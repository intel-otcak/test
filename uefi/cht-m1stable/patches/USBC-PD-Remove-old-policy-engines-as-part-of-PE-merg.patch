From d34bbb9002f551642bb9a92a276c6cc5588fd797 Mon Sep 17 00:00:00 2001
From: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
Date: Tue, 15 Dec 2015 16:50:03 +0530
Subject: [PATCH 5/8] USBC-PD: Remove old policy engines as part of PE merge.

With sink, source and display policies merged to single
policy engine, old policy file can be deleted.

Change-Id: I1c8a5bcbc0198b9a6f79ea91cbfac3ea167c75f7
Tracked-On: https://jira01.devtools.intel.com/browse/OAM-12097
Signed-off-by: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
Reviewed-on: https://android.intel.com:443/448854
---
 drivers/usb/typec/pd/Makefile        |    4 
 drivers/usb/typec/pd/display_pe.c    |  796 ----------------------
 drivers/usb/typec/pd/policy_engine.c |  916 -------------------------
 drivers/usb/typec/pd/policy_engine.h |    5 
 drivers/usb/typec/pd/sink_port_pe.c  | 1266 -----------------------------------
 drivers/usb/typec/pd/sink_port_pe.h  |  123 ---
 drivers/usb/typec/pd/src_port_pe.c   | 1046 ----------------------------
 7 files changed, 4156 deletions(-)
 delete mode 100644 drivers/usb/typec/pd/display_pe.c
 delete mode 100644 drivers/usb/typec/pd/policy_engine.c
 delete mode 100644 drivers/usb/typec/pd/sink_port_pe.c
 delete mode 100644 drivers/usb/typec/pd/sink_port_pe.h
 delete mode 100644 drivers/usb/typec/pd/src_port_pe.c

Index: b/drivers/usb/typec/pd/Makefile
===================================================================
--- a/drivers/usb/typec/pd/Makefile	2016-03-08 16:32:14.360850230 -0800
+++ b/drivers/usb/typec/pd/Makefile	2016-03-08 16:45:44.413281909 -0800
@@ -4,10 +4,6 @@
 
 pd_policy-y	:= devpolicy_mgr.o
 pd_policy-y	+= protocol.o
-pd_policy-y	+= policy_engine.o
-pd_policy-y	+= sink_port_pe.o
-pd_policy-y	+= src_port_pe.o
-pd_policy-y	+= display_pe.o
 
 obj-$(CONFIG_USBC_PD_POLICY)		+= pd_policy.o
 obj-$(CONFIG_USBC_SYSTEM_POLICY)	+= system_policy.o
Index: b/drivers/usb/typec/pd/display_pe.c
===================================================================
--- a/drivers/usb/typec/pd/display_pe.c	2016-03-08 16:45:44.413281909 -0800
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,796 +0,0 @@
-/*
- * src_port_pe.c: Intel USB Power Delivery Source Port Policy Engine
- *
- * Copyright (C) 2015 Intel Corporation
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Seee the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- * Author: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
- */
-
-#include <linux/slab.h>
-#include <linux/export.h>
-#include "message.h"
-#include "policy_engine.h"
-
-#define LOG_TAG "disp_pe"
-#define log_info(format, ...) \
-	pr_info(LOG_TAG":%s:"format, __func__, ##__VA_ARGS__)
-#define log_dbg(format, ...) \
-	pr_debug(LOG_TAG":%s:"format, __func__, ##__VA_ARGS__)
-#define log_err(format, ...) \
-	pr_err(LOG_TAG":%s:"format, __func__, ##__VA_ARGS__)
-#define log_warn(format, ...) \
-	pr_warn(LOG_TAG":%s:"format, __func__, ##__VA_ARGS__)
-
-#define MAX_CMD_RETRY	10
-#define CMD_NORESPONCE_TIME	1 /* 1 Sec */
-
-#define PD_SID          0xff00
-#define VESA_SVID       0xff01
-#define STRUCTURED_VDM	1
-
-/* Display port pin assignments */
-#define DISP_PORT_PIN_ASSIGN_A	(1 << 0)
-#define DISP_PORT_PIN_ASSIGN_B	(1 << 1)
-#define DISP_PORT_PIN_ASSIGN_C	(1 << 2)
-#define DISP_PORT_PIN_ASSIGN_D	(1 << 3)
-#define DISP_PORT_PIN_ASSIGN_E	(1 << 4)
-#define DISP_PORT_PIN_ASSIGN_F	(1 << 5)
-
-/* Display configuration */
-#define DISP_CONFIG_USB		0
-#define DISP_CONFIG_UFPU_AS_DFP_D	1
-#define DISP_CONFIG_UFPU_AS_UFP_D	2
-#define DISP_CONFIG_RESERVED		3
-
-/* Display port signaling for transport */
-#define DISP_PORT_SIGNAL_UNSPEC		0
-#define DISP_PORT_SIGNAL_DP_1P3		1
-#define DISP_PORT_SIGNAL_GEN2		2
-
-
-struct disp_port_caps {
-	int dmode_2x_index;
-	int dmode_4x_index;
-	bool usb_dev_support;
-	bool usb_host_support;
-	u8 pin_assign;
-};
-
-struct disp_port_pe {
-	struct mutex pe_lock;
-	struct policy p;
-	int state;
-	struct delayed_work start_comm;
-	int cmd_retry;
-	int dp_mode;
-	bool hpd_state;
-	struct disp_port_caps port_caps;
-};
-
-/* Source policy engine states */
-enum disp_pe_state {
-	DISP_PE_STATE_UNKNOWN = -1,
-	DISP_PE_STATE_NONE,
-	DISP_PE_STATE_DI_SENT,
-	DISP_PE_STATE_DI_GCRC,
-	DISP_PE_STATE_SVID_SENT,
-	DISP_PE_STATE_SVID_GCRC,
-	DISP_PE_STATE_DMODE_SENT,
-	DISP_PE_STATE_DMODE_GCRC,
-	DISP_PE_STATE_EMODE_SENT,
-	DISP_PE_STATE_EMODE_GCRC,
-	DISP_PE_STATE_EMODE_SUCCESS,
-	DISP_PE_STATE_DISPLAY_CONFIGURED,
-	DISP_PE_STATE_ALT_MODE_FAIL,
-};
-
-static void disp_pe_reset_policy_engine(struct disp_port_pe *disp_pe)
-{
-	cancel_delayed_work_sync(&disp_pe->start_comm);
-	mutex_lock(&disp_pe->pe_lock);
-	disp_pe->p.state = POLICY_STATE_OFFLINE;
-	disp_pe->p.status = POLICY_STATUS_UNKNOWN;
-	disp_pe->cmd_retry = 0;
-	disp_pe->dp_mode = TYPEC_DP_TYPE_NONE;
-	if (disp_pe->hpd_state) {
-		policy_set_dp_state(&disp_pe->p, CABLE_DETACHED,
-					TYPEC_DP_TYPE_NONE);
-		disp_pe->hpd_state = false;
-	}
-	disp_pe->state = DISP_PE_STATE_NONE;
-	/* Clear port caps */
-	memset(&disp_pe->port_caps, 0, sizeof(struct disp_port_caps));
-	mutex_unlock(&disp_pe->pe_lock);
-}
-
-static void disp_pe_do_protocol_reset(struct disp_port_pe *disp_pe)
-{
-	policy_send_packet(&disp_pe->p, NULL, 0, PD_CMD_PROTOCOL_RESET,
-				PE_EVT_SEND_PROTOCOL_RESET);
-}
-
-static void disp_pe_handle_dp_fail(struct disp_port_pe *disp_pe)
-{
-	log_info("DP failed\n");
-	cancel_delayed_work_sync(&disp_pe->start_comm);
-	mutex_lock(&disp_pe->pe_lock);
-	disp_pe->state = DISP_PE_STATE_ALT_MODE_FAIL;
-	disp_pe->p.status = POLICY_STATUS_FAIL;
-	mutex_unlock(&disp_pe->pe_lock);
-
-	/* Update the DP state to policy engine */
-	pe_notify_policy_status_changed(&disp_pe->p,
-			POLICY_TYPE_DISPLAY, PE_STATUS_CHANGE_DP_FAIL);
-
-}
-
-static int
-disp_pe_handle_gcrc(struct disp_port_pe *disp_pe, struct pd_packet *pkt)
-{
-	int ret = 0;
-
-	mutex_lock(&disp_pe->pe_lock);
-	switch (disp_pe->state) {
-	case DISP_PE_STATE_DI_SENT:
-		disp_pe->state = DISP_PE_STATE_DI_GCRC;
-		log_dbg("DISP_PE_STATE_DI_SENT -> DISP_PE_STATE_DI_GCRC\n");
-		break;
-	case DISP_PE_STATE_SVID_SENT:
-		disp_pe->state = DISP_PE_STATE_SVID_GCRC;
-		log_dbg("DISP_PE_STATE_SVID_SENT -> DISP_PE_STATE_SVID_GCRC\n");
-		break;
-	case DISP_PE_STATE_DMODE_SENT:
-		disp_pe->state = DISP_PE_STATE_DMODE_GCRC;
-		log_dbg("DISP_PE_STATE_DMODE_SENT -> DISP_PE_STATE_DMODE_GCRC\n");
-		break;
-	case DISP_PE_STATE_EMODE_SENT:
-		disp_pe->state = DISP_PE_STATE_EMODE_GCRC;
-		log_dbg("DISP_PE_STATE_EMODE_SENT -> DISP_PE_STATE_EMODE_GCRC\n");
-		break;
-	case DISP_PE_STATE_EMODE_SUCCESS:
-		log_dbg("State ->DISP_PE_STATE_EMODE_SUCCESS\n");
-		break;
-	default:
-		ret = -EINVAL;
-		log_dbg("GCRC received in wrong state=%d\n", disp_pe->state);
-	}
-	mutex_unlock(&disp_pe->pe_lock);
-	return ret;
-}
-
-
-static void disp_pe_prepare_vdm_header(struct pd_packet *pkt, enum vdm_cmd cmd,
-					int svid, int obj_pos)
-{
-	struct vdm_header *v_hdr = (struct vdm_header *) &pkt->data_obj[0];
-
-	memset(pkt, 0, sizeof(struct pd_packet));
-	v_hdr->cmd = cmd;
-	v_hdr->cmd_type = INITIATOR;
-	v_hdr->obj_pos = obj_pos;
-	v_hdr->str_vdm_version = 0x0; /* 0 = version 1.0 */
-	v_hdr->vdm_type = STRUCTURED_VDM; /* Structured VDM */
-	v_hdr->svid = svid;
-
-}
-
-static int disp_pe_send_discover_identity(struct disp_port_pe *disp_pe)
-{
-	struct pd_packet pkt;
-	int ret;
-
-	disp_pe_prepare_vdm_header(&pkt, DISCOVER_IDENTITY,
-						PD_SID, 0);
-	ret = policy_send_packet(&disp_pe->p, &pkt.data_obj[0], 4,
-				PD_DATA_MSG_VENDOR_DEF, PE_EVT_SEND_VDM);
-
-	return ret;
-}
-
-static int disp_pe_send_discover_identity_rnak(struct disp_port_pe *disp_pe)
-{
-	int ret;
-	struct vdm_header v_hdr = { 0 };
-
-	v_hdr.cmd = DISCOVER_IDENTITY;
-	v_hdr.cmd_type = REP_NACK;
-	v_hdr.vdm_type = STRUCTURED_VDM; /* Structured VDM */
-	v_hdr.svid = PD_SID;
-
-	ret = policy_send_packet(&disp_pe->p, &v_hdr, 4,
-				PD_DATA_MSG_VENDOR_DEF, PE_EVT_SEND_VDM);
-
-	return ret;
-}
-
-static int disp_pe_send_discover_svid(struct disp_port_pe *disp_pe)
-{
-	struct pd_packet pkt;
-	int ret;
-
-	disp_pe_prepare_vdm_header(&pkt, DISCOVER_SVID,
-						PD_SID, 0);
-	ret = policy_send_packet(&disp_pe->p, &pkt.data_obj[0], 4,
-				PD_DATA_MSG_VENDOR_DEF, PE_EVT_SEND_VDM);
-
-	return ret;
-}
-
-static int disp_pe_send_discover_mode(struct disp_port_pe *disp_pe, int svid)
-{
-	struct pd_packet pkt;
-	int ret;
-
-	disp_pe_prepare_vdm_header(&pkt, DISCOVER_MODE,
-						svid, 0);
-	ret = policy_send_packet(&disp_pe->p, &pkt.data_obj[0], 4,
-				PD_DATA_MSG_VENDOR_DEF, PE_EVT_SEND_VDM);
-
-	return ret;
-}
-
-static int disp_pe_send_enter_mode(struct disp_port_pe *disp_pe, int index)
-{
-	struct pd_packet pkt;
-	int ret;
-
-	disp_pe_prepare_vdm_header(&pkt, ENTER_MODE,
-						VESA_SVID, index);
-	ret = policy_send_packet(&disp_pe->p, &pkt.data_obj[0], 4,
-				PD_DATA_MSG_VENDOR_DEF, PE_EVT_SEND_VDM);
-
-	return ret;
-}
-
-static int disp_pe_send_display_configure(struct disp_port_pe *disp_pe)
-{
-	struct pd_packet pkt;
-	struct disp_config dconf;
-	int ret, index;
-
-
-	memset(&dconf, 0, sizeof(dconf));
-	dconf.conf_sel = DISP_CONFIG_UFPU_AS_UFP_D;
-	dconf.trans_sig = DISP_PORT_SIGNAL_DP_1P3;
-
-	if (disp_pe->dp_mode == TYPEC_DP_TYPE_2X) {
-		dconf.dfp_pin = DISP_PORT_PIN_ASSIGN_D;
-		index = disp_pe->port_caps.dmode_2x_index;
-
-	} else if (disp_pe->dp_mode == TYPEC_DP_TYPE_4X) {
-		if (disp_pe->port_caps.pin_assign
-				& DISP_PORT_PIN_ASSIGN_E)
-			dconf.dfp_pin = DISP_PORT_PIN_ASSIGN_E;
-
-		else if (disp_pe->port_caps.pin_assign
-				& DISP_PORT_PIN_ASSIGN_C)
-			dconf.dfp_pin = DISP_PORT_PIN_ASSIGN_C;
-		else {
-			log_err("Unknown 4X pin assign=%x\n",
-					disp_pe->port_caps.pin_assign);
-			ret = -EINVAL;
-			goto config_error;
-		}
-		index = disp_pe->port_caps.dmode_4x_index;
-
-	} else {
-		log_err("Invalid dp_mode=%d\n", disp_pe->dp_mode);
-		ret = -EINVAL;
-		goto config_error;
-	}
-
-	disp_pe_prepare_vdm_header(&pkt, DP_CONFIGURE,
-						VESA_SVID, index);
-	memcpy(&pkt.data_obj[1], &dconf, sizeof(dconf));
-
-	ret = policy_send_packet(&disp_pe->p, &pkt.data_obj[0], 8,
-				PD_DATA_MSG_VENDOR_DEF, PE_EVT_SEND_VDM);
-
-config_error:
-	return ret;
-}
-
-static int disp_pe_handle_discover_identity(struct disp_port_pe *disp_pe,
-							struct pd_packet *pkt)
-{
-	struct vdm_header *vdm_hdr = (struct vdm_header *)&pkt->data_obj[0];
-
-	switch (vdm_hdr->cmd_type) {
-	case INITIATOR:
-		log_warn("UFP alternate mode not supported, Sending NAK\n");
-		disp_pe_send_discover_identity_rnak(disp_pe);
-		break;
-	case REP_ACK:
-		if ((disp_pe->state != DISP_PE_STATE_DI_SENT)
-			&& (disp_pe->state != DISP_PE_STATE_DI_GCRC)) {
-			log_warn("DI RACK received in wrong state,state=%d\n",
-					disp_pe->state);
-			break;
-		}
-		disp_pe_send_discover_svid(disp_pe);
-		mutex_lock(&disp_pe->pe_lock);
-		disp_pe->state = DISP_PE_STATE_SVID_SENT;
-		mutex_unlock(&disp_pe->pe_lock);
-		log_dbg(" State -> DISP_PE_STATE_SVID_SENT\n");
-		break;
-	case REP_NACK:
-		log_err("Responder doesn't support alternate mode\n");
-		disp_pe_handle_dp_fail(disp_pe);
-		break;
-	case REP_BUSY:
-		break;
-	}
-	return 0;
-}
-
-
-static int disp_pe_handle_discover_svid(struct disp_port_pe *disp_pe,
-			struct pd_packet *pkt)
-{
-	struct dis_svid_response_pkt *svid_pkt;
-	int num_modes = 0;
-	int i, mode = 0;
-
-	svid_pkt = (struct dis_svid_response_pkt *)pkt;
-
-	switch (svid_pkt->vdm_hdr.cmd_type) {
-	case INITIATOR:
-		log_warn("UFP alternate mode not supported\n");
-		break;
-	case REP_ACK:
-		if ((disp_pe->state != DISP_PE_STATE_SVID_SENT)
-			&& (disp_pe->state != DISP_PE_STATE_SVID_GCRC)) {
-			log_warn("SVID RACK received in wrong state=%d\n",
-					disp_pe->state);
-			break;
-		}
-		/* 2 modes per VDO*/
-		num_modes = (svid_pkt->msg_hdr.num_data_obj - 1) * 2;
-		log_dbg("SVID_ACK-> This Display supports %d modes\n",
-				num_modes);
-		for (i = 0; i < num_modes; i++) {
-			log_dbg("vdo[%d].svid0=0x%x, svid1=0x%x\n",
-				i, svid_pkt->vdo[i].svid0,
-				svid_pkt->vdo[i].svid1);
-			if ((svid_pkt->vdo[i].svid0 == VESA_SVID)
-				|| (svid_pkt->vdo[i].svid1 == VESA_SVID)) {
-				mode = VESA_SVID;
-				break;
-			}
-		}
-		/* Currently we support only VESA */
-		if (mode == VESA_SVID) {
-			log_dbg("This Display supports VESA\n");
-			disp_pe_send_discover_mode(disp_pe, VESA_SVID);
-			mutex_lock(&disp_pe->pe_lock);
-			disp_pe->state = DISP_PE_STATE_DMODE_SENT;
-			mutex_unlock(&disp_pe->pe_lock);
-			log_dbg("State-> DISP_PE_STATE_DMODE_SENT\n");
-			break;
-		} else
-			log_err("This Display doesn't supports VESA\n");
-		/* Stop the display detection process */
-	case REP_NACK:
-		log_warn("Responder doesn't support alternate mode\n");
-		disp_pe_handle_dp_fail(disp_pe);
-		break;
-	case REP_BUSY:
-		log_info("Responder BUSY!!. Retry Discover SVID\n");
-		/*TODO: Retry the Discover SVID */
-		break;
-	}
-	return 0;
-}
-
-static void disp_pe_process_dp_modes(struct disp_port_pe *disp_pe,
-			struct dis_mode_response_pkt *dmode_pkt)
-{
-	int i;
-	int index_2x = 0;
-	int index_4x = 0;
-
-	for (i = 0; i < dmode_pkt->msg_hdr.num_data_obj - 1; i++) {
-		if (!index_4x) {
-			if (dmode_pkt->mode[i].ufp_pin
-					& DISP_PORT_PIN_ASSIGN_E
-				|| dmode_pkt->mode[i].dfp_pin
-					& DISP_PORT_PIN_ASSIGN_E) {
-				/* Mode intex starts from 1 */
-				index_4x = i + 1;
-				disp_pe->port_caps.pin_assign |=
-					DISP_PORT_PIN_ASSIGN_E;
-				log_dbg("Port supports Pin Assign E\n");
-			}
-			if (dmode_pkt->mode[i].ufp_pin
-					& DISP_PORT_PIN_ASSIGN_C
-				|| dmode_pkt->mode[i].dfp_pin
-					& DISP_PORT_PIN_ASSIGN_C) {
-				/* Mode intex starts from 1 */
-				index_4x = i + 1;
-				disp_pe->port_caps.pin_assign |=
-					DISP_PORT_PIN_ASSIGN_C;
-				log_dbg("Port supports Pin Assign C\n");
-			}
-		}
-		if (!index_2x) {
-			if (dmode_pkt->mode[i].ufp_pin
-					& DISP_PORT_PIN_ASSIGN_D
-				|| dmode_pkt->mode[i].dfp_pin
-					& DISP_PORT_PIN_ASSIGN_D) {
-				/* Mode intex starts from 1 */
-				index_2x = i + 1;
-				disp_pe->port_caps.pin_assign |=
-					DISP_PORT_PIN_ASSIGN_D;
-				log_dbg("Port supports Pin Assign D\n");
-			}
-		}
-		if (index_2x && index_4x)
-			break;
-	}
-	disp_pe->port_caps.dmode_4x_index = index_4x;
-	disp_pe->port_caps.dmode_2x_index = index_2x;
-}
-
-static int disp_pe_handle_discover_mode(struct disp_port_pe *disp_pe,
-			struct pd_packet *pkt)
-{
-	struct dis_mode_response_pkt *dmode_pkt;
-
-	dmode_pkt = (struct dis_mode_response_pkt *)pkt;
-
-	switch (dmode_pkt->vdm_hdr.cmd_type) {
-	case INITIATOR:
-		log_warn("UFP alternate mode not supported\n");
-		break;
-	case REP_ACK:
-		if ((disp_pe->state != DISP_PE_STATE_DMODE_SENT)
-			&& (disp_pe->state != DISP_PE_STATE_DMODE_GCRC)) {
-			log_warn("DiscMode RACK received in wrong state=%d\n",
-					disp_pe->state);
-			break;
-		}
-
-		disp_pe_process_dp_modes(disp_pe, dmode_pkt);
-		/* First check for 2X, Mode D */
-		log_dbg("4x_index=%d, 2x_index=%d\n",
-				disp_pe->port_caps.dmode_4x_index,
-				disp_pe->port_caps.dmode_2x_index);
-		if (disp_pe->port_caps.dmode_2x_index) {
-			disp_pe_send_enter_mode(disp_pe,
-				disp_pe->port_caps.dmode_2x_index);
-			mutex_lock(&disp_pe->pe_lock);
-			disp_pe->state = DISP_PE_STATE_EMODE_SENT;
-			disp_pe->dp_mode = TYPEC_DP_TYPE_2X;
-			mutex_unlock(&disp_pe->pe_lock);
-			log_dbg("State -> DISP_PE_STATE_EMODE_SENT\n");
-			break;
-
-		} else if (disp_pe->port_caps.dmode_4x_index) {
-			disp_pe_send_enter_mode(disp_pe,
-					disp_pe->port_caps.dmode_4x_index);
-			mutex_lock(&disp_pe->pe_lock);
-			disp_pe->state = DISP_PE_STATE_EMODE_SENT;
-			disp_pe->dp_mode = TYPEC_DP_TYPE_4X;
-			mutex_unlock(&disp_pe->pe_lock);
-			log_dbg("State -> DISP_PE_STATE_EMODE_SENT\n");
-			break;
-		} else
-			log_warn("This Display doesn't supports neither 2X nor 4X\n");
-		/* Stop the display detection process */
-
-	case REP_NACK:
-		log_warn("Responder doesn't support alternate mode\n");
-		disp_pe_handle_dp_fail(disp_pe);
-		break;
-	case REP_BUSY:
-		log_warn("Responder BUSY!!. Retry Discover SVID\n");
-		/*TODO: Retry the Discover SVID */
-		break;
-	}
-	return 0;
-}
-
-
-static int disp_pe_handle_enter_mode(struct disp_port_pe *disp_pe,
-			struct pd_packet *pkt)
-{
-	struct vdm_header *vdm_hdr = (struct vdm_header *)&pkt->data_obj[0];
-
-	switch (vdm_hdr->cmd_type) {
-	case INITIATOR:
-		log_warn("UFP alternate mode not supported\n");
-		break;
-	case REP_ACK:
-		if ((disp_pe->state != DISP_PE_STATE_EMODE_SENT)
-			&& (disp_pe->state != DISP_PE_STATE_EMODE_GCRC)) {
-			log_warn("EnterMode ACK received in wrong state=%d\n",
-					disp_pe->state);
-			break;
-		}
-		mutex_lock(&disp_pe->pe_lock);
-		disp_pe->state = DISP_PE_STATE_EMODE_SUCCESS;
-		mutex_unlock(&disp_pe->pe_lock);
-		log_dbg("State -> DISP_PE_STATE_EMODE_SUCCESS, dp_mode=%d\n",
-				disp_pe->dp_mode);
-		disp_pe_send_display_configure(disp_pe);
-		break;
-	case REP_NACK:
-		log_warn("Display falied to enter dp mode %d\n",
-			disp_pe->dp_mode);
-		disp_pe_handle_dp_fail(disp_pe);
-	}
-	return 0;
-}
-
-static int disp_pe_handle_display_configure(struct disp_port_pe *disp_pe,
-			struct pd_packet *pkt)
-{
-	struct vdm_header *vdm_hdr = (struct vdm_header *)&pkt->data_obj[0];
-
-	switch (vdm_hdr->cmd_type) {
-	case INITIATOR:
-		log_warn("UFP alternate mode not supported\n");
-		break;
-	case REP_ACK:
-		if (disp_pe->state != DISP_PE_STATE_EMODE_SUCCESS) {
-			log_warn("Config ACK received in wrong state=%d\n",
-					disp_pe->state);
-			break;
-		}
-		mutex_lock(&disp_pe->pe_lock);
-		disp_pe->state = DISP_PE_STATE_DISPLAY_CONFIGURED;
-		disp_pe->p.status = POLICY_STATUS_SUCCESS;
-		mutex_unlock(&disp_pe->pe_lock);
-		log_info("DISP_PE_STATE_DISPLAY_CONFIGURED,dp_mode=%d\n",
-				disp_pe->dp_mode);
-		disp_pe->hpd_state = true;
-		policy_set_dp_state(&disp_pe->p, CABLE_ATTACHED,
-					disp_pe->dp_mode);
-		/* Update the DP state to policy engine */
-		pe_notify_policy_status_changed(&disp_pe->p,
-			POLICY_TYPE_DISPLAY, PE_STATUS_CHANGE_DP_SUCCESS);
-		break;
-	case REP_NACK:
-		log_warn("NAK for display config cmd %d\n", disp_pe->dp_mode);
-		disp_pe_handle_dp_fail(disp_pe);
-	}
-	return 0;
-}
-
-static int disp_pe_handle_display_attention(struct disp_port_pe *disp_pe,
-		struct pd_packet *pkt)
-{
-	struct dis_port_status *dstat;
-	bool hpd;
-
-	dstat = (struct dis_port_status *) &pkt->data_obj[1];
-	log_info("hpd_status=%d\n", dstat->hpd_state);
-	hpd = dstat->hpd_state;
-
-	/* Some dp cable which doesnt suport status update cmd
-	 * which is expected after EnterMode. Due to this the hpd
-	 * status cannot be known after EnterMode. To fix this by
-	 * default hpd will be triggered after EnterMode.
-	 * So, if previous hpd is true then send diconnect and connect.
-	 */
-	if (hpd && disp_pe->hpd_state) {
-		policy_set_dp_state(&disp_pe->p, CABLE_DETACHED,
-					TYPEC_DP_TYPE_NONE);
-	}
-	disp_pe->hpd_state = hpd;
-	if (hpd)
-		policy_set_dp_state(&disp_pe->p, CABLE_ATTACHED,
-					disp_pe->dp_mode);
-	else
-		policy_set_dp_state(&disp_pe->p, CABLE_DETACHED,
-					TYPEC_DP_TYPE_NONE);
-
-	return 0;
-}
-
-static int disp_pe_handle_vendor_msg(struct disp_port_pe *disp_pe,
-		struct pd_packet *pkt)
-{
-	struct vdm_header *vdm_hdr = (struct vdm_header *)&pkt->data_obj[0];
-	int ret = 0;
-
-	switch (vdm_hdr->cmd) {
-	case DISCOVER_IDENTITY:
-		ret = disp_pe_handle_discover_identity(disp_pe, pkt);
-		break;
-	case DISCOVER_SVID:
-		ret = disp_pe_handle_discover_svid(disp_pe, pkt);
-		break;
-	case DISCOVER_MODE:
-		ret = disp_pe_handle_discover_mode(disp_pe, pkt);
-		break;
-	case ENTER_MODE:
-		ret = disp_pe_handle_enter_mode(disp_pe, pkt);
-		break;
-	case EXIT_MODE:
-		log_dbg("EXIT DP mode request received\n");
-		/* TODO: Handle the exit mode */
-		break;
-	case DP_CONFIGURE:
-		ret = disp_pe_handle_display_configure(disp_pe, pkt);
-		break;
-	/* DP_STATUS_UPDATE and ATTENTION has same status vdo*/
-	case DP_STATUS_UPDATE:
-	case ATTENTION:
-		ret = disp_pe_handle_display_attention(disp_pe, pkt);
-		break;
-	default:
-		ret = -EINVAL;
-		log_err("Not a valid vendor msg to handle\n");
-	}
-	return ret;
-}
-
-
-static int
-disp_pe_rcv_pkt(struct policy *p, struct pd_packet *pkt, enum pe_event evt)
-{
-	struct disp_port_pe *disp_pe = container_of(p,
-					struct disp_port_pe, p);
-	int ret = 0;
-
-	switch (evt) {
-	case PE_EVT_RCVD_GOODCRC:
-		disp_pe_handle_gcrc(disp_pe, pkt);
-		break;
-	case PE_EVT_RCVD_VDM:
-		disp_pe_handle_vendor_msg(disp_pe, pkt);
-		break;
-	default:
-		ret = -EINVAL;
-		log_warn("Not proccessing the event=%d\n", evt);
-	}
-	return ret;
-}
-
-int disp_pe_rcv_cmd(struct policy *p, enum pe_event evt)
-{
-	struct disp_port_pe *disp_pe = container_of(p,
-					struct disp_port_pe, p);
-	int ret = 0;
-
-	log_dbg("Received command, event=%d\n", evt);
-	switch (evt) {
-	case PE_EVT_RCVD_HARD_RESET:
-	case PE_EVT_RCVD_HARD_RESET_COMPLETE:
-		disp_pe_reset_policy_engine(disp_pe);
-	default:
-		ret = EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-
-static void disp_pe_start_comm(struct work_struct *work)
-{
-	struct disp_port_pe *disp_pe = container_of(work,
-					struct disp_port_pe,
-					start_comm.work);
-
-	if ((disp_pe->state == DISP_PE_STATE_ALT_MODE_FAIL)
-		|| (disp_pe->state == DISP_PE_STATE_DISPLAY_CONFIGURED)) {
-		log_dbg("Not required to send DI in this state=%d\n",
-				disp_pe->state);
-		return;
-	}
-
-	if (disp_pe->cmd_retry > 0)
-		disp_pe_do_protocol_reset(disp_pe);
-
-	log_info(" Sending DI\n");
-	mutex_lock(&disp_pe->pe_lock);
-	disp_pe->state = DISP_PE_STATE_DI_SENT;
-	mutex_unlock(&disp_pe->pe_lock);
-	disp_pe_send_discover_identity(disp_pe);
-
-	disp_pe->cmd_retry++;
-	if (disp_pe->cmd_retry < MAX_CMD_RETRY) {
-		log_dbg("Re-scheduling the start_comm after %dSec\n",
-				CMD_NORESPONCE_TIME);
-		/* Retry display identity if dp command sequence
-		 * failed/no responce with in CMD_NORESPONCE_TIME.
-		 */
-		schedule_delayed_work(&disp_pe->start_comm,
-					HZ * CMD_NORESPONCE_TIME);
-	} else {
-		log_warn("Not scheduling DI worker as max re-try reached\n");
-		disp_pe_handle_dp_fail(disp_pe);
-	}
-}
-
-static int disp_pe_start_policy_engine(struct policy *p)
-{
-	struct disp_port_pe *disp_pe = container_of(p,
-					struct disp_port_pe, p);
-	enum data_role drole;
-
-	log_dbg("IN");
-	mutex_lock(&disp_pe->pe_lock);
-	p->state = POLICY_STATE_ONLINE;
-	disp_pe->cmd_retry = 0;
-
-	/* Start DI only in host mode*/
-	drole = policy_get_data_role(p);
-	if (drole == DATA_ROLE_DFP)
-		schedule_delayed_work(&disp_pe->start_comm, 0);
-
-	mutex_unlock(&disp_pe->pe_lock);
-	return 0;
-}
-
-static int disp_pe_stop_policy_engine(struct policy *p)
-{
-	struct disp_port_pe *disp_pe = container_of(p,
-					struct disp_port_pe, p);
-
-	log_dbg("IN");
-	disp_pe_reset_policy_engine(disp_pe);
-
-	return 0;
-}
-
-static void disp_pe_exit(struct policy *p)
-{
-	struct disp_port_pe *disp_pe = container_of(p,
-					struct disp_port_pe, p);
-
-	kfree(disp_pe);
-}
-
-/* Init function to initialize the source policy engine */
-struct policy *disp_pe_init(struct policy_engine *pe)
-{
-	struct disp_port_pe *disp_pe;
-	struct policy *p;
-
-	if (!pe)
-		return ERR_PTR(-EINVAL);
-
-	disp_pe = kzalloc(sizeof(struct disp_port_pe),
-						GFP_KERNEL);
-	if (!disp_pe) {
-		log_err("mem alloc failed\n");
-		return ERR_PTR(-ENOMEM);
-	}
-
-	mutex_init(&disp_pe->pe_lock);
-	INIT_DELAYED_WORK(&disp_pe->start_comm, disp_pe_start_comm);
-
-	p = &disp_pe->p;
-	p->type = POLICY_TYPE_DISPLAY;
-	p->state = POLICY_STATE_OFFLINE;
-	p->status = POLICY_STATUS_UNKNOWN;
-	p->pe = pe;
-
-	p->rcv_pkt = disp_pe_rcv_pkt;
-	p->rcv_cmd = disp_pe_rcv_cmd;
-	p->start  = disp_pe_start_policy_engine;
-	p->stop = disp_pe_stop_policy_engine;
-	p->exit = disp_pe_exit;
-
-	log_info("Display pe initialized successfuly");
-	return p;
-}
-EXPORT_SYMBOL_GPL(disp_pe_init);
Index: b/drivers/usb/typec/pd/policy_engine.c
===================================================================
--- a/drivers/usb/typec/pd/policy_engine.c	2016-03-08 16:32:19.340901718 -0800
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,916 +0,0 @@
-/*
- * policy_engine.c: Intel USB Power Delivery Policy Engine Driver
- *
- * Copyright (C) 2015 Intel Corporation
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Seee the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- * Author: Albin B <albin.bala.krishnan@intel.com>
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/notifier.h>
-#include <linux/err.h>
-#include <linux/power_supply.h>
-#include <linux/delay.h>
-#include <linux/usb_typec_phy.h>
-#include <linux/random.h>
-#include "policy_engine.h"
-
-static void pe_dump_header(struct pd_pkt_header *header);
-static void pe_dump_data_msg(struct pd_packet *pkt);
-
-static inline
-struct policy *pe_get_active_src_or_snk_policy(struct list_head *head)
-{
-	struct policy *p = NULL;
-
-	list_for_each_entry(p, head, list) {
-		if (p && ((p->type == POLICY_TYPE_SINK)
-			|| (p->type == POLICY_TYPE_SOURCE))) {
-			if (p->state == POLICY_STATE_ONLINE)
-				return p;
-		}
-	}
-
-	return NULL;
-}
-
-static inline
-struct policy *pe_get_running_policy(struct list_head *head)
-{
-	struct policy *p = NULL;
-
-	list_for_each_entry(p, head, list) {
-		if (p && p->state == POLICY_STATE_ONLINE)
-				return p;
-	}
-
-	return NULL;
-}
-
-static inline bool pe_is_policy_active(struct policy *p)
-{
-	return (p->state == POLICY_STATE_ONLINE) ? true : false;
-}
-
-static inline bool pe_is_policy_running(struct policy *p)
-{
-	return (p->status == POLICY_STATUS_RUNNING) ? true : false;
-}
-
-static struct policy *pe_get_policy(struct policy_engine *pe,
-					enum policy_type type)
-{
-	struct policy *p = NULL;
-
-	list_for_each_entry(p, &pe->policy_list, list) {
-		if (p && (p->type == type))
-			return p;
-	}
-	return NULL;
-}
-
-static int policy_engine_process_data_msg(struct policy_engine *pe,
-				enum pe_event evt, struct pd_packet *pkt)
-{
-	struct policy *p = NULL;
-	int ret = 0;
-
-	pr_debug("PE: %s Data msg received evt - %d\n", __func__, evt);
-	switch (evt) {
-	case PE_EVT_RCVD_SRC_CAP:
-	case PE_EVT_RCVD_REQUEST:
-	case PE_EVT_RCVD_BIST:
-	case PE_EVT_RCVD_SNK_CAP:
-		p = pe_get_active_src_or_snk_policy(&pe->policy_list);
-		break;
-	case PE_EVT_RCVD_VDM:
-		p = pe_get_policy(pe, POLICY_TYPE_DISPLAY);
-		if (!p) {
-			pr_err("PE: No display pe to forward VDM msgs\n");
-			break;
-		}
-		if (!pe_is_policy_active(p)) {
-			pr_err("PE: DispPE not active to forward VDM msgs\n");
-			p = NULL;
-		}
-		break;
-	default:
-		pr_warn("PE: %s invalid data msg, event=%d\n", __func__, evt);
-		pe_dump_data_msg(pkt);
-	}
-
-	if (p && p->rcv_pkt)
-		ret = p->rcv_pkt(p, pkt, evt);
-	else
-		ret = -ENODEV;
-	return ret;
-}
-
-static int policy_engine_process_ctrl_msg(struct policy_engine *pe,
-				enum pe_event evt, struct pd_packet *pkt)
-{
-	struct policy *p = NULL;
-	int ret = 0;
-
-	pr_debug("PE: %s Ctrl msg received evt - %d\n", __func__, evt);
-	switch (evt) {
-	case PE_EVT_RCVD_GOODCRC:
-		p = pe_get_running_policy(&pe->policy_list);
-		if (!p)
-			pr_err("PE: No running policy to forward GCRC msgs\n");
-		break;
-	case PE_EVT_RCVD_GOTOMIN:
-	case PE_EVT_RCVD_ACCEPT:
-	case PE_EVT_RCVD_REJECT:
-	case PE_EVT_RCVD_PING:
-	case PE_EVT_RCVD_PS_RDY:
-	case PE_EVT_RCVD_GET_SRC_CAP:
-	case PE_EVT_RCVD_GET_SINK_CAP:
-	case PE_EVT_RCVD_DR_SWAP:
-	case PE_EVT_RCVD_PR_SWAP:
-	case PE_EVT_RCVD_VCONN_SWAP:
-	case PE_EVT_RCVD_WAIT:
-		p = pe_get_active_src_or_snk_policy(&pe->policy_list);
-		if (!p)
-			pr_err("PE: No active policy to forward Ctrl msgs\n");
-		break;
-	default:
-		pr_warn("PE: %s Not a valid ctrl msg to process, event=%d\n",
-				__func__, evt);
-		pe_dump_header(&pkt->header);
-	}
-	if (p && p->rcv_pkt)
-		ret = p->rcv_pkt(p, pkt, evt);
-	else
-		ret = -ENODEV;
-	return ret;
-}
-
-static void pe_dump_header(struct pd_pkt_header *header)
-{
-#ifdef DBG
-	if (!header) {
-		pr_err("PE: No Header information available...\n");
-		return;
-	}
-	pr_info("========== POLICY ENGINE: HEADER INFO ==========\n");
-	pr_info("PE: Message Type - 0x%x\n", header->msg_type);
-	pr_info("PE: Reserved B4 - 0x%x\n", header->rsvd_a);
-	pr_info("PE: Port Data Role - 0x%x\n", header->data_role);
-	pr_info("PE: Specification Revision - 0x%x\n", header->rev_id);
-	pr_info("PE: Port Power Role - 0x%x\n", header->pwr_role);
-	pr_info("PE: Message ID - 0x%x\n", header->msg_id);
-	pr_info("PE: Number of Data Objects - 0x%x\n", header->num_data_obj);
-	pr_info("PE: Reserved B15 - 0x%x\n", header->rsvd_b);
-	pr_info("=============================================");
-#endif /* DBG */
-}
-
-static void pe_dump_data_msg(struct pd_packet *pkt)
-{
-#ifdef DBG
-	int num_data_objs = PD_MSG_NUM_DATA_OBJS(&pkt->header);
-	unsigned int data_buf[num_data_objs];
-	int i;
-
-	memset(data_buf, 0, num_data_objs);
-	memcpy(data_buf, &pkt->data_obj, PD_MSG_LEN(&pkt->header));
-
-	for (i = 0; i < num_data_objs; i++) {
-		pr_info("PE: Data Message - data[%d]: 0x%08x\n",
-					i+1, data_buf[i]);
-	}
-#endif /* DBG */
-}
-
-static int pe_fwdcmd_to_policy(struct policy_engine *pe, enum pe_event evt)
-{
-	struct policy *p;
-	int ret = 0;
-
-	p = pe_get_active_src_or_snk_policy(&pe->policy_list);
-
-	if (p && p->rcv_cmd)
-		p->rcv_cmd(p, evt);
-
-	p = pe_get_policy(pe, POLICY_TYPE_DISPLAY);
-	if (p && p->rcv_cmd)
-		p->rcv_cmd(p, evt);
-
-	return ret;
-}
-
-static int policy_engine_process_cmd(struct policy_engine *pe,
-				enum pe_event evt)
-{
-	int ret = 0;
-
-	pr_debug("PE: %s - cmd %d\n", __func__, evt);
-	switch (evt) {
-	case PE_EVT_RCVD_HARD_RESET:
-	case PE_EVT_RCVD_HARD_RESET_COMPLETE:
-		ret = pe_fwdcmd_to_policy(pe, evt);
-		if (ret < 0)
-			pr_err("PE: Error in handling cmd\n");
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-static inline void policy_prot_update_data_role(struct policy_engine *pe,
-				enum data_role drole)
-{
-	if (pe && pe->prot && pe->prot->policy_update_data_role)
-		pe->prot->policy_update_data_role(pe->prot, drole);
-}
-
-static inline void policy_prot_update_power_role(struct policy_engine *pe,
-				enum pwr_role prole)
-{
-	if (pe && pe->prot && pe->prot->policy_update_power_role)
-		pe->prot->policy_update_power_role(pe->prot, prole);
-}
-
-static int pe_get_srcpwr_cap(struct policy_engine *pe,
-					struct power_cap *cap)
-{
-	if (pe && pe->dpm)
-		return devpolicy_get_srcpwr_cap(pe->dpm, cap);
-
-	return -ENODEV;
-}
-
-static int pe_get_snkpwr_cap(struct policy_engine *pe,
-					struct power_cap *cap)
-{
-	if (pe && pe->dpm)
-		return devpolicy_get_snkpwr_cap(pe->dpm, cap);
-
-	return -ENODEV;
-}
-
-static int pe_get_snkpwr_caps(struct policy_engine *pe,
-					struct power_caps *caps)
-{
-	if (pe && pe->dpm)
-		return devpolicy_get_snkpwr_caps(pe->dpm, caps);
-
-	return -ENODEV;
-}
-
-static int pe_get_max_snkpwr_cap(struct policy_engine *pe,
-					struct power_cap *cap)
-{
-	if (pe && pe->dpm)
-		return devpolicy_get_max_snkpwr_cap(pe->dpm, cap);
-
-	return -ENODEV;
-}
-
-static enum data_role pe_get_data_role(struct policy_engine *pe)
-{
-	enum data_role drole;
-
-	mutex_lock(&pe->pe_lock);
-	drole = pe->cur_drole;
-	mutex_unlock(&pe->pe_lock);
-	return drole;
-}
-
-static enum pwr_role pe_get_power_role(struct policy_engine *pe)
-{
-	enum pwr_role prole;
-
-	mutex_lock(&pe->pe_lock);
-	prole = pe->cur_prole;
-	mutex_unlock(&pe->pe_lock);
-	return prole;
-}
-
-static int pe_set_data_role(struct policy_engine *pe, enum data_role role)
-{
-	mutex_lock(&pe->pe_lock);
-	if (pe->cur_drole == role)
-		goto set_drole_out;
-
-	pe->cur_drole = role;
-	policy_dpm_update_data_role(pe, role);
-	/* If role swap, no need to update protocol */
-	if (role != DATA_ROLE_SWAP) {
-		/* Update the protocol */
-		policy_prot_update_data_role(pe, role);
-	}
-
-set_drole_out:
-	mutex_unlock(&pe->pe_lock);
-	return 0;
-}
-
-static int pe_set_power_role(struct policy_engine *pe, enum pwr_role role)
-{
-	mutex_lock(&pe->pe_lock);
-	if (pe->cur_prole == role)
-		goto set_prole_out;
-
-	pe->cur_prole = role;
-	policy_dpm_update_power_role(pe, role);
-	/* If role swap, no need to update protocol */
-	if (role != POWER_ROLE_SWAP) {
-		/* Update the protocol */
-		policy_prot_update_power_role(pe, role);
-	}
-
-set_prole_out:
-	mutex_unlock(&pe->pe_lock);
-	return 0;
-}
-
-static int pe_set_charger_mode(struct policy_engine *pe, enum charger_mode mode)
-{
-	if (pe && pe->dpm)
-		return devpolicy_set_charger_mode(pe->dpm, mode);
-
-	return -ENODEV;
-}
-
-static int pe_update_charger(struct policy_engine *pe, int ilim, int query)
-{
-	if (pe && pe->dpm)
-		return devpolicy_update_charger(pe->dpm, ilim, query);
-
-	return -ENODEV;
-}
-
-static int pe_get_min_snk_current(struct policy_engine *pe, int *ma)
-{
-	if (pe && pe->dpm)
-		return devpolicy_get_min_snk_current(pe->dpm, ma);
-
-	return -ENODEV;
-}
-
-static int pe_is_pr_swap_support(struct policy_engine *pe, enum pwr_role prole)
-{
-	if (pe && pe->dpm)
-		return devpolicy_is_pr_swap_support(pe->dpm, prole);
-
-	return -ENODEV;
-}
-
-static enum cable_state pe_get_cable_state(struct policy_engine *pe,
-						enum cable_type type)
-{
-	if (pe && pe->dpm)
-		return devpolicy_get_cable_state(pe->dpm, type);
-
-	return -ENODEV;
-}
-
-static bool pe_get_pd_state(struct policy_engine *pe)
-{
-	return pe->is_pd_connected;
-}
-
-static int pe_set_pd_state(struct policy_engine *pe, bool state)
-{
-	mutex_lock(&pe->pe_lock);
-	pe->is_pd_connected = state;
-	mutex_unlock(&pe->pe_lock);
-	return 0;
-}
-
-static int pe_start_policy(struct policy_engine *pe, enum policy_type type)
-
-{
-	struct policy *p;
-
-	p = pe_get_policy(pe, type);
-	if (!p) {
-		pr_err("PE: Unable to get %d policy\n", type);
-		return -ENODEV;
-	}
-
-	if (p->state != POLICY_STATE_ONLINE)
-		p->start(p);
-	else
-		pr_warn("PE: policy %d is already active!!!\n", type);
-
-	return 0;
-}
-
-static int pe_stop_policy(struct policy_engine *pe, enum policy_type type)
-
-{
-	struct policy *p;
-
-	p = pe_get_policy(pe, type);
-	if (!p) {
-		pr_err("PE: Unable to get %d policy\n", type);
-		return -ENODEV;
-	}
-
-	if (p->state == POLICY_STATE_ONLINE)
-		p->stop(p);
-	else {
-		pr_warn("PE: policy %d is not active!!!\n", type);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int pe_switch_policy(struct policy_engine *pe,
-				enum policy_type start_policy_type)
-{
-	enum policy_type stop_policy_type;
-	int ret;
-
-	if (start_policy_type == POLICY_TYPE_SOURCE)
-		stop_policy_type =  POLICY_TYPE_SINK;
-	else if (start_policy_type == POLICY_TYPE_SINK)
-		stop_policy_type = POLICY_TYPE_SOURCE;
-	else
-		return -EINVAL;
-
-	ret = pe_stop_policy(pe, stop_policy_type);
-	if (ret < 0)
-		return ret;
-
-	return pe_start_policy(pe, start_policy_type);
-}
-
-static int pe_send_packet(struct policy_engine *pe, void *data, int len,
-				u8 msg_type, enum pe_event evt)
-{
-	int ret = 0;
-
-	if (!pe_get_pd_state(pe) && evt != PE_EVT_SEND_HARD_RESET) {
-		pr_debug("PE:%s: Not sending pkt, evt=%d\n", __func__, evt);
-		ret = -EINVAL;
-		goto snd_pkt_err;
-	}
-
-	switch (evt) {
-	case PE_EVT_SEND_GOTOMIN:
-	case PE_EVT_SEND_ACCEPT:
-	case PE_EVT_SEND_REJECT:
-	case PE_EVT_SEND_PING:
-	case PE_EVT_SEND_PS_RDY:
-	case PE_EVT_SEND_GET_SRC_CAP:
-	case PE_EVT_SEND_GET_SINK_CAP:
-	case PE_EVT_SEND_DR_SWAP:
-	case PE_EVT_SEND_PR_SWAP:
-	case PE_EVT_SEND_VCONN_SWAP:
-	case PE_EVT_SEND_WAIT:
-	case PE_EVT_SEND_SRC_CAP:
-	case PE_EVT_SEND_REQUEST:
-	case PE_EVT_SEND_BIST:
-	case PE_EVT_SEND_SNK_CAP:
-	case PE_EVT_SEND_VDM:
-	case PE_EVT_SEND_HARD_RESET:
-	case PE_EVT_SEND_PROTOCOL_RESET:
-	case PE_EVT_SEND_SOFT_RESET:
-		break;
-	default:
-		ret = -EINVAL;
-		goto snd_pkt_err;
-	}
-
-	/* Send the pd_packet to protocol directly to request
-	 * sink power cap */
-	pr_debug("PE:%s: Sending pkt, evt=%d\n", __func__, evt);
-	if (pe && pe->prot && pe->prot->policy_fwd_pkt)
-		pe->prot->policy_fwd_pkt(pe->prot, msg_type, data, len);
-
-snd_pkt_err:
-	return ret;
-}
-
-static struct policy *__pe_find_policy(struct list_head *list,
-						enum policy_type type)
-{
-	struct policy  *p = NULL;
-
-	list_for_each_entry(p, list, list) {
-		if (p && p->type != type)
-			continue;
-		return p;
-	}
-
-	return NULL;
-}
-
-static void pe_policy_status_changed(struct policy_engine *pe,
-				enum policy_type ptype,
-				enum pe_status_change_evt status)
-{
-	struct policy *p;
-	enum pwr_role prole;
-	int ret;
-
-	pr_debug("PE:%s: Change event=%d\n", __func__, status);
-	if (!pe)
-		return;
-	switch (status) {
-	case PE_STATUS_CHANGE_PD_FAIL:
-	case PE_STATUS_CHANGE_PD_SUCCESS:
-		/* Start display pe after PD */
-		ret = pe_start_policy(pe, POLICY_TYPE_DISPLAY);
-		if (ret)
-			pr_warn("PE:%s: Failed to start disp policy\n",
-					__func__);
-		break;
-
-	case PE_STATUS_CHANGE_DP_FAIL:
-	case PE_STATUS_CHANGE_DP_SUCCESS:
-		/* Handle the display policy status change */
-		prole = pe_get_power_role(pe);
-		if (prole != POWER_ROLE_SOURCE)
-			break;
-
-		p = pe_get_policy(pe, POLICY_TYPE_SOURCE);
-		if (!p) {
-			pr_err("PE: %s No Source policy found\n", __func__);
-			break;
-		}
-
-		if (p->status != POLICY_STATUS_SUCCESS) {
-			pr_warn("PE:%s: Source PE not success!!\n", __func__);
-			break;
-		}
-		if (!p->get_port_caps)
-			break;
-
-		ret = p->get_port_caps(p, &pe->pp_caps);
-		if (ret) {
-			pr_warn("PE:%s: faied to get pp caps!!\n", __func__);
-			break;
-		}
-		/* Trigger PR_SWAP if pp is externally powered */
-		if (pe->pp_caps.pp_is_ext_pwrd && p->rcv_request)
-			p->rcv_request(p, PE_EVT_SEND_PR_SWAP);
-		break;
-	case PE_STATUS_CHANGE_DR_CHANGED:
-		/* Restart Display PE on data role change */
-		ret = pe_stop_policy(pe, POLICY_TYPE_DISPLAY);
-		if (ret < 0) {
-			pr_err("PE:%s: Failed to stop disp policy\n",
-					__func__);
-			break;
-		}
-		ret = pe_start_policy(pe, POLICY_TYPE_DISPLAY);
-		if (ret < 0) {
-			pr_err("PE:%s: Failed to start disp policy\n",
-					__func__);
-			break;
-		}
-		pr_info("PE:%s: Restarted disp policy\n", __func__);
-		break;
-
-	case PE_STATUS_CHANGE_PR_CHANGED:
-		if (ptype == POLICY_TYPE_SINK)
-			pe_switch_policy(pe, POLICY_TYPE_SOURCE);
-		else if (ptype == POLICY_TYPE_SOURCE)
-			pe_switch_policy(pe, POLICY_TYPE_SINK);
-		else
-			pr_err("PE:%s:PR_CHANGE from invalid policy=%d\n",
-					__func__, ptype);
-		break;
-
-	case PE_STATUS_CHANGE_PR_SWAP_FAIL:
-		/* As PR_SWAP changes the CC pull-up and pull-down,
-		 * swap fail should be treated as disconnect and enable
-		 * the CC toggle in DRP mode.
-		 */
-		pe_set_power_role(pe, POWER_ROLE_NONE);
-		pe_set_data_role(pe, DATA_ROLE_NONE);
-		/* Stop all active policies */
-		list_for_each_entry(p, &pe->policy_list, list) {
-			if (p && (p->state == POLICY_STATE_ONLINE))
-				p->stop(p);
-		}
-		break;
-	default:
-		pr_debug("PE:%s: Not processing state change evt=%d\n",
-					__func__, status);
-	}
-}
-
-static void pe_init_policy(struct work_struct *work)
-{
-	struct policy_engine *pe = container_of(work, struct policy_engine,
-							policy_init_work);
-
-	struct pd_policy *supported_policy = pe->supported_policies;
-	struct policy *policy;
-	int i;
-
-	for (i = 0; i < supported_policy->num_policies; i++) {
-		switch (supported_policy->policies[i]) {
-		case POLICY_TYPE_SINK:
-			policy = sink_port_policy_init(pe);
-			if (IS_ERR_OR_NULL(policy)) {
-				pr_err("PE: %s unable to init SINK_POLICY\n",
-								__func__);
-				continue;
-			}
-			list_add_tail(&policy->list, &pe->policy_list);
-			break;
-		case POLICY_TYPE_SOURCE:
-			policy = src_pe_init(pe);
-			if (IS_ERR_OR_NULL(policy)) {
-				pr_err("PE: %s unable to init SOURCE_POLICY\n",
-								__func__);
-				continue;
-			}
-			list_add_tail(&policy->list, &pe->policy_list);
-			pr_debug("PE: %s Successfuly init source pe\n",
-					__func__);
-			break;
-		case POLICY_TYPE_DISPLAY:
-			policy = disp_pe_init(pe);
-			if (IS_ERR_OR_NULL(policy)) {
-				pr_err("PE: %s unable to init DOSPLAY_POLICY\n",
-								__func__);
-				continue;
-			}
-			list_add_tail(&policy->list, &pe->policy_list);
-			pr_debug("PE: %s Successfuly init display pe\n",
-					__func__);
-			break;
-		default:
-			/* invalid, dont add it to policy */
-			pr_err("PE: Unknown policy type %d\n",
-				supported_policy->policies[i]);
-			break;
-		}
-	}
-
-	return;
-}
-
-static int pe_fwdreq_to_policy(struct policy_engine *pe,
-					enum pe_event evt)
-{
-	struct policy *p;
-	int ret = 0;
-
-	p = pe_get_active_src_or_snk_policy(&pe->policy_list);
-	if (!p) {
-		pr_err("PE: No Active policy!\n");
-		return -EINVAL;
-	}
-
-	if (p && p->rcv_request) {
-		p->rcv_request(p, evt);
-	} else {
-		pr_err("PE: Unable to send request\n");
-		ret = -ENODEV;
-	}
-
-	return ret;
-}
-
-static int pe_send_role_swap_request(struct policy_engine *pe,
-					enum pe_event evt)
-{
-	int ret = 0;
-
-	pr_debug("PE: %s - request %d\n", __func__, evt);
-	switch (evt) {
-	case PE_EVT_SEND_PR_SWAP:
-	case PE_EVT_SEND_DR_SWAP:
-		ret = pe_fwdreq_to_policy(pe, evt);
-		if (ret < 0)
-			pr_err("PE: Error in handling request\n");
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-static void pe_handle_dpm_event(struct policy_engine *pe,
-					enum devpolicy_mgr_events evt)
-{
-	struct policy *p;
-	enum pe_event pevt = PE_EVT_SEND_NONE;
-	int ret;
-
-	pr_info("PE: %s event - %d\n", __func__, evt);
-	switch (evt) {
-	case DEVMGR_EVENT_UFP_CONNECTED:
-		pe_set_power_role(pe, POWER_ROLE_SINK);
-		pe_set_data_role(pe, DATA_ROLE_UFP);
-		/* Start sink policy */
-		p = pe_get_policy(pe, POLICY_TYPE_SINK);
-		if (!p) {
-			pr_err("PE: No SINK policy to start on UFP connect\n");
-			break;
-		}
-		if (p->state != POLICY_STATE_ONLINE)
-			p->start(p);
-		else
-			pr_warn("PE: SINK policy is already active!!!\n");
-
-		/* Start display pe on connect in UFP mode as NAK the
-		 * port partner's DI irrespective of PD status.*/
-		ret = pe_start_policy(pe, POLICY_TYPE_DISPLAY);
-		if (ret)
-			pr_warn("PE:%s: Failed to start disp policy\n",
-					__func__);
-		break;
-	case DEVMGR_EVENT_DFP_CONNECTED:
-		pe_set_power_role(pe, POWER_ROLE_SOURCE);
-		pe_set_data_role(pe, DATA_ROLE_DFP);
-		/* Start source policy.
-		 * Display pe should be started after source pe complete.
-		 */
-		p = pe_get_policy(pe, POLICY_TYPE_SOURCE);
-		if (!p) {
-			pr_err("PE: No SOURCE policy to start on DFP connect\n");
-			break;
-		}
-		if (p->state != POLICY_STATE_ONLINE)
-			p->start(p);
-		else
-			pr_warn("PE: SOURCE policy is already active!!!\n");
-		break;
-
-	case DEVMGR_EVENT_UFP_DISCONNECTED:
-	case DEVMGR_EVENT_DFP_DISCONNECTED:
-		if (pe->cur_prole == POWER_ROLE_SWAP) {
-			/* This disconnect event is due to pwr role swap.
-			 * Hence ignore it.
-			 */
-			 pr_info("PE:%s: Disconnect evt during role swap\n",
-					__func__);
-			 break;
-		}
-		/* reset the protocol layer */
-		pe_send_packet(pe, NULL, 0,
-				PD_CMD_PROTOCOL_RESET, PE_EVT_SEND_PROTOCOL_RESET);
-
-		pe_set_power_role(pe, POWER_ROLE_NONE);
-		pe_set_data_role(pe, DATA_ROLE_NONE);
-		/* Stop all active policies */
-		list_for_each_entry(p, &pe->policy_list, list) {
-			if (p && (p->state == POLICY_STATE_ONLINE))
-				p->stop(p);
-		}
-		break;
-	case DEVMGR_EVENT_PR_SWAP:
-		pevt = PE_EVT_SEND_PR_SWAP;
-		break;
-	case DEVMGR_EVENT_DR_SWAP:
-		pevt = PE_EVT_SEND_DR_SWAP;
-		break;
-	default:
-		pr_err("PE: %s Unknown dpm event=%d\n",
-			__func__, evt);
-	}
-
-	if (pevt != PE_EVT_SEND_NONE)
-		pe_send_role_swap_request(pe, pevt);
-}
-
-
-static int pe_dpm_notification(struct policy_engine *pe,
-				enum devpolicy_mgr_events evt)
-{
-	pe_handle_dpm_event(pe, evt);
-	return 0;
-}
-
-
-
-
-static struct pe_operations ops = {
-	.get_snkpwr_cap = pe_get_snkpwr_cap,
-	.get_snkpwr_caps = pe_get_snkpwr_caps,
-	.get_srcpwr_cap = pe_get_srcpwr_cap,
-	.get_max_snkpwr_cap = pe_get_max_snkpwr_cap,
-	.get_data_role = pe_get_data_role,
-	.get_power_role = pe_get_power_role,
-	.set_data_role = pe_set_data_role,
-	.set_power_role = pe_set_power_role,
-	.set_charger_mode = pe_set_charger_mode,
-	.update_charger = pe_update_charger,
-	.get_min_snk_current = pe_get_min_snk_current,
-	.is_pr_swap_support = pe_is_pr_swap_support,
-	.send_packet = pe_send_packet,
-	.get_cable_state = pe_get_cable_state,
-	.get_pd_state = pe_get_pd_state,
-	.set_pd_state = pe_set_pd_state,
-	.process_data_msg = policy_engine_process_data_msg,
-	.process_ctrl_msg = policy_engine_process_ctrl_msg,
-	.process_cmd = policy_engine_process_cmd,
-	.policy_status_changed = pe_policy_status_changed,
-	.notify_dpm_evt = pe_dpm_notification,
-};
-
-int policy_engine_bind_dpm(struct devpolicy_mgr *dpm)
-{
-	int retval;
-	struct policy_engine *pe;
-
-	if (!dpm)
-		return -EINVAL;
-
-	if (dpm->pe)
-		return -EEXIST;
-
-	pe = devm_kzalloc(dpm->phy->dev, sizeof(struct policy_engine),
-				GFP_KERNEL);
-	if (!pe)
-		return -ENOMEM;
-
-	pe->ops = &ops;
-	pe->dpm = dpm;
-	pe->supported_policies = dpm->policy;
-
-	retval = protocol_bind_pe(pe);
-	if (retval) {
-		pr_err("PE: failed to bind pe to protocol\n");
-		retval = -EINVAL;
-		goto bind_error;
-	}
-	pe->cur_drole = DATA_ROLE_NONE;
-	pe->cur_prole = POWER_ROLE_NONE;
-	INIT_WORK(&pe->policy_init_work, pe_init_policy);
-
-	mutex_init(&pe->pe_lock);
-	INIT_LIST_HEAD(&pe->policy_list);
-	dpm->pe = pe;
-
-	schedule_work(&pe->policy_init_work);
-
-	return 0;
-
-bind_error:
-	kfree(pe);
-	return retval;
-}
-EXPORT_SYMBOL_GPL(policy_engine_bind_dpm);
-
-void policy_engine_unbind_dpm(struct devpolicy_mgr *dpm)
-{
-	struct policy_engine *pe;
-	struct policy *p;
-	struct pd_policy *supported_policy;
-	int i;
-
-	if (!dpm || !dpm->pe)
-		return;
-
-	pe = dpm->pe;
-	mutex_lock(&pe->pe_lock);
-	/* remove the pe ops to avoid further external
-	 * notifications and callbacks.
-	 */
-	pe->ops = NULL;
-
-	/* Exit all sub policy engines */
-	supported_policy = pe->supported_policies;
-	for (i = 0; i < supported_policy->num_policies; i++) {
-		p = __pe_find_policy(&pe->policy_list,
-					supported_policy->policies[i]);
-		if (p)
-			p->exit(p);
-	}
-	/* Unbind from protocol layer */
-	protocol_unbind_pe(pe);
-	mutex_unlock(&pe->pe_lock);
-
-	kfree(pe);
-}
-EXPORT_SYMBOL_GPL(policy_engine_unbind_dpm);
-
-MODULE_AUTHOR("Albin B <albin.bala.krishnan@intel.com>");
-MODULE_DESCRIPTION("PD Policy Engine Core");
-MODULE_LICENSE("GPL v2");
Index: b/drivers/usb/typec/pd/policy_engine.h
===================================================================
--- a/drivers/usb/typec/pd/policy_engine.h	2016-03-08 16:32:14.168848245 -0800
+++ b/drivers/usb/typec/pd/policy_engine.h	2016-03-08 16:45:44.413281909 -0800
@@ -564,17 +564,12 @@
 	return false;
 }
 
-#if defined(CONFIG_USBC_PD) && defined(CONFIG_USBC_PD_POLICY)
-extern int policy_engine_bind_dpm(struct devpolicy_mgr *dpm);
-extern void policy_engine_unbind_dpm(struct devpolicy_mgr *dpm);
-#else /* CONFIG_USBC_PD && CONFIG_USBC_PD_POLICY */
 static inline int policy_engine_bind_dpm(struct devpolicy_mgr *dpm)
 {
 	return 0;
 }
 static inline void policy_engine_unbind_dpm(struct devpolicy_mgr *dpm)
 { }
-#endif /* CONFIG_USBC_PD && CONFIG_USBC_PD_POLICY */
 
 static inline int pe_process_cmd(struct policy_engine *pe, enum pe_event cmd)
 {
Index: b/drivers/usb/typec/pd/sink_port_pe.c
===================================================================
--- a/drivers/usb/typec/pd/sink_port_pe.c	2016-03-08 16:32:19.584904242 -0800
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,1266 +0,0 @@
-/*
- * pd_sink_pe.c: Intel USB Power Delivery Sink Port Policy Engine
- *
- * Copyright (C) 2015 Intel Corporation
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Seee the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- * Author: Albin B <albin.bala.krishnan@intel.com>
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/notifier.h>
-#include <linux/kfifo.h>
-#include <linux/err.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/timer.h>
-#include "policy_engine.h"
-#include "sink_port_pe.h"
-
-static int snkpe_start(struct sink_port_pe *sink);
-static int snkpe_handle_select_capability_state(struct sink_port_pe *sink,
-							struct pd_packet *pkt);
-static int snkpe_handle_give_snk_cap_state(struct sink_port_pe *sink);
-static void sink_port_policy_exit(struct policy *p);
-static void sink_do_reset(struct sink_port_pe *pe);
-
-static inline void snkpe_update_state(struct sink_port_pe *sink,
-					enum pe_states cur_state)
-{
-	if (!sink)
-		return;
-
-	mutex_lock(&sink->snkpe_state_lock);
-	sink->cur_state = cur_state;
-	mutex_unlock(&sink->snkpe_state_lock);
-}
-
-static void snkpe_reset_params(struct sink_port_pe *sink)
-{
-	/* By default dual power role supported*/
-	sink->pp_is_dual_prole = 1;
-	/* By default dual data role supported*/
-	sink->pp_is_dual_drole = 1;
-	sink->pp_is_ext_pwrd = 0;
-}
-
-/* PR_SWAP fail handling is different from reset on timeout error.
- * During PR_SWAP as the CC pull-up is changed, on failure there is
- * no guarentee that this device still act as source. Hence this
- * failure should be treated as disconnect and start toggle in DRP.
- */
-static void snkpe_handle_pr_swap_fail(struct sink_port_pe *sink)
-{
-	snkpe_reset_params(sink);
-	pr_err("SNKPE:%s: Notifying PR_SWAP_FAIL to PE\n", __func__);
-	pe_notify_policy_status_changed(&sink->p,
-			POLICY_TYPE_SINK, PE_STATUS_CHANGE_PR_SWAP_FAIL);
-}
-
-static int snkpe_get_req_cap(struct sink_port_pe *sink,
-					struct pd_packet *pkt,
-					struct power_cap *pcap,
-					struct req_cap *rcap)
-{
-	int num_data_obj = PD_MSG_NUM_DATA_OBJS(&pkt->header);
-	int i;
-	int mv = 0;
-	int ma = 0;
-	bool is_mv_match = false;
-
-	rcap->cap_mismatch = true;
-
-	for (i = 0; i < num_data_obj; i++) {
-		/**
-		 * FIXME: should be selected based on the power (V*I) cap.
-		 */
-		mv = DATA_OBJ_TO_VOLT(pkt->data_obj[i]);
-		if (mv == pcap->mv) {
-			is_mv_match = true;
-			ma = DATA_OBJ_TO_CURRENT(pkt->data_obj[i]);
-			if (ma == pcap->ma) {
-				rcap->cap_mismatch = false;
-				break;
-			} else if (ma > pcap->ma) {
-				/* if the ma in the pdo is greater than the
-				 * required ma, exit from the loop as the pdo
-				 * capabilites are in ascending order */
-				break;
-			}
-		} else if (mv > pcap->mv) {
-			/* if the mv value in the pdo is greater than the
-			 * required mv, exit from the loop as the pdo
-			 * capabilites are in ascending order */
-			break;
-		}
-	}
-
-	if (!is_mv_match) {
-		i = 0; /* to select 1st pdo, Vsafe5V */
-	}
-
-	if (!rcap->cap_mismatch) {
-		rcap->obj_pos = i + 1; /* obj pos always starts from 1 */
-		rcap->max_ma = pcap->ma;
-		rcap->op_ma = pcap->ma;
-	} else  {
-		/* if cur is not match, select the previous pdo */
-		rcap->obj_pos = i ? i : 1;
-		rcap->op_ma = DATA_OBJ_TO_CURRENT(pkt->data_obj[rcap->obj_pos - 1]);
-		if (pcap->ma < rcap->op_ma) {
-			rcap->cap_mismatch = false;
-			rcap->max_ma = rcap->op_ma;
-			rcap->op_ma = pcap->ma;
-		} else {
-			rcap->max_ma = pcap->ma;
-		}
-	}
-
-	rcap->mv = DATA_OBJ_TO_VOLT(pkt->data_obj[rcap->obj_pos - 1]);
-
-	return 0;
-}
-
-static int snkpe_create_reqmsg(struct sink_port_pe *sink,
-					struct pd_packet *pkt, u32 *data)
-{
-	struct pd_fixed_var_rdo *rdo = (struct pd_fixed_var_rdo *)data;
-	struct req_cap *rcap = &sink->rcap;
-	struct power_cap dpm_suggested_cap;
-	int ret;
-
-	ret = policy_get_snkpwr_cap(&sink->p, &dpm_suggested_cap);
-	if (ret) {
-		pr_err("SNKPE: Error in getting max sink pwr cap %d\n",
-				ret);
-		goto error;
-	}
-
-	ret = snkpe_get_req_cap(sink, pkt, &dpm_suggested_cap, rcap);
-	if (ret < 0) {
-		pr_err("SNKPE: Unable to get the Sink Port PE cap\n");
-		goto error;
-	}
-
-	rdo->obj_pos = rcap->obj_pos;
-	rdo->cap_mismatch = rcap->cap_mismatch;
-	rdo->op_cur = CURRENT_TO_DATA_OBJ(rcap->op_ma);
-	rdo->max_cur = CURRENT_TO_DATA_OBJ(rcap->max_ma);
-
-	return 0;
-
-error:
-	return ret;
-}
-
-static int snkpe_handle_rcv_pr_swap(struct sink_port_pe *sink)
-{
-	enum pwr_role prole;
-	int ret = 0;
-
-	/* If not SNK_READY dont send accept or wait*/
-	if (sink->cur_state != PE_SNK_READY) {
-		pr_debug("SNKPE:%s: PR_Swap rcvd in worng state=%d\n",
-					__func__, sink->cur_state);
-		goto pr_swap_wait;
-	}
-
-	/* If port partner is externally powered, power role swap from
-	 * sink to source can be rejected.
-	 */
-	if (sink->pp_is_ext_pwrd) {
-		pr_info("SNKPE:%s: Port partner is ext pwrd\n",
-				__func__);
-		goto pr_swap_reject;
-	}
-
-	snkpe_update_state(sink, PE_PRS_SNK_SRC_EVALUATE_PR_SWAP);
-
-	prole = policy_get_power_role(&sink->p);
-	if (prole <= 0) {
-		pr_err("SINKPE: Error in getting power role\n");
-		goto pr_swap_reject_state_chng;
-	}
-
-	if (prole != POWER_ROLE_SINK) {
-		pr_warn("SNKPE: Current Power Role - %d\n", prole);
-		goto pr_swap_reject_state_chng;
-	}
-	/* As the request to transition to provider mode, It
-	 * will be accepted only if VBAT >= 50% else reject.
-	 * returns: 1 - accepted, 0 - rejected or error code.
-	 */
-	ret = policy_is_pr_swap_support(&sink->p, prole);
-	if (ret == 0) {
-		pr_warn("SNKPE: Batt cap < 50\n");
-		goto pr_swap_reject_state_chng;
-	}
-
-	pr_debug("SNKPE:%s: Accepting pr_swap\n", __func__);
-	snkpe_update_state(sink, PE_PRS_SNK_SRC_ACCEPT_PR_SWAP);
-	return policy_send_packet(&sink->p, NULL, 0,
-					PD_CTRL_MSG_ACCEPT, PE_EVT_SEND_ACCEPT);
-
-pr_swap_reject_state_chng:
-	snkpe_update_state(sink, PE_SNK_READY);
-pr_swap_reject:
-	pr_debug("SNKPE:%s: Rejecting pr_swap\n", __func__);
-	return policy_send_packet(&sink->p, NULL, 0,
-				PD_CTRL_MSG_REJECT, PE_EVT_SEND_REJECT);
-
-pr_swap_wait:
-	pr_debug("SNKPE:%s: Wait pr_swap\n", __func__);
-	return policy_send_packet(&sink->p, NULL, 0,
-				PD_CTRL_MSG_WAIT, PE_EVT_SEND_WAIT);
-}
-
-static inline int snkpe_do_prot_reset(struct sink_port_pe *sink)
-{
-	return	policy_send_packet(&sink->p, NULL, 0, PD_CMD_PROTOCOL_RESET,
-					 PE_EVT_SEND_PROTOCOL_RESET);
-}
-
-static void snkpe_reinitialize_completion(struct sink_port_pe *sink)
-{
-	reinit_completion(&sink->wct_complete);
-	reinit_completion(&sink->srt_complete);
-	reinit_completion(&sink->pstt_complete);
-	reinit_completion(&sink->sat_complete);
-	reinit_completion(&sink->pssoff_complete);
-}
-
-/* This function will set the role to POWER_ROLE_SWAP, disable charging
- * and schedule worker to wait for ps_rdy after accepting the pr_swap.
- */
-static int snkpe_handle_pss_transition_to_off(struct sink_port_pe *sink)
-{
-	int ret;
-
-	snkpe_update_state(sink, PE_PRS_SNK_SRC_TRANSITION_TO_OFF);
-
-	ret = policy_set_power_role(&sink->p, POWER_ROLE_SWAP);
-	if (ret < 0) {
-		pr_err("SNKPE: Error in setting POWER_ROLE_SWAP (%d)\n", ret);
-		goto trans_to_off_err;
-	}
-	schedule_work(&sink->timer_work);
-	return 0;
-
-trans_to_off_err:
-	/* Move to PE_SNK_Hard_Reset state */
-	snkpe_update_state(sink, PE_SNK_HARD_RESET);
-	schedule_work(&sink->timer_work);
-	return ret;
-}
-
-static void snkpe_handle_send_swap(struct sink_port_pe *sink)
-{
-	int ret;
-
-	ret = wait_for_completion_timeout(&sink->srt_complete,
-				msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER));
-
-	if (ret == 0) {
-		pr_warn("SNKPE: %s sender response expired\n", __func__);
-		snkpe_update_state(sink, PE_SNK_READY);
-		reinit_completion(&sink->srt_complete);
-		return;
-	}
-	reinit_completion(&sink->srt_complete);
-
-	/* Either accepr or reject received */
-	switch (sink->cur_state) {
-	case PE_PRS_SNK_SRC_SEND_PR_SWAP:
-		if (sink->last_pkt == PE_EVT_RCVD_ACCEPT) {
-			pr_debug("SNKPE:%s: PR_Swap accepted\n", __func__);
-			/* PR_SWAP accepted, transition to sink off*/
-			snkpe_handle_pss_transition_to_off(sink);
-		} else {
-			pr_debug("SNKPE:%s: PR_Swap not accepted\n", __func__);
-			/* PR_SWAP not accepted, go to ready state*/
-			snkpe_update_state(sink, PE_SNK_READY);
-		}
-		break;
-	case PE_EVT_SEND_DR_SWAP:
-		/* TODO: handle for data role swap */
-		break;
-	default:
-		pr_warn("SNKPE:%s: unexpected state=%d\n", __func__,
-						sink->cur_state);
-	}
-}
-
-static void snkpe_handle_dr_swap_transition(struct sink_port_pe *sink,
-			enum data_role to_role)
-{
-	int ret;
-
-	if (to_role == DATA_ROLE_UFP)
-		snkpe_update_state(sink, PE_DRS_DFP_UFP_CHANGE_TO_UFP);
-	else
-		snkpe_update_state(sink, PE_DRS_UFP_DFP_CHANGE_TO_DFP);
-
-	pr_debug("SNKPE:%s:Changing data role to %d", __func__, to_role);
-	ret = policy_set_data_role(&sink->p, to_role);
-	if (ret) {
-		pr_err("SNKPE:%s:Failed to change the data role\n", __func__);
-		/*Reset pe as role swap failed*/
-		/* Move to PE_SNK_Hard_Reset state */
-		snkpe_update_state(sink, PE_SNK_HARD_RESET);
-		schedule_work(&sink->timer_work);
-		return;
-	}
-	pe_notify_policy_status_changed(&sink->p,
-			POLICY_TYPE_SINK, PE_STATUS_CHANGE_DR_CHANGED);
-	pr_debug("SNKPE:%s:Data role changed to %d", __func__, to_role);
-	snkpe_update_state(sink, PE_SNK_READY);
-}
-
-static void snkpe_handle_after_dr_swap_sent(struct sink_port_pe *sink)
-{
-	unsigned long timeout;
-	int ret;
-
-	/* Initialize and run SenderResponseTimer */
-	timeout = msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER);
-	/* unblock this once Accept msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&sink->srt_complete, timeout);
-	if (ret == 0) {
-		pr_err("SNKPE:%s:SRT time expired, Move to READY\n",
-					__func__);
-		snkpe_update_state(sink, PE_SNK_READY);
-		reinit_completion(&sink->srt_complete);
-		return;
-	}
-	reinit_completion(&sink->srt_complete);
-
-	if (sink->last_pkt != PE_EVT_RCVD_ACCEPT) {
-		pr_info("SNKPE:%s:DR swap not accepted!!\n", __func__);
-		snkpe_update_state(sink, PE_SNK_READY);
-		return;
-	}
-	pr_debug("SNKPE:%s:DR swap accepted by port partner\n", __func__);
-	if (sink->cur_state == PE_DRS_DFP_UFP_SEND_DR_SWAP)
-		snkpe_handle_dr_swap_transition(sink, DATA_ROLE_UFP);
-	else if (sink->cur_state == PE_DRS_UFP_DFP_SEND_DR_SWAP)
-		snkpe_handle_dr_swap_transition(sink, DATA_ROLE_DFP);
-	else
-		pr_err("SNKPE:%s:Unexpected state=%d !!!\n",
-					__func__, sink->cur_state);
-}
-
-static int snkpe_handle_trigger_dr_swap(struct sink_port_pe *sink)
-{
-	enum data_role drole;
-
-	drole = policy_get_data_role(&sink->p);
-
-	if (sink->cur_state != PE_SNK_READY
-		|| (drole != DATA_ROLE_UFP && drole != DATA_ROLE_DFP)
-		|| !sink->pp_is_dual_drole) {
-		pr_warn("SNKPE:%s:Not processing DR_SWAP request in state=%d",
-				__func__, sink->cur_state);
-		return -EINVAL;
-	}
-
-	if (drole == DATA_ROLE_DFP)
-		snkpe_update_state(sink, PE_DRS_DFP_UFP_SEND_DR_SWAP);
-	else
-		snkpe_update_state(sink, PE_DRS_UFP_DFP_SEND_DR_SWAP);
-
-	schedule_work(&sink->timer_work);
-
-	policy_send_packet(&sink->p, NULL, 0,
-			PD_CTRL_MSG_DR_SWAP, PE_EVT_SEND_DR_SWAP);
-
-	return 0;
-}
-
-static void snkpe_handle_after_dr_swap_accept(struct sink_port_pe *sink)
-{
-	unsigned long timeout;
-	int ret;
-
-	/* Initialize and run SenderResponseTimer */
-	timeout = msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER);
-	/* unblock this once Accept msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&sink->srt_complete, timeout);
-	if (ret == 0) {
-		pr_err("SNKPE:%s:SRT time expired, move to RESET\n", __func__);
-		/*Reset pe as role swap failed*/
-		snkpe_update_state(sink, PE_SNK_HARD_RESET);
-		reinit_completion(&sink->srt_complete);
-		schedule_work(&sink->timer_work);
-		return;
-	}
-	reinit_completion(&sink->srt_complete);
-
-	if (sink->cur_state == PE_DRS_DFP_UFP_ACCEPT_DR_SWAP)
-		snkpe_handle_dr_swap_transition(sink, DATA_ROLE_UFP);
-	else if (sink->cur_state == PE_DRS_UFP_DFP_ACCEPT_DR_SWAP)
-		snkpe_handle_dr_swap_transition(sink, DATA_ROLE_DFP);
-	else
-		pr_err("SNKPE:%s:Unexpected state=%d !!!\n",
-				__func__, sink->cur_state);
-}
-
-static void snkpe_handle_rcv_dr_swap(struct sink_port_pe *sink)
-{
-	enum data_role drole;
-
-	drole = policy_get_data_role(&sink->p);
-
-	if (sink->cur_state != PE_SNK_READY
-		|| (drole != DATA_ROLE_UFP && drole != DATA_ROLE_DFP)) {
-		pr_debug("SNKPE:%s:Not processing DR_SWAP request in state=%d",
-				__func__, sink->cur_state);
-		/* As platform supports dual data role, sending wait will be
-		 * more appropriate than sending reject.
-		 */
-		policy_send_packet(&sink->p, NULL, 0,
-			PD_CTRL_MSG_WAIT, PE_EVT_SEND_WAIT);
-		return;
-	}
-
-	if (drole == DATA_ROLE_DFP)
-		snkpe_update_state(sink, PE_DRS_DFP_UFP_ACCEPT_DR_SWAP);
-	else
-		snkpe_update_state(sink, PE_DRS_UFP_DFP_ACCEPT_DR_SWAP);
-	schedule_work(&sink->timer_work);
-
-	policy_send_packet(&sink->p, NULL, 0,
-			PD_CTRL_MSG_ACCEPT, PE_EVT_SEND_ACCEPT);
-
-}
-
-static void snkpe_received_msg_good_crc(struct sink_port_pe *sink)
-{
-
-	switch (sink->cur_state) {
-	case PE_SNK_SOFT_RESET:
-		if (sink->last_pkt == PE_EVT_RCVD_ACCEPT) {
-			snkpe_update_state(sink, PE_SNK_STARTUP);
-			schedule_work(&sink->timer_work);
-		}
-		break;
-	case PE_SNK_SELECT_CAPABILITY:
-		schedule_work(&sink->timer_work);
-		break;
-	case PE_PRS_SNK_SRC_ACCEPT_PR_SWAP:
-		snkpe_handle_pss_transition_to_off(sink);
-		break;
-	case PE_PRS_SNK_SRC_SOURCE_ON:
-		pr_debug("SNKPE:%s: Notifying power role chnage\n", __func__);
-		pe_notify_policy_status_changed(&sink->p,
-			POLICY_TYPE_SINK, PE_STATUS_CHANGE_PR_CHANGED);
-		break;
-	case PE_DRS_DFP_UFP_ACCEPT_DR_SWAP:
-	case PE_DRS_UFP_DFP_ACCEPT_DR_SWAP:
-		complete(&sink->srt_complete);
-		break;
-	default:
-		pr_debug("SNKPE: Recved GOODCRC in %d state\n",
-							sink->cur_state);
-		break;
-	}
-}
-
-static int sink_port_policy_rcv_request(struct policy *p, enum pe_event evt)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-
-	switch (evt) {
-	case PE_EVT_SEND_PR_SWAP:
-		if (sink->pp_is_ext_pwrd || (!sink->pp_is_dual_prole)
-			|| (sink->cur_state != PE_SNK_READY)) {
-			pr_info("SNKPE:%s: Not processing PR_SWAP Req\n",
-					__func__);
-			break;
-		}
-		snkpe_update_state(sink, PE_PRS_SNK_SRC_SEND_PR_SWAP);
-		policy_send_packet(&sink->p, NULL, 0,
-				PD_CTRL_MSG_PR_SWAP, evt);
-		/* work schedule for rcv good crc for PR_SWAP and
-		 * receive Accept/reject */
-		schedule_work(&sink->timer_work);
-		break;
-	case PE_EVT_SEND_DR_SWAP:
-		snkpe_handle_trigger_dr_swap(sink);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static void sink_handle_src_cap(struct sink_port_pe *sink,
-					struct pd_packet *pkt)
-{
-	if (!sink->hard_reset_complete) {
-		/* You are here because reset complete got missed,
-		 * but it is handled properly by timeout.
-		 * Just set the variable as src_cap received means
-		 * port partner is recovered from reset.
-		 */
-		sink->hard_reset_complete = true;
-	}
-	snkpe_update_state(sink, PE_SNK_EVALUATE_CAPABILITY);
-
-	sink->hard_reset_count = 0;
-	if (timer_pending(&sink->no_response_timer))
-		del_timer_sync(&sink->no_response_timer);
-	sink->no_response_timer_expired = false;
-
-	policy_set_pd_state(&sink->p, true);
-
-	snkpe_handle_select_capability_state(sink, pkt);
-
-}
-
-static void sink_handle_accept_reject_wait(struct sink_port_pe *sink,
-					enum pe_event evt)
-{
-	switch (evt) {
-	case PE_EVT_RCVD_ACCEPT:
-		snkpe_update_state(sink, PE_SNK_TRANSITION_SINK);
-		break;
-	case PE_EVT_RCVD_REJECT:
-	case PE_EVT_RCVD_WAIT:
-		snkpe_update_state(sink, PE_SNK_READY);
-		break;
-	default:
-		pr_warn("SNKPE: recvd (%d) in select cap\n", evt);
-		goto end;
-	}
-	schedule_work(&sink->timer_work);
-end:
-	return;
-}
-
-static int snkpe_setup_charging(struct sink_port_pe *sink)
-{
-	int ret = 0;
-
-	pr_debug("SNKPE:%s In\n", __func__);
-	policy_update_charger(&sink->p, sink->rcap.op_ma, 0);
-	pr_info("SNKPE: Consumer Policy Negotiation Success!\n");
-	return ret;
-}
-
-/* This function will read the port partner capabilities and
- * save it for further use.
- */
-static void snkpe_read_src_caps(struct sink_port_pe *sink,
-					struct pd_packet *pkt)
-{
-	struct pd_fixed_supply_pdo *pdo =
-			(struct pd_fixed_supply_pdo *) &pkt->data_obj[0];
-
-	if (pdo->fixed_supply != SUPPLY_TYPE_FIXED) {
-		pr_debug("SNKPE:%s: source is not fixed supply\n",
-					__func__);
-		return;
-	}
-	sink->pp_is_dual_prole = pdo->dual_role_pwr;
-	sink->pp_is_dual_drole = pdo->data_role_swap;
-	sink->pp_is_ext_pwrd = pdo->ext_powered;
-
-	pr_debug("SNKPE:%s:dual_prole=%d, dual_drole=%d, ext_pwrd=%d",
-			__func__, sink->pp_is_dual_prole,
-			sink->pp_is_dual_drole,	sink->pp_is_ext_pwrd);
-}
-
-static int snkpe_handle_select_capability_state(struct sink_port_pe *sink,
-							struct pd_packet *pkt)
-{
-	int ret = 0;
-	u32 data = 0;
-
-	/* move the next state PE_SNK_Select_Capability */
-	snkpe_update_state(sink, PE_SNK_SELECT_CAPABILITY);
-
-	snkpe_read_src_caps(sink, pkt);
-	/* make request message and send to PE -> protocol */
-	ret = snkpe_create_reqmsg(sink, pkt, &data);
-	if (ret < 0) {
-		pr_err("SNKPE: Error in getting message!\n");
-		goto error;
-	}
-
-	ret = policy_send_packet(&sink->p, &data, 4, PD_DATA_MSG_REQUEST,
-							PE_EVT_SEND_REQUEST);
-	if (ret < 0) {
-		pr_err("SNKPE: Error in sending packet!\n");
-		goto error;
-	}
-	pr_debug("SNKPE: PD_DATA_MSG_REQUEST Sent\n");
-
-	/* Keeping backup to use later if required for wait event and
-	 * sink request timer timeout */
-	memcpy(&sink->prev_pkt, pkt, sizeof(struct pd_packet));
-
-error:
-	return ret;
-}
-
-static void snkpe_fill_default_cap(struct sink_port_pe *sink)
-{
-	struct pd_sink_fixed_pdo pdo = { 0 };
-
-	/* setting default pdo as vsafe5V with ma = 0 */
-	pdo.data_role_swap = 1;
-	pdo.usb_comm = 1;
-	pdo.ext_powered = 0;
-	pdo.higher_cap = 0;
-	pdo.dual_role_pwr = 1;
-	pdo.max_cur = CURRENT_TO_DATA_OBJ(0);
-	pdo.volt = (VOLT_TO_DATA_OBJ(5000) >>
-				SNK_FSPDO_VOLT_SHIFT);
-	pdo.supply_type = 0;
-	policy_send_packet(&sink->p, &pdo, 4,
-					PD_DATA_MSG_SINK_CAP,
-					PE_EVT_SEND_SNK_CAP);
-}
-
-static int snkpe_handle_give_snk_cap_state(struct sink_port_pe *sink)
-{
-	int ret = 0;
-	int i;
-	struct power_caps pcaps;
-	struct pd_sink_fixed_pdo pdo[MAX_NUM_DATA_OBJ] = { {0} };
-
-	snkpe_update_state(sink, PE_SNK_GIVE_SINK_CAP);
-
-	ret = policy_get_snkpwr_caps(&sink->p, &pcaps);
-	if (ret < 0) {
-		snkpe_fill_default_cap(sink);
-		goto error;
-	}
-
-	/**
-	 * As per PD v1.1 spec except first pdo, all other Fixed Supply Power
-	 * Data Objects shall set bits 29...20 to zero.
-	 */
-	if (pcaps.n_cap > 0) {
-		/* FIXME: DPM should provide info on USB capable and
-		 * higher power support required */
-		pdo[0].data_role_swap = 1;
-		pdo[0].usb_comm = 1;
-		pdo[0].ext_powered = 0;
-		pdo[0].higher_cap = 1;
-		pdo[0].dual_role_pwr = 1;
-	} else {
-		pr_debug("SNKPE: No PDO's from dpm setting default vasafe5v\n");
-		snkpe_fill_default_cap(sink);
-		goto error;
-	}
-
-	for (i = 0; i < MAX_NUM_DATA_OBJ; i++) {
-		if (i >= pcaps.n_cap)
-			break;
-
-		pdo[i].max_cur = CURRENT_TO_DATA_OBJ(pcaps.pcap[i].ma);
-		pdo[i].volt = (VOLT_TO_DATA_OBJ(pcaps.pcap[i].mv) >>
-					SNK_FSPDO_VOLT_SHIFT);
-		pdo[i].supply_type = pcaps.pcap[i].psy_type;
-	}
-
-	ret = policy_send_packet(&sink->p, pdo, pcaps.n_cap * 4,
-					PD_DATA_MSG_SINK_CAP,
-					PE_EVT_SEND_SNK_CAP);
-	if (ret < 0) {
-		pr_err("SNKPE: Error in sending packet!\n");
-		goto error;
-	}
-	pr_debug("SNKPE: PD_DATA_MSG_SINK_CAP sent\n");
-
-error:
-	snkpe_update_state(sink, PE_SNK_READY);
-	return ret;
-}
-
-/* After accepting the pr_swap and disabling the charging
- * (in PE_PRS_SNK_SRC_TRANSITION_TO_OFF state), this function
- * will wait for ps_rdy from source with timeout. On timeout,
- * pe will move to hard reset state. If ps_rdy received on-time
- * then move to source mode.
- */
-static void snkpe_handle_pss_transition_off(struct sink_port_pe *sink)
-{
-	int ret;
-	unsigned long timeout;
-
-	/* initialize and run the PSSourceOffTimer */
-	timeout = msecs_to_jiffies(TYPEC_PS_SRC_OFF_TIMER);
-	/* unblock this once PS_RDY msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&sink->pssoff_complete,
-						timeout);
-	if (!ret) {
-		reinit_completion(&sink->pssoff_complete);
-		goto trans_off_err;
-	}
-	reinit_completion(&sink->pssoff_complete);
-
-	pr_info("SNKPE: Received PS_READY\n");
-	/* Pull-up CC (enable Rp) and Vbus 5V enable */
-	ret = policy_set_power_role(&sink->p, POWER_ROLE_SOURCE);
-	if (ret)
-		goto trans_off_err;
-
-	/* SourceActivityTimer (40 - 50mSec) is not used to monitor source
-	 * activity. Assuming the source activity can be done within the time
-	 */
-	snkpe_update_state(sink, PE_PRS_SNK_SRC_SOURCE_ON);
-	policy_send_packet(&sink->p, NULL, 0,
-			PD_CTRL_MSG_PS_RDY, PE_EVT_SEND_PS_RDY);
-	return;
-
-trans_off_err:
-	pr_err("SNKPE: Error in pss_transition_off %d\n", ret);
-	snkpe_handle_pr_swap_fail(sink);
-	return;
-}
-
-static void snkpe_handle_startup(struct sink_port_pe *sink)
-{
-	int ret;
-	unsigned long timeout =
-		msecs_to_jiffies(TYPEC_SINK_WAIT_CAP_TIMER);
-
-	if (sink->cur_state == PE_SNK_STARTUP ||
-		sink->cur_state == PE_SNK_DISCOVERY) {
-		snkpe_update_state(sink, PE_SNK_WAIT_FOR_CAPABILITIES);
-
-		/* Initialize and run SinkWaitCapTimer */
-		/* unblock this once source cap rcv by checking the cur_state */
-		ret = wait_for_completion_timeout(&sink->wct_complete, timeout);
-		if (ret == 0) {
-			snkpe_update_state(sink, PE_SNK_HARD_RESET);
-			schedule_work(&sink->timer_work);
-		}
-	}
-
-	reinit_completion(&sink->wct_complete);
-}
-
-static void snkpe_handle_sink_hard_reset(struct sink_port_pe *sink)
-{
-	int ret;
-
-	pr_warn("SNKPE: transitioning to hard reset\n");
-	sink_do_reset(sink);
-	/* send hard reset */
-	sink->hard_reset_complete = false;
-	policy_send_packet(&sink->p, NULL, 0, PD_CMD_HARD_RESET,
-			PE_EVT_SEND_HARD_RESET);
-
-	/* increment counter */
-	sink->hard_reset_count++;
-	/* wait for hardrst complete */
-	ret = wait_event_timeout(sink->wq, sink->hard_reset_complete,
-		msecs_to_jiffies(TYPEC_HARD_RESET_COMPLETE_TIMER
-		+ TYPEC_HARD_RESET_TIMER));
-	if (ret == 0)
-		pr_info("SNKPE:%s: Reset complete timed out\n", __func__);
-
-	if (!timer_pending(&sink->no_response_timer))
-		mod_timer(&sink->no_response_timer,
-				msecs_to_jiffies(TYPEC_NO_RESPONSE_TIMER));
-
-	snkpe_update_state(sink, PE_SNK_STARTUP);
-	schedule_work(&sink->timer_work);
-}
-
-static void sink_handle_select_cap(struct sink_port_pe *sink)
-{
-	int ret;
-
-	sink->resend_cap = false;
-	ret = wait_for_completion_timeout(&sink->srt_complete,
-				msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER));
-
-	if (ret == 0) {
-		pr_warn("SNKPE: %s sender response expired\n", __func__);
-		snkpe_update_state(sink, PE_SNK_HARD_RESET);
-		reinit_completion(&sink->srt_complete);
-		schedule_work(&sink->timer_work);
-		return;
-	}
-	reinit_completion(&sink->srt_complete);
-}
-
-static void sink_handle_ready(struct sink_port_pe *sink)
-{
-	pr_debug("SNKPE: %s: last_pkt = %d cur_state %d\n", __func__,
-			sink->last_pkt, sink->cur_state);
-	if (sink->last_pkt == PE_EVT_RCVD_WAIT) {
-		pr_info("SNKPE:%s: wait\n", __func__);
-		schedule_work(&sink->request_timer);
-		goto ready_end;
-	}
-
-	/* enable charging if ps_rdy received */
-	snkpe_setup_charging(sink);
-
-ready_end:
-	sink->p.status = POLICY_STATUS_SUCCESS;
-	snkpe_update_state(sink, PE_SNK_READY);
-	pe_notify_policy_status_changed(&sink->p,
-			POLICY_TYPE_SINK, PE_STATUS_CHANGE_PD_SUCCESS);
-}
-
-static void sink_handle_transition_sink(struct sink_port_pe *sink)
-{
-	int ret;
-
-	pr_debug("SNKPE:%s: in\n", __func__);
-	policy_update_charger(&sink->p, 0, true);
-	ret = wait_for_completion_timeout(&sink->pstt_complete,
-				msecs_to_jiffies(TYPEC_PS_TRANSITION_TIMER));
-
-	if (ret == 0) {
-		pr_warn("SNKPE: %s PSTransition expired\n", __func__);
-		policy_update_charger(&sink->p, 0, true);
-		snkpe_update_state(sink, PE_SNK_HARD_RESET);
-		schedule_work(&sink->timer_work);
-		goto trans_sink_end;
-	}
-
-	/* PS_RDY received, handle it*/
-	sink_handle_ready(sink);
-
-trans_sink_end:
-	reinit_completion(&sink->pstt_complete);
-}
-
-/* wait for request timer expired to restart the request */
-static void sink_request_timer_work(struct work_struct *work)
-{
-	struct sink_port_pe *sink = container_of(work,
-					struct sink_port_pe,
-					request_timer);
-
-	if (timer_pending(&sink->snk_request_timer))
-		del_timer_sync(&sink->snk_request_timer);
-
-	mod_timer(&sink->snk_request_timer,
-				msecs_to_jiffies(TYPEC_SINK_REQUEST_TIMER));
-
-	sink->request_timer_expired = false;
-
-	wait_event(sink->wq_req, sink->request_timer_expired);
-
-	if ((sink->last_pkt != PE_EVT_RCVD_HARD_RESET) ||
-		(sink->last_pkt != PE_EVT_RCVD_SOFT_RESET)) {
-		snkpe_update_state(sink, PE_SNK_SELECT_CAPABILITY);
-		sink->resend_cap = true;
-		schedule_work(&sink->timer_work);
-	} else
-		sink->request_timer_expired = false;
-}
-
-static void sink_request_timer(unsigned long data)
-{
-	struct sink_port_pe *sink = (struct sink_port_pe *) data;
-
-	sink->request_timer_expired = true;
-	wake_up(&sink->wq_req);
-}
-
-static void sinkpe_no_response_timer(unsigned long data)
-{
-	struct sink_port_pe *sink_pe = (struct sink_port_pe *) data;
-
-	sink_pe->no_response_timer_expired  = true;
-
-	schedule_work(&sink_pe->timer_work);
-}
-
-static void sinkpe_handle_error_recovery(struct sink_port_pe *sink)
-{
-	snkpe_update_state(sink, ERROR_RECOVERY);
-	policy_send_packet(&sink->p, NULL, 0, PD_CMD_PROTOCOL_RESET,
-				PE_EVT_SEND_PROTOCOL_RESET);
-	sink->no_response_timer_expired = false;
-	pr_err("SNKPE: No Response timer expired, going to error recovery\n");
-	pe_notify_policy_status_changed(&sink->p,
-			POLICY_TYPE_SINK, PE_STATUS_CHANGE_PD_FAIL);
-}
-
-/* This is the main task worker for sink pe */
-static void snkpe_task_worker(struct work_struct *work)
-{
-	struct sink_port_pe *sink = container_of(work,
-					struct sink_port_pe,
-					timer_work);
-
-	if (sink->hard_reset_count > HARD_RESET_COUNT_N &&
-		sink->no_response_timer_expired) {
-		return sinkpe_handle_error_recovery(sink);
-	}
-
-	pr_err("SNKPE: %s: state = %d\n", __func__, sink->cur_state);
-	switch (sink->cur_state) {
-	case PE_SNK_STARTUP:
-	case PE_SNK_DISCOVERY:
-		sink->last_pkt = 0;
-		if (sink->is_sink_cable_connected)
-			snkpe_handle_startup(sink);
-		break;
-	case PE_SNK_HARD_RESET:
-		if (sink->hard_reset_count <= HARD_RESET_COUNT_N)
-			snkpe_handle_sink_hard_reset(sink);
-		else if (sink->hard_reset_count > HARD_RESET_COUNT_N &&
-			sink->no_response_timer_expired)
-			return sinkpe_handle_error_recovery(sink);
-		break;
-	case PE_SNK_SELECT_CAPABILITY:
-		if (sink->resend_cap)
-			snkpe_handle_select_capability_state(sink,
-							&sink->prev_pkt);
-		sink_handle_select_cap(sink);
-		break;
-	case PE_SNK_TRANSITION_SINK:
-		sink_handle_transition_sink(sink);
-		break;
-	case PE_PRS_SNK_SRC_TRANSITION_TO_OFF:
-		snkpe_handle_pss_transition_off(sink);
-		break;
-	case PE_PRS_SNK_SRC_SEND_PR_SWAP:
-		snkpe_handle_send_swap(sink);
-		break;
-	case PE_DRS_DFP_UFP_SEND_DR_SWAP:
-	case PE_DRS_UFP_DFP_SEND_DR_SWAP:
-		snkpe_handle_after_dr_swap_sent(sink);
-		break;
-	case PE_DRS_DFP_UFP_ACCEPT_DR_SWAP:
-	case PE_DRS_UFP_DFP_ACCEPT_DR_SWAP:
-		snkpe_handle_after_dr_swap_accept(sink);
-		break;
-	default:
-		pr_warn("SNKPE: got state %d\n", sink->cur_state);
-		break;
-	}
-}
-
-static void sinkpe_reset_timers(struct sink_port_pe *sink)
-{
-	del_timer_sync(&sink->no_response_timer);
-	del_timer_sync(&sink->snk_request_timer);
-}
-
-static void sink_do_reset(struct sink_port_pe *pe)
-{
-	snkpe_do_prot_reset(pe);
-
-	/* re-init all the timers */
-	snkpe_reinitialize_completion(pe);
-	if (timer_pending(&pe->snk_request_timer)) {
-		del_timer_sync(&pe->snk_request_timer);
-		pe->request_timer_expired = true;
-		wake_up(&pe->wq_req);
-	}
-
-	if (timer_pending(&pe->no_response_timer))
-		del_timer_sync(&pe->no_response_timer);
-
-}
-
-static void sink_handle_src_hard_reset(struct sink_port_pe *pe)
-{
-
-	sink_do_reset(pe);
-	/* restart the no response timer */
-	mod_timer(&pe->no_response_timer,
-				msecs_to_jiffies(TYPEC_NO_RESPONSE_TIMER));
-	pe->hard_reset_count = 0;
-}
-
-static int sink_port_policy_rcv_cmd(struct policy *p, enum pe_event evt)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-	int ret = 0;
-
-	switch (evt) {
-	case PE_EVT_RCVD_HARD_RESET:
-		/* If sink pe is already in reset state, ignore this*/
-		if (sink->cur_state == PE_SNK_HARD_RESET)
-			break;
-
-		sink->last_pkt = evt;
-		sink_handle_src_hard_reset(sink);
-		snkpe_update_state(sink, PE_SNK_STARTUP);
-		schedule_work(&sink->timer_work);
-		break;
-	case PE_EVT_RCVD_HARD_RESET_COMPLETE:
-		pr_err("SNKPE: RCVD PE_EVT_RCVD_HARD_RESET_COMPLETE\n");
-		if (sink->cur_state == PE_SNK_HARD_RESET) {
-			sink->hard_reset_complete = true;
-			wake_up(&sink->wq);
-		} else if ((sink->cur_state == PE_SNK_STARTUP
-			|| sink->cur_state == PE_SNK_WAIT_FOR_CAPABILITIES)
-				&& !sink->hard_reset_complete) {
-			/* Reset complete got timeout and sink is waiting
-			 *for src_cap, ignore this event.
-			 */
-			sink->hard_reset_complete = true;
-			break;
-		} else {
-			/* This is due to auto generated hardreset by Hw. */
-			/* reset sink */
-			sink_do_reset(sink);
-			snkpe_update_state(sink, PE_SNK_STARTUP);
-			schedule_work(&sink->timer_work);
-		}
-		break;
-	case PE_EVT_RCVD_SOFT_RESET:
-		ret = snkpe_do_prot_reset(sink);
-		sink->last_pkt = evt;
-		sink_do_reset(sink);
-		policy_send_packet(&sink->p, NULL, 0,
-				PD_CTRL_MSG_ACCEPT, PE_EVT_SEND_ACCEPT);
-		snkpe_update_state(sink, PE_SNK_SOFT_RESET);
-		break;
-	default:
-		pr_err("SNKPE: %s evt - %d\n", __func__, evt);
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-static int sink_port_policy_rcv_pkt(struct policy *p, struct pd_packet *pkt,
-				enum pe_event evt)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-
-	pr_debug("SNKPE:%s: received evt=%d\n", __func__, evt);
-	if (evt != PE_EVT_RCVD_GOODCRC)
-		sink->last_pkt = evt;
-
-	switch (evt) {
-	case PE_EVT_RCVD_SRC_CAP:
-		if (!completion_done(&sink->wct_complete))
-			complete(&sink->wct_complete);
-		/* Process ScrcCap if sink pe is waiting for caps */
-		if (sink->cur_state != PE_SNK_HARD_RESET ||
-			sink->cur_state != PE_SNK_TRANSITION_TO_DEFAULT)
-			sink_handle_src_cap(sink, pkt);
-		break;
-	case PE_EVT_RCVD_GET_SINK_CAP:
-		return snkpe_handle_give_snk_cap_state(sink);
-
-	case PE_EVT_RCVD_ACCEPT:
-	case PE_EVT_RCVD_REJECT:
-	case PE_EVT_RCVD_WAIT:
-		if (sink->cur_state == PE_SNK_SELECT_CAPABILITY) {
-			complete(&sink->srt_complete);
-			sink_handle_accept_reject_wait(sink, evt);
-
-		} else if (sink->cur_state == PE_SNK_SEND_SOFT_RESET) {
-			/* Move to start-up */
-			snkpe_update_state(sink, PE_SNK_STARTUP);
-
-		} else if (sink->cur_state == PE_PRS_SNK_SRC_SEND_PR_SWAP
-			|| sink->cur_state == PE_DRS_UFP_DFP_SEND_DR_SWAP
-			|| sink->cur_state == PE_DRS_DFP_UFP_SEND_DR_SWAP) {
-			/* unblock the waiting thread */
-			complete(&sink->srt_complete);
-		}
-		break;
-	case PE_EVT_RCVD_PS_RDY:
-		/* Unblock the task worker thread waiting for PS_RDY*/
-		if (sink->cur_state == PE_SNK_TRANSITION_SINK)
-			complete(&sink->pstt_complete);
-		else if (sink->cur_state == PE_PRS_SNK_SRC_TRANSITION_TO_OFF)
-			complete(&sink->pssoff_complete);
-		else
-			pr_warn("SNKPE: Got PSRdy in wrong state=%d\n",
-					sink->cur_state);
-		break;
-	case PE_EVT_RCVD_PING:
-		break;
-	case PE_EVT_RCVD_GOTOMIN:
-		snkpe_update_state(sink, PE_SNK_TRANSITION_SINK);
-		schedule_work(&sink->timer_work);
-		break;
-	case PE_EVT_RCVD_GOODCRC:
-		snkpe_received_msg_good_crc(sink);
-		break;
-	case PE_EVT_RCVD_PR_SWAP:
-		snkpe_handle_rcv_pr_swap(sink);
-		break;
-	case PE_EVT_RCVD_DR_SWAP:
-		snkpe_handle_rcv_dr_swap(sink);
-		break;
-	default:
-		pr_warn("SNKPE: Not intersted in (%d) event\n", evt);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int snkpe_start(struct sink_port_pe *sink)
-{
-	enum cable_state sink_cable_state;
-
-	pr_debug("SNKPE: %s\n", __func__);
-
-	/*---------- Start of Sink Port PE --------------*/
-	/* get the sink_cable_state, in case of boot with cable */
-	snkpe_reset_params(sink);
-	sink_cable_state = policy_get_cable_state(&sink->p,
-					CABLE_TYPE_CONSUMER);
-	if (sink_cable_state < 0) {
-		pr_err("SNKPE: Error in getting vbus state!\n");
-		return sink_cable_state;
-	}
-	if (sink_cable_state == CABLE_ATTACHED)
-		sink->is_sink_cable_connected = true;
-	else
-		sink->is_sink_cable_connected = false;
-
-	if (!sink->is_sink_cable_connected) {
-		mutex_lock(&sink->snkpe_state_lock);
-		sink->cur_state = PE_SNK_STARTUP;
-		mutex_unlock(&sink->snkpe_state_lock);
-		return snkpe_do_prot_reset(sink);
-	}
-
-	/* move the state from PE_SNK_STARTUP to PE_SNK_DISCOVERY */
-	snkpe_update_state(sink, PE_SNK_DISCOVERY);
-
-	schedule_work(&sink->timer_work);
-
-	return 0;
-}
-
-static inline int sink_port_policy_start(struct policy *p)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-
-	pr_debug("SNKPE: %s\n", __func__);
-	mutex_lock(&sink->snkpe_state_lock);
-	p->state = POLICY_STATE_ONLINE;
-	sink->cur_state = PE_SNK_STARTUP;
-	sink->hard_reset_complete = true;
-	mutex_unlock(&sink->snkpe_state_lock);
-	return snkpe_start(sink);
-}
-
-static int sink_port_policy_stop(struct policy *p)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-
-	pr_debug("SNKPE: %s\n", __func__);
-	/* reset HardResetCounter to zero upon vbus disconnect.
-	 */
-	mutex_lock(&sink->snkpe_state_lock);
-	sink->hard_reset_count = 0;
-	p->status = POLICY_STATUS_UNKNOWN;
-	p->state = POLICY_STATE_OFFLINE;
-	sink->is_sink_cable_connected = false;
-	mutex_unlock(&sink->snkpe_state_lock);
-	policy_set_pd_state(p, false);
-
-	/* clear any pending completions */
-	sink_do_reset(sink);
-	sinkpe_reset_timers(sink);
-	cancel_work_sync(&sink->timer_work);
-	cancel_work_sync(&sink->request_timer);
-	sink->resend_cap = 0;
-	sink->last_pkt = 0;
-	snkpe_reinitialize_completion(sink);
-	snkpe_update_state(sink, PE_SNK_STARTUP);
-	mutex_lock(&sink->snkpe_state_lock);
-	sink->cur_state = PE_SNK_STARTUP;
-	mutex_unlock(&sink->snkpe_state_lock);
-
-	return 0;
-}
-
-struct policy *sink_port_policy_init(struct policy_engine *pe)
-{
-	struct sink_port_pe *snkpe;
-	struct policy *p;
-
-	if (!pe)
-		return ERR_PTR(-EINVAL);
-
-	snkpe = kzalloc(sizeof(*snkpe), GFP_KERNEL);
-	if (!snkpe)
-		return ERR_PTR(-ENOMEM);
-
-	INIT_WORK(&snkpe->timer_work, snkpe_task_worker);
-	INIT_WORK(&snkpe->request_timer, sink_request_timer_work);
-	init_waitqueue_head(&snkpe->wq);
-	init_waitqueue_head(&snkpe->wq_req);
-
-	p = &snkpe->p;
-	p->type = POLICY_TYPE_SINK;
-	p->state = POLICY_STATE_OFFLINE;
-	p->status = POLICY_STATUS_UNKNOWN;
-	p->pe = pe;
-	p->rcv_request = sink_port_policy_rcv_request;
-	p->rcv_pkt = sink_port_policy_rcv_pkt;
-	p->rcv_cmd = sink_port_policy_rcv_cmd;
-	p->start = sink_port_policy_start;
-	p->stop = sink_port_policy_stop;
-	p->exit = sink_port_policy_exit;
-	setup_timer(&snkpe->no_response_timer, sinkpe_no_response_timer,
-					(unsigned long) snkpe);
-	setup_timer(&snkpe->snk_request_timer, sink_request_timer,
-					(unsigned long) snkpe);
-
-	init_completion(&snkpe->wct_complete);
-	init_completion(&snkpe->srt_complete);
-	init_completion(&snkpe->pstt_complete);
-	init_completion(&snkpe->sat_complete);
-	init_completion(&snkpe->pssoff_complete);
-	mutex_init(&snkpe->snkpe_state_lock);
-
-	return p;
-
-}
-EXPORT_SYMBOL_GPL(sink_port_policy_init);
-
-static void sink_port_policy_exit(struct policy *p)
-{
-	struct sink_port_pe *snkpe;
-
-	if (p) {
-		snkpe = container_of(p, struct sink_port_pe, p);
-		kfree(snkpe);
-	}
-}
-
-MODULE_AUTHOR("Albin B <albin.bala.krishnan@intel.com>");
-MODULE_DESCRIPTION("PD Sink Port Policy Engine");
-MODULE_LICENSE("GPL v2");
Index: b/drivers/usb/typec/pd/sink_port_pe.h
===================================================================
--- a/drivers/usb/typec/pd/sink_port_pe.h	2016-03-08 16:32:19.288901181 -0800
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,123 +0,0 @@
-#ifndef __SINK_PORT_PE__H__
-#define __SINK_PORT_PE__H__
-
-#include "policy_engine.h"
-
-#define SNK_FSPDO_VOLT_SHIFT		10
-
-#define SNK_FSPDO_FIXED_SUPPLY		(3 << 30)
-#define SNK_FSPDO_DUAL_ROLE_PWR		(1 << 29)
-#define SNK_FSPDO_HIGHTER_CAPABILITY	(1 << 28)
-#define SNK_FSPDO_EXT_POWERED		(1 << 27)
-#define SNK_FSPDO_USB_COMM_CAPABLE	(1 << 26)
-#define SNK_FSPDO_DATA_ROLE_SWAP	(1 << 25)
-#define SNK_FSPDO_RESERVED		(3 << 20)
-#define SNK_FSPDO_VOLTAGE		(0x3FF << SNK_FSPDO_VOLT_SHIFT)
-#define SNK_FSPDO_MAX_CURRENT		(0x3FF << 0)
-
-#define IS_DUAL_ROLE_POWER(x)	(x & SNK_FSPDO_DUAL_ROLE_PWR)
-#define IS_USB_SUSPEND_SUPP(x)	(x & SNK_FSPDO_HIGHTER_CAPABILITY)
-#define IS_EXT_POWERED(x)	(x & SNK_FSPDO_EXT_POWERED)
-#define IS_USB_COMM_CAP(x)	(x & SNK_FSPDO_USB_COMM_CAPABLE)
-#define IS_DATA_ROLE_SWAP(x)	(x & SNK_FSPDO_DATA_ROLE_SWAP)
-
-/* returns in mV */
-#define DATA_OBJ_TO_VOLT(x)	(((x & SNK_FSPDO_VOLTAGE) >>	\
-					SNK_FSPDO_VOLT_SHIFT) * 50)
-/* returns in mA */
-#define DATA_OBJ_TO_CURRENT(x)	((x & SNK_FSPDO_MAX_CURRENT) * 10)
-
-#define VOLT_TO_DATA_OBJ(x)	(((x / 50) << SNK_FSPDO_VOLT_SHIFT) &	\
-					SNK_FSPDO_VOLTAGE)
-#define CURRENT_TO_DATA_OBJ(x)	((x / 10) & SNK_FSPDO_MAX_CURRENT)
-
-#define REQ_DOBJ_OBJ_POS_SHIFT		28
-#define REQ_DOBJ_GB_FLAG_SHIFT		27
-#define REQ_DOBJ_CAP_MISMATCH_SHIFT	26
-#define REQ_DOBJ_USB_COMM_CAPABLE_SHIFT	25
-#define REQ_DOBJ_NO_USB_SUSPEND_SHIFT	24
-#define REQ_DOBJ_OPERATING_CUR_SHIFT	10
-#define REQ_DOBJ_MAX_OP_CUR_SHIFT	0
-
-#define REQ_DOBJ_OBJ_POSITION		(7 << REQ_DOBJ_OBJ_POS_SHIFT)
-#define REQ_DOBJ_GIVEBACK_FLAG		(1 << REQ_DOBJ_GB_FLAG_SHIFT)
-#define REQ_DOBJ_CAP_MISMATCH		(1 << REQ_DOBJ_CAP_MISMATCH_SHIFT)
-#define REQ_DOBJ_USB_COMM_CAPABLE	(1 << REQ_DOBJ_USB_COMM_CAPABLE_SHIFT)
-#define REQ_DOBJ_NO_USB_SUSPEND		(1 << REQ_DOBJ_NO_USB_SUSPEND_SHIFT)
-#define REQ_DOBJ_OPERATING_CUR		(0x3FF << REQ_DOBJ_OPERATING_CUR_SHIFT)
-#define REQ_DOBJ_MAX_OPERATING_CUR	(0x3FF << REQ_DOBJ_MAX_OP_CUR_SHIFT)
-
-#define TYPEC_SENDER_RESPONSE_TIMER	30 /* min: 24mSec; max: 30mSec */
-#define TYPEC_SINK_WAIT_CAP_TIMER	620 /* min 310mSec; max: 620mSec */
-#define TYPEC_NO_RESPONSE_TIMER		5500 /* min 4.5Sec; max: 5.5Sec */
-#define TYPEC_PS_TRANSITION_TIMER	550 /* min 450mSec; max: 550mSec */
-#define TYPEC_SINK_ACTIVITY_TIMER	150 /* min 120mSec; max: 150mSec */
-#define TYPEC_SINK_REQUEST_TIMER	100 /* min 100mSec; max: ? */
-#define TYPEC_PS_SRC_OFF_TIMER		920 /* min 750mSec; max: 920mSec */
-#define TYPEC_HARD_RESET_TIMER		5 /* max: 5mSec */
-#define TYPEC_HARD_RESET_COMPLETE_TIMER	5 /* max: 5mSec */
-#define HARD_RESET_COUNT_N		2
-
-enum {
-	CHRGR_UNKNOWN,
-	CHRGR_SET_HZ,
-	CHRGR_ENABLE,
-};
-
-struct snk_cable_event {
-	struct list_head node;
-	bool vbus_state;
-};
-
-enum snkpe_timeout {
-	UNKNOWN_TIMER,
-	SINK_WAIT_CAP_TIMER,
-	SINK_ACTIVITY_TIMER,
-	SINK_REQUEST_TIMER,
-	PS_TRANSITION_TIMER,
-	NO_RESPONSE_TIMER,
-	SENDER_RESPONSE_TIMER,
-	PS_SRC_OFF_TIMER,
-};
-
-struct req_cap {
-	u8 obj_pos;
-	u32 op_ma;
-	u32 max_ma;
-	u32 mv;
-	bool cap_mismatch;
-};
-
-struct sink_port_pe {
-	struct policy p;
-	struct pd_packet prev_pkt;
-	struct completion wct_complete; /* wait cap timer */
-	struct completion srt_complete; /* sender response timer */
-	struct completion pstt_complete; /* PS Transition timer */
-	struct completion sat_complete; /* Sink Activity timer */
-	struct completion pssoff_complete; /* PS Source Off timer */
-	struct mutex snkpe_state_lock;
-	struct timer_list no_response_timer;
-	struct timer_list snk_request_timer;
-	struct work_struct timer_work; /* sink pe worker thread */
-	struct work_struct request_timer; /* snk request timer on ready state */
-	struct req_cap rcap;
-	wait_queue_head_t wq;
-	wait_queue_head_t wq_req;
-	enum pe_event last_pkt;
-	enum pe_states cur_state;
-	enum snkpe_timeout timeout;
-	u8 hard_reset_count;
-	unsigned resend_cap:1;
-	unsigned hard_reset_complete:1;
-	unsigned is_sink_cable_connected:1;
-	unsigned request_timer_expired:1;
-	unsigned no_response_timer_expired:1;
-
-	/* Port partner caps */
-	unsigned pp_is_dual_prole:1;
-	unsigned pp_is_dual_drole:1;
-	unsigned pp_is_ext_pwrd:1;
-};
-
-#endif /* __SINK_PORT_PE__H__ */
Index: b/drivers/usb/typec/pd/src_port_pe.c
===================================================================
--- a/drivers/usb/typec/pd/src_port_pe.c	2016-03-08 16:32:22.748936956 -0800
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,1046 +0,0 @@
-/*
- * src_port_pe.c: Intel USB Power Delivery Source Port Policy Engine
- *
- * Copyright (C) 2015 Intel Corporation
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Seee the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- * Author: Venkataramana Kotakonda <venkataramana.kotakonda@intel.com>
- */
-
-#include <linux/slab.h>
-#include <linux/export.h>
-#include <linux/delay.h>
-#include "message.h"
-#include "policy_engine.h"
-
-#define LOG_TAG "src_pe"
-#define log_info(format, ...) \
-	pr_info(LOG_TAG":%s:"format"\n", __func__, ##__VA_ARGS__)
-#define log_dbg(format, ...) \
-	pr_debug(LOG_TAG":%s:"format"\n", __func__, ##__VA_ARGS__)
-#define log_err(format, ...) \
-	pr_err(LOG_TAG":%s:"format"\n", __func__, ##__VA_ARGS__)
-#define log_warn(format, ...)	\
-	pr_warn(LOG_TAG":%s:"format"\n", __func__, ##__VA_ARGS__)
-
-#define MAX_CMD_RETRY	50
-#define TYPEC_SEND_SRC_CAP_TIME	200 /* 200 mSec */
-#define TYPEC_SRC_ACTIVITY_TIME	40 /* 40 mSec */
-
-#define VOLT_TO_CAP_DATA_OBJ(x)		(x / 50)
-#define CURRENT_TO_CAP_DATA_OBJ(x)	(x / 10)
-
-#define TYPEC_SENDER_RESPONSE_TIMER     30 /* min: 24mSec; max: 30mSec */
-#define TYPEC_PS_SRC_ON_TIMER		480 /* min: 390mSec; max: 480mSec */
-#define TYPEC_PS_SRC_OFF_TIMER		750 /*750mSec*/
-
-struct src_port_pe {
-	struct mutex pe_lock;
-	struct policy p;
-	int state;
-	struct completion srt_complete; /* sender response timer */
-	struct completion psso_complete; /* power supply source on timer */
-	struct power_cap pcap;
-	struct delayed_work start_comm;
-	struct work_struct msg_work;
-	int cmd_retry;
-	int vbus_retry_cnt;
-	enum pe_event last_rcv_evt;
-	unsigned got_snk_caps:1;
-	unsigned is_pd_configured:1;
-	/* port partner caps */
-	unsigned pp_is_dual_drole:1;
-	unsigned pp_is_dual_prole:1;
-	unsigned pp_is_ext_pwrd:1;
-};
-
-/* Source policy engine states */
-enum src_pe_state {
-	SRC_PE_STATE_UNKNOWN = -1,
-	SRC_PE_STATE_NONE,
-	SRC_PE_STATE_SRCCAP_SENT,
-	SRC_PE_STATE_SRCCAP_GCRC,
-	SRC_PE_STATE_ACCEPT_SENT,
-	SRC_PE_STATE_PS_RDY_SENT,
-	SRC_PE_STATE_PD_CONFIGURED,
-	SRC_PE_STATE_PD_FAILED,
-};
-
-static inline int src_pe_get_power_cap(struct src_port_pe *src_pe,
-				struct power_cap *pcap)
-{
-	return policy_get_srcpwr_cap(&src_pe->p, pcap);
-}
-
-static void src_pe_reset_timers(struct src_port_pe *src_pe)
-{
-	complete(&src_pe->srt_complete);
-	complete(&src_pe->psso_complete);
-	reinit_completion(&src_pe->srt_complete);
-	reinit_completion(&src_pe->psso_complete);
-
-}
-
-static void src_pe_reset_policy_engine(struct src_port_pe *src_pe)
-{
-	src_pe->state = SRC_PE_STATE_NONE;
-	src_pe->pcap.mv = 0;
-	src_pe->pcap.ma = 0;
-
-	/* By default dual data role is enabled*/
-	src_pe->pp_is_dual_drole = 1;
-	/* By default dual power role is enabled*/
-	src_pe->pp_is_dual_prole = 1;
-	src_pe->pp_is_ext_pwrd = 0;
-	src_pe->got_snk_caps = 0;
-	src_pe->is_pd_configured = 0;
-	src_pe_reset_timers(src_pe);
-}
-
-static void src_pe_do_pe_reset_on_error(struct src_port_pe *src_pe)
-{
-	mutex_lock(&src_pe->pe_lock);
-	src_pe_reset_policy_engine(src_pe);
-	mutex_unlock(&src_pe->pe_lock);
-	log_info("Sending HARD_RESET");
-	policy_send_packet(&src_pe->p, NULL, 0, PD_CMD_HARD_RESET,
-						PE_EVT_SEND_HARD_RESET);
-
-	/* Schedule worker to send src_cap*/
-	schedule_delayed_work(&src_pe->start_comm, 0);
-}
-
-/* PR_SWAP fail handling is different from reset on timeout error.
- * During PR_SWAP as the CC pull-up is changed, on failure there is
- * no guarentee that this device still act as source. Hence this
- * failure should be treated as disconnect and start toggle in DRP.
- */
-static void src_pe_handle_pr_swap_fail(struct src_port_pe *src_pe)
-{
-	mutex_lock(&src_pe->pe_lock);
-	src_pe_reset_policy_engine(src_pe);
-	mutex_unlock(&src_pe->pe_lock);
-	log_info("Notifying PR_SWAP_FAIL to PE");
-	pe_notify_policy_status_changed(&src_pe->p,
-			POLICY_TYPE_SOURCE, PE_STATUS_CHANGE_PR_SWAP_FAIL);
-}
-
-static int src_pe_send_srccap_cmd(struct src_port_pe *src_pe)
-{
-	int ret;
-	struct pd_fixed_supply_pdo pdo;
-	struct power_cap pcap;
-
-	log_dbg("Sending SrcCap");
-	ret = src_pe_get_power_cap(src_pe, &pcap);
-	if (ret) {
-		log_err("Error in getting power capabilities\n");
-		return ret;
-	}
-	memset(&pdo, 0, sizeof(struct pd_fixed_supply_pdo));
-	pdo.max_cur = CURRENT_TO_CAP_DATA_OBJ(pcap.ma); /* In 10mA units */
-	pdo.volt = VOLT_TO_CAP_DATA_OBJ(pcap.mv); /* In 50mV units */
-	pdo.peak_cur = 0; /* No peek current supported */
-	pdo.dual_role_pwr = 1; /* Dual pwr role supported */
-	pdo.data_role_swap = 1; /*Dual data role*/
-	pdo.usb_comm = 1; /* USB communication supported */
-
-	ret = policy_send_packet(&src_pe->p, &pdo, 4,
-				PD_DATA_MSG_SRC_CAP, PE_EVT_SEND_SRC_CAP);
-	return ret;
-}
-
-static inline int src_pe_send_accept_cmd(struct src_port_pe *src_pe)
-{
-
-	return policy_send_packet(&src_pe->p, NULL, 0,
-				PD_CTRL_MSG_ACCEPT, PE_EVT_SEND_ACCEPT);
-}
-
-static inline int src_pe_send_psrdy_cmd(struct src_port_pe *src_pe)
-{
-
-	return policy_send_packet(&src_pe->p, NULL, 0,
-				PD_CTRL_MSG_PS_RDY, PE_EVT_SEND_PS_RDY);
-}
-
-static inline int src_pe_send_get_snk_cap_cmd(struct src_port_pe *src_pe)
-{
-
-	return policy_send_packet(&src_pe->p, NULL, 0,
-			PD_CTRL_MSG_GET_SINK_CAP, PE_EVT_SEND_GET_SINK_CAP);
-}
-
-static int src_pe_handle_snk_source_off(struct src_port_pe *src_pe)
-{
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->state = PE_PRS_SRC_SNK_SOURCE_OFF;
-	mutex_unlock(&src_pe->pe_lock);
-
-	return src_pe_send_psrdy_cmd(src_pe);
-}
-
-/* This function will wait for TYPEC_PS_SRC_OFF_TIMER to disbale vbus.
- * return 0 on success and -ETIME on timeout.
- */
-static int src_pe_sink_transition_wait_for_vbus_off(struct src_port_pe *src_pe)
-{
-	int max_cnt = TYPEC_PS_SRC_OFF_TIMER / TYPEC_SRC_ACTIVITY_TIME;
-	int cnt;
-	int ret = -ETIME;
-
-	if (!policy_get_vbus_state(&src_pe->p))
-		return 0;
-
-	for (cnt = 0; cnt < max_cnt; cnt++) {
-		log_dbg("Waiting for vbus to off, cnt=%d\n", cnt);
-		msleep(TYPEC_SRC_ACTIVITY_TIME);
-		if (!policy_get_vbus_state(&src_pe->p)) {
-			ret = 0;
-			break;
-		}
-	}
-
-	return ret;
-}
-
-static int src_pe_handle_sink_transition_to_off(struct src_port_pe *src_pe)
-{
-	int ret = 0;
-
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->state = PE_PRS_SRC_SNK_TRANSITION_TO_OFF;
-	mutex_unlock(&src_pe->pe_lock);
-
-	/* Pull-down CC (enable Rd) and Vbus 5V disable */
-	ret = policy_set_power_role(&src_pe->p, POWER_ROLE_SWAP);
-	if (ret < 0) {
-		log_err("Error in set pwr role swap %d\n", ret);
-		goto trans_to_swap_fail;
-	}
-
-	ret = src_pe_sink_transition_wait_for_vbus_off(src_pe);
-	if (ret < 0) {
-		log_err("Failed to disable the VBUS, HARD_RESET\n");
-		goto trans_to_swap_fail;
-	}
-
-	ret = src_pe_handle_snk_source_off(src_pe);
-	if (ret < 0) {
-		log_err("Failed to send PD_RDY\n");
-		goto trans_to_swap_fail;
-	}
-
-	/* wait for ps_rdy from port partner. */
-	schedule_work(&src_pe->msg_work);
-
-	return 0;
-
-trans_to_swap_fail:
-	/* As role swap accepted, handle pr swap fail*/
-	src_pe_handle_pr_swap_fail(src_pe);
-	return ret;
-}
-
-static void src_pe_handle_dr_swap_transition(struct src_port_pe *src_pe,
-			enum data_role to_role)
-{
-	int ret;
-
-	mutex_lock(&src_pe->pe_lock);
-	if (to_role == DATA_ROLE_UFP)
-		src_pe->state = PE_DRS_DFP_UFP_CHANGE_TO_UFP;
-	else
-		src_pe->state = PE_DRS_UFP_DFP_CHANGE_TO_DFP;
-	mutex_unlock(&src_pe->pe_lock);
-
-	log_dbg("Changing data role to %d", to_role);
-	ret = policy_set_data_role(&src_pe->p, to_role);
-	if (ret) {
-		log_err("Failed to change the data role");
-		/*Reset pe as role swap failed*/
-		src_pe_do_pe_reset_on_error(src_pe);
-		return;
-	}
-	log_dbg("Data role changed to %d", to_role);
-	pe_notify_policy_status_changed(&src_pe->p,
-			POLICY_TYPE_SOURCE, PE_STATUS_CHANGE_DR_CHANGED);
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->state = SRC_PE_STATE_PD_CONFIGURED;
-	mutex_unlock(&src_pe->pe_lock);
-}
-
-static void src_pe_handle_after_dr_swap_sent(struct src_port_pe *src_pe)
-{
-	unsigned long timeout;
-	int ret, state;
-
-	/* Initialize and run SenderResponseTimer */
-	timeout = msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER);
-	/* unblock this once Accept msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&src_pe->srt_complete, timeout);
-	mutex_lock(&src_pe->pe_lock);
-	if (ret == 0) {
-		log_err("SRT time expired, move to READY");
-		goto dr_sent_error;
-	}
-
-	if (src_pe->last_rcv_evt != PE_EVT_RCVD_ACCEPT) {
-		log_info("DR swap not accepted!!");
-		goto dr_sent_error;
-	}
-	state = src_pe->state;
-	mutex_unlock(&src_pe->pe_lock);
-	log_dbg("DR swap accepted by port partner");
-	if (state == PE_DRS_DFP_UFP_SEND_DR_SWAP)
-		src_pe_handle_dr_swap_transition(src_pe, DATA_ROLE_UFP);
-	else if (state == PE_DRS_UFP_DFP_SEND_DR_SWAP)
-		src_pe_handle_dr_swap_transition(src_pe, DATA_ROLE_DFP);
-	else
-		log_err("Unexpected state=%d !!!\n", state);
-	goto dr_sent_end;
-
-dr_sent_error:
-	src_pe->state = SRC_PE_STATE_PD_CONFIGURED;
-	mutex_unlock(&src_pe->pe_lock);
-dr_sent_end:
-	reinit_completion(&src_pe->srt_complete);
-	return;
-}
-
-static int src_pe_handle_trigger_dr_swap(struct src_port_pe *src_pe)
-{
-	enum data_role drole;
-
-	if (!src_pe->pp_is_dual_drole) {
-		log_dbg("Port partner doesn't support dual data role");
-		return -EINVAL;
-	}
-
-	drole = policy_get_data_role(&src_pe->p);
-
-	if ((src_pe->state != SRC_PE_STATE_PD_CONFIGURED)
-		|| (drole != DATA_ROLE_UFP && drole != DATA_ROLE_DFP)) {
-		log_dbg("Not processing DR_SWAP request in state=%d",
-				src_pe->state);
-		return -EINVAL;
-	}
-
-	mutex_lock(&src_pe->pe_lock);
-	if (drole == DATA_ROLE_DFP)
-		src_pe->state = PE_DRS_DFP_UFP_SEND_DR_SWAP;
-	else
-		src_pe->state = PE_DRS_UFP_DFP_SEND_DR_SWAP;
-	mutex_unlock(&src_pe->pe_lock);
-	schedule_work(&src_pe->msg_work);
-
-	policy_send_packet(&src_pe->p, NULL, 0,
-			PD_CTRL_MSG_DR_SWAP, PE_EVT_SEND_DR_SWAP);
-
-	return 0;
-}
-
-static void src_pe_handle_after_dr_swap_accept(struct src_port_pe *src_pe)
-{
-	unsigned long timeout;
-	int ret, state;
-
-	/* Initialize and run SenderResponseTimer */
-	timeout = msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER);
-	/* unblock this once Accept msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&src_pe->srt_complete, timeout);
-	if (ret == 0) {
-		log_err("SRT time expired, move to RESET");
-		/*Reset pe as role swap failed*/
-		src_pe_do_pe_reset_on_error(src_pe);
-		goto swap_accept_error;
-	}
-
-
-	mutex_lock(&src_pe->pe_lock);
-	state = src_pe->state;
-	mutex_unlock(&src_pe->pe_lock);
-	log_dbg("GCRC for DR swap accepted");
-	if (state == PE_DRS_DFP_UFP_ACCEPT_DR_SWAP)
-		src_pe_handle_dr_swap_transition(src_pe, DATA_ROLE_UFP);
-	else if (state == PE_DRS_UFP_DFP_ACCEPT_DR_SWAP)
-		src_pe_handle_dr_swap_transition(src_pe, DATA_ROLE_DFP);
-	else
-		log_err("Unexpected state=%d !!!\n", state);
-
-swap_accept_error:
-	reinit_completion(&src_pe->srt_complete);
-}
-
-static void src_pe_handle_rcv_dr_swap(struct src_port_pe *src_pe)
-{
-	enum data_role drole;
-
-	drole = policy_get_data_role(&src_pe->p);
-
-	if ((src_pe->state != SRC_PE_STATE_PD_CONFIGURED)
-		|| ((drole != DATA_ROLE_UFP)
-		&& (drole != DATA_ROLE_DFP))) {
-		log_dbg("Not accepting DR_SWAP request in state=%d",
-				src_pe->state);
-		/* As we are dual data role, donot reject the dr_swap
-		 * request but send wait.
-		 */
-		policy_send_packet(&src_pe->p, NULL, 0,
-			PD_CTRL_MSG_WAIT, PE_EVT_SEND_WAIT);
-		return;
-	}
-
-	mutex_lock(&src_pe->pe_lock);
-	if (drole == DATA_ROLE_DFP)
-		src_pe->state = PE_DRS_DFP_UFP_ACCEPT_DR_SWAP;
-	else
-		src_pe->state = PE_DRS_UFP_DFP_ACCEPT_DR_SWAP;
-	mutex_unlock(&src_pe->pe_lock);
-	schedule_work(&src_pe->msg_work);
-
-	policy_send_packet(&src_pe->p, NULL, 0,
-			PD_CTRL_MSG_ACCEPT, PE_EVT_SEND_ACCEPT);
-
-}
-
-static int
-src_pe_handle_gcrc(struct src_port_pe *src_pe, struct pd_packet *pkt)
-{
-	int ret = 0;
-
-	switch (src_pe->state) {
-	case SRC_PE_STATE_SRCCAP_SENT:
-		mutex_lock(&src_pe->pe_lock);
-		src_pe->state = SRC_PE_STATE_SRCCAP_GCRC;
-		mutex_unlock(&src_pe->pe_lock);
-		log_dbg("SRC_PE_STATE_SRCCAP_SENT -> SRC_PE_STATE_SRCCAP_GCRC");
-		break;
-	case SRC_PE_STATE_ACCEPT_SENT:
-		/* TODO: Enable the 5V  and send PS_DRY */
-		ret = src_pe_send_psrdy_cmd(src_pe);
-		mutex_lock(&src_pe->pe_lock);
-		src_pe->state = SRC_PE_STATE_PS_RDY_SENT;
-		mutex_unlock(&src_pe->pe_lock);
-		log_dbg("SRC_PE_STATE_ACCEPT_SENT -> SRC_PE_STATE_PS_RDY_SENT");
-		break;
-	case SRC_PE_STATE_PS_RDY_SENT:
-		mutex_lock(&src_pe->pe_lock);
-		src_pe->state = SRC_PE_STATE_PD_CONFIGURED;
-		src_pe->p.status = POLICY_STATUS_SUCCESS;
-		src_pe->cmd_retry = 0;
-		src_pe->is_pd_configured = 1;
-		mutex_unlock(&src_pe->pe_lock);
-		cancel_delayed_work_sync(&src_pe->start_comm);
-		log_info("SRC_PE_STATE_PS_RDY_SENT -> SRC_PE_STATE_PD_CONFIGURED");
-
-		/* Schedule worker to get sink caps */
-		schedule_work(&src_pe->msg_work);
-		break;
-	case PE_PRS_SRC_SNK_ACCEPT_PR_SWAP:
-	case PE_PRS_SRC_SNK_SEND_PR_SWAP:
-	case PE_PRS_SRC_SNK_SOURCE_OFF:
-		break;
-	case PE_DRS_DFP_UFP_ACCEPT_DR_SWAP:
-	case PE_DRS_UFP_DFP_ACCEPT_DR_SWAP:
-		complete(&src_pe->srt_complete);
-		break;
-	default:
-		ret = -EINVAL;
-		log_dbg("GCRC received in wrong state=%d\n", src_pe->state);
-		break;
-	}
-
-	return ret;
-}
-
-static int src_pe_handle_request_cmd(struct src_port_pe *src_pe)
-{
-	if ((src_pe->state == SRC_PE_STATE_SRCCAP_SENT)
-		|| (src_pe->state == SRC_PE_STATE_SRCCAP_GCRC)) {
-		/* Send accept for request */
-		src_pe_send_accept_cmd(src_pe);
-		mutex_lock(&src_pe->pe_lock);
-		src_pe->state = SRC_PE_STATE_ACCEPT_SENT;
-		mutex_unlock(&src_pe->pe_lock);
-		log_dbg(" STATE -> SRC_PE_STATE_ACCEPT_SENT\n");
-		return 0;
-	}
-	log_err(" REQUEST MSG received in wrong state!!!\n");
-	return -EINVAL;
-}
-
-static int src_pe_pr_swap_ok(struct src_port_pe *src_pe)
-{
-	int ret;
-
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->state = PE_PRS_SRC_SNK_ACCEPT_PR_SWAP;
-	mutex_unlock(&src_pe->pe_lock);
-	ret = src_pe_send_accept_cmd(src_pe);
-	if (ret) {
-		log_err("Failed to send Accept for dr swap");
-		goto swap_ok_error;
-	}
-	schedule_work(&src_pe->msg_work);
-	return 0;
-
-swap_ok_error:
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->state = SRC_PE_STATE_PD_CONFIGURED;
-	mutex_unlock(&src_pe->pe_lock);
-	return ret;
-}
-
-static int src_pe_handle_pr_swap(struct src_port_pe *src_pe)
-{
-	enum pwr_role prole;
-
-	if (src_pe->state != SRC_PE_STATE_PD_CONFIGURED) {
-		log_err("PR_SWAP cannot process in state =%d",
-					src_pe->state);
-		goto pr_swap_wait;
-	}
-	prole = policy_get_power_role(&src_pe->p);
-	if (prole <= 0) {
-		log_err("Error in getting power role\n");
-		goto pr_swap_wait;
-	}
-
-	if (prole != POWER_ROLE_SOURCE) {
-		log_info("Current Power Role - %d\n", prole);
-		goto pr_swap_wait;
-	}
-	/* As the request is to transition into consumer mode
-	 * should be accepted by default.
-	 */
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->state = PE_PRS_SRC_SNK_EVALUATE_PR_SWAP;
-	mutex_unlock(&src_pe->pe_lock);
-	return src_pe_pr_swap_ok(src_pe);
-
-	/* Wait will be more appropriate than rejecting the pr_swap
-	 * as the current power role is source.
-	 */
-pr_swap_wait:
-	return policy_send_packet(&src_pe->p, NULL, 0,
-				PD_CTRL_MSG_WAIT, PE_EVT_SEND_WAIT);
-
-}
-
-static int src_pe_rcv_request(struct policy *srcp, enum pe_event evt)
-{
-	struct src_port_pe *src_pe = container_of(srcp,
-					struct src_port_pe, p);
-	int ret = 0;
-
-	log_dbg("%s evt %d\n", __func__, evt);
-	switch (evt) {
-	case PE_EVT_SEND_PR_SWAP:
-		if (!src_pe->pp_is_dual_prole) {
-			log_info("Port partner doesnt support pr_swap");
-			break;
-		}
-		if (src_pe->state != SRC_PE_STATE_PD_CONFIGURED) {
-			log_info("Cannot process PR_SWAP in state=%d\n",
-					src_pe->state);
-			break;
-		}
-		mutex_lock(&src_pe->pe_lock);
-		src_pe->state = PE_PRS_SRC_SNK_SEND_PR_SWAP;
-		mutex_unlock(&src_pe->pe_lock);
-		policy_send_packet(&src_pe->p, NULL, 0,
-					PD_CTRL_MSG_PR_SWAP, evt);
-		/* Schedule worker to wait for Accept/Reject and process*/
-		schedule_work(&src_pe->msg_work);
-		break;
-	case PE_EVT_SEND_DR_SWAP:
-		ret = src_pe_handle_trigger_dr_swap(src_pe);
-		break;
-	default:
-		break;
-	}
-
-	return ret;
-}
-
-static void src_pe_handle_snk_cap_rcv(struct src_port_pe *src_pe,
-				struct pd_packet *pkt)
-{
-	struct pd_sink_fixed_pdo *snk_cap;
-
-	snk_cap = (struct pd_sink_fixed_pdo *) &pkt->data_obj[0];
-
-	if (snk_cap->supply_type != SUPPLY_TYPE_FIXED) {
-		log_dbg("Port partner is not a fixed sypply");
-		return;
-	}
-	/* Save sink port caps */
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->pp_is_dual_drole = snk_cap->data_role_swap;
-	src_pe->pp_is_dual_prole = snk_cap->dual_role_pwr;
-	src_pe->pp_is_ext_pwrd = snk_cap->ext_powered;
-	mutex_unlock(&src_pe->pe_lock);
-
-	log_dbg("is_dual_prole=%d, is_dual_drole=%d, is_ext_pwrd=%d",
-			snk_cap->dual_role_pwr, snk_cap->data_role_swap,
-			snk_cap->ext_powered);
-}
-
-static void srcpe_send_default_cap(struct src_port_pe *src)
-{
-	struct pd_sink_fixed_pdo pdo = { 0 };
-
-	/* setting default pdo as vsafe5V with ma = 0 */
-	pdo.max_cur = CURRENT_TO_CAP_DATA_OBJ(0);
-	pdo.volt = VOLT_TO_CAP_DATA_OBJ(5000);
-	policy_send_packet(&src->p, &pdo, 4,
-					PD_DATA_MSG_SINK_CAP,
-					PE_EVT_SEND_SNK_CAP);
-}
-
-static int srcpe_handle_snk_cap_request(struct src_port_pe *src)
-{
-	int ret = 0;
-	int i;
-	struct power_caps pcaps;
-	struct pd_sink_fixed_pdo pdo[MAX_NUM_DATA_OBJ] = { {0} };
-
-	ret = policy_get_snkpwr_caps(&src->p, &pcaps);
-	if (ret < 0) {
-		log_warn("Couldn't get the sink power caps %d\n", ret);
-		srcpe_send_default_cap(src);
-		goto error;
-	}
-
-	/**
-	 * As per PD v1.1 spec except first pdo, all other Fixed Supply Power
-	 * Data Objects shall set bits 29...20 to zero.
-	 */
-	if (pcaps.n_cap > 0) {
-		/*
-		 * FIXME: DPM should provide info on USB capable and
-		 * higher power support required
-		 */
-		pdo[0].data_role_swap = 1;
-		pdo[0].usb_comm = 1;
-		pdo[0].ext_powered = 0;
-		pdo[0].higher_cap = 1;
-		pdo[0].dual_role_pwr = 1;
-
-		if (pcaps.n_cap > MAX_NUM_DATA_OBJ)
-			pcaps.n_cap = MAX_NUM_DATA_OBJ;
-
-		log_warn("DPM needs to be fixed to provide CAPs\n");
-	} else {
-		log_dbg("No PDO's from dpm setting default vasafe5v\n");
-		srcpe_send_default_cap(src);
-		goto error;
-	}
-
-	for (i = 0; i < pcaps.n_cap; i++) {
-		pdo[i].max_cur = CURRENT_TO_CAP_DATA_OBJ(pcaps.pcap[i].ma);
-		pdo[i].volt = VOLT_TO_CAP_DATA_OBJ(pcaps.pcap[i].mv);
-		pdo[i].supply_type = pcaps.pcap[i].psy_type;
-	}
-
-	ret = policy_send_packet(&src->p, pdo, pcaps.n_cap * 4,
-					PD_DATA_MSG_SINK_CAP,
-					PE_EVT_SEND_SNK_CAP);
-	if (ret < 0) {
-		log_err("Error in sending packet!\n");
-		goto error;
-	}
-	log_dbg("PD_DATA_MSG_SINK_CAP sent\n");
-
-error:
-	return ret;
-}
-
-static int srcpe_handle_src_cap_request(struct src_port_pe *src)
-{
-	return src_pe_send_srccap_cmd(src);
-}
-
-static int
-src_pe_rcv_pkt(struct policy *srcp, struct pd_packet *pkt, enum pe_event evt)
-{
-	struct src_port_pe *src_pe = container_of(srcp,
-					struct src_port_pe, p);
-	int ret = 0;
-
-	log_dbg("%s evt %d\n", __func__, evt);
-	switch (evt) {
-	case PE_EVT_RCVD_GOODCRC:
-		ret = src_pe_handle_gcrc(src_pe, pkt);
-		break;
-	case PE_EVT_RCVD_REQUEST:
-		ret = src_pe_handle_request_cmd(src_pe);
-		break;
-	case PE_EVT_RCVD_PR_SWAP:
-		ret = src_pe_handle_pr_swap(src_pe);
-		break;
-	case PE_EVT_RCVD_ACCEPT:
-	case PE_EVT_RCVD_REJECT:
-	case PE_EVT_RCVD_WAIT:
-		if ((src_pe->state == PE_PRS_SRC_SNK_SEND_PR_SWAP)
-			|| (src_pe->state == PE_DRS_UFP_DFP_SEND_DR_SWAP)
-			|| (src_pe->state == PE_DRS_DFP_UFP_SEND_DR_SWAP)) {
-			src_pe->last_rcv_evt = evt;
-			complete(&src_pe->srt_complete);
-		}
-		break;
-
-	case PE_EVT_RCVD_PS_RDY:
-		if (src_pe->state == PE_PRS_SRC_SNK_SOURCE_OFF)
-			complete(&src_pe->psso_complete);
-		break;
-	case PE_EVT_RCVD_SNK_CAP:
-		if (src_pe->state == PE_SRC_GET_SINK_CAP) {
-			mutex_lock(&src_pe->pe_lock);
-			src_pe->state = SRC_PE_STATE_PD_CONFIGURED;
-			mutex_unlock(&src_pe->pe_lock);
-			complete(&src_pe->srt_complete);
-		}
-		src_pe->got_snk_caps = 1;
-		src_pe_handle_snk_cap_rcv(src_pe, pkt);
-		break;
-	case PE_EVT_RCVD_GET_SINK_CAP:
-		ret = srcpe_handle_snk_cap_request(src_pe);
-		break;
-	case PE_EVT_RCVD_GET_SRC_CAP:
-		ret = srcpe_handle_src_cap_request(src_pe);
-		break;
-	case PE_EVT_RCVD_DR_SWAP:
-		src_pe_handle_rcv_dr_swap(src_pe);
-		break;
-	default:
-		ret = -EINVAL;
-		log_info("Not proccessing the event=%d\n", evt);
-	}
-	return ret;
-}
-
-int src_pe_rcv_cmd(struct policy *srcp, enum pe_event evt)
-{
-	struct src_port_pe *src_pe = container_of(srcp,
-					struct src_port_pe, p);
-	int ret = 0;
-
-	switch (evt) {
-	case PE_EVT_RCVD_HARD_RESET:
-		log_info("Receviced HARD_RESET in state=%d\n", src_pe->state);
-		src_pe_reset_policy_engine(src_pe);
-		schedule_delayed_work(&src_pe->start_comm, 0);
-		break;
-	case PE_EVT_RCVD_HARD_RESET_COMPLETE:
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-/* This function will wait for accept/reject from port partner after
- * DR_SWAP sent and  handle the responce.
- */
-static int src_pe_handle_after_prswap_sent(struct src_port_pe *src_pe)
-{
-	unsigned long timeout;
-	int ret;
-
-	/* Initialize and run SenderResponseTimer */
-	timeout = msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER);
-	/* unblock this once Accept msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&src_pe->srt_complete, timeout);
-	mutex_lock(&src_pe->pe_lock);
-	if (ret == 0) {
-		log_err("SRT time expired, move to READY");
-		goto error;
-	}
-	if (src_pe->last_rcv_evt != PE_EVT_RCVD_ACCEPT) {
-		log_info("PR_SWAP not accepted by port partner");
-		goto error;
-	}
-
-	mutex_unlock(&src_pe->pe_lock);
-	ret = src_pe_handle_sink_transition_to_off(src_pe);
-	reinit_completion(&src_pe->srt_complete);
-	return ret;
-
-error:
-	src_pe->state = SRC_PE_STATE_PD_CONFIGURED;
-	mutex_unlock(&src_pe->pe_lock);
-	reinit_completion(&src_pe->srt_complete);
-	return ret;
-}
-
-static int src_pe_snk_source_off_waitfor_psrdy(struct src_port_pe *src_pe)
-{
-	unsigned long timeout;
-	int ret;
-
-	/* Initialize and run PSSourceOnTimer */
-	timeout = msecs_to_jiffies(TYPEC_PS_SRC_OFF_TIMER);
-	/* unblock this once PS_Ready msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&src_pe->psso_complete, timeout);
-	if (ret == 0) {
-		log_err("PSSO time expired during pr_swap");
-		src_pe_handle_pr_swap_fail(src_pe);
-		goto error;
-	}
-
-	/* RR Swap success, set role as sink and switch policy */
-	log_dbg("PE_PRS_SRC_SNK_SOURCE_OFF -> PE_SNK_STARTUP");
-	policy_set_power_role(&src_pe->p, POWER_ROLE_SINK);
-	log_dbg("Notifying power role change\n");
-	pe_notify_policy_status_changed(&src_pe->p,
-			POLICY_TYPE_SOURCE, PE_STATUS_CHANGE_PR_CHANGED);
-error:
-	reinit_completion(&src_pe->psso_complete);
-	return ret;
-}
-
-/* This function will send get_snk_cap and wait for responce.
- * If time out, then re-schedule the msg_worker to resend the get_snk_cap.
- */
-static void src_pe_get_sink_cap(struct src_port_pe *src_pe)
-{
-	unsigned long timeout;
-	int ret;
-
-	/* Get sink caps */
-	src_pe_send_get_snk_cap_cmd(src_pe);
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->cmd_retry++;
-	src_pe->state = PE_SRC_GET_SINK_CAP;
-	mutex_unlock(&src_pe->pe_lock);
-
-	/* Initialize and run sender responce timer */
-	timeout = msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER);
-	ret = wait_for_completion_timeout(&src_pe->srt_complete, timeout);
-	if (ret == 0 || !src_pe->got_snk_caps) {
-		mutex_lock(&src_pe->pe_lock);
-		src_pe->state = SRC_PE_STATE_PD_CONFIGURED;
-		if (src_pe->cmd_retry < MAX_CMD_RETRY) {
-			log_dbg("SnkCap not received, resend get_snk_cap\n");
-			mutex_unlock(&src_pe->pe_lock);
-			schedule_work(&src_pe->msg_work);
-			goto get_snk_cap_timeout;
-		} else{
-			log_err("SnkCap not received, even after max retry\n");
-			src_pe->cmd_retry = 0;
-			mutex_unlock(&src_pe->pe_lock);
-			goto get_sink_cap_error;
-		}
-	}
-	log_dbg("Successfuly got sink caps\n");
-get_sink_cap_error:
-	/* Irrespective of get_sink_cap status, update the
-	 * policy engine as success as PD negotiation is success.
-	 */
-	pe_notify_policy_status_changed(&src_pe->p,
-			POLICY_TYPE_SOURCE, PE_STATUS_CHANGE_PD_SUCCESS);
-get_snk_cap_timeout:
-	reinit_completion(&src_pe->srt_complete);
-}
-
-static void src_pe_msg_worker(struct work_struct *work)
-{
-	struct src_port_pe *src_pe = container_of(work,
-					struct src_port_pe,
-					msg_work);
-
-	switch (src_pe->state) {
-	case PE_PRS_SRC_SNK_SEND_PR_SWAP:
-		src_pe_handle_after_prswap_sent(src_pe);
-		break;
-	case PE_PRS_SRC_SNK_ACCEPT_PR_SWAP:
-		log_dbg("SRC_SNK_ACCEPT_PR_SWAP -> SRC_SNK_TRANSITION_TO_OFF");
-		src_pe_handle_sink_transition_to_off(src_pe);
-		break;
-	case PE_PRS_SRC_SNK_SOURCE_OFF:
-		src_pe_snk_source_off_waitfor_psrdy(src_pe);
-		break;
-	case SRC_PE_STATE_PD_CONFIGURED:
-		if (!src_pe->got_snk_caps)
-			src_pe_get_sink_cap(src_pe);
-		break;
-	case PE_DRS_DFP_UFP_SEND_DR_SWAP:
-	case PE_DRS_UFP_DFP_SEND_DR_SWAP:
-		src_pe_handle_after_dr_swap_sent(src_pe);
-		break;
-	case PE_DRS_DFP_UFP_ACCEPT_DR_SWAP:
-	case PE_DRS_UFP_DFP_ACCEPT_DR_SWAP:
-		src_pe_handle_after_dr_swap_accept(src_pe);
-		break;
-	default:
-		log_err("Unknown state %d\n", src_pe->state);
-		break;
-	}
-}
-
-static void src_pe_start_comm(struct work_struct *work)
-{
-	struct src_port_pe *src_pe = container_of(work,
-					struct src_port_pe,
-					start_comm.work);
-
-	if ((src_pe->state == SRC_PE_STATE_PD_FAILED)
-		|| (src_pe->is_pd_configured)
-		|| (src_pe->p.state == POLICY_STATE_OFFLINE)) {
-		log_info("Not required to send srccap in this state=%d\n",
-				src_pe->state);
-		return;
-	}
-
-	if (!policy_get_vbus_state(&src_pe->p)) {
-		mutex_lock(&src_pe->pe_lock);
-		if (src_pe->vbus_retry_cnt < MAX_CMD_RETRY) {
-			log_dbg("VBUS not present, delay SrcCap\n");
-			schedule_delayed_work(&src_pe->start_comm,
-				msecs_to_jiffies(TYPEC_SRC_ACTIVITY_TIME));
-			src_pe->vbus_retry_cnt++;
-		}
-		mutex_unlock(&src_pe->pe_lock);
-		return;
-	}
-
-	src_pe_send_srccap_cmd(src_pe);
-	mutex_lock(&src_pe->pe_lock);
-	src_pe->state = SRC_PE_STATE_SRCCAP_SENT;
-	src_pe->cmd_retry++;
-	mutex_unlock(&src_pe->pe_lock);
-
-	if (src_pe->cmd_retry < MAX_CMD_RETRY) {
-		log_dbg("Re-scheduling the start_comm after %lu mSec\n",
-				msecs_to_jiffies(TYPEC_SEND_SRC_CAP_TIME));
-		schedule_delayed_work(&src_pe->start_comm,
-				msecs_to_jiffies(TYPEC_SEND_SRC_CAP_TIME));
-	} else {
-		mutex_lock(&src_pe->pe_lock);
-		src_pe->state = SRC_PE_STATE_PD_FAILED;
-		src_pe->p.status = POLICY_STATUS_FAIL;
-		mutex_unlock(&src_pe->pe_lock);
-		log_dbg("Not sending srccap as max re-try reached\n");
-		pe_notify_policy_status_changed(&src_pe->p,
-			POLICY_TYPE_SOURCE, PE_STATUS_CHANGE_PD_FAIL);
-	}
-}
-
-static int src_pe_start_policy_engine(struct policy *p)
-{
-	struct src_port_pe *src_pe = container_of(p,
-					struct src_port_pe, p);
-
-	log_info("IN");
-	mutex_lock(&src_pe->pe_lock);
-	p->state = POLICY_STATE_ONLINE;
-	policy_set_pd_state(p, true);
-	src_pe_reset_policy_engine(src_pe);
-	schedule_delayed_work(&src_pe->start_comm, 0);
-	mutex_unlock(&src_pe->pe_lock);
-	return 0;
-}
-
-static int src_pe_stop_policy_engine(struct policy *p)
-{
-	struct src_port_pe *src_pe = container_of(p,
-					struct src_port_pe, p);
-
-	log_info("IN");
-	cancel_delayed_work_sync(&src_pe->start_comm);
-	mutex_lock(&src_pe->pe_lock);
-	p->state = POLICY_STATE_OFFLINE;
-	p->status = POLICY_STATUS_UNKNOWN;
-	src_pe_reset_policy_engine(src_pe);
-	policy_set_pd_state(p, false);
-	src_pe->cmd_retry = 0;
-	src_pe->vbus_retry_cnt = 0;
-	mutex_unlock(&src_pe->pe_lock);
-	return 0;
-}
-
-static void src_pe_exit(struct policy *p)
-{
-	struct src_port_pe *src_pe = container_of(p,
-					struct src_port_pe, p);
-
-	kfree(src_pe);
-}
-
-static int src_pe_get_port_caps(struct policy *p,
-			struct pe_port_partner_caps *pp_caps)
-{
-	struct src_port_pe *src_pe = container_of(p,
-					struct src_port_pe, p);
-
-	mutex_lock(&src_pe->pe_lock);
-	pp_caps->pp_is_dual_drole = src_pe->pp_is_dual_drole;
-	pp_caps->pp_is_dual_prole = src_pe->pp_is_dual_prole;
-	pp_caps->pp_is_ext_pwrd = src_pe->pp_is_ext_pwrd;
-	mutex_unlock(&src_pe->pe_lock);
-
-	return 0;
-}
-
-/* Init function to initialize the source policy engine */
-struct policy *src_pe_init(struct policy_engine *pe)
-{
-	struct src_port_pe *src_pe;
-	struct policy *p;
-
-	if (!pe)
-		return ERR_PTR(-EINVAL);
-
-	src_pe = kzalloc(sizeof(struct src_port_pe),
-						GFP_KERNEL);
-	if (!src_pe) {
-		log_err("mem alloc failed\n");
-		return ERR_PTR(-ENOMEM);
-	}
-
-	mutex_init(&src_pe->pe_lock);
-	INIT_DELAYED_WORK(&src_pe->start_comm, src_pe_start_comm);
-	INIT_WORK(&src_pe->msg_work, src_pe_msg_worker);
-
-	p = &src_pe->p;
-	p->type = POLICY_TYPE_SOURCE;
-	p->state = POLICY_STATE_OFFLINE;
-	p->status = POLICY_STATUS_UNKNOWN;
-
-	p->pe = pe;
-	p->rcv_pkt = src_pe_rcv_pkt;
-	p->rcv_request = src_pe_rcv_request;
-	p->rcv_cmd = src_pe_rcv_cmd;
-	p->start = src_pe_start_policy_engine;
-	p->stop = src_pe_stop_policy_engine;
-	p->exit = src_pe_exit;
-	p->get_port_caps = src_pe_get_port_caps;
-	init_completion(&src_pe->srt_complete);
-	init_completion(&src_pe->psso_complete);
-
-	log_info("Source pe initialized successfuly");
-
-	return p;
-}
-EXPORT_SYMBOL(src_pe_init);
