From c3ff031f6fc38ef22e1bf7584991e332a753bdc6 Mon Sep 17 00:00:00 2001
From: Mikael Persson <mikael.persson@intel.com>
Date: Mon, 17 Nov 2014 12:20:31 +0100
Subject: [PATCH 01/10] camera: fork lift from ICG gerrit

This patch is a fork lift from ICG gerrit
ssh://icggerrit.ir.intel.com:29418/vied-viedandr-camera
based on commit
  commit 1c9903592da9dbe6c56b607f68f84ea8efbcf4e6
  Author: Cao,Bing Bu <bingbu.cao@intel.com>
  Date:   Tue Nov 11 15:13:55 2014 +0000

    Add EV and 3a_lock ioctl for mt9m114 sensor

    For redhookbay, CTS case 'StillCaptureTest#testAeCompensation' need
    EV and 3a_lock settings for SOC Camera.
    This patch add the EV and 3a lock settings for mt9m114:
    * Real EV setting
    * Fake 3a lock setting

    Change-Id: Ib6ae61e6f00392c3ccdfc89538d6fb7cb83fa1fd

Valid Gmin specific patches will be added again ontop of this
patch.

The main purpose of this fork lift is to re-sync the ICG and
Gmin kernel code and enable an easier delivery process.

Change-Id: Ic4671e7fe7bed3fceafdd1ca380269fcdc3f7ba8
Signed-off-by: Mikael Persson <mikael.persson@intel.com>
---
 .../camera/drivers/media/i2c/Kconfig               |   35 +-
 .../camera/drivers/media/i2c/Makefile              |   16 +-
 .../camera/drivers/media/i2c/gc0339.c              | 1569 -------------
 .../camera/drivers/media/i2c/gc0339.h              |  541 -----
 .../camera/drivers/media/i2c/gc2235.c              | 1796 ++++++---------
 .../camera/drivers/media/i2c/gc2235.h              |  863 +++----
 .../camera/drivers/media/i2c/imx/Makefile          |    5 +-
 .../camera/drivers/media/i2c/imx/ad5816g.c         |    3 +
 .../camera/drivers/media/i2c/imx/drv201.c          |    3 +
 .../camera/drivers/media/i2c/imx/dw9714.c          |    3 +
 .../camera/drivers/media/i2c/imx/dw9718.c          |   36 +-
 .../camera/drivers/media/i2c/imx/dw9718.h          |    7 +
 .../camera/drivers/media/i2c/imx/imx.c             | 1177 +++++-----
 .../camera/drivers/media/i2c/imx/imx.h             |  233 +-
 .../camera/drivers/media/i2c/imx/imx132.h          |   65 +-
 .../camera/drivers/media/i2c/imx/imx134.h          |   19 +
 .../camera/drivers/media/i2c/imx/imx135.h          |  117 +-
 .../camera/drivers/media/i2c/imx/imx135vb.h        | 1889 ----------------
 .../camera/drivers/media/i2c/imx/imx208.h          |  550 +++++
 .../camera/drivers/media/i2c/imx/imx219.h          |  227 ++
 .../camera/drivers/media/i2c/imx/otp.c             |    3 +
 .../drivers/media/i2c/imx/otp_brcc064_e2prom.c     |   84 +
 .../camera/drivers/media/i2c/imx/otp_e2prom.c      |    3 +
 .../camera/drivers/media/i2c/imx/otp_imx.c         |    3 +
 .../camera/drivers/media/i2c/lm3554.c              |   35 +-
 .../camera/drivers/media/i2c/lm3559.c              |    6 +-
 .../camera/drivers/media/i2c/lm3642.c              |  855 +++++++
 .../camera/drivers/media/i2c/m10mo.c               | 2368 +++++++++++++++++---
 .../camera/drivers/media/i2c/m10mo.h               |  427 +++-
 .../camera/drivers/media/i2c/m10mo_fw.c            |  571 ++++-
 .../camera/drivers/media/i2c/m10mo_fw_type1_5.c    |  133 ++
 .../camera/drivers/media/i2c/m10mo_fw_type2.c      |  448 ++++
 .../camera/drivers/media/i2c/m10mo_tables.c        |  354 ++-
 .../camera/drivers/media/i2c/mt9m114.c             |  163 +-
 .../camera/drivers/media/i2c/mt9m114.h             |    1 -
 .../camera/drivers/media/i2c/ov5693-ecs/Kconfig    |   11 +
 .../camera/drivers/media/i2c/ov5693-ecs/Makefile   |    3 +
 .../camera/drivers/media/i2c/ov5693-ecs/ov5693.c   | 1801 +++++++++++++++
 .../camera/drivers/media/i2c/ov5693-ecs/ov5693.h   |  971 ++++++++
 .../camera/drivers/media/i2c/ov5693.c              | 1893 ----------------
 .../camera/drivers/media/i2c/ov5693.h              |  969 --------
 .../camera/drivers/media/i2c/ov5693/Kconfig        |   11 +
 .../camera/drivers/media/i2c/ov5693/Makefile       |    5 +
 .../camera/drivers/media/i2c/ov5693/ad5823.c       |    6 +-
 .../camera/drivers/media/i2c/ov5693/ad5823.h       |   92 +
 .../camera/drivers/media/i2c/ov5693/ov5693.c       |   86 +-
 .../camera/drivers/media/i2c/ov5693/ov5693.h       |   29 +-
 .../camera/drivers/media/i2c/ov680.c               |  255 ++-
 .../camera/drivers/media/i2c/ov680.h               |  334 ++-
 .../camera/drivers/media/i2c/ov8830.c              |   11 +
 .../camera/drivers/media/i2c/ov8858.c              |  448 ++--
 .../camera/drivers/media/i2c/ov8858.h              |  313 ++-
 .../camera/drivers/media/i2c/pixter.c              |  186 +-
 .../camera/drivers/media/i2c/pixter.h              |    6 +
 .../camera/drivers/media/i2c/s5k6b2yx.c            | 1766 +++++++++------
 .../camera/drivers/media/i2c/s5k6b2yx.h            |  678 ++++--
 .../camera/drivers/media/pci/atomisp2/Makefile     |    1 +
 .../pci/atomisp2/atomisp_driver/atomisp_cmd.c      |  220 +-
 .../pci/atomisp2/atomisp_driver/atomisp_cmd.h      |   12 +
 .../pci/atomisp2/atomisp_driver/atomisp_compat.h   |    3 +
 .../atomisp2/atomisp_driver/atomisp_compat_css20.c |   33 +-
 .../atomisp2/atomisp_driver/atomisp_compat_css20.h |    1 +
 .../atomisp_driver/atomisp_compat_ioctl32.c        |    2 +
 .../atomisp2/atomisp_driver/atomisp_dfs_tables.h   |   52 +-
 .../pci/atomisp2/atomisp_driver/atomisp_internal.h |    3 +-
 .../pci/atomisp2/atomisp_driver/atomisp_ioctl.c    |   10 +-
 .../pci/atomisp2/atomisp_driver/atomisp_v4l2.c     |   57 +-
 .../atomisp2/atomisp_driver_css15/atomisp_v4l2.c   |    6 +-
 .../media/pci/atomisp2/css2300/sh_css_debug.c      |   24 +-
 .../css2400b0_v21/base/refcount/src/refcount.c     |   36 +-
 .../camera/pipe/src/pipe_binarydesc.c              |    3 +-
 .../hive_isp_css_2400_system/host/isp.c            |   58 +
 .../hive_isp_css_2400_system/host/vmem.c           |   19 +-
 .../hive_isp_css_2400_system/isp_global.h          |   11 +-
 .../hive_isp_css_2400_system/sp_global.h           |    9 +-
 .../ia_css_isp_params.c                            |    7 +-
 .../hive_isp_css_include/host/isp_config.h         |    4 +-
 .../hive_isp_css_include/host/isp_public.h         |    8 +
 .../hive_isp_css_include/misc_support.h            |    3 +
 .../hive_isp_css_include/type_support.h            |    7 +
 .../media/pci/atomisp2/css2400b0_v21/ia_css.h      |    4 +-
 .../pci/atomisp2/css2400b0_v21/ia_css_acc_types.h  |    4 +
 .../media/pci/atomisp2/css2400b0_v21/ia_css_err.h  |   12 +-
 .../pci/atomisp2/css2400b0_v21/ia_css_host_data.h  |    4 +-
 .../pci/atomisp2/css2400b0_v21/ia_css_types.h      |    4 +-
 .../atomisp2/css2400b0_v21/ia_css_version_data.h   |    2 +-
 .../bayer_ls_1.0/ia_css_bayer_load_param.h         |   27 +
 .../bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h  |   38 +
 .../bayer_ls_1.0/ia_css_bayer_store_param.h        |   28 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c    |  129 ++
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h    |   43 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h   |   57 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h   |   63 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c    |  127 ++
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h    |   40 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h   |   53 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h      |   27 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.c        |  166 ++
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.h        |   41 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_param.h       |   59 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_types.h       |   65 +
 .../isp/kernels/dpc2/ia_css_dpc2.host.c            |   18 +-
 .../isp/kernels/dpc2/ia_css_dpc2_param.h           |   10 +-
 .../isp/kernels/dpc2/ia_css_dpc2_types.h           |    5 +
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.c        |    5 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.h        |    3 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8_param.h       |   12 +
 .../isp/kernels/eed1_8/ia_css_eed1_8_state.h       |   34 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c   |   54 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h   |   44 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h  |   31 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h  |    6 +-
 .../isp/kernels/hdr/ia_css_hdr.host.c              |    4 +-
 .../isp/kernels/hdr/ia_css_hdr.host.h              |    4 +-
 .../isp/kernels/hdr/ia_css_hdr_param.h             |    4 +-
 .../isp/kernels/hdr/ia_css_hdr_types.h             |    4 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.c      |  117 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.h      |    6 +
 .../kernels/iefd2_6/ia_css_iefd2_6_default.host.c  |    8 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_param.h     |   30 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_types.h     |    8 +-
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h      |   27 +
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h        |   42 +
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h     |   28 +
 .../css2400b0_v21/isp/modes/interface/isp_const.h  |    9 +
 .../css2400b0_v21/runtime/binary/src/binary.c      |   34 +-
 .../runtime/debug/interface/ia_css_debug.h         |   19 +-
 .../css2400b0_v21/runtime/debug/src/ia_css_debug.c |  196 +-
 .../css2400b0_v21/runtime/frame/src/frame.c        |   20 +-
 .../atomisp2/css2400b0_v21/runtime/isys/src/rx.c   |    9 +-
 .../css2400b0_v21/runtime/isys/src/virtual_isys.c  |   17 +-
 .../css2400b0_v21/runtime/rmgr/src/rmgr_vbuf.c     |   13 +-
 .../css2400b0_v21/runtime/spctrl/src/spctrl.c      |   17 +-
 .../media/pci/atomisp2/css2400b0_v21/sh_css.c      |   77 +-
 .../pci/atomisp2/css2400b0_v21/sh_css_firmware.c   |   15 +-
 .../pci/atomisp2/css2400b0_v21/sh_css_internal.h   |    1 -
 .../pci/atomisp2/css2400b0_v21/sh_css_params.c     |    2 +-
 .../media/pci/atomisp2/css2400b0_v21/spmem_dump.c  |  784 ++++---
 .../base/refcount/src/refcount.c                   |   36 +-
 .../camera/pipe/src/pipe_binarydesc.c              |    3 +-
 .../hive_isp_css_2400_system/host/isp.c            |   58 +
 .../hive_isp_css_2400_system/host/vmem.c           |   19 +-
 .../hive_isp_css_2400_system/isp_global.h          |   11 +-
 .../hive_isp_css_2400_system/sp_global.h           |    9 +-
 .../ia_css_isp_params.c                            |    7 +-
 .../hive_isp_css_include/host/isp_config.h         |    4 +-
 .../hive_isp_css_include/host/isp_public.h         |    8 +
 .../hive_isp_css_include/misc_support.h            |    3 +
 .../hive_isp_css_include/type_support.h            |    7 +
 .../pci/atomisp2/css2401a0_legacy_v21/ia_css.h     |    4 +-
 .../css2401a0_legacy_v21/ia_css_acc_types.h        |    4 +
 .../pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h |   12 +-
 .../css2401a0_legacy_v21/ia_css_host_data.h        |    4 +-
 .../atomisp2/css2401a0_legacy_v21/ia_css_types.h   |    4 +-
 .../css2401a0_legacy_v21/ia_css_version_data.h     |    2 +-
 .../bayer_ls_1.0/ia_css_bayer_load_param.h         |   27 +
 .../bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h  |   38 +
 .../bayer_ls_1.0/ia_css_bayer_store_param.h        |   28 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c    |  129 ++
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h    |   43 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h   |   57 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h   |   63 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c    |  127 ++
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h    |   40 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h   |   53 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h      |   27 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.c        |  166 ++
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.h        |   41 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_param.h       |   59 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_types.h       |   65 +
 .../isp/kernels/dpc2/ia_css_dpc2.host.c            |   18 +-
 .../isp/kernels/dpc2/ia_css_dpc2_param.h           |   10 +-
 .../isp/kernels/dpc2/ia_css_dpc2_types.h           |    5 +
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.c        |    5 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.h        |    3 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8_param.h       |   12 +
 .../isp/kernels/eed1_8/ia_css_eed1_8_state.h       |   34 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c   |   54 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h   |   44 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h  |   31 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h  |    6 +-
 .../isp/kernels/hdr/ia_css_hdr.host.c              |    4 +-
 .../isp/kernels/hdr/ia_css_hdr.host.h              |    4 +-
 .../isp/kernels/hdr/ia_css_hdr_param.h             |    4 +-
 .../isp/kernels/hdr/ia_css_hdr_types.h             |    4 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.c      |  117 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.h      |    6 +
 .../kernels/iefd2_6/ia_css_iefd2_6_default.host.c  |    8 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_param.h     |   30 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_types.h     |    8 +-
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h      |   27 +
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h        |   42 +
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h     |   28 +
 .../isp/modes/interface/isp_const.h                |    9 +
 .../runtime/binary/src/binary.c                    |   34 +-
 .../runtime/debug/interface/ia_css_debug.h         |   19 +-
 .../runtime/debug/src/ia_css_debug.c               |  196 +-
 .../css2401a0_legacy_v21/runtime/frame/src/frame.c |   20 +-
 .../css2401a0_legacy_v21/runtime/isys/src/rx.c     |    9 +-
 .../runtime/isys/src/virtual_isys.c                |   17 +-
 .../runtime/rmgr/src/rmgr_vbuf.c                   |   13 +-
 .../runtime/spctrl/src/spctrl.c                    |   17 +-
 .../pci/atomisp2/css2401a0_legacy_v21/sh_css.c     |   72 +-
 .../css2401a0_legacy_v21/sh_css_firmware.c         |   12 +-
 .../css2401a0_legacy_v21/sh_css_internal.h         |    1 -
 .../atomisp2/css2401a0_legacy_v21/sh_css_params.c  |    2 +-
 .../pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c |  784 ++++---
 .../css2401a0_v21/base/refcount/src/refcount.c     |   36 +-
 .../camera/pipe/src/pipe_binarydesc.c              |    3 +-
 .../hive_isp_css_2400_system/host/isp.c            |   58 +
 .../hive_isp_css_2400_system/host/vmem.c           |   19 +-
 .../hive_isp_css_2400_system/isp_global.h          |   11 +-
 .../hive_isp_css_2400_system/sp_global.h           |    9 +-
 .../ia_css_isp_params.c                            |    7 +-
 .../hive_isp_css_include/host/isp_config.h         |    4 +-
 .../hive_isp_css_include/host/isp_public.h         |    8 +
 .../hive_isp_css_include/misc_support.h            |    3 +
 .../hive_isp_css_include/type_support.h            |    7 +
 .../media/pci/atomisp2/css2401a0_v21/ia_css.h      |    4 +-
 .../pci/atomisp2/css2401a0_v21/ia_css_acc_types.h  |    4 +
 .../media/pci/atomisp2/css2401a0_v21/ia_css_err.h  |   12 +-
 .../pci/atomisp2/css2401a0_v21/ia_css_host_data.h  |    4 +-
 .../pci/atomisp2/css2401a0_v21/ia_css_types.h      |    4 +-
 .../atomisp2/css2401a0_v21/ia_css_version_data.h   |    2 +-
 .../bayer_ls_1.0/ia_css_bayer_load_param.h         |   27 +
 .../bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h  |   38 +
 .../bayer_ls_1.0/ia_css_bayer_store_param.h        |   28 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c    |  129 ++
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h    |   43 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h   |   57 +
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h   |   63 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c    |  127 ++
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h    |   40 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h   |   53 +
 .../isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h      |   27 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.c        |  166 ++
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.h        |   41 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_param.h       |   59 +
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_types.h       |   65 +
 .../isp/kernels/dpc2/ia_css_dpc2.host.c            |   18 +-
 .../isp/kernels/dpc2/ia_css_dpc2_param.h           |   10 +-
 .../isp/kernels/dpc2/ia_css_dpc2_types.h           |    5 +
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.c        |    5 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.h        |    3 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8_param.h       |   12 +
 .../isp/kernels/eed1_8/ia_css_eed1_8_state.h       |   34 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c   |   54 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h   |   44 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h  |   31 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h  |    6 +-
 .../isp/kernels/hdr/ia_css_hdr.host.c              |    4 +-
 .../isp/kernels/hdr/ia_css_hdr.host.h              |    4 +-
 .../isp/kernels/hdr/ia_css_hdr_param.h             |    4 +-
 .../isp/kernels/hdr/ia_css_hdr_types.h             |    4 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.c      |  117 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.h      |    6 +
 .../kernels/iefd2_6/ia_css_iefd2_6_default.host.c  |    8 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_param.h     |   30 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_types.h     |    8 +-
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h      |   27 +
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h        |   42 +
 .../yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h     |   28 +
 .../css2401a0_v21/isp/modes/interface/isp_const.h  |    9 +
 .../css2401a0_v21/runtime/binary/src/binary.c      |   34 +-
 .../runtime/debug/interface/ia_css_debug.h         |   19 +-
 .../css2401a0_v21/runtime/debug/src/ia_css_debug.c |  196 +-
 .../css2401a0_v21/runtime/frame/src/frame.c        |   20 +-
 .../atomisp2/css2401a0_v21/runtime/isys/src/rx.c   |    9 +-
 .../css2401a0_v21/runtime/isys/src/virtual_isys.c  |   17 +-
 .../css2401a0_v21/runtime/rmgr/src/rmgr_vbuf.c     |   13 +-
 .../css2401a0_v21/runtime/spctrl/src/spctrl.c      |   17 +-
 .../media/pci/atomisp2/css2401a0_v21/sh_css.c      |   72 +-
 .../pci/atomisp2/css2401a0_v21/sh_css_firmware.c   |   12 +-
 .../pci/atomisp2/css2401a0_v21/sh_css_internal.h   |    1 -
 .../pci/atomisp2/css2401a0_v21/sh_css_params.c     |    2 +-
 .../media/pci/atomisp2/css2401a0_v21/spmem_dump.c  |  778 ++++---
 276 files changed, 20753 insertions(+), 12756 deletions(-)
 delete mode 100644 drivers/external_drivers/camera/drivers/media/i2c/gc0339.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/i2c/gc0339.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx208.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx219.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/otp_brcc064_e2prom.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/lm3642.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type1_5.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Kconfig
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Makefile
 create mode 100755 drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c
 create mode 100755 drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h
 delete mode 100755 drivers/external_drivers/camera/drivers/media/i2c/ov5693.c
 delete mode 100755 drivers/external_drivers/camera/drivers/media/i2c/ov5693.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h
 mode change 100644 => 100755 drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h

diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
index 1cefad5..7af1925 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
@@ -3,6 +3,7 @@
 #
 
 source "drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig"
+source "drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig"
 source "drivers/external_drivers/camera/drivers/media/i2c/imx/Kconfig"
 source "drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Kconfig"
 
@@ -45,17 +46,6 @@ config VIDEO_M10MO_FAKE_SFI_TABLE
 
 	  Not needed if device IFWI already has M10MO in the SFI table.
 
-config VIDEO_GC0339
-       tristate "Galaxy gc0339 sensor support"
-       depends on I2C && VIDEO_V4L2
-       ---help---
-         This is a Video4Linux2 sensor-level driver for the OVT
-         GC0339 camera.
-
-         GC0339 is a 0.3M sensor.
-
-         It currently only works with the atomisp driver.
-
 config VIDEO_GC2235
        tristate "Galaxy gc2235 sensor support"
        depends on I2C && VIDEO_V4L2
@@ -67,17 +57,6 @@ config VIDEO_GC2235
 
          It currently only works with the atomisp driver.
 
-config VIDEO_OV5693
-       tristate "Omnivision ov5693 sensor support"
-       depends on I2C && VIDEO_V4L2
-       ---help---
-         This is a Video4Linux2 sensor-level driver for the Micron
-         ov5693 5 Mpixel camera.
-
-         ov5693 is video camera sensor.
-
-         It currently only works with the atomisp driver.
-
 config VIDEO_OV8830
        tristate "Omnivision ov8830 sensor support"
        depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP
@@ -215,6 +194,17 @@ config VIDEO_LM3554
          To compile this driver as a module, choose M here: the
          module will be called lm3554
 
+config VIDEO_LM3642
+       tristate "LM3642 flash light driver"
+       depends on VIDEO_V4L2 && I2C
+       ---help---
+         This is a Video4Linux2 sub-dev driver for the LM3642
+         flash light driver.
+
+         To compile this driver as a module, choose M here: the
+         module will be called lm3642
+
+
 config VIDEO_LM3559
        tristate "LM3559 flash light driver"
        depends on VIDEO_V4L2 && I2C
@@ -225,3 +215,4 @@ config VIDEO_LM3559
          To compile this driver as a module, choose M here: the
          module will be called lm3559
 
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
index 12faa4d..7898f25 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/Makefile
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
@@ -4,8 +4,11 @@
 
 obj-$(CONFIG_VIDEO_IMX)        += imx/
 obj-$(CONFIG_VIDEO_IMXVB)      += imx135VB/
-obj-$(CONFIG_VIDEO_OV5693)     += ov5693.o
-
+ifdef CONFIG_GMIN_INTEL_MID
+obj-$(CONFIG_VIDEO_OV5693)     += ov5693-ecs/
+else
+obj-$(CONFIG_VIDEO_OV5693)     += ov5693/
+endif
 obj-$(CONFIG_VIDEO_MT9M114)    += mt9m114.o
 obj-$(CONFIG_VIDEO_MT9E013)    += mt9e013/
 
@@ -15,18 +18,15 @@ obj-$(CONFIG_VIDEO_MT9V113)    += mt9v113.o
 
 obj-$(CONFIG_VIDEO_OV5640)     += ov5640.o
 
-obj-$(CONFIG_VIDEO_GC0339)     += gc0339.o
 obj-$(CONFIG_VIDEO_GC2235)     += gc2235.o
 obj-$(CONFIG_VIDEO_OV9724)     += ov9724.o
 obj-$(CONFIG_VIDEO_OV2722)     += ov2722.o
 obj-$(CONFIG_VIDEO_OV8830)     += ov8830.o
-obj-$(CONFIG_VIDEO_OV8858)     += ov8858_driver.o
-ov8858_driver-objs := ov8858.o imx/dw9718.o imx/vcm.o
 
 obj-$(CONFIG_VIDEO_S5K8AAY)    += s5k8aay.o
 obj-$(CONFIG_VIDEO_S5K6B2YX)    += s5k6b2yx.o
 
-m10mo_isp-objs := m10mo.o m10mo_fw.o m10mo_tables.o
+m10mo_isp-objs := m10mo.o m10mo_fw.o m10mo_tables.o m10mo_fw_type2.o m10mo_fw_type1_5.o
 obj-$(CONFIG_VIDEO_M10MO)    += m10mo_isp.o
 obj-$(CONFIG_VIDEO_M10MO)    += m10mo_spi.o
 
@@ -44,5 +44,9 @@ obj-$(CONFIG_VIDEO_PIXTER) += pixter.o
 
 obj-$(CONFIG_VIDEO_LM3554) += lm3554.o
 obj-$(CONFIG_VIDEO_LM3559) += lm3559.o
+obj-$(CONFIG_VIDEO_LM3642) += lm3642.o
 
 ccflags-y += -Werror
+
+# Add cflags to build camera sensor driver for CTP board
+ccflags-$(CONFIG_SND_CTP_MACHINE) += -DCSS15
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc0339.c b/drivers/external_drivers/camera/drivers/media/i2c/gc0339.c
deleted file mode 100644
index c820a00..0000000
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc0339.c
+++ /dev/null
@@ -1,1569 +0,0 @@
-/*
- * Support for GalaxyCore GC0339 VGA camera sensor.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/kmod.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <linux/moduleparam.h>
-#include <media/v4l2-device.h>
-#include <linux/io.h>
-#include <linux/atomisp_gmin_platform.h>
-
-#include "gc0339.h"
-
-/* i2c read/write stuff */
-static int gc0339_read_reg(struct i2c_client *client,
-			   u16 data_length, u8 reg, u8 *val)
-{
-	int err;
-	struct i2c_msg msg[2];
-	unsigned char data[2];
-
-	if (!client->adapter) {
-		dev_err(&client->dev, "%s error, no client->adapter\n",
-			__func__);
-		return -ENODEV;
-	}
-
-	if (data_length != GC0339_8BIT) {
-		dev_err(&client->dev, "%s error, invalid data length\n",
-			__func__);
-		return -EINVAL;
-	}
-
-	memset(msg, 0 , sizeof(msg));
-
-	msg[0].addr = client->addr;
-	msg[0].flags = 0;
-	msg[0].len = I2C_MSG_LENGTH;
-	msg[0].buf = data;
-
-	/* high byte goes out first */
-	data[0] = (u8)(reg & 0xff);
-	//pr_info("msg0 %x %d %d %d\n", msg[0].addr, msg[0].flags, msg[0].len, *msg[0].buf);
-
-	msg[1].addr = client->addr;
-	msg[1].len = data_length;
-	msg[1].flags = I2C_M_RD;
-	msg[1].buf = data+1;
-	//pr_info("msg1 %x %d %d %d\n", msg[1].addr, msg[1].flags, msg[1].len, *msg[1].buf);
-
-	err = i2c_transfer(client->adapter, msg, 2);
-	if (err != 2) {
-		if (err >= 0)
-			err = -EIO;
-		dev_err(&client->dev,
-			"read from offset 0x%x error %d", reg, err);
-		return err;
-	}
-
-//pr_info("read %d %d %d\n", data[0], data[1], err);
-	*val = 0;
-	/* high byte comes first */
-	if (data_length == GC0339_8BIT)
-		*val = (u8)data[1];
-
-	return 0;
-}
-
-static int gc0339_i2c_write(struct i2c_client *client, u16 len, u8 *data)
-{
-	struct i2c_msg msg;
-	const int num_msg = 1;
-	int ret;
-
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.len = len;
-	msg.buf = data;
-	ret = i2c_transfer(client->adapter, &msg, 1);
-
-	return ret == num_msg ? 0 : -EIO;
-}
-
-static int gc0339_write_reg(struct i2c_client *client, u16 data_length,
-							u8 reg, u8 val)
-{
-	int ret;
-	unsigned char data[2] = {0};
-	u8 *wreg = (u8 *)data;
-	const u16 len = data_length + sizeof(u8); /* 8-bit address + data */
-
-	if (data_length != GC0339_8BIT) {
-		dev_err(&client->dev,
-			"%s error, invalid data_length\n", __func__);
-		return -EINVAL;
-	}
-
-	/* high byte goes out first */
-	*wreg = (u8)(reg & 0xff);
-
-	if (data_length == GC0339_8BIT) {
-		data[1] = (u8)(val);
-	}
-
-	ret = gc0339_i2c_write(client, len, data);
-	if (ret)
-		dev_err(&client->dev,
-			"write error: wrote 0x%x to offset 0x%x error %d",
-			val, reg, ret);
-
-	return ret;
-}
-
-/*
- * gc0339_write_reg_array - Initializes a list of GC0339 registers
- * @client: i2c driver client structure
- * @reglist: list of registers to be written
- *
- * This function initializes a list of registers. When consecutive addresses
- * are found in a row on the list, this function creates a buffer and sends
- * consecutive data in a single i2c_transfer().
- *
- * __gc0339_flush_reg_array, __gc0339_buf_reg_array() and
- * __gc0339_write_reg_is_consecutive() are internal functions to
- * gc0339_write_reg_array_fast() and should be not used anywhere else.
- *
- */
-
-static int __gc0339_flush_reg_array(struct i2c_client *client,
-				    struct gc0339_write_ctrl *ctrl)
-{
-	u16 size;
-
-	if (ctrl->index == 0)
-		return 0;
-
-	size = sizeof(u8) + ctrl->index; /* 8-bit address + data */
-	ctrl->buffer.addr = (u8)(ctrl->buffer.addr);
-	ctrl->index = 0;
-
-	return gc0339_i2c_write(client, size, (u8 *)&ctrl->buffer);
-}
-
-static int __gc0339_buf_reg_array(struct i2c_client *client,
-				  struct gc0339_write_ctrl *ctrl,
-				  const struct gc0339_reg *next)
-{
-	int size;
-
-	switch (next->type) {
-	case GC0339_8BIT:
-		size = 1;
-		ctrl->buffer.data[ctrl->index] = (u8)next->val;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* When first item is added, we need to store its starting address */
-	if (ctrl->index == 0)
-		ctrl->buffer.addr = next->reg;
-
-	ctrl->index += size;
-
-	/*
-	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
-	 * possible lack of memory for next item.
-	 */
-	if (ctrl->index + sizeof(u8) >= GC0339_MAX_WRITE_BUF_SIZE)
-		return __gc0339_flush_reg_array(client, ctrl);
-
-	return 0;
-}
-
-static int __gc0339_write_reg_is_consecutive(struct i2c_client *client,
-					     struct gc0339_write_ctrl *ctrl,
-					     const struct gc0339_reg *next)
-{
-	if (ctrl->index == 0)
-		return 1;
-
-	return ctrl->buffer.addr + ctrl->index == next->reg;
-}
-
-static int gc0339_write_reg_array(struct i2c_client *client,
-				  const struct gc0339_reg *reglist)
-{
-	const struct gc0339_reg *next = reglist;
-	struct gc0339_write_ctrl ctrl;
-	int err;
-
-	ctrl.index = 0;
-	for (; next->type != GC0339_TOK_TERM; next++) {
-		switch (next->type & GC0339_TOK_MASK) {
-		case GC0339_TOK_DELAY:
-			err = __gc0339_flush_reg_array(client, &ctrl);
-			if (err)
-				return err;
-			msleep(next->val);
-			break;
-		default:
-			/*
-			 * If next address is not consecutive, data needs to be
-			 * flushed before proceed.
-			 */
-			if (!__gc0339_write_reg_is_consecutive(client, &ctrl,
-								next)) {
-				err = __gc0339_flush_reg_array(client, &ctrl);
-				if (err)
-					return err;
-			}
-			err = __gc0339_buf_reg_array(client, &ctrl, next);
-			if (err) {
-				dev_err(&client->dev, "%s: write error, aborted\n",
-					 __func__);
-				return err;
-			}
-			break;
-		}
-	}
-
-	return __gc0339_flush_reg_array(client, &ctrl);
-}
-static int gc0339_g_focal(struct v4l2_subdev *sd, s32 *val)
-{
-	*val = (GC0339_FOCAL_LENGTH_NUM << 16) | GC0339_FOCAL_LENGTH_DEM;
-	return 0;
-}
-
-static int gc0339_g_fnumber(struct v4l2_subdev *sd, s32 *val)
-{
-	/*const f number for imx*/
-	*val = (GC0339_F_NUMBER_DEFAULT_NUM << 16) | GC0339_F_NUMBER_DEM;
-	return 0;
-}
-
-static int gc0339_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
-{
-	*val = (GC0339_F_NUMBER_DEFAULT_NUM << 24) |
-		(GC0339_F_NUMBER_DEM << 16) |
-		(GC0339_F_NUMBER_DEFAULT_NUM << 8) | GC0339_F_NUMBER_DEM;
-	return 0;
-}
-
-static int gc0339_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	*val = gc0339_res[dev->fmt_idx].bin_factor_x;
-
-	return 0;
-}
-
-static int gc0339_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	*val = gc0339_res[dev->fmt_idx].bin_factor_y;
-
-	return 0;
-}
-
-static int gc0339_get_intg_factor(struct i2c_client *client,
-				struct camera_mipi_info *info,
-				const struct gc0339_resolution *res)
-{
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct atomisp_sensor_mode_data *buf = &info->data;
-	const unsigned int ext_clk_freq_hz = 19200000;
-	u16 val;
-	u8 reg_val;
-	int ret;
-	unsigned int hori_blanking;
-	unsigned int vert_blanking;
-	unsigned int sh_delay;
-
-	if (info == NULL)
-		return -EINVAL;
-
-	/* pixel clock calculattion */
-	dev->vt_pix_clk_freq_mhz = ext_clk_freq_hz / 2;
-	buf->vt_pix_clk_freq_mhz = ext_clk_freq_hz / 2;
-	pr_info("vt_pix_clk_freq_mhz=%d\n", buf->vt_pix_clk_freq_mhz);
-
-	/* get integration time */
-	buf->coarse_integration_time_min = GC0339_COARSE_INTG_TIME_MIN;
-	buf->coarse_integration_time_max_margin =
-					GC0339_COARSE_INTG_TIME_MAX_MARGIN;
-
-	buf->fine_integration_time_min = GC0339_FINE_INTG_TIME_MIN;
-	buf->fine_integration_time_max_margin =
-					GC0339_FINE_INTG_TIME_MAX_MARGIN;
-
-	buf->fine_integration_time_def = GC0339_FINE_INTG_TIME_MIN;
-	buf->read_mode = res->bin_mode;
-
-	/* get the cropping and output resolution to ISP for this mode. */
-	/* Getting crop_horizontal_start */
-	ret =  gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_H_CROP_START_H, &reg_val);
-	if (ret)
-		return ret;
-	val = (reg_val & 0xFF) << 8;
-	ret =  gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_H_CROP_START_L, &reg_val);
-	if (ret)
-		return ret;
-	buf->crop_horizontal_start = val | (reg_val & 0xFF);
-	pr_info("crop_horizontal_start=%d\n", buf->crop_horizontal_start);
-
-	/* Getting crop_vertical_start */
-	ret =  gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_V_CROP_START_H, &reg_val);
-	if (ret)
-		return ret;
-	val = (reg_val & 0xFF) << 8;
-	ret =  gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_V_CROP_START_L, &reg_val);
-	if (ret)
-		return ret;
-	buf->crop_vertical_start = val | (reg_val & 0xFF);
-	pr_info("crop_vertical_start=%d\n", buf->crop_vertical_start);
-
-	/* Getting output_width */
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_H_OUTSIZE_H, &reg_val);
-	if (ret)
-		return ret;
-	val = (reg_val & 0xFF) << 8;
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_H_OUTSIZE_L, &reg_val);
-	if (ret)
-		return ret;
-	buf->output_width = val | (reg_val & 0xFF);
-	pr_info("output_width=%d\n", buf->output_width);
-
-	/* Getting output_height */
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_V_OUTSIZE_H, &reg_val);
-	if (ret)
-		return ret;
-	val = (reg_val & 0xFF) << 8;
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_V_OUTSIZE_L, &reg_val);
-	if (ret)
-		return ret;
-	buf->output_height = val | (reg_val & 0xFF);
-	pr_info("output_height=%d\n", buf->output_height);
-
-	buf->crop_horizontal_end = buf->crop_horizontal_start + buf->output_width - 1;
-	buf->crop_vertical_end = buf->crop_vertical_start + buf->output_height - 1;
-	pr_info("crop_horizontal_end=%d\n", buf->crop_horizontal_end);
-	pr_info("crop_vertical_end=%d\n", buf->crop_vertical_end);
-
-	/* Getting line_length_pck */
-#if 1
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_H_BLANKING_H, &reg_val);
-	if (ret)
-		return ret;
-	val = ((reg_val & 0xF0) >> 4) << 8;
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_H_BLANKING_L, &reg_val);
-	if (ret)
-		return ret;
-	hori_blanking = val | (reg_val & 0xFF);
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_SH_DELAY, &reg_val);
-	if (ret)
-		return ret;
-	sh_delay = reg_val;
-	buf->line_length_pck = buf->output_width + hori_blanking + sh_delay + 4;
-	pr_info("hori_blanking=%d sh_delay=%d line_length_pck=%d\n", hori_blanking, sh_delay, buf->line_length_pck);
-#else
-	buf->line_length_pck = res->pixels_per_line;
-#endif
-
-	/* Getting frame_length_lines */
-#if 1
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_V_BLANKING_H, &reg_val);
-	if (ret)
-		return ret;
-	val = (reg_val & 0x0F) << 8;
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_V_BLANKING_L, &reg_val);
-	if (ret)
-		return ret;
-	vert_blanking = val | (reg_val & 0xFF);
-	buf->frame_length_lines = buf->output_height + vert_blanking;
-	pr_info("vert_blanking=%d frame_length_lines=%d\n", vert_blanking, buf->frame_length_lines);
-#else
-	buf->frame_length_lines = res->lines_per_frame;
-#endif
-
-	buf->binning_factor_x = res->bin_factor_x ?
-					res->bin_factor_x : 1;
-	buf->binning_factor_y = res->bin_factor_y ?
-					res->bin_factor_y : 1;
-	return 0;
-}
-
-static long __gc0339_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
-				 int gain, int digitgain)
-
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	u16 vts;
-	int frame_length;
-	int ret;
-
-	pr_info("coarse_itg=%d gain=%d digitgain=%d\n", coarse_itg, gain, digitgain);
-
-	vts = gc0339_res[dev->fmt_idx].lines_per_frame;
-	if ((coarse_itg + GC0339_COARSE_INTG_TIME_MAX_MARGIN) >= vts)
-		frame_length = coarse_itg + GC0339_COARSE_INTG_TIME_MAX_MARGIN;
-	else
-		frame_length = vts;
-
-#if 0
-	/* group hold start */
-	ret = gc0339_write_reg(client, GC0339_8BIT, GC0339_GROUP_ACCESS, 1);
-	if (ret)
-		return ret;
-#endif
-
-#if 0
-	ret = gc0339_write_reg(client, GC0339_8BIT,
-				GC0339_VTS_DIFF_H, frame_length >> 8);
-	if (ret)
-		return ret;
-#endif
-
-	/* set exposure */
-	ret = gc0339_write_reg(client, GC0339_8BIT,
-					GC0339_AEC_PK_EXPO_L,
-					coarse_itg & 0xff);
-	if (ret)
-		return ret;
-
-	ret = gc0339_write_reg(client, GC0339_8BIT,
-					GC0339_AEC_PK_EXPO_H,
-					(coarse_itg >> 8) & 0x0f);
-	if (ret)
-		return ret;
-
-	/* set analog gain */
-	ret = gc0339_write_reg(client, GC0339_8BIT,
-					GC0339_AGC_ADJ, gain);
-	if (ret)
-		return ret;
-
-#if 0
-	/* group hold end */
-	ret = gc0339_write_reg(client, GC0339_8BIT,
-					GC0339_GROUP_ACCESS, 0x0);
-#endif
-
-	return ret;
-}
-
-static int gc0339_set_exposure(struct v4l2_subdev *sd, int exposure,
-	int gain, int digitgain)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	int ret;
-
-	mutex_lock(&dev->input_lock);
-	ret = __gc0339_set_exposure(sd, exposure, gain, digitgain);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static long gc0339_s_exposure(struct v4l2_subdev *sd,
-			       struct atomisp_exposure *exposure)
-{
-	int exp = exposure->integration_time[0];
-	int gain = exposure->gain[0];
-	int digitgain = exposure->gain[1];
-
-	/* we should not accept the invalid value below. */
-	if (gain == 0) {
-		struct i2c_client *client = v4l2_get_subdevdata(sd);
-		v4l2_err(client, "%s: invalid value\n", __func__);
-		return -EINVAL;
-	}
-
-	return gc0339_set_exposure(sd, exp, gain, digitgain);
-}
-
-/* TO DO */
-static int gc0339_v_flip(struct v4l2_subdev *sd, s32 value)
-{
-	return 0;
-}
-
-/* TO DO */
-static int gc0339_h_flip(struct v4l2_subdev *sd, s32 value)
-{
-	return 0;
-}
-
-static long gc0339_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
-{
-
-	switch (cmd) {
-	case ATOMISP_IOC_S_EXPOSURE:
-		return gc0339_s_exposure(sd, arg);
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/* This returns the exposure time being used. This should only be used
-   for filling in EXIF data, not for actual image processing. */
-static int gc0339_q_exposure(struct v4l2_subdev *sd, s32 *value)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u8 reg_v;
-	int ret;
-
-	/* get exposure */
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_AEC_PK_EXPO_L,
-					&reg_v);
-	if (ret)
-		goto err;
-
-	*value = reg_v;
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_AEC_PK_EXPO_H,
-					&reg_v);
-	if (ret)
-		goto err;
-
-	*value = *value + (reg_v << 8);
-	//pr_info("gc0339_q_exposure %d\n", *value);
-err:
-	return ret;
-}
-struct gc0339_control gc0339_controls[] = {
-	{
-		.qc = {
-			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "exposure",
-			.minimum = 0x0,
-			.maximum = 0xffff,
-			.step = 0x01,
-			.default_value = 0x00,
-			.flags = 0,
-		},
-		.query = gc0339_q_exposure,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_VFLIP,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "Flip",
-			.minimum = 0,
-			.maximum = 1,
-			.step = 1,
-			.default_value = 0,
-		},
-		.tweak = gc0339_v_flip,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_HFLIP,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "Mirror",
-			.minimum = 0,
-			.maximum = 1,
-			.step = 1,
-			.default_value = 0,
-		},
-		.tweak = gc0339_h_flip,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FOCAL_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focal length",
-			.minimum = GC0339_FOCAL_LENGTH_DEFAULT,
-			.maximum = GC0339_FOCAL_LENGTH_DEFAULT,
-			.step = 0x01,
-			.default_value = GC0339_FOCAL_LENGTH_DEFAULT,
-			.flags = 0,
-		},
-		.query = gc0339_g_focal,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FNUMBER_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "f-number",
-			.minimum = GC0339_F_NUMBER_DEFAULT,
-			.maximum = GC0339_F_NUMBER_DEFAULT,
-			.step = 0x01,
-			.default_value = GC0339_F_NUMBER_DEFAULT,
-			.flags = 0,
-		},
-		.query = gc0339_g_fnumber,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FNUMBER_RANGE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "f-number range",
-			.minimum = GC0339_F_NUMBER_RANGE,
-			.maximum =  GC0339_F_NUMBER_RANGE,
-			.step = 0x01,
-			.default_value = GC0339_F_NUMBER_RANGE,
-			.flags = 0,
-		},
-		.query = gc0339_g_fnumber_range,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_BIN_FACTOR_HORZ,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "horizontal binning factor",
-			.minimum = 0,
-			.maximum = GC0339_BIN_FACTOR_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = gc0339_g_bin_factor_x,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_BIN_FACTOR_VERT,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "vertical binning factor",
-			.minimum = 0,
-			.maximum = GC0339_BIN_FACTOR_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = gc0339_g_bin_factor_y,
-	},
-};
-#define N_CONTROLS (ARRAY_SIZE(gc0339_controls))
-
-static struct gc0339_control *gc0339_find_control(u32 id)
-{
-	int i;
-
-	for (i = 0; i < N_CONTROLS; i++)
-		if (gc0339_controls[i].qc.id == id)
-			return &gc0339_controls[i];
-	return NULL;
-}
-
-static int gc0339_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
-{
-	struct gc0339_control *ctrl = gc0339_find_control(qc->id);
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	if (ctrl == NULL)
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	*qc = ctrl->qc;
-	mutex_unlock(&dev->input_lock);
-
-	return 0;
-}
-
-/* imx control set/get */
-static int gc0339_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct gc0339_control *s_ctrl;
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	int ret;
-
-	if (!ctrl)
-		return -EINVAL;
-
-	s_ctrl = gc0339_find_control(ctrl->id);
-	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = s_ctrl->query(sd, &ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static int gc0339_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct gc0339_control *octrl = gc0339_find_control(ctrl->id);
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	int ret;
-
-	if ((octrl == NULL) || (octrl->tweak == NULL))
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = octrl->tweak(sd, ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static int gc0339_init(struct v4l2_subdev *sd)
-{
-	int ret;
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	pr_info("%s S\n", __func__);
-	mutex_lock(&dev->input_lock);
-
-	/* set inital registers */
-	ret  = gc0339_write_reg_array(client, gc0339_reset_register);
-
-	/* restore settings */
-	gc0339_res = gc0339_res_preview;
-	N_RES = N_RES_PREVIEW;
-
-	mutex_unlock(&dev->input_lock);
-
-	pr_info("%s E\n", __func__);
-	return 0;
-}
-
-static int power_ctrl(struct v4l2_subdev *sd, bool flag)
-{
-	int ret = 0;
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->power_ctrl)
-		return dev->platform_data->power_ctrl(sd, flag);
-
-	if (flag) {
-		/* The upstream module driver (written to Crystal
-		 * Cove) had this logic to pulse the rails low first.
-		 * This appears to break things on the MRD7 with the
-		 * X-Powers PMIC...
-		 *
-		 *     ret = dev->platform_data->v1p8_ctrl(sd, 0);
-		 *     ret |= dev->platform_data->v2p8_ctrl(sd, 0);
-		 *     mdelay(50);
-		*/
-		ret |= dev->platform_data->v1p8_ctrl(sd, 1);
-		ret |= dev->platform_data->v2p8_ctrl(sd, 1);
-		msleep(10);
-	}
-
-	if (!flag || ret) {
-		ret |= dev->platform_data->v1p8_ctrl(sd, 0);
-		ret |= dev->platform_data->v2p8_ctrl(sd, 0);
-	}
-	return ret;
-}
-
-static int gpio_ctrl(struct v4l2_subdev *sd, bool flag)
-{
-	int ret;
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->gpio_ctrl)
-		return dev->platform_data->gpio_ctrl(sd, flag);
-
-	/* GPIO0 == "reset" (active low), GPIO1 == "power down" */
-	if (flag) {
-		/* Pulse reset, then release power down */
-		ret = dev->platform_data->gpio0_ctrl(sd, 0);
-		msleep(5);
-		ret |= dev->platform_data->gpio0_ctrl(sd, 1);
-		msleep(10);
-		ret |= dev->platform_data->gpio1_ctrl(sd, 0);
-		msleep(10);
-	} else {
-		ret = dev->platform_data->gpio1_ctrl(sd, 1);
-		ret |= dev->platform_data->gpio0_ctrl(sd, 0);
-	}
-	return ret;
-}
-
-static int power_down(struct v4l2_subdev *sd);
-
-static int power_up(struct v4l2_subdev *sd)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	pr_info("%s S\n", __func__);
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
-		return -ENODEV;
-	}
-
-	/* power control */
-	ret = power_ctrl(sd, 1);
-	if (ret)
-		goto fail_power;
-
-	/* flis clock control */
-	ret = dev->platform_data->flisclk_ctrl(sd, 1);
-	if (ret)
-		goto fail_clk;
-
-	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 1);
-	if (ret) {
-		ret = gpio_ctrl(sd, 1);
-		if (ret)
-			goto fail_gpio;
-	}
-
-	msleep(100);
-
-	pr_info("%s E\n", __func__);
-	return 0;
-
-fail_gpio:
-	power_ctrl(sd, 0);
-fail_power:
-	dev->platform_data->flisclk_ctrl(sd, 0);
-fail_clk:
-	dev_err(&client->dev, "sensor power-up failed\n");
-
-	return ret;
-}
-
-static int power_down(struct v4l2_subdev *sd)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
-		return -ENODEV;
-	}
-
-	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 0);
-	if (ret) {
-		ret = gpio_ctrl(sd, 0);
-		if (ret)
-			dev_err(&client->dev, "gpio failed 2\n");
-	}
-
-	/* power control */
-	ret = power_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "vprog failed.\n");
-
-	ret = dev->platform_data->flisclk_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "flisclk failed\n");
-
-	return ret;
-}
-
-static int gc0339_s_power(struct v4l2_subdev *sd, int on)
-{
-	int ret;
-	if (on == 0)
-		return power_down(sd);
-	else {
-		ret = power_up(sd);
-		if (!ret)
-			return gc0339_init(sd);
-	}
-	return ret;
-}
-
-/*
- * distance - calculate the distance
- * @res: resolution
- * @w: width
- * @h: height
- *
- * Get the gap between resolution and w/h.
- * res->width/height smaller than w/h wouldn't be considered.
- * Returns the value of gap or -1 if fail.
- */
-#define LARGEST_ALLOWED_RATIO_MISMATCH 800
-static int distance(struct gc0339_resolution *res, u32 w, u32 h)
-{
-	unsigned int w_ratio = ((res->width << 13)/w);
-	unsigned int h_ratio;
-	int match;
-
-	if (h == 0)
-		return -1;
-	h_ratio = ((res->height << 13) / h);
-	if (h_ratio == 0)
-		return -1;
-	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
-
-	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
-		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
-		return -1;
-
-	return w_ratio + h_ratio;
-}
-
-/* Return the nearest higher resolution index */
-static int nearest_resolution_index(int w, int h)
-{
-	int i;
-	int idx = -1;
-	int dist;
-	int min_dist = INT_MAX;
-	struct gc0339_resolution *tmp_res = NULL;
-
-	for (i = 0; i < N_RES; i++) {
-		tmp_res = &gc0339_res[i];
-		dist = distance(tmp_res, w, h);
-		if (dist == -1)
-			continue;
-		if (dist < min_dist) {
-			min_dist = dist;
-			idx = i;
-		}
-	}
-
-	return idx;
-}
-
-static int get_resolution_index(int w, int h)
-{
-	int i;
-
-	for (i = 0; i < N_RES; i++) {
-		if (w != gc0339_res[i].width)
-			continue;
-		if (h != gc0339_res[i].height)
-			continue;
-
-		return i;
-	}
-
-	return -1;
-}
-
-static int gc0339_try_mbus_fmt(struct v4l2_subdev *sd,
-			struct v4l2_mbus_framefmt *fmt)
-{
-	int idx;
-
-	if (!fmt)
-		return -EINVAL;
-	idx = nearest_resolution_index(fmt->width,
-					fmt->height);
-	if (idx == -1) {
-		/* return the largest resolution */
-		fmt->width = gc0339_res[N_RES - 1].width;
-		fmt->height = gc0339_res[N_RES - 1].height;
-	} else {
-		fmt->width = gc0339_res[idx].width;
-		fmt->height = gc0339_res[idx].height;
-	}
-	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
-
-	return 0;
-}
-
-/* TODO: remove it. */
-static int startup(struct v4l2_subdev *sd)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	pr_info("%s S\n", __func__);
-#if 0
-	ret = gc0339_write_reg(client, GC0339_8BIT,
-					GC0339_SW_RESET, 0x01);
-	if (ret) {
-		dev_err(&client->dev, "gc0339 reset err.\n");
-		return ret;
-	}
-#endif
-
-	ret = gc0339_write_reg_array(client, gc0339_res[dev->fmt_idx].regs);
-	if (ret) {
-		dev_err(&client->dev, "gc0339 write register err.\n");
-		return ret;
-	}
-
-	pr_info("%s E\n", __func__);
-	return ret;
-}
-
-static int gc0339_s_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_mipi_info *gc0339_info = NULL;
-	int ret = 0;
-
-	pr_info("%s S\n", __func__);
-	gc0339_info = v4l2_get_subdev_hostdata(sd);
-	if (gc0339_info == NULL)
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = gc0339_try_mbus_fmt(sd, fmt);
-	if (ret == -1) {
-		dev_err(&client->dev, "try fmt fail\n");
-		goto err;
-	}
-
-	dev->fmt_idx = get_resolution_index(fmt->width,
-					      fmt->height);
-	if (dev->fmt_idx == -1) {
-		dev_err(&client->dev, "get resolution fail\n");
-		mutex_unlock(&dev->input_lock);
-		return -EINVAL;
-	}
-
-	printk("%s: before gc0339_write_reg_array %s\n",__FUNCTION__, gc0339_res[dev->fmt_idx].desc);
-	ret = startup(sd);
-	if (ret) {
-		dev_err(&client->dev, "gc0339 startup err\n");
-		goto err;
-	}
-
-	ret = gc0339_get_intg_factor(client, gc0339_info,
-					&gc0339_res[dev->fmt_idx]);
-	if (ret) {
-		dev_err(&client->dev, "failed to get integration_factor\n");
-		goto err;
-	}
-
-	pr_info("%s E\n", __func__);
-err:
-	mutex_unlock(&dev->input_lock);
-	return ret;
-}
-static int gc0339_g_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	if (!fmt)
-		return -EINVAL;
-
-	fmt->width = gc0339_res[dev->fmt_idx].width;
-	fmt->height = gc0339_res[dev->fmt_idx].height;
-	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
-
-	return 0;
-}
-
-static int gc0339_detect(struct i2c_client *client)
-{
-	struct i2c_adapter *adapter = client->adapter;
-	int ret;
-	u8 id;
-
-	pr_info("%s S\n", __func__);
-	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
-		return -ENODEV;
-
-	ret = gc0339_write_reg(client, GC0339_8BIT,
-					0xFC, 0x10);
-	if (ret) {
-		dev_err(&client->dev, "gc0339 reset err.\n");
-		return ret;
-	}
-
-	ret = gc0339_read_reg(client, GC0339_8BIT,
-					GC0339_SC_CMMN_CHIP_ID, &id);
-	if (ret) {
-		dev_err(&client->dev, "read sensor ID failed\n");
-		return -ENODEV;
-	}
-
-	pr_info("sensor ID = 0x%x\n", id);
-	if (id != GC0339_ID) {
-		dev_err(&client->dev, "sensor ID error, read id = 0x%x, target id = 0x%x\n", id, GC0339_ID);
-		return -ENODEV;
-	}
-
-	dev_dbg(&client->dev, "detect gc0339 success\n");
-
-	pr_info("%s E\n", __func__);
-
-	return 0;
-}
-
-static int gc0339_s_stream(struct v4l2_subdev *sd, int enable)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	pr_info("%s S enable=%d\n", __func__, enable);
-	mutex_lock(&dev->input_lock);
-
-#if 1
-	if (enable) {
-		/* enable per frame MIPI and sensor ctrl reset  */
-		ret = gc0339_write_reg(client, GC0339_8BIT,0xFE, 0x50);
-		if (ret) {
-			mutex_unlock(&dev->input_lock);
-			return ret;
-		}
-		printk("reset register.\n");
-		//ret = gc0339_write_reg_array(client, gc0339_reset_register);
-		//ret = gc0339_write_reg_array(client, gc0339_VGA_30fps);
-
-	}
-#endif	
-	ret = gc0339_write_reg(client, GC0339_8BIT, GC0339_SW_STREAM,
-				enable ? GC0339_START_STREAMING :
-				GC0339_STOP_STREAMING);
-
-	mutex_unlock(&dev->input_lock);
-	pr_info("%s E\n", __func__);
-	return ret;
-}
-
-/* gc0339 enum frame size, frame intervals */
-static int gc0339_enum_framesizes(struct v4l2_subdev *sd,
-				  struct v4l2_frmsizeenum *fsize)
-{
-	unsigned int index = fsize->index;
-
-	if (index >= N_RES)
-		return -EINVAL;
-
-	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-	fsize->discrete.width = gc0339_res[index].width;
-	fsize->discrete.height = gc0339_res[index].height;
-	fsize->reserved[0] = gc0339_res[index].used;
-
-	return 0;
-}
-
-static int gc0339_enum_frameintervals(struct v4l2_subdev *sd,
-				      struct v4l2_frmivalenum *fival)
-{
-	unsigned int index = fival->index;
-
-	if (index >= N_RES)
-		return -EINVAL;
-
-	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
-	fival->width = gc0339_res[index].width;
-	fival->height = gc0339_res[index].height;
-	fival->discrete.numerator = 1;
-	fival->discrete.denominator = gc0339_res[index].fps;
-
-	return 0;
-}
-
-static int gc0339_enum_mbus_fmt(struct v4l2_subdev *sd,
-				unsigned int index,
-				enum v4l2_mbus_pixelcode *code)
-{
-	*code = V4L2_MBUS_FMT_SGRBG10_1X10;
-
-	return 0;
-}
-
-static int gc0339_s_config(struct v4l2_subdev *sd,
-			   int irq, void *platform_data)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	pr_info("%s S\n", __func__);
-	if (platform_data == NULL)
-		return -ENODEV;
-
-	dev->platform_data =
-		(struct camera_sensor_platform_data *)platform_data;
-
-	mutex_lock(&dev->input_lock);
-	/* power off the module, then power on it in future
-	 * as first power on by board may not fulfill the
-	 * power on sequqence needed by the module
-	 */
-	printk("+++[%s], platform_init.\n",__func__);
-	dev->platform_data->platform_init(client);
-
-	ret = power_down(sd);
-	if (ret) {
-		dev_err(&client->dev, "gc0339 power-off err.\n");
-		goto fail_power_off;
-	}
-	msleep(100);
-
-	ret = power_up(sd);
-	if (ret) {
-		dev_err(&client->dev, "gc0339 power-up err.\n");
-		goto fail_power_on;
-	}
-
-	ret = dev->platform_data->csi_cfg(sd, 1);
-	if (ret)
-		goto fail_csi_cfg;
-
-	/* config & detect sensor */
-	ret = gc0339_detect(client);
-	if (ret) {
-		dev_err(&client->dev, "gc0339_detect err s_config.\n");
-		goto fail_csi_cfg;
-	}
-
-	/* turn off sensor, after probed */
-	ret = power_down(sd);
-	if (ret) {
-		dev_err(&client->dev, "gc0339 power-off err.\n");
-		goto fail_csi_cfg;
-	}
-
-	mutex_unlock(&dev->input_lock);
-
-	pr_info("%s E\n", __func__);
-	return 0;
-
-fail_csi_cfg:
-	dev->platform_data->csi_cfg(sd, 0);
-fail_power_on:
-	power_down(sd);
-	dev_err(&client->dev, "sensor power-gating failed\n");
-fail_power_off:
-	mutex_unlock(&dev->input_lock);
-	return ret;
-}
-
-static int gc0339_g_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	if (!param)
-		return -EINVAL;
-
-	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_err(&client->dev,  "unsupported buffer type.\n");
-		return -EINVAL;
-	}
-
-	memset(param, 0, sizeof(*param));
-	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-
-	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
-		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
-		param->parm.capture.timeperframe.numerator = 1;
-		param->parm.capture.capturemode = dev->run_mode;
-		param->parm.capture.timeperframe.denominator =
-			gc0339_res[dev->fmt_idx].fps;
-	}
-	return 0;
-}
-
-static int gc0339_s_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	dev->run_mode = param->parm.capture.capturemode;
-
-	mutex_lock(&dev->input_lock);
-	switch (dev->run_mode) {
-	case CI_MODE_VIDEO:
-		gc0339_res = gc0339_res_video;
-		N_RES = N_RES_VIDEO;
-		break;
-	case CI_MODE_STILL_CAPTURE:
-		gc0339_res = gc0339_res_still;
-		N_RES = N_RES_STILL;
-		break;
-	default:
-		gc0339_res = gc0339_res_preview;
-		N_RES = N_RES_PREVIEW;
-	}
-	mutex_unlock(&dev->input_lock);
-	return 0;
-}
-
-static int gc0339_g_frame_interval(struct v4l2_subdev *sd,
-				   struct v4l2_subdev_frame_interval *interval)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	interval->interval.numerator = 1;
-	interval->interval.denominator = gc0339_res[dev->fmt_idx].fps;
-
-	return 0;
-}
-
-static int gc0339_enum_mbus_code(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_mbus_code_enum *code)
-{
-	if (code->index >= MAX_FMTS)
-		return -EINVAL;
-
-	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
-	return 0;
-}
-
-static int gc0339_enum_frame_size(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_frame_size_enum *fse)
-{
-	int index = fse->index;
-
-	if (index >= N_RES)
-		return -EINVAL;
-
-	fse->min_width = gc0339_res[index].width;
-	fse->min_height = gc0339_res[index].height;
-	fse->max_width = gc0339_res[index].width;
-	fse->max_height = gc0339_res[index].height;
-
-	return 0;
-
-}
-
-static struct v4l2_mbus_framefmt *
-__gc0339_get_pad_format(struct gc0339_device *sensor,
-			struct v4l2_subdev_fh *fh, unsigned int pad,
-			enum v4l2_subdev_format_whence which)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
-
-	if (pad != 0) {
-		dev_err(&client->dev,
-			"__gc0339_get_pad_format err. pad %x\n", pad);
-		return NULL;
-	}
-
-	switch (which) {
-	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
-	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &sensor->format;
-	default:
-		return NULL;
-	}
-}
-
-static int gc0339_get_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
-{
-	struct gc0339_device *snr = to_gc0339_sensor(sd);
-	struct v4l2_mbus_framefmt *format =
-			__gc0339_get_pad_format(snr, fh, fmt->pad, fmt->which);
-	if (!format)
-		return -EINVAL;
-
-	fmt->format = *format;
-	return 0;
-}
-
-static int gc0339_set_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
-{
-	struct gc0339_device *snr = to_gc0339_sensor(sd);
-
-	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		snr->format = fmt->format;
-
-	return 0;
-}
-
-static int gc0339_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
-{
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-
-	mutex_lock(&dev->input_lock);
-	*frames = gc0339_res[dev->fmt_idx].skip_frames;
-	mutex_unlock(&dev->input_lock);
-
-	return 0;
-}
-
-static const struct v4l2_subdev_sensor_ops gc0339_sensor_ops = {
-	.g_skip_frames	= gc0339_g_skip_frames,
-};
-
-static const struct v4l2_subdev_video_ops gc0339_video_ops = {
-	.s_stream = gc0339_s_stream,
-	.g_parm = gc0339_g_parm,
-	.s_parm = gc0339_s_parm,
-	.enum_framesizes = gc0339_enum_framesizes,
-	.enum_frameintervals = gc0339_enum_frameintervals,
-	.enum_mbus_fmt = gc0339_enum_mbus_fmt,
-	.try_mbus_fmt = gc0339_try_mbus_fmt,
-	.g_mbus_fmt = gc0339_g_mbus_fmt,
-	.s_mbus_fmt = gc0339_s_mbus_fmt,
-	.g_frame_interval = gc0339_g_frame_interval,
-};
-
-static const struct v4l2_subdev_core_ops gc0339_core_ops = {
-	.s_power = gc0339_s_power,
-	.queryctrl = gc0339_queryctrl,
-	.g_ctrl = gc0339_g_ctrl,
-	.s_ctrl = gc0339_s_ctrl,
-	.ioctl = gc0339_ioctl,
-};
-
-static const struct v4l2_subdev_pad_ops gc0339_pad_ops = {
-	.enum_mbus_code = gc0339_enum_mbus_code,
-	.enum_frame_size = gc0339_enum_frame_size,
-	.get_fmt = gc0339_get_pad_format,
-	.set_fmt = gc0339_set_pad_format,
-};
-
-static const struct v4l2_subdev_ops gc0339_ops = {
-	.core = &gc0339_core_ops,
-	.video = &gc0339_video_ops,
-	.pad = &gc0339_pad_ops,
-	.sensor = &gc0339_sensor_ops,
-};
-
-static int gc0339_remove(struct i2c_client *client)
-{
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct gc0339_device *dev = to_gc0339_sensor(sd);
-	dev_dbg(&client->dev, "gc0339_remove...\n");
-
-	dev->platform_data->csi_cfg(sd, 0);
-
-	v4l2_device_unregister_subdev(sd);
-	media_entity_cleanup(&dev->sd.entity);
-	kfree(dev);
-
-	return 0;
-}
-
-static int gc0339_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
-{
-	struct gc0339_device *dev;
-	int ret = -1;
-	void *pdata = client->dev.platform_data;
-
-	pr_info("%s S\n", __func__);
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev) {
-		dev_err(&client->dev, "out of memory\n");
-		return -ENOMEM;
-	}
-
-	mutex_init(&dev->input_lock);
-
-	dev->fmt_idx = 0;
-	v4l2_i2c_subdev_init(&(dev->sd), client, &gc0339_ops);
-
-	if (ACPI_COMPANION(&client->dev))
-		pdata = gmin_camera_platform_data(&dev->sd,
-						  ATOMISP_INPUT_FORMAT_RAW_10,
-						  atomisp_bayer_order_grbg);
-	if (!pdata)
-		goto out_free;
-
-	ret = gc0339_s_config(&dev->sd, client->irq, pdata);
-	if (ret)
-		goto out_free;
-
-	ret = atomisp_register_i2c_module(&dev->sd, pdata, RAW_CAMERA);
-	if (ret)
-		goto out_free;
-
-	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
-	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
-	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
-
-	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
-	if (ret)
-		gc0339_remove(client);
-
-	pr_info("%s E\n", __func__);
-
-	return ret;
-out_free:
-	v4l2_device_unregister_subdev(&dev->sd);
-	kfree(dev);
-	return ret;
-}
-
-static struct acpi_device_id gc0339_acpi_match[] = {
-	{"INT33F9"},
-	{},
-};
-MODULE_DEVICE_TABLE(acpi, gc0339_acpi_match);
-
-MODULE_DEVICE_TABLE(i2c, gc0339_id);
-static struct i2c_driver gc0339_driver = {
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = GC0339_NAME,
-		.acpi_match_table = ACPI_PTR(gc0339_acpi_match),
-	},
-	.probe = gc0339_probe,
-	.remove = gc0339_remove,
-	.id_table = gc0339_id,
-};
-
-static int init_gc0339(void)
-{
-	return i2c_add_driver(&gc0339_driver);
-}
-
-static void exit_gc0339(void)
-{
-
-	i2c_del_driver(&gc0339_driver);
-}
-
-module_init(init_gc0339);
-module_exit(exit_gc0339);
-
-MODULE_AUTHOR("Lai, Angie <angie.lai@intel.com>");
-MODULE_DESCRIPTION("A low-level driver for GalaxyCore GC0339 sensors");
-MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc0339.h b/drivers/external_drivers/camera/drivers/media/i2c/gc0339.h
deleted file mode 100644
index 986cae1..0000000
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc0339.h
+++ /dev/null
@@ -1,541 +0,0 @@
-/*
- * Support for GalaxyCore GC0339 VGA camera sensor.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __GC0339_H__
-#define __GC0339_H__
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/i2c.h>
-#include <linux/acpi.h>
-#include <linux/delay.h>
-#include <linux/videodev2.h>
-#include <linux/spinlock.h>
-#include <media/v4l2-subdev.h>
-#include <media/v4l2-device.h>
-#include <linux/v4l2-mediabus.h>
-#include <media/media-entity.h>
-
-#include <linux/atomisp_platform.h>
-
-#define GC0339_NAME		"gc0339"
-
-/* Defines for register writes and register array processing */
-#define I2C_MSG_LENGTH		1
-#define I2C_RETRY_COUNT		5
-
-#define GC0339_FOCAL_LENGTH_NUM	278	/*2.78mm*/
-#define GC0339_FOCAL_LENGTH_DEM	100
-#define GC0339_F_NUMBER_DEFAULT_NUM	26
-#define GC0339_F_NUMBER_DEM	10
-
-#define MAX_FMTS		1
-
-/*
- * focal length bits definition:
- * bits 31-16: numerator, bits 15-0: denominator
- */
-#define GC0339_FOCAL_LENGTH_DEFAULT 0x1160064
-
-/*
- * current f-number bits definition:
- * bits 31-16: numerator, bits 15-0: denominator
- */
-#define GC0339_F_NUMBER_DEFAULT 0x1a000a
-
-/*
- * f-number range bits definition:
- * bits 31-24: max f-number numerator
- * bits 23-16: max f-number denominator
- * bits 15-8: min f-number numerator
- * bits 7-0: min f-number denominator
- */
-#define GC0339_F_NUMBER_RANGE 0x1a0a1a0a
-#define GC0339_ID	0xc8
-
-#define GC0339_FINE_INTG_TIME_MIN 0
-#define GC0339_FINE_INTG_TIME_MAX_MARGIN 0
-#define GC0339_COARSE_INTG_TIME_MIN 1
-#define GC0339_COARSE_INTG_TIME_MAX_MARGIN 6
-
-/*
- * GC0339 System control registers
- */
-#define GC0339_SW_STREAM			0x60
-
-#define GC0339_SC_CMMN_CHIP_ID		0x0
-
-#define GC0339_AEC_PK_EXPO_H			0x03
-#define GC0339_AEC_PK_EXPO_L			0x04
-#define GC0339_AGC_ADJ			0x50
-#if 0
-#define GC0339_GROUP_ACCESS			0x3208
-#endif
-
-#define GC0339_H_CROP_START_H			0x07
-#define GC0339_H_CROP_START_L			0x08
-#define GC0339_V_CROP_START_H			0x05
-#define GC0339_V_CROP_START_L			0x06
-#define GC0339_H_OUTSIZE_H			0x0B
-#define GC0339_H_OUTSIZE_L			0x0C
-#define GC0339_V_OUTSIZE_H			0x09
-#define GC0339_V_OUTSIZE_L			0x0A
-#define GC0339_H_BLANKING_H			0x0F /* [3:0] */
-#define GC0339_H_BLANKING_L			0x01
-#define GC0339_V_BLANKING_H			0x0F /* [7:4] */
-#define GC0339_V_BLANKING_L			0x02
-#define GC0339_SH_DELAY			0x12
-
-#define GC0339_START_STREAMING			0x98 /* 10-bit enable */
-#define GC0339_STOP_STREAMING			0x88 /* 10-bit disable */
-
-#define GC0339_BIN_FACTOR_MAX			3
-
-#define REG_VER1 0
-
-struct regval_list {
-	u16 reg_num;
-	u8 value;
-};
-
-struct gc0339_resolution {
-	u8 *desc;
-	const struct gc0339_reg *regs;
-	int res;
-	int width;
-	int height;
-	int fps;
-	int pix_clk_freq;
-	u32 skip_frames;
-	u16 pixels_per_line;
-	u16 lines_per_frame;
-	u8 bin_factor_x;
-	u8 bin_factor_y;
-	u8 bin_mode;
-	bool used;
-};
-
-struct gc0339_format {
-	u8 *desc;
-	u32 pixelformat;
-	struct gc0339_reg *regs;
-};
-
-struct gc0339_control {
-	struct v4l2_queryctrl qc;
-	int (*query)(struct v4l2_subdev *sd, s32 *value);
-	int (*tweak)(struct v4l2_subdev *sd, s32 value);
-};
-
-/*
- * gc0339 device structure.
- */
-struct gc0339_device {
-	struct v4l2_subdev sd;
-	struct media_pad pad;
-	struct v4l2_mbus_framefmt format;
-	struct mutex input_lock;
-
-	struct camera_sensor_platform_data *platform_data;
-	int vt_pix_clk_freq_mhz;
-	int fmt_idx;
-	int run_mode;
-	u8 res;
-	u8 type;
-};
-
-enum gc0339_tok_type {
-	GC0339_8BIT  = 0x0001,
-	GC0339_TOK_TERM   = 0xf000,	/* terminating token for reg list */
-	GC0339_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
-	GC0339_TOK_MASK = 0xfff0
-};
-
-/**
- * struct gc0339_reg - MI sensor  register format
- * @type: type of the register
- * @reg: 16-bit offset to register
- * @val: 8/16/32-bit register value
- *
- * Define a structure for sensor register initialization values
- */
-struct gc0339_reg {
-	enum gc0339_tok_type type;
-	u8 reg;
-	u8 val;	/* @set value for read/mod/write, @mask */
-};
-
-#define to_gc0339_sensor(x) container_of(x, struct gc0339_device, sd)
-
-#define GC0339_MAX_WRITE_BUF_SIZE	30
-
-struct gc0339_write_buffer {
-	u8 addr;
-	u8 data[GC0339_MAX_WRITE_BUF_SIZE];
-};
-
-struct gc0339_write_ctrl {
-	int index;
-	struct gc0339_write_buffer buffer;
-};
-
-static const struct i2c_device_id gc0339_id[] = {
-	{GC0339_NAME, 0},
-	{}
-};
-
-/*
- * Register settings for various resolution
- */
-static const struct gc0339_reg gc0339_reset_register[] = {
-#if REG_VER1
-	{GC0339_8BIT, 0xFC, 0x10},
-	{GC0339_8BIT, 0xFE, 0x00},
-	{GC0339_8BIT, 0xF6, 0x05},
-	{GC0339_8BIT, 0xF7, 0x01},
-	{GC0339_8BIT, 0xF7, 0x03},
-	{GC0339_8BIT, 0xFC, 0x16},
-	
-	{GC0339_8BIT, 0x06, 0x00},
-	{GC0339_8BIT, 0x08, 0x05},
-	{GC0339_8BIT, 0x09, 0x01}, /* 484 */
-	{GC0339_8BIT, 0x0A, 0xE4},
-	{GC0339_8BIT, 0x0B, 0x02}, /* 644 */
-	{GC0339_8BIT, 0x0C, 0x84},
-	
-	{GC0339_8BIT, 0x01, 0x90}, /* DummyHor 144 */
-	{GC0339_8BIT, 0x02, 0x2F}, /* DummyVer 47 */
-	
-	{GC0339_8BIT, 0x0F, 0x00}, /* DummyHor 144 */
-	{GC0339_8BIT, 0x14, 0x00},
-	{GC0339_8BIT, 0x1A, 0x21},
-	{GC0339_8BIT, 0x1B, 0x08},
-	{GC0339_8BIT, 0x1C, 0x19},
-	{GC0339_8BIT, 0x1D, 0xEA},
-	{GC0339_8BIT, 0x20, 0xB0},
-	{GC0339_8BIT, 0x2E, 0x00},
-	
-	{GC0339_8BIT, 0x30, 0xB7},
-	{GC0339_8BIT, 0x31, 0x7F},
-	{GC0339_8BIT, 0x32, 0x00},
-	{GC0339_8BIT, 0x39, 0x04},
-	{GC0339_8BIT, 0x3A, 0x20},
-	{GC0339_8BIT, 0x3B, 0x20},
-	{GC0339_8BIT, 0x3C, 0x00},
-	{GC0339_8BIT, 0x3D, 0x00},
-	{GC0339_8BIT, 0x3E, 0x00},
-	{GC0339_8BIT, 0x3F, 0x00},
-	
-	{GC0339_8BIT, 0x62, 0x20},
-	{GC0339_8BIT, 0x63, 0x03},
-	{GC0339_8BIT, 0x69, 0x13},
-	{GC0339_8BIT, 0x60, 0x80},
-	{GC0339_8BIT, 0x65, 0x20}, /* 20 -> 21 */
-	{GC0339_8BIT, 0x6C, 0x40},
-	{GC0339_8BIT, 0x6D, 0x01},
-	{GC0339_8BIT, 0x6A, 0x33},
-	
-	{GC0339_8BIT, 0x4A, 0x50},
-	{GC0339_8BIT, 0x4B, 0x40},
-	{GC0339_8BIT, 0x4C, 0x40},
-	{GC0339_8BIT, 0xE8, 0x04},
-	{GC0339_8BIT, 0xE9, 0xBB},
-	
-	{GC0339_8BIT, 0x42, 0x20},
-	{GC0339_8BIT, 0x47, 0x10},
-	
-	{GC0339_8BIT, 0x50, 0x80},
-	
-	{GC0339_8BIT, 0xD0, 0x00},
-	{GC0339_8BIT, 0xD2, 0x00}, /* disable AE */
-	{GC0339_8BIT, 0xD3, 0x50},
-	
-	{GC0339_8BIT, 0x71, 0x01},
-	{GC0339_8BIT, 0x72, 0x01},
-	{GC0339_8BIT, 0x73, 0x05},
-	{GC0339_8BIT, 0x74, 0x01},
-	{GC0339_8BIT, 0x76, 0x03},
-	{GC0339_8BIT, 0x79, 0x01},
-	{GC0339_8BIT, 0x7B, 0x03},
-#else
-	{GC0339_8BIT, 0xfc, 0x10},
-	{GC0339_8BIT, 0xfe, 0x00},
-	{GC0339_8BIT, 0xf6, 0x07},
-	{GC0339_8BIT, 0xf7, 0x01},
-	{GC0339_8BIT, 0xf7, 0x03},
-	{GC0339_8BIT, 0xfc, 0x16},
-	{GC0339_8BIT, 0x06, 0x01},
-	{GC0339_8BIT, 0x08, 0x00},
-	{GC0339_8BIT, 0x09, 0x01},
-	{GC0339_8BIT, 0x0a, 0xf2},
-	{GC0339_8BIT, 0x0b, 0x02},
-	{GC0339_8BIT, 0x0c, 0x94},
-	{GC0339_8BIT, 0x0f, 0x02},
-	{GC0339_8BIT, 0x14, 0x23},
-	{GC0339_8BIT, 0x1a, 0x21},
-	{GC0339_8BIT, 0x1b, 0x08},
-	{GC0339_8BIT, 0x1c, 0x19},
-	{GC0339_8BIT, 0x1d, 0xea},
-	{GC0339_8BIT, 0x61, 0x2b},
-	{GC0339_8BIT, 0x62, 0x34},
-	{GC0339_8BIT, 0x63, 0x03},
-	{GC0339_8BIT, 0x30, 0xb7},
-	{GC0339_8BIT, 0x31, 0x7f},
-	{GC0339_8BIT, 0x32, 0x00},
-	{GC0339_8BIT, 0x39, 0x04},
-	{GC0339_8BIT, 0x3a, 0x20},
-	{GC0339_8BIT, 0x3b, 0x20},
-	{GC0339_8BIT, 0x3c, 0x04},
-	{GC0339_8BIT, 0x3d, 0x04},
-	{GC0339_8BIT, 0x3e, 0x04},
-	{GC0339_8BIT, 0x3f, 0x04},
-	{GC0339_8BIT, 0x69, 0x03},
-	//{GC0339_8BIT, 0x60, 0x82},
-	{GC0339_8BIT, 0x65, 0x10},
-	{GC0339_8BIT, 0x6c, 0x40},
-	{GC0339_8BIT, 0x6d, 0x01},
-	{GC0339_8BIT, 0x67, 0x10},
-	{GC0339_8BIT, 0x4a, 0x40},
-	{GC0339_8BIT, 0x4b, 0x40},
-	{GC0339_8BIT, 0x4c, 0x40},
-	{GC0339_8BIT, 0xe8, 0x04},
-	{GC0339_8BIT, 0xe9, 0xbb},
-	{GC0339_8BIT, 0x42, 0x20},
-	{GC0339_8BIT, 0x47, 0x10},
-	{GC0339_8BIT, 0x50, 0x40},
-	{GC0339_8BIT, 0xd0, 0x00},
-	{GC0339_8BIT, 0xd3, 0x50},
-	{GC0339_8BIT, 0xf6, 0x05},
-	{GC0339_8BIT, 0x01, 0x6a},
-	{GC0339_8BIT, 0x02, 0x0c},
-	{GC0339_8BIT, 0x0f, 0x00},
-	{GC0339_8BIT, 0x6a, 0x55},//11
-	{GC0339_8BIT, 0x71, 0x01},
-	{GC0339_8BIT, 0x72, 0x01},
-	{GC0339_8BIT, 0x73, 0x01},
-	{GC0339_8BIT, 0x79, 0x01},
-	{GC0339_8BIT, 0x7a, 0x01},
-	{GC0339_8BIT, 0x2e, 0x10},
-	{GC0339_8BIT, 0x2b, 0x00},
-	{GC0339_8BIT, 0x2c, 0x03},
-	{GC0339_8BIT, 0xd2, 0x00},
-	{GC0339_8BIT, 0x20, 0xb0},
-	//{GC0339_8BIT, 0x60, 0x92},
-#endif
-	{GC0339_TOK_TERM, 0, 0},
-};
-
-static struct gc0339_reg const gc0339_VGA_30fps[] = {
-#if REG_VER1
-	{GC0339_8BIT, 0x15, 0x0A},
-	{GC0339_8BIT, 0x62, 0x20},
-	{GC0339_8BIT, 0x63, 0x03},
-	{GC0339_8BIT, 0x06, 0x00}, /* Row_start */
-	{GC0339_8BIT, 0x08, 0x05}, /* Column start */
-	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
-	{GC0339_8BIT, 0x0A, 0xE4},
-	{GC0339_8BIT, 0x0B, 0x02}, /* Window width */
-	{GC0339_8BIT, 0x0C, 0x84},
-#else
-	{GC0339_8BIT, 0x15, 0x0A},
-	{GC0339_8BIT, 0x62, 0x34},
-	{GC0339_8BIT, 0x63, 0x03},
-	{GC0339_8BIT, 0x06, 0x01}, /* Row_start */
-	{GC0339_8BIT, 0x08, 0x00}, /* Column start */
-	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
-	{GC0339_8BIT, 0x0a, 0xf2},
-	{GC0339_8BIT, 0x0b, 0x02}, /* Window width */
-	{GC0339_8BIT, 0x0c, 0x94},
-#endif
-	{GC0339_TOK_TERM, 0, 0},
-};
-
-static struct gc0339_reg const gc0339_CIF_30fps[] = {
-#if REG_VER1
-	{GC0339_8BIT, 0x15, 0x8A}, /* CIF */
-	{GC0339_8BIT, 0x62, 0xBD}, /* LWC */
-	{GC0339_8BIT, 0x63, 0x01},
-	{GC0339_8BIT, 0x06, 0x00}, /* Row_start */
-	{GC0339_8BIT, 0x08, 0x05}, /* Column start */
-	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
-	{GC0339_8BIT, 0x0A, 0xD0},
-	{GC0339_8BIT, 0x0B, 0x02}, /* Window width */
-	{GC0339_8BIT, 0x0C, 0x40},
-#else
-	{GC0339_8BIT, 0x15, 0x8A}, /* CIF */
-	{GC0339_8BIT, 0x62, 0xD1}, /* LWC */
-	{GC0339_8BIT, 0x63, 0x01}, /* (368 + 4) / 4 * 5 */
-	{GC0339_8BIT, 0x06, 0x00}, /* Row_start */
-	{GC0339_8BIT, 0x08, 0x05}, /* Column start */
-	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
-	{GC0339_8BIT, 0x0A, 0xD0},
-	{GC0339_8BIT, 0x0B, 0x02}, /* Window width */
-	{GC0339_8BIT, 0x0C, 0x40},
-#endif
-	{GC0339_TOK_TERM, 0, 0},
-};
-
-struct gc0339_resolution gc0339_res_preview[] = {
-#if REG_VER1
-	{
-		.desc = "gc0339_VGA_30fps",
-		.width = 640,
-		.height = 480,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x0314,
-		.lines_per_frame = 0x0213,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 2,
-		.regs = gc0339_VGA_30fps,
-	},
-#else
-	{
-		.desc = "gc0339_VGA_30fps",
-		.width = 656,
-		.height = 496,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x0314,
-		.lines_per_frame = 0x0213,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 2,
-		.regs = gc0339_VGA_30fps,
-	},
-#endif
-};
-#define N_RES_PREVIEW (ARRAY_SIZE(gc0339_res_preview))
-
-struct gc0339_resolution gc0339_res_still[] = {
-#if REG_VER1
-	{
-		.desc = "gc0339_VGA_30fps",
-		.width = 640,
-		.height = 480,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x0314,
-		.lines_per_frame = 0x0213,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 2,
-		.regs = gc0339_VGA_30fps,
-	},
-#else
-	{
-		.desc = "gc0339_VGA_30fps",
-		.width = 656,
-		.height = 496,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x0314,
-		.lines_per_frame = 0x0213,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 2,
-		.regs = gc0339_VGA_30fps,
-	},
-#endif
-};
-#define N_RES_STILL (ARRAY_SIZE(gc0339_res_still))
-
-struct gc0339_resolution gc0339_res_video[] = {
-#if REG_VER1
-#if 0
-	{
-		.desc = "gc0339_CIF_30fps",
-		.width = 352,
-		.height = 288,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x01F0,
-		.lines_per_frame = 0x014F,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 1,
-		.regs = gc0339_CIF_30fps,
-	},
-#endif
-	{
-		.desc = "gc0339_VGA_30fps",
-		.width = 640,
-		.height = 480,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x0314,
-		.lines_per_frame = 0x0213,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 2,
-		.regs = gc0339_VGA_30fps,
-	},
-#else
-	{
-		.desc = "gc0339_CIF_30fps",
-		.width = 368,
-		.height = 304,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x01F0,
-		.lines_per_frame = 0x014F,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 1,
-		.regs = gc0339_CIF_30fps,
-	},
-	{
-		.desc = "gc0339_VGA_30fps",
-		.width = 656,
-		.height = 496,
-		.fps = 30,
-		//.pix_clk_freq = 73,
-		.used = 0,
-		.pixels_per_line = 0x0314,
-		.lines_per_frame = 0x0213,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 2,
-		.regs = gc0339_VGA_30fps,
-	},
-#endif
-};
-#define N_RES_VIDEO (ARRAY_SIZE(gc0339_res_video))
-
-static struct gc0339_resolution *gc0339_res = gc0339_res_preview;
-static int N_RES = N_RES_PREVIEW;
-#endif
-
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
index 93b232f..4c104aa 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
@@ -1,7 +1,7 @@
 /*
- * Support for Sony gc2235 8MP camera sensor.
+ * Support for GalaxyCore GC2235 2M camera sensor.
  *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -18,92 +18,79 @@
  * 02110-1301, USA.
  *
  */
-#include <linux/bitops.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <linux/fs.h>
-#include <linux/gpio.h>
-#include <linux/init.h>
-#include <linux/i2c.h>
-#include <linux/acpi.h>
-#include <linux/io.h>
+
+#include <linux/module.h>
+#include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
-#include <linux/kmod.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
 #include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
 #include <linux/slab.h>
-#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
 #include <media/v4l2-device.h>
-#include <asm/intel-mid.h>
-#include <linux/atomisp_gmin_platform.h>
-#include "gc2235.h"
-
-#ifndef POWER_ALWAYS_ON_BEFORE_SUSPEND
-#define POWER_ALWAYS_ON_BEFORE_SUSPEND
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
 #endif
+#include <linux/io.h>
 
-static enum atomisp_bayer_order gc2235_bayer_order_mapping[] = {
-	atomisp_bayer_order_gbrg,
-	atomisp_bayer_order_bggr,
-	atomisp_bayer_order_rggb,
-	atomisp_bayer_order_grbg,
-};
-
-u16 g_gain = 0, g_exposure = 0;
-u8 g_flip = 0x14;
+#include "gc2235.h"
 
-static int
-gc2235_read_reg(struct i2c_client *client, u8 len, u8 reg, u8 *val)
+/* i2c read/write stuff */
+static int gc2235_read_reg(struct i2c_client *client,
+			   u16 data_length, u16 reg, u16 *val)
 {
+	int err;
 	struct i2c_msg msg[2];
-	unsigned char data[GC2235_SHORT_MAX];
-	int err, i;
+	unsigned char data[6];
 
-	if (len > GC2235_BYTE_MAX) {
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != GC2235_8BIT) {
 		dev_err(&client->dev, "%s error, invalid data length\n",
 			__func__);
 		return -EINVAL;
 	}
 
 	memset(msg, 0 , sizeof(msg));
-	memset(data, 0 , sizeof(data));
 
 	msg[0].addr = client->addr;
 	msg[0].flags = 0;
 	msg[0].len = 1;
-	msg[0].buf = (u8 *)data;
-	/* high byte goes first */
-	data[0] = reg;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg & 0xff);
 
 	msg[1].addr = client->addr;
-	msg[1].len = len;
+	msg[1].len = data_length;
 	msg[1].flags = I2C_M_RD;
-	msg[1].buf = (u8 *)data;
+	msg[1].buf = data;
 
 	err = i2c_transfer(client->adapter, msg, 2);
 	if (err != 2) {
 		if (err >= 0)
 			err = -EIO;
-		goto error;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
 	}
 
+	*val = 0;
 	/* high byte comes first */
-	if (len == GC2235_8BIT) {
+	if (data_length == GC2235_8BIT)
 		*val = (u8)data[0];
-	} else {
-		/* 16-bit access is default when len > 1 */
-		for (i = 0; i < (len >> 1); i++)
-			val[i] = be16_to_cpu(data[i]);
-	}
 
 	return 0;
-
-error:
-	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
-	return err;
 }
 
 static int gc2235_i2c_write(struct i2c_client *client, u16 len, u8 *data)
@@ -116,33 +103,27 @@ static int gc2235_i2c_write(struct i2c_client *client, u16 len, u8 *data)
 	msg.flags = 0;
 	msg.len = len;
 	msg.buf = data;
-
 	ret = i2c_transfer(client->adapter, &msg, 1);
 
 	return ret == num_msg ? 0 : -EIO;
 }
 
-static int
-gc2235_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
+static int gc2235_write_reg(struct i2c_client *client, u16 data_length,
+							u8 reg, u8 val)
 {
 	int ret;
 	unsigned char data[4] = {0};
-	const u16 len = data_length + 1; /* 16-bit address + data */
+	const u16 len = data_length + sizeof(u8); /* 16-bit address + data */
 
-	if (data_length != GC2235_8BIT && data_length != GC2235_16BIT) {
-		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+	if (data_length != GC2235_8BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
 		return -EINVAL;
 	}
 
 	/* high byte goes out first */
 	data[0] = reg;
-	if (data_length == GC2235_8BIT)
-		data[1] = (u8)(val);
-	else {
-		/* GC2235_16BIT */
-		u16 *wdata = (u16 *)&data[2];
-		*wdata = cpu_to_be16(val);
-	}
+	data[1] = val;
 
 	ret = gc2235_i2c_write(client, len, data);
 	if (ret)
@@ -152,728 +133,323 @@ gc2235_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
 
 	return ret;
 }
-
-static int gc2235_write_reg_array(struct i2c_client *client,
-				   const struct gc2235_reg *reglist)
+static int __gc2235_flush_reg_array(struct i2c_client *client,
+				    struct gc2235_write_ctrl *ctrl)
 {
-	const struct gc2235_reg *next = reglist;
-	struct gc2235_write_ctrl ctrl;
-
-	ctrl.index = 0;
-	for (; next->type != GC2235_TOK_TERM; next++) {
-		switch (next->type & GC2235_TOK_MASK) {
-		case GC2235_TOK_DELAY:
-			msleep(next->val);
-			break;
+	u16 size;
 
-		default:
-			gc2235_write_reg(client, GC2235_8BIT,
-			       next->sreg, next->val);
-		}
-	}
-
-	return 0;
-}
-
-static int __gc2235_update_exposure_timing(struct i2c_client *client,
-					u16 exposure, u16 llp, u16 fll)
-{
-	int ret = 0;
-	u8 expo_coarse_h, expo_coarse_l;
-
-	/* Increase the VTS to match exposure + margin */
-	if (exposure > fll - GC2235_INTEGRATION_TIME_MARGIN)
-		fll = exposure + GC2235_INTEGRATION_TIME_MARGIN;
-
-	expo_coarse_h = (u8)(exposure >> 8);
-	expo_coarse_l = (u8)(exposure & 0xff);
-	ret = gc2235_write_reg(client, GCSENSOR_8BIT, GC2235_REG_EXPO_COARSE, expo_coarse_h);
-	if (ret)
-		return ret;
-	ret = gc2235_write_reg(client, GCSENSOR_8BIT, GC2235_REG_EXPO_COARSE+1, expo_coarse_l);
-
-	return ret;
-}
-
-static int __gc2235_update_gain(struct v4l2_subdev *sd, u16 gain)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 temp;
+	if (ctrl->index == 0)
+		return 0;
 
-	/* set global gain */
-	if (256 > gain)	{
-		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb0, 0x40);
-		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb1, gain & 0xff);
-	} else {
-		temp = 64 * gain / 256;
-		if (temp > 0xff)
-			temp = 0xff;
-		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb0, temp & 0xff);
-		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb1, 0xff);
-	}
+	size = sizeof(u8) + ctrl->index; /* 8-bit address + data */
+	ctrl->index = 0;
 
-	return 0;
+	return gc2235_i2c_write(client, size, (u8 *)&ctrl->buffer);
 }
 
-static int gc2235_set_exposure_gain(struct v4l2_subdev *sd, u16 coarse_itg,
-	u16 gain, u16 digitgain)
+static int __gc2235_buf_reg_array(struct i2c_client *client,
+				  struct gc2235_write_ctrl *ctrl,
+				  const struct gc2235_reg *next)
 {
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	/* Validate exposure:  cannot exceed VTS-4 where VTS is 16bit */
-	coarse_itg = clamp_t(u16, coarse_itg, 0, GC2235_MAX_EXPOSURE_SUPPORTED);
+	int size;
 
-	/* Validate gain: must not exceed maximum 8bit value */
-	gain = clamp_t(u16, gain, 0, GC2235_MAX_GLOBAL_GAIN_SUPPORTED);
-	g_gain = gain;
-	g_exposure = coarse_itg;
-
-	mutex_lock(&dev->input_lock);
+	if (next->type != GC2235_8BIT)
+		return -EINVAL;
 
-	ret = __gc2235_update_exposure_timing(client, coarse_itg,
-			dev->pixels_per_line, dev->lines_per_frame);
-	if (ret)
-		goto out;
-	dev->coarse_itg = coarse_itg;
+	size = 1;
+	ctrl->buffer.data[ctrl->index] = (u8)next->val;
 
-	ret = __gc2235_update_gain(sd, gain);
-	if (ret)
-		goto out;
-	dev->gain = gain;
-out:
-	mutex_unlock(&dev->input_lock);
-	return ret;
-}
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
 
-static long gc2235_s_exposure(struct v4l2_subdev *sd,
-			       struct atomisp_exposure *exposure)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	ctrl->index += size;
 
-	dev_dbg(&client->dev, "%s(0x%X 0x%X 0x%X)\n", __func__, exposure->integration_time[0], exposure->gain[0], exposure->gain[1]);
-	return gc2235_set_exposure_gain(sd, exposure->integration_time[0],
-				exposure->gain[0], exposure->gain[1]);
-}
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u8) >= GC2235_MAX_WRITE_BUF_SIZE)
+		return __gc2235_flush_reg_array(client, ctrl);
 
-static long gc2235_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
-{
-	switch (cmd) {
-	case ATOMISP_IOC_S_EXPOSURE:
-		return gc2235_s_exposure(sd, arg);
-	default:
-		return -EINVAL;
-	}
 	return 0;
 }
-
-static int power_ctrl(struct v4l2_subdev *sd, int flag)
+static int __gc2235_write_reg_is_consecutive(struct i2c_client *client,
+					     struct gc2235_write_ctrl *ctrl,
+					     const struct gc2235_reg *next)
 {
-	int ret;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
+	if (ctrl->index == 0)
+		return 1;
 
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->power_ctrl)
-		return dev->platform_data->power_ctrl(sd, flag);
-
-       if (flag) {
-               ret = dev->platform_data->v1p8_ctrl(sd, 1);
-               usleep_range(60, 90);
-               ret = dev->platform_data->v2p8_ctrl(sd, 1);
-               msleep(20);
-       } else {
-               ret = dev->platform_data->v2p8_ctrl(sd, 0);
-               ret |= dev->platform_data->v1p8_ctrl(sd, 0);
-       }
-       return ret;
+	return ctrl->buffer.addr + ctrl->index == next->reg;
 }
-
-static int gpio_ctrl(struct v4l2_subdev *sd, int flag)
-{
-	int ret;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->gpio_ctrl)
-		return dev->platform_data->gpio_ctrl(sd, flag);
-
-	/* GPIO0 == "reset" (active low), GPIO1 == "power down" */
-	if (flag) {
-		ret = dev->platform_data->gpio1_ctrl(sd, 0);
-		ret |= dev->platform_data->gpio0_ctrl(sd, 1);
-	} else {
-		ret = dev->platform_data->gpio1_ctrl(sd, 1);
-		ret |= dev->platform_data->gpio0_ctrl(sd, 0);
-	}
-	return ret;
-}
-
-
-static int power_up(struct v4l2_subdev *sd)
+static int gc2235_write_reg_array(struct i2c_client *client,
+				  const struct gc2235_reg *reglist)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	int ret;
-
-       /* power control */
-	ret = power_ctrl(sd, 1);
-	if (ret)
-		goto fail_power;
-
-	/* flis clock control*/
-	ret = dev->platform_data->flisclk_ctrl(sd, 1);
-	if (ret)
-		goto fail_clk;
-
-	/*MCLK to PWDN*/
-	usleep_range(1000, 1500);
+	const struct gc2235_reg *next = reglist;
+	struct gc2235_write_ctrl ctrl;
+	int err;
 
-	/* gpio ctrl*/
-	ret = gpio_ctrl(sd, 1);
-	if (ret) {
-		dev_err(&client->dev, "gpio failed\n");
-		goto fail_gpio;
+	ctrl.index = 0;
+	for (; next->type != GC2235_TOK_TERM; next++) {
+		switch (next->type & GC2235_TOK_MASK) {
+		case GC2235_TOK_DELAY:
+			err = __gc2235_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__gc2235_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __gc2235_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __gc2235_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
 	}
 
-	msleep(50);
-	return 0;
-
-fail_gpio:
-	gpio_ctrl(sd, 0);
-fail_clk:
-	dev->platform_data->flisclk_ctrl(sd, 0);
-fail_power:
-	power_ctrl(sd, 0);
-	dev_err(&client->dev, "sensor power-up failed\n");
-
-	return ret;
-}
-
-static int power_down(struct v4l2_subdev *sd)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	ret = dev->platform_data->flisclk_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "flisclk failed\n");
-
-	/* gpio ctrl*/
-	ret = gpio_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "gpio failed\n");
-
-	/* power control */
-	ret = power_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "vprog failed.\n");
-
-	msleep(20);
-
-	return ret;
+	return __gc2235_flush_reg_array(client, &ctrl);
 }
 
-static int gc2235_set_suspend(struct v4l2_subdev *sd)
+static int gc2235_g_focal(struct v4l2_subdev *sd, s32 *val)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x03);
-	gc2235_write_reg(client, GCSENSOR_8BIT,  0x10, 0x81);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
-
+	*val = (GC2235_FOCAL_LENGTH_NUM << 16) | GC2235_FOCAL_LENGTH_DEM;
 	return 0;
 }
 
-static int gc2235_set_streaming(struct v4l2_subdev *sd)
+static int gc2235_g_fnumber(struct v4l2_subdev *sd, s32 *val)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x30);
-	__gc2235_update_exposure_timing(client, g_exposure, 0, 0);
-	__gc2235_update_gain(sd, g_gain);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x03);
-	gc2235_write_reg(client, GCSENSOR_8BIT,  0x10, 0x91);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
+	/*const f number for imx*/
+	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 16) | GC2235_F_NUMBER_DEM;
 	return 0;
 }
 
-static int gc2235_init_common(struct v4l2_subdev *sd)
+static int gc2235_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = -1;
-
-       if (0 != (ret = gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x80))) {
-               dev_err(&client->dev, "%s:init common error", __func__);
-               return ret;
-       }
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x80);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x80);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf2, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf6, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfc, 0x06);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf7, 0x15);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf8, 0x85);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfa, 0x00);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf9, 0xfe);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x03, 0x04);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x04, 0xb0);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x05, 0x01);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x06, 0x2a);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x07, 0x00);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x08, 0x30);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0a, 0x02);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0c, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0d, 0x04);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0e, 0xd0);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0f, 0x06);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x10, 0x58);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x17, 0x14);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x17, g_flip);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x18, 0x12);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x19, 0x0d);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1a, 0x01);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1b, 0x48);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1e, 0x88);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1f, 0x48);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x20, 0x03);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x21, 0x6f);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x22, 0x80);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x23, 0xc1);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x24, 0x2f);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x26, 0x01);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x27, 0x30);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x3f, 0x00);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x8b, 0xa4);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x8c, 0x02);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x90, 0x01);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x92, 0x02);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x94, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x95, 0x04);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x96, 0xc0);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x97, 0x06);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x98, 0x50);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x40, 0x72);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x41, 0x04);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x5e, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x5f, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x60, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x61, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x62, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x63, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x64, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x65, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x66, 0x20);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x67, 0x20);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x68, 0x20);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x69, 0x20);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb2, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb3, 0x40);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb4, 0x40);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb5, 0x40);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb8, 0x0f);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb9, 0x23);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xba, 0xff);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbc, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbd, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbe, 0xff);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbf, 0x09);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x03);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x01, 0x07);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x02, 0x11);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x03, 0x11);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x06, 0x80);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x11, 0x2b);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x12, 0xe4);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x13, 0x07);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x15, 0x12);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x04, 0x20);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x05, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x17, 0x01);
-
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x21, 0x01);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x22, 0x02);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x23, 0x01);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x29, 0x02);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0x2a, 0x01);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
-	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf2, 0x00);
-
+	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 24) |
+		(GC2235_F_NUMBER_DEM << 16) |
+		(GC2235_F_NUMBER_DEFAULT_NUM << 8) | GC2235_F_NUMBER_DEM;
 	return 0;
 }
 
-static int __gc2235_s_power(struct v4l2_subdev *sd, int on)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	int ret = 0;
-
-	if (on == 0) {
-		ret = power_down(sd);
-		dev->power = 0;
-	} else {
-		ret = power_up(sd);
-		if (!ret) {
-			dev->power = 1;
-			return gc2235_init_common(sd);
-		}
-	}
-
-	return ret;
-}
-
-#ifndef POWER_ALWAYS_ON_BEFORE_SUSPEND
-static int gc2235_s_power(struct v4l2_subdev *sd, int on)
-{
-	int ret;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-
-	mutex_lock(&dev->input_lock);
-	ret = __gc2235_s_power(sd, on);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-#endif
-
-#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
-static int __gc2235_s_power_always_on(struct v4l2_subdev *sd, int on)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	int ret = 0;
-
-	if (on == 0) {
-		//ret = power_down(sd);
-		//dev->power = 0;
-	} else {
-		if (!dev->power) {
-			ret = power_up(sd);
-			if (!ret) {
-				dev->power = 1;
-				dev->once_launched = 1;
-				return gc2235_init_common(sd);
-			}
-		}
-	}
-
-	return ret;
-}
-
-static int gc2235_s_power_always_on(struct v4l2_subdev *sd, int on)
-{
-	int ret;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-
-	mutex_lock(&dev->input_lock);
-	ret = __gc2235_s_power_always_on(sd, on);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-#endif
 
 static int gc2235_get_intg_factor(struct i2c_client *client,
 				struct camera_mipi_info *info,
-				const struct gc2235_reg *reglist)
+				const struct gc2235_resolution *res)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	struct atomisp_sensor_mode_data *buf = &info->data;
+	u16 reg_val, reg_val_h, dummy;
 	int ret;
-	u8 data[GC2235_INTG_BUF_COUNT];
-
-	u32 vt_pix_clk_freq_mhz;
-	u32 coarse_integration_time_min;
-	u32 coarse_integration_time_max_margin;
-	u16 tmp;
 
 	if (info == NULL)
 		return -EINVAL;
 
-	ret =  gc2235_write_reg(client, 1, 0xfe, 0);
-	if (ret)
-		return ret;
-
-	memset(data, 0, GC2235_INTG_BUF_COUNT);
-	coarse_integration_time_min = 1;
-	coarse_integration_time_max_margin = 6;
+	/* pixel clock calculattion */
+	buf->vt_pix_clk_freq_mhz = dev->vt_pix_clk_freq_mhz = 43750000;
 
-	vt_pix_clk_freq_mhz = 67200000;
-
-	dev->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
-
-	buf->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
-	buf->coarse_integration_time_min = coarse_integration_time_min;
+	/* get integration time */
+	buf->coarse_integration_time_min = GC2235_COARSE_INTG_TIME_MIN;
 	buf->coarse_integration_time_max_margin =
-				coarse_integration_time_max_margin;
-
-	buf->fine_integration_time_min = GC2235_FINE_INTG_TIME;
-	buf->fine_integration_time_max_margin = GC2235_FINE_INTG_TIME;
-	buf->fine_integration_time_def = GC2235_FINE_INTG_TIME;
-
-	buf->frame_length_lines = dev->curr_res_table[dev->fmt_idx].lines_per_frame;
-	buf->line_length_pck = dev->curr_res_table[dev->fmt_idx].pixels_per_line;
-	buf->read_mode = dev->curr_res_table[dev->fmt_idx].bin_mode;
-
-	/* Get the cropping and output resolution to ISP for this mode. */
-	tmp = 0;
-	ret = gc2235_read_reg(client, 1, GC2235_HORIZONTAL_START_H, data);
-	if (ret)
-		return ret;
-	tmp = (data[0] & 0x07) << 8;
-	ret =  gc2235_read_reg(client, 1, GC2235_HORIZONTAL_START_L, data);
+					GC2235_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = GC2235_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					GC2235_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = GC2235_FINE_INTG_TIME_MIN;
+	buf->frame_length_lines = res->lines_per_frame;
+	buf->line_length_pck = res->pixels_per_line;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_H_CROP_START_H, &reg_val_h);
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_H_CROP_START_L, &reg_val);
 	if (ret)
 		return ret;
-	tmp += data[0] & 0x7f;
-	buf->crop_horizontal_start = tmp;
 
-	tmp = 0;
-	ret = gc2235_read_reg(client, 1, GC2235_VERTICAL_START_H, data);
-	if (ret)
-		return ret;
-	tmp = data[0] << 8;
-	ret =  gc2235_read_reg(client, 1, GC2235_VERTICAL_START_L, data);
-	if (ret)
-		return ret;
-	tmp += data[0];
-	buf->crop_vertical_start = tmp;
+	buf->crop_horizontal_start = ((u16)reg_val_h << 8) | (u16)reg_val;
 
-	tmp = 0;
-	ret = gc2235_read_reg(client, 1, GC2235_HORIZONTAL_OUTPUT_SIZE_H, data);
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_V_CROP_START_H, &reg_val_h);
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_V_CROP_START_L, &reg_val);
 	if (ret)
 		return ret;
-	tmp = (data[0] & 0x07) << 8;
-	ret = gc2235_read_reg(client, 1, GC2235_HORIZONTAL_OUTPUT_SIZE_L, data);
-	if (ret)
-		return ret;
-	tmp += data[0] & 0x7f ;
-	buf->output_width = tmp;
-	buf->crop_horizontal_end = buf->crop_horizontal_start + tmp - 1;
 
-	tmp = 0;
-	ret = gc2235_read_reg(client, 1, GC2235_VERTICAL_OUTPUT_SIZE_H, data);
-	if (ret)
-		return ret;
-	tmp = (data[0] & 0x07) << 8;
-	ret = gc2235_read_reg(client, 1, GC2235_VERTICAL_OUTPUT_SIZE_L, data);
-	if (ret)
-		return ret;
-	tmp += data[0];
-	buf->output_height = tmp;
-	buf->crop_vertical_end = tmp + buf->crop_vertical_start - 1;
+	buf->crop_vertical_start = ((u16)reg_val_h << 8) | (u16)reg_val;
 
-	tmp = 0;
-	ret = gc2235_read_reg(client, GC2235_8BIT, REG_HORI_BLANKING_H, data);
-	tmp = (data[0] & 0x0f) << 8;
-	ret = gc2235_read_reg(client, GC2235_8BIT, REG_HORI_BLANKING_L, data);
-	tmp += data[0];
-
-	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_SH_DELAY_H, data);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_H_OUTSIZE_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_H_OUTSIZE_L, &reg_val);
 	if (ret)
 		return ret;
-	tmp += (data[0] & 0x03) << 8;
+	buf->output_width = ((u16)reg_val_h << 8) | (u16)reg_val;
 
-	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_SH_DELAY_L, data);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_V_OUTSIZE_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_V_OUTSIZE_L, &reg_val);
 	if (ret)
 		return ret;
-	tmp += data[0];
-
-	buf->line_length_pck = (buf->output_width / 2 + tmp + 4) * 2;
+	buf->output_height = ((u16)reg_val_h << 8) | (u16)reg_val;
 
-	tmp = 0;
-	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_VERT_DUMMY_H, data);
-	tmp = (data[0] & 0x1f) << 8;
-	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_VERT_DUMMY_L, data);
-	tmp += data[0];
-	buf->frame_length_lines = buf->output_height + tmp;
+	buf->crop_horizontal_end = buf->crop_horizontal_start +
+						buf->output_width - 1;
+	buf->crop_vertical_end = buf->crop_vertical_start +
+						buf->output_height - 1;
 
-	buf->binning_factor_x = 1;
-	buf->binning_factor_y = 1;
-
-	return 0;
-}
-
-/* This returns the exposure time being used. This should only be used
-   for filling in EXIF data, not for actual image processing. */
-static int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 coarse;
-	u8 tmp;
-	int ret;
-
-	/* the fine integration time is currently not calculated */
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-			       GC2235_REG_EXPO_COARSE, &tmp);
-	if (ret != 0)
+					GC2235_HB_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_HB_L, &reg_val);
+	if (ret)
 		return ret;
 
-	coarse = (u16)((tmp & 0x1f) << 8);
+	dummy = ((u16)reg_val_h << 8) | (u16)reg_val;
 
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-			       GC2235_REG_EXPO_COARSE + 1, &tmp);
+                                        GC2235_SH_DELAY_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_SH_DELAY_L, &reg_val);
 
-	if (ret != 0)
+	buf->line_length_pck = buf->output_width + 16 + dummy +
+				(((u16)reg_val_h << 8) | (u16)reg_val) + 4;
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_VB_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_VB_L, &reg_val);
+	if (ret)
 		return ret;
 
-	coarse += (u16)tmp;
-
-	*value = coarse;
-
-	return ret;
-}
-
-static enum v4l2_mbus_pixelcode
-gc2235_translate_bayer_order(enum atomisp_bayer_order code)
-{
-	switch (code) {
-	case atomisp_bayer_order_rggb:
-		return V4L2_MBUS_FMT_SRGGB10_1X10;
-	case atomisp_bayer_order_grbg:
-		return V4L2_MBUS_FMT_SGRBG10_1X10;
-	case atomisp_bayer_order_bggr:
-		return V4L2_MBUS_FMT_SBGGR10_1X10;
-	case atomisp_bayer_order_gbrg:
-		return V4L2_MBUS_FMT_SGBRG10_1X10;
-	}
+	buf->frame_length_lines = buf->output_height + 32 +
+				(((u16)reg_val_h << 8) | (u16)reg_val);
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
 	return 0;
 }
 
-static int gc2235_v_flip(struct v4l2_subdev *sd, s32 value)
+static long __gc2235_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
 {
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct camera_mipi_info *gc2235_info = NULL;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-	u8 val;
+	u16 coarse_integration = (u16)coarse_itg;
+	int ret = 0;
+	u16 expo_coarse_h,expo_coarse_l, gain_val = 0xF0, gain_val2 = 0xF0;
+	expo_coarse_h = coarse_integration>>8;
+	expo_coarse_l = coarse_integration & 0xff;
 
-	val = g_flip;
-	dev_dbg(&client->dev, "@%s++ %d, 0x17:0x%x\n", __func__, value, val);
-	if (value) {
-		val |= GC2235_VFLIP_BIT;
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_H, expo_coarse_h);
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_L, expo_coarse_l);
+
+	if (gain <= 0x58) {
+		gain_val = 0x40;
+		gain_val2 = 0x58;
+	} else if (gain < 256) {
+		gain_val = 0x40;
+		gain_val2 = gain;
 	} else {
-		val &= ~GC2235_VFLIP_BIT;
+		gain_val2 = 64 * gain / 256;
+		gain_val = 0xff;
 	}
+
 	ret = gc2235_write_reg(client, GC2235_8BIT,
-		GC2235_IMG_ORIENTATION, val);
-	if (ret)
-		return ret;
-	g_flip = val;
-	gc2235_info = v4l2_get_subdev_hostdata(sd);
-	if (gc2235_info) {
-		val &= (GC2235_VFLIP_BIT|GC2235_HFLIP_BIT);
-		gc2235_info->raw_bayer_order = gc2235_bayer_order_mapping[val];
-		dev->format.code = gc2235_translate_bayer_order(
-			gc2235_info->raw_bayer_order);
-	}
+					GC2235_GLOBAL_GAIN, (u8)gain_val);
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+					GC2235_PRE_GAIN, (u8)gain_val2);
 
-	return 0;
+	return ret;
 }
 
-static int gc2235_h_flip(struct v4l2_subdev *sd, s32 value)
+static int gc2235_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct camera_mipi_info *gc2235_info = NULL;
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
-	u8 val;
-
-	val = g_flip;
-	dev_dbg(&client->dev, "@%s++ %d, 0x17:0x%x\n", __func__, value, val);
-	if (value){
-		val |= GC2235_HFLIP_BIT;
-	} else {
-		val &= ~GC2235_HFLIP_BIT;
-	}
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-		GC2235_IMG_ORIENTATION, val);
-	if (ret)
-		return ret;
 
-	g_flip = val;
-	gc2235_info = v4l2_get_subdev_hostdata(sd);
-	if (gc2235_info) {
-		val &= (GC2235_VFLIP_BIT|GC2235_HFLIP_BIT);
-		gc2235_info->raw_bayer_order = gc2235_bayer_order_mapping[val];
-		dev->format.code = gc2235_translate_bayer_order(
-		gc2235_info->raw_bayer_order);
-	}
+	mutex_lock(&dev->input_lock);
+	ret = __gc2235_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
 
-	return 0;
+	return ret;
 }
 
-static int gc2235_g_focal(struct v4l2_subdev *sd, s32 *val)
+static long gc2235_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
 {
-	*val = (GC2235_FOCAL_LENGTH_NUM << 16) | GC2235_FOCAL_LENGTH_DEM;
-	return 0;
-}
+	int exp = exposure->integration_time[0];
+	int gain = exposure->gain[0];
+	int digitgain = exposure->gain[1];
+
+	/* we should not accept the invalid value below. */
+	if (gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
 
-static int gc2235_g_fnumber(struct v4l2_subdev *sd, s32 *val)
-{
-	/*const f number for gc2235*/
-	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 16) | GC2235_F_NUMBER_DEM;
-	return 0;
+	return gc2235_set_exposure(sd, exp, gain, digitgain);
 }
 
-static int gc2235_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+static long gc2235_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 24) |
-		(GC2235_F_NUMBER_DEM << 16) |
-		(GC2235_F_NUMBER_DEFAULT_NUM << 8) | GC2235_F_NUMBER_DEM;
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return gc2235_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
 	return 0;
 }
 
 /* This returns the exposure time being used. This should only be used
    for filling in EXIF data, not for actual image processing. */
-static int gc2235_g_exposure(struct v4l2_subdev *sd, s32 *value)
+static int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 coarse;
-	u8 reg_val_h, reg_val_l;
+	u16 reg_v, reg_v2;
 	int ret;
 
-	/* the fine integration time is currently not calculated */
-	ret = gc2235_read_reg(client, GCSENSOR_8BIT,
-			       GC2235_REG_EXPO_COARSE, &reg_val_h);
+	/* get exposure */
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_L,
+					&reg_v);
 	if (ret)
-		return ret;
-
-	coarse = ((u16)(reg_val_h & 0x1f)) << 8;
+		goto err;
 
-	ret = gc2235_read_reg(client, GCSENSOR_8BIT,
-			       GC2235_REG_EXPO_COARSE + 1, &reg_val_l);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_H,
+					&reg_v2);
 	if (ret)
-		return ret;
+		goto err;
 
-	coarse |= reg_val_l;
+	reg_v += reg_v2 << 8;
 
-	*value = coarse;
-	return 0;
+	*value = reg_v;
+err:
+	return ret;
 }
 
 struct gc2235_control gc2235_controls[] = {
@@ -892,30 +468,6 @@ struct gc2235_control gc2235_controls[] = {
 	},
 	{
 		.qc = {
-			.id = V4L2_CID_VFLIP,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "Flip",
-			.minimum = 0,
-			.maximum = 1,
-			.step = 1,
-			.default_value = 0,
-		},
-		.tweak = gc2235_v_flip,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_HFLIP,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "Mirror",
-			.minimum = 0,
-			.maximum = 1,
-			.step = 1,
-			.default_value = 0,
-		},
-		.tweak = gc2235_h_flip,
-	},
-	{
-		.qc = {
 			.id = V4L2_CID_FOCAL_ABSOLUTE,
 			.type = V4L2_CTRL_TYPE_INTEGER,
 			.name = "focal length",
@@ -953,22 +505,9 @@ struct gc2235_control gc2235_controls[] = {
 		},
 		.query = gc2235_g_fnumber_range,
 	},
-	{
-		.qc = {
-			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "exposure",
-			.minimum = 0x0,
-			.maximum = 0xffff,
-			.step = 0x01,
-			.default_value = 0x00,
-			.flags = 0,
-		},
-		.query = gc2235_g_exposure,
-	},
 };
-
 #define N_CONTROLS (ARRAY_SIZE(gc2235_controls))
+
 static struct gc2235_control *gc2235_find_control(u32 id)
 {
 	int i;
@@ -994,7 +533,7 @@ static int gc2235_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
 	return 0;
 }
 
-/* gc2235 control set/get */
+/* imx control set/get */
 static int gc2235_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
 	struct gc2235_control *s_ctrl;
@@ -1028,338 +567,549 @@ static int gc2235_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 	ret = octrl->tweak(sd, ctrl->value);
 	mutex_unlock(&dev->input_lock);
 
-	return ret;
+	return ret;
+}
+static int __gc2235_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	/* restore settings */
+	gc2235_res = gc2235_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	return gc2235_write_reg_array(client, gc2235_init_settings);
+}
+
+static int gc2235_init(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+	ret = __gc2235_init(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
+	usleep_range(5000, 6000);
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+	usleep_range(5000, 6000);
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_power;
+	}
+
+	msleep(50);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int gc2235_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return gc2235_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct gc2235_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct gc2235_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &gc2235_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
 }
 
-static int get_resolution_index(struct v4l2_subdev *sd, int w, int h)
+static int get_resolution_index(int w, int h)
 {
 	int i;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
-	for (i = 0; i < dev->entries_curr_table; i++) {
-		if (w != dev->curr_res_table[i].width)
+	for (i = 0; i < N_RES; i++) {
+		if (w != gc2235_res[i].width)
 			continue;
-		if (h != dev->curr_res_table[i].height)
+		if (h != gc2235_res[i].height)
 			continue;
-		/* Found it */
+
 		return i;
 	}
+
 	return -1;
 }
 
 static int gc2235_try_mbus_fmt(struct v4l2_subdev *sd,
-				struct v4l2_mbus_framefmt *fmt)
+			struct v4l2_mbus_framefmt *fmt)
 {
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	int idx = 0;
-	const struct gc2235_resolution *tmp_res = NULL;
+	int idx;
 
-	mutex_lock(&dev->input_lock);
-
-	if ((fmt->width > gc2235_max_res[0].res_max_width)
-		|| (fmt->height > gc2235_max_res[0].res_max_height)) {
-		fmt->width =  gc2235_max_res[0].res_max_width;
-		fmt->height = gc2235_max_res[0].res_max_height;
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+					fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = gc2235_res[N_RES - 1].width;
+		fmt->height = gc2235_res[N_RES - 1].height;
 	} else {
-		for (idx = 0; idx < dev->entries_curr_table; idx++) {
-				tmp_res = &dev->curr_res_table[idx];
-				if ((tmp_res[idx].width >= fmt->width) &&
-					(tmp_res[idx].height >= fmt->height))
-					break;
-		}
-
-		/*
-		 * nearest_resolution_index() doesn't return smaller
-		 *  resolutions. If it fails, it means the requested
-		 *  resolution is higher than wecan support. Fallback
-		 *  to highest possible resolution in this case.
-		 */
-		if (idx == dev->entries_curr_table)
-			idx = dev->entries_curr_table - 1;
-
-		fmt->width = dev->curr_res_table[idx].width;
-		fmt->height = dev->curr_res_table[idx].height;
+		fmt->width = gc2235_res[idx].width;
+		fmt->height = gc2235_res[idx].height;
 	}
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
 
-	fmt->code = dev->format.code;
-
-	mutex_unlock(&dev->input_lock);
 	return 0;
 }
 
+static int startup(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	ret = gc2235_write_reg_array(client, gc2235_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 write register err.\n");
+		return ret;
+	}
+
+	return ret;
+}
+
 static int gc2235_s_mbus_fmt(struct v4l2_subdev *sd,
-			      struct v4l2_mbus_framefmt *fmt)
+			     struct v4l2_mbus_framefmt *fmt)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	const struct gc2235_reg *gc2235_def_reg;
-	struct camera_mipi_info *gc2235_info = NULL;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-	u8 val;
+	struct camera_mipi_info *gc2235_info = NULL;
+	int ret = 0;
 
 	gc2235_info = v4l2_get_subdev_hostdata(sd);
 	if (gc2235_info == NULL)
 		return -EINVAL;
 
-	ret = gc2235_try_mbus_fmt(sd, fmt);
-	if (ret)
-		return ret;
-
 	mutex_lock(&dev->input_lock);
-
-	dev->fmt_idx = get_resolution_index(sd, fmt->width, fmt->height);
-	/* Sanity check */
-	if (unlikely(dev->fmt_idx == -1)) {
-		ret = -EINVAL;
-		goto out;
+	ret = gc2235_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
 	}
 
-	gc2235_def_reg = dev->curr_res_table[dev->fmt_idx].regs;
-
-	ret = gc2235_write_reg_array(client, gc2235_def_reg);
-	if (ret)
-		goto out;
-	dev->fps = dev->curr_res_table[dev->fmt_idx].fps;
-	dev->pixels_per_line =
-		dev->curr_res_table[dev->fmt_idx].pixels_per_line;
-	dev->lines_per_frame =
-		dev->curr_res_table[dev->fmt_idx].lines_per_frame;
-	ret = __gc2235_update_exposure_timing(client, dev->coarse_itg,
-		dev->pixels_per_line, dev->lines_per_frame);
-	if (ret)
-		goto out;
+	dev->fmt_idx = get_resolution_index(fmt->width,
+					      fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
 
-	ret = gc2235_write_reg_array(client, gc2235_param_update);
-	if (ret)
-		goto out;
+	ret = startup(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 startup err\n");
+		goto err;
+	}
 
-	ret = gc2235_get_intg_factor(client, gc2235_info, gc2235_def_reg);
+	ret = gc2235_get_intg_factor(client, gc2235_info,
+					&gc2235_res[dev->fmt_idx]);
 	if (ret)
-		goto out;
+		dev_err(&client->dev, "failed to get integration_factor\n");
 
-	ret = gc2235_read_reg(client, GC2235_8BIT, GC2235_IMG_ORIENTATION, &val);
-	if (ret)
-		goto out;
-	val &= (GC2235_VFLIP_BIT|GC2235_HFLIP_BIT);
-	gc2235_info->raw_bayer_order = gc2235_bayer_order_mapping[val];
-	dev->format.code = gc2235_translate_bayer_order(
-		gc2235_info->raw_bayer_order);
-out:
+err:
 	mutex_unlock(&dev->input_lock);
 	return ret;
 }
-
 static int gc2235_g_mbus_fmt(struct v4l2_subdev *sd,
-			      struct v4l2_mbus_framefmt *fmt)
+			     struct v4l2_mbus_framefmt *fmt)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
 	if (!fmt)
 		return -EINVAL;
 
-	fmt->width = dev->curr_res_table[dev->fmt_idx].width;
-	fmt->height = dev->curr_res_table[dev->fmt_idx].height;
-	fmt->code = dev->format.code;
+	fmt->width = gc2235_res[dev->fmt_idx].width;
+	fmt->height = gc2235_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
 
 	return 0;
 }
 
-static int gc2235_detect(struct i2c_client *client, u16 *id)
+static int gc2235_detect(struct i2c_client *client)
 {
 	struct i2c_adapter *adapter = client->adapter;
-	u8 id_l, id_h;
+	u16 high, low;
+	int ret;
+	u16 id;
 
-	/* i2c check */
 	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
 		return -ENODEV;
 
-	/* check sensor chip ID	 */
-	if (gc2235_read_reg(client, GCSENSOR_8BIT, GC2235_REG_SENSOR_ID_HIGH_BIT, &id_h)) {
-		v4l2_err(client, "sensor id = 0x%x\n", id_h);
-		return -ENODEV;
-	}
-	*id = (u16)(id_h << 0x8);
-	if (gc2235_read_reg(client, GCSENSOR_8BIT, GC2235_REG_SENSOR_ID_LOW_BIT, &id_l)) {
-		v4l2_err(client, "sensor_id = 0x%x\n", id_l);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_SENSOR_ID_H, &high);
+	if (ret) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", high);
 		return -ENODEV;
 	}
-	*id = *id + id_l;
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_SENSOR_ID_L, &low);
+	id = ((((u16) high) << 8) | (u16) low);
 
-	if (*id == GC2235_ID)
-		goto found;
-	else {
-		v4l2_err(client, "no gc2235 sensor found\n");
+	if (id != GC2235_ID) {
+		dev_err(&client->dev, "sensor ID error, 0x%x\n", id);
 		return -ENODEV;
 	}
-found:
-	v4l2_info(client, "gc2235_detect: sensor_id = 0x%x\n", *id);
 
+	dev_dbg(&client->dev, "detect gc2235 success\n");
 	return 0;
 }
 
-/*
- * gc2235 stream on/off
- */
 static int gc2235_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	int ret;
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
 
 	mutex_lock(&dev->input_lock);
-	if (enable) {
-		ret = gc2235_set_streaming(sd);
-		dev->streaming = 1;
-	} else {
-		ret = gc2235_set_suspend(sd);
-		dev->streaming = 0;
-		dev->fps_index = 0;
-	}
-	mutex_unlock(&dev->input_lock);
 
-	return 0;
+	if (enable)
+		ret = gc2235_write_reg_array(client, gc2235_stream_on);
+	else
+		ret = gc2235_write_reg_array(client, gc2235_stream_off);
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
 }
 
-/*
- * gc2235 enum frame size, frame intervals
- */
+/* gc2235 enum frame size, frame intervals */
 static int gc2235_enum_framesizes(struct v4l2_subdev *sd,
-				   struct v4l2_frmsizeenum *fsize)
+				  struct v4l2_frmsizeenum *fsize)
 {
 	unsigned int index = fsize->index;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
-	if (index >= dev->entries_curr_table)
+	if (index >= N_RES)
 		return -EINVAL;
 
 	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-	fsize->discrete.width = dev->curr_res_table[index].width;
-	fsize->discrete.height = dev->curr_res_table[index].height;
-	fsize->reserved[0] = dev->curr_res_table[index].used;
+	fsize->discrete.width = gc2235_res[index].width;
+	fsize->discrete.height = gc2235_res[index].height;
+	fsize->reserved[0] = gc2235_res[index].used;
 
 	return 0;
 }
 
 static int gc2235_enum_frameintervals(struct v4l2_subdev *sd,
-				       struct v4l2_frmivalenum *fival)
+				      struct v4l2_frmivalenum *fival)
 {
-	int i;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	const struct gc2235_resolution *tmp_res = NULL;
+	unsigned int index = fival->index;
 
-	for (i = 0; i < dev->entries_curr_table; i++) {
-			tmp_res = &dev->curr_res_table[i];
-			if ((tmp_res[i].width >= fival->width) &&
-			 (tmp_res[i].height >= fival->height))
-				break;
-	}
-
-	if (i == dev->entries_curr_table)
-		i--;
+	if (index >= N_RES)
+		return -EINVAL;
 
 	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
-	fival->width = dev->curr_res_table[i].width;
-	fival->height = dev->curr_res_table[i].height;
+	fival->width = gc2235_res[index].width;
+	fival->height = gc2235_res[index].height;
 	fival->discrete.numerator = 1;
-	fival->discrete.denominator = dev->curr_res_table[i].fps;
+	fival->discrete.denominator = gc2235_res[index].fps;
+
+	return 0;
+}
+
+static int gc2235_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
 
 	return 0;
 }
 
 static int gc2235_s_config(struct v4l2_subdev *sd,
-			    int irq, void *pdata)
+			   int irq, void *platform_data)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 sensor_id;
-	int ret;
+	int ret = 0;
 
-	if (NULL == pdata)
+	if (platform_data == NULL)
 		return -ENODEV;
 
 	dev->platform_data =
-		(struct camera_sensor_platform_data *)pdata;
+		(struct camera_sensor_platform_data *)platform_data;
 
 	mutex_lock(&dev->input_lock);
-
 	if (dev->platform_data->platform_init) {
 		ret = dev->platform_data->platform_init(client);
 		if (ret) {
-			mutex_unlock(&dev->input_lock);
-			dev_err(&client->dev, "gc2235 platform init err\n");
-			return ret;
+			dev_err(&client->dev, "platform init err\n");
+			goto platform_init_failed;
 		}
 	}
-
-	ret = __gc2235_s_power(sd, 1);
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+	ret = power_down(sd);
 	if (ret) {
-		v4l2_err(client, "gc2235 power-up err.\n");
-		goto  fail_csi_cfg;
+		dev_err(&client->dev, "gc2235 power-off err.\n");
+		goto fail_power_off;
 	}
 
-	/* config & detect sensor */
-	ret = gc2235_detect(client, &sensor_id);
+	ret = power_up(sd);
 	if (ret) {
-		v4l2_err(client, "gc2235_detect err s_config.\n");
-		goto fail_detect;
+		dev_err(&client->dev, "gc2235 power-up err.\n");
+		goto fail_power_on;
 	}
 
 	ret = dev->platform_data->csi_cfg(sd, 1);
 	if (ret)
 		goto fail_csi_cfg;
 
-	dev->sensor_id = sensor_id;
+	/* config & detect sensor */
+	ret = gc2235_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "gc2235_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
 
-	/* power off sensor */
-	ret = __gc2235_s_power(sd, 0);
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 power-off err.\n");
+		goto fail_csi_cfg;
+	}
 	mutex_unlock(&dev->input_lock);
-	if (ret)
-		v4l2_err(client, "gc2235 power-down err.\n");
 
-	return ret;
+	return 0;
 
-fail_detect:
-	dev->platform_data->csi_cfg(sd, 0);
 fail_csi_cfg:
-	__gc2235_s_power(sd, 0);
-	mutex_unlock(&dev->input_lock);
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
 	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+platform_init_failed:
+	mutex_unlock(&dev->input_lock);
 	return ret;
 }
 
-static int
-gc2235_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-		       struct v4l2_subdev_mbus_code_enum *code)
+static int gc2235_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			gc2235_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int gc2235_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		gc2235_res = gc2235_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		gc2235_res = gc2235_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		gc2235_res = gc2235_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int gc2235_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = gc2235_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int gc2235_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
 	if (code->index >= MAX_FMTS)
 		return -EINVAL;
-	code->code = dev->format.code;
+
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
 	return 0;
 }
 
-static int
-gc2235_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			struct v4l2_subdev_frame_size_enum *fse)
+static int gc2235_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
 {
 	int index = fse->index;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
-	if (index >= dev->entries_curr_table)
+	if (index >= N_RES)
 		return -EINVAL;
 
-	fse->min_width = dev->curr_res_table[index].width;
-	fse->min_height = dev->curr_res_table[index].height;
-	fse->max_width = dev->curr_res_table[index].width;
-	fse->max_height = dev->curr_res_table[index].height;
+	fse->min_width = gc2235_res[index].width;
+	fse->min_height = gc2235_res[index].height;
+	fse->max_width = gc2235_res[index].width;
+	fse->max_height = gc2235_res[index].height;
 
 	return 0;
+
 }
 
 static struct v4l2_mbus_framefmt *
 __gc2235_get_pad_format(struct gc2235_device *sensor,
-			 struct v4l2_subdev_fh *fh, unsigned int pad,
-			 enum v4l2_subdev_format_whence which)
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
 {
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+			"__gc2235_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
 		return v4l2_subdev_get_try_format(fh, pad);
@@ -1370,96 +1120,28 @@ __gc2235_get_pad_format(struct gc2235_device *sensor,
 	}
 }
 
-static int
-gc2235_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-		       struct v4l2_subdev_format *fmt)
+static int gc2235_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
 {
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct gc2235_device *snr = to_gc2235_sensor(sd);
 	struct v4l2_mbus_framefmt *format =
-			__gc2235_get_pad_format(dev, fh, fmt->pad, fmt->which);
+			__gc2235_get_pad_format(snr, fh, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
 
 	fmt->format = *format;
-
 	return 0;
 }
 
-static int
-gc2235_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-		       struct v4l2_subdev_format *fmt)
+static int gc2235_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
 {
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct gc2235_device *snr = to_gc2235_sensor(sd);
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		dev->format = fmt->format;
-
-	return 0;
-}
-
-static int
-gc2235_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	dev->run_mode = param->parm.capture.capturemode;
-
-	mutex_lock(&dev->input_lock);
-	switch (dev->run_mode) {
-	case CI_MODE_VIDEO:
-		dev->curr_res_table = dev->mode_tables->res_video;
-		dev->entries_curr_table = dev->mode_tables->n_res_video;
-		break;
-	case CI_MODE_STILL_CAPTURE:
-		dev->curr_res_table = dev->mode_tables->res_still;
-		dev->entries_curr_table = dev->mode_tables->n_res_still;
-		break;
-	default:
-		dev->curr_res_table = dev->mode_tables->res_preview;
-		dev->entries_curr_table = dev->mode_tables->n_res_preview;
-	}
-	mutex_unlock(&dev->input_lock);
-	return 0;
-}
-
-int
-gc2235_g_frame_interval(struct v4l2_subdev *sd,
-				struct v4l2_subdev_frame_interval *interval)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 lines_per_frame;
-	/*
-	 * if no specific information to calculate the fps,
-	 * just used the value in sensor settings
-	 */
-
-	if (!dev->pixels_per_line || !dev->lines_per_frame) {
-		interval->interval.numerator = 1;
-		interval->interval.denominator = dev->fps;
-		return 0;
-	}
-
-	/*
-	 * DS: if coarse_integration_time is set larger than
-	 * lines_per_frame the frame_size will be expanded to
-	 * coarse_integration_time+1
-	 */
-	if (dev->coarse_itg > dev->lines_per_frame) {
-		if ((dev->coarse_itg + 4) < dev->coarse_itg) {
-			/*
-			 * we can not add 4 according to ds, as this will
-			 * cause over flow
-			 */
-			v4l2_warn(client, "%s: abnormal coarse_itg:0x%x\n",
-				  __func__, dev->coarse_itg);
-			lines_per_frame = dev->coarse_itg;
-		} else {
-			lines_per_frame = dev->coarse_itg + 4;
-		}
-	} else {
-		lines_per_frame = dev->lines_per_frame;
-	}
-	interval->interval.numerator = dev->pixels_per_line *
-					lines_per_frame;
-	interval->interval.denominator = dev->vt_pix_clk_freq_mhz;
+		snr->format = fmt->format;
 
 	return 0;
 }
@@ -1469,7 +1151,7 @@ static int gc2235_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
 	mutex_lock(&dev->input_lock);
-	*frames = dev->curr_res_table[dev->fmt_idx].skip_frames;
+	*frames = gc2235_res[dev->fmt_idx].skip_frames;
 	mutex_unlock(&dev->input_lock);
 
 	return 0;
@@ -1481,23 +1163,22 @@ static const struct v4l2_subdev_sensor_ops gc2235_sensor_ops = {
 
 static const struct v4l2_subdev_video_ops gc2235_video_ops = {
 	.s_stream = gc2235_s_stream,
+	.g_parm = gc2235_g_parm,
+	.s_parm = gc2235_s_parm,
 	.enum_framesizes = gc2235_enum_framesizes,
 	.enum_frameintervals = gc2235_enum_frameintervals,
+	.enum_mbus_fmt = gc2235_enum_mbus_fmt,
 	.try_mbus_fmt = gc2235_try_mbus_fmt,
 	.g_mbus_fmt = gc2235_g_mbus_fmt,
 	.s_mbus_fmt = gc2235_s_mbus_fmt,
-	.s_parm = gc2235_s_parm,
+	.g_frame_interval = gc2235_g_frame_interval,
 };
 
 static const struct v4l2_subdev_core_ops gc2235_core_ops = {
+	.s_power = gc2235_s_power,
 	.queryctrl = gc2235_queryctrl,
 	.g_ctrl = gc2235_g_ctrl,
 	.s_ctrl = gc2235_s_ctrl,
-#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
-	.s_power = gc2235_s_power_always_on,
-#else
-	.s_power = gc2235_s_power,
-#endif
 	.ioctl = gc2235_ioctl,
 };
 
@@ -1519,10 +1200,13 @@ static int gc2235_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	dev_dbg(&client->dev, "gc2235_remove...\n");
 
 	if (dev->platform_data->platform_deinit)
 		dev->platform_data->platform_deinit();
 
+	dev->platform_data->csi_cfg(sd, 0);
+
 	v4l2_device_unregister_subdev(sd);
 	media_entity_cleanup(&dev->sd.entity);
 	kfree(dev);
@@ -1530,75 +1214,33 @@ static int gc2235_remove(struct i2c_client *client)
 	return 0;
 }
 
-static int __update_gc2235_device_settings(struct gc2235_device *dev, u16 sensor_id)
-{
-	switch (sensor_id) {
-	case GC2235_ID:
-		dev->mode_tables = &gc2235_sets[0];
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
 static int gc2235_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
+			const struct i2c_device_id *id)
 {
 	struct gc2235_device *dev;
-	struct camera_mipi_info *gc2235_info = NULL;
-	int ret = -1;
-	void *pdata = client->dev.platform_data;
+	int ret;
 
-	/* allocate sensor device & init sub device */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
-		v4l2_err(client, "%s: out of memory\n", __func__);
+		dev_err(&client->dev, "out of memory\n");
 		return -ENOMEM;
 	}
+
 	mutex_init(&dev->input_lock);
 
 	dev->fmt_idx = 0;
-	dev->sensor_id = GC2235_ID_DEFAULT;
 	v4l2_i2c_subdev_init(&(dev->sd), client, &gc2235_ops);
 
-	dev->once_launched = 0;
-
-	if (ACPI_COMPANION(&client->dev))
-		pdata = gmin_camera_platform_data(&dev->sd,
-						  ATOMISP_INPUT_FORMAT_RAW_10,
-						  atomisp_bayer_order_grbg);
-	if (!pdata)
-		goto out_free;
-
-	ret = gc2235_s_config(&dev->sd, client->irq, pdata);
-	if (ret)
-		goto out_free;
-
-	ret = atomisp_register_i2c_module(&dev->sd, pdata, RAW_CAMERA);
-	if (ret)
-		goto out_free;
-
-	gc2235_info = v4l2_get_subdev_hostdata(&dev->sd);
-
-	/*
-	 * sd->name is updated with sensor driver name by the v4l2.
-	 * change it to sensor name in this case.
-	 */
-	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s%x %d-%04x",
-		GC2235_SUBDEV_PREFIX, dev->sensor_id,
-		i2c_adapter_id(client->adapter), client->addr);
-
-	/* Resolution settings depend on sensor type and platform */
-	ret = __update_gc2235_device_settings(dev, dev->sensor_id);
-	if (ret)
-		goto out_free;
+	if (client->dev.platform_data) {
+		ret = gc2235_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
 
 	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
-	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
-
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
 	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
 
 	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
@@ -1612,89 +1254,31 @@ out_free:
 	return ret;
 }
 
-#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
-static int gc2235_suspend(struct device *dev)
-{
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct gc2235_device *gc_dev = to_gc2235_sensor(sd);
-	int ret = 0;
-
-	//printk("%s() in\n", __func__);
-
-	if (gc_dev->once_launched) {
-		ret = __gc2235_s_power(sd, 0);
-		if (ret) {
-			v4l2_err(client, "gc2235 power-down err.\n");
-		}
-	}
-
-	return 0;
-}
-
-static int gc2235_resume(struct device *dev)
-{
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct gc2235_device *gc_dev = to_gc2235_sensor(sd);
-	int ret = 0;
-
-	//printk("%s() in\n", __func__);
-
-	if (gc_dev->once_launched) {
-		ret = __gc2235_s_power(sd, 1);
-		if (ret) {
-			v4l2_err(client, "gc2235 power-up err.\n");
-		}
-	}
-
-	return 0;
-}
-
-SIMPLE_DEV_PM_OPS(gc2235_pm_ops, gc2235_suspend, gc2235_resume);
-#endif
-
-static const struct i2c_device_id gc2235_ids[] = {
-	{GC2235_NAME, GC2235_ID},
-	{}
-};
-
-MODULE_DEVICE_TABLE(i2c, gc2235_ids);
-
-static struct acpi_device_id gc2235_acpi_match[] = {
-       {"INT33F8"},
-       {},
-};
-MODULE_DEVICE_TABLE(acpi, gc2235_acpi_match);
-
+MODULE_DEVICE_TABLE(i2c, gc2235_id);
 static struct i2c_driver gc2235_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
-		.name = GC2235_DRIVER,
-		.acpi_match_table = ACPI_PTR(gc2235_acpi_match),
-#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
-		.pm = &gc2235_pm_ops,
-#endif
+		.name = GC2235_NAME,
 	},
 	.probe = gc2235_probe,
 	.remove = gc2235_remove,
-	.id_table = gc2235_ids,
+	.id_table = gc2235_id,
 };
 
-static __init int init_gc2235(void)
+static int init_gc2235(void)
 {
 	return i2c_add_driver(&gc2235_driver);
 }
 
-static __exit void exit_gc2235(void)
+static void exit_gc2235(void)
 {
+
 	i2c_del_driver(&gc2235_driver);
 }
 
 module_init(init_gc2235);
 module_exit(exit_gc2235);
 
-MODULE_DESCRIPTION("A low-level driver for  sensors");
-MODULE_AUTHOR("Kun Jiang <kunx.jiang@intel.com>");
+MODULE_AUTHOR("Shuguang Gong <Shuguang.Gong@intel.com>");
+MODULE_DESCRIPTION("A low-level driver for GC2235 sensors");
 MODULE_LICENSE("GPL");
-
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
index aee2034..2a35791 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
@@ -1,7 +1,7 @@
 /*
- * Support for Sony GC2235 camera sensor.
+ * Support for GalaxyCore GC2235 2M camera sensor.
  *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -21,132 +21,46 @@
 
 #ifndef __GC2235_H__
 #define __GC2235_H__
-#include <linux/atomisp_platform.h>
-#include <linux/atomisp.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
 #include <linux/kernel.h>
-#include <linux/spinlock.h>
 #include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
 #include <linux/videodev2.h>
-#include <linux/v4l2-mediabus.h>
-#include <media/media-entity.h>
-#include <media/v4l2-device.h>
+#include <linux/spinlock.h>
 #include <media/v4l2-subdev.h>
-
-#define I2C_MSG_LENGTH		0x2
-
-#define GC2235_MCLK		192
-
-/* TODO - This should be added into include/linux/videodev2.h */
-#ifndef V4L2_IDENT_GC
-#define V4L2_IDENT_GC	2235
+#include <media/v4l2-device.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
 #endif
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
 
-/* #defines for register writes and register array processing */
-#define GCSENSOR_8BIT		1
-#define GCSENSOR_16BIT		2
-#define GCSENSOR_32BIT		4
-
-/*
- * gc2235 System control registers
- */
-#define GC2235_MASK_5BIT	0x1F
-#define GC2235_MASK_4BIT	0xF
-#define GC2235_MASK_2BIT	0x3
-#define GC2235_INTG_BUF_COUNT		2
-
-#define GC2235_FINE_INTG_TIME		0x0
-
-#define GC2235_ID_DEFAULT 0
-
-#define GC2235_LINES_PER_FRAME		0x0d
-#define GC2235_PIXELS_PER_LINE		0x0f
-
-#define GC2235_HORIZONTAL_START_H 0x0b
-#define GC2235_HORIZONTAL_START_L 0x0c
-
-#define GC2235_VERTICAL_START_H 0x09
-#define GC2235_VERTICAL_START_L 0x0a
-#define REG_SH_DELAY_H 0x11
-#define REG_SH_DELAY_L 0x12
-
-#define REG_HORI_BLANKING_H 0x05
-#define REG_HORI_BLANKING_L 0x06
-
-#define REG_VERT_DUMMY_H 0x07
-#define REG_VERT_DUMMY_L 0x08
-
-#define GC2235_HORIZONTAL_OUTPUT_SIZE_H 0x0f
-#define GC2235_HORIZONTAL_OUTPUT_SIZE_L 0x10
-#define GC2235_VERTICAL_OUTPUT_SIZE_H 0x0d
-#define GC2235_VERTICAL_OUTPUT_SIZE_L 0x0e
-
-#define GC2235_IMG_ORIENTATION			0x17
-#define GC2235_VFLIP_BIT			2
-#define GC2235_HFLIP_BIT			1
-#define GC2235_GLOBAL_GAIN			0xb0
+#include <linux/atomisp_platform.h>
 
-#define GC2235_DGC_LEN		10
-#define GC2235_MAX_EXPOSURE_SUPPORTED 8191
-#define GC2235_MAX_GLOBAL_GAIN_SUPPORTED 0xffff
-#define GC2235_MAX_DIGITAL_GAIN_SUPPORTED 0xffff
-#define GC2235_REG_EXPO_COARSE                 0x03
+#define GC2235_NAME		"gc2235"
 
 /* Defines for register writes and register array processing */
-#define GC2235_BYTE_MAX	32 /* change to 32 as needed by otpdata */
-#define GC2235_SHORT_MAX	16
+#define I2C_MSG_LENGTH		0x2
 #define I2C_RETRY_COUNT		5
-#define GC2235_TOK_MASK	0xfff0
 
-#define GC2235_FOCAL_LENGTH_NUM	208	/*2.08mm*/
+#define GC2235_FOCAL_LENGTH_NUM	278	/*2.78mm*/
 #define GC2235_FOCAL_LENGTH_DEM	100
-#define GC2235_F_NUMBER_DEFAULT_NUM	24
+#define GC2235_F_NUMBER_DEFAULT_NUM	26
 #define GC2235_F_NUMBER_DEM	10
-#define GC2235_WAIT_STAT_TIMEOUT	100
-#define GC2235_FLICKER_MODE_50HZ	1
-#define GC2235_FLICKER_MODE_60HZ	2
-
-/* Defines for OTP Data Registers */
-#define GC2235_OTP_START_ADDR		0x3B04
-#define GC2235_OTP_DATA_SIZE		1280
-#define GC2235_OTP_PAGE_SIZE		64
-#define GC2235_OTP_READY_REG		0x3B01
-#define GC2235_OTP_PAGE_REG		0x3B02
-#define GC2235_OTP_MODE_REG		0x3B00
-#define GC2235_OTP_PAGE_MAX		20
-#define GC2235_OTP_READY_REG_DONE		1
-#define GC2235_OTP_READ_ONETIME		32
-#define GC2235_OTP_MODE_READ		1
-
-#define MAX_FMTS 1
-
-#define GC2235_SUBDEV_PREFIX "gc"
-#define GC2235_DRIVER	"gc22351x5"
-#define GC2235_NAME	"gc2235"
-#define GC2235_ID	0x2235
-
-#define GC2235_REG_SENSOR_ID_HIGH_BIT	0xf0
-#define GC2235_REG_SENSOR_ID_LOW_BIT	0xf1
-#define GC2235_SENSOR_ID_HIGH_BIT	0x22
-#define GC2235_SENSOR_ID_LOW_BIT	0x35
 
-#define GC2235_RES_WIDTH_MAX	1616
-#define GC2235_RES_HEIGHT_MAX	1216
+#define MAX_FMTS		1
 
-#define GC2235_BIN_FACTOR_MAX			4
-#define GC2235_INTEGRATION_TIME_MARGIN	4
 /*
  * focal length bits definition:
  * bits 31-16: numerator, bits 15-0: denominator
  */
-#define GC2235_FOCAL_LENGTH_DEFAULT 0x1710064
+#define GC2235_FOCAL_LENGTH_DEFAULT 0x1160064
 
 /*
  * current f-number bits definition:
  * bits 31-16: numerator, bits 15-0: denominator
  */
-#define GC2235_F_NUMBER_DEFAULT 0x16000a
+#define GC2235_F_NUMBER_DEFAULT 0x1a000a
 
 /*
  * f-number range bits definition:
@@ -155,377 +69,490 @@
  * bits 15-8: min f-number numerator
  * bits 7-0: min f-number denominator
  */
-#define GC2235_F_NUMBER_RANGE 0x160a160a
+#define GC2235_F_NUMBER_RANGE 0x1a0a1a0a
+#define GC2235_ID	0x2235
+
+#define GC2235_FINE_INTG_TIME_MIN 0
+#define GC2235_FINE_INTG_TIME_MAX_MARGIN 0
+#define GC2235_COARSE_INTG_TIME_MIN 1
+#define GC2235_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
 
-struct max_res {
-	int res_max_width;
-	int res_max_height;
+/*
+ * GC2235 System control registers
+ */
+/*
+ * GC2235 System control registers
+ */
+#define GC2235_SENSOR_ID_H		0xF0
+#define GC2235_SENSOR_ID_L		0xF1
+#define GC2235_RESET_RELATED		0xFE
+#define GC2235_SW_RESET			0x8
+#define GC2235_MIPI_RESET		0x3
+#define GC2235_RESET_BIT		0x4
+#define GC2235_REGISTER_PAGE_0		0x0
+#define GC2235_REGISTER_PAGE_3		0x3
+
+#define GC2235_V_CROP_START_H		0x91
+#define GC2235_V_CROP_START_L		0x92
+#define GC2235_H_CROP_START_H		0x93
+#define GC2235_H_CROP_START_L		0x94
+#define GC2235_V_OUTSIZE_H		0x95
+#define GC2235_V_OUTSIZE_L		0x96
+#define GC2235_H_OUTSIZE_H 		0x97
+#define GC2235_H_OUTSIZE_L 		0x98
+
+#define GC2235_HB_H			0x5
+#define GC2235_HB_L			0x6
+#define GC2235_VB_H			0x7
+#define GC2235_VB_L			0x8
+#define GC2235_SH_DELAY_H		0x11
+#define GC2235_SH_DELAY_L		0x12
+
+#define GC2235_CSI2_MODE		0x10
+
+#define GC2235_EXPOSURE_H		0x3
+#define GC2235_EXPOSURE_L		0x4
+#define GC2235_GLOBAL_GAIN		0xB0
+#define GC2235_PRE_GAIN			0xB1
+#define GC2235_AWB_R_GAIN		0xB3
+#define GC2235_AWB_G_GAIN		0xB4
+#define GC2235_AWB_B_GAIN		0xB5
+
+#define GC2235_START_STREAMING		0x91
+#define GC2235_STOP_STREAMING		0x0
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
 };
 
-struct max_res gc2235_max_res[] = {
-	[0] = {
-		.res_max_width = GC2235_RES_WIDTH_MAX,
-		.res_max_height = GC2235_RES_HEIGHT_MAX,
-	},
+struct gc2235_resolution {
+	u8 *desc;
+	const struct gc2235_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u32 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
 };
 
-#define MAX_FPS_OPTIONS_SUPPORTED       3
+struct gc2235_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct gc2235_reg *regs;
+};
 
-enum gc2235_tok_type {
-	 GC2235_8BIT  = 0x0001,
-	 GC2235_16BIT = 0x0002,
-	 GC2235_TOK_TERM   = 0xf000,        /* terminating token for reg list */
-	 GC2235_TOK_DELAY  = 0xfe00 /* delay token for reg list */
+struct gc2235_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
 };
 
-#define GROUPED_PARAMETER_HOLD_ENABLE  {GC2235_8BIT, 0x0104, 0x1}
-#define GROUPED_PARAMETER_HOLD_DISABLE  {GC2235_8BIT, 0x0104, 0x0}
+/*
+ * gc2235 device structure.
+ */
+struct gc2235_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u8 res;
+	u8 type;
+};
+
+enum gc2235_tok_type {
+	GC2235_8BIT  = 0x0001,
+	GC2235_16BIT = 0x0002,
+	GC2235_32BIT = 0x0004,
+	GC2235_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	GC2235_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	GC2235_TOK_MASK = 0xfff0
+};
 
 /**
  * struct gc2235_reg - MI sensor  register format
  * @type: type of the register
- * @reg: 16-bit offset to register
+ * @reg: 8-bit offset to register
  * @val: 8/16/32-bit register value
  *
  * Define a structure for sensor register initialization values
  */
 struct gc2235_reg {
-	 enum gc2235_tok_type type;
-	 u16 sreg;
-	 u32 val;        /* @set value for read/mod/write, @mask */
+	enum gc2235_tok_type type;
+	u8 reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
 };
 
-struct gc2235_fps_setting {
-	 int fps;
-	 unsigned short pixels_per_line;
-	 unsigned short lines_per_frame;
-};
+#define to_gc2235_sensor(x) container_of(x, struct gc2235_device, sd)
 
-struct gc2235_resolution {
-	 u8 *desc;
-	 const struct gc2235_reg *regs;
-	 int res;
-	 int width;
-	 int height;
-	 int fps;
-	 unsigned short pixels_per_line;
-	 unsigned short lines_per_frame;
-	 unsigned short skip_frames;
-	 u8 bin_factor_x;
-	 u8 bin_factor_y;
-	 bool used;
-		u8 bin_mode;
-};
+#define GC2235_MAX_WRITE_BUF_SIZE	30
 
+struct gc2235_write_buffer {
+	u8 addr;
+	u8 data[GC2235_MAX_WRITE_BUF_SIZE];
+};
 
+struct gc2235_write_ctrl {
+	int index;
+	struct gc2235_write_buffer buffer;
+};
 
-struct gc2235_settings {
-	struct gc2235_reg const *init_settings;
-	struct gc2235_resolution *res_preview;
-	struct gc2235_resolution *res_still;
-	struct gc2235_resolution *res_video;
-	int n_res_preview;
-	int n_res_still;
-	int n_res_video;
+static const struct i2c_device_id gc2235_id[] = {
+	{GC2235_NAME, 0},
+	{}
 };
 
-static struct gc2235_reg const gc2235_720p_30fps[] = {
-	{GC2235_8BIT, 0x90, 0x01},
-	{GC2235_8BIT, 0x92, 0xf0},
-	{GC2235_8BIT, 0x94, 0xa0},
-	{GC2235_8BIT, 0x95, 0x02},
-	{GC2235_8BIT, 0x96, 0xe0},
-	{GC2235_8BIT, 0x97, 0x05},
-	{GC2235_8BIT, 0x98, 0x10},
-
-	{GC2235_8BIT, 0xfe, 0x03},
-	{GC2235_8BIT, 0x12, 0x54},
-	{GC2235_8BIT, 0x13, 0x06},
-	{GC2235_8BIT, 0x04, 0x20},
-	{GC2235_8BIT, 0x05, 0x00},
-	{GC2235_8BIT, 0xfe, 0x00},
-	{GC2235_TOK_TERM, 0, 0},
+static struct gc2235_reg const gc2235_stream_on[] = {
+	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
+	{ GC2235_8BIT, 0x10, 0x91}, /* start mipi */
+	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
 };
 
-static struct gc2235_reg const gc2235_1600x1200_30fps[] = {
-	{GC2235_8BIT, 0xfe, 0x00},
-	{GC2235_8BIT, 0x0a, 0x02},
-	{GC2235_8BIT, 0x0c, 0x00},
-	{GC2235_8BIT, 0x0d, 0x04},
-	{GC2235_8BIT, 0x0e, 0xd0},
-	{GC2235_8BIT, 0x0f, 0x06},
-	{GC2235_8BIT, 0x10, 0x58},
-
-	{GC2235_8BIT, 0x90, 0x01},
-	{GC2235_8BIT, 0x92, 0x02},
-	{GC2235_8BIT, 0x94, 0x00},
-	{GC2235_8BIT, 0x95, 0x04},
-	{GC2235_8BIT, 0x96, 0xc0},
-	{GC2235_8BIT, 0x97, 0x06},
-	{GC2235_8BIT, 0x98, 0x50},
-
-	{GC2235_8BIT, 0xfe, 0x03},
-	{GC2235_8BIT, 0x12, 0xe4},
-	{GC2235_8BIT, 0x13, 0x07},
-	{GC2235_8BIT, 0x04, 0x20},
-	{GC2235_8BIT, 0x05, 0x00},
-	{GC2235_8BIT, 0xfe, 0x00},
-	{GC2235_TOK_TERM, 0, 0},
+static struct gc2235_reg const gc2235_stream_off[] = {
+	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
+	{ GC2235_8BIT, 0x10, 0x81}, /* stop mipi */
+	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
 };
 
-static struct gc2235_reg const gc2235_still_1600x1200_30fps[] = {
-	{GC2235_8BIT, 0xfe, 0x00},
-	{GC2235_8BIT, 0x0a, 0x02},
-	{GC2235_8BIT, 0x0c, 0x00},
-	{GC2235_8BIT, 0x0d, 0x04},
-	{GC2235_8BIT, 0x0e, 0xd0},
-	{GC2235_8BIT, 0x0f, 0x06},
-	{GC2235_8BIT, 0x10, 0x58},
-
-	{GC2235_8BIT, 0x90, 0x01},
-	{GC2235_8BIT, 0x92, 0x02},
-	{GC2235_8BIT, 0x94, 0x00},
-	{GC2235_8BIT, 0x95, 0x04},
-	{GC2235_8BIT, 0x96, 0xc0},
-	{GC2235_8BIT, 0x97, 0x06},
-	{GC2235_8BIT, 0x98, 0x50},
-
-	{GC2235_8BIT, 0xfe, 0x03},
-	{GC2235_8BIT, 0x12, 0xe4},
-	{GC2235_8BIT, 0x13, 0x07},
-	{GC2235_8BIT, 0x04, 0x20},
-	{GC2235_8BIT, 0x05, 0x00},
-	{GC2235_8BIT, 0xfe, 0x00},
-	{GC2235_TOK_TERM, 0, 0},
+static struct gc2235_reg const gc2235_init_settings[] = {
+	/* Sysytem */
+	{ GC2235_8BIT, 0xfe, 0x80 },
+	{ GC2235_8BIT, 0xfe, 0x80 },
+	{ GC2235_8BIT, 0xfe, 0x80 },
+	{ GC2235_8BIT, 0xf2, 0x00 },
+	{ GC2235_8BIT, 0xf6, 0x00 },
+	{ GC2235_8BIT, 0xfc, 0x06 },
+	{ GC2235_8BIT, 0xf7, 0x15 },
+	{ GC2235_8BIT, 0xf8, 0x85 },
+	{ GC2235_8BIT, 0xf9, 0xfe },
+	{ GC2235_8BIT, 0xfa, 0x00 },
+	{ GC2235_8BIT, 0xfe, 0x00 },
+	/* Analog & cisctl */
+	{ GC2235_8BIT, 0x03, 0x04 },
+	{ GC2235_8BIT, 0x04, 0x9e },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x06, 0xf4 },
+	{ GC2235_8BIT, 0x07, 0x00 },
+	{ GC2235_8BIT, 0x08, 0x88 },
+	{ GC2235_8BIT, 0x0a, 0x00 }, /* row start */
+	{ GC2235_8BIT, 0x0c, 0x00 }, /* col start */
+	{ GC2235_8BIT, 0x0d, 0x04 }, /* win height 1232 */
+	{ GC2235_8BIT, 0x0e, 0xd0 },
+	{ GC2235_8BIT, 0x0f, 0x06 }, /* win width: 1616 */
+	{ GC2235_8BIT, 0x10, 0x60 },
+	{ GC2235_8BIT, 0x17, 0x15 }, /* mirror flip */
+	{ GC2235_8BIT, 0x18, 0x12 },
+	{ GC2235_8BIT, 0x19, 0x06 },
+	{ GC2235_8BIT, 0x1a, 0x01 },
+	{ GC2235_8BIT, 0x1b, 0x4d },
+	{ GC2235_8BIT, 0x1e, 0x88 },
+	{ GC2235_8BIT, 0x1f, 0x48 },
+	{ GC2235_8BIT, 0x20, 0x03 },
+	{ GC2235_8BIT, 0x21, 0x7f },
+	{ GC2235_8BIT, 0x22, 0x83 },
+	{ GC2235_8BIT, 0x23, 0x42 },
+	{ GC2235_8BIT, 0x24, 0x16 },
+	{ GC2235_8BIT, 0x26, 0x01 }, /*analog gain*/
+	{ GC2235_8BIT, 0x27, 0x30 },
+	{ GC2235_8BIT, 0x3f, 0x00 }, /* PRC */
+	/* blk */
+	{ GC2235_8BIT, 0x40, 0x03 },
+	{ GC2235_8BIT, 0x41, 0x00 },
+	{ GC2235_8BIT, 0x43, 0x20 },
+	{ GC2235_8BIT, 0x5e, 0x00 },
+	{ GC2235_8BIT, 0x5f, 0x00 },
+	{ GC2235_8BIT, 0x60, 0x00 },
+	{ GC2235_8BIT, 0x61, 0x00 },
+	{ GC2235_8BIT, 0x62, 0x00 },
+	{ GC2235_8BIT, 0x63, 0x00 },
+	{ GC2235_8BIT, 0x64, 0x00 },
+	{ GC2235_8BIT, 0x65, 0x00 },
+	{ GC2235_8BIT, 0x66, 0x20 },
+	{ GC2235_8BIT, 0x67, 0x20 },
+	{ GC2235_8BIT, 0x68, 0x20 },
+	{ GC2235_8BIT, 0x69, 0x20 },
+	/* Gain */
+	{ GC2235_8BIT, 0xb2, 0x00 },
+	{ GC2235_8BIT, 0xb3, 0x40 },
+	{ GC2235_8BIT, 0xb4, 0x40 },
+	{ GC2235_8BIT, 0xb5, 0x40 },
+	/* Dark sun */
+	{ GC2235_8BIT, 0xbc, 0x00 },
+
+	{ GC2235_8BIT, 0xfe, 0x03 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
+/*
+ * Register settings for various resolution
+ */
+static struct gc2235_reg const gc2235_1616_916_30fps[] = {
+	{ GC2235_8BIT, 0x8b, 0xa0 },
+	{ GC2235_8BIT, 0x8c, 0x02 },
+	{ GC2235_8BIT, 0x90, 0x01 },
+	{ GC2235_8BIT, 0x92, 0x96 },
+	{ GC2235_8BIT, 0x94, 0x00 },
+	{ GC2235_8BIT, 0x95, 0x03 }, /* crop win height 900 */
+	{ GC2235_8BIT, 0x96, 0x94 },
+	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1600 */
+	{ GC2235_8BIT, 0x98, 0x50 },
+	/* mimi init */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x01, 0x07 },
+	{ GC2235_8BIT, 0x02, 0x11 },
+	{ GC2235_8BIT, 0x03, 0x11 },
+	{ GC2235_8BIT, 0x06, 0x80 },
+	{ GC2235_8BIT, 0x11, 0x2b },
+	/* set mipi buffer */
+	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
+	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
+
+	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
+	{ GC2235_8BIT, 0x04, 0x20 },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x17, 0x01 },
+	{ GC2235_8BIT, 0x21, 0x01 },
+	{ GC2235_8BIT, 0x22, 0x02 },
+	{ GC2235_8BIT, 0x23, 0x01 },
+	{ GC2235_8BIT, 0x29, 0x02 },
+	{ GC2235_8BIT, 0x2a, 0x01 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
 };
 
+static struct gc2235_reg const gc2235_1616_1082_30fps[] = {
+	{ GC2235_8BIT, 0x8b, 0xa0 },
+	{ GC2235_8BIT, 0x8c, 0x02 },
+	{ GC2235_8BIT, 0x90, 0x01 },
+	{ GC2235_8BIT, 0x92, 0x4a },
+	{ GC2235_8BIT, 0x94, 0x00 },
+	{ GC2235_8BIT, 0x95, 0x04 }, /* crop win height 1082 */
+	{ GC2235_8BIT, 0x96, 0x3a },
+	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1616 */
+	{ GC2235_8BIT, 0x98, 0x50 },
+	/* mimi init */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x01, 0x07 },
+	{ GC2235_8BIT, 0x02, 0x11 },
+	{ GC2235_8BIT, 0x03, 0x11 },
+	{ GC2235_8BIT, 0x06, 0x80 },
+	{ GC2235_8BIT, 0x11, 0x2b },
+	/* set mipi buffer */
+	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
+	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
+
+	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
+	{ GC2235_8BIT, 0x04, 0x20 },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x17, 0x01 },
+	{ GC2235_8BIT, 0x21, 0x01 },
+	{ GC2235_8BIT, 0x22, 0x02 },
+	{ GC2235_8BIT, 0x23, 0x01 },
+	{ GC2235_8BIT, 0x29, 0x02 },
+	{ GC2235_8BIT, 0x2a, 0x01 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
 
-/* TODO settings of preview/still/video will be updated with new use case */
+static struct gc2235_reg const gc2235_1616_1216_30fps[] = {
+	{ GC2235_8BIT, 0x8b, 0xa0 },
+	{ GC2235_8BIT, 0x8c, 0x02 },
+	{ GC2235_8BIT, 0x90, 0x01 },
+	{ GC2235_8BIT, 0x92, 0x02 },
+	{ GC2235_8BIT, 0x94, 0x00 },
+	{ GC2235_8BIT, 0x95, 0x04 }, /* crop win height 1216 */
+	{ GC2235_8BIT, 0x96, 0xc0 },
+	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1616 */
+	{ GC2235_8BIT, 0x98, 0x50 },
+	/* mimi init */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x01, 0x07 },
+	{ GC2235_8BIT, 0x02, 0x11 },
+	{ GC2235_8BIT, 0x03, 0x11 },
+	{ GC2235_8BIT, 0x06, 0x80 },
+	{ GC2235_8BIT, 0x11, 0x2b },
+	/* set mipi buffer */
+	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
+	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
+
+	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
+	{ GC2235_8BIT, 0x04, 0x20 },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x17, 0x01 },
+	{ GC2235_8BIT, 0x21, 0x01 },
+	{ GC2235_8BIT, 0x22, 0x02 },
+	{ GC2235_8BIT, 0x23, 0x01 },
+	{ GC2235_8BIT, 0x29, 0x02 },
+	{ GC2235_8BIT, 0x2a, 0x01 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
 
-struct gc2235_resolution gc2235_res_still[] = {
+struct gc2235_resolution gc2235_res_preview[] = {
 	{
-		.desc = "gc2235_1600x1200_30fps",
-		.regs = gc2235_still_1600x1200_30fps,
+		.desc = "gc2235_1600_900_30fps",
+		.width = 1616,
+		.height = 916,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 932,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_916_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1066_30fps",
+		.width = 1616,
+		.height = 1082,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1098,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1082_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1200_30fps",
 		.width = 1616,
 		.height = 1216,
-		.fps = 23,
-		.pixels_per_line = 0x8c0,
-		.lines_per_frame = 0x500,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
+		.pix_clk_freq = 75,
+		.fps = 27,
 		.used = 0,
-		.skip_frames = 2,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1232,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
 		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1216_30fps,
 	},
 };
+#define N_RES_PREVIEW (ARRAY_SIZE(gc2235_res_preview))
 
-static struct gc2235_reg const gc2235_1280_30fps[] = {
-	{GC2235_8BIT, 0xfe, 0x00},
-	{GC2235_8BIT, 0x0a, 0x98},
-	{GC2235_8BIT, 0x0c, 0x00},
-	{GC2235_8BIT, 0x0d, 0x03},
-	{GC2235_8BIT, 0x0e, 0xa4},
-	{GC2235_8BIT, 0x0f, 0x06},
-	{GC2235_8BIT, 0x10, 0x50},
-
-	{GC2235_8BIT, 0x90, 0x01},
-	{GC2235_8BIT, 0x92, 0x02},
-	{GC2235_8BIT, 0x94, 0x00},
-	{GC2235_8BIT, 0x95, 0x03},
-	{GC2235_8BIT, 0x96, 0x94},
-	{GC2235_8BIT, 0x97, 0x06},
-	{GC2235_8BIT, 0x98, 0x50},
-	{GC2235_TOK_TERM, 0, 0},
-};
-
-struct gc2235_resolution gc2235_res_preview[] = {
+struct gc2235_resolution gc2235_res_still[] = {
 	{
-		.desc = "gc2235_1600x1200_30fps",
-		.regs = gc2235_1600x1200_30fps,
+		.desc = "gc2235_1600_900_30fps",
+		.width = 1616,
+		.height = 916,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 932,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_916_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1066_30fps",
+		.width = 1616,
+		.height = 1082,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1098,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1082_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1200_30fps",
 		.width = 1616,
 		.height = 1216,
-		.fps = 23,
-		.pixels_per_line = 0x8c0,
-		.lines_per_frame = 0x500,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
+		.pix_clk_freq = 75,
+		.fps = 27,
 		.used = 0,
-		.skip_frames = 2,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1232,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
 		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1216_30fps,
 	},
 };
+#define N_RES_STILL (ARRAY_SIZE(gc2235_res_still))
 
 struct gc2235_resolution gc2235_res_video[] = {
 	{
-		.desc = "gc2235_1280_30fps",
-		.regs = gc2235_1280_30fps,
+		.desc = "gc2235_1600_900_30fps",
 		.width = 1616,
 		.height = 916,
+		.pix_clk_freq = 75,
 		.fps = 30,
-		.pixels_per_line = 0x8c0,
-		.lines_per_frame = 0x3c4,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
 		.used = 0,
-		.skip_frames = 4,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 932,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_916_30fps,
 	},
-};
-
-/********************** settings for imx - reference *********************/
-static struct gc2235_reg const gc2235_init_settings[] = {
-	{ GC2235_TOK_TERM, 0, 0}
-};
-
-struct gc2235_settings gc2235_sets[] = {
-	[0] = {
-		.init_settings = gc2235_init_settings,
-		.res_preview = gc2235_res_preview,
-		.res_still = gc2235_res_still,
-		.res_video = gc2235_res_video,
-		.n_res_preview = ARRAY_SIZE(gc2235_res_preview),
-		.n_res_still = ARRAY_SIZE(gc2235_res_still),
-		.n_res_video = ARRAY_SIZE(gc2235_res_video),
+	{
+		.desc = "gc2235_1600_1066_30fps",
+		.width = 1616,
+		.height = 1082,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1098,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1082_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1200_30fps",
+		.width = 1616,
+		.height = 1216,
+		.pix_clk_freq = 75,
+		.fps = 27,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1232,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1216_30fps,
 	},
 };
+#define N_RES_VIDEO (ARRAY_SIZE(gc2235_res_video))
 
-#define	v4l2_format_capture_type_entry(_width, _height, \
-		_pixelformat, _bytesperline, _colorspace) \
-	{\
-		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\
-		.fmt.pix.width = (_width),\
-		.fmt.pix.height = (_height),\
-		.fmt.pix.pixelformat = (_pixelformat),\
-		.fmt.pix.bytesperline = (_bytesperline),\
-		.fmt.pix.colorspace = (_colorspace),\
-		.fmt.pix.sizeimage = (_height)*(_bytesperline),\
-	}
-
-#define	s_output_format_entry(_width, _height, _pixelformat, \
-		_bytesperline, _colorspace, _fps) \
-	{\
-		.v4l2_fmt = v4l2_format_capture_type_entry(_width, \
-			_height, _pixelformat, _bytesperline, \
-				_colorspace),\
-		.fps = (_fps),\
-	}
-
-#define	s_output_format_reg_entry(_width, _height, _pixelformat, \
-		_bytesperline, _colorspace, _fps, _reg_setting) \
-	{\
-		.s_fmt = s_output_format_entry(_width, _height,\
-				_pixelformat, _bytesperline, \
-				_colorspace, _fps),\
-		.reg_setting = (_reg_setting),\
-	}
-
-struct s_ctrl_id {
-	struct v4l2_queryctrl qc;
-	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
-	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
-};
-
-#define	v4l2_queryctrl_entry_integer(_id, _name,\
-		_minimum, _maximum, _step, \
-		_default_value, _flags)	\
-	{\
-		.id = (_id), \
-		.type = V4L2_CTRL_TYPE_INTEGER, \
-		.name = _name, \
-		.minimum = (_minimum), \
-		.maximum = (_maximum), \
-		.step = (_step), \
-		.default_value = (_default_value),\
-		.flags = (_flags),\
-	}
-#define	v4l2_queryctrl_entry_boolean(_id, _name,\
-		_default_value, _flags)	\
-	{\
-		.id = (_id), \
-		.type = V4L2_CTRL_TYPE_BOOLEAN, \
-		.name = _name, \
-		.minimum = 0, \
-		.maximum = 1, \
-		.step = 1, \
-		.default_value = (_default_value),\
-		.flags = (_flags),\
-	}
-
-#define	s_ctrl_id_entry_integer(_id, _name, \
-		_minimum, _maximum, _step, \
-		_default_value, _flags, \
-		_s_ctrl, _g_ctrl)	\
-	{\
-		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
-				_minimum, _maximum, _step,\
-				_default_value, _flags), \
-		.s_ctrl = _s_ctrl, \
-		.g_ctrl = _g_ctrl, \
-	}
-
-#define	s_ctrl_id_entry_boolean(_id, _name, \
-		_default_value, _flags, \
-		_s_ctrl, _g_ctrl)	\
-	{\
-		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
-				_default_value, _flags), \
-		.s_ctrl = _s_ctrl, \
-		.g_ctrl = _g_ctrl, \
-	}
-
-
-struct gc2235_control {
-	struct v4l2_queryctrl qc;
-	int (*query)(struct v4l2_subdev *sd, s32 *value);
-	int (*tweak)(struct v4l2_subdev *sd, s32 value);
-};
-
-/* gc2235 device structure */
-struct gc2235_device {
-	struct v4l2_subdev sd;
-	struct media_pad pad;
-	struct v4l2_mbus_framefmt format;
-	struct camera_sensor_platform_data *platform_data;
-	struct mutex input_lock; /* serialize sensor's ioctl */
-	int fmt_idx;
-	int status;
-	int streaming;
-	int power;
-	int once_launched;
-	int run_mode;
-	int vt_pix_clk_freq_mhz;
-	int fps_index;
-	u32 focus;
-	u16 sensor_id;
-	u16 coarse_itg;
-	u16 fine_itg;
-	u16 gain;
-	u16 pixels_per_line;
-	u16 lines_per_frame;
-	u8 fps;
-	u8 res;
-	u8 type;
-	u8 *otp_data;
-	struct gc2235_settings *mode_tables;
-	const struct gc2235_resolution *curr_res_table;
-	int entries_curr_table;
-};
-
-#define to_gc2235_sensor(x) container_of(x, struct gc2235_device, sd)
-
-#define GC2235_MAX_WRITE_BUF_SIZE	32
-struct gc2235_write_buffer {
-	u16 addr;
-	u8 data[GC2235_MAX_WRITE_BUF_SIZE];
-};
-
-struct gc2235_write_ctrl {
-	int index;
-	struct gc2235_write_buffer buffer;
-};
-
-static const struct gc2235_reg gc2235_param_update[] = {
-	{GC2235_TOK_TERM, 0, 0}
-};
+static struct gc2235_resolution *gc2235_res = gc2235_res_preview;
+static int N_RES = N_RES_PREVIEW;
 #endif
-
-
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile
index 12fabd6..1d7f7ab 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile
@@ -1,5 +1,8 @@
 obj-$(CONFIG_VIDEO_IMX) += imx1x5.o
 
-imx1x5-objs := imx.o drv201.o ad5816g.o dw9714.o dw9719.o vcm.o otp.o otp_imx.o otp_e2prom.o
+imx1x5-objs := imx.o drv201.o ad5816g.o dw9714.o dw9719.o dw9718.o vcm.o otp.o otp_imx.o otp_brcc064_e2prom.o otp_e2prom.o
+
+ov8858_driver-objs := ../ov8858.o dw9718.o vcm.o
+obj-$(CONFIG_VIDEO_OV8858)     += ov8858_driver.o
 
 ccflags-y += -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
index b27c854..f6c2e46 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
@@ -15,6 +15,9 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-device.h>
 
 #include "ad5816g.h"
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
index 86b152b..34afa83 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
@@ -15,6 +15,9 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-device.h>
 #include <asm/intel-mid.h>
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
index 6ea3340..1177b82 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
@@ -15,6 +15,9 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-device.h>
 #include <asm/intel-mid.h>
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
index 1e59ccb..5d22466 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
@@ -47,6 +47,22 @@ static int dw9718_i2c_rd8(struct i2c_client *client, u8 reg, u8 *val)
 	return 0;
 }
 
+static int dw9718_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct i2c_msg msg;
+	u8 buf[2] = { reg, val};
+
+	msg.addr = DW9718_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = sizeof(buf);
+	msg.buf = buf;
+
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+
+	return 0;
+}
+
 static int dw9718_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
 {
 	struct i2c_msg msg;
@@ -85,13 +101,27 @@ int dw9718_vcm_power_up(struct v4l2_subdev *sd)
 		return -ENXIO;
 	}
 
+	/* Initialize according to recommended settings */
+	ret = dw9718_i2c_wr8(client, DW9718_CONTROL,
+			     DW9718_CONTROL_SW_LINEAR |
+			     DW9718_CONTROL_S_SAC4 |
+			     DW9718_CONTROL_OCP_DISABLE |
+			     DW9718_CONTROL_UVLO_DISABLE);
+	if (ret < 0)
+		goto fail_powerdown;
+	ret = dw9718_i2c_wr8(client, DW9718_SACT,
+			     DW9718_SACT_MULT_TWO |
+			     DW9718_SACT_PERIOD_8_8MS);
+	if (ret < 0)
+		goto fail_powerdown;
+
 	dw9718_dev.focus = DW9718_MAX_FOCUS_POS;
 	dw9718_dev.initialized = true;
 
 	return 0;
 
 fail_powerdown:
-	dev_err(&client->dev, "%s error, detection failed\n", __func__);
+	dev_err(&client->dev, "%s error, powerup failed\n", __func__);
 	dw9718_dev.platform_data->power_ctrl(sd, 0);
 	return ret;
 }
@@ -133,10 +163,6 @@ int dw9718_t_focus_abs(struct v4l2_subdev *sd, s32 value)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
 
-	/*
-	 * TODO: Need to check here whether there is a need to test the
-	 * Flag bit (bit 0 or register 0x10) before writing the new
-	 * absolute vcm value */
 	value = clamp(value, 0, DW9718_MAX_FOCUS_POS);
 	ret = dw9718_i2c_wr16(client, DW9718_DATA_M, value);
 	if (ret < 0)
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
index 5657dad..f33511f 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
@@ -49,6 +49,13 @@ struct dw9718_device {
 #define DW9718_SACT			0x05
 #define DW9718_FLAG			0x10
 
+#define DW9718_CONTROL_SW_LINEAR	BIT(0)
+#define DW9718_CONTROL_S_SAC4		(BIT(1) | BIT(3))
+#define DW9718_CONTROL_OCP_DISABLE	BIT(4)
+#define DW9718_CONTROL_UVLO_DISABLE	BIT(5)
+
+#define DW9718_SACT_MULT_TWO		0x00
+#define DW9718_SACT_PERIOD_8_8MS	0x19
 #define DW9718_SACT_DEFAULT_VAL 	0x60
 
 #endif /* __DW9718_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
index 01bc1f9..fb875c8 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
@@ -19,6 +19,7 @@
  *
  */
 #include <asm/intel-mid.h>
+#include <linux/atomisp_platform.h>
 #include <linux/bitops.h>
 #include <linux/device.h>
 #include <linux/delay.h>
@@ -37,12 +38,22 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/types.h>
-#include <linux/acpi.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
-#include <linux/atomisp_gmin_platform.h>
 #include "imx.h"
 
+/*
+ * The imx135 embedded data info:
+ * embedded data line num: 2
+ * line 0 effective data size(byte): 76
+ * line 1 effective data size(byte): 113
+ */
+static const uint32_t imx135_embedded_effective_size[IMX135_EMBEDDED_DATA_LINE_NUM]
+	=  {76, 113};
+
 static enum atomisp_bayer_order imx_bayer_order_mapping[] = {
 	atomisp_bayer_order_rggb,
 	atomisp_bayer_order_grbg,
@@ -338,26 +349,44 @@ static int __imx_get_max_fps_index(
 	return i - 1;
 }
 
+static int imx_get_lanes(struct v4l2_subdev *sd)
+{
+	struct camera_mipi_info *imx_info = v4l2_get_subdev_hostdata(sd);
+
+	if (!imx_info)
+		return -ENOSYS;
+	if (imx_info->num_lanes < 1 || imx_info->num_lanes > 4 ||
+	    imx_info->num_lanes == 3)
+		return -EINVAL;
+
+	return imx_info->num_lanes;
+}
+
 static int __imx_update_exposure_timing(struct i2c_client *client, u16 exposure,
 			u16 llp, u16 fll)
 {
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx_device *dev = to_imx_sensor(sd);
 	int ret = 0;
 
 	/* Increase the VTS to match exposure + margin */
 	if (exposure > fll - IMX_INTEGRATION_TIME_MARGIN)
 		fll = exposure + IMX_INTEGRATION_TIME_MARGIN;
 
-	ret = imx_write_reg(client, IMX_16BIT, IMX_LINE_LENGTH_PIXELS, llp);
+	ret = imx_write_reg(client, IMX_16BIT,
+		dev->reg_addr->line_length_pixels, llp);
 	if (ret)
 		return ret;
 
-	ret = imx_write_reg(client, IMX_16BIT, IMX_FRAME_LENGTH_LINES, fll);
+	ret = imx_write_reg(client, IMX_16BIT,
+		dev->reg_addr->frame_length_lines, fll);
 	if (ret)
 		return ret;
 
 	if (exposure)
 		ret = imx_write_reg(client, IMX_16BIT,
-			IMX_COARSE_INTEGRATION_TIME, exposure);
+			dev->reg_addr->coarse_integration_time, exposure);
+
 	return ret;
 }
 
@@ -368,7 +397,7 @@ static int __imx_update_gain(struct v4l2_subdev *sd, u16 gain)
 	int ret;
 
 	/* set global gain */
-	ret = imx_write_reg(client, IMX_8BIT, IMX_GLOBAL_GAIN, gain);
+	ret = imx_write_reg(client, IMX_8BIT, dev->reg_addr->global_gain, gain);
 	if (ret)
 		return ret;
 
@@ -381,19 +410,26 @@ static int __imx_update_gain(struct v4l2_subdev *sd, u16 gain)
 
 static int __imx_update_digital_gain(struct i2c_client *client, u16 digitgain)
 {
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx_device *dev = to_imx_sensor(sd);
 	struct imx_write_buffer digit_gain;
 
-	digit_gain.addr = cpu_to_be16(IMX_DGC_ADJ);
+	digit_gain.addr = cpu_to_be16(dev->reg_addr->dgc_adj);
 	digit_gain.data[0] = (digitgain >> 8) & 0xFF;
 	digit_gain.data[1] = digitgain & 0xFF;
-	digit_gain.data[2] = (digitgain >> 8) & 0xFF;
-	digit_gain.data[3] = digitgain & 0xFF;
-	digit_gain.data[4] = (digitgain >> 8) & 0xFF;
-	digit_gain.data[5] = digitgain & 0xFF;
-	digit_gain.data[6] = (digitgain >> 8) & 0xFF;
-	digit_gain.data[7] = digitgain & 0xFF;
 
-	return imx_i2c_write(client, IMX_DGC_LEN, (u8 *)&digit_gain);
+	if (dev->sensor_id == IMX219_ID) {
+		return imx_i2c_write(client, IMX219_DGC_LEN, (u8 *)&digit_gain);
+	} else {
+		digit_gain.data[2] = (digitgain >> 8) & 0xFF;
+		digit_gain.data[3] = digitgain & 0xFF;
+		digit_gain.data[4] = (digitgain >> 8) & 0xFF;
+		digit_gain.data[5] = digitgain & 0xFF;
+		digit_gain.data[6] = (digitgain >> 8) & 0xFF;
+		digit_gain.data[7] = digitgain & 0xFF;
+		return imx_i2c_write(client, IMX_DGC_LEN, (u8 *)&digit_gain);
+	}
+	return 0;
 }
 
 static int imx_set_exposure_gain(struct v4l2_subdev *sd, u16 coarse_itg,
@@ -401,6 +437,8 @@ static int imx_set_exposure_gain(struct v4l2_subdev *sd, u16 coarse_itg,
 {
 	struct imx_device *dev = to_imx_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int lanes = imx_get_lanes(sd);
+	unsigned int digitgain_scaled;
 	int ret = 0;
 
 	/* Validate exposure:  cannot exceed VTS-4 where VTS is 16bit */
@@ -409,11 +447,22 @@ static int imx_set_exposure_gain(struct v4l2_subdev *sd, u16 coarse_itg,
 	/* Validate gain: must not exceed maximum 8bit value */
 	gain = clamp_t(u16, gain, 0, IMX_MAX_GLOBAL_GAIN_SUPPORTED);
 
-	/* Validate digital gain: must not exceed 12 bit value*/
-	digitgain = clamp_t(u16, digitgain, 0, IMX_MAX_DIGITAL_GAIN_SUPPORTED);
-
 	mutex_lock(&dev->input_lock);
 
+	/* For imx175, setting gain must be delayed by one */
+	if ((dev->sensor_id == IMX175_ID) && dev->digital_gain)
+		digitgain_scaled = dev->digital_gain;
+	else
+		digitgain_scaled = digitgain;
+	/* imx132 with two lanes needs more gain to saturate at max */
+	if (dev->sensor_id == IMX132_ID && lanes > 1) {
+		digitgain_scaled *= IMX132_2LANES_GAINFACT;
+		digitgain_scaled >>= IMX132_2LANES_GAINFACT_SHIFT;
+	}
+	/* Validate digital gain: must not exceed 12 bit value*/
+	digitgain_scaled = clamp_t(unsigned int, digitgain_scaled,
+				   0, IMX_MAX_DIGITAL_GAIN_SUPPORTED);
+
 	ret = __imx_update_exposure_timing(client, coarse_itg,
 			dev->pixels_per_line, dev->lines_per_frame);
 	if (ret)
@@ -428,10 +477,7 @@ static int imx_set_exposure_gain(struct v4l2_subdev *sd, u16 coarse_itg,
 		goto out;
 	dev->gain = gain;
 
-	if ((dev->sensor_id == IMX175_ID) && dev->digital_gain)
-		ret = __imx_update_digital_gain(client, dev->digital_gain);
-	else
-		ret = __imx_update_digital_gain(client, digitgain);
+	ret = __imx_update_digital_gain(client, digitgain_scaled);
 	if (ret)
 		goto out;
 	dev->digital_gain = digitgain;
@@ -487,11 +533,15 @@ static int __imx_init(struct v4l2_subdev *sd, u32 val)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct imx_device *dev = to_imx_sensor(sd);
+	int lanes = imx_get_lanes(sd);
 	int ret;
 
 	if (dev->sensor_id == IMX_ID_DEFAULT)
 		return 0;
 
+	/* The default is no flip at sensor initialization */
+	dev->h_flip->cur.val = 0;
+	dev->v_flip->cur.val = 0;
 	/* Sets the default FPS */
 	dev->fps_index = 0;
 	dev->curr_res_table = dev->mode_tables->res_preview;
@@ -501,22 +551,15 @@ static int __imx_init(struct v4l2_subdev *sd, u32 val)
 	if (ret)
 		return ret;
 
-	if (dev->sensor_id == IMX132_ID) {
-		static const unsigned int IMX132_DEFAULT_LANES = 1;
-		struct camera_mipi_info *imx_info =
-						v4l2_get_subdev_hostdata(sd);
+	if (dev->sensor_id == IMX132_ID && lanes > 0) {
 		static const u8 imx132_rglanesel[] = {
 			IMX132_RGLANESEL_1LANE,		/* 1 lane */
 			IMX132_RGLANESEL_2LANES,	/* 2 lanes */
 			IMX132_RGLANESEL_1LANE,		/* undefined */
 			IMX132_RGLANESEL_4LANES,	/* 4 lanes */
 		};
-		unsigned int lanes = (imx_info ? imx_info->num_lanes
-						: IMX132_DEFAULT_LANES) - 1;
-		if (lanes >= ARRAY_SIZE(imx132_rglanesel))
-			lanes = IMX132_DEFAULT_LANES - 1;
 		ret = imx_write_reg(client, IMX_8BIT,
-				    IMX132_RGLANESEL, imx132_rglanesel[lanes]);
+				IMX132_RGLANESEL, imx132_rglanesel[lanes - 1]);
 	}
 
 	return ret;
@@ -548,71 +591,6 @@ static long imx_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	return 0;
 }
 
-static int power_ctrl(struct v4l2_subdev *sd, int flag)
-{
-	int ret;
-	struct imx_device *dev = to_imx_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->power_ctrl)
-		return dev->platform_data->power_ctrl(sd, flag);
-
-	/* G-Min only supports imx134/imx175 */
-	if (dev->sensor_id && dev->sensor_id != IMX134_ID
-		&& dev->sensor_id != IMX175_ID)
-		return -EINVAL;
-
-	if (flag) {
-		ret = dev->platform_data->v2p8_ctrl(sd, 1);
-		if (!ret) {
-			ret = dev->platform_data->v1p8_ctrl(sd, 1);
-			if (ret)
-				dev->platform_data->v2p8_ctrl(sd, 0);
-		}
-		usleep_range(1000, 1200);
-	} else {
-		ret = dev->platform_data->v2p8_ctrl(sd, 0);
-		ret |= dev->platform_data->v1p8_ctrl(sd, 0);
-	}
-	return ret;
-}
-
-static int gpio_ctrl(struct v4l2_subdev *sd, int flag)
-{
-	int ret;
-	struct imx_device *dev = to_imx_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->gpio_ctrl)
-		return dev->platform_data->gpio_ctrl(sd, flag);
-
-	/* G-Min only supports imx134/imx175 */
-	if (dev->sensor_id && dev->sensor_id != IMX134_ID
-		&& dev->sensor_id != IMX175_ID)
-		return -EINVAL;
-
-	ret = dev->platform_data->gpio0_ctrl(sd, flag);
-
-	/* From original platform_imx134/175.c:
-	 *
-	 * imx134/175 core silicon initializing time - t1+t2+t3
-	 * 400us(t1) - Time to VDDL is supplied after REGEN high
-	 * 600us(t2) - imx134 core Waking up time
-	 * 459us(t3, 8825clocks) -Initializing time of silicon */
-	if (flag)
-                usleep_range(1500, 1600);
-	else
-		udelay(1);
-	return ret;
-}
-
-
 static int power_up(struct v4l2_subdev *sd)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -620,7 +598,7 @@ static int power_up(struct v4l2_subdev *sd)
 	int ret;
 
        /* power control */
-	ret = power_ctrl(sd, 1);
+	ret = dev->platform_data->power_ctrl(sd, 1);
 	if (ret)
 		goto fail_power;
 
@@ -630,7 +608,7 @@ static int power_up(struct v4l2_subdev *sd)
 		goto fail_clk;
 
 	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 1);
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
 	if (ret) {
 		dev_err(&client->dev, "gpio failed\n");
 		goto fail_gpio;
@@ -638,11 +616,11 @@ static int power_up(struct v4l2_subdev *sd)
 
 	return 0;
 fail_gpio:
-	gpio_ctrl(sd, 0);
+	dev->platform_data->gpio_ctrl(sd, 0);
 fail_clk:
 	dev->platform_data->flisclk_ctrl(sd, 0);
 fail_power:
-	power_ctrl(sd, 0);
+	dev->platform_data->power_ctrl(sd, 0);
 	dev_err(&client->dev, "sensor power-up failed\n");
 
 	return ret;
@@ -659,12 +637,12 @@ static int power_down(struct v4l2_subdev *sd)
 		dev_err(&client->dev, "flisclk failed\n");
 
 	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 0);
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
 	if (ret)
 		dev_err(&client->dev, "gpio failed\n");
 
 	/* power control */
-	ret = power_ctrl(sd, 0);
+	ret = dev->platform_data->power_ctrl(sd, 0);
 	if (ret)
 		dev_err(&client->dev, "vprog failed.\n");
 
@@ -710,13 +688,27 @@ static int imx_s_power(struct v4l2_subdev *sd, int on)
 
 	return ret;
 }
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+static int imx_g_chip_ident(struct v4l2_subdev *sd,
+				struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 
+	if (!chip)
+		return -EINVAL;
+
+	v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_IMX, 0);
+
+	return 0;
+}
+#endif
 static int imx_get_intg_factor(struct i2c_client *client,
 				struct camera_mipi_info *info,
 				const struct imx_reg *reglist)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct imx_device *dev = to_imx_sensor(sd);
+	int lanes = imx_get_lanes(sd);
 	u32 vt_pix_clk_div;
 	u32 vt_sys_clk_div;
 	u32 pre_pll_clk_div;
@@ -742,20 +734,28 @@ static int imx_get_intg_factor(struct i2c_client *client,
 		return ret;
 	vt_pix_clk_div = data[0] & IMX_MASK_5BIT;
 
-	if (dev->sensor_id == IMX132_ID)
-		ret = imx_read_reg(client, 1, IMX132_VT_RGPLTD, data);
-	else
+	if (dev->sensor_id == IMX132_ID || dev->sensor_id == IMX208_ID) {
+		static const int rgpltd[] = { 2, 4, 1, 1 };
+		ret = imx_read_reg(client, 1, IMX132_208_VT_RGPLTD, data);
+		if (ret)
+			return ret;
+		vt_sys_clk_div = rgpltd[data[0] & IMX_MASK_2BIT];
+	} else {
 		ret = imx_read_reg(client, 1, IMX_VT_SYS_CLK_DIV, data);
-	if (ret)
-		return ret;
-	vt_sys_clk_div = data[0] & IMX_MASK_2BIT;
+		if (ret)
+			return ret;
+		vt_sys_clk_div = data[0] & IMX_MASK_2BIT;
+	}
 	ret = imx_read_reg(client, 1, IMX_PRE_PLL_CLK_DIV, data);
 	if (ret)
 		return ret;
 	pre_pll_clk_div = data[0] & IMX_MASK_4BIT;
+
 	ret = imx_read_reg(client, 2,
-		(dev->sensor_id == IMX132_ID) ?
-		IMX132_PLL_MULTIPLIER : IMX_PLL_MULTIPLIER, data);
+		(dev->sensor_id == IMX132_ID ||
+		 dev->sensor_id == IMX219_ID ||
+		 dev->sensor_id == IMX208_ID) ?
+		IMX132_208_219_PLL_MULTIPLIER : IMX_PLL_MULTIPLIER, data);
 	if (ret)
 		return ret;
 	pll_multiplier = data[0] & IMX_MASK_11BIT;
@@ -768,38 +768,41 @@ static int imx_get_intg_factor(struct i2c_client *client,
 	coarse_integration_time_max_margin = data[1];
 
 	/* Get the cropping and output resolution to ISP for this mode. */
-	ret =  imx_read_reg(client, 2, IMX_HORIZONTAL_START_H, data);
+	ret =  imx_read_reg(client, 2, dev->reg_addr->horizontal_start_h, data);
 	if (ret)
 		return ret;
 	buf->crop_horizontal_start = data[0];
 
-	ret = imx_read_reg(client, 2, IMX_VERTICAL_START_H, data);
+	ret = imx_read_reg(client, 2, dev->reg_addr->vertical_start_h, data);
 	if (ret)
 		return ret;
 	buf->crop_vertical_start = data[0];
 
-	ret = imx_read_reg(client, 2, IMX_HORIZONTAL_END_H, data);
+	ret = imx_read_reg(client, 2, dev->reg_addr->horizontal_end_h, data);
 	if (ret)
 		return ret;
 	buf->crop_horizontal_end = data[0];
 
-	ret = imx_read_reg(client, 2, IMX_VERTICAL_END_H, data);
+	ret = imx_read_reg(client, 2, dev->reg_addr->vertical_end_h, data);
 	if (ret)
 		return ret;
 	buf->crop_vertical_end = data[0];
 
-	ret = imx_read_reg(client, 2, IMX_HORIZONTAL_OUTPUT_SIZE_H, data);
+	ret = imx_read_reg(client, 2,
+		dev->reg_addr->horizontal_output_size_h, data);
 	if (ret)
 		return ret;
 	buf->output_width = data[0];
 
-	ret = imx_read_reg(client, 2, IMX_VERTICAL_OUTPUT_SIZE_H, data);
+	ret = imx_read_reg(client, 2,
+		dev->reg_addr->vertical_output_size_h, data);
 	if (ret)
 		return ret;
 	buf->output_height = data[0];
 
 	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
-	if (dev->sensor_id == IMX132_ID)
+	if (dev->sensor_id == IMX132_ID || dev->sensor_id == IMX208_ID ||
+		dev->sensor_id == IMX219_ID)
 		read_mode = 0;
 	else {
 		ret = imx_read_reg(client, 1, IMX_READ_MODE, data);
@@ -812,8 +815,14 @@ static int imx_get_intg_factor(struct i2c_client *client,
 	if (div == 0)
 		return -EINVAL;
 
-	vt_pix_clk_freq_mhz = 2 * ext_clk_freq_hz / div;
+	if (dev->sensor_id == IMX132_ID || dev->sensor_id == IMX208_ID)
+		vt_pix_clk_freq_mhz = ext_clk_freq_hz / div;
+	else
+		vt_pix_clk_freq_mhz = 2 * ext_clk_freq_hz / div;
+
 	vt_pix_clk_freq_mhz *= pll_multiplier;
+	if (dev->sensor_id == IMX132_ID && lanes > 0)
+		vt_pix_clk_freq_mhz *= lanes;
 
 	dev->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
 
@@ -829,7 +838,8 @@ static int imx_get_intg_factor(struct i2c_client *client,
 	buf->line_length_pck = dev->pixels_per_line;
 	buf->read_mode = read_mode;
 
-	if (dev->sensor_id == IMX132_ID) {
+	if (dev->sensor_id == IMX132_ID || dev->sensor_id == IMX208_ID ||
+		dev->sensor_id == IMX219_ID) {
 		buf->binning_factor_x = 1;
 		buf->binning_factor_y = 1;
 	} else {
@@ -861,22 +871,49 @@ static int imx_get_intg_factor(struct i2c_client *client,
 static int imx_q_exposure(struct v4l2_subdev *sd, s32 *value)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
 	u16 coarse;
 	int ret;
 
 	/* the fine integration time is currently not calculated */
 	ret = imx_read_reg(client, IMX_16BIT,
-			       IMX_COARSE_INTEGRATION_TIME, &coarse);
+		dev->reg_addr->coarse_integration_time, &coarse);
 	*value = coarse;
 
 	return ret;
 }
 
-static int imx_test_pattern(struct v4l2_subdev *sd, s32 value)
+static int imx_test_pattern(struct v4l2_subdev *sd)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	if (dev->power == 0)
+		return 0;
 
-	return imx_write_reg(client, IMX_16BIT, IMX_TEST_PATTERN_MODE, value);
+	ret = imx_write_reg(client, IMX_16BIT, IMX_TEST_PATTERN_COLOR_R,
+		(u16)(dev->tp_r->val >> 22));
+	if (ret)
+		return ret;
+
+	ret = imx_write_reg(client, IMX_16BIT, IMX_TEST_PATTERN_COLOR_GR,
+		(u16)(dev->tp_gr->val >> 22));
+	if (ret)
+		return ret;
+
+	ret = imx_write_reg(client, IMX_16BIT, IMX_TEST_PATTERN_COLOR_GB,
+		(u16)(dev->tp_gb->val >> 22));
+	if (ret)
+		return ret;
+
+	ret = imx_write_reg(client, IMX_16BIT, IMX_TEST_PATTERN_COLOR_B,
+		(u16)(dev->tp_b->val >> 22));
+	if (ret)
+		return ret;
+
+	return imx_write_reg(client, IMX_16BIT, IMX_TEST_PATTERN_MODE,
+		(u16)(dev->tp_mode->val));
 }
 
 static enum v4l2_mbus_pixelcode
@@ -903,18 +940,24 @@ static int imx_v_flip(struct v4l2_subdev *sd, s32 value)
 	int ret;
 	u16 val;
 
-	ret = imx_write_reg_array(client, imx_param_hold);
+	if (dev->power == 0)
+		return -EIO;
+
+	ret = imx_write_reg_array(client, dev->param_hold);
 	if (ret)
 		return ret;
-	ret = imx_read_reg(client, IMX_8BIT, IMX_IMG_ORIENTATION, &val);
+
+	ret = imx_read_reg(client, IMX_8BIT,
+		dev->reg_addr->img_orientation, &val);
 	if (ret)
 		return ret;
 	if (value)
 		val |= IMX_VFLIP_BIT;
 	else
 		val &= ~IMX_VFLIP_BIT;
+
 	ret = imx_write_reg(client, IMX_8BIT,
-			IMX_IMG_ORIENTATION, val);
+		dev->reg_addr->img_orientation, val);
 	if (ret)
 		return ret;
 
@@ -926,7 +969,7 @@ static int imx_v_flip(struct v4l2_subdev *sd, s32 value)
 			imx_info->raw_bayer_order);
 	}
 
-	return imx_write_reg_array(client, imx_param_update);
+	return imx_write_reg_array(client, dev->param_update);
 }
 
 static int imx_h_flip(struct v4l2_subdev *sd, s32 value)
@@ -937,10 +980,14 @@ static int imx_h_flip(struct v4l2_subdev *sd, s32 value)
 	int ret;
 	u16 val;
 
-	ret = imx_write_reg_array(client, imx_param_hold);
+	if (dev->power == 0)
+		return -EIO;
+
+	ret = imx_write_reg_array(client, dev->param_hold);
 	if (ret)
 		return ret;
-	ret = imx_read_reg(client, IMX_8BIT, IMX_IMG_ORIENTATION, &val);
+	ret = imx_read_reg(client, IMX_8BIT,
+		dev->reg_addr->img_orientation, &val);
 	if (ret)
 		return ret;
 	if (value)
@@ -948,7 +995,7 @@ static int imx_h_flip(struct v4l2_subdev *sd, s32 value)
 	else
 		val &= ~IMX_HFLIP_BIT;
 	ret = imx_write_reg(client, IMX_8BIT,
-			IMX_IMG_ORIENTATION, val);
+		dev->reg_addr->img_orientation, val);
 	if (ret)
 		return ret;
 
@@ -960,7 +1007,7 @@ static int imx_h_flip(struct v4l2_subdev *sd, s32 value)
 		imx_info->raw_bayer_order);
 	}
 
-	return imx_write_reg_array(client, imx_param_update);
+	return imx_write_reg_array(client, dev->param_update);
 }
 
 static int imx_g_focal(struct v4l2_subdev *sd, s32 *val)
@@ -1081,251 +1128,365 @@ int imx_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
 	return 0;
 }
 
-struct imx_control imx_controls[] = {
+static int imx_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct imx_device *dev = container_of(
+		ctrl->handler, struct imx_device, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_TEST_PATTERN:
+		ret = imx_test_pattern(&dev->sd);
+		break;
+	case V4L2_CID_VFLIP:
+		dev_dbg(&client->dev, "%s: CID_VFLIP:%d.\n", __func__, ctrl->val);
+		ret = imx_v_flip(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		dev_dbg(&client->dev, "%s: CID_HFLIP:%d.\n", __func__, ctrl->val);
+		ret = imx_h_flip(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		ret = imx_t_focus_abs(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_FOCUS_RELATIVE:
+		ret = imx_t_focus_rel(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_VCM_SLEW:
+		ret = imx_t_vcm_slew(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_VCM_TIMEING:
+		ret = imx_t_vcm_timing(&dev->sd, ctrl->val);
+		break;
+	}
+
+	return ret;
+}
+
+static int imx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct imx_device *dev = container_of(
+		ctrl->handler, struct imx_device, ctrl_handler);
+	int ret = 0;
+	unsigned int val;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		ret = imx_q_exposure(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		ret = imx_q_focus_abs(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FOCUS_STATUS:
+		ret = imx_q_focus_status(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FOCAL_ABSOLUTE:
+		ret = imx_g_focal(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FNUMBER_ABSOLUTE:
+		ret = imx_g_fnumber(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FNUMBER_RANGE:
+		ret = imx_g_fnumber_range(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_BIN_FACTOR_HORZ:
+		ret = imx_g_bin_factor_x(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_BIN_FACTOR_VERT:
+		ret = imx_g_bin_factor_y(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_VBLANK:
+		ctrl->val = dev->lines_per_frame -
+			dev->curr_res_table[dev->fmt_idx].height;
+		break;
+	case V4L2_CID_HBLANK:
+		ctrl->val = dev->pixels_per_line -
+			dev->curr_res_table[dev->fmt_idx].width;
+		break;
+	case V4L2_CID_PIXEL_RATE:
+		ctrl->val = dev->vt_pix_clk_freq_mhz;
+		break;
+	case V4L2_CID_LINK_FREQ:
+		val = dev->curr_res_table[dev->fmt_idx].
+					fps_options[dev->fps_index].mipi_freq;
+		if (val == 0)
+			val = dev->curr_res_table[dev->fmt_idx].mipi_freq;
+		if (val == 0)
+			return -EINVAL;
+		ctrl->val = val * 1000;			/* To Hz */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = imx_s_ctrl,
+	.g_volatile_ctrl = imx_g_volatile_ctrl
+};
+
+static const struct v4l2_ctrl_config imx_controls[] = {
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "exposure",
+		.min = 0x0,
+		.max = 0xffff,
+		.step = 0x01,
+		.def = 0x00,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Test pattern",
+		.min = 0,
+		.max = 0xffff,
+		.step = 1,
+		.def = 0,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN_COLOR_R,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Test pattern solid color R",
+		.min = INT_MIN,
+		.max = INT_MAX,
+		.step = 1,
+		.def = 0,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN_COLOR_GR,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Test pattern solid color GR",
+		.min = INT_MIN,
+		.max = INT_MAX,
+		.step = 1,
+		.def = 0,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN_COLOR_GB,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Test pattern solid color GB",
+		.min = INT_MIN,
+		.max = INT_MAX,
+		.step = 1,
+		.def = 0,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN_COLOR_B,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "Test pattern solid color B",
+		.min = INT_MIN,
+		.max = INT_MAX,
+		.step = 1,
+		.def = 0,
+	},
 	{
-		.qc = {
-			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "exposure",
-			.minimum = 0x0,
-			.maximum = 0xffff,
-			.step = 0x01,
-			.default_value = 0x00,
-			.flags = 0,
-		},
-		.query = imx_q_exposure,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_VFLIP,
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.name = "Flip",
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_TEST_PATTERN,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "Test pattern",
-			.minimum = 0,
-			.maximum = 0xffff,
-			.step = 1,
-			.default_value = 0,
-		},
-		.tweak = imx_test_pattern,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_HFLIP,
+		.type = V4L2_CTRL_TYPE_BOOLEAN,
+		.name = "Mirror",
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_VFLIP,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "Flip",
-			.minimum = 0,
-			.maximum = 1,
-			.step = 1,
-			.default_value = 0,
-		},
-		.tweak = imx_v_flip,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focus move absolute",
+		.min = 0,
+		.max = IMX_MAX_FOCUS_POS,
+		.step = 1,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_HFLIP,
-			.type = V4L2_CTRL_TYPE_BOOLEAN,
-			.name = "Mirror",
-			.minimum = 0,
-			.maximum = 1,
-			.step = 1,
-			.default_value = 0,
-		},
-		.tweak = imx_h_flip,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_RELATIVE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focus move relative",
+		.min = IMX_MAX_FOCUS_NEG,
+		.max = IMX_MAX_FOCUS_POS,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_FOCUS_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focus move absolute",
-			.minimum = 0,
-			.maximum = IMX_MAX_FOCUS_POS,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = imx_t_focus_abs,
-		.query = imx_q_focus_abs,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_STATUS,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focus status",
+		.min = 0,
+		.max = 100, /* allow enum to grow in the future */
+		.step = 1,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_FOCUS_RELATIVE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focus move relative",
-			.minimum = IMX_MAX_FOCUS_NEG,
-			.maximum = IMX_MAX_FOCUS_POS,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = imx_t_focus_rel,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_VCM_SLEW,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "vcm slew",
+		.min = 0,
+		.max = IMX_VCM_SLEW_STEP_MAX,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_FOCUS_STATUS,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focus status",
-			.minimum = 0,
-			.maximum = 100, /* allow enum to grow in the future */
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = imx_q_focus_status,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_VCM_TIMEING,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "vcm step time",
+		.min = 0,
+		.max = IMX_VCM_SLEW_TIME_MAX,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_VCM_SLEW,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "vcm slew",
-			.minimum = 0,
-			.maximum = IMX_VCM_SLEW_STEP_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = imx_t_vcm_slew,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCAL_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focal length",
+		.min = IMX_FOCAL_LENGTH_DEFAULT,
+		.max = IMX_FOCAL_LENGTH_DEFAULT,
+		.step = 0x01,
+		.def = IMX_FOCAL_LENGTH_DEFAULT,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_VCM_TIMEING,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "vcm step time",
-			.minimum = 0,
-			.maximum = IMX_VCM_SLEW_TIME_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = imx_t_vcm_timing,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "f-number",
+		.min = IMX_F_NUMBER_DEFAULT,
+		.max = IMX_F_NUMBER_DEFAULT,
+		.step = 0x01,
+		.def = IMX_F_NUMBER_DEFAULT,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_FOCAL_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focal length",
-			.minimum = IMX_FOCAL_LENGTH_DEFAULT,
-			.maximum = IMX_FOCAL_LENGTH_DEFAULT,
-			.step = 0x01,
-			.default_value = IMX_FOCAL_LENGTH_DEFAULT,
-			.flags = 0,
-		},
-		.query = imx_g_focal,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_RANGE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "f-number range",
+		.min = IMX_F_NUMBER_RANGE,
+		.max =  IMX_F_NUMBER_RANGE,
+		.step = 0x01,
+		.def = IMX_F_NUMBER_RANGE,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_FNUMBER_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "f-number",
-			.minimum = IMX_F_NUMBER_DEFAULT,
-			.maximum = IMX_F_NUMBER_DEFAULT,
-			.step = 0x01,
-			.default_value = IMX_F_NUMBER_DEFAULT,
-			.flags = 0,
-		},
-		.query = imx_g_fnumber,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_HORZ,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "horizontal binning factor",
+		.min = 0,
+		.max = IMX_BIN_FACTOR_MAX,
+		.step = 1,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_FNUMBER_RANGE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "f-number range",
-			.minimum = IMX_F_NUMBER_RANGE,
-			.maximum =  IMX_F_NUMBER_RANGE,
-			.step = 0x01,
-			.default_value = IMX_F_NUMBER_RANGE,
-			.flags = 0,
-		},
-		.query = imx_g_fnumber_range,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_VERT,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "vertical binning factor",
+		.min = 0,
+		.max = IMX_BIN_FACTOR_MAX,
+		.step = 1,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_BIN_FACTOR_HORZ,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "horizontal binning factor",
-			.minimum = 0,
-			.maximum = IMX_BIN_FACTOR_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = imx_g_bin_factor_x,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_LINK_FREQ,
+		.name = "Link Frequency",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 1500000 * 1000,
+		.step = 1,
+		.def = 1,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
 	},
 	{
-		.qc = {
-			.id = V4L2_CID_BIN_FACTOR_VERT,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "vertical binning factor",
-			.minimum = 0,
-			.maximum = IMX_BIN_FACTOR_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = imx_g_bin_factor_y,
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_PIXEL_RATE,
+		.name = "Pixel Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = INT_MAX,
+		.step = 1,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_HBLANK,
+		.name = "Horizontal Blanking",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = SHRT_MAX,
+		.step = 1,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_VBLANK,
+		.name = "Vertical Blanking",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = SHRT_MAX,
+		.step = 1,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_HFLIP,
+		.name = "Horizontal Flip",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_VFLIP,
+		.name = "Vertical Flip",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.max = 1,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
 	},
 };
-#define N_CONTROLS (ARRAY_SIZE(imx_controls))
-
-static struct imx_control *imx_find_control(u32 id)
-{
-	int i;
-
-	for (i = 0; i < N_CONTROLS; i++)
-		if (imx_controls[i].qc.id == id)
-			return &imx_controls[i];
-	return NULL;
-}
-
-static int imx_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
-{
-	struct imx_control *ctrl = imx_find_control(qc->id);
-	struct imx_device *dev = to_imx_sensor(sd);
-
-	if (ctrl == NULL)
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	*qc = ctrl->qc;
-	mutex_unlock(&dev->input_lock);
-
-	return 0;
-}
-
-/* imx control set/get */
-static int imx_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct imx_control *s_ctrl;
-	struct imx_device *dev = to_imx_sensor(sd);
-	int ret;
-
-	if (!ctrl)
-		return -EINVAL;
-
-	s_ctrl = imx_find_control(ctrl->id);
-	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = s_ctrl->query(sd, &ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static int imx_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct imx_control *octrl = imx_find_control(ctrl->id);
-	struct imx_device *dev = to_imx_sensor(sd);
-	int ret;
-
-	if ((octrl == NULL) || (octrl->tweak == NULL))
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = octrl->tweak(sd, ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
 
 /*
  * distance - calculate the distance
@@ -1383,7 +1544,7 @@ static int nearest_resolution_index(struct v4l2_subdev *sd, int w, int h)
 			idx = i;
 		}
 		if (dist == min_dist) {
-			fps_diff = __imx_min_fps_diff(dev->fps,
+			fps_diff = __imx_min_fps_diff(dev->targetfps,
 						tmp_res->fps_options);
 			if (fps_diff < min_fps_diff) {
 				min_fps_diff = fps_diff;
@@ -1450,12 +1611,12 @@ static int __adjust_hvblank(struct v4l2_subdev *sd)
 	new_line_length_pck = dev->curr_res_table[dev->fmt_idx].width +
 		dev->h_blank->val;
 
-	ret = imx_write_reg(client, IMX_16BIT, IMX_LINE_LENGTH_PIXELS,
-			    new_line_length_pck);
+	ret = imx_write_reg(client, IMX_16BIT,
+		dev->reg_addr->line_length_pixels, new_line_length_pck);
 	if (ret)
 		return ret;
-	ret = imx_write_reg(client, IMX_16BIT, IMX_FRAME_LENGTH_LINES,
-			    new_frame_length_lines);
+	ret = imx_write_reg(client, IMX_16BIT,
+		dev->reg_addr->frame_length_lines, new_frame_length_lines);
 	if (ret)
 		return ret;
 
@@ -1472,8 +1633,9 @@ static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
 	struct camera_mipi_info *imx_info = NULL;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	const struct imx_resolution *res;
+	int lanes = imx_get_lanes(sd);
 	int ret;
-	u16 val;
+	u16 data, val;
 
 	imx_info = v4l2_get_subdev_hostdata(sd);
 	if (imx_info == NULL)
@@ -1492,7 +1654,7 @@ static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
 	res = &dev->curr_res_table[dev->fmt_idx];
 
 	/* Adjust the FPS selection based on the resolution selected */
-	dev->fps_index = __imx_nearest_fps_index(dev->fps, res->fps_options);
+	dev->fps_index = __imx_nearest_fps_index(dev->targetfps, res->fps_options);
 	dev->fps = res->fps_options[dev->fps_index].fps;
 	dev->regs = res->fps_options[dev->fps_index].regs;
 	if (!dev->regs)
@@ -1502,20 +1664,39 @@ static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
 	if (ret)
 		goto out;
 
+	if (dev->sensor_id == IMX132_ID && lanes > 0) {
+		static const u8 imx132_rgpltd[] = {
+			2,		/* 1 lane:  /1 */
+			0,		/* 2 lanes: /2 */
+			0,		/* undefined   */
+			1,		/* 4 lanes: /4 */
+		};
+		ret = imx_write_reg(client, IMX_8BIT, IMX132_208_VT_RGPLTD,
+				    imx132_rgpltd[lanes - 1]);
+		if (ret)
+			goto out;
+	}
+
 	dev->pixels_per_line = res->fps_options[dev->fps_index].pixels_per_line;
 	dev->lines_per_frame = res->fps_options[dev->fps_index].lines_per_frame;
 
 	/* dbg h/v blank time */
-	mutex_lock(dev->ctrl_handler.lock);
 	__adjust_hvblank(sd);
-	mutex_unlock(dev->ctrl_handler.lock);
 
 	ret = __imx_update_exposure_timing(client, dev->coarse_itg,
 		dev->pixels_per_line, dev->lines_per_frame);
 	if (ret)
 		goto out;
 
-	ret = imx_write_reg_array(client, imx_param_update);
+	ret = __imx_update_gain(sd, dev->gain);
+	if (ret)
+		goto out;
+
+	ret = __imx_update_digital_gain(client, dev->digital_gain);
+	if (ret)
+		goto out;
+
+	ret = imx_write_reg_array(client, dev->param_update);
 	if (ret)
 		goto out;
 
@@ -1523,13 +1704,54 @@ static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
 	if (ret)
 		goto out;
 
-	ret = imx_read_reg(client, IMX_8BIT, IMX_IMG_ORIENTATION, &val);
+	ret = imx_read_reg(client, IMX_8BIT,
+		dev->reg_addr->img_orientation, &val);
 	if (ret)
 		goto out;
 	val &= (IMX_VFLIP_BIT|IMX_HFLIP_BIT);
 	imx_info->raw_bayer_order = imx_bayer_order_mapping[val];
 	dev->format.code = imx_translate_bayer_order(
 		imx_info->raw_bayer_order);
+
+	/*
+	 * Fill meta data info. add imx135 metadata setting for RAW10 format
+	 */
+	switch (dev->sensor_id) {
+	case IMX135_ID:
+		ret = imx_read_reg(client, 2, IMX135_OUTPUT_DATA_FORMAT_REG, &data);
+		if (ret)
+			goto out;
+		/*
+		 * The IMX135 can support various resolutions like
+		 * RAW6/8/10/12/14.
+		 * 1.The data format is RAW10:
+		 *   matadata width = current resolution width(pixel) * 10 / 8
+		 * 2.The data format is RAW6 or RAW8:
+		 *   matadata width = current resolution width(pixel);
+		 * 3.other data format(RAW12/14 etc):
+		 *   TBD.
+		 */
+		if (data == IMX135_OUTPUT_FORMAT_RAW10)
+			/* the data format is RAW10. */
+			imx_info->metadata_width = res->width * 10 / 8;
+		else
+			/* The data format is RAW6/8/12/14/ etc. */
+			imx_info->metadata_width = res->width;
+
+		imx_info->metadata_height = IMX135_EMBEDDED_DATA_LINE_NUM;
+
+		if (imx_info->metadata_effective_width == NULL)
+			imx_info->metadata_effective_width =
+				imx135_embedded_effective_size;
+
+		break;
+	default:
+		imx_info->metadata_width = 0;
+		imx_info->metadata_height = 0;
+		imx_info->metadata_effective_width = NULL;
+		break;
+	}
+
 out:
 	mutex_unlock(&dev->input_lock);
 	return ret;
@@ -1561,11 +1783,12 @@ static int imx_detect(struct i2c_client *client, u16 *id, u8 *revision)
 		return -ENODEV;
 
 	/* check sensor chip ID	 */
-	if (imx_read_reg(client, IMX_16BIT, IMX132_175_CHIP_ID, id)) {
+	if (imx_read_reg(client, IMX_16BIT, IMX132_175_208_219_CHIP_ID, id)) {
 		v4l2_err(client, "sensor_id = 0x%x\n", *id);
 		return -ENODEV;
 	}
-	if (*id == IMX132_ID || *id == IMX175_ID)
+
+	if (*id == IMX132_ID || *id == IMX175_ID || *id == IMX208_ID || *id == IMX219_ID)
 		goto found;
 
 	if (imx_read_reg(client, IMX_16BIT, IMX134_135_CHIP_ID, id)) {
@@ -1629,6 +1852,12 @@ static int imx_s_stream(struct v4l2_subdev *sd, int enable)
 				return ret;
 			}
 		}
+		ret = imx_test_pattern(sd);
+		if (ret) {
+			v4l2_err(client, "Configure test pattern failed.\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
 		__imx_print_timing(sd);
 		ret = imx_write_reg_array(client, imx_streaming);
 		if (ret != 0) {
@@ -1645,8 +1874,7 @@ static int imx_s_stream(struct v4l2_subdev *sd, int enable)
 			return ret;
 		}
 		dev->streaming = 0;
-		dev->fps_index = 0;
-		dev->fps = 0;
+		dev->targetfps = 0;
 	}
 	mutex_unlock(&dev->input_lock);
 
@@ -1725,6 +1953,7 @@ static int imx_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
 
 static int __update_imx_device_settings(struct imx_device *dev, u16 sensor_id)
 {
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
 	switch (sensor_id) {
 	case IMX175_ID:
 		if (INTEL_MID_BOARD(1, TABLET, CHT) ||
@@ -1756,16 +1985,30 @@ static int __update_imx_device_settings(struct imx_device *dev, u16 sensor_id)
 		dev->vcm_driver = &imx_vcms[IMX134_VALLEYVIEW];
 		dev->otp_driver = &imx_otps[IMX134_VALLEYVIEW];
 		break;
+	case IMX219_ID:
+		dev->mode_tables = &imx_sets[IMX219_MFV0_PRH];
+		dev->vcm_driver = &imx_vcms[IMX219_MFV0_PRH];
+		dev->otp_driver = &imx_otps[IMX219_MFV0_PRH];
+		break;
 	case IMX132_ID:
 		dev->mode_tables = &imx_sets[IMX132_SALTBAY];
 		dev->otp_driver = &imx_otps[IMX132_SALTBAY];
 		dev->vcm_driver = NULL;
 		return 0;
+	case IMX208_ID:
+		dev->mode_tables = &imx_sets[IMX208_MOFD_PD2];
+		dev->otp_driver = &imx_otps[IMX208_MOFD_PD2];
+		dev->vcm_driver = NULL;
+		return 0;
 	default:
 		return -EINVAL;
 	}
 
 	return dev->vcm_driver->init(&dev->sd);
+#else
+	/* IMX on other platform is not supported yet */
+	return -EINVAL;
+#endif
 }
 
 static int imx_s_config(struct v4l2_subdev *sd,
@@ -1932,9 +2175,10 @@ static int
 imx_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
 {
 	struct imx_device *dev = to_imx_sensor(sd);
-	dev->run_mode = param->parm.capture.capturemode;
 
 	mutex_lock(&dev->input_lock);
+	dev->run_mode = param->parm.capture.capturemode;
+
 	switch (dev->run_mode) {
 	case CI_MODE_VIDEO:
 		dev->curr_res_table = dev->mode_tables->res_video;
@@ -1957,11 +2201,9 @@ imx_g_frame_interval(struct v4l2_subdev *sd,
 				struct v4l2_subdev_frame_interval *interval)
 {
 	struct imx_device *dev = to_imx_sensor(sd);
-	const struct imx_resolution *res =
-				&dev->curr_res_table[dev->fmt_idx];
 
 	mutex_lock(&dev->input_lock);
-	interval->interval.denominator = res->fps_options[dev->fps_index].fps;
+	interval->interval.denominator = dev->fps;
 	interval->interval.numerator = 1;
 	mutex_unlock(&dev->input_lock);
 	return 0;
@@ -1994,12 +2236,10 @@ static int __imx_s_frame_interval(struct v4l2_subdev *sd,
 	if (!fps)
 		return -EINVAL;
 
+	dev->targetfps = fps;
 	/* No need to proceed further if we are not streaming */
-	if (!dev->streaming) {
-		/* Save the new FPS and use it while selecting setting */
-		dev->fps = fps;
+	if (!dev->streaming)
 		return 0;
-	}
 
 	 /* Ignore if we are already using the required FPS. */
 	if (fps == dev->fps)
@@ -2124,49 +2364,6 @@ static const struct v4l2_subdev_sensor_ops imx_sensor_ops = {
 	.g_skip_frames	= imx_g_skip_frames,
 };
 
-static int imx_set_ctrl(struct v4l2_ctrl *ctrl)
-{
-	return 0;
-}
-
-static int imx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct imx_device *dev = container_of(ctrl->handler, struct imx_device,
-			ctrl_handler);
-	unsigned int val;
-
-	switch (ctrl->id) {
-	case V4L2_CID_VBLANK:
-		ctrl->val = dev->lines_per_frame -
-			dev->curr_res_table[dev->fmt_idx].height;
-		break;
-	case V4L2_CID_HBLANK:
-		ctrl->val = dev->pixels_per_line -
-			dev->curr_res_table[dev->fmt_idx].width;
-		break;
-	case V4L2_CID_PIXEL_RATE:
-		ctrl->val = dev->vt_pix_clk_freq_mhz;
-		break;
-	case V4L2_CID_LINK_FREQ:
-		val = dev->curr_res_table[dev->fmt_idx].
-					fps_options[dev->fps_index].mipi_freq;
-		if (val == 0)
-			val = dev->curr_res_table[dev->fmt_idx].mipi_freq;
-		if (val == 0)
-			return -EINVAL;
-		ctrl->val = val * 1000;			/* To Hz */
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static struct v4l2_ctrl_ops imx_ctrl_ops = {
-	.s_ctrl = imx_set_ctrl,
-	.g_volatile_ctrl = imx_g_volatile_ctrl,
-};
-
 static const struct v4l2_subdev_video_ops imx_video_ops = {
 	.s_stream = imx_s_stream,
 	.enum_framesizes = imx_enum_framesizes,
@@ -2181,9 +2378,12 @@ static const struct v4l2_subdev_video_ops imx_video_ops = {
 };
 
 static const struct v4l2_subdev_core_ops imx_core_ops = {
-	.queryctrl = imx_queryctrl,
-	.g_ctrl = imx_g_ctrl,
-	.s_ctrl = imx_s_ctrl,
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+	.g_chip_ident = imx_g_chip_ident,
+#endif
+	.queryctrl = v4l2_subdev_queryctrl,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
 	.s_power = imx_s_power,
 	.ioctl = imx_ioctl,
 	.init = imx_init,
@@ -2207,18 +2407,6 @@ static const struct media_entity_operations imx_entity_ops = {
 	.link_setup = NULL,
 };
 
-static const struct v4l2_ctrl_config v4l2_ctrl_link_freq = {
-	.ops = &imx_ctrl_ops,
-	.id = V4L2_CID_LINK_FREQ,
-	.name = "Link Frequency",
-	.type = V4L2_CTRL_TYPE_INTEGER,
-	.min = 1,
-	.max = 1500000 * 1000,
-	.step = 1,
-	.def = 1,
-	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
-};
-
 static int imx_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
@@ -2240,50 +2428,65 @@ static int imx_remove(struct i2c_client *client)
 static int __imx_init_ctrl_handler(struct imx_device *dev)
 {
 	struct v4l2_ctrl_handler *hdl;
+	int i;
 
 	hdl = &dev->ctrl_handler;
 
-	v4l2_ctrl_handler_init(&dev->ctrl_handler, 3);
-
-	dev->pixel_rate = v4l2_ctrl_new_std(&dev->ctrl_handler,
-					    &imx_ctrl_ops,
-					    V4L2_CID_PIXEL_RATE,
-					    0, UINT_MAX, 1, 0);
-
-	dev->h_blank = v4l2_ctrl_new_std(&dev->ctrl_handler,
-					  &imx_ctrl_ops,
-					  V4L2_CID_HBLANK, 0, SHRT_MAX, 1, 0);
-
-	dev->v_blank = v4l2_ctrl_new_std(&dev->ctrl_handler,
-					  &imx_ctrl_ops,
-					  V4L2_CID_VBLANK, 0, SHRT_MAX, 1, 0);
-	dev->link_freq = v4l2_ctrl_new_custom(&dev->ctrl_handler,
-					      &v4l2_ctrl_link_freq,
-					      NULL);
+	v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(imx_controls));
+
+	for (i = 0; i < ARRAY_SIZE(imx_controls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler,
+				&imx_controls[i], NULL);
+
+	dev->pixel_rate = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_PIXEL_RATE);
+	dev->h_blank = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_HBLANK);
+	dev->v_blank = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_VBLANK);
+	dev->link_freq = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_LINK_FREQ);
+	dev->h_flip = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_HFLIP);
+	dev->v_flip = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_VFLIP);
+	dev->tp_mode = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_TEST_PATTERN);
+	dev->tp_r = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_TEST_PATTERN_COLOR_R);
+	dev->tp_gr = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_TEST_PATTERN_COLOR_GR);
+	dev->tp_gb = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_TEST_PATTERN_COLOR_GB);
+	dev->tp_b = v4l2_ctrl_find(&dev->ctrl_handler,
+				V4L2_CID_TEST_PATTERN_COLOR_B);
 
 	if (dev->ctrl_handler.error || dev->pixel_rate == NULL
 		|| dev->h_blank == NULL || dev->v_blank == NULL
+		|| dev->h_flip == NULL || dev->v_flip == NULL
 		|| dev->link_freq == NULL) {
 		return dev->ctrl_handler.error;
 	}
 
+	dev->ctrl_handler.lock = &dev->input_lock;
 	dev->sd.ctrl_handler = hdl;
-
-	dev->pixel_rate->flags |= V4L2_CTRL_FLAG_VOLATILE;
-	dev->h_blank->flags |= V4L2_CTRL_FLAG_VOLATILE;
-	dev->v_blank->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
 
 	return 0;
 }
 
-static const struct i2c_device_id imx_ids[] = {
-	{IMX_NAME_175, IMX175_ID},
-	{IMX_NAME_135, IMX135_ID},
-	{IMX_NAME_135_FUJI, IMX135_FUJI_ID},
-	{IMX_NAME_134, IMX134_ID},
-	{IMX_NAME_132, IMX132_ID},
-	{}
-};
+static void imx_update_reg_info(struct imx_device *dev)
+{
+	if (dev->sensor_id == IMX219_ID) {
+		dev->reg_addr = &imx219_addr;
+		dev->param_hold = imx219_param_hold;
+		dev->param_update = imx219_param_update;
+	} else {
+		dev->reg_addr = &imx_addr;
+		dev->param_hold = imx_param_hold;
+		dev->param_update = imx_param_update;
+	}
+}
 
 static int imx_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
@@ -2292,7 +2495,6 @@ static int imx_probe(struct i2c_client *client,
 	struct camera_mipi_info *imx_info = NULL;
 	int ret;
 	char *msr_file_name = NULL;
-	struct camera_sensor_platform_data *pdata = NULL;
 
 	/* allocate sensor device & init sub device */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
@@ -2303,39 +2505,27 @@ static int imx_probe(struct i2c_client *client,
 
 	mutex_init(&dev->input_lock);
 
-	if (id) {
-		dev->i2c_id = id->driver_data;
-	} else {
-		dev->i2c_id = gmin_get_var_int(&client->dev, "ImxId", IMX134_ID);
-	}
+	dev->i2c_id = id->driver_data;
 	dev->fmt_idx = 0;
 	dev->sensor_id = IMX_ID_DEFAULT;
 	dev->vcm_driver = &imx_vcms[IMX_ID_DEFAULT];
+	dev->digital_gain = 256;
 
 	v4l2_i2c_subdev_init(&(dev->sd), client, &imx_ops);
 
-	pdata = client->dev.platform_data;
-	if (!pdata || ACPI_COMPANION(&client->dev))
-		pdata = gmin_camera_platform_data(&dev->sd,
-						  ATOMISP_INPUT_FORMAT_RAW_10,
-						  atomisp_bayer_order_grbg);
-
-	if (!pdata) {
-		v4l2_err(client, "No imx platform data\n");
-		ret = -EINVAL;
-		goto out_free;
+	if (client->dev.platform_data) {
+		ret = imx_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
 	}
-
-	ret = imx_s_config(&dev->sd, client->irq, pdata);
-	if (ret)
-		goto out_free;
-
 	imx_info = v4l2_get_subdev_hostdata(&dev->sd);
 
 	/*
 	 * sd->name is updated with sensor driver name by the v4l2.
 	 * change it to sensor name in this case.
 	 */
+	imx_update_reg_info(dev);
 	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s%x %d-%04x",
 		IMX_SUBDEV_PREFIX, dev->sensor_id,
 		i2c_adapter_id(client->adapter), client->addr);
@@ -2358,9 +2548,8 @@ static int imx_probe(struct i2c_client *client,
 	}
 
 	/* Load the Noise reduction, Dead pixel registers from cpf file*/
-	/* FIXME: msr_file_name needs to come from ACPI/EFI config too */
-	if (pdata->msr_file_name != NULL)
-		msr_file_name = pdata->msr_file_name();
+	if (dev->platform_data->msr_file_name != NULL)
+		msr_file_name = dev->platform_data->msr_file_name();
 	if (msr_file_name) {
 		ret = load_msr_list(client, msr_file_name, &dev->fw);
 		if (ret) {
@@ -2371,18 +2560,6 @@ static int imx_probe(struct i2c_client *client,
 		dev_warn(&client->dev, "Drvb file not present");
 	}
 
-	/* Register the atomisp platform data prior to the ISP module
-	 * load.  Ideally this would be stored as data on the
-	 * subdevices, but this API matches upstream better. */
-	/* FIXME: type and port need to come from ACPI/EFI config,
-	 * this is hard coded to FFRD8 */
-	ret = atomisp_register_i2c_module(&dev->sd, pdata, RAW_CAMERA);
-
-	if (ret) {
-		imx_remove(client);
-		return ret;
-	}
-
 	return ret;
 
 out_ctrl_handler_free:
@@ -2394,21 +2571,23 @@ out_free:
 	return ret;
 }
 
-MODULE_DEVICE_TABLE(i2c, imx_ids);
-
-static struct acpi_device_id imx_acpi_match[] = {
-	{ "INTCF1A" },
-	{ "INTCF1B" },
-	{},
+static const struct i2c_device_id imx_ids[] = {
+	{IMX_NAME_175, IMX175_ID},
+	{IMX_NAME_135, IMX135_ID},
+	{IMX_NAME_135_FUJI, IMX135_FUJI_ID},
+	{IMX_NAME_134, IMX134_ID},
+	{IMX_NAME_132, IMX132_ID},
+	{IMX_NAME_208, IMX208_ID},
+	{IMX_NAME_219, IMX219_ID},
+	{}
 };
 
-MODULE_DEVICE_TABLE(acpi, imx_acpi_match);
+MODULE_DEVICE_TABLE(i2c, imx_ids);
 
 static struct i2c_driver imx_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
 		.name = IMX_DRIVER,
-		.acpi_match_table = ACPI_PTR(imx_acpi_match),
 	},
 	.probe = imx_probe,
 	.remove = imx_remove,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
index 44b9a75..dd8f642 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
@@ -31,14 +31,18 @@
 #include <linux/videodev2.h>
 #include <linux/v4l2-mediabus.h>
 #include <media/media-entity.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-subdev.h>
 #include "imx175.h"
 #include "imx135.h"
-#include "imx135vb.h"
 #include "imx134.h"
 #include "imx132.h"
+#include "imx208.h"
+#include "imx219.h"
 
 #define IMX_MCLK		192
 
@@ -53,6 +57,7 @@
 #define IMX_MASK_5BIT	0x1F
 #define IMX_MASK_4BIT	0xF
 #define IMX_MASK_2BIT	0x3
+#define IMX_MASK_8BIT	0xFF
 #define IMX_MASK_11BIT	0x7FF
 #define IMX_INTG_BUF_COUNT		2
 
@@ -80,8 +85,18 @@
 #define IMX_HORIZONTAL_OUTPUT_SIZE_H 0x034c
 #define IMX_VERTICAL_OUTPUT_SIZE_H 0x034e
 
+/* Post Divider setting register for imx132 and imx208 */
+#define IMX132_208_VT_RGPLTD		0x30A4
+
+/* Multiplier setting register for imx132, imx208, and imx219 */
+#define IMX132_208_219_PLL_MULTIPLIER		0x0306
+
 #define IMX_COARSE_INTEGRATION_TIME		0x0202
 #define IMX_TEST_PATTERN_MODE			0x0600
+#define IMX_TEST_PATTERN_COLOR_R		0x0602
+#define IMX_TEST_PATTERN_COLOR_GR		0x0604
+#define IMX_TEST_PATTERN_COLOR_B		0x0606
+#define IMX_TEST_PATTERN_COLOR_GB		0x0608
 #define IMX_IMG_ORIENTATION			0x0101
 #define IMX_VFLIP_BIT			2
 #define IMX_HFLIP_BIT			1
@@ -104,10 +119,14 @@
 #define IMX_NAME_135	"imx135"
 #define IMX_NAME_175	"imx175"
 #define IMX_NAME_132	"imx132"
+#define IMX_NAME_208	"imx208"
+#define IMX_NAME_219	"imx219"
 #define IMX175_ID	0x0175
 #define IMX135_ID	0x0135
 #define IMX134_ID	0x0134
 #define IMX132_ID	0x0132
+#define IMX208_ID	0x0208
+#define IMX219_ID	0x0219
 
 /* Sensor id based on i2c_device_id table
  * (Fuji module can not be detected based on sensor registers) */
@@ -121,6 +140,8 @@
 #define IMX135_VICTORIABAY 0x136
 #define IMX132_SALTBAY 0x132
 #define IMX134_VALLEYVIEW 0x134
+#define IMX208_MOFD_PD2 0x208
+#define IMX219_MFV0_PRH 0x219
 
 /* otp - specific settings */
 #define E2PROM_ADDR 0xa0
@@ -128,10 +149,11 @@
 #define E2PROM_ABICO_SS89A839_ADDR 0xa8
 #define DEFAULT_OTP_SIZE 1280
 #define IMX135_OTP_SIZE 1280
+#define IMX219_OTP_SIZE 2048
 #define E2PROM_LITEON_12P1BA869D_SIZE 544
 
 #define IMX_ID_DEFAULT	0x0000
-#define IMX132_175_CHIP_ID	0x0000
+#define IMX132_175_208_219_CHIP_ID	0x0000
 #define IMX134_135_CHIP_ID	0x0016
 
 #define IMX175_RES_WIDTH_MAX	3280
@@ -142,6 +164,10 @@
 #define IMX132_RES_HEIGHT_MAX	1096
 #define IMX134_RES_WIDTH_MAX	3280
 #define IMX134_RES_HEIGHT_MAX	2464
+#define IMX208_RES_WIDTH_MAX	1936
+#define IMX208_RES_HEIGHT_MAX	1096
+#define IMX219_RES_WIDTH_MAX	3280
+#define IMX219_RES_HEIGHT_MAX	2464
 
 /* Defines for lens/VCM */
 #define IMX_FOCAL_LENGTH_NUM	369	/*3.69mm*/
@@ -220,6 +246,14 @@ struct max_res imx_max_res[] = {
 		.res_max_width = IMX134_RES_WIDTH_MAX,
 		.res_max_height = IMX134_RES_HEIGHT_MAX,
 	},
+	[IMX208_ID] = {
+		.res_max_width = IMX208_RES_WIDTH_MAX,
+		.res_max_height = IMX208_RES_HEIGHT_MAX,
+	},
+	[IMX219_ID] = {
+		.res_max_width = IMX219_RES_WIDTH_MAX,
+		.res_max_height = IMX219_RES_HEIGHT_MAX,
+	},
 };
 
 struct imx_settings {
@@ -261,13 +295,13 @@ struct imx_settings imx_sets[] = {
 		.n_res_video = ARRAY_SIZE(imx135_res_video),
 	},
 	[IMX135_VICTORIABAY] = {
-		.init_settings = imx135vb_init_settings,
-		.res_preview = imx135vb_res_preview,
-		.res_still = imx135vb_res_still,
-		.res_video = imx135vb_res_video,
-		.n_res_preview = ARRAY_SIZE(imx135vb_res_preview),
-		.n_res_still = ARRAY_SIZE(imx135vb_res_still),
-		.n_res_video = ARRAY_SIZE(imx135vb_res_video),
+		.init_settings = imx135_init_settings,
+		.res_preview = imx135_res_preview,
+		.res_still = imx135_res_still,
+		.res_video = imx135_res_video,
+		.n_res_preview = ARRAY_SIZE(imx135_res_preview),
+		.n_res_still = ARRAY_SIZE(imx135_res_still),
+		.n_res_video = ARRAY_SIZE(imx135_res_video),
 	},
 	[IMX132_SALTBAY] = {
 		.init_settings = imx132_init_settings,
@@ -287,6 +321,69 @@ struct imx_settings imx_sets[] = {
 		.n_res_still = ARRAY_SIZE(imx134_res_still),
 		.n_res_video = ARRAY_SIZE(imx134_res_video),
 	},
+	[IMX208_MOFD_PD2] = {
+		.init_settings = imx208_init_settings,
+		.res_preview = imx208_res_preview,
+		.res_still = imx208_res_still,
+		.res_video = imx208_res_video,
+		.n_res_preview = ARRAY_SIZE(imx208_res_preview),
+		.n_res_still = ARRAY_SIZE(imx208_res_still),
+		.n_res_video = ARRAY_SIZE(imx208_res_video),
+	},
+	[IMX219_MFV0_PRH] = {
+		.init_settings = imx219_init_settings,
+		.res_preview = imx219_res_preview,
+		.res_still = imx219_res_still,
+		.res_video = imx219_res_video,
+		.n_res_preview = ARRAY_SIZE(imx219_res_preview),
+		.n_res_still = ARRAY_SIZE(imx219_res_still),
+		.n_res_video = ARRAY_SIZE(imx219_res_video),
+	},
+};
+
+struct imx_reg_addr {
+	u16 frame_length_lines;
+	u16 line_length_pixels;
+	u16 horizontal_start_h;
+	u16 vertical_start_h;
+	u16 horizontal_end_h;
+	u16 vertical_end_h;
+	u16 horizontal_output_size_h;
+	u16 vertical_output_size_h;
+	u16 coarse_integration_time;
+	u16 img_orientation;
+	u16 global_gain;
+	u16 dgc_adj;
+};
+
+struct imx_reg_addr imx_addr = {
+	IMX_FRAME_LENGTH_LINES,
+	IMX_LINE_LENGTH_PIXELS,
+	IMX_HORIZONTAL_START_H,
+	IMX_VERTICAL_START_H,
+	IMX_HORIZONTAL_END_H,
+	IMX_VERTICAL_END_H,
+	IMX_HORIZONTAL_OUTPUT_SIZE_H,
+	IMX_VERTICAL_OUTPUT_SIZE_H,
+	IMX_COARSE_INTEGRATION_TIME,
+	IMX_IMG_ORIENTATION,
+	IMX_GLOBAL_GAIN,
+	IMX_DGC_ADJ,
+};
+
+struct imx_reg_addr imx219_addr = {
+	IMX219_FRAME_LENGTH_LINES,
+	IMX219_LINE_LENGTH_PIXELS,
+	IMX219_HORIZONTAL_START_H,
+	IMX219_VERTICAL_START_H,
+	IMX219_HORIZONTAL_END_H,
+	IMX219_VERTICAL_END_H,
+	IMX219_HORIZONTAL_OUTPUT_SIZE_H,
+	IMX219_VERTICAL_OUTPUT_SIZE_H,
+	IMX219_COARSE_INTEGRATION_TIME,
+	IMX219_IMG_ORIENTATION,
+	IMX219_GLOBAL_GAIN,
+	IMX219_DGC_ADJ,
 };
 
 #define	v4l2_format_capture_type_entry(_width, _height, \
@@ -319,67 +416,6 @@ struct imx_settings imx_sets[] = {
 		.reg_setting = (_reg_setting),\
 	}
 
-struct s_ctrl_id {
-	struct v4l2_queryctrl qc;
-	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
-	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
-};
-
-#define	v4l2_queryctrl_entry_integer(_id, _name,\
-		_minimum, _maximum, _step, \
-		_default_value, _flags)	\
-	{\
-		.id = (_id), \
-		.type = V4L2_CTRL_TYPE_INTEGER, \
-		.name = _name, \
-		.minimum = (_minimum), \
-		.maximum = (_maximum), \
-		.step = (_step), \
-		.default_value = (_default_value),\
-		.flags = (_flags),\
-	}
-#define	v4l2_queryctrl_entry_boolean(_id, _name,\
-		_default_value, _flags)	\
-	{\
-		.id = (_id), \
-		.type = V4L2_CTRL_TYPE_BOOLEAN, \
-		.name = _name, \
-		.minimum = 0, \
-		.maximum = 1, \
-		.step = 1, \
-		.default_value = (_default_value),\
-		.flags = (_flags),\
-	}
-
-#define	s_ctrl_id_entry_integer(_id, _name, \
-		_minimum, _maximum, _step, \
-		_default_value, _flags, \
-		_s_ctrl, _g_ctrl)	\
-	{\
-		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
-				_minimum, _maximum, _step,\
-				_default_value, _flags), \
-		.s_ctrl = _s_ctrl, \
-		.g_ctrl = _g_ctrl, \
-	}
-
-#define	s_ctrl_id_entry_boolean(_id, _name, \
-		_default_value, _flags, \
-		_s_ctrl, _g_ctrl)	\
-	{\
-		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
-				_default_value, _flags), \
-		.s_ctrl = _s_ctrl, \
-		.g_ctrl = _g_ctrl, \
-	}
-
-
-struct imx_control {
-	struct v4l2_queryctrl qc;
-	int (*query)(struct v4l2_subdev *sd, s32 *value);
-	int (*tweak)(struct v4l2_subdev *sd, s32 value);
-};
-
 /* imx device structure */
 struct imx_device {
 	struct v4l2_subdev sd;
@@ -403,6 +439,7 @@ struct imx_device {
 	u16 gain;
 	u16 pixels_per_line;
 	u16 lines_per_frame;
+	u8 targetfps;
 	u8 fps;
 	const struct imx_reg *regs;
 	u8 res;
@@ -415,6 +452,9 @@ struct imx_device {
 	const struct imx_resolution *curr_res_table;
 	int entries_curr_table;
 	const struct firmware *fw;
+	struct imx_reg_addr *reg_addr;
+	const struct imx_reg *param_hold;
+	const struct imx_reg *param_update;
 
 	/* used for h/b blank tuning */
 	struct v4l2_ctrl_handler ctrl_handler;
@@ -422,6 +462,15 @@ struct imx_device {
 	struct v4l2_ctrl *h_blank;
 	struct v4l2_ctrl *v_blank;
 	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *h_flip;
+	struct v4l2_ctrl *v_flip;
+
+	/* Test pattern control */
+	struct v4l2_ctrl *tp_mode;
+	struct v4l2_ctrl *tp_r;
+	struct v4l2_ctrl *tp_gr;
+	struct v4l2_ctrl *tp_gb;
+	struct v4l2_ctrl *tp_b;
 };
 
 #define to_imx_sensor(x) container_of(x, struct imx_device, sd)
@@ -457,6 +506,14 @@ static const struct imx_reg imx_param_update[] = {
 	{IMX_TOK_TERM, 0, 0}
 };
 
+static const struct imx_reg imx219_param_hold[] = {
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx219_param_update[] = {
+	{IMX_TOK_TERM, 0, 0}
+};
+
 extern int ad5816g_vcm_power_up(struct v4l2_subdev *sd);
 extern int ad5816g_vcm_power_down(struct v4l2_subdev *sd);
 extern int ad5816g_vcm_init(struct v4l2_subdev *sd);
@@ -505,6 +562,18 @@ extern int dw9719_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
 extern int dw9719_t_vcm_slew(struct v4l2_subdev *sd, s32 value);
 extern int dw9719_t_vcm_timing(struct v4l2_subdev *sd, s32 value);
 
+extern int dw9718_vcm_power_up(struct v4l2_subdev *sd);
+extern int dw9718_vcm_power_down(struct v4l2_subdev *sd);
+extern int dw9718_vcm_init(struct v4l2_subdev *sd);
+
+extern int dw9718_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+extern int dw9718_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+extern int dw9718_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+extern int dw9718_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+extern int dw9718_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+extern int dw9718_t_vcm_slew(struct v4l2_subdev *sd, s32 value);
+extern int dw9718_t_vcm_timing(struct v4l2_subdev *sd, s32 value);
+
 extern int vcm_power_up(struct v4l2_subdev *sd);
 extern int vcm_power_down(struct v4l2_subdev *sd);
 
@@ -569,6 +638,18 @@ struct imx_vcm imx_vcms[] = {
 		.t_vcm_slew = dw9714_t_vcm_slew,
 		.t_vcm_timing = dw9714_t_vcm_timing,
 	},
+	[IMX219_MFV0_PRH] = {
+		.power_up = dw9718_vcm_power_up,
+		.power_down = dw9718_vcm_power_down,
+		.init = dw9718_vcm_init,
+		.t_focus_vcm = dw9718_t_focus_vcm,
+		.t_focus_abs = dw9718_t_focus_abs,
+		.t_focus_rel = dw9718_t_focus_rel,
+		.q_focus_status = dw9718_q_focus_status,
+		.q_focus_abs = dw9718_q_focus_abs,
+		.t_vcm_slew = dw9718_t_vcm_slew,
+		.t_vcm_timing = dw9718_t_vcm_timing,
+	},
 	[IMX_ID_DEFAULT] = {
 		.power_up = vcm_power_up,
 		.power_down = vcm_power_down,
@@ -581,6 +662,8 @@ extern void *imx_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
 	u32 start_addr, u32 size);
 extern void *e2prom_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
 	u32 start_addr, u32 size);
+extern void *brcc064_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size);
 struct imx_otp imx_otps[] = {
 	[IMX175_MERRFLD] = {
 		.otp_read = imx_otp_read,
@@ -614,6 +697,16 @@ struct imx_otp imx_otps[] = {
 		.otp_read = dummy_otp_read,
 		.size = DEFAULT_OTP_SIZE,
 	},
+	[IMX208_MOFD_PD2] = {
+		.otp_read = dummy_otp_read,
+		.size = DEFAULT_OTP_SIZE,
+	},
+	[IMX219_MFV0_PRH] = {
+		.otp_read = brcc064_otp_read,
+		.dev_addr = E2PROM_ADDR,
+		.start_addr = 0,
+		.size = IMX219_OTP_SIZE,
+	},
 	[IMX_ID_DEFAULT] = {
 		.otp_read = dummy_otp_read,
 		.size = DEFAULT_OTP_SIZE,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h
index f950413..0f862ca 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h
@@ -24,13 +24,14 @@
 #include "common.h"
 
 /********************** registers define ********************************/
-#define IMX132_PLL_MULTIPLIER			0x0306
-#define IMX132_VT_RGPLTD			0x30A4
 #define IMX132_RGLANESEL			0x3301	/* Number of lanes */
 #define IMX132_RGLANESEL_1LANE			0x01
 #define IMX132_RGLANESEL_2LANES			0x00
 #define IMX132_RGLANESEL_4LANES			0x03
 
+#define IMX132_2LANES_GAINFACT			2096	/* 524/256 * 2^10 */
+#define IMX132_2LANES_GAINFACT_SHIFT		10
+
 /********************** settings for imx from vendor*********************/
 static struct imx_reg imx132_1080p_30fps[] = {
 	GROUPED_PARAMETER_HOLD_ENABLE,
@@ -122,18 +123,6 @@ static struct imx_reg imx132_1080p_30fps[] = {
 	{IMX_8BIT, 0x3322, 0x09},
 	{IMX_8BIT, 0x3342, 0x00},
 	{IMX_8BIT, 0x3348, 0xE0},
-	/* Gain Setting */
-	{IMX_8BIT, 0x0202, 0x04},
-	{IMX_8BIT, 0x0203, 0x50},
-	{IMX_8BIT, 0x0205, 0x00},
-	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
-	{IMX_8BIT, 0x020F, 0x00},
-	{IMX_8BIT, 0x0210, 0x01}, /* R */
-	{IMX_8BIT, 0x0211, 0xA0},
-	{IMX_8BIT, 0x0212, 0x02}, /* B */
-	{IMX_8BIT, 0x0213, 0x00},
-	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
-	{IMX_8BIT, 0x0215, 0x00},
 
 	{IMX_TOK_TERM, 0, 0},
 };
@@ -228,18 +217,6 @@ static struct imx_reg imx132_1456x1096_30fps[] = {
 	{IMX_8BIT, 0x3322, 0x09},
 	{IMX_8BIT, 0x3342, 0x00},
 	{IMX_8BIT, 0x3348, 0xE0},
-	/* Gain Setting */
-	{IMX_8BIT, 0x0202, 0x04},
-	{IMX_8BIT, 0x0203, 0x50},
-	{IMX_8BIT, 0x0205, 0x00},
-	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
-	{IMX_8BIT, 0x020F, 0x00},
-	{IMX_8BIT, 0x0210, 0x01}, /* R */
-	{IMX_8BIT, 0x0211, 0xA0},
-	{IMX_8BIT, 0x0212, 0x02}, /* B */
-	{IMX_8BIT, 0x0213, 0x00},
-	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
-	{IMX_8BIT, 0x0215, 0x00},
 
 	{IMX_TOK_TERM, 0, 0},
 };
@@ -334,18 +311,6 @@ static struct imx_reg imx132_1636x1096_30fps[] = {
 	{IMX_8BIT, 0x3322, 0x09},
 	{IMX_8BIT, 0x3342, 0x00},
 	{IMX_8BIT, 0x3348, 0xE0},
-	/* Gain Setting */
-	{IMX_8BIT, 0x0202, 0x04},
-	{IMX_8BIT, 0x0203, 0x50},
-	{IMX_8BIT, 0x0205, 0x00},
-	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
-	{IMX_8BIT, 0x020F, 0x00},
-	{IMX_8BIT, 0x0210, 0x01}, /* R */
-	{IMX_8BIT, 0x0211, 0xA0},
-	{IMX_8BIT, 0x0212, 0x02}, /* B */
-	{IMX_8BIT, 0x0213, 0x00},
-	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
-	{IMX_8BIT, 0x0215, 0x00},
 
 	{IMX_TOK_TERM, 0, 0},
 };
@@ -440,18 +405,6 @@ static struct imx_reg imx132_1336x1096_30fps[] = {
 	{IMX_8BIT, 0x3322, 0x09},
 	{IMX_8BIT, 0x3342, 0x00},
 	{IMX_8BIT, 0x3348, 0xE0},
-	/* Gain Setting */
-	{IMX_8BIT, 0x0202, 0x04},
-	{IMX_8BIT, 0x0203, 0x50},
-	{IMX_8BIT, 0x0205, 0x00},
-	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
-	{IMX_8BIT, 0x020F, 0x00},
-	{IMX_8BIT, 0x0210, 0x01}, /* R */
-	{IMX_8BIT, 0x0211, 0xA0},
-	{IMX_8BIT, 0x0212, 0x02}, /* B */
-	{IMX_8BIT, 0x0213, 0x00},
-	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
-	{IMX_8BIT, 0x0215, 0x00},
 
 	{IMX_TOK_TERM, 0, 0},
 };
@@ -546,18 +499,6 @@ static struct imx_reg imx132_1200p_30fps[] = {
 	{IMX_8BIT, 0x3322, 0x09},
 	{IMX_8BIT, 0x3342, 0x00},
 	{IMX_8BIT, 0x3348, 0xE0},
-	/* Gain Setting */
-	{IMX_8BIT, 0x0202, 0x04},
-	{IMX_8BIT, 0x0203, 0x50},
-	{IMX_8BIT, 0x0205, 0x00},
-	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
-	{IMX_8BIT, 0x020F, 0x00},
-	{IMX_8BIT, 0x0210, 0x01}, /* R */
-	{IMX_8BIT, 0x0211, 0xA0},
-	{IMX_8BIT, 0x0212, 0x02}, /* B */
-	{IMX_8BIT, 0x0213, 0x00},
-	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
-	{IMX_8BIT, 0x0215, 0x00},
 
 	{IMX_TOK_TERM, 0, 0},
 };
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
index 29323b3b..e906d09 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
@@ -2066,6 +2066,25 @@ struct imx_resolution imx134_res_video[] = {
 		.bin_factor_y = 0,
 		.used = 0,
 	},
+	{
+		/*This setting only be used for SDV mode*/
+		.desc = "imx134_8M_sdv_30fps",
+		.regs = imx134_8M_30fps,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
 };
 
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h
index c58e6a6..f407dc4 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h
@@ -51,6 +51,9 @@
 #define GROUPED_PARAMETER_HOLD_ENABLE  {IMX_8BIT, 0x0104, 0x1}
 #define GROUPED_PARAMETER_HOLD_DISABLE  {IMX_8BIT, 0x0104, 0x0}
 
+#define IMX135_EMBEDDED_DATA_LINE_NUM 2
+#define IMX135_OUTPUT_DATA_FORMAT_REG  0x0112
+#define IMX135_OUTPUT_FORMAT_RAW10  0x0a0a
 /*
  * We use three different MIPI rates for our modes based on the resolution and
  * FPS requirements. So we have three PLL configurationa and these are based
@@ -992,63 +995,6 @@ static struct imx_reg const imx135_1m[] = {
 	{IMX_TOK_TERM, 0, 0},
 };
 
-static struct imx_reg const imx135_976x736[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
-	/* mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x01},
-	{IMX_8BIT, 0x0391, 0x22},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x21},
-	{IMX_8BIT, 0x4082, 0x00},
-	{IMX_8BIT, 0x4083, 0x00},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00},
-	{IMX_8BIT, 0x0345, 0x58},
-	{IMX_8BIT, 0x0346, 0x00},
-	{IMX_8BIT, 0x0347, 0x28},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x17},
-	{IMX_8BIT, 0x034A, 0x0C},
-	{IMX_8BIT, 0x034B, 0x07}, /* 88,40  4119,3079  4032,3040*/
-	{IMX_8BIT, 0x034C, 0x03}, /* 976x736 */
-	{IMX_8BIT, 0x034D, 0xD0},
-	{IMX_8BIT, 0x034E, 0x02},
-	{IMX_8BIT, 0x034F, 0xE0},
-	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x07}, /* 2016,1520 */
-	{IMX_8BIT, 0x0355, 0xE0},
-	{IMX_8BIT, 0x0356, 0x05},
-	{IMX_8BIT, 0x0357, 0xF0},
-	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
-	{IMX_8BIT, 0x3310, 0x03},
-	{IMX_8BIT, 0x3311, 0xD0},
-	{IMX_8BIT, 0x3312, 0x02},
-	{IMX_8BIT, 0x3313, 0xE0},
-	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
-	{IMX_8BIT, 0x331D, 0x4E},
-	{IMX_8BIT, 0x4084, 0x03}, /* Scaling related? */
-	{IMX_8BIT, 0x4085, 0xD0},
-	{IMX_8BIT, 0x4086, 0x02},
-	{IMX_8BIT, 0x4087, 0xE0},
-	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
-	{IMX_TOK_TERM, 0, 0},
-};
-
 static struct imx_reg const imx135_3m_binning[] = {
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
@@ -2030,44 +1976,6 @@ struct imx_resolution imx135_res_preview[] = {
 		.mipi_freq = 209600,
 	},
 	{
-		.desc = "imx135_976x736_preview",
-		.regs = imx135_976x736,
-		.width = 976,
-		.height = 736,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.used = 0,
-		.mipi_freq = 209600,
-	},
-	{
-		.desc = "imx135_1m_preview",
-		.regs = imx135_1m,
-		.width = 1040,
-		.height = 784,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.used = 0,
-		.mipi_freq = 209600,
-	},
-	{
 		.desc = "imx135_1080p_binning_preview",
 		.regs = imx135_1080p_binning,
 		.width = 1936,
@@ -2576,6 +2484,25 @@ struct imx_resolution imx135_res_video[] = {
 		.mipi_freq = 451200,
 	},
 	{
+		.desc = "imx135_6m_cont_cap",
+		.regs = imx135_6m,
+		.width = 3280,
+		.height = 1852,
+		.fps_options = {
+			{ /* Binning Pixel clock: 360.96MHz */
+				.fps = 30,
+				.pixels_per_line = 4572,
+				.lines_per_frame = 2624,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 451200,
+	},
+	{
 		.desc = "imx135_8m_cropped_video",
 		.regs = imx135_8m_cropped,
 		.width = 3280,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h
deleted file mode 100644
index cd0e9e4..0000000
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h
+++ /dev/null
@@ -1,1889 +0,0 @@
-/*
- * Support for Sony IMX camera sensor.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __IMX135VB_H__
-#define __IMX135VB_H__
-
-#include "common.h"
-
-#define IMX_SC_CMMN_CHIP_ID_H	0x0016
-#define IMX_SC_CMMN_CHIP_ID_L	0x0017
-
-/*
- * focal length bits definition:
- * bits 31-16: numerator, bits 15-0: denominator
- */
-#define IMX_FOCAL_LENGTH_DEFAULT 0x1710064
-
-/*
- * current f-number bits definition:
- * bits 31-16: numerator, bits 15-0: denominator
- */
-#define IMX_F_NUMBER_DEFAULT 0x16000a
-
-/*
- * f-number range bits definition:
- * bits 31-24: max f-number numerator
- * bits 23-16: max f-number denominator
- * bits 15-8: min f-number numerator
- * bits 7-0: min f-number denominator
- */
-#define IMX_F_NUMBER_RANGE 0x160a160a
-
-#define GROUPED_PARAMETER_HOLD_ENABLE  {IMX_8BIT, 0x0104, 0x1}
-#define GROUPED_PARAMETER_HOLD_DISABLE  {IMX_8BIT, 0x0104, 0x0}
-
-/*
- * We use three different MIPI rates for our modes based on the resolution and
- * FPS requirements. So we have three PLL configurationa and these are based
- * on the EMC friendly MIPI values.
- *
- * Maximum clock: Pix clock @ 360.96MHz MIPI @ 451.2MHz 902.4mbps
- * Reduced clock: Pix clock @ 273.00MHz MIPI @ 342.0MHz 684.0mbps
- * Binning modes: Pix clock @ 335.36MHz MIPI @ 209.6MHz 419.2mbps
- * Global Timing registers are based on the data rates and these are part of
- * the below clock definitions.
- */
-
-/* MIPI 451.2MHz 902.4mbps PIXCLK: 360.96MHz */
-#define PLL_SETTINGS_FOR_MIPI_451_2MHZ \
-	{IMX_8BIT, 0x011e, 0x13}, \
-	{IMX_8BIT, 0x011f, 0x33}, \
-	{IMX_8BIT, 0x0301, 0x05}, \
-	{IMX_8BIT, 0x0303, 0x01}, \
-	{IMX_8BIT, 0x0305, 0x0c}, \
-	{IMX_8BIT, 0x0309, 0x05}, \
-	{IMX_8BIT, 0x030b, 0x01}, \
-	{IMX_8BIT, 0x030c, 0x02}, \
-	{IMX_8BIT, 0x030d, 0x34}, \
-	{IMX_8BIT, 0x030e, 0x01}, \
-	{IMX_8BIT, 0x3a06, 0x11}, \
-	{IMX_8BIT, 0x0830, 0x7f}, \
-	{IMX_8BIT, 0x0831, 0x37}, \
-	{IMX_8BIT, 0x0832, 0x67}, \
-	{IMX_8BIT, 0x0833, 0x3f}, \
-	{IMX_8BIT, 0x0834, 0x3f}, \
-	{IMX_8BIT, 0x0835, 0x47}, \
-	{IMX_8BIT, 0x0836, 0xdf}, \
-	{IMX_8BIT, 0x0837, 0x47}, \
-	{IMX_8BIT, 0x0839, 0x1f}, \
-	{IMX_8BIT, 0x083a, 0x17}, \
-	{IMX_8BIT, 0x083b, 0x02}
-
-/* MIPI 209.6MHz, 419.2mbps PIXCLK: 335.36 MHz */
-#define PLL_SETTINGS_FOR_MIPI_209_6MHZ \
-	{IMX_8BIT, 0x011e, 0x13}, \
-	{IMX_8BIT, 0x011f, 0x33}, \
-	{IMX_8BIT, 0x0301, 0x05}, \
-	{IMX_8BIT, 0x0303, 0x01}, \
-	{IMX_8BIT, 0x0305, 0x06}, \
-	{IMX_8BIT, 0x0309, 0x05}, \
-	{IMX_8BIT, 0x030b, 0x02}, \
-	{IMX_8BIT, 0x030c, 0x01}, \
-	{IMX_8BIT, 0x030d, 0x06}, \
-	{IMX_8BIT, 0x030e, 0x01}, \
-	{IMX_8BIT, 0x3a06, 0x12}, \
-	{IMX_8BIT, 0x0830, 0x5f}, \
-	{IMX_8BIT, 0x0831, 0x1f}, \
-	{IMX_8BIT, 0x0832, 0x3f}, \
-	{IMX_8BIT, 0x0833, 0x1f}, \
-	{IMX_8BIT, 0x0834, 0x1f}, \
-	{IMX_8BIT, 0x0835, 0x17}, \
-	{IMX_8BIT, 0x0836, 0x67}, \
-	{IMX_8BIT, 0x0837, 0x27}, \
-	{IMX_8BIT, 0x0839, 0x1f}, \
-	{IMX_8BIT, 0x083a, 0x17}, \
-	{IMX_8BIT, 0x083b, 0x02}
-
-/* MIPI 342MHz 684mbps PIXCLK: 273.6MHz */
-#define PLL_SETTINGS_FOR_MIPI_342MHZ \
-	{IMX_8BIT, 0x011e, 0x13}, \
-	{IMX_8BIT, 0x011f, 0x33}, \
-	{IMX_8BIT, 0x0301, 0x05}, \
-	{IMX_8BIT, 0x0303, 0x01}, \
-	{IMX_8BIT, 0x0305, 0x08}, \
-	{IMX_8BIT, 0x0309, 0x05}, \
-	{IMX_8BIT, 0x030b, 0x01}, \
-	{IMX_8BIT, 0x030c, 0x01}, \
-	{IMX_8BIT, 0x030d, 0x1d}, \
-	{IMX_8BIT, 0x030e, 0x01}, \
-	{IMX_8BIT, 0x3a06, 0x11}, \
-	{IMX_8BIT, 0x0830, 0x77}, \
-	{IMX_8BIT, 0x0831, 0x2f}, \
-	{IMX_8BIT, 0x0832, 0x4f}, \
-	{IMX_8BIT, 0x0833, 0x37}, \
-	{IMX_8BIT, 0x0834, 0x2f}, \
-	{IMX_8BIT, 0x0835, 0x37}, \
-	{IMX_8BIT, 0x0836, 0xa7}, \
-	{IMX_8BIT, 0x0837, 0x37}, \
-	{IMX_8BIT, 0x0839, 0x1f}, \
-	{IMX_8BIT, 0x083a, 0x17}, \
-	{IMX_8BIT, 0x083b, 0x02}
-
-/* Basic settings: Applied only once after the sensor power up */
-static struct imx_reg const imx135vb_init_settings[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	{ IMX_8BIT, 0x0220, 0x01},
-	{ IMX_8BIT, 0x3008, 0xB0},
-	{ IMX_8BIT, 0x320A, 0x01},
-	{ IMX_8BIT, 0x320D, 0x10},
-	{ IMX_8BIT, 0x3216, 0x2E},
-	{ IMX_8BIT, 0x3230, 0x0A},
-	{ IMX_8BIT, 0x3228, 0x05},
-	{ IMX_8BIT, 0x3229, 0x02},
-	{ IMX_8BIT, 0x322C, 0x02},
-	{ IMX_8BIT, 0x3302, 0x10},
-	{ IMX_8BIT, 0x3390, 0x45},
-	{ IMX_8BIT, 0x3409, 0x0C},
-	{ IMX_8BIT, 0x340B, 0xF5},
-	{ IMX_8BIT, 0x340C, 0x2D},
-	{ IMX_8BIT, 0x3412, 0x41},
-	{ IMX_8BIT, 0x3413, 0xAD},
-	{ IMX_8BIT, 0x3414, 0x1E},
-	{ IMX_8BIT, 0x3427, 0x04},
-	{ IMX_8BIT, 0x3480, 0x1E},
-	{ IMX_8BIT, 0x3484, 0x1E},
-	{ IMX_8BIT, 0x3488, 0x1E},
-	{ IMX_8BIT, 0x348C, 0x1E},
-	{ IMX_8BIT, 0x3490, 0x1E},
-	{ IMX_8BIT, 0x3494, 0x1E},
-	{ IMX_8BIT, 0x349C, 0x38},
-	{ IMX_8BIT, 0x34A3, 0x38},
-	{ IMX_8BIT, 0x3511, 0x8F},
-	{ IMX_8BIT, 0x3518, 0x00},
-	{ IMX_8BIT, 0x3519, 0x94},
-	{ IMX_8BIT, 0x3833, 0x20},
-	{ IMX_8BIT, 0x3893, 0x01},
-	{ IMX_8BIT, 0x38C2, 0x08},
-	{ IMX_8BIT, 0x38C3, 0x08},
-	{ IMX_8BIT, 0x3C09, 0x01},
-	{ IMX_8BIT, 0x4000, 0x0E},
-	{ IMX_8BIT, 0x4300, 0x00},
-	{ IMX_8BIT, 0x4316, 0x12},
-	{ IMX_8BIT, 0x4317, 0x22},
-	{ IMX_8BIT, 0x4318, 0x00},
-	{ IMX_8BIT, 0x4319, 0x00},
-	{ IMX_8BIT, 0x431A, 0x00},
-	{ IMX_8BIT, 0x4324, 0x03},
-	{ IMX_8BIT, 0x4325, 0x20},
-	{ IMX_8BIT, 0x4326, 0x03},
-	{ IMX_8BIT, 0x4327, 0x84},
-	{ IMX_8BIT, 0x4328, 0x03},
-	{ IMX_8BIT, 0x4329, 0x20},
-	{ IMX_8BIT, 0x432A, 0x03},
-	{ IMX_8BIT, 0x432B, 0x84},
-	{ IMX_8BIT, 0x432C, 0x01},
-	{ IMX_8BIT, 0x4401, 0x3F},
-	{ IMX_8BIT, 0x4402, 0xFF},
-	{ IMX_8BIT, 0x4412, 0x3F},
-	{ IMX_8BIT, 0x4413, 0xFF},
-	{ IMX_8BIT, 0x441D, 0x28},
-	{ IMX_8BIT, 0x4444, 0x00},
-	{ IMX_8BIT, 0x4445, 0x00},
-	{ IMX_8BIT, 0x4446, 0x3F},
-	{ IMX_8BIT, 0x4447, 0xFF},
-	{ IMX_8BIT, 0x4452, 0x00},
-	{ IMX_8BIT, 0x4453, 0xA0},
-	{ IMX_8BIT, 0x4454, 0x08},
-	{ IMX_8BIT, 0x4455, 0x00},
-	{ IMX_8BIT, 0x4458, 0x18},
-	{ IMX_8BIT, 0x4459, 0x18},
-	{ IMX_8BIT, 0x445A, 0x3F},
-	{ IMX_8BIT, 0x445B, 0x3A},
-	{ IMX_8BIT, 0x4462, 0x00},
-	{ IMX_8BIT, 0x4463, 0x00},
-	{ IMX_8BIT, 0x4464, 0x00},
-	{ IMX_8BIT, 0x4465, 0x00},
-	{ IMX_8BIT, 0x446E, 0x01},
-	{ IMX_8BIT, 0x4500, 0x1F},
-	{ IMX_8BIT, 0x600a, 0x00},
-	{ IMX_8BIT, 0x380a, 0x00},
-	{ IMX_8BIT, 0x380b, 0x00},
-	{ IMX_8BIT, 0x4103, 0x00},
-	{ IMX_8BIT, 0x4243, 0x9a},
-	{ IMX_8BIT, 0x4330, 0x01},
-	{ IMX_8BIT, 0x4331, 0x90},
-	{ IMX_8BIT, 0x4332, 0x02},
-	{ IMX_8BIT, 0x4333, 0x58},
-	{ IMX_8BIT, 0x4334, 0x03},
-	{ IMX_8BIT, 0x4335, 0x20},
-	{ IMX_8BIT, 0x4336, 0x03},
-	{ IMX_8BIT, 0x4337, 0x84},
-	{ IMX_8BIT, 0x433C, 0x01},
-	{ IMX_8BIT, 0x4340, 0x02},
-	{ IMX_8BIT, 0x4341, 0x58},
-	{ IMX_8BIT, 0x4342, 0x03},
-	{ IMX_8BIT, 0x4343, 0x52},
-	{ IMX_8BIT, 0x4364, 0x0b},
-	{ IMX_8BIT, 0x4368, 0x00},
-	{ IMX_8BIT, 0x4369, 0x0f},
-	{ IMX_8BIT, 0x436a, 0x03},
-	{ IMX_8BIT, 0x436b, 0xa8},
-	{ IMX_8BIT, 0x436c, 0x00},
-	{ IMX_8BIT, 0x436d, 0x00},
-	{ IMX_8BIT, 0x436e, 0x00},
-	{ IMX_8BIT, 0x436f, 0x06},
-	{ IMX_8BIT, 0x4281, 0x21},
-	{ IMX_8BIT, 0x4282, 0x18},
-	{ IMX_8BIT, 0x4283, 0x04},
-	{ IMX_8BIT, 0x4284, 0x08},
-	{ IMX_8BIT, 0x4287, 0x7f},
-	{ IMX_8BIT, 0x4288, 0x08},
-	{ IMX_8BIT, 0x428b, 0x7f},
-	{ IMX_8BIT, 0x428c, 0x08},
-	{ IMX_8BIT, 0x428f, 0x7f},
-	{ IMX_8BIT, 0x4297, 0x00},
-	{ IMX_8BIT, 0x4298, 0x7E},
-	{ IMX_8BIT, 0x4299, 0x7E},
-	{ IMX_8BIT, 0x429A, 0x7E},
-	{ IMX_8BIT, 0x42A4, 0xFB},
-	{ IMX_8BIT, 0x42A5, 0x7E},
-	{ IMX_8BIT, 0x42A6, 0xDF},
-	{ IMX_8BIT, 0x42A7, 0xB7},
-	{ IMX_8BIT, 0x42AF, 0x03},
-	{ IMX_8BIT, 0x4207, 0x03},
-	{ IMX_8BIT, 0x4216, 0x08},
-	{ IMX_8BIT, 0x4217, 0x08},
-	{ IMX_8BIT, 0x4218, 0x00},
-	{ IMX_8BIT, 0x421B, 0x20},
-	{ IMX_8BIT, 0x421F, 0x04},
-	{ IMX_8BIT, 0x4222, 0x02},
-	{ IMX_8BIT, 0x4223, 0x22},
-	{ IMX_8BIT, 0x422E, 0x54},
-	{ IMX_8BIT, 0x422F, 0xFB},
-	{ IMX_8BIT, 0x4230, 0xFF},
-	{ IMX_8BIT, 0x4231, 0xFE},
-	{ IMX_8BIT, 0x4232, 0xFF},
-	{ IMX_8BIT, 0x4235, 0x58},
-	{ IMX_8BIT, 0x4236, 0xF7},
-	{ IMX_8BIT, 0x4237, 0xFD},
-	{ IMX_8BIT, 0x4239, 0x4E},
-	{ IMX_8BIT, 0x423A, 0xFC},
-	{ IMX_8BIT, 0x423B, 0xFD},
-	{ IMX_8BIT, 0x4300, 0x00},
-	{ IMX_8BIT, 0x4316, 0x12},
-	{ IMX_8BIT, 0x4317, 0x22},
-	{ IMX_8BIT, 0x4318, 0x00},
-	{ IMX_8BIT, 0x4319, 0x00},
-	{ IMX_8BIT, 0x431A, 0x00},
-	{ IMX_8BIT, 0x4324, 0x03},
-	{ IMX_8BIT, 0x4325, 0x20},
-	{ IMX_8BIT, 0x4326, 0x03},
-	{ IMX_8BIT, 0x4327, 0x84},
-	{ IMX_8BIT, 0x4328, 0x03},
-	{ IMX_8BIT, 0x4329, 0x20},
-	{ IMX_8BIT, 0x432A, 0x03},
-	{ IMX_8BIT, 0x432B, 0x20},
-	{ IMX_8BIT, 0x432C, 0x01},
-	{ IMX_8BIT, 0x432D, 0x01},
-	{ IMX_8BIT, 0x4338, 0x02},
-	{ IMX_8BIT, 0x4339, 0x00},
-	{ IMX_8BIT, 0x433A, 0x00},
-	{ IMX_8BIT, 0x433B, 0x02},
-	{ IMX_8BIT, 0x435A, 0x03},
-	{ IMX_8BIT, 0x435B, 0x84},
-	{ IMX_8BIT, 0x435E, 0x01},
-	{ IMX_8BIT, 0x435F, 0xFF},
-	{ IMX_8BIT, 0x4360, 0x01},
-	{ IMX_8BIT, 0x4361, 0xF4},
-	{ IMX_8BIT, 0x4362, 0x03},
-	{ IMX_8BIT, 0x4363, 0x84},
-	{ IMX_8BIT, 0x437B, 0x01},
-	{ IMX_8BIT, 0x4400, 0x00}, /* STATS off ISP do not support STATS*/
-	{ IMX_8BIT, 0x4401, 0x3F},
-	{ IMX_8BIT, 0x4402, 0xFF},
-	{ IMX_8BIT, 0x4404, 0x13},
-	{ IMX_8BIT, 0x4405, 0x26},
-	{ IMX_8BIT, 0x4406, 0x07},
-	{ IMX_8BIT, 0x4408, 0x20},
-	{ IMX_8BIT, 0x4409, 0xE5},
-	{ IMX_8BIT, 0x440A, 0xFB},
-	{ IMX_8BIT, 0x440C, 0xF6},
-	{ IMX_8BIT, 0x440D, 0xEA},
-	{ IMX_8BIT, 0x440E, 0x20},
-	{ IMX_8BIT, 0x4410, 0x00},
-	{ IMX_8BIT, 0x4411, 0x00},
-	{ IMX_8BIT, 0x4412, 0x3F},
-	{ IMX_8BIT, 0x4413, 0xFF},
-	{ IMX_8BIT, 0x4414, 0x1F},
-	{ IMX_8BIT, 0x4415, 0xFF},
-	{ IMX_8BIT, 0x4416, 0x20},
-	{ IMX_8BIT, 0x4417, 0x00},
-	{ IMX_8BIT, 0x4418, 0x1F},
-	{ IMX_8BIT, 0x4419, 0xFF},
-	{ IMX_8BIT, 0x441A, 0x20},
-	{ IMX_8BIT, 0x441B, 0x00},
-	{ IMX_8BIT, 0x441D, 0x40},
-	{ IMX_8BIT, 0x441E, 0x1E},
-	{ IMX_8BIT, 0x441F, 0x38},
-	{ IMX_8BIT, 0x4420, 0x01},
-	{ IMX_8BIT, 0x4444, 0x00},
-	{ IMX_8BIT, 0x4445, 0x00},
-	{ IMX_8BIT, 0x4446, 0x1D},
-	{ IMX_8BIT, 0x4447, 0xF9},
-	{ IMX_8BIT, 0x4452, 0x00},
-	{ IMX_8BIT, 0x4453, 0xA0},
-	{ IMX_8BIT, 0x4454, 0x08},
-	{ IMX_8BIT, 0x4455, 0x00},
-	{ IMX_8BIT, 0x4456, 0x0F},
-	{ IMX_8BIT, 0x4457, 0xFF},
-	{ IMX_8BIT, 0x4458, 0x18},
-	{ IMX_8BIT, 0x4459, 0x18},
-	{ IMX_8BIT, 0x445A, 0x3F},
-	{ IMX_8BIT, 0x445B, 0x3A},
-	{ IMX_8BIT, 0x445C, 0x00},
-	{ IMX_8BIT, 0x445D, 0x28},
-	{ IMX_8BIT, 0x445E, 0x01},
-	{ IMX_8BIT, 0x445F, 0x90},
-	{ IMX_8BIT, 0x4460, 0x00},
-	{ IMX_8BIT, 0x4461, 0x60},
-	{ IMX_8BIT, 0x4462, 0x00},
-	{ IMX_8BIT, 0x4463, 0x00},
-	{ IMX_8BIT, 0x4464, 0x00},
-	{ IMX_8BIT, 0x4465, 0x00},
-	{ IMX_8BIT, 0x446C, 0x00},
-	{ IMX_8BIT, 0x446D, 0x00},
-	{ IMX_8BIT, 0x446E, 0x00},
-	{ IMX_8BIT, 0x452A, 0x02},
-	{ IMX_8BIT, 0x0712, 0x01},
-	{ IMX_8BIT, 0x0713, 0x00},
-	{ IMX_8BIT, 0x0714, 0x01},
-	{ IMX_8BIT, 0x0715, 0x00},
-	{ IMX_8BIT, 0x0716, 0x01},
-	{ IMX_8BIT, 0x0717, 0x00},
-	{ IMX_8BIT, 0x0718, 0x01},
-	{ IMX_8BIT, 0x0719, 0x00},
-	{ IMX_8BIT, 0x4500, 0x1F },
-	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
-	{ IMX_8BIT, 0x0205, 0x00},
-	{ IMX_8BIT, 0x020E, 0x01},
-	{ IMX_8BIT, 0x020F, 0x00},
-	{ IMX_8BIT, 0x0210, 0x02},
-	{ IMX_8BIT, 0x0211, 0x00},
-	{ IMX_8BIT, 0x0212, 0x02},
-	{ IMX_8BIT, 0x0213, 0x00},
-	{ IMX_8BIT, 0x0214, 0x01},
-	{ IMX_8BIT, 0x0215, 0x00},
-	/* HDR Setting */
-	{ IMX_8BIT, 0x0230, 0x00},
-	{ IMX_8BIT, 0x0231, 0x00},
-	{ IMX_8BIT, 0x0233, 0x00},
-	{ IMX_8BIT, 0x0234, 0x00},
-	{ IMX_8BIT, 0x0235, 0x40},
-	{ IMX_8BIT, 0x0238, 0x00},
-	{ IMX_8BIT, 0x0239, 0x04},
-	{ IMX_8BIT, 0x023B, 0x00},
-	{ IMX_8BIT, 0x023C, 0x01},
-	{ IMX_8BIT, 0x33B0, 0x04},
-	{ IMX_8BIT, 0x33B1, 0x00},
-	{ IMX_8BIT, 0x33B3, 0x00},
-	{ IMX_8BIT, 0x33B4, 0x01},
-	{ IMX_8BIT, 0x3800, 0x00},
-	GROUPED_PARAMETER_HOLD_DISABLE,
-	{ IMX_TOK_TERM, 0, 0}
-};
-
-/********* Preview, continuous capture and still modes *****************/
-
-static struct imx_reg const imx135vb_13m[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x00},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x10},
-	{IMX_8BIT, 0x4082, 0x01},
-	{IMX_8BIT, 0x4083, 0x01},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size Setting */
-	{IMX_8BIT, 0x0344, 0x00}, /* 0, 0, 4207,3119 4208x3120 */
-	{IMX_8BIT, 0x0345, 0x00},
-	{IMX_8BIT, 0x0346, 0x00},
-	{IMX_8BIT, 0x0347, 0x00},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x6F},
-	{IMX_8BIT, 0x034A, 0x0C},
-	{IMX_8BIT, 0x034B, 0x2F},
-	{IMX_8BIT, 0x034C, 0x10},
-	{IMX_8BIT, 0x034D, 0x70},
-	{IMX_8BIT, 0x034E, 0x0C},
-	{IMX_8BIT, 0x034F, 0x30},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10}, /* 4208x3120 */
-	{IMX_8BIT, 0x0355, 0x70},
-	{IMX_8BIT, 0x0356, 0x0C},
-	{IMX_8BIT, 0x0357, 0x30},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x10},
-	{IMX_8BIT, 0x3311, 0x70},
-	{IMX_8BIT, 0x3312, 0x0C},
-	{IMX_8BIT, 0x3313, 0x30},
-	{IMX_8BIT, 0x331C, 0x00},
-	{IMX_8BIT, 0x331D, 0x10},
-	{IMX_8BIT, 0x4084, 0x00}, /* If scaling, Fill this */
-	{IMX_8BIT, 0x4085, 0x00},
-	{IMX_8BIT, 0x4086, 0x00},
-	{IMX_8BIT, 0x4087, 0x00},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-/* 13MP reduced pixel clock MIPI 342MHz is EMC friendly*/
-static struct imx_reg const imx135vb_13m_for_mipi_342[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_342MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x00},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x10},
-	{IMX_8BIT, 0x4082, 0x01},
-	{IMX_8BIT, 0x4083, 0x01},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size Setting */
-	{IMX_8BIT, 0x0344, 0x00},
-	{IMX_8BIT, 0x0345, 0x00},
-	{IMX_8BIT, 0x0346, 0x00},
-	{IMX_8BIT, 0x0347, 0x00},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x6F},
-	{IMX_8BIT, 0x034A, 0x0C},
-	{IMX_8BIT, 0x034B, 0x2F},
-	{IMX_8BIT, 0x034C, 0x10},
-	{IMX_8BIT, 0x034D, 0x70},
-	{IMX_8BIT, 0x034E, 0x0C},
-	{IMX_8BIT, 0x034F, 0x30},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10},
-	{IMX_8BIT, 0x0355, 0x70},
-	{IMX_8BIT, 0x0356, 0x0C},
-	{IMX_8BIT, 0x0357, 0x30},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x10},
-	{IMX_8BIT, 0x3311, 0x70},
-	{IMX_8BIT, 0x3312, 0x0C},
-	{IMX_8BIT, 0x3313, 0x30},
-	{IMX_8BIT, 0x331C, 0x00},
-	{IMX_8BIT, 0x331D, 0x10},
-	{IMX_8BIT, 0x4084, 0x00}, /* If scaling, Fill this */
-	{IMX_8BIT, 0x4085, 0x00},
-	{IMX_8BIT, 0x4086, 0x00},
-	{IMX_8BIT, 0x4087, 0x00},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-static struct imx_reg const imx135vb_10m[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x00},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x10},
-	{IMX_8BIT, 0x4082, 0x01},
-	{IMX_8BIT, 0x4083, 0x01},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00}, /* 0, 376, 4207, 2743 */
-	{IMX_8BIT, 0x0345, 0x00},
-	{IMX_8BIT, 0x0346, 0x01},
-	{IMX_8BIT, 0x0347, 0x78},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x6f},
-	{IMX_8BIT, 0x034A, 0x0a},
-	{IMX_8BIT, 0x034B, 0xb7},
-	{IMX_8BIT, 0x034C, 0x10}, /* 4208x2368 */
-	{IMX_8BIT, 0x034D, 0x70},
-	{IMX_8BIT, 0x034E, 0x09},
-	{IMX_8BIT, 0x034F, 0x40},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10},
-	{IMX_8BIT, 0x0355, 0x70},
-	{IMX_8BIT, 0x0356, 0x09},
-	{IMX_8BIT, 0x0357, 0x40},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x10},
-	{IMX_8BIT, 0x3311, 0x70},
-	{IMX_8BIT, 0x3312, 0x09},
-	{IMX_8BIT, 0x3313, 0x40},
-	{IMX_8BIT, 0x331C, 0x01},
-	{IMX_8BIT, 0x331D, 0x68},
-	{IMX_8BIT, 0x4084, 0x00},
-	{IMX_8BIT, 0x4085, 0x00},
-	{IMX_8BIT, 0x4086, 0x00},
-	{IMX_8BIT, 0x4087, 0x00},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-static struct imx_reg const imx135vb_10m_for_mipi_342[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_342MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x00},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x10},
-	{IMX_8BIT, 0x4082, 0x01},
-	{IMX_8BIT, 0x4083, 0x01},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00}, /* 0, 376, 4207, 2743 */
-	{IMX_8BIT, 0x0345, 0x00},
-	{IMX_8BIT, 0x0346, 0x01},
-	{IMX_8BIT, 0x0347, 0x78},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x6f},
-	{IMX_8BIT, 0x034A, 0x0a},
-	{IMX_8BIT, 0x034B, 0xb7},
-	{IMX_8BIT, 0x034C, 0x10}, /* 4208x2368 */
-	{IMX_8BIT, 0x034D, 0x70},
-	{IMX_8BIT, 0x034E, 0x09},
-	{IMX_8BIT, 0x034F, 0x40},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10},
-	{IMX_8BIT, 0x0355, 0x70},
-	{IMX_8BIT, 0x0356, 0x09},
-	{IMX_8BIT, 0x0357, 0x40},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x10},
-	{IMX_8BIT, 0x3311, 0x70},
-	{IMX_8BIT, 0x3312, 0x09},
-	{IMX_8BIT, 0x3313, 0x40},
-	{IMX_8BIT, 0x331C, 0x01},
-	{IMX_8BIT, 0x331D, 0x68},
-	{IMX_8BIT, 0x4084, 0x00},
-	{IMX_8BIT, 0x4085, 0x00},
-	{IMX_8BIT, 0x4086, 0x00},
-	{IMX_8BIT, 0x4087, 0x00},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-static struct imx_reg const imx135vb_8m_scaled_from_12m[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x14},
-	{IMX_8BIT, 0x4082, 0x00},
-	{IMX_8BIT, 0x4083, 0x00},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00},
-	{IMX_8BIT, 0x0345, 0x36},
-	{IMX_8BIT, 0x0346, 0x00},
-	{IMX_8BIT, 0x0347, 0x14},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x39},
-	{IMX_8BIT, 0x034A, 0x0C},
-	{IMX_8BIT, 0x034B, 0x1B},
-	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x2464 */
-	{IMX_8BIT, 0x034D, 0xD0},
-	{IMX_8BIT, 0x034E, 0x09},
-	{IMX_8BIT, 0x034F, 0xA0},
-	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10}, /* Cut out size same as the size after crop */
-	{IMX_8BIT, 0x0355, 0x04},
-	{IMX_8BIT, 0x0356, 0x0C},
-	{IMX_8BIT, 0x0357, 0x08},
-	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
-	{IMX_8BIT, 0x3310, 0x0C}, /* Write H and V size  same as output size? */
-	{IMX_8BIT, 0x3311, 0xD0},
-	{IMX_8BIT, 0x3312, 0x09},
-	{IMX_8BIT, 0x3313, 0xA0},
-	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
-	{IMX_8BIT, 0x331D, 0xA0},
-	{IMX_8BIT, 0x4084, 0x0C}, /* Scaling related? */
-	{IMX_8BIT, 0x4085, 0xD0},
-	{IMX_8BIT, 0x4086, 0x09},
-	{IMX_8BIT, 0x4087, 0xA0},
-	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
-	{IMX_TOK_TERM, 0, 0},
-};
-
-static struct imx_reg const imx135vb_8m_scaled_from_12m_for_mipi342[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_342MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x14},
-	{IMX_8BIT, 0x4082, 0x00},
-	{IMX_8BIT, 0x4083, 0x00},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00},
-	{IMX_8BIT, 0x0345, 0x36},
-	{IMX_8BIT, 0x0346, 0x00},
-	{IMX_8BIT, 0x0347, 0x14},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x39},
-	{IMX_8BIT, 0x034A, 0x0C},
-	{IMX_8BIT, 0x034B, 0x1B},
-	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x2464 */
-	{IMX_8BIT, 0x034D, 0xD0},
-	{IMX_8BIT, 0x034E, 0x09},
-	{IMX_8BIT, 0x034F, 0xA0},
-	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10}, /* Cut out size same as the size after crop */
-	{IMX_8BIT, 0x0355, 0x04},
-	{IMX_8BIT, 0x0356, 0x0C},
-	{IMX_8BIT, 0x0357, 0x08},
-	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
-	{IMX_8BIT, 0x3310, 0x0C}, /* Write H and V size  same as output size? */
-	{IMX_8BIT, 0x3311, 0xD0},
-	{IMX_8BIT, 0x3312, 0x09},
-	{IMX_8BIT, 0x3313, 0xA0},
-	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
-	{IMX_8BIT, 0x331D, 0xA0},
-	{IMX_8BIT, 0x4084, 0x0C}, /* Resize IMG Hand V size-> Scaling related?*/
-	{IMX_8BIT, 0x4085, 0xD0},
-	{IMX_8BIT, 0x4086, 0x09},
-	{IMX_8BIT, 0x4087, 0xA0},
-	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
-	{IMX_TOK_TERM, 0, 0},
-};
-
-static struct imx_reg const imx135vb_6m[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x02},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x14},
-	{IMX_8BIT, 0x4082, 0x00},
-	{IMX_8BIT, 0x4083, 0x00},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00}, /* 36, 194, 1039, a9f 4100x2316 */
-	{IMX_8BIT, 0x0345, 0x36},
-	{IMX_8BIT, 0x0346, 0x01},
-	{IMX_8BIT, 0x0347, 0x94},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x39},
-	{IMX_8BIT, 0x034A, 0x0A},
-	{IMX_8BIT, 0x034B, 0x9F},
-	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x1852 */
-	{IMX_8BIT, 0x034D, 0xD0},
-	{IMX_8BIT, 0x034E, 0x07},
-	{IMX_8BIT, 0x034F, 0x3C},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10}, /* 4100x2316 */
-	{IMX_8BIT, 0x0355, 0x04},
-	{IMX_8BIT, 0x0356, 0x09},
-	{IMX_8BIT, 0x0357, 0x0C},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x0C},
-	{IMX_8BIT, 0x3311, 0xD0},
-	{IMX_8BIT, 0x3312, 0x07},
-	{IMX_8BIT, 0x3313, 0x3C},
-	{IMX_8BIT, 0x331C, 0x02},
-	{IMX_8BIT, 0x331D, 0xA0},
-	{IMX_8BIT, 0x4084, 0x0C},
-	{IMX_8BIT, 0x4085, 0xD0},
-	{IMX_8BIT, 0x4086, 0x07},
-	{IMX_8BIT, 0x4087, 0x3C},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-static struct imx_reg const imx135vb_6m_for_mipi_342[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_342MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x00},
-	{IMX_8BIT, 0x0391, 0x11},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x02},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x14},
-	{IMX_8BIT, 0x4082, 0x00},
-	{IMX_8BIT, 0x4083, 0x00},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00}, /* 36, 194, 1039, a9f 4100x2316 */
-	{IMX_8BIT, 0x0345, 0x36},
-	{IMX_8BIT, 0x0346, 0x01},
-	{IMX_8BIT, 0x0347, 0x94},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x39},
-	{IMX_8BIT, 0x034A, 0x0A},
-	{IMX_8BIT, 0x034B, 0x9F},
-	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x1852 */
-	{IMX_8BIT, 0x034D, 0xD0},
-	{IMX_8BIT, 0x034E, 0x07},
-	{IMX_8BIT, 0x034F, 0x3C},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x10}, /* 4100x2316 */
-	{IMX_8BIT, 0x0355, 0x04},
-	{IMX_8BIT, 0x0356, 0x09},
-	{IMX_8BIT, 0x0357, 0x0C},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x0C},
-	{IMX_8BIT, 0x3311, 0xD0},
-	{IMX_8BIT, 0x3312, 0x07},
-	{IMX_8BIT, 0x3313, 0x3C},
-	{IMX_8BIT, 0x331C, 0x02},
-	{IMX_8BIT, 0x331D, 0xA0},
-	{IMX_8BIT, 0x4084, 0x0C},
-	{IMX_8BIT, 0x4085, 0xD0},
-	{IMX_8BIT, 0x4086, 0x07},
-	{IMX_8BIT, 0x4087, 0x3C},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-static struct imx_reg const imx135vb_3m_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x01}, /* Binning */
-	{IMX_8BIT, 0x0391, 0x22}, /* 2x2 binning */
-	{IMX_8BIT, 0x0392, 0x00}, /* average */
-	{IMX_8BIT, 0x0401, 0x00},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x10},
-	{IMX_8BIT, 0x4082, 0x01},
-	{IMX_8BIT, 0x4083, 0x01},
-	{IMX_8BIT, 0x4203, 0xFF},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00},
-	{IMX_8BIT, 0x0345, 0x28},
-	{IMX_8BIT, 0x0346, 0x00},
-	{IMX_8BIT, 0x0347, 0x08},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x47},
-	{IMX_8BIT, 0x034A, 0x0C},
-	{IMX_8BIT, 0x034B, 0x27},
-	{IMX_8BIT, 0x034C, 0x08},
-	{IMX_8BIT, 0x034D, 0x10},
-	{IMX_8BIT, 0x034E, 0x06},
-	{IMX_8BIT, 0x034F, 0x10},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x08},
-	{IMX_8BIT, 0x0355, 0x10},
-	{IMX_8BIT, 0x0356, 0x06},
-	{IMX_8BIT, 0x0357, 0x10},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x08},
-	{IMX_8BIT, 0x3311, 0x10},
-	{IMX_8BIT, 0x3312, 0x06},
-	{IMX_8BIT, 0x3313, 0x10},
-	{IMX_8BIT, 0x331C, 0x00},
-	{IMX_8BIT, 0x331D, 0xAA},
-	{IMX_8BIT, 0x4084, 0x00},
-	{IMX_8BIT, 0x4085, 0x00},
-	{IMX_8BIT, 0x4086, 0x00},
-	{IMX_8BIT, 0x4087, 0x00},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-/* 1080P 1936x1104 */
-static struct imx_reg const imx135vb_1080p_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03},
-	{IMX_8BIT, 0x0112, 0x0A},
-	{IMX_8BIT, 0x0113, 0x0A},
-	{IMX_8BIT, 0x0381, 0x01},
-	{IMX_8BIT, 0x0383, 0x01},
-	{IMX_8BIT, 0x0385, 0x01},
-	{IMX_8BIT, 0x0387, 0x01},
-	{IMX_8BIT, 0x0390, 0x01},
-	{IMX_8BIT, 0x0391, 0x22},
-	{IMX_8BIT, 0x0392, 0x00},
-	{IMX_8BIT, 0x0401, 0x02},
-	{IMX_8BIT, 0x0404, 0x00},
-	{IMX_8BIT, 0x0405, 0x11},
-	{IMX_8BIT, 0x4082, 0x00},
-	{IMX_8BIT, 0x4083, 0x00},
-	{IMX_8BIT, 0x7006, 0x04},
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00},
-	{IMX_8BIT, 0x0345, 0x2E},
-	{IMX_8BIT, 0x0346, 0x01},
-	{IMX_8BIT, 0x0347, 0x84},
-	{IMX_8BIT, 0x0348, 0x10},
-	{IMX_8BIT, 0x0349, 0x41},
-	{IMX_8BIT, 0x034A, 0x0A},
-	{IMX_8BIT, 0x034B, 0xAF},
-	{IMX_8BIT, 0x034C, 0x07},
-	{IMX_8BIT, 0x034D, 0x90},
-	{IMX_8BIT, 0x034E, 0x04},
-	{IMX_8BIT, 0x034F, 0x50},
-	{IMX_8BIT, 0x0350, 0x00},
-	{IMX_8BIT, 0x0351, 0x00},
-	{IMX_8BIT, 0x0352, 0x00},
-	{IMX_8BIT, 0x0353, 0x00},
-	{IMX_8BIT, 0x0354, 0x08},
-	{IMX_8BIT, 0x0355, 0x0A},
-	{IMX_8BIT, 0x0356, 0x04},
-	{IMX_8BIT, 0x0357, 0x96},
-	{IMX_8BIT, 0x301D, 0x30},
-	{IMX_8BIT, 0x3310, 0x07},
-	{IMX_8BIT, 0x3311, 0x90},
-	{IMX_8BIT, 0x3312, 0x04},
-	{IMX_8BIT, 0x3313, 0x50},
-	{IMX_8BIT, 0x331C, 0x01},
-	{IMX_8BIT, 0x331D, 0x00},
-	{IMX_8BIT, 0x4084, 0x07},
-	{IMX_8BIT, 0x4085, 0x90},
-	{IMX_8BIT, 0x4086, 0x04},
-	{IMX_8BIT, 0x4087, 0x50},
-	{IMX_8BIT, 0x4400, 0x00},
-	{IMX_TOK_TERM, 0, 0},
-};
-
-/******************* Video Modes ******************/
-
-/* 1080P DVS 2336x1320 */
-static const struct imx_reg imx135vb_2336x1320_max_clock[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
-	/* mode setting */
-	{ IMX_8BIT, 0x0108, 0x03 },
-	{ IMX_8BIT, 0x0112, 0x0A },
-	{ IMX_8BIT, 0x0113, 0x0A },
-	{ IMX_8BIT, 0x0381, 0x01 },
-	{ IMX_8BIT, 0x0383, 0x01 },
-	{ IMX_8BIT, 0x0385, 0x01 },
-	{ IMX_8BIT, 0x0387, 0x01 },
-	{ IMX_8BIT, 0x0390, 0x00 },
-	{ IMX_8BIT, 0x0391, 0x11 },
-	{ IMX_8BIT, 0x0392, 0x00 },
-	{ IMX_8BIT, 0x0401, 0x02 },
-	{ IMX_8BIT, 0x0404, 0x00 },
-	{ IMX_8BIT, 0x0405, 0x1C },
-	{ IMX_8BIT, 0x4082, 0x00 },
-	{ IMX_8BIT, 0x4083, 0x00 },
-	{ IMX_8BIT, 0x7006, 0x04 },
-	/* size setting */
-	{ IMX_8BIT, 0x0344, 0x00 }, /* 60,404,4147,2715: 4088x2312 */
-	{ IMX_8BIT, 0x0345, 0x3C },
-	{ IMX_8BIT, 0x0346, 0x01 },
-	{ IMX_8BIT, 0x0347, 0x94 },
-	{ IMX_8BIT, 0x0348, 0x10 },
-	{ IMX_8BIT, 0x0349, 0x33 },
-	{ IMX_8BIT, 0x034A, 0x0A },
-	{ IMX_8BIT, 0x034B, 0x9B },
-	{ IMX_8BIT, 0x034C, 0x09 }, /*2336 x 1320 */
-	{ IMX_8BIT, 0x034D, 0x20 },
-	{ IMX_8BIT, 0x034E, 0x05 },
-	{ IMX_8BIT, 0x034F, 0x28 },
-	{ IMX_8BIT, 0x0350, 0x00 },
-	{ IMX_8BIT, 0x0351, 0x00 },
-	{ IMX_8BIT, 0x0352, 0x00 },
-	{ IMX_8BIT, 0x0353, 0x00 },
-	{ IMX_8BIT, 0x0354, 0x0F }, /* 4088x2312 */
-	{ IMX_8BIT, 0x0355, 0xF8 },
-	{ IMX_8BIT, 0x0356, 0x09 },
-	{ IMX_8BIT, 0x0357, 0x08 },
-	{ IMX_8BIT, 0x301D, 0x30 },
-	{ IMX_8BIT, 0x3310, 0x09 },
-	{ IMX_8BIT, 0x3311, 0x20 },
-	{ IMX_8BIT, 0x3312, 0x05 },
-	{ IMX_8BIT, 0x3313, 0x28 },
-	{ IMX_8BIT, 0x331C, 0x04 },
-	{ IMX_8BIT, 0x331D, 0xE2 },
-	{ IMX_8BIT, 0x4084, 0x09 },
-	{ IMX_8BIT, 0x4085, 0x20 },
-	{ IMX_8BIT, 0x4086, 0x05 },
-	{ IMX_8BIT, 0x4087, 0x28 },
-	{ IMX_8BIT, 0x4400, 0x00 },
-	{ IMX_TOK_TERM, 0, 0}
-};
-
-/* 720P DVS 1568 x 880 */
-static const struct imx_reg imx135vb_720p_dvs_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* mode setting */
-	{ IMX_8BIT, 0x0108, 0x03 },
-	{ IMX_8BIT, 0x0112, 0x0A },
-	{ IMX_8BIT, 0x0113, 0x0A },
-	{ IMX_8BIT, 0x0381, 0x01 },
-	{ IMX_8BIT, 0x0383, 0x01 },
-	{ IMX_8BIT, 0x0385, 0x01 },
-	{ IMX_8BIT, 0x0387, 0x01 },
-	{ IMX_8BIT, 0x0390, 0x01 },
-	{ IMX_8BIT, 0x0391, 0x22 },
-	{ IMX_8BIT, 0x0392, 0x00 },
-	{ IMX_8BIT, 0x0401, 0x02 },
-	{ IMX_8BIT, 0x0404, 0x00 },
-	{ IMX_8BIT, 0x0405, 0x15 },
-	{ IMX_8BIT, 0x4082, 0x00 },
-	{ IMX_8BIT, 0x4083, 0x00 },
-	{ IMX_8BIT, 0x7006, 0x04 },
-	/* size setting */
-	{ IMX_8BIT, 0x0344, 0x00 }, /* 46,404,4161,2715: 4116x2312 */
-	{ IMX_8BIT, 0x0345, 0x2e },
-	{ IMX_8BIT, 0x0346, 0x01 },
-	{ IMX_8BIT, 0x0347, 0x94 },
-	{ IMX_8BIT, 0x0348, 0x10 },
-	{ IMX_8BIT, 0x0349, 0x41 },
-	{ IMX_8BIT, 0x034A, 0x0A },
-	{ IMX_8BIT, 0x034B, 0x9B },
-	{ IMX_8BIT, 0x034C, 0x06 }, /*1568 x 880 */
-	{ IMX_8BIT, 0x034D, 0x20 },
-	{ IMX_8BIT, 0x034E, 0x03 },
-	{ IMX_8BIT, 0x034F, 0x70 },
-	{ IMX_8BIT, 0x0350, 0x00 },
-	{ IMX_8BIT, 0x0351, 0x00 },
-	{ IMX_8BIT, 0x0352, 0x00 },
-	{ IMX_8BIT, 0x0353, 0x00 },
-	{ IMX_8BIT, 0x0354, 0x08 }, /* 2058x1156 */
-	{ IMX_8BIT, 0x0355, 0x0a },
-	{ IMX_8BIT, 0x0356, 0x04 },
-	{ IMX_8BIT, 0x0357, 0x84 },
-	{ IMX_8BIT, 0x301D, 0x30 }, /* TODO! */
-	{ IMX_8BIT, 0x3310, 0x06 },
-	{ IMX_8BIT, 0x3311, 0x20 },
-	{ IMX_8BIT, 0x3312, 0x03 },
-	{ IMX_8BIT, 0x3313, 0x70 },
-	{ IMX_8BIT, 0x331C, 0x01 }, /* TODO! */
-	{ IMX_8BIT, 0x331D, 0xd6 }, /* TODO! */
-	{ IMX_8BIT, 0x4084, 0x06 },
-	{ IMX_8BIT, 0x4085, 0x20 },
-	{ IMX_8BIT, 0x4086, 0x03 },
-	{ IMX_8BIT, 0x4087, 0x70 },
-	{ IMX_8BIT, 0x4400, 0x00 },
-	{ IMX_TOK_TERM, 0, 0}
-};
-
-/* wvga: H : 1640 V : 1024 */
-static const struct imx_reg imx135vb_wvga_dvs_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03 },
-	{IMX_8BIT, 0x0112, 0x0A },
-	{IMX_8BIT, 0x0113, 0x0A },
-	{IMX_8BIT, 0x0381, 0x01 },
-	{IMX_8BIT, 0x0383, 0x01 },
-	{IMX_8BIT, 0x0385, 0x01 },
-	{IMX_8BIT, 0x0387, 0x01 },
-	{IMX_8BIT, 0x0390, 0x01 },
-	{IMX_8BIT, 0x0391, 0x22 },
-	{IMX_8BIT, 0x0392, 0x00 },
-	{IMX_8BIT, 0x0401, 0x02 },
-	{IMX_8BIT, 0x0404, 0x00 },
-	{IMX_8BIT, 0x0405, 0x14 },
-	{IMX_8BIT, 0x4082, 0x00 },
-	{IMX_8BIT, 0x4083, 0x00 },
-	{IMX_8BIT, 0x7006, 0x04 },
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00 },
-	{IMX_8BIT, 0x0345, 0x36 },
-	{IMX_8BIT, 0x0346, 0x01 },
-	{IMX_8BIT, 0x0347, 0x18 },
-	{IMX_8BIT, 0x0348, 0x10 },
-	{IMX_8BIT, 0x0349, 0x39 },
-	{IMX_8BIT, 0x034A, 0x0B },
-	{IMX_8BIT, 0x034B, 0x17 },
-	{IMX_8BIT, 0x034C, 0x06 },
-	{IMX_8BIT, 0x034D, 0x68 },
-	{IMX_8BIT, 0x034E, 0x04 },
-	{IMX_8BIT, 0x034F, 0x00 },
-	{IMX_8BIT, 0x0350, 0x00 },
-	{IMX_8BIT, 0x0351, 0x00 },
-	{IMX_8BIT, 0x0352, 0x00 },
-	{IMX_8BIT, 0x0353, 0x00 },
-	{IMX_8BIT, 0x0354, 0x08 },
-	{IMX_8BIT, 0x0355, 0x02 },
-	{IMX_8BIT, 0x0356, 0x05 },
-	{IMX_8BIT, 0x0357, 0x00 },
-	{IMX_8BIT, 0x301D, 0x30 },
-	{IMX_8BIT, 0x3310, 0x06 },
-	{IMX_8BIT, 0x3311, 0x68 },
-	{IMX_8BIT, 0x3312, 0x04 },
-	{IMX_8BIT, 0x3313, 0x00 },
-	{IMX_8BIT, 0x331C, 0x01 },
-	{IMX_8BIT, 0x331D, 0xBD },
-	{IMX_8BIT, 0x4084, 0x06 },
-	{IMX_8BIT, 0x4085, 0x68 },
-	{IMX_8BIT, 0x4086, 0x04 },
-	{IMX_8BIT, 0x4087, 0x00 },
-	{IMX_8BIT, 0x4400, 0x00 },
-	{IMX_TOK_TERM, 0, 0}
-};
-
-/* 480P DVS 936 x 602 */
-static const struct imx_reg imx135vb_480p_dvs_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* mode setting */
-	{ IMX_8BIT, 0x0108, 0x03 },
-	{ IMX_8BIT, 0x0112, 0x0A },
-	{ IMX_8BIT, 0x0113, 0x0A },
-	{ IMX_8BIT, 0x0381, 0x01 },
-	{ IMX_8BIT, 0x0383, 0x01 },
-	{ IMX_8BIT, 0x0385, 0x01 },
-	{ IMX_8BIT, 0x0387, 0x01 },
-	{ IMX_8BIT, 0x0390, 0x01 },
-	{ IMX_8BIT, 0x0391, 0x22 },
-	{ IMX_8BIT, 0x0392, 0x00 },
-	{ IMX_8BIT, 0x0401, 0x02 },
-	{ IMX_8BIT, 0x0404, 0x00 },
-	{ IMX_8BIT, 0x0405, 0x23 },
-	{ IMX_8BIT, 0x4082, 0x00 },
-	{ IMX_8BIT, 0x4083, 0x00 },
-	{ IMX_8BIT, 0x7006, 0x04 },
-	/* size setting */
-	{ IMX_8BIT, 0x0344, 0x00 }, /* 56,244,4151,2877: 4096x2634 */
-	{ IMX_8BIT, 0x0345, 0x38 },
-	{ IMX_8BIT, 0x0346, 0x00 },
-	{ IMX_8BIT, 0x0347, 0xf4 },
-	{ IMX_8BIT, 0x0348, 0x10 },
-	{ IMX_8BIT, 0x0349, 0x37 },
-	{ IMX_8BIT, 0x034A, 0x0b },
-	{ IMX_8BIT, 0x034B, 0x3d },
-	{ IMX_8BIT, 0x034C, 0x03 }, /* 936 x 602 */
-	{ IMX_8BIT, 0x034D, 0xa8 },
-	{ IMX_8BIT, 0x034E, 0x02 },
-	{ IMX_8BIT, 0x034F, 0x5a },
-	{ IMX_8BIT, 0x0350, 0x00 },
-	{ IMX_8BIT, 0x0351, 0x00 },
-	{ IMX_8BIT, 0x0352, 0x00 },
-	{ IMX_8BIT, 0x0353, 0x00 },
-	{ IMX_8BIT, 0x0354, 0x08 }, /* 2058x1156 */
-	{ IMX_8BIT, 0x0355, 0x00 },
-	{ IMX_8BIT, 0x0356, 0x05 },
-	{ IMX_8BIT, 0x0357, 0x25 },
-	{ IMX_8BIT, 0x301D, 0x30 }, /* TODO! */
-	{ IMX_8BIT, 0x3310, 0x03 },
-	{ IMX_8BIT, 0x3311, 0xa8 },
-	{ IMX_8BIT, 0x3312, 0x02 },
-	{ IMX_8BIT, 0x3313, 0x5a },
-	{ IMX_8BIT, 0x331C, 0x01 }, /* TODO! */
-	{ IMX_8BIT, 0x331D, 0xd6 },
-	{ IMX_8BIT, 0x4084, 0x03 },
-	{ IMX_8BIT, 0x4085, 0xa8 },
-	{ IMX_8BIT, 0x4086, 0x02 },
-	{ IMX_8BIT, 0x4087, 0x5a },
-	{ IMX_8BIT, 0x4400, 0x00 },
-	{ IMX_TOK_TERM, 0, 0}
-};
-
-/* VGA: H : 820 V : 616 */
-static const struct imx_reg imx135vb_vga_dvs_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03 },
-	{IMX_8BIT, 0x0112, 0x0A },
-	{IMX_8BIT, 0x0113, 0x0A },
-	{IMX_8BIT, 0x0381, 0x01 },
-	{IMX_8BIT, 0x0383, 0x01 },
-	{IMX_8BIT, 0x0385, 0x01 },
-	{IMX_8BIT, 0x0387, 0x01 },
-	{IMX_8BIT, 0x0390, 0x01 },
-	{IMX_8BIT, 0x0391, 0x44 },
-	{IMX_8BIT, 0x0392, 0x00 },
-	{IMX_8BIT, 0x0401, 0x02 },
-	{IMX_8BIT, 0x0404, 0x00 },
-	{IMX_8BIT, 0x0405, 0x14 },
-	{IMX_8BIT, 0x4082, 0x00 },
-	{IMX_8BIT, 0x4083, 0x00 },
-	{IMX_8BIT, 0x7006, 0x04 },
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00 }, /* 52,20,4155, 3099 4104x3080*/
-	{IMX_8BIT, 0x0345, 0x34 },
-	{IMX_8BIT, 0x0346, 0x00 },
-	{IMX_8BIT, 0x0347, 0x14 },
-	{IMX_8BIT, 0x0348, 0x10 },
-	{IMX_8BIT, 0x0349, 0x3B },
-	{IMX_8BIT, 0x034A, 0x0C },
-	{IMX_8BIT, 0x034B, 0x1B },
-	{IMX_8BIT, 0x034C, 0x03 }, /* 820x616 */
-	{IMX_8BIT, 0x034D, 0x34 },
-	{IMX_8BIT, 0x034E, 0x02 },
-	{IMX_8BIT, 0x034F, 0x68 },
-	{IMX_8BIT, 0x0350, 0x00 },
-	{IMX_8BIT, 0x0351, 0x00 },
-	{IMX_8BIT, 0x0352, 0x00 },
-	{IMX_8BIT, 0x0353, 0x00 },
-	{IMX_8BIT, 0x0354, 0x04 }, /* 1026x770 */
-	{IMX_8BIT, 0x0355, 0x02 },
-	{IMX_8BIT, 0x0356, 0x03 },
-	{IMX_8BIT, 0x0357, 0x02 },
-	{IMX_8BIT, 0x301D, 0x30 },
-	{IMX_8BIT, 0x3310, 0x03 },
-	{IMX_8BIT, 0x3311, 0x34 },
-	{IMX_8BIT, 0x3312, 0x02 },
-	{IMX_8BIT, 0x3313, 0x68 },
-	{IMX_8BIT, 0x331C, 0x02 },
-	{IMX_8BIT, 0x331D, 0x21 },
-	{IMX_8BIT, 0x4084, 0x03 },
-	{IMX_8BIT, 0x4085, 0x34 },
-	{IMX_8BIT, 0x4086, 0x02 },
-	{IMX_8BIT, 0x4087, 0x68 },
-	{IMX_8BIT, 0x4400, 0x00 },
-	{IMX_TOK_TERM, 0, 0}
-};
-
-/* QVGA: H : 408 V : 308 */
-static const struct imx_reg imx135vb_qvga__dvs_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03 },
-	{IMX_8BIT, 0x0112, 0x0A },
-	{IMX_8BIT, 0x0113, 0x0A },
-	{IMX_8BIT, 0x0381, 0x01 },
-	{IMX_8BIT, 0x0383, 0x01 },
-	{IMX_8BIT, 0x0385, 0x01 },
-	{IMX_8BIT, 0x0387, 0x01 },
-	{IMX_8BIT, 0x0390, 0x01 },
-	{IMX_8BIT, 0x0391, 0x44 },
-	{IMX_8BIT, 0x0392, 0x00 },
-	{IMX_8BIT, 0x0401, 0x02 },
-	{IMX_8BIT, 0x0404, 0x00 },
-	{IMX_8BIT, 0x0405, 0x28 },
-	{IMX_8BIT, 0x4082, 0x00 },
-	{IMX_8BIT, 0x4083, 0x00 },
-	{IMX_8BIT, 0x7006, 0x04 },
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00 }, /* 64,20,4143,3099 4080x3080 */
-	{IMX_8BIT, 0x0345, 0x40 },
-	{IMX_8BIT, 0x0346, 0x00 },
-	{IMX_8BIT, 0x0347, 0x14 },
-	{IMX_8BIT, 0x0348, 0x10 },
-	{IMX_8BIT, 0x0349, 0x2F },
-	{IMX_8BIT, 0x034A, 0x0C },
-	{IMX_8BIT, 0x034B, 0x1B },
-	{IMX_8BIT, 0x034C, 0x01 }, /* 408x308 */
-	{IMX_8BIT, 0x034D, 0x98 },
-	{IMX_8BIT, 0x034E, 0x01 },
-	{IMX_8BIT, 0x034F, 0x34 },
-	{IMX_8BIT, 0x0350, 0x00 },
-	{IMX_8BIT, 0x0351, 0x00 },
-	{IMX_8BIT, 0x0352, 0x00 },
-	{IMX_8BIT, 0x0353, 0x00 },
-	{IMX_8BIT, 0x0354, 0x03 }, /* 1020x770 */
-	{IMX_8BIT, 0x0355, 0xFC },
-	{IMX_8BIT, 0x0356, 0x03 },
-	{IMX_8BIT, 0x0357, 0x02 },
-	{IMX_8BIT, 0x301D, 0x30 },
-	{IMX_8BIT, 0x3310, 0x01 },
-	{IMX_8BIT, 0x3311, 0x98 },
-	{IMX_8BIT, 0x3312, 0x01 },
-	{IMX_8BIT, 0x3313, 0x34 },
-	{IMX_8BIT, 0x331C, 0x01 },
-	{IMX_8BIT, 0x331D, 0x68 },
-	{IMX_8BIT, 0x4084, 0x01 },
-	{IMX_8BIT, 0x4085, 0x98 },
-	{IMX_8BIT, 0x4086, 0x01 },
-	{IMX_8BIT, 0x4087, 0x34 },
-	{IMX_8BIT, 0x4400, 0x00 },
-	{IMX_TOK_TERM, 0, 0}
-};
-
-/* CIF H : 368 V : 304 */
-static const struct imx_reg imx135vb_cif_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03 },
-	{IMX_8BIT, 0x0112, 0x0A },
-	{IMX_8BIT, 0x0113, 0x0A },
-	{IMX_8BIT, 0x0381, 0x01 },
-	{IMX_8BIT, 0x0383, 0x01 },
-	{IMX_8BIT, 0x0385, 0x01 },
-	{IMX_8BIT, 0x0387, 0x01 },
-	{IMX_8BIT, 0x0390, 0x01 },
-	{IMX_8BIT, 0x0391, 0x44 },
-	{IMX_8BIT, 0x0392, 0x00 },
-	{IMX_8BIT, 0x0401, 0x02 },
-	{IMX_8BIT, 0x0404, 0x00 },
-	{IMX_8BIT, 0x0405, 0x28 },
-	{IMX_8BIT, 0x4082, 0x00 },
-	{IMX_8BIT, 0x4083, 0x00 },
-	{IMX_8BIT, 0x7006, 0x04 },
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x01 }, /* 264,42,3943,3081 3680x3040 */
-	{IMX_8BIT, 0x0345, 0x08 },
-	{IMX_8BIT, 0x0346, 0x00 },
-	{IMX_8BIT, 0x0347, 0x2a },
-	{IMX_8BIT, 0x0348, 0x0F },
-	{IMX_8BIT, 0x0349, 0x67 },
-	{IMX_8BIT, 0x034A, 0x0c },
-	{IMX_8BIT, 0x034B, 0x09 },
-	{IMX_8BIT, 0x034C, 0x01 }, /* 368x304 */
-	{IMX_8BIT, 0x034D, 0x70 },
-	{IMX_8BIT, 0x034E, 0x01 },
-	{IMX_8BIT, 0x034F, 0x30 },
-	{IMX_8BIT, 0x0350, 0x00 },
-	{IMX_8BIT, 0x0351, 0x00 },
-	{IMX_8BIT, 0x0352, 0x00 },
-	{IMX_8BIT, 0x0353, 0x00 },
-	{IMX_8BIT, 0x0354, 0x03 }, /* 920x760 */
-	{IMX_8BIT, 0x0355, 0x98 },
-	{IMX_8BIT, 0x0356, 0x02 },
-	{IMX_8BIT, 0x0357, 0xf8 },
-	{IMX_8BIT, 0x301D, 0x30 },
-	{IMX_8BIT, 0x3310, 0x01 },
-	{IMX_8BIT, 0x3311, 0x70 },
-	{IMX_8BIT, 0x3312, 0x01 },
-	{IMX_8BIT, 0x3313, 0x30 },
-	{IMX_8BIT, 0x331C, 0x02 }, /* TODO! binning 4x4 must be 021c? */
-	{IMX_8BIT, 0x331D, 0x1C },
-	{IMX_8BIT, 0x4084, 0x01 },
-	{IMX_8BIT, 0x4085, 0x70 },
-	{IMX_8BIT, 0x4086, 0x01 },
-	{IMX_8BIT, 0x4087, 0x30 },
-	{IMX_8BIT, 0x4400, 0x00 },
-	{IMX_TOK_TERM, 0, 0}
-};
-
-/* QCIF H : 216 V : 176 */
-static const struct imx_reg imx135vb_qcif_dvs_binning[] = {
-	GROUPED_PARAMETER_HOLD_ENABLE,
-	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
-	/* Mode setting */
-	{IMX_8BIT, 0x0108, 0x03 },
-	{IMX_8BIT, 0x0112, 0x0A },
-	{IMX_8BIT, 0x0113, 0x0A },
-	{IMX_8BIT, 0x0381, 0x01 },
-	{IMX_8BIT, 0x0383, 0x01 },
-	{IMX_8BIT, 0x0385, 0x01 },
-	{IMX_8BIT, 0x0387, 0x01 },
-	{IMX_8BIT, 0x0390, 0x01 },
-	{IMX_8BIT, 0x0391, 0x44 },
-	{IMX_8BIT, 0x0392, 0x00 },
-	{IMX_8BIT, 0x0401, 0x02 },
-	{IMX_8BIT, 0x0404, 0x00 },
-	{IMX_8BIT, 0x0405, 0x46 },
-	{IMX_8BIT, 0x4082, 0x00 },
-	{IMX_8BIT, 0x4083, 0x00 },
-	{IMX_8BIT, 0x7006, 0x04 },
-	/* Size setting */
-	{IMX_8BIT, 0x0344, 0x00 }, /* 212,20,3995,3099 3784x3080 */
-	{IMX_8BIT, 0x0345, 0xD4 },
-	{IMX_8BIT, 0x0346, 0x00 },
-	{IMX_8BIT, 0x0347, 0x14 },
-	{IMX_8BIT, 0x0348, 0x0F },
-	{IMX_8BIT, 0x0349, 0x9B },
-	{IMX_8BIT, 0x034A, 0x0C },
-	{IMX_8BIT, 0x034B, 0x1B },
-	{IMX_8BIT, 0x034C, 0x00 }, /* 216x176 */
-	{IMX_8BIT, 0x034D, 0xD8 },
-	{IMX_8BIT, 0x034E, 0x00 },
-	{IMX_8BIT, 0x034F, 0xB0 },
-	{IMX_8BIT, 0x0350, 0x00 },
-	{IMX_8BIT, 0x0351, 0x00 },
-	{IMX_8BIT, 0x0352, 0x00 },
-	{IMX_8BIT, 0x0353, 0x00 },
-	{IMX_8BIT, 0x0354, 0x03 }, /* 946x770 */
-	{IMX_8BIT, 0x0355, 0xB2 },
-	{IMX_8BIT, 0x0356, 0x03 },
-	{IMX_8BIT, 0x0357, 0x02 },
-	{IMX_8BIT, 0x301D, 0x30 },
-	{IMX_8BIT, 0x3310, 0x00 },
-	{IMX_8BIT, 0x3311, 0xD8 },
-	{IMX_8BIT, 0x3312, 0x00 },
-	{IMX_8BIT, 0x3313, 0xB0 },
-	{IMX_8BIT, 0x331C, 0x02 }, /* TODO! binning 4x4 must be 021c */
-	{IMX_8BIT, 0x331D, 0x1C },
-	{IMX_8BIT, 0x4084, 0x00 },
-	{IMX_8BIT, 0x4085, 0xD8 },
-	{IMX_8BIT, 0x4086, 0x00 },
-	{IMX_8BIT, 0x4087, 0xB0 },
-	{IMX_8BIT, 0x4400, 0x00 },
-	{IMX_TOK_TERM, 0, 0}
-};
-
-/*
- * ISP Scaling is now supported in offine capture use cases. Because of that
- * we need only few modes to cover the different aspect ratios from the
- * sensor and the ISP will scale it based on the requested resolution from HAL.
- *
- * There is a performance impact when continuous view finder option is chose
- * for resolutions above 8MP. So 8MP and 6MP resolution are kept, so that lower
- * than these take 8MP or 6MP espectively for down scaling based on the
- * aspect ratio.
- */
-struct imx_resolution imx135vb_res_preview[] = {
-	{
-		.desc = "imx135vb_cif_binning_preview",
-		.regs = imx135vb_cif_binning,
-		.width = 368,
-		.height = 304,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 30,
-				 .pixels_per_line = 9114,
-				 .lines_per_frame = 1226,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-	},
-	{
-		 .desc = "imx135vb_480p_binning_preview",
-		 .regs = imx135vb_480p_dvs_binning,
-		 .width = 936,
-		 .height = 602,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		 .bin_factor_x = 1,
-		 .bin_factor_y = 1,
-	},
-	{
-		.desc = "imx135vb_1080p_binning_preview",
-		.regs = imx135vb_1080p_binning,
-		.width = 1936,
-		.height = 1104,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_3m__cont_cap",
-		.regs = imx135vb_3m_binning,
-		.width = 2064,
-		.height = 1552,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_6m_cont_cap",
-		.regs = imx135vb_6m,
-		.width = 3280,
-		.height = 1852,
-		.fps_options = {
-			{ /* Binning Pixel clock: 360.96MHz */
-				 .fps = 30,
-				 .pixels_per_line = 4572,
-				 .lines_per_frame = 2624,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_8m_scaled_from_12m__cont_cap",
-		.regs = imx135vb_8m_scaled_from_12m,
-		.width = 3280,
-		.height = 2464,
-		.fps_options = {
-			{ /* Pixel clock: 360.96MHz */
-				 .fps = 24,
-				 .pixels_per_line = 4572,
-				 .lines_per_frame = 3280,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_10m__cont_cap",
-		.regs = imx135vb_10m,
-		.width = 4208,
-		.height = 2368,
-		.fps_options = {
-			{ /* Pixel clock: 360.96MHz */
-				 .fps = 30,
-				 .pixels_per_line = 4572,
-				 .lines_per_frame = 2632,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_13m__cont_cap",
-		.regs = imx135vb_13m,
-		.width = 4208,
-		.height = 3120,
-		.fps_options = {
-			{ /* Pixel clock: 360.96MHz */
-				 .fps = 24,
-				 .pixels_per_line = 4572,
-				 .lines_per_frame = 3290,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-};
-
-/*
- * ISP Scaling is now supported in online capture use cases. Because of that
- * we need only few modes to cover the different aspect ratios from the
- * sensor and the ISP will scale it based on the requested resolution from HAL.
- *
- * There is a performance impact when continuous view finder option is chose
- * for resolutions above 8MP. So 8MP and 6MP resolution are kept, so that lower
- * than these take 8MP or 6MP espectively for down scaling based on the
- * aspect ratio.
- */
-struct imx_resolution imx135vb_res_still[] = {
-	{
-		.desc = "imx135vb_cif_binning_preview",
-		.regs = imx135vb_cif_binning,
-		.width = 368,
-		.height = 304,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 30,
-				 .pixels_per_line = 9114,
-				 .lines_per_frame = 1226,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-	},
-	{
-		 .desc = "imx135vb_480p_binning_still",
-		 .regs = imx135vb_480p_dvs_binning,
-		 .width = 936,
-		 .height = 602,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 30,
-				 .pixels_per_line = 9114,
-				 .lines_per_frame = 2453,
-			},
-			{
-			}
-		},
-		 .bin_factor_x = 1,
-		 .bin_factor_y = 1,
-	},
-	{
-		.desc = "imx135vb_1080p_binning_still",
-		.regs = imx135vb_1080p_binning,
-		.width = 1936,
-		.height = 1104,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 15,
-				 .pixels_per_line = 9114,
-				 .lines_per_frame = 2453,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_3m__still",
-		.regs = imx135vb_3m_binning,
-		.width = 2064,
-		.height = 1552,
-		.fps_options = {
-			{ /* Binning Pixel clock: 335.36MHz */
-				 .fps = 15,
-				 .pixels_per_line = 9114,
-				 .lines_per_frame = 2453,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_6m_for_mipi_342_still",
-		.regs = imx135vb_6m_for_mipi_342,
-		.width = 3280,
-		.height = 1852,
-		.fps_options = {
-			{ /* Pixel clock: 273.6MHz */
-				 .fps = 11,
-				 .pixels_per_line = 9114,
-				 .lines_per_frame = 2664,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_8m_scaled_from_12m_for_mipi342_still",
-		.regs = imx135vb_8m_scaled_from_12m_for_mipi342,
-		.width = 3280,
-		.height = 2464,
-		.fps_options = {
-			{ /* Pixel clock: 273.6MHz */
-				 .fps = 15,
-				 .pixels_per_line = 5500,
-				 .lines_per_frame = 3314,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_10m_for_mipi_342_still",
-		.regs = imx135vb_10m_for_mipi_342,
-		.width = 4208,
-		.height = 2368,
-		.fps_options = {
-			{ /* Pixel clock: 273.6MHz */
-				 .fps = 11,
-				 .pixels_per_line = 9144,
-				 .lines_per_frame = 2664,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-	{
-		.desc = "imx135vb_13m_still",
-		.regs = imx135vb_13m_for_mipi_342,
-		.width = 4208,
-		.height = 3120,
-		.fps_options = {
-			{ /* Pixel clock: 273.6MHz */
-				 .fps = 9,
-				 .pixels_per_line = 9144,
-				 .lines_per_frame = 3328,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.used = 0,
-	},
-};
-
-/*
- * ISP scaling is not supported in case of video modes. So we need to have
- * separate sensor mode for video use cases
- */
-struct imx_resolution imx135vb_res_video[] = {
-	/* For binning modes pix clock is 335.36 MHz. */
-	{
-		.desc = "imx135vb_qcif_dvs_binning_video",
-		.regs = imx135vb_qcif_dvs_binning,
-		.width = 216,
-		.height = 176,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 9144,
-				 .lines_per_frame = 1226,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-	},
-	{
-		.desc = "imx135vb_cif_binning_video",
-		.regs = imx135vb_cif_binning,
-		.width = 368,
-		.height = 304,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 9144,
-				 .lines_per_frame = 1226,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-	},
-	{
-		.desc = "imx135vb_qvga__dvs_binning_video",
-		.regs = imx135vb_qvga__dvs_binning,
-		.width = 408,
-		.height = 308,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 9144,
-				 .lines_per_frame = 1226,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-	},
-	{
-		.desc = "imx135vb_vga_dvs_binning_video",
-		.regs = imx135vb_vga_dvs_binning,
-		.width = 820,
-		.height = 616,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 9144,
-				 .lines_per_frame = 1226,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-	},
-	{
-		.desc = "imx135vb_480p_dvs_binning_video",
-		.regs = imx135vb_480p_dvs_binning,
-		.width = 936,
-		.height = 602,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-	},
-	{
-		.desc = "imx135vb_720p_dvs_binning_video",
-		.regs = imx135vb_720p_dvs_binning,
-		.width = 1568,
-		.height = 880,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-	},
-	{
-		.desc = "imx135_wvga_dvs_binning_video",
-		.regs = imx135vb_wvga_dvs_binning,
-		.width = 1640,
-		.height = 1024,
-		.fps_options = {
-			{
-				 .fps = 30,
-				 .pixels_per_line = 5464,
-				 .lines_per_frame = 2046,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-	},
-	{
-		.desc = "imx135vb_1080P_dvs_video",
-		.regs = imx135vb_2336x1320_max_clock,
-		.width = 2336,
-		.height = 1320,
-		.fps_options = {
-			{/* Pixel Clock : 360.96 MHz */
-				 .fps = 30,
-				 .pixels_per_line = 4572,
-				 .lines_per_frame = 2632,
-			},
-			{
-			}
-		},
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-	},
-};
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx208.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx208.h
new file mode 100644
index 0000000..fed387f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx208.h
@@ -0,0 +1,550 @@
+/*
+ * Support for Sony IMX camera sensor.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IMX208_H__
+#define __IMX208_H__
+#include "common.h"
+
+/********************** settings for imx from vendor*********************/
+static struct imx_reg imx208_1080p_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0305, 0x02},    /* PREPLLCK DIV */
+	{IMX_8BIT, 0x0307, 0x54},    /* PLL MPY */
+	{IMX_8BIT, 0x303C, 0x3C},    /* PLL oscillation stable wait time */
+	{IMX_8BIT, 0x30A4, 0x02},    /* Default */
+	{IMX_8BIT, 0x0112, 0x0A},    /* CCP_data_format : RAW 10bit */
+	{IMX_8BIT, 0x0113, 0x0A},    /* CCP_data_format :  RAW 10bit */
+	{IMX_8BIT, 0x0340, 0x04},    /* frame length line [15:8] */
+	{IMX_8BIT, 0x0341, 0xAA},    /* frame length line [7:0] */
+	{IMX_8BIT, 0x0342, 0x08},    /* line length pck [15:8] */
+	{IMX_8BIT, 0x0343, 0xC8},    /* line length pck [7:0] */
+	{IMX_8BIT, 0x0344, 0x00},    /* x_addr_start[12:8] */
+	{IMX_8BIT, 0x0345, 0x00},    /* x_addr_start[7:0] */
+	{IMX_8BIT, 0x0346, 0x00},    /* y_addr_start[12:8] */
+	{IMX_8BIT, 0x0347, 0x00},    /* y_addr_start[7:0] */
+	{IMX_8BIT, 0x0348, 0x07},    /* x_addr_end [12:8] */
+	{IMX_8BIT, 0x0349, 0x8F},    /* x_addr_end [7:0] */
+	{IMX_8BIT, 0x034A, 0x04},    /* y_addr_end [12:8] */
+	{IMX_8BIT, 0x034B, 0x47},    /* y_addr_end [7:0] */
+	{IMX_8BIT, 0x034C, 0x07},    /* x_output_size [ 12:8] */
+	{IMX_8BIT, 0x034D, 0x90},    /* x_output_size [7:0] */
+	{IMX_8BIT, 0x034E, 0x04},    /* y_output_size [11:8] */
+	{IMX_8BIT, 0x034F, 0x48},    /* y_output_size [7:0] */
+	{IMX_8BIT, 0x0381, 0x01},    /* x_even_inc */
+	{IMX_8BIT, 0x0383, 0x01},    /* x_odd_inc */
+	{IMX_8BIT, 0x0385, 0x01},    /* y_even_inc */
+	{IMX_8BIT, 0x0387, 0x01},    /* y_odd_inc */
+	{IMX_8BIT, 0x3048, 0x00},    /* VMODEFDS  binning operation */
+	{IMX_8BIT, 0x304E, 0x0A},    /* VTPXCK_DIV */
+	{IMX_8BIT, 0x3050, 0x02},    /* OPSYCK_DIV */
+	{IMX_8BIT, 0x309B, 0x00},    /* RGDAFDSUMEN */
+	{IMX_8BIT, 0x30D5, 0x00},    /* HADDEN ( binning ) */
+	{IMX_8BIT, 0x3301, 0x01},    /* RGLANESEL */
+	{IMX_8BIT, 0x3318, 0x61},    /* MIPI Global Timing */
+	{IMX_8BIT, 0x0202, 0x01},    /* coarse integration time */
+	{IMX_8BIT, 0x0203, 0x90},    /* coarse integration time */
+	{IMX_8BIT, 0x0205, 0x00},    /* ana global gain */
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx208_1296x736_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0305, 0x02},    /* PREPLLCK DIV */
+	{IMX_8BIT, 0x0307, 0x54},    /* PLL MPY */
+	{IMX_8BIT, 0x303C, 0x3C},    /* PLL oscillation stable wait time */
+	{IMX_8BIT, 0x30A4, 0x02},    /* Default */
+	{IMX_8BIT, 0x0112, 0x0A},    /* CCP_data_format : RAW 10bit */
+	{IMX_8BIT, 0x0113, 0x0A},    /* CCP_data_format :  RAW 10bit */
+	{IMX_8BIT, 0x0340, 0x04},    /* frame length line [15:8] */
+	{IMX_8BIT, 0x0341, 0xAA},    /* frame length line [7:0] */
+	{IMX_8BIT, 0x0342, 0x08},    /* line length pck [15:8] */
+	{IMX_8BIT, 0x0343, 0xC8},    /* line length pck [7:0] */
+	{IMX_8BIT, 0x0344, 0x01},    /* x_addr_start[12:8] */
+	{IMX_8BIT, 0x0345, 0x40},    /* x_addr_start[7:0] */
+	{IMX_8BIT, 0x0346, 0x00},    /* y_addr_start[12:8] */
+	{IMX_8BIT, 0x0347, 0xB4},    /* y_addr_start[7:0] */
+	{IMX_8BIT, 0x0348, 0x06},    /* x_addr_end [12:8] */
+	{IMX_8BIT, 0x0349, 0x4F},    /* x_addr_end [7:0] */
+	{IMX_8BIT, 0x034A, 0x03},    /* y_addr_end [12:8] */
+	{IMX_8BIT, 0x034B, 0x93},    /* y_addr_end [7:0] */
+	{IMX_8BIT, 0x034C, 0x05},    /* x_output_size [ 12:8] */
+	{IMX_8BIT, 0x034D, 0x10},    /* x_output_size [7:0] */
+	{IMX_8BIT, 0x034E, 0x02},    /* y_output_size [11:8] */
+	{IMX_8BIT, 0x034F, 0xE0},    /* y_output_size [7:0] */
+	{IMX_8BIT, 0x0381, 0x01},    /* x_even_inc */
+	{IMX_8BIT, 0x0383, 0x01},    /* x_odd_inc */
+	{IMX_8BIT, 0x0385, 0x01},    /* y_even_inc */
+	{IMX_8BIT, 0x0387, 0x01},    /* y_odd_inc */
+	{IMX_8BIT, 0x3048, 0x00},    /* VMODEFDS  binning operation */
+	{IMX_8BIT, 0x304E, 0x0A},    /* VTPXCK_DIV */
+	{IMX_8BIT, 0x3050, 0x02},    /* OPSYCK_DIV */
+	{IMX_8BIT, 0x309B, 0x00},    /* RGDAFDSUMEN */
+	{IMX_8BIT, 0x30D5, 0x00},    /* HADDEN ( binning ) */
+	{IMX_8BIT, 0x3301, 0x01},    /* RGLANESEL */
+	{IMX_8BIT, 0x3318, 0x61},    /* MIPI Global Timing */
+	{IMX_8BIT, 0x0202, 0x01},    /* coarse integration time */
+	{IMX_8BIT, 0x0203, 0x90},    /* coarse integration time */
+	{IMX_8BIT, 0x0205, 0x00},    /* ana global gain */
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx208_1296x976_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0305, 0x02},    /* PREPLLCK DIV */
+	{IMX_8BIT, 0x0307, 0x54},    /* PLL MPY */
+	{IMX_8BIT, 0x303C, 0x3C},    /* PLL oscillation stable wait time */
+	{IMX_8BIT, 0x30A4, 0x02},    /* Default */
+	{IMX_8BIT, 0x0112, 0x0A},    /* CCP_data_format : RAW 10bit */
+	{IMX_8BIT, 0x0113, 0x0A},    /* CCP_data_format :  RAW 10bit */
+	{IMX_8BIT, 0x0340, 0x04},    /* frame length line [15:8] */
+	{IMX_8BIT, 0x0341, 0xAA},    /* frame length line [7:0] */
+	{IMX_8BIT, 0x0342, 0x08},    /* line length pck [15:8] */
+	{IMX_8BIT, 0x0343, 0xC8},    /* line length pck [7:0] */
+	{IMX_8BIT, 0x0344, 0x01},    /* x_addr_start[12:8] */
+	{IMX_8BIT, 0x0345, 0x40},    /* x_addr_start[7:0] */
+	{IMX_8BIT, 0x0346, 0x00},    /* y_addr_start[12:8] */
+	{IMX_8BIT, 0x0347, 0x3C},    /* y_addr_start[7:0] */
+	{IMX_8BIT, 0x0348, 0x06},    /* x_addr_end [12:8] */
+	{IMX_8BIT, 0x0349, 0x4F},    /* x_addr_end [7:0] */
+	{IMX_8BIT, 0x034A, 0x04},    /* y_addr_end [12:8] */
+	{IMX_8BIT, 0x034B, 0x0B},    /* y_addr_end [7:0] */
+	{IMX_8BIT, 0x034C, 0x05},    /* x_output_size [ 12:8] */
+	{IMX_8BIT, 0x034D, 0x10},    /* x_output_size [7:0] */
+	{IMX_8BIT, 0x034E, 0x03},    /* y_output_size [11:8] */
+	{IMX_8BIT, 0x034F, 0xD0},    /* y_output_size [7:0] */
+	{IMX_8BIT, 0x0381, 0x01},    /* x_even_inc */
+	{IMX_8BIT, 0x0383, 0x01},    /* x_odd_inc */
+	{IMX_8BIT, 0x0385, 0x01},    /* y_even_inc */
+	{IMX_8BIT, 0x0387, 0x01},    /* y_odd_inc */
+	{IMX_8BIT, 0x3048, 0x00},    /* VMODEFDS  binning operation */
+	{IMX_8BIT, 0x304E, 0x0A},    /* VTPXCK_DIV */
+	{IMX_8BIT, 0x3050, 0x02},    /* OPSYCK_DIV */
+	{IMX_8BIT, 0x309B, 0x00},    /* RGDAFDSUMEN */
+	{IMX_8BIT, 0x30D5, 0x00},    /* HADDEN ( binning ) */
+	{IMX_8BIT, 0x3301, 0x01},    /* RGLANESEL */
+	{IMX_8BIT, 0x3318, 0x61},    /* MIPI Global Timing */
+	{IMX_8BIT, 0x0202, 0x01},    /* coarse integration time */
+	{IMX_8BIT, 0x0203, 0x90},    /* coarse integration time */
+	{IMX_8BIT, 0x0205, 0x00},    /* ana global gain */
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx208_336x256_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0305, 0x02},    /* PREPLLCK DIV */
+	{IMX_8BIT, 0x0307, 0x54},    /* PLL MPY */
+	{IMX_8BIT, 0x303C, 0x3C},    /* PLL oscillation stable wait time */
+	{IMX_8BIT, 0x30A4, 0x02},    /* Default */
+	{IMX_8BIT, 0x0112, 0x0A},    /* CCP_data_format : RAW 10bit */
+	{IMX_8BIT, 0x0113, 0x0A},    /* CCP_data_format :  RAW 10bit */
+	{IMX_8BIT, 0x0340, 0x04},    /* frame length line [15:8] */
+	{IMX_8BIT, 0x0341, 0xAA},    /* frame length line [7:0] */
+	{IMX_8BIT, 0x0342, 0x08},    /* line length pck [15:8] */
+	{IMX_8BIT, 0x0343, 0xC8},    /* line length pck [7:0] */
+	{IMX_8BIT, 0x0344, 0x02},    /* x_addr_start[12:8] */
+	{IMX_8BIT, 0x0345, 0x78},    /* x_addr_start[7:0] */
+	{IMX_8BIT, 0x0346, 0x01},    /* y_addr_start[12:8] */
+	{IMX_8BIT, 0x0347, 0x24},    /* y_addr_start[7:0] */
+	{IMX_8BIT, 0x0348, 0x05},    /* x_addr_end [12:8] */
+	{IMX_8BIT, 0x0349, 0x17},    /* x_addr_end [7:0] */
+	{IMX_8BIT, 0x034A, 0x03},    /* y_addr_end [12:8] */
+	{IMX_8BIT, 0x034B, 0x23},    /* y_addr_end [7:0] */
+	{IMX_8BIT, 0x034C, 0x01},    /* x_output_size [ 12:8] */
+	{IMX_8BIT, 0x034D, 0x50},    /* x_output_size [7:0] */
+	{IMX_8BIT, 0x034E, 0x01},    /* y_output_size [11:8] */
+	{IMX_8BIT, 0x034F, 0x00},    /* y_output_size [7:0] */
+	{IMX_8BIT, 0x0381, 0x01},    /* x_even_inc */
+	{IMX_8BIT, 0x0383, 0x03},    /* x_odd_inc */
+	{IMX_8BIT, 0x0385, 0x01},    /* y_even_inc */
+	{IMX_8BIT, 0x0387, 0x03},    /* y_odd_inc */
+	{IMX_8BIT, 0x3048, 0x01},    /* VMODEFDS  binning operation */
+	{IMX_8BIT, 0x304E, 0x0A},    /* VTPXCK_DIV */
+	{IMX_8BIT, 0x3050, 0x02},    /* OPSYCK_DIV */
+	{IMX_8BIT, 0x309B, 0x00},    /* RGDAFDSUMEN */
+	{IMX_8BIT, 0x30D5, 0x03},    /* HADDEN ( binning ) */
+	{IMX_8BIT, 0x3301, 0x01},    /* RGLANESEL */
+	{IMX_8BIT, 0x3318, 0x66},    /* MIPI Global Timing */
+	{IMX_8BIT, 0x0202, 0x01},    /* coarse integration time */
+	{IMX_8BIT, 0x0203, 0x90},    /* coarse integration time */
+	{IMX_8BIT, 0x0205, 0x00},    /* ana global gain */
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx208_192x160_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0305, 0x02},    /* PREPLLCK DIV */
+	{IMX_8BIT, 0x0307, 0x54},    /* PLL MPY */
+	{IMX_8BIT, 0x303C, 0x3C},    /* PLL oscillation stable wait time */
+	{IMX_8BIT, 0x30A4, 0x02},    /* Default */
+	{IMX_8BIT, 0x0112, 0x0A},    /* CCP_data_format : RAW 10bit */
+	{IMX_8BIT, 0x0113, 0x0A},    /* CCP_data_format :  RAW 10bit */
+	{IMX_8BIT, 0x0340, 0x04},    /* frame length line [15:8] */
+	{IMX_8BIT, 0x0341, 0xAA},    /* frame length line [7:0] */
+	{IMX_8BIT, 0x0342, 0x08},    /* line length pck [15:8] */
+	{IMX_8BIT, 0x0343, 0xC8},    /* line length pck [7:0] */
+	{IMX_8BIT, 0x0344, 0x02},    /* x_addr_start[12:8] */
+	{IMX_8BIT, 0x0345, 0x48},    /* x_addr_start[7:0] */
+	{IMX_8BIT, 0x0346, 0x00},    /* y_addr_start[12:8] */
+	{IMX_8BIT, 0x0347, 0xE4},    /* y_addr_start[7:0] */
+	{IMX_8BIT, 0x0348, 0x05},    /* x_addr_end [12:8] */
+	{IMX_8BIT, 0x0349, 0x47},    /* x_addr_end [7:0] */
+	{IMX_8BIT, 0x034A, 0x03},    /* y_addr_end [12:8] */
+	{IMX_8BIT, 0x034B, 0x63},    /* y_addr_end [7:0] */
+	{IMX_8BIT, 0x034C, 0x00},    /* x_output_size [ 12:8] */
+	{IMX_8BIT, 0x034D, 0xC0},    /* x_output_size [7:0] */
+	{IMX_8BIT, 0x034E, 0x00},    /* y_output_size [11:8] */
+	{IMX_8BIT, 0x034F, 0xA0},    /* y_output_size [7:0] */
+	{IMX_8BIT, 0x0381, 0x03},    /* x_even_inc */
+	{IMX_8BIT, 0x0383, 0x05},    /* x_odd_inc */
+	{IMX_8BIT, 0x0385, 0x03},    /* y_even_inc */
+	{IMX_8BIT, 0x0387, 0x05},    /* y_odd_inc */
+	{IMX_8BIT, 0x3048, 0x01},    /* VMODEFDS  binning operation */
+	{IMX_8BIT, 0x304E, 0x0A},    /* VTPXCK_DIV */
+	{IMX_8BIT, 0x3050, 0x02},    /* OPSYCK_DIV */
+	{IMX_8BIT, 0x309B, 0x00},    /* RGDAFDSUMEN */
+	{IMX_8BIT, 0x30D5, 0x03},    /* HADDEN ( binning ) */
+	{IMX_8BIT, 0x3301, 0x11},    /* RGLANESEL */
+	{IMX_8BIT, 0x3318, 0x74},    /* MIPI Global Timing */
+	{IMX_8BIT, 0x0202, 0x01},    /* coarse integration time */
+	{IMX_8BIT, 0x0203, 0x90},    /* coarse integration time */
+	{IMX_8BIT, 0x0205, 0x00},    /* ana global gain */
+
+	{IMX_TOK_TERM, 0, 0},
+};
+/********************** settings for imx - reference *********************/
+static struct imx_reg const imx208_init_settings[] = {
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+struct imx_resolution imx208_res_preview[] = {
+	{
+		.desc = "imx208_1080p_30fps",
+		.regs = imx208_1080p_30fps,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_1296x976_30fps",
+		.regs = imx208_1296x976_30fps,
+		.width = 1296,
+		.height = 976,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_1296x736_30fps",
+		.regs = imx208_1296x736_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_336x256_30fps",
+		.regs = imx208_336x256_30fps,
+		.width = 336,
+		.height = 256,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 201600,
+	},
+	{
+		.desc = "imx208_192x160_30fps",
+		.regs = imx208_192x160_30fps,
+		.width = 192,
+		.height = 160,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 100800,
+	},
+};
+
+struct imx_resolution imx208_res_still[] = {
+	{
+		.desc = "imx208_1080p_30fps",
+		.regs = imx208_1080p_30fps,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_1296x976_30fps",
+		.regs = imx208_1296x976_30fps,
+		.width = 1296,
+		.height = 976,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_1296x736_30fps",
+		.regs = imx208_1296x736_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_336x256_30fps",
+		.regs = imx208_336x256_30fps,
+		.width = 336,
+		.height = 256,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 201600,
+	},
+	{
+		.desc = "imx208_192x160_30fps",
+		.regs = imx208_192x160_30fps,
+		.width = 192,
+		.height = 160,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 100800,
+	},
+};
+
+struct imx_resolution imx208_res_video[] = {
+	{
+		.desc = "imx208_1080p_30fps",
+		.regs = imx208_1080p_30fps,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_1296x976_30fps",
+		.regs = imx208_1296x976_30fps,
+		.width = 1296,
+		.height = 976,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_1296x736_30fps",
+		.regs = imx208_1296x736_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx208_336x256_30fps",
+		.regs = imx208_336x256_30fps,
+		.width = 336,
+		.height = 256,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 201600,
+	},
+	{
+		.desc = "imx208_192x160_30fps",
+		.regs = imx208_192x160_30fps,
+		.width = 192,
+		.height = 160,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08C8,
+				.lines_per_frame = 0x04AA,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 100800,
+	},
+};
+#endif
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx219.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx219.h
new file mode 100644
index 0000000..52df582
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx219.h
@@ -0,0 +1,227 @@
+#ifndef __IMX219_H__
+#define __IMX219_H__
+#include "common.h"
+
+#define IMX219_FRAME_LENGTH_LINES		0x0160
+#define IMX219_LINE_LENGTH_PIXELS		0x0162
+#define IMX219_HORIZONTAL_START_H		0x0164
+#define IMX219_VERTICAL_START_H			0x0168
+#define IMX219_HORIZONTAL_END_H			0x0166
+#define IMX219_VERTICAL_END_H			0x016A
+#define IMX219_HORIZONTAL_OUTPUT_SIZE_H	0x016c
+#define IMX219_VERTICAL_OUTPUT_SIZE_H	0x016E
+#define IMX219_COARSE_INTEGRATION_TIME	0x015A
+#define IMX219_IMG_ORIENTATION			0x0172
+#define IMX219_GLOBAL_GAIN				0x0157
+#define IMX219_DGC_ADJ					0x0158
+
+#define IMX219_DGC_LEN					4
+
+/************************** settings for imx *************************/
+static struct imx_reg const imx219_STILL_8M_30fps[] = {
+	{IMX_8BIT, 0x30EB, 0x05}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x30EB, 0x0C}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x300A, 0xFF}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x300B, 0xFF}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x30EB, 0x05}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x30EB, 0x09}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x0114, 0x03}, /*CSI_LANE_MODE[1:0}*/
+	{IMX_8BIT, 0x0128, 0x00}, /*DPHY_CNTRL*/
+	{IMX_8BIT, 0x012A, 0x13}, /*EXCK_FREQ[15:8]*/
+	{IMX_8BIT, 0x012B, 0x34}, /*EXCK_FREQ[7:0]*/
+	{IMX_8BIT, 0x0160, 0x0A}, /*FRM_LENGTH_A[15:8]*/
+	{IMX_8BIT, 0x0161, 0x94}, /*FRM_LENGTH_A[7:0]*/
+	{IMX_8BIT, 0x0162, 0x0D}, /*LINE_LENGTH_A[15:8]*/
+	{IMX_8BIT, 0x0163, 0x78}, /*LINE_LENGTH_A[7:0]*/
+	{IMX_8BIT, 0x0164, 0x00}, /*X_ADD_STA_A[11:8]*/
+	{IMX_8BIT, 0x0165, 0x00}, /*X_ADD_STA_A[7:0]*/
+	{IMX_8BIT, 0x0166, 0x0C}, /*X_ADD_END_A[11:8]*/
+	{IMX_8BIT, 0x0167, 0xCF}, /*X_ADD_END_A[7:0]*/
+	{IMX_8BIT, 0x0168, 0x00}, /*Y_ADD_STA_A[11:8]*/
+	{IMX_8BIT, 0x0169, 0x00}, /*Y_ADD_STA_A[7:0]*/
+	{IMX_8BIT, 0x016A, 0x09}, /*Y_ADD_END_A[11:8]*/
+	{IMX_8BIT, 0x016B, 0x9F}, /*Y_ADD_END_A[7:0]*/
+	{IMX_8BIT, 0x016C, 0x0C}, /*X_OUTPUT_SIZE_A[11:8]*/
+	{IMX_8BIT, 0x016D, 0xD0}, /*X_OUTPUT_SIZE_A[7:0]*/
+	{IMX_8BIT, 0x016E, 0x09}, /*Y_OUTPUT_SIZE_A[11:8]*/
+	{IMX_8BIT, 0x016F, 0xA0}, /*Y_OUTPUT_SIZE_A[7:0]*/
+	{IMX_8BIT, 0x0170, 0x01}, /*X_ODD_INC_A[2:0]*/
+	{IMX_8BIT, 0x0171, 0x01}, /*Y_ODD_INC_A[2:0]*/
+	{IMX_8BIT, 0x0174, 0x00}, /*BINNING_MODE_H_A*/
+	{IMX_8BIT, 0x0175, 0x00}, /*BINNING_MODE_V_A*/
+	{IMX_8BIT, 0x018C, 0x0A}, /*CSI_DATA_FORMAT_A[15:8]*/
+	{IMX_8BIT, 0x018D, 0x0A}, /*CSI_DATA_FORMAT_A[7:0]*/
+	{IMX_8BIT, 0x0301, 0x05}, /*VTPXCK_DIV*/
+	{IMX_8BIT, 0x0303, 0x01}, /*VTSYCK_DIV*/
+	{IMX_8BIT, 0x0304, 0x02}, /*PREPLLCK_VT_DIV[3:0]*/
+	{IMX_8BIT, 0x0305, 0x02}, /*PREPLLCK_OP_DIV[3:0]*/
+	{IMX_8BIT, 0x0306, 0x00}, /*PLL_VT_MPY[10:8]*/
+	{IMX_8BIT, 0x0307, 0x49}, /*PLL_VT_MPY[7:0]*/
+	{IMX_8BIT, 0x0309, 0x0A}, /*OPPXCK_DIV[4:0]*/
+	{IMX_8BIT, 0x030B, 0x01}, /*OPSYCK_DIV*/
+	{IMX_8BIT, 0x030C, 0x00}, /*PLL_OP_MPY[10:8]*/
+	{IMX_8BIT, 0x030D, 0x4C}, /*PLL_OP_MPY[7:0]*/
+	{IMX_8BIT, 0x4767, 0x0F}, /*CIS Tuning*/
+	{IMX_8BIT, 0x4750, 0x14}, /*CIS Tuning*/
+	{IMX_8BIT, 0x47B4, 0x14}, /*CIS Tuning*/
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx219_STILL_6M_30fps[] = {
+	{IMX_8BIT, 0x30EB, 0x05}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x30EB, 0x0C}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x300A, 0xFF}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x300B, 0xFF}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x30EB, 0x05}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x30EB, 0x09}, /*Access Code for address over 0x3000*/
+	{IMX_8BIT, 0x0114, 0x03}, /*CSI_LANE_MODE[1:0}*/
+	{IMX_8BIT, 0x0128, 0x00}, /*DPHY_CNTRL*/
+	{IMX_8BIT, 0x012A, 0x13}, /*EXCK_FREQ[15:8]*/
+	{IMX_8BIT, 0x012B, 0x34}, /*EXCK_FREQ[7:0]*/
+	{IMX_8BIT, 0x0160, 0x07}, /*FRM_LENGTH_A[15:8]*/
+	{IMX_8BIT, 0x0161, 0x64}, /*FRM_LENGTH_A[7:0]*/
+	{IMX_8BIT, 0x0162, 0x0D}, /*LINE_LENGTH_A[15:8]*/
+	{IMX_8BIT, 0x0163, 0x78}, /*LINE_LENGTH_A[7:0]*/
+	{IMX_8BIT, 0x0164, 0x00}, /*X_ADD_STA_A[11:8]*/
+	{IMX_8BIT, 0x0165, 0x00}, /*X_ADD_STA_A[7:0]*/
+	{IMX_8BIT, 0x0166, 0x0C}, /*X_ADD_END_A[11:8]*/
+	{IMX_8BIT, 0x0167, 0xCF}, /*X_ADD_END_A[7:0]*/
+	{IMX_8BIT, 0x0168, 0x01}, /*Y_ADD_STA_A[11:8]*/
+	{IMX_8BIT, 0x0169, 0x32}, /*Y_ADD_STA_A[7:0]*/
+	{IMX_8BIT, 0x016A, 0x08}, /*Y_ADD_END_A[11:8]*/
+	{IMX_8BIT, 0x016B, 0x6D}, /*Y_ADD_END_A[7:0]*/
+	{IMX_8BIT, 0x016C, 0x0C}, /*X_OUTPUT_SIZE_A[11:8]*/
+	{IMX_8BIT, 0x016D, 0xD0}, /*X_OUTPUT_SIZE_A[7:0]*/
+	{IMX_8BIT, 0x016E, 0x07}, /*Y_OUTPUT_SIZE_A[11:8]*/
+	{IMX_8BIT, 0x016F, 0x3C}, /*Y_OUTPUT_SIZE_A[7:0]*/
+	{IMX_8BIT, 0x0170, 0x01}, /*X_ODD_INC_A[2:0]*/
+	{IMX_8BIT, 0x0171, 0x01}, /*Y_ODD_INC_A[2:0]*/
+	{IMX_8BIT, 0x0174, 0x00}, /*BINNING_MODE_H_A*/
+	{IMX_8BIT, 0x0175, 0x00}, /*BINNING_MODE_V_A*/
+	{IMX_8BIT, 0x018C, 0x0A}, /*CSI_DATA_FORMAT_A[15:8]*/
+	{IMX_8BIT, 0x018D, 0x0A}, /*CSI_DATA_FORMAT_A[7:0]*/
+	{IMX_8BIT, 0x0301, 0x05}, /*VTPXCK_DIV*/
+	{IMX_8BIT, 0x0303, 0x01}, /*VTSYCK_DIV*/
+	{IMX_8BIT, 0x0304, 0x02}, /*PREPLLCK_VT_DIV[3:0]*/
+	{IMX_8BIT, 0x0305, 0x02}, /*PREPLLCK_OP_DIV[3:0]*/
+	{IMX_8BIT, 0x0306, 0x00}, /*PLL_VT_MPY[10:8]*/
+	{IMX_8BIT, 0x0307, 0x33}, /*PLL_VT_MPY[7:0]*/
+	{IMX_8BIT, 0x0309, 0x0A}, /*OPPXCK_DIV[4:0]*/
+	{IMX_8BIT, 0x030B, 0x01}, /*OPSYCK_DIV*/
+	{IMX_8BIT, 0x030C, 0x00}, /*PLL_OP_MPY[10:8]*/
+	{IMX_8BIT, 0x030D, 0x36}, /*PLL_OP_MPY[7:0]*/
+	{IMX_8BIT, 0x4767, 0x0F}, /*CIS Tuning*/
+	{IMX_8BIT, 0x4750, 0x14}, /*CIS Tuning*/
+	{IMX_8BIT, 0x47B4, 0x14}, /*CIS Tuning*/
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx219_init_settings[] = {
+	{IMX_TOK_TERM, 0, 0}
+};
+
+struct imx_resolution imx219_res_preview[] = {
+	{
+		.desc = "STILL_6M_30fps",
+		.regs = imx219_STILL_6M_30fps,
+		.width = 3280,
+		.height = 1852,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D78,
+				 .lines_per_frame = 0x0764,
+			},
+			{
+			}
+		},
+		.mipi_freq = 259000,
+	},
+	{
+		.desc = "STILL_8M_30fps",
+		.regs = imx219_STILL_8M_30fps,
+		.width = 3280,
+		.height = 2464,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D78,
+				 .lines_per_frame = 0x0A94,
+			},
+			{
+			}
+		},
+		.mipi_freq = 365000,
+	},
+};
+
+struct imx_resolution imx219_res_still[] = {
+	{
+		.desc = "STILL_6M_30fps",
+		.regs = imx219_STILL_6M_30fps,
+		.width = 3280,
+		.height = 1852,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D78,
+				 .lines_per_frame = 0x0764,
+			},
+			{
+			}
+		},
+		.mipi_freq = 259000,
+	},
+	{
+		.desc = "STILL_8M_30fps",
+		.regs = imx219_STILL_8M_30fps,
+		.width = 3280,
+		.height = 2464,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D78,
+				 .lines_per_frame = 0x0A94,
+			},
+			{
+			}
+		},
+		.mipi_freq = 365000,
+	},
+};
+
+struct imx_resolution imx219_res_video[] = {
+	{
+		.desc = "STILL_6M_30fps",
+		.regs = imx219_STILL_6M_30fps,
+		.width = 3280,
+		.height = 1852,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D78,
+				 .lines_per_frame = 0x0764,
+			},
+			{
+			}
+		},
+		.mipi_freq = 259000,
+	},
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c
index 4622750..e60014c 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c
@@ -23,6 +23,9 @@
 #include <linux/mm.h>
 #include <linux/string.h>
 #include <linux/types.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-device.h>
 
 void *dummy_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_brcc064_e2prom.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_brcc064_e2prom.c
new file mode 100644
index 0000000..7dffa9b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_brcc064_e2prom.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
+#include <media/v4l2-device.h>
+#include "common.h"
+
+/*
+ * Read EEPROM data from brcc064 and store
+ * it into a kmalloced buffer. On error return NULL.
+ * @size: set to the size of the returned EEPROM data.
+ */
+void *brcc064_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int e2prom_i2c_addr = dev_addr >> 1;
+	static const unsigned int max_read_size = 30;
+	int addr;
+	u32 s_addr = start_addr & E2PROM_ADDR_MASK;
+	unsigned char *buffer;
+
+	buffer = devm_kzalloc(&client->dev, size, GFP_KERNEL);
+	if (!buffer)
+		return NULL;
+
+	for (addr = s_addr; addr < size; addr += max_read_size) {
+		struct i2c_msg msg[2];
+		unsigned int i2c_addr = e2prom_i2c_addr;
+		u16 addr_buf;
+		int r;
+
+		msg[0].flags = 0;
+		msg[0].addr = i2c_addr;
+		addr_buf = cpu_to_be16(addr & 0xFFFF);
+		msg[0].len = 2;
+		msg[0].buf = (u8 *)&addr_buf;
+
+		msg[1].addr = i2c_addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].len = min(max_read_size, size - addr);
+		msg[1].buf = &buffer[addr];
+
+		r = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+		if (r != ARRAY_SIZE(msg)) {
+			kfree(buffer);
+			dev_err(&client->dev, "read failed at 0x%03x\n", addr);
+			return NULL;
+		}
+	}
+	return buffer;
+
+}
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c
index ce4e7ab..2772d05 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c
@@ -28,6 +28,9 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/types.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-device.h>
 #include "common.h"
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c
index ba98ff3..915f9b9 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c
@@ -29,6 +29,9 @@
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#ifndef CONFIG_GMIN_INTEL_MID /* FIXME! for non-gmin*/
+#include <media/v4l2-chip-ident.h>
+#endif
 #include <media/v4l2-device.h>
 #include <asm/intel-mid.h>
 #include "common.h"
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
index 17b15b4..c587d39 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
@@ -29,9 +29,10 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 #include <linux/acpi.h>
+#ifdef CONFIG_GMIN_INTEL_MID
 #include <linux/gpio/consumer.h>
 #include <linux/atomisp_gmin_platform.h>
-
+#endif
 #include <linux/atomisp.h>
 
 struct lm3554_ctrl_id {
@@ -428,6 +429,7 @@ static int lm3554_g_flash_status(struct v4l2_subdev *sd, s32 *val)
 	return 0;
 }
 
+#ifndef CSS15
 static int lm3554_g_flash_status_register(struct v4l2_subdev *sd, s32 *val)
 {
 	struct lm3554 *flash = to_lm3554(sd);
@@ -441,6 +443,7 @@ static int lm3554_g_flash_status_register(struct v4l2_subdev *sd, s32 *val)
 	*val = ret;
 	return 0;
 }
+#endif
 
 static const struct lm3554_ctrl_id lm3554_ctrls[] = {
 	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TIMEOUT,
@@ -503,6 +506,7 @@ static const struct lm3554_ctrl_id lm3554_ctrls[] = {
 				0,
 				NULL,
 				lm3554_g_flash_status),
+#ifndef CSS15
 	s_ctrl_id_entry_integer(V4L2_CID_FLASH_STATUS_REGISTER,
 				"Flash Status Register",
 				0,   /* don't assume any enum ID is first */
@@ -512,6 +516,7 @@ static const struct lm3554_ctrl_id lm3554_ctrls[] = {
 				0,
 				NULL,
 				lm3554_g_flash_status_register),
+#endif
 };
 
 static const struct lm3554_ctrl_id *find_ctrl_id(unsigned int id)
@@ -754,17 +759,29 @@ static int lm3554_gpio_init(struct i2c_client *client)
 	struct lm3554_platform_data *pdata = flash->pdata;
 	int ret;
 
+#ifdef CONFIG_GMIN_INTEL_MID
+	if (!gpio_is_valid(pdata->gpio_reset))
+		return -EINVAL;
+#else
 	ret = gpio_request(pdata->gpio_reset, "flash reset");
 	if (ret < 0)
 		return ret;
+#endif
 
 	ret = gpio_direction_output(pdata->gpio_reset, 1);
 	if (ret < 0)
 		goto err_gpio_reset;
 
+#ifdef CONFIG_GMIN_INTEL_MID
+	if (!gpio_is_valid(pdata->gpio_strobe)) {
+		ret = -EINVAL;
+		goto err_gpio_dir_reset;
+	}
+#else
 	ret = gpio_request(pdata->gpio_strobe, "flash");
 	if (ret < 0)
 		goto err_gpio_dir_reset;
+#endif
 
 	ret = gpio_direction_output(pdata->gpio_strobe, 0);
 	if (ret < 0)
@@ -802,6 +819,8 @@ static int lm3554_gpio_uninit(struct i2c_client *client)
 	return 0;
 }
 
+
+#ifdef CONFIG_GMIN_INTEL_MID
 void *lm3554_platform_data_func(struct i2c_client *client)
 {
 	static struct lm3554_platform_data platform_data;
@@ -813,6 +832,10 @@ void *lm3554_platform_data_func(struct i2c_client *client)
 			desc_to_gpio(gpiod_get_index(&(client->dev), "lm3554_gpio0", 0));
 		platform_data.gpio_torch  =
 			desc_to_gpio(gpiod_get_index(&(client->dev), "lm3554_gpio1", 1));
+	}else {
+		platform_data.gpio_reset = -1;
+		platform_data.gpio_strobe = -1;
+		platform_data.gpio_torch = -1;
 	}
 
 	dev_info(&client->dev, "camera pdata: lm3554: reset: %d strobe %d torch %d\n",
@@ -831,6 +854,7 @@ void *lm3554_platform_data_func(struct i2c_client *client)
 
 	return &platform_data;
 }
+#endif
 
 static int lm3554_probe(struct i2c_client *client,
 				  const struct i2c_device_id *id)
@@ -838,10 +862,12 @@ static int lm3554_probe(struct i2c_client *client,
 	int err;
 	struct lm3554 *flash;
 
+#ifndef CONFIG_GMIN_INTEL_MID
 	if (client->dev.platform_data == NULL) {
 		dev_err(&client->dev, "no platform data\n");
 		return -ENODEV;
 	}
+#endif
 
 	flash = kzalloc(sizeof(*flash), GFP_KERNEL);
 	if (!flash) {
@@ -851,8 +877,10 @@ static int lm3554_probe(struct i2c_client *client,
 
 	flash->pdata = client->dev.platform_data;
 
+#ifdef CONFIG_GMIN_INTEL_MID
 	if (!flash->pdata || ACPI_COMPANION(&client->dev))
 		flash->pdata = lm3554_platform_data_func(client);
+#endif
 
 	v4l2_i2c_subdev_init(&flash->sd, client, &lm3554_ops);
 	flash->sd.internal_ops = &lm3554_internal_ops;
@@ -879,9 +907,10 @@ static int lm3554_probe(struct i2c_client *client,
 		goto fail2;
 	}
 
+#ifdef CONFIG_GMIN_INTEL_MID
 	if (ACPI_HANDLE(&client->dev))
 		err = atomisp_register_i2c_module(&flash->sd, NULL, LED_FLASH);
-
+#endif
 	return 0;
 fail2:
 	media_entity_cleanup(&flash->sd.entity);
@@ -932,6 +961,8 @@ static struct acpi_device_id lm3554_acpi_match[] = {
 	{},
 };
 
+MODULE_DEVICE_TABLE(acpi, lm3554_acpi_match);
+
 static struct i2c_driver lm3554_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
index 45579d7..8a7578e 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
@@ -88,7 +88,7 @@ struct lm3559_ctrl_id {
 
 #define LM3559_CONFIG_REG_1_INIT_SETTING	0x6c
 #define LM3559_CONFIG_REG_2_INIT_SETTING	0x01
-#define LM3559_CONFIG_REG_2_INIT_SETTING_LM3560	0x11
+#define LM3559_CONFIG_REG_2_INIT_SETTING_LM3560	0x01
 #define LM3559_GPIO_REG_INIT_SETTING		0x00
 
 #define LM3559_ENVM_TX2_SHIFT		0
@@ -517,6 +517,7 @@ static int lm3559_g_flash_status(struct v4l2_subdev *sd, s32 *val)
 	return 0;
 }
 
+#ifndef CSS15
 static int lm3559_g_flash_status_register(struct v4l2_subdev *sd, s32 *val)
 {
 	struct lm3559 *flash = to_lm3559(sd);
@@ -530,6 +531,7 @@ static int lm3559_g_flash_status_register(struct v4l2_subdev *sd, s32 *val)
 	*val = ret;
 	return 0;
 }
+#endif
 
 static const struct lm3559_ctrl_id lm3559_ctrls[] = {
 	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TIMEOUT,
@@ -592,6 +594,7 @@ static const struct lm3559_ctrl_id lm3559_ctrls[] = {
 				0,
 				NULL,
 				lm3559_g_flash_status),
+#ifndef CSS15
 	s_ctrl_id_entry_integer(V4L2_CID_FLASH_STATUS_REGISTER,
 				"Flash Status Register",
 				0,   /* don't assume any enum ID is first */
@@ -601,6 +604,7 @@ static const struct lm3559_ctrl_id lm3559_ctrls[] = {
 				0,
 				NULL,
 				lm3559_g_flash_status_register),
+#endif
 };
 
 static const struct lm3559_ctrl_id *find_ctrl_id(unsigned int id)
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3642.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3642.c
new file mode 100644
index 0000000..38cc1b6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3642.c
@@ -0,0 +1,855 @@
+/*
+ * LED flash driver for LM3642
+ *
+ * Copyright (c) 2010-2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <media/lm3642.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+
+#include <linux/atomisp.h>
+
+struct lm3642_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl) (struct v4l2_subdev *sd, __u32 val);
+	int (*g_ctrl) (struct v4l2_subdev *sd, __s32 *val);
+};
+
+/* Registers */
+#define LM3642_CONTROL_REG		0x09
+#define LM3642_FLASH_CURRENT_SHIFT	0
+#define LM3642_TORCH_CURRENT_SHIFT	4
+
+#define LM3642_FEATURE_REG	0x08
+#define LM3642_FLASH_TIMEOUT_SHIFT	0
+#define LM3642_RAMP_SHIFT		3
+#define LM3642_INDICATOR_CURRENT_SHIFT	6
+
+#define LM3642_FLAGS_REG		0x0b
+#define LM3642_FLAG_TIMEOUT		(1 << 0)
+#define LM3642_FLAG_THERMAL_SHUTDOWN	(1 << 1)
+#define LM3642_FLAG_LED_FAULT		(1 << 2)
+#define LM3642_FLAG_OVP			(1 << 3)
+#define LM3642_FLAG_UVLO		(1 << 4)
+#define LM3642_FLAG_IVFM		(1 << 5)
+#define LM3642_FLAG_UNUSED		(3 << 6)
+
+#define LM3642_ENABLE_REG		0x0a
+#define LM3642_MODE_SHIFT		0
+#define LM3642_TORCH_EN_SHIFT		4
+#define LM3642_FLASH_EN_SHIFT		5
+#define LM3642_TX_EN_SHIFT		5
+#define LM3642_IVFM_EN_SHIFT		7
+
+struct lm3642 {
+	struct v4l2_subdev sd;
+
+	struct mutex power_lock;
+	int power_count;
+
+	unsigned int mode;
+	int timeout;
+	int ramp_time;
+	u8 torch_current;
+	u8 indicator_current;
+	u8 flash_current;
+
+	struct timer_list flash_off_delay;
+	struct lm3642_platform_data *pdata;
+};
+
+#define to_lm3642(p_sd)	container_of(p_sd, struct lm3642, sd)
+
+/* Return negative errno else zero on success */
+static int lm3642_write(struct lm3642 *flash, u8 addr, u8 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, addr, val);
+
+	dev_dbg(&client->dev, "Write Addr:%02X Val:%02X %s\n", addr, val,
+		ret < 0 ? "fail" : "ok");
+
+	return ret;
+}
+
+/* Return negative errno else a data byte received from the device. */
+static int lm3642_read(struct lm3642 *flash, u8 addr)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, addr);
+
+	dev_dbg(&client->dev, "Read Addr:%02X Val:%02X %s\n", addr, ret,
+		ret < 0 ? "fail" : "ok");
+
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * Hardware configuration
+ */
+
+static int lm3642_set_mode(struct lm3642 *flash, unsigned int mode)
+{
+	u8 val;
+	int ret;
+
+	val = (mode << LM3642_MODE_SHIFT) |
+	      (flash->pdata->torch_en << LM3642_TORCH_EN_SHIFT) |
+	      (flash->pdata->flash_en << LM3642_TORCH_EN_SHIFT) |
+	      (flash->pdata->tx_en << LM3642_TX_EN_SHIFT) |
+	      (flash->pdata->ivfm_en << LM3642_IVFM_EN_SHIFT);
+
+	ret = lm3642_write(flash, LM3642_ENABLE_REG, val);
+	if (ret == 0)
+		flash->mode = mode;
+	return ret;
+}
+
+static int lm3642_set_current(struct lm3642 *flash)
+{
+	u8 val;
+
+	val = (flash->torch_current << LM3642_TORCH_CURRENT_SHIFT) |
+	      (flash->flash_current << LM3642_FLASH_CURRENT_SHIFT);
+
+	return lm3642_write(flash, LM3642_CONTROL_REG, val);
+}
+
+static int lm3642_set_feature(struct lm3642 *flash)
+{
+	u8 val;
+
+	val = (flash->timeout << LM3642_FLASH_TIMEOUT_SHIFT) |
+	      (flash->ramp_time << LM3642_RAMP_SHIFT) |
+	      (flash->indicator_current << LM3642_INDICATOR_CURRENT_SHIFT);
+	return lm3642_write(flash, LM3642_FEATURE_REG, val);
+}
+
+static int lm3642_set_enable(struct lm3642 *flash)
+{
+	u8 val;
+	val = (flash->mode << LM3642_MODE_SHIFT) |
+	      (flash->pdata->torch_en << LM3642_TORCH_EN_SHIFT) |
+	      (flash->pdata->flash_en << LM3642_FLASH_EN_SHIFT) |
+	      (flash->pdata->tx_en << LM3642_TX_EN_SHIFT) |
+	      (flash->pdata->ivfm_en << LM3642_IVFM_EN_SHIFT);
+	return lm3642_write(flash, LM3642_ENABLE_REG, val);
+}
+
+static void lm3642_flash_off_delay(long unsigned int arg)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata((struct i2c_client *)arg);
+	struct lm3642 *flash = to_lm3642(sd);
+	struct lm3642_platform_data *pdata = flash->pdata;
+
+	gpio_set_value(pdata->gpio_strobe, 0);
+}
+
+static int lm3642_hw_strobe(struct i2c_client *client, bool strobe)
+{
+	int ret, timer_pending;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3642 *flash = to_lm3642(sd);
+	struct lm3642_platform_data *pdata = flash->pdata;
+
+	/*
+	 * An abnormal high flash current is observed when strobe off the
+	 * flash. Workaround here is firstly set flash current to lower level,
+	 * wait a short moment, and then strobe off the flash.
+	 */
+
+	timer_pending = del_timer_sync(&flash->flash_off_delay);
+
+	/* Flash off */
+	if (!strobe) {
+		/* set current to 70mA and wait a while */
+		ret = lm3642_write(flash, LM3642_CONTROL_REG, 0);
+		if (ret < 0)
+			goto err;
+		mod_timer(&flash->flash_off_delay,
+			  jiffies + msecs_to_jiffies(LM3642_TIMER_DELAY));
+		return 0;
+	}
+
+	/* Flash on */
+
+	/*
+	 * If timer is killed before run, flash is not strobe off,
+	 * so must strobe off here
+	 */
+	if (timer_pending)
+		gpio_set_value(pdata->gpio_strobe, 0);
+
+	/* Restore flash current settings */
+	ret = lm3642_set_current(flash);
+	if (ret < 0)
+		goto err;
+
+	/* Strobe on Flash */
+	gpio_set_value(pdata->gpio_strobe, 1);
+
+	return 0;
+err:
+	dev_err(&client->dev, "failed to %s flash strobe (%d)\n",
+		strobe ? "on" : "off", ret);
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 controls
+ */
+
+static int lm3642_read_status(struct lm3642 *flash)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+
+	/* NOTE: reading register clear fault status */
+	ret = lm3642_read(flash, LM3642_FLAGS_REG);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Accordingly to datasheet we read back '1' in bit 6.
+	 * Clear it first.
+	 */
+	ret &= ~LM3642_FLAG_UNUSED;
+	if (ret > 0)
+		dev_dbg(&client->dev, "LM3642 flag status: %02x\n", ret);
+
+	return ret;
+}
+
+static int lm3642_s_flash_timeout(struct v4l2_subdev *sd, u32 val)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	val = clamp(val, LM3642_MIN_TIMEOUT, LM3642_MAX_TIMEOUT);
+	val = val / LM3642_TIMEOUT_STEPSIZE - 1;
+
+	flash->timeout = val;
+
+	return lm3642_set_feature(flash);
+}
+
+static int lm3642_g_flash_timeout(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	*val = (u32)(flash->timeout + 1) * LM3642_TIMEOUT_STEPSIZE;
+
+	return 0;
+}
+
+static int lm3642_s_flash_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	intensity = LM3642_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3642_PERCENT_TO_VALUE(intensity, LM3642_FLASH_STEP);
+
+	flash->flash_current = intensity;
+
+	return lm3642_set_current(flash);
+}
+
+static int lm3642_g_flash_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	*val = LM3642_VALUE_TO_PERCENT((u32)flash->flash_current,
+			LM3642_FLASH_STEP);
+
+	return 0;
+}
+
+static int lm3642_s_torch_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	intensity = LM3642_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3642_PERCENT_TO_VALUE(intensity, LM3642_TORCH_STEP);
+
+	flash->torch_current = intensity;
+
+	return lm3642_set_current(flash);
+}
+
+static int lm3642_g_torch_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	*val = LM3642_VALUE_TO_PERCENT((u32)flash->torch_current,
+			LM3642_TORCH_STEP);
+
+	return 0;
+}
+
+static int lm3642_s_indicator_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	intensity = LM3642_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3642_PERCENT_TO_VALUE(intensity, LM3642_INDICATOR_STEP);
+
+	flash->indicator_current = intensity;
+
+	return lm3642_set_feature(flash);
+}
+
+static int lm3642_g_indicator_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+
+	*val = LM3642_VALUE_TO_PERCENT((u32)flash->indicator_current,
+			LM3642_INDICATOR_STEP);
+
+	return 0;
+}
+
+static int lm3642_s_flash_strobe(struct v4l2_subdev *sd, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return lm3642_hw_strobe(client, val);
+}
+
+static int lm3642_s_flash_mode(struct v4l2_subdev *sd, u32 new_mode)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+	unsigned int mode;
+
+	switch (new_mode) {
+	case ATOMISP_FLASH_MODE_OFF:
+		mode = LM3642_MODE_SHUTDOWN;
+		break;
+	case ATOMISP_FLASH_MODE_FLASH:
+		mode = LM3642_MODE_FLASH;
+		break;
+	case ATOMISP_FLASH_MODE_INDICATOR:
+		mode = LM3642_MODE_INDICATOR;
+		break;
+	case ATOMISP_FLASH_MODE_TORCH:
+		mode = LM3642_MODE_TORCH;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lm3642_set_mode(flash, mode);
+}
+
+static int lm3642_g_flash_mode(struct v4l2_subdev *sd, s32 * val)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+	*val = flash->mode;
+	return 0;
+}
+
+static int lm3642_g_flash_status(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+	int value;
+
+	value = lm3642_read_status(flash);
+	if (value < 0)
+		return value;
+
+	if (value & LM3642_FLAG_TIMEOUT)
+		*val = ATOMISP_FLASH_STATUS_TIMEOUT;
+	else if (value > 0)
+		*val = ATOMISP_FLASH_STATUS_HW_ERROR;
+	else
+		*val = ATOMISP_FLASH_STATUS_OK;
+
+	return 0;
+}
+
+static const struct lm3642_ctrl_id lm3642_ctrls[] = {
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TIMEOUT,
+				"Flash Timeout",
+				0,
+				LM3642_MAX_TIMEOUT,
+				1,
+				LM3642_DEFAULT_TIMEOUT,
+				0,
+				lm3642_s_flash_timeout,
+				lm3642_g_flash_timeout),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_INTENSITY,
+				"Flash Intensity",
+				LM3642_MIN_PERCENT,
+				LM3642_MAX_PERCENT,
+				1,
+				LM3642_FLASH_DEFAULT_BRIGHTNESS,
+				0,
+				lm3642_s_flash_intensity,
+				lm3642_g_flash_intensity),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TORCH_INTENSITY,
+				"Torch Intensity",
+				LM3642_MIN_PERCENT,
+				LM3642_MAX_PERCENT,
+				1,
+				LM3642_TORCH_DEFAULT_BRIGHTNESS,
+				0,
+				lm3642_s_torch_intensity,
+				lm3642_g_torch_intensity),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_INDICATOR_INTENSITY,
+				"Indicator Intensity",
+				LM3642_MIN_PERCENT,
+				LM3642_MAX_PERCENT,
+				1,
+				LM3642_INDICATOR_DEFAULT_BRIGHTNESS,
+				0,
+				lm3642_s_indicator_intensity,
+				lm3642_g_indicator_intensity),
+	s_ctrl_id_entry_boolean(V4L2_CID_FLASH_STROBE,
+				"Flash Strobe",
+				0,
+				0,
+				lm3642_s_flash_strobe,
+				NULL),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_MODE,
+				"Flash Mode",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				ATOMISP_FLASH_MODE_OFF,
+				0,
+				lm3642_s_flash_mode,
+				lm3642_g_flash_mode),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_STATUS,
+				"Flash Status",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				ATOMISP_FLASH_STATUS_OK,
+				0,
+				NULL,
+				lm3642_g_flash_status),
+};
+
+static const struct lm3642_ctrl_id *find_ctrl_id(unsigned int id)
+{
+	int i;
+	int num;
+
+	num = ARRAY_SIZE(lm3642_ctrls);
+	for (i = 0; i < num; i++) {
+		if (lm3642_ctrls[i].qc.id == id)
+			return &lm3642_ctrls[i];
+	}
+
+	return NULL;
+}
+
+static int lm3642_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	int num;
+
+	if (!qc)
+		return -EINVAL;
+
+	num = ARRAY_SIZE(lm3642_ctrls);
+	if (qc->id >= num)
+		return -EINVAL;
+
+	*qc = lm3642_ctrls[qc->id].qc;
+
+	return 0;
+}
+
+static int lm3642_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	const struct lm3642_ctrl_id *s_ctrl;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = find_ctrl_id(ctrl->id);
+	if (!s_ctrl)
+		return -EINVAL;
+
+	return s_ctrl->s_ctrl(sd, ctrl->value);
+}
+
+static int lm3642_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	const struct lm3642_ctrl_id *s_ctrl;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = find_ctrl_id(ctrl->id);
+	if (s_ctrl == NULL)
+		return -EINVAL;
+
+	return s_ctrl->g_ctrl(sd, &ctrl->value);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 subdev core operations
+ */
+
+/* Put device into known state. */
+static int lm3642_setup(struct lm3642 *flash)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	/* clear the flags register */
+	ret = lm3642_read(flash, LM3642_FLAGS_REG);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "Fault info: %02x\n", ret);
+
+	ret = lm3642_set_enable(flash);
+	if (ret < 0)
+		return ret;
+
+	ret = lm3642_set_feature(flash);
+	if (ret < 0)
+		return ret;
+
+	ret = lm3642_set_current(flash);
+	if (ret < 0)
+		return ret;
+
+	/* read status */
+	ret = lm3642_read_status(flash);
+	if (ret < 0)
+		return ret;
+
+	return ret ? -EIO : 0;
+}
+
+static int __lm3642_s_power(struct lm3642 *flash, int power)
+{
+	return 0;
+}
+
+static int lm3642_s_power(struct v4l2_subdev *sd, int power)
+{
+	struct lm3642 *flash = to_lm3642(sd);
+	int ret = 0;
+
+	mutex_lock(&flash->power_lock);
+
+	if (flash->power_count == !power) {
+		ret = __lm3642_s_power(flash, !!power);
+		if (ret < 0)
+			goto done;
+	}
+
+	flash->power_count += power ? 1 : -1;
+	WARN_ON(flash->power_count < 0);
+
+done:
+	mutex_unlock(&flash->power_lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops lm3642_core_ops = {
+	.queryctrl = lm3642_queryctrl,
+	.g_ctrl = lm3642_g_ctrl,
+	.s_ctrl = lm3642_s_ctrl,
+	.s_power = lm3642_s_power,
+};
+
+static const struct v4l2_subdev_ops lm3642_ops = {
+	.core = &lm3642_core_ops,
+};
+
+static int lm3642_detect(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *adapter = client->adapter;
+	struct lm3642 *flash = to_lm3642(sd);
+	int ret;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "lm3642_detect i2c error\n");
+		return -ENODEV;
+	}
+
+	/* Power up the flash driver and reset it */
+	ret = lm3642_s_power(&flash->sd, 1);
+	if (ret < 0)
+		return ret;
+
+	/* Setup default values. This makes sure that the chip is in a known
+	 * state.
+	 */
+	ret = lm3642_setup(flash);
+	if (ret < 0)
+		goto fail;
+
+	dev_dbg(&client->dev, "Successfully detected lm3642 LED flash\n");
+	lm3642_s_power(&flash->sd, 0);
+	return 0;
+
+fail:
+	lm3642_s_power(&flash->sd, 0);
+	return ret;
+}
+
+static int lm3642_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return lm3642_s_power(sd, 1);
+}
+
+static int lm3642_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return lm3642_s_power(sd, 0);
+}
+
+static const struct v4l2_subdev_internal_ops lm3642_internal_ops = {
+	.registered = lm3642_detect,
+	.open = lm3642_open,
+	.close = lm3642_close,
+};
+
+/* -----------------------------------------------------------------------------
+ *  I2C driver
+ */
+#ifdef CONFIG_PM
+
+static int lm3642_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct lm3642 *flash = to_lm3642(subdev);
+	int rval;
+
+	if (flash->power_count == 0)
+		return 0;
+
+	rval = __lm3642_s_power(flash, 0);
+
+	dev_dbg(&client->dev, "Suspend %s\n", rval < 0 ? "failed" : "ok");
+
+	return rval;
+}
+
+static int lm3642_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct lm3642 *flash = to_lm3642(subdev);
+	int rval;
+
+	if (flash->power_count == 0)
+		return 0;
+
+	rval = __lm3642_s_power(flash, 1);
+
+	dev_dbg(&client->dev, "Resume %s\n", rval < 0 ? "fail" : "ok");
+
+	return rval;
+}
+
+#else
+
+#define lm3642_suspend NULL
+#define lm3642_resume  NULL
+
+#endif /* CONFIG_PM */
+
+static int lm3642_gpio_init(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3642 *flash = to_lm3642(sd);
+	struct lm3642_platform_data *pdata = flash->pdata;
+	int ret;
+
+	ret = gpio_request(pdata->gpio_strobe, "flash");
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(pdata->gpio_strobe, 0);
+	if (ret < 0)
+		goto err_gpio_flash;
+
+	ret = gpio_request(pdata->gpio_torch, "torch");
+	if (ret < 0)
+		goto err_gpio_flash;
+
+	ret = gpio_direction_output(pdata->gpio_torch, 0);
+	if (ret < 0)
+		goto err_gpio_torch;
+
+	return 0;
+
+err_gpio_torch:
+	gpio_free(pdata->gpio_torch);
+err_gpio_flash:
+	gpio_free(pdata->gpio_strobe);
+	return ret;
+}
+
+static int lm3642_gpio_uninit(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3642 *flash = to_lm3642(sd);
+	struct lm3642_platform_data *pdata = flash->pdata;
+	int ret;
+
+	ret = gpio_direction_output(pdata->gpio_torch, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(pdata->gpio_strobe, 0);
+	if (ret < 0)
+		return ret;
+
+	gpio_free(pdata->gpio_torch);
+
+	gpio_free(pdata->gpio_strobe);
+
+	return 0;
+}
+
+static int lm3642_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	int err;
+	struct lm3642 *flash;
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "no platform data\n");
+		return -ENODEV;
+	}
+
+	flash = kzalloc(sizeof(*flash), GFP_KERNEL);
+	if (!flash) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	flash->pdata = client->dev.platform_data;
+
+	v4l2_i2c_subdev_init(&flash->sd, client, &lm3642_ops);
+	flash->sd.internal_ops = &lm3642_internal_ops;
+	flash->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	flash->mode = ATOMISP_FLASH_MODE_OFF;
+	flash->timeout = LM3642_DEFAULT_TIMEOUT;
+	flash->ramp_time = LM3642_DEFAULT_RAMP_TIME;
+	flash->indicator_current = LM3642_DEFAULT_INDICATOR_CURRENT;
+	flash->flash_current = LM3642_DEFAULT_FLASH_CURRENT;
+
+	err = media_entity_init(&flash->sd.entity, 0, NULL, 0);
+	if (err) {
+		dev_err(&client->dev, "error initialize a media entity.\n");
+		goto fail1;
+	}
+
+	flash->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_FLASH;
+
+	mutex_init(&flash->power_lock);
+
+	setup_timer(&flash->flash_off_delay, lm3642_flash_off_delay,
+		    (unsigned long)client);
+
+	err = lm3642_gpio_init(client);
+	if (err) {
+		dev_err(&client->dev, "gpio request/direction_output fail");
+		goto fail2;
+	}
+
+	return 0;
+fail2:
+	media_entity_cleanup(&flash->sd.entity);
+fail1:
+	v4l2_device_unregister_subdev(&flash->sd);
+	kfree(flash);
+
+	return err;
+}
+
+static int lm3642_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3642 *flash = to_lm3642(sd);
+	int ret;
+
+	media_entity_cleanup(&flash->sd.entity);
+	v4l2_device_unregister_subdev(sd);
+
+	del_timer_sync(&flash->flash_off_delay);
+
+	ret = lm3642_gpio_uninit(client);
+	if (ret < 0)
+		goto fail;
+
+	kfree(flash);
+
+	return 0;
+fail:
+	dev_err(&client->dev, "gpio request/direction_output fail");
+	return ret;
+}
+
+static const struct i2c_device_id lm3642_id[] = {
+	{LM3642_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, lm3642_id);
+
+static const struct dev_pm_ops lm3642_pm_ops = {
+	.suspend = lm3642_suspend,
+	.resume = lm3642_resume,
+};
+
+static struct i2c_driver lm3642_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LM3642_NAME,
+		.pm   = &lm3642_pm_ops,
+	},
+	.probe = lm3642_probe,
+	.remove = lm3642_remove,
+	.id_table = lm3642_id,
+};
+
+static __init int init_lm3642(void)
+{
+	return i2c_add_driver(&lm3642_driver);
+}
+
+static __exit void exit_lm3642(void)
+{
+	i2c_del_driver(&lm3642_driver);
+}
+
+module_init(init_lm3642);
+module_exit(exit_lm3642);
+MODULE_AUTHOR("Shuguang Gong <Shuguang.Gong@intel.com>");
+MODULE_DESCRIPTION("LED flash driver for LM3642");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
index faf319a..4260578 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
@@ -21,6 +21,7 @@
 #include <asm/intel-mid.h>
 #include <asm/irq.h>
 #include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
 #include <media/m10mo_atomisp.h>
 #include <linux/delay.h>
 #include <linux/i2c.h>
@@ -43,7 +44,10 @@
 #include <media/v4l2-device.h>
 #include "m10mo.h"
 
-#define M10MO_FORMAT	V4L2_MBUS_FMT_UYVY8_1X16
+/* cross component debug message flag */
+int dbglvl = 0;
+module_param(dbglvl, int, 0644);
+MODULE_PARM_DESC(dbglvl, "debug message on/off (default:off)");
 
 /*
  * m10mo_read -  I2C read function
@@ -100,7 +104,12 @@ static int m10mo_read(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 *
 			*val = recv_data[1] << 24 | recv_data[2] << 16
 				| recv_data[3] << 8 | recv_data[4];
 	}
-	return 0;
+
+	dev_dbg(&client->dev,
+		"%s len :%d cat, reg, val: 0x%02x, 0x%02x, 0x%02x\n",
+		__func__, len, category, reg, *val);
+
+	return (ret == 2) ? 0 : -EIO;
 }
 
 /**
@@ -126,6 +135,10 @@ static int m10mo_write(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32
 		return -EINVAL;
 	}
 
+	dev_dbg(&client->dev,
+		"%s len :%d cat, reg, val: 0x%02x, 0x%02x, 0x%02x\n",
+		__func__, len, category, reg, val);
+
 	msg.addr = client->addr;
 	msg.flags = 0;
 	msg.len = sizeof(data);
@@ -159,6 +172,8 @@ static int m10mo_write(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32
 
 	ret = i2c_transfer(client->adapter, &msg, 1);
 
+	dev_dbg(&client->dev, "Write reg. Category=0x%02X Reg=0x%02X Value=0x%X ret=%s\n",
+		category, reg, val, (ret == 1) ? "OK" : "Error");
 	return ret == num_msg ? 0 : -EIO;
 }
 
@@ -200,6 +215,8 @@ int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *va
 	u8 *data = m10mo_dev->message_buffer;
 	int i, ret;
 
+	dev_dbg(&client->dev, "Write mem. cmd=0x%02X len=%d addr=0x%X\n", cmd, len, addr);
+
 	if (!client->adapter)
 		return -ENODEV;
 
@@ -306,6 +323,7 @@ int m10mo_memory_read(struct v4l2_subdev *sd, u16 len, u32 addr, u8 *val)
 
 	memcpy(val, recv_data + 3, len);
 
+	dev_dbg(&client->dev, "Read mem. len=%d addr=0x%X\n", len, addr);
 	return 0;
 }
 
@@ -335,7 +353,7 @@ int m10mo_setup_flash_controller(struct v4l2_subdev *sd)
  * be read to clear pending interrupts.
  */
 
-static int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode)
+int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -349,17 +367,43 @@ static int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode)
 	case M10MO_PARAM_SETTING_MODE:
 		ret = m10mo_write(sd, 1, CATEGORY_FLASHROM, FLASH_CAM_START, 0x01);
 		if (ret < 0)
-			dev_err(&client->dev, "Unable to change to PARAM_SETTING_MODE\n");
+			dev_err(&client->dev,
+				"Unable to change to PARAM_SETTING_MODE\n");
+		break;
+	case M10MO_PARAMETER_MODE:
+		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x01);
+		if (ret < 0)
+			dev_err(&client->dev,
+				"Unable to change to PARAMETER MODE\n");
 		break;
+	case M10MO_MONITOR_MODE_PANORAMA:
+	case M10MO_MONITOR_MODE_ZSL:
 	case M10MO_MONITOR_MODE:
+	case M10MO_MONITOR_MODE_HIGH_SPEED:
 		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x02);
 		if (ret < 0)
-			dev_err(&client->dev, "Unable to change to MONITOR_MODE\n");
+			dev_err(&client->dev,
+				"Unable to change to MONITOR_MODE / ZSL \n");
 		break;
 	case M10MO_SINGLE_CAPTURE_MODE:
 		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x03);
 		if (ret < 0)
-			dev_err(&client->dev, "Unable to change to SINGLE_CAPTURE_MODE\n");
+			dev_err(&client->dev,
+				"Unable to change to SINGLE_CAPTURE_MODE\n");
+		break;
+	case M10MO_BURST_CAPTURE_MODE:
+		/* Set monitor type as burst capture. */
+		ret = m10mo_write(sd, 1, CATEGORY_PARAM,
+			MONITOR_TYPE, MONITOR_BURST);
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"Unable to change to BURST_CAPTURE_MODE\n");
+			break;
+		}
+		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x02);
+		if (ret < 0)
+			dev_err(&client->dev,
+				"Unable to change to BURST_CAPTURE_MODE\n");
 		break;
 	default:
 		break;
@@ -368,7 +412,72 @@ static int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode)
 	return ret;
 }
 
-static int m10mo_wait_mode_change(struct v4l2_subdev *sd, u8 mode, u32 timeout)
+static int is_m10mo_in_monitor_mode(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	if (dev->mode == M10MO_MONITOR_MODE_PANORAMA ||
+	    dev->mode == M10MO_MONITOR_MODE_ZSL ||
+	    dev->mode == M10MO_MONITOR_MODE ||
+	    dev->mode == M10MO_MONITOR_MODE_HIGH_SPEED)
+		return 1;
+
+	return 0;
+}
+
+static int m10mo_set_monitor_parameters(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+	int ret;
+
+	dev_info(&client->dev,
+		 "%s: af_mode: 0x%x exe_mode: 0x%x posx: 0x%x, posy: 0x%x\n",
+		 __func__, dev->monitor_params.af_mode,
+		 dev->monitor_params.exe_mode,
+		 dev->monitor_params.af_touch_posx,
+		 dev->monitor_params.af_touch_posy);
+
+	ret = m10mo_writeb(sd, CATEGORY_LENS,
+			   m10m0_af_parameters[id].af_mode,
+			   dev->monitor_params.af_mode);
+	if (ret)
+		return ret;
+
+	ret = m10mo_writew(sd, CATEGORY_LENS,
+			   m10m0_af_parameters[id].af_touch_posx,
+			   dev->monitor_params.af_touch_posx);
+	if (ret)
+		return ret;
+
+	ret = m10mo_writew(sd, CATEGORY_LENS,
+			   m10m0_af_parameters[id].af_touch_posy,
+			   dev->monitor_params.af_touch_posy);
+	if (ret)
+		return ret;
+
+	ret = m10mo_writeb(sd, CATEGORY_LENS,
+			   m10m0_af_parameters[id].af_execution,
+			   dev->monitor_params.exe_mode);
+
+	if (ret)
+	    return ret;
+
+	if (dev->monitor_params.flash_mode == LED_TORCH)
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				   LED_TORCH,
+				   dev->monitor_params.torch);
+	else
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				   FLASH_MODE,
+				   dev->monitor_params.flash_mode);
+
+	return ret;
+}
+
+int m10mo_wait_mode_change(struct v4l2_subdev *sd, u8 mode, u32 timeout)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -377,14 +486,33 @@ static int m10mo_wait_mode_change(struct v4l2_subdev *sd, u8 mode, u32 timeout)
 	ret = wait_event_interruptible_timeout(dev->irq_waitq,
 					       dev->mode == mode,
 					       msecs_to_jiffies(timeout));
-	if (ret <= 0) {
-		dev_err(&client->dev, "m10mo_wait_mode_change timed out");
+	if (ret > 0) {
+		if (is_m10mo_in_monitor_mode(sd))
+			return m10mo_set_monitor_parameters(sd);
+		return 0;
+	} else if (ret == 0) {
+		dev_err(&client->dev, "m10mo_wait_mode_change timed out\n");
 		return -ETIMEDOUT;
 	}
 
 	return ret;
 }
 
+int __m10mo_param_mode_set(struct v4l2_subdev *sd)
+{
+	int ret;
+
+	ret = m10mo_request_mode_change(sd, M10MO_PARAMETER_MODE);
+	if (ret)
+		return ret;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_PARAMETER_MODE,
+				     M10MO_INIT_TIMEOUT);
+	if (ret > 0)
+		ret = 0;
+	return ret;
+}
+
 static int m10mo_detect(struct v4l2_subdev *sd)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
@@ -397,7 +525,7 @@ static int m10mo_detect(struct v4l2_subdev *sd)
 	if (!ret)
 		ret = m10mo_read(sd, 1, CATEGORY_SYSTEM, SYSTEM_PROJECT_CODE,
 				&ver->project);
-	dev_info(&client->dev, "Customer/Project[0x%x/0x%x]", dev->ver.customer,
+	dev_info(&client->dev, "Customer/Project[0x%x/0x%x]\n", dev->ver.customer,
 				dev->ver.project);
 	return 0;
 }
@@ -407,6 +535,13 @@ static int __m10mo_fw_start(struct v4l2_subdev *sd)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
 
+	/*
+	 * Correct the pll value before fw start
+	 */
+	ret = m10mo_update_pll_setting(sd);
+	if (ret < 0)
+		return ret;
+
 	ret = m10mo_setup_flash_controller(sd);
 	if (ret < 0)
 		return ret;
@@ -418,7 +553,7 @@ static int __m10mo_fw_start(struct v4l2_subdev *sd)
 	ret = m10mo_wait_mode_change(sd, M10MO_PARAM_SETTING_MODE,
 				     M10MO_INIT_TIMEOUT);
 	if (ret < 0) {
-		dev_err(&client->dev, "Initialization timeout");
+		dev_err(&client->dev, "Initialization timeout\n");
 		return ret;
 	}
 
@@ -442,11 +577,377 @@ static int m10mo_fw_start(struct v4l2_subdev *sd, u32 val)
 	return ret;
 }
 
+static int m10mo_set_af_mode(struct v4l2_subdev *sd, unsigned int val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+	int ret = 0;
+	u32 cur_af_mode;
+
+	switch (val) {
+	case EXT_ISP_FOCUS_MODE_NORMAL:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_normal;
+		break;
+	case EXT_ISP_FOCUS_MODE_MACRO:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_macro;
+		break;
+	case EXT_ISP_FOCUS_MODE_TOUCH_AF:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_touch;
+		break;
+	case EXT_ISP_FOCUS_MODE_PREVIEW_CAF:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_preview_caf;
+		break;
+	case EXT_ISP_FOCUS_MODE_MOVIE_CAF:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_movie_caf;
+		break;
+	case EXT_ISP_FOCUS_MODE_FACE_CAF:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_face_caf;
+		break;
+	case EXT_ISP_FOCUS_MODE_TOUCH_MACRO:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_touch_macro;
+		break;
+	case EXT_ISP_FOCUS_MODE_TOUCH_CAF:
+		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_touch_caf;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (!is_m10mo_in_monitor_mode(sd))
+		return ret;
+
+	ret = m10mo_read(sd, 1, CATEGORY_LENS,
+			m10m0_af_parameters[id].af_mode,
+			&cur_af_mode);
+
+	/*
+	 * If af_mode has changed as expected already
+	 * no need to set any more
+	 */
+	if (dev->monitor_params.af_mode == cur_af_mode)
+		return ret;
+
+	dev_info(&client->dev, "%s: In monitor mode, set AF mode to %d",
+		 __func__, dev->monitor_params.af_mode);
+
+	/* We are in monitor mode already, */
+	/* af_mode can be applied immediately */
+	ret = m10mo_writeb(sd, CATEGORY_LENS,
+			m10m0_af_parameters[id].af_mode,
+			dev->monitor_params.af_mode);
+
+	return ret;
+}
+
+static int m10mo_set_af_execution(struct v4l2_subdev *sd, s32 val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+	int ret = 0;
+
+	switch (val) {
+	case EXT_ISP_FOCUS_STOP:
+		dev->monitor_params.exe_mode = m10m0_af_parameters[id].af_stop;
+		break;
+	case EXT_ISP_FOCUS_SEARCH:
+		dev->monitor_params.exe_mode = m10m0_af_parameters[id].af_search;
+		break;
+	case EXT_ISP_PAN_FOCUSING:
+		dev->monitor_params.exe_mode = m10m0_af_parameters[id].af_pan_focusing;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (is_m10mo_in_monitor_mode(sd)) {
+
+		dev_info(&client->dev, "%s: In monitor mode, set AF exe_mode to %d",
+			 __func__, dev->monitor_params.exe_mode);
+
+		/* We are in monitor mode already, */
+		/* exe_mode can be applied immediately */
+		ret = m10mo_writeb(sd, CATEGORY_LENS,
+				   m10m0_af_parameters[id].af_execution,
+				   dev->monitor_params.exe_mode);
+	}
+	return ret;
+}
+
+static int m10mo_set_af_position_x(struct v4l2_subdev *sd, unsigned int x)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+
+	dev->monitor_params.af_touch_posx = x;
+
+	if (is_m10mo_in_monitor_mode(sd)) {
+		dev_info(&client->dev,
+			 "%s: In monitor mode, set AF touch X pos to 0x%x",
+			 __func__, dev->monitor_params.af_touch_posx);
+
+		/* Set X Position */
+		ret = m10mo_writew(sd, CATEGORY_LENS,
+				   m10m0_af_parameters[id].af_touch_posx,
+				   dev->monitor_params.af_touch_posx);
+	}
+
+	if (ret)
+		dev_err(&client->dev, "AutoFocus position x failed %d\n", ret);
+
+	return ret;
+}
+
+static int m10mo_set_af_position_y(struct v4l2_subdev *sd, unsigned int y)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+
+	dev->monitor_params.af_touch_posy = y;
+
+	if (is_m10mo_in_monitor_mode(sd)) {
+		dev_info(&client->dev,
+			 "%s: In monitor mode, set AF touch Y pos to 0x%x",
+			 __func__, dev->monitor_params.af_touch_posy);
+
+		/* Set Y Position */
+		ret = m10mo_writew(sd, CATEGORY_LENS,
+				   m10m0_af_parameters[id].af_touch_posy,
+				   dev->monitor_params.af_touch_posy);
+	}
+
+	if (ret)
+		dev_err(&client->dev, "AutoFocus position y failed %d\n", ret);
+
+	return ret;
+}
+
+/* Because of different m10m0 firmwares and parameter values, transform
+   the values to the macro definition */
+static u32 m10mo_af_parameter_transform(struct v4l2_subdev *sd, u32 val)
+{
+	u32 ret = 0xffffffff;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+
+	if (val == m10m0_af_parameters[id].caf_status_focusing) {
+		ret = CAF_STATUS_FOCUSING;
+	} else if (val == m10m0_af_parameters[id].caf_status_success) {
+		ret = CAF_STATUS_SUCCESS;
+	} else if (val == m10m0_af_parameters[id].caf_status_fail) {
+		ret = CAF_STATUS_FAIL;
+	} else if (val == m10m0_af_parameters[id].caf_status_restart_check) {
+		ret = CAF_STATUS_RESTART_CHECK;
+	} else if (val == m10m0_af_parameters[id].af_status_invalid) {
+		ret = AF_STATUS_INVALID;
+	} else if (val == m10m0_af_parameters[id].af_status_focusing) {
+		ret = AF_STATUS_FOCUSING;
+	} else if (val == m10m0_af_parameters[id].af_status_success) {
+		ret = AF_STATUS_SUCCESS;
+	} else if (val == m10m0_af_parameters[id].af_status_fail) {
+		ret = AF_STATUS_FAIL;
+	} else if (val == m10m0_af_parameters[id].af_normal) {
+		ret = AF_NORMAL;
+	} else if (val == m10m0_af_parameters[id].af_macro) {
+		ret = AF_MACRO;
+	} else if (val == m10m0_af_parameters[id].af_touch) {
+		ret = AF_TOUCH;
+	} else if (val == m10m0_af_parameters[id].af_preview_caf) {
+		ret = AF_PREVIEW_CAF;
+	} else if (val == m10m0_af_parameters[id].af_movie_caf) {
+		ret = AF_MOVIE_CAF;
+	} else if (val == m10m0_af_parameters[id].af_face_caf) {
+		ret = AF_FACE_CAF;
+	} else if (val == m10m0_af_parameters[id].af_touch_macro) {
+		ret = AF_TOUCH_MACRO;
+	} else if (val == m10m0_af_parameters[id].af_touch_caf) {
+		ret = AF_TOUCH_CAF;
+	}
+
+	return ret;
+}
+
+static int m10mo_get_caf_status(struct v4l2_subdev *sd, unsigned int *status)
+{
+	int ret;
+	u32 af_result;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+
+	ret = m10mo_read(sd, 1, CATEGORY_LENS,
+			m10m0_af_parameters[id].af_result, &af_result);
+	if (ret)
+		return ret;
+
+	af_result = m10mo_af_parameter_transform(sd, af_result);
+
+	switch (af_result) {
+	case CAF_STATUS_FOCUSING:
+		*status = EXT_ISP_CAF_STATUS_FOCUSING;
+		break;
+	case CAF_STATUS_SUCCESS:
+		*status = EXT_ISP_CAF_STATUS_SUCCESS;
+		break;
+	case CAF_STATUS_FAIL:
+		*status = EXT_ISP_CAF_STATUS_FAIL;
+		break;
+	case CAF_STATUS_RESTART_CHECK:
+		*status = EXT_ISP_CAF_RESTART_CHECK;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int m10mo_get_af_status(struct v4l2_subdev *sd, unsigned int *status)
+{
+	int ret;
+	u32 af_result;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+
+	ret = m10mo_read(sd, 1, CATEGORY_LENS,
+			m10m0_af_parameters[id].af_result, &af_result);
+	if (ret)
+		return ret;
+
+	af_result = m10mo_af_parameter_transform(sd, af_result);
+
+	switch (af_result) {
+	case AF_STATUS_INVALID:
+		*status = EXT_ISP_AF_STATUS_INVALID;
+		break;
+	case AF_STATUS_FOCUSING:
+		*status = EXT_ISP_AF_STATUS_FOCUSING;
+		break;
+	case AF_STATUS_SUCCESS:
+		*status = EXT_ISP_AF_STATUS_SUCCESS;
+		break;
+	case AF_STATUS_FAIL:
+		*status = EXT_ISP_AF_STATUS_FAIL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/* Adding this as requested by HAL. Can be removed if HAL is saving af mode */
+static int m10mo_get_af_mode(struct v4l2_subdev *sd, unsigned int *status)
+{
+	int ret;
+	u32 af_mode;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
+
+	ret = m10mo_read(sd, 1, CATEGORY_LENS,
+			m10m0_af_parameters[id].af_result, &af_mode);
+	if (ret)
+		return ret;
+
+	af_mode = m10mo_af_parameter_transform(sd, af_mode);
+
+	switch (af_mode) {
+	case AF_NORMAL:
+		*status = EXT_ISP_FOCUS_MODE_NORMAL;
+		break;
+	case AF_MACRO:
+		*status = EXT_ISP_FOCUS_MODE_MACRO;
+		break;
+	case AF_TOUCH:
+		*status = EXT_ISP_FOCUS_MODE_TOUCH_AF;
+		break;
+	case AF_PREVIEW_CAF:
+		*status = EXT_ISP_FOCUS_MODE_PREVIEW_CAF;
+		break;
+	case AF_MOVIE_CAF:
+		*status = EXT_ISP_FOCUS_MODE_MOVIE_CAF;
+		break;
+	case AF_FACE_CAF:
+		*status = EXT_ISP_FOCUS_MODE_FACE_CAF;
+		break;
+	case AF_TOUCH_MACRO:
+		*status = EXT_ISP_FOCUS_MODE_TOUCH_MACRO;
+		break;
+	case AF_TOUCH_CAF:
+		*status = EXT_ISP_FOCUS_MODE_TOUCH_CAF;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int m10mo_set_flash_mode(struct v4l2_subdev *sd, unsigned int val)
+{
+	int ret = 0;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	/* by default force the torch off, value depends on incoming flash mode */
+	dev->monitor_params.torch = LED_TORCH_OFF;
+
+	switch (val) {
+	case EXT_ISP_FLASH_MODE_OFF:
+		dev->monitor_params.flash_mode = FLASH_MODE_OFF;
+		break;
+	case EXT_ISP_FLASH_MODE_ON:
+		dev->monitor_params.flash_mode = FLASH_MODE_ON;
+		break;
+	case EXT_ISP_FLASH_MODE_AUTO:
+		dev->monitor_params.flash_mode = FLASH_MODE_AUTO;
+		break;
+	case EXT_ISP_LED_TORCH_OFF:
+		dev->monitor_params.flash_mode = LED_TORCH;
+		dev->monitor_params.torch = LED_TORCH_OFF;
+		break;
+	case EXT_ISP_LED_TORCH_ON:
+		dev->monitor_params.flash_mode = LED_TORCH;
+		dev->monitor_params.torch = LED_TORCH_ON;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Only apply setting if we are in monitor mode */
+	if (!is_m10mo_in_monitor_mode(sd))
+		return ret;
+
+	dev_info(&client->dev, "%s: In monitor mode, set flash mode to %d",
+		 __func__, dev->monitor_params.flash_mode);
+
+	/* TODO get current flash mode, and apply new setting only when needed? */
+
+	if (dev->monitor_params.flash_mode == LED_TORCH)
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LED_TORCH,
+				   dev->monitor_params.torch);
+	else
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, FLASH_MODE,
+				   dev->monitor_params.flash_mode);
+
+	return ret;
+}
+
 static int power_up(struct v4l2_subdev *sd)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int ret;
 
+	if (dev->pdata->common.power_ctrl) {
+		ret = dev->pdata->common.power_ctrl(sd, 1);
+		if (ret)
+			goto fail_power_ctrl;
+	}
+
 	if (dev->pdata->common.flisclk_ctrl) {
 		ret = dev->pdata->common.flisclk_ctrl(sd, 1);
 		if (ret)
@@ -464,6 +965,9 @@ fail_power_off:
 fail_clk_off:
 	if (dev->pdata->common.flisclk_ctrl)
 		ret = dev->pdata->common.flisclk_ctrl(sd, 0);
+fail_power_ctrl:
+	if (dev->pdata->common.power_ctrl)
+		ret = dev->pdata->common.power_ctrl(sd, 0);
 	return ret;
 }
 
@@ -475,13 +979,19 @@ static int power_down(struct v4l2_subdev *sd)
 
 	ret = dev->pdata->common.gpio_ctrl(sd, 0);
 	if (ret)
-		dev_err(&client->dev, "gpio failed");
+		dev_err(&client->dev, "gpio failed\n");
 
 	/* Even if the first one fails we still want to turn clock off */
 	if (dev->pdata->common.flisclk_ctrl) {
 		ret = dev->pdata->common.flisclk_ctrl(sd, 0);
 		if (ret)
-			dev_err(&client->dev, "stop clock failed");
+			dev_err(&client->dev, "stop clock failed\n");
+	}
+
+	if (dev->pdata->common.power_ctrl) {
+		ret = dev->pdata->common.power_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "power off fail\n");
 	}
 	return ret;
 }
@@ -513,18 +1023,26 @@ static int __m10mo_s_power(struct v4l2_subdev *sd, int on, bool fw_update_mode)
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int ret;
 
+	if (dev->power == on)
+		return 0;
+
 	if (on) {
 		dev->mode = M10MO_POWERING_ON;
 		m10mo_request_mode_change(sd, M10MO_FLASH_WRITE_MODE);
 
 		ret = power_up(sd);
-		if (!ret) {
-			dev->power = 1;
-			ret = __m10mo_bootrom_mode_start(sd);
+		if (ret)
+			return ret;
+		dev->power = 1;
+
+		ret = __m10mo_bootrom_mode_start(sd);
+		if (ret)
+			goto startup_failure;
+
+		if (!fw_update_mode) {
+			ret = __m10mo_fw_start(sd);
 			if (ret)
-				return ret;
-			if (!fw_update_mode)
-				ret = __m10mo_fw_start(sd);
+				goto startup_failure;
 		}
 	} else {
 		ret = power_down(sd);
@@ -532,43 +1050,484 @@ static int __m10mo_s_power(struct v4l2_subdev *sd, int on, bool fw_update_mode)
 	}
 
 	return ret;
-}
-
-static int m10mo_s_power(struct v4l2_subdev *sd, int on)
-{
-	int ret;
-	struct m10mo_device *dev = to_m10mo_sensor(sd);
-
-	mutex_lock(&dev->input_lock);
-	ret = __m10mo_s_power(sd, on, false);
-	mutex_unlock(&dev->input_lock);
 
+startup_failure:
+	power_down(sd);
+	dev->power = 0;
 	return ret;
 }
 
-static int m10mo_single_capture_process(struct v4l2_subdev *sd)
+int m10mo_set_panorama_monitor(struct v4l2_subdev *sd)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
+	u32 val;
 
-	/* Select frame */
-	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
-			  CAPC_SEL_FRAME_MAIN, 0x01);
+	dev_info(&client->dev,
+		"%s mode: %d Width: %d, height: %d, cmd: 0x%x vdis: %d\n",
+		__func__, dev->mode, dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command,
+		(int)dev->curr_res_table[dev->fmt_idx].vdis);
 
+	/* Check if m10mo already streaming @ required resolution */
+	ret = m10mo_readb(sd, CATEGORY_PARAM,  PARAM_MON_SIZE, &val);
+	if (ret)
+		goto out;
+
+	/* If mode is monitor mode and size same, do not configure again*/
+	if (dev->mode == M10MO_MONITOR_MODE_PANORAMA &&
+		val == dev->curr_res_table[dev->fmt_idx].command) {
+		dev_info(&client->dev,
+			"%s Already streaming with required size\n", __func__);
+		return 0;
+	}
+
+	if (dev->mode != M10MO_PARAM_SETTING_MODE &&
+		dev->mode != M10MO_PARAMETER_MODE) {
+		/* Already in panorama mode. So swith to parameter mode */
+		ret = __m10mo_param_mode_set(sd);
+		if (ret)
+			goto out;
+	}
+
+	/* Change the Monitor Size */
+	ret = m10mo_write(sd, 1, CATEGORY_PARAM, PARAM_MON_SIZE,
+			dev->curr_res_table[dev->fmt_idx].command);
+	if (ret)
+		goto out;
+
+	/* Set Panorama mode */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, CAPTURE_MODE,
+			CAP_MODE_PANORAMA);
+	if (ret)
+		goto out;
+
+	/* Setting output to NV12/NV21. */
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, OUTPUT_FMT_SELECT,
+			OUTPUT_FMT_SELECT_NV12NV21);
+	if (ret)
+		goto out;
+
+	/* Select either NV12 or NV21 based on the format set from user space */
+	val = dev->format.code == V4L2_MBUS_FMT_CUSTOM_NV21 ?
+		CHOOSE_NV12NV21_FMT_NV21 : CHOOSE_NV12NV21_FMT_NV12;
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, CHOOSE_NV12NV21_FMT, val);
+	if (ret)
+		goto out;
+
+	/* Enable metadata (the command sequence PDF-example) */
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, MON_METADATA_SUPPORT_CTRL,
+			MON_METADATA_SUPPORT_CTRL_EN);
+	if (ret)
+		goto out;
+
+	/* Enable interrupt signal */
+	ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+	if (ret)
+		goto out;
+
+	/* Go to Panorama Monitor mode */
+	ret = m10mo_request_mode_change(sd, M10MO_MONITOR_MODE_PANORAMA);
+	if (ret)
+		goto out;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_MONITOR_MODE_PANORAMA,
+				M10MO_INIT_TIMEOUT);
+	if (ret < 0)
+		goto out;
+
+	return 0;
+out:
+	dev_err(&client->dev, "m10mo_set_panorama_monitor failed %d\n", ret);
+	return ret;
+}
+
+int m10mo_set_zsl_monitor(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+	int shot_mode_support = M10MO_SHOT_MODES_SUPPORTED(dev->fw_type);
+	const struct m10mo_resolution *capture_res =
+			resolutions[mode][M10MO_MODE_CAPTURE_INDEX];
+	int ret;
+	u32 fmt;
+
+	dev_info(&client->dev,
+		"%s mode: %d width: %d, height: %d, cmd: 0x%x vdis: %d\n",
+		__func__, dev->mode, dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command,
+		(int)dev->curr_res_table[dev->fmt_idx].vdis);
+
+	dev_info(&client->dev, "%s capture width: %d, height: %d, cmd: 0x%x\n",
+		__func__, capture_res[dev->capture_res_idx].width,
+		capture_res[dev->capture_res_idx].height,
+		capture_res[dev->capture_res_idx].command);
+
+	if (dev->mode != M10MO_PARAM_SETTING_MODE &&
+		dev->mode != M10MO_PARAMETER_MODE) {
+		/*
+		 * At this stage means we are already at ZSL. So switch to
+		 * param mode first and reset all the parameters.
+		 */
+
+		ret = __m10mo_param_mode_set(sd);
+		if (ret)
+			goto out;
+	}
+
+	/* Set ZSL mode */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, CAPTURE_MODE,
+				CAP_MODE_INFINITY_ZSL);
+	if (ret)
+		goto out;
+
+	/* Change the Monitor Size */
+	ret = m10mo_write(sd, 1, CATEGORY_PARAM, PARAM_MON_SIZE,
+			dev->curr_res_table[dev->fmt_idx].command);
+	if (ret)
+		goto out;
+
+	/* Change the capture size */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM, CAPP_MAIN_IMAGE_SIZE,
+			capture_res[dev->capture_res_idx].command);
+	if (ret)
+		goto out;
+
+	/* Set shot mode */
+	if (shot_mode_support) {
+		ret = m10mo_writeb(sd, CATEGORY_PARAM, SHOT_MODE, dev->shot_mode);
+		if (ret)
+			goto out;
+	}
+
+	/* Select monitor/movie mode */
+	ret = m10mo_write(sd, 1, CATEGORY_PARAM, MOVIE_MODE,
+			dev->run_mode == CI_MODE_VIDEO ? 0x01 : 0x00);
+	if (ret)
+		goto out;
+
+	/* vdis on/off */
+	m10mo_writeb(sd, CATEGORY_MONITOR, PARAM_VDIS,
+		     dev->curr_res_table[dev->fmt_idx].vdis ? 0x01 : 0x00);
+
+	/* Select either NV12 or NV21 based on the format set from user space */
+	fmt = dev->format.code == V4L2_MBUS_FMT_CUSTOM_NV21 ?
+		CHOOSE_NV12NV21_FMT_NV21 : CHOOSE_NV12NV21_FMT_NV12;
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, CHOOSE_NV12NV21_FMT, fmt);
+	if (ret)
+		goto out;
+
+	/* Enable interrupt signal */
+	ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+	if (ret)
+		goto out;
+
+	/* Go to ZSL Monitor mode */
+	ret = m10mo_request_mode_change(sd, M10MO_MONITOR_MODE_ZSL);
+	if (ret)
+		goto out;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_MONITOR_MODE_ZSL,
+				M10MO_INIT_TIMEOUT);
+	if (ret < 0)
+		goto out;
+
+	return 0;
+out:
+	dev_err(&client->dev, "m10mo_set_zsl_monitor failed %d\n", ret);
+	return ret;
+}
+
+static u32 __get_dual_capture_value(u8 capture_mode)
+{
+	switch(capture_mode) {
+	case M10MO_CAPTURE_MODE_ZSL_BURST:
+		return DUAL_CAPTURE_BURST_CAPTURE_START;
+	case M10MO_CAPTURE_MODE_ZSL_LLS:
+		return DUAL_CAPTURE_LLS_CAPTURE_START;
+	case M10MO_CAPTURE_MODE_ZSL_NORMAL:
+		return DUAL_CAPTURE_ZSL_CAPTURE_START;
+	case M10MO_CAPTURE_MODE_ZSL_HDR:
+	case M10MO_CAPTURE_MODE_ZSL_RAW:
+	default:
+		return DUAL_CAPTURE_SINGLE_CAPTURE_START;
+	}
+}
+
+static int m10mo_set_zsl_capture(struct v4l2_subdev *sd, int sel_frame)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret, i;
+	u32 val, dual_status;
+	int finish = 0;
+
+	/* TODO: Fix this. Currently we do not use this */
+	(void) sel_frame;
+
+	val = __get_dual_capture_value(dev->capture_mode);
+
+	/* Check dual capture status before the capture request */
+	for (i = POLL_NUM; i; i--) {
+		ret = m10mo_readb(sd, CATEGORY_CAPTURE_CTRL, START_DUAL_STATUS,
+				&dual_status);
+		if (ret)
+			continue;
+
+		if ((dual_status == 0) || (dual_status == DUAL_STATUS_AF_WORKING)) {
+			finish = 1;
+			break;
+		}
+
+		msleep(10);
+	}
+
+	/*
+	* If last capture not finished yet, return error code
+	*/
+	if (!finish) {
+		dev_err(&client->dev, "%s Device busy. Status check failed %d\n",
+			__func__, dual_status);
+		return -EBUSY;
+	}
+
+	/* Start capture, JPEG encode & transfer start */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, START_DUAL_CAPTURE, val);
+	dev_dbg(&client->dev, "%s zsl capture trigger result: %d\n",
+			__func__, ret);
+	return ret;
+}
+
+int m10mo_set_zsl_raw_capture(struct v4l2_subdev *sd)
+{
+	int ret;
+
+	/* Set capture mode - Infinity capture 3 */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, CAPTURE_MODE,
+						CAP_MODE_INFINITY_ZSL);
+	if (ret)
+		return ret;
+
+	/* Enable interrupt signal */
+	ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+	if (ret)
+		return ret;
+
+	/* Go to ZSL Monitor mode */
+	ret = m10mo_request_mode_change(sd, M10MO_MONITOR_MODE_ZSL);
+	if (ret)
+		return ret;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_MONITOR_MODE_ZSL,
+						M10MO_INIT_TIMEOUT);
+	if (ret < 0)
+		return ret;
+
+	/* switch to RAW capture mode */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, REG_CAP_NV12_MODE,
+						RAW_CAPTURE);
+	if (ret)
+		return ret;
+
+	/* RAW mode is set. Now do a normal capture */
+	return m10mo_set_zsl_capture(sd, 1);
+}
+
+int m10mo_set_burst_mode(struct v4l2_subdev *sd, unsigned int val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret = 0;
+
+	switch(val) {
+	case EXT_ISP_BURST_CAPTURE_CTRL_START:
+		/* First check if already in ZSL monitor mode. If not start */
+		if (dev->mode != M10MO_MONITOR_MODE_ZSL) {
+			ret = m10mo_set_zsl_monitor(sd);
+			if (ret)
+				return ret;
+		}
+		/* set cap mode to burst so that ZSL cap can differentiate */
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_BURST;
+		return m10mo_set_zsl_capture(sd, 1);
+	case EXT_ISP_BURST_CAPTURE_CTRL_STOP:
+		if (dev->capture_mode != M10MO_CAPTURE_MODE_ZSL_BURST)
+			return 0;
+		/* Stop the burst capture */
+		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+			START_DUAL_CAPTURE, DUAL_CAPTURE_BURST_CAPTURE_STOP);
+		if (ret)
+			return ret;
+		/* captutre mode back to normal */
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_NORMAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int m10mo_set_lls_mode(struct v4l2_subdev *sd, unsigned int val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	switch(val) {
+	case STOP_LLS_MODE:
+		/* switch to normal capture. HDR MODE off */
+		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, REG_CAP_NV12_MODE,
+				NORMAL_CAPTURE);
+		if (!ret)
+			dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_NORMAL;
+		break;
+	case START_LLS_MODE:
+		/* switch to HDR mode */
+		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, REG_CAP_NV12_MODE,
+				LLS_CAPTURE);
+		if (!ret)
+			dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_LLS;
+		break;
+	case RESUME_PREVIEW_IN_LLS_MODE:
+		/* switch to HDR mode */
+		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+				START_DUAL_CAPTURE, PREVIEW_IN_NV12_MODE);
+		if (!ret)
+			dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_LLS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int m10mo_set_hdr_mode(struct v4l2_subdev *sd, unsigned int val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	switch(val) {
+	case STOP_HDR_MODE:
+		/* switch to normal capture. HDR MODE off */
+		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, REG_CAP_NV12_MODE,
+				NORMAL_CAPTURE);
+		if (!ret)
+			dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_NORMAL;
+		break;
+	case START_HDR_MODE:
+		/* switch to HDR mode */
+		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, REG_CAP_NV12_MODE,
+				HDR_CAPTURE);
+		if (!ret)
+			dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_HDR;
+		break;
+	case RESUME_PREVIEW_IN_HDR_MODE:
+		/* switch to HDR mode */
+		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+				START_DUAL_CAPTURE, PREVIEW_IN_NV12_MODE);
+		if (!ret)
+			dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_HDR;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int m10mo_set_shot_mode(struct v4l2_subdev *sd, unsigned int val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int shot_mode_support = M10MO_SHOT_MODES_SUPPORTED(dev->fw_type);
+
+	if (!shot_mode_support)
+		return -EINVAL;
+
+	switch (val) {
+	case EXT_ISP_SHOT_MODE_AUTO:
+		dev->shot_mode = SHOT_MODE_AUTO;
+		break;
+	case EXT_ISP_SHOT_MODE_BEAUTY_FACE:
+		dev->shot_mode = SHOT_MODE_BEAUTY_FACE;
+		break;
+	case EXT_ISP_SHOT_MODE_BEST_PHOTO:
+		dev->shot_mode = SHOT_MODE_BEST_PHOTO;
+		break;
+	case EXT_ISP_SHOT_MODE_DRAMA:
+		dev->shot_mode = SHOT_MODE_DRAMA;
+		break;
+	case EXT_ISP_SHOT_MODE_BEST_FACE:
+		dev->shot_mode = SHOT_MODE_BEST_FACE;
+		break;
+	case EXT_ISP_SHOT_MODE_ERASER:
+		dev->shot_mode = SHOT_MODE_ERASER;
+		break;
+	case EXT_ISP_SHOT_MODE_PANORAMA:
+		dev->shot_mode = SHOT_MODE_PANORAMA;
+		break;
+	case EXT_ISP_SHOT_MODE_RICH_TONE_HDR:
+		dev->shot_mode = SHOT_MODE_RICH_TONE_HDR;
+		break;
+	case EXT_ISP_SHOT_MODE_NIGHT:
+		dev->shot_mode = SHOT_MODE_NIGHT;
+		break;
+	case EXT_ISP_SHOT_MODE_SOUND_SHOT:
+		dev->shot_mode = SHOT_MODE_SOUND_SHOT;
+		break;
+	case EXT_ISP_SHOT_MODE_ANIMATED_PHOTO:
+		dev->shot_mode = SHOT_MODE_ANIMATED_PHOTO;
+		break;
+	case EXT_ISP_SHOT_MODE_SPORTS:
+		dev->shot_mode = SHOT_MODE_SPORTS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int m10mo_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __m10mo_s_power(sd, on, false);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+int m10mo_single_capture_process(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+	u32 fmt;
+
+	/* Select frame */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+			  CAPC_SEL_FRAME_MAIN, 0x01);
 	if (ret)
 		return ret;
 
 	/* Image format */
-	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM,
-			  CAPP_YUVOUT_MAIN, CAPP_YUVOUT_MAIN);
+	if (dev->format.code == V4L2_MBUS_FMT_JPEG_1X8)
+		fmt = CAPTURE_FORMAT_JPEG8;
+	else
+		fmt = CAPTURE_FORMAT_YUV422;
 
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM, CAPP_YUVOUT_MAIN, fmt);
 	if (ret)
 		return ret;
 
 	/* Image size */
 	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM, CAPP_MAIN_IMAGE_SIZE,
-			  dev->curr_res_table[dev->fmt_idx].command);
-
+			   dev->curr_res_table[dev->fmt_idx].command);
 	if (ret)
 		return ret;
 
@@ -604,15 +1563,39 @@ static irqreturn_t m10mo_irq_thread(int irq, void *dev_id)
 			dev->mode = M10MO_PARAM_SETTING_MODE;
 		}
 		break;
+	case M10MO_PARAMETER_MODE:
+		if (int_factor & REG_INT_STATUS_MODE) {
+			dev->mode = M10MO_PARAMETER_MODE;
+		}
+		break;
 	case M10MO_MONITOR_MODE:
 		if (int_factor & REG_INT_STATUS_MODE) {
 			dev->mode = M10MO_MONITOR_MODE;
 		}
 		break;
+	case M10MO_MONITOR_MODE_ZSL:
+		if (int_factor & REG_INT_STATUS_MODE) {
+			dev->mode = M10MO_MONITOR_MODE_ZSL;
+		}
+		break;
+	case M10MO_MONITOR_MODE_PANORAMA:
+		if (int_factor & REG_INT_STATUS_MODE) {
+			dev->mode = M10MO_MONITOR_MODE_PANORAMA;
+		}
+		break;
 	case M10MO_SINGLE_CAPTURE_MODE:
 		if (int_factor & REG_INT_STATUS_CAPTURE) {
 			dev->mode = M10MO_SINGLE_CAPTURE_MODE;
-			m10mo_single_capture_process(sd);
+			dev->fw_ops->single_capture_process(sd);
+		}
+		break;
+	case M10MO_BURST_CAPTURE_MODE:
+		if (int_factor & REG_INT_STATUS_MODE)
+			dev->mode = M10MO_BURST_CAPTURE_MODE;
+		break;
+	case M10MO_MONITOR_MODE_HIGH_SPEED:
+		if (int_factor & REG_INT_STATUS_MODE) {
+			dev->mode = M10MO_MONITOR_MODE_HIGH_SPEED;
 		}
 		break;
 	default:
@@ -665,51 +1648,15 @@ out:
 	return ret;
 }
 
-#define LARGEST_ALLOWED_RATIO_MISMATCH 500
-static int distance(struct m10mo_resolution const *res, const u32 w,
-				const u32 h)
-{
-	unsigned int w_ratio = ((res->width << 13) / w);
-	unsigned int h_ratio = ((res->height << 13) / h);
-	int match = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
-
-	if ((w_ratio < 8192) || (h_ratio < 8192)
-		|| (match > LARGEST_ALLOWED_RATIO_MISMATCH))
-		return -1;
-
-	return w_ratio + h_ratio;
-}
-
-static int nearest_resolution_index(struct v4l2_subdev *sd, u32 w, u32 h)
-{
-	const struct m10mo_resolution *tmp_res = NULL;
-	struct m10mo_device *dev = to_m10mo_sensor(sd);
-	int min_dist = INT_MAX;
-	int idx = -1;
-	int i, dist;
-
-	for (i = 0; i < dev->entries_curr_table; i++) {
-		tmp_res = &dev->curr_res_table[i];
-		dist = distance(tmp_res, w, h);
-		if (dist == -1)
-			continue;
-		if (dist < min_dist) {
-			min_dist = dist;
-			idx = i;
-		}
-	}
-	return idx;
-}
-
-static int get_resolution_index(struct v4l2_subdev *sd, int w, int h)
+int get_resolution_index(const struct m10mo_resolution *res,
+			int entries, int w, int h)
 {
-	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int i;
 
-	for (i = 0; i < dev->entries_curr_table; i++) {
-		if (w != dev->curr_res_table[i].width)
+	for (i = 0; i < entries; i++) {
+		if (w != res[i].width)
 			continue;
-		if (h != dev->curr_res_table[i].height)
+		if (h != res[i].height)
 			continue;
 		/* Found it */
 		return i;
@@ -717,38 +1664,75 @@ static int get_resolution_index(struct v4l2_subdev *sd, int w, int h)
 	return -1;
 }
 
-static int __m10mo_try_mbus_fmt(struct v4l2_subdev *sd,
-				 struct v4l2_mbus_framefmt *fmt)
+int __m10mo_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt, bool update_fmt)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
-	int idx;
-
-	if (!fmt)
-		return -EINVAL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+			(struct atomisp_input_stream_info *)fmt->reserved;
+	const struct m10mo_resolution *res;
+	int entries, idx;
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+
+	if (fmt->code != V4L2_MBUS_FMT_JPEG_1X8 &&
+	    fmt->code != V4L2_MBUS_FMT_UYVY8_1X16 &&
+	    fmt->code != V4L2_MBUS_FMT_CUSTOM_NV12 &&
+	    fmt->code != V4L2_MBUS_FMT_CUSTOM_NV21 &&
+	    fmt->code != V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+		dev_info(&client->dev,
+			 "%s unsupported code: 0x%x. Set to NV12\n",
+			 __func__, fmt->code);
+		fmt->code = V4L2_MBUS_FMT_CUSTOM_NV12;
+	}
 
-	idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+	/* In ZSL case, capture table needs to be handled separately */
+	if (stream_info->stream == ATOMISP_INPUT_STREAM_CAPTURE &&
+			(dev->run_mode == CI_MODE_PREVIEW ||
+			 dev->run_mode == CI_MODE_VIDEO ||
+			 dev->run_mode == CI_MODE_CONTINUOUS)) {
+		res = resolutions[mode][M10MO_MODE_CAPTURE_INDEX];
+		entries =
+		     resolutions_sizes[mode][M10MO_MODE_CAPTURE_INDEX];
+	} else {
+		res = dev->curr_res_table;
+		entries = dev->entries_curr_table;
+	}
 
-	/* Fall back to the last if not found */
-	if (idx == -1)
-		idx = dev->entries_curr_table - 1;
+	/* check if the given resolutions are spported */
+	idx = get_resolution_index(res, entries, fmt->width, fmt->height);
+	if (idx < 0) {
+		dev_err(&client->dev, "%s unsupported resolution: %dx%d\n",
+			__func__, fmt->width, fmt->height);
+		return -EINVAL;
+	}
 
-	fmt->width = dev->curr_res_table[idx].width;
-	fmt->height = dev->curr_res_table[idx].height;
-	fmt->code = M10MO_FORMAT;
-	return 0;
+	/* If the caller wants to get updated fmt values based on the search */
+	if (update_fmt) {
+		if (fmt->code == V4L2_MBUS_FMT_JPEG_1X8) {
+			fmt->width = dev->mipi_params.jpeg_width;
+			fmt->height = dev->mipi_params.jpeg_height;
+		} else if (fmt->code == V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+			fmt->width = dev->mipi_params.raw_width;
+			fmt->height = dev->mipi_params.raw_height;
+		} else {
+			fmt->width = res[idx].width;
+			fmt->height = res[idx].height;
+		}
+	}
+	return idx;
 }
 
 static int m10mo_try_mbus_fmt(struct v4l2_subdev *sd,
 				struct v4l2_mbus_framefmt *fmt)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
-	int r;
+	int idx;
 
 	mutex_lock(&dev->input_lock);
-	r = __m10mo_try_mbus_fmt(sd, fmt);
+	idx = dev->fw_ops->try_mbus_fmt(sd, fmt, true);
 	mutex_unlock(&dev->input_lock);
-
-	return r;
+	return idx >= 0 ? 0 : -EINVAL;
 }
 
 static int m10mo_get_mbus_fmt(struct v4l2_subdev *sd,
@@ -760,71 +1744,292 @@ static int m10mo_get_mbus_fmt(struct v4l2_subdev *sd,
 
 	fmt->width = dev->curr_res_table[dev->fmt_idx].width;
 	fmt->height = dev->curr_res_table[dev->fmt_idx].height;
-	fmt->code = M10MO_FORMAT;
+	fmt->code = dev->format.code;
 
 	mutex_unlock(&dev->input_lock);
 
 	return 0;
 }
 
+int __m10mo_update_stream_info(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct atomisp_input_stream_info *stream_info =
+			(struct atomisp_input_stream_info*)fmt->reserved;
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+
+	/* TODO: Define a FW Type as well. Resolution could be reused */
+	switch (mode) {
+	case M10MO_RESOLUTION_MODE_0:
+		/* TODO: handle FW type cases here */
+		break;
+	case M10MO_RESOLUTION_MODE_1:
+		/* Raw Capture is a special case. Capture data comes like HDR */
+		if (fmt->code == V4L2_MBUS_FMT_JPEG_1X8 ||
+			fmt->code == V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+			/* fill stream info */
+			stream_info->ch_id = M10MO_ZSL_JPEG_VIRTUAL_CHANNEL;
+			stream_info->isys_configs = 1;
+			stream_info->isys_info[0].input_format =
+				(u8)ATOMISP_INPUT_FORMAT_USER_DEF3;
+			stream_info->isys_info[0].width = 0;
+			stream_info->isys_info[0].height = 0;
+		} else if (fmt->code == V4L2_MBUS_FMT_CUSTOM_NV12 ||
+			   fmt->code == V4L2_MBUS_FMT_CUSTOM_NV21) {
+			stream_info->ch_id = M10MO_ZSL_NV12_VIRTUAL_CHANNEL;
+			stream_info->isys_configs = 2;
+			/* first stream */
+			stream_info->isys_info[0].input_format =
+				(u8)ATOMISP_INPUT_FORMAT_USER_DEF1;
+			stream_info->isys_info[0].width = (u16)fmt->width;
+			stream_info->isys_info[0].height = (u16)fmt->height;
+			/* Second stream */
+			stream_info->isys_info[1].input_format =
+				(u8)ATOMISP_INPUT_FORMAT_USER_DEF2;
+			stream_info->isys_info[1].width = (u16)fmt->width;
+			stream_info->isys_info[1].height = (u16)fmt->height / 2;
+		}
+		break;
+	}
+	return 0;
+}
+
+int __m10mo_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+			(struct atomisp_input_stream_info *)fmt->reserved;
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+	int index;
+
+	mutex_lock(&dev->input_lock);
+
+	index = dev->fw_ops->try_mbus_fmt(sd, fmt, false);
+	if (index < 0) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	dev->format.code = fmt->code;
+	dev->fmt_idx = index;
+	if (stream_info->stream == ATOMISP_INPUT_STREAM_CAPTURE) {
+		/* Save the index for selecting the capture resolution */
+		dev->capture_res_idx = dev->fmt_idx;
+	}
+
+	/*
+	 * In ZSL Capture cases, for capture an image the run mode is not
+	 * changed. So we need to maintain a separate cpature table index
+	 * to select the snapshot sizes.
+	 */
+	if (stream_info->stream == ATOMISP_INPUT_STREAM_CAPTURE &&
+	    (dev->run_mode == CI_MODE_PREVIEW ||
+	     dev->run_mode == CI_MODE_VIDEO ||
+	     dev->run_mode == CI_MODE_CONTINUOUS))
+		dev->capture_res_idx = dev->fmt_idx;
+
+	dev_dbg(&client->dev,
+		"%s index prev/cap: %d/%d width: %d, height: %d, code; 0x%x\n",
+		 __func__, dev->fmt_idx, dev->capture_res_idx, fmt->width,
+		 fmt->height, dev->format.code);
+
+	/* Make the fixed width and height for JPEG and RAW formats */
+	if (dev->format.code == V4L2_MBUS_FMT_JPEG_1X8) {
+		/* The m10mo can only run JPEG in 30fps or lower */
+		dev->fps = M10MO_NORMAL_FPS;
+		fmt->width = dev->mipi_params.jpeg_width;
+		fmt->height = dev->mipi_params.jpeg_height;
+	} else if (dev->format.code == V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+		fmt->width = dev->mipi_params.raw_width;
+		fmt->height = dev->mipi_params.raw_height;
+	}
+
+	/* Update the stream info. Atomisp uses this for configuring mipi */
+	__m10mo_update_stream_info(sd, fmt);
+
+	/*
+	 * Handle raw capture mode separately. Update the capture mode to RAW
+	 * capture now. So that the next streamon call will start RAW capture.
+	 */
+	if (mode == M10MO_RESOLUTION_MODE_1 &&
+	    dev->format.code == V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+		dev_dbg(&client->dev, "%s RAW capture mode\n", __func__);
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_RAW;
+		dev->capture_res_idx = dev->fmt_idx;
+		dev->fmt_idx = 0;
+	}
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
 static int m10mo_set_mbus_fmt(struct v4l2_subdev *sd,
 			      struct v4l2_mbus_framefmt *fmt)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	return dev->fw_ops->set_mbus_fmt(sd, fmt);
+}
+
+static int m10mo_identify_fw_type(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct m10mo_fw_id *fw_ids = NULL;
+	char buffer[M10MO_MAX_FW_ID_STRING];
 	int ret;
 
-	mutex_lock(&dev->input_lock);
+	int m10mo_fw_address_cnt = m10mo_get_fw_address_count();
+	int i;
+
+	ret = dev->pdata->identify_fw();
+	if (ret != -1) {
+		dev->fw_type = ret;
+		return 0;
+	}
+
+	for (i = 0; i < m10mo_fw_address_cnt; i++) {
+		fw_ids = dev->pdata->fw_ids;
+		if (!fw_ids)
+			return 0;
+
+		ret = m10mo_get_isp_fw_version_string(dev, buffer,
+				sizeof(buffer), i);
+		if (ret)
+			return ret;
+
+		while (fw_ids->id_string) {
+			if (!strncmp(fw_ids->id_string, buffer,
+				     strlen(fw_ids->id_string)))
+			{
+				dev_info(&client->dev, "FW id %s detected\n", buffer);
+				dev->fw_type = fw_ids->fw_type;
+				dev->fw_addr_id = i;
+				return 0;
+			}
+			fw_ids++;
+		}
+	}
+
+	dev_err(&client->dev, "FW id string table given but no match found");
+	return 0;
+}
+
+static void m10mo_mipi_initialization(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int id = M10MO_GET_MIPI_PACKET_SIZE_IDX(dev->fw_type);
+	u32 mipi_packet_size = dev->pdata->mipi_packet_size[id];
+
+	dev->mipi_params.jpeg_width = mipi_packet_size;
+	dev->mipi_params.jpeg_height = M10MO_MAX_YUV422_SIZE / mipi_packet_size;
+
+	dev->mipi_params.raw_width = mipi_packet_size;
+	dev->mipi_params.raw_height = M10MO_MAX_RAW_SIZE / mipi_packet_size;
+
+	dev_dbg(&client->dev,
+		"%s JPEG: W=%d H=%d, RAW: W=%d H=%d\n", __func__,
+		dev->mipi_params.jpeg_width, dev->mipi_params.jpeg_height,
+		dev->mipi_params.raw_width, dev->mipi_params.raw_height);
+}
+
+int m10mo_set_still_capture(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	dev_info(&client->dev, "%s mode: %d width: %d, height: %d, cmd: 0x%x\n",
+		__func__, dev->mode, dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command);
 
-	ret = __m10mo_try_mbus_fmt(sd, fmt);
+	ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x08);
 	if (ret)
 		goto out;
 
-	/* This will be set during the next stream on call */
-	dev->fmt_idx = get_resolution_index(sd, fmt->width, fmt->height);
-	if (dev->fmt_idx == -1) {
-		ret = -EINVAL;
-		goto out;
-	}
+	/* Set capture mode */
+	ret = m10mo_request_mode_change(sd, M10MO_SINGLE_CAPTURE_MODE);
 
 out:
-	mutex_unlock(&dev->input_lock);
 	return ret;
 }
 
-static int m10mo_identify_fw_type(struct v4l2_subdev *sd)
+static int m10mo_set_run_mode(struct v4l2_subdev *sd)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct m10mo_fw_id *fw_ids = NULL;
-	char buffer[M10MO_MAX_FW_ID_STRING];
 	int ret;
 
-	fw_ids = dev->pdata->fw_ids;
-	if (!fw_ids)
-		return 0;
-
-	ret = m10mo_get_isp_fw_version_string(dev, buffer, sizeof(buffer));
-	if (ret)
-		return ret;
-
-	while(fw_ids->id_string) {
+	/*
+	 * Handle RAW capture mode separately irrespective of the run mode
+	 * being configured. Start the RAW capture right away.
+	 */
+	if (dev->capture_mode == M10MO_CAPTURE_MODE_ZSL_RAW) {
 		/*
-		 * Null char is skipped (strlen - 1) because the string in
-		 * platform data can be shorter than the string in the FW.
-		 * There can be some additional information
-		 * after the match.
+		 * As RAW capture is done from a command line tool, we are not
+		 * restarting the preview after the RAW capture. So it is ok
+		 * to reset the RAW capture mode here because the next RAW
+		 * capture has to start from the Set format onwards.
 		 */
-		if (!strncmp(fw_ids->id_string, buffer,
-			     strlen(fw_ids->id_string) - 1))
-		{
-			dev_info(&client->dev, "FW id %s detected\n", buffer);
-			dev->fw_type = fw_ids->fw_type;
-			return 0;
-		}
-		fw_ids++;
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_NORMAL;
+		return m10mo_set_zsl_raw_capture(sd);
+	}
+
+	switch (dev->run_mode) {
+	case CI_MODE_STILL_CAPTURE:
+		ret = m10mo_set_still_capture(sd);
+		break;
+	default:
+		/* TODO: Revisit this logic on switching to panorama */
+		if (dev->curr_res_table[dev->fmt_idx].command == 0x43)
+			ret = m10mo_set_panorama_monitor(sd);
+		else
+			ret = m10mo_set_zsl_monitor(sd);
+	}
+	return ret;
+}
+
+int m10mo_streamoff(struct v4l2_subdev *sd)
+{
+	return __m10mo_param_mode_set(sd);
+}
+
+int m10mo_test_pattern(struct v4l2_subdev *sd, u8 val)
+{
+	return -EINVAL;
+}
+
+static const struct m10mo_fw_ops fw_ops = {
+	.set_run_mode           = m10mo_set_run_mode,
+	.set_burst_mode         = m10mo_set_burst_mode,
+	.stream_off             = m10mo_streamoff,
+	.single_capture_process = m10mo_single_capture_process,
+	.try_mbus_fmt           =  __m10mo_try_mbus_fmt,
+	.set_mbus_fmt           =  __m10mo_set_mbus_fmt,
+	.test_pattern           = m10mo_test_pattern,
+};
+
+void m10mo_handlers_init(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	switch (dev->fw_type) {
+	case M10MO_FW_TYPE_1:
+		dev->fw_ops = &fw_type1_5_ops;
+		break;
+	case M10MO_FW_TYPE_2:
+		dev->fw_ops = &fw_type2_ops;
+		break;
+	case M10MO_FW_TYPE_5:
+		dev->fw_ops = &fw_type1_5_ops;
+		break;
+	default:
+		dev->fw_ops = &fw_ops;
 	}
-	dev_err(&client->dev, "FW id string table given but no match found");
-	return 0;
 }
 
 static int m10mo_s_config(struct v4l2_subdev *sd, int irq)
@@ -833,13 +2038,14 @@ static int m10mo_s_config(struct v4l2_subdev *sd, int irq)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
 	u16 result = M10MO_INVALID_CHECKSUM;
+	int id = 0;
 
 	mutex_lock(&dev->input_lock);
 
 	init_waitqueue_head(&dev->irq_waitq);
 
-	dev->fw_type = M10MO_FW_TYPE_0;
-	dev->ref_clock = dev->pdata->ref_clock_rate;
+	dev->fw_type = dev->pdata->def_fw_type;
+	dev->ref_clock = dev->pdata->ref_clock_rate[id];
 
 	if (dev->pdata->common.platform_init) {
 		ret = dev->pdata->common.platform_init(client);
@@ -860,8 +2066,7 @@ static int m10mo_s_config(struct v4l2_subdev *sd, int irq)
 	ret = __m10mo_s_power(sd, 1, true);
 	if (ret) {
 		dev_err(&client->dev, "power-up err.\n");
-		mutex_unlock(&dev->input_lock);
-		return ret;
+		goto free_irq;
 	}
 
 	if (dev->pdata->common.csi_cfg) {
@@ -886,104 +2091,57 @@ static int m10mo_s_config(struct v4l2_subdev *sd, int irq)
 	 */
 	m10mo_identify_fw_type(sd);
 
+	/*
+	 * Only after identify_fw_type the correct dev->fw_type
+	 * can be got, so here update the ref_clock
+	 */
+	id = M10MO_GET_CLOCK_RATE_MODE(dev->fw_type);
+	dev->ref_clock = dev->pdata->ref_clock_rate[id];
+
+	m10mo_mipi_initialization(sd);
+
+	/* Set proper function pointers based on FW_TYPE */
+	m10mo_handlers_init(sd);
+
 	ret = __m10mo_s_power(sd, 0, true);
-	mutex_unlock(&dev->input_lock);
 	if (ret) {
 		dev_err(&client->dev, "power-down err.\n");
-		return ret;
+		goto free_irq;
 	}
 
+	mutex_unlock(&dev->input_lock);
 	return 0;
 
 fail:
 	__m10mo_s_power(sd, 0, true);
+free_irq:
+	free_irq(client->irq, sd);
+
 	mutex_unlock(&dev->input_lock);
 	dev_err(&client->dev, "External ISP power-gating failed\n");
 	return ret;
 
 }
 
-static int m10mo_set_monitor_mode(struct v4l2_subdev *sd)
+static int m10mo_recovery(struct v4l2_subdev *sd)
 {
-	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	dev_info(&client->dev," Width: %d, height: %d, command: 0x%x\n",
-		dev->curr_res_table[dev->fmt_idx].width,
-		dev->curr_res_table[dev->fmt_idx].height,
-		dev->curr_res_table[dev->fmt_idx].command);
-
-	/*Change to Monitor Size (e,g. VGA) */
-	ret = m10mo_write(sd, 1, CATEGORY_PARAM, PARAM_MON_SIZE,
-			dev->curr_res_table[dev->fmt_idx].command);
-	if (ret)
-		goto out;
-
-	if (dev->fw_type == M10MO_FW_TYPE_0) {
-		/* TODO: FPS setting must be changed */
-		ret = m10mo_write(sd, 1, CATEGORY_PARAM, PARAM_MON_FPS, 0x02);
-		if (ret)
-			goto out;
+	int ret = 0;
 
-		ret = m10mo_write(sd, 1, CATEGORY_PARAM, 0x67, 0x00);
-		if (ret)
-			goto out;
+	/* still power off sensor in case power is cut off abnormally*/
+	ret = __m10mo_s_power(sd, 0, false);
+	if (ret) {
+		dev_err(&client->dev, "power-down err.\n");
+		return ret;
 	}
+	usleep_range(100, 200);
 
-	/* Enable interrupt signal */
-	ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
-	if (ret)
-		goto out;
-	/* Go to Monitor mode and output YUV Data */
-	ret = m10mo_request_mode_change(sd, M10MO_MONITOR_MODE);
-	if (ret)
-		goto out;
-
-	return 0;
-out:
-	dev_err(&client->dev, "Streaming failed %d\n", ret);
-	return ret;
-}
-
-static int m10mo_set_still_capture(struct v4l2_subdev *sd)
-{
-	struct m10mo_device *dev = to_m10mo_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	dev_info(&client->dev," Width: %d, height: %d, command: 0x%x\n",
-		dev->curr_res_table[dev->fmt_idx].width,
-		dev->curr_res_table[dev->fmt_idx].height,
-		dev->curr_res_table[dev->fmt_idx].command);
-
-	ret= m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x08);
-	if (ret)
-		goto out;
-
-	/* Set capture mode */
-	ret = m10mo_request_mode_change(sd, M10MO_SINGLE_CAPTURE_MODE);
-
-out:
-	return ret;
-}
-
-static int __m10mo_set_run_mode(struct v4l2_subdev *sd)
-{
-	struct m10mo_device *dev = to_m10mo_sensor(sd);
-	int ret;
-
-	switch (dev->run_mode) {
-	case CI_MODE_VIDEO:
-		/* TODO: Differentiate the video mode */
-		ret = m10mo_set_monitor_mode(sd);
-		break;
-	case CI_MODE_STILL_CAPTURE:
-		ret = m10mo_set_still_capture(sd);
-		break;
-	default:
-		ret = m10mo_set_monitor_mode(sd);
+	ret = __m10mo_s_power(sd, 1, false);
+	if (ret) {
+		dev_err(&client->dev, "power-up err.\n");
+		return ret;
 	}
+
 	return ret;
 }
 
@@ -992,11 +2150,29 @@ static int m10mo_s_stream(struct v4l2_subdev *sd, int enable)
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int ret = 0;
 
-	/* TODO: Handle Stream OFF case */
 	mutex_lock(&dev->input_lock);
-	if (enable)
-		ret = __m10mo_set_run_mode(sd);
+	if (enable) {
+		ret = dev->fw_ops->set_run_mode(sd);
+		if (ret) {
+			ret = m10mo_recovery(sd);
+			if (ret) {
+				mutex_unlock(&dev->input_lock);
+				return ret;
+			}
+			ret = dev->fw_ops->set_run_mode(sd);
+		}
+	} else {
+		ret = dev->fw_ops->stream_off(sd);
+	}
+
 	mutex_unlock(&dev->input_lock);
+
+	/*
+	 * Dump M10MO log when stream-off with checking folder
+	 */
+	if (!enable)
+		m10mo_dump_log(sd);
+
 	return ret;
 }
 
@@ -1021,10 +2197,12 @@ static int m10mo_enum_mbus_code(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_fh *fh,
 				  struct v4l2_subdev_mbus_code_enum *code)
 {
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
 	if (code->index)
 		return -EINVAL;
 
-	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+	code->code = dev->format.code;
 	return 0;
 }
 
@@ -1105,35 +2283,287 @@ static int m10mo_set_flicker_freq(struct v4l2_subdev *sd, s32 val)
 		return -EINVAL;
 	}
 
-	return m10mo_writeb(sd, CATEGORY_AE, AE_FLICKER, flicker_freq);
+	return m10mo_writeb(sd, CATEGORY_AE, AE_FLICKER, flicker_freq);
+}
+
+static int m10mo_set_metering(struct v4l2_subdev *sd, s32 val)
+{
+	unsigned int metering;
+
+	switch (val) {
+	case V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:
+		metering = M10MO_METERING_CENTER;
+		break;
+	case V4L2_EXPOSURE_METERING_SPOT:
+		metering = M10MO_METERING_SPOT;
+		break;
+	case V4L2_EXPOSURE_METERING_AVERAGE:
+		metering = M10MO_METERING_AVERAGE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return m10mo_writeb(sd, CATEGORY_AE, AE_MODE, metering);
+}
+
+static const unsigned short wb_lut[][2] = {
+	{ V4L2_WHITE_BALANCE_INCANDESCENT,  REG_AWB_INCANDESCENT },
+	{ V4L2_WHITE_BALANCE_FLUORESCENT,   REG_AWB_FLUORESCENT_L },
+	{ V4L2_WHITE_BALANCE_FLUORESCENT_H, REG_AWB_FLUORESCENT_H },
+	{ V4L2_WHITE_BALANCE_HORIZON,       REG_AWB_HORIZON },
+	{ V4L2_WHITE_BALANCE_DAYLIGHT,      REG_AWB_DAYLIGHT },
+	{ V4L2_WHITE_BALANCE_FLASH,         REG_AWB_LEDLIGHT },
+	{ V4L2_WHITE_BALANCE_CLOUDY,        REG_AWB_CLOUDY },
+	{ V4L2_WHITE_BALANCE_SHADE,         REG_AWB_SHADE },
+	{ V4L2_WHITE_BALANCE_AUTO,          REG_AWB_AUTO },
+};
+
+static int m10mo_set_white_balance(struct v4l2_subdev *sd, s32 val)
+{
+	int i, ret;
+	int awb = REG_AWB_MANUAL;
+
+	for (i = 0; i < ARRAY_SIZE(wb_lut); i++) {
+		if (val == wb_lut[i][0])
+			break;
+	}
+
+	if (i == ARRAY_SIZE(wb_lut))
+		return -EINVAL;
+
+	if (wb_lut[i][0] == V4L2_WHITE_BALANCE_AUTO)
+		awb = REG_AWB_AUTO;
+
+	ret = m10mo_writeb(sd, CATEGORY_WB,
+			   AWB_MODE, awb);
+	if (ret < 0)
+		return ret;
+
+	if (awb == REG_AWB_MANUAL)
+		ret = m10mo_writeb(sd, CATEGORY_WB,
+				   AWB_PRESET, wb_lut[i][1]);
+	return ret;
+}
+
+static int m10mo_set_ev_bias(struct v4l2_subdev *sd, s32 val)
+{
+	/* 0x04 refers to 0.0EV value in m10mo HW */
+	/* val refers to EV units, where the */
+	/* value 1000 stands for +1EV */
+
+	int ev_bias = 0x04 + (val/M10MO_EV_STEP);
+	return m10mo_writeb(sd, CATEGORY_AE, AE_EV_BIAS, ev_bias);
+}
+
+static int m10mo_get_ev_bias(struct v4l2_subdev *sd, s32 *val)
+{
+	int ret;
+	u32 ev_bias;
+
+	ret = m10mo_readb(sd, CATEGORY_AE, AE_EV_BIAS, &ev_bias);
+	if (ret)
+		return ret;
+
+	*val = (ev_bias-4) * M10MO_EV_STEP;
+	return 0;
+}
+
+
+static const unsigned short iso_lut[][2] = {
+	{ 100,  REG_AE_ISOMODE_ISO100},
+	{ 200,  REG_AE_ISOMODE_ISO200},
+	{ 400,  REG_AE_ISOMODE_ISO400},
+	{ 800,  REG_AE_ISOMODE_ISO800},
+	{ 1600, REG_AE_ISOMODE_ISO1600},
+};
+
+static int m10mo_set_iso_sensitivity(struct v4l2_subdev *sd, s32 val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret, i;
+
+	for (i = 0; i < ARRAY_SIZE(iso_lut); i++) {
+		if (val == iso_lut[i][0])
+			break;
+	}
+
+	if (i == ARRAY_SIZE(iso_lut))
+		return -EINVAL;
+
+	if (dev->iso_mode == V4L2_ISO_SENSITIVITY_MANUAL) {
+		ret = m10mo_writeb(sd, CATEGORY_AE,
+				   AE_ISOMODE, iso_lut[i][1]);
+		if (ret < 0)
+			return ret;
+	}
+	dev->iso_sensitivity = iso_lut[i][1];
+
+	return 0;
+}
+
+static int m10mo_set_iso_mode(struct v4l2_subdev *sd, s32 val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	if (val == V4L2_ISO_SENSITIVITY_AUTO) {
+		ret = m10mo_writeb(sd, CATEGORY_AE,
+				   AE_ISOMODE, REG_AE_ISOMODE_AUTO);
+		if (ret < 0)
+			return ret;
+		dev->iso_mode = V4L2_ISO_SENSITIVITY_AUTO;
+	} else {
+		ret = m10mo_writeb(sd, CATEGORY_AE,
+				   AE_ISOMODE, dev->iso_sensitivity);
+		if (ret < 0)
+			return ret;
+		dev->iso_mode = V4L2_ISO_SENSITIVITY_MANUAL;
+	}
+
+	return 0;
+}
+
+static const unsigned short ce_lut[][2] = {
+	{ V4L2_COLORFX_NONE,     COLOR_EFFECT_NONE},
+	{ V4L2_COLORFX_NEGATIVE, COLOR_EFFECT_NEGATIVE},
+	{ V4L2_COLORFX_WARM,     COLOR_EFFECT_WARM},
+	{ V4L2_COLORFX_COLD,     COLOR_EFFECT_COLD},
+	{ V4L2_COLORFX_WASHED,   COLOR_EFFECT_WASHED},
+};
+
+static const unsigned short cbcr_lut[][3] = {
+	{ V4L2_COLORFX_SEPIA,   COLOR_CFIXB_SEPIA,   COLOR_CFIXR_SEPIA},
+	{ V4L2_COLORFX_BW,      COLOR_CFIXB_BW,      COLOR_CFIXR_BW},
+	{ V4L2_COLORFX_RED,     COLOR_CFIXB_RED,     COLOR_CFIXR_RED},
+	{ V4L2_COLORFX_GREEN,   COLOR_CFIXB_GREEN,   COLOR_CFIXR_GREEN},
+	{ V4L2_COLORFX_BLUE,    COLOR_CFIXB_BLUE,    COLOR_CFIXR_BLUE},
+	{ V4L2_COLORFX_PINK ,   COLOR_CFIXB_PINK,    COLOR_CFIXR_PINK},
+	{ V4L2_COLORFX_YELLOW,  COLOR_CFIXB_YELLOW,  COLOR_CFIXR_YELLOW},
+	{ V4L2_COLORFX_PURPLE,  COLOR_CFIXB_PURPLE,  COLOR_CFIXR_PURPLE},
+	{ V4L2_COLORFX_ANTIQUE, COLOR_CFIXB_ANTIQUE, COLOR_CFIXR_ANTIQUE},
+};
+
+static int m10mo_set_cb_cr(struct v4l2_subdev *sd, u8 cfixb, u8 cfixr)
+{
+	int ret;
+
+	ret = m10mo_writeb(sd, CATEGORY_MONITOR,
+			   MONITOR_CFIXB, cfixb);
+	if (ret)
+		return ret;
+
+	ret = m10mo_writeb(sd, CATEGORY_MONITOR,
+			   MONITOR_CFIXR, cfixr);
+	if (ret)
+		return ret;
+
+	ret = m10mo_writeb(sd, CATEGORY_MONITOR,
+			   MONITOR_COLOR_EFFECT, COLOR_EFFECT_ON);
+	return ret;
+}
+
+static int m10mo_set_color_effect(struct v4l2_subdev *sd, s32 val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	int i, ret;
+
+	switch (val) {
+	case V4L2_COLORFX_NONE:
+	case V4L2_COLORFX_NEGATIVE:
+	case V4L2_COLORFX_WARM:
+	case V4L2_COLORFX_COLD:
+	case V4L2_COLORFX_WASHED:
+		for (i = 0; i < ARRAY_SIZE(ce_lut); i++) {
+			if (val == ce_lut[i][0])
+				break;
+		}
+
+		if (i == ARRAY_SIZE(ce_lut))
+			return -EINVAL;
+
+		ret = m10mo_writeb(sd, CATEGORY_MONITOR,
+				   MONITOR_COLOR_EFFECT, ce_lut[i][1]);
+		break;
+	case V4L2_COLORFX_SEPIA:
+	case V4L2_COLORFX_BW:
+	case V4L2_COLORFX_ANTIQUE:
+	case V4L2_COLORFX_RED:
+	case V4L2_COLORFX_GREEN:
+	case V4L2_COLORFX_BLUE:
+	case V4L2_COLORFX_PINK:
+	case V4L2_COLORFX_YELLOW:
+	case V4L2_COLORFX_PURPLE:
+		for (i = 0; i < ARRAY_SIZE(cbcr_lut); i++) {
+			if (val == cbcr_lut[i][0])
+				break;
+		}
+
+		if (i == ARRAY_SIZE(cbcr_lut))
+			return -EINVAL;
+
+		ret = m10mo_set_cb_cr(sd, cbcr_lut[i][1], cbcr_lut[i][2]);
+		break;
+	case V4L2_COLORFX_SET_CBCR:
+		ret = m10mo_set_cb_cr(sd, dev->colorfx_cb, dev->colorfx_cr);
+		break;
+	default:
+		ret = -EINVAL;
+	};
+
+	return ret;
 }
 
-static int m10mo_set_metering(struct v4l2_subdev *sd, s32 val)
+static int m10mo_set_color_effect_cbcr(struct v4l2_subdev *sd, s32 val)
 {
-	unsigned int metering;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+	u8 cr, cb;
 
-	switch (val) {
-	case V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:
-		metering = M10MO_METERING_CENTER;
-		break;
-	case V4L2_EXPOSURE_METERING_SPOT:
-		metering = M10MO_METERING_SPOT;
-		break;
-	case V4L2_EXPOSURE_METERING_AVERAGE:
-		metering = M10MO_METERING_AVERAGE;
-		break;
-	default:
-		return -EINVAL;
+	cr = val & 0xff;
+	cb = (val >> 8) & 0xff;
+
+	if (dev->colorfx->cur.val == V4L2_COLORFX_SET_CBCR) {
+		ret = m10mo_set_cb_cr(sd, cb, cr);
+		if (ret)
+			return ret;
 	}
 
-	return m10mo_writeb(sd, CATEGORY_AE, AE_MODE, metering);
+	dev->colorfx_cr = cr;
+	dev->colorfx_cb = cb;
+
+	return 0;
+}
+
+static int m10mo_get_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (M10MO_FOCAL_LENGTH_NUM << 16) | M10MO_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int m10mo_get_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (M10MO_F_NUMBER_DEFAULT_NUM << 16) | M10MO_F_NUMBER_DEM;
+	return 0;
+}
+
+static int m10mo_get_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (M10MO_F_NUMBER_DEFAULT_NUM << 24) |
+		(M10MO_F_NUMBER_DEM << 16) |
+		(M10MO_F_NUMBER_DEFAULT_NUM << 8) | M10MO_F_NUMBER_DEM;
+	return 0;
 }
 
 static int m10mo_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct m10mo_device *dev = container_of(
 		ctrl->handler, struct m10mo_device, ctrl_handler);
-	int ret;
+	int ret = 0;
+
+	if (!dev->power)
+		return 0;
 
 	switch (ctrl->id) {
 	case V4L2_CID_POWER_LINE_FREQUENCY:
@@ -1142,6 +2572,31 @@ static int m10mo_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_EXPOSURE_METERING:
 		ret = m10mo_set_metering(&dev->sd, ctrl->val);
 		break;
+	case V4L2_CID_START_ZSL_CAPTURE:
+		if (ctrl->val)
+			ret = m10mo_set_zsl_capture(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		ret = m10mo_set_white_balance(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = m10mo_set_ev_bias(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_ISO_SENSITIVITY:
+		ret = m10mo_set_iso_sensitivity(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_ISO_SENSITIVITY_AUTO:
+		ret = m10mo_set_iso_mode(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_COLORFX:
+		ret = m10mo_set_color_effect(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_COLORFX_CBCR:
+		ret = m10mo_set_color_effect_cbcr(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = dev->fw_ops->test_pattern(&dev->sd, ctrl->val);
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -1149,16 +2604,38 @@ static int m10mo_s_ctrl(struct v4l2_ctrl *ctrl)
 	return ret;
 }
 
+static const u32 m10mo_mipi_freq[] = {
+	M10MO_MIPI_FREQ_0,
+	M10MO_MIPI_FREQ_1,
+};
+
 static int m10mo_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
+	struct m10mo_device *dev = container_of(
+		ctrl->handler, struct m10mo_device, ctrl_handler);
+	int ret = 0;
+	int id = M10MO_GET_MIPI_FREQ_MODE(dev->fw_type);
+
 	switch (ctrl->id) {
 	case V4L2_CID_LINK_FREQ:
-		ctrl->val = M10MO_MIPI_FREQ;
+		ctrl->val = m10mo_mipi_freq[id];
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = m10mo_get_ev_bias(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FOCAL_ABSOLUTE:
+		ret = m10mo_get_focal(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FNUMBER_ABSOLUTE:
+		ret = m10mo_get_fnumber(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FNUMBER_RANGE:
+		ret = m10mo_get_fnumber_range(&dev->sd, &ctrl->val);
 		break;
 	default:
 		return -EINVAL;
 	}
-	return 0;
+	return ret;
 }
 
 static struct v4l2_ctrl_ops m10mo_ctrl_ops = {
@@ -1171,13 +2648,11 @@ static int m10mo_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int index;
-	dev->run_mode = param->parm.capture.capturemode;
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
 
 	mutex_lock(&dev->input_lock);
+	dev->run_mode = param->parm.capture.capturemode;
 	switch (dev->run_mode) {
-	case CI_MODE_VIDEO:
-		index = M10MO_MODE_VIDEO_INDEX;
-		break;
 	case CI_MODE_STILL_CAPTURE:
 		index = M10MO_MODE_CAPTURE_INDEX;
 		break;
@@ -1185,13 +2660,82 @@ static int m10mo_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
 		index = M10MO_MODE_PREVIEW_INDEX;
 		break;
 	}
-	dev->entries_curr_table = resolutions_sizes[dev->fw_type][index];
-	dev->curr_res_table = resolutions[dev->fw_type][index];
+	dev->entries_curr_table = resolutions_sizes[mode][index];
+	dev->curr_res_table = resolutions[mode][index];
 
 	mutex_unlock(&dev->input_lock);
 	return 0;
 }
 
+static long m10mo_ioctl(struct v4l2_subdev *sd, unsigned int cmd,
+			void *arg)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_ext_isp_ctrl *m10mo_ctrl
+		= (struct atomisp_ext_isp_ctrl *)arg;
+	int ret = 0;
+
+	dev_info(&client->dev, "m10mo ioctl id 0x%x data 0x%x\n",
+			m10mo_ctrl->id, m10mo_ctrl->data);
+
+	mutex_lock(&dev->input_lock);
+	switch(m10mo_ctrl->id)
+	{
+	case EXT_ISP_CID_ISO:
+		dev_info(&client->dev, "m10mo ioctl ISO\n");
+		break;
+	case EXT_ISP_CID_CAPTURE_HDR:
+		ret = m10mo_set_hdr_mode(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_CAPTURE_LLS:
+		ret = m10mo_set_lls_mode(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_FOCUS_MODE:
+		ret = m10mo_set_af_mode(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_FOCUS_EXECUTION:
+		ret = m10mo_set_af_execution(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_TOUCH_POSX:
+		ret = m10mo_set_af_position_x(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_TOUCH_POSY:
+		ret = m10mo_set_af_position_y(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_CAF_STATUS:
+		ret = m10mo_get_caf_status(sd, &m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_AF_STATUS:
+		ret = m10mo_get_af_status(sd, &m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_GET_AF_MODE:
+		ret = m10mo_get_af_mode(sd, &m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_CAPTURE_BURST:
+		ret = dev->fw_ops->set_burst_mode(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_FLASH_MODE:
+		ret = m10mo_set_flash_mode(sd, m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_ZOOM:
+		m10mo_ctrl->data = clamp_t(unsigned int, m10mo_ctrl->data,
+						ZOOM_POS_MIN, ZOOM_POS_MAX);
+		ret = m10mo_writeb(sd, CATEGORY_MONITOR, MONITOR_ZOOM,
+						m10mo_ctrl->data);
+		break;
+	case EXT_ISP_CID_SHOT_MODE:
+		ret = m10mo_set_shot_mode(sd, m10mo_ctrl->data);
+		break;
+	default:
+		ret = -EINVAL;
+		dev_err(&client->dev, "m10mo ioctl: Unsupported ID\n");
+	};
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
 static const struct v4l2_ctrl_config ctrls[] = {
 	{
 		.ops = &m10mo_ctrl_ops,
@@ -1222,7 +2766,118 @@ static const struct v4l2_ctrl_config ctrls[] = {
 		.min = 0,
 		.max = 2,
 	},
-
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_START_ZSL_CAPTURE,
+		.name = "Start zsl capture",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 1,
+		.max = 4,
+		.step = 1,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+		.name = "White Balance, Auto & Preset",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = V4L2_WHITE_BALANCE_MANUAL,
+		.def = V4L2_WHITE_BALANCE_AUTO,
+		.max = V4L2_WHITE_BALANCE_SHADE,
+		.step = 1,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_EXPOSURE,
+		.name = "Exposure Bias",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = M10MO_MIN_EV,
+		.def = 0,
+		.max = M10MO_MAX_EV,
+		.step = M10MO_EV_STEP
+	},
+	{
+		.id = V4L2_CID_ISO_SENSITIVITY,
+		.name = "Iso",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 100,
+		.def = 100,
+		.max = 1600,
+		.step = 100,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_ISO_SENSITIVITY_AUTO,
+		.name = "Iso mode",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = V4L2_ISO_SENSITIVITY_MANUAL,
+		.def = V4L2_ISO_SENSITIVITY_AUTO,
+		.max = V4L2_ISO_SENSITIVITY_AUTO,
+		.step = 1,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_COLORFX,
+		.name = "Image Color Effect",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = V4L2_COLORFX_NONE,
+		.def = V4L2_COLORFX_NONE,
+		.max = V4L2_COLORFX_PURPLE,
+		.step = 1,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_COLORFX_CBCR,
+		.name = "Image Color Effect CbCr",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 0xffff,
+		.step = 1,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN,
+		.name = "Test Pattern (Color Bar)",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 1,
+		.step = 1
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_FOCAL_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focal length",
+		.min = M10MO_FOCAL_LENGTH_DEFAULT,
+		.max = M10MO_FOCAL_LENGTH_DEFAULT,
+		.step = 1,
+		.def = M10MO_FOCAL_LENGTH_DEFAULT,
+		.flags = 0,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_FNUMBER_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "f-number",
+		.min = M10MO_F_NUMBER_DEFAULT,
+		.max = M10MO_F_NUMBER_DEFAULT,
+		.step = 1,
+		.def = M10MO_F_NUMBER_DEFAULT,
+		.flags = 0,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_FNUMBER_RANGE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "f-number range",
+		.min = M10MO_F_NUMBER_RANGE,
+		.max =  M10MO_F_NUMBER_RANGE,
+		.step = 1,
+		.def = M10MO_F_NUMBER_RANGE,
+		.flags = 0,
+	},
 };
 
 static int __m10mo_init_ctrl_handler(struct m10mo_device *dev)
@@ -1250,8 +2905,54 @@ static int __m10mo_init_ctrl_handler(struct m10mo_device *dev)
 	v4l2_ctrl_handler_setup(hdl);
 
 	dev->link_freq = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_LINK_FREQ);
+	if (NULL == dev->link_freq)
+		return -ENODEV;
 	v4l2_ctrl_s_ctrl(dev->link_freq, V4L2_CID_LINK_FREQ);
 
+	dev->zsl_capture = v4l2_ctrl_find(&dev->ctrl_handler,
+					V4L2_CID_START_ZSL_CAPTURE);
+	if (NULL == dev->zsl_capture)
+		return -ENODEV;
+	v4l2_ctrl_s_ctrl(dev->zsl_capture, V4L2_CID_START_ZSL_CAPTURE);
+
+	dev->colorfx = v4l2_ctrl_find(&dev->ctrl_handler,
+				      V4L2_CID_COLORFX);
+	return 0;
+}
+
+static int m10mo_s_routing(struct v4l2_subdev *sd, u32 input, u32 output, u32 config)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct atomisp_camera_caps *caps =
+		dev->pdata->common.get_camera_caps();
+
+	/* Select operating sensor. */
+	if (caps->sensor_num > 1) {
+		return m10mo_write(sd, 1, CATEGORY_SYSTEM,
+			SYSTEM_MASTER_SENSOR, !output);
+	}
+
+	return 0;
+}
+
+static int m10mo_s_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *interval)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int fps = 0;
+
+	mutex_lock(&dev->input_lock);
+	if (interval->interval.numerator != 0)
+		fps = interval->interval.denominator / interval->interval.numerator;
+	if (!fps) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+	dev->fps = fps;
+	dev_dbg(&client->dev, "%s: fps is %d\n", __func__, dev->fps);
+	mutex_unlock(&dev->input_lock);
+
 	return 0;
 }
 
@@ -1262,6 +2963,8 @@ static const struct v4l2_subdev_video_ops m10mo_video_ops = {
 	.s_stream = m10mo_s_stream,
 	.s_parm = m10mo_s_parm,
 	.enum_framesizes = m10mo_enum_framesizes,
+	.s_routing = m10mo_s_routing,
+	.s_frame_interval = m10mo_s_frame_interval,
 };
 
 static const struct v4l2_subdev_core_ops m10mo_core_ops = {
@@ -1269,6 +2972,7 @@ static const struct v4l2_subdev_core_ops m10mo_core_ops = {
 	.s_ctrl = v4l2_subdev_s_ctrl,
 	.s_power = m10mo_s_power,
 	.init	= m10mo_fw_start,
+	.ioctl  = m10mo_ioctl,
 };
 
 static const struct v4l2_subdev_pad_ops m10mo_pad_ops = {
@@ -1327,7 +3031,8 @@ static int read_fw_version(struct m10mo_device *dev, char *buf)
 		goto leave;
 	}
 	__m10mo_s_power(&dev->sd, 1, true);
-	ret = m10mo_get_isp_fw_version_string(dev, buf, M10MO_MAX_FW_ID_STRING);
+	ret = m10mo_get_isp_fw_version_string(dev, buf, M10MO_MAX_FW_ID_STRING,
+			dev->fw_addr_id);
 	__m10mo_s_power(&dev->sd, 0, true);
 leave:
 	mutex_unlock(&dev->input_lock);
@@ -1370,7 +3075,7 @@ leave:
 static ssize_t m10mo_flash_rom_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "flash\n");
+	return scnprintf(buf, PAGE_SIZE, "flash\n");
 }
 
 static ssize_t m10mo_flash_rom_store(struct device *dev,
@@ -1392,7 +3097,8 @@ static ssize_t m10mo_flash_spi_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct m10mo_device *m10mo_dev = dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", m10mo_get_spi_state(m10mo_dev));
+	return scnprintf(buf, PAGE_SIZE,
+			 "%d\n", m10mo_get_spi_state(m10mo_dev));
 }
 
 static ssize_t m10mo_flash_spi_store(struct device *dev,
@@ -1425,7 +3131,7 @@ static ssize_t m10mo_flash_checksum_show(struct device *dev,
 	if (ret)
 		return ret;
 
-	return sprintf(buf, "%04x\n", result);
+	return scnprintf(buf, PAGE_SIZE, "%04x\n", result);
 }
 static DEVICE_ATTR(isp_checksum, S_IRUGO, m10mo_flash_checksum_show, NULL);
 
@@ -1439,7 +3145,7 @@ static ssize_t m10mo_flash_version_show(struct device *dev,
 	if (ret)
 		return ret;
 
-	return sprintf(buf, "%s\n", buf);
+	return scnprintf(buf, PAGE_SIZE, "%s\n", buf);
 }
 static DEVICE_ATTR(isp_version, S_IRUGO, m10mo_flash_version_show, NULL);
 
@@ -1448,16 +3154,171 @@ static ssize_t m10mo_flash_dump_show(struct device *dev,
 {
 	struct m10mo_device *m10_dev = dev_get_drvdata(dev);
 	dump_fw(m10_dev);
-	return sprintf(buf, "done\n");
+	return scnprintf(buf, PAGE_SIZE, "done\n");
 }
 static DEVICE_ATTR(isp_fw_dump, S_IRUGO, m10mo_flash_dump_show, NULL);
 
+static int m10mo_ispd1(struct m10mo_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct v4l2_subdev *sd = &dev->sd;
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+
+	dev_info(&client->dev, "ispd1 start\n");
+	ret = m10mo_dump_string_log1(sd);
+	if (ret < 0)
+		dev_err(&client->dev, "isp log 1 error\n");
+
+	dev_info(&client->dev, "ispd1 finished\n");
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int m10mo_ispd2(struct m10mo_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct v4l2_subdev *sd = &dev->sd;
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+
+	dev_info(&client->dev, "ispd2 start\n");
+
+	ret = m10mo_dump_string_log2_1(sd);
+	if (ret != 0)
+		dev_err(&client->dev, "m10mo_dump_string_log2_1 error\n");
+
+	dev_info(&client->dev, "log2_1 finished\n");
+
+	ret = m10mo_dump_string_log2_2(sd);
+	if (ret != 0)
+		dev_err(&client->dev, "m10mo_dump_string_log2_2 error\n");
+
+	dev_info(&client->dev, "ispd2_2 finish\n");
+
+	ret = m10mo_dump_string_log2_3(sd);
+	if (ret != 0)
+		dev_err(&client->dev, "m10mo_dump_string_log2_3 error\n");
+
+	dev_info(&client->dev, "ispd2_3 finish\n");
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int m10mo_ispd3(struct m10mo_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct v4l2_subdev *sd = &dev->sd;
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+
+	/**ISP RESET**/
+	ret = dev->pdata->common.gpio_ctrl(sd, 0);
+
+	msleep(10);
+
+	/**ISP RESET**/
+	ret = dev->pdata->common.gpio_ctrl(sd, 1);
+
+	msleep(50);
+
+	dev_info(&client->dev, "ispd3 start\n");
+
+	ret = m10mo_dump_string_log2_1(sd);
+	if (ret != 0)
+		dev_err(&client->dev, "m10mo_dump_string_log2_1 error\n");
+
+	dev_info(&client->dev, "log2_1 finished\n");
+
+	ret = m10mo_dump_string_log2_2(sd);
+	if (ret != 0)
+		dev_err(&client->dev, "m10mo_dump_string_log2_2 error\n");
+
+	dev_info(&client->dev, "ispd2_2 finish\n");
+
+	ret = m10mo_dump_string_log2_3(sd);
+	if (ret != 0)
+		dev_err(&client->dev, "m10mo_dump_string_log2_3 error\n");
+
+	dev_info(&client->dev, "ispd2_3 finish\n");
+
+	dev_info(&client->dev, "ispd3 finished\n");
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int m10mo_ispd4(struct m10mo_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	struct v4l2_subdev *sd = &dev->sd;
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+
+	dev_info(&client->dev, "ispd4 start\n");
+	ret = m10mo_dump_string_log3(sd);
+	if (ret < 0)
+		dev_err(&client->dev, "isp log 4 error\n");
+
+	dev_info(&client->dev, "ispd4 finished\n");
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+void m10mo_dump_log(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *m10mo_dev = to_m10mo_sensor(sd);
+
+	/*
+	 * dbglvl: bit0 to dump m10mo_ispd1
+	 * dbglvl: bit1 to dump m10mo_ispd2
+	 * dbglvl: bit2 to dump m10mo_ispd4
+	 * Debug log 3 is most important, so dump first
+	 */
+	if (dbglvl & 4)
+		m10mo_ispd4(m10mo_dev);
+
+	if (dbglvl & 2)
+		m10mo_ispd2(m10mo_dev);
+
+	if (dbglvl & 1)
+		m10mo_ispd1(m10mo_dev);
+}
+
+static ssize_t m10mo_isp_log_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t len)
+{
+	struct m10mo_device *m10mo_dev = dev_get_drvdata(dev);
+
+	if (!strncmp(buf, "1", 1))
+		m10mo_ispd1(m10mo_dev);
+	else if (!strncmp(buf, "4", 1))
+		m10mo_ispd4(m10mo_dev);
+	else if (!strncmp(buf, "2", 1))
+		m10mo_ispd2(m10mo_dev);
+	else if (!strncmp(buf, "3", 1))
+		m10mo_ispd3(m10mo_dev);
+	else
+		m10mo_ispd4(m10mo_dev);
+
+	return len;
+}
+
+static DEVICE_ATTR(isp_log, S_IRUGO | S_IWUSR, NULL, m10mo_isp_log_store);
+
 static struct attribute *sysfs_attrs_ctrl[] = {
 	&dev_attr_isp_flashfw.attr,
 	&dev_attr_isp_checksum.attr,
 	&dev_attr_isp_fw_dump.attr,
 	&dev_attr_isp_spi.attr,
 	&dev_attr_isp_version.attr,
+	&dev_attr_isp_log.attr,
 	NULL
 };
 
@@ -1516,6 +3377,10 @@ static int m10mo_probe(struct i2c_client *client,
 
 	dev->mode = M10MO_POWERED_OFF;
 	dev->requested_mode = M10MO_NO_MODE_REQUEST;
+	dev->iso_sensitivity =  REG_AE_ISOMODE_ISO100;
+	dev->iso_mode = V4L2_ISO_SENSITIVITY_AUTO;
+	dev->monitor_params.af_mode = AF_NORMAL;
+	dev->monitor_params.exe_mode = AF_STOP;
 
 	mutex_init(&dev->input_lock);
 
@@ -1552,6 +3417,7 @@ static int m10mo_probe(struct i2c_client *client,
 	dev->sd.entity.ops = &m10mo_entity_ops;
 	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
 	dev->format.code = V4L2_MBUS_FMT_UYVY8_1X16;
+	dev->shot_mode = SHOT_MODE_AUTO;
 
 	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
 	if (ret)
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
index a41d18f..bef19cd 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
@@ -38,12 +38,15 @@
 #define M10MO_NAME 			"m10mo"
 #define M10MO_ADDR   			0x1f
 #define M10MO_I2C_RETRY			5
-#define M10MO_MIPI_FREQ			(963000000/2)
+#define M10MO_MIPI_FREQ_0			(963000000/2)
+#define M10MO_MIPI_FREQ_1			(980700000/2)
 #define M10MO_INIT_TIMEOUT		500
 #define M10MO_BOOT_TIMEOUT		50
+#define POLL_NUM			20
 
-#define M10MO_MIN_EV -3
-#define M10MO_MAX_EV  3
+#define M10MO_MIN_EV -2000
+#define M10MO_MAX_EV  3000
+#define M10MO_EV_STEP 500
 #define M10MO_FLICKER_AUTO 		0x00
 #define M10MO_FLICKER_50HZ 		0x01
 #define M10MO_FLICKER_60HZ 		0x02
@@ -52,9 +55,46 @@
 #define M10MO_METERING_SPOT		0x01
 #define M10MO_METERING_AVERAGE		0x02
 
+/* TODO These values for focal length, f-number are taken from
+ * imx135 13MP. This can be changed when we get the proper values
+ * for m10mo
+ */
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+
+#define M10MO_FOCAL_LENGTH_DEFAULT	0x1710064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+
+#define M10MO_F_NUMBER_DEFAULT 		0x16000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+
+#define M10MO_F_NUMBER_RANGE 		0x160a160a
+#define M10MO_FOCAL_LENGTH_NUM		369
+#define M10MO_FOCAL_LENGTH_DEM		100
+#define M10MO_F_NUMBER_DEFAULT_NUM	22
+#define M10MO_F_NUMBER_DEM		10
+
 #define M10MO_INVALID_CHECKSUM          0xffff
 #define M10MO_VALID_CHECKSUM            0
 
+/* M10MO FW VERSION INFO ADDR */
+#define M10MO_FW_VERSION_INFO_ADDR_0	0x181EF080
+#define M10MO_FW_VERSION_INFO_ADDR_1	0x18000020
+
 /* M10MO I2C commands */
 #define M10MO_BYTE_READ			0x01
 #define M10MO_BYTE_WRITE		0x02
@@ -65,6 +105,26 @@
 #define M10MO_MEMORY_READ_32BIT		0x07
 #define M10MO_MEMORY_WRITE_32BIT	0x08
 
+#define CAPTURE_FORMAT_YUV422		0x00
+#define CAPTURE_FORMAT_JPEG8		0x01
+
+/* TODO: Fix this */
+/* 4128*3096*2 + X extra bytes. Rounded to height divisible by 32 -> 25624576 */
+#define M10MO_MAX_YUV422_SIZE		25624576
+/* Max RAW size 26000000 + 8*2048 + 1048 (to algin to 32 bytes) */
+#define M10MO_MAX_RAW_SIZE		26017792
+
+#define M10MO_GET_CLOCK_RATE_MODE(arg)	((arg >> M10MO_CLOCK_RATE_MODE_OFFSET) & M10MO_MASK)
+#define M10MO_GET_MIPI_FREQ_MODE(arg)	((arg >> M10MO_MIPI_FREQ_MODE_OFFSET) & M10MO_MASK)
+#define M10MO_GET_FOCUS_MODE(arg)		((arg >> M10MO_AF_MODE_OFFSET) & M10MO_MASK)
+#define M10MO_GET_RESOLUTION_MODE(arg)	((arg >> M10MO_RESOLUTION_MODE_OFFSET) & M10MO_MASK)
+#define M10MO_SHOT_MODES_SUPPORTED(arg)	(arg & M10MO_SHOT_MODE_SUPPORT)
+#define M10MO_GET_MIPI_PACKET_SIZE_IDX(arg) ((arg >> M10MO_MIPI_PACKET_SIZE_OFFSET) & M10MO_MASK)
+
+#define M10MO_METADATA_WIDTH	2048
+#define M10MO_METADATA_HEIGHT	4
+#define M10MO_METADATA_FORMAT	ATOMISP_INPUT_FORMAT_EMBEDDED
+
 struct m10mo_spi {
 	int spi_enabled;
 	struct spi_device *spi_device;
@@ -87,6 +147,34 @@ struct m10mo_resolution {
 	u32 width;
 	u32 height;
 	u32 command;
+	bool vdis;
+};
+
+struct m10mo_monitor_params {
+	u8 af_mode;
+	u8 exe_mode;
+	unsigned int af_touch_posx;
+	unsigned int af_touch_posy;
+	u8 flash_mode;
+	u8 torch;
+};
+
+/* Parameters dependent to the MIPI packet size (FW specific) */
+struct m10mo_mipi_params {
+	u32 jpeg_width;
+	u32 jpeg_height;
+	u32 raw_width;
+	u32 raw_height;
+};
+
+struct m10mo_fw_ops {
+	int (*set_run_mode) (struct v4l2_subdev *sd);
+	int (*set_burst_mode) (struct v4l2_subdev *sd, unsigned int val);
+	int (*stream_off) (struct v4l2_subdev *sd);
+	int (*single_capture_process) (struct v4l2_subdev *sd);
+	int (*try_mbus_fmt) (struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt, bool update_fmt);
+	int (*set_mbus_fmt) (struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt);
+	int (*test_pattern) (struct v4l2_subdev *sd, u8 val);
 };
 
 struct m10mo_device {
@@ -96,13 +184,21 @@ struct m10mo_device {
 	struct m10mo_platform_data *pdata;
 	struct mutex input_lock; /* serialize sensor's ioctl */
 	struct m10mo_spi *spi;
+	struct m10mo_monitor_params monitor_params;
+	struct m10mo_mipi_params mipi_params;
 	u8 message_buffer[256]; /* Real buffer size TBD */
 	int res_type;
 	int power;
 	u8 fps;
 	u8 requested_mode;
 	u8 mode;
+	u8 capture_mode;
+	short iso_mode;
+	short iso_sensitivity;
+	u8 colorfx_cr;
+	u8 colorfx_cb;
 	int fmt_idx;
+	int capture_res_idx;
 	wait_queue_head_t irq_waitq;
 	unsigned int bad_fw:1;
 	unsigned int isp_ready:1;
@@ -111,11 +207,28 @@ struct m10mo_device {
 	struct v4l2_ctrl_handler ctrl_handler;
 	int run_mode;
 	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *zsl_capture;
+	struct v4l2_ctrl *colorfx;
+	const struct m10mo_fw_ops *fw_ops;
 	unsigned int num_lanes;
 	const struct m10mo_resolution *curr_res_table;
 	int entries_curr_table;
 	int ref_clock;
-	int fw_type;
+	unsigned int fw_type;
+	int fw_addr_id;
+	u8 shot_mode;
+};
+
+enum hdr_options{
+	STOP_HDR_MODE,
+	START_HDR_MODE,
+	RESUME_PREVIEW_IN_HDR_MODE
+};
+
+enum lls_options{
+	STOP_LLS_MODE,
+	START_LLS_MODE,
+	RESUME_PREVIEW_IN_LLS_MODE
 };
 
 #define to_m10mo_sensor(x) container_of(x, struct m10mo_device, sd)
@@ -129,18 +242,50 @@ int m10mo_readb(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val);
 int m10mo_readw(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val);
 int m10mo_readl(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val);
 int m10mo_setup_flash_controller(struct v4l2_subdev *sd);
+int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode);
+int m10mo_wait_mode_change(struct v4l2_subdev *sd, u8 mode, u32 timeout);
+int __m10mo_param_mode_set(struct v4l2_subdev *sd);
+int __m10mo_update_stream_info(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt);
+int __m10mo_try_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt, bool update_fmt);
+int __m10mo_set_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt);
+int m10mo_test_pattern_start(struct v4l2_subdev *sd);
+
+int get_resolution_index(const struct m10mo_resolution *res,
+			 int entries, int w, int h);
+int m10mo_set_zsl_raw_capture(struct v4l2_subdev *sd);
+
 
 void m10mo_register_spi_fw_flash_interface(struct m10mo_device *dev,
 					   struct m10mo_spi *m10mo_spi_dev);
 
 int m10mo_dump_fw(struct m10mo_device *m10mo_dev);
-int m10mo_get_isp_fw_version_string(struct m10mo_device *dev, char *buf, int len);
+int m10mo_get_fw_address_count(void);
+int m10mo_get_isp_fw_version_string(struct m10mo_device *dev, char *buf,
+		int len, int fw_address_id);
 int m10mo_fw_checksum(struct m10mo_device *dev, u16 *result);
 int m10mo_program_device(struct m10mo_device *m10mo_dev);
 
 int m10mo_get_spi_state(struct m10mo_device *m10mo_dev);
 int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 
+int m10mo_update_pll_setting(struct v4l2_subdev *sd);
+int m10mo_dump_string_log1(struct v4l2_subdev *sd);
+int m10mo_dump_string_log2_1(struct v4l2_subdev *sd);
+int m10mo_dump_string_log2_2(struct v4l2_subdev *sd);
+int m10mo_dump_string_log2_3(struct v4l2_subdev *sd);
+int m10mo_dump_string_log3(struct v4l2_subdev *sd);
+void m10mo_dump_log(struct v4l2_subdev *sd);
+int m10mo_single_capture_process(struct v4l2_subdev *sd);
+int m10mo_set_still_capture(struct v4l2_subdev *sd);
+int m10mo_set_panorama_monitor(struct v4l2_subdev *sd);
+int m10mo_set_zsl_monitor(struct v4l2_subdev *sd);
+int m10mo_set_burst_mode(struct v4l2_subdev *sd, unsigned int val);
+int m10mo_streamoff(struct v4l2_subdev *sd);
+int m10mo_test_pattern(struct v4l2_subdev *sd, u8 val);
+
+extern const struct m10mo_fw_ops fw_type1_5_ops;
+extern const struct m10mo_fw_ops fw_type2_ops;
+
 /* Below contents are based on the M10MO_categoryParameter-a1.xls */
 
 /* Category register */
@@ -153,6 +298,8 @@ int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 #define CATEGORY_LENS		0x0a	/* AF Control */
 #define CATEGORY_CAPTURE_PARAM	0x0b	/* Still Picture parameter */
 #define CATEGORY_CAPTURE_CTRL	0x0c  /* Still picture control */
+#define CATEGORY_LOGLEDFLASH	0x0d	/*Log Led Flash Category */
+#define CATEGORY_TEST		0x0d	/* Test category for FW_TYPE_2 */
 #define CATEGORY_FLASHROM	0x0f	/* FlashROM-Writer Mode only */
 
 /* Category 0_SYSTEM mode */
@@ -162,6 +309,7 @@ int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 #define SYSTEM_VER_HARDWARE	0x04
 #define SYSTEM_VER_PARAMETER	0x06
 #define SYSTEM_VER_AWB		0x08
+#define SYSTEM_MASTER_SENSOR	0x17
 
 #define SYSTEM_SYSMODE			0x0b
 /* SYSTEM mode status */
@@ -196,16 +344,100 @@ int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 #define PARAM_MIPI_OUT_LANE_NUM		0x3e
 #define REG_OUTPUT_MIPI_4LANE		0x04
 
+#define PARAM_VDIS			0x00
+#define SHOT_MODE			0x0e
+#define MPO_FORMAT_META			0x0e
+#define MONITOR_TYPE			0x6e
+#define MOVIE_MODE			0x3c
+
+#define MONITOR_PREVIEW		0
+#define MONITOR_BURST		1
+#define MONITOR_VIDEO		3
+
 /* Category 2_MONITOR mode */
 
 #define MONITOR_ZOOM		0x01
+#define ZOOM_POS_MIN		0x01
+#define ZOOM_POS_MAX		0x1f /* 31 */
 #define MONITOR_CFIXR		0x0a
 #define MONITOR_CFIXB		0x09
 #define MONITOR_COLOR_EFFECT	0x0b
 #define MONITOR_ZSL_MODE_STATUS	0x5f
 #define REG_NORMAL_MONITOR	0x00
 #define REG_ZSL_MONITOR 	0x01
-
+#define ZSL_MODE		0x6e
+#define ZSL_INTERVAL 		0x6f
+
+#define COLOR_EFFECT_NONE	0x00
+#define COLOR_EFFECT_ON		0x01
+#define COLOR_EFFECT_NEGATIVE	0x02
+#define COLOR_EFFECT_WARM	0x04
+#define COLOR_EFFECT_COLD	0x05
+#define COLOR_EFFECT_WASHED	0x06
+
+#define COLOR_CFIXB_SEPIA	0xd8
+#define COLOR_CFIXR_SEPIA	0x18
+#define COLOR_CFIXB_BW		0x00
+#define COLOR_CFIXR_BW		0x00
+#define COLOR_CFIXB_RED		0x00
+#define COLOR_CFIXR_RED		0x6b
+#define COLOR_CFIXB_GREEN	0xe0
+#define COLOR_CFIXR_GREEN	0xe0
+#define COLOR_CFIXB_BLUE	0x40
+#define COLOR_CFIXR_BLUE	0x00
+#define COLOR_CFIXB_PINK	0x20
+#define COLOR_CFIXR_PINK	0x40
+#define COLOR_CFIXB_YELLOW	0x80
+#define COLOR_CFIXR_YELLOW	0x00
+#define COLOR_CFIXB_PURPLE	0x50
+#define COLOR_CFIXR_PURPLE	0x20
+#define COLOR_CFIXB_ANTIQUE	0xd0
+#define COLOR_CFIXR_ANTIQUE	0x30
+
+/*  ZSL MODE */
+#define CAPTURE_MODE		0x00
+#define CAP_MODE_INFINITY_ZSL	0x0f
+#define CAP_MODE_PANORAMA	0x00
+
+/* In other type firmware movie mode is 0x00 */
+#define CAP_MODE_MOVIE		0x00
+
+#define ZSL_TRANSFER_NO 	0x16
+#define CAP_NV12_MODE		0x0a
+#define START_DUAL_STATUS	0x1f
+#define START_DUAL_CAPTURE 	0x05
+
+#define DUAL_CAPTURE_SINGLE_CAPTURE_START	0x01
+#define DUAL_CAPTURE_HDR_CAPTURE_START		0x01
+#define DUAL_CAPTURE_BURST_CAPTURE_START	0x04
+#define DUAL_CAPTURE_BURST_CAPTURE_STOP		0x05
+#define DUAL_CAPTURE_ZSL_CAPTURE_START		0x07
+#define DUAL_CAPTURE_LLS_CAPTURE_START		0x08
+
+#define DUAL_STATUS_IDLE			0x0
+#define DUAL_STATUS_CAPTURE			0x1
+#define DUAL_STATUS_AF_WORKING		0x2
+
+/* Output format selection between YUV422 and NV12/NV21 */
+#define OUTPUT_FMT_SELECT	0x05
+#define OUTPUT_FMT_SELECT_YUV422	0x00
+#define OUTPUT_FMT_SELECT_NV12NV21	0x01
+
+/* Choose between NV12 and NV21 */
+#define CHOOSE_NV12NV21_FMT		0x27
+#define CHOOSE_NV12NV21_FMT_NV12	0x00
+#define CHOOSE_NV12NV21_FMT_NV21	0x01
+
+/* Enable/Disable metadata in monitor mode */
+#define MON_METADATA_SUPPORT_CTRL	0x06
+#define MON_METADATA_SUPPORT_CTRL_EN	0x01
+#define MON_METADATA_SUPPORT_CTRL_DIS	0x00
+
+/* MPO format */
+#define MON_MPO_FMT_CTRL		0x07
+#define MON_MPO_FMT_NV21		0x02
+#define MON_MPO_FMT_YUV422		0x03
+#define MON_MPO_FMT_YUV420		0x06
 
 /* Category 3_Auto Exposure */
 
@@ -216,33 +448,39 @@ int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 #define REG_AE_OFF		0x00
 #define AE_TARGET		0x02
 #define AE_SPEED		0x03
+#define AE_ISOMODE		0x05
 #define AE_FLICKER		0x06
 #define AE_FLICKER_AUTO		0x07
 #define AE_EV_BIAS		0x09
 #define AE_AUTO_BRACKET_EV1	0x20
 #define AE_AUTO_BRACKET_EV2	0x21
 
+#define REG_AE_ISOMODE_AUTO	0x00
+#define REG_AE_ISOMODE_ISO100	0x01
+#define REG_AE_ISOMODE_ISO200	0x02
+#define REG_AE_ISOMODE_ISO400	0x03
+#define REG_AE_ISOMODE_ISO800	0x04
+#define REG_AE_ISOMODE_ISO1600	0x05
 
 
 /* Category 6_White Balance */
 
-#define AWB_LOCK		0x00
-#define REG_AWB_OFF		0x00
-#define REG_AWB_ON		0x01
-#define AWB_ADJUST_MODE 	0x01
 #define AWB_MODE		0x02
+
 #define REG_AWB_AUTO		0x01
-#define AWB_MANUAL		0x03
+#define REG_AWB_MANUAL		0x02
+
+#define AWB_PRESET		0x03
+
+#define REG_AWB_PROHIBITION	0x00
 #define REG_AWB_INCANDESCENT	0x01
-#define REG_AWB_FLUORESCENT_1	0x02
-#define REG_AWB_FLUORESCENT_2	0x03
+#define REG_AWB_FLUORESCENT_H	0x02
+#define REG_AWB_FLUORESCENT_L	0x03
 #define REG_AWB_DAYLIGHT	0x04
 #define REG_AWB_CLOUDY		0x05
 #define REG_AWB_SHADE		0x06
 #define REG_AWB_HORIZON		0x07
 #define REG_AWB_LEDLIGHT	0x09
-#define AWB_SPEED		0x04
-#define AWB_RANGE		0x05
 
 /* Category 7_EXIF */
 #define EXIF_INFO_EXPTIME_NU	0x00
@@ -263,20 +501,32 @@ int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 
 /* Category A_Lens Parameter */
 #define AF_MODE			0x01
-#define REG_AF_NORMAL		0x01
-#define REG_AF_MACRO		0x03
-#define REG_AF_POWEROFF		0x07
-
-#define AF_START		0x02
-#define REG_AF_STOP		0x00
-#define REG_AF_EXE_AUTO		0x01
-#define REG_AF_EXE_CAF		0x02
+#define AF_NORMAL		0x00
+#define AF_MACRO		0x01
+#define AF_TOUCH		0x02
+#define	AF_PREVIEW_CAF		0x03
+#define	AF_MOVIE_CAF		0x04
+#define	AF_FACE_CAF		0x05
+#define	AF_TOUCH_MACRO		0x06
+#define AF_TOUCH_CAF		0x07
+
+#define AF_EXECUTION		0x02
+#define AF_STOP			0x00
+#define AF_SEARCH		0x01
+#define AF_PAN_FOCUSING		0x02
+
+#define AF_RESULT			0x03
+#define CAF_STATUS_RESTART_CHECK	0x01
+#define CAF_STATUS_FOCUSING		0x02
+#define CAF_STATUS_SUCCESS		0x03
+#define CAF_STATUS_FAIL			0x04
+#define AF_STATUS_INVALID		0x10
+#define AF_STATUS_FOCUSING		0x20
+#define AF_STATUS_SUCCESS		0x30
+#define AF_STATUS_FAIL			0x40
+#define AF_TOUCH_POSX			0X30
+#define AF_TOUCH_POSY			0X32
 
-#define AF_RESULT		0x03
-#define REG_AF_FAIL		0x02
-#define REG_AF_SUCCESS		0x01
-#define REG_AF_IDLE		0x03
-#define REG_AF_BUSY		0x04
 
 /* Category B_CAPTURE Parameter */
 #define CAPP_YUVOUT_MAIN	0x00
@@ -298,6 +548,48 @@ int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 #define CAPC_TRANSFER_START	0x09
 #define REG_CAP_START_MAIN	0x01
 
+/* Category D LED Flash Control */
+#define FLASH_MODE              0xB6
+#define FLASH_MODE_OFF          0x00
+#define FLASH_MODE_ON           0X01
+#define FLASH_MODE_AUTO         0X02
+#define LED_TORCH               0x29
+#define LED_TORCH_OFF           0x00
+#define LED_TORCH_ON            0x01
+#define LOG_ADD_SHOW		0x06
+#define LOG_ADD_SHOW_INIT_VALUE	0x00
+#define LOG_STR_LEN		0x07
+#define LOG_STR_ADD3		0x08
+#define LOG_STR_ADD2		0x09
+#define LOG_STR_ADD1		0x0A
+#define LOG_STR_ADD0		0x0B
+#define LOG_SEL1		0x0C
+#define LOG_SEL0		0x0D
+#define LOG_ACT		0x0E
+#define LOG_ACT_ENABLE		0x01
+#define LOG_ACT_DISABLE	0x02
+#define LOG_ACT_OUTPUT_STR	0x03
+#define LOG_ACT_CLEAR		0x04
+#define LOG_MODE		0x0F
+#define LOG_STANDARD_MODE	0x00
+#define LOG_ANALYZE_MODE0	0x01
+#define LOG_ANALYZE_MODE1	0x02
+#define LOG_ANALYZE_MODE2	0x03
+#define LOG_TRACE_MODE		0x04
+#define LOG_DATA_LEN1		0x14
+#define LOG_DATA_LEN0		0x15
+
+#define I2C_MEM_READ_SIZE	128
+#define MAX_LOG_STR_LEN	0xFF
+#define MIN_LOG_STR_LEN	0x00
+#define MAX_LOG_STR_LEN_LOG2	0xFFFF
+#define MIN_LOG_STR_LEN_LOG2	0x0000
+#define MAX_MEM_DUMP_NUM	10000
+#define MAX_MEM_DUMP_NUM_LOG3	20000
+
+/* Category D Test */
+#define TEST_PATTERN_SENSOR	0x1d
+
 /* Category F_Flash */
 #define REG_FLASH_ADD           0x00
 #define REG_FLASH_BYTE          0x04
@@ -316,6 +608,29 @@ int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
 #define REG_FW_READ             0x57
 #define REG_CHECK_SUM_SIZE      0x5c
 
+/* Shot modes (cat 0x01 byte 0x0e) */
+#define SHOT_MODE_AUTO			0x01
+#define SHOT_MODE_BEAUTY_FACE		0X02
+#define SHOT_MODE_BEST_PHOTO		0X03
+#define SHOT_MODE_DRAMA			0X04
+#define SHOT_MODE_BEST_FACE		0X05
+#define SHOT_MODE_ERASER		0X06
+#define SHOT_MODE_PANORAMA		0x07
+#define SHOT_MODE_RICH_TONE_HDR		0X09
+#define SHOT_MODE_NIGHT			0X0A
+#define SHOT_MODE_SOUND_SHOT            0X0B
+#define SHOT_MODE_ANIMATED_PHOTO	0X0F
+#define SHOT_MODE_SPORTS		0X11
+
+/* Still capture modes for NV12 */
+#define REG_CAP_NV12_MODE	0x0a
+#define NORMAL_CAPTURE		0x00
+#define HDR_CAPTURE		0x02
+#define LLS_CAPTURE		0x04
+#define RAW_CAPTURE		0x10
+
+#define PREVIEW_IN_NV12_MODE	0x02
+
 #define REG_RAM_START_SRAM      0x01
 #define REG_RAM_START_SDRAM     0x02
 
@@ -342,16 +657,70 @@ enum M10MO_MODES {
 	M10MO_POWERING_ON,
 	M10MO_FLASH_WRITE_MODE,
 	M10MO_PARAM_SETTING_MODE,
+	M10MO_PARAMETER_MODE,
 	M10MO_MONITOR_MODE,
-	M10MO_SINGLE_CAPTURE_MODE
+	M10MO_MONITOR_MODE_ZSL,
+	M10MO_MONITOR_MODE_PANORAMA,
+	M10MO_SINGLE_CAPTURE_MODE,
+	M10MO_BURST_CAPTURE_MODE,
+	M10MO_MONITOR_MODE_HIGH_SPEED
+};
+
+/* Internal modes of M10MO */
+enum M10MO_CAPTURE_MODES {
+	M10MO_CAPTURE_MODE_ZSL_NORMAL = 0,
+	M10MO_CAPTURE_MODE_ZSL_HDR,
+	M10MO_CAPTURE_MODE_ZSL_LLS,
+	M10MO_CAPTURE_MODE_ZSL_BURST,
+	M10MO_CAPTURE_MODE_ZSL_RAW
 };
 
 #define M10MO_MODE_PREVIEW_INDEX	0
 #define M10MO_MODE_CAPTURE_INDEX	1
 #define M10MO_MODE_VIDEO_INDEX		2
+
+#define M10MO_ZSL_JPEG_VIRTUAL_CHANNEL	1
+#define M10MO_ZSL_NV12_VIRTUAL_CHANNEL	0
+
+#define M10MO_NORMAL_FPS		30
+#define M10MO_HIGH_SPEED_FPS	60
+/* FIXME It should be in tables */
+#define MON_SIZE_FHD_60FPS		0x2b
+
 extern const struct m10mo_resolution *resolutions[][3];
 extern const ssize_t resolutions_sizes[][3];
 
+struct M10MO_AF_Parameters {
+	u8 af_mode;
+	u8 af_normal;
+	u8 af_macro;
+	u8 af_touch;
+	u8 af_preview_caf;
+	u8 af_movie_caf;
+	u8 af_face_caf;
+	u8 af_touch_macro;
+	u8 af_touch_caf;
+
+	u8 af_execution;
+	u8 af_stop;
+	u8 af_search;
+	u8 af_pan_focusing;
+
+	u8 af_result;
+	u8 caf_status_restart_check;
+	u8 caf_status_focusing;
+	u8 caf_status_success;
+	u8 caf_status_fail;
+	u8 af_status_invalid;
+	u8 af_status_focusing;
+	u8 af_status_success;
+	u8 af_status_fail;
+
+	u8 af_touch_posx;
+	u8 af_touch_posy;
+};
+extern const struct M10MO_AF_Parameters m10m0_af_parameters[];
+
 #endif	/* M10MO_H */
 
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
index 161017c..9d64ae7 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
@@ -36,8 +36,17 @@
  * Currently the FW image and dump paths are hardcoded here.
  * TBD: flexible interface for defining proper path as needed
  */
-#define M10MO_FW_DUMP_PATH "/data/M10MO_dump.bin"
-#define M10MO_FW_NAME "M10MO_fw.bin"
+#define M10MO_FW_LOG1_NAME      "/data/M10MO_log1"
+#define M10MO_FW_LOG2_1_NAME    "/data/M10MO_log2_1"
+#define M10MO_FW_LOG2_2_NAME    "/data/M10MO_log2_2"
+#define M10MO_FW_LOG2_3_NAME    "/data/M10MO_log2_3"
+#define M10MO_FW_LOG3_NAME      "/data/M10MO_log3"
+
+#define M10MO_FW_LOG_SUFFIX     ".bin"
+#define M10MO_FW_LOG_MAX_NAME_LEN (128)
+
+#define M10MO_FW_DUMP_PATH      "/data/M10MO_dump.bin"
+#define M10MO_FW_NAME           "M10MO_fw.bin"
 
 #define SRAM_BUFFER_ADDRESS 0x01100000
 #define SDRAM_BUFFER_ADDRESS 0x20000000
@@ -104,6 +113,11 @@ static const u8 buf_port_settings2_m10mo[] = {
 		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 		 };
 
+static const u32 m10mo_fw_address[] = {
+	M10MO_FW_VERSION_INFO_ADDR_0,
+	M10MO_FW_VERSION_INFO_ADDR_1,
+};
+
 static int m10mo_set_flash_address(struct v4l2_subdev *sd, u32 addr)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -144,12 +158,24 @@ static int m10mo_wait_operation_complete(struct v4l2_subdev *sd, u8 reg,
 
 	if (!timeout) {
 		dev_err(&client->dev,
-			"timeout while waiting for chip op to finish");
+			"timeout while waiting for chip op to finish\n");
 		return -ETIME;
 	}
 	return 0;
 }
 
+int m10mo_update_pll_setting(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *m10mo_dev = to_m10mo_sensor(sd);
+	int err;
+
+	err = m10mo_writel(sd, CATEGORY_FLASHROM,
+			   REG_PLL_VALUES,
+			   m10mo_get_pll_cfg(m10mo_dev->ref_clock));
+
+	return err;
+}
+
 static int m10mo_to_fw_access_mode(struct m10mo_device *m10mo_dev)
 {
 	struct v4l2_subdev *sd = &m10mo_dev->sd;
@@ -324,7 +350,530 @@ out_file:
 	return err;
 }
 
-int m10mo_get_isp_fw_version_string(struct m10mo_device *dev, char *buf, int len)
+static void m10mo_gen_log_name(char *name, char *prefix)
+{
+	static long long time;
+
+	time = ktime_to_ms(ktime_get());
+	snprintf(name, M10MO_FW_LOG_MAX_NAME_LEN, "%s_%lld%s", prefix, time, M10MO_FW_LOG_SUFFIX);
+}
+
+int m10mo_dump_string_log3(struct v4l2_subdev *sd)
+{
+	u32 addr;
+	mm_segment_t old_fs;
+	struct file *fp;
+	u32 len = MAX_LOG_STR_LEN;
+	u32 ret = 0;
+	u32 count = 0;
+	u32 count_len = 0;
+	u32 ptr = 0;
+	char *buf = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	char filename[M10MO_FW_LOG_MAX_NAME_LEN] = {0};
+
+	m10mo_gen_log_name(filename, M10MO_FW_LOG3_NAME);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	fp = filp_open(filename,
+			O_WRONLY|O_CREAT|O_TRUNC, S_IRUGO|S_IWUGO|S_IXUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&client->dev,
+				"failed to open %s, err %ld\n",
+				M10MO_FW_DUMP_PATH, PTR_ERR(fp));
+		ret = -ENOENT;
+		goto out_file;
+	}
+
+	buf = kmalloc(DUMP_BLOCK_SIZE, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto out_close;
+	}
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_TRACE_MODE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_DISABLE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	while (count++ < MAX_MEM_DUMP_NUM_LOG3) {
+		ret = m10mo_writew(sd, CATEGORY_LOGLEDFLASH, LOG_SEL1, ptr);
+		if (ret < 0)
+			goto out_mem_free;
+
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		if (ret < 0)
+			goto out_mem_free;
+
+		do {
+			ret = m10mo_readb(sd, CATEGORY_LOGLEDFLASH, LOG_STR_LEN, &len);
+			if (ret < 0)
+				goto out_mem_free;
+			msleep(10);
+			count_len++;
+		} while ((len == MAX_LOG_STR_LEN) && (count_len < 10));
+
+		if (len == MIN_LOG_STR_LEN) {
+			goto out_mem_free;
+		} else {
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			if (ret < 0)
+				goto out_mem_free;
+
+			ret = m10mo_memory_read(sd, len, addr, buf);
+			if (ret < 0)
+				goto out_mem_free;
+			/* Do not add buf[len] = '\n'; */
+			vfs_write(fp, buf, len, &fp->f_pos);
+		}
+		len = MAX_LOG_STR_LEN;
+		ptr = ptr + 1;
+	}
+
+out_mem_free:
+	kfree(buf);
+out_close:
+	if (!IS_ERR(fp))
+		filp_close(fp, current->files);
+out_file:
+	set_fs(old_fs);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s, dump log error\n", __func__);
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_DISABLE);
+	if (ret < 0)
+		dev_err(&client->dev, "%s, m10mo_writeb error\n", __func__);
+
+	return ret;
+}
+
+/* Not verified */
+int m10mo_dump_string_log2_3(struct v4l2_subdev *sd)
+{
+	u32 addr, i;
+	mm_segment_t old_fs;
+	struct file *fp;
+	u32 len = MAX_LOG_STR_LEN_LOG2;
+	u32 ret = 0;
+	u32 count = 0;
+	u32 unit_count = 0;
+	u32 ptr = 0;
+	char *buf = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	char filename[M10MO_FW_LOG_MAX_NAME_LEN] = {0};
+
+	m10mo_gen_log_name(filename, M10MO_FW_LOG2_3_NAME);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	fp = filp_open(filename,
+			O_WRONLY|O_CREAT|O_TRUNC, S_IRUGO|S_IWUGO|S_IXUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&client->dev,
+				"failed to open %s, err %ld\n",
+				M10MO_FW_DUMP_PATH, PTR_ERR(fp));
+		ret = -ENOENT;
+		goto out_file;
+	}
+
+	buf = kmalloc(DUMP_BLOCK_SIZE, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto out_close;
+	}
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_ANALYZE_MODE2);
+	if (ret < 0)
+		goto out_mem_free;
+
+	while (count++ < MAX_MEM_DUMP_NUM) {
+		ret = m10mo_writew(sd, CATEGORY_LOGLEDFLASH, LOG_SEL1, ptr);
+		if (ret < 0)
+			goto out_mem_free;
+
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		if (ret < 0)
+			goto out_mem_free;
+
+		do {
+			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH, LOG_DATA_LEN1, &len);
+			if (ret < 0)
+				goto out_mem_free;
+		} while (len == MAX_LOG_STR_LEN_LOG2);
+
+		if (len == MIN_LOG_STR_LEN_LOG2) {
+			goto out_mem_free;
+		} else {
+
+			if (len > MAX_LOG_STR_LEN_LOG2)
+				len = MAX_LOG_STR_LEN_LOG2;
+
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			if (ret < 0)
+				goto out_mem_free;
+
+			unit_count =  len / I2C_MEM_READ_SIZE;
+			for (i = 0; i <= unit_count; i += I2C_MEM_READ_SIZE) {
+				if ((len - i) <= I2C_MEM_READ_SIZE) {
+					ret = m10mo_memory_read(sd, len - i, addr + i, buf);
+					if (ret < 0)
+						goto out_mem_free;
+
+					vfs_write(fp, buf, len - i, &fp->f_pos);
+					break;
+				} else {
+					ret = m10mo_memory_read(sd, I2C_MEM_READ_SIZE, addr + i, buf);
+					if (ret < 0)
+						goto out_mem_free;
+
+					vfs_write(fp, buf, I2C_MEM_READ_SIZE, &fp->f_pos);
+				}
+			}
+		}
+		len = MAX_LOG_STR_LEN_LOG2;
+		ptr = ptr + 1;
+	}
+
+out_mem_free:
+	kfree(buf);
+out_close:
+	if (!IS_ERR(fp))
+		filp_close(fp, current->files);
+out_file:
+	set_fs(old_fs);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s, dump log error\n", __func__);
+	return ret;
+}
+
+/* Not verified */
+int m10mo_dump_string_log2_2(struct v4l2_subdev *sd)
+{
+	u32 addr, i;
+	mm_segment_t old_fs;
+	struct file *fp;
+	u32 len = MAX_LOG_STR_LEN_LOG2;
+	u32 ret = 0;
+	u32 count = 0;
+	u32 unit_count = 0;
+	u32 ptr = 0;
+	char *buf = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	char filename[M10MO_FW_LOG_MAX_NAME_LEN] = {0};
+
+	m10mo_gen_log_name(filename, M10MO_FW_LOG2_2_NAME);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	fp = filp_open(filename,
+			O_WRONLY|O_CREAT|O_TRUNC, S_IRUGO|S_IWUGO|S_IXUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&client->dev,
+				"failed to open %s, err %ld\n",
+				M10MO_FW_DUMP_PATH, PTR_ERR(fp));
+		ret = -ENOENT;
+		goto out_file;
+	}
+
+	buf = kmalloc(DUMP_BLOCK_SIZE, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto out_close;
+	}
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_ANALYZE_MODE1);
+	if (ret < 0)
+		goto out_mem_free;
+
+	while (count++ < MAX_MEM_DUMP_NUM) {
+		ret = m10mo_writew(sd, CATEGORY_LOGLEDFLASH, LOG_SEL1, ptr);
+		if (ret < 0)
+			goto out_mem_free;
+
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		if (ret < 0)
+			goto out_mem_free;
+
+		do {
+			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH, LOG_DATA_LEN1, &len);
+			if (ret < 0)
+				goto out_mem_free;
+		} while (len == MAX_LOG_STR_LEN_LOG2);
+
+		if (len == MIN_LOG_STR_LEN_LOG2) {
+			goto out_mem_free;
+		} else {
+
+			if (len > MAX_LOG_STR_LEN_LOG2)
+				len = MAX_LOG_STR_LEN_LOG2;
+
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			if (ret < 0)
+				goto out_mem_free;
+
+			unit_count =  len / I2C_MEM_READ_SIZE;
+			for (i = 0; i <= unit_count; i += I2C_MEM_READ_SIZE) {
+				if ((len - i) <= I2C_MEM_READ_SIZE) {
+					ret = m10mo_memory_read(sd, len - i, addr + i, buf);
+					if (ret < 0)
+						goto out_mem_free;
+
+					vfs_write(fp, buf, len - i, &fp->f_pos);
+					break;
+				} else {
+					ret = m10mo_memory_read(sd, I2C_MEM_READ_SIZE, addr + i, buf);
+					if (ret < 0)
+						goto out_mem_free;
+
+					vfs_write(fp, buf, I2C_MEM_READ_SIZE, &fp->f_pos);
+				}
+			}
+		}
+		len = MAX_LOG_STR_LEN_LOG2;
+		ptr = ptr + 1;
+	}
+
+out_mem_free:
+	kfree(buf);
+out_close:
+	if (!IS_ERR(fp))
+		filp_close(fp, current->files);
+out_file:
+	set_fs(old_fs);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s, dump log error\n", __func__);
+	return ret;
+}
+
+int m10mo_dump_string_log2_1(struct v4l2_subdev *sd)
+{
+	u32 addr, i;
+	mm_segment_t old_fs;
+	struct file *fp;
+	u32 len = MAX_LOG_STR_LEN_LOG2;
+	u32 ret = 0;
+	u32 count = 0;
+	u32 unit_count = 0;
+	u32 ptr = 0;
+	char *buf = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	char filename[M10MO_FW_LOG_MAX_NAME_LEN] = {0};
+
+	m10mo_gen_log_name(filename, M10MO_FW_LOG2_1_NAME);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	fp = filp_open(filename,
+			O_WRONLY|O_CREAT|O_TRUNC, S_IRUGO|S_IWUGO|S_IXUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&client->dev,
+				"failed to open %s, err %ld\n",
+				M10MO_FW_DUMP_PATH, PTR_ERR(fp));
+		ret = -ENOENT;
+		goto out_file;
+	}
+
+	buf = kmalloc(DUMP_BLOCK_SIZE, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto out_close;
+	}
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_ANALYZE_MODE0);
+	if (ret < 0)
+		goto out_mem_free;
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_DISABLE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	while (count++ < MAX_MEM_DUMP_NUM) {
+		ret = m10mo_writew(sd, CATEGORY_LOGLEDFLASH, LOG_SEL1, ptr);
+		if (ret < 0)
+			goto out_mem_free;
+
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		if (ret < 0)
+			goto out_mem_free;
+
+		do {
+			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH, LOG_DATA_LEN1, &len);
+			if (ret < 0)
+				goto out_mem_free;
+		} while (len == MAX_LOG_STR_LEN_LOG2);
+
+		if (len == MIN_LOG_STR_LEN_LOG2) {
+				goto out_mem_free;
+		} else {
+
+			if (len > MAX_LOG_STR_LEN_LOG2)
+				len = MAX_LOG_STR_LEN_LOG2;
+
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			if (ret < 0)
+				goto out_mem_free;
+
+			unit_count =  len / I2C_MEM_READ_SIZE;
+			for (i = 0; i <= unit_count; i += I2C_MEM_READ_SIZE) {
+				if ((len - i) <= I2C_MEM_READ_SIZE) {
+					ret = m10mo_memory_read(sd, len - i, addr + i, buf);
+					if (ret < 0)
+						goto out_mem_free;
+
+					vfs_write(fp, buf, len - i, &fp->f_pos);
+					break;
+				} else {
+					ret = m10mo_memory_read(sd, I2C_MEM_READ_SIZE, addr + i, buf);
+					if (ret < 0)
+						goto out_mem_free;
+
+					vfs_write(fp, buf, I2C_MEM_READ_SIZE, &fp->f_pos);
+				}
+			}
+		}
+		len = MAX_LOG_STR_LEN_LOG2;
+		ptr = ptr + 1;
+	}
+
+out_mem_free:
+	kfree(buf);
+out_close:
+	if (!IS_ERR(fp))
+		filp_close(fp, current->files);
+out_file:
+	set_fs(old_fs);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s, dump log error\n", __func__);
+	return ret;
+}
+
+int m10mo_dump_string_log1(struct v4l2_subdev *sd)
+{
+	u32 addr;
+	mm_segment_t old_fs;
+	struct file *fp;
+	u32 len = MAX_LOG_STR_LEN;
+	u32 ret = 0;
+	u32 count = 0;
+	u32 count_len = 0;
+	u32 ptr = 0;
+	char *buf = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	char filename[M10MO_FW_LOG_MAX_NAME_LEN] = {0};
+
+	m10mo_gen_log_name(filename, M10MO_FW_LOG1_NAME);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	fp = filp_open(filename,
+			O_WRONLY|O_CREAT|O_TRUNC, S_IRUGO|S_IWUGO|S_IXUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&client->dev,
+				"failed to open %s, err %ld\n",
+				M10MO_FW_DUMP_PATH, PTR_ERR(fp));
+		ret = -ENOENT;
+		goto out_file;
+	}
+
+	buf = kmalloc(DUMP_BLOCK_SIZE, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		ret = -ENOMEM;
+		goto out_close;
+	}
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_STANDARD_MODE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_DISABLE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
+	if (ret < 0)
+		goto out_mem_free;
+
+	while (count++ < MAX_MEM_DUMP_NUM) {
+		ret = m10mo_writew(sd, CATEGORY_LOGLEDFLASH, LOG_SEL1, ptr);
+		if (ret < 0)
+			goto out_mem_free;
+
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		if (ret < 0)
+			goto out_mem_free;
+
+		do {
+			ret = m10mo_readb(sd, CATEGORY_LOGLEDFLASH, LOG_STR_LEN, &len);
+			if (ret < 0)
+				goto out_mem_free;
+			msleep(10);
+			count_len++;
+		} while ((len == MAX_LOG_STR_LEN) && (count_len < 10));
+
+		if (len == MIN_LOG_STR_LEN) {
+				goto out_mem_free;
+		} else {
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			if (ret < 0)
+				goto out_mem_free;
+
+				ret = m10mo_memory_read(sd, len, addr, buf);
+				if (ret < 0)
+					goto out_mem_free;
+
+				buf[len] = '\n';
+				vfs_write(fp, buf, len + 1, &fp->f_pos);
+		}
+		len = MAX_LOG_STR_LEN;
+		ptr = ptr + 1;
+	}
+
+out_mem_free:
+	kfree(buf);
+out_close:
+	if (!IS_ERR(fp))
+		filp_close(fp, current->files);
+out_file:
+	set_fs(old_fs);
+
+	if (ret < 0)
+		dev_err(&client->dev, "%s, dump log error\n", __func__);
+
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_DISABLE);
+	if (ret < 0)
+		dev_err(&client->dev, "%s, m10mo_writeb error\n", __func__);
+
+	return ret;
+}
+
+int m10mo_get_fw_address_count(void)
+{
+	return ARRAY_SIZE(m10mo_fw_address);
+}
+
+int m10mo_get_isp_fw_version_string(struct m10mo_device *dev,
+		char *buf, int len, int fw_address_id)
 {
 	int err;
 	struct v4l2_subdev *sd = &dev->sd;
@@ -343,8 +892,14 @@ int m10mo_get_isp_fw_version_string(struct m10mo_device *dev, char *buf, int len
 	msleep(10);
 
 	memset(buf, 0, len);
-	err = m10mo_memory_read(sd, len - 1, FW_VERSION_INFO_ADDR,
-				buf);
+	if ((fw_address_id < 0) ||
+		(fw_address_id >= ARRAY_SIZE(m10mo_fw_address))) {
+		dev_err(&client->dev, "Error FW address ID: %d\n",
+				fw_address_id);
+		fw_address_id = 0;
+	}
+	err = m10mo_memory_read(sd, len - 1,
+			m10mo_fw_address[fw_address_id], buf);
 	if (err)
 		dev_err(&client->dev, "version read failed\n");
 
@@ -523,7 +1078,7 @@ static int m10mo_sio_write(struct m10mo_device *m10mo_dev, u8 *buf)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 
 	if (!m10mo_dev->spi) {
-		dev_err(&client->dev, "No spi device available");
+		dev_err(&client->dev, "No spi device available\n");
 		return -ENODEV;
 	}
 
@@ -683,7 +1238,7 @@ int m10mo_program_device(struct m10mo_device *m10mo_dev)
 		}
 	}
 
-	dev_info(&client->dev, "Flashing done");
+	dev_info(&client->dev, "Flashing done\n");
 	msleep(50);
 
 	ret = 0;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type1_5.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type1_5.c
new file mode 100644
index 0000000..bdb37d3
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type1_5.c
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Partially based on m-5mols kernel driver,
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ *
+ * Partially based on jc_v4l2 kernel driver from http://opensource.samsung.com
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/atomisp_platform.h>
+#include <media/m10mo_atomisp.h>
+#include <linux/module.h>
+#include "m10mo.h"
+
+static int m10mo_set_high_speed(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	dev_dbg(&client->dev, "%s: enter\n", __func__);
+
+	if (dev->mode != M10MO_PARAM_SETTING_MODE &&
+		dev->mode != M10MO_PARAMETER_MODE) {
+		/*
+		 * We should switch to param mode first and
+		 * reset all the parameters.
+		 */
+		ret = __m10mo_param_mode_set(sd);
+		if (ret)
+			goto out;
+	}
+
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, CAPTURE_MODE,
+				CAP_MODE_MOVIE);
+	if (ret)
+		goto out;
+
+	/* 1080P@60FPS */
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, PARAM_MON_SIZE,
+			MON_SIZE_FHD_60FPS);
+	if (ret)
+		goto out;
+	/* NO meta data */
+	ret = m10mo_writeb(sd, CATEGORY_PARAM,
+			MON_METADATA_SUPPORT_CTRL,
+			MON_METADATA_SUPPORT_CTRL_DIS);
+	if (ret)
+		goto out;
+	/* Select format NV12 */
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, CHOOSE_NV12NV21_FMT,
+			CHOOSE_NV12NV21_FMT_NV12);
+	if (ret)
+		goto out;
+	/* Enable interrupt signal */
+	ret = m10mo_writeb(sd, CATEGORY_SYSTEM,
+			SYSTEM_INT_ENABLE, 0x01);
+	if (ret)
+		goto out;
+	/* Go to Monitor mode and output YUV Data */
+	ret = m10mo_request_mode_change(sd,
+			M10MO_MONITOR_MODE_HIGH_SPEED);
+	if (ret)
+		goto out;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_MONITOR_MODE_HIGH_SPEED,
+			M10MO_INIT_TIMEOUT);
+	if (ret < 0)
+		goto out;
+
+	return 0;
+out:
+	dev_err(&client->dev, "%s:streaming failed %d\n", __func__, ret);
+	return ret;
+}
+
+int m10mo_set_run_mode_fw_type1_5(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	/*
+	 * Handle RAW capture mode separately irrespective of the run mode
+	 * being configured. Start the RAW capture right away.
+	 */
+	if (dev->capture_mode == M10MO_CAPTURE_MODE_ZSL_RAW) {
+		/*
+		 * As RAW capture is done from a command line tool, we are not
+		 * restarting the preview after the RAW capture. So it is ok
+		 * to reset the RAW capture mode here because the next RAW
+		 * capture has to start from the Set format onwards.
+		 */
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_NORMAL;
+		return m10mo_set_zsl_raw_capture(sd);
+	}
+
+	switch (dev->run_mode) {
+	case CI_MODE_STILL_CAPTURE:
+		ret = m10mo_set_still_capture(sd);
+		break;
+	default:
+		/* TODO: Revisit this logic on switching to panorama */
+		if (dev->curr_res_table[dev->fmt_idx].command == 0x43)
+			ret = m10mo_set_panorama_monitor(sd);
+		else if (dev->fps == M10MO_HIGH_SPEED_FPS)
+			ret = m10mo_set_high_speed(sd);
+		else
+			ret = m10mo_set_zsl_monitor(sd);
+	}
+	return ret;
+
+}
+
+const struct m10mo_fw_ops fw_type1_5_ops = {
+	.set_run_mode           = m10mo_set_run_mode_fw_type1_5,
+	.set_burst_mode         = m10mo_set_burst_mode,
+	.stream_off             = m10mo_streamoff,
+	.single_capture_process = m10mo_single_capture_process,
+	.try_mbus_fmt           =  __m10mo_try_mbus_fmt,
+	.set_mbus_fmt           =  __m10mo_set_mbus_fmt,
+	.test_pattern           = m10mo_test_pattern,
+};
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c
new file mode 100644
index 0000000..17426d3
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c
@@ -0,0 +1,448 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Partially based on m-5mols kernel driver,
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ *
+ * Partially based on jc_v4l2 kernel driver from http://opensource.samsung.com
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/atomisp_platform.h>
+#include <media/m10mo_atomisp.h>
+#include <linux/module.h>
+#include "m10mo.h"
+
+static const uint32_t m10mo_md_effective_size[] = {
+	M10MO_METADATA_WIDTH,
+	M10MO_METADATA_WIDTH,
+	M10MO_METADATA_WIDTH,
+	M10MO_METADATA_WIDTH
+};
+
+int m10mo_set_burst_mode_fw_type2(struct v4l2_subdev *sd, unsigned int val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	switch (val) {
+	case EXT_ISP_BURST_CAPTURE_CTRL_START:
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_BURST;
+		break;
+	case EXT_ISP_BURST_CAPTURE_CTRL_STOP:
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_NORMAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int m10mo_set_monitor_mode(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u32 val;
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+
+	dev_info(&client->dev, "%s mode: %d Width: %d, height: %d, cmd: 0x%x\n",
+		__func__, dev->mode, dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command);
+
+	/* Check if m10mo already streaming @ required resolution */
+	ret = m10mo_readb(sd, CATEGORY_PARAM,  PARAM_MON_SIZE, &val);
+	if (ret)
+		goto out;
+
+	/* If mode is monitor mode and size same, do not configure again*/
+	if (dev->mode == M10MO_MONITOR_MODE &&
+		val == dev->curr_res_table[dev->fmt_idx].command)
+		return 0;
+
+	/*Change to Monitor Size (e,g. VGA) */
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, PARAM_MON_SIZE,
+			dev->curr_res_table[dev->fmt_idx].command);
+	if (ret)
+		goto out;
+
+	if (mode == M10MO_RESOLUTION_MODE_0) {
+		/* TODO: FPS setting must be changed */
+		ret = m10mo_writeb(sd, CATEGORY_PARAM, PARAM_MON_FPS, 0x02);
+		if (ret)
+			goto out;
+
+		ret = m10mo_writeb(sd, CATEGORY_PARAM, 0x67, 0x00);
+		if (ret)
+			goto out;
+	}
+
+	if (dev->run_mode == CI_MODE_VIDEO)
+		ret = m10mo_writeb(sd, CATEGORY_PARAM,
+				   MONITOR_TYPE, MONITOR_VIDEO);
+	else
+		ret = m10mo_writeb(sd, CATEGORY_PARAM,
+				   MONITOR_TYPE, MONITOR_PREVIEW);
+
+	/* Enable metadata */
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, MON_METADATA_SUPPORT_CTRL,
+			   MON_METADATA_SUPPORT_CTRL_EN);
+	if (ret)
+		goto out;
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, MPO_FORMAT_META, 1);
+	if (ret)
+		goto out;
+
+	/* Enable interrupt signal */
+	ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+	if (ret)
+		goto out;
+	/* Go to Monitor mode and output YUV Data */
+	ret = m10mo_request_mode_change(sd, M10MO_MONITOR_MODE);
+	if (ret)
+		goto out;
+
+	return 0;
+out:
+	dev_err(&client->dev, "Streaming failed %d\n", ret);
+	return ret;
+}
+
+static int m10mo_set_burst_capture(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct m10mo_resolution *capture_res;
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+	int idx;
+	int ret;
+
+	dev_info(&client->dev, "%s mode: %d width: %d, height: %d, cmd: 0x%x\n",
+		__func__, dev->mode, dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command);
+
+	/* Exit from normal monitor mode. */
+	ret = m10mo_request_mode_change(sd, M10MO_PARAMETER_MODE);
+	if (ret)
+		return ret;
+	ret = m10mo_wait_mode_change(sd, M10MO_PARAMETER_MODE, M10MO_INIT_TIMEOUT);
+	if (ret)
+		return ret;
+
+	/* Configure burst capture resolution.
+	 * Map burst capture size to monitor size. Burst capture uses
+	 * monitor parameters.
+	 */
+	capture_res = &resolutions[mode][M10MO_MODE_CAPTURE_INDEX]
+		[dev->capture_res_idx];
+	idx = get_resolution_index(
+		resolutions[mode][M10MO_MODE_PREVIEW_INDEX],
+		resolutions_sizes[mode][M10MO_MODE_PREVIEW_INDEX],
+		capture_res->width, capture_res->height);
+	if (idx == -1) {
+		dev_err(&client->dev, "Unsupported burst capture size %dx%d\n",
+			capture_res->width, capture_res->height);
+		return -EINVAL;
+	}
+	ret = m10mo_writeb(sd, CATEGORY_PARAM, PARAM_MON_SIZE,
+		resolutions[mode][M10MO_MODE_PREVIEW_INDEX][idx]
+		.command);
+	if (ret)
+		return ret;
+
+	/* Start burst capture. */
+	ret = m10mo_request_mode_change(sd, M10MO_BURST_CAPTURE_MODE);
+
+	return ret;
+}
+
+static int m10mo_set_still_capture_fw_type2(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+	int ret;
+
+	dev_info(&client->dev, "%s mode: %d width: %d, height: %d, cmd: 0x%x\n",
+		__func__, dev->mode, dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command);
+
+	/* Setting before switching to capture mode */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM, CAPP_MAIN_IMAGE_SIZE,
+			  resolutions[mode][M10MO_MODE_CAPTURE_INDEX][dev->capture_res_idx].command);
+	if (ret)
+		goto out;
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, CAPC_MODE, 0);/* Single Capture*/
+	if (ret)
+		goto out;
+
+	ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x08);
+	if (ret)
+		goto out;
+
+	/* Set capture mode */
+	ret = m10mo_request_mode_change(sd, M10MO_SINGLE_CAPTURE_MODE);
+
+out:
+	return ret;
+}
+
+int m10mo_set_run_mode_fw_type2(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	/*
+	 * Handle RAW capture mode separately irrespective of the run mode
+	 * being configured. Start the RAW capture right away.
+	 */
+	if (dev->capture_mode == M10MO_CAPTURE_MODE_ZSL_RAW) {
+		/*
+		 * As RAW capture is done from a command line tool, we are not
+		 * restarting the preview after the RAW capture. So it is ok
+		 * to reset the RAW capture mode here because the next RAW
+		 * capture has to start from the Set format onwards.
+		 */
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_NORMAL;
+		return m10mo_set_zsl_raw_capture(sd);
+	}
+
+	switch (dev->run_mode) {
+	case CI_MODE_STILL_CAPTURE:
+		ret = m10mo_set_still_capture_fw_type2(sd);
+		break;
+	default:
+		/* Start still capture if M10MO is already in monitor mode. */
+		if (dev->mode == M10MO_MONITOR_MODE) {
+			if (dev->capture_mode ==
+			    M10MO_CAPTURE_MODE_ZSL_BURST)
+				ret = m10mo_set_burst_capture(sd);
+			else
+				ret = m10mo_set_still_capture_fw_type2(sd);
+		} else {
+			ret = m10mo_set_monitor_mode(sd);
+		}
+	}
+	return ret;
+}
+
+static int __m10mo_monitor_mode_set(struct v4l2_subdev *sd)
+{
+	int ret;
+
+	ret = m10mo_request_mode_change(sd, M10MO_MONITOR_MODE);
+	if (ret)
+		return ret;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_MONITOR_MODE,
+				     M10MO_INIT_TIMEOUT);
+	if (ret > 0)
+		ret = 0;
+	return ret;
+}
+
+int m10mo_streamoff_fw_type2(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret = 0;
+
+	if (dev->mode == M10MO_SINGLE_CAPTURE_MODE) {
+		/* Exit capture mode and back to monitor mode */
+		ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+		if (ret)
+			goto out;
+		ret = __m10mo_monitor_mode_set(sd);
+		if (ret)
+			return ret;
+	} else if (dev->mode == M10MO_BURST_CAPTURE_MODE) {
+		/* Exit burst capture mode. */
+		ret = __m10mo_param_mode_set(sd);
+		if (ret)
+			goto out;
+		/* Set monitor type as Preview. */
+		ret = m10mo_writeb(sd, CATEGORY_PARAM,
+				  MONITOR_TYPE, MONITOR_PREVIEW);
+		if (ret)
+			goto out;
+		/* Restart monitor mode. */
+		ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+		if (ret)
+			return ret;
+		ret = __m10mo_monitor_mode_set(sd);
+	}
+out:
+	return ret;
+}
+
+int m10mo_single_capture_process_fw_type2(struct v4l2_subdev *sd)
+{
+	int ret;
+
+	/* Select frame */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+			  CAPC_SEL_FRAME_MAIN, 0x01);
+	if (ret)
+		return ret;
+
+	/* Start image transfer */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+			  CAPC_TRANSFER_START, 0x01);
+	return ret;
+}
+
+int __m10mo_try_mbus_fmt_fw_type2(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt, bool update_fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+			(struct atomisp_input_stream_info *)fmt->reserved;
+	const struct m10mo_resolution *res;
+	int entries, idx;
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+
+	/* Set mbus format to 0x8001(YUV420) */
+	fmt->code = 0x8001;
+
+	/* In ZSL case, capture table needs to be handled separately */
+	if (stream_info->stream == ATOMISP_INPUT_STREAM_CAPTURE &&
+			(dev->run_mode == CI_MODE_PREVIEW ||
+			 dev->run_mode == CI_MODE_VIDEO ||
+			 dev->run_mode == CI_MODE_CONTINUOUS)) {
+		res = resolutions[mode][M10MO_MODE_CAPTURE_INDEX];
+		entries =
+		     resolutions_sizes[mode][M10MO_MODE_CAPTURE_INDEX];
+	} else {
+		res = dev->curr_res_table;
+		entries = dev->entries_curr_table;
+	}
+
+	/* check if the given resolutions are spported */
+	idx = get_resolution_index(res, entries, fmt->width, fmt->height);
+	if (idx < 0) {
+		dev_err(&client->dev, "%s unsupported resolution: %dx%d\n",
+			__func__, fmt->width, fmt->height);
+		return -EINVAL;
+	}
+
+	/* If the caller wants to get updated fmt values based on the search */
+	if (update_fmt) {
+		if (fmt->code == V4L2_MBUS_FMT_JPEG_1X8) {
+			fmt->width = dev->mipi_params.jpeg_width;
+			fmt->height = dev->mipi_params.jpeg_height;
+		} else if (fmt->code == V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+			fmt->width = dev->mipi_params.raw_width;
+			fmt->height = dev->mipi_params.raw_height;
+		} else {
+			fmt->width = res[idx].width;
+			fmt->height = res[idx].height;
+		}
+	}
+	return idx;
+}
+
+int __m10mo_set_mbus_fmt_fw_type2(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+			(struct atomisp_input_stream_info *)fmt->reserved;
+	struct camera_mipi_info *mipi_info = v4l2_get_subdev_hostdata(sd);
+	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
+	int index;
+
+	mutex_lock(&dev->input_lock);
+
+	index = dev->fw_ops->try_mbus_fmt(sd, fmt, false);
+	if (index < 0) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	dev->format.code = fmt->code;
+	dev->fmt_idx = index;
+	if (stream_info->stream == ATOMISP_INPUT_STREAM_CAPTURE) {
+		/* Save the index for selecting the capture resolution */
+		dev->capture_res_idx = dev->fmt_idx;
+	}
+
+	/* For FW_TYPE_2, preview/video images are output from VC0
+	 * and capture images are output from VC1.
+	 */
+	if (stream_info->stream == ATOMISP_INPUT_STREAM_CAPTURE)
+		stream_info->ch_id = 1;
+	else
+		stream_info->ch_id = 0;
+
+	mipi_info->metadata_format = M10MO_METADATA_FORMAT;
+	mipi_info->metadata_width = M10MO_METADATA_WIDTH;
+	mipi_info->metadata_height = M10MO_METADATA_HEIGHT;
+	mipi_info->metadata_effective_width = m10mo_md_effective_size;
+
+	dev_dbg(&client->dev,
+		"%s index prev/cap: %d/%d width: %d, height: %d, code; 0x%x\n",
+		 __func__, dev->fmt_idx, dev->capture_res_idx, fmt->width,
+		 fmt->height, dev->format.code);
+
+	/* Make the fixed width and height for JPEG and RAW formats */
+	if (dev->format.code == V4L2_MBUS_FMT_JPEG_1X8) {
+		/* The m10mo can only run JPEG in 30fps or lower */
+		dev->fps = M10MO_NORMAL_FPS;
+		fmt->width = dev->mipi_params.jpeg_width;
+		fmt->height = dev->mipi_params.jpeg_height;
+	} else if (dev->format.code == V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+		fmt->width = dev->mipi_params.raw_width;
+		fmt->height = dev->mipi_params.raw_height;
+	}
+
+	/* Update the stream info. Atomisp uses this for configuring mipi */
+	__m10mo_update_stream_info(sd, fmt);
+
+	/*
+	 * Handle raw capture mode separately. Update the capture mode to RAW
+	 * capture now. So that the next streamon call will start RAW capture.
+	 */
+	if (mode == M10MO_RESOLUTION_MODE_1 &&
+	    dev->format.code == V4L2_MBUS_FMT_CUSTOM_M10MO_RAW) {
+		dev_dbg(&client->dev, "%s RAW capture mode\n", __func__);
+		dev->capture_mode = M10MO_CAPTURE_MODE_ZSL_RAW;
+		dev->capture_res_idx = dev->fmt_idx;
+		dev->fmt_idx = 0;
+	}
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+
+int m10mo_test_pattern_fw_type2(struct v4l2_subdev *sd, u8 val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	return m10mo_writeb(&dev->sd, CATEGORY_TEST,
+			    TEST_PATTERN_SENSOR, val ? 2 : 0);
+}
+
+const struct m10mo_fw_ops fw_type2_ops = {
+	.set_run_mode           = m10mo_set_run_mode_fw_type2,
+	.set_burst_mode         = m10mo_set_burst_mode_fw_type2,
+	.stream_off             = m10mo_streamoff_fw_type2,
+	.single_capture_process = m10mo_single_capture_process_fw_type2,
+	.try_mbus_fmt           =  __m10mo_try_mbus_fmt_fw_type2,
+	.set_mbus_fmt           =  __m10mo_set_mbus_fmt_fw_type2,
+	.test_pattern           = m10mo_test_pattern_fw_type2,
+};
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c
index bda2130..ad0c468 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c
@@ -42,20 +42,123 @@ static const struct m10mo_resolution const m10mo_preview_modes_fw0[] = {
 
 static const struct m10mo_resolution const m10mo_preview_modes_fw1[] = {
 	{
+		.width = 176,
+		.height = 144,
+		.command = 0x05,
+	},
+	{
 		.width = 640,
 		.height = 480,
 		.command = 0x17,
 	},
 	{
+		.width = 768,
+		.height = 576,
+		.command = 0x3E,
+		.vdis = true,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.command = 0x21,
+	},
+	{
+		.width = 1536,
+		.height = 864,
+		.command = 0x3C,
+		.vdis = true,
+	},
+	{
+		.width = 1440,
+		.height = 1080,
+		.command = 0x37,
+	},
+	{
+		.width = 1728,
+		.height = 1296,
+		.command = 0x40,
+		.vdis = true,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x28,
+	},
+	/* TODO: Fix the panorama mode handling */
+	/*
+	 * This is a specific resolution setting for the panaroma mode. So
+	 * kept at this position intentionally so that this won't get selected
+	 * if none of the resolutions matched.
+	 */
+	{
+		.width = 3264,
+		.height = 1836,
+		.command = 0x43,
+	},
+	{
+		.width = 2304,
+		.height = 1296,
+		.command = 0x3B,
+		.vdis = true,
+	},
+};
+
+static const struct m10mo_resolution const m10mo_preview_modes_fw2[] = {
+	{
+		.width = 176,
+		.height = 144,
+		.command = 0x5,
+	},
+	{
+		.width = 320,
+		.height = 240,
+		.command = 0x9,
+	},
+	{
+		.width = 480,
+		.height = 320,
+		.command = 0x12,
+	},
+	{
+		.width = 640,
+		.height = 480,
+		.command = 0x17,
+	},
+	{
+		.width = 720,
+		.height = 480,
+		.command = 0x18,
+	},
+	{
+		.width = 960,
+		.height = 720,
+		.command = 0x34,
+	},
+	{
 		.width = 1280,
 		.height = 720,
 		.command = 0x21,
 	},
 	{
+		.width = 1600,
+		.height = 1200,
+		.command = 0x26,
+	},
+	{
 		.width = 1920,
 		.height = 1080,
 		.command = 0x28,
 	},
+	{
+		.width = 3264,
+		.height = 2448,
+		.command = 0x29,
+	},
+	{
+		.width = 3840,
+		.height = 2160,
+		.command = 0x4a,
+	},
 };
 
 static const struct m10mo_resolution const m10mo_capture_modes_fw0[] = {
@@ -108,17 +211,110 @@ static const struct m10mo_resolution const m10mo_capture_modes_fw1[] = {
 		.command = 0x10,
 	},
 	{
+		.width = 1600,
+		.height = 1200,
+		.command = 0x17,
+	},
+	{
+		.width = 2048,
+		.height = 1152,
+		.command = 0x1a,
+	},
+	{
 		.width = 2048,
 		.height = 1536,
 		.command = 0x1b,
 	},
 	{
+		.width = 3264,
+		.height = 1836,
+		.command = 0x21,
+	},
+	{
+		.width = 3264,
+		.height = 2448,
+		.command = 0x25,
+	},
+	{
+		.width = 4128,
+		.height = 2322,
+		.command = 0x2b,
+	},
+	{
 		.width = 4128,
 		.height = 3096,
 		.command = 0x2c,
 	},
 };
 
+static const struct m10mo_resolution const m10mo_capture_modes_fw2[] = {
+	{
+		.width = 320,
+		.height = 240,
+		.command = 0x2,
+	},
+	{
+		.width = 480,
+		.height = 320,
+		.command = 0x37,
+	},
+	{
+		.width = 640,
+		.height = 480,
+		.command = 0x9,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.command = 0x10,
+	},
+	{
+		.width = 1520,
+		.height = 1140,
+		.command = 0x38,
+	},
+	{
+		.width = 1600,
+		.height = 1200,
+		.command = 0x17,
+	},
+	{
+		.width = 1824,
+		.height = 1026,
+		.command = 0x39,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x19,
+	},
+	{
+		.width = 2048,
+		.height = 1536,
+		.command = 0x1b,
+	},
+	{
+		.width = 3264,
+		.height = 2448,
+		.command = 0x25,
+	},
+	{
+		.width = 3840,
+		.height = 2160,
+		.command = 0x26,
+	},
+	{
+		.width = 5248,
+		.height = 2952,
+		.command = 0x3e,
+	},
+	{
+		.width = 5248,
+		.height = 3936,
+		.command = 0x40,
+	},
+};
+
 static const struct m10mo_resolution const m10mo_video_modes_fw0[] = {
 	{
 		.width = 1920,
@@ -135,13 +331,99 @@ static const struct m10mo_resolution const m10mo_video_modes_fw1[] = {
 	},
 };
 
+static const struct m10mo_resolution const m10mo_video_modes_fw2[] = {
+	{
+		.width = 176,
+		.height = 144,
+		.command = 0x5,
+	},
+	{
+		.width = 212,
+		.height = 172,
+		.command = 0x4b,
+	},
+	{
+		.width = 320,
+		.height = 240,
+		.command = 0x9,
+	},
+	{
+		.width = 384,
+		.height = 288,
+		.command = 0x3f,
+	},
+	{
+		.width = 352,
+		.height = 288,
+		.command = 0xe,
+	},
+	{
+		.width = 424,
+		.height = 346,
+		.command = 0x4c,
+	},
+	{
+		.width = 640,
+		.height = 480,
+		.command = 0x17,
+	},
+	{
+		.width = 768,
+		.height = 576,
+		.command = 0x3e,
+	},
+	{
+		.width = 720,
+		.height = 480,
+		.command = 0x18,
+	},
+	{
+		.width = 864,
+		.height = 576,
+		.command = 0x3d,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.command = 0x21,
+	},
+	{
+		.width = 1536,
+		.height = 864,
+		.command = 0x3c,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x28,
+	},
+	{
+		.width = 2304,
+		.height = 1296,
+		.command = 0x3b,
+	},
+	{
+		.width = 3840,
+		.height = 2160,
+		.command = 0x4a,
+	},
+	{
+		.width = 4032,
+		.height = 2268,
+		.command = 0x4d,
+	},
+};
+
 const struct m10mo_resolution *resolutions[][3] = {
 	{ m10mo_preview_modes_fw0,
 	  m10mo_capture_modes_fw0,
 	  m10mo_video_modes_fw0 } ,
 	{ m10mo_preview_modes_fw1,
 	  m10mo_capture_modes_fw1,
-	  m10mo_video_modes_fw1 }
+	  m10mo_video_modes_fw1 },
+	{ m10mo_preview_modes_fw2,
+	  m10mo_capture_modes_fw2,
+	  m10mo_video_modes_fw2 }
 };
 
 const ssize_t resolutions_sizes[][3] = {
@@ -150,5 +432,73 @@ const ssize_t resolutions_sizes[][3] = {
 	  ARRAY_SIZE(m10mo_video_modes_fw0) } ,
 	{ ARRAY_SIZE(m10mo_preview_modes_fw1),
 	  ARRAY_SIZE(m10mo_capture_modes_fw1),
-	  ARRAY_SIZE(m10mo_video_modes_fw1) }
+	  ARRAY_SIZE(m10mo_video_modes_fw1) } ,
+	{ ARRAY_SIZE(m10mo_preview_modes_fw2),
+	  ARRAY_SIZE(m10mo_capture_modes_fw2),
+	  ARRAY_SIZE(m10mo_video_modes_fw2) } ,
+};
+
+const struct M10MO_AF_Parameters m10m0_af_parameters[] = {
+	/* parameters for firmware M10MO_AF_MODE_0 */
+	{
+		0x01,
+		0x00,
+		0x01,
+		0x02,
+		0x03,
+		0x04,
+		0x05,
+		0x06,
+		0x07,
+
+		0x02,
+		0x00,
+		0x01,
+		0x02,
+
+		0x03,
+		0x01,
+		0x02,
+		0x03,
+		0x04,
+		0x10,
+		0x20,
+		0x30,
+		0x40,
+
+		0x30,
+		0x32
+	},
+
+	/* parameters for firmware M10MO_AF_MODE_1 */
+	{
+		0x00,
+		0x01,
+		0x03,
+		0x02,
+		0x06,
+		0x06,
+		0x06,
+		0x06,
+		0x06,
+		0x02,
+		0x00,
+		0x01,
+		0x01,
+
+		0x03,
+		0x03,
+		0x04,
+		0x01,
+		0x02,
+		0x03,
+		0x04,
+		0x01,
+		0x02,
+
+		0x30,
+		0x32
+	},
+
+	{},
 };
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
index 303c908..eb8e565 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
@@ -52,6 +52,7 @@
  * be printed.
  */
 static int debug;
+static int aaalock;
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "Debug level (0-1)");
 
@@ -629,8 +630,8 @@ static int mt9m114_s_power(struct v4l2_subdev *sd, int power)
  * res->width/height smaller than w/h wouldn't be considered.
  * Returns the value of gap or -1 if fail.
  */
-#define LARGEST_ALLOWED_RATIO_MISMATCH 800
-static int distance(struct mt9m114_res_struct *res, u32 w, u32 h)
+#define LARGEST_ALLOWED_RATIO_MISMATCH 600
+static int distance(struct mt9m114_res_struct const *res, u32 w, u32 h)
 {
 	unsigned int w_ratio;
 	unsigned int h_ratio;
@@ -638,14 +639,13 @@ static int distance(struct mt9m114_res_struct *res, u32 w, u32 h)
 
 	if (w == 0)
 		return -1;
-	w_ratio = ((res->width << 13) / w);
-
+	w_ratio = (res->width << 13) / w;
 	if (h == 0)
 		return -1;
-	h_ratio = ((res->height << 13) / h);
+	h_ratio = (res->height << 13) / h;
 	if (h_ratio == 0)
 		return -1;
-	match = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
 
 	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
 		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
@@ -661,9 +661,9 @@ static int nearest_resolution_index(int w, int h)
 	int idx = -1;
 	int dist;
 	int min_dist = INT_MAX;
-	struct mt9m114_res_struct *tmp_res = NULL;
+	const struct mt9m114_res_struct *tmp_res = NULL;
 
-	for (i = 0; i < N_RES; i++) {
+	for (i = 0; i < ARRAY_SIZE(mt9m114_res); i++) {
 		tmp_res = &mt9m114_res[i];
 		dist = distance(tmp_res, w, h);
 		if (dist == -1)
@@ -679,15 +679,24 @@ static int nearest_resolution_index(int w, int h)
 
 static int mt9m114_try_res(u32 *w, u32 *h)
 {
-	int idx;
-
-	idx = nearest_resolution_index(*w, *h);
+	int idx = 0;
 
-	if (idx == -1) {
-		/* return the largest resolution */
-		*w = mt9m114_res[N_RES-1].width;
-		*h = mt9m114_res[N_RES-1].height;
+	if ((*w > MT9M114_RES_960P_SIZE_H)
+		|| (*h > MT9M114_RES_960P_SIZE_V)) {
+		*w = MT9M114_RES_960P_SIZE_H;
+		*h = MT9M114_RES_960P_SIZE_V;
 	} else {
+		idx = nearest_resolution_index(*w, *h);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 *  resolutions. If it fails, it means the requested
+		 *  resolution is higher than wecan support. Fallback
+		 *  to highest possible resolution in this case.
+		 */
+		if (idx == -1)
+			idx = ARRAY_SIZE(mt9m114_res) - 1;
+
 		*w = mt9m114_res[idx].width;
 		*h = mt9m114_res[idx].height;
 	}
@@ -1157,7 +1166,6 @@ static long mt9m114_s_exposure(struct v4l2_subdev *sd,
     struct i2c_client *client = v4l2_get_subdevdata(sd);
     struct mt9m114_device *dev = to_mt9m114_sensor(sd);
     int ret = 0;
-    int max_itg;
     unsigned int coarse_integration = 0;
     unsigned int fine_integration = 0;
     unsigned int FLines = 0;
@@ -1176,18 +1184,12 @@ static long mt9m114_s_exposure(struct v4l2_subdev *sd,
     FLines = mt9m114_res[dev->res].lines_per_frame;
     AnalogGain = exposure->gain[0];
     DigitalGain = exposure->gain[1];
-
-    /* Clamp integration time in video mode so as not to reduce FPS */
-    max_itg = FLines - 6;
-    if (coarse_integration > max_itg && dev->run_mode == CI_MODE_VIDEO)
-	    coarse_integration = max_itg;
-
-    if (!dev->streamon) {
-	    /*Save the first exposure values while stream is off*/
-	    dev->first_exp = coarse_integration;
-	    dev->first_gain = AnalogGain;
-	    dev->first_diggain = DigitalGain;
-    }
+	if (!dev->streamon) {
+		/*Save the first exposure values while stream is off*/
+		dev->first_exp = coarse_integration;
+		dev->first_gain = AnalogGain;
+		dev->first_diggain = DigitalGain;
+	}
     //DigitalGain = 0x400 * (((u16) DigitalGain) >> 8) + ((unsigned int)(0x400 * (((u16) DigitalGain) & 0xFF)) >>8);
 
     //set frame length
@@ -1262,6 +1264,7 @@ static long mt9m114_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 }
 
 
+#endif
 /* This returns the exposure time being used. This should only be used
    for filling in EXIF data, not for actual image processing. */
 static int mt9m114_g_exposure(struct v4l2_subdev *sd, s32 *value)
@@ -1279,7 +1282,6 @@ static int mt9m114_g_exposure(struct v4l2_subdev *sd, s32 *value)
 	*value = coarse;
 	return 0;
 }
-#endif
 #ifndef CSS15
 /*
  * This function will return the sensor supported max exposure zone number.
@@ -1411,6 +1413,76 @@ static int mt9m114_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
 }
 #endif
 
+static int mt9m114_s_ev(struct v4l2_subdev *sd, s32 val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	s32 luma = 0x37;
+	int err;
+
+	/* EV value only support -2 to 2
+	 * 0: 0x37, 1:0x47, 2:0x57, -1:0x27, -2:0x17
+	 */
+	if (val < -2 || val > 2) {
+		return -EINVAL;
+	}
+	luma += 0x10 * val;
+	dev_dbg(&c->dev, "%s val:%d luma:0x%x\n", __func__, val, luma);
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC87A);
+	if (err) {
+		dev_err(&c->dev, "%s logic addr access error\n", __func__);
+		return err;
+	}
+	err = mt9m114_write_reg(c, MISENSOR_8BIT, 0xC87A, (u32)luma);
+	if (err) {
+		dev_err(&c->dev, "%s write target_average_luma failed\n", __func__);
+		return err;
+	}
+	udelay(10);
+
+	return 0;
+}
+
+static int mt9m114_g_ev(struct v4l2_subdev *sd, s32 *val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int err;
+	u32 luma;
+
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC87A);
+	if (err) {
+		dev_err(&c->dev, "%s logic addr access error\n", __func__);
+		return err;
+	}
+	err = mt9m114_read_reg(c, MISENSOR_8BIT, 0xC87A, &luma);
+	if (err) {
+		dev_err(&c->dev, "%s read target_average_luma failed\n", __func__);
+		return err;
+	}
+	luma -= 0x17;
+	luma /= 0x10;
+	*val = (s32)luma - 2;
+	dev_dbg(&c->dev, "%s val:%d\n", __func__, *val);
+
+	return 0;
+}
+
+/* Fake interface
+ * mt9m114 now can not support 3a_lock
+*/
+static int mt9m114_s_3a_lock(struct v4l2_subdev *sd, s32 val)
+{
+	aaalock = val;
+	return 0;
+}
+
+static int mt9m114_g_3a_lock(struct v4l2_subdev *sd, s32 *val)
+{
+	if (aaalock)
+		return V4L2_LOCK_EXPOSURE | V4L2_LOCK_WHITE_BALANCE
+			| V4L2_LOCK_FOCUS;
+	return 0;
+}
+
 static struct mt9m114_control mt9m114_controls[] = {
 	{
 		.qc = {
@@ -1506,7 +1578,6 @@ static struct mt9m114_control mt9m114_controls[] = {
 		.query = mt9m114_g_2a_status,
 	},
 #endif
-#ifdef CONFIG_GMIN_INTEL_MID /* FIXME! for RAW Mode*/
 	{
 		.qc = {
 			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
@@ -1520,7 +1591,6 @@ static struct mt9m114_control mt9m114_controls[] = {
 		},
 		.query = mt9m114_g_exposure,
 	},
-#endif
 #ifndef CSS15
 	{
 		.qc = {
@@ -1577,6 +1647,35 @@ static struct mt9m114_control mt9m114_controls[] = {
 		.query = mt9m114_g_bin_factor_y,
 	},
 #endif
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure biasx",
+			.minimum = -2,
+			.maximum = 2,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = mt9m114_s_ev,
+		.query = mt9m114_g_ev,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_3A_LOCK,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "3a lock",
+			.minimum = 0,
+			.maximum = V4L2_LOCK_EXPOSURE | V4L2_LOCK_WHITE_BALANCE
+			| V4L2_LOCK_FOCUS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = mt9m114_s_3a_lock,
+		.query = mt9m114_g_3a_lock,
+	},
 };
 #define N_CONTROLS (ARRAY_SIZE(mt9m114_controls))
 
@@ -1759,8 +1858,6 @@ static int mt9m114_t_vflip(struct v4l2_subdev *sd, int value)
 static int mt9m114_s_parm(struct v4l2_subdev *sd,
 			struct v4l2_streamparm *param)
 {
-	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
-	dev->run_mode = param->parm.capture.capturemode;
 	return 0;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
index 45d296d..58322d4 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
@@ -273,7 +273,6 @@ struct mt9m114_device {
 	int real_model_id;
 	int nctx;
 	int power;
-	int run_mode;
 
 	unsigned int bus_width;
 	unsigned int mode;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Kconfig
new file mode 100644
index 0000000..9fb1bff
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Kconfig
@@ -0,0 +1,11 @@
+config VIDEO_OV5693
+       tristate "Omnivision ov5693 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Micron
+         ov5693 5 Mpixel camera.
+
+         ov5693 is video camera sensor.
+
+         It currently only works with the atomisp driver.
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Makefile
new file mode 100644
index 0000000..fceb9e9
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_VIDEO_OV5693) += ov5693.o
+
+ccflags-y += -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c
new file mode 100755
index 0000000..06218c1
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c
@@ -0,0 +1,1801 @@
+/*
+ * Support for OmniVision OV5693 1080p HD camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <linux/io.h>
+#include <linux/acpi.h>
+#include <linux/atomisp_gmin_platform.h>
+
+#include "ov5693.h"
+
+static int vcm_ad_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err;
+	struct i2c_msg msg;
+	u8 buf[2];
+
+	buf[0] = reg;
+	buf[1] = val;
+
+	msg.addr = VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = &buf[0];
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+	if (err != 1) {
+		dev_err(&client->dev, "%s: vcm i2c fail, err code = %d\n",
+			__func__, err);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int vcm_ad_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
+{
+	int err;
+	struct i2c_msg msg;
+	u8 buf[3];
+	buf[0] = reg;
+	buf[1] = (u8)(val >> 8);
+	buf[2] = (u8)(val & 0xff);
+	msg.addr = VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 3;
+	msg.buf = &buf[0];
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+	if (err != 1) {
+		dev_err(&client->dev, "%s: vcm i2c fail, err code = %d\n",
+			__func__, err);
+		return -EIO;
+	}
+	return 0;
+}
+
+static const uint32_t ov5693_embedded_effective_size = 28;
+
+/* i2c read/write stuff */
+static int ov5693_read_reg(struct i2c_client *client,
+			   u16 data_length, u16 reg, u16 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[6];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != OV5693_8BIT && data_length != OV5693_16BIT
+					&& data_length != OV5693_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == OV5693_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == OV5693_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int ov5693_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int vcm_dw_i2c_write(struct i2c_client *client, u16 data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	u16 val;
+
+	val = cpu_to_be16(data);
+	msg.addr = VCM_ADDR;
+	msg.flags = 0;
+	msg.len = OV5693_16BIT;
+	msg.buf = (u8 *)&val;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+/* Theory: per datasheet, the two VCMs both allow for a 2-byte read.
+ * The DW9714 doesn't actually specify what this does (it has a
+ * two-byte write-only protocol, but specifies the read sequence as
+ * legal), but it returns the same data (zeroes) always, after an
+ * undocumented initial NAK.  The AD5823 has a one-byte address
+ * register to which all writes go, and subsequent reads will cycle
+ * through the 8 bytes of registers.  Notably, the default values (the
+ * device is always power-cycled affirmatively, so we can rely on
+ * these) in AD5823 are not pairwise repetitions of the same 16 bit
+ * word.  So all we have to do is sequentially read two bytes at a
+ * time and see if we detect a difference in any of the first four
+ * pairs.  */
+static int vcm_detect(struct i2c_client *client)
+{
+	int i, ret;
+	struct i2c_msg msg;
+        u16 data0=0, data;
+	for(i=0; i<4; i++) {
+		msg.addr = VCM_ADDR;
+		msg.flags = I2C_M_RD;
+		msg.len = sizeof(data);
+		msg.buf = (u8*)&data;
+		ret = i2c_transfer(client->adapter, &msg, 1);
+
+		/* DW9714 always fails the first read and returns
+		 * zeroes for subsequent ones */
+		if (i == 0 && ret == -EREMOTEIO) {
+			data0 = 0;
+			continue;
+		}
+
+		if (i == 0)
+			data0 = data;
+
+		if (data != data0)
+			return VCM_AD5823;
+	}
+	return ret == 1 ? VCM_DW9714 : ret;
+}
+
+static int ov5693_write_reg(struct i2c_client *client, u16 data_length,
+							u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg = (u16 *)data;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (data_length != OV5693_8BIT && data_length != OV5693_16BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == OV5693_8BIT) {
+		data[2] = (u8)(val);
+	} else {
+		/* OV5693_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
+
+	ret = ov5693_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * ov5693_write_reg_array - Initializes a list of OV5693 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __ov5693_flush_reg_array, __ov5693_buf_reg_array() and
+ * __ov5693_write_reg_is_consecutive() are internal functions to
+ * ov5693_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __ov5693_flush_reg_array(struct i2c_client *client,
+				    struct ov5693_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov5693_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __ov5693_buf_reg_array(struct i2c_client *client,
+				  struct ov5693_write_ctrl *ctrl,
+				  const struct ov5693_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case OV5693_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case OV5693_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= OV5693_MAX_WRITE_BUF_SIZE)
+		return __ov5693_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int __ov5693_write_reg_is_consecutive(struct i2c_client *client,
+					     struct ov5693_write_ctrl *ctrl,
+					     const struct ov5693_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int ov5693_write_reg_array(struct i2c_client *client,
+				  const struct ov5693_reg *reglist)
+{
+	const struct ov5693_reg *next = reglist;
+	struct ov5693_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != OV5693_TOK_TERM; next++) {
+		switch (next->type & OV5693_TOK_MASK) {
+		case OV5693_TOK_DELAY:
+			err = __ov5693_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__ov5693_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __ov5693_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			}
+			err = __ov5693_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __ov5693_flush_reg_array(client, &ctrl);
+}
+static int ov5693_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5693_FOCAL_LENGTH_NUM << 16) | OV5693_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov5693_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (OV5693_F_NUMBER_DEFAULT_NUM << 16) | OV5693_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5693_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5693_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV5693_F_NUMBER_DEM << 16) |
+		(OV5693_F_NUMBER_DEFAULT_NUM << 8) | OV5693_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5693_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	*val = ov5693_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int ov5693_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	*val = ov5693_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+static int ov5693_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct ov5693_resolution *res)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	unsigned int pix_clk_freq_hz;
+	u16 reg_val;
+	int ret;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* pixel clock */
+	pix_clk_freq_hz = res->pix_clk_freq * 1000000;
+
+	dev->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+	buf->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+
+	/* get integration time */
+	buf->coarse_integration_time_min = OV5693_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+					OV5693_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = OV5693_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					OV5693_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = OV5693_FINE_INTG_TIME_MIN;
+	buf->frame_length_lines = res->lines_per_frame;
+	buf->line_length_pck = res->pixels_per_line;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	ret =  ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_HORIZONTAL_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = reg_val;
+
+	ret =  ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_VERTICAL_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_HORIZONTAL_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_end = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_VERTICAL_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_end = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_HORIZONTAL_OUTPUT_SIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_width = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_VERTICAL_OUTPUT_SIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_height = reg_val;
+
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
+	return 0;
+}
+
+static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	u16 vts,hts;
+	int ret,exp_val;
+
+	hts = ov5693_res[dev->fmt_idx].pixels_per_line;
+	vts = ov5693_res[dev->fmt_idx].lines_per_frame;
+
+	/* group hold */
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+                                       OV5693_GROUP_ACCESS, 0x00);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_GROUP_ACCESS);
+		return ret;
+	}
+
+	/* Increase the VTS to match exposure + MARGIN */
+	if (coarse_itg > vts - OV5693_INTEGRATION_TIME_MARGIN)
+		vts = (u16) coarse_itg + OV5693_INTEGRATION_TIME_MARGIN;
+
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_TIMING_VTS_H, (vts >> 8) & 0xFF);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_TIMING_VTS_H);
+		return ret;
+	}
+
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_TIMING_VTS_L, vts & 0xFF);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_TIMING_VTS_L);
+		return ret;
+	}
+
+	/* set exposure */
+
+	/* Lower four bit should be 0*/
+	exp_val = coarse_itg << 4;
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+			       OV5693_EXPOSURE_L, exp_val & 0xFF);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_EXPOSURE_L);
+		return ret;
+	}
+
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+			       OV5693_EXPOSURE_M, (exp_val >> 8) & 0xFF);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_EXPOSURE_M);
+		return ret;
+	}
+
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+			       OV5693_EXPOSURE_H, (exp_val >> 16) & 0x0F);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_EXPOSURE_H);
+		return ret;
+	}
+
+	/* Analog gain */
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_AGC_L, gain & 0xff);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_AGC_L);
+		return ret;
+	}
+
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_AGC_H, (gain >> 8) & 0xff);
+	if (ret) {
+		dev_err(&client->dev, "%s: write %x error, aborted\n",
+			__func__, OV5693_AGC_H);
+		return ret;
+	}
+
+	/* Digital gain */
+	if (digitgain) {
+		ret = ov5693_write_reg(client, OV5693_16BIT,
+				OV5693_MWB_RED_GAIN_H, digitgain);
+		if (ret) {
+			dev_err(&client->dev, "%s: write %x error, aborted\n",
+				__func__, OV5693_MWB_RED_GAIN_H);
+			return ret;
+		}
+
+		ret = ov5693_write_reg(client, OV5693_16BIT,
+				OV5693_MWB_GREEN_GAIN_H, digitgain);
+		if (ret) {
+			dev_err(&client->dev, "%s: write %x error, aborted\n",
+				__func__, OV5693_MWB_RED_GAIN_H);
+			return ret;
+		}
+
+		ret = ov5693_write_reg(client, OV5693_16BIT,
+				OV5693_MWB_BLUE_GAIN_H, digitgain);
+		if (ret) {
+			dev_err(&client->dev, "%s: write %x error, aborted\n",
+				__func__, OV5693_MWB_RED_GAIN_H);
+			return ret;
+		}
+	}
+
+	/* End group */
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+			       OV5693_GROUP_ACCESS, 0x10);
+	if (ret)
+		return ret;
+
+	/* Delay launch group */
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+					   OV5693_GROUP_ACCESS, 0xa0);
+	if (ret)
+		return ret;
+	return ret;
+}
+
+static int ov5693_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov5693_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long ov5693_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	u16 coarse_itg = exposure->integration_time[0];
+	u16 analog_gain = exposure->gain[0];
+	u16 digital_gain = exposure->gain[1];
+
+	/* we should not accept the invalid value below */
+	if (analog_gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+	return ov5693_set_exposure(sd, coarse_itg, analog_gain, digital_gain);
+}
+
+static long ov5693_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return ov5693_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int ov5693_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 reg_v, reg_v2;
+	int ret;
+
+	/* get exposure */
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_EXPOSURE_L,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_EXPOSURE_M,
+					&reg_v2);
+	if (ret)
+		goto err;
+
+	reg_v += reg_v2 << 8;
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_EXPOSURE_H,
+					&reg_v2);
+	if (ret)
+		goto err;
+
+	*value = reg_v + (((u32)reg_v2 << 16));
+err:
+	return ret;
+}
+
+static int ov5693_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	dev_dbg(&client->dev, "%s: FOCUS_POS: %x\n", __func__, value);
+	value = clamp(value, 0, OV5693_VCM_MAX_FOCUS_POS);
+	if (dev->vcm == VCM_DW9714) {
+		if (dev->vcm_update) {
+			ret = vcm_dw_i2c_write(client, VCM_PROTECTION_OFF);
+			if (ret)
+				return ret;
+			ret = vcm_dw_i2c_write(client, DIRECT_VCM);
+			if (ret)
+				return ret;
+			ret = vcm_dw_i2c_write(client, VCM_PROTECTION_ON);
+			if (ret)
+				return ret;
+			dev->vcm_update = false;
+		}
+		ret = vcm_dw_i2c_write(client,
+				       vcm_val(value, VCM_DEFAULT_S));
+	} else if (dev->vcm == VCM_AD5823) {
+		ret = vcm_ad_i2c_wr16(client, VCM_CODE_MSB, value);
+	}
+	if (ret == 0) {
+		dev->number_of_steps = value - dev->focus;
+		dev->focus = value;
+		getnstimeofday(&(dev->timestamp_t_focus_abs));
+	} else
+		dev_err(&client->dev,
+			"%s: i2c failed. ret %d\n", __func__, ret);
+
+	return ret;
+}
+
+static int ov5693_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	return ov5693_t_focus_abs(sd, dev->focus + value);
+}
+
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+static int ov5693_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 status = 0;
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct timespec temptime;
+	const struct timespec timedelay = {
+		0,
+		min((u32)abs(dev->number_of_steps) * DELAY_PER_STEP_NS,
+		(u32)DELAY_MAX_PER_STEP_NS),
+	};
+
+	getnstimeofday(&temptime);
+	temptime = timespec_sub(temptime, (dev->timestamp_t_focus_abs));
+	if (timespec_compare(&temptime, &timedelay) <= 0) {
+		status |= ATOMISP_FOCUS_STATUS_MOVING;
+		status |= ATOMISP_FOCUS_HP_IN_PROGRESS;
+	} else {
+		status |= ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+		status |= ATOMISP_FOCUS_HP_COMPLETE;
+	}
+
+	*value = status;
+
+	return 0;
+}
+
+static int ov5693_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	s32 val;
+
+	ov5693_q_focus_status(sd, &val);
+
+	if (val & ATOMISP_FOCUS_STATUS_MOVING)
+		*value  = dev->focus - dev->number_of_steps;
+	else
+		*value  = dev->focus;
+
+	return 0;
+}
+
+static int ov5693_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	dev->number_of_steps = value;
+	dev->vcm_update = true;
+	return 0;
+}
+
+static int ov5693_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	dev->number_of_steps = value;
+	dev->vcm_update = true;
+	return 0;
+}
+
+struct ov5693_control ov5693_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5693_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = OV5693_FOCAL_LENGTH_DEFAULT,
+			.maximum = OV5693_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5693_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5693_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = OV5693_F_NUMBER_DEFAULT,
+			.maximum = OV5693_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5693_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5693_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = OV5693_F_NUMBER_RANGE,
+			.maximum =  OV5693_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV5693_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov5693_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move absolute",
+			.minimum = 0,
+			.maximum = OV5693_VCM_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = ov5693_t_focus_abs,
+		.query = ov5693_q_focus_abs,
+
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_RELATIVE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move relative",
+			.minimum = OV5693_VCM_MAX_FOCUS_NEG,
+			.maximum = OV5693_VCM_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = ov5693_t_focus_rel,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 100, /* allow enum to grow in the future */
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = ov5693_q_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VCM_SLEW,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vcm slew",
+			.minimum = 0,
+			.maximum = OV5693_VCM_SLEW_STEP_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = ov5693_t_vcm_slew,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VCM_TIMEING,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vcm step time",
+			.minimum = 0,
+			.maximum = OV5693_VCM_SLEW_TIME_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = ov5693_t_vcm_timing,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = OV5693_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = ov5693_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = OV5693_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = ov5693_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov5693_controls))
+
+static struct ov5693_control *ov5693_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (ov5693_controls[i].qc.id == id)
+			return &ov5693_controls[i];
+	return NULL;
+}
+
+static int ov5693_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov5693_control *ctrl = ov5693_find_control(qc->id);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int ov5693_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5693_control *s_ctrl;
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = ov5693_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov5693_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5693_control *octrl = ov5693_find_control(ctrl->id);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov5693_init(struct v4l2_subdev *sd)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	pr_info("%s\n", __func__);
+	mutex_lock(&dev->input_lock);
+	dev->vcm_update = false;
+
+	if (dev->vcm == VCM_AD5823) {
+		ret = vcm_ad_i2c_wr8(client, 0x01, 0x01); // vcm init test
+		if (ret)
+			dev_err(&client->dev,
+				"vcm reset failed\n");
+	}
+
+	/* restore settings */
+	ov5693_res = ov5693_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	dev->focus = 0;
+	ov5693_t_focus_abs(sd, 0);
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int power_ctrl(struct v4l2_subdev *sd, bool flag)
+{
+	int ret;
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	if (!dev || !dev->platform_data)
+		return -ENODEV;
+
+	/* Non-gmin platforms use the legacy callback */
+	if (dev->platform_data->power_ctrl)
+		return dev->platform_data->power_ctrl(sd, flag);
+
+	if (flag) {
+		ret = dev->platform_data->v2p8_ctrl(sd, 1);
+		if (ret == 0) {
+			ret = dev->platform_data->v1p8_ctrl(sd, 1);
+			if (ret)
+				ret = dev->platform_data->v2p8_ctrl(sd, 0);
+		}
+	} else {
+		ret = dev->platform_data->v1p8_ctrl(sd, 0);
+		ret |= dev->platform_data->v2p8_ctrl(sd, 0);
+	}
+
+	return ret;
+}
+
+static int gpio_ctrl(struct v4l2_subdev *sd, bool flag)
+{
+	int ret;
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	if (!dev || !dev->platform_data)
+		return -ENODEV;
+
+	/* Non-gmin platforms use the legacy callback */
+	if (dev->platform_data->gpio_ctrl)
+		return dev->platform_data->gpio_ctrl(sd, flag);
+
+	ret = dev->platform_data->gpio0_ctrl(sd, flag);
+
+	/* The OV5693 has two enable inputs: XSHUTDN and RESETB, both
+	 * are active low, both must be high to enable the device.
+	 * And they can be enabled in either order.  The datasheet
+	 * even suggests that one be tied high, and some modules do
+	 * that.  Basically: allow the second GPIO to be missing in
+	 * the DSDT and ignore an error here. */
+	dev->platform_data->gpio1_ctrl(sd, flag);
+
+	return ret;
+}
+
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
+	usleep_range(5000, 6000);
+
+	/* gpio ctrl */
+	ret = gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_power;
+	}
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* according to DS, 20ms is needed between PWDN and i2c access */
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	gpio_ctrl(sd, 0);
+fail_power:
+	power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	dev->focus = OV5693_INVALID_CONFIG;
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	/* power control */
+	ret = power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int ov5693_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+
+	pr_info("%s: on %d\n", __func__, on);
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return ov5693_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct ov5693_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct ov5693_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &ov5693_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != ov5693_res[i].width)
+			continue;
+		if (h != ov5693_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int ov5693_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+					fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = ov5693_res[0].width;
+		fmt->height = ov5693_res[0].height;
+	} else {
+		fmt->width = ov5693_res[idx].width;
+		fmt->height = ov5693_res[idx].height;
+	}
+
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+/* TODO: remove it. */
+static int startup(struct v4l2_subdev *sd)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+					OV5693_SW_RESET, 0x01);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 reset err.\n");
+		return ret;
+	}
+
+	ret = ov5693_write_reg_array(client, ov5693_global_setting);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 write register err.\n");
+		return ret;
+	}
+
+	ret = ov5693_write_reg_array(client, ov5693_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 write register err.\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ov5693_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *ov5693_info = NULL;
+	int ret = 0;
+
+	ov5693_info = v4l2_get_subdev_hostdata(sd);
+	if (ov5693_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = ov5693_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width,
+					      fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	ret = ov5693_get_intg_factor(client, ov5693_info,
+					&ov5693_res[dev->fmt_idx]);
+	if (ret) {
+		dev_err(&client->dev, "failed to get integration_factor\n");
+		goto err;
+	}
+
+	ret = startup(sd);
+	if (ret)
+		dev_err(&client->dev, "ov5693 startup err\n");
+
+	ov5693_info->metadata_width = fmt->width * 10 / 8;
+	ov5693_info->metadata_height = 1;
+	ov5693_info->metadata_effective_width = &ov5693_embedded_effective_size;
+
+err:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int ov5693_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = ov5693_res[dev->fmt_idx].width;
+	fmt->height = ov5693_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov5693_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 high, low;
+	int ret;
+	u16 id;
+	u8 revision;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_SC_CMMN_CHIP_ID_H, &high);
+	if (ret) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", high);
+		return -ENODEV;
+	}
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_SC_CMMN_CHIP_ID_L, &low);
+	id = ((((u16) high) << 8) | (u16) low);
+
+	if (id != OV5693_ID) {
+		dev_err(&client->dev, "sensor ID error 0x%x\n", id);
+		return -ENODEV;
+	}
+
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_SC_CMMN_SUB_ID, &high);
+	revision = (u8) high & 0x0f;
+
+	dev_dbg(&client->dev, "sensor_revision = 0x%x\n", revision);
+	dev_dbg(&client->dev, "detect ov5693 success\n");
+	return 0;
+}
+
+static int ov5693_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_SW_STREAM,
+				enable ? OV5693_START_STREAMING :
+				OV5693_STOP_STREAMING);
+
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+/* ov5693 enum frame size, frame intervals */
+static int ov5693_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov5693_res[index].width;
+	fsize->discrete.height = ov5693_res[index].height;
+	fsize->reserved[0] = ov5693_res[index].used;
+
+	return 0;
+}
+
+static int ov5693_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = ov5693_res[index].width;
+	fival->height = ov5693_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov5693_res[index].fps;
+
+	return 0;
+}
+
+static int ov5693_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov5693_s_config(struct v4l2_subdev *sd,
+			   int irq, void *platform_data)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	dev->platform_data =
+		(struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 power-off err.\n");
+		goto fail_power_off;
+	}
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 power-up err.\n");
+		goto fail_power_on;
+	}
+
+	if (!dev->vcm)
+		dev->vcm = vcm_detect(client);
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = ov5693_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "ov5693_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int ov5693_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			ov5693_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int ov5693_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		ov5693_res = ov5693_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		ov5693_res = ov5693_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		ov5693_res = ov5693_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov5693_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = ov5693_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int ov5693_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int ov5693_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov5693_res[index].width;
+	fse->min_height = ov5693_res[index].height;
+	fse->max_width = ov5693_res[index].width;
+	fse->max_height = ov5693_res[index].height;
+
+	return 0;
+
+}
+
+static struct v4l2_mbus_framefmt *
+__ov5693_get_pad_format(struct ov5693_device *sensor,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+			"__ov5693_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int ov5693_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct ov5693_device *snr = to_ov5693_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__ov5693_get_pad_format(snr, fh, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int ov5693_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct ov5693_device *snr = to_ov5693_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov5693_video_ops = {
+	.s_stream = ov5693_s_stream,
+	.g_parm = ov5693_g_parm,
+	.s_parm = ov5693_s_parm,
+	.enum_framesizes = ov5693_enum_framesizes,
+	.enum_frameintervals = ov5693_enum_frameintervals,
+	.enum_mbus_fmt = ov5693_enum_mbus_fmt,
+	.try_mbus_fmt = ov5693_try_mbus_fmt,
+	.g_mbus_fmt = ov5693_g_mbus_fmt,
+	.s_mbus_fmt = ov5693_s_mbus_fmt,
+	.g_frame_interval = ov5693_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops ov5693_core_ops = {
+	.s_power = ov5693_s_power,
+	.queryctrl = ov5693_queryctrl,
+	.g_ctrl = ov5693_g_ctrl,
+	.s_ctrl = ov5693_s_ctrl,
+	.ioctl = ov5693_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops ov5693_pad_ops = {
+	.enum_mbus_code = ov5693_enum_mbus_code,
+	.enum_frame_size = ov5693_enum_frame_size,
+	.get_fmt = ov5693_get_pad_format,
+	.set_fmt = ov5693_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ov5693_ops = {
+	.core = &ov5693_core_ops,
+	.video = &ov5693_video_ops,
+	.pad = &ov5693_pad_ops,
+};
+
+static int ov5693_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	dev_dbg(&client->dev, "ov5693_remove...\n");
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov5693_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct ov5693_device *dev;
+	int i2c;
+	int ret = 0;
+	void *pdata = client->dev.platform_data;
+
+	/* Firmware workaround: Some modules use a "secondary default"
+	 * address of 0x10 which doesn't appear on schematics, and
+	 * some BIOS versions haven't gotten the memo.  Work around
+	 * via config. */
+	i2c = gmin_get_var_int(&client->dev, "I2CAddr", -1);
+	if (i2c != -1) {
+		dev_info(&client->dev, "Overriding firmware-provided I2C address (0x%x) with 0x%x\n",
+			 client->addr, i2c);
+		client->addr = i2c;
+	}
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov5693_ops);
+
+	if (ACPI_COMPANION(&client->dev))
+		pdata = gmin_camera_platform_data(&dev->sd,
+						  ATOMISP_INPUT_FORMAT_RAW_10,
+						  atomisp_bayer_order_bggr);
+	if (!pdata)
+		goto out_free;
+
+	ret = ov5693_s_config(&dev->sd, client->irq, pdata);
+	if (ret)
+		goto out_free;
+
+	ret = atomisp_register_i2c_module(&dev->sd, pdata, RAW_CAMERA);
+	if (ret)
+		goto out_free;
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		ov5693_remove(client);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov5693_id);
+
+static struct acpi_device_id ov5693_acpi_match[] = {
+	{"INT33BE"},
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, ov5693_acpi_match);
+
+static struct i2c_driver ov5693_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV5693_NAME,
+		.acpi_match_table = ACPI_PTR(ov5693_acpi_match),
+	},
+	.probe = ov5693_probe,
+	.remove = ov5693_remove,
+	.id_table = ov5693_id,
+};
+
+static int init_ov5693(void)
+{
+	return i2c_add_driver(&ov5693_driver);
+}
+
+static void exit_ov5693(void)
+{
+
+	i2c_del_driver(&ov5693_driver);
+}
+
+module_init(init_ov5693);
+module_exit(exit_ov5693);
+
+MODULE_DESCRIPTION("A low-level driver for OmniVision 5693 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h
new file mode 100755
index 0000000..193283c
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h
@@ -0,0 +1,971 @@
+/*
+ * Support for OmniVision OV5693 5M camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV5693_H__
+#define __OV5693_H__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+
+#include <linux/atomisp_platform.h>
+
+#define OV5693_NAME		"ov5693"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		0x2
+#define I2C_RETRY_COUNT		5
+
+#define OV5693_FOCAL_LENGTH_NUM	334	/*3.34mm*/
+#define OV5693_FOCAL_LENGTH_DEM	100
+#define OV5693_F_NUMBER_DEFAULT_NUM	24
+#define OV5693_F_NUMBER_DEM	10
+
+#define MAX_FMTS		1
+
+/* sensor_mode_data read_mode adaptation */
+#define OV5693_READ_MODE_BINNING_ON	0x0400
+#define OV5693_READ_MODE_BINNING_OFF	0x00
+#define OV5693_INTEGRATION_TIME_MARGIN	8
+
+#define OV5693_MAX_EXPOSURE_VALUE	0xFFF1
+#define OV5693_MAX_GAIN_VALUE		0xFF
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5693_FOCAL_LENGTH_DEFAULT 0x1B70064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5693_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV5693_F_NUMBER_RANGE 0x180a180a
+#define OV5693_ID	0x5690
+
+#define OV5693_FINE_INTG_TIME_MIN 0
+#define OV5693_FINE_INTG_TIME_MAX_MARGIN 0
+#define OV5693_COARSE_INTG_TIME_MIN 1
+#define OV5693_COARSE_INTG_TIME_MAX_MARGIN 6
+
+#define OV5693_BIN_FACTOR_MAX 4
+/*
+ * OV5693 System control registers
+ */
+#define OV5693_SW_SLEEP				0x0100
+#define OV5693_SW_RESET				0x0103
+#define OV5693_SW_STREAM			0x0100
+
+#define OV5693_SC_CMMN_CHIP_ID_H		0x300A
+#define OV5693_SC_CMMN_CHIP_ID_L		0x300B
+#define OV5693_SC_CMMN_SCCB_ID			0x300C
+#define OV5693_SC_CMMN_SUB_ID			0x302A /* process, version*/
+
+#define OV5693_GROUP_ACCESS							0x3208 /*Bit[7:4] Group control, Bit[3:0] Group ID*/
+
+#define OV5693_EXPOSURE_H							0x3500 /*Bit[3:0] Bit[19:16] of exposure, remaining 16 bits lies in Reg0x3501&Reg0x3502*/
+#define OV5693_EXPOSURE_M							0x3501
+#define OV5693_EXPOSURE_L							0x3502
+#define OV5693_AGC_H								0x350A /*Bit[1:0] means Bit[9:8] of gain*/
+#define OV5693_AGC_L								0x350B /*Bit[7:0] of gain*/
+
+#define OV5693_HORIZONTAL_START_H					0x3800 /*Bit[11:8]*/
+#define OV5693_HORIZONTAL_START_L					0x3801 /*Bit[7:0]*/
+#define OV5693_VERTICAL_START_H						0x3802 /*Bit[11:8]*/
+#define OV5693_VERTICAL_START_L						0x3803 /*Bit[7:0]*/
+#define OV5693_HORIZONTAL_END_H						0x3804 /*Bit[11:8]*/
+#define OV5693_HORIZONTAL_END_L						0x3805 /*Bit[7:0]*/
+#define OV5693_VERTICAL_END_H						0x3806 /*Bit[11:8]*/
+#define OV5693_VERTICAL_END_L						0x3807 /*Bit[7:0]*/
+#define OV5693_HORIZONTAL_OUTPUT_SIZE_H				0x3808 /*Bit[3:0]*/
+#define OV5693_HORIZONTAL_OUTPUT_SIZE_L				0x3809 /*Bit[7:0]*/
+#define OV5693_VERTICAL_OUTPUT_SIZE_H				0x380a /*Bit[3:0]*/
+#define OV5693_VERTICAL_OUTPUT_SIZE_L				0x380b /*Bit[7:0]*/
+#define OV5693_TIMING_HTS_H							0x380C  /*High 8-bit, and low 8-bit HTS address is 0x380d*/
+#define OV5693_TIMING_HTS_L							0x380D  /*High 8-bit, and low 8-bit HTS address is 0x380d*/
+#define OV5693_TIMING_VTS_H							0x380e  /*High 8-bit, and low 8-bit HTS address is 0x380f*/
+#define OV5693_TIMING_VTS_L							0x380f  /*High 8-bit, and low 8-bit HTS address is 0x380f*/
+
+#define OV5693_MWB_RED_GAIN_H			0x3400
+#define OV5693_MWB_GREEN_GAIN_H			0x3402
+#define OV5693_MWB_BLUE_GAIN_H			0x3404
+#define OV5693_MWB_GAIN_MAX				0x0fff
+
+#define OV5693_START_STREAMING			0x01
+#define OV5693_STOP_STREAMING			0x00
+
+#define VCM_ADDR           0x0c
+#define VCM_CODE_MSB       0x04
+
+#define OV5693_INVALID_CONFIG	0xffffffff
+
+#define OV5693_VCM_SLEW_STEP			0x30F0
+#define OV5693_VCM_SLEW_STEP_MAX		0x7
+#define OV5693_VCM_SLEW_STEP_MASK		0x7
+#define OV5693_VCM_CODE				0x30F2
+#define OV5693_VCM_SLEW_TIME			0x30F4
+#define OV5693_VCM_SLEW_TIME_MAX		0xffff
+#define OV5693_VCM_ENABLE			0x8000
+
+#define OV5693_VCM_MAX_FOCUS_NEG       -1023
+#define OV5693_VCM_MAX_FOCUS_POS       1023
+
+#define DLC_ENABLE 1
+#define DLC_DISABLE 0
+#define VCM_PROTECTION_OFF     0xeca3
+#define VCM_PROTECTION_ON      0xdc51
+#define VCM_DEFAULT_S 0x0
+#define vcm_step_s(a) (u8)(a & 0xf)
+#define vcm_step_mclk(a) (u8)((a >> 4) & 0x3)
+#define vcm_dlc_mclk(dlc, mclk) (u16)((dlc << 3) | mclk | 0xa104)
+#define vcm_tsrc(tsrc) (u16)(tsrc << 3 | 0xf200)
+#define vcm_val(data, s) (u16)(data << 4 | s)
+#define DIRECT_VCM vcm_dlc_mclk(0, 0)
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov5693_resolution {
+	u8 *desc;
+	const struct ov5693_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+};
+
+struct ov5693_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct ov5693_reg *regs;
+};
+
+struct ov5693_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+enum vcm_type {
+       VCM_UNKNOWN,
+       VCM_AD5823,
+       VCM_DW9714,
+};
+
+/*
+ * ov5693 device structure.
+ */
+struct ov5693_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	struct timespec timestamp_t_focus_abs;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u32 focus;
+	s16 number_of_steps;
+	u8 res;
+	u8 type;
+	bool vcm_update;
+	enum vcm_type vcm;
+};
+
+enum ov5693_tok_type {
+	OV5693_8BIT  = 0x0001,
+	OV5693_16BIT = 0x0002,
+	OV5693_32BIT = 0x0004,
+	OV5693_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	OV5693_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	OV5693_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct ov5693_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov5693_reg {
+	enum ov5693_tok_type type;
+	u16 reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_ov5693_sensor(x) container_of(x, struct ov5693_device, sd)
+
+#define OV5693_MAX_WRITE_BUF_SIZE	30
+
+struct ov5693_write_buffer {
+	u16 addr;
+	u8 data[OV5693_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov5693_write_ctrl {
+	int index;
+	struct ov5693_write_buffer buffer;
+};
+
+static const struct i2c_device_id ov5693_id[] = {
+	{OV5693_NAME, 0},
+	{}
+};
+
+static struct ov5693_reg const ov5693_global_setting[] = {
+	{OV5693_8BIT, 0x0103, 0x01},
+	{OV5693_8BIT, 0x3001, 0x0a},
+	{OV5693_8BIT, 0x3002, 0x80},
+	{OV5693_8BIT, 0x3006, 0x00},
+	{OV5693_8BIT, 0x3011, 0x21},
+	{OV5693_8BIT, 0x3012, 0x09},
+	{OV5693_8BIT, 0x3013, 0x10},
+	{OV5693_8BIT, 0x3014, 0x00},
+	{OV5693_8BIT, 0x3015, 0x08},
+	{OV5693_8BIT, 0x3016, 0xf0},
+	{OV5693_8BIT, 0x3017, 0xf0},
+	{OV5693_8BIT, 0x3018, 0xf0},
+	{OV5693_8BIT, 0x301b, 0xb4},
+	{OV5693_8BIT, 0x301d, 0x02},
+	{OV5693_8BIT, 0x3021, 0x00},
+	{OV5693_8BIT, 0x3022, 0x01},
+	{OV5693_8BIT, 0x3028, 0x44},
+	{OV5693_8BIT, 0x3098, 0x02},
+	{OV5693_8BIT, 0x3099, 0x19},
+	{OV5693_8BIT, 0x309a, 0x02},
+	{OV5693_8BIT, 0x309b, 0x01},
+	{OV5693_8BIT, 0x309c, 0x00},
+	{OV5693_8BIT, 0x30a0, 0xd2},
+	{OV5693_8BIT, 0x30a2, 0x01},
+	{OV5693_8BIT, 0x30b2, 0x00},
+	{OV5693_8BIT, 0x30b3, 0x7d},
+	{OV5693_8BIT, 0x30b4, 0x03},
+	{OV5693_8BIT, 0x30b5, 0x04},
+	{OV5693_8BIT, 0x30b6, 0x01},
+	{OV5693_8BIT, 0x3104, 0x21},
+	{OV5693_8BIT, 0x3106, 0x00},
+	{OV5693_8BIT, 0x3400, 0x04},
+	{OV5693_8BIT, 0x3401, 0x00},
+	{OV5693_8BIT, 0x3402, 0x04},
+	{OV5693_8BIT, 0x3403, 0x00},
+	{OV5693_8BIT, 0x3404, 0x04},
+	{OV5693_8BIT, 0x3405, 0x00},
+	{OV5693_8BIT, 0x3406, 0x01},
+	{OV5693_8BIT, 0x3500, 0x00},
+	{OV5693_8BIT, 0x3503, 0x07},
+	{OV5693_8BIT, 0x3504, 0x00},
+	{OV5693_8BIT, 0x3505, 0x00},
+	{OV5693_8BIT, 0x3506, 0x00},
+	{OV5693_8BIT, 0x3507, 0x02},
+	{OV5693_8BIT, 0x3508, 0x00},
+	{OV5693_8BIT, 0x3509, 0x10},
+	{OV5693_8BIT, 0x350a, 0x00},
+	{OV5693_8BIT, 0x350b, 0x40},
+	{OV5693_8BIT, 0x3601, 0x0a},
+	{OV5693_8BIT, 0x3602, 0x38},
+	{OV5693_8BIT, 0x3612, 0x80},
+	{OV5693_8BIT, 0x3620, 0x54},
+	{OV5693_8BIT, 0x3621, 0xc7},
+	{OV5693_8BIT, 0x3622, 0x0f},
+	{OV5693_8BIT, 0x3625, 0x10},
+	{OV5693_8BIT, 0x3630, 0x55},
+	{OV5693_8BIT, 0x3631, 0xf4},
+	{OV5693_8BIT, 0x3632, 0x00},
+	{OV5693_8BIT, 0x3633, 0x34},
+	{OV5693_8BIT, 0x3634, 0x02},
+	{OV5693_8BIT, 0x364d, 0x0d},
+	{OV5693_8BIT, 0x364f, 0xdd},
+	{OV5693_8BIT, 0x3660, 0x04},
+	{OV5693_8BIT, 0x3662, 0x10},
+	{OV5693_8BIT, 0x3663, 0xf1},
+	{OV5693_8BIT, 0x3665, 0x00},
+	{OV5693_8BIT, 0x3666, 0x20},
+	{OV5693_8BIT, 0x3667, 0x00},
+	{OV5693_8BIT, 0x366a, 0x80},
+	{OV5693_8BIT, 0x3680, 0xe0},
+	{OV5693_8BIT, 0x3681, 0x00},
+	{OV5693_8BIT, 0x3700, 0x42},
+	{OV5693_8BIT, 0x3701, 0x14},
+	{OV5693_8BIT, 0x3702, 0xa0},
+	{OV5693_8BIT, 0x3703, 0xd8},
+	{OV5693_8BIT, 0x3704, 0x78},
+	{OV5693_8BIT, 0x3705, 0x02},
+	{OV5693_8BIT, 0x370a, 0x00},
+	{OV5693_8BIT, 0x370b, 0x20},
+	{OV5693_8BIT, 0x370c, 0x0c},
+	{OV5693_8BIT, 0x370d, 0x11},
+	{OV5693_8BIT, 0x370e, 0x00},
+	{OV5693_8BIT, 0x370f, 0x40},
+	{OV5693_8BIT, 0x3710, 0x00},
+	{OV5693_8BIT, 0x371a, 0x1c},
+	{OV5693_8BIT, 0x371b, 0x05},
+	{OV5693_8BIT, 0x371c, 0x01},
+	{OV5693_8BIT, 0x371e, 0xa1},
+	{OV5693_8BIT, 0x371f, 0x0c},
+	{OV5693_8BIT, 0x3721, 0x00},
+	{OV5693_8BIT, 0x3724, 0x10},
+	{OV5693_8BIT, 0x3726, 0x00},
+	{OV5693_8BIT, 0x372a, 0x01},
+	{OV5693_8BIT, 0x3730, 0x10},
+	{OV5693_8BIT, 0x3738, 0x22},
+	{OV5693_8BIT, 0x3739, 0xe5},
+	{OV5693_8BIT, 0x373a, 0x50},
+	{OV5693_8BIT, 0x373b, 0x02},
+	{OV5693_8BIT, 0x373c, 0x41},
+	{OV5693_8BIT, 0x373f, 0x02},
+	{OV5693_8BIT, 0x3740, 0x42},
+	{OV5693_8BIT, 0x3741, 0x02},
+	{OV5693_8BIT, 0x3742, 0x18},
+	{OV5693_8BIT, 0x3743, 0x01},
+	{OV5693_8BIT, 0x3744, 0x02},
+	{OV5693_8BIT, 0x3747, 0x10},
+	{OV5693_8BIT, 0x374c, 0x04},
+	{OV5693_8BIT, 0x3751, 0xf0},
+	{OV5693_8BIT, 0x3752, 0x00},
+	{OV5693_8BIT, 0x3753, 0x00},
+	{OV5693_8BIT, 0x3754, 0xc0},
+	{OV5693_8BIT, 0x3755, 0x00},
+	{OV5693_8BIT, 0x3756, 0x1a},
+	{OV5693_8BIT, 0x3758, 0x00},
+	{OV5693_8BIT, 0x3759, 0x0f},
+	{OV5693_8BIT, 0x376b, 0x44},
+	{OV5693_8BIT, 0x375c, 0x04},
+	{OV5693_8BIT, 0x3774, 0x10},
+	{OV5693_8BIT, 0x3776, 0x00},
+	{OV5693_8BIT, 0x377f, 0x08},
+	{OV5693_8BIT, 0x3780, 0x22},
+	{OV5693_8BIT, 0x3781, 0x0c},
+	{OV5693_8BIT, 0x3784, 0x2c},
+	{OV5693_8BIT, 0x3785, 0x1e},
+	{OV5693_8BIT, 0x378f, 0xf5},
+	{OV5693_8BIT, 0x3791, 0xb0},
+	{OV5693_8BIT, 0x3795, 0x00},
+	{OV5693_8BIT, 0x3796, 0x64},
+	{OV5693_8BIT, 0x3797, 0x11},
+	{OV5693_8BIT, 0x3798, 0x30},
+	{OV5693_8BIT, 0x3799, 0x41},
+	{OV5693_8BIT, 0x379a, 0x07},
+	{OV5693_8BIT, 0x379b, 0xb0},
+	{OV5693_8BIT, 0x379c, 0x0c},
+	{OV5693_8BIT, 0x37c5, 0x00},
+	{OV5693_8BIT, 0x37c6, 0x00},
+	{OV5693_8BIT, 0x37c7, 0x00},
+	{OV5693_8BIT, 0x37c9, 0x00},
+	{OV5693_8BIT, 0x37ca, 0x00},
+	{OV5693_8BIT, 0x37cb, 0x00},
+	{OV5693_8BIT, 0x37de, 0x00},
+	{OV5693_8BIT, 0x37df, 0x00},
+	{OV5693_8BIT, 0x3800, 0x00},
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},
+	{OV5693_8BIT, 0x3804, 0x0a},
+	{OV5693_8BIT, 0x3805, 0x3f},
+	{OV5693_8BIT, 0x3810, 0x00},
+	{OV5693_8BIT, 0x3812, 0x00},
+	{OV5693_8BIT, 0x3823, 0x00},
+	{OV5693_8BIT, 0x3824, 0x00},
+	{OV5693_8BIT, 0x3825, 0x00},
+	{OV5693_8BIT, 0x3826, 0x00},
+	{OV5693_8BIT, 0x3827, 0x00},
+	{OV5693_8BIT, 0x382a, 0x04},
+	{OV5693_8BIT, 0x3a04, 0x06},
+	{OV5693_8BIT, 0x3a05, 0x14},
+	{OV5693_8BIT, 0x3a06, 0x00},
+	{OV5693_8BIT, 0x3a07, 0xfe},
+	{OV5693_8BIT, 0x3b00, 0x00},
+	{OV5693_8BIT, 0x3b02, 0x00},
+	{OV5693_8BIT, 0x3b03, 0x00},
+	{OV5693_8BIT, 0x3b04, 0x00},
+	{OV5693_8BIT, 0x3b05, 0x00},
+	{OV5693_8BIT, 0x3e07, 0x20},
+	{OV5693_8BIT, 0x4000, 0x08},
+	{OV5693_8BIT, 0x4001, 0x04},
+	{OV5693_8BIT, 0x4002, 0x45},
+	{OV5693_8BIT, 0x4004, 0x08},
+	{OV5693_8BIT, 0x4005, 0x18},
+	{OV5693_8BIT, 0x4006, 0x20},
+	{OV5693_8BIT, 0x4008, 0x24},
+	{OV5693_8BIT, 0x4009, 0x10},
+	{OV5693_8BIT, 0x400c, 0x00},
+	{OV5693_8BIT, 0x400d, 0x00},
+	{OV5693_8BIT, 0x4058, 0x00},
+	{OV5693_8BIT, 0x404e, 0x37},
+	{OV5693_8BIT, 0x404f, 0x8f},
+	{OV5693_8BIT, 0x4058, 0x00},
+	{OV5693_8BIT, 0x4101, 0xb2},
+	{OV5693_8BIT, 0x4303, 0x00},
+	{OV5693_8BIT, 0x4304, 0x08},
+	{OV5693_8BIT, 0x4307, 0x31},
+	{OV5693_8BIT, 0x4311, 0x04},
+	{OV5693_8BIT, 0x4315, 0x01},
+	{OV5693_8BIT, 0x4511, 0x05},
+	{OV5693_8BIT, 0x4512, 0x01},
+	{OV5693_8BIT, 0x4806, 0x00},
+	{OV5693_8BIT, 0x4816, 0x52},
+	{OV5693_8BIT, 0x481f, 0x30},
+	{OV5693_8BIT, 0x4826, 0x2c},
+	{OV5693_8BIT, 0x4831, 0x64},
+	{OV5693_8BIT, 0x4d00, 0x04},
+	{OV5693_8BIT, 0x4d01, 0x71},
+	{OV5693_8BIT, 0x4d02, 0xfd},
+	{OV5693_8BIT, 0x4d03, 0xf5},
+	{OV5693_8BIT, 0x4d04, 0x0c},
+	{OV5693_8BIT, 0x4d05, 0xcc},
+	{OV5693_8BIT, 0x4837, 0x0a},
+	{OV5693_8BIT, 0x5000, 0x06},
+	{OV5693_8BIT, 0x5001, 0x01},
+	{OV5693_8BIT, 0x5003, 0x20},
+	{OV5693_8BIT, 0x5046, 0x0a},
+	{OV5693_8BIT, 0x5013, 0x00},
+	{OV5693_8BIT, 0x5046, 0x0a},
+	{OV5693_8BIT, 0x5780, 0x1c},
+	{OV5693_8BIT, 0x5786, 0x20},
+	{OV5693_8BIT, 0x5787, 0x10},
+	{OV5693_8BIT, 0x5788, 0x18},
+	{OV5693_8BIT, 0x578a, 0x04},
+	{OV5693_8BIT, 0x578b, 0x02},
+	{OV5693_8BIT, 0x578c, 0x02},
+	{OV5693_8BIT, 0x578e, 0x06},
+	{OV5693_8BIT, 0x578f, 0x02},
+	{OV5693_8BIT, 0x5790, 0x02},
+	{OV5693_8BIT, 0x5791, 0xff},
+	{OV5693_8BIT, 0x5842, 0x01},
+	{OV5693_8BIT, 0x5843, 0x2b},
+	{OV5693_8BIT, 0x5844, 0x01},
+	{OV5693_8BIT, 0x5845, 0x92},
+	{OV5693_8BIT, 0x5846, 0x01},
+	{OV5693_8BIT, 0x5847, 0x8f},
+	{OV5693_8BIT, 0x5848, 0x01},
+	{OV5693_8BIT, 0x5849, 0x0c},
+	{OV5693_8BIT, 0x5e00, 0x00},
+	{OV5693_8BIT, 0x5e10, 0x0c},
+	{OV5693_8BIT, 0x0100, 0x00},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+ * 654x496 30fps 17ms VBlanking 2lane 10Bit (Scaling)
+ */
+static struct ov5693_reg const ov5693_654x496[] = {
+	{OV5693_8BIT, 0x3501, 0x3d},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe6},
+	{OV5693_8BIT, 0x3709, 0xc7},
+	{OV5693_8BIT, 0x3803, 0x00},
+	{OV5693_8BIT, 0x3806, 0x07},
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x02},
+	{OV5693_8BIT, 0x3809, 0x90},
+	{OV5693_8BIT, 0x380a, 0x01},
+	{OV5693_8BIT, 0x380b, 0xf0},
+	{OV5693_8BIT, 0x380c, 0x0a},
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3811, 0x08},
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x31},
+	{OV5693_8BIT, 0x3815, 0x31},
+	{OV5693_8BIT, 0x3820, 0x04},
+	{OV5693_8BIT, 0x3821, 0x1f},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+static struct ov5693_reg const ov5693_736x496[] = {
+	{OV5693_8BIT, 0x3501, 0x3d},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe6},
+	{OV5693_8BIT, 0x3709, 0xc7},
+	{OV5693_8BIT, 0x3803, 0x68},
+	{OV5693_8BIT, 0x3806, 0x07},
+	{OV5693_8BIT, 0x3807, 0x3b},
+	{OV5693_8BIT, 0x3808, 0x02},
+	{OV5693_8BIT, 0x3809, 0xe0},
+	{OV5693_8BIT, 0x380a, 0x01},
+	{OV5693_8BIT, 0x380b, 0xf0},
+	{OV5693_8BIT, 0x380c, 0x0a}, //hts
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07}, //vts
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3811, 0x08},
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x31},
+	{OV5693_8BIT, 0x3815, 0x31},
+	{OV5693_8BIT, 0x3820, 0x04},
+	{OV5693_8BIT, 0x3821, 0x1f},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+static struct ov5693_reg const ov5693_736x496[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe6},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3803, 0x00},
+	{OV5693_8BIT, 0x3806, 0x07},
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x02},
+	{OV5693_8BIT, 0x3809, 0xe0},
+	{OV5693_8BIT, 0x380a, 0x01},
+	{OV5693_8BIT, 0x380b, 0xf0},
+	{OV5693_8BIT, 0x380c, 0x0d}, //hts
+	{OV5693_8BIT, 0x380d, 0xb0},
+	{OV5693_8BIT, 0x380e, 0x05}, //vts
+	{OV5693_8BIT, 0x380f, 0xf2},
+	{OV5693_8BIT, 0x3811, 0x08},
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x31},
+	{OV5693_8BIT, 0x3815, 0x31},
+	{OV5693_8BIT, 0x3820, 0x01},
+	{OV5693_8BIT, 0x3821, 0x1f},
+	{OV5693_8BIT, 0x5002, 0x00},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+*/
+/*
+ * 976x556 30fps 8.8ms VBlanking 2lane 10Bit (Scaling)
+ */
+static struct ov5693_reg const ov5693_976x556[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3803, 0xf0},
+	{OV5693_8BIT, 0x3806, 0x06},
+	{OV5693_8BIT, 0x3807, 0xa7},
+	{OV5693_8BIT, 0x3808, 0x03},
+	{OV5693_8BIT, 0x3809, 0xd0},
+	{OV5693_8BIT, 0x380a, 0x02},
+	{OV5693_8BIT, 0x380b, 0x2C},
+	{OV5693_8BIT, 0x380c, 0x0a},
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3811, 0x10},
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x11},
+	{OV5693_8BIT, 0x3815, 0x11},
+	{OV5693_8BIT, 0x3820, 0x00},
+	{OV5693_8BIT, 0x3821, 0x1e},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+static struct ov5693_reg const ov5693_1296x736[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe6},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3803, 0x00},
+	{OV5693_8BIT, 0x3806, 0x07},
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x05},
+	{OV5693_8BIT, 0x3809, 0x10},
+	{OV5693_8BIT, 0x380a, 0x02},
+	{OV5693_8BIT, 0x380b, 0xe0},
+	{OV5693_8BIT, 0x380c, 0x0d}, //hts
+	{OV5693_8BIT, 0x380d, 0xb0},
+	{OV5693_8BIT, 0x380e, 0x05}, //vts
+	{OV5693_8BIT, 0x380f, 0xf2},
+	{OV5693_8BIT, 0x3811, 0x08},
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x31},
+	{OV5693_8BIT, 0x3815, 0x31},
+	{OV5693_8BIT, 0x3820, 0x01},
+	{OV5693_8BIT, 0x3821, 0x1f},
+	{OV5693_8BIT, 0x5002, 0x00},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+static struct ov5693_reg const ov5693_1636p_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3803, 0xf0},
+	{OV5693_8BIT, 0x3806, 0x06},
+	{OV5693_8BIT, 0x3807, 0xa7},
+	{OV5693_8BIT, 0x3808, 0x06},
+	{OV5693_8BIT, 0x3809, 0x64},
+	{OV5693_8BIT, 0x380a, 0x04},
+	{OV5693_8BIT, 0x380b, 0x48},
+	{OV5693_8BIT, 0x380c, 0x0a}, //hts
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07}, //vts
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3811, 0x02},
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x11},
+	{OV5693_8BIT, 0x3815, 0x11},
+	{OV5693_8BIT, 0x3820, 0x00},
+	{OV5693_8BIT, 0x3821, 0x1e},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+static struct ov5693_reg const ov5693_1616x1216_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x80},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3800, 0x00},	/*{3800,3801} Array X start*/
+	{OV5693_8BIT, 0x3801, 0x08},	/* 04 //{3800,3801} Array X start*/
+	{OV5693_8BIT, 0x3802, 0x00},	/*{3802,3803} Array Y start*/
+	{OV5693_8BIT, 0x3803, 0x04},	/* 00  //{3802,3803} Array Y start*/
+	{OV5693_8BIT, 0x3804, 0x0a},	/*{3804,3805} Array X end*/
+	{OV5693_8BIT, 0x3805, 0x37},	/* 3b  //{3804,3805} Array X end*/
+	{OV5693_8BIT, 0x3806, 0x07},	/*{3806,3807} Array Y end*/
+	{OV5693_8BIT, 0x3807, 0x9f},	/* a3  //{3806,3807} Array Y end*/
+	{OV5693_8BIT, 0x3808, 0x06},	/*{3808,3809} Final output H size*/
+	{OV5693_8BIT, 0x3809, 0x50},	/*{3808,3809} Final output H size*/
+	{OV5693_8BIT, 0x380a, 0x04},	/*{380a,380b} Final output V size*/
+	{OV5693_8BIT, 0x380b, 0xc0},	/*{380a,380b} Final output V size*/
+	{OV5693_8BIT, 0x380c, 0x0a},	/*{380c,380d} HTS*/
+	{OV5693_8BIT, 0x380d, 0x80},	/*{380c,380d} HTS*/
+	{OV5693_8BIT, 0x380e, 0x07},	/*{380e,380f} VTS*/
+	{OV5693_8BIT, 0x380f, 0xc0},	/* bc	//{380e,380f} VTS*/
+	{OV5693_8BIT, 0x3810, 0x00},	/*{3810,3811} windowing X offset*/
+	{OV5693_8BIT, 0x3811, 0x10},	/*{3810,3811} windowing X offset*/
+	{OV5693_8BIT, 0x3812, 0x00},	/*{3812,3813} windowing Y offset*/
+	{OV5693_8BIT, 0x3813, 0x06},	/*{3812,3813} windowing Y offset*/
+	{OV5693_8BIT, 0x3814, 0x11},	/*X subsample control*/
+	{OV5693_8BIT, 0x3815, 0x11},	/*Y subsample control*/
+	{OV5693_8BIT, 0x3820, 0x00},	/*FLIP/Binnning control*/
+	{OV5693_8BIT, 0x3821, 0x1e},	/*MIRROR control*/
+	{OV5693_8BIT, 0x5002, 0x00},
+	{OV5693_8BIT, 0x5041, 0x84},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+
+/*
+ * 1940x1096 30fps 8.8ms VBlanking 2lane 10bit (Scaling)
+ */
+static struct ov5693_reg const ov5693_1940x1096[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3803, 0xf0},
+	{OV5693_8BIT, 0x3806, 0x06},
+	{OV5693_8BIT, 0x3807, 0xa7},
+	{OV5693_8BIT, 0x3808, 0x07},
+	{OV5693_8BIT, 0x3809, 0x94},
+	{OV5693_8BIT, 0x380a, 0x04},
+	{OV5693_8BIT, 0x380b, 0x48},
+	{OV5693_8BIT, 0x380c, 0x0a},
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3811, 0x02},
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x11},
+	{OV5693_8BIT, 0x3815, 0x11},
+	{OV5693_8BIT, 0x3820, 0x00},
+	{OV5693_8BIT, 0x3821, 0x1e},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+static struct ov5693_reg const ov5693_2592x1456_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3800, 0x00},
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},
+	{OV5693_8BIT, 0x3803, 0xf0},
+	{OV5693_8BIT, 0x3804, 0x0a},
+	{OV5693_8BIT, 0x3805, 0x3f},
+	{OV5693_8BIT, 0x3806, 0x06},
+	{OV5693_8BIT, 0x3807, 0xa4},
+	{OV5693_8BIT, 0x3808, 0x0a},
+	{OV5693_8BIT, 0x3809, 0x20},
+	{OV5693_8BIT, 0x380a, 0x05},
+	{OV5693_8BIT, 0x380b, 0xb0},
+	{OV5693_8BIT, 0x380c, 0x0a},
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3811, 0x10},
+	{OV5693_8BIT, 0x3813, 0x00},
+	{OV5693_8BIT, 0x3814, 0x11},
+	{OV5693_8BIT, 0x3815, 0x11},
+	{OV5693_8BIT, 0x3820, 0x00},
+	{OV5693_8BIT, 0x3821, 0x1e},
+	{OV5693_8BIT, 0x5002, 0x00},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+ * 2592x1944 30fps 0.6ms VBlanking 2lane 10Bit
+ */
+static struct ov5693_reg const ov5693_2592x1944_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3803, 0x00},
+	{OV5693_8BIT, 0x3806, 0x07},
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x0a},
+	{OV5693_8BIT, 0x3809, 0x20},
+	{OV5693_8BIT, 0x380a, 0x07},
+	{OV5693_8BIT, 0x380b, 0x98},
+	{OV5693_8BIT, 0x380c, 0x0a},
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3811, 0x10},
+	{OV5693_8BIT, 0x3813, 0x00},
+	{OV5693_8BIT, 0x3814, 0x11},
+	{OV5693_8BIT, 0x3815, 0x11},
+	{OV5693_8BIT, 0x3820, 0x00},
+	{OV5693_8BIT, 0x3821, 0x1e},
+	{OV5693_8BIT, 0x5002, 0x00},
+	{OV5693_8BIT, 0x0100, 0x01},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+struct ov5693_resolution ov5693_res_preview[] = {
+	{
+		.desc = "ov5693_1616x1216_30fps",
+		.width = 1616,
+		.height = 1216,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_1616x1216_30fps,
+	},
+	{
+		.desc = "ov5693_5M_30fps",
+		.width = 2592,
+		.height = 1456,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_2592x1456_30fps,
+	},
+	{
+		.desc = "ov5693_5M_30fps",
+		.width = 2592,
+		.height = 1944,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_2592x1944_30fps,
+	},
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(ov5693_res_preview))
+
+struct ov5693_resolution ov5693_res_still[] = {
+	{
+		.desc = "ov5693_1616x1216_30fps",
+		.width = 1616,
+		.height = 1216,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_1616x1216_30fps,
+	},
+	{
+		.desc = "ov5693_5M_30fps",
+		.width = 2592,
+		.height = 1456,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_2592x1456_30fps,
+	},
+	{
+		.desc = "ov5693_5M_30fps",
+		.width = 2592,
+		.height = 1944,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_2592x1944_30fps,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(ov5693_res_still))
+
+struct ov5693_resolution ov5693_res_video[] = {
+	{
+		.desc = "ov5693_736x496_30fps",
+		.width = 736,
+		.height = 496,
+		.fps = 30,
+		.pix_clk_freq = 160,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.bin_mode = 1,
+		.regs = ov5693_736x496,
+	},
+	{
+		.desc = "ov5693_1296x736_30fps",
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pix_clk_freq = 160,
+		.used = 0,
+		.pixels_per_line = 3504,
+		.lines_per_frame = 1522,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.bin_mode = 1,
+		.regs = ov5693_1296x736,
+	},
+	{
+		.desc = "ov5693_1636P_30fps",
+		.width = 1636,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 160,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_1636p_30fps,
+	},
+	{
+		.desc = "ov5693_1080P_30fps",
+		.width = 1940,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 160,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_1940x1096,
+	},
+	{
+		.desc = "ov5693_5M_30fps",
+		.width = 2592,
+		.height = 1456,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_2592x1456_30fps,
+	},
+	{
+		.desc = "ov5693_5M_30fps",
+		.width = 2592,
+		.height = 1944,
+		.pix_clk_freq = 160,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.regs = ov5693_2592x1944_30fps,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(ov5693_res_video))
+
+static struct ov5693_resolution *ov5693_res = ov5693_res_preview;
+static int N_RES = N_RES_PREVIEW;
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693.c
deleted file mode 100755
index 5f4ed2d..0000000
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693.c
+++ /dev/null
@@ -1,1893 +0,0 @@
-/*
- * Support for OmniVision OV5693 1080p HD camera sensor.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/kmod.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
-#include <linux/gpio.h>
-#include <linux/moduleparam.h>
-#include <media/v4l2-device.h>
-#include <linux/io.h>
-#include <linux/acpi.h>
-#include <linux/atomisp_gmin_platform.h>
-
-#include "ov5693.h"
-
-/* Focus for the AD5823 should start in the middle of the field */
-#define INIT_FOCUS_POS 350
-
-static int vcm_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)
-{
-	int err;
-	struct i2c_msg msg;
-	u8 buf[2];
-
-	buf[0] = reg;
-	buf[1] = val;
-
-	msg.addr = VCM_ADDR;
-	msg.flags = 0;
-	msg.len = 2;
-	msg.buf = &buf[0];
-
-	err = i2c_transfer(client->adapter, &msg, 1);
-	if (err != 1) {
-		dev_err(&client->dev, "%s: main camera vcm i2c fail, err code = %d\n",
-			__func__, err);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int vcm_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
-{
-	int err;
-	struct i2c_msg msg;
-	u8 buf[3];
-	buf[0] = reg;
-	buf[1] = (u8)(val >> 8);
-	buf[2] = (u8)(val & 0xff);
-	msg.addr = VCM_ADDR;
-	msg.flags = 0;
-	msg.len = 3;
-	msg.buf = &buf[0];
-
-	err = i2c_transfer(client->adapter, &msg, 1);
-	if (err != 1) {
-		dev_err(&client->dev, "%s: main camera vcm i2c fail, err code = %d\n",
-			__func__, err);
-		return -EIO;
-	}
-	return 0;
-}
-
-static const uint32_t ov5693_embedded_effective_size = 28;
-
-/* i2c read/write stuff */
-static int ov5693_read_reg(struct i2c_client *client,
-			   u16 data_length, u16 reg, u16 *val)
-{
-	int err;
-	struct i2c_msg msg[2];
-	unsigned char data[6];
-
-	if (!client->adapter) {
-		dev_err(&client->dev, "%s error, no client->adapter\n",
-			__func__);
-		return -ENODEV;
-	}
-
-	if (data_length != OV5693_8BIT && data_length != OV5693_16BIT
-					&& data_length != OV5693_32BIT) {
-		dev_err(&client->dev, "%s error, invalid data length\n",
-			__func__);
-		return -EINVAL;
-	}
-
-	memset(msg, 0 , sizeof(msg));
-
-	msg[0].addr = client->addr;
-	msg[0].flags = 0;
-	msg[0].len = I2C_MSG_LENGTH;
-	msg[0].buf = data;
-
-	/* high byte goes out first */
-	data[0] = (u8)(reg >> 8);
-	data[1] = (u8)(reg & 0xff);
-
-	msg[1].addr = client->addr;
-	msg[1].len = data_length;
-	msg[1].flags = I2C_M_RD;
-	msg[1].buf = data;
-
-	err = i2c_transfer(client->adapter, msg, 2);
-	if (err != 2) {
-		if (err >= 0)
-			err = -EIO;
-		dev_err(&client->dev,
-			"read from offset 0x%x error %d", reg, err);
-		return err;
-	}
-
-	*val = 0;
-	/* high byte comes first */
-	if (data_length == OV5693_8BIT)
-		*val = (u8)data[0];
-	else if (data_length == OV5693_16BIT)
-		*val = be16_to_cpu(*(u16 *)&data[0]);
-	else
-		*val = be32_to_cpu(*(u32 *)&data[0]);
-
-	return 0;
-}
-
-static int ov5693_i2c_write(struct i2c_client *client, u16 len, u8 *data)
-{
-	struct i2c_msg msg;
-	const int num_msg = 1;
-	int ret;
-
-	msg.addr = client->addr;
-	msg.flags = 0;
-	msg.len = len;
-	msg.buf = data;
-	ret = i2c_transfer(client->adapter, &msg, 1);
-
-	return ret == num_msg ? 0 : -EIO;
-}
-
-static int ov5693_write_reg(struct i2c_client *client, u16 data_length,
-							u16 reg, u16 val)
-{
-	int ret;
-	unsigned char data[4] = {0};
-	u16 *wreg = (u16 *)data;
-	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
-
-	if (data_length != OV5693_8BIT && data_length != OV5693_16BIT) {
-		dev_err(&client->dev,
-			"%s error, invalid data_length\n", __func__);
-		return -EINVAL;
-	}
-
-	/* high byte goes out first */
-	*wreg = cpu_to_be16(reg);
-
-	if (data_length == OV5693_8BIT) {
-		data[2] = (u8)(val);
-	} else {
-		/* OV5693_16BIT */
-		u16 *wdata = (u16 *)&data[2];
-		*wdata = cpu_to_be16(val);
-	}
-
-	ret = ov5693_i2c_write(client, len, data);
-	if (ret)
-		dev_err(&client->dev,
-			"write error: wrote 0x%x to offset 0x%x error %d",
-			val, reg, ret);
-
-	return ret;
-}
-
-/*
- * ov5693_write_reg_array - Initializes a list of OV5693 registers
- * @client: i2c driver client structure
- * @reglist: list of registers to be written
- *
- * This function initializes a list of registers. When consecutive addresses
- * are found in a row on the list, this function creates a buffer and sends
- * consecutive data in a single i2c_transfer().
- *
- * __ov5693_flush_reg_array, __ov5693_buf_reg_array() and
- * __ov5693_write_reg_is_consecutive() are internal functions to
- * ov5693_write_reg_array_fast() and should be not used anywhere else.
- *
- */
-
-static int __ov5693_flush_reg_array(struct i2c_client *client,
-				    struct ov5693_write_ctrl *ctrl)
-{
-	u16 size;
-
-	if (ctrl->index == 0)
-		return 0;
-
-	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
-	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
-	ctrl->index = 0;
-
-	return ov5693_i2c_write(client, size, (u8 *)&ctrl->buffer);
-}
-
-static int __ov5693_buf_reg_array(struct i2c_client *client,
-				  struct ov5693_write_ctrl *ctrl,
-				  const struct ov5693_reg *next)
-{
-	int size;
-	u16 *data16;
-
-	switch (next->type) {
-	case OV5693_8BIT:
-		size = 1;
-		ctrl->buffer.data[ctrl->index] = (u8)next->val;
-		break;
-	case OV5693_16BIT:
-		size = 2;
-		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
-		*data16 = cpu_to_be16((u16)next->val);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* When first item is added, we need to store its starting address */
-	if (ctrl->index == 0)
-		ctrl->buffer.addr = next->reg;
-
-	ctrl->index += size;
-
-	/*
-	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
-	 * possible lack of memory for next item.
-	 */
-	if (ctrl->index + sizeof(u16) >= OV5693_MAX_WRITE_BUF_SIZE)
-		return __ov5693_flush_reg_array(client, ctrl);
-
-	return 0;
-}
-
-static int __ov5693_write_reg_is_consecutive(struct i2c_client *client,
-					     struct ov5693_write_ctrl *ctrl,
-					     const struct ov5693_reg *next)
-{
-	if (ctrl->index == 0)
-		return 1;
-
-	return ctrl->buffer.addr + ctrl->index == next->reg;
-}
-
-static int ov5693_write_reg_array(struct i2c_client *client,
-				  const struct ov5693_reg *reglist)
-{
-	const struct ov5693_reg *next = reglist;
-	struct ov5693_write_ctrl ctrl;
-	int err;
-
-	ctrl.index = 0;
-	for (; next->type != OV5693_TOK_TERM; next++) {
-		switch (next->type & OV5693_TOK_MASK) {
-		case OV5693_TOK_DELAY:
-			err = __ov5693_flush_reg_array(client, &ctrl);
-			if (err)
-				return err;
-			msleep(next->val);
-			break;
-		default:
-			/*
-			 * If next address is not consecutive, data needs to be
-			 * flushed before proceed.
-			 */
-			if (!__ov5693_write_reg_is_consecutive(client, &ctrl,
-								next)) {
-				err = __ov5693_flush_reg_array(client, &ctrl);
-			if (err)
-				return err;
-			}
-			err = __ov5693_buf_reg_array(client, &ctrl, next);
-			if (err) {
-				dev_err(&client->dev, "%s: write error, aborted\n",
-					 __func__);
-				return err;
-			}
-			break;
-		}
-	}
-
-	return __ov5693_flush_reg_array(client, &ctrl);
-}
-static int ov5693_g_focal(struct v4l2_subdev *sd, s32 *val)
-{
-	*val = (OV5693_FOCAL_LENGTH_NUM << 16) | OV5693_FOCAL_LENGTH_DEM;
-	return 0;
-}
-
-static int ov5693_g_fnumber(struct v4l2_subdev *sd, s32 *val)
-{
-	/*const f number for imx*/
-	*val = (OV5693_F_NUMBER_DEFAULT_NUM << 16) | OV5693_F_NUMBER_DEM;
-	return 0;
-}
-
-static int ov5693_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
-{
-	*val = (OV5693_F_NUMBER_DEFAULT_NUM << 24) |
-		(OV5693_F_NUMBER_DEM << 16) |
-		(OV5693_F_NUMBER_DEFAULT_NUM << 8) | OV5693_F_NUMBER_DEM;
-	return 0;
-}
-
-static int ov5693_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-
-	*val = ov5693_res[dev->fmt_idx].bin_factor_x;
-
-	return 0;
-}
-
-static int ov5693_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-
-	*val = ov5693_res[dev->fmt_idx].bin_factor_y;
-
-	return 0;
-}
-
-static int ov5693_get_intg_factor(struct i2c_client *client,
-				struct camera_mipi_info *info,
-				const struct ov5693_resolution *res)
-{
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct atomisp_sensor_mode_data *buf = &info->data;
-	unsigned int pix_clk_freq_hz;
-	u16 reg_val;
-	int ret;
-
-	if (info == NULL)
-		return -EINVAL;
-
-	/* pixel clock */
-	pix_clk_freq_hz = res->pix_clk_freq * 1000000;
-
-	dev->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
-	buf->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
-
-	/* get integration time */
-	buf->coarse_integration_time_min = OV5693_COARSE_INTG_TIME_MIN;
-	buf->coarse_integration_time_max_margin =
-					OV5693_COARSE_INTG_TIME_MAX_MARGIN;
-
-	buf->fine_integration_time_min = OV5693_FINE_INTG_TIME_MIN;
-	buf->fine_integration_time_max_margin =
-					OV5693_FINE_INTG_TIME_MAX_MARGIN;
-
-	buf->fine_integration_time_def = OV5693_FINE_INTG_TIME_MIN;
-	buf->frame_length_lines = res->lines_per_frame;
-	buf->line_length_pck = res->pixels_per_line;
-	buf->read_mode = res->bin_mode;
-
-	/* get the cropping and output resolution to ISP for this mode. */
-	ret =  ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_HORIZONTAL_START_H, &reg_val);
-	if (ret)
-		return ret;
-	buf->crop_horizontal_start = reg_val;
-
-	ret =  ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_VERTICAL_START_H, &reg_val);
-	if (ret)
-		return ret;
-	buf->crop_vertical_start = reg_val;
-
-	ret = ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_HORIZONTAL_END_H, &reg_val);
-	if (ret)
-		return ret;
-	buf->crop_horizontal_end = reg_val;
-
-	ret = ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_VERTICAL_END_H, &reg_val);
-	if (ret)
-		return ret;
-	buf->crop_vertical_end = reg_val;
-
-	ret = ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_HORIZONTAL_OUTPUT_SIZE_H, &reg_val);
-	if (ret)
-		return ret;
-	buf->output_width = reg_val;
-
-	ret = ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_VERTICAL_OUTPUT_SIZE_H, &reg_val);
-	if (ret)
-		return ret;
-	buf->output_height = reg_val;
-
-	buf->binning_factor_x = res->bin_factor_x ?
-					res->bin_factor_x : 1;
-	buf->binning_factor_y = res->bin_factor_y ?
-					res->bin_factor_y : 1;
-	return 0;
-}
-
-static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
-				 int gain, int digitgain)
-
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	u16 vts,hts;
-	int ret,exp_val,max_itg;
-
-	hts = ov5693_res[dev->fmt_idx].pixels_per_line;
-	vts = ov5693_res[dev->fmt_idx].lines_per_frame;
-
-	max_itg = vts - OV5693_INTEGRATION_TIME_MARGIN;
-	if (coarse_itg > max_itg) {
-		if(dev->run_mode == CI_MODE_VIDEO) {
-			/* Don't reduce FPS in video mode */
-			coarse_itg = max_itg;
-		} else {
-			/* Increase the VTS to match exposure + MARGIN */
-			vts = (u16) coarse_itg + OV5693_INTEGRATION_TIME_MARGIN;
-		}
-	}
-
-	/* group hold */
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-                                       OV5693_GROUP_ACCESS, 0x00);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_GROUP_ACCESS);
-		return ret;
-	}
-
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_TIMING_VTS_H, (vts >> 8) & 0xFF);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_TIMING_VTS_H);
-		return ret;
-	}
-
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_TIMING_VTS_L, vts & 0xFF);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_TIMING_VTS_L);
-		return ret;
-	}
-
-	/* set exposure */
-
-	/* Lower four bit should be 0*/
-	exp_val = coarse_itg << 4;
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-			       OV5693_EXPOSURE_L, exp_val & 0xFF);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_EXPOSURE_L);
-		return ret;
-	}
-
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-			       OV5693_EXPOSURE_M, (exp_val >> 8) & 0xFF);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_EXPOSURE_M);
-		return ret;
-	}
-
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-			       OV5693_EXPOSURE_H, (exp_val >> 16) & 0x0F);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_EXPOSURE_H);
-		return ret;
-	}
-
-	/* Analog gain */
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_AGC_L, gain & 0xff);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_AGC_L);
-		return ret;
-	}
-
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_AGC_H, (gain >> 8) & 0xff);
-	if (ret) {
-		dev_err(&client->dev, "%s: write %x error, aborted\n",
-			__func__, OV5693_AGC_H);
-		return ret;
-	}
-
-	/* Digital gain */
-	if (digitgain) {
-		ret = ov5693_write_reg(client, OV5693_16BIT,
-				OV5693_MWB_RED_GAIN_H, digitgain);
-		if (ret) {
-			dev_err(&client->dev, "%s: write %x error, aborted\n",
-				__func__, OV5693_MWB_RED_GAIN_H);
-			return ret;
-		}
-
-		ret = ov5693_write_reg(client, OV5693_16BIT,
-				OV5693_MWB_GREEN_GAIN_H, digitgain);
-		if (ret) {
-			dev_err(&client->dev, "%s: write %x error, aborted\n",
-				__func__, OV5693_MWB_RED_GAIN_H);
-			return ret;
-		}
-
-		ret = ov5693_write_reg(client, OV5693_16BIT,
-				OV5693_MWB_BLUE_GAIN_H, digitgain);
-		if (ret) {
-			dev_err(&client->dev, "%s: write %x error, aborted\n",
-				__func__, OV5693_MWB_RED_GAIN_H);
-			return ret;
-		}
-	}
-
-	/* End group */
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-			       OV5693_GROUP_ACCESS, 0x10);
-	if (ret)
-		return ret;
-
-	/* Delay launch group */
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-					   OV5693_GROUP_ACCESS, 0xa0);
-	if (ret)
-		return ret;
-	return ret;
-}
-
-static int ov5693_set_exposure(struct v4l2_subdev *sd, int exposure,
-	int gain, int digitgain)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	int ret;
-
-	mutex_lock(&dev->input_lock);
-	ret = __ov5693_set_exposure(sd, exposure, gain, digitgain);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static long ov5693_s_exposure(struct v4l2_subdev *sd,
-			       struct atomisp_exposure *exposure)
-{
-	u16 coarse_itg = exposure->integration_time[0];
-	u16 analog_gain = exposure->gain[0];
-	u16 digital_gain = exposure->gain[1];
-
-	/* we should not accept the invalid value below */
-	if (analog_gain == 0) {
-		struct i2c_client *client = v4l2_get_subdevdata(sd);
-		v4l2_err(client, "%s: invalid value\n", __func__);
-		return -EINVAL;
-	}
-	return ov5693_set_exposure(sd, coarse_itg, analog_gain, digital_gain);
-}
-
-static int ov5693_read_otp_reg_array(struct i2c_client *client, u16 size,
-				     u16 addr, u8 * buf)
-{
-	u16 index;
-	int ret;
-	u16 *pVal = 0;
-
-	for (index = 0; index <= size; index++) {
-		pVal = (u16 *) (buf + index);
-		ret =
-			ov5693_read_reg(client, OV5693_8BIT, addr + index,
-				    pVal);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int __ov5693_otp_read(struct v4l2_subdev *sd, u8 * buf)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	int ret;
-	int i;
-	u8 *b = buf;
-	dev->otp_size = 0;
-	for (i = 1; i < OV5693_OTP_BANK_MAX; i++) {
-		/*set bank NO and OTP read mode. */
-		ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_OTP_BANK_REG, (i | 0xc0));	//[7:6] 2'b11 [5:0] bank no
-		if (ret) {
-			dev_err(&client->dev, "failed to prepare OTP page\n");
-			return ret;
-		}
-		//pr_debug("write 0x%x->0x%x\n",OV5693_OTP_BANK_REG,(i|0xc0));
-
-		/*enable read */
-		ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_OTP_READ_REG, OV5693_OTP_MODE_READ);	// enable :1
-		if (ret) {
-			dev_err(&client->dev,
-				"failed to set OTP reading mode page");
-			return ret;
-		}
-		//pr_debug("write 0x%x->0x%x\n",OV5693_OTP_READ_REG,OV5693_OTP_MODE_READ);
-
-		/* Reading the OTP data array */
-		ret = ov5693_read_otp_reg_array(client, OV5693_OTP_BANK_SIZE,
-						OV5693_OTP_START_ADDR,
-						b);
-		if (ret) {
-			dev_err(&client->dev, "failed to read OTP data\n");
-			return ret;
-		}
-
-		//pr_debug("BANK[%2d] %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", i, *b, *(b+1), *(b+2), *(b+3), *(b+4), *(b+5), *(b+6), *(b+7), *(b+8), *(b+9), *(b+10), *(b+11), *(b+12), *(b+13), *(b+14), *(b+15));
-
-		//Intel OTP map, try to read 320byts first.
-		if (21 == i) {
-			if ((*b) == 0) {
-				dev->otp_size = 320;
-				break;
-			} else {
-				b = buf;
-				continue;
-			}
-		} else if (24 == i) {		//if the first 320bytes data doesn't not exist, try to read the next 32bytes data.
-			if ((*b) == 0) {
-				dev->otp_size = 32;
-				break;
-		} else {
-				b = buf;
-				continue;
-			}
-		} else if (27 == i) {		//if the prvious 32bytes data doesn't exist, try to read the next 32bytes data again.
-			if ((*b) == 0) {
-				dev->otp_size = 32;
-				break;
-			} else {
-				dev->otp_size = 0;	// no OTP data.
-				break;
-			}
-		}
-
-		b = b + OV5693_OTP_BANK_SIZE;
-	}
-	return 0;
-}
-
-/*
- * Read otp data and store it into a kmalloced buffer.
- * The caller must kfree the buffer when no more needed.
- * @size: set to the size of the returned otp data.
- */
-static void *ov5693_otp_read(struct v4l2_subdev *sd)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u8 *buf;
-	int ret;
-
-	buf = devm_kzalloc(&client->dev, (OV5693_OTP_DATA_SIZE + 16), GFP_KERNEL);
-	if (!buf)
-		return ERR_PTR(-ENOMEM);
-
-	//otp valid after mipi on and sw stream on
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_FRAME_OFF_NUM, 0x00);
-
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-			       OV5693_SW_STREAM, OV5693_START_STREAMING);
-
-	ret = __ov5693_otp_read(sd, buf);
-
-	//mipi off and sw stream off after otp read
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_FRAME_OFF_NUM, 0x0f);
-
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-			       OV5693_SW_STREAM, OV5693_STOP_STREAMING);
-
-	/* Driver has failed to find valid data */
-	if (ret) {
-		dev_err(&client->dev, "sensor found no valid OTP data\n");
-		return ERR_PTR(ret);
-	}
-
-	return buf;
-}
-
-static int ov5693_g_priv_int_data(struct v4l2_subdev *sd,
-				  struct v4l2_private_int_data *priv)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	u8 __user *to = priv->data;
-	u32 read_size = priv->size;
-	int ret;
-
-	/* No need to copy data if size is 0 */
-	if (!read_size)
-		goto out;
-
-	if (IS_ERR(dev->otp_data)) {
-		dev_err(&client->dev, "OTP data not available");
-		return PTR_ERR(dev->otp_data);
-	}
-
-	/* Correct read_size value only if bigger than maximum */
-	if (read_size > OV5693_OTP_DATA_SIZE)
-		read_size = OV5693_OTP_DATA_SIZE;
-
-	ret = copy_to_user(to, dev->otp_data, read_size);
-	if (ret) {
-		dev_err(&client->dev, "%s: failed to copy OTP data to user\n",
-			__func__);
-		return -EFAULT;
-	}
-
-	pr_debug("%s read_size:%d\n", __func__, read_size);
-
-out:
-	/* Return correct size */
-	priv->size = dev->otp_size;
-
-	return 0;
-
-}
-
-static long ov5693_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
-{
-
-	switch (cmd) {
-	case ATOMISP_IOC_S_EXPOSURE:
-		return ov5693_s_exposure(sd, arg);
-	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
-		return ov5693_g_priv_int_data(sd, arg);
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/* This returns the exposure time being used. This should only be used
-   for filling in EXIF data, not for actual image processing. */
-static int ov5693_q_exposure(struct v4l2_subdev *sd, s32 *value)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 reg_v, reg_v2;
-	int ret;
-
-	/* get exposure */
-	ret = ov5693_read_reg(client, OV5693_8BIT,
-					OV5693_EXPOSURE_L,
-					&reg_v);
-	if (ret)
-		goto err;
-
-	ret = ov5693_read_reg(client, OV5693_8BIT,
-					OV5693_EXPOSURE_M,
-					&reg_v2);
-	if (ret)
-		goto err;
-
-	reg_v += reg_v2 << 8;
-	ret = ov5693_read_reg(client, OV5693_8BIT,
-					OV5693_EXPOSURE_H,
-					&reg_v2);
-	if (ret)
-		goto err;
-
-	*value = reg_v + (((u32)reg_v2 << 16));
-err:
-	return ret;
-}
-
-static int ov5693_t_focus_abs(struct v4l2_subdev *sd, s32 value)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	dev_dbg(&client->dev, "%s: FOCUS_POS: %x\n", __func__, value);
-	value = clamp(value, 0, OV5693_VCM_MAX_FOCUS_POS);
-	ret = vcm_i2c_wr16(client, VCM_CODE_MSB, value);
-	if (ret == 0) {
-		dev->number_of_steps = value - dev->focus;
-		dev->focus = value;
-		getnstimeofday(&(dev->timestamp_t_focus_abs));
-	} else
-		dev_err(&client->dev,
-			"%s: i2c failed. ret %d\n", __func__, ret);
-
-	return ret;
-}
-
-static int ov5693_t_focus_rel(struct v4l2_subdev *sd, s32 value)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	return ov5693_t_focus_abs(sd, dev->focus + value);
-}
-
-#define DELAY_PER_STEP_NS	1000000
-#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
-static int ov5693_q_focus_status(struct v4l2_subdev *sd, s32 *value)
-{
-	u32 status = 0;
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct timespec temptime;
-	const struct timespec timedelay = {
-		0,
-		min((u32)abs(dev->number_of_steps) * DELAY_PER_STEP_NS,
-		(u32)DELAY_MAX_PER_STEP_NS),
-	};
-
-	getnstimeofday(&temptime);
-	temptime = timespec_sub(temptime, (dev->timestamp_t_focus_abs));
-	if (timespec_compare(&temptime, &timedelay) <= 0) {
-		status |= ATOMISP_FOCUS_STATUS_MOVING;
-		status |= ATOMISP_FOCUS_HP_IN_PROGRESS;
-	} else {
-		status |= ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
-		status |= ATOMISP_FOCUS_HP_COMPLETE;
-	}
-
-	*value = status;
-
-	return 0;
-}
-
-static int ov5693_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	s32 val;
-
-	ov5693_q_focus_status(sd, &val);
-
-	if (val & ATOMISP_FOCUS_STATUS_MOVING)
-		*value  = dev->focus - dev->number_of_steps;
-	else
-		*value  = dev->focus;
-
-	return 0;
-}
-
-static int ov5693_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
-{
-	return 0;
-}
-
-static int ov5693_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
-{
-	return 0;
-}
-
-struct ov5693_control ov5693_controls[] = {
-	{
-		.qc = {
-			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "exposure",
-			.minimum = 0x0,
-			.maximum = 0xffff,
-			.step = 0x01,
-			.default_value = 0x00,
-			.flags = 0,
-		},
-		.query = ov5693_q_exposure,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FOCAL_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focal length",
-			.minimum = OV5693_FOCAL_LENGTH_DEFAULT,
-			.maximum = OV5693_FOCAL_LENGTH_DEFAULT,
-			.step = 0x01,
-			.default_value = OV5693_FOCAL_LENGTH_DEFAULT,
-			.flags = 0,
-		},
-		.query = ov5693_g_focal,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FNUMBER_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "f-number",
-			.minimum = OV5693_F_NUMBER_DEFAULT,
-			.maximum = OV5693_F_NUMBER_DEFAULT,
-			.step = 0x01,
-			.default_value = OV5693_F_NUMBER_DEFAULT,
-			.flags = 0,
-		},
-		.query = ov5693_g_fnumber,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FNUMBER_RANGE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "f-number range",
-			.minimum = OV5693_F_NUMBER_RANGE,
-			.maximum =  OV5693_F_NUMBER_RANGE,
-			.step = 0x01,
-			.default_value = OV5693_F_NUMBER_RANGE,
-			.flags = 0,
-		},
-		.query = ov5693_g_fnumber_range,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FOCUS_ABSOLUTE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focus move absolute",
-			.minimum = 0,
-			.maximum = OV5693_VCM_MAX_FOCUS_POS,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = ov5693_t_focus_abs,
-		.query = ov5693_q_focus_abs,
-
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FOCUS_RELATIVE,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focus move relative",
-			.minimum = OV5693_VCM_MAX_FOCUS_NEG,
-			.maximum = OV5693_VCM_MAX_FOCUS_POS,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = ov5693_t_focus_rel,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_FOCUS_STATUS,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "focus status",
-			.minimum = 0,
-			.maximum = 100, /* allow enum to grow in the future */
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = ov5693_q_focus_status,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_VCM_SLEW,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "vcm slew",
-			.minimum = 0,
-			.maximum = OV5693_VCM_SLEW_STEP_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = ov5693_t_vcm_slew,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_VCM_TIMEING,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "vcm step time",
-			.minimum = 0,
-			.maximum = OV5693_VCM_SLEW_TIME_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.tweak = ov5693_t_vcm_timing,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_BIN_FACTOR_HORZ,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "horizontal binning factor",
-			.minimum = 0,
-			.maximum = OV5693_BIN_FACTOR_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = ov5693_g_bin_factor_x,
-	},
-	{
-		.qc = {
-			.id = V4L2_CID_BIN_FACTOR_VERT,
-			.type = V4L2_CTRL_TYPE_INTEGER,
-			.name = "vertical binning factor",
-			.minimum = 0,
-			.maximum = OV5693_BIN_FACTOR_MAX,
-			.step = 1,
-			.default_value = 0,
-			.flags = 0,
-		},
-		.query = ov5693_g_bin_factor_y,
-	},
-};
-#define N_CONTROLS (ARRAY_SIZE(ov5693_controls))
-
-static struct ov5693_control *ov5693_find_control(u32 id)
-{
-	int i;
-
-	for (i = 0; i < N_CONTROLS; i++)
-		if (ov5693_controls[i].qc.id == id)
-			return &ov5693_controls[i];
-	return NULL;
-}
-
-static int ov5693_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
-{
-	struct ov5693_control *ctrl = ov5693_find_control(qc->id);
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-
-	if (ctrl == NULL)
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	*qc = ctrl->qc;
-	mutex_unlock(&dev->input_lock);
-
-	return 0;
-}
-
-/* imx control set/get */
-static int ov5693_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct ov5693_control *s_ctrl;
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	int ret;
-
-	if (!ctrl)
-		return -EINVAL;
-
-	s_ctrl = ov5693_find_control(ctrl->id);
-	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = s_ctrl->query(sd, &ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static int ov5693_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	struct ov5693_control *octrl = ov5693_find_control(ctrl->id);
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	int ret;
-
-	if ((octrl == NULL) || (octrl->tweak == NULL))
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = octrl->tweak(sd, ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static int ov5693_init(struct v4l2_subdev *sd)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	pr_info("%s\n", __func__);
-	mutex_lock(&dev->input_lock);
-
-	ret = vcm_i2c_wr8(client, 0x01, 0x01); // vcm init test
-	if (ret)
-		dev_err(&client->dev,
-			"vcm reset failed\n");
-
-	/* restore settings */
-	ov5693_res = ov5693_res_preview;
-	N_RES = N_RES_PREVIEW;
-
-	dev->focus = 0;
-	ov5693_t_focus_abs(sd, INIT_FOCUS_POS);
-
-	mutex_unlock(&dev->input_lock);
-
-	return 0;
-}
-
-static int power_ctrl(struct v4l2_subdev *sd, bool flag)
-{
-	int ret;
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->power_ctrl)
-		return dev->platform_data->power_ctrl(sd, flag);
-
-	if (flag) {
-		ret = dev->platform_data->v2p8_ctrl(sd, 1);
-		if (ret == 0) {
-			ret = dev->platform_data->v1p8_ctrl(sd, 1);
-			if (ret)
-				ret = dev->platform_data->v2p8_ctrl(sd, 0);
-		}
-	} else {
-		ret = dev->platform_data->v1p8_ctrl(sd, 0);
-		ret |= dev->platform_data->v2p8_ctrl(sd, 0);
-	}
-
-	return ret;
-}
-
-static int gpio_ctrl(struct v4l2_subdev *sd, bool flag)
-{
-	int ret;
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->gpio_ctrl)
-		return dev->platform_data->gpio_ctrl(sd, flag);
-
-	ret = dev->platform_data->gpio0_ctrl(sd, flag);
-
-	/* The OV5693 has two enable inputs: XSHUTDN and RESETB, both
-	 * are active low, both must be high to enable the device.
-	 * And they can be enabled in either order.  The datasheet
-	 * even suggests that one be tied high, and some modules do
-	 * that.  Basically: allow the second GPIO to be missing in
-	 * the DSDT and ignore an error here. */
-	dev->platform_data->gpio1_ctrl(sd, flag);
-
-	return ret;
-}
-
-
-static int power_up(struct v4l2_subdev *sd)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
-		return -ENODEV;
-	}
-
-	/* power control */
-	ret = power_ctrl(sd, 1);
-	if (ret)
-		goto fail_power;
-
-	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
-	usleep_range(5000, 6000);
-
-	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 1);
-	if (ret) {
-		ret = gpio_ctrl(sd, 1);
-		if (ret)
-			goto fail_power;
-	}
-
-	/* flis clock control */
-	ret = dev->platform_data->flisclk_ctrl(sd, 1);
-	if (ret)
-		goto fail_clk;
-
-	/* according to DS, 20ms is needed between PWDN and i2c access */
-	msleep(20);
-
-	return 0;
-
-fail_clk:
-	gpio_ctrl(sd, 0);
-fail_power:
-	power_ctrl(sd, 0);
-	dev_err(&client->dev, "sensor power-up failed\n");
-
-	return ret;
-}
-
-static int power_down(struct v4l2_subdev *sd)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	dev->focus = OV5693_INVALID_CONFIG;
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
-		return -ENODEV;
-	}
-
-	ret = dev->platform_data->flisclk_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "flisclk failed\n");
-
-	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 0);
-	if (ret) {
-		ret = gpio_ctrl(sd, 0);
-		if (ret)
-			dev_err(&client->dev, "gpio failed 2\n");
-	}
-
-	/* power control */
-	ret = power_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "vprog failed.\n");
-
-	return ret;
-}
-
-static int ov5693_s_power(struct v4l2_subdev *sd, int on)
-{
-	int ret;
-
-	pr_info("%s: on %d\n", __func__, on);
-	if (on == 0)
-		return power_down(sd);
-	else {
-		ret = power_up(sd);
-		if (!ret)
-			return ov5693_init(sd);
-	}
-	return ret;
-}
-
-/*
- * distance - calculate the distance
- * @res: resolution
- * @w: width
- * @h: height
- *
- * Get the gap between resolution and w/h.
- * res->width/height smaller than w/h wouldn't be considered.
- * Returns the value of gap or -1 if fail.
- */
-#define LARGEST_ALLOWED_RATIO_MISMATCH 800
-static int distance(struct ov5693_resolution *res, u32 w, u32 h)
-{
-	unsigned int w_ratio = ((res->width << 13)/w);
-	unsigned int h_ratio;
-	int match;
-
-	if (h == 0)
-		return -1;
-	h_ratio = ((res->height << 13) / h);
-	if (h_ratio == 0)
-		return -1;
-	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
-
-	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
-		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
-		return -1;
-
-	return w_ratio + h_ratio;
-}
-
-/* Return the nearest higher resolution index */
-static int nearest_resolution_index(int w, int h)
-{
-	int i;
-	int idx = -1;
-	int dist;
-	int min_dist = INT_MAX;
-	struct ov5693_resolution *tmp_res = NULL;
-
-	for (i = 0; i < N_RES; i++) {
-		tmp_res = &ov5693_res[i];
-		dist = distance(tmp_res, w, h);
-		if (dist == -1)
-			continue;
-		if (dist < min_dist) {
-			min_dist = dist;
-			idx = i;
-		}
-	}
-
-	return idx;
-}
-
-static int get_resolution_index(int w, int h)
-{
-	int i;
-
-	for (i = 0; i < N_RES; i++) {
-		if (w != ov5693_res[i].width)
-			continue;
-		if (h != ov5693_res[i].height)
-			continue;
-
-		return i;
-	}
-
-	return -1;
-}
-
-static int ov5693_try_mbus_fmt(struct v4l2_subdev *sd,
-			struct v4l2_mbus_framefmt *fmt)
-{
-	int idx;
-
-	if (!fmt)
-		return -EINVAL;
-	idx = nearest_resolution_index(fmt->width,
-					fmt->height);
-	if (idx == -1) {
-		/* return the largest resolution */
-		fmt->width = ov5693_res[0].width;
-		fmt->height = ov5693_res[0].height;
-	} else {
-		fmt->width = ov5693_res[idx].width;
-		fmt->height = ov5693_res[idx].height;
-	}
-
-	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
-
-	return 0;
-}
-
-/* TODO: remove it. */
-static int startup(struct v4l2_subdev *sd)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	ret = ov5693_write_reg(client, OV5693_8BIT,
-					OV5693_SW_RESET, 0x01);
-	if (ret) {
-		dev_err(&client->dev, "ov5693 reset err.\n");
-		return ret;
-	}
-
-	ret = ov5693_write_reg_array(client, ov5693_global_setting);
-	if (ret) {
-		dev_err(&client->dev, "ov5693 write register err.\n");
-		return ret;
-	}
-
-	ret = ov5693_write_reg_array(client, ov5693_res[dev->fmt_idx].regs);
-	if (ret) {
-		dev_err(&client->dev, "ov5693 write register err.\n");
-		return ret;
-	}
-
-	return ret;
-}
-
-static int ov5693_s_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_mipi_info *ov5693_info = NULL;
-	int ret = 0;
-
-	ov5693_info = v4l2_get_subdev_hostdata(sd);
-	if (ov5693_info == NULL)
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = ov5693_try_mbus_fmt(sd, fmt);
-	if (ret == -1) {
-		dev_err(&client->dev, "try fmt fail\n");
-		goto err;
-	}
-
-	dev->fmt_idx = get_resolution_index(fmt->width,
-					      fmt->height);
-	if (dev->fmt_idx == -1) {
-		dev_err(&client->dev, "get resolution fail\n");
-		mutex_unlock(&dev->input_lock);
-		return -EINVAL;
-	}
-
-	ret = ov5693_get_intg_factor(client, ov5693_info,
-					&ov5693_res[dev->fmt_idx]);
-	if (ret) {
-		dev_err(&client->dev, "failed to get integration_factor\n");
-		goto err;
-	}
-
-	ret = startup(sd);
-	if (ret)
-		dev_err(&client->dev, "ov5693 startup err\n");
-
-	ov5693_info->metadata_width = fmt->width * 10 / 8;
-	ov5693_info->metadata_height = 1;
-	ov5693_info->metadata_effective_width = &ov5693_embedded_effective_size;
-
-err:
-	mutex_unlock(&dev->input_lock);
-	return ret;
-}
-static int ov5693_g_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-
-	if (!fmt)
-		return -EINVAL;
-
-	fmt->width = ov5693_res[dev->fmt_idx].width;
-	fmt->height = ov5693_res[dev->fmt_idx].height;
-	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
-
-	return 0;
-}
-
-static int ov5693_detect(struct i2c_client *client)
-{
-	struct i2c_adapter *adapter = client->adapter;
-	u16 high, low;
-	int ret;
-	u16 id;
-	u8 revision;
-
-	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
-		return -ENODEV;
-
-	ret = ov5693_read_reg(client, OV5693_8BIT,
-					OV5693_SC_CMMN_CHIP_ID_H, &high);
-	if (ret) {
-		dev_err(&client->dev, "sensor_id_high = 0x%x\n", high);
-		return -ENODEV;
-	}
-	ret = ov5693_read_reg(client, OV5693_8BIT,
-					OV5693_SC_CMMN_CHIP_ID_L, &low);
-	id = ((((u16) high) << 8) | (u16) low);
-
-	if (id != OV5693_ID) {
-		dev_err(&client->dev, "sensor ID error 0x%x\n", id);
-		return -ENODEV;
-	}
-
-	ret = ov5693_read_reg(client, OV5693_8BIT,
-					OV5693_SC_CMMN_SUB_ID, &high);
-	revision = (u8) high & 0x0f;
-
-	dev_dbg(&client->dev, "sensor_revision = 0x%x\n", revision);
-	dev_dbg(&client->dev, "detect ov5693 success\n");
-	return 0;
-}
-
-static int ov5693_s_stream(struct v4l2_subdev *sd, int enable)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	mutex_lock(&dev->input_lock);
-
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_SW_STREAM,
-				enable ? OV5693_START_STREAMING :
-				OV5693_STOP_STREAMING);
-
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-/* ov5693 enum frame size, frame intervals */
-static int ov5693_enum_framesizes(struct v4l2_subdev *sd,
-				  struct v4l2_frmsizeenum *fsize)
-{
-	unsigned int index = fsize->index;
-
-	if (index >= N_RES)
-		return -EINVAL;
-
-	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-	fsize->discrete.width = ov5693_res[index].width;
-	fsize->discrete.height = ov5693_res[index].height;
-	fsize->reserved[0] = ov5693_res[index].used;
-
-	return 0;
-}
-
-static int ov5693_enum_frameintervals(struct v4l2_subdev *sd,
-				      struct v4l2_frmivalenum *fival)
-{
-	unsigned int index = fival->index;
-
-	if (index >= N_RES)
-		return -EINVAL;
-
-	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
-	fival->width = ov5693_res[index].width;
-	fival->height = ov5693_res[index].height;
-	fival->discrete.numerator = 1;
-	fival->discrete.denominator = ov5693_res[index].fps;
-
-	return 0;
-}
-
-static int ov5693_enum_mbus_fmt(struct v4l2_subdev *sd,
-				unsigned int index,
-				enum v4l2_mbus_pixelcode *code)
-{
-	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
-
-	return 0;
-}
-
-static int ov5693_s_config(struct v4l2_subdev *sd,
-			   int irq, void *platform_data)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	if (platform_data == NULL)
-		return -ENODEV;
-
-	dev->platform_data =
-		(struct camera_sensor_platform_data *)platform_data;
-
-	mutex_lock(&dev->input_lock);
-	/* power off the module, then power on it in future
-	 * as first power on by board may not fulfill the
-	 * power on sequqence needed by the module
-	 */
-	ret = power_down(sd);
-	if (ret) {
-		dev_err(&client->dev, "ov5693 power-off err.\n");
-		goto fail_power_off;
-	}
-
-	ret = power_up(sd);
-	if (ret) {
-		dev_err(&client->dev, "ov5693 power-up err.\n");
-		goto fail_power_on;
-	}
-
-	ret = dev->platform_data->csi_cfg(sd, 1);
-	if (ret)
-		goto fail_csi_cfg;
-
-	/* config & detect sensor */
-	ret = ov5693_detect(client);
-	if (ret) {
-		dev_err(&client->dev, "ov5693_detect err s_config.\n");
-		goto fail_csi_cfg;
-	}
-
-	dev->otp_data = ov5693_otp_read(sd);
-
-	/* turn off sensor, after probed */
-	ret = power_down(sd);
-	if (ret) {
-		dev_err(&client->dev, "ov5693 power-off err.\n");
-		goto fail_csi_cfg;
-	}
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-
-fail_csi_cfg:
-	dev->platform_data->csi_cfg(sd, 0);
-fail_power_on:
-	power_down(sd);
-	dev_err(&client->dev, "sensor power-gating failed\n");
-fail_power_off:
-	mutex_unlock(&dev->input_lock);
-	return ret;
-}
-
-static int ov5693_g_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	if (!param)
-		return -EINVAL;
-
-	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_err(&client->dev,  "unsupported buffer type.\n");
-		return -EINVAL;
-	}
-
-	memset(param, 0, sizeof(*param));
-	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-
-	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
-		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
-		param->parm.capture.timeperframe.numerator = 1;
-		param->parm.capture.capturemode = dev->run_mode;
-		param->parm.capture.timeperframe.denominator =
-			ov5693_res[dev->fmt_idx].fps;
-	}
-	return 0;
-}
-
-static int ov5693_s_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	dev->run_mode = param->parm.capture.capturemode;
-
-	mutex_lock(&dev->input_lock);
-	switch (dev->run_mode) {
-	case CI_MODE_VIDEO:
-		ov5693_res = ov5693_res_video;
-		N_RES = N_RES_VIDEO;
-		break;
-	case CI_MODE_STILL_CAPTURE:
-		ov5693_res = ov5693_res_still;
-		N_RES = N_RES_STILL;
-		break;
-	default:
-		ov5693_res = ov5693_res_preview;
-		N_RES = N_RES_PREVIEW;
-	}
-	mutex_unlock(&dev->input_lock);
-	return 0;
-}
-
-static int ov5693_g_frame_interval(struct v4l2_subdev *sd,
-				   struct v4l2_subdev_frame_interval *interval)
-{
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-
-	interval->interval.numerator = 1;
-	interval->interval.denominator = ov5693_res[dev->fmt_idx].fps;
-
-	return 0;
-}
-
-static int ov5693_enum_mbus_code(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_mbus_code_enum *code)
-{
-	if (code->index >= MAX_FMTS)
-		return -EINVAL;
-
-	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
-	return 0;
-}
-
-static int ov5693_enum_frame_size(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_frame_size_enum *fse)
-{
-	int index = fse->index;
-
-	if (index >= N_RES)
-		return -EINVAL;
-
-	fse->min_width = ov5693_res[index].width;
-	fse->min_height = ov5693_res[index].height;
-	fse->max_width = ov5693_res[index].width;
-	fse->max_height = ov5693_res[index].height;
-
-	return 0;
-
-}
-
-static struct v4l2_mbus_framefmt *
-__ov5693_get_pad_format(struct ov5693_device *sensor,
-			struct v4l2_subdev_fh *fh, unsigned int pad,
-			enum v4l2_subdev_format_whence which)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
-
-	if (pad != 0) {
-		dev_err(&client->dev,
-			"__ov5693_get_pad_format err. pad %x\n", pad);
-		return NULL;
-	}
-
-	switch (which) {
-	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
-	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &sensor->format;
-	default:
-		return NULL;
-	}
-}
-
-static int ov5693_get_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
-{
-	struct ov5693_device *snr = to_ov5693_sensor(sd);
-	struct v4l2_mbus_framefmt *format =
-			__ov5693_get_pad_format(snr, fh, fmt->pad, fmt->which);
-	if (!format)
-		return -EINVAL;
-
-	fmt->format = *format;
-	return 0;
-}
-
-static int ov5693_set_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
-{
-	struct ov5693_device *snr = to_ov5693_sensor(sd);
-
-	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		snr->format = fmt->format;
-
-	return 0;
-}
-
-static const struct v4l2_subdev_video_ops ov5693_video_ops = {
-	.s_stream = ov5693_s_stream,
-	.g_parm = ov5693_g_parm,
-	.s_parm = ov5693_s_parm,
-	.enum_framesizes = ov5693_enum_framesizes,
-	.enum_frameintervals = ov5693_enum_frameintervals,
-	.enum_mbus_fmt = ov5693_enum_mbus_fmt,
-	.try_mbus_fmt = ov5693_try_mbus_fmt,
-	.g_mbus_fmt = ov5693_g_mbus_fmt,
-	.s_mbus_fmt = ov5693_s_mbus_fmt,
-	.g_frame_interval = ov5693_g_frame_interval,
-};
-
-static const struct v4l2_subdev_core_ops ov5693_core_ops = {
-	.s_power = ov5693_s_power,
-	.queryctrl = ov5693_queryctrl,
-	.g_ctrl = ov5693_g_ctrl,
-	.s_ctrl = ov5693_s_ctrl,
-	.ioctl = ov5693_ioctl,
-};
-
-static const struct v4l2_subdev_pad_ops ov5693_pad_ops = {
-	.enum_mbus_code = ov5693_enum_mbus_code,
-	.enum_frame_size = ov5693_enum_frame_size,
-	.get_fmt = ov5693_get_pad_format,
-	.set_fmt = ov5693_set_pad_format,
-};
-
-static const struct v4l2_subdev_ops ov5693_ops = {
-	.core = &ov5693_core_ops,
-	.video = &ov5693_video_ops,
-	.pad = &ov5693_pad_ops,
-};
-
-static int ov5693_remove(struct i2c_client *client)
-{
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
-	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	dev_dbg(&client->dev, "ov5693_remove...\n");
-
-	dev->platform_data->csi_cfg(sd, 0);
-
-	v4l2_device_unregister_subdev(sd);
-	media_entity_cleanup(&dev->sd.entity);
-	kfree(dev);
-
-	return 0;
-}
-
-static int ov5693_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
-{
-	struct ov5693_device *dev;
-	int i2c;
-	int ret = 0;
-	void *pdata = client->dev.platform_data;
-
-	/* Firmware workaround: Some modules use a "secondary default"
-	 * address of 0x10 which doesn't appear on schematics, and
-	 * some BIOS versions haven't gotten the memo.  Work around
-	 * via config. */
-	i2c = gmin_get_var_int(&client->dev, "I2CAddr", -1);
-	if (i2c != -1) {
-		dev_info(&client->dev, "Overriding firmware-provided I2C address (0x%x) with 0x%x\n",
-			 client->addr, i2c);
-		client->addr = i2c;
-	}
-
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev) {
-		dev_err(&client->dev, "out of memory\n");
-		return -ENOMEM;
-	}
-
-	mutex_init(&dev->input_lock);
-
-	dev->fmt_idx = 0;
-	v4l2_i2c_subdev_init(&(dev->sd), client, &ov5693_ops);
-
-	if (ACPI_COMPANION(&client->dev))
-		pdata = gmin_camera_platform_data(&dev->sd,
-						  ATOMISP_INPUT_FORMAT_RAW_10,
-						  atomisp_bayer_order_bggr);
-	if (!pdata)
-		goto out_free;
-
-	ret = ov5693_s_config(&dev->sd, client->irq, pdata);
-	if (ret)
-		goto out_free;
-
-	ret = atomisp_register_i2c_module(&dev->sd, pdata, RAW_CAMERA);
-	if (ret)
-		goto out_free;
-
-	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
-	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
-	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
-
-	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
-	if (ret)
-		ov5693_remove(client);
-
-	return ret;
-out_free:
-	v4l2_device_unregister_subdev(&dev->sd);
-	kfree(dev);
-	return ret;
-}
-
-MODULE_DEVICE_TABLE(i2c, ov5693_id);
-
-static struct acpi_device_id ov5693_acpi_match[] = {
-	{"INT33BE"},
-	{},
-};
-MODULE_DEVICE_TABLE(acpi, ov5693_acpi_match);
-
-static struct i2c_driver ov5693_driver = {
-	.driver = {
-		.owner = THIS_MODULE,
-		.name = OV5693_NAME,
-		.acpi_match_table = ACPI_PTR(ov5693_acpi_match),
-	},
-	.probe = ov5693_probe,
-	.remove = ov5693_remove,
-	.id_table = ov5693_id,
-};
-
-static int init_ov5693(void)
-{
-	return i2c_add_driver(&ov5693_driver);
-}
-
-static void exit_ov5693(void)
-{
-
-	i2c_del_driver(&ov5693_driver);
-}
-
-module_init(init_ov5693);
-module_exit(exit_ov5693);
-
-MODULE_DESCRIPTION("A low-level driver for OmniVision 5693 sensors");
-MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693.h
deleted file mode 100755
index 2ec30e3..0000000
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693.h
+++ /dev/null
@@ -1,969 +0,0 @@
-/*
- * Support for OmniVision OV5693 5M camera sensor.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __OV5693_H__
-#define __OV5693_H__
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
-#include <linux/videodev2.h>
-#include <linux/spinlock.h>
-#include <media/v4l2-subdev.h>
-#include <media/v4l2-device.h>
-#include <linux/v4l2-mediabus.h>
-#include <media/media-entity.h>
-
-#include <linux/atomisp_platform.h>
-
-#define OV5693_NAME		"ov5693"
-
-/* Defines for register writes and register array processing */
-#define I2C_MSG_LENGTH		0x2
-#define I2C_RETRY_COUNT		5
-
-#define OV5693_FOCAL_LENGTH_NUM	334	/*3.34mm*/
-#define OV5693_FOCAL_LENGTH_DEM	100
-#define OV5693_F_NUMBER_DEFAULT_NUM	24
-#define OV5693_F_NUMBER_DEM	10
-
-#define MAX_FMTS		1
-
-/* sensor_mode_data read_mode adaptation */
-#define OV5693_READ_MODE_BINNING_ON	0x0400
-#define OV5693_READ_MODE_BINNING_OFF	0x00
-#define OV5693_INTEGRATION_TIME_MARGIN	8
-
-#define OV5693_MAX_EXPOSURE_VALUE	0xFFF1
-#define OV5693_MAX_GAIN_VALUE		0xFF
-
-/*
- * focal length bits definition:
- * bits 31-16: numerator, bits 15-0: denominator
- */
-#define OV5693_FOCAL_LENGTH_DEFAULT 0x1B70064
-
-/*
- * current f-number bits definition:
- * bits 31-16: numerator, bits 15-0: denominator
- */
-#define OV5693_F_NUMBER_DEFAULT 0x18000a
-
-/*
- * f-number range bits definition:
- * bits 31-24: max f-number numerator
- * bits 23-16: max f-number denominator
- * bits 15-8: min f-number numerator
- * bits 7-0: min f-number denominator
- */
-#define OV5693_F_NUMBER_RANGE 0x180a180a
-#define OV5693_ID	0x5690
-
-#define OV5693_FINE_INTG_TIME_MIN 0
-#define OV5693_FINE_INTG_TIME_MAX_MARGIN 0
-#define OV5693_COARSE_INTG_TIME_MIN 1
-#define OV5693_COARSE_INTG_TIME_MAX_MARGIN 6
-
-#define OV5693_BIN_FACTOR_MAX 4
-/*
- * OV5693 System control registers
- */
-#define OV5693_SW_SLEEP				0x0100
-#define OV5693_SW_RESET				0x0103
-#define OV5693_SW_STREAM			0x0100
-
-#define OV5693_SC_CMMN_CHIP_ID_H		0x300A
-#define OV5693_SC_CMMN_CHIP_ID_L		0x300B
-#define OV5693_SC_CMMN_SCCB_ID			0x300C
-#define OV5693_SC_CMMN_SUB_ID			0x302A /* process, version*/
-
-#define OV5693_GROUP_ACCESS							0x3208 /*Bit[7:4] Group control, Bit[3:0] Group ID*/
-
-#define OV5693_EXPOSURE_H							0x3500 /*Bit[3:0] Bit[19:16] of exposure, remaining 16 bits lies in Reg0x3501&Reg0x3502*/
-#define OV5693_EXPOSURE_M							0x3501
-#define OV5693_EXPOSURE_L							0x3502
-#define OV5693_AGC_H								0x350A /*Bit[1:0] means Bit[9:8] of gain*/
-#define OV5693_AGC_L								0x350B /*Bit[7:0] of gain*/
-
-#define OV5693_HORIZONTAL_START_H					0x3800 /*Bit[11:8]*/
-#define OV5693_HORIZONTAL_START_L					0x3801 /*Bit[7:0]*/
-#define OV5693_VERTICAL_START_H						0x3802 /*Bit[11:8]*/
-#define OV5693_VERTICAL_START_L						0x3803 /*Bit[7:0]*/
-#define OV5693_HORIZONTAL_END_H						0x3804 /*Bit[11:8]*/
-#define OV5693_HORIZONTAL_END_L						0x3805 /*Bit[7:0]*/
-#define OV5693_VERTICAL_END_H						0x3806 /*Bit[11:8]*/
-#define OV5693_VERTICAL_END_L						0x3807 /*Bit[7:0]*/
-#define OV5693_HORIZONTAL_OUTPUT_SIZE_H				0x3808 /*Bit[3:0]*/
-#define OV5693_HORIZONTAL_OUTPUT_SIZE_L				0x3809 /*Bit[7:0]*/
-#define OV5693_VERTICAL_OUTPUT_SIZE_H				0x380a /*Bit[3:0]*/
-#define OV5693_VERTICAL_OUTPUT_SIZE_L				0x380b /*Bit[7:0]*/
-#define OV5693_TIMING_HTS_H							0x380C  /*High 8-bit, and low 8-bit HTS address is 0x380d*/
-#define OV5693_TIMING_HTS_L							0x380D  /*High 8-bit, and low 8-bit HTS address is 0x380d*/
-#define OV5693_TIMING_VTS_H							0x380e  /*High 8-bit, and low 8-bit HTS address is 0x380f*/
-#define OV5693_TIMING_VTS_L							0x380f  /*High 8-bit, and low 8-bit HTS address is 0x380f*/
-
-#define OV5693_MWB_RED_GAIN_H			0x3400
-#define OV5693_MWB_GREEN_GAIN_H			0x3402
-#define OV5693_MWB_BLUE_GAIN_H			0x3404
-#define OV5693_MWB_GAIN_MAX				0x0fff
-
-#define OV5693_START_STREAMING			0x01
-#define OV5693_STOP_STREAMING			0x00
-
-#define VCM_ADDR           0x0c
-#define VCM_CODE_MSB       0x04
-
-#define OV5693_INVALID_CONFIG	0xffffffff
-
-#define OV5693_VCM_SLEW_STEP			0x30F0
-#define OV5693_VCM_SLEW_STEP_MAX		0x7
-#define OV5693_VCM_SLEW_STEP_MASK		0x7
-#define OV5693_VCM_CODE				0x30F2
-#define OV5693_VCM_SLEW_TIME			0x30F4
-#define OV5693_VCM_SLEW_TIME_MAX		0xffff
-#define OV5693_VCM_ENABLE			0x8000
-
-#define OV5693_VCM_MAX_FOCUS_NEG       -1023
-#define OV5693_VCM_MAX_FOCUS_POS       1023
-
-/* Defines for OTP Data Registers */
-#define OV5693_FRAME_OFF_NUM		0x4202
-#define OV5693_OTP_BYTE_MAX		32	//change to 32 as needed by otpdata
-#define OV5693_OTP_SHORT_MAX		16
-#define OV5693_OTP_START_ADDR		0x3D00
-#define OV5693_OTP_END_ADDR		0x3D0F
-#define OV5693_OTP_DATA_SIZE		320
-#define OV5693_OTP_PROGRAM_REG      	0x3D80
-#define OV5693_OTP_READ_REG		0x3D81	// 1:Enable 0:disable
-#define OV5693_OTP_BANK_REG		0x3D84	//otp bank and mode
-#define OV5693_OTP_READY_REG_DONE	1
-#define OV5693_OTP_BANK_MAX		28
-#define OV5693_OTP_BANK_SIZE		16	//16 bytes per bank
-#define OV5693_OTP_READ_ONETIME		16
-#define OV5693_OTP_MODE_READ		1
-
-struct regval_list {
-	u16 reg_num;
-	u8 value;
-};
-
-struct ov5693_resolution {
-	u8 *desc;
-	const struct ov5693_reg *regs;
-	int res;
-	int width;
-	int height;
-	int fps;
-	int pix_clk_freq;
-	u16 pixels_per_line;
-	u16 lines_per_frame;
-	u8 bin_factor_x;
-	u8 bin_factor_y;
-	u8 bin_mode;
-	bool used;
-};
-
-struct ov5693_format {
-	u8 *desc;
-	u32 pixelformat;
-	struct ov5693_reg *regs;
-};
-
-struct ov5693_control {
-	struct v4l2_queryctrl qc;
-	int (*query)(struct v4l2_subdev *sd, s32 *value);
-	int (*tweak)(struct v4l2_subdev *sd, s32 value);
-};
-
-/*
- * ov5693 device structure.
- */
-struct ov5693_device {
-	struct v4l2_subdev sd;
-	struct media_pad pad;
-	struct v4l2_mbus_framefmt format;
-	struct mutex input_lock;
-
-	struct camera_sensor_platform_data *platform_data;
-	struct timespec timestamp_t_focus_abs;
-	int vt_pix_clk_freq_mhz;
-	int fmt_idx;
-	int run_mode;
-	int otp_size;
-	u8 *otp_data;
-	u32 focus;
-	s16 number_of_steps;
-	u8 res;
-	u8 type;
-};
-
-enum ov5693_tok_type {
-	OV5693_8BIT  = 0x0001,
-	OV5693_16BIT = 0x0002,
-	OV5693_32BIT = 0x0004,
-	OV5693_TOK_TERM   = 0xf000,	/* terminating token for reg list */
-	OV5693_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
-	OV5693_TOK_MASK = 0xfff0
-};
-
-/**
- * struct ov5693_reg - MI sensor  register format
- * @type: type of the register
- * @reg: 16-bit offset to register
- * @val: 8/16/32-bit register value
- *
- * Define a structure for sensor register initialization values
- */
-struct ov5693_reg {
-	enum ov5693_tok_type type;
-	u16 reg;
-	u32 val;	/* @set value for read/mod/write, @mask */
-};
-
-#define to_ov5693_sensor(x) container_of(x, struct ov5693_device, sd)
-
-#define OV5693_MAX_WRITE_BUF_SIZE	30
-
-struct ov5693_write_buffer {
-	u16 addr;
-	u8 data[OV5693_MAX_WRITE_BUF_SIZE];
-};
-
-struct ov5693_write_ctrl {
-	int index;
-	struct ov5693_write_buffer buffer;
-};
-
-static const struct i2c_device_id ov5693_id[] = {
-	{OV5693_NAME, 0},
-	{}
-};
-
-static struct ov5693_reg const ov5693_global_setting[] = {
-	{OV5693_8BIT, 0x0103, 0x01},
-	{OV5693_8BIT, 0x3001, 0x0a},
-	{OV5693_8BIT, 0x3002, 0x80},
-	{OV5693_8BIT, 0x3006, 0x00},
-	{OV5693_8BIT, 0x3011, 0x21},
-	{OV5693_8BIT, 0x3012, 0x09},
-	{OV5693_8BIT, 0x3013, 0x10},
-	{OV5693_8BIT, 0x3014, 0x00},
-	{OV5693_8BIT, 0x3015, 0x08},
-	{OV5693_8BIT, 0x3016, 0xf0},
-	{OV5693_8BIT, 0x3017, 0xf0},
-	{OV5693_8BIT, 0x3018, 0xf0},
-	{OV5693_8BIT, 0x301b, 0xb4},
-	{OV5693_8BIT, 0x301d, 0x02},
-	{OV5693_8BIT, 0x3021, 0x00},
-	{OV5693_8BIT, 0x3022, 0x01},
-	{OV5693_8BIT, 0x3028, 0x44},
-	{OV5693_8BIT, 0x3098, 0x02},
-	{OV5693_8BIT, 0x3099, 0x19},
-	{OV5693_8BIT, 0x309a, 0x02},
-	{OV5693_8BIT, 0x309b, 0x01},
-	{OV5693_8BIT, 0x309c, 0x00},
-	{OV5693_8BIT, 0x30a0, 0xd2},
-	{OV5693_8BIT, 0x30a2, 0x01},
-	{OV5693_8BIT, 0x30b2, 0x00},
-	{OV5693_8BIT, 0x30b3, 0x7d},
-	{OV5693_8BIT, 0x30b4, 0x03},
-	{OV5693_8BIT, 0x30b5, 0x04},
-	{OV5693_8BIT, 0x30b6, 0x01},
-	{OV5693_8BIT, 0x3104, 0x21},
-	{OV5693_8BIT, 0x3106, 0x00},
-	{OV5693_8BIT, 0x3400, 0x04},
-	{OV5693_8BIT, 0x3401, 0x00},
-	{OV5693_8BIT, 0x3402, 0x04},
-	{OV5693_8BIT, 0x3403, 0x00},
-	{OV5693_8BIT, 0x3404, 0x04},
-	{OV5693_8BIT, 0x3405, 0x00},
-	{OV5693_8BIT, 0x3406, 0x01},
-	{OV5693_8BIT, 0x3500, 0x00},
-	{OV5693_8BIT, 0x3503, 0x07},
-	{OV5693_8BIT, 0x3504, 0x00},
-	{OV5693_8BIT, 0x3505, 0x00},
-	{OV5693_8BIT, 0x3506, 0x00},
-	{OV5693_8BIT, 0x3507, 0x02},
-	{OV5693_8BIT, 0x3508, 0x00},
-	{OV5693_8BIT, 0x3509, 0x10},
-	{OV5693_8BIT, 0x350a, 0x00},
-	{OV5693_8BIT, 0x350b, 0x40},
-	{OV5693_8BIT, 0x3601, 0x0a},
-	{OV5693_8BIT, 0x3602, 0x38},
-	{OV5693_8BIT, 0x3612, 0x80},
-	{OV5693_8BIT, 0x3620, 0x54},
-	{OV5693_8BIT, 0x3621, 0xc7},
-	{OV5693_8BIT, 0x3622, 0x0f},
-	{OV5693_8BIT, 0x3625, 0x10},
-	{OV5693_8BIT, 0x3630, 0x55},
-	{OV5693_8BIT, 0x3631, 0xf4},
-	{OV5693_8BIT, 0x3632, 0x00},
-	{OV5693_8BIT, 0x3633, 0x34},
-	{OV5693_8BIT, 0x3634, 0x02},
-	{OV5693_8BIT, 0x364d, 0x0d},
-	{OV5693_8BIT, 0x364f, 0xdd},
-	{OV5693_8BIT, 0x3660, 0x04},
-	{OV5693_8BIT, 0x3662, 0x10},
-	{OV5693_8BIT, 0x3663, 0xf1},
-	{OV5693_8BIT, 0x3665, 0x00},
-	{OV5693_8BIT, 0x3666, 0x20},
-	{OV5693_8BIT, 0x3667, 0x00},
-	{OV5693_8BIT, 0x366a, 0x80},
-	{OV5693_8BIT, 0x3680, 0xe0},
-	{OV5693_8BIT, 0x3681, 0x00},
-	{OV5693_8BIT, 0x3700, 0x42},
-	{OV5693_8BIT, 0x3701, 0x14},
-	{OV5693_8BIT, 0x3702, 0xa0},
-	{OV5693_8BIT, 0x3703, 0xd8},
-	{OV5693_8BIT, 0x3704, 0x78},
-	{OV5693_8BIT, 0x3705, 0x02},
-	{OV5693_8BIT, 0x370a, 0x00},
-	{OV5693_8BIT, 0x370b, 0x20},
-	{OV5693_8BIT, 0x370c, 0x0c},
-	{OV5693_8BIT, 0x370d, 0x11},
-	{OV5693_8BIT, 0x370e, 0x00},
-	{OV5693_8BIT, 0x370f, 0x40},
-	{OV5693_8BIT, 0x3710, 0x00},
-	{OV5693_8BIT, 0x371a, 0x1c},
-	{OV5693_8BIT, 0x371b, 0x05},
-	{OV5693_8BIT, 0x371c, 0x01},
-	{OV5693_8BIT, 0x371e, 0xa1},
-	{OV5693_8BIT, 0x371f, 0x0c},
-	{OV5693_8BIT, 0x3721, 0x00},
-	{OV5693_8BIT, 0x3724, 0x10},
-	{OV5693_8BIT, 0x3726, 0x00},
-	{OV5693_8BIT, 0x372a, 0x01},
-	{OV5693_8BIT, 0x3730, 0x10},
-	{OV5693_8BIT, 0x3738, 0x22},
-	{OV5693_8BIT, 0x3739, 0xe5},
-	{OV5693_8BIT, 0x373a, 0x50},
-	{OV5693_8BIT, 0x373b, 0x02},
-	{OV5693_8BIT, 0x373c, 0x41},
-	{OV5693_8BIT, 0x373f, 0x02},
-	{OV5693_8BIT, 0x3740, 0x42},
-	{OV5693_8BIT, 0x3741, 0x02},
-	{OV5693_8BIT, 0x3742, 0x18},
-	{OV5693_8BIT, 0x3743, 0x01},
-	{OV5693_8BIT, 0x3744, 0x02},
-	{OV5693_8BIT, 0x3747, 0x10},
-	{OV5693_8BIT, 0x374c, 0x04},
-	{OV5693_8BIT, 0x3751, 0xf0},
-	{OV5693_8BIT, 0x3752, 0x00},
-	{OV5693_8BIT, 0x3753, 0x00},
-	{OV5693_8BIT, 0x3754, 0xc0},
-	{OV5693_8BIT, 0x3755, 0x00},
-	{OV5693_8BIT, 0x3756, 0x1a},
-	{OV5693_8BIT, 0x3758, 0x00},
-	{OV5693_8BIT, 0x3759, 0x0f},
-	{OV5693_8BIT, 0x376b, 0x44},
-	{OV5693_8BIT, 0x375c, 0x04},
-	{OV5693_8BIT, 0x3774, 0x10},
-	{OV5693_8BIT, 0x3776, 0x00},
-	{OV5693_8BIT, 0x377f, 0x08},
-	{OV5693_8BIT, 0x3780, 0x22},
-	{OV5693_8BIT, 0x3781, 0x0c},
-	{OV5693_8BIT, 0x3784, 0x2c},
-	{OV5693_8BIT, 0x3785, 0x1e},
-	{OV5693_8BIT, 0x378f, 0xf5},
-	{OV5693_8BIT, 0x3791, 0xb0},
-	{OV5693_8BIT, 0x3795, 0x00},
-	{OV5693_8BIT, 0x3796, 0x64},
-	{OV5693_8BIT, 0x3797, 0x11},
-	{OV5693_8BIT, 0x3798, 0x30},
-	{OV5693_8BIT, 0x3799, 0x41},
-	{OV5693_8BIT, 0x379a, 0x07},
-	{OV5693_8BIT, 0x379b, 0xb0},
-	{OV5693_8BIT, 0x379c, 0x0c},
-	{OV5693_8BIT, 0x37c5, 0x00},
-	{OV5693_8BIT, 0x37c6, 0x00},
-	{OV5693_8BIT, 0x37c7, 0x00},
-	{OV5693_8BIT, 0x37c9, 0x00},
-	{OV5693_8BIT, 0x37ca, 0x00},
-	{OV5693_8BIT, 0x37cb, 0x00},
-	{OV5693_8BIT, 0x37de, 0x00},
-	{OV5693_8BIT, 0x37df, 0x00},
-	{OV5693_8BIT, 0x3800, 0x00},
-	{OV5693_8BIT, 0x3801, 0x00},
-	{OV5693_8BIT, 0x3802, 0x00},
-	{OV5693_8BIT, 0x3804, 0x0a},
-	{OV5693_8BIT, 0x3805, 0x3f},
-	{OV5693_8BIT, 0x3810, 0x00},
-	{OV5693_8BIT, 0x3812, 0x00},
-	{OV5693_8BIT, 0x3823, 0x00},
-	{OV5693_8BIT, 0x3824, 0x00},
-	{OV5693_8BIT, 0x3825, 0x00},
-	{OV5693_8BIT, 0x3826, 0x00},
-	{OV5693_8BIT, 0x3827, 0x00},
-	{OV5693_8BIT, 0x382a, 0x04},
-	{OV5693_8BIT, 0x3a04, 0x06},
-	{OV5693_8BIT, 0x3a05, 0x14},
-	{OV5693_8BIT, 0x3a06, 0x00},
-	{OV5693_8BIT, 0x3a07, 0xfe},
-	{OV5693_8BIT, 0x3b00, 0x00},
-	{OV5693_8BIT, 0x3b02, 0x00},
-	{OV5693_8BIT, 0x3b03, 0x00},
-	{OV5693_8BIT, 0x3b04, 0x00},
-	{OV5693_8BIT, 0x3b05, 0x00},
-	{OV5693_8BIT, 0x3e07, 0x20},
-	{OV5693_8BIT, 0x4000, 0x08},
-	{OV5693_8BIT, 0x4001, 0x04},
-	{OV5693_8BIT, 0x4002, 0x45},
-	{OV5693_8BIT, 0x4004, 0x08},
-	{OV5693_8BIT, 0x4005, 0x18},
-	{OV5693_8BIT, 0x4006, 0x20},
-	{OV5693_8BIT, 0x4008, 0x24},
-	{OV5693_8BIT, 0x4009, 0x10},
-	{OV5693_8BIT, 0x400c, 0x00},
-	{OV5693_8BIT, 0x400d, 0x00},
-	{OV5693_8BIT, 0x4058, 0x00},
-	{OV5693_8BIT, 0x404e, 0x37},
-	{OV5693_8BIT, 0x404f, 0x8f},
-	{OV5693_8BIT, 0x4058, 0x00},
-	{OV5693_8BIT, 0x4101, 0xb2},
-	{OV5693_8BIT, 0x4303, 0x00},
-	{OV5693_8BIT, 0x4304, 0x08},
-	{OV5693_8BIT, 0x4307, 0x31},
-	{OV5693_8BIT, 0x4311, 0x04},
-	{OV5693_8BIT, 0x4315, 0x01},
-	{OV5693_8BIT, 0x4511, 0x05},
-	{OV5693_8BIT, 0x4512, 0x01},
-	{OV5693_8BIT, 0x4806, 0x00},
-	{OV5693_8BIT, 0x4816, 0x52},
-	{OV5693_8BIT, 0x481f, 0x30},
-	{OV5693_8BIT, 0x4826, 0x2c},
-	{OV5693_8BIT, 0x4831, 0x64},
-	{OV5693_8BIT, 0x4d00, 0x04},
-	{OV5693_8BIT, 0x4d01, 0x71},
-	{OV5693_8BIT, 0x4d02, 0xfd},
-	{OV5693_8BIT, 0x4d03, 0xf5},
-	{OV5693_8BIT, 0x4d04, 0x0c},
-	{OV5693_8BIT, 0x4d05, 0xcc},
-	{OV5693_8BIT, 0x4837, 0x0a},
-	{OV5693_8BIT, 0x5000, 0x06},
-	{OV5693_8BIT, 0x5001, 0x01},
-	{OV5693_8BIT, 0x5003, 0x20},
-	{OV5693_8BIT, 0x5046, 0x0a},
-	{OV5693_8BIT, 0x5013, 0x00},
-	{OV5693_8BIT, 0x5046, 0x0a},
-	{OV5693_8BIT, 0x5780, 0x1c},
-	{OV5693_8BIT, 0x5786, 0x20},
-	{OV5693_8BIT, 0x5787, 0x10},
-	{OV5693_8BIT, 0x5788, 0x18},
-	{OV5693_8BIT, 0x578a, 0x04},
-	{OV5693_8BIT, 0x578b, 0x02},
-	{OV5693_8BIT, 0x578c, 0x02},
-	{OV5693_8BIT, 0x578e, 0x06},
-	{OV5693_8BIT, 0x578f, 0x02},
-	{OV5693_8BIT, 0x5790, 0x02},
-	{OV5693_8BIT, 0x5791, 0xff},
-	{OV5693_8BIT, 0x5842, 0x01},
-	{OV5693_8BIT, 0x5843, 0x2b},
-	{OV5693_8BIT, 0x5844, 0x01},
-	{OV5693_8BIT, 0x5845, 0x92},
-	{OV5693_8BIT, 0x5846, 0x01},
-	{OV5693_8BIT, 0x5847, 0x8f},
-	{OV5693_8BIT, 0x5848, 0x01},
-	{OV5693_8BIT, 0x5849, 0x0c},
-	{OV5693_8BIT, 0x5e00, 0x00},
-	{OV5693_8BIT, 0x5e10, 0x0c},
-	{OV5693_8BIT, 0x0100, 0x00},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-/*
- * 654x496 30fps 17ms VBlanking 2lane 10Bit (Scaling)
- */
-static struct ov5693_reg const ov5693_654x496[] = {
-	{OV5693_8BIT, 0x3501, 0x3d},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe6},
-	{OV5693_8BIT, 0x3709, 0xc7},
-	{OV5693_8BIT, 0x3803, 0x00},
-	{OV5693_8BIT, 0x3806, 0x07},
-	{OV5693_8BIT, 0x3807, 0xa3},
-	{OV5693_8BIT, 0x3808, 0x02},
-	{OV5693_8BIT, 0x3809, 0x90},
-	{OV5693_8BIT, 0x380a, 0x01},
-	{OV5693_8BIT, 0x380b, 0xf0},
-	{OV5693_8BIT, 0x380c, 0x0a},
-	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07},
-	{OV5693_8BIT, 0x380f, 0xc0},
-	{OV5693_8BIT, 0x3811, 0x08},
-	{OV5693_8BIT, 0x3813, 0x02},
-	{OV5693_8BIT, 0x3814, 0x31},
-	{OV5693_8BIT, 0x3815, 0x31},
-	{OV5693_8BIT, 0x3820, 0x04},
-	{OV5693_8BIT, 0x3821, 0x1f},
-	{OV5693_8BIT, 0x5002, 0x80},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-static struct ov5693_reg const ov5693_736x496[] = {
-	{OV5693_8BIT, 0x3501, 0x3d},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe6},
-	{OV5693_8BIT, 0x3709, 0xc7},
-	{OV5693_8BIT, 0x3803, 0x68},
-	{OV5693_8BIT, 0x3806, 0x07},
-	{OV5693_8BIT, 0x3807, 0x3b},
-	{OV5693_8BIT, 0x3808, 0x02},
-	{OV5693_8BIT, 0x3809, 0xe0},
-	{OV5693_8BIT, 0x380a, 0x01},
-	{OV5693_8BIT, 0x380b, 0xf0},
-	{OV5693_8BIT, 0x380c, 0x0a}, //hts
-	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07}, //vts
-	{OV5693_8BIT, 0x380f, 0xc0},
-	{OV5693_8BIT, 0x3811, 0x08},
-	{OV5693_8BIT, 0x3813, 0x02},
-	{OV5693_8BIT, 0x3814, 0x31},
-	{OV5693_8BIT, 0x3815, 0x31},
-	{OV5693_8BIT, 0x3820, 0x04},
-	{OV5693_8BIT, 0x3821, 0x1f},
-	{OV5693_8BIT, 0x5002, 0x80},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-/*
-static struct ov5693_reg const ov5693_736x496[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe6},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3803, 0x00},
-	{OV5693_8BIT, 0x3806, 0x07},
-	{OV5693_8BIT, 0x3807, 0xa3},
-	{OV5693_8BIT, 0x3808, 0x02},
-	{OV5693_8BIT, 0x3809, 0xe0},
-	{OV5693_8BIT, 0x380a, 0x01},
-	{OV5693_8BIT, 0x380b, 0xf0},
-	{OV5693_8BIT, 0x380c, 0x0d}, //hts
-	{OV5693_8BIT, 0x380d, 0xb0},
-	{OV5693_8BIT, 0x380e, 0x05}, //vts
-	{OV5693_8BIT, 0x380f, 0xf2},
-	{OV5693_8BIT, 0x3811, 0x08},
-	{OV5693_8BIT, 0x3813, 0x02},
-	{OV5693_8BIT, 0x3814, 0x31},
-	{OV5693_8BIT, 0x3815, 0x31},
-	{OV5693_8BIT, 0x3820, 0x01},
-	{OV5693_8BIT, 0x3821, 0x1f},
-	{OV5693_8BIT, 0x5002, 0x00},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-*/
-/*
- * 976x556 30fps 8.8ms VBlanking 2lane 10Bit (Scaling)
- */
-static struct ov5693_reg const ov5693_976x556[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe2},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3803, 0xf0},
-	{OV5693_8BIT, 0x3806, 0x06},
-	{OV5693_8BIT, 0x3807, 0xa7},
-	{OV5693_8BIT, 0x3808, 0x03},
-	{OV5693_8BIT, 0x3809, 0xd0},
-	{OV5693_8BIT, 0x380a, 0x02},
-	{OV5693_8BIT, 0x380b, 0x2C},
-	{OV5693_8BIT, 0x380c, 0x0a},
-	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07},
-	{OV5693_8BIT, 0x380f, 0xc0},
-	{OV5693_8BIT, 0x3811, 0x10},
-	{OV5693_8BIT, 0x3813, 0x02},
-	{OV5693_8BIT, 0x3814, 0x11},
-	{OV5693_8BIT, 0x3815, 0x11},
-	{OV5693_8BIT, 0x3820, 0x00},
-	{OV5693_8BIT, 0x3821, 0x1e},
-	{OV5693_8BIT, 0x5002, 0x80},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-static struct ov5693_reg const ov5693_1296x736[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe6},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3803, 0x00},
-	{OV5693_8BIT, 0x3806, 0x07},
-	{OV5693_8BIT, 0x3807, 0xa3},
-	{OV5693_8BIT, 0x3808, 0x05},
-	{OV5693_8BIT, 0x3809, 0x10},
-	{OV5693_8BIT, 0x380a, 0x02},
-	{OV5693_8BIT, 0x380b, 0xe0},
-	{OV5693_8BIT, 0x380c, 0x0d}, //hts
-	{OV5693_8BIT, 0x380d, 0xb0},
-	{OV5693_8BIT, 0x380e, 0x05}, //vts
-	{OV5693_8BIT, 0x380f, 0xf2},
-	{OV5693_8BIT, 0x3811, 0x08},
-	{OV5693_8BIT, 0x3813, 0x02},
-	{OV5693_8BIT, 0x3814, 0x31},
-	{OV5693_8BIT, 0x3815, 0x31},
-	{OV5693_8BIT, 0x3820, 0x01},
-	{OV5693_8BIT, 0x3821, 0x1f},
-	{OV5693_8BIT, 0x5002, 0x00},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-static struct ov5693_reg const ov5693_1636p_30fps[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe2},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3803, 0xf0},
-	{OV5693_8BIT, 0x3806, 0x06},
-	{OV5693_8BIT, 0x3807, 0xa7},
-	{OV5693_8BIT, 0x3808, 0x06},
-	{OV5693_8BIT, 0x3809, 0x64},
-	{OV5693_8BIT, 0x380a, 0x04},
-	{OV5693_8BIT, 0x380b, 0x48},
-	{OV5693_8BIT, 0x380c, 0x0a}, //hts
-	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07}, //vts
-	{OV5693_8BIT, 0x380f, 0xc0},
-	{OV5693_8BIT, 0x3811, 0x02},
-	{OV5693_8BIT, 0x3813, 0x02},
-	{OV5693_8BIT, 0x3814, 0x11},
-	{OV5693_8BIT, 0x3815, 0x11},
-	{OV5693_8BIT, 0x3820, 0x00},
-	{OV5693_8BIT, 0x3821, 0x1e},
-	{OV5693_8BIT, 0x5002, 0x80},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-static struct ov5693_reg const ov5693_1616x1216_30fps[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x80},
-	{OV5693_8BIT, 0x3708, 0xe2},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3800, 0x00},	/*{3800,3801} Array X start*/
-	{OV5693_8BIT, 0x3801, 0x08},	/* 04 //{3800,3801} Array X start*/
-	{OV5693_8BIT, 0x3802, 0x00},	/*{3802,3803} Array Y start*/
-	{OV5693_8BIT, 0x3803, 0x04},	/* 00  //{3802,3803} Array Y start*/
-	{OV5693_8BIT, 0x3804, 0x0a},	/*{3804,3805} Array X end*/
-	{OV5693_8BIT, 0x3805, 0x37},	/* 3b  //{3804,3805} Array X end*/
-	{OV5693_8BIT, 0x3806, 0x07},	/*{3806,3807} Array Y end*/
-	{OV5693_8BIT, 0x3807, 0x9f},	/* a3  //{3806,3807} Array Y end*/
-	{OV5693_8BIT, 0x3808, 0x06},	/*{3808,3809} Final output H size*/
-	{OV5693_8BIT, 0x3809, 0x50},	/*{3808,3809} Final output H size*/
-	{OV5693_8BIT, 0x380a, 0x04},	/*{380a,380b} Final output V size*/
-	{OV5693_8BIT, 0x380b, 0xc0},	/*{380a,380b} Final output V size*/
-	{OV5693_8BIT, 0x380c, 0x0a},	/*{380c,380d} HTS*/
-	{OV5693_8BIT, 0x380d, 0x80},	/*{380c,380d} HTS*/
-	{OV5693_8BIT, 0x380e, 0x07},	/*{380e,380f} VTS*/
-	{OV5693_8BIT, 0x380f, 0xc0},	/* bc	//{380e,380f} VTS*/
-	{OV5693_8BIT, 0x3810, 0x00},	/*{3810,3811} windowing X offset*/
-	{OV5693_8BIT, 0x3811, 0x10},	/*{3810,3811} windowing X offset*/
-	{OV5693_8BIT, 0x3812, 0x00},	/*{3812,3813} windowing Y offset*/
-	{OV5693_8BIT, 0x3813, 0x06},	/*{3812,3813} windowing Y offset*/
-	{OV5693_8BIT, 0x3814, 0x11},	/*X subsample control*/
-	{OV5693_8BIT, 0x3815, 0x11},	/*Y subsample control*/
-	{OV5693_8BIT, 0x3820, 0x00},	/*FLIP/Binnning control*/
-	{OV5693_8BIT, 0x3821, 0x1e},	/*MIRROR control*/
-	{OV5693_8BIT, 0x5002, 0x00},
-	{OV5693_8BIT, 0x5041, 0x84},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-
-/*
- * 1940x1096 30fps 8.8ms VBlanking 2lane 10bit (Scaling)
- */
-static struct ov5693_reg const ov5693_1940x1096[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe2},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3803, 0xf0},
-	{OV5693_8BIT, 0x3806, 0x06},
-	{OV5693_8BIT, 0x3807, 0xa7},
-	{OV5693_8BIT, 0x3808, 0x07},
-	{OV5693_8BIT, 0x3809, 0x94},
-	{OV5693_8BIT, 0x380a, 0x04},
-	{OV5693_8BIT, 0x380b, 0x48},
-	{OV5693_8BIT, 0x380c, 0x0a},
-	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07},
-	{OV5693_8BIT, 0x380f, 0xc0},
-	{OV5693_8BIT, 0x3811, 0x02},
-	{OV5693_8BIT, 0x3813, 0x02},
-	{OV5693_8BIT, 0x3814, 0x11},
-	{OV5693_8BIT, 0x3815, 0x11},
-	{OV5693_8BIT, 0x3820, 0x00},
-	{OV5693_8BIT, 0x3821, 0x1e},
-	{OV5693_8BIT, 0x5002, 0x80},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-static struct ov5693_reg const ov5693_2592x1456_30fps[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe2},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3800, 0x00},
-	{OV5693_8BIT, 0x3801, 0x00},
-	{OV5693_8BIT, 0x3802, 0x00},
-	{OV5693_8BIT, 0x3803, 0xf0},
-	{OV5693_8BIT, 0x3804, 0x0a},
-	{OV5693_8BIT, 0x3805, 0x3f},
-	{OV5693_8BIT, 0x3806, 0x06},
-	{OV5693_8BIT, 0x3807, 0xa4},
-	{OV5693_8BIT, 0x3808, 0x0a},
-	{OV5693_8BIT, 0x3809, 0x20},
-	{OV5693_8BIT, 0x380a, 0x05},
-	{OV5693_8BIT, 0x380b, 0xb0},
-	{OV5693_8BIT, 0x380c, 0x0a},
-	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07},
-	{OV5693_8BIT, 0x380f, 0xc0},
-	{OV5693_8BIT, 0x3811, 0x10},
-	{OV5693_8BIT, 0x3813, 0x00},
-	{OV5693_8BIT, 0x3814, 0x11},
-	{OV5693_8BIT, 0x3815, 0x11},
-	{OV5693_8BIT, 0x3820, 0x00},
-	{OV5693_8BIT, 0x3821, 0x1e},
-	{OV5693_8BIT, 0x5002, 0x00},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-/*
- * 2592x1944 30fps 0.6ms VBlanking 2lane 10Bit
- */
-static struct ov5693_reg const ov5693_2592x1944_30fps[] = {
-	{OV5693_8BIT, 0x3501, 0x7b},
-	{OV5693_8BIT, 0x3502, 0x00},
-	{OV5693_8BIT, 0x3708, 0xe2},
-	{OV5693_8BIT, 0x3709, 0xc3},
-	{OV5693_8BIT, 0x3803, 0x00},
-	{OV5693_8BIT, 0x3806, 0x07},
-	{OV5693_8BIT, 0x3807, 0xa3},
-	{OV5693_8BIT, 0x3808, 0x0a},
-	{OV5693_8BIT, 0x3809, 0x20},
-	{OV5693_8BIT, 0x380a, 0x07},
-	{OV5693_8BIT, 0x380b, 0x98},
-	{OV5693_8BIT, 0x380c, 0x0a},
-	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07},
-	{OV5693_8BIT, 0x380f, 0xc0},
-	{OV5693_8BIT, 0x3811, 0x10},
-	{OV5693_8BIT, 0x3813, 0x00},
-	{OV5693_8BIT, 0x3814, 0x11},
-	{OV5693_8BIT, 0x3815, 0x11},
-	{OV5693_8BIT, 0x3820, 0x00},
-	{OV5693_8BIT, 0x3821, 0x1e},
-	{OV5693_8BIT, 0x5002, 0x00},
-	{OV5693_8BIT, 0x0100, 0x01},
-	{OV5693_TOK_TERM, 0, 0}
-};
-
-struct ov5693_resolution ov5693_res_preview[] = {
-	{
-		.desc = "ov5693_1616x1216_30fps",
-		.width = 1616,
-		.height = 1216,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_1616x1216_30fps,
-	},
-	{
-		.desc = "ov5693_5M_30fps",
-		.width = 2592,
-		.height = 1456,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_2592x1456_30fps,
-	},
-	{
-		.desc = "ov5693_5M_30fps",
-		.width = 2592,
-		.height = 1944,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_2592x1944_30fps,
-	},
-};
-#define N_RES_PREVIEW (ARRAY_SIZE(ov5693_res_preview))
-
-struct ov5693_resolution ov5693_res_still[] = {
-	{
-		.desc = "ov5693_1616x1216_30fps",
-		.width = 1616,
-		.height = 1216,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_1616x1216_30fps,
-	},
-	{
-		.desc = "ov5693_5M_30fps",
-		.width = 2592,
-		.height = 1456,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_2592x1456_30fps,
-	},
-	{
-		.desc = "ov5693_5M_30fps",
-		.width = 2592,
-		.height = 1944,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_2592x1944_30fps,
-	},
-};
-#define N_RES_STILL (ARRAY_SIZE(ov5693_res_still))
-
-struct ov5693_resolution ov5693_res_video[] = {
-	{
-		.desc = "ov5693_736x496_30fps",
-		.width = 736,
-		.height = 496,
-		.fps = 30,
-		.pix_clk_freq = 160,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-		.bin_mode = 1,
-		.regs = ov5693_736x496,
-	},
-	{
-		.desc = "ov5693_1296x736_30fps",
-		.width = 1296,
-		.height = 736,
-		.fps = 30,
-		.pix_clk_freq = 160,
-		.used = 0,
-		.pixels_per_line = 3504,
-		.lines_per_frame = 1522,
-		.bin_factor_x = 2,
-		.bin_factor_y = 2,
-		.bin_mode = 1,
-		.regs = ov5693_1296x736,
-	},
-	{
-		.desc = "ov5693_1636P_30fps",
-		.width = 1636,
-		.height = 1096,
-		.fps = 30,
-		.pix_clk_freq = 160,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_1636p_30fps,
-	},
-	{
-		.desc = "ov5693_1080P_30fps",
-		.width = 1940,
-		.height = 1096,
-		.fps = 30,
-		.pix_clk_freq = 160,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_1940x1096,
-	},
-	{
-		.desc = "ov5693_5M_30fps",
-		.width = 2592,
-		.height = 1456,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_2592x1456_30fps,
-	},
-	{
-		.desc = "ov5693_5M_30fps",
-		.width = 2592,
-		.height = 1944,
-		.pix_clk_freq = 160,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 2688,
-		.lines_per_frame = 1984,
-		.bin_factor_x = 1,
-		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.regs = ov5693_2592x1944_30fps,
-	},
-};
-#define N_RES_VIDEO (ARRAY_SIZE(ov5693_res_video))
-
-static struct ov5693_resolution *ov5693_res = ov5693_res_preview;
-static int N_RES = N_RES_PREVIEW;
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig
new file mode 100644
index 0000000..9fb1bff
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig
@@ -0,0 +1,11 @@
+config VIDEO_OV5693
+       tristate "Omnivision ov5693 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Micron
+         ov5693 5 Mpixel camera.
+
+         ov5693 is video camera sensor.
+
+         It currently only works with the atomisp driver.
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile
new file mode 100644
index 0000000..d8a63fa
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_VIDEO_OV5693) += ov569x.o
+
+ov569x-objs := ov5693.o ad5823.o
+
+ccflags-y += -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
index e1d02a8..db31578 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
@@ -151,7 +151,7 @@ int ad5823_t_focus_abs(struct v4l2_subdev *sd, s32 value)
 	int ret;
 
 	value = min(value, AD5823_MAX_FOCUS_POS);
-	ret = ad5823_t_focus_vcm(sd, AD5823_MAX_FOCUS_POS - value);
+	ret = ad5823_t_focus_vcm(sd, value);
 	if (ret == 0) {
 		ad5823_dev.number_of_steps = value - ad5823_dev.focus;
 		ad5823_dev.focus = value;
@@ -218,8 +218,8 @@ int ad5823_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
 
 int ad5823_vcm_init(struct v4l2_subdev *sd)
 {
-	/* set vcm mode to ARC RES0.5 */
-	ad5823_dev.vcm_mode = AD5823_ARC_RES1;
+	/* set vcm mode to DIRECT */
+	ad5823_dev.vcm_mode = AD5823_DIRECT;
 	ad5823_dev.platform_data = camera_get_af_platform_data();
 	return ad5823_dev.platform_data ? 0 : -ENODEV;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h
new file mode 100644
index 0000000..794f91f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h
@@ -0,0 +1,92 @@
+/*
+ * Support for AD5823 VCM.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __AD5823_H__
+#define __AD5823_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+
+
+#define AD5823_VCM_ADDR	0x0c
+
+#define AD5823_REG_RESET		0x01
+#define AD5823_REG_MODE			0x02
+#define AD5823_REG_VCM_MOVE_TIME	0x03
+#define AD5823_REG_VCM_CODE_MSB		0x04
+#define AD5823_REG_VCM_CODE_LSB		0x05
+#define AD5823_REG_VCM_THRESHOLD_MSB	0x06
+#define AD5823_REG_VCM_THRESHOLD_LSB	0x07
+
+#define AD5823_REG_LENGTH		0x1
+
+#define AD5823_RING_CTRL_ENABLE		0x04
+#define AD5823_RING_CTRL_DISABLE	0x00
+
+#define AD5823_RESONANCE_PERIOD		100000
+#define AD5823_RESONANCE_COEF		512
+#define AD5823_HIGH_FREQ_RANGE		0x80
+
+#define VCM_CODE_MSB_MASK		0xfc
+
+enum ad5823_tok_type {
+	AD5823_8BIT  = 0x1,
+	AD5823_16BIT = 0x2,
+};
+
+enum ad5823_vcm_mode {
+	AD5823_ARC_RES0 = 0x0,	/* Actuator response control RES1 */
+	AD5823_ARC_RES1 = 0x1,	/* Actuator response control RES0.5 */
+	AD5823_ARC_RES2 = 0x2,	/* Actuator response control RES2 */
+	AD5823_ESRC = 0x3,	/* Enhanced slew rate control */
+	AD5823_DIRECT = 0x4,	/* Direct control */
+};
+
+/* ad5823 device structure */
+struct ad5823_device {
+	struct timespec timestamp_t_focus_abs;
+	enum ad5823_vcm_mode vcm_mode;
+	s16 number_of_steps;
+	bool initialized;		/* true if ad5823 is detected */
+	s32 focus;			/* Current focus value */
+	struct timespec focus_time;	/* Time when focus was last time set */
+	__u8 buffer[4];			/* Used for i2c transactions */
+	const struct camera_af_platform_data *platform_data;
+};
+
+#define AD5823_INVALID_CONFIG	0xffffffff
+#define AD5823_MAX_FOCUS_POS	1023
+
+
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+
+int ad5823_vcm_power_up(struct v4l2_subdev *sd);
+int ad5823_vcm_power_down(struct v4l2_subdev *sd);
+int ad5823_vcm_init(struct v4l2_subdev *sd);
+
+int ad5823_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+int ad5823_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+int ad5823_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+int ad5823_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+int ad5823_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
index 3f3bc69..e494183 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
@@ -25,7 +25,6 @@
 #include <linux/gpio.h>
 #include <linux/init.h>
 #include <linux/i2c.h>
-#include <linux/acpi.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/kmod.h>
@@ -40,8 +39,6 @@
 
 #include "ov5693.h"
 
-static const uint32_t ov5693_embedded_effective_size = 28;
-
 /* i2c read/write stuff */
 static int ov5693_read_reg(struct i2c_client *client,
 			   u16 data_length, u16 reg, u16 *val)
@@ -374,22 +371,16 @@ static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
 	u16 vts;
 	int ret;
 
-	/*
-	 * According to spec, the low 4 bits of exposure/gain reg are
-	 * fraction bits, so need to take 4 bits left shift to align
-	 * reg integer bits.
-	 */
-	coarse_itg <<= 4;
-	gain <<= 4;
-
-	ret = ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_VTS_H, &vts);
+	/* group hold start */
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_GROUP_ACCESS, 0);
 	if (ret)
 		return ret;
 
+	vts = dev->ov5693_res[dev->fmt_idx].lines_per_frame;
 	if (coarse_itg + OV5693_INTEGRATION_TIME_MARGIN >= vts)
 		vts = coarse_itg + OV5693_INTEGRATION_TIME_MARGIN;
 
@@ -397,10 +388,12 @@ static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 	if (ret)
 		return ret;
 
-	/* group hold start */
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_GROUP_ACCESS, 0);
-	if (ret)
-		return ret;
+	/*
+	 * According to spec, the low 4 bits of exposure reg are
+	 * fraction bits, so need to take 4 bits left shift to align
+	 * reg integer bits.
+	 */
+	coarse_itg <<= 4;
 
 	/* set exposure */
 	ret = ov5693_write_reg(client, OV5693_8BIT,
@@ -615,12 +608,13 @@ static int ov5693_g_ctrl(struct v4l2_ctrl *ctrl)
 
 static int ov5693_s_ctrl(struct v4l2_ctrl *ctrl)
 {
-	struct ov5693_device *dev = container_of(
-		ctrl->handler, struct ov5693_device, ctrl_handler);
+	struct ov5693_device *dev = NULL;
 	int ret = 0;
 
 	if (!ctrl)
 		return -EINVAL;
+	dev = container_of(
+		ctrl->handler, struct ov5693_device, ctrl_handler);
 
 	switch (ctrl->id) {
 	case V4L2_CID_RUN_MODE:
@@ -914,10 +908,6 @@ static int ov5693_s_mbus_fmt(struct v4l2_subdev *sd,
 	if (ret)
 		dev_err(&client->dev, "failed to get integration_factor\n");
 
-	ov5693_info->metadata_width = fmt->width * 10 / 8;
-	ov5693_info->metadata_height = 1;
-	ov5693_info->metadata_effective_width = &ov5693_embedded_effective_size;
-
 done:
 	mutex_unlock(&dev->input_lock);
 	return ret;
@@ -1052,15 +1042,6 @@ static int ov5693_s_config(struct v4l2_subdev *sd,
 
 	dev->platform_data = platform_data;
 
-	if (dev->platform_data->platform_init) {
-		ret = dev->platform_data->platform_init(client);
-		if (ret) {
-			mutex_unlock(&dev->input_lock);
-			dev_err(&client->dev, "ov5693 platform init err\n");
-			return ret;
-		}
-	}
-
 	ret = power_up(sd);
 	if (ret) {
 		dev_err(&client->dev, "ov5693 power-up err.\n");
@@ -1084,21 +1065,6 @@ static int ov5693_s_config(struct v4l2_subdev *sd,
 		dev_err(&client->dev, "ov5693 power-off err.\n");
 		goto fail_csi_cfg;
 	}
-
-	/* Register the atomisp platform data prior to the ISP module
-	 * load.  Ideally this would be stored as data on the
-	 * subdevices, but this API matches upstream better. */
-	ret = atomisp_register_i2c_module(sd, client, platform_data,
-					  gmin_get_var_int(&client->dev, "CamType",
-						     RAW_CAMERA),
-					  gmin_get_var_int(&client->dev, "CsiPort",
-						     ATOMISP_CAMERA_PORT_PRIMARY));
-	if (ret) {
-		dev_err(&client->dev,
-			"ov5693 atomisp_register_i2c_module failed.\n");
-		goto fail_csi_cfg;
-	}
-
 	mutex_unlock(&dev->input_lock);
 
 	return 0;
@@ -1108,8 +1074,6 @@ fail_csi_cfg:
 fail_power_on:
 	power_down(sd);
 	dev_err(&client->dev, "sensor power-gating failed\n");
-	if (dev->platform_data->platform_deinit)
-		dev->platform_data->platform_deinit();
 	mutex_unlock(&dev->input_lock);
 	return ret;
 }
@@ -1403,9 +1367,6 @@ static int ov5693_remove(struct i2c_client *client)
 	media_entity_cleanup(&dev->sd.entity);
 	devm_kfree(&client->dev, dev);
 
-	if (dev->platform_data->platform_deinit)
-		dev->platform_data->platform_deinit();
-
 	return 0;
 }
 
@@ -1415,7 +1376,6 @@ static int ov5693_probe(struct i2c_client *client,
 	struct ov5693_device *dev;
 	int i;
 	int ret;
-	void *pdata = client->dev.platform_data;
 
 	dev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
@@ -1434,17 +1394,9 @@ static int ov5693_probe(struct i2c_client *client,
 
 	v4l2_i2c_subdev_init(&(dev->sd), client, &ov5693_ops);
 
-	if (!pdata && ACPI_COMPANION(&client->dev)) {
-		/*
-		 * If no SFI firmware, try to grab the platform struct
-		 * directly and configure via ACPI/EFIvars instead
-		 */
-		pdata = ov5693_platform_data(NULL);
-	}
-
-	if(pdata) {
+	if (client->dev.platform_data) {
 		ret = ov5693_s_config(&dev->sd, client->irq,
-				       pdata);
+				       client->dev.platform_data);
 		if (ret)
 			goto out_free;
 	}
@@ -1495,19 +1447,11 @@ out_free:
 	return ret;
 }
 
-static struct acpi_device_id ov5693_acpi_match[] = {
-	{"INT33BE"},
-	{},
-};
-
-MODULE_DEVICE_TABLE(acpi, ov5693_acpi_match);
 MODULE_DEVICE_TABLE(i2c, ov5693_id);
-
 static struct i2c_driver ov5693_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
 		.name = OV5693_NAME,
-		.acpi_match_table = ACPI_PTR(ov5693_acpi_match),
 	},
 	.probe = ov5693_probe,
 	.remove = ov5693_remove,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
old mode 100644
new mode 100755
index f5b3ace..7a68b73
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
@@ -35,8 +35,6 @@
 #include <linux/v4l2-mediabus.h>
 
 #include <linux/atomisp_platform.h>
-#include <linux/atomisp_gmin_platform.h>
-
 #include "ad5823.h"
 
 #define OV5693_NAME		"ov5693"
@@ -81,7 +79,7 @@
 #define OV5693_FINE_INTG_TIME_MIN 0
 #define OV5693_FINE_INTG_TIME_MAX_MARGIN 0
 #define OV5693_COARSE_INTG_TIME_MIN 1
-#define OV5693_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
+#define OV5693_COARSE_INTG_TIME_MAX_MARGIN 6
 #define OV5693_INTEGRATION_TIME_MARGIN	8
 
 #define OV5693_BIN_FACTOR_MAX	2
@@ -116,8 +114,6 @@
 #define OV5693_START_STREAMING			0x01
 #define OV5693_STOP_STREAMING			0x00
 
-void *ov5693_platform_data(void *info);
-
 struct ov5693_vcm {
 	int (*power_up)(struct v4l2_subdev *sd);
 	int (*power_down)(struct v4l2_subdev *sd);
@@ -230,7 +226,6 @@ static struct ov5693_reg const ov5693_init_setting[] = {
 	{OV5693_8BIT, 0x3016, 0xf0},
 	{OV5693_8BIT, 0x3017, 0xf0},
 	{OV5693_8BIT, 0x3018, 0xf0},
-	{OV5693_8BIT, 0x3019, 0x10},
 	{OV5693_8BIT, 0x301b, 0xb4},
 	{OV5693_8BIT, 0x301d, 0x02},
 	{OV5693_8BIT, 0x3021, 0x00},
@@ -408,7 +403,7 @@ static struct ov5693_reg const ov5693_init_setting[] = {
 	{OV5693_8BIT, 0x4101, 0xb2},
 	{OV5693_8BIT, 0x4303, 0x00},
 	{OV5693_8BIT, 0x4304, 0x08},
-	{OV5693_8BIT, 0x4307, 0x31},
+	{OV5693_8BIT, 0x4307, 0x30},
 	{OV5693_8BIT, 0x4311, 0x04},
 	{OV5693_8BIT, 0x4315, 0x01},
 	{OV5693_8BIT, 0x4511, 0x05},
@@ -684,7 +679,7 @@ struct ov5693_resolution ov5693_res_preview[] = {
 		.width = 656,
 		.height = 496,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 2688,
 		.lines_per_frame = 1984,
@@ -699,7 +694,7 @@ struct ov5693_resolution ov5693_res_preview[] = {
 		.width = 1940,
 		.height = 1096,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 3688,
 		.lines_per_frame = 2984,
@@ -714,7 +709,7 @@ struct ov5693_resolution ov5693_res_preview[] = {
 		.width = 2592,
 		.height = 1944,
 		.fps = 15,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 3688,
 		.lines_per_frame = 3968,
@@ -733,7 +728,7 @@ struct ov5693_resolution ov5693_res_still[] = {
 		.width = 656,
 		.height = 496,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 2688,
 		.lines_per_frame = 1984,
@@ -748,7 +743,7 @@ struct ov5693_resolution ov5693_res_still[] = {
 		.width = 1940,
 		.height = 1096,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 3688,
 		.lines_per_frame = 2984,
@@ -763,7 +758,7 @@ struct ov5693_resolution ov5693_res_still[] = {
 		.width = 2592,
 		.height = 1944,
 		.fps = 15,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 3688,
 		.lines_per_frame = 3968,
@@ -782,7 +777,7 @@ struct ov5693_resolution ov5693_res_video[] = {
 		.width = 656,
 		.height = 496,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 2688,
 		.lines_per_frame = 1984,
@@ -797,7 +792,7 @@ struct ov5693_resolution ov5693_res_video[] = {
 		.width = 736,
 		.height = 496,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 2688,
 		.lines_per_frame = 1984,
@@ -812,7 +807,7 @@ struct ov5693_resolution ov5693_res_video[] = {
 		.width = 1296,
 		.height = 736,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 2688,
 		.lines_per_frame = 1984,
@@ -827,7 +822,7 @@ struct ov5693_resolution ov5693_res_video[] = {
 		.width = 1940,
 		.height = 1096,
 		.fps = 30,
-		.pix_clk_freq = 81,
+		.pix_clk_freq = 160,
 		.used = 0,
 		.pixels_per_line = 3688,
 		.lines_per_frame = 2984,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov680.c b/drivers/external_drivers/camera/drivers/media/i2c/ov680.c
index d9f99ba..8065a76 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov680.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov680.c
@@ -274,33 +274,60 @@ static int ov680_read_sensor(struct v4l2_subdev *sd, int sid,
 	ret = ov680_i2c_write_reg(sd, OV680_CMD_PARAMETER_2, reg & 0xff);
 	if (ret)
 		dev_dbg(&client->dev, "4%s - reg = %x failed\n", __func__, reg);
-	msleep(20);
 	ret = ov680_i2c_write_reg(sd, OV680_CMD_CIR_REG,
 				  OV680_CMD_CIR_SENSOR_ACCESS_STATE);
 	if (ret)
 		dev_dbg(&client->dev, "5%s - reg = %x failed\n", __func__, reg);
-	msleep(20);
+	usleep_range(8000, 10000);
 	ret = ov680_i2c_read_reg(sd, OV680_CMD_PARAMETER_4, data);
 	if (ret)
 		dev_dbg(&client->dev, "6%s - reg = %x failed\n", __func__, reg);
-	dev_dbg(&client->dev, "%s - sid = %x, reg = %x, data= %x successfully\n",
+	dev_dbg(&client->dev, "%s - sid = %x, reg = %x, data= %x successful\n",
 		__func__, sid, reg, *data);
 	return ret;
 }
 
+static int ov680_check_sensor_avail(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[2];
+	int ret, i;
+	bool sensor_fail = false;
+	int sid[OV680_MAX_INPUT_SENSOR_NUM] = {
+		OV680_SENSOR_0_ID, OV680_SENSOR_1_ID
+	};
+
+	for (i = 0; i < OV680_MAX_INPUT_SENSOR_NUM; i++) {
+		ret = ov680_read_sensor(sd, sid[i], 0x0000, &data[0]);
+		ret = ov680_read_sensor(sd, sid[i], 0x0001, &data[1]);
+		if (ret || data[0] != OV680_SENSOR_REG0_VAL ||
+		    data[1] != OV680_SENSOR_REG1_VAL) {
+			dev_err(&client->dev, "Subdev OV680 sensor %d with"\
+				" id:0x%x detection failure.\n", i, sid[i]);
+			sensor_fail = true;
+		} else {
+			dev_info(&client->dev,
+				 "Subdev OV680 sensor %d with id:0x%x"\
+				 " detection Successful.\n", i, sid[i]);
+		}
+	}
+
+	return sensor_fail ? -1 : 0;
+}
+
+#ifdef ov680_DUMP_DEBUG
 static int ov680_dump_snr_regs(struct v4l2_subdev *sd)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
 	u8 data;
 
-	/* sensor0 is 0x20, sensor 1 is 6c */
-	int sid = 0x20;
+	int sid = OV680_SENSOR_0_ID;
 	ret = ov680_read_sensor(sd, sid, 0x0000, &data); /* 0x97 */
 	ret = ov680_read_sensor(sd, sid, 0x0001, &data); /* 0x28 */
 	ret = ov680_read_sensor(sd, sid, 0x0100, &data);
 
-	sid = 0x6c;
+	sid = OV680_SENSOR_1_ID;
 	ret = ov680_read_sensor(sd, sid, 0x0000, &data); /* 0x97 */
 	ret = ov680_read_sensor(sd, sid, 0x0001, &data); /* 0x28 */
 
@@ -343,25 +370,99 @@ static int ov680_dump_rx_regs(struct v4l2_subdev *sd)
 	}
 	return 0;
 }
+#endif
+
+static int ov680_write_firmware(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov680_device *dev = to_ov680_device(sd);
+	int count, ret;
+	u16 len;
+	const struct ov680_firmware *ov680_fw_header =
+		(const struct ov680_firmware *)dev->fw->data;
+
+	count = ov680_fw_header->cmd_count;
+	len = count + sizeof(u16); /* 16-bit address + data */
+
+	ret = ov680_i2c_write(client, len, (u8 *)dev->ov680_fw);
+	if (ret)
+		dev_err(&client->dev, "write failure\n");
+
+	return ret;
+}
 
 static int ov680_load_firmware(struct v4l2_subdev *sd)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov680_device *dev = to_ov680_device(sd);
 	int ret;
+	u8 read_value;
+	unsigned int read_timeout = 500;
 
 	dev_info(&client->dev, "Start to load firmware.\n");
 
-	ret = ov680_write_reg_array(sd, dev->ov680_fw);
+	/* Init clock PLL */
+	ret = ov680_write_reg_array(sd, ov680_init_clock_pll);
 	if (ret) {
-		dev_dbg(&client->dev, "%s - debug fw load failed\n", __func__);
+		dev_err(&client->dev, "%s - clock init failed\n", __func__);
 		return ret;
 	}
 
-	dev_info(&client->dev, "firmware load successfully.\n");
-	ov680_dump_res_regs(sd);
-	ov680_dump_rx_regs(sd);
+	/* Change clock for FW loading */
+	ret = ov680_write_reg_array(sd, ov680_dw_fw_change_pll);
+	if (ret) {
+		dev_err(&client->dev, "%s - clock set failed\n", __func__);
+		return ret;
+	}
 
+	/* Load FW */
+	ret = ov680_write_firmware(sd);
+	if (ret) {
+		dev_err(&client->dev, "%s - FW load failed\n", __func__);
+		return ret;
+	}
+
+	/* Restore clock for FW loading */
+	ret = ov680_write_reg_array(sd, ov680_dw_fw_change_back_pll);
+	if (ret) {
+		dev_err(&client->dev, "%s - clk restore failed\n", __func__);
+		return ret;
+	}
+
+	/* Check for readiness */
+	while (read_timeout) {
+		ret = ov680_i2c_read_reg(sd, REG_SC_66, &read_value);
+		if (ret) {
+			dev_err(&client->dev,
+				"%s - status check failed\n", __func__);
+			return ret;
+		} else if (REG_SC_66_GLOBAL_READY == read_value) {
+			break;
+		} else {
+			usleep_range(1000, 2000);
+			dev_dbg(&client->dev,
+				"%s - status check val: %x\n", __func__,
+				read_value);
+			--read_timeout;
+		}
+	}
+
+	if (0 == read_timeout) {
+		dev_err(&client->dev,
+			"%s - status check timed out\n", __func__);
+		return -EBUSY;
+	}
+
+	if (dev->probed) {
+		/* turn embedded line on */
+		ret = ov680_write_reg_array(sd, ov680_720p_2s_embedded_line);
+		if (ret) {
+			dev_err(&client->dev, "%s - turn embedded on failed\n",
+					__func__);
+			return ret;
+		}
+	}
+	dev_info(&client->dev, "firmware load successfully.\n");
 	return ret;
 }
 
@@ -372,6 +473,23 @@ static int __ov680_s_power(struct v4l2_subdev *sd, int on, int load_fw)
 	int ret;
 
 	dev_info(&client->dev, "%s - on-%d.\n", __func__, on);
+
+	/* clock control */
+	/*
+	 * WA: If the app did not disable the clock before exit,
+	 * driver has to disable it firstly, or the clock cannot
+	 * be enabled any more after device enter sleep.
+	 */
+	if (dev->power_on && on)
+		dev->platform_data->flisclk_ctrl(sd, 0);
+
+	ret = dev->platform_data->flisclk_ctrl(sd, on);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s - set clock error.\n", __func__);
+		return ret;
+	}
+
 	ret = dev->platform_data->power_ctrl(sd, on);
 	if (ret) {
 		dev_err(&client->dev,
@@ -387,6 +505,19 @@ static int __ov680_s_power(struct v4l2_subdev *sd, int on, int load_fw)
 	}
 
 	dev->power_on = on;
+	if (on) {
+		/* Load firmware after power on. */
+		ret = ov680_load_firmware(sd);
+		if (ret)
+			dev_err(&client->dev,
+				"ov680_load_firmware failed. ret=%d\n", ret);
+#ifdef OV680_DUMP_DEBUG
+		ov680_dump_rx_regs(sd);
+		ov680_dump_res_regs(sd);
+		ov680_dump_snr_regs(sd);
+#endif
+	}
+
 	return ret;
 }
 
@@ -435,15 +566,21 @@ static int ov680_s_config(struct v4l2_subdev *sd, void *pdata)
 	if (ret)
 		goto fail_config;
 
-	msleep(200);
 	/* Detect for OV680 */
 	ret = ov680_i2c_read_reg(sd, REG_SC_00, &reg_val);
-	if (ret || (reg_val != 0x1E)) { /* defalut value of REG_SC_00*/
+	if (ret) {
+		dev_err(&client->dev, "ov680_i2c_read_reg fails: %d\n", ret);
+		goto fail_config;
+	}
+
+	if (reg_val != 0x1E) { /* default value of REG_SC_00*/
+		ret = -EINVAL;
 		dev_err(&client->dev,
-			"reg SC_00 does no match with default value 0x1E. ret=%d sc_00=0x%04x\n",
-			ret, reg_val);
+			"register value doesn't match: 0x1E != 0x%02x\n",
+			reg_val);
 		goto fail_config;
 	}
+
 	/* reg access test purpose */
 	ret = ov680_i2c_write_reg(sd, REG_SC_00, 0x03);
 	if (ret) {
@@ -453,14 +590,28 @@ static int ov680_s_config(struct v4l2_subdev *sd, void *pdata)
 
 	ret = ov680_i2c_read_reg(sd, REG_SC_00, &reg_val);
 
-	if (ret || (reg_val != 0x03)) { /* defalut value of REG_SC_00*/
+	if (ret) {
+		dev_err(&client->dev, "ov680_i2c_read_reg fails: %d\n", ret);
+		goto fail_config;
+	}
+
+	if (reg_val != 0x03) {
+		ret = -EINVAL;
 		dev_err(&client->dev,
-			"reg SC_00 is incorrect. ret=%d sc_00=0x%04x\n",
-			ret, reg_val);
+			"register value doesn't match: 0x03 != 0x%02x\n",
+			reg_val);
 		goto fail_config;
 	}
+
 	ov680_i2c_write_reg(sd, REG_SC_00, 0x1E); /* write back value */
-	dev_info(&client->dev, "OV680 Chip was detected with reg access ok\n");
+	dev_info(&client->dev, "Subdev OV680 Chip detect with reg access ok\n");
+
+	/* detect the input sensor */
+	ret = ov680_check_sensor_avail(sd);
+	if (ret) {
+		dev_err(&client->dev, "detect sensors failed. ret=%d\n", ret);
+		goto fail_config;
+	}
 
 	mipi_info = v4l2_get_subdev_hostdata(sd);
 	if (!mipi_info) {
@@ -477,7 +628,7 @@ static int ov680_s_config(struct v4l2_subdev *sd, void *pdata)
 		dev_dbg(&client->dev, "ov680_s_config - bayer output\n");
 		dev->bayer_fmt = 1;
 		dev->mbus_pixelcode = V4L2_MBUS_FMT_SBGGR10_1X10;
-	 }
+	}
 
 	ret = __ov680_s_power(sd, 0, 0);
 	if (ret)
@@ -622,6 +773,26 @@ static int ov680_set_mbus_fmt(struct v4l2_subdev *sd,
 		dev_dbg(&client->dev, "%s - fw_index failed\n", __func__);
 		ret = -EINVAL;
 	}
+
+	switch (ov680_info->input_format) {
+	case ATOMISP_INPUT_FORMAT_YUV422_8:
+		ov680_info->metadata_width = fmt->width * 2;
+		break;
+	case ATOMISP_INPUT_FORMAT_RAW_10:
+		ov680_info->metadata_width = fmt->width * 10 / 8;
+		break;
+	case ATOMISP_INPUT_FORMAT_RAW_8:
+		ov680_info->metadata_width = fmt->width;
+		break;
+	default:
+		ov680_info->metadata_width = 0;
+		dev_err(&client->dev, "%s unsupported format for embedded data.\n",
+			__func__);
+	}
+
+	ov680_info->metadata_height = 2;
+	ov680_info->metadata_format = ATOMISP_INPUT_FORMAT_EMBEDDED;
+
 out:
 	dev_dbg(&client->dev, "%s - mbusf done ret %d\n", __func__, ret);
 	return ret;
@@ -636,9 +807,8 @@ static int ov680_enum_framesizes(struct v4l2_subdev *sd,
 
 	dev_dbg(&client->dev, "%s\n", __func__);
 
-	if (index >= N_FW) {
+	if (index >= N_FW)
 		return -EINVAL;
-	}
 
 	mutex_lock(&dev->input_lock);
 	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
@@ -783,24 +953,23 @@ static int ov680_s_stream(struct v4l2_subdev *sd, int enable)
 
 	mutex_lock(&dev->input_lock);
 	if (dev->power_on && enable) {
-		/* Load firmware after power on. */
-		ret = ov680_load_firmware(sd);
+		/* start streaming */
+		ret = ov680_write_reg_array(sd, ov680_720p_2s_embedded_stream_on);
 		if (ret) {
 			dev_err(&client->dev,
-				"ov680_load_firmware failed. ret=%d\n", ret);
+				"%s - stream on failed\n", __func__);
 			dev->sys_activated = 0;
+		} else {
+			dev->sys_activated = 1;
 		}
-		ov680_dump_rx_regs(sd);
-		ov680_dump_res_regs(sd);
-
-		dev->sys_activated = 1; /* fw loaded */
-		/* to be removed after get ov680 fw handshake document */
-		msleep(20000); /* wait enough for finish fw downloading */
-		ov680_dump_snr_regs(sd);
-		ov680_dump_rx_regs(sd);
-
 	} else { /* stream off */
-		dev->sys_activated = 0; /* fw loaded */
+
+		ret = ov680_i2c_write_reg(sd, REG_SC_03,
+					  REG_SC_03_GLOBAL_DISABLED);
+		if (ret)
+			dev_err(&client->dev,
+				"%s - stream off failed\n", __func__);
+		dev->sys_activated = 0;
 	}
 
 	mutex_unlock(&dev->input_lock);
@@ -1098,14 +1267,23 @@ static int ov680_probe(struct i2c_client *client,
 
 	/* Request firmware */
 	ret = request_firmware(&dev->fw, "ov680_fw.bin", &client->dev);
-	if (ret || !dev->fw) {
+	if (ret) {
 		dev_err(&client->dev,
 			"Requesting ov680_fw.bin failed, ret=%d.\n", ret);
 		goto out_free_dev;
 	}
+
+	if (!dev->fw) {
+		ret = -EINVAL;
+		dev_err(&client->dev,
+			"No firmware, ret=%d.\n", ret);
+		goto out_free_dev;
+	}
+
 	ov680_fw_header = (const struct ov680_firmware *)dev->fw->data;
 	ov680_fw_data_size = ov680_fw_header->cmd_count *
-				ov680_fw_header->cmd_size;
+				ov680_fw_header->cmd_size +
+				sizeof(u16);
 
 	/* Check firmware size: FW header size + FW data size */
 	if (dev->fw->size != (sizeof(*ov680_fw_header)+ov680_fw_data_size)) {
@@ -1165,6 +1343,8 @@ static int ov680_probe(struct i2c_client *client,
 		ov680_remove(client);
 	}
 	dev_dbg(&client->dev, "%s - driver load done\n", __func__);
+
+	dev->probed = true;
 	return ret;
 
 out_free:
@@ -1172,7 +1352,6 @@ out_free:
 	v4l2_device_unregister_subdev(&dev->sd);
 	mutex_destroy(&dev->input_lock);
 out_free_dev:
-	kfree(dev);
 	return ret;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov680.h b/drivers/external_drivers/camera/drivers/media/i2c/ov680.h
index 06e4d0b..76e1dcc 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov680.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov680.h
@@ -90,9 +90,14 @@
 #define REG_SC_03 (REG_SC_BASE + 0x03)
 #define REG_SC_06 (REG_SC_BASE + 0x06)
 #define REG_SC_0A (REG_SC_BASE + 0x0a)
+#define REG_SC_66 (REG_SC_BASE + 0x66)
 #define REG_SC_90 (REG_SC_BASE + 0x90)
 #define REG_SC_93 (REG_SC_BASE + 0x93)
 
+#define REG_SC_03_GLOBAL_ENABLED  0x10
+#define REG_SC_03_GLOBAL_DISABLED 0x11
+#define REG_SC_66_GLOBAL_READY   0x18
+
 #define REG_SCCB_SLAVE_03 (REG_SCCB_SLAVE_BASE + 0x03)
 
 #define REG_MC_17 (REG_MC_BASE + 0x17)
@@ -106,6 +111,13 @@
 #define REG_YUV_CROP1_08 (REG_YUV_CROP1_BASE + 0x08)
 #define REG_YUV_CROP1_0B (REG_YUV_CROP1_BASE + 0x0b)
 
+/* detect input sensor */
+#define OV680_MAX_INPUT_SENSOR_NUM 2
+#define OV680_SENSOR_0_ID 0x20
+#define OV680_SENSOR_1_ID 0x6c
+#define OV680_SENSOR_REG0_VAL 0x97
+#define OV680_SENSOR_REG1_VAL 0x28
+
 /* ov680 command set definition */
 #define OV680_CMD_CIR_REG REG_MC_17 /* command interrupt register */
 #define OV680_CMD_OP_REG REG_MC_18 /* operation function */
@@ -231,6 +243,7 @@ struct ov680_device {
 	enum v4l2_mbus_pixelcode mbus_pixelcode;
 	bool sys_activated;
 	bool power_on;
+	bool probed;
 
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct v4l2_ctrl *run_mode;
@@ -245,9 +258,328 @@ static struct ov680_res_struct ov680_res_list[] = {
 	{
 		.width = 1280,
 		.height = 1440,
-		.fps = 15,
+		.fps = 30,
 	},
 };
 #define N_FW (ARRAY_SIZE(ov680_res_list))
 
+/* ov680 init clock pll instructions */
+static struct ov680_reg const ov680_init_clock_pll[] = {
+	/*
+	 *----Start OV680 Clock and PLL configuration-----
+	 *new setting for 19.2M---------------------------
+	 *CCLK (sensor input clock/camera clock output)
+	 */
+
+	/* CCLK (camera clock) divider, 19.2/2=9.6MHz */
+	{OV680_8BIT, 0x601a, 0x02},
+
+	/* Common initial setting */
+	/* Reset MC to disable looking for F/W from E2PROM */
+	{OV680_8BIT, 0x6b00, 0x10},
+	/* MIPI Rx CIF sel Rx0 PHY clk (MIPI receiver sync clock select */
+	{OV680_8BIT, 0x6001, 0xa8},
+	/* Clock Drive Strength --YM (CMD_RDY driver - open drain) */
+	{OV680_8BIT, 0x6060, 0x3C},
+	/* PLL1 - for system clock */
+	{OV680_8BIT, 0x6020, 0x64},
+	{OV680_8BIT, 0x6021, 0x22},
+	{OV680_8BIT, 0x6022, 0x15},
+	{OV680_8BIT, 0x6023, 0x12},
+	{OV680_8BIT, 0x6024, 0x90},
+	/* sys clk = pll_sysclk/2 = 46.4 MHz */
+	{OV680_8BIT, 0x6018, 0x02},
+	/* PLL2 - for MIPI */
+	{OV680_8BIT, 0x6025, 0x59},
+	{OV680_8BIT, 0x6026, 0x22},
+	{OV680_8BIT, 0x6027, 0x15},
+	{OV680_8BIT, 0x6028, 0x01},
+	{OV680_8BIT, 0x6029, 0xa0},
+	/* mipi_pclk = 96/2 = 48 */
+	{OV680_8BIT, 0x6019, 0x02},
+	/* 1000/mipi_clk */
+	{OV680_8BIT, 0x6937, 0x11},
+	/* Sel PLL2 sys_clk as Tx clk, PLL1 sys_clk as sys clk */
+	{OV680_8BIT, 0x6103, 0x71},
+	/* CCLK (sensor input clock) */
+	/* Release AEC2&1, ISP2&1 */
+	{OV680_8BIT, 0x6009, 0x00},
+	/* Release Tx, stch 1~3, AWB1&2 */
+	{OV680_8BIT, 0x600a, 0x00},
+	/* Release Rx0~3 */
+	{OV680_8BIT, 0x600b, 0x00},
+	/* Release Tx, Rx PHY */
+	{OV680_8BIT, 0x600c, 0x00},
+	/* Enable CCLK, SCCB slave clock, MC, MC RAM */
+	{OV680_8BIT, 0x6010, 0x3c},
+	/* AEC2&1, ISP2&1 */
+	{OV680_8BIT, 0x6011, 0xff},
+	/* Sync FIFO, stch FIFO, Tx, stch 1~3, AWB1&2 */
+	{OV680_8BIT, 0x6012, 0xff},
+	/* Enable Rx0~Rx3 PHY clock */
+	{OV680_8BIT, 0x6002, 0xff},
+
+	{OV680_TOK_TERM, 0, 0}
+};
+
+/* ov680 pll change before fw loading */
+static struct ov680_reg const ov680_dw_fw_change_pll[] = {
+	/*
+	 * OV680 Firmware download--Start
+	 * ----inlude OV680 and OV6710 setting in firmware-------------
+	 * change to pll clock
+	 */
+
+	/* Select PLL2 as system clock & MIPI transmitter clock source */
+	{OV680_8BIT, 0x6103, 0x20},
+
+	{OV680_8BIT, 0x6b00, 0x14},
+	{OV680_8BIT, 0x6004, 0x00},
+	{OV680_8BIT, 0x6008, 0x00},
+	{OV680_8BIT, 0x6010, 0xff},
+	{OV680_8BIT, 0x6101, 0x02},
+	{OV680_8BIT, 0x6b0c, 0x00},
+	{OV680_8BIT, 0x6b0d, 0x00},
+
+	{OV680_TOK_TERM, 0, 0}
+};
+
+/* ov680 pll restore after fw loading */
+static struct ov680_reg const ov680_dw_fw_change_back_pll[] = {
+	/* Change back PLL */
+	{OV680_8BIT, 0x6103, 0x71},
+
+	{OV680_8BIT, 0x6b56, 0x22},
+	{OV680_8BIT, 0x6b57, 0xab},
+	{OV680_8BIT, 0x6b00, 0x1c},
+	{OV680_8BIT, 0x6b01, 0x04},
+	{OV680_8BIT, 0x6b0e, 0xff},
+
+	{OV680_TOK_TERM, 0, 0}
+};
+
+static struct ov680_reg const ov680_720p_2s_embedded_stream_on[] = {
+
+	{OV680_8BIT, 0x6B18, 0x85},
+	{OV680_8BIT, 0x6B19, 0x90},
+	{OV680_8BIT, 0x6B1A, 0x01},
+	{OV680_8BIT, 0x6B1B, 0x00},
+	{OV680_8BIT, 0x6B1C, 0x01},
+	{OV680_8BIT, 0x6B17, 0xF0},
+
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+	{OV680_8BIT, 0x6011, 0xFF}, /* AEC on */
+
+	{OV680_TOK_TERM, 0, 0}
+};
+
+static struct ov680_reg const ov680_720p_2s_embedded_line[] = {
+	/* Embedded Line Additional Setting 07/31/2014 */
+	{OV680_8BIT, 0x6b18, 0x81}, /* TYPE_Sensor_Config */
+	{OV680_8BIT, 0x6b19, 0x05}, /* 2560x720p SBS */
+	{OV680_8BIT, 0x6b17, 0x80}, /* streaming */
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+
+	{OV680_8BIT, 0x6099, 0x00},
+	{OV680_8BIT, 0x6914, 0x52},
+	{OV680_8BIT, 0x6096, 0x11},
+
+
+	{OV680_8BIT, 0x6b01, 0x24},
+	{OV680_8BIT, 0x6b02, 0xc0},
+	{OV680_8BIT, 0x6003, 0x10},
+
+
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+
+
+	{OV680_8BIT, 0x600a, 0x00},
+	{OV680_TOK_TERM, 0, 0}
+};
+
+static struct ov680_reg const ov680_embedded_line_off[] = {
+	/* @@ embedded line off */
+	{OV680_8BIT, 0x6b18, 0x81}, /* TYPE_Sensor_Config */
+	{OV680_8BIT, 0x6b19, 0x05}, /* 2560x720p SBS */
+	{OV680_8BIT, 0x6b17, 0x80}, /* streaming */
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+
+	{OV680_8BIT, 0x6003, 0x11},
+	{OV680_8BIT, 0x6b01, 0x04},
+	{OV680_8BIT, 0x6b02, 0x00},
+	{OV680_8BIT, 0x6b03, 0x00},
+
+	{OV680_8BIT, 0x6096, 0x10},
+	{OV680_8BIT, 0x6914, 0x00},
+	{OV680_8BIT, 0x7002, 0x02},
+	{OV680_8BIT, 0x7032, 0x02},
+
+	{OV680_8BIT, 0x700c, 0x04},
+	{OV680_8BIT, 0x700d, 0xff},
+	{OV680_8BIT, 0x700e, 0x02},
+	{OV680_8BIT, 0x700f, 0xcf},
+
+	{OV680_8BIT, 0x7704, 0x05},
+	{OV680_8BIT, 0x7705, 0x00},
+	{OV680_8BIT, 0x7706, 0x02},
+	{OV680_8BIT, 0x7707, 0xd0},
+
+	{OV680_8BIT, 0x703c, 0x04},
+	{OV680_8BIT, 0x703d, 0xff},
+	{OV680_8BIT, 0x703e, 0x02},
+	{OV680_8BIT, 0x703f, 0xcf},
+
+	{OV680_8BIT, 0x7800, 0x00},
+	{OV680_8BIT, 0x7801, 0x01},
+	{OV680_8BIT, 0x7811, 0x30},
+
+	{OV680_8BIT, 0x7e04, 0x05},
+	{OV680_8BIT, 0x7e05, 0x00},
+	{OV680_8BIT, 0x7e06, 0x02},
+	{OV680_8BIT, 0x7e07, 0xd0},
+
+	{OV680_8BIT, 0x7002, 0x02},
+	{OV680_8BIT, 0x7032, 0x02},
+
+	{OV680_8BIT, 0x608c, 0x05},
+	{OV680_8BIT, 0x608d, 0x00},
+	{OV680_8BIT, 0x608e, 0x05},
+	{OV680_8BIT, 0x608f, 0xa0},
+	{OV680_8BIT, 0x6090, 0x05},
+	{OV680_8BIT, 0x6091, 0x00},
+	{OV680_8BIT, 0x6092, 0x02},
+	{OV680_8BIT, 0x6093, 0xd0},
+
+	{OV680_8BIT, 0x6AF1, 0x20},
+	{OV680_8BIT, 0x6AF2, 0x01},
+	{OV680_8BIT, 0x6AF3, 0x00},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x20},
+	{OV680_8BIT, 0x6AF2, 0x43},
+	{OV680_8BIT, 0x6AF3, 0x07},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x20},
+	{OV680_8BIT, 0x6AF2, 0x01},
+	{OV680_8BIT, 0x6AF3, 0x00},
+	{OV680_8BIT, 0x6AF5, 0x01},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x6c},
+	{OV680_8BIT, 0x6AF2, 0x01},
+	{OV680_8BIT, 0x6AF3, 0x00},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+
+	{OV680_8BIT, 0x6AF1, 0x6c},
+	{OV680_8BIT, 0x6AF2, 0x43},
+	{OV680_8BIT, 0x6AF3, 0x07},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x6c},
+	{OV680_8BIT, 0x6AF2, 0x01},
+	{OV680_8BIT, 0x6AF3, 0x00},
+	{OV680_8BIT, 0x6AF5, 0x01},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6880, 0x01},
+	{OV680_8BIT, 0x6881, 0x60},
+	{OV680_8BIT, 0x6840, 0x01},
+	{OV680_8BIT, 0x6841, 0x60},
+
+	{OV680_8BIT, 0x6b02, 0x0c},
+	{OV680_8BIT, 0x6b03, 0x00},
+
+	/*
+	 * sensor system change clock -48M to match OV8858 clock support
+	 * for HW sync
+	 */
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x01},
+	{OV680_8BIT, 0x6AF3, 0x00},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x30},
+	{OV680_8BIT, 0x6AF3, 0x02},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x38},
+	{OV680_8BIT, 0x6AF3, 0x23},
+	{OV680_8BIT, 0x6AF5, 0x30},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x38},
+	{OV680_8BIT, 0x6AF3, 0x26},
+	{OV680_8BIT, 0x6AF5, 0x05},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x38},
+	{OV680_8BIT, 0x6AF3, 0x27},
+	{OV680_8BIT, 0x6AF5, 0xfd},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x43},
+	{OV680_8BIT, 0x6AF3, 0x0d},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x43},
+	{OV680_8BIT, 0x6AF3, 0x0e},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x43},
+	{OV680_8BIT, 0x6AF3, 0x0f},
+	{OV680_8BIT, 0x6AF5, 0x00},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x4f},
+	{OV680_8BIT, 0x6AF3, 0x07},
+	{OV680_8BIT, 0x6AF5, 0x23},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x4f},
+	{OV680_8BIT, 0x6AF3, 0x0f},
+	{OV680_8BIT, 0x6AF5, 0xa2},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	{OV680_TOK_DELAY, 0x0, 0xC6}, /* sleep 198ms */
+
+	/* sensor wake up */
+	{OV680_8BIT, 0x6AF1, 0x90},
+	{OV680_8BIT, 0x6AF2, 0x01},
+	{OV680_8BIT, 0x6AF3, 0x00},
+	{OV680_8BIT, 0x6AF5, 0x01},
+	{OV680_8BIT, 0x6AF9, 0x37},
+
+	/* Turn on AEC/AGC */
+	{OV680_8BIT, 0x6B48, 0x00},
+	{OV680_8BIT, 0x6B19, 0x00},
+	{OV680_8BIT, 0x6B18, 0x83},
+	{OV680_8BIT, 0x6B17, 0x80},
+
+	{OV680_TOK_DELAY, 0x0, 0x64}, /* sleep 100ms */
+
+	{OV680_TOK_TERM, 0, 0}
+};
+
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
index 98f37b0..9943e48 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
@@ -590,6 +590,15 @@ static int __ov8830_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int exp_val, ret;
 
+	dev_dbg(&client->dev, "set exposure:0x%x, gain:0x%x, dig_gain:0x%x",
+		exposure,
+		gain,
+		dig_gain);
+
+	if (!(exposure && gain)) {
+		return 0;
+	}
+
 	/* Update frame timings. Expsure must be minimum <  vts-14 */
 	ret = __ov8830_update_frame_timing(sd, exposure, hts, vts);
 	if (ret)
@@ -692,12 +701,14 @@ static int ov8830_s_exposure(struct v4l2_subdev *sd,
 
 static long ov8830_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	switch (cmd) {
 	case ATOMISP_IOC_S_EXPOSURE:
 		return ov8830_s_exposure(sd, (struct atomisp_exposure *)arg);
 	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
 		return ov8830_g_priv_int_data(sd, arg);
 	default:
+		dev_err(&client->dev, "%s: invalid ioctl cmd\n", __func__);
 		return -EINVAL;
 	}
 	return 0;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
index 527bf3a..f720aae 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
@@ -25,55 +25,78 @@
 #include <media/v4l2-device.h>
 #include "ov8858.h"
 
-static int
-ov8858_read_reg(struct i2c_client *client, u16 len, u16 reg, u16 *val)
+static int ov8858_i2c_read(struct i2c_client *client, u16 len, u16 addr,
+			   u8 *buf)
 {
 	struct i2c_msg msg[2];
-	u16 data[OV8858_SHORT_MAX];
-	int err, i;
+	u8 address[2];
+	int err;
 
 	if (!client->adapter) {
 		dev_err(&client->dev, "%s error, no adapter\n", __func__);
 		return -ENODEV;
 	}
 
-	/* @len should be even when > 1 */
-	if (len > OV8858_BYTE_MAX) {
-		dev_err(&client->dev, "%s error, invalid data length\n",
-			__func__);
-		return -EINVAL;
-	}
+	dev_dbg(&client->dev, "%s: len = %d, addr = 0x%04x\n",
+		__func__, len, addr);
 
 	memset(msg, 0, sizeof(msg));
-	memset(data, 0, sizeof(data));
+
+	address[0] = (addr >> 8) & 0xff;
+	address[1] = addr & 0xff;
 
 	msg[0].addr = client->addr;
 	msg[0].flags = 0;
 	msg[0].len = I2C_MSG_LENGTH;
-	msg[0].buf = (u8 *)data;
-	/* high byte goes first */
-	data[0] = cpu_to_be16(reg);
+	msg[0].buf = address;
 
 	msg[1].addr = client->addr;
 	msg[1].len = len;
 	msg[1].flags = I2C_M_RD;
-	msg[1].buf = (u8 *)data;
+	msg[1].buf = buf;
 
-	err = i2c_transfer(client->adapter, msg, 2);
+	err = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
 	if (err != 2) {
 		if (err >= 0)
 			err = -EIO;
 		goto error;
 	}
 
+	return 0;
+error:
+	dev_err(&client->dev, "reading from address 0x%x error %d", addr, err);
+	return err;
+}
+
+static int ov8858_read_reg(struct i2c_client *client, u16 type, u16 reg,
+			   u16 *val)
+{
+	u8 data[OV8858_SHORT_MAX];
+	int err;
+
+	dev_dbg(&client->dev, "%s: type = %d, reg = 0x%04x\n",
+		__func__, type, reg);
+
+	/* read only 8 and 16 bit values */
+	if (type != OV8858_8BIT && type != OV8858_16BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(data, 0, sizeof(data));
+
+	err = ov8858_i2c_read(client, type, reg, data);
+	if (err)
+		goto error;
+
 	/* high byte comes first */
-	if (len == OV8858_8BIT) {
+	if (type == OV8858_8BIT)
 		*val = (u8)data[0];
-	} else {
-		/* 16-bit access is default when len > 1 */
-		for (i = 0; i < (len >> 1); i++)
-			val[i] = be16_to_cpu(data[i]);
-	}
+	else
+		*val = data[0] << 8 | data[1];
+
+	dev_dbg(&client->dev, "%s: val = 0x%04x\n", __func__, *val);
 
 	return 0;
 
@@ -92,7 +115,9 @@ static int ov8858_i2c_write(struct i2c_client *client, u16 len, u8 *data)
 	msg.flags = 0;
 	msg.len = len;
 	msg.buf = data;
+
 	ret = i2c_transfer(client->adapter, &msg, 1);
+
 	return ret == num_msg ? 0 : -EIO;
 }
 
@@ -104,6 +129,10 @@ ov8858_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
 	u16 *wreg;
 	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
 
+	dev_dbg(&client->dev,
+		"%s: data_length = %d, reg = 0x%04x, val = 0x%04x\n",
+		__func__, data_length, reg, val);
+
 	if (!client->adapter) {
 		dev_err(&client->dev, "%s error, no adapter\n", __func__);
 		return -ENODEV;
@@ -169,6 +198,7 @@ static int __ov8858_buf_reg_array(struct i2c_client *client,
 {
 	int size;
 	u16 *data16;
+
 	switch (next->type) {
 	case OV8858_8BIT:
 		size = 1;
@@ -290,6 +320,7 @@ static int __ov8858_get_max_fps_index(
 				const struct ov8858_fps_setting *fps_settings)
 {
 	int i;
+
 	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
 		if (fps_settings[i].fps == 0)
 			break;
@@ -298,19 +329,23 @@ static int __ov8858_get_max_fps_index(
 	return i - 1;
 }
 
-static int __ov8858_update_frame_timing(struct v4l2_subdev *sd, int exposure,
+static int __ov8858_update_frame_timing(struct v4l2_subdev *sd,
 					u16 *hts, u16 *vts)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
 
-	/* Increase the VTS to match exposure + 14 */
-	if (exposure > *vts - OV8858_INTEGRATION_TIME_MARGIN)
-		*vts = (u16) exposure + OV8858_INTEGRATION_TIME_MARGIN;
 
-	ret = ov8858_write_reg(client, OV8858_16BIT, OV8858_TIMING_HTS, *hts);
+	dev_dbg(&client->dev, "%s OV8858_TIMING_HTS=0x%04x\n",
+		__func__, *hts);
+
+	/* HTS = pixel_per_line / 2 */
+	ret = ov8858_write_reg(client, OV8858_16BIT, OV8858_TIMING_HTS, *hts >> 1);
 	if (ret)
 		return ret;
+	dev_dbg(&client->dev, "%s OV8858_TIMING_VTS=0x%04x\n",
+		__func__, *vts);
+
 	return ov8858_write_reg(client, OV8858_16BIT, OV8858_TIMING_VTS, *vts);
 }
 
@@ -319,13 +354,18 @@ static int __ov8858_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int exp_val, ret;
+	dev_dbg(&client->dev, "%s, exposure = %d, gain=%d, dig_gain=%d\n",
+		__func__, exposure, gain, dig_gain);
+
+	if (*vts < exposure + OV8858_INTEGRATION_TIME_MARGIN) {
+		*vts = (u16) exposure + OV8858_INTEGRATION_TIME_MARGIN;
+	}
 
-	/* Update frame timings. Exposure must be minimum <  vts-14 */
-	ret = __ov8858_update_frame_timing(sd, exposure, hts, vts);
+	ret = __ov8858_update_frame_timing(sd, hts, vts);
 	if (ret)
 		return ret;
 
-	/* For OV8835, the low 4 bits are fraction bits and must be kept 0 */
+	/* For ov8858, the low 4 bits are fraction bits and must be kept 0 */
 	exp_val = exposure << 4;
 	ret = ov8858_write_reg(client, OV8858_8BIT,
 			       OV8858_LONG_EXPO+2, exp_val & 0xFF);
@@ -360,8 +400,8 @@ static int __ov8858_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
 			return ret;
 	}
 
-	/* set global gain */
-	return ov8858_write_reg(client, OV8858_8BIT, OV8858_AGC_ADJ, gain);
+	return ov8858_write_reg(client, OV8858_16BIT, OV8858_LONG_GAIN,
+				gain & 0x07ff);
 }
 
 static int ov8858_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
@@ -392,6 +432,9 @@ static int ov8858_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
 	}
 
 	res = &dev->curr_res_table[dev->fmt_idx];
+	/*
+	 * Vendor: HTS reg value is half the total pixel line
+	 */
 	hts = res->fps_options[dev->fps_index].pixels_per_line;
 	vts = res->fps_options[dev->fps_index].lines_per_frame;
 
@@ -425,20 +468,111 @@ static int ov8858_s_exposure(struct v4l2_subdev *sd,
 static int ov8858_g_priv_int_data(struct v4l2_subdev *sd,
 				  struct v4l2_private_int_data *priv)
 {
-	u32 size;
-	/* TODO: Need to add reading of OTP data here */
-	void *b = NULL; /*le24l042cs_read(v4l2_get_subdevdata(sd), &size);*/
-	int r = 0;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = OV8858_OTP_END_ADDR - OV8858_OTP_START_ADDR + 1;
+	int r;
+	u16 isp_ctrl2 = 0;
 
-	if (!b)
-		return -EIO;
+	mutex_lock(&dev->input_lock);
+	if (!dev->otp_data) {
+		dev->otp_data = devm_kzalloc(&client->dev, size, GFP_KERNEL);
+		if (!dev->otp_data) {
+			dev_err(&client->dev, "%s: can't allocate memory",
+				__func__);
+			r = -ENOMEM;
+			goto error3;
+		}
+
+		/* Streaming has to be on */
+		r = ov8858_write_reg(client, OV8858_8BIT, OV8858_STREAM_MODE,
+				     0x01);
+		if (r)
+			goto error2;
+
+		/* Turn off Dead Pixel Correction */
+		r = ov8858_read_reg(client, OV8858_8BIT,
+				    OV8858_OTP_ISP_CTRL2, &isp_ctrl2);
+		if (r)
+			goto error1;
+
+		r = ov8858_write_reg(client, OV8858_8BIT, OV8858_OTP_ISP_CTRL2,
+				     isp_ctrl2 & ~OV8858_OTP_DPC_ENABLE);
+		if (r)
+			goto error1;
+
+		/* Enable partial OTP read mode */
+		r = ov8858_write_reg(client, OV8858_8BIT, OV8858_OTP_MODE_CTRL,
+				     OV8858_OTP_MODE_PROGRAM_DISABLE |
+				     OV8858_OTP_MODE_MANUAL);
+		if (r)
+			goto error1;
+
+		/* Set address range of OTP memory to read */
+		r = ov8858_write_reg(client, OV8858_16BIT,
+				     OV8858_OTP_START_ADDR_REG,
+				     OV8858_OTP_START_ADDR);
+		if (r)
+			goto error1;
+
+		r = ov8858_write_reg(client, OV8858_16BIT,
+				     OV8858_OTP_END_ADDR_REG,
+				     OV8858_OTP_END_ADDR);
+		if (r)
+			goto error1;
+
+		/* Load the OTP data into the OTP buffer */
+		r = ov8858_write_reg(client, OV8858_8BIT, OV8858_OTP_LOAD_CTRL,
+				     OV8858_OTP_LOAD_ENABLE);
+		if (r)
+			goto error1;
+
+		/* Wait for the data to load into the buffer */
+		usleep_range(5000, 5500);
+
+		/* Read the OTP data from the buffer */
+		r = ov8858_i2c_read(client, size, OV8858_OTP_START_ADDR,
+				    dev->otp_data);
+		if (r)
+			goto error1;
+
+		/* Turn on Dead Pixel Correction */
+		r = ov8858_write_reg(client, OV8858_8BIT, OV8858_OTP_ISP_CTRL2,
+				     isp_ctrl2 | OV8858_OTP_DPC_ENABLE);
+		if (r)
+			goto error1;
+
+		/* Stop streaming */
+		r = ov8858_write_reg(client, 1, OV8858_STREAM_MODE, 0x00);
+		if (r) {
+			dev_err(&client->dev, "%s: cannot turn off streaming\n",
+				__func__);
+			goto error1;
+		}
+	}
 
-	if (copy_to_user(priv->data, b, min_t(__u32, priv->size, size)))
+	if (copy_to_user(priv->data, dev->otp_data,
+			 min_t(__u32, priv->size, size))) {
 		r = -EFAULT;
+		goto error3;
+	}
 
 	priv->size = size;
-	kfree(b);
+	mutex_unlock(&dev->input_lock);
 
+	return 0;
+
+error1:
+	/* Turn on Dead Pixel Correction and set streaming off */
+	ov8858_write_reg(client, OV8858_8BIT, OV8858_OTP_ISP_CTRL2,
+			     isp_ctrl2 | OV8858_OTP_DPC_ENABLE);
+	ov8858_write_reg(client, 1, OV8858_STREAM_MODE, 0x00);
+error2:
+	devm_kfree(&client->dev, dev->otp_data);
+	dev->otp_data = NULL;
+error3:
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "%s: OTP reading failed\n", __func__);
 	return r;
 }
 
@@ -446,12 +580,21 @@ static int __ov8858_init(struct v4l2_subdev *sd)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	dev_dbg(&client->dev, "%s\n", __func__);
 
 	if (dev->sensor_id == OV8858_ID_DEFAULT)
 		return 0;
 
 	/* Sets the default FPS */
 	dev->fps_index = 0;
+
+	/* Set default exposure values (initially start values) */
+	dev->exposure = 256;
+	dev->gain = 16;
+	dev->digital_gain = 1024;
+
+	dev_dbg(&client->dev, "%s: Writing basic settings to ov8858\n",
+		__func__);
 	return ov8858_write_reg_array(client, ov8858_BasicSettings);
 }
 
@@ -469,7 +612,9 @@ static int ov8858_init(struct v4l2_subdev *sd, u32 val)
 
 static void ov8858_uninit(struct v4l2_subdev *sd)
 {
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	dev_dbg(&client->dev, "%s:\n", __func__);
 
 	dev->exposure = 0;
 	dev->gain     = 0;
@@ -478,12 +623,14 @@ static void ov8858_uninit(struct v4l2_subdev *sd)
 
 static long ov8858_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	switch (cmd) {
 	case ATOMISP_IOC_S_EXPOSURE:
 		return ov8858_s_exposure(sd, (struct atomisp_exposure *)arg);
 	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
 		return ov8858_g_priv_int_data(sd, arg);
 	default:
+		dev_err(&client->dev, "Unhandled command 0x%X\n", cmd);
 		return -EINVAL;
 	}
 	return 0;
@@ -494,6 +641,7 @@ static int power_up(struct v4l2_subdev *sd)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
 	int ret;
+	dev_dbg(&client->dev, "%s\n", __func__);
 
 	/* Enable power */
 	ret = dev->platform_data->power_ctrl(sd, 1);
@@ -531,6 +679,7 @@ static int power_down(struct v4l2_subdev *sd)
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
+	dev_dbg(&client->dev, "%s\n", __func__);
 
 	ret = dev->platform_data->flisclk_ctrl(sd, 0);
 	if (ret)
@@ -609,10 +758,11 @@ static int ov8858_g_chip_ident(struct v4l2_subdev *sd,
 	return 0;
 }
 
-/* Return value of the specified register, first try getting it from
+/*
+ * Return value of the specified register, first try getting it from
  * the register list and if not found, get from the sensor via i2c.
  */
-static int ov8858_get_register(struct v4l2_subdev *sd, int reg,
+static int ov8858_get_register(struct v4l2_subdev *sd, int reg, int type,
 			       const struct ov8858_reg *reglist)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
@@ -621,38 +771,35 @@ static int ov8858_get_register(struct v4l2_subdev *sd, int reg,
 
 	/* Try if the values are in the register list */
 	for (next = reglist; next->type != OV8858_TOK_TERM; next++) {
-		if (next->type != OV8858_8BIT) {
-			dev_err(&client->dev, "register not 8-bit\n");
-			return -ENXIO;
+		if (next->sreg == reg) {
+			if (type == OV8858_8BIT)
+				return next->val;
+
+			if (type == OV8858_16BIT &&
+			    next[1].type != OV8858_TOK_TERM)
+				return next[0].val << 8 | next[1].val;
 		}
-		if (next->sreg == reg)
-			return next->val;
 	}
 
 	/* If not, read from sensor */
-	if (ov8858_read_reg(client, OV8858_8BIT, reg, &val)) {
-		dev_err(&client->dev, "failed to read register 0x%04X\n", reg);
+	if (ov8858_read_reg(client, type, reg, &val)) {
+		dev_err(&client->dev, "failed to read register 0x%08x\n", reg);
 		return -EIO;
 	}
 
 	return val;
 }
 
-static int ov8858_get_register_16bit(struct v4l2_subdev *sd, int reg,
-				     const struct ov8858_reg *reglist,
-				     unsigned int *value)
+static inline int ov8858_get_register_16bit(struct v4l2_subdev *sd, int reg,
+					    const struct ov8858_reg *reglist)
 {
-	int high, low;
-	high = ov8858_get_register(sd, reg, reglist);
-	if (high < 0)
-		return high;
-
-	low = ov8858_get_register(sd, reg + 1, reglist);
-	if (low < 0)
-		return low;
+	return ov8858_get_register(sd, reg, OV8858_16BIT, reglist);
+}
 
-	*value = ((u8) high << 8) | (u8) low;
-	return 0;
+static inline int ov8858_get_register_8bit(struct v4l2_subdev *sd, int reg,
+					   const struct ov8858_reg *reglist)
+{
+	return ov8858_get_register(sd, reg, OV8858_8BIT, reglist);
 }
 
 static int __ov8858_get_pll1_values(struct v4l2_subdev *sd,
@@ -666,15 +813,14 @@ static int __ov8858_get_pll1_values(struct v4l2_subdev *sd,
 	unsigned int prediv_coef[] = {2, 3, 4, 5, 6, 8, 12, 16};
 	int ret;
 
-	ret = ov8858_get_register(sd, OV8858_PLL1_PREDIV0, reglist);
-
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL1_PREDIV0, reglist);
 	if (ret < 0)
 		return ret;
 
 	if (ret & OV8858_PLL1_PREDIV0_MASK)
 		*value /= 2;
 
-	ret = ov8858_get_register(sd, OV8858_PLL1_PREDIV, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL1_PREDIV, reglist);
 
 	if (ret < 0)
 		return ret;
@@ -682,20 +828,20 @@ static int __ov8858_get_pll1_values(struct v4l2_subdev *sd,
 	prediv_idx = ret & OV8858_PLL1_PREDIV_MASK;
 	*value = *value * 2 / prediv_coef[prediv_idx];
 
-	ret = ov8858_get_register_16bit(sd, OV8858_PLL1_MULTIPLIER, reglist,
-					&multiplier);
+	ret = ov8858_get_register_16bit(sd, OV8858_PLL1_MULTIPLIER, reglist);
 	if (ret < 0)
 		return ret;
 
+	multiplier = ret;
 	*value *= multiplier & OV8858_PLL1_MULTIPLIER_MASK;
-	ret = ov8858_get_register(sd, OV8858_PLL1_SYS_PRE_DIV, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL1_SYS_PRE_DIV, reglist);
 
 	if (ret < 0)
 		return ret;
 
 	sys_prediv = ret & OV8858_PLL1_SYS_PRE_DIV_MASK;
 	*value /= (sys_prediv + 3);
-	ret = ov8858_get_register(sd, OV8858_PLL1_SYS_DIVIDER, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL1_SYS_DIVIDER, reglist);
 
 	if (ret < 0)
 		return ret;
@@ -717,25 +863,25 @@ static int __ov8858_get_pll2a_values(struct v4l2_subdev *sd, int *value,
 	unsigned int prediv_coef[] = {2, 3, 4, 5, 6, 8, 12, 16};
 	int ret;
 
-	ret = ov8858_get_register(sd, OV8858_PLL2_PREDIV0, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL2_PREDIV0, reglist);
 	if (ret < 0)
 		return ret;
 
 	if (ret & OV8858_PLL2_PREDIV0_MASK)
 		*value /= 2;
 
-	ret = ov8858_get_register(sd, OV8858_PLL2_PREDIV, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL2_PREDIV, reglist);
 	if (ret < 0)
 		return ret;
 
 	prediv_idx = (ret & OV8858_PLL2_PREDIV_MASK);
 	*value = *value * 2 / prediv_coef[prediv_idx];
 
-	ret = ov8858_get_register_16bit(sd, OV8858_PLL2_MULTIPLIER, reglist,
-					&multiplier);
+	ret = ov8858_get_register_16bit(sd, OV8858_PLL2_MULTIPLIER, reglist);
 	if (ret < 0)
 		return ret;
 
+	multiplier = ret;
 	*value *= multiplier & OV8858_PLL2_MULTIPLIER_MASK;
 	dev_dbg(&client->dev, "%s: *value: %d\n", __func__, *value);
 
@@ -748,7 +894,7 @@ static int __ov8858_get_pll2b_values(struct v4l2_subdev *sd, int *value,
 	unsigned int dac_divider;
 	int ret;
 
-	ret = ov8858_get_register(sd, OV8858_PLL2_DAC_DIVIDER, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL2_DAC_DIVIDER, reglist);
 	if (ret < 0)
 		return ret;
 
@@ -768,14 +914,14 @@ static int __ov8858_get_pll2c_values(struct v4l2_subdev *sd, int *value,
 	unsigned int sys_divider_coef[] = {2, 3, 4, 5, 6, 7, 8, 10};
 	int ret;
 
-	ret = ov8858_get_register(sd, OV8858_PLL2_SYS_PRE_DIV, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL2_SYS_PRE_DIV, reglist);
 	if (ret < 0)
 		return ret;
 
 	sys_pre_div = (ret & OV8858_PLL2_SYS_PRE_DIV_MASK) + 1;
 	*value /= sys_pre_div;
 
-	ret = ov8858_get_register(sd, OV8858_PLL2_SYS_DIVIDER, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL2_SYS_DIVIDER, reglist);
 	if (ret < 0)
 		return ret;
 
@@ -807,14 +953,14 @@ static int ov8858_get_intg_factor(struct v4l2_subdev *sd,
 
 	memset(&info->data, 0, sizeof(info->data));
 
-	ret = ov8858_get_register(sd, OV8858_PLL_SCLKSEL1, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL_SCLKSEL1, reglist);
 	if (ret < 0)
 		return ret;
 
 	dev_dbg(d, "%s: OV8858_PLL_SCLKSEL1: 0x%02x\n", __func__, ret);
 	pll_sclksel1 = ret & OV8858_PLL_SCLKSEL1_MASK;
 
-	ret = ov8858_get_register(sd, OV8858_PLL_SCLKSEL2, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_PLL_SCLKSEL2, reglist);
 	if (ret < 0)
 		return ret;
 
@@ -841,7 +987,7 @@ static int ov8858_get_intg_factor(struct v4l2_subdev *sd,
 			return ret;
 	}
 
-	ret = ov8858_get_register(sd, OV8858_SRB_HOST_INPUT_DIS, reglist);
+	ret = ov8858_get_register_8bit(sd, OV8858_SRB_HOST_INPUT_DIS, reglist);
 	if (ret < 0)
 		return ret;
 
@@ -863,6 +1009,7 @@ static int ov8858_get_intg_factor(struct v4l2_subdev *sd,
 
 	dev_dbg(d, "%s: sclk: %d\n", __func__, sclk);
 
+	dev->vt_pix_clk_freq_mhz = sclk;
 	m->vt_pix_clk_freq_mhz = sclk;
 
 	/* HTS and VTS */
@@ -885,44 +1032,57 @@ static int ov8858_get_intg_factor(struct v4l2_subdev *sd,
 	m->read_mode = res->bin_factor_x ?
 		OV8858_READ_MODE_BINNING_ON : OV8858_READ_MODE_BINNING_OFF;
 
-	ret = ov8858_get_register(sd, OV8858_H_INC_ODD, res->regs);
+	ret = ov8858_get_register_8bit(sd, OV8858_H_INC_ODD, res->regs);
 	if (ret < 0)
 		return ret;
 	m->binning_factor_x = (ret + 1) / 2;
 
-	ret = ov8858_get_register(sd, OV8858_V_INC_ODD, res->regs);
+	ret = ov8858_get_register_8bit(sd, OV8858_V_INC_ODD, res->regs);
 	if (ret < 0)
 		return ret;
 	m->binning_factor_y = (ret + 1) / 2;
 
 	/* Get the cropping and output resolution to ISP for this mode. */
 	ret =  ov8858_get_register_16bit(sd, OV8858_HORIZONTAL_START_H,
-		res->regs, &m->crop_horizontal_start);
-	if (ret)
+					 res->regs);
+	if (ret < 0)
 		return ret;
 
-	ret = ov8858_get_register_16bit(sd, OV8858_VERTICAL_START_H,
-		res->regs, &m->crop_vertical_start);
-	if (ret)
+	m->crop_horizontal_start = ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_VERTICAL_START_H, res->regs);
+	if (ret < 0)
 		return ret;
 
-	ret = ov8858_get_register_16bit(sd, OV8858_HORIZONTAL_END_H,
-		res->regs, &m->crop_horizontal_end);
-	if (ret)
+	m->crop_vertical_start = ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_HORIZONTAL_END_H, res->regs);
+	if (ret < 0)
 		return ret;
 
-	ret = ov8858_get_register_16bit(sd, OV8858_VERTICAL_END_H,
-		res->regs, &m->crop_vertical_end);
-	if (ret)
+	m->crop_horizontal_end = ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_VERTICAL_END_H, res->regs);
+	if (ret < 0)
 		return ret;
 
+	m->crop_vertical_end = ret;
+
 	ret = ov8858_get_register_16bit(sd, OV8858_HORIZONTAL_OUTPUT_SIZE_H,
-		res->regs, &m->output_width);
-	if (ret)
+					res->regs);
+	if (ret < 0)
 		return ret;
 
-	return ov8858_get_register_16bit(sd, OV8858_VERTICAL_OUTPUT_SIZE_H,
-		res->regs, &m->output_height);
+	m->output_width = ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_VERTICAL_OUTPUT_SIZE_H,
+					res->regs);
+	if (ret < 0)
+		return ret;
+
+	m->output_height = ret;
+
+	return 0;
 }
 
 /*
@@ -970,11 +1130,16 @@ static int nearest_resolution_index(struct v4l2_subdev *sd, int w, int h)
 	int min_fps_diff = INT_MAX;
 	int min_dist = INT_MAX;
 	const struct ov8858_resolution *tmp_res = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	dev_dbg(&client->dev, "%s: w=%d, h=%d\n", __func__, w, h);
 
 	for (i = 0; i < dev->entries_curr_table; i++) {
 		tmp_res = &dev->curr_res_table[i];
 		dist = distance(tmp_res, w, h);
+		dev_dbg(&client->dev,
+			"nearest_resolution_index[%d]: %dx%d distance=%d\n",
+			i, tmp_res->width, tmp_res->height, dist);
 		if (dist == -1)
 			continue;
 		if (dist < min_dist) {
@@ -990,6 +1155,7 @@ static int nearest_resolution_index(struct v4l2_subdev *sd, int w, int h)
 			}
 		}
 	}
+
 	return idx;
 }
 
@@ -997,7 +1163,11 @@ static int __ov8858_try_mbus_fmt(struct v4l2_subdev *sd,
 				 struct v4l2_mbus_framefmt *fmt)
 {
 	int idx;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	dev_dbg(&client->dev, "%s: width = %d, height = %d\n",
+		__func__, fmt->width, fmt->height);
+
 	if (!fmt)
 		return -EINVAL;
 
@@ -1063,6 +1233,8 @@ static int ov8858_s_mbus_fmt(struct v4l2_subdev *sd,
 		goto out;
 	}
 	res = &dev->curr_res_table[dev->fmt_idx];
+	dev_dbg(&client->dev, "%s: selected width = %d, height = %d\n",
+		__func__, res->width, res->height);
 
 	/* Adjust the FPS selection based on the resolution selected */
 	dev->fps_index = __ov8858_nearest_fps_index(dev->fps, res->fps_options);
@@ -1078,6 +1250,12 @@ static int ov8858_s_mbus_fmt(struct v4l2_subdev *sd,
 	dev->pixels_per_line = res->fps_options[dev->fps_index].pixels_per_line;
 	dev->lines_per_frame = res->fps_options[dev->fps_index].lines_per_frame;
 
+	/* ov8858 only support RGB RAW10 output */
+	ov8858_info->metadata_width = res->width * 10 / 8;
+	ov8858_info->metadata_height = 2;
+	ov8858_info->metadata_format = ATOMISP_INPUT_FORMAT_EMBEDDED;
+
+	/* Set the initial exposure */
 	ret = __ov8858_set_exposure(sd, dev->exposure, dev->gain,
 				    dev->digital_gain, &dev->pixels_per_line,
 				    &dev->lines_per_frame);
@@ -1096,6 +1274,7 @@ static int ov8858_g_mbus_fmt(struct v4l2_subdev *sd,
 			     struct v4l2_mbus_framefmt *fmt)
 {
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
 	if (!fmt)
 		return -EINVAL;
 
@@ -1114,19 +1293,25 @@ static int ov8858_detect(struct i2c_client *client, u16 *id)
 	u16 id_hi = 0;
 	u16 id_low = 0;
 	int ret;
+
 	/* i2c check */
 	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
 		return -ENODEV;
 
+	dev_dbg(&client->dev, "%s: I2C functionality ok\n", __func__);
 	ret = ov8858_read_reg(client, OV8858_8BIT, OV8858_CHIP_ID_HIGH, &id_hi);
 	if (ret)
 		return ret;
+	dev_dbg(&client->dev, "%s: id_high = 0x%04x\n", __func__, id_hi);
 	ret = ov8858_read_reg(client, OV8858_8BIT, OV8858_CHIP_ID_LOW, &id_low);
 	if (ret)
 		return ret;
+	dev_dbg(&client->dev, "%s: id_low = 0x%04x\n", __func__, id_low);
 	*id = (id_hi << 8) | id_low;
 
-	dev_info(&client->dev, "%s: chip_id = 0x%4.4x\n", __func__, *id);
+	dev_dbg(&client->dev, "%s: chip_id = 0x%04x\n", __func__, *id);
+
+	dev_info(&client->dev, "%s: chip_id = 0x%04x\n", __func__, *id);
 	if (*id != OV8858_CHIP_ID)
 		return -ENODEV;
 
@@ -1141,14 +1326,16 @@ static void __ov8858_print_timing(struct v4l2_subdev *sd)
 	u16 width = dev->curr_res_table[dev->fmt_idx].width;
 	u16 height = dev->curr_res_table[dev->fmt_idx].height;
 
-	dev_dbg(&client->dev, "Dump imx timing in stream on:\n");
+	dev_dbg(&client->dev, "Dump ov8858 timing in stream on:\n");
 	dev_dbg(&client->dev, "width: %d:\n", width);
 	dev_dbg(&client->dev, "height: %d:\n", height);
 	dev_dbg(&client->dev, "pixels_per_line: %d:\n", dev->pixels_per_line);
 	dev_dbg(&client->dev, "line per frame: %d:\n", dev->lines_per_frame);
 	dev_dbg(&client->dev, "pix freq: %d:\n", dev->vt_pix_clk_freq_mhz);
+	/* updated formula: pixels_per_line = 2 * HTS */
+	/* updated formula: fps = SCLK / (VTS * HTS) */
 	dev_dbg(&client->dev, "init fps: %d:\n", dev->vt_pix_clk_freq_mhz /
-		dev->pixels_per_line / dev->lines_per_frame);
+		(dev->pixels_per_line / 2) / dev->lines_per_frame);
 	dev_dbg(&client->dev, "HBlank: %d nS:\n",
 		1000 * (dev->pixels_per_line - width) /
 		(dev->vt_pix_clk_freq_mhz / 1000000));
@@ -1165,6 +1352,7 @@ static int ov8858_s_stream(struct v4l2_subdev *sd, int enable)
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
+	dev_dbg(&client->dev, "%s: enable = %d\n", __func__, enable);
 
 	mutex_lock(&dev->input_lock);
 	if (enable) {
@@ -1172,24 +1360,22 @@ static int ov8858_s_stream(struct v4l2_subdev *sd, int enable)
 		ret = ov8858_write_reg_array(client, ov8858_streaming);
 		if (ret != 0) {
 			dev_err(&client->dev, "write_reg_array err\n");
-			mutex_unlock(&dev->input_lock);
-			return ret;
+			goto out;
 		}
 		dev->streaming = 1;
 	} else {
 		ret = ov8858_write_reg_array(client, ov8858_soft_standby);
 		if (ret != 0) {
 			dev_err(&client->dev, "write_reg_array err\n");
-			mutex_unlock(&dev->input_lock);
-			return ret;
+			goto out;
 		}
 		dev->streaming = 0;
 		dev->fps_index = 0;
 		dev->fps = 0;
 	}
+out:
 	mutex_unlock(&dev->input_lock);
-
-	return 0;
+	return ret;
 }
 
 /*
@@ -1286,14 +1472,14 @@ static int ov8858_s_config(struct v4l2_subdev *sd,
 		ret = dev->platform_data->platform_init(client);
 		if (ret) {
 			mutex_unlock(&dev->input_lock);
-			dev_err(&client->dev, "ov8858 platform init err\n");
+			dev_err(&client->dev, "platform init error %d!\n", ret);
 			return ret;
 		}
 	}
 
 	ret = __ov8858_s_power(sd, 1);
 	if (ret) {
-		dev_err(&client->dev, "ov8858 power-up err.\n");
+		dev_err(&client->dev, "power-up error %d!\n", ret);
 		mutex_unlock(&dev->input_lock);
 		return ret;
 	}
@@ -1305,7 +1491,7 @@ static int ov8858_s_config(struct v4l2_subdev *sd,
 	/* config & detect sensor */
 	ret = ov8858_detect(client, &sensor_id);
 	if (ret) {
-		dev_err(&client->dev, "ov8858_detect err s_config.\n");
+		dev_err(&client->dev, "detect error %d!\n", ret);
 		goto fail_detect;
 	}
 
@@ -1321,7 +1507,7 @@ static int ov8858_s_config(struct v4l2_subdev *sd,
 
 	mutex_unlock(&dev->input_lock);
 	if (ret)
-		dev_err(&client->dev, "ov8858 power-down err.\n");
+		dev_err(&client->dev, "power-down error %d!\n", ret);
 
 	return ret;
 
@@ -1385,6 +1571,7 @@ ov8858_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 		      struct v4l2_subdev_format *fmt)
 {
 	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
 	fmt->format = *__ov8858_get_pad_format(dev, fh, fmt->pad, fmt->which);
 
 	return 0;
@@ -1436,6 +1623,9 @@ static int ov8858_s_ctrl(struct v4l2_ctrl *ctrl)
 
 		return 0;
 	case V4L2_CID_TEST_PATTERN:
+		dev_dbg(&client->dev,
+			"%s: V4L2_CID_TEST_PATTERN = %d, val = 0x%04X\n",
+			__func__, V4L2_CID_TEST_PATTERN, ctrl->val);
 		return ov8858_write_reg(client, OV8858_16BIT,
 					OV8858_TEST_PATTERN_REG, ctrl->val);
 	case V4L2_CID_FOCUS_ABSOLUTE:
@@ -1453,42 +1643,44 @@ static int ov8858_g_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ov8858_device *dev = container_of(
 		ctrl->handler, struct ov8858_device, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
 	int r_odd, r_even;
+	int i = dev->fmt_idx;
 
 	switch (ctrl->id) {
-	case V4L2_CID_FOCUS_STATUS: {
+	case V4L2_CID_FOCUS_STATUS:
 		if (dev->vcm_driver && dev->vcm_driver->q_focus_status)
-			return dev->vcm_driver->q_focus_status(
-						&dev->sd, &(ctrl->val));
-	}
+			return dev->vcm_driver->q_focus_status(&dev->sd,
+							       &(ctrl->val));
 	case V4L2_CID_BIN_FACTOR_HORZ:
-		r_odd = ov8858_get_register(&dev->sd, OV8858_H_INC_ODD,
-					dev->curr_res_table[dev->fmt_idx].regs);
+		r_odd = ov8858_get_register_8bit(&dev->sd, OV8858_H_INC_ODD,
+						 dev->curr_res_table[i].regs);
 		if (r_odd < 0)
 			return r_odd;
-		r_even = ov8858_get_register(&dev->sd, OV8858_H_INC_EVEN,
-					dev->curr_res_table[dev->fmt_idx].regs);
+		r_even = ov8858_get_register_8bit(&dev->sd, OV8858_H_INC_EVEN,
+						  dev->curr_res_table[i].regs);
 		if (r_even < 0)
 			return r_even;
 		ctrl->val = fls(r_odd + (r_even)) - 2;
 		return 0;
 
-	case V4L2_CID_BIN_FACTOR_VERT: {
-		r_odd = ov8858_get_register(&dev->sd, OV8858_V_INC_ODD,
-					dev->curr_res_table[dev->fmt_idx].regs);
+	case V4L2_CID_BIN_FACTOR_VERT:
+		r_odd = ov8858_get_register_8bit(&dev->sd, OV8858_V_INC_ODD,
+						 dev->curr_res_table[i].regs);
 		if (r_odd < 0)
 			return r_odd;
-		r_even = ov8858_get_register(&dev->sd, OV8858_V_INC_EVEN,
-					dev->curr_res_table[dev->fmt_idx].regs);
+		r_even = ov8858_get_register_8bit(&dev->sd, OV8858_V_INC_EVEN,
+						  dev->curr_res_table[i].regs);
 		if (r_even < 0)
 			return r_even;
 		ctrl->val = fls(r_odd + (r_even)) - 2;
 		return 0;
-	}
-	default: {
+
+	default:
+		dev_warn(&client->dev,
+			 "%s: Error: Invalid ctrl: 0x%X\n", __func__, ctrl->id);
 		return -EINVAL;
 	}
-	}
 
 	return 0;
 }
@@ -1559,8 +1751,8 @@ static int __ov8858_s_frame_interval(struct v4l2_subdev *sd,
 		res->fps_options[dev->fps_index].lines_per_frame;
 
 	/* update frametiming. Conside the curren exposure/gain as well */
-	ret = __ov8858_set_exposure(sd, dev->exposure, dev->gain,
-	      dev->digital_gain, &dev->pixels_per_line, &dev->lines_per_frame);
+	ret = __ov8858_update_frame_timing(sd,
+			&dev->pixels_per_line, &dev->lines_per_frame);
 	if (ret)
 		return ret;
 
@@ -1792,6 +1984,8 @@ static int ov8858_probe(struct i2c_client *client,
 	unsigned int i;
 	int ret;
 
+	dev_dbg(&client->dev, "%s:\n", __func__);
+
 	/* allocate sensor device & init sub device */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
index 0bd52d6..417263c 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
@@ -29,7 +29,7 @@
 /*
  * This should be added into include/linux/videodev2.h
  * NOTE: This is most likely not used anywhere.
- * */
+ */
 #define V4L2_IDENT_OV8858	V4L2_IDENT_UNKNOWN
 
 /*
@@ -38,9 +38,24 @@
 #define OV8858_ID_DEFAULT	0
 #define OV8858_SUNNY		1
 
+#define OV8858_OTP_START_ADDR	0x7010
+#define OV8858_OTP_END_ADDR	0x7186
+
 /*
  * ov8858 System control registers
  */
+
+#define OV8858_OTP_LOAD_CTRL		0x3D81
+#define OV8858_OTP_MODE_CTRL		0x3D84
+#define OV8858_OTP_START_ADDR_REG	0x3D88
+#define OV8858_OTP_END_ADDR_REG		0x3D8A
+#define OV8858_OTP_ISP_CTRL2		0x5002
+
+#define OV8858_OTP_MODE_MANUAL		BIT(6)
+#define OV8858_OTP_MODE_PROGRAM_DISABLE	BIT(7)
+#define OV8858_OTP_LOAD_ENABLE		BIT(0)
+#define OV8858_OTP_DPC_ENABLE		BIT(3)
+
 #define OV8858_PLL1_PREDIV0		0x030A
 #define OV8858_PLL1_PREDIV		0x0300
 #define OV8858_PLL1_MULTIPLIER		0x0301
@@ -102,12 +117,15 @@
 #define OV8858_CHIP_ID				0x8858
 
 #define OV8858_LONG_EXPO			0x3500
-#define OV8858_AGC_ADJ				0x3508 /* OV Long Gain? */
+#define OV8858_LONG_GAIN			0x3508
+#define OV8858_LONG_DIGI_GAIN			0x350A
+#define OV8858_SHORT_GAIN			0x350C
+#define OV8858_SHORT_DIGI_GAIN			0x350E
 
-#define OV8858_MWB_RED_GAIN_H			0x5032 /* ToDo: Fixed? */
-#define OV8858_MWB_GREEN_GAIN_H			0x5034 /* ToDo: Fixed? */
-#define OV8858_MWB_BLUE_GAIN_H			0x5036 /* ToDo: Fixed? */
-#define OV8858_MWB_GAIN_MAX			0x0FFF /* ToDo: Fixed? */
+#define OV8858_MWB_RED_GAIN_H			0x5032
+#define OV8858_MWB_GREEN_GAIN_H			0x5034
+#define OV8858_MWB_BLUE_GAIN_H			0x5036
+#define OV8858_MWB_GAIN_MAX			0x0FFF
 
 #define OV8858_CHIP_ID_HIGH			0x300B
 #define OV8858_CHIP_ID_LOW			0x300C
@@ -128,10 +146,10 @@
 #define OV8858_BIN_FACTOR_MAX			2
 #define OV8858_INTEGRATION_TIME_MARGIN		14
 
-#define OV8858_MAX_VTS_VALUE			0x7FFF /* ToDo: ?? */
+#define OV8858_MAX_VTS_VALUE			0xFFFF
 #define OV8858_MAX_EXPOSURE_VALUE \
 		(OV8858_MAX_VTS_VALUE - OV8858_INTEGRATION_TIME_MARGIN)
-#define OV8858_MAX_GAIN_VALUE			0xFF   /* ToDo: ?? */
+#define OV8858_MAX_GAIN_VALUE			0x07FF
 
 #define OV8858_MAX_FOCUS_POS			1023
 
@@ -231,6 +249,8 @@ struct ov8858_device {
 	u16 pixels_per_line;
 	u16 lines_per_frame;
 	u8 fps;
+	u8 *otp_data;
+
 	const struct ov8858_reg *regs;
 	struct ov8858_vcm *vcm_driver;
 	const struct ov8858_resolution *curr_res_table;
@@ -314,32 +334,85 @@ static struct ov8858_vcm ov8858_vcms[] = {
 #define OV8858_RES_WIDTH_MAX	3280
 #define OV8858_RES_HEIGHT_MAX	2464
 
-static const struct ov8858_reg ov8858_module_detection[] = {
-	{OV8858_8BIT, OV8858_STREAM_MODE, 0x01}, /* Stream on */
-	{OV8858_8BIT, 0x3d84, 0xc0}, /* Select Bank 0 */
-	{OV8858_8BIT, 0x3d81, 0x01}, /* OTP read enable */
-	{OV8858_TOK_TERM, 0, 0}
-};
-
 static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x0103, 0x01}, /* software_reset */
 	{OV8858_8BIT, 0x0100, 0x00}, /* software_standby */
 	/* PLL settings */
-	{OV8858_8BIT, 0x0300, 0x02}, /* pll1_pre_div = /2 */
-	{OV8858_8BIT, 0x0302, 0x50}, /* pll1_multiplier = 80 */
+	{OV8858_8BIT, 0x0300, 0x05}, /* pll1_pre_div = /4 */
+	{OV8858_8BIT, 0x0302, 0xAF}, /* pll1_multiplier = 175 */
 	{OV8858_8BIT, 0x0303, 0x00}, /* pll1_divm = /(1 + 0) */
 	{OV8858_8BIT, 0x0304, 0x03}, /* pll1_div_mipi = /8 */
 	{OV8858_8BIT, 0x030B, 0x02}, /* pll2_pre_div = /2 */
-	{OV8858_8BIT, 0x030D, 0x4B}, /* pll2_r_divp = 75 */
+	{OV8858_8BIT, 0x030D, 0x4E}, /* pll2_r_divp = 78 */
 	{OV8858_8BIT, 0x030E, 0x00}, /* pll2_r_divs = /1 */
 	{OV8858_8BIT, 0x030F, 0x04}, /* pll2_r_divsp = /(1 + 4) */
 	/* pll2_pre_div0 = /1, pll2_r_divdac = /(1 + 1) */
 	{OV8858_8BIT, 0x0312, 0x01},
 	{OV8858_8BIT, 0x031E, 0x0C}, /* pll1_no_lat = 1, mipi_bitsel_man = 0 */
 
-	{OV8858_8BIT, 0x300D, 0x00}, /* PAD SEL2, VSYNC out value = 0 */
-	{OV8858_8BIT, 0x3002, 0x80}, /* PAD OEN2, VSYNC out enable */
-	{OV8858_8BIT, 0x3010, 0x00}, /* PAD OUT2, VSYNC out select = 0 */
+	/* PAD OEN2, VSYNC out enable=0x80, disable=0x00 */
+	{OV8858_8BIT, 0x3002, 0x80},
+	/* PAD OUT2, VSYNC pulse direction low-to-high = 1 */
+	{OV8858_8BIT, 0x3007, 0x01},
+	/* PAD SEL2, VSYNC out value = 0 */
+	{OV8858_8BIT, 0x300D, 0x00},
+	/* PAD OUT2, VSYNC out select = 0 */
+	{OV8858_8BIT, 0x3010, 0x00},
+
+	/* Npump clock div = /2, Ppump clock div = /4 */
+	{OV8858_8BIT, 0x3015, 0x01},
+	/*
+	 * mipi_lane_mode = 1+3, mipi_lvds_sel = 1 = MIPI enable,
+	 * r_phy_pd_mipi_man = 0, lane_dis_option = 0
+	 */
+	{OV8858_8BIT, 0x3018, 0x72},
+	/* Clock switch output = normal, pclk_div = /1 */
+	{OV8858_8BIT, 0x3020, 0x93},
+	/*
+	 * lvds_mode_o = 0, clock lane disable when pd_mipi = 0,
+	 * pd_mipi enable when rst_sync = 1
+	 */
+	{OV8858_8BIT, 0x3022, 0x01},
+	{OV8858_8BIT, 0x3031, 0x0A}, /* mipi_bit_sel = 10 */
+	{OV8858_8BIT, 0x3034, 0x00}, /* Unknown */
+	/* sclk_div = /1, sclk_pre_div = /1, chip debug = 1 */
+	{OV8858_8BIT, 0x3106, 0x01},
+
+	{OV8858_8BIT, 0x3305, 0xF1}, /* Unknown */
+	{OV8858_8BIT, 0x3307, 0x04}, /* Unknown */
+	{OV8858_8BIT, 0x3308, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3309, 0x28}, /* Unknown */
+	{OV8858_8BIT, 0x330A, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330B, 0x20}, /* Unknown */
+	{OV8858_8BIT, 0x330C, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330D, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330E, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330F, 0x40}, /* Unknown */
+
+	{OV8858_8BIT, 0x3500, 0x00}, /* long exposure = 0x9A20 */
+	{OV8858_8BIT, 0x3501, 0x9A}, /* long exposure = 0x9A20 */
+	{OV8858_8BIT, 0x3502, 0x20}, /* long exposure = 0x9A20 */
+	/*
+	 * Digital fraction gain delay option = Delay 1 frame,
+	 * Gain change delay option = Delay 1 frame,
+	 * Gain delay option = Delay 1 frame,
+	 * Gain manual as sensor gain = Input gain as real gain format,
+	 * Exposure delay option (must be 0 = Delay 1 frame,
+	 * Exposure change delay option (must be 0) = Delay 1 frame
+	 */
+	{OV8858_8BIT, 0x3503, 0x00},
+	{OV8858_8BIT, 0x3505, 0x80}, /* gain conversation option */
+	/*
+	 * [10:7] are integer gain, [6:0] are fraction gain. For example:
+	 * 0x80 is 1x gain, 0x100 is 2x gain, 0x1C0 is 3.5x gain
+	 */
+	{OV8858_8BIT, 0x3508, 0x02}, /* long gain = 0x0200 */
+	{OV8858_8BIT, 0x3509, 0x00}, /* long gain = 0x0200 */
+	{OV8858_8BIT, 0x350C, 0x00}, /* short gain = 0x0080 */
+	{OV8858_8BIT, 0x350D, 0x80}, /* short gain = 0x0080 */
+	{OV8858_8BIT, 0x3510, 0x00}, /* short exposure = 0x000200 */
+	{OV8858_8BIT, 0x3511, 0x02}, /* short exposure = 0x000200 */
+	{OV8858_8BIT, 0x3512, 0x00}, /* short exposure = 0x000200 */
 
 	{OV8858_8BIT, 0x3600, 0x00}, /* Unknown */
 	{OV8858_8BIT, 0x3601, 0x00}, /* Unknown */
@@ -382,53 +455,6 @@ static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x3646, 0x83}, /* Unknown */
 	{OV8858_8BIT, 0x364A, 0x07}, /* Unknown */
 
-	/* Npump clock div = /2, Ppump clock div = /4 */
-	{OV8858_8BIT, 0x3015, 0x01},
-	/* mipi_lane_mode = 1+3, mipi_lvds_sel = 1 = MIPI enable,
-	 * r_phy_pd_mipi_man = 0, lane_dis_option = 0 */
-	{OV8858_8BIT, 0x3018, 0x72},
-	/*Clock switch output = normal, pclk_div = /1 */
-	{OV8858_8BIT, 0x3020, 0x93},
-	/* lvds_mode_o = 0, clock lane disable when pd_mipi = 0,
-	 * pd_mipi enable when rst_sync = 1 */
-	{OV8858_8BIT, 0x3022, 0x01},
-	{OV8858_8BIT, 0x3031, 0x0A}, /* mipi_bit_sel = 10 */
-	{OV8858_8BIT, 0x3034, 0x00}, /* Unknown */
-	/* sclk_div = /1, sclk_pre_div = /1, chip debug = 1 */
-	{OV8858_8BIT, 0x3106, 0x01},
-
-	{OV8858_8BIT, 0x3305, 0xF1}, /* Unknown */
-	{OV8858_8BIT, 0x3307, 0x04}, /* Unknown */
-	{OV8858_8BIT, 0x3308, 0x28}, /* Unknown */
-	{OV8858_8BIT, 0x3309, 0x00}, /* Unknown */
-	{OV8858_8BIT, 0x330A, 0x20}, /* Unknown */
-	{OV8858_8BIT, 0x330B, 0x00}, /* Unknown */
-	{OV8858_8BIT, 0x330C, 0x00}, /* Unknown */
-	{OV8858_8BIT, 0x330D, 0x00}, /* Unknown */
-	{OV8858_8BIT, 0x330E, 0x40}, /* Unknown */
-	{OV8858_8BIT, 0x330F, 0x04}, /* Unknown */
-
-	{OV8858_8BIT, 0x3500, 0x00}, /* long exposure = 0x9A20 */
-	{OV8858_8BIT, 0x3501, 0x9A}, /* long exposure = 0x9A20 */
-	{OV8858_8BIT, 0x3502, 0x20}, /* long exposure = 0x9A20 */
-	/* Digital fraction gain delay option = Delay 1 frame,
-	 * Gain change delay option = Delay 1 frame,
-	 * Gain delay option = Delay 1 frame,
-	 * Gain manual as sensor gain = Input gain as real gain format,
-	 * Exposure delay option (must be 0 = Delay 1 frame,
-	 * Exposure change delay option (must be 0) = Delay 1 frame */
-	{OV8858_8BIT, 0x3503, 0x00},
-	{OV8858_8BIT, 0x3505, 0x80}, /* gain conversation option */
-	/* [10:7] are integer gain, [6:0] are fraction gain. For example:
-	 * 0x80 is 1x gain, 0x100 is 2x gain, 0x1C0 is 3.5x gain */
-	{OV8858_8BIT, 0x3508, 0x02}, /* long gain = 0x0200 */
-	{OV8858_8BIT, 0x3509, 0x00}, /* long gain = 0x0200 */
-	{OV8858_8BIT, 0x350C, 0x00}, /* short gain = 0x0080 */
-	{OV8858_8BIT, 0x350D, 0x80}, /* short gain = 0x0080 */
-	{OV8858_8BIT, 0x3510, 0x00}, /* short exposure = 0x000200 */
-	{OV8858_8BIT, 0x3511, 0x02}, /* short exposure = 0x000200 */
-	{OV8858_8BIT, 0x3512, 0x00}, /* short exposure = 0x000200 */
-
 	{OV8858_8BIT, 0x3700, 0x30}, /* Unknown */
 	{OV8858_8BIT, 0x3701, 0x18}, /* Unknown */
 	{OV8858_8BIT, 0x3702, 0x50}, /* Unknown */
@@ -538,16 +564,16 @@ static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x380B, 0x90}, /* v_output_size low */
 	{OV8858_8BIT, 0x380C, 0x07}, /* horizontal timing size high */
 	{OV8858_8BIT, 0x380D, 0x94}, /* horizontal timing size low */
-	{OV8858_8BIT, 0x380E, 0x09}, /* vertical timing size high */
-	{OV8858_8BIT, 0x380F, 0xAA}, /* vertical timing size low */
+	{OV8858_8BIT, 0x380E, 0x0A}, /* vertical timing size high */
+	{OV8858_8BIT, 0x380F, 0x0D}, /* vertical timing size low */
 	{OV8858_8BIT, 0x3810, 0x00}, /* h_win offset high */
 	{OV8858_8BIT, 0x3811, 0x04}, /* h_win offset low */
 	{OV8858_8BIT, 0x3812, 0x00}, /* v_win offset high */
 	{OV8858_8BIT, 0x3813, 0x02}, /* v_win offset low */
 	{OV8858_8BIT, 0x3814, 0x01}, /* h_odd_inc */
 	{OV8858_8BIT, 0x3815, 0x01}, /* h_even_inc */
-	{OV8858_8BIT, 0x3820, 0x00}, /* format1 */
-	{OV8858_8BIT, 0x3821, 0x46}, /* format2 */
+	{OV8858_8BIT, 0x3820, 0x46}, /* format1 */
+	{OV8858_8BIT, 0x3821, 0x00}, /* format2 */
 	{OV8858_8BIT, 0x382A, 0x01}, /* v_odd_inc */
 	{OV8858_8BIT, 0x382B, 0x01}, /* v_even_inc */
 
@@ -591,16 +617,18 @@ static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x4300, 0xFF}, /* clip_max[11:4] = 0xFFF */
 	{OV8858_8BIT, 0x4301, 0x00}, /* clip_min[11:4] = 0 */
 	{OV8858_8BIT, 0x4302, 0x0F}, /* clip_min/max[3:0] */
+	{OV8858_8BIT, 0x4307, 0x01}, /* Unknown */
 	{OV8858_8BIT, 0x4316, 0x00}, /* CTRL16 = default */
 	{OV8858_8BIT, 0x4503, 0x18}, /* Unknown */
 	{OV8858_8BIT, 0x4600, 0x01}, /* Unknown */
 	{OV8858_8BIT, 0x4601, 0x97}, /* Unknown */
 	/* wkup_dly = Mark1 wakeup delay/2^10 = 0x25 */
 	{OV8858_8BIT, 0x4808, 0x25},
+	{OV8858_8BIT, 0x4816, 0x52}, /* Embedded data type*/
 	{OV8858_8BIT, 0x481F, 0x32}, /* clk_prepare_min = 0x32 */
 	{OV8858_8BIT, 0x4825, 0x3A}, /* lpx_p_min = 0x3A */
 	{OV8858_8BIT, 0x4826, 0x40}, /* hs_prepare_min = 0x40 */
-	{OV8858_8BIT, 0x4837, 0x16}, /* pclk_period = 0x16 */
+	{OV8858_8BIT, 0x4837, 0x14}, /* pclk_period = 0x14 */
 	{OV8858_8BIT, 0x4850, 0x10}, /* LANE SEL01 */
 	{OV8858_8BIT, 0x4851, 0x32}, /* LANE SEL02 */
 
@@ -613,39 +641,48 @@ static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x4D04, 0xFF}, /* TPM_CTRL_REG */
 	{OV8858_8BIT, 0x4D05, 0xFF}, /* TPM_CTRL_REG */
 
-	/* Lens correction (LENC) function enable = 0
+	/*
+	 * Lens correction (LENC) function enable = 0
 	 * Slave sensor AWB Gain function enable = 1
 	 * Slave sensor AWB Statistics function enable = 1
 	 * Master sensor AWB Gain function enable = 1
 	 * Master sensor AWB Statistics function enable = 1
 	 * Black DPC function enable = 1
-	 * White DPC function enable =1 */
+	 * White DPC function enable =1
+	 */
 	{OV8858_8BIT, 0x5000, 0x7E},
 	{OV8858_8BIT, 0x5001, 0x01}, /* BLC function enable = 1 */
-	/* Horizontal scale function enable = 0
+	/*
+	 * Horizontal scale function enable = 0
 	 * WBMATCH bypass mode = Select slave sensor's gain
 	 * WBMATCH function enable = 0
 	 * Master MWB gain support RGBC = 0
 	 * OTP_DPC function enable = 1
 	 * Manual mode of VarioPixel function enable = 0
 	 * Manual enable of VarioPixel function enable = 0
-	 * Use VSYNC to latch ISP modules's function enable signals = 0 */
+	 * Use VSYNC to latch ISP modules's function enable signals = 0
+	 */
 	{OV8858_8BIT, 0x5002, 0x08},
-	/* Bypass all ISP modules after BLC module = 0
+	/*
+	 * Bypass all ISP modules after BLC module = 0
 	 * DPC_DBC buffer control enable = 1
 	 * WBMATCH VSYNC selection = Select master sensor's VSYNC fall
 	 * Select master AWB gain to embed line = AWB gain before manual mode
-	 * Enable BLC's input flip_i signal = 0 */
+	 * Enable BLC's input flip_i signal = 0
+	 */
 	{OV8858_8BIT, 0x5003, 0x20},
+	{OV8858_8BIT, 0x5041, 0x1D}, /* ISP CTRL41 - embedded data=on */
 	{OV8858_8BIT, 0x5046, 0x12}, /* ISP CTRL46 = default */
-	/* Tail enable = 1
+	/*
+	 * Tail enable = 1
 	 * Saturate cross cluster enable = 1
 	 * Remove cross cluster enable = 1
 	 * Enable to remove connected defect pixels in same channel = 1
 	 * Enable to remove connected defect pixels in different channel = 1
 	 * Smooth enable, use average G for recovery = 1
 	 * Black/white sensor mode enable = 0
-	 * Manual mode enable = 0 */
+	 * Manual mode enable = 0
+	 */
 	{OV8858_8BIT, 0x5780, 0xFC},
 	{OV8858_8BIT, 0x5784, 0x0C}, /* DPC CTRL04 */
 	{OV8858_8BIT, 0x5787, 0x40}, /* DPC CTRL07 */
@@ -657,6 +694,7 @@ static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x578F, 0x01}, /* DPC CTRL0F */
 	{OV8858_8BIT, 0x5790, 0x01}, /* DPC CTRL10 */
 	{OV8858_8BIT, 0x5901, 0x00}, /* VAP CTRL01 = default */
+	{OV8858_8BIT, 0x5A08, 0x00}, /* WINC CTRL08 = embedded data in 1st line*/
 	{OV8858_8BIT, 0x5B00, 0x02}, /* OTP CTRL00 */
 	{OV8858_8BIT, 0x5B01, 0x10}, /* OTP CTRL01 */
 	{OV8858_8BIT, 0x5B02, 0x03}, /* OTP CTRL02 */
@@ -665,13 +703,13 @@ static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x5E00, 0x00}, /* PRE CTRL00 = default */
 	{OV8858_8BIT, 0x5E01, 0x41}, /* PRE_CTRL01 = default */
 
-	{OV8858_8BIT, 0x0100, 0x01}, /* Streaming enable */
 	{OV8858_TOK_TERM, 0, 0}
 };
 
 /*****************************STILL********************************/
 
 static const struct ov8858_reg ov8858_8M[] = {
+	{OV8858_8BIT, 0x3778, 0x16}, /* Unknown */
 	{OV8858_8BIT, 0x3800, 0x00}, /* h_crop_start high */
 	{OV8858_8BIT, 0x3801, 0x0C}, /* h_crop_start low */
 	{OV8858_8BIT, 0x3802, 0x00}, /* v_crop_start high */
@@ -684,14 +722,24 @@ static const struct ov8858_reg ov8858_8M[] = {
 	{OV8858_8BIT, 0x3809, 0xD0}, /* h_output_size low */
 	{OV8858_8BIT, 0x380A, 0x09}, /* v_output_size high */
 	{OV8858_8BIT, 0x380B, 0xa0}, /* v_output_size low */
-	{OV8858_8BIT, 0x3810, 0x00}, /* h_win offset high */
-	{OV8858_8BIT, 0x3811, 0x04}, /* h_win offset low */
-	{OV8858_8BIT, 0x3812, 0x00}, /* v_win offset high */
-	{OV8858_8BIT, 0x3813, 0x02}, /* v_win offset low */
+	{OV8858_8BIT, 0x380C, 0x07}, /* horizontal timing size high */
+	{OV8858_8BIT, 0x380D, 0x94}, /* horizontal timing size low */
+	{OV8858_8BIT, 0x380E, 0x0A}, /* vertical timing size high */
+	{OV8858_8BIT, 0x380F, 0x0D}, /* vertical timing size low */
+	{OV8858_8BIT, 0x4022, 0x0B}, /* Anchor left end = 0x0BC3 */
+	{OV8858_8BIT, 0x4023, 0xC3}, /* Anchor left end = 0x0BC3 */
+	{OV8858_8BIT, 0x4024, 0x0C}, /* Anchor right start = 0x0C36 */
+	{OV8858_8BIT, 0x4025, 0x36}, /* Anchor right start = 0x0C36 */
+	{OV8858_8BIT, 0x4026, 0x0C}, /* Anchor right end = 0x0C37 */
+	{OV8858_8BIT, 0x4027, 0x37}, /* Anchor right end = 0x0C37 */
+	{OV8858_8BIT, 0x4600, 0x01}, /* Unknown */
+	{OV8858_8BIT, 0x4601, 0x97}, /* Unknown */
+	{OV8858_8BIT, 0x4837, 0x14}, /* pclk_period = 0x14 */
 	{OV8858_TOK_TERM, 0, 0}
 };
 
 static const struct ov8858_reg ov8858_6M[] = {
+	{OV8858_8BIT, 0x3778, 0x16}, /* Unknown */
 	{OV8858_8BIT, 0x3800, 0x00}, /* h_crop_start high */
 	{OV8858_8BIT, 0x3801, 0x0C}, /* h_crop_start low */
 	{OV8858_8BIT, 0x3802, 0x01}, /* v_crop_start high */
@@ -704,10 +752,49 @@ static const struct ov8858_reg ov8858_6M[] = {
 	{OV8858_8BIT, 0x3809, 0xD0}, /* h_output_size low */
 	{OV8858_8BIT, 0x380A, 0x07}, /* v_output_size high */
 	{OV8858_8BIT, 0x380B, 0x3C}, /* v_output_size low */
-	{OV8858_8BIT, 0x3810, 0x00}, /* h_win offset high */
-	{OV8858_8BIT, 0x3811, 0x04}, /* h_win offset low */
-	{OV8858_8BIT, 0x3812, 0x00}, /* v_win offset high */
-	{OV8858_8BIT, 0x3813, 0x02}, /* v_win offset low */
+	{OV8858_8BIT, 0x380C, 0x07}, /* horizontal timing size high */
+	{OV8858_8BIT, 0x380D, 0x94}, /* horizontal timing size low */
+	{OV8858_8BIT, 0x380E, 0x0A}, /* vertical timing size high */
+	{OV8858_8BIT, 0x380F, 0x0D}, /* vertical timing size low */
+	{OV8858_8BIT, 0x4022, 0x0B}, /* Anchor left end = 0x0BC3 */
+	{OV8858_8BIT, 0x4023, 0xC3}, /* Anchor left end = 0x0BC3 */
+	{OV8858_8BIT, 0x4024, 0x0C}, /* Anchor right start = 0x0C36 */
+	{OV8858_8BIT, 0x4025, 0x36}, /* Anchor right start = 0x0C36 */
+	{OV8858_8BIT, 0x4026, 0x0C}, /* Anchor right end = 0x0C37 */
+	{OV8858_8BIT, 0x4027, 0x37}, /* Anchor right end = 0x0C37 */
+	{OV8858_8BIT, 0x4600, 0x01}, /* Unknown */
+	{OV8858_8BIT, 0x4601, 0x97}, /* Unknown */
+	{OV8858_8BIT, 0x4837, 0x14}, /* pclk_period = 0x14 */
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+static const struct ov8858_reg ov8858_1080P_60[] = {
+	{OV8858_8BIT, 0x3778, 0x17}, /* Unknown */
+	{OV8858_8BIT, 0x3800, 0x02}, /* h_crop_start high */
+	{OV8858_8BIT, 0x3801, 0x26}, /* h_crop_start low */
+	{OV8858_8BIT, 0x3802, 0x02}, /* v_crop_start high */
+	{OV8858_8BIT, 0x3803, 0x8C}, /* v_crop_start low */
+	{OV8858_8BIT, 0x3804, 0x0A}, /* h_crop_end high */
+	{OV8858_8BIT, 0x3805, 0x9D}, /* h_crop_end low */
+	{OV8858_8BIT, 0x3806, 0x07}, /* v_crop_end high */
+	{OV8858_8BIT, 0x3807, 0x0A}, /* v_crop_end low */
+	{OV8858_8BIT, 0x3808, 0x07}, /* h_output_size high*/
+	{OV8858_8BIT, 0x3809, 0x90}, /* h_output_size low */
+	{OV8858_8BIT, 0x380A, 0x04}, /* v_output_size high */
+	{OV8858_8BIT, 0x380B, 0x48}, /* v_output_size low */
+	{OV8858_8BIT, 0x380C, 0x08}, /* horizontal timing size high */
+	{OV8858_8BIT, 0x380D, 0x78}, /* horizontal timing size low */
+	{OV8858_8BIT, 0x380E, 0x04}, /* vertical timing size high */
+	{OV8858_8BIT, 0x380F, 0x7f}, /* vertical timing size low */
+	{OV8858_8BIT, 0x4022, 0x07}, /* Anchor left end = 0x072D */
+	{OV8858_8BIT, 0x4023, 0x2D}, /* Anchor left end = 0x072D */
+	{OV8858_8BIT, 0x4024, 0x07}, /* Anchor right start = 0x079E */
+	{OV8858_8BIT, 0x4025, 0x9E}, /* Anchor right start = 0x079E */
+	{OV8858_8BIT, 0x4026, 0x07}, /* Anchor right end = 0x079F */
+	{OV8858_8BIT, 0x4027, 0x9F}, /* Anchor right end = 0x079F */
+	{OV8858_8BIT, 0x4600, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x4601, 0xef}, /* Unknown */
+	{OV8858_8BIT, 0x4837, 0x16}, /* pclk_period = 0x16 */
 	{OV8858_TOK_TERM, 0, 0}
 };
 
@@ -724,8 +811,8 @@ static struct ov8858_resolution ov8858_res_preview[] = {
 		.fps_options = {
 			{
 				.fps = 30,
-				.pixels_per_line = 4696,
-				.lines_per_frame = 2867,
+				.pixels_per_line = 3880,
+				.lines_per_frame = 2573,
 			},
 			{
 			}
@@ -743,8 +830,8 @@ static struct ov8858_resolution ov8858_res_preview[] = {
 		.fps_options = {
 			{
 				.fps = 30,
-				.pixels_per_line = 4464,
-				.lines_per_frame = 2867,
+				.pixels_per_line = 3880,
+				.lines_per_frame = 2573,
 			},
 			{
 			}
@@ -765,8 +852,8 @@ static struct ov8858_resolution ov8858_res_still[] = {
 		 .fps_options =  {
 			{
 				.fps = 30,
-				.pixels_per_line = 4464,
-				.lines_per_frame = 2867,
+				.pixels_per_line = 3880,
+				.lines_per_frame = 2573,
 			},
 			{
 			}
@@ -783,9 +870,10 @@ static struct ov8858_resolution ov8858_res_still[] = {
 		.skip_frames = 1,
 		.fps_options = {
 			{
-				.fps = 30,
-				.pixels_per_line = 4464,
-				.lines_per_frame = 2867,
+				/* Pixel clock: 149.76MHZ */
+				.fps = 10,
+				.pixels_per_line = 3880,
+				.lines_per_frame = 3859,
 			},
 			{
 			}
@@ -795,6 +883,25 @@ static struct ov8858_resolution ov8858_res_still[] = {
 
 static struct ov8858_resolution ov8858_res_video[] = {
 	{
+		.desc = "ov8858_1080P_60_VIDEO",
+		.width = 1936,
+		.height = 1096,
+		.used = 0,
+		.regs = ov8858_1080P_60,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options =  {
+			{
+				.fps = 60,
+				.pixels_per_line = 4366,
+				.lines_per_frame = 1151,
+			},
+			{
+			}
+		},
+	},
+	{
 		 .desc = "ov8858_6M_STILL",
 		 .width = 3280,
 		 .height = 1852,
@@ -806,8 +913,8 @@ static struct ov8858_resolution ov8858_res_video[] = {
 		 .fps_options =  {
 			{
 				.fps = 30,
-				.pixels_per_line = 4464,
-				.lines_per_frame = 2867,
+				.pixels_per_line = 3880,
+				.lines_per_frame = 2573,
 			},
 			{
 			}
@@ -825,8 +932,8 @@ static struct ov8858_resolution ov8858_res_video[] = {
 		.fps_options = {
 			{
 				.fps = 30,
-				.pixels_per_line = 4464,
-				.lines_per_frame = 2867,
+				.pixels_per_line = 3880,
+				.lines_per_frame = 2573,
 			},
 			{
 			}
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/pixter.c b/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
index 275d35f..3ea0f2a 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
@@ -41,10 +41,10 @@ static struct pixter_format_bridge format_bridge[] = {
 	{"GRBG10", V4L2_MBUS_FMT_SGRBG10_1X10, ATOMISP_INPUT_FORMAT_RAW_10, 10},
 	{"GBRG10", V4L2_MBUS_FMT_SGBRG10_1X10, ATOMISP_INPUT_FORMAT_RAW_10, 10},
 	{"BGGR10", V4L2_MBUS_FMT_SBGGR10_1X10, ATOMISP_INPUT_FORMAT_RAW_10, 10},
-	{"RGGB8", V4L2_MBUS_FMT_SRGGB10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
-	{"GRBG8", V4L2_MBUS_FMT_SGRBG10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
-	{"GBRG8", V4L2_MBUS_FMT_SGBRG10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
-	{"BGGR8", V4L2_MBUS_FMT_SBGGR10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"RGGB8", V4L2_MBUS_FMT_SRGGB8_1X8, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"GRBG8", V4L2_MBUS_FMT_SGRBG8_1X8, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"GBRG8", V4L2_MBUS_FMT_SGBRG8_1X8, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"BGGR8", V4L2_MBUS_FMT_SBGGR8_1X8, ATOMISP_INPUT_FORMAT_RAW_8, 8},
 	{"YUV422_8", V4L2_MBUS_FMT_UYVY8_1X16, ATOMISP_INPUT_FORMAT_YUV422_8, 16},
 	{"YUV420_8", 0x8001/*For YUV420*/, ATOMISP_INPUT_FORMAT_YUV420_8, 16},
 };
@@ -52,47 +52,53 @@ static struct pixter_format_bridge format_bridge[] = {
 static u32 port_to_channel[4] = {1, 0, 2, 0};
 
 static struct pixter_dbgfs dbgfs[] = {
-	{"root", NULL, DBGFS_DIR, 0},
-	{"fps", "root", DBGFS_DIR, 0},
-	{"blank", "root", DBGFS_DIR, 0},
-	{"timing", "root", DBGFS_DIR, 0},
-	{"fps_ovrd", "fps", DBGFS_FILE, dev_off(dbg_fps.fps_ovrd)},
-	{"fps", "fps", DBGFS_FILE, dev_off(dbg_fps.fps)},
-	{"blank_ovrd", "blank", DBGFS_FILE, dev_off(dbg_blank.blank_ovrd)},
-	{"h_blank", "blank", DBGFS_FILE, dev_off(dbg_blank.h_blank)},
-	{"v_blank_pre", "blank", DBGFS_FILE, dev_off(dbg_blank.v_blank_pre)},
-	{"v_blank_post", "blank", DBGFS_FILE, dev_off(dbg_blank.v_blank_post)},
-	{"mipi_clk", "timing", DBGFS_FILE, dev_off(dbg_timing.mipi_clk)},
-	{"cont_hs_clk", "timing", DBGFS_FILE, dev_off(dbg_timing.cont_hs_clk)},
-	{"timing_ovrd", "timing", DBGFS_FILE, dev_off(dbg_timing.timing_ovrd)},
-	{"pre", "timing", DBGFS_FILE, dev_off(dbg_timing.pre)},
-	{"post", "timing", DBGFS_FILE, dev_off(dbg_timing.post)},
-	{"gap", "timing", DBGFS_FILE, dev_off(dbg_timing.gap)},
-	{"ck_lpx", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_lpx)},
-	{"ck_prep", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_prep)},
-	{"ck_zero", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_zero)},
-	{"ck_trail", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_trail)},
-	{"dat_lpx", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_lpx)},
-	{"dat_prep", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_prep)},
-	{"dat_zero", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_zero)},
-	{"dat_trail", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_trail)},
-	{"twakeup", "timing", DBGFS_FILE, dev_off(dbg_timing.twakeup)},
+	{"root", NULL, DBGFS_DIR, 0, 0},
+	{"fps", "root", DBGFS_DIR, 0, 0},
+	{"blank", "root", DBGFS_DIR, 0, 0},
+	{"timing", "root", DBGFS_DIR, 0, 0},
+	{"fps_ovrd", "fps", DBGFS_FILE, PIXTER_RW, dev_off(dbg_fps.fps_ovrd)},
+	{"fps", "fps", DBGFS_FILE, PIXTER_RW, dev_off(dbg_fps.fps)},
+	{"blank_ovrd", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.blank_ovrd)},
+	{"h_blank", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.h_blank)},
+	{"v_blank_pre", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.v_blank_pre)},
+	{"v_blank_post", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.v_blank_post)},
+	{"mipi_clk", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.mipi_clk)},
+	{"cont_hs_clk", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.cont_hs_clk)},
+	{"timing_ovrd", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.timing_ovrd)},
+	{"pre", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.pre)},
+	{"post", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.post)},
+	{"gap", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.gap)},
+	{"ck_lpx", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_lpx)},
+	{"ck_prep", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_prep)},
+	{"ck_zero", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_zero)},
+	{"ck_trail", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_trail)},
+	{"dat_lpx", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_lpx)},
+	{"dat_prep", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_prep)},
+	{"dat_zero", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_zero)},
+	{"dat_trail", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_trail)},
+	{"twakeup", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.twakeup)},
+	{"mipi_lanes_num", "timing", DBGFS_FILE, PIXTER_RONLY, dev_off(dbg_timing.mipi_lanes_num)},
 };
 
-static u32 pixter_get_tx_freq_sel(u32 freq)
+static u32 pixter_get_tx_freq_sel(u32 *freq)
 {
 	u32 sel;
 
-	freq /= 1000000; /* To MHz */
-	if (freq < 20) {
+	*freq /= 1000000; /* To MHz */
+	if (*freq < 20) {
 		sel = 1;
-	} else if (freq <= 100) {
-		sel = (freq + 9) / 10 - 1;
-	} else if (freq <= 750) {
-		sel = (freq + 24) / 25 + 5;
+		*freq = 20;
+	} else if (*freq <= 100) {
+		sel = (*freq + 9) / 10 - 1;
+		*freq = 20 + (sel - 1) * 10;
+	} else if (*freq <= 750) {
+		sel = (*freq + 24) / 25 + 5;
+		*freq = 100 + (sel - 9) * 25;
 	} else {
 		sel = 35;
+		*freq = 750;
 	}
+	*freq *= 1000000;
 
 	return sel;
 }
@@ -281,7 +287,7 @@ static int pixter_config_tx(struct v4l2_subdev *sd)
 	}
 
 	/* Config MIPI clock. */
-	reg_val = pixter_get_tx_freq_sel(dev->dbg_timing.mipi_clk);
+	reg_val = pixter_get_tx_freq_sel(&dev->dbg_timing.mipi_clk);
 	pixter_write_reg(sd, PIXTER_TX_CTRL(ch), reg_val);
 	/* Wait MIPI clock to be ready. Timeout=5s. */
 	while (cnt) {
@@ -301,6 +307,85 @@ static int pixter_config_tx(struct v4l2_subdev *sd)
 	return 0;
 }
 
+static void __print_mipi_timing(struct v4l2_subdev *sd)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct pixter_timing *dbg_time = &dev->dbg_timing;
+	unsigned short mipi_clk = dbg_time->mipi_clk / 1000000;
+	/* 1UI = 1 bit periold, in pS */
+	unsigned int ui = 1000000 / (mipi_clk * 2);
+	unsigned int tmp;
+
+	dev_dbg(&client->dev, "MIPI CLK: %d MHz.\n", mipi_clk);
+
+	dev_dbg(&client->dev, "----Pixter MIPI Parameters----\n");
+	dev_dbg(&client->dev, "ck_lpx: %d.\n", dbg_time->ck_lpx);
+	dev_dbg(&client->dev, "ck_prep: %d.\n", dbg_time->ck_prep);
+	dev_dbg(&client->dev, "ck_zero: %d.\n", dbg_time->ck_zero);
+	dev_dbg(&client->dev, "pre: %d.\n", dbg_time->pre);
+	dev_dbg(&client->dev, "post: %d.\n", dbg_time->post);
+	dev_dbg(&client->dev, "ck_trail: %d.\n", dbg_time->ck_trail);
+	dev_dbg(&client->dev, "dat_lpx: %d.\n", dbg_time->dat_lpx);
+	dev_dbg(&client->dev, "dat_prep: %d.\n", dbg_time->dat_prep);
+	dev_dbg(&client->dev, "dat_zero: %d.\n", dbg_time->dat_zero);
+	dev_dbg(&client->dev, "dat_trail: %d.\n", dbg_time->dat_trail);
+	dev_dbg(&client->dev, "gap: %d.\n", dbg_time->gap);
+	dev_dbg(&client->dev, "twakeup: %d.\n", dbg_time->twakeup);
+
+	dev_dbg(&client->dev, "----Standard MIPI Parameters----\n");
+
+	tmp = (dbg_time->ck_lpx + 1) * 8 * ui;
+	dev_dbg(&client->dev, "CLK-LPX: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->ck_prep + 1) * 8 * ui;
+	dev_dbg(&client->dev, "CLK-PREPARE: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->ck_zero + 1) * 8 * ui;
+	dev_dbg(&client->dev, "CLK-ZERO: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->pre - dbg_time->ck_lpx - dbg_time->ck_zero - 3)
+		* 8 * ui;
+	dev_dbg(&client->dev, "CLK-PRE: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->post + 8) * 8 * ui;
+	dev_dbg(&client->dev, "CLK-POST: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->ck_trail + 1) * 8 * ui;
+	dev_dbg(&client->dev, "CLK-TRAIL: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->dat_lpx + 1) * 8 * ui;
+	dev_dbg(&client->dev, "HS-LPX: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->dat_prep + 1) * 8 * ui;
+	dev_dbg(&client->dev, "HS-PREPARE: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->dat_zero + 6) * 8 * ui;
+	dev_dbg(&client->dev, "HS-ZERO: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->dat_trail + 2) * 8 * ui;
+	dev_dbg(&client->dev, "HS-TRAIL: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->gap + 9) * 8 * ui;
+	dev_dbg(&client->dev, "HS-EXIT: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+	tmp = (dbg_time->twakeup + 1) * 8 * ui;
+	dev_dbg(&client->dev, "Wakeup: %d.%d nS.\n",
+			tmp / 1000, tmp % 1000);
+
+}
+
 static int pixter_s_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct pixter_device *dev = to_pixter_dev(sd);
@@ -313,6 +398,7 @@ static int pixter_s_stream(struct v4l2_subdev *sd, int enable)
 	mutex_lock(&dev->input_lock);
 
 	if (enable) {
+		__print_mipi_timing(sd);
 		ret = pixter_config_rx(sd);
 		if (ret)
 			goto out;
@@ -396,7 +482,8 @@ static u32 pixter_try_mbus_fmt_locked(struct v4l2_subdev *sd,
 		(struct atomisp_input_stream_info*)fmt->reserved;
 	struct pixter_setting *settings = dev->settings;
 	struct pixter_vc_setting *vc_setting = dev->vc_setting;
-	u32 vc, i, j, idx;
+	u32 vc, i, j;
+	s32 idx = -1, max_idx = -1;
 	s64 w0, h0, mismatch, distance;
 	s64 w1 = fmt->width;
 	s64 h1 = fmt->height;
@@ -408,9 +495,10 @@ static u32 pixter_try_mbus_fmt_locked(struct v4l2_subdev *sd,
 		vc = 0;
 	else
 		vc = stream_info->stream;
-	for (i = 0, idx = dev->setting_num - 1; i < dev->setting_num; i++) {
+	for (i = 0; i < dev->setting_num; i++) {
 		if (dev->setting_en[i] == 0)
 			continue;
+		max_idx = i;
 		for (j = 0; j < 4; j++) {
 			if (!vc_setting[j].width)
 				continue;
@@ -435,6 +523,17 @@ static u32 pixter_try_mbus_fmt_locked(struct v4l2_subdev *sd,
 			idx = i;
 		}
 	}
+	if (idx < 0 && max_idx < 0) {
+		idx = dev->setting_num - 1;
+		dev_warn(&client->dev, "All settings disabled, using: %dx%d\n",
+				settings[idx].vc[vc].width,
+				settings[idx].vc[vc].height);
+	} else if (idx < 0) {
+		idx = max_idx;
+		dev_warn(&client->dev, "using max enabled resolution: %dx%d\n",
+				settings[idx].vc[vc].width,
+				settings[idx].vc[vc].height);
+	}
 	fmt->width = settings[idx].vc[vc].width;
 	fmt->height = settings[idx].vc[vc].height;
 	fmt->code = format_bridge[settings[idx].vc[vc].format].v4l2_format;
@@ -865,6 +964,9 @@ static int pixter_probe(struct i2c_client *client,
 		goto out_free;
 	}
 
+	/* Get the number of mipi lanes */
+	dev->dbg_timing.mipi_lanes_num = dev->mipi_info->num_lanes;
+
 	dev->regmap = devm_regmap_init_i2c(client,
 					   &pixter_reg_config);
 	if (IS_ERR(dev->regmap)) {
@@ -904,9 +1006,7 @@ static int pixter_probe(struct i2c_client *client,
 
 	/* Find settings that match the current device. */
 	for (i = 0, j = 0; i < dev->setting_num; i++) {
-		if (caps->sensor[0].stream_num == settings[i].valid_vc_num &&
-		   (dev->mipi_info->input_format == format_bridge[
-		   settings[i].vc[settings[i].def_vc].format].atomisp_format))
+		if (caps->sensor[0].stream_num == settings[i].valid_vc_num)
 			settings[j++] = settings[i];
 	}
 	dev->setting_num = j;
@@ -986,7 +1086,7 @@ static int pixter_probe(struct i2c_client *client,
 				parent);
 		else
 			dbgfs_data[i].entry = debugfs_create_file(dbgfs[i].name,
-				S_IRUSR|S_IWUSR, parent,
+				dbgfs[i].mode, parent,
 				&dbgfs_data[i], &pixter_dbgfs_fops);
 	}
 	/* Create setting nodes. */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/pixter.h b/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
index 189b0c6..f199623 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
@@ -71,6 +71,9 @@
 #define PIXTER_SETTING_NUM	0x80000004
 #define PIXTER_SETTING_START	0x80000008
 
+#define PIXTER_RONLY		S_IRUSR
+#define PIXTER_RW			S_IRUSR | S_IWUSR
+
 enum pixter_image_format {
 	PIXTER_UNKNOWN_FMT,
 	PIXTER_RGGB10,
@@ -141,12 +144,15 @@ struct pixter_timing {
 	u32 dat_zero;
 	u32 dat_trail;
 	u32 twakeup;
+
+	u32 mipi_lanes_num;	/* The number of mipi lanes */
 };
 
 struct pixter_dbgfs {
 	char *name;
 	char *parent;
 	enum pixter_dbgfs_type type;
+	umode_t mode;
 	u32  offset;
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
index a499c79..ebb4f14 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
@@ -1,7 +1,7 @@
 /*
- * Support for OmniVision S5K6B2YX 1080p HD camera sensor.
+ * Support for S5K6B2YX 2M camera sensor.
  *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -19,44 +19,57 @@
  *
  */
 
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/kmod.h>
+#include <linux/bitops.h>
 #include <linux/device.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
 #include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <media/v4l2-device.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
 #include <media/v4l2-chip-ident.h>
-#include <linux/io.h>
+#include <media/v4l2-device.h>
 
 #include "s5k6b2yx.h"
 
-/* i2c read/write stuff */
-static int s5k6b2yx_read_reg(struct i2c_client *client,
-			   u16 data_length, u16 reg, u16 *val)
+/* the bayer order mapping table
+ *          hflip=0                  hflip=1
+ * vflip=0  atomisp_bayer_order_grbg atomisp_bayer_order_rggb
+ * vflip=1  atomisp_bayer_order_bggr atomisp_bayer_order_gbrg
+ *
+ * usage: s5k6b2yx_bayer_order_mapping[vflip][hflip]
+ */
+
+/* S5K6B2YXA support only GRBG */
+static const int s5k6b2yx_bayer_order_mapping[2][2] = {
+	{ atomisp_bayer_order_grbg, atomisp_bayer_order_rggb },
+	{ atomisp_bayer_order_bggr, atomisp_bayer_order_gbrg }
+};
+
+static const int s5k6b2yx_raw_bayer_order[] = {
+	[CAM_SW_STBY] = ATOMISP_INPUT_FORMAT_RAW_10,
+	[CAM_VIS_STBY] = ATOMISP_INPUT_FORMAT_RAW_8,
+};
+
+static int s5k6b2yx_read_reg(struct i2c_client *client, u16 len,
+						u16 reg, u16 *val)
 {
-	int err;
 	struct i2c_msg msg[2];
-	unsigned char data[6];
+	u16 data[S5K6B2YX_SHORT_MAX] = {0};
+	int err, i;
+	int retry_cnt = 5;
 
-	if (!client->adapter) {
-		dev_err(&client->dev, "%s error, no client->adapter\n",
-			__func__);
-		return -ENODEV;
-	}
-
-	if (data_length != S5K6B2YX_8BIT && data_length != S5K6B2YX_16BIT
-					&& data_length != S5K6B2YX_32BIT) {
-		dev_err(&client->dev, "%s error, invalid data length\n",
-			__func__);
+	if (len > S5K6B2YX_BYTE_MAX) {
+		dev_err(&client->dev, "%s error, invalid data length\n", __func__);
 		return -EINVAL;
 	}
 
@@ -65,36 +78,43 @@ static int s5k6b2yx_read_reg(struct i2c_client *client,
 	msg[0].addr = client->addr;
 	msg[0].flags = 0;
 	msg[0].len = I2C_MSG_LENGTH;
-	msg[0].buf = data;
-
-	/* high byte goes out first */
-	data[0] = (u8)(reg >> 8);
-	data[1] = (u8)(reg & 0xff);
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
 
 	msg[1].addr = client->addr;
-	msg[1].len = data_length;
+	msg[1].len = len;
 	msg[1].flags = I2C_M_RD;
-	msg[1].buf = data;
-
-	err = i2c_transfer(client->adapter, msg, 2);
-	if (err != 2) {
-		if (err >= 0)
-			err = -EIO;
-		dev_err(&client->dev,
-			"read from offset 0x%x error %d", reg, err);
-		return err;
+	msg[1].buf = (u8 *)data;
+
+	while (retry_cnt-- > 0) {
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err != 2) {
+			if (err >= 0)
+				err = -EIO;
+			dev_err(&client->dev, "%s error %d, retry_cnt: %d\n",
+				__func__, err, retry_cnt);
+
+			if (retry_cnt <= 0)
+				goto error;
+		} else
+			break;
 	}
 
-	*val = 0;
 	/* high byte comes first */
-	if (data_length == S5K6B2YX_8BIT)
+	if (len == S5K6B2YX_8BIT)
 		*val = (u8)data[0];
-	else if (data_length == S5K6B2YX_16BIT)
-		*val = be16_to_cpu(*(u16 *)&data[0]);
-	else
-		*val = be32_to_cpu(*(u32 *)&data[0]);
+	else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			val[i] = be16_to_cpu(data[i]);
+	}
 
 	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
 }
 
 static int s5k6b2yx_i2c_write(struct i2c_client *client, u16 len, u8 *data)
@@ -109,20 +129,23 @@ static int s5k6b2yx_i2c_write(struct i2c_client *client, u16 len, u8 *data)
 	msg.buf = data;
 	ret = i2c_transfer(client->adapter, &msg, 1);
 
+	if (ret != num_msg)
+		dev_err(&client->dev, "%s error!!\n", __func__);
+
 	return ret == num_msg ? 0 : -EIO;
 }
 
 static int s5k6b2yx_write_reg(struct i2c_client *client, u16 data_length,
-							u16 reg, u16 val)
+								u16 reg, u16 val)
 {
 	int ret;
 	unsigned char data[4] = {0};
 	u16 *wreg = (u16 *)data;
 	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+	int retry_cnt = 5;
 
 	if (data_length != S5K6B2YX_8BIT && data_length != S5K6B2YX_16BIT) {
-		dev_err(&client->dev,
-			"%s error, invalid data_length\n", __func__);
+		dev_err(&client->dev, "%s error, invalid data_length\n", __func__);
 		return -EINVAL;
 	}
 
@@ -137,11 +160,16 @@ static int s5k6b2yx_write_reg(struct i2c_client *client, u16 data_length,
 		*wdata = cpu_to_be16(val);
 	}
 
-	ret = s5k6b2yx_i2c_write(client, len, data);
-	if (ret)
-		dev_err(&client->dev,
-			"write error: wrote 0x%x to offset 0x%x error %d",
-			val, reg, ret);
+	while (retry_cnt-- > 0) {
+		ret = s5k6b2yx_i2c_write(client, len, data);
+		if (ret) {
+			dev_err(&client->dev,
+				"write error: wrote 0x%x to offset 0x%xerror %d, retry_cnt %d\n",
+				val, reg, ret, retry_cnt);
+			return ret;
+		} else
+			break;
+	}
 
 	return ret;
 }
@@ -162,7 +190,7 @@ static int s5k6b2yx_write_reg(struct i2c_client *client, u16 data_length,
  */
 
 static int __s5k6b2yx_flush_reg_array(struct i2c_client *client,
-				    struct s5k6b2yx_write_ctrl *ctrl)
+				     struct s5k6b2yx_write_ctrl *ctrl)
 {
 	u16 size;
 
@@ -177,8 +205,8 @@ static int __s5k6b2yx_flush_reg_array(struct i2c_client *client,
 }
 
 static int __s5k6b2yx_buf_reg_array(struct i2c_client *client,
-				  struct s5k6b2yx_write_ctrl *ctrl,
-				  const struct s5k6b2yx_reg *next)
+				   struct s5k6b2yx_write_ctrl *ctrl,
+				   const struct s5k6b2yx_reg *next)
 {
 	int size;
 	u16 *data16;
@@ -191,7 +219,7 @@ static int __s5k6b2yx_buf_reg_array(struct i2c_client *client,
 	case S5K6B2YX_16BIT:
 		size = 2;
 		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
-		*data16 = cpu_to_be16((u16)next->val);
+		*data16 = (u16)next->val;
 		break;
 	default:
 		return -EINVAL;
@@ -199,7 +227,7 @@ static int __s5k6b2yx_buf_reg_array(struct i2c_client *client,
 
 	/* When first item is added, we need to store its starting address */
 	if (ctrl->index == 0)
-		ctrl->buffer.addr = next->reg;
+		ctrl->buffer.addr = next->sreg;
 
 	ctrl->index += size;
 
@@ -214,17 +242,17 @@ static int __s5k6b2yx_buf_reg_array(struct i2c_client *client,
 }
 
 static int __s5k6b2yx_write_reg_is_consecutive(struct i2c_client *client,
-					     struct s5k6b2yx_write_ctrl *ctrl,
-					     const struct s5k6b2yx_reg *next)
+				   struct s5k6b2yx_write_ctrl *ctrl,
+				   const struct s5k6b2yx_reg *next)
 {
 	if (ctrl->index == 0)
 		return 1;
 
-	return ctrl->buffer.addr + ctrl->index == next->reg;
+	return ctrl->buffer.addr + ctrl->index == next->sreg;
 }
 
 static int s5k6b2yx_write_reg_array(struct i2c_client *client,
-				  const struct s5k6b2yx_reg *reglist)
+				   const struct s5k6b2yx_reg *reglist)
 {
 	const struct s5k6b2yx_reg *next = reglist;
 	struct s5k6b2yx_write_ctrl ctrl;
@@ -235,8 +263,10 @@ static int s5k6b2yx_write_reg_array(struct i2c_client *client,
 		switch (next->type & S5K6B2YX_TOK_MASK) {
 		case S5K6B2YX_TOK_DELAY:
 			err = __s5k6b2yx_flush_reg_array(client, &ctrl);
-			if (err)
+			if (err) {
+				dev_err(&client->dev, "%s: write error\n", __func__);
 				return err;
+			}
 			msleep(next->val);
 			break;
 		default:
@@ -247,13 +277,14 @@ static int s5k6b2yx_write_reg_array(struct i2c_client *client,
 			if (!__s5k6b2yx_write_reg_is_consecutive(client, &ctrl,
 								next)) {
 				err = __s5k6b2yx_flush_reg_array(client, &ctrl);
-				if (err)
+				if (err) {
+					dev_err(&client->dev, "%s: write error\n", __func__);
 					return err;
+				}
 			}
 			err = __s5k6b2yx_buf_reg_array(client, &ctrl, next);
 			if (err) {
-				dev_err(&client->dev, "%s: write error, aborted\n",
-					 __func__);
+				dev_err(&client->dev, "%s: write error\n", __func__);
 				return err;
 			}
 			break;
@@ -262,257 +293,576 @@ static int s5k6b2yx_write_reg_array(struct i2c_client *client,
 
 	return __s5k6b2yx_flush_reg_array(client, &ctrl);
 }
-static int s5k6b2yx_g_focal(struct v4l2_subdev *sd, s32 *val)
+
+static int __s5k6b2yx_init(struct v4l2_subdev *sd, u32 val)
 {
-	*val = (S5K6B2YX_FOCAL_LENGTH_NUM << 16) | S5K6B2YX_FOCAL_LENGTH_DEM;
+
+	/* restore settings */
+	s5k6b2yx_res = s5k6b2yx_res_preview;
+	N_RES = N_RES_PREVIEW;
+
 	return 0;
 }
 
-static int s5k6b2yx_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+static int s5k6b2yx_init(struct v4l2_subdev *sd, u32 val)
 {
-	/*const f number for imx*/
-	*val = (S5K6B2YX_F_NUMBER_DEFAULT_NUM << 16) | S5K6B2YX_F_NUMBER_DEM;
-	return 0;
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+	ret = __s5k6b2yx_init(sd, val);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
 }
 
-static int s5k6b2yx_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+static void s5k6b2yx_uninit(struct v4l2_subdev *sd)
 {
-	*val = (S5K6B2YX_F_NUMBER_DEFAULT_NUM << 24) |
-		(S5K6B2YX_F_NUMBER_DEM << 16) |
-		(S5K6B2YX_F_NUMBER_DEFAULT_NUM << 8) | S5K6B2YX_F_NUMBER_DEM;
-	return 0;
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	dev->coarse_itg = 0;
+	dev->fine_itg   = 0;
+	dev->gain       = 0;
 }
 
-static int s5k6b2yx_get_intg_factor(struct i2c_client *client,
-				struct camera_mipi_info *info,
-				const struct s5k6b2yx_resolution *res)
+static int power_up(struct v4l2_subdev *sd)
 {
-	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	struct atomisp_sensor_mode_data *buf = &info->data;
-	const unsigned int ext_clk_freq_hz = 19200000;
-	unsigned int pix_clk_freq_hz;
-	u16 pre_pll_clk_div;
-	u16 pll_multiplier;
-	u16 vt_sys_clk_div;
-	u16 vt_pix_clk_div;
-	u16 reg_val;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data\n");
+		return -ENODEV;
+	}
 
-	if (info == NULL)
-		return -EINVAL;
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
 
-	/* pixel clock calculattion */
-	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-				S5K6B2YX_REG_PRE_PLL_CLK_DIV_H,
-				&pre_pll_clk_div);
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, CAM_SW_STBY);
+	if (ret) {
+		dev_err(&client->dev, "gpio failed\n");
+		goto fail_gpio;
+	}
+
+	dev->mode = CAM_SW_STBY;
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
 	if (ret)
-		return ret;
+		goto fail_clk;
 
-	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-				S5K6B2YX_REG_PLL_MULTIPLIER_H,
-				&pll_multiplier);
+	return 0;
+fail_gpio:
+	dev->platform_data->gpio_ctrl(sd, CAM_HW_STBY);
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data\n");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
 	if (ret)
-		return ret;
+		dev_err(&client->dev, "flisclk failed\n");
 
-	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-				S5K6B2YX_REG_VT_PIX_CLK_DIV_H,
-				&vt_pix_clk_div);
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, CAM_HW_STBY);
 	if (ret)
-		return ret;
+		dev_err(&client->dev, "gpio failed\n");
 
-	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-				S5K6B2YX_REG_VT_SYS_CLK_DIV_H,
-				&vt_sys_clk_div);
+	dev->mode = CAM_HW_STBY;
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
 	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int __s5k6b2yx_s_power(struct v4l2_subdev *sd, int power)
+{
+	int ret;
+
+	if (power == 0) {
+		s5k6b2yx_uninit(sd);
+
+		ret = power_down(sd);
+		if (ret)
+			v4l2_err(sd, "sensor power down fail\n");
+
 		return ret;
+	} else {
 
-	pre_pll_clk_div = (pre_pll_clk_div & 0x70) >> 4;
-	if (0 == pre_pll_clk_div)
-		return -EINVAL;
+		ret = power_up(sd);
+		if (ret) {
+			v4l2_err(sd, "cam sensor power up fail\n");
+			return ret;
+		}
 
-	pix_clk_freq_hz = ext_clk_freq_hz * pll_multiplier / pre_pll_clk_div
-				/ vt_sys_clk_div / vt_pix_clk_div;
+		return __s5k6b2yx_init(sd, 0);
+	}
+}
 
-	dev->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
-	buf->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+static int s5k6b2yx_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 
-	/* get integration time */
-	buf->coarse_integration_time_min = S5K6B2YX_COARSE_INTG_TIME_MIN;
-	buf->coarse_integration_time_max_margin =
-					S5K6B2YX_COARSE_INTG_TIME_MAX_MARGIN;
+	mutex_lock(&dev->input_lock);
+	ret = __s5k6b2yx_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
 
-	buf->fine_integration_time_min = S5K6B2YX_FINE_INTG_TIME_MIN;
-	buf->fine_integration_time_max_margin =
-					S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN;
+	return ret;
+}
 
-	buf->fine_integration_time_def = S5K6B2YX_FINE_INTG_TIME_MIN;
-	buf->frame_length_lines = res->lines_per_frame;
-	buf->line_length_pck = res->pixels_per_line;
-	buf->read_mode = res->bin_mode;
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int s5k6b2yx_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse;
+	int ret;
+	/* the fine integration time is currently not calculated */
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+			       S5K6B2YX_COARSE_INTEGRATION_TIME, &coarse);
+	*value = coarse;
 
-	/* get the cropping and output resolution to ISP for this mode. */
-	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_H_CROP_START_H, &reg_val);
+	return ret;
+}
+
+static int s5k6b2yx_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	u32 vt_pix_clk_div;
+	u32 vt_sys_clk_div;
+	u32 pre_pll_clk_div;
+	u32 pll_multiplier;
+
+	const int ext_clk_freq_hz = 19200000;
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	int ret;
+	u16 data[S5K6B2YX_INTG_BUF_COUNT];
+
+	u32 vt_pix_clk_freq_mhz;
+	u32 fine_integration_time;
+	u32 frame_length_lines;
+	u32 line_length_pck;
+	u32 div;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	memset(data, 0, S5K6B2YX_INTG_BUF_COUNT * sizeof(u16));
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_VT_PIX_CLK_DIV, data);
 	if (ret)
 		return ret;
-	buf->crop_horizontal_start = reg_val;
+	vt_pix_clk_div = data[0];
 
-	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_V_CROP_START_H, &reg_val);
+	memset(data, 0, S5K6B2YX_INTG_BUF_COUNT * sizeof(u16));
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_VT_SYS_CLK_DIV, data);
 	if (ret)
 		return ret;
-	buf->crop_vertical_start = reg_val;
+	vt_sys_clk_div = data[0];
 
-	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_H_CROP_END_H, &reg_val);
+	memset(data, 0, S5K6B2YX_INTG_BUF_COUNT * sizeof(u16));
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_PRE_PLL_CLK_DIV, data);
 	if (ret)
 		return ret;
-	buf->crop_horizontal_end = reg_val;
+	pre_pll_clk_div = data[0];
 
-	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_V_CROP_END_H, &reg_val);
+	memset(data, 0, S5K6B2YX_INTG_BUF_COUNT * sizeof(u16));
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_PLL_MULTIPLIER, data);
 	if (ret)
 		return ret;
-	buf->crop_vertical_end = reg_val;
+	pll_multiplier = data[0];
 
-	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_H_OUTSIZE_H, &reg_val);
+	memset(data, 0, S5K6B2YX_INTG_BUF_COUNT * sizeof(u16));
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_FINE_INTEGRATION_TIME, data);
 	if (ret)
 		return ret;
-	buf->output_width = reg_val;
+	fine_integration_time = data[0];
 
-	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_V_OUTSIZE_H, &reg_val);
+	memset(data, 0, S5K6B2YX_INTG_BUF_COUNT * sizeof(u16));
+	ret = s5k6b2yx_read_reg(client, 4, S5K6B2YX_FRAME_LENGTH_LINES, data);
 	if (ret)
 		return ret;
-	buf->output_height = reg_val;
+	frame_length_lines = data[0];
+	line_length_pck = data[1];
 
-	buf->binning_factor_x = res->bin_factor_x ?
-					res->bin_factor_x : 1;
-	buf->binning_factor_y = res->bin_factor_y ?
-					res->bin_factor_y : 1;
-	return 0;
-}
+	div = pre_pll_clk_div * vt_sys_clk_div*vt_pix_clk_div;
+	if (div == 0)
+		return -EINVAL;
 
-static long __s5k6b2yx_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
-				 int gain, int digitgain)
+	vt_pix_clk_freq_mhz = ext_clk_freq_hz / div;
+	vt_pix_clk_freq_mhz *= pll_multiplier;
 
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
+	dev->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf->coarse_integration_time_min =
+			S5K6B2YX_COARSE_INTEGRATION_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+			S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN;
+	buf->fine_integration_time_min = S5K6B2YX_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin = S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN;
+	buf->fine_integration_time_def = S5K6B2YX_FINE_INTG_TIME_MIN;
+	buf->line_length_pck = line_length_pck;
+	buf->frame_length_lines = frame_length_lines;
+	buf->read_mode = 0;
 
+	/* 1:binning enabled, 0:disabled */
+	buf->binning_factor_x = 1;
+	buf->binning_factor_y = 1;
 
-	/*
-	 * FIXME!
-	 * TBD: Tuning for exposure and gain control
-	 */
+	/* Get the cropping and output resolution to ISP for this mode. */
+	ret =  s5k6b2yx_read_reg(client, 2, S5K6B2YX_HORIZONTAL_START_H, data);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = data[0];
 
-	/* group hold start */
-	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
-			S5K6B2YX_REG_GROUND_HOLD, 1);
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_VERTICAL_START_H, data);
 	if (ret)
 		return ret;
+	buf->crop_vertical_start = data[0];
 
-	/* set exposure */
-	ret = s5k6b2yx_write_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_COARSE_INTEG,
-					coarse_itg);
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_HORIZONTAL_END_H, data);
 	if (ret)
 		return ret;
+	buf->crop_horizontal_end = data[0];
 
-	/* set analog gain */
-	/*
-	 * DS: the gain of pixel signal is controlled by Analog Gain Control
-	 * Register (analogue_gain_code_global), here is the equation:
-	 * Analog Gain = (m0 * x + c0) / (m1 * x + c1)
-	 *
-	 * S5K6N2YX specifies analog gain by coefficients of m0 = 1, m1 = 0,
-	 * c1 = 32. As a result, here is the equation:
-	 * Analog Gain = analogue_gain_code_global[12:0] / 32
-	 *
-	 * The miminum value of analogure_gain_code_global[12:0] is
-	 * recommended to 32d, which means that the analog gain should be less
-	 * than x1.
-	 */
-	ret = s5k6b2yx_write_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_ANALOG_GAIN, gain);
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_VERTICAL_END_H, data);
 	if (ret)
 		return ret;
+	buf->crop_vertical_end = data[0];
 
-	/* There is no digital gain control */
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_HORIZONTAL_OUTPUT_SIZE_H, data);
+	if (ret)
+		return ret;
+	buf->output_width = data[0];
 
-	/* group hold end */
-	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
-					S5K6B2YX_REG_GROUND_HOLD, 0);
+	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_VERTICAL_OUTPUT_SIZE_H, data);
 	if (ret)
 		return ret;
+	buf->output_height = data[0];
 
-	return ret;
+	return 0;
 }
 
-static int s5k6b2yx_set_exposure(struct v4l2_subdev *sd, int exposure,
-	int gain, int digitgain)
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 600
+static int distance(struct s5k6b2yx_resolution *res, u32 w, u32 h)
 {
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	int ret;
+	unsigned int w_ratio = ((res->width << 13) / w);
+	unsigned int h_ratio;
+	int match;
 
-	mutex_lock(&dev->input_lock);
-	ret = __s5k6b2yx_set_exposure(sd, exposure, gain, digitgain);
-	mutex_unlock(&dev->input_lock);
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
 
-	return ret;
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
 }
 
-static long s5k6b2yx_s_exposure(struct v4l2_subdev *sd,
-			       struct atomisp_exposure *exposure)
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
 {
-	int exp = exposure->integration_time[0];
-	int gain = exposure->gain[0];
-	int digitgain = exposure->gain[1];
-
-	/* we should not accept the invalid value below. */
-	if (gain == 0) {
-		struct i2c_client *client = v4l2_get_subdevdata(sd);
-		v4l2_err(client, "%s: invalid value\n", __func__);
-		return -EINVAL;
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct s5k6b2yx_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &s5k6b2yx_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
 	}
 
-	return s5k6b2yx_set_exposure(sd, exp, gain, digitgain);
+	return idx;
 }
 
-static long s5k6b2yx_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+static int s5k6b2yx_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
 {
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int idx;
 
-	switch (cmd) {
-	case ATOMISP_IOC_S_EXPOSURE:
-		return s5k6b2yx_s_exposure(sd, arg);
-	default:
-		return -EINVAL;
+	mutex_lock(&dev->input_lock);
+
+	if ((fmt->width > S5K6B2YX_RES_WIDTH_MAX) ||
+		(fmt->height > S5K6B2YX_RES_HEIGHT_MAX)) {
+		fmt->width = S5K6B2YX_RES_WIDTH_MAX;
+		fmt->height = S5K6B2YX_RES_HEIGHT_MAX;
+		fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	} else {
+		idx = nearest_resolution_index(fmt->width, fmt->height);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 *  resolutions. If it fails, it means the requested
+		 *  resolution is higher than wecan support. Fallback
+		 *  to highest possible resolution in this case.
+		 */
+		if (idx == -1)
+			idx = N_RES - 1;
+
+		fmt->width = s5k6b2yx_res[idx].width;
+		fmt->height = s5k6b2yx_res[idx].height;
+		fmt->code = s5k6b2yx_res[idx].code;
 	}
+
+	mutex_unlock(&dev->input_lock);
 	return 0;
 }
 
-/* This returns the exposure time being used. This should only be used
-   for filling in EXIF data, not for actual image processing. */
-static int s5k6b2yx_q_exposure(struct v4l2_subdev *sd, s32 *value)
+static int s5k6b2yx_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
 {
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	const struct s5k6b2yx_reg *s5k6b2yx_def_reg;
+	struct camera_mipi_info *s5k6b2yx_info = NULL;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 coarse;
 	int ret;
+	u8 tmp;
+	int vflip, hflip;
 
-	/* get exposure */
-	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_COARSE_INTEG,
-					&coarse);
+	s5k6b2yx_info = v4l2_get_subdev_hostdata(sd);
+	if (s5k6b2yx_info == NULL)
+		return -EINVAL;
+
+	ret = s5k6b2yx_try_mbus_fmt(sd, fmt);
+	if (ret) {
+		v4l2_err(sd, "try fmt fail\n");
+		return ret;
+	}
+
+	mutex_lock(&dev->input_lock);
+	dev->fmt_idx = nearest_resolution_index(fmt->width, fmt->height);
+
+	/* Sanity check */
+	if (unlikely(dev->fmt_idx == -1)) {
+		mutex_unlock(&dev->input_lock);
+		v4l2_err(sd, "get resolution fail\n");
+		return -EINVAL;
+	}
+
+	s5k6b2yx_def_reg = s5k6b2yx_res[dev->fmt_idx].regs;
+
+	if (s5k6b2yx_res[dev->fmt_idx].mode != dev->mode) {
+		dev->platform_data->gpio_ctrl(sd,
+			s5k6b2yx_res[dev->fmt_idx].mode);
+		dev->mode = s5k6b2yx_res[dev->fmt_idx].mode;
+	}
+	s5k6b2yx_info->input_format = s5k6b2yx_raw_bayer_order[dev->mode];
+	/* enable group hold */
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_param_hold);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_def_reg);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	/* disable group hold */
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_param_update);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+	dev->fps = s5k6b2yx_res[dev->fmt_idx].fps;
+	dev->pixels_per_line = s5k6b2yx_res[dev->fmt_idx].pixels_per_line;
+	dev->lines_per_frame = s5k6b2yx_res[dev->fmt_idx].lines_per_frame;
+	dev->coarse_itg = 0;
+	dev->fine_itg = 0;
+	dev->gain = 0;
+	if (dev->mode == CAM_VIS_STBY)
+		goto out;
+
+	ret = s5k6b2yx_get_intg_factor(client, s5k6b2yx_info);
+	if (ret) {
+		v4l2_err(sd, "failed to get integration_factor\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_8BIT,
+				S5K6B2YX_IMG_ORIENTATION, (u16 *)&tmp);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+	hflip = tmp & S5K6B2YX_HFLIP_BIT;
+	vflip = (tmp & S5K6B2YX_VFLIP_BIT) >> S5K6B2YX_VFLIP_OFFSET;
+	s5k6b2yx_info->raw_bayer_order =
+				s5k6b2yx_bayer_order_mapping[vflip][hflip];
+
+out:
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int s5k6b2yx_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = s5k6b2yx_res[dev->fmt_idx].width;
+	fmt->height = s5k6b2yx_res[dev->fmt_idx].height;
+	fmt->code = s5k6b2yx_res[dev->fmt_idx].code;
+
+	return 0;
+}
+
+static int s5k6b2yx_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (S5K6B2YX_FOCAL_LENGTH_NUM << 16) | S5K6B2YX_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int s5k6b2yx_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for s5k6b2yx*/
+	*val = (S5K6B2YX_F_NUMBER_DEFAULT_NUM << 16) | S5K6B2YX_F_NUMBER_DEM;
+	return 0;
+}
+
+static int s5k6b2yx_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (S5K6B2YX_F_NUMBER_DEFAULT_NUM << 24) |
+		(S5K6B2YX_F_NUMBER_DEM << 16) |
+		(S5K6B2YX_F_NUMBER_DEFAULT_NUM << 8) | S5K6B2YX_F_NUMBER_DEM;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int s5k6b2yx_t_hflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int ret;
+	u16 val;
+
+	/* enable group hold */
+	ret = s5k6b2yx_write_reg_array(c, s5k6b2yx_param_hold);
+
+	ret = s5k6b2yx_read_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, &val);
+	if (ret)
+		return ret;
+	if (value)
+		val |= S5K6B2YX_HFLIP_BIT;
+	else
+		val &= ~S5K6B2YX_HFLIP_BIT;
+	ret = s5k6b2yx_write_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, val);
 	if (ret)
-		goto err;
+		return ret;
+
+	ret = s5k6b2yx_write_reg_array(c, s5k6b2yx_param_update);
+
+	dev->flip = val;
 
-	*value = coarse;
-err:
 	return ret;
 }
-struct s5k6b2yx_control s5k6b2yx_controls[] = {
+
+/* Vertically flip the image */
+static int s5k6b2yx_t_vflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int ret;
+	u16 val;
+
+	/* enable group hold */
+	ret = s5k6b2yx_write_reg_array(c, s5k6b2yx_param_hold);
+
+	ret = s5k6b2yx_read_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, &val);
+	if (ret)
+		return ret;
+	if (value)
+		val |= S5K6B2YX_VFLIP_BIT;
+	else
+		val &= ~S5K6B2YX_VFLIP_BIT;
+	ret = s5k6b2yx_write_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
+
+	ret = s5k6b2yx_write_reg_array(c, s5k6b2yx_param_update);
+
+	dev->flip = val;
+
+	return ret;
+}
+
+static int s5k6b2yx_test_pattern(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
+			S5K6B2YX_TEST_PATTERN_MODE, value);
+}
+
+static int s5k6b2yx_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	*val = s5k6b2yx_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int s5k6b2yx_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	*val = s5k6b2yx_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+static struct s5k6b2yx_control s5k6b2yx_controls[] = {
 	{
 		.qc = {
 			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
@@ -528,6 +878,42 @@ struct s5k6b2yx_control s5k6b2yx_controls[] = {
 	},
 	{
 		.qc = {
+			.id = V4L2_CID_TEST_PATTERN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Test pattern",
+			.minimum = 0,
+			.maximum = 0xffff,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = s5k6b2yx_test_pattern,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image v-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = s5k6b2yx_t_vflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image h-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = s5k6b2yx_t_hflip,
+	},
+	{
+		.qc = {
 			.id = V4L2_CID_FOCAL_ABSOLUTE,
 			.type = V4L2_CTRL_TYPE_INTEGER,
 			.name = "focal length",
@@ -565,414 +951,374 @@ struct s5k6b2yx_control s5k6b2yx_controls[] = {
 		},
 		.query = s5k6b2yx_g_fnumber_range,
 	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = S5K6B2YX_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = s5k6b2yx_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = S5K6B2YX_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = s5k6b2yx_g_bin_factor_y,
+	},
 };
 #define N_CONTROLS (ARRAY_SIZE(s5k6b2yx_controls))
 
-static int s5k6b2yx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+static long __s5k6b2yx_set_exposure(struct v4l2_subdev *sd, u16 coarse_itg, u16 gain)
 {
-	struct s5k6b2yx_device *dev = container_of(ctrl->handler,
-			struct s5k6b2yx_device, ctrl_handler);
-	unsigned int val;
-
-	switch (ctrl->id) {
-	case V4L2_CID_LINK_FREQ:
-		val = s5k6b2yx_res[dev->fmt_idx].mipi_freq;
-		if (val == 0)
-			return -EINVAL;
-
-		ctrl->val = val * 1000;			/* To Hz */
-		break;
-	default:
-		return -EINVAL;
-	}
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 lines_per_frame;
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 
-	return 0;
-}
+	/* Validate exposure:  cannot exceed VTS-4 where VTS is 16bit */
+	coarse_itg = clamp_t(u16, coarse_itg,
+		S5K6B2YX_COARSE_INTEGRATION_TIME_MIN,
+					S5K6B2YX_MAX_EXPOSURE_SUPPORTED);
+	/* Validate gain: must not exceed maximum 8bit value */
+	gain = clamp_t(u16, gain, S5K6B2YX_MIN_GLOBAL_GAIN_SUPPORTED,
+					S5K6B2YX_MAX_GLOBAL_GAIN_SUPPORTED);
 
+	/* enable group hold */
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_param_hold);
+	if (ret)
+		goto out;
 
-static struct s5k6b2yx_control *s5k6b2yx_find_control(u32 id)
-{
-	int i;
+	/* check coarse integration time margin */
+	if (coarse_itg > dev->lines_per_frame -
+					S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN)
+		lines_per_frame = coarse_itg +
+					S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN;
+	else
+		lines_per_frame = dev->lines_per_frame;
 
-	for (i = 0; i < N_CONTROLS; i++)
-		if (s5k6b2yx_controls[i].qc.id == id)
-			return &s5k6b2yx_controls[i];
-	return NULL;
-}
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_16BIT,
+				S5K6B2YX_FRAME_LENGTH_LINES,
+				lines_per_frame);
+	if (ret)
+		goto out_disable;
 
-static int s5k6b2yx_queryctrl(struct v4l2_subdev *sd,
-		struct v4l2_queryctrl *qc)
-{
-	struct s5k6b2yx_control *ctrl = s5k6b2yx_find_control(qc->id);
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	/* set exposure gain */
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_16BIT,
+				S5K6B2YX_COARSE_INTEGRATION_TIME,
+				coarse_itg);
+	if (ret)
+		goto out_disable;
 
-	if (ctrl == NULL)
-		return -EINVAL;
+	/* set analogue gain */
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_GLOBAL_GAIN, gain);
+	if (ret)
+		goto out_disable;
 
-	mutex_lock(&dev->input_lock);
-	*qc = ctrl->qc;
-	mutex_unlock(&dev->input_lock);
+	dev->gain       = gain;
+	dev->coarse_itg = coarse_itg;
 
-	return 0;
+out_disable:
+	s5k6b2yx_write_reg_array(client, s5k6b2yx_param_update);
+out:
+	return ret;
 }
 
-/* imx control set/get */
-static int s5k6b2yx_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+static int s5k6b2yx_set_exposure(struct v4l2_subdev *sd, u16 exposure, u16 gain)
 {
-	struct s5k6b2yx_control *s_ctrl;
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 	int ret;
 
-	if (!ctrl)
-		return -EINVAL;
-
-	s_ctrl = s5k6b2yx_find_control(ctrl->id);
-	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
-		return -EINVAL;
-
 	mutex_lock(&dev->input_lock);
-	ret = s_ctrl->query(sd, &ctrl->value);
+	ret = __s5k6b2yx_set_exposure(sd, exposure, gain);
 	mutex_unlock(&dev->input_lock);
 
 	return ret;
 }
-
-static int s5k6b2yx_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+static long s5k6b2yx_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
 {
-	struct s5k6b2yx_control *octrl = s5k6b2yx_find_control(ctrl->id);
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	int ret;
+	u16 coarse_itg, gain;
 
-	if ((octrl == NULL) || (octrl->tweak == NULL))
-		return -EINVAL;
+	coarse_itg = exposure->integration_time[0];
+	gain = exposure->gain[0];
 
-	mutex_lock(&dev->input_lock);
-	ret = octrl->tweak(sd, ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
+	return s5k6b2yx_set_exposure(sd, coarse_itg, gain);
 }
 
-static int __s5k6b2yx_init(struct v4l2_subdev *sd)
+static long s5k6b2yx_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 {
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	mutex_lock(&dev->input_lock);
-
-	/* restore settings */
-	s5k6b2yx_res = s5k6b2yx_res_preview;
-	N_RES = N_RES_PREVIEW;
 
-	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_init);
-	if (ret) {
-		dev_err(&client->dev, "s5k6b2yx write init registers err.\n");
-		return ret;
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return s5k6b2yx_s_exposure(sd, (struct atomisp_exposure *)arg);
+	default:
+		return -EINVAL;
 	}
-
-	mutex_unlock(&dev->input_lock);
-
 	return 0;
 }
 
+static struct s5k6b2yx_control *s5k6b2yx_find_control(__u32 id)
+{
+	int i;
 
-static int power_up(struct v4l2_subdev *sd)
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (s5k6b2yx_controls[i].qc.id == id)
+			return &s5k6b2yx_controls[i];
+	}
+	return NULL;
+}
+
+static int s5k6b2yx_detect(struct i2c_client *client, u16 *id, u8 *revision)
 {
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
+	struct i2c_adapter *adapter = client->adapter;
+	u16 high, low, rev;
 
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
+	/* i2c check */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	/* check sensor chip ID	 */
+	if (s5k6b2yx_read_reg(client, S5K6B2YX_8BIT, S5K6B2YX_PID_HIGH,
+			     &high)) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", high);
 		return -ENODEV;
 	}
 
-	/* power control */
-	ret = dev->platform_data->power_ctrl(sd, 1);
-	if (ret)
-		goto fail_power;
+	if (s5k6b2yx_read_reg(client, S5K6B2YX_8BIT, S5K6B2YX_PID_LOW,
+			     &low)) {
+		dev_err(&client->dev, "sensor_id_low = 0x%x\n", low);
+		return -ENODEV;
+	}
 
-	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
-	usleep_range(5000, 6000);
+	*id = (((u8) high) << 8) | (u8) low;
 
-	/* gpio ctrl */
-	ret = dev->platform_data->gpio_ctrl(sd, 1);
-	if (ret) {
-		ret = dev->platform_data->gpio_ctrl(sd, 1);
-		if (ret)
-			goto fail_power;
+	if (*id != S5K6B2YX_MOD_ID) {
+		dev_err(&client->dev, "main sensor s5k6b2yx ID error\n");
+		return -ENODEV;
 	}
 
-	/* flis clock control */
-	ret = dev->platform_data->flisclk_ctrl(sd, 1);
-	if (ret)
-		goto fail_clk;
+	if (s5k6b2yx_read_reg(client, S5K6B2YX_8BIT, S5K6B2YX_REV,
+			     &rev)) {
+		dev_err(&client->dev, "sensor_id_low = 0x%x\n", rev);
+		return -ENODEV;
+	}
 
-	/* according to DS, 20ms is needed between PWDN and i2c access */
-	msleep(20);
+	*revision = rev;
 
 	return 0;
-
-fail_clk:
-	dev->platform_data->gpio_ctrl(sd, 0);
-fail_power:
-	dev->platform_data->power_ctrl(sd, 0);
-	dev_err(&client->dev, "sensor power-up failed\n");
-
-	return ret;
 }
 
-static int power_down(struct v4l2_subdev *sd)
+static int
+s5k6b2yx_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
 {
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
 
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
+	if (NULL == platform_data)
 		return -ENODEV;
-	}
 
-	ret = dev->platform_data->flisclk_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "flisclk failed\n");
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+	dev->platform_data->platform_init(client);
 
-	/* gpio ctrl */
-	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	mutex_lock(&dev->input_lock);
+	ret = __s5k6b2yx_s_power(sd, 1);
 	if (ret) {
-		ret = dev->platform_data->gpio_ctrl(sd, 0);
-		if (ret)
-			dev_err(&client->dev, "gpio failed 2\n");
+		mutex_unlock(&dev->input_lock);
+		dev_err(&client->dev, "s5k6b2yx power-up err");
+		return ret;
 	}
 
-	/* power control */
-	ret = dev->platform_data->power_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "vprog failed.\n");
-
-	return ret;
-}
-
-static int s5k6b2yx_s_power(struct v4l2_subdev *sd, int on)
-{
-	int ret;
-	if (on == 0)
-		return power_down(sd);
-	else {
-		ret = power_up(sd);
-		if (!ret)
-			return __s5k6b2yx_init(sd);
+	/* config & detect sensor */
+	ret = s5k6b2yx_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx_detect err s_config.\n");
+		goto fail_detect;
 	}
-	return ret;
-}
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
 
-/*
- * distance - calculate the distance
- * @res: resolution
- * @w: width
- * @h: height
- *
- * Get the gap between resolution and w/h.
- * res->width/height smaller than w/h wouldn't be considered.
- * Returns the value of gap or -1 if fail.
- */
-#define LARGEST_ALLOWED_RATIO_MISMATCH 800
-static int distance(struct s5k6b2yx_resolution *res, u32 w, u32 h)
-{
-	unsigned int w_ratio = ((res->width << 13)/w);
-	unsigned int h_ratio;
-	int match;
-
-	if (h == 0)
-		return -1;
-	h_ratio = ((res->height << 13) / h);
-	if (h_ratio == 0)
-		return -1;
-	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
-
-	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
-		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
-		return -1;
-
-	return w_ratio + h_ratio;
-}
-
-/* Return the nearest higher resolution index */
-static int nearest_resolution_index(int w, int h)
-{
-	int i;
-	int idx = -1;
-	int dist;
-	int min_dist = INT_MAX;
-	struct s5k6b2yx_resolution *tmp_res = NULL;
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
 
-	for (i = 0; i < N_RES; i++) {
-		tmp_res = &s5k6b2yx_res[i];
-		dist = distance(tmp_res, w, h);
-		if (dist == -1)
-			continue;
-		if (dist < min_dist) {
-			min_dist = dist;
-			idx = i;
-		}
+	ret = __s5k6b2yx_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx power down err\n");
+		return ret;
 	}
 
-	return idx;
-}
-
-static int get_resolution_index(int w, int h)
-{
-	int i;
-
-	for (i = 0; i < N_RES; i++) {
-		if (w != s5k6b2yx_res[i].width)
-			continue;
-		if (h != s5k6b2yx_res[i].height)
-			continue;
-
-		return i;
-	}
+	return 0;
 
-	return -1;
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	__s5k6b2yx_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "s5k6b2yx sensor power-gating failed\n");
+	return ret;
 }
 
-static int s5k6b2yx_try_mbus_fmt(struct v4l2_subdev *sd,
-			struct v4l2_mbus_framefmt *fmt)
+static int s5k6b2yx_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
 {
-	int idx;
+	struct s5k6b2yx_control *ctrl = s5k6b2yx_find_control(qc->id);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 
-	if (!fmt)
+	if (ctrl == NULL)
 		return -EINVAL;
-	idx = nearest_resolution_index(fmt->width,
-					fmt->height);
-	if (idx == -1) {
-		/* return the largest resolution */
-		fmt->width = s5k6b2yx_res[N_RES - 1].width;
-		fmt->height = s5k6b2yx_res[N_RES - 1].height;
-	} else {
-		fmt->width = s5k6b2yx_res[idx].width;
-		fmt->height = s5k6b2yx_res[idx].height;
-	}
-	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
 
 	return 0;
 }
 
-static int s5k6b2yx_s_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
+static int s5k6b2yx_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
+	struct s5k6b2yx_control *octrl = s5k6b2yx_find_control(ctrl->id);
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_mipi_info *s5k6b2yx_info = NULL;
-	int ret = 0;
-
-	s5k6b2yx_info = v4l2_get_subdev_hostdata(sd);
-	if (s5k6b2yx_info == NULL)
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = s5k6b2yx_try_mbus_fmt(sd, fmt);
-	if (ret == -1) {
-		dev_err(&client->dev, "try fmt fail\n");
-		goto err;
-	}
+	int ret;
 
-	dev->fmt_idx = get_resolution_index(fmt->width,
-					      fmt->height);
-	if (dev->fmt_idx == -1) {
-		dev_err(&client->dev, "get resolution fail\n");
-		mutex_unlock(&dev->input_lock);
+	if (octrl == NULL)
 		return -EINVAL;
-	}
-
-	ret = s5k6b2yx_write_reg_array(client,
-			s5k6b2yx_res[dev->fmt_idx].regs);
-	if (ret) {
-		dev_err(&client->dev, "s5k6b2yx write fmt register err.\n");
-		return ret;
-	}
-
-	ret = s5k6b2yx_get_intg_factor(client, s5k6b2yx_info,
-					&s5k6b2yx_res[dev->fmt_idx]);
-	if (ret)
-		dev_err(&client->dev, "failed to get integration_factor\n");
 
-err:
+	mutex_lock(&dev->input_lock);
+	ret = octrl->query(sd, &ctrl->value);
 	mutex_unlock(&dev->input_lock);
+
 	return ret;
 }
-static int s5k6b2yx_g_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
+
+static int s5k6b2yx_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
+	struct s5k6b2yx_control *octrl = s5k6b2yx_find_control(ctrl->id);
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int ret;
 
-	if (!fmt)
+	if (!octrl || !octrl->tweak)
 		return -EINVAL;
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
 
-	fmt->width = s5k6b2yx_res[dev->fmt_idx].width;
-	fmt->height = s5k6b2yx_res[dev->fmt_idx].height;
-	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
-
-	return 0;
+	return ret;
 }
 
-static int s5k6b2yx_detect(struct i2c_client *client)
+static int s5k6b2yx_recovery(struct v4l2_subdev *sd)
 {
-	struct i2c_adapter *adapter = client->adapter;
-	u16 id;
-	u16 revision;
 	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 
-	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
-		return -ENODEV;
-
-	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
-					S5K6B2YX_REG_CHIP_ID_H, &id);
+	ret = __s5k6b2yx_s_power(sd, 0);
 	if (ret) {
-		dev_err(&client->dev, "Err read sensor_id 0x%x\n", ret);
-		return -ENODEV;
+		dev_err(&client->dev, "power-down err.\n");
+		return ret;
 	}
 
-	if ((id != S5K6B2YX_ID)) {
-		dev_err(&client->dev, "sensor ID error\n");
-		return -ENODEV;
+	ret = __s5k6b2yx_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "power-up err.\n");
+		return ret;
 	}
 
-	ret = s5k6b2yx_read_reg(client, S5K6B2YX_8BIT,
-					S5K6B2YX_REG_REVISION, &revision);
-	if (ret) {
-		dev_err(&client->dev, "Err read sensor revision 0x%x\n", ret);
-		return -ENODEV;
+	if (s5k6b2yx_res[dev->fmt_idx].mode != dev->mode) {
+		dev->platform_data->gpio_ctrl(sd,
+			s5k6b2yx_res[dev->fmt_idx].mode);
+		dev->mode = s5k6b2yx_res[dev->fmt_idx].mode;
 	}
 
-	dev_dbg(&client->dev, "sensor_revision = 0x%x\n", revision);
-	dev_dbg(&client->dev, "detect s5k6b2yx success\n");
-	return 0;
+	/* enable group hold */
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_param_hold);
+	if (ret)
+		return ret;
+
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION,
+								dev->flip);
+	if (ret)
+		return ret;
+
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_res[dev->fmt_idx].regs);
+	if (ret)
+		return ret;
+
+	/* disable group hold */
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_param_update);
+	if (ret)
+		return ret;
+
+	return ret;
 }
 
+
 static int s5k6b2yx_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
+	u16 id;
+	u8 rev;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 
 	mutex_lock(&dev->input_lock);
+	if (enable) {
+		ret = s5k6b2yx_detect(client, &id, &rev);
+		if (ret) {
+			ret = s5k6b2yx_recovery(sd);
+			if (ret) {
+				dev_err(&client->dev, "recovery err.\n");
+				mutex_unlock(&dev->input_lock);
+				return ret;
+			}
+		}
+		if (dev->mode == CAM_SW_STBY)
+			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_streaming);
+		else
+			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_vis_streaming);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
 
-	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
-			S5K6B2YX_REG_MODE_SELECT,
-			enable ? S5K6B2YX_START_STREAMING :
-			S5K6B2YX_STOP_STREAMING);
+		dev->streaming = 1;
+	} else {
+		if (dev->mode == CAM_SW_STBY)
+			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_suspend);
+		else
+			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_vis_suspend);
+		if (ret != 0) {
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		dev->streaming = 0;
+	}
 
 	mutex_unlock(&dev->input_lock);
-	return ret;
+	return 0;
 }
 
-/* s5k6b2yx enum frame size, frame intervals */
+/*
+ * s5k6b2yx enum frame size, frame intervals
+ */
 static int s5k6b2yx_enum_framesizes(struct v4l2_subdev *sd,
-				  struct v4l2_frmsizeenum *fsize)
+				   struct v4l2_frmsizeenum *fsize)
 {
 	unsigned int index = fsize->index;
 
@@ -988,132 +1334,119 @@ static int s5k6b2yx_enum_framesizes(struct v4l2_subdev *sd,
 }
 
 static int s5k6b2yx_enum_frameintervals(struct v4l2_subdev *sd,
-				      struct v4l2_frmivalenum *fival)
+				       struct v4l2_frmivalenum *fival)
 {
-	unsigned int index = fival->index;
+	int i;
 
-	if (index >= N_RES)
+	/* since the isp will donwscale the resolution to the right size,
+	  * find the nearest one that will allow the isp to do so
+	  * important to ensure that the resolution requested is padded
+	  * correctly by the requester, which is the atomisp driver in
+	  * this case.
+	  */
+	i = nearest_resolution_index(fival->width, fival->height);
+
+	if (i == -1)
 		return -EINVAL;
 
 	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
-	fival->width = s5k6b2yx_res[index].width;
-	fival->height = s5k6b2yx_res[index].height;
+	fival->width = s5k6b2yx_res[i].width;
+	fival->height = s5k6b2yx_res[i].height;
 	fival->discrete.numerator = 1;
-	fival->discrete.denominator = s5k6b2yx_res[index].fps;
+	fival->discrete.denominator = s5k6b2yx_res[i].fps;
 
 	return 0;
 }
 
-static int s5k6b2yx_enum_mbus_fmt(struct v4l2_subdev *sd,
-				unsigned int index,
-				enum v4l2_mbus_pixelcode *code)
+static int s5k6b2yx_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
 {
-	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	if (index >= MAX_FMTS)
+		return -EINVAL;
 
+	*code = V4L2_MBUS_FMT_SGRBG10_1X10;
 	return 0;
 }
 
-static int s5k6b2yx_s_config(struct v4l2_subdev *sd,
-			   int irq, void *platform_data)
+
+static int
+s5k6b2yx_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
 {
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
 
-	if (platform_data == NULL)
-		return -ENODEV;
-
-	dev->platform_data =
-		(struct camera_sensor_platform_data *)platform_data;
-
-	mutex_lock(&dev->input_lock);
-	if (dev->platform_data->platform_init) {
-		ret = dev->platform_data->platform_init(client);
-		if (ret) {
-			dev_err(&client->dev, "platform init err\n");
-			goto platform_init_failed;
-		}
-	}
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_S5K6B2YX, 0);
+}
 
-	/* power off the module, then power on it in future
-	 * as first power on by board may not fulfill the
-	 * power on sequqence needed by the module
-	 */
-	ret = power_down(sd);
-	if (ret) {
-		dev_err(&client->dev, "s5k6b2yx power-off err.\n");
-		goto fail_power_off;
-	}
+static int
+s5k6b2yx_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
 
-	ret = power_up(sd);
-	if (ret) {
-		dev_err(&client->dev, "s5k6b2yx power-up err.\n");
-		goto fail_power_on;
-	}
+	return 0;
+}
 
-	ret = dev->platform_data->csi_cfg(sd, 1);
-	if (ret)
-		goto fail_csi_cfg;
+static int
+s5k6b2yx_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
 
-	/* config & detect sensor */
-	ret = s5k6b2yx_detect(client);
-	if (ret) {
-		dev_err(&client->dev, "s5k6b2yx_detect err s_config.\n");
-		goto fail_csi_cfg;
-	}
+	if (index >= N_RES)
+		return -EINVAL;
 
-	/* turn off sensor, after probed */
-	ret = power_down(sd);
-	if (ret) {
-		dev_err(&client->dev, "s5k6b2yx power-off err.\n");
-		goto fail_csi_cfg;
-	}
-	mutex_unlock(&dev->input_lock);
+	fse->min_width = s5k6b2yx_res[index].width;
+	fse->min_height = s5k6b2yx_res[index].height;
+	fse->max_width = s5k6b2yx_res[index].width;
+	fse->max_height = s5k6b2yx_res[index].height;
 
 	return 0;
+}
 
-fail_csi_cfg:
-	dev->platform_data->csi_cfg(sd, 0);
-fail_power_on:
-	power_down(sd);
-	dev_err(&client->dev, "sensor power-gating failed\n");
-fail_power_off:
-	if (dev->platform_data->platform_deinit)
-		dev->platform_data->platform_deinit();
-platform_init_failed:
-	mutex_unlock(&dev->input_lock);
-	return ret;
+static struct v4l2_mbus_framefmt *
+__s5k6b2yx_get_pad_format(struct s5k6b2yx_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
 }
 
-static int s5k6b2yx_g_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
+static int
+s5k6b2yx_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
 {
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format =
+			__s5k6b2yx_get_pad_format(dev, fh, fmt->pad, fmt->which);
 
-	if (!param)
-		return -EINVAL;
+	fmt->format = *format;
 
-	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_err(&client->dev,  "unsupported buffer type.\n");
-		return -EINVAL;
-	}
+	return 0;
+}
+
+static int
+s5k6b2yx_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 
-	memset(param, 0, sizeof(*param));
-	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
 
-	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
-		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
-		param->parm.capture.timeperframe.numerator = 1;
-		param->parm.capture.capturemode = dev->run_mode;
-		param->parm.capture.timeperframe.denominator =
-			s5k6b2yx_res[dev->fmt_idx].fps;
-	}
 	return 0;
 }
 
-static int s5k6b2yx_s_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
+static int
+s5k6b2yx_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
 {
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 	dev->run_mode = param->parm.capture.capturemode;
@@ -1136,111 +1469,80 @@ static int s5k6b2yx_s_parm(struct v4l2_subdev *sd,
 	return 0;
 }
 
-static int s5k6b2yx_g_frame_interval(struct v4l2_subdev *sd,
-				   struct v4l2_subdev_frame_interval *interval)
+int
+s5k6b2yx_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
 {
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	u16 lines_per_frame;
 
-	interval->interval.numerator = 1;
-	interval->interval.denominator = s5k6b2yx_res[dev->fmt_idx].fps;
+	/*
+	 * if no specific information to calculate the fps,
+	 * just used the value in sensor settings
+	 */
+	if (!dev->pixels_per_line || !dev->lines_per_frame) {
+		interval->interval.numerator = 1;
+		interval->interval.denominator = dev->fps;
+		return 0;
+	}
 
-	return 0;
-}
+	/*
+	 * DS: if coarse_integration_time is set larger than
+	 * lines_per_frame the frame_size will be expanded to
+	 * coarse_integration_time+1
+	 */
+	if (dev->coarse_itg > dev->lines_per_frame -
+			S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN) {
+
+		if (dev->coarse_itg > S5K6B2YX_MAX_EXPOSURE_SUPPORTED) {
+			lines_per_frame = dev->coarse_itg;
+		} else {
+			lines_per_frame = dev->coarse_itg +
+				S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN;
+		}
+	} else {
+		lines_per_frame = dev->lines_per_frame;
+	}
 
-static int s5k6b2yx_enum_mbus_code(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_mbus_code_enum *code)
-{
-	if (code->index >= MAX_FMTS)
-		return -EINVAL;
+	interval->interval.numerator = dev->pixels_per_line *
+					lines_per_frame;
+	interval->interval.denominator = dev->vt_pix_clk_freq_mhz;
 
-	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
 	return 0;
 }
 
-static int s5k6b2yx_enum_frame_size(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_frame_size_enum *fse)
+static int s5k6b2yx_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
 {
-	int index = fse->index;
-
-	if (index >= N_RES)
-		return -EINVAL;
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 
-	fse->min_width = s5k6b2yx_res[index].width;
-	fse->min_height = s5k6b2yx_res[index].height;
-	fse->max_width = s5k6b2yx_res[index].width;
-	fse->max_height = s5k6b2yx_res[index].height;
+	mutex_lock(&dev->input_lock);
+	*frames = s5k6b2yx_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
 
 	return 0;
-
 }
 
-static struct v4l2_mbus_framefmt *
-__s5k6b2yx_get_pad_format(struct s5k6b2yx_device *sensor,
-			struct v4l2_subdev_fh *fh, unsigned int pad,
-			enum v4l2_subdev_format_whence which)
+static int s5k6b2yx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+	struct s5k6b2yx_device *dev = container_of(ctrl->handler,
+	struct s5k6b2yx_device, ctrl_handler);
+	unsigned int val;
 
-	if (pad != 0) {
-		dev_err(&client->dev,
-			"__s5k6b2yx_get_pad_format err. pad %x\n", pad);
-		return NULL;
-	}
+	switch (ctrl->id) {
+	case V4L2_CID_LINK_FREQ:
+		val = s5k6b2yx_res[dev->fmt_idx].mipi_freq;
+		if (val == 0)
+			return -EINVAL;
 
-	switch (which) {
-	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
-	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &sensor->format;
+		ctrl->val = val * 1000;	/* To Hz */
+		break;
 	default:
-		return NULL;
-	}
-}
-
-static int s5k6b2yx_get_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
-{
-	struct s5k6b2yx_device *snr = to_s5k6b2yx_sensor(sd);
-	struct v4l2_mbus_framefmt *format =
-			__s5k6b2yx_get_pad_format(snr, fh, fmt->pad,
-					fmt->which);
-	if (!format)
 		return -EINVAL;
-
-	fmt->format = *format;
-	return 0;
-}
-
-static int s5k6b2yx_set_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
-{
-	struct s5k6b2yx_device *snr = to_s5k6b2yx_sensor(sd);
-
-	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		snr->format = fmt->format;
-
-	return 0;
-}
-
-static int s5k6b2yx_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
-{
-	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-
-	mutex_lock(&dev->input_lock);
-	*frames = s5k6b2yx_res[dev->fmt_idx].skip_frames;
-	mutex_unlock(&dev->input_lock);
+	}
 
 	return 0;
 }
 
-static const struct v4l2_subdev_sensor_ops s5k6b2yx_sensor_ops = {
-	.g_skip_frames	= s5k6b2yx_g_skip_frames,
-};
-
 static struct v4l2_ctrl_ops s5k6b2yx_ctrl_ops = {
 	.g_volatile_ctrl = s5k6b2yx_g_volatile_ctrl,
 };
@@ -1257,25 +1559,30 @@ static const struct v4l2_ctrl_config v4l2_ctrl_link_freq = {
 	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
 };
 
+static const struct v4l2_subdev_sensor_ops s5k6b2yx_sensor_ops = {
+	.g_skip_frames = s5k6b2yx_g_skip_frames,
+};
+
 static const struct v4l2_subdev_video_ops s5k6b2yx_video_ops = {
+	.try_mbus_fmt = s5k6b2yx_try_mbus_fmt,
+	.s_mbus_fmt = s5k6b2yx_set_mbus_fmt,
 	.s_stream = s5k6b2yx_s_stream,
-	.g_parm = s5k6b2yx_g_parm,
-	.s_parm = s5k6b2yx_s_parm,
 	.enum_framesizes = s5k6b2yx_enum_framesizes,
 	.enum_frameintervals = s5k6b2yx_enum_frameintervals,
-	.enum_mbus_fmt = s5k6b2yx_enum_mbus_fmt,
-	.try_mbus_fmt = s5k6b2yx_try_mbus_fmt,
+	.s_parm = s5k6b2yx_s_parm,
 	.g_mbus_fmt = s5k6b2yx_g_mbus_fmt,
-	.s_mbus_fmt = s5k6b2yx_s_mbus_fmt,
+	.enum_mbus_fmt = s5k6b2yx_enum_mbus_fmt,
 	.g_frame_interval = s5k6b2yx_g_frame_interval,
 };
 
 static const struct v4l2_subdev_core_ops s5k6b2yx_core_ops = {
-	.s_power = s5k6b2yx_s_power,
+	.g_chip_ident = s5k6b2yx_g_chip_ident,
 	.queryctrl = s5k6b2yx_queryctrl,
 	.g_ctrl = s5k6b2yx_g_ctrl,
 	.s_ctrl = s5k6b2yx_s_ctrl,
 	.ioctl = s5k6b2yx_ioctl,
+	.s_power = s5k6b2yx_s_power,
+	.init = s5k6b2yx_init,
 };
 
 static const struct v4l2_subdev_pad_ops s5k6b2yx_pad_ops = {
@@ -1292,19 +1599,17 @@ static const struct v4l2_subdev_ops s5k6b2yx_ops = {
 	.sensor = &s5k6b2yx_sensor_ops,
 };
 
+static const struct media_entity_operations s5k6b2yx_entity_ops = {
+	.link_setup = NULL,
+};
+
 static int s5k6b2yx_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
-	dev_dbg(&client->dev, "s5k6b2yx_remove...\n");
-
-	if (dev->platform_data->platform_deinit)
-		dev->platform_data->platform_deinit();
 
 	dev->platform_data->csi_cfg(sd, 0);
-	v4l2_ctrl_handler_free(&dev->ctrl_handler);
 	v4l2_device_unregister_subdev(sd);
-	media_entity_cleanup(&dev->sd.entity);
 	kfree(dev);
 
 	return 0;
@@ -1319,25 +1624,25 @@ static int __s5k6b2yx_init_ctrl_handler(struct s5k6b2yx_device *dev)
 	v4l2_ctrl_handler_init(&dev->ctrl_handler, 3);
 
 	dev->link_freq = v4l2_ctrl_new_custom(&dev->ctrl_handler,
-					      &v4l2_ctrl_link_freq,
-					      NULL);
+				&v4l2_ctrl_link_freq, NULL);
 
 	if (dev->ctrl_handler.error || dev->link_freq == NULL)
 		return dev->ctrl_handler.error;
 
 	dev->sd.ctrl_handler = hdl;
-
 	return 0;
 }
+
 static int s5k6b2yx_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
+			 const struct i2c_device_id *id)
 {
 	struct s5k6b2yx_device *dev;
-	int ret;
+	int ret = 0;
 
+	/* allocate sensor device & init sub device */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
-		dev_err(&client->dev, "out of memory\n");
+		dev_err(&client->dev, "%s: out of memory\n", __func__);
 		return -ENOMEM;
 	}
 
@@ -1345,39 +1650,51 @@ static int s5k6b2yx_probe(struct i2c_client *client,
 
 	dev->fmt_idx = 0;
 	v4l2_i2c_subdev_init(&(dev->sd), client, &s5k6b2yx_ops);
-
 	if (client->dev.platform_data) {
 		ret = s5k6b2yx_s_config(&dev->sd, client->irq,
 				       client->dev.platform_data);
-		if (ret)
+		if (ret) {
+			dev_err(&client->dev, "%s: configuration fail!!\n",
+							__func__);
 			goto out_free;
+		}
 	}
 
 	ret = __s5k6b2yx_init_ctrl_handler(dev);
-	if (ret)
+	if (ret) {
+		dev_err(&client->dev, "%s: init ctrl handler fail!!\n", __func__);
 		goto out_ctrl_handler_free;
+	}
 
 	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
-	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	dev->sd.entity.ops = &s5k6b2yx_entity_ops;
 	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
-
+	dev->flip = 0;
 	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
 	if (ret)
 		s5k6b2yx_remove(client);
 
+	v4l2_info(client, "%s: done!!\n", __func__);
+
 	return ret;
 
 out_ctrl_handler_free:
 	v4l2_ctrl_handler_free(&dev->ctrl_handler);
-
 out_free:
 	v4l2_device_unregister_subdev(&dev->sd);
 	kfree(dev);
 	return ret;
 }
 
+static const struct i2c_device_id s5k6b2yx_id[] = {
+	{S5K6B2YX_NAME, 0},
+	{ }
+};
+
 MODULE_DEVICE_TABLE(i2c, s5k6b2yx_id);
+
 static struct i2c_driver s5k6b2yx_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
@@ -1388,20 +1705,19 @@ static struct i2c_driver s5k6b2yx_driver = {
 	.id_table = s5k6b2yx_id,
 };
 
-static int init_s5k6b2yx(void)
+static __init int init_s5k6b2yx(void)
 {
 	return i2c_add_driver(&s5k6b2yx_driver);
 }
 
-static void exit_s5k6b2yx(void)
+static __exit void exit_s5k6b2yx(void)
 {
-
 	i2c_del_driver(&s5k6b2yx_driver);
 }
 
 module_init(init_s5k6b2yx);
 module_exit(exit_s5k6b2yx);
 
-MODULE_AUTHOR("Tao Jing <jing.tao@intel.com>");
-MODULE_DESCRIPTION("A low-level driver for SANGSUME S5K6B2YX sensors");
+MODULE_DESCRIPTION("A low-level driver for S5K6B2YX sensor");
+MODULE_AUTHOR("Max Kim <max.kim@intel.com>");
 MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
index 7ba5952..73e42e3 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
@@ -1,7 +1,7 @@
 /*
- * Support for OmniVision S5K6B2YX 1080p HD camera sensor.
+ * Support for S5K6B2YX camera sensor.
  *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -21,45 +21,89 @@
 
 #ifndef __S5K6B2YX_H__
 #define __S5K6B2YX_H__
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
 #include <linux/kernel.h>
+#include <linux/spinlock.h>
 #include <linux/types.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
 #include <linux/videodev2.h>
-#include <linux/spinlock.h>
-#include <media/v4l2-subdev.h>
-#include <media/v4l2-device.h>
-#include <media/v4l2-chip-ident.h>
 #include <linux/v4l2-mediabus.h>
 #include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
 #include <media/v4l2-ctrls.h>
 
-#include <linux/atomisp_platform.h>
-
-#define S5K6B2YX_NAME		"s5k6b2yx"
+#define S5K6B2YX_NAME	"s5k6b2yx"
+#define V4L2_IDENT_S5K6B2YX 8245
 
 /* Defines for register writes and register array processing */
+#define S5K6B2YX_BYTE_MAX	30
+#define S5K6B2YX_SHORT_MAX	16
 #define I2C_MSG_LENGTH		0x2
 #define I2C_RETRY_COUNT		5
 
-#define S5K6B2YX_FOCAL_LENGTH_NUM	278	/*2.78mm*/
-#define S5K6B2YX_FOCAL_LENGTH_DEM	100
-#define S5K6B2YX_F_NUMBER_DEFAULT_NUM	26
-#define S5K6B2YX_F_NUMBER_DEM	10
+#define S5K6B2YX_TEST_PATTERN_MODE	0x0601
+
+#define S5K6B2YX_HFLIP_BIT	0x1
+#define S5K6B2YX_VFLIP_BIT	0x2
+#define S5K6B2YX_VFLIP_OFFSET	1
+#define S5K6B2YX_IMG_ORIENTATION 0x0101
 
+#define I2C_RETRY_COUNT		5
 #define MAX_FMTS		1
 
+#define S5K6B2YX_PID_LOW	0x1
+#define S5K6B2YX_PID_HIGH	0x0
+#define S5K6B2YX_REV		0x1
+#define S5K6B2YX_MOD_ID		0x6B20
+
+#define S5K6B2YX_RES_WIDTH_MAX	1936
+#define S5K6B2YX_RES_HEIGHT_MAX	1096
+
+#define S5K6B2YX_FINE_INTEGRATION_TIME		0x0200
+#define S5K6B2YX_COARSE_INTEGRATION_TIME	0x0202
+#define S5K6B2YX_GLOBAL_GAIN			0x0204
+
+#define S5K6B2YX_FINE_INTG_TIME_MIN 0
+#define S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN 0
+#define S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN	6
+#define S5K6B2YX_COARSE_INTEGRATION_TIME_MIN	1
+
+#define S5K6B2YX_MAX_EXPOSURE_SUPPORTED (0xffff - S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN)
+#define S5K6B2YX_MAX_GLOBAL_GAIN_SUPPORTED	0x0200
+#define S5K6B2YX_MIN_GLOBAL_GAIN_SUPPORTED	0x0020
+
+#define S5K6B2YX_INTG_BUF_COUNT		2
+
+#define S5K6B2YX_VT_PIX_CLK_DIV		0x0300
+#define S5K6B2YX_VT_SYS_CLK_DIV		0x0302
+#define S5K6B2YX_PRE_PLL_CLK_DIV	0x0304
+#define S5K6B2YX_PLL_MULTIPLIER		0x0306
+#define S5K6B2YX_FRAME_LENGTH_LINES	0x0340
+
+#define S5K6B2YX_MCLK	192
+
+#define S5K6B2YX_HORIZONTAL_START_H	0x0344
+#define S5K6B2YX_VERTICAL_START_H	0x0346
+#define S5K6B2YX_HORIZONTAL_END_H	0x0348
+#define S5K6B2YX_VERTICAL_END_H		0x034a
+#define S5K6B2YX_HORIZONTAL_OUTPUT_SIZE_H	0x034c
+#define S5K6B2YX_VERTICAL_OUTPUT_SIZE_H		0x034e
+
 /*
  * focal length bits definition:
  * bits 31-16: numerator, bits 15-0: denominator
  */
-#define S5K6B2YX_FOCAL_LENGTH_DEFAULT 0x1160064
+#define S5K6B2YX_FOCAL_LENGTH_DEFAULT	0x14a0064
 
 /*
  * current f-number bits definition:
  * bits 31-16: numerator, bits 15-0: denominator
  */
-#define S5K6B2YX_F_NUMBER_DEFAULT 0x1a000a
+#define S5K6B2YX_F_NUMBER_DEFAULT	0x18000a
 
 /*
  * f-number range bits definition:
@@ -68,110 +112,163 @@
  * bits 15-8: min f-number numerator
  * bits 7-0: min f-number denominator
  */
-#define S5K6B2YX_F_NUMBER_RANGE 0x1a0a1a0a
-#define S5K6B2YX_ID	0x6b20
+#define S5K6B2YX_F_NUMBER_RANGE	0x180a180a
 
-#define S5K6B2YX_FINE_INTG_TIME_MIN 0
-#define S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN 0
-#define S5K6B2YX_COARSE_INTG_TIME_MIN 1
-#define S5K6B2YX_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
+#define S5K6B2YX_BIN_FACTOR_MAX	2
 
-/*
- * S5K6B2YX System control registers
- */
-#define S5K6B2YX_REG_CHIP_ID_H		0x0000
-#define S5K6B2YX_REG_REVISION		0x0002
-
-#define S5K6B2YX_REG_MODE_SELECT	0x0100
-#define S5K6B2YX_REG_IMG_ORI		0x0101
-#define S5K6B2YX_REG_SOFT_RESET		0x0103
-#define S5K6B2YX_REG_GROUND_HOLD	0x0104
-
-#define S5K6B2YX_REG_FINE_INTEG		0x0200
-#define S5K6B2YX_REG_COARSE_INTEG	0x0202
-#define S5K6B2YX_REG_ANALOG_GAIN	0x0204
-
-#define S5K6B2YX_REG_VT_PIX_CLK_DIV_H	0x0300
-#define S5K6B2YX_REG_VT_SYS_CLK_DIV_H	0x0302
-#define S5K6B2YX_REG_PRE_PLL_CLK_DIV_H	0x0304
-#define S5K6B2YX_REG_PLL_MULTIPLIER_H	0x0306
-#define S5K6B2YX_REG_OP_PIX_CLK_DIV_H	0x0308
-#define S5K6B2YX_REG_OP_SYS_CLK_DIV_H	0x030a
-
-#define S5K6B2YX_REG_H_CROP_START_H	0x0344
-#define S5K6B2YX_REG_V_CROP_START_H	0x0346
-#define S5K6B2YX_REG_H_CROP_END_H	0x0348
-#define S5K6B2YX_REG_V_CROP_END_H	0x034a
-#define S5K6B2YX_REG_H_OUTSIZE_H	0x034c
-#define S5K6B2YX_REG_V_OUTSIZE_H	0x034e
-
-#define S5K6B2YX_START_STREAMING	0x01
-#define S5K6B2YX_STOP_STREAMING		0x00
-
-struct regval_list {
-	u16 reg_num;
-	u8 value;
-};
+/* Defines for lens/VCM */
+#define S5K6B2YX_FOCAL_LENGTH_NUM	185	/* 1.85 mm */
+#define S5K6B2YX_FOCAL_LENGTH_DEM	100
+#define S5K6B2YX_F_NUMBER_DEFAULT_NUM	24	/*  F/2.4 */
+#define S5K6B2YX_F_NUMBER_DEM	10
 
-struct s5k6b2yx_resolution {
-	u8 *desc;
-	const struct s5k6b2yx_reg *regs;
-	int res;
-	int width;
-	int height;
-	int fps;
-	int pix_clk_freq;
-	u32 skip_frames;
-	u16 pixels_per_line;
-	u16 lines_per_frame;
-	u8 bin_factor_x;
-	u8 bin_factor_y;
-	u8 bin_mode;
-	bool used;
-	int mipi_freq;
+#define S5K6B2YX_INVALID_CONFIG	0xffffffff
+
+#define	v4l2_format_capture_type_entry(_width, _height, \
+		_pixelformat, _bytesperline, _colorspace) \
+	{\
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\
+		.fmt.pix.width = (_width),\
+		.fmt.pix.height = (_height),\
+		.fmt.pix.pixelformat = (_pixelformat),\
+		.fmt.pix.bytesperline = (_bytesperline),\
+		.fmt.pix.colorspace = (_colorspace),\
+		.fmt.pix.sizeimage = (_height)*(_bytesperline),\
+	}
+
+#define	s_output_format_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps) \
+	{\
+		.v4l2_fmt = v4l2_format_capture_type_entry(_width, \
+			_height, _pixelformat, _bytesperline, \
+				_colorspace),\
+		.fps = (_fps),\
+	}
+
+#define	s_output_format_reg_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps, _reg_setting) \
+	{\
+		.s_fmt = s_output_format_entry(_width, _height,\
+				_pixelformat, _bytesperline, \
+				_colorspace, _fps),\
+		.reg_setting = (_reg_setting),\
+	}
+
+struct s_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
 };
 
-struct s5k6b2yx_format {
-	u8 *desc;
-	u32 pixelformat;
-	struct s5k6b2yx_reg *regs;
+#define	v4l2_queryctrl_entry_integer(_id, _name,\
+		_minimum, _maximum, _step, \
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_INTEGER, \
+		.name = _name, \
+		.minimum = (_minimum), \
+		.maximum = (_maximum), \
+		.step = (_step), \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+#define	v4l2_queryctrl_entry_boolean(_id, _name,\
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_BOOLEAN, \
+		.name = _name, \
+		.minimum = 0, \
+		.maximum = 1, \
+		.step = 1, \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+
+#define	s_ctrl_id_entry_integer(_id, _name, \
+		_minimum, _maximum, _step, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
+				_minimum, _maximum, _step,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+#define	s_ctrl_id_entry_boolean(_id, _name, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+enum s5k6b2yx_tok_type {
+	S5K6B2YX_8BIT  = 0x0001,
+	S5K6B2YX_16BIT = 0x0002,
+	S5K6B2YX_RMW   = 0x0010,
+	S5K6B2YX_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	S5K6B2YX_TOK_DELAY  = 0xfe00, /* delay token for reg list */
+	S5K6B2YX_TOK_MASK = 0xfff0
 };
 
-struct s5k6b2yx_control {
-	struct v4l2_queryctrl qc;
-	int (*query)(struct v4l2_subdev *sd, s32 *value);
-	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+enum s5k6b2yx_mode {
+	CAM_HW_STBY = 0, /* hw standby mode */
+	CAM_SW_STBY, /* sw standby mode */
+	CAM_VIS_STBY /* low power vision sening standby mode */
 };
 
 /*
- * s5k6b2yx device structure.
+ * If register address or register width is not 32 bit width,
+ * user needs to convert it manually
  */
+
+struct s_register_setting {
+	u32 reg;
+	u32 val;
+};
+
+struct s_output_format {
+	struct v4l2_format v4l2_fmt;
+	int fps;
+};
+
 struct s5k6b2yx_device {
 	struct v4l2_subdev sd;
 	struct media_pad pad;
 	struct v4l2_mbus_framefmt format;
-	struct mutex input_lock;
-
 	struct camera_sensor_platform_data *platform_data;
-	int vt_pix_clk_freq_mhz;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	struct s5k6b2yx_vcm *vcm_driver;
 	int fmt_idx;
+	int status;
+	int streaming;
+	int power;
 	int run_mode;
+	int vt_pix_clk_freq_mhz;
+	u16 sensor_id;
+	u16 coarse_itg;
+	u16 fine_itg;
+	u16 gain;
+	u16 digital_gain;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u16 flip;
+	u8 fps;
 	u8 res;
 	u8 type;
+	u8 sensor_revision;
+	enum s5k6b2yx_mode mode;
 
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct v4l2_ctrl *link_freq;
 };
 
-enum s5k6b2yx_tok_type {
-	S5K6B2YX_8BIT  = 0x0001,
-	S5K6B2YX_16BIT = 0x0002,
-	S5K6B2YX_32BIT = 0x0004,
-	S5K6B2YX_TOK_TERM   = 0xf000,	/* terminating token for reg list */
-	S5K6B2YX_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
-	S5K6B2YX_TOK_MASK = 0xfff0
-};
-
 /**
  * struct s5k6b2yx_reg - MI sensor  register format
  * @type: type of the register
@@ -182,14 +279,13 @@ enum s5k6b2yx_tok_type {
  */
 struct s5k6b2yx_reg {
 	enum s5k6b2yx_tok_type type;
-	u16 reg;
+	u16 sreg;
 	u32 val;	/* @set value for read/mod/write, @mask */
 };
 
 #define to_s5k6b2yx_sensor(x) container_of(x, struct s5k6b2yx_device, sd)
 
 #define S5K6B2YX_MAX_WRITE_BUF_SIZE	30
-
 struct s5k6b2yx_write_buffer {
 	u16 addr;
 	u8 data[S5K6B2YX_MAX_WRITE_BUF_SIZE];
@@ -200,145 +296,349 @@ struct s5k6b2yx_write_ctrl {
 	struct s5k6b2yx_write_buffer buffer;
 };
 
-static const struct i2c_device_id s5k6b2yx_id[] = {
-	{S5K6B2YX_NAME, 0},
-	{}
+struct s5k6b2yx_format_struct {
+	u8 *desc;
+	struct regval_list *regs;
+	u32 pixelformat;
 };
 
-/*
- * Register settings for one-time initialization
- */
-static struct s5k6b2yx_reg const s5k6b2yx_init[] = {
+struct s5k6b2yx_resolution {
+	u8 *desc;
+	const struct s5k6b2yx_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	bool used;
+	enum s5k6b2yx_mode mode;
+	u32 skip_frames;
+	u32 code;
+	int mipi_freq;
+};
+
+struct s5k6b2yx_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+/* init settings */
+static struct s5k6b2yx_reg const s5k6b2yx_init_config[] = {
 	/* Vendor specific */
-	{S5K6B2YX_8BIT, 0x31d3, 0x01}, /* efuse read en */
-	{S5K6B2YX_8BIT, 0x3426, 0x3a}, /* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
-	{S5K6B2YX_8BIT, 0x340d, 0x30}, /* efuse clock off */
-
-	{S5K6B2YX_8BIT, 0x3067, 0x25}, /* adc_sat[mV]=617mV */
-	{S5K6B2YX_8BIT, 0x307d, 0x08}, /* dbr_tune_tgs */
-	{S5K6B2YX_8BIT, 0x307e, 0x08}, /* dbr_tune_rg */
-	{S5K6B2YX_8BIT, 0x307f, 0x08}, /* dbr_tune_fdb */
-	{S5K6B2YX_8BIT, 0x3080, 0x04}, /* dbr_tune_ntg */
-	{S5K6B2YX_8BIT, 0x3073, 0x73}, /* comp1_bias, comp2_bias */
-	{S5K6B2YX_8BIT, 0x3074, 0x45}, /* pix_bias, pix_bias_boost */
-	{S5K6B2YX_8BIT, 0x3075, 0xd4}, /* clp_lvl */
-	{S5K6B2YX_8BIT, 0x3085, 0xf0}, /* rdv_option; LOB_PLA enable */
-	{S5K6B2YX_8BIT, 0x3068, 0x55}, /* ms[15:8]; x4~ */
-	{S5K6B2YX_8BIT, 0x3069, 0x00}, /* ms[7:0]; x1~x4 */
-	{S5K6B2YX_8BIT, 0x3063, 0x08}, /* cds_option[15:8];[11]ldb nmos sw enable=1 */
-	{S5K6B2YX_8BIT, 0x3064, 0x00}, /* cds_option[7:0]; */
-	{S5K6B2YX_8BIT, 0x3010, 0x04}, /* FD start 2->4 for low lux fluctuation */
-
-	{S5K6B2YX_8BIT, 0x3247, 0x11}, /*[4] fadlc_blst_en */
-	{S5K6B2YX_8BIT, 0x3083, 0x00}, /* blst_en_cintr = 16 */
-	{S5K6B2YX_8BIT, 0x3084, 0x10},
+	{ S5K6B2YX_8BIT, 0x31d3, 0x01 }, /* efuse read en */
+	{ S5K6B2YX_8BIT, 0x3426, 0x3a }, /* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
+	{ S5K6B2YX_8BIT, 0x340d, 0x30 }, /* efuse clock off */
+
+	{ S5K6B2YX_8BIT, 0x3067, 0x25 }, /* adc_sat[mV]=617mV */
+	{ S5K6B2YX_8BIT, 0x307d, 0x08 }, /* dbr_tune_tgs */
+	{ S5K6B2YX_8BIT, 0x307e, 0x08 }, /* dbr_tune_rg */
+	{ S5K6B2YX_8BIT, 0x307f, 0x08 }, /* dbr_tune_fdb */
+	{ S5K6B2YX_8BIT, 0x3080, 0x04 }, /* dbr_tune_ntg */
+	{ S5K6B2YX_8BIT, 0x3073, 0x73 }, /* comp1_bias, comp2_bias */
+	{ S5K6B2YX_8BIT, 0x3074, 0x45 }, /* pix_bias, pix_bias_boost */
+	{ S5K6B2YX_8BIT, 0x3075, 0xd4 }, /* clp_lvl */
+	{ S5K6B2YX_8BIT, 0x3085, 0xf0 }, /* rdv_option; LOB_PLA enable */
+	{ S5K6B2YX_8BIT, 0x3068, 0x55 }, /* ms[15:8]; x4~ */
+	{ S5K6B2YX_8BIT, 0x3069, 0x00 }, /* ms[7:0]; x1~x4 */
+	{ S5K6B2YX_8BIT, 0x3063, 0x08 }, /* cds_option[15:8];[11]ldb nmos sw enable=1 */
+	{ S5K6B2YX_8BIT, 0x3064, 0x00 }, /* cds_option[7:0]; */
+	{ S5K6B2YX_8BIT, 0x3010, 0x04 }, /* FD start 2->4 for low lux fluctuation */
+
+	{ S5K6B2YX_8BIT, 0x3247, 0x11 }, /*[4] fadlc_blst_en */
+	{ S5K6B2YX_8BIT, 0x3083, 0x00 }, /* blst_en_cintr = 16 */
+	{ S5K6B2YX_8BIT, 0x3084, 0x10 },
 
 	/* PLL Setting: ext_clk = 19.2MHz; PLL output = 744MHz */
-	{S5K6B2YX_8BIT, 0x0305, 0x04}, /* pll_pre_pre_div = 4 */
-	{S5K6B2YX_8BIT, 0x0306, 0x00},
-	{S5K6B2YX_8BIT, 0x0307, 0x9B}, /* pll_multiplier = 155 */
+	{ S5K6B2YX_8BIT, 0x0305, 0x04 }, /* pll_pre_pre_div = 4 */
+	{ S5K6B2YX_8BIT, 0x0306, 0x00 },
+	{ S5K6B2YX_8BIT, 0x0307, 0x9b }, /* pll_multiplier = 155 */
 
 	/* Vendor specific */
-	{S5K6B2YX_8BIT, 0x3351, 0x02},
-	{S5K6B2YX_8BIT, 0x3352, 0xdc},
-	{S5K6B2YX_8BIT, 0x3353, 0x00},
-	{S5K6B2YX_8BIT, 0x3354, 0x00},
+	{ S5K6B2YX_8BIT, 0x3351, 0x02 },
+	{ S5K6B2YX_8BIT, 0x3352, 0xdc },
+	{ S5K6B2YX_8BIT, 0x3353, 0x00 },
+	{ S5K6B2YX_8BIT, 0x3354, 0x00 },
 
 	/* others */
-	{S5K6B2YX_8BIT, 0x7339, 0x03}, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	{ S5K6B2YX_8BIT, 0x7339, 0x03 }, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	{ S5K6B2YX_8BIT, 0x0202, 0x03 },
+	{ S5K6B2YX_8BIT, 0x0203, 0x88 }, /* TBD: Coarse_integration_time */
+	{ S5K6B2YX_8BIT, 0x0204, 0x00 },
+	{ S5K6B2YX_8BIT, 0x0205, 0x2a }, /* TBD: Analogue_gain_code_global */
 
-	{S5K6B2YX_8BIT, 0x0202, 0x03},
-	{S5K6B2YX_8BIT, 0x0203, 0x88}, /* TBD: Coarse_integration_time */
-	{S5K6B2YX_8BIT, 0x0204, 0x00},
-	{S5K6B2YX_8BIT, 0x0205, 0x2a}, /* TBD: Analogue_gain_code_global */
-	{S5K6B2YX_TOK_TERM, 0, 0},
+
+
+
+	{S5K6B2YX_TOK_TERM, 0, 0}
 };
-/*
- * Register settings for various resolution
- */
-static struct s5k6b2yx_reg const s5k6b2yx_1936_1096_30fps[] = {
-	{S5K6B2YX_8BIT, 0x0344, 0x00}, /* x_addr_start MSB */
-	{S5K6B2YX_8BIT, 0x0345, 0x00}, /* x_addr_start LSB */
-	{S5K6B2YX_8BIT, 0x0346, 0x00}, /* y_addr_start MSB */
-	{S5K6B2YX_8BIT, 0x0347, 0x02}, /* y_addr_start LSB */
-
-	{S5K6B2YX_8BIT, 0x0348, 0x07}, /* x_addr_end MSB */
-	{S5K6B2YX_8BIT, 0x0349, 0x8F}, /* x_addr_end LSB */
-	{S5K6B2YX_8BIT, 0x034a, 0x04}, /* y_addr_end MSB */
-	{S5K6B2YX_8BIT, 0x034b, 0x47}, /* y_addr_end LSB */
-
-	{S5K6B2YX_8BIT, 0x034c, 0x07}, /* x_output_size MSB */
-	{S5K6B2YX_8BIT, 0x034d, 0x90}, /* x_output_size LSB */
-	{S5K6B2YX_8BIT, 0x034e, 0x04}, /* y_output_size MSB */
-	{S5K6B2YX_8BIT, 0x034f, 0x48}, /* y_output_size LSB */
-
-	{S5K6B2YX_8BIT, 0x0340, 0x04}, /* frame_length_lines MSB */
-	{S5K6B2YX_8BIT, 0x0341, 0x66}, /* frame_length_lines LSB */
-	{S5K6B2YX_8BIT, 0x0342, 0x08}, /* line_length_pck MSB */
-	{S5K6B2YX_8BIT, 0x0343, 0x9b}, /* line_length_pck LSB */
-	{S5K6B2YX_TOK_TERM, 0, 0},
+
+/* Stream mode */
+static struct s5k6b2yx_reg const s5k6b2yx_suspend[] = {
+	{S5K6B2YX_8BIT, 0x0100, 0x0 },
+	{S5K6B2YX_TOK_TERM, 0, 0 },
+};
+
+static struct s5k6b2yx_reg const s5k6b2yx_streaming[] = {
+	{S5K6B2YX_8BIT, 0x0100, 0x1 },
+	{S5K6B2YX_TOK_TERM, 0, 0 },
+};
+
+static struct s5k6b2yx_reg const s5k6b2yx_vis_suspend[] = {
+	{S5K6B2YX_8BIT, 0x4100, 0x0 },
+	{S5K6B2YX_TOK_TERM, 0, 0 }
+};
+
+static struct s5k6b2yx_reg const s5k6b2yx_vis_streaming[] = {
+	{S5K6B2YX_8BIT, 0x4100, 0x1 },
+	{ S5K6B2YX_TOK_TERM, 0, 0}
+};
+
+/* GROUPED_PARAMETER_HOLD */
+static struct s5k6b2yx_reg const s5k6b2yx_param_hold[] = {
+	{ S5K6B2YX_8BIT,  0x0104, 0x1 },
+	{ S5K6B2YX_TOK_TERM, 0, 0 }
+};
+static struct s5k6b2yx_reg const s5k6b2yx_param_update[] = {
+	{ S5K6B2YX_8BIT,  0x0104, 0x0 },
+	{ S5K6B2YX_TOK_TERM, 0, 0 }
+};
+
+/* Settings */
+static struct s5k6b2yx_reg const s5k6b2yx_184x104_15fps[] = {
+	{ S5K6B2YX_8BIT, 0x4307, 0xB7}, /* pll_multiplier */
+	{ S5K6B2YX_8BIT, 0x6030, 0x13}, /* EXTCLK_MHz */
+	{ S5K6B2YX_8BIT, 0x6031, 0x37},
+	{ S5K6B2YX_8BIT, 0x3412, 0x4B}, /* streaming_enable_time */
+	{ S5K6B2YX_8BIT, 0x3413, 0x13},
+	{ S5K6B2YX_8BIT, 0x7412, 0x07}, /* streaming_enable_time_alv */
+	{ S5K6B2YX_8BIT, 0x7413, 0x80},
+
+	/* 8bit mode */
+	{ S5K6B2YX_8BIT, 0x7030, 0x0E},
+	{ S5K6B2YX_8BIT, 0x7031, 0x2F},
+
+	/* Analog Tuning */
+	{ S5K6B2YX_8BIT, 0x7067, 0x00}, /* adc_sat_alv (392mV) (20120807) */
+	{ S5K6B2YX_8BIT, 0x7074, 0x22}, /* pix_bias_alv, pix_bias_boost_alv */
+
+
+	/* Dark Tuning */
+	{ S5K6B2YX_8BIT, 0x7402, 0x1F}, /* data_depedestal_adlc_alv */
+	{ S5K6B2YX_8BIT, 0x7403, 0xC0},
+	{ S5K6B2YX_8BIT, 0x7247, 0x01}, /* adlc_option (20121116) */
+
+	/* Remove Dark Band (20121031) */
+	{ S5K6B2YX_8BIT, 0x7412, 0x09}, /* streaming_enable_time_alv (103.9usec) */
+	{ S5K6B2YX_8BIT, 0x7413, 0xB9},
+	{ S5K6B2YX_8BIT, 0x7430, 0x05}, /* cintc_default_1_alv */
+	{ S5K6B2YX_8BIT, 0x7432, 0x02}, /* cintc_default_2_alv */
+	{ S5K6B2YX_8BIT, 0x7433, 0x32},
+
+	/* Remove  Sun spot (20120807) */
+	{ S5K6B2YX_8BIT, 0x7075, 0x3D}, /* clp_lvl_alv */
+
+	/* Remove CFPN (20120830) -> (20121026 EVT1) */
+	{ S5K6B2YX_8BIT, 0x7066, 0x09}, /* off_rst_alv */
+
+
+	/* AE setting (20121025 EVT1) */
+	/* weight */
+	{ S5K6B2YX_8BIT, 0x6000, 0x01},
+	{ S5K6B2YX_8BIT, 0x6001, 0x10},
+	{ S5K6B2YX_8BIT, 0x6002, 0x14},
+	{ S5K6B2YX_8BIT, 0x6003, 0x41},
+	{ S5K6B2YX_8BIT, 0x6004, 0x14},
+	{ S5K6B2YX_8BIT, 0x6005, 0x41},
+	{ S5K6B2YX_8BIT, 0x6006, 0x01},
+	{ S5K6B2YX_8BIT, 0x6007, 0x10},
+
+	/* number of pixel */
+	{ S5K6B2YX_8BIT, 0x5030, 0x1C},
+	{ S5K6B2YX_8BIT, 0x5031, 0x08},
+
+	/* Speed */
+	{ S5K6B2YX_8BIT, 0x5034, 0x00},
+
+	/* Innner Target Tolerance */
+	{ S5K6B2YX_8BIT, 0x503F, 0x03},
+
+	/* patch height (20121116) */
+	{ S5K6B2YX_8BIT, 0x6015, 0x19},
+
+	/* G + R Setting (20120813) */
+	/* Vision Senser Data = 0.5*Gr + 0.5*R */
+	{ S5K6B2YX_8BIT, 0x6029, 0x02}, /* [2:0] : 1bit integer, 2bit fraction */
+	{ S5K6B2YX_8BIT, 0x602A, 0x02}, /* [2:0] : 1bit integer, 2bit fraction */
+
+
+	/* For Analog Gain 16x (20120904) */
+	{ S5K6B2YX_8BIT, 0x7018, 0xCF},
+	{ S5K6B2YX_8BIT, 0x7019, 0xDB},
+	{ S5K6B2YX_8BIT, 0x702A, 0x8D},
+	{ S5K6B2YX_8BIT, 0x702B, 0x60},
+	{ S5K6B2YX_8BIT, 0x5035, 0x02}, /* analog gain max */
+
+
+	/* BIT_RATE_MBPS_alv (585Mbps) */
+	{ S5K6B2YX_8BIT, 0x7351, 0x02},
+	{ S5K6B2YX_8BIT, 0x7352, 0x49},
+	{ S5K6B2YX_8BIT, 0x7353, 0x00},
+	{ S5K6B2YX_8BIT, 0x7354, 0x00},
+
+	{ S5K6B2YX_8BIT, 0x7339, 0x03}, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+#ifdef VISION_MODE_TEST_PATTERN
+	{ S5K6B2YX_8BIT, 0x7203, 0x42}, /* to enable test pattern */
+#endif
+
+	{ S5K6B2YX_TOK_TERM, 0, 0 }
+};
+
+static struct s5k6b2yx_reg const s5k6b2yx_1936x1096_30fps[] = {
+    /* Vendor specific */
+	{ S5K6B2YX_8BIT, 0x31d3, 0x01 }, /* efuse read en */
+	{ S5K6B2YX_8BIT, 0x3426, 0x3a }, /* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
+	{ S5K6B2YX_8BIT, 0x340d, 0x30 }, /* efuse clock off */
+
+	{ S5K6B2YX_8BIT, 0x3067, 0x25 }, /* adc_sat[mV]=617mV */
+	{ S5K6B2YX_8BIT, 0x307d, 0x08 }, /* dbr_tune_tgs */
+	{ S5K6B2YX_8BIT, 0x307e, 0x08 }, /* dbr_tune_rg */
+	{ S5K6B2YX_8BIT, 0x307f, 0x08 }, /* dbr_tune_fdb */
+	{ S5K6B2YX_8BIT, 0x3080, 0x04 }, /* dbr_tune_ntg */
+	{ S5K6B2YX_8BIT, 0x3073, 0x73 }, /* comp1_bias, comp2_bias */
+	{ S5K6B2YX_8BIT, 0x3074, 0x45 }, /* pix_bias, pix_bias_boost */
+	{ S5K6B2YX_8BIT, 0x3075, 0xd4 }, /* clp_lvl */
+	{ S5K6B2YX_8BIT, 0x3085, 0xf0 }, /* rdv_option; LOB_PLA enable */
+	{ S5K6B2YX_8BIT, 0x3068, 0x55 }, /* ms[15:8]; x4~ */
+	{ S5K6B2YX_8BIT, 0x3069, 0x00 }, /* ms[7:0]; x1~x4 */
+	{ S5K6B2YX_8BIT, 0x3063, 0x08 }, /* cds_option[15:8];[11]ldb nmos sw enable=1 */
+	{ S5K6B2YX_8BIT, 0x3064, 0x00 }, /* cds_option[7:0]; */
+	{ S5K6B2YX_8BIT, 0x3010, 0x04 }, /* FD start 2->4 for low lux fluctuation */
+
+	{ S5K6B2YX_8BIT, 0x3247, 0x11 }, /*[4] fadlc_blst_en */
+	{ S5K6B2YX_8BIT, 0x3083, 0x00 }, /* blst_en_cintr = 16 */
+	{ S5K6B2YX_8BIT, 0x3084, 0x10 },
+
+	/* PLL Setting: ext_clk = 19.2MHz; PLL output = 744MHz */
+	{ S5K6B2YX_8BIT, 0x0305, 0x04 }, /* pll_pre_pre_div = 4 */
+	{ S5K6B2YX_8BIT, 0x0306, 0x00 },
+	{ S5K6B2YX_8BIT, 0x0307, 0x9b }, /* pll_multiplier = 155 */
+
+	/* Vendor specific */
+	{ S5K6B2YX_8BIT, 0x3351, 0x02 },
+	{ S5K6B2YX_8BIT, 0x3352, 0xdc },
+	{ S5K6B2YX_8BIT, 0x3353, 0x00 },
+	{ S5K6B2YX_8BIT, 0x3354, 0x00 },
+
+	/* others */
+	{ S5K6B2YX_8BIT, 0x7339, 0x03 }, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	{ S5K6B2YX_8BIT, 0x0202, 0x03 },
+	{ S5K6B2YX_8BIT, 0x0203, 0x88 }, /* TBD: Coarse_integration_time */
+	{ S5K6B2YX_8BIT, 0x0204, 0x00 },
+	{ S5K6B2YX_8BIT, 0x0205, 0x2a }, /* TBD: Analogue_gain_code_global */
+
+	/* Resolution Setting */
+	{ S5K6B2YX_8BIT, 0x0344, 0x00 }, /* x_addr_start MSB */
+	{ S5K6B2YX_8BIT, 0x0345, 0x00 }, /* x_addr_start LSB */
+	{ S5K6B2YX_8BIT, 0x0346, 0x00 }, /* y_addr_start MSB */
+	{ S5K6B2YX_8BIT, 0x0347, 0x00 }, /* y_addr_start LSB */
+
+	{ S5K6B2YX_8BIT, 0x0348, 0x07 }, /* x_addr_end MSB */
+	{ S5K6B2YX_8BIT, 0x0349, 0x8f }, /* x_addr_end LSB */
+	{ S5K6B2YX_8BIT, 0x034a, 0x04 }, /* y_addr_end MSB */
+	{ S5K6B2YX_8BIT, 0x034b, 0x47 }, /* y_addr_end LSB */
+
+	{ S5K6B2YX_8BIT, 0x034c, 0x07 }, /* x_output_size MSB */
+	{ S5K6B2YX_8BIT, 0x034d, 0x90 }, /* x_output_size LSB */
+	{ S5K6B2YX_8BIT, 0x034e, 0x04 }, /* y_output_size MSB */
+	{ S5K6B2YX_8BIT, 0x034f, 0x48 }, /* y_output_size LSB */
+
+	{ S5K6B2YX_8BIT, 0x0340, 0x04 }, /* frame_length_lines MSB */
+	{ S5K6B2YX_8BIT, 0x0341, 0x66 }, /* frame_length_lines LSB */
+	{ S5K6B2YX_8BIT, 0x0342, 0x08 }, /* line_length_pck MSB */
+	{ S5K6B2YX_8BIT, 0x0343, 0x9b }, /* line_length_pck LSB */
+	{ S5K6B2YX_TOK_TERM, 0, 0 }
 };
 
 struct s5k6b2yx_resolution s5k6b2yx_res_preview[] = {
 	{
-		.desc = "s5k6b2yx_1936_1096_30fps",
+		.desc = "s5k6b2yx_184x104_15fps",
+		.regs = s5k6b2yx_184x104_15fps,
+		.width = 184,
+		.height = 104,
+		.fps = 15,
+		.pixels_per_line = 2203, /* consistent with regs arrays */
+		.lines_per_frame = 1126, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 292000,
+		.code = V4L2_MBUS_FMT_SGRBG8_1X8,
+		.mode = CAM_VIS_STBY,
+	},
+	{
+		.desc = "s5k6b2yx_1936x1096_30fps",
+		.regs = s5k6b2yx_1936x1096_30fps,
 		.width = 1936,
 		.height = 1096,
 		.fps = 30,
-		.pix_clk_freq = 74,
-		.used = 0,
-		.pixels_per_line = 2203,
-		.lines_per_frame = 1126,
+		.pixels_per_line = 2203, /* consistent with regs arrays */
+		.lines_per_frame = 1126, /* consistent with regs arrays */
 		.bin_factor_x = 1,
 		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = s5k6b2yx_1936_1096_30fps,
+		.used = 0,
+		.skip_frames = 2,
 		.mipi_freq = 372000,
+		.mode = CAM_SW_STBY,
+		.code = V4L2_MBUS_FMT_SGRBG10_1X10,
 	},
 };
 #define N_RES_PREVIEW (ARRAY_SIZE(s5k6b2yx_res_preview))
 
 struct s5k6b2yx_resolution s5k6b2yx_res_still[] = {
 	{
-		.desc = "s5k6b2yx_1936_1096_30fps",
+		.desc = "s5k6b2yx_1936x1096_30fps",
+		.regs = s5k6b2yx_1936x1096_30fps,
 		.width = 1936,
 		.height = 1096,
 		.fps = 30,
-		.pix_clk_freq = 74,
-		.used = 0,
-		.pixels_per_line = 2203,
-		.lines_per_frame = 1126,
+		.pixels_per_line = 2203, /* consistent with regs arrays */
+		.lines_per_frame = 1126, /* consistent with regs arrays */
 		.bin_factor_x = 1,
 		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = s5k6b2yx_1936_1096_30fps,
+		.used = 0,
+		.skip_frames = 2,
 		.mipi_freq = 372000,
+		.mode = CAM_SW_STBY,
+		.code = V4L2_MBUS_FMT_SGRBG10_1X10,
 	},
 };
 #define N_RES_STILL (ARRAY_SIZE(s5k6b2yx_res_still))
 
 struct s5k6b2yx_resolution s5k6b2yx_res_video[] = {
 	{
-		.desc = "s5k6b2yx_1936_1096_30fps",
+		.desc = "s5k6b2yx_1936x1096_30fps",
+		.regs = s5k6b2yx_1936x1096_30fps,
 		.width = 1936,
 		.height = 1096,
 		.fps = 30,
-		.pix_clk_freq = 74,
-		.used = 0,
-		.pixels_per_line = 2203,
-		.lines_per_frame = 1126,
+		.pixels_per_line = 2203, /* consistent with regs arrays */
+		.lines_per_frame = 1126, /* consistent with regs arrays */
 		.bin_factor_x = 1,
 		.bin_factor_y = 1,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = s5k6b2yx_1936_1096_30fps,
+		.used = 0,
+		.skip_frames = 2,
 		.mipi_freq = 372000,
+		.mode = CAM_SW_STBY,
+		.code = V4L2_MBUS_FMT_SGRBG10_1X10,
 	},
 };
 #define N_RES_VIDEO (ARRAY_SIZE(s5k6b2yx_res_video))
 
-static struct s5k6b2yx_resolution *s5k6b2yx_res = s5k6b2yx_res_preview;
+struct s5k6b2yx_resolution *s5k6b2yx_res = s5k6b2yx_res_preview;
 static int N_RES = N_RES_PREVIEW;
+
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile
index 64f3a25..517d597 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile
@@ -1,5 +1,6 @@
 ifdef CONFIG_GMIN_INTEL_MID
 obj-$(CONFIG_VIDEO_ATOMISP) += css2400b0_v21_build/
+#obj-$(CONFIG_VIDEO_ATOMISP) += css2401a0_v21_build/
 else
 ifeq ($(CONFIG_64BIT), )
 	obj-$(CONFIG_VIDEO_ATOMISP) += css2300_build/
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c
index 63de81c..c167765 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c
@@ -533,12 +533,32 @@ static void clear_irq_reg(struct atomisp_device *isp)
 	pci_write_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, msg_ret);
 }
 
+static struct atomisp_sub_device *
+__get_asd_from_port(struct atomisp_device *isp, mipi_port_ID_t port)
+{
+	int i;
+
+	/* Check which isp subdev to send eof */
+	for (i = 0; i < isp->num_of_streams; i++) {
+		struct atomisp_sub_device *asd = &isp->asd[i];
+		struct camera_mipi_info *mipi_info =
+				atomisp_to_sensor_mipi_info(
+					isp->inputs[asd->input_curr].camera);
+		if (isp->asd[i].streaming == ATOMISP_DEVICE_STREAMING_ENABLED &&
+		    __get_mipi_port(isp, mipi_info->port) == port) {
+			return &isp->asd[i];
+		}
+	}
+
+	return NULL;
+}
 
 /* interrupt handling function*/
 irqreturn_t atomisp_isr(int irq, void *dev)
 {
 	struct atomisp_device *isp = (struct atomisp_device *)dev;
 	struct atomisp_sub_device *asd;
+	struct atomisp_css_event eof_event;
 	unsigned int irq_infos = 0;
 	unsigned long flags;
 	unsigned int i;
@@ -587,13 +607,6 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 						&asd->sequence_temp))
 				atomic_set(&asd->sequence_temp,
 						atomic_read(&asd->sof_count));
-
-			/* signal streamon after delayed init is done */
-			if (asd->delayed_init ==
-					ATOMISP_DELAYED_INIT_WORK_DONE) {
-				asd->delayed_init = ATOMISP_DELAYED_INIT_DONE;
-				complete(&asd->init_done);
-			}
 		}
 		if (irq_infos & CSS_IRQ_INFO_EVENTS_READY)
 			atomic_set(&asd->sequence,
@@ -616,6 +629,28 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 			atomisp_css_rx_clear_irq_info(port, rx_infos);
 		}
 	}
+
+	if (irq_infos & IA_CSS_IRQ_INFO_ISYS_EVENTS_READY) {
+		while (ia_css_dequeue_isys_event(&(eof_event.event)) ==
+		       IA_CSS_SUCCESS) {
+			/* EOF Event does not have the css_pipe returned */
+			asd = __get_asd_from_port(isp, eof_event.event.port);
+			if (!asd) {
+				dev_err(isp->dev, "%s:no subdev.event:%d",  __func__,
+				        eof_event.event.type);
+				continue;
+			}
+
+			atomisp_eof_event(asd, eof_event.event.exp_id);
+			dev_dbg(isp->dev, "%s EOF exp_id %d\n", __func__,
+				eof_event.event.exp_id);
+		}
+
+		irq_infos &= ~IA_CSS_IRQ_INFO_ISYS_EVENTS_READY;
+		if (irq_infos == 0)
+			goto out_nowake;
+	}
+
 	spin_unlock_irqrestore(&isp->lock, flags);
 
 	return IRQ_WAKE_THREAD;
@@ -1165,9 +1200,7 @@ void atomisp_delayed_init_work(struct work_struct *work)
 	/*
 	 * to SOC camera, use yuvpp pipe and no support continuous mode.
 	 */
-	if (ATOMISP_USE_YUVPP(asd)) {
-		asd->delayed_init = ATOMISP_DELAYED_INIT_WORK_DONE;
-	} else {
+	if (!ATOMISP_USE_YUVPP(asd)) {
 		struct v4l2_event event = {0};
 
 		atomisp_css_allocate_continuous_frames(false, asd);
@@ -1175,8 +1208,11 @@ void atomisp_delayed_init_work(struct work_struct *work)
 
 		event.type = V4L2_EVENT_ATOMISP_RAW_BUFFERS_ALLOC_DONE;
 		v4l2_event_queue(asd->subdev.devnode, &event);
-		asd->delayed_init = ATOMISP_DELAYED_INIT_WORK_DONE;
 	}
+
+	/* signal streamon after delayed init is done */
+	asd->delayed_init = ATOMISP_DELAYED_INIT_DONE;
+	complete(&asd->init_done);
 }
 
 static void __atomisp_css_recover(struct atomisp_device *isp)
@@ -1531,25 +1567,6 @@ void atomisp_setup_flash(struct atomisp_sub_device *asd)
 	}
 }
 
-static struct atomisp_sub_device *
-__get_asd_from_port(struct atomisp_device *isp, mipi_port_ID_t port)
-{
-	int i;
-
-	/* Check which isp subdev to send eof */
-	for (i = 0; i < isp->num_of_streams; i++) {
-		struct atomisp_sub_device *asd = &isp->asd[i];
-		struct camera_mipi_info *mipi_info =
-				atomisp_to_sensor_mipi_info(
-					isp->inputs[asd->input_curr].camera);
-		if (isp->asd[i].streaming == ATOMISP_DEVICE_STREAMING_ENABLED &&
-		    __get_mipi_port(isp, mipi_info->port) == port) {
-			return &isp->asd[i];
-		}
-	}
-
-	return NULL;
-}
 irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
 {
 	struct atomisp_device *isp = isp_ptr;
@@ -1557,44 +1574,19 @@ irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
 	bool frame_done_found[MAX_STREAM_NUM] = {0};
 	bool css_pipe_done[MAX_STREAM_NUM] = {0};
 	bool reset_wdt_timer = false;
-	struct atomisp_css_event eof_event;
 	unsigned int i;
 	struct atomisp_sub_device *asd = &isp->asd[0];
 
 	dev_dbg(isp->dev, ">%s\n", __func__);
-	mutex_lock(&isp->streamoff_mutex);
 
 	spin_lock_irqsave(&isp->lock, flags);
 
 	if (!atomisp_streaming_count(isp) && !isp->acc.pipeline) {
 		spin_unlock_irqrestore(&isp->lock, flags);
-		mutex_unlock(&isp->streamoff_mutex);
 		return IRQ_HANDLED;
 	}
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	while (ia_css_dequeue_isys_event(&(eof_event.event)) ==
-	       IA_CSS_SUCCESS) {
-		/* EOF Event does not have the css_pipe returned */
-		asd = __get_asd_from_port(isp, eof_event.event.port);
-		if (!asd) {
-			dev_err(isp->dev, "%s:no subdev.event:%d",  __func__,
-			        eof_event.event.type);
-			continue;
-		}
-
-		atomisp_eof_event(asd, eof_event.event.exp_id);
-		dev_dbg(isp->dev, "%s EOF exp_id %d\n", __func__,
-			eof_event.event.exp_id);
 
-		/* signal streamon after delayed init is done */
-		if (asd->delayed_init ==
-				ATOMISP_DELAYED_INIT_WORK_DONE) {
-			asd->delayed_init = ATOMISP_DELAYED_INIT_DONE;
-			complete(&asd->init_done);
-		}
-	}
-	mutex_unlock(&isp->streamoff_mutex);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	/*
 	 * The standard CSS2.0 API tells the following calling sequence of
@@ -2279,6 +2271,27 @@ int atomisp_get_dis_stat(struct atomisp_sub_device *asd,
 }
 
 /*
+ * Function to get current sensor output effective resolution
+ */
+int atomisp_get_effective_res(struct atomisp_sub_device *asd,
+			 struct atomisp_resolution  *config)
+{
+	struct atomisp_stream_env stream_env =
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
+
+	dev_dbg(asd->isp->dev, ">%s start\n", __func__);
+	if (config == NULL) {
+		dev_err(asd->isp->dev, "Get effective struct address is not valid.\n");
+		return -EINVAL;
+	}
+	config->width =
+		stream_env.stream_config.input_config.effective_res.width;
+	config->height =
+		stream_env.stream_config.input_config.effective_res.height;
+	return 0;
+}
+
+/*
  * Function to get DVS2 BQ resolution settings
  */
 int atomisp_get_dvs2_bq_resolutions(struct atomisp_sub_device *asd,
@@ -3445,6 +3458,8 @@ int atomisp_param(struct atomisp_sub_device *asd, int flag,
 	       sizeof(struct atomisp_css_dp_config));
 	memcpy(&asd->params.css_param.de_config, &config->de_config,
 	       sizeof(struct atomisp_css_de_config));
+	memcpy(&asd->params.css_param.dz_config, &config->dz_config,
+	       sizeof(struct atomisp_css_dz_config));
 	memcpy(&asd->params.css_param.ce_config, &config->ce_config,
 	       sizeof(struct atomisp_css_ce_config));
 	memcpy(&asd->params.css_param.nr_config, &config->nr_config,
@@ -3473,6 +3488,7 @@ int atomisp_param(struct atomisp_sub_device *asd, int flag,
 	atomisp_css_set_wb_config(asd, &asd->params.css_param.wb_config);
 	atomisp_css_set_ob_config(asd, &asd->params.css_param.ob_config);
 	atomisp_css_set_de_config(asd, &asd->params.css_param.de_config);
+	atomisp_css_set_dz_config(asd, &asd->params.css_param.dz_config);
 	atomisp_css_set_ce_config(asd, &asd->params.css_param.ce_config);
 	atomisp_css_set_dp_config(asd, &asd->params.css_param.dp_config);
 	atomisp_css_set_nr_config(asd, &asd->params.css_param.nr_config);
@@ -4223,8 +4239,11 @@ static int css_input_resolution_changed(struct atomisp_sub_device *asd,
 
 	if (asd->continuous_mode->val) {
 		/* Note for all checks: ffmt includes pad_w+pad_h */
+#if defined(ISP2401_NEW_INPUT_SYSTEM)
 		atomisp_css_input_set_two_pixels_per_clock(asd, false);
-
+#else
+		atomisp_css_input_set_two_pixels_per_clock(asd, true);
+#endif
 		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
 		    (ffmt->width >= 2048 || ffmt->height >= 1536)) {
 			/*
@@ -4996,6 +5015,26 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 					     V4L2_SUBDEV_FORMAT_ACTIVE,
 					     source_pad, V4L2_SEL_TGT_COMPOSE,
 					     0, &isp_sink_crop);
+	} else if (IS_MOFD) {
+		struct v4l2_rect main_compose = {0};
+
+		main_compose.width = isp_sink_crop.width;
+		main_compose.height =
+			DIV_ROUND_UP(main_compose.width * f->fmt.pix.height,
+				     f->fmt.pix.width);
+		if (main_compose.height > isp_sink_crop.height) {
+			main_compose.height = isp_sink_crop.height;
+			main_compose.width =
+				DIV_ROUND_UP(main_compose.height *
+					     f->fmt.pix.width,
+					     f->fmt.pix.height);
+		}
+
+		atomisp_subdev_set_selection(&asd->subdev, &fh,
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+				source_pad,
+				V4L2_SEL_TGT_COMPOSE, 0,
+				&main_compose);
 	} else {
 		struct v4l2_rect sink_crop = {0};
 		struct v4l2_rect main_compose = {0};
@@ -5579,3 +5618,70 @@ int atomisp_inject_a_fake_event(struct atomisp_sub_device *asd, int *event)
 	return 0;
 }
 
+int atomisp_get_pipe_id(struct atomisp_video_pipe *pipe)
+{
+	struct atomisp_sub_device *asd = pipe->asd;
+
+	if (ATOMISP_USE_YUVPP(asd))
+		return CSS_PIPE_ID_YUVPP;
+	else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER)
+		return CSS_PIPE_ID_VIDEO;
+	else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT)
+		return CSS_PIPE_ID_CAPTURE;
+	else if (pipe == &asd->video_out_video_capture)
+		return CSS_PIPE_ID_VIDEO;
+	else if (pipe == &asd->video_out_vf)
+		return CSS_PIPE_ID_CAPTURE;
+	else if (pipe == &asd->video_out_preview) {
+		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
+			return CSS_PIPE_ID_VIDEO;
+		else
+			return CSS_PIPE_ID_PREVIEW;
+	} else if (pipe == &asd->video_out_capture) {
+		if (asd->copy_mode && !asd->copy_mode_format_conv)
+			return IA_CSS_PIPE_ID_COPY;
+		else
+			return CSS_PIPE_ID_CAPTURE;
+	}
+
+	/* fail through */
+	dev_warn(asd->isp->dev, "%s failed to find proper pipe\n",
+	         __func__);
+	return CSS_PIPE_ID_CAPTURE;
+}
+
+int atomisp_get_invalid_frame_num(struct video_device *vdev,
+					int *invalid_frame_num)
+{
+	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
+	struct atomisp_sub_device *asd = pipe->asd;
+	enum atomisp_css_pipe_id pipe_id;
+	struct ia_css_pipe_info p_info;
+	int ret;
+
+	if (asd->isp->inputs[asd->input_curr].camera_caps->
+		sensor[asd->sensor_curr].stream_num > 1) {
+		/* External ISP */
+		*invalid_frame_num = 0;
+		return 0;
+	}
+
+	pipe_id = atomisp_get_pipe_id(pipe);
+	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipes[pipe_id]) {
+		dev_warn(asd->isp->dev, "%s pipe %d has not been created yet, do SET_FMT first!\n",
+		         __func__, pipe_id);
+		return -EINVAL;
+	}
+
+	ret = ia_css_pipe_get_info(
+		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
+		.pipes[pipe_id], &p_info);
+	if (ret == IA_CSS_SUCCESS) {
+		*invalid_frame_num = p_info.num_invalid_frames;
+		return 0;
+	} else {
+		dev_warn(asd->isp->dev, "%s get pipe infor failed %d\n",
+		         __func__, ret);
+		return -EINVAL;
+	}
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h
index faa7331..9eefa5f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h
@@ -281,6 +281,12 @@ int atomisp_3a_config_param(struct atomisp_sub_device *asd, int flag,
 int atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag,
 			 __s32 *value);
 
+/*
+ * Function to get current sensor output effective resolution
+ */
+int atomisp_get_effective_res(struct atomisp_sub_device *asd,
+			struct atomisp_resolution  *config);
+
 int atomisp_cp_dvs_6axis_config(struct atomisp_sub_device *asd,
 			struct atomisp_dvs_6axis_config *user_6axis_config,
 			struct atomisp_css_params *css_param);
@@ -382,4 +388,10 @@ atomisp_get_metadata_type(struct atomisp_sub_device *asd,
  */
 int atomisp_inject_a_fake_event(struct atomisp_sub_device *asd, int *event);
 
+/*
+ * Function for HAL to query how many invalid frames at the beginning of ISP
+ * pipeline output
+ */
+int atomisp_get_invalid_frame_num(struct video_device *vdev,
+			int *invalid_frame_num);
 #endif /* __ATOMISP_CMD_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat.h
index 73f51c4..2bf354d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat.h
@@ -508,6 +508,9 @@ void atomisp_css_set_dp_config(struct atomisp_sub_device *asd,
 void atomisp_css_set_de_config(struct atomisp_sub_device *asd,
 			struct atomisp_css_de_config *de_config);
 
+void atomisp_css_set_dz_config(struct atomisp_sub_device *asd,
+			struct atomisp_css_dz_config *dz_config);
+
 void atomisp_css_set_default_de_config(struct atomisp_sub_device *asd);
 
 void atomisp_css_set_ce_config(struct atomisp_sub_device *asd,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c
index 4be620b..b8f69ce 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c
@@ -531,6 +531,7 @@ static int __destroy_stream(struct atomisp_sub_device *asd,
 {
 	struct atomisp_device *isp = asd->isp;
 	int i;
+	unsigned long timeout;
 
 	if (!stream_env->stream)
 		return 0;
@@ -549,6 +550,22 @@ static int __destroy_stream(struct atomisp_sub_device *asd,
 		dev_err(isp->dev, "stop stream failed.\n");
 		return -EINVAL;
 	}
+
+	if (stream_env->stream_state == CSS_STREAM_STARTED) {
+		timeout = jiffies + msecs_to_jiffies(40);
+		while (1) {
+			if (ia_css_stream_has_stopped(stream_env->stream))
+				break;
+
+			if (time_after(jiffies, timeout)) {
+				dev_warn(isp->dev, "stop stream timeout.\n");
+				break;
+			}
+
+			usleep_range(100, 200);
+		};
+	}
+
 	stream_env->stream_state = CSS_STREAM_STOPPED;
 
 	if (ia_css_stream_destroy(stream_env->stream) != IA_CSS_SUCCESS) {
@@ -2344,12 +2361,8 @@ int atomisp_css_stop(struct atomisp_sub_device *asd,
 	/*
 	 * SP can not be stop if other streams are in use
 	 */
-	if (atomisp_streaming_count(isp) == 0) {
+	if (atomisp_streaming_count(isp) == 0)
 		ia_css_stop_sp();
-		if (!sh_css_hrt_system_is_idle())
-			dev_err(isp->dev, "CSS HW not idle after stopping SP\n");
-	}
-
 
 	if (!in_reset) {
 		struct atomisp_stream_env *stream_env;
@@ -2946,8 +2959,8 @@ static int __get_frame_info(struct atomisp_sub_device *asd,
 			*info = p_info.raw_output_info;
 			dev_dbg(isp->dev, "getting raw frame info.\n");
 		}
-		dev_dbg(isp->dev, "get frame info: w=%d, h=%d.\n",
-			info->res.width, info->res.height);
+		dev_dbg(isp->dev, "get frame info: w=%d, h=%d, num_invalid_frames %d.\n",
+			info->res.width, info->res.height, p_info.num_invalid_frames);
 		return 0;
 	}
 
@@ -3469,6 +3482,12 @@ void atomisp_css_set_de_config(struct atomisp_sub_device *asd,
 	asd->params.config.de_config = de_config;
 }
 
+void atomisp_css_set_dz_config(struct atomisp_sub_device *asd,
+			struct atomisp_css_dz_config *dz_config)
+{
+	asd->params.config.dz_config = dz_config;
+}
+
 void atomisp_css_set_default_de_config(struct atomisp_sub_device *asd)
 {
 	asd->params.config.de_config = NULL;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h
index 12716bb..72d109b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h
@@ -54,6 +54,7 @@
 #define atomisp_css_ee_config	ia_css_ee_config
 #define atomisp_css_ob_config	ia_css_ob_config
 #define atomisp_css_de_config	ia_css_de_config
+#define atomisp_css_dz_config	ia_css_dz_config
 #define atomisp_css_ce_config	ia_css_ce_config
 #define atomisp_css_gc_config	ia_css_gc_config
 #define atomisp_css_tnr_config	ia_css_tnr_config
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c
index 1ac6c5b..56f9a02 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c
@@ -1158,6 +1158,8 @@ long atomisp_compat_ioctl32(struct file *file,
 	case ATOMISP_IOC_G_SENSOR_AE_BRACKETING_INFO:
 	case ATOMISP_IOC_S_SENSOR_AE_BRACKETING_MODE:
 	case ATOMISP_IOC_G_SENSOR_AE_BRACKETING_MODE:
+	case ATOMISP_IOC_G_INVALID_FRAME_NUM:
+	case ATOMISP_IOC_G_EFFECTIVE_RESOLUTION:
 		ret = native_ioctl(file, cmd, arg);
 		break;
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_dfs_tables.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_dfs_tables.h
index 2edfbcb..818c8e5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_dfs_tables.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_dfs_tables.h
@@ -219,6 +219,52 @@ static const struct atomisp_freq_scaling_rule dfs_rules_byt[] = {
 		.width = ISP_FREQ_RULE_ANY,
 		.height = ISP_FREQ_RULE_ANY,
 		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_VIDEO,
+	},
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
+	},
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE,
+	},
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_PREVIEW,
+	},
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
+		.isp_freq = ISP_FREQ_400MHZ,
+		.run_mode = ATOMISP_RUN_MODE_SDV,
+	},
+};
+
+static const struct atomisp_dfs_config dfs_config_byt = {
+	.lowest_freq = ISP_FREQ_200MHZ,
+	.max_freq_at_vmin = ISP_FREQ_400MHZ,
+	.highest_freq = ISP_FREQ_400MHZ,
+	.dfs_table = dfs_rules_byt,
+	.dfs_table_size = ARRAY_SIZE(dfs_rules_byt),
+};
+
+static const struct atomisp_freq_scaling_rule dfs_rules_byt_cr[] = {
+	{
+		.width = ISP_FREQ_RULE_ANY,
+		.height = ISP_FREQ_RULE_ANY,
+		.fps = ISP_FREQ_RULE_ANY,
 		.isp_freq = ISP_FREQ_320MHZ,
 		.run_mode = ATOMISP_RUN_MODE_VIDEO,
 	},
@@ -252,12 +298,12 @@ static const struct atomisp_freq_scaling_rule dfs_rules_byt[] = {
 	},
 };
 
-static const struct atomisp_dfs_config dfs_config_byt = {
+static const struct atomisp_dfs_config dfs_config_byt_cr = {
 	.lowest_freq = ISP_FREQ_200MHZ,
 	.max_freq_at_vmin = ISP_FREQ_320MHZ,
 	.highest_freq = ISP_FREQ_320MHZ,
-	.dfs_table = dfs_rules_byt,
-	.dfs_table_size = ARRAY_SIZE(dfs_rules_byt),
+	.dfs_table = dfs_rules_byt_cr,
+	.dfs_table_size = ARRAY_SIZE(dfs_rules_byt_cr),
 };
 
 static const struct atomisp_freq_scaling_rule dfs_rules_cht[] = {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h
index cd65479..aa3696e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h
@@ -135,8 +135,7 @@
 
 #define ATOMISP_DELAYED_INIT_NOT_QUEUED	0
 #define ATOMISP_DELAYED_INIT_QUEUED	1
-#define ATOMISP_DELAYED_INIT_WORK_DONE	2
-#define ATOMISP_DELAYED_INIT_DONE	3
+#define ATOMISP_DELAYED_INIT_DONE	2
 
 #define ATOMISP_CALC_CSS_PREV_OVERLAP(lines) \
 	((lines) * 38 / 100 & 0xfffffe)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c
index 63a68c5..94ca844 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c
@@ -1625,7 +1625,7 @@ static int atomisp_streamon(struct file *file, void *fh,
 				"ZSL last preview raw buffer id: %u\n",
 				asd->latest_preview_exp_id);
 
-			if (asd->delayed_init != ATOMISP_DELAYED_INIT_DONE) {
+			if (asd->delayed_init == ATOMISP_DELAYED_INIT_QUEUED) {
 				flush_work(&asd->delayed_init_work);
 				rt_mutex_unlock(&isp->mutex);
 				if (wait_for_completion_interruptible(
@@ -1767,6 +1767,8 @@ wdt_start:
 		queue_work(asd->delayed_init_workq, &asd->delayed_init_work);
 		atomisp_css_set_cont_prev_start_time(isp,
 				ATOMISP_CALC_CSS_PREV_OVERLAP(sink->height));
+	} else {
+		asd->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
 	}
 
 	if (atomisp_buffers_queued(asd))
@@ -2811,6 +2813,12 @@ static long atomisp_vidioc_default(struct file *file, void *fh,
 	case ATOMISP_IOC_INJECT_A_FAKE_EVENT:
 		err = atomisp_inject_a_fake_event(asd, arg);
 		break;
+	case ATOMISP_IOC_G_INVALID_FRAME_NUM:
+		err = atomisp_get_invalid_frame_num(vdev, arg);
+		break;
+	case ATOMISP_IOC_G_EFFECTIVE_RESOLUTION:
+		err = atomisp_get_effective_res(asd, arg);
+		break;
 	default:
 		rt_mutex_unlock(&isp->mutex);
 		return -EINVAL;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c
index 4761e84..09bdd90 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c
@@ -61,7 +61,7 @@
 
 #ifdef CONFIG_GMIN_INTEL_MID
 /* Moorefield lacks PCI PM, BYT advertises it but it's broken, use PUNIT */
-#define ATOMISP_INTERNAL_PM	(IS_MOFD || IS_BYT)
+#define ATOMISP_INTERNAL_PM	(IS_MOFD || IS_BYT || IS_CHT)
 #endif
 
 /* set reserved memory pool size in page */
@@ -221,18 +221,16 @@ static int atomisp_save_iunit_reg(struct atomisp_device *isp)
 	pci_read_config_dword(dev, MRFLD_PCI_CSI_CONTROL,
 			      &isp->saved_regs.csi_control);
 	if (isp->media_dev.hw_revision >=
-	    ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT)
+	    (ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT))
 		isp->saved_regs.csi_control |=
 			MRFLD_PCI_CSI_CONTROL_PARPATHEN;
-	/* Disable CSI interface on ANN B0/K0. It is turned on just before
-	 * starting streaming, not before to allow driver time to configure
-	 * the CSI receiver before incoming packets are seen.
-	 * A fuse configures whether this bit has actually any effect.
+	/*
+	 * On CHT CSI_READY bit should be enabled before stream on
 	 */
-	if (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<
-	    ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0))
-		isp->saved_regs.csi_control &=
-			~MRFLD_PCI_CSI_CONTROL_CSI_READY;
+	if (IS_CHT && (isp->media_dev.hw_revision >= ((ATOMISP_HW_REVISION_ISP2401 <<
+	    ATOMISP_HW_REVISION_SHIFT) | ATOMISP_HW_STEPPING_B0)))
+		isp->saved_regs.csi_control |=
+			MRFLD_PCI_CSI_CONTROL_CSI_READY;
 	pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
 			      &isp->saved_regs.csi_afe_rcomp_config);
 	pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_HS_CONTROL,
@@ -1140,7 +1138,6 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 	unsigned int start;
 	void __iomem *base;
 	int err;
-	u32 irq;
 
 	if (!dev) {
 		dev_err(&dev->dev, "atomisp: error device ptr\n");
@@ -1234,7 +1231,11 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 			(ATOMISP_HW_REVISION_ISP2400
 			 << ATOMISP_HW_REVISION_SHIFT) |
 			ATOMISP_HW_STEPPING_B0;
-		isp->dfs = &dfs_config_byt;
+		if (INTEL_MID_BOARD(3, TABLET, BYT, BLK, PRO, CRV2) ||
+				INTEL_MID_BOARD(3, TABLET, BYT, BLK, ENG, CRV2))
+			isp->dfs = &dfs_config_byt_cr;
+		else
+			isp->dfs = &dfs_config_byt;
 		/*
 		 * for BYT/CHT we are put isp into D3cold to avoid pci registers access
 		 * in power off. Set d3cold_delay to 0 since default 100ms is not
@@ -1261,8 +1262,10 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 #else
 			 ATOMISP_HW_REVISION_ISP2401_LEGACY
 #endif
-			 << ATOMISP_HW_REVISION_SHIFT) |
-			ATOMISP_HW_STEPPING_A0;
+			<< ATOMISP_HW_REVISION_SHIFT);
+		isp->media_dev.hw_revision |= isp->pdev->revision < 2 ?
+			 ATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0;
+
 		isp->dfs = &dfs_config_cht;
 		isp->pdev->d3cold_delay = 0;
 		break;
@@ -1432,29 +1435,9 @@ wdt_work_queue_fail:
 fw_validation_fail:
 	release_firmware(isp->firmware);
 load_fw_fail:
-	/*
-	 * Switch off ISP, as keeping it powered on would prevent
-	 * reaching S0ix states.
-	 *
-	 * The following lines have been copied from atomisp suspend path
-	 */
-
-	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
-	irq = irq & 1 << INTR_IIR;
-	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, irq);
-
-	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
-	irq &= ~(1 << INTR_IER);
-	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, irq);
-
-	atomisp_msi_irq_uninit(isp, dev);
-
-	atomisp_ospm_dphy_down(isp);
-	if (ATOMISP_INTERNAL_PM) {
-		if (atomisp_mrfld_power_down(isp))
-			dev_err(&dev->dev, "Failed to switch off ISP\n");
-	}
-
+#ifdef CONFIG_GMIN_INTEL_MID
+	pm_qos_remove_request(&isp->pm_qos);
+#endif
 	pci_dev_put(isp->pci_root);
 	return err;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c
index 60554fc..19d2541 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c
@@ -1142,6 +1142,7 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 	struct atomisp_device *isp;
 	unsigned int start;
 	void __iomem *base;
+	void __iomem * const *iomap;
 	int err;
 
 	if (!dev) {
@@ -1177,10 +1178,11 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 		return err;
 	}
 
-	if (!pcim_iomap_table(dev))
+	iomap = pcim_iomap_table(dev);
+	if (!iomap)
 		return -ENODEV;
 
-	base = pcim_iomap_table(dev)[ATOM_ISP_PCI_BAR];
+	base = iomap[ATOM_ISP_PCI_BAR];
 	dev_dbg(&dev->dev, "base: %p\n", base);
 	if (!base)
 		return -ENODEV;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c
index 1316323..13c06b8 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c
@@ -1916,13 +1916,13 @@ sh_css_debug_pipe_graph_dump_stage(
 				while (ei[p] != ',' && p > 0)
 					p--;
 				/* Last space found, copy till that space */
-				if (p >= 0 && p <= 100) {
-					strncpy(enable_info1, ei, p);
-					enable_info1[p] = '\0';
+				if (p >= sizeof(enable_info1))
+					return;
+				strncpy(enable_info1, ei, p);
+				enable_info1[p] = '\0';
 
-					ei += p+1;
-					l = strlen(ei);
-				}
+				ei += p+1;
+				l = strlen(ei);
 
 				if (l<=ENABLE_LINE2_MAX_LENGHT2) {
 					/* The 2nd line fits */
@@ -1938,12 +1938,12 @@ sh_css_debug_pipe_graph_dump_stage(
 					p=ENABLE_LINE2_MAX_LENGHT2;
 					while (ei[p] != ',' && p > 0)
 						p--;
-					if (p >= 0 && p <= 100) {
-						strncpy(enable_info2, ei, p);
-						enable_info2[p] = '\0';
-						ei += p+1;
-						strcpy(enable_info3, ei);
-					}
+					if (p >= sizeof(enable_info2))
+						return;
+					strncpy(enable_info2, ei, p);
+					enable_info2[p] = '\0';
+					ei += p+1;
+					strcpy(enable_info3, ei);
 					snprintf(enable_info, 200,
 						"%s\\n%s\\n%s",
 						enable_info1, enable_info2,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/base/refcount/src/refcount.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/base/refcount/src/refcount.c
index 11f8603..9fe9b48 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/base/refcount/src/refcount.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/base/refcount/src/refcount.c
@@ -49,8 +49,13 @@ static struct ia_css_refcount_entry *refcount_find_entry(hrt_vaddress ptr,
 {
 	uint32_t i;
 
-	assert(ptr != 0);
-	assert(myrefcount.items != NULL);
+	if (ptr == 0)
+		return NULL;
+	if (myrefcount.items == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "refcount_find_entry(): Ref count not initiliazed!\n");
+		return NULL;
+	}
 
 	for (i = 0; i < myrefcount.size; i++) {
 
@@ -72,9 +77,16 @@ enum ia_css_err ia_css_refcount_init(uint32_t size)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	assert(size != 0);
-	assert(myrefcount.items == NULL);
-
+	if (size == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "ia_css_refcount_init(): Size of 0 for Ref count init!\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (myrefcount.items != NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "ia_css_refcount_init(): Ref count is already initialized\n");
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 	myrefcount.items =
 	    sh_css_malloc(sizeof(struct ia_css_refcount_entry) * size);
 	if (!myrefcount.items)
@@ -136,7 +148,11 @@ hrt_vaddress ia_css_refcount_increment(int32_t id, hrt_vaddress ptr)
 		entry->id = id;
 	}
 
-	assert(entry->id == id);
+	if (entry->id != id) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+			    "ia_css_refcount_increment(): Ref count IDS do not match!\n");
+		return mmgr_NULL;
+	}
 
 	if (entry->data == ptr)
 		entry->count += 1;
@@ -162,7 +178,11 @@ bool ia_css_refcount_decrement(int32_t id, hrt_vaddress ptr)
 	entry = refcount_find_entry(ptr, false);
 
 	if (entry) {
-		assert(entry->id == id);
+		if (entry->id != id) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+					    "ia_css_refcount_decrement(): Ref count IDS do not match!\n");
+			return false;
+		}
 		if (entry->count > 0) {
 			entry->count -= 1;
 			if (entry->count == 0) {
@@ -234,6 +254,8 @@ void ia_css_refcount_clear(int32_t id, clear_func clear_func_ptr)
 				mmgr_free(entry->data);
 			}
 			assert(entry->count == 0);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+					    "ia_css_refcount_clear(): Ref count for entry %x is not zero!\n", entry->id);
 			entry->data = mmgr_NULL;
 			entry->count = 0;
 			entry->id = 0;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c
index 243b120..3c708ef 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c
@@ -533,7 +533,8 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	pipe_binarydesc_get_offline(pipe,
 			       IA_CSS_BINARY_MODE_CAPTURE_PP,
 			       yuv_scaler_descr,
-			       NULL, in_info, out_infos, vf_info);
+			       NULL, in_info, out_infos,
+			       (vf_info->res.width == 0 && vf_info->res.height == 0) ? NULL : vf_info);
 
 	yuv_scaler_descr->enable_fractional_ds = true;
 	IA_CSS_LEAVE_PRIVATE("");
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/isp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/isp.c
index 3c7b86b..d2cb159 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/isp.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/isp.c
@@ -19,6 +19,7 @@
  *
  */
 
+#include <system_global.h>
 #include "isp.h"
 
 #ifndef __INLINE_ISP__
@@ -26,6 +27,7 @@
 #endif /* __INLINE_ISP__ */
 
 #include "assert_support.h"
+#include "platform_support.h"			/* hrt_sleep() */
 
 void cnd_isp_irq_enable(
 	const isp_ID_t		ID,
@@ -52,6 +54,12 @@ void isp_get_state(
 	assert(state != NULL);
 	assert(stall != NULL);
 
+#if defined(_hrt_sysmem_ident_address)
+	/* Patch to avoid compiler unused symbol warning in C_RUN build */
+	(void)__hrt_sysmem_ident_address;
+	(void)_hrt_sysmem_map_var;
+#endif
+
 	state->pc = isp_ctrl_load(ID, ISP_PC_REG);
 	state->status_register = sc;
 	state->is_broken = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_BROKEN_BIT);
@@ -95,3 +103,53 @@ void isp_get_state(
  */
 return;
 }
+
+/* ISP functions to control the ISP state from the host, even in crun. */
+#ifdef C_RUN
+volatile uint32_t isp_sleeping[N_ISP_ID] = { 0 }; /* Sleeping state per ISP */
+volatile uint32_t isp_ready   [N_ISP_ID] = { 1 }; /* Ready state per ISP */
+#endif
+
+/* Inspect readiness of an ISP indexed by ID */
+unsigned isp_is_ready(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	return isp_ready[ID];
+#else
+	return isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);
+#endif
+}
+
+/* Inspect sleeping of an ISP indexed by ID */
+unsigned isp_is_sleeping(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	return isp_sleeping[ID];
+#else
+	return isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);
+#endif
+}
+
+/* To be called by the host immediately before starting ISP ID. */
+void isp_start(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	isp_ready[ID] = 0;
+#endif
+}
+
+/* Wake up ISP ID. */
+void isp_wake(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	isp_sleeping[ID] = 0;
+#else
+	isp_ctrl_setbit(ID, ISP_SC_REG, ISP_START_BIT);
+	hrt_sleep();
+#endif
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/vmem.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/vmem.c
index 66aea95d..cf64acf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/vmem.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/host/vmem.c
@@ -27,6 +27,7 @@
 #include "ia_css_device_access.h"
 #endif
 #include "assert_support.h"
+#include "platform_support.h"			/* hrt_sleep() */
 
 typedef unsigned long long hive_uedge;
 typedef hive_uedge *hive_wide;
@@ -34,10 +35,10 @@ typedef hive_uedge *hive_wide;
 /* Copied from SDK: sim_semantics.c */
 
 /* subword bits move like this:         MSB[____xxxx____]LSB -> MSB[00000000xxxx]LSB */
-#define SUBWORD(w, start, end)     ((w & (((1ULL << (end-1))-1) << 1 | 1)) >> (start))
+#define SUBWORD(w, start, end)     (((w) & (((1ULL << ((end)-1))-1) << 1 | 1)) >> (start))
 
 /* inverse subword bits move like this: MSB[xxxx____xxxx]LSB -> MSB[xxxx0000xxxx]LSB */
-#define INV_SUBWORD(w, start, end) (w & (~(((1ULL << (end-1))-1) << 1 | 1) | ((1ULL << (start))-1)) )
+#define INV_SUBWORD(w, start, end) ((w) & (~(((1ULL << ((end)-1))-1) << 1 | 1) | ((1ULL << (start))-1)) )
 
 #define uedge_bits (8*sizeof(hive_uedge))
 #define move_lower_bits(target, target_bit, src, src_bit) move_subword(target, target_bit, src, 0, src_bit)
@@ -116,9 +117,9 @@ hive_sim_wide_pack(
 	if (elem_bits == uedge_bits) {
 		vector[start_elem] = elem[0];
 	} else if (elem_bits > uedge_bits) {
-		int bits_to_write = elem_bits;
-		int start_bit = elem_bits * index;
-		int i = 0;
+		unsigned bits_to_write = elem_bits;
+		unsigned start_bit = elem_bits * index;
+		unsigned i = 0;
 		for(; bits_to_write > uedge_bits; bits_to_write -= uedge_bits, i++, start_bit += uedge_bits) {
 			move_word(vector, start_bit, elem[i]);
 		}
@@ -135,11 +136,11 @@ static void load_vector (
 	const t_vmem_elem	*from)
 {
 	unsigned i;
-	unsigned size = sizeof(short)*ISP_NWAY;
 #ifdef C_RUN
 	hive_uedge *data = (hive_uedge *)from;
 	(void)ID;
 #else
+	unsigned size = sizeof(short)*ISP_NWAY;
 	VMEM_ARRAY(v, 2*ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
 	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
@@ -163,19 +164,19 @@ static void store_vector (
 	const t_vmem_elem	*from)
 {
 	unsigned i;
-	unsigned size = sizeof(short)*ISP_NWAY;
 #ifdef C_RUN
 	hive_uedge *data = (hive_uedge *)to;
 	(void)ID;
 	for (i = 0; i < ISP_NWAY; i++) {
-		hive_sim_wide_pack(data, &from[i], ISP_VEC_ELEMBITS, i);
+		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);
 	}
 #else
+	unsigned size = sizeof(short)*ISP_NWAY;
 	VMEM_ARRAY(v, 2*ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
 	//load_vector (&v[1][0], &to[ISP_NWAY]); /* Fetch the next vector, since it will be overwritten. */
 	hive_uedge *data = (hive_uedge *)v;
 	for (i = 0; i < ISP_NWAY; i++) {
-		hive_sim_wide_pack(data, &from[i], ISP_VEC_ELEMBITS, i);
+		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);
 	}
 	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/isp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/isp_global.h
index ea913be..40870e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/isp_global.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/isp_global.h
@@ -46,22 +46,23 @@
 #define ISP_VEC_BYTES			(ISP_VEC_NELEMS*sizeof(uint16_t))
 
 /* ISP SC Registers */
-#define ISP_SC_REG				0x00
-#define ISP_PC_REG				0x07
+#define ISP_SC_REG			0x00
+#define ISP_PC_REG			0x07
 #define ISP_IRQ_READY_REG		0x00
 #define ISP_IRQ_CLEAR_REG		0x00
 
 /* ISP SC Register bits */
-#define ISP_RST_BIT				0x00
+#define ISP_RST_BIT			0x00
 #define ISP_START_BIT			0x01
 #define ISP_BREAK_BIT			0x02
-#define ISP_RUN_BIT				0x03
+#define ISP_RUN_BIT			0x03
 #define ISP_BROKEN_BIT			0x04
 #define ISP_IDLE_BIT			0x05     /* READY */
+#define ISP_SLEEPING_BIT		0x06
 #define ISP_STALLING_BIT		0x07
 #define ISP_IRQ_CLEAR_BIT		0x08
 #define ISP_IRQ_READY_BIT		0x0A
-#define ISP_SLEEPING_BIT		0x0B     /* SLEEPING_IRQ_MASK */
+#define ISP_IRQ_SLEEPING_BIT		0x0B
 
 /* ISP Register bits */
 #define ISP_CTRL_SINK_BIT		0x00
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/sp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/sp_global.h
index a8fdad2..64e4b0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/sp_global.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system/sp_global.h
@@ -52,16 +52,17 @@
 #define SP_CTRL_SINK_REG		0x0A
 
 /* SP Register bits */
-#define SP_RST_BIT				0x00
+#define SP_RST_BIT			0x00
 #define SP_START_BIT			0x01
 #define SP_BREAK_BIT			0x02
-#define SP_RUN_BIT				0x03
+#define SP_RUN_BIT			0x03
 #define SP_BROKEN_BIT			0x04
-#define SP_IDLE_BIT				0x05     /* READY */
+#define SP_IDLE_BIT			0x05     /* READY */
+#define SP_SLEEPING_BIT			0x06
 #define SP_STALLING_BIT			0x07
 #define SP_IRQ_CLEAR_BIT		0x08
 #define SP_IRQ_READY_BIT		0x0A
-#define SP_SLEEPING_BIT			0x0B     /* SLEEPING_IRQ_MASK */
+#define SP_IRQ_SLEEPING_BIT		0x0B
 
 #define SP_ICACHE_INV_BIT		0x0C
 #define SP_IPREFETCH_EN_BIT		0x0D
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c
index 04ce4fa..48d5bcf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c
@@ -26,17 +26,18 @@
 #include "isp/kernels/anr/anr_2/ia_css_anr2.host.h"
 #include "isp/kernels/bh/bh_2/ia_css_bh.host.h"
 #include "isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h"
-#include "isp/kernels/bnr/bnr_2.2/ia_css_bnr22.host.h"
+#include "isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h"
 #include "isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h"
 #include "isp/kernels/crop/crop_1.0/ia_css_crop.host.h"
 #include "isp/kernels/csc/csc_1.0/ia_css_csc.host.h"
 #include "isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h"
-#include "isp/kernels/ctc/ctc_2/ia_css_ctc2.host.h"
-#include "isp/kernels/ctc/ctc_v2/ia_css_ctcv2.host.h"
+#include "isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h"
+#include "isp/kernels/ctc/ctc2/ia_css_ctc2.host.h"
 #include "isp/kernels/de/de_1.0/ia_css_de.host.h"
 #include "isp/kernels/de/de_2/ia_css_de2.host.h"
 #include "isp/kernels/dp/dp_1.0/ia_css_dp.host.h"
 #include "isp/kernels/fc/fc_1.0/ia_css_formats.host.h"
+#include "isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h"
 #include "isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h"
 #include "isp/kernels/gc/gc_1.0/ia_css_gc.host.h"
 #include "isp/kernels/gc/gc_2/ia_css_gc2.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_config.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_config.h
index d9f35f1..0f89476 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_config.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_config.h
@@ -28,10 +28,10 @@
 #include "isp2601_config.h"
 #elif defined(ISP2500)
 #include "isp2500_config.h"
-#elif defined(ISP2400)
+#elif defined(ISP2400) || defined(ISP2401)
 #include "isp2400_config.h"
 #else
-#error "Please define a core {ISP2400, ISP2500, ISP2600, ISP2601}"
+#error "Please define a core {ISP2400, ISP2401, ISP2500, ISP2600, ISP2601}"
 #endif
 
 #endif /* __ISP_CONFIG_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_public.h
index f3877ae..798dcc6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_public.h
@@ -182,4 +182,12 @@ STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(
 	const uint16_t		x0,
 	const uint16_t		x1);
 
+unsigned isp_is_ready(isp_ID_t ID);
+
+unsigned isp_is_sleeping(isp_ID_t ID);
+
+void isp_start(isp_ID_t ID);
+
+void isp_wake(isp_ID_t ID);
+
 #endif /* __ISP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/misc_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/misc_support.h
index 7fea8e1..f8e33a1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/misc_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/misc_support.h
@@ -27,4 +27,7 @@
 #define NOT_USED(a) ((void)(a))
 #endif
 
+/* Calculate the  total bytes for pow(2) byte alignment */
+#define tot_bytes_for_pow2_align(pow2, cur_bytes)	((cur_bytes + (pow2 - 1)) & ~(pow2 - 1))
+
 #endif /* __MISC_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/type_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/type_support.h
index 91ea849..feaa0e7 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/type_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/type_support.h
@@ -39,7 +39,14 @@
 
 #if defined(_MSC_VER)
 #include <stdint.h>
+/* For ATE compilation define the bool */
+#if defined(_ATE_)
+#define bool int
+#define true 1
+#define false 0
+#else
 #include <stdbool.h>
+#endif
 #include <stddef.h>
 #include <limits.h>
 #include <errno.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h
index 2a5c911..10fb476 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h
index 46d2f21..b1606c6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h
@@ -304,6 +304,8 @@ struct ia_css_binary_xinfo {
 	enum ia_css_acc_type	     type;
 	CSS_ALIGN(int32_t	     num_output_formats, 8);
 	enum ia_css_frame_format     output_formats[IA_CSS_FRAME_FORMAT_NUM];
+	CSS_ALIGN(int32_t	     num_vf_formats, 8); /**< number of supported vf formats */
+	enum ia_css_frame_format     vf_formats[IA_CSS_FRAME_FORMAT_NUM]; /**< types of supported vf formats */
 	uint8_t			     num_output_pins;
 	ia_css_ptr		     xmem_addr;
 	CSS_ALIGN(const struct ia_css_blob_descr *blob, 8);
@@ -338,6 +340,8 @@ struct ia_css_sp_info {
 	uint32_t debug_stage; /**< thread/pipe post mortem debug */
 	uint32_t debug_stripe; /**< thread/pipe post mortem debug */
 #endif
+	uint32_t threads_stack; /**< sp thread's stack pointers */
+	uint32_t threads_stack_size; /**< sp thread's stack sizes */
 	uint32_t curr_binary_id;        /**< current binary id */
 	uint32_t raw_copy_line_count;   /**< raw copy line counter */
 	uint32_t ddr_parameter_address; /**< acc param ddrptr, sp dmem */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h
index 398adab..0ff0d90 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h
@@ -70,10 +70,14 @@ enum ia_css_fw_err {
  */
 enum ia_css_fw_warning {
 	IA_CSS_FW_WARNING_NONE,
-	IA_CSS_FW_WARNING_ISYS_QUEUE_FULL,
-	IA_CSS_FW_WARNING_PSYS_QUEUE_FULL,
-	IA_CSS_FW_WARNING_CIRCBUF_ALL_LOCKED,
-	IA_CSS_FW_WARNING_EXP_ID_LOCKED,
+	IA_CSS_FW_WARNING_ISYS_QUEUE_FULL, /** < CSS system delayed because of insufficient space in the ISys queue.
+		This warning can be avoided by de-queing ISYS buffers more timely. */
+	IA_CSS_FW_WARNING_PSYS_QUEUE_FULL, /** < CSS system delayed because of insufficient space in the PSys queue.
+		This warning can be avoided by de-queing PSYS buffers more timely. */
+	IA_CSS_FW_WARNING_CIRCBUF_ALL_LOCKED, /** < CSS system delayed because of insufficient available buffers.
+		This warning can be avoided by unlocking locked frame-buffers more timely. */
+	IA_CSS_FW_WARNING_EXP_ID_LOCKED, /** < Exposure ID skipped because the frame associated to it was still locked.
+		This warning can be avoided by unlocking locked frame-buffers more timely. */
 };
 
 #endif /* __IA_CSS_ERR_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h
index 677b2cb..2fbdfc1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h
index 183a4e5..e7da197 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h
index 42e20b5..f19e83f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h
@@ -29,7 +29,7 @@
 #define __IA_CSS_VERSION_DATA_H
 
 
-#define CSS_VERSION_STRING "REL:20141014_42.2_1539; API:2.1.8.4; GIT:irci_20141013_1500__e1aae7#e1aae7f4badd10c57188ebad975743f469ced787; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
+#define CSS_VERSION_STRING "REL:20141029_44.3_1545; API:2.1.8.4; GIT:irci_20141028_0204__191ffe#191ffe4d489862c47f19ac58aea084d6204ef02b; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
 
 
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
new file mode 100644
index 0000000..70e69a2
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_LOAD_PARAM_H
+#define __IA_CSS_BAYER_LOAD_PARAM_H
+
+#include "ia_css_bayer_ls_param.h"
+
+#endif /* __IA_CSS_BAYER_LOAD_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
new file mode 100644
index 0000000..f344448
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
@@ -0,0 +1,38 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_LS_PARAM_H
+#define __IA_CSS_BAYER_LS_PARAM_H
+
+#include "type_support.h"
+
+#define NUM_BAYER_LS 2
+
+/** bayer load/store */
+struct sh_css_isp_bayer_ls_isp_config {
+	uint32_t base_address[NUM_BAYER_LS];
+	uint32_t width[NUM_BAYER_LS];
+	uint32_t height[NUM_BAYER_LS];
+	uint32_t stride[NUM_BAYER_LS];
+};
+
+
+#endif /* __IA_CSS_BAYER_LS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
new file mode 100644
index 0000000..2cb77a4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_STORE_PARAM_H
+#define __IA_CSS_BAYER_STORE_PARAM_H
+
+#include "ia_css_bayer_ls_param.h"
+
+
+#endif /* __IA_CSS_BAYER_STORE_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
new file mode 100644
index 0000000..350f19b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
@@ -0,0 +1,129 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "type_support.h"
+#include "ia_css_bnr2_2.host.h"
+
+#ifndef IA_CSS_NO_DEBUG
+#include "ia_css_debug.h" /* ia_css_debug_dtrace() */
+#endif
+
+/* Default kernel parameters. */
+const struct ia_css_bnr2_2_config default_bnr2_2_config = {
+	200,
+	200,
+	200,
+	0,
+	0,
+	0,
+	200,
+	200,
+	200,
+	0,
+	0,
+	0,
+	0,
+	4096,
+	8191,
+	128,
+	1,
+	0,
+	0,
+	0,
+	8191,
+	0,
+	8191
+};
+
+void
+ia_css_bnr2_2_encode(
+	struct sh_css_isp_bnr2_2_params *to,
+	const struct ia_css_bnr2_2_config *from,
+	size_t size)
+{
+	(void)size;
+	to->d_var_gain_r = from->d_var_gain_r;
+	to->d_var_gain_g = from->d_var_gain_g;
+	to->d_var_gain_b = from->d_var_gain_b;
+	to->d_var_gain_slope_r = from->d_var_gain_slope_r;
+	to->d_var_gain_slope_g = from->d_var_gain_slope_g;
+	to->d_var_gain_slope_b = from->d_var_gain_slope_b;
+
+	to->n_var_gain_r = from->n_var_gain_r;
+	to->n_var_gain_g = from->n_var_gain_g;
+	to->n_var_gain_b = from->n_var_gain_b;
+	to->n_var_gain_slope_r = from->n_var_gain_slope_r;
+	to->n_var_gain_slope_g = from->n_var_gain_slope_g;
+	to->n_var_gain_slope_b = from->n_var_gain_slope_b;
+
+	to->dir_thres = from->dir_thres;
+	to->dir_thres_w = from->dir_thres_w;
+	to->var_offset_coef = from->var_offset_coef;
+
+	to->dir_gain = from->dir_gain;
+	to->detail_gain	= from->detail_gain;
+	to->detail_gain_divisor = from->detail_gain_divisor;
+	to->detail_level_offset = from->detail_level_offset;
+
+	to->d_var_th_min = from->d_var_th_min;
+	to->d_var_th_max = from->d_var_th_max;
+	to->n_var_th_min = from->n_var_th_min;
+	to->n_var_th_max = from->n_var_th_max;
+}
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnr2_2_debug_trace(
+	const struct ia_css_bnr2_2_config *bnr,
+	unsigned level)
+{
+	if (!bnr)
+		return;
+
+	ia_css_debug_dtrace(level, "Bayer Noise Reduction 2.2:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_r", bnr->d_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_g", bnr->d_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_b", bnr->d_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_r", bnr->d_var_gain_slope_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_g", bnr->d_var_gain_slope_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_b", bnr->d_var_gain_slope_b);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_r", bnr->n_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_g", bnr->n_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_b", bnr->n_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_r", bnr->n_var_gain_slope_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_g", bnr->n_var_gain_slope_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_b", bnr->n_var_gain_slope_b);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres", bnr->dir_thres);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres_w", bnr->dir_thres_w);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "var_offset_coef", bnr->var_offset_coef);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_gain", bnr->dir_gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain", bnr->detail_gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain_divisor", bnr->detail_gain_divisor);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_level_offset", bnr->detail_level_offset);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_min", bnr->d_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_max", bnr->d_var_th_max);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_min", bnr->n_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_max", bnr->n_var_th_max);
+}
+#endif /* IA_CSS_NO_DEBUG */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
new file mode 100644
index 0000000..aa1ac6a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_HOST_H
+#define __IA_CSS_BNR2_2_HOST_H
+
+#include "ia_css_bnr2_2_types.h"
+#include "ia_css_bnr2_2_param.h"
+
+extern const struct ia_css_bnr2_2_config default_bnr2_2_config;
+
+void
+ia_css_bnr2_2_encode(
+	struct sh_css_isp_bnr2_2_params *to,
+	const struct ia_css_bnr2_2_config *from,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnr2_2_debug_trace(
+	const struct ia_css_bnr2_2_config *config,
+	unsigned level);
+#endif
+
+#endif /* __IA_CSS_BNR2_2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
new file mode 100644
index 0000000..c0fdf06
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
@@ -0,0 +1,57 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_PARAM_H
+#define __IA_CSS_BNR2_2_PARAM_H
+
+#include "type_support.h"
+
+/* TEMP: for implementation purpose.... */
+#define BYPASS_BNR2_2		1
+
+/* BNR (Bayer Noise Reduction) ISP parameters */
+struct sh_css_isp_bnr2_2_params {
+	int32_t d_var_gain_r;
+	int32_t d_var_gain_g;
+	int32_t d_var_gain_b;
+	int32_t d_var_gain_slope_r;
+	int32_t d_var_gain_slope_g;
+	int32_t d_var_gain_slope_b;
+	int32_t n_var_gain_r;
+	int32_t n_var_gain_g;
+	int32_t n_var_gain_b;
+	int32_t n_var_gain_slope_r;
+	int32_t n_var_gain_slope_g;
+	int32_t n_var_gain_slope_b;
+	int32_t dir_thres;
+	int32_t dir_thres_w;
+	int32_t var_offset_coef;
+	int32_t dir_gain;
+	int32_t detail_gain;
+	int32_t detail_gain_divisor;
+	int32_t detail_level_offset;
+	int32_t d_var_th_min;
+	int32_t d_var_th_max;
+	int32_t n_var_th_min;
+	int32_t n_var_th_max;
+};
+
+#endif /* __IA_CSS_BNR2_2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
new file mode 100644
index 0000000..bf22d00
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
@@ -0,0 +1,63 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_TYPES_H
+#define __IA_CSS_BNR2_2_TYPES_H
+
+#include "type_support.h" /* int32_t */
+
+/**
+ * \brief BNR2_2 public parameters.
+ * \details Struct with all parameters for the BNR2.2 kernel that can be set
+ * from the CSS API.
+ */
+struct ia_css_bnr2_2_config {
+	/* Directional variance gain for R/G/B components in dark region */
+	int32_t d_var_gain_r;
+	int32_t d_var_gain_g;
+	int32_t d_var_gain_b;
+	/* Slope of Directional variance gain between dark and bright region */
+	int32_t d_var_gain_slope_r;
+	int32_t d_var_gain_slope_g;
+	int32_t d_var_gain_slope_b;
+	/* Non-Directional variance gain for R/G/B components in dark region */
+	int32_t n_var_gain_r;
+	int32_t n_var_gain_g;
+	int32_t n_var_gain_b;
+	/* Slope of Non-Directional variance gain between dark and bright region */
+	int32_t n_var_gain_slope_r;
+	int32_t n_var_gain_slope_g;
+	int32_t n_var_gain_slope_b;
+
+	int32_t dir_thres;		/* Threshold for directional filtering */
+	int32_t dir_thres_w;		/* Threshold width for directional filtering */
+	int32_t var_offset_coef;	/* Variance offset coefficient */
+	int32_t dir_gain;		/* Gain for directional coefficient */
+	int32_t detail_gain;		/* Gain for low contrast texture control */
+	int32_t detail_gain_divisor;	/* Gain divisor for low contrast texture control */
+	int32_t detail_level_offset;	/* Bias value for low contrast texture control */
+	int32_t d_var_th_min;		/* Minimum clipping value for directional variance*/
+	int32_t d_var_th_max;		/* Maximum clipping value for diretional variance*/
+	int32_t n_var_th_min;		/* Minimum clipping value for non-directional variance*/
+	int32_t n_var_th_max;		/* Maximum clipping value for non-directional variance*/
+};
+
+#endif /* __IA_CSS_BNR2_2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
new file mode 100644
index 0000000..94ab59b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
@@ -0,0 +1,127 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+#include "ctc/ctc_1.0/ia_css_ctc.host.h"
+#include "ia_css_ctc1_5.host.h"
+
+static void ctc_gradient(
+	int *dydx, int *shift,
+	int y1, int y0, int x1, int x0)
+{
+	int frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int dydx_int;
+	int dydx_frc;
+	int sft;
+	/* max_dydx = the maxinum gradient = the maximum y (gain) */
+	int max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+
+	if (dx == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() error, illegal division operation\n");
+		return;
+	} else {
+		dydx_int = dy / dx;
+		dydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;
+	}
+
+	assert(y0 >= 0 && y0 <= max_dydx);
+	assert(y1 >= 0 && y1 <= max_dydx);
+	assert(x0 < x1);
+	assert(dydx != NULL);
+	assert(shift != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
+
+	/* search "sft" which meets this condition:
+		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
+		<= (((float)dy / (float)dx) * (1 << sft))
+		<= ((1 << IA_CSS_CTC_COEF_SHIFT) - 1) */
+	for (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {
+		int tmp_dydx = (dydx_int << sft)
+			     + (dydx_frc >> (frc_bits - sft));
+		if (tmp_dydx <= max_dydx) {
+			*dydx = tmp_dydx;
+			*shift = sft;
+		}
+		if (tmp_dydx >= max_dydx)
+			break;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
+}
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from,
+	unsigned size)
+{
+	(void)size;
+	to->y0 = from->y0;
+	to->y1 = from->y1;
+	to->y2 = from->y2;
+	to->y3 = from->y3;
+	to->y4 = from->y4;
+	to->y5 = from->y5;
+
+	to->ce_gain_exp = from->ce_gain_exp;
+
+	to->x1 = from->x1;
+	to->x2 = from->x2;
+	to->x3 = from->x3;
+	to->x4 = from->x4;
+
+	ctc_gradient(&(to->dydx0),
+		     &(to->dydx0_shift),
+		     from->y1, from->y0,
+		     from->x1, 0);
+
+	ctc_gradient(&(to->dydx1),
+		     &(to->dydx1_shift),
+		     from->y2, from->y1,
+		     from->x2, from->x1);
+
+	ctc_gradient(&to->dydx2,
+		     &to->dydx2_shift,
+		     from->y3, from->y2,
+		     from->x3, from->x2);
+
+	ctc_gradient(&to->dydx3,
+		     &to->dydx3_shift,
+		     from->y4, from->y3,
+		     from->x4, from->x3);
+
+	ctc_gradient(&(to->dydx4),
+		     &(to->dydx4_shift),
+		     from->y5, from->y4,
+		     SH_CSS_BAYER_MAXVAL, from->x4);
+}
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
new file mode 100644
index 0000000..c1f6b15
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC1_5_HOST_H
+#define __IA_CSS_CTC1_5_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_ctc1_5_param.h"
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from,
+	unsigned size);
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
+
+#endif /* __IA_CSS_CTC1_5_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
new file mode 100644
index 0000000..cc3cb36
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC1_5_PARAM_H
+#define __IA_CSS_CTC1_5_PARAM_H
+
+#include "type_support.h"
+#include "ctc/ctc_1.0/ia_css_ctc_param.h" /* vamem params */
+
+/* CTC (Color Tone Control) */
+struct sh_css_isp_ctc_params {
+	int32_t y0;
+	int32_t y1;
+	int32_t y2;
+	int32_t y3;
+	int32_t y4;
+	int32_t y5;
+	int32_t ce_gain_exp;
+	int32_t x1;
+	int32_t x2;
+	int32_t x3;
+	int32_t x4;
+	int32_t dydx0;
+	int32_t dydx0_shift;
+	int32_t dydx1;
+	int32_t dydx1_shift;
+	int32_t dydx2;
+	int32_t dydx2_shift;
+	int32_t dydx3;
+	int32_t dydx3_shift;
+	int32_t dydx4;
+	int32_t dydx4_shift;
+};
+
+#endif /* __IA_CSS_CTC1_5_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
new file mode 100644
index 0000000..8d57b9a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTCX_PARAM_H
+#define __IA_CSS_CTCX_PARAM_H
+
+#include "ia_css_ctc1_5_param.h"
+
+#endif /* __IA_CSS_CTCX_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
new file mode 100644
index 0000000..d10e4ff
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
@@ -0,0 +1,166 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "assert_support.h"
+
+#include "ia_css_ctc2.host.h"
+#include <stdio.h>
+
+#define INEFFECTIVE_VAL 4096
+#define BASIC_VAL 819
+
+/*Default configuration of parameters for Ctc2
+*/
+const struct ia_css_ctc2_config default_ctc2_config = {
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	BASIC_VAL * 2, BASIC_VAL * 4, BASIC_VAL * 6,
+	BASIC_VAL * 8, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	BASIC_VAL >> 1, BASIC_VAL};
+
+
+
+/* (dydx) = ctc2_slope(y1, y0, x1, x0)
+ * -----------------------------------------------
+ * Calculation of the Slope of a Line = ((y1 - y0) >> 8)/(x1 - x0)
+ *
+ * Note: y1, y0 , x1 & x0 must lie within the range 0 <-> 8191
+ */
+static int ctc2_slope(int y1, int y0, int x1, int x0)
+{
+	const int shift_val = 8;
+	const int max_slope = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int rounding = (dx+1) >> 1;
+	int dy_shift = dy << shift_val;
+	int slope, dydx;
+
+	/*Protection for paramater values, & avoiding zero divisions*/
+	assert(y0 >= 0 && y0 <= max_slope);
+	assert(y1 >= 0 && y1 <= max_slope);
+	assert(x0 >= 0 && x0 <= max_slope);
+	assert(x1 > 0 && x1 <= max_slope);
+	assert(dx > 0);
+
+	if (dy < 0) {
+		rounding = -rounding;
+	}
+	slope = (int) (dy_shift + rounding) / dx;
+
+	/*the slope must lie within the range
+	  (-max_slope-1) >= (dydx) >= (max_slope)
+	*/
+	if (slope <= -max_slope-1) {
+		dydx = -max_slope-1;
+	} else if (slope >= max_slope) {
+		dydx = max_slope;
+	} else {
+		dydx = slope;
+	}
+
+	return dydx;
+}
+
+/* (void) = ia_css_ctc2_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate Y parameters from userspace into ISP space
+ */
+void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
+			    const struct ia_css_ctc2_config *from)
+{
+	unsigned i, j;
+	const unsigned shffl_blck = 4;
+	const unsigned lenght_zeros = 11;
+	short dydx0, dydx1, dydx2, dydx3, dydx4;
+
+	/*
+	*  Calculation of slopes of lines interconnecting
+	*  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0
+	*/
+	dydx0 = ctc2_slope(from->y_y1, from->y_y0,
+			    from->y_x1, 0);
+	dydx1 = ctc2_slope(from->y_y2, from->y_y1,
+			    from->y_x2, from->y_x1);
+	dydx2 = ctc2_slope(from->y_y3, from->y_y2,
+			    from->y_x3, from->y_x2);
+	dydx3 = ctc2_slope(from->y_y4, from->y_y3,
+			    from->y_x4, from->y_x3);
+	dydx4 = ctc2_slope(from->y_y5, from->y_y4,
+			    SH_CSS_BAYER_MAXVAL, from->y_x4);
+
+	/*Fill 3 arrays with:
+	* - Luma input gain values y_y0, y_y1, y_y2, y_3, y_y4
+	* - Luma kneepoints 0, y_x1, y_x2, y_x3, y_x4
+	* - Calculated slopes dydx0, dyxd1, dydx2, dydx3, dydx4
+	*
+	* - Each 64-element array is divided in blocks of 16 elements:
+	*   the 5 parameters + zeros in the remaining 11 positions
+	* - All blocks of the same array will contain the same data
+	*/
+	for (i = 0; i < shffl_blck; i++) {
+		to->y_x[0][(i << shffl_blck)]     = 0;
+		to->y_x[0][(i << shffl_blck) + 1] = from->y_x1;
+		to->y_x[0][(i << shffl_blck) + 2] = from->y_x2;
+		to->y_x[0][(i << shffl_blck) + 3] = from->y_x3;
+		to->y_x[0][(i << shffl_blck) + 4] = from->y_x4;
+
+		to->y_y[0][(i << shffl_blck)]     = from->y_y0;
+		to->y_y[0][(i << shffl_blck) + 1] = from->y_y1;
+		to->y_y[0][(i << shffl_blck) + 2] = from->y_y2;
+		to->y_y[0][(i << shffl_blck) + 3] = from->y_y3;
+		to->y_y[0][(i << shffl_blck) + 4] = from->y_y4;
+
+		to->e_y_slope[0][(i << shffl_blck)]    = dydx0;
+		to->e_y_slope[0][(i << shffl_blck) +1] = dydx1;
+		to->e_y_slope[0][(i << shffl_blck) +2] = dydx2;
+		to->e_y_slope[0][(i << shffl_blck) +3] = dydx3;
+		to->e_y_slope[0][(i << shffl_blck) +4] = dydx4;
+
+		for (j = 0; j < lenght_zeros; j++) {
+			to->y_x[0][(i << shffl_blck)+ 5 + j] = 0;
+			to->y_y[0][(i << shffl_blck)+ 5 + j] = 0;
+			to->e_y_slope[0][(i << shffl_blck)+ 5 + j] = 0;
+		}
+	}
+}
+
+/* (void) = ia_css_ctc2_dmem_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void ia_css_ctc2_dmem_encode(struct ia_css_isp_ctc2_dmem_params *to,
+			     struct ia_css_ctc2_config *from)
+{
+	to->uv_y0 = from->uv_y0;
+	to->uv_y1 = from->uv_y1;
+	to->uv_x0 = from->uv_x0;
+	to->uv_x1 = from->uv_x1;
+
+	/*Slope Calculation*/
+	to->uv_dydx = ctc2_slope(from->uv_y1, from->uv_y0,
+				  from->uv_x1, from->uv_x0);
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
new file mode 100644
index 0000000..e5e5b39
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
@@ -0,0 +1,41 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_HOST_H
+#define __IA_CSS_CTC2_HOST_H
+
+#include "ia_css_ctc2_param.h"
+#include "ia_css_ctc2_types.h"
+
+extern const struct ia_css_ctc2_config default_ctc2_config;
+
+/*Encode Functions to translate parameters from userspace into ISP space*/
+
+void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
+			     const struct ia_css_ctc2_config *from);
+
+void ia_css_ctc2_dmem_encode(struct ia_css_isp_ctc2_dmem_params *to,
+			     struct ia_css_ctc2_config *from);
+
+#endif /* __IA_CSS_CTC2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
new file mode 100644
index 0000000..4cc81c6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
@@ -0,0 +1,59 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_PARAM_H
+#define __IA_CSS_CTC2_PARAM_H
+
+#define IA_CSS_CTC_COEF_SHIFT          13
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+/* CTC (Chroma Tone Control)ISP Parameters */
+
+/*VMEM Luma params*/
+struct ia_css_isp_ctc2_vmem_params {
+	/**< Gains by Y(Luma) at Y = 0.0,Y_X1, Y_X2, Y_X3, Y_X4*/
+	VMEM_ARRAY(y_x, ISP_VEC_NELEMS);
+	/** kneepoints by Y(Luma) 0.0, y_x1, y_x2, y _x3, y_x4*/
+	VMEM_ARRAY(y_y, ISP_VEC_NELEMS);
+	/** Slopes of lines interconnecting
+	 *  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0*/
+	VMEM_ARRAY(e_y_slope, ISP_VEC_NELEMS);
+};
+
+/*DMEM Chroma params*/
+struct ia_css_isp_ctc2_dmem_params {
+
+	/** Gains by UV(Chroma) under kneepoints uv_x0 and uv_x1*/
+	int32_t uv_y0;
+	int32_t uv_y1;
+
+	/** Kneepoints by UV(Chroma)- uv_x0 and uv_x1*/
+	int32_t uv_x0;
+	int32_t uv_x1;
+
+	/** Slope of line interconnecting uv_x0 -> uv_x1*/
+	int32_t uv_dydx;
+
+};
+#endif /* __IA_CSS_CTC2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
new file mode 100644
index 0000000..028535a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
@@ -0,0 +1,65 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_TYPES_H
+#define __IA_CSS_CTC2_TYPES_H
+
+/** Chroma Tone Control configuration.
+*
+*  ISP block: CTC2 (CTC by polygonal approximation)
+* (ISP1: CTC1 (CTC by look-up table) is used.)
+*  ISP2: CTC2 is used.
+*  ISP261: CTC2 (CTC by Fast Approximate Distance)
+*/
+struct ia_css_ctc2_config {
+
+	/**< Gains by Y(Luma) at Y =0.0,Y_X1, Y_X2, Y_X3, Y_X4 and Y_X5
+	*   --default/ineffective value: 4096(0.5f)
+	*/
+	uint16_t y_y0;
+	uint16_t y_y1;
+	uint16_t y_y2;
+	uint16_t y_y3;
+	uint16_t y_y4;
+	uint16_t y_y5;
+	/** 1st-4th  kneepoints by Y(Luma) --default/ineffective value:n/a
+	*   requirement: 0.0 < y_x1 < y_x2 <y _x3 < y_x4 < 1.0
+	*/
+	uint16_t y_x1;
+	uint16_t y_x2;
+	uint16_t y_x3;
+	uint16_t y_x4;
+	/** Gains by UV(Chroma) under threholds uv_x0 and uv_x1
+	*   --default/ineffective value: 4096(0.5f)
+	*/
+	uint16_t uv_y0;
+	uint16_t uv_y1;
+	/** Minimum and Maximum Thresholds by UV(Chroma)- uv_x0 and uv_x1
+	*   --default/ineffective value: n/a
+	*/
+	uint16_t uv_x0;
+	uint16_t uv_x1;
+	};
+
+#endif /* __IA_CSS_CTC2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
index a89ff8e..6b23ed5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
@@ -22,11 +22,6 @@
 #include "ia_css_dpc2.host.h"
 #include "assert_support.h"
 
-#define METRIC1_ONE_FP	(1<<12)
-#define METRIC2_ONE_FP	(1<<5)
-#define METRIC3_ONE_FP	(1<<12)
-#define WBGAIN_ONE_FP	(1<<9)
-
 void
 ia_css_dpc2_encode(
 	struct ia_css_isp_dpc2_params *to,
@@ -44,20 +39,13 @@ ia_css_dpc2_encode(
 	assert ((from->wb_gain_b  > 0) && (from->wb_gain_b  < 16*WBGAIN_ONE_FP));
 	assert ((from->wb_gain_gb > 0) && (from->wb_gain_gb < 16*WBGAIN_ONE_FP));
 
-	/* TODO: BBBs */
-	to->one_plus_metric1  = METRIC1_ONE_FP + from->metric1;
-	to->one_minus_metric1 = METRIC1_ONE_FP - from->metric1;
-	to->one_plus_metric3  = METRIC3_ONE_FP + from->metric3;
+	to->metric1 = from->metric1;
+	to->metric2 = from->metric2;
+	to->metric3 = from->metric3;
 
 	to->wb_gain_gr = from->wb_gain_gr;
 	to->wb_gain_r  = from->wb_gain_r;
 	to->wb_gain_b  = from->wb_gain_b;
 	to->wb_gain_gb = from->wb_gain_gb;
-
-	/* TODO: Double-check the precision here by MUL and SHIFT operation */
-	to->wb_gain_gr_scaled_by_metric2 = (from->wb_gain_gr * from->metric2) >> 13;
-	to->wb_gain_r_scaled_by_metric2  = (from->wb_gain_r  * from->metric2) >> 13;
-	to->wb_gain_b_scaled_by_metric2  = (from->wb_gain_b  * from->metric2) >> 13;
-	to->wb_gain_gb_scaled_by_metric2 = (from->wb_gain_gb * from->metric2) >> 13;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
index 860a90f..6402cdc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
@@ -48,17 +48,13 @@
 
 
 struct ia_css_isp_dpc2_params {
-	int32_t one_plus_metric1;
-	int32_t one_minus_metric1;
-	int32_t one_plus_metric3;
+	int32_t metric1;
+	int32_t metric2;
+	int32_t metric3;
 	int32_t wb_gain_gr;
 	int32_t wb_gain_r;
 	int32_t wb_gain_b;
 	int32_t wb_gain_gb;
-	int32_t wb_gain_gr_scaled_by_metric2;
-	int32_t wb_gain_r_scaled_by_metric2;
-	int32_t wb_gain_b_scaled_by_metric2;
-	int32_t wb_gain_gb_scaled_by_metric2;
 };
 
 #endif /* __IA_CSS_DPC2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
index a55dddf..ae21f2b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
@@ -23,6 +23,11 @@
 #define __IA_CSS_DPC2_TYPES_H
 
 #include "type_support.h"
+#define METRIC1_ONE_FP	(1<<12)
+#define METRIC2_ONE_FP	(1<<5)
+#define METRIC3_ONE_FP	(1<<12)
+#define WBGAIN_ONE_FP	(1<<9)
+
 
 struct ia_css_dpc2_config {
 	int32_t metric1;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
index 44bc726..e70ab33 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
@@ -31,10 +31,13 @@
 void
 ia_css_eed1_8_encode(
 	struct ia_css_isp_eed1_8_params *to,
-	const struct ia_css_eed1_8_config *from)
+	const struct ia_css_eed1_8_config *from,
+	size_t size)
 {
 	int i;
 
+	(void)size;
+
 	to->rbzp_strength = from->rbzp_strength;
 
 	to->fcstrength = from->fcstrength;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
index bbd23db..053bd1e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
@@ -29,7 +29,8 @@
 void
 ia_css_eed1_8_encode(
 	struct ia_css_isp_eed1_8_params *to,
-	const struct ia_css_eed1_8_config *from);
+	const struct ia_css_eed1_8_config *from,
+	size_t size);
 
 #ifndef IA_CSS_NO_DEBUG
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
index 135b9ef..d2bd1b5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
@@ -23,8 +23,20 @@
 #define __IA_CSS_EED1_8_PARAM_H
 
 #include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
 #include "ia_css_eed1_8_types.h" /* IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS */
 
+/* Define size of the state..... TODO: check if this is the correct place */
+/* 4 planes : GR, R, B, GB */
+#define NUM_PLANES		4
+/* 3 lines state per color plane input_line_state */
+#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(2 * NUM_PLANES)
+/* ToDo: Move this to testsetup */
+#define MAX_FRAME_SIMDWIDTH	30
+/* Each plane has width equal to half frame line */
+#define EED1_8_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+
 /* EED (Edge Enhancing Demosaic) ISP parameters */
 struct ia_css_isp_eed1_8_params {
 	int32_t rbzp_strength;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
new file mode 100644
index 0000000..75efce7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
@@ -0,0 +1,34 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_EED1_8_STATE_H
+#define __IA_CSS_EED1_8_STATE_H
+
+#include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
+
+#include "ia_css_eed1_8_param.h"
+
+struct ia_css_isp_eed1_8_vmem_state {
+	VMEM_ARRAY(eed1_8_input_lines[EED1_8_STATE_INPUT_BUFFER_HEIGHT], EED1_8_STATE_INPUT_BUFFER_WIDTH*ISP_NWAY);
+};
+
+#endif /* __IA_CSS_EED1_8_STATE_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
new file mode 100644
index 0000000..3cb5e35
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_fixedbds.host.h"
+
+void
+ia_css_bds_encode(
+	struct sh_css_isp_bds_params *to,
+	const struct ia_css_aa_config *from,
+	unsigned size)
+{
+	(void)size;
+	to->baf_strength = from->strength;
+}
+
+void
+ia_css_bds_dump(
+	const struct sh_css_isp_bds_params *raw,
+	unsigned level)
+{
+	(void)raw;
+	(void)level;
+}
+
+void
+ia_css_bds_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level)
+{
+  (void)config;
+  (void)level;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
new file mode 100644
index 0000000..560e7b4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIXEDBDS_HOST_H
+#define __IA_CSS_FIXEDBDS_HOST_H
+
+#include "ia_css_binary.h"
+#include "ia_css_fixedbds_param.h"
+
+void
+ia_css_bds_encode(
+	struct sh_css_isp_bds_params *to,
+	const struct ia_css_aa_config *from,
+	unsigned size);
+
+void
+ia_css_bds_dump(
+	const struct sh_css_isp_bds_params *raw,
+	unsigned level);
+
+void
+ia_css_bds_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_FIXEDBDS_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
new file mode 100644
index 0000000..ded1d61
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIXEDBDS_PARAM_H
+#define __IA_CSS_FIXEDBDS_PARAM_H
+
+#include "type_support.h"
+
+struct sh_css_isp_bds_params {
+	int baf_strength;
+};
+
+#endif /* __IA_CSS_FIXEDBDS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
index 2b38a94..ec69f37 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
@@ -19,8 +19,8 @@
  *
  */
 
-#ifndef __IA_CSS_FIXEDBDS_HOST_H
-#define __IA_CSS_FIXEDBDS_HOST_H
+#ifndef __IA_CSS_FIXEDBDS_TYPES_H
+#define __IA_CSS_FIXEDBDS_TYPES_H
 
 
 struct sh_css_bds_factor {
@@ -30,4 +30,4 @@ struct sh_css_bds_factor {
 };
 
 
-#endif	/*__IA_CSS_FIXEDBDS_HOST_H*/
+#endif	/*__IA_CSS_FIXEDBDS_TYPES_H*/
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c
index 264b80f..66e239c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * INTEL CONFIDENTIAL
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h
index b618004..430587d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h
index 89e39d3..7cc861d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h
index 8ea6202..d872fc2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
index a03cea4..0ca39b3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
@@ -19,9 +19,87 @@
  *
  */
 
+#ifndef IA_CSS_NO_DEBUG
 #include "ia_css_debug.h"
+#endif
 #include "ia_css_iefd2_6.host.h"
 
+/* Copy parameters to VMEM
+ */
+void
+ia_css_iefd2_6_vmem_encode(
+	struct ia_css_isp_iefd2_6_vmem_params *to,
+	const struct ia_css_iefd2_6_config *from,
+	size_t size)
+{
+	const int total_blocks = 4;
+	const int shuffle_block = 16;
+	unsigned i, j, base;
+	(void)size;
+
+	/* For configurable units parameters are copied to vmem. Per CU 3 arrays are copied:
+	 * x containing the x coordinates
+	 * a containing the slopes
+	 * b containing the intercept values.
+	 *
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* first init the vectors */
+	for(i = 0; i < total_blocks*shuffle_block; i++) {
+		to->e_cued_x[0][i] = 0;
+		to->e_cued_a[0][i] = 0;
+		to->e_cued_b[0][i] = 0;
+
+		to->e_cu_dir_x[0][i] = 0;
+		to->e_cu_dir_a[0][i] = 0;
+		to->e_cu_dir_b[0][i] = 0;
+
+		to->e_cu_non_dir_x[0][i] = 0;
+		to->e_cu_non_dir_a[0][i] = 0;
+		to->e_cu_non_dir_b[0][i] = 0;
+	}
+
+	/* Copy all data */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block*i;
+
+
+		to->e_cued_x[0][base] = 0;
+		to->e_cued_a[0][base] = 0;
+		to->e_cued_b[0][base] = from->cu_ed_slopes_b[1];
+
+		to->e_cu_dir_x[0][base] = 0;
+		to->e_cu_dir_a[0][base] = 0;
+		to->e_cu_dir_b[0][base] = from->cu_dir_sharp_slopes_b[1];
+
+		to->e_cu_non_dir_x[0][base] = 0;
+		to->e_cu_non_dir_a[0][base] = 0;
+		to->e_cu_non_dir_b[0][base] = from->cu_non_dir_sharp_slopes_b[1];
+
+		for (j = 1; j < 4; j++) {
+			to->e_cu_dir_a[0][base+j] = from->cu_dir_sharp_slopes_a[j];
+			to->e_cu_dir_b[0][base+j] = from->cu_dir_sharp_slopes_b[j];
+			to->e_cu_non_dir_a[0][base+j] = from->cu_non_dir_sharp_slopes_a[j];
+			to->e_cu_non_dir_b[0][base+j] = from->cu_non_dir_sharp_slopes_b[j];
+		}
+
+		for (j = 1; j < 5; j++) {
+			to->e_cu_dir_x[0][base+j] = from->cu_dir_sharp_points_x[j];
+			to->e_cu_non_dir_x[0][base+j] = from->cu_non_dir_sharp_points_x[j];
+		}
+
+
+		for (j = 1; j < 6; j++) {
+			to->e_cued_x[0][base+j] = from->cu_ed_points_x[j];
+			to->e_cued_a[0][base+j] = from->cu_ed_slopes_a[j];
+			to->e_cued_b[0][base+j] = from->cu_ed_slopes_b[j];
+		}
+
+		to->e_cued_x[0][base+6] = from->cu_ed_points_x[j];
+	}
+}
 
 void
 ia_css_iefd2_6_encode(
@@ -32,6 +110,9 @@ ia_css_iefd2_6_encode(
 	int i;
 
 	(void)size;
+
+	/* Copy parameters to dmem, as described in the KFS
+	 */
 	to->horver_diag_coeff		= from->horver_diag_coeff;
 	to->ed_horver_diag_coeff	= from->ed_horver_diag_coeff;
 	to->dir_smooth_enable		= from->dir_smooth_enable;
@@ -52,10 +133,10 @@ ia_css_iefd2_6_encode(
 	to->rad_cu_dir_sharp_x1		= from->rad_cu_dir_sharp_x1;
 	to->rad_cu_non_dir_sharp_x1	= from->rad_cu_non_dir_sharp_x1;
 	to->rad_dir_far_sharp_weight	= from->rad_dir_far_sharp_weight;
-	to->sharp_nega_lmt_txt		= from->sharp_nega_lmt_txt;
-	to->sharp_posi_lmt_txt		= from->sharp_posi_lmt_txt;
-	to->sharp_nega_lmt_dir		= from->sharp_nega_lmt_dir;
-	to->sharp_posi_lmt_dir		= from->sharp_posi_lmt_dir;
+	to->shrpn_nega_lmt_txt		= from->shrpn_nega_lmt_txt;
+	to->shrpn_posi_lmt_txt		= from->shrpn_posi_lmt_txt;
+	to->shrpn_nega_lmt_dir		= from->shrpn_nega_lmt_dir;
+	to->shrpn_posi_lmt_dir		= from->shrpn_posi_lmt_dir;
 	to->clamp_stitch		= from->clamp_stitch;
 	to->rad_enable			= from->rad_enable;
 	to->rad_x_origin		= from->rad_x_origin;
@@ -72,50 +153,22 @@ ia_css_iefd2_6_encode(
 
 	/* Setup for configurable units */
 	/* First copy the hardcoded items */
-
 	to->curad_x[0]			= 0;
 	to->curad_a[0]			= 0;
 	to->curad_b[0]			= from->cu_radial_slope_b[1];
-	to->e_cued_x[0]			= 0;
-	to->e_cued_a[0]			= 0;
-	to->e_cued_b[0]			= from->cu_ed_slopes_b[1];
-	to->e_cu_dir_x[0]		= 0;
-	to->e_cu_dir_a[0]		= 0;
-	to->e_cu_dir_b[0]		= from->cu_dir_sharp_slopes_b[1];
-	to->e_cu_non_dir_x[0]		= 0;
-	to->e_cu_non_dir_a[0]		= 0;
-	to->e_cu_non_dir_b[0]		= from->cu_non_dir_sharp_slopes_b[1];
 	to->e_cued2_a			= from->cu_ed2_slopes_a;
 	to->e_cu_vssnlm_a		= from->cu_vssnlm_slopes_a;
 
 	/* copying remaining array part */
-
-	for (i = 1; i < 3; i++)
-	{
-		to->e_cu_dir_a[i]		= from->cu_dir_sharp_slopes_a[i];
-		to->e_cu_dir_b[i]		= from->cu_dir_sharp_slopes_b[i];
-		to->e_cu_non_dir_a[i]		= from->cu_non_dir_sharp_slopes_a[i];
-		to->e_cu_non_dir_b[i]		= from->cu_non_dir_sharp_slopes_b[i];
-	}
-
-	for (i = 1; i < 4; i++)
-	{
-		to->e_cu_dir_x[i]		= from->cu_dir_sharp_points_x[i];
-		to->e_cu_non_dir_x[i]		= from->cu_non_dir_sharp_points_x[i];
-	}
-
 	for (i = 1; i < 5; i++)
 	{
 		to->curad_a[i]			= from->cu_radial_slope_a[i];
 		to->curad_b[i]			= from->cu_radial_slope_b[i];
-		to->e_cued_a[i]			= from->cu_ed_slopes_a[i];
-		to->e_cued_b[i]			= from->cu_ed_slopes_b[i];
 	}
 
 	for (i = 1; i < 6; i++)
 	{
 		to->curad_x[i]			= from->cu_radial_points_x[i];
-		to->e_cued_x[i]			= from->cu_ed_points_x[i];
 	}
 
 	to->e_cued2_b		= ((0-from->cu_ed2_points_x[1]) * from->cu_ed2_slopes_a)>>4;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
index 13c9a33..1f83f94 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
@@ -27,6 +27,12 @@
 #include "ia_css_iefd2_6_default.host.h"
 
 void
+ia_css_iefd2_6_vmem_encode(
+	struct ia_css_isp_iefd2_6_vmem_params *to,
+	const struct ia_css_iefd2_6_config *from,
+	size_t size);
+
+void
 ia_css_iefd2_6_encode(
 	struct ia_css_isp_iefd2_6_dmem_params *to,
 	const struct ia_css_iefd2_6_config *from,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
index b1688ce..e56f875 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
@@ -42,10 +42,10 @@ const struct ia_css_iefd2_6_config default_iefd2_6_config = {
 	.rad_cu_dir_sharp_x1 = 0,
 	.rad_cu_non_dir_sharp_x1 = 128,
 	.rad_dir_far_sharp_weight = 8,
-	.sharp_nega_lmt_txt = 1024,
-	.sharp_posi_lmt_txt = 1024,
-	.sharp_nega_lmt_dir = 128,
-	.sharp_posi_lmt_dir = 128,
+	.shrpn_nega_lmt_txt = 1024,
+	.shrpn_posi_lmt_txt = 1024,
+	.shrpn_nega_lmt_dir = 128,
+	.shrpn_posi_lmt_dir = 128,
 	.clamp_stitch = 0,
 	.rad_enable = true,
 	.rad_x_origin = 0,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
index 0310111..ace1bc4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
@@ -23,6 +23,19 @@
 #define __IA_CSS_IEFD2_6_PARAM_H
 
 #include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+struct ia_css_isp_iefd2_6_vmem_params {
+	VMEM_ARRAY(e_cued_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cued_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cued_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_b, ISP_VEC_NELEMS);
+};
 
 struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t horver_diag_coeff;
@@ -45,10 +58,10 @@ struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t rad_cu_dir_sharp_x1;
 	int32_t rad_cu_non_dir_sharp_x1;
 	int32_t rad_dir_far_sharp_weight;
-	int32_t sharp_nega_lmt_txt;
-	int32_t sharp_posi_lmt_txt;
-	int32_t sharp_nega_lmt_dir;
-	int32_t sharp_posi_lmt_dir;
+	int32_t shrpn_nega_lmt_txt;
+	int32_t shrpn_posi_lmt_txt;
+	int32_t shrpn_nega_lmt_dir;
+	int32_t shrpn_posi_lmt_dir;
 	int32_t clamp_stitch;
 	bool rad_enable;
 	int32_t rad_x_origin;
@@ -62,17 +75,8 @@ struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t vssnlm_y1;
 	int32_t vssnlm_y2;
 	int32_t vssnlm_y3;
-	int32_t e_cued_x[6];
-	int32_t e_cued_a[5];
-	int32_t e_cued_b[5];
 	int32_t e_cued2_a;
 	int32_t e_cued2_b;
-	int32_t e_cu_dir_x[4];
-	int32_t e_cu_dir_a[3];
-	int32_t e_cu_dir_b[3];
-	int32_t e_cu_non_dir_x[4];
-	int32_t e_cu_non_dir_a[3];
-	int32_t e_cu_non_dir_b[3];
 	int32_t curad_x[6];
 	int32_t curad_a[5];
 	int32_t curad_b[5];
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
index 264aa2d..18cfc8d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
@@ -80,14 +80,14 @@ struct ia_css_iefd2_6_config {
 						u9.0, [0,511], default 128, ineffective 0 */
 	int32_t rad_dir_far_sharp_weight;  /**< Weight of wide direct sharpening.
 						u1.12, [0,4096], default 8, ineffective 0 */
-	int32_t sharp_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
+	int32_t shrpn_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t sharp_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
+	int32_t shrpn_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t sharp_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
+	int32_t shrpn_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
-	int32_t sharp_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
+	int32_t shrpn_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
 	int32_t clamp_stitch;		   /**< Slope to stitch between clamped and unclamped edge values.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
new file mode 100644
index 0000000..2e999b9
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_LOAD_PARAM_H
+#define __IA_CSS_YUV_LOAD_PARAM_H
+
+#include "ia_css_yuv_ls_param.h"
+
+#endif /* __IA_CSS_YUV_LOAD_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
new file mode 100644
index 0000000..fe12bf7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_LS_PARAM_H
+#define __IA_CSS_YUV_LS_PARAM_H
+
+#include "type_support.h"
+
+/* The number of load/store kernels in a pipeline can be greater than one.
+ * A kernel can consume more than one input or can produce more
+ * than one output.
+ */
+#define NUM_YUV_LS 2
+
+/** YUV load/store */
+struct sh_css_isp_yuv_ls_isp_config {
+	unsigned base_address[NUM_YUV_LS];
+	unsigned width[NUM_YUV_LS];
+	unsigned height[NUM_YUV_LS];
+	unsigned stride[NUM_YUV_LS];
+};
+
+
+#endif /* __IA_CSS_YUV_LS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
new file mode 100644
index 0000000..88d9dea
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_STORE_PARAM_H
+#define __IA_CSS_YUV_STORE_PARAM_H
+
+#include "ia_css_yuv_ls_param.h"
+
+
+#endif /* __IA_CSS_YUV_STORE_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h
index e2cd223..860eafc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h
@@ -129,6 +129,7 @@
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_YUVP2               131
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_REF               132
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_REF_STRIPED       133
+#define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_REF           134
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_DVS               135
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR               136
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_STRIPED       137
@@ -195,6 +196,7 @@
 #define SH_CSS_BINARY_ID_IF_TO_BDS_RGBP_DVS_STATS           233
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_NO_DPC_OB              234
 #define SH_CSS_BINARY_ID_IF_TO_BDS_RGBP_DVS_STATS_STRIPED   235
+#define SH_CSS_BINARY_ID_IF_TO_REF                          236
 #define SH_CSS_BINARY_ID_IF_TO_DVS_STRIPED                  237
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_STRIPED                238
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1_STRIPED                239
@@ -211,6 +213,13 @@
 #define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STRIPED           250
 #define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STATS_C0          251
 #define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE            252
+#define SH_CSS_BINARY_ID_COPY_KERNELTEST_OUTPUT_SYSTEM      253
+#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE_C0         254
+#define SH_CSS_BINARY_ID_IF_TO_XNR                          255
+#define SH_CSS_BINARY_ID_IF_TO_XNR_STRIPED                  256
+#define SH_CSS_BINARY_ID_IF_TO_REF_STRIPED                  257
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS                   258
+
 
 #define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
 #define XMEM_SHORTS_PER_WORD         (HIVE_ISP_DDR_WORD_BITS/16)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c
index 9f074f7..2733d0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c
@@ -449,6 +449,21 @@ binary_supports_output_format(const struct ia_css_binary_xinfo *info,
 	return false;
 }
 
+static bool
+binary_supports_vf_format(const struct ia_css_binary_xinfo *info,
+			  enum ia_css_frame_format format)
+{
+	int i;
+
+	assert(info != NULL);
+
+	for (i = 0; i < info->num_vf_formats; i++) {
+		if (info->vf_formats[i] == format)
+			return true;
+	}
+	return false;
+}
+
 /* move to host part of bds module */
 static bool
 supports_bds_factor(uint32_t supported_factors,
@@ -464,8 +479,8 @@ binary_init_info(struct ia_css_binary_xinfo *info, unsigned int i,
 	const unsigned char *blob = sh_css_blob_info[i].blob;
 	unsigned size = sh_css_blob_info[i].header.blob.size;
 
-	assert(info != NULL);
-	assert(binary_found != NULL);
+	if ((info == NULL) || (binary_found == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	*info = sh_css_blob_info[i].header.info.isp;
 	*binary_found = blob != NULL;
@@ -756,8 +771,7 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	/* viewfinder output info */
 	if ((vf_info != NULL) && (vf_info->res.width != 0)) {
 		unsigned int vf_out_vecs, vf_out_width, vf_out_height;
-
-		binary->vf_frame_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+		binary->vf_frame_info.format = vf_info->format;
 		if (bin_out_info == NULL)
 			return IA_CSS_ERR_INTERNAL_ERROR;
 		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(bin_out_info->padded_width,
@@ -1166,6 +1180,18 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 			continue;
 		}
 
+		/* Check if vf_veceven supports the requested vf format */
+		if (xcandidate->num_output_pins == 1 &&
+			req_vf_info && candidate->enable.vf_veceven &&
+			!binary_supports_vf_format(xcandidate, req_vf_info->format)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%d == %d) && (%p != NULL) && %d && !%d\n",
+				__LINE__, xcandidate->num_output_pins, 1,
+				req_vf_info, candidate->enable.vf_veceven,
+				binary_supports_vf_format(xcandidate, req_vf_info->format));
+			continue;
+		}
+
 		if (!supports_bds_factor(candidate->bds.supported_bds_factors,
 		    descr->required_bds_factor)) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h
index 9761b66..f2c4b16 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h
@@ -151,6 +151,13 @@ ia_css_debug_dtrace(unsigned int level, const char *fmt, ...)
 }
 #endif
 
+/*! \brief Dump sp thread's stack contents
+ * SP thread's stack contents are set to 0xcafecafe. This function dumps the
+ * stack to inspect if the stack's boundaries are compromised.
+ * \return	None
+ */
+void ia_css_debug_dump_sp_stack_info(void);
+
 /*! \brief Function to set the global dtrace verbosity level.
  * \param[in]	trace_level	Maximum level of the messages to be traced.
  * \return	None
@@ -227,17 +234,23 @@ void ia_css_debug_dump_dma_isp_fifo_state(void);
  */
 void ia_css_debug_dump_dma_sp_fifo_state(void);
 
-/*! \brief Dump pif isp fifo state
+/*! \brief Dump pif A isp fifo state
+ * Dumps the primary input formatter state to tracing output.
+ * \return	None
+ */
+void ia_css_debug_dump_pif_a_isp_fifo_state(void);
+
+/*! \brief Dump pif B isp fifo state
  * Dumps the primary input formatter state to tracing output.
  * \return	None
  */
-void ia_css_debug_dump_pif_isp_fifo_state(void);
+void ia_css_debug_dump_pif_b_isp_fifo_state(void);
 
 /*! \brief Dump stream-to-memory sp fifo state
  * Dumps the stream-to-memory block state to tracing output.
  * \return	None
  */
-extern void ia_css_debug_dump_str2mem_sp_fifo_state(void);
+void ia_css_debug_dump_str2mem_sp_fifo_state(void);
 
 /*! \brief Dump isp sp fifo state
  * Dumps the isp sp fifo state to tracing output.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c
index 32bcdaf..36c321b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c
@@ -65,6 +65,7 @@
 #include "sp.h"
 #include "isp.h"
 #include "type_support.h"
+#include "math_support.h" /* CEIL_DIV */
 #if defined(HAS_INPUT_FORMATTER_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
 #include "input_system.h"	/* input_formatter_reg_load */
 #include "gp_device.h"		/* gp_device_reg_load */
@@ -119,6 +120,12 @@ unsigned int ia_css_debug_trace_level = IA_CSS_DEBUG_WARNING;
 
 #define ENABLE_LINE_MAX_LENGTH (25)
 
+/*
+ * TODO:SH_CSS_MAX_SP_THREADS is not the max number of sp threads
+ * future rework should fix this and remove the define MAX_THREAD_NUM
+ */
+#define MAX_THREAD_NUM (SH_CSS_MAX_SP_THREADS + SH_CSS_MAX_SP_INTERNAL_THREADS)
+
 static struct pipe_graph_class {
 	bool do_init;
 	int height;
@@ -151,6 +158,87 @@ static const char * const pipe_id_to_str[] = {
 static char dot_id_input_bin[SH_CSS_MAX_BINARY_NAME+10];
 static char ring_buffer[200];
 
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+static void debug_dump_long_array_formatted(
+	const sp_ID_t sp_id,
+	hrt_address stack_sp_addr,
+	unsigned stack_size)
+{
+	unsigned int i;
+	uint32_t val;
+	uint32_t addr = (uint32_t) stack_sp_addr;
+	uint32_t stack_size_words = CEIL_DIV(stack_size, sizeof(uint32_t));
+
+	/* When size is not multiple of four, last word is only relevant for
+	 * remaining bytes */
+	for (i = 0; i < stack_size_words; i++) {
+		val = sp_dmem_load_uint32(sp_id, (hrt_address)addr);
+		if ((i%8) == 0)
+			ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "\n");
+
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "0x%08x ", val);
+		addr += sizeof(uint32_t);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "\n");
+}
+
+static void debug_dump_sp_stack_info(
+	const sp_ID_t sp_id)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_threads_stack;
+	unsigned int HIVE_ADDR_sp_threads_stack_size;
+	uint32_t stack_sizes[MAX_THREAD_NUM];
+	uint32_t stack_sp_addr[MAX_THREAD_NUM];
+	unsigned int i;
+
+	fw = &sh_css_sp_fw;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "sp_id(%u) stack info\n", sp_id);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+		"from objects stack_addr_offset:0x%x stack_size_offset:0x%x\n",
+		fw->info.sp.threads_stack,
+		fw->info.sp.threads_stack_size);
+
+	HIVE_ADDR_sp_threads_stack = fw->info.sp.threads_stack;
+	HIVE_ADDR_sp_threads_stack_size = fw->info.sp.threads_stack_size;
+
+	if (fw->info.sp.threads_stack == 0 ||
+		fw->info.sp.threads_stack_size == 0)
+		return;
+
+	(void) HIVE_ADDR_sp_threads_stack;
+	(void) HIVE_ADDR_sp_threads_stack_size;
+
+	sp_dmem_load(sp_id,
+		(unsigned int)sp_address_of(sp_threads_stack),
+		&stack_sp_addr, sizeof(stack_sp_addr));
+	sp_dmem_load(sp_id,
+		(unsigned int)sp_address_of(sp_threads_stack_size),
+		&stack_sizes, sizeof(stack_sizes));
+
+	for (i = 0 ; i < MAX_THREAD_NUM; i++) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			"thread: %u stack_addr: 0x%08x stack_size: %u\n",
+			i, stack_sp_addr[i], stack_sizes[i]);
+		debug_dump_long_array_formatted(sp_id, (hrt_address)stack_sp_addr[i],
+			stack_sizes[i]);
+	}
+}
+
+void ia_css_debug_dump_sp_stack_info(void)
+{
+	debug_dump_sp_stack_info(SP0_ID);
+}
+#else
+/* Empty def for crun */
+void ia_css_debug_dump_sp_stack_info(void)
+{
+}
+#endif /* #if __HIVECC */
+
+
 void ia_css_debug_set_dtrace_level(const unsigned int trace_level)
 {
 	ia_css_debug_trace_level = trace_level;
@@ -454,8 +542,59 @@ void ia_css_debug_dump_sp_state(void)
 	return;
 }
 
+static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
+					   const char *descr)
+{
+	assert(state != NULL);
+	assert(descr != NULL);
+
+	ia_css_debug_dtrace(2, "FIFO channel: %s\n", descr);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "source valid",
+			    state->src_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo accept",
+			    state->fifo_accept);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo valid",
+			    state->fifo_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "sink accept",
+			    state->sink_accept);
+	return;
+}
+
 #if !defined(HAS_NO_INPUT_FORMATTER) && defined(USE_INPUT_SYSTEM_VERSION_2)
-static void debug_print_if_state(input_formatter_state_t *state)
+void ia_css_debug_dump_pif_a_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
+	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
+	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A");
+}
+
+void ia_css_debug_dump_pif_b_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_IF1_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_IF1, &isp_to_pif);
+	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF B to ISP");
+	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF B");
+}
+
+void ia_css_debug_dump_str2mem_sp_fifo_state(void)
+{
+	fifo_channel_state_t s2m_to_sp, sp_to_s2m;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_STREAM2MEM0_TO_SP0, &s2m_to_sp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_SP0_TO_STREAM2MEM0, &sp_to_s2m);
+	debug_print_fifo_channel_state(&s2m_to_sp, "Stream-to-memory to SP");
+	debug_print_fifo_channel_state(&sp_to_s2m, "SP to stream-to-memory");
+}
+
+static void debug_print_if_state(input_formatter_state_t *state, const char *id)
 {
 	unsigned int val;
 
@@ -489,7 +628,7 @@ static void debug_print_if_state(input_formatter_state_t *state)
 	int st_block_fifo_when_no_req = state->block_fifo_when_no_req;
 
 	assert(state != NULL);
-	ia_css_debug_dtrace(2, "InputFormatter State:\n");
+	ia_css_debug_dtrace(2, "InputFormatter State (%s):\n", id);
 
 	ia_css_debug_dtrace(2, "\tConfiguration:\n");
 
@@ -777,8 +916,12 @@ void ia_css_debug_dump_if_state(void)
 	input_formatter_bin_state_t if_bin_state;
 
 	input_formatter_get_state(INPUT_FORMATTER0_ID, &if_state);
-	debug_print_if_state(&if_state);
-	ia_css_debug_dump_pif_isp_fifo_state();
+	debug_print_if_state(&if_state, "Primary IF A");
+	ia_css_debug_dump_pif_a_isp_fifo_state();
+
+	input_formatter_get_state(INPUT_FORMATTER1_ID, &if_state);
+	debug_print_if_state(&if_state, "Primary IF B");
+	ia_css_debug_dump_pif_b_isp_fifo_state();
 
 	input_formatter_bin_get_state(INPUT_FORMATTER3_ID, &if_bin_state);
 	debug_print_if_bin_state(&if_bin_state);
@@ -1057,46 +1200,6 @@ void ia_css_debug_dump_dma_state(void)
 	return;
 }
 
-static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
-					   const char *descr)
-{
-	assert(state != NULL);
-	assert(descr != NULL);
-
-	ia_css_debug_dtrace(2, "FIFO channel: %s\n", descr);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "source valid",
-			    state->src_valid);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo accept",
-			    state->fifo_accept);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo valid",
-			    state->fifo_valid);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "sink accept",
-			    state->sink_accept);
-	return;
-}
-
-void ia_css_debug_dump_pif_isp_fifo_state(void)
-{
-	fifo_channel_state_t pif_to_isp, isp_to_pif;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
-	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
-	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A");
-}
-
-void ia_css_debug_dump_str2mem_sp_fifo_state(void)
-{
-	fifo_channel_state_t s2m_to_sp, sp_to_s2m;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_STREAM2MEM0_TO_SP0, &s2m_to_sp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_SP0_TO_STREAM2MEM0, &sp_to_s2m);
-	debug_print_fifo_channel_state(&s2m_to_sp, "Stream-to-memory to SP");
-	debug_print_fifo_channel_state(&sp_to_s2m, "SP to stream-to-memory");
-}
-
 void ia_css_debug_dump_dma_sp_fifo_state(void)
 {
 	fifo_channel_state_t dma_to_sp, sp_to_dma;
@@ -2506,11 +2609,6 @@ STORAGE_CLASS_INLINE void dtrace_dot(const char *fmt, ...)
 	va_end(ap);
 }
 #ifdef HAS_WATCHDOG_SP_THREAD_DEBUG
-/*
- * TODO:SH_CSS_MAX_SP_THREADS is not the max number of sp threads
- * future rework should fix this and remove the define MAX_THREAD_NUM
- */
-#define MAX_THREAD_NUM (SH_CSS_MAX_SP_THREADS + SH_CSS_MAX_SP_INTERNAL_THREADS)
 void sh_css_dump_thread_wait_info(void)
 {
 	const struct ia_css_fw_info *fw;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c
index fd0cf99..91d4406 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c
@@ -27,6 +27,10 @@
 #include "sh_css_internal.h"
 #include "memory_access.h"
 
+
+#define NV12_TILEY_TILE_WIDTH  128
+#define NV12_TILEY_TILE_HEIGHT  32
+
 /**************************************************************************
 **	Static functions declarations
 **************************************************************************/
@@ -380,6 +384,7 @@ enum ia_css_err ia_css_frame_init_planes(struct ia_css_frame *frame)
 		 */
 	case IA_CSS_FRAME_FORMAT_NV12:
 	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV12_TILEY:
 		frame_init_nv_planes(frame, 2, 2);
 		break;
 		/* nv16 and nv61 have the same frame layout, only the data
@@ -454,6 +459,8 @@ void ia_css_frame_info_set_width(struct ia_css_frame_info *info,
 	    info->format == IA_CSS_FRAME_FORMAT_YUV_LINE)
 		info->padded_width =
 		    CEIL_MUL(align, 2 * HIVE_ISP_DDR_WORD_BYTES);
+	else if (info->format == IA_CSS_FRAME_FORMAT_NV12_TILEY)
+		info->padded_width = CEIL_MUL(align, NV12_TILEY_TILE_WIDTH);
 	else if (info->format == IA_CSS_FRAME_FORMAT_RAW ||
 		 info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED)
 		info->padded_width = CEIL_MUL(align, 2 * ISP_VEC_NELEMS);
@@ -468,11 +475,7 @@ void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
 	assert(info != NULL);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 		"ia_css_frame_info_set_format() enter:\n");
-	/* yuv_line has 2*NWAY alignment */
 	info->format = format;
-	/* HACK: this resets the padded width incorrectly.
-	   Lex needs to fix this in the vf_veceven module. */
-	info->padded_width = CEIL_MUL(info->padded_width, 2 * ISP_VEC_NELEMS);
 }
 
 void ia_css_frame_info_init(struct ia_css_frame_info *info,
@@ -650,7 +653,7 @@ static void frame_init_mipi_plane(struct ia_css_frame *frame,
 	unsigned int stride;
 
 	stride = subpixels_per_line * bytes_per_pixel;
-	frame->data_bytes = 8388608;
+	frame->data_bytes = 8388608; /* 8*1024*1024 */
 	frame->valid = false;
 	frame->contiguous = true;
 	frame_init_plane(plane, subpixels_per_line, stride, height, 0);
@@ -666,6 +669,13 @@ static void frame_init_nv_planes(struct ia_css_frame *frame,
 	    uv_width = 2 * (y_width / horizontal_decimation),
 	    uv_height = y_height / vertical_decimation, y_bytes, uv_bytes;
 
+	if (IA_CSS_FRAME_FORMAT_NV12_TILEY == frame->info.format) {
+		y_width   = CEIL_MUL(y_width,   NV12_TILEY_TILE_WIDTH);
+		uv_width  = CEIL_MUL(uv_width,  NV12_TILEY_TILE_WIDTH);
+		y_height  = CEIL_MUL(y_height,  NV12_TILEY_TILE_HEIGHT);
+		uv_height = CEIL_MUL(uv_height, NV12_TILEY_TILE_HEIGHT);
+	}
+
 	y_bytes = y_width * y_height;
 	uv_bytes = uv_width * uv_height;
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c
index 6448e9a..66c723a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c
@@ -484,8 +484,13 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 	bool port_enabled[N_MIPI_PORT_ID];
 	bool any_port_enabled = false;
 	mipi_port_ID_t port;
-
-	assert(config != NULL);
+    
+    if ((config == NULL)
+            || (config->mode >= N_RX_MODE)
+            || (config->port >= N_MIPI_PORT_ID)) {
+            assert(0);
+            return;
+    }
 	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++) {
 		if (is_receiver_port_enabled(RX0_ID, port))
 			any_port_enabled = true;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/virtual_isys.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/virtual_isys.c
index 5222e77..1b57e4f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/virtual_isys.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/virtual_isys.c
@@ -174,6 +174,10 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 		"ia_css_isys_stream_create() enter:\n");
 
+	/*Reset isys_stream to 0*/
+	memset(isys_stream, 0, sizeof(*isys_stream));
+	isys_stream->enable_metadata = isys_stream_descr->metadata.enable;
+
 	isys_stream->linked_isys_stream_id = isys_stream_descr->linked_isys_stream_id;
 	rc = create_input_system_input_port(isys_stream_descr, &(isys_stream->input_port));
 	if (rc == false)
@@ -181,7 +185,7 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 
 	rc = create_input_system_channel(isys_stream_descr, false, &(isys_stream->channel));
 	if (rc == false) {
-		destroy_input_system_input_port(&(isys_stream->input_port));
+		destroy_input_system_input_port(&isys_stream->input_port);
 		return false;
 	}
 
@@ -203,7 +207,7 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 void ia_css_isys_stream_destroy(
 	ia_css_isys_stream_h	isys_stream)
 {
-	destroy_input_system_input_port(&(isys_stream->input_port));
+	destroy_input_system_input_port(&isys_stream->input_port);
 	destroy_input_system_channel(&(isys_stream->channel));
 	if (isys_stream->enable_metadata) {
 		/* Destroy metadata channel only if its allocated*/
@@ -402,6 +406,7 @@ static bool create_input_system_input_port(
 	me->source_type = cfg->mode;
 
 	/* for metadata */
+	me->metadata.packet_type = CSI_MIPI_PACKET_TYPE_UNDEFINED;
 	if (rc && cfg->metadata.enable) {
 		me->metadata.packet_type = get_csi_mipi_packet_type(
 				cfg->metadata.fmt_type);
@@ -423,6 +428,14 @@ static void destroy_input_system_input_port(
 				me->csi_rx.packet_type,
 				&me->csi_rx.backend_lut_entry);
 	}
+
+	if (me->metadata.packet_type != CSI_MIPI_PACKET_TYPE_UNDEFINED) {
+		/*Free the backend lut allocated for metadata*/
+		release_be_lut_entry(
+				me->csi_rx.backend_id,
+				me->metadata.packet_type,
+				&me->metadata.backend_lut_entry);
+	}
 }
 
 static bool calculate_input_system_channel_cfg(
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/rmgr/src/rmgr_vbuf.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/rmgr/src/rmgr_vbuf.c
index 4655dd7..1870766 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/rmgr/src/rmgr_vbuf.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/rmgr/src/rmgr_vbuf.c
@@ -121,9 +121,11 @@ void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
  */
 void ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
 {
-	assert(handle != NULL);
-	assert(*handle != NULL);
-	assert((*handle)->count != 0);
+	if ((handle == NULL) || ((*handle) == NULL) || (((*handle)->count) == 0)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "ia_css_rmgr_refcount_release_vbuf() invalid arguments!\n");
+		return;
+	}
 	/* decrease reference count */
 	(*handle)->count--;
 	/* remove from admin */
@@ -175,7 +177,10 @@ void ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
 {
 	uint32_t i;
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_rmgr_uninit_vbuf()\n");
-	assert(pool != NULL);
+	if (pool == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_rmgr_uninit_vbuf(): NULL argument\n");
+		 return;
+	}
 	if (pool->handles != NULL) {
 		/* free the hmm buffers */
 		for (i = 0; i < pool->size; i++) {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/spctrl/src/spctrl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/spctrl/src/spctrl.c
index 9fc89d5..88e48f6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/spctrl/src/spctrl.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/spctrl/src/spctrl.c
@@ -30,6 +30,7 @@
 #include "memory_access.h"
 #include "assert_support.h"
 #include "ia_css_spctrl.h"
+#include "ia_css_debug.h"
 
 typedef struct {
 	struct ia_css_sp_init_dmem_cfg dmem_config;
@@ -82,10 +83,22 @@ enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
 		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
 	mmgr_store(code_addr, spctrl_cfg->code, spctrl_cfg->code_size);
 
-	assert(sizeof(hrt_vaddress) <= sizeof(hrt_data));
+	if (sizeof(hrt_vaddress) > sizeof(hrt_data)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "size of hrt_vaddress can not be greater than hrt_data\n");
+		mmgr_free(spctrl_cfg->code_size);
+		spctrl_cfg->code_size = mmgr_NULL;
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 
 	init_dmem_cfg->ddr_data_addr  = code_addr + spctrl_cfg->ddr_data_offset;
-	assert((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) == 0);
+	if ((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) != 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "DDR address pointer is not properly aligned for DMA transfer\n");
+		mmgr_free(spctrl_cfg->code_size);
+		spctrl_cfg->code_size = mmgr_NULL;
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 #endif
 	spctrl_cofig_info[sp_id].sp_entry = spctrl_cfg->sp_entry;
 	spctrl_cofig_info[sp_id].code_addr = code_addr;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c
index 23854ea..7a9a587 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c
@@ -1184,7 +1184,8 @@ static void print_pc_histo(char *core_name, struct sh_css_pc_histogram *hist)
 	unsigned cnt_run = 0;
 	unsigned cnt_stall = 0;
 
-	assert(hist != NULL);
+	if (hist == NULL)
+		return;
 
 	sh_css_print("%s histogram length = %d\n", core_name, hist->length);
 	sh_css_print("%s PC\trun\tstall\n", core_name);
@@ -4994,6 +4995,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	struct ia_css_frame_info video_bin_out_info;
 	bool need_scaler = false;
 	bool vf_res_different_than_output = false;
+	bool need_vf_pp = false;
+	int vf_ds_log2;
 	struct ia_css_video_settings *mycs  = &pipe->pipe_settings.video;
 
 	assert(pipe != NULL);
@@ -5100,19 +5103,65 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 
 	{
 		struct ia_css_binary_descr video_descr;
+		enum ia_css_frame_format vf_info_format;
 
 		err = ia_css_pipe_get_video_binarydesc(pipe,
 			&video_descr, &video_in_info, &video_bds_out_info, &video_bin_out_info, video_vf_info,
 			pipe->stream->config.left_padding);
 		if (err != IA_CSS_SUCCESS)
 			return err;
+
+		/* In the case where video_vf_info is not NULL, this allows
+		 * us to find a potential video library with desired vf format.
+		 * If success, no vf_pp binary is needed.
+		 * If failed, we will look up video binary with YUV_LINE vf format
+		 */
 		err = ia_css_binary_find(&video_descr,
 					 &mycs->video_binary);
-		if (err != IA_CSS_SUCCESS)
-			return err;
-	}
 
-	num_output_pins = mycs->video_binary.info->num_output_pins;
+		if (err != IA_CSS_SUCCESS) {
+			if (video_vf_info) {
+				/* This will do another video binary lookup later for YUV_LINE format*/
+				need_vf_pp = true;
+			} else
+				return err;
+		} else if (video_vf_info) {
+			/* The first video binary lookup is successful, but we may
+			 * still need vf_pp binary based on additiona check */
+			num_output_pins = mycs->video_binary.info->num_output_pins;
+			vf_ds_log2 = mycs->video_binary.vf_downscale_log2;
+
+			/* If the binary has dual output pins, we need vf_pp if the resolution
+			* is different. */
+			need_vf_pp |= ((num_output_pins == 2) && vf_res_different_than_output);
+
+			/* If the binary has single output pin, we need vf_pp if additional
+			* scaling is needed for vf */
+			need_vf_pp |= ((num_output_pins == 1) &&
+				((video_vf_info->res.width << vf_ds_log2 != pipe_out_info->res.width) ||
+				(video_vf_info->res.height << vf_ds_log2 != pipe_out_info->res.height)));
+		}
+
+		if (need_vf_pp) {
+			/* save the current vf_info format for restoration later */
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"load_video_binaries() need_vf_pp; find video binary with YUV_LINE again\n");
+
+			vf_info_format = video_vf_info->format;
+
+			ia_css_frame_info_set_format(video_vf_info,
+					IA_CSS_FRAME_FORMAT_YUV_LINE);
+			err = ia_css_binary_find(&video_descr,
+						&mycs->video_binary);
+
+			/* restore original vf_info format */
+			ia_css_frame_info_set_format(video_vf_info,
+					vf_info_format);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+
+	}
 
 	/* If a video binary does not use a ref_frame, we set the frame delay
 	 * to 0. This is the case for the 1-stage low-power video binary. */
@@ -5153,12 +5202,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 #endif
 #endif
 
-	/* Viewfinder post-processing */
-	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] &&  /* only when viewfinder is enabled. */
-	   ((num_output_pins == 1)        /* when the binary has a single output pin, we need vf_pp */
-		|| ((num_output_pins == 2) && vf_res_different_than_output))) {
-			/* when the binary has dual output pin, */
-			/* we only need vf_pp in case the resolution is different. */
+#if !defined(HAS_OUTPUT_SYSTEM)
+	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {
 		struct ia_css_binary_descr vf_pp_descr;
 
 		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
@@ -5169,6 +5214,7 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 		if (err != IA_CSS_SUCCESS)
 			return err;
 	}
+#endif
 
 	ref_info = mycs->video_binary.internal_frame_info;
 #if defined(IS_ISP_2500_SYSTEM)
@@ -6795,8 +6841,10 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 			}
 		}
 	} else if (post_stage != NULL) {
-		err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
+		if (vf_frame[0] != NULL && vf_frame[0]->info.res.width != 0) {
+			err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
 				      post_stage, &vf_pp_stage);
+		}
 		if (err != IA_CSS_SUCCESS)
 			return err;
 	}
@@ -9134,7 +9182,7 @@ enum ia_css_err
 ia_css_stop_sp(void)
 {
 	unsigned int i;
-	unsigned long timeout;
+/*	unsigned long timeout; */
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
 	IA_CSS_ENTER("void");
@@ -9151,6 +9199,7 @@ ia_css_stop_sp(void)
 	sh_css_write_host2sp_command(host2sp_cmd_terminate);
 	sh_css_sp_set_sp_running(false);
 
+#if 0
 	timeout = SP_SHUTDOWN_TIMEOUT_US;
 	while (!sp_ctrl_getbit(SP0_ID, SP_SC_REG, SP_IDLE_BIT) && timeout) {
 		timeout--;
@@ -9172,7 +9221,7 @@ ia_css_stop_sp(void)
 		IA_CSS_WARNING("ISP is not idle");
 		ia_css_debug_dump_sp_sw_debug_info();
 	}
-
+#endif
 	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
 		if (hmm_buffer_record_h[i] != NULL) {
 			ia_css_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c
index a298792..d5d162b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c
@@ -54,10 +54,10 @@ struct fw_param {
 /* Warning: same order as SH_CSS_BINARY_ID_* */
 static struct firmware_header *firmware_header;
 
-/* The string STR(irci_master_20141014_1500) is a place holder
+/* The string STR(irci_master_20141029_1500) is a place holder
  * which will be replaced with the actual RELEASE_VERSION
  * during package generation. Please do not modify  */
-static const char *release_version = STR(irci_master_20141014_1500);
+static const char *release_version = STR(irci_master_20141029_1500);
 
 #define MAX_FW_REL_VER_NAME	300
 static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
@@ -88,8 +88,8 @@ setup_sp(struct ia_css_fw_info *fw, const char *fw_data, struct ia_css_fw_info *
 {
 	const char *blob_data;
 
-	assert(fw != NULL);
-	assert(fw_data != NULL);
+	if ((fw == NULL) || (fw_data == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	blob_data = fw_data + fw->blob.offset;
 
@@ -116,8 +116,8 @@ sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi, struct ia
 	const char *name;
 	const unsigned char *blob;
 
-	assert(fw != NULL);
-	assert(bd != NULL);
+	if ((fw == NULL) || (bd == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	/* Special case: only one binary in fw */
 	if (bi == NULL) bi = (const struct ia_css_fw_info *)fw;
@@ -226,9 +226,6 @@ sh_css_load_firmware(const char *fw_data,
 #if (!defined HRT_CSIM && !defined HRT_RTL)
 		IA_CSS_ERROR("CSS code version (%s) and firmware version (%s) mismatch!",
 				file_header->version, release_version);
-		pr_err("ISP firmware version mismatch, got %s, want %s\n",
-		       file_header->version, release_version);
-		WARN_ON(1);
 		return IA_CSS_ERR_VERSION_MISMATCH;
 #endif
 	} else {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h
index 483a9c3..462c19b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h
@@ -147,7 +147,6 @@
 
 #define SH_CSS_MAX_SP_INTERNAL_THREADS	(\
 	 SH_CSS_SP_INTERNAL_SERVICE_THREAD +\
-	 SH_CSS_SP_INTERNAL_SWITCH_GACS_TO_SP1_THREAD +\
 	 SH_CSS_SP_INTERNAL_METADATA_THREAD)
 
 #define SH_CSS_MAX_PIPELINES	SH_CSS_MAX_SP_THREADS
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c
index 000c47b..95024ec 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c
@@ -90,7 +90,7 @@
 #include "anr/anr_2/ia_css_anr2.host.h"
 #include "bh/bh_2/ia_css_bh.host.h"
 #include "cnr/cnr_2/ia_css_cnr2.host.h"
-#include "ctc/ctc_2/ia_css_ctc2.host.h"
+#include "ctc/ctc1_5/ia_css_ctc1_5.host.h"
 #include "de/de_2/ia_css_de2.host.h"
 #include "gc/gc_2/ia_css_gc2.host.h"
 #include "sdis/sdis_2/ia_css_sdis2.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c
index 4c2ca88..3b3183f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c
@@ -29,20 +29,20 @@
 
 #define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
 
-/* function input_system_acquisition_stop: AD2 */
+/* function input_system_acquisition_stop: B05 */
 
-/* function longjmp: 683C */
+/* function longjmp: 68F4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_buff_pool_lock_frame_handles
 #define HIVE_MEM_raw_buff_pool_lock_frame_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_buff_pool_lock_frame_handles 0x6198
+#define HIVE_ADDR_raw_buff_pool_lock_frame_handles 0x6188
 #define HIVE_SIZE_raw_buff_pool_lock_frame_handles 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_buff_pool_lock_frame_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_buff_pool_lock_frame_handles 0x6198
+#define HIVE_ADDR_sp_raw_buff_pool_lock_frame_handles 0x6188
 #define HIVE_SIZE_sp_raw_buff_pool_lock_frame_handles 60
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -57,66 +57,66 @@
 #define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x1CC
 #define HIVE_SIZE_sp_HIVE_IF_SRST_MASK 16
 
-/* function tmpmem_init_dmem: 65EF */
+/* function tmpmem_init_dmem: 66A7 */
 
-/* function ia_css_isys_sp_token_map_receive_ack: 5F04 */
+/* function ia_css_isys_sp_token_map_receive_ack: 5FBC */
 
-/* function ia_css_dmaproxy_sp_set_addr_B: 3073 */
+/* function ia_css_dmaproxy_sp_set_addr_B: 30A6 */
 
 /* function debug_buffer_set_ddr_addr: F8 */
 
-/* function receiver_port_reg_load: AB6 */
+/* function receiver_port_reg_load: AE9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_mipi
 #define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_mipi 0x629C
+#define HIVE_ADDR_vbuf_mipi 0x628C
 #define HIVE_SIZE_vbuf_mipi 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_mipi 0x629C
+#define HIVE_ADDR_sp_vbuf_mipi 0x628C
 #define HIVE_SIZE_sp_vbuf_mipi 12
 
-/* function ia_css_event_sp_decode: 327F */
+/* function ia_css_event_sp_decode: 32B2 */
 
-/* function ia_css_queue_get_size: 478E */
+/* function ia_css_queue_get_size: 47C1 */
 
-/* function ia_css_queue_load: 4E59 */
+/* function ia_css_queue_load: 4E8C */
 
-/* function setjmp: 6845 */
+/* function setjmp: 68FD */
 
-/* function __dmaproxy_sp_read_write_text: 318B */
+/* function __dmaproxy_sp_read_write_text: 31BE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_isys_event_queue
 #define HIVE_MEM_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x4664
+#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x4650
 #define HIVE_SIZE_sem_for_sp2host_isys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x4664
+#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x4650
 #define HIVE_SIZE_sp_sem_for_sp2host_isys_event_queue 20
 
-/* function ia_css_dmaproxy_sp_wait_for_ack: 6E6D */
+/* function ia_css_dmaproxy_sp_wait_for_ack: 6F2E */
 
-/* function ia_css_sp_rawcopy_func: 50B8 */
+/* function ia_css_sp_rawcopy_func: 50E0 */
 
-/* function ia_css_tagger_buf_sp_pop_marked: 26E1 */
+/* function ia_css_tagger_buf_sp_pop_marked: 2714 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stage
 #define HIVE_MEM_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stage 0x5B10
+#define HIVE_ADDR_isp_stage 0x5B00
 #define HIVE_SIZE_isp_stage 824
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stage 0x5B10
+#define HIVE_ADDR_sp_isp_stage 0x5B00
 #define HIVE_SIZE_sp_isp_stage 824
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -131,32 +131,32 @@
 #define HIVE_ADDR_sp_vbuf_raw 0x2E0
 #define HIVE_SIZE_sp_vbuf_raw 4
 
-/* function ia_css_sp_bin_copy_func: 4FE0 */
+/* function ia_css_sp_bin_copy_func: 5013 */
 
-/* function ia_css_queue_item_store: 4B2F */
+/* function ia_css_queue_item_store: 4B62 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49D8
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49C4
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49D8
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49C4
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49EC
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49D8
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49EC
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49D8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 
 /* function sp_start_isp: 501 */
@@ -164,83 +164,83 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_binary_group
 #define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_binary_group 0x5EF8
+#define HIVE_ADDR_sp_binary_group 0x5EE8
 #define HIVE_SIZE_sp_binary_group 32
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_binary_group 0x5EF8
+#define HIVE_ADDR_sp_sp_binary_group 0x5EE8
 #define HIVE_SIZE_sp_sp_binary_group 32
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sw_state
 #define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sw_state 0x622C
+#define HIVE_ADDR_sp_sw_state 0x621C
 #define HIVE_SIZE_sp_sw_state 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sw_state 0x622C
+#define HIVE_ADDR_sp_sp_sw_state 0x621C
 #define HIVE_SIZE_sp_sp_sw_state 4
 
-/* function sp_error: 90A */
+/* function sp_error: 93D */
 
-/* function ia_css_thread_sp_main: D76 */
+/* function ia_css_thread_sp_main: DA9 */
 
-/* function ia_css_ispctrl_sp_init_internal_buffers: 34C6 */
+/* function ia_css_ispctrl_sp_init_internal_buffers: 34F9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_psys_event_queue_handle
 #define HIVE_MEM_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x4A8C
+#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x4A78
 #define HIVE_SIZE_sp2host_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x4A8C
+#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x4A78
 #define HIVE_SIZE_sp_sp2host_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_psys_event_queue
 #define HIVE_MEM_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4678
+#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4664
 #define HIVE_SIZE_sem_for_sp2host_psys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4678
+#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4664
 #define HIVE_SIZE_sp_sem_for_sp2host_psys_event_queue 20
 
-/* function ia_css_tagger_sp_propagate_frame: 20CA */
+/* function ia_css_tagger_sp_propagate_frame: 20FD */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_stop_copy_preview
 #define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_stop_copy_preview 0x61D4
+#define HIVE_ADDR_sp_stop_copy_preview 0x61C4
 #define HIVE_SIZE_sp_stop_copy_preview 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_stop_copy_preview 0x61D4
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x61C4
 #define HIVE_SIZE_sp_sp_stop_copy_preview 4
 
-/* function input_system_reg_load: B18 */
+/* function input_system_reg_load: B4B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_handles
 #define HIVE_MEM_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_handles 0x62A8
+#define HIVE_ADDR_vbuf_handles 0x6298
 #define HIVE_SIZE_vbuf_handles 960
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_handles 0x62A8
+#define HIVE_ADDR_sp_vbuf_handles 0x6298
 #define HIVE_SIZE_sp_vbuf_handles 960
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -255,31 +255,31 @@
 #define HIVE_ADDR_sp_max_mm_tracer 0x1B8
 #define HIVE_SIZE_sp_max_mm_tracer 4
 
-/* function ia_css_queue_store: 4CD2 */
+/* function ia_css_queue_store: 4D05 */
 
-/* function ia_css_sp_flash_register: 28BB */
+/* function ia_css_sp_flash_register: 28EE */
 
-/* function ia_css_isys_sp_backend_create: 5B5B */
+/* function ia_css_isys_sp_backend_create: 5C13 */
 
-/* function ia_css_pipeline_sp_init: 17B9 */
+/* function ia_css_pipeline_sp_init: 17EC */
 
-/* function ia_css_tagger_sp_configure: 1FAF */
+/* function ia_css_tagger_sp_configure: 1FE2 */
 
-/* function ia_css_ispctrl_sp_end_binary: 32C9 */
+/* function ia_css_ispctrl_sp_end_binary: 32FC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A98
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A84
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A98
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A84
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 
-/* function receiver_port_reg_store: ABD */
+/* function receiver_port_reg_store: AF0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_is_pending_mask
@@ -296,116 +296,116 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_frame
 #define HIVE_MEM_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_frame 0x468C
+#define HIVE_ADDR_sp_all_cb_elems_frame 0x4678
 #define HIVE_SIZE_sp_all_cb_elems_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x468C
+#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x4678
 #define HIVE_SIZE_sp_sp_all_cb_elems_frame 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_isys_event_queue_handle
 #define HIVE_MEM_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4AAC
+#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4A98
 #define HIVE_SIZE_sp2host_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4AAC
+#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4A98
 #define HIVE_SIZE_sp_sp2host_isys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_com
 #define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_com 0x4130
+#define HIVE_ADDR_host_sp_com 0x411C
 #define HIVE_SIZE_host_sp_com 220
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_com 0x4130
+#define HIVE_ADDR_sp_host_sp_com 0x411C
 #define HIVE_SIZE_sp_host_sp_com 220
 
-/* function ia_css_queue_get_free_space: 48E6 */
+/* function ia_css_queue_get_free_space: 4919 */
 
-/* function exec_image_pipe: 718 */
+/* function exec_image_pipe: 74B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_init_dmem_data
 #define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_init_dmem_data 0x6230
+#define HIVE_ADDR_sp_init_dmem_data 0x6220
 #define HIVE_SIZE_sp_init_dmem_data 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_init_dmem_data 0x6230
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x6220
 #define HIVE_SIZE_sp_sp_init_dmem_data 24
 
-/* function ia_css_sp_metadata_start: 5977 */
+/* function ia_css_sp_metadata_start: 59E7 */
 
-/* function ia_css_tagger_buf_sp_is_marked: 2808 */
+/* function ia_css_tagger_buf_sp_is_marked: 283B */
 
-/* function ia_css_bufq_sp_init_buffer_queues: 293A */
+/* function ia_css_bufq_sp_init_buffer_queues: 296D */
 
-/* function ia_css_pipeline_sp_stop: 179C */
+/* function ia_css_pipeline_sp_stop: 17CF */
 
-/* function ia_css_tagger_sp_connect_pipes: 24DB */
+/* function ia_css_tagger_sp_connect_pipes: 250E */
 
-/* function sp_isys_copy_wait: 761 */
+/* function sp_isys_copy_wait: 794 */
 
 /* function is_isp_debug_buffer_full: 3BC */
 
-/* function ia_css_dmaproxy_sp_configure_channel_from_info: 2FF0 */
+/* function ia_css_dmaproxy_sp_configure_channel_from_info: 3023 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_per_frame_data
 #define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_per_frame_data 0x420C
+#define HIVE_ADDR_sp_per_frame_data 0x41F8
 #define HIVE_SIZE_sp_per_frame_data 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_per_frame_data 0x420C
+#define HIVE_ADDR_sp_sp_per_frame_data 0x41F8
 #define HIVE_SIZE_sp_sp_per_frame_data 4
 
-/* function ia_css_rmgr_sp_vbuf_dequeue: 633F */
+/* function ia_css_rmgr_sp_vbuf_dequeue: 63F7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_psys_event_queue_handle
 #define HIVE_MEM_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4AB8
+#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4AA4
 #define HIVE_SIZE_host2sp_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4AB8
+#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4AA4
 #define HIVE_SIZE_sp_host2sp_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_xmem_bin_addr
 #define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_xmem_bin_addr 0x4210
+#define HIVE_ADDR_xmem_bin_addr 0x41FC
 #define HIVE_SIZE_xmem_bin_addr 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_xmem_bin_addr 0x4210
+#define HIVE_ADDR_sp_xmem_bin_addr 0x41FC
 #define HIVE_SIZE_sp_xmem_bin_addr 4
 
-/* function tmr_clock_init: AA0 */
+/* function tmr_clock_init: AD3 */
 
-/* function ia_css_sp_rawcopy_unlock_buffer: 5610 */
+/* function ia_css_sp_rawcopy_unlock_buffer: 5647 */
 
-/* function ia_css_pipeline_sp_run: 142E */
+/* function ia_css_pipeline_sp_run: 1461 */
 
-/* function memcpy: 68E5 */
+/* function memcpy: 699D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_GP_DEVICE_BASE
@@ -431,51 +431,51 @@
 #define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x1E4
 #define HIVE_SIZE_sp_ia_css_thread_sp_ready_queue 12
 
-/* function input_system_reg_store: B1F */
+/* function input_system_reg_store: B52 */
 
-/* function sp_dma_proxy_set_width_ab: 2E8D */
+/* function sp_dma_proxy_set_width_ab: 2EC0 */
 
-/* function ia_css_isys_sp_frontend_start: 5D85 */
+/* function ia_css_isys_sp_frontend_start: 5E3D */
 
-/* function ia_css_uds_sp_scale_params: 6609 */
+/* function ia_css_uds_sp_scale_params: 66C1 */
 
-/* function ia_css_circbuf_increase_size: E5B */
+/* function ia_css_circbuf_increase_size: E8E */
 
-/* function __divu: 6863 */
+/* function __divu: 691B */
 
-/* function ia_css_thread_sp_get_state: C9E */
+/* function ia_css_thread_sp_get_state: CD1 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_stop
 #define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_stop 0x469C
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x4688
 #define HIVE_SIZE_sem_for_cont_capt_stop 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x469C
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x4688
 #define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
 
-/* function thread_fiber_sp_main: E54 */
+/* function thread_fiber_sp_main: E87 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_pipe_thread
 #define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pipe_thread 0x47E0
+#define HIVE_ADDR_sp_isp_pipe_thread 0x47CC
 #define HIVE_SIZE_sp_isp_pipe_thread 340
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x47E0
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x47CC
 #define HIVE_SIZE_sp_sp_isp_pipe_thread 340
 
-/* function ia_css_parambuf_sp_handle_parameter_sets: 12D1 */
+/* function ia_css_parambuf_sp_handle_parameter_sets: 1304 */
 
-/* function ia_css_spctrl_sp_set_state: 59A6 */
+/* function ia_css_spctrl_sp_set_state: 5A16 */
 
-/* function ia_css_thread_sem_sp_signal: 6ABB */
+/* function ia_css_thread_sem_sp_signal: 6B73 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_IRQ_BASE
@@ -501,13 +501,13 @@
 #define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
 #define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
 
-/* function ia_css_isys_sp_isr: 701E */
+/* function ia_css_isys_sp_isr: 70DF */
 
-/* function ia_css_isys_sp_generate_exp_id: 6137 */
+/* function ia_css_isys_sp_generate_exp_id: 61EF */
 
-/* function ia_css_rmgr_sp_init: 622E */
+/* function ia_css_rmgr_sp_init: 62E6 */
 
-/* function ia_css_thread_sem_sp_init: 6B8E */
+/* function ia_css_thread_sem_sp_init: 6C46 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_is_isp_requested
@@ -524,20 +524,20 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_frame
 #define HIVE_MEM_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frame 0x46B0
+#define HIVE_ADDR_sem_for_reading_cb_frame 0x469C
 #define HIVE_SIZE_sem_for_reading_cb_frame 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x46B0
+#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x469C
 #define HIVE_SIZE_sp_sem_for_reading_cb_frame 40
 
-/* function ia_css_dmaproxy_sp_execute: 2F48 */
+/* function ia_css_dmaproxy_sp_execute: 2F7B */
 
-/* function ia_css_queue_is_empty: 47C9 */
+/* function ia_css_queue_is_empty: 47FC */
 
-/* function ia_css_pipeline_sp_has_stopped: 1792 */
+/* function ia_css_pipeline_sp_has_stopped: 17C5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_verbosity
@@ -551,7 +551,7 @@
 #define HIVE_ADDR_sp_verbosity 0x2680
 #define HIVE_SIZE_sp_verbosity 4
 
-/* function ia_css_circbuf_extract: F69 */
+/* function ia_css_circbuf_extract: F9C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_sp_thread
@@ -565,11 +565,11 @@
 #define HIVE_ADDR_sp_current_sp_thread 0x1E0
 #define HIVE_SIZE_sp_current_sp_thread 4
 
-/* function ia_css_spctrl_sp_get_spid: 59AD */
+/* function ia_css_spctrl_sp_get_spid: 5A1D */
 
-/* function ia_css_dmaproxy_sp_read_byte_addr: 6E9E */
+/* function ia_css_dmaproxy_sp_read_byte_addr: 6F5F */
 
-/* function ia_css_rmgr_sp_uninit: 6227 */
+/* function ia_css_rmgr_sp_uninit: 62DF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack
@@ -595,22 +595,22 @@
 #define HIVE_ADDR_sp_trace_buffer_sp 0x1B4
 #define HIVE_SIZE_sp_trace_buffer_sp 4
 
-/* function ia_css_circbuf_peek: F48 */
+/* function ia_css_circbuf_peek: F7B */
 
-/* function ia_css_parambuf_sp_wait_for_in_param: 107F */
+/* function ia_css_parambuf_sp_wait_for_in_param: 10B2 */
 
-/* function ia_css_isys_sp_token_map_get_exp_id: 5FF2 */
+/* function ia_css_isys_sp_token_map_get_exp_id: 60AA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_param
 #define HIVE_MEM_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_param 0x46D8
+#define HIVE_ADDR_sp_all_cb_elems_param 0x46C4
 #define HIVE_SIZE_sp_all_cb_elems_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x46D8
+#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x46C4
 #define HIVE_SIZE_sp_sp_all_cb_elems_param 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -628,103 +628,103 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame_desc
 #define HIVE_MEM_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame_desc 0x46E8
+#define HIVE_ADDR_sp_all_cbs_frame_desc 0x46D4
 #define HIVE_SIZE_sp_all_cbs_frame_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x46E8
+#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x46D4
 #define HIVE_SIZE_sp_sp_all_cbs_frame_desc 8
 
-/* function sp_isys_copy_func_v2: 75A */
+/* function sp_isys_copy_func_v2: 78D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_param
 #define HIVE_MEM_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_param 0x46F0
+#define HIVE_ADDR_sem_for_reading_cb_param 0x46DC
 #define HIVE_SIZE_sem_for_reading_cb_param 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x46F0
+#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x46DC
 #define HIVE_SIZE_sp_sem_for_reading_cb_param 40
 
-/* function ia_css_queue_get_used_space: 4898 */
+/* function ia_css_queue_get_used_space: 48CB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_start
 #define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_start 0x4718
+#define HIVE_ADDR_sem_for_cont_capt_start 0x4704
 #define HIVE_SIZE_sem_for_cont_capt_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x4718
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x4704
 #define HIVE_SIZE_sp_sem_for_cont_capt_start 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tmp_heap
 #define HIVE_MEM_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_tmp_heap 0x5F18
+#define HIVE_ADDR_tmp_heap 0x5F08
 #define HIVE_SIZE_tmp_heap 640
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tmp_heap 0x5F18
+#define HIVE_ADDR_sp_tmp_heap 0x5F08
 #define HIVE_SIZE_sp_tmp_heap 640
 
-/* function ia_css_tagger_buf_sp_mark: 2894 */
+/* function ia_css_tagger_buf_sp_mark: 28C7 */
 
-/* function ia_css_rmgr_sp_get_num_vbuf: 6544 */
+/* function ia_css_rmgr_sp_get_num_vbuf: 65FC */
 
-/* function ia_css_ispctrl_sp_output_compute_dma_info: 3CDE */
+/* function ia_css_ispctrl_sp_output_compute_dma_info: 3D11 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AC4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AB0
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AC4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AB0
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 
-/* function ia_css_queue_is_full: 4935 */
+/* function ia_css_queue_is_full: 4968 */
 
 /* function debug_buffer_init_isp: 105 */
 
-/* function ia_css_isys_sp_frontend_uninit: 5D36 */
+/* function ia_css_isys_sp_frontend_uninit: 5DEE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem
 #define HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x6668
+#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x6658
 #define HIVE_SIZE_ia_css_rmgr_sp_mipi_frame_sem 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x6668
+#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x6658
 #define HIVE_SIZE_sp_ia_css_rmgr_sp_mipi_frame_sem 60
 
-/* function ia_css_rmgr_sp_refcount_dump: 631A */
+/* function ia_css_rmgr_sp_refcount_dump: 63D2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4B00
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4AEC
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4B00
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4AEC
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -739,59 +739,59 @@
 #define HIVE_ADDR_sp_sp_pipe_threads 0x148
 #define HIVE_SIZE_sp_sp_pipe_threads 20
 
-/* function sp_event_proxy_func: 76F */
+/* function sp_event_proxy_func: 7A2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_isys_event_queue_handle
 #define HIVE_MEM_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4B14
+#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4B00
 #define HIVE_SIZE_host2sp_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4B14
+#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4B00
 #define HIVE_SIZE_sp_host2sp_isys_event_queue_handle 12
 
-/* function ia_css_thread_sp_yield: 6A31 */
+/* function ia_css_thread_sp_yield: 6AE9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param_desc
 #define HIVE_MEM_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param_desc 0x472C
+#define HIVE_ADDR_sp_all_cbs_param_desc 0x4718
 #define HIVE_SIZE_sp_all_cbs_param_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x472C
+#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x4718
 #define HIVE_SIZE_sp_sp_all_cbs_param_desc 8
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb
 #define HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5B04
+#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5AF0
 #define HIVE_SIZE_ia_css_dmaproxy_sp_invalidate_tlb 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5B04
+#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5AF0
 #define HIVE_SIZE_sp_ia_css_dmaproxy_sp_invalidate_tlb 4
 
-/* function ia_css_thread_sp_fork: D2B */
+/* function ia_css_thread_sp_fork: D5E */
 
-/* function ia_css_tagger_sp_destroy: 24E5 */
+/* function ia_css_tagger_sp_destroy: 2518 */
 
-/* function ia_css_dmaproxy_sp_vmem_read: 2ED1 */
+/* function ia_css_dmaproxy_sp_vmem_read: 2F04 */
 
-/* function ia_css_ifmtr_sp_init: 6185 */
+/* function ia_css_ifmtr_sp_init: 623D */
 
-/* function initialize_sp_group: 728 */
+/* function initialize_sp_group: 75B */
 
-/* function ia_css_thread_sp_init: D57 */
+/* function ia_css_thread_sp_init: D8A */
 
-/* function ia_css_ispctrl_sp_set_stream_base_addr: 44D6 */
+/* function ia_css_ispctrl_sp_set_stream_base_addr: 4509 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_DMEM_BASE
@@ -817,7 +817,7 @@
 #define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
 #define HIVE_SIZE_sp_SP_DMEM_BASE 4
 
-/* function ia_css_dmaproxy_sp_read: 2F69 */
+/* function ia_css_dmaproxy_sp_read: 2F9C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_copy_line_count
@@ -834,27 +834,27 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_tag_cmd_queue_handle
 #define HIVE_MEM_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4B20
+#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4B0C
 #define HIVE_SIZE_host2sp_tag_cmd_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4B20
+#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4B0C
 #define HIVE_SIZE_sp_host2sp_tag_cmd_queue_handle 12
 
-/* function ia_css_queue_peek: 480D */
+/* function ia_css_queue_peek: 4840 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_frame_cnt
 #define HIVE_MEM_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x49CC
+#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x49B8
 #define HIVE_SIZE_ia_css_flash_sp_frame_cnt 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x49CC
+#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x49B8
 #define HIVE_SIZE_sp_ia_css_flash_sp_frame_cnt 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -884,26 +884,26 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_thread
 #define HIVE_MEM_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_thread 0x5E48
+#define HIVE_ADDR_isp_thread 0x5E38
 #define HIVE_SIZE_isp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_thread 0x5E48
+#define HIVE_ADDR_sp_isp_thread 0x5E38
 #define HIVE_SIZE_sp_isp_thread 4
 
-/* function encode_and_post_sp_event_non_blocking: A57 */
+/* function encode_and_post_sp_event_non_blocking: A8A */
 
-/* function ia_css_isys_sp_frontend_destroy: 5E1E */
+/* function ia_css_isys_sp_frontend_destroy: 5ED6 */
 
 /* function is_ddr_debug_buffer_full: 33E */
 
-/* function ia_css_isys_sp_frontend_stop: 5D4E */
+/* function ia_css_isys_sp_frontend_stop: 5E06 */
 
-/* function ia_css_isys_sp_token_map_init: 60D2 */
+/* function ia_css_isys_sp_token_map_init: 618A */
 
-/* function sp_dma_proxy_isp_write_addr: 2EE9 */
+/* function sp_dma_proxy_isp_write_addr: 2F1C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_fiber
@@ -917,38 +917,38 @@
 #define HIVE_ADDR_sp_sp_threads_fiber 0x194
 #define HIVE_SIZE_sp_sp_threads_fiber 28
 
-/* function encode_and_post_sp_event: A28 */
+/* function encode_and_post_sp_event: A5B */
 
 /* function debug_enqueue_ddr: 114 */
 
-/* function ia_css_rmgr_sp_refcount_init_vbuf: 62D5 */
+/* function ia_css_rmgr_sp_refcount_init_vbuf: 638D */
 
-/* function dmaproxy_sp_read_write: 6F49 */
+/* function dmaproxy_sp_read_write: 700A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer
 #define HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5B08
+#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5AF4
 #define HIVE_SIZE_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5B08
+#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5AF4
 #define HIVE_SIZE_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 
-/* function ia_css_dmaproxy_sp_ack: 6BB6 */
+/* function ia_css_dmaproxy_sp_ack: 6C6E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_buffer_queue_handle
 #define HIVE_MEM_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4B2C
+#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4B18
 #define HIVE_SIZE_host2sp_buffer_queue_handle 480
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4B2C
+#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4B18
 #define HIVE_SIZE_sp_host2sp_buffer_queue_handle 480
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -963,40 +963,40 @@
 #define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x3214
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_service 4
 
-/* function ia_css_dmaproxy_sp_process: 6BE5 */
+/* function ia_css_dmaproxy_sp_process: 6C9D */
 
-/* function ia_css_isys_sp_backend_rcv_acquire_ack: 5A0A */
+/* function ia_css_isys_sp_backend_rcv_acquire_ack: 5AC2 */
 
-/* function ia_css_isys_sp_backend_pre_acquire_request: 5A20 */
+/* function ia_css_isys_sp_backend_pre_acquire_request: 5AD8 */
 
-/* function ia_css_ispctrl_sp_init_cs: 33CF */
+/* function ia_css_ispctrl_sp_init_cs: 3402 */
 
-/* function ia_css_spctrl_sp_init: 59BB */
+/* function ia_css_spctrl_sp_init: 5A2B */
 
-/* function sp_event_proxy_init: 784 */
+/* function sp_event_proxy_init: 7B7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_output
 #define HIVE_MEM_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_output 0x4214
+#define HIVE_ADDR_sp_output 0x4200
 #define HIVE_SIZE_sp_output 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_output 0x4214
+#define HIVE_ADDR_sp_sp_output 0x4200
 #define HIVE_SIZE_sp_sp_output 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4D0C
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4CF8
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4D0C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4CF8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1023,54 +1023,54 @@
 #define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
 #define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
 
-/* function sp_dma_proxy_reset_channels: 31E3 */
+/* function sp_dma_proxy_reset_channels: 3216 */
 
-/* function ia_css_bufq_set_clock_tick: 2932 */
+/* function ia_css_bufq_set_clock_tick: 2965 */
 
-/* function ia_css_isys_sp_backend_acquire: 5B31 */
+/* function ia_css_isys_sp_backend_acquire: 5BE9 */
 
-/* function ia_css_tagger_sp_update_size: 25E7 */
+/* function ia_css_tagger_sp_update_size: 261A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_host_sp_queue
 #define HIVE_MEM_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x502C
+#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x5018
 #define HIVE_SIZE_ia_css_bufq_host_sp_queue 2008
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x502C
+#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x5018
 #define HIVE_SIZE_sp_ia_css_bufq_host_sp_queue 2008
 
-/* function thread_fiber_sp_create: DC3 */
+/* function thread_fiber_sp_create: DF6 */
 
-/* function ia_css_dmaproxy_sp_set_increments: 305E */
+/* function ia_css_dmaproxy_sp_set_increments: 3091 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_frame
 #define HIVE_MEM_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_frame 0x4734
+#define HIVE_ADDR_sem_for_writing_cb_frame 0x4720
 #define HIVE_SIZE_sem_for_writing_cb_frame 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x4734
+#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x4720
 #define HIVE_SIZE_sp_sem_for_writing_cb_frame 20
 
-/* function receiver_reg_store: ACB */
+/* function receiver_reg_store: AFE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_param
 #define HIVE_MEM_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_param 0x4748
+#define HIVE_ADDR_sem_for_writing_cb_param 0x4734
 #define HIVE_SIZE_sem_for_writing_cb_param 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4748
+#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4734
 #define HIVE_SIZE_sp_sem_for_writing_cb_param 20
 
 /* function sp_start_isp_entry: 4F7 */
@@ -1081,45 +1081,45 @@
 #endif
 #define HIVE_ADDR_sp_sp_start_isp_entry 0x4F7
 
-/* function ia_css_tagger_buf_sp_unmark_all: 282C */
+/* function ia_css_tagger_buf_sp_unmark_all: 285F */
 
-/* function ia_css_dmaproxy_sp_channel_acquire: 3212 */
+/* function ia_css_dmaproxy_sp_channel_acquire: 3245 */
 
-/* function ia_css_rmgr_sp_add_num_vbuf: 6520 */
+/* function ia_css_rmgr_sp_add_num_vbuf: 65D8 */
 
-/* function ia_css_isys_sp_token_map_create: 611E */
+/* function ia_css_isys_sp_token_map_create: 61D6 */
 
-/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 2E84 */
+/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 2EB7 */
 
-/* function ia_css_tagger_buf_sp_push_marked: 2756 */
+/* function ia_css_tagger_buf_sp_push_marked: 2789 */
 
-/* function ia_css_bufq_sp_is_dynamic_buffer: 2CB1 */
+/* function ia_css_bufq_sp_is_dynamic_buffer: 2CE4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_group
 #define HIVE_MEM_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_group 0x4224
+#define HIVE_ADDR_sp_group 0x4210
 #define HIVE_SIZE_sp_group 1084
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_group 0x4224
+#define HIVE_ADDR_sp_sp_group 0x4210
 #define HIVE_SIZE_sp_sp_group 1084
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_event_proxy_thread
 #define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_event_proxy_thread 0x4934
+#define HIVE_ADDR_sp_event_proxy_thread 0x4920
 #define HIVE_SIZE_sp_event_proxy_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_event_proxy_thread 0x4934
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x4920
 #define HIVE_SIZE_sp_sp_event_proxy_thread 68
 
-/* function ia_css_thread_sp_kill: CF1 */
+/* function ia_css_thread_sp_kill: D24 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_cur_loc
@@ -1133,9 +1133,9 @@
 #define HIVE_ADDR_sp_cur_loc 0x2674
 #define HIVE_SIZE_sp_cur_loc 4
 
-/* function ia_css_tagger_sp_create: 259E */
+/* function ia_css_tagger_sp_create: 25D1 */
 
-/* function tmpmem_acquire_dmem: 65D0 */
+/* function tmpmem_acquire_dmem: 6688 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_MMU_BASE
@@ -1149,36 +1149,36 @@
 #define HIVE_ADDR_sp_MMU_BASE 0x24
 #define HIVE_SIZE_sp_MMU_BASE 8
 
-/* function ia_css_dmaproxy_sp_channel_release: 31FB */
+/* function ia_css_dmaproxy_sp_channel_release: 322E */
 
-/* function ia_css_dmaproxy_sp_is_idle: 31CE */
+/* function ia_css_dmaproxy_sp_is_idle: 3201 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_qos_start
 #define HIVE_MEM_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_qos_start 0x475C
+#define HIVE_ADDR_sem_for_qos_start 0x4748
 #define HIVE_SIZE_sem_for_qos_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_qos_start 0x475C
+#define HIVE_ADDR_sp_sem_for_qos_start 0x4748
 #define HIVE_SIZE_sp_sem_for_qos_start 20
 
-/* function isp_hmem_load: B5F */
+/* function isp_hmem_load: B92 */
 
-/* function ia_css_eventq_sp_send: 3257 */
+/* function ia_css_eventq_sp_send: 328A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_error_cnt
 #define HIVE_MEM_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x6254
+#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x6244
 #define HIVE_SIZE_ia_css_isys_sp_error_cnt 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x6254
+#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x6244
 #define HIVE_SIZE_sp_ia_css_isys_sp_error_cnt 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1193,31 +1193,31 @@
 #define HIVE_ADDR_sp_debug_buffer_ddr_address 0xBC
 #define HIVE_SIZE_sp_debug_buffer_ddr_address 4
 
-/* function sp_isys_copy_request: 768 */
+/* function sp_isys_copy_request: 79B */
 
-/* function ia_css_rmgr_sp_refcount_retain_vbuf: 63AF */
+/* function ia_css_rmgr_sp_refcount_retain_vbuf: 6467 */
 
-/* function ia_css_thread_sp_set_priority: CE9 */
+/* function ia_css_thread_sp_set_priority: D1C */
 
-/* function sizeof_hmem: C15 */
+/* function sizeof_hmem: C48 */
 
-/* function tmpmem_release_dmem: 65BD */
+/* function tmpmem_release_dmem: 6675 */
 
 /* function cnd_input_system_cfg: 419 */
 
-/* function __ia_css_sp_rawcopy_func_critical: 6FA7 */
+/* function __ia_css_sp_rawcopy_func_critical: 7068 */
 
-/* function __ia_css_dmaproxy_sp_process_text: 2DC0 */
+/* function __ia_css_dmaproxy_sp_process_text: 2DF3 */
 
-/* function ia_css_dmaproxy_sp_set_width_exception: 3048 */
+/* function ia_css_dmaproxy_sp_set_width_exception: 307B */
 
-/* function ia_css_flash_sp_init_internal_params: 2927 */
+/* function ia_css_flash_sp_init_internal_params: 295A */
 
-/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 260C */
+/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 263F */
 
-/* function __modu: 68A9 */
+/* function __modu: 6961 */
 
-/* function ia_css_dmaproxy_sp_init_isp_vector: 2EA3 */
+/* function ia_css_dmaproxy_sp_init_isp_vector: 2ED6 */
 
 /* function isp_vamem_store: 0 */
 
@@ -1257,22 +1257,22 @@
 #define HIVE_ADDR_sp_GDC_BASE 0x44
 #define HIVE_SIZE_sp_GDC_BASE 8
 
-/* function ia_css_queue_local_init: 4B09 */
+/* function ia_css_queue_local_init: 4B3C */
 
-/* function sp_event_proxy_callout_func: 693B */
+/* function sp_event_proxy_callout_func: 69F3 */
 
-/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 2E6B */
+/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 2E9E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_num_ready_threads
 #define HIVE_MEM_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x49C0
+#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x49AC
 #define HIVE_SIZE_ia_css_thread_sp_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x49C0
+#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x49AC
 #define HIVE_SIZE_sp_ia_css_thread_sp_num_ready_threads 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1287,27 +1287,27 @@
 #define HIVE_ADDR_sp_sp_threads_stack_size 0x178
 #define HIVE_SIZE_sp_sp_threads_stack_size 28
 
-/* function ia_css_ispctrl_sp_isp_done_row_striping: 3CC4 */
+/* function ia_css_ispctrl_sp_isp_done_row_striping: 3CF7 */
 
-/* function __ia_css_isys_sp_isr_text: 5E49 */
+/* function __ia_css_isys_sp_isr_text: 5F01 */
 
-/* function ia_css_queue_dequeue: 497D */
+/* function ia_css_queue_dequeue: 49B0 */
 
-/* function ia_css_dmaproxy_sp_configure_channel: 6EB5 */
+/* function ia_css_dmaproxy_sp_configure_channel: 6F76 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_thread_fiber_sp
 #define HIVE_MEM_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_current_thread_fiber_sp 0x49C8
+#define HIVE_ADDR_current_thread_fiber_sp 0x49B4
 #define HIVE_SIZE_current_thread_fiber_sp 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_thread_fiber_sp 0x49C8
+#define HIVE_ADDR_sp_current_thread_fiber_sp 0x49B4
 #define HIVE_SIZE_sp_current_thread_fiber_sp 4
 
-/* function ia_css_circbuf_pop: 1001 */
+/* function ia_css_circbuf_pop: 1034 */
 
 /* function irq_raise_set_token: C1 */
 
@@ -1323,81 +1323,81 @@
 #define HIVE_ADDR_sp_GPIO_BASE 0x3C
 #define HIVE_SIZE_sp_GPIO_BASE 4
 
-/* function ia_css_pipeline_acc_stage_enable: 1772 */
+/* function ia_css_pipeline_acc_stage_enable: 17A5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_ph
 #define HIVE_MEM_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_ph 0x6264
+#define HIVE_ADDR_isp_ph 0x6254
 #define HIVE_SIZE_isp_ph 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_ph 0x6264
+#define HIVE_ADDR_sp_isp_ph 0x6254
 #define HIVE_SIZE_sp_isp_ph 28
 
-/* function ia_css_isys_sp_token_map_flush: 605B */
+/* function ia_css_isys_sp_token_map_flush: 6113 */
 
-/* function ia_css_ispctrl_sp_init_ds: 356D */
+/* function ia_css_ispctrl_sp_init_ds: 35A0 */
 
-/* function get_xmem_base_addr_raw: 3927 */
+/* function get_xmem_base_addr_raw: 395A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param
 #define HIVE_MEM_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param 0x4770
+#define HIVE_ADDR_sp_all_cbs_param 0x475C
 #define HIVE_SIZE_sp_all_cbs_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param 0x4770
+#define HIVE_ADDR_sp_sp_all_cbs_param 0x475C
 #define HIVE_SIZE_sp_sp_all_cbs_param 16
 
-/* function ia_css_circbuf_create: 1052 */
+/* function ia_css_circbuf_create: 1085 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp_group
 #define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp_group 0x4780
+#define HIVE_ADDR_sem_for_sp_group 0x476C
 #define HIVE_SIZE_sem_for_sp_group 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp_group 0x4780
+#define HIVE_ADDR_sp_sem_for_sp_group 0x476C
 #define HIVE_SIZE_sp_sem_for_sp_group 20
 
-/* function ia_css_framebuf_sp_wait_for_in_frame: 654B */
+/* function ia_css_framebuf_sp_wait_for_in_frame: 6603 */
 
-/* function ia_css_tagger_buf_sp_push_unmarked: 267F */
+/* function ia_css_tagger_buf_sp_push_unmarked: 26B2 */
 
-/* function isp_hmem_clear: B26 */
+/* function isp_hmem_clear: B59 */
 
-/* function ia_css_framebuf_sp_release_in_frame: 658E */
+/* function ia_css_framebuf_sp_release_in_frame: 6646 */
 
-/* function ia_css_isys_sp_backend_snd_acquire_request: 5A83 */
+/* function ia_css_isys_sp_backend_snd_acquire_request: 5B3B */
 
-/* function ia_css_isys_sp_token_map_is_full: 5ED0 */
+/* function ia_css_isys_sp_token_map_is_full: 5F88 */
 
-/* function input_system_acquisition_run: AF4 */
+/* function input_system_acquisition_run: B27 */
 
-/* function ia_css_ispctrl_sp_start_binary: 33AD */
+/* function ia_css_ispctrl_sp_start_binary: 33E0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x5804
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x57F0
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x5804
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x57F0
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 
-/* function ia_css_eventq_sp_recv: 3229 */
+/* function ia_css_eventq_sp_recv: 325C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_pool
@@ -1411,9 +1411,9 @@
 #define HIVE_ADDR_sp_isp_pool 0x2D4
 #define HIVE_SIZE_sp_isp_pool 4
 
-/* function ia_css_rmgr_sp_rel_gen: 6270 */
+/* function ia_css_rmgr_sp_rel_gen: 6328 */
 
-/* function css_get_frame_processing_time_end: 1F41 */
+/* function css_get_frame_processing_time_end: 1F74 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_any_pending_mask
@@ -1427,13 +1427,13 @@
 #define HIVE_ADDR_sp_event_any_pending_mask 0x2F0
 #define HIVE_SIZE_sp_event_any_pending_mask 8
 
-/* function ia_css_isys_sp_backend_push: 5A34 */
+/* function ia_css_isys_sp_backend_push: 5AEC */
 
 /* function sh_css_decode_tag_descr: 3D7 */
 
 /* function debug_enqueue_isp: 2E9 */
 
-/* function ia_css_spctrl_sp_uninit: 59B4 */
+/* function ia_css_spctrl_sp_uninit: 5A24 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SWITCH_CODE
@@ -1450,30 +1450,30 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x5818
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x5804
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_dis_bufs 140
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x5818
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x5804
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_dis_bufs 140
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_isp_idle
 #define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_isp_idle 0x4794
+#define HIVE_ADDR_sem_for_isp_idle 0x4780
 #define HIVE_SIZE_sem_for_isp_idle 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_isp_idle 0x4794
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x4780
 #define HIVE_SIZE_sp_sem_for_isp_idle 20
 
-/* function ia_css_dmaproxy_sp_write_byte_addr: 2F17 */
+/* function ia_css_dmaproxy_sp_write_byte_addr: 2F4A */
 
-/* function ia_css_dmaproxy_sp_init: 2E3D */
+/* function ia_css_dmaproxy_sp_init: 2E70 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_VAMEM_BASE
@@ -1490,46 +1490,46 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rawcopy_sp_tagger
 #define HIVE_MEM_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x61D8
+#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x61C8
 #define HIVE_SIZE_ia_css_rawcopy_sp_tagger 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x61D8
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x61C8
 #define HIVE_SIZE_sp_ia_css_rawcopy_sp_tagger 24
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x58A4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x5890
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_exp_ids 70
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x58A4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x5890
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_exp_ids 70
 
-/* function ia_css_queue_item_load: 4C1E */
+/* function ia_css_queue_item_load: 4C51 */
 
-/* function ia_css_spctrl_sp_get_state: 599F */
+/* function ia_css_spctrl_sp_get_state: 5A0F */
 
-/* function ia_css_isys_sp_token_map_uninit: 607A */
+/* function ia_css_isys_sp_token_map_uninit: 6132 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_callout_sp_thread
 #define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_callout_sp_thread 0x49BC
+#define HIVE_ADDR_callout_sp_thread 0x49A8
 #define HIVE_SIZE_callout_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_callout_sp_thread 0x49BC
+#define HIVE_ADDR_sp_callout_sp_thread 0x49A8
 #define HIVE_SIZE_sp_callout_sp_thread 4
 
-/* function thread_fiber_sp_init: E4A */
+/* function thread_fiber_sp_init: E7D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_SP_PMEM_BASE
@@ -1543,31 +1543,31 @@
 #define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
 #define HIVE_SIZE_sp_SP_PMEM_BASE 4
 
-/* function ia_css_isys_sp_token_map_snd_acquire_req: 5FD9 */
+/* function ia_css_isys_sp_token_map_snd_acquire_req: 6091 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_input_stream_format
 #define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_input_stream_format 0x3FF8
+#define HIVE_ADDR_sp_isp_input_stream_format 0x3FE4
 #define HIVE_SIZE_sp_isp_input_stream_format 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3FF8
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3FE4
 #define HIVE_SIZE_sp_sp_isp_input_stream_format 20
 
-/* function __mod: 6895 */
+/* function __mod: 694D */
 
-/* function ia_css_dmaproxy_sp_init_dmem_channel: 2F83 */
+/* function ia_css_dmaproxy_sp_init_dmem_channel: 2FB6 */
 
-/* function ia_css_thread_sp_join: D1A */
+/* function ia_css_thread_sp_join: D4D */
 
-/* function ia_css_dmaproxy_sp_add_command: 6F8B */
+/* function ia_css_dmaproxy_sp_add_command: 704C */
 
-/* function ia_css_sp_metadata_thread_func: 5815 */
+/* function ia_css_sp_metadata_thread_func: 5885 */
 
-/* function __sp_event_proxy_func_critical: 6928 */
+/* function __sp_event_proxy_func_critical: 69E0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_dmaproxy_sp_proxy_status
@@ -1581,27 +1581,29 @@
 #define HIVE_ADDR_sp_dmaproxy_sp_proxy_status 0x208
 #define HIVE_SIZE_sp_dmaproxy_sp_proxy_status 4
 
-/* function ia_css_sp_metadata_wait: 5966 */
+/* function ia_css_sp_metadata_wait: 59D6 */
 
-/* function ia_css_circbuf_peek_from_start: F27 */
+/* function ia_css_circbuf_peek_from_start: F5A */
 
-/* function ia_css_sp_rawcopy_buffer_is_locked: 56B0 */
+/* function ia_css_sp_rawcopy_buffer_is_locked: 56D4 */
 
-/* function ia_css_event_sp_encode: 32B5 */
+/* function ia_css_event_sp_encode: 32E8 */
 
-/* function ia_css_thread_sp_run: D8D */
+/* function ia_css_thread_sp_run: DC0 */
 
-/* function sp_isys_copy_func: 74A */
+/* function sp_isys_copy_func: 77D */
 
-/* function ia_css_isys_sp_backend_flush: 5AA3 */
+/* function ia_css_isys_sp_backend_flush: 5B5B */
 
-/* function ia_css_sp_isp_param_init_isp_memories: 4658 */
+/* function ia_css_isys_sp_backend_frame_exists: 5A7A */
 
-/* function register_isr: 8CE */
+/* function ia_css_sp_isp_param_init_isp_memories: 468B */
+
+/* function register_isr: 901 */
 
 /* function irq_raise: D3 */
 
-/* function ia_css_dmaproxy_sp_mmu_invalidate: 2D7B */
+/* function ia_css_dmaproxy_sp_mmu_invalidate: 2DAE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SRST_ADDRESS
@@ -1615,27 +1617,27 @@
 #define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x1BC
 #define HIVE_SIZE_sp_HIVE_IF_SRST_ADDRESS 16
 
-/* function pipeline_sp_initialize_stage: 1891 */
+/* function pipeline_sp_initialize_stage: 18C4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_frontend_states
 #define HIVE_MEM_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x6248
+#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x6238
 #define HIVE_SIZE_ia_css_isys_sp_frontend_states 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x6248
+#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x6238
 #define HIVE_SIZE_sp_ia_css_isys_sp_frontend_states 12
 
-/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6E87 */
+/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6F48 */
 
-/* function ia_css_ispctrl_sp_done_ds: 3550 */
+/* function ia_css_ispctrl_sp_done_ds: 3583 */
 
-/* function ia_css_sp_isp_param_get_mem_inits: 4633 */
+/* function ia_css_sp_isp_param_get_mem_inits: 4666 */
 
-/* function ia_css_parambuf_sp_init_buffer_queues: 1416 */
+/* function ia_css_parambuf_sp_init_buffer_queues: 1449 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_pfp_spref
@@ -1649,7 +1651,7 @@
 #define HIVE_ADDR_sp_vbuf_pfp_spref 0x2DC
 #define HIVE_SIZE_sp_vbuf_pfp_spref 4
 
-/* function input_system_cfg: AAF */
+/* function input_system_cfg: AE2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_HMEM_BASE
@@ -1666,148 +1668,148 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_frames
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x58EC
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x58D8
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_frames 280
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x58EC
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x58D8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_frames 280
 
-/* function ia_css_isys_sp_backend_release: 5B18 */
+/* function ia_css_isys_sp_backend_release: 5BD0 */
 
-/* function ia_css_isys_sp_backend_destroy: 5B42 */
+/* function ia_css_isys_sp_backend_destroy: 5BFA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_buffer_queue_handle
 #define HIVE_MEM_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_buffer_queue_handle 0x5A04
+#define HIVE_ADDR_sp2host_buffer_queue_handle 0x59F0
 #define HIVE_SIZE_sp2host_buffer_queue_handle 96
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x5A04
+#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x59F0
 #define HIVE_SIZE_sp_sp2host_buffer_queue_handle 96
 
-/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 5F9D */
+/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 6055 */
 
-/* function ia_css_ispctrl_sp_init_isp_vars: 4339 */
+/* function ia_css_ispctrl_sp_init_isp_vars: 436C */
 
-/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 5B95 */
+/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 5C4D */
 
-/* function sp_warning: 8E3 */
+/* function sp_warning: 916 */
 
-/* function ia_css_rmgr_sp_vbuf_enqueue: 636F */
+/* function ia_css_rmgr_sp_vbuf_enqueue: 6427 */
 
-/* function ia_css_tagger_sp_tag_exp_id: 1F53 */
+/* function ia_css_tagger_sp_tag_exp_id: 1F86 */
 
-/* function ia_css_dmaproxy_sp_write: 2F2E */
+/* function ia_css_dmaproxy_sp_write: 2F61 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_buff_pool_lock_params_handles
 #define HIVE_MEM_raw_buff_pool_lock_params_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_buff_pool_lock_params_handles 0x61F0
+#define HIVE_ADDR_raw_buff_pool_lock_params_handles 0x61E0
 #define HIVE_SIZE_raw_buff_pool_lock_params_handles 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_buff_pool_lock_params_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_buff_pool_lock_params_handles 0x61F0
+#define HIVE_ADDR_sp_raw_buff_pool_lock_params_handles 0x61E0
 #define HIVE_SIZE_sp_raw_buff_pool_lock_params_handles 60
 
-/* function ia_css_parambuf_sp_release_in_param: 1296 */
+/* function ia_css_parambuf_sp_release_in_param: 12C9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_irq_sw_interrupt_token
 #define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_irq_sw_interrupt_token 0x3FF4
+#define HIVE_ADDR_irq_sw_interrupt_token 0x3FE0
 #define HIVE_SIZE_irq_sw_interrupt_token 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3FF4
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3FE0
 #define HIVE_SIZE_sp_irq_sw_interrupt_token 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_addresses
 #define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_addresses 0x5E4C
+#define HIVE_ADDR_sp_isp_addresses 0x5E3C
 #define HIVE_SIZE_sp_isp_addresses 172
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_addresses 0x5E4C
+#define HIVE_ADDR_sp_sp_isp_addresses 0x5E3C
 #define HIVE_SIZE_sp_sp_isp_addresses 172
 
-/* function ia_css_rmgr_sp_acq_gen: 6294 */
+/* function ia_css_rmgr_sp_acq_gen: 634C */
 
-/* function receiver_reg_load: AC4 */
+/* function receiver_reg_load: AF7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isps
 #define HIVE_MEM_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_isps 0x6280
+#define HIVE_ADDR_isps 0x6270
 #define HIVE_SIZE_isps 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isps 0x6280
+#define HIVE_ADDR_sp_isps 0x6270
 #define HIVE_SIZE_sp_isps 28
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_queues_initialized
 #define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_queues_initialized 0x400C
+#define HIVE_ADDR_host_sp_queues_initialized 0x3FF8
 #define HIVE_SIZE_host_sp_queues_initialized 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_queues_initialized 0x400C
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3FF8
 #define HIVE_SIZE_sp_host_sp_queues_initialized 4
 
-/* function ia_css_queue_uninit: 4AC7 */
+/* function ia_css_queue_uninit: 4AFA */
 
-/* function ia_css_tagger_buf_sp_is_locked: 27C4 */
+/* function ia_css_tagger_buf_sp_is_locked: 27F7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_ispctrl_sp_isp_started
 #define HIVE_MEM_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5B0C
+#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5AF8
 #define HIVE_SIZE_ia_css_ispctrl_sp_isp_started 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5B0C
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5AF8
 #define HIVE_SIZE_sp_ia_css_ispctrl_sp_isp_started 4
 
-/* function ia_css_bufq_sp_release_dynamic_buf: 29C2 */
+/* function ia_css_bufq_sp_release_dynamic_buf: 29F5 */
 
-/* function ia_css_sp_metadata_thread_terminate: 594E */
+/* function ia_css_sp_metadata_thread_terminate: 59BE */
 
-/* function ia_css_dmaproxy_sp_set_height_exception: 3036 */
+/* function ia_css_dmaproxy_sp_set_height_exception: 3069 */
 
-/* function ia_css_dmaproxy_sp_init_vmem_channel: 2FB9 */
+/* function ia_css_dmaproxy_sp_init_vmem_channel: 2FEC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_num_ready_threads
 #define HIVE_MEM_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_num_ready_threads 0x49C4
+#define HIVE_ADDR_num_ready_threads 0x49B0
 #define HIVE_SIZE_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_num_ready_threads 0x49C4
+#define HIVE_ADDR_sp_num_ready_threads 0x49B0
 #define HIVE_SIZE_sp_num_ready_threads 4
 
-/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 2F00 */
+/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 2F33 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_spref
@@ -1824,54 +1826,54 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_metadata_thread
 #define HIVE_MEM_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_metadata_thread 0x4978
+#define HIVE_ADDR_sp_metadata_thread 0x4964
 #define HIVE_SIZE_sp_metadata_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_metadata_thread 0x4978
+#define HIVE_ADDR_sp_sp_metadata_thread 0x4964
 #define HIVE_SIZE_sp_sp_metadata_thread 68
 
-/* function ia_css_queue_enqueue: 4A07 */
+/* function ia_css_queue_enqueue: 4A3A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_request
 #define HIVE_MEM_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_request 0x49D0
+#define HIVE_ADDR_ia_css_flash_sp_request 0x49BC
 #define HIVE_SIZE_ia_css_flash_sp_request 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x49D0
+#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x49BC
 #define HIVE_SIZE_sp_ia_css_flash_sp_request 4
 
-/* function ia_css_dmaproxy_sp_vmem_write: 2EBA */
+/* function ia_css_dmaproxy_sp_vmem_write: 2EED */
 
-/* function ia_css_tagger_buf_sp_unmark: 286D */
+/* function ia_css_tagger_buf_sp_unmark: 28A0 */
 
-/* function ia_css_isys_sp_token_map_snd_capture_req: 5FFF */
+/* function ia_css_isys_sp_token_map_snd_capture_req: 60B7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_if
 #define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_if 0x47A8
+#define HIVE_ADDR_sem_for_reading_if 0x4794
 #define HIVE_SIZE_sem_for_reading_if 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_if 0x47A8
+#define HIVE_ADDR_sp_sem_for_reading_if 0x4794
 #define HIVE_SIZE_sp_sem_for_reading_if 20
 
-/* function sp_generate_interrupts: 985 */
+/* function sp_generate_interrupts: 9B8 */
 
-/* function ia_css_pipeline_sp_start: 17A4 */
+/* function ia_css_pipeline_sp_start: 17D7 */
 
-/* function ia_css_sp_rawcopy_init: 50A2 */
+/* function ia_css_sp_rawcopy_init: 50D5 */
 
-/* function tmr_clock_read: A96 */
+/* function tmr_clock_read: AC9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_BAMEM_BASE
@@ -1885,65 +1887,65 @@
 #define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x2E8
 #define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
 
-/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5C4D */
+/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5D05 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A64
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A50
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A64
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A50
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_mem_map
 #define HIVE_MEM_mem_map scalar_processor_2400_dmem
-#define HIVE_ADDR_mem_map 0x4010
+#define HIVE_ADDR_mem_map 0x3FFC
 #define HIVE_SIZE_mem_map 284
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_mem_map scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_mem_map 0x4010
+#define HIVE_ADDR_sp_mem_map 0x3FFC
 #define HIVE_SIZE_sp_mem_map 284
 
-/* function css_get_frame_processing_time_start: 1F4A */
+/* function css_get_frame_processing_time_start: 1F7D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame
 #define HIVE_MEM_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame 0x47BC
+#define HIVE_ADDR_sp_all_cbs_frame 0x47A8
 #define HIVE_SIZE_sp_all_cbs_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame 0x47BC
+#define HIVE_ADDR_sp_sp_all_cbs_frame 0x47A8
 #define HIVE_SIZE_sp_sp_all_cbs_frame 16
 
-/* function thread_sp_queue_print: DAA */
+/* function thread_sp_queue_print: DDD */
 
-/* function sp_notify_eof: 931 */
+/* function sp_notify_eof: 964 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_str2mem
 #define HIVE_MEM_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_str2mem 0x47CC
+#define HIVE_ADDR_sem_for_str2mem 0x47B8
 #define HIVE_SIZE_sem_for_str2mem 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_str2mem 0x47CC
+#define HIVE_ADDR_sp_sem_for_str2mem 0x47B8
 #define HIVE_SIZE_sp_sem_for_str2mem 20
 
-/* function ia_css_bufq_sp_acquire_dynamic_buf: 2BCF */
+/* function ia_css_bufq_sp_acquire_dynamic_buf: 2C02 */
 
-/* function ia_css_circbuf_destroy: 1049 */
+/* function ia_css_circbuf_destroy: 107C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_PMEM_BASE
@@ -1957,38 +1959,38 @@
 #define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
 #define HIVE_SIZE_sp_ISP_PMEM_BASE 4
 
-/* function ia_css_sp_isp_param_mem_load: 45BB */
+/* function ia_css_sp_isp_param_mem_load: 45EE */
 
-/* function __div: 684D */
+/* function __div: 6905 */
 
-/* function ia_css_isys_sp_frontend_create: 5E2F */
+/* function ia_css_isys_sp_frontend_create: 5EE7 */
 
-/* function ia_css_rmgr_sp_refcount_release_vbuf: 638E */
+/* function ia_css_rmgr_sp_refcount_release_vbuf: 6446 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_in_use
 #define HIVE_MEM_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_in_use 0x49D4
+#define HIVE_ADDR_ia_css_flash_sp_in_use 0x49C0
 #define HIVE_SIZE_ia_css_flash_sp_in_use 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x49D4
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x49C0
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_use 4
 
-/* function ia_css_thread_sem_sp_wait: 6B06 */
+/* function ia_css_thread_sem_sp_wait: 6BBE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sleep_mode
 #define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sleep_mode 0x412C
+#define HIVE_ADDR_sp_sleep_mode 0x4118
 #define HIVE_SIZE_sp_sleep_mode 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sleep_mode 0x412C
+#define HIVE_ADDR_sp_sp_sleep_mode 0x4118
 #define HIVE_SIZE_sp_sp_sleep_mode 4
 
 /* function mmu_invalidate_cache: EA */
@@ -2005,27 +2007,23 @@
 #define HIVE_ADDR_sp_sp_max_cb_elems 0x140
 #define HIVE_SIZE_sp_sp_max_cb_elems 8
 
-/* function ia_css_dmaproxy_sp_register_channel_to_port: 2E78 */
+/* function ia_css_dmaproxy_sp_register_channel_to_port: 2EAB */
 
-/* function ia_css_queue_remote_init: 4AE9 */
+/* function ia_css_queue_remote_init: 4B1C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stop_req
 #define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stop_req 0x4660
+#define HIVE_ADDR_isp_stop_req 0x464C
 #define HIVE_SIZE_isp_stop_req 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stop_req 0x4660
+#define HIVE_ADDR_sp_isp_stop_req 0x464C
 #define HIVE_SIZE_sp_isp_stop_req 4
 
 #define HIVE_ICACHE_sp_critical_SEGMENT_START 0
 #define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
 
 #endif /* _sp_map_h_ */
-extern void sh_css_dump_sp_dmem(void);
-void sh_css_dump_sp_dmem(void)
-{
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/refcount/src/refcount.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/refcount/src/refcount.c
index 11f8603..9fe9b48 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/refcount/src/refcount.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/refcount/src/refcount.c
@@ -49,8 +49,13 @@ static struct ia_css_refcount_entry *refcount_find_entry(hrt_vaddress ptr,
 {
 	uint32_t i;
 
-	assert(ptr != 0);
-	assert(myrefcount.items != NULL);
+	if (ptr == 0)
+		return NULL;
+	if (myrefcount.items == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "refcount_find_entry(): Ref count not initiliazed!\n");
+		return NULL;
+	}
 
 	for (i = 0; i < myrefcount.size; i++) {
 
@@ -72,9 +77,16 @@ enum ia_css_err ia_css_refcount_init(uint32_t size)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	assert(size != 0);
-	assert(myrefcount.items == NULL);
-
+	if (size == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "ia_css_refcount_init(): Size of 0 for Ref count init!\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (myrefcount.items != NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "ia_css_refcount_init(): Ref count is already initialized\n");
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 	myrefcount.items =
 	    sh_css_malloc(sizeof(struct ia_css_refcount_entry) * size);
 	if (!myrefcount.items)
@@ -136,7 +148,11 @@ hrt_vaddress ia_css_refcount_increment(int32_t id, hrt_vaddress ptr)
 		entry->id = id;
 	}
 
-	assert(entry->id == id);
+	if (entry->id != id) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+			    "ia_css_refcount_increment(): Ref count IDS do not match!\n");
+		return mmgr_NULL;
+	}
 
 	if (entry->data == ptr)
 		entry->count += 1;
@@ -162,7 +178,11 @@ bool ia_css_refcount_decrement(int32_t id, hrt_vaddress ptr)
 	entry = refcount_find_entry(ptr, false);
 
 	if (entry) {
-		assert(entry->id == id);
+		if (entry->id != id) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+					    "ia_css_refcount_decrement(): Ref count IDS do not match!\n");
+			return false;
+		}
 		if (entry->count > 0) {
 			entry->count -= 1;
 			if (entry->count == 0) {
@@ -234,6 +254,8 @@ void ia_css_refcount_clear(int32_t id, clear_func clear_func_ptr)
 				mmgr_free(entry->data);
 			}
 			assert(entry->count == 0);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+					    "ia_css_refcount_clear(): Ref count for entry %x is not zero!\n", entry->id);
 			entry->data = mmgr_NULL;
 			entry->count = 0;
 			entry->id = 0;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c
index 243b120..3c708ef 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c
@@ -533,7 +533,8 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	pipe_binarydesc_get_offline(pipe,
 			       IA_CSS_BINARY_MODE_CAPTURE_PP,
 			       yuv_scaler_descr,
-			       NULL, in_info, out_infos, vf_info);
+			       NULL, in_info, out_infos,
+			       (vf_info->res.width == 0 && vf_info->res.height == 0) ? NULL : vf_info);
 
 	yuv_scaler_descr->enable_fractional_ds = true;
 	IA_CSS_LEAVE_PRIVATE("");
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/isp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/isp.c
index 3c7b86b..d2cb159 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/isp.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/isp.c
@@ -19,6 +19,7 @@
  *
  */
 
+#include <system_global.h>
 #include "isp.h"
 
 #ifndef __INLINE_ISP__
@@ -26,6 +27,7 @@
 #endif /* __INLINE_ISP__ */
 
 #include "assert_support.h"
+#include "platform_support.h"			/* hrt_sleep() */
 
 void cnd_isp_irq_enable(
 	const isp_ID_t		ID,
@@ -52,6 +54,12 @@ void isp_get_state(
 	assert(state != NULL);
 	assert(stall != NULL);
 
+#if defined(_hrt_sysmem_ident_address)
+	/* Patch to avoid compiler unused symbol warning in C_RUN build */
+	(void)__hrt_sysmem_ident_address;
+	(void)_hrt_sysmem_map_var;
+#endif
+
 	state->pc = isp_ctrl_load(ID, ISP_PC_REG);
 	state->status_register = sc;
 	state->is_broken = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_BROKEN_BIT);
@@ -95,3 +103,53 @@ void isp_get_state(
  */
 return;
 }
+
+/* ISP functions to control the ISP state from the host, even in crun. */
+#ifdef C_RUN
+volatile uint32_t isp_sleeping[N_ISP_ID] = { 0 }; /* Sleeping state per ISP */
+volatile uint32_t isp_ready   [N_ISP_ID] = { 1 }; /* Ready state per ISP */
+#endif
+
+/* Inspect readiness of an ISP indexed by ID */
+unsigned isp_is_ready(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	return isp_ready[ID];
+#else
+	return isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);
+#endif
+}
+
+/* Inspect sleeping of an ISP indexed by ID */
+unsigned isp_is_sleeping(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	return isp_sleeping[ID];
+#else
+	return isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);
+#endif
+}
+
+/* To be called by the host immediately before starting ISP ID. */
+void isp_start(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	isp_ready[ID] = 0;
+#endif
+}
+
+/* Wake up ISP ID. */
+void isp_wake(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	isp_sleeping[ID] = 0;
+#else
+	isp_ctrl_setbit(ID, ISP_SC_REG, ISP_START_BIT);
+	hrt_sleep();
+#endif
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/vmem.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/vmem.c
index 66aea95d..cf64acf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/vmem.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/vmem.c
@@ -27,6 +27,7 @@
 #include "ia_css_device_access.h"
 #endif
 #include "assert_support.h"
+#include "platform_support.h"			/* hrt_sleep() */
 
 typedef unsigned long long hive_uedge;
 typedef hive_uedge *hive_wide;
@@ -34,10 +35,10 @@ typedef hive_uedge *hive_wide;
 /* Copied from SDK: sim_semantics.c */
 
 /* subword bits move like this:         MSB[____xxxx____]LSB -> MSB[00000000xxxx]LSB */
-#define SUBWORD(w, start, end)     ((w & (((1ULL << (end-1))-1) << 1 | 1)) >> (start))
+#define SUBWORD(w, start, end)     (((w) & (((1ULL << ((end)-1))-1) << 1 | 1)) >> (start))
 
 /* inverse subword bits move like this: MSB[xxxx____xxxx]LSB -> MSB[xxxx0000xxxx]LSB */
-#define INV_SUBWORD(w, start, end) (w & (~(((1ULL << (end-1))-1) << 1 | 1) | ((1ULL << (start))-1)) )
+#define INV_SUBWORD(w, start, end) ((w) & (~(((1ULL << ((end)-1))-1) << 1 | 1) | ((1ULL << (start))-1)) )
 
 #define uedge_bits (8*sizeof(hive_uedge))
 #define move_lower_bits(target, target_bit, src, src_bit) move_subword(target, target_bit, src, 0, src_bit)
@@ -116,9 +117,9 @@ hive_sim_wide_pack(
 	if (elem_bits == uedge_bits) {
 		vector[start_elem] = elem[0];
 	} else if (elem_bits > uedge_bits) {
-		int bits_to_write = elem_bits;
-		int start_bit = elem_bits * index;
-		int i = 0;
+		unsigned bits_to_write = elem_bits;
+		unsigned start_bit = elem_bits * index;
+		unsigned i = 0;
 		for(; bits_to_write > uedge_bits; bits_to_write -= uedge_bits, i++, start_bit += uedge_bits) {
 			move_word(vector, start_bit, elem[i]);
 		}
@@ -135,11 +136,11 @@ static void load_vector (
 	const t_vmem_elem	*from)
 {
 	unsigned i;
-	unsigned size = sizeof(short)*ISP_NWAY;
 #ifdef C_RUN
 	hive_uedge *data = (hive_uedge *)from;
 	(void)ID;
 #else
+	unsigned size = sizeof(short)*ISP_NWAY;
 	VMEM_ARRAY(v, 2*ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
 	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
@@ -163,19 +164,19 @@ static void store_vector (
 	const t_vmem_elem	*from)
 {
 	unsigned i;
-	unsigned size = sizeof(short)*ISP_NWAY;
 #ifdef C_RUN
 	hive_uedge *data = (hive_uedge *)to;
 	(void)ID;
 	for (i = 0; i < ISP_NWAY; i++) {
-		hive_sim_wide_pack(data, &from[i], ISP_VEC_ELEMBITS, i);
+		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);
 	}
 #else
+	unsigned size = sizeof(short)*ISP_NWAY;
 	VMEM_ARRAY(v, 2*ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
 	//load_vector (&v[1][0], &to[ISP_NWAY]); /* Fetch the next vector, since it will be overwritten. */
 	hive_uedge *data = (hive_uedge *)v;
 	for (i = 0; i < ISP_NWAY; i++) {
-		hive_sim_wide_pack(data, &from[i], ISP_VEC_ELEMBITS, i);
+		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);
 	}
 	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/isp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/isp_global.h
index ea913be..40870e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/isp_global.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/isp_global.h
@@ -46,22 +46,23 @@
 #define ISP_VEC_BYTES			(ISP_VEC_NELEMS*sizeof(uint16_t))
 
 /* ISP SC Registers */
-#define ISP_SC_REG				0x00
-#define ISP_PC_REG				0x07
+#define ISP_SC_REG			0x00
+#define ISP_PC_REG			0x07
 #define ISP_IRQ_READY_REG		0x00
 #define ISP_IRQ_CLEAR_REG		0x00
 
 /* ISP SC Register bits */
-#define ISP_RST_BIT				0x00
+#define ISP_RST_BIT			0x00
 #define ISP_START_BIT			0x01
 #define ISP_BREAK_BIT			0x02
-#define ISP_RUN_BIT				0x03
+#define ISP_RUN_BIT			0x03
 #define ISP_BROKEN_BIT			0x04
 #define ISP_IDLE_BIT			0x05     /* READY */
+#define ISP_SLEEPING_BIT		0x06
 #define ISP_STALLING_BIT		0x07
 #define ISP_IRQ_CLEAR_BIT		0x08
 #define ISP_IRQ_READY_BIT		0x0A
-#define ISP_SLEEPING_BIT		0x0B     /* SLEEPING_IRQ_MASK */
+#define ISP_IRQ_SLEEPING_BIT		0x0B
 
 /* ISP Register bits */
 #define ISP_CTRL_SINK_BIT		0x00
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/sp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/sp_global.h
index a8fdad2..64e4b0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/sp_global.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/sp_global.h
@@ -52,16 +52,17 @@
 #define SP_CTRL_SINK_REG		0x0A
 
 /* SP Register bits */
-#define SP_RST_BIT				0x00
+#define SP_RST_BIT			0x00
 #define SP_START_BIT			0x01
 #define SP_BREAK_BIT			0x02
-#define SP_RUN_BIT				0x03
+#define SP_RUN_BIT			0x03
 #define SP_BROKEN_BIT			0x04
-#define SP_IDLE_BIT				0x05     /* READY */
+#define SP_IDLE_BIT			0x05     /* READY */
+#define SP_SLEEPING_BIT			0x06
 #define SP_STALLING_BIT			0x07
 #define SP_IRQ_CLEAR_BIT		0x08
 #define SP_IRQ_READY_BIT		0x0A
-#define SP_SLEEPING_BIT			0x0B     /* SLEEPING_IRQ_MASK */
+#define SP_IRQ_SLEEPING_BIT		0x0B
 
 #define SP_ICACHE_INV_BIT		0x0C
 #define SP_IPREFETCH_EN_BIT		0x0D
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_params.c
index 04ce4fa..48d5bcf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_params.c
@@ -26,17 +26,18 @@
 #include "isp/kernels/anr/anr_2/ia_css_anr2.host.h"
 #include "isp/kernels/bh/bh_2/ia_css_bh.host.h"
 #include "isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h"
-#include "isp/kernels/bnr/bnr_2.2/ia_css_bnr22.host.h"
+#include "isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h"
 #include "isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h"
 #include "isp/kernels/crop/crop_1.0/ia_css_crop.host.h"
 #include "isp/kernels/csc/csc_1.0/ia_css_csc.host.h"
 #include "isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h"
-#include "isp/kernels/ctc/ctc_2/ia_css_ctc2.host.h"
-#include "isp/kernels/ctc/ctc_v2/ia_css_ctcv2.host.h"
+#include "isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h"
+#include "isp/kernels/ctc/ctc2/ia_css_ctc2.host.h"
 #include "isp/kernels/de/de_1.0/ia_css_de.host.h"
 #include "isp/kernels/de/de_2/ia_css_de2.host.h"
 #include "isp/kernels/dp/dp_1.0/ia_css_dp.host.h"
 #include "isp/kernels/fc/fc_1.0/ia_css_formats.host.h"
+#include "isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h"
 #include "isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h"
 #include "isp/kernels/gc/gc_1.0/ia_css_gc.host.h"
 #include "isp/kernels/gc/gc_2/ia_css_gc2.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_config.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_config.h
index d9f35f1..0f89476 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_config.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_config.h
@@ -28,10 +28,10 @@
 #include "isp2601_config.h"
 #elif defined(ISP2500)
 #include "isp2500_config.h"
-#elif defined(ISP2400)
+#elif defined(ISP2400) || defined(ISP2401)
 #include "isp2400_config.h"
 #else
-#error "Please define a core {ISP2400, ISP2500, ISP2600, ISP2601}"
+#error "Please define a core {ISP2400, ISP2401, ISP2500, ISP2600, ISP2601}"
 #endif
 
 #endif /* __ISP_CONFIG_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_public.h
index f3877ae..798dcc6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isp_public.h
@@ -182,4 +182,12 @@ STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(
 	const uint16_t		x0,
 	const uint16_t		x1);
 
+unsigned isp_is_ready(isp_ID_t ID);
+
+unsigned isp_is_sleeping(isp_ID_t ID);
+
+void isp_start(isp_ID_t ID);
+
+void isp_wake(isp_ID_t ID);
+
 #endif /* __ISP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/misc_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/misc_support.h
index 7fea8e1..f8e33a1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/misc_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/misc_support.h
@@ -27,4 +27,7 @@
 #define NOT_USED(a) ((void)(a))
 #endif
 
+/* Calculate the  total bytes for pow(2) byte alignment */
+#define tot_bytes_for_pow2_align(pow2, cur_bytes)	((cur_bytes + (pow2 - 1)) & ~(pow2 - 1))
+
 #endif /* __MISC_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h
index 91ea849..feaa0e7 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h
@@ -39,7 +39,14 @@
 
 #if defined(_MSC_VER)
 #include <stdint.h>
+/* For ATE compilation define the bool */
+#if defined(_ATE_)
+#define bool int
+#define true 1
+#define false 0
+#else
 #include <stdbool.h>
+#endif
 #include <stddef.h>
 #include <limits.h>
 #include <errno.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h
index 2a5c911..10fb476 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h
index 46d2f21..b1606c6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h
@@ -304,6 +304,8 @@ struct ia_css_binary_xinfo {
 	enum ia_css_acc_type	     type;
 	CSS_ALIGN(int32_t	     num_output_formats, 8);
 	enum ia_css_frame_format     output_formats[IA_CSS_FRAME_FORMAT_NUM];
+	CSS_ALIGN(int32_t	     num_vf_formats, 8); /**< number of supported vf formats */
+	enum ia_css_frame_format     vf_formats[IA_CSS_FRAME_FORMAT_NUM]; /**< types of supported vf formats */
 	uint8_t			     num_output_pins;
 	ia_css_ptr		     xmem_addr;
 	CSS_ALIGN(const struct ia_css_blob_descr *blob, 8);
@@ -338,6 +340,8 @@ struct ia_css_sp_info {
 	uint32_t debug_stage; /**< thread/pipe post mortem debug */
 	uint32_t debug_stripe; /**< thread/pipe post mortem debug */
 #endif
+	uint32_t threads_stack; /**< sp thread's stack pointers */
+	uint32_t threads_stack_size; /**< sp thread's stack sizes */
 	uint32_t curr_binary_id;        /**< current binary id */
 	uint32_t raw_copy_line_count;   /**< raw copy line counter */
 	uint32_t ddr_parameter_address; /**< acc param ddrptr, sp dmem */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h
index 398adab..0ff0d90 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h
@@ -70,10 +70,14 @@ enum ia_css_fw_err {
  */
 enum ia_css_fw_warning {
 	IA_CSS_FW_WARNING_NONE,
-	IA_CSS_FW_WARNING_ISYS_QUEUE_FULL,
-	IA_CSS_FW_WARNING_PSYS_QUEUE_FULL,
-	IA_CSS_FW_WARNING_CIRCBUF_ALL_LOCKED,
-	IA_CSS_FW_WARNING_EXP_ID_LOCKED,
+	IA_CSS_FW_WARNING_ISYS_QUEUE_FULL, /** < CSS system delayed because of insufficient space in the ISys queue.
+		This warning can be avoided by de-queing ISYS buffers more timely. */
+	IA_CSS_FW_WARNING_PSYS_QUEUE_FULL, /** < CSS system delayed because of insufficient space in the PSys queue.
+		This warning can be avoided by de-queing PSYS buffers more timely. */
+	IA_CSS_FW_WARNING_CIRCBUF_ALL_LOCKED, /** < CSS system delayed because of insufficient available buffers.
+		This warning can be avoided by unlocking locked frame-buffers more timely. */
+	IA_CSS_FW_WARNING_EXP_ID_LOCKED, /** < Exposure ID skipped because the frame associated to it was still locked.
+		This warning can be avoided by unlocking locked frame-buffers more timely. */
 };
 
 #endif /* __IA_CSS_ERR_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h
index 677b2cb..2fbdfc1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h
index 183a4e5..e7da197 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h
index 42e20b5..a76f609 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h
@@ -29,7 +29,7 @@
 #define __IA_CSS_VERSION_DATA_H
 
 
-#define CSS_VERSION_STRING "REL:20141014_42.2_1539; API:2.1.8.4; GIT:irci_20141013_1500__e1aae7#e1aae7f4badd10c57188ebad975743f469ced787; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
+#define CSS_VERSION_STRING "REL:20141029_44.3_1542; API:2.1.8.4; GIT:irci_20141028_0204__191ffe#191ffe4d489862c47f19ac58aea084d6204ef02b; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
 
 
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
new file mode 100644
index 0000000..70e69a2
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_LOAD_PARAM_H
+#define __IA_CSS_BAYER_LOAD_PARAM_H
+
+#include "ia_css_bayer_ls_param.h"
+
+#endif /* __IA_CSS_BAYER_LOAD_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
new file mode 100644
index 0000000..f344448
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
@@ -0,0 +1,38 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_LS_PARAM_H
+#define __IA_CSS_BAYER_LS_PARAM_H
+
+#include "type_support.h"
+
+#define NUM_BAYER_LS 2
+
+/** bayer load/store */
+struct sh_css_isp_bayer_ls_isp_config {
+	uint32_t base_address[NUM_BAYER_LS];
+	uint32_t width[NUM_BAYER_LS];
+	uint32_t height[NUM_BAYER_LS];
+	uint32_t stride[NUM_BAYER_LS];
+};
+
+
+#endif /* __IA_CSS_BAYER_LS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
new file mode 100644
index 0000000..2cb77a4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_STORE_PARAM_H
+#define __IA_CSS_BAYER_STORE_PARAM_H
+
+#include "ia_css_bayer_ls_param.h"
+
+
+#endif /* __IA_CSS_BAYER_STORE_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
new file mode 100644
index 0000000..350f19b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
@@ -0,0 +1,129 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "type_support.h"
+#include "ia_css_bnr2_2.host.h"
+
+#ifndef IA_CSS_NO_DEBUG
+#include "ia_css_debug.h" /* ia_css_debug_dtrace() */
+#endif
+
+/* Default kernel parameters. */
+const struct ia_css_bnr2_2_config default_bnr2_2_config = {
+	200,
+	200,
+	200,
+	0,
+	0,
+	0,
+	200,
+	200,
+	200,
+	0,
+	0,
+	0,
+	0,
+	4096,
+	8191,
+	128,
+	1,
+	0,
+	0,
+	0,
+	8191,
+	0,
+	8191
+};
+
+void
+ia_css_bnr2_2_encode(
+	struct sh_css_isp_bnr2_2_params *to,
+	const struct ia_css_bnr2_2_config *from,
+	size_t size)
+{
+	(void)size;
+	to->d_var_gain_r = from->d_var_gain_r;
+	to->d_var_gain_g = from->d_var_gain_g;
+	to->d_var_gain_b = from->d_var_gain_b;
+	to->d_var_gain_slope_r = from->d_var_gain_slope_r;
+	to->d_var_gain_slope_g = from->d_var_gain_slope_g;
+	to->d_var_gain_slope_b = from->d_var_gain_slope_b;
+
+	to->n_var_gain_r = from->n_var_gain_r;
+	to->n_var_gain_g = from->n_var_gain_g;
+	to->n_var_gain_b = from->n_var_gain_b;
+	to->n_var_gain_slope_r = from->n_var_gain_slope_r;
+	to->n_var_gain_slope_g = from->n_var_gain_slope_g;
+	to->n_var_gain_slope_b = from->n_var_gain_slope_b;
+
+	to->dir_thres = from->dir_thres;
+	to->dir_thres_w = from->dir_thres_w;
+	to->var_offset_coef = from->var_offset_coef;
+
+	to->dir_gain = from->dir_gain;
+	to->detail_gain	= from->detail_gain;
+	to->detail_gain_divisor = from->detail_gain_divisor;
+	to->detail_level_offset = from->detail_level_offset;
+
+	to->d_var_th_min = from->d_var_th_min;
+	to->d_var_th_max = from->d_var_th_max;
+	to->n_var_th_min = from->n_var_th_min;
+	to->n_var_th_max = from->n_var_th_max;
+}
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnr2_2_debug_trace(
+	const struct ia_css_bnr2_2_config *bnr,
+	unsigned level)
+{
+	if (!bnr)
+		return;
+
+	ia_css_debug_dtrace(level, "Bayer Noise Reduction 2.2:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_r", bnr->d_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_g", bnr->d_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_b", bnr->d_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_r", bnr->d_var_gain_slope_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_g", bnr->d_var_gain_slope_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_b", bnr->d_var_gain_slope_b);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_r", bnr->n_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_g", bnr->n_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_b", bnr->n_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_r", bnr->n_var_gain_slope_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_g", bnr->n_var_gain_slope_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_b", bnr->n_var_gain_slope_b);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres", bnr->dir_thres);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres_w", bnr->dir_thres_w);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "var_offset_coef", bnr->var_offset_coef);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_gain", bnr->dir_gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain", bnr->detail_gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain_divisor", bnr->detail_gain_divisor);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_level_offset", bnr->detail_level_offset);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_min", bnr->d_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_max", bnr->d_var_th_max);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_min", bnr->n_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_max", bnr->n_var_th_max);
+}
+#endif /* IA_CSS_NO_DEBUG */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
new file mode 100644
index 0000000..aa1ac6a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_HOST_H
+#define __IA_CSS_BNR2_2_HOST_H
+
+#include "ia_css_bnr2_2_types.h"
+#include "ia_css_bnr2_2_param.h"
+
+extern const struct ia_css_bnr2_2_config default_bnr2_2_config;
+
+void
+ia_css_bnr2_2_encode(
+	struct sh_css_isp_bnr2_2_params *to,
+	const struct ia_css_bnr2_2_config *from,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnr2_2_debug_trace(
+	const struct ia_css_bnr2_2_config *config,
+	unsigned level);
+#endif
+
+#endif /* __IA_CSS_BNR2_2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
new file mode 100644
index 0000000..c0fdf06
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
@@ -0,0 +1,57 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_PARAM_H
+#define __IA_CSS_BNR2_2_PARAM_H
+
+#include "type_support.h"
+
+/* TEMP: for implementation purpose.... */
+#define BYPASS_BNR2_2		1
+
+/* BNR (Bayer Noise Reduction) ISP parameters */
+struct sh_css_isp_bnr2_2_params {
+	int32_t d_var_gain_r;
+	int32_t d_var_gain_g;
+	int32_t d_var_gain_b;
+	int32_t d_var_gain_slope_r;
+	int32_t d_var_gain_slope_g;
+	int32_t d_var_gain_slope_b;
+	int32_t n_var_gain_r;
+	int32_t n_var_gain_g;
+	int32_t n_var_gain_b;
+	int32_t n_var_gain_slope_r;
+	int32_t n_var_gain_slope_g;
+	int32_t n_var_gain_slope_b;
+	int32_t dir_thres;
+	int32_t dir_thres_w;
+	int32_t var_offset_coef;
+	int32_t dir_gain;
+	int32_t detail_gain;
+	int32_t detail_gain_divisor;
+	int32_t detail_level_offset;
+	int32_t d_var_th_min;
+	int32_t d_var_th_max;
+	int32_t n_var_th_min;
+	int32_t n_var_th_max;
+};
+
+#endif /* __IA_CSS_BNR2_2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
new file mode 100644
index 0000000..bf22d00
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
@@ -0,0 +1,63 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_TYPES_H
+#define __IA_CSS_BNR2_2_TYPES_H
+
+#include "type_support.h" /* int32_t */
+
+/**
+ * \brief BNR2_2 public parameters.
+ * \details Struct with all parameters for the BNR2.2 kernel that can be set
+ * from the CSS API.
+ */
+struct ia_css_bnr2_2_config {
+	/* Directional variance gain for R/G/B components in dark region */
+	int32_t d_var_gain_r;
+	int32_t d_var_gain_g;
+	int32_t d_var_gain_b;
+	/* Slope of Directional variance gain between dark and bright region */
+	int32_t d_var_gain_slope_r;
+	int32_t d_var_gain_slope_g;
+	int32_t d_var_gain_slope_b;
+	/* Non-Directional variance gain for R/G/B components in dark region */
+	int32_t n_var_gain_r;
+	int32_t n_var_gain_g;
+	int32_t n_var_gain_b;
+	/* Slope of Non-Directional variance gain between dark and bright region */
+	int32_t n_var_gain_slope_r;
+	int32_t n_var_gain_slope_g;
+	int32_t n_var_gain_slope_b;
+
+	int32_t dir_thres;		/* Threshold for directional filtering */
+	int32_t dir_thres_w;		/* Threshold width for directional filtering */
+	int32_t var_offset_coef;	/* Variance offset coefficient */
+	int32_t dir_gain;		/* Gain for directional coefficient */
+	int32_t detail_gain;		/* Gain for low contrast texture control */
+	int32_t detail_gain_divisor;	/* Gain divisor for low contrast texture control */
+	int32_t detail_level_offset;	/* Bias value for low contrast texture control */
+	int32_t d_var_th_min;		/* Minimum clipping value for directional variance*/
+	int32_t d_var_th_max;		/* Maximum clipping value for diretional variance*/
+	int32_t n_var_th_min;		/* Minimum clipping value for non-directional variance*/
+	int32_t n_var_th_max;		/* Maximum clipping value for non-directional variance*/
+};
+
+#endif /* __IA_CSS_BNR2_2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
new file mode 100644
index 0000000..94ab59b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
@@ -0,0 +1,127 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+#include "ctc/ctc_1.0/ia_css_ctc.host.h"
+#include "ia_css_ctc1_5.host.h"
+
+static void ctc_gradient(
+	int *dydx, int *shift,
+	int y1, int y0, int x1, int x0)
+{
+	int frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int dydx_int;
+	int dydx_frc;
+	int sft;
+	/* max_dydx = the maxinum gradient = the maximum y (gain) */
+	int max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+
+	if (dx == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() error, illegal division operation\n");
+		return;
+	} else {
+		dydx_int = dy / dx;
+		dydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;
+	}
+
+	assert(y0 >= 0 && y0 <= max_dydx);
+	assert(y1 >= 0 && y1 <= max_dydx);
+	assert(x0 < x1);
+	assert(dydx != NULL);
+	assert(shift != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
+
+	/* search "sft" which meets this condition:
+		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
+		<= (((float)dy / (float)dx) * (1 << sft))
+		<= ((1 << IA_CSS_CTC_COEF_SHIFT) - 1) */
+	for (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {
+		int tmp_dydx = (dydx_int << sft)
+			     + (dydx_frc >> (frc_bits - sft));
+		if (tmp_dydx <= max_dydx) {
+			*dydx = tmp_dydx;
+			*shift = sft;
+		}
+		if (tmp_dydx >= max_dydx)
+			break;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
+}
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from,
+	unsigned size)
+{
+	(void)size;
+	to->y0 = from->y0;
+	to->y1 = from->y1;
+	to->y2 = from->y2;
+	to->y3 = from->y3;
+	to->y4 = from->y4;
+	to->y5 = from->y5;
+
+	to->ce_gain_exp = from->ce_gain_exp;
+
+	to->x1 = from->x1;
+	to->x2 = from->x2;
+	to->x3 = from->x3;
+	to->x4 = from->x4;
+
+	ctc_gradient(&(to->dydx0),
+		     &(to->dydx0_shift),
+		     from->y1, from->y0,
+		     from->x1, 0);
+
+	ctc_gradient(&(to->dydx1),
+		     &(to->dydx1_shift),
+		     from->y2, from->y1,
+		     from->x2, from->x1);
+
+	ctc_gradient(&to->dydx2,
+		     &to->dydx2_shift,
+		     from->y3, from->y2,
+		     from->x3, from->x2);
+
+	ctc_gradient(&to->dydx3,
+		     &to->dydx3_shift,
+		     from->y4, from->y3,
+		     from->x4, from->x3);
+
+	ctc_gradient(&(to->dydx4),
+		     &(to->dydx4_shift),
+		     from->y5, from->y4,
+		     SH_CSS_BAYER_MAXVAL, from->x4);
+}
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
new file mode 100644
index 0000000..c1f6b15
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC1_5_HOST_H
+#define __IA_CSS_CTC1_5_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_ctc1_5_param.h"
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from,
+	unsigned size);
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
+
+#endif /* __IA_CSS_CTC1_5_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
new file mode 100644
index 0000000..cc3cb36
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC1_5_PARAM_H
+#define __IA_CSS_CTC1_5_PARAM_H
+
+#include "type_support.h"
+#include "ctc/ctc_1.0/ia_css_ctc_param.h" /* vamem params */
+
+/* CTC (Color Tone Control) */
+struct sh_css_isp_ctc_params {
+	int32_t y0;
+	int32_t y1;
+	int32_t y2;
+	int32_t y3;
+	int32_t y4;
+	int32_t y5;
+	int32_t ce_gain_exp;
+	int32_t x1;
+	int32_t x2;
+	int32_t x3;
+	int32_t x4;
+	int32_t dydx0;
+	int32_t dydx0_shift;
+	int32_t dydx1;
+	int32_t dydx1_shift;
+	int32_t dydx2;
+	int32_t dydx2_shift;
+	int32_t dydx3;
+	int32_t dydx3_shift;
+	int32_t dydx4;
+	int32_t dydx4_shift;
+};
+
+#endif /* __IA_CSS_CTC1_5_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
new file mode 100644
index 0000000..8d57b9a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTCX_PARAM_H
+#define __IA_CSS_CTCX_PARAM_H
+
+#include "ia_css_ctc1_5_param.h"
+
+#endif /* __IA_CSS_CTCX_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
new file mode 100644
index 0000000..d10e4ff
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
@@ -0,0 +1,166 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "assert_support.h"
+
+#include "ia_css_ctc2.host.h"
+#include <stdio.h>
+
+#define INEFFECTIVE_VAL 4096
+#define BASIC_VAL 819
+
+/*Default configuration of parameters for Ctc2
+*/
+const struct ia_css_ctc2_config default_ctc2_config = {
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	BASIC_VAL * 2, BASIC_VAL * 4, BASIC_VAL * 6,
+	BASIC_VAL * 8, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	BASIC_VAL >> 1, BASIC_VAL};
+
+
+
+/* (dydx) = ctc2_slope(y1, y0, x1, x0)
+ * -----------------------------------------------
+ * Calculation of the Slope of a Line = ((y1 - y0) >> 8)/(x1 - x0)
+ *
+ * Note: y1, y0 , x1 & x0 must lie within the range 0 <-> 8191
+ */
+static int ctc2_slope(int y1, int y0, int x1, int x0)
+{
+	const int shift_val = 8;
+	const int max_slope = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int rounding = (dx+1) >> 1;
+	int dy_shift = dy << shift_val;
+	int slope, dydx;
+
+	/*Protection for paramater values, & avoiding zero divisions*/
+	assert(y0 >= 0 && y0 <= max_slope);
+	assert(y1 >= 0 && y1 <= max_slope);
+	assert(x0 >= 0 && x0 <= max_slope);
+	assert(x1 > 0 && x1 <= max_slope);
+	assert(dx > 0);
+
+	if (dy < 0) {
+		rounding = -rounding;
+	}
+	slope = (int) (dy_shift + rounding) / dx;
+
+	/*the slope must lie within the range
+	  (-max_slope-1) >= (dydx) >= (max_slope)
+	*/
+	if (slope <= -max_slope-1) {
+		dydx = -max_slope-1;
+	} else if (slope >= max_slope) {
+		dydx = max_slope;
+	} else {
+		dydx = slope;
+	}
+
+	return dydx;
+}
+
+/* (void) = ia_css_ctc2_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate Y parameters from userspace into ISP space
+ */
+void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
+			    const struct ia_css_ctc2_config *from)
+{
+	unsigned i, j;
+	const unsigned shffl_blck = 4;
+	const unsigned lenght_zeros = 11;
+	short dydx0, dydx1, dydx2, dydx3, dydx4;
+
+	/*
+	*  Calculation of slopes of lines interconnecting
+	*  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0
+	*/
+	dydx0 = ctc2_slope(from->y_y1, from->y_y0,
+			    from->y_x1, 0);
+	dydx1 = ctc2_slope(from->y_y2, from->y_y1,
+			    from->y_x2, from->y_x1);
+	dydx2 = ctc2_slope(from->y_y3, from->y_y2,
+			    from->y_x3, from->y_x2);
+	dydx3 = ctc2_slope(from->y_y4, from->y_y3,
+			    from->y_x4, from->y_x3);
+	dydx4 = ctc2_slope(from->y_y5, from->y_y4,
+			    SH_CSS_BAYER_MAXVAL, from->y_x4);
+
+	/*Fill 3 arrays with:
+	* - Luma input gain values y_y0, y_y1, y_y2, y_3, y_y4
+	* - Luma kneepoints 0, y_x1, y_x2, y_x3, y_x4
+	* - Calculated slopes dydx0, dyxd1, dydx2, dydx3, dydx4
+	*
+	* - Each 64-element array is divided in blocks of 16 elements:
+	*   the 5 parameters + zeros in the remaining 11 positions
+	* - All blocks of the same array will contain the same data
+	*/
+	for (i = 0; i < shffl_blck; i++) {
+		to->y_x[0][(i << shffl_blck)]     = 0;
+		to->y_x[0][(i << shffl_blck) + 1] = from->y_x1;
+		to->y_x[0][(i << shffl_blck) + 2] = from->y_x2;
+		to->y_x[0][(i << shffl_blck) + 3] = from->y_x3;
+		to->y_x[0][(i << shffl_blck) + 4] = from->y_x4;
+
+		to->y_y[0][(i << shffl_blck)]     = from->y_y0;
+		to->y_y[0][(i << shffl_blck) + 1] = from->y_y1;
+		to->y_y[0][(i << shffl_blck) + 2] = from->y_y2;
+		to->y_y[0][(i << shffl_blck) + 3] = from->y_y3;
+		to->y_y[0][(i << shffl_blck) + 4] = from->y_y4;
+
+		to->e_y_slope[0][(i << shffl_blck)]    = dydx0;
+		to->e_y_slope[0][(i << shffl_blck) +1] = dydx1;
+		to->e_y_slope[0][(i << shffl_blck) +2] = dydx2;
+		to->e_y_slope[0][(i << shffl_blck) +3] = dydx3;
+		to->e_y_slope[0][(i << shffl_blck) +4] = dydx4;
+
+		for (j = 0; j < lenght_zeros; j++) {
+			to->y_x[0][(i << shffl_blck)+ 5 + j] = 0;
+			to->y_y[0][(i << shffl_blck)+ 5 + j] = 0;
+			to->e_y_slope[0][(i << shffl_blck)+ 5 + j] = 0;
+		}
+	}
+}
+
+/* (void) = ia_css_ctc2_dmem_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void ia_css_ctc2_dmem_encode(struct ia_css_isp_ctc2_dmem_params *to,
+			     struct ia_css_ctc2_config *from)
+{
+	to->uv_y0 = from->uv_y0;
+	to->uv_y1 = from->uv_y1;
+	to->uv_x0 = from->uv_x0;
+	to->uv_x1 = from->uv_x1;
+
+	/*Slope Calculation*/
+	to->uv_dydx = ctc2_slope(from->uv_y1, from->uv_y0,
+				  from->uv_x1, from->uv_x0);
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
new file mode 100644
index 0000000..e5e5b39
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
@@ -0,0 +1,41 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_HOST_H
+#define __IA_CSS_CTC2_HOST_H
+
+#include "ia_css_ctc2_param.h"
+#include "ia_css_ctc2_types.h"
+
+extern const struct ia_css_ctc2_config default_ctc2_config;
+
+/*Encode Functions to translate parameters from userspace into ISP space*/
+
+void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
+			     const struct ia_css_ctc2_config *from);
+
+void ia_css_ctc2_dmem_encode(struct ia_css_isp_ctc2_dmem_params *to,
+			     struct ia_css_ctc2_config *from);
+
+#endif /* __IA_CSS_CTC2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
new file mode 100644
index 0000000..4cc81c6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
@@ -0,0 +1,59 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_PARAM_H
+#define __IA_CSS_CTC2_PARAM_H
+
+#define IA_CSS_CTC_COEF_SHIFT          13
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+/* CTC (Chroma Tone Control)ISP Parameters */
+
+/*VMEM Luma params*/
+struct ia_css_isp_ctc2_vmem_params {
+	/**< Gains by Y(Luma) at Y = 0.0,Y_X1, Y_X2, Y_X3, Y_X4*/
+	VMEM_ARRAY(y_x, ISP_VEC_NELEMS);
+	/** kneepoints by Y(Luma) 0.0, y_x1, y_x2, y _x3, y_x4*/
+	VMEM_ARRAY(y_y, ISP_VEC_NELEMS);
+	/** Slopes of lines interconnecting
+	 *  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0*/
+	VMEM_ARRAY(e_y_slope, ISP_VEC_NELEMS);
+};
+
+/*DMEM Chroma params*/
+struct ia_css_isp_ctc2_dmem_params {
+
+	/** Gains by UV(Chroma) under kneepoints uv_x0 and uv_x1*/
+	int32_t uv_y0;
+	int32_t uv_y1;
+
+	/** Kneepoints by UV(Chroma)- uv_x0 and uv_x1*/
+	int32_t uv_x0;
+	int32_t uv_x1;
+
+	/** Slope of line interconnecting uv_x0 -> uv_x1*/
+	int32_t uv_dydx;
+
+};
+#endif /* __IA_CSS_CTC2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
new file mode 100644
index 0000000..028535a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
@@ -0,0 +1,65 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_TYPES_H
+#define __IA_CSS_CTC2_TYPES_H
+
+/** Chroma Tone Control configuration.
+*
+*  ISP block: CTC2 (CTC by polygonal approximation)
+* (ISP1: CTC1 (CTC by look-up table) is used.)
+*  ISP2: CTC2 is used.
+*  ISP261: CTC2 (CTC by Fast Approximate Distance)
+*/
+struct ia_css_ctc2_config {
+
+	/**< Gains by Y(Luma) at Y =0.0,Y_X1, Y_X2, Y_X3, Y_X4 and Y_X5
+	*   --default/ineffective value: 4096(0.5f)
+	*/
+	uint16_t y_y0;
+	uint16_t y_y1;
+	uint16_t y_y2;
+	uint16_t y_y3;
+	uint16_t y_y4;
+	uint16_t y_y5;
+	/** 1st-4th  kneepoints by Y(Luma) --default/ineffective value:n/a
+	*   requirement: 0.0 < y_x1 < y_x2 <y _x3 < y_x4 < 1.0
+	*/
+	uint16_t y_x1;
+	uint16_t y_x2;
+	uint16_t y_x3;
+	uint16_t y_x4;
+	/** Gains by UV(Chroma) under threholds uv_x0 and uv_x1
+	*   --default/ineffective value: 4096(0.5f)
+	*/
+	uint16_t uv_y0;
+	uint16_t uv_y1;
+	/** Minimum and Maximum Thresholds by UV(Chroma)- uv_x0 and uv_x1
+	*   --default/ineffective value: n/a
+	*/
+	uint16_t uv_x0;
+	uint16_t uv_x1;
+	};
+
+#endif /* __IA_CSS_CTC2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
index a89ff8e..6b23ed5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
@@ -22,11 +22,6 @@
 #include "ia_css_dpc2.host.h"
 #include "assert_support.h"
 
-#define METRIC1_ONE_FP	(1<<12)
-#define METRIC2_ONE_FP	(1<<5)
-#define METRIC3_ONE_FP	(1<<12)
-#define WBGAIN_ONE_FP	(1<<9)
-
 void
 ia_css_dpc2_encode(
 	struct ia_css_isp_dpc2_params *to,
@@ -44,20 +39,13 @@ ia_css_dpc2_encode(
 	assert ((from->wb_gain_b  > 0) && (from->wb_gain_b  < 16*WBGAIN_ONE_FP));
 	assert ((from->wb_gain_gb > 0) && (from->wb_gain_gb < 16*WBGAIN_ONE_FP));
 
-	/* TODO: BBBs */
-	to->one_plus_metric1  = METRIC1_ONE_FP + from->metric1;
-	to->one_minus_metric1 = METRIC1_ONE_FP - from->metric1;
-	to->one_plus_metric3  = METRIC3_ONE_FP + from->metric3;
+	to->metric1 = from->metric1;
+	to->metric2 = from->metric2;
+	to->metric3 = from->metric3;
 
 	to->wb_gain_gr = from->wb_gain_gr;
 	to->wb_gain_r  = from->wb_gain_r;
 	to->wb_gain_b  = from->wb_gain_b;
 	to->wb_gain_gb = from->wb_gain_gb;
-
-	/* TODO: Double-check the precision here by MUL and SHIFT operation */
-	to->wb_gain_gr_scaled_by_metric2 = (from->wb_gain_gr * from->metric2) >> 13;
-	to->wb_gain_r_scaled_by_metric2  = (from->wb_gain_r  * from->metric2) >> 13;
-	to->wb_gain_b_scaled_by_metric2  = (from->wb_gain_b  * from->metric2) >> 13;
-	to->wb_gain_gb_scaled_by_metric2 = (from->wb_gain_gb * from->metric2) >> 13;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
index 860a90f..6402cdc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
@@ -48,17 +48,13 @@
 
 
 struct ia_css_isp_dpc2_params {
-	int32_t one_plus_metric1;
-	int32_t one_minus_metric1;
-	int32_t one_plus_metric3;
+	int32_t metric1;
+	int32_t metric2;
+	int32_t metric3;
 	int32_t wb_gain_gr;
 	int32_t wb_gain_r;
 	int32_t wb_gain_b;
 	int32_t wb_gain_gb;
-	int32_t wb_gain_gr_scaled_by_metric2;
-	int32_t wb_gain_r_scaled_by_metric2;
-	int32_t wb_gain_b_scaled_by_metric2;
-	int32_t wb_gain_gb_scaled_by_metric2;
 };
 
 #endif /* __IA_CSS_DPC2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
index a55dddf..ae21f2b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
@@ -23,6 +23,11 @@
 #define __IA_CSS_DPC2_TYPES_H
 
 #include "type_support.h"
+#define METRIC1_ONE_FP	(1<<12)
+#define METRIC2_ONE_FP	(1<<5)
+#define METRIC3_ONE_FP	(1<<12)
+#define WBGAIN_ONE_FP	(1<<9)
+
 
 struct ia_css_dpc2_config {
 	int32_t metric1;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
index 44bc726..e70ab33 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
@@ -31,10 +31,13 @@
 void
 ia_css_eed1_8_encode(
 	struct ia_css_isp_eed1_8_params *to,
-	const struct ia_css_eed1_8_config *from)
+	const struct ia_css_eed1_8_config *from,
+	size_t size)
 {
 	int i;
 
+	(void)size;
+
 	to->rbzp_strength = from->rbzp_strength;
 
 	to->fcstrength = from->fcstrength;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
index bbd23db..053bd1e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
@@ -29,7 +29,8 @@
 void
 ia_css_eed1_8_encode(
 	struct ia_css_isp_eed1_8_params *to,
-	const struct ia_css_eed1_8_config *from);
+	const struct ia_css_eed1_8_config *from,
+	size_t size);
 
 #ifndef IA_CSS_NO_DEBUG
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
index 135b9ef..d2bd1b5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
@@ -23,8 +23,20 @@
 #define __IA_CSS_EED1_8_PARAM_H
 
 #include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
 #include "ia_css_eed1_8_types.h" /* IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS */
 
+/* Define size of the state..... TODO: check if this is the correct place */
+/* 4 planes : GR, R, B, GB */
+#define NUM_PLANES		4
+/* 3 lines state per color plane input_line_state */
+#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(2 * NUM_PLANES)
+/* ToDo: Move this to testsetup */
+#define MAX_FRAME_SIMDWIDTH	30
+/* Each plane has width equal to half frame line */
+#define EED1_8_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+
 /* EED (Edge Enhancing Demosaic) ISP parameters */
 struct ia_css_isp_eed1_8_params {
 	int32_t rbzp_strength;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
new file mode 100644
index 0000000..75efce7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
@@ -0,0 +1,34 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_EED1_8_STATE_H
+#define __IA_CSS_EED1_8_STATE_H
+
+#include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
+
+#include "ia_css_eed1_8_param.h"
+
+struct ia_css_isp_eed1_8_vmem_state {
+	VMEM_ARRAY(eed1_8_input_lines[EED1_8_STATE_INPUT_BUFFER_HEIGHT], EED1_8_STATE_INPUT_BUFFER_WIDTH*ISP_NWAY);
+};
+
+#endif /* __IA_CSS_EED1_8_STATE_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
new file mode 100644
index 0000000..3cb5e35
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_fixedbds.host.h"
+
+void
+ia_css_bds_encode(
+	struct sh_css_isp_bds_params *to,
+	const struct ia_css_aa_config *from,
+	unsigned size)
+{
+	(void)size;
+	to->baf_strength = from->strength;
+}
+
+void
+ia_css_bds_dump(
+	const struct sh_css_isp_bds_params *raw,
+	unsigned level)
+{
+	(void)raw;
+	(void)level;
+}
+
+void
+ia_css_bds_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level)
+{
+  (void)config;
+  (void)level;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
new file mode 100644
index 0000000..560e7b4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIXEDBDS_HOST_H
+#define __IA_CSS_FIXEDBDS_HOST_H
+
+#include "ia_css_binary.h"
+#include "ia_css_fixedbds_param.h"
+
+void
+ia_css_bds_encode(
+	struct sh_css_isp_bds_params *to,
+	const struct ia_css_aa_config *from,
+	unsigned size);
+
+void
+ia_css_bds_dump(
+	const struct sh_css_isp_bds_params *raw,
+	unsigned level);
+
+void
+ia_css_bds_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_FIXEDBDS_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
new file mode 100644
index 0000000..ded1d61
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIXEDBDS_PARAM_H
+#define __IA_CSS_FIXEDBDS_PARAM_H
+
+#include "type_support.h"
+
+struct sh_css_isp_bds_params {
+	int baf_strength;
+};
+
+#endif /* __IA_CSS_FIXEDBDS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
index 2b38a94..ec69f37 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
@@ -19,8 +19,8 @@
  *
  */
 
-#ifndef __IA_CSS_FIXEDBDS_HOST_H
-#define __IA_CSS_FIXEDBDS_HOST_H
+#ifndef __IA_CSS_FIXEDBDS_TYPES_H
+#define __IA_CSS_FIXEDBDS_TYPES_H
 
 
 struct sh_css_bds_factor {
@@ -30,4 +30,4 @@ struct sh_css_bds_factor {
 };
 
 
-#endif	/*__IA_CSS_FIXEDBDS_HOST_H*/
+#endif	/*__IA_CSS_FIXEDBDS_TYPES_H*/
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c
index 264b80f..66e239c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * INTEL CONFIDENTIAL
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h
index b618004..430587d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h
index 89e39d3..7cc861d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h
index 8ea6202..d872fc2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
index a03cea4..0ca39b3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
@@ -19,9 +19,87 @@
  *
  */
 
+#ifndef IA_CSS_NO_DEBUG
 #include "ia_css_debug.h"
+#endif
 #include "ia_css_iefd2_6.host.h"
 
+/* Copy parameters to VMEM
+ */
+void
+ia_css_iefd2_6_vmem_encode(
+	struct ia_css_isp_iefd2_6_vmem_params *to,
+	const struct ia_css_iefd2_6_config *from,
+	size_t size)
+{
+	const int total_blocks = 4;
+	const int shuffle_block = 16;
+	unsigned i, j, base;
+	(void)size;
+
+	/* For configurable units parameters are copied to vmem. Per CU 3 arrays are copied:
+	 * x containing the x coordinates
+	 * a containing the slopes
+	 * b containing the intercept values.
+	 *
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* first init the vectors */
+	for(i = 0; i < total_blocks*shuffle_block; i++) {
+		to->e_cued_x[0][i] = 0;
+		to->e_cued_a[0][i] = 0;
+		to->e_cued_b[0][i] = 0;
+
+		to->e_cu_dir_x[0][i] = 0;
+		to->e_cu_dir_a[0][i] = 0;
+		to->e_cu_dir_b[0][i] = 0;
+
+		to->e_cu_non_dir_x[0][i] = 0;
+		to->e_cu_non_dir_a[0][i] = 0;
+		to->e_cu_non_dir_b[0][i] = 0;
+	}
+
+	/* Copy all data */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block*i;
+
+
+		to->e_cued_x[0][base] = 0;
+		to->e_cued_a[0][base] = 0;
+		to->e_cued_b[0][base] = from->cu_ed_slopes_b[1];
+
+		to->e_cu_dir_x[0][base] = 0;
+		to->e_cu_dir_a[0][base] = 0;
+		to->e_cu_dir_b[0][base] = from->cu_dir_sharp_slopes_b[1];
+
+		to->e_cu_non_dir_x[0][base] = 0;
+		to->e_cu_non_dir_a[0][base] = 0;
+		to->e_cu_non_dir_b[0][base] = from->cu_non_dir_sharp_slopes_b[1];
+
+		for (j = 1; j < 4; j++) {
+			to->e_cu_dir_a[0][base+j] = from->cu_dir_sharp_slopes_a[j];
+			to->e_cu_dir_b[0][base+j] = from->cu_dir_sharp_slopes_b[j];
+			to->e_cu_non_dir_a[0][base+j] = from->cu_non_dir_sharp_slopes_a[j];
+			to->e_cu_non_dir_b[0][base+j] = from->cu_non_dir_sharp_slopes_b[j];
+		}
+
+		for (j = 1; j < 5; j++) {
+			to->e_cu_dir_x[0][base+j] = from->cu_dir_sharp_points_x[j];
+			to->e_cu_non_dir_x[0][base+j] = from->cu_non_dir_sharp_points_x[j];
+		}
+
+
+		for (j = 1; j < 6; j++) {
+			to->e_cued_x[0][base+j] = from->cu_ed_points_x[j];
+			to->e_cued_a[0][base+j] = from->cu_ed_slopes_a[j];
+			to->e_cued_b[0][base+j] = from->cu_ed_slopes_b[j];
+		}
+
+		to->e_cued_x[0][base+6] = from->cu_ed_points_x[j];
+	}
+}
 
 void
 ia_css_iefd2_6_encode(
@@ -32,6 +110,9 @@ ia_css_iefd2_6_encode(
 	int i;
 
 	(void)size;
+
+	/* Copy parameters to dmem, as described in the KFS
+	 */
 	to->horver_diag_coeff		= from->horver_diag_coeff;
 	to->ed_horver_diag_coeff	= from->ed_horver_diag_coeff;
 	to->dir_smooth_enable		= from->dir_smooth_enable;
@@ -52,10 +133,10 @@ ia_css_iefd2_6_encode(
 	to->rad_cu_dir_sharp_x1		= from->rad_cu_dir_sharp_x1;
 	to->rad_cu_non_dir_sharp_x1	= from->rad_cu_non_dir_sharp_x1;
 	to->rad_dir_far_sharp_weight	= from->rad_dir_far_sharp_weight;
-	to->sharp_nega_lmt_txt		= from->sharp_nega_lmt_txt;
-	to->sharp_posi_lmt_txt		= from->sharp_posi_lmt_txt;
-	to->sharp_nega_lmt_dir		= from->sharp_nega_lmt_dir;
-	to->sharp_posi_lmt_dir		= from->sharp_posi_lmt_dir;
+	to->shrpn_nega_lmt_txt		= from->shrpn_nega_lmt_txt;
+	to->shrpn_posi_lmt_txt		= from->shrpn_posi_lmt_txt;
+	to->shrpn_nega_lmt_dir		= from->shrpn_nega_lmt_dir;
+	to->shrpn_posi_lmt_dir		= from->shrpn_posi_lmt_dir;
 	to->clamp_stitch		= from->clamp_stitch;
 	to->rad_enable			= from->rad_enable;
 	to->rad_x_origin		= from->rad_x_origin;
@@ -72,50 +153,22 @@ ia_css_iefd2_6_encode(
 
 	/* Setup for configurable units */
 	/* First copy the hardcoded items */
-
 	to->curad_x[0]			= 0;
 	to->curad_a[0]			= 0;
 	to->curad_b[0]			= from->cu_radial_slope_b[1];
-	to->e_cued_x[0]			= 0;
-	to->e_cued_a[0]			= 0;
-	to->e_cued_b[0]			= from->cu_ed_slopes_b[1];
-	to->e_cu_dir_x[0]		= 0;
-	to->e_cu_dir_a[0]		= 0;
-	to->e_cu_dir_b[0]		= from->cu_dir_sharp_slopes_b[1];
-	to->e_cu_non_dir_x[0]		= 0;
-	to->e_cu_non_dir_a[0]		= 0;
-	to->e_cu_non_dir_b[0]		= from->cu_non_dir_sharp_slopes_b[1];
 	to->e_cued2_a			= from->cu_ed2_slopes_a;
 	to->e_cu_vssnlm_a		= from->cu_vssnlm_slopes_a;
 
 	/* copying remaining array part */
-
-	for (i = 1; i < 3; i++)
-	{
-		to->e_cu_dir_a[i]		= from->cu_dir_sharp_slopes_a[i];
-		to->e_cu_dir_b[i]		= from->cu_dir_sharp_slopes_b[i];
-		to->e_cu_non_dir_a[i]		= from->cu_non_dir_sharp_slopes_a[i];
-		to->e_cu_non_dir_b[i]		= from->cu_non_dir_sharp_slopes_b[i];
-	}
-
-	for (i = 1; i < 4; i++)
-	{
-		to->e_cu_dir_x[i]		= from->cu_dir_sharp_points_x[i];
-		to->e_cu_non_dir_x[i]		= from->cu_non_dir_sharp_points_x[i];
-	}
-
 	for (i = 1; i < 5; i++)
 	{
 		to->curad_a[i]			= from->cu_radial_slope_a[i];
 		to->curad_b[i]			= from->cu_radial_slope_b[i];
-		to->e_cued_a[i]			= from->cu_ed_slopes_a[i];
-		to->e_cued_b[i]			= from->cu_ed_slopes_b[i];
 	}
 
 	for (i = 1; i < 6; i++)
 	{
 		to->curad_x[i]			= from->cu_radial_points_x[i];
-		to->e_cued_x[i]			= from->cu_ed_points_x[i];
 	}
 
 	to->e_cued2_b		= ((0-from->cu_ed2_points_x[1]) * from->cu_ed2_slopes_a)>>4;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
index 13c9a33..1f83f94 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
@@ -27,6 +27,12 @@
 #include "ia_css_iefd2_6_default.host.h"
 
 void
+ia_css_iefd2_6_vmem_encode(
+	struct ia_css_isp_iefd2_6_vmem_params *to,
+	const struct ia_css_iefd2_6_config *from,
+	size_t size);
+
+void
 ia_css_iefd2_6_encode(
 	struct ia_css_isp_iefd2_6_dmem_params *to,
 	const struct ia_css_iefd2_6_config *from,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
index b1688ce..e56f875 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
@@ -42,10 +42,10 @@ const struct ia_css_iefd2_6_config default_iefd2_6_config = {
 	.rad_cu_dir_sharp_x1 = 0,
 	.rad_cu_non_dir_sharp_x1 = 128,
 	.rad_dir_far_sharp_weight = 8,
-	.sharp_nega_lmt_txt = 1024,
-	.sharp_posi_lmt_txt = 1024,
-	.sharp_nega_lmt_dir = 128,
-	.sharp_posi_lmt_dir = 128,
+	.shrpn_nega_lmt_txt = 1024,
+	.shrpn_posi_lmt_txt = 1024,
+	.shrpn_nega_lmt_dir = 128,
+	.shrpn_posi_lmt_dir = 128,
 	.clamp_stitch = 0,
 	.rad_enable = true,
 	.rad_x_origin = 0,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
index 0310111..ace1bc4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
@@ -23,6 +23,19 @@
 #define __IA_CSS_IEFD2_6_PARAM_H
 
 #include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+struct ia_css_isp_iefd2_6_vmem_params {
+	VMEM_ARRAY(e_cued_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cued_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cued_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_b, ISP_VEC_NELEMS);
+};
 
 struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t horver_diag_coeff;
@@ -45,10 +58,10 @@ struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t rad_cu_dir_sharp_x1;
 	int32_t rad_cu_non_dir_sharp_x1;
 	int32_t rad_dir_far_sharp_weight;
-	int32_t sharp_nega_lmt_txt;
-	int32_t sharp_posi_lmt_txt;
-	int32_t sharp_nega_lmt_dir;
-	int32_t sharp_posi_lmt_dir;
+	int32_t shrpn_nega_lmt_txt;
+	int32_t shrpn_posi_lmt_txt;
+	int32_t shrpn_nega_lmt_dir;
+	int32_t shrpn_posi_lmt_dir;
 	int32_t clamp_stitch;
 	bool rad_enable;
 	int32_t rad_x_origin;
@@ -62,17 +75,8 @@ struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t vssnlm_y1;
 	int32_t vssnlm_y2;
 	int32_t vssnlm_y3;
-	int32_t e_cued_x[6];
-	int32_t e_cued_a[5];
-	int32_t e_cued_b[5];
 	int32_t e_cued2_a;
 	int32_t e_cued2_b;
-	int32_t e_cu_dir_x[4];
-	int32_t e_cu_dir_a[3];
-	int32_t e_cu_dir_b[3];
-	int32_t e_cu_non_dir_x[4];
-	int32_t e_cu_non_dir_a[3];
-	int32_t e_cu_non_dir_b[3];
 	int32_t curad_x[6];
 	int32_t curad_a[5];
 	int32_t curad_b[5];
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
index 264aa2d..18cfc8d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
@@ -80,14 +80,14 @@ struct ia_css_iefd2_6_config {
 						u9.0, [0,511], default 128, ineffective 0 */
 	int32_t rad_dir_far_sharp_weight;  /**< Weight of wide direct sharpening.
 						u1.12, [0,4096], default 8, ineffective 0 */
-	int32_t sharp_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
+	int32_t shrpn_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t sharp_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
+	int32_t shrpn_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t sharp_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
+	int32_t shrpn_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
-	int32_t sharp_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
+	int32_t shrpn_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
 	int32_t clamp_stitch;		   /**< Slope to stitch between clamped and unclamped edge values.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
new file mode 100644
index 0000000..2e999b9
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_LOAD_PARAM_H
+#define __IA_CSS_YUV_LOAD_PARAM_H
+
+#include "ia_css_yuv_ls_param.h"
+
+#endif /* __IA_CSS_YUV_LOAD_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
new file mode 100644
index 0000000..fe12bf7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_LS_PARAM_H
+#define __IA_CSS_YUV_LS_PARAM_H
+
+#include "type_support.h"
+
+/* The number of load/store kernels in a pipeline can be greater than one.
+ * A kernel can consume more than one input or can produce more
+ * than one output.
+ */
+#define NUM_YUV_LS 2
+
+/** YUV load/store */
+struct sh_css_isp_yuv_ls_isp_config {
+	unsigned base_address[NUM_YUV_LS];
+	unsigned width[NUM_YUV_LS];
+	unsigned height[NUM_YUV_LS];
+	unsigned stride[NUM_YUV_LS];
+};
+
+
+#endif /* __IA_CSS_YUV_LS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
new file mode 100644
index 0000000..88d9dea
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_STORE_PARAM_H
+#define __IA_CSS_YUV_STORE_PARAM_H
+
+#include "ia_css_yuv_ls_param.h"
+
+
+#endif /* __IA_CSS_YUV_STORE_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h
index e2cd223..860eafc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h
@@ -129,6 +129,7 @@
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_YUVP2               131
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_REF               132
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_REF_STRIPED       133
+#define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_REF           134
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_DVS               135
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR               136
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_STRIPED       137
@@ -195,6 +196,7 @@
 #define SH_CSS_BINARY_ID_IF_TO_BDS_RGBP_DVS_STATS           233
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_NO_DPC_OB              234
 #define SH_CSS_BINARY_ID_IF_TO_BDS_RGBP_DVS_STATS_STRIPED   235
+#define SH_CSS_BINARY_ID_IF_TO_REF                          236
 #define SH_CSS_BINARY_ID_IF_TO_DVS_STRIPED                  237
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_STRIPED                238
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1_STRIPED                239
@@ -211,6 +213,13 @@
 #define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STRIPED           250
 #define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STATS_C0          251
 #define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE            252
+#define SH_CSS_BINARY_ID_COPY_KERNELTEST_OUTPUT_SYSTEM      253
+#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE_C0         254
+#define SH_CSS_BINARY_ID_IF_TO_XNR                          255
+#define SH_CSS_BINARY_ID_IF_TO_XNR_STRIPED                  256
+#define SH_CSS_BINARY_ID_IF_TO_REF_STRIPED                  257
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS                   258
+
 
 #define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
 #define XMEM_SHORTS_PER_WORD         (HIVE_ISP_DDR_WORD_BITS/16)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c
index 9f074f7..2733d0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c
@@ -449,6 +449,21 @@ binary_supports_output_format(const struct ia_css_binary_xinfo *info,
 	return false;
 }
 
+static bool
+binary_supports_vf_format(const struct ia_css_binary_xinfo *info,
+			  enum ia_css_frame_format format)
+{
+	int i;
+
+	assert(info != NULL);
+
+	for (i = 0; i < info->num_vf_formats; i++) {
+		if (info->vf_formats[i] == format)
+			return true;
+	}
+	return false;
+}
+
 /* move to host part of bds module */
 static bool
 supports_bds_factor(uint32_t supported_factors,
@@ -464,8 +479,8 @@ binary_init_info(struct ia_css_binary_xinfo *info, unsigned int i,
 	const unsigned char *blob = sh_css_blob_info[i].blob;
 	unsigned size = sh_css_blob_info[i].header.blob.size;
 
-	assert(info != NULL);
-	assert(binary_found != NULL);
+	if ((info == NULL) || (binary_found == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	*info = sh_css_blob_info[i].header.info.isp;
 	*binary_found = blob != NULL;
@@ -756,8 +771,7 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	/* viewfinder output info */
 	if ((vf_info != NULL) && (vf_info->res.width != 0)) {
 		unsigned int vf_out_vecs, vf_out_width, vf_out_height;
-
-		binary->vf_frame_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+		binary->vf_frame_info.format = vf_info->format;
 		if (bin_out_info == NULL)
 			return IA_CSS_ERR_INTERNAL_ERROR;
 		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(bin_out_info->padded_width,
@@ -1166,6 +1180,18 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 			continue;
 		}
 
+		/* Check if vf_veceven supports the requested vf format */
+		if (xcandidate->num_output_pins == 1 &&
+			req_vf_info && candidate->enable.vf_veceven &&
+			!binary_supports_vf_format(xcandidate, req_vf_info->format)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%d == %d) && (%p != NULL) && %d && !%d\n",
+				__LINE__, xcandidate->num_output_pins, 1,
+				req_vf_info, candidate->enable.vf_veceven,
+				binary_supports_vf_format(xcandidate, req_vf_info->format));
+			continue;
+		}
+
 		if (!supports_bds_factor(candidate->bds.supported_bds_factors,
 		    descr->required_bds_factor)) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h
index 9761b66..f2c4b16 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h
@@ -151,6 +151,13 @@ ia_css_debug_dtrace(unsigned int level, const char *fmt, ...)
 }
 #endif
 
+/*! \brief Dump sp thread's stack contents
+ * SP thread's stack contents are set to 0xcafecafe. This function dumps the
+ * stack to inspect if the stack's boundaries are compromised.
+ * \return	None
+ */
+void ia_css_debug_dump_sp_stack_info(void);
+
 /*! \brief Function to set the global dtrace verbosity level.
  * \param[in]	trace_level	Maximum level of the messages to be traced.
  * \return	None
@@ -227,17 +234,23 @@ void ia_css_debug_dump_dma_isp_fifo_state(void);
  */
 void ia_css_debug_dump_dma_sp_fifo_state(void);
 
-/*! \brief Dump pif isp fifo state
+/*! \brief Dump pif A isp fifo state
+ * Dumps the primary input formatter state to tracing output.
+ * \return	None
+ */
+void ia_css_debug_dump_pif_a_isp_fifo_state(void);
+
+/*! \brief Dump pif B isp fifo state
  * Dumps the primary input formatter state to tracing output.
  * \return	None
  */
-void ia_css_debug_dump_pif_isp_fifo_state(void);
+void ia_css_debug_dump_pif_b_isp_fifo_state(void);
 
 /*! \brief Dump stream-to-memory sp fifo state
  * Dumps the stream-to-memory block state to tracing output.
  * \return	None
  */
-extern void ia_css_debug_dump_str2mem_sp_fifo_state(void);
+void ia_css_debug_dump_str2mem_sp_fifo_state(void);
 
 /*! \brief Dump isp sp fifo state
  * Dumps the isp sp fifo state to tracing output.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c
index 32bcdaf..36c321b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c
@@ -65,6 +65,7 @@
 #include "sp.h"
 #include "isp.h"
 #include "type_support.h"
+#include "math_support.h" /* CEIL_DIV */
 #if defined(HAS_INPUT_FORMATTER_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
 #include "input_system.h"	/* input_formatter_reg_load */
 #include "gp_device.h"		/* gp_device_reg_load */
@@ -119,6 +120,12 @@ unsigned int ia_css_debug_trace_level = IA_CSS_DEBUG_WARNING;
 
 #define ENABLE_LINE_MAX_LENGTH (25)
 
+/*
+ * TODO:SH_CSS_MAX_SP_THREADS is not the max number of sp threads
+ * future rework should fix this and remove the define MAX_THREAD_NUM
+ */
+#define MAX_THREAD_NUM (SH_CSS_MAX_SP_THREADS + SH_CSS_MAX_SP_INTERNAL_THREADS)
+
 static struct pipe_graph_class {
 	bool do_init;
 	int height;
@@ -151,6 +158,87 @@ static const char * const pipe_id_to_str[] = {
 static char dot_id_input_bin[SH_CSS_MAX_BINARY_NAME+10];
 static char ring_buffer[200];
 
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+static void debug_dump_long_array_formatted(
+	const sp_ID_t sp_id,
+	hrt_address stack_sp_addr,
+	unsigned stack_size)
+{
+	unsigned int i;
+	uint32_t val;
+	uint32_t addr = (uint32_t) stack_sp_addr;
+	uint32_t stack_size_words = CEIL_DIV(stack_size, sizeof(uint32_t));
+
+	/* When size is not multiple of four, last word is only relevant for
+	 * remaining bytes */
+	for (i = 0; i < stack_size_words; i++) {
+		val = sp_dmem_load_uint32(sp_id, (hrt_address)addr);
+		if ((i%8) == 0)
+			ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "\n");
+
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "0x%08x ", val);
+		addr += sizeof(uint32_t);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "\n");
+}
+
+static void debug_dump_sp_stack_info(
+	const sp_ID_t sp_id)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_threads_stack;
+	unsigned int HIVE_ADDR_sp_threads_stack_size;
+	uint32_t stack_sizes[MAX_THREAD_NUM];
+	uint32_t stack_sp_addr[MAX_THREAD_NUM];
+	unsigned int i;
+
+	fw = &sh_css_sp_fw;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "sp_id(%u) stack info\n", sp_id);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+		"from objects stack_addr_offset:0x%x stack_size_offset:0x%x\n",
+		fw->info.sp.threads_stack,
+		fw->info.sp.threads_stack_size);
+
+	HIVE_ADDR_sp_threads_stack = fw->info.sp.threads_stack;
+	HIVE_ADDR_sp_threads_stack_size = fw->info.sp.threads_stack_size;
+
+	if (fw->info.sp.threads_stack == 0 ||
+		fw->info.sp.threads_stack_size == 0)
+		return;
+
+	(void) HIVE_ADDR_sp_threads_stack;
+	(void) HIVE_ADDR_sp_threads_stack_size;
+
+	sp_dmem_load(sp_id,
+		(unsigned int)sp_address_of(sp_threads_stack),
+		&stack_sp_addr, sizeof(stack_sp_addr));
+	sp_dmem_load(sp_id,
+		(unsigned int)sp_address_of(sp_threads_stack_size),
+		&stack_sizes, sizeof(stack_sizes));
+
+	for (i = 0 ; i < MAX_THREAD_NUM; i++) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			"thread: %u stack_addr: 0x%08x stack_size: %u\n",
+			i, stack_sp_addr[i], stack_sizes[i]);
+		debug_dump_long_array_formatted(sp_id, (hrt_address)stack_sp_addr[i],
+			stack_sizes[i]);
+	}
+}
+
+void ia_css_debug_dump_sp_stack_info(void)
+{
+	debug_dump_sp_stack_info(SP0_ID);
+}
+#else
+/* Empty def for crun */
+void ia_css_debug_dump_sp_stack_info(void)
+{
+}
+#endif /* #if __HIVECC */
+
+
 void ia_css_debug_set_dtrace_level(const unsigned int trace_level)
 {
 	ia_css_debug_trace_level = trace_level;
@@ -454,8 +542,59 @@ void ia_css_debug_dump_sp_state(void)
 	return;
 }
 
+static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
+					   const char *descr)
+{
+	assert(state != NULL);
+	assert(descr != NULL);
+
+	ia_css_debug_dtrace(2, "FIFO channel: %s\n", descr);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "source valid",
+			    state->src_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo accept",
+			    state->fifo_accept);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo valid",
+			    state->fifo_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "sink accept",
+			    state->sink_accept);
+	return;
+}
+
 #if !defined(HAS_NO_INPUT_FORMATTER) && defined(USE_INPUT_SYSTEM_VERSION_2)
-static void debug_print_if_state(input_formatter_state_t *state)
+void ia_css_debug_dump_pif_a_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
+	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
+	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A");
+}
+
+void ia_css_debug_dump_pif_b_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_IF1_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_IF1, &isp_to_pif);
+	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF B to ISP");
+	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF B");
+}
+
+void ia_css_debug_dump_str2mem_sp_fifo_state(void)
+{
+	fifo_channel_state_t s2m_to_sp, sp_to_s2m;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_STREAM2MEM0_TO_SP0, &s2m_to_sp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_SP0_TO_STREAM2MEM0, &sp_to_s2m);
+	debug_print_fifo_channel_state(&s2m_to_sp, "Stream-to-memory to SP");
+	debug_print_fifo_channel_state(&sp_to_s2m, "SP to stream-to-memory");
+}
+
+static void debug_print_if_state(input_formatter_state_t *state, const char *id)
 {
 	unsigned int val;
 
@@ -489,7 +628,7 @@ static void debug_print_if_state(input_formatter_state_t *state)
 	int st_block_fifo_when_no_req = state->block_fifo_when_no_req;
 
 	assert(state != NULL);
-	ia_css_debug_dtrace(2, "InputFormatter State:\n");
+	ia_css_debug_dtrace(2, "InputFormatter State (%s):\n", id);
 
 	ia_css_debug_dtrace(2, "\tConfiguration:\n");
 
@@ -777,8 +916,12 @@ void ia_css_debug_dump_if_state(void)
 	input_formatter_bin_state_t if_bin_state;
 
 	input_formatter_get_state(INPUT_FORMATTER0_ID, &if_state);
-	debug_print_if_state(&if_state);
-	ia_css_debug_dump_pif_isp_fifo_state();
+	debug_print_if_state(&if_state, "Primary IF A");
+	ia_css_debug_dump_pif_a_isp_fifo_state();
+
+	input_formatter_get_state(INPUT_FORMATTER1_ID, &if_state);
+	debug_print_if_state(&if_state, "Primary IF B");
+	ia_css_debug_dump_pif_b_isp_fifo_state();
 
 	input_formatter_bin_get_state(INPUT_FORMATTER3_ID, &if_bin_state);
 	debug_print_if_bin_state(&if_bin_state);
@@ -1057,46 +1200,6 @@ void ia_css_debug_dump_dma_state(void)
 	return;
 }
 
-static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
-					   const char *descr)
-{
-	assert(state != NULL);
-	assert(descr != NULL);
-
-	ia_css_debug_dtrace(2, "FIFO channel: %s\n", descr);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "source valid",
-			    state->src_valid);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo accept",
-			    state->fifo_accept);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo valid",
-			    state->fifo_valid);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "sink accept",
-			    state->sink_accept);
-	return;
-}
-
-void ia_css_debug_dump_pif_isp_fifo_state(void)
-{
-	fifo_channel_state_t pif_to_isp, isp_to_pif;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
-	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
-	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A");
-}
-
-void ia_css_debug_dump_str2mem_sp_fifo_state(void)
-{
-	fifo_channel_state_t s2m_to_sp, sp_to_s2m;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_STREAM2MEM0_TO_SP0, &s2m_to_sp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_SP0_TO_STREAM2MEM0, &sp_to_s2m);
-	debug_print_fifo_channel_state(&s2m_to_sp, "Stream-to-memory to SP");
-	debug_print_fifo_channel_state(&sp_to_s2m, "SP to stream-to-memory");
-}
-
 void ia_css_debug_dump_dma_sp_fifo_state(void)
 {
 	fifo_channel_state_t dma_to_sp, sp_to_dma;
@@ -2506,11 +2609,6 @@ STORAGE_CLASS_INLINE void dtrace_dot(const char *fmt, ...)
 	va_end(ap);
 }
 #ifdef HAS_WATCHDOG_SP_THREAD_DEBUG
-/*
- * TODO:SH_CSS_MAX_SP_THREADS is not the max number of sp threads
- * future rework should fix this and remove the define MAX_THREAD_NUM
- */
-#define MAX_THREAD_NUM (SH_CSS_MAX_SP_THREADS + SH_CSS_MAX_SP_INTERNAL_THREADS)
 void sh_css_dump_thread_wait_info(void)
 {
 	const struct ia_css_fw_info *fw;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/frame/src/frame.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/frame/src/frame.c
index fd0cf99..91d4406 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/frame/src/frame.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/frame/src/frame.c
@@ -27,6 +27,10 @@
 #include "sh_css_internal.h"
 #include "memory_access.h"
 
+
+#define NV12_TILEY_TILE_WIDTH  128
+#define NV12_TILEY_TILE_HEIGHT  32
+
 /**************************************************************************
 **	Static functions declarations
 **************************************************************************/
@@ -380,6 +384,7 @@ enum ia_css_err ia_css_frame_init_planes(struct ia_css_frame *frame)
 		 */
 	case IA_CSS_FRAME_FORMAT_NV12:
 	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV12_TILEY:
 		frame_init_nv_planes(frame, 2, 2);
 		break;
 		/* nv16 and nv61 have the same frame layout, only the data
@@ -454,6 +459,8 @@ void ia_css_frame_info_set_width(struct ia_css_frame_info *info,
 	    info->format == IA_CSS_FRAME_FORMAT_YUV_LINE)
 		info->padded_width =
 		    CEIL_MUL(align, 2 * HIVE_ISP_DDR_WORD_BYTES);
+	else if (info->format == IA_CSS_FRAME_FORMAT_NV12_TILEY)
+		info->padded_width = CEIL_MUL(align, NV12_TILEY_TILE_WIDTH);
 	else if (info->format == IA_CSS_FRAME_FORMAT_RAW ||
 		 info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED)
 		info->padded_width = CEIL_MUL(align, 2 * ISP_VEC_NELEMS);
@@ -468,11 +475,7 @@ void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
 	assert(info != NULL);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 		"ia_css_frame_info_set_format() enter:\n");
-	/* yuv_line has 2*NWAY alignment */
 	info->format = format;
-	/* HACK: this resets the padded width incorrectly.
-	   Lex needs to fix this in the vf_veceven module. */
-	info->padded_width = CEIL_MUL(info->padded_width, 2 * ISP_VEC_NELEMS);
 }
 
 void ia_css_frame_info_init(struct ia_css_frame_info *info,
@@ -650,7 +653,7 @@ static void frame_init_mipi_plane(struct ia_css_frame *frame,
 	unsigned int stride;
 
 	stride = subpixels_per_line * bytes_per_pixel;
-	frame->data_bytes = 8388608;
+	frame->data_bytes = 8388608; /* 8*1024*1024 */
 	frame->valid = false;
 	frame->contiguous = true;
 	frame_init_plane(plane, subpixels_per_line, stride, height, 0);
@@ -666,6 +669,13 @@ static void frame_init_nv_planes(struct ia_css_frame *frame,
 	    uv_width = 2 * (y_width / horizontal_decimation),
 	    uv_height = y_height / vertical_decimation, y_bytes, uv_bytes;
 
+	if (IA_CSS_FRAME_FORMAT_NV12_TILEY == frame->info.format) {
+		y_width   = CEIL_MUL(y_width,   NV12_TILEY_TILE_WIDTH);
+		uv_width  = CEIL_MUL(uv_width,  NV12_TILEY_TILE_WIDTH);
+		y_height  = CEIL_MUL(y_height,  NV12_TILEY_TILE_HEIGHT);
+		uv_height = CEIL_MUL(uv_height, NV12_TILEY_TILE_HEIGHT);
+	}
+
 	y_bytes = y_width * y_height;
 	uv_bytes = uv_width * uv_height;
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/rx.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/rx.c
index 6448e9a..b3e9d4a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/rx.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/rx.c
@@ -484,8 +484,13 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 	bool port_enabled[N_MIPI_PORT_ID];
 	bool any_port_enabled = false;
 	mipi_port_ID_t port;
-
-	assert(config != NULL);
+   
+    if ((config == NULL)
+            || (config->mode >= N_RX_MODE)
+            || (config->port >= N_MIPI_PORT_ID)) {
+            assert(0);
+            return;
+    }
 	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++) {
 		if (is_receiver_port_enabled(RX0_ID, port))
 			any_port_enabled = true;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/virtual_isys.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/virtual_isys.c
index 5222e77..1b57e4f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/virtual_isys.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/virtual_isys.c
@@ -174,6 +174,10 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 		"ia_css_isys_stream_create() enter:\n");
 
+	/*Reset isys_stream to 0*/
+	memset(isys_stream, 0, sizeof(*isys_stream));
+	isys_stream->enable_metadata = isys_stream_descr->metadata.enable;
+
 	isys_stream->linked_isys_stream_id = isys_stream_descr->linked_isys_stream_id;
 	rc = create_input_system_input_port(isys_stream_descr, &(isys_stream->input_port));
 	if (rc == false)
@@ -181,7 +185,7 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 
 	rc = create_input_system_channel(isys_stream_descr, false, &(isys_stream->channel));
 	if (rc == false) {
-		destroy_input_system_input_port(&(isys_stream->input_port));
+		destroy_input_system_input_port(&isys_stream->input_port);
 		return false;
 	}
 
@@ -203,7 +207,7 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 void ia_css_isys_stream_destroy(
 	ia_css_isys_stream_h	isys_stream)
 {
-	destroy_input_system_input_port(&(isys_stream->input_port));
+	destroy_input_system_input_port(&isys_stream->input_port);
 	destroy_input_system_channel(&(isys_stream->channel));
 	if (isys_stream->enable_metadata) {
 		/* Destroy metadata channel only if its allocated*/
@@ -402,6 +406,7 @@ static bool create_input_system_input_port(
 	me->source_type = cfg->mode;
 
 	/* for metadata */
+	me->metadata.packet_type = CSI_MIPI_PACKET_TYPE_UNDEFINED;
 	if (rc && cfg->metadata.enable) {
 		me->metadata.packet_type = get_csi_mipi_packet_type(
 				cfg->metadata.fmt_type);
@@ -423,6 +428,14 @@ static void destroy_input_system_input_port(
 				me->csi_rx.packet_type,
 				&me->csi_rx.backend_lut_entry);
 	}
+
+	if (me->metadata.packet_type != CSI_MIPI_PACKET_TYPE_UNDEFINED) {
+		/*Free the backend lut allocated for metadata*/
+		release_be_lut_entry(
+				me->csi_rx.backend_id,
+				me->metadata.packet_type,
+				&me->metadata.backend_lut_entry);
+	}
 }
 
 static bool calculate_input_system_channel_cfg(
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/rmgr/src/rmgr_vbuf.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/rmgr/src/rmgr_vbuf.c
index 4655dd7..1870766 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/rmgr/src/rmgr_vbuf.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/rmgr/src/rmgr_vbuf.c
@@ -121,9 +121,11 @@ void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
  */
 void ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
 {
-	assert(handle != NULL);
-	assert(*handle != NULL);
-	assert((*handle)->count != 0);
+	if ((handle == NULL) || ((*handle) == NULL) || (((*handle)->count) == 0)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "ia_css_rmgr_refcount_release_vbuf() invalid arguments!\n");
+		return;
+	}
 	/* decrease reference count */
 	(*handle)->count--;
 	/* remove from admin */
@@ -175,7 +177,10 @@ void ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
 {
 	uint32_t i;
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_rmgr_uninit_vbuf()\n");
-	assert(pool != NULL);
+	if (pool == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_rmgr_uninit_vbuf(): NULL argument\n");
+		 return;
+	}
 	if (pool->handles != NULL) {
 		/* free the hmm buffers */
 		for (i = 0; i < pool->size; i++) {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c
index 9fc89d5..88e48f6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c
@@ -30,6 +30,7 @@
 #include "memory_access.h"
 #include "assert_support.h"
 #include "ia_css_spctrl.h"
+#include "ia_css_debug.h"
 
 typedef struct {
 	struct ia_css_sp_init_dmem_cfg dmem_config;
@@ -82,10 +83,22 @@ enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
 		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
 	mmgr_store(code_addr, spctrl_cfg->code, spctrl_cfg->code_size);
 
-	assert(sizeof(hrt_vaddress) <= sizeof(hrt_data));
+	if (sizeof(hrt_vaddress) > sizeof(hrt_data)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "size of hrt_vaddress can not be greater than hrt_data\n");
+		mmgr_free(spctrl_cfg->code_size);
+		spctrl_cfg->code_size = mmgr_NULL;
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 
 	init_dmem_cfg->ddr_data_addr  = code_addr + spctrl_cfg->ddr_data_offset;
-	assert((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) == 0);
+	if ((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) != 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "DDR address pointer is not properly aligned for DMA transfer\n");
+		mmgr_free(spctrl_cfg->code_size);
+		spctrl_cfg->code_size = mmgr_NULL;
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 #endif
 	spctrl_cofig_info[sp_id].sp_entry = spctrl_cfg->sp_entry;
 	spctrl_cofig_info[sp_id].code_addr = code_addr;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c
index 23854ea..004f0d0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c
@@ -1184,7 +1184,8 @@ static void print_pc_histo(char *core_name, struct sh_css_pc_histogram *hist)
 	unsigned cnt_run = 0;
 	unsigned cnt_stall = 0;
 
-	assert(hist != NULL);
+	if (hist == NULL)
+		return;
 
 	sh_css_print("%s histogram length = %d\n", core_name, hist->length);
 	sh_css_print("%s PC\trun\tstall\n", core_name);
@@ -4994,6 +4995,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	struct ia_css_frame_info video_bin_out_info;
 	bool need_scaler = false;
 	bool vf_res_different_than_output = false;
+	bool need_vf_pp = false;
+	int vf_ds_log2;
 	struct ia_css_video_settings *mycs  = &pipe->pipe_settings.video;
 
 	assert(pipe != NULL);
@@ -5100,19 +5103,65 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 
 	{
 		struct ia_css_binary_descr video_descr;
+		enum ia_css_frame_format vf_info_format;
 
 		err = ia_css_pipe_get_video_binarydesc(pipe,
 			&video_descr, &video_in_info, &video_bds_out_info, &video_bin_out_info, video_vf_info,
 			pipe->stream->config.left_padding);
 		if (err != IA_CSS_SUCCESS)
 			return err;
+
+		/* In the case where video_vf_info is not NULL, this allows
+		 * us to find a potential video library with desired vf format.
+		 * If success, no vf_pp binary is needed.
+		 * If failed, we will look up video binary with YUV_LINE vf format
+		 */
 		err = ia_css_binary_find(&video_descr,
 					 &mycs->video_binary);
-		if (err != IA_CSS_SUCCESS)
-			return err;
-	}
 
-	num_output_pins = mycs->video_binary.info->num_output_pins;
+		if (err != IA_CSS_SUCCESS) {
+			if (video_vf_info) {
+				/* This will do another video binary lookup later for YUV_LINE format*/
+				need_vf_pp = true;
+			} else
+				return err;
+		} else if (video_vf_info) {
+			/* The first video binary lookup is successful, but we may
+			 * still need vf_pp binary based on additiona check */
+			num_output_pins = mycs->video_binary.info->num_output_pins;
+			vf_ds_log2 = mycs->video_binary.vf_downscale_log2;
+
+			/* If the binary has dual output pins, we need vf_pp if the resolution
+			* is different. */
+			need_vf_pp |= ((num_output_pins == 2) && vf_res_different_than_output);
+
+			/* If the binary has single output pin, we need vf_pp if additional
+			* scaling is needed for vf */
+			need_vf_pp |= ((num_output_pins == 1) &&
+				((video_vf_info->res.width << vf_ds_log2 != pipe_out_info->res.width) ||
+				(video_vf_info->res.height << vf_ds_log2 != pipe_out_info->res.height)));
+		}
+
+		if (need_vf_pp) {
+			/* save the current vf_info format for restoration later */
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"load_video_binaries() need_vf_pp; find video binary with YUV_LINE again\n");
+
+			vf_info_format = video_vf_info->format;
+
+			ia_css_frame_info_set_format(video_vf_info,
+					IA_CSS_FRAME_FORMAT_YUV_LINE);
+			err = ia_css_binary_find(&video_descr,
+						&mycs->video_binary);
+
+			/* restore original vf_info format */
+			ia_css_frame_info_set_format(video_vf_info,
+					vf_info_format);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+
+	}
 
 	/* If a video binary does not use a ref_frame, we set the frame delay
 	 * to 0. This is the case for the 1-stage low-power video binary. */
@@ -5153,12 +5202,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 #endif
 #endif
 
-	/* Viewfinder post-processing */
-	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] &&  /* only when viewfinder is enabled. */
-	   ((num_output_pins == 1)        /* when the binary has a single output pin, we need vf_pp */
-		|| ((num_output_pins == 2) && vf_res_different_than_output))) {
-			/* when the binary has dual output pin, */
-			/* we only need vf_pp in case the resolution is different. */
+#if !defined(HAS_OUTPUT_SYSTEM)
+	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {
 		struct ia_css_binary_descr vf_pp_descr;
 
 		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
@@ -5169,6 +5214,7 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 		if (err != IA_CSS_SUCCESS)
 			return err;
 	}
+#endif
 
 	ref_info = mycs->video_binary.internal_frame_info;
 #if defined(IS_ISP_2500_SYSTEM)
@@ -6795,8 +6841,10 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 			}
 		}
 	} else if (post_stage != NULL) {
-		err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
+		if (vf_frame[0] != NULL && vf_frame[0]->info.res.width != 0) {
+			err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
 				      post_stage, &vf_pp_stage);
+		}
 		if (err != IA_CSS_SUCCESS)
 			return err;
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c
index af5d769..d5d162b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c
@@ -54,10 +54,10 @@ struct fw_param {
 /* Warning: same order as SH_CSS_BINARY_ID_* */
 static struct firmware_header *firmware_header;
 
-/* The string STR(irci_master_20141014_1500) is a place holder
+/* The string STR(irci_master_20141029_1500) is a place holder
  * which will be replaced with the actual RELEASE_VERSION
  * during package generation. Please do not modify  */
-static const char *release_version = STR(irci_master_20141014_1500);
+static const char *release_version = STR(irci_master_20141029_1500);
 
 #define MAX_FW_REL_VER_NAME	300
 static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
@@ -88,8 +88,8 @@ setup_sp(struct ia_css_fw_info *fw, const char *fw_data, struct ia_css_fw_info *
 {
 	const char *blob_data;
 
-	assert(fw != NULL);
-	assert(fw_data != NULL);
+	if ((fw == NULL) || (fw_data == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	blob_data = fw_data + fw->blob.offset;
 
@@ -116,8 +116,8 @@ sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi, struct ia
 	const char *name;
 	const unsigned char *blob;
 
-	assert(fw != NULL);
-	assert(bd != NULL);
+	if ((fw == NULL) || (bd == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	/* Special case: only one binary in fw */
 	if (bi == NULL) bi = (const struct ia_css_fw_info *)fw;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h
index 483a9c3..462c19b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h
@@ -147,7 +147,6 @@
 
 #define SH_CSS_MAX_SP_INTERNAL_THREADS	(\
 	 SH_CSS_SP_INTERNAL_SERVICE_THREAD +\
-	 SH_CSS_SP_INTERNAL_SWITCH_GACS_TO_SP1_THREAD +\
 	 SH_CSS_SP_INTERNAL_METADATA_THREAD)
 
 #define SH_CSS_MAX_PIPELINES	SH_CSS_MAX_SP_THREADS
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c
index 000c47b..95024ec 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c
@@ -90,7 +90,7 @@
 #include "anr/anr_2/ia_css_anr2.host.h"
 #include "bh/bh_2/ia_css_bh.host.h"
 #include "cnr/cnr_2/ia_css_cnr2.host.h"
-#include "ctc/ctc_2/ia_css_ctc2.host.h"
+#include "ctc/ctc1_5/ia_css_ctc1_5.host.h"
 #include "de/de_2/ia_css_de2.host.h"
 #include "gc/gc_2/ia_css_gc2.host.h"
 #include "sdis/sdis_2/ia_css_sdis2.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c
index 4c2ca88..3b3183f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c
@@ -29,20 +29,20 @@
 
 #define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
 
-/* function input_system_acquisition_stop: AD2 */
+/* function input_system_acquisition_stop: B05 */
 
-/* function longjmp: 683C */
+/* function longjmp: 68F4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_buff_pool_lock_frame_handles
 #define HIVE_MEM_raw_buff_pool_lock_frame_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_buff_pool_lock_frame_handles 0x6198
+#define HIVE_ADDR_raw_buff_pool_lock_frame_handles 0x6188
 #define HIVE_SIZE_raw_buff_pool_lock_frame_handles 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_buff_pool_lock_frame_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_buff_pool_lock_frame_handles 0x6198
+#define HIVE_ADDR_sp_raw_buff_pool_lock_frame_handles 0x6188
 #define HIVE_SIZE_sp_raw_buff_pool_lock_frame_handles 60
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -57,66 +57,66 @@
 #define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x1CC
 #define HIVE_SIZE_sp_HIVE_IF_SRST_MASK 16
 
-/* function tmpmem_init_dmem: 65EF */
+/* function tmpmem_init_dmem: 66A7 */
 
-/* function ia_css_isys_sp_token_map_receive_ack: 5F04 */
+/* function ia_css_isys_sp_token_map_receive_ack: 5FBC */
 
-/* function ia_css_dmaproxy_sp_set_addr_B: 3073 */
+/* function ia_css_dmaproxy_sp_set_addr_B: 30A6 */
 
 /* function debug_buffer_set_ddr_addr: F8 */
 
-/* function receiver_port_reg_load: AB6 */
+/* function receiver_port_reg_load: AE9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_mipi
 #define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_mipi 0x629C
+#define HIVE_ADDR_vbuf_mipi 0x628C
 #define HIVE_SIZE_vbuf_mipi 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_mipi 0x629C
+#define HIVE_ADDR_sp_vbuf_mipi 0x628C
 #define HIVE_SIZE_sp_vbuf_mipi 12
 
-/* function ia_css_event_sp_decode: 327F */
+/* function ia_css_event_sp_decode: 32B2 */
 
-/* function ia_css_queue_get_size: 478E */
+/* function ia_css_queue_get_size: 47C1 */
 
-/* function ia_css_queue_load: 4E59 */
+/* function ia_css_queue_load: 4E8C */
 
-/* function setjmp: 6845 */
+/* function setjmp: 68FD */
 
-/* function __dmaproxy_sp_read_write_text: 318B */
+/* function __dmaproxy_sp_read_write_text: 31BE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_isys_event_queue
 #define HIVE_MEM_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x4664
+#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x4650
 #define HIVE_SIZE_sem_for_sp2host_isys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x4664
+#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x4650
 #define HIVE_SIZE_sp_sem_for_sp2host_isys_event_queue 20
 
-/* function ia_css_dmaproxy_sp_wait_for_ack: 6E6D */
+/* function ia_css_dmaproxy_sp_wait_for_ack: 6F2E */
 
-/* function ia_css_sp_rawcopy_func: 50B8 */
+/* function ia_css_sp_rawcopy_func: 50E0 */
 
-/* function ia_css_tagger_buf_sp_pop_marked: 26E1 */
+/* function ia_css_tagger_buf_sp_pop_marked: 2714 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stage
 #define HIVE_MEM_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stage 0x5B10
+#define HIVE_ADDR_isp_stage 0x5B00
 #define HIVE_SIZE_isp_stage 824
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stage 0x5B10
+#define HIVE_ADDR_sp_isp_stage 0x5B00
 #define HIVE_SIZE_sp_isp_stage 824
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -131,32 +131,32 @@
 #define HIVE_ADDR_sp_vbuf_raw 0x2E0
 #define HIVE_SIZE_sp_vbuf_raw 4
 
-/* function ia_css_sp_bin_copy_func: 4FE0 */
+/* function ia_css_sp_bin_copy_func: 5013 */
 
-/* function ia_css_queue_item_store: 4B2F */
+/* function ia_css_queue_item_store: 4B62 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49D8
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49C4
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49D8
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49C4
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49EC
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49D8
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49EC
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49D8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 
 /* function sp_start_isp: 501 */
@@ -164,83 +164,83 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_binary_group
 #define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_binary_group 0x5EF8
+#define HIVE_ADDR_sp_binary_group 0x5EE8
 #define HIVE_SIZE_sp_binary_group 32
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_binary_group 0x5EF8
+#define HIVE_ADDR_sp_sp_binary_group 0x5EE8
 #define HIVE_SIZE_sp_sp_binary_group 32
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sw_state
 #define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sw_state 0x622C
+#define HIVE_ADDR_sp_sw_state 0x621C
 #define HIVE_SIZE_sp_sw_state 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sw_state 0x622C
+#define HIVE_ADDR_sp_sp_sw_state 0x621C
 #define HIVE_SIZE_sp_sp_sw_state 4
 
-/* function sp_error: 90A */
+/* function sp_error: 93D */
 
-/* function ia_css_thread_sp_main: D76 */
+/* function ia_css_thread_sp_main: DA9 */
 
-/* function ia_css_ispctrl_sp_init_internal_buffers: 34C6 */
+/* function ia_css_ispctrl_sp_init_internal_buffers: 34F9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_psys_event_queue_handle
 #define HIVE_MEM_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x4A8C
+#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x4A78
 #define HIVE_SIZE_sp2host_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x4A8C
+#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x4A78
 #define HIVE_SIZE_sp_sp2host_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_psys_event_queue
 #define HIVE_MEM_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4678
+#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4664
 #define HIVE_SIZE_sem_for_sp2host_psys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4678
+#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4664
 #define HIVE_SIZE_sp_sem_for_sp2host_psys_event_queue 20
 
-/* function ia_css_tagger_sp_propagate_frame: 20CA */
+/* function ia_css_tagger_sp_propagate_frame: 20FD */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_stop_copy_preview
 #define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_stop_copy_preview 0x61D4
+#define HIVE_ADDR_sp_stop_copy_preview 0x61C4
 #define HIVE_SIZE_sp_stop_copy_preview 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_stop_copy_preview 0x61D4
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x61C4
 #define HIVE_SIZE_sp_sp_stop_copy_preview 4
 
-/* function input_system_reg_load: B18 */
+/* function input_system_reg_load: B4B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_handles
 #define HIVE_MEM_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_handles 0x62A8
+#define HIVE_ADDR_vbuf_handles 0x6298
 #define HIVE_SIZE_vbuf_handles 960
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_handles 0x62A8
+#define HIVE_ADDR_sp_vbuf_handles 0x6298
 #define HIVE_SIZE_sp_vbuf_handles 960
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -255,31 +255,31 @@
 #define HIVE_ADDR_sp_max_mm_tracer 0x1B8
 #define HIVE_SIZE_sp_max_mm_tracer 4
 
-/* function ia_css_queue_store: 4CD2 */
+/* function ia_css_queue_store: 4D05 */
 
-/* function ia_css_sp_flash_register: 28BB */
+/* function ia_css_sp_flash_register: 28EE */
 
-/* function ia_css_isys_sp_backend_create: 5B5B */
+/* function ia_css_isys_sp_backend_create: 5C13 */
 
-/* function ia_css_pipeline_sp_init: 17B9 */
+/* function ia_css_pipeline_sp_init: 17EC */
 
-/* function ia_css_tagger_sp_configure: 1FAF */
+/* function ia_css_tagger_sp_configure: 1FE2 */
 
-/* function ia_css_ispctrl_sp_end_binary: 32C9 */
+/* function ia_css_ispctrl_sp_end_binary: 32FC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A98
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A84
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A98
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A84
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 
-/* function receiver_port_reg_store: ABD */
+/* function receiver_port_reg_store: AF0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_is_pending_mask
@@ -296,116 +296,116 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_frame
 #define HIVE_MEM_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_frame 0x468C
+#define HIVE_ADDR_sp_all_cb_elems_frame 0x4678
 #define HIVE_SIZE_sp_all_cb_elems_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x468C
+#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x4678
 #define HIVE_SIZE_sp_sp_all_cb_elems_frame 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_isys_event_queue_handle
 #define HIVE_MEM_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4AAC
+#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4A98
 #define HIVE_SIZE_sp2host_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4AAC
+#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4A98
 #define HIVE_SIZE_sp_sp2host_isys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_com
 #define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_com 0x4130
+#define HIVE_ADDR_host_sp_com 0x411C
 #define HIVE_SIZE_host_sp_com 220
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_com 0x4130
+#define HIVE_ADDR_sp_host_sp_com 0x411C
 #define HIVE_SIZE_sp_host_sp_com 220
 
-/* function ia_css_queue_get_free_space: 48E6 */
+/* function ia_css_queue_get_free_space: 4919 */
 
-/* function exec_image_pipe: 718 */
+/* function exec_image_pipe: 74B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_init_dmem_data
 #define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_init_dmem_data 0x6230
+#define HIVE_ADDR_sp_init_dmem_data 0x6220
 #define HIVE_SIZE_sp_init_dmem_data 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_init_dmem_data 0x6230
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x6220
 #define HIVE_SIZE_sp_sp_init_dmem_data 24
 
-/* function ia_css_sp_metadata_start: 5977 */
+/* function ia_css_sp_metadata_start: 59E7 */
 
-/* function ia_css_tagger_buf_sp_is_marked: 2808 */
+/* function ia_css_tagger_buf_sp_is_marked: 283B */
 
-/* function ia_css_bufq_sp_init_buffer_queues: 293A */
+/* function ia_css_bufq_sp_init_buffer_queues: 296D */
 
-/* function ia_css_pipeline_sp_stop: 179C */
+/* function ia_css_pipeline_sp_stop: 17CF */
 
-/* function ia_css_tagger_sp_connect_pipes: 24DB */
+/* function ia_css_tagger_sp_connect_pipes: 250E */
 
-/* function sp_isys_copy_wait: 761 */
+/* function sp_isys_copy_wait: 794 */
 
 /* function is_isp_debug_buffer_full: 3BC */
 
-/* function ia_css_dmaproxy_sp_configure_channel_from_info: 2FF0 */
+/* function ia_css_dmaproxy_sp_configure_channel_from_info: 3023 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_per_frame_data
 #define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_per_frame_data 0x420C
+#define HIVE_ADDR_sp_per_frame_data 0x41F8
 #define HIVE_SIZE_sp_per_frame_data 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_per_frame_data 0x420C
+#define HIVE_ADDR_sp_sp_per_frame_data 0x41F8
 #define HIVE_SIZE_sp_sp_per_frame_data 4
 
-/* function ia_css_rmgr_sp_vbuf_dequeue: 633F */
+/* function ia_css_rmgr_sp_vbuf_dequeue: 63F7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_psys_event_queue_handle
 #define HIVE_MEM_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4AB8
+#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4AA4
 #define HIVE_SIZE_host2sp_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4AB8
+#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4AA4
 #define HIVE_SIZE_sp_host2sp_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_xmem_bin_addr
 #define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_xmem_bin_addr 0x4210
+#define HIVE_ADDR_xmem_bin_addr 0x41FC
 #define HIVE_SIZE_xmem_bin_addr 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_xmem_bin_addr 0x4210
+#define HIVE_ADDR_sp_xmem_bin_addr 0x41FC
 #define HIVE_SIZE_sp_xmem_bin_addr 4
 
-/* function tmr_clock_init: AA0 */
+/* function tmr_clock_init: AD3 */
 
-/* function ia_css_sp_rawcopy_unlock_buffer: 5610 */
+/* function ia_css_sp_rawcopy_unlock_buffer: 5647 */
 
-/* function ia_css_pipeline_sp_run: 142E */
+/* function ia_css_pipeline_sp_run: 1461 */
 
-/* function memcpy: 68E5 */
+/* function memcpy: 699D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_GP_DEVICE_BASE
@@ -431,51 +431,51 @@
 #define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x1E4
 #define HIVE_SIZE_sp_ia_css_thread_sp_ready_queue 12
 
-/* function input_system_reg_store: B1F */
+/* function input_system_reg_store: B52 */
 
-/* function sp_dma_proxy_set_width_ab: 2E8D */
+/* function sp_dma_proxy_set_width_ab: 2EC0 */
 
-/* function ia_css_isys_sp_frontend_start: 5D85 */
+/* function ia_css_isys_sp_frontend_start: 5E3D */
 
-/* function ia_css_uds_sp_scale_params: 6609 */
+/* function ia_css_uds_sp_scale_params: 66C1 */
 
-/* function ia_css_circbuf_increase_size: E5B */
+/* function ia_css_circbuf_increase_size: E8E */
 
-/* function __divu: 6863 */
+/* function __divu: 691B */
 
-/* function ia_css_thread_sp_get_state: C9E */
+/* function ia_css_thread_sp_get_state: CD1 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_stop
 #define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_stop 0x469C
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x4688
 #define HIVE_SIZE_sem_for_cont_capt_stop 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x469C
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x4688
 #define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
 
-/* function thread_fiber_sp_main: E54 */
+/* function thread_fiber_sp_main: E87 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_pipe_thread
 #define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pipe_thread 0x47E0
+#define HIVE_ADDR_sp_isp_pipe_thread 0x47CC
 #define HIVE_SIZE_sp_isp_pipe_thread 340
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x47E0
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x47CC
 #define HIVE_SIZE_sp_sp_isp_pipe_thread 340
 
-/* function ia_css_parambuf_sp_handle_parameter_sets: 12D1 */
+/* function ia_css_parambuf_sp_handle_parameter_sets: 1304 */
 
-/* function ia_css_spctrl_sp_set_state: 59A6 */
+/* function ia_css_spctrl_sp_set_state: 5A16 */
 
-/* function ia_css_thread_sem_sp_signal: 6ABB */
+/* function ia_css_thread_sem_sp_signal: 6B73 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_IRQ_BASE
@@ -501,13 +501,13 @@
 #define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
 #define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
 
-/* function ia_css_isys_sp_isr: 701E */
+/* function ia_css_isys_sp_isr: 70DF */
 
-/* function ia_css_isys_sp_generate_exp_id: 6137 */
+/* function ia_css_isys_sp_generate_exp_id: 61EF */
 
-/* function ia_css_rmgr_sp_init: 622E */
+/* function ia_css_rmgr_sp_init: 62E6 */
 
-/* function ia_css_thread_sem_sp_init: 6B8E */
+/* function ia_css_thread_sem_sp_init: 6C46 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_is_isp_requested
@@ -524,20 +524,20 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_frame
 #define HIVE_MEM_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frame 0x46B0
+#define HIVE_ADDR_sem_for_reading_cb_frame 0x469C
 #define HIVE_SIZE_sem_for_reading_cb_frame 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x46B0
+#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x469C
 #define HIVE_SIZE_sp_sem_for_reading_cb_frame 40
 
-/* function ia_css_dmaproxy_sp_execute: 2F48 */
+/* function ia_css_dmaproxy_sp_execute: 2F7B */
 
-/* function ia_css_queue_is_empty: 47C9 */
+/* function ia_css_queue_is_empty: 47FC */
 
-/* function ia_css_pipeline_sp_has_stopped: 1792 */
+/* function ia_css_pipeline_sp_has_stopped: 17C5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_verbosity
@@ -551,7 +551,7 @@
 #define HIVE_ADDR_sp_verbosity 0x2680
 #define HIVE_SIZE_sp_verbosity 4
 
-/* function ia_css_circbuf_extract: F69 */
+/* function ia_css_circbuf_extract: F9C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_sp_thread
@@ -565,11 +565,11 @@
 #define HIVE_ADDR_sp_current_sp_thread 0x1E0
 #define HIVE_SIZE_sp_current_sp_thread 4
 
-/* function ia_css_spctrl_sp_get_spid: 59AD */
+/* function ia_css_spctrl_sp_get_spid: 5A1D */
 
-/* function ia_css_dmaproxy_sp_read_byte_addr: 6E9E */
+/* function ia_css_dmaproxy_sp_read_byte_addr: 6F5F */
 
-/* function ia_css_rmgr_sp_uninit: 6227 */
+/* function ia_css_rmgr_sp_uninit: 62DF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack
@@ -595,22 +595,22 @@
 #define HIVE_ADDR_sp_trace_buffer_sp 0x1B4
 #define HIVE_SIZE_sp_trace_buffer_sp 4
 
-/* function ia_css_circbuf_peek: F48 */
+/* function ia_css_circbuf_peek: F7B */
 
-/* function ia_css_parambuf_sp_wait_for_in_param: 107F */
+/* function ia_css_parambuf_sp_wait_for_in_param: 10B2 */
 
-/* function ia_css_isys_sp_token_map_get_exp_id: 5FF2 */
+/* function ia_css_isys_sp_token_map_get_exp_id: 60AA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_param
 #define HIVE_MEM_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_param 0x46D8
+#define HIVE_ADDR_sp_all_cb_elems_param 0x46C4
 #define HIVE_SIZE_sp_all_cb_elems_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x46D8
+#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x46C4
 #define HIVE_SIZE_sp_sp_all_cb_elems_param 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -628,103 +628,103 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame_desc
 #define HIVE_MEM_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame_desc 0x46E8
+#define HIVE_ADDR_sp_all_cbs_frame_desc 0x46D4
 #define HIVE_SIZE_sp_all_cbs_frame_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x46E8
+#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x46D4
 #define HIVE_SIZE_sp_sp_all_cbs_frame_desc 8
 
-/* function sp_isys_copy_func_v2: 75A */
+/* function sp_isys_copy_func_v2: 78D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_param
 #define HIVE_MEM_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_param 0x46F0
+#define HIVE_ADDR_sem_for_reading_cb_param 0x46DC
 #define HIVE_SIZE_sem_for_reading_cb_param 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x46F0
+#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x46DC
 #define HIVE_SIZE_sp_sem_for_reading_cb_param 40
 
-/* function ia_css_queue_get_used_space: 4898 */
+/* function ia_css_queue_get_used_space: 48CB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_start
 #define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_start 0x4718
+#define HIVE_ADDR_sem_for_cont_capt_start 0x4704
 #define HIVE_SIZE_sem_for_cont_capt_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x4718
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x4704
 #define HIVE_SIZE_sp_sem_for_cont_capt_start 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tmp_heap
 #define HIVE_MEM_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_tmp_heap 0x5F18
+#define HIVE_ADDR_tmp_heap 0x5F08
 #define HIVE_SIZE_tmp_heap 640
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tmp_heap 0x5F18
+#define HIVE_ADDR_sp_tmp_heap 0x5F08
 #define HIVE_SIZE_sp_tmp_heap 640
 
-/* function ia_css_tagger_buf_sp_mark: 2894 */
+/* function ia_css_tagger_buf_sp_mark: 28C7 */
 
-/* function ia_css_rmgr_sp_get_num_vbuf: 6544 */
+/* function ia_css_rmgr_sp_get_num_vbuf: 65FC */
 
-/* function ia_css_ispctrl_sp_output_compute_dma_info: 3CDE */
+/* function ia_css_ispctrl_sp_output_compute_dma_info: 3D11 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AC4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AB0
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AC4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4AB0
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 
-/* function ia_css_queue_is_full: 4935 */
+/* function ia_css_queue_is_full: 4968 */
 
 /* function debug_buffer_init_isp: 105 */
 
-/* function ia_css_isys_sp_frontend_uninit: 5D36 */
+/* function ia_css_isys_sp_frontend_uninit: 5DEE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem
 #define HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x6668
+#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x6658
 #define HIVE_SIZE_ia_css_rmgr_sp_mipi_frame_sem 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x6668
+#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x6658
 #define HIVE_SIZE_sp_ia_css_rmgr_sp_mipi_frame_sem 60
 
-/* function ia_css_rmgr_sp_refcount_dump: 631A */
+/* function ia_css_rmgr_sp_refcount_dump: 63D2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4B00
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4AEC
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4B00
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4AEC
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -739,59 +739,59 @@
 #define HIVE_ADDR_sp_sp_pipe_threads 0x148
 #define HIVE_SIZE_sp_sp_pipe_threads 20
 
-/* function sp_event_proxy_func: 76F */
+/* function sp_event_proxy_func: 7A2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_isys_event_queue_handle
 #define HIVE_MEM_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4B14
+#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4B00
 #define HIVE_SIZE_host2sp_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4B14
+#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4B00
 #define HIVE_SIZE_sp_host2sp_isys_event_queue_handle 12
 
-/* function ia_css_thread_sp_yield: 6A31 */
+/* function ia_css_thread_sp_yield: 6AE9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param_desc
 #define HIVE_MEM_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param_desc 0x472C
+#define HIVE_ADDR_sp_all_cbs_param_desc 0x4718
 #define HIVE_SIZE_sp_all_cbs_param_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x472C
+#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x4718
 #define HIVE_SIZE_sp_sp_all_cbs_param_desc 8
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb
 #define HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5B04
+#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5AF0
 #define HIVE_SIZE_ia_css_dmaproxy_sp_invalidate_tlb 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5B04
+#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5AF0
 #define HIVE_SIZE_sp_ia_css_dmaproxy_sp_invalidate_tlb 4
 
-/* function ia_css_thread_sp_fork: D2B */
+/* function ia_css_thread_sp_fork: D5E */
 
-/* function ia_css_tagger_sp_destroy: 24E5 */
+/* function ia_css_tagger_sp_destroy: 2518 */
 
-/* function ia_css_dmaproxy_sp_vmem_read: 2ED1 */
+/* function ia_css_dmaproxy_sp_vmem_read: 2F04 */
 
-/* function ia_css_ifmtr_sp_init: 6185 */
+/* function ia_css_ifmtr_sp_init: 623D */
 
-/* function initialize_sp_group: 728 */
+/* function initialize_sp_group: 75B */
 
-/* function ia_css_thread_sp_init: D57 */
+/* function ia_css_thread_sp_init: D8A */
 
-/* function ia_css_ispctrl_sp_set_stream_base_addr: 44D6 */
+/* function ia_css_ispctrl_sp_set_stream_base_addr: 4509 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_DMEM_BASE
@@ -817,7 +817,7 @@
 #define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
 #define HIVE_SIZE_sp_SP_DMEM_BASE 4
 
-/* function ia_css_dmaproxy_sp_read: 2F69 */
+/* function ia_css_dmaproxy_sp_read: 2F9C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_copy_line_count
@@ -834,27 +834,27 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_tag_cmd_queue_handle
 #define HIVE_MEM_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4B20
+#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4B0C
 #define HIVE_SIZE_host2sp_tag_cmd_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4B20
+#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4B0C
 #define HIVE_SIZE_sp_host2sp_tag_cmd_queue_handle 12
 
-/* function ia_css_queue_peek: 480D */
+/* function ia_css_queue_peek: 4840 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_frame_cnt
 #define HIVE_MEM_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x49CC
+#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x49B8
 #define HIVE_SIZE_ia_css_flash_sp_frame_cnt 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x49CC
+#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x49B8
 #define HIVE_SIZE_sp_ia_css_flash_sp_frame_cnt 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -884,26 +884,26 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_thread
 #define HIVE_MEM_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_thread 0x5E48
+#define HIVE_ADDR_isp_thread 0x5E38
 #define HIVE_SIZE_isp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_thread 0x5E48
+#define HIVE_ADDR_sp_isp_thread 0x5E38
 #define HIVE_SIZE_sp_isp_thread 4
 
-/* function encode_and_post_sp_event_non_blocking: A57 */
+/* function encode_and_post_sp_event_non_blocking: A8A */
 
-/* function ia_css_isys_sp_frontend_destroy: 5E1E */
+/* function ia_css_isys_sp_frontend_destroy: 5ED6 */
 
 /* function is_ddr_debug_buffer_full: 33E */
 
-/* function ia_css_isys_sp_frontend_stop: 5D4E */
+/* function ia_css_isys_sp_frontend_stop: 5E06 */
 
-/* function ia_css_isys_sp_token_map_init: 60D2 */
+/* function ia_css_isys_sp_token_map_init: 618A */
 
-/* function sp_dma_proxy_isp_write_addr: 2EE9 */
+/* function sp_dma_proxy_isp_write_addr: 2F1C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_fiber
@@ -917,38 +917,38 @@
 #define HIVE_ADDR_sp_sp_threads_fiber 0x194
 #define HIVE_SIZE_sp_sp_threads_fiber 28
 
-/* function encode_and_post_sp_event: A28 */
+/* function encode_and_post_sp_event: A5B */
 
 /* function debug_enqueue_ddr: 114 */
 
-/* function ia_css_rmgr_sp_refcount_init_vbuf: 62D5 */
+/* function ia_css_rmgr_sp_refcount_init_vbuf: 638D */
 
-/* function dmaproxy_sp_read_write: 6F49 */
+/* function dmaproxy_sp_read_write: 700A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer
 #define HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5B08
+#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5AF4
 #define HIVE_SIZE_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5B08
+#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5AF4
 #define HIVE_SIZE_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 
-/* function ia_css_dmaproxy_sp_ack: 6BB6 */
+/* function ia_css_dmaproxy_sp_ack: 6C6E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_buffer_queue_handle
 #define HIVE_MEM_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4B2C
+#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4B18
 #define HIVE_SIZE_host2sp_buffer_queue_handle 480
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4B2C
+#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4B18
 #define HIVE_SIZE_sp_host2sp_buffer_queue_handle 480
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -963,40 +963,40 @@
 #define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x3214
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_service 4
 
-/* function ia_css_dmaproxy_sp_process: 6BE5 */
+/* function ia_css_dmaproxy_sp_process: 6C9D */
 
-/* function ia_css_isys_sp_backend_rcv_acquire_ack: 5A0A */
+/* function ia_css_isys_sp_backend_rcv_acquire_ack: 5AC2 */
 
-/* function ia_css_isys_sp_backend_pre_acquire_request: 5A20 */
+/* function ia_css_isys_sp_backend_pre_acquire_request: 5AD8 */
 
-/* function ia_css_ispctrl_sp_init_cs: 33CF */
+/* function ia_css_ispctrl_sp_init_cs: 3402 */
 
-/* function ia_css_spctrl_sp_init: 59BB */
+/* function ia_css_spctrl_sp_init: 5A2B */
 
-/* function sp_event_proxy_init: 784 */
+/* function sp_event_proxy_init: 7B7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_output
 #define HIVE_MEM_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_output 0x4214
+#define HIVE_ADDR_sp_output 0x4200
 #define HIVE_SIZE_sp_output 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_output 0x4214
+#define HIVE_ADDR_sp_sp_output 0x4200
 #define HIVE_SIZE_sp_sp_output 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4D0C
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4CF8
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4D0C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4CF8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1023,54 +1023,54 @@
 #define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
 #define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
 
-/* function sp_dma_proxy_reset_channels: 31E3 */
+/* function sp_dma_proxy_reset_channels: 3216 */
 
-/* function ia_css_bufq_set_clock_tick: 2932 */
+/* function ia_css_bufq_set_clock_tick: 2965 */
 
-/* function ia_css_isys_sp_backend_acquire: 5B31 */
+/* function ia_css_isys_sp_backend_acquire: 5BE9 */
 
-/* function ia_css_tagger_sp_update_size: 25E7 */
+/* function ia_css_tagger_sp_update_size: 261A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_host_sp_queue
 #define HIVE_MEM_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x502C
+#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x5018
 #define HIVE_SIZE_ia_css_bufq_host_sp_queue 2008
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x502C
+#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x5018
 #define HIVE_SIZE_sp_ia_css_bufq_host_sp_queue 2008
 
-/* function thread_fiber_sp_create: DC3 */
+/* function thread_fiber_sp_create: DF6 */
 
-/* function ia_css_dmaproxy_sp_set_increments: 305E */
+/* function ia_css_dmaproxy_sp_set_increments: 3091 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_frame
 #define HIVE_MEM_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_frame 0x4734
+#define HIVE_ADDR_sem_for_writing_cb_frame 0x4720
 #define HIVE_SIZE_sem_for_writing_cb_frame 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x4734
+#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x4720
 #define HIVE_SIZE_sp_sem_for_writing_cb_frame 20
 
-/* function receiver_reg_store: ACB */
+/* function receiver_reg_store: AFE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_param
 #define HIVE_MEM_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_param 0x4748
+#define HIVE_ADDR_sem_for_writing_cb_param 0x4734
 #define HIVE_SIZE_sem_for_writing_cb_param 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4748
+#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4734
 #define HIVE_SIZE_sp_sem_for_writing_cb_param 20
 
 /* function sp_start_isp_entry: 4F7 */
@@ -1081,45 +1081,45 @@
 #endif
 #define HIVE_ADDR_sp_sp_start_isp_entry 0x4F7
 
-/* function ia_css_tagger_buf_sp_unmark_all: 282C */
+/* function ia_css_tagger_buf_sp_unmark_all: 285F */
 
-/* function ia_css_dmaproxy_sp_channel_acquire: 3212 */
+/* function ia_css_dmaproxy_sp_channel_acquire: 3245 */
 
-/* function ia_css_rmgr_sp_add_num_vbuf: 6520 */
+/* function ia_css_rmgr_sp_add_num_vbuf: 65D8 */
 
-/* function ia_css_isys_sp_token_map_create: 611E */
+/* function ia_css_isys_sp_token_map_create: 61D6 */
 
-/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 2E84 */
+/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 2EB7 */
 
-/* function ia_css_tagger_buf_sp_push_marked: 2756 */
+/* function ia_css_tagger_buf_sp_push_marked: 2789 */
 
-/* function ia_css_bufq_sp_is_dynamic_buffer: 2CB1 */
+/* function ia_css_bufq_sp_is_dynamic_buffer: 2CE4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_group
 #define HIVE_MEM_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_group 0x4224
+#define HIVE_ADDR_sp_group 0x4210
 #define HIVE_SIZE_sp_group 1084
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_group 0x4224
+#define HIVE_ADDR_sp_sp_group 0x4210
 #define HIVE_SIZE_sp_sp_group 1084
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_event_proxy_thread
 #define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_event_proxy_thread 0x4934
+#define HIVE_ADDR_sp_event_proxy_thread 0x4920
 #define HIVE_SIZE_sp_event_proxy_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_event_proxy_thread 0x4934
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x4920
 #define HIVE_SIZE_sp_sp_event_proxy_thread 68
 
-/* function ia_css_thread_sp_kill: CF1 */
+/* function ia_css_thread_sp_kill: D24 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_cur_loc
@@ -1133,9 +1133,9 @@
 #define HIVE_ADDR_sp_cur_loc 0x2674
 #define HIVE_SIZE_sp_cur_loc 4
 
-/* function ia_css_tagger_sp_create: 259E */
+/* function ia_css_tagger_sp_create: 25D1 */
 
-/* function tmpmem_acquire_dmem: 65D0 */
+/* function tmpmem_acquire_dmem: 6688 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_MMU_BASE
@@ -1149,36 +1149,36 @@
 #define HIVE_ADDR_sp_MMU_BASE 0x24
 #define HIVE_SIZE_sp_MMU_BASE 8
 
-/* function ia_css_dmaproxy_sp_channel_release: 31FB */
+/* function ia_css_dmaproxy_sp_channel_release: 322E */
 
-/* function ia_css_dmaproxy_sp_is_idle: 31CE */
+/* function ia_css_dmaproxy_sp_is_idle: 3201 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_qos_start
 #define HIVE_MEM_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_qos_start 0x475C
+#define HIVE_ADDR_sem_for_qos_start 0x4748
 #define HIVE_SIZE_sem_for_qos_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_qos_start 0x475C
+#define HIVE_ADDR_sp_sem_for_qos_start 0x4748
 #define HIVE_SIZE_sp_sem_for_qos_start 20
 
-/* function isp_hmem_load: B5F */
+/* function isp_hmem_load: B92 */
 
-/* function ia_css_eventq_sp_send: 3257 */
+/* function ia_css_eventq_sp_send: 328A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_error_cnt
 #define HIVE_MEM_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x6254
+#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x6244
 #define HIVE_SIZE_ia_css_isys_sp_error_cnt 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x6254
+#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x6244
 #define HIVE_SIZE_sp_ia_css_isys_sp_error_cnt 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1193,31 +1193,31 @@
 #define HIVE_ADDR_sp_debug_buffer_ddr_address 0xBC
 #define HIVE_SIZE_sp_debug_buffer_ddr_address 4
 
-/* function sp_isys_copy_request: 768 */
+/* function sp_isys_copy_request: 79B */
 
-/* function ia_css_rmgr_sp_refcount_retain_vbuf: 63AF */
+/* function ia_css_rmgr_sp_refcount_retain_vbuf: 6467 */
 
-/* function ia_css_thread_sp_set_priority: CE9 */
+/* function ia_css_thread_sp_set_priority: D1C */
 
-/* function sizeof_hmem: C15 */
+/* function sizeof_hmem: C48 */
 
-/* function tmpmem_release_dmem: 65BD */
+/* function tmpmem_release_dmem: 6675 */
 
 /* function cnd_input_system_cfg: 419 */
 
-/* function __ia_css_sp_rawcopy_func_critical: 6FA7 */
+/* function __ia_css_sp_rawcopy_func_critical: 7068 */
 
-/* function __ia_css_dmaproxy_sp_process_text: 2DC0 */
+/* function __ia_css_dmaproxy_sp_process_text: 2DF3 */
 
-/* function ia_css_dmaproxy_sp_set_width_exception: 3048 */
+/* function ia_css_dmaproxy_sp_set_width_exception: 307B */
 
-/* function ia_css_flash_sp_init_internal_params: 2927 */
+/* function ia_css_flash_sp_init_internal_params: 295A */
 
-/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 260C */
+/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 263F */
 
-/* function __modu: 68A9 */
+/* function __modu: 6961 */
 
-/* function ia_css_dmaproxy_sp_init_isp_vector: 2EA3 */
+/* function ia_css_dmaproxy_sp_init_isp_vector: 2ED6 */
 
 /* function isp_vamem_store: 0 */
 
@@ -1257,22 +1257,22 @@
 #define HIVE_ADDR_sp_GDC_BASE 0x44
 #define HIVE_SIZE_sp_GDC_BASE 8
 
-/* function ia_css_queue_local_init: 4B09 */
+/* function ia_css_queue_local_init: 4B3C */
 
-/* function sp_event_proxy_callout_func: 693B */
+/* function sp_event_proxy_callout_func: 69F3 */
 
-/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 2E6B */
+/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 2E9E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_num_ready_threads
 #define HIVE_MEM_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x49C0
+#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x49AC
 #define HIVE_SIZE_ia_css_thread_sp_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x49C0
+#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x49AC
 #define HIVE_SIZE_sp_ia_css_thread_sp_num_ready_threads 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1287,27 +1287,27 @@
 #define HIVE_ADDR_sp_sp_threads_stack_size 0x178
 #define HIVE_SIZE_sp_sp_threads_stack_size 28
 
-/* function ia_css_ispctrl_sp_isp_done_row_striping: 3CC4 */
+/* function ia_css_ispctrl_sp_isp_done_row_striping: 3CF7 */
 
-/* function __ia_css_isys_sp_isr_text: 5E49 */
+/* function __ia_css_isys_sp_isr_text: 5F01 */
 
-/* function ia_css_queue_dequeue: 497D */
+/* function ia_css_queue_dequeue: 49B0 */
 
-/* function ia_css_dmaproxy_sp_configure_channel: 6EB5 */
+/* function ia_css_dmaproxy_sp_configure_channel: 6F76 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_thread_fiber_sp
 #define HIVE_MEM_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_current_thread_fiber_sp 0x49C8
+#define HIVE_ADDR_current_thread_fiber_sp 0x49B4
 #define HIVE_SIZE_current_thread_fiber_sp 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_thread_fiber_sp 0x49C8
+#define HIVE_ADDR_sp_current_thread_fiber_sp 0x49B4
 #define HIVE_SIZE_sp_current_thread_fiber_sp 4
 
-/* function ia_css_circbuf_pop: 1001 */
+/* function ia_css_circbuf_pop: 1034 */
 
 /* function irq_raise_set_token: C1 */
 
@@ -1323,81 +1323,81 @@
 #define HIVE_ADDR_sp_GPIO_BASE 0x3C
 #define HIVE_SIZE_sp_GPIO_BASE 4
 
-/* function ia_css_pipeline_acc_stage_enable: 1772 */
+/* function ia_css_pipeline_acc_stage_enable: 17A5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_ph
 #define HIVE_MEM_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_ph 0x6264
+#define HIVE_ADDR_isp_ph 0x6254
 #define HIVE_SIZE_isp_ph 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_ph 0x6264
+#define HIVE_ADDR_sp_isp_ph 0x6254
 #define HIVE_SIZE_sp_isp_ph 28
 
-/* function ia_css_isys_sp_token_map_flush: 605B */
+/* function ia_css_isys_sp_token_map_flush: 6113 */
 
-/* function ia_css_ispctrl_sp_init_ds: 356D */
+/* function ia_css_ispctrl_sp_init_ds: 35A0 */
 
-/* function get_xmem_base_addr_raw: 3927 */
+/* function get_xmem_base_addr_raw: 395A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param
 #define HIVE_MEM_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param 0x4770
+#define HIVE_ADDR_sp_all_cbs_param 0x475C
 #define HIVE_SIZE_sp_all_cbs_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param 0x4770
+#define HIVE_ADDR_sp_sp_all_cbs_param 0x475C
 #define HIVE_SIZE_sp_sp_all_cbs_param 16
 
-/* function ia_css_circbuf_create: 1052 */
+/* function ia_css_circbuf_create: 1085 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp_group
 #define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp_group 0x4780
+#define HIVE_ADDR_sem_for_sp_group 0x476C
 #define HIVE_SIZE_sem_for_sp_group 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp_group 0x4780
+#define HIVE_ADDR_sp_sem_for_sp_group 0x476C
 #define HIVE_SIZE_sp_sem_for_sp_group 20
 
-/* function ia_css_framebuf_sp_wait_for_in_frame: 654B */
+/* function ia_css_framebuf_sp_wait_for_in_frame: 6603 */
 
-/* function ia_css_tagger_buf_sp_push_unmarked: 267F */
+/* function ia_css_tagger_buf_sp_push_unmarked: 26B2 */
 
-/* function isp_hmem_clear: B26 */
+/* function isp_hmem_clear: B59 */
 
-/* function ia_css_framebuf_sp_release_in_frame: 658E */
+/* function ia_css_framebuf_sp_release_in_frame: 6646 */
 
-/* function ia_css_isys_sp_backend_snd_acquire_request: 5A83 */
+/* function ia_css_isys_sp_backend_snd_acquire_request: 5B3B */
 
-/* function ia_css_isys_sp_token_map_is_full: 5ED0 */
+/* function ia_css_isys_sp_token_map_is_full: 5F88 */
 
-/* function input_system_acquisition_run: AF4 */
+/* function input_system_acquisition_run: B27 */
 
-/* function ia_css_ispctrl_sp_start_binary: 33AD */
+/* function ia_css_ispctrl_sp_start_binary: 33E0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x5804
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x57F0
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x5804
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x57F0
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 
-/* function ia_css_eventq_sp_recv: 3229 */
+/* function ia_css_eventq_sp_recv: 325C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_pool
@@ -1411,9 +1411,9 @@
 #define HIVE_ADDR_sp_isp_pool 0x2D4
 #define HIVE_SIZE_sp_isp_pool 4
 
-/* function ia_css_rmgr_sp_rel_gen: 6270 */
+/* function ia_css_rmgr_sp_rel_gen: 6328 */
 
-/* function css_get_frame_processing_time_end: 1F41 */
+/* function css_get_frame_processing_time_end: 1F74 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_any_pending_mask
@@ -1427,13 +1427,13 @@
 #define HIVE_ADDR_sp_event_any_pending_mask 0x2F0
 #define HIVE_SIZE_sp_event_any_pending_mask 8
 
-/* function ia_css_isys_sp_backend_push: 5A34 */
+/* function ia_css_isys_sp_backend_push: 5AEC */
 
 /* function sh_css_decode_tag_descr: 3D7 */
 
 /* function debug_enqueue_isp: 2E9 */
 
-/* function ia_css_spctrl_sp_uninit: 59B4 */
+/* function ia_css_spctrl_sp_uninit: 5A24 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SWITCH_CODE
@@ -1450,30 +1450,30 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x5818
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x5804
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_dis_bufs 140
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x5818
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x5804
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_dis_bufs 140
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_isp_idle
 #define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_isp_idle 0x4794
+#define HIVE_ADDR_sem_for_isp_idle 0x4780
 #define HIVE_SIZE_sem_for_isp_idle 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_isp_idle 0x4794
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x4780
 #define HIVE_SIZE_sp_sem_for_isp_idle 20
 
-/* function ia_css_dmaproxy_sp_write_byte_addr: 2F17 */
+/* function ia_css_dmaproxy_sp_write_byte_addr: 2F4A */
 
-/* function ia_css_dmaproxy_sp_init: 2E3D */
+/* function ia_css_dmaproxy_sp_init: 2E70 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_VAMEM_BASE
@@ -1490,46 +1490,46 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rawcopy_sp_tagger
 #define HIVE_MEM_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x61D8
+#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x61C8
 #define HIVE_SIZE_ia_css_rawcopy_sp_tagger 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x61D8
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x61C8
 #define HIVE_SIZE_sp_ia_css_rawcopy_sp_tagger 24
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x58A4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x5890
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_exp_ids 70
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x58A4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x5890
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_exp_ids 70
 
-/* function ia_css_queue_item_load: 4C1E */
+/* function ia_css_queue_item_load: 4C51 */
 
-/* function ia_css_spctrl_sp_get_state: 599F */
+/* function ia_css_spctrl_sp_get_state: 5A0F */
 
-/* function ia_css_isys_sp_token_map_uninit: 607A */
+/* function ia_css_isys_sp_token_map_uninit: 6132 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_callout_sp_thread
 #define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_callout_sp_thread 0x49BC
+#define HIVE_ADDR_callout_sp_thread 0x49A8
 #define HIVE_SIZE_callout_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_callout_sp_thread 0x49BC
+#define HIVE_ADDR_sp_callout_sp_thread 0x49A8
 #define HIVE_SIZE_sp_callout_sp_thread 4
 
-/* function thread_fiber_sp_init: E4A */
+/* function thread_fiber_sp_init: E7D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_SP_PMEM_BASE
@@ -1543,31 +1543,31 @@
 #define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
 #define HIVE_SIZE_sp_SP_PMEM_BASE 4
 
-/* function ia_css_isys_sp_token_map_snd_acquire_req: 5FD9 */
+/* function ia_css_isys_sp_token_map_snd_acquire_req: 6091 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_input_stream_format
 #define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_input_stream_format 0x3FF8
+#define HIVE_ADDR_sp_isp_input_stream_format 0x3FE4
 #define HIVE_SIZE_sp_isp_input_stream_format 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3FF8
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3FE4
 #define HIVE_SIZE_sp_sp_isp_input_stream_format 20
 
-/* function __mod: 6895 */
+/* function __mod: 694D */
 
-/* function ia_css_dmaproxy_sp_init_dmem_channel: 2F83 */
+/* function ia_css_dmaproxy_sp_init_dmem_channel: 2FB6 */
 
-/* function ia_css_thread_sp_join: D1A */
+/* function ia_css_thread_sp_join: D4D */
 
-/* function ia_css_dmaproxy_sp_add_command: 6F8B */
+/* function ia_css_dmaproxy_sp_add_command: 704C */
 
-/* function ia_css_sp_metadata_thread_func: 5815 */
+/* function ia_css_sp_metadata_thread_func: 5885 */
 
-/* function __sp_event_proxy_func_critical: 6928 */
+/* function __sp_event_proxy_func_critical: 69E0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_dmaproxy_sp_proxy_status
@@ -1581,27 +1581,29 @@
 #define HIVE_ADDR_sp_dmaproxy_sp_proxy_status 0x208
 #define HIVE_SIZE_sp_dmaproxy_sp_proxy_status 4
 
-/* function ia_css_sp_metadata_wait: 5966 */
+/* function ia_css_sp_metadata_wait: 59D6 */
 
-/* function ia_css_circbuf_peek_from_start: F27 */
+/* function ia_css_circbuf_peek_from_start: F5A */
 
-/* function ia_css_sp_rawcopy_buffer_is_locked: 56B0 */
+/* function ia_css_sp_rawcopy_buffer_is_locked: 56D4 */
 
-/* function ia_css_event_sp_encode: 32B5 */
+/* function ia_css_event_sp_encode: 32E8 */
 
-/* function ia_css_thread_sp_run: D8D */
+/* function ia_css_thread_sp_run: DC0 */
 
-/* function sp_isys_copy_func: 74A */
+/* function sp_isys_copy_func: 77D */
 
-/* function ia_css_isys_sp_backend_flush: 5AA3 */
+/* function ia_css_isys_sp_backend_flush: 5B5B */
 
-/* function ia_css_sp_isp_param_init_isp_memories: 4658 */
+/* function ia_css_isys_sp_backend_frame_exists: 5A7A */
 
-/* function register_isr: 8CE */
+/* function ia_css_sp_isp_param_init_isp_memories: 468B */
+
+/* function register_isr: 901 */
 
 /* function irq_raise: D3 */
 
-/* function ia_css_dmaproxy_sp_mmu_invalidate: 2D7B */
+/* function ia_css_dmaproxy_sp_mmu_invalidate: 2DAE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SRST_ADDRESS
@@ -1615,27 +1617,27 @@
 #define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x1BC
 #define HIVE_SIZE_sp_HIVE_IF_SRST_ADDRESS 16
 
-/* function pipeline_sp_initialize_stage: 1891 */
+/* function pipeline_sp_initialize_stage: 18C4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_frontend_states
 #define HIVE_MEM_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x6248
+#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x6238
 #define HIVE_SIZE_ia_css_isys_sp_frontend_states 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x6248
+#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x6238
 #define HIVE_SIZE_sp_ia_css_isys_sp_frontend_states 12
 
-/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6E87 */
+/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6F48 */
 
-/* function ia_css_ispctrl_sp_done_ds: 3550 */
+/* function ia_css_ispctrl_sp_done_ds: 3583 */
 
-/* function ia_css_sp_isp_param_get_mem_inits: 4633 */
+/* function ia_css_sp_isp_param_get_mem_inits: 4666 */
 
-/* function ia_css_parambuf_sp_init_buffer_queues: 1416 */
+/* function ia_css_parambuf_sp_init_buffer_queues: 1449 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_pfp_spref
@@ -1649,7 +1651,7 @@
 #define HIVE_ADDR_sp_vbuf_pfp_spref 0x2DC
 #define HIVE_SIZE_sp_vbuf_pfp_spref 4
 
-/* function input_system_cfg: AAF */
+/* function input_system_cfg: AE2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_HMEM_BASE
@@ -1666,148 +1668,148 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_frames
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x58EC
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x58D8
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_frames 280
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x58EC
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x58D8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_frames 280
 
-/* function ia_css_isys_sp_backend_release: 5B18 */
+/* function ia_css_isys_sp_backend_release: 5BD0 */
 
-/* function ia_css_isys_sp_backend_destroy: 5B42 */
+/* function ia_css_isys_sp_backend_destroy: 5BFA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_buffer_queue_handle
 #define HIVE_MEM_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_buffer_queue_handle 0x5A04
+#define HIVE_ADDR_sp2host_buffer_queue_handle 0x59F0
 #define HIVE_SIZE_sp2host_buffer_queue_handle 96
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x5A04
+#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x59F0
 #define HIVE_SIZE_sp_sp2host_buffer_queue_handle 96
 
-/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 5F9D */
+/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 6055 */
 
-/* function ia_css_ispctrl_sp_init_isp_vars: 4339 */
+/* function ia_css_ispctrl_sp_init_isp_vars: 436C */
 
-/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 5B95 */
+/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 5C4D */
 
-/* function sp_warning: 8E3 */
+/* function sp_warning: 916 */
 
-/* function ia_css_rmgr_sp_vbuf_enqueue: 636F */
+/* function ia_css_rmgr_sp_vbuf_enqueue: 6427 */
 
-/* function ia_css_tagger_sp_tag_exp_id: 1F53 */
+/* function ia_css_tagger_sp_tag_exp_id: 1F86 */
 
-/* function ia_css_dmaproxy_sp_write: 2F2E */
+/* function ia_css_dmaproxy_sp_write: 2F61 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_buff_pool_lock_params_handles
 #define HIVE_MEM_raw_buff_pool_lock_params_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_buff_pool_lock_params_handles 0x61F0
+#define HIVE_ADDR_raw_buff_pool_lock_params_handles 0x61E0
 #define HIVE_SIZE_raw_buff_pool_lock_params_handles 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_buff_pool_lock_params_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_buff_pool_lock_params_handles 0x61F0
+#define HIVE_ADDR_sp_raw_buff_pool_lock_params_handles 0x61E0
 #define HIVE_SIZE_sp_raw_buff_pool_lock_params_handles 60
 
-/* function ia_css_parambuf_sp_release_in_param: 1296 */
+/* function ia_css_parambuf_sp_release_in_param: 12C9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_irq_sw_interrupt_token
 #define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_irq_sw_interrupt_token 0x3FF4
+#define HIVE_ADDR_irq_sw_interrupt_token 0x3FE0
 #define HIVE_SIZE_irq_sw_interrupt_token 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3FF4
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3FE0
 #define HIVE_SIZE_sp_irq_sw_interrupt_token 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_addresses
 #define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_addresses 0x5E4C
+#define HIVE_ADDR_sp_isp_addresses 0x5E3C
 #define HIVE_SIZE_sp_isp_addresses 172
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_addresses 0x5E4C
+#define HIVE_ADDR_sp_sp_isp_addresses 0x5E3C
 #define HIVE_SIZE_sp_sp_isp_addresses 172
 
-/* function ia_css_rmgr_sp_acq_gen: 6294 */
+/* function ia_css_rmgr_sp_acq_gen: 634C */
 
-/* function receiver_reg_load: AC4 */
+/* function receiver_reg_load: AF7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isps
 #define HIVE_MEM_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_isps 0x6280
+#define HIVE_ADDR_isps 0x6270
 #define HIVE_SIZE_isps 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isps 0x6280
+#define HIVE_ADDR_sp_isps 0x6270
 #define HIVE_SIZE_sp_isps 28
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_queues_initialized
 #define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_queues_initialized 0x400C
+#define HIVE_ADDR_host_sp_queues_initialized 0x3FF8
 #define HIVE_SIZE_host_sp_queues_initialized 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_queues_initialized 0x400C
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3FF8
 #define HIVE_SIZE_sp_host_sp_queues_initialized 4
 
-/* function ia_css_queue_uninit: 4AC7 */
+/* function ia_css_queue_uninit: 4AFA */
 
-/* function ia_css_tagger_buf_sp_is_locked: 27C4 */
+/* function ia_css_tagger_buf_sp_is_locked: 27F7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_ispctrl_sp_isp_started
 #define HIVE_MEM_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5B0C
+#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5AF8
 #define HIVE_SIZE_ia_css_ispctrl_sp_isp_started 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5B0C
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5AF8
 #define HIVE_SIZE_sp_ia_css_ispctrl_sp_isp_started 4
 
-/* function ia_css_bufq_sp_release_dynamic_buf: 29C2 */
+/* function ia_css_bufq_sp_release_dynamic_buf: 29F5 */
 
-/* function ia_css_sp_metadata_thread_terminate: 594E */
+/* function ia_css_sp_metadata_thread_terminate: 59BE */
 
-/* function ia_css_dmaproxy_sp_set_height_exception: 3036 */
+/* function ia_css_dmaproxy_sp_set_height_exception: 3069 */
 
-/* function ia_css_dmaproxy_sp_init_vmem_channel: 2FB9 */
+/* function ia_css_dmaproxy_sp_init_vmem_channel: 2FEC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_num_ready_threads
 #define HIVE_MEM_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_num_ready_threads 0x49C4
+#define HIVE_ADDR_num_ready_threads 0x49B0
 #define HIVE_SIZE_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_num_ready_threads 0x49C4
+#define HIVE_ADDR_sp_num_ready_threads 0x49B0
 #define HIVE_SIZE_sp_num_ready_threads 4
 
-/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 2F00 */
+/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 2F33 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_spref
@@ -1824,54 +1826,54 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_metadata_thread
 #define HIVE_MEM_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_metadata_thread 0x4978
+#define HIVE_ADDR_sp_metadata_thread 0x4964
 #define HIVE_SIZE_sp_metadata_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_metadata_thread 0x4978
+#define HIVE_ADDR_sp_sp_metadata_thread 0x4964
 #define HIVE_SIZE_sp_sp_metadata_thread 68
 
-/* function ia_css_queue_enqueue: 4A07 */
+/* function ia_css_queue_enqueue: 4A3A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_request
 #define HIVE_MEM_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_request 0x49D0
+#define HIVE_ADDR_ia_css_flash_sp_request 0x49BC
 #define HIVE_SIZE_ia_css_flash_sp_request 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x49D0
+#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x49BC
 #define HIVE_SIZE_sp_ia_css_flash_sp_request 4
 
-/* function ia_css_dmaproxy_sp_vmem_write: 2EBA */
+/* function ia_css_dmaproxy_sp_vmem_write: 2EED */
 
-/* function ia_css_tagger_buf_sp_unmark: 286D */
+/* function ia_css_tagger_buf_sp_unmark: 28A0 */
 
-/* function ia_css_isys_sp_token_map_snd_capture_req: 5FFF */
+/* function ia_css_isys_sp_token_map_snd_capture_req: 60B7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_if
 #define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_if 0x47A8
+#define HIVE_ADDR_sem_for_reading_if 0x4794
 #define HIVE_SIZE_sem_for_reading_if 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_if 0x47A8
+#define HIVE_ADDR_sp_sem_for_reading_if 0x4794
 #define HIVE_SIZE_sp_sem_for_reading_if 20
 
-/* function sp_generate_interrupts: 985 */
+/* function sp_generate_interrupts: 9B8 */
 
-/* function ia_css_pipeline_sp_start: 17A4 */
+/* function ia_css_pipeline_sp_start: 17D7 */
 
-/* function ia_css_sp_rawcopy_init: 50A2 */
+/* function ia_css_sp_rawcopy_init: 50D5 */
 
-/* function tmr_clock_read: A96 */
+/* function tmr_clock_read: AC9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_BAMEM_BASE
@@ -1885,65 +1887,65 @@
 #define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x2E8
 #define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
 
-/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5C4D */
+/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5D05 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A64
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A50
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A64
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A50
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_mem_map
 #define HIVE_MEM_mem_map scalar_processor_2400_dmem
-#define HIVE_ADDR_mem_map 0x4010
+#define HIVE_ADDR_mem_map 0x3FFC
 #define HIVE_SIZE_mem_map 284
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_mem_map scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_mem_map 0x4010
+#define HIVE_ADDR_sp_mem_map 0x3FFC
 #define HIVE_SIZE_sp_mem_map 284
 
-/* function css_get_frame_processing_time_start: 1F4A */
+/* function css_get_frame_processing_time_start: 1F7D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame
 #define HIVE_MEM_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame 0x47BC
+#define HIVE_ADDR_sp_all_cbs_frame 0x47A8
 #define HIVE_SIZE_sp_all_cbs_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame 0x47BC
+#define HIVE_ADDR_sp_sp_all_cbs_frame 0x47A8
 #define HIVE_SIZE_sp_sp_all_cbs_frame 16
 
-/* function thread_sp_queue_print: DAA */
+/* function thread_sp_queue_print: DDD */
 
-/* function sp_notify_eof: 931 */
+/* function sp_notify_eof: 964 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_str2mem
 #define HIVE_MEM_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_str2mem 0x47CC
+#define HIVE_ADDR_sem_for_str2mem 0x47B8
 #define HIVE_SIZE_sem_for_str2mem 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_str2mem 0x47CC
+#define HIVE_ADDR_sp_sem_for_str2mem 0x47B8
 #define HIVE_SIZE_sp_sem_for_str2mem 20
 
-/* function ia_css_bufq_sp_acquire_dynamic_buf: 2BCF */
+/* function ia_css_bufq_sp_acquire_dynamic_buf: 2C02 */
 
-/* function ia_css_circbuf_destroy: 1049 */
+/* function ia_css_circbuf_destroy: 107C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_PMEM_BASE
@@ -1957,38 +1959,38 @@
 #define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
 #define HIVE_SIZE_sp_ISP_PMEM_BASE 4
 
-/* function ia_css_sp_isp_param_mem_load: 45BB */
+/* function ia_css_sp_isp_param_mem_load: 45EE */
 
-/* function __div: 684D */
+/* function __div: 6905 */
 
-/* function ia_css_isys_sp_frontend_create: 5E2F */
+/* function ia_css_isys_sp_frontend_create: 5EE7 */
 
-/* function ia_css_rmgr_sp_refcount_release_vbuf: 638E */
+/* function ia_css_rmgr_sp_refcount_release_vbuf: 6446 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_in_use
 #define HIVE_MEM_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_in_use 0x49D4
+#define HIVE_ADDR_ia_css_flash_sp_in_use 0x49C0
 #define HIVE_SIZE_ia_css_flash_sp_in_use 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x49D4
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x49C0
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_use 4
 
-/* function ia_css_thread_sem_sp_wait: 6B06 */
+/* function ia_css_thread_sem_sp_wait: 6BBE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sleep_mode
 #define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sleep_mode 0x412C
+#define HIVE_ADDR_sp_sleep_mode 0x4118
 #define HIVE_SIZE_sp_sleep_mode 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sleep_mode 0x412C
+#define HIVE_ADDR_sp_sp_sleep_mode 0x4118
 #define HIVE_SIZE_sp_sp_sleep_mode 4
 
 /* function mmu_invalidate_cache: EA */
@@ -2005,27 +2007,23 @@
 #define HIVE_ADDR_sp_sp_max_cb_elems 0x140
 #define HIVE_SIZE_sp_sp_max_cb_elems 8
 
-/* function ia_css_dmaproxy_sp_register_channel_to_port: 2E78 */
+/* function ia_css_dmaproxy_sp_register_channel_to_port: 2EAB */
 
-/* function ia_css_queue_remote_init: 4AE9 */
+/* function ia_css_queue_remote_init: 4B1C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stop_req
 #define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stop_req 0x4660
+#define HIVE_ADDR_isp_stop_req 0x464C
 #define HIVE_SIZE_isp_stop_req 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stop_req 0x4660
+#define HIVE_ADDR_sp_isp_stop_req 0x464C
 #define HIVE_SIZE_sp_isp_stop_req 4
 
 #define HIVE_ICACHE_sp_critical_SEGMENT_START 0
 #define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
 
 #endif /* _sp_map_h_ */
-extern void sh_css_dump_sp_dmem(void);
-void sh_css_dump_sp_dmem(void)
-{
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/refcount/src/refcount.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/refcount/src/refcount.c
index 11f8603..9fe9b48 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/refcount/src/refcount.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/refcount/src/refcount.c
@@ -49,8 +49,13 @@ static struct ia_css_refcount_entry *refcount_find_entry(hrt_vaddress ptr,
 {
 	uint32_t i;
 
-	assert(ptr != 0);
-	assert(myrefcount.items != NULL);
+	if (ptr == 0)
+		return NULL;
+	if (myrefcount.items == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "refcount_find_entry(): Ref count not initiliazed!\n");
+		return NULL;
+	}
 
 	for (i = 0; i < myrefcount.size; i++) {
 
@@ -72,9 +77,16 @@ enum ia_css_err ia_css_refcount_init(uint32_t size)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	assert(size != 0);
-	assert(myrefcount.items == NULL);
-
+	if (size == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "ia_css_refcount_init(): Size of 0 for Ref count init!\n");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	if (myrefcount.items != NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				    "ia_css_refcount_init(): Ref count is already initialized\n");
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 	myrefcount.items =
 	    sh_css_malloc(sizeof(struct ia_css_refcount_entry) * size);
 	if (!myrefcount.items)
@@ -136,7 +148,11 @@ hrt_vaddress ia_css_refcount_increment(int32_t id, hrt_vaddress ptr)
 		entry->id = id;
 	}
 
-	assert(entry->id == id);
+	if (entry->id != id) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+			    "ia_css_refcount_increment(): Ref count IDS do not match!\n");
+		return mmgr_NULL;
+	}
 
 	if (entry->data == ptr)
 		entry->count += 1;
@@ -162,7 +178,11 @@ bool ia_css_refcount_decrement(int32_t id, hrt_vaddress ptr)
 	entry = refcount_find_entry(ptr, false);
 
 	if (entry) {
-		assert(entry->id == id);
+		if (entry->id != id) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+					    "ia_css_refcount_decrement(): Ref count IDS do not match!\n");
+			return false;
+		}
 		if (entry->count > 0) {
 			entry->count -= 1;
 			if (entry->count == 0) {
@@ -234,6 +254,8 @@ void ia_css_refcount_clear(int32_t id, clear_func clear_func_ptr)
 				mmgr_free(entry->data);
 			}
 			assert(entry->count == 0);
+			ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+					    "ia_css_refcount_clear(): Ref count for entry %x is not zero!\n", entry->id);
 			entry->data = mmgr_NULL;
 			entry->count = 0;
 			entry->id = 0;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c
index 243b120..3c708ef 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c
@@ -533,7 +533,8 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	pipe_binarydesc_get_offline(pipe,
 			       IA_CSS_BINARY_MODE_CAPTURE_PP,
 			       yuv_scaler_descr,
-			       NULL, in_info, out_infos, vf_info);
+			       NULL, in_info, out_infos,
+			       (vf_info->res.width == 0 && vf_info->res.height == 0) ? NULL : vf_info);
 
 	yuv_scaler_descr->enable_fractional_ds = true;
 	IA_CSS_LEAVE_PRIVATE("");
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/isp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/isp.c
index 3c7b86b..d2cb159 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/isp.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/isp.c
@@ -19,6 +19,7 @@
  *
  */
 
+#include <system_global.h>
 #include "isp.h"
 
 #ifndef __INLINE_ISP__
@@ -26,6 +27,7 @@
 #endif /* __INLINE_ISP__ */
 
 #include "assert_support.h"
+#include "platform_support.h"			/* hrt_sleep() */
 
 void cnd_isp_irq_enable(
 	const isp_ID_t		ID,
@@ -52,6 +54,12 @@ void isp_get_state(
 	assert(state != NULL);
 	assert(stall != NULL);
 
+#if defined(_hrt_sysmem_ident_address)
+	/* Patch to avoid compiler unused symbol warning in C_RUN build */
+	(void)__hrt_sysmem_ident_address;
+	(void)_hrt_sysmem_map_var;
+#endif
+
 	state->pc = isp_ctrl_load(ID, ISP_PC_REG);
 	state->status_register = sc;
 	state->is_broken = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_BROKEN_BIT);
@@ -95,3 +103,53 @@ void isp_get_state(
  */
 return;
 }
+
+/* ISP functions to control the ISP state from the host, even in crun. */
+#ifdef C_RUN
+volatile uint32_t isp_sleeping[N_ISP_ID] = { 0 }; /* Sleeping state per ISP */
+volatile uint32_t isp_ready   [N_ISP_ID] = { 1 }; /* Ready state per ISP */
+#endif
+
+/* Inspect readiness of an ISP indexed by ID */
+unsigned isp_is_ready(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	return isp_ready[ID];
+#else
+	return isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);
+#endif
+}
+
+/* Inspect sleeping of an ISP indexed by ID */
+unsigned isp_is_sleeping(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	return isp_sleeping[ID];
+#else
+	return isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);
+#endif
+}
+
+/* To be called by the host immediately before starting ISP ID. */
+void isp_start(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	isp_ready[ID] = 0;
+#endif
+}
+
+/* Wake up ISP ID. */
+void isp_wake(isp_ID_t ID)
+{
+	assert (ID < N_ISP_ID);
+#ifdef C_RUN
+	isp_sleeping[ID] = 0;
+#else
+	isp_ctrl_setbit(ID, ISP_SC_REG, ISP_START_BIT);
+	hrt_sleep();
+#endif
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/vmem.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/vmem.c
index 66aea95d..cf64acf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/vmem.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/vmem.c
@@ -27,6 +27,7 @@
 #include "ia_css_device_access.h"
 #endif
 #include "assert_support.h"
+#include "platform_support.h"			/* hrt_sleep() */
 
 typedef unsigned long long hive_uedge;
 typedef hive_uedge *hive_wide;
@@ -34,10 +35,10 @@ typedef hive_uedge *hive_wide;
 /* Copied from SDK: sim_semantics.c */
 
 /* subword bits move like this:         MSB[____xxxx____]LSB -> MSB[00000000xxxx]LSB */
-#define SUBWORD(w, start, end)     ((w & (((1ULL << (end-1))-1) << 1 | 1)) >> (start))
+#define SUBWORD(w, start, end)     (((w) & (((1ULL << ((end)-1))-1) << 1 | 1)) >> (start))
 
 /* inverse subword bits move like this: MSB[xxxx____xxxx]LSB -> MSB[xxxx0000xxxx]LSB */
-#define INV_SUBWORD(w, start, end) (w & (~(((1ULL << (end-1))-1) << 1 | 1) | ((1ULL << (start))-1)) )
+#define INV_SUBWORD(w, start, end) ((w) & (~(((1ULL << ((end)-1))-1) << 1 | 1) | ((1ULL << (start))-1)) )
 
 #define uedge_bits (8*sizeof(hive_uedge))
 #define move_lower_bits(target, target_bit, src, src_bit) move_subword(target, target_bit, src, 0, src_bit)
@@ -116,9 +117,9 @@ hive_sim_wide_pack(
 	if (elem_bits == uedge_bits) {
 		vector[start_elem] = elem[0];
 	} else if (elem_bits > uedge_bits) {
-		int bits_to_write = elem_bits;
-		int start_bit = elem_bits * index;
-		int i = 0;
+		unsigned bits_to_write = elem_bits;
+		unsigned start_bit = elem_bits * index;
+		unsigned i = 0;
 		for(; bits_to_write > uedge_bits; bits_to_write -= uedge_bits, i++, start_bit += uedge_bits) {
 			move_word(vector, start_bit, elem[i]);
 		}
@@ -135,11 +136,11 @@ static void load_vector (
 	const t_vmem_elem	*from)
 {
 	unsigned i;
-	unsigned size = sizeof(short)*ISP_NWAY;
 #ifdef C_RUN
 	hive_uedge *data = (hive_uedge *)from;
 	(void)ID;
 #else
+	unsigned size = sizeof(short)*ISP_NWAY;
 	VMEM_ARRAY(v, 2*ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
 	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
@@ -163,19 +164,19 @@ static void store_vector (
 	const t_vmem_elem	*from)
 {
 	unsigned i;
-	unsigned size = sizeof(short)*ISP_NWAY;
 #ifdef C_RUN
 	hive_uedge *data = (hive_uedge *)to;
 	(void)ID;
 	for (i = 0; i < ISP_NWAY; i++) {
-		hive_sim_wide_pack(data, &from[i], ISP_VEC_ELEMBITS, i);
+		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);
 	}
 #else
+	unsigned size = sizeof(short)*ISP_NWAY;
 	VMEM_ARRAY(v, 2*ISP_NWAY); /* Need 2 vectors to work around vmem hss bug */
 	//load_vector (&v[1][0], &to[ISP_NWAY]); /* Fetch the next vector, since it will be overwritten. */
 	hive_uedge *data = (hive_uedge *)v;
 	for (i = 0; i < ISP_NWAY; i++) {
-		hive_sim_wide_pack(data, &from[i], ISP_VEC_ELEMBITS, i);
+		hive_sim_wide_pack(data, (hive_wide)&from[i], ISP_VEC_ELEMBITS, i);
 	}
 	assert(ISP_BAMEM_BASE[ID] != (hrt_address)-1);
 #if !defined(HRT_MEMORY_ACCESS)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/isp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/isp_global.h
index ea913be..40870e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/isp_global.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/isp_global.h
@@ -46,22 +46,23 @@
 #define ISP_VEC_BYTES			(ISP_VEC_NELEMS*sizeof(uint16_t))
 
 /* ISP SC Registers */
-#define ISP_SC_REG				0x00
-#define ISP_PC_REG				0x07
+#define ISP_SC_REG			0x00
+#define ISP_PC_REG			0x07
 #define ISP_IRQ_READY_REG		0x00
 #define ISP_IRQ_CLEAR_REG		0x00
 
 /* ISP SC Register bits */
-#define ISP_RST_BIT				0x00
+#define ISP_RST_BIT			0x00
 #define ISP_START_BIT			0x01
 #define ISP_BREAK_BIT			0x02
-#define ISP_RUN_BIT				0x03
+#define ISP_RUN_BIT			0x03
 #define ISP_BROKEN_BIT			0x04
 #define ISP_IDLE_BIT			0x05     /* READY */
+#define ISP_SLEEPING_BIT		0x06
 #define ISP_STALLING_BIT		0x07
 #define ISP_IRQ_CLEAR_BIT		0x08
 #define ISP_IRQ_READY_BIT		0x0A
-#define ISP_SLEEPING_BIT		0x0B     /* SLEEPING_IRQ_MASK */
+#define ISP_IRQ_SLEEPING_BIT		0x0B
 
 /* ISP Register bits */
 #define ISP_CTRL_SINK_BIT		0x00
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/sp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/sp_global.h
index a8fdad2..64e4b0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/sp_global.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/sp_global.h
@@ -52,16 +52,17 @@
 #define SP_CTRL_SINK_REG		0x0A
 
 /* SP Register bits */
-#define SP_RST_BIT				0x00
+#define SP_RST_BIT			0x00
 #define SP_START_BIT			0x01
 #define SP_BREAK_BIT			0x02
-#define SP_RUN_BIT				0x03
+#define SP_RUN_BIT			0x03
 #define SP_BROKEN_BIT			0x04
-#define SP_IDLE_BIT				0x05     /* READY */
+#define SP_IDLE_BIT			0x05     /* READY */
+#define SP_SLEEPING_BIT			0x06
 #define SP_STALLING_BIT			0x07
 #define SP_IRQ_CLEAR_BIT		0x08
 #define SP_IRQ_READY_BIT		0x0A
-#define SP_SLEEPING_BIT			0x0B     /* SLEEPING_IRQ_MASK */
+#define SP_IRQ_SLEEPING_BIT		0x0B
 
 #define SP_ICACHE_INV_BIT		0x0C
 #define SP_IPREFETCH_EN_BIT		0x0D
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_params.c
index 04ce4fa..48d5bcf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_params.c
@@ -26,17 +26,18 @@
 #include "isp/kernels/anr/anr_2/ia_css_anr2.host.h"
 #include "isp/kernels/bh/bh_2/ia_css_bh.host.h"
 #include "isp/kernels/bnr/bnr_1.0/ia_css_bnr.host.h"
-#include "isp/kernels/bnr/bnr_2.2/ia_css_bnr22.host.h"
+#include "isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h"
 #include "isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h"
 #include "isp/kernels/crop/crop_1.0/ia_css_crop.host.h"
 #include "isp/kernels/csc/csc_1.0/ia_css_csc.host.h"
 #include "isp/kernels/ctc/ctc_1.0/ia_css_ctc.host.h"
-#include "isp/kernels/ctc/ctc_2/ia_css_ctc2.host.h"
-#include "isp/kernels/ctc/ctc_v2/ia_css_ctcv2.host.h"
+#include "isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h"
+#include "isp/kernels/ctc/ctc2/ia_css_ctc2.host.h"
 #include "isp/kernels/de/de_1.0/ia_css_de.host.h"
 #include "isp/kernels/de/de_2/ia_css_de2.host.h"
 #include "isp/kernels/dp/dp_1.0/ia_css_dp.host.h"
 #include "isp/kernels/fc/fc_1.0/ia_css_formats.host.h"
+#include "isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h"
 #include "isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.h"
 #include "isp/kernels/gc/gc_1.0/ia_css_gc.host.h"
 #include "isp/kernels/gc/gc_2/ia_css_gc2.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_config.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_config.h
index d9f35f1..0f89476 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_config.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_config.h
@@ -28,10 +28,10 @@
 #include "isp2601_config.h"
 #elif defined(ISP2500)
 #include "isp2500_config.h"
-#elif defined(ISP2400)
+#elif defined(ISP2400) || defined(ISP2401)
 #include "isp2400_config.h"
 #else
-#error "Please define a core {ISP2400, ISP2500, ISP2600, ISP2601}"
+#error "Please define a core {ISP2400, ISP2401, ISP2500, ISP2600, ISP2601}"
 #endif
 
 #endif /* __ISP_CONFIG_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_public.h
index f3877ae..798dcc6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isp_public.h
@@ -182,4 +182,12 @@ STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(
 	const uint16_t		x0,
 	const uint16_t		x1);
 
+unsigned isp_is_ready(isp_ID_t ID);
+
+unsigned isp_is_sleeping(isp_ID_t ID);
+
+void isp_start(isp_ID_t ID);
+
+void isp_wake(isp_ID_t ID);
+
 #endif /* __ISP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/misc_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/misc_support.h
index 7fea8e1..f8e33a1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/misc_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/misc_support.h
@@ -27,4 +27,7 @@
 #define NOT_USED(a) ((void)(a))
 #endif
 
+/* Calculate the  total bytes for pow(2) byte alignment */
+#define tot_bytes_for_pow2_align(pow2, cur_bytes)	((cur_bytes + (pow2 - 1)) & ~(pow2 - 1))
+
 #endif /* __MISC_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h
index 91ea849..feaa0e7 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h
@@ -39,7 +39,14 @@
 
 #if defined(_MSC_VER)
 #include <stdint.h>
+/* For ATE compilation define the bool */
+#if defined(_ATE_)
+#define bool int
+#define true 1
+#define false 0
+#else
 #include <stdbool.h>
+#endif
 #include <stddef.h>
 #include <limits.h>
 #include <errno.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h
index 2a5c911..10fb476 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h
index 46d2f21..b1606c6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h
@@ -304,6 +304,8 @@ struct ia_css_binary_xinfo {
 	enum ia_css_acc_type	     type;
 	CSS_ALIGN(int32_t	     num_output_formats, 8);
 	enum ia_css_frame_format     output_formats[IA_CSS_FRAME_FORMAT_NUM];
+	CSS_ALIGN(int32_t	     num_vf_formats, 8); /**< number of supported vf formats */
+	enum ia_css_frame_format     vf_formats[IA_CSS_FRAME_FORMAT_NUM]; /**< types of supported vf formats */
 	uint8_t			     num_output_pins;
 	ia_css_ptr		     xmem_addr;
 	CSS_ALIGN(const struct ia_css_blob_descr *blob, 8);
@@ -338,6 +340,8 @@ struct ia_css_sp_info {
 	uint32_t debug_stage; /**< thread/pipe post mortem debug */
 	uint32_t debug_stripe; /**< thread/pipe post mortem debug */
 #endif
+	uint32_t threads_stack; /**< sp thread's stack pointers */
+	uint32_t threads_stack_size; /**< sp thread's stack sizes */
 	uint32_t curr_binary_id;        /**< current binary id */
 	uint32_t raw_copy_line_count;   /**< raw copy line counter */
 	uint32_t ddr_parameter_address; /**< acc param ddrptr, sp dmem */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h
index 398adab..0ff0d90 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h
@@ -70,10 +70,14 @@ enum ia_css_fw_err {
  */
 enum ia_css_fw_warning {
 	IA_CSS_FW_WARNING_NONE,
-	IA_CSS_FW_WARNING_ISYS_QUEUE_FULL,
-	IA_CSS_FW_WARNING_PSYS_QUEUE_FULL,
-	IA_CSS_FW_WARNING_CIRCBUF_ALL_LOCKED,
-	IA_CSS_FW_WARNING_EXP_ID_LOCKED,
+	IA_CSS_FW_WARNING_ISYS_QUEUE_FULL, /** < CSS system delayed because of insufficient space in the ISys queue.
+		This warning can be avoided by de-queing ISYS buffers more timely. */
+	IA_CSS_FW_WARNING_PSYS_QUEUE_FULL, /** < CSS system delayed because of insufficient space in the PSys queue.
+		This warning can be avoided by de-queing PSYS buffers more timely. */
+	IA_CSS_FW_WARNING_CIRCBUF_ALL_LOCKED, /** < CSS system delayed because of insufficient available buffers.
+		This warning can be avoided by unlocking locked frame-buffers more timely. */
+	IA_CSS_FW_WARNING_EXP_ID_LOCKED, /** < Exposure ID skipped because the frame associated to it was still locked.
+		This warning can be avoided by unlocking locked frame-buffers more timely. */
 };
 
 #endif /* __IA_CSS_ERR_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h
index 677b2cb..2fbdfc1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h
index 183a4e5..e7da197 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h
index 42e20b5..1f658e7 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h
@@ -29,7 +29,7 @@
 #define __IA_CSS_VERSION_DATA_H
 
 
-#define CSS_VERSION_STRING "REL:20141014_42.2_1539; API:2.1.8.4; GIT:irci_20141013_1500__e1aae7#e1aae7f4badd10c57188ebad975743f469ced787; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
+#define CSS_VERSION_STRING "REL:20141029_44.3_1537; API:2.1.8.4; GIT:irci_20141028_0204__191ffe#191ffe4d489862c47f19ac58aea084d6204ef02b; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
 
 
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
new file mode 100644
index 0000000..70e69a2
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_load_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_LOAD_PARAM_H
+#define __IA_CSS_BAYER_LOAD_PARAM_H
+
+#include "ia_css_bayer_ls_param.h"
+
+#endif /* __IA_CSS_BAYER_LOAD_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
new file mode 100644
index 0000000..f344448
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_ls_param.h
@@ -0,0 +1,38 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_LS_PARAM_H
+#define __IA_CSS_BAYER_LS_PARAM_H
+
+#include "type_support.h"
+
+#define NUM_BAYER_LS 2
+
+/** bayer load/store */
+struct sh_css_isp_bayer_ls_isp_config {
+	uint32_t base_address[NUM_BAYER_LS];
+	uint32_t width[NUM_BAYER_LS];
+	uint32_t height[NUM_BAYER_LS];
+	uint32_t stride[NUM_BAYER_LS];
+};
+
+
+#endif /* __IA_CSS_BAYER_LS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
new file mode 100644
index 0000000..2cb77a4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bayer_ls/bayer_ls_1.0/ia_css_bayer_store_param.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_STORE_PARAM_H
+#define __IA_CSS_BAYER_STORE_PARAM_H
+
+#include "ia_css_bayer_ls_param.h"
+
+
+#endif /* __IA_CSS_BAYER_STORE_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
new file mode 100644
index 0000000..350f19b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
@@ -0,0 +1,129 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "type_support.h"
+#include "ia_css_bnr2_2.host.h"
+
+#ifndef IA_CSS_NO_DEBUG
+#include "ia_css_debug.h" /* ia_css_debug_dtrace() */
+#endif
+
+/* Default kernel parameters. */
+const struct ia_css_bnr2_2_config default_bnr2_2_config = {
+	200,
+	200,
+	200,
+	0,
+	0,
+	0,
+	200,
+	200,
+	200,
+	0,
+	0,
+	0,
+	0,
+	4096,
+	8191,
+	128,
+	1,
+	0,
+	0,
+	0,
+	8191,
+	0,
+	8191
+};
+
+void
+ia_css_bnr2_2_encode(
+	struct sh_css_isp_bnr2_2_params *to,
+	const struct ia_css_bnr2_2_config *from,
+	size_t size)
+{
+	(void)size;
+	to->d_var_gain_r = from->d_var_gain_r;
+	to->d_var_gain_g = from->d_var_gain_g;
+	to->d_var_gain_b = from->d_var_gain_b;
+	to->d_var_gain_slope_r = from->d_var_gain_slope_r;
+	to->d_var_gain_slope_g = from->d_var_gain_slope_g;
+	to->d_var_gain_slope_b = from->d_var_gain_slope_b;
+
+	to->n_var_gain_r = from->n_var_gain_r;
+	to->n_var_gain_g = from->n_var_gain_g;
+	to->n_var_gain_b = from->n_var_gain_b;
+	to->n_var_gain_slope_r = from->n_var_gain_slope_r;
+	to->n_var_gain_slope_g = from->n_var_gain_slope_g;
+	to->n_var_gain_slope_b = from->n_var_gain_slope_b;
+
+	to->dir_thres = from->dir_thres;
+	to->dir_thres_w = from->dir_thres_w;
+	to->var_offset_coef = from->var_offset_coef;
+
+	to->dir_gain = from->dir_gain;
+	to->detail_gain	= from->detail_gain;
+	to->detail_gain_divisor = from->detail_gain_divisor;
+	to->detail_level_offset = from->detail_level_offset;
+
+	to->d_var_th_min = from->d_var_th_min;
+	to->d_var_th_max = from->d_var_th_max;
+	to->n_var_th_min = from->n_var_th_min;
+	to->n_var_th_max = from->n_var_th_max;
+}
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnr2_2_debug_trace(
+	const struct ia_css_bnr2_2_config *bnr,
+	unsigned level)
+{
+	if (!bnr)
+		return;
+
+	ia_css_debug_dtrace(level, "Bayer Noise Reduction 2.2:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_r", bnr->d_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_g", bnr->d_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_b", bnr->d_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_r", bnr->d_var_gain_slope_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_g", bnr->d_var_gain_slope_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_gain_slope_b", bnr->d_var_gain_slope_b);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_r", bnr->n_var_gain_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_g", bnr->n_var_gain_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_b", bnr->n_var_gain_b);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_r", bnr->n_var_gain_slope_r);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_g", bnr->n_var_gain_slope_g);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_gain_slope_b", bnr->n_var_gain_slope_b);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres", bnr->dir_thres);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_thres_w", bnr->dir_thres_w);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "var_offset_coef", bnr->var_offset_coef);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dir_gain", bnr->dir_gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain", bnr->detail_gain);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_gain_divisor", bnr->detail_gain_divisor);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "detail_level_offset", bnr->detail_level_offset);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_min", bnr->d_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "d_var_th_max", bnr->d_var_th_max);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_min", bnr->n_var_th_min);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "n_var_th_max", bnr->n_var_th_max);
+}
+#endif /* IA_CSS_NO_DEBUG */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
new file mode 100644
index 0000000..aa1ac6a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_HOST_H
+#define __IA_CSS_BNR2_2_HOST_H
+
+#include "ia_css_bnr2_2_types.h"
+#include "ia_css_bnr2_2_param.h"
+
+extern const struct ia_css_bnr2_2_config default_bnr2_2_config;
+
+void
+ia_css_bnr2_2_encode(
+	struct sh_css_isp_bnr2_2_params *to,
+	const struct ia_css_bnr2_2_config *from,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnr2_2_debug_trace(
+	const struct ia_css_bnr2_2_config *config,
+	unsigned level);
+#endif
+
+#endif /* __IA_CSS_BNR2_2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
new file mode 100644
index 0000000..c0fdf06
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_param.h
@@ -0,0 +1,57 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_PARAM_H
+#define __IA_CSS_BNR2_2_PARAM_H
+
+#include "type_support.h"
+
+/* TEMP: for implementation purpose.... */
+#define BYPASS_BNR2_2		1
+
+/* BNR (Bayer Noise Reduction) ISP parameters */
+struct sh_css_isp_bnr2_2_params {
+	int32_t d_var_gain_r;
+	int32_t d_var_gain_g;
+	int32_t d_var_gain_b;
+	int32_t d_var_gain_slope_r;
+	int32_t d_var_gain_slope_g;
+	int32_t d_var_gain_slope_b;
+	int32_t n_var_gain_r;
+	int32_t n_var_gain_g;
+	int32_t n_var_gain_b;
+	int32_t n_var_gain_slope_r;
+	int32_t n_var_gain_slope_g;
+	int32_t n_var_gain_slope_b;
+	int32_t dir_thres;
+	int32_t dir_thres_w;
+	int32_t var_offset_coef;
+	int32_t dir_gain;
+	int32_t detail_gain;
+	int32_t detail_gain_divisor;
+	int32_t detail_level_offset;
+	int32_t d_var_th_min;
+	int32_t d_var_th_max;
+	int32_t n_var_th_min;
+	int32_t n_var_th_max;
+};
+
+#endif /* __IA_CSS_BNR2_2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
new file mode 100644
index 0000000..bf22d00
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
@@ -0,0 +1,63 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNR2_2_TYPES_H
+#define __IA_CSS_BNR2_2_TYPES_H
+
+#include "type_support.h" /* int32_t */
+
+/**
+ * \brief BNR2_2 public parameters.
+ * \details Struct with all parameters for the BNR2.2 kernel that can be set
+ * from the CSS API.
+ */
+struct ia_css_bnr2_2_config {
+	/* Directional variance gain for R/G/B components in dark region */
+	int32_t d_var_gain_r;
+	int32_t d_var_gain_g;
+	int32_t d_var_gain_b;
+	/* Slope of Directional variance gain between dark and bright region */
+	int32_t d_var_gain_slope_r;
+	int32_t d_var_gain_slope_g;
+	int32_t d_var_gain_slope_b;
+	/* Non-Directional variance gain for R/G/B components in dark region */
+	int32_t n_var_gain_r;
+	int32_t n_var_gain_g;
+	int32_t n_var_gain_b;
+	/* Slope of Non-Directional variance gain between dark and bright region */
+	int32_t n_var_gain_slope_r;
+	int32_t n_var_gain_slope_g;
+	int32_t n_var_gain_slope_b;
+
+	int32_t dir_thres;		/* Threshold for directional filtering */
+	int32_t dir_thres_w;		/* Threshold width for directional filtering */
+	int32_t var_offset_coef;	/* Variance offset coefficient */
+	int32_t dir_gain;		/* Gain for directional coefficient */
+	int32_t detail_gain;		/* Gain for low contrast texture control */
+	int32_t detail_gain_divisor;	/* Gain divisor for low contrast texture control */
+	int32_t detail_level_offset;	/* Bias value for low contrast texture control */
+	int32_t d_var_th_min;		/* Minimum clipping value for directional variance*/
+	int32_t d_var_th_max;		/* Maximum clipping value for diretional variance*/
+	int32_t n_var_th_min;		/* Minimum clipping value for non-directional variance*/
+	int32_t n_var_th_max;		/* Maximum clipping value for non-directional variance*/
+};
+
+#endif /* __IA_CSS_BNR2_2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
new file mode 100644
index 0000000..94ab59b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.c
@@ -0,0 +1,127 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+#include "assert_support.h"
+
+#include "ctc/ctc_1.0/ia_css_ctc.host.h"
+#include "ia_css_ctc1_5.host.h"
+
+static void ctc_gradient(
+	int *dydx, int *shift,
+	int y1, int y0, int x1, int x0)
+{
+	int frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int dydx_int;
+	int dydx_frc;
+	int sft;
+	/* max_dydx = the maxinum gradient = the maximum y (gain) */
+	int max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+
+	if (dx == 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() error, illegal division operation\n");
+		return;
+	} else {
+		dydx_int = dy / dx;
+		dydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;
+	}
+
+	assert(y0 >= 0 && y0 <= max_dydx);
+	assert(y1 >= 0 && y1 <= max_dydx);
+	assert(x0 < x1);
+	assert(dydx != NULL);
+	assert(shift != NULL);
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
+
+	/* search "sft" which meets this condition:
+		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
+		<= (((float)dy / (float)dx) * (1 << sft))
+		<= ((1 << IA_CSS_CTC_COEF_SHIFT) - 1) */
+	for (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {
+		int tmp_dydx = (dydx_int << sft)
+			     + (dydx_frc >> (frc_bits - sft));
+		if (tmp_dydx <= max_dydx) {
+			*dydx = tmp_dydx;
+			*shift = sft;
+		}
+		if (tmp_dydx >= max_dydx)
+			break;
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
+}
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from,
+	unsigned size)
+{
+	(void)size;
+	to->y0 = from->y0;
+	to->y1 = from->y1;
+	to->y2 = from->y2;
+	to->y3 = from->y3;
+	to->y4 = from->y4;
+	to->y5 = from->y5;
+
+	to->ce_gain_exp = from->ce_gain_exp;
+
+	to->x1 = from->x1;
+	to->x2 = from->x2;
+	to->x3 = from->x3;
+	to->x4 = from->x4;
+
+	ctc_gradient(&(to->dydx0),
+		     &(to->dydx0_shift),
+		     from->y1, from->y0,
+		     from->x1, 0);
+
+	ctc_gradient(&(to->dydx1),
+		     &(to->dydx1_shift),
+		     from->y2, from->y1,
+		     from->x2, from->x1);
+
+	ctc_gradient(&to->dydx2,
+		     &to->dydx2_shift,
+		     from->y3, from->y2,
+		     from->x3, from->x2);
+
+	ctc_gradient(&to->dydx3,
+		     &to->dydx3_shift,
+		     from->y4, from->y3,
+		     from->x4, from->x3);
+
+	ctc_gradient(&(to->dydx4),
+		     &(to->dydx4_shift),
+		     from->y5, from->y4,
+		     SH_CSS_BAYER_MAXVAL, from->x4);
+}
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
new file mode 100644
index 0000000..c1f6b15
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5.host.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC1_5_HOST_H
+#define __IA_CSS_CTC1_5_HOST_H
+
+#include "sh_css_params.h"
+
+#include "ia_css_ctc1_5_param.h"
+
+void
+ia_css_ctc_encode(
+	struct sh_css_isp_ctc_params *to,
+	const struct ia_css_ctc_config *from,
+	unsigned size);
+
+void
+ia_css_ctc_dump(
+	const struct sh_css_isp_ctc_params *ctc,
+	unsigned level);
+
+#endif /* __IA_CSS_CTC1_5_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
new file mode 100644
index 0000000..cc3cb36
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc1_5_param.h
@@ -0,0 +1,53 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTC1_5_PARAM_H
+#define __IA_CSS_CTC1_5_PARAM_H
+
+#include "type_support.h"
+#include "ctc/ctc_1.0/ia_css_ctc_param.h" /* vamem params */
+
+/* CTC (Color Tone Control) */
+struct sh_css_isp_ctc_params {
+	int32_t y0;
+	int32_t y1;
+	int32_t y2;
+	int32_t y3;
+	int32_t y4;
+	int32_t y5;
+	int32_t ce_gain_exp;
+	int32_t x1;
+	int32_t x2;
+	int32_t x3;
+	int32_t x4;
+	int32_t dydx0;
+	int32_t dydx0_shift;
+	int32_t dydx1;
+	int32_t dydx1_shift;
+	int32_t dydx2;
+	int32_t dydx2_shift;
+	int32_t dydx3;
+	int32_t dydx3_shift;
+	int32_t dydx4;
+	int32_t dydx4_shift;
+};
+
+#endif /* __IA_CSS_CTC1_5_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
new file mode 100644
index 0000000..8d57b9a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc1_5/ia_css_ctc_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_CTCX_PARAM_H
+#define __IA_CSS_CTCX_PARAM_H
+
+#include "ia_css_ctc1_5_param.h"
+
+#endif /* __IA_CSS_CTCX_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
new file mode 100644
index 0000000..d10e4ff
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
@@ -0,0 +1,166 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "assert_support.h"
+
+#include "ia_css_ctc2.host.h"
+#include <stdio.h>
+
+#define INEFFECTIVE_VAL 4096
+#define BASIC_VAL 819
+
+/*Default configuration of parameters for Ctc2
+*/
+const struct ia_css_ctc2_config default_ctc2_config = {
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	INEFFECTIVE_VAL, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	BASIC_VAL * 2, BASIC_VAL * 4, BASIC_VAL * 6,
+	BASIC_VAL * 8, INEFFECTIVE_VAL, INEFFECTIVE_VAL,
+	BASIC_VAL >> 1, BASIC_VAL};
+
+
+
+/* (dydx) = ctc2_slope(y1, y0, x1, x0)
+ * -----------------------------------------------
+ * Calculation of the Slope of a Line = ((y1 - y0) >> 8)/(x1 - x0)
+ *
+ * Note: y1, y0 , x1 & x0 must lie within the range 0 <-> 8191
+ */
+static int ctc2_slope(int y1, int y0, int x1, int x0)
+{
+	const int shift_val = 8;
+	const int max_slope = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;
+	int dy = y1 - y0;
+	int dx = x1 - x0;
+	int rounding = (dx+1) >> 1;
+	int dy_shift = dy << shift_val;
+	int slope, dydx;
+
+	/*Protection for paramater values, & avoiding zero divisions*/
+	assert(y0 >= 0 && y0 <= max_slope);
+	assert(y1 >= 0 && y1 <= max_slope);
+	assert(x0 >= 0 && x0 <= max_slope);
+	assert(x1 > 0 && x1 <= max_slope);
+	assert(dx > 0);
+
+	if (dy < 0) {
+		rounding = -rounding;
+	}
+	slope = (int) (dy_shift + rounding) / dx;
+
+	/*the slope must lie within the range
+	  (-max_slope-1) >= (dydx) >= (max_slope)
+	*/
+	if (slope <= -max_slope-1) {
+		dydx = -max_slope-1;
+	} else if (slope >= max_slope) {
+		dydx = max_slope;
+	} else {
+		dydx = slope;
+	}
+
+	return dydx;
+}
+
+/* (void) = ia_css_ctc2_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate Y parameters from userspace into ISP space
+ */
+void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
+			    const struct ia_css_ctc2_config *from)
+{
+	unsigned i, j;
+	const unsigned shffl_blck = 4;
+	const unsigned lenght_zeros = 11;
+	short dydx0, dydx1, dydx2, dydx3, dydx4;
+
+	/*
+	*  Calculation of slopes of lines interconnecting
+	*  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0
+	*/
+	dydx0 = ctc2_slope(from->y_y1, from->y_y0,
+			    from->y_x1, 0);
+	dydx1 = ctc2_slope(from->y_y2, from->y_y1,
+			    from->y_x2, from->y_x1);
+	dydx2 = ctc2_slope(from->y_y3, from->y_y2,
+			    from->y_x3, from->y_x2);
+	dydx3 = ctc2_slope(from->y_y4, from->y_y3,
+			    from->y_x4, from->y_x3);
+	dydx4 = ctc2_slope(from->y_y5, from->y_y4,
+			    SH_CSS_BAYER_MAXVAL, from->y_x4);
+
+	/*Fill 3 arrays with:
+	* - Luma input gain values y_y0, y_y1, y_y2, y_3, y_y4
+	* - Luma kneepoints 0, y_x1, y_x2, y_x3, y_x4
+	* - Calculated slopes dydx0, dyxd1, dydx2, dydx3, dydx4
+	*
+	* - Each 64-element array is divided in blocks of 16 elements:
+	*   the 5 parameters + zeros in the remaining 11 positions
+	* - All blocks of the same array will contain the same data
+	*/
+	for (i = 0; i < shffl_blck; i++) {
+		to->y_x[0][(i << shffl_blck)]     = 0;
+		to->y_x[0][(i << shffl_blck) + 1] = from->y_x1;
+		to->y_x[0][(i << shffl_blck) + 2] = from->y_x2;
+		to->y_x[0][(i << shffl_blck) + 3] = from->y_x3;
+		to->y_x[0][(i << shffl_blck) + 4] = from->y_x4;
+
+		to->y_y[0][(i << shffl_blck)]     = from->y_y0;
+		to->y_y[0][(i << shffl_blck) + 1] = from->y_y1;
+		to->y_y[0][(i << shffl_blck) + 2] = from->y_y2;
+		to->y_y[0][(i << shffl_blck) + 3] = from->y_y3;
+		to->y_y[0][(i << shffl_blck) + 4] = from->y_y4;
+
+		to->e_y_slope[0][(i << shffl_blck)]    = dydx0;
+		to->e_y_slope[0][(i << shffl_blck) +1] = dydx1;
+		to->e_y_slope[0][(i << shffl_blck) +2] = dydx2;
+		to->e_y_slope[0][(i << shffl_blck) +3] = dydx3;
+		to->e_y_slope[0][(i << shffl_blck) +4] = dydx4;
+
+		for (j = 0; j < lenght_zeros; j++) {
+			to->y_x[0][(i << shffl_blck)+ 5 + j] = 0;
+			to->y_y[0][(i << shffl_blck)+ 5 + j] = 0;
+			to->e_y_slope[0][(i << shffl_blck)+ 5 + j] = 0;
+		}
+	}
+}
+
+/* (void) = ia_css_ctc2_dmem_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void ia_css_ctc2_dmem_encode(struct ia_css_isp_ctc2_dmem_params *to,
+			     struct ia_css_ctc2_config *from)
+{
+	to->uv_y0 = from->uv_y0;
+	to->uv_y1 = from->uv_y1;
+	to->uv_x0 = from->uv_x0;
+	to->uv_x1 = from->uv_x1;
+
+	/*Slope Calculation*/
+	to->uv_dydx = ctc2_slope(from->uv_y1, from->uv_y0,
+				  from->uv_x1, from->uv_x0);
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
new file mode 100644
index 0000000..e5e5b39
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
@@ -0,0 +1,41 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_HOST_H
+#define __IA_CSS_CTC2_HOST_H
+
+#include "ia_css_ctc2_param.h"
+#include "ia_css_ctc2_types.h"
+
+extern const struct ia_css_ctc2_config default_ctc2_config;
+
+/*Encode Functions to translate parameters from userspace into ISP space*/
+
+void ia_css_ctc2_vmem_encode(struct ia_css_isp_ctc2_vmem_params *to,
+			     const struct ia_css_ctc2_config *from);
+
+void ia_css_ctc2_dmem_encode(struct ia_css_isp_ctc2_dmem_params *to,
+			     struct ia_css_ctc2_config *from);
+
+#endif /* __IA_CSS_CTC2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
new file mode 100644
index 0000000..4cc81c6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
@@ -0,0 +1,59 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_PARAM_H
+#define __IA_CSS_CTC2_PARAM_H
+
+#define IA_CSS_CTC_COEF_SHIFT          13
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+/* CTC (Chroma Tone Control)ISP Parameters */
+
+/*VMEM Luma params*/
+struct ia_css_isp_ctc2_vmem_params {
+	/**< Gains by Y(Luma) at Y = 0.0,Y_X1, Y_X2, Y_X3, Y_X4*/
+	VMEM_ARRAY(y_x, ISP_VEC_NELEMS);
+	/** kneepoints by Y(Luma) 0.0, y_x1, y_x2, y _x3, y_x4*/
+	VMEM_ARRAY(y_y, ISP_VEC_NELEMS);
+	/** Slopes of lines interconnecting
+	 *  0.0 -> y_x1 -> y_x2 -> y _x3 -> y_x4 -> 1.0*/
+	VMEM_ARRAY(e_y_slope, ISP_VEC_NELEMS);
+};
+
+/*DMEM Chroma params*/
+struct ia_css_isp_ctc2_dmem_params {
+
+	/** Gains by UV(Chroma) under kneepoints uv_x0 and uv_x1*/
+	int32_t uv_y0;
+	int32_t uv_y1;
+
+	/** Kneepoints by UV(Chroma)- uv_x0 and uv_x1*/
+	int32_t uv_x0;
+	int32_t uv_x1;
+
+	/** Slope of line interconnecting uv_x0 -> uv_x1*/
+	int32_t uv_dydx;
+
+};
+#endif /* __IA_CSS_CTC2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
new file mode 100644
index 0000000..028535a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
@@ -0,0 +1,65 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_CTC2_TYPES_H
+#define __IA_CSS_CTC2_TYPES_H
+
+/** Chroma Tone Control configuration.
+*
+*  ISP block: CTC2 (CTC by polygonal approximation)
+* (ISP1: CTC1 (CTC by look-up table) is used.)
+*  ISP2: CTC2 is used.
+*  ISP261: CTC2 (CTC by Fast Approximate Distance)
+*/
+struct ia_css_ctc2_config {
+
+	/**< Gains by Y(Luma) at Y =0.0,Y_X1, Y_X2, Y_X3, Y_X4 and Y_X5
+	*   --default/ineffective value: 4096(0.5f)
+	*/
+	uint16_t y_y0;
+	uint16_t y_y1;
+	uint16_t y_y2;
+	uint16_t y_y3;
+	uint16_t y_y4;
+	uint16_t y_y5;
+	/** 1st-4th  kneepoints by Y(Luma) --default/ineffective value:n/a
+	*   requirement: 0.0 < y_x1 < y_x2 <y _x3 < y_x4 < 1.0
+	*/
+	uint16_t y_x1;
+	uint16_t y_x2;
+	uint16_t y_x3;
+	uint16_t y_x4;
+	/** Gains by UV(Chroma) under threholds uv_x0 and uv_x1
+	*   --default/ineffective value: 4096(0.5f)
+	*/
+	uint16_t uv_y0;
+	uint16_t uv_y1;
+	/** Minimum and Maximum Thresholds by UV(Chroma)- uv_x0 and uv_x1
+	*   --default/ineffective value: n/a
+	*/
+	uint16_t uv_x0;
+	uint16_t uv_x1;
+	};
+
+#endif /* __IA_CSS_CTC2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
index a89ff8e..6b23ed5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
@@ -22,11 +22,6 @@
 #include "ia_css_dpc2.host.h"
 #include "assert_support.h"
 
-#define METRIC1_ONE_FP	(1<<12)
-#define METRIC2_ONE_FP	(1<<5)
-#define METRIC3_ONE_FP	(1<<12)
-#define WBGAIN_ONE_FP	(1<<9)
-
 void
 ia_css_dpc2_encode(
 	struct ia_css_isp_dpc2_params *to,
@@ -44,20 +39,13 @@ ia_css_dpc2_encode(
 	assert ((from->wb_gain_b  > 0) && (from->wb_gain_b  < 16*WBGAIN_ONE_FP));
 	assert ((from->wb_gain_gb > 0) && (from->wb_gain_gb < 16*WBGAIN_ONE_FP));
 
-	/* TODO: BBBs */
-	to->one_plus_metric1  = METRIC1_ONE_FP + from->metric1;
-	to->one_minus_metric1 = METRIC1_ONE_FP - from->metric1;
-	to->one_plus_metric3  = METRIC3_ONE_FP + from->metric3;
+	to->metric1 = from->metric1;
+	to->metric2 = from->metric2;
+	to->metric3 = from->metric3;
 
 	to->wb_gain_gr = from->wb_gain_gr;
 	to->wb_gain_r  = from->wb_gain_r;
 	to->wb_gain_b  = from->wb_gain_b;
 	to->wb_gain_gb = from->wb_gain_gb;
-
-	/* TODO: Double-check the precision here by MUL and SHIFT operation */
-	to->wb_gain_gr_scaled_by_metric2 = (from->wb_gain_gr * from->metric2) >> 13;
-	to->wb_gain_r_scaled_by_metric2  = (from->wb_gain_r  * from->metric2) >> 13;
-	to->wb_gain_b_scaled_by_metric2  = (from->wb_gain_b  * from->metric2) >> 13;
-	to->wb_gain_gb_scaled_by_metric2 = (from->wb_gain_gb * from->metric2) >> 13;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
index 860a90f..6402cdc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_param.h
@@ -48,17 +48,13 @@
 
 
 struct ia_css_isp_dpc2_params {
-	int32_t one_plus_metric1;
-	int32_t one_minus_metric1;
-	int32_t one_plus_metric3;
+	int32_t metric1;
+	int32_t metric2;
+	int32_t metric3;
 	int32_t wb_gain_gr;
 	int32_t wb_gain_r;
 	int32_t wb_gain_b;
 	int32_t wb_gain_gb;
-	int32_t wb_gain_gr_scaled_by_metric2;
-	int32_t wb_gain_r_scaled_by_metric2;
-	int32_t wb_gain_b_scaled_by_metric2;
-	int32_t wb_gain_gb_scaled_by_metric2;
 };
 
 #endif /* __IA_CSS_DPC2_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
index a55dddf..ae21f2b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
@@ -23,6 +23,11 @@
 #define __IA_CSS_DPC2_TYPES_H
 
 #include "type_support.h"
+#define METRIC1_ONE_FP	(1<<12)
+#define METRIC2_ONE_FP	(1<<5)
+#define METRIC3_ONE_FP	(1<<12)
+#define WBGAIN_ONE_FP	(1<<9)
+
 
 struct ia_css_dpc2_config {
 	int32_t metric1;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
index 44bc726..e70ab33 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
@@ -31,10 +31,13 @@
 void
 ia_css_eed1_8_encode(
 	struct ia_css_isp_eed1_8_params *to,
-	const struct ia_css_eed1_8_config *from)
+	const struct ia_css_eed1_8_config *from,
+	size_t size)
 {
 	int i;
 
+	(void)size;
+
 	to->rbzp_strength = from->rbzp_strength;
 
 	to->fcstrength = from->fcstrength;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
index bbd23db..053bd1e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
@@ -29,7 +29,8 @@
 void
 ia_css_eed1_8_encode(
 	struct ia_css_isp_eed1_8_params *to,
-	const struct ia_css_eed1_8_config *from);
+	const struct ia_css_eed1_8_config *from,
+	size_t size);
 
 #ifndef IA_CSS_NO_DEBUG
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
index 135b9ef..d2bd1b5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
@@ -23,8 +23,20 @@
 #define __IA_CSS_EED1_8_PARAM_H
 
 #include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
 #include "ia_css_eed1_8_types.h" /* IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS */
 
+/* Define size of the state..... TODO: check if this is the correct place */
+/* 4 planes : GR, R, B, GB */
+#define NUM_PLANES		4
+/* 3 lines state per color plane input_line_state */
+#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(2 * NUM_PLANES)
+/* ToDo: Move this to testsetup */
+#define MAX_FRAME_SIMDWIDTH	30
+/* Each plane has width equal to half frame line */
+#define EED1_8_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+
 /* EED (Edge Enhancing Demosaic) ISP parameters */
 struct ia_css_isp_eed1_8_params {
 	int32_t rbzp_strength;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
new file mode 100644
index 0000000..75efce7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
@@ -0,0 +1,34 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_EED1_8_STATE_H
+#define __IA_CSS_EED1_8_STATE_H
+
+#include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
+
+#include "ia_css_eed1_8_param.h"
+
+struct ia_css_isp_eed1_8_vmem_state {
+	VMEM_ARRAY(eed1_8_input_lines[EED1_8_STATE_INPUT_BUFFER_HEIGHT], EED1_8_STATE_INPUT_BUFFER_WIDTH*ISP_NWAY);
+};
+
+#endif /* __IA_CSS_EED1_8_STATE_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
new file mode 100644
index 0000000..3cb5e35
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
@@ -0,0 +1,54 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#include "ia_css_debug.h"
+
+#include "ia_css_fixedbds.host.h"
+
+void
+ia_css_bds_encode(
+	struct sh_css_isp_bds_params *to,
+	const struct ia_css_aa_config *from,
+	unsigned size)
+{
+	(void)size;
+	to->baf_strength = from->strength;
+}
+
+void
+ia_css_bds_dump(
+	const struct sh_css_isp_bds_params *raw,
+	unsigned level)
+{
+	(void)raw;
+	(void)level;
+}
+
+void
+ia_css_bds_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level)
+{
+  (void)config;
+  (void)level;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
new file mode 100644
index 0000000..560e7b4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
@@ -0,0 +1,44 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIXEDBDS_HOST_H
+#define __IA_CSS_FIXEDBDS_HOST_H
+
+#include "ia_css_binary.h"
+#include "ia_css_fixedbds_param.h"
+
+void
+ia_css_bds_encode(
+	struct sh_css_isp_bds_params *to,
+	const struct ia_css_aa_config *from,
+	unsigned size);
+
+void
+ia_css_bds_dump(
+	const struct sh_css_isp_bds_params *raw,
+	unsigned level);
+
+void
+ia_css_bds_debug_dtrace(
+	const struct ia_css_aa_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_FIXEDBDS_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
new file mode 100644
index 0000000..ded1d61
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_param.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_FIXEDBDS_PARAM_H
+#define __IA_CSS_FIXEDBDS_PARAM_H
+
+#include "type_support.h"
+
+struct sh_css_isp_bds_params {
+	int baf_strength;
+};
+
+#endif /* __IA_CSS_FIXEDBDS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
index 2b38a94..ec69f37 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds_types.h
@@ -19,8 +19,8 @@
  *
  */
 
-#ifndef __IA_CSS_FIXEDBDS_HOST_H
-#define __IA_CSS_FIXEDBDS_HOST_H
+#ifndef __IA_CSS_FIXEDBDS_TYPES_H
+#define __IA_CSS_FIXEDBDS_TYPES_H
 
 
 struct sh_css_bds_factor {
@@ -30,4 +30,4 @@ struct sh_css_bds_factor {
 };
 
 
-#endif	/*__IA_CSS_FIXEDBDS_HOST_H*/
+#endif	/*__IA_CSS_FIXEDBDS_TYPES_H*/
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c
index 264b80f..66e239c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * INTEL CONFIDENTIAL
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h
index b618004..430587d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h
index 89e39d3..7cc861d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h
index 8ea6202..d872fc2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141014_1500 */
-/* Release Version: irci_master_20141014_1500 */
+/* Release Version: irci_master_20141029_1500 */
+/* Release Version: irci_master_20141029_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
index a03cea4..0ca39b3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
@@ -19,9 +19,87 @@
  *
  */
 
+#ifndef IA_CSS_NO_DEBUG
 #include "ia_css_debug.h"
+#endif
 #include "ia_css_iefd2_6.host.h"
 
+/* Copy parameters to VMEM
+ */
+void
+ia_css_iefd2_6_vmem_encode(
+	struct ia_css_isp_iefd2_6_vmem_params *to,
+	const struct ia_css_iefd2_6_config *from,
+	size_t size)
+{
+	const int total_blocks = 4;
+	const int shuffle_block = 16;
+	unsigned i, j, base;
+	(void)size;
+
+	/* For configurable units parameters are copied to vmem. Per CU 3 arrays are copied:
+	 * x containing the x coordinates
+	 * a containing the slopes
+	 * b containing the intercept values.
+	 *
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* first init the vectors */
+	for(i = 0; i < total_blocks*shuffle_block; i++) {
+		to->e_cued_x[0][i] = 0;
+		to->e_cued_a[0][i] = 0;
+		to->e_cued_b[0][i] = 0;
+
+		to->e_cu_dir_x[0][i] = 0;
+		to->e_cu_dir_a[0][i] = 0;
+		to->e_cu_dir_b[0][i] = 0;
+
+		to->e_cu_non_dir_x[0][i] = 0;
+		to->e_cu_non_dir_a[0][i] = 0;
+		to->e_cu_non_dir_b[0][i] = 0;
+	}
+
+	/* Copy all data */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block*i;
+
+
+		to->e_cued_x[0][base] = 0;
+		to->e_cued_a[0][base] = 0;
+		to->e_cued_b[0][base] = from->cu_ed_slopes_b[1];
+
+		to->e_cu_dir_x[0][base] = 0;
+		to->e_cu_dir_a[0][base] = 0;
+		to->e_cu_dir_b[0][base] = from->cu_dir_sharp_slopes_b[1];
+
+		to->e_cu_non_dir_x[0][base] = 0;
+		to->e_cu_non_dir_a[0][base] = 0;
+		to->e_cu_non_dir_b[0][base] = from->cu_non_dir_sharp_slopes_b[1];
+
+		for (j = 1; j < 4; j++) {
+			to->e_cu_dir_a[0][base+j] = from->cu_dir_sharp_slopes_a[j];
+			to->e_cu_dir_b[0][base+j] = from->cu_dir_sharp_slopes_b[j];
+			to->e_cu_non_dir_a[0][base+j] = from->cu_non_dir_sharp_slopes_a[j];
+			to->e_cu_non_dir_b[0][base+j] = from->cu_non_dir_sharp_slopes_b[j];
+		}
+
+		for (j = 1; j < 5; j++) {
+			to->e_cu_dir_x[0][base+j] = from->cu_dir_sharp_points_x[j];
+			to->e_cu_non_dir_x[0][base+j] = from->cu_non_dir_sharp_points_x[j];
+		}
+
+
+		for (j = 1; j < 6; j++) {
+			to->e_cued_x[0][base+j] = from->cu_ed_points_x[j];
+			to->e_cued_a[0][base+j] = from->cu_ed_slopes_a[j];
+			to->e_cued_b[0][base+j] = from->cu_ed_slopes_b[j];
+		}
+
+		to->e_cued_x[0][base+6] = from->cu_ed_points_x[j];
+	}
+}
 
 void
 ia_css_iefd2_6_encode(
@@ -32,6 +110,9 @@ ia_css_iefd2_6_encode(
 	int i;
 
 	(void)size;
+
+	/* Copy parameters to dmem, as described in the KFS
+	 */
 	to->horver_diag_coeff		= from->horver_diag_coeff;
 	to->ed_horver_diag_coeff	= from->ed_horver_diag_coeff;
 	to->dir_smooth_enable		= from->dir_smooth_enable;
@@ -52,10 +133,10 @@ ia_css_iefd2_6_encode(
 	to->rad_cu_dir_sharp_x1		= from->rad_cu_dir_sharp_x1;
 	to->rad_cu_non_dir_sharp_x1	= from->rad_cu_non_dir_sharp_x1;
 	to->rad_dir_far_sharp_weight	= from->rad_dir_far_sharp_weight;
-	to->sharp_nega_lmt_txt		= from->sharp_nega_lmt_txt;
-	to->sharp_posi_lmt_txt		= from->sharp_posi_lmt_txt;
-	to->sharp_nega_lmt_dir		= from->sharp_nega_lmt_dir;
-	to->sharp_posi_lmt_dir		= from->sharp_posi_lmt_dir;
+	to->shrpn_nega_lmt_txt		= from->shrpn_nega_lmt_txt;
+	to->shrpn_posi_lmt_txt		= from->shrpn_posi_lmt_txt;
+	to->shrpn_nega_lmt_dir		= from->shrpn_nega_lmt_dir;
+	to->shrpn_posi_lmt_dir		= from->shrpn_posi_lmt_dir;
 	to->clamp_stitch		= from->clamp_stitch;
 	to->rad_enable			= from->rad_enable;
 	to->rad_x_origin		= from->rad_x_origin;
@@ -72,50 +153,22 @@ ia_css_iefd2_6_encode(
 
 	/* Setup for configurable units */
 	/* First copy the hardcoded items */
-
 	to->curad_x[0]			= 0;
 	to->curad_a[0]			= 0;
 	to->curad_b[0]			= from->cu_radial_slope_b[1];
-	to->e_cued_x[0]			= 0;
-	to->e_cued_a[0]			= 0;
-	to->e_cued_b[0]			= from->cu_ed_slopes_b[1];
-	to->e_cu_dir_x[0]		= 0;
-	to->e_cu_dir_a[0]		= 0;
-	to->e_cu_dir_b[0]		= from->cu_dir_sharp_slopes_b[1];
-	to->e_cu_non_dir_x[0]		= 0;
-	to->e_cu_non_dir_a[0]		= 0;
-	to->e_cu_non_dir_b[0]		= from->cu_non_dir_sharp_slopes_b[1];
 	to->e_cued2_a			= from->cu_ed2_slopes_a;
 	to->e_cu_vssnlm_a		= from->cu_vssnlm_slopes_a;
 
 	/* copying remaining array part */
-
-	for (i = 1; i < 3; i++)
-	{
-		to->e_cu_dir_a[i]		= from->cu_dir_sharp_slopes_a[i];
-		to->e_cu_dir_b[i]		= from->cu_dir_sharp_slopes_b[i];
-		to->e_cu_non_dir_a[i]		= from->cu_non_dir_sharp_slopes_a[i];
-		to->e_cu_non_dir_b[i]		= from->cu_non_dir_sharp_slopes_b[i];
-	}
-
-	for (i = 1; i < 4; i++)
-	{
-		to->e_cu_dir_x[i]		= from->cu_dir_sharp_points_x[i];
-		to->e_cu_non_dir_x[i]		= from->cu_non_dir_sharp_points_x[i];
-	}
-
 	for (i = 1; i < 5; i++)
 	{
 		to->curad_a[i]			= from->cu_radial_slope_a[i];
 		to->curad_b[i]			= from->cu_radial_slope_b[i];
-		to->e_cued_a[i]			= from->cu_ed_slopes_a[i];
-		to->e_cued_b[i]			= from->cu_ed_slopes_b[i];
 	}
 
 	for (i = 1; i < 6; i++)
 	{
 		to->curad_x[i]			= from->cu_radial_points_x[i];
-		to->e_cued_x[i]			= from->cu_ed_points_x[i];
 	}
 
 	to->e_cued2_b		= ((0-from->cu_ed2_points_x[1]) * from->cu_ed2_slopes_a)>>4;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
index 13c9a33..1f83f94 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
@@ -27,6 +27,12 @@
 #include "ia_css_iefd2_6_default.host.h"
 
 void
+ia_css_iefd2_6_vmem_encode(
+	struct ia_css_isp_iefd2_6_vmem_params *to,
+	const struct ia_css_iefd2_6_config *from,
+	size_t size);
+
+void
 ia_css_iefd2_6_encode(
 	struct ia_css_isp_iefd2_6_dmem_params *to,
 	const struct ia_css_iefd2_6_config *from,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
index b1688ce..e56f875 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
@@ -42,10 +42,10 @@ const struct ia_css_iefd2_6_config default_iefd2_6_config = {
 	.rad_cu_dir_sharp_x1 = 0,
 	.rad_cu_non_dir_sharp_x1 = 128,
 	.rad_dir_far_sharp_weight = 8,
-	.sharp_nega_lmt_txt = 1024,
-	.sharp_posi_lmt_txt = 1024,
-	.sharp_nega_lmt_dir = 128,
-	.sharp_posi_lmt_dir = 128,
+	.shrpn_nega_lmt_txt = 1024,
+	.shrpn_posi_lmt_txt = 1024,
+	.shrpn_nega_lmt_dir = 128,
+	.shrpn_posi_lmt_dir = 128,
 	.clamp_stitch = 0,
 	.rad_enable = true,
 	.rad_x_origin = 0,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
index 0310111..ace1bc4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
@@ -23,6 +23,19 @@
 #define __IA_CSS_IEFD2_6_PARAM_H
 
 #include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+struct ia_css_isp_iefd2_6_vmem_params {
+	VMEM_ARRAY(e_cued_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cued_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cued_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_dir_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cu_non_dir_b, ISP_VEC_NELEMS);
+};
 
 struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t horver_diag_coeff;
@@ -45,10 +58,10 @@ struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t rad_cu_dir_sharp_x1;
 	int32_t rad_cu_non_dir_sharp_x1;
 	int32_t rad_dir_far_sharp_weight;
-	int32_t sharp_nega_lmt_txt;
-	int32_t sharp_posi_lmt_txt;
-	int32_t sharp_nega_lmt_dir;
-	int32_t sharp_posi_lmt_dir;
+	int32_t shrpn_nega_lmt_txt;
+	int32_t shrpn_posi_lmt_txt;
+	int32_t shrpn_nega_lmt_dir;
+	int32_t shrpn_posi_lmt_dir;
 	int32_t clamp_stitch;
 	bool rad_enable;
 	int32_t rad_x_origin;
@@ -62,17 +75,8 @@ struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t vssnlm_y1;
 	int32_t vssnlm_y2;
 	int32_t vssnlm_y3;
-	int32_t e_cued_x[6];
-	int32_t e_cued_a[5];
-	int32_t e_cued_b[5];
 	int32_t e_cued2_a;
 	int32_t e_cued2_b;
-	int32_t e_cu_dir_x[4];
-	int32_t e_cu_dir_a[3];
-	int32_t e_cu_dir_b[3];
-	int32_t e_cu_non_dir_x[4];
-	int32_t e_cu_non_dir_a[3];
-	int32_t e_cu_non_dir_b[3];
 	int32_t curad_x[6];
 	int32_t curad_a[5];
 	int32_t curad_b[5];
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
index 264aa2d..18cfc8d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
@@ -80,14 +80,14 @@ struct ia_css_iefd2_6_config {
 						u9.0, [0,511], default 128, ineffective 0 */
 	int32_t rad_dir_far_sharp_weight;  /**< Weight of wide direct sharpening.
 						u1.12, [0,4096], default 8, ineffective 0 */
-	int32_t sharp_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
+	int32_t shrpn_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t sharp_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
+	int32_t shrpn_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t sharp_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
+	int32_t shrpn_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
-	int32_t sharp_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
+	int32_t shrpn_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
 	int32_t clamp_stitch;		   /**< Slope to stitch between clamped and unclamped edge values.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
new file mode 100644
index 0000000..2e999b9
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_load_param.h
@@ -0,0 +1,27 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_LOAD_PARAM_H
+#define __IA_CSS_YUV_LOAD_PARAM_H
+
+#include "ia_css_yuv_ls_param.h"
+
+#endif /* __IA_CSS_YUV_LOAD_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
new file mode 100644
index 0000000..fe12bf7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_ls_param.h
@@ -0,0 +1,42 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_LS_PARAM_H
+#define __IA_CSS_YUV_LS_PARAM_H
+
+#include "type_support.h"
+
+/* The number of load/store kernels in a pipeline can be greater than one.
+ * A kernel can consume more than one input or can produce more
+ * than one output.
+ */
+#define NUM_YUV_LS 2
+
+/** YUV load/store */
+struct sh_css_isp_yuv_ls_isp_config {
+	unsigned base_address[NUM_YUV_LS];
+	unsigned width[NUM_YUV_LS];
+	unsigned height[NUM_YUV_LS];
+	unsigned stride[NUM_YUV_LS];
+};
+
+
+#endif /* __IA_CSS_YUV_LS_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
new file mode 100644
index 0000000..88d9dea
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/yuv_ls/yuv_ls_1.0/ia_css_yuv_store_param.h
@@ -0,0 +1,28 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_YUV_STORE_PARAM_H
+#define __IA_CSS_YUV_STORE_PARAM_H
+
+#include "ia_css_yuv_ls_param.h"
+
+
+#endif /* __IA_CSS_YUV_STORE_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h
index e2cd223..860eafc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h
@@ -129,6 +129,7 @@
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_YUVP2               131
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_REF               132
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_REF_STRIPED       133
+#define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_REF           134
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_DVS               135
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR               136
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_STRIPED       137
@@ -195,6 +196,7 @@
 #define SH_CSS_BINARY_ID_IF_TO_BDS_RGBP_DVS_STATS           233
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_NO_DPC_OB              234
 #define SH_CSS_BINARY_ID_IF_TO_BDS_RGBP_DVS_STATS_STRIPED   235
+#define SH_CSS_BINARY_ID_IF_TO_REF                          236
 #define SH_CSS_BINARY_ID_IF_TO_DVS_STRIPED                  237
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_STRIPED                238
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1_STRIPED                239
@@ -211,6 +213,13 @@
 #define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STRIPED           250
 #define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STATS_C0          251
 #define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE            252
+#define SH_CSS_BINARY_ID_COPY_KERNELTEST_OUTPUT_SYSTEM      253
+#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE_C0         254
+#define SH_CSS_BINARY_ID_IF_TO_XNR                          255
+#define SH_CSS_BINARY_ID_IF_TO_XNR_STRIPED                  256
+#define SH_CSS_BINARY_ID_IF_TO_REF_STRIPED                  257
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS                   258
+
 
 #define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
 #define XMEM_SHORTS_PER_WORD         (HIVE_ISP_DDR_WORD_BITS/16)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c
index 9f074f7..2733d0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c
@@ -449,6 +449,21 @@ binary_supports_output_format(const struct ia_css_binary_xinfo *info,
 	return false;
 }
 
+static bool
+binary_supports_vf_format(const struct ia_css_binary_xinfo *info,
+			  enum ia_css_frame_format format)
+{
+	int i;
+
+	assert(info != NULL);
+
+	for (i = 0; i < info->num_vf_formats; i++) {
+		if (info->vf_formats[i] == format)
+			return true;
+	}
+	return false;
+}
+
 /* move to host part of bds module */
 static bool
 supports_bds_factor(uint32_t supported_factors,
@@ -464,8 +479,8 @@ binary_init_info(struct ia_css_binary_xinfo *info, unsigned int i,
 	const unsigned char *blob = sh_css_blob_info[i].blob;
 	unsigned size = sh_css_blob_info[i].header.blob.size;
 
-	assert(info != NULL);
-	assert(binary_found != NULL);
+	if ((info == NULL) || (binary_found == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	*info = sh_css_blob_info[i].header.info.isp;
 	*binary_found = blob != NULL;
@@ -756,8 +771,7 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	/* viewfinder output info */
 	if ((vf_info != NULL) && (vf_info->res.width != 0)) {
 		unsigned int vf_out_vecs, vf_out_width, vf_out_height;
-
-		binary->vf_frame_info.format = IA_CSS_FRAME_FORMAT_YUV_LINE;
+		binary->vf_frame_info.format = vf_info->format;
 		if (bin_out_info == NULL)
 			return IA_CSS_ERR_INTERNAL_ERROR;
 		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(bin_out_info->padded_width,
@@ -1166,6 +1180,18 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 			continue;
 		}
 
+		/* Check if vf_veceven supports the requested vf format */
+		if (xcandidate->num_output_pins == 1 &&
+			req_vf_info && candidate->enable.vf_veceven &&
+			!binary_supports_vf_format(xcandidate, req_vf_info->format)) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: (%d == %d) && (%p != NULL) && %d && !%d\n",
+				__LINE__, xcandidate->num_output_pins, 1,
+				req_vf_info, candidate->enable.vf_veceven,
+				binary_supports_vf_format(xcandidate, req_vf_info->format));
+			continue;
+		}
+
 		if (!supports_bds_factor(candidate->bds.supported_bds_factors,
 		    descr->required_bds_factor)) {
 			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h
index 9761b66..f2c4b16 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h
@@ -151,6 +151,13 @@ ia_css_debug_dtrace(unsigned int level, const char *fmt, ...)
 }
 #endif
 
+/*! \brief Dump sp thread's stack contents
+ * SP thread's stack contents are set to 0xcafecafe. This function dumps the
+ * stack to inspect if the stack's boundaries are compromised.
+ * \return	None
+ */
+void ia_css_debug_dump_sp_stack_info(void);
+
 /*! \brief Function to set the global dtrace verbosity level.
  * \param[in]	trace_level	Maximum level of the messages to be traced.
  * \return	None
@@ -227,17 +234,23 @@ void ia_css_debug_dump_dma_isp_fifo_state(void);
  */
 void ia_css_debug_dump_dma_sp_fifo_state(void);
 
-/*! \brief Dump pif isp fifo state
+/*! \brief Dump pif A isp fifo state
+ * Dumps the primary input formatter state to tracing output.
+ * \return	None
+ */
+void ia_css_debug_dump_pif_a_isp_fifo_state(void);
+
+/*! \brief Dump pif B isp fifo state
  * Dumps the primary input formatter state to tracing output.
  * \return	None
  */
-void ia_css_debug_dump_pif_isp_fifo_state(void);
+void ia_css_debug_dump_pif_b_isp_fifo_state(void);
 
 /*! \brief Dump stream-to-memory sp fifo state
  * Dumps the stream-to-memory block state to tracing output.
  * \return	None
  */
-extern void ia_css_debug_dump_str2mem_sp_fifo_state(void);
+void ia_css_debug_dump_str2mem_sp_fifo_state(void);
 
 /*! \brief Dump isp sp fifo state
  * Dumps the isp sp fifo state to tracing output.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c
index 32bcdaf..36c321b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c
@@ -65,6 +65,7 @@
 #include "sp.h"
 #include "isp.h"
 #include "type_support.h"
+#include "math_support.h" /* CEIL_DIV */
 #if defined(HAS_INPUT_FORMATTER_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
 #include "input_system.h"	/* input_formatter_reg_load */
 #include "gp_device.h"		/* gp_device_reg_load */
@@ -119,6 +120,12 @@ unsigned int ia_css_debug_trace_level = IA_CSS_DEBUG_WARNING;
 
 #define ENABLE_LINE_MAX_LENGTH (25)
 
+/*
+ * TODO:SH_CSS_MAX_SP_THREADS is not the max number of sp threads
+ * future rework should fix this and remove the define MAX_THREAD_NUM
+ */
+#define MAX_THREAD_NUM (SH_CSS_MAX_SP_THREADS + SH_CSS_MAX_SP_INTERNAL_THREADS)
+
 static struct pipe_graph_class {
 	bool do_init;
 	int height;
@@ -151,6 +158,87 @@ static const char * const pipe_id_to_str[] = {
 static char dot_id_input_bin[SH_CSS_MAX_BINARY_NAME+10];
 static char ring_buffer[200];
 
+#if !defined(C_RUN) && !defined(HRT_UNSCHED)
+static void debug_dump_long_array_formatted(
+	const sp_ID_t sp_id,
+	hrt_address stack_sp_addr,
+	unsigned stack_size)
+{
+	unsigned int i;
+	uint32_t val;
+	uint32_t addr = (uint32_t) stack_sp_addr;
+	uint32_t stack_size_words = CEIL_DIV(stack_size, sizeof(uint32_t));
+
+	/* When size is not multiple of four, last word is only relevant for
+	 * remaining bytes */
+	for (i = 0; i < stack_size_words; i++) {
+		val = sp_dmem_load_uint32(sp_id, (hrt_address)addr);
+		if ((i%8) == 0)
+			ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "\n");
+
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "0x%08x ", val);
+		addr += sizeof(uint32_t);
+	}
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "\n");
+}
+
+static void debug_dump_sp_stack_info(
+	const sp_ID_t sp_id)
+{
+	const struct ia_css_fw_info *fw;
+	unsigned int HIVE_ADDR_sp_threads_stack;
+	unsigned int HIVE_ADDR_sp_threads_stack_size;
+	uint32_t stack_sizes[MAX_THREAD_NUM];
+	uint32_t stack_sp_addr[MAX_THREAD_NUM];
+	unsigned int i;
+
+	fw = &sh_css_sp_fw;
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE, "sp_id(%u) stack info\n", sp_id);
+	ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+		"from objects stack_addr_offset:0x%x stack_size_offset:0x%x\n",
+		fw->info.sp.threads_stack,
+		fw->info.sp.threads_stack_size);
+
+	HIVE_ADDR_sp_threads_stack = fw->info.sp.threads_stack;
+	HIVE_ADDR_sp_threads_stack_size = fw->info.sp.threads_stack_size;
+
+	if (fw->info.sp.threads_stack == 0 ||
+		fw->info.sp.threads_stack_size == 0)
+		return;
+
+	(void) HIVE_ADDR_sp_threads_stack;
+	(void) HIVE_ADDR_sp_threads_stack_size;
+
+	sp_dmem_load(sp_id,
+		(unsigned int)sp_address_of(sp_threads_stack),
+		&stack_sp_addr, sizeof(stack_sp_addr));
+	sp_dmem_load(sp_id,
+		(unsigned int)sp_address_of(sp_threads_stack_size),
+		&stack_sizes, sizeof(stack_sizes));
+
+	for (i = 0 ; i < MAX_THREAD_NUM; i++) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_VERBOSE,
+			"thread: %u stack_addr: 0x%08x stack_size: %u\n",
+			i, stack_sp_addr[i], stack_sizes[i]);
+		debug_dump_long_array_formatted(sp_id, (hrt_address)stack_sp_addr[i],
+			stack_sizes[i]);
+	}
+}
+
+void ia_css_debug_dump_sp_stack_info(void)
+{
+	debug_dump_sp_stack_info(SP0_ID);
+}
+#else
+/* Empty def for crun */
+void ia_css_debug_dump_sp_stack_info(void)
+{
+}
+#endif /* #if __HIVECC */
+
+
 void ia_css_debug_set_dtrace_level(const unsigned int trace_level)
 {
 	ia_css_debug_trace_level = trace_level;
@@ -454,8 +542,59 @@ void ia_css_debug_dump_sp_state(void)
 	return;
 }
 
+static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
+					   const char *descr)
+{
+	assert(state != NULL);
+	assert(descr != NULL);
+
+	ia_css_debug_dtrace(2, "FIFO channel: %s\n", descr);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "source valid",
+			    state->src_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo accept",
+			    state->fifo_accept);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo valid",
+			    state->fifo_valid);
+	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "sink accept",
+			    state->sink_accept);
+	return;
+}
+
 #if !defined(HAS_NO_INPUT_FORMATTER) && defined(USE_INPUT_SYSTEM_VERSION_2)
-static void debug_print_if_state(input_formatter_state_t *state)
+void ia_css_debug_dump_pif_a_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
+	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
+	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A");
+}
+
+void ia_css_debug_dump_pif_b_isp_fifo_state(void)
+{
+	fifo_channel_state_t pif_to_isp, isp_to_pif;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_IF1_TO_ISP0, &pif_to_isp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_ISP0_TO_IF1, &isp_to_pif);
+	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF B to ISP");
+	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF B");
+}
+
+void ia_css_debug_dump_str2mem_sp_fifo_state(void)
+{
+	fifo_channel_state_t s2m_to_sp, sp_to_s2m;
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_STREAM2MEM0_TO_SP0, &s2m_to_sp);
+	fifo_channel_get_state(FIFO_MONITOR0_ID,
+			       FIFO_CHANNEL_SP0_TO_STREAM2MEM0, &sp_to_s2m);
+	debug_print_fifo_channel_state(&s2m_to_sp, "Stream-to-memory to SP");
+	debug_print_fifo_channel_state(&sp_to_s2m, "SP to stream-to-memory");
+}
+
+static void debug_print_if_state(input_formatter_state_t *state, const char *id)
 {
 	unsigned int val;
 
@@ -489,7 +628,7 @@ static void debug_print_if_state(input_formatter_state_t *state)
 	int st_block_fifo_when_no_req = state->block_fifo_when_no_req;
 
 	assert(state != NULL);
-	ia_css_debug_dtrace(2, "InputFormatter State:\n");
+	ia_css_debug_dtrace(2, "InputFormatter State (%s):\n", id);
 
 	ia_css_debug_dtrace(2, "\tConfiguration:\n");
 
@@ -777,8 +916,12 @@ void ia_css_debug_dump_if_state(void)
 	input_formatter_bin_state_t if_bin_state;
 
 	input_formatter_get_state(INPUT_FORMATTER0_ID, &if_state);
-	debug_print_if_state(&if_state);
-	ia_css_debug_dump_pif_isp_fifo_state();
+	debug_print_if_state(&if_state, "Primary IF A");
+	ia_css_debug_dump_pif_a_isp_fifo_state();
+
+	input_formatter_get_state(INPUT_FORMATTER1_ID, &if_state);
+	debug_print_if_state(&if_state, "Primary IF B");
+	ia_css_debug_dump_pif_b_isp_fifo_state();
 
 	input_formatter_bin_get_state(INPUT_FORMATTER3_ID, &if_bin_state);
 	debug_print_if_bin_state(&if_bin_state);
@@ -1057,46 +1200,6 @@ void ia_css_debug_dump_dma_state(void)
 	return;
 }
 
-static void debug_print_fifo_channel_state(const fifo_channel_state_t *state,
-					   const char *descr)
-{
-	assert(state != NULL);
-	assert(descr != NULL);
-
-	ia_css_debug_dtrace(2, "FIFO channel: %s\n", descr);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "source valid",
-			    state->src_valid);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo accept",
-			    state->fifo_accept);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "fifo valid",
-			    state->fifo_valid);
-	ia_css_debug_dtrace(2, "\t%-32s: %d\n", "sink accept",
-			    state->sink_accept);
-	return;
-}
-
-void ia_css_debug_dump_pif_isp_fifo_state(void)
-{
-	fifo_channel_state_t pif_to_isp, isp_to_pif;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
-	debug_print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
-	debug_print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A");
-}
-
-void ia_css_debug_dump_str2mem_sp_fifo_state(void)
-{
-	fifo_channel_state_t s2m_to_sp, sp_to_s2m;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_STREAM2MEM0_TO_SP0, &s2m_to_sp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-			       FIFO_CHANNEL_SP0_TO_STREAM2MEM0, &sp_to_s2m);
-	debug_print_fifo_channel_state(&s2m_to_sp, "Stream-to-memory to SP");
-	debug_print_fifo_channel_state(&sp_to_s2m, "SP to stream-to-memory");
-}
-
 void ia_css_debug_dump_dma_sp_fifo_state(void)
 {
 	fifo_channel_state_t dma_to_sp, sp_to_dma;
@@ -2506,11 +2609,6 @@ STORAGE_CLASS_INLINE void dtrace_dot(const char *fmt, ...)
 	va_end(ap);
 }
 #ifdef HAS_WATCHDOG_SP_THREAD_DEBUG
-/*
- * TODO:SH_CSS_MAX_SP_THREADS is not the max number of sp threads
- * future rework should fix this and remove the define MAX_THREAD_NUM
- */
-#define MAX_THREAD_NUM (SH_CSS_MAX_SP_THREADS + SH_CSS_MAX_SP_INTERNAL_THREADS)
 void sh_css_dump_thread_wait_info(void)
 {
 	const struct ia_css_fw_info *fw;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/frame/src/frame.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/frame/src/frame.c
index fd0cf99..91d4406 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/frame/src/frame.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/frame/src/frame.c
@@ -27,6 +27,10 @@
 #include "sh_css_internal.h"
 #include "memory_access.h"
 
+
+#define NV12_TILEY_TILE_WIDTH  128
+#define NV12_TILEY_TILE_HEIGHT  32
+
 /**************************************************************************
 **	Static functions declarations
 **************************************************************************/
@@ -380,6 +384,7 @@ enum ia_css_err ia_css_frame_init_planes(struct ia_css_frame *frame)
 		 */
 	case IA_CSS_FRAME_FORMAT_NV12:
 	case IA_CSS_FRAME_FORMAT_NV21:
+	case IA_CSS_FRAME_FORMAT_NV12_TILEY:
 		frame_init_nv_planes(frame, 2, 2);
 		break;
 		/* nv16 and nv61 have the same frame layout, only the data
@@ -454,6 +459,8 @@ void ia_css_frame_info_set_width(struct ia_css_frame_info *info,
 	    info->format == IA_CSS_FRAME_FORMAT_YUV_LINE)
 		info->padded_width =
 		    CEIL_MUL(align, 2 * HIVE_ISP_DDR_WORD_BYTES);
+	else if (info->format == IA_CSS_FRAME_FORMAT_NV12_TILEY)
+		info->padded_width = CEIL_MUL(align, NV12_TILEY_TILE_WIDTH);
 	else if (info->format == IA_CSS_FRAME_FORMAT_RAW ||
 		 info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED)
 		info->padded_width = CEIL_MUL(align, 2 * ISP_VEC_NELEMS);
@@ -468,11 +475,7 @@ void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
 	assert(info != NULL);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
 		"ia_css_frame_info_set_format() enter:\n");
-	/* yuv_line has 2*NWAY alignment */
 	info->format = format;
-	/* HACK: this resets the padded width incorrectly.
-	   Lex needs to fix this in the vf_veceven module. */
-	info->padded_width = CEIL_MUL(info->padded_width, 2 * ISP_VEC_NELEMS);
 }
 
 void ia_css_frame_info_init(struct ia_css_frame_info *info,
@@ -650,7 +653,7 @@ static void frame_init_mipi_plane(struct ia_css_frame *frame,
 	unsigned int stride;
 
 	stride = subpixels_per_line * bytes_per_pixel;
-	frame->data_bytes = 8388608;
+	frame->data_bytes = 8388608; /* 8*1024*1024 */
 	frame->valid = false;
 	frame->contiguous = true;
 	frame_init_plane(plane, subpixels_per_line, stride, height, 0);
@@ -666,6 +669,13 @@ static void frame_init_nv_planes(struct ia_css_frame *frame,
 	    uv_width = 2 * (y_width / horizontal_decimation),
 	    uv_height = y_height / vertical_decimation, y_bytes, uv_bytes;
 
+	if (IA_CSS_FRAME_FORMAT_NV12_TILEY == frame->info.format) {
+		y_width   = CEIL_MUL(y_width,   NV12_TILEY_TILE_WIDTH);
+		uv_width  = CEIL_MUL(uv_width,  NV12_TILEY_TILE_WIDTH);
+		y_height  = CEIL_MUL(y_height,  NV12_TILEY_TILE_HEIGHT);
+		uv_height = CEIL_MUL(uv_height, NV12_TILEY_TILE_HEIGHT);
+	}
+
 	y_bytes = y_width * y_height;
 	uv_bytes = uv_width * uv_height;
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/rx.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/rx.c
index 6448e9a..66c723a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/rx.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/rx.c
@@ -484,8 +484,13 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 	bool port_enabled[N_MIPI_PORT_ID];
 	bool any_port_enabled = false;
 	mipi_port_ID_t port;
-
-	assert(config != NULL);
+    
+    if ((config == NULL)
+            || (config->mode >= N_RX_MODE)
+            || (config->port >= N_MIPI_PORT_ID)) {
+            assert(0);
+            return;
+    }
 	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++) {
 		if (is_receiver_port_enabled(RX0_ID, port))
 			any_port_enabled = true;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/virtual_isys.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/virtual_isys.c
index 5222e77..1b57e4f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/virtual_isys.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/virtual_isys.c
@@ -174,6 +174,10 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
 		"ia_css_isys_stream_create() enter:\n");
 
+	/*Reset isys_stream to 0*/
+	memset(isys_stream, 0, sizeof(*isys_stream));
+	isys_stream->enable_metadata = isys_stream_descr->metadata.enable;
+
 	isys_stream->linked_isys_stream_id = isys_stream_descr->linked_isys_stream_id;
 	rc = create_input_system_input_port(isys_stream_descr, &(isys_stream->input_port));
 	if (rc == false)
@@ -181,7 +185,7 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 
 	rc = create_input_system_channel(isys_stream_descr, false, &(isys_stream->channel));
 	if (rc == false) {
-		destroy_input_system_input_port(&(isys_stream->input_port));
+		destroy_input_system_input_port(&isys_stream->input_port);
 		return false;
 	}
 
@@ -203,7 +207,7 @@ ia_css_isys_error_t ia_css_isys_stream_create(
 void ia_css_isys_stream_destroy(
 	ia_css_isys_stream_h	isys_stream)
 {
-	destroy_input_system_input_port(&(isys_stream->input_port));
+	destroy_input_system_input_port(&isys_stream->input_port);
 	destroy_input_system_channel(&(isys_stream->channel));
 	if (isys_stream->enable_metadata) {
 		/* Destroy metadata channel only if its allocated*/
@@ -402,6 +406,7 @@ static bool create_input_system_input_port(
 	me->source_type = cfg->mode;
 
 	/* for metadata */
+	me->metadata.packet_type = CSI_MIPI_PACKET_TYPE_UNDEFINED;
 	if (rc && cfg->metadata.enable) {
 		me->metadata.packet_type = get_csi_mipi_packet_type(
 				cfg->metadata.fmt_type);
@@ -423,6 +428,14 @@ static void destroy_input_system_input_port(
 				me->csi_rx.packet_type,
 				&me->csi_rx.backend_lut_entry);
 	}
+
+	if (me->metadata.packet_type != CSI_MIPI_PACKET_TYPE_UNDEFINED) {
+		/*Free the backend lut allocated for metadata*/
+		release_be_lut_entry(
+				me->csi_rx.backend_id,
+				me->metadata.packet_type,
+				&me->metadata.backend_lut_entry);
+	}
 }
 
 static bool calculate_input_system_channel_cfg(
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/rmgr/src/rmgr_vbuf.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/rmgr/src/rmgr_vbuf.c
index 4655dd7..1870766 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/rmgr/src/rmgr_vbuf.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/rmgr/src/rmgr_vbuf.c
@@ -121,9 +121,11 @@ void ia_css_rmgr_refcount_retain_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
  */
 void ia_css_rmgr_refcount_release_vbuf(struct ia_css_rmgr_vbuf_handle **handle)
 {
-	assert(handle != NULL);
-	assert(*handle != NULL);
-	assert((*handle)->count != 0);
+	if ((handle == NULL) || ((*handle) == NULL) || (((*handle)->count) == 0)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "ia_css_rmgr_refcount_release_vbuf() invalid arguments!\n");
+		return;
+	}
 	/* decrease reference count */
 	(*handle)->count--;
 	/* remove from admin */
@@ -175,7 +177,10 @@ void ia_css_rmgr_uninit_vbuf(struct ia_css_rmgr_vbuf_pool *pool)
 {
 	uint32_t i;
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_rmgr_uninit_vbuf()\n");
-	assert(pool != NULL);
+	if (pool == NULL) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_rmgr_uninit_vbuf(): NULL argument\n");
+		 return;
+	}
 	if (pool->handles != NULL) {
 		/* free the hmm buffers */
 		for (i = 0; i < pool->size; i++) {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c
index 9fc89d5..88e48f6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c
@@ -30,6 +30,7 @@
 #include "memory_access.h"
 #include "assert_support.h"
 #include "ia_css_spctrl.h"
+#include "ia_css_debug.h"
 
 typedef struct {
 	struct ia_css_sp_init_dmem_cfg dmem_config;
@@ -82,10 +83,22 @@ enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
 		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
 	mmgr_store(code_addr, spctrl_cfg->code, spctrl_cfg->code_size);
 
-	assert(sizeof(hrt_vaddress) <= sizeof(hrt_data));
+	if (sizeof(hrt_vaddress) > sizeof(hrt_data)) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "size of hrt_vaddress can not be greater than hrt_data\n");
+		mmgr_free(spctrl_cfg->code_size);
+		spctrl_cfg->code_size = mmgr_NULL;
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 
 	init_dmem_cfg->ddr_data_addr  = code_addr + spctrl_cfg->ddr_data_offset;
-	assert((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) == 0);
+	if ((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) != 0) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
+				    "DDR address pointer is not properly aligned for DMA transfer\n");
+		mmgr_free(spctrl_cfg->code_size);
+		spctrl_cfg->code_size = mmgr_NULL;
+		return IA_CSS_ERR_INTERNAL_ERROR;
+	}
 #endif
 	spctrl_cofig_info[sp_id].sp_entry = spctrl_cfg->sp_entry;
 	spctrl_cofig_info[sp_id].code_addr = code_addr;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c
index 23854ea..004f0d0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c
@@ -1184,7 +1184,8 @@ static void print_pc_histo(char *core_name, struct sh_css_pc_histogram *hist)
 	unsigned cnt_run = 0;
 	unsigned cnt_stall = 0;
 
-	assert(hist != NULL);
+	if (hist == NULL)
+		return;
 
 	sh_css_print("%s histogram length = %d\n", core_name, hist->length);
 	sh_css_print("%s PC\trun\tstall\n", core_name);
@@ -4994,6 +4995,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	struct ia_css_frame_info video_bin_out_info;
 	bool need_scaler = false;
 	bool vf_res_different_than_output = false;
+	bool need_vf_pp = false;
+	int vf_ds_log2;
 	struct ia_css_video_settings *mycs  = &pipe->pipe_settings.video;
 
 	assert(pipe != NULL);
@@ -5100,19 +5103,65 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 
 	{
 		struct ia_css_binary_descr video_descr;
+		enum ia_css_frame_format vf_info_format;
 
 		err = ia_css_pipe_get_video_binarydesc(pipe,
 			&video_descr, &video_in_info, &video_bds_out_info, &video_bin_out_info, video_vf_info,
 			pipe->stream->config.left_padding);
 		if (err != IA_CSS_SUCCESS)
 			return err;
+
+		/* In the case where video_vf_info is not NULL, this allows
+		 * us to find a potential video library with desired vf format.
+		 * If success, no vf_pp binary is needed.
+		 * If failed, we will look up video binary with YUV_LINE vf format
+		 */
 		err = ia_css_binary_find(&video_descr,
 					 &mycs->video_binary);
-		if (err != IA_CSS_SUCCESS)
-			return err;
-	}
 
-	num_output_pins = mycs->video_binary.info->num_output_pins;
+		if (err != IA_CSS_SUCCESS) {
+			if (video_vf_info) {
+				/* This will do another video binary lookup later for YUV_LINE format*/
+				need_vf_pp = true;
+			} else
+				return err;
+		} else if (video_vf_info) {
+			/* The first video binary lookup is successful, but we may
+			 * still need vf_pp binary based on additiona check */
+			num_output_pins = mycs->video_binary.info->num_output_pins;
+			vf_ds_log2 = mycs->video_binary.vf_downscale_log2;
+
+			/* If the binary has dual output pins, we need vf_pp if the resolution
+			* is different. */
+			need_vf_pp |= ((num_output_pins == 2) && vf_res_different_than_output);
+
+			/* If the binary has single output pin, we need vf_pp if additional
+			* scaling is needed for vf */
+			need_vf_pp |= ((num_output_pins == 1) &&
+				((video_vf_info->res.width << vf_ds_log2 != pipe_out_info->res.width) ||
+				(video_vf_info->res.height << vf_ds_log2 != pipe_out_info->res.height)));
+		}
+
+		if (need_vf_pp) {
+			/* save the current vf_info format for restoration later */
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"load_video_binaries() need_vf_pp; find video binary with YUV_LINE again\n");
+
+			vf_info_format = video_vf_info->format;
+
+			ia_css_frame_info_set_format(video_vf_info,
+					IA_CSS_FRAME_FORMAT_YUV_LINE);
+			err = ia_css_binary_find(&video_descr,
+						&mycs->video_binary);
+
+			/* restore original vf_info format */
+			ia_css_frame_info_set_format(video_vf_info,
+					vf_info_format);
+			if (err != IA_CSS_SUCCESS)
+				return err;
+		}
+
+	}
 
 	/* If a video binary does not use a ref_frame, we set the frame delay
 	 * to 0. This is the case for the 1-stage low-power video binary. */
@@ -5153,12 +5202,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 #endif
 #endif
 
-	/* Viewfinder post-processing */
-	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] &&  /* only when viewfinder is enabled. */
-	   ((num_output_pins == 1)        /* when the binary has a single output pin, we need vf_pp */
-		|| ((num_output_pins == 2) && vf_res_different_than_output))) {
-			/* when the binary has dual output pin, */
-			/* we only need vf_pp in case the resolution is different. */
+#if !defined(HAS_OUTPUT_SYSTEM)
+	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {
 		struct ia_css_binary_descr vf_pp_descr;
 
 		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
@@ -5169,6 +5214,7 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 		if (err != IA_CSS_SUCCESS)
 			return err;
 	}
+#endif
 
 	ref_info = mycs->video_binary.internal_frame_info;
 #if defined(IS_ISP_2500_SYSTEM)
@@ -6795,8 +6841,10 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 			}
 		}
 	} else if (post_stage != NULL) {
-		err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
+		if (vf_frame[0] != NULL && vf_frame[0]->info.res.width != 0) {
+			err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
 				      post_stage, &vf_pp_stage);
+		}
 		if (err != IA_CSS_SUCCESS)
 			return err;
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c
index af5d769..d5d162b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c
@@ -54,10 +54,10 @@ struct fw_param {
 /* Warning: same order as SH_CSS_BINARY_ID_* */
 static struct firmware_header *firmware_header;
 
-/* The string STR(irci_master_20141014_1500) is a place holder
+/* The string STR(irci_master_20141029_1500) is a place holder
  * which will be replaced with the actual RELEASE_VERSION
  * during package generation. Please do not modify  */
-static const char *release_version = STR(irci_master_20141014_1500);
+static const char *release_version = STR(irci_master_20141029_1500);
 
 #define MAX_FW_REL_VER_NAME	300
 static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
@@ -88,8 +88,8 @@ setup_sp(struct ia_css_fw_info *fw, const char *fw_data, struct ia_css_fw_info *
 {
 	const char *blob_data;
 
-	assert(fw != NULL);
-	assert(fw_data != NULL);
+	if ((fw == NULL) || (fw_data == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	blob_data = fw_data + fw->blob.offset;
 
@@ -116,8 +116,8 @@ sh_css_load_blob_info(const char *fw, const struct ia_css_fw_info *bi, struct ia
 	const char *name;
 	const unsigned char *blob;
 
-	assert(fw != NULL);
-	assert(bd != NULL);
+	if ((fw == NULL) || (bd == NULL))
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
 
 	/* Special case: only one binary in fw */
 	if (bi == NULL) bi = (const struct ia_css_fw_info *)fw;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h
index 483a9c3..462c19b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h
@@ -147,7 +147,6 @@
 
 #define SH_CSS_MAX_SP_INTERNAL_THREADS	(\
 	 SH_CSS_SP_INTERNAL_SERVICE_THREAD +\
-	 SH_CSS_SP_INTERNAL_SWITCH_GACS_TO_SP1_THREAD +\
 	 SH_CSS_SP_INTERNAL_METADATA_THREAD)
 
 #define SH_CSS_MAX_PIPELINES	SH_CSS_MAX_SP_THREADS
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c
index 000c47b..95024ec 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c
@@ -90,7 +90,7 @@
 #include "anr/anr_2/ia_css_anr2.host.h"
 #include "bh/bh_2/ia_css_bh.host.h"
 #include "cnr/cnr_2/ia_css_cnr2.host.h"
-#include "ctc/ctc_2/ia_css_ctc2.host.h"
+#include "ctc/ctc1_5/ia_css_ctc1_5.host.h"
 #include "de/de_2/ia_css_de2.host.h"
 #include "gc/gc_2/ia_css_gc2.host.h"
 #include "sdis/sdis_2/ia_css_sdis2.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c
index 2cf7f40..c8790a7 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c
@@ -29,65 +29,65 @@
 
 #define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
 
-/* function longjmp: 67B2 */
+/* function longjmp: 67B4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_buff_pool_lock_frame_handles
 #define HIVE_MEM_raw_buff_pool_lock_frame_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_buff_pool_lock_frame_handles 0x71F0
+#define HIVE_ADDR_raw_buff_pool_lock_frame_handles 0x71E0
 #define HIVE_SIZE_raw_buff_pool_lock_frame_handles 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_buff_pool_lock_frame_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_buff_pool_lock_frame_handles 0x71F0
+#define HIVE_ADDR_sp_raw_buff_pool_lock_frame_handles 0x71E0
 #define HIVE_SIZE_sp_raw_buff_pool_lock_frame_handles 60
 
-/* function tmpmem_init_dmem: 6565 */
+/* function tmpmem_init_dmem: 6567 */
 
-/* function ia_css_dmaproxy_sp_set_addr_B: 38FD */
+/* function ia_css_dmaproxy_sp_set_addr_B: 392A */
 
 /* function debug_buffer_set_ddr_addr: F8 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_mipi
 #define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_mipi 0x72D8
+#define HIVE_ADDR_vbuf_mipi 0x72C8
 #define HIVE_SIZE_vbuf_mipi 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_mipi 0x72D8
+#define HIVE_ADDR_sp_vbuf_mipi 0x72C8
 #define HIVE_SIZE_sp_vbuf_mipi 12
 
-/* function ia_css_event_sp_decode: 3B09 */
+/* function ia_css_event_sp_decode: 3B36 */
 
-/* function ia_css_queue_get_size: 500E */
+/* function ia_css_queue_get_size: 503B */
 
-/* function ia_css_queue_load: 56D9 */
+/* function ia_css_queue_load: 5706 */
 
-/* function setjmp: 67BB */
+/* function setjmp: 67BD */
 
-/* function __dmaproxy_sp_read_write_text: 3A15 */
+/* function __dmaproxy_sp_read_write_text: 3A42 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_isys_event_queue
 #define HIVE_MEM_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x5700
+#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x56EC
 #define HIVE_SIZE_sem_for_sp2host_isys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x5700
+#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x56EC
 #define HIVE_SIZE_sp_sem_for_sp2host_isys_event_queue 20
 
-/* function ia_css_dmaproxy_sp_wait_for_ack: 6E01 */
+/* function ia_css_dmaproxy_sp_wait_for_ack: 6E0C */
 
-/* function ia_css_sp_rawcopy_func: 587D */
+/* function ia_css_sp_rawcopy_func: 589F */
 
-/* function ia_css_tagger_buf_sp_pop_marked: 2F91 */
+/* function ia_css_tagger_buf_sp_pop_marked: 2FBE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_CSI_RX_BE_SID_WIDTH
@@ -104,13 +104,13 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stage
 #define HIVE_MEM_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stage 0x6B68
+#define HIVE_ADDR_isp_stage 0x6B58
 #define HIVE_SIZE_isp_stage 824
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stage 0x6B68
+#define HIVE_ADDR_sp_isp_stage 0x6B58
 #define HIVE_SIZE_sp_isp_stage 824
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -125,34 +125,34 @@
 #define HIVE_ADDR_sp_vbuf_raw 0x370
 #define HIVE_SIZE_sp_vbuf_raw 4
 
-/* function ia_css_sp_bin_copy_func: 5860 */
+/* function ia_css_sp_bin_copy_func: 588D */
 
-/* function ia_css_queue_item_store: 53AF */
+/* function ia_css_queue_item_store: 53DC */
 
-/* function input_system_reset: 12EB */
+/* function input_system_reset: 1318 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5A30
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5A1C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5A30
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5A1C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5A44
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5A30
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5A44
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5A30
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 
 /* function sp_start_isp: 423 */
@@ -160,83 +160,83 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_binary_group
 #define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_binary_group 0x6F50
+#define HIVE_ADDR_sp_binary_group 0x6F40
 #define HIVE_SIZE_sp_binary_group 32
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_binary_group 0x6F50
+#define HIVE_ADDR_sp_sp_binary_group 0x6F40
 #define HIVE_SIZE_sp_sp_binary_group 32
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sw_state
 #define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sw_state 0x7284
+#define HIVE_ADDR_sp_sw_state 0x7274
 #define HIVE_SIZE_sp_sw_state 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sw_state 0x7284
+#define HIVE_ADDR_sp_sp_sw_state 0x7274
 #define HIVE_SIZE_sp_sp_sw_state 4
 
-/* function sp_error: 971 */
+/* function sp_error: 99E */
 
-/* function ia_css_thread_sp_main: 145D */
+/* function ia_css_thread_sp_main: 148A */
 
-/* function ia_css_ispctrl_sp_init_internal_buffers: 3D50 */
+/* function ia_css_ispctrl_sp_init_internal_buffers: 3D7D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_psys_event_queue_handle
 #define HIVE_MEM_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x5AE4
+#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x5AD0
 #define HIVE_SIZE_sp2host_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x5AE4
+#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x5AD0
 #define HIVE_SIZE_sp_sp2host_psys_event_queue_handle 12
 
-/* function pixelgen_unit_test: ECC */
+/* function pixelgen_unit_test: EF9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_psys_event_queue
 #define HIVE_MEM_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x5714
+#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x5700
 #define HIVE_SIZE_sem_for_sp2host_psys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x5714
+#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x5700
 #define HIVE_SIZE_sp_sem_for_sp2host_psys_event_queue 20
 
-/* function ia_css_tagger_sp_propagate_frame: 297A */
+/* function ia_css_tagger_sp_propagate_frame: 29A7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_stop_copy_preview
 #define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_stop_copy_preview 0x722C
+#define HIVE_ADDR_sp_stop_copy_preview 0x721C
 #define HIVE_SIZE_sp_stop_copy_preview 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_stop_copy_preview 0x722C
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x721C
 #define HIVE_SIZE_sp_sp_stop_copy_preview 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_handles
 #define HIVE_MEM_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_handles 0x72E4
+#define HIVE_ADDR_vbuf_handles 0x72D4
 #define HIVE_SIZE_vbuf_handles 960
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_handles 0x72E4
+#define HIVE_ADDR_sp_vbuf_handles 0x72D4
 #define HIVE_SIZE_sp_vbuf_handles 960
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -251,29 +251,29 @@
 #define HIVE_ADDR_sp_max_mm_tracer 0x1AC
 #define HIVE_SIZE_sp_max_mm_tracer 4
 
-/* function ia_css_queue_store: 5552 */
+/* function ia_css_queue_store: 557F */
 
-/* function ia_css_sp_flash_register: 316B */
+/* function ia_css_sp_flash_register: 3198 */
 
-/* function ia_css_pipeline_sp_init: 209A */
+/* function ia_css_pipeline_sp_init: 20C7 */
 
-/* function ia_css_tagger_sp_configure: 285F */
+/* function ia_css_tagger_sp_configure: 288C */
 
-/* function ia_css_ispctrl_sp_end_binary: 3B53 */
+/* function ia_css_ispctrl_sp_end_binary: 3B80 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5AF0
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5ADC
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5AF0
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5ADC
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 
-/* function pixelgen_tpg_run: F82 */
+/* function pixelgen_tpg_run: FAF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_is_pending_mask
@@ -290,70 +290,70 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_frame
 #define HIVE_MEM_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_frame 0x5728
+#define HIVE_ADDR_sp_all_cb_elems_frame 0x5714
 #define HIVE_SIZE_sp_all_cb_elems_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x5728
+#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x5714
 #define HIVE_SIZE_sp_sp_all_cb_elems_frame 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_isys_event_queue_handle
 #define HIVE_MEM_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x5B04
+#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x5AF0
 #define HIVE_SIZE_sp2host_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x5B04
+#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x5AF0
 #define HIVE_SIZE_sp_sp2host_isys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_com
 #define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_com 0x3E50
+#define HIVE_ADDR_host_sp_com 0x3E3C
 #define HIVE_SIZE_host_sp_com 220
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_com 0x3E50
+#define HIVE_ADDR_sp_host_sp_com 0x3E3C
 #define HIVE_SIZE_sp_host_sp_com 220
 
-/* function ia_css_queue_get_free_space: 5166 */
+/* function ia_css_queue_get_free_space: 5193 */
 
-/* function exec_image_pipe: 61D */
+/* function exec_image_pipe: 650 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_init_dmem_data
 #define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_init_dmem_data 0x7288
+#define HIVE_ADDR_sp_init_dmem_data 0x7278
 #define HIVE_SIZE_sp_init_dmem_data 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_init_dmem_data 0x7288
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x7278
 #define HIVE_SIZE_sp_sp_init_dmem_data 24
 
-/* function ia_css_sp_metadata_start: 5E1E */
+/* function ia_css_sp_metadata_start: 5E4A */
 
-/* function ia_css_tagger_buf_sp_is_marked: 30B8 */
+/* function ia_css_tagger_buf_sp_is_marked: 30E5 */
 
-/* function ia_css_bufq_sp_init_buffer_queues: 31C4 */
+/* function ia_css_bufq_sp_init_buffer_queues: 31F1 */
 
-/* function ia_css_pipeline_sp_stop: 207D */
+/* function ia_css_pipeline_sp_stop: 20AA */
 
-/* function ia_css_tagger_sp_connect_pipes: 2D8B */
+/* function ia_css_tagger_sp_connect_pipes: 2DB8 */
 
-/* function sp_isys_copy_wait: 67B */
+/* function sp_isys_copy_wait: 6AE */
 
 /* function is_isp_debug_buffer_full: 3BC */
 
-/* function ia_css_dmaproxy_sp_configure_channel_from_info: 387A */
+/* function ia_css_dmaproxy_sp_configure_channel_from_info: 38A7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_input_system_bz2788_active
@@ -382,48 +382,48 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_per_frame_data
 #define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_per_frame_data 0x3F2C
+#define HIVE_ADDR_sp_per_frame_data 0x3F18
 #define HIVE_SIZE_sp_per_frame_data 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_per_frame_data 0x3F2C
+#define HIVE_ADDR_sp_sp_per_frame_data 0x3F18
 #define HIVE_SIZE_sp_sp_per_frame_data 4
 
-/* function ia_css_rmgr_sp_vbuf_dequeue: 62B5 */
+/* function ia_css_rmgr_sp_vbuf_dequeue: 62B7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_psys_event_queue_handle
 #define HIVE_MEM_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x5B10
+#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x5AFC
 #define HIVE_SIZE_host2sp_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x5B10
+#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x5AFC
 #define HIVE_SIZE_sp_host2sp_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_xmem_bin_addr
 #define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_xmem_bin_addr 0x3F30
+#define HIVE_ADDR_xmem_bin_addr 0x3F1C
 #define HIVE_SIZE_xmem_bin_addr 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_xmem_bin_addr 0x3F30
+#define HIVE_ADDR_sp_xmem_bin_addr 0x3F1C
 #define HIVE_SIZE_sp_xmem_bin_addr 4
 
-/* function tmr_clock_init: B07 */
+/* function tmr_clock_init: B34 */
 
-/* function ia_css_sp_rawcopy_unlock_buffer: 5CAF */
+/* function ia_css_sp_rawcopy_unlock_buffer: 5CE0 */
 
-/* function ia_css_pipeline_sp_run: 1B1C */
+/* function ia_css_pipeline_sp_run: 1B49 */
 
-/* function memcpy: 685B */
+/* function memcpy: 685D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_ISYS2401_DMA_CHANNEL_PROCS
@@ -461,28 +461,28 @@
 #define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x284
 #define HIVE_SIZE_sp_ia_css_thread_sp_ready_queue 12
 
-/* function sp_dma_proxy_set_width_ab: 3717 */
+/* function sp_dma_proxy_set_width_ab: 3744 */
 
-/* function stream2mmio_send_command: E6E */
+/* function stream2mmio_send_command: E9B */
 
-/* function ia_css_uds_sp_scale_params: 657F */
+/* function ia_css_uds_sp_scale_params: 6581 */
 
-/* function ia_css_circbuf_increase_size: 1542 */
+/* function ia_css_circbuf_increase_size: 156F */
 
-/* function __divu: 67D9 */
+/* function __divu: 67DB */
 
-/* function ia_css_thread_sp_get_state: 1385 */
+/* function ia_css_thread_sp_get_state: 13B2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_stop
 #define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_stop 0x5738
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x5724
 #define HIVE_SIZE_sem_for_cont_capt_stop 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x5738
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x5724
 #define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -497,25 +497,25 @@
 #define HIVE_ADDR_sp_N_SHORT_PACKET_LUT_ENTRIES 0x1B0
 #define HIVE_SIZE_sp_N_SHORT_PACKET_LUT_ENTRIES 12
 
-/* function thread_fiber_sp_main: 153B */
+/* function thread_fiber_sp_main: 1568 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_pipe_thread
 #define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pipe_thread 0x587C
+#define HIVE_ADDR_sp_isp_pipe_thread 0x5868
 #define HIVE_SIZE_sp_isp_pipe_thread 340
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x587C
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x5868
 #define HIVE_SIZE_sp_sp_isp_pipe_thread 340
 
-/* function ia_css_parambuf_sp_handle_parameter_sets: 19B8 */
+/* function ia_css_parambuf_sp_handle_parameter_sets: 19E5 */
 
-/* function ia_css_spctrl_sp_set_state: 5E3A */
+/* function ia_css_spctrl_sp_set_state: 5E66 */
 
-/* function ia_css_thread_sem_sp_signal: 6A4F */
+/* function ia_css_thread_sem_sp_signal: 6A51 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_IRQ_BASE
@@ -529,7 +529,7 @@
 #define HIVE_ADDR_sp_IRQ_BASE 0x2C
 #define HIVE_SIZE_sp_IRQ_BASE 16
 
-/* function ia_css_virtual_isys_sp_isr_init: 5EE5 */
+/* function ia_css_virtual_isys_sp_isr_init: 5F11 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_TIMED_CTRL_BASE
@@ -543,11 +543,11 @@
 #define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
 #define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
 
-/* function ia_css_isys_sp_generate_exp_id: 6144 */
+/* function ia_css_isys_sp_generate_exp_id: 6146 */
 
-/* function ia_css_rmgr_sp_init: 61A4 */
+/* function ia_css_rmgr_sp_init: 61A6 */
 
-/* function ia_css_thread_sem_sp_init: 6B22 */
+/* function ia_css_thread_sem_sp_init: 6B24 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_is_isp_requested
@@ -564,22 +564,22 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_frame
 #define HIVE_MEM_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frame 0x574C
+#define HIVE_ADDR_sem_for_reading_cb_frame 0x5738
 #define HIVE_SIZE_sem_for_reading_cb_frame 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x574C
+#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x5738
 #define HIVE_SIZE_sp_sem_for_reading_cb_frame 40
 
-/* function ia_css_dmaproxy_sp_execute: 37D2 */
+/* function ia_css_dmaproxy_sp_execute: 37FF */
 
-/* function csi_rx_backend_rst: D04 */
+/* function csi_rx_backend_rst: D31 */
 
-/* function ia_css_queue_is_empty: 5049 */
+/* function ia_css_queue_is_empty: 5076 */
 
-/* function ia_css_pipeline_sp_has_stopped: 2073 */
+/* function ia_css_pipeline_sp_has_stopped: 20A0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_verbosity
@@ -593,7 +593,7 @@
 #define HIVE_ADDR_sp_verbosity 0x2510
 #define HIVE_SIZE_sp_verbosity 4
 
-/* function ia_css_circbuf_extract: 1650 */
+/* function ia_css_circbuf_extract: 167D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_sp_thread
@@ -607,13 +607,11 @@
 #define HIVE_ADDR_sp_current_sp_thread 0x280
 #define HIVE_SIZE_sp_current_sp_thread 4
 
-/* function ia_css_spctrl_sp_get_spid: 5E41 */
+/* function ia_css_spctrl_sp_get_spid: 5E6D */
 
-/* function ia_css_dmaproxy_sp_read_byte_addr: 6E32 */
+/* function ia_css_dmaproxy_sp_read_byte_addr: 6E3D */
 
-/* function ia_css_rmgr_sp_uninit: 619D */
-
-/* function ia_css_virtual_isys_sync_all: 5F09 */
+/* function ia_css_rmgr_sp_uninit: 619F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack
@@ -651,20 +649,20 @@
 #define HIVE_ADDR_sp_trace_buffer_sp 0x1A8
 #define HIVE_SIZE_sp_trace_buffer_sp 4
 
-/* function ia_css_circbuf_peek: 162F */
+/* function ia_css_circbuf_peek: 165C */
 
-/* function ia_css_parambuf_sp_wait_for_in_param: 1766 */
+/* function ia_css_parambuf_sp_wait_for_in_param: 1793 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_param
 #define HIVE_MEM_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_param 0x5774
+#define HIVE_ADDR_sp_all_cb_elems_param 0x5760
 #define HIVE_SIZE_sp_all_cb_elems_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x5774
+#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x5760
 #define HIVE_SIZE_sp_sp_all_cb_elems_param 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -682,101 +680,101 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame_desc
 #define HIVE_MEM_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame_desc 0x5784
+#define HIVE_ADDR_sp_all_cbs_frame_desc 0x5770
 #define HIVE_SIZE_sp_all_cbs_frame_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x5784
+#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x5770
 #define HIVE_SIZE_sp_sp_all_cbs_frame_desc 8
 
-/* function sp_isys_copy_func_v2: 660 */
+/* function sp_isys_copy_func_v2: 693 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_param
 #define HIVE_MEM_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_param 0x578C
+#define HIVE_ADDR_sem_for_reading_cb_param 0x5778
 #define HIVE_SIZE_sem_for_reading_cb_param 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x578C
+#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x5778
 #define HIVE_SIZE_sp_sem_for_reading_cb_param 40
 
-/* function ia_css_queue_get_used_space: 5118 */
+/* function ia_css_queue_get_used_space: 5145 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_start
 #define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_start 0x57B4
+#define HIVE_ADDR_sem_for_cont_capt_start 0x57A0
 #define HIVE_SIZE_sem_for_cont_capt_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x57B4
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x57A0
 #define HIVE_SIZE_sp_sem_for_cont_capt_start 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tmp_heap
 #define HIVE_MEM_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_tmp_heap 0x6F70
+#define HIVE_ADDR_tmp_heap 0x6F60
 #define HIVE_SIZE_tmp_heap 640
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tmp_heap 0x6F70
+#define HIVE_ADDR_sp_tmp_heap 0x6F60
 #define HIVE_SIZE_sp_tmp_heap 640
 
-/* function ia_css_tagger_buf_sp_mark: 3144 */
+/* function ia_css_tagger_buf_sp_mark: 3171 */
 
-/* function ia_css_rmgr_sp_get_num_vbuf: 64BA */
+/* function ia_css_rmgr_sp_get_num_vbuf: 64BC */
 
-/* function ia_css_ispctrl_sp_output_compute_dma_info: 455E */
+/* function ia_css_ispctrl_sp_output_compute_dma_info: 458B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5B1C
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5B08
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5B1C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5B08
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 
-/* function ia_css_queue_is_full: 51B5 */
+/* function ia_css_queue_is_full: 51E2 */
 
 /* function debug_buffer_init_isp: 105 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem
 #define HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x76A4
+#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x7694
 #define HIVE_SIZE_ia_css_rmgr_sp_mipi_frame_sem 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x76A4
+#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x7694
 #define HIVE_SIZE_sp_ia_css_rmgr_sp_mipi_frame_sem 60
 
-/* function ia_css_rmgr_sp_refcount_dump: 6290 */
+/* function ia_css_rmgr_sp_refcount_dump: 6292 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5B58
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5B44
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5B58
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5B44
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -791,53 +789,53 @@
 #define HIVE_ADDR_sp_sp_pipe_threads 0x148
 #define HIVE_SIZE_sp_sp_pipe_threads 20
 
-/* function sp_event_proxy_func: 7CB */
+/* function sp_event_proxy_func: 7F8 */
 
-/* function ibuf_ctrl_run: DD4 */
+/* function ibuf_ctrl_run: E01 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_isys_event_queue_handle
 #define HIVE_MEM_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x5B6C
+#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x5B58
 #define HIVE_SIZE_host2sp_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x5B6C
+#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x5B58
 #define HIVE_SIZE_sp_host2sp_isys_event_queue_handle 12
 
-/* function ia_css_thread_sp_yield: 69C5 */
+/* function ia_css_thread_sp_yield: 69C7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param_desc
 #define HIVE_MEM_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param_desc 0x57C8
+#define HIVE_ADDR_sp_all_cbs_param_desc 0x57B4
 #define HIVE_SIZE_sp_all_cbs_param_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x57C8
+#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x57B4
 #define HIVE_SIZE_sp_sp_all_cbs_param_desc 8
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb
 #define HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x6B5C
+#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x6B48
 #define HIVE_SIZE_ia_css_dmaproxy_sp_invalidate_tlb 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x6B5C
+#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x6B48
 #define HIVE_SIZE_sp_ia_css_dmaproxy_sp_invalidate_tlb 4
 
-/* function ia_css_thread_sp_fork: 1412 */
+/* function ia_css_thread_sp_fork: 143F */
 
-/* function ia_css_tagger_sp_destroy: 2D95 */
+/* function ia_css_tagger_sp_destroy: 2DC2 */
 
-/* function ia_css_dmaproxy_sp_vmem_read: 375B */
+/* function ia_css_dmaproxy_sp_vmem_read: 3788 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_LONG_PACKET_LUT_ENTRIES
@@ -851,11 +849,11 @@
 #define HIVE_ADDR_sp_N_LONG_PACKET_LUT_ENTRIES 0x1BC
 #define HIVE_SIZE_sp_N_LONG_PACKET_LUT_ENTRIES 12
 
-/* function initialize_sp_group: 62D */
+/* function initialize_sp_group: 660 */
 
-/* function ia_css_thread_sp_init: 143E */
+/* function ia_css_thread_sp_init: 146B */
 
-/* function ia_css_ispctrl_sp_set_stream_base_addr: 4D56 */
+/* function ia_css_ispctrl_sp_set_stream_base_addr: 4D83 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_DMEM_BASE
@@ -881,9 +879,9 @@
 #define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
 #define HIVE_SIZE_sp_SP_DMEM_BASE 4
 
-/* function ibuf_ctrl_transfer: DAF */
+/* function ibuf_ctrl_transfer: DDC */
 
-/* function ia_css_dmaproxy_sp_read: 37F3 */
+/* function ia_css_dmaproxy_sp_read: 3820 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_copy_line_count
@@ -900,27 +898,27 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_tag_cmd_queue_handle
 #define HIVE_MEM_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x5B78
+#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x5B64
 #define HIVE_SIZE_host2sp_tag_cmd_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x5B78
+#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x5B64
 #define HIVE_SIZE_sp_host2sp_tag_cmd_queue_handle 12
 
-/* function ia_css_queue_peek: 508D */
+/* function ia_css_queue_peek: 50BA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_frame_cnt
 #define HIVE_MEM_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x5A24
+#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x5A10
 #define HIVE_SIZE_ia_css_flash_sp_frame_cnt 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x5A24
+#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x5A10
 #define HIVE_SIZE_sp_ia_css_flash_sp_frame_cnt 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -935,7 +933,7 @@
 #define HIVE_ADDR_sp_event_can_send_token_mask 0x88
 #define HIVE_SIZE_sp_event_can_send_token_mask 44
 
-/* function csi_rx_frontend_stop: C0D */
+/* function csi_rx_frontend_stop: C3A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_started
@@ -952,20 +950,20 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_thread
 #define HIVE_MEM_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_thread 0x6EA0
+#define HIVE_ADDR_isp_thread 0x6E90
 #define HIVE_SIZE_isp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_thread 0x6EA0
+#define HIVE_ADDR_sp_isp_thread 0x6E90
 #define HIVE_SIZE_sp_isp_thread 4
 
-/* function encode_and_post_sp_event_non_blocking: ABE */
+/* function encode_and_post_sp_event_non_blocking: AEB */
 
 /* function is_ddr_debug_buffer_full: 33E */
 
-/* function sp_dma_proxy_isp_write_addr: 3773 */
+/* function sp_dma_proxy_isp_write_addr: 37A0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_fiber
@@ -979,38 +977,38 @@
 #define HIVE_ADDR_sp_sp_threads_fiber 0x18C
 #define HIVE_SIZE_sp_sp_threads_fiber 24
 
-/* function encode_and_post_sp_event: A8F */
+/* function encode_and_post_sp_event: ABC */
 
 /* function debug_enqueue_ddr: 114 */
 
-/* function ia_css_rmgr_sp_refcount_init_vbuf: 624B */
+/* function ia_css_rmgr_sp_refcount_init_vbuf: 624D */
 
-/* function dmaproxy_sp_read_write: 6EDD */
+/* function dmaproxy_sp_read_write: 6EE8 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer
 #define HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6B60
+#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6B4C
 #define HIVE_SIZE_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6B60
+#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6B4C
 #define HIVE_SIZE_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 
-/* function ia_css_dmaproxy_sp_ack: 6B4A */
+/* function ia_css_dmaproxy_sp_ack: 6B4C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_buffer_queue_handle
 #define HIVE_MEM_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_buffer_queue_handle 0x5B84
+#define HIVE_ADDR_host2sp_buffer_queue_handle 0x5B70
 #define HIVE_SIZE_host2sp_buffer_queue_handle 480
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x5B84
+#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x5B70
 #define HIVE_SIZE_sp_host2sp_buffer_queue_handle 480
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1025,41 +1023,41 @@
 #define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x30F8
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_service 4
 
-/* function ia_css_dmaproxy_sp_process: 6B79 */
+/* function ia_css_dmaproxy_sp_process: 6B7B */
 
-/* function ia_css_ispctrl_sp_init_cs: 3C59 */
+/* function ia_css_ispctrl_sp_init_cs: 3C86 */
 
-/* function ia_css_spctrl_sp_init: 5E4F */
+/* function ia_css_spctrl_sp_init: 5E7B */
 
-/* function sp_event_proxy_init: 7E0 */
+/* function sp_event_proxy_init: 80D */
 
-/* function input_system_input_port_close: 10FF */
+/* function input_system_input_port_close: 112C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_output
 #define HIVE_MEM_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_output 0x3F34
+#define HIVE_ADDR_sp_output 0x3F20
 #define HIVE_SIZE_sp_output 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_output 0x3F34
+#define HIVE_ADDR_sp_sp_output 0x3F20
 #define HIVE_SIZE_sp_sp_output 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5D64
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5D50
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5D64
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5D50
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 
-/* function pixelgen_prbs_config: EF7 */
+/* function pixelgen_prbs_config: F24 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_CTRL_BASE
@@ -1085,55 +1083,55 @@
 #define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
 #define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
 
-/* function sp_dma_proxy_reset_channels: 3A6D */
+/* function sp_dma_proxy_reset_channels: 3A9A */
 
-/* function ia_css_bufq_set_clock_tick: 31BC */
+/* function ia_css_bufq_set_clock_tick: 31E9 */
 
-/* function ia_css_tagger_sp_update_size: 2E97 */
+/* function ia_css_tagger_sp_update_size: 2EC4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_host_sp_queue
 #define HIVE_MEM_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x6084
+#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x6070
 #define HIVE_SIZE_ia_css_bufq_host_sp_queue 2008
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x6084
+#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x6070
 #define HIVE_SIZE_sp_ia_css_bufq_host_sp_queue 2008
 
-/* function thread_fiber_sp_create: 14AA */
+/* function thread_fiber_sp_create: 14D7 */
 
-/* function ia_css_dmaproxy_sp_set_increments: 38E8 */
+/* function ia_css_dmaproxy_sp_set_increments: 3915 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_frame
 #define HIVE_MEM_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_frame 0x57D0
+#define HIVE_ADDR_sem_for_writing_cb_frame 0x57BC
 #define HIVE_SIZE_sem_for_writing_cb_frame 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x57D0
+#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x57BC
 #define HIVE_SIZE_sp_sem_for_writing_cb_frame 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_param
 #define HIVE_MEM_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_param 0x57E4
+#define HIVE_ADDR_sem_for_writing_cb_param 0x57D0
 #define HIVE_SIZE_sem_for_writing_cb_param 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x57E4
+#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x57D0
 #define HIVE_SIZE_sp_sem_for_writing_cb_param 20
 
-/* function pixelgen_tpg_is_done: F71 */
+/* function pixelgen_tpg_is_done: F9E */
 
-/* function ia_css_isys_stream_capture_indication: 5FF6 */
+/* function ia_css_isys_stream_capture_indication: 5FF8 */
 
 /* function sp_start_isp_entry: 419 */
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1143,47 +1141,47 @@
 #endif
 #define HIVE_ADDR_sp_sp_start_isp_entry 0x419
 
-/* function ia_css_tagger_buf_sp_unmark_all: 30DC */
+/* function ia_css_tagger_buf_sp_unmark_all: 3109 */
 
-/* function ia_css_dmaproxy_sp_channel_acquire: 3A9C */
+/* function ia_css_dmaproxy_sp_channel_acquire: 3AC9 */
 
-/* function ia_css_rmgr_sp_add_num_vbuf: 6496 */
+/* function ia_css_rmgr_sp_add_num_vbuf: 6498 */
 
-/* function ibuf_ctrl_config: DED */
+/* function ibuf_ctrl_config: E1A */
 
-/* function ia_css_isys_stream_stop: 605F */
+/* function ia_css_isys_stream_stop: 6061 */
 
-/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 370E */
+/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 373B */
 
-/* function ia_css_tagger_buf_sp_push_marked: 3006 */
+/* function ia_css_tagger_buf_sp_push_marked: 3033 */
 
-/* function ia_css_bufq_sp_is_dynamic_buffer: 353B */
+/* function ia_css_bufq_sp_is_dynamic_buffer: 3568 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_group
 #define HIVE_MEM_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_group 0x3F44
+#define HIVE_ADDR_sp_group 0x3F30
 #define HIVE_SIZE_sp_group 6072
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_group 0x3F44
+#define HIVE_ADDR_sp_sp_group 0x3F30
 #define HIVE_SIZE_sp_sp_group 6072
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_event_proxy_thread
 #define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_event_proxy_thread 0x59D0
+#define HIVE_ADDR_sp_event_proxy_thread 0x59BC
 #define HIVE_SIZE_sp_event_proxy_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_event_proxy_thread 0x59D0
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x59BC
 #define HIVE_SIZE_sp_sp_event_proxy_thread 68
 
-/* function ia_css_thread_sp_kill: 13D8 */
+/* function ia_css_thread_sp_kill: 1405 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_cur_loc
@@ -1197,9 +1195,9 @@
 #define HIVE_ADDR_sp_cur_loc 0x2504
 #define HIVE_SIZE_sp_cur_loc 4
 
-/* function ia_css_tagger_sp_create: 2E4E */
+/* function ia_css_tagger_sp_create: 2E7B */
 
-/* function tmpmem_acquire_dmem: 6546 */
+/* function tmpmem_acquire_dmem: 6548 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_MMU_BASE
@@ -1213,27 +1211,27 @@
 #define HIVE_ADDR_sp_MMU_BASE 0x24
 #define HIVE_SIZE_sp_MMU_BASE 8
 
-/* function ia_css_dmaproxy_sp_channel_release: 3A85 */
+/* function ia_css_dmaproxy_sp_channel_release: 3AB2 */
 
-/* function pixelgen_prbs_run: EE5 */
+/* function pixelgen_prbs_run: F12 */
 
-/* function ia_css_dmaproxy_sp_is_idle: 3A58 */
+/* function ia_css_dmaproxy_sp_is_idle: 3A85 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_qos_start
 #define HIVE_MEM_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_qos_start 0x57F8
+#define HIVE_ADDR_sem_for_qos_start 0x57E4
 #define HIVE_SIZE_sem_for_qos_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_qos_start 0x57F8
+#define HIVE_ADDR_sp_sem_for_qos_start 0x57E4
 #define HIVE_SIZE_sp_sem_for_qos_start 20
 
-/* function isp_hmem_load: B4F */
+/* function isp_hmem_load: B7C */
 
-/* function ia_css_eventq_sp_send: 3AE1 */
+/* function ia_css_eventq_sp_send: 3B0E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_debug_buffer_ddr_address
@@ -1247,33 +1245,33 @@
 #define HIVE_ADDR_sp_debug_buffer_ddr_address 0xBC
 #define HIVE_SIZE_sp_debug_buffer_ddr_address 4
 
-/* function sp_isys_copy_request: 72A */
+/* function sp_isys_copy_request: 757 */
 
-/* function ia_css_rmgr_sp_refcount_retain_vbuf: 6325 */
+/* function ia_css_rmgr_sp_refcount_retain_vbuf: 6327 */
 
-/* function ia_css_thread_sp_set_priority: 13D0 */
+/* function ia_css_thread_sp_set_priority: 13FD */
 
-/* function sizeof_hmem: C05 */
+/* function sizeof_hmem: C32 */
 
-/* function input_system_channel_open: 12A6 */
+/* function input_system_channel_open: 12D3 */
 
-/* function pixelgen_tpg_stop: F5F */
+/* function pixelgen_tpg_stop: F8C */
 
-/* function tmpmem_release_dmem: 6533 */
+/* function tmpmem_release_dmem: 6535 */
 
-/* function __ia_css_dmaproxy_sp_process_text: 364A */
+/* function __ia_css_dmaproxy_sp_process_text: 3677 */
 
-/* function ia_css_dmaproxy_sp_set_width_exception: 38D2 */
+/* function ia_css_dmaproxy_sp_set_width_exception: 38FF */
 
-/* function ia_css_flash_sp_init_internal_params: 31B1 */
+/* function ia_css_flash_sp_init_internal_params: 31DE */
 
-/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 2EBC */
+/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 2EE9 */
 
-/* function __modu: 681F */
+/* function __modu: 6821 */
 
-/* function ia_css_dmaproxy_sp_init_isp_vector: 372D */
+/* function ia_css_dmaproxy_sp_init_isp_vector: 375A */
 
-/* function input_system_channel_transfer: 128F */
+/* function input_system_channel_transfer: 12BC */
 
 /* function isp_vamem_store: 0 */
 
@@ -1313,22 +1311,22 @@
 #define HIVE_ADDR_sp_GDC_BASE 0x44
 #define HIVE_SIZE_sp_GDC_BASE 8
 
-/* function ia_css_queue_local_init: 5389 */
+/* function ia_css_queue_local_init: 53B6 */
 
-/* function sp_event_proxy_callout_func: 68EC */
+/* function sp_event_proxy_callout_func: 68EE */
 
-/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 36F5 */
+/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 3722 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_num_ready_threads
 #define HIVE_MEM_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x5A18
+#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x5A04
 #define HIVE_SIZE_ia_css_thread_sp_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x5A18
+#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x5A04
 #define HIVE_SIZE_sp_ia_css_thread_sp_num_ready_threads 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1343,29 +1341,29 @@
 #define HIVE_ADDR_sp_sp_threads_stack_size 0x174
 #define HIVE_SIZE_sp_sp_threads_stack_size 24
 
-/* function ia_css_ispctrl_sp_isp_done_row_striping: 4544 */
+/* function ia_css_ispctrl_sp_isp_done_row_striping: 4571 */
 
-/* function __ia_css_virtual_isys_sp_isr_text: 5E9E */
+/* function __ia_css_virtual_isys_sp_isr_text: 5ECA */
 
-/* function ia_css_queue_dequeue: 51FD */
+/* function ia_css_queue_dequeue: 522A */
 
-/* function ia_css_dmaproxy_sp_configure_channel: 6E49 */
+/* function ia_css_dmaproxy_sp_configure_channel: 6E54 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_thread_fiber_sp
 #define HIVE_MEM_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_current_thread_fiber_sp 0x5A20
+#define HIVE_ADDR_current_thread_fiber_sp 0x5A0C
 #define HIVE_SIZE_current_thread_fiber_sp 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_thread_fiber_sp 0x5A20
+#define HIVE_ADDR_sp_current_thread_fiber_sp 0x5A0C
 #define HIVE_SIZE_sp_current_thread_fiber_sp 4
 
-/* function ia_css_circbuf_pop: 16E8 */
+/* function ia_css_circbuf_pop: 1715 */
 
-/* function memset: 689E */
+/* function memset: 68A0 */
 
 /* function irq_raise_set_token: C1 */
 
@@ -1381,87 +1379,87 @@
 #define HIVE_ADDR_sp_GPIO_BASE 0x3C
 #define HIVE_SIZE_sp_GPIO_BASE 4
 
-/* function pixelgen_prbs_stop: ED3 */
+/* function pixelgen_prbs_stop: F00 */
 
-/* function ia_css_pipeline_acc_stage_enable: 2053 */
+/* function ia_css_pipeline_acc_stage_enable: 2080 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_ph
 #define HIVE_MEM_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_ph 0x72A0
+#define HIVE_ADDR_isp_ph 0x7290
 #define HIVE_SIZE_isp_ph 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_ph 0x72A0
+#define HIVE_ADDR_sp_isp_ph 0x7290
 #define HIVE_SIZE_sp_isp_ph 28
 
-/* function ia_css_ispctrl_sp_init_ds: 3DF7 */
+/* function ia_css_ispctrl_sp_init_ds: 3E24 */
 
-/* function get_xmem_base_addr_raw: 41A7 */
+/* function get_xmem_base_addr_raw: 41D4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param
 #define HIVE_MEM_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param 0x580C
+#define HIVE_ADDR_sp_all_cbs_param 0x57F8
 #define HIVE_SIZE_sp_all_cbs_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param 0x580C
+#define HIVE_ADDR_sp_sp_all_cbs_param 0x57F8
 #define HIVE_SIZE_sp_sp_all_cbs_param 16
 
-/* function pixelgen_tpg_config: F94 */
+/* function pixelgen_tpg_config: FC1 */
 
-/* function ia_css_circbuf_create: 1739 */
+/* function ia_css_circbuf_create: 1766 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp_group
 #define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp_group 0x581C
+#define HIVE_ADDR_sem_for_sp_group 0x5808
 #define HIVE_SIZE_sem_for_sp_group 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp_group 0x581C
+#define HIVE_ADDR_sp_sem_for_sp_group 0x5808
 #define HIVE_SIZE_sp_sem_for_sp_group 20
 
-/* function csi_rx_frontend_run: C1E */
+/* function csi_rx_frontend_run: C4B */
 
-/* function ia_css_framebuf_sp_wait_for_in_frame: 64C1 */
+/* function ia_css_framebuf_sp_wait_for_in_frame: 64C3 */
 
-/* function ia_css_tagger_buf_sp_push_unmarked: 2F2F */
+/* function ia_css_tagger_buf_sp_push_unmarked: 2F5C */
 
-/* function ia_css_isys_stream_open: 60F3 */
+/* function ia_css_isys_stream_open: 60F5 */
 
-/* function input_system_channel_configure: 12C2 */
+/* function input_system_channel_configure: 12EF */
 
-/* function isp_hmem_clear: B16 */
+/* function isp_hmem_clear: B43 */
 
-/* function ia_css_framebuf_sp_release_in_frame: 6504 */
+/* function ia_css_framebuf_sp_release_in_frame: 6506 */
 
-/* function stream2mmio_config: E7F */
+/* function stream2mmio_config: EAC */
 
-/* function ia_css_ispctrl_sp_start_binary: 3C37 */
+/* function ia_css_ispctrl_sp_start_binary: 3C64 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x685C
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x6848
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x685C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x6848
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 
-/* function ia_css_eventq_sp_recv: 3AB3 */
+/* function ia_css_eventq_sp_recv: 3AE0 */
 
-/* function csi_rx_frontend_config: C76 */
+/* function csi_rx_frontend_config: CA3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_pool
@@ -1475,9 +1473,9 @@
 #define HIVE_ADDR_sp_isp_pool 0x364
 #define HIVE_SIZE_sp_isp_pool 4
 
-/* function ia_css_rmgr_sp_rel_gen: 61E6 */
+/* function ia_css_rmgr_sp_rel_gen: 61E8 */
 
-/* function css_get_frame_processing_time_end: 27F1 */
+/* function css_get_frame_processing_time_end: 281E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_any_pending_mask
@@ -1491,43 +1489,43 @@
 #define HIVE_ADDR_sp_event_any_pending_mask 0x380
 #define HIVE_SIZE_sp_event_any_pending_mask 8
 
-/* function ia_css_pipeline_sp_get_pipe_io_status: 1B15 */
+/* function ia_css_pipeline_sp_get_pipe_io_status: 1B42 */
 
 /* function sh_css_decode_tag_descr: 3D7 */
 
 /* function debug_enqueue_isp: 2E9 */
 
-/* function ia_css_spctrl_sp_uninit: 5E48 */
+/* function ia_css_spctrl_sp_uninit: 5E74 */
 
-/* function csi_rx_backend_run: C64 */
+/* function csi_rx_backend_run: C91 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x6870
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x685C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_dis_bufs 140
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x6870
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x685C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_dis_bufs 140
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_isp_idle
 #define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_isp_idle 0x5830
+#define HIVE_ADDR_sem_for_isp_idle 0x581C
 #define HIVE_SIZE_sem_for_isp_idle 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_isp_idle 0x5830
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x581C
 #define HIVE_SIZE_sp_sem_for_isp_idle 20
 
-/* function ia_css_dmaproxy_sp_write_byte_addr: 37A1 */
+/* function ia_css_dmaproxy_sp_write_byte_addr: 37CE */
 
-/* function ia_css_dmaproxy_sp_init: 36C7 */
+/* function ia_css_dmaproxy_sp_init: 36F4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_VAMEM_BASE
@@ -1541,49 +1539,49 @@
 #define HIVE_ADDR_sp_ISP_VAMEM_BASE 0x14
 #define HIVE_SIZE_sp_ISP_VAMEM_BASE 12
 
-/* function input_system_channel_sync: 1208 */
+/* function input_system_channel_sync: 1235 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rawcopy_sp_tagger
 #define HIVE_MEM_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x7230
+#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x7220
 #define HIVE_SIZE_ia_css_rawcopy_sp_tagger 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x7230
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x7220
 #define HIVE_SIZE_sp_ia_css_rawcopy_sp_tagger 24
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x68FC
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x68E8
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_exp_ids 70
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x68FC
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x68E8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_exp_ids 70
 
-/* function ia_css_queue_item_load: 549E */
+/* function ia_css_queue_item_load: 54CB */
 
-/* function ia_css_spctrl_sp_get_state: 5E33 */
+/* function ia_css_spctrl_sp_get_state: 5E5F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_callout_sp_thread
 #define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_callout_sp_thread 0x5A14
+#define HIVE_ADDR_callout_sp_thread 0x5A00
 #define HIVE_SIZE_callout_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_callout_sp_thread 0x5A14
+#define HIVE_ADDR_sp_callout_sp_thread 0x5A00
 #define HIVE_SIZE_sp_callout_sp_thread 4
 
-/* function thread_fiber_sp_init: 1531 */
+/* function thread_fiber_sp_init: 155E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_SP_PMEM_BASE
@@ -1600,26 +1598,26 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_input_stream_format
 #define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_input_stream_format 0x3D18
+#define HIVE_ADDR_sp_isp_input_stream_format 0x3D04
 #define HIVE_SIZE_sp_isp_input_stream_format 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3D18
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3D04
 #define HIVE_SIZE_sp_sp_isp_input_stream_format 20
 
-/* function __mod: 680B */
+/* function __mod: 680D */
 
-/* function ia_css_dmaproxy_sp_init_dmem_channel: 380D */
+/* function ia_css_dmaproxy_sp_init_dmem_channel: 383A */
 
-/* function ia_css_thread_sp_join: 1401 */
+/* function ia_css_thread_sp_join: 142E */
 
-/* function ia_css_dmaproxy_sp_add_command: 6F1F */
+/* function ia_css_dmaproxy_sp_add_command: 6F2A */
 
-/* function ia_css_sp_metadata_thread_func: 5E2C */
+/* function ia_css_sp_metadata_thread_func: 5E58 */
 
-/* function __sp_event_proxy_func_critical: 68D9 */
+/* function __sp_event_proxy_func_critical: 68DB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_dmaproxy_sp_proxy_status
@@ -1633,31 +1631,31 @@
 #define HIVE_ADDR_sp_dmaproxy_sp_proxy_status 0x2A8
 #define HIVE_SIZE_sp_dmaproxy_sp_proxy_status 4
 
-/* function ia_css_pipeline_sp_wait_for_isys_stream_N: 5F9F */
+/* function ia_css_pipeline_sp_wait_for_isys_stream_N: 5FA1 */
 
-/* function ia_css_sp_metadata_wait: 5E25 */
+/* function ia_css_sp_metadata_wait: 5E51 */
 
-/* function ia_css_circbuf_peek_from_start: 160E */
+/* function ia_css_circbuf_peek_from_start: 163B */
 
-/* function ia_css_sp_rawcopy_buffer_is_locked: 5D4F */
+/* function ia_css_sp_rawcopy_buffer_is_locked: 5D6D */
 
-/* function ia_css_event_sp_encode: 3B3F */
+/* function ia_css_event_sp_encode: 3B6C */
 
-/* function ia_css_thread_sp_run: 1474 */
+/* function ia_css_thread_sp_run: 14A1 */
 
-/* function sp_isys_copy_func: 64F */
+/* function sp_isys_copy_func: 682 */
 
-/* function ia_css_sp_isp_param_init_isp_memories: 4ED8 */
+/* function ia_css_sp_isp_param_init_isp_memories: 4F05 */
 
-/* function register_isr: 935 */
+/* function register_isr: 962 */
 
 /* function irq_raise: D3 */
 
-/* function ia_css_dmaproxy_sp_mmu_invalidate: 3605 */
+/* function ia_css_dmaproxy_sp_mmu_invalidate: 3632 */
 
-/* function csi_rx_backend_disable: C30 */
+/* function csi_rx_backend_disable: C5D */
 
-/* function pipeline_sp_initialize_stage: 2172 */
+/* function pipeline_sp_initialize_stage: 219F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_CSI_RX_FE_CTRL_DLANES
@@ -1671,15 +1669,15 @@
 #define HIVE_ADDR_sp_N_CSI_RX_FE_CTRL_DLANES 0x1C8
 #define HIVE_SIZE_sp_N_CSI_RX_FE_CTRL_DLANES 12
 
-/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6E1B */
+/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6E26 */
 
-/* function ia_css_ispctrl_sp_done_ds: 3DDA */
+/* function ia_css_ispctrl_sp_done_ds: 3E07 */
 
-/* function csi_rx_backend_config: C87 */
+/* function csi_rx_backend_config: CB4 */
 
-/* function ia_css_sp_isp_param_get_mem_inits: 4EB3 */
+/* function ia_css_sp_isp_param_get_mem_inits: 4EE0 */
 
-/* function ia_css_parambuf_sp_init_buffer_queues: 1AFD */
+/* function ia_css_parambuf_sp_init_buffer_queues: 1B2A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_pfp_spref
@@ -1708,146 +1706,146 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_frames
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x6944
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x6930
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_frames 280
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x6944
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x6930
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_frames 280
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_buffer_queue_handle
 #define HIVE_MEM_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_buffer_queue_handle 0x6A5C
+#define HIVE_ADDR_sp2host_buffer_queue_handle 0x6A48
 #define HIVE_SIZE_sp2host_buffer_queue_handle 96
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x6A5C
+#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x6A48
 #define HIVE_SIZE_sp_sp2host_buffer_queue_handle 96
 
-/* function ia_css_ispctrl_sp_init_isp_vars: 4BB9 */
+/* function ia_css_ispctrl_sp_init_isp_vars: 4BE6 */
 
-/* function ia_css_isys_stream_start: 6041 */
+/* function ia_css_isys_stream_start: 6043 */
 
-/* function sp_warning: 94A */
+/* function sp_warning: 977 */
 
-/* function ia_css_rmgr_sp_vbuf_enqueue: 62E5 */
+/* function ia_css_rmgr_sp_vbuf_enqueue: 62E7 */
 
-/* function ia_css_tagger_sp_tag_exp_id: 2803 */
+/* function ia_css_tagger_sp_tag_exp_id: 2830 */
 
-/* function ia_css_dmaproxy_sp_write: 37B8 */
+/* function ia_css_dmaproxy_sp_write: 37E5 */
 
-/* function ia_css_isys_stream_start_async: 6096 */
+/* function ia_css_isys_stream_start_async: 6098 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_buff_pool_lock_params_handles
 #define HIVE_MEM_raw_buff_pool_lock_params_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_buff_pool_lock_params_handles 0x7248
+#define HIVE_ADDR_raw_buff_pool_lock_params_handles 0x7238
 #define HIVE_SIZE_raw_buff_pool_lock_params_handles 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_buff_pool_lock_params_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_buff_pool_lock_params_handles 0x7248
+#define HIVE_ADDR_sp_raw_buff_pool_lock_params_handles 0x7238
 #define HIVE_SIZE_sp_raw_buff_pool_lock_params_handles 60
 
-/* function ia_css_parambuf_sp_release_in_param: 197D */
+/* function ia_css_parambuf_sp_release_in_param: 19AA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_irq_sw_interrupt_token
 #define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_irq_sw_interrupt_token 0x3D14
+#define HIVE_ADDR_irq_sw_interrupt_token 0x3D00
 #define HIVE_SIZE_irq_sw_interrupt_token 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3D14
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3D00
 #define HIVE_SIZE_sp_irq_sw_interrupt_token 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_addresses
 #define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_addresses 0x6EA4
+#define HIVE_ADDR_sp_isp_addresses 0x6E94
 #define HIVE_SIZE_sp_isp_addresses 172
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_addresses 0x6EA4
+#define HIVE_ADDR_sp_sp_isp_addresses 0x6E94
 #define HIVE_SIZE_sp_sp_isp_addresses 172
 
-/* function ia_css_rmgr_sp_acq_gen: 620A */
+/* function ia_css_rmgr_sp_acq_gen: 620C */
 
-/* function input_system_input_port_open: 1151 */
+/* function input_system_input_port_open: 117E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isps
 #define HIVE_MEM_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_isps 0x72BC
+#define HIVE_ADDR_isps 0x72AC
 #define HIVE_SIZE_isps 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isps 0x72BC
+#define HIVE_ADDR_sp_isps 0x72AC
 #define HIVE_SIZE_sp_isps 28
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_queues_initialized
 #define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_queues_initialized 0x3D2C
+#define HIVE_ADDR_host_sp_queues_initialized 0x3D18
 #define HIVE_SIZE_host_sp_queues_initialized 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3D2C
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3D18
 #define HIVE_SIZE_sp_host_sp_queues_initialized 4
 
-/* function ia_css_queue_uninit: 5347 */
+/* function ia_css_queue_uninit: 5374 */
 
-/* function ia_css_tagger_buf_sp_is_locked: 3074 */
+/* function ia_css_tagger_buf_sp_is_locked: 30A1 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_ispctrl_sp_isp_started
 #define HIVE_MEM_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x6B64
+#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x6B50
 #define HIVE_SIZE_ia_css_ispctrl_sp_isp_started 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x6B64
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x6B50
 #define HIVE_SIZE_sp_ia_css_ispctrl_sp_isp_started 4
 
-/* function ia_css_bufq_sp_release_dynamic_buf: 324C */
+/* function ia_css_bufq_sp_release_dynamic_buf: 3279 */
 
-/* function ia_css_sp_metadata_thread_terminate: 5E17 */
+/* function ia_css_sp_metadata_thread_terminate: 5E43 */
 
-/* function ia_css_dmaproxy_sp_set_height_exception: 38C0 */
+/* function ia_css_dmaproxy_sp_set_height_exception: 38ED */
 
-/* function ia_css_dmaproxy_sp_init_vmem_channel: 3843 */
+/* function ia_css_dmaproxy_sp_init_vmem_channel: 3870 */
 
-/* function csi_rx_backend_stop: C53 */
+/* function csi_rx_backend_stop: C80 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_num_ready_threads
 #define HIVE_MEM_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_num_ready_threads 0x5A1C
+#define HIVE_ADDR_num_ready_threads 0x5A08
 #define HIVE_SIZE_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_num_ready_threads 0x5A1C
+#define HIVE_ADDR_sp_num_ready_threads 0x5A08
 #define HIVE_SIZE_sp_num_ready_threads 4
 
-/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 378A */
+/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 37B7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_spref
@@ -1861,47 +1859,47 @@
 #define HIVE_ADDR_sp_vbuf_spref 0x368
 #define HIVE_SIZE_sp_vbuf_spref 4
 
-/* function ia_css_queue_enqueue: 5287 */
+/* function ia_css_queue_enqueue: 52B4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_request
 #define HIVE_MEM_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_request 0x5A28
+#define HIVE_ADDR_ia_css_flash_sp_request 0x5A14
 #define HIVE_SIZE_ia_css_flash_sp_request 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x5A28
+#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x5A14
 #define HIVE_SIZE_sp_ia_css_flash_sp_request 4
 
-/* function ia_css_dmaproxy_sp_vmem_write: 3744 */
+/* function ia_css_dmaproxy_sp_vmem_write: 3771 */
 
-/* function ia_css_tagger_buf_sp_unmark: 311D */
+/* function ia_css_tagger_buf_sp_unmark: 314A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_if
 #define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_if 0x5844
+#define HIVE_ADDR_sem_for_reading_if 0x5830
 #define HIVE_SIZE_sem_for_reading_if 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_if 0x5844
+#define HIVE_ADDR_sp_sem_for_reading_if 0x5830
 #define HIVE_SIZE_sp_sem_for_reading_if 20
 
-/* function sp_generate_interrupts: 9EC */
+/* function sp_generate_interrupts: A19 */
 
-/* function ia_css_pipeline_sp_start: 2085 */
+/* function ia_css_pipeline_sp_start: 20B2 */
 
-/* function csi_rx_backend_enable: C41 */
+/* function csi_rx_backend_enable: C6E */
 
-/* function ia_css_sp_rawcopy_init: 5867 */
+/* function ia_css_sp_rawcopy_init: 5894 */
 
-/* function input_system_input_port_configure: 11A3 */
+/* function input_system_input_port_configure: 11D0 */
 
-/* function tmr_clock_read: AFD */
+/* function tmr_clock_read: B2A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_BAMEM_BASE
@@ -1918,28 +1916,28 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6ABC
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6AA8
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6ABC
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6AA8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_mem_map
 #define HIVE_MEM_mem_map scalar_processor_2400_dmem
-#define HIVE_ADDR_mem_map 0x3D30
+#define HIVE_ADDR_mem_map 0x3D1C
 #define HIVE_SIZE_mem_map 284
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_mem_map scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_mem_map 0x3D30
+#define HIVE_ADDR_sp_mem_map 0x3D1C
 #define HIVE_SIZE_sp_mem_map 284
 
-/* function isys2401_dma_config_legacy: E44 */
+/* function isys2401_dma_config_legacy: E71 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ibuf_ctrl_master_ports
@@ -1953,41 +1951,41 @@
 #define HIVE_ADDR_sp_ibuf_ctrl_master_ports 0x214
 #define HIVE_SIZE_sp_ibuf_ctrl_master_ports 12
 
-/* function css_get_frame_processing_time_start: 27FA */
+/* function css_get_frame_processing_time_start: 2827 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame
 #define HIVE_MEM_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame 0x5858
+#define HIVE_ADDR_sp_all_cbs_frame 0x5844
 #define HIVE_SIZE_sp_all_cbs_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame 0x5858
+#define HIVE_ADDR_sp_sp_all_cbs_frame 0x5844
 #define HIVE_SIZE_sp_sp_all_cbs_frame 16
 
-/* function ia_css_virtual_isys_sp_isr: 6F3B */
+/* function ia_css_virtual_isys_sp_isr: 6F46 */
 
-/* function thread_sp_queue_print: 1491 */
+/* function thread_sp_queue_print: 14BE */
 
-/* function sp_notify_eof: 998 */
+/* function sp_notify_eof: 9C5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_str2mem
 #define HIVE_MEM_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_str2mem 0x5868
+#define HIVE_ADDR_sem_for_str2mem 0x5854
 #define HIVE_SIZE_sem_for_str2mem 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_str2mem 0x5868
+#define HIVE_ADDR_sp_sem_for_str2mem 0x5854
 #define HIVE_SIZE_sp_sem_for_str2mem 20
 
-/* function ia_css_bufq_sp_acquire_dynamic_buf: 3459 */
+/* function ia_css_bufq_sp_acquire_dynamic_buf: 3486 */
 
-/* function ia_css_circbuf_destroy: 1730 */
+/* function ia_css_circbuf_destroy: 175D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_PMEM_BASE
@@ -2001,36 +1999,36 @@
 #define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
 #define HIVE_SIZE_sp_ISP_PMEM_BASE 4
 
-/* function ia_css_sp_isp_param_mem_load: 4E3B */
+/* function ia_css_sp_isp_param_mem_load: 4E68 */
 
-/* function __div: 67C3 */
+/* function __div: 67C5 */
 
-/* function ia_css_rmgr_sp_refcount_release_vbuf: 6304 */
+/* function ia_css_rmgr_sp_refcount_release_vbuf: 6306 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_in_use
 #define HIVE_MEM_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_in_use 0x5A2C
+#define HIVE_ADDR_ia_css_flash_sp_in_use 0x5A18
 #define HIVE_SIZE_ia_css_flash_sp_in_use 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x5A2C
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x5A18
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_use 4
 
-/* function ia_css_thread_sem_sp_wait: 6A9A */
+/* function ia_css_thread_sem_sp_wait: 6A9C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sleep_mode
 #define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sleep_mode 0x3E4C
+#define HIVE_ADDR_sp_sleep_mode 0x3E38
 #define HIVE_SIZE_sp_sleep_mode 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sleep_mode 0x3E4C
+#define HIVE_ADDR_sp_sp_sleep_mode 0x3E38
 #define HIVE_SIZE_sp_sp_sleep_mode 4
 
 /* function mmu_invalidate_cache: EA */
@@ -2047,27 +2045,23 @@
 #define HIVE_ADDR_sp_sp_max_cb_elems 0x140
 #define HIVE_SIZE_sp_sp_max_cb_elems 8
 
-/* function ia_css_dmaproxy_sp_register_channel_to_port: 3702 */
+/* function ia_css_dmaproxy_sp_register_channel_to_port: 372F */
 
-/* function ia_css_queue_remote_init: 5369 */
+/* function ia_css_queue_remote_init: 5396 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stop_req
 #define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stop_req 0x56FC
+#define HIVE_ADDR_isp_stop_req 0x56E8
 #define HIVE_SIZE_isp_stop_req 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stop_req 0x56FC
+#define HIVE_ADDR_sp_isp_stop_req 0x56E8
 #define HIVE_SIZE_sp_isp_stop_req 4
 
 #define HIVE_ICACHE_sp_critical_SEGMENT_START 0
 #define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
 
 #endif /* _sp_map_h_ */
-extern void sh_css_dump_sp_dmem(void);
-void sh_css_dump_sp_dmem(void)
-{
-}
-- 
1.7.9.5

