From ddec7e43e544cff47523a70ae3eff8ea2a4cd0e3 Mon Sep 17 00:00:00 2001
From: Andy Ross <andrew.j.ross@intel.com>
Date: Tue, 17 Jun 2014 15:38:49 -0700
Subject: [PATCH 069/117] gc2235: Clobber with CTS mrd7 tree

FORK LIFT PATCH. DOES NOT BUILD WITHOUT FURTHER CHANGES.

Replace the Galaxycore 2235 driver with source forklifted from the
umg/byt/cr/ext/ww21 branch of
ssh://mcg-cts-gcr.jf.intel.com/a/bsp/linux/modules/camera as of
commit:

    commit 50803352f9814f2931d011fea31108f79e1560b4
    Author: chenyi2x <yingx.z.chen@intel.com>
    Date:   Thu May 29 17:26:45 2014 +0800

    Output isp timeout infomation.

    bz:486

    Change-Id: I73f16a5f32e9fff043d49147e4e11a39316a22ab
    Signed-off-by: chenyi2x <yingx.z.chen@intel.com>

Issue: GMIN-1853
Change-Id: I5f8f13ded86185c8cf5731cef0f140e620e3a90d
Signed-off-by: Andy Ross <andrew.j.ross@intel.com>
---
 .../camera/drivers/media/i2c/gc2235.c              | 1818 +++++++++++---------
 .../camera/drivers/media/i2c/gc2235.h              |  862 +++++-----
 2 files changed, 1471 insertions(+), 1209 deletions(-)

diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
index fa7bc18..55802ab 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
@@ -1,7 +1,7 @@
 /*
- * Support for GalaxyCore GC2235 2M camera sensor.
+ * Support for Sony gc2235 8MP camera sensor.
  *
- * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -18,79 +18,92 @@
  * 02110-1301, USA.
  *
  */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/kmod.h>
+#include <linux/bitops.h>
 #include <linux/device.h>
-#include <linux/acpi.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/i2c.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
 #include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <media/v4l2-device.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
 #include <media/v4l2-chip-ident.h>
-#include <linux/io.h>
-#include <linux/atomisp_gmin_platform.h>
-
+#include <media/v4l2-device.h>
+#include <asm/intel-mid.h>
 #include "gc2235.h"
+#include <asm/intel-mid.h>
 
-/* i2c read/write stuff */
-static int gc2235_read_reg(struct i2c_client *client,
-			   u16 data_length, u16 reg, u16 *val)
+#ifndef POWER_ALWAYS_ON_BEFORE_SUSPEND
+#define POWER_ALWAYS_ON_BEFORE_SUSPEND
+#endif
+
+static enum atomisp_bayer_order gc2235_bayer_order_mapping[] = {
+	atomisp_bayer_order_gbrg,
+	atomisp_bayer_order_bggr,
+	atomisp_bayer_order_rggb,
+	atomisp_bayer_order_grbg,
+};
+
+u16 g_gain = 0, g_exposure = 0;
+u8 g_flip = 0x14;
+
+static int
+gc2235_read_reg(struct i2c_client *client, u8 len, u8 reg, u8 *val)
 {
-	int err;
 	struct i2c_msg msg[2];
-	unsigned char data[6];
+	unsigned char data[GC2235_SHORT_MAX];
+	int err, i;
 
-	if (!client->adapter) {
-		dev_err(&client->dev, "%s error, no client->adapter\n",
-			__func__);
-		return -ENODEV;
-	}
-
-	if (data_length != GC2235_8BIT) {
+	if (len > GC2235_BYTE_MAX) {
 		dev_err(&client->dev, "%s error, invalid data length\n",
 			__func__);
 		return -EINVAL;
 	}
 
 	memset(msg, 0 , sizeof(msg));
+	memset(data, 0 , sizeof(data));
 
 	msg[0].addr = client->addr;
 	msg[0].flags = 0;
 	msg[0].len = 1;
-	msg[0].buf = data;
-
-	/* high byte goes out first */
-	data[0] = (u8)(reg & 0xff);
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = reg;
 
 	msg[1].addr = client->addr;
-	msg[1].len = data_length;
+	msg[1].len = len;
 	msg[1].flags = I2C_M_RD;
-	msg[1].buf = data;
+	msg[1].buf = (u8 *)data;
 
 	err = i2c_transfer(client->adapter, msg, 2);
 	if (err != 2) {
 		if (err >= 0)
 			err = -EIO;
-		dev_err(&client->dev,
-			"read from offset 0x%x error %d", reg, err);
-		return err;
+		goto error;
 	}
 
-	*val = 0;
 	/* high byte comes first */
-	if (data_length == GC2235_8BIT)
+	if (len == GC2235_8BIT) {
 		*val = (u8)data[0];
+	} else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			val[i] = be16_to_cpu(data[i]);
+	}
 
 	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
 }
 
 static int gc2235_i2c_write(struct i2c_client *client, u16 len, u8 *data)
@@ -103,27 +116,33 @@ static int gc2235_i2c_write(struct i2c_client *client, u16 len, u8 *data)
 	msg.flags = 0;
 	msg.len = len;
 	msg.buf = data;
+
 	ret = i2c_transfer(client->adapter, &msg, 1);
 
 	return ret == num_msg ? 0 : -EIO;
 }
 
-static int gc2235_write_reg(struct i2c_client *client, u16 data_length,
-							u8 reg, u8 val)
+static int
+gc2235_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
 {
 	int ret;
 	unsigned char data[4] = {0};
-	const u16 len = data_length + sizeof(u8); /* 16-bit address + data */
+	const u16 len = data_length + 1; /* 16-bit address + data */
 
-	if (data_length != GC2235_8BIT) {
-		dev_err(&client->dev,
-			"%s error, invalid data_length\n", __func__);
+	if (data_length != GC2235_8BIT && data_length != GC2235_16BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
 		return -EINVAL;
 	}
 
 	/* high byte goes out first */
 	data[0] = reg;
-	data[1] = val;
+	if (data_length == GC2235_8BIT)
+		data[1] = (u8)(val);
+	else {
+		/* GC2235_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
 
 	ret = gc2235_i2c_write(client, len, data);
 	if (ret)
@@ -133,323 +152,694 @@ static int gc2235_write_reg(struct i2c_client *client, u16 data_length,
 
 	return ret;
 }
-static int __gc2235_flush_reg_array(struct i2c_client *client,
-				    struct gc2235_write_ctrl *ctrl)
+
+static int gc2235_write_reg_array(struct i2c_client *client,
+				   const struct gc2235_reg *reglist)
 {
-	u16 size;
+	const struct gc2235_reg *next = reglist;
+	struct gc2235_write_ctrl ctrl;
+	int err;
 
-	if (ctrl->index == 0)
-		return 0;
+	ctrl.index = 0;
+	for (; next->type != GC2235_TOK_TERM; next++) {
+		switch (next->type & GC2235_TOK_MASK) {
+		case GC2235_TOK_DELAY:
+			msleep(next->val);
+			break;
 
-	size = sizeof(u8) + ctrl->index; /* 8-bit address + data */
-	ctrl->index = 0;
+		default:
+			gc2235_write_reg(client, GC2235_8BIT,
+			       next->sreg, next->val);
+		}
+	}
 
-	return gc2235_i2c_write(client, size, (u8 *)&ctrl->buffer);
+	return 0;
 }
 
-static int __gc2235_buf_reg_array(struct i2c_client *client,
-				  struct gc2235_write_ctrl *ctrl,
-				  const struct gc2235_reg *next)
+static int __gc2235_update_exposure_timing(struct i2c_client *client,
+					u16 exposure, u16 llp, u16 fll)
 {
-	int size;
+	int ret = 0;
+	u8 expo_coarse_h, expo_coarse_l;
 
-	if (next->type != GC2235_8BIT)
-		return -EINVAL;
+	/* Increase the VTS to match exposure + margin */
+	if (exposure > fll - GC2235_INTEGRATION_TIME_MARGIN)
+		fll = exposure + GC2235_INTEGRATION_TIME_MARGIN;
 
-	size = 1;
-	ctrl->buffer.data[ctrl->index] = (u8)next->val;
+	expo_coarse_h = (u8)(exposure >> 8);
+	expo_coarse_l = (u8)(exposure & 0xff);
+	ret = gc2235_write_reg(client, GCSENSOR_8BIT, GC2235_REG_EXPO_COARSE, expo_coarse_h);
+	if (ret)
+		return ret;
+	ret = gc2235_write_reg(client, GCSENSOR_8BIT, GC2235_REG_EXPO_COARSE+1, expo_coarse_l);
 
-	/* When first item is added, we need to store its starting address */
-	if (ctrl->index == 0)
-		ctrl->buffer.addr = next->reg;
+	return ret;
+}
 
-	ctrl->index += size;
+static int __gc2235_update_gain(struct v4l2_subdev *sd, u16 gain)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 temp;
 
-	/*
-	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
-	 * possible lack of memory for next item.
-	 */
-	if (ctrl->index + sizeof(u8) >= GC2235_MAX_WRITE_BUF_SIZE)
-		return __gc2235_flush_reg_array(client, ctrl);
+	/* set global gain */
+	if (256 > gain)	{
+		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb0, 0x40);
+		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb1, gain & 0xff);
+	} else {
+		temp = 64 * gain / 256;
+		if (temp > 0xff)
+			temp = 0xff;
+		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb0, temp & 0xff);
+		gc2235_write_reg(client, GCSENSOR_8BIT, 0xb1, 0xff);
+	}
 
 	return 0;
 }
-static int __gc2235_write_reg_is_consecutive(struct i2c_client *client,
-					     struct gc2235_write_ctrl *ctrl,
-					     const struct gc2235_reg *next)
+
+static int gc2235_set_exposure_gain(struct v4l2_subdev *sd, u16 coarse_itg,
+	u16 gain, u16 digitgain)
 {
-	if (ctrl->index == 0)
-		return 1;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	/* Validate exposure:  cannot exceed VTS-4 where VTS is 16bit */
+	coarse_itg = clamp_t(u16, coarse_itg, 0, GC2235_MAX_EXPOSURE_SUPPORTED);
+
+	/* Validate gain: must not exceed maximum 8bit value */
+	gain = clamp_t(u16, gain, 0, GC2235_MAX_GLOBAL_GAIN_SUPPORTED);
+	g_gain = gain;
+	g_exposure = coarse_itg;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = __gc2235_update_exposure_timing(client, coarse_itg,
+			dev->pixels_per_line, dev->lines_per_frame);
+	if (ret)
+		goto out;
+	dev->coarse_itg = coarse_itg;
 
-	return ctrl->buffer.addr + ctrl->index == next->reg;
+	ret = __gc2235_update_gain(sd, gain);
+	if (ret)
+		goto out;
+	dev->gain = gain;
+out:
+	mutex_unlock(&dev->input_lock);
+	return ret;
 }
-static int gc2235_write_reg_array(struct i2c_client *client,
-				  const struct gc2235_reg *reglist)
+
+static long gc2235_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
 {
-	const struct gc2235_reg *next = reglist;
-	struct gc2235_write_ctrl ctrl;
-	int err;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 
-	ctrl.index = 0;
-	for (; next->type != GC2235_TOK_TERM; next++) {
-		switch (next->type & GC2235_TOK_MASK) {
-		case GC2235_TOK_DELAY:
-			err = __gc2235_flush_reg_array(client, &ctrl);
-			if (err)
-				return err;
-			msleep(next->val);
-			break;
-		default:
-			/*
-			 * If next address is not consecutive, data needs to be
-			 * flushed before proceed.
-			 */
-			if (!__gc2235_write_reg_is_consecutive(client, &ctrl,
-								next)) {
-				err = __gc2235_flush_reg_array(client, &ctrl);
-				if (err)
-					return err;
-			}
-			err = __gc2235_buf_reg_array(client, &ctrl, next);
-			if (err) {
-				dev_err(&client->dev, "%s: write error, aborted\n",
-					 __func__);
-				return err;
-			}
-			break;
-		}
+	dev_dbg(&client->dev, "%s(0x%X 0x%X 0x%X)\n", __func__, exposure->integration_time[0], exposure->gain[0], exposure->gain[1]);
+	return gc2235_set_exposure_gain(sd, exposure->integration_time[0],
+				exposure->gain[0], exposure->gain[1]);
+}
+
+static long gc2235_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return gc2235_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret;
+
+       /* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control*/
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/*MCLK to PWDN*/
+	usleep_range(1000, 1500);
+
+	/* gpio ctrl*/
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "gpio failed\n");
+		goto fail_gpio;
 	}
 
-	return __gc2235_flush_reg_array(client, &ctrl);
+	msleep(50);
+	return 0;
+
+fail_gpio:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
 }
 
-static int gc2235_g_focal(struct v4l2_subdev *sd, s32 *val)
+static int power_down(struct v4l2_subdev *sd)
 {
-	*val = (GC2235_FOCAL_LENGTH_NUM << 16) | GC2235_FOCAL_LENGTH_DEM;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl*/
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	msleep(20);
+
+	return ret;
+}
+
+static int gc2235_set_suspend(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x03);
+	gc2235_write_reg(client, GCSENSOR_8BIT,  0x10, 0x81);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
+
 	return 0;
 }
 
-static int gc2235_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+static int gc2235_set_streaming(struct v4l2_subdev *sd)
 {
-	/*const f number for imx*/
-	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 16) | GC2235_F_NUMBER_DEM;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x30);
+	__gc2235_update_exposure_timing(client, g_exposure, 0, 0);
+	__gc2235_update_gain(sd, g_gain);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x03);
+	gc2235_write_reg(client, GCSENSOR_8BIT,  0x10, 0x91);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
 	return 0;
 }
 
-static int gc2235_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+static int gc2235_init_common(struct v4l2_subdev *sd)
 {
-	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 24) |
-		(GC2235_F_NUMBER_DEM << 16) |
-		(GC2235_F_NUMBER_DEFAULT_NUM << 8) | GC2235_F_NUMBER_DEM;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = -1;
+
+       if (0 != (ret = gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x80))) {
+               dev_err(&client->dev, "%s:init common error", __func__);
+               return ret;
+       }
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x80);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x80);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf2, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf6, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfc, 0x06);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf7, 0x15);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf8, 0x85);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfa, 0x00);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf9, 0xfe);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x03, 0x04);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x04, 0xb0);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x05, 0x01);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x06, 0x2a);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x07, 0x00);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x08, 0x30);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0a, 0x02);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0c, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0d, 0x04);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0e, 0xd0);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x0f, 0x06);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x10, 0x58);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x17, 0x14);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x17, g_flip);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x18, 0x12);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x19, 0x0d);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1a, 0x01);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1b, 0x48);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1e, 0x88);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x1f, 0x48);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x20, 0x03);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x21, 0x6f);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x22, 0x80);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x23, 0xc1);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x24, 0x2f);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x26, 0x01);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x27, 0x30);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x3f, 0x00);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x8b, 0xa4);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x8c, 0x02);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x90, 0x01);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x92, 0x02);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x94, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x95, 0x04);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x96, 0xc0);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x97, 0x06);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x98, 0x50);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x40, 0x72);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x41, 0x04);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x5e, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x5f, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x60, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x61, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x62, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x63, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x64, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x65, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x66, 0x20);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x67, 0x20);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x68, 0x20);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x69, 0x20);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb2, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb3, 0x40);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb4, 0x40);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb5, 0x40);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb8, 0x0f);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xb9, 0x23);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xba, 0xff);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbc, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbd, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbe, 0xff);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xbf, 0x09);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x03);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x01, 0x07);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x02, 0x11);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x03, 0x11);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x06, 0x80);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x11, 0x2b);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x12, 0xe4);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x13, 0x07);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x15, 0x12);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x04, 0x20);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x05, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x17, 0x01);
+
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x21, 0x01);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x22, 0x02);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x23, 0x01);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x29, 0x02);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0x2a, 0x01);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xfe, 0x00);
+	gc2235_write_reg(client, GCSENSOR_8BIT, 0xf2, 0x00);
+
 	return 0;
 }
 
+static int __gc2235_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret = 0;
+
+	if (on == 0) {
+		ret = power_down(sd);
+		dev->power = 0;
+	} else {
+		ret = power_up(sd);
+		if (!ret) {
+			dev->power = 1;
+			return gc2235_init_common(sd);
+		}
+	}
+
+	return ret;
+}
+
+static int gc2235_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __gc2235_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
+static int __gc2235_s_power_always_on(struct v4l2_subdev *sd, int on)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret = 0;
+
+	if (on == 0) {
+		//ret = power_down(sd);
+		//dev->power = 0;
+	} else {
+		if (!dev->power) {
+			ret = power_up(sd);
+			if (!ret) {
+				dev->power = 1;
+				dev->once_launched = 1;
+				return gc2235_init_common(sd);
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int gc2235_s_power_always_on(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __gc2235_s_power_always_on(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+#endif
+
+static int gc2235_g_chip_ident(struct v4l2_subdev *sd,
+				struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!chip)
+		return -EINVAL;
+
+	v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_GC, 0);
+
+	return 0;
+}
 
 static int gc2235_get_intg_factor(struct i2c_client *client,
 				struct camera_mipi_info *info,
-				const struct gc2235_resolution *res)
+				const struct gc2235_reg *reglist)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	struct atomisp_sensor_mode_data *buf = &info->data;
-	u16 reg_val, reg_val_h, dummy;
 	int ret;
+	u8 data[GC2235_INTG_BUF_COUNT];
+
+	u32 vt_pix_clk_freq_mhz;
+	u32 coarse_integration_time_min;
+	u32 coarse_integration_time_max_margin;
+	u16 tmp;
 
 	if (info == NULL)
 		return -EINVAL;
 
-	/* pixel clock calculattion */
-	buf->vt_pix_clk_freq_mhz = dev->vt_pix_clk_freq_mhz = 43750000;
+	ret =  gc2235_write_reg(client, 1, 0xfe, 0);
+	if (ret)
+		return ret;
+
+	memset(data, 0, GC2235_INTG_BUF_COUNT);
+	coarse_integration_time_min = 1;
+	coarse_integration_time_max_margin = 6;
 
-	/* get integration time */
-	buf->coarse_integration_time_min = GC2235_COARSE_INTG_TIME_MIN;
+	vt_pix_clk_freq_mhz = 67200000;
+
+	dev->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+
+	buf->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf->coarse_integration_time_min = coarse_integration_time_min;
 	buf->coarse_integration_time_max_margin =
-					GC2235_COARSE_INTG_TIME_MAX_MARGIN;
-
-	buf->fine_integration_time_min = GC2235_FINE_INTG_TIME_MIN;
-	buf->fine_integration_time_max_margin =
-					GC2235_FINE_INTG_TIME_MAX_MARGIN;
-
-	buf->fine_integration_time_def = GC2235_FINE_INTG_TIME_MIN;
-	buf->frame_length_lines = res->lines_per_frame;
-	buf->line_length_pck = res->pixels_per_line;
-	buf->read_mode = res->bin_mode;
-
-	/* get the cropping and output resolution to ISP for this mode. */
-	ret =  gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_H_CROP_START_H, &reg_val_h);
-	ret =  gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_H_CROP_START_L, &reg_val);
+				coarse_integration_time_max_margin;
+
+	buf->fine_integration_time_min = GC2235_FINE_INTG_TIME;
+	buf->fine_integration_time_max_margin = GC2235_FINE_INTG_TIME;
+	buf->fine_integration_time_def = GC2235_FINE_INTG_TIME;
+
+	buf->frame_length_lines = dev->curr_res_table[dev->fmt_idx].lines_per_frame;
+	buf->line_length_pck = dev->curr_res_table[dev->fmt_idx].pixels_per_line;
+	buf->read_mode = dev->curr_res_table[dev->fmt_idx].bin_mode;
+
+	/* Get the cropping and output resolution to ISP for this mode. */
+	tmp = 0;
+	ret = gc2235_read_reg(client, 1, GC2235_HORIZONTAL_START_H, data);
+	if (ret)
+		return ret;
+	tmp = (data[0] & 0x07) << 8;
+	ret =  gc2235_read_reg(client, 1, GC2235_HORIZONTAL_START_L, data);
 	if (ret)
 		return ret;
+	tmp += data[0] & 0x7f;
+	buf->crop_horizontal_start = tmp;
 
-	buf->crop_horizontal_start = ((u16)reg_val_h << 8) | (u16)reg_val;
+	tmp = 0;
+	ret = gc2235_read_reg(client, 1, GC2235_VERTICAL_START_H, data);
+	if (ret)
+		return ret;
+	tmp = data[0] << 8;
+	ret =  gc2235_read_reg(client, 1, GC2235_VERTICAL_START_L, data);
+	if (ret)
+		return ret;
+	tmp += data[0];
+	buf->crop_vertical_start = tmp;
+
+	tmp = 0;
+	ret = gc2235_read_reg(client, 1, GC2235_HORIZONTAL_OUTPUT_SIZE_H, data);
+	if (ret)
+		return ret;
+	tmp = (data[0] & 0x07) << 8;
+	ret = gc2235_read_reg(client, 1, GC2235_HORIZONTAL_OUTPUT_SIZE_L, data);
+	if (ret)
+		return ret;
+	tmp += data[0] & 0x7f ;
+	buf->output_width = tmp;
+	buf->crop_horizontal_end = buf->crop_horizontal_start + tmp - 1;
 
-	ret =  gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_V_CROP_START_H, &reg_val_h);
-	ret =  gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_V_CROP_START_L, &reg_val);
+	tmp = 0;
+	ret = gc2235_read_reg(client, 1, GC2235_VERTICAL_OUTPUT_SIZE_H, data);
+	if (ret)
+		return ret;
+	tmp = (data[0] & 0x07) << 8;
+	ret = gc2235_read_reg(client, 1, GC2235_VERTICAL_OUTPUT_SIZE_L, data);
 	if (ret)
 		return ret;
+	tmp += data[0];
+	buf->output_height = tmp;
+	buf->crop_vertical_end = tmp + buf->crop_vertical_start - 1;
 
-	buf->crop_vertical_start = ((u16)reg_val_h << 8) | (u16)reg_val;
+	tmp = 0;
+	ret = gc2235_read_reg(client, GC2235_8BIT, REG_HORI_BLANKING_H, data);
+	tmp = (data[0] & 0x0f) << 8;
+	ret = gc2235_read_reg(client, GC2235_8BIT, REG_HORI_BLANKING_L, data);
+	tmp += data[0];
 
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_H_OUTSIZE_H, &reg_val_h);
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_H_OUTSIZE_L, &reg_val);
+	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_SH_DELAY_H, data);
 	if (ret)
 		return ret;
-	buf->output_width = ((u16)reg_val_h << 8) | (u16)reg_val;
+	tmp += (data[0] & 0x03) << 8;
 
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_V_OUTSIZE_H, &reg_val_h);
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_V_OUTSIZE_L, &reg_val);
+	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_SH_DELAY_L, data);
 	if (ret)
 		return ret;
-	buf->output_height = ((u16)reg_val_h << 8) | (u16)reg_val;
+	tmp += data[0];
 
-	buf->crop_horizontal_end = buf->crop_horizontal_start +
-						buf->output_width - 1;
-	buf->crop_vertical_end = buf->crop_vertical_start +
-						buf->output_height - 1;
+	buf->line_length_pck = (buf->output_width / 2 + tmp + 4) * 2;
 
+	tmp = 0;
+	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_VERT_DUMMY_H, data);
+	tmp = (data[0] & 0x1f) << 8;
+	ret = gc2235_read_reg(client, GC2235_8BIT,  REG_VERT_DUMMY_L, data);
+	tmp += data[0];
+	buf->frame_length_lines = buf->output_height + tmp;
+
+	buf->binning_factor_x = 1;
+	buf->binning_factor_y = 1;
+
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse;
+	u8 tmp;
+	int ret;
+
+	/* the fine integration time is currently not calculated */
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_HB_H, &reg_val_h);
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_HB_L, &reg_val);
-	if (ret)
+			       GC2235_REG_EXPO_COARSE, &tmp);
+	if (ret != 0)
 		return ret;
 
-	dummy = ((u16)reg_val_h << 8) | (u16)reg_val;
+	coarse = (u16)((tmp & 0x1f) << 8);
 
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_SH_DELAY_H, &reg_val_h);
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_SH_DELAY_L, &reg_val);
+			       GC2235_REG_EXPO_COARSE + 1, &tmp);
 
-	buf->line_length_pck = buf->output_width + 16 + dummy +
-				(((u16)reg_val_h << 8) | (u16)reg_val) + 4;
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_VB_H, &reg_val_h);
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_VB_L, &reg_val);
-	if (ret)
+	if (ret != 0)
 		return ret;
 
-	buf->frame_length_lines = buf->output_height + 32 +
-				(((u16)reg_val_h << 8) | (u16)reg_val);
-	buf->binning_factor_x = res->bin_factor_x ?
-					res->bin_factor_x : 1;
-	buf->binning_factor_y = res->bin_factor_y ?
-					res->bin_factor_y : 1;
-	return 0;
+	coarse += (u16)tmp;
+
+	*value = coarse;
+
+	return ret;
 }
 
-static long __gc2235_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
-				 int gain, int digitgain)
+static enum v4l2_mbus_pixelcode
+gc2235_translate_bayer_order(enum atomisp_bayer_order code)
+{
+	switch (code) {
+	case atomisp_bayer_order_rggb:
+		return V4L2_MBUS_FMT_SRGGB10_1X10;
+	case atomisp_bayer_order_grbg:
+		return V4L2_MBUS_FMT_SGRBG10_1X10;
+	case atomisp_bayer_order_bggr:
+		return V4L2_MBUS_FMT_SBGGR10_1X10;
+	case atomisp_bayer_order_gbrg:
+		return V4L2_MBUS_FMT_SGBRG10_1X10;
+	}
+	return 0;
+}
 
+static int gc2235_v_flip(struct v4l2_subdev *sd, s32 value)
 {
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct camera_mipi_info *gc2235_info = NULL;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 coarse_integration = (u16)coarse_itg;
-	int ret = 0;
-	u16 expo_coarse_h,expo_coarse_l, gain_val = 0xF0, gain_val2 = 0xF0;
-	expo_coarse_h = coarse_integration>>8;
-	expo_coarse_l = coarse_integration & 0xff;
+	int ret;
+	int need_write = 0;
+	u8 val;
 
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-					GC2235_EXPOSURE_H, expo_coarse_h);
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-					GC2235_EXPOSURE_L, expo_coarse_l);
-
-	if (gain <= 0x58) {
-		gain_val = 0x40;
-		gain_val2 = 0x58;
-	} else if (gain < 256) {
-		gain_val = 0x40;
-		gain_val2 = gain;
+	val = g_flip;
+	dev_dbg(&client->dev, "@%s++ %d, 0x17:0x%x\n", __func__, value, val);
+	if (value) {
+		val |= GC2235_VFLIP_BIT;
 	} else {
-		gain_val2 = 64 * gain / 256;
-		gain_val = 0xff;
+		val &= ~GC2235_VFLIP_BIT;
 	}
-
-	ret = gc2235_write_reg(client, GC2235_8BIT,
-					GC2235_GLOBAL_GAIN, (u8)gain_val);
 	ret = gc2235_write_reg(client, GC2235_8BIT,
-					GC2235_PRE_GAIN, (u8)gain_val2);
+		GC2235_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
+	g_flip = val;
+	gc2235_info = v4l2_get_subdev_hostdata(sd);
+	if (gc2235_info) {
+		val &= (GC2235_VFLIP_BIT|GC2235_HFLIP_BIT);
+		gc2235_info->raw_bayer_order = gc2235_bayer_order_mapping[val];
+		dev->format.code = gc2235_translate_bayer_order(
+			gc2235_info->raw_bayer_order);
+	}
 
-	return ret;
+	return 0;
 }
 
-static int gc2235_set_exposure(struct v4l2_subdev *sd, int exposure,
-	int gain, int digitgain)
+static int gc2235_h_flip(struct v4l2_subdev *sd, s32 value)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct camera_mipi_info *gc2235_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
+	int need_write = 0;
+	u8 val;
 
-	mutex_lock(&dev->input_lock);
-	ret = __gc2235_set_exposure(sd, exposure, gain, digitgain);
-	mutex_unlock(&dev->input_lock);
+	val = g_flip;
+	dev_dbg(&client->dev, "@%s++ %d, 0x17:0x%x\n", __func__, value, val);
+	if (value){
+		val |= GC2235_HFLIP_BIT;
+	} else {
+		val &= ~GC2235_HFLIP_BIT;
+	}
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+		GC2235_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
 
-	return ret;
+	g_flip = val;
+	gc2235_info = v4l2_get_subdev_hostdata(sd);
+	if (gc2235_info) {
+		val &= (GC2235_VFLIP_BIT|GC2235_HFLIP_BIT);
+		gc2235_info->raw_bayer_order = gc2235_bayer_order_mapping[val];
+		dev->format.code = gc2235_translate_bayer_order(
+		gc2235_info->raw_bayer_order);
+	}
+
+	return 0;
 }
 
-static long gc2235_s_exposure(struct v4l2_subdev *sd,
-			       struct atomisp_exposure *exposure)
+static int gc2235_g_focal(struct v4l2_subdev *sd, s32 *val)
 {
-	int exp = exposure->integration_time[0];
-	int gain = exposure->gain[0];
-	int digitgain = exposure->gain[1];
-
-	/* we should not accept the invalid value below. */
-	if (gain == 0) {
-		struct i2c_client *client = v4l2_get_subdevdata(sd);
-		v4l2_err(client, "%s: invalid value\n", __func__);
-		return -EINVAL;
-	}
-
-	return gc2235_set_exposure(sd, exp, gain, digitgain);
+	*val = (GC2235_FOCAL_LENGTH_NUM << 16) | GC2235_FOCAL_LENGTH_DEM;
+	return 0;
 }
 
-static long gc2235_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+static int gc2235_g_fnumber(struct v4l2_subdev *sd, s32 *val)
 {
+	/*const f number for gc2235*/
+	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 16) | GC2235_F_NUMBER_DEM;
+	return 0;
+}
 
-	switch (cmd) {
-	case ATOMISP_IOC_S_EXPOSURE:
-		return gc2235_s_exposure(sd, arg);
-	default:
-		return -EINVAL;
-	}
+static int gc2235_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 24) |
+		(GC2235_F_NUMBER_DEM << 16) |
+		(GC2235_F_NUMBER_DEFAULT_NUM << 8) | GC2235_F_NUMBER_DEM;
 	return 0;
 }
 
 /* This returns the exposure time being used. This should only be used
    for filling in EXIF data, not for actual image processing. */
-static int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)
+static int gc2235_g_exposure(struct v4l2_subdev *sd, s32 *value)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	u16 reg_v, reg_v2;
+	u16 coarse;
+	u8 reg_val_h, reg_val_l;
 	int ret;
 
-	/* get exposure */
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_EXPOSURE_L,
-					&reg_v);
+	/* the fine integration time is currently not calculated */
+	ret = gc2235_read_reg(client, GCSENSOR_8BIT,
+			       GC2235_REG_EXPO_COARSE, &reg_val_h);
 	if (ret)
-		goto err;
+		return ret;
 
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_EXPOSURE_H,
-					&reg_v2);
+	coarse = ((u16)(reg_val_h & 0x1f)) << 8;
+
+	ret = gc2235_read_reg(client, GCSENSOR_8BIT,
+			       GC2235_REG_EXPO_COARSE + 1, &reg_val_l);
 	if (ret)
-		goto err;
+		return ret;
 
-	reg_v += reg_v2 << 8;
+	coarse |= reg_val_l;
 
-	*value = reg_v;
-err:
-	return ret;
+	*value = coarse;
+	return 0;
 }
 
 struct gc2235_control gc2235_controls[] = {
@@ -468,6 +858,30 @@ struct gc2235_control gc2235_controls[] = {
 	},
 	{
 		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc2235_v_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Mirror",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc2235_h_flip,
+	},
+	{
+		.qc = {
 			.id = V4L2_CID_FOCAL_ABSOLUTE,
 			.type = V4L2_CTRL_TYPE_INTEGER,
 			.name = "focal length",
@@ -505,9 +919,22 @@ struct gc2235_control gc2235_controls[] = {
 		},
 		.query = gc2235_g_fnumber_range,
 	},
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = gc2235_g_exposure,
+	},
 };
-#define N_CONTROLS (ARRAY_SIZE(gc2235_controls))
 
+#define N_CONTROLS (ARRAY_SIZE(gc2235_controls))
 static struct gc2235_control *gc2235_find_control(u32 id)
 {
 	int i;
@@ -533,7 +960,7 @@ static int gc2235_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
 	return 0;
 }
 
-/* imx control set/get */
+/* gc2235 control set/get */
 static int gc2235_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 {
 	struct gc2235_control *s_ctrl;
@@ -560,619 +987,345 @@ static int gc2235_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	int ret;
 
-	if ((octrl == NULL) || (octrl->tweak == NULL))
-		return -EINVAL;
-
-	mutex_lock(&dev->input_lock);
-	ret = octrl->tweak(sd, ctrl->value);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-static int __gc2235_init(struct v4l2_subdev *sd)
-{
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	/* restore settings */
-	gc2235_res = gc2235_res_preview;
-	N_RES = N_RES_PREVIEW;
-
-	return gc2235_write_reg_array(client, gc2235_init_settings);
-}
-
-static int gc2235_init(struct v4l2_subdev *sd)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	int ret = 0;
-
-	mutex_lock(&dev->input_lock);
-	ret = __gc2235_init(sd);
-	mutex_unlock(&dev->input_lock);
-
-	return ret;
-}
-
-static int power_ctrl(struct v4l2_subdev *sd, int flag)
-{
-	int ret;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->power_ctrl)
-		return dev->platform_data->power_ctrl(sd, flag);
-
-	if (flag) {
-		ret = dev->platform_data->v1p8_ctrl(sd, 1);
-		usleep_range(60, 90);
-		ret = dev->platform_data->v2p8_ctrl(sd, 1);
-		msleep(20);
-	} else {
-		ret = dev->platform_data->v2p8_ctrl(sd, 0);
-		ret |= dev->platform_data->v1p8_ctrl(sd, 0);
-	}
-	return ret;
-}
-
-
-static int gpio_ctrl(struct v4l2_subdev *sd, int flag)
-{
-	int ret;
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-
-	if (!dev || !dev->platform_data)
-		return -ENODEV;
-
-	/* Non-gmin platforms use the legacy callback */
-	if (dev->platform_data->gpio_ctrl)
-		return dev->platform_data->gpio_ctrl(sd, flag);
-
-	/* GPIO0 == "reset" (active low), GPIO1 == "power down" */
-	if (flag) {
-		ret = dev->platform_data->gpio1_ctrl(sd, 0);
-		ret |= dev->platform_data->gpio0_ctrl(sd, 1);
-	} else {
-		ret = dev->platform_data->gpio1_ctrl(sd, 1);
-		ret |= dev->platform_data->gpio0_ctrl(sd, 0);
-	}
-	return ret;
-}
-
-static int power_up(struct v4l2_subdev *sd)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret;
-
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
-		return -ENODEV;
-	}
-	/* power control */
-	ret = power_ctrl(sd, 1);
-	if (ret)
-		goto fail_power;
-
-	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
-	usleep_range(5000, 6000);
-
-	ret = dev->platform_data->flisclk_ctrl(sd, 1);
-	if (ret)
-		goto fail_clk;
-	usleep_range(5000, 6000);
-
-	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 1);
-	if (ret) {
-		ret = gpio_ctrl(sd, 1);
-		if (ret)
-			goto fail_power;
-	}
-
-	msleep(50);
-
-	return 0;
-
-fail_clk:
-	gpio_ctrl(sd, 0);
-fail_power:
-	power_ctrl(sd, 0);
-	dev_err(&client->dev, "sensor power-up failed\n");
-
-	return ret;
-}
-
-static int power_down(struct v4l2_subdev *sd)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
-
-	if (NULL == dev->platform_data) {
-		dev_err(&client->dev,
-			"no camera_sensor_platform_data");
-		return -ENODEV;
-	}
-	/* gpio ctrl */
-	ret = gpio_ctrl(sd, 0);
-	if (ret) {
-		ret = gpio_ctrl(sd, 0);
-		if (ret)
-			dev_err(&client->dev, "gpio failed 2\n");
-	}
-
-	ret = dev->platform_data->flisclk_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "flisclk failed\n");
-
-	/* power control */
-	ret = power_ctrl(sd, 0);
-	if (ret)
-		dev_err(&client->dev, "vprog failed.\n");
-
-	return ret;
-}
-
-static int gc2235_s_power(struct v4l2_subdev *sd, int on)
-{
-	int ret;
-	if (on == 0)
-		return power_down(sd);
-	else {
-		ret = power_up(sd);
-		if (!ret)
-			return gc2235_init(sd);
-	}
-	return ret;
-}
-
-/*
- * distance - calculate the distance
- * @res: resolution
- * @w: width
- * @h: height
- *
- * Get the gap between resolution and w/h.
- * res->width/height smaller than w/h wouldn't be considered.
- * Returns the value of gap or -1 if fail.
- */
-#define LARGEST_ALLOWED_RATIO_MISMATCH 800
-static int distance(struct gc2235_resolution *res, u32 w, u32 h)
-{
-	unsigned int w_ratio = ((res->width << 13)/w);
-	unsigned int h_ratio;
-	int match;
-
-	if (h == 0)
-		return -1;
-	h_ratio = ((res->height << 13) / h);
-	if (h_ratio == 0)
-		return -1;
-	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
-
-	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
-		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
-		return -1;
-
-	return w_ratio + h_ratio;
-}
-
-/* Return the nearest higher resolution index */
-static int nearest_resolution_index(int w, int h)
-{
-	int i;
-	int idx = -1;
-	int dist;
-	int min_dist = INT_MAX;
-	struct gc2235_resolution *tmp_res = NULL;
-
-	for (i = 0; i < N_RES; i++) {
-		tmp_res = &gc2235_res[i];
-		dist = distance(tmp_res, w, h);
-		if (dist == -1)
-			continue;
-		if (dist < min_dist) {
-			min_dist = dist;
-			idx = i;
-		}
-	}
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
 
-	return idx;
+	return ret;
 }
 
-static int get_resolution_index(int w, int h)
+static int get_resolution_index(struct v4l2_subdev *sd, int w, int h)
 {
 	int i;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
-	for (i = 0; i < N_RES; i++) {
-		if (w != gc2235_res[i].width)
+	for (i = 0; i < dev->entries_curr_table; i++) {
+		if (w != dev->curr_res_table[i].width)
 			continue;
-		if (h != gc2235_res[i].height)
+		if (h != dev->curr_res_table[i].height)
 			continue;
-
+		/* Found it */
 		return i;
 	}
-
 	return -1;
 }
 
 static int gc2235_try_mbus_fmt(struct v4l2_subdev *sd,
-			struct v4l2_mbus_framefmt *fmt)
+				struct v4l2_mbus_framefmt *fmt)
 {
-	int idx;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int idx = 0;
+	const struct gc2235_resolution *tmp_res = NULL;
 
-	if (!fmt)
-		return -EINVAL;
-	idx = nearest_resolution_index(fmt->width,
-					fmt->height);
-	if (idx == -1) {
-		/* return the largest resolution */
-		fmt->width = gc2235_res[N_RES - 1].width;
-		fmt->height = gc2235_res[N_RES - 1].height;
-	} else {
-		fmt->width = gc2235_res[idx].width;
-		fmt->height = gc2235_res[idx].height;
-	}
-	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	mutex_lock(&dev->input_lock);
 
-	return 0;
-}
+	if ((fmt->width > gc2235_max_res[0].res_max_width)
+		|| (fmt->height > gc2235_max_res[0].res_max_height)) {
+		fmt->width =  gc2235_max_res[0].res_max_width;
+		fmt->height = gc2235_max_res[0].res_max_height;
+	} else {
+		for (idx = 0; idx < dev->entries_curr_table; idx++) {
+				tmp_res = &dev->curr_res_table[idx];
+				if ((tmp_res[idx].width >= fmt->width) &&
+					(tmp_res[idx].height >= fmt->height))
+					break;
+		}
 
-static int startup(struct v4l2_subdev *sd)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 *  resolutions. If it fails, it means the requested
+		 *  resolution is higher than wecan support. Fallback
+		 *  to highest possible resolution in this case.
+		 */
+		if (idx == dev->entries_curr_table)
+			idx = dev->entries_curr_table - 1;
 
-	ret = gc2235_write_reg_array(client, gc2235_res[dev->fmt_idx].regs);
-	if (ret) {
-		dev_err(&client->dev, "gc2235 write register err.\n");
-		return ret;
+		fmt->width = dev->curr_res_table[idx].width;
+		fmt->height = dev->curr_res_table[idx].height;
 	}
 
-	return ret;
+	fmt->code = dev->format.code;
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
 }
 
 static int gc2235_s_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
+			      struct v4l2_mbus_framefmt *fmt)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct gc2235_reg *gc2235_def_reg;
 	struct camera_mipi_info *gc2235_info = NULL;
-	int ret = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 val;
 
 	gc2235_info = v4l2_get_subdev_hostdata(sd);
 	if (gc2235_info == NULL)
 		return -EINVAL;
 
-	mutex_lock(&dev->input_lock);
 	ret = gc2235_try_mbus_fmt(sd, fmt);
-	if (ret == -1) {
-		dev_err(&client->dev, "try fmt fail\n");
-		goto err;
-	}
+	if (ret)
+		return ret;
 
-	dev->fmt_idx = get_resolution_index(fmt->width,
-					      fmt->height);
-	if (dev->fmt_idx == -1) {
-		dev_err(&client->dev, "get resolution fail\n");
-		mutex_unlock(&dev->input_lock);
-		return -EINVAL;
-	}
+	mutex_lock(&dev->input_lock);
 
-	ret = startup(sd);
-	if (ret) {
-		dev_err(&client->dev, "gc2235 startup err\n");
-		goto err;
+	dev->fmt_idx = get_resolution_index(sd, fmt->width, fmt->height);
+	/* Sanity check */
+	if (unlikely(dev->fmt_idx == -1)) {
+		ret = -EINVAL;
+		goto out;
 	}
 
-	ret = gc2235_get_intg_factor(client, gc2235_info,
-					&gc2235_res[dev->fmt_idx]);
+	gc2235_def_reg = dev->curr_res_table[dev->fmt_idx].regs;
+
+	ret = gc2235_write_reg_array(client, gc2235_def_reg);
+	if (ret)
+		goto out;
+	dev->fps = dev->curr_res_table[dev->fmt_idx].fps;
+	dev->pixels_per_line =
+		dev->curr_res_table[dev->fmt_idx].pixels_per_line;
+	dev->lines_per_frame =
+		dev->curr_res_table[dev->fmt_idx].lines_per_frame;
+	ret = __gc2235_update_exposure_timing(client, dev->coarse_itg,
+		dev->pixels_per_line, dev->lines_per_frame);
+	if (ret)
+		goto out;
+
+	ret = gc2235_write_reg_array(client, gc2235_param_update);
+	if (ret)
+		goto out;
+
+	ret = gc2235_get_intg_factor(client, gc2235_info, gc2235_def_reg);
 	if (ret)
-		dev_err(&client->dev, "failed to get integration_factor\n");
+		goto out;
 
-err:
+	ret = gc2235_read_reg(client, GC2235_8BIT, GC2235_IMG_ORIENTATION, &val);
+	if (ret)
+		goto out;
+	val &= (GC2235_VFLIP_BIT|GC2235_HFLIP_BIT);
+	gc2235_info->raw_bayer_order = gc2235_bayer_order_mapping[val];
+	dev->format.code = gc2235_translate_bayer_order(
+		gc2235_info->raw_bayer_order);
+out:
 	mutex_unlock(&dev->input_lock);
 	return ret;
 }
+
 static int gc2235_g_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
+			      struct v4l2_mbus_framefmt *fmt)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
 	if (!fmt)
 		return -EINVAL;
 
-	fmt->width = gc2235_res[dev->fmt_idx].width;
-	fmt->height = gc2235_res[dev->fmt_idx].height;
-	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	fmt->width = dev->curr_res_table[dev->fmt_idx].width;
+	fmt->height = dev->curr_res_table[dev->fmt_idx].height;
+	fmt->code = dev->format.code;
 
 	return 0;
 }
 
-static int gc2235_detect(struct i2c_client *client)
+static int gc2235_detect(struct i2c_client *client, u16 *id)
 {
 	struct i2c_adapter *adapter = client->adapter;
-	u16 high, low;
-	int ret;
-	u16 id;
+	u8 id_l, id_h;
 
+	/* i2c check */
 	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
 		return -ENODEV;
 
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_SENSOR_ID_H, &high);
-	if (ret) {
-		dev_err(&client->dev, "sensor_id_high = 0x%x\n", high);
+	/* check sensor chip ID	 */
+	if (gc2235_read_reg(client, GCSENSOR_8BIT, GC2235_REG_SENSOR_ID_HIGH_BIT, &id_h)) {
+		v4l2_err(client, "sensor id = 0x%x\n", id_h);
 		return -ENODEV;
 	}
-	ret = gc2235_read_reg(client, GC2235_8BIT,
-					GC2235_SENSOR_ID_L, &low);
-	id = ((((u16) high) << 8) | (u16) low);
+	*id = (u16)(id_h << 0x8);
+	if (gc2235_read_reg(client, GCSENSOR_8BIT, GC2235_REG_SENSOR_ID_LOW_BIT, &id_l)) {
+		v4l2_err(client, "sensor_id = 0x%x\n", id_l);
+		return -ENODEV;
+	}
+	*id = *id + id_l;
 
-	if (id != GC2235_ID) {
-		dev_err(&client->dev, "sensor ID error, 0x%x\n", id);
+	if (*id == GC2235_ID)
+		goto found;
+	else {
+		v4l2_err(client, "no gc2235 sensor found\n");
 		return -ENODEV;
 	}
+found:
+	v4l2_info(client, "gc2235_detect: sensor_id = 0x%x\n", *id);
 
-	dev_dbg(&client->dev, "detect gc2235 success\n");
 	return 0;
 }
 
+/*
+ * gc2235 stream on/off
+ */
 static int gc2235_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
 	mutex_lock(&dev->input_lock);
-
-	if (enable)
-		ret = gc2235_write_reg_array(client, gc2235_stream_on);
-	else
-		ret = gc2235_write_reg_array(client, gc2235_stream_off);
-
+	if (enable) {
+		ret = gc2235_set_streaming(sd);
+		dev->streaming = 1;
+	} else {
+		ret = gc2235_set_suspend(sd);
+		dev->streaming = 0;
+		dev->fps_index = 0;
+	}
 	mutex_unlock(&dev->input_lock);
-	return ret;
+
+	return 0;
 }
 
-/* gc2235 enum frame size, frame intervals */
+/*
+ * gc2235 enum frame size, frame intervals
+ */
 static int gc2235_enum_framesizes(struct v4l2_subdev *sd,
-				  struct v4l2_frmsizeenum *fsize)
+				   struct v4l2_frmsizeenum *fsize)
 {
 	unsigned int index = fsize->index;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
-	if (index >= N_RES)
+	if (index >= dev->entries_curr_table)
 		return -EINVAL;
 
 	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
-	fsize->discrete.width = gc2235_res[index].width;
-	fsize->discrete.height = gc2235_res[index].height;
-	fsize->reserved[0] = gc2235_res[index].used;
+	fsize->discrete.width = dev->curr_res_table[index].width;
+	fsize->discrete.height = dev->curr_res_table[index].height;
+	fsize->reserved[0] = dev->curr_res_table[index].used;
 
 	return 0;
 }
 
 static int gc2235_enum_frameintervals(struct v4l2_subdev *sd,
-				      struct v4l2_frmivalenum *fival)
+				       struct v4l2_frmivalenum *fival)
 {
-	unsigned int index = fival->index;
+	int i;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	const struct gc2235_resolution *tmp_res = NULL;
 
-	if (index >= N_RES)
-		return -EINVAL;
+	for (i = 0; i < dev->entries_curr_table; i++) {
+			tmp_res = &dev->curr_res_table[i];
+			if ((tmp_res[i].width >= fival->width) &&
+			 (tmp_res[i].height >= fival->height))
+				break;
+	}
+
+	if (i == dev->entries_curr_table)
+		i--;
 
 	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
-	fival->width = gc2235_res[index].width;
-	fival->height = gc2235_res[index].height;
+	fival->width = dev->curr_res_table[i].width;
+	fival->height = dev->curr_res_table[i].height;
 	fival->discrete.numerator = 1;
-	fival->discrete.denominator = gc2235_res[index].fps;
-
-	return 0;
-}
-
-static int gc2235_enum_mbus_fmt(struct v4l2_subdev *sd,
-				unsigned int index,
-				enum v4l2_mbus_pixelcode *code)
-{
-	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	fival->discrete.denominator = dev->curr_res_table[i].fps;
 
 	return 0;
 }
 
 static int gc2235_s_config(struct v4l2_subdev *sd,
-			   int irq, void *platform_data)
+			    int irq, void *pdata)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	int ret = 0;
+	u16 sensor_id;
+	int ret;
 
-	if (platform_data == NULL)
+	if (NULL == pdata)
 		return -ENODEV;
 
 	dev->platform_data =
-		(struct camera_sensor_platform_data *)platform_data;
+		(struct camera_sensor_platform_data *)pdata;
 
 	mutex_lock(&dev->input_lock);
+
 	if (dev->platform_data->platform_init) {
 		ret = dev->platform_data->platform_init(client);
 		if (ret) {
-			dev_err(&client->dev, "platform init err\n");
-			goto platform_init_failed;
+			mutex_unlock(&dev->input_lock);
+			dev_err(&client->dev, "gc2235 platform init err\n");
+			return ret;
 		}
 	}
-	/* power off the module, then power on it in future
-	 * as first power on by board may not fulfill the
-	 * power on sequqence needed by the module
-	 */
-	ret = power_down(sd);
+
+	ret = __gc2235_s_power(sd, 1);
 	if (ret) {
-		dev_err(&client->dev, "gc2235 power-off err.\n");
-		goto fail_power_off;
+		v4l2_err(client, "gc2235 power-up err.\n");
+		goto  fail_csi_cfg;
 	}
 
-	ret = power_up(sd);
+	/* config & detect sensor */
+	ret = gc2235_detect(client, &sensor_id);
 	if (ret) {
-		dev_err(&client->dev, "gc2235 power-up err.\n");
-		goto fail_power_on;
+		v4l2_err(client, "gc2235_detect err s_config.\n");
+		goto fail_detect;
 	}
 
 	ret = dev->platform_data->csi_cfg(sd, 1);
 	if (ret)
 		goto fail_csi_cfg;
 
-	/* config & detect sensor */
-	ret = gc2235_detect(client);
-	if (ret) {
-		dev_err(&client->dev, "gc2235_detect err s_config.\n");
-		goto fail_csi_cfg;
-	}
-
-	/* turn off sensor, after probed */
-	ret = power_down(sd);
-	if (ret) {
-		dev_err(&client->dev, "gc2235 power-off err.\n");
-		goto fail_csi_cfg;
-	}
+	dev->sensor_id = sensor_id;
 
-	/* Register the atomisp platform data prior to the ISP module
-	 * load.  Ideally this would be stored as data on the
-	 * subdevices, but this API matches upstream better. */
-	/* FIXME: type and port need to come from ACPI/EFI config,
-	 * this is hard coded to FFRD8 */
-	ret = atomisp_register_i2c_module(sd, client, platform_data,
-					  getvar_int(&client->dev, "CamType",
-						     RAW_CAMERA),
-					  getvar_int(&client->dev, "CsiPort",
-						     ATOMISP_CAMERA_PORT_PRIMARY));
-	if (ret) {
-		dev_err(&client->dev,
-			"gc2235 atomisp_register_i2c_module failed.\n");
-		goto fail_csi_cfg;
-	}
+	/* power off sensor */
+	ret = __gc2235_s_power(sd, 0);
 	mutex_unlock(&dev->input_lock);
+	if (ret)
+		v4l2_err(client, "gc2235 power-down err.\n");
 
-	return 0;
+	return ret;
 
-fail_csi_cfg:
+fail_detect:
 	dev->platform_data->csi_cfg(sd, 0);
-fail_power_on:
-	power_down(sd);
-	dev_err(&client->dev, "sensor power-gating failed\n");
-fail_power_off:
-	if (dev->platform_data->platform_deinit)
-		dev->platform_data->platform_deinit();
-platform_init_failed:
+fail_csi_cfg:
+	__gc2235_s_power(sd, 0);
 	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
 	return ret;
 }
 
-static int gc2235_g_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-
-	if (!param)
-		return -EINVAL;
-
-	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_err(&client->dev,  "unsupported buffer type.\n");
-		return -EINVAL;
-	}
-
-	memset(param, 0, sizeof(*param));
-	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-
-	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
-		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
-		param->parm.capture.timeperframe.numerator = 1;
-		param->parm.capture.capturemode = dev->run_mode;
-		param->parm.capture.timeperframe.denominator =
-			gc2235_res[dev->fmt_idx].fps;
-	}
-	return 0;
-}
-
-static int gc2235_s_parm(struct v4l2_subdev *sd,
-			struct v4l2_streamparm *param)
-{
-	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	dev->run_mode = param->parm.capture.capturemode;
-
-	mutex_lock(&dev->input_lock);
-	switch (dev->run_mode) {
-	case CI_MODE_VIDEO:
-		gc2235_res = gc2235_res_video;
-		N_RES = N_RES_VIDEO;
-		break;
-	case CI_MODE_STILL_CAPTURE:
-		gc2235_res = gc2235_res_still;
-		N_RES = N_RES_STILL;
-		break;
-	default:
-		gc2235_res = gc2235_res_preview;
-		N_RES = N_RES_PREVIEW;
-	}
-	mutex_unlock(&dev->input_lock);
-	return 0;
-}
-
-static int gc2235_g_frame_interval(struct v4l2_subdev *sd,
-				   struct v4l2_subdev_frame_interval *interval)
+static int
+gc2235_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
 {
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
-
-	interval->interval.numerator = 1;
-	interval->interval.denominator = gc2235_res[dev->fmt_idx].fps;
-
-	return 0;
-}
-
-static int gc2235_enum_mbus_code(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_mbus_code_enum *code)
-{
 	if (code->index >= MAX_FMTS)
 		return -EINVAL;
-
-	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	code->code = dev->format.code;
 	return 0;
 }
 
-static int gc2235_enum_frame_size(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_frame_size_enum *fse)
+static int
+gc2235_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
 {
 	int index = fse->index;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
-	if (index >= N_RES)
+	if (index >= dev->entries_curr_table)
 		return -EINVAL;
 
-	fse->min_width = gc2235_res[index].width;
-	fse->min_height = gc2235_res[index].height;
-	fse->max_width = gc2235_res[index].width;
-	fse->max_height = gc2235_res[index].height;
+	fse->min_width = dev->curr_res_table[index].width;
+	fse->min_height = dev->curr_res_table[index].height;
+	fse->max_width = dev->curr_res_table[index].width;
+	fse->max_height = dev->curr_res_table[index].height;
 
 	return 0;
-
 }
 
 static struct v4l2_mbus_framefmt *
 __gc2235_get_pad_format(struct gc2235_device *sensor,
-			struct v4l2_subdev_fh *fh, unsigned int pad,
-			enum v4l2_subdev_format_whence which)
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
-
-	if (pad != 0) {
-		dev_err(&client->dev,
-			"__gc2235_get_pad_format err. pad %x\n", pad);
-		return NULL;
-	}
-
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
 		return v4l2_subdev_get_try_format(fh, pad);
@@ -1183,28 +1336,96 @@ __gc2235_get_pad_format(struct gc2235_device *sensor,
 	}
 }
 
-static int gc2235_get_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
+static int
+gc2235_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
 {
-	struct gc2235_device *snr = to_gc2235_sensor(sd);
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
 	struct v4l2_mbus_framefmt *format =
-			__gc2235_get_pad_format(snr, fh, fmt->pad, fmt->which);
-	if (!format)
-		return -EINVAL;
+			__gc2235_get_pad_format(dev, fh, fmt->pad, fmt->which);
 
 	fmt->format = *format;
+
 	return 0;
 }
 
-static int gc2235_set_pad_format(struct v4l2_subdev *sd,
-				struct v4l2_subdev_fh *fh,
-				struct v4l2_subdev_format *fmt)
+static int
+gc2235_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
 {
-	struct gc2235_device *snr = to_gc2235_sensor(sd);
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
 	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		snr->format = fmt->format;
+		dev->format = fmt->format;
+
+	return 0;
+}
+
+static int
+gc2235_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		dev->curr_res_table = dev->mode_tables->res_video;
+		dev->entries_curr_table = dev->mode_tables->n_res_video;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		dev->curr_res_table = dev->mode_tables->res_still;
+		dev->entries_curr_table = dev->mode_tables->n_res_still;
+		break;
+	default:
+		dev->curr_res_table = dev->mode_tables->res_preview;
+		dev->entries_curr_table = dev->mode_tables->n_res_preview;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+int
+gc2235_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 lines_per_frame;
+	/*
+	 * if no specific information to calculate the fps,
+	 * just used the value in sensor settings
+	 */
+
+	if (!dev->pixels_per_line || !dev->lines_per_frame) {
+		interval->interval.numerator = 1;
+		interval->interval.denominator = dev->fps;
+		return 0;
+	}
+
+	/*
+	 * DS: if coarse_integration_time is set larger than
+	 * lines_per_frame the frame_size will be expanded to
+	 * coarse_integration_time+1
+	 */
+	if (dev->coarse_itg > dev->lines_per_frame) {
+		if ((dev->coarse_itg + 4) < dev->coarse_itg) {
+			/*
+			 * we can not add 4 according to ds, as this will
+			 * cause over flow
+			 */
+			v4l2_warn(client, "%s: abnormal coarse_itg:0x%x\n",
+				  __func__, dev->coarse_itg);
+			lines_per_frame = dev->coarse_itg;
+		} else {
+			lines_per_frame = dev->coarse_itg + 4;
+		}
+	} else {
+		lines_per_frame = dev->lines_per_frame;
+	}
+	interval->interval.numerator = dev->pixels_per_line *
+					lines_per_frame;
+	interval->interval.denominator = dev->vt_pix_clk_freq_mhz;
 
 	return 0;
 }
@@ -1214,7 +1435,7 @@ static int gc2235_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
 
 	mutex_lock(&dev->input_lock);
-	*frames = gc2235_res[dev->fmt_idx].skip_frames;
+	*frames = dev->curr_res_table[dev->fmt_idx].skip_frames;
 	mutex_unlock(&dev->input_lock);
 
 	return 0;
@@ -1226,22 +1447,24 @@ static const struct v4l2_subdev_sensor_ops gc2235_sensor_ops = {
 
 static const struct v4l2_subdev_video_ops gc2235_video_ops = {
 	.s_stream = gc2235_s_stream,
-	.g_parm = gc2235_g_parm,
-	.s_parm = gc2235_s_parm,
 	.enum_framesizes = gc2235_enum_framesizes,
 	.enum_frameintervals = gc2235_enum_frameintervals,
-	.enum_mbus_fmt = gc2235_enum_mbus_fmt,
 	.try_mbus_fmt = gc2235_try_mbus_fmt,
 	.g_mbus_fmt = gc2235_g_mbus_fmt,
 	.s_mbus_fmt = gc2235_s_mbus_fmt,
-	.g_frame_interval = gc2235_g_frame_interval,
+	.s_parm = gc2235_s_parm,
 };
 
 static const struct v4l2_subdev_core_ops gc2235_core_ops = {
-	.s_power = gc2235_s_power,
+	.g_chip_ident = gc2235_g_chip_ident,
 	.queryctrl = gc2235_queryctrl,
 	.g_ctrl = gc2235_g_ctrl,
 	.s_ctrl = gc2235_s_ctrl,
+#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
+	.s_power = gc2235_s_power_always_on,
+#else
+	.s_power = gc2235_s_power,
+#endif
 	.ioctl = gc2235_ioctl,
 };
 
@@ -1263,13 +1486,10 @@ static int gc2235_remove(struct i2c_client *client)
 {
 	struct v4l2_subdev *sd = i2c_get_clientdata(client);
 	struct gc2235_device *dev = to_gc2235_sensor(sd);
-	dev_dbg(&client->dev, "gc2235_remove...\n");
 
 	if (dev->platform_data->platform_deinit)
 		dev->platform_data->platform_deinit();
 
-	dev->platform_data->csi_cfg(sd, 0);
-
 	v4l2_device_unregister_subdev(sd);
 	media_entity_cleanup(&dev->sd.entity);
 	kfree(dev);
@@ -1277,42 +1497,65 @@ static int gc2235_remove(struct i2c_client *client)
 	return 0;
 }
 
+static int __update_gc2235_device_settings(struct gc2235_device *dev, u16 sensor_id)
+{
+	switch (sensor_id) {
+	case GC2235_ID:
+		dev->mode_tables = &gc2235_sets[0];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 static int gc2235_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
+			 const struct i2c_device_id *id)
 {
 	struct gc2235_device *dev;
+	struct camera_mipi_info *gc2235_info = NULL;
 	int ret;
 
+	/* allocate sensor device & init sub device */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev) {
-		dev_err(&client->dev, "out of memory\n");
+		v4l2_err(client, "%s: out of memory\n", __func__);
 		return -ENOMEM;
 	}
-
 	mutex_init(&dev->input_lock);
 
 	dev->fmt_idx = 0;
+	dev->sensor_id = GC2235_ID_DEFAULT;
 	v4l2_i2c_subdev_init(&(dev->sd), client, &gc2235_ops);
 
+	dev->once_launched = 0;
+
 	if (client->dev.platform_data) {
 		ret = gc2235_s_config(&dev->sd, client->irq,
 				       client->dev.platform_data);
 		if (ret)
 			goto out_free;
-	} else if (ACPI_COMPANION(&client->dev)) {
-		/*
-		 * If no SFI firmware, grab the platform struct
-		 * directly and configure via ACPI/EFIvars instead
-		 */
-		ret = gc2235_s_config(&dev->sd, client->irq,
-				      gmin_camera_platform_data());
-		if (ret)
-			goto out_free;
 	}
+	gc2235_info = v4l2_get_subdev_hostdata(&dev->sd);
+
+	/*
+	 * sd->name is updated with sensor driver name by the v4l2.
+	 * change it to sensor name in this case.
+	 */
+	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s%x %d-%04x",
+		GC2235_SUBDEV_PREFIX, dev->sensor_id,
+		i2c_adapter_id(client->adapter), client->addr);
+
+	/* Resolution settings depend on sensor type and platform */
+	ret = __update_gc2235_device_settings(dev, dev->sensor_id);
+	if (ret)
+		goto out_free;
 
 	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
-	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
 	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
 
 	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
@@ -1326,39 +1569,82 @@ out_free:
 	return ret;
 }
 
+#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
+static int gc2235_suspend(struct device *dev)
+{
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2235_device *gc_dev = to_gc2235_sensor(sd);
+	int ret = 0;
+
+	//printk("%s() in\n", __func__);
+
+	if (gc_dev->once_launched) {
+		ret = __gc2235_s_power(sd, 0);
+		if (ret) {
+			v4l2_err(client, "gc2235 power-down err.\n");
+		}
+	}
+
+	return 0;
+}
+
+static int gc2235_resume(struct device *dev)
+{
+	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2235_device *gc_dev = to_gc2235_sensor(sd);
+	int ret = 0;
+
+	//printk("%s() in\n", __func__);
+
+	if (gc_dev->once_launched) {
+		ret = __gc2235_s_power(sd, 1);
+		if (ret) {
+			v4l2_err(client, "gc2235 power-up err.\n");
+		}
+	}
+
+	return 0;
+}
+
+SIMPLE_DEV_PM_OPS(gc2235_pm_ops, gc2235_suspend, gc2235_resume);
+#endif
 
-static struct acpi_device_id gc2235_acpi_match[] = {
-	{"INT33F8"},
-	{},
+static const struct i2c_device_id gc2235_ids[] = {
+	{GC2235_NAME, GC2235_ID},
+	{}
 };
-MODULE_DEVICE_TABLE(acpi, gc2235_acpi_match);
 
-MODULE_DEVICE_TABLE(i2c, gc2235_id);
+MODULE_DEVICE_TABLE(i2c, gc2235_ids);
+
 static struct i2c_driver gc2235_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
-		.name = GC2235_NAME,
-		.acpi_match_table = ACPI_PTR(gc2235_acpi_match),
+		.name = GC2235_DRIVER,
+#ifdef POWER_ALWAYS_ON_BEFORE_SUSPEND
+		.pm = &gc2235_pm_ops,
+#endif
 	},
 	.probe = gc2235_probe,
 	.remove = gc2235_remove,
-	.id_table = gc2235_id,
+	.id_table = gc2235_ids,
 };
 
-static int init_gc2235(void)
+static __init int init_gc2235(void)
 {
 	return i2c_add_driver(&gc2235_driver);
 }
 
-static void exit_gc2235(void)
+static __exit void exit_gc2235(void)
 {
-
 	i2c_del_driver(&gc2235_driver);
 }
 
 module_init(init_gc2235);
 module_exit(exit_gc2235);
 
-MODULE_AUTHOR("Shuguang Gong <Shuguang.Gong@intel.com>");
-MODULE_DESCRIPTION("A low-level driver for GC2235 sensors");
+MODULE_DESCRIPTION("A low-level driver for  sensors");
+MODULE_AUTHOR("Kun Jiang <kunx.jiang@intel.com>");
 MODULE_LICENSE("GPL");
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
index 3e7ee62..594663e 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
@@ -1,7 +1,7 @@
 /*
- * Support for GalaxyCore GC2235 2M camera sensor.
+ * Support for Sony GC2235 camera sensor.
  *
- * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
@@ -21,44 +21,133 @@
 
 #ifndef __GC2235_H__
 #define __GC2235_H__
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
 #include <linux/kernel.h>
+#include <linux/spinlock.h>
 #include <linux/types.h>
-#include <linux/i2c.h>
-#include <linux/delay.h>
 #include <linux/videodev2.h>
-#include <linux/spinlock.h>
-#include <media/v4l2-subdev.h>
-#include <media/v4l2-device.h>
-#include <media/v4l2-chip-ident.h>
 #include <linux/v4l2-mediabus.h>
 #include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
 
-#include <linux/atomisp_platform.h>
+#define I2C_MSG_LENGTH		0x2
+
+#define GC2235_MCLK		192
+
+/* TODO - This should be added into include/linux/videodev2.h */
+#ifndef V4L2_IDENT_GC
+#define V4L2_IDENT_GC	2235
+#endif
+
+/* #defines for register writes and register array processing */
+#define GCSENSOR_8BIT		1
+#define GCSENSOR_16BIT		2
+#define GCSENSOR_32BIT		4
+
+/*
+ * gc2235 System control registers
+ */
+#define GC2235_MASK_5BIT	0x1F
+#define GC2235_MASK_4BIT	0xF
+#define GC2235_MASK_2BIT	0x3
+#define GC2235_INTG_BUF_COUNT		2
 
-#define GC2235_NAME		"gc2235"
+#define GC2235_FINE_INTG_TIME		0x0
+
+#define GC2235_ID_DEFAULT 0
+
+#define GC2235_LINES_PER_FRAME		0x0d
+#define GC2235_PIXELS_PER_LINE		0x0f
+
+#define GC2235_HORIZONTAL_START_H 0x0b
+#define GC2235_HORIZONTAL_START_L 0x0c
+
+#define GC2235_VERTICAL_START_H 0x09
+#define GC2235_VERTICAL_START_L 0x0a
+#define REG_SH_DELAY_H 0x11
+#define REG_SH_DELAY_L 0x12
+
+#define REG_HORI_BLANKING_H 0x05
+#define REG_HORI_BLANKING_L 0x06
+
+#define REG_VERT_DUMMY_H 0x07
+#define REG_VERT_DUMMY_L 0x08
+
+#define GC2235_HORIZONTAL_OUTPUT_SIZE_H 0x0f
+#define GC2235_HORIZONTAL_OUTPUT_SIZE_L 0x10
+#define GC2235_VERTICAL_OUTPUT_SIZE_H 0x0d
+#define GC2235_VERTICAL_OUTPUT_SIZE_L 0x0e
+
+#define GC2235_IMG_ORIENTATION			0x17
+#define GC2235_VFLIP_BIT			2
+#define GC2235_HFLIP_BIT			1
+#define GC2235_GLOBAL_GAIN			0xb0
+
+#define GC2235_DGC_LEN		10
+#define GC2235_MAX_EXPOSURE_SUPPORTED 8191
+#define GC2235_MAX_GLOBAL_GAIN_SUPPORTED 0xffff
+#define GC2235_MAX_DIGITAL_GAIN_SUPPORTED 0xffff
+#define GC2235_REG_EXPO_COARSE                 0x03
 
 /* Defines for register writes and register array processing */
-#define I2C_MSG_LENGTH		0x2
+#define GC2235_BYTE_MAX	32 /* change to 32 as needed by otpdata */
+#define GC2235_SHORT_MAX	16
 #define I2C_RETRY_COUNT		5
+#define GC2235_TOK_MASK	0xfff0
 
-#define GC2235_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define GC2235_FOCAL_LENGTH_NUM	208	/*2.08mm*/
 #define GC2235_FOCAL_LENGTH_DEM	100
-#define GC2235_F_NUMBER_DEFAULT_NUM	26
+#define GC2235_F_NUMBER_DEFAULT_NUM	24
 #define GC2235_F_NUMBER_DEM	10
+#define GC2235_WAIT_STAT_TIMEOUT	100
+#define GC2235_FLICKER_MODE_50HZ	1
+#define GC2235_FLICKER_MODE_60HZ	2
+
+/* Defines for OTP Data Registers */
+#define GC2235_OTP_START_ADDR		0x3B04
+#define GC2235_OTP_DATA_SIZE		1280
+#define GC2235_OTP_PAGE_SIZE		64
+#define GC2235_OTP_READY_REG		0x3B01
+#define GC2235_OTP_PAGE_REG		0x3B02
+#define GC2235_OTP_MODE_REG		0x3B00
+#define GC2235_OTP_PAGE_MAX		20
+#define GC2235_OTP_READY_REG_DONE		1
+#define GC2235_OTP_READ_ONETIME		32
+#define GC2235_OTP_MODE_READ		1
+
+#define MAX_FMTS 1
+
+#define GC2235_SUBDEV_PREFIX "gc"
+#define GC2235_DRIVER	"gc22351x5"
+#define GC2235_NAME	"gc2235"
+#define GC2235_ID	0x2235
 
-#define MAX_FMTS		1
+#define GC2235_REG_SENSOR_ID_HIGH_BIT	0xf0
+#define GC2235_REG_SENSOR_ID_LOW_BIT	0xf1
+#define GC2235_SENSOR_ID_HIGH_BIT	0x22
+#define GC2235_SENSOR_ID_LOW_BIT	0x35
 
+#define GC2235_RES_WIDTH_MAX	1616
+#define GC2235_RES_HEIGHT_MAX	1216
+
+#define GC2235_BIN_FACTOR_MAX			4
+#define GC2235_INTEGRATION_TIME_MARGIN	4
 /*
  * focal length bits definition:
  * bits 31-16: numerator, bits 15-0: denominator
  */
-#define GC2235_FOCAL_LENGTH_DEFAULT 0x1160064
+#define GC2235_FOCAL_LENGTH_DEFAULT 0x1710064
 
 /*
  * current f-number bits definition:
  * bits 31-16: numerator, bits 15-0: denominator
  */
-#define GC2235_F_NUMBER_DEFAULT 0x1a000a
+#define GC2235_F_NUMBER_DEFAULT 0x16000a
 
 /*
  * f-number range bits definition:
@@ -67,490 +156,377 @@
  * bits 15-8: min f-number numerator
  * bits 7-0: min f-number denominator
  */
-#define GC2235_F_NUMBER_RANGE 0x1a0a1a0a
-#define GC2235_ID	0x2235
-
-#define GC2235_FINE_INTG_TIME_MIN 0
-#define GC2235_FINE_INTG_TIME_MAX_MARGIN 0
-#define GC2235_COARSE_INTG_TIME_MIN 1
-#define GC2235_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
-
-/*
- * GC2235 System control registers
- */
-/*
- * GC2235 System control registers
- */
-#define GC2235_SENSOR_ID_H		0xF0
-#define GC2235_SENSOR_ID_L		0xF1
-#define GC2235_RESET_RELATED		0xFE
-#define GC2235_SW_RESET			0x8
-#define GC2235_MIPI_RESET		0x3
-#define GC2235_RESET_BIT		0x4
-#define GC2235_REGISTER_PAGE_0		0x0
-#define GC2235_REGISTER_PAGE_3		0x3
-
-#define GC2235_V_CROP_START_H		0x91
-#define GC2235_V_CROP_START_L		0x92
-#define GC2235_H_CROP_START_H		0x93
-#define GC2235_H_CROP_START_L		0x94
-#define GC2235_V_OUTSIZE_H		0x95
-#define GC2235_V_OUTSIZE_L		0x96
-#define GC2235_H_OUTSIZE_H 		0x97
-#define GC2235_H_OUTSIZE_L 		0x98
-
-#define GC2235_HB_H			0x5
-#define GC2235_HB_L			0x6
-#define GC2235_VB_H			0x7
-#define GC2235_VB_L			0x8
-#define GC2235_SH_DELAY_H		0x11
-#define GC2235_SH_DELAY_L		0x12
-
-#define GC2235_CSI2_MODE		0x10
-
-#define GC2235_EXPOSURE_H		0x3
-#define GC2235_EXPOSURE_L		0x4
-#define GC2235_GLOBAL_GAIN		0xB0
-#define GC2235_PRE_GAIN			0xB1
-#define GC2235_AWB_R_GAIN		0xB3
-#define GC2235_AWB_G_GAIN		0xB4
-#define GC2235_AWB_B_GAIN		0xB5
-
-#define GC2235_START_STREAMING		0x91
-#define GC2235_STOP_STREAMING		0x0
-
-struct regval_list {
-	u16 reg_num;
-	u8 value;
-};
-
-struct gc2235_resolution {
-	u8 *desc;
-	const struct gc2235_reg *regs;
-	int res;
-	int width;
-	int height;
-	int fps;
-	int pix_clk_freq;
-	u32 skip_frames;
-	u16 pixels_per_line;
-	u16 lines_per_frame;
-	u8 bin_factor_x;
-	u8 bin_factor_y;
-	u8 bin_mode;
-	bool used;
-};
+#define GC2235_F_NUMBER_RANGE 0x160a160a
 
-struct gc2235_format {
-	u8 *desc;
-	u32 pixelformat;
-	struct gc2235_reg *regs;
+struct max_res {
+	int res_max_width;
+	int res_max_height;
 };
 
-struct gc2235_control {
-	struct v4l2_queryctrl qc;
-	int (*query)(struct v4l2_subdev *sd, s32 *value);
-	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+struct max_res gc2235_max_res[] = {
+	[0] = {
+		.res_max_width = GC2235_RES_WIDTH_MAX,
+		.res_max_height = GC2235_RES_HEIGHT_MAX,
+	},
 };
 
-/*
- * gc2235 device structure.
- */
-struct gc2235_device {
-	struct v4l2_subdev sd;
-	struct media_pad pad;
-	struct v4l2_mbus_framefmt format;
-	struct mutex input_lock;
-
-	struct camera_sensor_platform_data *platform_data;
-	int vt_pix_clk_freq_mhz;
-	int fmt_idx;
-	int run_mode;
-	u8 res;
-	u8 type;
-};
+#define MAX_FPS_OPTIONS_SUPPORTED       3
 
 enum gc2235_tok_type {
-	GC2235_8BIT  = 0x0001,
-	GC2235_16BIT = 0x0002,
-	GC2235_32BIT = 0x0004,
-	GC2235_TOK_TERM   = 0xf000,	/* terminating token for reg list */
-	GC2235_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
-	GC2235_TOK_MASK = 0xfff0
+	 GC2235_8BIT  = 0x0001,
+	 GC2235_16BIT = 0x0002,
+	 GC2235_TOK_TERM   = 0xf000,        /* terminating token for reg list */
+	 GC2235_TOK_DELAY  = 0xfe00 /* delay token for reg list */
 };
 
+#define GROUPED_PARAMETER_HOLD_ENABLE  {GC2235_8BIT, 0x0104, 0x1}
+#define GROUPED_PARAMETER_HOLD_DISABLE  {GC2235_8BIT, 0x0104, 0x0}
+
 /**
  * struct gc2235_reg - MI sensor  register format
  * @type: type of the register
- * @reg: 8-bit offset to register
+ * @reg: 16-bit offset to register
  * @val: 8/16/32-bit register value
  *
  * Define a structure for sensor register initialization values
  */
 struct gc2235_reg {
-	enum gc2235_tok_type type;
-	u8 reg;
-	u32 val;	/* @set value for read/mod/write, @mask */
+	 enum gc2235_tok_type type;
+	 u16 sreg;
+	 u32 val;        /* @set value for read/mod/write, @mask */
 };
 
-#define to_gc2235_sensor(x) container_of(x, struct gc2235_device, sd)
-
-#define GC2235_MAX_WRITE_BUF_SIZE	30
-
-struct gc2235_write_buffer {
-	u8 addr;
-	u8 data[GC2235_MAX_WRITE_BUF_SIZE];
+struct gc2235_fps_setting {
+	 int fps;
+	 unsigned short pixels_per_line;
+	 unsigned short lines_per_frame;
 };
 
-struct gc2235_write_ctrl {
-	int index;
-	struct gc2235_write_buffer buffer;
+struct gc2235_resolution {
+	 u8 *desc;
+	 const struct gc2235_reg *regs;
+	 int res;
+	 int width;
+	 int height;
+	 int fps;
+	 unsigned short pixels_per_line;
+	 unsigned short lines_per_frame;
+	 unsigned short skip_frames;
+	 u8 bin_factor_x;
+	 u8 bin_factor_y;
+	 bool used;
+		u8 bin_mode;
 };
 
-static const struct i2c_device_id gc2235_id[] = {
-	{GC2235_NAME, 0},
-	{}
-};
 
-static struct gc2235_reg const gc2235_stream_on[] = {
-	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
-	{ GC2235_8BIT, 0x10, 0x91}, /* start mipi */
-	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
-	{ GC2235_TOK_TERM, 0, 0 }
-};
 
-static struct gc2235_reg const gc2235_stream_off[] = {
-	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
-	{ GC2235_8BIT, 0x10, 0x81}, /* stop mipi */
-	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
-	{ GC2235_TOK_TERM, 0, 0 }
+struct gc2235_settings {
+	struct gc2235_reg const *init_settings;
+	struct gc2235_resolution *res_preview;
+	struct gc2235_resolution *res_still;
+	struct gc2235_resolution *res_video;
+	int n_res_preview;
+	int n_res_still;
+	int n_res_video;
 };
 
-static struct gc2235_reg const gc2235_init_settings[] = {
-	/* Sysytem */
-	{ GC2235_8BIT, 0xfe, 0x80 },
-	{ GC2235_8BIT, 0xfe, 0x80 },
-	{ GC2235_8BIT, 0xfe, 0x80 },
-	{ GC2235_8BIT, 0xf2, 0x00 },
-	{ GC2235_8BIT, 0xf6, 0x00 },
-	{ GC2235_8BIT, 0xfc, 0x06 },
-	{ GC2235_8BIT, 0xf7, 0x15 },
-	{ GC2235_8BIT, 0xf8, 0x85 },
-	{ GC2235_8BIT, 0xf9, 0xfe },
-	{ GC2235_8BIT, 0xfa, 0x00 },
-	{ GC2235_8BIT, 0xfe, 0x00 },
-	/* Analog & cisctl */
-	{ GC2235_8BIT, 0x03, 0x04 },
-	{ GC2235_8BIT, 0x04, 0x9e },
-	{ GC2235_8BIT, 0x05, 0x00 },
-	{ GC2235_8BIT, 0x06, 0xf4 },
-	{ GC2235_8BIT, 0x07, 0x00 },
-	{ GC2235_8BIT, 0x08, 0x88 },
-	{ GC2235_8BIT, 0x0a, 0x00 }, /* row start */
-	{ GC2235_8BIT, 0x0c, 0x00 }, /* col start */
-	{ GC2235_8BIT, 0x0d, 0x04 }, /* win height 1232 */
-	{ GC2235_8BIT, 0x0e, 0xd0 },
-	{ GC2235_8BIT, 0x0f, 0x06 }, /* win width: 1616 */
-	{ GC2235_8BIT, 0x10, 0x60 },
-	{ GC2235_8BIT, 0x17, 0x15 }, /* mirror flip */
-	{ GC2235_8BIT, 0x18, 0x12 },
-	{ GC2235_8BIT, 0x19, 0x06 },
-	{ GC2235_8BIT, 0x1a, 0x01 },
-	{ GC2235_8BIT, 0x1b, 0x4d },
-	{ GC2235_8BIT, 0x1e, 0x88 },
-	{ GC2235_8BIT, 0x1f, 0x48 },
-	{ GC2235_8BIT, 0x20, 0x03 },
-	{ GC2235_8BIT, 0x21, 0x7f },
-	{ GC2235_8BIT, 0x22, 0x83 },
-	{ GC2235_8BIT, 0x23, 0x42 },
-	{ GC2235_8BIT, 0x24, 0x16 },
-	{ GC2235_8BIT, 0x26, 0x01 }, /*analog gain*/
-	{ GC2235_8BIT, 0x27, 0x30 },
-	{ GC2235_8BIT, 0x3f, 0x00 }, /* PRC */
-	/* blk */
-	{ GC2235_8BIT, 0x40, 0x03 },
-	{ GC2235_8BIT, 0x41, 0x00 },
-	{ GC2235_8BIT, 0x43, 0x20 },
-	{ GC2235_8BIT, 0x5e, 0x00 },
-	{ GC2235_8BIT, 0x5f, 0x00 },
-	{ GC2235_8BIT, 0x60, 0x00 },
-	{ GC2235_8BIT, 0x61, 0x00 },
-	{ GC2235_8BIT, 0x62, 0x00 },
-	{ GC2235_8BIT, 0x63, 0x00 },
-	{ GC2235_8BIT, 0x64, 0x00 },
-	{ GC2235_8BIT, 0x65, 0x00 },
-	{ GC2235_8BIT, 0x66, 0x20 },
-	{ GC2235_8BIT, 0x67, 0x20 },
-	{ GC2235_8BIT, 0x68, 0x20 },
-	{ GC2235_8BIT, 0x69, 0x20 },
-	/* Gain */
-	{ GC2235_8BIT, 0xb2, 0x00 },
-	{ GC2235_8BIT, 0xb3, 0x40 },
-	{ GC2235_8BIT, 0xb4, 0x40 },
-	{ GC2235_8BIT, 0xb5, 0x40 },
-	/* Dark sun */
-	{ GC2235_8BIT, 0xbc, 0x00 },
-
-	{ GC2235_8BIT, 0xfe, 0x03 },
-	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
-	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
-	{ GC2235_TOK_TERM, 0, 0 }
-};
-/*
- * Register settings for various resolution
- */
-static struct gc2235_reg const gc2235_1616_916_30fps[] = {
-	{ GC2235_8BIT, 0x8b, 0xa0 },
-	{ GC2235_8BIT, 0x8c, 0x02 },
-	{ GC2235_8BIT, 0x90, 0x01 },
-	{ GC2235_8BIT, 0x92, 0x96 },
-	{ GC2235_8BIT, 0x94, 0x00 },
-	{ GC2235_8BIT, 0x95, 0x03 }, /* crop win height 900 */
-	{ GC2235_8BIT, 0x96, 0x94 },
-	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1600 */
-	{ GC2235_8BIT, 0x98, 0x50 },
-	/* mimi init */
-	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
-	{ GC2235_8BIT, 0x01, 0x07 },
-	{ GC2235_8BIT, 0x02, 0x11 },
-	{ GC2235_8BIT, 0x03, 0x11 },
-	{ GC2235_8BIT, 0x06, 0x80 },
-	{ GC2235_8BIT, 0x11, 0x2b },
-	/* set mipi buffer */
-	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
-	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
-
-	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
-	{ GC2235_8BIT, 0x04, 0x20 },
-	{ GC2235_8BIT, 0x05, 0x00 },
-	{ GC2235_8BIT, 0x17, 0x01 },
-	{ GC2235_8BIT, 0x21, 0x01 },
-	{ GC2235_8BIT, 0x22, 0x02 },
-	{ GC2235_8BIT, 0x23, 0x01 },
-	{ GC2235_8BIT, 0x29, 0x02 },
-	{ GC2235_8BIT, 0x2a, 0x01 },
-	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
-	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
-	{ GC2235_TOK_TERM, 0, 0 }
+static struct gc2235_reg const gc2235_720p_30fps[] = {
+	{GC2235_8BIT, 0x90, 0x01},
+	{GC2235_8BIT, 0x92, 0xf0},
+	{GC2235_8BIT, 0x94, 0xa0},
+	{GC2235_8BIT, 0x95, 0x02},
+	{GC2235_8BIT, 0x96, 0xe0},
+	{GC2235_8BIT, 0x97, 0x05},
+	{GC2235_8BIT, 0x98, 0x10},
+
+	{GC2235_8BIT, 0xfe, 0x03},
+	{GC2235_8BIT, 0x12, 0x54},
+	{GC2235_8BIT, 0x13, 0x06},
+	{GC2235_8BIT, 0x04, 0x20},
+	{GC2235_8BIT, 0x05, 0x00},
+	{GC2235_8BIT, 0xfe, 0x00},
+	{GC2235_TOK_TERM, 0, 0},
 };
 
-static struct gc2235_reg const gc2235_1616_1082_30fps[] = {
-	{ GC2235_8BIT, 0x8b, 0xa0 },
-	{ GC2235_8BIT, 0x8c, 0x02 },
-	{ GC2235_8BIT, 0x90, 0x01 },
-	{ GC2235_8BIT, 0x92, 0x4a },
-	{ GC2235_8BIT, 0x94, 0x00 },
-	{ GC2235_8BIT, 0x95, 0x04 }, /* crop win height 1082 */
-	{ GC2235_8BIT, 0x96, 0x3a },
-	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1616 */
-	{ GC2235_8BIT, 0x98, 0x50 },
-	/* mimi init */
-	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
-	{ GC2235_8BIT, 0x01, 0x07 },
-	{ GC2235_8BIT, 0x02, 0x11 },
-	{ GC2235_8BIT, 0x03, 0x11 },
-	{ GC2235_8BIT, 0x06, 0x80 },
-	{ GC2235_8BIT, 0x11, 0x2b },
-	/* set mipi buffer */
-	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
-	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
-
-	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
-	{ GC2235_8BIT, 0x04, 0x20 },
-	{ GC2235_8BIT, 0x05, 0x00 },
-	{ GC2235_8BIT, 0x17, 0x01 },
-	{ GC2235_8BIT, 0x21, 0x01 },
-	{ GC2235_8BIT, 0x22, 0x02 },
-	{ GC2235_8BIT, 0x23, 0x01 },
-	{ GC2235_8BIT, 0x29, 0x02 },
-	{ GC2235_8BIT, 0x2a, 0x01 },
-	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
-	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
-	{ GC2235_TOK_TERM, 0, 0 }
+static struct gc2235_reg const gc2235_1600x1200_30fps[] = {
+	{GC2235_8BIT, 0xfe, 0x00},
+	{GC2235_8BIT, 0x0a, 0x02},
+	{GC2235_8BIT, 0x0c, 0x00},
+	{GC2235_8BIT, 0x0d, 0x04},
+	{GC2235_8BIT, 0x0e, 0xd0},
+	{GC2235_8BIT, 0x0f, 0x06},
+	{GC2235_8BIT, 0x10, 0x58},
+
+	{GC2235_8BIT, 0x90, 0x01},
+	{GC2235_8BIT, 0x92, 0x02},
+	{GC2235_8BIT, 0x94, 0x00},
+	{GC2235_8BIT, 0x95, 0x04},
+	{GC2235_8BIT, 0x96, 0xc0},
+	{GC2235_8BIT, 0x97, 0x06},
+	{GC2235_8BIT, 0x98, 0x50},
+
+	{GC2235_8BIT, 0xfe, 0x03},
+	{GC2235_8BIT, 0x12, 0xe4},
+	{GC2235_8BIT, 0x13, 0x07},
+	{GC2235_8BIT, 0x04, 0x20},
+	{GC2235_8BIT, 0x05, 0x00},
+	{GC2235_8BIT, 0xfe, 0x00},
+	{GC2235_TOK_TERM, 0, 0},
 };
 
-static struct gc2235_reg const gc2235_1616_1216_30fps[] = {
-	{ GC2235_8BIT, 0x8b, 0xa0 },
-	{ GC2235_8BIT, 0x8c, 0x02 },
-	{ GC2235_8BIT, 0x90, 0x01 },
-	{ GC2235_8BIT, 0x92, 0x02 },
-	{ GC2235_8BIT, 0x94, 0x00 },
-	{ GC2235_8BIT, 0x95, 0x04 }, /* crop win height 1216 */
-	{ GC2235_8BIT, 0x96, 0xc0 },
-	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1616 */
-	{ GC2235_8BIT, 0x98, 0x50 },
-	/* mimi init */
-	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
-	{ GC2235_8BIT, 0x01, 0x07 },
-	{ GC2235_8BIT, 0x02, 0x11 },
-	{ GC2235_8BIT, 0x03, 0x11 },
-	{ GC2235_8BIT, 0x06, 0x80 },
-	{ GC2235_8BIT, 0x11, 0x2b },
-	/* set mipi buffer */
-	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
-	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
-
-	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
-	{ GC2235_8BIT, 0x04, 0x20 },
-	{ GC2235_8BIT, 0x05, 0x00 },
-	{ GC2235_8BIT, 0x17, 0x01 },
-	{ GC2235_8BIT, 0x21, 0x01 },
-	{ GC2235_8BIT, 0x22, 0x02 },
-	{ GC2235_8BIT, 0x23, 0x01 },
-	{ GC2235_8BIT, 0x29, 0x02 },
-	{ GC2235_8BIT, 0x2a, 0x01 },
-	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
-	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
-	{ GC2235_TOK_TERM, 0, 0 }
+static struct gc2235_reg const gc2235_still_1600x1200_30fps[] = {
+	{GC2235_8BIT, 0xfe, 0x00},
+	{GC2235_8BIT, 0x0a, 0x02},
+	{GC2235_8BIT, 0x0c, 0x00},
+	{GC2235_8BIT, 0x0d, 0x04},
+	{GC2235_8BIT, 0x0e, 0xd0},
+	{GC2235_8BIT, 0x0f, 0x06},
+	{GC2235_8BIT, 0x10, 0x58},
+
+	{GC2235_8BIT, 0x90, 0x01},
+	{GC2235_8BIT, 0x92, 0x02},
+	{GC2235_8BIT, 0x94, 0x00},
+	{GC2235_8BIT, 0x95, 0x04},
+	{GC2235_8BIT, 0x96, 0xc0},
+	{GC2235_8BIT, 0x97, 0x06},
+	{GC2235_8BIT, 0x98, 0x50},
+
+	{GC2235_8BIT, 0xfe, 0x03},
+	{GC2235_8BIT, 0x12, 0xe4},
+	{GC2235_8BIT, 0x13, 0x07},
+	{GC2235_8BIT, 0x04, 0x20},
+	{GC2235_8BIT, 0x05, 0x00},
+	{GC2235_8BIT, 0xfe, 0x00},
+	{GC2235_TOK_TERM, 0, 0},
 };
 
-struct gc2235_resolution gc2235_res_preview[] = {
-	{
-		.desc = "gc2235_1600_900_30fps",
-		.width = 1616,
-		.height = 916,
-		.pix_clk_freq = 75,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 932,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_916_30fps,
-	},
-	{
-		.desc = "gc2235_1600_1066_30fps",
-		.width = 1616,
-		.height = 1082,
-		.pix_clk_freq = 75,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 1098,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_1082_30fps,
-	},
+
+/* TODO settings of preview/still/video will be updated with new use case */
+
+struct gc2235_resolution gc2235_res_still[] = {
 	{
-		.desc = "gc2235_1600_1200_30fps",
+		.desc = "gc2235_1600x1200_30fps",
+		.regs = gc2235_still_1600x1200_30fps,
 		.width = 1616,
 		.height = 1216,
-		.pix_clk_freq = 75,
-		.fps = 27,
+		.fps = 23,
+		.pixels_per_line = 0x8c0,
+		.lines_per_frame = 0x500,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
 		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 1232,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
+		.skip_frames = 2,
 		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_1216_30fps,
 	},
 };
-#define N_RES_PREVIEW (ARRAY_SIZE(gc2235_res_preview))
 
-struct gc2235_resolution gc2235_res_still[] = {
-	{
-		.desc = "gc2235_1600_900_30fps",
-		.width = 1616,
-		.height = 916,
-		.pix_clk_freq = 75,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 932,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_916_30fps,
-	},
-	{
-		.desc = "gc2235_1600_1066_30fps",
-		.width = 1616,
-		.height = 1082,
-		.pix_clk_freq = 75,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 1098,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_1082_30fps,
-	},
+static struct gc2235_reg const gc2235_1280_30fps[] = {
+	{GC2235_8BIT, 0xfe, 0x00},
+	{GC2235_8BIT, 0x0a, 0x98},
+	{GC2235_8BIT, 0x0c, 0x00},
+	{GC2235_8BIT, 0x0d, 0x03},
+	{GC2235_8BIT, 0x0e, 0xa4},
+	{GC2235_8BIT, 0x0f, 0x06},
+	{GC2235_8BIT, 0x10, 0x50},
+
+	{GC2235_8BIT, 0x90, 0x01},
+	{GC2235_8BIT, 0x92, 0x02},
+	{GC2235_8BIT, 0x94, 0x00},
+	{GC2235_8BIT, 0x95, 0x03},
+	{GC2235_8BIT, 0x96, 0x94},
+	{GC2235_8BIT, 0x97, 0x06},
+	{GC2235_8BIT, 0x98, 0x50},
+	{GC2235_TOK_TERM, 0, 0},
+};
+
+struct gc2235_resolution gc2235_res_preview[] = {
 	{
-		.desc = "gc2235_1600_1200_30fps",
+		.desc = "gc2235_1600x1200_30fps",
+		.regs = gc2235_1600x1200_30fps,
 		.width = 1616,
 		.height = 1216,
-		.pix_clk_freq = 75,
-		.fps = 27,
+		.fps = 23,
+		.pixels_per_line = 0x8c0,
+		.lines_per_frame = 0x500,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
 		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 1232,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
+		.skip_frames = 2,
 		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_1216_30fps,
 	},
 };
-#define N_RES_STILL (ARRAY_SIZE(gc2235_res_still))
 
 struct gc2235_resolution gc2235_res_video[] = {
 	{
-		.desc = "gc2235_1600_900_30fps",
+		.desc = "gc2235_1280_30fps",
+		.regs = gc2235_1280_30fps,
 		.width = 1616,
 		.height = 916,
-		.pix_clk_freq = 75,
 		.fps = 30,
+		.pixels_per_line = 0x8c0,
+		.lines_per_frame = 0x3c4,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
 		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 932,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_916_30fps,
+		.skip_frames = 4,
 	},
-	{
-		.desc = "gc2235_1600_1066_30fps",
-		.width = 1616,
-		.height = 1082,
-		.pix_clk_freq = 75,
-		.fps = 30,
-		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 1098,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_1082_30fps,
-	},
-	{
-		.desc = "gc2235_1600_1200_30fps",
-		.width = 1616,
-		.height = 1216,
-		.pix_clk_freq = 75,
-		.fps = 27,
-		.used = 0,
-		.pixels_per_line = 1616,
-		.lines_per_frame = 1232,
-		.bin_factor_x = 0,
-		.bin_factor_y = 0,
-		.bin_mode = 0,
-		.skip_frames = 3,
-		.regs = gc2235_1616_1216_30fps,
+};
+
+/********************** settings for imx - reference *********************/
+static struct gc2235_reg const gc2235_init_settings[] = {
+	{ GC2235_TOK_TERM, 0, 0}
+};
+
+struct gc2235_settings gc2235_sets[] = {
+	[0] = {
+		.init_settings = gc2235_init_settings,
+		.res_preview = gc2235_res_preview,
+		.res_still = gc2235_res_still,
+		.res_video = gc2235_res_video,
+		.n_res_preview = ARRAY_SIZE(gc2235_res_preview),
+		.n_res_still = ARRAY_SIZE(gc2235_res_still),
+		.n_res_video = ARRAY_SIZE(gc2235_res_video),
 	},
 };
-#define N_RES_VIDEO (ARRAY_SIZE(gc2235_res_video))
 
-static struct gc2235_resolution *gc2235_res = gc2235_res_preview;
-static int N_RES = N_RES_PREVIEW;
+#define	v4l2_format_capture_type_entry(_width, _height, \
+		_pixelformat, _bytesperline, _colorspace) \
+	{\
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\
+		.fmt.pix.width = (_width),\
+		.fmt.pix.height = (_height),\
+		.fmt.pix.pixelformat = (_pixelformat),\
+		.fmt.pix.bytesperline = (_bytesperline),\
+		.fmt.pix.colorspace = (_colorspace),\
+		.fmt.pix.sizeimage = (_height)*(_bytesperline),\
+	}
+
+#define	s_output_format_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps) \
+	{\
+		.v4l2_fmt = v4l2_format_capture_type_entry(_width, \
+			_height, _pixelformat, _bytesperline, \
+				_colorspace),\
+		.fps = (_fps),\
+	}
+
+#define	s_output_format_reg_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps, _reg_setting) \
+	{\
+		.s_fmt = s_output_format_entry(_width, _height,\
+				_pixelformat, _bytesperline, \
+				_colorspace, _fps),\
+		.reg_setting = (_reg_setting),\
+	}
+
+struct s_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
+};
+
+#define	v4l2_queryctrl_entry_integer(_id, _name,\
+		_minimum, _maximum, _step, \
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_INTEGER, \
+		.name = _name, \
+		.minimum = (_minimum), \
+		.maximum = (_maximum), \
+		.step = (_step), \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+#define	v4l2_queryctrl_entry_boolean(_id, _name,\
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_BOOLEAN, \
+		.name = _name, \
+		.minimum = 0, \
+		.maximum = 1, \
+		.step = 1, \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+
+#define	s_ctrl_id_entry_integer(_id, _name, \
+		_minimum, _maximum, _step, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
+				_minimum, _maximum, _step,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+#define	s_ctrl_id_entry_boolean(_id, _name, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+
+struct gc2235_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/* gc2235 device structure */
+struct gc2235_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct camera_sensor_platform_data *platform_data;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	int fmt_idx;
+	int status;
+	int streaming;
+	int power;
+	int once_launched;
+	int run_mode;
+	int vt_pix_clk_freq_mhz;
+	int fps_index;
+	u32 focus;
+	u16 sensor_id;
+	u16 coarse_itg;
+	u16 fine_itg;
+	u16 gain;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 fps;
+	u8 res;
+	u8 type;
+	u8 *otp_data;
+	struct gc2235_settings *mode_tables;
+	const struct gc2235_resolution *curr_res_table;
+	int entries_curr_table;
+};
+
+#define to_gc2235_sensor(x) container_of(x, struct gc2235_device, sd)
+
+#define GC2235_MAX_WRITE_BUF_SIZE	32
+struct gc2235_write_buffer {
+	u16 addr;
+	u8 data[GC2235_MAX_WRITE_BUF_SIZE];
+};
+
+struct gc2235_write_ctrl {
+	int index;
+	struct gc2235_write_buffer buffer;
+};
+
+static const struct gc2235_reg gc2235_param_update[] = {
+	{GC2235_TOK_TERM, 0, 0}
+};
 #endif
+
+
-- 
1.9.3

