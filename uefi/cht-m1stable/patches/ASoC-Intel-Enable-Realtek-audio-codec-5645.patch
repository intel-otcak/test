From 72cbf4ea1a0365f42b86408b939406db9933b497 Mon Sep 17 00:00:00 2001
From: Carlos Rodriguez <carlos.a.rodriguez@intel.com>
Date: Fri, 29 Jan 2016 00:45:37 -0600
Subject: [PATCH 1/3] ASoC: Intel: Enable Realtek audio codec 5645

The Realtek rt5645 audio codec chip is not part of
the current kernel baseline. These files are to use
to activate the HW (codec driver).

Change-Id: I1c28cbf072be1e9edfbd78c209a50c7e636d640e
Tracked-On: https://jira01.devtools.intel.com/browse/OAM-15628
Signed-off-by: Carlos Rodriguez <carlos.a.rodriguez@intel.com>
Signed-off-by: Alejandro Ochoa <alejandro.ochoa@intel.com>
Reviewed-on: https://android.intel.com:443/467563
---
 arch/x86/configs/x86_64_defconfig          |    1 +
 sound/soc/codecs/Kconfig                   |    4 +
 sound/soc/codecs/Makefile                  |    2 +
 sound/soc/codecs/rt5645.c                  | 3328 ++++++++++++++++++++++++++++
 sound/soc/codecs/rt5645.h                  | 2264 +++++++++++++++++++
 sound/soc/codecs/rt5645_ioctl.c            |  153 ++
 sound/soc/codecs/rt5645_ioctl.h            |   47 +
 sound/soc/codecs/rt_codec_ioctl_5645.c     |  181 ++
 sound/soc/codecs/rt_codec_ioctl_5645.h     |   82 +
 sound/soc/intel/Kconfig                    |    1 +
 sound/soc/intel/board/Makefile             |    3 +-
 sound/soc/intel/board/cht_cr_dpcm_rt5645.c | 1043 +++++++++
 sound/soc/intel/sst/sst.c                  |   21 +-
 sound/soc/intel/sst/sst_platform.c         |    3 +-
 14 files changed, 7128 insertions(+), 5 deletions(-)
 create mode 100644 sound/soc/codecs/rt5645.c
 create mode 100644 sound/soc/codecs/rt5645.h
 create mode 100644 sound/soc/codecs/rt5645_ioctl.c
 create mode 100644 sound/soc/codecs/rt5645_ioctl.h
 create mode 100644 sound/soc/codecs/rt_codec_ioctl_5645.c
 create mode 100644 sound/soc/codecs/rt_codec_ioctl_5645.h
 create mode 100644 sound/soc/intel/board/cht_cr_dpcm_rt5645.c

diff --git a/arch/x86/configs/x86_64_defconfig b/arch/x86/configs/x86_64_defconfig
index 2ead254..f76f3e1 100644
--- a/arch/x86/configs/x86_64_defconfig
+++ b/arch/x86/configs/x86_64_defconfig
@@ -2826,6 +2826,7 @@ CONFIG_SND_SOC_RT56XX=y
 CONFIG_SND_SOC_RT5640=y
 CONFIG_SND_SOC_RT5651=y
 CONFIG_SND_SOC_RT5672=y
+CONFIG_SND_SOC_RT5645=y
 CONFIG_SND_SOC_TLV320AIC31XX=y
 # CONFIG_SND_SIMPLE_CARD is not set
 # CONFIG_SOUND_PRIME is not set
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 24fc38c..e8ad9be 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -62,6 +62,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_PCM3008
 	select SND_SOC_RT5631 if I2C
 	select SND_SOC_RT5640 if I2C
+	select SND_SOC_RT5645 if I2C
 	select SND_SOC_RT5651 if I2C
 	select SND_SOC_SGTL5000 if I2C
 	select SND_SOC_SI476X if MFD_SI476X_CORE
@@ -339,6 +340,9 @@ config SND_SOC_RT56XX
 config SND_SOC_RT5640
 	tristate
 
+config SND_SOC_RT5645
+	tristate
+
 config SND_SOC_RT5651
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 218ec53..fd6cb78 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -23,6 +23,7 @@ snd-soc-cs42l52-objs := cs42l52.o
 snd-soc-rt56xx-objs := rt56xx_ioctl.o
 snd-soc-rt5640-objs := rt5640.o rt5640_ioctl.o
 snd-soc-rt5642-objs := rt5640.o rt5640-dsp.o rt5640_ioctl.o
+snd-soc-rt5645-objs := rt5645.o rt_codec_ioctl_5645.o rt5645_ioctl.o
 snd-soc-rt5651-objs := rt5651.o rt5651_ioctl.o
 snd-soc-rt5672-objs := rt5670.o rt5670-dsp.o rt5670_ioctl.o rt_codec_ioctl.o
 snd-soc-cs42l73-objs := cs42l73.o
@@ -162,6 +163,7 @@ obj-$(CONFIG_SND_SOC_CQ0093VC) += snd-soc-cq93vc.o
 obj-$(CONFIG_SND_SOC_RT56XX) += snd-soc-rt56xx.o
 obj-$(CONFIG_SND_SOC_RT5640) += snd-soc-rt5640.o
 obj-$(CONFIG_SND_SOC_RT5642) += snd-soc-rt5642.o
+obj-$(CONFIG_SND_SOC_RT5645) += snd-soc-rt5645.o
 obj-$(CONFIG_SND_SOC_RT5651) += snd-soc-rt5651.o
 obj-$(CONFIG_SND_SOC_RT5672) += snd-soc-rt5672.o
 obj-$(CONFIG_SND_SOC_CS42L51)	+= snd-soc-cs42l51.o
diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c
new file mode 100644
index 0000000..d888faf
--- /dev/null
+++ b/sound/soc/codecs/rt5645.c
@@ -0,0 +1,3328 @@
+/*
+ * rt5645.c  --  RT5645 ALSA SoC audio codec driver
+ *
+ * Copyright 2012 Realtek Semiconductor Corp.
+ * Author: Bard Liao <bardliao@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/jack.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/acpi.h>
+
+#define RTK_IOCTL
+#ifdef RTK_IOCTL
+#if defined(CONFIG_SND_HWDEP) || defined(CONFIG_SND_HWDEP_MODULE)
+#include "rt_codec_ioctl_5645.h"
+#include "rt5645_ioctl.h"
+#endif
+#endif
+
+#include "rt5645.h"
+
+#define RT5645_DET_EXT_MIC 0
+/* #define USE_INT_CLK */
+#define JD1_FUNC
+/* #define ALC_DRC_FUNC */
+#define USE_ASRC
+#define USE_TDM
+
+#define VERSION "0.0.9 alsa 1.0.25"
+
+struct rt5645_init_reg {
+	u8 reg;
+	u16 val;
+};
+
+static struct rt5645_init_reg init_list[] = {
+	{ RT5645_DIG_MISC	, 0x0129 },
+	{ RT5645_ADDA_CLK1	, 0x0005 },
+	{ RT5645_IL_CMD2	, 0x0010 }, /* set Inline Command Window */
+	{ RT5645_PRIV_INDEX	, 0x003d },
+	{ RT5645_PRIV_DATA	, 0x3600 },
+	{ RT5645_A_JD_CTRL1	, 0x0202 },/* for combo jack 1.8v */
+	{RT5645_GEN_CTRL2	, 0x0028 },
+	/* playback */
+	{ RT5645_DAC_CTRL	, 0x0011 },
+	/* Dig inf 1 -> Sto DAC mixer -> DACL */
+	{ RT5645_STO_DAC_MIXER	, 0x1616 },
+
+	{ RT5645_MONO_DAC_MIXER	, 0x4444 },
+	{ RT5645_OUT_L1_MIXER	, 0x01fe },/* DACL1 -> OUTMIXL */
+	{ RT5645_OUT_R1_MIXER	, 0x01fe },/* DACR1 -> OUTMIXR */
+	{ RT5645_LOUT_MIXER	, 0xc000 },
+	{ RT5645_LOUT1		, 0x8888 },
+#if 0 /* HP direct path */
+	{ RT5645_HPO_MIXER	, 0x2000 },/* DAC1 -> HPOLMIX */
+#else /* HP via mixer path */
+	{ RT5645_HPOMIXL_CTRL	, 0x001e },/* DAC1 -> HPOVOL */
+	{ RT5645_HPOMIXR_CTRL	, 0x001e },/* DAC1 -> HPOVOL */
+	{ RT5645_HPO_MIXER	, 0x4000 },/* HPOVOL -> HPOLMIX */
+#endif
+	{ RT5645_HP_VOL		, 0x8888 },/* OUTMIX -> HPVOL */
+#if 0 /* SPK direct path */
+	{ RT5645_SPO_MIXER	, 0x7803 },/* DAC1 -> SPO */
+#else /* SPK via mixer path */
+	{ RT5645_SPK_L_MIXER	, 0x003c },/* DAC1 -> SPKVOL */
+	{ RT5645_SPK_R_MIXER	, 0x003c },/* DAC1 -> SPKVOL */
+	{ RT5645_SPO_MIXER	, 0xd806 },/* SPKVOL -> SPO */
+#endif
+	{ RT5645_SPK_VOL	, 0x8888 },
+	{ RT5645_AD_DA_MIXER	, 0x8580 },
+	{ RT5645_ASRC_8		, 0x0000 },
+	/* record */
+	/* IN1 boost 20db and signal ended mode */
+	{ RT5645_IN1_IN2	, 0x0200 },
+
+	{ RT5645_REC_L2_MIXER	, 0x007d },/* Mic1 -> RECMIXL */
+	{ RT5645_REC_R2_MIXER	, 0x007d },/* Mic1 -> RECMIXR */
+	/* DMIC1 */
+	{ RT5645_STO1_ADC_MIXER	, 0x5840 },
+	{ RT5645_MONO_ADC_MIXER	, 0x5858 },
+
+#if 0 /* DMIC2 */
+	{ RT5645_STO1_ADC_MIXER	, 0x5940 },
+	{ RT5645_MONO_ADC_MIXER	, 0x5858 },
+#endif
+#if 0 /* AMIC */
+	{ RT5645_STO1_ADC_MIXER	, 0x3020 },/* ADC -> Sto ADC mixer */
+	{ RT5645_MONO_ADC_MIXER	, 0x3838 },
+#endif
+	{ RT5645_DMIC_CTRL1	, 0x1469 },
+	/* Mute STO1 ADC for depop, Digital Input Gain */
+	/* { RT5645_STO1_ADC_DIG_VOL, 0xafaf },*/
+
+	/* Mute STO1 ADC for depop, Digital Input Gain */
+	{ RT5645_STO1_ADC_DIG_VOL, 0xd7d7 },
+
+	{ RT5645_GPIO_CTRL1	, 0xc000 },
+	{ RT5645_GPIO_CTRL2	, 0x0004 },
+#ifdef JD1_FUNC
+	{ RT5645_IRQ_CTRL2	, 0x0200 },
+	{ RT5645_MICBIAS	, 0x0008 },
+	{ RT5645_GEN_CTRL3	, 0x1180 },
+	{ RT5645_CJ_CTRL1	, 0x4021 },
+	{ RT5645_CJ_CTRL3	, 0x4000 },
+#endif
+
+};
+#define RT5645_INIT_REG_LEN ARRAY_SIZE(init_list)
+
+#ifdef ALC_DRC_FUNC
+static struct rt5645_init_reg alc_drc_list[] = {
+	{ RT5645_ALC_DRC_CTRL1	, 0x0000 },
+	{ RT5645_ALC_DRC_CTRL2	, 0x0000 },
+	{ RT5645_ALC_CTRL_2	, 0x0000 },
+	{ RT5645_ALC_CTRL_3	, 0x0000 },
+	{ RT5645_ALC_CTRL_4	, 0x0000 },
+	{ RT5645_ALC_CTRL_1	, 0x0000 },
+};
+#define RT5645_ALC_DRC_REG_LEN ARRAY_SIZE(alc_drc_list)
+#endif
+
+static int rt5645_reg_init(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for (i = 0; i < RT5645_INIT_REG_LEN; i++)
+		snd_soc_write(codec, init_list[i].reg, init_list[i].val);
+#ifdef ALC_DRC_FUNC
+	for (i = 0; i < RT5645_ALC_DRC_REG_LEN; i++)
+		snd_soc_write(codec, alc_drc_list[i].reg, alc_drc_list[i].val);
+#endif
+
+	return 0;
+}
+
+static int rt5645_index_sync(struct snd_soc_codec *codec)
+{
+	int i;
+
+	for (i = 0; i < RT5645_INIT_REG_LEN; i++)
+		if (RT5645_PRIV_INDEX == init_list[i].reg ||
+			RT5645_PRIV_DATA == init_list[i].reg)
+			snd_soc_write(codec, init_list[i].reg,
+					init_list[i].val);
+	return 0;
+}
+
+static const u16 rt5645_reg[RT5645_VENDOR_ID2 + 1] = {
+	[RT5645_HP_VOL] = 0xc8c8,
+	[RT5645_SPK_VOL] = 0xc8c8,
+	[RT5645_LOUT1] = 0xc8c8,
+	[RT5645_CJ_CTRL1] = 0x4002,
+	[RT5645_CJ_CTRL2] = 0x0827,
+	[RT5645_CJ_CTRL3] = 0xe000,
+	[RT5645_INL1_INR1_VOL] = 0x0808,
+	[RT5645_SPK_FUNC_LIM] = 0x3333,
+	[RT5645_ADJ_HPF_CTRL] = 0x4b00,
+	[RT5645_SIDETONE_CTRL] = 0x018b,
+	[RT5645_DAC1_DIG_VOL] = 0xafaf,
+	[RT5645_DAC2_DIG_VOL] = 0xafaf,
+	[RT5645_DAC_CTRL] = 0x0001,
+	[RT5645_STO1_ADC_DIG_VOL] = 0x2f2f,
+	[RT5645_MONO_ADC_DIG_VOL] = 0x2f2f,
+	[RT5645_STO1_ADC_MIXER] = 0x7060,
+	[RT5645_MONO_ADC_MIXER] = 0x7070,
+	[RT5645_AD_DA_MIXER] = 0x8080,
+	[RT5645_STO_DAC_MIXER] = 0x5656,
+	[RT5645_MONO_DAC_MIXER] = 0x5454,
+	[RT5645_DIG_MIXER] = 0xaaa0,
+	[RT5645_DIG_INF1_DATA] = 0x1002,
+	[RT5645_PDM_OUT_CTRL] = 0x5000,
+	[RT5645_REC_L2_MIXER] = 0x007f,
+	[RT5645_REC_R2_MIXER] = 0x007f,
+	[RT5645_HPOMIXL_CTRL] = 0x001f,
+	[RT5645_HPOMIXR_CTRL] = 0x001f,
+	[RT5645_HPO_MIXER] = 0x6000,
+	[RT5645_SPK_L_MIXER] = 0x003e,
+	[RT5645_SPK_R_MIXER] = 0x003e,
+	[RT5645_SPO_MIXER] = 0xf807,
+	[RT5645_SPO_CLSD_RATIO] = 0x0007,
+	[RT5645_OUT_L1_MIXER] = 0x01ff,
+	[RT5645_OUT_R1_MIXER] = 0x01ff,
+	[RT5645_LOUT_MIXER] = 0xf000,
+	[RT5645_HAPTIC_CTRL1] = 0x0111,
+	[RT5645_HAPTIC_CTRL2] = 0x0064,
+	[RT5645_HAPTIC_CTRL3] = 0xef0e,
+	[RT5645_HAPTIC_CTRL4] = 0xf0f0,
+	[RT5645_HAPTIC_CTRL5] = 0xef0e,
+	[RT5645_HAPTIC_CTRL6] = 0xf0f0,
+	[RT5645_HAPTIC_CTRL7] = 0xef0e,
+	[RT5645_HAPTIC_CTRL8] = 0xf0f0,
+	[RT5645_HAPTIC_CTRL9] = 0xf000,
+	[RT5645_PWR_DIG1] = 0x0300,
+	[RT5645_PWR_ANLG1] = 0x00c2,
+	[RT5645_I2S1_SDP] = 0x8000,
+	[RT5645_I2S2_SDP] = 0x8000,
+	[RT5645_I2S3_SDP] = 0x8000,
+	[RT5645_ADDA_CLK1] = 0x1110,
+	[RT5645_ADDA_CLK2] = 0x3e00,
+	[RT5645_DMIC_CTRL1] = 0x2409,
+	[RT5645_DMIC_CTRL2] = 0x000a,
+	[RT5645_TDM_CTRL_3] = 0x0123,
+	[RT5645_ASRC_3] = 0x0003,
+	[RT5645_DEPOP_M1] = 0x0004,
+	[RT5645_DEPOP_M2] = 0x1100,
+	[RT5645_DEPOP_M3] = 0x0646,
+	[RT5645_CHARGE_PUMP] = 0x0c06,
+	[RT5645_MICBIAS] = 0x3000,
+	[RT5645_A_JD_CTRL1] = 0x0200,
+	[RT5645_VAD_CTRL1] = 0x2184,
+	[RT5645_VAD_CTRL2] = 0x010a,
+	[RT5645_VAD_CTRL3] = 0x0aea,
+	[RT5645_VAD_CTRL4] = 0x000c,
+	[RT5645_VAD_CTRL5] = 0x0400,
+	[RT5645_CLSD_OUT_CTRL] = 0xa0a8,
+	[RT5645_CLSD_OUT_CTRL1] = 0x0059,
+	[RT5645_CLSD_OUT_CTRL2] = 0x0001,
+	[RT5645_ADC_EQ_CTRL1] = 0x6000,
+	[RT5645_EQ_CTRL1] = 0x6000,
+	[RT5645_ALC_DRC_CTRL2] = 0x001f,
+	[RT5645_ALC_CTRL_1] = 0x020c,
+	[RT5645_ALC_CTRL_2] = 0x1f00,
+	[RT5645_ALC_CTRL_4] = 0x4000,
+	[RT5645_INT_IRQ_ST] = 0x0180,
+	[RT5645_GPIO_CTRL4] = 0x2000,
+	[RT5645_BASE_BACK] = 0x1813,
+	[RT5645_MP3_PLUS1] = 0x0690,
+	[RT5645_MP3_PLUS2] = 0x1c17,
+	[RT5645_ADJ_HPF1] = 0xb320,
+	[RT5645_HP_CALIB_AMP_DET] = 0x0400,
+	[RT5645_SV_ZCD1] = 0x0809,
+	[RT5645_IL_CMD] = 0x0003,
+	[RT5645_IL_CMD2] = 0x0049,
+	[RT5645_IL_CMD3] = 0x001b,
+	[RT5645_DRC1_HL_CTRL1] = 0x8000,
+	[RT5645_DRC1_HL_CTRL2] = 0x0200,
+	[RT5645_DRC2_HL_CTRL1] = 0x8000,
+	[RT5645_DRC2_HL_CTRL2] = 0x0200,
+	[RT5645_MUTI_DRC_CTRL1] = 0x0f20,
+	[RT5645_ADC_MONO_HP_CTRL1] = 0xb300,
+	[RT5645_DRC2_CTRL1] = 0x001f,
+	[RT5645_DRC2_CTRL2] = 0x020c,
+	[RT5645_DRC2_CTRL3] = 0x1f00,
+	[RT5645_DRC2_CTRL5] = 0x4000,
+	[RT5645_DIG_MISC] = 0x0120,
+};
+
+static int rt5645_reset(struct snd_soc_codec *codec)
+{
+	return snd_soc_write(codec, RT5645_RESET, 0);
+}
+
+/**
+ * rt5645_index_write - Write private register.
+ * @codec: SoC audio codec device.
+ * @reg: Private register index.
+ * @value: Private register Data.
+ *
+ * Modify private register for advanced setting. It can be written through
+ * private index (0x6a) and data (0x6c) register.
+ *
+ * Returns 0 for success or negative error code.
+ */
+static int rt5645_index_write(struct snd_soc_codec *codec,
+		unsigned int reg, unsigned int value)
+{
+	int ret;
+
+	ret = snd_soc_write(codec, RT5645_PRIV_INDEX, reg);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set private addr: %d\n", ret);
+		goto err;
+	}
+	ret = snd_soc_write(codec, RT5645_PRIV_DATA, value);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set private value: %d\n", ret);
+		goto err;
+	}
+	return 0;
+
+err:
+	return ret;
+}
+
+/**
+ * rt5645_index_read - Read private register.
+ * @codec: SoC audio codec device.
+ * @reg: Private register index.
+ *
+ * Read advanced setting from private register. It can be read through
+ * private index (0x6a) and data (0x6c) register.
+ *
+ * Returns private register value or negative error code.
+ */
+static unsigned int rt5645_index_read(
+	struct snd_soc_codec *codec, unsigned int reg)
+{
+	int ret;
+
+	ret = snd_soc_write(codec, RT5645_PRIV_INDEX, reg);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to set private addr: %d\n", ret);
+		return ret;
+	}
+	return snd_soc_read(codec, RT5645_PRIV_DATA);
+}
+
+/**
+ * rt5645_index_update_bits - update private register bits
+ * @codec: audio codec
+ * @reg: Private register index.
+ * @mask: register mask
+ * @value: new value
+ *
+ * Writes new register value.
+ *
+ * Returns 1 for change, 0 for no change, or negative error code.
+ */
+static int rt5645_index_update_bits(struct snd_soc_codec *codec,
+	unsigned int reg, unsigned int mask, unsigned int value)
+{
+	unsigned int old, new;
+	int change, ret;
+
+	ret = rt5645_index_read(codec, reg);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to read private reg: %d\n", ret);
+		goto err;
+	}
+
+	old = ret;
+	new = (old & ~mask) | (value & mask);
+	change = old != new;
+	if (change) {
+		ret = rt5645_index_write(codec, reg, new);
+		if (ret < 0) {
+			dev_err(codec->dev,
+				"Failed to write private reg: %d\n", ret);
+			goto err;
+		}
+	}
+	return change;
+
+err:
+	return ret;
+}
+
+
+static int rt5645_volatile_register(
+	struct snd_soc_codec *codec, unsigned int reg)
+{
+	switch (reg) {
+	case RT5645_RESET:
+	case RT5645_PDM_DATA_CTRL1:
+	case RT5645_PDM1_DATA_CTRL4:
+	case RT5645_PRIV_DATA:
+	case RT5645_CJ_CTRL1:
+	case RT5645_CJ_CTRL2:
+	case RT5645_CJ_CTRL3:
+	case RT5645_A_JD_CTRL1:
+	case RT5645_A_JD_CTRL2:
+	case RT5645_VAD_CTRL5:
+	case RT5645_ADC_EQ_CTRL1:
+	case RT5645_EQ_CTRL1:
+	case RT5645_ALC_CTRL_1:
+	case RT5645_IRQ_CTRL2:
+	case RT5645_IRQ_CTRL3:
+	case RT5645_INT_IRQ_ST:
+	case RT5645_IL_CMD:
+	case RT5645_VENDOR_ID:
+	case RT5645_VENDOR_ID1:
+	case RT5645_VENDOR_ID2:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static int rt5645_readable_register(
+	struct snd_soc_codec *codec, unsigned int reg)
+{
+	switch (reg) {
+	case RT5645_RESET:
+	case RT5645_SPK_VOL:
+	case RT5645_HP_VOL:
+	case RT5645_LOUT1:
+	case RT5645_CJ_CTRL1:
+	case RT5645_CJ_CTRL2:
+	case RT5645_CJ_CTRL3:
+	case RT5645_IN1_IN2:
+	case RT5645_IN3:
+	case RT5645_INL1_INR1_VOL:
+	case RT5645_SPK_FUNC_LIM:
+	case RT5645_ADJ_HPF_CTRL:
+	case RT5645_SIDETONE_CTRL:
+	case RT5645_DAC1_DIG_VOL:
+	case RT5645_DAC2_DIG_VOL:
+	case RT5645_DAC_CTRL:
+	case RT5645_STO1_ADC_DIG_VOL:
+	case RT5645_MONO_ADC_DIG_VOL:
+	case RT5645_ADC_BST_VOL1:
+	case RT5645_ADC_BST_VOL2:
+	case RT5645_STO1_ADC_MIXER:
+	case RT5645_MONO_ADC_MIXER:
+	case RT5645_AD_DA_MIXER:
+	case RT5645_STO_DAC_MIXER:
+	case RT5645_MONO_DAC_MIXER:
+	case RT5645_DIG_MIXER:
+	case RT5645_DIG_INF1_DATA:
+	case RT5645_PDM_OUT_CTRL:
+	case RT5645_PDM_DATA_CTRL1:
+	case RT5645_PDM1_DATA_CTRL2:
+	case RT5645_PDM1_DATA_CTRL3:
+	case RT5645_PDM1_DATA_CTRL4:
+	case RT5645_REC_L1_MIXER:
+	case RT5645_REC_L2_MIXER:
+	case RT5645_REC_R1_MIXER:
+	case RT5645_REC_R2_MIXER:
+	case RT5645_HPMIXL_CTRL:
+	case RT5645_HPOMIXL_CTRL:
+	case RT5645_HPMIXR_CTRL:
+	case RT5645_HPOMIXR_CTRL:
+	case RT5645_HPO_MIXER:
+	case RT5645_SPK_L_MIXER:
+	case RT5645_SPK_R_MIXER:
+	case RT5645_SPO_MIXER:
+	case RT5645_SPO_CLSD_RATIO:
+	case RT5645_OUT_L1_MIXER:
+	case RT5645_OUT_R1_MIXER:
+	case RT5645_OUT_L_GAIN1:
+	case RT5645_OUT_L_GAIN2:
+	case RT5645_OUT_R_GAIN1:
+	case RT5645_OUT_R_GAIN2:
+	case RT5645_LOUT_MIXER:
+	case RT5645_HAPTIC_CTRL1:
+	case RT5645_HAPTIC_CTRL2:
+	case RT5645_HAPTIC_CTRL3:
+	case RT5645_HAPTIC_CTRL4:
+	case RT5645_HAPTIC_CTRL5:
+	case RT5645_HAPTIC_CTRL6:
+	case RT5645_HAPTIC_CTRL7:
+	case RT5645_HAPTIC_CTRL8:
+	case RT5645_HAPTIC_CTRL9:
+	case RT5645_HAPTIC_CTRL10:
+	case RT5645_PWR_DIG1:
+	case RT5645_PWR_DIG2:
+	case RT5645_PWR_ANLG1:
+	case RT5645_PWR_ANLG2:
+	case RT5645_PWR_MIXER:
+	case RT5645_PWR_VOL:
+	case RT5645_PRIV_INDEX:
+	case RT5645_PRIV_DATA:
+	case RT5645_I2S1_SDP:
+	case RT5645_I2S2_SDP:
+	case RT5645_I2S3_SDP:
+	case RT5645_ADDA_CLK1:
+	case RT5645_ADDA_CLK2:
+	case RT5645_DMIC_CTRL1:
+	case RT5645_DMIC_CTRL2:
+	case RT5645_TDM_CTRL_1:
+	case RT5645_TDM_CTRL_2:
+	case RT5645_GLB_CLK:
+	case RT5645_PLL_CTRL1:
+	case RT5645_PLL_CTRL2:
+	case RT5645_ASRC_1:
+	case RT5645_ASRC_2:
+	case RT5645_ASRC_3:
+	case RT5645_ASRC_8:
+	case RT5645_DEPOP_M1:
+	case RT5645_DEPOP_M2:
+	case RT5645_DEPOP_M3:
+	case RT5645_CHARGE_PUMP:
+	case RT5645_MICBIAS:
+	case RT5645_A_JD_CTRL1:
+	case RT5645_A_JD_CTRL2:
+	case RT5645_VAD_CTRL1:
+	case RT5645_VAD_CTRL2:
+	case RT5645_VAD_CTRL3:
+	case RT5645_VAD_CTRL4:
+	case RT5645_VAD_CTRL5:
+	case RT5645_CLSD_OUT_CTRL:
+	case RT5645_CLSD_OUT_CTRL1:
+	case RT5645_CLSD_OUT_CTRL2:
+	case RT5645_ADC_EQ_CTRL1:
+	case RT5645_ADC_EQ_CTRL2:
+	case RT5645_EQ_CTRL1:
+	case RT5645_EQ_CTRL2:
+	case RT5645_ALC_DRC_CTRL1:
+	case RT5645_ALC_DRC_CTRL2:
+	case RT5645_ALC_CTRL_1:
+	case RT5645_ALC_CTRL_2:
+	case RT5645_ALC_CTRL_3:
+	case RT5645_JD_CTRL:
+	case RT5645_IRQ_CTRL1:
+	case RT5645_IRQ_CTRL2:
+	case RT5645_IRQ_CTRL3:
+	case RT5645_INT_IRQ_ST:
+	case RT5645_GPIO_CTRL1:
+	case RT5645_GPIO_CTRL2:
+	case RT5645_GPIO_CTRL3:
+	case RT5645_GPIO_CTRL4:
+	case RT5645_SCRABBLE_FUN:
+	case RT5645_SCRABBLE_CTRL:
+	case RT5645_BASE_BACK:
+	case RT5645_MP3_PLUS1:
+	case RT5645_MP3_PLUS2:
+	case RT5645_ADJ_HPF1:
+	case RT5645_ADJ_HPF2:
+	case RT5645_HP_CALIB_AMP_DET:
+	case RT5645_SV_ZCD1:
+	case RT5645_SV_ZCD2:
+	case RT5645_IL_CMD:
+	case RT5645_IL_CMD2:
+	case RT5645_IL_CMD3:
+	case RT5645_DRC1_HL_CTRL1:
+	case RT5645_DRC1_HL_CTRL2:
+	case RT5645_ADC_MONO_HP_CTRL1:
+	case RT5645_ADC_MONO_HP_CTRL2:
+	case RT5645_DRC2_CTRL1:
+	case RT5645_DRC2_CTRL2:
+	case RT5645_DRC2_CTRL3:
+	case RT5645_DRC2_CTRL4:
+	case RT5645_DRC2_CTRL5:
+	case RT5645_JD_CTRL3:
+	case RT5645_JD_CTRL4:
+	case RT5645_DIG_MISC:
+	case RT5645_GEN_CTRL2:
+	case RT5645_GEN_CTRL3:
+	case RT5645_VENDOR_ID:
+	case RT5645_VENDOR_ID1:
+	case RT5645_VENDOR_ID2:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+void dc_calibrate(struct snd_soc_codec *codec)
+{
+	unsigned int sclk_src;
+
+	sclk_src = snd_soc_read(codec, RT5645_GLB_CLK) &
+		RT5645_SCLK_SRC_MASK;
+
+	snd_soc_update_bits(codec, RT5645_PWR_ANLG2,
+		RT5645_PWR_MB1, RT5645_PWR_MB1);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M2,
+		RT5645_DEPOP_MASK, RT5645_DEPOP_MAN);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_HP_CP_MASK | RT5645_HP_SG_MASK
+		| RT5645_HP_CB_MASK, RT5645_HP_CP_PU
+		| RT5645_HP_SG_DIS | RT5645_HP_CB_PU);
+
+	snd_soc_update_bits(codec, RT5645_GLB_CLK,
+		RT5645_SCLK_SRC_MASK, 0x2 << RT5645_SCLK_SRC_SFT);
+	rt5645_index_write(codec, RT5645_HP_DCC_INT1, 0x9f01);
+	snd_soc_update_bits(codec, RT5645_PWR_ANLG2,
+		RT5645_PWR_MB1, 0);
+	snd_soc_update_bits(codec, RT5645_GLB_CLK,
+		RT5645_SCLK_SRC_MASK, sclk_src);
+}
+
+/**
+ * rt5645_headset_detect - Detect headset.
+ * @codec: SoC audio codec device.
+ * @jack_insert: Jack insert or not.
+ *
+ * Detect whether is headset or not when jack inserted.
+ *
+ * Returns detect status.
+ */
+int rt5645_headset_detect(struct snd_soc_codec *codec, int jack_insert)
+{
+	int jack_type, val;
+
+	if (jack_insert) {
+		snd_soc_dapm_force_enable_pin(&codec->dapm, "micbias1");
+		snd_soc_dapm_force_enable_pin(&codec->dapm, "micbias2");
+		snd_soc_dapm_force_enable_pin(&codec->dapm, "LDO2");
+		snd_soc_dapm_force_enable_pin(&codec->dapm, "Mic Det Power");
+		snd_soc_dapm_sync(&codec->dapm);
+		snd_soc_write(codec, RT5645_CJ_CTRL1, 0x4006);
+
+		snd_soc_write(codec, RT5645_JD_CTRL3, 0x00b0);
+		snd_soc_update_bits(codec, RT5645_CJ_CTRL2,
+			RT5645_CBJ_MN_JD, 0);
+		snd_soc_update_bits(codec, RT5645_CJ_CTRL2,
+			RT5645_CBJ_MN_JD, RT5645_CBJ_MN_JD);
+		msleep(400);
+		val = snd_soc_read(codec, RT5645_CJ_CTRL3) & 0x7;
+		pr_debug("%s(): value = %d\n", __func__, val);
+
+		switch (val) {
+		case 0x1: /* Nokia type*/
+		case 0x2: /* iPhone type*/
+			/* for push button */
+			/*snd_soc_update_bits(codec, RT5645_INT_IRQ_ST,
+								0x8, 0x8);*/
+			/*snd_soc_update_bits(codec, RT5645_IL_CMD,
+								0x40, 0x40);*/
+			/*snd_soc_read(codec, RT5645_IL_CMD);*/
+			jack_type = SND_JACK_HEADSET;
+			break;
+		default:
+			snd_soc_dapm_disable_pin(&codec->dapm, "micbias1");
+			snd_soc_dapm_disable_pin(&codec->dapm, "micbias2");
+			snd_soc_dapm_disable_pin(&codec->dapm, "LDO2");
+			snd_soc_dapm_disable_pin(&codec->dapm, "Mic Det Power");
+			snd_soc_dapm_sync(&codec->dapm);
+			snd_soc_update_bits(codec, RT5645_INT_IRQ_ST, 0x8, 0x0);
+			jack_type = SND_JACK_HEADPHONE;
+			break;
+		}
+	} else {
+		snd_soc_dapm_disable_pin(&codec->dapm, "micbias1");
+		snd_soc_dapm_disable_pin(&codec->dapm, "micbias2");
+		snd_soc_dapm_disable_pin(&codec->dapm, "LDO2");
+		snd_soc_dapm_disable_pin(&codec->dapm, "Mic Det Power");
+		snd_soc_dapm_sync(&codec->dapm);
+		jack_type = 0;
+	}
+
+	pr_debug("%s(): jack_type=%d\n", __func__, jack_type);
+	return jack_type;
+}
+EXPORT_SYMBOL(rt5645_headset_detect);
+
+int rt5645_button_detect(struct snd_soc_codec *codec)
+{
+	int btn_type, val;
+
+	if (!(snd_soc_read(codec, RT5645_INT_IRQ_ST) & 0x4))
+		return 0;
+
+	snd_soc_update_bits(codec, RT5645_IL_CMD, 0x40, 0x40);
+
+	val = snd_soc_read(codec, RT5645_IL_CMD);
+	btn_type = val & 0xff80;
+	pr_debug("%s(): button type=0x%x\n", __func__, btn_type);
+	snd_soc_write(codec, RT5645_IL_CMD, val);
+	msleep(20);
+	if (btn_type == 0 ||
+		((snd_soc_read(codec, RT5645_IL_CMD) & 0xff80) == 0)) {
+			pr_debug("%s(): button release\n", __func__);
+			btn_type = 0;
+	}
+
+	return btn_type;
+}
+EXPORT_SYMBOL(rt5645_button_detect);
+
+int rt5645_check_jd_status(struct snd_soc_codec *codec)
+{
+	return snd_soc_read(codec, RT5645_A_JD_CTRL1) & 0x0020;
+}
+EXPORT_SYMBOL(rt5645_check_jd_status);
+
+void rt5645_i2s2_func_switch(struct snd_soc_codec *codec, bool enable)
+{
+	snd_soc_update_bits(codec, RT5645_GPIO_CTRL1,
+		RT5645_I2S2_SEL, (!enable) << RT5645_I2S2_SEL_SFT);
+}
+EXPORT_SYMBOL(rt5645_i2s2_func_switch);
+
+static const DECLARE_TLV_DB_SCALE(out_vol_tlv, -4650, 150, 0);
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -65625, 375, 0);
+static const DECLARE_TLV_DB_SCALE(in_vol_tlv, -3450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(adc_vol_tlv, -17625, 375, 0);
+static const DECLARE_TLV_DB_SCALE(adc_bst_tlv, 0, 1200, 0);
+
+/* {0, +20, +24, +30, +35, +40, +44, +50, +52} dB */
+static unsigned int bst_tlv[] = {
+	TLV_DB_RANGE_HEAD(7),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 1, TLV_DB_SCALE_ITEM(2000, 0, 0),
+	2, 2, TLV_DB_SCALE_ITEM(2400, 0, 0),
+	3, 5, TLV_DB_SCALE_ITEM(3000, 500, 0),
+	6, 6, TLV_DB_SCALE_ITEM(4400, 0, 0),
+	7, 7, TLV_DB_SCALE_ITEM(5000, 0, 0),
+	8, 8, TLV_DB_SCALE_ITEM(5200, 0, 0),
+};
+
+/* IN1/IN2 Input Type */
+static const char *const rt5645_input_mode[] = {
+	"Single ended", "Differential"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_in1_mode_enum, RT5645_IN1_IN2,
+	RT5645_IN_SFT1, rt5645_input_mode);
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_in2_mode_enum, RT5645_IN3,
+	RT5645_IN_SFT2, rt5645_input_mode);
+
+/* Interface data select */
+static const char *const rt5645_data_select[] = {
+	"Normal", "Swap", "left copy to right", "right copy to left"
+};
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_if2_dac_enum, RT5645_DIG_INF1_DATA,
+				RT5645_IF2_DAC_SEL_SFT, rt5645_data_select);
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_if2_adc_enum, RT5645_DIG_INF1_DATA,
+				RT5645_IF2_ADC_SEL_SFT, rt5645_data_select);
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_if3_dac_enum, RT5645_DIG_INF1_DATA,
+				RT5645_IF3_DAC_SEL_SFT, rt5645_data_select);
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_if3_adc_enum, RT5645_DIG_INF1_DATA,
+				RT5645_IF3_ADC_SEL_SFT, rt5645_data_select);
+
+
+static const char *const rt5645_tdm_data_swap_select[] = {
+	"L/R", "R/L", "L/L", "R/R"
+};
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_tdm_adc_slot0_1_enum,
+				RT5645_TDM_CTRL_1, 6,
+				rt5645_tdm_data_swap_select);
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_tdm_adc_slot2_3_enum,
+				RT5645_TDM_CTRL_1, 4,
+				rt5645_tdm_data_swap_select);
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_tdm_adc_slot4_5_enum,
+				RT5645_TDM_CTRL_1, 2,
+				rt5645_tdm_data_swap_select);
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_tdm_adc_slot6_7_enum,
+				RT5645_TDM_CTRL_1, 0,
+				rt5645_tdm_data_swap_select);
+
+static const char *const rt5645_tdm_adc_data_select[] = {
+	"1/2/R", "2/1/R", "R/1/2", "R/2/1"
+};
+
+static const SOC_ENUM_SINGLE_DECL(rt5645_tdm_adc_sel_enum,
+				RT5645_TDM_CTRL_1, 8,
+				rt5645_tdm_adc_data_select);
+
+static const struct snd_kcontrol_new rt5645_snd_controls[] = {
+	/* Speaker Output Volume */
+	SOC_DOUBLE("Speaker Playback Switch", RT5645_SPK_VOL,
+		RT5645_L_MUTE_SFT, RT5645_R_MUTE_SFT, 1, 1),
+	SOC_DOUBLE_TLV("Speaker Playback Volume", RT5645_SPK_VOL,
+		RT5645_L_VOL_SFT, RT5645_R_VOL_SFT, 39, 1, out_vol_tlv),
+	/* Headphone Output Volume */
+	SOC_DOUBLE("HP Playback Switch", RT5645_HP_VOL,
+		RT5645_L_MUTE_SFT, RT5645_R_MUTE_SFT, 1, 1),
+	SOC_DOUBLE_TLV("HP Playback Volume", RT5645_HP_VOL,
+		RT5645_L_VOL_SFT, RT5645_R_VOL_SFT, 39, 1, out_vol_tlv),
+	/* OUTPUT Control */
+	SOC_DOUBLE("OUT Playback Switch", RT5645_LOUT1,
+		RT5645_L_MUTE_SFT, RT5645_R_MUTE_SFT, 1, 1),
+	SOC_DOUBLE("OUT Channel Switch", RT5645_LOUT1,
+		RT5645_VOL_L_SFT, RT5645_VOL_R_SFT, 1, 1),
+	SOC_DOUBLE_TLV("OUT Playback Volume", RT5645_LOUT1,
+		RT5645_L_VOL_SFT, RT5645_R_VOL_SFT, 39, 1, out_vol_tlv),
+	/* DAC Digital Volume */
+	SOC_DOUBLE("DAC2 Playback Switch", RT5645_DAC_CTRL,
+		RT5645_M_DAC_L2_VOL_SFT, RT5645_M_DAC_R2_VOL_SFT, 1, 1),
+	SOC_DOUBLE_TLV("DAC1 Playback Volume", RT5645_DAC1_DIG_VOL,
+			RT5645_L_VOL_SFT, RT5645_R_VOL_SFT,
+			175, 0, dac_vol_tlv),
+	SOC_DOUBLE_TLV("Mono DAC Playback Volume", RT5645_DAC2_DIG_VOL,
+			RT5645_L_VOL_SFT, RT5645_R_VOL_SFT,
+			175, 0, dac_vol_tlv),
+	/* IN1/IN2 Control */
+	SOC_ENUM("IN1 Mode Control",  rt5645_in1_mode_enum),
+	SOC_SINGLE_TLV("IN1 Boost", RT5645_IN1_IN2,
+		RT5645_BST_SFT1, 8, 0, bst_tlv),
+	SOC_ENUM("IN2 Mode Control", rt5645_in2_mode_enum),
+	SOC_SINGLE_TLV("IN2 Boost", RT5645_IN3,
+		RT5645_BST_SFT2, 8, 0, bst_tlv),
+	/* INL/INR Volume Control */
+	SOC_DOUBLE_TLV("IN Capture Volume", RT5645_INL1_INR1_VOL,
+			RT5645_INL_VOL_SFT, RT5645_INR_VOL_SFT,
+			31, 1, in_vol_tlv),
+	/* ADC Digital Volume Control */
+	SOC_DOUBLE("ADC Capture Switch", RT5645_STO1_ADC_DIG_VOL,
+		RT5645_L_MUTE_SFT, RT5645_R_MUTE_SFT, 1, 1),
+	SOC_DOUBLE_TLV("ADC Capture Volume", RT5645_STO1_ADC_DIG_VOL,
+			RT5645_L_VOL_SFT, RT5645_R_VOL_SFT,
+			127, 0, adc_vol_tlv),
+
+	SOC_DOUBLE_TLV("Mono ADC Capture Volume", RT5645_MONO_ADC_DIG_VOL,
+			RT5645_L_VOL_SFT, RT5645_R_VOL_SFT,
+			127, 0, adc_vol_tlv),
+
+	/* ADC Boost Volume Control */
+	SOC_DOUBLE_TLV("STO1 ADC Boost Gain", RT5645_ADC_BST_VOL1,
+			RT5645_STO1_ADC_L_BST_SFT, RT5645_STO1_ADC_R_BST_SFT,
+			3, 0, adc_bst_tlv),
+
+	SOC_DOUBLE_TLV("STO2 ADC Boost Gain", RT5645_ADC_BST_VOL1,
+			RT5645_STO2_ADC_L_BST_SFT, RT5645_STO2_ADC_R_BST_SFT,
+			3, 0, adc_bst_tlv),
+
+	/* I2S2 function select */
+	SOC_SINGLE("I2S2 Func Switch", RT5645_GPIO_CTRL1,
+				RT5645_I2S2_SEL_SFT, 1, 1),
+
+	/* TDM */
+	SOC_ENUM("TDM Adc Slot0 1 Data", rt5645_tdm_adc_slot0_1_enum),
+	SOC_ENUM("TDM Adc Slot2 3 Data", rt5645_tdm_adc_slot2_3_enum),
+	SOC_ENUM("TDM Adc Slot4 5 Data", rt5645_tdm_adc_slot4_5_enum),
+	SOC_ENUM("TDM Adc Slot6 7 Data", rt5645_tdm_adc_slot6_7_enum),
+	SOC_ENUM("TDM IF1 ADC DATA Sel", rt5645_tdm_adc_sel_enum),
+	SOC_SINGLE("TDM IF1_DAC1_L Sel", RT5645_TDM_CTRL_3, 12, 7, 0),
+	SOC_SINGLE("TDM IF1_DAC1_R Sel", RT5645_TDM_CTRL_3, 8, 7, 0),
+	SOC_SINGLE("TDM IF1_DAC2_L Sel", RT5645_TDM_CTRL_3, 4, 7, 0),
+	SOC_SINGLE("TDM IF1_DAC2_R Sel", RT5645_TDM_CTRL_3, 0, 7, 0),
+
+};
+
+/**
+ * set_dmic_clk - Set parameter of dmic.
+ *
+ * @w: DAPM widget.
+ * @kcontrol: The kcontrol of this widget.
+ * @event: Event id.
+ *
+ * Choose dmic clock between 1MHz and 3MHz.
+ * It is better for clock to approximate 3MHz.
+ */
+static int set_dmic_clk(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+	int div[] = {2, 3, 4, 6, 8, 12};
+	int idx = -EINVAL, i;
+	int rate, red, bound, temp;
+
+	rate = rt5645->lrck[rt5645->aif_pu] << 8;
+	/* red = 3000000 * 12; */
+	red = 2000000 * 12;
+	for (i = 0; i < ARRAY_SIZE(div); i++) {
+		bound = div[i] * 2000000;
+		if (rate > bound)
+			continue;
+		temp = bound - rate;
+		if (temp < red) {
+			red = temp;
+			idx = i;
+		}
+	}
+#ifdef USE_ASRC
+	idx = 5;
+#endif
+	if (idx < 0)
+		dev_err(codec->dev, "Failed to set DMIC clock\n");
+	else
+		snd_soc_update_bits(codec, RT5645_DMIC_CTRL1,
+					RT5645_DMIC_CLK_MASK,
+					idx << RT5645_DMIC_CLK_SFT);
+	return idx;
+}
+
+static int check_sysclk1_source(struct snd_soc_dapm_widget *source,
+			 struct snd_soc_dapm_widget *sink)
+{
+	unsigned int val;
+
+	val = snd_soc_read(source->codec, RT5645_GLB_CLK);
+	val &= RT5645_SCLK_SRC_MASK;
+	if (val == RT5645_SCLK_SRC_PLL1)
+		return 1;
+	else
+		return 0;
+}
+
+/* Digital Mixer */
+static const struct snd_kcontrol_new rt5645_sto1_adc_l_mix[] = {
+	SOC_DAPM_SINGLE("ADC1 Switch", RT5645_STO1_ADC_MIXER,
+			RT5645_M_ADC_L1_SFT, 1, 1),
+	SOC_DAPM_SINGLE("ADC2 Switch", RT5645_STO1_ADC_MIXER,
+			RT5645_M_ADC_L2_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_sto1_adc_r_mix[] = {
+	SOC_DAPM_SINGLE("ADC1 Switch", RT5645_STO1_ADC_MIXER,
+			RT5645_M_ADC_R1_SFT, 1, 1),
+	SOC_DAPM_SINGLE("ADC2 Switch", RT5645_STO1_ADC_MIXER,
+			RT5645_M_ADC_R2_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_mono_adc_l_mix[] = {
+	SOC_DAPM_SINGLE("ADC1 Switch", RT5645_MONO_ADC_MIXER,
+			RT5645_M_MONO_ADC_L1_SFT, 1, 1),
+	SOC_DAPM_SINGLE("ADC2 Switch", RT5645_MONO_ADC_MIXER,
+			RT5645_M_MONO_ADC_L2_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_mono_adc_r_mix[] = {
+	SOC_DAPM_SINGLE("ADC1 Switch", RT5645_MONO_ADC_MIXER,
+			RT5645_M_MONO_ADC_R1_SFT, 1, 1),
+	SOC_DAPM_SINGLE("ADC2 Switch", RT5645_MONO_ADC_MIXER,
+			RT5645_M_MONO_ADC_R2_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_dac_l_mix[] = {
+	SOC_DAPM_SINGLE("Stereo ADC Switch", RT5645_AD_DA_MIXER,
+			RT5645_M_ADCMIX_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC1 Switch", RT5645_AD_DA_MIXER,
+			RT5645_M_DAC1_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_dac_r_mix[] = {
+	SOC_DAPM_SINGLE("Stereo ADC Switch", RT5645_AD_DA_MIXER,
+			RT5645_M_ADCMIX_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC1 Switch", RT5645_AD_DA_MIXER,
+			RT5645_M_DAC1_R_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_sto_dac_l_mix[] = {
+	SOC_DAPM_SINGLE("DAC L1 Switch", RT5645_STO_DAC_MIXER,
+			RT5645_M_DAC_L1_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L2 Switch", RT5645_STO_DAC_MIXER,
+			RT5645_M_DAC_L2_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_STO_DAC_MIXER,
+			RT5645_M_DAC_R1_STO_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_sto_dac_r_mix[] = {
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_STO_DAC_MIXER,
+			RT5645_M_DAC_R1_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R2 Switch", RT5645_STO_DAC_MIXER,
+			RT5645_M_DAC_R2_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L1 Switch", RT5645_STO_DAC_MIXER,
+			RT5645_M_DAC_L1_STO_R_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_mono_dac_l_mix[] = {
+	SOC_DAPM_SINGLE("DAC L1 Switch", RT5645_MONO_DAC_MIXER,
+			RT5645_M_DAC_L1_MONO_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L2 Switch", RT5645_MONO_DAC_MIXER,
+			RT5645_M_DAC_L2_MONO_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R2 Switch", RT5645_MONO_DAC_MIXER,
+			RT5645_M_DAC_R2_MONO_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_mono_dac_r_mix[] = {
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_MONO_DAC_MIXER,
+			RT5645_M_DAC_R1_MONO_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R2 Switch", RT5645_MONO_DAC_MIXER,
+			RT5645_M_DAC_R2_MONO_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L2 Switch", RT5645_MONO_DAC_MIXER,
+			RT5645_M_DAC_L2_MONO_R_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_dig_l_mix[] = {
+	SOC_DAPM_SINGLE("Sto DAC Mix L Switch", RT5645_DIG_MIXER,
+			RT5645_M_STO_L_DAC_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L2 Switch", RT5645_DIG_MIXER,
+			RT5645_M_DAC_L2_DAC_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R2 Switch", RT5645_DIG_MIXER,
+			RT5645_M_DAC_R2_DAC_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_dig_r_mix[] = {
+	SOC_DAPM_SINGLE("Sto DAC Mix R Switch", RT5645_DIG_MIXER,
+			RT5645_M_STO_R_DAC_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R2 Switch", RT5645_DIG_MIXER,
+			RT5645_M_DAC_R2_DAC_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L2 Switch", RT5645_DIG_MIXER,
+			RT5645_M_DAC_L2_DAC_R_SFT, 1, 1),
+};
+
+/* Analog Input Mixer */
+static const struct snd_kcontrol_new rt5645_rec_l_mix[] = {
+	SOC_DAPM_SINGLE("HPOL Switch", RT5645_REC_L2_MIXER,
+			RT5645_M_HP_L_RM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INL Switch", RT5645_REC_L2_MIXER,
+			RT5645_M_IN_L_RM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST2 Switch", RT5645_REC_L2_MIXER,
+			RT5645_M_BST2_RM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST1 Switch", RT5645_REC_L2_MIXER,
+			RT5645_M_BST1_RM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("OUT MIXL Switch", RT5645_REC_L2_MIXER,
+			RT5645_M_OM_L_RM_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_rec_r_mix[] = {
+	SOC_DAPM_SINGLE("HPOR Switch", RT5645_REC_R2_MIXER,
+			RT5645_M_HP_R_RM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INR Switch", RT5645_REC_R2_MIXER,
+			RT5645_M_IN_R_RM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST2 Switch", RT5645_REC_R2_MIXER,
+			RT5645_M_BST2_RM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST1 Switch", RT5645_REC_R2_MIXER,
+			RT5645_M_BST1_RM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("OUT MIXR Switch", RT5645_REC_R2_MIXER,
+			RT5645_M_OM_R_RM_R_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_spk_l_mix[] = {
+	SOC_DAPM_SINGLE("DAC L1 Switch", RT5645_SPK_L_MIXER,
+			RT5645_M_DAC_L1_SM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L2 Switch", RT5645_SPK_L_MIXER,
+			RT5645_M_DAC_L2_SM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INL Switch", RT5645_SPK_L_MIXER,
+			RT5645_M_IN_L_SM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST1 Switch", RT5645_SPK_L_MIXER,
+			RT5645_M_BST1_L_SM_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_spk_r_mix[] = {
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_SPK_R_MIXER,
+			RT5645_M_DAC_R1_SM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R2 Switch", RT5645_SPK_R_MIXER,
+			RT5645_M_DAC_R2_SM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INR Switch", RT5645_SPK_R_MIXER,
+			RT5645_M_IN_R_SM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST2 Switch", RT5645_SPK_R_MIXER,
+			RT5645_M_BST2_R_SM_R_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_out_l_mix[] = {
+	SOC_DAPM_SINGLE("BST1 Switch", RT5645_OUT_L1_MIXER,
+			RT5645_M_BST1_OM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INL Switch", RT5645_OUT_L1_MIXER,
+			RT5645_M_IN_L_OM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L2 Switch", RT5645_OUT_L1_MIXER,
+			RT5645_M_DAC_L2_OM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L1 Switch", RT5645_OUT_L1_MIXER,
+			RT5645_M_DAC_L1_OM_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_out_r_mix[] = {
+	SOC_DAPM_SINGLE("BST2 Switch", RT5645_OUT_R1_MIXER,
+			RT5645_M_BST2_OM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INR Switch", RT5645_OUT_R1_MIXER,
+			RT5645_M_IN_R_OM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R2 Switch", RT5645_OUT_R1_MIXER,
+			RT5645_M_DAC_R2_OM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_OUT_R1_MIXER,
+			RT5645_M_DAC_R1_OM_R_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_spo_l_mix[] = {
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_SPO_MIXER,
+			RT5645_M_DAC_R1_SPM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC L1 Switch", RT5645_SPO_MIXER,
+			RT5645_M_DAC_L1_SPM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("SPKVOL R Switch", RT5645_SPO_MIXER,
+			RT5645_M_SV_R_SPM_L_SFT, 1, 1),
+	SOC_DAPM_SINGLE("SPKVOL L Switch", RT5645_SPO_MIXER,
+			RT5645_M_SV_L_SPM_L_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_spo_r_mix[] = {
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_SPO_MIXER,
+			RT5645_M_DAC_R1_SPM_R_SFT, 1, 1),
+	SOC_DAPM_SINGLE("SPKVOL R Switch", RT5645_SPO_MIXER,
+			RT5645_M_SV_R_SPM_R_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_hpo_mix[] = {
+	SOC_DAPM_SINGLE("DAC1 Switch", RT5645_HPO_MIXER,
+			RT5645_M_DAC1_HM_SFT, 1, 1),
+	SOC_DAPM_SINGLE("HPVOL Switch", RT5645_HPO_MIXER,
+			RT5645_M_HPVOL_HM_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_hpvoll_mix[] = {
+	SOC_DAPM_SINGLE("DAC1 Switch", RT5645_HPOMIXL_CTRL,
+			RT5645_M_DAC1_HV_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC2 Switch", RT5645_HPOMIXL_CTRL,
+			RT5645_M_DAC2_HV_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INL Switch", RT5645_HPOMIXL_CTRL,
+			RT5645_M_IN_HV_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST1 Switch", RT5645_HPOMIXL_CTRL,
+			RT5645_M_BST1_HV_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_hpvolr_mix[] = {
+	SOC_DAPM_SINGLE("DAC1 Switch", RT5645_HPOMIXR_CTRL,
+			RT5645_M_DAC1_HV_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC2 Switch", RT5645_HPOMIXR_CTRL,
+			RT5645_M_DAC2_HV_SFT, 1, 1),
+	SOC_DAPM_SINGLE("INR Switch", RT5645_HPOMIXR_CTRL,
+			RT5645_M_IN_HV_SFT, 1, 1),
+	SOC_DAPM_SINGLE("BST2 Switch", RT5645_HPOMIXR_CTRL,
+			RT5645_M_BST2_HV_SFT, 1, 1),
+};
+
+static const struct snd_kcontrol_new rt5645_lout_mix[] = {
+	SOC_DAPM_SINGLE("DAC L1 Switch", RT5645_LOUT_MIXER,
+			RT5645_M_DAC_L1_LM_SFT, 1, 1),
+	SOC_DAPM_SINGLE("DAC R1 Switch", RT5645_LOUT_MIXER,
+			RT5645_M_DAC_R1_LM_SFT, 1, 1),
+	SOC_DAPM_SINGLE("OUTMIX L Switch", RT5645_LOUT_MIXER,
+			RT5645_M_OV_L_LM_SFT, 1, 1),
+	SOC_DAPM_SINGLE("OUTMIX R Switch", RT5645_LOUT_MIXER,
+			RT5645_M_OV_R_LM_SFT, 1, 1),
+};
+
+/*DAC1 L/R source*/ /* MX-29 [9:8] [11:10] */
+static const char *const rt5645_dac1_src[] = {
+	"IF1 DAC", "IF2 DAC", "IF3 DAC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_dac1l_enum, RT5645_AD_DA_MIXER,
+	RT5645_DAC1_L_SEL_SFT, rt5645_dac1_src);
+
+static const struct snd_kcontrol_new rt5645_dac1l_mux =
+	SOC_DAPM_ENUM("DAC1 L source", rt5645_dac1l_enum);
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_dac1r_enum, RT5645_AD_DA_MIXER,
+	RT5645_DAC1_R_SEL_SFT, rt5645_dac1_src);
+
+static const struct snd_kcontrol_new rt5645_dac1r_mux =
+	SOC_DAPM_ENUM("DAC1 R source", rt5645_dac1r_enum);
+
+/*DAC2 L/R source*/ /* MX-1B [6:4] [2:0] */
+static const char *const rt5645_dac12_src[] = {
+	"IF1 DAC", "IF2 DAC", "IF3 DAC", "Mono ADC", "VAD_ADC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_dac2l_enum, RT5645_DAC_CTRL,
+	RT5645_DAC2_L_SEL_SFT, rt5645_dac12_src);
+
+static const struct snd_kcontrol_new rt5645_dac_l2_mux =
+	SOC_DAPM_ENUM("DAC2 L source", rt5645_dac2l_enum);
+
+static const char *const rt5645_dacr2_src[] = {
+	"IF1 DAC", "IF2 DAC", "IF3 DAC", "Mono ADC", "Haptic"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_dac2r_enum, RT5645_DAC_CTRL,
+	RT5645_DAC2_R_SEL_SFT, rt5645_dacr2_src);
+
+static const struct snd_kcontrol_new rt5645_dac_r2_mux =
+	SOC_DAPM_ENUM("DAC2 R source", rt5645_dac2r_enum);
+
+
+/* INL/R source */
+static const char *const rt5645_inl_src[] = {
+	"IN2P", "MonoP"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_inl_enum, RT5645_INL1_INR1_VOL,
+	RT5645_INL_SEL_SFT, rt5645_inl_src);
+
+static const struct snd_kcontrol_new rt5645_inl_mux =
+	SOC_DAPM_ENUM("INL source", rt5645_inl_enum);
+
+static const char *const rt5645_inr_src[] = {
+	"IN2N", "MonoN"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_inr_enum, RT5645_INL1_INR1_VOL,
+	RT5645_INR_SEL_SFT, rt5645_inr_src);
+
+static const struct snd_kcontrol_new rt5645_inr_mux =
+	SOC_DAPM_ENUM("INR source", rt5645_inr_enum);
+
+/* Stereo1 ADC source */
+/* MX-27 [12] */
+static const char *const rt5645_stereo_adc1_src[] = {
+	"DAC MIX", "ADC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_stereo1_adc1_enum, RT5645_STO1_ADC_MIXER,
+	RT5645_ADC_1_SRC_SFT, rt5645_stereo_adc1_src);
+
+static const struct snd_kcontrol_new rt5645_sto_adc_l1_mux =
+	SOC_DAPM_ENUM("Stereo1 ADC L1 source", rt5645_stereo1_adc1_enum);
+
+static const struct snd_kcontrol_new rt5645_sto_adc_r1_mux =
+	SOC_DAPM_ENUM("Stereo1 ADC R1 source", rt5645_stereo1_adc1_enum);
+
+/* MX-27 [11] */
+static const char *const rt5645_stereo_adc2_src[] = {
+	"DAC MIX", "DMIC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_stereo1_adc2_enum, RT5645_STO1_ADC_MIXER,
+	RT5645_ADC_2_SRC_SFT, rt5645_stereo_adc2_src);
+
+static const struct snd_kcontrol_new rt5645_sto_adc_l2_mux =
+	SOC_DAPM_ENUM("Stereo1 ADC L2 source", rt5645_stereo1_adc2_enum);
+
+static const struct snd_kcontrol_new rt5645_sto_adc_r2_mux =
+	SOC_DAPM_ENUM("Stereo1 ADC R2 source", rt5645_stereo1_adc2_enum);
+
+/* MX-27 [8] */
+static const char *const rt5645_stereo_dmic_src[] = {
+	"DMIC1", "DMIC2"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_stereo1_dmic_enum, RT5645_STO1_ADC_MIXER,
+	RT5645_DMIC_SRC_SFT, rt5645_stereo_dmic_src);
+
+static const struct snd_kcontrol_new rt5645_sto1_dmic_mux =
+	SOC_DAPM_ENUM("Stereo1 DMIC source", rt5645_stereo1_dmic_enum);
+
+/* Mono ADC source */
+/* MX-28 [12] */
+static const char *const rt5645_mono_adc_l1_src[] = {
+	"Mono DAC MIXL", "ADC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_mono_adc_l1_enum, RT5645_MONO_ADC_MIXER,
+	RT5645_MONO_ADC_L1_SRC_SFT, rt5645_mono_adc_l1_src);
+
+static const struct snd_kcontrol_new rt5645_mono_adc_l1_mux =
+	SOC_DAPM_ENUM("Mono ADC1 left source", rt5645_mono_adc_l1_enum);
+/* MX-28 [11] */
+static const char *const rt5645_mono_adc_l2_src[] = {
+	"Mono DAC MIXL", "DMIC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_mono_adc_l2_enum, RT5645_MONO_ADC_MIXER,
+	RT5645_MONO_ADC_L2_SRC_SFT, rt5645_mono_adc_l2_src);
+
+static const struct snd_kcontrol_new rt5645_mono_adc_l2_mux =
+	SOC_DAPM_ENUM("Mono ADC2 left source", rt5645_mono_adc_l2_enum);
+
+/* MX-28 [8] */
+static const char *const rt5645_mono_dmic_src[] = {
+	"DMIC1", "DMIC2"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_mono_dmic_l_enum, RT5645_MONO_ADC_MIXER,
+	RT5645_MONO_DMIC_L_SRC_SFT, rt5645_mono_dmic_src);
+
+static const struct snd_kcontrol_new rt5645_mono_dmic_l_mux =
+	SOC_DAPM_ENUM("Mono DMIC left source", rt5645_mono_dmic_l_enum);
+/* MX-28 [1:0] */
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_mono_dmic_r_enum, RT5645_MONO_ADC_MIXER,
+	RT5645_MONO_DMIC_R_SRC_SFT, rt5645_mono_dmic_src);
+
+static const struct snd_kcontrol_new rt5645_mono_dmic_r_mux =
+	SOC_DAPM_ENUM("Mono DMIC Right source", rt5645_mono_dmic_r_enum);
+/* MX-28 [4] */
+static const char *const rt5645_mono_adc_r1_src[] = {
+	"Mono DAC MIXR", "ADC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_mono_adc_r1_enum, RT5645_MONO_ADC_MIXER,
+	RT5645_MONO_ADC_R1_SRC_SFT, rt5645_mono_adc_r1_src);
+
+static const struct snd_kcontrol_new rt5645_mono_adc_r1_mux =
+	SOC_DAPM_ENUM("Mono ADC1 right source", rt5645_mono_adc_r1_enum);
+/* MX-28 [3] */
+static const char *const rt5645_mono_adc_r2_src[] = {
+	"Mono DAC MIXR", "DMIC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_mono_adc_r2_enum, RT5645_MONO_ADC_MIXER,
+	RT5645_MONO_ADC_R2_SRC_SFT, rt5645_mono_adc_r2_src);
+
+static const struct snd_kcontrol_new rt5645_mono_adc_r2_mux =
+	SOC_DAPM_ENUM("Mono ADC2 right source", rt5645_mono_adc_r2_enum);
+
+/* MX-77 [9:8] */
+static const char *const rt5645_if1_adc_in_src[] = {
+	"IF_ADC1", "IF_ADC2", "VAD_ADC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_if1_adc_in_enum, RT5645_TDM_CTRL_1,
+	RT5645_IF1_ADC_IN_SFT, rt5645_if1_adc_in_src);
+
+static const struct snd_kcontrol_new rt5645_if1_adc_in_mux =
+	SOC_DAPM_ENUM("IF1 ADC IN source", rt5645_if1_adc_in_enum);
+
+/* MX-2F [13:12] */
+static const char *const rt5645_if2_adc_in_src[] = {
+	"IF_ADC1", "IF_ADC2", "VAD_ADC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_if2_adc_in_enum, RT5645_DIG_INF1_DATA,
+	RT5645_IF2_ADC_IN_SFT, rt5645_if2_adc_in_src);
+
+static const struct snd_kcontrol_new rt5645_if2_adc_in_mux =
+	SOC_DAPM_ENUM("IF2 ADC IN source", rt5645_if2_adc_in_enum);
+
+/* MX-2F [1:0] */
+static const char *const rt5645_if3_adc_in_src[] = {
+	"IF_ADC1", "IF_ADC2", "VAD_ADC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_if3_adc_in_enum, RT5645_DIG_INF1_DATA,
+	RT5645_IF3_ADC_IN_SFT, rt5645_if3_adc_in_src);
+
+static const struct snd_kcontrol_new rt5645_if3_adc_in_mux =
+	SOC_DAPM_ENUM("IF3 ADC IN source", rt5645_if3_adc_in_enum);
+
+/* MX-31 [15] [13] [11] [9] */
+static const char *const rt5645_pdm_src[] = {
+	"Mono DAC", "Stereo DAC"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_pdm1_l_enum, RT5645_PDM_OUT_CTRL,
+	RT5645_PDM1_L_SFT, rt5645_pdm_src);
+
+static const struct snd_kcontrol_new rt5645_pdm1_l_mux =
+	SOC_DAPM_ENUM("PDM1 L source", rt5645_pdm1_l_enum);
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_pdm1_r_enum, RT5645_PDM_OUT_CTRL,
+	RT5645_PDM1_R_SFT, rt5645_pdm_src);
+
+static const struct snd_kcontrol_new rt5645_pdm1_r_mux =
+	SOC_DAPM_ENUM("PDM1 R source", rt5645_pdm1_r_enum);
+
+/* MX-9D [9:8] */
+static const char *const rt5645_vad_adc_src[] = {
+	"Sto1 ADC L", "Mono ADC L", "Mono ADC R"
+};
+
+static const SOC_ENUM_SINGLE_DECL(
+	rt5645_vad_adc_enum, RT5645_VAD_CTRL4,
+	RT5645_VAD_SEL_SFT, rt5645_vad_adc_src);
+
+static const struct snd_kcontrol_new rt5645_vad_adc_mux =
+	SOC_DAPM_ENUM("VAD ADC source", rt5645_vad_adc_enum);
+
+static const struct snd_kcontrol_new spk_l_vol_control =
+	SOC_DAPM_SINGLE("Switch", RT5645_SPK_VOL,
+		RT5645_VOL_L_SFT, 1, 1);
+
+static const struct snd_kcontrol_new spk_r_vol_control =
+	SOC_DAPM_SINGLE("Switch", RT5645_SPK_VOL,
+		RT5645_VOL_R_SFT, 1, 1);
+
+static const struct snd_kcontrol_new hp_l_vol_control =
+	SOC_DAPM_SINGLE("Switch", RT5645_HP_VOL,
+		RT5645_VOL_L_SFT, 1, 1);
+
+static const struct snd_kcontrol_new hp_r_vol_control =
+	SOC_DAPM_SINGLE("Switch", RT5645_HP_VOL,
+		RT5645_VOL_R_SFT, 1, 1);
+
+static int rt5645_adc_clk_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		rt5645_index_update_bits(codec,
+			RT5645_CHOP_DAC_ADC, 0x1000, 0x1000);
+		break;
+
+	case SND_SOC_DAPM_POST_PMD:
+		rt5645_index_update_bits(codec,
+			RT5645_CHOP_DAC_ADC, 0x1000, 0x0000);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_sto1_adcl_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_STO1_ADC_DIG_VOL,
+			RT5645_L_MUTE, 0);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_STO1_ADC_DIG_VOL,
+			RT5645_L_MUTE,
+			RT5645_L_MUTE);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_sto1_adcr_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_STO1_ADC_DIG_VOL,
+			RT5645_R_MUTE, 0);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_STO1_ADC_DIG_VOL,
+			RT5645_R_MUTE,
+			RT5645_R_MUTE);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_mono_adcl_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_MONO_ADC_DIG_VOL,
+			RT5645_L_MUTE, 0);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_MONO_ADC_DIG_VOL,
+			RT5645_L_MUTE,
+			RT5645_L_MUTE);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_mono_adcr_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_MONO_ADC_DIG_VOL,
+			RT5645_R_MUTE, 0);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_MONO_ADC_DIG_VOL,
+			RT5645_R_MUTE,
+			RT5645_R_MUTE);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static void hp_amp_power(struct snd_soc_codec *codec, int on)
+{
+	static int hp_amp_power_count;
+
+	if (on) {
+		if (hp_amp_power_count <= 0) {
+			/* depop parameters */
+			snd_soc_update_bits(codec, RT5645_DEPOP_M2,
+				RT5645_DEPOP_MASK, RT5645_DEPOP_MAN);
+			snd_soc_write(codec, RT5645_DEPOP_M1, 0x000d);
+			rt5645_index_write(codec, RT5645_HP_DCC_INT1, 0x9f01);
+			mdelay(150);
+			/* headphone amp power on */
+			snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+				RT5645_PWR_FV1 | RT5645_PWR_FV2 , 0);
+			snd_soc_update_bits(codec, RT5645_PWR_VOL,
+				RT5645_PWR_HV_L | RT5645_PWR_HV_R,
+				RT5645_PWR_HV_L | RT5645_PWR_HV_R);
+			snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+				RT5645_PWR_HP_L | RT5645_PWR_HP_R
+				| RT5645_PWR_HA,
+				RT5645_PWR_HP_L | RT5645_PWR_HP_R
+				| RT5645_PWR_HA);
+			mdelay(5);
+			snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+				RT5645_PWR_FV1 | RT5645_PWR_FV2,
+				RT5645_PWR_FV1 | RT5645_PWR_FV2);
+
+			snd_soc_update_bits(codec, RT5645_HP_CALIB_AMP_DET,
+				RT5645_HPD_PS_MASK, RT5645_HPD_PS_EN);
+			snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+				RT5645_HP_CO_MASK | RT5645_HP_SG_MASK,
+				RT5645_HP_CO_EN | RT5645_HP_SG_EN);
+
+			rt5645_index_write(codec, 0x14, 0x1aaa);
+			rt5645_index_write(codec, 0x24, 0x0430);
+		}
+		hp_amp_power_count++;
+	} else {
+		hp_amp_power_count--;
+		if (hp_amp_power_count <= 0) {
+			snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+				RT5645_HP_SG_MASK | RT5645_HP_L_SMT_MASK |
+				RT5645_HP_R_SMT_MASK, RT5645_HP_SG_DIS |
+				RT5645_HP_L_SMT_DIS | RT5645_HP_R_SMT_DIS);
+			/* headphone amp power down */
+			/*
+			snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+				RT5645_SMT_TRIG_MASK | RT5645_HP_CD_PD_MASK |
+				RT5645_HP_CO_MASK | RT5645_HP_CP_MASK |
+				RT5645_HP_SG_MASK | RT5645_HP_CB_MASK,
+				RT5645_SMT_TRIG_DIS | RT5645_HP_CD_PD_EN |
+				RT5645_HP_CO_DIS | RT5645_HP_CP_PD |
+				RT5645_HP_SG_EN | RT5645_HP_CB_PD);
+			*/
+			snd_soc_write(codec, RT5645_DEPOP_M1, 0x0000);
+			snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+				RT5645_PWR_HP_L | RT5645_PWR_HP_R
+				| RT5645_PWR_HA,
+				0);
+		}
+	}
+}
+
+static void rt5645_pmu_depop(struct snd_soc_codec *codec)
+{
+	hp_amp_power(codec, 1);
+	/* headphone unmute sequence */
+	snd_soc_update_bits(codec, RT5645_DEPOP_M3,
+		RT5645_CP_FQ1_MASK | RT5645_CP_FQ2_MASK | RT5645_CP_FQ3_MASK,
+		(RT5645_CP_FQ_192_KHZ << RT5645_CP_FQ1_SFT) |
+		(RT5645_CP_FQ_12_KHZ << RT5645_CP_FQ2_SFT) |
+		(RT5645_CP_FQ_192_KHZ << RT5645_CP_FQ3_SFT));
+	rt5645_index_write(codec, RT5645_MAMP_INT_REG2, 0xfc00);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_SMT_TRIG_MASK, RT5645_SMT_TRIG_EN);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_RSTN_MASK, RT5645_RSTN_EN);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_RSTN_MASK | RT5645_HP_L_SMT_MASK | RT5645_HP_R_SMT_MASK,
+		RT5645_RSTN_DIS | RT5645_HP_L_SMT_EN | RT5645_HP_R_SMT_EN);
+	snd_soc_update_bits(codec, RT5645_HP_VOL,
+		RT5645_L_MUTE | RT5645_R_MUTE, 0);
+	msleep(40);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_HP_SG_MASK | RT5645_HP_L_SMT_MASK |
+		RT5645_HP_R_SMT_MASK, RT5645_HP_SG_DIS |
+		RT5645_HP_L_SMT_DIS | RT5645_HP_R_SMT_DIS);
+
+}
+
+static void rt5645_pmd_depop(struct snd_soc_codec *codec)
+{
+	/* headphone mute sequence */
+	snd_soc_update_bits(codec, RT5645_DEPOP_M3,
+		RT5645_CP_FQ1_MASK | RT5645_CP_FQ2_MASK | RT5645_CP_FQ3_MASK,
+		(RT5645_CP_FQ_96_KHZ << RT5645_CP_FQ1_SFT) |
+		(RT5645_CP_FQ_12_KHZ << RT5645_CP_FQ2_SFT) |
+		(RT5645_CP_FQ_96_KHZ << RT5645_CP_FQ3_SFT));
+	rt5645_index_write(codec, RT5645_MAMP_INT_REG2, 0xfc00);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_HP_SG_MASK, RT5645_HP_SG_EN);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_RSTP_MASK, RT5645_RSTP_EN);
+	snd_soc_update_bits(codec, RT5645_DEPOP_M1,
+		RT5645_RSTP_MASK | RT5645_HP_L_SMT_MASK |
+		RT5645_HP_R_SMT_MASK, RT5645_RSTP_DIS |
+		RT5645_HP_L_SMT_EN | RT5645_HP_R_SMT_EN);
+
+	snd_soc_update_bits(codec, RT5645_HP_VOL,
+		RT5645_L_MUTE | RT5645_R_MUTE, RT5645_L_MUTE | RT5645_R_MUTE);
+	msleep(30);
+
+	hp_amp_power(codec, 0);
+}
+
+static int rt5645_hp_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		rt5645_pmu_depop(codec);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		rt5645_pmd_depop(codec);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_spk_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		rt5645_index_write(codec, 0x1c, 0xfd20);
+		rt5645_index_write(codec, 0x20, 0x611f);
+		rt5645_index_write(codec, 0x21, 0x4040);
+		rt5645_index_write(codec, 0x23, 0x0004);
+
+		snd_soc_update_bits(codec, RT5645_PWR_DIG1,
+			RT5645_PWR_CLS_D | RT5645_PWR_CLS_D_R
+			| RT5645_PWR_CLS_D_L,
+			RT5645_PWR_CLS_D | RT5645_PWR_CLS_D_R
+			| RT5645_PWR_CLS_D_L);
+		snd_soc_update_bits(codec, RT5645_GEN_CTRL3, 0x0200, 0x0200);
+		snd_soc_update_bits(codec, RT5645_SPK_VOL,
+			RT5645_L_MUTE | RT5645_R_MUTE, 0);
+	break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_SPK_VOL,
+			RT5645_L_MUTE | RT5645_R_MUTE,
+			RT5645_L_MUTE | RT5645_R_MUTE);
+		snd_soc_update_bits(codec, RT5645_GEN_CTRL3, 0x0200, 0x0);
+		snd_soc_update_bits(codec, RT5645_PWR_DIG1,
+			RT5645_PWR_CLS_D | RT5645_PWR_CLS_D_R
+			| RT5645_PWR_CLS_D_L, 0);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_lout_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		hp_amp_power(codec, 1);
+		snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+			RT5645_PWR_LM, RT5645_PWR_LM);
+		snd_soc_update_bits(codec, RT5645_LOUT1,
+			RT5645_L_MUTE | RT5645_R_MUTE, 0);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_LOUT1,
+			RT5645_L_MUTE | RT5645_R_MUTE,
+			RT5645_L_MUTE | RT5645_R_MUTE);
+		snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+			RT5645_PWR_LM, 0);
+		hp_amp_power(codec, 0);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_bst2_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_PWR_ANLG2,
+			RT5645_PWR_BST2_P, RT5645_PWR_BST2_P);
+		snd_soc_update_bits(codec, RT5645_PWR_ANLG2,
+			RT5645_PWR_MB1, RT5645_PWR_MB1);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_PWR_ANLG2,
+			RT5645_PWR_BST2_P, 0);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_pdm1_l_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_PDM_OUT_CTRL,
+			RT5645_M_PDM1_L, 0);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_PDM_OUT_CTRL,
+			RT5645_M_PDM1_L, RT5645_M_PDM1_L);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_pdm1_r_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_PDM_OUT_CTRL,
+			RT5645_M_PDM1_R, 0);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_PDM_OUT_CTRL,
+			RT5645_M_PDM1_R, RT5645_M_PDM1_R);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_dac_l_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		rt5645_update_eqmode(codec, EQ_CH_DACL, rt5645->eq_mode);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		rt5645_update_eqmode(codec, EQ_CH_DACL, NORMAL);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_dac_r_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		rt5645_update_eqmode(codec, EQ_CH_DACR, rt5645->eq_mode);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		rt5645_update_eqmode(codec, EQ_CH_DACR, NORMAL);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_hpvol_l_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_PWR_MIXER,
+			RT5645_PWR_HM_L, RT5645_PWR_HM_L);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_PWR_MIXER,
+			RT5645_PWR_HM_L, 0);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_hpvol_r_event(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_update_bits(codec, RT5645_PWR_MIXER,
+			RT5645_PWR_HM_R, RT5645_PWR_HM_R);
+		break;
+
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_update_bits(codec, RT5645_PWR_MIXER,
+			RT5645_PWR_HM_R, 0);
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int rt5645_asrc_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+
+	pr_debug("%s(): event %d\n", __func__, event);
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		snd_soc_write(w->codec, RT5645_ASRC_1, 0xffff);
+		snd_soc_write(w->codec, RT5645_ASRC_2, 0x1221);
+		snd_soc_write(w->codec, RT5645_ASRC_3, 0x0022);
+		snd_soc_write(w->codec, 0x87, 0x23d7);
+		snd_soc_write(w->codec, 0x88, 0x23d7);
+
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_soc_write(w->codec, RT5645_ASRC_1, 0);
+		snd_soc_write(w->codec, RT5645_ASRC_2, 0);
+		snd_soc_write(w->codec, RT5645_ASRC_3, 0);
+		break;
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget rt5645_dapm_widgets[] = {
+	SND_SOC_DAPM_SUPPLY("ASRC enable", SND_SOC_NOPM, 0, 0,
+		rt5645_asrc_event, SND_SOC_DAPM_POST_PMU
+		| SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_SUPPLY("LDO2", RT5645_PWR_MIXER,
+		RT5645_PWR_LDO2_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("PLL1", RT5645_PWR_ANLG2,
+		RT5645_PWR_PLL_BIT, 0, NULL, 0),
+	/*def JD1_FUNC*/
+	SND_SOC_DAPM_SUPPLY("Mic Det Power", RT5645_PWR_VOL,
+		RT5645_PWR_MIC_DET_BIT, 0, NULL, 0),
+#if 0
+	SND_SOC_DAPM_SUPPLY("Mic Det Power", SND_SOC_NOPM,
+		0, 0, NULL, 0),
+#endif
+	SND_SOC_DAPM_SUPPLY("JD Power", SND_SOC_NOPM,
+		0, 0, NULL, 0),
+
+	/* Input Side */
+	/* micbias */
+	SND_SOC_DAPM_SUPPLY("micbias1", RT5645_PWR_ANLG2,
+			RT5645_PWR_MB1_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("micbias2", RT5645_PWR_ANLG2,
+			RT5645_PWR_MB2_BIT, 0, NULL, 0),
+	/* Input Lines */
+	SND_SOC_DAPM_INPUT("DMIC L1"),
+	SND_SOC_DAPM_INPUT("DMIC R1"),
+	SND_SOC_DAPM_INPUT("DMIC L2"),
+	SND_SOC_DAPM_INPUT("DMIC R2"),
+
+	SND_SOC_DAPM_INPUT("IN1P"),
+	SND_SOC_DAPM_INPUT("IN1N"),
+	SND_SOC_DAPM_INPUT("IN2P"),
+	SND_SOC_DAPM_INPUT("IN2N"),
+
+	SND_SOC_DAPM_INPUT("Haptic Generator"),
+
+	SND_SOC_DAPM_PGA("DMIC1", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DMIC2", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("DMIC CLK", SND_SOC_NOPM, 0, 0,
+		set_dmic_clk, SND_SOC_DAPM_PRE_PMU),
+	SND_SOC_DAPM_SUPPLY("DMIC1 Power", RT5645_DMIC_CTRL1,
+		RT5645_DMIC_1_EN_SFT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DMIC2 Power", RT5645_DMIC_CTRL1,
+		RT5645_DMIC_2_EN_SFT, 0, NULL, 0),
+	/* Boost */
+	SND_SOC_DAPM_PGA("BST1", RT5645_PWR_ANLG2,
+		RT5645_PWR_BST1_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA_E("BST2", RT5645_PWR_ANLG2,
+		RT5645_PWR_BST2_BIT, 0, NULL, 0, rt5645_bst2_event,
+		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
+	/* Input Volume */
+	SND_SOC_DAPM_PGA("INL VOL", RT5645_PWR_VOL,
+		RT5645_PWR_IN_L_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("INR VOL", RT5645_PWR_VOL,
+		RT5645_PWR_IN_R_BIT, 0, NULL, 0),
+	/* IN Mux */
+	SND_SOC_DAPM_MUX("INL Mux", SND_SOC_NOPM, 0, 0, &rt5645_inl_mux),
+	SND_SOC_DAPM_MUX("INR Mux", SND_SOC_NOPM, 0, 0, &rt5645_inr_mux),
+	/* REC Mixer */
+	SND_SOC_DAPM_MIXER("RECMIXL", RT5645_PWR_MIXER, RT5645_PWR_RM_L_BIT,
+			0, rt5645_rec_l_mix, ARRAY_SIZE(rt5645_rec_l_mix)),
+	SND_SOC_DAPM_MIXER("RECMIXR", RT5645_PWR_MIXER, RT5645_PWR_RM_R_BIT,
+			0, rt5645_rec_r_mix, ARRAY_SIZE(rt5645_rec_r_mix)),
+	/* ADCs */
+	SND_SOC_DAPM_ADC("ADC L", NULL, SND_SOC_NOPM,
+		0, 0),
+	SND_SOC_DAPM_ADC("ADC R", NULL, SND_SOC_NOPM,
+		0, 0),
+
+	SND_SOC_DAPM_SUPPLY("ADC L power", RT5645_PWR_DIG1,
+			RT5645_PWR_ADC_L_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC R power", RT5645_PWR_DIG1,
+			RT5645_PWR_ADC_R_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC clock", SND_SOC_NOPM,
+			0, 0, rt5645_adc_clk_event,
+			SND_SOC_DAPM_POST_PMD |
+			SND_SOC_DAPM_POST_PMU),
+	/* ADC Mux */
+	SND_SOC_DAPM_MUX("Stereo1 DMIC Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_sto1_dmic_mux),
+	SND_SOC_DAPM_MUX("Stereo1 ADC L2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_sto_adc_l2_mux),
+	SND_SOC_DAPM_MUX("Stereo1 ADC R2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_sto_adc_r2_mux),
+	SND_SOC_DAPM_MUX("Stereo1 ADC L1 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_sto_adc_l1_mux),
+	SND_SOC_DAPM_MUX("Stereo1 ADC R1 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_sto_adc_r1_mux),
+	SND_SOC_DAPM_MUX("Mono DMIC L Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_mono_dmic_l_mux),
+	SND_SOC_DAPM_MUX("Mono DMIC R Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_mono_dmic_r_mux),
+	SND_SOC_DAPM_MUX("Mono ADC L2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_mono_adc_l2_mux),
+	SND_SOC_DAPM_MUX("Mono ADC L1 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_mono_adc_l1_mux),
+	SND_SOC_DAPM_MUX("Mono ADC R1 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_mono_adc_r1_mux),
+	SND_SOC_DAPM_MUX("Mono ADC R2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_mono_adc_r2_mux),
+	/* ADC Mixer */
+
+	SND_SOC_DAPM_SUPPLY_S("adc stereo1 filter", 1, RT5645_PWR_DIG2,
+		RT5645_PWR_ADC_S1F_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY_S("adc stereo2 filter", 1, RT5645_PWR_DIG2,
+		RT5645_PWR_ADC_S2F_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER_E("Sto1 ADC MIXL", SND_SOC_NOPM, 0, 0,
+		rt5645_sto1_adc_l_mix, ARRAY_SIZE(rt5645_sto1_adc_l_mix),
+		rt5645_sto1_adcl_event,	SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_MIXER_E("Sto1 ADC MIXR", SND_SOC_NOPM, 0, 0,
+		rt5645_sto1_adc_r_mix, ARRAY_SIZE(rt5645_sto1_adc_r_mix),
+		rt5645_sto1_adcr_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_SUPPLY_S("adc mono left filter", 1, RT5645_PWR_DIG2,
+		RT5645_PWR_ADC_MF_L_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER_E("Mono ADC MIXL", SND_SOC_NOPM, 0, 0,
+		rt5645_mono_adc_l_mix, ARRAY_SIZE(rt5645_mono_adc_l_mix),
+		rt5645_mono_adcl_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_SUPPLY_S("adc mono right filter", 1, RT5645_PWR_DIG2,
+		RT5645_PWR_ADC_MF_R_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER_E("Mono ADC MIXR", SND_SOC_NOPM, 0, 0,
+		rt5645_mono_adc_r_mix, ARRAY_SIZE(rt5645_mono_adc_r_mix),
+		rt5645_mono_adcr_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+
+	/* ADC PGA */
+	SND_SOC_DAPM_PGA("Stereo1 ADC MIXL", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Stereo1 ADC MIXR", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Sto2 ADC LR MIX", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("VAD_ADC", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF_ADC1", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF_ADC2", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1_ADC1", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1_ADC2", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1_ADC3", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1_ADC4", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	/* IF2 3 4 Mux */
+	SND_SOC_DAPM_MUX("IF1 ADC Mux", SND_SOC_NOPM,
+		0, 0, &rt5645_if1_adc_in_mux),
+	SND_SOC_DAPM_MUX("IF2 ADC Mux", SND_SOC_NOPM,
+		0, 0, &rt5645_if2_adc_in_mux),
+	SND_SOC_DAPM_MUX("IF3 ADC Mux", SND_SOC_NOPM,
+		0, 0, &rt5645_if3_adc_in_mux),
+
+	/* Digital Interface */
+	SND_SOC_DAPM_SUPPLY("I2S1", RT5645_PWR_DIG1,
+		RT5645_PWR_I2S1_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 DAC1", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 DAC2", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 DAC1 L", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 DAC1 R", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 DAC2 L", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 DAC2 R", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 ADC", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 ADC L", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF1 ADC R", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("I2S2", RT5645_PWR_DIG1,
+		RT5645_PWR_I2S2_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF2 DAC", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF2 DAC L", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF2 DAC R", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("IF2 ADC", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	/* Digital Interface Select */
+	SND_SOC_DAPM_MUX("VAD ADC Mux", SND_SOC_NOPM,
+		0, 0, &rt5645_vad_adc_mux),
+
+	/* Audio Interface */
+	SND_SOC_DAPM_AIF_IN("AIF1RX", "AIF1 Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("AIF1TX", "AIF1 Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("AIF2RX", "AIF2 Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("AIF2TX", "AIF2 Capture", 0, SND_SOC_NOPM, 0, 0),
+
+	/* Audio DSP */
+	SND_SOC_DAPM_PGA("Audio DSP", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	/* Output Side */
+	/* DAC mixer before sound effect  */
+	SND_SOC_DAPM_MIXER_E("DAC1 MIXL", SND_SOC_NOPM, 0, 0,
+		rt5645_dac_l_mix, ARRAY_SIZE(rt5645_dac_l_mix),
+		rt5645_dac_l_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_MIXER_E("DAC1 MIXR", SND_SOC_NOPM, 0, 0,
+		rt5645_dac_r_mix, ARRAY_SIZE(rt5645_dac_r_mix),
+		rt5645_dac_r_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_PGA("DAC MIX", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	/* DAC2 channel Mux */
+	SND_SOC_DAPM_MUX("DAC L2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_dac_l2_mux),
+	SND_SOC_DAPM_MUX("DAC R2 Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_dac_r2_mux),
+	SND_SOC_DAPM_PGA("DAC L2 Volume", RT5645_PWR_DIG1,
+			RT5645_PWR_DAC_L2_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DAC R2 Volume", RT5645_PWR_DIG1,
+			RT5645_PWR_DAC_R2_BIT, 0, NULL, 0),
+
+	SND_SOC_DAPM_MUX("DAC1 L Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_dac1l_mux),
+	SND_SOC_DAPM_MUX("DAC1 R Mux", SND_SOC_NOPM, 0, 0,
+				&rt5645_dac1r_mux),
+
+	/* DAC Mixer */
+	SND_SOC_DAPM_SUPPLY_S("dac stereo1 filter", 1, RT5645_PWR_DIG2,
+		RT5645_PWR_DAC_S1F_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY_S("dac mono left filter", 1, RT5645_PWR_DIG2,
+		RT5645_PWR_DAC_MF_L_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY_S("dac mono right filter", 1, RT5645_PWR_DIG2,
+		RT5645_PWR_DAC_MF_R_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_MIXER("Stereo DAC MIXL", SND_SOC_NOPM, 0, 0,
+		rt5645_sto_dac_l_mix, ARRAY_SIZE(rt5645_sto_dac_l_mix)),
+	SND_SOC_DAPM_MIXER("Stereo DAC MIXR", SND_SOC_NOPM, 0, 0,
+		rt5645_sto_dac_r_mix, ARRAY_SIZE(rt5645_sto_dac_r_mix)),
+	SND_SOC_DAPM_MIXER("Mono DAC MIXL", SND_SOC_NOPM, 0, 0,
+		rt5645_mono_dac_l_mix, ARRAY_SIZE(rt5645_mono_dac_l_mix)),
+	SND_SOC_DAPM_MIXER("Mono DAC MIXR", SND_SOC_NOPM, 0, 0,
+		rt5645_mono_dac_r_mix, ARRAY_SIZE(rt5645_mono_dac_r_mix)),
+	SND_SOC_DAPM_MIXER("DAC MIXL", SND_SOC_NOPM, 0, 0,
+		rt5645_dig_l_mix, ARRAY_SIZE(rt5645_dig_l_mix)),
+	SND_SOC_DAPM_MIXER("DAC MIXR", SND_SOC_NOPM, 0, 0,
+		rt5645_dig_r_mix, ARRAY_SIZE(rt5645_dig_r_mix)),
+
+	/* DACs */
+	SND_SOC_DAPM_DAC("DAC L1", NULL, RT5645_PWR_DIG1,
+			RT5645_PWR_DAC_L1_BIT, 0),
+	SND_SOC_DAPM_DAC("DAC L2", NULL, RT5645_PWR_DIG1,
+			RT5645_PWR_DAC_L2_BIT, 0),
+	SND_SOC_DAPM_DAC("DAC R1", NULL, RT5645_PWR_DIG1,
+			RT5645_PWR_DAC_R1_BIT, 0),
+	SND_SOC_DAPM_DAC("DAC R2", NULL, RT5645_PWR_DIG1,
+			RT5645_PWR_DAC_R2_BIT, 0),
+	/* OUT Mixer */
+	SND_SOC_DAPM_MIXER("SPK MIXL", RT5645_PWR_MIXER, RT5645_PWR_SM_L_BIT,
+		0, rt5645_spk_l_mix, ARRAY_SIZE(rt5645_spk_l_mix)),
+	SND_SOC_DAPM_MIXER("SPK MIXR", RT5645_PWR_MIXER, RT5645_PWR_SM_R_BIT,
+		0, rt5645_spk_r_mix, ARRAY_SIZE(rt5645_spk_r_mix)),
+	SND_SOC_DAPM_MIXER("OUT MIXL", RT5645_PWR_MIXER, RT5645_PWR_OM_L_BIT,
+		0, rt5645_out_l_mix, ARRAY_SIZE(rt5645_out_l_mix)),
+	SND_SOC_DAPM_MIXER("OUT MIXR", RT5645_PWR_MIXER, RT5645_PWR_OM_R_BIT,
+		0, rt5645_out_r_mix, ARRAY_SIZE(rt5645_out_r_mix)),
+	/* Ouput Volume */
+	SND_SOC_DAPM_SWITCH("SPKVOL L", RT5645_PWR_VOL,
+		RT5645_PWR_SV_L_BIT, 0, &spk_l_vol_control),
+	SND_SOC_DAPM_SWITCH("SPKVOL R", RT5645_PWR_VOL,
+		RT5645_PWR_SV_R_BIT, 0,	&spk_r_vol_control),
+	SND_SOC_DAPM_MIXER_E("HPOVOL MIXL", RT5645_PWR_VOL, RT5645_PWR_HV_L_BIT,
+		0, rt5645_hpvoll_mix, ARRAY_SIZE(rt5645_hpvoll_mix),
+		rt5645_hpvol_l_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_MIXER_E("HPOVOL MIXR", RT5645_PWR_VOL, RT5645_PWR_HV_R_BIT,
+		0, rt5645_hpvolr_mix, ARRAY_SIZE(rt5645_hpvolr_mix),
+		rt5645_hpvol_r_event, SND_SOC_DAPM_PRE_PMD |
+		SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_PGA("DAC 1", SND_SOC_NOPM,
+		0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("DAC 2", SND_SOC_NOPM,
+		0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("HPOVOL", SND_SOC_NOPM,
+		0, 0, NULL, 0),
+	SND_SOC_DAPM_SWITCH("HPOVOL L", SND_SOC_NOPM,
+		0, 0, &hp_l_vol_control),
+	SND_SOC_DAPM_SWITCH("HPOVOL R", SND_SOC_NOPM,
+		0, 0, &hp_r_vol_control),
+
+
+	/* HPO/LOUT/Mono Mixer */
+	SND_SOC_DAPM_MIXER("SPOL MIX", SND_SOC_NOPM, 0,
+		0, rt5645_spo_l_mix, ARRAY_SIZE(rt5645_spo_l_mix)),
+	SND_SOC_DAPM_MIXER("SPOR MIX", SND_SOC_NOPM, 0,
+		0, rt5645_spo_r_mix, ARRAY_SIZE(rt5645_spo_r_mix)),
+	SND_SOC_DAPM_MIXER("HPO MIX", SND_SOC_NOPM, 0, 0,
+		rt5645_hpo_mix, ARRAY_SIZE(rt5645_hpo_mix)),
+	SND_SOC_DAPM_MIXER("LOUT MIX", SND_SOC_NOPM, 0, 0,
+		rt5645_lout_mix, ARRAY_SIZE(rt5645_lout_mix)),
+
+	SND_SOC_DAPM_PGA_S("HP amp", 1, SND_SOC_NOPM,
+		0, 0, rt5645_hp_event,
+		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_PGA_S("LOUT amp", 1, SND_SOC_NOPM,
+		0, 0, rt5645_lout_event,
+		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_PGA_S("SPK amp", 2, SND_SOC_NOPM,
+		0, 0, rt5645_spk_event,
+		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
+
+	/* PDM */
+	SND_SOC_DAPM_SUPPLY("PDM1 Power", RT5645_PWR_DIG2,
+		RT5645_PWR_PDM1_BIT, 0, NULL, 0),
+	SND_SOC_DAPM_MUX_E("PDM1 L Mux", SND_SOC_NOPM,
+		0, 0, &rt5645_pdm1_l_mux, rt5645_pdm1_l_event,
+		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_MUX_E("PDM1 R Mux", SND_SOC_NOPM,
+		0, 0, &rt5645_pdm1_r_mux, rt5645_pdm1_r_event,
+		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
+
+	/* Output Lines */
+	SND_SOC_DAPM_OUTPUT("HPOL"),
+	SND_SOC_DAPM_OUTPUT("HPOR"),
+	SND_SOC_DAPM_OUTPUT("LOUTL"),
+	SND_SOC_DAPM_OUTPUT("LOUTR"),
+	SND_SOC_DAPM_OUTPUT("PDM1L"),
+	SND_SOC_DAPM_OUTPUT("PDM1R"),
+	SND_SOC_DAPM_OUTPUT("SPOL"),
+	SND_SOC_DAPM_OUTPUT("SPOR"),
+};
+
+static const struct snd_soc_dapm_route rt5645_dapm_routes[] = {
+#ifdef USE_ASRC
+	{"I2S1", NULL, "ASRC enable"},
+	{"I2S2", NULL, "ASRC enable"},
+#endif
+
+	{ "IN1P", NULL, "LDO2" },
+	{ "IN2P", NULL, "LDO2" },
+
+	{ "DMIC1", NULL, "DMIC L1" },
+	{ "DMIC1", NULL, "DMIC R1" },
+	{ "DMIC2", NULL, "DMIC L2" },
+	{ "DMIC2", NULL, "DMIC R2" },
+
+	{ "BST1", NULL, "IN1P" },
+	{ "BST1", NULL, "IN1N" },
+	{ "BST1", NULL, "JD Power" },
+	{ "BST1", NULL, "Mic Det Power" },
+	{ "BST2", NULL, "IN2P" },
+	{ "BST2", NULL, "IN2N" },
+	{ "BST2", NULL, "micbias1" },
+
+	{ "INL VOL", NULL, "IN2P" },
+	{ "INR VOL", NULL, "IN2N" },
+
+	{ "RECMIXL", "HPOL Switch", "HPOL" },
+	{ "RECMIXL", "INL Switch", "INL VOL" },
+	{ "RECMIXL", "BST2 Switch", "BST2" },
+	{ "RECMIXL", "BST1 Switch", "BST1" },
+	{ "RECMIXL", "OUT MIXL Switch", "OUT MIXL" },
+
+	{ "RECMIXR", "HPOR Switch", "HPOR" },
+	{ "RECMIXR", "INR Switch", "INR VOL" },
+	{ "RECMIXR", "BST2 Switch", "BST2" },
+	{ "RECMIXR", "BST1 Switch", "BST1" },
+	{ "RECMIXR", "OUT MIXR Switch", "OUT MIXR" },
+
+	{ "ADC L", NULL, "RECMIXL" },
+	{ "ADC L", NULL, "ADC L power" },
+	{ "ADC L", NULL, "ADC clock" },
+	{ "ADC R", NULL, "RECMIXR" },
+	{ "ADC R", NULL, "ADC R power" },
+	{ "ADC R", NULL, "ADC clock" },
+
+	{"DMIC L1", NULL, "DMIC CLK"},
+	{"DMIC L1", NULL, "DMIC1 Power"},
+	{"DMIC R1", NULL, "DMIC CLK"},
+	{"DMIC R1", NULL, "DMIC1 Power"},
+	{"DMIC L2", NULL, "DMIC CLK"},
+	{"DMIC L2", NULL, "DMIC2 Power"},
+	{"DMIC R2", NULL, "DMIC CLK"},
+	{"DMIC R2", NULL, "DMIC2 Power"},
+
+	{ "Stereo1 DMIC Mux", "DMIC1", "DMIC1" },
+	{ "Stereo1 DMIC Mux", "DMIC2", "DMIC2" },
+
+	{ "Mono DMIC L Mux", "DMIC1", "DMIC L1" },
+	{ "Mono DMIC L Mux", "DMIC2", "DMIC L2" },
+
+	{ "Mono DMIC R Mux", "DMIC1", "DMIC R1" },
+	{ "Mono DMIC R Mux", "DMIC2", "DMIC R2" },
+
+	{ "Stereo1 ADC L2 Mux", "DMIC", "Stereo1 DMIC Mux" },
+	{ "Stereo1 ADC L2 Mux", "DAC MIX", "DAC MIXL" },
+	{ "Stereo1 ADC L1 Mux", "ADC", "ADC L" },
+	{ "Stereo1 ADC L1 Mux", "DAC MIX", "DAC MIXL" },
+
+	{ "Stereo1 ADC R1 Mux", "ADC", "ADC R" },
+	{ "Stereo1 ADC R1 Mux", "DAC MIX", "DAC MIXR" },
+	{ "Stereo1 ADC R2 Mux", "DMIC", "Stereo1 DMIC Mux" },
+	{ "Stereo1 ADC R2 Mux", "DAC MIX", "DAC MIXR" },
+
+	{ "Mono ADC L2 Mux", "DMIC", "Mono DMIC L Mux" },
+	{ "Mono ADC L2 Mux", "Mono DAC MIXL", "Mono DAC MIXL" },
+	{ "Mono ADC L1 Mux", "Mono DAC MIXL", "Mono DAC MIXL" },
+	{ "Mono ADC L1 Mux", "ADC", "ADC L" },
+
+	{ "Mono ADC R1 Mux", "Mono DAC MIXR", "Mono DAC MIXR" },
+	{ "Mono ADC R1 Mux", "ADC", "ADC R" },
+	{ "Mono ADC R2 Mux", "DMIC", "Mono DMIC R Mux" },
+	{ "Mono ADC R2 Mux", "Mono DAC MIXR", "Mono DAC MIXR" },
+
+	{ "Sto1 ADC MIXL", "ADC1 Switch", "Stereo1 ADC L1 Mux" },
+	{ "Sto1 ADC MIXL", "ADC2 Switch", "Stereo1 ADC L2 Mux" },
+	{ "Sto1 ADC MIXR", "ADC1 Switch", "Stereo1 ADC R1 Mux" },
+	{ "Sto1 ADC MIXR", "ADC2 Switch", "Stereo1 ADC R2 Mux" },
+
+	{ "Stereo1 ADC MIXL", NULL, "Sto1 ADC MIXL" },
+	{ "Stereo1 ADC MIXL", NULL, "adc stereo1 filter" },
+	{ "adc stereo1 filter", NULL, "PLL1", check_sysclk1_source },
+
+	{ "Stereo1 ADC MIXR", NULL, "Sto1 ADC MIXR" },
+	{ "Stereo1 ADC MIXR", NULL, "adc stereo1 filter" },
+	{ "adc stereo1 filter", NULL, "PLL1", check_sysclk1_source },
+
+	{ "Mono ADC MIXL", "ADC1 Switch", "Mono ADC L1 Mux" },
+	{ "Mono ADC MIXL", "ADC2 Switch", "Mono ADC L2 Mux" },
+	{ "Mono ADC MIXL", NULL, "adc mono left filter" },
+	{ "adc mono left filter", NULL, "PLL1", check_sysclk1_source },
+
+	{ "Mono ADC MIXR", "ADC1 Switch", "Mono ADC R1 Mux" },
+	{ "Mono ADC MIXR", "ADC2 Switch", "Mono ADC R2 Mux" },
+	{ "Mono ADC MIXR", NULL, "adc mono right filter" },
+	{ "adc mono right filter", NULL, "PLL1", check_sysclk1_source },
+
+	{ "VAD ADC Mux", "Sto1 ADC L", "Stereo1 ADC MIXL" },
+	{ "VAD ADC Mux", "Mono ADC L", "Mono ADC MIXL" },
+	{ "VAD ADC Mux", "Mono ADC R", "Mono ADC MIXR" },
+
+	{ "IF_ADC1", NULL, "Stereo1 ADC MIXL" },
+	{ "IF_ADC1", NULL, "Stereo1 ADC MIXR" },
+	{ "IF_ADC2", NULL, "Mono ADC MIXL" },
+	{ "IF_ADC2", NULL, "Mono ADC MIXR" },
+	{ "VAD_ADC", NULL, "VAD ADC Mux" },
+#if 0
+	{ "IF1 ADC Mux", "IF_ADC1", "IF_ADC1" },
+	{ "IF1 ADC Mux", "IF_ADC2", "IF_ADC2" },
+	{ "IF1 ADC Mux", "VAD_ADC", "VAD_ADC" },
+#endif
+	{ "IF2 ADC Mux", "IF_ADC1", "IF_ADC1" },
+	{ "IF2 ADC Mux", "IF_ADC2", "IF_ADC2" },
+	{ "IF2 ADC Mux", "VAD_ADC", "VAD_ADC" },
+
+	{ "IF1 ADC", NULL, "I2S1" },
+#if 0
+	{ "IF1 ADC", NULL, "IF1 ADC Mux" },
+#endif
+		{ "IF1 ADC", NULL, "IF_ADC1" },
+		{ "IF1 ADC", NULL, "IF_ADC2" },
+		{ "IF1 ADC", NULL, "VAD_ADC" },
+
+	{ "IF2 ADC", NULL, "I2S2" },
+	{ "IF2 ADC", NULL, "IF2 ADC Mux" },
+
+	{ "AIF1TX", NULL, "IF1 ADC" },
+#ifdef USE_TDM
+	{ "AIF1TX", NULL, "IF2 ADC" },
+#endif
+	{ "AIF2TX", NULL, "IF2 ADC" },
+
+	{ "IF1 DAC1", NULL, "AIF1RX" },
+#ifdef USE_TDM
+	{ "IF1 DAC2", NULL, "AIF1RX" },
+#endif
+	{ "IF2 DAC", NULL, "AIF2RX" },
+
+	{ "IF1 DAC1", NULL, "I2S1" },
+	{ "IF1 DAC2", NULL, "I2S1" },
+	{ "IF2 DAC", NULL, "I2S2" },
+
+	{ "IF1 DAC2 L", NULL, "IF1 DAC2" },
+	{ "IF1 DAC2 R", NULL, "IF1 DAC2" },
+	{ "IF1 DAC1 L", NULL, "IF1 DAC1" },
+	{ "IF1 DAC1 R", NULL, "IF1 DAC1" },
+	{ "IF2 DAC L", NULL, "IF2 DAC" },
+	{ "IF2 DAC R", NULL, "IF2 DAC" },
+
+	{ "DAC1 L Mux", "IF1 DAC", "IF1 DAC1 L" },
+	{ "DAC1 L Mux", "IF2 DAC", "IF2 DAC L" },
+
+	{ "DAC1 R Mux", "IF1 DAC", "IF1 DAC1 R" },
+	{ "DAC1 R Mux", "IF2 DAC", "IF2 DAC R" },
+
+	{ "DAC1 MIXL", "Stereo ADC Switch", "Stereo1 ADC MIXL" },
+	{ "DAC1 MIXL", "DAC1 Switch", "DAC1 L Mux" },
+	{ "DAC1 MIXL", NULL, "dac stereo1 filter" },
+	{ "DAC1 MIXR", "Stereo ADC Switch", "Stereo1 ADC MIXR" },
+	{ "DAC1 MIXR", "DAC1 Switch", "DAC1 R Mux" },
+	{ "DAC1 MIXR", NULL, "dac stereo1 filter" },
+
+	{ "DAC MIX", NULL, "DAC1 MIXL" },
+	{ "DAC MIX", NULL, "DAC1 MIXR" },
+
+	{ "Audio DSP", NULL, "DAC1 MIXL" },
+	{ "Audio DSP", NULL, "DAC1 MIXR" },
+
+	{ "DAC L2 Mux", "IF1 DAC", "IF1 DAC2 L" },
+	{ "DAC L2 Mux", "IF2 DAC", "IF2 DAC L" },
+	{ "DAC L2 Mux", "Mono ADC", "Mono ADC MIXL" },
+	{ "DAC L2 Mux", "VAD_ADC", "VAD_ADC" },
+	{ "DAC L2 Volume", NULL, "DAC L2 Mux" },
+	{ "DAC L2 Volume", NULL, "dac mono left filter" },
+
+	{ "DAC R2 Mux", "IF1 DAC", "IF1 DAC2 R" },
+	{ "DAC R2 Mux", "IF2 DAC", "IF2 DAC R" },
+	{ "DAC R2 Mux", "Mono ADC", "Mono ADC MIXR" },
+	{ "DAC R2 Mux", "Haptic", "Haptic Generator" },
+	{ "DAC R2 Volume", NULL, "DAC R2 Mux" },
+	{ "DAC R2 Volume", NULL, "dac mono right filter" },
+
+	{ "Stereo DAC MIXL", "DAC L1 Switch", "DAC1 MIXL" },
+	{ "Stereo DAC MIXL", "DAC R1 Switch", "DAC1 MIXR" },
+	{ "Stereo DAC MIXL", "DAC L2 Switch", "DAC L2 Volume" },
+	{ "Stereo DAC MIXL", NULL, "dac stereo1 filter" },
+	{ "Stereo DAC MIXR", "DAC R1 Switch", "DAC1 MIXR" },
+	{ "Stereo DAC MIXR", "DAC L1 Switch", "DAC1 MIXL" },
+	{ "Stereo DAC MIXR", "DAC R2 Switch", "DAC R2 Volume" },
+	{ "Stereo DAC MIXR", NULL, "dac stereo1 filter" },
+
+	{ "Mono DAC MIXL", "DAC L1 Switch", "DAC1 MIXL" },
+	{ "Mono DAC MIXL", "DAC L2 Switch", "DAC L2 Volume" },
+	{ "Mono DAC MIXL", "DAC R2 Switch", "DAC R2 Volume" },
+	{ "Mono DAC MIXL", NULL, "dac mono left filter" },
+	{ "Mono DAC MIXR", "DAC R1 Switch", "DAC1 MIXR" },
+	{ "Mono DAC MIXR", "DAC R2 Switch", "DAC R2 Volume" },
+	{ "Mono DAC MIXR", "DAC L2 Switch", "DAC L2 Volume" },
+	{ "Mono DAC MIXR", NULL, "dac mono right filter" },
+
+	{ "DAC MIXL", "Sto DAC Mix L Switch", "Stereo DAC MIXL" },
+	{ "DAC MIXL", "DAC L2 Switch", "DAC L2 Volume" },
+	{ "DAC MIXL", "DAC R2 Switch", "DAC R2 Volume" },
+	{ "DAC MIXR", "Sto DAC Mix R Switch", "Stereo DAC MIXR" },
+	{ "DAC MIXR", "DAC R2 Switch", "DAC R2 Volume" },
+	{ "DAC MIXR", "DAC L2 Switch", "DAC L2 Volume" },
+
+	{ "DAC L1", NULL, "Stereo DAC MIXL" },
+	{ "DAC L1", NULL, "PLL1", check_sysclk1_source },
+	{ "DAC R1", NULL, "Stereo DAC MIXR" },
+	{ "DAC R1", NULL, "PLL1", check_sysclk1_source },
+	{ "DAC L2", NULL, "Mono DAC MIXL" },
+	{ "DAC L2", NULL, "PLL1", check_sysclk1_source },
+	{ "DAC R2", NULL, "Mono DAC MIXR" },
+	{ "DAC R2", NULL, "PLL1", check_sysclk1_source },
+
+	{ "SPK MIXL", "BST1 Switch", "BST1" },
+	{ "SPK MIXL", "INL Switch", "INL VOL" },
+	{ "SPK MIXL", "DAC L1 Switch", "DAC L1" },
+	{ "SPK MIXL", "DAC L2 Switch", "DAC L2" },
+	{ "SPK MIXR", "BST2 Switch", "BST2" },
+	{ "SPK MIXR", "INR Switch", "INR VOL" },
+	{ "SPK MIXR", "DAC R1 Switch", "DAC R1" },
+	{ "SPK MIXR", "DAC R2 Switch", "DAC R2" },
+
+	{ "OUT MIXL", "BST1 Switch", "BST1" },
+	{ "OUT MIXL", "INL Switch", "INL VOL" },
+	{ "OUT MIXL", "DAC L2 Switch", "DAC L2" },
+	{ "OUT MIXL", "DAC L1 Switch", "DAC L1" },
+
+	{ "OUT MIXR", "BST2 Switch", "BST2" },
+	{ "OUT MIXR", "INR Switch", "INR VOL" },
+	{ "OUT MIXR", "DAC R2 Switch", "DAC R2" },
+	{ "OUT MIXR", "DAC R1 Switch", "DAC R1" },
+
+	{ "HPOVOL MIXL", "DAC1 Switch", "DAC L1" },
+	{ "HPOVOL MIXL", "DAC2 Switch", "DAC L2" },
+	{ "HPOVOL MIXL", "INL Switch", "INL VOL" },
+	{ "HPOVOL MIXL", "BST1 Switch", "BST1" },
+	{ "HPOVOL MIXR", "DAC1 Switch", "DAC R1" },
+	{ "HPOVOL MIXR", "DAC2 Switch", "DAC R2" },
+	{ "HPOVOL MIXR", "INR Switch", "INR VOL" },
+	{ "HPOVOL MIXR", "BST2 Switch", "BST2" },
+
+	{ "DAC 2", NULL, "DAC L2" },
+	{ "DAC 2", NULL, "DAC R2" },
+	{ "DAC 1", NULL, "DAC L1" },
+	{ "DAC 1", NULL, "DAC R1" },
+	{ "HPOVOL L", "Switch", "HPOVOL MIXL" },
+	{ "HPOVOL R", "Switch", "HPOVOL MIXR" },
+	{ "HPOVOL", NULL, "HPOVOL L" },
+	{ "HPOVOL", NULL, "HPOVOL R" },
+	{ "HPO MIX", "DAC1 Switch", "DAC 1" },
+	{ "HPO MIX", "HPVOL Switch", "HPOVOL" },
+
+	{ "SPKVOL L", "Switch", "SPK MIXL" },
+	{ "SPKVOL R", "Switch", "SPK MIXR" },
+
+	{ "SPOL MIX", "DAC R1 Switch", "DAC R1" },
+	{ "SPOL MIX", "DAC L1 Switch", "DAC L1" },
+	{ "SPOL MIX", "SPKVOL R Switch", "SPKVOL R" },
+	{ "SPOL MIX", "SPKVOL L Switch", "SPKVOL L" },
+	{ "SPOR MIX", "DAC R1 Switch", "DAC R1" },
+	{ "SPOR MIX", "SPKVOL R Switch", "SPKVOL R" },
+
+	{ "LOUT MIX", "DAC L1 Switch", "DAC L1" },
+	{ "LOUT MIX", "DAC R1 Switch", "DAC R1" },
+	{ "LOUT MIX", "OUTMIX L Switch", "OUT MIXL" },
+	{ "LOUT MIX", "OUTMIX R Switch", "OUT MIXR" },
+
+	{ "PDM1 L Mux", "Stereo DAC", "Stereo DAC MIXL" },
+	{ "PDM1 L Mux", "Mono DAC", "Mono DAC MIXL" },
+	{ "PDM1 L Mux", NULL, "PDM1 Power" },
+	{ "PDM1 R Mux", "Stereo DAC", "Stereo DAC MIXR" },
+	{ "PDM1 R Mux", "Mono DAC", "Mono DAC MIXR" },
+	{ "PDM1 R Mux", NULL, "PDM1 Power" },
+
+	{ "HP amp", NULL, "HPO MIX" },
+	{ "HP amp", NULL, "JD Power" },
+	{ "HP amp", NULL, "Mic Det Power" },
+	{ "HP amp", NULL, "LDO2" },
+	{ "HPOL", NULL, "HP amp" },
+	{ "HPOR", NULL, "HP amp" },
+
+	{ "LOUT amp", NULL, "LOUT MIX" },
+	{ "LOUTL", NULL, "LOUT amp" },
+	{ "LOUTR", NULL, "LOUT amp" },
+
+	{ "PDM1L", NULL, "PDM1 L Mux" },
+	{ "PDM1R", NULL, "PDM1 R Mux" },
+
+	{ "SPK amp", NULL, "SPOL MIX" },
+	{ "SPK amp", NULL, "SPOR MIX" },
+	{ "SPOL", NULL, "SPK amp" },
+	{ "SPOR", NULL, "SPK amp" },
+};
+
+static int get_clk_info(int sclk, int rate)
+{
+	int i, pd[] = {1, 2, 3, 4, 6, 8, 12, 16};
+
+/*#ifdef USE_ASRC*/
+/*	return 0;*/
+/*#endif*/
+	if (sclk <= 0 || rate <= 0)
+		return -EINVAL;
+
+	rate = rate << 8;
+	for (i = 0; i < ARRAY_SIZE(pd); i++)
+		if (sclk == rate * pd[i])
+			return i;
+
+	return -EINVAL;
+}
+
+static int rt5645_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+	unsigned int val_len = 0, val_clk, mask_clk;
+	int pre_div, bclk_ms, frame_size;
+
+	rt5645->lrck[dai->id] = params_rate(params);
+	pre_div = get_clk_info(rt5645->sysclk, rt5645->lrck[dai->id]);
+	if (pre_div < 0) {
+		dev_err(codec->dev, "Unsupported clock setting\n");
+		return -EINVAL;
+	}
+	frame_size = snd_soc_params_to_frame_size(params);
+	if (frame_size < 0) {
+		dev_err(codec->dev, "Unsupported frame size: %d\n", frame_size);
+		return -EINVAL;
+	}
+	bclk_ms = frame_size > 32 ? 1 : 0;
+	rt5645->bclk[dai->id] = rt5645->lrck[dai->id] * (32 << bclk_ms);
+
+	dev_dbg(dai->dev, "bclk is %dHz and lrck is %dHz\n",
+		rt5645->bclk[dai->id], rt5645->lrck[dai->id]);
+	dev_dbg(dai->dev, "bclk_ms is %d and pre_div is %d for iis %d\n",
+				bclk_ms, pre_div, dai->id);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		val_len |= RT5645_I2S_DL_20;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		val_len |= RT5645_I2S_DL_24;
+		break;
+	case SNDRV_PCM_FORMAT_S8:
+		val_len |= RT5645_I2S_DL_8;
+		break;
+	default:
+		return -EINVAL;
+	}
+	switch (dai->id) {
+	case RT5645_AIF1:
+		mask_clk = RT5645_I2S_PD1_MASK;
+		val_clk = pre_div << RT5645_I2S_PD1_SFT;
+		snd_soc_update_bits(codec, RT5645_I2S1_SDP,
+			RT5645_I2S_DL_MASK, val_len);
+		snd_soc_update_bits(codec, RT5645_ADDA_CLK1, mask_clk, val_clk);
+		break;
+	case  RT5645_AIF2:
+		mask_clk = RT5645_I2S_BCLK_MS2_MASK | RT5645_I2S_PD2_MASK;
+		val_clk = bclk_ms << RT5645_I2S_BCLK_MS2_SFT |
+			pre_div << RT5645_I2S_PD2_SFT;
+		snd_soc_update_bits(codec, RT5645_I2S2_SDP,
+			RT5645_I2S_DL_MASK, val_len);
+		snd_soc_update_bits(codec, RT5645_ADDA_CLK1, mask_clk, val_clk);
+		break;
+	default:
+		dev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int rt5645_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+
+	rt5645->aif_pu = dai->id;
+	return 0;
+}
+
+static int rt5645_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+	unsigned int reg_val = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		rt5645->master[dai->id] = 1;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		reg_val |= RT5645_I2S_MS_S;
+		rt5645->master[dai->id] = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		reg_val |= RT5645_I2S_BP_INV;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		reg_val |= RT5645_I2S_DF_LEFT;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		reg_val |= RT5645_I2S_DF_PCM_A;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		reg_val |= RT5645_I2S_DF_PCM_B;
+		break;
+	default:
+		return -EINVAL;
+	}
+	switch (dai->id) {
+	case RT5645_AIF1:
+		snd_soc_update_bits(codec, RT5645_I2S1_SDP,
+			RT5645_I2S_MS_MASK | RT5645_I2S_BP_MASK |
+			RT5645_I2S_DF_MASK, reg_val);
+		break;
+	case  RT5645_AIF2:
+		snd_soc_update_bits(codec, RT5645_I2S1_SDP,
+			RT5645_I2S_MS_MASK | RT5645_I2S_BP_MASK |
+			RT5645_I2S_DF_MASK, reg_val);
+		break;
+	default:
+		dev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int rt5645_set_dai_sysclk(struct snd_soc_dai *dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+	unsigned int reg_val = 0;
+
+	if (freq == rt5645->sysclk && clk_id == rt5645->sysclk_src)
+		return 0;
+
+	switch (clk_id) {
+	case RT5645_SCLK_S_MCLK:
+		reg_val |= RT5645_SCLK_SRC_MCLK;
+		break;
+	case RT5645_SCLK_S_PLL1:
+		reg_val |= RT5645_SCLK_SRC_PLL1;
+		break;
+	case RT5645_SCLK_S_RCCLK:
+		reg_val |= RT5645_SCLK_SRC_RCCLK;
+		break;
+	default:
+		dev_err(codec->dev, "Invalid clock id (%d)\n", clk_id);
+		return -EINVAL;
+	}
+	snd_soc_update_bits(codec, RT5645_GLB_CLK,
+		RT5645_SCLK_SRC_MASK, reg_val);
+	rt5645->sysclk = freq;
+	rt5645->sysclk_src = clk_id;
+
+	dev_dbg(dai->dev, "Sysclk is %dHz and clock id is %d\n", freq, clk_id);
+
+	return 0;
+}
+
+/**
+ * rt5645_pll_calc - Calcualte PLL M/N/K code.
+ * @freq_in: external clock provided to codec.
+ * @freq_out: target clock which codec works on.
+ * @pll_code: Pointer to structure with M, N, K and bypass flag.
+ *
+ * Calcualte M/N/K code to configure PLL for codec. And K is assigned to 2
+ * which make calculation more efficiently.
+ *
+ * Returns 0 for success or negative error code.
+ */
+static int rt5645_pll_calc(const unsigned int freq_in,
+	const unsigned int freq_out, struct rt5645_pll_code *pll_code)
+{
+	int max_n = RT5645_PLL_N_MAX, max_m = RT5645_PLL_M_MAX;
+	int k, red, n_t, m_t, pll_out, in_t, out_t;
+	int red_t = abs(freq_out - freq_in);
+	bool bypass = false;
+	int n = 0, m = 0;
+
+	if (RT5645_PLL_INP_MAX < freq_in || RT5645_PLL_INP_MIN > freq_in)
+		return -EINVAL;
+
+	k = 100000000 / freq_out - 2;
+	if (k > RT5645_PLL_K_MAX)
+		k = RT5645_PLL_K_MAX;
+	for (n_t = 0; n_t <= max_n; n_t++) {
+		in_t = freq_in / (k + 2);
+		pll_out = freq_out / (n_t + 2);
+		if (in_t < 0)
+			continue;
+		if (in_t == pll_out) {
+			bypass = true;
+			n = n_t;
+			goto code_find;
+		}
+		red = abs(in_t - pll_out);
+		if (red < red_t) {
+			bypass = true;
+			n = n_t;
+			m = m_t;
+			if (red == 0)
+				goto code_find;
+			red_t = red;
+		}
+		for (m_t = 0; m_t <= max_m; m_t++) {
+			out_t = in_t / (m_t + 2);
+			red = abs(out_t - pll_out);
+			if (red < red_t) {
+				bypass = false;
+				n = n_t;
+				m = m_t;
+				if (red == 0)
+					goto code_find;
+				red_t = red;
+			}
+		}
+	}
+	pr_debug("%s(): Only get approximation about PLL\n", __func__);
+
+code_find:
+
+	pll_code->m_bp = bypass;
+	pll_code->m_code = m;
+	pll_code->n_code = n;
+	pll_code->k_code = k;
+	return 0;
+}
+
+static int rt5645_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,
+			unsigned int freq_in, unsigned int freq_out)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+	struct rt5645_pll_code pll_code;
+	int ret;
+
+	if (source == rt5645->pll_src && freq_in == rt5645->pll_in &&
+	    freq_out == rt5645->pll_out)
+		return 0;
+
+	if (!freq_in || !freq_out) {
+		dev_dbg(codec->dev, "PLL disabled\n");
+
+		rt5645->pll_in = 0;
+		rt5645->pll_out = 0;
+		snd_soc_update_bits(codec, RT5645_GLB_CLK,
+			RT5645_SCLK_SRC_MASK, RT5645_SCLK_SRC_MCLK);
+		return 0;
+	}
+
+	switch (source) {
+	case RT5645_PLL1_S_MCLK:
+		snd_soc_update_bits(codec, RT5645_GLB_CLK,
+			RT5645_PLL1_SRC_MASK, RT5645_PLL1_SRC_MCLK);
+		break;
+	case RT5645_PLL1_S_BCLK1:
+	case RT5645_PLL1_S_BCLK2:
+		switch (dai->id) {
+		case RT5645_AIF1:
+			snd_soc_update_bits(codec, RT5645_GLB_CLK,
+				RT5645_PLL1_SRC_MASK, RT5645_PLL1_SRC_BCLK1);
+			break;
+		case  RT5645_AIF2:
+			snd_soc_update_bits(codec, RT5645_GLB_CLK,
+				RT5645_PLL1_SRC_MASK, RT5645_PLL1_SRC_BCLK2);
+			break;
+		default:
+			dev_err(codec->dev, "Invalid dai->id: %d\n", dai->id);
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_err(codec->dev, "Unknown PLL source %d\n", source);
+		return -EINVAL;
+	}
+
+	ret = rt5645_pll_calc(freq_in, freq_out, &pll_code);
+	if (ret < 0) {
+		dev_err(codec->dev, "Unsupport input clock %d\n", freq_in);
+		return ret;
+	}
+
+	dev_dbg(codec->dev, "bypass=%d m=%d n=%d k=%d\n",
+		pll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),
+		pll_code.n_code, pll_code.k_code);
+
+	snd_soc_write(codec, RT5645_PLL_CTRL1,
+		pll_code.n_code << RT5645_PLL_N_SFT | pll_code.k_code);
+	snd_soc_write(codec, RT5645_PLL_CTRL2,
+		(pll_code.m_bp ? 0 : pll_code.m_code) << RT5645_PLL_M_SFT |
+		pll_code.m_bp << RT5645_PLL_M_BP_SFT);
+
+	rt5645->pll_in = freq_in;
+	rt5645->pll_out = freq_out;
+	rt5645->pll_src = source;
+
+	return 0;
+}
+
+static int rt5645_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,
+			unsigned int rx_mask, int slots, int slot_width)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	unsigned int val = 0;
+
+	if (rx_mask || tx_mask)
+		val |= (1 << 14);
+
+	switch (slots) {
+	case 4:
+		val |= (1 << 12);
+		break;
+	case 6:
+		val |= (2 << 12);
+		break;
+	case 8:
+		val |= (3 << 12);
+		break;
+	case 2:
+	default:
+		break;
+	}
+
+	switch (slot_width) {
+	case 20:
+		val |= (1 << 10);
+		break;
+	case 24:
+		val |= (2 << 10);
+		break;
+	case 32:
+		val |= (3 << 10);
+		break;
+	case 16:
+	default:
+		break;
+	}
+
+	snd_soc_update_bits(codec, RT5645_TDM_CTRL_1, 0x7c00, val);
+
+	return 0;
+}
+
+/**
+ * rt5645_index_show - Dump private registers.
+ * @dev: codec device.
+ * @attr: device attribute.
+ * @buf: buffer for display.
+ *
+ * To show non-zero values of all private registers.
+ *
+ * Returns buffer length.
+ */
+static ssize_t rt5645_index_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rt5645_priv *rt5645 = i2c_get_clientdata(client);
+	struct snd_soc_codec *codec = rt5645->codec;
+	unsigned int val;
+	int cnt = 0, i;
+
+	cnt += sprintf(buf, "RT5645 index register\n");
+	for (i = 0; i < 0xff; i++) {
+		if (cnt + RT5645_REG_DISP_LEN >= PAGE_SIZE)
+			break;
+		val = rt5645_index_read(codec, i);
+		if (!val)
+			continue;
+		cnt += snprintf(buf + cnt, RT5645_REG_DISP_LEN,
+				"%02x: %04x\n", i, val);
+	}
+
+	if (cnt >= PAGE_SIZE)
+		cnt = PAGE_SIZE - 1;
+
+	return cnt;
+}
+
+static ssize_t rt5645_index_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rt5645_priv *rt5645 = i2c_get_clientdata(client);
+	struct snd_soc_codec *codec = rt5645->codec;
+	unsigned int val = 0, addr = 0;
+	int i;
+
+	for (i = 0; i < count; i++) {
+		if (*(buf + i) <= '9' && *(buf + i) >= '0')
+			addr = (addr << 4) | (*(buf + i)-'0');
+		else if (*(buf + i) <= 'f' && *(buf + i) >= 'a')
+			addr = (addr << 4) | ((*(buf + i) - 'a') + 0xa);
+		else if (*(buf + i) <= 'F' && *(buf + i) >= 'A')
+			addr = (addr << 4) | ((*(buf + i)-'A') + 0xa);
+		else
+			break;
+	}
+
+	for (i = i + 1 ; i < count; i++) {
+		if (*(buf + i) <= '9' && *(buf + i) >= '0')
+			val = (val << 4) | (*(buf + i) - '0');
+		else if (*(buf + i) <= 'f' && *(buf + i) >= 'a')
+			val = (val << 4) | ((*(buf + i) - 'a') + 0xa);
+		else if (*(buf + i) <= 'F' && *(buf + i) >= 'A')
+			val = (val << 4) | ((*(buf + i) - 'A') + 0xa);
+		else
+			break;
+	}
+	pr_debug("addr=0x%x val=0x%x\n", addr, val);
+	if (addr > RT5645_VENDOR_ID2 || val > 0xffff)
+		return count;
+
+	if (i == count)
+		pr_info("0x%02x = 0x%04x\n", addr,
+				rt5645_index_read(codec, addr));
+	else
+		rt5645_index_write(codec, addr, val);
+
+
+	return count;
+}
+static DEVICE_ATTR(index_reg, 0666, rt5645_index_show, rt5645_index_store);
+
+static ssize_t rt5645_codec_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rt5645_priv *rt5645 = i2c_get_clientdata(client);
+	struct snd_soc_codec *codec = rt5645->codec;
+	unsigned int val;
+	int cnt = 0, i;
+
+	for (i = 0; i <= RT5645_VENDOR_ID2; i++) {
+		if (cnt + RT5645_REG_DISP_LEN >= PAGE_SIZE)
+			break;
+		val = snd_soc_read(codec, i);
+		if (!val)
+			continue;
+		cnt += snprintf(buf + cnt, RT5645_REG_DISP_LEN,
+				"#rng%02x  #rv%04x  #rd0\n", i, val);
+	}
+
+	if (cnt >= PAGE_SIZE)
+		cnt = PAGE_SIZE - 1;
+
+	return cnt;
+}
+
+static ssize_t rt5645_codec_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rt5645_priv *rt5645 = i2c_get_clientdata(client);
+	struct snd_soc_codec *codec = rt5645->codec;
+	unsigned int val = 0, addr = 0;
+	int i;
+
+	pr_debug("register \"%s\" count=%d\n", buf, (int)count);
+	for (i = 0; i < count; i++) {
+		if (*(buf + i) <= '9' && *(buf + i) >= '0')
+			addr = (addr << 4) | (*(buf + i) - '0');
+		else if (*(buf + i) <= 'f' && *(buf + i) >= 'a')
+			addr = (addr << 4) | ((*(buf + i)-'a') + 0xa);
+		else if (*(buf + i) <= 'F' && *(buf + i) >= 'A')
+			addr = (addr << 4) | ((*(buf + i)-'A') + 0xa);
+		else
+			break;
+	}
+
+	for (i = i + 1 ; i < count; i++) {
+		if (*(buf + i) <= '9' && *(buf + i) >= '0')
+			val = (val << 4) | (*(buf + i)-'0');
+		else if (*(buf + i) <= 'f' && *(buf + i) >= 'a')
+			val = (val << 4) | ((*(buf + i)-'a') + 0xa);
+		else if (*(buf + i) <= 'F' && *(buf + i) >= 'A')
+			val = (val << 4) | ((*(buf + i)-'A') + 0xa);
+		else
+			break;
+	}
+	pr_debug("addr=0x%x val=0x%x\n", addr, val);
+	if (addr > RT5645_VENDOR_ID2 || val > 0xffff)
+		return count;
+
+	if (i == count)
+		pr_info("0x%02x = 0x%04x\n", addr, codec->hw_read(codec, addr));
+	else
+		snd_soc_write(codec, addr, val);
+
+
+	return count;
+}
+
+static DEVICE_ATTR(codec_reg, 0666, rt5645_codec_show, rt5645_codec_store);
+
+static int rt5645_set_bias_level(struct snd_soc_codec *codec,
+			enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (SND_SOC_BIAS_OFF == codec->dapm.bias_level) {
+			snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+				RT5645_PWR_VREF1 | RT5645_PWR_MB |
+				RT5645_PWR_BG | RT5645_PWR_VREF2,
+				RT5645_PWR_VREF1 | RT5645_PWR_MB |
+				RT5645_PWR_BG | RT5645_PWR_VREF2);
+			mdelay(10);
+			snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+				RT5645_PWR_FV1 | RT5645_PWR_FV2,
+				RT5645_PWR_FV1 | RT5645_PWR_FV2);
+			snd_soc_update_bits(codec, RT5645_DIG_MISC,
+				RT5645_DIG_GATE_CTRL, RT5645_DIG_GATE_CTRL);
+			codec->cache_only = false;
+			codec->cache_sync = 1;
+			snd_soc_cache_sync(codec);
+			rt5645_index_sync(codec);
+		}
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		snd_soc_write(codec, RT5645_DEPOP_M2, 0x1100);
+		snd_soc_write(codec, RT5645_DIG_MISC, 0x0128);
+		snd_soc_write(codec, RT5645_PWR_DIG1, 0x0000);
+		snd_soc_write(codec, RT5645_PWR_DIG2, 0x0000);
+		snd_soc_write(codec, RT5645_PWR_VOL, 0x0000);
+		snd_soc_write(codec, RT5645_PWR_MIXER, RT5645_PWR_LDO2);
+		snd_soc_write(codec, RT5645_PWR_ANLG1,
+				RT5645_PWR_MB | RT5645_PWR_BG | 0x2);
+#ifdef JD1_FUNC
+		snd_soc_write(codec, RT5645_PWR_ANLG2, 0x0004);
+#else
+		snd_soc_write(codec, RT5645_PWR_ANLG2, 0x0000);
+#endif
+		break;
+
+	default:
+		break;
+	}
+	codec->dapm.bias_level = level;
+
+	return 0;
+}
+
+static int rt5645_probe(struct snd_soc_codec *codec)
+{
+	struct rt5645_priv *rt5645 = snd_soc_codec_get_drvdata(codec);
+#ifdef RTK_IOCTL
+#if defined(CONFIG_SND_HWDEP) || defined(CONFIG_SND_HWDEP_MODULE)
+	struct rt_codec_ops *ioctl_ops = rt5645_codec_get_ioctl_ops();
+#endif
+#endif
+	int ret;
+
+	pr_info("%s(): Codec driver version %s\n", __func__, VERSION);
+
+	codec->dapm.idle_bias_off = 1;
+
+	ret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_I2C);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+
+	rt5645_reset(codec);
+	snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+		RT5645_PWR_VREF1 | RT5645_PWR_MB |
+		RT5645_PWR_BG | RT5645_PWR_VREF2,
+		RT5645_PWR_VREF1 | RT5645_PWR_MB |
+		RT5645_PWR_BG | RT5645_PWR_VREF2);
+	mdelay(10);
+	snd_soc_update_bits(codec, RT5645_PWR_ANLG1,
+		RT5645_PWR_FV1 | RT5645_PWR_FV2,
+		RT5645_PWR_FV1 | RT5645_PWR_FV2);
+
+	rt5645_reg_init(codec);
+
+	snd_soc_update_bits(codec, RT5645_PWR_ANLG1, RT5645_LDO_SEL_MASK, 0x0);
+
+	/* dc_calibrate(codec); */
+	codec->dapm.bias_level = SND_SOC_BIAS_OFF;/*SND_SOC_BIAS_STANDBY;*/
+	rt5645->codec = codec;
+	rt5645->combo_jack_en = true; /* enable combo jack */
+
+	snd_soc_add_codec_controls(codec, rt5645_snd_controls,
+			ARRAY_SIZE(rt5645_snd_controls));
+	snd_soc_dapm_new_controls(&codec->dapm, rt5645_dapm_widgets,
+			ARRAY_SIZE(rt5645_dapm_widgets));
+	snd_soc_dapm_add_routes(&codec->dapm, rt5645_dapm_routes,
+			ARRAY_SIZE(rt5645_dapm_routes));
+
+#ifdef JD1_FUNC
+	snd_soc_dapm_force_enable_pin(&codec->dapm, "LDO2");
+	snd_soc_dapm_force_enable_pin(&codec->dapm, "Mic Det Power");
+	snd_soc_dapm_sync(&codec->dapm);
+	snd_soc_update_bits(codec, RT5645_HPO_MIXER, 0x1000, 0x1000);
+	snd_soc_update_bits(codec, RT5645_PWR_ANLG2, 0x0004, 0x0004);
+#endif
+
+#ifdef RTK_IOCTL
+#if defined(CONFIG_SND_HWDEP) || defined(CONFIG_SND_HWDEP_MODULE)
+	ioctl_ops->index_write = rt5645_index_write;
+	ioctl_ops->index_read = rt5645_index_read;
+	ioctl_ops->index_update_bits = rt5645_index_update_bits;
+	ioctl_ops->ioctl_common = rt5645_ioctl_common;
+	/*realtek_ce_init_hwdep(codec);*/
+#endif
+#endif
+
+	ret = device_create_file(codec->dev, &dev_attr_index_reg);
+	if (ret != 0) {
+		dev_err(codec->dev,
+			"Failed to create index_reg sysfs files: %d\n", ret);
+		return ret;
+	}
+
+	ret = device_create_file(codec->dev, &dev_attr_codec_reg);
+	if (ret != 0) {
+		dev_err(codec->dev,
+			"Failed to create codex_reg sysfs files: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int rt5645_remove(struct snd_soc_codec *codec)
+{
+	rt5645_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int rt5645_suspend(struct snd_soc_codec *codec)
+{
+	rt5645_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static int rt5645_resume(struct snd_soc_codec *codec)
+{
+	rt5645_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+#else
+#define rt5645_suspend NULL
+#define rt5645_resume NULL
+#endif
+
+#define RT5645_STEREO_RATES SNDRV_PCM_RATE_8000_96000
+#define RT5645_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)
+
+struct snd_soc_dai_ops rt5645_aif_dai_ops = {
+	.hw_params = rt5645_hw_params,
+	.prepare = rt5645_prepare,
+	.set_fmt = rt5645_set_dai_fmt,
+	.set_sysclk = rt5645_set_dai_sysclk,
+	.set_tdm_slot = rt5645_set_tdm_slot,
+	.set_pll = rt5645_set_dai_pll,
+};
+
+struct snd_soc_dai_driver rt5645_dai[] = {
+	{
+		.name = "rt5645-aif1",
+		.id = RT5645_AIF1,
+		.playback = {
+			.stream_name = "AIF1 Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = RT5645_STEREO_RATES,
+			.formats = RT5645_FORMATS,
+		},
+		.capture = {
+			.stream_name = "AIF1 Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = RT5645_STEREO_RATES,
+			.formats = RT5645_FORMATS,
+		},
+		.ops = &rt5645_aif_dai_ops,
+	},
+	{
+		.name = "rt5645-aif2",
+		.id = RT5645_AIF2,
+		.playback = {
+			.stream_name = "AIF2 Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = RT5645_STEREO_RATES,
+			.formats = RT5645_FORMATS,
+		},
+		.capture = {
+			.stream_name = "AIF2 Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = RT5645_STEREO_RATES,
+			.formats = RT5645_FORMATS,
+		},
+		.ops = &rt5645_aif_dai_ops,
+	},
+};
+
+static struct snd_soc_codec_driver soc_codec_dev_rt5645 = {
+	.probe = rt5645_probe,
+	.remove = rt5645_remove,
+	.suspend = rt5645_suspend,
+	.resume = rt5645_resume,
+	.set_bias_level = rt5645_set_bias_level,
+	.reg_cache_size = RT5645_VENDOR_ID2 + 1,
+	.reg_word_size = sizeof(u16),
+	.reg_cache_default = rt5645_reg,
+	.volatile_register = rt5645_volatile_register,
+	.readable_register = rt5645_readable_register,
+	.reg_cache_step = 1,
+};
+
+static struct acpi_device_id rt5645_acpi_match[] = {
+		{ "10EC5645", 0 },
+		{ },
+};
+MODULE_DEVICE_TABLE(acpi, rt5645_acpi_match);
+
+static const struct i2c_device_id rt5645_i2c_id[] = {
+		{ "rt5645", 0 },
+		{ "10EC5645:00", 0},
+		{ "10EC5645", 0},
+		{ "i2c-10EC5645:00:1a", 0},
+		{ }
+};
+MODULE_DEVICE_TABLE(i2c, rt5645_i2c_id);
+
+static int rt5645_i2c_probe(struct i2c_client *i2c,
+		    const struct i2c_device_id *id)
+{
+	struct rt5645_priv *rt5645;
+	int ret;
+
+	rt5645 = kzalloc(sizeof(struct rt5645_priv), GFP_KERNEL);
+	if (NULL == rt5645)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, rt5645);
+
+	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt5645,
+			rt5645_dai, ARRAY_SIZE(rt5645_dai));
+	if (ret < 0)
+		kfree(rt5645);
+
+	return ret;
+}
+
+static int rt5645_i2c_remove(struct i2c_client *i2c)
+{
+	snd_soc_unregister_codec(&i2c->dev);
+	kfree(i2c_get_clientdata(i2c));
+	return 0;
+}
+
+void rt5645_i2c_shutdown(struct i2c_client *client)
+{
+	struct rt5645_priv *rt5645 = i2c_get_clientdata(client);
+	struct snd_soc_codec *codec = rt5645->codec;
+
+	if (codec != NULL)
+		rt5645_set_bias_level(codec, SND_SOC_BIAS_OFF);
+}
+
+struct i2c_driver rt5645_i2c_driver = {
+	.driver = {
+		.name = "rt5645",
+		.owner = THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(rt5645_acpi_match),
+	},
+	.probe = rt5645_i2c_probe,
+	.remove   = rt5645_i2c_remove,
+	.shutdown = rt5645_i2c_shutdown,
+	.id_table = rt5645_i2c_id,
+};
+
+static int __init rt5645_modinit(void)
+{
+	return i2c_add_driver(&rt5645_i2c_driver);
+}
+module_init(rt5645_modinit);
+
+static void __exit rt5645_modexit(void)
+{
+	i2c_del_driver(&rt5645_i2c_driver);
+}
+module_exit(rt5645_modexit);
+
+MODULE_DESCRIPTION("ASoC RT5645 driver");
+MODULE_AUTHOR("Bard Liao <bardliao@realtek.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/rt5645.h b/sound/soc/codecs/rt5645.h
new file mode 100644
index 0000000..7f3c74e
--- /dev/null
+++ b/sound/soc/codecs/rt5645.h
@@ -0,0 +1,2264 @@
+/*
+ * rt5645.h  --  RT5645 ALSA SoC audio driver
+ *
+ * Copyright 2011 Realtek Microelectronics
+ * Author: Johnny Hsu <johnnyhsu@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __RT5645_H__
+#define __RT5645_H__
+
+/* Info */
+#define RT5645_RESET				0x00
+#define RT5645_VENDOR_ID			0xfd
+#define RT5645_VENDOR_ID1			0xfe
+#define RT5645_VENDOR_ID2			0xff
+/*  I/O - Output */
+#define RT5645_SPK_VOL				0x01
+#define RT5645_HP_VOL				0x02
+#define RT5645_LOUT1				0x03
+/* I/O - Input */
+#define RT5645_CJ_CTRL1				0x0a
+#define RT5645_CJ_CTRL2				0x0b
+#define RT5645_CJ_CTRL3				0x0c
+#define RT5645_IN1_IN2				0x0d
+#define RT5645_IN3				0x0e
+#define RT5645_INL1_INR1_VOL			0x0f
+#define RT5645_SPK_FUNC_LIM			0x14
+#define RT5645_ADJ_HPF_CTRL			0x16
+/* I/O - ADC/DAC/DMIC */
+#define RT5645_SIDETONE_CTRL			0x18
+#define RT5645_DAC1_DIG_VOL			0x19
+#define RT5645_DAC2_DIG_VOL			0x1a
+#define RT5645_DAC_CTRL				0x1b
+#define RT5645_STO1_ADC_DIG_VOL			0x1c
+#define RT5645_MONO_ADC_DIG_VOL			0x1d
+#define RT5645_ADC_BST_VOL1			0x1e
+/* Mixer - D-D */
+#define RT5645_ADC_BST_VOL2			0x20
+#define RT5645_STO1_ADC_MIXER			0x27
+#define RT5645_MONO_ADC_MIXER			0x28
+#define RT5645_AD_DA_MIXER			0x29
+#define RT5645_STO_DAC_MIXER			0x2a
+#define RT5645_MONO_DAC_MIXER			0x2b
+#define RT5645_DIG_MIXER			0x2c
+#define RT5645_DSP_PATH1			0x2d
+#define RT5645_DSP_PATH2			0x2e
+#define RT5645_DIG_INF1_DATA			0x2f
+/* Mixer - PDM */
+#define RT5645_PDM_OUT_CTRL			0x31
+#define RT5645_PDM_DATA_CTRL1			0x32
+#define RT5645_PDM1_DATA_CTRL2			0x33
+#define RT5645_PDM1_DATA_CTRL3			0x34
+#define RT5645_PDM1_DATA_CTRL4			0x35
+#define RT5645_PDM2_DATA_CTRL2			0x36
+#define RT5645_PDM2_DATA_CTRL3			0x37
+#define RT5645_PDM2_DATA_CTRL4			0x38
+/* Mixer - ADC */
+#define RT5645_REC_L1_MIXER			0x3b
+#define RT5645_REC_L2_MIXER			0x3c
+#define RT5645_REC_R1_MIXER			0x3d
+#define RT5645_REC_R2_MIXER			0x3e
+/* Mixer - DAC */
+#define RT5645_HPMIXL_CTRL			0x3f
+#define RT5645_HPOMIXL_CTRL			0x40
+#define RT5645_HPMIXR_CTRL			0x41
+#define RT5645_HPOMIXR_CTRL			0x42
+#define RT5645_HPO_MIXER			0x45
+#define RT5645_SPK_L_MIXER			0x46
+#define RT5645_SPK_R_MIXER			0x47
+#define RT5645_SPO_MIXER			0x48
+#define RT5645_SPO_CLSD_RATIO			0x4a
+#define RT5645_OUT_L_GAIN1			0x4d
+#define RT5645_OUT_L_GAIN2			0x4e
+#define RT5645_OUT_L1_MIXER			0x4f
+#define RT5645_OUT_R_GAIN1			0x50
+#define RT5645_OUT_R_GAIN2			0x51
+#define RT5645_OUT_R1_MIXER			0x52
+#define RT5645_LOUT_MIXER			0x53
+/* Haptic */
+#define RT5645_HAPTIC_CTRL1			0x56
+#define RT5645_HAPTIC_CTRL2			0x57
+#define RT5645_HAPTIC_CTRL3			0x58
+#define RT5645_HAPTIC_CTRL4			0x59
+#define RT5645_HAPTIC_CTRL5			0x5a
+#define RT5645_HAPTIC_CTRL6			0x5b
+#define RT5645_HAPTIC_CTRL7			0x5c
+#define RT5645_HAPTIC_CTRL8			0x5d
+#define RT5645_HAPTIC_CTRL9			0x5e
+#define RT5645_HAPTIC_CTRL10			0x5f
+/* Power */
+#define RT5645_PWR_DIG1				0x61
+#define RT5645_PWR_DIG2				0x62
+#define RT5645_PWR_ANLG1			0x63
+#define RT5645_PWR_ANLG2			0x64
+#define RT5645_PWR_MIXER			0x65
+#define RT5645_PWR_VOL				0x66
+/* Private Register Control */
+#define RT5645_PRIV_INDEX			0x6a
+#define RT5645_PRIV_DATA			0x6c
+/* Format - ADC/DAC */
+#define RT5645_I2S1_SDP				0x70
+#define RT5645_I2S2_SDP				0x71
+#define RT5645_I2S3_SDP				0x72
+#define RT5645_ADDA_CLK1			0x73
+#define RT5645_ADDA_CLK2			0x74
+#define RT5645_DMIC_CTRL1			0x75
+#define RT5645_DMIC_CTRL2			0x76
+/* Format - TDM Control */
+#define RT5645_TDM_CTRL_1			0x77
+#define RT5645_TDM_CTRL_2			0x78
+#define RT5645_TDM_CTRL_3			0x79
+
+/* Function - Analog */
+#define RT5645_GLB_CLK				0x80
+#define RT5645_PLL_CTRL1			0x81
+#define RT5645_PLL_CTRL2			0x82
+#define RT5645_ASRC_1				0x83
+#define RT5645_ASRC_2				0x84
+#define RT5645_ASRC_3				0x85
+#define RT5645_ASRC_8				0x8a
+#define RT5645_DEPOP_M1				0x8e
+#define RT5645_DEPOP_M2				0x8f
+#define RT5645_DEPOP_M3				0x90
+#define RT5645_CHARGE_PUMP			0x91
+#define RT5645_MICBIAS				0x93
+#define RT5645_A_JD_CTRL1			0x94
+#define RT5645_A_JD_CTRL2			0x95
+#define RT5645_VAD_CTRL1			0x9a
+#define RT5645_VAD_CTRL2			0x9b
+#define RT5645_VAD_CTRL3			0x9c
+#define RT5645_VAD_CTRL4			0x9d
+#define RT5645_VAD_CTRL5			0x9e
+#define RT5645_CLSD_OUT_CTRL			0xa0
+#define RT5645_CLSD_OUT_CTRL1			0xa1
+#define RT5645_CLSD_OUT_CTRL2			0xa2
+/* Function - Digital */
+#define RT5645_ADC_EQ_CTRL1			0xae
+#define RT5645_ADC_EQ_CTRL2			0xaf
+#define RT5645_EQ_CTRL1				0xb0
+#define RT5645_EQ_CTRL2				0xb1
+#define RT5645_ALC_DRC_CTRL1			0xb2
+#define RT5645_ALC_DRC_CTRL2			0xb3
+#define RT5645_ALC_CTRL_1			0xb4
+#define RT5645_ALC_CTRL_2			0xb5
+#define RT5645_ALC_CTRL_3			0xb6
+#define RT5645_ALC_CTRL_4			0xb7
+#define RT5645_JD_CTRL				0xbb
+#define RT5645_IRQ_CTRL1			0xbc
+#define RT5645_IRQ_CTRL2			0xbd
+#define RT5645_IRQ_CTRL3			0xbe
+#define RT5645_INT_IRQ_ST			0xbf
+#define RT5645_GPIO_CTRL1			0xc0
+#define RT5645_GPIO_CTRL2			0xc1
+#define RT5645_GPIO_CTRL3			0xc2
+#define RT5645_GPIO_CTRL4			0xc3
+#define RT5645_SCRABBLE_FUN			0xcd
+#define RT5645_SCRABBLE_CTRL			0xce
+#define RT5645_BASE_BACK			0xcf
+#define RT5645_MP3_PLUS1			0xd0
+#define RT5645_MP3_PLUS2			0xd1
+#define RT5645_ADJ_HPF1				0xd3
+#define RT5645_ADJ_HPF2				0xd4
+#define RT5645_HP_CALIB_AMP_DET			0xd6
+#define RT5645_SV_ZCD1				0xd9
+#define RT5645_SV_ZCD2				0xda
+#define RT5645_IL_CMD				0xdb
+#define RT5645_IL_CMD2				0xdc
+#define RT5645_IL_CMD3				0xdd
+#define RT5645_DRC1_HL_CTRL1			0xe6
+#define RT5645_DRC1_HL_CTRL2			0xe7
+#define RT5645_DRC2_HL_CTRL1			0xe8
+#define RT5645_DRC2_HL_CTRL2			0xe9
+#define RT5645_MUTI_DRC_CTRL1			0xea
+#define RT5645_ADC_MONO_HP_CTRL1		0xec
+#define RT5645_ADC_MONO_HP_CTRL2		0xed
+#define RT5645_DRC2_CTRL1			0xf0
+#define RT5645_DRC2_CTRL2			0xf1
+#define RT5645_DRC2_CTRL3			0xf2
+#define RT5645_DRC2_CTRL4			0xf3
+#define RT5645_DRC2_CTRL5			0xf4
+#define RT5645_JD_CTRL3				0xf8
+#define RT5645_JD_CTRL4				0xf9
+/* General Control */
+#define RT5645_DIG_MISC				0xfa
+#define RT5645_GEN_CTRL2			0xfb
+#define RT5645_GEN_CTRL3			0xfc
+
+
+/* Index of Codec Private Register definition */
+#define RT5645_DIG_VOL				0x00
+#define RT5645_PR_ALC_CTRL_1			0x01
+#define RT5645_PR_ALC_CTRL_2			0x02
+#define RT5645_PR_ALC_CTRL_3			0x03
+#define RT5645_PR_ALC_CTRL_4			0x04
+#define RT5645_PR_ALC_CTRL_5			0x05
+#define RT5645_PR_ALC_CTRL_6			0x06
+#define RT5645_BIAS_CUR1			0x12
+#define RT5645_BIAS_CUR3			0x14
+#define RT5645_CLSD_INT_REG1			0x1c
+#define RT5645_MAMP_INT_REG2			0x37
+#define RT5645_CHOP_DAC_ADC			0x3d
+#define RT5645_MIXER_INT_REG			0x3f
+#define RT5645_3D_SPK				0x63
+#define RT5645_WND_1				0x6c
+#define RT5645_WND_2				0x6d
+#define RT5645_WND_3				0x6e
+#define RT5645_WND_4				0x6f
+#define RT5645_WND_5				0x70
+#define RT5645_WND_8				0x73
+#define RT5645_DIP_SPK_INF			0x75
+#define RT5645_HP_DCC_INT1			0x77
+#define RT5645_EQ_BW_LOP			0xa0
+#define RT5645_EQ_GN_LOP			0xa1
+#define RT5645_EQ_FC_BP1			0xa2
+#define RT5645_EQ_BW_BP1			0xa3
+#define RT5645_EQ_GN_BP1			0xa4
+#define RT5645_EQ_FC_BP2			0xa5
+#define RT5645_EQ_BW_BP2			0xa6
+#define RT5645_EQ_GN_BP2			0xa7
+#define RT5645_EQ_FC_BP3			0xa8
+#define RT5645_EQ_BW_BP3			0xa9
+#define RT5645_EQ_GN_BP3			0xaa
+#define RT5645_EQ_FC_BP4			0xab
+#define RT5645_EQ_BW_BP4			0xac
+#define RT5645_EQ_GN_BP4			0xad
+#define RT5645_EQ_FC_HIP1			0xae
+#define RT5645_EQ_GN_HIP1			0xaf
+#define RT5645_EQ_FC_HIP2			0xb0
+#define RT5645_EQ_BW_HIP2			0xb1
+#define RT5645_EQ_GN_HIP2			0xb2
+#define RT5645_EQ_PRE_VOL			0xb3
+#define RT5645_EQ_PST_VOL			0xb4
+
+
+/* global definition */
+#define RT5645_L_MUTE				(0x1 << 15)
+#define RT5645_L_MUTE_SFT			15
+#define RT5645_VOL_L_MUTE			(0x1 << 14)
+#define RT5645_VOL_L_SFT			14
+#define RT5645_R_MUTE				(0x1 << 7)
+#define RT5645_R_MUTE_SFT			7
+#define RT5645_VOL_R_MUTE			(0x1 << 6)
+#define RT5645_VOL_R_SFT			6
+#define RT5645_L_VOL_MASK			(0x3f << 8)
+#define RT5645_L_VOL_SFT			8
+#define RT5645_R_VOL_MASK			(0x3f)
+#define RT5645_R_VOL_SFT			0
+
+/* Combo Jack Control 1 (0x0a) */
+#define RT5645_CBJ_BST1_MASK			(0xf << 12)
+#define RT5645_CBJ_BST1_SFT			(12)
+#define RT5645_CBJ_JD_HP_EN			(0x1 << 9)
+#define RT5645_CBJ_JD_MIC_EN			(0x1 << 8)
+#define RT5645_CBJ_JD_MIC_SW_EN			(0x1 << 7)
+#define RT5645_CBJ_MIC_SEL_R			(0x1 << 6)
+#define RT5645_CBJ_MIC_SEL_L			(0x1 << 5)
+#define RT5645_CBJ_MIC_SW			(0x1 << 4)
+#define RT5645_CBJ_BST1_EN			(0x1 << 2)
+
+/* Combo Jack Control 2 (0x0b) */
+#define RT5645_CBJ_MN_JD			(0x1 << 12)
+#define RT5645_CAPLESS_EN			(0x1 << 11)
+#define RT5645_CBJ_DET_MODE			(0x1 << 7)
+
+/* Combo Jack Control 3 (0x0c) */
+#define RT5645_CBJ_TIE_G_L			(0x1 << 15)
+#define RT5645_CBJ_TIE_G_R			(0x1 << 14)
+
+/* IN1 and IN2 Control (0x0d) */
+/* IN3 and IN4 Control (0x0e) */
+#define RT5645_BST_MASK1			(0xf<<12)
+#define RT5645_BST_SFT1				12
+#define RT5645_BST_MASK2			(0xf<<8)
+#define RT5645_BST_SFT2				8
+#define RT5645_IN_DF1				(0x1 << 7)
+#define RT5645_IN_SFT1				7
+#define RT5645_IN_DF2				(0x1 << 6)
+#define RT5645_IN_SFT2				6
+
+/* INL and INR Volume Control (0x0f) */
+#define RT5645_INL_SEL_MASK			(0x1 << 15)
+#define RT5645_INL_SEL_SFT			15
+#define RT5645_INL_SEL_IN4P			(0x0 << 15)
+#define RT5645_INL_SEL_MONOP			(0x1 << 15)
+#define RT5645_INL_VOL_MASK			(0x1f << 8)
+#define RT5645_INL_VOL_SFT			8
+#define RT5645_INR_SEL_MASK			(0x1 << 7)
+#define RT5645_INR_SEL_SFT			7
+#define RT5645_INR_SEL_IN4N			(0x0 << 7)
+#define RT5645_INR_SEL_MONON			(0x1 << 7)
+#define RT5645_INR_VOL_MASK			(0x1f)
+#define RT5645_INR_VOL_SFT			0
+
+/* Sidetone Control (0x18) */
+#define RT5645_ST_SEL_MASK			(0x7 << 9)
+#define RT5645_ST_SEL_SFT			9
+#define RT5645_M_ST_DACR2			(0x1 << 8)
+#define RT5645_M_ST_DACR2_SFT			8
+#define RT5645_M_ST_DACL2			(0x1 << 7)
+#define RT5645_M_ST_DACL2_SFT			7
+#define RT5645_ST_EN				(0x1 << 6)
+#define RT5645_ST_EN_SFT			6
+
+/* DAC1 Digital Volume (0x19) */
+#define RT5645_DAC_L1_VOL_MASK			(0xff << 8)
+#define RT5645_DAC_L1_VOL_SFT			8
+#define RT5645_DAC_R1_VOL_MASK			(0xff)
+#define RT5645_DAC_R1_VOL_SFT			0
+
+/* DAC2 Digital Volume (0x1a) */
+#define RT5645_DAC_L2_VOL_MASK			(0xff << 8)
+#define RT5645_DAC_L2_VOL_SFT			8
+#define RT5645_DAC_R2_VOL_MASK			(0xff)
+#define RT5645_DAC_R2_VOL_SFT			0
+
+/* DAC2 Control (0x1b) */
+#define RT5645_M_DAC_L2_VOL			(0x1 << 13)
+#define RT5645_M_DAC_L2_VOL_SFT			13
+#define RT5645_M_DAC_R2_VOL			(0x1 << 12)
+#define RT5645_M_DAC_R2_VOL_SFT			12
+#define RT5645_DAC2_L_SEL_MASK			(0x7 << 4)
+#define RT5645_DAC2_L_SEL_SFT			4
+#define RT5645_DAC2_R_SEL_MASK			(0x7 << 0)
+#define RT5645_DAC2_R_SEL_SFT			0
+
+/* ADC Digital Volume Control (0x1c) */
+#define RT5645_ADC_L_VOL_MASK			(0x7f << 8)
+#define RT5645_ADC_L_VOL_SFT			8
+#define RT5645_ADC_R_VOL_MASK			(0x7f)
+#define RT5645_ADC_R_VOL_SFT			0
+
+/* Mono ADC Digital Volume Control (0x1d) */
+#define RT5645_MONO_ADC_L_VOL_MASK		(0x7f << 8)
+#define RT5645_MONO_ADC_L_VOL_SFT		8
+#define RT5645_MONO_ADC_R_VOL_MASK		(0x7f)
+#define RT5645_MONO_ADC_R_VOL_SFT		0
+
+/* ADC Boost Volume Control (0x1e) */
+#define RT5645_STO1_ADC_L_BST_MASK		(0x3 << 14)
+#define RT5645_STO1_ADC_L_BST_SFT		14
+#define RT5645_STO1_ADC_R_BST_MASK		(0x3 << 12)
+#define RT5645_STO1_ADC_R_BST_SFT		12
+#define RT5645_STO1_ADC_COMP_MASK		(0x3 << 10)
+#define RT5645_STO1_ADC_COMP_SFT		10
+#define RT5645_STO2_ADC_L_BST_MASK		(0x3 << 8)
+#define RT5645_STO2_ADC_L_BST_SFT		8
+#define RT5645_STO2_ADC_R_BST_MASK		(0x3 << 6)
+#define RT5645_STO2_ADC_R_BST_SFT		6
+#define RT5645_STO2_ADC_COMP_MASK		(0x3 << 4)
+#define RT5645_STO2_ADC_COMP_SFT		4
+
+/* Stereo2 ADC Mixer Control (0x26) */
+#define RT5645_STO2_ADC_SRC_MASK		(0x1 << 15)
+#define RT5645_STO2_ADC_SRC_SFT			15
+
+/* Stereo ADC Mixer Control (0x27) */
+#define RT5645_M_ADC_L1				(0x1 << 14)
+#define RT5645_M_ADC_L1_SFT			14
+#define RT5645_M_ADC_L2				(0x1 << 13)
+#define RT5645_M_ADC_L2_SFT			13
+#define RT5645_ADC_1_SRC_MASK			(0x1 << 12)
+#define RT5645_ADC_1_SRC_SFT			12
+#define RT5645_ADC_1_SRC_ADC			(0x1 << 12)
+#define RT5645_ADC_1_SRC_DACMIX			(0x0 << 12)
+#define RT5645_ADC_2_SRC_MASK			(0x1 << 11)
+#define RT5645_ADC_2_SRC_SFT			11
+#define RT5645_DMIC_SRC_MASK			(0x1 << 8)
+#define RT5645_DMIC_SRC_SFT			8
+#define RT5645_M_ADC_R1				(0x1 << 6)
+#define RT5645_M_ADC_R1_SFT			6
+#define RT5645_M_ADC_R2				(0x1 << 5)
+#define RT5645_M_ADC_R2_SFT			5
+#define RT5645_DMIC3_SRC_MASK			(0x1 << 1)
+#define RT5645_DMIC3_SRC_SFT			0
+
+/* Mono ADC Mixer Control (0x28) */
+#define RT5645_M_MONO_ADC_L1			(0x1 << 14)
+#define RT5645_M_MONO_ADC_L1_SFT		14
+#define RT5645_M_MONO_ADC_L2			(0x1 << 13)
+#define RT5645_M_MONO_ADC_L2_SFT		13
+#define RT5645_MONO_ADC_L1_SRC_MASK		(0x1 << 12)
+#define RT5645_MONO_ADC_L1_SRC_SFT		12
+#define RT5645_MONO_ADC_L1_SRC_DACMIXL		(0x0 << 12)
+#define RT5645_MONO_ADC_L1_SRC_ADCL		(0x1 << 12)
+#define RT5645_MONO_ADC_L2_SRC_MASK		(0x1 << 11)
+#define RT5645_MONO_ADC_L2_SRC_SFT		11
+#define RT5645_MONO_DMIC_L_SRC_MASK		(0x1 << 8)
+#define RT5645_MONO_DMIC_L_SRC_SFT		8
+#define RT5645_M_MONO_ADC_R1			(0x1 << 6)
+#define RT5645_M_MONO_ADC_R1_SFT		6
+#define RT5645_M_MONO_ADC_R2			(0x1 << 5)
+#define RT5645_M_MONO_ADC_R2_SFT		5
+#define RT5645_MONO_ADC_R1_SRC_MASK		(0x1 << 4)
+#define RT5645_MONO_ADC_R1_SRC_SFT		4
+#define RT5645_MONO_ADC_R1_SRC_ADCR		(0x1 << 4)
+#define RT5645_MONO_ADC_R1_SRC_DACMIXR		(0x0 << 4)
+#define RT5645_MONO_ADC_R2_SRC_MASK		(0x1 << 3)
+#define RT5645_MONO_ADC_R2_SRC_SFT		3
+#define RT5645_MONO_DMIC_R_SRC_MASK		(0x3)
+#define RT5645_MONO_DMIC_R_SRC_SFT		0
+
+/* ADC Mixer to DAC Mixer Control (0x29) */
+#define RT5645_M_ADCMIX_L			(0x1 << 15)
+#define RT5645_M_ADCMIX_L_SFT			15
+#define RT5645_M_DAC1_L				(0x1 << 14)
+#define RT5645_M_DAC1_L_SFT			14
+#define RT5645_DAC1_R_SEL_MASK			(0x3 << 10)
+#define RT5645_DAC1_R_SEL_SFT			10
+#define RT5645_DAC1_R_SEL_IF1			(0x0 << 10)
+#define RT5645_DAC1_R_SEL_IF2			(0x1 << 10)
+#define RT5645_DAC1_R_SEL_IF3			(0x2 << 10)
+#define RT5645_DAC1_R_SEL_IF4			(0x3 << 10)
+#define RT5645_DAC1_L_SEL_MASK			(0x3 << 8)
+#define RT5645_DAC1_L_SEL_SFT			8
+#define RT5645_DAC1_L_SEL_IF1			(0x0 << 8)
+#define RT5645_DAC1_L_SEL_IF2			(0x1 << 8)
+#define RT5645_DAC1_L_SEL_IF3			(0x2 << 8)
+#define RT5645_DAC1_L_SEL_IF4			(0x3 << 8)
+#define RT5645_M_ADCMIX_R			(0x1 << 7)
+#define RT5645_M_ADCMIX_R_SFT			7
+#define RT5645_M_DAC1_R				(0x1 << 6)
+#define RT5645_M_DAC1_R_SFT			6
+
+/* Stereo DAC Mixer Control (0x2a) */
+#define RT5645_M_DAC_L1				(0x1 << 14)
+#define RT5645_M_DAC_L1_SFT			14
+#define RT5645_DAC_L1_STO_L_VOL_MASK		(0x1 << 13)
+#define RT5645_DAC_L1_STO_L_VOL_SFT		13
+#define RT5645_M_DAC_L2				(0x1 << 12)
+#define RT5645_M_DAC_L2_SFT			12
+#define RT5645_DAC_L2_STO_L_VOL_MASK		(0x1 << 11)
+#define RT5645_DAC_L2_STO_L_VOL_SFT		11
+#define RT5645_M_ANC_DAC_L			(0x1 << 10)
+#define RT5645_M_ANC_DAC_L_SFT			10
+#define RT5645_M_DAC_R1_STO_L			(0x1 << 9)
+#define RT5645_M_DAC_R1_STO_L_SFT			9
+#define RT5645_DAC_R1_STO_L_VOL_MASK		(0x1 << 8)
+#define RT5645_DAC_R1_STO_L_VOL_SFT		8
+#define RT5645_M_DAC_R1				(0x1 << 6)
+#define RT5645_M_DAC_R1_SFT			6
+#define RT5645_DAC_R1_STO_R_VOL_MASK		(0x1 << 5)
+#define RT5645_DAC_R1_STO_R_VOL_SFT		5
+#define RT5645_M_DAC_R2				(0x1 << 4)
+#define RT5645_M_DAC_R2_SFT			4
+#define RT5645_DAC_R2_STO_R_VOL_MASK		(0x1 << 3)
+#define RT5645_DAC_R2_STO_R_VOL_SFT		3
+#define RT5645_M_ANC_DAC_R			(0x1 << 2)
+#define RT5645_M_ANC_DAC_R_SFT			2
+#define RT5645_M_DAC_L1_STO_R			(0x1 << 1)
+#define RT5645_M_DAC_L1_STO_R_SFT			1
+#define RT5645_DAC_L1_STO_R_VOL_MASK		(0x1)
+#define RT5645_DAC_L1_STO_R_VOL_SFT		0
+
+/* Mono DAC Mixer Control (0x2b) */
+#define RT5645_M_DAC_L1_MONO_L			(0x1 << 14)
+#define RT5645_M_DAC_L1_MONO_L_SFT		14
+#define RT5645_DAC_L1_MONO_L_VOL_MASK		(0x1 << 13)
+#define RT5645_DAC_L1_MONO_L_VOL_SFT		13
+#define RT5645_M_DAC_L2_MONO_L			(0x1 << 12)
+#define RT5645_M_DAC_L2_MONO_L_SFT		12
+#define RT5645_DAC_L2_MONO_L_VOL_MASK		(0x1 << 11)
+#define RT5645_DAC_L2_MONO_L_VOL_SFT		11
+#define RT5645_M_DAC_R2_MONO_L			(0x1 << 10)
+#define RT5645_M_DAC_R2_MONO_L_SFT		10
+#define RT5645_DAC_R2_MONO_L_VOL_MASK		(0x1 << 9)
+#define RT5645_DAC_R2_MONO_L_VOL_SFT		9
+#define RT5645_M_DAC_R1_MONO_R			(0x1 << 6)
+#define RT5645_M_DAC_R1_MONO_R_SFT		6
+#define RT5645_DAC_R1_MONO_R_VOL_MASK		(0x1 << 5)
+#define RT5645_DAC_R1_MONO_R_VOL_SFT		5
+#define RT5645_M_DAC_R2_MONO_R			(0x1 << 4)
+#define RT5645_M_DAC_R2_MONO_R_SFT		4
+#define RT5645_DAC_R2_MONO_R_VOL_MASK		(0x1 << 3)
+#define RT5645_DAC_R2_MONO_R_VOL_SFT		3
+#define RT5645_M_DAC_L2_MONO_R			(0x1 << 2)
+#define RT5645_M_DAC_L2_MONO_R_SFT		2
+#define RT5645_DAC_L2_MONO_R_VOL_MASK		(0x1 << 1)
+#define RT5645_DAC_L2_MONO_R_VOL_SFT		1
+
+/* Digital Mixer Control (0x2c) */
+#define RT5645_M_STO_L_DAC_L			(0x1 << 15)
+#define RT5645_M_STO_L_DAC_L_SFT		15
+#define RT5645_STO_L_DAC_L_VOL_MASK		(0x1 << 14)
+#define RT5645_STO_L_DAC_L_VOL_SFT		14
+#define RT5645_M_DAC_L2_DAC_L			(0x1 << 13)
+#define RT5645_M_DAC_L2_DAC_L_SFT		13
+#define RT5645_DAC_L2_DAC_L_VOL_MASK		(0x1 << 12)
+#define RT5645_DAC_L2_DAC_L_VOL_SFT		12
+#define RT5645_M_STO_R_DAC_R			(0x1 << 11)
+#define RT5645_M_STO_R_DAC_R_SFT		11
+#define RT5645_STO_R_DAC_R_VOL_MASK		(0x1 << 10)
+#define RT5645_STO_R_DAC_R_VOL_SFT		10
+#define RT5645_M_DAC_R2_DAC_R			(0x1 << 9)
+#define RT5645_M_DAC_R2_DAC_R_SFT		9
+#define RT5645_DAC_R2_DAC_R_VOL_MASK		(0x1 << 8)
+#define RT5645_DAC_R2_DAC_R_VOL_SFT		8
+#define RT5645_M_DAC_R2_DAC_L			(0x1 << 7)
+#define RT5645_M_DAC_R2_DAC_L_SFT		7
+#define RT5645_DAC_R2_DAC_L_VOL_MASK		(0x1 << 6)
+#define RT5645_DAC_R2_DAC_L_VOL_SFT		6
+#define RT5645_M_DAC_L2_DAC_R			(0x1 << 5)
+#define RT5645_M_DAC_L2_DAC_R_SFT		5
+#define RT5645_DAC_L2_DAC_R_VOL_MASK		(0x1 << 4)
+#define RT5645_DAC_L2_DAC_R_VOL_SFT		4
+
+/* DSP Path Control 1 (0x2d) */
+#define RT5645_RXDP_SEL_MASK			(0x7 << 13)
+#define RT5645_RXDP_SEL_SFT			13
+#define RT5645_RXDP_SRC_MASK			(0x1 << 15)
+#define RT5645_RXDP_SRC_SFT			15
+#define RT5645_RXDP_SRC_NOR			(0x0 << 15)
+#define RT5645_RXDP_SRC_DIV3			(0x1 << 15)
+#define RT5645_TXDP_SRC_MASK			(0x1 << 14)
+#define RT5645_TXDP_SRC_SFT			14
+#define RT5645_TXDP_SRC_NOR			(0x0 << 14)
+#define RT5645_TXDP_SRC_DIV3			(0x1 << 14)
+#define RT5645_DSP_UL_SEL			(0x1 << 1)
+#define RT5645_DSP_UL_SFT			1
+#define RT5645_DSP_DL_SEL			0x1
+#define RT5645_DSP_DL_SFT			0
+
+/* DSP Path Control 2 (0x2e) */
+#define RT5645_TXDP_L_VOL_MASK			(0x7f << 8)
+#define RT5645_TXDP_L_VOL_SFT			8
+#define RT5645_TXDP_R_VOL_MASK			(0x7f)
+#define RT5645_TXDP_R_VOL_SFT			0
+
+/* Digital Interface Data Control (0x2f) */
+#define RT5645_IF1_ADC2_IN_SEL			(0x1 << 15)
+#define RT5645_IF1_ADC2_IN_SFT			15
+#define RT5645_IF2_ADC_IN_MASK			(0x7 << 12)
+#define RT5645_IF2_ADC_IN_SFT			12
+#define RT5645_IF2_DAC_SEL_MASK			(0x3 << 10)
+#define RT5645_IF2_DAC_SEL_SFT			10
+#define RT5645_IF2_ADC_SEL_MASK			(0x3 << 8)
+#define RT5645_IF2_ADC_SEL_SFT			8
+#define RT5645_IF3_DAC_SEL_MASK			(0x3 << 6)
+#define RT5645_IF3_DAC_SEL_SFT			6
+#define RT5645_IF3_ADC_SEL_MASK			(0x3 << 4)
+#define RT5645_IF3_ADC_SEL_SFT			4
+#define RT5645_IF3_ADC_IN_MASK			(0x7)
+#define RT5645_IF3_ADC_IN_SFT			0
+
+/* PDM Output Control (0x31) */
+#define RT5645_PDM1_L_MASK			(0x1 << 15)
+#define RT5645_PDM1_L_SFT			15
+#define RT5645_M_PDM1_L				(0x1 << 14)
+#define RT5645_M_PDM1_L_SFT			14
+#define RT5645_PDM1_R_MASK			(0x1 << 13)
+#define RT5645_PDM1_R_SFT			13
+#define RT5645_M_PDM1_R				(0x1 << 12)
+#define RT5645_M_PDM1_R_SFT			12
+#define RT5645_PDM2_L_MASK			(0x1 << 11)
+#define RT5645_PDM2_L_SFT			11
+#define RT5645_M_PDM2_L				(0x1 << 10)
+#define RT5645_M_PDM2_L_SFT			10
+#define RT5645_PDM2_R_MASK			(0x1 << 9)
+#define RT5645_PDM2_R_SFT			9
+#define RT5645_M_PDM2_R				(0x1 << 8)
+#define RT5645_M_PDM2_R_SFT			8
+#define RT5645_PDM2_BUSY			(0x1 << 7)
+#define RT5645_PDM1_BUSY			(0x1 << 6)
+#define RT5645_PDM_PATTERN			(0x1 << 5)
+#define RT5645_PDM_GAIN				(0x1 << 4)
+#define RT5645_PDM_DIV_MASK			(0x3)
+
+/* REC Left Mixer Control 1 (0x3b) */
+#define RT5645_G_HP_L_RM_L_MASK			(0x7 << 13)
+#define RT5645_G_HP_L_RM_L_SFT			13
+#define RT5645_G_IN_L_RM_L_MASK			(0x7 << 10)
+#define RT5645_G_IN_L_RM_L_SFT			10
+#define RT5645_G_BST4_RM_L_MASK			(0x7 << 7)
+#define RT5645_G_BST4_RM_L_SFT			7
+#define RT5645_G_BST3_RM_L_MASK			(0x7 << 4)
+#define RT5645_G_BST3_RM_L_SFT			4
+#define RT5645_G_BST2_RM_L_MASK			(0x7 << 1)
+#define RT5645_G_BST2_RM_L_SFT			1
+
+/* REC Left Mixer Control 2 (0x3c) */
+#define RT5645_G_BST1_RM_L_MASK			(0x7 << 13)
+#define RT5645_G_BST1_RM_L_SFT			13
+#define RT5645_G_OM_L_RM_L_MASK			(0x7 << 10)
+#define RT5645_G_OM_L_RM_L_SFT			10
+#define RT5645_M_MM_L_RM_L			(0x1 << 6)
+#define RT5645_M_MM_L_RM_L_SFT			6
+#define RT5645_M_IN_L_RM_L			(0x1 << 5)
+#define RT5645_M_IN_L_RM_L_SFT			5
+#define RT5645_M_HP_L_RM_L			(0x1 << 4)
+#define RT5645_M_HP_L_RM_L_SFT			4
+#define RT5645_M_BST3_RM_L			(0x1 << 3)
+#define RT5645_M_BST3_RM_L_SFT			3
+#define RT5645_M_BST2_RM_L			(0x1 << 2)
+#define RT5645_M_BST2_RM_L_SFT			2
+#define RT5645_M_BST1_RM_L			(0x1 << 1)
+#define RT5645_M_BST1_RM_L_SFT			1
+#define RT5645_M_OM_L_RM_L			(0x1)
+#define RT5645_M_OM_L_RM_L_SFT			0
+
+/* REC Right Mixer Control 1 (0x3d) */
+#define RT5645_G_HP_R_RM_R_MASK			(0x7 << 13)
+#define RT5645_G_HP_R_RM_R_SFT			13
+#define RT5645_G_IN_R_RM_R_MASK			(0x7 << 10)
+#define RT5645_G_IN_R_RM_R_SFT			10
+#define RT5645_G_BST4_RM_R_MASK			(0x7 << 7)
+#define RT5645_G_BST4_RM_R_SFT			7
+#define RT5645_G_BST3_RM_R_MASK			(0x7 << 4)
+#define RT5645_G_BST3_RM_R_SFT			4
+#define RT5645_G_BST2_RM_R_MASK			(0x7 << 1)
+#define RT5645_G_BST2_RM_R_SFT			1
+
+/* REC Right Mixer Control 2 (0x3e) */
+#define RT5645_G_BST1_RM_R_MASK			(0x7 << 13)
+#define RT5645_G_BST1_RM_R_SFT			13
+#define RT5645_G_OM_R_RM_R_MASK			(0x7 << 10)
+#define RT5645_G_OM_R_RM_R_SFT			10
+#define RT5645_M_MM_R_RM_R			(0x1 << 6)
+#define RT5645_M_MM_R_RM_R_SFT			6
+#define RT5645_M_IN_R_RM_R			(0x1 << 5)
+#define RT5645_M_IN_R_RM_R_SFT			5
+#define RT5645_M_HP_R_RM_R			(0x1 << 4)
+#define RT5645_M_HP_R_RM_R_SFT			4
+#define RT5645_M_BST3_RM_R			(0x1 << 3)
+#define RT5645_M_BST3_RM_R_SFT			3
+#define RT5645_M_BST2_RM_R			(0x1 << 2)
+#define RT5645_M_BST2_RM_R_SFT			2
+#define RT5645_M_BST1_RM_R			(0x1 << 1)
+#define RT5645_M_BST1_RM_R_SFT			1
+#define RT5645_M_OM_R_RM_R			(0x1)
+#define RT5645_M_OM_R_RM_R_SFT			0
+
+/* HPOMIX Control (0x40) (0x42) */
+#define RT5645_M_BST1_HV			(0x1 << 4)
+#define RT5645_M_BST1_HV_SFT			4
+#define RT5645_M_BST2_HV			(0x1 << 4)
+#define RT5645_M_BST2_HV_SFT			4
+#define RT5645_M_BST3_HV			(0x1 << 3)
+#define RT5645_M_BST3_HV_SFT			3
+#define RT5645_M_IN_HV				(0x1 << 2)
+#define RT5645_M_IN_HV_SFT			2
+#define RT5645_M_DAC2_HV			(0x1 << 1)
+#define RT5645_M_DAC2_HV_SFT			1
+#define RT5645_M_DAC1_HV			(0x1 << 0)
+#define RT5645_M_DAC1_HV_SFT			0
+
+/* HPMIX Control (0x45) */
+#define RT5645_M_DAC1_HM			(0x1 << 14)
+#define RT5645_M_DAC1_HM_SFT			14
+#define RT5645_M_HPVOL_HM			(0x1 << 13)
+#define RT5645_M_HPVOL_HM_SFT			13
+
+/* SPK Left Mixer Control (0x46) */
+#define RT5645_G_RM_L_SM_L_MASK			(0x3 << 14)
+#define RT5645_G_RM_L_SM_L_SFT			14
+#define RT5645_G_IN_L_SM_L_MASK			(0x3 << 12)
+#define RT5645_G_IN_L_SM_L_SFT			12
+#define RT5645_G_DAC_L1_SM_L_MASK		(0x3 << 10)
+#define RT5645_G_DAC_L1_SM_L_SFT		10
+#define RT5645_G_DAC_L2_SM_L_MASK		(0x3 << 8)
+#define RT5645_G_DAC_L2_SM_L_SFT		8
+#define RT5645_G_OM_L_SM_L_MASK			(0x3 << 6)
+#define RT5645_G_OM_L_SM_L_SFT			6
+#define RT5645_M_BST1_L_SM_L			(0x1 << 5)
+#define RT5645_M_BST1_L_SM_L_SFT		5
+#define RT5645_M_IN_L_SM_L			(0x1 << 3)
+#define RT5645_M_IN_L_SM_L_SFT			3
+#define RT5645_M_DAC_L1_SM_L			(0x1 << 1)
+#define RT5645_M_DAC_L1_SM_L_SFT		1
+#define RT5645_M_DAC_L2_SM_L			(0x1 << 2)
+#define RT5645_M_DAC_L2_SM_L_SFT		2
+#define RT5645_M_BST3_L_SM_L			(0x1 << 4)
+#define RT5645_M_BST3_L_SM_L_SFT		4
+
+/* SPK Right Mixer Control (0x47) */
+#define RT5645_G_RM_R_SM_R_MASK			(0x3 << 14)
+#define RT5645_G_RM_R_SM_R_SFT			14
+#define RT5645_G_IN_R_SM_R_MASK			(0x3 << 12)
+#define RT5645_G_IN_R_SM_R_SFT			12
+#define RT5645_G_DAC_R1_SM_R_MASK		(0x3 << 10)
+#define RT5645_G_DAC_R1_SM_R_SFT		10
+#define RT5645_G_DAC_R2_SM_R_MASK		(0x3 << 8)
+#define RT5645_G_DAC_R2_SM_R_SFT		8
+#define RT5645_G_OM_R_SM_R_MASK			(0x3 << 6)
+#define RT5645_G_OM_R_SM_R_SFT			6
+#define RT5645_M_BST2_R_SM_R			(0x1 << 5)
+#define RT5645_M_BST2_R_SM_R_SFT		5
+#define RT5645_M_IN_R_SM_R			(0x1 << 3)
+#define RT5645_M_IN_R_SM_R_SFT			3
+#define RT5645_M_DAC_R1_SM_R			(0x1 << 1)
+#define RT5645_M_DAC_R1_SM_R_SFT		1
+#define RT5645_M_DAC_R2_SM_R			(0x1 << 2)
+#define RT5645_M_DAC_R2_SM_R_SFT		2
+#define RT5645_M_BST3_R_SM_R			(0x1 << 4)
+#define RT5645_M_BST3_R_SM_R_SFT		4
+
+/* SPOLMIX Control (0x48) */
+#define RT5645_M_DAC_L1_SPM_L			(0x1 << 15)
+#define RT5645_M_DAC_L1_SPM_L_SFT		15
+#define RT5645_M_DAC_R1_SPM_L			(0x1 << 14)
+#define RT5645_M_DAC_R1_SPM_L_SFT		14
+#define RT5645_M_SV_L_SPM_L			(0x1 << 13)
+#define RT5645_M_SV_L_SPM_L_SFT			13
+#define RT5645_M_SV_R_SPM_L			(0x1 << 12)
+#define RT5645_M_SV_R_SPM_L_SFT			12
+#define RT5645_M_BST3_SPM_L			(0x1 << 11)
+#define RT5645_M_BST3_SPM_L_SFT			11
+#define RT5645_M_DAC_R1_SPM_R			(0x1 << 2)
+#define RT5645_M_DAC_R1_SPM_R_SFT		2
+#define RT5645_M_BST3_SPM_R			(0x1 << 1)
+#define RT5645_M_BST3_SPM_R_SFT			1
+#define RT5645_M_SV_R_SPM_R			(0x1 << 0)
+#define RT5645_M_SV_R_SPM_R_SFT			0
+
+/* Mono Output Mixer Control (0x4c) */
+#define RT5645_M_OV_L_MM			(0x1 << 9)
+#define RT5645_M_OV_L_MM_SFT			9
+#define RT5645_M_DAC_L2_MA			(0x1 << 8)
+#define RT5645_M_DAC_L2_MA_SFT			8
+#define RT5645_G_MONOMIX_MASK			(0x1 << 10)
+#define RT5645_G_MONOMIX_SFT			10
+#define RT5645_M_BST2_MM			(0x1 << 4)
+#define RT5645_M_BST2_MM_SFT			4
+#define RT5645_M_DAC_R1_MM			(0x1 << 3)
+#define RT5645_M_DAC_R1_MM_SFT			3
+#define RT5645_M_DAC_R2_MM			(0x1 << 2)
+#define RT5645_M_DAC_R2_MM_SFT			2
+#define RT5645_M_DAC_L2_MM			(0x1 << 1)
+#define RT5645_M_DAC_L2_MM_SFT			1
+#define RT5645_M_BST3_MM			(0x1 << 0)
+#define RT5645_M_BST3_MM_SFT			0
+
+/* Output Left Mixer Control 1 (0x4d) */
+#define RT5645_G_BST3_OM_L_MASK			(0x7 << 13)
+#define RT5645_G_BST3_OM_L_SFT			13
+#define RT5645_G_BST2_OM_L_MASK			(0x7 << 10)
+#define RT5645_G_BST2_OM_L_SFT			10
+#define RT5645_G_BST1_OM_L_MASK			(0x7 << 7)
+#define RT5645_G_BST1_OM_L_SFT			7
+#define RT5645_G_IN_L_OM_L_MASK			(0x7 << 4)
+#define RT5645_G_IN_L_OM_L_SFT			4
+#define RT5645_G_RM_L_OM_L_MASK			(0x7 << 1)
+#define RT5645_G_RM_L_OM_L_SFT			1
+
+/* Output Left Mixer Control 2 (0x4e) */
+#define RT5645_G_DAC_R2_OM_L_MASK		(0x7 << 13)
+#define RT5645_G_DAC_R2_OM_L_SFT		13
+#define RT5645_G_DAC_L2_OM_L_MASK		(0x7 << 10)
+#define RT5645_G_DAC_L2_OM_L_SFT		10
+#define RT5645_G_DAC_L1_OM_L_MASK		(0x7 << 7)
+#define RT5645_G_DAC_L1_OM_L_SFT		7
+
+/* Output Left Mixer Control 3 (0x4f) */
+#define RT5645_M_BST3_OM_L			(0x1 << 4)
+#define RT5645_M_BST3_OM_L_SFT			4
+#define RT5645_M_BST1_OM_L			(0x1 << 3)
+#define RT5645_M_BST1_OM_L_SFT			3
+#define RT5645_M_IN_L_OM_L			(0x1 << 2)
+#define RT5645_M_IN_L_OM_L_SFT			2
+#define RT5645_M_DAC_L2_OM_L			(0x1 << 1)
+#define RT5645_M_DAC_L2_OM_L_SFT		1
+#define RT5645_M_DAC_L1_OM_L			(0x1)
+#define RT5645_M_DAC_L1_OM_L_SFT		0
+
+/* Output Right Mixer Control 1 (0x50) */
+#define RT5645_G_BST4_OM_R_MASK			(0x7 << 13)
+#define RT5645_G_BST4_OM_R_SFT			13
+#define RT5645_G_BST2_OM_R_MASK			(0x7 << 10)
+#define RT5645_G_BST2_OM_R_SFT			10
+#define RT5645_G_BST1_OM_R_MASK			(0x7 << 7)
+#define RT5645_G_BST1_OM_R_SFT			7
+#define RT5645_G_IN_R_OM_R_MASK			(0x7 << 4)
+#define RT5645_G_IN_R_OM_R_SFT			4
+#define RT5645_G_RM_R_OM_R_MASK			(0x7 << 1)
+#define RT5645_G_RM_R_OM_R_SFT			1
+
+/* Output Right Mixer Control 2 (0x51) */
+#define RT5645_G_DAC_L2_OM_R_MASK		(0x7 << 13)
+#define RT5645_G_DAC_L2_OM_R_SFT		13
+#define RT5645_G_DAC_R2_OM_R_MASK		(0x7 << 10)
+#define RT5645_G_DAC_R2_OM_R_SFT		10
+#define RT5645_G_DAC_R1_OM_R_MASK		(0x7 << 7)
+#define RT5645_G_DAC_R1_OM_R_SFT		7
+
+/* Output Right Mixer Control 3 (0x52) */
+#define RT5645_M_BST3_OM_R			(0x1 << 4)
+#define RT5645_M_BST3_OM_R_SFT			4
+#define RT5645_M_BST2_OM_R			(0x1 << 3)
+#define RT5645_M_BST2_OM_R_SFT			3
+#define RT5645_M_IN_R_OM_R			(0x1 << 2)
+#define RT5645_M_IN_R_OM_R_SFT			2
+#define RT5645_M_DAC_R2_OM_R			(0x1 << 1)
+#define RT5645_M_DAC_R2_OM_R_SFT		1
+#define RT5645_M_DAC_R1_OM_R			(0x1)
+#define RT5645_M_DAC_R1_OM_R_SFT		0
+
+/* LOUT Mixer Control (0x53) */
+#define RT5645_M_DAC_L1_LM			(0x1 << 15)
+#define RT5645_M_DAC_L1_LM_SFT			15
+#define RT5645_M_DAC_R1_LM			(0x1 << 14)
+#define RT5645_M_DAC_R1_LM_SFT			14
+#define RT5645_M_OV_L_LM			(0x1 << 13)
+#define RT5645_M_OV_L_LM_SFT			13
+#define RT5645_M_OV_R_LM			(0x1 << 12)
+#define RT5645_M_OV_R_LM_SFT			12
+#define RT5645_G_LOUTMIX_MASK			(0x1 << 11)
+#define RT5645_G_LOUTMIX_SFT			11
+
+/* Power Management for Digital 1 (0x61) */
+#define RT5645_PWR_I2S1				(0x1 << 15)
+#define RT5645_PWR_I2S1_BIT			15
+#define RT5645_PWR_I2S2				(0x1 << 14)
+#define RT5645_PWR_I2S2_BIT			14
+#define RT5645_PWR_I2S3				(0x1 << 13)
+#define RT5645_PWR_I2S3_BIT			13
+#define RT5645_PWR_DAC_L1			(0x1 << 12)
+#define RT5645_PWR_DAC_L1_BIT			12
+#define RT5645_PWR_DAC_R1			(0x1 << 11)
+#define RT5645_PWR_DAC_R1_BIT			11
+#define RT5645_PWR_CLS_D_R			(0x1 << 9)
+#define RT5645_PWR_CLS_D_R_BIT			9
+#define RT5645_PWR_CLS_D_L			(0x1 << 8)
+#define RT5645_PWR_CLS_D_L_BIT			8
+#define RT5645_PWR_ADC_R			(0x1 << 1)
+#define RT5645_PWR_ADC_R_BIT			1
+#define RT5645_PWR_DAC_L2			(0x1 << 7)
+#define RT5645_PWR_DAC_L2_BIT			7
+#define RT5645_PWR_DAC_R2			(0x1 << 6)
+#define RT5645_PWR_DAC_R2_BIT			6
+#define RT5645_PWR_ADC_L			(0x1 << 2)
+#define RT5645_PWR_ADC_L_BIT			2
+#define RT5645_PWR_ADC_R			(0x1 << 1)
+#define RT5645_PWR_ADC_R_BIT			1
+#define RT5645_PWR_CLS_D			(0x1)
+#define RT5645_PWR_CLS_D_BIT			0
+
+/* Power Management for Digital 2 (0x62) */
+#define RT5645_PWR_ADC_S1F			(0x1 << 15)
+#define RT5645_PWR_ADC_S1F_BIT			15
+#define RT5645_PWR_ADC_MF_L			(0x1 << 14)
+#define RT5645_PWR_ADC_MF_L_BIT			14
+#define RT5645_PWR_ADC_MF_R			(0x1 << 13)
+#define RT5645_PWR_ADC_MF_R_BIT			13
+#define RT5645_PWR_I2S_DSP			(0x1 << 12)
+#define RT5645_PWR_I2S_DSP_BIT			12
+#define RT5645_PWR_DAC_S1F			(0x1 << 11)
+#define RT5645_PWR_DAC_S1F_BIT			11
+#define RT5645_PWR_DAC_MF_L			(0x1 << 10)
+#define RT5645_PWR_DAC_MF_L_BIT			10
+#define RT5645_PWR_DAC_MF_R			(0x1 << 9)
+#define RT5645_PWR_DAC_MF_R_BIT			9
+#define RT5645_PWR_ADC_S2F			(0x1 << 8)
+#define RT5645_PWR_ADC_S2F_BIT			8
+#define RT5645_PWR_PDM1				(0x1 << 7)
+#define RT5645_PWR_PDM1_BIT			7
+#define RT5645_PWR_PDM2				(0x1 << 6)
+#define RT5645_PWR_PDM2_BIT			6
+#define RT5645_PWR_IPTV				(0x1 << 1)
+#define RT5645_PWR_IPTV_BIT			1
+#define RT5645_PWR_PAD				(0x1)
+#define RT5645_PWR_PAD_BIT			0
+
+/* Power Management for Analog 1 (0x63) */
+#define RT5645_PWR_VREF1			(0x1 << 15)
+#define RT5645_PWR_VREF1_BIT			15
+#define RT5645_PWR_FV1				(0x1 << 14)
+#define RT5645_PWR_FV1_BIT			14
+#define RT5645_PWR_MB				(0x1 << 13)
+#define RT5645_PWR_MB_BIT			13
+#define RT5645_PWR_LM				(0x1 << 12)
+#define RT5645_PWR_LM_BIT			12
+#define RT5645_PWR_BG				(0x1 << 11)
+#define RT5645_PWR_BG_BIT			11
+#define RT5645_PWR_MA				(0x1 << 10)
+#define RT5645_PWR_MA_BIT			10
+#define RT5645_PWR_HP_L				(0x1 << 7)
+#define RT5645_PWR_HP_L_BIT			7
+#define RT5645_PWR_HP_R				(0x1 << 6)
+#define RT5645_PWR_HP_R_BIT			6
+#define RT5645_PWR_HA				(0x1 << 5)
+#define RT5645_PWR_HA_BIT			5
+#define RT5645_PWR_VREF2			(0x1 << 4)
+#define RT5645_PWR_VREF2_BIT			4
+#define RT5645_PWR_FV2				(0x1 << 3)
+#define RT5645_PWR_FV2_BIT			3
+#define RT5645_LDO_SEL_MASK			(0x3)
+#define RT5645_LDO_SEL_SFT			0
+
+/* Power Management for Analog 2 (0x64) */
+#define RT5645_PWR_BST1				(0x1 << 15)
+#define RT5645_PWR_BST1_BIT			15
+#define RT5645_PWR_BST2				(0x1 << 14)
+#define RT5645_PWR_BST2_BIT			14
+#define RT5645_PWR_BST3				(0x1 << 13)
+#define RT5645_PWR_BST3_BIT			13
+#define RT5645_PWR_BST4				(0x1 << 12)
+#define RT5645_PWR_BST4_BIT			12
+#define RT5645_PWR_MB1				(0x1 << 11)
+#define RT5645_PWR_MB1_BIT			11
+#define RT5645_PWR_MB2				(0x1 << 10)
+#define RT5645_PWR_MB2_BIT			10
+#define RT5645_PWR_PLL				(0x1 << 9)
+#define RT5645_PWR_PLL_BIT			9
+#define RT5645_PWR_BST2_P			(0x1 << 5)
+#define RT5645_PWR_BST2_P_BIT			5
+#define RT5645_PWR_BST3_P			(0x1 << 4)
+#define RT5645_PWR_BST3_P_BIT			4
+#define RT5645_PWR_BST4_P			(0x1 << 3)
+#define RT5645_PWR_BST4_P_BIT			3
+#define RT5645_PWR_JD1				(0x1 << 2)
+#define RT5645_PWR_JD1_BIT			2
+#define RT5645_PWR_JD				(0x1 << 1)
+#define RT5645_PWR_JD_BIT			1
+
+/* Power Management for Mixer (0x65) */
+#define RT5645_PWR_OM_L				(0x1 << 15)
+#define RT5645_PWR_OM_L_BIT			15
+#define RT5645_PWR_OM_R				(0x1 << 14)
+#define RT5645_PWR_OM_R_BIT			14
+#define RT5645_PWR_SM_L				(0x1 << 13)
+#define RT5645_PWR_SM_L_BIT			13
+#define RT5645_PWR_SM_R				(0x1 << 12)
+#define RT5645_PWR_SM_R_BIT			12
+#define RT5645_PWR_RM_L				(0x1 << 11)
+#define RT5645_PWR_RM_L_BIT			11
+#define RT5645_PWR_RM_R				(0x1 << 10)
+#define RT5645_PWR_RM_R_BIT			10
+#define RT5645_PWR_MM				(0x1 << 8)
+#define RT5645_PWR_MM_BIT			8
+#define RT5645_PWR_HM_L				(0x1 << 7)
+#define RT5645_PWR_HM_L_BIT			7
+#define RT5645_PWR_HM_R				(0x1 << 6)
+#define RT5645_PWR_HM_R_BIT			6
+#define RT5645_PWR_LDO2				(0x1 << 1)
+#define RT5645_PWR_LDO2_BIT			1
+
+/* Power Management for Volume (0x66) */
+#define RT5645_PWR_SV_L				(0x1 << 15)
+#define RT5645_PWR_SV_L_BIT			15
+#define RT5645_PWR_SV_R				(0x1 << 14)
+#define RT5645_PWR_SV_R_BIT			14
+#define RT5645_PWR_HV_L				(0x1 << 11)
+#define RT5645_PWR_HV_L_BIT			11
+#define RT5645_PWR_HV_R				(0x1 << 10)
+#define RT5645_PWR_HV_R_BIT			10
+#define RT5645_PWR_IN_L				(0x1 << 9)
+#define RT5645_PWR_IN_L_BIT			9
+#define RT5645_PWR_IN_R				(0x1 << 8)
+#define RT5645_PWR_IN_R_BIT			8
+#define RT5645_PWR_MIC_DET			(0x1 << 5)
+#define RT5645_PWR_MIC_DET_BIT			5
+
+/* I2S1/2/3 Audio Serial Data Port Control (0x70 0x71 0x72) */
+#define RT5645_I2S_MS_MASK			(0x1 << 15)
+#define RT5645_I2S_MS_SFT			15
+#define RT5645_I2S_MS_M				(0x0 << 15)
+#define RT5645_I2S_MS_S				(0x1 << 15)
+#define RT5645_I2S_O_CP_MASK			(0x3 << 10)
+#define RT5645_I2S_O_CP_SFT			10
+#define RT5645_I2S_O_CP_OFF			(0x0 << 10)
+#define RT5645_I2S_O_CP_U_LAW			(0x1 << 10)
+#define RT5645_I2S_O_CP_A_LAW			(0x2 << 10)
+#define RT5645_I2S_I_CP_MASK			(0x3 << 8)
+#define RT5645_I2S_I_CP_SFT			8
+#define RT5645_I2S_I_CP_OFF			(0x0 << 8)
+#define RT5645_I2S_I_CP_U_LAW			(0x1 << 8)
+#define RT5645_I2S_I_CP_A_LAW			(0x2 << 8)
+#define RT5645_I2S_BP_MASK			(0x1 << 7)
+#define RT5645_I2S_BP_SFT			7
+#define RT5645_I2S_BP_NOR			(0x0 << 7)
+#define RT5645_I2S_BP_INV			(0x1 << 7)
+#define RT5645_I2S_DL_MASK			(0x3 << 2)
+#define RT5645_I2S_DL_SFT			2
+#define RT5645_I2S_DL_16			(0x0 << 2)
+#define RT5645_I2S_DL_20			(0x1 << 2)
+#define RT5645_I2S_DL_24			(0x2 << 2)
+#define RT5645_I2S_DL_8				(0x3 << 2)
+#define RT5645_I2S_DF_MASK			(0x3)
+#define RT5645_I2S_DF_SFT			0
+#define RT5645_I2S_DF_I2S			(0x0)
+#define RT5645_I2S_DF_LEFT			(0x1)
+#define RT5645_I2S_DF_PCM_A			(0x2)
+#define RT5645_I2S_DF_PCM_B			(0x3)
+
+/* I2S2 Audio Serial Data Port Control (0x71) */
+#define RT5645_I2S2_SDI_MASK			(0x1 << 6)
+#define RT5645_I2S2_SDI_SFT			6
+#define RT5645_I2S2_SDI_I2S1			(0x0 << 6)
+#define RT5645_I2S2_SDI_I2S2			(0x1 << 6)
+
+/* ADC/DAC Clock Control 1 (0x73) */
+#define RT5645_I2S_BCLK_MS1_MASK		(0x1 << 15)
+#define RT5645_I2S_BCLK_MS1_SFT			15
+#define RT5645_I2S_BCLK_MS1_32			(0x0 << 15)
+#define RT5645_I2S_BCLK_MS1_64			(0x1 << 15)
+#define RT5645_I2S_PD1_MASK			(0x7 << 12)
+#define RT5645_I2S_PD1_SFT			12
+#define RT5645_I2S_PD1_1			(0x0 << 12)
+#define RT5645_I2S_PD1_2			(0x1 << 12)
+#define RT5645_I2S_PD1_3			(0x2 << 12)
+#define RT5645_I2S_PD1_4			(0x3 << 12)
+#define RT5645_I2S_PD1_6			(0x4 << 12)
+#define RT5645_I2S_PD1_8			(0x5 << 12)
+#define RT5645_I2S_PD1_12			(0x6 << 12)
+#define RT5645_I2S_PD1_16			(0x7 << 12)
+#define RT5645_I2S_BCLK_MS2_MASK		(0x1 << 11)
+#define RT5645_I2S_BCLK_MS2_SFT			11
+#define RT5645_I2S_BCLK_MS2_32			(0x0 << 11)
+#define RT5645_I2S_BCLK_MS2_64			(0x1 << 11)
+#define RT5645_I2S_PD2_MASK			(0x7 << 8)
+#define RT5645_I2S_PD2_SFT			8
+#define RT5645_I2S_PD2_1			(0x0 << 8)
+#define RT5645_I2S_PD2_2			(0x1 << 8)
+#define RT5645_I2S_PD2_3			(0x2 << 8)
+#define RT5645_I2S_PD2_4			(0x3 << 8)
+#define RT5645_I2S_PD2_6			(0x4 << 8)
+#define RT5645_I2S_PD2_8			(0x5 << 8)
+#define RT5645_I2S_PD2_12			(0x6 << 8)
+#define RT5645_I2S_PD2_16			(0x7 << 8)
+#define RT5645_I2S_BCLK_MS3_MASK		(0x1 << 7)
+#define RT5645_I2S_BCLK_MS3_SFT			7
+#define RT5645_I2S_BCLK_MS3_32			(0x0 << 7)
+#define RT5645_I2S_BCLK_MS3_64			(0x1 << 7)
+#define RT5645_I2S_PD3_MASK			(0x7 << 4)
+#define RT5645_I2S_PD3_SFT			4
+#define RT5645_I2S_PD3_1			(0x0 << 4)
+#define RT5645_I2S_PD3_2			(0x1 << 4)
+#define RT5645_I2S_PD3_3			(0x2 << 4)
+#define RT5645_I2S_PD3_4			(0x3 << 4)
+#define RT5645_I2S_PD3_6			(0x4 << 4)
+#define RT5645_I2S_PD3_8			(0x5 << 4)
+#define RT5645_I2S_PD3_12			(0x6 << 4)
+#define RT5645_I2S_PD3_16			(0x7 << 4)
+#define RT5645_DAC_OSR_MASK			(0x3 << 2)
+#define RT5645_DAC_OSR_SFT			2
+#define RT5645_DAC_OSR_128			(0x0 << 2)
+#define RT5645_DAC_OSR_64			(0x1 << 2)
+#define RT5645_DAC_OSR_32			(0x2 << 2)
+#define RT5645_DAC_OSR_16			(0x3 << 2)
+#define RT5645_ADC_OSR_MASK			(0x3)
+#define RT5645_ADC_OSR_SFT			0
+#define RT5645_ADC_OSR_128			(0x0)
+#define RT5645_ADC_OSR_64			(0x1)
+#define RT5645_ADC_OSR_32			(0x2)
+#define RT5645_ADC_OSR_16			(0x3)
+
+/* ADC/DAC Clock Control 2 (0x74) */
+#define RT5645_DAC_L_OSR_MASK			(0x3 << 14)
+#define RT5645_DAC_L_OSR_SFT			14
+#define RT5645_DAC_L_OSR_128			(0x0 << 14)
+#define RT5645_DAC_L_OSR_64			(0x1 << 14)
+#define RT5645_DAC_L_OSR_32			(0x2 << 14)
+#define RT5645_DAC_L_OSR_16			(0x3 << 14)
+#define RT5645_ADC_R_OSR_MASK			(0x3 << 12)
+#define RT5645_ADC_R_OSR_SFT			12
+#define RT5645_ADC_R_OSR_128			(0x0 << 12)
+#define RT5645_ADC_R_OSR_64			(0x1 << 12)
+#define RT5645_ADC_R_OSR_32			(0x2 << 12)
+#define RT5645_ADC_R_OSR_16			(0x3 << 12)
+#define RT5645_DAHPF_EN				(0x1 << 11)
+#define RT5645_DAHPF_EN_SFT			11
+#define RT5645_ADHPF_EN				(0x1 << 10)
+#define RT5645_ADHPF_EN_SFT			10
+
+/* Digital Microphone Control (0x75) */
+#define RT5645_DMIC_1_EN_MASK			(0x1 << 15)
+#define RT5645_DMIC_1_EN_SFT			15
+#define RT5645_DMIC_1_DIS			(0x0 << 15)
+#define RT5645_DMIC_1_EN			(0x1 << 15)
+#define RT5645_DMIC_2_EN_MASK			(0x1 << 14)
+#define RT5645_DMIC_2_EN_SFT			14
+#define RT5645_DMIC_2_DIS			(0x0 << 14)
+#define RT5645_DMIC_2_EN			(0x1 << 14)
+#define RT5645_DMIC_1L_LH_MASK			(0x1 << 13)
+#define RT5645_DMIC_1L_LH_SFT			13
+#define RT5645_DMIC_1L_LH_FALLING		(0x0 << 13)
+#define RT5645_DMIC_1L_LH_RISING		(0x1 << 13)
+#define RT5645_DMIC_1R_LH_MASK			(0x1 << 12)
+#define RT5645_DMIC_1R_LH_SFT			12
+#define RT5645_DMIC_1R_LH_FALLING		(0x0 << 12)
+#define RT5645_DMIC_1R_LH_RISING		(0x1 << 12)
+#define RT5645_DMIC_2_DP_MASK			(0x1 << 10)
+#define RT5645_DMIC_2_DP_SFT			10
+#define RT5645_DMIC_2_DP_GPIO4			(0x0 << 10)
+#define RT5645_DMIC_2_DP_IN1N			(0x1 << 10)
+#define RT5645_DMIC_2L_LH_MASK			(0x1 << 9)
+#define RT5645_DMIC_2L_LH_SFT			9
+#define RT5645_DMIC_2L_LH_FALLING		(0x0 << 9)
+#define RT5645_DMIC_2L_LH_RISING		(0x1 << 9)
+#define RT5645_DMIC_2R_LH_MASK			(0x1 << 8)
+#define RT5645_DMIC_2R_LH_SFT			8
+#define RT5645_DMIC_2R_LH_FALLING		(0x0 << 8)
+#define RT5645_DMIC_2R_LH_RISING		(0x1 << 8)
+#define RT5645_DMIC_CLK_MASK			(0x7 << 5)
+#define RT5645_DMIC_CLK_SFT			5
+#define RT5645_DMIC_3_EN_MASK			(0x1 << 4)
+#define RT5645_DMIC_3_EN_SFT			4
+#define RT5645_DMIC_3_DIS			(0x0 << 4)
+#define RT5645_DMIC_3_EN			(0x1 << 4)
+#define RT5645_DMIC_1_DP_MASK			(0x3 << 0)
+#define RT5645_DMIC_1_DP_SFT			0
+#define RT5645_DMIC_1_DP_GPIO6			(0x0 << 0)
+#define RT5645_DMIC_1_DP_IN2P			(0x1 << 0)
+#define RT5645_DMIC_1_DP_GPIO7			(0x2 << 0)
+
+/* TDM Control 1 (0x77) */
+#define RT5645_IF1_ADC_IN_MASK			(0x3 << 8)
+#define RT5645_IF1_ADC_IN_SFT			8
+
+/* Global Clock Control (0x80) */
+#define RT5645_SCLK_SRC_MASK			(0x3 << 14)
+#define RT5645_SCLK_SRC_SFT			14
+#define RT5645_SCLK_SRC_MCLK			(0x0 << 14)
+#define RT5645_SCLK_SRC_PLL1			(0x1 << 14)
+#define RT5645_SCLK_SRC_RCCLK			(0x2 << 14) /* 15MHz */
+#define RT5645_PLL1_SRC_MASK			(0x3 << 12)
+#define RT5645_PLL1_SRC_SFT			12
+#define RT5645_PLL1_SRC_MCLK			(0x0 << 12)
+#define RT5645_PLL1_SRC_BCLK1			(0x1 << 12)
+#define RT5645_PLL1_SRC_BCLK2			(0x2 << 12)
+#define RT5645_PLL1_SRC_BCLK3			(0x3 << 12)
+#define RT5645_PLL1_PD_MASK			(0x1 << 3)
+#define RT5645_PLL1_PD_SFT			3
+#define RT5645_PLL1_PD_1			(0x0 << 3)
+#define RT5645_PLL1_PD_2			(0x1 << 3)
+
+#define RT5645_PLL_INP_MAX			40000000
+#define RT5645_PLL_INP_MIN			256000
+/* PLL M/N/K Code Control 1 (0x81) */
+#define RT5645_PLL_N_MAX			0x1ff
+#define RT5645_PLL_N_MASK			(RT5645_PLL_N_MAX << 7)
+#define RT5645_PLL_N_SFT			7
+#define RT5645_PLL_K_MAX			0x1f
+#define RT5645_PLL_K_MASK			(RT5645_PLL_K_MAX)
+#define RT5645_PLL_K_SFT			0
+
+/* PLL M/N/K Code Control 2 (0x82) */
+#define RT5645_PLL_M_MAX			0xf
+#define RT5645_PLL_M_MASK			(RT5645_PLL_M_MAX << 12)
+#define RT5645_PLL_M_SFT			12
+#define RT5645_PLL_M_BP				(0x1 << 11)
+#define RT5645_PLL_M_BP_SFT			11
+
+/* ASRC Control 1 (0x83) */
+#define RT5645_STO_T_MASK			(0x1 << 15)
+#define RT5645_STO_T_SFT			15
+#define RT5645_STO_T_SCLK			(0x0 << 15)
+#define RT5645_STO_T_LRCK1			(0x1 << 15)
+#define RT5645_M1_T_MASK			(0x1 << 14)
+#define RT5645_M1_T_SFT				14
+#define RT5645_M1_T_I2S2			(0x0 << 14)
+#define RT5645_M1_T_I2S2_D3			(0x1 << 14)
+#define RT5645_I2S2_F_MASK			(0x1 << 12)
+#define RT5645_I2S2_F_SFT			12
+#define RT5645_I2S2_F_I2S2_D2			(0x0 << 12)
+#define RT5645_I2S2_F_I2S1_TCLK			(0x1 << 12)
+#define RT5645_DMIC_1_M_MASK			(0x1 << 9)
+#define RT5645_DMIC_1_M_SFT			9
+#define RT5645_DMIC_1_M_NOR			(0x0 << 9)
+#define RT5645_DMIC_1_M_ASYN			(0x1 << 9)
+#define RT5645_DMIC_2_M_MASK			(0x1 << 8)
+#define RT5645_DMIC_2_M_SFT			8
+#define RT5645_DMIC_2_M_NOR			(0x0 << 8)
+#define RT5645_DMIC_2_M_ASYN			(0x1 << 8)
+
+/* ASRC Control 2 (0x84) */
+#define RT5645_MDA_L_M_MASK			(0x1 << 15)
+#define RT5645_MDA_L_M_SFT			15
+#define RT5645_MDA_L_M_NOR			(0x0 << 15)
+#define RT5645_MDA_L_M_ASYN			(0x1 << 15)
+#define RT5645_MDA_R_M_MASK			(0x1 << 14)
+#define RT5645_MDA_R_M_SFT			14
+#define RT5645_MDA_R_M_NOR			(0x0 << 14)
+#define RT5645_MDA_R_M_ASYN			(0x1 << 14)
+#define RT5645_MAD_L_M_MASK			(0x1 << 13)
+#define RT5645_MAD_L_M_SFT			13
+#define RT5645_MAD_L_M_NOR			(0x0 << 13)
+#define RT5645_MAD_L_M_ASYN			(0x1 << 13)
+#define RT5645_MAD_R_M_MASK			(0x1 << 12)
+#define RT5645_MAD_R_M_SFT			12
+#define RT5645_MAD_R_M_NOR			(0x0 << 12)
+#define RT5645_MAD_R_M_ASYN			(0x1 << 12)
+#define RT5645_ADC_M_MASK			(0x1 << 11)
+#define RT5645_ADC_M_SFT			11
+#define RT5645_ADC_M_NOR			(0x0 << 11)
+#define RT5645_ADC_M_ASYN			(0x1 << 11)
+#define RT5645_STO_DAC_M_MASK			(0x1 << 5)
+#define RT5645_STO_DAC_M_SFT			5
+#define RT5645_STO_DAC_M_NOR			(0x0 << 5)
+#define RT5645_STO_DAC_M_ASYN			(0x1 << 5)
+#define RT5645_I2S1_R_D_MASK			(0x1 << 4)
+#define RT5645_I2S1_R_D_SFT			4
+#define RT5645_I2S1_R_D_DIS			(0x0 << 4)
+#define RT5645_I2S1_R_D_EN			(0x1 << 4)
+#define RT5645_I2S2_R_D_MASK			(0x1 << 3)
+#define RT5645_I2S2_R_D_SFT			3
+#define RT5645_I2S2_R_D_DIS			(0x0 << 3)
+#define RT5645_I2S2_R_D_EN			(0x1 << 3)
+#define RT5645_PRE_SCLK_MASK			(0x3)
+#define RT5645_PRE_SCLK_SFT			0
+#define RT5645_PRE_SCLK_512			(0x0)
+#define RT5645_PRE_SCLK_1024			(0x1)
+#define RT5645_PRE_SCLK_2048			(0x2)
+
+/* ASRC Control 3 (0x85) */
+#define RT5645_I2S1_RATE_MASK			(0xf << 12)
+#define RT5645_I2S1_RATE_SFT			12
+#define RT5645_I2S2_RATE_MASK			(0xf << 8)
+#define RT5645_I2S2_RATE_SFT			8
+
+/* ASRC Control 4 (0x89) */
+#define RT5645_I2S1_PD_MASK			(0x7 << 12)
+#define RT5645_I2S1_PD_SFT			12
+#define RT5645_I2S2_PD_MASK			(0x7 << 8)
+#define RT5645_I2S2_PD_SFT			8
+
+/* HPOUT Over Current Detection (0x8b) */
+#define RT5645_HP_OVCD_MASK			(0x1 << 10)
+#define RT5645_HP_OVCD_SFT			10
+#define RT5645_HP_OVCD_DIS			(0x0 << 10)
+#define RT5645_HP_OVCD_EN			(0x1 << 10)
+#define RT5645_HP_OC_TH_MASK			(0x3 << 8)
+#define RT5645_HP_OC_TH_SFT			8
+#define RT5645_HP_OC_TH_90			(0x0 << 8)
+#define RT5645_HP_OC_TH_105			(0x1 << 8)
+#define RT5645_HP_OC_TH_120			(0x2 << 8)
+#define RT5645_HP_OC_TH_135			(0x3 << 8)
+
+/* Class D Over Current Control (0x8c) */
+#define RT5645_CLSD_OC_MASK			(0x1 << 9)
+#define RT5645_CLSD_OC_SFT			9
+#define RT5645_CLSD_OC_PU			(0x0 << 9)
+#define RT5645_CLSD_OC_PD			(0x1 << 9)
+#define RT5645_AUTO_PD_MASK			(0x1 << 8)
+#define RT5645_AUTO_PD_SFT			8
+#define RT5645_AUTO_PD_DIS			(0x0 << 8)
+#define RT5645_AUTO_PD_EN			(0x1 << 8)
+#define RT5645_CLSD_OC_TH_MASK			(0x3f)
+#define RT5645_CLSD_OC_TH_SFT			0
+
+/* Class D Output Control (0x8d) */
+#define RT5645_CLSD_RATIO_MASK			(0xf << 12)
+#define RT5645_CLSD_RATIO_SFT			12
+#define RT5645_CLSD_OM_MASK			(0x1 << 11)
+#define RT5645_CLSD_OM_SFT			11
+#define RT5645_CLSD_OM_MONO			(0x0 << 11)
+#define RT5645_CLSD_OM_STO			(0x1 << 11)
+#define RT5645_CLSD_SCH_MASK			(0x1 << 10)
+#define RT5645_CLSD_SCH_SFT			10
+#define RT5645_CLSD_SCH_L			(0x0 << 10)
+#define RT5645_CLSD_SCH_S			(0x1 << 10)
+
+/* Depop Mode Control 1 (0x8e) */
+#define RT5645_SMT_TRIG_MASK			(0x1 << 15)
+#define RT5645_SMT_TRIG_SFT			15
+#define RT5645_SMT_TRIG_DIS			(0x0 << 15)
+#define RT5645_SMT_TRIG_EN			(0x1 << 15)
+#define RT5645_HP_L_SMT_MASK			(0x1 << 9)
+#define RT5645_HP_L_SMT_SFT			9
+#define RT5645_HP_L_SMT_DIS			(0x0 << 9)
+#define RT5645_HP_L_SMT_EN			(0x1 << 9)
+#define RT5645_HP_R_SMT_MASK			(0x1 << 8)
+#define RT5645_HP_R_SMT_SFT			8
+#define RT5645_HP_R_SMT_DIS			(0x0 << 8)
+#define RT5645_HP_R_SMT_EN			(0x1 << 8)
+#define RT5645_HP_CD_PD_MASK			(0x1 << 7)
+#define RT5645_HP_CD_PD_SFT			7
+#define RT5645_HP_CD_PD_DIS			(0x0 << 7)
+#define RT5645_HP_CD_PD_EN			(0x1 << 7)
+#define RT5645_RSTN_MASK			(0x1 << 6)
+#define RT5645_RSTN_SFT				6
+#define RT5645_RSTN_DIS				(0x0 << 6)
+#define RT5645_RSTN_EN				(0x1 << 6)
+#define RT5645_RSTP_MASK			(0x1 << 5)
+#define RT5645_RSTP_SFT				5
+#define RT5645_RSTP_DIS				(0x0 << 5)
+#define RT5645_RSTP_EN				(0x1 << 5)
+#define RT5645_HP_CO_MASK			(0x1 << 4)
+#define RT5645_HP_CO_SFT			4
+#define RT5645_HP_CO_DIS			(0x0 << 4)
+#define RT5645_HP_CO_EN				(0x1 << 4)
+#define RT5645_HP_CP_MASK			(0x1 << 3)
+#define RT5645_HP_CP_SFT			3
+#define RT5645_HP_CP_PD				(0x0 << 3)
+#define RT5645_HP_CP_PU				(0x1 << 3)
+#define RT5645_HP_SG_MASK			(0x1 << 2)
+#define RT5645_HP_SG_SFT			2
+#define RT5645_HP_SG_DIS			(0x0 << 2)
+#define RT5645_HP_SG_EN				(0x1 << 2)
+#define RT5645_HP_DP_MASK			(0x1 << 1)
+#define RT5645_HP_DP_SFT			1
+#define RT5645_HP_DP_PD				(0x0 << 1)
+#define RT5645_HP_DP_PU				(0x1 << 1)
+#define RT5645_HP_CB_MASK			(0x1)
+#define RT5645_HP_CB_SFT			0
+#define RT5645_HP_CB_PD				(0x0)
+#define RT5645_HP_CB_PU				(0x1)
+
+/* Depop Mode Control 2 (0x8f) */
+#define RT5645_DEPOP_MASK			(0x1 << 13)
+#define RT5645_DEPOP_SFT			13
+#define RT5645_DEPOP_AUTO			(0x0 << 13)
+#define RT5645_DEPOP_MAN			(0x1 << 13)
+#define RT5645_RAMP_MASK			(0x1 << 12)
+#define RT5645_RAMP_SFT				12
+#define RT5645_RAMP_DIS				(0x0 << 12)
+#define RT5645_RAMP_EN				(0x1 << 12)
+#define RT5645_BPS_MASK				(0x1 << 11)
+#define RT5645_BPS_SFT				11
+#define RT5645_BPS_DIS				(0x0 << 11)
+#define RT5645_BPS_EN				(0x1 << 11)
+#define RT5645_FAST_UPDN_MASK			(0x1 << 10)
+#define RT5645_FAST_UPDN_SFT			10
+#define RT5645_FAST_UPDN_DIS			(0x0 << 10)
+#define RT5645_FAST_UPDN_EN			(0x1 << 10)
+#define RT5645_MRES_MASK			(0x3 << 8)
+#define RT5645_MRES_SFT				8
+#define RT5645_MRES_15MO			(0x0 << 8)
+#define RT5645_MRES_25MO			(0x1 << 8)
+#define RT5645_MRES_35MO			(0x2 << 8)
+#define RT5645_MRES_45MO			(0x3 << 8)
+#define RT5645_VLO_MASK				(0x1 << 7)
+#define RT5645_VLO_SFT				7
+#define RT5645_VLO_3V				(0x0 << 7)
+#define RT5645_VLO_32V				(0x1 << 7)
+#define RT5645_DIG_DP_MASK			(0x1 << 6)
+#define RT5645_DIG_DP_SFT			6
+#define RT5645_DIG_DP_DIS			(0x0 << 6)
+#define RT5645_DIG_DP_EN			(0x1 << 6)
+#define RT5645_DP_TH_MASK			(0x3 << 4)
+#define RT5645_DP_TH_SFT			4
+
+/* Depop Mode Control 3 (0x90) */
+#define RT5645_CP_SYS_MASK			(0x7 << 12)
+#define RT5645_CP_SYS_SFT			12
+#define RT5645_CP_FQ1_MASK			(0x7 << 8)
+#define RT5645_CP_FQ1_SFT			8
+#define RT5645_CP_FQ2_MASK			(0x7 << 4)
+#define RT5645_CP_FQ2_SFT			4
+#define RT5645_CP_FQ3_MASK			(0x7)
+#define RT5645_CP_FQ3_SFT			0
+#define RT5645_CP_FQ_1_5_KHZ			0
+#define RT5645_CP_FQ_3_KHZ			1
+#define RT5645_CP_FQ_6_KHZ			2
+#define RT5645_CP_FQ_12_KHZ			3
+#define RT5645_CP_FQ_24_KHZ			4
+#define RT5645_CP_FQ_48_KHZ			5
+#define RT5645_CP_FQ_96_KHZ			6
+#define RT5645_CP_FQ_192_KHZ			7
+
+/* HPOUT charge pump (0x91) */
+#define RT5645_OSW_L_MASK			(0x1 << 11)
+#define RT5645_OSW_L_SFT			11
+#define RT5645_OSW_L_DIS			(0x0 << 11)
+#define RT5645_OSW_L_EN				(0x1 << 11)
+#define RT5645_OSW_R_MASK			(0x1 << 10)
+#define RT5645_OSW_R_SFT			10
+#define RT5645_OSW_R_DIS			(0x0 << 10)
+#define RT5645_OSW_R_EN				(0x1 << 10)
+#define RT5645_PM_HP_MASK			(0x3 << 8)
+#define RT5645_PM_HP_SFT			8
+#define RT5645_PM_HP_LV				(0x0 << 8)
+#define RT5645_PM_HP_MV				(0x1 << 8)
+#define RT5645_PM_HP_HV				(0x2 << 8)
+#define RT5645_IB_HP_MASK			(0x3 << 6)
+#define RT5645_IB_HP_SFT			6
+#define RT5645_IB_HP_125IL			(0x0 << 6)
+#define RT5645_IB_HP_25IL			(0x1 << 6)
+#define RT5645_IB_HP_5IL			(0x2 << 6)
+#define RT5645_IB_HP_1IL			(0x3 << 6)
+
+/* PV detection and SPK gain control (0x92) */
+#define RT5645_PVDD_DET_MASK			(0x1 << 15)
+#define RT5645_PVDD_DET_SFT			15
+#define RT5645_PVDD_DET_DIS			(0x0 << 15)
+#define RT5645_PVDD_DET_EN			(0x1 << 15)
+#define RT5645_SPK_AG_MASK			(0x1 << 14)
+#define RT5645_SPK_AG_SFT			14
+#define RT5645_SPK_AG_DIS			(0x0 << 14)
+#define RT5645_SPK_AG_EN			(0x1 << 14)
+
+/* Micbias Control (0x93) */
+#define RT5645_MIC1_BS_MASK			(0x1 << 15)
+#define RT5645_MIC1_BS_SFT			15
+#define RT5645_MIC1_BS_9AV			(0x0 << 15)
+#define RT5645_MIC1_BS_75AV			(0x1 << 15)
+#define RT5645_MIC2_BS_MASK			(0x1 << 14)
+#define RT5645_MIC2_BS_SFT			14
+#define RT5645_MIC2_BS_9AV			(0x0 << 14)
+#define RT5645_MIC2_BS_75AV			(0x1 << 14)
+#define RT5645_MIC1_CLK_MASK			(0x1 << 13)
+#define RT5645_MIC1_CLK_SFT			13
+#define RT5645_MIC1_CLK_DIS			(0x0 << 13)
+#define RT5645_MIC1_CLK_EN			(0x1 << 13)
+#define RT5645_MIC2_CLK_MASK			(0x1 << 12)
+#define RT5645_MIC2_CLK_SFT			12
+#define RT5645_MIC2_CLK_DIS			(0x0 << 12)
+#define RT5645_MIC2_CLK_EN			(0x1 << 12)
+#define RT5645_MIC1_OVCD_MASK			(0x1 << 11)
+#define RT5645_MIC1_OVCD_SFT			11
+#define RT5645_MIC1_OVCD_DIS			(0x0 << 11)
+#define RT5645_MIC1_OVCD_EN			(0x1 << 11)
+#define RT5645_MIC1_OVTH_MASK			(0x3 << 9)
+#define RT5645_MIC1_OVTH_SFT			9
+#define RT5645_MIC1_OVTH_600UA			(0x0 << 9)
+#define RT5645_MIC1_OVTH_1500UA			(0x1 << 9)
+#define RT5645_MIC1_OVTH_2000UA			(0x2 << 9)
+#define RT5645_MIC2_OVCD_MASK			(0x1 << 8)
+#define RT5645_MIC2_OVCD_SFT			8
+#define RT5645_MIC2_OVCD_DIS			(0x0 << 8)
+#define RT5645_MIC2_OVCD_EN			(0x1 << 8)
+#define RT5645_MIC2_OVTH_MASK			(0x3 << 6)
+#define RT5645_MIC2_OVTH_SFT			6
+#define RT5645_MIC2_OVTH_600UA			(0x0 << 6)
+#define RT5645_MIC2_OVTH_1500UA			(0x1 << 6)
+#define RT5645_MIC2_OVTH_2000UA			(0x2 << 6)
+#define RT5645_PWR_MB_MASK			(0x1 << 5)
+#define RT5645_PWR_MB_SFT			5
+#define RT5645_PWR_MB_PD			(0x0 << 5)
+#define RT5645_PWR_MB_PU			(0x1 << 5)
+#define RT5645_PWR_CLK25M_MASK			(0x1 << 4)
+#define RT5645_PWR_CLK25M_SFT			4
+#define RT5645_PWR_CLK25M_PD			(0x0 << 4)
+#define RT5645_PWR_CLK25M_PU			(0x1 << 4)
+
+/* VAD Control 4 (0x9d) */
+#define RT5645_VAD_SEL_MASK			(0x3 << 8)
+#define RT5645_VAD_SEL_SFT			8
+
+/* EQ Control 1 (0xb0) */
+#define RT5645_EQ_SRC_MASK			(0x1 << 15)
+#define RT5645_EQ_SRC_SFT			15
+#define RT5645_EQ_SRC_DAC			(0x0 << 15)
+#define RT5645_EQ_SRC_ADC			(0x1 << 15)
+#define RT5645_EQ_UPD				(0x1 << 14)
+#define RT5645_EQ_UPD_BIT			14
+#define RT5645_EQ_CD_MASK			(0x1 << 13)
+#define RT5645_EQ_CD_SFT			13
+#define RT5645_EQ_CD_DIS			(0x0 << 13)
+#define RT5645_EQ_CD_EN				(0x1 << 13)
+#define RT5645_EQ_DITH_MASK			(0x3 << 8)
+#define RT5645_EQ_DITH_SFT			8
+#define RT5645_EQ_DITH_NOR			(0x0 << 8)
+#define RT5645_EQ_DITH_LSB			(0x1 << 8)
+#define RT5645_EQ_DITH_LSB_1			(0x2 << 8)
+#define RT5645_EQ_DITH_LSB_2			(0x3 << 8)
+
+/* EQ Control 2 (0xb1) */
+#define RT5645_EQ_HPF1_M_MASK			(0x1 << 8)
+#define RT5645_EQ_HPF1_M_SFT			8
+#define RT5645_EQ_HPF1_M_HI			(0x0 << 8)
+#define RT5645_EQ_HPF1_M_1ST			(0x1 << 8)
+#define RT5645_EQ_LPF1_M_MASK			(0x1 << 7)
+#define RT5645_EQ_LPF1_M_SFT			7
+#define RT5645_EQ_LPF1_M_LO			(0x0 << 7)
+#define RT5645_EQ_LPF1_M_1ST			(0x1 << 7)
+#define RT5645_EQ_HPF2_MASK			(0x1 << 6)
+#define RT5645_EQ_HPF2_SFT			6
+#define RT5645_EQ_HPF2_DIS			(0x0 << 6)
+#define RT5645_EQ_HPF2_EN			(0x1 << 6)
+#define RT5645_EQ_HPF1_MASK			(0x1 << 5)
+#define RT5645_EQ_HPF1_SFT			5
+#define RT5645_EQ_HPF1_DIS			(0x0 << 5)
+#define RT5645_EQ_HPF1_EN			(0x1 << 5)
+#define RT5645_EQ_BPF4_MASK			(0x1 << 4)
+#define RT5645_EQ_BPF4_SFT			4
+#define RT5645_EQ_BPF4_DIS			(0x0 << 4)
+#define RT5645_EQ_BPF4_EN			(0x1 << 4)
+#define RT5645_EQ_BPF3_MASK			(0x1 << 3)
+#define RT5645_EQ_BPF3_SFT			3
+#define RT5645_EQ_BPF3_DIS			(0x0 << 3)
+#define RT5645_EQ_BPF3_EN			(0x1 << 3)
+#define RT5645_EQ_BPF2_MASK			(0x1 << 2)
+#define RT5645_EQ_BPF2_SFT			2
+#define RT5645_EQ_BPF2_DIS			(0x0 << 2)
+#define RT5645_EQ_BPF2_EN			(0x1 << 2)
+#define RT5645_EQ_BPF1_MASK			(0x1 << 1)
+#define RT5645_EQ_BPF1_SFT			1
+#define RT5645_EQ_BPF1_DIS			(0x0 << 1)
+#define RT5645_EQ_BPF1_EN			(0x1 << 1)
+#define RT5645_EQ_LPF_MASK			(0x1)
+#define RT5645_EQ_LPF_SFT			0
+#define RT5645_EQ_LPF_DIS			(0x0)
+#define RT5645_EQ_LPF_EN			(0x1)
+#define RT5645_EQ_CTRL_MASK			(0x7f)
+
+/* Memory Test (0xb2) */
+#define RT5645_MT_MASK				(0x1 << 15)
+#define RT5645_MT_SFT				15
+#define RT5645_MT_DIS				(0x0 << 15)
+#define RT5645_MT_EN				(0x1 << 15)
+
+/* DRC/AGC Control 1 (0xb4) */
+#define RT5645_DRC_AGC_P_MASK			(0x1 << 15)
+#define RT5645_DRC_AGC_P_SFT			15
+#define RT5645_DRC_AGC_P_DAC			(0x0 << 15)
+#define RT5645_DRC_AGC_P_ADC			(0x1 << 15)
+#define RT5645_DRC_AGC_MASK			(0x1 << 14)
+#define RT5645_DRC_AGC_SFT			14
+#define RT5645_DRC_AGC_DIS			(0x0 << 14)
+#define RT5645_DRC_AGC_EN			(0x1 << 14)
+#define RT5645_DRC_AGC_UPD			(0x1 << 13)
+#define RT5645_DRC_AGC_UPD_BIT			13
+#define RT5645_DRC_AGC_AR_MASK			(0x1f << 8)
+#define RT5645_DRC_AGC_AR_SFT			8
+#define RT5645_DRC_AGC_R_MASK			(0x7 << 5)
+#define RT5645_DRC_AGC_R_SFT			5
+#define RT5645_DRC_AGC_R_48K			(0x1 << 5)
+#define RT5645_DRC_AGC_R_96K			(0x2 << 5)
+#define RT5645_DRC_AGC_R_192K			(0x3 << 5)
+#define RT5645_DRC_AGC_R_441K			(0x5 << 5)
+#define RT5645_DRC_AGC_R_882K			(0x6 << 5)
+#define RT5645_DRC_AGC_R_1764K			(0x7 << 5)
+#define RT5645_DRC_AGC_RC_MASK			(0x1f)
+#define RT5645_DRC_AGC_RC_SFT			0
+
+/* DRC/AGC Control 2 (0xb5) */
+#define RT5645_DRC_AGC_POB_MASK			(0x3f << 8)
+#define RT5645_DRC_AGC_POB_SFT			8
+#define RT5645_DRC_AGC_CP_MASK			(0x1 << 7)
+#define RT5645_DRC_AGC_CP_SFT			7
+#define RT5645_DRC_AGC_CP_DIS			(0x0 << 7)
+#define RT5645_DRC_AGC_CP_EN			(0x1 << 7)
+#define RT5645_DRC_AGC_CPR_MASK			(0x3 << 5)
+#define RT5645_DRC_AGC_CPR_SFT			5
+#define RT5645_DRC_AGC_CPR_1_1			(0x0 << 5)
+#define RT5645_DRC_AGC_CPR_1_2			(0x1 << 5)
+#define RT5645_DRC_AGC_CPR_1_3			(0x2 << 5)
+#define RT5645_DRC_AGC_CPR_1_4			(0x3 << 5)
+#define RT5645_DRC_AGC_PRB_MASK			(0x1f)
+#define RT5645_DRC_AGC_PRB_SFT			0
+
+/* DRC/AGC Control 3 (0xb6) */
+#define RT5645_DRC_AGC_NGB_MASK			(0xf << 12)
+#define RT5645_DRC_AGC_NGB_SFT			12
+#define RT5645_DRC_AGC_TAR_MASK			(0x1f << 7)
+#define RT5645_DRC_AGC_TAR_SFT			7
+#define RT5645_DRC_AGC_NG_MASK			(0x1 << 6)
+#define RT5645_DRC_AGC_NG_SFT			6
+#define RT5645_DRC_AGC_NG_DIS			(0x0 << 6)
+#define RT5645_DRC_AGC_NG_EN			(0x1 << 6)
+#define RT5645_DRC_AGC_NGH_MASK			(0x1 << 5)
+#define RT5645_DRC_AGC_NGH_SFT			5
+#define RT5645_DRC_AGC_NGH_DIS			(0x0 << 5)
+#define RT5645_DRC_AGC_NGH_EN			(0x1 << 5)
+#define RT5645_DRC_AGC_NGT_MASK			(0x1f)
+#define RT5645_DRC_AGC_NGT_SFT			0
+
+/* ANC Control 1 (0xb8) */
+#define RT5645_ANC_M_MASK			(0x1 << 15)
+#define RT5645_ANC_M_SFT			15
+#define RT5645_ANC_M_NOR			(0x0 << 15)
+#define RT5645_ANC_M_REV			(0x1 << 15)
+#define RT5645_ANC_MASK				(0x1 << 14)
+#define RT5645_ANC_SFT				14
+#define RT5645_ANC_DIS				(0x0 << 14)
+#define RT5645_ANC_EN				(0x1 << 14)
+#define RT5645_ANC_MD_MASK			(0x3 << 12)
+#define RT5645_ANC_MD_SFT			12
+#define RT5645_ANC_MD_DIS			(0x0 << 12)
+#define RT5645_ANC_MD_67MS			(0x1 << 12)
+#define RT5645_ANC_MD_267MS			(0x2 << 12)
+#define RT5645_ANC_MD_1067MS			(0x3 << 12)
+#define RT5645_ANC_SN_MASK			(0x1 << 11)
+#define RT5645_ANC_SN_SFT			11
+#define RT5645_ANC_SN_DIS			(0x0 << 11)
+#define RT5645_ANC_SN_EN			(0x1 << 11)
+#define RT5645_ANC_CLK_MASK			(0x1 << 10)
+#define RT5645_ANC_CLK_SFT			10
+#define RT5645_ANC_CLK_ANC			(0x0 << 10)
+#define RT5645_ANC_CLK_REG			(0x1 << 10)
+#define RT5645_ANC_ZCD_MASK			(0x3 << 8)
+#define RT5645_ANC_ZCD_SFT			8
+#define RT5645_ANC_ZCD_DIS			(0x0 << 8)
+#define RT5645_ANC_ZCD_T1			(0x1 << 8)
+#define RT5645_ANC_ZCD_T2			(0x2 << 8)
+#define RT5645_ANC_ZCD_WT			(0x3 << 8)
+#define RT5645_ANC_CS_MASK			(0x1 << 7)
+#define RT5645_ANC_CS_SFT			7
+#define RT5645_ANC_CS_DIS			(0x0 << 7)
+#define RT5645_ANC_CS_EN			(0x1 << 7)
+#define RT5645_ANC_SW_MASK			(0x1 << 6)
+#define RT5645_ANC_SW_SFT			6
+#define RT5645_ANC_SW_NOR			(0x0 << 6)
+#define RT5645_ANC_SW_AUTO			(0x1 << 6)
+#define RT5645_ANC_CO_L_MASK			(0x3f)
+#define RT5645_ANC_CO_L_SFT			0
+
+/* ANC Control 2 (0xb6) */
+#define RT5645_ANC_FG_R_MASK			(0xf << 12)
+#define RT5645_ANC_FG_R_SFT			12
+#define RT5645_ANC_FG_L_MASK			(0xf << 8)
+#define RT5645_ANC_FG_L_SFT			8
+#define RT5645_ANC_CG_R_MASK			(0xf << 4)
+#define RT5645_ANC_CG_R_SFT			4
+#define RT5645_ANC_CG_L_MASK			(0xf)
+#define RT5645_ANC_CG_L_SFT			0
+
+/* ANC Control 3 (0xb6) */
+#define RT5645_ANC_CD_MASK			(0x1 << 6)
+#define RT5645_ANC_CD_SFT			6
+#define RT5645_ANC_CD_BOTH			(0x0 << 6)
+#define RT5645_ANC_CD_IND			(0x1 << 6)
+#define RT5645_ANC_CO_R_MASK			(0x3f)
+#define RT5645_ANC_CO_R_SFT			0
+
+/* Jack Detect Control (0xbb) */
+#define RT5645_JD_MASK				(0x7 << 13)
+#define RT5645_JD_SFT				13
+#define RT5645_JD_DIS				(0x0 << 13)
+#define RT5645_JD_GPIO1				(0x1 << 13)
+#define RT5645_JD_JD1_IN4P			(0x2 << 13)
+#define RT5645_JD_JD2_IN4N			(0x3 << 13)
+#define RT5645_JD_GPIO2				(0x4 << 13)
+#define RT5645_JD_GPIO3				(0x5 << 13)
+#define RT5645_JD_GPIO4				(0x6 << 13)
+#define RT5645_JD_HP_MASK			(0x1 << 11)
+#define RT5645_JD_HP_SFT			11
+#define RT5645_JD_HP_DIS			(0x0 << 11)
+#define RT5645_JD_HP_EN				(0x1 << 11)
+#define RT5645_JD_HP_TRG_MASK			(0x1 << 10)
+#define RT5645_JD_HP_TRG_SFT			10
+#define RT5645_JD_HP_TRG_LO			(0x0 << 10)
+#define RT5645_JD_HP_TRG_HI			(0x1 << 10)
+#define RT5645_JD_SPL_MASK			(0x1 << 9)
+#define RT5645_JD_SPL_SFT			9
+#define RT5645_JD_SPL_DIS			(0x0 << 9)
+#define RT5645_JD_SPL_EN			(0x1 << 9)
+#define RT5645_JD_SPL_TRG_MASK			(0x1 << 8)
+#define RT5645_JD_SPL_TRG_SFT			8
+#define RT5645_JD_SPL_TRG_LO			(0x0 << 8)
+#define RT5645_JD_SPL_TRG_HI			(0x1 << 8)
+#define RT5645_JD_SPR_MASK			(0x1 << 7)
+#define RT5645_JD_SPR_SFT			7
+#define RT5645_JD_SPR_DIS			(0x0 << 7)
+#define RT5645_JD_SPR_EN			(0x1 << 7)
+#define RT5645_JD_SPR_TRG_MASK			(0x1 << 6)
+#define RT5645_JD_SPR_TRG_SFT			6
+#define RT5645_JD_SPR_TRG_LO			(0x0 << 6)
+#define RT5645_JD_SPR_TRG_HI			(0x1 << 6)
+#define RT5645_JD_MO_MASK			(0x1 << 5)
+#define RT5645_JD_MO_SFT			5
+#define RT5645_JD_MO_DIS			(0x0 << 5)
+#define RT5645_JD_MO_EN				(0x1 << 5)
+#define RT5645_JD_MO_TRG_MASK			(0x1 << 4)
+#define RT5645_JD_MO_TRG_SFT			4
+#define RT5645_JD_MO_TRG_LO			(0x0 << 4)
+#define RT5645_JD_MO_TRG_HI			(0x1 << 4)
+#define RT5645_JD_LO_MASK			(0x1 << 3)
+#define RT5645_JD_LO_SFT			3
+#define RT5645_JD_LO_DIS			(0x0 << 3)
+#define RT5645_JD_LO_EN				(0x1 << 3)
+#define RT5645_JD_LO_TRG_MASK			(0x1 << 2)
+#define RT5645_JD_LO_TRG_SFT			2
+#define RT5645_JD_LO_TRG_LO			(0x0 << 2)
+#define RT5645_JD_LO_TRG_HI			(0x1 << 2)
+#define RT5645_JD1_IN4P_MASK			(0x1 << 1)
+#define RT5645_JD1_IN4P_SFT			1
+#define RT5645_JD1_IN4P_DIS			(0x0 << 1)
+#define RT5645_JD1_IN4P_EN			(0x1 << 1)
+#define RT5645_JD2_IN4N_MASK			(0x1)
+#define RT5645_JD2_IN4N_SFT			0
+#define RT5645_JD2_IN4N_DIS			(0x0)
+#define RT5645_JD2_IN4N_EN			(0x1)
+
+/* Jack detect for ANC (0xbc) */
+#define RT5645_ANC_DET_MASK			(0x3 << 4)
+#define RT5645_ANC_DET_SFT			4
+#define RT5645_ANC_DET_DIS			(0x0 << 4)
+#define RT5645_ANC_DET_MB1			(0x1 << 4)
+#define RT5645_ANC_DET_MB2			(0x2 << 4)
+#define RT5645_ANC_DET_JD			(0x3 << 4)
+#define RT5645_AD_TRG_MASK			(0x1 << 3)
+#define RT5645_AD_TRG_SFT			3
+#define RT5645_AD_TRG_LO			(0x0 << 3)
+#define RT5645_AD_TRG_HI			(0x1 << 3)
+#define RT5645_ANCM_DET_MASK			(0x3 << 4)
+#define RT5645_ANCM_DET_SFT			4
+#define RT5645_ANCM_DET_DIS			(0x0 << 4)
+#define RT5645_ANCM_DET_MB1			(0x1 << 4)
+#define RT5645_ANCM_DET_MB2			(0x2 << 4)
+#define RT5645_ANCM_DET_JD			(0x3 << 4)
+#define RT5645_AMD_TRG_MASK			(0x1 << 3)
+#define RT5645_AMD_TRG_SFT			3
+#define RT5645_AMD_TRG_LO			(0x0 << 3)
+#define RT5645_AMD_TRG_HI			(0x1 << 3)
+
+/* IRQ Control 1 (0xbd) */
+#define RT5645_IRQ_JD_MASK			(0x1 << 15)
+#define RT5645_IRQ_JD_SFT			15
+#define RT5645_IRQ_JD_BP			(0x0 << 15)
+#define RT5645_IRQ_JD_NOR			(0x1 << 15)
+#define RT5645_IRQ_OT_MASK			(0x1 << 14)
+#define RT5645_IRQ_OT_SFT			14
+#define RT5645_IRQ_OT_BP			(0x0 << 14)
+#define RT5645_IRQ_OT_NOR			(0x1 << 14)
+#define RT5645_JD_STKY_MASK			(0x1 << 13)
+#define RT5645_JD_STKY_SFT			13
+#define RT5645_JD_STKY_DIS			(0x0 << 13)
+#define RT5645_JD_STKY_EN			(0x1 << 13)
+#define RT5645_OT_STKY_MASK			(0x1 << 12)
+#define RT5645_OT_STKY_SFT			12
+#define RT5645_OT_STKY_DIS			(0x0 << 12)
+#define RT5645_OT_STKY_EN			(0x1 << 12)
+#define RT5645_JD_P_MASK			(0x1 << 11)
+#define RT5645_JD_P_SFT				11
+#define RT5645_JD_P_NOR				(0x0 << 11)
+#define RT5645_JD_P_INV				(0x1 << 11)
+#define RT5645_OT_P_MASK			(0x1 << 10)
+#define RT5645_OT_P_SFT				10
+#define RT5645_OT_P_NOR				(0x0 << 10)
+#define RT5645_OT_P_INV				(0x1 << 10)
+
+/* IRQ Control 2 (0xbe) */
+#define RT5645_IRQ_MB1_OC_MASK			(0x1 << 15)
+#define RT5645_IRQ_MB1_OC_SFT			15
+#define RT5645_IRQ_MB1_OC_BP			(0x0 << 15)
+#define RT5645_IRQ_MB1_OC_NOR			(0x1 << 15)
+#define RT5645_IRQ_MB2_OC_MASK			(0x1 << 14)
+#define RT5645_IRQ_MB2_OC_SFT			14
+#define RT5645_IRQ_MB2_OC_BP			(0x0 << 14)
+#define RT5645_IRQ_MB2_OC_NOR			(0x1 << 14)
+#define RT5645_MB1_OC_STKY_MASK			(0x1 << 11)
+#define RT5645_MB1_OC_STKY_SFT			11
+#define RT5645_MB1_OC_STKY_DIS			(0x0 << 11)
+#define RT5645_MB1_OC_STKY_EN			(0x1 << 11)
+#define RT5645_MB2_OC_STKY_MASK			(0x1 << 10)
+#define RT5645_MB2_OC_STKY_SFT			10
+#define RT5645_MB2_OC_STKY_DIS			(0x0 << 10)
+#define RT5645_MB2_OC_STKY_EN			(0x1 << 10)
+#define RT5645_MB1_OC_P_MASK			(0x1 << 7)
+#define RT5645_MB1_OC_P_SFT			7
+#define RT5645_MB1_OC_P_NOR			(0x0 << 7)
+#define RT5645_MB1_OC_P_INV			(0x1 << 7)
+#define RT5645_MB2_OC_P_MASK			(0x1 << 6)
+#define RT5645_MB2_OC_P_SFT			6
+#define RT5645_MB2_OC_P_NOR			(0x0 << 6)
+#define RT5645_MB2_OC_P_INV			(0x1 << 6)
+#define RT5645_MB1_OC_CLR			(0x1 << 3)
+#define RT5645_MB1_OC_CLR_SFT			3
+#define RT5645_MB2_OC_CLR			(0x1 << 2)
+#define RT5645_MB2_OC_CLR_SFT			2
+
+/* GPIO Control 1 (0xc0) */
+#define RT5645_GP1_PIN_MASK			(0x1 << 15)
+#define RT5645_GP1_PIN_SFT			15
+#define RT5645_GP1_PIN_GPIO1			(0x0 << 15)
+#define RT5645_GP1_PIN_IRQ			(0x1 << 15)
+#define RT5645_GP2_PIN_MASK			(0x1 << 14)
+#define RT5645_GP2_PIN_SFT			14
+#define RT5645_GP2_PIN_GPIO2			(0x0 << 14)
+#define RT5645_GP2_PIN_DMIC1_SCL		(0x1 << 14)
+#define RT5645_GP3_PIN_MASK			(0x3 << 12)
+#define RT5645_GP3_PIN_SFT			12
+#define RT5645_GP3_PIN_GPIO3			(0x0 << 12)
+#define RT5645_GP3_PIN_DMIC1_SDA		(0x1 << 12)
+#define RT5645_GP3_PIN_IRQ			(0x2 << 12)
+#define RT5645_GP4_PIN_MASK			(0x1 << 11)
+#define RT5645_GP4_PIN_SFT			11
+#define RT5645_GP4_PIN_GPIO4			(0x0 << 11)
+#define RT5645_GP4_PIN_DMIC2_SDA		(0x1 << 11)
+#define RT5645_DP_SIG_MASK			(0x1 << 10)
+#define RT5645_DP_SIG_SFT			10
+#define RT5645_DP_SIG_TEST			(0x0 << 10)
+#define RT5645_DP_SIG_AP			(0x1 << 10)
+#define RT5645_GPIO_M_MASK			(0x1 << 9)
+#define RT5645_GPIO_M_SFT			9
+#define RT5645_GPIO_M_FLT			(0x0 << 9)
+#define RT5645_GPIO_M_PH			(0x1 << 9)
+#define RT5645_I2S2_SEL				(0x1 << 8)
+#define RT5645_I2S2_SEL_SFT			8
+#define RT5645_GP5_PIN_MASK			(0x1 << 7)
+#define RT5645_GP5_PIN_SFT			7
+#define RT5645_GP5_PIN_GPIO5			(0x0 << 7)
+#define RT5645_GP5_PIN_DMIC3_SCL		(0x1 << 7)
+#define RT5645_GP7_PIN_MASK			(0x3 << 4)
+#define RT5645_GP7_PIN_SFT			4
+#define RT5645_GP7_PIN_GPIO7			(0x0 << 4)
+#define RT5645_GP7_PIN_DMIC1_SDA		(0x1 << 4)
+#define RT5645_GP7_PIN_PDM_SCL2			(0x2 << 4)
+#define RT5645_GP8_PIN_MASK			(0x1 << 3)
+#define RT5645_GP8_PIN_SFT			3
+#define RT5645_GP8_PIN_GPIO8			(0x0 << 3)
+#define RT5645_GP8_PIN_DMIC2_SDA		(0x1 << 3)
+#define RT5645_GP9_PIN_MASK			(0x1 << 2)
+#define RT5645_GP9_PIN_SFT			2
+#define RT5645_GP9_PIN_GPIO9			(0x0 << 2)
+#define RT5645_GP9_PIN_DMIC3_SDA		(0x1 << 2)
+#define RT5645_GP10_PIN_MASK			(0x3)
+#define RT5645_GP10_PIN_SFT			0
+#define RT5645_GP10_PIN_GPIO9			(0x0)
+#define RT5645_GP10_PIN_DMIC3_SDA		(0x1)
+#define RT5645_GP10_PIN_PDM_ADT2		(0x2)
+
+/* GPIO Control 3 (0xc2) */
+#define RT5645_GP4_PF_MASK			(0x1 << 11)
+#define RT5645_GP4_PF_SFT			11
+#define RT5645_GP4_PF_IN			(0x0 << 11)
+#define RT5645_GP4_PF_OUT			(0x1 << 11)
+#define RT5645_GP4_OUT_MASK			(0x1 << 10)
+#define RT5645_GP4_OUT_SFT			10
+#define RT5645_GP4_OUT_LO			(0x0 << 10)
+#define RT5645_GP4_OUT_HI			(0x1 << 10)
+#define RT5645_GP4_P_MASK			(0x1 << 9)
+#define RT5645_GP4_P_SFT			9
+#define RT5645_GP4_P_NOR			(0x0 << 9)
+#define RT5645_GP4_P_INV			(0x1 << 9)
+#define RT5645_GP3_PF_MASK			(0x1 << 8)
+#define RT5645_GP3_PF_SFT			8
+#define RT5645_GP3_PF_IN			(0x0 << 8)
+#define RT5645_GP3_PF_OUT			(0x1 << 8)
+#define RT5645_GP3_OUT_MASK			(0x1 << 7)
+#define RT5645_GP3_OUT_SFT			7
+#define RT5645_GP3_OUT_LO			(0x0 << 7)
+#define RT5645_GP3_OUT_HI			(0x1 << 7)
+#define RT5645_GP3_P_MASK			(0x1 << 6)
+#define RT5645_GP3_P_SFT			6
+#define RT5645_GP3_P_NOR			(0x0 << 6)
+#define RT5645_GP3_P_INV			(0x1 << 6)
+#define RT5645_GP2_PF_MASK			(0x1 << 5)
+#define RT5645_GP2_PF_SFT			5
+#define RT5645_GP2_PF_IN			(0x0 << 5)
+#define RT5645_GP2_PF_OUT			(0x1 << 5)
+#define RT5645_GP2_OUT_MASK			(0x1 << 4)
+#define RT5645_GP2_OUT_SFT			4
+#define RT5645_GP2_OUT_LO			(0x0 << 4)
+#define RT5645_GP2_OUT_HI			(0x1 << 4)
+#define RT5645_GP2_P_MASK			(0x1 << 3)
+#define RT5645_GP2_P_SFT			3
+#define RT5645_GP2_P_NOR			(0x0 << 3)
+#define RT5645_GP2_P_INV			(0x1 << 3)
+#define RT5645_GP1_PF_MASK			(0x1 << 2)
+#define RT5645_GP1_PF_SFT			2
+#define RT5645_GP1_PF_IN			(0x0 << 2)
+#define RT5645_GP1_PF_OUT			(0x1 << 2)
+#define RT5645_GP1_OUT_MASK			(0x1 << 1)
+#define RT5645_GP1_OUT_SFT			1
+#define RT5645_GP1_OUT_LO			(0x0 << 1)
+#define RT5645_GP1_OUT_HI			(0x1 << 1)
+#define RT5645_GP1_P_MASK			(0x1)
+#define RT5645_GP1_P_SFT			0
+#define RT5645_GP1_P_NOR			(0x0)
+#define RT5645_GP1_P_INV			(0x1)
+
+/* Programmable Register Array Control 1 (0xc8) */
+#define RT5645_REG_SEQ_MASK			(0xf << 12)
+#define RT5645_REG_SEQ_SFT			12
+#define RT5645_SEQ1_ST_MASK			(0x1 << 11) /*RO*/
+#define RT5645_SEQ1_ST_SFT			11
+#define RT5645_SEQ1_ST_RUN			(0x0 << 11)
+#define RT5645_SEQ1_ST_FIN			(0x1 << 11)
+#define RT5645_SEQ2_ST_MASK			(0x1 << 10) /*RO*/
+#define RT5645_SEQ2_ST_SFT			10
+#define RT5645_SEQ2_ST_RUN			(0x0 << 10)
+#define RT5645_SEQ2_ST_FIN			(0x1 << 10)
+#define RT5645_REG_LV_MASK			(0x1 << 9)
+#define RT5645_REG_LV_SFT			9
+#define RT5645_REG_LV_MX			(0x0 << 9)
+#define RT5645_REG_LV_PR			(0x1 << 9)
+#define RT5645_SEQ_2_PT_MASK			(0x1 << 8)
+#define RT5645_SEQ_2_PT_BIT			8
+#define RT5645_REG_IDX_MASK			(0xff)
+#define RT5645_REG_IDX_SFT			0
+
+/* Programmable Register Array Control 2 (0xc9) */
+#define RT5645_REG_DAT_MASK			(0xffff)
+#define RT5645_REG_DAT_SFT			0
+
+/* Programmable Register Array Control 3 (0xca) */
+#define RT5645_SEQ_DLY_MASK			(0xff << 8)
+#define RT5645_SEQ_DLY_SFT			8
+#define RT5645_PROG_MASK			(0x1 << 7)
+#define RT5645_PROG_SFT				7
+#define RT5645_PROG_DIS				(0x0 << 7)
+#define RT5645_PROG_EN				(0x1 << 7)
+#define RT5645_SEQ1_PT_RUN			(0x1 << 6)
+#define RT5645_SEQ1_PT_RUN_BIT			6
+#define RT5645_SEQ2_PT_RUN			(0x1 << 5)
+#define RT5645_SEQ2_PT_RUN_BIT			5
+
+/* Programmable Register Array Control 4 (0xcb) */
+#define RT5645_SEQ1_START_MASK			(0xf << 8)
+#define RT5645_SEQ1_START_SFT			8
+#define RT5645_SEQ1_END_MASK			(0xf)
+#define RT5645_SEQ1_END_SFT			0
+
+/* Programmable Register Array Control 5 (0xcc) */
+#define RT5645_SEQ2_START_MASK			(0xf << 8)
+#define RT5645_SEQ2_START_SFT			8
+#define RT5645_SEQ2_END_MASK			(0xf)
+#define RT5645_SEQ2_END_SFT			0
+
+/* Scramble Function (0xcd) */
+#define RT5645_SCB_KEY_MASK			(0xff)
+#define RT5645_SCB_KEY_SFT			0
+
+/* Scramble Control (0xce) */
+#define RT5645_SCB_SWAP_MASK			(0x1 << 15)
+#define RT5645_SCB_SWAP_SFT			15
+#define RT5645_SCB_SWAP_DIS			(0x0 << 15)
+#define RT5645_SCB_SWAP_EN			(0x1 << 15)
+#define RT5645_SCB_MASK				(0x1 << 14)
+#define RT5645_SCB_SFT				14
+#define RT5645_SCB_DIS				(0x0 << 14)
+#define RT5645_SCB_EN				(0x1 << 14)
+
+/* Baseback Control (0xcf) */
+#define RT5645_BB_MASK				(0x1 << 15)
+#define RT5645_BB_SFT				15
+#define RT5645_BB_DIS				(0x0 << 15)
+#define RT5645_BB_EN				(0x1 << 15)
+#define RT5645_BB_CT_MASK			(0x7 << 12)
+#define RT5645_BB_CT_SFT			12
+#define RT5645_BB_CT_A				(0x0 << 12)
+#define RT5645_BB_CT_B				(0x1 << 12)
+#define RT5645_BB_CT_C				(0x2 << 12)
+#define RT5645_BB_CT_D				(0x3 << 12)
+#define RT5645_M_BB_L_MASK			(0x1 << 9)
+#define RT5645_M_BB_L_SFT			9
+#define RT5645_M_BB_R_MASK			(0x1 << 8)
+#define RT5645_M_BB_R_SFT			8
+#define RT5645_M_BB_HPF_L_MASK			(0x1 << 7)
+#define RT5645_M_BB_HPF_L_SFT			7
+#define RT5645_M_BB_HPF_R_MASK			(0x1 << 6)
+#define RT5645_M_BB_HPF_R_SFT			6
+#define RT5645_G_BB_BST_MASK			(0x3f)
+#define RT5645_G_BB_BST_SFT			0
+
+/* MP3 Plus Control 1 (0xd0) */
+#define RT5645_M_MP3_L_MASK			(0x1 << 15)
+#define RT5645_M_MP3_L_SFT			15
+#define RT5645_M_MP3_R_MASK			(0x1 << 14)
+#define RT5645_M_MP3_R_SFT			14
+#define RT5645_M_MP3_MASK			(0x1 << 13)
+#define RT5645_M_MP3_SFT			13
+#define RT5645_M_MP3_DIS			(0x0 << 13)
+#define RT5645_M_MP3_EN				(0x1 << 13)
+#define RT5645_EG_MP3_MASK			(0x1f << 8)
+#define RT5645_EG_MP3_SFT			8
+#define RT5645_MP3_HLP_MASK			(0x1 << 7)
+#define RT5645_MP3_HLP_SFT			7
+#define RT5645_MP3_HLP_DIS			(0x0 << 7)
+#define RT5645_MP3_HLP_EN			(0x1 << 7)
+#define RT5645_M_MP3_ORG_L_MASK			(0x1 << 6)
+#define RT5645_M_MP3_ORG_L_SFT			6
+#define RT5645_M_MP3_ORG_R_MASK			(0x1 << 5)
+#define RT5645_M_MP3_ORG_R_SFT			5
+
+/* MP3 Plus Control 2 (0xd1) */
+#define RT5645_MP3_WT_MASK			(0x1 << 13)
+#define RT5645_MP3_WT_SFT			13
+#define RT5645_MP3_WT_1_4			(0x0 << 13)
+#define RT5645_MP3_WT_1_2			(0x1 << 13)
+#define RT5645_OG_MP3_MASK			(0x1f << 8)
+#define RT5645_OG_MP3_SFT			8
+#define RT5645_HG_MP3_MASK			(0x3f)
+#define RT5645_HG_MP3_SFT			0
+
+/* 3D HP Control 1 (0xd2) */
+#define RT5645_3D_CF_MASK			(0x1 << 15)
+#define RT5645_3D_CF_SFT			15
+#define RT5645_3D_CF_DIS			(0x0 << 15)
+#define RT5645_3D_CF_EN				(0x1 << 15)
+#define RT5645_3D_HP_MASK			(0x1 << 14)
+#define RT5645_3D_HP_SFT			14
+#define RT5645_3D_HP_DIS			(0x0 << 14)
+#define RT5645_3D_HP_EN				(0x1 << 14)
+#define RT5645_3D_BT_MASK			(0x1 << 13)
+#define RT5645_3D_BT_SFT			13
+#define RT5645_3D_BT_DIS			(0x0 << 13)
+#define RT5645_3D_BT_EN				(0x1 << 13)
+#define RT5645_3D_1F_MIX_MASK			(0x3 << 11)
+#define RT5645_3D_1F_MIX_SFT			11
+#define RT5645_3D_HP_M_MASK			(0x1 << 10)
+#define RT5645_3D_HP_M_SFT			10
+#define RT5645_3D_HP_M_SUR			(0x0 << 10)
+#define RT5645_3D_HP_M_FRO			(0x1 << 10)
+#define RT5645_M_3D_HRTF_MASK			(0x1 << 9)
+#define RT5645_M_3D_HRTF_SFT			9
+#define RT5645_M_3D_D2H_MASK			(0x1 << 8)
+#define RT5645_M_3D_D2H_SFT			8
+#define RT5645_M_3D_D2R_MASK			(0x1 << 7)
+#define RT5645_M_3D_D2R_SFT			7
+#define RT5645_M_3D_REVB_MASK			(0x1 << 6)
+#define RT5645_M_3D_REVB_SFT			6
+
+/* Adjustable high pass filter control 1 (0xd3) */
+#define RT5645_2ND_HPF_MASK			(0x1 << 15)
+#define RT5645_2ND_HPF_SFT			15
+#define RT5645_2ND_HPF_DIS			(0x0 << 15)
+#define RT5645_2ND_HPF_EN			(0x1 << 15)
+#define RT5645_HPF_CF_L_MASK			(0x7 << 12)
+#define RT5645_HPF_CF_L_SFT			12
+#define RT5645_1ST_HPF_MASK			(0x1 << 11)
+#define RT5645_1ST_HPF_SFT			11
+#define RT5645_1ST_HPF_DIS			(0x0 << 11)
+#define RT5645_1ST_HPF_EN			(0x1 << 11)
+#define RT5645_HPF_CF_R_MASK			(0x7 << 8)
+#define RT5645_HPF_CF_R_SFT			8
+#define RT5645_ZD_T_MASK			(0x3 << 6)
+#define RT5645_ZD_T_SFT				6
+#define RT5645_ZD_F_MASK			(0x3 << 4)
+#define RT5645_ZD_F_SFT				4
+#define RT5645_ZD_F_IM				(0x0 << 4)
+#define RT5645_ZD_F_ZC_IM			(0x1 << 4)
+#define RT5645_ZD_F_ZC_IOD			(0x2 << 4)
+#define RT5645_ZD_F_UN				(0x3 << 4)
+
+/* HP calibration control and Amp detection (0xd6) */
+#define RT5645_SI_DAC_MASK			(0x1 << 11)
+#define RT5645_SI_DAC_SFT			11
+#define RT5645_SI_DAC_AUTO			(0x0 << 11)
+#define RT5645_SI_DAC_TEST			(0x1 << 11)
+#define RT5645_DC_CAL_M_MASK			(0x1 << 10)
+#define RT5645_DC_CAL_M_SFT			10
+#define RT5645_DC_CAL_M_CAL			(0x0 << 10)
+#define RT5645_DC_CAL_M_NOR			(0x1 << 10)
+#define RT5645_DC_CAL_MASK			(0x1 << 9)
+#define RT5645_DC_CAL_SFT			9
+#define RT5645_DC_CAL_DIS			(0x0 << 9)
+#define RT5645_DC_CAL_EN			(0x1 << 9)
+#define RT5645_HPD_RCV_MASK			(0x7 << 6)
+#define RT5645_HPD_RCV_SFT			6
+#define RT5645_HPD_PS_MASK			(0x1 << 5)
+#define RT5645_HPD_PS_SFT			5
+#define RT5645_HPD_PS_DIS			(0x0 << 5)
+#define RT5645_HPD_PS_EN			(0x1 << 5)
+#define RT5645_CAL_M_MASK			(0x1 << 4)
+#define RT5645_CAL_M_SFT			4
+#define RT5645_CAL_M_DEP			(0x0 << 4)
+#define RT5645_CAL_M_CAL			(0x1 << 4)
+#define RT5645_CAL_MASK				(0x1 << 3)
+#define RT5645_CAL_SFT				3
+#define RT5645_CAL_DIS				(0x0 << 3)
+#define RT5645_CAL_EN				(0x1 << 3)
+#define RT5645_CAL_TEST_MASK			(0x1 << 2)
+#define RT5645_CAL_TEST_SFT			2
+#define RT5645_CAL_TEST_DIS			(0x0 << 2)
+#define RT5645_CAL_TEST_EN			(0x1 << 2)
+#define RT5645_CAL_P_MASK			(0x3)
+#define RT5645_CAL_P_SFT			0
+#define RT5645_CAL_P_NONE			(0x0)
+#define RT5645_CAL_P_CAL			(0x1)
+#define RT5645_CAL_P_DAC_CAL			(0x2)
+
+/* Soft volume and zero cross control 1 (0xd9) */
+#define RT5645_SV_MASK				(0x1 << 15)
+#define RT5645_SV_SFT				15
+#define RT5645_SV_DIS				(0x0 << 15)
+#define RT5645_SV_EN				(0x1 << 15)
+#define RT5645_SPO_SV_MASK			(0x1 << 14)
+#define RT5645_SPO_SV_SFT			14
+#define RT5645_SPO_SV_DIS			(0x0 << 14)
+#define RT5645_SPO_SV_EN			(0x1 << 14)
+#define RT5645_OUT_SV_MASK			(0x1 << 13)
+#define RT5645_OUT_SV_SFT			13
+#define RT5645_OUT_SV_DIS			(0x0 << 13)
+#define RT5645_OUT_SV_EN			(0x1 << 13)
+#define RT5645_HP_SV_MASK			(0x1 << 12)
+#define RT5645_HP_SV_SFT			12
+#define RT5645_HP_SV_DIS			(0x0 << 12)
+#define RT5645_HP_SV_EN				(0x1 << 12)
+#define RT5645_ZCD_DIG_MASK			(0x1 << 11)
+#define RT5645_ZCD_DIG_SFT			11
+#define RT5645_ZCD_DIG_DIS			(0x0 << 11)
+#define RT5645_ZCD_DIG_EN			(0x1 << 11)
+#define RT5645_ZCD_MASK				(0x1 << 10)
+#define RT5645_ZCD_SFT				10
+#define RT5645_ZCD_PD				(0x0 << 10)
+#define RT5645_ZCD_PU				(0x1 << 10)
+#define RT5645_M_ZCD_MASK			(0x3f << 4)
+#define RT5645_M_ZCD_SFT			4
+#define RT5645_M_ZCD_RM_L			(0x1 << 9)
+#define RT5645_M_ZCD_RM_R			(0x1 << 8)
+#define RT5645_M_ZCD_SM_L			(0x1 << 7)
+#define RT5645_M_ZCD_SM_R			(0x1 << 6)
+#define RT5645_M_ZCD_OM_L			(0x1 << 5)
+#define RT5645_M_ZCD_OM_R			(0x1 << 4)
+#define RT5645_SV_DLY_MASK			(0xf)
+#define RT5645_SV_DLY_SFT			0
+
+/* Soft volume and zero cross control 2 (0xda) */
+#define RT5645_ZCD_HP_MASK			(0x1 << 15)
+#define RT5645_ZCD_HP_SFT			15
+#define RT5645_ZCD_HP_DIS			(0x0 << 15)
+#define RT5645_ZCD_HP_EN			(0x1 << 15)
+
+
+/* Codec Private Register definition */
+/* 3D Speaker Control (0x63) */
+#define RT5645_3D_SPK_MASK			(0x1 << 15)
+#define RT5645_3D_SPK_SFT			15
+#define RT5645_3D_SPK_DIS			(0x0 << 15)
+#define RT5645_3D_SPK_EN			(0x1 << 15)
+#define RT5645_3D_SPK_M_MASK			(0x3 << 13)
+#define RT5645_3D_SPK_M_SFT			13
+#define RT5645_3D_SPK_CG_MASK			(0x1f << 8)
+#define RT5645_3D_SPK_CG_SFT			8
+#define RT5645_3D_SPK_SG_MASK			(0x1f)
+#define RT5645_3D_SPK_SG_SFT			0
+
+/* Wind Noise Detection Control 1 (0x6c) */
+#define RT5645_WND_MASK				(0x1 << 15)
+#define RT5645_WND_SFT				15
+#define RT5645_WND_DIS				(0x0 << 15)
+#define RT5645_WND_EN				(0x1 << 15)
+
+/* Wind Noise Detection Control 2 (0x6d) */
+#define RT5645_WND_FC_NW_MASK			(0x3f << 10)
+#define RT5645_WND_FC_NW_SFT			10
+#define RT5645_WND_FC_WK_MASK			(0x3f << 4)
+#define RT5645_WND_FC_WK_SFT			4
+
+/* Wind Noise Detection Control 3 (0x6e) */
+#define RT5645_HPF_FC_MASK			(0x3f << 6)
+#define RT5645_HPF_FC_SFT			6
+#define RT5645_WND_FC_ST_MASK			(0x3f)
+#define RT5645_WND_FC_ST_SFT			0
+
+/* Wind Noise Detection Control 4 (0x6f) */
+#define RT5645_WND_TH_LO_MASK			(0x3ff)
+#define RT5645_WND_TH_LO_SFT			0
+
+/* Wind Noise Detection Control 5 (0x70) */
+#define RT5645_WND_TH_HI_MASK			(0x3ff)
+#define RT5645_WND_TH_HI_SFT			0
+
+/* Wind Noise Detection Control 8 (0x73) */
+#define RT5645_WND_WIND_MASK			(0x1 << 13) /* Read-Only */
+#define RT5645_WND_WIND_SFT			13
+#define RT5645_WND_STRONG_MASK			(0x1 << 12) /* Read-Only */
+#define RT5645_WND_STRONG_SFT			12
+enum {
+	RT5645_NO_WIND,
+	RT5645_BREEZE,
+	RT5645_STORM,
+};
+
+/* Dipole Speaker Interface (0x75) */
+#define RT5645_DP_ATT_MASK			(0x3 << 14)
+#define RT5645_DP_ATT_SFT			14
+#define RT5645_DP_SPK_MASK			(0x1 << 10)
+#define RT5645_DP_SPK_SFT			10
+#define RT5645_DP_SPK_DIS			(0x0 << 10)
+#define RT5645_DP_SPK_EN			(0x1 << 10)
+
+/* EQ Pre Volume Control (0xb3) */
+#define RT5645_EQ_PRE_VOL_MASK			(0xffff)
+#define RT5645_EQ_PRE_VOL_SFT			0
+
+/* EQ Post Volume Control (0xb4) */
+#define RT5645_EQ_PST_VOL_MASK			(0xffff)
+#define RT5645_EQ_PST_VOL_SFT			0
+
+/* Jack Detect Control 3 (0xf8) */
+#define RT5645_CMP_MIC_IN_DET_MASK		(0x7 << 12)
+#define RT5645_JD_CBJ_EN			(0x1 << 7)
+#define RT5645_JD_CBJ_POL			(0x1 << 6)
+#define RT5645_JD_TRI_CBJ_SEL_MASK		(0x7 << 3)
+#define RT5645_JD_TRI_CBJ_SEL_SFT		(3)
+#define RT5645_JD_TRI_HPO_SEL_MASK		(0x7)
+#define RT5645_JD_TRI_HPO_SEL_SFT		(0)
+#define RT5645_JD_F_GPIO_JD1			(0x0)
+#define RT5645_JD_F_JD1_1			(0x1)
+#define RT5645_JD_F_JD1_2			(0x2)
+#define RT5645_JD_F_JD2				(0x3)
+#define RT5645_JD_F_JD3				(0x4)
+#define RT5645_JD_F_GPIO_JD2			(0x5)
+#define RT5645_JD_F_MX0B_12			(0x6)
+
+/* Digital Misc Control (0xfa) */
+#define RT5645_RST_DSP				(0x1 << 13)
+#define RT5645_IF1_ADC1_IN1_SEL			(0x1 << 12)
+#define RT5645_IF1_ADC1_IN1_SFT			12
+#define RT5645_IF1_ADC1_IN2_SEL			(0x1 << 11)
+#define RT5645_IF1_ADC1_IN2_SFT			11
+#define RT5645_IF1_ADC2_IN1_SEL			(0x1 << 10)
+#define RT5645_IF1_ADC2_IN1_SFT			10
+#define RT5645_DIG_GATE_CTRL			0x1
+
+/* General Control2 (0xfb) */
+#define RT5645_RXDC_SRC_MASK			(0x1 << 7)
+#define RT5645_RXDC_SRC_STO			(0x0 << 7)
+#define RT5645_RXDC_SRC_MONO			(0x1 << 7)
+#define RT5645_RXDC_SRC_SFT			(7)
+#define RT5645_RXDP2_SEL_MASK			(0x1 << 3)
+#define RT5645_RXDP2_SEL_IF2			(0x0 << 3)
+#define RT5645_RXDP2_SEL_ADC			(0x1 << 3)
+#define RT5645_RXDP2_SEL_SFT			(3)
+
+
+/* Vendor ID (0xfd) */
+#define RT5645_VER_C				0x2
+#define RT5645_VER_D				0x3
+
+
+/* Volume Rescale */
+#define RT5645_VOL_RSCL_MAX 0x27
+#define RT5645_VOL_RSCL_RANGE 0x1F
+/* Debug String Length */
+#define RT5645_REG_DISP_LEN 23
+
+int rt5645_headset_detect(struct snd_soc_codec *codec, int jack_insert);
+int rt5645_check_jd_status(struct snd_soc_codec *codec);
+int rt5645_button_detect(struct snd_soc_codec *codec);
+/* System Clock Source */
+enum {
+	RT5645_SCLK_S_MCLK,
+	RT5645_SCLK_S_PLL1,
+	RT5645_SCLK_S_RCCLK,
+};
+
+/* PLL1 Source */
+enum {
+	RT5645_PLL1_S_MCLK,
+	RT5645_PLL1_S_BCLK1,
+	RT5645_PLL1_S_BCLK2,
+};
+
+enum {
+	RT5645_AIF1,
+	RT5645_AIF2,
+	RT5645_AIFS,
+};
+
+enum {
+	RT5645_DMIC_DIS,
+	RT5645_DMIC1,
+	RT5645_DMIC2,
+};
+
+struct rt5645_pll_code {
+	bool m_bp; /* Indicates bypass m code or not. */
+	int m_code;
+	int n_code;
+	int k_code;
+};
+
+struct rt5645_priv {
+	struct snd_soc_codec *codec;
+
+	int aif_pu;
+	int sysclk;
+	int sysclk_src;
+	int lrck[RT5645_AIFS];
+	int bclk[RT5645_AIFS];
+	int master[RT5645_AIFS];
+
+	int pll_src;
+	int pll_in;
+	int pll_out;
+
+	int eq_mode;
+	int dmic_en;
+	bool combo_jack_en;
+
+	unsigned int adb_reg_addr[0x100];
+	unsigned int adb_reg_value[0x100];
+	unsigned char adb_reg_num;
+};
+
+#endif /* __RT5645_H__ */
diff --git a/sound/soc/codecs/rt5645_ioctl.c b/sound/soc/codecs/rt5645_ioctl.c
new file mode 100644
index 0000000..d71c26c
--- /dev/null
+++ b/sound/soc/codecs/rt5645_ioctl.c
@@ -0,0 +1,153 @@
+/*
+ * rt5645_ioctl.h  --  RT5645 ALSA SoC audio driver IO control
+ *
+ * Copyright 2012 Realtek Microelectronics
+ * Author: Bard <bardliao@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/spi/spi.h>
+#include <sound/soc.h>
+#include "rt_codec_ioctl_5645.h"
+#include "rt5645_ioctl.h"
+#include "rt5645.h"
+
+static struct hweq_s hweq_param[] = {
+	{/* NORMAL */
+		{0},
+		{0},
+		0x0000,
+	},
+	{/* CLUB */
+		{0},
+		{0x1bbc, 0x0c73, 0x030b, 0xff24, 0x1ea6, 0xe4d9, 0x1c98, 0x589d,
+		0x01bd, 0xd344, 0x01ca, 0x2940, 0xd8cb, 0x1bbc, 0x0000, 0xef01,
+		0x1bbc, 0x0000, 0xef01, 0x1bbc, 0x0000, 0x0257, 0x0000, 0x1cc9,
+		0x02eb, 0x1cee, 0x0800, 0x0800},
+		0x0082,
+	},
+	{/* SPK */
+		{0},
+		{0x1c10, 0x01f4, 0xc5e9, 0x1a98, 0x1d2c, 0xc882, 0x1c10,
+		0x01f4, 0xe904, 0x1c10, 0x01f4, 0xe904, 0x1c10, 0x01f4,
+		0x1c10, 0x01f4, 0x2000, 0x0000, 0x2000},
+		0x0000,
+	},
+	{/* HP */
+		{0},
+		{0x1c10, 0x01f4, 0xc5e9, 0x1a98, 0x1d2c, 0xc882, 0x1c10, 0x01f4,
+		0xe904, 0x1c10, 0x01f4, 0xe904, 0x1c10, 0x01f4, 0x1c10, 0x01f4,
+		0x2000, 0x0000, 0x2000},
+		0x0000,
+	},
+};
+#define RT5645_HWEQ_LEN ARRAY_SIZE(hweq_param)
+
+int eqreg5645[EQ_CH_NUM][EQ_REG_NUM] = {
+	{0xa4, 0xa5, 0xeb, 0xec, 0xed, 0xee, 0xe7, 0xe8, 0xe9, 0xea, 0xe5,
+	 0xe6, 0xae, 0xaf, 0xb0, 0xb4, 0xb5, 0xb6, 0xba, 0xbb, 0xbc, 0xc0,
+	 0xc1, 0xc4, 0xc5, 0xc6, 0xca, 0xcc},
+	{0xa6, 0xa7, 0xf5, 0xf6, 0xf7, 0xf8, 0xf1, 0xf2, 0xf3, 0xf4, 0xef,
+	 0xf0, 0xb1, 0xb2, 0xb3, 0xb7, 0xb8, 0xb9, 0xbd, 0xbe, 0xbf, 0xc2,
+	 0xc3, 0xc7, 0xc8, 0xc9, 0xcb, 0xcd},
+	{0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
+	 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xe1, 0xe2},
+};
+
+int rt5645_update_eqmode(
+	struct snd_soc_codec *codec, int channel, int mode)
+{
+	struct rt_codec_ops *ioctl_ops = rt5645_codec_get_ioctl_ops();
+	int i, upd_reg, reg, mask;
+
+	if (codec == NULL ||  mode >= RT5645_HWEQ_LEN)
+		return -EINVAL;
+
+	dev_dbg(codec->dev, "%s(): mode=%d\n", __func__, mode);
+	if (mode != NORMAL) {
+		for (i = 0; i < EQ_REG_NUM; i++)
+			hweq_param[mode].reg[i] = eqreg5645[channel][i];
+
+		for (i = 0; i < EQ_REG_NUM; i++) {
+			if (hweq_param[mode].reg[i])
+				ioctl_ops->index_write(codec,
+						hweq_param[mode].reg[i],
+						hweq_param[mode].value[i]);
+			else
+				break;
+		}
+	}
+	switch (channel) {
+	case EQ_CH_DACL:
+		reg = RT5645_EQ_CTRL2;
+		mask = 0x11fe;
+		upd_reg = RT5645_EQ_CTRL1;
+		break;
+	case EQ_CH_DACR:
+		reg = RT5645_EQ_CTRL2;
+		mask = 0x22fe;
+		upd_reg = RT5645_EQ_CTRL1;
+		break;
+	case EQ_CH_ADC:
+		reg = RT5645_ADC_EQ_CTRL2;
+		mask = 0x01bf;
+		upd_reg = RT5645_ADC_EQ_CTRL1;
+		break;
+	default:
+		dev_err(codec->dev, "Invalid EQ channel\n");
+		return -EINVAL;
+	}
+	snd_soc_update_bits(codec, reg, mask, hweq_param[mode].ctrl);
+	snd_soc_update_bits(codec, upd_reg,
+		RT5645_EQ_UPD, RT5645_EQ_UPD);
+	snd_soc_update_bits(codec, upd_reg, RT5645_EQ_UPD, 0);
+
+	return 0;
+}
+
+int rt5645_ioctl_common(struct snd_hwdep *hw, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	struct snd_soc_codec *codec = hw->private_data;
+	struct rt_codec_cmd __user *_rt_codec = (struct rt_codec_cmd *)arg;
+	struct rt_codec_cmd rt_codec;
+	/*struct rt_codec_ops *ioctl_ops = rt_codec_get_ioctl_ops();*/
+	int *buf;
+	static int eq_mode[EQ_CH_NUM];
+
+	if (copy_from_user(&rt_codec, _rt_codec, sizeof(rt_codec))) {
+		dev_err(codec->dev, "copy_from_user faild\n");
+		return -EFAULT;
+	}
+	dev_dbg(codec->dev, "%s(): rt_codec.number=%d, cmd=%d\n",
+			__func__, (int)rt_codec.number, cmd);
+	buf = memdup_user(rt_codec.buf, sizeof(*buf) * rt_codec.number);
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+
+	switch (cmd) {
+	case RT_SET_CODEC_HWEQ_IOCTL:
+		if (eq_mode[0] == *buf)
+			break;
+		eq_mode[*buf] = *(buf + 1);
+		rt5645_update_eqmode(codec, eq_mode[*buf], *buf);
+		break;
+
+	case RT_GET_CODEC_ID:
+		*buf = snd_soc_read(codec, RT5645_VENDOR_ID2);
+		if (copy_to_user(rt_codec.buf, buf,
+					sizeof(*buf) * rt_codec.number))
+			goto err;
+		break;
+	default:
+		break;
+	}
+
+err:
+	kfree(buf);
+	return -EFAULT;
+}
+EXPORT_SYMBOL_GPL(rt5645_ioctl_common);
diff --git a/sound/soc/codecs/rt5645_ioctl.h b/sound/soc/codecs/rt5645_ioctl.h
new file mode 100644
index 0000000..159aeb19
--- /dev/null
+++ b/sound/soc/codecs/rt5645_ioctl.h
@@ -0,0 +1,47 @@
+/*
+ * rt5645_ioctl.h  --  RT5645 ALSA SoC audio driver IO control
+ *
+ * Copyright 2012 Realtek Microelectronics
+ * Author: Bard <bardliao@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __RT5645_IOCTL_H__
+#define __RT5645_IOCTL_H__
+
+#include <sound/hwdep.h>
+#include <linux/ioctl.h>
+
+enum {
+	NORMAL = 0,
+	CLUB,
+	SPK,
+	HP,
+	MODE_NUM,
+};
+
+enum {
+	EQ_CH_DACL = 0,
+	EQ_CH_DACR,
+	EQ_CH_ADC,
+	EQ_CH_NUM,
+};
+
+
+
+#define EQ_REG_NUM 28
+struct  hweq_s {
+	unsigned int reg[EQ_REG_NUM];
+	unsigned int value[EQ_REG_NUM];
+	unsigned int ctrl;
+};
+
+int rt5645_ioctl_common(struct snd_hwdep *hw, struct file *file,
+			unsigned int cmd, unsigned long arg);
+int rt5645_update_eqmode(
+	struct snd_soc_codec *codec, int channel, int mode);
+
+#endif /* __RT5645_IOCTL_H__ */
diff --git a/sound/soc/codecs/rt_codec_ioctl_5645.c b/sound/soc/codecs/rt_codec_ioctl_5645.c
new file mode 100644
index 0000000..f3ec337
--- /dev/null
+++ b/sound/soc/codecs/rt_codec_ioctl_5645.c
@@ -0,0 +1,181 @@
+/*
+ * rt_codec_ioctl.h  --  RT56XX ALSA SoC audio driver IO control
+ *
+ * Copyright 2012 Realtek Microelectronics
+ * Author: Bard <bardliao@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/spi/spi.h>
+#include <sound/soc.h>
+#include "rt_codec_ioctl_5645.h"
+
+static struct rt_codec_ops rt_codec_ioctl_ops;
+
+#if defined(CONFIG_SND_HWDEP) || defined(CONFIG_SND_HWDEP_MODULE)
+#define RT_CE_CODEC_HWDEP_NAME "rt_codec hwdep "
+static int rt_codec_hwdep_open(struct snd_hwdep *hw, struct file *file)
+{
+	struct snd_soc_codec *codec = hw->private_data;
+	dev_dbg(codec->dev, "%s()\n", __func__);
+	return 0;
+}
+
+static int rt_codec_hwdep_release(struct snd_hwdep *hw, struct file *file)
+{
+	struct snd_soc_codec *codec = hw->private_data;
+	dev_dbg(codec->dev, "%s()\n", __func__);
+	return 0;
+}
+
+static int rt_codec_hwdep_ioctl_common(struct snd_hwdep *hw,
+		struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct snd_soc_codec *codec = hw->private_data;
+	struct rt_codec_cmd __user *_rt_codec = (struct rt_codec_cmd *)arg;
+	struct rt_codec_cmd rt_codec;
+	int *buf, *p;
+
+	if (copy_from_user(&rt_codec, _rt_codec, sizeof(rt_codec))) {
+		dev_err(codec->dev, "copy_from_user faild\n");
+		return -EFAULT;
+	}
+	dev_dbg(codec->dev, "%s(): rt_codec.number=%d, cmd=%d\n",
+			__func__, (int)rt_codec.number, cmd);
+	buf = memdup_user(rt_codec.buf, sizeof(*buf) * rt_codec.number);
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+
+	switch (cmd) {
+	case RT_READ_CODEC_REG_IOCTL:
+		for (p = buf; p < buf + rt_codec.number / 2; p++)
+			*(p + rt_codec.number / 2) = snd_soc_read(codec, *p);
+
+		if (copy_to_user(rt_codec.buf, buf,
+					sizeof(*buf) * rt_codec.number))
+			goto err;
+		break;
+
+	case RT_WRITE_CODEC_REG_IOCTL:
+		for (p = buf; p < buf + rt_codec.number / 2; p++)
+			snd_soc_write(codec, *p, *(p + rt_codec.number / 2));
+		break;
+
+	case RT_READ_CODEC_INDEX_IOCTL:
+		if (NULL == rt_codec_ioctl_ops.index_read)
+			goto err;
+
+		for (p = buf; p < buf + rt_codec.number / 2; p++)
+			*(p+rt_codec.number/2) = rt_codec_ioctl_ops.index_read(
+							codec, *p);
+		if (copy_to_user(rt_codec.buf, buf,
+			sizeof(*buf) * rt_codec.number))
+			goto err;
+		break;
+
+	case RT_WRITE_CODEC_INDEX_IOCTL:
+		if (NULL == rt_codec_ioctl_ops.index_write)
+			goto err;
+
+		for (p = buf; p < buf + rt_codec.number / 2; p++) {
+			dev_dbg(codec->dev, "%x , %x\n",
+				*p, *(p+rt_codec.number/2));
+			rt_codec_ioctl_ops.index_write(codec, *p,
+				*(p+rt_codec.number/2));
+		}
+		break;
+
+	default:
+		if (NULL == rt_codec_ioctl_ops.ioctl_common)
+			goto err;
+
+		rt_codec_ioctl_ops.ioctl_common(hw, file, cmd, arg);
+		break;
+	}
+
+	kfree(buf);
+	return 0;
+
+err:
+	kfree(buf);
+	return -EFAULT;
+}
+
+static int rt_codec_codec_dump_reg(struct snd_hwdep *hw,
+		struct file *file, unsigned long arg)
+{
+	struct snd_soc_codec *codec = hw->private_data;
+	struct rt_codec_cmd __user *_rt_codec = (struct rt_codec_cmd *)arg;
+	struct rt_codec_cmd rt_codec;
+	int i, *buf, number = codec->driver->reg_cache_size;
+
+	dev_dbg(codec->dev, "enter %s, number = %d\n", __func__, number);
+	if (copy_from_user(&rt_codec, _rt_codec, sizeof(rt_codec)))
+		return -EFAULT;
+
+	buf = kmalloc(sizeof(*buf) * number, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < number/2; i++) {
+		buf[i] = i << 1;
+		buf[i + number / 2] = codec->read(codec, buf[i]);
+	}
+	if (copy_to_user(rt_codec.buf, buf, sizeof(*buf) * i))
+		goto err;
+	rt_codec.number = number;
+	if (copy_to_user(_rt_codec, &rt_codec, sizeof(rt_codec)))
+		goto err;
+	kfree(buf);
+	return 0;
+
+err:
+	kfree(buf);
+	return -EFAULT;
+}
+
+static int rt_codec_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case RT_READ_ALL_CODEC_REG_IOCTL:
+		return rt_codec_codec_dump_reg(hw, file, arg);
+
+	default:
+		return rt_codec_hwdep_ioctl_common(hw, file, cmd, arg);
+	}
+
+	return 0;
+}
+
+int realtek5645_ce_init_hwdep(struct snd_soc_codec *codec)
+{
+	struct snd_hwdep *hw;
+	struct snd_card *card = codec->card->snd_card;
+	int err;
+
+	dev_dbg(codec->dev, "enter %s\n", __func__);
+
+	err = snd_hwdep_new(card, RT_CE_CODEC_HWDEP_NAME, 0, &hw);
+	if (err < 0)
+		return err;
+
+	strcpy(hw->name, RT_CE_CODEC_HWDEP_NAME);
+	hw->private_data = codec;
+	hw->ops.open = rt_codec_hwdep_open;
+	hw->ops.release = rt_codec_hwdep_release;
+	hw->ops.ioctl = rt_codec_hwdep_ioctl;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(realtek5645_ce_init_hwdep);
+#endif
+
+struct rt_codec_ops *rt5645_codec_get_ioctl_ops(void)
+{
+	return &rt_codec_ioctl_ops;
+}
+EXPORT_SYMBOL_GPL(rt5645_codec_get_ioctl_ops);
diff --git a/sound/soc/codecs/rt_codec_ioctl_5645.h b/sound/soc/codecs/rt_codec_ioctl_5645.h
new file mode 100644
index 0000000..08bd71f
--- /dev/null
+++ b/sound/soc/codecs/rt_codec_ioctl_5645.h
@@ -0,0 +1,82 @@
+/*
+ * rt_codec_ioctl.h  --  RT56XX ALSA SoC audio driver IO control
+ *
+ * Copyright 2012 Realtek Microelectronics
+ * Author: Bard <bardliao@realtek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __RT56XX_IOCTL_H__
+#define __RT56XX_IOCTL_H__
+
+#include <sound/hwdep.h>
+#include <linux/ioctl.h>
+
+struct rt_codec_cmd {
+	size_t number;
+	int __user *buf;
+};
+
+struct rt_codec_ops {
+	int (*index_write)(struct snd_soc_codec *codec,
+		unsigned int reg, unsigned int value);
+	unsigned int (*index_read)(struct snd_soc_codec *codec,
+				unsigned int reg);
+	int (*index_update_bits)(struct snd_soc_codec *codec,
+		unsigned int reg, unsigned int mask, unsigned int value);
+	int (*ioctl_common)(struct snd_hwdep *hw, struct file *file,
+			unsigned int cmd, unsigned long arg);
+};
+
+enum {
+	RT_READ_CODEC_REG_IOCTL = _IOR('R', 0x01, struct rt_codec_cmd),
+	RT_WRITE_CODEC_REG_IOCTL = _IOW('R', 0x01, struct rt_codec_cmd),
+	RT_READ_ALL_CODEC_REG_IOCTL = _IOR('R', 0x02, struct rt_codec_cmd),
+	RT_READ_CODEC_INDEX_IOCTL = _IOR('R', 0x03, struct rt_codec_cmd),
+	RT_WRITE_CODEC_INDEX_IOCTL = _IOW('R', 0x03, struct rt_codec_cmd),
+	RT_READ_CODEC_DSP_IOCTL = _IOR('R', 0x04, struct rt_codec_cmd),
+	RT_WRITE_CODEC_DSP_IOCTL = _IOW('R', 0x04, struct rt_codec_cmd),
+	RT_SET_CODEC_HWEQ_IOCTL = _IOW('R', 0x05, struct rt_codec_cmd),
+	RT_GET_CODEC_HWEQ_IOCTL = _IOR('R', 0x05, struct rt_codec_cmd),
+	RT_SET_CODEC_SPK_VOL_IOCTL = _IOW('R', 0x06, struct rt_codec_cmd),
+	RT_GET_CODEC_SPK_VOL_IOCTL = _IOR('R', 0x06, struct rt_codec_cmd),
+	RT_SET_CODEC_MIC_GAIN_IOCTL = _IOW('R', 0x07, struct rt_codec_cmd),
+	RT_GET_CODEC_MIC_GAIN_IOCTL = _IOR('R', 0x07, struct rt_codec_cmd),
+	RT_SET_CODEC_3D_SPK_IOCTL = _IOW('R', 0x08, struct rt_codec_cmd),
+	RT_GET_CODEC_3D_SPK_IOCTL = _IOR('R', 0x08, struct rt_codec_cmd),
+	RT_SET_CODEC_MP3PLUS_IOCTL = _IOW('R', 0x09, struct rt_codec_cmd),
+	RT_GET_CODEC_MP3PLUS_IOCTL = _IOR('R', 0x09, struct rt_codec_cmd),
+	RT_SET_CODEC_3D_HEADPHONE_IOCTL = _IOW('R', 0x0a, struct rt_codec_cmd),
+	RT_GET_CODEC_3D_HEADPHONE_IOCTL = _IOR('R', 0x0a, struct rt_codec_cmd),
+	RT_SET_CODEC_BASS_BACK_IOCTL = _IOW('R', 0x0b, struct rt_codec_cmd),
+	RT_GET_CODEC_BASS_BACK_IOCTL = _IOR('R', 0x0b, struct rt_codec_cmd),
+	RT_SET_CODEC_DIPOLE_SPK_IOCTL = _IOW('R', 0x0c, struct rt_codec_cmd),
+	RT_GET_CODEC_DIPOLE_SPK_IOCTL = _IOR('R', 0x0c, struct rt_codec_cmd),
+	RT_SET_CODEC_DRC_AGC_ENABLE_IOCTL = _IOW('R', 0x0d,
+			struct rt_codec_cmd),
+	RT_GET_CODEC_DRC_AGC_ENABLE_IOCTL = _IOR('R', 0x0d,
+			struct rt_codec_cmd),
+	RT_SET_CODEC_DSP_MODE_IOCTL = _IOW('R', 0x0e, struct rt_codec_cmd),
+	RT_GET_CODEC_DSP_MODE_IOCTL = _IOR('R', 0x0e, struct rt_codec_cmd),
+	RT_SET_CODEC_WNR_ENABLE_IOCTL = _IOW('R', 0x0f, struct rt_codec_cmd),
+	RT_GET_CODEC_WNR_ENABLE_IOCTL = _IOR('R', 0x0f, struct rt_codec_cmd),
+	RT_SET_CODEC_DRC_AGC_PAR_IOCTL = _IOW('R', 0x10, struct rt_codec_cmd),
+	RT_GET_CODEC_DRC_AGC_PAR_IOCTL = _IOR('R', 0x10, struct rt_codec_cmd),
+	RT_SET_CODEC_DIGI_BOOST_GAIN_IOCTL = _IOW('R', 0x11,
+			struct rt_codec_cmd),
+	RT_GET_CODEC_DIGI_BOOST_GAIN_IOCTL = _IOR('R', 0x11,
+			struct rt_codec_cmd),
+	RT_SET_CODEC_NOISE_GATE_IOCTL = _IOW('R', 0x12, struct rt_codec_cmd),
+	RT_GET_CODEC_NOISE_GATE_IOCTL = _IOR('R', 0x12, struct rt_codec_cmd),
+	RT_SET_CODEC_DRC_AGC_COMP_IOCTL = _IOW('R', 0x13, struct rt_codec_cmd),
+	RT_GET_CODEC_DRC_AGC_COMP_IOCTL = _IOR('R', 0x13, struct rt_codec_cmd),
+	RT_GET_CODEC_ID = _IOR('R', 0x30, struct rt_codec_cmd),
+};
+
+int realtek5645_ce_init_hwdep(struct snd_soc_codec *codec);
+struct rt_codec_ops *rt5645_codec_get_ioctl_ops(void);
+
+#endif /* __RT56XX_IOCTL_H__ */
diff --git a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
index 5c2d473..9c35d68 100644
--- a/sound/soc/intel/Kconfig
+++ b/sound/soc/intel/Kconfig
@@ -34,6 +34,7 @@ config SND_SOC_INTEL_CHT_T
 	tristate "SOC Machine Audio driver for Intel(R) CHT-T4 & CHT-T3 device"
 	depends on X86
 	select SND_SOC_RT5672
+	select SND_SOC_RT5645
 	select SND_SOC_TLV320AIC31XX
 	select SND_SST_PLATFORM
 	select SND_SST_MACHINE
diff --git a/sound/soc/intel/board/Makefile b/sound/soc/intel/board/Makefile
index 988e1d3..4105eda 100644
--- a/sound/soc/intel/board/Makefile
+++ b/sound/soc/intel/board/Makefile
@@ -14,4 +14,5 @@ obj-$(CONFIG_SND_SOC_INTEL_ANCHOR8) += snd-byt-cr-dpcm-rt5651.o  byt_cr_board_co
 # Cherrytrail board
 snd-cht-dpcm-rt5672-objs := cht_bl_dpcm_rt5672.o
 snd-cht-cr-aic3100-objs := cht_cr_aic3100.o
-obj-$(CONFIG_SND_SOC_INTEL_CHT_T) += snd-cht-dpcm-rt5672.o snd-cht-cr-aic3100.o
+snd-cht-cr-dpcm-rt5645-objs := cht_cr_dpcm_rt5645.o
+obj-$(CONFIG_SND_SOC_INTEL_CHT_T) += snd-cht-dpcm-rt5672.o snd-cht-cr-dpcm-rt5645.o snd-cht-cr-aic3100.o
diff --git a/sound/soc/intel/board/cht_cr_dpcm_rt5645.c b/sound/soc/intel/board/cht_cr_dpcm_rt5645.c
new file mode 100644
index 0000000..01c1dc0
--- /dev/null
+++ b/sound/soc/intel/board/cht_cr_dpcm_rt5645.c
@@ -0,0 +1,1043 @@
+/*
+ *  cht_rvp_rt5645.c - ASoc DPCM Machine driver
+ *  for Intel CherryTrail MID platform
+ *
+ *  Copyright (C) 2014 Intel Corp
+ *  Author: Mythri P K <mythri.p.k@intel.com>
+ *  This file is modified from byt_bl_rt5642.c for cherrytrail
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/vlv2_plat_clock.h>
+#include <linux/mutex.h>
+#include <linux/dmi.h>
+#include <asm/platform_cht_audio.h>
+#include <asm/intel-mid.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include "../../codecs/rt5645.h"
+
+#define CHT_PLAT_CLK_3_HZ	19200000
+
+#define CHT_INTR_DEBOUNCE               0
+#define CHT_HS_INSERT_DET_DELAY         500
+#define CHT_HS_REMOVE_DET_DELAY         500
+#define CHT_BUTTON_DET_DELAY            100
+#define CHT_HS_DET_POLL_INTRVL          100
+#define CHT_BUTTON_EN_DELAY             1500
+
+#define CHT_HS_DET_RETRY_COUNT          6
+
+struct cht_mc_private {
+	struct snd_soc_jack jack;
+	struct delayed_work hs_insert_work;
+	struct delayed_work hs_remove_work;
+	struct delayed_work hs_button_work;
+	struct mutex jack_mlock;
+	/* To enable button press interrupts after a delay after HS detection.
+	 * This is to avoid spurious button press events during slow
+	 * HS insertion
+	 */
+	struct delayed_work hs_button_en_work;
+	int intr_debounce;
+	int hs_insert_det_delay;
+	int hs_remove_det_delay;
+	int button_det_delay;
+	int button_en_delay;
+	int hs_det_poll_intrvl;
+	int hs_det_retry;
+	bool process_button_events;
+
+};
+
+static int cht_hs_detection(void *);
+
+static struct snd_soc_jack_gpio hs_gpio = {
+		.name			= "cht-codec-int",
+		.report			= SND_JACK_HEADSET |
+					  SND_JACK_HEADPHONE |
+					  SND_JACK_BTN_0,
+		.debounce_time		= CHT_INTR_DEBOUNCE,
+		.jack_status_check	= cht_hs_detection,
+};
+static inline void cht_force_enable_pin(struct snd_soc_codec *codec,
+			 const char *bias_widget, bool enable)
+{
+	pr_debug("%s %s\n", enable ? "enable" : "disable", bias_widget);
+	if (enable)
+		snd_soc_dapm_force_enable_pin(&codec->dapm, bias_widget);
+	else
+		snd_soc_dapm_disable_pin(&codec->dapm, bias_widget);
+}
+
+static inline void cht_set_codec_power(struct snd_soc_codec *codec,
+								int jack_type)
+{
+	const char *board_name;
+	switch (jack_type) {
+	case SND_JACK_HEADSET:
+		board_name = dmi_get_system_info(DMI_BOARD_NAME);
+		pr_debug("Setting the micbias for %s\n", board_name);
+		if (strcmp(board_name, "Cherry Trail FFD") == 0)
+			cht_force_enable_pin(codec, "micbias1", true);
+		else
+			cht_force_enable_pin(codec, "micbias2", true);
+		cht_force_enable_pin(codec, "JD Power", true);
+		cht_force_enable_pin(codec, "Mic Det Power", true);
+		break;
+	case SND_JACK_HEADPHONE:
+		cht_force_enable_pin(codec, "JD Power", true);
+		cht_force_enable_pin(codec, "Mic Det Power", false);
+		cht_force_enable_pin(codec, "micbias2", false);
+		break;
+	case 0:
+		cht_force_enable_pin(codec, "JD Power", false);
+		cht_force_enable_pin(codec, "Mic Det Power", false);
+		cht_force_enable_pin(codec, "micbias2", false);
+		break;
+	default:
+		return;
+	}
+	snd_soc_dapm_sync(&codec->dapm);
+}
+/* Identify the jack type as Headset/Headphone/None */
+static int cht_check_jack_type(struct snd_soc_jack *jack,
+					struct snd_soc_codec *codec)
+{
+	int status, jack_type = 0;
+	/*const char *board_name;*/
+	struct cht_mc_private *ctx = container_of(jack,
+					struct cht_mc_private, jack);
+
+	status = rt5645_check_jd_status(codec);
+	/* jd status low indicates some accessory has been connected */
+	if (!status) {
+		pr_debug("Jack insert intr\n");
+		/* Do not process button events until
+		accessory is detected as headset*/
+		ctx->process_button_events = false;
+		cht_set_codec_power(codec, SND_JACK_HEADSET);
+		jack_type = rt5645_headset_detect(codec, true);
+		if (jack_type == SND_JACK_HEADSET) {
+			ctx->process_button_events = true;
+			/* If headset is detected, enable
+			button interrupts after a delay */
+			schedule_delayed_work(&ctx->hs_button_en_work,
+					msecs_to_jiffies(ctx->button_en_delay));
+		}
+		if (jack_type != SND_JACK_HEADSET)
+			cht_set_codec_power(codec, SND_JACK_HEADPHONE);
+	} else
+		jack_type = 0;
+
+	pr_debug("Jack type detected:%d\n", jack_type);
+
+	return jack_type;
+}
+
+/* Work function invoked by the Jack Infrastructure.
+ * Other delayed works for jack detection/removal/button
+ * press are scheduled from this function
+ */
+static int cht_hs_detection(void *data)
+{
+	int status, jack_type = 0;
+	int ret;
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(jack,
+						struct cht_mc_private, jack);
+
+	mutex_lock(&ctx->jack_mlock);
+	/* Initialize jack status with previous status.
+	 * Delayed work will confirm the event and send updated status later
+	 */
+	jack_type = jack->status;
+	pr_debug("Enter:%s\n", __func__);
+
+	if (!jack->status) {
+		ctx->hs_det_retry = CHT_HS_DET_RETRY_COUNT;
+		ret = schedule_delayed_work(&ctx->hs_insert_work,
+				msecs_to_jiffies(ctx->hs_insert_det_delay));
+		if (!ret)
+			pr_debug("cht_check_hs_insert_status already queued\n");
+		else
+			pr_debug("%s:Check hs insertion  after %d msec\n",
+					__func__, ctx->hs_insert_det_delay);
+
+	} else {
+		/* First check for accessory removal; If not removed,
+		 * check for button events
+		 */
+		status = rt5645_check_jd_status(codec);
+		/* jd status high indicates accessory has been disconnected.
+		 * However, confirm the removal in the delayed work
+		 */
+		if (status) {
+			/* Do not process button events while we make sure
+			 * accessory is disconnected
+			 */
+			ctx->process_button_events = false;
+			ret = schedule_delayed_work(&ctx->hs_remove_work,
+				msecs_to_jiffies(ctx->hs_remove_det_delay));
+			if (!ret)
+				pr_debug("remove work already queued\n");
+			else
+				pr_debug("%s:Check hs removal after %d msec\n",
+					__func__, ctx->hs_remove_det_delay);
+		} else {
+			/* Must be button event.
+			Confirm the event in delayed work*/
+			if (((jack->status & SND_JACK_HEADSET) ==
+						SND_JACK_HEADSET) &&
+					ctx->process_button_events) {
+				ret = schedule_delayed_work(
+					&ctx->hs_button_work,
+					msecs_to_jiffies(
+						ctx->button_det_delay));
+				if (!ret)
+					pr_debug("button_work already queued\n");
+				else
+					pr_debug("%s:check BP/BR after %d msec\n",
+					__func__, ctx->button_det_delay);
+			}
+		}
+	}
+
+	mutex_unlock(&ctx->jack_mlock);
+	pr_debug("Exit:%s\n", __func__);
+	return jack_type;
+}
+/* Checks jack insertion and identifies the jack type.
+ * Retries the detection if necessary
+ */
+static void cht_check_hs_insert_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work,
+				struct cht_mc_private, hs_insert_work.work);
+	int jack_type = 0;
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s\n", __func__);
+
+	jack_type = cht_check_jack_type(jack, codec);
+
+	/* Report jack immediately only if jack is headset.
+	 * If headphone or no jack was detected, dont report it
+	 * until the last HS det try.
+	 * This is to avoid reporting any temporary jack removal or
+	 * accessory change (eg, HP to HS) during the detection tries.
+	 * This provides additional debounce that will help in the case
+	 * of slow insertion.
+	 * This also avoids the pause in audio due to accessory change
+	 * from HP to HS
+	 */
+	if (ctx->hs_det_retry <= 0) {
+		/* end of retries; report the status */
+		snd_soc_jack_report(jack, jack_type, gpio->report);
+	} else {
+		/* Schedule another detection try if headphone or no jack
+		 * is detected.During slow insertion of headset, first a
+		 * headphone may be detected.
+		 * Hence retry until headset is detected
+		 */
+		if (jack_type == SND_JACK_HEADSET) {
+			ctx->hs_det_retry = 0;
+			/* HS detected, no more retries needed */
+			snd_soc_jack_report(jack, jack_type, gpio->report);
+		} else {
+			ctx->hs_det_retry--;
+			schedule_delayed_work(&ctx->hs_insert_work,
+				msecs_to_jiffies(ctx->hs_det_poll_intrvl));
+			pr_debug("%s:re-try hs detection after %d msec\n",
+					__func__, ctx->hs_det_poll_intrvl);
+		}
+	}
+
+	pr_debug("Exit:%s\n", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+/* Checks jack removal. */
+static void cht_check_hs_remove_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work,
+			struct cht_mc_private, hs_remove_work.work);
+	int status = 0, jack_type = 0;
+
+	/* Cancel any pending insertion detection.
+	 * There could be pending insertion detection in the
+	 * case of very slow insertion or insertion and immediate removal.
+	 */
+	cancel_delayed_work_sync(&ctx->hs_insert_work);
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s\n", __func__);
+	/* Initialize jack_type with previous status.
+	 * If the event was an invalid one, we return the previous state
+	 */
+	jack_type = jack->status;
+
+	if (jack->status) {
+		/* jack is in connected state; look for removal event */
+		status = rt5645_check_jd_status(codec);
+		if (status) {
+			/* jd status high implies accessory disconnected */
+			pr_debug("Jack remove event\n");
+			ctx->process_button_events = false;
+			cancel_delayed_work_sync(&ctx->hs_button_en_work);
+			status = rt5645_headset_detect(codec, false);
+			jack_type = 0;
+			cht_set_codec_power(codec, 0);
+
+		} else if (((jack->status & SND_JACK_HEADSET) ==
+				SND_JACK_HEADSET)
+				&& !ctx->process_button_events) {
+			/* Jack is still connected. We may come here if there
+			 * was a spurious jack removal event. No state change
+			 * is done until removal is confirmed by the
+			 * check_jd_status above.i.e. jack status remains
+			 * Headset or headphone.But as soon as the interrupt
+			 * thread(cht_hs_detection) detected a jack removal,
+			 * button processing gets disabled. Hence re-enable
+			 * button processing in the case of headset.
+			 */
+			pr_debug("spurious Jack remove event for headset\n");
+			pr_debug("re-enable button events\n");
+			ctx->process_button_events = true;
+		}
+	}
+	snd_soc_jack_report(jack, jack_type, gpio->report);
+	pr_debug("Exit:%s\n", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+/* Check for button press/release */
+static void cht_check_hs_button_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work,
+			struct cht_mc_private, hs_button_work.work);
+	int status = 0, jack_type = 0;
+	int ret;
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s\n", __func__);
+	/* Initialize jack_type with previous status.
+	 * If the event was an invalid one, we return the preious state
+	 */
+	jack_type = jack->status;
+
+	if (((jack->status & SND_JACK_HEADSET) == SND_JACK_HEADSET)
+			&& ctx->process_button_events) {
+
+		status = rt5645_check_jd_status(codec);
+		if (!status) {
+			/* confirm jack is connected */
+			status = rt5645_button_detect(codec);
+			if (jack->status & SND_JACK_BTN_0) {
+				/* if button was previosly in pressed state*/
+				if (!status) {
+					pr_debug("BR event received\n");
+					jack_type = SND_JACK_HEADSET;
+				}
+			} else {
+				/* If button was previously in released state */
+				if (status) {
+					pr_debug("BP event received\n");
+					jack_type = SND_JACK_HEADSET |
+								SND_JACK_BTN_0;
+				}
+			}
+		}
+		/* There could be button interrupts during jack removal.
+		 * There can be situations where a button interrupt is generated
+		 * first but no jack removal interrupt is generated.
+		 * This can happen on platforrms where jack detection is
+		 * aligned to Headset Left pin instead of the ground  pin and
+		 * codec multiplexes (ORs) the jack and button interrupts.
+		 * So schedule a jack removal detection work
+		 */
+		ret = schedule_delayed_work(&ctx->hs_remove_work,
+				msecs_to_jiffies(ctx->hs_remove_det_delay));
+		if (!ret)
+			pr_debug("cht_check_hs_remove_status already queued\n");
+		else
+			pr_debug("%s:Check hs removal after %d msec\n",
+					__func__, ctx->hs_remove_det_delay);
+
+	}
+	snd_soc_jack_report(jack, jack_type, gpio->report);
+	pr_debug("Exit:%s\n", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+
+/* Delayed work for enabling the overcurrent detection circuit
+ * and interrupt for generating button events */
+static void cht_enable_hs_button_events(struct work_struct *work)
+{
+	/* TODO move the enable button event here */
+}
+
+static inline struct snd_soc_codec *cht_get_codec(struct snd_soc_card *card)
+{
+	bool found = false;
+	struct snd_soc_codec *codec;
+
+	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
+		if (!strstr(codec->name, "i2c-10EC5645:00")) {
+			pr_debug("codec was %s\n", codec->name);
+			continue;
+		} else {
+			found = true;
+			break;
+		}
+	}
+	if (!found) {
+		pr_err("%s: cant find codec\n", __func__);
+		return NULL;
+	}
+	return codec;
+}
+
+#define VLV2_PLAT_CLK_AUDIO	3
+#define PLAT_CLK_FORCE_ON	1
+#define PLAT_CLK_FORCE_OFF	2
+static int platform_clock_control(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *k, int  event)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct snd_soc_codec *codec;
+
+	codec = cht_get_codec(card);
+	if (!codec) {
+		pr_err("Codec not found; Unable to set platform clock\n");
+		return -EIO;
+	}
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO,
+				PLAT_CLK_FORCE_ON);
+		pr_debug("%s Platform clk turned ON\n", __func__);
+		snd_soc_codec_set_sysclk(codec, RT5645_SCLK_S_PLL1,
+				0, CHT_PLAT_CLK_3_HZ, SND_SOC_CLOCK_IN);
+	} else {
+		/* Set codec clock source to internal clock before
+		 * turning off the platform clock. Codec needs clock
+		 * for Jack detection and button press
+		 */
+		snd_soc_codec_set_sysclk(codec, RT5645_SCLK_S_RCCLK,
+				0, 0, SND_SOC_CLOCK_IN);
+		vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO,
+				PLAT_CLK_FORCE_OFF);
+		pr_debug("%s Platform clk turned OFF\n", __func__);
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget cht_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_SUPPLY("Platform Clock", SND_SOC_NOPM, 0, 0,
+			platform_clock_control, SND_SOC_DAPM_PRE_PMU|
+			SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_route cht_audio_map[] = {
+	{"IN1P", NULL, "Headset Mic"},
+	{"IN1N", NULL, "Headset Mic"},
+	{"micbias1", NULL, "Int Mic"},
+	{"DMIC L1", NULL, "Int Mic"},
+	{"DMIC R1", NULL, "Int Mic"},
+	{"Headphone", NULL, "HPOL"},
+	{"Headphone", NULL, "HPOR"},
+	{"Ext Spk", NULL, "SPOL"},
+	{"Ext Spk", NULL, "SPOR"},
+	{ "AIF1 Playback", NULL, "ssp2 Tx"},
+	{ "ssp2 Tx", NULL, "codec_out0"},
+	{ "ssp2 Tx", NULL, "codec_out1"},
+	{ "codec_in0", NULL, "ssp2 Rx" },
+	{ "codec_in1", NULL, "ssp2 Rx" },
+	{ "ssp2 Rx", NULL, "AIF1 Capture"},
+	{ "ssp0 Tx", NULL, "modem_out"},
+	{ "modem_in", NULL, "ssp0 Rx" },
+
+	{ "ssp1 Tx", NULL, "bt_fm_out"},
+	{ "bt_fm_in", NULL, "ssp1 Rx" },
+
+	{"AIF1 Playback", NULL, "Platform Clock"},
+	{"AIF1 Capture", NULL, "Platform Clock"},
+};
+
+static const struct snd_kcontrol_new cht_mc_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Int Mic"),
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
+
+static int cht_aif1_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	unsigned int fmt;
+	int ret;
+
+	pr_debug("Enter:%s\n", __func__);
+
+	/* proceed only if dai is valid */
+	if (strncmp(codec_dai->name, "rt5645-aif1", 11))
+		return 0;
+#if 0
+	/* TDM 4 slot 24 bit set the Rx and Tx bitmask to
+	 * 4 active slots as 0xF
+	 */
+	ret = snd_soc_dai_set_tdm_slot(codec_dai, 0xF, 0xF, 4,
+			SNDRV_PCM_FORMAT_GSM);
+	if (ret < 0) {
+		pr_err("can't set codec TDM slot %d\n", ret);
+		return ret;
+	}
+
+	/* TDM slave Mode */
+		fmt =   SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+				| SND_SOC_DAIFMT_CBS_CFS;
+#endif
+	/* I2S Slave Mode`*/
+	fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS;
+
+	/* Set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_err("can't set codec DAI configuration %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, RT5645_PLL1_S_MCLK,
+				  CHT_PLAT_CLK_3_HZ, params_rate(params) * 512);
+	if (ret < 0) {
+		pr_err("can't set codec pll: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_PLL1,
+				     params_rate(params) * 512,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		pr_err("can't set codec sysclk: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int cht_compr_set_params(struct snd_compr_stream *cstream)
+{
+	return 0;
+}
+
+static const struct snd_soc_pcm_stream cht_dai_params = {
+	.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	.rate_min = 48000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+};
+
+static int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	pr_debug("Invoked %s for dailink %s\n", __func__, rtd->dai_link->name);
+
+	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+
+	/* set SSP2 to 24-bit */
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				    SNDRV_PCM_FORMAT_S24_LE);
+	return 0;
+}
+
+static int cht_set_bias_level(struct snd_soc_card *card,
+				struct snd_soc_dapm_context *dapm,
+				enum snd_soc_bias_level level)
+{
+	int ret = 0;
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+	case SND_SOC_BIAS_STANDBY:
+	case SND_SOC_BIAS_OFF:
+		card->dapm.bias_level = level;
+		pr_debug("%s: card(%s)->bias_level %u\n", __func__,
+				card->name, card->dapm.bias_level);
+		break;
+	default:
+		pr_err("%s: Invalid bias level=%d\n", __func__, level);
+		ret =  -EINVAL;
+	}
+
+	return ret;
+}
+
+static int cht_audio_init(struct snd_soc_pcm_runtime *runtime)
+{
+	int ret = 0;
+	struct snd_soc_codec *codec;
+	struct snd_soc_card *card = runtime->card;
+	struct cht_mc_private *ctx = snd_soc_card_get_drvdata(runtime->card);
+	int codec_gpio;
+	int pol, val;
+	struct gpio_desc *desc;
+
+	pr_debug("Enter:%s\n", __func__);
+	codec = cht_get_codec(card);
+	if (!codec) {
+		pr_err("Codec not found; %s: failed\n", __func__);
+		return -EIO;
+	}
+	/* Set codec bias level */
+	cht_set_bias_level(card, &card->dapm, SND_SOC_BIAS_OFF);
+	card->dapm.idle_bias_off = true;
+
+	desc = devm_gpiod_get_index(codec->dev, NULL, 0);
+	if (!IS_ERR(desc)) {
+		codec_gpio = desc_to_gpio(desc);
+		devm_gpiod_put(codec->dev, desc);
+
+		ret = gpiod_export(desc, true);
+		if (ret)
+			pr_debug("%s: Unable to export GPIO%d (JD/BP)! Returned %d.\n",
+					__func__, codec_gpio, ret);
+		pol = gpiod_is_active_low(desc);
+		val = gpiod_get_value(desc);
+		pr_info("%s: GPIOs - JD/BP-int: %d (pol = %d, val = %d)\n",
+				__func__, codec_gpio, pol, val);
+
+	} else {
+		codec_gpio = -1;
+		pr_err("%s: GPIOs - JD/BP-int: Not present!\n", __func__);
+	}
+
+
+	hs_gpio.gpio = codec_gpio;
+
+	ctx->intr_debounce = CHT_INTR_DEBOUNCE;
+	ctx->hs_insert_det_delay = CHT_HS_INSERT_DET_DELAY;
+	ctx->hs_remove_det_delay = CHT_HS_REMOVE_DET_DELAY;
+	ctx->button_det_delay = CHT_BUTTON_DET_DELAY;
+	ctx->hs_det_poll_intrvl = CHT_HS_DET_POLL_INTRVL;
+	ctx->hs_det_retry = CHT_HS_DET_RETRY_COUNT;
+	ctx->button_en_delay = CHT_BUTTON_EN_DELAY;
+	ctx->process_button_events = false;
+
+	INIT_DELAYED_WORK(&ctx->hs_insert_work, cht_check_hs_insert_status);
+	INIT_DELAYED_WORK(&ctx->hs_remove_work, cht_check_hs_remove_status);
+	INIT_DELAYED_WORK(&ctx->hs_button_work, cht_check_hs_button_status);
+	INIT_DELAYED_WORK(&ctx->hs_button_en_work, cht_enable_hs_button_events);
+
+	mutex_init(&ctx->jack_mlock);
+
+	ret = snd_soc_jack_new(codec, "Intel MID Audio Jack",
+			       SND_JACK_HEADSET | SND_JACK_HEADPHONE |
+			       SND_JACK_BTN_0, &ctx->jack);
+	if (ret) {
+		pr_err("jack creation failed\n");
+		return ret;
+	}
+	snd_jack_set_key(ctx->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+	ret = snd_soc_jack_add_gpios(&ctx->jack, 1, &hs_gpio);
+	if (ret) {
+		pr_err("adding jack GPIO failed\n");
+		return ret;
+	}
+
+	/* Keep the voice call paths active during
+	 * suspend. Mark the end points ignore_suspend
+	 */
+	/*TODO: CHECK this */
+	snd_soc_dapm_ignore_suspend(&codec->dapm, "HPOL");
+	snd_soc_dapm_ignore_suspend(&codec->dapm, "HPOR");
+
+	snd_soc_dapm_ignore_suspend(&codec->dapm, "SPOL");
+	snd_soc_dapm_ignore_suspend(&codec->dapm, "SPOR");
+
+	snd_soc_dapm_enable_pin(&card->dapm, "Headset Mic");
+	snd_soc_dapm_enable_pin(&card->dapm, "Headphone");
+	snd_soc_dapm_enable_pin(&card->dapm, "Ext Spk");
+	snd_soc_dapm_enable_pin(&card->dapm, "Int Mic");
+
+	snd_soc_dapm_sync(&card->dapm);
+	pr_debug("Exit:%s\n", __func__);
+	return ret;
+}
+
+static unsigned int rates_8000_16000[] = {
+	8000,
+	16000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_8000_16000 = {
+	.count = ARRAY_SIZE(rates_8000_16000),
+	.list  = rates_8000_16000,
+};
+
+static unsigned int rates_48000[] = {
+	48000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_48000 = {
+	.count = ARRAY_SIZE(rates_48000),
+	.list  = rates_48000,
+};
+
+static int cht_aif1_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_48000);
+}
+
+static struct snd_soc_ops cht_aif1_ops = {
+	.startup = cht_aif1_startup,
+};
+
+static int cht_8k_16k_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_8000_16000);
+}
+
+static struct snd_soc_ops cht_8k_16k_ops = {
+	.startup = cht_8k_16k_startup,
+	.hw_params = cht_aif1_hw_params,
+};
+static struct snd_soc_ops cht_be_ssp2_ops = {
+	.hw_params = cht_aif1_hw_params,
+};
+
+static struct snd_soc_compr_ops cht_compr_ops = {
+	.set_params = cht_compr_set_params,
+};
+
+static struct snd_soc_dai_link cht_dailink[] = {
+	[CHT_DPCM_AUDIO] = {
+		.name = "Cherrytrail Audio Port",
+		.stream_name = "Cherrytrail Audio",
+		.cpu_dai_name = "Headset-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "sst-platform",
+		.init = cht_audio_init,
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &cht_aif1_ops,
+	},
+	[CHT_DPCM_DB] = {
+		.name = "Cherrytrail DB Audio Port",
+		.stream_name = "Deep Buffer Audio",
+		.cpu_dai_name = "Deepbuffer-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &cht_aif1_ops,
+		.dpcm_playback = 1,
+	},
+	[CHT_DPCM_COMPR] = {
+		.name = "Cherrytrail Compressed Port",
+		.stream_name = "Cherrytrail Compress",
+		.cpu_dai_name = "Compress-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.compr_ops = &cht_compr_ops,
+		.dpcm_playback = 1,
+	},
+	[CHT_DPCM_VOIP] = {
+		.name = "Cherrytrail VOIP Port",
+		.stream_name = "Cherrytrail Voip",
+		.cpu_dai_name = "Voip-cpu-dai",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.init = NULL,
+		.ignore_suspend = 1,
+		.ops = &cht_8k_16k_ops,
+		.dynamic = 1,
+	},
+	[CHT_DPCM_LL] = {
+		.name = "Cherrytrail LL Audio Port",
+		.stream_name = "Low Latency Audio",
+		.cpu_dai_name = "Lowlatency-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &cht_aif1_ops,
+	},
+	[CHT_DPCM_PROBE] = {
+		.name = "Cherrytrail Probe Port",
+		.stream_name = "Cherrytrail Probe",
+		.cpu_dai_name = "Probe-cpu-dai",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.playback_count = 8,
+		.capture_count = 8,
+	},
+	/* CODEC<->CODEC link */
+	{
+		.name = "Cherrytrail Codec-Loop Port",
+		.stream_name = "Cherrytrail Codec-Loop",
+		.cpu_dai_name = "ssp2-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "rt5645-aif1",
+		.codec_name = "i2c-10EC5645:00", /* use 3100*/
+		.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+			| SND_SOC_DAIFMT_CBS_CFS,
+		.params = &cht_dai_params,
+		.dsp_loopback = true,
+	},
+	{
+		.name = "Cherrytrail Modem-Loop Port",
+		.stream_name = "Cherrytrail Modem-Loop",
+		.cpu_dai_name = "ssp0-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.params = &cht_dai_params,
+		.dsp_loopback = true,
+	},
+	{
+		.name = "Cherrytrail BTFM-Loop Port",
+		.stream_name = "Cherrytrail BTFM-Loop",
+		.cpu_dai_name = "ssp1-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.params = &cht_dai_params,
+		.dsp_loopback = true,
+	},
+	/* Back ends */
+	{
+		.name = "SSP2-Codec",
+		.be_id = 1,
+		.cpu_dai_name = "ssp2-port",
+		.platform_name = "sst-platform",
+		.no_pcm = 1,
+		.codec_dai_name = "rt5645-aif1",
+		.codec_name = "i2c-10EC5645:00",
+		.be_hw_params_fixup = cht_codec_fixup,
+		.ignore_suspend = 1,
+		.ops = &cht_be_ssp2_ops,
+	},
+	{
+		.name = "SSP1-BTFM",
+		.be_id = 2,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "SSP0-Modem",
+		.be_id = 3,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int snd_cht_rt5645_prepare(struct device *dev)
+{
+	pr_debug("In %s device name\n", __func__);
+	return snd_soc_suspend(dev);
+}
+
+static void snd_cht_rt5645_complete(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO, PLAT_CLK_FORCE_OFF);
+	snd_soc_resume(dev);
+}
+
+static int snd_cht_rt5645_poweroff(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	return snd_soc_poweroff(dev);
+}
+#else
+#define snd_cht_prepare NULL
+#define snd_cht_complete NULL
+#define snd_cht_poweroff NULL
+#endif
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_cht = {
+	.name = "cherrytrailaud",
+	.dai_link = cht_dailink,
+	.num_links = ARRAY_SIZE(cht_dailink),
+	.set_bias_level = cht_set_bias_level,
+	.dapm_widgets = cht_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(cht_dapm_widgets),
+	.dapm_routes = cht_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(cht_audio_map),
+	.controls = cht_mc_controls,
+	.num_controls = ARRAY_SIZE(cht_mc_controls),
+};
+
+static int snd_cht_mc_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	struct cht_mc_private *drv;
+
+	pr_debug("Entry %s\n", __func__);
+
+	/* Audio Platform clock is on by default. The machine driver requests
+	 * this clock to be turned ON and OFF on playing any stream. But
+	 * until any stream is played the clock remains ON. Hence request the
+	 * clock to be turned OFF initially.
+	 */
+	vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO, PLAT_CLK_FORCE_OFF);
+
+	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);
+	if (!drv) {
+		pr_err("%s allocation failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	/* register the soc card */
+	snd_soc_card_cht.dev = &pdev->dev;
+	snd_soc_card_set_drvdata(&snd_soc_card_cht, drv);
+	ret_val = snd_soc_register_card(&snd_soc_card_cht);
+	if (ret_val) {
+		pr_err("snd_soc_register_card failed %d\n", ret_val);
+		return ret_val;
+	}
+	platform_set_drvdata(pdev, &snd_soc_card_cht);
+	pr_info("%s successful\n", __func__);
+	return ret_val;
+}
+
+static void snd_cht_unregister_jack(struct cht_mc_private *ctx)
+{
+	/* Set process button events to false so that the button
+	   delayed work will not be scheduled.*/
+	ctx->process_button_events = false;
+	cancel_delayed_work_sync(&ctx->hs_insert_work);
+	cancel_delayed_work_sync(&ctx->hs_button_en_work);
+	cancel_delayed_work_sync(&ctx->hs_button_work);
+	cancel_delayed_work_sync(&ctx->hs_remove_work);
+	snd_soc_jack_free_gpios(&ctx->jack, 1, &hs_gpio);
+}
+
+static int snd_cht_mc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct cht_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+	snd_cht_unregister_jack(drv);
+	snd_soc_card_set_drvdata(soc_card, NULL);
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static void snd_cht_mc_shutdown(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct cht_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+	snd_cht_unregister_jack(drv);
+}
+
+const struct dev_pm_ops snd_cht_mc_rt5645_pm_ops = {
+	.prepare = snd_cht_rt5645_prepare,
+	.complete = snd_cht_rt5645_complete,
+	.poweroff = snd_cht_rt5645_poweroff,
+};
+
+static struct platform_driver snd_cht_mc_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "cht_rt5645",
+		.pm = &snd_cht_mc_rt5645_pm_ops,
+	},
+	.probe = snd_cht_mc_probe,
+	.remove = snd_cht_mc_remove,
+	.shutdown = snd_cht_mc_shutdown,
+};
+
+static int __init snd_cht_driver_init(void)
+{
+	pr_info("Cherrytrail Machine Driver cht_rt5645 registerd\n");
+	return platform_driver_register(&snd_cht_mc_driver);
+}
+late_initcall(snd_cht_driver_init);
+
+static void __exit snd_cht_driver_exit(void)
+{
+	pr_debug("In %s\n", __func__);
+	platform_driver_unregister(&snd_cht_mc_driver);
+}
+module_exit(snd_cht_driver_exit);
+
+MODULE_DESCRIPTION("ASoC Intel(R) Cherrytrail Machine driver");
+MODULE_AUTHOR("Mythri P K <mythri.p.k@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cht_rt5645");
diff --git a/sound/soc/intel/sst/sst.c b/sound/soc/intel/sst/sst.c
index f4acab1..480f3d7 100644
--- a/sound/soc/intel/sst/sst.c
+++ b/sound/soc/intel/sst/sst.c
@@ -621,12 +621,16 @@ static struct platform_device cht_t_mach_dev = {
 	.num_resources  = 0,
 };
 
+static struct platform_device cht_cr_mrd_mach_dev = {
+	.name           = "cht_rt5645",
+	.id             = -1,
+	.num_resources  = 0,
+};
 static struct platform_device cht_cr_mach_dev = {
 	.name           = "cht_aic31xx",
 	.id             = -1,
 	.num_resources  = 0,
 };
-
 void sst_init_lib_mem_mgr(struct intel_sst_drv *ctx)
 {
 	struct sst_mem_mgr *mgr = &ctx->lib_mem_mgr;
@@ -672,10 +676,21 @@ int sst_request_firmware_async(struct intel_sst_drv *ctx)
 				"fw_sst_%04x.bin", ctx->pci_id);
 
 		board_name = dmi_get_system_info(DMI_BOARD_NAME);
-		if (strcmp(board_name, "Cherry Trail CR") == 0) {
+		if (strcmp(board_name, "Cherry Trail MRD") == 0) {
+			pr_info("Registering machine device %s\n",
+						cht_cr_mrd_mach_dev.name);
+			ret = platform_device_register(
+							&cht_cr_mrd_mach_dev);
+			if (ret) {
+				pr_err("failed to register machine device %s\n",
+						cht_cr_mrd_mach_dev.name);
+				return -ENOENT;
+			}
+		} else if (strcmp(board_name, "Cherry Trail CR") == 0) {
 			pr_info("Registering machine device %s\n",
 						cht_cr_mach_dev.name);
-			ret = platform_device_register(&cht_cr_mach_dev);
+			ret = platform_device_register(
+						&cht_cr_mach_dev);
 			if (ret) {
 				pr_err("failed to register machine device %s\n",
 						cht_cr_mach_dev.name);
diff --git a/sound/soc/intel/sst/sst_platform.c b/sound/soc/intel/sst/sst_platform.c
index cee8a2b..9bb584d 100644
--- a/sound/soc/intel/sst/sst_platform.c
+++ b/sound/soc/intel/sst/sst_platform.c
@@ -354,7 +354,8 @@ static void set_cht_platform_config(void)
 	sst_platform_pdata.dfw_enable = 1;
 	memcpy(sst_platform_pdata.ssp_config, sst_ssp_configs_mrfld, sizeof(sst_ssp_configs_mrfld));
 	board_name = dmi_get_system_info(DMI_BOARD_NAME);
-	if (strcmp(board_name, "Cherry Trail CR") == 0) {
+	if ((strcmp(board_name, "Cherry Trail CR") == 0) ||
+			(strcmp(board_name, "Cherry Trail MRD") == 0)) {
 		pr_debug("Load CHT CR SSP Config %s\n", board_name);
 		memcpy(sst_platform_pdata.ssp_config, sst_ssp_configs_cht_cr,
 					sizeof(sst_ssp_configs_cht_cr));
-- 
1.9.1

