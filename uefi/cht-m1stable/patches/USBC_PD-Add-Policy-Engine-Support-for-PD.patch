From b535c29390b18c7118d18da17ff369ff3de4d658 Mon Sep 17 00:00:00 2001
From: Albin B <albin.bala.krishnan@intel.com>
Date: Fri, 29 May 2015 11:18:15 +0530
Subject: [PATCH] [USBC_PD]: Add Policy Engine Support for PD

The Policy Engine is to parse the data/control messages received from
the protocol layer and handle it based on the pd policy for power
delivery. PE is the layer between the protocol and device policy
manger which will handle or forward the packet to the respective
port(source/sink/display) policy engine. Also PE is responsible for
executing different policies based on the port/power role negotiated.

Change-Id: Ib2940bdf8eca2fdad1700b42bdabf274fec0b9db
Tracked-On: https://jira01.devtools.intel.com/browse/IMINAN-37850
Signed-off-by: Albin B <albin.bala.krishnan@intel.com>
---
 drivers/usb/typec/pd/Makefile        |   1 +
 drivers/usb/typec/pd/devpolicy_mgr.c |  11 +-
 drivers/usb/typec/pd/policy_engine.c | 867 +++++++++++++++++++++++++++++++++++
 drivers/usb/typec/pd/policy_engine.h | 545 ++++++++++++++++++++++
 drivers/usb/typec/pd/protocol.c      |  53 ++-
 drivers/usb/typec/pd/protocol.h      |   2 +
 6 files changed, 1473 insertions(+), 6 deletions(-)
 create mode 100644 drivers/usb/typec/pd/policy_engine.c
 create mode 100644 drivers/usb/typec/pd/policy_engine.h

diff --git a/drivers/usb/typec/pd/Makefile b/drivers/usb/typec/pd/Makefile
index 0b4ce89f88f5..d38f8b1a9df3 100644
--- a/drivers/usb/typec/pd/Makefile
+++ b/drivers/usb/typec/pd/Makefile
@@ -4,6 +4,7 @@
 
 pd_policy-y	:= devpolicy_mgr.o
 pd_policy-y	+= message.o protocol.o
+pd_policy-y	+= policy_engine.o
 
 obj-$(CONFIG_USBC_PD_POLICY)		+= pd_policy.o
 obj-$(CONFIG_USBC_SYSTEM_POLICY)	+= system_policy.o
diff --git a/drivers/usb/typec/pd/devpolicy_mgr.c b/drivers/usb/typec/pd/devpolicy_mgr.c
index e47e5090eb78..891da537c0e7 100644
--- a/drivers/usb/typec/pd/devpolicy_mgr.c
+++ b/drivers/usb/typec/pd/devpolicy_mgr.c
@@ -33,7 +33,7 @@
 #include <linux/extcon.h>
 #include <linux/usb_typec_phy.h>
 #include "devpolicy_mgr.h"
-#include "protocol.h"
+#include "policy_engine.h"
 
 static struct power_cap spcaps[] = {
 	{
@@ -541,8 +541,16 @@ struct devpolicy_mgr *dpm_register_syspolicy(struct typec_phy *phy,
 		goto error2;
 	}
 
+	ret = policy_engine_bind_dpm(dpm);
+	if (ret < 0) {
+		pr_err("DPM: failed in binding policy engine\n");
+		goto error3;
+	}
+
 	return dpm;
 
+error3:
+	protocol_unbind_dpm(dpm->phy);
 error2:
 	extcon_unregister_interest(&dpm->provider_cable_nb);
 error1:
@@ -556,6 +564,7 @@ EXPORT_SYMBOL(dpm_register_syspolicy);
 void dpm_unregister_syspolicy(struct devpolicy_mgr *dpm)
 {
 	if (dpm) {
+		policy_engine_unbind_dpm(dpm);
 		protocol_unbind_dpm(dpm->phy);
 		extcon_unregister_interest(&dpm->provider_cable_nb);
 		extcon_unregister_interest(&dpm->consumer_cable_nb);
diff --git a/drivers/usb/typec/pd/policy_engine.c b/drivers/usb/typec/pd/policy_engine.c
new file mode 100644
index 000000000000..4d2b7d0ab440
--- /dev/null
+++ b/drivers/usb/typec/pd/policy_engine.c
@@ -0,0 +1,867 @@
+/*
+ * policy_engine.c: Intel USB Power Delivery Policy Engine Driver
+ *
+ * Copyright (C) 2015 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Seee the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Albin B <albin.bala.krishnan@intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/notifier.h>
+#include <linux/err.h>
+#include <linux/power_supply.h>
+#include <linux/delay.h>
+#include <linux/usb_typec_phy.h>
+#include <linux/random.h>
+#include "policy_engine.h"
+
+static LIST_HEAD(pe_list);
+static DEFINE_SPINLOCK(pe_lock);
+
+static inline
+struct policy *find_active_policy(struct list_head *head)
+{
+	struct policy *p = NULL;
+
+	list_for_each_entry(p, head, list) {
+		if (p && p->status == POLICY_STATUS_STARTED)
+			return p;
+	}
+
+	return NULL;
+}
+
+static int pe_handle_data_msg(struct policy_engine *pe, struct pd_packet *pkt)
+{
+	struct policy *p;
+	int ret = 0;
+	enum pe_event event;
+
+	p = find_active_policy(&pe->policy_list);
+	if (!p) {
+		pr_err("PE: No Active policy!\n");
+		return -EINVAL;
+	}
+
+	switch (PD_MSG_TYPE(&pkt->header)) {
+	case PD_DATA_MSG_SRC_CAP:
+		pr_debug("PE: Data msg received - PD_DATA_MSG_SRC_CAP\n");
+		event = PE_EVT_RCVD_SRC_CAP;
+		memcpy(&pe->pkt, pkt, sizeof(struct pd_packet));
+
+		if (p && p->rcv_pkt) {
+			p->rcv_pkt(p, pkt, event);
+		} else {
+			pr_err("PE: Unable to find send pkt\n");
+			ret = -ENODEV;
+		}
+		break;
+	case PD_DATA_MSG_REQUEST:
+		pr_debug("PE: Data msg received - PD_DATA_MSG_REQUEST\n");
+		break;
+	case PD_DATA_MSG_BIST:
+		pr_debug("PE: Data msg received - PD_DATA_MSG_BIST\n");
+		break;
+	case PD_DATA_MSG_SINK_CAP:
+		pr_debug("PE: Data msg received - PD_DATA_MSG_SINK_CAP\n");
+		break;
+	case PD_DATA_MSG_VENDOR_DEF:
+		pr_debug("PE: Data msg received - PD_DATA_MSG_VENDOR_DEF\n");
+		break;
+	case PD_DATA_MSG_RESERVED_0:
+	case PD_DATA_MSG_RESERVED_5:
+	case PD_DATA_MSG_RESERVED_6:
+	case PD_DATA_MSG_RESERVED_7:
+	case PD_DATA_MSG_RESERVED_8:
+	case PD_DATA_MSG_RESERVED_9:
+	case PD_DATA_MSG_RESERVED_10:
+	case PD_DATA_MSG_RESERVED_11:
+	case PD_DATA_MSG_RESERVED_12:
+	case PD_DATA_MSG_RESERVED_13:
+	case PD_DATA_MSG_RESERVED_14:
+	default:
+		pr_debug("PE: Data msg received - Unknown\n");
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int pe_fwdpkt_snkport(struct policy_engine *pe, struct pd_packet *pkt,
+					 enum pe_event evt)
+{
+	struct policy *p;
+	int ret = 0;
+
+	p = find_active_policy(&pe->policy_list);
+	if (!p) {
+		pr_err("PE: No Active policy!\n");
+		return -EINVAL;
+	}
+
+	memcpy(&pe->pkt, pkt, sizeof(struct pd_packet));
+	if (p && p->rcv_pkt) {
+		p->rcv_pkt(p, pkt, evt);
+	} else {
+		pr_err("PE: Unable to find send pkt\n");
+		ret = -ENODEV;
+	}
+
+	pe->prev_evt = evt;
+	return ret;
+}
+
+static int pe_handle_ctrl_msg(struct policy_engine *pe, struct pd_packet *pkt)
+{
+	int ret = 0;
+	enum pe_event event = PD_CTRL_MSG_RESERVED_0;
+
+	switch (pkt->header.msg_type) {
+	case PD_CTRL_MSG_GOODCRC:
+		/* Assume that the previous message sent successfully.
+		 * modify the internal state if requried */
+		pr_debug("PE Ctrl msg received - PD_CTRL_MSG_GOODCRC\n");
+		event = PE_EVT_SEND_GOODCRC;
+		break;
+	case PD_CTRL_MSG_GOTOMIN:
+		/* send by source only event, Start PSTransitionTimer Reduce
+		 * current min and send Good  CRC*/
+		event = PE_EVT_RCVD_GOTOMIN;
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_GOTOMIN\n");
+		ret = pe_fwdpkt_snkport(pe, pkt, event);
+		if (ret < 0) {
+			pr_err("PE: Error in handling pkt\n");
+			goto error;
+		}
+		break;
+	case PD_CTRL_MSG_ACCEPT:
+		/* sent by recipient of the Soft Reset Message, PR_Swap,
+		 * DR_Swap, VCONN_Swap */
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_ACCEPT\n");
+		event = PE_EVT_RCVD_ACCEPT;
+		if (pe->prev_evt == PE_EVT_SEND_REQUEST) {
+			ret = pe_fwdpkt_snkport(pe, pkt, event);
+			if (ret < 0) {
+				pr_err("PE: Error in handling pkt\n");
+				goto error;
+			}
+		}
+		break;
+	case PD_CTRL_MSG_REJECT:
+		/* sent by recipient of the PR_Swap, DR_Swap, VCONN_Swap
+		 * without DR cap rcving Get_Sync_Cap in src, Get_Source_Cap
+		 * in snk */
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_REJECT\n");
+		event = PE_EVT_RCVD_REJECT;
+		if (pe->prev_evt == PE_EVT_SEND_REQUEST ||
+			pe->prev_evt == PE_EVT_SEND_GET_SRC_CAP) {
+			ret = pe_fwdpkt_snkport(pe, pkt, event);
+			if (ret < 0) {
+				pr_err("PE: Error in handling pkt\n");
+				goto error;
+			}
+		}
+		break;
+	case PD_CTRL_MSG_PING:
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_PING\n");
+		event = PE_EVT_RCVD_PING;
+		if (pe->prev_evt == PE_EVT_RCVD_WAIT) {
+			ret = pe_fwdpkt_snkport(pe, pkt, event);
+			if (ret < 0) {
+				pr_err("PE: Error in handling pkt\n");
+				goto error;
+			}
+		}
+		break;
+	case PD_CTRL_MSG_PS_RDY:
+		/* Response for GotoMin: Stop PSTransitionTimer Start
+		 * SinkActivityTimer (optional) */
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_PS_RDY\n");
+		event = PE_EVT_RCVD_PS_RDY;
+		if (pe->prev_evt == PE_EVT_RCVD_ACCEPT ||
+			pe->prev_evt == PE_EVT_RCVD_WAIT) {
+			ret = pe_fwdpkt_snkport(pe, pkt, event);
+			if (ret < 0) {
+				pr_err("PE: Error in handling pkt\n");
+				goto error;
+			}
+		}
+		break;
+	case PD_CTRL_MSG_GET_SRC_CAP:
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_GET_SRC_CAP\n");
+		break;
+	case PD_CTRL_MSG_GET_SINK_CAP:
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_GET_SINK_CAP\n");
+		event = PE_EVT_RCVD_GET_SINK_CAP;
+		ret = pe_fwdpkt_snkport(pe, pkt, event);
+		if (ret < 0) {
+			pr_err("PE: Error in handling pkt\n");
+			goto error;
+		}
+		break;
+	case PD_CTRL_MSG_DR_SWAP:
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_DR_SWAP\n");
+		break;
+	case PD_CTRL_MSG_PR_SWAP:
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_PR_SWAP\n");
+		break;
+	case PD_CTRL_MSG_VCONN_SWAP:
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_VCONN_SWAP\n");
+		break;
+	case PD_CTRL_MSG_WAIT:
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_WAIT\n");
+		event = PE_EVT_RCVD_WAIT;
+		if (pe->prev_evt == PE_EVT_SEND_REQUEST) {
+			ret = pe_fwdpkt_snkport(pe, pkt, event);
+			if (ret < 0) {
+				pr_err("PE: Error in handling pkt\n");
+				goto error;
+			}
+		}
+		break;
+	case PD_CTRL_MSG_SOFT_RESET:
+		/* Reset state dependent behavior */
+		pr_debug("PE: Ctrl msg received - PD_CTRL_MSG_SOFT_RESET\n");
+		break;
+	case PD_CTRL_MSG_RESERVED_0:
+	default:
+		pr_debug("PE: Ctrl msg received (%d) - Unknown\n",
+				pkt->header.msg_type);
+		goto event_unknown;
+		break;
+	}
+
+	pe->prev_evt = event;
+
+event_unknown:
+error:
+	return ret;
+}
+
+static void pe_dump_header(struct pd_pkt_header *header)
+{
+#ifdef DBG
+	if (!header) {
+		pr_err("PE: No Header information available...\n");
+		return;
+	}
+	pr_info("========== POLICY ENGINE: HEADER INFO ==========\n");
+	pr_info("PE: Message Type - 0x%x\n", header->msg_type);
+	pr_info("PE: Reserved B4 - 0x%x\n", header->rsvd_a);
+	pr_info("PE: Port Data Role - 0x%x\n", header->data_role);
+	pr_info("PE: Specification Revision - 0x%x\n", header->rev_id);
+	pr_info("PE: Port Power Role - 0x%x\n", header->pwr_role);
+	pr_info("PE: Message ID - 0x%x\n", header->msg_id);
+	pr_info("PE: Number of Data Objects - 0x%x\n", header->num_data_obj);
+	pr_info("PE: Reserved B15 - 0x%x\n", header->rsvd_b);
+	pr_info("=============================================");
+#endif /* DBG */
+
+	return;
+}
+
+static void pe_dump_data_msg(struct pd_packet *pkt)
+{
+#ifdef DBG
+	int num_data_objs = PD_MSG_NUM_DATA_OBJS(&pkt->header);
+	unsigned int data_buf[num_data_objs];
+	int i;
+
+	memset(data_buf, 0, num_data_objs);
+	memcpy(data_buf, &pkt->data_obj, PD_MSG_LEN(&pkt->header));
+
+	for (i = 0; i < num_data_objs; i++) {
+		pr_info("PE: Data Message - data[%d]: 0x%08x\n",
+					i+1, data_buf[i]);
+	}
+#endif /* DBG */
+	return;
+}
+
+static int pe_process_rcv_msg(struct policy_engine *pe,
+					struct pd_packet *pkt)
+{
+	int ret;
+
+	if (pkt == NULL) {
+		pr_err("PE: %s No data Found!\n", __func__);
+		return -ENODATA;
+	}
+
+	pe_dump_header(&pkt->header);
+
+	if (IS_DATA_MSG(&pkt->header)) {
+		pe_dump_data_msg(pkt);
+
+		if (IS_DATA_VDM(&pkt->header)) {
+			/* TODO: forward the vdm packet to the dsppe to handle
+			 * it out */
+		}
+
+		ret = pe_handle_data_msg(pe, pkt);
+		if (ret < 0) {
+			pr_err("PE: handling data msg failed.\n");
+			goto fail;
+		}
+
+	} else if (IS_CTRL_MSG(&pkt->header)) {
+		pe_dump_data_msg(pkt);
+
+		/* Control Message Received */
+		ret = pe_handle_ctrl_msg(pe, pkt);
+		if (ret < 0) {
+			pr_err("PE: handling ctrl msg failed.\n");
+			goto fail;
+		}
+	} else {
+		/* Invalid data which doesn't occur */
+		pe_dump_header(&pkt->header);
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	return 0;
+fail:
+	return ret;
+}
+
+static void pe_proto_worker(struct work_struct *work)
+{
+	struct policy_engine *pe =
+			container_of(work, struct policy_engine, proto_work);
+	struct pe_proto_evt *evt, *tmp;
+	unsigned long flags;
+	int ret;
+	struct list_head new_list;
+
+	if (list_empty(&pe->proto_queue))
+		return;
+
+	spin_lock_irqsave(&pe->proto_queue_lock, flags);
+	list_replace_init(&pe->proto_queue, &new_list);
+	spin_unlock_irqrestore(&pe->proto_queue_lock, flags);
+
+	list_for_each_entry_safe(evt, tmp, &new_list, node) {
+		mutex_lock(&pe->protowk_lock);
+		/* do parsing the message packet received from protocol */
+		ret = pe_process_rcv_msg(pe, &evt->pkt);
+		if (ret)
+			pr_err("PE: Error in parsing protocol message\n");
+
+		mutex_unlock(&pe->protowk_lock);
+		kfree(evt);
+	}
+}
+
+static int pe_process_msg(struct policy_engine *pe, struct pd_packet *pkt)
+{
+	struct pe_proto_evt *evt;
+
+	if (!pkt)
+		return -EINVAL;
+
+	evt = kzalloc(sizeof(*evt), GFP_ATOMIC);
+	if (!evt) {
+		pr_err("PE: failed to allocate memory for Protocol event\n");
+		return -ENOMEM;
+	}
+	memcpy(&evt->pkt, pkt, sizeof(struct pd_packet));
+	INIT_LIST_HEAD(&evt->node);
+	list_add_tail(&evt->node, &pe->proto_queue);
+	queue_work(system_nrt_wq, &pe->proto_work);
+
+	return 0;
+}
+
+static int pe_fwdcmd_snkport(struct policy_engine *pe, enum pe_event evt)
+{
+	struct policy *p;
+	int ret = 0;
+
+	p = find_active_policy(&pe->policy_list);
+	if (!p) {
+		pr_err("PE: No Active policy!\n");
+		return -EINVAL;
+	}
+
+	if (p && p->rcv_cmd) {
+		p->rcv_cmd(p, evt);
+	} else {
+		pr_err("PE: Unable to find send cmd\n");
+		ret = -ENODEV;
+	}
+
+	pe->prev_evt = evt;
+	return ret;
+}
+
+static int pe_process_cmd(struct policy_engine *pe, int cmd)
+{
+	int ret = 0;
+	enum pe_event event;
+
+	switch (cmd) {
+	case PD_CMD_HARD_RESET:
+		event  = PE_EVT_RCVD_HARD_RESET;
+		ret = pe_fwdcmd_snkport(pe, event);
+		if (ret < 0)
+			pr_err("PE: Error in handling cmd\n");
+		break;
+	case PD_CMD_HARD_RESET_COMPLETE:
+		event = PE_EVT_RCVD_HARD_RESET_COMPLETE;
+		ret = pe_fwdcmd_snkport(pe, event);
+		if (ret < 0)
+			pr_err("PE: Error in handling cmd\n");
+		break;
+	default:
+		pr_debug("PE: %s - cmd %d\n", __func__, cmd);
+		break;
+	}
+
+	return ret;
+}
+
+static void pe_dpm_worker(struct work_struct *work)
+{
+	struct policy_engine *pe =
+		container_of(work, struct policy_engine, dpm_work);
+	struct pe_dpm_evt *evt, *tmp;
+	unsigned long flags;
+	struct list_head new_list;
+
+	if (list_empty(&pe->dpm_queue))
+		return;
+
+	spin_lock_irqsave(&pe->dpm_queue_lock, flags);
+	list_replace_init(&pe->dpm_queue, &new_list);
+	spin_unlock_irqrestore(&pe->dpm_queue_lock, flags);
+
+	list_for_each_entry_safe(evt, tmp, &new_list, node) {
+		mutex_lock(&pe->dpmwk_lock);
+		if (evt != NULL) {
+			/* FIXME: Send msg to protocol to advertise the the
+			 * source cap if evt = DEVMGR_EVENT_ADVERTISE_SRC_CAP */
+		}
+		mutex_unlock(&pe->dpmwk_lock);
+		kfree(evt);
+	}
+}
+
+static int pe_dpm_notification(struct notifier_block *nb,
+				unsigned long event, void *param)
+{
+	struct policy_engine *pe =
+		container_of(nb, struct policy_engine, dpm_nb);
+	struct pe_dpm_evt *evt;
+
+	if (!param || event != DEVMGR_EVENT_DFP_CONNECTED)
+		return NOTIFY_DONE;
+
+	evt = kzalloc(sizeof(*evt), GFP_ATOMIC);
+	if (!evt) {
+		pr_err("PE: failed to allocate memory for dpm event\n");
+		return NOTIFY_DONE;
+	}
+
+	memcpy(&evt->caps, param, sizeof(struct pe_dpm_evt));
+	INIT_LIST_HEAD(&evt->node);
+	list_add_tail(&evt->node, &pe->dpm_queue);
+	queue_work(system_nrt_wq, &pe->dpm_work);
+
+	return NOTIFY_OK;
+}
+
+static inline int pe_register_dpm_notifications(struct policy_engine *pe)
+{
+	int retval;
+
+	INIT_LIST_HEAD(&pe->dpm_queue);
+	INIT_WORK(&pe->dpm_work, pe_dpm_worker);
+	mutex_init(&pe->dpmwk_lock);
+	spin_lock_init(&pe->dpm_queue_lock);
+
+	pe->dpm_nb.notifier_call = pe_dpm_notification;
+	retval = devpolicy_mgr_reg_notifier(&pe->dpm_nb);
+	if (retval < 0) {
+		pr_err("PE: failed to register dpm notifier\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int pe_get_snkpwr_cap(struct policy_engine *pe,
+					struct power_cap *cap)
+{
+	if (pe && pe->dpm)
+		return devpolicy_get_snkpwr_cap(pe->dpm, cap);
+
+	return -ENODEV;
+}
+
+static int pe_get_snkpwr_caps(struct policy_engine *pe,
+					struct power_caps *caps)
+{
+	if (pe && pe->dpm)
+		return devpolicy_get_snkpwr_caps(pe->dpm, caps);
+
+	return -ENODEV;
+}
+
+static int pe_get_max_snkpwr_cap(struct policy_engine *pe,
+					struct power_cap *cap)
+{
+	if (pe && pe->dpm)
+		return devpolicy_get_max_snkpwr_cap(pe->dpm, cap);
+
+	return -ENODEV;
+}
+
+static enum data_role pe_get_data_role(struct policy_engine *pe)
+{
+	if (pe && pe->dpm)
+		return devpolicy_get_data_role(pe->dpm);
+
+	return DATA_ROLE_NONE;
+}
+
+static enum pwr_role pe_get_power_role(struct policy_engine *pe)
+{
+	if (pe && pe->dpm)
+		return devpolicy_get_power_role(pe->dpm);
+
+	return POWER_ROLE_NONE;
+}
+
+static void  pe_set_data_role(struct policy_engine *pe, enum data_role role)
+{
+	if (pe && pe->dpm)
+		devpolicy_set_data_role(pe->dpm, role);
+}
+
+static void pe_set_power_role(struct policy_engine *pe, enum pwr_role role)
+{
+	if (pe && pe->dpm)
+		devpolicy_set_power_role(pe->dpm, role);
+}
+
+static int pe_set_charger_mode(struct policy_engine *pe, enum charger_mode mode)
+{
+	if (pe && pe->dpm)
+		return devpolicy_set_charger_mode(pe->dpm, mode);
+
+	return -ENODEV;
+}
+
+static int pe_update_charger_ilim(struct policy_engine *pe, int ilim)
+{
+	if (pe && pe->dpm)
+		return devpolicy_update_current_limit(pe->dpm, ilim);
+
+	return -ENODEV;
+}
+
+static int pe_get_min_snk_current(struct policy_engine *pe, int *ma)
+{
+	if (pe && pe->dpm)
+		return devpolicy_get_min_snk_current(pe->dpm, ma);
+
+	return -ENODEV;
+}
+
+static enum cable_state pe_get_vbus_state(struct policy_engine *pe)
+{
+	if (pe && pe->dpm)
+		return devpolicy_get_consumer_state(pe->dpm);
+
+	return -ENODEV;
+}
+
+static bool pe_get_pd_state(struct policy_engine *pe)
+{
+	return pe->is_pd_connected;
+}
+
+static int pe_set_pd_state(struct policy_engine *pe, bool state)
+{
+	mutex_lock(&pe->pe_lock);
+	pe->is_pd_connected = state;
+	mutex_unlock(&pe->pe_lock);
+	return 0;
+}
+
+static int pe_send_packet(struct policy_engine *pe, void *data, int len,
+				u8 msg_type, enum pe_event evt)
+{
+	int ret = 0;
+
+	switch (evt) {
+	case PE_EVT_SEND_REQUEST:
+	case PE_EVT_SEND_SNK_CAP:
+	case PE_EVT_SEND_GET_SRC_CAP:
+		if (!pe_get_pd_state(pe)) {
+			ret = -EINVAL;
+			goto error;
+		}
+		break;
+	case PE_EVT_SEND_HARD_RESET:
+	case PE_EVT_SEND_PROTOCOL_RESET:
+		break;
+	default:
+		goto unknown;
+	}
+
+	/* Send the pd_packet to protocol directly to request
+	 * sink power cap */
+	if (pe && pe->prot && pe->prot->policy_fwd_pkt)
+		pe->prot->policy_fwd_pkt(pe->prot, msg_type, data, len);
+
+unknown:
+	pe->prev_evt = evt;
+error:
+	return ret;
+}
+
+static struct policy *__pe_find_policy(struct list_head *list,
+						enum policy_type type)
+{
+	struct policy  *p = NULL;
+
+	list_for_each_entry(p, list, list) {
+		if (p && p->type != type)
+			continue;
+		return p;
+	}
+
+	return ERR_PTR(-ENODEV);
+}
+
+static void pe_update_state(struct policy_engine *pe, int policy_type,
+				int state)
+{
+	if (pe) {
+		pe->policy_in_use = policy_type;
+		pe->state = state;
+	}
+}
+
+static void pe_init_policy(struct work_struct *work)
+{
+	struct policy_engine *pe = container_of(work, struct policy_engine,
+							policy_init_work);
+
+	struct pd_policy *supported_policy = pe->supported_policies;
+	int i;
+
+	for (i = 0; i < supported_policy->num_policies; i++) {
+		switch (supported_policy->policies[i]) {
+		case POLICY_TYPE_SINK:
+			break;
+		/* TODO: Should be handled POLICY_TYPE_SINK and
+		 * POLICY_TYPE_DISPLAY policies as well */
+		default:
+			/* invalid, dont add it to policy */
+			pr_err("PE: Unknown policy type %d\n",
+				supported_policy->policies[i]);
+			break;
+		}
+	}
+
+	return;
+}
+
+static void pe_policy_work(struct work_struct *work)
+{
+	struct policy_engine *pe = container_of(work, struct policy_engine,
+						policy_work);
+	struct policy *p;
+
+	p = __pe_find_policy(&pe->policy_list, pe->policy_in_use);
+
+	if (!IS_ERR_OR_NULL(p)) {
+		if (pe->state == POLICY_STATE_ONLINE)
+			p->start(p);
+		else if (pe->state == POLICY_STATE_OFFLINE)
+			p->stop(p);
+	}
+}
+
+static int sink_port_event(struct notifier_block *nb, unsigned long event,
+				void *param)
+{
+	struct policy_engine *pe = container_of(nb, struct policy_engine,
+						sink_nb);
+	struct extcon_dev *edev = (struct extcon_dev *)param;
+	int cable_state;
+
+	cable_state = extcon_get_cable_state(edev, "USB_TYPEC_UFP");
+	pe->policy_in_use = POLICY_TYPE_SINK;
+	pe->state = cable_state ? POLICY_STATE_ONLINE : POLICY_STATE_OFFLINE;
+	schedule_work(&pe->policy_work);
+	return 0;
+}
+
+static int source_port_event(struct notifier_block *nb, unsigned long event,
+				void *param)
+{
+	struct policy_engine *pe = container_of(nb, struct policy_engine,
+						source_nb);
+	struct extcon_dev *edev = (struct extcon_dev *)param;
+	int cable_state;
+
+	cable_state = extcon_get_cable_state(edev, "USB_TYPEC_DFP");
+	pe->policy_in_use = POLICY_TYPE_SOURCE;
+	pe->state = cable_state ? POLICY_STATE_ONLINE : POLICY_STATE_OFFLINE;
+	schedule_work(&pe->policy_work);
+	return  0;
+}
+
+static struct pe_operations ops = {
+	.get_snkpwr_cap = pe_get_snkpwr_cap,
+	.get_snkpwr_caps = pe_get_snkpwr_caps,
+	.get_max_snkpwr_cap = pe_get_max_snkpwr_cap,
+	.get_data_role = pe_get_data_role,
+	.get_power_role = pe_get_power_role,
+	.set_data_role = pe_set_data_role,
+	.set_power_role = pe_set_power_role,
+	.set_charger_mode = pe_set_charger_mode,
+	.update_charger_ilim = pe_update_charger_ilim,
+	.get_min_snk_current = pe_get_min_snk_current,
+	.send_packet = pe_send_packet,
+	.get_vbus_state = pe_get_vbus_state,
+	.get_pd_state = pe_get_pd_state,
+	.set_pd_state = pe_set_pd_state,
+	.process_msg = pe_process_msg,
+	.process_cmd = pe_process_cmd,
+	.update_policy_engine = pe_update_state,
+};
+
+int policy_engine_bind_dpm(struct devpolicy_mgr *dpm)
+{
+	int retval;
+	struct policy_engine *pe;
+
+	if (!dpm)
+		return -EINVAL;
+
+	pe = devm_kzalloc(dpm->phy->dev, sizeof(struct policy_engine),
+				GFP_KERNEL);
+	if (!pe)
+		return -ENOMEM;
+
+	pe->ops = &ops;
+	pe->dpm = dpm;
+	pe->supported_policies = dpm->policy;
+	retval = pe_register_dpm_notifications(pe);
+	if (retval) {
+		pr_err("PE: failed to register dpm policy notifier\n");
+		retval = -EINVAL;
+		goto error0;
+	}
+	INIT_LIST_HEAD(&pe->list);
+
+	/* worker init for protocol message handling */
+	INIT_LIST_HEAD(&pe->proto_queue);
+	INIT_WORK(&pe->proto_work, pe_proto_worker);
+	spin_lock_init(&pe->proto_queue_lock);
+
+	mutex_init(&pe->protowk_lock);
+	retval = protocol_bind_pe(pe);
+	if (retval) {
+		pr_err("PE: failed to bind pe to protocol\n");
+		retval = -EINVAL;
+		goto error1;
+	}
+
+	pe->sink_nb.notifier_call = sink_port_event;
+	pe->source_nb.notifier_call = source_port_event;
+
+	retval = extcon_register_interest(&pe->sink_cable_nb,
+						NULL, "USB_TYPEC_UFP",
+						&pe->sink_nb);
+	if (retval < 0)
+		goto error2;
+
+	retval = extcon_register_interest(&pe->source_cable_nb,
+						NULL, "USB_TYPEC_DFP",
+						&pe->source_nb);
+	if (retval < 0)
+		goto error3;
+
+
+	INIT_WORK(&pe->policy_init_work, pe_init_policy);
+	INIT_WORK(&pe->policy_work, pe_policy_work);
+	mutex_init(&pe->pe_lock);
+	INIT_LIST_HEAD(&pe->policy_list);
+	list_add_tail(&pe->list, &pe_list);
+
+	schedule_work(&pe->policy_init_work);
+
+	return 0;
+
+error3:
+	extcon_unregister_interest(&pe->sink_cable_nb);
+error2:
+	protocol_unbind_pe(pe);
+error1:
+	devpolicy_mgr_unreg_notifier(&pe->dpm_nb);
+error0:
+	kfree(pe);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(policy_engine_bind_dpm);
+
+static void remove_pe(struct policy_engine *pe)
+{
+	if (!pe)
+		return;
+
+	extcon_unregister_interest(&pe->source_cable_nb);
+	extcon_unregister_interest(&pe->sink_cable_nb);
+	protocol_unbind_pe(pe);
+	devpolicy_mgr_unreg_notifier(&pe->dpm_nb);
+	kfree(pe);
+}
+
+void policy_engine_unbind_dpm(struct devpolicy_mgr *dpm)
+{
+	struct policy_engine *pe, *temp;
+
+	if (list_empty(&pe_list))
+		return;
+
+	spin_lock(&pe_lock);
+	list_for_each_entry_safe(pe, temp, &pe_list, list) {
+		if (pe->dpm == dpm) {
+			list_del(&pe->list);
+			remove_pe(pe);
+			break;
+		}
+	}
+	spin_unlock(&pe_lock);
+}
+EXPORT_SYMBOL_GPL(policy_engine_unbind_dpm);
+
+MODULE_AUTHOR("Albin B <albin.bala.krishnan@intel.com>");
+MODULE_DESCRIPTION("PD Policy Engine Core");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/usb/typec/pd/policy_engine.h b/drivers/usb/typec/pd/policy_engine.h
new file mode 100644
index 000000000000..973ef0c282ef
--- /dev/null
+++ b/drivers/usb/typec/pd/policy_engine.h
@@ -0,0 +1,545 @@
+#ifndef __POLICY_ENGINE_H__
+#define __POLICY_ENGINE_H__
+
+#include "message.h"
+#include "devpolicy_mgr.h"
+#include "protocol.h"
+
+enum pe_event {
+
+	/* Control Messages (0 - 13) */
+	PE_EVT_SEND_NONE,
+	PE_EVT_SEND_GOODCRC,
+	PE_EVT_SEND_GOTOMIN,
+	PE_EVT_SEND_ACCEPT,
+	PE_EVT_SEND_REJECT,
+	PE_EVT_SEND_PING,
+	PE_EVT_SEND_PS_RDY,
+	PE_EVT_SEND_GET_SRC_CAP,
+	PE_EVT_SEND_GET_SINK_CAP,
+	PE_EVT_SEND_DR_SWAP,
+	PE_EVT_SEND_PR_SWAP,
+	PE_EVT_SEND_VCONN_SWAP,
+	PE_EVT_SEND_WAIT,
+	PE_EVT_SEND_SOFT_RESET,
+
+	/* Data Messages (14 - 18) */
+	PE_EVT_SEND_SRC_CAP,
+	PE_EVT_SEND_REQUEST,
+	PE_EVT_SEND_BIST,
+	PE_EVT_SEND_SNK_CAP,
+	PE_EVT_SEND_VDM,
+
+	/* Control Messages (19 - 32) */
+	PE_EVT_RCVD_NONE,
+	PE_EVT_RCVD_GOODCRC,
+	PE_EVT_RCVD_GOTOMIN,
+	PE_EVT_RCVD_ACCEPT,
+	PE_EVT_RCVD_REJECT,
+	PE_EVT_RCVD_PING,
+	PE_EVT_RCVD_PS_RDY,
+	PE_EVT_RCVD_GET_SRC_CAP,
+	PE_EVT_RCVD_GET_SINK_CAP,
+	PE_EVT_RCVD_DR_SWAP,
+	PE_EVT_RCVD_PR_SWAP,
+	PE_EVT_RCVD_VCONN_SWAP,
+	PE_EVT_RCVD_WAIT,
+	PE_EVT_RCVD_SOFT_RESET,
+
+	/* Data Messages (33 - 37) */
+	PE_EVT_RCVD_SRC_CAP,
+	PE_EVT_RCVD_REQUEST,
+	PE_EVT_RCVD_BIST,
+	PE_EVT_RCVD_SNK_CAP,
+	PE_EVT_RCVD_VDM,
+
+	/* Other Messages (38 - 41) */
+	PE_EVT_SEND_HARD_RESET,
+	PE_EVT_SEND_PROTOCOL_RESET,
+	PE_EVT_RCVD_HARD_RESET,
+	PE_EVT_RCVD_HARD_RESET_COMPLETE,
+
+};
+
+enum pe_states {
+
+	PE_STATE_STARTUP,
+
+	/* Source Port (1 - 12 ) */
+	PE_SRC_STARTUP,
+	PE_SRC_DISCOVERY,
+	PE_SRC_SEND_CAPABILITIES,
+	PE_SRC_NEGOTIATE_CAPABILITY,
+	PE_SRC_TRANSITION_SUPPLY,
+	PE_SRC_READY,
+	PE_SRC_DISABLED,
+	PE_SRC_CAPABILITY_RESPONSE,
+	PE_SRC_HARD_RESET,
+	PE_SRC_TRANSITION_TO_DEFAULT,
+	PE_SRC_GIVE_SOURCE_CAP,
+	PE_SRC_GET_SINK_CAP,
+
+	/* Sink Port (13 - 23) */
+	PE_SNK_STARTUP,
+	PE_SNK_DISCOVERY,
+	PE_SNK_WAIT_FOR_CAPABILITIES,
+	PE_SNK_EVALUATE_CAPABILITY,
+	PE_SNK_SELECT_CAPABILITY,
+	PE_SNK_TRANSITION_SINK,
+	PE_SNK_READY,
+	PE_SNK_HARD_RESET,
+	PE_SNK_TRANSITION_TO_DEFAULT,
+	PE_SNK_GIVE_SINK_CAP,
+	PE_SNK_GET_SOURCE_CAP,
+
+	/* Source Port Soft Reset (24, 25) */
+	PE_SRC_SEND_SOFT_RESET,
+	PE_SRC_SOFT_RESET,
+
+	/* Sink Port Soft Reset (26, 27) */
+	PE_SNK_SEND_SOFT_RESET,
+	PE_SNK_SOFT_RESET,
+
+	/* Source Port Ping (28)*/
+	PE_SRC_PING,
+
+	/* Type-A/B Dual-Role (initially Source Port) Ping (29) */
+	PE_PRS_SRC_SNK_PING,
+
+	/* Type-A/B Dual-Role (initially Sink Port) Ping (30) */
+	PE_PRS_SNK_SRC_PING,
+
+	/* Type-A/B Hard Reset of P/C in Sink Role (31, 32) */
+	PE_PC_SNK_HARD_RESET,
+	PE_PC_SNK_SWAP_RECOVERY,
+
+	/* Type-A/B Hard Reset of C/P in Source Role (33, 34) */
+	PE_CP_SRC_HARD_RESET,
+	PE_CP_SRC_TRANSITION_TO_OFF,
+
+	/* Type-A/B C/P Dead Battery/Power Loss (35 - 41) */
+	PE_DB_CP_CHECK_FOR_VBUS,
+	PE_DB_CP_POWER_VBUS_DB,
+	PE_DB_CP_WAIT_FOR_BIT_STREAM,
+	PE_DB_CP_POWER_VBUS_5V,
+	PE_DB_CP_WAIT_BIT_STREAM_STOP,
+	PE_DB_CP_UNPOWER_VBUS,
+	PE_DB_CP_PS_DISCHARGE,
+
+	/* Type-A/B P/C Dead Battery/Power Loss (42 - 46) */
+	PE_DB_PC_UNPOWERED,
+	PE_DB_PC_CHECK_POWER,
+	PE_DB_PC_SEND_BIT_STREAM,
+	PE_DB_PC_WAIT_TO_DETECT,
+	PE_DB_PC_WAIT_TO_START,
+
+	/* Type-C DFP to UFP Data Role Swap (47 - 51) */
+	PE_DRS_DFP_UFP_EVALUATE_DR_SWAP,
+	PE_DRS_DFP_UFP_ACCEPT_DR_SWAP,
+	PE_DRS_DFP_UFP_CHANGE_TO_UFP,
+	PE_DRS_DFP_UFP_SEND_DR_SWAP,
+	PE_DRS_DFP_UFP_REJECT_DR_SWAP,
+
+	/* Type-C UFP to DFP Data Role Swap (52 - 56) */
+	PE_DRS_UFP_DFP_EVALUATE_DR_SWAP,
+	PE_DRS_UFP_DFP_ACCEPT_DR_SWAP,
+	PE_DRS_UFP_DFP_CHANGE_TO_DFP,
+	PE_DRS_UFP_DFP_SEND_DR_SWAP,
+	PE_DRS_UFP_DFP_REJECT_DR_SWAP,
+
+	/* Source to Sink Power Role Swap (57 - 63) */
+	PE_PRS_SRC_SNK_EVALUATE_PR_SWAP,
+	PE_PRS_SRC_SNK_ACCEPT_PR_SWAP,
+	PE_PRS_SRC_SNK_TRANSITION_TO_OFF,
+	PE_PRS_SRC_SNK_ASSERT_RD,
+	PE_PRS_SRC_SNK_SOURCE_OFF,
+	PE_PRS_SRC_SNK_SEND_PR_SWAP,
+	PE_PRS_SRC_SNK_REJECT_PR_SWAP,
+
+	/* Sink to Source Power Role Swap (64 - 70) */
+	PE_PRS_SNK_SRC_EVALUATE_PR_SWAP,
+	PE_PRS_SNK_SRC_ACCEPT_PR_SWAP,
+	PE_PRS_SNK_SRC_TRANSITION_TO_OFF,
+	PE_PRS_SNK_SRC_ASSERT_RP,
+	PE_PRS_SNK_SRC_SOURCE_ON,
+	PE_PRS_SNK_SRC_SEND_PR_SWAP,
+	PE_PRS_SNK_SRC_REJECT_PR_SWAP,
+
+	/* Dual-Role Source Port Get Source Capabilities (71) */
+	PE_DR_SRC_GET_SOURCE_CAP,
+
+	/* Dual-Role Source Port Give Sink Capabilities (72) */
+	PE_DR_SRC_GIVE_SINK_CAP,
+
+	/* Dual-Role Sink Port Get Sink Capabilities (73) */
+	PE_DR_SNK_GET_SINK_CAP,
+
+	/* Dual-Role Sink Port Give Source Capabilities (74) */
+	PE_DR_SNK_GIVE_SOURCE_CAP,
+
+	/* Type-C DFP VCONN Swap (75 - 79) */
+	PE_VCS_DFP_SEND_SWAP,
+	PE_VCS_DFP_WAIT_FOR_UFP_VCONN,
+	PE_VCS_DFP_TURN_OFF_VCONN,
+	PE_VCS_DFP_TURN_ON_VCONN,
+	PE_VCS_DFP_SEND_PS_Rdy,
+
+	/* Type-C UFP VCONN Swap (80 - 86) */
+	PE_VCS_UFP_EVALUATE_SWAP,
+	PE_VCS_UFP_ACCEPT_SWAP,
+	PE_VCS_UFP_REJECT_SWAP,
+	PE_VCS_UFP_WAIT_FOR_DFP_VCONN,
+	PE_VCS_UFP_TURN_OFF_VCONN,
+	PE_VCS_UFP_TURN_ON_VCONN,
+	PE_VCS_UFP_SEND_PS_RDY,
+
+	/* UFP VDM (87 - 97) */
+	PE_UFP_VDM_GET_IDENTITY,
+	PE_UFP_VDM_SEND_IDENTITY,
+	PE_UFP_VDM_GET_SVIDS,
+	PE_UFP_VDM_SEND_SVIDS,
+	PE_UFP_VDM_GET_MODES,
+	PE_UFP_VDM_SEND_MODES,
+	PE_UFP_VDM_EVALUATE_MODE_ENTRY,
+	PE_UFP_VDM_MODE_ENTRY_ACK,
+	PE_UFP_VDM_MODE_ENTRY_NAK,
+	PE_UFP_VDM_MODE_EXIT,
+	PE_UFP_VDM_MODE_EXIT_ACK,
+
+	/* UFP VDM Attention (98) */
+	PE_UFP_VDM_ATTENTION_REQUEST,
+
+	/* DFP VDM Discover Identity (99 - 101) */
+	PE_DFP_VDM_IDENTITY_REQUEST,
+	PE_DFP_VDM_IDENTITY_ACKED,
+	PE_DFP_VDM_IDENTITY_NAKED,
+
+	/* DFP VDM Discover SVIDs (102 - 104) */
+	PE_DFP_VDM_SVIDS_REQUEST,
+	PE_DFP_VDM_SVIDS_ACKED,
+	PE_DFP_VDM_SVIDS_NAKED,
+
+	/* DFP VDM Discover Modes (105 - 107) */
+	PE_DFP_VDM_MODES_REQUEST,
+	PE_DFP_VDM_MODES_ACKED,
+	PE_DFP_VDM_MODES_NAKED,
+
+	/* DFP VDM Mode Entry (108 - 110) */
+	PE_DFP_VDM_MODES_ENTRY_REQUEST,
+	PE_DFP_VDM_MODES_ENTRY_ACKED,
+	PE_DFP_VDM_MODES_ENTRY_NAKED,
+
+	/* DFP VDM Mode Exit (111, 112) */
+	PE_DFP_VDM_MODE_EXIT_REQUEST,
+	PE_DFP_VDM_MODE_EXIT_ACKED,
+
+	/* Source Startup VDM Discover Identity (113 - 115) */
+	PE_SRC_VDM_IDENTITY_REQUEST,
+	PE_SRC_VDM_IDENTITY_ACKED,
+	PE_SRC_VDM_IDENTITY_NAKED,
+
+	/* DFP VDM Attention (116) */
+	PE_DFP_VDM_ATTENTION_REQUEST,
+
+	/* USB to USB Cable (117 - 128) */
+	PE_CBL_READY,
+	PE_CBL_GET_IDENTITY,
+	PE_CBL_SEND_IDENTITY,
+	PE_CBL_GEG_SVIDS,
+	PE_CBL_SEND_SVIDS,
+	PE_CBL_GEG_MODES,
+	PE_CBL_SEND_MODES,
+	PE_CBL_EVALUATE_MODE_ENTRY,
+	PE_CBL_MODE_ENTRY_ACK,
+	PE_CBL_MODE_ENTRY_NAK,
+	PE_CBL_MODE_EXUIT,
+	PE_CBL_MODE_EXIT_ACK,
+
+	/* Cable Soft Reset (129) */
+	PE_CBL_SOFT_RESET,
+
+	/* Cable Hard Reset (130) */
+	PE_CBL_HARD_RESET,
+
+	/* BIST Receive Mode (131, 132) */
+	PE_BIST_RECEIVE_MODE,
+	PE_BIST_FRAME_RECEIVED,
+
+	/* BIST Transmit Mode (133, 134) */
+	PE_BIST_TRANSMIT_MODE,
+	PE_BIST_SEND_FRAME,
+
+	/* BIST Carrier Mode and Eye Pattern (135 - 139) */
+	PE_BIST_EYE_PATTERN_MODE,
+	PE_BIST_CARRIER_MODE_0,
+	PE_BIST_CARRIER_MODE_1,
+	PE_BIST_CARRIER_MODE_2,
+	PE_BIST_CARRIER_MODE_3,
+
+	/* Type-C referenced states (140) */
+	ERROR_RECOVERY,
+};
+
+enum policy_state {
+	POLICY_STATE_UNKNOWN,
+	POLICY_STATE_OFFLINE,
+	POLICY_STATE_ONLINE,
+};
+
+enum policy_status {
+	POLICY_STATUS_UNKNOWN,
+	POLICY_STATUS_STOPPED,
+	POLICY_STATUS_STARTED,
+};
+
+struct policy {
+	enum policy_type type;
+	struct policy_engine *pe;
+	struct list_head list;
+	enum policy_status status;
+	void *priv;
+	int (*start)(struct policy *p);
+	int (*stop)(struct policy *p);
+	int (*rcv_pkt)(struct policy *p, struct pd_packet *pkt,
+				enum pe_event evt);
+	int (*rcv_cmd)(struct policy *p, enum pe_event evt);
+};
+
+struct policy_engine {
+	struct pd_prot *prot;
+	struct notifier_block proto_nb;
+	struct notifier_block dpm_nb;
+	struct mutex protowk_lock;
+	struct mutex dpmwk_lock;
+	struct mutex pe_lock;
+	struct list_head proto_queue;
+	struct list_head dpm_queue;
+	struct work_struct proto_work;
+	struct work_struct dpm_work;
+	struct devpolicy_mgr *dpm;
+	struct pe_operations *ops;
+	struct pd_packet pkt;
+	struct list_head list;
+
+	enum pe_event prev_evt;
+	spinlock_t proto_queue_lock;
+	spinlock_t dpm_queue_lock;
+
+	struct pd_policy *supported_policies;
+	struct notifier_block sink_nb;
+	struct notifier_block source_nb;
+	struct extcon_specific_cable_nb sink_cable_nb;
+	struct extcon_specific_cable_nb source_cable_nb;
+	struct work_struct policy_work;
+	struct work_struct policy_init_work;
+
+	struct list_head policy_list;
+	enum policy_type policy_in_use;
+	enum policy_state state;
+	bool is_pd_connected;
+};
+
+struct pe_operations {
+	int (*get_snkpwr_cap)(struct policy_engine *pe,
+					struct power_cap *cap);
+	int (*get_snkpwr_caps)(struct policy_engine *pe,
+					struct power_caps *caps);
+	int (*get_max_snkpwr_cap)(struct policy_engine *pe,
+					struct power_cap *cap);
+	enum data_role (*get_data_role)(struct policy_engine *pe);
+	enum pwr_role (*get_power_role)(struct policy_engine *pe);
+	void (*set_data_role)(struct policy_engine *pe, enum data_role role);
+	void (*set_power_role)(struct policy_engine *pe, enum pwr_role role);
+	int (*set_charger_mode)(struct policy_engine *pe,
+					enum charger_mode mode);
+	int (*update_charger_ilim)(struct policy_engine *pe,
+					int ilim);
+	int (*get_min_snk_current)(struct policy_engine *pe,
+					int *ma);
+	int (*send_packet)(struct policy_engine *pe, void *data,
+				int len, u8 msg_type, enum pe_event evt);
+	enum cable_state (*get_vbus_state)(struct policy_engine *pe);
+	int (*set_pd_state)(struct policy_engine *pe, bool state);
+	bool (*get_pd_state)(struct policy_engine *pe);
+	int (*process_msg)(struct policy_engine *pe, struct pd_packet *data);
+	int (*process_cmd)(struct policy_engine *pe, int cmd);
+	void (*update_policy_engine)(struct policy_engine *pe, int policy_type,
+					int state);
+};
+
+struct pe_proto_evt {
+	struct list_head node;
+	struct pd_packet pkt;
+};
+
+struct pe_dpm_evt {
+	struct list_head node;
+	struct power_cap caps;
+};
+
+#define pe_get_phy(x)	((x) ?  x->dpm->phy : NULL)
+
+static inline const char *policy_port_type_string(enum policy_type ptype)
+{
+	switch (ptype) {
+	case POLICY_TYPE_SOURCE:
+	return "SOURCE PORT PE";
+	case POLICY_TYPE_SINK:
+		return "SINK PORT PE";
+	case POLICY_TYPE_DISPLAY:
+		return "DISPLAY PORT PE";
+	default:
+		return "UNKNOWN PE TYPE";
+	}
+}
+
+/* methods to initialize/destroy the policy manager */
+static inline int policy_get_snkpwr_cap(struct policy *p, struct power_cap *cap)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_snkpwr_cap)
+		return p->pe->ops->get_snkpwr_cap(p->pe, cap);
+
+	return -ENOTSUPP;
+}
+
+static inline int policy_get_snkpwr_caps(struct policy *p,
+						struct power_caps *caps)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_snkpwr_caps)
+		return p->pe->ops->get_snkpwr_caps(p->pe, caps);
+
+	return -ENOTSUPP;
+}
+
+static inline int policy_get_max_snkpwr_cap(struct policy *p,
+						struct power_cap *cap)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_max_snkpwr_cap)
+		return p->pe->ops->get_max_snkpwr_cap(p->pe, cap);
+
+	return -ENOTSUPP;
+}
+
+static inline enum data_role policy_get_data_role(struct policy *p)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_data_role)
+		return p->pe->ops->get_data_role(p->pe);
+
+	return DATA_ROLE_NONE;
+}
+
+static inline enum pwr_role policy_get_power_role(struct policy *p)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_power_role)
+		return p->pe->ops->get_power_role(p->pe);
+
+	return POWER_ROLE_NONE;
+}
+
+static inline void policy_set_data_role(struct policy *p, int role)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->set_data_role)
+		p->pe->ops->set_data_role(p->pe, role);
+}
+
+static inline void policy_set_power_role(struct policy *p, int role)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->set_power_role)
+		p->pe->ops->set_power_role(p->pe, role);
+}
+
+static inline int policy_set_charger_mode(struct policy *p,
+						enum charger_mode mode)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->set_charger_mode)
+		return p->pe->ops->set_charger_mode(p->pe, mode);
+
+	return -ENOTSUPP;
+}
+
+static inline int policy_update_charger_ilim(struct policy *p,
+						int ilim)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->update_charger_ilim)
+		return p->pe->ops->update_charger_ilim(p->pe, ilim);
+
+	return -ENOTSUPP;
+}
+
+static inline int policy_get_min_current(struct policy *p,
+						int *ma)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_min_snk_current)
+		return p->pe->ops->get_min_snk_current(p->pe, ma);
+
+	return -ENOTSUPP;
+}
+
+static inline int policy_send_packet(struct policy *p, void *data, int len,
+					u8 msg_type, enum pe_event evt)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->send_packet)
+		return p->pe->ops->send_packet(p->pe, data, len, msg_type, evt);
+
+	return -ENOTSUPP;
+}
+
+static inline enum cable_state policy_get_vbus_state(struct policy *p)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_vbus_state)
+		return p->pe->ops->get_vbus_state(p->pe);
+
+	return -ENOTSUPP;
+}
+
+static inline int policy_set_pd_state(struct policy *p, bool state)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->set_pd_state)
+		return p->pe->ops->set_pd_state(p->pe, state);
+
+	return -ENOTSUPP;
+}
+
+static inline bool policy_get_pd_state(struct policy *p)
+{
+	if (p && p->pe && p->pe->ops && p->pe->ops->get_pd_state)
+		return p->pe->ops->get_pd_state(p->pe);
+
+	return -ENOTSUPP;
+}
+
+#if defined(CONFIG_USBC_PD) && defined(CONFIG_USBC_PD_POLICY)
+extern int policy_engine_bind_dpm(struct devpolicy_mgr *dpm);
+extern void policy_engine_unbind_dpm(struct devpolicy_mgr *dpm);
+#else /* CONFIG_USBC_PD && CONFIG_USBC_PD_POLICY */
+static inline int policy_engine_bind_dpm(struct devpolicy_mgr *dpm)
+{
+	return 0;
+}
+static inline void policy_engine_unbind_dpm(struct devpolicy_mgr *dpm)
+{ }
+#endif /* CONFIG_USBC_PD && CONFIG_USBC_PD_POLICY */
+
+static inline int pe_send_cmd(struct policy_engine *pe, int cmd)
+{
+	if (pe && pe->ops && pe->ops->process_cmd)
+		return pe->ops->process_cmd(pe, cmd);
+
+	return -ENOTSUPP;
+}
+
+static inline int pe_send_msg(struct policy_engine *pe, struct pd_packet *pkt)
+{
+	if (pe && pe->ops && pe->ops->process_msg)
+		return pe->ops->process_msg(pe, pkt);
+
+	return -ENOTSUPP;
+}
+
+extern struct policy *sink_port_policy_init(struct policy_engine *pe);
+extern int dpm_register_pe(struct policy_engine *x, int port);
+extern void dpm_unregister_pe(struct policy_engine *x);
+extern int protocol_bind_pe(struct policy_engine *pe);
+extern void protocol_unbind_pe(struct policy_engine *pe);
+
+#endif /* __POLICY_ENGINE_H__ */
diff --git a/drivers/usb/typec/pd/protocol.c b/drivers/usb/typec/pd/protocol.c
index 0f35ee194219..eea1f1765d2f 100644
--- a/drivers/usb/typec/pd/protocol.c
+++ b/drivers/usb/typec/pd/protocol.c
@@ -29,7 +29,6 @@
 #include <linux/errno.h>
 #include "message.h"
 #include "protocol.h"
-#include "devpolicy_mgr.h"
 
 static LIST_HEAD(protocol_list);
 static DEFINE_SPINLOCK(protocol_lock);
@@ -106,6 +105,10 @@ static int pd_prot_handle_reset(struct pd_prot *pd, enum typec_phy_evts evt)
 	/*TODO: check if the the work is completed */
 	pd->event = PROT_PHY_EVENT_NONE;
 
+	if (evt == PROT_PHY_EVENT_HARD_RST)
+		/* notify policy */
+		pe_send_cmd(pd->pe, PD_CMD_HARD_RESET);
+
 	return 0;
 }
 
@@ -189,7 +192,7 @@ static void pd_prot_rx_work(struct pd_prot *pd)
 		wait_for_completion(&pd->tx_complete);
 
 	if (pd->event == PROT_PHY_EVENT_RESET)
-		goto end;
+		return;
 
 	buf = &pd->cached_rx_buf;
 
@@ -200,10 +203,9 @@ static void pd_prot_rx_work(struct pd_prot *pd)
 		pd_tx_discard_msg(pd);
 		pd->rx_msg_id = msg_id;
 
+		/* notify policy */
+		pe_send_msg(pd->pe, buf);
 	}
-end:
-	if (!pd->phy->support_auto_goodcrc)
-		reinit_completion(&pd->tx_complete);
 }
 
 static inline void prot_rx_reset(struct pd_prot *pd)
@@ -263,6 +265,9 @@ static void pd_prot_phy_rcv(struct pd_prot *pd)
 		}
 		memcpy(&pd->cached_rx_buf, &rcv_buf, len);
 		pd_prot_rx_work(pd);
+
+		if (!pd->phy->support_auto_goodcrc)
+			reinit_completion(&pd->tx_complete);
 	}
 end:
 	mutex_unlock(&pd->rx_data_lock);
@@ -312,6 +317,8 @@ static void pd_notify_protocol(struct typec_phy *phy, unsigned long event)
 	case PROT_PHY_EVENT_SOFT_RST_FAIL:
 		break;
 	case PROT_PHY_EVENT_TX_HARD_RST: /* sent HRD_RST */
+		/* Hard reset complete signaling */
+		pe_send_cmd(pd->pe, PD_CMD_HARD_RESET_COMPLETE);
 		break;
 	default:
 		break;
@@ -326,6 +333,42 @@ static void prot_cable_worker(struct work_struct *work)
 	pd_prot_setup_role(prot, prot->new_data_role, prot->new_pwr_role);
 }
 
+static void *to_prot(struct typec_phy *phy)
+{
+	struct pd_prot *prot, *temp;
+	list_for_each_entry_safe(prot, temp, &protocol_list, list) {
+		if (prot->phy == phy)
+			return prot;
+	}
+	return NULL;
+}
+
+int protocol_bind_pe(struct policy_engine *pe)
+{
+	struct typec_phy *phy = pe_get_phy(pe);
+	struct pd_prot *prot = to_prot(phy);
+
+	if (!prot)
+		return -ENODEV;
+	pe->prot = prot;
+	prot->pe = pe;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(protocol_bind_pe);
+
+void protocol_unbind_pe(struct policy_engine *pe)
+{
+	struct typec_phy *phy = pe_get_phy(pe);
+	struct pd_prot *prot = to_prot(phy);
+
+	if (!prot)
+		return;
+
+	pe->prot = NULL;
+	prot->pe = NULL;
+}
+EXPORT_SYMBOL_GPL(protocol_unbind_pe);
+
 int protocol_bind_dpm(struct typec_phy *phy)
 {
 	int ret;
diff --git a/drivers/usb/typec/pd/protocol.h b/drivers/usb/typec/pd/protocol.h
index 477f337f9c60..24f65c741b77 100644
--- a/drivers/usb/typec/pd/protocol.h
+++ b/drivers/usb/typec/pd/protocol.h
@@ -7,6 +7,7 @@
 #include <linux/extcon.h>
 #include <linux/usb_typec_phy.h>
 #include "message.h"
+#include "policy_engine.h"
 
 #define PD_MAX_MSG_ID	8
 
@@ -28,6 +29,7 @@ enum prot_tx_fsm {
 
 struct pd_prot {
 	struct typec_phy *phy;
+	struct policy_engine *pe;
 	u32 retry_count;
 	u8 pd_version;
 
-- 
1.9.1

