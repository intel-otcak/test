From 5fb2f60675dee8468dc2a516cf44a4e23a2b0036 Mon Sep 17 00:00:00 2001
From: Ilkka Koskinen <ilkka.koskinen@intel.com>
Date: Fri, 9 May 2014 17:04:56 +0300
Subject: [PATCH 026/117] gc0339: Add gc0339 camera sensor driver

Received April 7th

Signed-off-by: Ilkka Koskinen <ilkka.koskinen@intel.com>
---
 arch/x86/platform/intel-mid/Makefile               |    1 +
 .../intel-mid/device_libs/platform_gc0339.c        |  259 ++++
 .../camera/drivers/media/i2c/Kconfig               |   12 +-
 .../camera/drivers/media/i2c/Makefile              |    1 +
 .../camera/drivers/media/i2c/gc0339.c              | 1492 ++++++++++++++++++++
 .../camera/drivers/media/i2c/gc0339.h              |  541 +++++++
 6 files changed, 2305 insertions(+), 1 deletion(-)
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_gc0339.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/gc0339.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/gc0339.h

diff --git a/arch/x86/platform/intel-mid/Makefile b/arch/x86/platform/intel-mid/Makefile
index e9e543c8..f501849 100644
--- a/arch/x86/platform/intel-mid/Makefile
+++ b/arch/x86/platform/intel-mid/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_GMIN_INTEL_MID) += platform_byt_regulator.o
 obj-$(CONFIG_GMIN_INTEL_MID) += intel_mid_pcihelpers.o platform_imx134.o atomisp_gmin_platform.o
 
 obj-$(subst m,y,$(CONFIG_VIDEO_GC2235)) += device_libs/platform_gc2235.o
+obj-$(subst m,y,$(CONFIG_VIDEO_GC0339)) += device_libs/platform_gc0339.o
 
 # SFI specific code
 ifdef CONFIG_X86_INTEL_MID
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_gc0339.c b/arch/x86/platform/intel-mid/device_libs/platform_gc0339.c
new file mode 100644
index 0000000..eede39d
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_gc0339.c
@@ -0,0 +1,259 @@
+/*
+ * platform_gc0339.c: gc0339 platform data initilization file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/atomisp_platform.h>
+#include <asm/intel_scu_ipcutil.h>
+#include <asm/intel-mid.h>
+#include <media/v4l2-subdev.h>
+#include <linux/mfd/intel_mid_pmic.h>
+#include <linux/vlv2_plat_clock.h>
+#include "platform_camera.h"
+#include "platform_gc0339.h"
+
+/* workround - pin defined for byt */
+#define CAMERA_0_RESET 126
+#define CAMERA_0_PWDN 123
+#ifdef CONFIG_VLV2_PLAT_CLK
+#define OSC_CAM0_CLK 0x0
+#define CLK_19P2MHz 0x1
+#endif
+#ifdef CONFIG_CRYSTAL_COVE
+#define VPROG_2P8V 0x66
+#define VPROG_1P8V 0x5D
+#define VPROG_ENABLE 0x3
+#define VPROG_DISABLE 0x2
+#endif
+static int camera_reset;
+static int camera_power_down;
+static int camera_vprog1_on;
+
+/*
+ * GC0339 platform data
+ */
+
+static int gc0339_gpio_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret;
+	int pin;
+
+#if 0
+if (flag == 0)
+	return 0;
+#endif
+
+	if (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_VALLEYVIEW2) {
+		if (camera_reset < 0) {
+			ret = camera_sensor_gpio(-1, GP_CAMERA_0_RESET,
+					GPIOF_DIR_OUT, 1);
+			if (ret < 0)
+				return ret;
+			camera_reset = ret;
+		}
+
+		if (camera_power_down < 0) {
+			ret = camera_sensor_gpio(-1, GP_CAMERA_0_POWER_DOWN,
+					GPIOF_DIR_OUT, 0);
+			if (ret < 0)
+				return ret;
+			camera_power_down = ret;
+		}
+	} else {
+		/*
+		 * FIXME: WA using hardcoded GPIO value here.
+		 * The GPIO value would be provided by ACPI table, which is
+		 * not implemented currently.
+		 */
+		pin = CAMERA_0_RESET;
+		if (camera_reset < 0) {
+			ret = gpio_request(pin, "camera_0_reset");
+			if (ret) {
+				pr_err("%s: failed to request gpio(pin %d)\n",
+					__func__, pin);
+				return ret;
+			}
+			camera_reset = pin;
+#if 0
+			pr_info("output reset %d\n", flag ? 1 : 0);
+			ret = gpio_direction_output(pin, flag ? 1 : 0);
+			if (ret) {
+				pr_err("%s: failed to set gpio(pin %d) direction\n",
+					__func__, pin);
+				gpio_free(pin);
+				return ret;
+			}
+#endif
+		}
+
+		/*
+		 * FIXME: WA using hardcoded GPIO value here.
+		 * The GPIO value would be provided by ACPI table, which is
+		 * not implemented currently.
+		 */
+		pin = CAMERA_0_PWDN;
+		if (camera_power_down < 0) {
+			ret = gpio_request(pin, "camera_0_power");
+			if (ret) {
+				pr_err("%s: failed to request gpio(pin %d)\n",
+					__func__, pin);
+				return ret;
+			}
+			camera_power_down = pin;
+#if 0
+			pr_info("output pwn %d\n", 0);//flag ? 0 : 1);
+			ret = gpio_direction_output(pin, 0);//flag ? 0 : 1);
+			if (ret) {
+				pr_err("%s: failed to set gpio(pin %d) direction\n",
+					__func__, pin);
+				gpio_free(pin);
+				return ret;
+			}
+#endif
+		}
+
+	}
+	if (flag) {
+		pr_info("pull low reset\n");
+		gpio_set_value(camera_reset, 0);
+		msleep(5);
+		pr_info("pull high reset\n");
+		gpio_set_value(camera_reset, 1);
+		msleep(10);
+		pr_info("pull low pwn\n");
+		gpio_set_value(camera_power_down, 0);
+		msleep(10);
+	} else {
+		pr_info("pull high pwn\n");
+		gpio_set_value(camera_power_down, 1);
+		pr_info("pull low reset\n");
+		gpio_set_value(camera_reset, 0);
+	}
+
+	return 0;
+}
+
+static int gc0339_flisclk_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	static const unsigned int clock_khz = 19200;
+	int ret = 0;
+
+#if 0
+	if (flag == 0)
+		return 0;
+#endif
+
+	if (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_VALLEYVIEW2)
+		return intel_scu_ipc_osc_clk(OSC_CLK_CAM0,
+					     flag ? clock_khz : 0);
+#ifdef CONFIG_VLV2_PLAT_CLK
+	if (flag) {
+		pr_info("mclk enable\n");
+		ret = vlv2_plat_set_clock_freq(OSC_CAM0_CLK, CLK_19P2MHz);
+		if (ret)
+			return ret;
+	}
+	ret = vlv2_plat_configure_clock(OSC_CAM0_CLK, flag);
+#endif
+	return ret;
+}
+
+/*
+ * The power_down gpio pin is to control GC0339's
+ * internal power state.
+ */
+static int gc0339_power_ctrl(struct v4l2_subdev *sd, int flag)
+{
+	int ret = 0;
+
+#if 0
+	if (flag == 0)
+		return 0;
+#endif
+
+	if (flag) {
+		if (camera_vprog1_on != 1) {
+			if (intel_mid_identify_cpu() !=
+			    INTEL_MID_CPU_CHIP_VALLEYVIEW2)
+				ret = intel_scu_ipc_msic_vprog1(1);
+#ifdef CONFIG_CRYSTAL_COVE
+			pr_info("1 disable 1V8\n");
+			ret = camera_set_pmic_power(CAMERA_1P8V, false);
+			if (ret)
+				return ret;
+			pr_info("1 disable 2V8\n");
+			ret = camera_set_pmic_power(CAMERA_2P8V, false);
+			mdelay(50);
+
+			/*
+			 * This should call VRF APIs.
+			 *
+			 * VRF not implemented for BTY, so call this
+			 * as WAs
+			 */
+			 pr_info("enable 1V8\n");
+			ret = camera_set_pmic_power(CAMERA_1P8V, true);
+			if (ret)
+				return ret;
+			//msleep(10);
+			pr_info("enable 2V8\n");
+			ret = camera_set_pmic_power(CAMERA_2P8V, true);
+			msleep(10);
+#endif
+			if (!ret)
+				camera_vprog1_on = 1;
+			return ret;
+		}
+	} else {
+		if (camera_vprog1_on != 0) {
+			if (intel_mid_identify_cpu() !=
+			    INTEL_MID_CPU_CHIP_VALLEYVIEW2)
+				ret = intel_scu_ipc_msic_vprog1(0);
+#ifdef CONFIG_CRYSTAL_COVE
+			pr_info("disable 1V8\n");
+			ret = camera_set_pmic_power(CAMERA_1P8V, false);
+			if (ret)
+				return ret;
+			pr_info("disable 2V8\n");
+			ret = camera_set_pmic_power(CAMERA_2P8V, false);
+#endif
+			if (!ret)
+				camera_vprog1_on = 0;
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int gc0339_csi_configure(struct v4l2_subdev *sd, int flag)
+{
+	return camera_sensor_csi(sd, ATOMISP_CAMERA_PORT_PRIMARY, 1,
+		ATOMISP_INPUT_FORMAT_RAW_10, atomisp_bayer_order_grbg, flag);
+}
+
+static struct camera_sensor_platform_data gc0339_sensor_platform_data = {
+	.gpio_ctrl	= gc0339_gpio_ctrl,
+	.flisclk_ctrl	= gc0339_flisclk_ctrl,
+	.power_ctrl	= gc0339_power_ctrl,
+	.csi_cfg	= gc0339_csi_configure,
+};
+
+void *gc0339_platform_data(void *info)
+{
+	camera_reset = -1;
+	camera_power_down = -1;
+	camera_vprog1_on = -1;
+
+	return &gc0339_sensor_platform_data;
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
index 1271fd9..6ee662a 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
@@ -46,6 +46,17 @@ config VIDEO_M10MO_FAKE_SFI_TABLE
 
 	  Not needed if device IFWI already has M10MO in the SFI table.
 
+config VIDEO_GC0339
+       tristate "Galaxy gc0339 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the OVT
+         GC0339 camera.
+
+         GC0339 is a 0.3M sensor.
+
+         It currently only works with the atomisp driver.
+
 config VIDEO_GC2235
        tristate "Galaxy gc2235 sensor support"
        depends on I2C && VIDEO_V4L2
@@ -204,4 +215,3 @@ config VIDEO_LM3559
          To compile this driver as a module, choose M here: the
          module will be called lm3559
 
-
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
index 275eee8..af76bb7 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/Makefile
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_VIDEO_MT9V113)    += mt9v113.o
 
 obj-$(CONFIG_VIDEO_OV5640)     += ov5640.o
 
+obj-$(CONFIG_VIDEO_GC0339)     += gc0339.o
 obj-$(CONFIG_VIDEO_GC2235)     += gc2235.o
 obj-$(CONFIG_VIDEO_OV9724)     += ov9724.o
 obj-$(CONFIG_VIDEO_OV2722)     += ov2722.o
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc0339.c b/drivers/external_drivers/camera/drivers/media/i2c/gc0339.c
new file mode 100644
index 0000000..8dab73f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc0339.c
@@ -0,0 +1,1492 @@
+/*
+ * Support for GalaxyCore GC0339 VGA camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/io.h>
+
+#include "gc0339.h"
+
+/* i2c read/write stuff */
+static int gc0339_read_reg(struct i2c_client *client,
+			   u16 data_length, u8 reg, u8 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != GC0339_8BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg & 0xff);
+	//pr_info("msg0 %x %d %d %d\n", msg[0].addr, msg[0].flags, msg[0].len, *msg[0].buf);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data+1;
+	//pr_info("msg1 %x %d %d %d\n", msg[1].addr, msg[1].flags, msg[1].len, *msg[1].buf);
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+//pr_info("read %d %d %d\n", data[0], data[1], err);
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == GC0339_8BIT)
+		*val = (u8)data[1];
+
+	return 0;
+}
+
+static int gc0339_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int gc0339_write_reg(struct i2c_client *client, u16 data_length,
+							u8 reg, u8 val)
+{
+	int ret;
+	unsigned char data[2] = {0};
+	u8 *wreg = (u8 *)data;
+	const u16 len = data_length + sizeof(u8); /* 8-bit address + data */
+
+	if (data_length != GC0339_8BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = (u8)(reg & 0xff);
+
+	if (data_length == GC0339_8BIT) {
+		data[1] = (u8)(val);
+	}
+
+	ret = gc0339_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * gc0339_write_reg_array - Initializes a list of GC0339 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __gc0339_flush_reg_array, __gc0339_buf_reg_array() and
+ * __gc0339_write_reg_is_consecutive() are internal functions to
+ * gc0339_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __gc0339_flush_reg_array(struct i2c_client *client,
+				    struct gc0339_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u8) + ctrl->index; /* 8-bit address + data */
+	ctrl->buffer.addr = (u8)(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return gc0339_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __gc0339_buf_reg_array(struct i2c_client *client,
+				  struct gc0339_write_ctrl *ctrl,
+				  const struct gc0339_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case GC0339_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u8) >= GC0339_MAX_WRITE_BUF_SIZE)
+		return __gc0339_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int __gc0339_write_reg_is_consecutive(struct i2c_client *client,
+					     struct gc0339_write_ctrl *ctrl,
+					     const struct gc0339_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int gc0339_write_reg_array(struct i2c_client *client,
+				  const struct gc0339_reg *reglist)
+{
+	const struct gc0339_reg *next = reglist;
+	struct gc0339_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != GC0339_TOK_TERM; next++) {
+		switch (next->type & GC0339_TOK_MASK) {
+		case GC0339_TOK_DELAY:
+			err = __gc0339_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__gc0339_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __gc0339_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __gc0339_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __gc0339_flush_reg_array(client, &ctrl);
+}
+static int gc0339_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC0339_FOCAL_LENGTH_NUM << 16) | GC0339_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int gc0339_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (GC0339_F_NUMBER_DEFAULT_NUM << 16) | GC0339_F_NUMBER_DEM;
+	return 0;
+}
+
+static int gc0339_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC0339_F_NUMBER_DEFAULT_NUM << 24) |
+		(GC0339_F_NUMBER_DEM << 16) |
+		(GC0339_F_NUMBER_DEFAULT_NUM << 8) | GC0339_F_NUMBER_DEM;
+	return 0;
+}
+
+static int gc0339_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+
+	*val = gc0339_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int gc0339_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+
+	*val = gc0339_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+static int gc0339_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct gc0339_resolution *res)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	const unsigned int ext_clk_freq_hz = 19200000;
+	u16 val;
+	u8 reg_val;
+	int ret;
+	unsigned int hori_blanking;
+	unsigned int vert_blanking;
+	unsigned int sh_delay;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* pixel clock calculattion */
+	dev->vt_pix_clk_freq_mhz = ext_clk_freq_hz / 2;
+	buf->vt_pix_clk_freq_mhz = ext_clk_freq_hz / 2;
+	pr_info("vt_pix_clk_freq_mhz=%d\n", buf->vt_pix_clk_freq_mhz);
+
+	/* get integration time */
+	buf->coarse_integration_time_min = GC0339_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+					GC0339_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = GC0339_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					GC0339_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = GC0339_FINE_INTG_TIME_MIN;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	/* Getting crop_horizontal_start */
+	ret =  gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_H_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret =  gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_H_CROP_START_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = val | (reg_val & 0xFF);
+	pr_info("crop_horizontal_start=%d\n", buf->crop_horizontal_start);
+
+	/* Getting crop_vertical_start */
+	ret =  gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_V_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret =  gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_V_CROP_START_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = val | (reg_val & 0xFF);
+	pr_info("crop_vertical_start=%d\n", buf->crop_vertical_start);
+
+	/* Getting output_width */
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_H_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_H_OUTSIZE_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_width = val | (reg_val & 0xFF);
+	pr_info("output_width=%d\n", buf->output_width);
+
+	/* Getting output_height */
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_V_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_V_OUTSIZE_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_height = val | (reg_val & 0xFF);
+	pr_info("output_height=%d\n", buf->output_height);
+
+	buf->crop_horizontal_end = buf->crop_horizontal_start + buf->output_width - 1;
+	buf->crop_vertical_end = buf->crop_vertical_start + buf->output_height - 1;
+	pr_info("crop_horizontal_end=%d\n", buf->crop_horizontal_end);
+	pr_info("crop_vertical_end=%d\n", buf->crop_vertical_end);
+
+	/* Getting line_length_pck */
+#if 1
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_H_BLANKING_H, &reg_val);
+	if (ret)
+		return ret;
+	val = ((reg_val & 0xF0) >> 4) << 8;
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_H_BLANKING_L, &reg_val);
+	if (ret)
+		return ret;
+	hori_blanking = val | (reg_val & 0xFF);
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_SH_DELAY, &reg_val);
+	if (ret)
+		return ret;
+	sh_delay = reg_val;
+	buf->line_length_pck = buf->output_width + hori_blanking + sh_delay + 4;
+	pr_info("hori_blanking=%d sh_delay=%d line_length_pck=%d\n", hori_blanking, sh_delay, buf->line_length_pck);
+#else
+	buf->line_length_pck = res->pixels_per_line;
+#endif
+
+	/* Getting frame_length_lines */
+#if 1
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_V_BLANKING_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0x0F) << 8;
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_V_BLANKING_L, &reg_val);
+	if (ret)
+		return ret;
+	vert_blanking = val | (reg_val & 0xFF);
+	buf->frame_length_lines = buf->output_height + vert_blanking;
+	pr_info("vert_blanking=%d frame_length_lines=%d\n", vert_blanking, buf->frame_length_lines);
+#else
+	buf->frame_length_lines = res->lines_per_frame;
+#endif
+
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
+	return 0;
+}
+
+static long __gc0339_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	u16 vts;
+	int frame_length;
+	int ret;
+
+	pr_info("coarse_itg=%d gain=%d digitgain=%d\n", coarse_itg, gain, digitgain);
+
+	vts = gc0339_res[dev->fmt_idx].lines_per_frame;
+	if ((coarse_itg + GC0339_COARSE_INTG_TIME_MAX_MARGIN) >= vts)
+		frame_length = coarse_itg + GC0339_COARSE_INTG_TIME_MAX_MARGIN;
+	else
+		frame_length = vts;
+
+#if 0
+	/* group hold start */
+	ret = gc0339_write_reg(client, GC0339_8BIT, GC0339_GROUP_ACCESS, 1);
+	if (ret)
+		return ret;
+#endif
+
+#if 0
+	ret = gc0339_write_reg(client, GC0339_8BIT,
+				GC0339_VTS_DIFF_H, frame_length >> 8);
+	if (ret)
+		return ret;
+#endif
+
+	/* set exposure */
+	ret = gc0339_write_reg(client, GC0339_8BIT,
+					GC0339_AEC_PK_EXPO_L,
+					coarse_itg & 0xff);
+	if (ret)
+		return ret;
+
+	ret = gc0339_write_reg(client, GC0339_8BIT,
+					GC0339_AEC_PK_EXPO_H,
+					(coarse_itg >> 8) & 0x0f);
+	if (ret)
+		return ret;
+
+	/* set analog gain */
+	ret = gc0339_write_reg(client, GC0339_8BIT,
+					GC0339_AGC_ADJ, gain);
+	if (ret)
+		return ret;
+
+#if 0
+	/* group hold end */
+	ret = gc0339_write_reg(client, GC0339_8BIT,
+					GC0339_GROUP_ACCESS, 0x0);
+#endif
+
+	return ret;
+}
+
+static int gc0339_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __gc0339_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long gc0339_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	int exp = exposure->integration_time[0];
+	int gain = exposure->gain[0];
+	int digitgain = exposure->gain[1];
+
+	/* we should not accept the invalid value below. */
+	if (gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	return gc0339_set_exposure(sd, exp, gain, digitgain);
+}
+
+/* TO DO */
+static int gc0339_v_flip(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+/* TO DO */
+static int gc0339_h_flip(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+static long gc0339_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return gc0339_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int gc0339_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 reg_v;
+	int ret;
+
+	/* get exposure */
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_AEC_PK_EXPO_L,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	*value = reg_v;
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_AEC_PK_EXPO_H,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	*value = *value + (reg_v << 8);
+	//pr_info("gc0339_q_exposure %d\n", *value);
+err:
+	return ret;
+}
+struct gc0339_control gc0339_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = gc0339_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc0339_v_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Mirror",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc0339_h_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = GC0339_FOCAL_LENGTH_DEFAULT,
+			.maximum = GC0339_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = GC0339_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc0339_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = GC0339_F_NUMBER_DEFAULT,
+			.maximum = GC0339_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = GC0339_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc0339_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = GC0339_F_NUMBER_RANGE,
+			.maximum =  GC0339_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = GC0339_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = gc0339_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = GC0339_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = gc0339_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = GC0339_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = gc0339_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(gc0339_controls))
+
+static struct gc0339_control *gc0339_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (gc0339_controls[i].qc.id == id)
+			return &gc0339_controls[i];
+	return NULL;
+}
+
+static int gc0339_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct gc0339_control *ctrl = gc0339_find_control(qc->id);
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int gc0339_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc0339_control *s_ctrl;
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = gc0339_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int gc0339_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc0339_control *octrl = gc0339_find_control(ctrl->id);
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int gc0339_init(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+
+	pr_info("%s S\n", __func__);
+	mutex_lock(&dev->input_lock);
+
+	/* set inital registers */
+	ret  = gc0339_write_reg_array(client, gc0339_reset_register);
+
+	/* restore settings */
+	gc0339_res = gc0339_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	mutex_unlock(&dev->input_lock);
+
+	pr_info("%s E\n", __func__);
+	return 0;
+}
+
+static int power_down(struct v4l2_subdev *sd);
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	pr_info("%s S\n", __func__);
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_gpio;
+	}
+
+	msleep(100);
+
+	pr_info("%s E\n", __func__);
+	return 0;
+
+fail_gpio:
+	dev->platform_data->power_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_clk:
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	return ret;
+}
+
+static int gc0339_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return gc0339_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct gc0339_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct gc0339_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &gc0339_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != gc0339_res[i].width)
+			continue;
+		if (h != gc0339_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int gc0339_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+					fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = gc0339_res[N_RES - 1].width;
+		fmt->height = gc0339_res[N_RES - 1].height;
+	} else {
+		fmt->width = gc0339_res[idx].width;
+		fmt->height = gc0339_res[idx].height;
+	}
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+/* TODO: remove it. */
+static int startup(struct v4l2_subdev *sd)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	pr_info("%s S\n", __func__);
+#if 0
+	ret = gc0339_write_reg(client, GC0339_8BIT,
+					GC0339_SW_RESET, 0x01);
+	if (ret) {
+		dev_err(&client->dev, "gc0339 reset err.\n");
+		return ret;
+	}
+#endif
+
+	ret = gc0339_write_reg_array(client, gc0339_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "gc0339 write register err.\n");
+		return ret;
+	}
+
+	pr_info("%s E\n", __func__);
+	return ret;
+}
+
+static int gc0339_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *gc0339_info = NULL;
+	int ret = 0;
+
+	pr_info("%s S\n", __func__);
+	gc0339_info = v4l2_get_subdev_hostdata(sd);
+	if (gc0339_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = gc0339_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width,
+					      fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	printk("%s: before gc0339_write_reg_array %s\n",__FUNCTION__, gc0339_res[dev->fmt_idx].desc);
+	ret = startup(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0339 startup err\n");
+		goto err;
+	}
+
+	ret = gc0339_get_intg_factor(client, gc0339_info,
+					&gc0339_res[dev->fmt_idx]);
+	if (ret) {
+		dev_err(&client->dev, "failed to get integration_factor\n");
+		goto err;
+	}
+
+	pr_info("%s E\n", __func__);
+err:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int gc0339_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = gc0339_res[dev->fmt_idx].width;
+	fmt->height = gc0339_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int gc0339_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	int ret;
+	u8 id;
+
+	pr_info("%s S\n", __func__);
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = gc0339_write_reg(client, GC0339_8BIT,
+					0xFC, 0x10);
+	if (ret) {
+		dev_err(&client->dev, "gc0339 reset err.\n");
+		return ret;
+	}
+
+	ret = gc0339_read_reg(client, GC0339_8BIT,
+					GC0339_SC_CMMN_CHIP_ID, &id);
+	if (ret) {
+		dev_err(&client->dev, "read sensor ID failed\n");
+		return -ENODEV;
+	}
+
+	pr_info("sensor ID = 0x%x\n", id);
+	if (id != GC0339_ID) {
+		dev_err(&client->dev, "sensor ID error, read id = 0x%x, target id = 0x%x\n", id, GC0339_ID);
+		return -ENODEV;
+	}
+
+	dev_dbg(&client->dev, "detect gc0339 success\n");
+
+	pr_info("%s E\n", __func__);
+
+	return 0;
+}
+
+static int gc0339_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	pr_info("%s S enable=%d\n", __func__, enable);
+	mutex_lock(&dev->input_lock);
+
+#if 1
+	if (enable) {
+		/* enable per frame MIPI and sensor ctrl reset  */
+		ret = gc0339_write_reg(client, GC0339_8BIT,0xFE, 0x50);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		printk("reset register.\n");
+		//ret = gc0339_write_reg_array(client, gc0339_reset_register);
+		//ret = gc0339_write_reg_array(client, gc0339_VGA_30fps);
+
+	}
+#endif	
+	ret = gc0339_write_reg(client, GC0339_8BIT, GC0339_SW_STREAM,
+				enable ? GC0339_START_STREAMING :
+				GC0339_STOP_STREAMING);
+
+	mutex_unlock(&dev->input_lock);
+	pr_info("%s E\n", __func__);
+	return ret;
+}
+
+/* gc0339 enum frame size, frame intervals */
+static int gc0339_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = gc0339_res[index].width;
+	fsize->discrete.height = gc0339_res[index].height;
+	fsize->reserved[0] = gc0339_res[index].used;
+
+	return 0;
+}
+
+static int gc0339_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = gc0339_res[index].width;
+	fival->height = gc0339_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = gc0339_res[index].fps;
+
+	return 0;
+}
+
+static int gc0339_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int gc0339_s_config(struct v4l2_subdev *sd,
+			   int irq, void *platform_data)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	pr_info("%s S\n", __func__);
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	dev->platform_data =
+		(struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+	printk("+++[%s], platform_init.\n",__func__);
+	dev->platform_data->platform_init(client);
+
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0339 power-off err.\n");
+		goto fail_power_off;
+	}
+	msleep(100);
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0339 power-up err.\n");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = gc0339_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "gc0339_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0339 power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	pr_info("%s E\n", __func__);
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int gc0339_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			gc0339_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int gc0339_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		gc0339_res = gc0339_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		gc0339_res = gc0339_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		gc0339_res = gc0339_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int gc0339_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = gc0339_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int gc0339_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	return 0;
+}
+
+static int gc0339_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = gc0339_res[index].width;
+	fse->min_height = gc0339_res[index].height;
+	fse->max_width = gc0339_res[index].width;
+	fse->max_height = gc0339_res[index].height;
+
+	return 0;
+
+}
+
+static struct v4l2_mbus_framefmt *
+__gc0339_get_pad_format(struct gc0339_device *sensor,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+			"__gc0339_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int gc0339_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct gc0339_device *snr = to_gc0339_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__gc0339_get_pad_format(snr, fh, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int gc0339_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct gc0339_device *snr = to_gc0339_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int gc0339_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = gc0339_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops gc0339_sensor_ops = {
+	.g_skip_frames	= gc0339_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops gc0339_video_ops = {
+	.s_stream = gc0339_s_stream,
+	.g_parm = gc0339_g_parm,
+	.s_parm = gc0339_s_parm,
+	.enum_framesizes = gc0339_enum_framesizes,
+	.enum_frameintervals = gc0339_enum_frameintervals,
+	.enum_mbus_fmt = gc0339_enum_mbus_fmt,
+	.try_mbus_fmt = gc0339_try_mbus_fmt,
+	.g_mbus_fmt = gc0339_g_mbus_fmt,
+	.s_mbus_fmt = gc0339_s_mbus_fmt,
+	.g_frame_interval = gc0339_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops gc0339_core_ops = {
+	.s_power = gc0339_s_power,
+	.queryctrl = gc0339_queryctrl,
+	.g_ctrl = gc0339_g_ctrl,
+	.s_ctrl = gc0339_s_ctrl,
+	.ioctl = gc0339_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops gc0339_pad_ops = {
+	.enum_mbus_code = gc0339_enum_mbus_code,
+	.enum_frame_size = gc0339_enum_frame_size,
+	.get_fmt = gc0339_get_pad_format,
+	.set_fmt = gc0339_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops gc0339_ops = {
+	.core = &gc0339_core_ops,
+	.video = &gc0339_video_ops,
+	.pad = &gc0339_pad_ops,
+	.sensor = &gc0339_sensor_ops,
+};
+
+static int gc0339_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc0339_device *dev = to_gc0339_sensor(sd);
+	dev_dbg(&client->dev, "gc0339_remove...\n");
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int gc0339_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct gc0339_device *dev;
+	int ret;
+
+	pr_info("%s S\n", __func__);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &gc0339_ops);
+
+	if (client->dev.platform_data) {
+		ret = gc0339_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		gc0339_remove(client);
+
+	pr_info("%s E\n", __func__);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, gc0339_id);
+static struct i2c_driver gc0339_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = GC0339_NAME,
+	},
+	.probe = gc0339_probe,
+	.remove = gc0339_remove,
+	.id_table = gc0339_id,
+};
+
+static int init_gc0339(void)
+{
+	return i2c_add_driver(&gc0339_driver);
+}
+
+static void exit_gc0339(void)
+{
+
+	i2c_del_driver(&gc0339_driver);
+}
+
+module_init(init_gc0339);
+module_exit(exit_gc0339);
+
+MODULE_AUTHOR("Lai, Angie <angie.lai@intel.com>");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GC0339 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc0339.h b/drivers/external_drivers/camera/drivers/media/i2c/gc0339.h
new file mode 100644
index 0000000..a934c97
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc0339.h
@@ -0,0 +1,541 @@
+/*
+ * Support for GalaxyCore GC0339 VGA camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GC0339_H__
+#define __GC0339_H__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+
+#include <linux/atomisp_platform.h>
+
+#define GC0339_NAME		"gc0339_raw"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		1
+#define I2C_RETRY_COUNT		5
+
+#define GC0339_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define GC0339_FOCAL_LENGTH_DEM	100
+#define GC0339_F_NUMBER_DEFAULT_NUM	26
+#define GC0339_F_NUMBER_DEM	10
+
+#define MAX_FMTS		1
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC0339_FOCAL_LENGTH_DEFAULT 0x1160064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC0339_F_NUMBER_DEFAULT 0x1a000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define GC0339_F_NUMBER_RANGE 0x1a0a1a0a
+#define GC0339_ID	0xc8
+
+#define GC0339_FINE_INTG_TIME_MIN 0
+#define GC0339_FINE_INTG_TIME_MAX_MARGIN 0
+#define GC0339_COARSE_INTG_TIME_MIN 1
+#define GC0339_COARSE_INTG_TIME_MAX_MARGIN 6
+
+/*
+ * GC0339 System control registers
+ */
+#define GC0339_SW_STREAM			0x60
+
+#define GC0339_SC_CMMN_CHIP_ID		0x0
+
+#define GC0339_AEC_PK_EXPO_H			0x03
+#define GC0339_AEC_PK_EXPO_L			0x04
+#define GC0339_AGC_ADJ			0x50
+#if 0
+#define GC0339_GROUP_ACCESS			0x3208
+#endif
+
+#define GC0339_H_CROP_START_H			0x07
+#define GC0339_H_CROP_START_L			0x08
+#define GC0339_V_CROP_START_H			0x05
+#define GC0339_V_CROP_START_L			0x06
+#define GC0339_H_OUTSIZE_H			0x0B
+#define GC0339_H_OUTSIZE_L			0x0C
+#define GC0339_V_OUTSIZE_H			0x09
+#define GC0339_V_OUTSIZE_L			0x0A
+#define GC0339_H_BLANKING_H			0x0F /* [3:0] */
+#define GC0339_H_BLANKING_L			0x01
+#define GC0339_V_BLANKING_H			0x0F /* [7:4] */
+#define GC0339_V_BLANKING_L			0x02
+#define GC0339_SH_DELAY			0x12
+
+#define GC0339_START_STREAMING			0x98 /* 10-bit enable */
+#define GC0339_STOP_STREAMING			0x88 /* 10-bit disable */
+
+#define GC0339_BIN_FACTOR_MAX			3
+
+#define REG_VER1 0
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct gc0339_resolution {
+	u8 *desc;
+	const struct gc0339_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u32 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+};
+
+struct gc0339_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct gc0339_reg *regs;
+};
+
+struct gc0339_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * gc0339 device structure.
+ */
+struct gc0339_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u8 res;
+	u8 type;
+};
+
+enum gc0339_tok_type {
+	GC0339_8BIT  = 0x0001,
+	GC0339_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	GC0339_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	GC0339_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct gc0339_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct gc0339_reg {
+	enum gc0339_tok_type type;
+	u8 reg;
+	u8 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_gc0339_sensor(x) container_of(x, struct gc0339_device, sd)
+
+#define GC0339_MAX_WRITE_BUF_SIZE	30
+
+struct gc0339_write_buffer {
+	u8 addr;
+	u8 data[GC0339_MAX_WRITE_BUF_SIZE];
+};
+
+struct gc0339_write_ctrl {
+	int index;
+	struct gc0339_write_buffer buffer;
+};
+
+static const struct i2c_device_id gc0339_id[] = {
+	{GC0339_NAME, 0},
+	{}
+};
+
+/*
+ * Register settings for various resolution
+ */
+static const struct gc0339_reg gc0339_reset_register[] = {
+#if REG_VER1
+	{GC0339_8BIT, 0xFC, 0x10},
+	{GC0339_8BIT, 0xFE, 0x00},
+	{GC0339_8BIT, 0xF6, 0x05},
+	{GC0339_8BIT, 0xF7, 0x01},
+	{GC0339_8BIT, 0xF7, 0x03},
+	{GC0339_8BIT, 0xFC, 0x16},
+	
+	{GC0339_8BIT, 0x06, 0x00},
+	{GC0339_8BIT, 0x08, 0x05},
+	{GC0339_8BIT, 0x09, 0x01}, /* 484 */
+	{GC0339_8BIT, 0x0A, 0xE4},
+	{GC0339_8BIT, 0x0B, 0x02}, /* 644 */
+	{GC0339_8BIT, 0x0C, 0x84},
+	
+	{GC0339_8BIT, 0x01, 0x90}, /* DummyHor 144 */
+	{GC0339_8BIT, 0x02, 0x2F}, /* DummyVer 47 */
+	
+	{GC0339_8BIT, 0x0F, 0x00}, /* DummyHor 144 */
+	{GC0339_8BIT, 0x14, 0x00},
+	{GC0339_8BIT, 0x1A, 0x21},
+	{GC0339_8BIT, 0x1B, 0x08},
+	{GC0339_8BIT, 0x1C, 0x19},
+	{GC0339_8BIT, 0x1D, 0xEA},
+	{GC0339_8BIT, 0x20, 0xB0},
+	{GC0339_8BIT, 0x2E, 0x00},
+	
+	{GC0339_8BIT, 0x30, 0xB7},
+	{GC0339_8BIT, 0x31, 0x7F},
+	{GC0339_8BIT, 0x32, 0x00},
+	{GC0339_8BIT, 0x39, 0x04},
+	{GC0339_8BIT, 0x3A, 0x20},
+	{GC0339_8BIT, 0x3B, 0x20},
+	{GC0339_8BIT, 0x3C, 0x00},
+	{GC0339_8BIT, 0x3D, 0x00},
+	{GC0339_8BIT, 0x3E, 0x00},
+	{GC0339_8BIT, 0x3F, 0x00},
+	
+	{GC0339_8BIT, 0x62, 0x20},
+	{GC0339_8BIT, 0x63, 0x03},
+	{GC0339_8BIT, 0x69, 0x13},
+	{GC0339_8BIT, 0x60, 0x80},
+	{GC0339_8BIT, 0x65, 0x20}, /* 20 -> 21 */
+	{GC0339_8BIT, 0x6C, 0x40},
+	{GC0339_8BIT, 0x6D, 0x01},
+	{GC0339_8BIT, 0x6A, 0x33},
+	
+	{GC0339_8BIT, 0x4A, 0x50},
+	{GC0339_8BIT, 0x4B, 0x40},
+	{GC0339_8BIT, 0x4C, 0x40},
+	{GC0339_8BIT, 0xE8, 0x04},
+	{GC0339_8BIT, 0xE9, 0xBB},
+	
+	{GC0339_8BIT, 0x42, 0x20},
+	{GC0339_8BIT, 0x47, 0x10},
+	
+	{GC0339_8BIT, 0x50, 0x80},
+	
+	{GC0339_8BIT, 0xD0, 0x00},
+	{GC0339_8BIT, 0xD2, 0x00}, /* disable AE */
+	{GC0339_8BIT, 0xD3, 0x50},
+	
+	{GC0339_8BIT, 0x71, 0x01},
+	{GC0339_8BIT, 0x72, 0x01},
+	{GC0339_8BIT, 0x73, 0x05},
+	{GC0339_8BIT, 0x74, 0x01},
+	{GC0339_8BIT, 0x76, 0x03},
+	{GC0339_8BIT, 0x79, 0x01},
+	{GC0339_8BIT, 0x7B, 0x03},
+#else
+	{GC0339_8BIT, 0xfc, 0x10},
+	{GC0339_8BIT, 0xfe, 0x00},
+	{GC0339_8BIT, 0xf6, 0x07},
+	{GC0339_8BIT, 0xf7, 0x01},
+	{GC0339_8BIT, 0xf7, 0x03},
+	{GC0339_8BIT, 0xfc, 0x16},
+	{GC0339_8BIT, 0x06, 0x01},
+	{GC0339_8BIT, 0x08, 0x00},
+	{GC0339_8BIT, 0x09, 0x01},
+	{GC0339_8BIT, 0x0a, 0xf2},
+	{GC0339_8BIT, 0x0b, 0x02},
+	{GC0339_8BIT, 0x0c, 0x94},
+	{GC0339_8BIT, 0x0f, 0x02},
+	{GC0339_8BIT, 0x14, 0x23},
+	{GC0339_8BIT, 0x1a, 0x21},
+	{GC0339_8BIT, 0x1b, 0x08},
+	{GC0339_8BIT, 0x1c, 0x19},
+	{GC0339_8BIT, 0x1d, 0xea},
+	{GC0339_8BIT, 0x61, 0x2b},
+	{GC0339_8BIT, 0x62, 0x34},
+	{GC0339_8BIT, 0x63, 0x03},
+	{GC0339_8BIT, 0x30, 0xb7},
+	{GC0339_8BIT, 0x31, 0x7f},
+	{GC0339_8BIT, 0x32, 0x00},
+	{GC0339_8BIT, 0x39, 0x04},
+	{GC0339_8BIT, 0x3a, 0x20},
+	{GC0339_8BIT, 0x3b, 0x20},
+	{GC0339_8BIT, 0x3c, 0x04},
+	{GC0339_8BIT, 0x3d, 0x04},
+	{GC0339_8BIT, 0x3e, 0x04},
+	{GC0339_8BIT, 0x3f, 0x04},
+	{GC0339_8BIT, 0x69, 0x03},
+	//{GC0339_8BIT, 0x60, 0x82},
+	{GC0339_8BIT, 0x65, 0x10},
+	{GC0339_8BIT, 0x6c, 0x40},
+	{GC0339_8BIT, 0x6d, 0x01},
+	{GC0339_8BIT, 0x67, 0x10},
+	{GC0339_8BIT, 0x4a, 0x40},
+	{GC0339_8BIT, 0x4b, 0x40},
+	{GC0339_8BIT, 0x4c, 0x40},
+	{GC0339_8BIT, 0xe8, 0x04},
+	{GC0339_8BIT, 0xe9, 0xbb},
+	{GC0339_8BIT, 0x42, 0x20},
+	{GC0339_8BIT, 0x47, 0x10},
+	{GC0339_8BIT, 0x50, 0x40},
+	{GC0339_8BIT, 0xd0, 0x00},
+	{GC0339_8BIT, 0xd3, 0x50},
+	{GC0339_8BIT, 0xf6, 0x05},
+	{GC0339_8BIT, 0x01, 0x6a},
+	{GC0339_8BIT, 0x02, 0x0c},
+	{GC0339_8BIT, 0x0f, 0x00},
+	{GC0339_8BIT, 0x6a, 0x55},//11
+	{GC0339_8BIT, 0x71, 0x01},
+	{GC0339_8BIT, 0x72, 0x01},
+	{GC0339_8BIT, 0x73, 0x01},
+	{GC0339_8BIT, 0x79, 0x01},
+	{GC0339_8BIT, 0x7a, 0x01},
+	{GC0339_8BIT, 0x2e, 0x10},
+	{GC0339_8BIT, 0x2b, 0x00},
+	{GC0339_8BIT, 0x2c, 0x03},
+	{GC0339_8BIT, 0xd2, 0x00},
+	{GC0339_8BIT, 0x20, 0xb0},
+	//{GC0339_8BIT, 0x60, 0x92},
+#endif
+	{GC0339_TOK_TERM, 0, 0},
+};
+
+static struct gc0339_reg const gc0339_VGA_30fps[] = {
+#if REG_VER1
+	{GC0339_8BIT, 0x15, 0x0A},
+	{GC0339_8BIT, 0x62, 0x20},
+	{GC0339_8BIT, 0x63, 0x03},
+	{GC0339_8BIT, 0x06, 0x00}, /* Row_start */
+	{GC0339_8BIT, 0x08, 0x05}, /* Column start */
+	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
+	{GC0339_8BIT, 0x0A, 0xE4},
+	{GC0339_8BIT, 0x0B, 0x02}, /* Window width */
+	{GC0339_8BIT, 0x0C, 0x84},
+#else
+	{GC0339_8BIT, 0x15, 0x0A},
+	{GC0339_8BIT, 0x62, 0x34},
+	{GC0339_8BIT, 0x63, 0x03},
+	{GC0339_8BIT, 0x06, 0x01}, /* Row_start */
+	{GC0339_8BIT, 0x08, 0x00}, /* Column start */
+	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
+	{GC0339_8BIT, 0x0a, 0xf2},
+	{GC0339_8BIT, 0x0b, 0x02}, /* Window width */
+	{GC0339_8BIT, 0x0c, 0x94},
+#endif
+	{GC0339_TOK_TERM, 0, 0},
+};
+
+static struct gc0339_reg const gc0339_CIF_30fps[] = {
+#if REG_VER1
+	{GC0339_8BIT, 0x15, 0x8A}, /* CIF */
+	{GC0339_8BIT, 0x62, 0xBD}, /* LWC */
+	{GC0339_8BIT, 0x63, 0x01},
+	{GC0339_8BIT, 0x06, 0x00}, /* Row_start */
+	{GC0339_8BIT, 0x08, 0x05}, /* Column start */
+	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
+	{GC0339_8BIT, 0x0A, 0xD0},
+	{GC0339_8BIT, 0x0B, 0x02}, /* Window width */
+	{GC0339_8BIT, 0x0C, 0x40},
+#else
+	{GC0339_8BIT, 0x15, 0x8A}, /* CIF */
+	{GC0339_8BIT, 0x62, 0xD1}, /* LWC */
+	{GC0339_8BIT, 0x63, 0x01}, /* (368 + 4) / 4 * 5 */
+	{GC0339_8BIT, 0x06, 0x00}, /* Row_start */
+	{GC0339_8BIT, 0x08, 0x05}, /* Column start */
+	{GC0339_8BIT, 0x09, 0x01}, /* Window height */
+	{GC0339_8BIT, 0x0A, 0xD0},
+	{GC0339_8BIT, 0x0B, 0x02}, /* Window width */
+	{GC0339_8BIT, 0x0C, 0x40},
+#endif
+	{GC0339_TOK_TERM, 0, 0},
+};
+
+struct gc0339_resolution gc0339_res_preview[] = {
+#if REG_VER1
+	{
+		.desc = "gc0339_VGA_30fps",
+		.width = 640,
+		.height = 480,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0339_VGA_30fps,
+	},
+#else
+	{
+		.desc = "gc0339_VGA_30fps",
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0339_VGA_30fps,
+	},
+#endif
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(gc0339_res_preview))
+
+struct gc0339_resolution gc0339_res_still[] = {
+#if REG_VER1
+	{
+		.desc = "gc0339_VGA_30fps",
+		.width = 640,
+		.height = 480,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0339_VGA_30fps,
+	},
+#else
+	{
+		.desc = "gc0339_VGA_30fps",
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0339_VGA_30fps,
+	},
+#endif
+};
+#define N_RES_STILL (ARRAY_SIZE(gc0339_res_still))
+
+struct gc0339_resolution gc0339_res_video[] = {
+#if REG_VER1
+#if 0
+	{
+		.desc = "gc0339_CIF_30fps",
+		.width = 352,
+		.height = 288,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x01F0,
+		.lines_per_frame = 0x014F,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 1,
+		.regs = gc0339_CIF_30fps,
+	},
+#endif
+	{
+		.desc = "gc0339_VGA_30fps",
+		.width = 640,
+		.height = 480,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0339_VGA_30fps,
+	},
+#else
+	{
+		.desc = "gc0339_CIF_30fps",
+		.width = 368,
+		.height = 304,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x01F0,
+		.lines_per_frame = 0x014F,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 1,
+		.regs = gc0339_CIF_30fps,
+	},
+	{
+		.desc = "gc0339_VGA_30fps",
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0339_VGA_30fps,
+	},
+#endif
+};
+#define N_RES_VIDEO (ARRAY_SIZE(gc0339_res_video))
+
+static struct gc0339_resolution *gc0339_res = gc0339_res_preview;
+static int N_RES = N_RES_PREVIEW;
+#endif
+
-- 
1.9.3

