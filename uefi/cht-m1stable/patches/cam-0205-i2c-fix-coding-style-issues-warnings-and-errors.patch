From 4c4a869d83ffa33e7e283ec0431c59a5f022b9e5 Mon Sep 17 00:00:00 2001
From: Ding Yunliang <yunliang.ding@intel.com>
Date: Fri, 26 Dec 2014 13:45:49 +0800
Subject: [PATCH 205/210] i2c: fix coding style issues,warnings and errors

kernel requires to check coding style using checkpatch.pl
This patch fixed all source code in i2c folder for camera

Change-Id: I59a3860c53e977eb8371cf8b438fbcf31b31ee89
Tracked-On: https://jira01.devtools.intel.com/browse/IMINAN-14249
Signed-off-by: Ding Yunliang <yunliang.ding@intel.com>
Reviewed-on: https://icggerrit.ir.intel.com/34319
Approver: Wei Tao <wei.tao@intel.com>
Reviewed-by: Wei Tao <wei.tao@intel.com>
Build: Wei Tao <wei.tao@intel.com>
Maintainer: Wei Tao <wei.tao@intel.com>
---
 .../camera/drivers/media/i2c/Kconfig               |  26 +-
 .../camera/drivers/media/i2c/ap1302.c              |  32 +-
 .../camera/drivers/media/i2c/gc2235.c              |  18 +-
 .../camera/drivers/media/i2c/gc2235.h              |   4 +-
 .../camera/drivers/media/i2c/imx/ad5816g.c         |   4 +-
 .../camera/drivers/media/i2c/imx/drv201.c          |   2 +-
 .../camera/drivers/media/i2c/imx/dw9714.c          |   2 +-
 .../camera/drivers/media/i2c/imx/dw9718.c          |   2 +-
 .../camera/drivers/media/i2c/imx/dw9718.h          |   2 +-
 .../camera/drivers/media/i2c/imx/dw9719.c          |   2 +-
 .../camera/drivers/media/i2c/imx/imx.c             |  33 +-
 .../camera/drivers/media/i2c/imx/imx.h             |   2 +-
 .../camera/drivers/media/i2c/imx/imx134.h          |  10 +-
 .../camera/drivers/media/i2c/imx135VB/dw9719.c     |   5 +-
 .../camera/drivers/media/i2c/lm3554.c              |  17 +-
 .../camera/drivers/media/i2c/lm3559.c              |   6 +-
 .../camera/drivers/media/i2c/lm3642.c              |   6 +-
 .../camera/drivers/media/i2c/m10mo.c               | 179 +++++----
 .../camera/drivers/media/i2c/m10mo.h               |  60 +--
 .../camera/drivers/media/i2c/m10mo_fw.c            | 137 ++++---
 .../camera/drivers/media/i2c/m10mo_fw_type2.c      |  14 +-
 .../camera/drivers/media/i2c/m10mo_spi.c           |   3 +-
 .../camera/drivers/media/i2c/mt9e013/Kconfig       |  15 +
 .../camera/drivers/media/i2c/mt9e013/Makefile      |   2 +-
 .../camera/drivers/media/i2c/mt9e013/mt9e013.c     |  30 +-
 .../camera/drivers/media/i2c/mt9e013/mt9e013.h     |   3 +-
 .../drivers/media/i2c/mt9e013/mt9e013_blackbay.h   | 223 +++++++----
 .../drivers/media/i2c/mt9e013/mt9e013_enzo.h       | 226 +++++++----
 .../drivers/media/i2c/mt9e013/mt9e013_lexington.h  | 122 ++++--
 .../camera/drivers/media/i2c/mt9m114.c             | 199 ++++-----
 .../camera/drivers/media/i2c/mt9m114.h             | 443 +++++++++++----------
 .../camera/drivers/media/i2c/ov2722.c              |  11 +-
 .../camera/drivers/media/i2c/ov5693-ecs/ov5693.c   |  48 ++-
 .../camera/drivers/media/i2c/ov5693-ecs/ov5693.h   |  80 ++--
 .../camera/drivers/media/i2c/ov5693/ad5823.c       |   5 +-
 .../camera/drivers/media/i2c/ov5693/ov5693.c       |   3 +-
 .../camera/drivers/media/i2c/ov5693/ov5693.h       |   0
 .../camera/drivers/media/i2c/ov8830.c              |  48 ++-
 .../camera/drivers/media/i2c/ov8858.c              |   3 +-
 .../camera/drivers/media/i2c/ov8858.h              |   3 +-
 .../camera/drivers/media/i2c/pixter.c              |  80 ++--
 .../camera/drivers/media/i2c/pixter.h              |   2 +-
 .../camera/drivers/media/i2c/s5k6b2yx.c            |  66 +--
 .../camera/drivers/media/i2c/s5k6b2yx.h            |  37 +-
 .../camera/drivers/media/i2c/s5k8aay.c             |   7 +-
 .../camera/drivers/media/i2c/s5k8aay_settings.h    | 331 +++++++++------
 .../camera/drivers/media/i2c/xactor_x.c            |  41 +-
 47 files changed, 1574 insertions(+), 1020 deletions(-)
 mode change 100755 => 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c
 mode change 100755 => 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h

diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
index 7af1925..019d4b1 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
@@ -38,12 +38,18 @@ config VIDEO_M10MO
 	  It currently depends on internal V4L2 extensions defined in
 	  atomisp driver.
 
+          It currently only works with the atomisp driver.
+
 config VIDEO_M10MO_FAKE_SFI_TABLE
 	bool "Add fake SFI entry for Fujitsu M10MO on VV board + AOB"
 	depends on VIDEO_M10MO
 	---help---
 	  Enable this when working with VV board with Fujitsu AOB.
 
+	  This is FAKE SFI table.
+
+	  Please note:
+
 	  Not needed if device IFWI already has M10MO in the SFI table.
 
 config VIDEO_GC2235
@@ -62,7 +68,9 @@ config VIDEO_OV8830
        depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP
        ---help---
          This is a Video4Linux2 sensor-level driver for the Omnivision
-         ov8830 8MP RAW sensor.
+         ov8830 RAW sensor.
+
+	 OV8830 is a 8M raw sensor.
 
          It currently only works with the atomisp driver.
 
@@ -71,7 +79,9 @@ config VIDEO_OV8858
        depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP
        ---help---
          This is a Video4Linux2 sensor-level driver for the Omnivision
-         ov8858 8MP RAW sensor.
+         ov8858 RAW sensor.
+
+	 OV8858 is a 8M raw sensor.
 
          It currently only works with the atomisp driver.
 
@@ -79,7 +89,10 @@ config VIDEO_CSI_XACTOR
         tristate "csi xactor"
         depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP
         ---help---
-          Use this if you need to send data through external csi data generator
+          Use this if you need to send data through external csi data
+	  generator.
+
+	  CSI Xactor module.
 
           To compile this driver as a module, choose M here.
 
@@ -129,6 +142,8 @@ config VIDEO_MT9M114
          mt9m114 1.3 Mpixel camera.
 
          mt9m114 is video camrea sensor.
+
+         It currently only works with the atomisp driver.
 config VIDEO_MT9V113
        tristate "Aptina mt9v113 sensor support"
        depends on I2C && VIDEO_V4L2
@@ -167,8 +182,13 @@ config VIDEO_PIXTER
        depends on I2C && VIDEO_V4L2
        ---help---
          This is a Video4Linux2 sensor-level driver for Pixter2+.
+
+	 Pixter 2+ MIPI CSI simulator.
+
          Pixter 2+ is a MIPI CSI simulator.
 
+         It currently only works with the atomisp driver.
+
 config VIDEO_OV680
        tristate "OV680 external ISP support"
        depends on I2C && VIDEO_V4L2
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ap1302.c b/drivers/external_drivers/camera/drivers/media/i2c/ap1302.c
index 6974154..946441a 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ap1302.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ap1302.c
@@ -31,7 +31,8 @@
 #include <media/v4l2-device.h>
 #include "ap1302.h"
 
-#define to_ap1302_device(sub_dev) container_of(sub_dev, struct ap1302_device, sd)
+#define to_ap1302_device(sub_dev) \
+		container_of(sub_dev, struct ap1302_device, sd)
 
 /* Static definitions */
 static struct regmap_config ap1302_reg16_config = {
@@ -200,10 +201,10 @@ static int ap1302_i2c_read_reg(struct v4l2_subdev *sd,
 	}
 	if (len == AP1302_REG16)
 		dev_dbg(&client->dev, "read_reg[0x%04X] = 0x%04X\n",
-			reg, *(u16*)val);
+			reg, *(u16 *)val);
 	else
 		dev_dbg(&client->dev, "read_reg[0x%04X] = 0x%08X\n",
-			reg, *(u32*)val);
+			reg, *(u32 *)val);
 	return ret;
 }
 
@@ -264,7 +265,7 @@ static int ap1302_read_context_reg(struct v4l2_subdev *sd,
 	if (reg_addr == 0)
 		return -EINVAL;
 	return ap1302_i2c_read_reg(sd, reg_addr, len,
-			    ((u8*)&dev->cntx_config[context]) + offset);
+			    ((u8 *)&dev->cntx_config[context]) + offset);
 }
 
 static int ap1302_write_context_reg(struct v4l2_subdev *sd,
@@ -275,7 +276,7 @@ static int ap1302_write_context_reg(struct v4l2_subdev *sd,
 	if (reg_addr == 0)
 		return -EINVAL;
 	return ap1302_i2c_write_reg(sd, reg_addr, len,
-			*(u32*)(((u8*)&dev->cntx_config[context]) + offset));
+			*(u32 *)(((u8 *)&dev->cntx_config[context]) + offset));
 }
 
 static int ap1302_dump_context_reg(struct v4l2_subdev *sd,
@@ -287,7 +288,7 @@ static int ap1302_dump_context_reg(struct v4l2_subdev *sd,
 	dev_dbg(&client->dev, "Dump registers for context[%d]:\n", context);
 	for (i = 0; i < ARRAY_SIZE(context_info); i++) {
 		struct ap1302_context_info *info = &context_info[i];
-		u8 *var = (u8*)&dev->cntx_config[context] + info->offset;
+		u8 *var = (u8 *)&dev->cntx_config[context] + info->offset;
 		/* Snapshot context does not have s1_sensor_mode register. */
 		if (context == CONTEXT_SNAPSHOT &&
 			info->offset == CNTX_S1_SENSOR_MODE)
@@ -295,10 +296,10 @@ static int ap1302_dump_context_reg(struct v4l2_subdev *sd,
 		ap1302_read_context_reg(sd, context, info->offset, info->len);
 		if (info->len == AP1302_REG16)
 			dev_dbg(&client->dev, "context.%s = 0x%04X (%d)\n",
-				info->name, *(u16*)var, *(u16*)var);
+				info->name, *(u16 *)var, *(u16 *)var);
 		else
 			dev_dbg(&client->dev, "context.%s = 0x%08X (%d)\n",
-				info->name, *(u32*)var, *(u32*)var);
+				info->name, *(u32 *)var, *(u32 *)var);
 	}
 	return 0;
 }
@@ -350,7 +351,7 @@ static int ap1302_load_firmware(struct v4l2_subdev *sd)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ap1302_device *dev = to_ap1302_device(sd);
 	const struct ap1302_firmware *fw;
-	const u8* fw_data;
+	const u8 *fw_data;
 	u16 reg_val = 0;
 	u16 win_pos = 0;
 	int ret;
@@ -360,7 +361,7 @@ static int ap1302_load_firmware(struct v4l2_subdev *sd)
 		dev_err(&client->dev, "firmware not requested.\n");
 		return -EINVAL;
 	}
-	fw = (const struct ap1302_firmware*) dev->fw->data;
+	fw = (const struct ap1302_firmware *) dev->fw->data;
 	if (dev->fw->size != (sizeof(*fw) + fw->total_size)) {
 		dev_err(&client->dev, "firmware size does not match.\n");
 		return -EINVAL;
@@ -368,7 +369,7 @@ static int ap1302_load_firmware(struct v4l2_subdev *sd)
 	/* The fw binary contains a header of struct ap1302_firmware.
 	   Following the header is the bootdata of AP1302.
 	   The bootdata pointer can be referenced as &fw[1]. */
-	fw_data = (u8*)&fw[1];
+	fw_data = (u8 *)&fw[1];
 
 	/* Clear crc register. */
 	ret = ap1302_i2c_write_reg(sd, REG_SIP_CRC, AP1302_REG16, 0xFFFF);
@@ -388,7 +389,7 @@ static int ap1302_load_firmware(struct v4l2_subdev *sd)
 		return ret;
 
 	/* Wait 1ms for PLL to lock. */
-	msleep(1);
+	msleep(20);
 
 	/* Load the rest of bootdata content. */
 	ret = ap1302_write_fw_window(sd, &win_pos, fw_data + fw->pll_init_size,
@@ -571,7 +572,7 @@ static int ap1302_match_resolution(struct ap1302_context_res *res,
 		mismatch = abs(w0 * h1 - w1 * h0) * 8192 / w1 / h0;
 		if (mismatch > 8192 * AP1302_MAX_RATIO_MISMATCH / 100)
 			continue;
-		distance = (w0 *h1 + w1 * h0) * 8192 / w1 / h1;
+		distance = (w0 * h1 + w1 * h0) * 8192 / w1 / h1;
 		if (distance < min_distance) {
 			min_distance = distance;
 			idx = i;
@@ -641,7 +642,7 @@ static int ap1302_set_mbus_fmt(struct v4l2_subdev *sd,
 	struct ap1302_device *dev = to_ap1302_device(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct atomisp_input_stream_info *stream_info =
-		(struct atomisp_input_stream_info*)fmt->reserved;
+		(struct atomisp_input_stream_info *)fmt->reserved;
 	enum ap1302_contexts context, main_context;
 
 	mutex_lock(&dev->input_lock);
@@ -862,7 +863,8 @@ static int ap1302_s_stream(struct v4l2_subdev *sd, int enable)
 
 	mutex_lock(&dev->input_lock);
 	context = ap1302_get_context(sd);
-	dev_dbg(&client->dev, "ap1302_s_stream. context=%d enable=%d\n", context, enable);
+	dev_dbg(&client->dev, "ap1302_s_stream. context=%d enable=%d\n",
+			context, enable);
 	/* Switch context */
 	ap1302_i2c_read_reg(sd, REG_CTRL,
 			    AP1302_REG16, &reg_val);
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
index 4c104aa..acb59c7 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
@@ -279,7 +279,7 @@ static int gc2235_get_intg_factor(struct i2c_client *client,
 	ret =  gc2235_read_reg(client, GC2235_8BIT,
 					GC2235_H_CROP_START_H, &reg_val_h);
 	ret =  gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_H_CROP_START_L, &reg_val);
+					GC2235_H_CROP_START_L, &reg_val);
 	if (ret)
 		return ret;
 
@@ -288,7 +288,7 @@ static int gc2235_get_intg_factor(struct i2c_client *client,
 	ret =  gc2235_read_reg(client, GC2235_8BIT,
 					GC2235_V_CROP_START_H, &reg_val_h);
 	ret =  gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_V_CROP_START_L, &reg_val);
+					GC2235_V_CROP_START_L, &reg_val);
 	if (ret)
 		return ret;
 
@@ -297,7 +297,7 @@ static int gc2235_get_intg_factor(struct i2c_client *client,
 	ret = gc2235_read_reg(client, GC2235_8BIT,
 					GC2235_H_OUTSIZE_H, &reg_val_h);
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_H_OUTSIZE_L, &reg_val);
+					GC2235_H_OUTSIZE_L, &reg_val);
 	if (ret)
 		return ret;
 	buf->output_width = ((u16)reg_val_h << 8) | (u16)reg_val;
@@ -305,7 +305,7 @@ static int gc2235_get_intg_factor(struct i2c_client *client,
 	ret = gc2235_read_reg(client, GC2235_8BIT,
 					GC2235_V_OUTSIZE_H, &reg_val_h);
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_V_OUTSIZE_L, &reg_val);
+					GC2235_V_OUTSIZE_L, &reg_val);
 	if (ret)
 		return ret;
 	buf->output_height = ((u16)reg_val_h << 8) | (u16)reg_val;
@@ -318,23 +318,23 @@ static int gc2235_get_intg_factor(struct i2c_client *client,
 	ret = gc2235_read_reg(client, GC2235_8BIT,
 					GC2235_HB_H, &reg_val_h);
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_HB_L, &reg_val);
+					GC2235_HB_L, &reg_val);
 	if (ret)
 		return ret;
 
 	dummy = ((u16)reg_val_h << 8) | (u16)reg_val;
 
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_SH_DELAY_H, &reg_val_h);
+					GC2235_SH_DELAY_H, &reg_val_h);
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_SH_DELAY_L, &reg_val);
+					GC2235_SH_DELAY_L, &reg_val);
 
 	buf->line_length_pck = buf->output_width + 16 + dummy +
 				(((u16)reg_val_h << 8) | (u16)reg_val) + 4;
 	ret = gc2235_read_reg(client, GC2235_8BIT,
 					GC2235_VB_H, &reg_val_h);
 	ret = gc2235_read_reg(client, GC2235_8BIT,
-                                        GC2235_VB_L, &reg_val);
+					GC2235_VB_L, &reg_val);
 	if (ret)
 		return ret;
 
@@ -354,7 +354,7 @@ static long __gc2235_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	u16 coarse_integration = (u16)coarse_itg;
 	int ret = 0;
-	u16 expo_coarse_h,expo_coarse_l, gain_val = 0xF0, gain_val2 = 0xF0;
+	u16 expo_coarse_h, expo_coarse_l, gain_val = 0xF0, gain_val2 = 0xF0;
 	expo_coarse_h = coarse_integration>>8;
 	expo_coarse_l = coarse_integration & 0xff;
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
index 2a35791..5ef9894 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
@@ -98,8 +98,8 @@
 #define GC2235_H_CROP_START_L		0x94
 #define GC2235_V_OUTSIZE_H		0x95
 #define GC2235_V_OUTSIZE_L		0x96
-#define GC2235_H_OUTSIZE_H 		0x97
-#define GC2235_H_OUTSIZE_L 		0x98
+#define GC2235_H_OUTSIZE_H		0x97
+#define GC2235_H_OUTSIZE_L		0x98
 
 #define GC2235_HB_H			0x5
 #define GC2235_HB_L			0x6
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
index f6c2e46..2ff7d15 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
@@ -109,7 +109,7 @@ int ad5816g_vcm_power_up(struct v4l2_subdev *sd)
 	  * t1(1ms) -Time from VDD high to first i2c cmd
 	  * t2(100us) - exit power-down mode time
 	  */
-	usleep_range(1100, 1100);
+	usleep_range(1100, 2200);
 	/* Detect device */
 	ret = ad5816g_i2c_rd8(client, AD5816G_IC_INFO, &ad5816g_id);
 	if (ret < 0)
@@ -203,7 +203,7 @@ int ad5816g_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 	if (val & ATOMISP_FOCUS_STATUS_MOVING)
 		*value  = ad5816g_dev.focus - ad5816g_dev.number_of_steps;
 	else
-		*value  = ad5816g_dev.focus ;
+		*value = ad5816g_dev.focus;
 
 	return 0;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
index 34afa83..4369f01 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
@@ -196,7 +196,7 @@ int drv201_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 	if (val & ATOMISP_FOCUS_STATUS_MOVING)
 		*value  = drv201_dev.focus - drv201_dev.number_of_steps;
 	else
-		*value  = drv201_dev.focus ;
+		*value  = drv201_dev.focus;
 
 	return 0;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
index 1177b82..d7282df 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
@@ -189,7 +189,7 @@ int dw9714_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 	if (val & ATOMISP_FOCUS_STATUS_MOVING)
 		*value  = dw9714_dev.focus - dw9714_dev.number_of_steps;
 	else
-		*value  = dw9714_dev.focus ;
+		*value  = dw9714_dev.focus;
 
 	return 0;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
index 5d22466..8020bb3 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
@@ -181,7 +181,7 @@ int dw9718_t_focus_rel(struct v4l2_subdev *sd, s32 value)
 
 int dw9718_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 {
-	*value  = dw9718_dev.focus ;
+	*value  = dw9718_dev.focus;
 	return 0;
 }
 int dw9718_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
index f33511f..ae1a0f0 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
@@ -56,6 +56,6 @@ struct dw9718_device {
 
 #define DW9718_SACT_MULT_TWO		0x00
 #define DW9718_SACT_PERIOD_8_8MS	0x19
-#define DW9718_SACT_DEFAULT_VAL 	0x60
+#define DW9718_SACT_DEFAULT_VAL		0x60
 
 #endif /* __DW9718_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c
index ce149f4..eca2d76 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c
@@ -189,7 +189,7 @@ int dw9719_t_focus_rel(struct v4l2_subdev *sd, s32 value)
 
 int dw9719_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 {
-	*value  = dw9719_dev.focus ;
+	*value = dw9719_dev.focus;
 	return 0;
 }
 int dw9719_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
index fb875c8..caafcc4 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
@@ -51,7 +51,8 @@
  * line 0 effective data size(byte): 76
  * line 1 effective data size(byte): 113
  */
-static const uint32_t imx135_embedded_effective_size[IMX135_EMBEDDED_DATA_LINE_NUM]
+static const uint32_t
+	imx135_embedded_effective_size[IMX135_EMBEDDED_DATA_LINE_NUM]
 	=  {76, 113};
 
 static enum atomisp_bayer_order imx_bayer_order_mapping[] = {
@@ -1140,11 +1141,13 @@ static int imx_s_ctrl(struct v4l2_ctrl *ctrl)
 		ret = imx_test_pattern(&dev->sd);
 		break;
 	case V4L2_CID_VFLIP:
-		dev_dbg(&client->dev, "%s: CID_VFLIP:%d.\n", __func__, ctrl->val);
+		dev_dbg(&client->dev, "%s: CID_VFLIP:%d.\n",
+			__func__, ctrl->val);
 		ret = imx_v_flip(&dev->sd, ctrl->val);
 		break;
 	case V4L2_CID_HFLIP:
-		dev_dbg(&client->dev, "%s: CID_HFLIP:%d.\n", __func__, ctrl->val);
+		dev_dbg(&client->dev, "%s: CID_HFLIP:%d.\n",
+			__func__, ctrl->val);
 		ret = imx_h_flip(&dev->sd, ctrl->val);
 		break;
 	case V4L2_CID_FOCUS_ABSOLUTE:
@@ -1654,7 +1657,8 @@ static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
 	res = &dev->curr_res_table[dev->fmt_idx];
 
 	/* Adjust the FPS selection based on the resolution selected */
-	dev->fps_index = __imx_nearest_fps_index(dev->targetfps, res->fps_options);
+	dev->fps_index = __imx_nearest_fps_index(dev->targetfps,
+						res->fps_options);
 	dev->fps = res->fps_options[dev->fps_index].fps;
 	dev->regs = res->fps_options[dev->fps_index].regs;
 	if (!dev->regs)
@@ -1718,7 +1722,8 @@ static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
 	 */
 	switch (dev->sensor_id) {
 	case IMX135_ID:
-		ret = imx_read_reg(client, 2, IMX135_OUTPUT_DATA_FORMAT_REG, &data);
+		ret = imx_read_reg(client, 2,
+				IMX135_OUTPUT_DATA_FORMAT_REG, &data);
 		if (ret)
 			goto out;
 		/*
@@ -1788,7 +1793,8 @@ static int imx_detect(struct i2c_client *client, u16 *id, u8 *revision)
 		return -ENODEV;
 	}
 
-	if (*id == IMX132_ID || *id == IMX175_ID || *id == IMX208_ID || *id == IMX219_ID)
+	if (*id == IMX132_ID || *id == IMX175_ID ||
+		*id == IMX208_ID || *id == IMX219_ID)
 		goto found;
 
 	if (imx_read_reg(client, IMX_16BIT, IMX134_135_CHIP_ID, id)) {
@@ -1930,7 +1936,8 @@ static int imx_enum_frameintervals(struct v4l2_subdev *sd,
 	fival->width = dev->curr_res_table[i].width;
 	fival->height = dev->curr_res_table[i].height;
 	fival->discrete.numerator = 1;
-	fival->discrete.denominator = dev->curr_res_table[i].fps_options[index].fps;
+	fival->discrete.denominator =
+			dev->curr_res_table[i].fps_options[index].fps;
 	mutex_unlock(&dev->input_lock);
 	return 0;
 out:
@@ -2265,15 +2272,17 @@ static int __imx_s_frame_interval(struct v4l2_subdev *sd,
 		 * with current setting, not use this one, as may have
 		 * unexpected result, e.g. PLL, IQ.
 		 */
-		dev_dbg(&client->dev, "Sensor is streaming, not apply new sensor setting\n");
+		dev_dbg(&client->dev,
+			"Sensor is streaming, not apply new sensor setting\n");
 		if (fps > res->fps_options[dev->fps_index].fps) {
 			/*
 			 * Does not support increase fps based on low fps
 			 * setting, as the high fps setting could not be used,
 			 * and fps requested is above current setting fps.
 			 */
-			dev_warn(&client->dev, "Could not support fps: %d, keep current: %d.\n",
-					fps, dev->fps);
+			dev_warn(&client->dev,
+			"Could not support fps: %d, keep current: %d.\n",
+			fps, dev->fps);
 			return 0;
 		}
 	} else {
@@ -2305,9 +2314,9 @@ static int __imx_s_frame_interval(struct v4l2_subdev *sd,
 		 * 2: consider use pixel per line for more range?
 		 */
 		if (dev->lines_per_frame * dev->fps / fps >
-				MAX_LINES_PER_FRAME) {
+			MAX_LINES_PER_FRAME) {
 			dev_warn(&client->dev,
-					"adjust lines_per_frame out of range, try to use max value.\n");
+		"adjust lines_per_frame out of range, try to use max value.\n");
 			lines_per_frame = MAX_LINES_PER_FRAME;
 		} else {
 			lines_per_frame = lines_per_frame * dev->fps / fps;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
index dd8f642..43ea32a 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
@@ -217,7 +217,7 @@ struct imx_vcm {
 };
 
 struct imx_otp {
-	void *(*otp_read)(struct v4l2_subdev *sd, u8 dev_addr,
+	void * (*otp_read)(struct v4l2_subdev *sd, u8 dev_addr,
 		u32 start_addr, u32 size);
 	u32 start_addr;
 	u32 size;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
index e906d09..f7f94b8 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
@@ -1909,12 +1909,12 @@ struct imx_resolution imx134_res_still[] = {
 		.width = 3280,
 		.height = 2464,
 		.fps_options = {
-                        {
+			{
 				/* WORKAROUND for FW performance limitation */
-                                 .fps = 8,
-                                 .pixels_per_line = 6400,
-                                 .lines_per_frame = 5312,
-                        },
+				 .fps = 8,
+				 .pixels_per_line = 6400,
+				 .lines_per_frame = 5312,
+			},
 			{
 				 .fps = 30,
 				 .pixels_per_line = 3600,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c
index 0236089..d0fa66a 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c
@@ -146,7 +146,8 @@ int imx_t_focus_abs(struct v4l2_subdev *sd, s32 value)
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
 	value = clamp(value, 0, DW9719_MAX_FOCUS_POS);
-	ret = dw9719_i2c_wr16(client, DW9719_VCM_CURRENT, DW9719_MAX_FOCUS_POS - value);
+	ret = dw9719_i2c_wr16(client, DW9719_VCM_CURRENT,
+				DW9719_MAX_FOCUS_POS - value);
 	if (ret < 0)
 		return ret;
 	getnstimeofday(&dw9719_dev.focus_time);
@@ -161,7 +162,7 @@ int imx_t_focus_rel(struct v4l2_subdev *sd, s32 value)
 
 int imx_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 {
-	*value  = dw9719_dev.focus ;
+	*value = dw9719_dev.focus;
 	return 0;
 }
 int imx_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
index 04a122f..165766d 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
@@ -37,8 +37,8 @@
 
 struct lm3554_ctrl_id {
 	struct v4l2_queryctrl qc;
-	int (*s_ctrl) (struct v4l2_subdev *sd, __u32 val);
-	int (*g_ctrl) (struct v4l2_subdev *sd, __s32 *val);
+	int (*s_ctrl)(struct v4l2_subdev *sd, __u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, __s32 *val);
 };
 
 /* Registers */
@@ -404,7 +404,7 @@ static int lm3554_s_flash_mode(struct v4l2_subdev *sd, u32 new_mode)
 	return lm3554_set_mode(flash, mode);
 }
 
-static int lm3554_g_flash_mode(struct v4l2_subdev *sd, s32 * val)
+static int lm3554_g_flash_mode(struct v4l2_subdev *sd, s32 *val)
 {
 	struct lm3554 *flash = to_lm3554(sd);
 	*val = flash->mode;
@@ -828,12 +828,15 @@ void *lm3554_platform_data_func(struct i2c_client *client)
 
 	if (ACPI_COMPANION(&client->dev)) {
 		platform_data.gpio_reset  =
-			desc_to_gpio(gpiod_get_index(&(client->dev), "lm3554_gpio2", 2));
+			desc_to_gpio(gpiod_get_index(&(client->dev),
+							"lm3554_gpio2", 2));
 		platform_data.gpio_strobe =
-			desc_to_gpio(gpiod_get_index(&(client->dev), "lm3554_gpio0", 0));
+			desc_to_gpio(gpiod_get_index(&(client->dev),
+							"lm3554_gpio0", 0));
 		platform_data.gpio_torch  =
-			desc_to_gpio(gpiod_get_index(&(client->dev), "lm3554_gpio1", 1));
-	}else {
+			desc_to_gpio(gpiod_get_index(&(client->dev),
+							"lm3554_gpio1", 1));
+	} else {
 		platform_data.gpio_reset = -1;
 		platform_data.gpio_strobe = -1;
 		platform_data.gpio_torch = -1;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
index 8a7578e..85b0b61 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
@@ -33,8 +33,8 @@
 
 struct lm3559_ctrl_id {
 	struct v4l2_queryctrl qc;
-	int (*s_ctrl) (struct v4l2_subdev *sd, __u32 val);
-	int (*g_ctrl) (struct v4l2_subdev *sd, __s32 *val);
+	int (*s_ctrl)(struct v4l2_subdev *sd, __u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, __s32 *val);
 };
 
 /* Registers */
@@ -729,7 +729,7 @@ static int __lm3559_s_power(struct lm3559 *flash, int power)
 	}
 	gpio_set_value(pdata->gpio_reset, power);
 	gpio_free(pdata->gpio_reset);
-	usleep_range(100, 100);
+	usleep_range(100, 100 + 1);
 
 	if (power) {
 		/* Setup default values. This makes sure that the chip
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3642.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3642.c
index 38cc1b6..3cc1df6 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/lm3642.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3642.c
@@ -33,8 +33,8 @@
 
 struct lm3642_ctrl_id {
 	struct v4l2_queryctrl qc;
-	int (*s_ctrl) (struct v4l2_subdev *sd, __u32 val);
-	int (*g_ctrl) (struct v4l2_subdev *sd, __s32 *val);
+	int (*s_ctrl)(struct v4l2_subdev *sd, __u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, __s32 *val);
 };
 
 /* Registers */
@@ -365,7 +365,7 @@ static int lm3642_s_flash_mode(struct v4l2_subdev *sd, u32 new_mode)
 	return lm3642_set_mode(flash, mode);
 }
 
-static int lm3642_g_flash_mode(struct v4l2_subdev *sd, s32 * val)
+static int lm3642_g_flash_mode(struct v4l2_subdev *sd, s32 *val)
 {
 	struct lm3642 *flash = to_lm3642(sd);
 	*val = flash->mode;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
index 4260578..f61e9557 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
@@ -58,7 +58,8 @@ MODULE_PARM_DESC(dbglvl, "debug message on/off (default:off)");
  * Returns 0 on success, or else negative errno.
 */
 
-static int m10mo_read(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 *val)
+static int m10mo_read(struct v4l2_subdev *sd, u8 len,
+			u8 category, u8 reg, u32 *val)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	unsigned char data[5];
@@ -83,7 +84,7 @@ static int m10mo_read(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 *
 	data[1] = M10MO_BYTE_READ;
 	data[2] = category;
 	data[3] = reg;
-        data[4] = len;
+	data[4] = len;
 
 	msg[1].addr = client->addr;
 	msg[1].flags = I2C_M_RD;
@@ -91,7 +92,8 @@ static int m10mo_read(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 *
 	msg[1].buf = recv_data;
 
 	/* isp firmware becomes stable during this time*/
-	usleep_range(200, 200);
+	/*usleep_range should not use min == max args*/
+	usleep_range(200, 200 + 1);
 
 	ret = i2c_transfer(client->adapter, msg, 2);
 
@@ -119,7 +121,8 @@ static int m10mo_read(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 *
  *
  * Returns 0 on success, or else negative errno.
  */
-static int m10mo_write(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 val)
+static int m10mo_write(struct v4l2_subdev *sd, u8 len,
+			u8 category, u8 reg, u32 val)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	u8 data[len + 4];
@@ -168,11 +171,13 @@ static int m10mo_write(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32
 	}
 
 	/* isp firmware becomes stable during this time*/
-	usleep_range(200, 200);
+	/*usleep_range should not use min == max args*/
+	usleep_range(200, 200 + 1);
 
 	ret = i2c_transfer(client->adapter, &msg, 1);
 
-	dev_dbg(&client->dev, "Write reg. Category=0x%02X Reg=0x%02X Value=0x%X ret=%s\n",
+	dev_dbg(&client->dev,
+		"Write reg. Category=0x%02X Reg=0x%02X Value=0x%X ret=%s\n",
 		category, reg, val, (ret == 1) ? "OK" : "Error");
 	return ret == num_msg ? 0 : -EIO;
 }
@@ -207,7 +212,8 @@ int m10mo_readl(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val)
 	return m10mo_read(sd, 4, category, reg, val);
 }
 
-int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *val)
+int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd,
+			u16 len, u32 addr, u8 *val)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct m10mo_device *m10mo_dev =  to_m10mo_sensor(sd);
@@ -215,7 +221,8 @@ int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *va
 	u8 *data = m10mo_dev->message_buffer;
 	int i, ret;
 
-	dev_dbg(&client->dev, "Write mem. cmd=0x%02X len=%d addr=0x%X\n", cmd, len, addr);
+	dev_dbg(&client->dev, "Write mem. cmd=0x%02X len=%d addr=0x%X\n",
+		cmd, len, addr);
 
 	if (!client->adapter)
 		return -ENODEV;
@@ -239,13 +246,13 @@ int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *va
 	/* Payload starts at offset 8 */
 	memcpy(data + 8, val, len);
 
-	usleep_range(200, 200);
+	/*yuniang:usleep_range should not use min == max args*/
+	/*usleep_range(200, 200);*/
 
 	for (i = M10MO_I2C_RETRY; i; i--) {
 		ret = i2c_transfer(client->adapter, &msg, 1);
-		if (ret == 1) {
+		if (ret == 1)
 			return 0;
-		}
 		msleep(20);
 	}
 
@@ -365,7 +372,8 @@ int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode)
 	case M10MO_FLASH_WRITE_MODE:
 		break;
 	case M10MO_PARAM_SETTING_MODE:
-		ret = m10mo_write(sd, 1, CATEGORY_FLASHROM, FLASH_CAM_START, 0x01);
+		ret = m10mo_write(sd, 1, CATEGORY_FLASHROM,
+						FLASH_CAM_START, 0x01);
 		if (ret < 0)
 			dev_err(&client->dev,
 				"Unable to change to PARAM_SETTING_MODE\n");
@@ -383,7 +391,7 @@ int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode)
 		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x02);
 		if (ret < 0)
 			dev_err(&client->dev,
-				"Unable to change to MONITOR_MODE / ZSL \n");
+				"Unable to change to MONITOR_MODE / ZSL\n");
 		break;
 	case M10MO_SINGLE_CAPTURE_MODE:
 		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x03);
@@ -463,7 +471,7 @@ static int m10mo_set_monitor_parameters(struct v4l2_subdev *sd)
 			   dev->monitor_params.exe_mode);
 
 	if (ret)
-	    return ret;
+		return ret;
 
 	if (dev->monitor_params.flash_mode == LED_TORCH)
 		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
@@ -520,13 +528,13 @@ static int m10mo_detect(struct v4l2_subdev *sd)
 	struct m10mo_version *ver = &dev->ver;
 	int ret;
 
-        ret = m10mo_read(sd, 1, CATEGORY_SYSTEM, SYSTEM_CUSTOMER_CODE,
+	ret = m10mo_read(sd, 1, CATEGORY_SYSTEM, SYSTEM_CUSTOMER_CODE,
 			&ver->customer);
 	if (!ret)
 		ret = m10mo_read(sd, 1, CATEGORY_SYSTEM, SYSTEM_PROJECT_CODE,
 				&ver->project);
-	dev_info(&client->dev, "Customer/Project[0x%x/0x%x]\n", dev->ver.customer,
-				dev->ver.project);
+	dev_info(&client->dev, "Customer/Project[0x%x/0x%x]\n",
+			dev->ver.customer, dev->ver.project);
 	return 0;
 }
 
@@ -596,19 +604,24 @@ static int m10mo_set_af_mode(struct v4l2_subdev *sd, unsigned int val)
 		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_touch;
 		break;
 	case EXT_ISP_FOCUS_MODE_PREVIEW_CAF:
-		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_preview_caf;
+		dev->monitor_params.af_mode =
+				m10m0_af_parameters[id].af_preview_caf;
 		break;
 	case EXT_ISP_FOCUS_MODE_MOVIE_CAF:
-		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_movie_caf;
+		dev->monitor_params.af_mode =
+				m10m0_af_parameters[id].af_movie_caf;
 		break;
 	case EXT_ISP_FOCUS_MODE_FACE_CAF:
-		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_face_caf;
+		dev->monitor_params.af_mode =
+				m10m0_af_parameters[id].af_face_caf;
 		break;
 	case EXT_ISP_FOCUS_MODE_TOUCH_MACRO:
-		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_touch_macro;
+		dev->monitor_params.af_mode =
+				m10m0_af_parameters[id].af_touch_macro;
 		break;
 	case EXT_ISP_FOCUS_MODE_TOUCH_CAF:
-		dev->monitor_params.af_mode = m10m0_af_parameters[id].af_touch_caf;
+		dev->monitor_params.af_mode =
+				m10m0_af_parameters[id].af_touch_caf;
 		break;
 	default:
 		return -EINVAL;
@@ -652,10 +665,12 @@ static int m10mo_set_af_execution(struct v4l2_subdev *sd, s32 val)
 		dev->monitor_params.exe_mode = m10m0_af_parameters[id].af_stop;
 		break;
 	case EXT_ISP_FOCUS_SEARCH:
-		dev->monitor_params.exe_mode = m10m0_af_parameters[id].af_search;
+		dev->monitor_params.exe_mode =
+				m10m0_af_parameters[id].af_search;
 		break;
 	case EXT_ISP_PAN_FOCUSING:
-		dev->monitor_params.exe_mode = m10m0_af_parameters[id].af_pan_focusing;
+		dev->monitor_params.exe_mode =
+				m10m0_af_parameters[id].af_pan_focusing;
 		break;
 	default:
 		return -EINVAL;
@@ -663,7 +678,8 @@ static int m10mo_set_af_execution(struct v4l2_subdev *sd, s32 val)
 
 	if (is_m10mo_in_monitor_mode(sd)) {
 
-		dev_info(&client->dev, "%s: In monitor mode, set AF exe_mode to %d",
+		dev_info(&client->dev,
+			"%s: In monitor mode, set AF exe_mode to %d",
 			 __func__, dev->monitor_params.exe_mode);
 
 		/* We are in monitor mode already, */
@@ -735,39 +751,38 @@ static u32 m10mo_af_parameter_transform(struct v4l2_subdev *sd, u32 val)
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int id = M10MO_GET_FOCUS_MODE(dev->fw_type);
 
-	if (val == m10m0_af_parameters[id].caf_status_focusing) {
+	if (val == m10m0_af_parameters[id].caf_status_focusing)
 		ret = CAF_STATUS_FOCUSING;
-	} else if (val == m10m0_af_parameters[id].caf_status_success) {
+	else if (val == m10m0_af_parameters[id].caf_status_success)
 		ret = CAF_STATUS_SUCCESS;
-	} else if (val == m10m0_af_parameters[id].caf_status_fail) {
+	else if (val == m10m0_af_parameters[id].caf_status_fail)
 		ret = CAF_STATUS_FAIL;
-	} else if (val == m10m0_af_parameters[id].caf_status_restart_check) {
+	else if (val == m10m0_af_parameters[id].caf_status_restart_check)
 		ret = CAF_STATUS_RESTART_CHECK;
-	} else if (val == m10m0_af_parameters[id].af_status_invalid) {
+	else if (val == m10m0_af_parameters[id].af_status_invalid)
 		ret = AF_STATUS_INVALID;
-	} else if (val == m10m0_af_parameters[id].af_status_focusing) {
+	else if (val == m10m0_af_parameters[id].af_status_focusing)
 		ret = AF_STATUS_FOCUSING;
-	} else if (val == m10m0_af_parameters[id].af_status_success) {
+	else if (val == m10m0_af_parameters[id].af_status_success)
 		ret = AF_STATUS_SUCCESS;
-	} else if (val == m10m0_af_parameters[id].af_status_fail) {
+	else if (val == m10m0_af_parameters[id].af_status_fail)
 		ret = AF_STATUS_FAIL;
-	} else if (val == m10m0_af_parameters[id].af_normal) {
+	else if (val == m10m0_af_parameters[id].af_normal)
 		ret = AF_NORMAL;
-	} else if (val == m10m0_af_parameters[id].af_macro) {
+	else if (val == m10m0_af_parameters[id].af_macro)
 		ret = AF_MACRO;
-	} else if (val == m10m0_af_parameters[id].af_touch) {
+	else if (val == m10m0_af_parameters[id].af_touch)
 		ret = AF_TOUCH;
-	} else if (val == m10m0_af_parameters[id].af_preview_caf) {
+	else if (val == m10m0_af_parameters[id].af_preview_caf)
 		ret = AF_PREVIEW_CAF;
-	} else if (val == m10m0_af_parameters[id].af_movie_caf) {
+	else if (val == m10m0_af_parameters[id].af_movie_caf)
 		ret = AF_MOVIE_CAF;
-	} else if (val == m10m0_af_parameters[id].af_face_caf) {
+	else if (val == m10m0_af_parameters[id].af_face_caf)
 		ret = AF_FACE_CAF;
-	} else if (val == m10m0_af_parameters[id].af_touch_macro) {
+	else if (val == m10m0_af_parameters[id].af_touch_macro)
 		ret = AF_TOUCH_MACRO;
-	} else if (val == m10m0_af_parameters[id].af_touch_caf) {
+	else if (val == m10m0_af_parameters[id].af_touch_caf)
 		ret = AF_TOUCH_CAF;
-	}
 
 	return ret;
 }
@@ -893,7 +908,8 @@ static int m10mo_set_flash_mode(struct v4l2_subdev *sd, unsigned int val)
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 
-	/* by default force the torch off, value depends on incoming flash mode */
+	/* by default force the torch off,
+	value depends on incoming flash mode */
 	dev->monitor_params.torch = LED_TORCH_OFF;
 
 	switch (val) {
@@ -925,8 +941,8 @@ static int m10mo_set_flash_mode(struct v4l2_subdev *sd, unsigned int val)
 	dev_info(&client->dev, "%s: In monitor mode, set flash mode to %d",
 		 __func__, dev->monitor_params.flash_mode);
 
-	/* TODO get current flash mode, and apply new setting only when needed? */
-
+	/* TODO get current flash mode,
+	and apply new setting only when needed? */
 	if (dev->monitor_params.flash_mode == LED_TORCH)
 		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LED_TORCH,
 				   dev->monitor_params.torch);
@@ -1199,7 +1215,8 @@ int m10mo_set_zsl_monitor(struct v4l2_subdev *sd)
 
 	/* Set shot mode */
 	if (shot_mode_support) {
-		ret = m10mo_writeb(sd, CATEGORY_PARAM, SHOT_MODE, dev->shot_mode);
+		ret = m10mo_writeb(sd, CATEGORY_PARAM,
+					SHOT_MODE, dev->shot_mode);
 		if (ret)
 			goto out;
 	}
@@ -1244,7 +1261,7 @@ out:
 
 static u32 __get_dual_capture_value(u8 capture_mode)
 {
-	switch(capture_mode) {
+	switch (capture_mode) {
 	case M10MO_CAPTURE_MODE_ZSL_BURST:
 		return DUAL_CAPTURE_BURST_CAPTURE_START;
 	case M10MO_CAPTURE_MODE_ZSL_LLS:
@@ -1278,19 +1295,21 @@ static int m10mo_set_zsl_capture(struct v4l2_subdev *sd, int sel_frame)
 		if (ret)
 			continue;
 
-		if ((dual_status == 0) || (dual_status == DUAL_STATUS_AF_WORKING)) {
+		if ((dual_status == 0) ||
+			(dual_status == DUAL_STATUS_AF_WORKING)) {
 			finish = 1;
 			break;
 		}
 
-		msleep(10);
+		msleep(20);
 	}
 
 	/*
 	* If last capture not finished yet, return error code
 	*/
 	if (!finish) {
-		dev_err(&client->dev, "%s Device busy. Status check failed %d\n",
+		dev_err(&client->dev,
+			"%s Device busy. Status check failed %d\n",
 			__func__, dual_status);
 		return -EBUSY;
 	}
@@ -1342,7 +1361,7 @@ int m10mo_set_burst_mode(struct v4l2_subdev *sd, unsigned int val)
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int ret = 0;
 
-	switch(val) {
+	switch (val) {
 	case EXT_ISP_BURST_CAPTURE_CTRL_START:
 		/* First check if already in ZSL monitor mode. If not start */
 		if (dev->mode != M10MO_MONITOR_MODE_ZSL) {
@@ -1376,7 +1395,7 @@ static int m10mo_set_lls_mode(struct v4l2_subdev *sd, unsigned int val)
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int ret;
 
-	switch(val) {
+	switch (val) {
 	case STOP_LLS_MODE:
 		/* switch to normal capture. HDR MODE off */
 		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, REG_CAP_NV12_MODE,
@@ -1410,7 +1429,7 @@ static int m10mo_set_hdr_mode(struct v4l2_subdev *sd, unsigned int val)
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	int ret;
 
-	switch(val) {
+	switch (val) {
 	case STOP_HDR_MODE:
 		/* switch to normal capture. HDR MODE off */
 		ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, REG_CAP_NV12_MODE,
@@ -1556,32 +1575,28 @@ static irqreturn_t m10mo_irq_thread(int irq, void *dev_id)
 		if (dev->mode == M10MO_POWERING_ON)
 			dev->mode = M10MO_FLASH_WRITE_MODE;
 		else
-			dev_err(&client->dev, "Illegal flash write mode request\n");
+			dev_err(&client->dev,
+				"Illegal flash write mode request\n");
 		break;
 	case M10MO_PARAM_SETTING_MODE:
-		if (int_factor & REG_INT_STATUS_MODE) {
+		if (int_factor & REG_INT_STATUS_MODE)
 			dev->mode = M10MO_PARAM_SETTING_MODE;
-		}
 		break;
 	case M10MO_PARAMETER_MODE:
-		if (int_factor & REG_INT_STATUS_MODE) {
+		if (int_factor & REG_INT_STATUS_MODE)
 			dev->mode = M10MO_PARAMETER_MODE;
-		}
 		break;
 	case M10MO_MONITOR_MODE:
-		if (int_factor & REG_INT_STATUS_MODE) {
+		if (int_factor & REG_INT_STATUS_MODE)
 			dev->mode = M10MO_MONITOR_MODE;
-		}
 		break;
 	case M10MO_MONITOR_MODE_ZSL:
-		if (int_factor & REG_INT_STATUS_MODE) {
+		if (int_factor & REG_INT_STATUS_MODE)
 			dev->mode = M10MO_MONITOR_MODE_ZSL;
-		}
 		break;
 	case M10MO_MONITOR_MODE_PANORAMA:
-		if (int_factor & REG_INT_STATUS_MODE) {
+		if (int_factor & REG_INT_STATUS_MODE)
 			dev->mode = M10MO_MONITOR_MODE_PANORAMA;
-		}
 		break;
 	case M10MO_SINGLE_CAPTURE_MODE:
 		if (int_factor & REG_INT_STATUS_CAPTURE) {
@@ -1594,9 +1609,8 @@ static irqreturn_t m10mo_irq_thread(int irq, void *dev_id)
 			dev->mode = M10MO_BURST_CAPTURE_MODE;
 		break;
 	case M10MO_MONITOR_MODE_HIGH_SPEED:
-		if (int_factor & REG_INT_STATUS_MODE) {
+		if (int_factor & REG_INT_STATUS_MODE)
 			dev->mode = M10MO_MONITOR_MODE_HIGH_SPEED;
-		}
 		break;
 	default:
 		return IRQ_HANDLED;
@@ -1756,7 +1770,7 @@ int __m10mo_update_stream_info(struct v4l2_subdev *sd,
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	struct atomisp_input_stream_info *stream_info =
-			(struct atomisp_input_stream_info*)fmt->reserved;
+			(struct atomisp_input_stream_info *)fmt->reserved;
 	int mode = M10MO_GET_RESOLUTION_MODE(dev->fw_type);
 
 	/* TODO: Define a FW Type as well. Resolution could be reused */
@@ -1903,9 +1917,9 @@ static int m10mo_identify_fw_type(struct v4l2_subdev *sd)
 
 		while (fw_ids->id_string) {
 			if (!strncmp(fw_ids->id_string, buffer,
-				     strlen(fw_ids->id_string)))
-			{
-				dev_info(&client->dev, "FW id %s detected\n", buffer);
+				     strlen(fw_ids->id_string))) {
+				dev_info(&client->dev,
+						"FW id %s detected\n", buffer);
 				dev->fw_type = fw_ids->fw_type;
 				dev->fw_addr_id = i;
 				return 0;
@@ -2680,8 +2694,7 @@ static long m10mo_ioctl(struct v4l2_subdev *sd, unsigned int cmd,
 			m10mo_ctrl->id, m10mo_ctrl->data);
 
 	mutex_lock(&dev->input_lock);
-	switch(m10mo_ctrl->id)
-	{
+	switch (m10mo_ctrl->id) {
 	case EXT_ISP_CID_ISO:
 		dev_info(&client->dev, "m10mo ioctl ISO\n");
 		break;
@@ -2920,7 +2933,8 @@ static int __m10mo_init_ctrl_handler(struct m10mo_device *dev)
 	return 0;
 }
 
-static int m10mo_s_routing(struct v4l2_subdev *sd, u32 input, u32 output, u32 config)
+static int m10mo_s_routing(struct v4l2_subdev *sd, u32 input,
+					u32 output, u32 config)
 {
 	struct m10mo_device *dev = to_m10mo_sensor(sd);
 	struct atomisp_camera_caps *caps =
@@ -2944,7 +2958,8 @@ static int m10mo_s_frame_interval(struct v4l2_subdev *sd,
 
 	mutex_lock(&dev->input_lock);
 	if (interval->interval.numerator != 0)
-		fps = interval->interval.denominator / interval->interval.numerator;
+		fps = interval->interval.denominator /
+			interval->interval.numerator;
 	if (!fps) {
 		mutex_unlock(&dev->input_lock);
 		return -EINVAL;
@@ -3079,8 +3094,8 @@ static ssize_t m10mo_flash_rom_show(struct device *dev,
 }
 
 static ssize_t m10mo_flash_rom_store(struct device *dev,
-                                  struct device_attribute *attr,
-                                  const char *buf, size_t len)
+				  struct device_attribute *attr,
+				  const char *buf, size_t len)
 {
 	struct m10mo_device *m10mo_dev = dev_get_drvdata(dev);
 
@@ -3102,14 +3117,15 @@ static ssize_t m10mo_flash_spi_show(struct device *dev,
 }
 
 static ssize_t m10mo_flash_spi_store(struct device *dev,
-                                  struct device_attribute *attr,
-                                  const char *buf, size_t len)
+				  struct device_attribute *attr,
+				  const char *buf, size_t len)
 {
 	struct m10mo_device *m10mo_dev = dev_get_drvdata(dev);
 	unsigned long value;
 	int ret;
 
-	if (strict_strtoul(buf, 0, &value))
+	/*yunliang:strict_strtoul is obsolete, use kstrtoul instead*/
+	if (kstrtoul(buf, 0, &value))
 		return -EINVAL;
 
 	ret = m10mo_set_spi_state(m10mo_dev, value);
@@ -3219,7 +3235,7 @@ static int m10mo_ispd3(struct m10mo_device *dev)
 	/**ISP RESET**/
 	ret = dev->pdata->common.gpio_ctrl(sd, 0);
 
-	msleep(10);
+	msleep(20);
 
 	/**ISP RESET**/
 	ret = dev->pdata->common.gpio_ctrl(sd, 1);
@@ -3410,7 +3426,8 @@ static int m10mo_probe(struct i2c_client *client,
 		dev->num_lanes = mipi_info->num_lanes;
 
 	dev->curr_res_table = resolutions[0][M10MO_MODE_PREVIEW_INDEX];
-	dev->entries_curr_table = resolutions_sizes[0][M10MO_MODE_PREVIEW_INDEX];
+	dev->entries_curr_table =
+			resolutions_sizes[0][M10MO_MODE_PREVIEW_INDEX];
 
 	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
index bef19cd..297a347 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
@@ -35,8 +35,8 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-subdev.h>
 
-#define M10MO_NAME 			"m10mo"
-#define M10MO_ADDR   			0x1f
+#define M10MO_NAME			"m10mo"
+#define M10MO_ADDR			0x1f
 #define M10MO_I2C_RETRY			5
 #define M10MO_MIPI_FREQ_0			(963000000/2)
 #define M10MO_MIPI_FREQ_1			(980700000/2)
@@ -47,10 +47,10 @@
 #define M10MO_MIN_EV -2000
 #define M10MO_MAX_EV  3000
 #define M10MO_EV_STEP 500
-#define M10MO_FLICKER_AUTO 		0x00
-#define M10MO_FLICKER_50HZ 		0x01
-#define M10MO_FLICKER_60HZ 		0x02
-#define M10MO_FLICKER_OFF 		0x03
+#define M10MO_FLICKER_AUTO		0x00
+#define M10MO_FLICKER_50HZ		0x01
+#define M10MO_FLICKER_60HZ		0x02
+#define M10MO_FLICKER_OFF		0x03
 #define M10MO_METERING_CENTER		0x00
 #define M10MO_METERING_SPOT		0x01
 #define M10MO_METERING_AVERAGE		0x02
@@ -72,7 +72,7 @@
  * bits 31-16: numerator, bits 15-0: denominator
  */
 
-#define M10MO_F_NUMBER_DEFAULT 		0x16000a
+#define M10MO_F_NUMBER_DEFAULT		0x16000a
 
 /*
  * f-number range bits definition:
@@ -82,7 +82,7 @@
  * bits 7-0: min f-number denominator
  */
 
-#define M10MO_F_NUMBER_RANGE 		0x160a160a
+#define M10MO_F_NUMBER_RANGE		0x160a160a
 #define M10MO_FOCAL_LENGTH_NUM		369
 #define M10MO_FOCAL_LENGTH_DEM		100
 #define M10MO_F_NUMBER_DEFAULT_NUM	22
@@ -116,10 +116,10 @@
 
 #define M10MO_GET_CLOCK_RATE_MODE(arg)	((arg >> M10MO_CLOCK_RATE_MODE_OFFSET) & M10MO_MASK)
 #define M10MO_GET_MIPI_FREQ_MODE(arg)	((arg >> M10MO_MIPI_FREQ_MODE_OFFSET) & M10MO_MASK)
-#define M10MO_GET_FOCUS_MODE(arg)		((arg >> M10MO_AF_MODE_OFFSET) & M10MO_MASK)
+#define M10MO_GET_FOCUS_MODE(arg)	((arg >> M10MO_AF_MODE_OFFSET) & M10MO_MASK)
 #define M10MO_GET_RESOLUTION_MODE(arg)	((arg >> M10MO_RESOLUTION_MODE_OFFSET) & M10MO_MASK)
 #define M10MO_SHOT_MODES_SUPPORTED(arg)	(arg & M10MO_SHOT_MODE_SUPPORT)
-#define M10MO_GET_MIPI_PACKET_SIZE_IDX(arg) ((arg >> M10MO_MIPI_PACKET_SIZE_OFFSET) & M10MO_MASK)
+#define M10MO_GET_MIPI_PACKET_SIZE_IDX(arg)	((arg >> M10MO_MIPI_PACKET_SIZE_OFFSET) & M10MO_MASK)
 
 #define M10MO_METADATA_WIDTH	2048
 #define M10MO_METADATA_HEIGHT	4
@@ -168,13 +168,15 @@ struct m10mo_mipi_params {
 };
 
 struct m10mo_fw_ops {
-	int (*set_run_mode) (struct v4l2_subdev *sd);
-	int (*set_burst_mode) (struct v4l2_subdev *sd, unsigned int val);
-	int (*stream_off) (struct v4l2_subdev *sd);
-	int (*single_capture_process) (struct v4l2_subdev *sd);
-	int (*try_mbus_fmt) (struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt, bool update_fmt);
-	int (*set_mbus_fmt) (struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt);
-	int (*test_pattern) (struct v4l2_subdev *sd, u8 val);
+	int (*set_run_mode)(struct v4l2_subdev *sd);
+	int (*set_burst_mode)(struct v4l2_subdev *sd, unsigned int val);
+	int (*stream_off)(struct v4l2_subdev *sd);
+	int (*single_capture_process)(struct v4l2_subdev *sd);
+	int (*try_mbus_fmt)(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt, bool update_fmt);
+	int (*set_mbus_fmt)(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt);
+	int (*test_pattern)(struct v4l2_subdev *sd, u8 val);
 };
 
 struct m10mo_device {
@@ -219,13 +221,13 @@ struct m10mo_device {
 	u8 shot_mode;
 };
 
-enum hdr_options{
+enum hdr_options {
 	STOP_HDR_MODE,
 	START_HDR_MODE,
 	RESUME_PREVIEW_IN_HDR_MODE
 };
 
-enum lls_options{
+enum lls_options {
 	STOP_LLS_MODE,
 	START_LLS_MODE,
 	RESUME_PREVIEW_IN_LLS_MODE
@@ -234,7 +236,8 @@ enum lls_options{
 #define to_m10mo_sensor(x) container_of(x, struct m10mo_device, sd)
 
 int m10mo_memory_read(struct v4l2_subdev *sd, u16 len, u32 addr, u8 *val);
-int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *val);
+int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd,
+				u16 len, u32 addr, u8 *val);
 int m10mo_writeb(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val);
 int m10mo_writew(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val);
 int m10mo_writel(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val);
@@ -245,9 +248,12 @@ int m10mo_setup_flash_controller(struct v4l2_subdev *sd);
 int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode);
 int m10mo_wait_mode_change(struct v4l2_subdev *sd, u8 mode, u32 timeout);
 int __m10mo_param_mode_set(struct v4l2_subdev *sd);
-int __m10mo_update_stream_info(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt);
-int __m10mo_try_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt, bool update_fmt);
-int __m10mo_set_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *fmt);
+int __m10mo_update_stream_info(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt);
+int __m10mo_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt, bool update_fmt);
+int __m10mo_set_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt);
 int m10mo_test_pattern_start(struct v4l2_subdev *sd);
 
 int get_resolution_index(const struct m10mo_resolution *res,
@@ -364,9 +370,9 @@ extern const struct m10mo_fw_ops fw_type2_ops;
 #define MONITOR_COLOR_EFFECT	0x0b
 #define MONITOR_ZSL_MODE_STATUS	0x5f
 #define REG_NORMAL_MONITOR	0x00
-#define REG_ZSL_MONITOR 	0x01
+#define REG_ZSL_MONITOR	0x01
 #define ZSL_MODE		0x6e
-#define ZSL_INTERVAL 		0x6f
+#define ZSL_INTERVAL		0x6f
 
 #define COLOR_EFFECT_NONE	0x00
 #define COLOR_EFFECT_ON		0x01
@@ -402,10 +408,10 @@ extern const struct m10mo_fw_ops fw_type2_ops;
 /* In other type firmware movie mode is 0x00 */
 #define CAP_MODE_MOVIE		0x00
 
-#define ZSL_TRANSFER_NO 	0x16
+#define ZSL_TRANSFER_NO	0x16
 #define CAP_NV12_MODE		0x0a
 #define START_DUAL_STATUS	0x1f
-#define START_DUAL_CAPTURE 	0x05
+#define START_DUAL_CAPTURE	0x05
 
 #define DUAL_CAPTURE_SINGLE_CAPTURE_START	0x01
 #define DUAL_CAPTURE_HDR_CAPTURE_START		0x01
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
index 9d64ae7..ebfe139 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
@@ -131,7 +131,7 @@ static int m10mo_set_flash_address(struct v4l2_subdev *sd, u32 addr)
 static u32 m10mo_get_pll_cfg(u32 freq)
 {
 	u32 ret;
-	switch(freq) {
+	switch (freq) {
 	case 24000000:
 		ret = PLL_SETTINGS_24MHZ;
 		break;
@@ -183,24 +183,27 @@ static int m10mo_to_fw_access_mode(struct m10mo_device *m10mo_dev)
 	int err;
 
 	err = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT, SZ_64,
-				 PORT_SETTINGS0_ADDR , (u8 *)buf_port_settings0_m10mo);
+				 PORT_SETTINGS0_ADDR,
+				(u8 *)buf_port_settings0_m10mo);
 	if (err)
 		goto fail;
 
-	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY);
+	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY + 1);
 
 	err = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT, SZ_64,
-				 PORT_SETTINGS1_ADDR, (u8 *)buf_port_settings1_m10mo);
+				 PORT_SETTINGS1_ADDR,
+				(u8 *)buf_port_settings1_m10mo);
 	if (err)
 		goto fail;
 
-	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY);
+	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY + 1);
 
 	err = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT, SZ_64,
-				 PORT_SETTINGS2_ADDR, (u8 *)buf_port_settings2_m10mo);
+				 PORT_SETTINGS2_ADDR,
+				(u8 *)buf_port_settings2_m10mo);
 	if (err)
 		goto fail;
-	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY);
+	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY + 1);
 
 	err = m10mo_writel(sd, CATEGORY_FLASHROM,
 			   REG_PLL_VALUES,
@@ -248,7 +251,7 @@ static int m10mo_memory_dump(struct m10mo_device *m10mo_dev, u16 len,
 		err = i2c_transfer(client->adapter, &msg, 1);
 		if (err == 1)
 			break;
-		usleep_range(I2C_DELAY, I2C_DELAY);
+		usleep_range(I2C_DELAY, I2C_DELAY + 1);
 	}
 
 	if (err != 1)
@@ -261,7 +264,7 @@ static int m10mo_memory_dump(struct m10mo_device *m10mo_dev, u16 len,
 		err = i2c_transfer(client->adapter, &msg, 1);
 		if (err == 1)
 			break;
-		usleep_range(I2C_DELAY, I2C_DELAY);
+		usleep_range(I2C_DELAY, I2C_DELAY + 1);
 	}
 
 	if (err != 1)
@@ -355,7 +358,8 @@ static void m10mo_gen_log_name(char *name, char *prefix)
 	static long long time;
 
 	time = ktime_to_ms(ktime_get());
-	snprintf(name, M10MO_FW_LOG_MAX_NAME_LEN, "%s_%lld%s", prefix, time, M10MO_FW_LOG_SUFFIX);
+	snprintf(name, M10MO_FW_LOG_MAX_NAME_LEN, "%s_%lld%s",
+			prefix, time, M10MO_FW_LOG_SUFFIX);
 }
 
 int m10mo_dump_string_log3(struct v4l2_subdev *sd)
@@ -401,7 +405,8 @@ int m10mo_dump_string_log3(struct v4l2_subdev *sd)
 	if (ret < 0)
 		goto out_mem_free;
 
-	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+			LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
 	if (ret < 0)
 		goto out_mem_free;
 
@@ -410,22 +415,25 @@ int m10mo_dump_string_log3(struct v4l2_subdev *sd)
 		if (ret < 0)
 			goto out_mem_free;
 
-		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				LOG_ACT, LOG_ACT_OUTPUT_STR);
 		if (ret < 0)
 			goto out_mem_free;
 
 		do {
-			ret = m10mo_readb(sd, CATEGORY_LOGLEDFLASH, LOG_STR_LEN, &len);
+			ret = m10mo_readb(sd, CATEGORY_LOGLEDFLASH,
+						LOG_STR_LEN, &len);
 			if (ret < 0)
 				goto out_mem_free;
-			msleep(10);
+			msleep(20);
 			count_len++;
 		} while ((len == MAX_LOG_STR_LEN) && (count_len < 10));
 
 		if (len == MIN_LOG_STR_LEN) {
 			goto out_mem_free;
 		} else {
-			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH,
+						LOG_STR_ADD3, &addr);
 			if (ret < 0)
 				goto out_mem_free;
 
@@ -493,7 +501,8 @@ int m10mo_dump_string_log2_3(struct v4l2_subdev *sd)
 		goto out_close;
 	}
 
-	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_ANALYZE_MODE2);
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				LOG_MODE, LOG_ANALYZE_MODE2);
 	if (ret < 0)
 		goto out_mem_free;
 
@@ -502,12 +511,14 @@ int m10mo_dump_string_log2_3(struct v4l2_subdev *sd)
 		if (ret < 0)
 			goto out_mem_free;
 
-		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+					LOG_ACT, LOG_ACT_OUTPUT_STR);
 		if (ret < 0)
 			goto out_mem_free;
 
 		do {
-			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH, LOG_DATA_LEN1, &len);
+			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH,
+						LOG_DATA_LEN1, &len);
 			if (ret < 0)
 				goto out_mem_free;
 		} while (len == MAX_LOG_STR_LEN_LOG2);
@@ -519,25 +530,29 @@ int m10mo_dump_string_log2_3(struct v4l2_subdev *sd)
 			if (len > MAX_LOG_STR_LEN_LOG2)
 				len = MAX_LOG_STR_LEN_LOG2;
 
-			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH,
+						LOG_STR_ADD3, &addr);
 			if (ret < 0)
 				goto out_mem_free;
 
 			unit_count =  len / I2C_MEM_READ_SIZE;
 			for (i = 0; i <= unit_count; i += I2C_MEM_READ_SIZE) {
 				if ((len - i) <= I2C_MEM_READ_SIZE) {
-					ret = m10mo_memory_read(sd, len - i, addr + i, buf);
+					ret = m10mo_memory_read(sd, len - i,
+								addr + i, buf);
 					if (ret < 0)
 						goto out_mem_free;
 
 					vfs_write(fp, buf, len - i, &fp->f_pos);
 					break;
 				} else {
-					ret = m10mo_memory_read(sd, I2C_MEM_READ_SIZE, addr + i, buf);
+					ret = m10mo_memory_read(sd,
+					I2C_MEM_READ_SIZE, addr + i, buf);
 					if (ret < 0)
 						goto out_mem_free;
 
-					vfs_write(fp, buf, I2C_MEM_READ_SIZE, &fp->f_pos);
+					vfs_write(fp, buf,
+						I2C_MEM_READ_SIZE, &fp->f_pos);
 				}
 			}
 		}
@@ -594,7 +609,8 @@ int m10mo_dump_string_log2_2(struct v4l2_subdev *sd)
 		goto out_close;
 	}
 
-	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_ANALYZE_MODE1);
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				LOG_MODE, LOG_ANALYZE_MODE1);
 	if (ret < 0)
 		goto out_mem_free;
 
@@ -603,12 +619,14 @@ int m10mo_dump_string_log2_2(struct v4l2_subdev *sd)
 		if (ret < 0)
 			goto out_mem_free;
 
-		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+					LOG_ACT, LOG_ACT_OUTPUT_STR);
 		if (ret < 0)
 			goto out_mem_free;
 
 		do {
-			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH, LOG_DATA_LEN1, &len);
+			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH,
+						LOG_DATA_LEN1, &len);
 			if (ret < 0)
 				goto out_mem_free;
 		} while (len == MAX_LOG_STR_LEN_LOG2);
@@ -620,25 +638,29 @@ int m10mo_dump_string_log2_2(struct v4l2_subdev *sd)
 			if (len > MAX_LOG_STR_LEN_LOG2)
 				len = MAX_LOG_STR_LEN_LOG2;
 
-			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH,
+						LOG_STR_ADD3, &addr);
 			if (ret < 0)
 				goto out_mem_free;
 
 			unit_count =  len / I2C_MEM_READ_SIZE;
 			for (i = 0; i <= unit_count; i += I2C_MEM_READ_SIZE) {
 				if ((len - i) <= I2C_MEM_READ_SIZE) {
-					ret = m10mo_memory_read(sd, len - i, addr + i, buf);
+					ret = m10mo_memory_read(sd, len - i,
+								addr + i, buf);
 					if (ret < 0)
 						goto out_mem_free;
 
 					vfs_write(fp, buf, len - i, &fp->f_pos);
 					break;
 				} else {
-					ret = m10mo_memory_read(sd, I2C_MEM_READ_SIZE, addr + i, buf);
+					ret = m10mo_memory_read(sd,
+					I2C_MEM_READ_SIZE, addr + i, buf);
 					if (ret < 0)
 						goto out_mem_free;
 
-					vfs_write(fp, buf, I2C_MEM_READ_SIZE, &fp->f_pos);
+					vfs_write(fp, buf,
+						I2C_MEM_READ_SIZE, &fp->f_pos);
 				}
 			}
 		}
@@ -694,7 +716,8 @@ int m10mo_dump_string_log2_1(struct v4l2_subdev *sd)
 		goto out_close;
 	}
 
-	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_ANALYZE_MODE0);
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+			LOG_MODE, LOG_ANALYZE_MODE0);
 	if (ret < 0)
 		goto out_mem_free;
 
@@ -702,7 +725,8 @@ int m10mo_dump_string_log2_1(struct v4l2_subdev *sd)
 	if (ret < 0)
 		goto out_mem_free;
 
-	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
 	if (ret < 0)
 		goto out_mem_free;
 
@@ -711,12 +735,14 @@ int m10mo_dump_string_log2_1(struct v4l2_subdev *sd)
 		if (ret < 0)
 			goto out_mem_free;
 
-		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+					LOG_ACT, LOG_ACT_OUTPUT_STR);
 		if (ret < 0)
 			goto out_mem_free;
 
 		do {
-			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH, LOG_DATA_LEN1, &len);
+			ret = m10mo_readw(sd, CATEGORY_LOGLEDFLASH,
+							LOG_DATA_LEN1, &len);
 			if (ret < 0)
 				goto out_mem_free;
 		} while (len == MAX_LOG_STR_LEN_LOG2);
@@ -728,25 +754,29 @@ int m10mo_dump_string_log2_1(struct v4l2_subdev *sd)
 			if (len > MAX_LOG_STR_LEN_LOG2)
 				len = MAX_LOG_STR_LEN_LOG2;
 
-			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH,
+					LOG_STR_ADD3, &addr);
 			if (ret < 0)
 				goto out_mem_free;
 
 			unit_count =  len / I2C_MEM_READ_SIZE;
 			for (i = 0; i <= unit_count; i += I2C_MEM_READ_SIZE) {
 				if ((len - i) <= I2C_MEM_READ_SIZE) {
-					ret = m10mo_memory_read(sd, len - i, addr + i, buf);
+					ret = m10mo_memory_read(sd, len - i,
+								addr + i, buf);
 					if (ret < 0)
 						goto out_mem_free;
 
 					vfs_write(fp, buf, len - i, &fp->f_pos);
 					break;
 				} else {
-					ret = m10mo_memory_read(sd, I2C_MEM_READ_SIZE, addr + i, buf);
+					ret = m10mo_memory_read(sd,
+					I2C_MEM_READ_SIZE, addr + i, buf);
 					if (ret < 0)
 						goto out_mem_free;
 
-					vfs_write(fp, buf, I2C_MEM_READ_SIZE, &fp->f_pos);
+					vfs_write(fp, buf,
+						I2C_MEM_READ_SIZE, &fp->f_pos);
 				}
 			}
 		}
@@ -802,7 +832,8 @@ int m10mo_dump_string_log1(struct v4l2_subdev *sd)
 		goto out_close;
 	}
 
-	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_MODE, LOG_STANDARD_MODE);
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				LOG_MODE, LOG_STANDARD_MODE);
 	if (ret < 0)
 		goto out_mem_free;
 
@@ -810,7 +841,8 @@ int m10mo_dump_string_log1(struct v4l2_subdev *sd)
 	if (ret < 0)
 		goto out_mem_free;
 
-	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
+	ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+				LOG_ADD_SHOW, LOG_ADD_SHOW_INIT_VALUE);
 	if (ret < 0)
 		goto out_mem_free;
 
@@ -819,22 +851,25 @@ int m10mo_dump_string_log1(struct v4l2_subdev *sd)
 		if (ret < 0)
 			goto out_mem_free;
 
-		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH, LOG_ACT, LOG_ACT_OUTPUT_STR);
+		ret = m10mo_writeb(sd, CATEGORY_LOGLEDFLASH,
+					LOG_ACT, LOG_ACT_OUTPUT_STR);
 		if (ret < 0)
 			goto out_mem_free;
 
 		do {
-			ret = m10mo_readb(sd, CATEGORY_LOGLEDFLASH, LOG_STR_LEN, &len);
+			ret = m10mo_readb(sd, CATEGORY_LOGLEDFLASH,
+							LOG_STR_LEN, &len);
 			if (ret < 0)
 				goto out_mem_free;
-			msleep(10);
+			msleep(20);
 			count_len++;
 		} while ((len == MAX_LOG_STR_LEN) && (count_len < 10));
 
 		if (len == MIN_LOG_STR_LEN) {
 				goto out_mem_free;
 		} else {
-			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH, LOG_STR_ADD3, &addr);
+			ret = m10mo_readl(sd, CATEGORY_LOGLEDFLASH,
+						LOG_STR_ADD3, &addr);
 			if (ret < 0)
 				goto out_mem_free;
 
@@ -889,7 +924,7 @@ int m10mo_get_isp_fw_version_string(struct m10mo_device *dev,
 		dev_err(&client->dev, "Read mode transition fail: %d\n", err);
 		return err;
 	}
-	msleep(10);
+	msleep(20);
 
 	memset(buf, 0, len);
 	if ((fw_address_id < 0) ||
@@ -1066,7 +1101,8 @@ int m10mo_flash_write_block(struct m10mo_device *dev, u32 target_addr,
 		return ret;
 	}
 
-	ret = m10mo_wait_operation_complete(sd, REG_FLASH_WRITE, PROGRAMMING_TIMEOUT);
+	ret = m10mo_wait_operation_complete(sd, REG_FLASH_WRITE,
+						PROGRAMMING_TIMEOUT);
 
 	return ret;
 }
@@ -1117,7 +1153,7 @@ static int m10mo_sio_write(struct m10mo_device *m10mo_dev, u8 *buf)
 	ret = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_RAM_START,
 			   REG_RAM_START_SDRAM);
 	if (ret) {
-		dev_err(&client->dev, "start sio mode failed \n");
+		dev_err(&client->dev, "start sio mode failed\n");
 		return ret;
 	}
 
@@ -1126,14 +1162,14 @@ static int m10mo_sio_write(struct m10mo_device *m10mo_dev, u8 *buf)
 	if (ret)
 		return ret;
 
-	usleep_range(30000, 30000);  /* TDB: is that required */
+	usleep_range(30000, 30000 + 1);  /* TDB: is that required */
 
 	ret = m10mo_dev->spi->write(m10mo_dev->spi->spi_device,
 				    buf, FW_SIZE, SIO_BLOCK_SIZE);
 	if (ret)
 		return ret;
 
-	msleep(5); /* TDB: is that required */
+	msleep(20); /* TDB: is that required */
 
 	/* Flash address to 0*/
 	ret = m10mo_set_flash_address(sd, 0);
@@ -1143,7 +1179,7 @@ static int m10mo_sio_write(struct m10mo_device *m10mo_dev, u8 *buf)
 	/* Programming size */
 	ret = m10mo_writel(sd, CATEGORY_FLASHROM, REG_DATA_TRANS_SIZE, FW_SIZE);
 	if (ret) {
-		dev_err(&client->dev, "set sio programming size failed \n");
+		dev_err(&client->dev, "set sio programming size failed\n");
 		return ret;
 	}
 
@@ -1227,7 +1263,8 @@ int m10mo_program_device(struct m10mo_device *m10mo_dev)
 		}
 	} else {
 		for (i = 0 ; i < FW_SIZE; i = i + FLASH_BLOCK_SIZE) {
-			dev_dbg(&client->dev, "Writing block %d\n", i / FLASH_BLOCK_SIZE);
+			dev_dbg(&client->dev, "Writing block %d\n",
+					i / FLASH_BLOCK_SIZE);
 			ret = m10mo_flash_write_block(m10mo_dev,
 						      i, (u8 *)&fw->data[i],
 						      FLASH_BLOCK_SIZE);
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c
index 17426d3..25fa5dc 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw_type2.c
@@ -137,7 +137,8 @@ static int m10mo_set_burst_capture(struct v4l2_subdev *sd)
 	ret = m10mo_request_mode_change(sd, M10MO_PARAMETER_MODE);
 	if (ret)
 		return ret;
-	ret = m10mo_wait_mode_change(sd, M10MO_PARAMETER_MODE, M10MO_INIT_TIMEOUT);
+	ret = m10mo_wait_mode_change(sd, M10MO_PARAMETER_MODE,
+					M10MO_INIT_TIMEOUT);
 	if (ret)
 		return ret;
 
@@ -182,10 +183,11 @@ static int m10mo_set_still_capture_fw_type2(struct v4l2_subdev *sd)
 
 	/* Setting before switching to capture mode */
 	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM, CAPP_MAIN_IMAGE_SIZE,
-			  resolutions[mode][M10MO_MODE_CAPTURE_INDEX][dev->capture_res_idx].command);
+resolutions[mode][M10MO_MODE_CAPTURE_INDEX][dev->capture_res_idx].command);
 	if (ret)
 		goto out;
-	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, CAPC_MODE, 0);/* Single Capture*/
+	/* Single Capture*/
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL, CAPC_MODE, 0);
 	if (ret)
 		goto out;
 
@@ -261,7 +263,8 @@ int m10mo_streamoff_fw_type2(struct v4l2_subdev *sd)
 
 	if (dev->mode == M10MO_SINGLE_CAPTURE_MODE) {
 		/* Exit capture mode and back to monitor mode */
-		ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+		ret = m10mo_writeb(sd, CATEGORY_SYSTEM,
+				SYSTEM_INT_ENABLE, 0x01);
 		if (ret)
 			goto out;
 		ret = __m10mo_monitor_mode_set(sd);
@@ -278,7 +281,8 @@ int m10mo_streamoff_fw_type2(struct v4l2_subdev *sd)
 		if (ret)
 			goto out;
 		/* Restart monitor mode. */
-		ret = m10mo_writeb(sd, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+		ret = m10mo_writeb(sd, CATEGORY_SYSTEM,
+				SYSTEM_INT_ENABLE, 0x01);
 		if (ret)
 			return ret;
 		ret = __m10mo_monitor_mode_set(sd);
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c
index eb3fc72..4a91ed0 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c
@@ -28,7 +28,8 @@
 #include <media/m10mo_atomisp.h>
 #include "m10mo.h"
 
-static inline int spi_xmit(struct spi_device *spi, const u8 *addr, const int len)
+static inline int spi_xmit(struct spi_device *spi,
+				const u8 *addr, const int len)
 {
 	int ret;
 	struct spi_message msg;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig
index 406f38f..a63b547 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig
@@ -16,12 +16,27 @@ config VIDEO_MT9E013_BLACKBAY
 	bool "MT9E013 settings for Blackbay"
 	---help---
 	  Default mt9e013 sensor settings for Blackbay
+
+	  For MT9E013 sensor and the sensor currently depends
+	  on internal V4L2 extensions defined in atomisp
+	  driver.
+
 config VIDEO_MT9E013_LEXINGTON
 	bool "MT9E013 settings for Lexington"
 	---help---
 	  Default mt9e013 sensor settings for Lexington
+
+	  For MT9E013 sensor and the sensor currently depends
+	  on internal V4L2 extensions defined in atomisp
+	  driver.
+
 config VIDEO_MT9E013_ENZO
 	bool "MT9E013 settings for Enzo"
 	---help---
 	  Default mt9e013 sensor settings for Enzo
+
+	  For MT9E013 sensor and the sensor currently depends
+	  on internal V4L2 extensions defined in atomisp
+	  driver.
+
 endchoice
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile
index 32edaf8..ec82d75 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile
@@ -1,2 +1,2 @@
 obj-$(CONFIG_VIDEO_MT9E013) += mt9e013.o
-EXTRA_CFLAGS := -Werror
+ccflags-y := -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c
index 0acd65e..d2c4d25 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c
@@ -354,8 +354,8 @@ static int mt9e013_write_reg_array(struct i2c_client *client,
 					       next->reg.sreg, next->val,
 					       next->val2);
 			if (err) {
-				v4l2_err(client, "%s: rwm error, "
-						"aborted\n", __func__);
+				v4l2_err(client,
+				"%s: rwm error,aborted\n", __func__);
 				return err;
 			}
 			break;
@@ -445,7 +445,7 @@ static int mt9e013_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 	if (val & ATOMISP_FOCUS_STATUS_MOVING)
 		*value  = dev->focus - dev->number_of_steps;
 	else
-		*value  = dev->focus ;
+		*value  = dev->focus;
 
 	return 0;
 }
@@ -598,8 +598,8 @@ __mt9e013_otp_read(struct v4l2_subdev *sd, const struct mt9e013_reg *type,
 		ret = mt9e013_read_reg(client, MT9E013_16BIT,
 				       MT9E013_OTP_READY_REG, &ready);
 		if (ret) {
-			v4l2_err(client, "%s: failed to read OTP memory "
-					 "status\n", __func__);
+			v4l2_err(client,
+			"%s: failed to read OTP memory status\n", __func__);
 			return ret;
 		}
 		if (ready & MT9E013_OTP_READY_REG_DONE)
@@ -686,8 +686,8 @@ static u8 *mt9e013_fuseid_read(struct v4l2_subdev *sd)
 	fuseid = kmalloc(sizeof(*fuseid) * MT9E013_FUSEID_SIZE, GFP_KERNEL);
 
 	if (!fuseid) {
-		v4l2_err(client, "%s: no memory available when reading "
-				 "FUSEID.\n", __func__);
+		v4l2_err(client,
+		"%s: no memory available when reading FUSEID.\n", __func__);
 		return ERR_PTR(-ENOMEM);
 	}
 
@@ -810,8 +810,8 @@ static int __mt9e013_init(struct v4l2_subdev *sd, u32 val)
 		dev->keeps_focus_pos = fw_version >= PR3_3_FW;
 	}
 	if (!dev->keeps_focus_pos) {
-		v4l2_warn(sd, "VCM does not maintain focus position in standby"
-			      "mode, using software workaround\n");
+		v4l2_warn(sd,
+		"VCM does not maintain focus position in standby mode, using software workaround\n");
 	}
 
 	return ret;
@@ -1714,9 +1714,11 @@ static int mt9e013_s_stream(struct v4l2_subdev *sd, int enable)
 		if (!dev->keeps_focus_pos) {
 			struct mt9e013_reg mt9e013_stream_enable[] = {
 				mt9e013_streaming[0],
-				{MT9E013_16BIT, {0x30F2}, 0x0000}, /* VCM_NEW_CODE */
+				/* VCM_NEW_CODE */
+				{MT9E013_16BIT, {0x30F2}, 0x0000},
 				INIT_VCM_CONTROL,
-				{MT9E013_16BIT, {0x30F2}, 0x0000}, /* VCM_NEW_CODE */
+				/* VCM_NEW_CODE */
+				{MT9E013_16BIT, {0x30F2}, 0x0000},
 				{MT9E013_TOK_DELAY, {0}, 60},
 				{MT9E013_TOK_TERM, {0}, 0}
 			};
@@ -1724,9 +1726,11 @@ static int mt9e013_s_stream(struct v4l2_subdev *sd, int enable)
 			mt9e013_stream_enable[1].val = dev->focus + 1;
 			mt9e013_stream_enable[3].val = dev->focus;
 
-			ret = mt9e013_write_reg_array(client, mt9e013_stream_enable);
+			ret = mt9e013_write_reg_array(client,
+							mt9e013_stream_enable);
 		} else {
-			ret = mt9e013_write_reg_array(client, mt9e013_streaming);
+			ret = mt9e013_write_reg_array(client,
+							mt9e013_streaming);
 		}
 
 		if (ret != 0) {
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h
index ea36b0d..ed94b58 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h
@@ -417,7 +417,8 @@ static const struct mt9e013_reg mt9e013_reset_register[] = {
 };
 
 static const struct mt9e013_reg mt9e013_raw_10[] = {
-	{MT9E013_16BIT, {0x0112}, 0x0A0A}, /* CCP_DATA_FORMAT, set to RAW10 mode */
+	/* CCP_DATA_FORMAT, set to RAW10 mode */
+	{MT9E013_16BIT, {0x0112}, 0x0A0A},
 	{MT9E013_TOK_TERM, {0}, 0}
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h
index b80299b..9f57e8f 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h
@@ -114,11 +114,15 @@ static const struct mt9e013_reg mt9e013_recommended_settings[] = {
 
 static const struct mt9e013_reg mt9e013_pll_timing[] = {
 	/* pixelrate into the isp = 153.600.000 Hz */
-	{MT9E013_16BIT, {0x0300}, 0x0004}, /* vt_pix_clk_div = 4, internal pixel clk freq = 192.000MHz */
+	/* vt_pix_clk_div = 4, internal pixel clk freq = 192.000MHz */
+	{MT9E013_16BIT, {0x0300}, 0x0004},
 	{MT9E013_16BIT, {0x0302}, 0x0001}, /* vt_sys_clk_div = 1 */
-	{MT9E013_16BIT, {0x0304}, 0x0001}, /* pre_pll_clk_div = 1 PLL input clock freq = 19.200MHz */
-	{MT9E013_16BIT, {0x0306}, 0x0028}, /* pll_multiplier = 40 mipi bus speed = 768.000MHz */
-	{MT9E013_16BIT, {0x0308}, 0x000A}, /* op_pix_clk_div = 10, output pixel clk freq = 76.800MHz */
+	/* pre_pll_clk_div = 1 PLL input clock freq = 19.200MHz */
+	{MT9E013_16BIT, {0x0304}, 0x0001},
+	/* pll_multiplier = 40 mipi bus speed = 768.000MHz */
+	{MT9E013_16BIT, {0x0306}, 0x0028},
+	/* op_pix_clk_div = 10, output pixel clk freq = 76.800MHz */
+	{MT9E013_16BIT, {0x0308}, 0x000A},
 	{MT9E013_16BIT, {0x030A}, 0x0001}, /* op_sys_clk_div = 1 */
 	{MT9E013_16BIT, {0x3016}, 0x0111}, /* row_speed = 273 */
 	{MT9E013_TOK_DELAY, {0}, 1},
@@ -154,7 +158,8 @@ static struct mt9e013_reg const mt9e013_STILL_8M_15fps[] = {
 	/*	STILL 8M */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	/*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0340},	0x0AA4	},
 	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -162,12 +167,16 @@ static struct mt9e013_reg const mt9e013_STILL_8M_15fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
 	{MT9E013_16BIT, {0x034E},	0x09A0	}, /*	Y_OUTPUT_SIZE	2464 */
-	{MT9E013_16BIT, {0x3040},	0x0041	}, /*	READ_MODE	0 0 0 0 0 0 0 1 1 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 0 0 1 1 */
+	{MT9E013_16BIT, {0x3040},	0x0041	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
-	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
-	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	},
+	/*	FINE_INTEGRATION_TIME	1014 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -178,7 +187,8 @@ static struct mt9e013_reg const mt9e013_STILL_6M_15fps[] = {
 	/*	STILL 6M */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	/*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0340},	0x0AA4	},
 	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0134	}, /*	Y_ADDR_START	308 */
@@ -186,12 +196,16 @@ static struct mt9e013_reg const mt9e013_STILL_6M_15fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x086D	}, /*	Y_ADDR_END	2157 */
 	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
 	{MT9E013_16BIT, {0x034E},	0x0738	}, /*	Y_OUTPUT_SIZE	1848 */
-	{MT9E013_16BIT, {0x3040},	0x0041	}, /*	READ_MODE	0 0 0 0 0 0 0 1 1 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 0 0 1 1 */
+	{MT9E013_16BIT, {0x3040},	0x0041	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
-	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
-	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	},
+	/*	FINE_INTEGRATION_TIME	1014 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -202,7 +216,8 @@ static struct mt9e013_reg const mt9e013_STILL_2M_15fps[] = {
 	/*	STILL 2M */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x0C1C	}, /*	FRAME_LENGTH_LINES	3100 */
+	/*	FRAME_LENGTH_LINES	3100 */
+	{MT9E013_16BIT, {0x0340},	0x0C1C	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -210,12 +225,16 @@ static struct mt9e013_reg const mt9e013_STILL_2M_15fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x09A1	}, /*	Y_ADDR_END	2465 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
 	{MT9E013_16BIT, {0x034E},	0x04D0	}, /*	Y_OUTPUT_SIZE	1232 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -227,7 +246,8 @@ static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
 	/* PREVIEW */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -235,12 +255,16 @@ static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
 	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
@@ -251,7 +275,8 @@ static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
 	/* WIDE PREVIEW */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
@@ -259,12 +284,16 @@ static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
 	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -275,7 +304,8 @@ static struct mt9e013_reg const mt9e013_PREVIEW1640_30fps[] = {
 	/*	PREVIEW 1640x1232 */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -283,12 +313,16 @@ static struct mt9e013_reg const mt9e013_PREVIEW1640_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x09A1	}, /*	Y_ADDR_END	2465 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
 	{MT9E013_16BIT, {0x034E},	0x04D0	}, /*	Y_OUTPUT_SIZE	1232 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -300,7 +334,8 @@ static struct mt9e013_reg const mt9e013_1080p_strong_dvs_30fps[] = {
 	/*	1080p strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x05AB	}, /*	FRAME_LENGTH_LINES	1451 */
+	/*	FRAME_LENGTH_LINES	1451 */
+	{MT9E013_16BIT, {0x0340},	0x05AB	},
 	{MT9E013_16BIT, {0x0342},	0x113A	}, /*	LINE_LENGTH_PCK	4410 */
 	{MT9E013_16BIT, {0x0344},	0x01D8	}, /*	X_ADDR_START	472 */
 	{MT9E013_16BIT, {0x0346},	0x0242	}, /*	Y_ADDR_START	578 */
@@ -308,12 +343,16 @@ static struct mt9e013_reg const mt9e013_1080p_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x075D	}, /*	Y_ADDR_END	1885 */
 	{MT9E013_16BIT, {0x034C},	0x0920	}, /*	X_OUTPUT_SIZE	2336 */
 	{MT9E013_16BIT, {0x034E},	0x051C	}, /*	Y_OUTPUT_SIZE	1308 */
-	{MT9E013_16BIT, {0x3040},	0x0041	}, /*	READ_MODE	0 0 0 0 0 0 0 1 1  */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 0 0 1 1  */
+	{MT9E013_16BIT, {0x3040},	0x0041	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
-	{MT9E013_16BIT, {0X3012},	0x05AB	}, /*	COARSE_INTEGRATION_TIME	1451 */
-	{MT9E013_16BIT, {0X3014},	0x0442	}, /*	FINE_INTEGRATION_TIME	1090 */
+	/*	COARSE_INTEGRATION_TIME	1451 */
+	{MT9E013_16BIT, {0X3012},	0x05AB	},
+	/*	FINE_INTEGRATION_TIME	1090 */
+	{MT9E013_16BIT, {0X3014},	0x0442	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -324,7 +363,8 @@ static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
 	/*	720p strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0048	}, /*	X_ADDR_START	72 */
 	{MT9E013_16BIT, {0x0346},	0x0160	}, /*	Y_ADDR_START	352 */
@@ -332,12 +372,16 @@ static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x083F	}, /*	Y_ADDR_END	2111 */
 	{MT9E013_16BIT, {0x034C},	0x0620	}, /*	X_OUTPUT_SIZE	1568 */
 	{MT9E013_16BIT, {0x034E},	0x0370	}, /*	Y_OUTPUT_SIZE	880 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -345,10 +389,10 @@ static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
 };
 
 static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
-	/*	PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
+	/*PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*FRAME_LENGTH_LINES	1550 */
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -356,12 +400,16 @@ static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1050 */
 	{MT9E013_16BIT, {0x034E},	0x0400	}, /*	Y_OUTPUT_SIZE	778 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*READ_MODE0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	25 */
@@ -372,7 +420,8 @@ static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
 	/*	WVGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x00D0	}, /*	Y_ADDR_START	208 */
@@ -380,12 +429,16 @@ static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x08CD	}, /*	Y_ADDR_END	2253 */
 	{MT9E013_16BIT, {0x034C},	0x03F0	}, /*	X_OUTPUT_SIZE	1008 */
 	{MT9E013_16BIT, {0x034E},	0x0276	}, /*	Y_OUTPUT_SIZE	630 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x001A	}, /*	SCALE_M	26 */
@@ -396,7 +449,8 @@ static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
 	/*	480p strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -404,12 +458,16 @@ static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0388	}, /*	X_OUTPUT_SIZE	904 */
 	{MT9E013_16BIT, {0x034E},	0x025A	}, /*	Y_OUTPUT_SIZE	602 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	  304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x001D	}, /*	SCALE_M	29 */
@@ -420,7 +478,8 @@ static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
 	/*	VGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -428,12 +487,16 @@ static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
 	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
@@ -444,7 +507,8 @@ static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
 	/*	QVGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0008	}, /*	X_ADDR_START	8 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -452,12 +516,16 @@ static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0198	}, /*	X_OUTPUT_SIZE	408 */
 	{MT9E013_16BIT, {0x034E},	0x0134	}, /*	Y_OUTPUT_SIZE	308 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0040	}, /*	SCALE_M	64 */
@@ -468,7 +536,8 @@ static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
 	/* QCIF strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0080	}, /*	X_ADDR_START	128 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -476,12 +545,16 @@ static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x00D8	}, /*	X_OUTPUT_SIZE	216 */
 	{MT9E013_16BIT, {0x034E},	0x00B0	}, /*	Y_OUTPUT_SIZE	176 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0070	}, /*	SCALE_M	112 */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h
index 1ff2616..b8628a3 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h
@@ -114,12 +114,16 @@ static const struct mt9e013_reg mt9e013_recommended_settings[] = {
 };
 
 static const struct mt9e013_reg mt9e013_pll_timing[] = {
-	/*			pixelrate into the isp =	153.600.000 Hz*/
-	{MT9E013_16BIT, {0x0300},	0x0004	}, /*	vt_pix_clk_div=	4	internal pixel clock freq =	192.000.000 Hz*/
+	/*pixelrate into the isp =	153.600.000 Hz*/
+	/*vt_pix_clk_div=4 internal pixel clock freq = 192.000.000 Hz*/
+	{MT9E013_16BIT, {0x0300},	0x0004	},
 	{MT9E013_16BIT, {0x0302},	0x0001	}, /*	vt_sys_clk_div=	1*/
-	{MT9E013_16BIT, {0x0304},	0x0001	}, /*	pre_pll_clk_div=	1	PLL input clock freq =	19.200.000 Hz*/
-	{MT9E013_16BIT, {0x0306},	0x0028	}, /*	pll_multiplier=	40	mipi bus speed =	768.000.000 Hz*/
-	{MT9E013_16BIT, {0x0308},	0x000A	}, /*	op_pix_clk_div=	10	output pixel clock freq =	76.800.000 Hz*/
+	/*pre_pll_clk_div=1 PLL input clock freq = 19.200.000 Hz*/
+	{MT9E013_16BIT, {0x0304},	0x0001	},
+	/*pll_multiplier=40 mipi bus speed =	768.000.000 Hz*/
+	{MT9E013_16BIT, {0x0306},	0x0028	},
+	/*op_pix_clk_div= 10 output pixel clock freq =76.800.000 Hz*/
+	{MT9E013_16BIT, {0x0308},	0x000A	},
 	{MT9E013_16BIT, {0x030A},	0x0001	}, /*	op_sys_clk_div=	1*/
 	{MT9E013_16BIT, {0x3016},	0x111	}, /*	row_speed=	273*/
 	{MT9E013_TOK_DELAY, {0}, 1},
@@ -159,7 +163,8 @@ static struct mt9e013_reg const mt9e013_STILL_8M_15fps[] = {
 	/*	STILL 8M */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	/*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0340},	0x0AA4	},
 	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -167,12 +172,16 @@ static struct mt9e013_reg const mt9e013_STILL_8M_15fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
 	{MT9E013_16BIT, {0x034E},	0x09A0	}, /*	Y_OUTPUT_SIZE	2464 */
-	{MT9E013_16BIT, {0x3040},	0x4041	}, /*	READ_MODE	0 1 1 0 0 0 0 1 1 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 0 0 1 1 */
+	{MT9E013_16BIT, {0x3040},	0x4041	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
-	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
-	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	},
+	/*	FINE_INTEGRATION_TIME	1014 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -183,7 +192,8 @@ static struct mt9e013_reg const mt9e013_STILL_6M_15fps[] = {
 	/*	STILL 6M */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	/*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0340},	0x0AA4	},
 	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0134	}, /*	Y_ADDR_START	308 */
@@ -191,12 +201,16 @@ static struct mt9e013_reg const mt9e013_STILL_6M_15fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x086D	}, /*	Y_ADDR_END	2157 */
 	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
 	{MT9E013_16BIT, {0x034E},	0x0738	}, /*	Y_OUTPUT_SIZE	1848 */
-	{MT9E013_16BIT, {0x3040},	0x4041	}, /*	READ_MODE	0 1 1 0 0 0 0 1 1 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 0 0 1 1 */
+	{MT9E013_16BIT, {0x3040},	0x4041	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
-	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
-	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	},
+	/*	FINE_INTEGRATION_TIME	1014 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -207,7 +221,8 @@ static struct mt9e013_reg const mt9e013_STILL_2M_15fps[] = {
 	/*	STILL 2M */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x0C1C	}, /*	FRAME_LENGTH_LINES	3100 */
+	/*	FRAME_LENGTH_LINES	3100 */
+	{MT9E013_16BIT, {0x0340},	0x0C1C	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -215,12 +230,16 @@ static struct mt9e013_reg const mt9e013_STILL_2M_15fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x09A1	}, /*	Y_ADDR_END	2465 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
 	{MT9E013_16BIT, {0x034E},	0x04D0	}, /*	Y_OUTPUT_SIZE	1232 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -232,7 +251,8 @@ static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
 	/* PREVIEW */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -240,12 +260,16 @@ static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
 	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
@@ -256,7 +280,8 @@ static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
 	/* WIDE PREVIEW */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
@@ -264,12 +289,16 @@ static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
 	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -281,7 +310,8 @@ static struct mt9e013_reg const mt9e013_1080p_strong_dvs_30fps[] = {
 	/*	1080p strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x05AB	}, /*	FRAME_LENGTH_LINES	1451 */
+	/*	FRAME_LENGTH_LINES	1451 */
+	{MT9E013_16BIT, {0x0340},	0x05AB	},
 	{MT9E013_16BIT, {0x0342},	0x113A	}, /*	LINE_LENGTH_PCK	4410 */
 	{MT9E013_16BIT, {0x0344},	0x01D8	}, /*	X_ADDR_START	472 */
 	{MT9E013_16BIT, {0x0346},	0x0242	}, /*	Y_ADDR_START	578 */
@@ -289,12 +319,16 @@ static struct mt9e013_reg const mt9e013_1080p_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x075D	}, /*	Y_ADDR_END	1885 */
 	{MT9E013_16BIT, {0x034C},	0x0920	}, /*	X_OUTPUT_SIZE	2336 */
 	{MT9E013_16BIT, {0x034E},	0x051C	}, /*	Y_OUTPUT_SIZE	1308 */
-	{MT9E013_16BIT, {0x3040},	0x4041	}, /*	READ_MODE	0 1 1 0 0 0 0 1 1  */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 0 0 1 1  */
+	{MT9E013_16BIT, {0x3040},	0x4041	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
-	{MT9E013_16BIT, {0X3012},	0x05AB	}, /*	COARSE_INTEGRATION_TIME	1451 */
-	{MT9E013_16BIT, {0X3014},	0x0442	}, /*	FINE_INTEGRATION_TIME	1090 */
+	/*	COARSE_INTEGRATION_TIME	1451 */
+	{MT9E013_16BIT, {0X3012},	0x05AB	},
+	/*	FINE_INTEGRATION_TIME	1090 */
+	{MT9E013_16BIT, {0X3014},	0x0442	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -305,7 +339,8 @@ static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
 	/*	720p strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0048	}, /*	X_ADDR_START	72 */
 	{MT9E013_16BIT, {0x0346},	0x0160	}, /*	Y_ADDR_START	352 */
@@ -313,12 +348,16 @@ static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x083F	}, /*	Y_ADDR_END	2111 */
 	{MT9E013_16BIT, {0x034C},	0x0620	}, /*	X_OUTPUT_SIZE	1568 */
 	{MT9E013_16BIT, {0x034E},	0x0370	}, /*	Y_OUTPUT_SIZE	880 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -326,10 +365,11 @@ static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
 };
 
 static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
-	/*	PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
+	/*PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -337,12 +377,16 @@ static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1050 */
 	{MT9E013_16BIT, {0x034E},	0x0400	}, /*	Y_OUTPUT_SIZE	778 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	25 */
@@ -353,7 +397,8 @@ static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
 	/*	WVGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x00D0	}, /*	Y_ADDR_START	208 */
@@ -361,12 +406,16 @@ static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x08CD	}, /*	Y_ADDR_END	2253 */
 	{MT9E013_16BIT, {0x034C},	0x03F0	}, /*	X_OUTPUT_SIZE	1008 */
 	{MT9E013_16BIT, {0x034E},	0x0276	}, /*	Y_OUTPUT_SIZE	630 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x001A	}, /*	SCALE_M	26 */
@@ -377,7 +426,8 @@ static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
 	/*	480p strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -385,12 +435,16 @@ static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0388	}, /*	X_OUTPUT_SIZE	904 */
 	{MT9E013_16BIT, {0x034E},	0x025A	}, /*	Y_OUTPUT_SIZE	602 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	  304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x001D	}, /*	SCALE_M	29 */
@@ -401,7 +455,8 @@ static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
 	/*	VGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -409,12 +464,16 @@ static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
 	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
@@ -425,7 +484,8 @@ static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
 	/*	QVGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0008	}, /*	X_ADDR_START	8 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -433,12 +493,16 @@ static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0198	}, /*	X_OUTPUT_SIZE	408 */
 	{MT9E013_16BIT, {0x034E},	0x0134	}, /*	Y_OUTPUT_SIZE	308 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0040	}, /*	SCALE_M	64 */
@@ -449,7 +513,8 @@ static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
 	/* QCIF strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0080	}, /*	X_ADDR_START	128 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -457,12 +522,16 @@ static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x00D8	}, /*	X_OUTPUT_SIZE	216 */
 	{MT9E013_16BIT, {0x034E},	0x00B0	}, /*	Y_OUTPUT_SIZE	176 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0070	}, /*	SCALE_M	112 */
@@ -473,7 +542,8 @@ static struct mt9e013_reg const enzofullhd_strong_dvs_30fps[] = {
 	/* enzofullhd_strong_dvs_30fps */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
@@ -481,12 +551,16 @@ static struct mt9e013_reg const enzofullhd_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
 	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
-	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h
index f93986e..f462098 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h
@@ -238,7 +238,8 @@ static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
 	/* PREVIEW */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -246,12 +247,16 @@ static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
 	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
@@ -262,7 +267,8 @@ static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
 	/* WIDE PREVIEW */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
@@ -270,12 +276,16 @@ static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
 	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
@@ -331,10 +341,11 @@ static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
 };
 
 static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
-	/*	PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
+	/*PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -342,12 +353,16 @@ static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1050 */
 	{MT9E013_16BIT, {0x034E},	0x0400	}, /*	Y_OUTPUT_SIZE	778 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	25 */
@@ -358,7 +373,8 @@ static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
 	/*	WVGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x00D0	}, /*	Y_ADDR_START	208 */
@@ -366,12 +382,16 @@ static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x08CD	}, /*	Y_ADDR_END	2253 */
 	{MT9E013_16BIT, {0x034C},	0x03F0	}, /*	X_OUTPUT_SIZE	1008 */
 	{MT9E013_16BIT, {0x034E},	0x0276	}, /*	Y_OUTPUT_SIZE	630 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x001A	}, /*	SCALE_M	26 */
@@ -382,7 +402,8 @@ static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
 	/*	480p strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -390,12 +411,16 @@ static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0388	}, /*	X_OUTPUT_SIZE	904 */
 	{MT9E013_16BIT, {0x034E},	0x025A	}, /*	Y_OUTPUT_SIZE	602 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	  304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x001D	}, /*	SCALE_M	29 */
@@ -406,7 +431,8 @@ static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
 	/*	VGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -414,12 +440,16 @@ static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
 	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
@@ -430,7 +460,8 @@ static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
 	/*	QVGA strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0008	}, /*	X_ADDR_START	8 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -438,12 +469,16 @@ static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x0198	}, /*	X_OUTPUT_SIZE	408 */
 	{MT9E013_16BIT, {0x034E},	0x0134	}, /*	Y_OUTPUT_SIZE	308 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0040	}, /*	SCALE_M	64 */
@@ -454,7 +489,8 @@ static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
 	/* QCIF strong dvs */
 	GROUPED_PARAMETER_HOLD_ENABLE,
 	/* Frame size & Timing Configuration*/
-	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	/*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0340},	0x060E	},
 	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
 	{MT9E013_16BIT, {0x0344},	0x0080	}, /*	X_ADDR_START	128 */
 	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
@@ -462,12 +498,16 @@ static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
 	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
 	{MT9E013_16BIT, {0x034C},	0x00D8	}, /*	X_OUTPUT_SIZE	216 */
 	{MT9E013_16BIT, {0x034E},	0x00B0	}, /*	Y_OUTPUT_SIZE	176 */
-	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
-	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	},
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
 	/* Initial integration time */
 	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
-	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
-	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3012},	0x0573	},
+	/*	FINE_INTEGRATION_TIME	2118 */
+	{MT9E013_16BIT, {0X3014},	0x0846	},
 	/* Scaler configuration */
 	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
 	{MT9E013_16BIT, {0x0404},	0x0070	}, /*	SCALE_M	112 */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
index eb8e565..22c6b7a 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
@@ -445,7 +445,8 @@ static int mt9m114_set_suspend(struct v4l2_subdev *sd)
 #ifndef CONFIG_GMIN_INTEL_MID /* FIXME! */
 	return mt9m114_write_reg_array(client, mt9m114_suspend, POST_POLLING);
 #else
-	return mt9m114_write_reg_array(client, mt9m114_standby_reg, POST_POLLING);
+	return mt9m114_write_reg_array(client,
+			mt9m114_standby_reg, POST_POLLING);
 #endif
 }
 #ifndef CONFIG_GMIN_INTEL_MID /* FIXME! */
@@ -1053,20 +1054,20 @@ static int mt9m114_set_mbus_fmt(struct v4l2_subdev *sd,
 }
 
 /* TODO: Update to SOC functions, remove exposure and gain */
-static int mt9m114_g_focal(struct v4l2_subdev *sd, s32 * val)
+static int mt9m114_g_focal(struct v4l2_subdev *sd, s32 *val)
 {
 	*val = (MT9M114_FOCAL_LENGTH_NUM << 16) | MT9M114_FOCAL_LENGTH_DEM;
 	return 0;
 }
 
-static int mt9m114_g_fnumber(struct v4l2_subdev *sd, s32 * val)
+static int mt9m114_g_fnumber(struct v4l2_subdev *sd, s32 *val)
 {
 	/*const f number for mt9m114*/
 	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 16) | MT9M114_F_NUMBER_DEM;
 	return 0;
 }
 
-static int mt9m114_g_fnumber_range(struct v4l2_subdev *sd, s32 * val)
+static int mt9m114_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
 {
 	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 24) |
 		(MT9M114_F_NUMBER_DEM << 16) |
@@ -1075,7 +1076,7 @@ static int mt9m114_g_fnumber_range(struct v4l2_subdev *sd, s32 * val)
 }
 
 /* Horizontal flip the image. */
-static int mt9m114_g_hflip(struct v4l2_subdev *sd, s32 * val)
+static int mt9m114_g_hflip(struct v4l2_subdev *sd, s32 *val)
 {
 	struct i2c_client *c = v4l2_get_subdevdata(sd);
 	int ret;
@@ -1089,7 +1090,7 @@ static int mt9m114_g_hflip(struct v4l2_subdev *sd, s32 * val)
 	return 0;
 }
 
-static int mt9m114_g_vflip(struct v4l2_subdev *sd, s32 * val)
+static int mt9m114_g_vflip(struct v4l2_subdev *sd, s32 *val)
 {
 	struct i2c_client *c = v4l2_get_subdevdata(sd);
 	int ret;
@@ -1163,92 +1164,98 @@ static int mt9m114_g_2a_status(struct v4l2_subdev *sd, s32 *val)
 static long mt9m114_s_exposure(struct v4l2_subdev *sd,
 			       struct atomisp_exposure *exposure)
 {
-    struct i2c_client *client = v4l2_get_subdevdata(sd);
-    struct mt9m114_device *dev = to_mt9m114_sensor(sd);
-    int ret = 0;
-    unsigned int coarse_integration = 0;
-    unsigned int fine_integration = 0;
-    unsigned int FLines = 0;
-    unsigned int FrameLengthLines = 0; //ExposureTime.FrameLengthLines;
-    unsigned int AnalogGain, DigitalGain;
-    u32 AnalogGainToWrite = 0;
-    u16 exposure_local[3];
-
-    dev_dbg(&client->dev, "%s(0x%X 0x%X 0x%X)\n", __func__,
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int ret = 0;
+	unsigned int coarse_integration = 0;
+	unsigned int fine_integration = 0;
+	unsigned int FLines = 0;
+	unsigned int FrameLengthLines = 0; /* ExposureTime.FrameLengthLines; */
+	unsigned int AnalogGain, DigitalGain;
+	u32 AnalogGainToWrite = 0;
+	u16 exposure_local[3];
+
+	dev_dbg(&client->dev, "%s(0x%X 0x%X 0x%X)\n", __func__,
 		    exposure->integration_time[0], exposure->gain[0],
 		    exposure->gain[1]);
 
-    coarse_integration = exposure->integration_time[0];
-//    fine_integration = ExposureTime.FineIntegrationTime;
-//    FrameLengthLines = ExposureTime.FrameLengthLines;
-    FLines = mt9m114_res[dev->res].lines_per_frame;
-    AnalogGain = exposure->gain[0];
-    DigitalGain = exposure->gain[1];
+	coarse_integration = exposure->integration_time[0];
+	/* fine_integration = ExposureTime.FineIntegrationTime; */
+	/* FrameLengthLines = ExposureTime.FrameLengthLines; */
+	FLines = mt9m114_res[dev->res].lines_per_frame;
+	AnalogGain = exposure->gain[0];
+	DigitalGain = exposure->gain[1];
 	if (!dev->streamon) {
 		/*Save the first exposure values while stream is off*/
 		dev->first_exp = coarse_integration;
 		dev->first_gain = AnalogGain;
 		dev->first_diggain = DigitalGain;
 	}
-    //DigitalGain = 0x400 * (((u16) DigitalGain) >> 8) + ((unsigned int)(0x400 * (((u16) DigitalGain) & 0xFF)) >>8);
-
-    //set frame length
-    if (FLines < coarse_integration + 6)
-        FLines = coarse_integration + 6;
-    if (FLines < FrameLengthLines)
-        FLines = FrameLengthLines;
-    ret = mt9m114_write_reg(client, MISENSOR_16BIT, 0x300A, FLines);
+	/* DigitalGain = 0x400 * (((u16) DigitalGain) >> 8) +
+	((unsigned int)(0x400 * (((u16) DigitalGain) & 0xFF)) >>8); */
+
+	/* set frame length */
+	if (FLines < coarse_integration + 6)
+		FLines = coarse_integration + 6;
+	if (FLines < FrameLengthLines)
+		FLines = FrameLengthLines;
+	ret = mt9m114_write_reg(client, MISENSOR_16BIT, 0x300A, FLines);
 	if (ret) {
 		v4l2_err(client, "%s: fail to set FLines\n", __func__);
 		return -EINVAL;
 	}
 
-    //set coarse/fine integration
-    exposure_local[0] = REG_EXPO_COARSE;
-    exposure_local[1] = (u16)coarse_integration;
-    exposure_local[2] = (u16)fine_integration;
-    // 3A provide real exposure time. should not translate to any value here.
-    ret = mt9m114_write_reg(client, MISENSOR_16BIT, REG_EXPO_COARSE, (u16)(coarse_integration));
-    if (ret) {
-		 v4l2_err(client, "%s: fail to set exposure time\n", __func__);
-		 return -EINVAL;
-    }
-
-     /*
-    // set analog/digital gain
-    switch(AnalogGain)
-    {
-      case 0:
-          AnalogGainToWrite = 0x0;
-          break;
-      case 1:
-          AnalogGainToWrite = 0x20;
-          break;
-      case 2:
-          AnalogGainToWrite = 0x60;
-          break;
-      case 4:
-          AnalogGainToWrite = 0xA0;
-          break;
-      case 8:
-          AnalogGainToWrite = 0xE0;
-          break;
-      default:
-          AnalogGainToWrite = 0x20;
-          break;
-    }
-    */
-   if (DigitalGain >= 16 || DigitalGain <= 1)
-        DigitalGain = 1;
-   // AnalogGainToWrite = (u16)((DigitalGain << 12) | AnalogGainToWrite);
-   AnalogGainToWrite = (u16)((DigitalGain << 12) | (u16)AnalogGain);
-   ret = mt9m114_write_reg(client, MISENSOR_16BIT, REG_GAIN, AnalogGainToWrite);
-   if (ret) {
-		v4l2_err(client, "%s: fail to set AnalogGainToWrite\n", __func__);
+	/* set coarse/fine integration */
+	exposure_local[0] = REG_EXPO_COARSE;
+	exposure_local[1] = (u16)coarse_integration;
+	exposure_local[2] = (u16)fine_integration;
+	/* 3A provide real exposure time.
+		should not translate to any value here. */
+	ret = mt9m114_write_reg(client, MISENSOR_16BIT,
+			REG_EXPO_COARSE, (u16)(coarse_integration));
+	if (ret) {
+		v4l2_err(client, "%s: fail to set exposure time\n", __func__);
+		return -EINVAL;
+	}
+
+	/*
+	// set analog/digital gain
+	switch(AnalogGain)
+	{
+	case 0:
+	  AnalogGainToWrite = 0x0;
+	  break;
+	case 1:
+	  AnalogGainToWrite = 0x20;
+	  break;
+	case 2:
+	  AnalogGainToWrite = 0x60;
+	  break;
+	case 4:
+	  AnalogGainToWrite = 0xA0;
+	  break;
+	case 8:
+	  AnalogGainToWrite = 0xE0;
+	  break;
+	default:
+	  AnalogGainToWrite = 0x20;
+	  break;
+	}
+	*/
+	if (DigitalGain >= 16 || DigitalGain <= 1)
+		DigitalGain = 1;
+	/* AnalogGainToWrite =
+		(u16)((DigitalGain << 12) | AnalogGainToWrite); */
+	AnalogGainToWrite = (u16)((DigitalGain << 12) | (u16)AnalogGain);
+	ret = mt9m114_write_reg(client, MISENSOR_16BIT,
+					REG_GAIN, AnalogGainToWrite);
+	if (ret) {
+		v4l2_err(client, "%s: fail to set AnalogGainToWrite\n",
+			__func__);
 		return -EINVAL;
-   }
+	}
 
-    return ret;
+	return ret;
 }
 
 static long mt9m114_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
@@ -1260,6 +1267,7 @@ static long mt9m114_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
 	default:
 		return -EINVAL;
 	}
+
 	return 0;
 }
 
@@ -1304,7 +1312,8 @@ static int mt9m114_s_exposure_metering(struct v4l2_subdev *sd, s32 val)
 
 	switch (val) {
 	case V4L2_EXPOSURE_METERING_SPOT:
-		ret = mt9m114_write_reg_array(client, mt9m114_exp_average, NO_POLLING);
+		ret = mt9m114_write_reg_array(client, mt9m114_exp_average,
+						NO_POLLING);
 		if (ret) {
 			dev_err(&client->dev, "write exp_average reg err.\n");
 			return ret;
@@ -1312,7 +1321,8 @@ static int mt9m114_s_exposure_metering(struct v4l2_subdev *sd, s32 val)
 		break;
 	case V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:
 	default:
-		ret = mt9m114_write_reg_array(client, mt9m114_exp_center, NO_POLLING);
+		ret = mt9m114_write_reg_array(client, mt9m114_exp_center,
+						NO_POLLING);
 		if (ret) {
 			dev_err(&client->dev, "write exp_default reg err");
 			return ret;
@@ -1336,7 +1346,7 @@ static int mt9m114_s_exposure_selection(struct v4l2_subdev *sd,
 	int grid_width, grid_height;
 	int grid_left, grid_top, grid_right, grid_bottom;
 	int win_left, win_top, win_right, win_bottom;
-	int i,j;
+	int i, j;
 	int ret;
 
 	if (sel->which != V4L2_SUBDEV_FORMAT_TRY &&
@@ -1422,9 +1432,8 @@ static int mt9m114_s_ev(struct v4l2_subdev *sd, s32 val)
 	/* EV value only support -2 to 2
 	 * 0: 0x37, 1:0x47, 2:0x57, -1:0x27, -2:0x17
 	 */
-	if (val < -2 || val > 2) {
+	if (val < -2 || val > 2)
 		return -EINVAL;
-	}
 	luma += 0x10 * val;
 	dev_dbg(&c->dev, "%s val:%d luma:0x%x\n", __func__, val, luma);
 	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC87A);
@@ -1434,7 +1443,8 @@ static int mt9m114_s_ev(struct v4l2_subdev *sd, s32 val)
 	}
 	err = mt9m114_write_reg(c, MISENSOR_8BIT, 0xC87A, (u32)luma);
 	if (err) {
-		dev_err(&c->dev, "%s write target_average_luma failed\n", __func__);
+		dev_err(&c->dev, "%s write target_average_luma failed\n",
+			__func__);
 		return err;
 	}
 	udelay(10);
@@ -1455,7 +1465,8 @@ static int mt9m114_g_ev(struct v4l2_subdev *sd, s32 *val)
 	}
 	err = mt9m114_read_reg(c, MISENSOR_8BIT, 0xC87A, &luma);
 	if (err) {
-		dev_err(&c->dev, "%s read target_average_luma failed\n", __func__);
+		dev_err(&c->dev, "%s read target_average_luma failed\n",
+			__func__);
 		return err;
 	}
 	luma -= 0x17;
@@ -2096,7 +2107,7 @@ static int mt9m114_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
 	return 0;
 }
 static const struct v4l2_subdev_video_ops mt9m114_video_ops = {
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 	.s_parm = mt9m114_s_parm,
 #endif
 	.try_mbus_fmt = mt9m114_try_mbus_fmt,
@@ -2105,7 +2116,7 @@ static const struct v4l2_subdev_video_ops mt9m114_video_ops = {
 	.s_stream = mt9m114_s_stream,
 	.enum_framesizes = mt9m114_enum_framesizes,
 	.enum_frameintervals = mt9m114_enum_frameintervals,
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 	.g_frame_interval = mt9m114_g_frame_interval,
 #endif
 };
@@ -2115,14 +2126,14 @@ static struct v4l2_subdev_sensor_ops mt9m114_sensor_ops = {
 };
 
 static const struct v4l2_subdev_core_ops mt9m114_core_ops = {
-#ifndef CONFIG_GMIN_INTEL_MID 
+#ifndef CONFIG_GMIN_INTEL_MID
 	.g_chip_ident = mt9m114_g_chip_ident,
 #endif
 	.queryctrl = mt9m114_queryctrl,
 	.g_ctrl = mt9m114_g_ctrl,
 	.s_ctrl = mt9m114_s_ctrl,
 	.s_power = mt9m114_s_power,
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 	.ioctl = mt9m114_ioctl,
 #endif
 };
@@ -2170,7 +2181,7 @@ static int mt9m114_probe(struct i2c_client *client,
 {
 	struct mt9m114_device *dev;
 	int ret = 0;
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 	void *pdata;
 #endif
 	/* Setup sensor configuration structure */
@@ -2181,7 +2192,7 @@ static int mt9m114_probe(struct i2c_client *client,
 	}
 
 	v4l2_i2c_subdev_init(&dev->sd, client, &mt9m114_ops);
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 	pdata = client->dev.platform_data;
 	if (ACPI_COMPANION(&client->dev))
 		pdata = gmin_camera_platform_data(&dev->sd,
@@ -2214,7 +2225,7 @@ static int mt9m114_probe(struct i2c_client *client,
 	/*TODO add format code here*/
 	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
 	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
 #endif
@@ -2224,7 +2235,7 @@ static int mt9m114_probe(struct i2c_client *client,
 		mt9m114_remove(client);
 		return ret;
 	}
-#ifndef CONFIG_GMIN_INTEL_MID 
+#ifndef CONFIG_GMIN_INTEL_MID
 	/* set res index to be invalid */
 	dev->res = -1;
 #endif
@@ -2232,11 +2243,11 @@ static int mt9m114_probe(struct i2c_client *client,
 }
 
 MODULE_DEVICE_TABLE(i2c, mt9m114_id);
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 static struct acpi_device_id mt9m114_acpi_match[] = {
 	{ "INT33F0" },
 	{ "CRMT1040" },
-        {},
+	{},
 };
 MODULE_DEVICE_TABLE(acpi, mt9m114_acpi_match);
 #endif
@@ -2244,7 +2255,7 @@ static struct i2c_driver mt9m114_driver = {
 	.driver = {
 		.owner = THIS_MODULE,
 		.name = "mt9m114",
-#ifdef CONFIG_GMIN_INTEL_MID 
+#ifdef CONFIG_GMIN_INTEL_MID
 		.acpi_match_table = ACPI_PTR(mt9m114_acpi_match),
 #endif
 	},
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
index 58322d4..d9e423a 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
@@ -84,26 +84,26 @@
 /* sensor coarse integration time register */
 #define MISENSOR_COARSE_INTEGRATION_TIME 0xC83C
 
-//registers
+/* registers */
 #define REG_SW_RESET                    0x301A
 #define REG_SW_STREAM                   0xDC00
 #define REG_SCCB_CTRL                   0x3100
 #define REG_SC_CMMN_CHIP_ID             0x0000
-#define REG_V_START                     0xc800 //16bits
-#define REG_H_START                     0xc802 //16bits
-#define REG_V_END                       0xc804 //16bits
-#define REG_H_END                       0xc806 //16bits
-#define REG_PIXEL_CLK                   0xc808 //32bits
-#define REG_TIMING_VTS                  0xc812 //16bits
-#define REG_TIMING_HTS                  0xc814 //16bits
-#define REG_WIDTH                       0xC868 //16bits
-#define REG_HEIGHT                      0xC86A //16bits
-#define REG_EXPO_COARSE                 0x3012 //16bits
-#define REG_EXPO_FINE                   0x3014 //16bits
+#define REG_V_START                     0xc800 /* 16bits */
+#define REG_H_START                     0xc802 /* 16bits */
+#define REG_V_END                       0xc804 /* 16bits */
+#define REG_H_END                       0xc806 /* 16bits */
+#define REG_PIXEL_CLK                   0xc808 /* 32bits */
+#define REG_TIMING_VTS                  0xc812 /* 16bits */
+#define REG_TIMING_HTS                  0xc814 /* 16bits */
+#define REG_WIDTH                       0xC868 /* 16bits */
+#define REG_HEIGHT                      0xC86A /* 16bits */
+#define REG_EXPO_COARSE                 0x3012 /* 16bits */
+#define REG_EXPO_FINE                   0x3014 /* 16bits */
 #define REG_GAIN                        0x305E
 #define REG_ANALOGGAIN                  0x305F
-#define REG_ADDR_ACESSS                 0x098E //logical_address_access
-#define REG_COMM_Register               0x0080 //command_register
+#define REG_ADDR_ACESSS                 0x098E /* logical_address_access */
+#define REG_COMM_Register               0x0080 /* command_register */
 
 #define SENSOR_DETECTED		1
 #define SENSOR_NOT_DETECTED	0
@@ -493,11 +493,11 @@ static const struct i2c_device_id mt9m114_id[] = {
 };
 
 static struct misensor_reg const mt9m114_exitstandby[] = {
-	 {MISENSOR_16BIT,  0x098E, 0xDC00},
-     // exit-standby
-     {MISENSOR_8BIT,  0xDC00, 0x54},
-	 {MISENSOR_16BIT,  0x0080, 0x8002},
-	 {MISENSOR_TOK_TERM, 0, 0}
+	{MISENSOR_16BIT,  0x098E, 0xDC00},
+	/* exit-standby */
+	{MISENSOR_8BIT,  0xDC00, 0x54},
+	{MISENSOR_16BIT,  0x0080, 0x8002},
+	{MISENSOR_TOK_TERM, 0, 0}
 };
 
 static struct misensor_reg const mt9m114_exp_win[5][5] = {
@@ -913,218 +913,259 @@ static struct misensor_reg const mt9m114_common[] = {
 	{MISENSOR_TOK_TERM, 0, 0}
 };
 #else
-// [1296x976_30fps] - Intel
+/* [1296x976_30fps] - Intel */
 static struct misensor_reg const mt9m114_960P_init[] = {
 	{MISENSOR_16BIT, 0x098E, 0x1000},
-	{MISENSOR_8BIT, 0xC97E, 0x01},	  //cam_sysctl_pll_enable = 1
-	{MISENSOR_16BIT, 0xC980, 0x0128}, //cam_sysctl_pll_divider_m_n = 276
-	{MISENSOR_16BIT, 0xC982, 0x0700}, //cam_sysctl_pll_divider_p = 1792
-	{MISENSOR_16BIT, 0xC800, 0x0000}, //cam_sensor_cfg_y_addr_start = 0
-	{MISENSOR_16BIT, 0xC802, 0x0000}, //cam_sensor_cfg_x_addr_start = 0
-	{MISENSOR_16BIT, 0xC804, 0x03CF}, //cam_sensor_cfg_y_addr_end = 971
-	{MISENSOR_16BIT, 0xC806, 0x050F}, //cam_sensor_cfg_x_addr_end = 1291
-	{MISENSOR_16BIT, 0xC808, 0x02DC}, //cam_sensor_cfg_pixclk = 48000000
+	{MISENSOR_8BIT, 0xC97E, 0x01},	  /* cam_sysctl_pll_enable = 1 */
+	{MISENSOR_16BIT, 0xC980, 0x0128}, /* cam_sysctl_pll_divider_m_n = 276 */
+	{MISENSOR_16BIT, 0xC982, 0x0700}, /* cam_sysctl_pll_divider_p = 1792 */
+	{MISENSOR_16BIT, 0xC800, 0x0000}, /* cam_sensor_cfg_y_addr_start = 0 */
+	{MISENSOR_16BIT, 0xC802, 0x0000}, /* cam_sensor_cfg_x_addr_start = 0 */
+	{MISENSOR_16BIT, 0xC804, 0x03CF}, /* cam_sensor_cfg_y_addr_end = 971 */
+	{MISENSOR_16BIT, 0xC806, 0x050F}, /* cam_sensor_cfg_x_addr_end = 1291 */
+	{MISENSOR_16BIT, 0xC808, 0x02DC}, /* cam_sensor_cfg_pixclk = 48000000 */
 	{MISENSOR_16BIT, 0xC80A, 0x6C00},
-	{MISENSOR_16BIT, 0xC80C, 0x0001}, //cam_sensor_cfg_row_speed = 1
-	{MISENSOR_16BIT, 0xC80E, 0x00DB}, //cam_sensor_cfg_fine_integ_time_min = 219
-	{MISENSOR_16BIT, 0xC810, 0x05B3}, //cam_sensor_cfg_fine_integ_time_max = 1459
-	{MISENSOR_16BIT, 0xC812, 0x03F6}, //cam_sensor_cfg_frame_length_lines = 1006
-	{MISENSOR_16BIT, 0xC814, 0x063E}, //cam_sensor_cfg_line_length_pck = 1590
-	{MISENSOR_16BIT, 0xC816, 0x0060}, //cam_sensor_cfg_fine_correction = 96
-	{MISENSOR_16BIT, 0xC818, 0x03C3}, //cam_sensor_cfg_cpipe_last_row = 963
-	{MISENSOR_16BIT, 0xC826, 0x0020}, //cam_sensor_cfg_reg_0_data = 32
-	{MISENSOR_16BIT, 0xC834, 0x0000}, //cam_sensor_control_read_mode = 0
-	{MISENSOR_16BIT, 0xC854, 0x0000}, //cam_crop_window_xoffset = 0
-	{MISENSOR_16BIT, 0xC856, 0x0000}, //cam_crop_window_yoffset = 0
-	{MISENSOR_16BIT, 0xC858, 0x0508}, //cam_crop_window_width = 1280
-	{MISENSOR_16BIT, 0xC85A, 0x03C8}, //cam_crop_window_height = 960
-	{MISENSOR_8BIT,  0xC85C, 0x03},   //cam_crop_cropmode = 3
-	{MISENSOR_16BIT, 0xC868, 0x0508}, //cam_output_width = 1280
-	{MISENSOR_16BIT, 0xC86A, 0x03C8}, //cam_output_height = 960
+	{MISENSOR_16BIT, 0xC80C, 0x0001}, /* cam_sensor_cfg_row_speed = 1 */
+	/* cam_sensor_cfg_fine_integ_time_min = 219 */
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	/* cam_sensor_cfg_fine_integ_time_max = 1459 */
+	{MISENSOR_16BIT, 0xC810, 0x05B3},
+	/* cam_sensor_cfg_frame_length_lines = 1006 */
+	{MISENSOR_16BIT, 0xC812, 0x03F6},
+	/* cam_sensor_cfg_line_length_pck = 1590 */
+	{MISENSOR_16BIT, 0xC814, 0x063E},
+	/* cam_sensor_cfg_fine_correction = 96 */
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	/* cam_sensor_cfg_cpipe_last_row = 963 */
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020}, /* cam_sensor_cfg_reg_0_data = 32 */
+	{MISENSOR_16BIT, 0xC834, 0x0000}, /* cam_sensor_control_read_mode = 0 */
+	{MISENSOR_16BIT, 0xC854, 0x0000}, /* cam_crop_window_xoffset = 0 */
+	{MISENSOR_16BIT, 0xC856, 0x0000}, /* cam_crop_window_yoffset = 0 */
+	{MISENSOR_16BIT, 0xC858, 0x0508}, /* cam_crop_window_width = 1280 */
+	{MISENSOR_16BIT, 0xC85A, 0x03C8}, /* cam_crop_window_height = 960 */
+	{MISENSOR_8BIT,  0xC85C, 0x03},   /* cam_crop_cropmode = 3 */
+	{MISENSOR_16BIT, 0xC868, 0x0508}, /* cam_output_width = 1280 */
+	{MISENSOR_16BIT, 0xC86A, 0x03C8}, /* cam_output_height = 960 */
 	{MISENSOR_TOK_TERM, 0, 0},
 };
 
-//[1296x976_30fps_768Mbps]
+/* [1296x976_30fps_768Mbps] */
 static struct misensor_reg const mt9m114_976P_init[] = {
 	{MISENSOR_16BIT, 0x98E, 0x1000},
-	{MISENSOR_8BIT, 0xC97E, 0x01},	  //cam_sysctl_pll_enable = 1
-	{MISENSOR_16BIT, 0xC980, 0x0128}, //cam_sysctl_pll_divider_m_n = 276
-	{MISENSOR_16BIT, 0xC982, 0x0700}, //cam_sysctl_pll_divider_p = 1792
-	{MISENSOR_16BIT, 0xC800, 0x0000}, //cam_sensor_cfg_y_addr_start = 0
-	{MISENSOR_16BIT, 0xC802, 0x0000}, //cam_sensor_cfg_x_addr_start = 0
-	{MISENSOR_16BIT, 0xC804, 0x03CF}, //cam_sensor_cfg_y_addr_end = 975
-	{MISENSOR_16BIT, 0xC806, 0x050F}, //cam_sensor_cfg_x_addr_end = 1295
-	{MISENSOR_32BIT, 0xC808, 0x2DC6C00}, //cam_sensor_cfg_pixclk = 480000
-	{MISENSOR_16BIT, 0xC80C, 0x0001}, //cam_sensor_cfg_row_speed = 1
-	{MISENSOR_16BIT, 0xC80E, 0x00DB}, //cam_sensor_cfg_fine_integ_time_min = 219
-	{MISENSOR_16BIT, 0xC810, 0x05B3}, //0x062E //cam_sensor_cfg_fine_integ_time_max = 1459
-	{MISENSOR_16BIT, 0xC812, 0x03E5}, //0x074C //cam_sensor_cfg_frame_length_lines = 1006
-	{MISENSOR_16BIT, 0xC814, 0x0644}, //0x06B1 /cam_sensor_cfg_line_length_pck = 1590
-	{MISENSOR_16BIT, 0xC816, 0x0060}, //cam_sensor_cfg_fine_correction = 96
-	{MISENSOR_16BIT, 0xC818, 0x03C3}, //cam_sensor_cfg_cpipe_last_row = 963
-	{MISENSOR_16BIT, 0xC826, 0x0020}, //cam_sensor_cfg_reg_0_data = 32
-	{MISENSOR_16BIT, 0xC834, 0x0000}, //cam_sensor_control_read_mode = 0
-	{MISENSOR_16BIT, 0xC854, 0x0000}, //cam_crop_window_xoffset = 0
-	{MISENSOR_16BIT, 0xC856, 0x0000}, //cam_crop_window_yoffset = 0
-	{MISENSOR_16BIT, 0xC858, 0x0508}, //cam_crop_window_width = 1288
-	{MISENSOR_16BIT, 0xC85A, 0x03C8}, //cam_crop_window_height = 968
-	{MISENSOR_8BIT, 0xC85C, 0x03}, //cam_crop_cropmode = 3
-	{MISENSOR_16BIT, 0xC868, 0x0508}, //cam_output_width = 1288
-	{MISENSOR_16BIT, 0xC86A, 0x03C8}, //cam_output_height = 968
-	{MISENSOR_8BIT, 0xC878, 0x00}, //0x0E //cam_aet_aemode = 0
+	{MISENSOR_8BIT, 0xC97E, 0x01},	  /* cam_sysctl_pll_enable = 1 */
+	{MISENSOR_16BIT, 0xC980, 0x0128}, /* cam_sysctl_pll_divider_m_n = 276 */
+	{MISENSOR_16BIT, 0xC982, 0x0700}, /* cam_sysctl_pll_divider_p = 1792 */
+	{MISENSOR_16BIT, 0xC800, 0x0000}, /* cam_sensor_cfg_y_addr_start = 0 */
+	{MISENSOR_16BIT, 0xC802, 0x0000}, /* cam_sensor_cfg_x_addr_start = 0 */
+	{MISENSOR_16BIT, 0xC804, 0x03CF}, /* cam_sensor_cfg_y_addr_end = 975 */
+	{MISENSOR_16BIT, 0xC806, 0x050F}, /* cam_sensor_cfg_x_addr_end = 1295 */
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},/* cam_sensor_cfg_pixclk = 480000*/
+	{MISENSOR_16BIT, 0xC80C, 0x0001}, /* cam_sensor_cfg_row_speed = 1 */
+	/* cam_sensor_cfg_fine_integ_time_min = 219 */
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	 /* 0x062E //cam_sensor_cfg_fine_integ_time_max = 1459 */
+	{MISENSOR_16BIT, 0xC810, 0x05B3},
+	/* 0x074C //cam_sensor_cfg_frame_length_lines = 1006 */
+	{MISENSOR_16BIT, 0xC812, 0x03E5},
+	/* 0x06B1 /cam_sensor_cfg_line_length_pck = 1590 */
+	{MISENSOR_16BIT, 0xC814, 0x0644},
+	/* cam_sensor_cfg_fine_correction = 96 */
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	/* cam_sensor_cfg_cpipe_last_row = 963 */
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020}, /* cam_sensor_cfg_reg_0_data = 32 */
+	{MISENSOR_16BIT, 0xC834, 0x0000}, /* cam_sensor_control_read_mode = 0 */
+	{MISENSOR_16BIT, 0xC854, 0x0000}, /* cam_crop_window_xoffset = 0 */
+	{MISENSOR_16BIT, 0xC856, 0x0000}, /* cam_crop_window_yoffset = 0 */
+	{MISENSOR_16BIT, 0xC858, 0x0508}, /* cam_crop_window_width = 1288 */
+	{MISENSOR_16BIT, 0xC85A, 0x03C8}, /* cam_crop_window_height = 968 */
+	{MISENSOR_8BIT, 0xC85C, 0x03}, /* cam_crop_cropmode = 3 */
+	{MISENSOR_16BIT, 0xC868, 0x0508}, /* cam_output_width = 1288 */
+	{MISENSOR_16BIT, 0xC86A, 0x03C8}, /* cam_output_height = 968 */
+	{MISENSOR_8BIT, 0xC878, 0x00}, /* 0x0E //cam_aet_aemode = 0 */
 	{MISENSOR_TOK_TERM, 0, 0}
 };
 
-// [1296x864_30fps]
+/* [1296x864_30fps] */
 static struct misensor_reg const mt9m114_864P_init[] = {
 	{MISENSOR_16BIT, 0x98E, 0x1000},
-	{MISENSOR_8BIT, 0xC97E, 0x01},	  //cam_sysctl_pll_enable = 1
-	{MISENSOR_16BIT, 0xC980, 0x0128}, //cam_sysctl_pll_divider_m_n = 276
-	{MISENSOR_16BIT, 0xC982, 0x0700}, //cam_sysctl_pll_divider_p = 1792
-	{MISENSOR_16BIT, 0xC800, 0x0038}, //cam_sensor_cfg_y_addr_start = 56
-	{MISENSOR_16BIT, 0xC802, 0x0000}, //cam_sensor_cfg_x_addr_start = 0
-	{MISENSOR_16BIT, 0xC804, 0x0397}, //cam_sensor_cfg_y_addr_end = 919
-	{MISENSOR_16BIT, 0xC806, 0x050F}, //cam_sensor_cfg_x_addr_end = 1295
-	{MISENSOR_32BIT, 0xC808, 0x2DC6C00}, //cam_sensor_cfg_pixclk = 48000000
-	{MISENSOR_16BIT, 0xC80C, 0x0001}, //cam_sensor_cfg_row_speed = 1
-	{MISENSOR_16BIT, 0xC80E, 0x00DB}, //cam_sensor_cfg_fine_integ_time_min = 219
-	{MISENSOR_16BIT, 0xC810, 0x05BD}, //cam_sensor_cfg_fine_integ_time_max = 1469
-	{MISENSOR_16BIT, 0xC812, 0x03E8}, //cam_sensor_cfg_frame_length_lines = 1000
-	{MISENSOR_16BIT, 0xC814, 0x0640}, //cam_sensor_cfg_line_length_pck = 1600
-	{MISENSOR_16BIT, 0xC816, 0x0060}, //cam_sensor_cfg_fine_correction = 96
-	{MISENSOR_16BIT, 0xC818, 0x035B}, //cam_sensor_cfg_cpipe_last_row = 859
-	{MISENSOR_16BIT, 0xC826, 0x0020}, //cam_sensor_cfg_reg_0_data = 32
-	{MISENSOR_16BIT, 0xC834, 0x0000}, //cam_sensor_control_read_mode = 0
-	{MISENSOR_16BIT, 0xC854, 0x0000}, //cam_crop_window_xoffset = 0
-	{MISENSOR_16BIT, 0xC856, 0x0000}, //cam_crop_window_yoffset = 0
-	{MISENSOR_16BIT, 0xC858, 0x0508}, //cam_crop_window_width = 1288
-	{MISENSOR_16BIT, 0xC85A, 0x0358}, //cam_crop_window_height = 856
-	{MISENSOR_8BIT, 0xC85C, 0x03}, //cam_crop_cropmode = 3
-	{MISENSOR_16BIT, 0xC868, 0x0508}, //cam_output_width = 1288
-	{MISENSOR_16BIT, 0xC86A, 0x0358}, //cam_output_height = 856
-	{MISENSOR_8BIT, 0xC878, 0x00}, //0x0E //cam_aet_aemode = 0
+	{MISENSOR_8BIT, 0xC97E, 0x01},	  /* cam_sysctl_pll_enable = 1 */
+	{MISENSOR_16BIT, 0xC980, 0x0128}, /* cam_sysctl_pll_divider_m_n = 276 */
+	{MISENSOR_16BIT, 0xC982, 0x0700}, /* cam_sysctl_pll_divider_p = 1792 */
+	{MISENSOR_16BIT, 0xC800, 0x0038}, /* cam_sensor_cfg_y_addr_start = 56 */
+	{MISENSOR_16BIT, 0xC802, 0x0000}, /* cam_sensor_cfg_x_addr_start = 0 */
+	{MISENSOR_16BIT, 0xC804, 0x0397}, /* cam_sensor_cfg_y_addr_end = 919 */
+	{MISENSOR_16BIT, 0xC806, 0x050F}, /* cam_sensor_cfg_x_addr_end = 1295 */
+	/* cam_sensor_cfg_pixclk = 48000000 */
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001}, /* cam_sensor_cfg_row_speed = 1 */
+	/* cam_sensor_cfg_fine_integ_time_min = 219 */
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	/* cam_sensor_cfg_fine_integ_time_max = 1469 */
+	{MISENSOR_16BIT, 0xC810, 0x05BD},
+	/* cam_sensor_cfg_frame_length_lines = 1000 */
+	{MISENSOR_16BIT, 0xC812, 0x03E8},
+	/* cam_sensor_cfg_line_length_pck = 1600 */
+	{MISENSOR_16BIT, 0xC814, 0x0640},
+	/* cam_sensor_cfg_fine_correction = 96 */
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	/* cam_sensor_cfg_cpipe_last_row = 859 */
+	{MISENSOR_16BIT, 0xC818, 0x035B},
+	{MISENSOR_16BIT, 0xC826, 0x0020}, /* cam_sensor_cfg_reg_0_data = 32 */
+	{MISENSOR_16BIT, 0xC834, 0x0000}, /* cam_sensor_control_read_mode = 0 */
+	{MISENSOR_16BIT, 0xC854, 0x0000}, /* cam_crop_window_xoffset = 0 */
+	{MISENSOR_16BIT, 0xC856, 0x0000}, /* cam_crop_window_yoffset = 0 */
+	{MISENSOR_16BIT, 0xC858, 0x0508}, /* cam_crop_window_width = 1288 */
+	{MISENSOR_16BIT, 0xC85A, 0x0358}, /* cam_crop_window_height = 856 */
+	{MISENSOR_8BIT, 0xC85C, 0x03}, /* cam_crop_cropmode = 3 */
+	{MISENSOR_16BIT, 0xC868, 0x0508}, /* cam_output_width = 1288 */
+	{MISENSOR_16BIT, 0xC86A, 0x0358}, /* cam_output_height = 856 */
+	{MISENSOR_8BIT, 0xC878, 0x00}, /* 0x0E //cam_aet_aemode = 0 */
 	{MISENSOR_TOK_TERM, 0, 0}
 };
 
-// [1296x736_30fps]
+/* [1296x736_30fps] */
 static struct misensor_reg const mt9m114_736P_init[] = {
 	{MISENSOR_16BIT, 0x98E, 0x1000},
-	{MISENSOR_8BIT, 0xC97E, 0x01},	  //cam_sysctl_pll_enable = 1
-	{MISENSOR_16BIT, 0xC980, 0x011F}, //cam_sysctl_pll_divider_m_n = 287
-	{MISENSOR_16BIT, 0xC982, 0x0700}, //cam_sysctl_pll_divider_p = 1792
-	{MISENSOR_16BIT, 0xC800, 0x0078}, //cam_sensor_cfg_y_addr_start = 120
-	{MISENSOR_16BIT, 0xC802, 0x0000}, //cam_sensor_cfg_x_addr_start = 0
-	{MISENSOR_16BIT, 0xC804, 0x0357}, //cam_sensor_cfg_y_addr_end = 855
-	{MISENSOR_16BIT, 0xC806, 0x050F}, //cam_sensor_cfg_x_addr_end = 1295
-	{MISENSOR_32BIT, 0xC808, 0x237A07F}, //cam_sensor_cfg_pixclk = 37199999
-	{MISENSOR_16BIT, 0xC80C, 0x0001}, //cam_sensor_cfg_row_speed = 1
-	{MISENSOR_16BIT, 0xC80E, 0x00DB}, //cam_sensor_cfg_fine_integ_time_min = 219
-	{MISENSOR_16BIT, 0xC810, 0x05BD}, //0x062E //cam_sensor_cfg_fine_integ_time_max = 1469
-	{MISENSOR_16BIT, 0xC812, 0x0307}, //0x074C //cam_sensor_cfg_frame_length_lines = 775
-	{MISENSOR_16BIT, 0xC814, 0x0640}, //0x06B1 /cam_sensor_cfg_line_length_pck = 1600
-	{MISENSOR_16BIT, 0xC816, 0x0060}, //cam_sensor_cfg_fine_correction = 96
-	{MISENSOR_16BIT, 0xC818, 0x02DB}, //cam_sensor_cfg_cpipe_last_row = 731
-	{MISENSOR_16BIT, 0xC826, 0x0020}, //cam_sensor_cfg_reg_0_data = 32
-	{MISENSOR_16BIT, 0xC834, 0x0000}, //cam_sensor_control_read_mode = 0
-	{MISENSOR_16BIT, 0xC854, 0x0000}, //cam_crop_window_xoffset = 0
-	{MISENSOR_16BIT, 0xC856, 0x0000}, //cam_crop_window_yoffset = 0
-	{MISENSOR_16BIT, 0xC858, 0x0508}, //cam_crop_window_width = 1288
-	{MISENSOR_16BIT, 0xC85A, 0x02D8}, //cam_crop_window_height = 728
-	{MISENSOR_8BIT, 0xC85C, 0x03}, //cam_crop_cropmode = 3
-	{MISENSOR_16BIT, 0xC868, 0x0508}, //cam_output_width = 1288
-	{MISENSOR_16BIT, 0xC86A, 0x02D8}, //cam_output_height = 728
-	{MISENSOR_8BIT, 0xC878, 0x00}, //0x0E //cam_aet_aemode = 0
+	{MISENSOR_8BIT, 0xC97E, 0x01},	  /* cam_sysctl_pll_enable = 1 */
+	{MISENSOR_16BIT, 0xC980, 0x011F}, /* cam_sysctl_pll_divider_m_n = 287 */
+	{MISENSOR_16BIT, 0xC982, 0x0700}, /* cam_sysctl_pll_divider_p = 1792 */
+	{MISENSOR_16BIT, 0xC800, 0x0078}, /* cam_sensor_cfg_y_addr_start = 120*/
+	{MISENSOR_16BIT, 0xC802, 0x0000}, /* cam_sensor_cfg_x_addr_start = 0 */
+	{MISENSOR_16BIT, 0xC804, 0x0357}, /* cam_sensor_cfg_y_addr_end = 855 */
+	{MISENSOR_16BIT, 0xC806, 0x050F}, /* cam_sensor_cfg_x_addr_end = 1295 */
+	{MISENSOR_32BIT, 0xC808, 0x237A07F}, /* cam_sensor_cfg_pixclk=37199999*/
+	{MISENSOR_16BIT, 0xC80C, 0x0001}, /* cam_sensor_cfg_row_speed = 1 */
+	/* cam_sensor_cfg_fine_integ_time_min = 219 */
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	/* 0x062E //cam_sensor_cfg_fine_integ_time_max = 1469 */
+	{MISENSOR_16BIT, 0xC810, 0x05BD},
+	/* 0x074C //cam_sensor_cfg_frame_length_lines = 775 */
+	{MISENSOR_16BIT, 0xC812, 0x0307},
+	/* 0x06B1 /cam_sensor_cfg_line_length_pck = 1600 */
+	{MISENSOR_16BIT, 0xC814, 0x0640},
+	/* cam_sensor_cfg_fine_correction = 96 */
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	/* cam_sensor_cfg_cpipe_last_row = 731 */
+	{MISENSOR_16BIT, 0xC818, 0x02DB},
+	{MISENSOR_16BIT, 0xC826, 0x0020}, /* cam_sensor_cfg_reg_0_data = 32 */
+	{MISENSOR_16BIT, 0xC834, 0x0000}, /* cam_sensor_control_read_mode = 0 */
+	{MISENSOR_16BIT, 0xC854, 0x0000}, /* cam_crop_window_xoffset = 0 */
+	{MISENSOR_16BIT, 0xC856, 0x0000}, /* cam_crop_window_yoffset = 0 */
+	{MISENSOR_16BIT, 0xC858, 0x0508}, /* cam_crop_window_width = 1288 */
+	{MISENSOR_16BIT, 0xC85A, 0x02D8}, /* cam_crop_window_height = 728 */
+	{MISENSOR_8BIT, 0xC85C, 0x03}, /* cam_crop_cropmode = 3 */
+	{MISENSOR_16BIT, 0xC868, 0x0508}, /* cam_output_width = 1288 */
+	{MISENSOR_16BIT, 0xC86A, 0x02D8}, /* cam_output_height = 728 */
+	{MISENSOR_8BIT, 0xC878, 0x00}, /* 0x0E //cam_aet_aemode = 0 */
 	{MISENSOR_TOK_TERM, 0, 0}
 };
 
-//[736x496_30fps_768Mbps]
+/* [736x496_30fps_768Mbps] */
 static struct misensor_reg const mt9m114_720_480P_init[] = {
 	{MISENSOR_16BIT, 0x98E, 0x1000},
-	{MISENSOR_8BIT, 0xC97E, 0x01},	  //cam_sysctl_pll_enable = 1
-	{MISENSOR_16BIT, 0xC980, 0x0128}, //cam_sysctl_pll_divider_m_n = 276
-	{MISENSOR_16BIT, 0xC982, 0x0700}, //cam_sysctl_pll_divider_p = 1792
-	{MISENSOR_16BIT, 0xC800, 0x00F0}, //cam_sensor_cfg_y_addr_start = 240
-	{MISENSOR_16BIT, 0xC802, 0x0118}, //cam_sensor_cfg_x_addr_start = 280
-	{MISENSOR_16BIT, 0xC804, 0x02DF}, //cam_sensor_cfg_y_addr_end = 735
-	{MISENSOR_16BIT, 0xC806, 0x03F7}, //cam_sensor_cfg_x_addr_end = 1015
-	{MISENSOR_32BIT, 0xC808, 0x2DC6C00}, //cam_sensor_cfg_pixclk = 48000000
-	{MISENSOR_16BIT, 0xC80C, 0x0001}, //cam_sensor_cfg_row_speed = 1
-	{MISENSOR_16BIT, 0xC80E, 0x00DB}, //cam_sensor_cfg_fine_integ_time_min = 219
-	{MISENSOR_16BIT, 0xC810, 0x05B3}, //0x062E //cam_sensor_cfg_fine_integ_time_max = 1459
-	{MISENSOR_16BIT, 0xC812, 0x03E5}, //0x074C //cam_sensor_cfg_frame_length_lines = 997
-	{MISENSOR_16BIT, 0xC814, 0x0644}, //0x06B1 /cam_sensor_cfg_line_length_pck = 1604
-	{MISENSOR_16BIT, 0xC816, 0x0060}, //cam_sensor_cfg_fine_correction = 96
-	{MISENSOR_16BIT, 0xC818, 0x03C3}, //cam_sensor_cfg_cpipe_last_row = 963
-	{MISENSOR_16BIT, 0xC826, 0x0020}, //cam_sensor_cfg_reg_0_data = 32
-	{MISENSOR_16BIT, 0xC834, 0x0000}, //cam_sensor_control_read_mode = 0
-	{MISENSOR_16BIT, 0xC854, 0x0000}, //cam_crop_window_xoffset = 0
-	{MISENSOR_16BIT, 0xC856, 0x0000}, //cam_crop_window_yoffset = 0
-	{MISENSOR_16BIT, 0xC858, 0x02D8}, //cam_crop_window_width = 728
-	{MISENSOR_16BIT, 0xC85A, 0x01E8}, //cam_crop_window_height = 488
-	{MISENSOR_8BIT, 0xC85C, 0x03}, //cam_crop_cropmode = 3
-	{MISENSOR_16BIT, 0xC868, 0x02D8}, //cam_output_width = 728
-	{MISENSOR_16BIT, 0xC86A, 0x01E8}, //cam_output_height = 488
-	{MISENSOR_8BIT, 0xC878, 0x00}, //0x0E //cam_aet_aemode = 0
+	{MISENSOR_8BIT, 0xC97E, 0x01},	  /* cam_sysctl_pll_enable = 1 */
+	{MISENSOR_16BIT, 0xC980, 0x0128}, /* cam_sysctl_pll_divider_m_n = 276 */
+	{MISENSOR_16BIT, 0xC982, 0x0700}, /* cam_sysctl_pll_divider_p = 1792 */
+	{MISENSOR_16BIT, 0xC800, 0x00F0}, /* cam_sensor_cfg_y_addr_start = 240*/
+	{MISENSOR_16BIT, 0xC802, 0x0118}, /* cam_sensor_cfg_x_addr_start = 280*/
+	{MISENSOR_16BIT, 0xC804, 0x02DF}, /* cam_sensor_cfg_y_addr_end = 735 */
+	{MISENSOR_16BIT, 0xC806, 0x03F7}, /* cam_sensor_cfg_x_addr_end = 1015 */
+	/* cam_sensor_cfg_pixclk = 48000000 */
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001}, /* cam_sensor_cfg_row_speed = 1 */
+	/* cam_sensor_cfg_fine_integ_time_min = 219 */
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	/* 0x062E //cam_sensor_cfg_fine_integ_time_max = 1459 */
+	{MISENSOR_16BIT, 0xC810, 0x05B3},
+	/* 0x074C //cam_sensor_cfg_frame_length_lines = 997 */
+	{MISENSOR_16BIT, 0xC812, 0x03E5},
+	/* 0x06B1 /cam_sensor_cfg_line_length_pck = 1604 */
+	{MISENSOR_16BIT, 0xC814, 0x0644},
+	/* cam_sensor_cfg_fine_correction = 96 */
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3}, /* cam_sensor_cfg_cpipe_last_row=963*/
+	{MISENSOR_16BIT, 0xC826, 0x0020}, /* cam_sensor_cfg_reg_0_data = 32 */
+	{MISENSOR_16BIT, 0xC834, 0x0000}, /* cam_sensor_control_read_mode = 0*/
+	{MISENSOR_16BIT, 0xC854, 0x0000}, /* cam_crop_window_xoffset = 0 */
+	{MISENSOR_16BIT, 0xC856, 0x0000}, /* cam_crop_window_yoffset = 0 */
+	{MISENSOR_16BIT, 0xC858, 0x02D8}, /* cam_crop_window_width = 728 */
+	{MISENSOR_16BIT, 0xC85A, 0x01E8}, /* cam_crop_window_height = 488 */
+	{MISENSOR_8BIT, 0xC85C, 0x03}, /* cam_crop_cropmode = 3 */
+	{MISENSOR_16BIT, 0xC868, 0x02D8}, /* cam_output_width = 728 */
+	{MISENSOR_16BIT, 0xC86A, 0x01E8}, /* cam_output_height = 488 */
+	{MISENSOR_8BIT, 0xC878, 0x00}, /* 0x0E //cam_aet_aemode = 0 */
 	{MISENSOR_TOK_TERM, 0, 0}
 };
 
 static struct misensor_reg const mt9m114_common[] = {
 	/* reset */
 	{MISENSOR_16BIT,  0x301A, 0x0234},
-	//LOAD = Step2-PLL_Timing      //PLL and Timing
-	{MISENSOR_16BIT, 0x098E, 0x1000}, // LOGICAL_ADDRESS_ACCESS
-	{MISENSOR_8BIT, 0xC97E, 0x01},    //cam_sysctl_pll_enable = 1
-	{MISENSOR_16BIT, 0xC980, 0x0128}, //cam_sysctl_pll_divider_m_n = 276
-	{MISENSOR_16BIT, 0xC982, 0x0700}, //cam_sysctl_pll_divider_p = 1792
-	{MISENSOR_16BIT, 0xC800, 0x0000}, //cam_sensor_cfg_y_addr_start = 216
-	{MISENSOR_16BIT, 0xC802, 0x0000}, //cam_sensor_cfg_x_addr_start = 168
-	{MISENSOR_16BIT, 0xC804, 0x03CD}, //cam_sensor_cfg_y_addr_end = 761
-	{MISENSOR_16BIT, 0xC806, 0x050D}, //cam_sensor_cfg_x_addr_end = 1127
-	{MISENSOR_16BIT, 0xC808, 0x02DC}, //cam_sensor_cfg_pixclk = 24000000
+	/* LOAD = Step2-PLL_Timing      //PLL and Timing */
+	{MISENSOR_16BIT, 0x098E, 0x1000}, /* LOGICAL_ADDRESS_ACCESS */
+	{MISENSOR_8BIT, 0xC97E, 0x01},    /* cam_sysctl_pll_enable = 1 */
+	{MISENSOR_16BIT, 0xC980, 0x0128}, /* cam_sysctl_pll_divider_m_n = 276 */
+	{MISENSOR_16BIT, 0xC982, 0x0700}, /* cam_sysctl_pll_divider_p = 1792 */
+	{MISENSOR_16BIT, 0xC800, 0x0000}, /* cam_sensor_cfg_y_addr_start = 216*/
+	{MISENSOR_16BIT, 0xC802, 0x0000}, /* cam_sensor_cfg_x_addr_start = 168*/
+	{MISENSOR_16BIT, 0xC804, 0x03CD}, /* cam_sensor_cfg_y_addr_end = 761 */
+	{MISENSOR_16BIT, 0xC806, 0x050D}, /* cam_sensor_cfg_x_addr_end = 1127 */
+	{MISENSOR_16BIT, 0xC808, 0x02DC}, /* cam_sensor_cfg_pixclk = 24000000 */
 	{MISENSOR_16BIT, 0xC80A, 0x6C00},
-	{MISENSOR_16BIT, 0xC80C, 0x0001}, //cam_sensor_cfg_row_speed = 1
-	{MISENSOR_16BIT, 0xC80E, 0x01C3}, //cam_sensor_cfg_fine_integ_time_min = 219
-	{MISENSOR_16BIT, 0xC810, 0x03F7}, //cam_sensor_cfg_fine_integ_time_max = 1149
-	{MISENSOR_16BIT, 0xC812, 0x0500}, //cam_sensor_cfg_frame_length_lines = 625
-	{MISENSOR_16BIT, 0xC814, 0x04E2}, //cam_sensor_cfg_line_length_pck = 1280
-	{MISENSOR_16BIT, 0xC816, 0x00E0}, //cam_sensor_cfg_fine_correction = 96
-	{MISENSOR_16BIT, 0xC818, 0x01E3}, //cam_sensor_cfg_cpipe_last_row = 541
-	{MISENSOR_16BIT, 0xC826, 0x0020}, //cam_sensor_cfg_reg_0_data = 32
-	{MISENSOR_16BIT, 0xC834, 0x0330}, //cam_sensor_control_read_mode = 0
-	{MISENSOR_16BIT, 0xC854, 0x0000}, //cam_crop_window_xoffset = 0
-	{MISENSOR_16BIT, 0xC856, 0x0000}, //cam_crop_window_yoffset = 0
-	{MISENSOR_16BIT, 0xC858, 0x0280}, //cam_crop_window_width = 952
-	{MISENSOR_16BIT, 0xC85A, 0x01E0}, //cam_crop_window_height = 538
-	{MISENSOR_8BIT, 0xC85C, 0x03},    //cam_crop_cropmode = 3
-	{MISENSOR_16BIT, 0xC868, 0x0280}, //cam_output_width = 952
-	{MISENSOR_16BIT, 0xC86A, 0x01E0}, //cam_output_height = 538
-	//LOAD = Step3-Recommended     //Patch,Errata and Sensor optimization Setting
-	{MISENSOR_16BIT, 0x316A, 0x8270}, // DAC_TXLO_ROW
-	{MISENSOR_16BIT, 0x316C, 0x8270}, // DAC_TXLO
-	{MISENSOR_16BIT, 0x3ED0, 0x2305}, // DAC_LD_4_5
-	{MISENSOR_16BIT, 0x3ED2, 0x77CF}, // DAC_LD_6_7
-	{MISENSOR_16BIT, 0x316E, 0x8202}, // DAC_ECL
-	{MISENSOR_16BIT, 0x3180, 0x87FF}, // DELTA_DK_CONTROL
-	{MISENSOR_16BIT, 0x30D4, 0x6080}, // COLUMN_CORRECTION
-	{MISENSOR_16BIT, 0xA802, 0x0008}, // AE_TRACK_MODE
-	{MISENSOR_16BIT, 0x3E14, 0xFF39}, // SAMP_COL_PUP2
-	{MISENSOR_16BIT, 0x31E0, 0x0003}, // PIX_DEF_ID
-	//LOAD = Step8-Features		//Ports, special features, etc.
-	{MISENSOR_16BIT, 0x098E, 0x0000}, // LOGICAL_ADDRESS_ACCESS
-	{MISENSOR_16BIT, 0x001E, 0x0777}, // PAD_SLEW
-	{MISENSOR_16BIT, 0x098E, 0x0000}, // LOGICAL_ADDRESS_ACCESS
-	{MISENSOR_16BIT, 0xC984, 0x8001}, // CAM_PORT_OUTPUT_CONTROL
-	{MISENSOR_16BIT, 0xC988, 0x0F00}, // CAM_PORT_MIPI_TIMING_T_HS_ZERO
-	{MISENSOR_16BIT, 0xC98A, 0x0B07}, // CAM_PORT_MIPI_TIMING_T_HS_EXIT_HS_TRAIL
-	{MISENSOR_16BIT, 0xC98C, 0x0D01}, // CAM_PORT_MIPI_TIMING_T_CLK_POST_CLK_PRE
-	{MISENSOR_16BIT, 0xC98E, 0x071D}, // CAM_PORT_MIPI_TIMING_T_CLK_TRAIL_CLK_ZERO
-	{MISENSOR_16BIT, 0xC990, 0x0006}, // CAM_PORT_MIPI_TIMING_T_LPX
-	{MISENSOR_16BIT, 0xC992, 0x0A0C}, // CAM_PORT_MIPI_TIMING_INIT_TIMING
-	{MISENSOR_16BIT, 0x3C5A, 0x0009}, // MIPI_DELAY_TRIM
-	{MISENSOR_16BIT, 0xC86C, 0x0210}, // CAM_OUTPUT_FORMAT
-	{MISENSOR_16BIT, 0xA804, 0x0000}, // AE_TRACK_ALGO
-	//default exposure
-	{MISENSOR_16BIT, 0x3012, 0x0110}, // COMMAND_REGISTER
+	{MISENSOR_16BIT, 0xC80C, 0x0001}, /* cam_sensor_cfg_row_speed = 1 */
+	/* cam_sensor_cfg_fine_integ_time_min = 219 */
+	{MISENSOR_16BIT, 0xC80E, 0x01C3},
+	/* cam_sensor_cfg_fine_integ_time_max = 1149 */
+	{MISENSOR_16BIT, 0xC810, 0x03F7},
+	/* cam_sensor_cfg_frame_length_lines = 625 */
+	{MISENSOR_16BIT, 0xC812, 0x0500},
+	/* cam_sensor_cfg_line_length_pck = 1280 */
+	{MISENSOR_16BIT, 0xC814, 0x04E2},
+	/* cam_sensor_cfg_fine_correction = 96 */
+	{MISENSOR_16BIT, 0xC816, 0x00E0},
+	/* cam_sensor_cfg_cpipe_last_row = 541 */
+	{MISENSOR_16BIT, 0xC818, 0x01E3},
+	{MISENSOR_16BIT, 0xC826, 0x0020}, /* cam_sensor_cfg_reg_0_data = 32 */
+	{MISENSOR_16BIT, 0xC834, 0x0330}, /* cam_sensor_control_read_mode = 0 */
+	{MISENSOR_16BIT, 0xC854, 0x0000}, /* cam_crop_window_xoffset = 0 */
+	{MISENSOR_16BIT, 0xC856, 0x0000}, /* cam_crop_window_yoffset = 0 */
+	{MISENSOR_16BIT, 0xC858, 0x0280}, /* cam_crop_window_width = 952 */
+	{MISENSOR_16BIT, 0xC85A, 0x01E0}, /* cam_crop_window_height = 538 */
+	{MISENSOR_8BIT, 0xC85C, 0x03},    /* cam_crop_cropmode = 3 */
+	{MISENSOR_16BIT, 0xC868, 0x0280}, /* cam_output_width = 952 */
+	{MISENSOR_16BIT, 0xC86A, 0x01E0}, /* cam_output_height = 538 */
+	/* LOAD = Step3-Recommended
+	 * Patch,Errata and Sensor optimization Setting */
+	{MISENSOR_16BIT, 0x316A, 0x8270}, /* DAC_TXLO_ROW */
+	{MISENSOR_16BIT, 0x316C, 0x8270}, /* DAC_TXLO */
+	{MISENSOR_16BIT, 0x3ED0, 0x2305}, /* DAC_LD_4_5 */
+	{MISENSOR_16BIT, 0x3ED2, 0x77CF}, /* DAC_LD_6_7 */
+	{MISENSOR_16BIT, 0x316E, 0x8202}, /* DAC_ECL */
+	{MISENSOR_16BIT, 0x3180, 0x87FF}, /* DELTA_DK_CONTROL */
+	{MISENSOR_16BIT, 0x30D4, 0x6080}, /* COLUMN_CORRECTION */
+	{MISENSOR_16BIT, 0xA802, 0x0008}, /* AE_TRACK_MODE */
+	{MISENSOR_16BIT, 0x3E14, 0xFF39}, /* SAMP_COL_PUP2 */
+	{MISENSOR_16BIT, 0x31E0, 0x0003}, /* PIX_DEF_ID */
+	/* LOAD = Step8-Features	//Ports, special features, etc. */
+	{MISENSOR_16BIT, 0x098E, 0x0000}, /* LOGICAL_ADDRESS_ACCESS */
+	{MISENSOR_16BIT, 0x001E, 0x0777}, /* PAD_SLEW */
+	{MISENSOR_16BIT, 0x098E, 0x0000}, /* LOGICAL_ADDRESS_ACCESS */
+	{MISENSOR_16BIT, 0xC984, 0x8001}, /* CAM_PORT_OUTPUT_CONTROL */
+	{MISENSOR_16BIT, 0xC988, 0x0F00}, /* CAM_PORT_MIPI_TIMING_T_HS_ZERO */
+	/* CAM_PORT_MIPI_TIMING_T_HS_EXIT_HS_TRAIL */
+	{MISENSOR_16BIT, 0xC98A, 0x0B07},
+	/* CAM_PORT_MIPI_TIMING_T_CLK_POST_CLK_PRE */
+	{MISENSOR_16BIT, 0xC98C, 0x0D01},
+	/* CAM_PORT_MIPI_TIMING_T_CLK_TRAIL_CLK_ZERO */
+	{MISENSOR_16BIT, 0xC98E, 0x071D},
+	{MISENSOR_16BIT, 0xC990, 0x0006}, /* CAM_PORT_MIPI_TIMING_T_LPX */
+	{MISENSOR_16BIT, 0xC992, 0x0A0C}, /* CAM_PORT_MIPI_TIMING_INIT_TIMING */
+	{MISENSOR_16BIT, 0x3C5A, 0x0009}, /* MIPI_DELAY_TRIM */
+	{MISENSOR_16BIT, 0xC86C, 0x0210}, /* CAM_OUTPUT_FORMAT */
+	{MISENSOR_16BIT, 0xA804, 0x0000}, /* AE_TRACK_ALGO */
+	/* default exposure */
+	{MISENSOR_16BIT, 0x3012, 0x0110}, /* COMMAND_REGISTER */
 	{MISENSOR_TOK_TERM, 0, 0},
 
 };
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov2722.c b/drivers/external_drivers/camera/drivers/media/i2c/ov2722.c
index e9c6d58..8e5f208 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov2722.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov2722.c
@@ -408,7 +408,7 @@ static long __ov2722_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 		return ret;
 
 	hts = dev->pixels_per_line;
-	vts = dev->lines_per_frame;;
+	vts = dev->lines_per_frame;
 
 	if ((coarse_itg + OV2722_COARSE_INTG_TIME_MAX_MARGIN) > vts)
 		vts = coarse_itg + OV2722_COARSE_INTG_TIME_MAX_MARGIN;
@@ -611,8 +611,8 @@ struct ov2722_control ov2722_controls[] = {
 
 static int ov2722_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
-	struct ov2722_device *dev = container_of(ctrl->handler, struct ov2722_device,
-			ctrl_handler);
+	struct ov2722_device *dev = container_of(ctrl->handler,
+			struct ov2722_device, ctrl_handler);
 	unsigned int val;
 
 	switch (ctrl->id) {
@@ -726,7 +726,7 @@ static int power_ctrl(struct v4l2_subdev *sd, bool flag)
 		if (ret == 0) {
 			ret = dev->platform_data->v1p8_ctrl(sd, 1);
 			if (ret)
-			   dev->platform_data->v2p8_ctrl(sd, 0);
+				dev->platform_data->v2p8_ctrl(sd, 0);
 		}
 	} else {
 		ret = dev->platform_data->v1p8_ctrl(sd, 0);
@@ -1430,9 +1430,8 @@ static int __ov2722_init_ctrl_handler(struct ov2722_device *dev)
 					      &v4l2_ctrl_link_freq,
 					      NULL);
 
-	if (dev->ctrl_handler.error || dev->link_freq == NULL) {
+	if (dev->ctrl_handler.error || dev->link_freq == NULL)
 		return dev->ctrl_handler.error;
-	}
 
 	dev->sd.ctrl_handler = hdl;
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c
old mode 100755
new mode 100644
index c5fbf99..6745f2a
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.c
@@ -236,12 +236,12 @@ static int vcm_detect(struct i2c_client *client)
 {
 	int i, ret;
 	struct i2c_msg msg;
-        u16 data0=0, data;
-	for(i=0; i<4; i++) {
+	u16 data0 = 0, data;
+	for (i = 0; i < 4; i++) {
 		msg.addr = VCM_ADDR;
 		msg.flags = I2C_M_RD;
 		msg.len = sizeof(data);
-		msg.buf = (u8*)&data;
+		msg.buf = (u8 *)&data;
 		ret = i2c_transfer(client->adapter, &msg, 1);
 
 		/* DW9714 always fails the first read and returns
@@ -400,8 +400,9 @@ static int ov5693_write_reg_array(struct i2c_client *client,
 			}
 			err = __ov5693_buf_reg_array(client, &ctrl, next);
 			if (err) {
-				dev_err(&client->dev, "%s: write error, aborted\n",
-					 __func__);
+				dev_err(&client->dev,
+					"%s: write error, aborted\n",
+					__func__);
 				return err;
 			}
 			break;
@@ -509,13 +510,13 @@ static int ov5693_get_intg_factor(struct i2c_client *client,
 	buf->crop_vertical_end = reg_val;
 
 	ret = ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_HORIZONTAL_OUTPUT_SIZE_H, &reg_val);
+				OV5693_HORIZONTAL_OUTPUT_SIZE_H, &reg_val);
 	if (ret)
 		return ret;
 	buf->output_width = reg_val;
 
 	ret = ov5693_read_reg(client, OV5693_16BIT,
-					OV5693_VERTICAL_OUTPUT_SIZE_H, &reg_val);
+				OV5693_VERTICAL_OUTPUT_SIZE_H, &reg_val);
 	if (ret)
 		return ret;
 	buf->output_height = reg_val;
@@ -533,15 +534,15 @@ static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct ov5693_device *dev = to_ov5693_sensor(sd);
-	u16 vts,hts;
-	int ret,exp_val;
+	u16 vts, hts;
+	int ret, exp_val;
 
 	hts = ov5693_res[dev->fmt_idx].pixels_per_line;
 	vts = ov5693_res[dev->fmt_idx].lines_per_frame;
 
 	/* group hold */
 	ret = ov5693_write_reg(client, OV5693_8BIT,
-                                       OV5693_GROUP_ACCESS, 0x00);
+				       OV5693_GROUP_ACCESS, 0x00);
 	if (ret) {
 		dev_err(&client->dev, "%s: write %x error, aborted\n",
 			__func__, OV5693_GROUP_ACCESS);
@@ -552,14 +553,16 @@ static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 	if (coarse_itg > vts - OV5693_INTEGRATION_TIME_MARGIN)
 		vts = (u16) coarse_itg + OV5693_INTEGRATION_TIME_MARGIN;
 
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_TIMING_VTS_H, (vts >> 8) & 0xFF);
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+				OV5693_TIMING_VTS_H, (vts >> 8) & 0xFF);
 	if (ret) {
 		dev_err(&client->dev, "%s: write %x error, aborted\n",
 			__func__, OV5693_TIMING_VTS_H);
 		return ret;
 	}
 
-	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_TIMING_VTS_L, vts & 0xFF);
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+				OV5693_TIMING_VTS_L, vts & 0xFF);
 	if (ret) {
 		dev_err(&client->dev, "%s: write %x error, aborted\n",
 			__func__, OV5693_TIMING_VTS_L);
@@ -607,15 +610,17 @@ static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
 		int setvalue = 0;
 
 		/*
-		*  for sensor metadata only support 1x/2x digital gain, to support
-		*  sensor metadata we need switch from MWB gain to digital gain
+		*  for sensor metadata only support 1x/2x digital gain,
+		*  to support sensor metadata we need switch from MWB gain
+		*  to digital gain
 		*/
 		if (digitgain == 2048)
 			setvalue = 1;
 		else
 			setvalue = 0;
 
-		ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_AGC_H, setvalue);
+		ret = ov5693_write_reg(client, OV5693_8BIT,
+					OV5693_AGC_H, setvalue);
 		if (ret) {
 			dev_err(&client->dev, "%s: write %x error, aborted\n",
 				__func__, OV5693_AGC_H);
@@ -889,7 +894,8 @@ int ad5823_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
 		return ret;
 
 	/* set reg VCM_CODE_MSB Bit[1:0] */
-	vcm_code = (vcm_code & VCM_CODE_MSB_MASK) | ((val >> 8) & ~VCM_CODE_MSB_MASK);
+	vcm_code = (vcm_code & VCM_CODE_MSB_MASK) |
+		((val >> 8) & ~VCM_CODE_MSB_MASK);
 	ret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_MSB, vcm_code);
 	if (ret)
 		return ret;
@@ -1241,7 +1247,7 @@ static int ov5693_init(struct v4l2_subdev *sd)
 	dev->vcm_update = false;
 
 	if (dev->vcm == VCM_AD5823) {
-		ret = vcm_ad_i2c_wr8(client, 0x01, 0x01); // vcm init test
+		ret = vcm_ad_i2c_wr8(client, 0x01, 0x01); /* vcm init test */
 		if (ret)
 			dev_err(&client->dev,
 				"vcm reset failed\n");
@@ -1251,7 +1257,8 @@ static int ov5693_init(struct v4l2_subdev *sd)
 		if (ret)
 			dev_err(&client->dev,
 				"vcm enable ringing failed\n");
-		ret = ad5823_i2c_write(client, AD5823_REG_MODE, AD5823_ARC_RES1);
+		ret = ad5823_i2c_write(client, AD5823_REG_MODE,
+					AD5823_ARC_RES1);
 		if (ret)
 			dev_err(&client->dev,
 				"vcm change mode failed\n");
@@ -1262,7 +1269,7 @@ static int ov5693_init(struct v4l2_subdev *sd)
 	N_RES = N_RES_PREVIEW;
 
 	/*change initial focus value for ad5823*/
-	if(dev->vcm == VCM_AD5823) {
+	if (dev->vcm == VCM_AD5823) {
 		dev->focus = AD5823_INIT_FOCUS_POS;
 		ov5693_t_focus_abs(sd, AD5823_INIT_FOCUS_POS);
 	} else {
@@ -1970,7 +1977,8 @@ static int ov5693_probe(struct i2c_client *client,
 	 * via config. */
 	i2c = gmin_get_var_int(&client->dev, "I2CAddr", -1);
 	if (i2c != -1) {
-		dev_info(&client->dev, "Overriding firmware-provided I2C address (0x%x) with 0x%x\n",
+		dev_info(&client->dev,
+		"Overriding firmware-provided I2C address (0x%x) with 0x%x\n",
 			 client->addr, i2c);
 		client->addr = i2c;
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h
index 85b28a0..3d88d95 100755
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693-ecs/ov5693.h
@@ -94,36 +94,44 @@
 #define OV5693_SC_CMMN_CHIP_ID_L		0x300B
 #define OV5693_SC_CMMN_SCCB_ID			0x300C
 #define OV5693_SC_CMMN_SUB_ID			0x302A /* process, version*/
+/*Bit[7:4] Group control, Bit[3:0] Group ID*/
+#define OV5693_GROUP_ACCESS			0x3208
+/*
+*Bit[3:0] Bit[19:16] of exposure,
+*remaining 16 bits lies in Reg0x3501&Reg0x3502
+*/
+#define OV5693_EXPOSURE_H			0x3500
+#define OV5693_EXPOSURE_M			0x3501
+#define OV5693_EXPOSURE_L			0x3502
+/*Bit[1:0] means Bit[9:8] of gain*/
+#define OV5693_AGC_H				0x350A
+#define OV5693_AGC_L				0x350B /*Bit[7:0] of gain*/
 
-#define OV5693_GROUP_ACCESS							0x3208 /*Bit[7:4] Group control, Bit[3:0] Group ID*/
-
-#define OV5693_EXPOSURE_H							0x3500 /*Bit[3:0] Bit[19:16] of exposure, remaining 16 bits lies in Reg0x3501&Reg0x3502*/
-#define OV5693_EXPOSURE_M							0x3501
-#define OV5693_EXPOSURE_L							0x3502
-#define OV5693_AGC_H								0x350A /*Bit[1:0] means Bit[9:8] of gain*/
-#define OV5693_AGC_L								0x350B /*Bit[7:0] of gain*/
-
-#define OV5693_HORIZONTAL_START_H					0x3800 /*Bit[11:8]*/
-#define OV5693_HORIZONTAL_START_L					0x3801 /*Bit[7:0]*/
-#define OV5693_VERTICAL_START_H						0x3802 /*Bit[11:8]*/
-#define OV5693_VERTICAL_START_L						0x3803 /*Bit[7:0]*/
-#define OV5693_HORIZONTAL_END_H						0x3804 /*Bit[11:8]*/
-#define OV5693_HORIZONTAL_END_L						0x3805 /*Bit[7:0]*/
-#define OV5693_VERTICAL_END_H						0x3806 /*Bit[11:8]*/
-#define OV5693_VERTICAL_END_L						0x3807 /*Bit[7:0]*/
-#define OV5693_HORIZONTAL_OUTPUT_SIZE_H				0x3808 /*Bit[3:0]*/
-#define OV5693_HORIZONTAL_OUTPUT_SIZE_L				0x3809 /*Bit[7:0]*/
-#define OV5693_VERTICAL_OUTPUT_SIZE_H				0x380a /*Bit[3:0]*/
-#define OV5693_VERTICAL_OUTPUT_SIZE_L				0x380b /*Bit[7:0]*/
-#define OV5693_TIMING_HTS_H							0x380C  /*High 8-bit, and low 8-bit HTS address is 0x380d*/
-#define OV5693_TIMING_HTS_L							0x380D  /*High 8-bit, and low 8-bit HTS address is 0x380d*/
-#define OV5693_TIMING_VTS_H							0x380e  /*High 8-bit, and low 8-bit HTS address is 0x380f*/
-#define OV5693_TIMING_VTS_L							0x380f  /*High 8-bit, and low 8-bit HTS address is 0x380f*/
+#define OV5693_HORIZONTAL_START_H		0x3800 /*Bit[11:8]*/
+#define OV5693_HORIZONTAL_START_L		0x3801 /*Bit[7:0]*/
+#define OV5693_VERTICAL_START_H			0x3802 /*Bit[11:8]*/
+#define OV5693_VERTICAL_START_L			0x3803 /*Bit[7:0]*/
+#define OV5693_HORIZONTAL_END_H			0x3804 /*Bit[11:8]*/
+#define OV5693_HORIZONTAL_END_L			0x3805 /*Bit[7:0]*/
+#define OV5693_VERTICAL_END_H			0x3806 /*Bit[11:8]*/
+#define OV5693_VERTICAL_END_L			0x3807 /*Bit[7:0]*/
+#define OV5693_HORIZONTAL_OUTPUT_SIZE_H		0x3808 /*Bit[3:0]*/
+#define OV5693_HORIZONTAL_OUTPUT_SIZE_L		0x3809 /*Bit[7:0]*/
+#define OV5693_VERTICAL_OUTPUT_SIZE_H		0x380a /*Bit[3:0]*/
+#define OV5693_VERTICAL_OUTPUT_SIZE_L		0x380b /*Bit[7:0]*/
+/*High 8-bit, and low 8-bit HTS address is 0x380d*/
+#define OV5693_TIMING_HTS_H			0x380C
+/*High 8-bit, and low 8-bit HTS address is 0x380d*/
+#define OV5693_TIMING_HTS_L			0x380D
+/*High 8-bit, and low 8-bit HTS address is 0x380f*/
+#define OV5693_TIMING_VTS_H			0x380e
+/*High 8-bit, and low 8-bit HTS address is 0x380f*/
+#define OV5693_TIMING_VTS_L			0x380f
 
 #define OV5693_MWB_RED_GAIN_H			0x3400
 #define OV5693_MWB_GREEN_GAIN_H			0x3402
 #define OV5693_MWB_BLUE_GAIN_H			0x3404
-#define OV5693_MWB_GAIN_MAX				0x0fff
+#define OV5693_MWB_GAIN_MAX			0x0fff
 
 #define OV5693_START_STREAMING			0x01
 #define OV5693_STOP_STREAMING			0x00
@@ -206,9 +214,9 @@ struct ov5693_control {
 };
 
 enum vcm_type {
-       VCM_UNKNOWN,
-       VCM_AD5823,
-       VCM_DW9714,
+	VCM_UNKNOWN,
+	VCM_AD5823,
+	VCM_DW9714,
 };
 
 /*
@@ -550,9 +558,9 @@ static struct ov5693_reg const ov5693_736x496[] = {
 	{OV5693_8BIT, 0x3809, 0xe0},
 	{OV5693_8BIT, 0x380a, 0x01},
 	{OV5693_8BIT, 0x380b, 0xf0},
-	{OV5693_8BIT, 0x380c, 0x0a}, //hts
+	{OV5693_8BIT, 0x380c, 0x0a}, /*hts*/
 	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07}, //vts
+	{OV5693_8BIT, 0x380e, 0x07}, /*vts*/
 	{OV5693_8BIT, 0x380f, 0xc0},
 	{OV5693_8BIT, 0x3811, 0x08},
 	{OV5693_8BIT, 0x3813, 0x02},
@@ -578,9 +586,9 @@ static struct ov5693_reg const ov5693_736x496[] = {
 	{OV5693_8BIT, 0x3809, 0xe0},
 	{OV5693_8BIT, 0x380a, 0x01},
 	{OV5693_8BIT, 0x380b, 0xf0},
-	{OV5693_8BIT, 0x380c, 0x0d}, //hts
+	{OV5693_8BIT, 0x380c, 0x0d},
 	{OV5693_8BIT, 0x380d, 0xb0},
-	{OV5693_8BIT, 0x380e, 0x05}, //vts
+	{OV5693_8BIT, 0x380e, 0x05},
 	{OV5693_8BIT, 0x380f, 0xf2},
 	{OV5693_8BIT, 0x3811, 0x08},
 	{OV5693_8BIT, 0x3813, 0x02},
@@ -635,9 +643,9 @@ static struct ov5693_reg const ov5693_1296x736[] = {
 	{OV5693_8BIT, 0x3809, 0x10},
 	{OV5693_8BIT, 0x380a, 0x02},
 	{OV5693_8BIT, 0x380b, 0xe0},
-	{OV5693_8BIT, 0x380c, 0x0d}, //hts
+	{OV5693_8BIT, 0x380c, 0x0d}, /*hts*/
 	{OV5693_8BIT, 0x380d, 0xb0},
-	{OV5693_8BIT, 0x380e, 0x05}, //vts
+	{OV5693_8BIT, 0x380e, 0x05}, /*vts*/
 	{OV5693_8BIT, 0x380f, 0xf2},
 	{OV5693_8BIT, 0x3811, 0x08},
 	{OV5693_8BIT, 0x3813, 0x02},
@@ -662,9 +670,9 @@ static struct ov5693_reg const ov5693_1636p_30fps[] = {
 	{OV5693_8BIT, 0x3809, 0x64},
 	{OV5693_8BIT, 0x380a, 0x04},
 	{OV5693_8BIT, 0x380b, 0x48},
-	{OV5693_8BIT, 0x380c, 0x0a}, //hts
+	{OV5693_8BIT, 0x380c, 0x0a}, /*hts*/
 	{OV5693_8BIT, 0x380d, 0x80},
-	{OV5693_8BIT, 0x380e, 0x07}, //vts
+	{OV5693_8BIT, 0x380e, 0x07}, /*vts*/
 	{OV5693_8BIT, 0x380f, 0xc0},
 	{OV5693_8BIT, 0x3811, 0x02},
 	{OV5693_8BIT, 0x3813, 0x02},
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
index db31578..e0707c0 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
@@ -128,7 +128,8 @@ int ad5823_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
 		return ret;
 
 	/* set reg VCM_CODE_MSB Bit[1:0] */
-	vcm_code = (vcm_code & VCM_CODE_MSB_MASK) | ((val >> 8) & ~VCM_CODE_MSB_MASK);
+	vcm_code = (vcm_code & VCM_CODE_MSB_MASK) |
+			((val >> 8) & ~VCM_CODE_MSB_MASK);
 	ret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_MSB, vcm_code);
 	if (ret)
 		return ret;
@@ -201,7 +202,7 @@ int ad5823_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
 	if (val & ATOMISP_FOCUS_STATUS_MOVING)
 		*value  = ad5823_dev.focus - ad5823_dev.number_of_steps;
 	else
-		*value  = ad5823_dev.focus ;
+		*value  = ad5823_dev.focus;
 
 	return 0;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
index e494183..b4d0ae7 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
@@ -897,7 +897,8 @@ static int ov5693_s_mbus_fmt(struct v4l2_subdev *sd,
 		goto done;
 	}
 
-	ret = ov5693_write_reg_array(client, dev->ov5693_res[dev->fmt_idx].regs);
+	ret = ov5693_write_reg_array(client,
+					dev->ov5693_res[dev->fmt_idx].regs);
 	if (ret) {
 		dev_err(&client->dev, "ov5693 write fmt register err.\n");
 		goto done;
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
old mode 100755
new mode 100644
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
index 9943e48..9511d62 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
@@ -595,9 +595,8 @@ static int __ov8830_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
 		gain,
 		dig_gain);
 
-	if (!(exposure && gain)) {
+	if (!(exposure && gain))
 		return 0;
-	}
 
 	/* Update frame timings. Expsure must be minimum <  vts-14 */
 	ret = __ov8830_update_frame_timing(sd, exposure, hts, vts);
@@ -771,7 +770,7 @@ static int power_up(struct v4l2_subdev *sd)
 
 	/* Minumum delay is 8192 clock cycles before first i2c transaction,
 	 * which is 1.37 ms at the lowest allowed clock rate 6 MHz */
-	msleep(2);
+	msleep(20);
 	return 0;
 
 fail_clk:
@@ -1164,11 +1163,11 @@ static int __ov8830_try_mbus_fmt(struct v4l2_subdev *sd,
 	} else {
 		idx = nearest_resolution_index(sd, fmt->width, fmt->height);
 
-		/*
-		 * nearest_resolution_index() doesn't return smaller resolutions.
-		 * If it fails, it means the requested resolution is higher than we
-		 * can support. Fallback to highest possible resolution in this case.
-		 */
+	/*
+	 * nearest_resolution_index() doesn't return smaller resolutions.
+	 * If it fails, it means the requested resolution is higher than we
+	 * can support. Fallback to highest possible resolution in this case.
+	 */
 		if (idx == -1)
 			idx = dev->entries_curr_table - 1;
 
@@ -1815,10 +1814,13 @@ static const struct v4l2_ctrl_config ctrls[] = {
 		.id = V4L2_CID_FOCAL_ABSOLUTE,
 		.name = "Focal lenght",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = (OV8830_FOCAL_LENGTH_NUM << 16) | OV8830_FOCAL_LENGTH_DEM,
-		.max = (OV8830_FOCAL_LENGTH_NUM << 16) | OV8830_FOCAL_LENGTH_DEM,
+		.min = (OV8830_FOCAL_LENGTH_NUM << 16) |
+						OV8830_FOCAL_LENGTH_DEM,
+		.max = (OV8830_FOCAL_LENGTH_NUM << 16) |
+						OV8830_FOCAL_LENGTH_DEM,
 		.step = 1,
-		.def = (OV8830_FOCAL_LENGTH_NUM << 16) | OV8830_FOCAL_LENGTH_DEM,
+		.def = (OV8830_FOCAL_LENGTH_NUM << 16) |
+						OV8830_FOCAL_LENGTH_DEM,
 		.flags = V4L2_CTRL_FLAG_READ_ONLY,
 	}, {
 		/* This one is crap, too. For compatibility use only. */
@@ -1826,10 +1828,13 @@ static const struct v4l2_ctrl_config ctrls[] = {
 		.id = V4L2_CID_FNUMBER_ABSOLUTE,
 		.name = "F-number",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = (OV8830_F_NUMBER_DEFAULT_NUM << 16) | OV8830_F_NUMBER_DEM,
-		.max = (OV8830_F_NUMBER_DEFAULT_NUM << 16) | OV8830_F_NUMBER_DEM,
+		.min = (OV8830_F_NUMBER_DEFAULT_NUM << 16) |
+			OV8830_F_NUMBER_DEM,
+		.max = (OV8830_F_NUMBER_DEFAULT_NUM << 16) |
+			OV8830_F_NUMBER_DEM,
 		.step = 1,
-		.def = (OV8830_F_NUMBER_DEFAULT_NUM << 16) | OV8830_F_NUMBER_DEM,
+		.def = (OV8830_F_NUMBER_DEFAULT_NUM << 16) |
+			OV8830_F_NUMBER_DEM,
 		.flags = V4L2_CTRL_FLAG_READ_ONLY,
 	}, {
 		/*
@@ -1840,10 +1845,19 @@ static const struct v4l2_ctrl_config ctrls[] = {
 		.id = V4L2_CID_FNUMBER_RANGE,
 		.name = "F-number range",
 		.type = V4L2_CTRL_TYPE_INTEGER,
-		.min = (OV8830_F_NUMBER_DEFAULT_NUM << 24) | (OV8830_F_NUMBER_DEM << 16) | (OV8830_F_NUMBER_DEFAULT_NUM << 8) | OV8830_F_NUMBER_DEM,
-		.max = (OV8830_F_NUMBER_DEFAULT_NUM << 24) | (OV8830_F_NUMBER_DEM << 16) | (OV8830_F_NUMBER_DEFAULT_NUM << 8) | OV8830_F_NUMBER_DEM,
+		.min = (OV8830_F_NUMBER_DEFAULT_NUM << 24) |
+			(OV8830_F_NUMBER_DEM << 16) |
+			(OV8830_F_NUMBER_DEFAULT_NUM << 8) |
+			OV8830_F_NUMBER_DEM,
+		.max = (OV8830_F_NUMBER_DEFAULT_NUM << 24) |
+			(OV8830_F_NUMBER_DEM << 16) |
+			(OV8830_F_NUMBER_DEFAULT_NUM << 8) |
+			OV8830_F_NUMBER_DEM,
 		.step = 1,
-		.def = (OV8830_F_NUMBER_DEFAULT_NUM << 24) | (OV8830_F_NUMBER_DEM << 16) | (OV8830_F_NUMBER_DEFAULT_NUM << 8) | OV8830_F_NUMBER_DEM,
+		.def = (OV8830_F_NUMBER_DEFAULT_NUM << 24) |
+			(OV8830_F_NUMBER_DEM << 16) |
+			(OV8830_F_NUMBER_DEFAULT_NUM << 8) |
+			OV8830_F_NUMBER_DEM,
 		.flags = V4L2_CTRL_FLAG_READ_ONLY,
 	}, {
 		.ops = &ctrl_ops,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
index f720aae..6642b58 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
@@ -340,7 +340,8 @@ static int __ov8858_update_frame_timing(struct v4l2_subdev *sd,
 		__func__, *hts);
 
 	/* HTS = pixel_per_line / 2 */
-	ret = ov8858_write_reg(client, OV8858_16BIT, OV8858_TIMING_HTS, *hts >> 1);
+	ret = ov8858_write_reg(client, OV8858_16BIT,
+				OV8858_TIMING_HTS, *hts >> 1);
 	if (ret)
 		return ret;
 	dev_dbg(&client->dev, "%s OV8858_TIMING_VTS=0x%04x\n",
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
index 417263c..310335d 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
@@ -694,7 +694,8 @@ static const struct ov8858_reg ov8858_BasicSettings[] = {
 	{OV8858_8BIT, 0x578F, 0x01}, /* DPC CTRL0F */
 	{OV8858_8BIT, 0x5790, 0x01}, /* DPC CTRL10 */
 	{OV8858_8BIT, 0x5901, 0x00}, /* VAP CTRL01 = default */
-	{OV8858_8BIT, 0x5A08, 0x00}, /* WINC CTRL08 = embedded data in 1st line*/
+	/* WINC CTRL08 = embedded data in 1st line*/
+	{OV8858_8BIT, 0x5A08, 0x00},
 	{OV8858_8BIT, 0x5B00, 0x02}, /* OTP CTRL00 */
 	{OV8858_8BIT, 0x5B01, 0x10}, /* OTP CTRL01 */
 	{OV8858_8BIT, 0x5B02, 0x03}, /* OTP CTRL02 */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/pixter.c b/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
index 3ea0f2a..b9974ad 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
@@ -45,7 +45,8 @@ static struct pixter_format_bridge format_bridge[] = {
 	{"GRBG8", V4L2_MBUS_FMT_SGRBG8_1X8, ATOMISP_INPUT_FORMAT_RAW_8, 8},
 	{"GBRG8", V4L2_MBUS_FMT_SGBRG8_1X8, ATOMISP_INPUT_FORMAT_RAW_8, 8},
 	{"BGGR8", V4L2_MBUS_FMT_SBGGR8_1X8, ATOMISP_INPUT_FORMAT_RAW_8, 8},
-	{"YUV422_8", V4L2_MBUS_FMT_UYVY8_1X16, ATOMISP_INPUT_FORMAT_YUV422_8, 16},
+	{"YUV422_8", V4L2_MBUS_FMT_UYVY8_1X16,
+		ATOMISP_INPUT_FORMAT_YUV422_8, 16},
 	{"YUV420_8", 0x8001/*For YUV420*/, ATOMISP_INPUT_FORMAT_YUV420_8, 16},
 };
 
@@ -58,26 +59,41 @@ static struct pixter_dbgfs dbgfs[] = {
 	{"timing", "root", DBGFS_DIR, 0, 0},
 	{"fps_ovrd", "fps", DBGFS_FILE, PIXTER_RW, dev_off(dbg_fps.fps_ovrd)},
 	{"fps", "fps", DBGFS_FILE, PIXTER_RW, dev_off(dbg_fps.fps)},
-	{"blank_ovrd", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.blank_ovrd)},
+	{"blank_ovrd", "blank",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.blank_ovrd)},
 	{"h_blank", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.h_blank)},
-	{"v_blank_pre", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.v_blank_pre)},
-	{"v_blank_post", "blank", DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.v_blank_post)},
-	{"mipi_clk", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.mipi_clk)},
-	{"cont_hs_clk", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.cont_hs_clk)},
-	{"timing_ovrd", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.timing_ovrd)},
+	{"v_blank_pre", "blank",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.v_blank_pre)},
+	{"v_blank_post", "blank",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_blank.v_blank_post)},
+	{"mipi_clk", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.mipi_clk)},
+	{"cont_hs_clk", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.cont_hs_clk)},
+	{"timing_ovrd", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.timing_ovrd)},
 	{"pre", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.pre)},
 	{"post", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.post)},
 	{"gap", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.gap)},
 	{"ck_lpx", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_lpx)},
-	{"ck_prep", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_prep)},
-	{"ck_zero", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_zero)},
-	{"ck_trail", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_trail)},
-	{"dat_lpx", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_lpx)},
-	{"dat_prep", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_prep)},
-	{"dat_zero", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_zero)},
-	{"dat_trail", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_trail)},
-	{"twakeup", "timing", DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.twakeup)},
-	{"mipi_lanes_num", "timing", DBGFS_FILE, PIXTER_RONLY, dev_off(dbg_timing.mipi_lanes_num)},
+	{"ck_prep", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_prep)},
+	{"ck_zero", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_zero)},
+	{"ck_trail", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.ck_trail)},
+	{"dat_lpx", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_lpx)},
+	{"dat_prep", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_prep)},
+	{"dat_zero", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_zero)},
+	{"dat_trail", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.dat_trail)},
+	{"twakeup", "timing",
+		DBGFS_FILE, PIXTER_RW, dev_off(dbg_timing.twakeup)},
+	{"mipi_lanes_num", "timing",
+		DBGFS_FILE, PIXTER_RONLY, dev_off(dbg_timing.mipi_lanes_num)},
 };
 
 static u32 pixter_get_tx_freq_sel(u32 *freq)
@@ -150,7 +166,7 @@ static int pixter_read_buf(struct v4l2_subdev *sd,
 	int ret = 0;
 
 	for (i = 0; i < size; i += 4) {
-		ret = pixter_read_reg(sd, addr + i, (u32*)((u8*)buf + i));
+		ret = pixter_read_reg(sd, addr + i, (u32 *)((u8 *)buf + i));
 		if (ret)
 			break;
 	}
@@ -229,7 +245,7 @@ static int pixter_config_rx(struct v4l2_subdev *sd)
 	if (dev->dbg_blank.blank_ovrd) {
 		h_blank = dev->dbg_blank.h_blank;
 		line_bits = 1000 * (width_bits + h_blank *
-                        format_bridge[setting->vc[vc].format].bpp);
+			format_bridge[setting->vc[vc].format].bpp);
 		line_interval = line_bits / bit_rate;
 		v_blank_pre = dev->dbg_blank.v_blank_pre;
 		v_blank_post = dev->dbg_blank.v_blank_post;
@@ -295,7 +311,8 @@ static int pixter_config_tx(struct v4l2_subdev *sd)
 		pixter_read_reg(sd, PIXTER_TX_STATUS(ch), &reg_val);
 		if (reg_val & PIXTER_TX_READY)
 			break;
-		usleep_range(10000, 10000);
+		/*usleep_range should not use min == max args*/
+		usleep_range(10000, 10000 + 1);
 		cnt--;
 	}
 	if (cnt == 0) {
@@ -479,7 +496,7 @@ static u32 pixter_try_mbus_fmt_locked(struct v4l2_subdev *sd,
 	struct pixter_device *dev = to_pixter_dev(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct atomisp_input_stream_info *stream_info =
-		(struct atomisp_input_stream_info*)fmt->reserved;
+		(struct atomisp_input_stream_info *)fmt->reserved;
 	struct pixter_setting *settings = dev->settings;
 	struct pixter_vc_setting *vc_setting = dev->vc_setting;
 	u32 vc, i, j;
@@ -558,7 +575,7 @@ static int pixter_g_mbus_fmt(struct v4l2_subdev *sd,
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct pixter_device *dev = to_pixter_dev(sd);
 	struct atomisp_input_stream_info *stream_info =
-		(struct atomisp_input_stream_info*)fmt->reserved;
+		(struct atomisp_input_stream_info *)fmt->reserved;
 	struct pixter_setting *setting;
 	u32 vc;
 
@@ -590,7 +607,7 @@ static int pixter_s_mbus_fmt(struct v4l2_subdev *sd,
 	struct pixter_device *dev = to_pixter_dev(sd);
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct atomisp_input_stream_info *stream_info =
-		(struct atomisp_input_stream_info*)fmt->reserved;
+		(struct atomisp_input_stream_info *)fmt->reserved;
 
 	if (!fmt)
 		return -EINVAL;
@@ -784,12 +801,13 @@ static int pixter_s_power(struct v4l2_subdev *sd, int on)
 	return 0;
 }
 
-static ssize_t pixter_dbgfs_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
+static ssize_t pixter_dbgfs_read(struct file *file, char __user *buf,
+					size_t size, loff_t *ppos)
 {
 	struct pixter_dbgfs_data *data = file->f_inode->i_private;
 	struct pixter_device *dev = data->dev;
 	ssize_t ret = 0;
-	u32 *val = (u32*) data->ptr;
+	u32 *val = (u32 *) data->ptr;
 	u32 i;
 
 	char *str = kzalloc(1024, GFP_KERNEL);
@@ -826,16 +844,18 @@ out:
 	return ret;
 }
 
-static ssize_t pixter_dbgfs_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos)
+static ssize_t pixter_dbgfs_write(struct file *file, const char __user *buf,
+					size_t size, loff_t *ppos)
 {
 	struct pixter_dbgfs_data *data = file->f_inode->i_private;
 	struct pixter_device *dev = data->dev;
-	u32 *val = (u32*) data->ptr;
+	u32 *val = (u32 *) data->ptr;
 	char str[16] = {0};
 	ssize_t ret;
+	int sf_ret;
 
 	ret =  simple_write_to_buffer(str, 16, ppos, buf, size);
-	sscanf(str, "%d", val);
+	sf_ret = sscanf(str, "%d", val);
 	if (val == &dev->dbg_timing.timing_ovrd && *val == 0)
 		pixter_config_tx(&dev->sd);
 
@@ -1029,14 +1049,14 @@ static int pixter_probe(struct i2c_client *client,
 	 */
 	if (dev->mipi_info->port == ATOMISP_CAMERA_PORT_PRIMARY)
 		pixter_name = PIXTER_0;
-	else if(dev->mipi_info->port == ATOMISP_CAMERA_PORT_SECONDARY)
+	else if (dev->mipi_info->port == ATOMISP_CAMERA_PORT_SECONDARY)
 		pixter_name = PIXTER_1;
 	else
 		pixter_name = PIXTER_2;
 	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s %d-%04x",
 		pixter_name, i2c_adapter_id(client->adapter), client->addr);
 
-        dev_info(&client->dev, "%s dev->sd.name: %s\n", __func__, dev->sd.name);
+	dev_info(&client->dev, "%s dev->sd.name: %s\n", __func__, dev->sd.name);
 
 	dev->sd.entity.ops = &pixter_entity_ops;
 	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
@@ -1080,7 +1100,7 @@ static int pixter_probe(struct i2c_client *client,
 			continue;
 		parent = dbgfs_data[j].entry;
 		dbgfs_data[i].dev = dev;
-		dbgfs_data[i].ptr = (u8*)dev + dbgfs[i].offset;
+		dbgfs_data[i].ptr = (u8 *)dev + dbgfs[i].offset;
 		if (dbgfs[i].type == DBGFS_DIR)
 			dbgfs_data[i].entry = debugfs_create_dir(dbgfs[i].name,
 				parent);
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/pixter.h b/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
index f199623..9e03f64 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
@@ -72,7 +72,7 @@
 #define PIXTER_SETTING_START	0x80000008
 
 #define PIXTER_RONLY		S_IRUSR
-#define PIXTER_RW			S_IRUSR | S_IWUSR
+#define PIXTER_RW		(S_IRUSR | S_IWUSR)
 
 enum pixter_image_format {
 	PIXTER_UNKNOWN_FMT,
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
index ebb4f14..6a23094 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
@@ -69,7 +69,8 @@ static int s5k6b2yx_read_reg(struct i2c_client *client, u16 len,
 	int retry_cnt = 5;
 
 	if (len > S5K6B2YX_BYTE_MAX) {
-		dev_err(&client->dev, "%s error, invalid data length\n", __func__);
+		dev_err(&client->dev,
+			"%s error, invalid data length\n", __func__);
 		return -EINVAL;
 	}
 
@@ -136,7 +137,7 @@ static int s5k6b2yx_i2c_write(struct i2c_client *client, u16 len, u8 *data)
 }
 
 static int s5k6b2yx_write_reg(struct i2c_client *client, u16 data_length,
-								u16 reg, u16 val)
+							u16 reg, u16 val)
 {
 	int ret;
 	unsigned char data[4] = {0};
@@ -145,7 +146,8 @@ static int s5k6b2yx_write_reg(struct i2c_client *client, u16 data_length,
 	int retry_cnt = 5;
 
 	if (data_length != S5K6B2YX_8BIT && data_length != S5K6B2YX_16BIT) {
-		dev_err(&client->dev, "%s error, invalid data_length\n", __func__);
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
 		return -EINVAL;
 	}
 
@@ -264,7 +266,8 @@ static int s5k6b2yx_write_reg_array(struct i2c_client *client,
 		case S5K6B2YX_TOK_DELAY:
 			err = __s5k6b2yx_flush_reg_array(client, &ctrl);
 			if (err) {
-				dev_err(&client->dev, "%s: write error\n", __func__);
+				dev_err(&client->dev,
+					"%s: write error\n", __func__);
 				return err;
 			}
 			msleep(next->val);
@@ -278,13 +281,15 @@ static int s5k6b2yx_write_reg_array(struct i2c_client *client,
 								next)) {
 				err = __s5k6b2yx_flush_reg_array(client, &ctrl);
 				if (err) {
-					dev_err(&client->dev, "%s: write error\n", __func__);
+					dev_err(&client->dev,
+						"%s: write error\n", __func__);
 					return err;
 				}
 			}
 			err = __s5k6b2yx_buf_reg_array(client, &ctrl, next);
 			if (err) {
-				dev_err(&client->dev, "%s: write error\n", __func__);
+				dev_err(&client->dev,
+					"%s: write error\n", __func__);
 				return err;
 			}
 			break;
@@ -494,7 +499,8 @@ static int s5k6b2yx_get_intg_factor(struct i2c_client *client,
 	pll_multiplier = data[0];
 
 	memset(data, 0, S5K6B2YX_INTG_BUF_COUNT * sizeof(u16));
-	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_FINE_INTEGRATION_TIME, data);
+	ret = s5k6b2yx_read_reg(client, 2,
+				S5K6B2YX_FINE_INTEGRATION_TIME, data);
 	if (ret)
 		return ret;
 	fine_integration_time = data[0];
@@ -520,7 +526,8 @@ static int s5k6b2yx_get_intg_factor(struct i2c_client *client,
 	buf->coarse_integration_time_max_margin =
 			S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN;
 	buf->fine_integration_time_min = S5K6B2YX_FINE_INTG_TIME_MIN;
-	buf->fine_integration_time_max_margin = S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN;
+	buf->fine_integration_time_max_margin =
+				S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN;
 	buf->fine_integration_time_def = S5K6B2YX_FINE_INTG_TIME_MIN;
 	buf->line_length_pck = line_length_pck;
 	buf->frame_length_lines = frame_length_lines;
@@ -551,12 +558,14 @@ static int s5k6b2yx_get_intg_factor(struct i2c_client *client,
 		return ret;
 	buf->crop_vertical_end = data[0];
 
-	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_HORIZONTAL_OUTPUT_SIZE_H, data);
+	ret = s5k6b2yx_read_reg(client, 2,
+				S5K6B2YX_HORIZONTAL_OUTPUT_SIZE_H, data);
 	if (ret)
 		return ret;
 	buf->output_width = data[0];
 
-	ret = s5k6b2yx_read_reg(client, 2, S5K6B2YX_VERTICAL_OUTPUT_SIZE_H, data);
+	ret = s5k6b2yx_read_reg(client, 2,
+				S5K6B2YX_VERTICAL_OUTPUT_SIZE_H, data);
 	if (ret)
 		return ret;
 	buf->output_height = data[0];
@@ -789,14 +798,16 @@ static int s5k6b2yx_t_hflip(struct v4l2_subdev *sd, int value)
 	/* enable group hold */
 	ret = s5k6b2yx_write_reg_array(c, s5k6b2yx_param_hold);
 
-	ret = s5k6b2yx_read_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, &val);
+	ret = s5k6b2yx_read_reg(c, S5K6B2YX_8BIT,
+				S5K6B2YX_IMG_ORIENTATION, &val);
 	if (ret)
 		return ret;
 	if (value)
 		val |= S5K6B2YX_HFLIP_BIT;
 	else
 		val &= ~S5K6B2YX_HFLIP_BIT;
-	ret = s5k6b2yx_write_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, val);
+	ret = s5k6b2yx_write_reg(c, S5K6B2YX_8BIT,
+				S5K6B2YX_IMG_ORIENTATION, val);
 	if (ret)
 		return ret;
 
@@ -818,14 +829,16 @@ static int s5k6b2yx_t_vflip(struct v4l2_subdev *sd, int value)
 	/* enable group hold */
 	ret = s5k6b2yx_write_reg_array(c, s5k6b2yx_param_hold);
 
-	ret = s5k6b2yx_read_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, &val);
+	ret = s5k6b2yx_read_reg(c, S5K6B2YX_8BIT,
+				S5K6B2YX_IMG_ORIENTATION, &val);
 	if (ret)
 		return ret;
 	if (value)
 		val |= S5K6B2YX_VFLIP_BIT;
 	else
 		val &= ~S5K6B2YX_VFLIP_BIT;
-	ret = s5k6b2yx_write_reg(c, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION, val);
+	ret = s5k6b2yx_write_reg(c, S5K6B2YX_8BIT,
+				S5K6B2YX_IMG_ORIENTATION, val);
 	if (ret)
 		return ret;
 
@@ -980,7 +993,8 @@ static struct s5k6b2yx_control s5k6b2yx_controls[] = {
 };
 #define N_CONTROLS (ARRAY_SIZE(s5k6b2yx_controls))
 
-static long __s5k6b2yx_set_exposure(struct v4l2_subdev *sd, u16 coarse_itg, u16 gain)
+static long __s5k6b2yx_set_exposure(struct v4l2_subdev *sd,
+					u16 coarse_itg, u16 gain)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	int ret;
@@ -1251,8 +1265,8 @@ static int s5k6b2yx_recovery(struct v4l2_subdev *sd)
 	if (ret)
 		return ret;
 
-	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT, S5K6B2YX_IMG_ORIENTATION,
-								dev->flip);
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
+			S5K6B2YX_IMG_ORIENTATION, dev->flip);
 	if (ret)
 		return ret;
 
@@ -1289,9 +1303,11 @@ static int s5k6b2yx_s_stream(struct v4l2_subdev *sd, int enable)
 			}
 		}
 		if (dev->mode == CAM_SW_STBY)
-			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_streaming);
+			ret = s5k6b2yx_write_reg_array(client,
+							s5k6b2yx_streaming);
 		else
-			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_vis_streaming);
+			ret = s5k6b2yx_write_reg_array(client,
+							s5k6b2yx_vis_streaming);
 		if (ret) {
 			mutex_unlock(&dev->input_lock);
 			return ret;
@@ -1300,9 +1316,11 @@ static int s5k6b2yx_s_stream(struct v4l2_subdev *sd, int enable)
 		dev->streaming = 1;
 	} else {
 		if (dev->mode == CAM_SW_STBY)
-			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_suspend);
+			ret = s5k6b2yx_write_reg_array(client,
+							s5k6b2yx_suspend);
 		else
-			ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_vis_suspend);
+			ret = s5k6b2yx_write_reg_array(client,
+							s5k6b2yx_vis_suspend);
 		if (ret != 0) {
 			mutex_unlock(&dev->input_lock);
 			return ret;
@@ -1426,7 +1444,8 @@ s5k6b2yx_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 {
 	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
 	struct v4l2_mbus_framefmt *format =
-			__s5k6b2yx_get_pad_format(dev, fh, fmt->pad, fmt->which);
+			__s5k6b2yx_get_pad_format(dev, fh,
+						fmt->pad, fmt->which);
 
 	fmt->format = *format;
 
@@ -1662,7 +1681,8 @@ static int s5k6b2yx_probe(struct i2c_client *client,
 
 	ret = __s5k6b2yx_init_ctrl_handler(dev);
 	if (ret) {
-		dev_err(&client->dev, "%s: init ctrl handler fail!!\n", __func__);
+		dev_err(&client->dev,
+			"%s: init ctrl handler fail!!\n", __func__);
 		goto out_ctrl_handler_free;
 	}
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
index 73e42e3..560bb32 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
@@ -72,7 +72,7 @@
 #define S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN	6
 #define S5K6B2YX_COARSE_INTEGRATION_TIME_MIN	1
 
-#define S5K6B2YX_MAX_EXPOSURE_SUPPORTED (0xffff - S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN)
+#define S5K6B2YX_MAX_EXPOSURE_SUPPORTED		(0xffff - S5K6B2YX_COARSE_INTEGRATION_TIME_MARGIN)
 #define S5K6B2YX_MAX_GLOBAL_GAIN_SUPPORTED	0x0200
 #define S5K6B2YX_MIN_GLOBAL_GAIN_SUPPORTED	0x0020
 
@@ -329,7 +329,8 @@ struct s5k6b2yx_control {
 static struct s5k6b2yx_reg const s5k6b2yx_init_config[] = {
 	/* Vendor specific */
 	{ S5K6B2YX_8BIT, 0x31d3, 0x01 }, /* efuse read en */
-	{ S5K6B2YX_8BIT, 0x3426, 0x3a }, /* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
+	/* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
+	{ S5K6B2YX_8BIT, 0x3426, 0x3a },
 	{ S5K6B2YX_8BIT, 0x340d, 0x30 }, /* efuse clock off */
 
 	{ S5K6B2YX_8BIT, 0x3067, 0x25 }, /* adc_sat[mV]=617mV */
@@ -343,9 +344,11 @@ static struct s5k6b2yx_reg const s5k6b2yx_init_config[] = {
 	{ S5K6B2YX_8BIT, 0x3085, 0xf0 }, /* rdv_option; LOB_PLA enable */
 	{ S5K6B2YX_8BIT, 0x3068, 0x55 }, /* ms[15:8]; x4~ */
 	{ S5K6B2YX_8BIT, 0x3069, 0x00 }, /* ms[7:0]; x1~x4 */
-	{ S5K6B2YX_8BIT, 0x3063, 0x08 }, /* cds_option[15:8];[11]ldb nmos sw enable=1 */
+	/* cds_option[15:8];[11]ldb nmos sw enable=1 */
+	{ S5K6B2YX_8BIT, 0x3063, 0x08 },
 	{ S5K6B2YX_8BIT, 0x3064, 0x00 }, /* cds_option[7:0]; */
-	{ S5K6B2YX_8BIT, 0x3010, 0x04 }, /* FD start 2->4 for low lux fluctuation */
+	/* FD start 2->4 for low lux fluctuation */
+	{ S5K6B2YX_8BIT, 0x3010, 0x04 },
 
 	{ S5K6B2YX_8BIT, 0x3247, 0x11 }, /*[4] fadlc_blst_en */
 	{ S5K6B2YX_8BIT, 0x3083, 0x00 }, /* blst_en_cintr = 16 */
@@ -363,7 +366,8 @@ static struct s5k6b2yx_reg const s5k6b2yx_init_config[] = {
 	{ S5K6B2YX_8BIT, 0x3354, 0x00 },
 
 	/* others */
-	{ S5K6B2YX_8BIT, 0x7339, 0x03 }, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	/* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	{ S5K6B2YX_8BIT, 0x7339, 0x03 },
 	{ S5K6B2YX_8BIT, 0x0202, 0x03 },
 	{ S5K6B2YX_8BIT, 0x0203, 0x88 }, /* TBD: Coarse_integration_time */
 	{ S5K6B2YX_8BIT, 0x0204, 0x00 },
@@ -431,7 +435,8 @@ static struct s5k6b2yx_reg const s5k6b2yx_184x104_15fps[] = {
 	{ S5K6B2YX_8BIT, 0x7247, 0x01}, /* adlc_option (20121116) */
 
 	/* Remove Dark Band (20121031) */
-	{ S5K6B2YX_8BIT, 0x7412, 0x09}, /* streaming_enable_time_alv (103.9usec) */
+	/* streaming_enable_time_alv (103.9usec) */
+	{ S5K6B2YX_8BIT, 0x7412, 0x09},
 	{ S5K6B2YX_8BIT, 0x7413, 0xB9},
 	{ S5K6B2YX_8BIT, 0x7430, 0x05}, /* cintc_default_1_alv */
 	{ S5K6B2YX_8BIT, 0x7432, 0x02}, /* cintc_default_2_alv */
@@ -470,8 +475,8 @@ static struct s5k6b2yx_reg const s5k6b2yx_184x104_15fps[] = {
 
 	/* G + R Setting (20120813) */
 	/* Vision Senser Data = 0.5*Gr + 0.5*R */
-	{ S5K6B2YX_8BIT, 0x6029, 0x02}, /* [2:0] : 1bit integer, 2bit fraction */
-	{ S5K6B2YX_8BIT, 0x602A, 0x02}, /* [2:0] : 1bit integer, 2bit fraction */
+	{ S5K6B2YX_8BIT, 0x6029, 0x02}, /* [2:0] : 1bit integer, 2bit fraction*/
+	{ S5K6B2YX_8BIT, 0x602A, 0x02}, /* [2:0] : 1bit integer, 2bit fraction*/
 
 
 	/* For Analog Gain 16x (20120904) */
@@ -487,8 +492,8 @@ static struct s5k6b2yx_reg const s5k6b2yx_184x104_15fps[] = {
 	{ S5K6B2YX_8BIT, 0x7352, 0x49},
 	{ S5K6B2YX_8BIT, 0x7353, 0x00},
 	{ S5K6B2YX_8BIT, 0x7354, 0x00},
-
-	{ S5K6B2YX_8BIT, 0x7339, 0x03}, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	/* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	{ S5K6B2YX_8BIT, 0x7339, 0x03},
 #ifdef VISION_MODE_TEST_PATTERN
 	{ S5K6B2YX_8BIT, 0x7203, 0x42}, /* to enable test pattern */
 #endif
@@ -499,7 +504,8 @@ static struct s5k6b2yx_reg const s5k6b2yx_184x104_15fps[] = {
 static struct s5k6b2yx_reg const s5k6b2yx_1936x1096_30fps[] = {
     /* Vendor specific */
 	{ S5K6B2YX_8BIT, 0x31d3, 0x01 }, /* efuse read en */
-	{ S5K6B2YX_8BIT, 0x3426, 0x3a }, /* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
+	/* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
+	{ S5K6B2YX_8BIT, 0x3426, 0x3a },
 	{ S5K6B2YX_8BIT, 0x340d, 0x30 }, /* efuse clock off */
 
 	{ S5K6B2YX_8BIT, 0x3067, 0x25 }, /* adc_sat[mV]=617mV */
@@ -513,9 +519,11 @@ static struct s5k6b2yx_reg const s5k6b2yx_1936x1096_30fps[] = {
 	{ S5K6B2YX_8BIT, 0x3085, 0xf0 }, /* rdv_option; LOB_PLA enable */
 	{ S5K6B2YX_8BIT, 0x3068, 0x55 }, /* ms[15:8]; x4~ */
 	{ S5K6B2YX_8BIT, 0x3069, 0x00 }, /* ms[7:0]; x1~x4 */
-	{ S5K6B2YX_8BIT, 0x3063, 0x08 }, /* cds_option[15:8];[11]ldb nmos sw enable=1 */
+	/* cds_option[15:8];[11]ldb nmos sw enable=1 */
+	{ S5K6B2YX_8BIT, 0x3063, 0x08 },
 	{ S5K6B2YX_8BIT, 0x3064, 0x00 }, /* cds_option[7:0]; */
-	{ S5K6B2YX_8BIT, 0x3010, 0x04 }, /* FD start 2->4 for low lux fluctuation */
+	/* FD start 2->4 for low lux fluctuation */
+	{ S5K6B2YX_8BIT, 0x3010, 0x04 },
 
 	{ S5K6B2YX_8BIT, 0x3247, 0x11 }, /*[4] fadlc_blst_en */
 	{ S5K6B2YX_8BIT, 0x3083, 0x00 }, /* blst_en_cintr = 16 */
@@ -533,7 +541,8 @@ static struct s5k6b2yx_reg const s5k6b2yx_1936x1096_30fps[] = {
 	{ S5K6B2YX_8BIT, 0x3354, 0x00 },
 
 	/* others */
-	{ S5K6B2YX_8BIT, 0x7339, 0x03 }, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	/* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+	{ S5K6B2YX_8BIT, 0x7339, 0x03 },
 	{ S5K6B2YX_8BIT, 0x0202, 0x03 },
 	{ S5K6B2YX_8BIT, 0x0203, 0x88 }, /* TBD: Coarse_integration_time */
 	{ S5K6B2YX_8BIT, 0x0204, 0x00 },
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c
index f34e47f..5cbf081 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c
@@ -277,7 +277,7 @@ static int s5k8aay_reset(struct v4l2_subdev *sd)
 		return ret;
 
 	/* Allow startup code to run */
-	usleep_range(1000, 1000);
+	usleep_range(1000, 2000);
 
 	return 0;
 }
@@ -370,7 +370,8 @@ static int power_up(struct v4l2_subdev *sd)
 	if (ret)
 		goto fail_clk;
 
-	usleep_range(15, 15);
+	/*usleep_range should not use min == max args;*/
+	usleep_range(15, 30);
 
 	/* Release reset */
 	ret = dev->platform_data->gpio_ctrl(sd, 1);
@@ -378,7 +379,7 @@ static int power_up(struct v4l2_subdev *sd)
 		goto fail_gpio;
 
 	/* 100 us is needed between power up and first i2c transaction. */
-	usleep_range(100, 100);
+	usleep_range(100, 200);
 
 	return 0;
 
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h
index e593a3c..4c0ccbc 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h
@@ -23,16 +23,18 @@
  *  [8AA_EVT1]Preview 640x480_30fps_Capture 1280x960_30fps_M19.2_S58_P116.nset
  */
 
-static struct s5k8aay_reg const s5k8aay_regs_1[] = {		/* 01.Start Setting */
-	/* $MIPI[Width:1280,Height:720,Format:YUV422,Lane:1,ErrorCheck:0,PolarityData:0,PolarityClock:0,Buffer:2] */
+/* 01.Start Setting */
+static struct s5k8aay_reg const s5k8aay_regs_1[] = {
+	/* $MIPI[Width:1280,Height:720,Format:YUV422,Lane:1,
+	ErrorCheck:0,PolarityData:0,PolarityClock:0,Buffer:2] */
 
-	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /* Default page address setting */
-	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /* Enable Address Auto-Increase */
-	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /* Default page address setting */
-	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /* Enable Address Auto-Increase */
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /*Default page address setting */
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /*Enable Address Auto-Increase */
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /*Default page address setting */
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /*Enable Address Auto-Increase */
 
-	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /* Default page address setting */
-	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /* Enable Address Auto-Increase */
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /*Default page address setting */
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /*Enable Address Auto-Increase */
 
 	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
 	{ S5K8AAY_TOK_16BIT, 0x0010, 0x0001 }, /* S/W Reset */
@@ -49,188 +51,291 @@ static struct s5k8aay_reg const s5k8aay_regs_1[] = {		/* 01.Start Setting */
 	{ S5K8AAY_TOK_TERM, 0, 0 }
 };
 
-static struct s5k8aay_reg const s5k8aay_regs_19_1056x864[] = {		/* 19.Input Size Setting */
+/* 19.Input Size Setting */
+static struct s5k8aay_reg const s5k8aay_regs_19_1056x864[] = {
 	{ S5K8AAY_TOK_16BIT, 0x0138, 0x0420 },	/* REG_TC_IPRM_InputWidthSize */
-	{ S5K8AAY_TOK_16BIT, 0x013A, 0x0360 },	/* REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x0360 },	/* REG_TC_IPRM_InputHeightSize*/
 	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0070 },	/* REG_TC_IPRM_InputWidthOfs */
 	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0030 },	/* REG_TC_IPRM_InputHeightOfs */
 
 
-	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x04B0 },	/* REG_TC_PZOOM_ZoomInputWidth */
-	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x0320 },	/* REG_TC_PZOOM_ZoomInputHeight */
-	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0000 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x04B0 },	/* REG_TC_PZOOM_ZoomInputWidth*/
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x0320 },	/*REG_TC_PZOOM_ZoomInputHeight*/
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },/*REG_TC_PZOOM_ZoomInputWidthOfs*/
+	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0000 },
+	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },
 
 	/* Preview config[0] 1056X864  xxfps // */
-	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0420 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
-	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x0360 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
-	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
+	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0420 },
+	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x0360 },
+	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },
+	/* REG_0TC_PCFG_uClockInd */
+	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },
+	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },
+	/* REG_0TC_PCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },
+	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10
+	30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },
+	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },
 	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
-	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+	/* REG_0TC_PCFG_uCaptureMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },
 
 	/* // Capture config[0] 1056x864  xxfps */
 	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
-	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0420 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
-	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x0360 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0420 },
+	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x0360 },
+	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },
 	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },
+	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },
+	/* REG_0TC_CCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },
+	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },
+	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },
 
 	{ S5K8AAY_TOK_TERM, 0, 0 }
 };
 
-static struct s5k8aay_reg const s5k8aay_regs_19_1200x800[] = {		/* 19.Input Size Setting */
+/* 19.Input Size Setting */
+static struct s5k8aay_reg const s5k8aay_regs_19_1200x800[] = {
 	{ S5K8AAY_TOK_16BIT, 0x0138, 0x04B0 },	/* REG_TC_IPRM_InputWidthSize */
-	{ S5K8AAY_TOK_16BIT, 0x013A, 0x0320 },	/* REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x0320 },	/* REG_TC_IPRM_InputHeightSize*/
 	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0028 },	/* REG_TC_IPRM_InputWidthOfs */
 	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0080 },	/* REG_TC_IPRM_InputHeightOfs */
 
-	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x04B0 },	/* REG_TC_PZOOM_ZoomInputWidth */
-	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x0320 },	/* REG_TC_PZOOM_ZoomInputHeight */
-	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0080 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x04B0 },	/* REG_TC_PZOOM_ZoomInputWidth*/
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x0320 },	/*REG_TC_PZOOM_ZoomInputHeight*/
+	/* REG_TC_PZOOM_ZoomInputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },
+	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0080 },
+	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },
 
 	/* Preview config[0] 1200X800  xxfps // */
-	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x04B0 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
-	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x0320 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x04B0 },
+	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x0320 },
+	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },
 	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },
+	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },
+	/* REG_0TC_PCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },
+	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10
+	 30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },
+	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },
 	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
-	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },/* REG_0TC_PCFG_uCaptureMirror */
 
 	/* // Capture config[0] 1200x800  xxfps */
 	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
-	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x04B0 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
-	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x0320 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x04B0 },
+	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x0320 },
+	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },
 	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },
+	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },
+	/* REG_0TC_CCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },
+	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },
+	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },
 
 	{ S5K8AAY_TOK_TERM, 0, 0 }
 };
 
-static struct s5k8aay_reg const s5k8aay_regs_19_1280x720[] = {		/* 19.Input Size Setting */
+/* 19.Input Size Setting */
+static struct s5k8aay_reg const s5k8aay_regs_19_1280x720[] = {
 	{ S5K8AAY_TOK_16BIT, 0x0138, 0x0500 },	/* REG_TC_IPRM_InputWidthSize */
-	{ S5K8AAY_TOK_16BIT, 0x013A, 0x02D0 },	/* 03C0 //REG_TC_IPRM_InputHeightSize */
+	/* 03C0 //REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x02D0 },
 	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0000 },	/* REG_TC_IPRM_InputWidthOfs */
 	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0078 },	/* REG_TC_IPRM_InputHeightOfs */
 
 
-	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x0500 },	/* REG_TC_PZOOM_ZoomInputWidth */
-	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x02D0 },	/* 03C0 //REG_TC_PZOOM_ZoomInputHeight */
-	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0078 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x0500 },	/* REG_TC_PZOOM_ZoomInputWidth*/
+	/* 03C0 //REG_TC_PZOOM_ZoomInputHeight */
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x02D0 },
+	/* REG_TC_PZOOM_ZoomInputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },
+	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0078 },
+	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },
 
 	/* Preview config[0] 1280X720  30fps // */
-	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0500 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
-	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x02D0 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0500 },
+	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x02D0 },
+	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },
 	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },
+	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },
+	/* REG_0TC_PCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },
+	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10
+	30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },
+	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },
 	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
-	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },/* REG_0TC_PCFG_uCaptureMirror */
 
 	/* // Capture config[0] 1280x720  30fps */
 	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
-	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0500 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
-	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x02D0 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0500 },
+	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x02D0 },
+	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },
 	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },
+	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },
+	/* REG_0TC_CCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },
+	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },
+	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },
 
 	{ S5K8AAY_TOK_TERM, 0, 0 }
 };
 
-
-static struct s5k8aay_reg const s5k8aay_regs_19_1280x960[] = {		/* 19.Input Size Setting */
+/* 19.Input Size Setting */
+static struct s5k8aay_reg const s5k8aay_regs_19_1280x960[] = {
 
 	{ S5K8AAY_TOK_16BIT, 0x0138, 0x0500 },	/* REG_TC_IPRM_InputWidthSize */
-	{ S5K8AAY_TOK_16BIT, 0x013A, 0x03C0 },	/* REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x03C0 },	/* REG_TC_IPRM_InputHeightSize*/
 	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0000 },	/* REG_TC_IPRM_InputWidthOfs */
 	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0000 },	/* REG_TC_IPRM_InputHeightOfs */
 
-	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x0500 },	/* REG_TC_PZOOM_ZoomInputWidth */
-	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x03C0 },	/* REG_TC_PZOOM_ZoomInputHeight */
-	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0000 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
-	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x0500 },	/* REG_TC_PZOOM_ZoomInputWidth*/
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x03C0 },	/* REG_TC_PZOOM_ZoomInputHeigh*/
+	/* REG_TC_PZOOM_ZoomInputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },
+	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0000 },
+	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },
 
 	/* Preview config[0] 1280X960  30fps // */
-	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0500 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
-	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x03C0 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0500 },
+	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x03C0 },
+	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },
 	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0001 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x0000 },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },
+	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },
+	/* REG_0TC_PCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0001 },
+	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10
+	 30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },
+	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x0000 },
 	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
-	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror*/
 
 	/* // Capture config[0] 1280x960  xxfps */
 	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
-	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0500 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
-	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x03C0 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
-	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0500 },
+	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x03C0 },
+	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },
 	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
 	/* debug liao */
-	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0052 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
-	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
-	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0001 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
-	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
-	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0052 },
+	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },
+	/* REG_0TC_CCFG_usFrTimeType
+	0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0001 },
+	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },
+	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },
 
 	{ S5K8AAY_TOK_TERM, 0, 0 }
 };
 
-
-static struct s5k8aay_reg const s5k8aay_regs_21[] = {		/* 21.Select Cofigration Display */
-	{ S5K8AAY_TOK_16BIT, 0x01A8, 0x0000 },	/* REG_TC_GP_ActivePreviewConfig */
-	{ S5K8AAY_TOK_16BIT, 0x01AC, 0x0001 },	/* REG_TC_GP_PrevOpenAfterChange */
+/* 21.Select Cofigration Display */
+static struct s5k8aay_reg const s5k8aay_regs_21[] = {
+	/* REG_TC_GP_ActivePreviewConfig */
+	{ S5K8AAY_TOK_16BIT, 0x01A8, 0x0000 },
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{ S5K8AAY_TOK_16BIT, 0x01AC, 0x0001 },
 	{ S5K8AAY_TOK_16BIT, 0x01A6, 0x0001 },	/* REG_TC_GP_NewConfigSync */
-	{ S5K8AAY_TOK_16BIT, 0x01AC, 0x0001 },	/* REG_TC_GP_PrevOpenAfterChange */
+	/* REG_TC_GP_PrevOpenAfterChange */
+	{ S5K8AAY_TOK_16BIT, 0x01AC, 0x0001 },
 	{ S5K8AAY_TOK_16BIT, 0x01A6, 0x0001 },	/* REG_TC_GP_NewConfigSync */
-	{ S5K8AAY_TOK_16BIT, 0x01AA, 0x0001 },	/* REG_TC_GP_PreviewConfigChanged */
+	/* REG_TC_GP_PreviewConfigChanged */
+	{ S5K8AAY_TOK_16BIT, 0x01AA, 0x0001 },
 	{ S5K8AAY_TOK_16BIT, 0x019E, 0x0001 },	/* REG_TC_GP_EnablePreview */
-	{ S5K8AAY_TOK_16BIT, 0x01A0, 0x0001 },	/* REG_TC_GP_EnablePreviewChanged */
+	/* REG_TC_GP_EnablePreviewChanged */
+	{ S5K8AAY_TOK_16BIT, 0x01A0, 0x0001 },
 
 	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
 	{ S5K8AAY_TOK_16BIT, 0x1000, 0x0001 },	/* Set host interrupt */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c b/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c
index c76f644..0bf4340 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c
+++ b/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c
@@ -98,13 +98,16 @@ static int csi_xactor_s_stream(struct v4l2_subdev *sd, int enable)
 		(0xc5180000 | (lane<<16) | (((pause_en) ? 7 : 0)<<8))
 
 		if (strcmp(client->name, CSI_XACTOR_A_NAME) == 0) {
-			dev_dbg(&client->dev, "set stream on to %d port a\n", enable);
+			dev_dbg(&client->dev, "set stream on to %d port a\n",
+				enable);
 			xactor_on = CSI_XACTOR_PAUSE(1, !enable);
 		} else if (strcmp(client->name, CSI_XACTOR_B_NAME) == 0) {
-			dev_dbg(&client->dev, "set stream on to %d port b\n", enable);
+			dev_dbg(&client->dev, "set stream on to %d port b\n",
+				enable);
 			xactor_on = CSI_XACTOR_PAUSE(2, !enable);
 		} else if (strcmp(client->name, CSI_XACTOR_C_NAME) == 0) {
-			dev_dbg(&client->dev, "set stream on to %d port c\n", enable);
+			dev_dbg(&client->dev, "set stream on to %d port c\n",
+				enable);
 			xactor_on = CSI_XACTOR_PAUSE(4, !enable);
 		} else {
 			dev_err(&client->dev, "xactor driver doesn't match!\n");
@@ -113,12 +116,14 @@ static int csi_xactor_s_stream(struct v4l2_subdev *sd, int enable)
 
 		base = phys_to_virt(CSI_XACTOR_UNPAUSE_REG_ADDR);
 		if (!base) {
-			dev_dbg(&client->dev, "Failed to phys_to_virt(CSI_XACTOR_UNPAUSE_REG_ADDR)\n");
+			dev_dbg(&client->dev,
+		"Failed to phys_to_virt(CSI_XACTOR_UNPAUSE_REG_ADDR)\n");
 			return -EINVAL;
 		}
 
 		if (enable) {
-			dev_dbg(&client->dev, "waiting  for sensor to start sending data\n");
+			dev_dbg(&client->dev,
+				"waiting  for sensor to start sending data\n");
 			usleep_range(40000000, 55000000);
 		}
 
@@ -216,7 +221,7 @@ static int csi_xactor_g_mbus_fmt(struct v4l2_subdev *sd,
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
 	struct atomisp_input_stream_info *stream_info =
-		(struct atomisp_input_stream_info*)fmt->reserved;
+		(struct atomisp_input_stream_info *)fmt->reserved;
 
 	if (!fmt)
 		return -EINVAL;
@@ -256,7 +261,7 @@ static int csi_xactor_s_mbus_fmt(struct v4l2_subdev *sd,
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 	struct camera_mipi_info *info = v4l2_get_subdev_hostdata(sd);
 	struct atomisp_input_stream_info *stream_info =
-		(struct atomisp_input_stream_info*)fmt->reserved;
+		(struct atomisp_input_stream_info *)fmt->reserved;
 
 	if (!fmt)
 		return -EINVAL;
@@ -280,7 +285,8 @@ static int csi_xactor_s_power(struct v4l2_subdev *sd, int on)
 	return 0;
 }
 
-static long csi_xactor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+static long csi_xactor_ioctl(struct v4l2_subdev *sd,
+			unsigned int cmd, void *arg)
 {
 	switch (cmd) {
 	case ATOMISP_IOC_S_EXPOSURE:
@@ -362,7 +368,7 @@ csi_xactor_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
 {
 	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
 	struct v4l2_mbus_framefmt *format =
-			__csi_xactor_get_pad_format(dev, fh, fmt->pad, fmt->which);
+		__csi_xactor_get_pad_format(dev, fh, fmt->pad, fmt->which);
 
 	fmt->format = *format;
 
@@ -515,7 +521,7 @@ static int csi_xactor_probe(struct i2c_client *client,
 			goto out_free;
 	}
 
-	switch(mode) {
+	switch (mode) {
 	case MODE_PIXTER:
 		dev_info(&client->dev, "Driver in Pixter mode\n");
 		break;
@@ -523,8 +529,9 @@ static int csi_xactor_probe(struct i2c_client *client,
 		dev_info(&client->dev, "Driver in SLE CSI xactor mode\n");
 		break;
 	default:
-		dev_err(&client->dev, "Mode %d is not supported setting to default mode.\n",
-				mode);
+		dev_err(&client->dev,
+			"Mode %d is not supported setting to default mode.\n",
+			mode);
 		mode = MODE_DEFAULT;
 		break;
 	}
@@ -559,17 +566,17 @@ static int csi_xactor_probe(struct i2c_client *client,
 	csi = v4l2_get_subdev_hostdata(&dev->sd);
 
 	if (csi->port == ATOMISP_CAMERA_PORT_PRIMARY)
-	    name[0] = 'a';
-	else if(csi->port == ATOMISP_CAMERA_PORT_SECONDARY)
-	    name[0] = 'b';
+		name[0] = 'a';
+	else if (csi->port == ATOMISP_CAMERA_PORT_SECONDARY)
+		name[0] = 'b';
 	else
-	    name[0] = 'c';
+		name[0] = 'c';
 
 	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s%s %d-%04x",
 		"xactor", name,
 		i2c_adapter_id(client->adapter), client->addr);
 
-        dev_info(&client->dev, "%s dev->sd.name: %s\n", __func__, dev->sd.name);
+	dev_info(&client->dev, "%s dev->sd.name: %s\n", __func__, dev->sd.name);
 
 	dev->sd.entity.ops = &csi_xactor_entity_ops;
 	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
-- 
1.9.1

