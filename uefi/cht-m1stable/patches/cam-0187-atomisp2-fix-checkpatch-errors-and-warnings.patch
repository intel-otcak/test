From 1991c353635d3e3070177dda7868ca35d70ddcbc Mon Sep 17 00:00:00 2001
From: Bin Han <bin.b.han@intel.com>
Date: Fri, 26 Dec 2014 14:09:40 +0800
Subject: [PATCH 187/196] atomisp2: fix checkpatch errors and warnings

This patch intends to fix all the checkpatch errors and warnings for
atomisp2, but not all of them are fixed because some of them depend
on CSS and other kernel modules, they might be fixed later with
co-work between teams.

Change-Id: I0eed208f4df0dc115e2f1abbf5524fd1a2bbc5d9
Tracked-On: https://hsdes.intel.com/home/default.html#article?id=1503901208
Signed-off-by: Bin Han <bin.b.han@intel.com>
Reviewed-on: https://icggerrit.ir.intel.com/34298
Reviewed-by: Fang Wang <fang.c.wang@intel.com>
Approver: Wei Tao <wei.tao@intel.com>
Reviewed-by: Wei Tao <wei.tao@intel.com>
---
 .../pci/atomisp2/atomisp_driver/atomisp-regs.h     |   2 +-
 .../pci/atomisp2/atomisp_driver/atomisp_acc.c      |   3 +-
 .../pci/atomisp2/atomisp_driver/atomisp_cmd.c      | 517 ++++++++++-----------
 .../pci/atomisp2/atomisp_driver/atomisp_cmd.h      |   4 +
 .../atomisp2/atomisp_driver/atomisp_compat_css20.c |  84 ++--
 .../atomisp2/atomisp_driver/atomisp_compat_css20.h |   3 +-
 .../atomisp_driver/atomisp_compat_ioctl32.c        |   6 +-
 .../atomisp_driver/atomisp_compat_ioctl32.h        |   2 +-
 .../pci/atomisp2/atomisp_driver/atomisp_drvfs.c    |   4 +-
 .../pci/atomisp2/atomisp_driver/atomisp_fops.c     |  51 +-
 .../pci/atomisp2/atomisp_driver/atomisp_internal.h |   2 +
 .../pci/atomisp2/atomisp_driver/atomisp_ioctl.c    |  41 +-
 .../pci/atomisp2/atomisp_driver/atomisp_subdev.c   |  12 +-
 .../atomisp2/atomisp_driver/atomisp_trace_event.h  |   2 +-
 .../pci/atomisp2/atomisp_driver/atomisp_v4l2.c     |  36 +-
 .../media/pci/atomisp2/atomisp_driver/hmm/hmm.c    |  10 +-
 .../media/pci/atomisp2/atomisp_driver/hmm/hmm_bo.c |   6 +-
 .../pci/atomisp2/atomisp_driver/hmm/hmm_bo_dev.c   |   5 +-
 .../atomisp2/atomisp_driver/hrt/memory_access.c    |   5 +-
 .../atomisp_driver/include/hmm/hmm_bo_dev.h        |   2 +-
 .../atomisp_driver/include/hmm/hmm_common.h        |   4 +-
 .../atomisp2/atomisp_driver/include/hmm/hmm_pool.h |   4 +-
 .../pci/atomisp2/atomisp_driver/mmu/isp_mmu.c      |   1 -
 23 files changed, 390 insertions(+), 416 deletions(-)

diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp-regs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp-regs.h
index ed9a79f..82edeb1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp-regs.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp-regs.h
@@ -148,7 +148,7 @@
 #define ISP_FREQ_266MHZ				0x10a
 #define ISP_FREQ_200MHZ				0xc8
 #define HPLL_FREQ				0x640
-#define HPLL_FREQ_CR        			0x7D0
+#define HPLL_FREQ_CR				0x7D0
 
 #if defined(ISP2401)
 #define ISP_FREQ_MAX	ISP_FREQ_320MHZ
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_acc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_acc.c
index 4a648d5..8ade9f3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_acc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_acc.c
@@ -480,7 +480,8 @@ int atomisp_acc_load_extensions(struct atomisp_sub_device *asd)
 
 			if (acc_fw->flags & acc_flag_to_pipe[i].flag) {
 				ret = atomisp_css_load_acc_extension(asd,
-					acc_fw->fw,acc_flag_to_pipe[i].pipe_id,
+					acc_fw->fw,
+					acc_flag_to_pipe[i].pipe_id,
 					acc_fw->type);
 				if (ret) {
 					i--;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c
index 575a932..8469409 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.c
@@ -249,8 +249,8 @@ static int write_target_freq_to_hw(struct atomisp_device *isp,
 	timeout = 10;
 	while (((isp_sspm1 >> ISP_FREQ_STAT_OFFSET) != ratio) && timeout) {
 		isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
-		dev_dbg(isp->dev, "waiting for ISPSSPM1 status bit to be "
-				"0x%x.\n", new_freq);
+		dev_dbg(isp->dev, "waiting for ISPSSPM1 status bit to be 0x%x.\n",
+			new_freq);
 		udelay(100);
 		timeout--;
 	}
@@ -645,7 +645,7 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 			asd = __get_asd_from_port(isp, eof_event.event.port);
 			if (!asd) {
 				dev_err(isp->dev, "%s:no subdev.event:%d",  __func__,
-				        eof_event.event.type);
+					eof_event.event.type);
 				continue;
 			}
 
@@ -863,7 +863,7 @@ static struct atomisp_video_pipe *__atomisp_get_pipe(
 				}
 			}
 		} else if (buf_type == CSS_BUFFER_TYPE_OUTPUT_FRAME) {
-			switch(asd->run_mode->val) {
+			switch (asd->run_mode->val) {
 			case ATOMISP_RUN_MODE_VIDEO:
 				return &asd->video_out_video_capture;
 			case ATOMISP_RUN_MODE_PREVIEW:
@@ -963,215 +963,214 @@ void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
 	}
 
 	switch (buf_type) {
-		case CSS_BUFFER_TYPE_3A_STATISTICS:
-			list_for_each_entry_safe(s3a_buf, _s3a_buf_tmp,
-							&asd->s3a_stats_in_css, list) {
-				if (s3a_buf->s3a_data == buffer.css_buffer.data.stats_3a) {
-					list_del_init(&s3a_buf->list);
-					list_add_tail(&s3a_buf->list, &asd->s3a_stats_ready);
-					break;
-				}
+	case CSS_BUFFER_TYPE_3A_STATISTICS:
+		list_for_each_entry_safe(s3a_buf, _s3a_buf_tmp,
+						&asd->s3a_stats_in_css, list) {
+			if (s3a_buf->s3a_data ==
+				buffer.css_buffer.data.stats_3a) {
+				list_del_init(&s3a_buf->list);
+				list_add_tail(&s3a_buf->list,
+						&asd->s3a_stats_ready);
+				break;
 			}
+		}
 
-			asd->s3a_bufs_in_css[css_pipe_id]--;
-			atomisp_3a_stats_ready_event(asd, buffer.css_buffer.exp_id);
-			dev_dbg(isp->dev, "%s: s3a stat with exp_id %d is ready\n",
-				__func__, s3a_buf->s3a_data->exp_id);
+		asd->s3a_bufs_in_css[css_pipe_id]--;
+		atomisp_3a_stats_ready_event(asd, buffer.css_buffer.exp_id);
+		dev_dbg(isp->dev, "%s: s3a stat with exp_id %d is ready\n",
+			__func__, s3a_buf->s3a_data->exp_id);
+		break;
+	case CSS_BUFFER_TYPE_METADATA:
+		if (error)
 			break;
-		case CSS_BUFFER_TYPE_METADATA:
-			if (error)
-				break;
 
-			md_type = atomisp_get_metadata_type(asd, css_pipe_id);
-			list_for_each_entry_safe(md_buf, _md_buf_tmp,
+		md_type = atomisp_get_metadata_type(asd, css_pipe_id);
+		list_for_each_entry_safe(md_buf, _md_buf_tmp,
 					&asd->metadata_in_css[md_type], list) {
-				if (md_buf->metadata == buffer.css_buffer.data.metadata) {
-					list_del_init(&md_buf->list);
-					list_add_tail(&md_buf->list, &asd->metadata_ready[md_type]);
-					break;
-				}
-			}
-			asd->metadata_bufs_in_css[stream_id][css_pipe_id]--;
-			atomisp_metadata_ready_event(asd, md_type);
-			dev_dbg(isp->dev, "%s: metadata with exp_id %d is ready\n",
-				__func__, md_buf->metadata->exp_id);
-			break;
-		case CSS_BUFFER_TYPE_DIS_STATISTICS:
-			list_for_each_entry_safe(dis_buf, _dis_buf_tmp,
-							&asd->dis_stats_in_css, list) {
-				if (dis_buf->dis_data == buffer.css_buffer.data.stats_dvs) {
-					spin_lock_irqsave(&asd->dis_stats_lock, irqflags);
-					list_del_init(&dis_buf->list);
-					list_add(&dis_buf->list, &asd->dis_stats);
-					asd->params.dis_proj_data_valid = true;
-					spin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);
-					break;
-				}
-			}
-			asd->dis_bufs_in_css--;
-			dev_dbg(isp->dev, "%s: dis stat with exp_id %d is ready\n",
-				__func__, dis_buf->dis_data->exp_id);
-			break;
-		case CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
-		case CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME:
-			if (isp->sw_contex.invalid_vf_frame) {
-				error = true;
-				isp->sw_contex.invalid_vf_frame = 0;
-				dev_dbg(isp->dev, "%s css has marked this "
-					"vf frame as invalid\n", __func__);
-			}
-
-			pipe->buffers_in_css--;
-			frame = buffer.css_buffer.data.frame;
-			if (!frame) {
-				WARN_ON(1);
+			if (md_buf->metadata ==
+				buffer.css_buffer.data.metadata) {
+				list_del_init(&md_buf->list);
+				list_add_tail(&md_buf->list,
+					&asd->metadata_ready[md_type]);
 				break;
 			}
-			if (!frame->valid)
-				error = true;
-
-			dev_dbg(isp->dev, "%s: vf frame with exp_id %d is ready\n",
-				__func__, frame->exp_id);
-			if (asd->params.flash_state ==
-			    ATOMISP_FLASH_ONGOING) {
-				if (frame->flash_state
-				    == CSS_FRAME_FLASH_STATE_PARTIAL)
-					dev_dbg(isp->dev, "%s thumb partially "
-						"flashed\n", __func__);
-				else if (frame->flash_state
-					 == CSS_FRAME_FLASH_STATE_FULL)
-					dev_dbg(isp->dev, "%s thumb completely "
-						"flashed\n", __func__);
-				else
-					dev_dbg(isp->dev, "%s thumb no flash "
-						"in this frame\n", __func__);
+		}
+		asd->metadata_bufs_in_css[stream_id][css_pipe_id]--;
+		atomisp_metadata_ready_event(asd, md_type);
+		dev_dbg(isp->dev, "%s: metadata with exp_id %d is ready\n",
+			__func__, md_buf->metadata->exp_id);
+		break;
+	case CSS_BUFFER_TYPE_DIS_STATISTICS:
+		list_for_each_entry_safe(dis_buf, _dis_buf_tmp,
+						&asd->dis_stats_in_css, list) {
+			if (dis_buf->dis_data ==
+				buffer.css_buffer.data.stats_dvs) {
+				spin_lock_irqsave(&asd->dis_stats_lock,
+						irqflags);
+				list_del_init(&dis_buf->list);
+				list_add(&dis_buf->list, &asd->dis_stats);
+				asd->params.dis_proj_data_valid = true;
+				spin_unlock_irqrestore(&asd->dis_stats_lock,
+						irqflags);
+				break;
 			}
-			vb = atomisp_css_frame_to_vbuf(pipe, frame);
-			WARN_ON(!vb);
-			if (vb)
-				pipe->frame_config_id[vb->i] = frame->isp_config_id;
-			if (css_pipe_id == IA_CSS_PIPE_ID_CAPTURE &&
-			    asd->pending_capture_request > 0) {
-				err = atomisp_css_offline_capture_configure(
-					asd,
+		}
+		asd->dis_bufs_in_css--;
+		dev_dbg(isp->dev, "%s: dis stat with exp_id %d is ready\n",
+			__func__, dis_buf->dis_data->exp_id);
+		break;
+	case CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
+	case CSS_BUFFER_TYPE_SEC_VF_OUTPUT_FRAME:
+		if (isp->sw_contex.invalid_vf_frame) {
+			error = true;
+			isp->sw_contex.invalid_vf_frame = 0;
+			dev_dbg(isp->dev, "%s css has marked this vf frame as invalid\n",
+				 __func__);
+		}
+
+		pipe->buffers_in_css--;
+		frame = buffer.css_buffer.data.frame;
+		if (!frame) {
+			WARN_ON(1);
+			break;
+		}
+		if (!frame->valid)
+			error = true;
+
+		dev_dbg(isp->dev, "%s: vf frame with exp_id %d is ready\n",
+			__func__, frame->exp_id);
+		if (asd->params.flash_state == ATOMISP_FLASH_ONGOING) {
+			if (frame->flash_state
+			    == CSS_FRAME_FLASH_STATE_PARTIAL)
+				dev_dbg(isp->dev, "%s thumb partially flashed\n",
+					__func__);
+			else if (frame->flash_state
+				 == CSS_FRAME_FLASH_STATE_FULL)
+				dev_dbg(isp->dev, "%s thumb completely flashed\n",
+					__func__);
+			else
+				dev_dbg(isp->dev, "%s thumb no flash in this frame\n",
+					__func__);
+		}
+		vb = atomisp_css_frame_to_vbuf(pipe, frame);
+		WARN_ON(!vb);
+		if (vb)
+			pipe->frame_config_id[vb->i] = frame->isp_config_id;
+		if (css_pipe_id == IA_CSS_PIPE_ID_CAPTURE &&
+		    asd->pending_capture_request > 0) {
+			err = atomisp_css_offline_capture_configure(asd,
 					asd->params.offline_parm.num_captures,
 					asd->params.offline_parm.skip_frames,
 					asd->params.offline_parm.offset);
-				asd->pending_capture_request--;
-				dev_dbg(isp->dev, "Trigger capture again for new buffer. err=%d\n", err);
-			}
+			asd->pending_capture_request--;
+			dev_dbg(isp->dev, "Trigger capture again for new buffer. err=%d\n",
+				err);
+		}
+		break;
+	case CSS_BUFFER_TYPE_OUTPUT_FRAME:
+	case CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME:
+		if (isp->sw_contex.invalid_frame) {
+			error = true;
+			isp->sw_contex.invalid_frame = 0;
+			dev_dbg(isp->dev, "%s css has marked this frame as invalid\n",
+				__func__);
+		}
+		pipe->buffers_in_css--;
+		frame = buffer.css_buffer.data.frame;
+		if (!frame) {
+			WARN_ON(1);
 			break;
-		case CSS_BUFFER_TYPE_OUTPUT_FRAME:
-		case CSS_BUFFER_TYPE_SEC_OUTPUT_FRAME:
-			if (isp->sw_contex.invalid_frame) {
-				error = true;
-				isp->sw_contex.invalid_frame = 0;
-				dev_dbg(isp->dev, "%s css has marked this "
-					"frame as invalid\n", __func__);
-			}
-			pipe->buffers_in_css--;
-			frame = buffer.css_buffer.data.frame;
-			if (!frame) {
-				WARN_ON(1);
-				break;
-			}
-
-			if (!frame->valid)
-				error = true;
+		}
 
-			dev_dbg(isp->dev, "%s: main frame with exp_id %d is ready\n",
-				__func__, frame->exp_id);
-			vb = atomisp_css_frame_to_vbuf(pipe, frame);
-			if (!vb) {
-				WARN_ON(1);
-				break;
-			}
+		if (!frame->valid)
+			error = true;
 
-			pipe->frame_config_id[vb->i] = frame->isp_config_id;
-			ctrl.id = V4L2_CID_FLASH_MODE;
-			if (asd->params.flash_state ==
-			    ATOMISP_FLASH_ONGOING) {
-				if (frame->flash_state
-				    == CSS_FRAME_FLASH_STATE_PARTIAL) {
-					asd->frame_status[vb->i] =
-						ATOMISP_FRAME_STATUS_FLASH_PARTIAL;
-					dev_dbg(isp->dev,
-						 "%s partially flashed\n",
-						 __func__);
-				} else if (frame->flash_state
-					   == CSS_FRAME_FLASH_STATE_FULL) {
-					asd->frame_status[vb->i] =
-						ATOMISP_FRAME_STATUS_FLASH_EXPOSED;
-					asd->params.num_flash_frames--;
-					dev_dbg(isp->dev,
-						 "%s completely flashed\n",
-						 __func__);
-				} else {
-					asd->frame_status[vb->i] =
-						ATOMISP_FRAME_STATUS_OK;
-					dev_dbg(isp->dev,
-						 "%s no flash in this frame\n",
-						 __func__);
-				}
+		dev_dbg(isp->dev, "%s: main frame with exp_id %d is ready\n",
+			__func__, frame->exp_id);
+		vb = atomisp_css_frame_to_vbuf(pipe, frame);
+		if (!vb) {
+			WARN_ON(1);
+			break;
+		}
 
-				/* Check if flashing sequence is done */
-				if (asd->frame_status[vb->i] ==
-					ATOMISP_FRAME_STATUS_FLASH_EXPOSED)
-					asd->params.flash_state =
-						ATOMISP_FLASH_DONE;
-			} else if (v4l2_subdev_call(isp->flash, core, g_ctrl, &ctrl) == 0 &&
-				ctrl.value == ATOMISP_FLASH_MODE_TORCH) {
-				ctrl.id = V4L2_CID_FLASH_TORCH_INTENSITY;
-				if (v4l2_subdev_call(isp->flash, core, g_ctrl, &ctrl) == 0 &&
-					ctrl.value > 0) {
-					asd->frame_status[vb->i] =
-						ATOMISP_FRAME_STATUS_FLASH_EXPOSED;
-				} else {
-					asd->frame_status[vb->i] =
-						ATOMISP_FRAME_STATUS_OK;
-				}
+		pipe->frame_config_id[vb->i] = frame->isp_config_id;
+		ctrl.id = V4L2_CID_FLASH_MODE;
+		if (asd->params.flash_state == ATOMISP_FLASH_ONGOING) {
+			if (frame->flash_state
+			    == CSS_FRAME_FLASH_STATE_PARTIAL) {
+				asd->frame_status[vb->i] =
+					ATOMISP_FRAME_STATUS_FLASH_PARTIAL;
+				dev_dbg(isp->dev, "%s partially flashed\n",
+					 __func__);
+			} else if (frame->flash_state
+				   == CSS_FRAME_FLASH_STATE_FULL) {
+				asd->frame_status[vb->i] =
+					ATOMISP_FRAME_STATUS_FLASH_EXPOSED;
+				asd->params.num_flash_frames--;
+				dev_dbg(isp->dev, "%s completely flashed\n",
+					 __func__);
 			} else {
 				asd->frame_status[vb->i] =
 					ATOMISP_FRAME_STATUS_OK;
+				dev_dbg(isp->dev,
+					 "%s no flash in this frame\n",
+					 __func__);
 			}
 
-			asd->params.last_frame_status =
-				asd->frame_status[vb->i];
-
-			if (asd->continuous_mode->val) {
-				if (css_pipe_id == CSS_PIPE_ID_PREVIEW ||
-				    css_pipe_id == CSS_PIPE_ID_VIDEO) {
-					asd->latest_preview_exp_id = frame->exp_id;
-				} else if (css_pipe_id ==
-						CSS_PIPE_ID_CAPTURE) {
-					if (asd->run_mode->val ==
-					    ATOMISP_RUN_MODE_VIDEO)
-					    dev_dbg(isp->dev,
-						    "SDV capture raw buffer id: %u\n",
-						    frame->exp_id);
-					else
-					    dev_dbg(isp->dev,
-						    "ZSL capture raw buffer id: %u\n",
-						    frame->exp_id);
-				}
+			/* Check if flashing sequence is done */
+			if (asd->frame_status[vb->i] ==
+				ATOMISP_FRAME_STATUS_FLASH_EXPOSED)
+				asd->params.flash_state =
+					ATOMISP_FLASH_DONE;
+		} else if (v4l2_subdev_call(isp->flash, core, g_ctrl, &ctrl) ==
+			0 && ctrl.value == ATOMISP_FLASH_MODE_TORCH) {
+			ctrl.id = V4L2_CID_FLASH_TORCH_INTENSITY;
+			if (v4l2_subdev_call(isp->flash, core, g_ctrl, &ctrl) ==
+				0 && ctrl.value > 0) {
+				asd->frame_status[vb->i] =
+					ATOMISP_FRAME_STATUS_FLASH_EXPOSED;
+			} else {
+				asd->frame_status[vb->i] =
+					ATOMISP_FRAME_STATUS_OK;
 			}
-			/*
-			 * Only after enabled the raw buffer lock
-			 * and in continuous mode.
-			 * in preview/video pipe, each buffer will
-			 * be locked automatically, so record it here.
-			 */
-			if (((css_pipe_id == CSS_PIPE_ID_PREVIEW) ||
-				(css_pipe_id == CSS_PIPE_ID_VIDEO)) &&
-				asd->enable_raw_buffer_lock->val &&
-				asd->continuous_mode->val) {
-				atomisp_set_raw_buffer_bitmap(asd, frame->exp_id);
-				WARN_ON(frame->exp_id > ATOMISP_MAX_EXP_ID);
+		} else {
+			asd->frame_status[vb->i] = ATOMISP_FRAME_STATUS_OK;
+		}
+
+		asd->params.last_frame_status = asd->frame_status[vb->i];
+
+		if (asd->continuous_mode->val) {
+			if (css_pipe_id == CSS_PIPE_ID_PREVIEW ||
+			    css_pipe_id == CSS_PIPE_ID_VIDEO) {
+				asd->latest_preview_exp_id = frame->exp_id;
+			} else if (css_pipe_id ==
+					CSS_PIPE_ID_CAPTURE) {
+				if (asd->run_mode->val ==
+					ATOMISP_RUN_MODE_VIDEO)
+					dev_dbg(isp->dev, "SDV capture raw buffer id: %u\n",
+					    frame->exp_id);
+				else
+					dev_dbg(isp->dev, "ZSL capture raw buffer id: %u\n",
+					    frame->exp_id);
 			}
+		}
+		/*
+		 * Only after enabled the raw buffer lock
+		 * and in continuous mode.
+		 * in preview/video pipe, each buffer will
+		 * be locked automatically, so record it here.
+		 */
+		if (((css_pipe_id == CSS_PIPE_ID_PREVIEW) ||
+			(css_pipe_id == CSS_PIPE_ID_VIDEO)) &&
+			asd->enable_raw_buffer_lock->val &&
+			asd->continuous_mode->val) {
+			atomisp_set_raw_buffer_bitmap(asd, frame->exp_id);
+			WARN_ON(frame->exp_id > ATOMISP_MAX_EXP_ID);
+		}
 
-			break;
-		default:
-			break;
+		break;
+	default:
+		break;
 	}
 	if (vb) {
 		get_buf_timestamp(&vb->ts);
@@ -1471,8 +1470,7 @@ void atomisp_wdt_work(struct work_struct *work)
 				unsigned int j;
 
 				dev_err(isp->dev, "%s, raw_buffer_locked_count %d\n",
-					__func__,
-				        asd->raw_buffer_locked_count);
+					__func__, asd->raw_buffer_locked_count);
 				for (j = 0; j <= ATOMISP_MAX_EXP_ID/32; j++)
 					dev_err(isp->dev, "%s, raw_buffer_bitmap[%d]: 0x%x\n",
 						__func__, j,
@@ -2125,13 +2123,12 @@ static void atomisp_update_grid_info(struct atomisp_sub_device *asd,
 		goto err;
 	}
 
-	if (atomisp_alloc_3a_output_buf(asd)){
+	if (atomisp_alloc_3a_output_buf(asd)) {
 		/* Failure for 3A buffers does not influence DIS buffers */
 		if (asd->params.s3a_output_bytes != 0) {
-		/* For SOC sensor happens s3a_output_bytes == 0,
-		*  using if condition to exclude false error log */
-			dev_err(isp->dev, "Failed to allocate memory for 3A"
-					" statistics\n");
+			/* For SOC sensor happens s3a_output_bytes == 0,
+			 * using if condition to exclude false error log */
+			dev_err(isp->dev, "Failed to allocate memory for 3A statistics\n");
 		}
 		goto err;
 	}
@@ -2142,9 +2139,8 @@ static void atomisp_update_grid_info(struct atomisp_sub_device *asd,
 		goto err;
 	}
 
-	if (atomisp_alloc_metadata_output_buf(asd)){
-		dev_err(isp->dev,
-			"Failed to allocate memory for metadata\n");
+	if (atomisp_alloc_metadata_output_buf(asd)) {
+		dev_err(isp->dev, "Failed to allocate memory for metadata\n");
 		goto err;
 	}
 
@@ -2367,9 +2363,9 @@ int atomisp_get_dvs2_bq_resolutions(struct atomisp_sub_device *asd,
 	/* the GDC input resolution */
 	if (!asd->continuous_mode->val) {
 		bq_res->source_bq.width_bq = bq_res->output_bq.width_bq +
-		                             pipe_cfg->dvs_envelope.width / 2;
+				pipe_cfg->dvs_envelope.width / 2;
 		bq_res->source_bq.height_bq = bq_res->output_bq.height_bq +
-		                            pipe_cfg->dvs_envelope.height / 2;
+				pipe_cfg->dvs_envelope.height / 2;
 		/*
 		 * Bad pixels caused by spatial filter processing
 		 * ISP filter resolution should be given by CSS/FW, but for now
@@ -2476,9 +2472,9 @@ int atomisp_get_dvs2_bq_resolutions(struct atomisp_sub_device *asd,
 			}
 
 			dvs_w = pipe_cfg->bayer_ds_out_res.width -
-			        pipe_cfg->output_info[0].res.width;
+				pipe_cfg->output_info[0].res.width;
 			dvs_h = pipe_cfg->bayer_ds_out_res.height -
-			        pipe_cfg->output_info[0].res.height;
+				pipe_cfg->output_info[0].res.height;
 			dvs_w_max = rounddown(
 					pipe_cfg->output_info[0].res.width / 5,
 					ATOM_ISP_STEP_WIDTH);
@@ -2596,10 +2592,8 @@ int atomisp_get_metadata(struct atomisp_sub_device *asd, int flag,
 	/* sanity check to avoid writing into unallocated memory.
 	 * This does not return an error because it is a valid way
 	 * for applications to detect that metadata is not enabled. */
-	if (md->width == 0 || md->height == 0 || !md->data) {
-		printk("%s: %d\n", __func__, __LINE__);
+	if (md->width == 0 || md->height == 0 || !md->data)
 		return 0;
-	}
 
 	/* This is done in the atomisp_buf_done() */
 	if (list_empty(&asd->metadata_ready[md_type])) {
@@ -2619,24 +2613,24 @@ int atomisp_get_metadata(struct atomisp_sub_device *asd, int flag,
 	}
 
 	md_buf = list_entry(asd->metadata_ready[md_type].next,
-	                    struct atomisp_metadata_buf, list);
+			struct atomisp_metadata_buf, list);
 	md->exp_id = md_buf->metadata->exp_id;
 	if (md_buf->md_vptr) {
 		ret = copy_to_user(md->data,
-		                   md_buf->md_vptr,
-				   stream_info->metadata_info.size);
+				md_buf->md_vptr,
+				stream_info->metadata_info.size);
 	} else {
 		hrt_isp_css_mm_load(md_buf->metadata->address,
-		                    asd->params.metadata_user[md_type],
-		                    stream_info->metadata_info.size);
+				asd->params.metadata_user[md_type],
+				stream_info->metadata_info.size);
 
 		ret = copy_to_user(md->data,
-		                   asd->params.metadata_user[md_type],
-				   stream_info->metadata_info.size);
+				asd->params.metadata_user[md_type],
+				stream_info->metadata_info.size);
 	}
 	if (ret) {
 		dev_err(isp->dev, "copy to user failed: copied %d bytes\n",
-				ret);
+			ret);
 		return -EFAULT;
 	} else {
 		list_del_init(&md_buf->list);
@@ -2702,24 +2696,24 @@ int atomisp_get_metadata_by_type(struct atomisp_sub_device *asd, int flag,
 	}
 
 	md_buf = list_entry(asd->metadata_ready[md_type].next,
-	                    struct atomisp_metadata_buf, list);
+			struct atomisp_metadata_buf, list);
 	md->exp_id = md_buf->metadata->exp_id;
 	if (md_buf->md_vptr) {
 		ret = copy_to_user(md->data,
-		                   md_buf->md_vptr,
-				   stream_info->metadata_info.size);
+				md_buf->md_vptr,
+				stream_info->metadata_info.size);
 	} else {
 		hrt_isp_css_mm_load(md_buf->metadata->address,
-		                    asd->params.metadata_user[md_type],
-		                    stream_info->metadata_info.size);
+				asd->params.metadata_user[md_type],
+				stream_info->metadata_info.size);
 
 		ret = copy_to_user(md->data,
-		                   asd->params.metadata_user[md_type],
-				   stream_info->metadata_info.size);
+				asd->params.metadata_user[md_type],
+				stream_info->metadata_info.size);
 	}
 	if (ret) {
 		dev_err(isp->dev, "copy to user failed: copied %d bytes\n",
-				ret);
+			ret);
 		return -EFAULT;
 	} else {
 		list_del_init(&md_buf->list);
@@ -2764,7 +2758,7 @@ static bool atomisp_check_zoom_region(
 	h = dz_config.zoom_region.origin.y +
 		dz_config.zoom_region.resolution.height;
 
-	if ((w <= config.width) && (h <= config.height) && w > 0 && h >0)
+	if ((w <= config.width) && (h <= config.height) && w > 0 && h > 0)
 		flag = true;
 
 	return flag;
@@ -3054,7 +3048,7 @@ static int __atomisp_cp_lsc_table(struct atomisp_sub_device *asd,
 	/* user config is to disable the shading table. */
 	if (!user_st->enable) {
 		/* Generate a minimum table with enable = 0. */
-		shading_table = atomisp_css_shading_table_alloc(1,1);
+		shading_table = atomisp_css_shading_table_alloc(1, 1);
 		if (!shading_table)
 			return -ENOMEM;
 		shading_table->enable = 0;
@@ -3306,7 +3300,8 @@ error:
 	return ret;
 }
 
-void atomisp_free_css_parameters(struct atomisp_css_params *css_param) {
+void atomisp_free_css_parameters(struct atomisp_css_params *css_param)
+{
 	if (css_param->dvs_6axis) {
 		ia_css_dvs2_6axis_config_free(css_param->dvs_6axis);
 		css_param->dvs_6axis = NULL;
@@ -3423,7 +3418,7 @@ int atomisp_set_parameters(struct video_device *vdev,
 
 	dev_dbg(asd->isp->dev, "%s: set parameter(per_frame_setting %d) with isp_config_id %d of %s\n",
 		__func__, arg->per_frame_setting, arg->isp_config_id,
-	        vdev->name);
+		vdev->name);
 
 	if (arg->per_frame_setting && !atomisp_is_vf_pipe(pipe)) {
 		/*
@@ -3435,7 +3430,7 @@ int atomisp_set_parameters(struct video_device *vdev,
 		param = atomisp_kernel_zalloc(sizeof(*param), true);
 		if (!param) {
 			dev_err(asd->isp->dev, "%s: failed to alloc params buffer\n",
-			        __func__);
+				__func__);
 			return -ENOMEM;
 		}
 		memcpy(&param->us_params, arg, sizeof(*arg));
@@ -3536,9 +3531,9 @@ int atomisp_param(struct atomisp_sub_device *asd, int flag,
 			unsigned int dvs_w, dvs_h, dvs_w_max, dvs_h_max;
 
 			dvs_w = vp_cfg->bayer_ds_out_res.width -
-			        vp_cfg->output_info[0].res.width;
+				vp_cfg->output_info[0].res.width;
 			dvs_h = vp_cfg->bayer_ds_out_res.height -
-			        vp_cfg->output_info[0].res.height;
+				vp_cfg->output_info[0].res.height;
 			dvs_w_max = rounddown(
 					vp_cfg->output_info[0].res.width / 5,
 					ATOM_ISP_STEP_WIDTH);
@@ -4363,7 +4358,7 @@ static int css_input_resolution_changed(struct atomisp_sub_device *asd,
 	 */
 	for (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {
 		list_for_each_entry_safe(md_buf, _md_buf, &asd->metadata[i],
-		                         list) {
+					list) {
 			atomisp_css_free_metadata_buffer(md_buf);
 			list_del(&md_buf->list);
 			kfree(md_buf);
@@ -4849,13 +4844,13 @@ int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
 			r.height = f->fmt.pix.height;
 
 			if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW)
-			    capture_comp = atomisp_subdev_get_rect(
+				capture_comp = atomisp_subdev_get_rect(
 					&asd->subdev, NULL,
 					V4L2_SUBDEV_FORMAT_ACTIVE,
 					ATOMISP_SUBDEV_PAD_SOURCE_VIDEO,
 					V4L2_SEL_TGT_COMPOSE);
 			else
-			    capture_comp = atomisp_subdev_get_rect(
+				capture_comp = atomisp_subdev_get_rect(
 					&asd->subdev, NULL,
 					V4L2_SUBDEV_FORMAT_ACTIVE,
 					ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
@@ -5527,20 +5522,20 @@ int atomisp_source_pad_to_stream_id(struct atomisp_sub_device *asd,
 		return ATOMISP_INPUT_STREAM_GENERAL;
 
 	switch (source_pad) {
-		case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
-			stream_id = ATOMISP_INPUT_STREAM_CAPTURE;
-			break;
-		case ATOMISP_SUBDEV_PAD_SOURCE_VF:
-			stream_id = ATOMISP_INPUT_STREAM_POSTVIEW;
-			break;
-		case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
-			stream_id = ATOMISP_INPUT_STREAM_PREVIEW;
-			break;
-		case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO:
-			stream_id = ATOMISP_INPUT_STREAM_VIDEO;
-			break;
-		default:
-			stream_id = ATOMISP_INPUT_STREAM_GENERAL;
+	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
+		stream_id = ATOMISP_INPUT_STREAM_CAPTURE;
+		break;
+	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
+		stream_id = ATOMISP_INPUT_STREAM_POSTVIEW;
+		break;
+	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
+		stream_id = ATOMISP_INPUT_STREAM_PREVIEW;
+		break;
+	case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO:
+		stream_id = ATOMISP_INPUT_STREAM_VIDEO;
+		break;
+	default:
+		stream_id = ATOMISP_INPUT_STREAM_GENERAL;
 	}
 
 	return stream_id;
@@ -5570,10 +5565,10 @@ static int __checking_exp_id(struct atomisp_sub_device *asd, int exp_id)
 	}
 	if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
 		dev_err(isp->dev, "%s streaming %d invalid exp_id %d.\n",
-		        __func__, exp_id, asd->streaming);
+			__func__, exp_id, asd->streaming);
 		return -EINVAL;
 	}
-	if ((exp_id > ATOMISP_MAX_EXP_ID) || (exp_id <= 0) ) {
+	if ((exp_id > ATOMISP_MAX_EXP_ID) || (exp_id <= 0)) {
 		dev_err(isp->dev, "%s exp_id %d invalid.\n", __func__, exp_id);
 		return -EINVAL;
 	}
@@ -5601,11 +5596,11 @@ int atomisp_set_raw_buffer_bitmap(struct atomisp_sub_device *asd, int exp_id)
 	bit = exp_id % 32;
 	spin_lock_irqsave(&asd->raw_buffer_bitmap_lock, flags);
 	(*bitmap) |= (1 << bit);
-	asd->raw_buffer_locked_count ++;
+	asd->raw_buffer_locked_count++;
 	spin_unlock_irqrestore(&asd->raw_buffer_bitmap_lock, flags);
 
 	dev_dbg(asd->isp->dev, "%s: exp_id %d,  raw_buffer_locked_count %d\n",
-	        __func__, exp_id, asd->raw_buffer_locked_count);
+		__func__, exp_id, asd->raw_buffer_locked_count);
 
 	/* Check if the raw buffer after next is still locked!!! */
 	exp_id += 2;
@@ -5620,16 +5615,16 @@ int atomisp_set_raw_buffer_bitmap(struct atomisp_sub_device *asd, int exp_id)
 		ret = atomisp_css_exp_id_unlock(asd, exp_id);
 		if (ret) {
 			dev_err(asd->isp->dev, "%s exp_id is wrapping back to %d but force unlock failed,, err %d.\n",
-			        __func__, exp_id, ret);
+				__func__, exp_id, ret);
 			return ret;
 		}
 
 		spin_lock_irqsave(&asd->raw_buffer_bitmap_lock, flags);
 		(*bitmap) &= ~(1 << bit);
-		asd->raw_buffer_locked_count --;
+		asd->raw_buffer_locked_count--;
 		spin_unlock_irqrestore(&asd->raw_buffer_bitmap_lock, flags);
 		dev_warn(asd->isp->dev, "%s exp_id is wrapping back to %d but it is still locked so force unlock it, raw_buffer_locked_count %d\n",
-		         __func__, exp_id, asd->raw_buffer_locked_count);
+			__func__, exp_id, asd->raw_buffer_locked_count);
 	}
 	return 0;
 }
@@ -5663,11 +5658,11 @@ static int __clear_raw_buffer_bitmap(struct atomisp_sub_device *asd, int exp_id)
 	bit = exp_id % 32;
 	spin_lock_irqsave(&asd->raw_buffer_bitmap_lock, flags);
 	(*bitmap) &= ~(1 << bit);
-	asd->raw_buffer_locked_count --;
+	asd->raw_buffer_locked_count--;
 	spin_unlock_irqrestore(&asd->raw_buffer_bitmap_lock, flags);
 
 	dev_dbg(asd->isp->dev, "%s: exp_id %d,  raw_buffer_locked_count %d\n",
-	        __func__, exp_id, asd->raw_buffer_locked_count);
+		__func__, exp_id, asd->raw_buffer_locked_count);
 	return 0;
 }
 
@@ -5708,7 +5703,7 @@ int atomisp_exp_id_unlock(struct atomisp_sub_device *asd, int *exp_id)
 	ret = atomisp_css_exp_id_unlock(asd, value);
 	if (ret)
 		dev_err(isp->dev, "%s exp_id %d failed, err %d.\n",
-		        __func__, value, ret);
+			__func__, value, ret);
 
 	return ret;
 }
@@ -5734,7 +5729,7 @@ int atomisp_inject_a_fake_event(struct atomisp_sub_device *asd, int *event)
 		return -EINVAL;
 
 	dev_dbg(asd->isp->dev, "%s: trying to inject a fake event 0x%x\n",
-	        __func__, *event);
+		__func__, *event);
 
 	switch (*event) {
 	case V4L2_EVENT_FRAME_SYNC:
@@ -5784,7 +5779,7 @@ int atomisp_get_pipe_id(struct atomisp_video_pipe *pipe)
 
 	/* fail through */
 	dev_warn(asd->isp->dev, "%s failed to find proper pipe\n",
-	         __func__);
+		__func__);
 	return CSS_PIPE_ID_CAPTURE;
 }
 
@@ -5807,7 +5802,7 @@ int atomisp_get_invalid_frame_num(struct video_device *vdev,
 	pipe_id = atomisp_get_pipe_id(pipe);
 	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipes[pipe_id]) {
 		dev_warn(asd->isp->dev, "%s pipe %d has not been created yet, do SET_FMT first!\n",
-		         __func__, pipe_id);
+			__func__, pipe_id);
 		return -EINVAL;
 	}
 
@@ -5819,7 +5814,7 @@ int atomisp_get_invalid_frame_num(struct video_device *vdev,
 		return 0;
 	} else {
 		dev_warn(asd->isp->dev, "%s get pipe infor failed %d\n",
-		         __func__, ret);
+			 __func__, ret);
 		return -EINVAL;
 	}
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h
index 578d8c6..4ccbbb9 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_cmd.h
@@ -45,6 +45,10 @@ struct atomisp_css_frame;
 #define INTR_IER		24
 #define INTR_IIR		16
 
+#ifdef CONFIG_GMIN_INTEL_MID
+extern int atomisp_punit_hpll_freq;
+#endif
+
 /*
  * Helper function
  */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c
index a3bb13a..bb721f1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.c
@@ -58,7 +58,6 @@
  * #4684168, if concurrency access happened, system may hard hang.
  */
 static DEFINE_SPINLOCK(mmio_lock);
-extern raw_spinlock_t pci_config_lock;
 
 enum frame_info_type {
 	ATOMISP_CSS_VF_FRAME,
@@ -397,7 +396,7 @@ static void __dump_pipe_config(struct atomisp_sub_device *asd,
 }
 
 static void __dump_stream_config(struct atomisp_sub_device *asd,
-        struct atomisp_stream_env *stream_env)
+				struct atomisp_stream_env *stream_env)
 {
 	struct atomisp_device *isp = asd->isp;
 	struct ia_css_stream_config *s_config;
@@ -786,40 +785,40 @@ static bool is_pipe_valid_to_current_run_mode(struct atomisp_sub_device *asd,
 		return true;
 
 	switch (asd->run_mode->val) {
-		case ATOMISP_RUN_MODE_STILL_CAPTURE:
-			if (pipe_id == IA_CSS_PIPE_ID_CAPTURE)
-				return true;
-			else
-				return false;
-		case ATOMISP_RUN_MODE_PREVIEW:
-			if (!asd->continuous_mode->val) {
-				if (pipe_id == IA_CSS_PIPE_ID_PREVIEW)
-					return true;
-				else
-					return false;
-			}
-			/* fall through to ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE */
-		case ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE:
-			if (pipe_id == IA_CSS_PIPE_ID_CAPTURE ||
-			    pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+	case ATOMISP_RUN_MODE_STILL_CAPTURE:
+		if (pipe_id == IA_CSS_PIPE_ID_CAPTURE)
+			return true;
+		else
+			return false;
+	case ATOMISP_RUN_MODE_PREVIEW:
+		if (!asd->continuous_mode->val) {
+			if (pipe_id == IA_CSS_PIPE_ID_PREVIEW)
 				return true;
 			else
 				return false;
-		case ATOMISP_RUN_MODE_VIDEO:
-			if (!asd->continuous_mode->val) {
-				if (pipe_id == IA_CSS_PIPE_ID_VIDEO ||
-				    pipe_id == IA_CSS_PIPE_ID_YUVPP)
-					return true;
-				else
-					return false;
-			}
-			/* fall through to ATOMISP_RUN_MODE_SDV */
-		case ATOMISP_RUN_MODE_SDV:
-			if (pipe_id == IA_CSS_PIPE_ID_CAPTURE ||
-			    pipe_id == IA_CSS_PIPE_ID_VIDEO)
+		}
+		/* fall through to ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE */
+	case ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE:
+		if (pipe_id == IA_CSS_PIPE_ID_CAPTURE ||
+		    pipe_id == IA_CSS_PIPE_ID_PREVIEW)
+			return true;
+		else
+			return false;
+	case ATOMISP_RUN_MODE_VIDEO:
+		if (!asd->continuous_mode->val) {
+			if (pipe_id == IA_CSS_PIPE_ID_VIDEO ||
+			    pipe_id == IA_CSS_PIPE_ID_YUVPP)
 				return true;
 			else
 				return false;
+		}
+		/* fall through to ATOMISP_RUN_MODE_SDV */
+	case ATOMISP_RUN_MODE_SDV:
+		if (pipe_id == IA_CSS_PIPE_ID_CAPTURE ||
+		    pipe_id == IA_CSS_PIPE_ID_VIDEO)
+			return true;
+		else
+			return false;
 	}
 
 	return false;
@@ -1429,15 +1428,15 @@ void atomisp_css_update_isp_params_on_pipe(struct atomisp_sub_device *asd,
 	}
 
 	dev_dbg(asd->isp->dev, "%s: apply parameter for ia_css_frame %p with isp_config_id %d on pipe %p.\n",
-	        __func__, asd->params.config.output_frame,
-	        asd->params.config.isp_config_id, pipe);
+		__func__, asd->params.config.output_frame,
+		asd->params.config.isp_config_id, pipe);
 
 	ret = ia_css_stream_set_isp_config_on_pipe(
 			asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
 			&asd->params.config, pipe);
 	if (ret != IA_CSS_SUCCESS)
 		dev_warn(asd->isp->dev, "%s: ia_css_stream_set_isp_config_on_pipe failed %d\n",
-		         __func__, ret);
+			__func__, ret);
 	atomisp_isp_parameters_clean_up(&asd->params.config);
 }
 
@@ -1625,19 +1624,19 @@ void atomisp_css_free_stat_buffers(struct atomisp_sub_device *asd)
 
 	for (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {
 		list_for_each_entry_safe(md_buf, _md_buf,
-		                         &asd->metadata[i], list) {
+					&asd->metadata[i], list) {
 			atomisp_css_free_metadata_buffer(md_buf);
 			list_del(&md_buf->list);
 			kfree(md_buf);
 		}
 		list_for_each_entry_safe(md_buf, _md_buf,
-		                         &asd->metadata_in_css[i], list) {
+					&asd->metadata_in_css[i], list) {
 			atomisp_css_free_metadata_buffer(md_buf);
 			list_del(&md_buf->list);
 			kfree(md_buf);
 		}
 		list_for_each_entry_safe(md_buf, _md_buf,
-		                         &asd->metadata_ready[i], list) {
+					&asd->metadata_ready[i], list) {
 			atomisp_css_free_metadata_buffer(md_buf);
 			list_del(&md_buf->list);
 			kfree(md_buf);
@@ -2661,8 +2660,7 @@ static void __configure_preview_pp_input(struct atomisp_sub_device *asd,
 	struct ia_css_resolution  *effective_res =
 		&stream_config->input_config.effective_res;
 
-	const struct bayer_ds_factor bds_fct[] =
-		{{2, 1}, {3, 2}, {5, 4}};
+	const struct bayer_ds_factor bds_fct[] = {{2, 1}, {3, 2}, {5, 4} };
 	/*
 	 * BZ201033: YUV decimation factor of 4 causes couple of rightmost
 	 * columns to be shaded. Remove this factor to work around the CSS bug.
@@ -2781,8 +2779,8 @@ static void __configure_video_pp_input(struct atomisp_sub_device *asd,
 	struct ia_css_resolution  *effective_res =
 		&stream_config->input_config.effective_res;
 
-	const struct bayer_ds_factor bds_factors[] =
-		{{8, 1}, {6, 1}, {4, 1}, {3, 1}, {2, 1}, {3, 2}};
+	const struct bayer_ds_factor bds_factors[] = {
+		{8, 1}, {6, 1}, {4, 1}, {3, 1}, {2, 1}, {3, 2} };
 	unsigned int i;
 
 	if (width == 0 && height == 0)
@@ -4569,15 +4567,15 @@ int atomisp_css_isr_thread(struct atomisp_device *isp,
 		if (current_event.event.type == IA_CSS_EVENT_TYPE_FW_ERROR) {
 			/* Received FW error signal, trigger WDT to recover */
 			dev_err(isp->dev, "%s: ISP reports FW_ERROR event, error code %d!!!!",
-			        __func__, current_event.event.fw_error);
+				__func__, current_event.event.fw_error);
 			for (i = 0; i < isp->num_of_streams; i++)
 				atomisp_wdt_stop(&isp->asd[i], 0);
 			atomisp_wdt((unsigned long)isp);
 			return -EINVAL;
 		} else if (current_event.event.type == IA_CSS_EVENT_TYPE_FW_WARNING) {
 			dev_warn(isp->dev, "%s: ISP reports warning, code is %d, exp_id %d\n",
-			        __func__, current_event.event.fw_warning,
-			        current_event.event.exp_id);
+				__func__, current_event.event.fw_warning,
+				current_event.event.exp_id);
 			continue;
 		}
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h
index e0cf98a..7c8dc72 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_css20.h
@@ -84,7 +84,6 @@
 #define atomisp_css_dvs_6axis_config	ia_css_dvs_6axis_config
 #define atomisp_css_fw_info	ia_css_fw_info
 #define atomisp_css_formats_config	ia_css_formats_config
-typedef struct ia_css_isp_3a_statistics atomisp_css_3a_data;
 
 #define CSS_PIPE_ID_PREVIEW	IA_CSS_PIPE_ID_PREVIEW
 #define CSS_PIPE_ID_COPY	IA_CSS_PIPE_ID_COPY
@@ -181,7 +180,7 @@ struct atomisp_css_env {
 };
 
 struct atomisp_s3a_buf {
-	atomisp_css_3a_data *s3a_data;
+	struct ia_css_isp_3a_statistics *s3a_data;
 	struct ia_css_isp_3a_statistics_map *s3a_map;
 	struct list_head list;
 };
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c
index 2e0abd1..cb6ead5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.c
@@ -697,7 +697,7 @@ static int get_atomisp_parameters32(struct atomisp_parameters *kp,
 	if (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_parameters32)))
 			return -EFAULT;
 
-	while(n-- > 0) {
+	while (n-- > 0) {
 		compat_uptr_t *src = (compat_uptr_t *)up + n;
 		uintptr_t *dst = (uintptr_t *)kp + n;
 
@@ -1028,7 +1028,7 @@ long atomisp_do_compat_ioctl(struct file *file,
 		break;
 	case ATOMISP_IOC_G_METADATA_BY_TYPE:
 		err = get_atomisp_metadata_by_type_stat32(&karg.md_with_type,
-		                                          up);
+							up);
 		break;
 	case ATOMISP_IOC_S_SENSOR_AE_BRACKETING_LUT:
 		err = get_atomisp_sensor_ae_bracketing_lut(&karg.lut, up);
@@ -1090,7 +1090,7 @@ long atomisp_do_compat_ioctl(struct file *file,
 		break;
 	case ATOMISP_IOC_G_METADATA_BY_TYPE:
 		err = put_atomisp_metadata_by_type_stat32(&karg.md_with_type,
-		                                          up);
+							up);
 		break;
 	}
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.h
index 35983dc..750478f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_compat_ioctl32.h
@@ -101,7 +101,7 @@ struct atomisp_morph_table32 {
 struct v4l2_framebuffer32 {
 	__u32			capability;
 	__u32			flags;
-	compat_uptr_t 		base;
+	compat_uptr_t		base;
 	struct v4l2_pix_format	fmt;
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_drvfs.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_drvfs.c
index 492ba20..327a5c5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_drvfs.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_drvfs.c
@@ -41,11 +41,11 @@ struct _iunit_debug {
 	struct atomisp_device	*isp;
 	unsigned int		dbglvl;
 	unsigned int		dbgfun;
-	unsigned int 		dbgopt;
+	unsigned int		dbgopt;
 };
 
 #define OPTION_BIN_LIST			(1<<0)
-#define OPTION_BIN_RUN 			(1<<1)
+#define OPTION_BIN_RUN			(1<<1)
 #define OPTION_MEM_STAT			(1<<2)
 #define OPTION_VALID			(OPTION_BIN_LIST \
 					| OPTION_BIN_RUN \
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_fops.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_fops.c
index a2b955a..7da5134 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_fops.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_fops.c
@@ -54,11 +54,13 @@
 #define	ISP_PARAM_MMAP_OFFSET	0xfffff000
 
 #define MAGIC_CHECK(is, should)	\
-	if (unlikely((is) != (should))) { \
-		printk(KERN_ERR "magic mismatch: %x (expected %x)\n", \
-			is, should); \
-		BUG(); \
-	}
+	do { \
+		if (unlikely((is) != (should))) { \
+			pr_err("magic mismatch: %x (expected %x)\n", \
+				is, should); \
+			BUG(); \
+		} \
+	} while (0)
 
 /*
  * Videobuf ops
@@ -167,7 +169,7 @@ static int atomisp_q_metadata_buffers_to_css(struct atomisp_sub_device *asd,
 			metadata_list = &asd->metadata_ready[md_type];
 		} else {
 			dev_warn(asd->isp->dev, "%s: No metadata buffers available for type %d!\n",
-			         __func__, md_type);
+				__func__, md_type);
 			return -EINVAL;
 		}
 
@@ -181,7 +183,7 @@ static int atomisp_q_metadata_buffers_to_css(struct atomisp_sub_device *asd,
 			return -EINVAL;
 		} else {
 			list_add_tail(&metadata_buf->list,
-			              &asd->metadata_in_css[md_type]);
+					&asd->metadata_in_css[md_type]);
 		}
 		asd->metadata_bufs_in_css[stream_id][css_pipe_id]++;
 	}
@@ -204,12 +206,12 @@ int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *asd,
 			s3a_list = &asd->s3a_stats_ready;
 		} else {
 			dev_warn(asd->isp->dev, "%s: No s3a buffers available!\n",
-			         __func__);
+				__func__);
 			return -EINVAL;
 		}
 
 		s3a_buf = list_entry(s3a_list->next, struct atomisp_s3a_buf,
-		                     list);
+					list);
 		list_del_init(&s3a_buf->list);
 		exp_id = s3a_buf->s3a_data->exp_id;
 
@@ -223,7 +225,7 @@ int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *asd,
 			list_add_tail(&s3a_buf->list, &asd->s3a_stats_in_css);
 			if (s3a_list == &asd->s3a_stats_ready)
 				dev_warn(asd->isp->dev, "%s: drop one s3a stat which has exp_id %d!\n",
-				         __func__, exp_id);
+					__func__, exp_id);
 		}
 
 		asd->s3a_bufs_in_css[css_pipe_id]++;
@@ -244,7 +246,7 @@ int atomisp_q_dis_buffers_to_css(struct atomisp_sub_device *asd,
 		if (list_empty(&asd->dis_stats)) {
 			spin_unlock_irqrestore(&asd->dis_stats_lock, irqflags);
 			dev_warn(asd->isp->dev, "%s: No dis buffers available!\n",
-			         __func__);
+				__func__);
 			return -EINVAL;
 		}
 
@@ -350,7 +352,7 @@ static int atomisp_qbuffers_to_css_for_all_pipes(struct atomisp_sub_device *asd)
 			css_preview_pipe_id);
 	}
 
-	buf_type = atomisp_get_css_buf_type( asd, css_capture_pipe_id,
+	buf_type = atomisp_get_css_buf_type(asd, css_capture_pipe_id,
 			atomisp_subdev_source_pad(&capture_pipe->vdev));
 	input_stream_id = ATOMISP_INPUT_STREAM_GENERAL;
 	atomisp_q_video_buffers_to_css(asd, capture_pipe,
@@ -678,11 +680,11 @@ static int atomisp_init_pipe(struct atomisp_video_pipe *pipe)
 	INIT_LIST_HEAD(&pipe->activeq_out);
 	INIT_LIST_HEAD(&pipe->buffers_waiting_for_param);
 	INIT_LIST_HEAD(&pipe->per_frame_params);
-	memset(pipe->frame_request_config_id,
-	       0, VIDEO_MAX_FRAME * sizeof(unsigned int));
-	memset(pipe->frame_params,
-	       0, VIDEO_MAX_FRAME *
-	          sizeof(struct atomisp_css_params_with_list *));
+	memset(pipe->frame_request_config_id, 0,
+		VIDEO_MAX_FRAME * sizeof(unsigned int));
+	memset(pipe->frame_params, 0,
+		VIDEO_MAX_FRAME *
+		sizeof(struct atomisp_css_params_with_list *));
 
 	return 0;
 }
@@ -1038,8 +1040,7 @@ int atomisp_videobuf_mmap_mapper(struct videobuf_queue *q,
 
 	MAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);
 	if (!(vma->vm_flags & VM_WRITE) || !(vma->vm_flags & VM_SHARED)) {
-		dev_err(isp->dev, "map appl bug: PROT_WRITE and MAP_SHARED "
-				  "are required\n");
+		dev_err(isp->dev, "map appl bug: PROT_WRITE and MAP_SHARED are required\n");
 		return -EINVAL;
 	}
 
@@ -1064,11 +1065,7 @@ int atomisp_videobuf_mmap_mapper(struct videobuf_queue *q,
 		    buf->boff == offset) {
 			vm_mem = buf->priv;
 			ret = frame_mmap(isp, vm_mem->vaddr, vma);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 			vma->vm_flags |= VM_IO|VM_DONTEXPAND|VM_DONTDUMP;
-#else
-			vma->vm_flags |= VM_DONTEXPAND | VM_RESERVED;
-#endif
 			break;
 		}
 	}
@@ -1096,7 +1093,6 @@ static int remove_pad_from_frame(struct atomisp_device *isp,
 		return -ENOMEM;
 	}
 
-//#define ISP_LEFT_PAD			128	/* equal to 2*NWAY */
 	load += ISP_LEFT_PAD;
 	for (i = 0; i < height; i++) {
 		ret = hrt_isp_css_mm_load(load, buffer, width*sizeof(load));
@@ -1173,8 +1169,7 @@ static int atomisp_mmap(struct file *file, struct vm_area_struct *vma)
 		raw_virt_addr->data_bytes = new_size;
 
 		if (size != PAGE_ALIGN(new_size)) {
-			dev_err(isp->dev, "incorrect size for mmap ISP"
-				 " Raw Frame\n");
+			dev_err(isp->dev, "incorrect size for mmap ISP  Raw Frame\n");
 			ret = -EINVAL;
 			goto error;
 		}
@@ -1186,11 +1181,7 @@ static int atomisp_mmap(struct file *file, struct vm_area_struct *vma)
 			goto error;
 		}
 		raw_virt_addr->data_bytes = origin_size;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 		vma->vm_flags |= VM_IO|VM_DONTEXPAND|VM_DONTDUMP;
-#else
-		vma->vm_flags |= VM_RESERVED;
-#endif
 		rt_mutex_unlock(&isp->mutex);
 		return 0;
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h
index 588593b..42cb36d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_internal.h
@@ -318,6 +318,8 @@ struct atomisp_device {
 #define v4l2_dev_to_atomisp_device(dev) \
 	container_of(dev, struct atomisp_device, v4l2_dev)
 
+extern raw_spinlock_t pci_config_lock;
+
 extern struct device *atomisp_dev;
 
 extern void *atomisp_kernel_malloc(size_t bytes);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c
index 6f74874..e3b61c9 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_ioctl.c
@@ -503,14 +503,13 @@ const struct atomisp_format_bridge atomisp_output_fmts[] = {
 		.mbus_code = V4L2_MBUS_FMT_BGR565_2X8_LE,
 		.sh_fmt = CSS_FRAME_FORMAT_RGB565,
 		.description = "16 RGB 5-6-5"
-	},{
+	}, {
 		.pixelformat = V4L2_PIX_FMT_JPEG,
 		.depth = 8,
 		.mbus_code = V4L2_MBUS_FMT_JPEG_1X8,
 		.sh_fmt = CSS_FRAME_FORMAT_BINARY_8,
 		.description = "JPEG"
-	},
-	{
+	}, {
 	/* This is a custom format being used by M10MO to send the RAW data */
 		.pixelformat = V4L2_PIX_FMT_CUSTOM_M10MO_RAW,
 		.depth = 8,
@@ -1006,7 +1005,7 @@ int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,
 	if (list_empty(&asd->s3a_stats) &&
 		asd->params.curr_grid_info.s3a_grid.enable) {
 		count = ATOMISP_CSS_Q_DEPTH +
-		        ATOMISP_S3A_BUF_QUEUE_DEPTH_FOR_HAL;
+			ATOMISP_S3A_BUF_QUEUE_DEPTH_FOR_HAL;
 		dev_dbg(isp->dev, "allocating %d 3a buffers\n", count);
 		while (count--) {
 			s3a_buf = kzalloc(sizeof(struct atomisp_s3a_buf), GFP_KERNEL);
@@ -1053,7 +1052,7 @@ int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd,
 			count = ATOMISP_CSS_Q_DEPTH +
 				ATOMISP_METADATA_QUEUE_DEPTH_FOR_HAL;
 			dev_dbg(isp->dev, "allocating %d metadata buffers for type %d\n",
-			        count, i);
+				count, i);
 			while (count--) {
 				md_buf = kzalloc(sizeof(struct atomisp_metadata_buf),
 						 GFP_KERNEL);
@@ -1090,7 +1089,7 @@ error:
 
 	for (i = 0; i < ATOMISP_METADATA_TYPE_NUM; i++) {
 		list_for_each_entry_safe(md_buf, _md_buf, &asd->metadata[i],
-		                         list) {
+					list) {
 			atomisp_css_free_metadata_buffer(md_buf);
 			list_del(&md_buf->list);
 			kfree(md_buf);
@@ -1117,17 +1116,17 @@ int __atomisp_reqbufs(struct file *file, void *fh,
 
 	if (req->count == 0) {
 		mutex_lock(&pipe->capq.vb_lock);
-		if (!list_empty(&pipe->capq.stream)) {
+		if (!list_empty(&pipe->capq.stream))
 			videobuf_queue_cancel(&pipe->capq);
-		}
+
 		atomisp_videobuf_free_queue(&pipe->capq);
 		mutex_unlock(&pipe->capq.vb_lock);
 		/* clear request config id */
-		memset(pipe->frame_request_config_id,
-		       0, VIDEO_MAX_FRAME * sizeof(unsigned int));
-		memset(pipe->frame_params,
-		       0, VIDEO_MAX_FRAME *
-		          sizeof(struct atomisp_css_params_with_list *));
+		memset(pipe->frame_request_config_id, 0,
+			VIDEO_MAX_FRAME * sizeof(unsigned int));
+		memset(pipe->frame_params, 0,
+			VIDEO_MAX_FRAME *
+			sizeof(struct atomisp_css_params_with_list *));
 		return 0;
 	}
 
@@ -1331,7 +1330,7 @@ done:
 		pipe->frame_request_config_id[buf->index] = buf->reserved2 &
 					~ATOMISP_BUFFER_HAS_PER_FRAME_SETTING;
 		dev_dbg(isp->dev, "This buffer requires per_frame setting which has isp_config_id %d\n",
-		        pipe->frame_request_config_id[buf->index]);
+			pipe->frame_request_config_id[buf->index]);
 	} else {
 		pipe->frame_request_config_id[buf->index] = 0;
 	}
@@ -1707,13 +1706,11 @@ static int atomisp_streamon(struct file *file, void *fh,
 		    atomisp_subdev_source_pad(vdev)
 		    == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE) {
 			if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-			    dev_dbg(isp->dev,
-				"SDV last video raw buffer id: %u\n",
-				asd->latest_preview_exp_id);
+				dev_dbg(isp->dev, "SDV last video raw buffer id: %u\n",
+					asd->latest_preview_exp_id);
 			else
-			    dev_dbg(isp->dev,
-				"ZSL last preview raw buffer id: %u\n",
-				asd->latest_preview_exp_id);
+				dev_dbg(isp->dev, "ZSL last preview raw buffer id: %u\n",
+					asd->latest_preview_exp_id);
 
 			if (asd->delayed_init == ATOMISP_DELAYED_INIT_QUEUED) {
 				flush_work(&asd->delayed_init_work);
@@ -2628,11 +2625,7 @@ static int atomisp_s_parm_file(struct file *file, void *fh,
 }
 
 static long atomisp_vidioc_default(struct file *file, void *fh,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 	bool valid_prio, unsigned int cmd, void *arg)
-#else
-	bool valid_prio, int cmd, void *arg)
-#endif
 {
 	struct video_device *vdev = video_devdata(file);
 	struct atomisp_device *isp = video_get_drvdata(vdev);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_subdev.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_subdev.c
index 283ac83..de3f7b8 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_subdev.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_subdev.c
@@ -497,11 +497,11 @@ int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
 		 * ratio = width / height
 		 *
 		 * if ratio_output < ratio_sensor:
-		 * 	effect_width = sensor_height * out_width / out_height;
-		 * 	effect_height = sensor_height;
+		 *	effect_width = sensor_height * out_width / out_height;
+		 *	effect_height = sensor_height;
 		 * else
-		 * 	effect_width = sensor_width;
-		 * 	effect_height = sensor_width * out_height / out_width;
+		 *	effect_width = sensor_width;
+		 *	effect_height = sensor_width * out_height / out_width;
 		 *
 		 */
 		if (r->width * crop[ATOMISP_SUBDEV_PAD_SINK]->height <
@@ -1055,7 +1055,7 @@ static void atomisp_init_subdev_pipe(struct atomisp_sub_device *asd,
 	       0, VIDEO_MAX_FRAME * sizeof(unsigned int));
 	memset(pipe->frame_params,
 	       0, VIDEO_MAX_FRAME *
-	          sizeof(struct atomisp_css_params_with_list *));
+		sizeof(struct atomisp_css_params_with_list *));
 }
 
 /*
@@ -1219,7 +1219,7 @@ void atomisp_subdev_cleanup_pending_events(struct atomisp_sub_device *asd)
 	unsigned int i, pending_event;
 
 	list_for_each_entry_safe(fh, fh_tmp,
-	                         &asd->subdev.devnode->fh_list, list) {
+		&asd->subdev.devnode->fh_list, list) {
 		pending_event = v4l2_event_pending(fh);
 		for (i = 0; i < pending_event; i++)
 			v4l2_event_dequeue(fh, &event, 1);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_trace_event.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_trace_event.h
index 5889287..60c1845 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_trace_event.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_trace_event.h
@@ -87,7 +87,7 @@ TRACE_EVENT(camera_debug,
 
 #undef TRACE_INCLUDE_PATH
 #undef TRACE_INCLUDE_FILE
-#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_PATH (.)
 #define TRACE_INCLUDE_FILE   atomisp_trace_event
 /* This part must be outside protection */
 #include <trace/define_trace.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c
index 0b9448b..f775b5a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/atomisp_v4l2.c
@@ -88,7 +88,7 @@ MODULE_PARM_DESC(defer_fw_load,
 		"Defer FW loading until device is opened (default:disable)");
 
 /* cross componnet debug message flag */
-int dbg_level = 0;
+int dbg_level;
 module_param(dbg_level, int, 0644);
 MODULE_PARM_DESC(dbg_level, "debug message on/off (default:off)");
 
@@ -612,8 +612,9 @@ static int atomisp_csi_lane_config(struct atomisp_device *isp)
 	u32 port_config_mask;
 	int port3_lanes_shift;
 
- 	if (isp->media_dev.hw_revision <
-	    ATOMISP_HW_REVISION_ISP2401_LEGACY << ATOMISP_HW_REVISION_SHIFT) {
+	if (isp->media_dev.hw_revision <
+		ATOMISP_HW_REVISION_ISP2401_LEGACY <<
+		ATOMISP_HW_REVISION_SHIFT) {
 		/* Merrifield */
 		port_config_mask = MRFLD_PORT_CONFIG_MASK;
 		port3_lanes_shift = MRFLD_PORT3_LANES_SHIFT;
@@ -624,7 +625,8 @@ static int atomisp_csi_lane_config(struct atomisp_device *isp)
 	}
 
 	if (isp->media_dev.hw_revision <
-	    ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT) {
+		ATOMISP_HW_REVISION_ISP2401 <<
+		ATOMISP_HW_REVISION_SHIFT) {
 		/* Merrifield / Moorefield legacy input system */
 		nportconfigs = MRFLD_PORT_CONFIG_NUM;
 	} else {
@@ -778,7 +780,7 @@ static int atomisp_subdev_probe(struct atomisp_device *isp)
 			 * pixel_format.
 			 */
 			isp->inputs[isp->input_cnt].frame_size.pixel_format = 0;
-			sensor_pdata = (struct camera_sensor_platform_data*)
+			sensor_pdata = (struct camera_sensor_platform_data *)
 					board_info->platform_data;
 			if (sensor_pdata->get_camera_caps)
 				isp->inputs[isp->input_cnt].camera_caps =
@@ -1171,9 +1173,6 @@ static struct pci_driver atomisp_pci_driver;
 
 #define ATOM_ISP_PCI_BAR	0
 
-#ifdef CONFIG_GMIN_INTEL_MID
-extern int atomisp_punit_hpll_freq; /* atomisp_cmd.c */
-#endif
 static int atomisp_pci_probe(struct pci_dev *dev,
 				       const struct pci_device_id *id)
 {
@@ -1203,9 +1202,8 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 	atomisp_dev = &dev->dev;
 
 	pdata = atomisp_get_platform_data();
-	if (pdata == NULL) {
+	if (pdata == NULL)
 		dev_warn(&dev->dev, "no platform data available\n");
-	}
 
 	err = pcim_enable_device(dev);
 	if (err) {
@@ -1262,15 +1260,15 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 			ATOMISP_HW_STEPPING_B0;
 
 		switch (id->device) {
-			case ATOMISP_PCI_DEVICE_SOC_MRFLD_1179:
-				isp->dfs = &dfs_config_merr_1179;
-				break;
-			case ATOMISP_PCI_DEVICE_SOC_MRFLD_117A:
-				isp->dfs = &dfs_config_merr_117a;
-				break;
-			default:
-				isp->dfs = &dfs_config_merr;
-				break;
+		case ATOMISP_PCI_DEVICE_SOC_MRFLD_1179:
+			isp->dfs = &dfs_config_merr_1179;
+			break;
+		case ATOMISP_PCI_DEVICE_SOC_MRFLD_117A:
+			isp->dfs = &dfs_config_merr_117a;
+			break;
+		default:
+			isp->dfs = &dfs_config_merr;
+			break;
 		}
 		break;
 	case ATOMISP_PCI_DEVICE_SOC_BYT:
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm.c
index 0258a68..478aa67 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm.c
@@ -611,11 +611,11 @@ ia_css_ptr hmm_host_vaddr_to_hrt_vaddr(const void *ptr)
 
 void hmm_show_mem_stat(const char *func, const int line)
 {
-	trace_printk("tol_cnt=%d usr_size=%d res_size=%d res_cnt=%d sys_size=%d"
-		     " dyc_thr=%d dyc_size=%d.\n", hmm_mem_stat.tol_cnt,
-		     hmm_mem_stat.usr_size, hmm_mem_stat.res_size,
-		     hmm_mem_stat.res_cnt, hmm_mem_stat.sys_size,
-		     hmm_mem_stat.dyc_thr, hmm_mem_stat.dyc_size);
+	trace_printk("tol_cnt=%d usr_size=%d res_size=%d res_cnt=%d sys_size=%d  dyc_thr=%d dyc_size=%d.\n",
+			hmm_mem_stat.tol_cnt,
+			hmm_mem_stat.usr_size, hmm_mem_stat.res_size,
+			hmm_mem_stat.res_cnt, hmm_mem_stat.sys_size,
+			hmm_mem_stat.dyc_thr, hmm_mem_stat.dyc_size);
 }
 
 void hmm_init_mem_stat(int res_pgnr, int dyc_en, int dyc_pgnr)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo.c
index 19edf29..0af87da 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo.c
@@ -991,7 +991,7 @@ int hmm_bo_bind(struct hmm_buffer_object *bo)
 map_err:
 	/* unbind the physical pages with related virtual address space */
 	virt = bo->vm_node->start;
-	for ( ; i > 0; i--) {
+	for (; i > 0; i--) {
 		isp_mmu_unmap(&bdev->mmu, virt, 1);
 		virt += pgnr_to_size(1);
 	}
@@ -1259,11 +1259,7 @@ int hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo)
 	vma->vm_private_data = bo;
 
 	vma->vm_ops = &hmm_bo_vm_ops;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 	vma->vm_flags |= VM_IO|VM_DONTEXPAND|VM_DONTDUMP;
-#else
-	vma->vm_flags |= (VM_RESERVED | VM_IO);
-#endif
 
 	/*
 	 * call hmm_bo_vm_open explictly.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo_dev.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo_dev.c
index 6955e9b..87090ce 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo_dev.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hmm/hmm_bo_dev.c
@@ -59,9 +59,8 @@ int hmm_bo_device_init(struct hmm_bo_device *bdev,
 
 	ret = hmm_vm_init(&bdev->vaddr_space, vaddr_start, size);
 	if (ret) {
-		dev_err(atomisp_dev, "hmm_vm_init falied. "
-			     "vaddr_start = 0x%x, size = %d\n", vaddr_start,
-			     size);
+		dev_err(atomisp_dev, "hmm_vm_init falied. vaddr_start = 0x%x, size = %d\n",
+			vaddr_start, size);
 		goto vm_init_err;
 	}
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hrt/memory_access.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hrt/memory_access.c
index b10bfb5..362707d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hrt/memory_access.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/hrt/memory_access.c
@@ -21,7 +21,6 @@
  */
 
 static sys_address	page_table_base_address = (sys_address)-1;
-const ia_css_ptr	mmgr_NULL = 0;
 
 #ifndef SH_CSS_MEMORY_GUARDING
 /* Choose default in case not defined */
@@ -220,7 +219,7 @@ void mmgr_free(
 	ia_css_ptr			vaddr)
 {
 /* "free()" should accept NULL, "hrt_isp_css_mm_free()" may not */
-	if (vaddr != mmgr_NULL) {
+	if (vaddr) {
 #if SH_CSS_MEMORY_GUARDING
 		alloc_admin_remove(vaddr);
 		/* Reconstruct the "original" address used with the alloc */
@@ -313,7 +312,7 @@ assert(0);
 (void)vaddr;
 (void)size;
 (void)attribute;
-return mmgr_NULL;
+return 0;
 }
 
 ia_css_ptr mmgr_mmap(const void *ptr, const size_t size, uint16_t attribute,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_bo_dev.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_bo_dev.h
index 04dad7a..a9446ad 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_bo_dev.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_bo_dev.h
@@ -60,7 +60,7 @@ struct hmm_bo_device {
 	struct list_head	active_bo_list;
 
 	/* list lock is used to protect both of the buffer object lists */
-	struct spinlock		list_lock;
+	spinlock_t		list_lock;
 #ifdef CONFIG_ION
 	struct ion_client	*iclient;
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_common.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_common.h
index b0cca3c..f1593aa 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_common.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_common.h
@@ -77,8 +77,8 @@
  * res_size:  reserved mem pool size, being allocated from system at system boot time.
  *		res_size >= res_cnt.
  * sys_size:  system mem pool size, being allocated from system at camera running time.
- * 	      dyc_size:  dynamic mem pool size.
- * 	      dyc_thr:   dynamic mem pool high watermark.
+ *		dyc_size:  dynamic mem pool size.
+ *		dyc_thr:   dynamic mem pool high watermark.
  *		dyc_size <= dyc_thr.
  * usr_size:  user ptr mem size.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_pool.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_pool.h
index 9b0d29e..57c3cf9 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_pool.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/include/hmm/hmm_pool.h
@@ -83,7 +83,7 @@ struct hmm_reserved_pool_info {
 
 	unsigned int		index;
 	unsigned int		pgnr;
-	struct spinlock		list_lock;
+	spinlock_t		list_lock;
 	bool			initialized;
 };
 
@@ -100,7 +100,7 @@ struct hmm_dynamic_pool_info {
 	struct list_head	pages_list;
 
 	/* list lock is used to protect the free pages block lists */
-	struct spinlock		list_lock;
+	spinlock_t		list_lock;
 
 #ifdef USE_KMEM_CACHE
 	struct kmem_cache	*pgptr_cache;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/mmu/isp_mmu.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/mmu/isp_mmu.c
index c9c88aa..b53aaa0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/mmu/isp_mmu.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver/mmu/isp_mmu.c
@@ -561,7 +561,6 @@ int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver)
 
 #ifdef USE_KMEM_CACHE
 	mmu->tbl_cache = kmem_cache_create("iopte_cache", ISP_PAGE_SIZE,
-						//ISP_L1PT_PTES, SLAB_HWCACHE_ALIGN,
 					   ISP_PAGE_SIZE, SLAB_HWCACHE_ALIGN,
 					   NULL);
 	if (!mmu->tbl_cache)
-- 
1.9.1

