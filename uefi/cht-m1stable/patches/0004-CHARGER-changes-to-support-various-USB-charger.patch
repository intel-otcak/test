From 353b65191d3dacfd8c52648b8fdba8a0c2a72846 Mon Sep 17 00:00:00 2001
From: Fei Yang <fei.yang@intel.com>
Date: Fri, 13 Jun 2014 17:17:40 -0700
Subject: [PATCH 04/10] CHARGER: changes to support various USB charger

This is a forklift from MCG's tree. Changes are necessary to
deal with various battery charging design with differences in
USB switch, Charger and Battery

Change-Id: Id4a600a62f0d210c8f7f6294618237319073a157
Signed-off-by: Fei Yang <fei.yang@intel.com>
Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@intel.com>
Signed-off-by: David Cohen <david.a.cohen@intel.com>
---
 drivers/power/Kconfig                |   30 +
 drivers/power/Makefile               |    9 +-
 drivers/power/battery_id.c           |   68 ++
 drivers/power/charging_algo_pse.c    |  191 ++++++
 drivers/power/power_supply_charger.c | 1143 ++++++++++++++++++++++++++++++++++
 drivers/power/power_supply_core.c    |   98 ++-
 drivers/power/power_supply_sysfs.c   |   15 +-
 7 files changed, 1545 insertions(+), 9 deletions(-)
 create mode 100644 drivers/power/battery_id.c
 create mode 100644 drivers/power/charging_algo_pse.c
 create mode 100644 drivers/power/power_supply_charger.c

diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index ba69751..44c4333 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -8,6 +8,36 @@ menuconfig POWER_SUPPLY
 
 if POWER_SUPPLY
 
+config POWER_SUPPLY_CHARGER
+        bool "Power Supply Charger"
+        select EXTCON
+        select POWER_SUPPLY_BATTID
+        help
+          Say Y here to enable the power supply charger framework. Charger
+          framework supports charging in a generic way. This allows the charger
+          drivers to keep the charging logic outside and the charger driver
+          just need to abstract the charger hardware
+
+config POWER_SUPPLY_CHARGING_ALGO_PSE
+        bool "PSE compliant charging algorithm"
+        help
+          Say Y here to select PSE compliant charging algorithm. As per PSE
+          standard the battery characteristics and thereby the charging rates
+          can vary on different temperature zones. This config will enable PSE
+          compliant charging algorithm with maintenance charging support. The
+          algorithm can be selected by the charging framework based on the type
+          of the battery charging profile.
+
+        depends on POWER_SUPPLY_CHARGER
+
+config POWER_SUPPLY_BATTID
+        bool "Power Supply Battery Identification Framework"
+        help
+         Say Y here to enable the power supply battery idnetification
+         framework. The framework would allow different battery identification
+         drivers to interface with power supply subsystem. Also it allows consumer
+         drivers to register for notification from the power_supply subsystem.
+
 config POWER_SUPPLY_DEBUG
 	bool "Power supply debug"
 	help
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index ee54a3e..81bd054 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -1,12 +1,15 @@
 ccflags-$(CONFIG_POWER_SUPPLY_DEBUG) := -DDEBUG
 
-power_supply-y				:= power_supply_core.o
-power_supply-$(CONFIG_SYSFS)		+= power_supply_sysfs.o
-power_supply-$(CONFIG_LEDS_TRIGGERS)	+= power_supply_leds.o
+power_supply-y					:= power_supply_core.o
+power_supply-$(CONFIG_SYSFS)			+= power_supply_sysfs.o
+power_supply-$(CONFIG_LEDS_TRIGGERS)		+= power_supply_leds.o
+power_supply-$(CONFIG_POWER_SUPPLY_CHARGER)	+= power_supply_charger.o
+power_supply-$(CONFIG_POWER_SUPPLY_BATTID)	+= battery_id.o
 
 obj-$(CONFIG_POWER_SUPPLY)	+= power_supply.o
 obj-$(CONFIG_GENERIC_ADC_BATTERY)	+= generic-adc-battery.o
 
+obj-$(CONFIG_POWER_SUPPLY_CHARGING_ALGO_PSE)	+= charging_algo_pse.o
 obj-$(CONFIG_PDA_POWER)		+= pda_power.o
 obj-$(CONFIG_APM_POWER)		+= apm_power.o
 obj-$(CONFIG_MAX8925_POWER)	+= max8925_power.o
diff --git a/drivers/power/battery_id.c b/drivers/power/battery_id.c
new file mode 100644
index 0000000..13425b6
--- /dev/null
+++ b/drivers/power/battery_id.c
@@ -0,0 +1,68 @@
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/notifier.h>
+#include <linux/power/battery_id.h>
+
+ATOMIC_NOTIFIER_HEAD(batt_id_notifier);
+
+static struct ps_batt_chg_prof *batt_property;
+static int batt_status;
+
+int batt_id_reg_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&batt_id_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(batt_id_reg_notifier);
+
+void batt_id_unreg_notifier(struct notifier_block *nb)
+{
+	atomic_notifier_chain_unregister(&batt_id_notifier, nb);
+}
+EXPORT_SYMBOL_GPL(batt_id_unreg_notifier);
+
+
+/**
+ * battery_prop_changed - Update properties when  battery connection status
+ *                        changes
+ * @battery_conn_stat : The current connection status of battery
+ * @batt_prop : Address of the ps_batt_chg_prof structure with the updated
+ *              values passed from the calling function
+ *
+ * Whenever the battery connection status changes this function will be called
+ * to indicate a change in the status and to update the status and value of
+ * properties
+ */
+void battery_prop_changed(int battery_conn_stat,
+			struct ps_batt_chg_prof *batt_prop)
+{
+	if (batt_status != battery_conn_stat) {
+		if (battery_conn_stat == POWER_SUPPLY_BATTERY_INSERTED)
+			batt_property = batt_prop;
+		else
+			batt_property = NULL;
+
+		batt_status = battery_conn_stat;
+	}
+
+	atomic_notifier_call_chain(&batt_id_notifier,
+			0, &(batt_property));
+
+}
+EXPORT_SYMBOL_GPL(battery_prop_changed);
+
+/**
+ * get_batt_prop - Get the battery connection status and updated properties
+ * @batt_prop : battery properties structure copied to this address
+ */
+int get_batt_prop(struct ps_batt_chg_prof *batt_prop)
+{
+	if (batt_property)
+		memcpy(batt_prop, batt_property,
+			sizeof(struct ps_batt_chg_prof));
+	else
+		return -ENOMEM;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(get_batt_prop);
diff --git a/drivers/power/charging_algo_pse.c b/drivers/power/charging_algo_pse.c
new file mode 100644
index 0000000..85067e22
--- /dev/null
+++ b/drivers/power/charging_algo_pse.c
@@ -0,0 +1,191 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/power_supply.h>
+#include <linux/thermal.h>
+#include <linux/power/battery_id.h>
+#include "power_supply.h"
+#include "power_supply_charger.h"
+
+/* 98% of CV is considered as voltage to detect Full */
+#define FULL_CV_MIN 98
+
+/* Offset to exit from maintenance charging. In maintenance charging
+*  if the volatge is less than the (maintenance_lower_threshold -
+*  MAINT_EXIT_OFFSET) then system can switch to normal charging
+*/
+#define MAINT_EXIT_OFFSET 50  /* mV */
+
+static int get_tempzone(struct ps_pse_mod_prof *pse_mod_bprof,
+		int temp)
+{
+
+	int i = 0;
+	int temp_range_cnt = min_t(u16, pse_mod_bprof->temp_mon_ranges,
+					BATT_TEMP_NR_RNG);
+
+	if ((temp < pse_mod_bprof->temp_low_lim) ||
+		(temp > pse_mod_bprof->temp_mon_range[0].temp_up_lim))
+		return -EINVAL;
+
+	for (i = 0; i < temp_range_cnt; ++i)
+		if (temp > pse_mod_bprof->temp_mon_range[i].temp_up_lim)
+			break;
+	return i-1;
+}
+
+static inline bool __is_battery_full
+	(long volt, long cur, long iterm, unsigned long cv)
+{
+	pr_devel("%s:current=%d pse_mod_bprof->chrg_term_ma =%d voltage_now=%d full_cond=%d",
+			__func__, cur, iterm, volt * 100, (FULL_CV_MIN * cv));
+
+	return ((cur > 0) && (cur <= iterm) &&
+	((volt * 100)  >= (FULL_CV_MIN * cv)));
+
+}
+
+static inline bool is_battery_full(struct batt_props bat_prop,
+		struct ps_pse_mod_prof *pse_mod_bprof, unsigned long cv)
+{
+
+	int i;
+	/* Software full detection. Check the battery charge current to detect
+	*  battery Full. The voltage also verified to avoid false charge
+	*  full detection.
+	*/
+	pr_devel("%s:current=%d pse_mod_bprof->chrg_term_ma =%d bat_prop.voltage_now=%d full_cond=%d",
+		__func__, bat_prop.current_now, (pse_mod_bprof->chrg_term_ma),
+		bat_prop.voltage_now * 100, (FULL_CV_MIN * cv));
+
+	for (i = (MAX_CUR_VOLT_SAMPLES - 1); i >= 0; --i) {
+
+		if (!(__is_battery_full(bat_prop.voltage_now_cache[i],
+				bat_prop.current_now_cache[i],
+				pse_mod_bprof->chrg_term_ma, cv)))
+			return false;
+	}
+
+	return true;
+}
+
+static int  pse_get_bat_thresholds(struct ps_batt_chg_prof  bprof,
+			struct psy_batt_thresholds *bat_thresh)
+{
+	struct ps_pse_mod_prof *pse_mod_bprof =
+			(struct ps_pse_mod_prof *) bprof.batt_prof;
+
+	if ((bprof.chrg_prof_type != PSE_MOD_CHRG_PROF) || (!pse_mod_bprof))
+		return -EINVAL;
+
+	bat_thresh->iterm = pse_mod_bprof->chrg_term_ma;
+	bat_thresh->temp_min = pse_mod_bprof->temp_low_lim;
+	bat_thresh->temp_max = pse_mod_bprof->temp_mon_range[0].temp_up_lim;
+
+	return 0;
+}
+
+static enum psy_algo_stat pse_get_next_cc_cv(struct batt_props bat_prop,
+	struct ps_batt_chg_prof  bprof, unsigned long *cc, unsigned long *cv)
+{
+	int tzone;
+	struct ps_pse_mod_prof *pse_mod_bprof =
+			(struct ps_pse_mod_prof *) bprof.batt_prof;
+	enum psy_algo_stat algo_stat = bat_prop.algo_stat;
+	int maint_exit_volt;
+
+	*cc = *cv = 0;
+
+	/* If STATUS is discharging, assume that charger is not connected.
+	*  If charger is not connected, no need to take any action.
+	*  If charge profile type is not PSE_MOD_CHRG_PROF or the charge profile
+	*  is not present, no need to take any action.
+	*/
+
+	pr_devel("%s:battery status = %d algo_status=%d\n",
+			__func__, bat_prop.status, algo_stat);
+
+	if ((bprof.chrg_prof_type != PSE_MOD_CHRG_PROF) || (!pse_mod_bprof))
+		return PSY_ALGO_STAT_NOT_CHARGE;
+
+	tzone = get_tempzone(pse_mod_bprof, bat_prop.temperature);
+
+	if (tzone < 0)
+		return PSY_ALGO_STAT_NOT_CHARGE;
+
+	/* Change the algo status to not charging, if battery is
+	*  not really charging or less than maintenance exit threshold.
+	*  This way algorithm can switch to normal
+	*  charging if current status is full/maintenace
+	*/
+	maint_exit_volt = pse_mod_bprof->
+			temp_mon_range[tzone].maint_chrg_vol_ll -
+				MAINT_EXIT_OFFSET;
+
+	if ((bat_prop.status == POWER_SUPPLY_STATUS_DISCHARGING) ||
+		(bat_prop.status == POWER_SUPPLY_STATUS_NOT_CHARGING) ||
+			bat_prop.voltage_now < maint_exit_volt) {
+		algo_stat = PSY_ALGO_STAT_NOT_CHARGE;
+	}
+
+	/* read cc and cv based on temperature and algorithm status*/
+	if (algo_stat == PSY_ALGO_STAT_FULL ||
+			algo_stat == PSY_ALGO_STAT_MAINT) {
+
+		/* if status is full and voltage is lower than maintenance lower
+		*  threshold change status to maintenenance
+		*/
+
+		if (algo_stat == PSY_ALGO_STAT_FULL) {
+			*cv = pse_mod_bprof->temp_mon_range
+					[tzone].full_chrg_vol;
+			*cc = pse_mod_bprof->temp_mon_range
+					[tzone].full_chrg_cur;
+		}
+
+		if (algo_stat == PSY_ALGO_STAT_FULL && (bat_prop.voltage_now <=
+			pse_mod_bprof->temp_mon_range[tzone].maint_chrg_vol_ll))
+				algo_stat = PSY_ALGO_STAT_MAINT;
+
+		/* Read maintenance CC and CV */
+		if (algo_stat == PSY_ALGO_STAT_MAINT) {
+			*cv = pse_mod_bprof->temp_mon_range
+					[tzone].maint_chrg_vol_ul;
+			*cc = pse_mod_bprof->temp_mon_range
+					[tzone].maint_chrg_cur;
+		}
+	} else {
+		*cv = pse_mod_bprof->temp_mon_range[tzone].full_chrg_vol;
+		*cc = pse_mod_bprof->temp_mon_range[tzone].full_chrg_cur;
+		algo_stat = PSY_ALGO_STAT_CHARGE;
+	}
+
+	if (bat_prop.voltage_now > *cv) {
+		algo_stat = PSY_ALGO_STAT_NOT_CHARGE;
+		return algo_stat;
+	}
+
+	if (algo_stat == PSY_ALGO_STAT_FULL)
+		return algo_stat;
+
+	if (is_battery_full(bat_prop, pse_mod_bprof, *cv))
+		algo_stat = PSY_ALGO_STAT_FULL;
+
+	return algo_stat;
+}
+
+static int __init pse_algo_init(void)
+{
+	struct charging_algo pse_algo;
+	pse_algo.chrg_prof_type = PSE_MOD_CHRG_PROF;
+	pse_algo.name = "pse_algo";
+	pse_algo.get_next_cc_cv = pse_get_next_cc_cv;
+	pse_algo.get_batt_thresholds = pse_get_bat_thresholds;
+	power_supply_register_charging_algo(&pse_algo);
+	return 0;
+}
+
+module_init(pse_algo_init);
diff --git a/drivers/power/power_supply_charger.c b/drivers/power/power_supply_charger.c
new file mode 100644
index 0000000..7b7c4a4
--- /dev/null
+++ b/drivers/power/power_supply_charger.c
@@ -0,0 +1,1143 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/power_supply.h>
+#include <linux/thermal.h>
+#include <linux/extcon.h>
+#include <linux/power/battery_id.h>
+#include <linux/notifier.h>
+#include <linux/usb/otg.h>
+#include "power_supply.h"
+#include "power_supply_charger.h"
+
+struct work_struct notifier_work;
+#define MAX_CHARGER_COUNT 5
+
+static LIST_HEAD(algo_list);
+
+struct power_supply_charger {
+	bool is_cable_evt_reg;
+	/*cache battery and charger properties */
+	struct list_head chrgr_cache_lst;
+	struct list_head batt_cache_lst;
+	struct list_head evt_queue;
+	struct work_struct algo_trigger_work;
+	struct mutex evt_lock;
+	wait_queue_head_t wait_chrg_enable;
+};
+
+struct charger_cable {
+	struct work_struct work;
+	struct notifier_block nb;
+	struct extcon_chrgr_cbl_props cable_props;
+	enum extcon_cable_name extcon_cable_type;
+	enum power_supply_charger_cable_type psy_cable_type;
+	struct extcon_specific_cable_nb extcon_dev;
+	struct extcon_dev *edev;
+};
+
+static struct power_supply_charger psy_chrgr;
+
+static struct charger_cable cable_list[] = {
+	{
+	 .psy_cable_type = POWER_SUPPLY_CHARGER_TYPE_USB_SDP,
+	 .extcon_cable_type = EXTCON_SDP,
+	 },
+	{
+	 .psy_cable_type = POWER_SUPPLY_CHARGER_TYPE_USB_CDP,
+	 .extcon_cable_type = EXTCON_CDP,
+	 },
+	{
+	 .psy_cable_type = POWER_SUPPLY_CHARGER_TYPE_USB_DCP,
+	 .extcon_cable_type = EXTCON_DCP,
+	 },
+	{
+	 .psy_cable_type = POWER_SUPPLY_CHARGER_TYPE_USB_ACA,
+	 .extcon_cable_type = EXTCON_ACA,
+	 },
+	{
+	 .psy_cable_type = POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK,
+	 .extcon_cable_type = EXTCON_ACA,
+	 },
+	{
+	 .psy_cable_type = POWER_SUPPLY_CHARGER_TYPE_SE1,
+	 .extcon_cable_type = EXTCON_TA,
+	 },
+	{
+	 .psy_cable_type = POWER_SUPPLY_CHARGER_TYPE_AC,
+	 .extcon_cable_type = EXTCON_AC,
+	 },
+};
+
+static int get_supplied_by_list(struct power_supply *psy,
+				struct power_supply *psy_lst[]);
+
+static int handle_cable_notification(struct notifier_block *nb,
+				   unsigned long event, void *data);
+struct usb_phy *otg_xceiver;
+struct notifier_block nb = {
+		   .notifier_call = handle_cable_notification,
+		};
+static void configure_chrgr_source(struct charger_cable *cable_lst);
+
+struct charger_cable *get_cable(unsigned long usb_chrgr_type)
+{
+
+	switch (usb_chrgr_type) {
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+		return &cable_list[0];
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+		return &cable_list[1];
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+		return &cable_list[2];
+	case POWER_SUPPLY_CHARGER_TYPE_USB_ACA:
+		return &cable_list[3];
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+		return &cable_list[4];
+	case POWER_SUPPLY_CHARGER_TYPE_AC:
+		return &cable_list[6];
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
+		return &cable_list[5];
+	}
+
+	return NULL;
+}
+
+
+static void notifier_event_worker(struct work_struct *work)
+{
+	configure_chrgr_source(cable_list);
+}
+
+static int process_cable_props(struct power_supply_cable_props *cap)
+{
+
+	struct charger_cable *cable = NULL;
+
+	pr_info("%s: event:%d, type:%d, ma:%d\n",
+		__func__, cap->chrg_evt, cap->chrg_type, cap->ma);
+
+	cable = get_cable(cap->chrg_type);
+	if (!cable) {
+
+		pr_err("%s:Error in getting charger cable\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (cap->chrg_evt) {
+	case POWER_SUPPLY_CHARGER_EVENT_CONNECT:
+	case POWER_SUPPLY_CHARGER_EVENT_RESUME:
+		cable->cable_props.cable_stat = EXTCON_CHRGR_CABLE_CONNECTED;
+		break;
+	case POWER_SUPPLY_CHARGER_EVENT_UPDATE:
+		cable->cable_props.cable_stat = EXTCON_CHRGR_CABLE_UPDATED;
+		break;
+	case POWER_SUPPLY_CHARGER_EVENT_DISCONNECT:
+		cable->cable_props.cable_stat = EXTCON_CHRGR_CABLE_DISCONNECTED;
+		break;
+	case POWER_SUPPLY_CHARGER_EVENT_SUSPEND:
+		cable->cable_props.cable_stat = EXTCON_CHRGR_CABLE_SUSPENDED;
+		break;
+	default:
+		pr_err("%s:Invalid cable event\n", __func__);
+		return -EINVAL;
+	}
+
+	cable->cable_props.ma = cap->ma;
+	schedule_work(&notifier_work);
+
+	return 0;
+
+}
+
+static int handle_cable_notification(struct notifier_block *nb,
+				   unsigned long event, void *data)
+{
+	struct power_supply_cable_props cap;
+
+	memcpy(&cap, data, sizeof(struct power_supply_cable_props));
+
+	if (event != USB_EVENT_CHARGER && event != PSY_CABLE_EVENT)
+		return NOTIFY_DONE;
+
+	process_cable_props(&cap);
+
+	return NOTIFY_OK;
+}
+
+static int register_notifier(void)
+{
+	int retval;
+
+	otg_xceiver = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!otg_xceiver) {
+		pr_err("failure to get otg transceiver\n");
+		retval = -EIO;
+		goto notifier_reg_failed;
+	}
+	retval = usb_register_notifier(otg_xceiver, &nb);
+	if (retval) {
+		pr_err("failure to register otg notifier\n");
+		goto notifier_reg_failed;
+	}
+
+	retval = power_supply_reg_notifier(&nb);
+	if (retval) {
+		pr_err("failure to register power_supply notifier\n");
+		goto notifier_reg_failed;
+
+	}
+
+	INIT_WORK(&notifier_work, notifier_event_worker);
+
+	return 0;
+
+notifier_reg_failed:
+	return retval;
+}
+
+static int charger_cable_notifier(struct notifier_block *nb,
+				  unsigned long event, void *ptr);
+static void charger_cable_event_worker(struct work_struct *work);
+struct charging_algo *power_supply_get_charging_algo
+		(struct power_supply *, struct ps_batt_chg_prof *);
+
+static void init_charger_cables(struct charger_cable *cable_lst, int count)
+{
+	struct charger_cable *cable;
+	struct extcon_chrgr_cbl_props cable_props;
+	const char *cable_name;
+	struct power_supply_cable_props cap;
+
+	register_notifier();
+
+	while (--count) {
+		cable = cable_lst++;
+		/* initialize cable instance */
+		INIT_WORK(&cable->work, charger_cable_event_worker);
+		cable->nb.notifier_call = charger_cable_notifier;
+		cable->cable_props.cable_stat = EXTCON_CHRGR_CABLE_DISCONNECTED;
+		cable->cable_props.ma = 0;
+		cable_name = extcon_cable_name[cable->extcon_cable_type];
+
+		if (extcon_register_interest(&cable->extcon_dev,
+				NULL, cable_name, &cable->nb))
+				continue;
+
+		cable->edev = cable->extcon_dev.edev;
+
+		if (!cable->edev)
+			continue;
+
+		if (cable->edev->get_cable_properties(cable_name,
+						      (void *)&cable_props)) {
+			continue;
+
+		} else if (cable_props.cable_stat !=
+			   cable->cable_props.cable_stat) {
+			cable->cable_props.cable_stat = cable_props.cable_stat;
+			cable->cable_props.ma = cable_props.ma;
+		}
+	}
+
+#if 0
+	if (!otg_get_chrg_status(otg_xceiver, &cap))
+		process_cable_props(&cap);
+#endif
+
+}
+
+static inline int is_charging_can_be_enabled(struct power_supply *psy)
+{
+	int health;
+
+	health = HEALTH(psy);
+	if (IS_BATTERY(psy)) {
+		return (health == POWER_SUPPLY_HEALTH_GOOD) ||
+				(health == POWER_SUPPLY_HEALTH_DEAD);
+	} else {
+		return
+	((CURRENT_THROTTLE_ACTION(psy) != PSY_THROTTLE_DISABLE_CHARGER) &&
+	(CURRENT_THROTTLE_ACTION(psy) != PSY_THROTTLE_DISABLE_CHARGING) &&
+	(INLMT(psy) >= 100) && (health == POWER_SUPPLY_HEALTH_GOOD));
+	}
+}
+
+static inline void get_cur_chrgr_prop(struct power_supply *psy,
+				      struct charger_props *chrgr_prop)
+{
+	chrgr_prop->is_charging = IS_CHARGING_ENABLED(psy);
+	chrgr_prop->name = psy->name;
+	chrgr_prop->online = IS_ONLINE(psy);
+	chrgr_prop->present = IS_PRESENT(psy);
+	chrgr_prop->cable = CABLE_TYPE(psy);
+	chrgr_prop->health = HEALTH(psy);
+	chrgr_prop->tstamp = get_jiffies_64();
+
+}
+
+static inline int get_chrgr_prop_cache(struct power_supply *psy,
+				       struct charger_props *chrgr_cache)
+{
+
+	struct charger_props *chrgr_prop;
+	int ret = -ENODEV;
+
+	list_for_each_entry(chrgr_prop, &psy_chrgr.chrgr_cache_lst, node) {
+		if (!strcmp(chrgr_prop->name, psy->name)) {
+			memcpy(chrgr_cache, chrgr_prop, sizeof(*chrgr_cache));
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static void dump_charger_props(struct charger_props *props)
+{
+	pr_devel("%s:name=%s present=%d is_charging=%d health=%d online=%d cable=%d tstamp=%d\n",
+		__func__, props->name, props->present, props->is_charging,
+		props->health, props->online, props->cable, props->tstamp);
+}
+
+static void dump_battery_props(struct batt_props *props)
+{
+	pr_devel("%s:name=%s voltage_now=%d current_now=%d temperature=%d status=%d health=%d tstamp=%d algo_stat=%d ",
+		__func__, props->name, props->voltage_now, props->current_now,
+		props->temperature, props->status, props->health,
+		props->tstamp, props->algo_stat);
+}
+
+static inline void cache_chrgr_prop(struct charger_props *chrgr_prop_new)
+{
+
+	struct charger_props *chrgr_cache;
+
+	list_for_each_entry(chrgr_cache, &psy_chrgr.chrgr_cache_lst, node) {
+		if (!strcmp(chrgr_cache->name, chrgr_prop_new->name))
+			goto update_props;
+	}
+
+	chrgr_cache = kzalloc(sizeof(*chrgr_cache), GFP_KERNEL);
+	if (chrgr_cache == NULL) {
+		pr_err("%s:Error in allocating memory\n", __func__);
+		return;
+	}
+
+	INIT_LIST_HEAD(&chrgr_cache->node);
+	list_add_tail(&chrgr_cache->node, &psy_chrgr.chrgr_cache_lst);
+
+	chrgr_cache->name = chrgr_prop_new->name;
+
+update_props:
+	chrgr_cache->is_charging = chrgr_prop_new->is_charging;
+	chrgr_cache->online = chrgr_prop_new->online;
+	chrgr_cache->health = chrgr_prop_new->health;
+	chrgr_cache->present = chrgr_prop_new->present;
+	chrgr_cache->cable = chrgr_prop_new->cable;
+	chrgr_cache->tstamp = chrgr_prop_new->tstamp;
+}
+
+
+static inline bool is_chrgr_prop_changed(struct power_supply *psy)
+{
+	struct charger_props chrgr_prop_cache, chrgr_prop;
+
+	get_cur_chrgr_prop(psy, &chrgr_prop);
+	/* Get cached battery property. If no cached property available
+	 *  then cache the new property and return true
+	 */
+	if (get_chrgr_prop_cache(psy, &chrgr_prop_cache)) {
+		cache_chrgr_prop(&chrgr_prop);
+		return true;
+	}
+
+	dump_charger_props(&chrgr_prop);
+	dump_charger_props(&chrgr_prop_cache);
+
+	if (!IS_CHARGER_PROP_CHANGED(chrgr_prop, chrgr_prop_cache))
+		return false;
+
+	cache_chrgr_prop(&chrgr_prop);
+	return true;
+}
+static void cache_successive_samples(long *sample_array, long new_sample)
+{
+	int i;
+
+	for (i = 0; i < MAX_CUR_VOLT_SAMPLES - 1; ++i)
+		*(sample_array + i) = *(sample_array + i + 1);
+
+	*(sample_array + i) = new_sample;
+}
+
+static inline void cache_bat_prop(struct batt_props *bat_prop_new, bool force)
+{
+
+	struct batt_props *bat_cache;
+
+	/* Find entry in cache list. If an entry is located update
+	 * the existing entry else create new entry in the list */
+	list_for_each_entry(bat_cache, &psy_chrgr.batt_cache_lst, node) {
+		if (!strcmp(bat_cache->name, bat_prop_new->name))
+			goto update_props;
+	}
+
+	bat_cache = kzalloc(sizeof(*bat_cache), GFP_KERNEL);
+	if (bat_cache == NULL) {
+		pr_err("%s:Error in allocating memory\n", __func__);
+		return;
+	}
+	INIT_LIST_HEAD(&bat_cache->node);
+	list_add_tail(&bat_cache->node, &psy_chrgr.batt_cache_lst);
+
+	bat_cache->name = bat_prop_new->name;
+
+update_props:
+	if (time_after(bat_prop_new->tstamp,
+		(bat_cache->tstamp + DEF_CUR_VOLT_SAMPLE_JIFF)) || force ||
+						bat_cache->tstamp == 0) {
+		cache_successive_samples(bat_cache->voltage_now_cache,
+						bat_prop_new->voltage_now);
+		cache_successive_samples(bat_cache->current_now_cache,
+						bat_prop_new->current_now);
+		bat_cache->tstamp = bat_prop_new->tstamp;
+	}
+
+	bat_cache->voltage_now = bat_prop_new->voltage_now;
+	bat_cache->current_now = bat_prop_new->current_now;
+	bat_cache->health = bat_prop_new->health;
+
+	bat_cache->temperature = bat_prop_new->temperature;
+	bat_cache->status = bat_prop_new->status;
+	bat_cache->algo_stat = bat_prop_new->algo_stat;
+	bat_cache->throttle_state = bat_prop_new->throttle_state;
+}
+
+static inline int get_bat_prop_cache(struct power_supply *psy,
+				     struct batt_props *bat_cache)
+{
+	struct batt_props *bat_prop;
+	int ret = -ENODEV;
+
+	list_for_each_entry(bat_prop, &psy_chrgr.batt_cache_lst, node) {
+		if (!strcmp(bat_prop->name, psy->name)) {
+			memcpy(bat_cache, bat_prop, sizeof(*bat_cache));
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static inline void get_cur_bat_prop(struct power_supply *psy,
+				    struct batt_props *bat_prop)
+{
+	struct batt_props bat_prop_cache;
+	int ret;
+
+	bat_prop->name = psy->name;
+	bat_prop->voltage_now = VOLTAGE_OCV(psy) / 1000;
+	bat_prop->current_now = CURRENT_NOW(psy) / 1000;
+	bat_prop->temperature = TEMPERATURE(psy) / 10;
+	bat_prop->status = STATUS(psy);
+	bat_prop->health = HEALTH(psy);
+	bat_prop->tstamp = get_jiffies_64();
+	bat_prop->throttle_state = CURRENT_THROTTLE_STATE(psy);
+
+	/* Populate cached algo data to new profile */
+	ret = get_bat_prop_cache(psy, &bat_prop_cache);
+	if (!ret)
+		bat_prop->algo_stat = bat_prop_cache.algo_stat;
+}
+
+static inline bool is_batt_prop_changed(struct power_supply *psy)
+{
+	struct batt_props bat_prop_cache, bat_prop;
+
+	/* Get cached battery property. If no cached property available
+	 *  then cache the new property and return true
+	 */
+	get_cur_bat_prop(psy, &bat_prop);
+	if (get_bat_prop_cache(psy, &bat_prop_cache)) {
+		cache_bat_prop(&bat_prop, false);
+		return true;
+	}
+
+	dump_battery_props(&bat_prop);
+	dump_battery_props(&bat_prop_cache);
+
+	if (!IS_BAT_PROP_CHANGED(bat_prop, bat_prop_cache))
+		return false;
+
+	cache_bat_prop(&bat_prop, false);
+	return true;
+}
+
+static inline bool is_supplied_to_has_ext_pwr_changed(struct power_supply *psy)
+{
+	int i;
+	struct power_supply *psb;
+	bool is_pwr_changed_defined = true;
+
+	for (i = 0; i < psy->num_supplicants; i++) {
+		psb =
+		    power_supply_get_by_name(psy->
+					     supplied_to[i]);
+		if (psb && !psb->external_power_changed)
+			is_pwr_changed_defined &= false;
+	}
+
+	return is_pwr_changed_defined;
+
+}
+
+static inline bool is_supplied_by_changed(struct power_supply *psy)
+{
+	int cnt;
+	struct power_supply *chrgr_lst[MAX_CHARGER_COUNT];
+
+	cnt = get_supplied_by_list(psy, chrgr_lst);
+	while (cnt--) {
+		if ((IS_CHARGER(chrgr_lst[cnt])) &&
+			is_chrgr_prop_changed(chrgr_lst[cnt]))
+			return true;
+	}
+
+	return false;
+}
+
+static inline bool is_trigger_charging_algo(struct power_supply *psy)
+{
+	/* trigger charging alorithm if battery or
+	 * charger properties are changed. Also no need to
+	 * invoke algorithm for power_supply_changed from
+	 * charger, if all supplied_to has the ext_port_changed defined.
+	 * On invoking the ext_port_changed the supplied to can send
+	 * power_supplied_changed event.
+	 */
+
+	if ((IS_CHARGER(psy) && !is_supplied_to_has_ext_pwr_changed(psy)) &&
+			is_chrgr_prop_changed(psy))
+		return true;
+
+	if ((IS_BATTERY(psy)) && (is_batt_prop_changed(psy) ||
+				is_supplied_by_changed(psy)))
+		return true;
+
+	return false;
+}
+
+static int get_supplied_by_list(struct power_supply *psy,
+				struct power_supply *psy_lst[])
+{
+	struct class_dev_iter iter;
+	struct device *dev;
+	struct power_supply *pst;
+	int cnt = 0, i, j;
+
+	if (!IS_BATTERY(psy))
+		return 0;
+
+	/* Identify chargers which are supplying power to the battery */
+	class_dev_iter_init(&iter, power_supply_class, NULL, NULL);
+	while ((dev = class_dev_iter_next(&iter))) {
+		pst = (struct power_supply *)dev_get_drvdata(dev);
+		if (!IS_CHARGER(pst))
+			continue;
+		for (i = 0; i < pst->num_supplicants; i++) {
+			if (!strcmp(pst->supplied_to[i], psy->name))
+				psy_lst[cnt++] = pst;
+		}
+	}
+	class_dev_iter_exit(&iter);
+
+	if (cnt <= 1)
+		return cnt;
+
+	/*sort based on priority. 0 has the highest priority  */
+	for (i = 0; i < cnt; ++i)
+		for (j = 0; j < cnt; ++j)
+			if (PRIORITY(psy_lst[j]) > PRIORITY(psy_lst[i]))
+				swap(psy_lst[j], psy_lst[i]);
+
+	return cnt;
+}
+
+static int get_battery_status(struct power_supply *psy)
+{
+	int cnt, status, ret;
+	struct power_supply *chrgr_lst[MAX_CHARGER_COUNT];
+	struct batt_props bat_prop;
+	int health;
+
+	if (!IS_BATTERY(psy))
+		return -EINVAL;
+
+	ret = get_bat_prop_cache(psy, &bat_prop);
+	if (ret)
+		return ret;
+
+	status = POWER_SUPPLY_STATUS_DISCHARGING;
+	cnt = get_supplied_by_list(psy, chrgr_lst);
+
+
+	while (cnt--) {
+		if (IS_PRESENT(chrgr_lst[cnt]))
+			status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+
+		if (is_charging_can_be_enabled(chrgr_lst[cnt]) &&
+				(IS_HEALTH_GOOD(chrgr_lst[cnt]))) {
+			health = HEALTH(psy);
+			if ((health == POWER_SUPPLY_HEALTH_GOOD) ||
+				(health == POWER_SUPPLY_HEALTH_DEAD)) {
+				/* do charging with Good / Dead battery */
+				if ((bat_prop.algo_stat ==
+							PSY_ALGO_STAT_FULL) ||
+					(bat_prop.algo_stat ==
+							PSY_ALGO_STAT_MAINT))
+					status = POWER_SUPPLY_STATUS_FULL;
+				else if (IS_CHARGING_ENABLED(chrgr_lst[cnt]))
+					status = POWER_SUPPLY_STATUS_CHARGING;
+			}
+		}
+	}
+	pr_devel("%s: Set status=%d for %s\n", __func__, status, psy->name);
+
+	return status;
+}
+
+static void update_charger_online(struct power_supply *psy)
+{
+	if (IS_CHARGER_ENABLED(psy))
+		set_charger_online(psy, 1);
+	else
+		set_charger_online(psy, 0);
+}
+
+static inline void cache_cur_batt_prop_force(struct power_supply *psb)
+{
+	struct batt_props bat_prop;
+
+	if (!IS_BATTERY(psb))
+		return;
+
+	get_cur_bat_prop(psb, &bat_prop);
+	cache_bat_prop(&bat_prop, true);
+}
+
+static void update_sysfs(struct power_supply *psy)
+{
+	int i, cnt;
+	struct power_supply *psb;
+	struct power_supply *chrgr_lst[MAX_CHARGER_COUNT];
+
+	if (IS_BATTERY(psy)) {
+		/* set charger online */
+		cnt = get_supplied_by_list(psy, chrgr_lst);
+		while (cnt--) {
+			if (!IS_PRESENT(chrgr_lst[cnt]))
+				continue;
+
+			update_charger_online(psy);
+		}
+		/* set battery status */
+		if (set_battery_status(psy, get_battery_status(psy)))
+			/* forcefully cache the battery properties */
+			cache_cur_batt_prop_force(psy);
+	} else {
+		/*set charger online */
+		update_charger_online(psy);
+		/*set battery status */
+		for (i = 0; i < psy->num_supplicants; i++) {
+			psb =
+			    power_supply_get_by_name(psy->
+						     supplied_to[i]);
+			if (psb && IS_BATTERY(psb) && IS_PRESENT(psb))
+				if (set_battery_status(psb,
+					get_battery_status(psb)))
+					/*
+					 * forcefully cache the battery
+					 * properties
+					 */
+					cache_cur_batt_prop_force(psy);
+		}
+	}
+}
+
+static int trigger_algo(struct power_supply *psy)
+{
+	unsigned long cc = 0, cv = 0, cc_min;
+	struct power_supply *chrgr_lst[MAX_CHARGER_COUNT];
+	struct batt_props bat_prop;
+	struct charging_algo *algo;
+	struct ps_batt_chg_prof chrg_profile;
+	int cnt;
+
+	if (psy->type != POWER_SUPPLY_TYPE_BATTERY)
+		return 0;
+
+	if (get_batt_prop(&chrg_profile)) {
+		pr_err("%s:Error in getting charge profile\n", __func__);
+		return -EINVAL;
+	}
+
+
+	get_bat_prop_cache(psy, &bat_prop);
+
+	algo = power_supply_get_charging_algo(psy, &chrg_profile);
+	if (!algo) {
+		pr_err("%s:Error in getting charging algo!!\n", __func__);
+		return -EINVAL;
+	}
+
+	bat_prop.algo_stat = algo->get_next_cc_cv(bat_prop,
+						chrg_profile, &cc, &cv);
+
+	pr_info("%s:Algo_status:%d\n", __func__, bat_prop.algo_stat);
+
+	cache_bat_prop(&bat_prop, false);
+
+	if (!cc || !cv)
+		return -ENODATA;
+
+	/* CC needs to be updated for all chargers which are supplying
+	 *  power to this battery to ensure that the sum of CCs of all
+	 * chargers are never more than the CC selected by the algo.
+	 * The CC is set based on the charger priority.
+	 */
+	cnt = get_supplied_by_list(psy, chrgr_lst);
+
+	while (cnt--) {
+		if (!IS_PRESENT(chrgr_lst[cnt]))
+			continue;
+
+		cc_min = min_t(unsigned long, MAX_CC(chrgr_lst[cnt]), cc);
+		if (cc_min < 0)
+			cc_min = 0;
+		cc -= cc_min;
+		set_cc(chrgr_lst[cnt], cc_min);
+		set_cv(chrgr_lst[cnt], cv);
+	}
+
+	if ((bat_prop.algo_stat == PSY_ALGO_STAT_NOT_CHARGE) ||
+		(bat_prop.algo_stat == PSY_ALGO_STAT_FULL))
+		return -EOPNOTSUPP;
+
+	return 0;
+}
+
+static inline void wait_for_charging_enabled(struct power_supply *psy)
+{
+	wait_event_timeout(psy_chrgr.wait_chrg_enable,
+			(IS_CHARGING_ENABLED(psy)), HZ);
+}
+
+static inline void enable_supplied_by_charging
+		(struct power_supply *psy, bool is_enable)
+{
+	struct power_supply *chrgr_lst[MAX_CHARGER_COUNT];
+	int cnt;
+
+	if (psy->type != POWER_SUPPLY_TYPE_BATTERY)
+		return;
+	/* Get list of chargers supplying power to this battery and
+	 * disable charging for all chargers
+	 */
+	cnt = get_supplied_by_list(psy, chrgr_lst);
+	if (cnt == 0)
+		return;
+	while (cnt--) {
+		if (!IS_PRESENT(chrgr_lst[cnt]))
+			continue;
+		if (is_enable && is_charging_can_be_enabled(chrgr_lst[cnt]) &&
+				is_charging_can_be_enabled(psy)) {
+			enable_charging(chrgr_lst[cnt]);
+			wait_for_charging_enabled(chrgr_lst[cnt]);
+		} else
+			disable_charging(chrgr_lst[cnt]);
+	}
+}
+
+static void __power_supply_trigger_charging_handler(struct power_supply *psy)
+{
+	int i;
+	struct power_supply *psb = NULL;
+
+	mutex_lock(&psy_chrgr.evt_lock);
+
+	if (is_trigger_charging_algo(psy)) {
+
+		if (IS_BATTERY(psy)) {
+			if (trigger_algo(psy))
+				enable_supplied_by_charging(psy, false);
+			else
+				enable_supplied_by_charging(psy, true);
+		} else if (IS_CHARGER(psy)) {
+			for (i = 0; i < psy->num_supplicants; i++) {
+				psb =
+				    power_supply_get_by_name(psy->
+							     supplied_to[i]);
+
+				if (psb && IS_BATTERY(psb) && IS_PRESENT(psb)) {
+					if (trigger_algo(psb)) {
+						disable_charging(psy);
+						break;
+					} else if (is_charging_can_be_enabled
+								(psy)) {
+						enable_charging(psy);
+						wait_for_charging_enabled(psy);
+					}
+				}
+			}
+		}
+		update_sysfs(psy);
+		power_supply_changed(psy);
+	}
+	mutex_unlock(&psy_chrgr.evt_lock);
+
+}
+
+static int __trigger_charging_handler(struct device *dev, void *data)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	__power_supply_trigger_charging_handler(psy);
+
+	return 0;
+}
+
+static void trigger_algo_psy_class(struct work_struct *work)
+{
+	class_for_each_device(power_supply_class, NULL, NULL,
+			__trigger_charging_handler);
+}
+
+static bool is_cable_connected(void)
+{
+	int i;
+	struct charger_cable *cable;
+
+	for (i = 0; i < ARRAY_SIZE(cable_list); ++i) {
+		cable = cable_list + i;
+		if (IS_CABLE_ACTIVE(cable->cable_props.cable_stat))
+			return true;
+	}
+	return false;
+}
+
+void power_supply_trigger_charging_handler(struct power_supply *psy)
+{
+	if (!psy_chrgr.is_cable_evt_reg || !is_cable_connected())
+		return;
+
+	wake_up(&psy_chrgr.wait_chrg_enable);
+
+	if (psy)
+		__power_supply_trigger_charging_handler(psy);
+	else
+		schedule_work(&psy_chrgr.algo_trigger_work);
+
+}
+EXPORT_SYMBOL(power_supply_trigger_charging_handler);
+
+static inline int get_battery_thresholds(struct power_supply *psy,
+	struct psy_batt_thresholds *bat_thresh)
+{
+	struct charging_algo *algo;
+	struct ps_batt_chg_prof chrg_profile;
+
+	/* FIXME: Get iterm only for supplied_to arguments*/
+	if (get_batt_prop(&chrg_profile)) {
+		pr_err("%s:Error in getting charge profile\n", __func__);
+		return -EINVAL;
+	}
+
+	algo = power_supply_get_charging_algo(psy, &chrg_profile);
+	if (!algo) {
+		pr_err("%s:Error in getting charging algo!!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (algo->get_batt_thresholds) {
+		algo->get_batt_thresholds(chrg_profile, bat_thresh);
+	} else {
+		pr_err("%s:Error in getting battery thresholds from: %s\n",
+			__func__, algo->name);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int select_chrgr_cable(struct device *dev, void *data)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct charger_cable *cable, *max_ma_cable = NULL;
+	struct charger_cable *cable_lst = (struct charger_cable *)data;
+	int max_ma = -1, i;
+
+	if (!IS_CHARGER(psy))
+		return 0;
+
+	mutex_lock(&psy_chrgr.evt_lock);
+
+	/* get cable with maximum capability */
+	for (i = 0; i < ARRAY_SIZE(cable_list); ++i) {
+		cable = cable_lst + i;
+		if ((!IS_CABLE_ACTIVE(cable->cable_props.cable_stat)) ||
+		    (!IS_SUPPORTED_CABLE(psy, cable->psy_cable_type)))
+			continue;
+
+		if ((int)cable->cable_props.ma > max_ma) {
+			max_ma_cable = cable;
+			max_ma = cable->cable_props.ma;
+		}
+	}
+
+	/* no cable connected. disable charging */
+	if (!max_ma_cable) {
+		if ((IS_CHARGER_ENABLED(psy) || IS_CHARGING_ENABLED(psy))) {
+			disable_charging(psy);
+			disable_charger(psy);
+		}
+		set_cc(psy, 0);
+		set_cv(psy, 0);
+		set_inlmt(psy, 0);
+
+		/* set present and online as 0 */
+		set_present(psy, 0);
+		update_charger_online(psy);
+
+		switch_cable(psy, POWER_SUPPLY_CHARGER_TYPE_NONE);
+
+		mutex_unlock(&psy_chrgr.evt_lock);
+		power_supply_changed(psy);
+		return 0;
+	}
+
+	/* cable type changed.New cable connected or existing cable
+	 * capabilities changed.switch cable and enable charger and charging
+	 */
+	set_present(psy, 1);
+
+	if (CABLE_TYPE(psy) != max_ma_cable->psy_cable_type)
+		switch_cable(psy, max_ma_cable->psy_cable_type);
+
+	if (IS_CHARGER_CAN_BE_ENABLED(psy) &&
+			(max_ma_cable->cable_props.ma >= 100)) {
+		struct psy_batt_thresholds bat_thresh;
+		memset(&bat_thresh, 0, sizeof(bat_thresh));
+		enable_charger(psy);
+
+		update_charger_online(psy);
+
+		set_inlmt(psy, max_ma_cable->cable_props.ma);
+		if (!get_battery_thresholds(psy, &bat_thresh)) {
+			if (!ITERM(psy))
+				SET_ITERM(psy, bat_thresh.iterm);
+			SET_MIN_TEMP(psy, bat_thresh.temp_min);
+			SET_MAX_TEMP(psy, bat_thresh.temp_max);
+		}
+
+	} else {
+		set_inlmt(psy, max_ma_cable->cable_props.ma);
+		disable_charger(psy);
+		update_charger_online(psy);
+	}
+
+	mutex_unlock(&psy_chrgr.evt_lock);
+	power_supply_trigger_charging_handler(NULL);
+	/* Cable status is same as previous. No action to be taken */
+	return 0;
+
+}
+
+static void configure_chrgr_source(struct charger_cable *cable_lst)
+{
+	class_for_each_device(power_supply_class, NULL,
+			      cable_lst, select_chrgr_cable);
+}
+
+static void charger_cable_event_worker(struct work_struct *work)
+{
+	struct charger_cable *cable =
+	    container_of(work, struct charger_cable, work);
+	struct extcon_chrgr_cbl_props cable_props;
+
+	if (cable->edev->
+	    get_cable_properties(extcon_cable_name[cable->extcon_cable_type],
+				 (void *)&cable_props)) {
+		pr_err("%s:Error in getting cable(%s) properties from extcon device(%s)",
+			__func__, extcon_cable_name[cable->extcon_cable_type],
+				cable->edev->name);
+		return;
+	} else {
+		if (cable_props.cable_stat != cable->cable_props.cable_stat) {
+			cable->cable_props.cable_stat = cable_props.cable_stat;
+			cable->cable_props.ma = cable_props.ma;
+			configure_chrgr_source(cable_list);
+		}
+	}
+
+}
+
+static int charger_cable_notifier(struct notifier_block *nb,
+				  unsigned long stat, void *ptr)
+{
+	struct charger_cable *cable =
+	    container_of(nb, struct charger_cable, nb);
+
+	schedule_work(&cable->work);
+
+	return NOTIFY_DONE | NOTIFY_STOP_MASK;
+}
+
+int psy_charger_throttle_charger(struct power_supply *psy,
+					unsigned long state)
+{
+	int ret = 0;
+
+	if (!IS_PRESENT(psy))
+		return 0;
+
+	if (state < 0 || state > MAX_THROTTLE_STATE(psy))
+		return -EINVAL;
+
+	mutex_lock(&psy_chrgr.evt_lock);
+
+	switch THROTTLE_ACTION(psy, state)
+	{
+
+		case PSY_THROTTLE_DISABLE_CHARGER:
+			SET_MAX_CC(psy, 0);
+			disable_charger(psy);
+			break;
+		case PSY_THROTTLE_DISABLE_CHARGING:
+			SET_MAX_CC(psy, 0);
+			disable_charging(psy);
+			break;
+		case PSY_THROTTLE_CC_LIMIT:
+			SET_MAX_CC(psy, THROTTLE_CC_VALUE(psy, state));
+			break;
+		case PSY_THROTTLE_INPUT_LIMIT:
+			set_inlmt(psy, THROTTLE_CC_VALUE(psy, state));
+			break;
+		default:
+			pr_err("%s:Invalid throttle action for %s\n",
+						__func__, psy->name);
+			ret = -EINVAL;
+			break;
+	}
+	mutex_unlock(&psy_chrgr.evt_lock);
+
+	/* Configure the driver based on new state */
+	if (!ret)
+		configure_chrgr_source(cable_list);
+	return ret;
+}
+EXPORT_SYMBOL(psy_charger_throttle_charger);
+
+int power_supply_register_charger(struct power_supply *psy)
+{
+	int ret = 0;
+
+	if (!psy_chrgr.is_cable_evt_reg) {
+		mutex_init(&psy_chrgr.evt_lock);
+		init_waitqueue_head(&psy_chrgr.wait_chrg_enable);
+		init_charger_cables(cable_list, ARRAY_SIZE(cable_list));
+		INIT_LIST_HEAD(&psy_chrgr.chrgr_cache_lst);
+		INIT_LIST_HEAD(&psy_chrgr.batt_cache_lst);
+		INIT_WORK(&psy_chrgr.algo_trigger_work, trigger_algo_psy_class);
+		psy_chrgr.is_cable_evt_reg = true;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(power_supply_register_charger);
+
+static inline void flush_charger_context(struct power_supply *psy)
+{
+	struct charger_props *chrgr_prop, *tmp;
+
+	list_for_each_entry_safe(chrgr_prop, tmp,
+				&psy_chrgr.chrgr_cache_lst, node) {
+		if (!strcmp(chrgr_prop->name, psy->name)) {
+			list_del(&chrgr_prop->node);
+			kfree(chrgr_prop);
+		}
+	}
+}
+int power_supply_unregister_charger(struct power_supply *psy)
+{
+	flush_charger_context(psy);
+	return 0;
+}
+EXPORT_SYMBOL(power_supply_unregister_charger);
+
+int power_supply_register_charging_algo(struct charging_algo *algo)
+{
+	struct charging_algo *algo_new;
+
+	algo_new = kzalloc(sizeof(*algo_new), GFP_KERNEL);
+	if (algo_new == NULL) {
+		pr_err("%s: Error allocating memory for algo!!", __func__);
+		return -ENOMEM;
+	}
+	memcpy(algo_new, algo, sizeof(*algo_new));
+
+	list_add_tail(&algo_new->node, &algo_list);
+	return 0;
+}
+EXPORT_SYMBOL(power_supply_register_charging_algo);
+
+int power_supply_unregister_charging_algo(struct charging_algo *algo)
+{
+	struct charging_algo *algo_l, *tmp;
+
+	list_for_each_entry_safe(algo_l, tmp, &algo_list, node) {
+		if (!strcmp(algo_l->name, algo->name)) {
+			list_del(&algo_l->node);
+			kfree(algo_l);
+		}
+	}
+	return 0;
+
+}
+EXPORT_SYMBOL(power_supply_unregister_charging_algo);
+
+static struct charging_algo *get_charging_algo_byname(char *algo_name)
+{
+	struct charging_algo *algo;
+
+	list_for_each_entry(algo, &algo_list, node) {
+		if (!strcmp(algo->name, algo_name))
+			return algo;
+	}
+
+	return NULL;
+}
+
+static struct charging_algo *get_charging_algo_by_type
+		(enum batt_chrg_prof_type chrg_prof_type)
+{
+	struct charging_algo *algo;
+
+	list_for_each_entry(algo, &algo_list, node) {
+		if (algo->chrg_prof_type == chrg_prof_type)
+			return algo;
+	}
+
+	return NULL;
+}
+
+struct charging_algo *power_supply_get_charging_algo
+	(struct power_supply *psy, struct ps_batt_chg_prof *batt_prof)
+{
+	return get_charging_algo_by_type(batt_prof->chrg_prof_type);
+
+}
+EXPORT_SYMBOL_GPL(power_supply_get_charging_algo);
diff --git a/drivers/power/power_supply_core.c b/drivers/power/power_supply_core.c
index 2660664..8a12de7 100644
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@ -20,6 +20,7 @@
 #include <linux/power_supply.h>
 #include <linux/thermal.h>
 #include "power_supply.h"
+#include "power_supply_charger.h"
 
 /* exported for the APM Power driver, APM emulation */
 struct class *power_supply_class;
@@ -30,6 +31,13 @@ EXPORT_SYMBOL_GPL(power_supply_notifier);
 
 static struct device_type power_supply_dev_type;
 
+static struct mutex ps_chrg_evt_lock;
+
+static struct power_supply_charger_cap power_supply_chrg_cap = {
+		.chrg_evt	= POWER_SUPPLY_CHARGER_EVENT_DISCONNECT,
+		.chrg_type	= POWER_SUPPLY_TYPE_USB,
+		.mA		= 0	/* 0 mA */
+};
 static bool __power_supply_is_supplied_by(struct power_supply *supplier,
 					 struct power_supply *supply)
 {
@@ -83,6 +91,7 @@ static void power_supply_changed_work(struct work_struct *work)
 		spin_unlock_irqrestore(&psy->changed_lock, flags);
 		class_for_each_device(power_supply_class, NULL, psy,
 				      __power_supply_changed_work);
+		power_supply_trigger_charging_handler(psy);
 		power_supply_update_leds(psy);
 		atomic_notifier_call_chain(&power_supply_notifier,
 				PSY_EVENT_PROP_CHANGED, psy);
@@ -103,6 +112,11 @@ void power_supply_changed(struct power_supply *psy)
 {
 	unsigned long flags;
 
+	if (psy == NULL) {
+		power_supply_trigger_charging_handler(psy);
+		return;
+	}
+
 	dev_dbg(psy->dev, "%s\n", __func__);
 
 	spin_lock_irqsave(&psy->changed_lock, flags);
@@ -113,6 +127,37 @@ void power_supply_changed(struct power_supply *psy)
 }
 EXPORT_SYMBOL_GPL(power_supply_changed);
 
+static int __power_supply_charger_event(struct device *dev, void *data)
+{
+	struct power_supply_charger_cap *cap =
+				(struct power_supply_charger_cap *)data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->charging_port_changed)
+		psy->charging_port_changed(psy, cap);
+
+	return 0;
+}
+
+void power_supply_charger_event(struct power_supply_charger_cap cap)
+{
+	class_for_each_device(power_supply_class, NULL, &cap,
+				      __power_supply_charger_event);
+
+	mutex_lock(&ps_chrg_evt_lock);
+	memcpy(&power_supply_chrg_cap, &cap, sizeof(power_supply_chrg_cap));
+	mutex_unlock(&ps_chrg_evt_lock);
+}
+EXPORT_SYMBOL_GPL(power_supply_charger_event);
+
+void power_supply_query_charger_caps(struct power_supply_charger_cap *cap)
+{
+	mutex_lock(&ps_chrg_evt_lock);
+	memcpy(cap, &power_supply_chrg_cap, sizeof(power_supply_chrg_cap));
+	mutex_unlock(&ps_chrg_evt_lock);
+}
+EXPORT_SYMBOL_GPL(power_supply_query_charger_caps);
+
 #ifdef CONFIG_OF
 #include <linux/of.h>
 
@@ -300,12 +345,12 @@ int power_supply_is_system_supplied(void)
 	unsigned int count = 0;
 
 	error = class_for_each_device(power_supply_class, NULL, &count,
-				      __power_supply_is_system_supplied);
+					__power_supply_is_system_supplied);
 
 	/*
-	 * If no power class device was found at all, most probably we are
-	 * running on a desktop system, so assume we are on mains power.
-	 */
+	* If no power class device was found at all, most probably we are
+	* running on a desktop system, so assume we are on mains power.
+	*/
 	if (count == 0)
 		return 1;
 
@@ -313,6 +358,30 @@ int power_supply_is_system_supplied(void)
 }
 EXPORT_SYMBOL_GPL(power_supply_is_system_supplied);
 
+static int __power_supply_is_battery_connected(struct device *dev, void *data)
+{
+	union power_supply_propval ret = {0,};
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->type == POWER_SUPPLY_TYPE_BATTERY) {
+		if (psy->get_property(psy, POWER_SUPPLY_PROP_PRESENT, &ret))
+			return 0;
+		if (ret.intval)
+			return ret.intval;
+	}
+	return 0;
+}
+
+int power_supply_is_battery_connected(void)
+{
+	int error;
+
+	error = class_for_each_device(power_supply_class, NULL, NULL,
+					__power_supply_is_battery_connected);
+	return error;
+}
+EXPORT_SYMBOL_GPL(power_supply_is_battery_connected);
+
 int power_supply_set_battery_charged(struct power_supply *psy)
 {
 	if (psy->type == POWER_SUPPLY_TYPE_BATTERY && psy->set_charged) {
@@ -399,7 +468,8 @@ static int power_supply_read_temp(struct thermal_zone_device *tzd,
 	union power_supply_propval val;
 	int ret;
 
-	WARN_ON(tzd == NULL);
+	if (WARN_ON(tzd == NULL))
+		return -EINVAL;
 	psy = tzd->devdata;
 	ret = psy->get_property(psy, POWER_SUPPLY_PROP_TEMP, &val);
 
@@ -446,6 +516,8 @@ static int ps_get_max_charge_cntl_limit(struct thermal_cooling_device *tcd,
 	union power_supply_propval val;
 	int ret;
 
+	if (WARN_ON(tcd == NULL))
+		return -EINVAL;
 	psy = tcd->devdata;
 	ret = psy->get_property(psy,
 		POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX, &val);
@@ -462,6 +534,8 @@ static int ps_get_cur_chrage_cntl_limit(struct thermal_cooling_device *tcd,
 	union power_supply_propval val;
 	int ret;
 
+	if (WARN_ON(tcd == NULL))
+		return -EINVAL;
 	psy = tcd->devdata;
 	ret = psy->get_property(psy,
 		POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, &val);
@@ -478,11 +552,15 @@ static int ps_set_cur_charge_cntl_limit(struct thermal_cooling_device *tcd,
 	union power_supply_propval val;
 	int ret;
 
+	if (WARN_ON(tcd == NULL))
+		return -EINVAL;
 	psy = tcd->devdata;
 	val.intval = state;
 	ret = psy->set_property(psy,
 		POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT, &val);
 
+	psy_charger_throttle_charger(psy, state);
+
 	return ret;
 }
 
@@ -588,10 +666,16 @@ int power_supply_register(struct device *parent, struct power_supply *psy)
 	if (rc)
 		goto create_triggers_failed;
 
+	if (IS_CHARGER(psy))
+		rc = power_supply_register_charger(psy);
+	if (rc)
+		goto charger_register_failed;
+
 	power_supply_changed(psy);
 
 	goto success;
 
+charger_register_failed:
 create_triggers_failed:
 	psy_unregister_cooler(psy);
 register_cooler_failed:
@@ -613,6 +697,9 @@ void power_supply_unregister(struct power_supply *psy)
 	cancel_work_sync(&psy->changed_work);
 	sysfs_remove_link(&psy->dev->kobj, "powers");
 	power_supply_remove_triggers(psy);
+	if (IS_CHARGER(psy))
+		power_supply_unregister_charger(psy);
+	power_supply_remove_triggers(psy);
 	psy_unregister_cooler(psy);
 	psy_unregister_thermal(psy);
 	device_init_wakeup(psy->dev, false);
@@ -629,6 +716,7 @@ static int __init power_supply_class_init(void)
 
 	power_supply_class->dev_uevent = power_supply_uevent;
 	power_supply_init_attrs(&power_supply_dev_type);
+	mutex_init(&ps_chrg_evt_lock);
 
 	return 0;
 }
diff --git a/drivers/power/power_supply_sysfs.c b/drivers/power/power_supply_sysfs.c
index 7566e15..77a5992 100644
--- a/drivers/power/power_supply_sysfs.c
+++ b/drivers/power/power_supply_sysfs.c
@@ -44,7 +44,7 @@ static ssize_t power_supply_show_property(struct device *dev,
 					  struct device_attribute *attr,
 					  char *buf) {
 	static char *type_text[] = {
-		"Unknown", "Battery", "UPS", "Mains", "USB",
+		"Unknown", "Battery", "UPS", "Mains", "USB", "USB",
 		"USB_DCP", "USB_CDP", "USB_ACA"
 	};
 	static char *status_text[] = {
@@ -165,8 +165,14 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(constant_charge_current_max),
 	POWER_SUPPLY_ATTR(constant_charge_voltage),
 	POWER_SUPPLY_ATTR(constant_charge_voltage_max),
+	POWER_SUPPLY_ATTR(charge_current_limit),
 	POWER_SUPPLY_ATTR(charge_control_limit),
 	POWER_SUPPLY_ATTR(charge_control_limit_max),
+	POWER_SUPPLY_ATTR(charge_current),
+	POWER_SUPPLY_ATTR(max_charge_current),
+	POWER_SUPPLY_ATTR(charge_voltage),
+	POWER_SUPPLY_ATTR(max_charge_voltage),
+	POWER_SUPPLY_ATTR(input_cur_limit),
 	POWER_SUPPLY_ATTR(energy_full_design),
 	POWER_SUPPLY_ATTR(energy_empty_design),
 	POWER_SUPPLY_ATTR(energy_full),
@@ -180,6 +186,8 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(temp),
 	POWER_SUPPLY_ATTR(temp_alert_min),
 	POWER_SUPPLY_ATTR(temp_alert_max),
+	POWER_SUPPLY_ATTR(max_temp),
+	POWER_SUPPLY_ATTR(min_temp),
 	POWER_SUPPLY_ATTR(temp_ambient),
 	POWER_SUPPLY_ATTR(temp_ambient_alert_min),
 	POWER_SUPPLY_ATTR(temp_ambient_alert_max),
@@ -188,6 +196,11 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(time_to_full_now),
 	POWER_SUPPLY_ATTR(time_to_full_avg),
 	POWER_SUPPLY_ATTR(type),
+	POWER_SUPPLY_ATTR(charge_term_cur),
+	POWER_SUPPLY_ATTR(enable_charging),
+	POWER_SUPPLY_ATTR(enable_charger),
+	POWER_SUPPLY_ATTR(cable_type),
+	POWER_SUPPLY_ATTR(priority),
 	POWER_SUPPLY_ATTR(scope),
 	/* Local extensions */
 	POWER_SUPPLY_ATTR(usb_hc),
-- 
2.0.0

