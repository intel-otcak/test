From 3650eb44734ad4fbe098313349da8185595a20d8 Mon Sep 17 00:00:00 2001
Message-Id: <3650eb44734ad4fbe098313349da8185595a20d8.1421709247.git.chang-joon.lee@intel.com>
From: Arun R Murthy <arun.r.murthy@intel.com>
Date: Wed, 18 Jun 2014 14:23:54 +0800
Subject: [PATCH 01/75] MUST_REBASE [VPG]: adf/intel: Pull in intel ADF driver
 framework.

Big bulk of MCG work done to enable ADF driver. This patch brings in all
the MCG code for intel-adf framework

Code originates from multiple changes in MCG trees. Primarily -
Ia3f1fc537fd20365cd832064666cfcde73db3a2b

v2: - Modified the file licence content
    - Corrected checkpatch errors
    - Moved all code from external_drivers to drivers/video/adf/intel/

v3: - Compilation warnings removed.

v4: - Squashed one separate MCG code base patch into this one as well

v5: - Removed all remaining checkpatch errors. Still some warnings are there to
      be removed
    - Updated commit message

MUST_REBASE: Since Google ADF framework is not in upstream and also
we cannot have two display drivers, other one being i915, we need to
work on i915 and ADF convergence path before it can be upstreamed

For: GMINL-3547
Change-Id: Idf0faec8123d4bf4bd4131be896050194c469a32
Signed-off-by: Austin Hu <austin.hu@intel.com>
Signed-off-by: Jason Chen <jason.chen@intel.com>
Signed-off-by: Jackie Li <yaodong.li@intel.com>
Signed-off-by: Arun R Murthy <arun.r.murthy@intel.com>
Signed-off-by: Shobhit Kumar <shobhit.kumar@intel.com>
---
 drivers/video/adf/Makefile                         |    2 +-
 drivers/video/adf/adf.c                            |    4 +-
 drivers/video/adf/adf.h                            |    1 -
 drivers/video/adf/adf_client.c                     |    5 +-
 drivers/video/adf/adf_fbdev.c                      |    5 +-
 drivers/video/adf/adf_fops.c                       |    4 +-
 drivers/video/adf/intel/Makefile                   |   14 +
 drivers/video/adf/intel/core/Makefile              |   13 +
 drivers/video/adf/intel/core/common/Makefile       |    7 +
 .../video/adf/intel/core/common/backlight_dev.c    |  117 +
 drivers/video/adf/intel/core/common/dc_mm.c        |  415 +++
 .../video/adf/intel/core/common/dsi/dsi_config.c   |  248 ++
 drivers/video/adf/intel/core/common/dsi/dsi_dbi.c  |  881 ++++++
 drivers/video/adf/intel/core/common/dsi/dsi_dbi.h  |   35 +
 .../video/adf/intel/core/common/dsi/dsi_dbi_dsr.c  |  352 +++
 drivers/video/adf/intel/core/common/dsi/dsi_dpi.c  | 1022 +++++++
 drivers/video/adf/intel/core/common/dsi/dsi_dpi.h  |   42 +
 .../video/adf/intel/core/common/dsi/dsi_dpi_sdo.c  |  456 +++
 .../video/adf/intel/core/common/dsi/dsi_panel.c    |   66 +
 drivers/video/adf/intel/core/common/dsi/dsi_pipe.c |  811 +++++
 .../adf/intel/core/common/dsi/dsi_pkg_sender.c     | 1772 +++++++++++
 .../intel/core/common/dsi/panels/cmi_7x12_cmd.c    |  738 +++++
 .../intel/core/common/dsi/panels/jdi_7x12_cmd.c    |  640 ++++
 .../intel/core/common/dsi/panels/jdi_7x12_vid.c    |  438 +++
 .../intel/core/common/dsi/panels/sharp_10x19_cmd.c |  657 +++++
 .../intel/core/common/dsi/panels/sharp_25x16_cmd.c |  373 +++
 .../intel/core/common/dsi/panels/sharp_25x16_vid.c |  349 +++
 .../adf/intel/core/common/hdmi/adf_hdmi_audio_if.h |   94 +
 .../video/adf/intel/core/common/hdmi/hdmi_audio.c  |  298 ++
 .../video/adf/intel/core/common/hdmi/hdmi_edid.c   | 3096 ++++++++++++++++++++
 .../video/adf/intel/core/common/hdmi/hdmi_edid.h   |  334 +++
 .../video/adf/intel/core/common/hdmi/hdmi_hdcp.c   | 1407 +++++++++
 .../video/adf/intel/core/common/hdmi/hdmi_hdcp.h   |  162 +
 .../adf/intel/core/common/hdmi/hdmi_hotplug.c      |   82 +
 .../adf/intel/core/common/hdmi/hdmi_hotplug.h      |   29 +
 .../video/adf/intel/core/common/hdmi/hdmi_pipe.c   |  963 ++++++
 .../video/adf/intel/core/common/hdmi/hdmi_pipe.h   |  204 ++
 .../intel/core/common/hdmi/platforms/mofd_hdcp.c   |  809 +++++
 .../core/common/hdmi/platforms/mofd_hdcp_reg.h     |  167 ++
 .../intel/core/common/hdmi/platforms/mofd_hdmi.c   |  171 ++
 drivers/video/adf/intel/core/intel_dc_config.c     |  285 ++
 drivers/video/adf/intel/core/intel_dc_memory.c     |  166 ++
 drivers/video/adf/intel/core/intel_dc_power.c      |   52 +
 drivers/video/adf/intel/core/intel_pipe.c          |   44 +
 drivers/video/adf/intel/core/intel_plane.c         |   39 +
 .../adf/intel/include/core/common/backlight_dev.h  |   29 +
 .../video/adf/intel/include/core/common/dc_mm.h    |   62 +
 .../adf/intel/include/core/common/dsi/dsi_config.h |  319 ++
 .../intel/include/core/common/dsi/dsi_dbi_dsr.h    |   58 +
 .../intel/include/core/common/dsi/dsi_dpi_sdo.h    |   56 +
 .../adf/intel/include/core/common/dsi/dsi_panel.h  |   87 +
 .../adf/intel/include/core/common/dsi/dsi_pipe.h   |   77 +
 .../intel/include/core/common/dsi/dsi_pkg_sender.h |  230 ++
 .../adf/intel/include/core/common/intel_dc_regs.h  |   17 +
 .../video/adf/intel/include/core/common/overlay.h  |  133 +
 .../video/adf/intel/include/core/intel_dc_config.h |  345 +++
 drivers/video/adf/intel/include/intel_adf.h        |   51 +
 drivers/video/adf/intel/include/intel_adf_device.h |   69 +
 drivers/video/adf/intel/include/intel_adf_fbdev.h  |   24 +
 .../video/adf/intel/include/intel_adf_interface.h  |   49 +
 drivers/video/adf/intel/include/intel_adf_mm.h     |   47 +
 .../adf/intel/include/intel_adf_overlay_engine.h   |   41 +
 drivers/video/adf/intel/include/intel_adf_sync.h   |   41 +
 drivers/video/adf/intel/include/uapi/intel_adf.h   |  218 ++
 .../adf/intel/include/uapi/intel_custom_formats.h  |   32 +
 drivers/video/adf/intel/intel_adf.c                |  342 +++
 drivers/video/adf/intel/intel_adf_device.c         |  649 ++++
 drivers/video/adf/intel/intel_adf_fbdev.c          |   72 +
 drivers/video/adf/intel/intel_adf_interface.c      |  460 +++
 drivers/video/adf/intel/intel_adf_mm.c             |  516 ++++
 drivers/video/adf/intel/intel_adf_overlay_engine.c |   41 +
 drivers/video/adf/intel/intel_adf_sync.c           |  153 +
 include/video/adf.h                                |    1 -
 73 files changed, 22076 insertions(+), 12 deletions(-)
 create mode 100644 drivers/video/adf/intel/Makefile
 create mode 100644 drivers/video/adf/intel/core/Makefile
 create mode 100644 drivers/video/adf/intel/core/common/Makefile
 create mode 100644 drivers/video/adf/intel/core/common/backlight_dev.c
 create mode 100644 drivers/video/adf/intel/core/common/dc_mm.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_config.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_dbi.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_dbi.h
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_dbi_dsr.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_dpi.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_dpi.h
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_dpi_sdo.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_panel.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_pipe.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_pkg_sender.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/cmi_7x12_cmd.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_cmd.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_vid.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/sharp_10x19_cmd.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_cmd.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_vid.c
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/adf_hdmi_audio_if.h
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_audio.c
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_edid.c
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_edid.h
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.c
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.h
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.c
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.h
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.c
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.h
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp.c
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp_reg.h
 create mode 100644 drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdmi.c
 create mode 100644 drivers/video/adf/intel/core/intel_dc_config.c
 create mode 100644 drivers/video/adf/intel/core/intel_dc_memory.c
 create mode 100644 drivers/video/adf/intel/core/intel_dc_power.c
 create mode 100644 drivers/video/adf/intel/core/intel_pipe.c
 create mode 100644 drivers/video/adf/intel/core/intel_plane.c
 create mode 100644 drivers/video/adf/intel/include/core/common/backlight_dev.h
 create mode 100644 drivers/video/adf/intel/include/core/common/dc_mm.h
 create mode 100644 drivers/video/adf/intel/include/core/common/dsi/dsi_config.h
 create mode 100644 drivers/video/adf/intel/include/core/common/dsi/dsi_dbi_dsr.h
 create mode 100644 drivers/video/adf/intel/include/core/common/dsi/dsi_dpi_sdo.h
 create mode 100644 drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h
 create mode 100644 drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
 create mode 100644 drivers/video/adf/intel/include/core/common/dsi/dsi_pkg_sender.h
 create mode 100644 drivers/video/adf/intel/include/core/common/intel_dc_regs.h
 create mode 100644 drivers/video/adf/intel/include/core/common/overlay.h
 create mode 100644 drivers/video/adf/intel/include/core/intel_dc_config.h
 create mode 100644 drivers/video/adf/intel/include/intel_adf.h
 create mode 100644 drivers/video/adf/intel/include/intel_adf_device.h
 create mode 100644 drivers/video/adf/intel/include/intel_adf_fbdev.h
 create mode 100644 drivers/video/adf/intel/include/intel_adf_interface.h
 create mode 100644 drivers/video/adf/intel/include/intel_adf_mm.h
 create mode 100644 drivers/video/adf/intel/include/intel_adf_overlay_engine.h
 create mode 100644 drivers/video/adf/intel/include/intel_adf_sync.h
 create mode 100644 drivers/video/adf/intel/include/uapi/intel_adf.h
 create mode 100644 drivers/video/adf/intel/include/uapi/intel_custom_formats.h
 create mode 100644 drivers/video/adf/intel/intel_adf.c
 create mode 100644 drivers/video/adf/intel/intel_adf_device.c
 create mode 100644 drivers/video/adf/intel/intel_adf_fbdev.c
 create mode 100644 drivers/video/adf/intel/intel_adf_interface.c
 create mode 100644 drivers/video/adf/intel/intel_adf_mm.c
 create mode 100644 drivers/video/adf/intel/intel_adf_overlay_engine.c
 create mode 100644 drivers/video/adf/intel/intel_adf_sync.c

diff --git a/drivers/video/adf/Makefile b/drivers/video/adf/Makefile
index 78d0915..d5604d1 100644
--- a/drivers/video/adf/Makefile
+++ b/drivers/video/adf/Makefile
@@ -1,4 +1,4 @@
-ccflags-y := -Idrivers/staging/android
+ccflags-y := -Idrivers/staging/
 
 CFLAGS_adf.o := -I$(src)
 
diff --git a/drivers/video/adf/adf.c b/drivers/video/adf/adf.c
index 2d20024..019e8f4 100644
--- a/drivers/video/adf/adf.c
+++ b/drivers/video/adf/adf.c
@@ -24,8 +24,8 @@
 
 #include <video/adf_format.h>
 
-#include "sw_sync.h"
-#include "sync.h"
+#include <android/sw_sync.h>
+#include <android/sync.h>
 
 #include "adf.h"
 #include "adf_fops.h"
diff --git a/drivers/video/adf/adf.h b/drivers/video/adf/adf.h
index 3bcf1fa..f0eba44 100644
--- a/drivers/video/adf/adf.h
+++ b/drivers/video/adf/adf.h
@@ -18,7 +18,6 @@
 #include <linux/idr.h>
 #include <linux/list.h>
 #include <video/adf.h>
-#include "sync.h"
 
 struct adf_event_refcount {
 	struct rb_node node;
diff --git a/drivers/video/adf/adf_client.c b/drivers/video/adf/adf_client.c
index 8061d8e..5292745 100644
--- a/drivers/video/adf/adf_client.c
+++ b/drivers/video/adf/adf_client.c
@@ -15,13 +15,10 @@
 #include <linux/kthread.h>
 #include <linux/mutex.h>
 #include <linux/slab.h>
-
-#include "sw_sync.h"
-
+#include <android/sw_sync.h>
 #include <video/adf.h>
 #include <video/adf_client.h>
 #include <video/adf_format.h>
-
 #include "adf.h"
 
 static inline bool vsync_active(u8 state)
diff --git a/drivers/video/adf/adf_fbdev.c b/drivers/video/adf/adf_fbdev.c
index cac34d1..dbd660a 100644
--- a/drivers/video/adf/adf_fbdev.c
+++ b/drivers/video/adf/adf_fbdev.c
@@ -18,6 +18,8 @@
 #include <video/adf_client.h>
 #include <video/adf_fbdev.h>
 #include <video/adf_format.h>
+#include <android/sync.h>
+#include <android/sw_sync.h>
 
 #include "adf.h"
 
@@ -90,7 +92,8 @@ static u32 drm_fourcc_from_fb_var(struct fb_var_screeninfo *var)
 	size_t i;
 	for (i = 0; i < ARRAY_SIZE(format_table); i++) {
 		const struct adf_fbdev_format *f = &format_table[i];
-		if (var->red.length == f->r_length &&
+		if (var->bits_per_pixel == f->bpp &&
+			var->red.length == f->r_length &&
 			var->red.offset == f->r_offset &&
 			var->green.length == f->g_length &&
 			var->green.offset == f->g_offset &&
diff --git a/drivers/video/adf/adf_fops.c b/drivers/video/adf/adf_fops.c
index abec58e..7d0a1c2 100644
--- a/drivers/video/adf/adf_fops.c
+++ b/drivers/video/adf/adf_fops.c
@@ -23,8 +23,8 @@
 #include <video/adf_client.h>
 #include <video/adf_format.h>
 
-#include "sw_sync.h"
-#include "sync.h"
+#include <android/sw_sync.h>
+#include <android/sync.h>
 
 #include "adf.h"
 #include "adf_fops.h"
diff --git a/drivers/video/adf/intel/Makefile b/drivers/video/adf/intel/Makefile
new file mode 100644
index 0000000..e55da6e
--- /dev/null
+++ b/drivers/video/adf/intel/Makefile
@@ -0,0 +1,14 @@
+# Makefile for Intel display driver based on ADF framework
+ccflags-y := -Idrivers/staging/ -Iinclude/adf -Iinclude/uapi/adf -Idrivers/video/adf/intel/include
+
+obj-$(CONFIG_ADF_INTEL) += intel_adf.o \
+	intel_adf_device.o \
+	intel_adf_interface.o \
+	intel_adf_overlay_engine.o \
+	intel_adf_sync.o
+
+obj-$(CONFIG_ADF_INTEL_FBDEV) += intel_adf_fbdev.o
+
+obj-$(CONFIG_ADF_MEMBLOCK) += intel_adf_mm.o
+
+obj-$(CONFIG_ADF_INTEL) += core/
diff --git a/drivers/video/adf/intel/core/Makefile b/drivers/video/adf/intel/core/Makefile
new file mode 100644
index 0000000..c463d10
--- /dev/null
+++ b/drivers/video/adf/intel/core/Makefile
@@ -0,0 +1,13 @@
+# Makefile for Intel display driver based on ADF framework
+
+ccflags-y := -Idrivers/staging/android -Iinclude/adf -Iinclude/uapi/adf -Idrivers/video/adf/intel/include
+
+CFLAGS_adf.o := -I$(src)
+
+obj-$(CONFIG_ADF_INTEL) += intel_plane.o \
+	intel_pipe.o \
+	intel_dc_power.o \
+	intel_dc_memory.o \
+	intel_dc_config.o
+
+obj-$(CONFIG_ADF_INTEL) += common/
diff --git a/drivers/video/adf/intel/core/common/Makefile b/drivers/video/adf/intel/core/common/Makefile
new file mode 100644
index 0000000..c950d6e
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/Makefile
@@ -0,0 +1,7 @@
+# Makefile for Intel display driver based on ADF framework
+
+ccflags-y := -Idrivers/staging/ -Iinclude/adf -Iinclude/uapi/adf -Idrivers/video/adf/intel/include
+
+CFLAGS_adf.o := -I$(src)
+
+obj-$(CONFIG_ADF_INTEL) += backlight_dev.o
diff --git a/drivers/video/adf/intel/core/common/backlight_dev.c b/drivers/video/adf/intel/core/common/backlight_dev.c
new file mode 100644
index 0000000..86c22ac
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/backlight_dev.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "core/common/backlight_dev.h"
+#include "intel_adf.h"
+
+static int get_brightness(struct backlight_device *bl_dev)
+{
+	if (!bl_dev) {
+		pr_err("%s: invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	pr_debug("brightness = 0x%x\n", bl_dev->props.brightness);
+
+	return bl_dev->props.brightness;
+}
+
+static int set_brightness(struct backlight_device *bl_dev)
+{
+	int level = 0, i = 0, ret = 0;
+	struct intel_adf_context *adf_ctx;
+	struct intel_adf_interface *intf;
+	struct intel_pipe *pipe;
+
+	if (!bl_dev) {
+		pr_err("%s: invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	adf_ctx = bl_get_data(bl_dev);
+	if (!adf_ctx)
+		return -EINVAL;
+
+	level = bl_dev->props.brightness;
+	/* Perform value bounds checking */
+	if (level < BRIGHTNESS_MIN_LEVEL)
+		level = BRIGHTNESS_MIN_LEVEL;
+
+	if (level > BRIGHTNESS_MAX_LEVEL)
+		level = BRIGHTNESS_MAX_LEVEL;
+
+	pr_debug("%s: level is %d\n", __func__, level);
+
+	for (i = 0; i < adf_ctx->n_intfs; i++) {
+		intf = &adf_ctx->intfs[i];
+		if (!intf)
+			continue;
+
+		pipe = intf->pipe;
+		if (!pipe || !pipe->ops)
+			continue;
+
+		/*
+		 * Primary display should support brightness setting,
+		 * but external display may not.
+		 */
+		if (!pipe->ops->set_brightness) {
+			pr_debug("%s: pipe %s doesn't support brightness",
+				 __func__, pipe->base.name);
+			continue;
+		}
+
+		ret = pipe->ops->set_brightness(pipe, level);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+const struct backlight_ops bl_ops = {
+	.get_brightness = get_brightness,
+	.update_status = set_brightness,
+};
+
+int backlight_init(struct intel_adf_context *adf_ctx)
+{
+	struct backlight_properties props;
+
+	if (!adf_ctx) {
+		pr_err("%s: invalid argument\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.max_brightness = BRIGHTNESS_MAX_LEVEL;
+	props.type = BACKLIGHT_RAW;
+
+	/* Use the legacy backlight device name 'psb-bl'... */
+	adf_ctx->bl_dev = backlight_device_register("psb-bl",
+			NULL, (void *)adf_ctx, &bl_ops, &props);
+	if (IS_ERR(adf_ctx->bl_dev))
+		return PTR_ERR(adf_ctx->bl_dev);
+
+	adf_ctx->bl_dev->props.brightness = BRIGHTNESS_INIT_LEVEL;
+	adf_ctx->bl_dev->props.max_brightness = BRIGHTNESS_MAX_LEVEL;
+
+	return 0;
+}
+
+void backlight_exit(struct backlight_device *bl_dev)
+{
+	if (bl_dev)
+		backlight_device_unregister(bl_dev);
+}
diff --git a/drivers/video/adf/intel/core/common/dc_mm.c b/drivers/video/adf/intel/core/common/dc_mm.c
new file mode 100644
index 0000000..1d805f4
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dc_mm.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <asm/cacheflush.h>
+
+#include "core/common/dc_mm.h"
+
+static inline void dc_mm_insert_pages(struct dc_mm *mm, u32 offset,
+	struct page **pages, size_t n_pages)
+{
+	mm->insert(mm, offset, pages, n_pages);
+}
+
+static inline void dc_mm_clear_pages(struct dc_mm *mm, u32 offset,
+	size_t n_pages)
+{
+	struct page *pages[1];
+	size_t i;
+
+	pages[0] = mm->blank_page;
+	for (i = 0; i < n_pages; i++)
+		mm->insert(mm, (offset + i), pages, 1);
+}
+
+static int dc_mm_find_ht_locked(struct dc_mm *mm, u32 tgid,
+	struct dc_mm_per_thread_entry **hentry)
+{
+	struct drm_hash_item *entry;
+	int err;
+
+	err = drm_ht_find_item(&mm->ht, tgid, &entry);
+	if (err)
+		return err;
+
+	*hentry = container_of(entry, struct dc_mm_per_thread_entry, item);
+
+	return 0;
+}
+
+static int dc_mm_insert_ht_locked(struct dc_mm *mm, u32 tgid,
+	struct dc_mm_per_thread_entry *hentry)
+{
+	struct drm_hash_item *item;
+	int err;
+
+	if (!hentry)
+		return -EINVAL;
+
+	item = &hentry->item;
+	item->key = tgid;
+
+	/**
+	 * NOTE: drm_ht_insert_item will perform such a check
+	ret = psb_gtt_mm_get_ht_by_pid(mm, tgid, &tmp);
+	if (!ret) {
+		DRM_DEBUG("Entry already exists for pid %ld\n", tgid);
+		return -EAGAIN;
+	}
+	*/
+
+	/*Insert the given entry */
+	err = drm_ht_insert_item(&mm->ht, item);
+	if (err)
+		return err;
+	mm->n_entries++;
+	return 0;
+}
+
+static int dc_mm_alloc_insert_ht_locked(struct dc_mm *mm,
+	u32 tgid, struct dc_mm_per_thread_entry **entry)
+{
+	struct dc_mm_per_thread_entry *hentry;
+	int err;
+
+	/*if the hentry for this tgid exists, just get it and return */
+	err = dc_mm_find_ht_locked(mm, tgid, &hentry);
+	if (!err) {
+		kref_get(&hentry->ref);
+		*entry = hentry;
+		return 0;
+	}
+
+	hentry = kzalloc(sizeof(struct dc_mm_per_thread_entry), GFP_KERNEL);
+	if (!hentry) {
+		err = -ENOMEM;
+		goto err_out0;
+	}
+
+	err = drm_ht_create(&hentry->ht, PAGE_SHIFT);
+	if (err)
+		goto err_out1;
+
+	err = dc_mm_insert_ht_locked(mm, tgid, hentry);
+	if (err)
+		goto err_out2;
+
+	kref_init(&hentry->ref);
+	hentry->parent = &mm->ht;
+	*entry = hentry;
+
+	return 0;
+err_out2:
+	drm_ht_remove(&hentry->ht);
+err_out1:
+	kfree(hentry);
+err_out0:
+	return err;
+}
+
+static int dc_mm_get_mem_mapping_locked(struct drm_open_hash *ht,
+	u32 key, struct dc_mm_buffer_mem_mapping **hentry)
+{
+	struct drm_hash_item *entry;
+	struct dc_mm_buffer_mem_mapping *mapping;
+	int ret;
+
+	ret = drm_ht_find_item(ht, key, &entry);
+	if (ret)
+		return ret;
+
+	mapping = container_of(entry, struct dc_mm_buffer_mem_mapping, item);
+	if (!mapping)
+		return -EINVAL;
+
+	*hentry = mapping;
+	return 0;
+}
+
+static int dc_mm_insert_mem_mapping_locked(
+	struct dc_mm_per_thread_entry *hentry, u32 key,
+	struct dc_mm_buffer_mem_mapping *mapping)
+{
+	struct drm_hash_item *item;
+	int err;
+
+	item = &mapping->item;
+	item->key = key;
+
+	err = drm_ht_insert_item(&hentry->ht, item);
+	if (err)
+		return err;
+	hentry->n_entries++;
+
+	return 0;
+}
+
+static int dc_mm_alloc_insert_mem_mapping_locked(struct dc_mm *mm,
+	struct dc_mm_per_thread_entry *hentry, u32 key,
+	struct drm_mm_node *node, struct dc_mm_buffer_mem_mapping **entry)
+{
+	struct dc_mm_buffer_mem_mapping *mapping;
+	int err;
+
+	/*try to get this mem_map */
+	err = dc_mm_get_mem_mapping_locked(&hentry->ht, key, &mapping);
+	if (!err) {
+		kref_get(&mapping->ref);
+		*entry = mapping;
+		return 0;
+	}
+
+	mapping = kzalloc(sizeof(struct dc_mm_buffer_mem_mapping), GFP_KERNEL);
+	if (!mapping)
+		return -ENOMEM;
+
+	mapping->node = node;
+
+	err = dc_mm_insert_mem_mapping_locked(hentry, key, mapping);
+	if (err)
+		goto out_err0;
+
+	kref_init(&mapping->ref);
+	mapping->parent = &hentry->ht;
+	*entry = mapping;
+
+	return 0;
+out_err0:
+	kfree(mapping);
+	return err;
+}
+
+static int dc_mm_add_node_locked(struct dc_mm *mm, u32 tgid, u32 key,
+	struct drm_mm_node *node, struct dc_mm_buffer_mem_mapping **entry)
+{
+	struct dc_mm_per_thread_entry *hentry;
+	struct dc_mm_buffer_mem_mapping *mapping;
+	int ret;
+
+	ret = dc_mm_alloc_insert_ht_locked(mm, tgid, &hentry);
+	if (ret)
+		return ret;
+
+	ret = dc_mm_alloc_insert_mem_mapping_locked(mm, hentry, key, node,
+		&mapping);
+	if (ret)
+		return ret;
+
+	*entry = mapping;
+
+	return 0;
+}
+
+static int dc_mm_alloc_mem_locked(struct dc_mm *mm, uint32_t pages,
+	uint32_t align, struct drm_mm_node **node)
+{
+	struct drm_mm_node *tmp_node;
+	int ret;
+
+	do {
+		ret = drm_mm_pre_get(&mm->base);
+		if (unlikely(ret))
+			return ret;
+
+		tmp_node = drm_mm_search_free(&mm->base, pages, align, 1);
+		if (unlikely(!tmp_node))
+			break;
+
+		tmp_node = drm_mm_get_block_atomic(tmp_node, pages, align);
+	} while (!tmp_node);
+
+	if (!tmp_node)
+		return -ENOMEM;
+
+	*node = tmp_node;
+	return 0;
+}
+
+static void dc_mm_destroy_per_thread_entry_locked(struct kref *ref)
+{
+	struct dc_mm_per_thread_entry *hentry =
+		container_of(ref, struct dc_mm_per_thread_entry, ref);
+	struct dc_mm *mm = container_of(hentry->parent, struct dc_mm, ht);
+
+	/*remove it from mm*/
+	drm_ht_remove_item(&mm->ht, &hentry->item);
+	/*remove hash table*/
+	drm_ht_remove(&hentry->ht);
+	/*free this entry*/
+	kfree(hentry);
+
+	--mm->n_entries;
+}
+
+static void dc_mm_destroy_mem_mapping_locked(struct kref *ref)
+{
+	struct dc_mm_buffer_mem_mapping *mapping =
+		container_of(ref, struct dc_mm_buffer_mem_mapping, ref);
+	struct dc_mm_per_thread_entry *hentry =
+		container_of(mapping->parent, struct dc_mm_per_thread_entry,
+			ht);
+	struct drm_mm_node *node = mapping->node;
+	struct dc_mm *mm = container_of(hentry->parent, struct dc_mm, ht);
+
+	/*remove this mapping from per thread table*/
+	drm_ht_remove_item(&hentry->ht, &mapping->item);
+	/*remove from MMU*/
+	dc_mm_clear_pages(mm, node->start, node->size);
+	/*release this node*/
+	drm_mm_put_block(node);
+	/*free this mapping*/
+	kfree(mapping);
+
+	/**
+	 * there's no mapping for this thread, continue destroying
+	 * per thread table
+	 */
+	if (--hentry->n_entries)
+		kref_put(&hentry->ref,
+			dc_mm_destroy_per_thread_entry_locked);
+}
+
+static int dc_mm_remove_free_mem_mapping_locked(struct drm_open_hash *ht,
+	u32 key)
+{
+	struct dc_mm_buffer_mem_mapping *mapping;
+	int err;
+
+	err = dc_mm_get_mem_mapping_locked(ht, key, &mapping);
+	if (err)
+		return err;
+
+	kref_put(&mapping->ref, dc_mm_destroy_mem_mapping_locked);
+
+	return 0;
+}
+
+static int dc_mm_remove_node_locked(struct dc_mm *mm, u32 tgid, u32 key)
+{
+	struct dc_mm_per_thread_entry *hentry;
+	int err;
+
+	err = dc_mm_find_ht_locked(mm, tgid, &hentry);
+	if (err)
+		return err;
+
+	/*remove mapping entry */
+	return dc_mm_remove_free_mem_mapping_locked(&hentry->ht, key);
+}
+
+int dc_mm_buffer_import(struct dc_mm *mm, u32 handle, struct page **pages,
+	size_t n_pages, u32 *addr)
+{
+	struct drm_mm_node *node;
+	struct dc_mm_buffer_mem_mapping *mapping;
+	u32 offset_pages;
+	int err = 0;
+
+	if (!mm || !mm->insert || !pages || !n_pages || !addr)
+		return -EINVAL;
+
+	mutex_lock(&mm->lock);
+
+	/*alloc memory in TT apeture */
+	err = dc_mm_alloc_mem_locked(mm, n_pages, 0, &node);
+	if (err) {
+		pr_info("%s: alloc TT memory error\n", __func__);
+		goto out_err0;
+	}
+
+	/*update psb_gtt_mm */
+	err = dc_mm_add_node_locked(mm, task_tgid_nr(current), handle,
+		node, &mapping);
+	if (err) {
+		pr_info("%s: add_node failed\n", __func__);
+		goto out_err1;
+	}
+
+	node = mapping->node;
+	offset_pages = node->start;
+
+	/*insert pages*/
+	dc_mm_insert_pages(mm, offset_pages, pages, n_pages);
+
+	*addr = offset_pages;
+
+	mutex_unlock(&mm->lock);
+	return 0;
+out_err1:
+	drm_mm_put_block(node);
+out_err0:
+	mutex_unlock(&mm->lock);
+	return err;
+}
+
+void dc_mm_buffer_free(struct dc_mm *mm, u32 handle)
+{
+
+	if (!mm)
+		return;
+
+	mutex_lock(&mm->lock);
+
+	dc_mm_remove_node_locked(mm, task_tgid_nr(current), handle);
+
+	mutex_unlock(&mm->lock);
+}
+
+int dc_mm_init(struct dc_mm *mm, u32 start, size_t n_pages,
+	page_table_insert_t insert_func)
+{
+	struct page *blank_page;
+	int err;
+
+	if (!mm || !insert_func)
+		return -EINVAL;
+
+	memset(mm, 0, sizeof(*mm));
+
+	blank_page = alloc_page(GFP_DMA32 | __GFP_ZERO);
+	if (!blank_page)
+		return -ENOMEM;
+	get_page(blank_page);
+	set_pages_uc(blank_page, 1);
+
+	mm->insert = insert_func;
+	mm->blank_page = blank_page;
+
+	err = drm_ht_create(&mm->ht, PAGE_SHIFT);
+	if (err)
+		goto out_err0;
+
+	drm_mm_init(&mm->base, start, n_pages);
+
+	mutex_init(&mm->lock);
+
+	dc_mm_clear_pages(mm, start, n_pages);
+	return 0;
+out_err0:
+	put_page(blank_page);
+	__free_page(blank_page);
+	return err;
+}
+
+void dc_mm_destroy(struct dc_mm *mm)
+{
+	if (mm) {
+		put_page(mm->blank_page);
+		__free_page(mm->blank_page);
+		drm_mm_takedown(&mm->base);
+		drm_ht_remove(&mm->ht);
+	}
+}
+
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_config.c b/drivers/video/adf/intel/core/common/dsi/dsi_config.c
new file mode 100644
index 0000000..152d030
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_config.c
@@ -0,0 +1,248 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_panel.h"
+
+static void dsi_regs_init(struct dsi_config *config, int idx)
+{
+	struct dsi_registers *regs;
+
+	regs = &config->regs;
+
+	regs->vgacntr_reg = VGACNTRL;
+	regs->dpll_reg = DPLL_CTRL_A;
+
+	regs->ovaadd_reg = OVAADD;
+	regs->ovcadd_reg = OVCADD;
+	regs->ddl1_reg = DDL1;
+	regs->ddl2_reg = DDL2;
+	regs->ddl3_reg = DDL3;
+	regs->ddl4_reg = DDL4;
+	regs->histogram_intr_ctrl_reg = HIST_THRESHOLD_GD;
+	regs->histogram_logic_ctrl_reg = A_BLK_HISTOGRAM_LOGIC_CTRL;
+	regs->aimg_enhance_bin_reg = A_IMG_ENHANCE_BIN;
+
+	switch (idx) {
+	case 0:
+		regs->dspcntr_reg = DSPACNTR;
+		regs->dspsize_reg = DSPASIZE;
+		regs->dspsurf_reg = DSPASURF;
+		regs->dsplinoff_reg = DSPALINOFF;
+		regs->dsppos_reg = DSPAPOS;
+		regs->dspstride_reg = DSPASTRIDE;
+		regs->color_coef_reg = PIPEA_COLOR_COEF0;
+		regs->htotal_reg = HTOTAL_A;
+		regs->hblank_reg = HBLANK_A;
+		regs->hsync_reg = HSYNC_A;
+		regs->vtotal_reg = VTOTAL_A;
+		regs->vblank_reg = VBLANK_A;
+		regs->vsync_reg = VSYNC_A;
+		regs->pipesrc_reg = SRCSZ_A;
+		regs->pipeconf_reg = PIPEACONF;
+		regs->pipestat_reg = PIPEASTAT;
+		regs->pipeframehigh_reg = PIPEAFRAMEHIGH;
+		regs->pipeframepixel_reg = PIPEAFRAMEPIXEL;
+		regs->mipi_reg = MIPIA_PORT_CTRL;
+		regs->palette_reg = PIPE_A_PALETTE;
+		regs->gamma_red_max_reg = GAMMA_RED_MAX_A;
+		regs->gamma_green_max_reg = GAMMA_GREEN_MAX_A;
+		regs->gamma_blue_max_reg = GAMMA_BLUE_MAX_A;
+
+		regs->device_ready_reg = MIPIA_DEVICE_READY;
+		regs->intr_stat_reg = MIPIA_INTR_STAT_REG;
+		regs->intr_en_reg = MIPIA_INTR_EN_REG;
+		regs->dsi_func_prg_reg = MIPIA_DSI_FUNC_PRG_REG;
+		regs->hs_tx_timeout_reg = MIPIA_HS_TX_TIMEOUT_REG;
+		regs->lp_rx_timeout_reg = MIPIA_LP_RX_TIMEOUT_REG;
+		regs->turn_around_timeout_reg = MIPIA_TURN_AROUND_TIMEOUT_REG;
+		regs->device_reset_timer_reg = MIPIA_DEVICE_RESET_TIMER;
+		regs->dpi_resolution_reg = MIPIA_DPI_RESOLUTION_REG;
+		regs->hsync_count_reg = MIPIA_HORIZ_SYNC_PADDING_CNT;
+		regs->hbp_count_reg = MIPIA_HORIZ_BACK_PORCH_CNT;
+		regs->hfp_count_reg = MIPIA_HORIZ_FRONT_PORCH_CNT;
+		regs->hactive_count_reg = MIPIA_HORIZ_ACTIVE_AREA_CNT;
+		regs->vsync_count_reg = MIPIA_VERT_SYNC_PADDING_CNT;
+		regs->vbp_count_reg = MIPIA_VERT_BACK_PORCH_CNT;
+		regs->vfp_count_reg = MIPIA_VERT_FRONT_PORCH_CNT;
+		regs->high_low_switch_count_reg = MIPIA_HIGH_LOW_SWITCH_CNT;
+		regs->dpi_control_reg = MIPIA_DPI_CTRL_REG;
+		regs->dpi_data_reg = MIPIA_DPI_DATA_REG;
+		regs->init_count_reg = MIPIA_INIT_COUNT_REG;
+		regs->max_return_pack_size_reg = MIPIA_MAX_RETURN_PKT_SIZE_REG;
+		regs->video_mode_format_reg = MIPIA_VIDEO_MODE_FORMAT_REG;
+		regs->eot_disable_reg = MIPIA_EOT_DISABLE_REG;
+		regs->lp_byteclk_reg = MIPIA_LP_BYTECLK_REG;
+		regs->lp_gen_data_reg = MIPIA_LP_GEN_DATA_REG;
+		regs->hs_gen_data_reg = MIPIA_HS_GEN_DATA_REG;
+		regs->lp_gen_ctrl_reg = MIPIA_LP_GEN_CTRL_REG;
+		regs->hs_gen_ctrl_reg = MIPIA_HS_GEN_CTRL_REG;
+		regs->gen_fifo_stat_reg = MIPIA_GEN_FIFO_STAT_REG;
+		regs->hs_ls_dbi_enable_reg = MIPIA_HS_LS_DBI_ENABLE_REG;
+		regs->dphy_param_reg = MIPIA_DPHY_PARAM_REG;
+		regs->dbi_bw_ctrl_reg = MIPIA_DBI_BW_CTRL_REG;
+		regs->clk_lane_switch_time_cnt_reg =
+					MIPIA_CLK_LANE_SWITCHING_TIME_CNT;
+		regs->mipi_control_reg = MIPIA_CTRL;
+		regs->mipi_data_addr_reg = MIPIA_DATA_ADD;
+		regs->mipi_data_len_reg = MIPIA_DATA_LEN;
+		regs->mipi_cmd_addr_reg = MIPIA_CMD_ADD;
+		regs->mipi_cmd_len_reg = MIPIA_CMD_LEN;
+		break;
+	case 2:
+		regs->dspcntr_reg = DSPCCNTR;
+		regs->dspsize_reg = DSPCSIZE;
+		regs->dspsurf_reg = DSPCSURF;
+		regs->dsplinoff_reg = DSPCLINOFF;
+		regs->dsppos_reg = DSPCPOS;
+		regs->dspstride_reg = DSPCSTRIDE;
+		regs->color_coef_reg = PIPEC_COLOR_COEF0;
+		regs->htotal_reg = HTOTAL_C;
+		regs->hblank_reg = HBLANK_C;
+		regs->hsync_reg = HSYNC_C;
+		regs->vtotal_reg = VTOTAL_C;
+		regs->vblank_reg = VBLANK_C;
+		regs->vsync_reg = VSYNC_C;
+		regs->pipesrc_reg = SRCSZ_C;
+		regs->pipeconf_reg = PIPECCONF;
+		regs->pipestat_reg = PIPECSTAT;
+		regs->pipeframehigh_reg = PIPECFRAMEHIGH;
+		regs->pipeframepixel_reg = PIPECFRAMEPIXEL;
+		regs->mipi_reg = MIPIC_PORT_CTRL;
+		regs->palette_reg = PIPE_C_PALETTE;
+		regs->gamma_red_max_reg = GAMMA_RED_MAX_C;
+		regs->gamma_green_max_reg = GAMMA_GREEN_MAX_C;
+		regs->gamma_blue_max_reg = GAMMA_BLUE_MAX_C;
+
+		regs->device_ready_reg = MIPIC_DEVICE_READY;
+		regs->intr_stat_reg = MIPIC_INTR_STAT_REG;
+		regs->intr_en_reg = MIPIC_INTR_EN_REG;
+		regs->dsi_func_prg_reg = MIPIC_DSI_FUNC_PRG_REG;
+		regs->hs_tx_timeout_reg = MIPIC_HS_TX_TIMEOUT_REG;
+		regs->lp_rx_timeout_reg = MIPIC_LP_RX_TIMEOUT_REG;
+		regs->turn_around_timeout_reg = MIPIC_TURN_AROUND_TIMEOUT_REG;
+		regs->device_reset_timer_reg = MIPIC_DEVICE_RESET_TIMER;
+		regs->dpi_resolution_reg = MIPIC_DPI_RESOLUTION_REG;
+		regs->hsync_count_reg = MIPIC_HORIZ_SYNC_PADDING_CNT;
+		regs->hbp_count_reg = MIPIC_HORIZ_BACK_PORCH_CNT;
+		regs->hfp_count_reg = MIPIC_HORIZ_FRONT_PORCH_CNT;
+		regs->hactive_count_reg = MIPIC_HORIZ_ACTIVE_AREA_CNT;
+		regs->vsync_count_reg = MIPIC_VERT_SYNC_PADDING_CNT;
+		regs->vbp_count_reg = MIPIC_VERT_BACK_PORCH_CNT;
+		regs->vfp_count_reg = MIPIC_VERT_FRONT_PORCH_CNT;
+		regs->high_low_switch_count_reg = MIPIC_HIGH_LOW_SWITCH_CNT;
+		regs->dpi_control_reg = MIPIC_DPI_CTRL_REG;
+		regs->dpi_data_reg = MIPIC_DPI_DATA_REG;
+		regs->init_count_reg = MIPIC_INIT_COUNT_REG;
+		regs->max_return_pack_size_reg = MIPIC_MAX_RETURN_PKT_SIZE_REG;
+		regs->video_mode_format_reg = MIPIC_VIDEO_MODE_FORMAT_REG;
+		regs->eot_disable_reg = MIPIC_EOT_DISABLE_REG;
+		regs->lp_byteclk_reg = MIPIC_LP_BYTECLK_REG;
+		regs->lp_gen_data_reg = MIPIC_LP_GEN_DATA_REG;
+		regs->hs_gen_data_reg = MIPIC_HS_GEN_DATA_REG;
+		regs->lp_gen_ctrl_reg = MIPIC_LP_GEN_CTRL_REG;
+		regs->hs_gen_ctrl_reg = MIPIC_HS_GEN_CTRL_REG;
+		regs->gen_fifo_stat_reg = MIPIC_GEN_FIFO_STAT_REG;
+		regs->hs_ls_dbi_enable_reg = MIPIC_HS_LS_DBI_ENABLE_REG;
+		regs->dphy_param_reg = MIPIC_DPHY_PARAM_REG;
+		regs->dbi_bw_ctrl_reg = MIPIC_DBI_BW_CTRL_REG;
+		regs->clk_lane_switch_time_cnt_reg =
+					MIPIC_CLK_LANE_SWITCHING_TIME_CNT;
+		regs->mipi_control_reg = MIPIC_CTRL;
+		regs->mipi_data_addr_reg = MIPIC_DATA_ADD;
+		regs->mipi_data_len_reg = MIPIC_DATA_LEN;
+		regs->mipi_cmd_addr_reg = MIPIC_CMD_ADD;
+		regs->mipi_cmd_len_reg = MIPIC_CMD_LEN;
+		break;
+	default:
+		pr_err("%s: invalid index %d\n", __func__, idx);
+		return;
+	}
+}
+
+int dsi_config_init(struct dsi_config *config,
+			struct dsi_panel *panel, u8 idx)
+{
+	int err = 0;
+	struct panel_info pi;
+	struct drm_mode_modeinfo mode;
+
+	if (!config || !panel) {
+		pr_err("%s: invalid parameter\n", __func__);
+		err = -EINVAL;
+		goto out_err0;
+	}
+
+	if (!panel->ops) {
+		pr_err("%s: no panel ops found\n", __func__);
+		err = -EINVAL;
+		goto out_err0;
+	}
+
+	if (!panel->ops->get_panel_info) {
+		pr_err("%s: failed to get panel info\n", __func__);
+		err = -ENODEV;
+		goto out_err0;
+	}
+
+	if (!panel->ops->get_config_mode) {
+		pr_err("%s: panel doesn't have configured mode\n", __func__);
+		err = -ENODEV;
+		goto out_err0;
+	}
+
+	err = panel->ops->get_config_mode(&mode);
+	if (err) {
+		pr_err("%s: failed to get configured mode\n", __func__);
+		goto out_err0;
+	}
+
+	panel->ops->get_panel_info(&pi);
+
+	config->changed = 0;
+	config->channel_num = 0;
+	config->drv_ic_inited = 0;
+	config->enable_gamma_csc = 0;
+	config->video_mode = DSI_VIDEO_BURST_MODE;
+	config->bpp = pi.bpp;
+	config->lane_count = pi.lane_num;
+	config->type = pi.dsi_type;
+	config->dual_link = pi.dual_link;
+
+	memcpy(&config->perferred_mode, &mode, sizeof(mode));
+
+	/*init regs*/
+	dsi_regs_init(config, idx);
+
+	/*init context lock*/
+	mutex_init(&config->ctx_lock);
+
+	/*init DSR for DBI panels*/
+	/*
+	 if (config->type == DSI_DBI) {
+		dsi_dsr_init();
+	}
+	*/
+	return 0;
+out_err0:
+	return err;
+}
+
+void dsi_config_destroy(struct dsi_config *config)
+{
+
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_dbi.c b/drivers/video/adf/intel/core/common/dsi/dsi_dbi.c
new file mode 100644
index 0000000..6b363f4
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_dbi.c
@@ -0,0 +1,881 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_pipe.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "dsi_dbi.h"
+#include "pwr_mgmt.h"
+
+static void dbi_update_fb(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	struct dsi_config *config = &pipe->config;
+
+	if (!IS_ANN()) {
+		/* refresh plane changes */
+		REG_WRITE(dsplinoff_reg, REG_READ(dsplinoff_reg));
+		REG_WRITE(dspsurf_reg, REG_READ(dspsurf_reg));
+		REG_READ(dspsurf_reg);
+	}
+
+	if (is_dual_link(config))
+		dsi_send_dual_dcs(sender, write_mem_start, NULL, 0,
+				  CMD_DATA_SRC_PIPE, DSI_SEND_PACKAGE, true);
+	else
+		dsi_send_dcs(sender, write_mem_start, NULL, 0,
+			     CMD_DATA_SRC_PIPE, DSI_SEND_PACKAGE);
+}
+
+static int __dbi_enter_ulps_locked(struct dsi_pipe *pipe, int offset)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+
+	ctx->device_ready = REG_READ(regs->device_ready_reg + offset);
+
+	if ((offset == 0) && (ctx->device_ready & ULPS_STATE_MASK)) {
+		pr_err("%s:Broken ULPS states\n", __func__);
+		return -EINVAL;
+	}
+
+	if (offset != 0)
+		sender->work_for_slave_panel = true;
+
+	/*wait for all FIFOs empty*/
+	dsi_wait_for_fifos_empty(sender);
+	sender->work_for_slave_panel = false;
+
+	/*inform DSI host is to be put on ULPS*/
+	ctx->device_ready |= (ULPS_ENTER | DEVICE_READY);
+	REG_WRITE(regs->device_ready_reg + offset, ctx->device_ready);
+	mdelay(1);
+
+	/* set AFE hold value*/
+	REG_WRITE(regs->mipi_reg + offset,
+	     REG_READ(regs->mipi_reg + offset) & ~LP_OUTPUT_HOLD_ENABLE);
+
+	pr_debug("%s: entered ULPS state\n", __func__);
+
+	return 0;
+}
+
+static int __dbi_exit_ulps_locked(struct dsi_pipe *pipe, int offset)
+{
+	int tem = 0;
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+
+	ctx->device_ready = REG_READ(regs->device_ready_reg + offset);
+
+	/*inform DSI host is to be put on ULPS*/
+	ctx->device_ready |= (ULPS_ENTER | DEVICE_READY);
+	REG_WRITE(regs->device_ready_reg + offset, ctx->device_ready);
+
+	mdelay(1);
+	/* clear AFE hold value*/
+	if (offset != 0)
+		tem = 0x1000;
+	REG_WRITE(regs->mipi_reg + tem,
+		REG_READ(regs->mipi_reg + tem) | LP_OUTPUT_HOLD_ENABLE);
+
+	/*enter ULPS EXIT state*/
+	ctx->device_ready &= ~ULPS_STATE_MASK;
+	ctx->device_ready |= (ULPS_EXIT | DEVICE_READY);
+	REG_WRITE(regs->device_ready_reg + offset, ctx->device_ready);
+
+	/*wait for 1ms as spec suggests*/
+	mdelay(1);
+
+	/*clear ULPS state*/
+	ctx->device_ready &= ~ULPS_STATE_MASK;
+	ctx->device_ready |= DEVICE_READY;
+	REG_WRITE(regs->device_ready_reg + offset, ctx->device_ready);
+
+	mdelay(1);
+
+	pr_debug("%s: exited ULPS state\n", __func__);
+	return 0;
+}
+
+static void __dbi_set_properties(struct dsi_pipe *pipe,
+					enum enum_ports port)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+	int offset = 0;
+	u32 mipi_eot_disable_mask = 0;
+
+	if (port == PORT_C)
+		offset = MIPI_C_REG_OFFSET;
+	/*D-PHY parameter*/
+	REG_WRITE(regs->dphy_param_reg + offset, ctx->dphy_param);
+
+	/*Configure DSI controller*/
+	REG_WRITE(regs->mipi_control_reg + offset, ctx->mipi_control);
+	REG_WRITE(regs->intr_en_reg + offset, ctx->intr_en);
+	REG_WRITE(regs->hs_tx_timeout_reg + offset, ctx->hs_tx_timeout);
+	REG_WRITE(regs->lp_rx_timeout_reg + offset, ctx->lp_rx_timeout);
+	REG_WRITE(regs->turn_around_timeout_reg + offset,
+		ctx->turn_around_timeout);
+	REG_WRITE(regs->device_reset_timer_reg + offset,
+		ctx->device_reset_timer);
+	REG_WRITE(regs->high_low_switch_count_reg + offset,
+		ctx->high_low_switch_count);
+	REG_WRITE(regs->init_count_reg + offset, ctx->init_count);
+	mipi_eot_disable_mask = LP_RX_TIMEOUT_REC_DISABLE |
+		HS_TX_TIMEOUT_REC_DISABLE | LOW_CONTENTION_REC_DISABLE |
+		HIGH_CONTENTION_REC_DISABLE | TXDSI_TYPE_NOT_RECOG_REC_DISABLE |
+		TXECC_MULTIBIT_REC_DISABLE | CLOCK_STOP | EOT_DIS;
+	REG_WRITE(regs->eot_disable_reg + offset,
+			(REG_READ(regs->eot_disable_reg) &
+			 ~mipi_eot_disable_mask) |
+			(ctx->eot_disable & mipi_eot_disable_mask));
+	REG_WRITE(regs->lp_byteclk_reg + offset, ctx->lp_byteclk);
+	REG_WRITE(regs->clk_lane_switch_time_cnt_reg + offset,
+		ctx->clk_lane_switch_time_cnt);
+	REG_WRITE(regs->dsi_func_prg_reg + offset, ctx->dsi_func_prg);
+
+	/*DBI bw ctrl*/
+	REG_WRITE(regs->dbi_bw_ctrl_reg + offset, ctx->dbi_bw_ctrl);
+}
+
+static int __set_te(struct dsi_pipe *pipe, bool enabled)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	u8 idx = pipe->base.base.idx;
+	u32 event_bit = 0;
+
+	switch (idx) {
+	case 0:
+		event_bit = IIR_PIPEA_EVENT;
+		break;
+	case 2:
+		event_bit = IIR_PIPEC_EVENT;
+		break;
+	default:
+		pr_err("%s: invalid pipe index %d\n", __func__, idx);
+		return -EINVAL;
+	}
+
+	/* FIXME: add lock to avoid race condition for the 1st level IRQ. */
+
+	/* Enable/disable TE interrupt for DBI panel. */
+	if (enabled) {
+		REG_WRITE(IMR, REG_READ(IMR) & ~event_bit);
+		REG_WRITE(IER, REG_READ(IER) | event_bit);
+		REG_WRITE(regs->pipestat_reg,
+			REG_READ(regs->pipestat_reg) |
+			(TE_ENABLE | TE_STATUS));
+		REG_READ(regs->pipestat_reg);
+	} else {
+		/*
+		 * FIXME: keep 1st level interrupt on. To use get/put mechanism
+		 * to manage it if it's required to turn on/off the 1st level
+		 * interrupt dynamically.
+		 */
+/*
+		REG_WRITE(IMR, REG_READ(IMR) | event_bit);
+		REG_WRITE(IER, REG_READ(IER) & ~event_bit);
+*/
+		REG_WRITE(regs->pipestat_reg,
+			REG_READ(regs->pipestat_reg) & ~TE_ENABLE);
+		REG_READ(regs->pipestat_reg);
+	}
+
+	return 0;
+}
+
+/* dbi interface power on*/
+int dbi_power_on(struct dsi_pipe *pipe)
+{
+	u32 val = 0;
+	struct dsi_config *config;
+	struct dsi_registers *regs;
+	struct dsi_context *ctx;
+	int retry;
+	int err = 0;
+	u32 power_island = 0;
+	u32 sprite_reg_offset = 0;
+	int i = 0;
+	int offset = 0;
+
+	if (!pipe)
+		return -EINVAL;
+
+	config = &pipe->config;
+	regs = &config->regs;
+	ctx = &config->ctx;
+
+	power_island = pipe_to_island(pipe->base.base.idx);
+
+	if (power_island & (OSPM_DISPLAY_A | OSPM_DISPLAY_C))
+		power_island |= OSPM_DISPLAY_MIO;
+
+	if (is_dual_link(config))
+		power_island |= OSPM_DISPLAY_C;
+
+	if (!power_island_get(power_island))
+		return -EAGAIN;
+
+	if (!dsi_pipe_enable_clocking(pipe)) {
+		pr_err("%s: Failed to enable clocking for DSI.\n", __func__);
+		return -EAGAIN;
+	}
+
+	/*
+	 * Wait for DSI PLL locked on pipe, and only need to poll status of pipe
+	 * A as both MIPI pipes share the same DSI PLL.
+	 */
+	if (pipe->base.base.idx == 0) {
+		retry = 20000;
+		while (!(REG_READ(regs->pipeconf_reg) & PIPECONF_DSIPLL_LOCK) &&
+				--retry)
+			udelay(150);
+		if (!retry) {
+			pr_err("%s: PLL failed to lock on pipe\n", __func__);
+			err = -EAGAIN;
+			goto power_on_err;
+		}
+	}
+
+	if (IS_ANN()) {
+		/* FIXME: reset the DC registers for ANN A0 */
+		power_island_get(OSPM_DISPLAY_B | OSPM_DISPLAY_C);
+
+		REG_WRITE(DSPCLK_GATE_D, 0x0); /* 0x10000000 */
+		REG_WRITE(RAMCLK_GATE_D, 0xc0000); /* 0x0 */
+		REG_WRITE(PFIT_CONTROL, 0x20000000);
+		REG_WRITE(DSPIEDCFGSHDW, 0x0);
+		REG_WRITE(DSPARB2, 0x000A0200);
+		REG_WRITE(DSPARB, 0x18040080);
+		REG_WRITE(DSPFW1, 0x0F0F3F3F);
+		REG_WRITE(DSPFW2, 0x5F2F0F3F);
+		REG_WRITE(DSPFW3, 0x0);
+		REG_WRITE(DSPFW4, 0x07071F1F);
+		REG_WRITE(DSPFW5, 0x2F17071F);
+		REG_WRITE(DSPFW6, 0x00001F3F);
+		REG_WRITE(DSPFW7, 0x1F3F1F3F);
+		REG_WRITE(DSPSRCTRL, 0x00080100);
+		REG_WRITE(DSPCHICKENBIT, 0x20);
+		REG_WRITE(FBDC_CHICKEN, 0x0C0C0C0C);
+		REG_WRITE(CURACNTR, 0x0);
+		REG_WRITE(CURBCNTR, 0x0);
+		REG_WRITE(CURCCNTR, 0x0);
+		REG_WRITE(IEP_OVA_CTRL, 0x0);
+		REG_WRITE(IEP_OVA_CTRL, 0x0);
+		REG_WRITE(DSPACNTR, 0x0);
+		REG_WRITE(DSPBCNTR, 0x0);
+		REG_WRITE(DSPCCNTR, 0x0);
+		REG_WRITE(DSPDCNTR, 0x0);
+		REG_WRITE(DSPECNTR, 0x0);
+		REG_WRITE(DSPFCNTR, 0x0);
+
+		power_island_put(OSPM_DISPLAY_B | OSPM_DISPLAY_C);
+	}
+
+	/*exit ULPS*/
+	if (__dbi_exit_ulps_locked(pipe, 0)) {
+		pr_err("%s: Failed to exit ULPS\n", __func__);
+		goto power_on_err;
+	}
+	/*update MIPI port config*/
+	REG_WRITE(regs->mipi_reg, ctx->mipi |
+			 REG_READ(regs->mipi_reg));
+
+	/*unready dsi adapter for re-programming*/
+	REG_WRITE(regs->device_ready_reg,
+		REG_READ(regs->device_ready_reg) & ~DEVICE_READY);
+
+	if (is_dual_link(config)) {
+		if (__dbi_exit_ulps_locked(pipe, MIPI_C_REG_OFFSET)) {
+			pr_err("%s: Failed to exit ULPS\n", __func__);
+			goto power_on_err;
+		}
+		REG_WRITE(MIPIC_PORT_CTRL, ctx->mipi |
+			  REG_READ(MIPIC_PORT_CTRL));
+		/*unready dsi adapter for re-programming*/
+		offset = MIPI_C_REG_OFFSET;
+		REG_WRITE(regs->device_ready_reg + offset,
+			REG_READ(regs->device_ready_reg + offset) &
+			~DEVICE_READY);
+	}
+
+	/*
+	 * According to MIPI D-PHY spec, if clock stop feature is enabled (EOT
+	 * Disable), un-ready MIPI adapter needs to wait for 20 cycles from HS
+	 * to LP mode. Per calculation 1us is enough.
+	 */
+	if (ctx->eot_disable & CLOCK_STOP)
+		udelay(1);
+
+	__dbi_set_properties(pipe, PORT_A);
+
+	/*Setup pipe timing*/
+	REG_WRITE(regs->htotal_reg, ctx->htotal);
+	REG_WRITE(regs->hblank_reg, ctx->hblank);
+	REG_WRITE(regs->hsync_reg, ctx->hsync);
+	REG_WRITE(regs->vtotal_reg, ctx->vtotal);
+	REG_WRITE(regs->vblank_reg, ctx->vblank);
+	REG_WRITE(regs->vsync_reg, ctx->vsync);
+	REG_WRITE(regs->pipesrc_reg, ctx->pipesrc);
+	REG_WRITE(regs->dsppos_reg, ctx->dsppos);
+	REG_WRITE(regs->dspstride_reg, ctx->dspstride);
+
+	/*restore color_coef (chrome) */
+	for (i = 0; i < 6; i++)
+		REG_WRITE(regs->color_coef_reg + (i << 2), ctx->color_coef[i]);
+
+	/* restore palette (gamma) */
+	for (i = 0; i < 256; i++)
+		REG_WRITE(regs->palette_reg + (i << 2), ctx->palette[i]);
+
+	/*Setup plane*/
+	REG_WRITE(regs->dspsize_reg, ctx->dspsize);
+	REG_WRITE(regs->dspsurf_reg, ctx->dspsurf);
+	REG_WRITE(regs->dsplinoff_reg, ctx->dsplinoff);
+	REG_WRITE(regs->vgacntr_reg, ctx->vgacntr);
+
+	if (is_dual_link(config))
+		__dbi_set_properties(pipe, PORT_C);
+
+	/*enable plane*/
+	val = ctx->dspcntr | PRIMARY_PLANE_ENABLE;
+	REG_WRITE(regs->dspcntr_reg, val);
+
+	if (ctx->sprite_dspcntr & PRIMARY_PLANE_ENABLE) {
+		if (pipe->base.base.idx == 0)
+			sprite_reg_offset = SP_D_REG_OFFSET;
+		else if (pipe->base.base.idx == 2)
+			sprite_reg_offset = SP_B_REG_OFFSET;
+
+		/* Set up Sprite Plane */
+		REG_WRITE(regs->dspsize_reg + sprite_reg_offset,
+				ctx->sprite_dspsize);
+		REG_WRITE(regs->dspsurf_reg + sprite_reg_offset,
+				ctx->sprite_dspsurf);
+		REG_WRITE(regs->dsplinoff_reg + sprite_reg_offset,
+				ctx->sprite_dsplinoff);
+		REG_WRITE(regs->dsppos_reg + sprite_reg_offset,
+				ctx->sprite_dsppos);
+		REG_WRITE(regs->dspstride_reg + sprite_reg_offset,
+				ctx->sprite_dspstride);
+
+		/* enable plane */
+		REG_WRITE(regs->dspcntr_reg + sprite_reg_offset,
+				ctx->sprite_dspcntr);
+	}
+
+	/* Set up Overlay Plane */
+	if (ctx->ovaadd)
+		REG_WRITE(OVAADD, ctx->ovaadd);
+
+	if (ctx->ovcadd)
+		REG_WRITE(OVCADD, ctx->ovcadd);
+
+	/*ready dsi adapter*/
+	REG_WRITE(regs->device_ready_reg,
+		REG_READ(regs->device_ready_reg) | DEVICE_READY);
+	mdelay(1);
+
+	if (is_dual_link(config)) {
+		REG_WRITE(regs->device_ready_reg + offset,
+			REG_READ(regs->device_ready_reg + offset) |
+			DEVICE_READY);
+	}
+
+	if (IS_ANN()) {
+		REG_WRITE(regs->ddl1_reg, ctx->ddl1);
+		REG_WRITE(regs->ddl2_reg, ctx->ddl2);
+		REG_WRITE(regs->ddl3_reg, ctx->ddl3);
+		REG_WRITE(regs->ddl4_reg, ctx->ddl4);
+	}
+
+	/*Enable pipe*/
+	val = ctx->pipeconf;
+	val &= ~(SPRITE_OVERLAY_PLANES_OFF | CURSOR_PLANES_OFF);
+	val |= PIPEACONF_ENABLE | PIPEACONF_DSR;
+	REG_WRITE(regs->pipeconf_reg, val);
+
+	/*Wait for pipe enabling,when timing generator is working */
+	retry = 10000;
+	while (--retry && !(REG_READ(regs->pipeconf_reg) & PIPE_STATE_ENABLED))
+		udelay(3);
+
+	if (!retry) {
+		pr_err("Failed to enable pipe\n");
+		err = -EAGAIN;
+		goto power_on_err;
+	}
+
+	/*
+	 * FIXME: Enable TE to trigger "write_mem_start" issuing
+	 * in non-normal boot modes, and need to move to dbi_pipe_power_on
+	 * as TE enabling hasn't been done in HWC yet.
+	 */
+	__set_te(pipe, true);
+
+	return err;
+
+power_on_err:
+	power_island_put(power_island);
+	return err;
+}
+
+/**
+ * Power on sequence for command mode MIPI panel.
+ * NOTE: do NOT modify this function
+ */
+int dbi_pipe_power_on(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_pkg_sender *sender;
+	struct dsi_panel *panel;
+	struct dsi_registers *regs;
+	struct dsi_context *ctx;
+	int reset_count = 10;
+	int err = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI interface", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	sender = &pipe->sender;
+	regs = &config->regs;
+	ctx = &config->ctx;
+
+	panel = pipe->panel;
+	if (!panel || !panel->ops) {
+		pr_err("%s: invalid panel\n", __func__);
+		return -ENODEV;
+	}
+
+	dsi_dsr_forbid_locked(pipe);
+
+reset_recovery:
+	--reset_count;
+	err = 0;
+	/*after entering dstb mode, need reset*/
+	if (panel->ops->exit_deep_standby)
+		panel->ops->exit_deep_standby(pipe);
+
+	if (dbi_power_on(pipe)) {
+		pr_err("%s:Failed to init display controller!\n", __func__);
+		err = -EAGAIN;
+		goto power_on_err;
+	}
+
+	/**
+	 * Different panel may have different ways to have
+	 * drvIC initialized. Support it!
+	 */
+	if (panel->ops->drv_ic_init) {
+		if (panel->ops->drv_ic_init(pipe)) {
+			pr_err("%s: Failed to init drv IC!\n", __func__);
+			err = -EAGAIN;
+			goto power_on_err;
+		}
+	}
+
+	if (!IS_ANN())
+		dbi_update_fb(pipe);
+
+	/**
+	 * Different panel may have different ways to have
+	 * panel turned on. Support it!
+	 */
+	if (panel->ops->power_on)
+		if (panel->ops->power_on(pipe)) {
+			pr_err("%s: Failed to power on panel\n", __func__);
+			err = -EAGAIN;
+			goto power_on_err;
+		}
+	if (panel->ops->set_brightness) {
+		if (ctx->backlight_level <= 0)
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+			ctx->backlight_level = BRIGHTNESS_MAX_LEVEL;
+#else
+			ctx->backlight_level = 100;
+#endif
+
+		if (panel->ops->set_brightness(pipe, ctx->backlight_level))
+			pr_err("%s:Failed to set panel brightness\n", __func__);
+	}
+
+	/*wait for all FIFOs empty*/
+	dsi_wait_for_fifos_empty(sender);
+
+	if (is_dual_link(config)) {
+		sender->work_for_slave_panel = true;
+		dsi_wait_for_fifos_empty(sender);
+		sender->work_for_slave_panel = false;
+	}
+
+	if (IS_ANN())
+		dbi_update_fb(pipe);
+
+power_on_err:
+	if (err && reset_count) {
+		pr_err("Failed to init panel, try  reset it again!\n");
+		goto reset_recovery;
+	}
+	dsi_dsr_allow(pipe);
+	return err;
+}
+/**
+ * Power off sequence for DBI interface
+*/
+int dbi_power_off(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_registers *regs;
+	struct dsi_context *ctx;
+	int err = 0;
+	u32 power_island = 0;
+	int retry, i;
+	int offset = 0;
+	u32 val;
+
+	if (!pipe)
+		return -EINVAL;
+
+	config = &pipe->config;
+	regs = &config->regs;
+	ctx = &config->ctx;
+
+	ctx->dspcntr    = REG_READ(regs->dspcntr_reg);
+	ctx->pipeconf   = REG_READ(regs->pipeconf_reg);
+
+	/*save color_coef (chrome) */
+	for (i = 0; i < 6; i++)
+		ctx->color_coef[i] = REG_READ(regs->color_coef_reg + (i<<2));
+
+	/* save palette (gamma) */
+	for (i = 0; i < 256; i++)
+		ctx->palette[i] = REG_READ(regs->palette_reg + (i<<2));
+
+	/*Disable plane*/
+	val = ctx->dspcntr;
+	REG_WRITE(regs->dspcntr_reg, (val & ~PRIMARY_PLANE_ENABLE));
+
+	/* Disable pipe */
+	/* Don't disable DSR mode. */
+	REG_WRITE(regs->pipeconf_reg,
+		(REG_READ(regs->pipeconf_reg) & ~PIPEACONF_ENABLE));
+	/*
+	 * wait for pipe disabling,
+	 * pipe synchronization plus , only avaiable when
+	 * timer generator is working
+	 */
+	if (REG_READ(regs->mipi_reg) & MIPI_PORT_ENABLE) {
+		retry = 100000;
+		while (--retry && (REG_READ(regs->pipeconf_reg) &
+							PIPE_STATE_ENABLED))
+			udelay(5);
+
+		if (!retry) {
+			pr_err("Failed to disable pipe\n");
+			err = -EAGAIN;
+			goto power_off_err;
+		}
+	}
+	if (!is_dual_link(config)) {
+		/*enter ULPS*/
+		__dbi_enter_ulps_locked(pipe, offset);
+	} else {
+		/*Disable MIPI port*/
+		REG_WRITE(regs->mipi_reg,
+			(REG_READ(regs->mipi_reg) & ~MIPI_PORT_ENABLE));
+		/*clear Low power output hold*/
+		REG_WRITE(regs->mipi_reg,
+			(REG_READ(regs->mipi_reg) & ~LP_OUTPUT_HOLD_ENABLE));
+		/*Disable DSI controller*/
+		REG_WRITE(regs->device_ready_reg, (ctx->device_ready &
+						   ~DEVICE_READY));
+		/*enter ULPS*/
+		__dbi_enter_ulps_locked(pipe, offset);
+
+		/*Disable MIPI port*/
+		REG_WRITE(MIPIC_PORT_CTRL,
+			(REG_READ(MIPIC_PORT_CTRL) & ~MIPI_PORT_ENABLE));
+		/*clear Low power output hold*/
+		REG_WRITE(MIPIC_PORT_CTRL,
+			(REG_READ(MIPIC_PORT_CTRL) & ~LP_OUTPUT_HOLD_ENABLE));
+
+		offset = MIPI_C_REG_OFFSET;
+		/*Disable DSI controller*/
+		REG_WRITE(regs->device_ready_reg + offset,
+			(ctx->device_ready & ~DEVICE_READY));
+		/*enter ULPS*/
+		__dbi_enter_ulps_locked(pipe, offset);
+		offset = 0x0;
+	}
+
+	if (!dsi_pipe_disable_clocking(pipe)) {
+		pr_err("%s: Failed to disable clocking for DSI.\n", __func__);
+		err = -EAGAIN;
+		goto power_off_err;
+	}
+
+power_off_err:
+
+	power_island = pipe_to_island(pipe->base.base.idx);
+
+	if (power_island & (OSPM_DISPLAY_A | OSPM_DISPLAY_C))
+		power_island |= OSPM_DISPLAY_MIO;
+	if (is_dual_link(config))
+		power_island |= OSPM_DISPLAY_C;
+
+	if (!power_island_put(power_island))
+		return -EINVAL;
+
+	return err;
+}
+
+/**
+ * Power off sequence for command mode MIPI panel.
+ * NOTE: do NOT modify this function
+ */
+int dbi_pipe_power_off(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_panel *panel;
+	struct dsi_registers *regs;
+	struct dsi_context *ctx;
+	int err = 0;
+
+	if (!pipe)
+		return -EINVAL;
+
+	pr_debug("\n");
+
+	config = &pipe->config;
+	regs = &config->regs;
+	ctx = &config->ctx;
+
+	dsi_dsr_forbid_locked(pipe);
+
+	panel = pipe->panel;
+	if (!panel || !panel->ops) {
+		pr_err("%s: invalid panel\n", __func__);
+		return -ENODEV;
+	}
+
+	if (panel->ops->set_brightness)
+		if (panel->ops->set_brightness(pipe, 0))
+			pr_err("%s: Failed to set brightness\n", __func__);
+
+	/*wait for two TE, let pending PVR flip complete*/
+	/* FIXME: To Remove */
+	msleep(32);
+
+	/**
+	 * Different panel may have different ways to have
+	 * panel turned off. Support it!
+	 */
+	if (panel->ops->power_off) {
+		if (panel->ops->power_off(pipe)) {
+			pr_err("%s: Failed to power off panel\n", __func__);
+			err = -EAGAIN;
+			goto power_off_err;
+		}
+	}
+
+	/*power off dbi interface*/
+	dbi_power_off(pipe);
+
+power_off_err:
+	dsi_dsr_allow(pipe);
+	return err;
+}
+
+static int dbi_fillup_ctx(struct dsi_pipe *pipe,
+			struct drm_mode_modeinfo *mode)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_context *ctx = &config->ctx;
+	struct dsi_panel *panel = pipe->panel;
+	u16 hblank_start, hblank_end;
+	u16 vblank_start, vblank_end;
+	int hdelay;
+
+	/* FIXME: need to do same setting with drm_mode_set_crtcinfo(). */
+	hblank_start = min(mode->hdisplay, mode->hsync_start);
+	hblank_end = max(mode->htotal, mode->hsync_end);
+	vblank_start = min(mode->vdisplay, mode->vsync_start);
+	vblank_end = max(mode->vtotal, mode->vsync_end);
+
+	ctx->vgacntr = VGA_DISP_DISABLE;
+
+	/*set up pipe timings */
+
+	ctx->htotal =
+		(mode->hdisplay - 1) | ((mode->htotal - 1) << HORZ_TOTAL_SHIFT);
+	ctx->hblank =
+		(hblank_start - 1) | ((hblank_end - 1) << HORZ_BLANK_END_SHIFT);
+	ctx->hsync = (mode->hsync_start - 1) |
+		((mode->hsync_end - 1) << HORZ_SYNC_END_SHIFT);
+	ctx->vtotal =
+		(mode->vdisplay - 1) | ((mode->vtotal - 1) << VERT_TOTAL_SHIFT);
+	ctx->vblank =
+		(vblank_start - 1) | ((vblank_end - 1) << VERT_BLANK_END_SHIFT);
+	ctx->vsync = (mode->vsync_start - 1) |
+		((mode->vsync_end - 1) << VERT_SYNC_END_SHIFT);
+
+	/*pipe source */
+	ctx->pipesrc =
+		((mode->hdisplay - 1) << HORZ_SRC_SIZE_SHIFT) |
+					 (mode->vdisplay - 1);
+
+	/*setup dsp plane */
+	ctx->dsppos = 0;
+	/* PR2 panel has 200 pixel dummy clocks,
+	 * So the display timing should be 800x1024, and surface
+	 * is 608x1024(64 bits align), then the information between android
+	 * and Linux frame buffer is not consistent.
+	 */
+	if (panel->panel_id == TMD_6X10_VID)
+		ctx->dspsize = ((mode->vdisplay - 1) << HEIGHT_SHIFT) |
+		    (mode->hdisplay - 200 - 1);
+	else
+		ctx->dspsize = ((mode->vdisplay - 1) << HEIGHT_SHIFT) |
+		    (mode->hdisplay - 1);
+
+	/* FIXME: To make the aligned value DC independant. */
+	ctx->dspstride = ALIGN(mode->hdisplay * 4, 64);
+	ctx->dspsurf = 0;
+	ctx->dsplinoff = 0;
+	ctx->dspcntr = SRC_PIX_FMT_BGRX8888;
+
+	if (pipe->base.base.idx == 2)
+		ctx->dspcntr |= PIPE_SELECT_PIPEC;
+
+	/*
+	 * Setup pipe configuration for different panels
+	 * The formula recommended from hw team is as below:
+	 * (htotal * 5ns * hdelay) >= 8000ns
+	 * hdelay is the count of delayed HBLANK scan lines
+	 * And the max hdelay is 4
+	 * by programming of PIPE(A/C) CONF bit 28:27:
+	 * 00 = 1 scan line, 01 = 2 scan line,
+	 * 02 = 3 scan line, 03 = 4 scan line
+	 */
+	ctx->pipeconf &= ~FRAME_START_DELAY_MASK;
+
+	hdelay = 8000 / mode->htotal / 5;
+	if (8000 % (mode->htotal * 5) > 0)
+		hdelay += 1;
+
+	/* Use the max hdelay instead */
+	if (hdelay > 4)
+		hdelay = 4;
+
+	ctx->pipeconf |= ((hdelay - 1) << FRAME_START_DELAY_SHIFT);
+
+	/*setup deadline*/
+	ctx->ddl1 = 0x83838383;
+	ctx->ddl2 = 0x83838383;
+	ctx->ddl3 = 0x83;
+	ctx->ddl4 = 0x8383;
+
+	return 0;
+}
+
+int dbi_pipe_mode_set(struct dsi_pipe *pipe,
+			struct drm_mode_modeinfo *mode)
+{
+	if (!pipe || !mode) {
+		pr_err("%s: invalid parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	return dbi_fillup_ctx(pipe, mode);
+}
+
+void dbi_pipe_pre_post(struct dsi_pipe *pipe)
+{
+	dsi_dsr_forbid_locked(pipe);
+}
+
+void dbi_pipe_on_post(struct dsi_pipe *pipe)
+{
+	dbi_update_fb(pipe);
+}
+
+int dbi_pipe_set_event(struct dsi_pipe *pipe, u8 event, bool enabled)
+{
+	if (!pipe) {
+		pr_err("%s: invalid parameter\n", __func__);
+		return -EINVAL;
+	}
+
+	if (event != INTEL_PIPE_EVENT_VSYNC) {
+		pr_err("%s: unsupported event %u\n", __func__, event);
+		return -EINVAL;
+	}
+
+	pr_debug("%s: pipe %u, event = %u, enabled = %d\n", __func__,
+			pipe->base.base.idx, event, enabled);
+
+	return __set_te(pipe, enabled);
+}
+
+void dbi_pipe_get_events(struct dsi_pipe *pipe, u32 *events)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_dsr *dsr = (struct dsi_dsr *)config->dsr;
+	u32 pipe_stat = 0;
+	const int pipe_stat_cnt = 16;
+	int i = 0;
+
+	*events = 0;
+
+	/* Get the interrupt type via PIPESTAT */
+	pipe_stat = REG_READ(regs->pipestat_reg);
+	/* FIXME: to add lock */
+	/* Clear the 2nd level interrupt. */
+	REG_WRITE(regs->pipestat_reg, pipe_stat);
+
+	pr_debug("%s: pipestate = %#x\n", __func__, pipe_stat);
+
+	for (i = 0; i < pipe_stat_cnt; i++) {
+		switch (pipe_stat & (1 << i)) {
+		case TE_STATUS:
+			*events |= INTEL_PIPE_EVENT_VSYNC;
+			/* To report TE and allow DSR. */
+			/* It's better to be moved into handle_vsync_event(). */
+			if (dsr)
+				schedule_work(&dsr->te_work);
+			break;
+		/* TODO: to support more device custom events handling. */
+		case DPST_STATUS:
+		case REPEATED_FRAME_CNT_STATUS:
+		case MIPI_CMD_DONE_STATUS:
+		default:
+			break;
+		}
+	}
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_dbi.h b/drivers/video/adf/intel/core/common/dsi/dsi_dbi.h
new file mode 100644
index 0000000..051eaae
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_dbi.h
@@ -0,0 +1,35 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef DSI_DBI_H_
+#define DSI_DBI_H_
+
+#include "core/common/dsi/dsi_pipe.h"
+#include "core/common/dsi/dsi_dbi_dsr.h"
+
+extern int dbi_power_on(struct dsi_pipe *pipe);
+extern int dbi_power_off(struct dsi_pipe *pipe);
+extern int dbi_pipe_power_on(struct dsi_pipe *intf);
+extern int dbi_pipe_power_off(struct dsi_pipe *intf);
+extern int dbi_pipe_mode_set(struct dsi_pipe *intf,
+	struct drm_mode_modeinfo *mode);
+extern void dbi_pipe_pre_post(struct dsi_pipe *pipe);
+extern void dbi_pipe_on_post(struct dsi_pipe *pipe);
+extern int dbi_pipe_set_event(struct dsi_pipe *pipe, u8 event, bool enabled);
+extern void dbi_pipe_get_events(struct dsi_pipe *pipe, u32 *events);
+
+#endif /* DSI_DBI_H_ */
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_dbi_dsr.c b/drivers/video/adf/intel/core/common/dsi/dsi_dbi_dsr.c
new file mode 100644
index 0000000..20eae06
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_dbi_dsr.c
@@ -0,0 +1,352 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include "dsi_dbi.h"
+#include "core/common/dsi/dsi_dbi_dsr.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+
+/*
+ * Note: Don't modify/adjust DSR_COUNT.
+ *
+ * Some DC registers (DSPCNTR, SURFADDR, etc.) updating takes effect at the
+ * rising edge of next TE interrupt, so DC should enter DSR at the next next TE.
+ */
+#define DSR_COUNT 2
+
+static int __exit_dsr_locked(struct dsi_pipe *pipe)
+{
+	return dbi_power_on(pipe);
+}
+
+static int __enter_dsr_locked(struct dsi_pipe *pipe, int level)
+{
+	struct dsi_pkg_sender *sender = NULL;
+	int err = 0;
+
+	pr_debug("%s: enter dsr\n", __func__);
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	sender = &pipe->sender;
+
+	if (!sender) {
+		pr_err("Failed to get dsi sender\n");
+		return -EINVAL;
+	}
+
+	if (level < DSR_EXITED) {
+		pr_err("Invalid DSR level %d", level);
+		return -EINVAL;
+	}
+
+	pr_debug("%s: entering DSR level %d\n", __func__, level);
+
+	err = dsi_wait_for_fifos_empty(sender);
+	if (err) {
+		pr_err("%s: FIFO not empty\n", __func__);
+		return err;
+	}
+
+	/*turn off dbi interface put in ulps*/
+	dbi_power_off(pipe);
+
+	pr_debug("entered\n");
+	return 0;
+}
+
+int dsi_dsr_report_te(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = NULL;
+	struct dsi_dsr *dsr = NULL;
+	int err = 0;
+	int dsr_level;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	dsr = config->dsr;
+
+	/*if no dsr attached, return 0*/
+	if (!dsr)
+		return 0;
+
+	/*
+	 * Simply enter DSR LEVEL0 even if HDMI is connected,
+	 * to make MIO power island gated at least.
+	 */
+	dsr_level = DSR_ENTERED_LEVEL0;
+
+	mutex_lock(&config->ctx_lock);
+
+	if (!dsr->dsr_enabled)
+		goto report_te_out;
+
+	/*if panel is off, then forget it*/
+	/* FIXME: to check the interface's DPMS state. */
+
+	if (dsr_level <= dsr->dsr_state)
+		goto report_te_out;
+	else if (++dsr->free_count > DSR_COUNT && !dsr->ref_count) {
+		/*reset free count*/
+		dsr->free_count = 0;
+		/*enter dsr*/
+		err = __enter_dsr_locked(pipe, dsr_level);
+		if (err) {
+			pr_debug("Failed to enter DSR\n");
+			goto report_te_out;
+		}
+
+		dsr->dsr_state = dsr_level;
+	}
+report_te_out:
+	mutex_unlock(&config->ctx_lock);
+	return err;
+}
+
+int dsi_dsr_forbid_locked(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = NULL;
+	struct dsi_dsr *dsr = NULL;
+	int err = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	dsr = config->dsr;
+
+	/*if no dsr attached, return 0*/
+	if (!dsr)
+		return 0;
+
+	/*exit dsr if necessary*/
+	if (!dsr->dsr_enabled)
+		goto forbid_out;
+
+	pr_debug("%s\n", __func__);
+
+	/*if reference count is not 0, it means dsr was forbidden*/
+	if (dsr->ref_count) {
+		dsr->ref_count++;
+		goto forbid_out;
+	}
+
+	/*exited dsr if current dsr state is DSR_ENTERED*/
+	if (dsr->dsr_state > DSR_EXITED) {
+		err = __exit_dsr_locked(pipe);
+		if (err) {
+			pr_err("Failed to exit DSR\n");
+			goto forbid_out;
+		}
+		dsr->dsr_state = DSR_EXITED;
+	}
+	dsr->ref_count++;
+forbid_out:
+	return err;
+}
+
+int dsi_dsr_forbid(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = NULL;
+	int err = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&config->ctx_lock);
+	err = dsi_dsr_forbid_locked(pipe);
+	mutex_unlock(&config->ctx_lock);
+
+	return err;
+}
+
+int dsi_dsr_allow_locked(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = NULL;
+	struct dsi_dsr *dsr = NULL;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	dsr = config->dsr;
+
+	/*if no dsr attached, return 0*/
+	if (!dsr)
+		return 0;
+
+	if (!dsr->dsr_enabled)
+		goto allow_out;
+
+	if (!dsr->ref_count) {
+		pr_debug("Reference count is 0\n");
+		goto allow_out;
+	}
+
+	pr_debug("%s\n", __func__);
+
+	dsr->ref_count--;
+allow_out:
+	return 0;
+}
+
+int dsi_dsr_allow(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = NULL;
+	int err = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	if (!config)
+		return -EINVAL;
+
+	mutex_lock(&config->ctx_lock);
+	err = dsi_dsr_allow_locked(pipe);
+	mutex_unlock(&config->ctx_lock);
+
+	return err;
+}
+
+void dsi_dsr_enable(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = NULL;
+	struct dsi_dsr *dsr = NULL;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return;
+	}
+
+	dsr = config->dsr;
+
+	pr_debug("%s\n", __func__);
+
+	/*if no dsr attached, return 0*/
+	if (!dsr)
+		return;
+
+	/*lock dsr*/
+	mutex_lock(&config->ctx_lock);
+	dsr->dsr_enabled = 1;
+	dsr->dsr_state = DSR_EXITED;
+	mutex_unlock(&config->ctx_lock);
+}
+
+static void __dbi_dsr_te_work(struct work_struct *work)
+{
+	struct dsi_dsr *dsr = container_of(work, struct dsi_dsr, te_work);
+	struct dsi_config *config = (struct dsi_config *)dsr->config;
+	struct dsi_pipe *pipe = container_of(config, struct dsi_pipe, config);
+
+	dsi_dsr_report_te(pipe);
+	dsi_dsr_allow(pipe);
+}
+
+/**
+ * init dsr structure
+ */
+int dsi_dsr_init(struct dsi_pipe *pipe)
+{
+	struct dsi_dsr *dsr;
+
+	if (!pipe)
+		return -EINVAL;
+
+	dsr = kzalloc(sizeof(*dsr), GFP_KERNEL);
+	if (!dsr)
+		return -ENOMEM;
+
+	/*init reference count*/
+	dsr->ref_count = 0;
+
+	/*init free count*/
+	dsr->free_count = 0;
+
+	/*init dsr enabled*/
+	dsr->dsr_enabled = 0;
+
+	/*set dsr state*/
+	dsr->dsr_state = DSR_INIT;
+
+	/*init dsi config*/
+	dsr->config = &pipe->config;
+
+	pipe->config.dsr = dsr;
+
+	INIT_WORK(&dsr->te_work, __dbi_dsr_te_work);
+
+	return 0;
+}
+
+/**
+ * destroy dsr structure
+ */
+void dsi_dsr_destroy(struct dsi_config *config)
+{
+
+	if (config) {
+		kfree(config->dsr);
+		config->dsr = NULL;
+	}
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_dpi.c b/drivers/video/adf/intel/core/common/dsi/dsi_dpi.c
new file mode 100644
index 0000000..bda4d25
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_dpi.c
@@ -0,0 +1,1022 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_pipe.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "dsi_dpi.h"
+#include "pwr_mgmt.h"
+
+/* Try to enter MAXFIFO mode immediately. */
+#define REPEATED_FRM_CNT_THRESHHOLD 1
+
+static int __dpi_enter_ulps_locked(struct dsi_pipe *pipe, int offset)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+
+	if (!sender) {
+		pr_debug("pkg sender is NULL\n");
+		return -EINVAL;
+	}
+
+	ctx->device_ready = REG_READ(regs->device_ready_reg + offset);
+
+	if (ctx->device_ready & ULPS_STATE_MASK) {
+		pr_debug("Broken ULPS states\n");
+		return -EINVAL;
+	}
+
+	if (offset != 0)
+		sender->work_for_slave_panel = true;
+
+	/*wait for all FIFOs empty*/
+	dsi_wait_for_fifos_empty(sender);
+	sender->work_for_slave_panel = false;
+
+	/*inform DSI host is to be put on ULPS*/
+	ctx->device_ready |= ULPS_ENTER;
+	REG_WRITE(regs->device_ready_reg + offset, ctx->device_ready);
+
+	pr_debug("entered ULPS state\n");
+	return 0;
+}
+
+static int __dpi_exit_ulps_locked(struct dsi_pipe *pipe, int offset)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+
+	ctx->device_ready = REG_READ(regs->device_ready_reg + offset);
+
+	/*enter ULPS EXIT state*/
+	ctx->device_ready &= ~ULPS_STATE_MASK;
+	ctx->device_ready |= ULPS_EXIT;
+	REG_WRITE(regs->device_ready_reg + offset, ctx->device_ready);
+
+	/*wait for 1ms as spec suggests*/
+	mdelay(1);
+
+	/*clear ULPS state*/
+	ctx->device_ready &= ~ULPS_STATE_MASK;
+	REG_WRITE(regs->device_ready_reg + offset, ctx->device_ready);
+
+	pr_debug("exited ULPS state\n");
+	return 0;
+}
+
+static void __dpi_set_properties(struct dsi_pipe *pipe,
+		enum enum_ports port)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+	int offset = 0;
+	u32 mipi_eot_disable_mask = 0;
+
+	if (port == PORT_C)
+		offset = MIPI_C_REG_OFFSET;
+
+	/*D-PHY parameter*/
+	REG_WRITE(regs->dphy_param_reg + offset, ctx->dphy_param);
+
+	/*Configure DSI controller*/
+	REG_WRITE(regs->mipi_control_reg + offset, ctx->mipi_control);
+	REG_WRITE(regs->intr_en_reg + offset, ctx->intr_en);
+	REG_WRITE(regs->hs_tx_timeout_reg + offset, ctx->hs_tx_timeout);
+	REG_WRITE(regs->lp_rx_timeout_reg + offset, ctx->lp_rx_timeout);
+	REG_WRITE(regs->turn_around_timeout_reg + offset,
+			ctx->turn_around_timeout);
+	REG_WRITE(regs->device_reset_timer_reg + offset,
+			ctx->device_reset_timer);
+	REG_WRITE(regs->high_low_switch_count_reg + offset,
+			ctx->high_low_switch_count);
+	REG_WRITE(regs->init_count_reg + offset, ctx->init_count);
+	mipi_eot_disable_mask = LP_RX_TIMEOUT_REC_DISABLE |
+		HS_TX_TIMEOUT_REC_DISABLE | LOW_CONTENTION_REC_DISABLE |
+		HIGH_CONTENTION_REC_DISABLE | TXDSI_TYPE_NOT_RECOG_REC_DISABLE |
+		TXECC_MULTIBIT_REC_DISABLE | CLOCK_STOP | EOT_DIS;
+	REG_WRITE(regs->eot_disable_reg + offset,
+			(REG_READ(regs->eot_disable_reg) &
+			 ~mipi_eot_disable_mask) |
+			(ctx->eot_disable & mipi_eot_disable_mask));
+	REG_WRITE(regs->lp_byteclk_reg + offset, ctx->lp_byteclk);
+	REG_WRITE(regs->clk_lane_switch_time_cnt_reg + offset,
+			ctx->clk_lane_switch_time_cnt);
+	REG_WRITE(regs->video_mode_format_reg + offset, ctx->video_mode_format);
+	REG_WRITE(regs->dsi_func_prg_reg + offset, ctx->dsi_func_prg);
+
+	/*DSI timing*/
+	REG_WRITE(regs->dpi_resolution_reg + offset, ctx->dpi_resolution);
+	REG_WRITE(regs->hsync_count_reg + offset, ctx->hsync_count);
+	REG_WRITE(regs->hbp_count_reg + offset, ctx->hbp_count);
+	REG_WRITE(regs->hfp_count_reg + offset, ctx->hfp_count);
+	REG_WRITE(regs->hactive_count_reg + offset, ctx->hactive_count);
+	REG_WRITE(regs->vsync_count_reg + offset, ctx->vsync_count);
+	REG_WRITE(regs->vbp_count_reg + offset, ctx->vbp_count);
+	REG_WRITE(regs->vfp_count_reg + offset, ctx->vfp_count);
+}
+
+static int __dpi_config_port(struct dsi_pipe *pipe, enum enum_ports port)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+	int offset = 0;
+
+	if (port == PORT_C)
+		offset = MIPI_C_REG_OFFSET;
+
+	/*exit ULPS state*/
+	__dpi_exit_ulps_locked(pipe, offset);
+
+	/*Enable DSI Controller*/
+	REG_WRITE(regs->device_ready_reg + offset,
+		ctx->device_ready | DEVICE_READY);
+
+	/*set low power output hold*/
+	if (port == PORT_C)
+		offset = 0x1000;
+
+	REG_WRITE(regs->mipi_reg + offset, (ctx->mipi | LP_OUTPUT_HOLD_ENABLE));
+
+	return 0;
+}
+
+static int __set_vblank(struct dsi_pipe *pipe, bool enabled)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	u8 idx = pipe->base.base.idx;
+	u32 event_bit = 0;
+
+	switch (idx) {
+	case 0:
+		event_bit = IIR_PIPEA_EVENT;
+		break;
+	case 2:
+		event_bit = IIR_PIPEC_EVENT;
+		break;
+	default:
+		pr_err("%s: invalid pipe index %d\n", __func__, idx);
+		return -EINVAL;
+	}
+
+	/* FIXME: add lock to avoid race condition for the 1st level IRQ. */
+
+	/* Enable/disable Vblank interrupt for DPI panel. */
+	if (enabled) {
+		REG_WRITE(IMR, REG_READ(IMR) & ~event_bit);
+		REG_WRITE(IER, REG_READ(IER) | event_bit);
+		REG_WRITE(regs->pipestat_reg, REG_READ(regs->pipestat_reg) |
+				(VBLANK_ENABLE | VBLANK_STATUS));
+		REG_READ(regs->pipestat_reg);
+	} else {
+		/*
+		 * FIXME: keep 1st level interrupt on. To use get/put mechanism
+		 * to manage it if it's required to turn on/off the 1st level
+		 * interrupt dynamically.
+		 */
+/*
+		REG_WRITE(IMR, REG_READ(IMR) | event_bit);
+		REG_WRITE(IER, REG_READ(IER) & ~event_bit);
+*/
+		REG_WRITE(regs->pipestat_reg,
+			REG_READ(regs->pipestat_reg) & ~VBLANK_ENABLE);
+		REG_READ(regs->pipestat_reg);
+	}
+
+	return 0;
+}
+
+static int __set_repeated_frame(struct dsi_pipe *pipe, bool enabled)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	u8 idx = pipe->base.base.idx;
+	u32 event_bit = 0;
+	int repeated_frm_cnt_threshold = REPEATED_FRM_CNT_THRESHHOLD;
+
+	switch (idx) {
+	case 0:
+		event_bit = IIR_PIPEA_EVENT;
+		break;
+	case 2:
+		event_bit = IIR_PIPEC_EVENT;
+		break;
+	default:
+		pr_err("%s: invalid pipe index %d\n", __func__, idx);
+		return -EINVAL;
+	}
+
+	/* FIXME: add lock to avoid race condition for the 1st level IRQ. */
+
+	/* Enable/disable Repeated Frame interrupt for DPI panel. */
+	if (enabled) {
+		REG_WRITE(PIPE_A_CRC_CTRL_RED, ENBALE_CRC);
+		REG_WRITE(PIPEA_RPT_FRM_CNT_THRESHOLD,
+				RPT_FRAME_CNT_LOGIC_ENABLE |
+				repeated_frm_cnt_threshold);
+
+		REG_WRITE(IMR, REG_READ(IMR) & ~event_bit);
+		REG_WRITE(IER, REG_READ(IER) | event_bit);
+		REG_WRITE(regs->pipestat_reg,
+				REG_READ(regs->pipestat_reg) |
+				(REPEATED_FRAME_CNT_ENABLE |
+				 REPEATED_FRAME_CNT_STATUS));
+		REG_READ(regs->pipestat_reg);
+	} else {
+		/*
+		 * FIXME: keep 1st level interrupt on. To use get/put mechanism
+		 * to manage it if it's required to turn on/off the 1st level
+		 * interrupt dynamically.
+		 */
+/*
+		REG_WRITE(IMR, REG_READ(IMR) | event_bit);
+		REG_WRITE(IER, REG_READ(IER) & ~event_bit);
+*/
+		REG_WRITE(regs->pipestat_reg,
+				REG_READ(regs->pipestat_reg) &
+				~(REPEATED_FRAME_CNT_ENABLE));
+		REG_READ(regs->pipestat_reg);
+
+		REG_WRITE(PIPEA_RPT_FRM_CNT_THRESHOLD,
+				REG_READ(PIPEA_RPT_FRM_CNT_THRESHOLD) &
+				~RPT_FRAME_CNT_LOGIC_ENABLE);
+		REG_WRITE(PIPE_A_CRC_CTRL_RED,
+				REG_READ(PIPE_A_CRC_CTRL_RED) & ~ENBALE_CRC);
+	}
+
+	return 0;
+}
+
+static void ann_dc_setup(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	struct dsi_context *ctx = &config->ctx;
+
+	pr_debug("restore some registers to default value\n");
+
+	power_island_get(OSPM_DISPLAY_B | OSPM_DISPLAY_C);
+
+	REG_WRITE(DSPCLK_GATE_D, 0x0);
+	REG_WRITE(RAMCLK_GATE_D, DISABLE_CLKGATING_RDB | DISABLE_CLKGATING_OVR);
+	REG_WRITE(PFIT_CONTROL, PFIT_PIPE_SEL_B);
+	REG_WRITE(DSPIEDCFGSHDW, 0x0);
+	/* TODO: to figure out the watermark values. */
+	REG_WRITE(DSPARB2, 0x000A0200);
+	REG_WRITE(DSPARB, 0x18040080);
+	REG_WRITE(DSPFW1, 0x0F0F3F3F);
+	REG_WRITE(DSPFW2, 0x5F2F0F3F);
+	REG_WRITE(DSPFW3, 0x0);
+	REG_WRITE(DSPFW4, 0x07071F1F);
+	REG_WRITE(DSPFW5, 0x2F17071F);
+	REG_WRITE(DSPFW6, 0x00001F3F);
+	REG_WRITE(DSPFW7, 0x1F3F1F3F);
+	REG_WRITE(DSPSRCTRL, 0x00080100);
+	REG_WRITE(CHICKEN_BIT, PIPEA_PALETTE);
+	REG_WRITE(FBDC_CHICKEN, 0x0C0C0C0C);
+	REG_WRITE(CURACNTR, 0x0);
+	REG_WRITE(CURBCNTR, 0x0);
+	REG_WRITE(CURCCNTR, 0x0);
+	REG_WRITE(IEP_OVA_CTRL, 0x0);
+	REG_WRITE(IEP_OVA_CTRL, 0x0);
+	REG_WRITE(DSPACNTR, 0x0);
+	REG_WRITE(DSPBCNTR, 0x0);
+	REG_WRITE(DSPCCNTR, 0x0);
+	REG_WRITE(DSPDCNTR, 0x0);
+	REG_WRITE(DSPECNTR, 0x0);
+	REG_WRITE(DSPFCNTR, 0x0);
+
+	power_island_put(OSPM_DISPLAY_B | OSPM_DISPLAY_C);
+
+	pr_debug("setup drain latency\n");
+
+	REG_WRITE(regs->ddl1_reg, ctx->ddl1);
+	REG_WRITE(regs->ddl2_reg, ctx->ddl2);
+	REG_WRITE(regs->ddl3_reg, ctx->ddl3);
+	REG_WRITE(regs->ddl4_reg, ctx->ddl4);
+}
+
+/*
+ * Power on sequence for video mode MIPI panel.
+ * NOTE: do NOT modify this function
+ */
+int dpi_pipe_power_on(struct dsi_pipe *pipe)
+{
+	u32 val = 0;
+	struct dsi_config *config;
+	struct dsi_registers *regs;
+	struct dsi_context *ctx;
+	struct dsi_panel *panel;
+	int retry, reset_count = 10;
+	int i;
+	int err = 0;
+	u32 power_island = 0;
+	int offset = 0;
+
+	pr_debug("\n");
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	regs = &config->regs;
+	ctx = &config->ctx;
+
+	panel = pipe->panel;
+	if (!panel || !panel->ops) {
+		pr_err("%s: invalid panel\n", __func__);
+		return -ENODEV;
+	}
+
+	power_island = pipe_to_island(pipe->base.base.idx);
+
+	if (power_island & (OSPM_DISPLAY_A | OSPM_DISPLAY_C))
+		power_island |= OSPM_DISPLAY_MIO;
+
+	if (is_dual_link(config))
+		power_island |= OSPM_DISPLAY_C;
+
+	if (!power_island_get(power_island))
+		return -EAGAIN;
+
+	if (!dsi_pipe_enable_clocking(pipe)) {
+		pr_err("%s: Failed to enable clocking for DSI.\n", __func__);
+		return -EAGAIN;
+	}
+
+reset_recovery:
+	--reset_count;
+	/*HW-Reset*/
+	if (panel->ops->reset)
+		panel->ops->reset(pipe);
+
+	/*
+	 * Wait for DSI PLL locked on pipe, and only need to poll status of pipe
+	 * A as both MIPI pipes share the same DSI PLL.
+	 */
+	if (pipe->base.base.idx == 0) {
+		retry = 20000;
+		while (!(REG_READ(regs->pipeconf_reg) & PIPECONF_DSIPLL_LOCK) &&
+				--retry)
+			udelay(150);
+		if (!retry) {
+			pr_err("PLL failed to lock on pipe\n");
+			err = -EAGAIN;
+			goto power_on_err;
+		}
+	}
+
+	if (IS_ANN()) {
+		/* FIXME: reset the DC registers for ANN A0 */
+		ann_dc_setup(pipe);
+	}
+
+	__dpi_set_properties(pipe, PORT_A);
+
+	/*Setup pipe timing*/
+	REG_WRITE(regs->htotal_reg, ctx->htotal);
+	REG_WRITE(regs->hblank_reg, ctx->hblank);
+	REG_WRITE(regs->hsync_reg, ctx->hsync);
+	REG_WRITE(regs->vtotal_reg, ctx->vtotal);
+	REG_WRITE(regs->vblank_reg, ctx->vblank);
+	REG_WRITE(regs->vsync_reg, ctx->vsync);
+	REG_WRITE(regs->pipesrc_reg, ctx->pipesrc);
+
+	REG_WRITE(regs->dsppos_reg, ctx->dsppos);
+	REG_WRITE(regs->dspstride_reg, ctx->dspstride);
+
+	/*Setup plane*/
+	REG_WRITE(regs->dspsize_reg, ctx->dspsize);
+	REG_WRITE(regs->dspsurf_reg, ctx->dspsurf);
+	REG_WRITE(regs->dsplinoff_reg, ctx->dsplinoff);
+	REG_WRITE(regs->vgacntr_reg, ctx->vgacntr);
+
+	/*restore color_coef (chrome) */
+	for (i = 0; i < 6; i++)
+		REG_WRITE(regs->color_coef_reg + (i << 2), ctx->color_coef[i]);
+
+	/* restore palette (gamma) */
+	for (i = 0; i < 256; i++)
+		REG_WRITE(regs->palette_reg + (i << 2), ctx->palette[i]);
+
+	/* restore dpst setting */
+	/*
+	   if (dev_priv->psb_dpst_state) {
+	   dpstmgr_reg_restore_locked(dev, dsi_config);
+	   psb_enable_pipestat(dev_priv, 0, PIPE_DPST_EVENT_ENABLE);
+	   }
+	 */
+
+	if (__dpi_config_port(pipe, PORT_A) != 0) {
+		if (!reset_count) {
+			err = -EAGAIN;
+			goto power_on_err;
+		}
+		pr_err("Failed to init dsi controller, reset it!\n");
+		goto reset_recovery;
+	}
+
+	if (is_dual_link(config)) {
+		__dpi_set_properties(pipe, PORT_C);
+		__dpi_config_port(pipe, PORT_C);
+	}
+
+	/**
+	 * Different panel may have different ways to have
+	 * drvIC initialized. Support it!
+	 */
+	if (panel->ops->drv_ic_init) {
+		if (panel->ops->drv_ic_init(pipe)) {
+			if (!reset_count) {
+				err = -EAGAIN;
+				goto power_on_err;
+			}
+
+			pr_err("Failed to init dsi controller, reset it!\n");
+			goto reset_recovery;
+		}
+	}
+
+	/*Enable MIPI Port A*/
+	offset = 0x0;
+	REG_WRITE(regs->mipi_reg + offset, (ctx->mipi | MIPI_PORT_ENABLE));
+	REG_WRITE(regs->dpi_control_reg + offset, TURN_ON);
+	if (is_dual_link(config)) {
+		/*Enable MIPI Port C*/
+		REG_WRITE(MIPIC_PORT_CTRL, (ctx->mipi | MIPI_PORT_ENABLE));
+		offset = MIPI_C_REG_OFFSET;
+		REG_WRITE(regs->dpi_control_reg + offset, TURN_ON);
+	}
+
+	/**
+	 * Different panel may have different ways to have
+	 * panel turned on. Support it!
+	 */
+	if (panel->ops->power_on)
+		if (panel->ops->power_on(pipe)) {
+			pr_err("Failed to power on panel\n");
+			err = -EAGAIN;
+			goto power_on_err;
+		}
+
+	if (IS_ANN()) {
+		REG_WRITE(regs->ddl1_reg, ctx->ddl1);
+		REG_WRITE(regs->ddl2_reg, ctx->ddl2);
+		REG_WRITE(regs->ddl3_reg, ctx->ddl3);
+		REG_WRITE(regs->ddl4_reg, ctx->ddl4);
+	}
+
+	/*Enable pipe*/
+	val = ctx->pipeconf;
+	val &= ~(SPRITE_OVERLAY_PLANES_OFF | CURSOR_PLANES_OFF);
+
+	/**
+	 * Frame Start occurs on third HBLANK
+	 * after the start of VBLANK
+	 */
+	val |= PIPEACONF_ENABLE | FRAME_START_DELAY_THIRD;
+	REG_WRITE(regs->pipeconf_reg, val);
+
+	/*Wait for pipe enabling,when timing generator
+	  is wroking */
+	if (REG_READ(regs->mipi_reg) & MIPI_PORT_ENABLE) {
+		retry = 10000;
+		while (--retry && !(REG_READ(regs->pipeconf_reg) &
+					     PIPE_STATE_ENABLED))
+			udelay(3);
+
+		if (!retry) {
+			pr_err("Failed to enable pipe\n");
+			err = -EAGAIN;
+			goto power_on_err;
+		}
+	}
+
+	/*enable plane*/
+	val = ctx->dspcntr | PRIMARY_PLANE_ENABLE;
+	REG_WRITE(regs->dspcntr_reg, val);
+
+	if (panel->ops->set_brightness) {
+		if (ctx->backlight_level <= 0)
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+			ctx->backlight_level = BRIGHTNESS_MAX_LEVEL;
+#else
+			ctx->backlight_level = 100;
+#endif
+
+		if (panel->ops->set_brightness(pipe, ctx->backlight_level))
+			pr_err("Failed to set panel brightness\n");
+	} else {
+		pr_err("Failed to set panel brightness\n");
+	}
+
+	if (panel->ops->drv_set_panel_mode)
+		panel->ops->drv_set_panel_mode(pipe);
+
+	/* FIXME: To remove it after HWC enables vsync event setting. */
+	__set_vblank(pipe, true);
+
+	return err;
+
+power_on_err:
+	power_island_put(power_island);
+	return err;
+}
+
+/*
+ * Power off sequence for video mode MIPI panel.
+ * NOTE: do NOT modify this function
+ */
+int dpi_pipe_power_off(struct dsi_pipe *pipe)
+{
+	u32 val = 0;
+	u32 tmp = 0;
+	struct dsi_config *config;
+	struct dsi_panel *panel;
+	struct dsi_registers *regs;
+	struct dsi_context *ctx;
+	int retry;
+	int i;
+	int err = 0;
+	u32 power_island = 0;
+	int offset = 0;
+
+	pr_debug("\n");
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	regs = &config->regs;
+	ctx = &config->ctx;
+
+	panel = pipe->panel;
+	if (!panel || !panel->ops) {
+		pr_err("%s: invalid panel\n", __func__);
+		return -ENODEV;
+	}
+
+	tmp = REG_READ(regs->pipeconf_reg);
+	ctx->dspcntr = REG_READ(regs->dspcntr_reg);
+
+	/*save color_coef (chrome) */
+	for (i = 0; i < 6; i++)
+		ctx->color_coef[i] = REG_READ(regs->color_coef_reg + (i << 2));
+
+	/* save palette (gamma) */
+	for (i = 0; i < 256; i++)
+		ctx->palette[i] = REG_READ(regs->palette_reg + (i << 2));
+
+	/*
+	 * Couldn't disable the pipe until DRM_WAIT_ON signaled by last
+	 * vblank event when playing video, otherwise the last vblank event
+	 * will lost when pipe disabled before vblank interrupt coming
+	 * sometimes.
+	 */
+
+	/*Disable panel*/
+	val = ctx->dspcntr;
+	REG_WRITE(regs->dspcntr_reg, (val & ~PRIMARY_PLANE_ENABLE));
+	/*Disable overlay & cursor panel assigned to this pipe*/
+	REG_WRITE(regs->pipeconf_reg,
+		(tmp | SPRITE_OVERLAY_PLANES_OFF | CURSOR_PLANES_OFF));
+
+	/*Disable pipe*/
+	val = REG_READ(regs->pipeconf_reg);
+	ctx->pipeconf = val;
+	REG_WRITE(regs->pipeconf_reg, (val & ~PIPEACONF_ENABLE));
+
+	/*wait for pipe disabling,
+	  pipe synchronization plus , only avaiable when
+	  timer generator is working*/
+	if (REG_READ(regs->mipi_reg) & MIPI_PORT_ENABLE) {
+		retry = 100000;
+		while (--retry && (REG_READ(regs->pipeconf_reg) &
+					    PIPE_STATE_ENABLED))
+			udelay(5);
+
+		if (!retry) {
+			pr_err("Failed to disable pipe\n");
+			/*
+			 * FIXME: turn off the power island directly
+			 * although failed to disable pipe.
+			 */
+			err = 0;
+			goto power_off_err;
+		}
+	}
+
+	/**
+	 * Different panel may have different ways to have
+	 * panel turned off. Support it!
+	 */
+	if (panel->ops->power_off) {
+		if (panel->ops->power_off(pipe)) {
+			pr_err("Failed to power off panel\n");
+			err = -EAGAIN;
+			goto power_off_err;
+		}
+	}
+
+	/*Disable MIPI port*/
+	REG_WRITE(regs->mipi_reg, (REG_READ(regs->mipi_reg) &
+				   ~MIPI_PORT_ENABLE));
+
+	/*clear Low power output hold*/
+	REG_WRITE(regs->mipi_reg,
+		(REG_READ(regs->mipi_reg) & ~LP_OUTPUT_HOLD_ENABLE));
+
+	/*Disable DSI controller*/
+	REG_WRITE(regs->device_ready_reg, (ctx->device_ready & ~DEVICE_READY));
+
+	/*enter ULPS*/
+	__dpi_enter_ulps_locked(pipe, offset);
+
+	if (is_dual_link(config)) {
+		offset = 0x1000;
+		/*Disable MIPI port*/
+		REG_WRITE(MIPIC_PORT_CTRL,
+			(REG_READ(MIPIC_PORT_CTRL) & ~MIPI_PORT_ENABLE));
+		/*clear Low power output hold*/
+		REG_WRITE(MIPIC_PORT_CTRL,
+			(REG_READ(MIPIC_PORT_CTRL) & ~LP_OUTPUT_HOLD_ENABLE));
+
+		offset = MIPI_C_REG_OFFSET;
+		/*Disable DSI controller*/
+		REG_WRITE(regs->device_ready_reg + offset,
+				(ctx->device_ready & ~DEVICE_READY));
+
+		/*enter ULPS*/
+		__dpi_enter_ulps_locked(pipe, offset);
+		offset = 0x0;
+	}
+
+	if (!dsi_pipe_disable_clocking(pipe)) {
+		pr_err("%s: Failed to disable clocking for DSI.\n", __func__);
+		err = -EAGAIN;
+		goto power_off_err;
+	}
+
+power_off_err:
+	power_island = pipe_to_island(pipe->base.base.idx);
+
+	if (power_island & (OSPM_DISPLAY_A | OSPM_DISPLAY_C))
+		power_island |= OSPM_DISPLAY_MIO;
+
+	if (is_dual_link(config))
+		power_island |= OSPM_DISPLAY_C;
+
+	if (!power_island_put(power_island))
+		return -EINVAL;
+
+	return err;
+}
+
+static u16 dpi_to_byte_clock_count(int pixel_clock_count, int num_lane, int bpp)
+{
+	return (u16)((pixel_clock_count * bpp) / (num_lane * 8));
+}
+
+/*
+ * Calculate the dpi time basing on a given drm mode @mode
+ * return 0 on success.
+ * FIXME: I was using proposed mode value for calculation, may need to
+ * use crtc mode values later
+ */
+static int dpi_timing_calculation(struct dsi_pipe *pipe,
+		struct drm_mode_modeinfo *mode,
+		struct dpi_timing *dpi_timing,
+		int num_lane, int bpp)
+{
+	struct dsi_config *config = &pipe->config;
+	int pclk_hsync, pclk_hfp, pclk_hbp, pclk_hactive;
+	int pclk_vsync, pclk_vfp, pclk_vbp;
+
+	if (!mode || !dpi_timing) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	pr_debug("pclk %d, hdisplay %d, hsync_start %d, hsync_end %d, htotal %d\n",
+			mode->clock, mode->hdisplay, mode->hsync_start,
+			mode->hsync_end, mode->htotal);
+	pr_debug("vdisplay %d, vsync_start %d, vsync_end %d, vtotal %d\n",
+			mode->vdisplay, mode->vsync_start,
+			mode->vsync_end, mode->vtotal);
+
+	pclk_hactive = mode->hdisplay;
+	pclk_hfp = mode->hsync_start - mode->hdisplay;
+	pclk_hsync = mode->hsync_end - mode->hsync_start;
+	pclk_hbp = mode->htotal - mode->hsync_end;
+
+	pclk_vfp = mode->vsync_start - mode->vdisplay;
+	pclk_vsync = mode->vsync_end - mode->vsync_start;
+	pclk_vbp = mode->vtotal - mode->vsync_end;
+	/*
+	 * byte clock counts were calculated by following formula
+	 * bclock_count = pclk_count * bpp / num_lane / 8
+	 */
+	if (is_dual_link(config)) {
+		dpi_timing->hsync_count = pclk_hsync;
+		dpi_timing->hbp_count = pclk_hbp;
+		dpi_timing->hfp_count = pclk_hfp;
+		dpi_timing->hactive_count = pclk_hactive / 2;
+		dpi_timing->vsync_count = pclk_vsync;
+		dpi_timing->vbp_count = pclk_vbp;
+		dpi_timing->vfp_count = pclk_vfp;
+	} else {
+		dpi_timing->hsync_count =
+			dpi_to_byte_clock_count(pclk_hsync, num_lane, bpp);
+		dpi_timing->hbp_count =
+			dpi_to_byte_clock_count(pclk_hbp, num_lane, bpp);
+		dpi_timing->hfp_count =
+			dpi_to_byte_clock_count(pclk_hfp, num_lane, bpp);
+		dpi_timing->hactive_count =
+			dpi_to_byte_clock_count(pclk_hactive, num_lane, bpp);
+
+		dpi_timing->vsync_count =
+			dpi_to_byte_clock_count(pclk_vsync, num_lane, bpp);
+		dpi_timing->vbp_count =
+			dpi_to_byte_clock_count(pclk_vbp, num_lane, bpp);
+		dpi_timing->vfp_count =
+			dpi_to_byte_clock_count(pclk_vfp, num_lane, bpp);
+	}
+
+	pr_debug("DPI timings: %d, %d, %d, %d, %d, %d, %d\n",
+			dpi_timing->hsync_count, dpi_timing->hbp_count,
+			dpi_timing->hfp_count, dpi_timing->hactive_count,
+			dpi_timing->vsync_count, dpi_timing->vbp_count,
+			dpi_timing->vfp_count);
+
+	return 0;
+}
+
+/*
+ * Setup DPI timing for video mode MIPI panel.
+ * NOTE: do NOT modify this function
+ */
+static void dpi_set_timing(struct dsi_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	struct dpi_timing dpi_timing;
+	struct dsi_config *config = &pipe->config;
+	struct dsi_context *ctx = &config->ctx;
+
+	/*dpi resolution*/
+	if (is_dual_link(config))
+		ctx->dpi_resolution =
+			(mode->vdisplay << VERT_ADDR_SHIFT |
+			(mode->hdisplay / 2));
+	else
+		ctx->dpi_resolution =
+			(mode->vdisplay << VERT_ADDR_SHIFT | mode->hdisplay);
+
+	/*Calculate DPI timing*/
+	dpi_timing_calculation(pipe, mode, &dpi_timing,
+			config->lane_count, config->bpp);
+
+	/*update HW context with new DPI timings*/
+	ctx->hsync_count = dpi_timing.hsync_count;
+	ctx->hbp_count = dpi_timing.hbp_count;
+	ctx->hfp_count = dpi_timing.hfp_count;
+	ctx->hactive_count = dpi_timing.hactive_count;
+	ctx->vsync_count = dpi_timing.vsync_count;
+	ctx->vbp_count = dpi_timing.vbp_count;
+	ctx->vfp_count = dpi_timing.vfp_count;
+}
+
+static int dpi_fillup_ctx(struct dsi_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_context *ctx = &config->ctx;
+	struct dsi_panel *panel = pipe->panel;
+	u16 hblank_start, hblank_end;
+	u16 vblank_start, vblank_end;
+	int hdelay;
+
+	/* FIXME: need to do same setting with drm_mode_set_crtcinfo(). */
+	hblank_start = min(mode->hdisplay, mode->hsync_start);
+	hblank_end = max(mode->htotal, mode->hsync_end);
+	vblank_start = min(mode->vdisplay, mode->vsync_start);
+	vblank_end = max(mode->vtotal, mode->vsync_end);
+
+	ctx->vgacntr = VGA_DISP_DISABLE;
+
+	/*set up pipe timings */
+
+	ctx->htotal =
+		(mode->hdisplay - 1) | ((mode->htotal - 1) << HORZ_TOTAL_SHIFT);
+	ctx->hblank =
+		(hblank_start - 1) | ((hblank_end - 1) << HORZ_BLANK_END_SHIFT);
+	ctx->hsync =
+		(mode->hsync_start - 1) |
+		((mode->hsync_end - 1) << HORZ_SYNC_END_SHIFT);
+	ctx->vtotal =
+		(mode->vdisplay - 1) | ((mode->vtotal - 1) << VERT_TOTAL_SHIFT);
+	ctx->vblank =
+		(vblank_start - 1) | ((vblank_end - 1) << VERT_BLANK_END_SHIFT);
+	ctx->vsync =
+		(mode->vsync_start - 1) |
+		((mode->vsync_end - 1) << VERT_SYNC_END_SHIFT);
+
+	/*pipe source */
+	ctx->pipesrc =
+		((mode->hdisplay - 1) << HORZ_SRC_SIZE_SHIFT) |
+		(mode->vdisplay - 1);
+
+	/*setup dsp plane */
+	ctx->dsppos = 0;
+	/* PR2 panel has 200 pixel dummy clocks,
+	 * So the display timing should be 800x1024, and surface
+	 * is 608x1024(64 bits align), then the information between android
+	 * and Linux frame buffer is not consistent.
+	 */
+	if (panel->panel_id == TMD_6X10_VID)
+		ctx->dspsize = ((mode->vdisplay - 1) << HEIGHT_SHIFT) |
+			(mode->hdisplay - 200 - 1);
+	else
+		ctx->dspsize = ((mode->vdisplay - 1) << HEIGHT_SHIFT) |
+			(mode->hdisplay - 1);
+
+	/* FIXME: To make the aligned value DC independant. */
+	ctx->dspstride = ALIGN(mode->hdisplay * 4, 64);
+	ctx->dspsurf = 0;
+	ctx->dsplinoff = 0;
+	ctx->dspcntr = SRC_PIX_FMT_BGRX8888;
+
+	if (pipe->base.base.idx == 2)
+		ctx->dspcntr |= PIPE_SELECT_PIPEC;
+
+	/*
+	 * Setup pipe configuration for different panels
+	 * The formula recommended from hw team is as below:
+	 * (htotal * 5ns * hdelay) >= 8000ns
+	 * hdelay is the count of delayed HBLANK scan lines
+	 * And the max hdelay is 4
+	 * by programming of PIPE(A/C) CONF bit 28:27:
+	 * 00 = 1 scan line, 01 = 2 scan line,
+	 * 02 = 3 scan line, 03 = 4 scan line
+	 */
+	ctx->pipeconf &= ~FRAME_START_DELAY_MASK;
+
+	hdelay = 8000 / mode->htotal / 5;
+	if (8000 % (mode->htotal * 5) > 0)
+		hdelay += 1;
+
+	/* Use the max hdelay instead */
+	if (hdelay > 4)
+		hdelay = 4;
+
+	ctx->pipeconf |= ((hdelay - 1) << FRAME_START_DELAY_SHIFT);
+
+	/*setup deadline*/
+	ctx->ddl1 = 0x83838383;
+	ctx->ddl2 = 0x83838383;
+	ctx->ddl3 = 0x83;
+	ctx->ddl4 = 0x8383;
+
+	dpi_set_timing(pipe, mode);
+
+	return 0;
+}
+
+int dpi_pipe_mode_set(struct dsi_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	if (!pipe || !mode) {
+		pr_err("%s: invalid parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	return dpi_fillup_ctx(pipe, mode);
+}
+
+void dpi_pipe_pre_post(struct dsi_pipe *pipe)
+{
+	dsi_sdo_forbid(pipe);
+}
+
+int dpi_pipe_set_event(struct dsi_pipe *pipe, u8 event, bool enabled)
+{
+	int ret = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid parameter\n", __func__);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	pr_debug("%s: pipe %u, event = %u, enabled = %d\n", __func__,
+			pipe->base.base.idx, event, enabled);
+
+	switch (event) {
+	case INTEL_PIPE_EVENT_VSYNC:
+		ret = __set_vblank(pipe, enabled);
+		break;
+	case INTEL_PIPE_EVENT_REPEATED_FRAME:
+		ret = __set_repeated_frame(pipe, enabled);
+		break;
+	default:
+		pr_err("%s: unsupported event %u\n", __func__, event);
+		ret = -EINVAL;
+		goto err;
+	}
+
+err:
+	return ret;
+}
+
+void dpi_pipe_get_events(struct dsi_pipe *pipe, u32 *events)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_registers *regs = &config->regs;
+	u32 pipe_stat = 0;
+	const int pipe_stat_cnt = 16;
+	int i = 0;
+
+	*events = 0;
+
+	/* Get the interrupt type via PIPESTAT */
+	pipe_stat = REG_READ(regs->pipestat_reg);
+	/* FIXME: to add lock */
+	/* Clear the 2nd level interrupt. */
+	REG_WRITE(regs->pipestat_reg, pipe_stat);
+
+	pr_debug("%s: pipestate = %#x\n", __func__, pipe_stat);
+
+	for (i = 0; i < pipe_stat_cnt; i++) {
+		switch (pipe_stat & (1 << i)) {
+		case VBLANK_STATUS:
+			*events |= INTEL_PIPE_EVENT_VSYNC;
+			break;
+		case REPEATED_FRAME_CNT_STATUS:
+			*events |= INTEL_PIPE_EVENT_REPEATED_FRAME;
+			break;
+		/* TODO: to support more device custom events handling. */
+		case DPST_STATUS:
+		case MIPI_CMD_DONE_STATUS:
+		default:
+			break;
+		}
+	}
+}
+
+void dpi_pipe_handle_events(struct dsi_pipe *pipe, u32 events)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_panel *panel = pipe->panel;
+	struct dsi_sdo *sdo = NULL;
+
+	if (!config || !panel) {
+		pr_err("%s: invalid arguments", __func__);
+		return;
+	}
+
+	if ((panel->info.dsi_type != DSI_DPI) || (!pipe->base.primary)) {
+		pr_debug("%s: Repeated Frame interrupt should be only asserted"
+				"for video mode panel via Pipe A.\n", __func__);
+		return;
+	}
+
+	if (events & INTEL_PIPE_EVENT_REPEATED_FRAME) {
+		/*
+		 * Note: the Repeated Frame interrupt should have been disabled
+		 * when entering MAXFIFO mode, but we disable it at the top half
+		 * of IRQ handler because it's asserted too much frequently
+		 * (~14ns) so that the work couldn't be scheduled normally
+		 * later.
+		 */
+		dpi_pipe_set_event(pipe, INTEL_PIPE_EVENT_REPEATED_FRAME,
+				   false);
+
+		sdo = (struct dsi_sdo *)config->sdo;
+		if (sdo)
+			schedule_work(&sdo->repeated_frm_work);
+	}
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_dpi.h b/drivers/video/adf/intel/core/common/dsi/dsi_dpi.h
new file mode 100644
index 0000000..fa511d8
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_dpi.h
@@ -0,0 +1,42 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#ifndef DSI_DPI_H_
+#define DSI_DPI_H_
+
+#include "core/common/dsi/dsi_pipe.h"
+#include "core/common/dsi/dsi_dpi_sdo.h"
+
+struct dpi_timing {
+	u16 hsync_count;
+	u16 hbp_count;
+	u16 hfp_count;
+	u16 hactive_count;
+	u16 vsync_count;
+	u16 vbp_count;
+	u16 vfp_count;
+};
+
+extern int dpi_pipe_power_on(struct dsi_pipe *pipe);
+extern int dpi_pipe_power_off(struct dsi_pipe *pipe);
+extern int dpi_pipe_mode_set(struct dsi_pipe *pipe,
+		struct drm_mode_modeinfo *mode);
+extern void dpi_pipe_pre_post(struct dsi_pipe *pipe);
+extern int dpi_pipe_set_event(struct dsi_pipe *pipe, u8 event, bool enabled);
+extern void dpi_pipe_get_events(struct dsi_pipe *pipe, u32 *events);
+extern void dpi_pipe_handle_events(struct dsi_pipe *pipe, u32 events);
+
+#endif /* DSI_DPI_H_ */
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_dpi_sdo.c b/drivers/video/adf/intel/core/common/dsi/dsi_dpi_sdo.c
new file mode 100644
index 0000000..dd5faf5
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_dpi_sdo.c
@@ -0,0 +1,456 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include "core/common/dsi/dsi_dpi_sdo.h"
+
+#define SDO_COUNT 0
+
+static bool sdo_unsupported_plane(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_registers *regs;
+	u32 plane_val = 0;
+	u32 plane_d_offset = SP_D_REG_OFFSET;
+	u32 plane_offset = SP_REG_OFFSET;
+	/* FIXME: Anniedale has another 3 Sprite Planes attached to Pipe A. */
+	int num_sprite = 3;
+	/*
+	 * FIXME: Anniedale has 2 Overlay Planes
+	 * which can be attached to Pipe A.
+	 */
+	int num_ov = 2;
+	u32 ov_a_offset = 0;
+	u32 ov_plane_offset = OV_C_REG_OFFSET;
+	int i = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return false;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return false;
+	}
+
+	regs = &config->regs;
+	if (!regs) {
+		pr_err("%s: invalid DC registers", __func__);
+		return false;
+	}
+
+	/* Check whether there is any Sprite Plane attached to Pipe A. */
+	for (i = plane_d_offset;
+			i < (plane_d_offset + num_sprite * plane_offset);
+			i += plane_offset) {
+		plane_val = REG_READ(regs->dspcntr_reg + i);
+		if ((plane_val & PRIMARY_PLANE_ENABLE) &&
+				((plane_val & PIPE_SELECT_MASK) ==
+				 PIPE_SELECT_FIXED))
+			return true;
+	}
+
+	/* Check whether there is any Sprite Plane attached to Pipe A. */
+	for (i = ov_a_offset; i < (ov_a_offset + num_ov * ov_plane_offset);
+			i += ov_plane_offset) {
+		/* FIXME: Anniedale supports SDO mode with Overlay Plane A. */
+		if (i == ov_a_offset)
+			continue;
+
+		plane_val = REG_READ(regs->ovaadd_reg + i);
+		if ((plane_val & OV_ENABLE) &&
+				((plane_val & OV_PIPE_SELECT_MASK) ==
+				 OV_ASSIGN_TO_PIPE_A))
+			return true;
+	}
+
+	return false;
+}
+
+static void sdo_event_notify(struct dsi_pipe *pipe)
+{
+	pr_debug("Generating invalidate event to HWC/SF\n");
+
+	/*
+	 * FIXME: to invoke adf_event_notify(),
+	 * or wake up the event polling thread.
+	 */
+}
+
+static int exit_sdo(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	u8 event = INTEL_PIPE_EVENT_UNKNOWN;
+	u32 pwr_cur = 0;
+	int retry = 0;
+	int err = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	/* Note: ideally to invoke adf_event_get(). */
+	/* Enable the Repeated Frame interrupt. */
+	event = INTEL_PIPE_EVENT_REPEATED_FRAME;
+	if (pipe->ops.set_event)
+		pipe->ops.set_event(pipe, event, true);
+
+	/* Exit S0i1-Display On state. */
+	/* Notify P-Unit to disable S0i1-Display On mode. */
+	pwr_cur = intel_mid_msgbus_read32(PUNIT_PORT, DSP_SS_PM);
+	pwr_cur &= ~PUNIT_SDO_ENABLE;
+	intel_mid_msgbus_write32(PUNIT_PORT, DSP_SS_PM, pwr_cur);
+
+	/* Disable the MAXFIFO mode. */
+	REG_WRITE(DSPSRCTRL, REG_READ(DSPSRCTRL) & ~MAXFIFO_ENABLE);
+
+	retry = 32;
+	while (--retry && (REG_READ(DSPSRCTRL) & MAXFIFO_STATUS))
+		usleep_range(1000, 1500);
+
+	if (!retry)
+		pr_err("Failed to exit from MAXFIFO mode.\n");
+
+	if (!(REG_READ(DSPSRCTRL) & MAXFIFO_STATUS))
+		pr_debug("Exited from MAXFIFO mode.\n");
+
+	return err;
+}
+
+static int enter_sdo(struct dsi_pipe *pipe, int level)
+{
+	struct dsi_config *config;
+	u32 pwr_cur = 0;
+	int retry = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	pr_debug("Enter SDO\n");
+
+	if (level < SDO_EXITED) {
+		pr_err("%s: incorrect sdo level %d", __func__, level);
+		return -EINVAL;
+	}
+
+	if (sdo_unsupported_plane(pipe)) {
+		/*
+		 * Notify HWC/SF to composite layers into frame buffer
+		 * (YUV layer can be attached with Overlay A for ANN).
+		 */
+		pr_debug("%s: Issuing invalidate UEvent\n", __func__);
+		sdo_event_notify(pipe);
+		return 0;
+	}
+
+	/* Enter S0i1-Display On state. */
+	/* Notify P-Unit to enable S0i1-Display On mode. */
+	pwr_cur = intel_mid_msgbus_read32(PUNIT_PORT, DSP_SS_PM);
+	pwr_cur |= PUNIT_SDO_ENABLE;
+	intel_mid_msgbus_write32(PUNIT_PORT, DSP_SS_PM, pwr_cur);
+
+	/* Enable the MAXFIFO mode, with specified watermarks. */
+	REG_WRITE(DSPSRCTRL, MAXFIFO_ENABLE |
+			(SPRITE_PLANE_A_WM1 << MAXFIFO_WM1_SHIFT) |
+			(SPRITE_PLANE_A_WM0 << MAXFIFO_WM_SHIFT));
+
+	retry = 32;
+	while (--retry && (!(REG_READ(DSPSRCTRL) & MAXFIFO_STATUS)))
+		usleep_range(1000, 1500);
+
+	if (!retry)
+		pr_err("Failed to enter MAXFIFO mode.\n");
+
+	if (REG_READ(DSPSRCTRL) & MAXFIFO_STATUS)
+		pr_debug("Entered MAXFIFO mode.\n");
+
+	return 0;
+}
+
+int dsi_report_repeated_frame(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_sdo *sdo;
+	int sdo_level = SDO_INIT;
+	int err = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	sdo = config->sdo;
+	if (!sdo)
+		return 0;
+
+	sdo_level = SDO_ENTERED_LEVEL0;
+
+	mutex_lock(&config->ctx_lock);
+
+	if (!sdo->sdo_enabled)
+		goto repeated_frame_out;
+
+	/* FIXME: if panel is off, then ignore it */
+
+	/*
+	 * To enter MAXFIFO mode ASAP, because the Repeated Frame interrupt has
+	 * been disabled at top half of IRQ handler, and the work couldn't be
+	 * scheduled any more.
+	 */
+	if (sdo_level <= sdo->sdo_state)
+		goto repeated_frame_out;
+	else if (++sdo->free_count > SDO_COUNT && sdo->ref_count > 0) {
+		/* reset free count */
+		sdo->free_count = 0;
+		/* enter SDO */
+		err = enter_sdo(pipe, sdo_level);
+		if (err) {
+			pr_debug("Failed to enter SDO\n");
+			goto repeated_frame_out;
+		}
+		sdo->sdo_state = sdo_level;
+		sdo->ref_count = 0;
+	}
+repeated_frame_out:
+	mutex_unlock(&config->ctx_lock);
+	return err;
+}
+
+int dsi_sdo_forbid(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_sdo *sdo;
+	int err = 0;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	sdo = config->sdo;
+	if (!sdo)
+		return 0;
+
+	mutex_lock(&config->ctx_lock);
+
+	/*exit SDO if necessary*/
+	if (!sdo->sdo_enabled)
+		goto forbid_out;
+
+	pr_debug("\n");
+
+	/*if reference count is not 0, it means SDO was forbidden*/
+	if (sdo->ref_count) {
+		sdo->ref_count++;
+		goto forbid_out;
+	}
+
+	/*exited SDO if current SDO state is SDO_ENTERED*/
+	if ((sdo->sdo_state > SDO_EXITED) || (sdo->sdo_state == SDO_INIT)) {
+		err = exit_sdo(pipe);
+		if (err) {
+			pr_err("Failed to exit SDO\n");
+			goto forbid_out;
+		}
+		sdo->sdo_state = SDO_EXITED;
+	}
+
+	sdo->ref_count++;
+forbid_out:
+	mutex_unlock(&config->ctx_lock);
+	return err;
+}
+
+int dsi_sdo_allow(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_sdo *sdo;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return -EINVAL;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return -EINVAL;
+	}
+
+	sdo = config->sdo;
+	if (!sdo)
+		return 0;
+
+	mutex_lock(&config->ctx_lock);
+
+	if (!sdo->sdo_enabled)
+		goto allow_out;
+
+	if (!sdo->ref_count)
+		goto allow_out;
+
+	pr_debug("\n");
+
+	sdo->ref_count--;
+allow_out:
+	mutex_unlock(&config->ctx_lock);
+	return 0;
+}
+
+void dsi_sdo_enable(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_sdo *sdo;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return;
+	}
+
+	pr_debug("\n");
+
+	sdo = config->sdo;
+	if (!sdo)
+		return;
+
+	mutex_lock(&config->ctx_lock);
+	sdo->sdo_enabled = 1;
+	mutex_unlock(&config->ctx_lock);
+}
+
+void dsi_sdo_disable(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config;
+	struct dsi_sdo *sdo;
+
+	if (!pipe) {
+		pr_err("%s: invalid DSI pipe", __func__);
+		return;
+	}
+
+	config = &pipe->config;
+	if (!config) {
+		pr_err("%s: invalid DSI config", __func__);
+		return;
+	}
+
+	pr_debug("\n");
+
+	sdo = config->sdo;
+	if (!sdo)
+		return;
+
+	mutex_lock(&config->ctx_lock);
+	sdo->sdo_enabled = 0;
+	sdo->ref_count = 0;
+	sdo->free_count = 0;
+	sdo->sdo_state = SDO_INIT;
+	mutex_unlock(&config->ctx_lock);
+}
+
+static void __dpi_sdo_repeated_frame_work(struct work_struct *work)
+{
+	struct dsi_sdo *sdo =
+		container_of(work, struct dsi_sdo, repeated_frm_work);
+	struct dsi_config *config = (struct dsi_config *)sdo->config;
+	struct dsi_pipe *pipe = container_of(config, struct dsi_pipe, config);
+
+	dsi_report_repeated_frame(pipe);
+}
+
+/**
+ * Init SDO structure
+ */
+int dsi_sdo_init(struct dsi_pipe *pipe)
+{
+	struct dsi_sdo *sdo;
+
+	pr_debug("\n");
+
+	if (!pipe) {
+		pr_err("%s: invalid arguments", __func__);
+		return -EINVAL;
+	}
+
+	sdo = kzalloc(sizeof(struct dsi_sdo), GFP_KERNEL);
+	if (!sdo) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	/*set SDO state*/
+	sdo->sdo_state = SDO_INIT;
+
+	/*init DSI config*/
+	sdo->config = &pipe->config;
+
+	pipe->config.sdo = sdo;
+
+	INIT_WORK(&sdo->repeated_frm_work, __dpi_sdo_repeated_frame_work);
+
+	return 0;
+}
+
+/**
+ * destroy SDO structure
+ */
+void dsi_sdo_destroy(struct dsi_config *config)
+{
+	struct dsi_sdo *sdo;
+
+	pr_debug("\n");
+
+	if (config) {
+		sdo = config->sdo;
+		kfree(sdo);
+		config->sdo = NULL;
+	}
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_panel.c b/drivers/video/adf/intel/core/common/dsi/dsi_panel.c
new file mode 100644
index 0000000..68d817f
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_panel.c
@@ -0,0 +1,66 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include "core/common/dsi/dsi_panel.h"
+
+extern int PanelID;
+/*declare get panel callbacks*/
+extern const struct dsi_panel *cmi_get_panel(void);
+extern struct dsi_panel *jdi_cmd_get_panel(void);
+extern struct dsi_panel *jdi_vid_get_panel(void);
+extern struct dsi_panel *sharp_10x19_cmd_get_panel(void);
+extern struct dsi_panel *sharp_10x19_dual_cmd_get_panel(void);
+extern struct dsi_panel *sharp_25x16_vid_get_panel(void);
+extern struct dsi_panel *sharp_25x16_cmd_get_panel(void);
+
+struct supported_panel_item {
+	u8 id;
+	const struct dsi_panel* (*get_panel)(void);
+};
+
+static const struct supported_panel_item supported_panels[] = {
+	{CMI_7x12_CMD, cmi_get_panel},
+	{JDI_7x12_CMD, jdi_cmd_get_panel},
+	{JDI_7x12_VID, jdi_vid_get_panel},
+	{SHARP_10x19_CMD, sharp_10x19_cmd_get_panel},
+	{SHARP_10x19_DUAL_CMD, sharp_10x19_dual_cmd_get_panel},
+	{SHARP_25x16_VID, sharp_25x16_vid_get_panel},
+	{SHARP_25x16_CMD, sharp_25x16_cmd_get_panel},
+};
+
+const struct dsi_panel *get_dsi_panel_by_id(u8 id)
+{
+	int i;
+
+	if (id == GCT_DETECT) {
+		pr_err("%s: invalid panel id\n", __func__);
+		return NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(supported_panels); i++) {
+		if (id == supported_panels[i].id)
+			return supported_panels[i].get_panel();
+	}
+
+	return NULL;
+}
+
+const struct dsi_panel *get_dsi_panel(void)
+{
+
+	return get_dsi_panel_by_id((u8)PanelID);
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_pipe.c b/drivers/video/adf/intel/core/common/dsi/dsi_pipe.c
new file mode 100644
index 0000000..b6478ef
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_pipe.c
@@ -0,0 +1,811 @@
+/*
+ * ann_dsi_pipe.c
+ *
+ *  Created on: May 23, 2014
+ *      Author: root
+ */
+
+#include <drm/drm_mode.h>
+
+#include "core/common/dsi/dsi_pipe.h"
+#include "core/common/dsi/dsi_dbi.h"
+#include "core/common/dsi/dsi_dpi.h"
+
+#define KSEL_CRYSTAL_19 1
+#define KSEL_BYPASS_19 5
+#define KSEL_BYPASS_25 6
+#define KSEL_BYPASS_83_100 7
+
+#define MRFLD_M_MIN	    21
+#define MRFLD_M_MAX	    180
+static const u32 mrfld_m_converts[] = {
+	/* M configuration table from 9-bit LFSR table */
+	224, 368, 440, 220, 366, 439, 219, 365, 182, 347,	/* 21 - 30 */
+	173, 342, 171, 85, 298, 149, 74, 37, 18, 265,	/* 31 - 40 */
+	388, 194, 353, 432, 216, 108, 310, 155, 333, 166,	/* 41 - 50 */
+	83, 41, 276, 138, 325, 162, 337, 168, 340, 170,	/* 51 - 60 */
+	341, 426, 469, 234, 373, 442, 221, 110, 311, 411,	/* 61 - 70 */
+	461, 486, 243, 377, 188, 350, 175, 343, 427, 213,	/* 71 - 80 */
+	106, 53, 282, 397, 354, 227, 113, 56, 284, 142,	/* 81 - 90 */
+	71, 35, 273, 136, 324, 418, 465, 488, 500, 506,	/* 91 - 100 */
+	253, 126, 63, 287, 399, 455, 483, 241, 376, 444,	/* 101 - 110 */
+	478, 495, 503, 251, 381, 446, 479, 239, 375, 443,	/* 111 - 120 */
+	477, 238, 119, 315, 157, 78, 295, 147, 329, 420,	/* 121 - 130 */
+	210, 105, 308, 154, 77, 38, 275, 137, 68, 290,	/* 131 - 140 */
+	145, 328, 164, 82, 297, 404, 458, 485, 498, 249,	/* 141 - 150 */
+	380, 190, 351, 431, 471, 235, 117, 314, 413, 206,	/* 151 - 160 */
+	103, 51, 25, 12, 262, 387, 193, 96, 48, 280,	/* 161 - 170 */
+	396, 198, 99, 305, 152, 76, 294, 403, 457, 228,	/* 171 - 180 */
+};
+
+struct clock_info {
+	int dot;
+	/* Multiplier */
+	int m;
+	/* Post divisor */
+	int p1;
+};
+
+static bool get_ref_clock(struct intel_pipe *pipe, int ksel,
+		int core_freq, int *ref_clk, int *clk_n, int *clk_p2)
+{
+	if (!pipe) {
+		pr_err("%s: invalid pipe\n", __func__);
+		return false;
+	}
+
+	switch (ksel) {
+	case KSEL_CRYSTAL_19:
+	case KSEL_BYPASS_19:
+		*ref_clk = 19200;
+
+		if (pipe->primary)
+			*clk_n = 1, *clk_p2 = 8;
+		else
+			*clk_n = 1, *clk_p2 = 10;
+		break;
+	case KSEL_BYPASS_25:
+		*ref_clk = 25000;
+
+		if (pipe->primary)
+			*clk_n = 1, *clk_p2 = 8;
+		else
+			*clk_n = 1, *clk_p2 = 10;
+		break;
+	case KSEL_BYPASS_83_100:
+		if (core_freq == 166)
+			*ref_clk = 83000;
+		else if (core_freq == 100 || core_freq == 200)
+			*ref_clk = 100000;
+
+		if (pipe->primary)
+			*clk_n = 4, *clk_p2 = 8;
+		else
+			*clk_n = 4, *clk_p2 = 10;
+		break;
+	default:
+		pr_err("%s: invalid reference clock.\n", __func__);
+		return false;
+	}
+
+	return true;
+}
+
+static int dsi_pipe_setup_clocking(struct intel_pipe *pipe, int pixel_clk)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *ctx = &config->ctx;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	int ref_clk = 0, clk_n = 0, clk_p2 = 0, byte_clk = 1, clk_tmp = 0;
+	int m_conv = 0;
+	u32 pll = 0, fp = 0;
+	struct clock_info clock;
+
+	if (!get_ref_clock(pipe, KSEL_CRYSTAL_19, 200, &ref_clk,
+			   &clk_n, &clk_p2)) {
+		pr_err("%s: failed to get reference clock\n", __func__);
+		return -EINVAL;
+	}
+
+	if (pipe->primary)
+		byte_clk = 3;
+
+	clk_tmp = pixel_clk * clk_n * clk_p2 * byte_clk;
+
+	/*
+	 * FIXME: Hard code the divisors' value for JDI panel, and need to
+	 * calculate them according to the DSI PLL HAS spec.
+	 */
+	memset(&clock, 0, sizeof(clock));
+	switch (panel->panel_id) {
+	case JDI_7x12_CMD:
+		/* JDI 7x12 CMD */
+		clock.dot = 576000;
+		clock.p1 = 4;
+		clock.m = 142;
+		break;
+	case JDI_7x12_VID:
+		/* JDI 7x12 VID */
+		clock.dot = 576000;
+		clock.p1 = 5;
+		clock.m = 130;
+		break;
+	case SHARP_10x19_CMD:
+		/* Sharp 10x19 CMD */
+		clock.dot = 801600;
+		clock.p1 = 3;
+		clock.m = 137;
+		break;
+	case SHARP_10x19_DUAL_CMD:
+		/* Sharp 10x19 DUAL CMD */
+		/* FIXME */
+		clock.dot = 801600;
+		clock.p1 = 3;
+		clock.m = 125;
+		break;
+	case SHARP_25x16_VID:
+		/* Sharp 25x16 VID */
+		clock.dot = 0;
+		clock.p1 = 3;
+		clock.m = 140;
+		break;
+	case SHARP_25x16_CMD:
+		/* Sharp 25x16 CMD */
+		clock.dot = 0;
+		clock.p1 = 3;
+		clock.m = 138;
+		break;
+	default:
+		pr_err("%s: unsupported panel %u\n", __func__, panel->panel_id);
+		return -EOPNOTSUPP;
+	}
+
+	m_conv = mrfld_m_converts[(clock.m - MRFLD_M_MIN)];
+
+	/* Write the N1 & M1 parameters into DSI_PLL_DIV_REG */
+	fp = (clk_n / 2) << 16;
+	fp |= m_conv;
+
+	if (pipe->primary) {
+		/* Enable DSI PLL clocks for DSI0 rather than CCK. */
+		pll |= _CLK_EN_PLL_DSI0;
+		pll &= ~_CLK_EN_CCK_DSI0;
+		/* Select DSI PLL as the source of the mux input clocks. */
+		pll &= ~_DSI_MUX_SEL_CCK_DSI0;
+	} else
+		pll |= VCO_SELECT_83_3_MHZ_REF_CLK;
+
+	/* FIXME: consider dual panels. */
+	/* if (is_mipi2 || is_dual_dsi(dev)) { */
+	if (is_dual_link(config)) {
+		/* Enable DSI PLL clocks for DSI1 rather than CCK. */
+		pll |= _CLK_EN_PLL_DSI1;
+		pll &= ~_CLK_EN_CCK_DSI1;
+		/* Select DSI PLL as the source of the mux input clocks. */
+		pll &= ~_DSI_MUX_SEL_CCK_DSI1;
+	}
+
+	/* compute bitmask from p1 value */
+	pll |= (1 << (clock.p1 - 2)) << _P1_POST_DIV_SHIFT;
+
+	if (pipe->primary) {
+		ctx->dpll = pll;
+		ctx->fp = fp;
+	}
+
+	return 0;
+}
+
+bool dsi_pipe_enable_clocking(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = &pipe->config;
+	struct dsi_context *ctx = &config->ctx;
+	u32 gunit_val = 0x0;
+	u32 retry;
+
+	if (IS_ANN())
+		intel_mid_msgbus_write32(CCK_PORT,
+				FUSE_OVERRIDE_FREQ_CNTRL_REG5,
+				CKESC_GATE_EN | CKDP1X_GATE_EN |
+				DISPLAY_FRE_EN | 0x2);
+
+	/* Prepare DSI  PLL register before enabling */
+	intel_mid_msgbus_write32(CCK_PORT, DSI_PLL_DIV_REG, 0);
+	gunit_val = intel_mid_msgbus_read32(CCK_PORT, DSI_PLL_CTRL_REG);
+	gunit_val &= ~(DPLL_VCO_ENABLE | _DSI_LDO_EN
+			|_CLK_EN_MASK | _DSI_MUX_SEL_CCK_DSI0 |
+			_DSI_MUX_SEL_CCK_DSI1);
+	intel_mid_msgbus_write32(CCK_PORT, DSI_PLL_CTRL_REG, gunit_val);
+	udelay(1);
+
+	/* Program PLL */
+
+	/*
+	 * first set up the dpll and fp variables
+	 * dpll - will contain the following information
+	 *      - the clock source - DSI vs HFH vs LFH PLL
+	 *      - what clocks should be running DSI0, DSI1
+	 *      - and the divisor.
+	 */
+
+	intel_mid_msgbus_write32(CCK_PORT, DSI_PLL_DIV_REG, ctx->fp);
+	gunit_val &= ~_P1_POST_DIV_MASK;	/*clear the divisor bit*/
+	/*
+	 * the ctx->dpll contains the divisor that we need to use as well as
+	 * which clocks need to start up
+	 */
+	gunit_val |= ctx->dpll;
+	/* We want to clear the LDO enable when programming*/
+	gunit_val &= ~_DSI_LDO_EN;
+	/* Enable the DSI PLL */
+	gunit_val |= DPLL_VCO_ENABLE;
+
+	/* For the CD clock (clock used by Display controller), we need to set
+	 * the DSI_CCK_PLL_SELECT bit (bit 11). This should already be set. But
+	 * setting it just in case
+	 */
+	/* When using HFH PLL. */
+	/* gunit_val |= _DSI_CCK_PLL_SELECT; */
+
+	intel_mid_msgbus_write32(CCK_PORT, DSI_PLL_CTRL_REG, gunit_val);
+
+	/* Wait for DSI PLL lock */
+	retry = 10000;
+	gunit_val = intel_mid_msgbus_read32(CCK_PORT, DSI_PLL_CTRL_REG);
+	while (((gunit_val & _DSI_PLL_LOCK) != _DSI_PLL_LOCK) && (--retry)) {
+		udelay(3);
+		gunit_val = intel_mid_msgbus_read32(CCK_PORT, DSI_PLL_CTRL_REG);
+		if (!retry % 1000)
+			pr_err("DSI PLL taking too long to lock - retry = %d\n",
+			      10000 - retry);
+	}
+	if (retry == 0) {
+		pr_err("DSI PLL fails to lock\n");
+		return false;
+	}
+
+	return true;
+}
+
+bool dsi_pipe_disable_clocking(struct dsi_pipe *pipe)
+{
+	u32 gunit_val = 0x0;
+
+	/* Disable PLL*/
+	intel_mid_msgbus_write32(CCK_PORT, DSI_PLL_DIV_REG, 0);
+
+	gunit_val = intel_mid_msgbus_read32(CCK_PORT, DSI_PLL_CTRL_REG);
+	gunit_val &= ~_CLK_EN_MASK;
+	intel_mid_msgbus_write32(CCK_PORT, DSI_PLL_CTRL_REG, gunit_val);
+	udelay(1);
+	gunit_val &= ~DPLL_VCO_ENABLE;
+	gunit_val |= _DSI_LDO_EN;
+	intel_mid_msgbus_write32(CCK_PORT, DSI_PLL_CTRL_REG, gunit_val);
+	udelay(1);
+
+	gunit_val = intel_mid_msgbus_read32(CCK_PORT, DSI_PLL_CTRL_REG);
+	if ((gunit_val & _DSI_PLL_LOCK) == _DSI_PLL_LOCK) {
+		pr_err("DSI PLL fails to Unlock\n");
+		return false;
+	}
+
+	return true;
+}
+
+static void dsi_pipe_suspend(struct intel_dc_component *component)
+{
+	struct intel_pipe *pipe = to_intel_pipe(component);
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_context *ctx = &dsi_pipe->config.ctx;
+
+	/*power gate the power rail directly*/
+	dsi_pipe->ops.power_off(dsi_pipe);
+}
+
+static void dsi_pipe_resume(struct intel_dc_component *component)
+{
+	struct intel_pipe *pipe = to_intel_pipe(component);
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_context *ctx = &dsi_pipe->config.ctx;
+
+/*	mutex_lock(&dsi_pipe->config.ctx_lock);
+
+	if (!(ctx->pipeconf & PIPEACONF_ENABLE)) {
+		mutex_unlock(&dsi_pipe->config.ctx_lock);
+		return;
+	}
+
+	pr_info("%s: id = %d\n", __func__, component->idx);
+
+	mutex_unlock(&dsi_pipe->config.ctx_lock);
+*/
+	dsi_pipe->ops.power_on(dsi_pipe);
+}
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+static int dsi_set_brightness(struct intel_pipe *pipe, int level)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_panel *panel = NULL;
+	struct dsi_config *config = NULL;
+	struct dsi_context *ctx = NULL;
+	int err = 0;
+
+	if (!dsi_pipe) {
+		pr_err("%s: invalid DSI interface", __func__);
+		return -EINVAL;
+	}
+
+	panel = dsi_pipe->panel;
+	if (!panel || !panel->ops || !panel->ops->set_brightness) {
+		pr_err("%s: invalid panel\n", __func__);
+		return -EINVAL;
+	}
+
+	config = &dsi_pipe->config;
+	ctx = &config->ctx;
+
+	mutex_lock(&config->ctx_lock);
+	dsi_dsr_forbid_locked(dsi_pipe);
+
+	ctx->backlight_level = level;
+	err = panel->ops->set_brightness(dsi_pipe, level);
+
+	dsi_dsr_allow_locked(dsi_pipe);
+	mutex_unlock(&config->ctx_lock);
+
+	return err;
+}
+#endif
+
+static int dsi_pipe_hw_init(struct intel_pipe *pipe)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_panel *panel = dsi_pipe->panel;
+	int err;
+
+	if (!panel || !panel->ops) {
+		pr_err("%s: invalid panel\n", __func__);
+		err = -EINVAL;
+		goto out_err;
+	}
+
+	/* FIXME: check for DBI, as reset isn't necessary here. */
+	if (panel->info.dsi_type == DSI_DBI) {
+		/*reset panel*/
+		if (!panel->ops->reset) {
+			pr_err("%s: reset panel operation is missing\n",
+			       __func__);
+			err = -ENODEV;
+			goto out_err;
+		}
+
+		err = panel->ops->reset(dsi_pipe);
+		if (err) {
+			pr_err("%s: failed to reset panel\n", __func__);
+			goto out_err;
+		}
+	}
+
+	/*detect panel connection status*/
+	if (!panel->ops->detect) {
+		pr_err("%s: detect panel operation is missing\n", __func__);
+		err = -ENODEV;
+		goto out_err;
+	}
+
+	err = panel->ops->detect(dsi_pipe);
+	if (err) {
+		pr_err("%s: failed to detect panel connection\n", __func__);
+		goto out_err;
+	}
+
+	/*init dsi controller*/
+	if (!panel->ops->dsi_controller_init) {
+		pr_err("%s: controller init operation is missing\n", __func__);
+		err = -ENODEV;
+		goto out_err;
+	}
+
+	panel->ops->dsi_controller_init(dsi_pipe);
+
+	/* WA: power down islands turned on by firmware */
+	power_island_put(OSPM_DISPLAY_A | OSPM_DISPLAY_C | OSPM_DISPLAY_MIO);
+
+	return 0;
+out_err:
+	return err;
+}
+
+static void dsi_pipe_hw_deinit(struct intel_pipe *pipe)
+{
+
+}
+
+static void dsi_get_modelist(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **modelist, size_t *n_modes)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+
+	mutex_lock(&config->ctx_lock);
+	*modelist = &config->perferred_mode;
+	*n_modes = 1;
+	mutex_unlock(&config->ctx_lock);
+}
+
+static void dsi_get_preferred_mode(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **mode)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+
+	mutex_lock(&config->ctx_lock);
+	*mode = &config->perferred_mode;
+	mutex_unlock(&config->ctx_lock);
+}
+
+static bool dsi_is_screen_connected(struct intel_pipe *pipe)
+{
+	return true;
+}
+
+static int dsi_dpms(struct intel_pipe *pipe, u8 state)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+	int err = 0;
+
+	if (!config)
+		return -EINVAL;
+
+	mutex_lock(&config->ctx_lock);
+
+	switch (state) {
+	case DRM_MODE_DPMS_ON:
+		err = dsi_pipe->ops.power_on(dsi_pipe);
+		break;
+	case DRM_MODE_DPMS_OFF:
+		err = dsi_pipe->ops.power_off(dsi_pipe);
+		break;
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+	default:
+		mutex_unlock(&config->ctx_lock);
+		pr_err("%s: unsupported dpms mode\n", __func__);
+		return -EOPNOTSUPP;
+	}
+
+	mutex_unlock(&config->ctx_lock);
+	return err;
+}
+
+static int dsi_modeset(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+	int pixel_clk = 0;
+	int err = 0;
+
+	if (!mode) {
+		pr_err("%s: invalid mode\n", __func__);
+		err = -EINVAL;
+		return err;
+	}
+
+	if (!config) {
+		pr_err("%s: invalid DSI config\n", __func__);
+		err = -EINVAL;
+		return err;
+	}
+
+	mutex_lock(&config->ctx_lock);
+
+	if (config->lane_count)
+		pixel_clk = mode->clock / config->lane_count;
+	else
+		pixel_clk = mode->clock;
+
+	err = dsi_pipe_setup_clocking(pipe, pixel_clk);
+	if (err)
+		goto out_err;
+
+	err = dsi_pipe->ops.mode_set(dsi_pipe, mode);
+	if (err) {
+		pr_err("%s: failed to set mode\n", __func__);
+		goto out_err;
+	}
+
+out_err:
+	mutex_unlock(&config->ctx_lock);
+	return err;
+}
+
+static int dsi_get_screen_size(struct intel_pipe *pipe,
+		u16 *width_mm, u16 *height_mm)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_panel *panel = dsi_pipe->panel;
+	struct panel_info pi;
+	int err;
+
+	if (!panel || !panel->ops || !panel->ops->get_panel_info) {
+		pr_err("%s: failed to get panel info\n", __func__);
+		err = -ENODEV;
+		goto out_err;
+	}
+
+	panel->ops->get_panel_info(&pi);
+
+	*width_mm = pi.width_mm;
+	*height_mm = pi.height_mm;
+
+	return 0;
+out_err:
+	return err;
+}
+
+static void dsi_on_post(struct intel_pipe *pipe)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.on_post)
+		dsi_pipe->ops.on_post(dsi_pipe);
+}
+
+static void dsi_pre_post(struct intel_pipe *pipe)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.pre_post)
+		dsi_pipe->ops.pre_post(dsi_pipe);
+}
+
+static u32 dsi_get_supported_events(struct intel_pipe *pipe)
+{
+	return INTEL_PIPE_EVENT_VSYNC;
+}
+
+static int dsi_set_event(struct intel_pipe *pipe, u8 event, bool enabled)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.set_event)
+		return dsi_pipe->ops.set_event(dsi_pipe, event, enabled);
+	else
+		return -EOPNOTSUPP;
+}
+
+/**
+ * FIXME: hardware vsync counter failed to work on ANN. use static SW
+ * counter for now.
+ */
+static u32 vsync_counter;
+
+#define VSYNC_COUNT_MAX_MASK 0xffffff
+
+static void dsi_get_events(struct intel_pipe *pipe, u32 *events)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	u8 idx = pipe->base.idx;
+	u32 dc_events = REG_READ(IIR);
+	u32 event_bit;
+
+	*events = 0;
+
+	pr_debug("%s: IIR = %#x\n", __func__, dc_events);
+
+	switch (idx) {
+	case 0:
+		event_bit = IIR_PIPEA_EVENT;
+		break;
+	case 2:
+		event_bit = IIR_PIPEC_EVENT;
+		break;
+	default:
+		pr_err("%s: invalid pipe index %d\n", __func__, idx);
+		return;
+	}
+
+	if (!(dc_events & event_bit))
+		return;
+
+	/* Clear the 1st level interrupt. */
+	REG_WRITE(IIR, dc_events & (IIR_PIPEA_EVENT | IIR_PIPEC_EVENT));
+
+	if (dsi_pipe->ops.get_events)
+		dsi_pipe->ops.get_events(dsi_pipe, events);
+
+	/**
+	 * FIXME: should use hardware vsync counter.
+	 */
+	if (*events & INTEL_PIPE_EVENT_VSYNC) {
+		if (++vsync_counter > VSYNC_COUNT_MAX_MASK)
+			vsync_counter = 0;
+	}
+}
+
+u32 dsi_get_vsync_counter(struct intel_pipe *pipe, u32 interval)
+{
+	u32 count;
+	u32 max_count_mask = VSYNC_COUNT_MAX_MASK;
+
+	/* NOTE: PIPEFRAMEHIGH & PIPEFRAMEPIXEL regs are RESERVED in ANN DC. */
+#if 0
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_registers *regs = &dsi_pipe->config.regs;
+	u32 high1, high2, low;
+
+	if (!(PIPEACONF_ENABLE & REG_READ(regs->pipeconf_reg))) {
+		pr_err("%s: pipe was disabled\n", __func__);
+		return 0;
+	}
+
+	/*
+	 * High & low register fields aren't synchronized, so make sure
+	 * we get a low value that's stable across two reads of the high
+	 * register.
+	 */
+	do {
+		high1 = ((REG_READ(regs->pipeframehigh_reg) &
+			PIPE_FRAME_HIGH_MASK) >> PIPE_FRAME_HIGH_SHIFT);
+		low =  ((REG_READ(regs->pipeframepixel_reg) &
+			PIPE_FRAME_LOW_MASK) >> PIPE_FRAME_LOW_SHIFT);
+		high2 = ((REG_READ(regs->pipeframehigh_reg) &
+			PIPE_FRAME_HIGH_MASK) >>  PIPE_FRAME_HIGH_SHIFT);
+	} while (high1 != high2);
+
+	count = (high1 << 8) | low;
+#endif
+	count = vsync_counter;
+	count |= (~max_count_mask);
+	count += interval;
+	count &= max_count_mask;
+
+	pr_debug("%s: count = %#x\n", __func__, count);
+
+	return count;
+}
+
+/* Handle more device custom events. */
+static void dsi_handle_events(struct intel_pipe *pipe, u32 events)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.handle_events)
+		dsi_pipe->ops.handle_events(dsi_pipe, events);
+}
+
+static struct intel_pipe_ops dsi_base_ops = {
+	.base = {
+		.suspend = dsi_pipe_suspend,
+		.resume = dsi_pipe_resume,
+	},
+	.hw_init = dsi_pipe_hw_init,
+	.hw_deinit = dsi_pipe_hw_deinit,
+	.get_preferred_mode = dsi_get_preferred_mode,
+	.is_screen_connected = dsi_is_screen_connected,
+	.get_modelist = dsi_get_modelist,
+	.dpms = dsi_dpms,
+	.modeset = dsi_modeset,
+	.get_screen_size = dsi_get_screen_size,
+	.pre_post = dsi_pre_post,
+	.on_post = dsi_on_post,
+	.get_supported_events = dsi_get_supported_events,
+	.set_event = dsi_set_event,
+	.get_events = dsi_get_events,
+	.get_vsync_counter = dsi_get_vsync_counter,
+	.handle_events = dsi_handle_events,
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+	.set_brightness = dsi_set_brightness,
+#endif
+};
+
+void dsi_pipe_destroy(struct dsi_pipe *pipe)
+{
+	struct dsi_panel *panel;
+	if (pipe) {
+		panel = pipe->panel;
+		if (panel) {
+			switch (panel->info.dsi_type) {
+			case DSI_DBI:
+				dsi_dsr_destroy(&pipe->config);
+				break;
+			case DSI_DPI:
+				dsi_sdo_destroy(&pipe->config);
+				break;
+			default:
+				break;
+			}
+		}
+
+		dsi_pkg_sender_destroy(&pipe->sender);
+		dsi_config_destroy(&pipe->config);
+	}
+}
+
+int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
+	struct intel_plane *primary_plane, u8 idx, u32 gtt_phy_addr)
+{
+	struct dsi_panel *panel;
+	int err;
+
+	if (!pipe || !primary_plane)
+		return -EINVAL;
+
+	memset(pipe, 0, sizeof(struct dsi_pipe));
+
+	/*get panel*/
+	panel = get_dsi_panel();
+	if (!panel)
+		return -ENODEV;
+
+	/*init config*/
+	err = dsi_config_init(&pipe->config, panel, idx);
+	if (err)
+		goto err;
+
+	/*init dsi interface ops*/
+	switch (panel->info.dsi_type) {
+	case DSI_DBI:
+		pipe->ops.power_on = dbi_pipe_power_on;
+		pipe->ops.power_off = dbi_pipe_power_off;
+		pipe->ops.mode_set = dbi_pipe_mode_set;
+		pipe->ops.pre_post = dbi_pipe_pre_post;
+		pipe->ops.on_post = dbi_pipe_on_post;
+		pipe->ops.set_event = dbi_pipe_set_event;
+		pipe->ops.get_events = dbi_pipe_get_events;
+		pipe->ops.handle_events = NULL;
+		break;
+	case DSI_DPI:
+		pipe->ops.power_on = dpi_pipe_power_on;
+		pipe->ops.power_off = dpi_pipe_power_off;
+		pipe->ops.mode_set = dpi_pipe_mode_set;
+		pipe->ops.pre_post = dpi_pipe_pre_post;
+		pipe->ops.set_event = dpi_pipe_set_event;
+		pipe->ops.get_events = dpi_pipe_get_events;
+		pipe->ops.handle_events = dpi_pipe_handle_events;
+		break;
+	default:
+		goto err;
+	}
+
+	/*init sender*/
+	err = dsi_pkg_sender_init(&pipe->sender, gtt_phy_addr,
+		panel->info.dsi_type, idx);
+	if (err)
+		goto err;
+
+	switch (panel->info.dsi_type) {
+	case DSI_DBI:
+		err = dsi_dsr_init(pipe);
+		if (err)
+			goto err;
+
+		/* dsi_dsr_enable(pipe); */
+		break;
+	case DSI_DPI:
+		err = dsi_sdo_init(pipe);
+		if (err)
+			goto err;
+
+		/* dsi_sdo_enable(pipe); */
+		break;
+	default:
+		goto err;
+	}
+
+	pipe->panel = panel;
+
+	err = intel_pipe_init(&pipe->base, dev, idx, true, INTEL_PIPE_DSI,
+		primary_plane, &dsi_base_ops, "dsi_pipe");
+	if (err)
+		goto err;
+
+	return 0;
+err:
+	dsi_pipe_destroy(pipe);
+	return err;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_pkg_sender.c b/drivers/video/adf/intel/core/common/dsi/dsi_pkg_sender.c
new file mode 100644
index 0000000..4426e0c
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_pkg_sender.c
@@ -0,0 +1,1772 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include <linux/delay.h>
+#include <linux/freezer.h>
+
+#include "core/common/dsi/dsi_pkg_sender.h"
+
+#define DSI_DBI_FIFO_TIMEOUT		1000
+#define DSI_MAX_RETURN_PACKET_SIZE	512
+#define DSI_READ_MAX_COUNT		10000
+
+const char *dsi_error_msgs[] = {
+	"[ 0:RX SOT Error]",
+	"[ 1:RX SOT Sync Error]",
+	"[ 2:RX EOT Sync Error]",
+	"[ 3:RX Escape Mode Entry Error]",
+	"[ 4:RX LP TX Sync Error",
+	"[ 5:RX HS Receive Timeout Error]",
+	"[ 6:RX False Control Error]",
+	"[ 7:RX ECC Single Bit Error]",
+	"[ 8:RX ECC Multibit Error]",
+	"[ 9:RX Checksum Error]",
+	"[10:RX DSI Data Type Not Recognised]",
+	"[11:RX DSI VC ID Invalid]",
+	"[12:TX False Control Error]",
+	"[13:TX ECC Single Bit Error]",
+	"[14:TX ECC Multibit Error]",
+	"[15:TX Checksum Error]",
+	"[16:TX DSI Data Type Not Recognised]",
+	"[17:TX DSI VC ID invalid]",
+	"[18:High Contention]",
+	"[19:Low contention]",
+	"[20:DPI FIFO Under run]",
+	"[21:HS TX Timeout]",
+	"[22:LP RX Timeout]",
+	"[23:Turn Around ACK Timeout]",
+	"[24:ACK With No Error]",
+	"[25:RX Invalid TX Length]",
+	"[26:RX Prot Violation]",
+	"[27:HS Generic Write FIFO Full]",
+	"[28:LP Generic Write FIFO Full]",
+	"[29:Generic Read Data Avail]",
+	"[30:Special Packet Sent]",
+	"[31:Tearing Effect]",
+};
+
+static inline int wait_for_gen_fifo_empty(struct dsi_pkg_sender *sender,
+						u32 mask)
+{
+	u32 gen_fifo_stat_reg = sender->mipi_gen_fifo_stat_reg;
+	int retry = 10000;
+
+	if (sender->work_for_slave_panel)
+		gen_fifo_stat_reg += MIPI_C_REG_OFFSET;
+
+	while (retry--) {
+		if ((mask & REG_READ(gen_fifo_stat_reg)) == mask)
+			return 0;
+		udelay(3);
+	}
+
+	pr_err("fifo is NOT empty 0x%08x\n", REG_READ(gen_fifo_stat_reg));
+	if (!IS_ANN())
+		debug_dbi_hang(sender);
+
+	sender->status = DSI_CONTROL_ABNORMAL;
+	return -EIO;
+}
+
+static int wait_for_all_fifos_empty(struct dsi_pkg_sender *sender)
+{
+	return wait_for_gen_fifo_empty(sender,
+		(HS_DATA_FIFO_EMPTY | LP_DATA_FIFO_EMPTY | HS_CTRL_FIFO_EMPTY |
+			LP_CTRL_FIFO_EMPTY | DBI_FIFO_EMPTY | DPI_FIFO_EMPTY));
+}
+
+static int wait_for_lp_fifos_empty(struct dsi_pkg_sender *sender)
+{
+	return wait_for_gen_fifo_empty(sender,
+		(LP_DATA_FIFO_EMPTY | LP_CTRL_FIFO_EMPTY));
+}
+
+static int wait_for_hs_fifos_empty(struct dsi_pkg_sender *sender)
+{
+	return wait_for_gen_fifo_empty(sender,
+		(HS_DATA_FIFO_EMPTY | HS_CTRL_FIFO_EMPTY));
+}
+
+static int wait_for_dbi_fifo_empty(struct dsi_pkg_sender *sender)
+{
+	return wait_for_gen_fifo_empty(sender, (DBI_FIFO_EMPTY));
+}
+
+static int wait_for_dpi_fifo_empty(struct dsi_pkg_sender *sender)
+{
+	return wait_for_gen_fifo_empty(sender, (DPI_FIFO_EMPTY));
+}
+
+static int dsi_error_handler(struct dsi_pkg_sender *sender)
+{
+	u32 intr_stat_reg = sender->mipi_intr_stat_reg;
+
+	int i;
+	u32 mask;
+	int err = 0;
+	int count = 0;
+	u32 intr_stat;
+
+	intr_stat = REG_READ(intr_stat_reg);
+	if (!intr_stat)
+		return 0;
+
+	for (i = 0; i < 32; i++) {
+		mask = (0x00000001UL) << i;
+		if (!(intr_stat & mask))
+			continue;
+
+		switch (mask) {
+		case RX_SOT_ERROR:
+		case RX_SOT_SYNC_ERROR:
+		case RX_EOT_SYNC_ERROR:
+		case RX_ESCAPE_MODE_ENTRY_ERROR:
+		case RX_LP_TX_SYNC_ERROR:
+		case RX_HS_RECEIVE_TIMEOUT_ERROR:
+		case RX_FALSE_CONTROL_ERROR:
+		case RX_ECC_SINGLE_BIT_ERROR:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case RX_ECC_MULTI_BIT_ERROR:
+			/*No Action required.*/
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case RX_CHECKSUM_ERROR:
+		case RX_DSI_DATA_TYPE_NOT_RECOGNIZED:
+		case RX_DSI_VC_ID_INVALID:
+		case TX_FALSE_CONTROL_ERROR:
+		case TX_ECC_SINGLE_BIT_ERROR:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case TX_ECC_MULTI_BIT_ERROR:
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			break;
+		case TX_CHECKSUM_ERROR:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case TX_DSI_DATA_TYPE_NOT_RECOGNIZED:
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case TX_DSI_VC_ID_INVALID:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case HIGH_CONTENTION:
+			REG_WRITE(MIPIA_EOT_DISABLE_REG,
+				REG_READ(MIPIA_EOT_DISABLE_REG) |
+				LOW_CONTENTION_REC_DISABLE |
+				HIGH_CONTENTION_REC_DISABLE);
+			while ((REG_READ(intr_stat_reg) & HIGH_CONTENTION)) {
+				count++;
+				/*
+				* Per silicon feedback,
+				* if this bit cannot be
+				* cleared by 3 times,
+				* it should be a real
+				* High Contention error.
+				*/
+				if (count == 4) {
+					pr_info("dsi status %s\n",
+						dsi_error_msgs[i]);
+					break;
+				}
+				REG_WRITE(intr_stat_reg, mask);
+			}
+			break;
+		case LOW_CONTENTION:
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			break;
+		case DPI_FIFO_UNDER_RUN:
+			/*No Action required.*/
+			pr_debug("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case HS_TX_TIMEOUT:
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			err = wait_for_all_fifos_empty(sender);
+			break;
+		case LP_RX_TIMEOUT:
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			err = wait_for_all_fifos_empty(sender);
+			break;
+		case TURN_AROUND_ACK_TIMEOUT:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case ACK_WITH_NO_ERROR:
+			/*No Action required.*/
+			pr_debug("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case RX_INVALID_TX_LENGTH:
+		case RX_PROT_VIOLATION:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			break;
+		case HS_GENERIC_WR_FIFO_FULL:
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			err = wait_for_hs_fifos_empty(sender);
+			break;
+		case LP_GENERIC_WR_FIFO_FULL:
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			REG_WRITE(intr_stat_reg, mask);
+			err = wait_for_lp_fifos_empty(sender);
+			break;
+		case GEN_READ_DATA_AVAIL:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			break;
+		case SPL_PKT_SENT_INTERRUPT:
+			break;
+		case TEARING_EFFECT:
+			/*No Action required.*/
+			pr_info("dsi status %s\n", dsi_error_msgs[i]);
+			break;
+		}
+	}
+
+	return err;
+}
+
+static inline int dbi_cmd_sent(struct dsi_pkg_sender *sender)
+{
+	u32 retry = 0xffff;
+	u32 dbi_cmd_addr_reg = sender->mipi_cmd_addr_reg;
+	int ret = 0;
+
+	/*query the command execution status*/
+	while (retry--) {
+		if (!(REG_READ(dbi_cmd_addr_reg) & CMD_VALID))
+			break;
+	}
+
+	if (!retry) {
+		pr_err("Timeout waiting for DBI Command status\n");
+		ret = -EAGAIN;
+	}
+
+	return ret;
+}
+
+/**
+ * NOTE: this interface is abandoned expect for write_mem_start DCS
+ * other DCS are sent via generic pkg interfaces
+ */
+static int send_dcs_pkg(struct dsi_pkg_sender *sender,
+			struct dsi_pkg *pkg)
+{
+	struct dsi_dcs_pkg *dcs_pkg = &pkg->pkg.dcs_pkg;
+	u32 dbi_cmd_len_reg = sender->mipi_cmd_len_reg;
+	u32 dbi_cmd_addr_reg = sender->mipi_cmd_addr_reg;
+	u32 cb_phy = sender->dbi_cb_phy;
+	u32 index = 0;
+	u8 *cb = (u8 *)sender->dbi_cb_addr;
+	int i;
+	int ret;
+
+	if (!sender->dbi_pkg_support) {
+		pr_err("Trying to send DCS on a non DBI output, abort!\n");
+		return -ENOTSUPP;
+	}
+
+	pr_debug("Sending DCS pkg 0x%x...\n", dcs_pkg->cmd);
+
+	/*wait for DBI fifo empty*/
+	wait_for_dbi_fifo_empty(sender);
+
+	*(cb + (index++)) = dcs_pkg->cmd;
+	if (dcs_pkg->param_num) {
+		for (i = 0; i < dcs_pkg->param_num; i++)
+			*(cb + (index++)) = *(dcs_pkg->param + i);
+	}
+
+	REG_WRITE(dbi_cmd_len_reg, (1 + dcs_pkg->param_num));
+	REG_WRITE(dbi_cmd_addr_reg,
+		(cb_phy << CMD_MEM_ADDR_OFFSET)
+		| CMD_VALID
+		| ((dcs_pkg->data_src == CMD_DATA_SRC_PIPE) ?
+					 CMD_DATA_MODE : 0));
+
+	ret = dbi_cmd_sent(sender);
+	if (ret) {
+		pr_err("command 0x%x not complete\n", dcs_pkg->cmd);
+		return -EAGAIN;
+	}
+
+	pr_debug("sent DCS pkg 0x%x...\n", dcs_pkg->cmd);
+
+	return 0;
+}
+
+static int __send_short_pkg(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	u32 hs_gen_ctrl_reg = sender->mipi_hs_gen_ctrl_reg;
+	u32 lp_gen_ctrl_reg = sender->mipi_lp_gen_ctrl_reg;
+	u32 gen_ctrl_val = 0;
+	struct dsi_gen_short_pkg *short_pkg = &pkg->pkg.short_pkg;
+
+	if (sender->work_for_slave_panel) {
+		hs_gen_ctrl_reg += MIPI_C_REG_OFFSET;
+		lp_gen_ctrl_reg += MIPI_C_REG_OFFSET;
+	}
+	gen_ctrl_val |= short_pkg->cmd << HS_WORD_COUNT_SHIFT;
+	gen_ctrl_val |= 0 << HS_VIRTUAL_CHANNEL_SHIFT;
+	gen_ctrl_val |= pkg->pkg_type;
+	gen_ctrl_val |= short_pkg->param << HS_MCS_PARAMETER_SHIFT;
+
+	if (pkg->transmission_type == DSI_HS_TRANSMISSION) {
+		/*wait for hs fifo empty*/
+		wait_for_dbi_fifo_empty(sender);
+		wait_for_hs_fifos_empty(sender);
+
+		/*send pkg*/
+		REG_WRITE(hs_gen_ctrl_reg, gen_ctrl_val);
+	} else if (pkg->transmission_type == DSI_LP_TRANSMISSION) {
+		wait_for_dbi_fifo_empty(sender);
+		wait_for_lp_fifos_empty(sender);
+
+		/*send pkg*/
+		REG_WRITE(lp_gen_ctrl_reg, gen_ctrl_val);
+	} else {
+		pr_err("Unknown transmission type %d\n",
+				pkg->transmission_type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __send_long_pkg(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	u32 hs_gen_ctrl_reg = sender->mipi_hs_gen_ctrl_reg;
+	u32 hs_gen_data_reg = sender->mipi_hs_gen_data_reg;
+	u32 lp_gen_ctrl_reg = sender->mipi_lp_gen_ctrl_reg;
+	u32 lp_gen_data_reg = sender->mipi_lp_gen_data_reg;
+	u32 gen_ctrl_val = 0;
+	u8 *dp = NULL;
+	u32 reg_val = 0;
+	int i;
+	int dword_count = 0, remain_byte_count = 0;
+	struct dsi_gen_long_pkg *long_pkg = &pkg->pkg.long_pkg;
+
+	dp = long_pkg->data;
+	if (sender->work_for_slave_panel) {
+		hs_gen_ctrl_reg += MIPI_C_REG_OFFSET;
+		hs_gen_data_reg += MIPI_C_REG_OFFSET;
+		lp_gen_ctrl_reg += MIPI_C_REG_OFFSET;
+		lp_gen_data_reg += MIPI_C_REG_OFFSET;
+	}
+
+	/**
+	 * Set up word count for long pkg
+	 * FIXME: double check word count field.
+	 * currently, using the byte counts of the payload as the word count.
+	 * ------------------------------------------------------------
+	 * | DI |   WC   | ECC|         PAYLOAD              |CHECKSUM|
+	 * ------------------------------------------------------------
+	 */
+	gen_ctrl_val |= (long_pkg->len) << HS_WORD_COUNT_SHIFT;
+	gen_ctrl_val |= 0 << HS_VIRTUAL_CHANNEL_SHIFT;
+	gen_ctrl_val |= pkg->pkg_type;
+
+	if (pkg->transmission_type == DSI_HS_TRANSMISSION) {
+		/*wait for hs ctrl and data fifos to be empty*/
+		wait_for_dbi_fifo_empty(sender);
+		wait_for_hs_fifos_empty(sender);
+
+		dword_count = long_pkg->len / 4;
+		remain_byte_count = long_pkg->len % 4;
+		for (i = 0; i < dword_count * 4; i = i + 4) {
+			reg_val = 0;
+			reg_val = *(dp + i);
+			reg_val |= *(dp + i + 1) << 8;
+			reg_val |= *(dp + i + 2) << 16;
+			reg_val |= *(dp + i + 3) << 24;
+			pr_debug("HS Sending data 0x%08x\n", reg_val);
+			REG_WRITE(hs_gen_data_reg, reg_val);
+		}
+
+		if (remain_byte_count) {
+			reg_val = 0;
+			for (i = 0; i < remain_byte_count; i++)
+				reg_val |=
+					*(dp + dword_count * 4 + i) << (8 * i);
+			pr_debug("HS Sending data 0x%08x\n", reg_val);
+			REG_WRITE(hs_gen_data_reg, reg_val);
+		}
+
+		REG_WRITE(hs_gen_ctrl_reg, gen_ctrl_val);
+	} else if (pkg->transmission_type == DSI_LP_TRANSMISSION) {
+		wait_for_dbi_fifo_empty(sender);
+		wait_for_lp_fifos_empty(sender);
+
+		dword_count = long_pkg->len / 4;
+		remain_byte_count = long_pkg->len % 4;
+		for (i = 0; i < dword_count * 4; i = i + 4) {
+			reg_val = 0;
+			reg_val = *(dp + i);
+			reg_val |= *(dp + i + 1) << 8;
+			reg_val |= *(dp + i + 2) << 16;
+			reg_val |= *(dp + i + 3) << 24;
+			pr_debug("LP Sending data 0x%08x\n", reg_val);
+			REG_WRITE(lp_gen_data_reg, reg_val);
+		}
+
+		if (remain_byte_count) {
+			reg_val = 0;
+			for (i = 0; i < remain_byte_count; i++) {
+				reg_val |=
+					*(dp + dword_count * 4 + i) << (8 * i);
+			}
+			pr_debug("LP Sending data 0x%08x\n", reg_val);
+			REG_WRITE(lp_gen_data_reg, reg_val);
+		}
+
+		REG_WRITE(lp_gen_ctrl_reg, gen_ctrl_val);
+	} else {
+		pr_err("Unknown transmission type %d\n",
+				pkg->transmission_type);
+		return -EINVAL;
+	}
+
+	return 0;
+
+}
+
+static int send_mcs_short_pkg(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	pr_debug("Sending MCS short pkg...\n");
+
+	return __send_short_pkg(sender, pkg);
+}
+
+static int send_mcs_long_pkg(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	pr_debug("Sending MCS long pkg...\n");
+
+	return __send_long_pkg(sender, pkg);
+}
+
+static int send_gen_short_pkg(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	pr_debug("Sending GEN short pkg...\n");
+
+	return __send_short_pkg(sender, pkg);
+}
+
+static int send_gen_long_pkg(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	pr_debug("Sending GEN long pkg...\n");
+
+	return __send_long_pkg(sender, pkg);
+}
+
+static int send_dpi_spk_pkg(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	u32 dpi_control_reg = sender->mipi_dpi_control_reg;
+	u32 intr_stat_reg = sender->mipi_intr_stat_reg;
+	u32 dpi_control_val = 0;
+	u32 dpi_control_current_setting = 0;
+	struct dsi_dpi_spk_pkg *spk_pkg = &pkg->pkg.spk_pkg;
+	int retry = 10000;
+
+	dpi_control_val = spk_pkg->cmd;
+
+	if (pkg->transmission_type == DSI_LP_TRANSMISSION)
+		dpi_control_val |= HS_LP;
+
+	/*Wait for DPI fifo empty*/
+	wait_for_dpi_fifo_empty(sender);
+
+	/*clean spk packet sent interrupt*/
+	REG_WRITE(intr_stat_reg, SPL_PKT_SENT_INTERRUPT);
+	dpi_control_current_setting =
+		REG_READ(dpi_control_reg);
+
+	/*send out spk packet*/
+	if (dpi_control_current_setting != dpi_control_val) {
+		REG_WRITE(dpi_control_reg, dpi_control_val);
+
+		/*wait for spk packet sent interrupt*/
+		while (--retry && !(REG_READ(intr_stat_reg) &
+				    SPL_PKT_SENT_INTERRUPT))
+			udelay(3);
+
+		if (!retry) {
+			pr_err("Fail to send SPK Packet 0x%x\n",
+				 spk_pkg->cmd);
+			return -EINVAL;
+		}
+	} else
+		/*For SHUT_DOWN and TURN_ON, it is better called by
+		symmetrical. so skip duplicate called*/
+		pr_warn("skip duplicate setting of DPI control\n");
+	return 0;
+}
+
+static int send_pkg_prepare(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg)
+{
+	u8 cmd;
+	u8 *data;
+
+	pr_debug("Prepare to Send type 0x%x pkg\n", pkg->pkg_type);
+
+	switch (pkg->pkg_type) {
+	case DSI_PKG_DCS:
+		cmd = pkg->pkg.dcs_pkg.cmd;
+		break;
+	case DSI_PKG_MCS_SHORT_WRITE_0:
+	case DSI_PKG_MCS_SHORT_WRITE_1:
+		cmd = pkg->pkg.short_pkg.cmd;
+		break;
+	case DSI_PKG_MCS_LONG_WRITE:
+		data = (u8 *)pkg->pkg.long_pkg.data;
+		cmd = *data;
+		break;
+	default:
+		return 0;
+	}
+
+	/*this prevents other package sending while doing msleep*/
+	sender->status = DSI_PKG_SENDER_BUSY;
+
+	return 0;
+}
+
+static int send_pkg_done(struct dsi_pkg_sender *sender,
+		struct dsi_pkg *pkg)
+{
+	u8 cmd;
+	u8 *data = NULL;
+
+	pr_debug("Sent type 0x%x pkg\n", pkg->pkg_type);
+
+	switch (pkg->pkg_type) {
+	case DSI_PKG_DCS:
+		cmd = pkg->pkg.dcs_pkg.cmd;
+		break;
+	case DSI_PKG_MCS_SHORT_WRITE_0:
+	case DSI_PKG_MCS_SHORT_WRITE_1:
+		cmd = pkg->pkg.short_pkg.cmd;
+		break;
+	case DSI_PKG_MCS_LONG_WRITE:
+	case DSI_PKG_GEN_LONG_WRITE:
+		data = (u8 *)pkg->pkg.long_pkg.data;
+		cmd = *data;
+		break;
+	default:
+		return 0;
+	}
+
+	/*update panel status*/
+	if (unlikely(cmd == enter_sleep_mode))
+		sender->panel_mode |= DSI_PANEL_MODE_SLEEP;
+	else if (unlikely(cmd == exit_sleep_mode))
+		sender->panel_mode &= ~DSI_PANEL_MODE_SLEEP;
+
+	if (sender->status != DSI_CONTROL_ABNORMAL)
+		sender->status = DSI_PKG_SENDER_FREE;
+
+	/*after sending pkg done, free the data buffer for mcs long pkg*/
+	if (pkg->pkg_type == DSI_PKG_MCS_LONG_WRITE ||
+		pkg->pkg_type == DSI_PKG_GEN_LONG_WRITE) {
+		if (data != NULL)
+			kfree(data);
+	}
+
+	return 0;
+}
+
+static int do_send_pkg(struct dsi_pkg_sender *sender,
+			struct dsi_pkg *pkg)
+{
+	int ret = 0;
+
+	pr_debug("Sending type 0x%x pkg\n", pkg->pkg_type);
+
+	if (sender->status == DSI_PKG_SENDER_BUSY) {
+		pr_err("sender is busy\n");
+		return -EAGAIN;
+	}
+
+	ret = send_pkg_prepare(sender, pkg);
+	if (ret) {
+		pr_err("send_pkg_prepare error\n");
+		return ret;
+	}
+
+	switch (pkg->pkg_type) {
+	case DSI_PKG_DCS:
+		ret = send_dcs_pkg(sender, pkg);
+		break;
+	case DSI_PKG_GEN_SHORT_WRITE_0:
+	case DSI_PKG_GEN_SHORT_WRITE_1:
+	case DSI_PKG_GEN_SHORT_WRITE_2:
+	case DSI_PKG_GEN_READ_0:
+	case DSI_PKG_GEN_READ_1:
+	case DSI_PKG_GEN_READ_2:
+		ret = send_gen_short_pkg(sender, pkg);
+		break;
+	case DSI_PKG_GEN_LONG_WRITE:
+		ret = send_gen_long_pkg(sender, pkg);
+		break;
+	case DSI_PKG_MCS_SHORT_WRITE_0:
+	case DSI_PKG_MCS_SHORT_WRITE_1:
+	case DSI_PKG_MCS_READ:
+		ret = send_mcs_short_pkg(sender, pkg);
+		break;
+	case DSI_PKG_MCS_LONG_WRITE:
+		ret = send_mcs_long_pkg(sender, pkg);
+		break;
+	case DSI_DPI_SPK:
+		ret = send_dpi_spk_pkg(sender, pkg);
+		break;
+	default:
+		pr_err("Invalid pkg type 0x%x\n", pkg->pkg_type);
+		ret = -EINVAL;
+	}
+
+	send_pkg_done(sender, pkg);
+
+	return ret;
+}
+
+static int send_pkg(struct dsi_pkg_sender *sender,
+			struct dsi_pkg *pkg)
+{
+	int err = 0;
+
+	/*handle DSI error*/
+	err = dsi_error_handler(sender);
+	if (err) {
+		pr_err("Error handling failed\n");
+		err = -EAGAIN;
+		goto send_pkg_err;
+	}
+
+	/*send pkg*/
+	err = do_send_pkg(sender, pkg);
+	if (err) {
+		pr_err("sent pkg failed\n");
+		dsi_error_handler(sender);
+		err = -EAGAIN;
+		goto send_pkg_err;
+	}
+
+	/*FIXME: should I query complete and fifo empty here?*/
+send_pkg_err:
+	return err;
+}
+
+static struct dsi_pkg *
+pkg_sender_get_pkg_locked(struct dsi_pkg_sender *sender)
+{
+	struct dsi_pkg *pkg;
+
+	if (list_empty(&sender->free_list)) {
+		pr_err("No free pkg left\n");
+		return NULL;
+	}
+
+	pkg = list_first_entry(&sender->free_list, struct dsi_pkg, entry);
+
+	/*detach from free list*/
+	list_del_init(&pkg->entry);
+
+	return pkg;
+}
+
+static void pkg_sender_put_pkg_locked(struct dsi_pkg_sender *sender,
+		struct dsi_pkg *pkg)
+{
+	memset(pkg, 0, sizeof(struct dsi_pkg));
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	list_add_tail(&pkg->entry, &sender->free_list);
+}
+
+static int dbi_cb_init(struct dsi_pkg_sender *sender, u32 gtt_phys_addr,
+	int pipe)
+{
+	uint32_t phy;
+	void *virt_addr = NULL;
+
+	switch (pipe) {
+	case 0:
+		phy = gtt_phys_addr - 0x1000;
+		break;
+	case 2:
+		phy = gtt_phys_addr - 0x800;
+		break;
+	default:
+		pr_err("Unsupported channel\n");
+		return -EINVAL;
+	}
+
+	/*mapping*/
+	virt_addr = ioremap_nocache(phy, 0x800);
+	if (!virt_addr) {
+		pr_err("Map DBI command buffer error\n");
+		return -ENOMEM;
+	}
+
+	if (IS_ANN())
+		memset(virt_addr, 0x0, 0x800);
+
+	sender->dbi_cb_phy = phy;
+	sender->dbi_cb_addr = virt_addr;
+
+	pr_debug("DBI command buffer initailized. phy %x, addr %p\n",
+			phy, virt_addr);
+
+	return 0;
+}
+
+static void dbi_cb_destroy(struct dsi_pkg_sender *sender)
+{
+	pr_debug("\n");
+
+	if (sender && sender->dbi_cb_addr)
+		iounmap(sender->dbi_cb_addr);
+}
+
+static inline void pkg_sender_queue_pkg(struct dsi_pkg_sender *sender,
+					struct dsi_pkg *pkg,
+					int delay)
+{
+	mutex_lock(&sender->lock);
+
+	if (!delay) {
+		send_pkg(sender, pkg);
+
+		pkg_sender_put_pkg_locked(sender, pkg);
+	} else {
+		/*queue it*/
+		list_add_tail(&pkg->entry, &sender->pkg_list);
+	}
+
+	mutex_unlock(&sender->lock);
+}
+
+static inline int process_pkg_list(struct dsi_pkg_sender *sender)
+{
+	struct dsi_pkg *pkg;
+	int ret = 0;
+
+	mutex_lock(&sender->lock);
+
+	while (!list_empty(&sender->pkg_list)) {
+		pkg = list_first_entry(&sender->pkg_list,
+				struct dsi_pkg, entry);
+		ret = send_pkg(sender, pkg);
+
+		if (ret) {
+			pr_info("Returning eror from process_pkg_lisgt");
+			goto errorunlock;
+		}
+
+		list_del_init(&pkg->entry);
+
+		pkg_sender_put_pkg_locked(sender, pkg);
+	}
+
+	mutex_unlock(&sender->lock);
+	return 0;
+
+errorunlock:
+	mutex_unlock(&sender->lock);
+	return ret;
+}
+
+static int dsi_send_mcs_long(struct dsi_pkg_sender *sender,
+				   u8 *data,
+				   u32 len,
+				   u8 transmission,
+				   int delay)
+{
+	struct dsi_pkg *pkg;
+	u8 *pdata = NULL;
+
+	mutex_lock(&sender->lock);
+
+	pkg = pkg_sender_get_pkg_locked(sender);
+
+	mutex_unlock(&sender->lock);
+
+	if (!pkg) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	/* alloc a data buffer to save the long pkg data,
+	 * free the buffer when send_pkg_done.
+	 * */
+	pdata = kmalloc(sizeof(u8) * len, GFP_KERNEL);
+	if (!pdata) {
+		pr_err("No memory for long_pkg data\n");
+		return -ENOMEM;
+	}
+
+	memcpy(pdata, data, len * sizeof(u8));
+
+	pkg->pkg_type = DSI_PKG_MCS_LONG_WRITE;
+	pkg->transmission_type = transmission;
+	pkg->pkg.long_pkg.data = pdata;
+	pkg->pkg.long_pkg.len = len;
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	pkg_sender_queue_pkg(sender, pkg, delay);
+
+	return 0;
+}
+
+static int dsi_send_mcs_short(struct dsi_pkg_sender *sender,
+					u8 cmd, u8 param, u8 param_num,
+					u8 transmission,
+					int delay)
+{
+	struct dsi_pkg *pkg;
+
+	mutex_lock(&sender->lock);
+
+	pkg = pkg_sender_get_pkg_locked(sender);
+
+	mutex_unlock(&sender->lock);
+
+	if (!pkg) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	if (param_num) {
+		pkg->pkg_type = DSI_PKG_MCS_SHORT_WRITE_1;
+		pkg->pkg.short_pkg.param = param;
+	} else {
+		pkg->pkg_type = DSI_PKG_MCS_SHORT_WRITE_0;
+		pkg->pkg.short_pkg.param = 0;
+	}
+	pkg->transmission_type = transmission;
+	pkg->pkg.short_pkg.cmd = cmd;
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	pkg_sender_queue_pkg(sender, pkg, delay);
+
+	return 0;
+}
+
+static int dsi_send_gen_short(struct dsi_pkg_sender *sender,
+					u8 param0, u8 param1, u8 param_num,
+					u8 transmission,
+					int delay)
+{
+	struct dsi_pkg *pkg;
+
+	mutex_lock(&sender->lock);
+
+	pkg = pkg_sender_get_pkg_locked(sender);
+
+	mutex_unlock(&sender->lock);
+
+	if (!pkg) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	switch (param_num) {
+	case 0:
+		pkg->pkg_type = DSI_PKG_GEN_SHORT_WRITE_0;
+		pkg->pkg.short_pkg.cmd = 0;
+		pkg->pkg.short_pkg.param = 0;
+		break;
+	case 1:
+		pkg->pkg_type = DSI_PKG_GEN_SHORT_WRITE_1;
+		pkg->pkg.short_pkg.cmd = param0;
+		pkg->pkg.short_pkg.param = 0;
+		break;
+	case 2:
+		pkg->pkg_type = DSI_PKG_GEN_SHORT_WRITE_2;
+		pkg->pkg.short_pkg.cmd = param0;
+		pkg->pkg.short_pkg.param = param1;
+		break;
+	}
+
+	pkg->transmission_type = transmission;
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	pkg_sender_queue_pkg(sender, pkg, delay);
+
+	return 0;
+}
+
+static int dsi_send_gen_long(struct dsi_pkg_sender *sender,
+				   u8 *data,
+				   u32 len,
+				   u8 transmission,
+				   int delay)
+{
+	struct dsi_pkg *pkg;
+	u8 *pdata = NULL;
+
+	mutex_lock(&sender->lock);
+
+	pkg = pkg_sender_get_pkg_locked(sender);
+
+	mutex_unlock(&sender->lock);
+
+	if (!pkg) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	/* alloc a data buffer to save the long pkg data,
+	 * free the buffer when send_pkg_done.
+	 * */
+	pdata = kmalloc(sizeof(u8)*len, GFP_KERNEL);
+	if (!pdata) {
+		pr_err("No memory for long_pkg data\n");
+		return -ENOMEM;
+	}
+
+	memcpy(pdata, data, len*sizeof(u8));
+
+	pkg->pkg_type = DSI_PKG_GEN_LONG_WRITE;
+	pkg->transmission_type = transmission;
+	pkg->pkg.long_pkg.data = pdata;
+	pkg->pkg.long_pkg.len = len;
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	pkg_sender_queue_pkg(sender, pkg, delay);
+
+	return 0;
+}
+
+static int __read_panel_data(struct dsi_pkg_sender *sender,
+				struct dsi_pkg *pkg,
+				u8 *data,
+				u32 len)
+{
+	int i;
+	u32 gen_data_reg;
+	u32 gen_data_value;
+	int retry = DSI_READ_MAX_COUNT;
+	u8 transmission = pkg->transmission_type;
+	int dword_count = 0, remain_byte_count = 0;
+
+	/*Check the len. Max value is 0x40
+	based on the generic read FIFO size*/
+	if (len * sizeof(*data) > 0x40) {
+		len = 0x40 / sizeof(*data);
+		pr_err("Bigger than Max.Set the len to Max 0x40 bytes\n");
+	}
+
+	/**
+	 * do reading.
+	 * 0) set the max return pack size
+	 * 1) send out generic read request
+	 * 2) polling read data avail interrupt
+	 * 3) read data
+	 */
+	mutex_lock(&sender->lock);
+
+	/*Set the Max return pack size*/
+	wait_for_all_fifos_empty(sender);
+	REG_WRITE(MIPIA_MAX_RETURN_PKT_SIZE_REG, (len*sizeof(*data)) &
+		  MAX_RETURN_PKT_SIZE_MASK);
+	wait_for_all_fifos_empty(sender);
+
+	REG_WRITE(sender->mipi_intr_stat_reg, GEN_READ_DATA_AVAIL);
+
+	if ((REG_READ(sender->mipi_intr_stat_reg) & GEN_READ_DATA_AVAIL))
+		pr_err("Can NOT clean read data valid interrupt\n");
+
+	/*send out read request*/
+	send_pkg(sender, pkg);
+
+	pkg_sender_put_pkg_locked(sender, pkg);
+
+	/*polling read data avail interrupt*/
+	while (--retry && !(REG_READ(sender->mipi_intr_stat_reg) &
+			    GEN_READ_DATA_AVAIL))
+		udelay(3);
+
+	if (!retry) {
+		mutex_unlock(&sender->lock);
+		return -ETIMEDOUT;
+	}
+
+	REG_WRITE(sender->mipi_intr_stat_reg, GEN_READ_DATA_AVAIL);
+
+	/*read data*/
+	if (transmission == DSI_HS_TRANSMISSION)
+		gen_data_reg = sender->mipi_hs_gen_data_reg;
+	else if (transmission == DSI_LP_TRANSMISSION)
+		gen_data_reg = sender->mipi_lp_gen_data_reg;
+	else {
+		pr_err("Unknown transmission");
+		mutex_unlock(&sender->lock);
+		return -EINVAL;
+	}
+
+	dword_count = len / 4;
+	remain_byte_count = len % 4;
+	for (i = 0; i < dword_count * 4; i = i + 4) {
+		gen_data_value = REG_READ(gen_data_reg);
+		*(data + i)     = gen_data_value & 0x000000FF;
+		*(data + i + 1) = (gen_data_value >> 8)  & 0x000000FF;
+		*(data + i + 2) = (gen_data_value >> 16) & 0x000000FF;
+		*(data + i + 3) = (gen_data_value >> 24) & 0x000000FF;
+	}
+	if (remain_byte_count) {
+		gen_data_value = REG_READ(gen_data_reg);
+		for (i = 0; i < remain_byte_count; i++) {
+			*(data + dword_count * 4 + i)  =
+				(gen_data_value >> (8 * i)) & 0x000000FF;
+		}
+	}
+
+	mutex_unlock(&sender->lock);
+
+	return len;
+}
+
+static int dsi_read_gen(struct dsi_pkg_sender *sender,
+				u8 param0,
+				u8 param1,
+				u8 param_num,
+				u8 *data,
+				u32 len,
+				u8 transmission)
+{
+	struct dsi_pkg *pkg;
+
+	mutex_lock(&sender->lock);
+
+	pkg = pkg_sender_get_pkg_locked(sender);
+
+	mutex_unlock(&sender->lock);
+
+	if (!pkg) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	switch (param_num) {
+	case 0:
+		pkg->pkg_type = DSI_PKG_GEN_READ_0;
+		pkg->pkg.short_pkg.cmd = 0;
+		pkg->pkg.short_pkg.param = 0;
+		break;
+	case 1:
+		pkg->pkg_type = DSI_PKG_GEN_READ_1;
+		pkg->pkg.short_pkg.cmd = param0;
+		pkg->pkg.short_pkg.param = 0;
+		break;
+	case 2:
+		pkg->pkg_type = DSI_PKG_GEN_READ_2;
+		pkg->pkg.short_pkg.cmd = param0;
+		pkg->pkg.short_pkg.param = param1;
+		break;
+	}
+
+	pkg->transmission_type = transmission;
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	return __read_panel_data(sender, pkg, data, len);
+}
+
+static int dsi_read_mcs(struct dsi_pkg_sender *sender,
+				u8 cmd,
+				u8 *data,
+				u32 len,
+				u8 transmission)
+{
+	struct dsi_pkg *pkg;
+
+	mutex_lock(&sender->lock);
+
+	pkg = pkg_sender_get_pkg_locked(sender);
+
+	mutex_unlock(&sender->lock);
+
+	if (!pkg) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	pkg->pkg_type = DSI_PKG_MCS_READ;
+	pkg->pkg.short_pkg.cmd = cmd;
+	pkg->pkg.short_pkg.param = 0;
+
+	pkg->transmission_type = transmission;
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	return __read_panel_data(sender, pkg, data, len);
+}
+
+static int dsi_send_dpi_spk_pkg(struct dsi_pkg_sender *sender,
+				u32 spk_pkg,
+				u8 transmission)
+{
+	struct dsi_pkg *pkg;
+
+	mutex_lock(&sender->lock);
+
+	pkg = pkg_sender_get_pkg_locked(sender);
+
+	mutex_unlock(&sender->lock);
+
+	if (!pkg) {
+		pr_err("No memory\n");
+		return -ENOMEM;
+	}
+
+	pkg->pkg_type = DSI_DPI_SPK;
+	pkg->transmission_type = transmission;
+	pkg->pkg.spk_pkg.cmd = spk_pkg;
+
+	INIT_LIST_HEAD(&pkg->entry);
+
+	pkg_sender_queue_pkg(sender, pkg, 0);
+
+	return 0;
+}
+
+int dsi_cmds_kick_out(struct dsi_pkg_sender *sender)
+{
+	return process_pkg_list(sender);
+}
+
+int dsi_status_check(struct dsi_pkg_sender *sender)
+{
+	return dsi_error_handler(sender);
+}
+
+int dsi_check_fifo_empty(struct dsi_pkg_sender *sender)
+{
+	if (!sender) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	if (!sender->dbi_pkg_support) {
+		pr_err("No DBI pkg sending on this sender\n");
+		return -ENOTSUPP;
+	}
+
+	/* FIXME: need to check DPI_FIFO_EMPTY as well? */
+	return REG_READ(sender->mipi_gen_fifo_stat_reg) & DBI_FIFO_EMPTY;
+}
+
+int dsi_send_dcs(struct dsi_pkg_sender *sender,
+			u8 dcs, u8 *param, u32 param_num, u8 data_src,
+			int delay)
+{
+	u32 cb_phy;
+	u32 index = 0;
+	u8 *cb;
+	int retry = 1;
+	u8 *dst = NULL;
+	u8 *pSendparam = NULL;
+	int err = 0;
+	int i;
+	int loop_num = 1;
+	int offset = 0;
+
+	if (!sender) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	cb_phy = sender->dbi_cb_phy;
+	cb = (u8 *)sender->dbi_cb_addr;
+
+	if (!sender->dbi_pkg_support) {
+		pr_err("No DBI pkg sending on this sender\n");
+		return -ENOTSUPP;
+	}
+
+	/*
+	 * If dcs is write_mem_start, send it directly using
+	 * DSI adapter interface
+	 */
+	if (dcs == write_mem_start) {
+
+		/**
+		 * query whether DBI FIFO is empty,
+		 * if not sleep the drv and wait for it to become empty.
+		 * The MIPI frame done interrupt will wake up the drv.
+		 */
+		mutex_lock(&sender->lock);
+		for (i = 0; i < loop_num; i++) {
+			if (i != 0)
+				offset = MIPI_C_REG_OFFSET;
+
+			retry = DSI_DBI_FIFO_TIMEOUT;
+			while (retry &&
+				!(REG_READ(
+				sender->mipi_gen_fifo_stat_reg + offset) &
+				DBI_FIFO_EMPTY)) {
+				udelay(500);
+				retry--;
+			}
+
+			/*if DBI FIFO timeout, drop this frame*/
+			if (!retry) {
+				pr_err("DBI FIFO timeout, drop frame\n");
+				mutex_unlock(&sender->lock);
+				if (!IS_ANN()) {
+					debug_dbi_hang(sender);
+					panic("DBI FIFO timeout, drop frame\n");
+				}
+				return -EIO;
+			}
+
+			if (i != 0)
+				sender->work_for_slave_panel = true;
+
+			/*wait for generic fifo*/
+			if (REG_READ(MIPIA_HS_LS_DBI_ENABLE_REG + offset) &
+				DBI_HS_LS_SWITCH_RE)
+				wait_for_lp_fifos_empty(sender);
+			else
+				wait_for_hs_fifos_empty(sender);
+			sender->work_for_slave_panel = false;
+		}
+
+		/*record the last screen update timestamp*/
+		atomic64_set(&sender->last_screen_update,
+			atomic64_read(&sender->te_seq));
+		*(cb + (index++)) = write_mem_start;
+
+		/* Set write_mem_start to mipi C first */
+		REG_WRITE(sender->mipi_cmd_len_reg, 1);
+		REG_WRITE(sender->mipi_cmd_addr_reg,
+			cb_phy | CMD_DATA_MODE | CMD_VALID);
+
+		retry = DSI_DBI_FIFO_TIMEOUT;
+		while (retry && (REG_READ(sender->mipi_cmd_addr_reg) &
+				 CMD_VALID)) {
+			udelay(1);
+			retry--;
+		}
+		mutex_unlock(&sender->lock);
+		return 0;
+	}
+
+	if (param_num == 0)
+		err =  dsi_send_mcs_short_hs(sender, dcs, 0, 0, delay);
+	else if (param_num == 1)
+		err =  dsi_send_mcs_short_hs(sender, dcs, param[0], 1,
+				delay);
+	else if (param_num > 1) {
+		/*transfer to dcs package*/
+		pSendparam = kmalloc(sizeof(u8) * (param_num + 1), GFP_KERNEL);
+		if (!pSendparam) {
+			pr_err("No memory\n");
+			return -ENOMEM;
+		}
+
+		(*pSendparam) = dcs;
+
+		dst = pSendparam + 1;
+		memcpy(dst, param, param_num);
+
+		err = dsi_send_mcs_long_hs(sender, pSendparam,
+				param_num + 1, delay);
+
+		/*free pkg*/
+		kfree(pSendparam);
+	}
+
+	return err;
+}
+
+/* FIXME: to use another sender to issue write_mem_start. */
+int dsi_send_dual_dcs(struct dsi_pkg_sender *sender,
+			u8 dcs, u8 *param, u32 param_num, u8 data_src,
+			int delay, bool is_dual_link)
+{
+	u32 cb_phy;
+	u32 index = 0;
+	u8 *cb;
+	int retry = 1;
+	int i;
+	int loop_num = 1;
+	int offset = 0;
+
+	if (!sender) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	cb_phy = sender->dbi_cb_phy;
+	cb = (u8 *)sender->dbi_cb_addr;
+
+	if (!sender->dbi_pkg_support) {
+		pr_err("No DBI pkg sending on this sender\n");
+		return -ENOTSUPP;
+	}
+
+	/**
+	 * query whether DBI FIFO is empty,
+	 * if not sleep the drv and wait for it to become empty.
+	 * The MIPI frame done interrupt will wake up the drv.
+	 */
+	if (is_dual_link)
+		loop_num = 2;
+	mutex_lock(&sender->lock);
+	for (i = 0; i < loop_num; i++) {
+		if (i != 0)
+			offset = MIPI_C_REG_OFFSET;
+
+		retry = DSI_DBI_FIFO_TIMEOUT;
+		while (retry &&
+			!(REG_READ(sender->mipi_gen_fifo_stat_reg + offset) &
+			DBI_FIFO_EMPTY)) {
+			udelay(500);
+			retry--;
+		}
+
+		/*if DBI FIFO timeout, drop this frame*/
+		if (!retry) {
+			pr_err("DBI FIFO timeout, drop frame\n");
+			mutex_unlock(&sender->lock);
+			if (!IS_ANN()) {
+				debug_dbi_hang(sender);
+				panic("DBI FIFO timeout, drop frame\n");
+			}
+			return -EIO;
+		}
+
+		if (i != 0)
+			sender->work_for_slave_panel = true;
+
+		/*wait for generic fifo*/
+		if (REG_READ(MIPIA_HS_LS_DBI_ENABLE_REG + offset) &
+			DBI_HS_LS_SWITCH_RE)
+			wait_for_lp_fifos_empty(sender);
+		else
+			wait_for_hs_fifos_empty(sender);
+		sender->work_for_slave_panel = false;
+	}
+
+	/*record the last screen update timestamp*/
+	atomic64_set(&sender->last_screen_update,
+			atomic64_read(&sender->te_seq));
+	*(cb + (index++)) = write_mem_start;
+
+	pr_info("--> Sending write_mem_start\n");
+
+	/* Set write_mem_start to mipi C first */
+	if (is_dual_link)
+		REG_WRITE(sender->mipi_cmd_len_reg + MIPI_C_REG_OFFSET, 1);
+	REG_WRITE(sender->mipi_cmd_len_reg, 1);
+	if (is_dual_link)
+		REG_WRITE(sender->mipi_cmd_addr_reg + MIPI_C_REG_OFFSET,
+			cb_phy | CMD_DATA_MODE | CMD_VALID);
+	REG_WRITE(sender->mipi_cmd_addr_reg,
+		cb_phy | CMD_DATA_MODE | CMD_VALID);
+
+	if (is_dual_link) {
+		retry = DSI_DBI_FIFO_TIMEOUT;
+		while (retry &&
+			(REG_READ(
+			sender->mipi_cmd_addr_reg + MIPI_C_REG_OFFSET) &
+			CMD_VALID)) {
+			udelay(1);
+			retry--;
+		}
+	}
+
+	retry = DSI_DBI_FIFO_TIMEOUT;
+	while (retry && (REG_READ(sender->mipi_cmd_addr_reg) & CMD_VALID)) {
+		udelay(1);
+		retry--;
+	}
+	mutex_unlock(&sender->lock);
+	return 0;
+}
+
+int dsi_send_mcs_short_hs(struct dsi_pkg_sender *sender,
+				u8 cmd, u8 param, u8 param_num, int delay)
+{
+	if (!sender) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_mcs_short(sender, cmd, param, param_num,
+			DSI_HS_TRANSMISSION, delay);
+}
+
+int dsi_send_mcs_short_lp(struct dsi_pkg_sender *sender,
+				u8 cmd, u8 param, u8 param_num, int delay)
+{
+	if (!sender) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_mcs_short(sender, cmd, param, param_num,
+			DSI_LP_TRANSMISSION, delay);
+}
+
+int dsi_send_mcs_long_hs(struct dsi_pkg_sender *sender,
+				u8 *data,
+				u32 len,
+				int delay)
+{
+	if (!sender || !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_mcs_long(sender, data, len,
+			DSI_HS_TRANSMISSION, delay);
+}
+
+int dsi_send_mcs_long_lp(struct dsi_pkg_sender *sender,
+				u8 *data,
+				u32 len,
+				int delay)
+{
+	if (!sender || !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_mcs_long(sender, data, len,
+			DSI_LP_TRANSMISSION, delay);
+}
+
+int dsi_send_gen_short_hs(struct dsi_pkg_sender *sender,
+				u8 param0, u8 param1, u8 param_num, int delay)
+{
+	if (!sender) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_gen_short(sender, param0, param1, param_num,
+			DSI_HS_TRANSMISSION, delay);
+}
+
+int dsi_send_gen_short_lp(struct dsi_pkg_sender *sender,
+				u8 param0, u8 param1, u8 param_num, int delay)
+{
+	if (!sender || param_num < 0 || param_num > 2) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_gen_short(sender, param0, param1, param_num,
+			DSI_LP_TRANSMISSION, delay);
+}
+
+int dsi_send_gen_long_hs(struct dsi_pkg_sender *sender,
+				u8 *data,
+				u32 len,
+				int delay)
+{
+	if (!sender || !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_gen_long(sender, data, len,
+			DSI_HS_TRANSMISSION, delay);
+}
+
+int dsi_send_gen_long_lp(struct dsi_pkg_sender *sender,
+				u8 *data,
+				u32 len,
+				int delay)
+{
+	if (!sender || !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_gen_long(sender, data, len,
+			DSI_LP_TRANSMISSION, delay);
+}
+
+int dsi_read_gen_hs(struct dsi_pkg_sender *sender,
+			u8 param0,
+			u8 param1,
+			u8 param_num,
+			u8 *data,
+			u32 len)
+{
+	if (!sender || !data || param_num < 0 || param_num > 2
+		|| !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_read_gen(sender, param0, param1, param_num,
+				data, len, DSI_HS_TRANSMISSION);
+
+}
+
+int dsi_read_gen_lp(struct dsi_pkg_sender *sender,
+			u8 param0,
+			u8 param1,
+			u8 param_num,
+			u8 *data,
+			u32 len)
+{
+	if (!sender || !data || param_num < 0 || param_num > 2
+		|| !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_read_gen(sender, param0, param1, param_num,
+				data, len, DSI_LP_TRANSMISSION);
+}
+
+int dsi_read_mcs_hs(struct dsi_pkg_sender *sender,
+			u8 cmd,
+			u8 *data,
+			u32 len)
+{
+	if (!sender || !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_read_mcs(sender, cmd, data, len,
+				DSI_HS_TRANSMISSION);
+}
+EXPORT_SYMBOL(dsi_read_mcs_hs);
+
+int dsi_read_mcs_lp(struct dsi_pkg_sender *sender,
+			u8 cmd,
+			u8 *data,
+			u32 len)
+{
+	if (!sender || !data || !len) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_read_mcs(sender, cmd, data, len,
+				DSI_LP_TRANSMISSION);
+}
+
+int dsi_send_dpi_spk_pkg_hs(struct dsi_pkg_sender *sender,
+				u32 spk_pkg)
+{
+	if (!sender) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_dpi_spk_pkg(sender, spk_pkg,
+				DSI_HS_TRANSMISSION);
+}
+
+int dsi_send_dpi_spk_pkg_lp(struct dsi_pkg_sender *sender,
+				u32 spk_pkg)
+{
+	if (!sender) {
+		pr_err("Invalid parameters\n");
+		return -EINVAL;
+	}
+
+	return dsi_send_dpi_spk_pkg(sender, spk_pkg,
+				DSI_LP_TRANSMISSION);
+}
+
+int dsi_wait_for_fifos_empty(struct dsi_pkg_sender *sender)
+{
+	return wait_for_all_fifos_empty(sender);
+}
+
+void dsi_report_te(struct dsi_pkg_sender *sender)
+{
+	if (sender)
+		atomic64_inc(&sender->te_seq);
+}
+
+int dsi_pkg_sender_init(struct dsi_pkg_sender *sender, u32 gtt_phy_addr,
+	int type, int pipe)
+{
+	int ret;
+	struct dsi_pkg *pkg, *tmp;
+	int i;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Invalid parameter\n");
+		return -EINVAL;
+	}
+
+	memset(sender, 0, sizeof(struct dsi_pkg_sender));
+
+	sender->pipe = pipe;
+	sender->pkg_num = 0;
+	sender->panel_mode = 0;
+	sender->status = DSI_PKG_SENDER_FREE;
+
+	/*int dbi command buffer*/
+	if (type == DSI_DBI) {
+		sender->dbi_pkg_support = 1;
+		ret = dbi_cb_init(sender, gtt_phy_addr, pipe);
+		if (ret) {
+			pr_err("DBI command buffer map failed\n");
+			goto mapping_err;
+		}
+	}
+
+	/*init regs*/
+	if (pipe == 0) {
+		sender->dpll_reg = DPLL_CTRL_A;
+		sender->dspcntr_reg = DSPACNTR;
+		sender->pipeconf_reg = PIPEACONF;
+		sender->dsplinoff_reg = DSPALINOFF;
+		sender->dspsurf_reg = DSPASURF;
+		sender->pipestat_reg = PIPEASTAT;
+
+		sender->mipi_intr_stat_reg = MIPIA_INTR_STAT_REG;
+		sender->mipi_lp_gen_data_reg = MIPIA_LP_GEN_DATA_REG;
+		sender->mipi_hs_gen_data_reg = MIPIA_HS_GEN_DATA_REG;
+		sender->mipi_lp_gen_ctrl_reg = MIPIA_LP_GEN_CTRL_REG;
+		sender->mipi_hs_gen_ctrl_reg = MIPIA_HS_GEN_CTRL_REG;
+		sender->mipi_gen_fifo_stat_reg = MIPIA_GEN_FIFO_STAT_REG;
+		sender->mipi_data_addr_reg = MIPIA_DATA_ADD;
+		sender->mipi_data_len_reg = MIPIA_DATA_LEN;
+		sender->mipi_cmd_addr_reg = MIPIA_CMD_ADD;
+		sender->mipi_cmd_len_reg = MIPIA_CMD_LEN;
+		sender->mipi_dpi_control_reg = MIPIA_DPI_CTRL_REG;
+	} else if (pipe == 2) {
+		sender->dpll_reg = DPLL_CTRL_A;
+		sender->dspcntr_reg = DSPCCNTR;
+		sender->pipeconf_reg = PIPECCONF;
+		sender->dsplinoff_reg = DSPCLINOFF;
+		sender->dspsurf_reg = DSPCSURF;
+		sender->pipestat_reg = PIPECSTAT;
+
+		sender->mipi_intr_stat_reg = MIPIC_INTR_STAT_REG;
+		sender->mipi_lp_gen_data_reg = MIPIC_LP_GEN_DATA_REG;
+		sender->mipi_hs_gen_data_reg = MIPIC_HS_GEN_DATA_REG;
+		sender->mipi_lp_gen_ctrl_reg = MIPIC_LP_GEN_CTRL_REG;
+		sender->mipi_hs_gen_ctrl_reg = MIPIC_HS_GEN_CTRL_REG;
+		sender->mipi_gen_fifo_stat_reg = MIPIC_GEN_FIFO_STAT_REG;
+		sender->mipi_data_addr_reg = MIPIC_DATA_ADD;
+		sender->mipi_data_len_reg = MIPIC_DATA_LEN;
+		sender->mipi_cmd_addr_reg = MIPIC_CMD_ADD;
+		sender->mipi_cmd_len_reg = MIPIC_CMD_LEN;
+		sender->mipi_dpi_control_reg = MIPIC_DPI_CTRL_REG;
+	}
+
+	/*init pkg list*/
+	INIT_LIST_HEAD(&sender->pkg_list);
+	INIT_LIST_HEAD(&sender->free_list);
+
+	/*init lock*/
+	mutex_init(&sender->lock);
+
+	/*allocate free pkg pool*/
+	for (i = 0; i < MAX_PKG_NUM; i++) {
+		pkg = kzalloc(sizeof(struct dsi_pkg), GFP_KERNEL);
+		if (!pkg) {
+			ret = -ENOMEM;
+			goto pkg_alloc_err;
+		}
+
+		INIT_LIST_HEAD(&pkg->entry);
+
+		/*append to free list*/
+		list_add_tail(&pkg->entry, &sender->free_list);
+	}
+
+	/*init te & screen update seqs*/
+	atomic64_set(&sender->te_seq, 0);
+	atomic64_set(&sender->last_screen_update, 0);
+
+	pr_debug("initialized\n");
+
+	return 0;
+
+pkg_alloc_err:
+	list_for_each_entry_safe(pkg, tmp, &sender->free_list, entry) {
+		list_del(&pkg->entry);
+		kfree(pkg);
+	}
+
+	/*free mapped command buffer*/
+	dbi_cb_destroy(sender);
+mapping_err:
+	return ret;
+}
+
+void dsi_pkg_sender_destroy(struct dsi_pkg_sender *sender)
+{
+	struct dsi_pkg *pkg, *tmp;
+
+	if (!sender || IS_ERR(sender))
+		return;
+
+	/*free pkg pool*/
+	list_for_each_entry_safe(pkg, tmp, &sender->free_list, entry) {
+		list_del(&pkg->entry);
+		kfree(pkg);
+	}
+
+	/*free pkg list*/
+	list_for_each_entry_safe(pkg, tmp, &sender->pkg_list, entry) {
+		list_del(&pkg->entry);
+		kfree(pkg);
+	}
+
+	/*free mapped command buffer*/
+	dbi_cb_destroy(sender);
+
+	pr_debug("destroyed\n");
+}
+
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/cmi_7x12_cmd.c b/drivers/video/adf/intel/core/common/dsi/panels/cmi_7x12_cmd.c
new file mode 100644
index 0000000..c2a0732
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/cmi_7x12_cmd.c
@@ -0,0 +1,738 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include <linux/gpio.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/intel_pmic.h>
+#include <linux/regulator/machine.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pipe.h"
+
+#include "pwr_mgmt.h"
+
+#define CMI_CMD_PHY_WIDTH	53
+#define CMI_CMD_PHY_HEIGHT	95
+#define CMI_CMD_BPP		24
+#define CMI_CMD_DSI_TYPE	DSI_DBI
+#define CMI_CMD_LANE_NUM	3
+
+/* The register to control secure I2C FLIS pin */
+#define SECURE_I2C_FLIS_REG	0xFF0C1D30
+
+static int mipi_reset_gpio;
+
+static u8 cmi_exit_sleep_mode[] = {0x11};
+static u8 cmi_set_tear_on[] = {0x35, 0x00};
+static u8 cmi_set_brightness[] = {0x51, 0x00};
+static u8 cmi_turn_on_backlight[] = {0x53, 0x24};
+static u8 cmi_turn_off_backlight[] = {0x53, 0x00};
+static u8 cmi_set_mipi_ctrl[] = {
+	0xba, 0x12, 0x83, 0x00,
+	0xd6, 0xc5, 0x00, 0x09,
+	0xff, 0x0f, 0x27, 0x03,
+	0x21, 0x27, 0x25, 0x20,
+	0x00, 0x10};
+static u8 cmi_command_mode[] = {0xc2, 0x08};
+static u8 cmi_set_panel[] = {0xcc, 0x08};
+static u8 cmi_set_eq_func_ltps[] = {0xd4, 0x0c};
+static u8 cmi_set_address_mode[] = {0x36, 0x00};
+static u8 cmi_set_te_scanline[] = {0x44, 0x00, 0x00, 0x00};
+static u8 cmi_set_pixel_format[] = {0x3a, 0x77};
+static u8 cmi_mcs_protect_off[] = {0xb9, 0xff, 0x83, 0x92};
+static u8 cmi_mcs_protect_on[] = {0xb9, 0x00, 0x00, 0x00};
+static u8 cmi_set_blanking_opt_2[] = {0xc7, 0x00, 0x40};
+static u8 cmi_mcs_clumn_addr[] = {0x2a, 0x00, 0x00, 0x02, 0xcf};
+static u8 cmi_mcs_page_addr[] = {0x2b, 0x00, 0x00, 0x04, 0xff};
+static u8 cmi_ic_bias_current[] = {0xbf, 0x05, 0xe0, 0x02, 0x00};
+static u8 cmi_set_power[] = {
+	0xb1, 0x7c, 0x00, 0x44,
+	0x94, 0x00, 0x0d, 0x0d,
+	0x12, 0x1f, 0x3f, 0x3f,
+	0x42, 0x72};
+static u8 cmi_set_power_dstb[] = {
+	0xb1, 0x01, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00};
+static u8 cmi_set_disp_reg[] = {
+	0xb2, 0x0f, 0xc8, 0x01,
+	0x01, 0x06, 0x84, 0x00,
+	0xff, 0x01, 0x01, 0x06,
+	0x20};
+static u8 cmi_set_command_cyc[] = {
+	0xb4, 0x00, 0x00, 0x05,
+	0x00, 0xa0, 0x05, 0x16,
+	0x9d, 0x30, 0x03, 0x16,
+	0x00, 0x03, 0x03, 0x00,
+	0x1b, 0x04, 0x07, 0x07,
+	0x01, 0x00, 0x1a, 0x77};
+static u8 cmi_set_ltps_ctrl_output[] = {
+	0xd5, 0x00, 0x08, 0x08,
+	0x00, 0x44, 0x55, 0x66,
+	0x77, 0xcc, 0xcc, 0xcc,
+	0xcc, 0x00, 0x77, 0x66,
+	0x55, 0x44, 0xcc, 0xcc,
+	0xcc, 0xcc};
+static u8 cmi_set_video_cyc[] = {
+	0xd8, 0x00, 0x00, 0x05,
+	0x00, 0xa0, 0x05, 0x16,
+	0x9d, 0x30, 0x03, 0x16,
+	0x00, 0x03, 0x03, 0x00,
+	0x1b, 0x04, 0x07, 0x07,
+	0x01, 0x00, 0x1a, 0x77};
+static u8 cmi_gamma_r[] = {
+	0xe0, 0x00, 0x1f, 0x23,
+	0x3f, 0x3f, 0x3f, 0x33,
+	0x55, 0x06, 0x0e, 0x0e,
+	0x11, 0x14, 0x12, 0x14,
+	0x1d, 0x1f, 0x00, 0x1f,
+	0x23, 0x3f, 0x3f, 0x3f,
+	0x33, 0x55, 0x06, 0x0e,
+	0x0e, 0x11, 0x14, 0x12,
+	0x14, 0x1d, 0x1f};
+static u8 cmi_gamma_g[] = {
+	0xe1, 0x00, 0x1f, 0x23,
+	0x3f, 0x3f, 0x3f, 0x33,
+	0x55, 0x06, 0x0e, 0x0e,
+	0x11, 0x14, 0x12, 0x14,
+	0x1d, 0x1f, 0x00, 0x1f,
+	0x23, 0x3f, 0x3f, 0x3f,
+	0x33, 0x55, 0x06, 0x0e,
+	0x0e, 0x11, 0x14, 0x12,
+	0x14, 0x1d, 0x1f};
+static u8 cmi_gamma_b[] = {
+	0xe2, 0x00, 0x1f, 0x23,
+	0x3f, 0x3f, 0x3f, 0x33,
+	0x55, 0x06, 0x0e, 0x0e,
+	0x11, 0x14, 0x12, 0x14,
+	0x1d, 0x1f, 0x00, 0x1f,
+	0x23, 0x3f, 0x3f, 0x3f,
+	0x33, 0x55, 0x06, 0x0e,
+	0x0e, 0x11, 0x14, 0x12,
+	0x14, 0x1d, 0x1f};
+static u8 cmi_enter_set_cabc[] = {
+	0xc9, 0x1f, 0x00, 0x1e,
+	0x1e, 0x00, 0x20, 0x00,
+	0x01, 0xe3};
+static u8 cmi_set_stba[] = {0xc0, 0x01, 0x94};
+
+static int cmi_cmd_drv_ic_init(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender;
+	struct dsi_registers *regs;
+
+	if (!pipe)
+		return -EINVAL;
+
+	sender = &pipe->sender;
+	regs = &pipe->config.regs;
+
+	pr_debug("\n");
+	sender->status = DSI_PKG_SENDER_FREE;
+
+	/* swtich to 2 data lanes */
+	REG_WRITE(regs->device_ready_reg, 0x0);
+	udelay(1);
+	REG_WRITE(regs->dsi_func_prg_reg, DBI_16BIT_IF_OPTION_2 | DATA_LANES_2);
+	udelay(1);
+	REG_WRITE(regs->device_ready_reg, DEVICE_READY);
+	udelay(1);
+
+	dsi_send_mcs_short_hs(sender, cmi_exit_sleep_mode[0], 0, 0, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	mdelay(150);
+
+	dsi_send_mcs_long_hs(sender, cmi_mcs_protect_off, 4, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_ic_bias_current, 5, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_power, 14, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_disp_reg, 13, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_command_cyc, 24, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_mipi_ctrl, 3, 0);
+
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	/* switch back to 3 data lanes */
+	dsi_wait_for_fifos_empty(sender);
+	REG_WRITE(regs->device_ready_reg, 0x0);
+	udelay(1);
+	REG_WRITE(regs->dsi_func_prg_reg, DBI_16BIT_IF_OPTION_2 | DATA_LANES_3);
+	udelay(1);
+	REG_WRITE(regs->device_ready_reg, DEVICE_READY);
+
+	dsi_send_mcs_long_hs(sender, cmi_set_stba, 3, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_short_hs(sender, cmi_command_mode[0],
+			cmi_command_mode[1], 1, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_blanking_opt_2,
+			sizeof(cmi_set_blanking_opt_2), 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_short_hs(sender, cmi_set_panel[0],
+			cmi_set_panel[1], 1, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_short_hs(sender, cmi_set_eq_func_ltps[0],
+			cmi_set_eq_func_ltps[1], 1, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_ltps_ctrl_output, 22, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_video_cyc, 24, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_gamma_r, 35, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_gamma_g, 35, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_gamma_b, 35, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_short_hs(sender, cmi_set_pixel_format[0],
+			cmi_set_pixel_format[1], 1, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_mcs_clumn_addr, 5, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_mcs_page_addr, 5, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_short_hs(sender, cmi_set_address_mode[0],
+	cmi_set_address_mode[1], 1, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_set_te_scanline, 4, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_short_hs(sender, cmi_set_tear_on[0],
+			cmi_set_tear_on[1], 1, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	dsi_send_mcs_long_hs(sender, cmi_enter_set_cabc, 10, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	/* set backlight on*/
+	dsi_send_mcs_short_hs(sender,
+		cmi_turn_on_backlight[0],
+		cmi_turn_on_backlight[1], 1 , 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+
+	/* turn CABC on*/
+	dsi_send_mcs_short_hs(sender,
+			write_ctrl_cabc, STILL_IMAGE, 1,
+			DSI_SEND_PACKAGE);
+
+	dsi_send_mcs_long_hs(sender, cmi_mcs_protect_on, 4, 0);
+	if (sender->status == DSI_CONTROL_ABNORMAL)
+		return -EIO;
+	mdelay(5);
+	return 0;
+}
+
+static void cmi_cmd_dsi_controller_init(struct dsi_pipe *pipe)
+{
+
+	struct dsi_context *hw_ctx = &pipe->config.ctx;
+#ifdef ENABLE_CSC_GAMMA /*FIXME*/
+
+	struct csc_setting csc = {
+		.pipe = 0,
+		.type = CSC_REG_SETTING,
+		.enable_state = true,
+		.data_len = CSC_REG_COUNT,
+		.data.csc_reg_data = {
+			0xFFB0424, 0xFDF, 0x4320FF1, 0xFDC, 0xFF50FF5, 0x415}
+	};
+	struct gamma_setting gamma = {
+		.pipe = 0,
+		.type = GAMMA_REG_SETTING,
+		.enable_state = true,
+		.data_len = GAMMA_10_BIT_TABLE_COUNT,
+		.gamma_tableX100 = {
+			0x000000, 0x030303, 0x050505, 0x070707,
+			0x090909, 0x0C0C0C, 0x0E0E0E, 0x101010,
+			0x121212, 0x141414, 0x171717, 0x191919,
+			0x1B1B1B, 0x1D1D1D, 0x1F1F1F, 0x212121,
+			0x232323, 0x252525, 0x282828, 0x2A2A2A,
+			0x2C2C2C, 0x2E2E2E, 0x303030, 0x323232,
+			0x343434, 0x363636, 0x383838, 0x3A3A3A,
+			0x3C3C3C, 0x3E3E3E, 0x404040, 0x424242,
+			0x444444, 0x464646, 0x484848, 0x4A4A4A,
+			0x4C4C4C, 0x4E4E4E, 0x505050, 0x525252,
+			0x545454, 0x565656, 0x585858, 0x5A5A5A,
+			0x5C5C5C, 0x5E5E5E, 0x606060, 0x626262,
+			0x646464, 0x666666, 0x686868, 0x6A6A6A,
+			0x6C6C6C, 0x6E6E6E, 0x707070, 0x727272,
+			0x747474, 0x767676, 0x787878, 0x7A7A7A,
+			0x7C7C7C, 0x7E7E7E, 0x808080, 0x828282,
+			0x848484, 0x868686, 0x888888, 0x8A8A8A,
+			0x8C8C8C, 0x8E8E8E, 0x909090, 0x929292,
+			0x949494, 0x969696, 0x989898, 0x999999,
+			0x9B9B9B, 0x9D9D9D, 0x9F9F9F, 0xA1A1A1,
+			0xA3A3A3, 0xA5A5A5, 0xA7A7A7, 0xA9A9A9,
+			0xABABAB, 0xADADAD, 0xAFAFAF, 0xB1B1B1,
+			0xB3B3B3, 0xB5B5B5, 0xB6B6B6, 0xB8B8B8,
+			0xBABABA, 0xBCBCBC, 0xBEBEBE, 0xC0C0C0,
+			0xC2C2C2, 0xC4C4C4, 0xC6C6C6, 0xC8C8C8,
+			0xCACACA, 0xCCCCCC, 0xCECECE, 0xCFCFCF,
+			0xD1D1D1, 0xD3D3D3, 0xD5D5D5, 0xD7D7D7,
+			0xD9D9D9, 0xDBDBDB, 0xDDDDDD, 0xDFDFDF,
+			0xE1E1E1, 0xE3E3E3, 0xE4E4E4, 0xE6E6E6,
+			0xE8E8E8, 0xEAEAEA, 0xECECEC, 0xEEEEEE,
+			0xF0F0F0, 0xF2F2F2, 0xF4F4F4, 0xF6F6F6,
+			0xF7F7F7, 0xF9F9F9, 0xFBFBFB, 0xFDFDFD}
+	};
+#endif
+
+	pr_debug("\n");
+
+	/*reconfig lane configuration*/
+	pipe->config.lane_count = 3;
+	pipe->config.lane_config = DSI_DATA_LANE_3_1;
+	pipe->config.enable_gamma_csc = ENABLE_GAMMA | ENABLE_CSC;
+	/* This is for 400 mhz.  Set it to 0 for 800mhz */
+	hw_ctx->cck_div = 1;
+	hw_ctx->pll_bypass_mode = 0;
+
+	hw_ctx->mipi_control = 0x0;
+	hw_ctx->intr_en = 0xFFFFFFFF;
+	hw_ctx->hs_tx_timeout = 0xFFFFFF;
+	hw_ctx->lp_rx_timeout = 0xFFFFFF;
+	hw_ctx->turn_around_timeout = 0x1f;
+	hw_ctx->device_reset_timer = 0xffff;
+	hw_ctx->high_low_switch_count = 0x20;
+	hw_ctx->clk_lane_switch_time_cnt = 0x20000E;
+	hw_ctx->eot_disable = CLOCK_STOP | EOT_DIS;
+	hw_ctx->init_count = 0xf0;
+	hw_ctx->lp_byteclk = 0x4;
+	hw_ctx->dphy_param = 0x1B104315;
+	hw_ctx->dbi_bw_ctrl = 1390;
+	hw_ctx->hs_ls_dbi_enable = 0x0;
+	hw_ctx->dsi_func_prg = DBI_16BIT_IF_OPTION_2 | pipe->config.lane_count;
+	hw_ctx->mipi = SEL_FLOPPED_HSTX | LP_OUTPUT_HOLD_ENABLE |
+		BANDGAP_CHICKEN_BIT | TE_TRIGGER_BY_GPIO;
+	hw_ctx->video_mode_format = DISABLE_VIDEO_BTA | IP_TG_CONFIG |
+				    BURST_MODE;
+
+#ifdef ENABLE_CSC_GAMMA /*FIXME*/
+	if (pipe->config.enable_gamma_csc & ENABLE_CSC) {
+		/* setting the tuned csc setting */
+		drm_psb_enable_color_conversion = 1;
+		intel_crtc_set_color_conversion(dev, &csc);
+	}
+
+	if (pipe->config.enable_gamma_csc & ENABLE_GAMMA) {
+		/* setting the tuned gamma setting */
+		drm_psb_enable_gamma = 1;
+		intel_crtc_set_gamma(dev, &gamma);
+	}
+#endif
+}
+
+static int cmi_cmd_get_config_mode(struct drm_mode_modeinfo *mode)
+{
+	pr_debug("\n");
+
+	if (!mode)
+		return -EINVAL;
+
+	mode->htotal = 920;
+	mode->hdisplay = 720;
+	mode->hsync_start = 816;
+	mode->hsync_end = 824;
+	mode->vtotal = 1300;
+	mode->vdisplay = 1280;
+	mode->vsync_start = 1294;
+	mode->vsync_end = 1296;
+	mode->vrefresh = 60;
+	mode->clock =  mode->vrefresh * mode->vtotal * mode->htotal / 1000;
+
+	adf_modeinfo_set_name(mode);
+
+	return 0;
+}
+
+static int cmi_cmd_power_on(struct dsi_pipe *pipe)
+{
+
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err = 0;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	/*exit sleep */
+	err = dsi_send_dcs(sender,
+		 exit_sleep_mode,
+		 NULL,
+		 0,
+		 CMD_DATA_SRC_SYSTEM_MEM,
+		 DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("faild to exit_sleep mode\n");
+		goto power_err;
+	}
+
+	msleep(120);
+
+	/*set tear on*/
+	err = dsi_send_dcs(sender,
+		 set_tear_on,
+		 NULL,
+		 0,
+		 CMD_DATA_SRC_SYSTEM_MEM,
+		 DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("faild to set_tear_on mode\n");
+		goto power_err;
+	}
+
+	/*turn on display*/
+	err = dsi_send_dcs(sender,
+		 set_display_on,
+		 NULL,
+		 0,
+		 CMD_DATA_SRC_SYSTEM_MEM,
+		 DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("faild to set_display_on mode\n");
+		goto power_err;
+	}
+power_err:
+	return err;
+}
+
+static int cmi_cmd_power_off(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err = 0;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	/* turn off cabc */
+	err = dsi_send_mcs_short_hs(sender,
+		write_ctrl_cabc, 0, 1,
+		DSI_SEND_PACKAGE);
+
+	/*turn off backlight*/
+	err = dsi_send_mcs_long_hs(sender, cmi_turn_off_backlight,
+					 sizeof(cmi_turn_off_backlight), 0);
+	if (err) {
+		pr_err("%s: failed to turn off backlight\n", __func__);
+		goto out;
+	}
+	mdelay(1);
+
+
+	/*turn off display */
+	err = dsi_send_dcs(sender,
+		 set_display_off,
+		 NULL,
+		 0,
+		 CMD_DATA_SRC_SYSTEM_MEM,
+		 DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("sent set_display_off faild\n");
+		goto out;
+	}
+
+	/*set tear off */
+	err = dsi_send_dcs(sender,
+		 set_tear_off,
+		 NULL,
+		 0,
+		 CMD_DATA_SRC_SYSTEM_MEM,
+		 DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("sent set_tear_off faild\n");
+		goto out;
+	}
+
+	/*Enter sleep mode */
+	err = dsi_send_dcs(sender,
+			enter_sleep_mode,
+			NULL,
+			0,
+			CMD_DATA_SRC_SYSTEM_MEM,
+			DSI_SEND_PACKAGE);
+
+	if (err) {
+		pr_err("DCS 0x%x sent failed\n", enter_sleep_mode);
+		goto out;
+	}
+
+	/**
+	 * MIPI spec shows it must wait 5ms
+	 * before sneding next command
+	 */
+	mdelay(5);
+
+	/*enter deep standby mode*/
+	err = dsi_send_mcs_long_hs(sender, cmi_mcs_protect_off, 4, 0);
+	if (err) {
+		pr_err("Failed to turn off protection\n");
+		goto out;
+	}
+
+	err = dsi_send_mcs_long_hs(sender, cmi_set_power_dstb, 14, 0);
+	if (err)
+		pr_err("Failed to enter DSTB\n");
+	mdelay(5);
+	dsi_send_mcs_long_hs(sender, cmi_mcs_protect_on, 4, 0);
+
+out:
+	return err;
+}
+
+static void cmi_cmd_get_panel_info(struct panel_info *pi)
+{
+	pr_debug("\n");
+
+	pi->width_mm = CMI_CMD_PHY_WIDTH;
+	pi->height_mm = CMI_CMD_PHY_HEIGHT;
+	pi->bpp = CMI_CMD_BPP;
+	pi->dsi_type = CMI_CMD_DSI_TYPE;
+	pi->lane_num = CMI_CMD_LANE_NUM;
+	pi->dual_link = DSI_PANEL_SINGLE_LINK;
+}
+
+static int cmi_cmd_detect(struct dsi_pipe *pipe)
+{
+	int status;
+	struct dsi_registers *regs = &pipe->config.regs;
+	u32 dpll_val, device_ready_val;
+	int idx = pipe->config.pipe;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("\n");
+
+	if (idx == 0) {
+		/*
+		 * FIXME: WA to detect the panel connection status, and need to
+		 * implement detection feature with get_power_mode DSI command.
+		 */
+		if (!ospm_power_using_hw_begin(OSPM_DISPLAY_ISLAND,
+					OSPM_UHB_FORCE_POWER_ON)) {
+			pr_err("hw begin failed\n");
+			return -EAGAIN;
+		}
+
+		dpll_val = REG_READ(regs->dpll_reg);
+		device_ready_val = REG_READ(regs->device_ready_reg);
+		if ((device_ready_val & DEVICE_READY) &&
+		    (dpll_val & DPLL_VCO_ENABLE)) {
+			pipe->config.ctx.panel_on = true;
+			dsi_send_gen_long_hs(sender,
+					cmi_mcs_protect_off, 4, 0);
+			dsi_send_gen_long_hs(sender,
+					cmi_set_disp_reg, 13, 0);
+			dsi_send_gen_long_hs(sender,
+					cmi_mcs_protect_on, 4, 0);
+
+		} else {
+			pipe->config.ctx.panel_on = false;
+			pr_info("%s: panel is not initialized!\n", __func__);
+		}
+
+		status = DSI_PANEL_CONNECTED;
+
+		ospm_power_using_hw_end(OSPM_DISPLAY_ISLAND);
+	} else {
+		pr_info("%s: do NOT support dual panel\n", __func__);
+		status = DSI_PANEL_DISCONNECTED;
+	}
+
+	return status;
+}
+
+static int cmi_cmd_set_brightness(struct dsi_pipe *pipe,
+				int level)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int duty_val = 0;
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+	duty_val = (255 * level) / 100;
+	cmi_set_brightness[1] = duty_val;
+
+	dsi_send_mcs_short_hs(sender,
+		cmi_set_brightness[0], cmi_set_brightness[1], 1, 0);
+
+	return 0;
+}
+
+static void __vpro2_power_ctrl(bool on)
+{
+	u8 addr, value;
+	addr = 0xad;
+	if (intel_scu_ipc_ioread8(addr, &value))
+		pr_err("%s: %d: failed to read vPro2\n", __func__, __LINE__);
+
+	/* Control vPROG2 power rail with 2.85v. */
+	if (on)
+		value |= 0x1;
+	else
+		value &= ~0x1;
+
+	if (intel_scu_ipc_iowrite8(addr, value))
+		pr_err("%s: %d: failed to write vPro2\n",
+				__func__, __LINE__);
+}
+static
+void _get_panel_reset_gpio(void)
+{
+	int ret = 0;
+	if (mipi_reset_gpio == 0) {
+		ret = get_gpio_by_name("mipi-reset");
+		if (ret < 0) {
+			pr_err("Faild to get panel reset gpio, use default reset pin\n");
+			return;
+		}
+		mipi_reset_gpio = ret;
+		ret = gpio_request(mipi_reset_gpio, "mipi_display");
+		if (ret) {
+			pr_err("Faild to request panel reset gpio\n");
+			return;
+		}
+		gpio_direction_output(mipi_reset_gpio, 0);
+	}
+}
+
+static int cmi_cmd_panel_reset(struct dsi_pipe *pipe)
+{
+	u8 *vaddr = NULL, *vaddr1 = NULL;
+	int reg_value_scl = 0;
+
+	pr_debug("\n");
+
+	/* Because when reset touchscreen panel, touchscreen will pull i2c bus
+	 * to low, sometime this operation will cause i2c bus enter into wrong
+	 * status, so before reset, switch i2c scl pin */
+	vaddr1 = ioremap(SECURE_I2C_FLIS_REG, 4);
+	reg_value_scl = ioread32(vaddr1);
+	reg_value_scl &= ~0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+					(u8 *)&reg_value_scl, 4,
+					NULL, 0,
+					SECURE_I2C_FLIS_REG, 0);
+
+	__vpro2_power_ctrl(true);
+	usleep_range(2000, 2500);
+
+	_get_panel_reset_gpio();
+	gpio_direction_output(mipi_reset_gpio, 0);
+	gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	usleep_range(2000, 2500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+	usleep_range(3000, 3500);
+	vaddr = ioremap(0xff0c2d00, 0x60);
+	iowrite32(0x3221, vaddr + 0x1c);
+	usleep_range(2000, 2500);
+	iounmap(vaddr);
+	/* switch i2c scl pin back */
+	reg_value_scl |= 0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+					(u8 *)&reg_value_scl, 4,
+					NULL, 0,
+					SECURE_I2C_FLIS_REG, 0);
+	iounmap(vaddr1);
+	return 0;
+}
+
+static struct panel_ops cmi_cmd_panel_ops = {
+	.drv_ic_init = cmi_cmd_drv_ic_init,
+	.dsi_controller_init = cmi_cmd_dsi_controller_init,
+	.detect = cmi_cmd_detect,
+	.power_on = cmi_cmd_power_on,
+	.power_off = cmi_cmd_power_off,
+	.set_brightness = cmi_cmd_set_brightness,
+	.reset = cmi_cmd_panel_reset,
+	.get_config_mode = cmi_cmd_get_config_mode,
+	.exit_deep_standby = 0,
+	.get_panel_info = cmi_cmd_get_panel_info,
+};
+
+static const struct dsi_panel cmi_cmd_panel = {
+	.panel_id = CMI_7x12_CMD,
+	.ops = &cmi_cmd_panel_ops,
+};
+
+const struct dsi_panel *cmi_get_panel(void)
+{
+	return &cmi_cmd_panel;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_cmd.c b/drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_cmd.c
new file mode 100644
index 0000000..24e8119
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_cmd.c
@@ -0,0 +1,640 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include <linux/gpio.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pipe.h"
+
+#include "pwr_mgmt.h"
+
+/*JDI panel info*/
+#define JDI_CMD_PHY_WIDTH	56
+#define JDI_CMD_PHY_HEIGHT	99
+#define JDI_CMD_BPP		24
+#define JDI_CMD_DSI_TYPE	DSI_DBI
+#define JDI_CMD_LANE_NUM	3
+
+/* The register to control secure I2C FLIS pin */
+#define SECURE_I2C_FLIS_REG	0xFF0C1D30
+
+static int mipi_reset_gpio;
+static int bias_en_gpio;
+
+static u8 jdi_mcs_clumn_addr[] = {0x2a, 0x00, 0x00, 0x02, 0xcf};
+static u8 jdi_mcs_page_addr[] = {
+			0x2b, 0x00, 0x00, 0x04, 0xff};
+static u8 jdi_timing_control[] = {
+			0xc6, 0x6d, 0x05, 0x60, 0x05,
+			0x60, 0x01, 0x01, 0x01, 0x02,
+			0x01, 0x02, 0x01, 0x01, 0x01,
+			0x01, 0x01, 0x01, 0x05, 0x15,
+			0x09
+};
+
+static int jdi_cmd_drv_ic_init(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err = 0;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Cannot get sender\n");
+		return -EINVAL;
+	}
+	err = dsi_send_mcs_short_hs(sender,
+			exit_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Exit Sleep Mode\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	msleep(120);
+	err = dsi_send_mcs_short_hs(sender,
+			write_display_brightness, 0x0, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Brightness\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			write_ctrl_display, 0x24, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Write Control Display\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			write_ctrl_cabc, STILL_IMAGE, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Write Control CABC\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	if (!IS_ANN()) {
+		err = dsi_send_mcs_short_hs(sender,
+				write_cabc_min_bright, 51, 1,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Write CABC minimum brightness\n",
+					__func__, __LINE__);
+			goto ic_init_err;
+		}
+		err = dsi_send_gen_short_hs(sender,
+				access_protect, 4, 2,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Manufacture command protect on\n",
+					__func__, __LINE__);
+			goto ic_init_err;
+		}
+
+		err = dsi_send_gen_long_lp(sender,
+				jdi_timing_control,
+				21, DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Set panel timing\n",
+					__func__, __LINE__);
+			goto ic_init_err;
+		}
+		msleep(20);
+	}
+
+	err = dsi_send_gen_short_hs(sender,
+			access_protect, 4, 2,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Manufacture command protect on\n",
+			__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	err = dsi_send_gen_long_lp(sender,
+			jdi_timing_control,
+			21, DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set panel timing\n",
+				__func__, __LINE__);
+		goto ic_init_err;
+	}
+	msleep(20);
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_tear_on, 0x00, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Tear On\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	err = dsi_send_mcs_long_hs(sender,
+			jdi_mcs_clumn_addr,
+			5, DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Clumn Address\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	err = dsi_send_mcs_long_hs(sender,
+			jdi_mcs_page_addr,
+			5, DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Page Address\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	return 0;
+
+ic_init_err:
+	err = -EIO;
+	return err;
+}
+
+static void jdi_cmd_controller_init(struct dsi_pipe *pipe)
+{
+
+	struct dsi_context *hw_ctx = &pipe->config.ctx;
+
+#ifdef ENABLE_CSC_GAMMA /*FIXME*/
+	struct csc_setting csc = {
+			.pipe = 0,
+			.type = CSC_REG_SETTING,
+			.enable_state = true,
+			.data_len = CSC_REG_COUNT,
+			.data.csc_reg_data = {
+			0xFFB0424, 0xFDF, 0x4320FF1,
+			0xFDC, 0xFF50FF5, 0x415}
+		 };
+	struct gamma_setting gamma = {
+		.pipe = 0,
+		.type = GAMMA_REG_SETTING,
+		.enable_state = true,
+		.data_len = GAMMA_10_BIT_TABLE_COUNT,
+		.gamma_tableX100 = {
+			0x000000, 0x030303, 0x050505, 0x070707,
+			0x090909, 0x0C0C0C, 0x0E0E0E, 0x101010,
+			0x121212, 0x141414, 0x171717, 0x191919,
+			0x1B1B1B, 0x1D1D1D, 0x1F1F1F, 0x212121,
+			0x232323, 0x252525, 0x282828, 0x2A2A2A,
+			0x2C2C2C, 0x2E2E2E, 0x303030, 0x323232,
+			0x343434, 0x363636, 0x383838, 0x3A3A3A,
+			0x3C3C3C, 0x3E3E3E, 0x404040, 0x424242,
+			0x444444, 0x464646, 0x484848, 0x4A4A4A,
+			0x4C4C4C, 0x4E4E4E, 0x505050, 0x525252,
+			0x545454, 0x565656, 0x585858, 0x5A5A5A,
+			0x5C5C5C, 0x5E5E5E, 0x606060, 0x626262,
+			0x646464, 0x666666, 0x686868, 0x6A6A6A,
+			0x6C6C6C, 0x6E6E6E, 0x707070, 0x727272,
+			0x747474, 0x767676, 0x787878, 0x7A7A7A,
+			0x7C7C7C, 0x7E7E7E, 0x808080, 0x828282,
+			0x848484, 0x868686, 0x888888, 0x8A8A8A,
+			0x8C8C8C, 0x8E8E8E, 0x909090, 0x929292,
+			0x949494, 0x969696, 0x989898, 0x999999,
+			0x9B9B9B, 0x9D9D9D, 0x9F9F9F, 0xA1A1A1,
+			0xA3A3A3, 0xA5A5A5, 0xA7A7A7, 0xA9A9A9,
+			0xABABAB, 0xADADAD, 0xAFAFAF, 0xB1B1B1,
+			0xB3B3B3, 0xB5B5B5, 0xB6B6B6, 0xB8B8B8,
+			0xBABABA, 0xBCBCBC, 0xBEBEBE, 0xC0C0C0,
+			0xC2C2C2, 0xC4C4C4, 0xC6C6C6, 0xC8C8C8,
+			0xCACACA, 0xCCCCCC, 0xCECECE, 0xCFCFCF,
+			0xD1D1D1, 0xD3D3D3, 0xD5D5D5, 0xD7D7D7,
+			0xD9D9D9, 0xDBDBDB, 0xDDDDDD, 0xDFDFDF,
+			0xE1E1E1, 0xE3E3E3, 0xE4E4E4, 0xE6E6E6,
+			0xE8E8E8, 0xEAEAEA, 0xECECEC, 0xEEEEEE,
+			0xF0F0F0, 0xF2F2F2, 0xF4F4F4, 0xF6F6F6,
+			0xF7F7F7, 0xF9F9F9, 0xFBFBFB, 0xFDFDFD}
+	 };
+#endif
+
+	pr_debug("\n");
+
+	/*reconfig lane configuration*/
+	pipe->config.lane_count = 3;
+	pipe->config.lane_config = DSI_DATA_LANE_4_0;
+	/* FIXME: enable CSC and GAMMA */
+	/*dsi_config->enable_gamma_csc = ENABLE_GAMMA | ENABLE_CSC;*/
+	/* This is for 400 mhz.  Set it to 0 for 800mhz */
+	hw_ctx->cck_div = 1;
+	hw_ctx->pll_bypass_mode = 0;
+
+	if (IS_ANN()) {
+		hw_ctx->mipi_control = 0x18;
+		hw_ctx->intr_en = 0xFFFFFFFF;
+		hw_ctx->hs_tx_timeout = 0xFFFFFF;
+		hw_ctx->lp_rx_timeout = 0xFFFFFF;
+		hw_ctx->device_reset_timer = 0xff;
+		hw_ctx->turn_around_timeout = 0xffff;
+		hw_ctx->high_low_switch_count = 0x20;
+		hw_ctx->clk_lane_switch_time_cnt = 0x21000e;
+		hw_ctx->lp_byteclk = 0x4;
+		hw_ctx->dphy_param = 0x1b104315;
+		hw_ctx->eot_disable = 0x1;
+		hw_ctx->init_count = 0x7d0;
+		hw_ctx->dbi_bw_ctrl = 1390;
+		hw_ctx->hs_ls_dbi_enable = 0x0;
+		hw_ctx->dsi_func_prg = ((DBI_DATA_WIDTH_OPT2 << 13) |
+				pipe->config.lane_count);
+		hw_ctx->mipi = SEL_FLOPPED_HSTX	| PASS_FROM_SPHY_TO_AFE |
+			BANDGAP_CHICKEN_BIT | TE_TRIGGER_GPIO_PIN;
+	} else {
+		hw_ctx->mipi_control = 0x0;
+		hw_ctx->intr_en = 0xFFFFFFFF;
+		hw_ctx->hs_tx_timeout = 0xFFFFFF;
+		hw_ctx->lp_rx_timeout = 0xFFFFFF;
+		hw_ctx->device_reset_timer = 0xffff;
+		hw_ctx->turn_around_timeout = 0x1a;
+		hw_ctx->high_low_switch_count = 0x21;
+		hw_ctx->clk_lane_switch_time_cnt = 0x21000f;
+		hw_ctx->lp_byteclk = 0x5;
+		hw_ctx->dphy_param = 0x25155b1e;
+		hw_ctx->eot_disable = 0x3;
+		hw_ctx->init_count = 0xf0;
+		hw_ctx->dbi_bw_ctrl = 1390;
+		hw_ctx->hs_ls_dbi_enable = 0x0;
+		hw_ctx->dsi_func_prg = ((DBI_DATA_WIDTH_OPT2 << 13) |
+				pipe->config.lane_count);
+		hw_ctx->mipi = PASS_FROM_SPHY_TO_AFE |
+			BANDGAP_CHICKEN_BIT |
+			TE_TRIGGER_GPIO_PIN;
+	}
+	hw_ctx->video_mode_format = 0xf;
+
+#ifdef ENABLE_CSC_GAMMA /*FIXME*/
+	if (pipe->config.enable_gamma_csc & ENABLE_CSC) {
+		/* setting the tuned csc setting */
+		drm_psb_enable_color_conversion = 1;
+		intel_crtc_set_color_conversion(dev, &csc);
+	}
+
+	if (pipe->config.enable_gamma_csc & ENABLE_GAMMA) {
+		/* setting the tuned gamma setting */
+		drm_psb_enable_gamma = 1;
+		intel_crtc_set_gamma(dev, &gamma);
+	}
+#endif
+
+}
+static int jdi_cmd_panel_connection_detect(struct dsi_pipe *pipe)
+{
+	int status;
+	int idx = pipe->base.base.idx;
+
+	pr_debug("\n");
+
+	if (idx == 0) {
+		status = DSI_PANEL_CONNECTED;
+	} else {
+		pr_info("%s: do NOT support dual panel\n",
+		__func__);
+		status = DSI_PANEL_DISCONNECTED;
+	}
+
+	return status;
+}
+
+static int jdi_cmd_power_on(struct dsi_pipe *pipe)
+{
+
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err = 0;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_address_mode, 0x0, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Address Mode\n",
+		__func__, __LINE__);
+		goto power_err;
+	}
+	usleep_range(20000, 20100);
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_pixel_format, 0x77, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Pixel format\n",
+		__func__, __LINE__);
+		goto power_err;
+	}
+
+	/*turn on display*/
+	err = dsi_send_dcs(sender,
+		 set_display_on,
+		 NULL,
+		 0,
+		 CMD_DATA_SRC_SYSTEM_MEM,
+		 DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("faild to set_display_on mode\n");
+		goto power_err;
+	}
+	usleep_range(20000, 20100);
+
+power_err:
+	return err;
+}
+
+static void __vpro2_power_ctrl(bool on)
+{
+	u8 addr, value;
+	addr = 0xad;
+	if (intel_scu_ipc_ioread8(addr, &value))
+		pr_err("%s: %d: failed to read vPro2\n",
+		__func__, __LINE__);
+
+	/* Control vPROG2 power rail with 2.85v. */
+	if (on)
+		value |= 0x1;
+	else
+		value &= ~0x1;
+
+	if (intel_scu_ipc_iowrite8(addr, value))
+		pr_err("%s: %d: failed to write vPro2\n",
+				__func__, __LINE__);
+}
+
+static int jdi_cmd_power_off(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_display_off, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Display Off\n",
+		__func__, __LINE__);
+		goto power_off_err;
+	}
+	usleep_range(20000, 20100);
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_tear_off, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Tear Off\n",
+		__func__, __LINE__);
+		goto power_off_err;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			enter_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Enter Sleep Mode\n",
+		__func__, __LINE__);
+		goto power_off_err;
+	}
+
+	msleep(60);
+
+	err = dsi_send_gen_short_hs(sender,
+		access_protect, 4, 2,
+		DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Access Protect\n",
+		__func__, __LINE__);
+		goto power_off_err;
+	}
+
+	err = dsi_send_gen_short_hs(sender,
+		low_power_mode, 1, 2,
+		DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Low Power Mode\n",
+		__func__, __LINE__);
+		goto power_off_err;
+	}
+	if (bias_en_gpio)
+		gpio_set_value_cansleep(bias_en_gpio, 0);
+	usleep_range(1000, 1500);
+	return 0;
+power_off_err:
+	err = -EIO;
+	return err;
+}
+
+static int jdi_cmd_set_brightness(struct dsi_pipe *pipe,
+				int level)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	u8 duty_val = 0;
+
+	pr_debug("level = %d\n", level);
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	duty_val = (0xFF * level) / 100;
+	dsi_send_mcs_short_hs(sender,
+			write_display_brightness, duty_val, 1,
+			DSI_SEND_PACKAGE);
+	return 0;
+}
+
+static void _get_panel_reset_gpio(void)
+{
+	int ret = 0;
+	if (mipi_reset_gpio == 0) {
+		ret = get_gpio_by_name("disp0_rst");
+		if (ret < 0) {
+			pr_err("Faild to get panel reset gpio, use default reset pin\n");
+			return;
+		}
+		mipi_reset_gpio = ret;
+		ret = gpio_request(mipi_reset_gpio, "mipi_display");
+		if (ret) {
+			pr_err("Faild to request panel reset gpio\n");
+			return;
+		}
+		gpio_direction_output(mipi_reset_gpio, 0);
+	}
+}
+
+static int jdi_cmd_panel_reset(struct dsi_pipe *pipe)
+{
+	int ret = 0;
+	u8 *vaddr = NULL, *vaddr1 = NULL;
+	int reg_value_scl = 0;
+
+	pr_debug("\n");
+
+	/* Because when reset touchscreen panel, touchscreen will pull i2c bus
+	 * to low, sometime this operation will cause i2c bus enter into wrong
+	 * status, so before reset, switch i2c scl pin */
+	vaddr1 = ioremap(SECURE_I2C_FLIS_REG, 4);
+	reg_value_scl = ioread32(vaddr1);
+	reg_value_scl &= ~0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+					(u8 *)&reg_value_scl, 4,
+					NULL, 0,
+					SECURE_I2C_FLIS_REG, 0);
+
+	__vpro2_power_ctrl(true);
+	usleep_range(2000, 2500);
+
+	if (bias_en_gpio == 0) {
+		bias_en_gpio = 189;
+		ret = gpio_request(bias_en_gpio, "bias_enable");
+		if (ret) {
+			pr_err("Faild to request bias_enable gpio\n");
+			return -EINVAL;
+		}
+		gpio_direction_output(bias_en_gpio, 0);
+	}
+
+	_get_panel_reset_gpio();
+
+	gpio_direction_output(bias_en_gpio, 0);
+	gpio_direction_output(mipi_reset_gpio, 0);
+	gpio_set_value_cansleep(bias_en_gpio, 0);
+	gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	usleep_range(2000, 2500);
+	gpio_set_value_cansleep(bias_en_gpio, 1);
+	usleep_range(2000, 2500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+	usleep_range(3000, 3500);
+	vaddr = ioremap(0xff0c2d00, 0x60);
+	iowrite32(0x3221, vaddr + 0x1c);
+	usleep_range(2000, 2500);
+	iounmap(vaddr);
+
+	/* switch i2c scl pin back */
+	reg_value_scl |= 0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+					(u8 *)&reg_value_scl, 4,
+					NULL, 0,
+					SECURE_I2C_FLIS_REG, 0);
+	iounmap(vaddr1);
+	return 0;
+}
+
+static int jdi_cmd_exit_deep_standby(struct dsi_pipe *pipe)
+{
+	pr_debug("\n");
+
+	if (bias_en_gpio)
+		gpio_set_value_cansleep(bias_en_gpio, 1);
+	_get_panel_reset_gpio();
+	gpio_direction_output(mipi_reset_gpio, 0);
+
+	gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	usleep_range(1000, 1500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+	usleep_range(3000, 3500);
+	return 0;
+}
+
+static int jdi_cmd_get_config_mode(struct drm_mode_modeinfo *mode)
+{
+	pr_debug("\n");
+
+	if (!mode)
+		return -EINVAL;
+
+	mode->hdisplay = 720;
+	mode->hsync_start = 816;
+	mode->hsync_end = 818;
+	mode->htotal = 920;
+
+	mode->vdisplay = 1280;
+	mode->vsync_start = 1288;
+	mode->vsync_end = 1296;
+	mode->vtotal = 1304;
+
+	mode->vrefresh = 60;
+	mode->clock =  mode->vrefresh * mode->vtotal * mode->htotal / 1000;
+
+	adf_modeinfo_set_name(mode);
+
+	return 0;
+}
+
+static void jdi_cmd_get_panel_info(struct panel_info *pi)
+{
+	pr_debug("\n");
+
+	pi->width_mm = JDI_CMD_PHY_WIDTH;
+	pi->height_mm = JDI_CMD_PHY_HEIGHT;
+	pi->bpp = JDI_CMD_BPP;
+	pi->dsi_type = JDI_CMD_DSI_TYPE;
+	pi->lane_num = JDI_CMD_LANE_NUM;
+	pi->dual_link = DSI_PANEL_SINGLE_LINK;
+}
+
+static struct panel_ops jdi_cmd_panel_ops = {
+	.drv_ic_init = jdi_cmd_drv_ic_init,
+	.dsi_controller_init = jdi_cmd_controller_init,
+	.detect = jdi_cmd_panel_connection_detect,
+	.power_on = jdi_cmd_power_on,
+	.power_off = jdi_cmd_power_off,
+	.set_brightness = jdi_cmd_set_brightness,
+	.reset = jdi_cmd_panel_reset,
+	.get_config_mode = jdi_cmd_get_config_mode,
+	.exit_deep_standby = jdi_cmd_exit_deep_standby,
+	.get_panel_info = jdi_cmd_get_panel_info,
+};
+
+struct dsi_panel jdi_cmd_panel = {
+	.panel_id = JDI_7x12_CMD,
+	.info.width_mm = JDI_CMD_PHY_WIDTH,
+	.info.height_mm = JDI_CMD_PHY_HEIGHT,
+	.info.bpp = JDI_CMD_BPP,
+	.info.dsi_type = JDI_CMD_DSI_TYPE,
+	.info.lane_num = JDI_CMD_LANE_NUM,
+	.info.dual_link = DSI_PANEL_SINGLE_LINK,
+	.ops = &jdi_cmd_panel_ops,
+};
+
+const struct dsi_panel *jdi_cmd_get_panel(void)
+{
+	return &jdi_cmd_panel;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_vid.c b/drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_vid.c
new file mode 100644
index 0000000..5229d57
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/jdi_7x12_vid.c
@@ -0,0 +1,438 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include <linux/gpio.h>
+
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pipe.h"
+
+/*JDI panel info*/
+#define JDI_VID_PHY_WIDTH	56
+#define JDI_VID_PHY_HEIGHT	99
+#define JDI_VID_BPP		24
+#define JDI_VID_DSI_TYPE	DSI_DPI
+#define JDI_VID_LANE_NUM	3
+
+/* The register to control secure I2C FLIS pin */
+#define SECURE_I2C_FLIS_REG	0xFF0C1D30
+
+static int mipi_reset_gpio;
+static int bias_en_gpio;
+
+static u8 jdi_set_address_mode[] = {0x36, 0xc0, 0x00, 0x00};
+static u8 jdi_write_display_brightness[] = {0x51, 0x0f, 0xff, 0x00};
+
+static int jdi_vid_drv_ic_init(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err = 0;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Cannot get sender\n");
+		return -EINVAL;
+	}
+
+	/* Set Address Mode */
+	err = dsi_send_mcs_long_hs(sender, jdi_set_address_mode,
+			4,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Address Mode\n", __func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	/* Set Pixel format */
+	err = dsi_send_mcs_short_hs(sender, set_pixel_format, 0x70, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Pixel format\n", __func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	/* change "ff0f" according to the brightness desired. */
+	err = dsi_send_mcs_long_hs(sender, jdi_write_display_brightness,
+			4, DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Brightness\n", __func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	/* Write control display */
+	err = dsi_send_mcs_short_hs(sender, write_ctrl_display, 0x24, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Write Control Display\n", __func__,
+				__LINE__);
+		goto ic_init_err;
+	}
+
+	/* Write control CABC */
+	err = dsi_send_mcs_short_hs(sender, write_ctrl_cabc, STILL_IMAGE,
+			1, DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Write Control CABC\n", __func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	return 0;
+
+ic_init_err:
+	err = -EIO;
+	return err;
+}
+
+static void jdi_vid_controller_init(struct dsi_pipe *pipe)
+{
+	struct dsi_context *hw_ctx = &pipe->config.ctx;
+
+	pr_debug("\n");
+
+	/*reconfig lane configuration*/
+	pipe->config.lane_count = 3;
+	pipe->config.lane_config = DSI_DATA_LANE_4_0;
+	hw_ctx->pll_bypass_mode = 0;
+	/* This is for 400 mhz.  Set it to 0 for 800mhz */
+	hw_ctx->cck_div = 1;
+
+	hw_ctx->mipi_control = READ_REQUEST_HIGH_PRIORITY;
+	hw_ctx->intr_en = 0xFFFFFFFF;
+	hw_ctx->hs_tx_timeout = 0xFFFFFF;
+	hw_ctx->lp_rx_timeout = 0xFFFFFF;
+	hw_ctx->turn_around_timeout = 0xFFFF;
+	hw_ctx->device_reset_timer = 0xFF;
+	hw_ctx->high_low_switch_count = 0x20;
+	hw_ctx->clk_lane_switch_time_cnt = 0x0020000E;
+	hw_ctx->dbi_bw_ctrl = 0x0;
+	hw_ctx->eot_disable = 0x0;
+	hw_ctx->init_count = 0x7D0;
+	hw_ctx->lp_byteclk = 0x4;
+	hw_ctx->dphy_param = 0x1B0F4115;
+
+	/*setup video mode format*/
+	hw_ctx->video_mode_format = BURST_MODE | DISABLE_VIDEO_BTA;
+
+	/*set up func_prg*/
+	hw_ctx->dsi_func_prg = (MIPI_FMT_RGB888 | VID_VIRTUAL_CHANNEL_0 |
+			pipe->config.lane_count);
+
+	/*setup mipi port configuration*/
+	hw_ctx->mipi = MIPI_PORT_ENABLE | LP_OUTPUT_HOLD_ENABLE |
+		BANDGAP_CHICKEN_BIT | pipe->config.lane_config;
+}
+
+static int jdi_vid_panel_connection_detect(struct dsi_pipe *pipe)
+{
+	int status;
+	int idx = pipe->base.base.idx;
+
+	pr_debug("\n");
+
+	if (idx == 0)
+		status = DSI_PANEL_CONNECTED;
+	else {
+		pr_info("%s: do NOT support dual panel\n", __func__);
+		status = DSI_PANEL_DISCONNECTED;
+	}
+
+	return status;
+}
+
+static int jdi_vid_power_on(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	/* Sleep Out */
+	err = dsi_send_mcs_short_hs(sender, exit_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Exit Sleep Mode\n", __func__, __LINE__);
+		goto power_on_err;
+	}
+	/* Wait for 6 frames after exit_sleep_mode. */
+	msleep(100);
+
+	/* Set Display on */
+	err = dsi_send_mcs_short_hs(sender, set_display_on, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Display On\n", __func__, __LINE__);
+		goto power_on_err;
+	}
+	/* Wait for 1 frame after set_display_on. */
+	msleep(20);
+
+	/* Send TURN_ON packet */
+	err = dsi_send_dpi_spk_pkg_hs(sender, DSI_DPI_SPK_TURN_ON);
+	if (err) {
+		pr_err("Failed to send turn on packet\n");
+		goto power_on_err;
+	}
+
+	return 0;
+
+power_on_err:
+	err = -EIO;
+	return err;
+}
+
+static void __vpro2_power_ctrl(bool on)
+{
+	u8 addr, value;
+	addr = 0xad;
+	if (intel_scu_ipc_ioread8(addr, &value))
+		pr_err("%s: %d: failed to read vPro2\n", __func__, __LINE__);
+
+	/* Control vPROG2 power rail with 2.85v. */
+	if (on)
+		value |= 0x1;
+	else
+		value &= ~0x1;
+
+	if (intel_scu_ipc_iowrite8(addr, value))
+		pr_err("%s: %d: failed to write vPro2\n", __func__, __LINE__);
+}
+
+static int jdi_vid_power_off(struct dsi_pipe *pipe)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int err;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+}
+
+	/*send SHUT_DOWN packet */
+	err = dsi_send_dpi_spk_pkg_hs(sender,
+			DSI_DPI_SPK_SHUT_DOWN);
+	if (err) {
+		pr_err("Failed to send turn off packet\n");
+		goto power_off_err;
+	}
+	/* According HW DSI spec, need to wait for 100ms. */
+	msleep(100);
+
+	/* Set Display off */
+	err = dsi_send_mcs_short_hs(sender, set_display_off, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Display On\n", __func__, __LINE__);
+		goto power_off_err;
+	}
+	/* Wait for 1 frame after set_display_on. */
+	msleep(20);
+
+	/* Sleep In */
+	err = dsi_send_mcs_short_hs(sender, enter_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Exit Sleep Mode\n", __func__, __LINE__);
+		goto power_off_err;
+	}
+	/* Wait for 3 frames after enter_sleep_mode. */
+	msleep(51);
+
+	/* Can not poweroff VPROG2, because many other module related to
+	 * this power supply, such as PSH sensor. */
+	/*__vpro2_power_ctrl(false);*/
+	if (bias_en_gpio)
+		gpio_set_value_cansleep(bias_en_gpio, 0);
+
+	return 0;
+
+power_off_err:
+	err = -EIO;
+	return err;
+}
+
+static int jdi_vid_set_brightness(struct dsi_pipe *pipe, int level)
+{
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	int duty_val = 0;
+
+	pr_debug("level = %d\n", level);
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	duty_val = (0xFFF * level) / 100;
+
+	/*
+	 * Note: the parameters of write_display_brightness in JDI R69001 spec
+	 * map DBV[7:4] as MSB.
+	 */
+	jdi_write_display_brightness[0] = 0x51;
+	jdi_write_display_brightness[1] = duty_val & 0xF;
+	jdi_write_display_brightness[2] = ((duty_val & 0xFF0) >> 4);
+	jdi_write_display_brightness[3] = 0x0;
+	dsi_send_mcs_long_hs(sender, jdi_write_display_brightness, 4, 0);
+
+	return 0;
+}
+
+static int jdi_vid_panel_reset(struct dsi_pipe *pipe)
+{
+	u8 *vaddr1 = NULL;
+	int reg_value_scl = 0;
+	int ret = 0;
+
+	pr_debug("\n");
+
+	/* Because when reset touchscreen panel, touchscreen will pull i2c bus
+	 * to low, sometime this operation will cause i2c bus enter into wrong
+	 * status, so before reset, switch i2c scl pin */
+	vaddr1 = ioremap(SECURE_I2C_FLIS_REG, 4);
+	reg_value_scl = ioread32(vaddr1);
+	reg_value_scl &= ~0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+			(u8 *)&reg_value_scl, 4,
+			NULL, 0,
+			SECURE_I2C_FLIS_REG, 0);
+
+	__vpro2_power_ctrl(true);
+
+	/* For meeting tRW1 panel spec */
+	usleep_range(2000, 2500);
+
+	if (bias_en_gpio == 0) {
+		bias_en_gpio = 189;
+		ret = gpio_request(bias_en_gpio, "bias_enable");
+		if (ret) {
+			pr_err("Faild to request bias_enable gpio\n");
+			return -EINVAL;
+		}
+		gpio_direction_output(bias_en_gpio, 0);
+	}
+	if (mipi_reset_gpio == 0) {
+		ret = get_gpio_by_name("disp0_rst");
+		if (ret < 0) {
+			pr_err("Faild to get panel reset gpio, use default reset pin\n");
+			return -EINVAL;
+		}
+		mipi_reset_gpio = ret;
+		ret = gpio_request(mipi_reset_gpio, "mipi_display");
+		if (ret) {
+			pr_err("Faild to request panel reset gpio\n");
+			return -EINVAL;
+		}
+		gpio_direction_output(mipi_reset_gpio, 0);
+	}
+	gpio_direction_output(bias_en_gpio, 0);
+	gpio_direction_output(mipi_reset_gpio, 0);
+	gpio_set_value_cansleep(bias_en_gpio, 0);
+	gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	usleep_range(2000, 2500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+	usleep_range(2000, 2500);
+	gpio_set_value_cansleep(bias_en_gpio, 1);
+	usleep_range(2000, 2500);
+	/* switch i2c scl pin back */
+	reg_value_scl |= 0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+			(u8 *)&reg_value_scl, 4,
+			NULL, 0,
+			SECURE_I2C_FLIS_REG, 0);
+	iounmap(vaddr1);
+
+	return 0;
+}
+
+static int jdi_vid_get_config_mode(struct drm_mode_modeinfo *mode)
+{
+	pr_debug("\n");
+
+	if (!mode)
+		return -EINVAL;
+
+	mode->hdisplay = 720;
+	mode->hsync_start = 816;
+	mode->hsync_end = 818;
+	mode->htotal = 920;
+
+	mode->vdisplay = 1280;
+	mode->vsync_start = 1288;
+	mode->vsync_end = 1296;
+	mode->vtotal = 1304;
+
+	mode->vrefresh = 60;
+	mode->clock = mode->vrefresh * mode->vtotal * mode->htotal / 1000;
+
+	adf_modeinfo_set_name(mode);
+
+	return 0;
+}
+
+static void jdi_vid_get_panel_info(struct panel_info *pi)
+{
+	pr_debug("\n");
+
+	pi->width_mm = JDI_VID_PHY_WIDTH;
+	pi->height_mm = JDI_VID_PHY_HEIGHT;
+	pi->bpp = JDI_VID_BPP;
+	pi->dsi_type = JDI_VID_DSI_TYPE;
+	pi->lane_num = JDI_VID_LANE_NUM;
+	pi->dual_link = DSI_PANEL_SINGLE_LINK;
+}
+
+static struct panel_ops jdi_vid_panel_ops = {
+	.drv_ic_init = jdi_vid_drv_ic_init,
+	.dsi_controller_init = jdi_vid_controller_init,
+	.detect = jdi_vid_panel_connection_detect,
+	.power_on = jdi_vid_power_on,
+	.power_off = jdi_vid_power_off,
+	.set_brightness = jdi_vid_set_brightness,
+	.reset = jdi_vid_panel_reset,
+	.get_config_mode = jdi_vid_get_config_mode,
+	.exit_deep_standby = NULL,
+	.get_panel_info = jdi_vid_get_panel_info,
+};
+
+struct dsi_panel jdi_vid_panel = {
+	.panel_id = JDI_7x12_VID,
+	.info.width_mm = JDI_VID_PHY_WIDTH,
+	.info.height_mm = JDI_VID_PHY_HEIGHT,
+	.info.bpp = JDI_VID_BPP,
+	.info.dsi_type = JDI_VID_DSI_TYPE,
+	.info.lane_num = JDI_VID_LANE_NUM,
+	.info.dual_link = DSI_PANEL_SINGLE_LINK,
+	.ops = &jdi_vid_panel_ops,
+};
+
+const struct dsi_panel *jdi_vid_get_panel(void)
+{
+	return &jdi_vid_panel;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/sharp_10x19_cmd.c b/drivers/video/adf/intel/core/common/dsi/panels/sharp_10x19_cmd.c
new file mode 100644
index 0000000..937f537
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/sharp_10x19_cmd.c
@@ -0,0 +1,657 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include <linux/gpio.h>
+
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pipe.h"
+
+#define SHARP_10x19_CMD_PHY_WIDTH	58
+#define SHARP_10x19_CMD_PHY_HEIGHT	103
+#define SHARP_10x19_CMD_BPP		24
+#define SHARP_10x19_CMD_DSI_TYPE	DSI_DBI
+#define SHARP_10x19_CMD_LANE_NUM	4
+
+/* The register to control secure I2C FLIS pin */
+#define SECURE_I2C_FLIS_REG	0xFF0C1D30
+
+#define EXPANDER_BUS_NUMBER 7
+
+static int mipi_reset_gpio;
+static int mipic_reset_gpio;
+static int bias_en_gpio;
+
+#define sharp10x19_remove_nvm_reload 0xd6
+static u8 sharp10x19_mcs_column_addr[] = { 0x2a, 0x00, 0x00, 0x04, 0x37 };
+static u8 sharp10x19_mcs_page_addr[] = { 0x2b, 0x00, 0x00, 0x07, 0x7f };
+
+static int sharp10x19_cmd_drv_ic_init(struct dsi_pipe *pipe)
+{
+	int ret;
+	u8 cmd;
+	int i;
+	int loop = 1;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	struct dsi_config *config = &pipe->config;
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	if (is_dual_panel(config))
+		loop = 2;
+
+	for (i = 0; i < loop; i++) {
+		if (i == 0)
+			sender->work_for_slave_panel = false;
+		else
+			sender->work_for_slave_panel = true;
+
+		/* exit sleep */
+		cmd = exit_sleep_mode;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0, 0, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+		msleep(120);
+
+		/* unlock MCW */
+		cmd = access_protect;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0x0, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* reload NVM */
+		cmd = sharp10x19_remove_nvm_reload;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0x1, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* send display brightness */
+		cmd = write_display_brightness;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0xff, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* display control */
+		cmd = write_ctrl_display;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0x0c, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* CABC */
+		cmd = write_ctrl_cabc;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0x0, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* tear on*/
+		cmd = set_tear_on;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0x0, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* column address */
+		cmd = set_column_address;
+		ret = dsi_send_mcs_long_hs(sender,
+				sharp10x19_mcs_column_addr, 5,
+				DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* page address */
+		cmd = set_page_addr;
+		ret = dsi_send_mcs_long_hs(sender, sharp10x19_mcs_page_addr, 5,
+				DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+	}
+	sender->work_for_slave_panel = false;
+	return 0;
+
+err_out:
+	sender->work_for_slave_panel = false;
+	pr_err("failed to send command %#x\n", cmd);
+	return ret;
+}
+
+static void sharp10x19_cmd_controller_init(struct dsi_pipe *pipe)
+{
+	struct dsi_context *hw_ctx = &pipe->config.ctx;
+	struct dsi_config *config = &pipe->config;
+
+	pr_debug("\n");
+
+	/*reconfig lane configuration*/
+	pipe->config.lane_count = 4;
+	pipe->config.lane_config = DSI_DATA_LANE_4_0;
+	hw_ctx->cck_div = 1;
+	hw_ctx->pll_bypass_mode = 0;
+
+	hw_ctx->mipi_control = 0x0;
+	hw_ctx->intr_en = 0xFFFFFFFF;
+	hw_ctx->hs_tx_timeout = 0xFFFFFF;
+	hw_ctx->lp_rx_timeout = 0xFFFFFF;
+	hw_ctx->device_reset_timer = 0xffff;
+	hw_ctx->turn_around_timeout = 0x14;
+
+	if (is_dual_panel(config)) {
+		hw_ctx->high_low_switch_count = 0x2B;
+		hw_ctx->clk_lane_switch_time_cnt =  0x2b0014;
+		hw_ctx->eot_disable = 0x0;
+	} else {
+		hw_ctx->high_low_switch_count = 0x2c;
+		hw_ctx->clk_lane_switch_time_cnt =  0x2e0016;
+		hw_ctx->eot_disable = EOT_DIS;
+	}
+
+	hw_ctx->lp_byteclk = 0x6;
+	hw_ctx->dphy_param = 0x2a18681f;
+
+	hw_ctx->init_count = 0xf0;
+	hw_ctx->dbi_bw_ctrl = 1100;
+	hw_ctx->hs_ls_dbi_enable = 0x0;
+	hw_ctx->dsi_func_prg = DBI_16BIT_IF_OPTION_2 | pipe->config.lane_count;
+
+	if (is_dual_panel(config))
+		hw_ctx->mipi = SEL_FLOPPED_HSTX	| LP_OUTPUT_HOLD_ENABLE |
+			DUAL_LINK_ENABLE | DUAL_LINK_CAPABLE;
+	else
+		hw_ctx->mipi = LP_OUTPUT_HOLD_ENABLE |
+			BANDGAP_CHICKEN_BIT | TE_TRIGGER_BY_GPIO;
+
+	hw_ctx->video_mode_format = DISABLE_VIDEO_BTA | IP_TG_CONFIG |
+				    BURST_MODE;
+}
+
+static int sharp10x19_cmd_panel_connection_detect(struct dsi_pipe *pipe)
+{
+	int status;
+	int idx = pipe->base.base.idx;
+
+	pr_debug("\n");
+
+	if (idx == 0)
+		status = DSI_PANEL_CONNECTED;
+	else {
+		pr_info("%s: do NOT support dual panel\n", __func__);
+		status = DSI_PANEL_DISCONNECTED;
+	}
+
+	return status;
+}
+
+static int sharp10x19_cmd_power_on(struct dsi_pipe *pipe)
+{
+	int ret;
+	u8 cmd;
+	int i;
+	int loop = 1;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	struct dsi_config *config = &pipe->config;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	if (is_dual_panel(config))
+		loop = 2;
+
+	for (i = 0; i < loop; i++) {
+		if (i == 0)
+			sender->work_for_slave_panel = false;
+		else
+			sender->work_for_slave_panel = true;
+		/* address mode */
+		cmd = set_address_mode;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0x0, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* pixel format*/
+		cmd = set_pixel_format;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0x77, 1, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+
+		/* display on */
+		cmd = set_display_on;
+		ret = dsi_send_mcs_short_hs(sender,
+				cmd, 0, 0, DSI_SEND_PACKAGE);
+		if (ret)
+			goto err_out;
+	}
+	sender->work_for_slave_panel = false;
+	return 0;
+
+err_out:
+	sender->work_for_slave_panel = false;
+	pr_err("failed to send command %#x\n", cmd);
+	return ret;
+}
+
+static void __vpro2_power_ctrl(bool on)
+{
+	u8 addr, value;
+	addr = 0xad;
+	if (intel_scu_ipc_ioread8(addr, &value))
+		pr_err("%s: %d: failed to read vPro2\n", __func__, __LINE__);
+
+	/* Control vPROG2 power rail with 2.85v. */
+	if (on)
+		value |= 0x1;
+	else
+		value &= ~0x1;
+
+	if (intel_scu_ipc_iowrite8(addr, value))
+		pr_err("%s: %d: failed to write vPro2\n",
+				__func__, __LINE__);
+}
+
+static int sharp10x19_cmd_power_off(struct dsi_pipe *pipe)
+{
+	int err;
+	int i;
+	int loop = 1;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	struct dsi_config *config = &pipe->config;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	if (is_dual_panel(config))
+		loop = 2;
+
+	for (i = 0; i < loop; i++) {
+		if (i == 0)
+			sender->work_for_slave_panel = false;
+		else
+			sender->work_for_slave_panel = true;
+
+		err = dsi_send_mcs_short_hs(sender,
+				set_display_off, 0, 0,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Set Display Off\n", __func__, __LINE__);
+			goto power_off_err;
+		}
+		usleep_range(20000, 20100);
+
+		err = dsi_send_mcs_short_hs(sender,
+				set_tear_off, 0, 0,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Set Tear Off\n", __func__, __LINE__);
+			goto power_off_err;
+		}
+
+		err = dsi_send_mcs_short_hs(sender,
+				enter_sleep_mode, 0, 0,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Enter Sleep Mode\n",
+							__func__, __LINE__);
+			goto power_off_err;
+		}
+
+		msleep(60);
+
+		err = dsi_send_gen_short_hs(sender,
+				access_protect, 4, 2,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Set Access Protect\n",
+							__func__, __LINE__);
+			goto power_off_err;
+		}
+
+		err = dsi_send_gen_short_hs(sender, low_power_mode, 1, 2,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Set Low Power Mode\n",
+							__func__, __LINE__);
+			goto power_off_err;
+		}
+		if (bias_en_gpio)
+			gpio_set_value_cansleep(bias_en_gpio, 0);
+		usleep_range(1000, 1500);
+	}
+	sender->work_for_slave_panel = false;
+	return 0;
+power_off_err:
+	sender->work_for_slave_panel = false;
+	err = -EIO;
+	return err;
+}
+
+static int sharp10x19_cmd_set_brightness(struct dsi_pipe *pipe, int level)
+{
+	u8 duty_val = 0;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+	struct dsi_config *config = &pipe->config;
+
+	pr_debug("%s: level = %d\n", __func__, level);
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	duty_val = (0xFF * level) / 100;
+	dsi_send_mcs_short_hs(sender,
+			write_display_brightness, duty_val, 1,
+			DSI_SEND_PACKAGE);
+
+	if (is_dual_panel(config)) {
+		sender->work_for_slave_panel = true;
+		dsi_send_mcs_short_hs(sender,
+				write_display_brightness, duty_val, 1,
+				DSI_SEND_PACKAGE);
+		sender->work_for_slave_panel = false;
+	}
+	return 0;
+}
+
+static void _get_panel_reset_gpio(bool is_dual_panel)
+{
+	int ret = 0;
+	if (mipi_reset_gpio == 0) {
+		ret = get_gpio_by_name("disp0_rst");
+		if (ret < 0) {
+			pr_err("Faild to get panel reset gpio, use default reset pin\n");
+			return;
+		}
+		mipi_reset_gpio = ret;
+		ret = gpio_request(mipi_reset_gpio, "mipi_display");
+		if (ret) {
+			pr_err("Faild to request panel reset gpio\n");
+			return;
+		}
+		gpio_direction_output(mipi_reset_gpio, 0);
+		pr_info("gpio_reseta=%d\n", mipi_reset_gpio);
+	}
+	if (is_dual_panel && (mipic_reset_gpio == 0)) {
+		mipic_reset_gpio = ret;
+		ret = gpio_request(mipic_reset_gpio, "mipic_display");
+		if (ret) {
+			pr_err("Faild to request panel reset gpio(c)\n");
+			return;
+		}
+		gpio_direction_output(mipic_reset_gpio, 0);
+		pr_info("gpio_resetc=%d\n", mipic_reset_gpio);
+	}
+}
+
+static int sharp10x19_cmd_panel_reset(struct dsi_pipe *pipe)
+{
+	int ret = 0;
+	u8 *vaddr = NULL, *vaddr1 = NULL;
+	int reg_value_scl = 0;
+	u8 i2_data[4];
+	struct dsi_config *config = &pipe->config;
+
+	pr_debug("\n");
+
+	if (is_dual_panel(config)) {
+		struct i2c_adapter *adapter =
+			i2c_get_adapter(EXPANDER_BUS_NUMBER);
+		if (adapter) {
+			i2_data[0] = 0x4;
+			i2_data[1] = 0x0;
+			i2c_clients_command(adapter, 1, i2_data);
+			i2_data[0] = 0x5;
+			i2_data[1] = 0x3;
+			i2c_clients_command(adapter, 1, i2_data);
+		}
+	}
+	/* Because when reset touchscreen panel, touchscreen will pull i2c bus
+	 * to low, sometime this operation will cause i2c bus enter into wrong
+	 * status, so before reset, switch i2c scl pin */
+	vaddr1 = ioremap(SECURE_I2C_FLIS_REG, 4);
+	reg_value_scl = ioread32(vaddr1);
+	reg_value_scl &= ~0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+					(u8 *)&reg_value_scl, 4,
+					NULL, 0,
+					SECURE_I2C_FLIS_REG, 0);
+
+	__vpro2_power_ctrl(true);
+	usleep_range(2000, 2500);
+
+	if (bias_en_gpio == 0) {
+		bias_en_gpio = 189;
+		ret = gpio_request(bias_en_gpio, "bias_enable");
+		if (ret) {
+			pr_err("Faild to request bias_enable gpio\n");
+			return -EINVAL;
+		}
+		gpio_direction_output(bias_en_gpio, 0);
+		pr_info("gpio_bias_enable=%d\n", bias_en_gpio);
+	}
+
+	_get_panel_reset_gpio(is_dual_panel(config));
+
+	gpio_direction_output(bias_en_gpio, 0);
+	gpio_direction_output(mipi_reset_gpio, 0);
+	if (is_dual_panel(config))
+		gpio_direction_output(mipic_reset_gpio, 0);
+	gpio_set_value_cansleep(bias_en_gpio, 0);
+	gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	if (is_dual_panel(config))
+		gpio_set_value_cansleep(mipic_reset_gpio, 0);
+	usleep_range(2000, 2500);
+	gpio_set_value_cansleep(bias_en_gpio, 1);
+	usleep_range(2000, 2500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+	usleep_range(2000, 2500);
+	if (is_dual_panel(config)) {
+		gpio_set_value_cansleep(mipic_reset_gpio, 1);
+		usleep_range(3000, 3500);
+	}
+	vaddr = ioremap(0xff0c2d00, 0x60);
+	iowrite32(0x3221, vaddr + 0x1c);
+	usleep_range(2000, 2500);
+	iounmap(vaddr);
+
+	/* switch i2c scl pin back */
+	reg_value_scl |= 0x1000;
+	rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+					(u8 *)&reg_value_scl, 4,
+					NULL, 0,
+					SECURE_I2C_FLIS_REG, 0);
+	iounmap(vaddr1);
+	return ret;
+}
+
+static int sharp10x19_cmd_exit_deep_standby(struct dsi_pipe *pipe)
+{
+	struct dsi_config *config = &pipe->config;
+
+	pr_debug("\n");
+
+	if (bias_en_gpio)
+		gpio_set_value_cansleep(bias_en_gpio, 1);
+	_get_panel_reset_gpio(is_dual_panel(config));
+	gpio_direction_output(mipi_reset_gpio, 0);
+
+	gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	usleep_range(1000, 1500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+	usleep_range(3000, 3500);
+	if (is_dual_panel(config)) {
+		gpio_direction_output(mipic_reset_gpio, 0);
+		gpio_set_value_cansleep(mipic_reset_gpio, 0);
+		usleep_range(1000, 1500);
+		gpio_set_value_cansleep(mipic_reset_gpio, 1);
+		usleep_range(3000, 3500);
+	}
+	return 0;
+}
+
+static int sharp10x19_cmd_get_config_mode(struct drm_mode_modeinfo *mode)
+{
+	pr_debug("\n");
+
+	if (!mode)
+		return -EINVAL;
+
+	mode->hdisplay = 1080;
+	mode->hsync_start = mode->hdisplay + 8;
+	mode->hsync_end = mode->hsync_start + 24;
+	mode->htotal = mode->hsync_end + 8;
+
+	mode->vdisplay = 1920;
+	mode->vsync_start = 1923;
+	mode->vsync_end = 1926;
+	mode->vtotal = 1987;
+
+	mode->vrefresh = 60;
+	mode->clock =  mode->vrefresh * mode->vtotal * mode->htotal / 1000;
+
+	adf_modeinfo_set_name(mode);
+
+	return 0;
+}
+
+static int sharp10x19_dual_cmd_get_config_mode(struct drm_mode_modeinfo *mode)
+{
+	pr_debug("\n");
+
+	if (!mode)
+		return -EINVAL;
+
+	mode->hdisplay = 2160;
+	mode->hsync_start = mode->hdisplay + 8;
+	mode->hsync_end = mode->hsync_start + 24;
+	mode->htotal = mode->hsync_end + 8;
+
+	mode->vdisplay = 1920;
+	mode->vsync_start = 1923;
+	mode->vsync_end = 1926;
+	mode->vtotal = 1987;
+
+	mode->vrefresh = 60;
+	mode->clock =  mode->vrefresh * mode->vtotal * mode->htotal / 1000;
+
+	adf_modeinfo_set_name(mode);
+
+	return 0;
+}
+
+static void sharp10x19_cmd_get_panel_info(struct panel_info *pi)
+{
+	pr_debug("\n");
+
+	pi->width_mm = SHARP_10x19_CMD_PHY_WIDTH;
+	pi->height_mm = SHARP_10x19_CMD_PHY_HEIGHT;
+	pi->bpp = SHARP_10x19_CMD_BPP;
+	pi->dsi_type = SHARP_10x19_CMD_DSI_TYPE;
+	pi->lane_num = SHARP_10x19_CMD_LANE_NUM;
+	pi->dual_link = DSI_PANEL_SINGLE_LINK;
+}
+
+static void sharp10x19_dual_cmd_get_panel_info(struct panel_info *pi)
+{
+	pr_debug("\n");
+
+	pi->width_mm = SHARP_10x19_CMD_PHY_WIDTH;
+	pi->height_mm = SHARP_10x19_CMD_PHY_HEIGHT;
+	pi->bpp = SHARP_10x19_CMD_BPP;
+	pi->dsi_type = SHARP_10x19_CMD_DSI_TYPE;
+	pi->lane_num = SHARP_10x19_CMD_LANE_NUM;
+	pi->dual_link = DSI_PANEL_DUAL_PANEL;
+}
+
+static struct panel_ops sharp10x19_cmd_panel_ops = {
+	.drv_ic_init = sharp10x19_cmd_drv_ic_init,
+	.dsi_controller_init = sharp10x19_cmd_controller_init,
+	.detect = sharp10x19_cmd_panel_connection_detect,
+	.power_on = sharp10x19_cmd_power_on,
+	.power_off = sharp10x19_cmd_power_off,
+	.set_brightness = sharp10x19_cmd_set_brightness,
+	.reset = sharp10x19_cmd_panel_reset,
+	.get_config_mode = sharp10x19_cmd_get_config_mode,
+	.exit_deep_standby = sharp10x19_cmd_exit_deep_standby,
+	.get_panel_info = sharp10x19_cmd_get_panel_info,
+};
+
+struct dsi_panel sharp10x19_cmd_panel = {
+	.panel_id = SHARP_10x19_CMD,
+	.info.width_mm = SHARP_10x19_CMD_PHY_WIDTH,
+	.info.height_mm = SHARP_10x19_CMD_PHY_HEIGHT,
+	.info.bpp = SHARP_10x19_CMD_BPP,
+	.info.dsi_type = SHARP_10x19_CMD_DSI_TYPE,
+	.info.lane_num = SHARP_10x19_CMD_LANE_NUM,
+	.info.dual_link = DSI_PANEL_SINGLE_LINK,
+	.ops = &sharp10x19_cmd_panel_ops,
+};
+
+const struct dsi_panel *sharp_10x19_cmd_get_panel(void)
+{
+	return &sharp10x19_cmd_panel;
+}
+
+static struct panel_ops sharp10x19_dual_cmd_panel_ops = {
+	.drv_ic_init = sharp10x19_cmd_drv_ic_init,
+	.dsi_controller_init = sharp10x19_cmd_controller_init,
+	.detect = sharp10x19_cmd_panel_connection_detect,
+	.power_on = sharp10x19_cmd_power_on,
+	.power_off = sharp10x19_cmd_power_off,
+	.set_brightness = sharp10x19_cmd_set_brightness,
+	.reset = sharp10x19_cmd_panel_reset,
+	.get_config_mode = sharp10x19_dual_cmd_get_config_mode,
+	.exit_deep_standby = sharp10x19_cmd_exit_deep_standby,
+	.get_panel_info = sharp10x19_dual_cmd_get_panel_info,
+};
+
+struct dsi_panel sharp10x19_dual_cmd_panel = {
+	.panel_id = SHARP_10x19_DUAL_CMD,
+	.info.width_mm = SHARP_10x19_CMD_PHY_WIDTH,
+	.info.height_mm = SHARP_10x19_CMD_PHY_HEIGHT,
+	.info.bpp = SHARP_10x19_CMD_BPP,
+	.info.dsi_type = SHARP_10x19_CMD_DSI_TYPE,
+	.info.lane_num = SHARP_10x19_CMD_LANE_NUM,
+	.info.dual_link = DSI_PANEL_DUAL_PANEL,
+	.ops = &sharp10x19_dual_cmd_panel_ops,
+};
+
+const struct dsi_panel *sharp_10x19_dual_cmd_get_panel(void)
+{
+	return &sharp10x19_dual_cmd_panel;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_cmd.c b/drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_cmd.c
new file mode 100644
index 0000000..c962d2e
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_cmd.c
@@ -0,0 +1,373 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include <linux/gpio.h>
+
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pipe.h"
+
+#define SHARP_25x16_CMD_PHY_WIDTH	217
+#define SHARP_25x16_CMD_PHY_HEIGHT	136
+#define SHARP_25x16_CMD_BPP		24
+#define SHARP_25x16_CMD_DSI_TYPE	DSI_DBI
+#define SHARP_25x16_CMD_LANE_NUM	4
+
+static int mipi_reset_gpio;
+
+static u8 sharp_mode_set_data[7][3] = {
+			{0x10, 0x00, 0x2f},
+			{0x10, 0x01, 0x01},
+			{0x10, 0x07, 0x00},
+			{0x70, 0x00, 0x70},
+			{0x00, 0x1f, 0x00},
+			{0x20, 0x2e, 0x12},
+			{0x20, 0x2a, 0x0}
+};
+static u8 sharp_clumn_addr_left[] = {0x2a, 0x00, 0x00, 0x09, 0xff};
+static u8 sharp_page_addr_left[] = {0x2b, 0x00, 0x00, 0x06, 0x3f};
+static u8 sharp_set_brightness[3] = {0x20, 0x2a, 0x0};
+
+static int sharp25x16_cmd_drv_ic_init(struct dsi_pipe *pipe)
+{
+	int err = 0;
+	int i;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Cannot get sender\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 7; i++) {
+		err = dsi_send_gen_long_hs(sender, sharp_mode_set_data[i],
+				3,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Set Mode data\n", __func__, __LINE__);
+			goto ic_init_err;
+		}
+		REG_WRITE(MIPIA_HS_GEN_CTRL_REG, 5);
+	}
+
+	err = dsi_send_mcs_long_hs(sender,
+			sharp_clumn_addr_left,
+			5, DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Clumn Address\n", __func__, __LINE__);
+		goto ic_init_err;
+	}
+
+	REG_WRITE(MIPIA_HS_GEN_CTRL_REG, 5);
+	err = dsi_send_mcs_long_hs(sender,
+			sharp_page_addr_left,
+			5, DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Page Address\n", __func__, __LINE__);
+		goto ic_init_err;
+	}
+	REG_WRITE(MIPIA_HS_GEN_CTRL_REG, 5);
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_tear_on, 0x00, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Tear On\n",
+		__func__, __LINE__);
+		goto ic_init_err;
+	}
+	return 0;
+
+ic_init_err:
+	err = -EIO;
+	return err;
+}
+
+static void sharp25x16_cmd_controller_init(struct dsi_pipe *pipe)
+{
+	struct dsi_context *hw_ctx = &pipe->config.ctx;
+
+	pr_debug("\n");
+
+	/*reconfig lane configuration*/
+	pipe->config.lane_count = 4;
+	pipe->config.lane_config = DSI_DATA_LANE_4_0;
+	hw_ctx->cck_div = 1;
+	hw_ctx->pll_bypass_mode = 0;
+
+	hw_ctx->mipi_control = 0x0;
+	hw_ctx->intr_en = 0xFFFFFFFF;
+	hw_ctx->hs_tx_timeout = 0xFFFFFF;
+	hw_ctx->lp_rx_timeout = 0xFFFFFF;
+	hw_ctx->device_reset_timer = 0xffff;
+	hw_ctx->turn_around_timeout = 0x3f;
+	hw_ctx->high_low_switch_count = 0x40;
+	hw_ctx->clk_lane_switch_time_cnt = 0x16002d;
+	hw_ctx->lp_byteclk = 0x5;
+	hw_ctx->dphy_param = 0x3c1fc51f;
+	hw_ctx->eot_disable = 0x0;
+	hw_ctx->init_count = 0xfa0;
+	hw_ctx->dbi_bw_ctrl = 1024;
+	hw_ctx->hs_ls_dbi_enable = 0x0;
+	hw_ctx->dsi_func_prg = DBI_16BIT_IF_OPTION_2 | pipe->config.lane_count;
+	hw_ctx->mipi = SEL_FLOPPED_HSTX	| LP_OUTPUT_HOLD_ENABLE |
+		DUAL_LINK_ENABLE | DUAL_LINK_CAPABLE | TE_TRIGGER_BY_GPIO |
+		DUAL_LINK_MODE_PIXEL_ALTER;
+	hw_ctx->video_mode_format = DISABLE_VIDEO_BTA | IP_TG_CONFIG |
+				    BURST_MODE;
+}
+
+static int sharp25x16_cmd_panel_connection_detect(struct dsi_pipe *pipe)
+{
+	int status;
+	int idx = pipe->base.base.idx;
+
+	pr_debug("\n");
+
+	if (idx == 0)
+		status = DSI_PANEL_CONNECTED;
+	else {
+		pr_info("%s: do NOT support dual panel\n", __func__);
+		status = DSI_PANEL_DISCONNECTED;
+	}
+
+	return status;
+}
+
+static int sharp25x16_cmd_power_on(struct dsi_pipe *pipe)
+{
+	int err = 0;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	msleep(150);
+	err = dsi_send_mcs_short_hs(sender,
+		set_address_mode, 0x0, 1,
+		DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Address Mode\n", __func__, __LINE__);
+		goto power_err;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_pixel_format, 0x77, 1,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Pixel format\n", __func__, __LINE__);
+		goto power_err;
+	}
+
+	/* Sleep Out */
+	err = dsi_send_mcs_short_hs(sender, exit_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Exit Sleep Mode\n", __func__, __LINE__);
+		goto power_err;
+	}
+
+	msleep(20);
+	/* Set Display on 0x29 */
+	err = dsi_send_mcs_short_hs(sender, set_display_on, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Display On\n", __func__, __LINE__);
+		goto power_err;
+	}
+	msleep(150);
+
+power_err:
+	return err;
+}
+
+static int sharp25x16_cmd_power_off(struct dsi_pipe *pipe)
+{
+	int err;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("\n");
+
+	msleep(100);
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			set_display_off, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Display Off\n", __func__, __LINE__);
+		goto power_off_err;
+	}
+
+	err = dsi_send_mcs_short_hs(sender,
+			enter_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Enter Sleep Mode\n", __func__, __LINE__);
+		goto power_off_err;
+	}
+	/* enable it after AOB re-work
+	* gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	*/
+	msleep(100);
+	return 0;
+power_off_err:
+	err = -EIO;
+	return err;
+}
+
+static int sharp25x16_cmd_set_brightness(struct dsi_pipe *pipe, int level)
+{
+	u8 duty_val = 0;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("level = %d\n", level);
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	duty_val = (0xFF * level) / 100;
+	if (duty_val < 12)
+		duty_val = 0;
+	sharp_set_brightness[2] = duty_val;
+	dsi_send_gen_long_hs(sender, sharp_set_brightness,
+				3,
+				DSI_SEND_PACKAGE);
+
+	REG_WRITE(MIPIA_HS_GEN_CTRL_REG, 5);
+	return 0;
+}
+
+static int sharp25x16_cmd_panel_reset(struct dsi_pipe *pipe)
+{
+	int ret = 0;
+
+	pr_debug("\n");
+
+	usleep_range(10000, 10500);
+	if (mipi_reset_gpio == 0) {
+		ret = get_gpio_by_name("disp0_rst");
+		if (ret < 0) {
+			pr_err("Faild to get panel reset gpio, use default reset pin\n");
+			return 0;
+		}
+		mipi_reset_gpio = ret;
+		ret = gpio_request(mipi_reset_gpio, "mipi_display");
+		if (ret) {
+			pr_err("Faild to request panel reset gpio\n");
+			return 0;
+		}
+	}
+	gpio_direction_output(mipi_reset_gpio, 0);
+	usleep_range(1000, 1500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+
+	return ret;
+}
+
+static int sharp25x16_cmd_exit_deep_standby(struct dsi_pipe *pipe)
+{
+	pr_debug("\n");
+
+	gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	usleep_range(1000, 1500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+
+	return 0;
+}
+
+static int sharp25x16_cmd_get_config_mode(struct drm_mode_modeinfo *mode)
+{
+	pr_debug("\n");
+
+	if (!mode)
+		return -EINVAL;
+
+	mode->hdisplay = 2560;
+
+	mode->hsync_start = mode->hdisplay + 48;
+	mode->hsync_end = mode->hsync_start + 32;
+	mode->htotal = mode->hsync_end + 80;
+
+	mode->vdisplay = 1600;
+	mode->vsync_start = mode->vdisplay + 3;
+	mode->vsync_end = mode->vsync_start + 33;
+	mode->vtotal = mode->vsync_end + 10;
+
+	mode->vrefresh = 60;
+	mode->clock = mode->vrefresh * mode->vtotal * mode->htotal / 1000;
+
+	adf_modeinfo_set_name(mode);
+
+	return 0;
+}
+
+static void sharp25x16_cmd_get_panel_info(struct panel_info *pi)
+{
+	pr_debug("\n");
+
+	pi->width_mm = SHARP_25x16_CMD_PHY_WIDTH;
+	pi->height_mm = SHARP_25x16_CMD_PHY_HEIGHT;
+	pi->bpp = SHARP_25x16_CMD_BPP;
+	pi->dsi_type = SHARP_25x16_CMD_DSI_TYPE;
+	pi->lane_num = SHARP_25x16_CMD_LANE_NUM;
+	pi->dual_link = DSI_PANEL_DUAL_LINK;
+}
+
+static struct panel_ops sharp25x16_cmd_panel_ops = {
+	.drv_ic_init = sharp25x16_cmd_drv_ic_init,
+	.dsi_controller_init = sharp25x16_cmd_controller_init,
+	.detect = sharp25x16_cmd_panel_connection_detect,
+	.power_on = sharp25x16_cmd_power_on,
+	.power_off = sharp25x16_cmd_power_off,
+	.set_brightness = sharp25x16_cmd_set_brightness,
+	.reset = sharp25x16_cmd_panel_reset,
+	.get_config_mode = sharp25x16_cmd_get_config_mode,
+	.exit_deep_standby = sharp25x16_cmd_exit_deep_standby,
+	.get_panel_info = sharp25x16_cmd_get_panel_info,
+};
+
+struct dsi_panel sharp25x16_cmd_panel = {
+	.panel_id = SHARP_25x16_CMD,
+	.info.width_mm = SHARP_25x16_CMD_PHY_WIDTH,
+	.info.height_mm = SHARP_25x16_CMD_PHY_HEIGHT,
+	.info.bpp = SHARP_25x16_CMD_BPP,
+	.info.dsi_type = SHARP_25x16_CMD_DSI_TYPE,
+	.info.lane_num = SHARP_25x16_CMD_LANE_NUM,
+	.info.dual_link = DSI_PANEL_DUAL_LINK,
+	.ops = &sharp25x16_cmd_panel_ops,
+};
+
+const struct dsi_panel *sharp_25x16_cmd_get_panel(void)
+{
+	return &sharp25x16_cmd_panel;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_vid.c b/drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_vid.c
new file mode 100644
index 0000000..718fb30
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/sharp_25x16_vid.c
@@ -0,0 +1,349 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include <linux/gpio.h>
+
+#include "intel_adf_device.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pipe.h"
+
+#define SHARP_25x16_VID_PHY_WIDTH	217
+#define SHARP_25x16_VID_PHY_HEIGHT	136
+#define SHARP_25x16_VID_BPP		24
+#define SHARP_25x16_VID_DSI_TYPE	DSI_DPI
+#define SHARP_25x16_VID_LANE_NUM	4
+
+static int mipi_reset_gpio;
+
+static u8 sharp_mode_set_data[7][3] = {
+			{0x10, 0x00, 0x3f},
+			{0x10, 0x01, 0x00},
+			{0x10, 0x07, 0x00},
+			{0x70, 0x00, 0x70},
+			{0x00, 0x1f, 0x00},
+			{0x20, 0x2e, 0x12},
+			{0x20, 0x2a, 0x00}
+};
+static u8 sharp_set_brightness[3] = {0x20, 0x2a, 0x0};
+
+int sharp25x16_vid_drv_ic_init(struct dsi_pipe *pipe)
+{
+	int err = 0;
+	int i;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Cannot get sender\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 7; i++) {
+		err = dsi_send_gen_long_hs(sender, sharp_mode_set_data[i],
+				3,
+				DSI_SEND_PACKAGE);
+		if (err) {
+			pr_err("%s: %d: Set Mode data\n", __func__, __LINE__);
+			goto ic_init_err;
+		}
+		REG_WRITE(MIPIA_HS_GEN_CTRL_REG, 5);
+	}
+	return 0;
+
+ic_init_err:
+	err = -EIO;
+	return err;
+}
+
+static void sharp25x16_vid_controller_init(struct dsi_pipe *pipe)
+{
+	struct dsi_context *hw_ctx = &pipe->config.ctx;
+
+	pr_debug("\n");
+
+	/*reconfig lane configuration*/
+	pipe->config.lane_count = 4;
+	pipe->config.lane_config = DSI_DATA_LANE_4_0;
+	hw_ctx->pll_bypass_mode = 0;
+	/* This is for 400 mhz.  Set it to 0 for 800mhz */
+	hw_ctx->cck_div = 1;
+
+	hw_ctx->mipi_control = 0;
+	hw_ctx->intr_en = 0xFFFFFFFF;
+	hw_ctx->hs_tx_timeout = 0xFFFFFF;
+	hw_ctx->lp_rx_timeout = 0xFFFFFF;
+	hw_ctx->device_reset_timer = 0xffff;
+	hw_ctx->turn_around_timeout = 0x3f;
+	hw_ctx->high_low_switch_count = 0x2c;
+	hw_ctx->clk_lane_switch_time_cnt =  0x2b0014;
+	hw_ctx->lp_byteclk = 0x5;
+	hw_ctx->dphy_param = 0x2a18681f;
+	hw_ctx->eot_disable = CLOCK_STOP;
+	hw_ctx->init_count = 0xfa0;
+	hw_ctx->dbi_bw_ctrl = 0x820;
+
+	/*setup video mode format*/
+	hw_ctx->video_mode_format = DISABLE_VIDEO_BTA | IP_TG_CONFIG |
+				    BURST_MODE;
+
+	/*set up func_prg*/
+	hw_ctx->dsi_func_prg = (MIPI_FMT_RGB888 | VID_VIRTUAL_CHANNEL_0 |
+			pipe->config.lane_count);
+
+	/*setup mipi port configuration*/
+	hw_ctx->mipi = MIPI_PORT_ENABLE | LP_OUTPUT_HOLD_ENABLE |
+		pipe->config.lane_config |
+		DUAL_LINK_ENABLE | DUAL_LINK_CAPABLE |
+		DUAL_LINK_MODE_PIXEL_ALTER;
+}
+
+static int sharp25x16_vid_panel_connection_detect(struct dsi_pipe *pipe)
+{
+	int status;
+	int idx = pipe->base.base.idx;
+
+	pr_debug("\n");
+
+	if (idx == 0)
+		status = DSI_PANEL_CONNECTED;
+	else {
+		pr_info("%s: do NOT support dual panel\n", __func__);
+		status = DSI_PANEL_DISCONNECTED;
+	}
+
+	return status;
+}
+
+static int sharp25x16_vid_power_on(struct dsi_pipe *pipe)
+{
+	int err;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+	/* Sleep Out */
+	err = dsi_send_mcs_short_hs(sender, exit_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Exit Sleep Mode\n", __func__, __LINE__);
+		goto power_on_err;
+	}
+	/* Wait for 6 frames after exit_sleep_mode. */
+	msleep(100);
+
+	/* Set Display on */
+	err = dsi_send_mcs_short_hs(sender, set_display_on, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Display On\n", __func__, __LINE__);
+		goto power_on_err;
+	}
+	/* Wait for 1 frame after set_display_on. */
+	msleep(20);
+
+	/* Send TURN_ON packet */
+	err = dsi_send_dpi_spk_pkg_hs(sender, DSI_DPI_SPK_TURN_ON);
+	if (err) {
+		pr_err("Failed to send turn on packet\n");
+		goto power_on_err;
+	}
+	return 0;
+
+power_on_err:
+	err = -EIO;
+	return err;
+}
+
+static int sharp25x16_vid_power_off(struct dsi_pipe *pipe)
+{
+	int err;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("\n");
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	/*send SHUT_DOWN packet */
+	err = dsi_send_dpi_spk_pkg_hs(sender,
+			DSI_DPI_SPK_SHUT_DOWN);
+	if (err) {
+		pr_err("Failed to send turn off packet\n");
+		goto power_off_err;
+	}
+	/* According HW DSI spec, need to wait for 100ms. */
+	msleep(100);
+
+	/* Set Display off */
+	err = dsi_send_mcs_short_hs(sender, set_display_off, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Set Display On\n", __func__, __LINE__);
+		goto power_off_err;
+	}
+	/* Wait for 1 frame after set_display_on. */
+	msleep(20);
+
+	/* Sleep In */
+	err = dsi_send_mcs_short_hs(sender, enter_sleep_mode, 0, 0,
+			DSI_SEND_PACKAGE);
+	if (err) {
+		pr_err("%s: %d: Exit Sleep Mode\n", __func__, __LINE__);
+		goto power_off_err;
+	}
+	/* Wait for 3 frames after enter_sleep_mode. */
+	msleep(51);
+
+	/* enable it after AOB re-work
+	* gpio_set_value_cansleep(mipi_reset_gpio, 0);
+	*/
+	return 0;
+
+power_off_err:
+	err = -EIO;
+	return err;
+}
+
+static int sharp25x16_vid_panel_reset(struct dsi_pipe *pipe)
+{
+	int ret = 0;
+
+	pr_debug("\n");
+	usleep_range(10000, 10500);
+	if (mipi_reset_gpio == 0) {
+		ret = get_gpio_by_name("disp0_rst");
+		if (ret < 0) {
+			pr_err("Faild to get panel reset gpio, use default reset pin\n");
+			return 0;
+		}
+		mipi_reset_gpio = ret;
+		ret = gpio_request(mipi_reset_gpio, "mipi_display");
+		if (ret) {
+			pr_err("Faild to request panel reset gpio\n");
+			return 0;
+		}
+	}
+	gpio_direction_output(mipi_reset_gpio, 0);
+	usleep_range(1000, 1500);
+	gpio_set_value_cansleep(mipi_reset_gpio, 1);
+
+	return ret;
+}
+
+static int sharp25x16_vid_get_config_mode(struct drm_mode_modeinfo *mode)
+{
+	pr_debug("\n");
+
+	if (!mode)
+		return -EINVAL;
+
+	mode->hdisplay = 2560;
+	mode->hsync_start = mode->hdisplay + 120;
+	mode->hsync_end = mode->hsync_start + 34;
+	mode->htotal = mode->hsync_end + 86;
+
+	mode->vdisplay = 1600;
+	mode->vsync_start = mode->vdisplay + 12;
+	mode->vsync_end = mode->vsync_start + 4;
+	mode->vtotal = mode->vsync_end + 4;
+
+	mode->vrefresh = 60;
+	mode->clock =  mode->vrefresh * mode->vtotal * mode->htotal / 1000;
+
+	adf_modeinfo_set_name(mode);
+
+	return 0;
+}
+
+static int sharp25x16_vid_set_brightness(struct dsi_pipe *pipe, int level)
+{
+	u8 duty_val = 0;
+	struct dsi_pkg_sender *sender = &pipe->sender;
+
+	pr_debug("level = %d\n", level);
+
+	if (!sender) {
+		pr_err("Failed to get DSI packet sender\n");
+		return -EINVAL;
+	}
+
+	duty_val = (0xFF * level) / 100;
+	if (duty_val < 12)
+		duty_val = 0;
+	sharp_set_brightness[2] = duty_val;
+	dsi_send_gen_long_hs(sender, sharp_set_brightness,
+				3,
+				DSI_SEND_PACKAGE);
+
+	REG_WRITE(MIPIA_HS_GEN_CTRL_REG, 5);
+	return 0;
+}
+
+static void sharp25x16_vid_get_panel_info(struct panel_info *pi)
+{
+	if (!pi)
+		return;
+
+	pr_debug("\n");
+
+	pi->width_mm = SHARP_25x16_VID_PHY_WIDTH;
+	pi->height_mm = SHARP_25x16_VID_PHY_HEIGHT;
+	pi->bpp = SHARP_25x16_VID_BPP;
+	pi->dsi_type = SHARP_25x16_VID_DSI_TYPE;
+	pi->lane_num = SHARP_25x16_VID_LANE_NUM;
+	pi->dual_link = DSI_PANEL_DUAL_LINK;
+}
+
+static struct panel_ops sharp25x16_vid_panel_ops = {
+	.drv_ic_init = sharp25x16_vid_drv_ic_init,
+	.dsi_controller_init = sharp25x16_vid_controller_init,
+	.detect = sharp25x16_vid_panel_connection_detect,
+	.power_on = sharp25x16_vid_power_on,
+	.power_off = sharp25x16_vid_power_off,
+	.set_brightness = sharp25x16_vid_set_brightness,
+	.reset = sharp25x16_vid_panel_reset,
+	.get_config_mode = sharp25x16_vid_get_config_mode,
+	.exit_deep_standby = NULL,
+	.get_panel_info = sharp25x16_vid_get_panel_info,
+};
+
+struct dsi_panel sharp25x16_vid_panel = {
+	.panel_id = SHARP_25x16_VID,
+	.info.width_mm = SHARP_25x16_VID_PHY_WIDTH,
+	.info.height_mm = SHARP_25x16_VID_PHY_HEIGHT,
+	.info.bpp = SHARP_25x16_VID_BPP,
+	.info.dsi_type = SHARP_25x16_VID_DSI_TYPE,
+	.info.lane_num = SHARP_25x16_VID_LANE_NUM,
+	.info.dual_link = DSI_PANEL_DUAL_LINK,
+	.ops = &sharp25x16_vid_panel_ops,
+};
+
+const struct dsi_panel *sharp_25x16_vid_get_panel(void)
+{
+	return &sharp25x16_vid_panel;
+}
diff --git a/drivers/video/adf/intel/core/common/hdmi/adf_hdmi_audio_if.h b/drivers/video/adf/intel/core/common/hdmi/adf_hdmi_audio_if.h
new file mode 100644
index 0000000..9023f8c
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/adf_hdmi_audio_if.h
@@ -0,0 +1,94 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef ADF_HDMI_AUDIO_IF_H
+#define ADF_HDMI_AUDIO_IF_H
+
+#include <linux/types.h>
+
+/* HDMI AUDIO INTERRUPT TYPE */
+#define HDMI_AUDIO_UNDERRUN	(1UL<<0)
+#define HDMI_AUDIO_BUFFER_DONE	(1UL<<1)
+
+enum had_caps_list {
+	HAD_GET_ELD = 1,
+	HAD_GET_SAMPLING_FREQ,
+	HAD_GET_DISPLAY_RATE,
+	HAD_GET_HDCP_STATUS,
+	HAD_GET_AUDIO_STATUS,
+	HAD_SET_ENABLE_AUDIO,
+	HAD_SET_DISABLE_AUDIO,
+	HAD_SET_ENABLE_AUDIO_INT,
+	HAD_SET_DISABLE_AUDIO_INT,
+	OTHERS_TBD,
+};
+
+enum had_event_type {
+	HAD_EVENT_HOT_PLUG = 1,
+	HAD_EVENT_HOT_UNPLUG,
+	HAD_EVENT_MODE_CHANGING,
+	HAD_EVENT_PM_CHANGING,
+	HAD_EVENT_AUDIO_BUFFER_DONE,
+	HAD_EVENT_AUDIO_BUFFER_UNDERRUN,
+	HAD_EVENT_QUERY_IS_AUDIO_BUSY,
+	HAD_EVENT_QUERY_IS_AUDIO_SUSPENDED,
+};
+
+/**
+ * HDMI Display Controller Audio Interface
+ *
+ */
+typedef int (*had_event_call_back)(enum had_event_type event_type,
+			void *ctxt_info);
+
+struct  hdmi_audio_registers_ops {
+	int (*hdmi_audio_read_register)(uint32_t reg_addr, uint32_t *data);
+	int (*hdmi_audio_write_register)(uint32_t reg_addr, uint32_t data);
+	int (*hdmi_audio_read_modify)(uint32_t reg_addr,
+			uint32_t data, uint32_t mask);
+};
+
+struct hdmi_audio_query_set_ops {
+	int (*hdmi_audio_get_caps)(enum had_caps_list query_element,
+					void *capabilties);
+	int (*hdmi_audio_set_caps)(enum had_caps_list set_element,
+					void *capabilties);
+};
+
+typedef struct hdmi_audio_event {
+	int type;
+} hdmi_audio_event_t;
+
+struct snd_intel_had_interface {
+	const char *name;
+	int (*query)(void *had_data, hdmi_audio_event_t event);
+	int (*suspend)(void *had_data, hdmi_audio_event_t event);
+	int (*resume)(void *had_data);
+};
+
+extern int adf_hdmi_audio_setup(
+	had_event_call_back audio_callbacks,
+	struct hdmi_audio_registers_ops *reg_ops,
+	struct hdmi_audio_query_set_ops *query_ops);
+extern int adf_hdmi_audio_register(
+			struct snd_intel_had_interface *driver, void *had_data);
+extern bool adf_hdmi_audio_is_busy(void);
+extern bool adf_hdmi_audio_suspend(void);
+extern void adf_hdmi_audio_resume(void);
+extern void adf_hdmi_audio_signal_event(enum had_event_type event);
+
+#endif /* ADF_HDMI_AUDIO_IF_H */
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_audio.c b/drivers/video/adf/intel/core/common/hdmi/hdmi_audio.c
new file mode 100644
index 0000000..6c60b49
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_audio.c
@@ -0,0 +1,298 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include "adf_hdmi_audio_if.h"
+#include "hdmi_pipe.h"
+
+/*
+ * Audio register range 0x69000 to 0x69114
+ */
+#define IS_HDMI_AUDIO_REG(reg) ((reg >= AUD_CONFIG) && \
+				(reg <= AUD_HDMIW_INFOFR))
+
+static struct hdmi_pipe  *pipe;
+
+#if 0
+static void hdmi_suspend_work(struct work_struct *work)
+{
+	struct android_hdmi_priv *hdmi_priv =
+		container_of(work, struct android_hdmi_priv, suspend_wq);
+	struct drm_device *dev = hdmi_priv->dev;
+
+	android_hdmi_suspend_display(dev);
+}
+
+/*
+ * return whether HDMI audio device is busy.
+*/
+bool mid_hdmi_audio_is_busy(struct drm_device *dev)
+{
+	struct drm_psb_private *dev_priv = dev->dev_private;
+	int hdmi_audio_busy = 0;
+	hdmi_audio_event_t hdmi_audio_event;
+
+	if (hdmi_state == 0) {
+		/* HDMI is not connected, assuming audio device is idle. */
+		return false;
+	}
+
+	if (dev_priv->had_interface) {
+		hdmi_audio_event.type = HAD_EVENT_QUERY_IS_AUDIO_BUSY;
+		hdmi_audio_busy = dev_priv->had_interface->query(
+			dev_priv->had_pvt_data,
+			hdmi_audio_event);
+		return hdmi_audio_busy != 0;
+	}
+	return false;
+}
+
+/*
+ * return whether HDMI audio device is suspended.
+*/
+bool mid_hdmi_audio_suspend(struct drm_device *dev)
+{
+	struct drm_psb_private *dev_priv = dev->dev_private;
+	hdmi_audio_event_t hdmi_audio_event;
+	int ret = 0;
+
+	PSB_DEBUG_ENTRY("%s: hdmi_state %d", __func__, hdmi_state);
+	if (hdmi_state == 0) {
+		/* HDMI is not connected,
+		*assuming audio device is suspended already.
+		*/
+		return true;
+	}
+
+	if (dev_priv->had_interface) {
+		hdmi_audio_event.type = 0;
+		ret = dev_priv->had_interface->suspend(
+						dev_priv->had_pvt_data,
+						hdmi_audio_event);
+		return (ret == 0) ? true : false;
+	}
+	return true;
+}
+
+void mid_hdmi_audio_resume(struct drm_device *dev)
+{
+	struct drm_psb_private *dev_priv = dev->dev_private;
+	PSB_DEBUG_ENTRY("%s: hdmi_state %d", __func__, hdmi_state);
+	if (hdmi_state == 0) {
+		/* HDMI is not connected,
+		*  there is no need to resume audio device.
+		*/
+		return;
+	}
+
+	if (dev_priv->had_interface)
+		dev_priv->had_interface->resume(dev_priv->had_pvt_data);
+}
+#endif
+
+static void adf_audio_hotplug_work(struct work_struct *work)
+{
+	pr_debug("%s\n", __func__);
+	if (atomic_read(&pipe->hpd_ctx.is_connected))
+		adf_hdmi_audio_signal_event(HAD_EVENT_HOT_PLUG);
+}
+
+static void adf_audio_bufferdone_work(struct work_struct *work)
+{
+	pr_debug("%s\n", __func__);
+	if (atomic_read(&pipe->hpd_ctx.is_connected))
+		adf_hdmi_audio_signal_event(HAD_EVENT_AUDIO_BUFFER_DONE);
+}
+
+static void adf_audio_underrun_work(struct work_struct *work)
+{
+	pr_debug("%s\n", __func__);
+	if (atomic_read(&pipe->hpd_ctx.is_connected))
+		adf_hdmi_audio_signal_event(HAD_EVENT_AUDIO_BUFFER_UNDERRUN);
+}
+
+void adf_hdmi_audio_signal_event(
+						enum had_event_type event)
+{
+	pr_debug("%s: event type= %d\n", __func__, event);
+	if (pipe->audio.callbacks)
+		(pipe->audio.callbacks)
+				(event, pipe->audio.had_pvt_data);
+}
+
+void adf_hdmi_audio_init(struct hdmi_pipe *hdmi_pipe)
+{
+	pipe = hdmi_pipe;
+	INIT_WORK(&pipe->audio.hdmi_audio_work, adf_audio_hotplug_work);
+	INIT_WORK(&pipe->audio.hdmi_bufferdone_work, adf_audio_bufferdone_work);
+	INIT_WORK(&pipe->audio.hdmi_underrun_work, adf_audio_underrun_work);
+}
+
+/**
+ * mid_hdmi_audio_get_caps:
+ * used to return the HDMI audio capabilities.
+ * e.g. resolution, frame rate.
+ */
+static int adf_hdmi_audio_get_caps(enum had_caps_list get_element,
+		void *capabilities)
+{
+
+	switch (get_element) {
+	case HAD_GET_ELD:
+		pr_debug("%s: HAD_GET_ELD\n", __func__);
+		memcpy(capabilities, &pipe->monitor.eld[7], sizeof(uint8_t));
+		break;
+	case HAD_GET_SAMPLING_FREQ:
+	{
+		pr_debug("%s: HAD_GET_SAMPLING_FREQ\n", __func__);
+		memcpy(capabilities, &pipe->audio.tmds_clock, sizeof(uint32_t));
+		break;
+	}
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+/**
+ * mid_hdmi_audio_set_caps:
+ * used to set the HDMI audio capabilities.
+ * e.g. Audio INT.
+ */
+static int adf_hdmi_audio_set_caps(enum had_caps_list set_element,
+		void *capabilties)
+{
+	int ret = 0;
+
+	switch (set_element) {
+	case HAD_SET_ENABLE_AUDIO:
+		pr_debug("%s: HAD_SET_ENABLE_AUDIO\n", __func__);
+		break;
+	case HAD_SET_DISABLE_AUDIO:
+		pr_debug("%s: HAD_SET_DISABLE_AUDIO\n", __func__);
+		break;
+	case HAD_SET_ENABLE_AUDIO_INT:
+		pr_debug("%s: HAD_SET_ENABLE_AUDIO_INT\n", __func__);
+		break;
+	case HAD_SET_DISABLE_AUDIO_INT:
+		pr_debug("%s: HAD_SET_DISABLE_AUDIO_INT\n", __func__);
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * mid_hdmi_audio_write:
+ * used to write into display controller HDMI audio registers.
+ *
+ */
+static int adf_hdmi_audio_write(uint32_t reg, uint32_t val)
+{
+	pr_debug("%s: reg=%x, val=%x\n", __func__, reg, val);
+	if (IS_HDMI_AUDIO_REG(reg)) {
+		REG_WRITE(reg, val);
+		return 0;
+	} else
+		return -EINVAL;
+}
+
+/**
+ * mid_hdmi_audio_read:
+ * used to get the register value read
+ * from display controller HDMI audio registers.
+ *
+ */
+static int adf_hdmi_audio_read(uint32_t reg, uint32_t *val)
+{
+	pr_debug("%s: reg=%x\n", __func__, reg);
+	if (IS_HDMI_AUDIO_REG(reg)) {
+		*val = REG_READ(reg);
+		return 0;
+	} else
+		return -EINVAL;
+}
+
+/**
+ * mid_hdmi_audio_rmw:
+ * used to update the masked bits in display
+ * controller HDMI audio registers .
+ *
+ */
+static int adf_hdmi_audio_rmw(uint32_t reg,
+				uint32_t val, uint32_t mask)
+{
+	u32 val_tmp;
+	pr_debug("%s: reg=%x, val=%x\n", __func__, reg, val);
+	if (IS_HDMI_AUDIO_REG(reg)) {
+		val_tmp = (val & mask) | (REG_READ(reg) & ~mask);
+		REG_WRITE(reg, val_tmp);
+		return 0;
+	} else
+		return -EINVAL;
+}
+
+static struct  hdmi_audio_registers_ops hdmi_audio_reg_ops = {
+	.hdmi_audio_read_register = adf_hdmi_audio_read,
+	.hdmi_audio_write_register = adf_hdmi_audio_write,
+	.hdmi_audio_read_modify = adf_hdmi_audio_rmw,
+};
+
+static struct hdmi_audio_query_set_ops hdmi_audio_get_set_ops = {
+	.hdmi_audio_get_caps = adf_hdmi_audio_get_caps,
+	.hdmi_audio_set_caps = adf_hdmi_audio_set_caps,
+};
+
+int adf_hdmi_audio_setup(
+	had_event_call_back audio_callbacks,
+	struct hdmi_audio_registers_ops *reg_ops,
+	struct hdmi_audio_query_set_ops *query_ops)
+{
+	int ret = 0;
+	reg_ops->hdmi_audio_read_register =
+			(hdmi_audio_reg_ops.hdmi_audio_read_register);
+	reg_ops->hdmi_audio_write_register =
+				(hdmi_audio_reg_ops.hdmi_audio_write_register);
+	reg_ops->hdmi_audio_read_modify =
+			(hdmi_audio_reg_ops.hdmi_audio_read_modify);
+	query_ops->hdmi_audio_get_caps =
+			hdmi_audio_get_set_ops.hdmi_audio_get_caps;
+	query_ops->hdmi_audio_set_caps =
+			hdmi_audio_get_set_ops.hdmi_audio_set_caps;
+
+	pipe->audio.callbacks = audio_callbacks;
+	return ret;
+}
+EXPORT_SYMBOL(adf_hdmi_audio_setup);
+
+int adf_hdmi_audio_register(struct snd_intel_had_interface *driver,
+							void *had_data)
+{
+	pr_debug("%s\n", __func__);
+	pipe->audio.had_pvt_data = had_data;
+	pipe->audio.had_interface = driver;
+
+	if (pipe->monitor.is_hdmi == false)
+		return 0;
+
+	/* The Audio driver is loading now and we need to notify
+	 * it if there is an HDMI device attached */
+	schedule_work(&pipe->audio.hdmi_audio_work);
+	return 0;
+}
+EXPORT_SYMBOL(adf_hdmi_audio_register);
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_edid.c b/drivers/video/adf/intel/core/common/hdmi/hdmi_edid.c
new file mode 100644
index 0000000..ec8ab32
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_edid.c
@@ -0,0 +1,3096 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include <linux/i2c.h>
+#include <linux/slab.h>
+
+#include "hdmi_edid.h"
+
+static const u8 edid_header[] = {
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
+};
+
+/*
+ * Autogenerated from the DMT spec.
+ * This table is copied from xfree86/modes/xf86EdidModes.c.
+ */
+static const struct drm_mode_modeinfo dmt_modes[] = {
+	/* 640x350@85Hz */
+	{ DEFINE_MODE("640x350", DRM_MODE_TYPE_DRIVER, 31500, 640, 672,
+		   736, 832, 0, 350, 382, 385, 445, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x400@85Hz */
+	{ DEFINE_MODE("640x400", DRM_MODE_TYPE_DRIVER, 31500, 640, 672,
+		   736, 832, 0, 400, 401, 404, 445, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 720x400@85Hz */
+	{ DEFINE_MODE("720x400", DRM_MODE_TYPE_DRIVER, 35500, 720, 756,
+		   828, 936, 0, 400, 401, 404, 446, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 640x480@60Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		   752, 800, 0, 480, 489, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@72Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 31500, 640, 664,
+		   704, 832, 0, 480, 489, 492, 520, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@75Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 31500, 640, 656,
+		   720, 840, 0, 480, 481, 484, 500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@85Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 36000, 640, 696,
+		   752, 832, 0, 480, 481, 484, 509, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 800x600@56Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 36000, 800, 824,
+		   896, 1024, 0, 600, 601, 603, 625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@60Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 40000, 800, 840,
+		   968, 1056, 0, 600, 601, 605, 628, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@72Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 50000, 800, 856,
+		   976, 1040, 0, 600, 637, 643, 666, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@75Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 49500, 800, 816,
+		   896, 1056, 0, 600, 601, 604, 625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@85Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 56250, 800, 832,
+		   896, 1048, 0, 600, 601, 604, 631, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@120Hz RB */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 73250, 800, 848,
+		   880, 960, 0, 600, 603, 607, 636, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 848x480@60Hz */
+	{ DEFINE_MODE("848x480", DRM_MODE_TYPE_DRIVER, 33750, 848, 864,
+		   976, 1088, 0, 480, 486, 494, 517, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@43Hz, interlace */
+	{ DEFINE_MODE("1024x768i", DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,
+		   1208, 1264, 0, 768, 768, 772, 817, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE) },
+	/* 1024x768@60Hz */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,
+		   1184, 1344, 0, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1024x768@70Hz */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,
+		   1184, 1328, 0, 768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1024x768@75Hz */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 78750, 1024, 1040,
+		   1136, 1312, 0, 768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@85Hz */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 94500, 1024, 1072,
+		   1168, 1376, 0, 768, 769, 772, 808, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@120Hz RB */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 115500, 1024, 1072,
+		   1104, 1184, 0, 768, 771, 775, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1152x864@75Hz */
+	{ DEFINE_MODE("1152x864", DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,
+		   1344, 1600, 0, 864, 865, 868, 900, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x768@60Hz RB */
+	{ DEFINE_MODE("1280x768", DRM_MODE_TYPE_DRIVER, 68250, 1280, 1328,
+		   1360, 1440, 0, 768, 771, 778, 790, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x768@60Hz */
+	{ DEFINE_MODE("1280x768", DRM_MODE_TYPE_DRIVER, 79500, 1280, 1344,
+		   1472, 1664, 0, 768, 771, 778, 798, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x768@75Hz */
+	{ DEFINE_MODE("1280x768", DRM_MODE_TYPE_DRIVER, 102250, 1280, 1360,
+		   1488, 1696, 0, 768, 771, 778, 805, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x768@85Hz */
+	{ DEFINE_MODE("1280x768", DRM_MODE_TYPE_DRIVER, 117500, 1280, 1360,
+		   1496, 1712, 0, 768, 771, 778, 809, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x768@120Hz RB */
+	{ DEFINE_MODE("1280x768", DRM_MODE_TYPE_DRIVER, 140250, 1280, 1328,
+		   1360, 1440, 0, 768, 771, 778, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x800@60Hz RB */
+	{ DEFINE_MODE("1280x800", DRM_MODE_TYPE_DRIVER, 71000, 1280, 1328,
+		   1360, 1440, 0, 800, 803, 809, 823, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x800@60Hz */
+	{ DEFINE_MODE("1280x800", DRM_MODE_TYPE_DRIVER, 83500, 1280, 1352,
+		   1480, 1680, 0, 800, 803, 809, 831, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x800@75Hz */
+	{ DEFINE_MODE("1280x800", DRM_MODE_TYPE_DRIVER, 106500, 1280, 1360,
+		   1488, 1696, 0, 800, 803, 809, 838, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x800@85Hz */
+	{ DEFINE_MODE("1280x800", DRM_MODE_TYPE_DRIVER, 122500, 1280, 1360,
+		   1496, 1712, 0, 800, 803, 809, 843, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x800@120Hz RB */
+	{ DEFINE_MODE("1280x800", DRM_MODE_TYPE_DRIVER, 146250, 1280, 1328,
+		   1360, 1440, 0, 800, 803, 809, 847, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x960@60Hz */
+	{ DEFINE_MODE("1280x960", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1376,
+		   1488, 1800, 0, 960, 961, 964, 1000, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x960@85Hz */
+	{ DEFINE_MODE("1280x960", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1344,
+		   1504, 1728, 0, 960, 961, 964, 1011, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x960@120Hz RB */
+	{ DEFINE_MODE("1280x960", DRM_MODE_TYPE_DRIVER, 175500, 1280, 1328,
+		   1360, 1440, 0, 960, 963, 967, 1017, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1280x1024@60Hz */
+	{ DEFINE_MODE("1280x1024", DRM_MODE_TYPE_DRIVER, 108000, 1280, 1328,
+		   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x1024@75Hz */
+	{ DEFINE_MODE("1280x1024", DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,
+		   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x1024@85Hz */
+	{ DEFINE_MODE("1280x1024", DRM_MODE_TYPE_DRIVER, 157500, 1280, 1344,
+		   1504, 1728, 0, 1024, 1025, 1028, 1072, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x1024@120Hz RB */
+	{ DEFINE_MODE("1280x1024", DRM_MODE_TYPE_DRIVER, 187250, 1280, 1328,
+		   1360, 1440, 0, 1024, 1027, 1034, 1084, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1360x768@60Hz */
+	{ DEFINE_MODE("1360x768", DRM_MODE_TYPE_DRIVER, 85500, 1360, 1424,
+		   1536, 1792, 0, 768, 771, 777, 795, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1360x768@120Hz RB */
+	{ DEFINE_MODE("1360x768", DRM_MODE_TYPE_DRIVER, 148250, 1360, 1408,
+		   1440, 1520, 0, 768, 771, 776, 813, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1400x1050@60Hz RB */
+	{ DEFINE_MODE("1400x1050", DRM_MODE_TYPE_DRIVER, 101000, 1400, 1448,
+		   1480, 1560, 0, 1050, 1053, 1057, 1080, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1400x1050@60Hz */
+	{ DEFINE_MODE("1400x1050", DRM_MODE_TYPE_DRIVER, 121750, 1400, 1488,
+		   1632, 1864, 0, 1050, 1053, 1057, 1089, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1400x1050@75Hz */
+	{ DEFINE_MODE("1400x1050", DRM_MODE_TYPE_DRIVER, 156000, 1400, 1504,
+		   1648, 1896, 0, 1050, 1053, 1057, 1099, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1400x1050@85Hz */
+	{ DEFINE_MODE("1400x1050", DRM_MODE_TYPE_DRIVER, 179500, 1400, 1504,
+		   1656, 1912, 0, 1050, 1053, 1057, 1105, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1400x1050@120Hz RB */
+	{ DEFINE_MODE("1400x1050", DRM_MODE_TYPE_DRIVER, 208000, 1400, 1448,
+		   1480, 1560, 0, 1050, 1053, 1057, 1112, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1440x900@60Hz RB */
+	{ DEFINE_MODE("1440x900", DRM_MODE_TYPE_DRIVER, 88750, 1440, 1488,
+		   1520, 1600, 0, 900, 903, 909, 926, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1440x900@60Hz */
+	{ DEFINE_MODE("1440x900", DRM_MODE_TYPE_DRIVER, 106500, 1440, 1520,
+		   1672, 1904, 0, 900, 903, 909, 934, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1440x900@75Hz */
+	{ DEFINE_MODE("1440x900", DRM_MODE_TYPE_DRIVER, 136750, 1440, 1536,
+		   1688, 1936, 0, 900, 903, 909, 942, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1440x900@85Hz */
+	{ DEFINE_MODE("1440x900", DRM_MODE_TYPE_DRIVER, 157000, 1440, 1544,
+		   1696, 1952, 0, 900, 903, 909, 948, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1440x900@120Hz RB */
+	{ DEFINE_MODE("1440x900", DRM_MODE_TYPE_DRIVER, 182750, 1440, 1488,
+		   1520, 1600, 0, 900, 903, 909, 953, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1600x1200@60Hz */
+	{ DEFINE_MODE("1600x1200", DRM_MODE_TYPE_DRIVER, 162000, 1600, 1664,
+		   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1600x1200@65Hz */
+	{ DEFINE_MODE("1600x1200", DRM_MODE_TYPE_DRIVER, 175500, 1600, 1664,
+		   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1600x1200@70Hz */
+	{ DEFINE_MODE("1600x1200", DRM_MODE_TYPE_DRIVER, 189000, 1600, 1664,
+		   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1600x1200@75Hz */
+	{ DEFINE_MODE("1600x1200", DRM_MODE_TYPE_DRIVER, 202500, 1600, 1664,
+		   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1600x1200@85Hz */
+	{ DEFINE_MODE("1600x1200", DRM_MODE_TYPE_DRIVER, 229500, 1600, 1664,
+		   1856, 2160, 0, 1200, 1201, 1204, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1600x1200@120Hz RB */
+	{ DEFINE_MODE("1600x1200", DRM_MODE_TYPE_DRIVER, 268250, 1600, 1648,
+		   1680, 1760, 0, 1200, 1203, 1207, 1271, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1680x1050@60Hz RB */
+	{ DEFINE_MODE("1680x1050", DRM_MODE_TYPE_DRIVER, 119000, 1680, 1728,
+		   1760, 1840, 0, 1050, 1053, 1059, 1080, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1680x1050@60Hz */
+	{ DEFINE_MODE("1680x1050", DRM_MODE_TYPE_DRIVER, 146250, 1680, 1784,
+		   1960, 2240, 0, 1050, 1053, 1059, 1089, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1680x1050@75Hz */
+	{ DEFINE_MODE("1680x1050", DRM_MODE_TYPE_DRIVER, 187000, 1680, 1800,
+		   1976, 2272, 0, 1050, 1053, 1059, 1099, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1680x1050@85Hz */
+	{ DEFINE_MODE("1680x1050", DRM_MODE_TYPE_DRIVER, 214750, 1680, 1808,
+		   1984, 2288, 0, 1050, 1053, 1059, 1105, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1680x1050@120Hz RB */
+	{ DEFINE_MODE("1680x1050", DRM_MODE_TYPE_DRIVER, 245500, 1680, 1728,
+		   1760, 1840, 0, 1050, 1053, 1059, 1112, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1792x1344@60Hz */
+	{ DEFINE_MODE("1792x1344", DRM_MODE_TYPE_DRIVER, 204750, 1792, 1920,
+		   2120, 2448, 0, 1344, 1345, 1348, 1394, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1792x1344@75Hz */
+	{ DEFINE_MODE("1792x1344", DRM_MODE_TYPE_DRIVER, 261000, 1792, 1888,
+		   2104, 2456, 0, 1344, 1345, 1348, 1417, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1792x1344@120Hz RB */
+	{ DEFINE_MODE("1792x1344", DRM_MODE_TYPE_DRIVER, 333250, 1792, 1840,
+		   1872, 1952, 0, 1344, 1347, 1351, 1423, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1856x1392@60Hz */
+	{ DEFINE_MODE("1856x1392", DRM_MODE_TYPE_DRIVER, 218250, 1856, 1952,
+		   2176, 2528, 0, 1392, 1393, 1396, 1439, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1856x1392@75Hz */
+	{ DEFINE_MODE("1856x1392", DRM_MODE_TYPE_DRIVER, 288000, 1856, 1984,
+		   2208, 2560, 0, 1392, 1395, 1399, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1856x1392@120Hz RB */
+	{ DEFINE_MODE("1856x1392", DRM_MODE_TYPE_DRIVER, 356500, 1856, 1904,
+		   1936, 2016, 0, 1392, 1395, 1399, 1474, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1920x1200@60Hz RB */
+	{ DEFINE_MODE("1920x1200", DRM_MODE_TYPE_DRIVER, 154000, 1920, 1968,
+		   2000, 2080, 0, 1200, 1203, 1209, 1235, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1920x1200@60Hz */
+	{ DEFINE_MODE("1920x1200", DRM_MODE_TYPE_DRIVER, 193250, 1920, 2056,
+		   2256, 2592, 0, 1200, 1203, 1209, 1245, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1920x1200@75Hz */
+	{ DEFINE_MODE("1920x1200", DRM_MODE_TYPE_DRIVER, 245250, 1920, 2056,
+		   2264, 2608, 0, 1200, 1203, 1209, 1255, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1920x1200@85Hz */
+	{ DEFINE_MODE("1920x1200", DRM_MODE_TYPE_DRIVER, 281250, 1920, 2064,
+		   2272, 2624, 0, 1200, 1203, 1209, 1262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1920x1200@120Hz RB */
+	{ DEFINE_MODE("1920x1200", DRM_MODE_TYPE_DRIVER, 317000, 1920, 1968,
+		   2000, 2080, 0, 1200, 1203, 1209, 1271, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1920x1440@60Hz */
+	{ DEFINE_MODE("1920x1440", DRM_MODE_TYPE_DRIVER, 234000, 1920, 2048,
+		   2256, 2600, 0, 1440, 1441, 1444, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1920x1440@75Hz */
+	{ DEFINE_MODE("1920x1440", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2064,
+		   2288, 2640, 0, 1440, 1441, 1444, 1500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1920x1440@120Hz RB */
+	{ DEFINE_MODE("1920x1440", DRM_MODE_TYPE_DRIVER, 380500, 1920, 1968,
+		   2000, 2080, 0, 1440, 1443, 1447, 1525, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 2560x1600@60Hz RB */
+	{ DEFINE_MODE("2560x1600", DRM_MODE_TYPE_DRIVER, 268500, 2560, 2608,
+		   2640, 2720, 0, 1600, 1603, 1609, 1646, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 2560x1600@60Hz */
+	{ DEFINE_MODE("2560x1600", DRM_MODE_TYPE_DRIVER, 348500, 2560, 2752,
+		   3032, 3504, 0, 1600, 1603, 1609, 1658, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 2560x1600@75HZ */
+	{ DEFINE_MODE("2560x1600", DRM_MODE_TYPE_DRIVER, 443250, 2560, 2768,
+		   3048, 3536, 0, 1600, 1603, 1609, 1672, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 2560x1600@85HZ */
+	{ DEFINE_MODE("2560x1600", DRM_MODE_TYPE_DRIVER, 505250, 2560, 2768,
+		   3048, 3536, 0, 1600, 1603, 1609, 1682, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 2560x1600@120Hz RB */
+	{ DEFINE_MODE("2560x1600", DRM_MODE_TYPE_DRIVER, 552750, 2560, 2608,
+		   2640, 2720, 0, 1600, 1603, 1609, 1694, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC)},
+};
+
+static const struct drm_mode_modeinfo edid_est_modes[] = {
+	/* 800x600@60Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 40000, 800, 840,
+		   968, 1056, 0, 600, 601, 605, 628, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	 /* 800x600@56Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 36000, 800, 824,
+		   896, 1024, 0, 600, 601, 603,  625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 640x480@75Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 31500, 640, 656,
+		   720, 840, 0, 480, 481, 484, 500, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@72Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 31500, 640, 664,
+		   704,  832, 0, 480, 489, 491, 520, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@67Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 30240, 640, 704,
+		   768,  864, 0, 480, 483, 486, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 640x480@60Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25200, 640, 656,
+		   752, 800, 0, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 720x400@88Hz */
+	{ DEFINE_MODE("720x400", DRM_MODE_TYPE_DRIVER, 35500, 720, 738,
+		   846, 900, 0, 400, 421, 423,  449, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 720x400@70Hz */
+	{ DEFINE_MODE("720x400", DRM_MODE_TYPE_DRIVER, 28320, 720, 738,
+		   846,  900, 0, 400, 412, 414, 449, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1280x1024@75Hz */
+	{ DEFINE_MODE("1280x1024", DRM_MODE_TYPE_DRIVER, 135000, 1280, 1296,
+		   1440, 1688, 0, 1024, 1025, 1028, 1066, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@75Hz */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 78800, 1024, 1040,
+		   1136, 1312, 0,  768, 769, 772, 800, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1024x768@70Hz */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 75000, 1024, 1048,
+		   1184, 1328, 0,  768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 1024x768@60Hz */
+	{ DEFINE_MODE("1024x768", DRM_MODE_TYPE_DRIVER, 65000, 1024, 1048,
+		   1184, 1344, 0,  768, 771, 777, 806, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	 /* 1024x768@43Hz */
+	{ DEFINE_MODE("1024x768i", DRM_MODE_TYPE_DRIVER, 44900, 1024, 1032,
+		   1208, 1264, 0, 768, 768, 776, 817, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE) },
+	/* 832x624@75Hz */
+	{ DEFINE_MODE("832x624", DRM_MODE_TYPE_DRIVER, 57284, 832, 864,
+		   928, 1152, 0, 624, 625, 628, 667, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC) },
+	/* 800x600@75Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 49500, 800, 816,
+		   896, 1056, 0, 600, 601, 604,  625, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 800x600@72Hz */
+	{ DEFINE_MODE("800x600", DRM_MODE_TYPE_DRIVER, 50000, 800, 856,
+		   976, 1040, 0, 600, 637, 643, 666, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+	/* 1152x864@75Hz */
+	{ DEFINE_MODE("1152x864", DRM_MODE_TYPE_DRIVER, 108000, 1152, 1216,
+		   1344, 1600, 0,  864, 865, 868, 900, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC) },
+};
+
+struct minimode {
+	short w;
+	short h;
+	short r;
+	short rb;
+};
+
+static const struct minimode est3_modes[] = {
+	/* byte 6 */
+	{ 640, 350, 85, 0 },
+	{ 640, 400, 85, 0 },
+	{ 720, 400, 85, 0 },
+	{ 640, 480, 85, 0 },
+	{ 848, 480, 60, 0 },
+	{ 800, 600, 85, 0 },
+	{ 1024, 768, 85, 0 },
+	{ 1152, 864, 75, 0 },
+	/* byte 7 */
+	{ 1280, 768, 60, 1 },
+	{ 1280, 768, 60, 0 },
+	{ 1280, 768, 75, 0 },
+	{ 1280, 768, 85, 0 },
+	{ 1280, 960, 60, 0 },
+	{ 1280, 960, 85, 0 },
+	{ 1280, 1024, 60, 0 },
+	{ 1280, 1024, 85, 0 },
+	/* byte 8 */
+	{ 1360, 768, 60, 0 },
+	{ 1440, 900, 60, 1 },
+	{ 1440, 900, 60, 0 },
+	{ 1440, 900, 75, 0 },
+	{ 1440, 900, 85, 0 },
+	{ 1400, 1050, 60, 1 },
+	{ 1400, 1050, 60, 0 },
+	{ 1400, 1050, 75, 0 },
+	/* byte 9 */
+	{ 1400, 1050, 85, 0 },
+	{ 1680, 1050, 60, 1 },
+	{ 1680, 1050, 60, 0 },
+	{ 1680, 1050, 75, 0 },
+	{ 1680, 1050, 85, 0 },
+	{ 1600, 1200, 60, 0 },
+	{ 1600, 1200, 65, 0 },
+	{ 1600, 1200, 70, 0 },
+	/* byte 10 */
+	{ 1600, 1200, 75, 0 },
+	{ 1600, 1200, 85, 0 },
+	{ 1792, 1344, 60, 0 },
+	{ 1792, 1344, 85, 0 },
+	{ 1856, 1392, 60, 0 },
+	{ 1856, 1392, 75, 0 },
+	{ 1920, 1200, 60, 1 },
+	{ 1920, 1200, 60, 0 },
+	/* byte 11 */
+	{ 1920, 1200, 75, 0 },
+	{ 1920, 1200, 85, 0 },
+	{ 1920, 1440, 60, 0 },
+	{ 1920, 1440, 75, 0 },
+};
+
+static const struct minimode extra_modes[] = {
+	{ 1024, 576,  60, 0 },
+	{ 1366, 768,  60, 0 },
+	{ 1600, 900,  60, 0 },
+	{ 1680, 945,  60, 0 },
+	{ 1920, 1080, 60, 0 },
+	{ 2048, 1152, 60, 0 },
+	{ 2048, 1536, 60, 0 },
+};
+
+/*
+ * Probably taken from CEA-861 spec.
+ * This table is converted from xorg's hw/xfree86/modes/xf86EdidModes.c.
+ */
+static const struct drm_mode_modeinfo edid_cea_modes[] = {
+	/* 1 - 640x480@60Hz */
+	{ DEFINE_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25200, 640, 656,
+		   752, 800, 0, 480, 490, 492, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, },
+	/* 2 - 720x480@60Hz */
+	{ DEFINE_MODE("720x480", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, },
+	/* 3 - 720x480@60Hz */
+	{ DEFINE_MODE("720x480", DRM_MODE_TYPE_DRIVER, 27000, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 4 - 1280x720@60Hz */
+	{ DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 5 - 1920x1080i@60Hz */
+	{ DEFINE_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 6 - 1440x480i@60Hz */
+	{ DEFINE_MODE("1440x480i", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1478,
+		   1602, 1716, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, },
+	/* 7 - 1440x480i@60Hz */
+	{ DEFINE_MODE("1440x480i", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1478,
+		   1602, 1716, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 8 - 1440x240@60Hz */
+	{ DEFINE_MODE("1440x240", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1478,
+		   1602, 1716, 0, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_DBLCLK | DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60,},
+	/* 9 - 1440x240@60Hz */
+	{ DEFINE_MODE("1440x240", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1478,
+		   1602, 1716, 0, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_DBLCLK | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 10 - 2880x480i@60Hz */
+	{ DEFINE_MODE("2880x480i", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, },
+	/* 11 - 2880x480i@60Hz */
+	{ DEFINE_MODE("2880x480i", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 12 - 2880x240@60Hz */
+	{ DEFINE_MODE("2880x240", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 0, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, },
+	/* 13 - 2880x240@60Hz */
+	{ DEFINE_MODE("2880x240", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2956,
+		   3204, 3432, 0, 240, 244, 247, 262, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 14 - 1440x480@60Hz */
+	{ DEFINE_MODE("1440x480", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,
+		   1596, 1716, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, },
+	/* 15 - 1440x480@60Hz */
+	{ DEFINE_MODE("1440x480", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1472,
+		   1596, 1716, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 16 - 1920x1080@60Hz */
+	{ DEFINE_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 17 - 720x576@50Hz */
+	{ DEFINE_MODE("720x576", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 50, },
+	/* 18 - 720x576@50Hz */
+	{ DEFINE_MODE("720x576", DRM_MODE_TYPE_DRIVER, 27000, 720, 732,
+		   796, 864, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 19 - 1280x720@50Hz */
+	{ DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1720,
+		   1760, 1980, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 20 - 1920x1080i@50Hz */
+	{ DEFINE_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 21 - 1440x576i@50Hz */
+	{ DEFINE_MODE("1440x576i", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1464,
+		   1590, 1728, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 50, },
+	/* 22 - 1440x576i@50Hz */
+	{ DEFINE_MODE("1440x576i", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1464,
+		   1590, 1728, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 23 - 1440x288@50Hz */
+	{ DEFINE_MODE("1440x288", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1464,
+		   1590, 1728, 0, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_DBLCLK | DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 50, },
+	/* 24 - 1440x288@50Hz */
+	{ DEFINE_MODE("1440x288", DRM_MODE_TYPE_DRIVER, 27000, 1440, 1464,
+		   1590, 1728, 0, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_DBLCLK | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 25 - 2880x576i@50Hz */
+	{ DEFINE_MODE("2880x576i", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 50, },
+	/* 26 - 2880x576i@50Hz */
+	{ DEFINE_MODE("2880x576i", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 27 - 2880x288@50Hz */
+	{ DEFINE_MODE("2880x288", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 0, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 50, },
+	/* 28 - 2880x288@50Hz */
+	{ DEFINE_MODE("2880x288", DRM_MODE_TYPE_DRIVER, 54000, 2880, 2928,
+		   3180, 3456, 0, 288, 290, 293, 312, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 29 - 1440x576@50Hz */
+	{ DEFINE_MODE("1440x576", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1592, 1728, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 30 - 1440x576@50Hz */
+	{ DEFINE_MODE("1440x576", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1592, 1728, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 50, },
+	/* 31 - 1920x1080@50Hz */
+	{ DEFINE_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 32 - 1920x1080@24Hz */
+	{ DEFINE_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2558,
+		   2602, 2750, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 24, },
+	/* 33 - 1920x1080@25Hz */
+	{ DEFINE_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 25, },
+	/* 34 - 1920x1080@30Hz */
+	{ DEFINE_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 74250, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 30, },
+	/* 35 - 2880x480@60Hz */
+	{ DEFINE_MODE("2880x480", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,
+		   3192, 3432, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, },
+	/* 36 - 2880x480@60Hz */
+	{ DEFINE_MODE("2880x480", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2944,
+		   3192, 3432, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 60, },
+	/* 37 - 2880x576@50Hz */
+	{ DEFINE_MODE("2880x576", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,
+		   3184, 3456, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 50, },
+	/* 38 - 2880x576@50Hz */
+	{ DEFINE_MODE("2880x576", DRM_MODE_TYPE_DRIVER, 108000, 2880, 2928,
+		   3184, 3456, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 39 - 1920x1080i@50Hz */
+	{ DEFINE_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 72000, 1920, 1952,
+		   2120, 2304, 0, 1080, 1126, 1136, 1250, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 50, },
+	/* 40 - 1920x1080i@100Hz */
+	{ DEFINE_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+			DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 100, },
+	/* 41 - 1280x720@100Hz */
+	{ DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1720,
+		   1760, 1980, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 100, },
+	/* 42 - 720x576@100Hz */
+	{ DEFINE_MODE("720x576", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   796, 864, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 100, },
+	/* 43 - 720x576@100Hz */
+	{ DEFINE_MODE("720x576", DRM_MODE_TYPE_DRIVER, 54000, 720, 732,
+		   796, 864, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 100, },
+	/* 44 - 1440x576i@100Hz */
+	{ DEFINE_MODE("1440x576", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1590, 1728, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_DBLCLK | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 100, },
+	/* 45 - 1440x576i@100Hz */
+	{ DEFINE_MODE("1440x576", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1464,
+		   1590, 1728, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_DBLCLK | DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 100, },
+	/* 46 - 1920x1080i@120Hz */
+	{ DEFINE_MODE("1920x1080i", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 120, },
+	/* 47 - 1280x720@120Hz */
+	{ DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 148500, 1280, 1390,
+		   1430, 1650, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 120, },
+	/* 48 - 720x480@120Hz */
+	{ DEFINE_MODE("720x480", DRM_MODE_TYPE_DRIVER, 54000, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 120, },
+	/* 49 - 720x480@120Hz */
+	{ DEFINE_MODE("720x480", DRM_MODE_TYPE_DRIVER, 54000, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 120, },
+	/* 50 - 1440x480i@120Hz */
+	{ DEFINE_MODE("1440x480i", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1478,
+		   1602, 1716, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 120, },
+	/* 51 - 1440x480i@120Hz */
+	{ DEFINE_MODE("1440x480i", DRM_MODE_TYPE_DRIVER, 54000, 1440, 1478,
+		   1602, 1716, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 120, },
+	/* 52 - 720x576@200Hz */
+	{ DEFINE_MODE("720x576", DRM_MODE_TYPE_DRIVER, 108000, 720, 732,
+		   796, 864, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 200, },
+	/* 53 - 720x576@200Hz */
+	{ DEFINE_MODE("720x576", DRM_MODE_TYPE_DRIVER, 108000, 720, 732,
+		   796, 864, 0, 576, 581, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 200, },
+	/* 54 - 1440x576i@200Hz */
+	{ DEFINE_MODE("1440x576i", DRM_MODE_TYPE_DRIVER, 108000, 1440, 1464,
+		   1590, 1728, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 200, },
+	/* 55 - 1440x576i@200Hz */
+	{ DEFINE_MODE("1440x576i", DRM_MODE_TYPE_DRIVER, 108000, 1440, 1464,
+		   1590, 1728, 0, 576, 580, 586, 625, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 200, },
+	/* 56 - 720x480@240Hz */
+	{ DEFINE_MODE("720x480", DRM_MODE_TYPE_DRIVER, 108000, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 240, },
+	/* 57 - 720x480@240Hz */
+	{ DEFINE_MODE("720x480", DRM_MODE_TYPE_DRIVER, 108000, 720, 736,
+		   798, 858, 0, 480, 489, 495, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 240, },
+	/* 58 - 1440x480i@240 */
+	{ DEFINE_MODE("1440x480i", DRM_MODE_TYPE_DRIVER, 108000, 1440, 1478,
+		   1602, 1716, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 240, },
+	/* 59 - 1440x480i@240 */
+	{ DEFINE_MODE("1440x480i", DRM_MODE_TYPE_DRIVER, 108000, 1440, 1478,
+		   1602, 1716, 0, 480, 488, 494, 525, 0,
+		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC |
+		   DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_DBLCLK |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 240, },
+	/* 60 - 1280x720@24Hz */
+	{ DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 59400, 1280, 3040,
+		   3080, 3300, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 24, },
+	/* 61 - 1280x720@25Hz */
+	{ DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3700,
+		   3740, 3960, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 25, },
+	/* 62 - 1280x720@30Hz */
+	{ DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 3040,
+		   3080, 3300, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	  .vrefresh = 30, },
+	/* 63 - 1920x1080@120Hz */
+	{ DEFINE_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2008,
+		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	 .vrefresh = 120, },
+	/* 64 - 1920x1080@100Hz */
+	{ DEFINE_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 297000, 1920, 2448,
+		   2492, 2640, 0, 1080, 1084, 1094, 1125, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR16_9),
+	 .vrefresh = 100, },
+};
+
+static int cea_db_payload_len(const u8 *db)
+{
+	return db[0] & 0x1f;
+}
+
+static int cea_db_tag(const u8 *db)
+{
+	return db[0] >> 5;
+}
+
+#define EDID_PRODUCT_ID(e) ((e)->prod_code[0] | ((e)->prod_code[1] << 8))
+
+
+#define for_each_cea_db(cea, i, start, end) \
+	 for ((i) = (start); \
+		(i) < (end) && (i) + cea_db_payload_len(&(cea)[(i)]) < (end); \
+		(i) += cea_db_payload_len(&(cea)[(i)]) + 1)
+
+static int cea_db_offsets(const u8 *cea, int *start, int *end)
+{
+	/* Data block offset in CEA extension block */
+	*start = 4;
+	*end = cea[2];
+	if (*end == 0)
+		*end = 127;
+	if (*end < 4 || *end > 127)
+		return -ERANGE;
+	return 0;
+}
+
+/**
+  * edid_vendor - match a string against EDID's obfuscated vendor field
+  * @edid: EDID to match
+  * @vendor: vendor string
+  *
+  * Returns true if @vendor is in @edid, false otherwise
+  */
+static bool edid_vendor(struct edid *edid, char *vendor)
+{
+	char edid_vendor[3];
+
+	edid_vendor[0] = ((edid->mfg_id[0] & 0x7c) >> 2) + '@';
+	edid_vendor[1] = (((edid->mfg_id[0] & 0x3) << 3) |
+				   ((edid->mfg_id[1] & 0xe0) >> 5)) + '@';
+	edid_vendor[2] = (edid->mfg_id[1] & 0x1f) + '@';
+
+	return !strncmp(edid_vendor, vendor, 3);
+}
+
+static struct edid_quirk {
+	char vendor[4];
+	int product_id;
+	u32 quirks;
+} edid_quirk_list[] = {
+	/* Acer AL1706 */
+	{ "ACR", 44358, EDID_QUIRK_PREFER_LARGE_60 },
+	/* Acer F51 */
+	{ "API", 0x7602, EDID_QUIRK_PREFER_LARGE_60 },
+	/* Unknown Acer */
+	{ "ACR", 2423, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* Belinea 10 15 55 */
+	{ "MAX", 1516, EDID_QUIRK_PREFER_LARGE_60 },
+	{ "MAX", 0x77e, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Envision Peripherals, Inc. EN-7100e */
+	{ "EPI", 59264, EDID_QUIRK_135_CLOCK_TOO_HIGH },
+	/* Envision EN2028 */
+	{ "EPI", 8232, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* Funai Electronics PM36B */
+	{ "FCM", 13600, EDID_QUIRK_PREFER_LARGE_75 |
+	  EDID_QUIRK_DETAILED_IN_CM },
+
+	/* LG Philips LCD LP154W01-A5 */
+	{ "LPL", 0, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
+	{ "LPL", 0x2a00, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
+
+	/* Philips 107p5 CRT */
+	{ "PHL", 57364, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* Proview AY765C */
+	{ "PTS", 765, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
+
+	/* Samsung SyncMaster 205BW.  Note: irony */
+	{ "SAM", 541, EDID_QUIRK_DETAILED_SYNC_PP },
+	/* Samsung SyncMaster 22[5-6]BW */
+	{ "SAM", 596, EDID_QUIRK_PREFER_LARGE_60 },
+	{ "SAM", 638, EDID_QUIRK_PREFER_LARGE_60 },
+
+	/* ViewSonic VA2026w */
+	{ "VSC", 5020, EDID_QUIRK_FORCE_REDUCED_BLANKING },
+
+	/* Medion MD 30217 PG */
+	{ "MED", 0x7b8, EDID_QUIRK_PREFER_LARGE_75 },
+};
+
+ /*
+ * Sanity check the header of the base EDID block.  Return 8 if the header
+ * is perfect, down to 0 if it's totally wrong.
+ */
+int edid_header_is_valid(const u8 *raw_edid)
+{
+	int i, score = 0;
+
+	for (i = 0; i < sizeof(edid_header); i++)
+		if (raw_edid[i] == edid_header[i])
+			score++;
+
+	return score;
+}
+
+static bool edid_is_zero(u8 *in_edid, int length)
+{
+	if (memchr_inv(in_edid, 0, length))
+		return false;
+
+	return true;
+}
+
+static bool cea_db_is_hdmi_vsdb(const u8 *db)
+{
+	int hdmi_id;
+
+	if (cea_db_tag(db) != VENDOR_BLOCK)
+		return false;
+
+	if (cea_db_payload_len(db) < 5)
+		return false;
+
+	hdmi_id = db[1] | (db[2] << 8) | (db[3] << 16);
+
+	return hdmi_id == HDMI_IDENTIFIER;
+}
+
+u8 *find_cea_extension(struct edid *edid)
+{
+	u8 *edid_ext = NULL;
+	int i;
+
+	/* No EDID or EDID extensions */
+	if (edid == NULL || edid->extensions == 0)
+		return NULL;
+
+	/* Find CEA extension */
+	for (i = 0; i < edid->extensions; i++) {
+		edid_ext = (u8 *)edid + EDID_LENGTH * (i + 1);
+		if (edid_ext[0] == CEA_EXT)
+			break;
+	}
+
+	if (i == edid->extensions)
+		return NULL;
+
+	return edid_ext;
+}
+
+bool detect_hdmi_monitor(struct edid *edid)
+{
+	u8 *edid_ext;
+	int i;
+	int start_offset, end_offset;
+
+	edid_ext = find_cea_extension(edid);
+	if (!edid_ext)
+		return false;
+
+	if (cea_db_offsets(edid_ext, &start_offset, &end_offset))
+		return false;
+
+	/*
+	 * Because HDMI identifier is in Vendor Specific Block,
+	 * search it from all data blocks of CEA extension.
+	 */
+	for_each_cea_db(edid_ext, i, start_offset, end_offset) {
+		if (cea_db_is_hdmi_vsdb(&edid_ext[i]))
+			return true;
+	}
+
+	return false;
+}
+
+ /*
+ * Sanity check the EDID block (base or extension).  Return 0 if the block
+ * doesn't check out, or 1 if it's valid.
+ */
+bool edid_block_valid(u8 *raw_edid, int block)
+{
+	int i;
+	u8 csum = 0;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if (!raw_edid)
+		return false;
+
+	if (block == 0) {
+		int score = edid_header_is_valid(raw_edid);
+		if (score != 8)
+			goto bad;
+	}
+
+	for (i = 0; i < EDID_LENGTH; i++)
+		csum += raw_edid[i];
+	if (csum) {
+		/* allow CEA to slide through, switches mangle this */
+		if (raw_edid[0] != 0x02)
+			goto bad;
+	}
+
+	/* per-block-type checks */
+	switch (raw_edid[0]) {
+	case 0: /* base */
+		if (edid->version != 1)
+			goto bad;
+		break;
+	default:
+		break;
+	}
+
+	return true;
+
+bad:
+	return false;
+}
+
+bool edid_is_valid(struct edid *edid)
+{
+	int i;
+	u8 *raw = (u8 *)edid;
+
+	if (!edid)
+		return false;
+
+	for (i = 0; i <= edid->extensions; i++)
+		if (!edid_block_valid(raw + i * EDID_LENGTH, i))
+			return false;
+
+	return true;
+}
+
+static u8 *do_get_edid(struct i2c_adapter *adapter)
+{
+	int i, j = 0, valid_extensions = 0;
+	u8 *block, *new;
+
+	block = kmalloc(EDID_LENGTH, GFP_KERNEL);
+	if (block  == NULL)
+		return NULL;
+
+	/* base block fetch */
+	for (i = 0; i < 4; i++) {
+		if (probe_ddc_edid(adapter, block, 0, EDID_LENGTH))
+			goto out;
+		if (edid_block_valid(block, 0))
+			break;
+		if (i == 0 && edid_is_zero(block, EDID_LENGTH))
+			goto out;
+	}
+	if (i == 4)
+		goto out;
+
+	/* if there's no extensions, we're done */
+	if (block[0x7e] == 0)
+		return block;
+
+	pr_debug("there is %d extention(s) here!\n", block[0x7e]);
+
+	new = krealloc(block, (block[0x7e] + 1) * EDID_LENGTH, GFP_KERNEL);
+	if (!new)
+		goto out;
+	block = new;
+
+	for (j = 1; j <= block[0x7e]; j++) {
+		for (i = 0; i < 4; i++) {
+			if (probe_ddc_edid(adapter,
+				  block + (valid_extensions + 1) * EDID_LENGTH,
+				  j, EDID_LENGTH))
+				goto out;
+			if (edid_block_valid(block + (valid_extensions + 1) *
+					     EDID_LENGTH, j)) {
+				valid_extensions++;
+				break;
+			}
+		}
+	}
+
+	if (valid_extensions != block[0x7e]) {
+		block[EDID_LENGTH-1] += block[0x7e] - valid_extensions;
+		block[0x7e] = valid_extensions;
+		new = krealloc(block, (valid_extensions + 1) * EDID_LENGTH,
+			       GFP_KERNEL);
+		if (!new)
+			goto out;
+		block = new;
+	}
+
+	return block;
+out:
+	kfree(block);
+	return NULL;
+}
+
+struct edid *get_edid(struct i2c_adapter *adapter)
+{
+	struct edid *raw_edid = NULL;
+	unsigned char out;
+	if (probe_ddc_edid(adapter, &out, 0, 1) == 0) {
+		pr_debug("Start to read EDID\n");
+		raw_edid = (struct edid *)do_get_edid(adapter);
+	}
+
+	if (raw_edid) {
+		pr_debug("Got edid!!\n");
+		print_hex_dump(KERN_ERR, " \t", DUMP_PREFIX_NONE, 1, 1,
+			       raw_edid, EDID_LENGTH * 2, false);
+	}
+	return raw_edid;
+}
+
+int probe_ddc_edid(struct i2c_adapter *adapter, unsigned char *buf,
+					int block, int len)
+{
+	unsigned char start = block * EDID_LENGTH;
+	unsigned char segment = block >> 1;
+	unsigned char xfers = segment ? 3 : 2;
+	int ret, retries = 5;
+
+	/* The core i2c driver will automatically retry the transfer if the
+	  * adapter reports EAGAIN. However, we find that bit-banging transfers
+	  * are susceptible to errors under a heavily loaded machine and
+	  * generate spurious NAKs and timeouts. Retrying the transfer
+	  * of the individual block a few times seems to overcome this.
+	  */
+	do {
+		struct i2c_msg msgs[] = {
+			{
+				.addr	= DDC_SEGMENT_ADDR,
+				.flags	= 0,
+				.len	= 1,
+				.buf	= &segment,
+			}, {
+				.addr	= DDC_ADDR,
+				.flags	= 0,
+				.len	= 1,
+				.buf	= &start,
+			}, {
+				.addr	= DDC_ADDR,
+				.flags	= I2C_M_RD,
+				.len	= len,
+				.buf	= buf,
+			}
+		};
+
+		/*
+		 * Avoid sending the segment addr to not upset non-compliant
+		 * ddc monitors.
+		 */
+		ret = i2c_transfer(adapter, &msgs[3 - xfers], xfers);
+		if (ret == -ENXIO) {
+			pr_debug("HDMI_EDID:skipping non-existent adapter %s\n",
+				adapter->name);
+			break;
+		}
+	} while (ret != xfers && --retries);
+	return ret == xfers ? 0 : -1;
+}
+
+static u32 edid_get_quirks(struct edid *edid)
+{
+	struct edid_quirk *quirk;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {
+		quirk = &edid_quirk_list[i];
+
+		if (edid_vendor(edid, quirk->vendor) &&
+		    (EDID_PRODUCT_ID(edid) == quirk->product_id))
+			return quirk->quirks;
+	}
+
+	return 0;
+}
+
+static void
+cea_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)
+{
+	int i, n = 0;
+	u8 d = ext[0x02];
+	u8 *det_base = ext + d;
+
+	n = (127 - d) / 18;
+	for (i = 0; i < n; i++)
+		cb((struct detailed_timing *)(det_base + 18 * i), closure);
+}
+
+static void
+vtb_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)
+{
+	unsigned int i, n = min_t(int, ext[0x02], 6);
+	u8 *det_base = ext + 5;
+
+	if (ext[0x01] != 1)
+		return; /* unknown version */
+
+	for (i = 0; i < n; i++)
+		cb((struct detailed_timing *)(det_base + 18 * i), closure);
+}
+
+static void for_each_detailed_block(u8 *raw_edid, detailed_cb *cb,
+				    void *closure)
+{
+	int i;
+	struct edid *edid = (struct edid *)raw_edid;
+
+	if (edid == NULL)
+		return;
+
+	for (i = 0; i < EDID_DETAILED_TIMINGS; i++)
+		cb(&(edid->detailed_timings[i]), closure);
+
+	for (i = 1; i <= raw_edid[0x7e]; i++) {
+		u8 *ext = raw_edid + (i * EDID_LENGTH);
+		switch (*ext) {
+		case CEA_EXT:
+			cea_for_each_detailed_block(ext, cb, closure);
+			break;
+		case VTB_EXT:
+			vtb_for_each_detailed_block(ext, cb, closure);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+/**
+ * drm_mode_set_name - set the name on a mode
+ * @mode: name will be set in this mode
+ *
+ * LOCKING:
+ * None.
+ *
+ * Set the name of @mode to a standard format.
+ */
+void mode_set_name(struct drm_mode_modeinfo *mode)
+{
+	bool interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);
+
+	snprintf(mode->name, DRM_DISPLAY_MODE_LEN, "%dx%d%s",
+		 mode->hdisplay, mode->vdisplay,
+		 interlaced ? "i" : "");
+}
+
+/**
+ * drm_mode_vrefresh - get the vrefresh of a mode
+ * @mode: mode
+ *
+ * LOCKING:
+ * None.
+ *
+ * Return @mode's vrefresh rate in Hz or calculate it if necessary.
+ *
+ * FIXME: why is this needed?  shouldn't vrefresh be set already?
+ *
+ * RETURNS:
+ * Vertical refresh rate. It will be the result of actual value plus 0.5.
+ * If it is 70.288, it will return 70Hz.
+ * If it is 59.6, it will return 60Hz.
+ */
+int mode_vrefresh(const struct drm_mode_modeinfo *mode)
+{
+	int refresh = 0;
+	unsigned int calc_val;
+
+	if (mode->vrefresh > 0)
+		refresh = mode->vrefresh;
+	else if (mode->htotal > 0 && mode->vtotal > 0) {
+		int vtotal;
+		vtotal = mode->vtotal;
+		/* work out vrefresh the value will be x1000 */
+		calc_val = (mode->clock * 1000);
+		calc_val /= mode->htotal;
+		refresh = (calc_val + vtotal / 2) / vtotal;
+
+		if (mode->flags & DRM_MODE_FLAG_INTERLACE)
+			refresh *= 2;
+		if (mode->flags & DRM_MODE_FLAG_DBLSCAN)
+			refresh /= 2;
+		if (mode->vscan > 1)
+			refresh /= mode->vscan;
+	}
+	return refresh;
+}
+
+/*
+ * EDID is delightfully ambiguous about how interlaced modes are to be
+ * encoded.  Our internal representation is of frame height, but some
+ * HDTV detailed timings are encoded as field height.
+ *
+ * The format list here is from CEA, in frame size.  Technically we
+ * should be checking refresh rate too.  Whatever.
+ */
+static void
+mode_do_interlace_quirk(struct drm_mode_modeinfo *mode,
+			    struct detailed_pixel_timing *pt)
+{
+	int i;
+	static const struct {
+		int w, h;
+	} cea_interlaced[] = {
+		{ 1920, 1080 },
+		{  720,  480 },
+		{ 1440,  480 },
+		{ 2880,  480 },
+		{  720,  576 },
+		{ 1440,  576 },
+		{ 2880,  576 },
+	};
+
+	if (!(pt->misc & DRM_EDID_PT_INTERLACED))
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(cea_interlaced); i++) {
+		if ((mode->hdisplay == cea_interlaced[i].w) &&
+		    (mode->vdisplay == cea_interlaced[i].h / 2)) {
+			mode->vdisplay *= 2;
+			mode->vsync_start *= 2;
+			mode->vsync_end *= 2;
+			mode->vtotal *= 2;
+			mode->vtotal |= 1;
+		}
+	}
+
+	mode->flags |= DRM_MODE_FLAG_INTERLACE;
+}
+
+/**
+ * cvt_mode -create a modeline based on CVT algorithm
+ * @hdisplay: hdisplay size
+ * @vdisplay: vdisplay size
+ * @vrefresh  : vrefresh rate
+ * @reduced : Whether the GTF calculation is simplified
+ * @interlaced:Whether the interlace is supported
+ *
+ * LOCKING:
+ * none.
+ *
+ * return the modeline based on CVT algorithm
+ *
+ * This function is called to generate the modeline based on CVT algorithm
+ * according to the hdisplay, vdisplay, vrefresh.
+ * It is based from the VESA(TM) Coordinated Video Timing Generator by
+ * Graham Loveridge April 9, 2003 available at
+ * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls
+ *
+ * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.
+ * What I have done is to translate it by using integer calculation.
+ */
+#define HV_FACTOR			1000
+void cvt_mode(struct drm_mode_modeinfo *drm_mode, int hdisplay,
+				      int vdisplay, int vrefresh,
+				      bool reduced, bool interlaced,
+				      bool margins)
+{
+	/* 1) top/bottom margin size (% of height) - default: 1.8, */
+#define	CVT_MARGIN_PERCENTAGE		18
+	/* 2) character cell horizontal granularity (pixels) - default 8 */
+#define	CVT_H_GRANULARITY		8
+	/* 3) Minimum vertical porch (lines) - default 3 */
+#define	CVT_MIN_V_PORCH			3
+	/* 4) Minimum number of vertical back porch lines - default 6 */
+#define	CVT_MIN_V_BPORCH		6
+	/* Pixel Clock step (kHz) */
+#define CVT_CLOCK_STEP			250
+	unsigned int vfieldrate, hperiod;
+	int hdisplay_rnd, hmargin, vdisplay_rnd, vmargin, vsync;
+	int interlace;
+
+	/* the CVT default refresh rate is 60Hz */
+	if (!vrefresh)
+		vrefresh = 60;
+
+	/* the required field fresh rate */
+	if (interlaced)
+		vfieldrate = vrefresh * 2;
+	else
+		vfieldrate = vrefresh;
+
+	/* horizontal pixels */
+	hdisplay_rnd = hdisplay - (hdisplay % CVT_H_GRANULARITY);
+
+	/* determine the left&right borders */
+	hmargin = 0;
+	if (margins) {
+		hmargin = hdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;
+		hmargin -= hmargin % CVT_H_GRANULARITY;
+	}
+	/* find the total active pixels */
+	drm_mode->hdisplay = hdisplay_rnd + 2 * hmargin;
+
+	/* find the number of lines per field */
+	if (interlaced)
+		vdisplay_rnd = vdisplay / 2;
+	else
+		vdisplay_rnd = vdisplay;
+
+	/* find the top & bottom borders */
+	vmargin = 0;
+	if (margins)
+		vmargin = vdisplay_rnd * CVT_MARGIN_PERCENTAGE / 1000;
+
+	drm_mode->vdisplay = vdisplay + 2 * vmargin;
+
+	/* Interlaced */
+	if (interlaced)
+		interlace = 1;
+	else
+		interlace = 0;
+
+	/* Determine VSync Width from aspect ratio */
+	if (!(vdisplay % 3) && ((vdisplay * 4 / 3) == hdisplay))
+		vsync = 4;
+	else if (!(vdisplay % 9) && ((vdisplay * 16 / 9) == hdisplay))
+		vsync = 5;
+	else if (!(vdisplay % 10) && ((vdisplay * 16 / 10) == hdisplay))
+		vsync = 6;
+	else if (!(vdisplay % 4) && ((vdisplay * 5 / 4) == hdisplay))
+		vsync = 7;
+	else if (!(vdisplay % 9) && ((vdisplay * 15 / 9) == hdisplay))
+		vsync = 7;
+	else /* custom */
+		vsync = 10;
+
+	if (!reduced) {
+		/* simplify the GTF calculation */
+		/* 4) Minimum time of vertical sync + back porch interval (µs)
+		 * default 550.0
+		 */
+		int tmp1, tmp2;
+#define CVT_MIN_VSYNC_BP	550
+		/* 3) Nominal HSync width (% of line period) - default 8 */
+#define CVT_HSYNC_PERCENTAGE	8
+		unsigned int hblank_percentage;
+		int vsyncandback_porch, vback_porch, hblank;
+
+		/* estimated the horizontal period */
+		tmp1 = HV_FACTOR * 1000000  -
+				CVT_MIN_VSYNC_BP * HV_FACTOR * vfieldrate;
+		tmp2 = (vdisplay_rnd + 2 * vmargin + CVT_MIN_V_PORCH) * 2 +
+				interlace;
+		hperiod = tmp1 * 2 / (tmp2 * vfieldrate);
+
+		tmp1 = CVT_MIN_VSYNC_BP * HV_FACTOR / hperiod + 1;
+		/* 9. Find number of lines in sync + backporch */
+		if (tmp1 < (vsync + CVT_MIN_V_PORCH))
+			vsyncandback_porch = vsync + CVT_MIN_V_PORCH;
+		else
+			vsyncandback_porch = tmp1;
+		/* 10. Find number of lines in back porch */
+		vback_porch = vsyncandback_porch - vsync;
+		drm_mode->vtotal = vdisplay_rnd + 2 * vmargin +
+				vsyncandback_porch + CVT_MIN_V_PORCH;
+		/* 5) Definition of Horizontal blanking time limitation */
+		/* Gradient (%/kHz) - default 600 */
+#define CVT_M_FACTOR	600
+		/* Offset (%) - default 40 */
+#define CVT_C_FACTOR	40
+		/* Blanking time scaling factor - default 128 */
+#define CVT_K_FACTOR	128
+		/* Scaling factor weighting - default 20 */
+#define CVT_J_FACTOR	20
+#define CVT_M_PRIME	(CVT_M_FACTOR * CVT_K_FACTOR / 256)
+#define CVT_C_PRIME	((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \
+			 CVT_J_FACTOR)
+		/* 12. Find ideal blanking duty cycle from formula */
+		hblank_percentage = CVT_C_PRIME * HV_FACTOR - CVT_M_PRIME *
+					hperiod / 1000;
+		/* 13. Blanking time */
+		if (hblank_percentage < 20 * HV_FACTOR)
+			hblank_percentage = 20 * HV_FACTOR;
+		hblank = drm_mode->hdisplay * hblank_percentage /
+			 (100 * HV_FACTOR - hblank_percentage);
+		hblank -= hblank % (2 * CVT_H_GRANULARITY);
+		/* 14. find the total pixes per line */
+		drm_mode->htotal = drm_mode->hdisplay + hblank;
+		drm_mode->hsync_end = drm_mode->hdisplay + hblank / 2;
+		drm_mode->hsync_start = drm_mode->hsync_end -
+			(drm_mode->htotal * CVT_HSYNC_PERCENTAGE) / 100;
+		drm_mode->hsync_start += CVT_H_GRANULARITY -
+			drm_mode->hsync_start % CVT_H_GRANULARITY;
+		/* fill the Vsync values */
+		drm_mode->vsync_start = drm_mode->vdisplay + CVT_MIN_V_PORCH;
+		drm_mode->vsync_end = drm_mode->vsync_start + vsync;
+	} else {
+		/* Reduced blanking */
+		/* Minimum vertical blanking interval time (µs)- default 460 */
+#define CVT_RB_MIN_VBLANK	460
+		/* Fixed number of clocks for horizontal sync */
+#define CVT_RB_H_SYNC		32
+		/* Fixed number of clocks for horizontal blanking */
+#define CVT_RB_H_BLANK		160
+		/* Fixed number of lines for vertical front porch - default 3*/
+#define CVT_RB_VFPORCH		3
+		int vbilines;
+		int tmp1, tmp2;
+		/* 8. Estimate Horizontal period. */
+		tmp1 = HV_FACTOR * 1000000 -
+			CVT_RB_MIN_VBLANK * HV_FACTOR * vfieldrate;
+		tmp2 = vdisplay_rnd + 2 * vmargin;
+		hperiod = tmp1 / (tmp2 * vfieldrate);
+		/* 9. Find number of lines in vertical blanking */
+		vbilines = CVT_RB_MIN_VBLANK * HV_FACTOR / hperiod + 1;
+		/* 10. Check if vertical blanking is sufficient */
+		if (vbilines < (CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH))
+			vbilines = CVT_RB_VFPORCH + vsync + CVT_MIN_V_BPORCH;
+		/* 11. Find total number of lines in vertical field */
+		drm_mode->vtotal = vdisplay_rnd + 2 * vmargin + vbilines;
+		/* 12. Find total number of pixels in a line */
+		drm_mode->htotal = drm_mode->hdisplay + CVT_RB_H_BLANK;
+		/* Fill in HSync values */
+		drm_mode->hsync_end = drm_mode->hdisplay + CVT_RB_H_BLANK / 2;
+		drm_mode->hsync_start = drm_mode->hsync_end - CVT_RB_H_SYNC;
+		/* Fill in VSync values */
+		drm_mode->vsync_start = drm_mode->vdisplay + CVT_RB_VFPORCH;
+		drm_mode->vsync_end = drm_mode->vsync_start + vsync;
+	}
+	/* 15/13. Find pixel clock frequency (kHz for xf86) */
+	drm_mode->clock = drm_mode->htotal * HV_FACTOR * 1000 / hperiod;
+	drm_mode->clock -= drm_mode->clock % CVT_CLOCK_STEP;
+	/* 18/16. Find actual vertical frame frequency */
+	/* ignore - just set the mode flag for interlaced */
+	if (interlaced) {
+		drm_mode->vtotal *= 2;
+		drm_mode->flags |= DRM_MODE_FLAG_INTERLACE;
+	}
+	/* Fill the mode line name */
+	mode_set_name(drm_mode);
+	if (reduced)
+		drm_mode->flags |= (DRM_MODE_FLAG_PHSYNC |
+					DRM_MODE_FLAG_NVSYNC);
+	else
+		drm_mode->flags |= (DRM_MODE_FLAG_PVSYNC |
+					DRM_MODE_FLAG_NHSYNC);
+}
+
+static int mode_detailed(struct drm_mode_modeinfo *mode, struct edid *edid,
+			 struct detailed_timing *timing, u32 quirks)
+{
+	struct detailed_pixel_timing *pt = &timing->data.pixel_data;
+	int width_mm, height_mm;
+	unsigned hactive = (pt->hactive_hblank_hi & 0xf0) << 4 | pt->hactive_lo;
+	unsigned vactive = (pt->vactive_vblank_hi & 0xf0) << 4 | pt->vactive_lo;
+	unsigned hblank = (pt->hactive_hblank_hi & 0xf) << 8 | pt->hblank_lo;
+	unsigned vblank = (pt->vactive_vblank_hi & 0xf) << 8 | pt->vblank_lo;
+	unsigned hsync_offset =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0xc0) << 2 |
+		pt->hsync_offset_lo;
+
+	unsigned hsync_pulse_width =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0x30) << 4 |
+		pt->hsync_pulse_width_lo;
+
+	unsigned vsync_offset =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0xc) << 2 |
+		pt->vsync_offset_pulse_width_lo >> 4;
+
+	unsigned vsync_pulse_width =
+		(pt->hsync_vsync_offset_pulse_width_hi & 0x3) << 4 |
+		(pt->vsync_offset_pulse_width_lo & 0xf);
+
+	/* ignore tiny modes */
+	if (hactive < 64 || vactive < 64)
+		return -1;
+
+	if (pt->misc & DRM_EDID_PT_STEREO) {
+		pr_debug("stereo mode not supported\n");
+		return -1;
+	}
+	if (!(pt->misc & DRM_EDID_PT_SEPARATE_SYNC))
+		pr_debug("composite sync not supported\n");
+
+	/* it is incorrect if hsync/vsync width is zero */
+	if (!hsync_pulse_width || !vsync_pulse_width) {
+		pr_debug("Incorrect Detailed timing. Wrong Hsync/Vsync pulse width\n");
+		return -1;
+	}
+
+	if (quirks & EDID_QUIRK_FORCE_REDUCED_BLANKING) {
+		cvt_mode(mode, hactive, vactive, 60, true, false, false);
+		goto set_size;
+	}
+
+	if (quirks & EDID_QUIRK_135_CLOCK_TOO_HIGH)
+		timing->pixel_clock = cpu_to_le16(1088);
+
+	mode->clock = le16_to_cpu(timing->pixel_clock) * 10;
+
+	mode->hdisplay = hactive;
+	mode->hsync_start = mode->hdisplay + hsync_offset;
+	mode->hsync_end = mode->hsync_start + hsync_pulse_width;
+	mode->htotal = mode->hdisplay + hblank;
+
+	mode->vdisplay = vactive;
+	mode->vsync_start = mode->vdisplay + vsync_offset;
+	mode->vsync_end = mode->vsync_start + vsync_pulse_width;
+	mode->vtotal = mode->vdisplay + vblank;
+
+	/* Some EDIDs have bogus h/vtotal values */
+	if (mode->hsync_end > mode->htotal)
+		mode->htotal = mode->hsync_end + 1;
+	if (mode->vsync_end > mode->vtotal)
+		mode->vtotal = mode->vsync_end + 1;
+
+	mode_do_interlace_quirk(mode, pt);
+
+	if (quirks & EDID_QUIRK_DETAILED_SYNC_PP) {
+		pt->misc |= DRM_EDID_PT_HSYNC_POSITIVE |
+			    DRM_EDID_PT_VSYNC_POSITIVE;
+	}
+
+	mode->flags |= (pt->misc & DRM_EDID_PT_HSYNC_POSITIVE) ?
+		DRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;
+	mode->flags |= (pt->misc & DRM_EDID_PT_VSYNC_POSITIVE) ?
+		DRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;
+
+set_size:
+	width_mm = pt->width_mm_lo | (pt->width_height_mm_hi & 0xf0) << 4;
+	height_mm = pt->height_mm_lo | (pt->width_height_mm_hi & 0xf) << 8;
+
+	if (quirks & EDID_QUIRK_DETAILED_IN_CM) {
+		width_mm *= 10;
+		height_mm *= 10;
+	}
+
+	if (quirks & EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE) {
+		width_mm = edid->width_cm * 10;
+		height_mm = edid->height_cm * 10;
+	}
+
+	if (width_mm/4 == height_mm/3)
+		mode->flags |= DRM_MODE_FLAG_PAR4_3;
+	if (width_mm/16 == height_mm/9)
+		mode->flags |= DRM_MODE_FLAG_PAR16_9;
+
+	mode->type = DRM_MODE_TYPE_DRIVER;
+	mode->vrefresh = mode_vrefresh(mode);
+	mode_set_name(mode);
+	return 0;
+}
+
+static void do_detailed_mode(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct hdmi_mode_info *newmode;
+
+	if (timing->pixel_clock) {
+		newmode = kzalloc(sizeof(struct hdmi_mode_info), GFP_KERNEL);
+		if (!newmode)
+			return;
+		INIT_LIST_HEAD(&newmode->head);
+		pr_debug("Start to parse 18-byte chunk\n");
+
+		if (mode_detailed(&newmode->drm_mode, closure->edid,
+						timing, closure->quirks) == 0) {
+			if (closure->preferred)
+				newmode->drm_mode.type |=
+						DRM_MODE_TYPE_PREFERRED;
+
+			list_add_tail(&newmode->head,
+				      &closure->monitor->probedModes);
+			closure->modes++;
+			closure->preferred = 0;
+			pr_debug("Add a new mode in %s\n", __func__);
+			pr_debug("vdisplay=%d, hdisplay=%d, vtotal=%d, htotal=%d,"
+				"vfresh=%d, flags=%x, type=%x, name=%s, clock=%d\n",
+				newmode->drm_mode.vdisplay,
+				newmode->drm_mode.hdisplay,
+				newmode->drm_mode.vtotal,
+				newmode->drm_mode.htotal,
+				newmode->drm_mode.vrefresh,
+				newmode->drm_mode.flags,
+				newmode->drm_mode.type,
+				newmode->drm_mode.name,
+				newmode->drm_mode.clock);
+		}
+	}
+}
+
+static int cvt_modes(struct hdmi_monitor *monitor,
+			 struct detailed_timing *timing)
+{
+	int i, j, modes = 0;
+	struct hdmi_mode_info *newmode;
+	struct cvt_timing *cvt;
+	const int rates[] = { 60, 85, 75, 60, 50 };
+	const u8 empty[3] = { 0, 0, 0 };
+
+	for (i = 0; i < 4; i++) {
+		int uninitialized_var(width), height;
+		cvt = &(timing->data.other_data.data.cvt[i]);
+
+		if (!memcmp(cvt->code, empty, 3))
+			continue;
+
+		height = (cvt->code[0] + ((cvt->code[1] & 0xf0) << 4) + 1) * 2;
+		switch (cvt->code[1] & 0x0c) {
+		case 0x00:
+			width = height * 4 / 3;
+			break;
+		case 0x04:
+			width = height * 16 / 9;
+			break;
+		case 0x08:
+			width = height * 16 / 10;
+			break;
+		case 0x0c:
+			width = height * 15 / 9;
+			break;
+		}
+
+		for (j = 1; j < 5; j++) {
+			if (cvt->code[2] & (1 << j)) {
+				newmode = kzalloc(sizeof(struct hdmi_mode_info),
+						 GFP_KERNEL);
+				if (!newmode)
+					continue;
+				INIT_LIST_HEAD(&newmode->head);
+				cvt_mode(&newmode->drm_mode, width, height,
+						       rates[j], j == 0,
+						       false, false);
+				list_add_tail(&newmode->head,
+							&monitor->probedModes);
+				modes++;
+			}
+		}
+	}
+
+	return modes;
+}
+
+static void
+do_cvt_mode(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+
+	pr_debug("In %s and non_pixel data type = %x\n", __func__, data->type);
+
+	if (data->type == EDID_DETAIL_CVT_3BYTE)
+		closure->modes += cvt_modes(closure->monitor, timing);
+}
+
+static void
+find_gtf2(struct detailed_timing *t, void *data)
+{
+	u8 *r = (u8 *)t;
+	if (r[3] == EDID_DETAIL_MONITOR_RANGE && r[10] == 0x02)
+		*(u8 **)data = r;
+}
+
+static int
+gtf2_hbreak(struct edid *edid)
+{
+	u8 *r = NULL;
+	for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? (r[12] * 2) : 0;
+}
+
+/**
+ * standard_timing_level - get std. timing level(CVT/GTF/DMT)
+ * @edid: EDID block to scan
+ */
+static int standard_timing_level(struct edid *edid)
+{
+	if (edid->revision >= 2) {
+		if (edid->revision >= 4 &&
+				(edid->features & DRM_EDID_FEATURE_DEFAULT_GTF))
+			return LEVEL_CVT;
+		if (gtf2_hbreak(edid))
+			return LEVEL_GTF2;
+		return LEVEL_GTF;
+	}
+	return LEVEL_DMT;
+}
+
+static int
+bad_std_timing(u8 a, u8 b)
+{
+	return (a == 0x00 && b == 0x00) ||
+	       (a == 0x01 && b == 0x01) ||
+	       (a == 0x20 && b == 0x20);
+}
+
+static void
+is_rb(struct detailed_timing *t, void *data)
+{
+	u8 *r = (u8 *)t;
+	if (r[3] == EDID_DETAIL_MONITOR_RANGE)
+		if (r[15] & 0x10)
+			*(bool *)data = true;
+}
+
+static bool
+monitor_supports_rb(struct edid *edid)
+{
+	if (edid->revision >= 4) {
+		bool ret = false;
+		for_each_detailed_block((u8 *)edid, is_rb, &ret);
+		return ret;
+	}
+
+	return (edid->input & DRM_EDID_INPUT_DIGITAL) != 0;
+}
+
+static bool
+mode_is_rb(const struct drm_mode_modeinfo *mode)
+{
+	return (mode->htotal - mode->hdisplay == 160) &&
+	       (mode->hsync_end - mode->hdisplay == 80) &&
+	       (mode->hsync_end - mode->hsync_start == 32) &&
+	       (mode->vsync_start - mode->vdisplay == 3);
+}
+
+int  mode_find_dmt(struct drm_mode_modeinfo *dst,
+					   int hsize, int vsize, int fresh,
+					   bool rb)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dmt_modes); i++) {
+		const struct drm_mode_modeinfo *ptr = &dmt_modes[i];
+		if (hsize != ptr->hdisplay)
+			continue;
+		if (vsize != ptr->vdisplay)
+			continue;
+		if (fresh != mode_vrefresh(ptr))
+			continue;
+		if (rb != mode_is_rb(ptr))
+			continue;
+
+		memcpy(dst, ptr, sizeof(struct drm_mode_modeinfo));
+		return 0;
+	}
+
+	return -1;
+}
+
+void gtf_mode_complex(struct drm_mode_modeinfo *drm_mode, int hdisplay,
+		     int vdisplay, int vrefresh, bool interlaced, int margins,
+		     int GTF_M, int GTF_2C, int GTF_K, int GTF_2J)
+{	/* 1) top/bottom margin size (% of height) - default: 1.8, */
+#define	GTF_MARGIN_PERCENTAGE		18
+	/* 2) character cell horizontal granularity (pixels) - default 8 */
+#define	GTF_CELL_GRAN			8
+	/* 3) Minimum vertical porch (lines) - default 3 */
+#define	GTF_MIN_V_PORCH			1
+	/* width of vsync in lines */
+#define V_SYNC_RQD			3
+	/* width of hsync as % of total line */
+#define H_SYNC_PERCENT			8
+	/* min time of vsync + back porch (microsec) */
+#define MIN_VSYNC_PLUS_BP		550
+	/* C' and M' are part of the Blanking Duty Cycle computation */
+#define GTF_C_PRIME	((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)
+#define GTF_M_PRIME	(GTF_K * GTF_M / 256)
+	unsigned int hdisplay_rnd, vdisplay_rnd, vfieldrate_rqd;
+	int top_margin, bottom_margin;
+	int interlace;
+	unsigned int hfreq_est;
+	int vsync_plus_bp, vback_porch;
+	unsigned int vtotal_lines, vfieldrate_est, hperiod;
+	unsigned int vfield_rate, vframe_rate;
+	int left_margin, right_margin;
+	unsigned int total_active_pixels, ideal_duty_cycle;
+	unsigned int hblank, total_pixels, pixel_freq;
+	int hsync, hfront_porch, vodd_front_porch_lines;
+	unsigned int tmp1, tmp2;
+
+
+	/* 1. In order to give correct results, the number of horizontal
+	 * pixels requested is first processed to ensure that it is divisible
+	 * by the character size, by rounding it to the nearest character
+	 * cell boundary:
+	 */
+	hdisplay_rnd = (hdisplay + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;
+	hdisplay_rnd = hdisplay_rnd * GTF_CELL_GRAN;
+
+	/* 2. If interlace is requested, the number of vertical lines assumed
+	 * by the calculation must be halved, as the computation calculates
+	 * the number of vertical lines per field.
+	 */
+	if (interlaced)
+		vdisplay_rnd = vdisplay / 2;
+	else
+		vdisplay_rnd = vdisplay;
+
+	/* 3. Find the frame rate required: */
+	if (interlaced)
+		vfieldrate_rqd = vrefresh * 2;
+	else
+		vfieldrate_rqd = vrefresh;
+
+	/* 4. Find number of lines in Top margin: */
+	top_margin = 0;
+	if (margins)
+		top_margin = (vdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /
+				1000;
+	/* 5. Find number of lines in bottom margin: */
+	bottom_margin = top_margin;
+
+	/* 6. If interlace is required, then set variable interlace: */
+	if (interlaced)
+		interlace = 1;
+	else
+		interlace = 0;
+
+	/* 7. Estimate the Horizontal frequency */
+	{
+		tmp1 = (1000000  - MIN_VSYNC_PLUS_BP * vfieldrate_rqd) / 500;
+		tmp2 = (vdisplay_rnd + 2 * top_margin + GTF_MIN_V_PORCH) *
+				2 + interlace;
+		hfreq_est = (tmp2 * 1000 * vfieldrate_rqd) / tmp1;
+	}
+
+	/* 8. Find the number of lines in V sync + back porch */
+	/* [V SYNC+BP] = RINT(([MIN VSYNC+BP] * hfreq_est / 1000000)) */
+	vsync_plus_bp = MIN_VSYNC_PLUS_BP * hfreq_est / 1000;
+	vsync_plus_bp = (vsync_plus_bp + 500) / 1000;
+	/*  9. Find the number of lines in V back porch alone: */
+	vback_porch = vsync_plus_bp - V_SYNC_RQD;
+	/*  10. Find the total number of lines in Vertical field period: */
+	vtotal_lines = vdisplay_rnd + top_margin + bottom_margin +
+			vsync_plus_bp + GTF_MIN_V_PORCH;
+	/*  11. Estimate the Vertical field frequency: */
+	vfieldrate_est = hfreq_est / vtotal_lines;
+	/*  12. Find the actual horizontal period: */
+	hperiod = 1000000 / (vfieldrate_rqd * vtotal_lines);
+
+	/*  13. Find the actual Vertical field frequency: */
+	vfield_rate = hfreq_est / vtotal_lines;
+	/*  14. Find the Vertical frame frequency: */
+	if (interlaced)
+		vframe_rate = vfield_rate / 2;
+	else
+		vframe_rate = vfield_rate;
+	/*  15. Find number of pixels in left margin: */
+	if (margins)
+		left_margin = (hdisplay_rnd * GTF_MARGIN_PERCENTAGE + 500) /
+				1000;
+	else
+		left_margin = 0;
+
+	/* 16.Find number of pixels in right margin: */
+	right_margin = left_margin;
+	/* 17.Find total number of active pixels in image and left and right */
+	total_active_pixels = hdisplay_rnd + left_margin + right_margin;
+	/* 18.Find the ideal blanking duty cycle from blanking duty cycle */
+	ideal_duty_cycle = GTF_C_PRIME * 1000 -
+				(GTF_M_PRIME * 1000000 / hfreq_est);
+	/* 19.Find the number of pixels in the blanking time to the nearest
+	 * double character cell: */
+	hblank = total_active_pixels * ideal_duty_cycle /
+			(100000 - ideal_duty_cycle);
+	hblank = (hblank + GTF_CELL_GRAN) / (2 * GTF_CELL_GRAN);
+	hblank = hblank * 2 * GTF_CELL_GRAN;
+	/* 20.Find total number of pixels: */
+	total_pixels = total_active_pixels + hblank;
+	/* 21.Find pixel clock frequency: */
+	pixel_freq = total_pixels * hfreq_est / 1000;
+	/* Stage 1 computations are now complete; I should really pass
+	 * the results to another function and do the Stage 2 computations,
+	 * but I only need a few more values so I'll just append the
+	 * computations here for now */
+	/* 17. Find the number of pixels in the horizontal sync period: */
+	hsync = H_SYNC_PERCENT * total_pixels / 100;
+	hsync = (hsync + GTF_CELL_GRAN / 2) / GTF_CELL_GRAN;
+	hsync = hsync * GTF_CELL_GRAN;
+	/* 18. Find the number of pixels in horizontal front porch period */
+	hfront_porch = hblank / 2 - hsync;
+	/*  36. Find the number of lines in the odd front porch period: */
+	vodd_front_porch_lines = GTF_MIN_V_PORCH;
+
+	/* finally, pack the results in the mode struct */
+	drm_mode->hdisplay = hdisplay_rnd;
+	drm_mode->hsync_start = hdisplay_rnd + hfront_porch;
+	drm_mode->hsync_end = drm_mode->hsync_start + hsync;
+	drm_mode->htotal = total_pixels;
+	drm_mode->vdisplay = vdisplay_rnd;
+	drm_mode->vsync_start = vdisplay_rnd + vodd_front_porch_lines;
+	drm_mode->vsync_end = drm_mode->vsync_start + V_SYNC_RQD;
+	drm_mode->vtotal = vtotal_lines;
+
+	drm_mode->clock = pixel_freq;
+
+	if (interlaced) {
+		drm_mode->vtotal *= 2;
+		drm_mode->flags |= DRM_MODE_FLAG_INTERLACE;
+	}
+
+	mode_set_name(drm_mode);
+	if (GTF_M == 600 && GTF_2C == 80 && GTF_K == 128 && GTF_2J == 40)
+		drm_mode->flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_PVSYNC;
+	else
+		drm_mode->flags = DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NVSYNC;
+
+	return;
+}
+
+int mode_hsync(const struct drm_mode_modeinfo *mode)
+{
+	unsigned int calc_val;
+
+	if (mode->htotal < 0)
+		return 0;
+
+	calc_val = (mode->clock * 1000) / mode->htotal; /* hsync in Hz */
+	calc_val += 500;				/* round to 1000Hz */
+	calc_val /= 1000;				/* truncate to kHz */
+
+	return calc_val;
+}
+
+static int
+gtf2_2c(struct edid *edid)
+{
+	u8 *r = NULL;
+	for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[13] : 0;
+}
+
+static int
+gtf2_m(struct edid *edid)
+{
+	u8 *r = NULL;
+	for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? (r[15] << 8) + r[14] : 0;
+}
+
+static int
+gtf2_k(struct edid *edid)
+{
+	u8 *r = NULL;
+	for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[16] : 0;
+}
+
+static int
+gtf2_2j(struct edid *edid)
+{
+	u8 *r = NULL;
+	for_each_detailed_block((u8 *)edid, find_gtf2, &r);
+	return r ? r[17] : 0;
+}
+
+static int
+mode_std(struct hdmi_monitor *monitor, struct drm_mode_modeinfo *drm_mode,
+		struct edid *edid, struct std_timing *t, int revision)
+{
+	struct hdmi_mode_info *m = NULL;
+	int hsize, vsize;
+	int vrefresh_rate;
+	unsigned aspect_ratio = (t->vfreq_aspect & EDID_TIMING_ASPECT_MASK)
+		>> EDID_TIMING_ASPECT_SHIFT;
+	unsigned vfreq = (t->vfreq_aspect & EDID_TIMING_VFREQ_MASK)
+		>> EDID_TIMING_VFREQ_SHIFT;
+	int timing_level = standard_timing_level(edid);
+
+	if (bad_std_timing(t->hsize, t->vfreq_aspect))
+		return -1;
+
+	/* According to the EDID spec, the hdisplay = hsize * 8 + 248 */
+	hsize = t->hsize * 8 + 248;
+	/* vrefresh_rate = vfreq + 60 */
+	vrefresh_rate = vfreq + 60;
+	/* the vdisplay is calculated based on the aspect ratio */
+	if (aspect_ratio == 0) {
+		if (revision < 3)
+			vsize = hsize;
+		else
+			vsize = (hsize * 10) / 16;
+	} else if (aspect_ratio == 1)
+		vsize = (hsize * 3) / 4;
+	else if (aspect_ratio == 2)
+		vsize = (hsize * 4) / 5;
+	else
+		vsize = (hsize * 9) / 16;
+
+	/* HDTV hack, part 1 */
+	if (vrefresh_rate == 60 &&
+	    ((hsize == 1360 && vsize == 765) ||
+	     (hsize == 1368 && vsize == 769))) {
+		hsize = 1366;
+		vsize = 768;
+	}
+
+	/*
+	 * If this connector already has a mode for this size and refresh
+	 * rate (because it came from detailed or CVT info), use that
+	 * instead.  This way we don't have to guess at interlace or
+	 * reduced blanking.
+	 */
+	list_for_each_entry(m, &monitor->probedModes, head)
+		if (m->drm_mode.hdisplay == hsize &&
+					m->drm_mode.vdisplay == vsize &&
+		    mode_vrefresh(&m->drm_mode) == vrefresh_rate)
+			return -1;
+
+	/* HDTV hack, part 2 */
+	if (hsize == 1366 && vsize == 768 && vrefresh_rate == 60) {
+		cvt_mode(drm_mode, 1366, 768, vrefresh_rate, 0, 0,
+				    false);
+		drm_mode->hdisplay = 1366;
+		drm_mode->hsync_start = drm_mode->hsync_start - 1;
+		drm_mode->hsync_end = drm_mode->hsync_end - 1;
+		return 0;
+	}
+
+	/* check whether it can be found in default mode table */
+	if (monitor_supports_rb(edid)) {
+		if (!mode_find_dmt(drm_mode, hsize, vsize, vrefresh_rate,
+				   true))
+			return 0;
+	}
+	if (!mode_find_dmt(drm_mode, hsize, vsize, vrefresh_rate, false))
+		return 0;
+
+	/* okay, generate it */
+	switch (timing_level) {
+	case LEVEL_DMT:
+		break;
+	case LEVEL_GTF:
+		gtf_mode_complex(drm_mode, hsize, vsize, vrefresh_rate, 0, 0,
+				600, 40 * 2, 128, 20 * 2);
+		break;
+	case LEVEL_GTF2:
+		/*
+		 * This is potentially wrong if there's ever a monitor with
+		 * more than one ranges section, each claiming a different
+		 * secondary GTF curve.  Please don't do that.
+		 */
+		gtf_mode_complex(drm_mode, hsize, vsize, vrefresh_rate, 0, 0,
+				600, 40 * 2, 128, 20 * 2);
+		if (mode_hsync(drm_mode) > gtf2_hbreak(edid)) {
+			gtf_mode_complex(drm_mode, hsize, vsize,
+						    vrefresh_rate, 0, 0,
+						    gtf2_m(edid),
+						    gtf2_2c(edid),
+						    gtf2_k(edid),
+						    gtf2_2j(edid));
+		}
+		break;
+	case LEVEL_CVT:
+		cvt_mode(drm_mode, hsize, vsize, vrefresh_rate, 0, 0,
+				    false);
+		break;
+	}
+	return 0;
+}
+
+static void
+do_standard_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+	struct hdmi_monitor *monitor = closure->monitor;
+	struct edid *edid = closure->edid;
+
+	if (data->type == EDID_DETAIL_STD_MODES) {
+		int i;
+		for (i = 0; i < 6; i++) {
+			struct std_timing *std;
+			struct hdmi_mode_info *newmode;
+			int res;
+			newmode = kzalloc(sizeof(struct hdmi_mode_info),
+					 GFP_KERNEL);
+			if (!newmode)
+				return;
+			INIT_LIST_HEAD(&newmode->head);
+			std = &data->data.timings[i];
+			res = mode_std(monitor, &newmode->drm_mode, edid, std,
+					       edid->revision);
+			if (!res) {
+				list_add_tail(&newmode->head,
+					     &monitor->probedModes);
+				pr_debug("Add a new mode in %s\n", __func__);
+				pr_debug("vdisplay=%d, hdisplay=%d, vtotal=%d, htotal=%d,"
+					"vfresh=%d, flags=%x, type=%x, name=%s, clock=%d\n",
+					newmode->drm_mode.vdisplay,
+					newmode->drm_mode.hdisplay,
+					newmode->drm_mode.vtotal,
+					newmode->drm_mode.htotal,
+					newmode->drm_mode.vrefresh,
+					newmode->drm_mode.flags,
+					newmode->drm_mode.type,
+					newmode->drm_mode.name,
+					newmode->drm_mode.clock);
+				closure->modes++;
+			} else
+				kfree(newmode);
+		}
+	}
+}
+
+static int
+fill_est3_modes(struct hdmi_monitor *monitor, struct detailed_timing *timing)
+{
+	int i, j, m, modes = 0;
+	struct hdmi_mode_info *newmode;
+	int res;
+	u8 *est = ((u8 *)timing) + 5;
+
+	for (i = 0; i < 6; i++) {
+		for (j = 7; j > 0; j--) {
+			m = (i * 8) + (7 - j);
+			if (m >= ARRAY_SIZE(est3_modes))
+				break;
+			if (est[i] & (1 << j)) {
+				newmode = kzalloc(sizeof(struct hdmi_mode_info),
+						 GFP_KERNEL);
+				if (!newmode)
+					continue;
+				INIT_LIST_HEAD(&newmode->head);
+				res = mode_find_dmt(&newmode->drm_mode,
+							 est3_modes[m].w,
+							 est3_modes[m].h,
+							 est3_modes[m].r,
+							 est3_modes[m].rb);
+				if (!res) {
+					list_add_tail(&newmode->head,
+						     &monitor->probedModes);
+					modes++;
+				}
+			}
+		}
+	}
+
+	return modes;
+}
+
+static bool
+mode_in_hsync_range(const struct drm_mode_modeinfo *mode,
+		    struct edid *edid, u8 *t)
+{
+	int hsync, hmin, hmax;
+
+	hmin = t[7];
+	if (edid->revision >= 4)
+		hmin += ((t[4] & 0x04) ? 255 : 0);
+	hmax = t[8];
+	if (edid->revision >= 4)
+		hmax += ((t[4] & 0x08) ? 255 : 0);
+	hsync = mode_hsync(mode);
+
+	return hsync <= hmax && hsync >= hmin;
+}
+
+static bool
+mode_in_vsync_range(const struct drm_mode_modeinfo *mode,
+		    struct edid *edid, u8 *t)
+{
+	int vsync, vmin, vmax;
+
+	vmin = t[5];
+	if (edid->revision >= 4)
+		vmin += ((t[4] & 0x01) ? 255 : 0);
+	vmax = t[6];
+	if (edid->revision >= 4)
+		vmax += ((t[4] & 0x02) ? 255 : 0);
+	vsync = mode_vrefresh(mode);
+
+	return vsync <= vmax && vsync >= vmin;
+}
+
+static u32
+range_pixel_clock(struct edid *edid, u8 *t)
+{
+	/* unspecified */
+	if (t[9] == 0 || t[9] == 255)
+		return 0;
+
+	/* 1.4 with CVT support gives us real precision, yay */
+	if (edid->revision >= 4 && t[10] == 0x04)
+		return (t[9] * 10000) - ((t[12] >> 2) * 250);
+
+	/* 1.3 is pathetic, so fuzz up a bit */
+	return t[9] * 10000 + 5001;
+}
+
+static bool
+mode_in_range(const struct drm_mode_modeinfo *mode, struct edid *edid,
+	      struct detailed_timing *timing)
+{
+	u32 max_clock;
+	u8 *t = (u8 *)timing;
+
+	if (!mode_in_hsync_range(mode, edid, t))
+		return false;
+
+	if (!mode_in_vsync_range(mode, edid, t))
+		return false;
+
+	(max_clock = range_pixel_clock(edid, t);
+	if (max_clock)
+		if (mode->clock > max_clock)
+			return false;
+
+	/* 1.4 max horizontal check */
+	if (edid->revision >= 4 && t[10] == 0x04)
+		if (t[13] && mode->hdisplay > 8 * (t[13] + (256 * (t[12]&0x3))))
+			return false;
+
+	if (mode_is_rb(mode) && !monitor_supports_rb(edid))
+		return false;
+
+	return true;
+}
+
+static bool valid_inferred_mode(const struct hdmi_monitor *monitor,
+				const struct drm_mode_modeinfo *mode)
+{
+	struct hdmi_mode_info *m;
+	bool ok = false;
+
+	list_for_each_entry(m, &monitor->probedModes, head) {
+		if (mode->hdisplay == m->drm_mode.hdisplay &&
+		    mode->vdisplay == m->drm_mode.vdisplay &&
+		    mode_vrefresh(mode) == mode_vrefresh(&m->drm_mode))
+			return false; /* duplicated */
+		if (mode->hdisplay <= m->drm_mode.hdisplay &&
+		    mode->vdisplay <= m->drm_mode.vdisplay)
+			ok = true;
+	}
+	return ok;
+}
+
+static int
+dmt_modes_for_range(struct hdmi_monitor *monitor, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+	struct hdmi_mode_info *newmode;
+
+	for (i = 0; i < ARRAY_SIZE(dmt_modes); i++) {
+		if (mode_in_range(dmt_modes + i, edid, timing) &&
+		    valid_inferred_mode(monitor, dmt_modes + i)) {
+			newmode = kzalloc(sizeof(struct hdmi_mode_info),
+					  GFP_KERNEL);
+			if (!newmode)
+				continue;
+			INIT_LIST_HEAD(&newmode->head);
+			memcpy(&newmode->drm_mode, &dmt_modes[i],
+			      sizeof(struct drm_mode_modeinfo));
+			list_add_tail(&newmode->head, &monitor->probedModes);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+/* fix up 1366x768 mode from 1368x768;
+ * GFT/CVT can't express 1366 width which isn't dividable by 8
+ */
+static void fixup_mode_1366x768(struct drm_mode_modeinfo *mode)
+{
+	if (mode->hdisplay == 1368 && mode->vdisplay == 768) {
+		mode->hdisplay = 1366;
+		mode->hsync_start--;
+		mode->hsync_end--;
+		mode_set_name(mode);
+	}
+}
+
+static int
+gtf_modes_for_range(struct hdmi_monitor *monitor, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+	struct hdmi_mode_info *newmode;
+
+	for (i = 0; i < ARRAY_SIZE(extra_modes); i++) {
+		const struct minimode *m = &extra_modes[i];
+		newmode = kzalloc(sizeof(struct hdmi_mode_info), GFP_KERNEL);
+		if (!newmode)
+			continue;
+		INIT_LIST_HEAD(&newmode->head);
+		gtf_mode_complex(&newmode->drm_mode, m->w, m->h, m->r, 0, 0,
+				600, 40 * 2, 128, 20 * 2);
+		fixup_mode_1366x768(&newmode->drm_mode);
+		if (!mode_in_range(&newmode->drm_mode, edid, timing) ||
+		    !valid_inferred_mode(monitor, &newmode->drm_mode)) {
+			kfree(newmode);
+			continue;
+		}
+
+		list_add_tail(&newmode->head, &monitor->probedModes);
+		modes++;
+	}
+
+	return modes;
+}
+
+static int
+cvt_modes_for_range(struct hdmi_monitor *monitor, struct edid *edid,
+			struct detailed_timing *timing)
+{
+	int i, modes = 0;
+	struct hdmi_mode_info *newmode;
+	bool rb = monitor_supports_rb(edid);
+
+	for (i = 0; i < ARRAY_SIZE(extra_modes); i++) {
+		const struct minimode *m = &extra_modes[i];
+		newmode = kzalloc(sizeof(struct hdmi_mode_info), GFP_KERNEL);
+		if (!newmode)
+			continue;
+		INIT_LIST_HEAD(&newmode->head);
+		cvt_mode(&newmode->drm_mode, m->w, m->h, m->r, rb, 0, 0);
+
+		fixup_mode_1366x768(&newmode->drm_mode);
+		if (!mode_in_range(&newmode->drm_mode, edid, timing) ||
+		    !valid_inferred_mode(monitor, &newmode->drm_mode)) {
+			kfree(newmode);
+			continue;
+		}
+
+		list_add_tail(&newmode->head, &monitor->probedModes);
+		modes++;
+	}
+
+	return modes;
+}
+
+static void
+do_established_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+
+	if (data->type == EDID_DETAIL_EST_TIMINGS)
+		closure->modes += fill_est3_modes(closure->monitor, timing);
+}
+
+static void
+do_inferred_modes(struct detailed_timing *timing, void *c)
+{
+	struct detailed_mode_closure *closure = c;
+	struct detailed_non_pixel *data = &timing->data.other_data;
+	struct detailed_data_monitor_range *range = &data->data.range;
+
+	if (data->type != EDID_DETAIL_MONITOR_RANGE)
+		return;
+
+	closure->modes += dmt_modes_for_range(closure->monitor,
+						  closure->edid,
+						  timing);
+
+	if (!version_greater(closure->edid, 1, 1))
+		return; /* GTF not defined yet */
+
+	switch (range->flags) {
+	case 0x02: /* secondary gtf, XXX could do more */
+	case 0x00: /* default gtf */
+		closure->modes += gtf_modes_for_range(closure->monitor,
+							  closure->edid,
+							  timing);
+		break;
+	case 0x04: /* cvt, only in 1.4+ */
+		if (!version_greater(closure->edid, 1, 3))
+			break;
+
+		closure->modes += cvt_modes_for_range(closure->monitor,
+							  closure->edid,
+							  timing);
+		break;
+	case 0x01: /* just the ranges, no formula */
+	default:
+		break;
+	}
+}
+
+bool mode_equal_no_clocks(const struct drm_mode_modeinfo *mode1,
+			 const struct drm_mode_modeinfo *mode2)
+{
+	if (mode1->hdisplay == mode2->hdisplay &&
+	    mode1->hsync_start == mode2->hsync_start &&
+	    mode1->hsync_end == mode2->hsync_end &&
+	    mode1->htotal == mode2->htotal &&
+	    mode1->hskew == mode2->hskew &&
+	    mode1->vdisplay == mode2->vdisplay &&
+	    mode1->vsync_start == mode2->vsync_start &&
+	    mode1->vsync_end == mode2->vsync_end &&
+	    mode1->vtotal == mode2->vtotal &&
+	    mode1->vscan == mode2->vscan &&
+	    mode1->flags == mode2->flags)
+		return true;
+
+	return false;
+}
+
+static unsigned int
+cea_mode_alternate_clock(const struct drm_mode_modeinfo *cea_mode)
+{
+	unsigned int clock = cea_mode->clock;
+
+	if (cea_mode->vrefresh % 6 != 0)
+		return clock;
+
+	/*
+	 * edid_cea_modes contains the 59.94Hz
+	 * variant for 240 and 480 line modes,
+	 * and the 60Hz variant otherwise.
+	 */
+	if (cea_mode->vdisplay == 240 || cea_mode->vdisplay == 480)
+		clock = clock * 1001 / 1000;
+	else
+		clock = DIV_ROUND_UP(clock * 1000, 1001);
+
+	return clock;
+}
+
+u8 match_cea_mode(const struct drm_mode_modeinfo *to_match)
+{
+	u8 mode;
+
+	if (!to_match->clock)
+		return 0;
+
+	for (mode = 0; mode < ARRAY_SIZE(edid_cea_modes); mode++) {
+		const struct drm_mode_modeinfo *cea_mode =
+						&edid_cea_modes[mode];
+
+		unsigned int clock1, clock2;
+
+		/* Check both 60Hz and 59.94Hz */
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+
+		if ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||
+			KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&
+			mode_equal_no_clocks(to_match, cea_mode)) {
+				return mode + 1;
+		}
+	}
+	return 0;
+}
+
+static int
+add_alternate_cea_modes(struct hdmi_monitor *monitor, struct edid *edid)
+{
+	struct hdmi_mode_info *mode, *tmp;
+	int modes = 0;
+	LIST_HEAD(list);
+
+	/* Don't add CEA modes if the CEA extension block is missing */
+	if (!find_cea_extension(edid))
+		return 0;
+
+	/*
+	 * Go through all probed modes and create a new mode
+	 * with the alternate clock for certain CEA modes.
+	 */
+	list_for_each_entry(mode, &monitor->probedModes, head) {
+		const struct drm_mode_modeinfo *cea_mode;
+		struct hdmi_mode_info *newmode;
+		u8 cea_mode_idx = match_cea_mode(&mode->drm_mode) - 1;
+		unsigned int clock1, clock2;
+
+		pr_debug("In %s and mode_idx=%d\n", __func__, cea_mode_idx);
+
+		if (cea_mode_idx >= ARRAY_SIZE(edid_cea_modes) ||
+							cea_mode_idx < 0)
+			continue;
+
+		cea_mode = &edid_cea_modes[cea_mode_idx];
+
+		clock1 = cea_mode->clock;
+		clock2 = cea_mode_alternate_clock(cea_mode);
+
+		if (clock1 == clock2)
+			continue;
+
+		if (mode->drm_mode.clock != clock1 &&
+		    mode->drm_mode.clock != clock2)
+			continue;
+
+		pr_debug("In %s and cea_mode=%p\n", __func__, cea_mode);
+
+		newmode = kzalloc(sizeof(struct hdmi_mode_info), GFP_KERNEL);
+		if (!newmode)
+			continue;
+		INIT_LIST_HEAD(&newmode->head);
+
+
+		pr_debug("In %s and newmode=%p\n", __func__, newmode);
+
+		memcpy(&newmode->drm_mode, cea_mode,
+		      sizeof(struct drm_mode_modeinfo));
+
+		/*
+		 * The current mode could be either variant. Make
+		 * sure to pick the "other" clock for the new mode.
+		 */
+		if (mode->drm_mode.clock != clock1)
+			newmode->drm_mode.clock = clock1;
+		else
+			newmode->drm_mode.clock = clock2;
+
+		list_add_tail(&newmode->head, &list);
+
+	}
+
+	list_for_each_entry_safe(mode, tmp, &list, head) {
+		list_del(&mode->head);
+		list_add_tail(&mode->head, &monitor->probedModes);
+		modes++;
+	}
+	return modes;
+}
+
+static int
+do_cea_modes(struct hdmi_monitor *monitor, u8 *db, u8 len)
+{
+	struct hdmi_mode_info *newmode;
+	u8 *mode, cea_mode;
+	int modes = 0;
+
+	for (mode = db; mode < db + len; mode++) {
+		cea_mode = (*mode & 127) - 1; /*CEA modes are numbered 1..127*/
+		if (cea_mode < ARRAY_SIZE(edid_cea_modes)) {
+			newmode = kzalloc(sizeof(struct hdmi_mode_info),
+					 GFP_KERNEL);
+			if (!newmode)
+				continue;
+			INIT_LIST_HEAD(&newmode->head);
+			memcpy(&newmode->drm_mode, &edid_cea_modes[cea_mode],
+			      sizeof(struct drm_mode_modeinfo));
+			/* TODO: add aspect ratio info here */
+
+			newmode->drm_mode.vrefresh = 0;
+			list_add_tail(&newmode->head, &monitor->probedModes);
+			modes++;
+		}
+	}
+
+	return modes;
+}
+
+static int
+add_cea_modes(struct hdmi_monitor *monitor, struct edid *edid)
+{
+	u8 *cea = find_cea_extension(edid);
+	u8 *db, dbl;
+	int modes = 0;
+
+	if (cea && cea[1] >= 3) {
+		int i, start, end;
+
+		if (cea_db_offsets(cea, &start, &end))
+			return 0;
+
+		for_each_cea_db(cea, i, start, end) {
+			db = &cea[i];
+			dbl = cea_db_payload_len(db);
+
+			if (cea_db_tag(db) == VIDEO_BLOCK)
+				modes += do_cea_modes(monitor, db+1, dbl);
+		}
+	}
+
+	return modes;
+}
+
+static int
+add_established_modes(struct hdmi_monitor *monitor, struct edid *edid)
+{
+	unsigned long est_bits = edid->established_timings.t1 |
+		(edid->established_timings.t2 << 8) |
+		((edid->established_timings.mfg_rsvd & 0x80) << 9);
+	int i, modes = 0;
+	struct detailed_mode_closure closure = {
+		monitor, edid, 0, 0, 0
+	};
+
+	for (i = 0; i <= EDID_EST_TIMINGS; i++) {
+		if (est_bits & (1<<i)) {
+			struct hdmi_mode_info *newmode;
+			newmode = kzalloc(sizeof(struct hdmi_mode_info),
+					 GFP_KERNEL);
+			if (!newmode)
+				continue;
+			INIT_LIST_HEAD(&newmode->head);
+			memcpy(&newmode->drm_mode, &edid_est_modes[i],
+			      sizeof(struct drm_mode_modeinfo));
+			list_add_tail(&newmode->head, &monitor->probedModes);
+			modes++;
+		}
+	}
+
+	if (version_greater(edid, 1, 0))
+		for_each_detailed_block((u8 *)edid,
+					do_established_modes, &closure);
+
+	return modes + closure.modes;
+}
+
+static int
+add_standard_modes(struct hdmi_monitor *monitor, struct edid *edid)
+{
+	int i, modes = 0;
+	struct detailed_mode_closure closure = {
+		monitor, edid, 0, 0, 0
+	};
+
+	pr_debug("enter %s\n", __func__);
+
+	for (i = 0; i < EDID_STD_TIMINGS; i++) {
+		struct hdmi_mode_info *newmode;
+		int res;
+		newmode = kzalloc(sizeof(struct hdmi_mode_info), GFP_KERNEL);
+		if (!newmode)
+			return 0;
+		INIT_LIST_HEAD(&newmode->head);
+		res = mode_std(monitor, &newmode->drm_mode, edid,
+				       &edid->standard_timings[i],
+				       edid->revision);
+		if (!res) {
+			list_add_tail(&newmode->head, &monitor->probedModes);
+			pr_debug("Add a new mode in %s\n", __func__);
+			pr_debug("vdisplay=%d, hdisplay=%d, vtotal=%d, htotal=%d,"
+				"vfresh=%d, flags=%x, type=%x, name=%s, clock=%d\n",
+				newmode->drm_mode.vdisplay,
+				newmode->drm_mode.hdisplay,
+				newmode->drm_mode.vtotal,
+				newmode->drm_mode.htotal,
+				newmode->drm_mode.vrefresh,
+				newmode->drm_mode.flags,
+				newmode->drm_mode.type,
+				newmode->drm_mode.name,
+				newmode->drm_mode.clock);
+			modes++;
+		} else
+			kfree(newmode);
+	}
+
+	if (version_greater(edid, 1, 0))
+		for_each_detailed_block((u8 *)edid, do_standard_modes,
+					    &closure);
+
+	/* XXX should also look for standard codes in VTB blocks */
+
+	return modes + closure.modes;
+}
+
+static int
+add_cvt_modes(struct hdmi_monitor *monitor, struct edid *edid)
+{
+	struct detailed_mode_closure closure = {
+		monitor, edid, 0, 0, 0
+	};
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (version_greater(edid, 1, 2))
+		for_each_detailed_block((u8 *)edid, do_cvt_mode, &closure);
+
+	/* XXX should also look for CVT codes in VTB blocks */
+
+	return closure.modes;
+}
+
+static int add_detailed_modes(struct hdmi_monitor *monitor, struct edid *edid,
+		   u32 quirks)
+{
+	struct detailed_mode_closure closure = {
+		monitor,
+		edid,
+		1,
+		quirks,
+		0
+	};
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (closure.preferred && !version_greater(edid, 1, 3))
+		closure.preferred =
+		    (edid->features & DRM_EDID_FEATURE_PREFERRED_TIMING);
+
+	for_each_detailed_block((u8 *)edid, do_detailed_mode, &closure);
+
+	return closure.modes;
+}
+
+static int
+add_inferred_modes(struct hdmi_monitor *monitor, struct edid *edid)
+{
+	struct detailed_mode_closure closure = {
+		monitor, edid, 0, 0, 0
+	};
+
+	if (version_greater(edid, 1, 0))
+		for_each_detailed_block((u8 *)edid, do_inferred_modes,
+					    &closure);
+
+	return closure.modes;
+}
+
+#define MODE_SIZE(m) ((m)->hdisplay * (m)->vdisplay)
+#define MODE_REFRESH_DIFF(m, r) (abs((m)->vrefresh - target_refresh))
+
+static void edid_fixup_preferred(struct hdmi_monitor *monitor,
+				 u32 quirks)
+{
+	struct hdmi_mode_info *t, *cur_mode, *preferred_mode;
+	int target_refresh = 0;
+
+	if (list_empty(&monitor->probedModes))
+		return;
+
+	if (quirks & EDID_QUIRK_PREFER_LARGE_60)
+		target_refresh = 60;
+	if (quirks & EDID_QUIRK_PREFER_LARGE_75)
+		target_refresh = 75;
+
+	preferred_mode = list_first_entry(&monitor->probedModes,
+					  struct hdmi_mode_info, head);
+
+	list_for_each_entry_safe(cur_mode, t, &monitor->probedModes, head) {
+		cur_mode->drm_mode.type &= ~DRM_MODE_TYPE_PREFERRED;
+
+		if (cur_mode == preferred_mode)
+			continue;
+
+		/* Largest mode is preferred */
+		if (MODE_SIZE(&cur_mode->drm_mode) >
+				MODE_SIZE(&preferred_mode->drm_mode))
+			preferred_mode = cur_mode;
+
+		/* At a given size, try to get closest to target refresh */
+		if ((MODE_SIZE(&cur_mode->drm_mode) ==
+					MODE_SIZE(&preferred_mode->drm_mode)) &&
+		    MODE_REFRESH_DIFF(&cur_mode->drm_mode, target_refresh) <
+		    MODE_REFRESH_DIFF(&preferred_mode->drm_mode,
+				     target_refresh)) {
+			preferred_mode = cur_mode;
+		}
+	}
+
+	preferred_mode->drm_mode.type |= DRM_MODE_TYPE_PREFERRED;
+}
+
+static void
+monitor_name(struct detailed_timing *t, void *data)
+{
+	if (t->data.other_data.type == EDID_DETAIL_MONITOR_NAME)
+		*(u8 **)data = t->data.other_data.data.str.str;
+}
+
+void edid_to_eld(struct hdmi_monitor *monitor, struct edid *edid)
+{
+	uint8_t *eld = monitor->eld;
+	u8 *cea;
+	u8 *name;
+	u8 *db;
+	int sad_count = 0;
+	int mnl;
+	int dbl;
+
+	memset(eld, 0, sizeof(monitor->eld));
+
+	cea = find_cea_extension(edid);
+	if (!cea)
+		return;
+
+	name = NULL;
+	for_each_detailed_block((u8 *)edid, monitor_name, &name);
+	for (mnl = 0; name && mnl < 13; mnl++) {
+		if (name[mnl] == 0x0a)
+			break;
+		eld[20 + mnl] = name[mnl];
+	}
+	eld[4] = (cea[1] << 5) | mnl;
+
+	eld[0] = 2 << 3;		/* ELD version: 2 */
+
+	eld[16] = edid->mfg_id[0];
+	eld[17] = edid->mfg_id[1];
+	eld[18] = edid->prod_code[0];
+	eld[19] = edid->prod_code[1];
+
+	if (cea[1] >= 3) {
+		int i, start, end;
+
+		if (cea_db_offsets(cea, &start, &end)) {
+			start = 0;
+			end = 0;
+		}
+
+		for_each_cea_db(cea, i, start, end) {
+			db = &cea[i];
+			dbl = cea_db_payload_len(db);
+
+			switch (cea_db_tag(db)) {
+			case AUDIO_BLOCK:
+				/* Audio Data Block, contains SADs */
+				sad_count = dbl / 3;
+				if (dbl >= 1)
+					memcpy(eld + 20 + mnl, &db[1], dbl);
+				break;
+			case SPEAKER_BLOCK:
+				/* Speaker Allocation Data Block */
+				if (dbl >= 1)
+					eld[7] = db[1];
+				break;
+			case VENDOR_BLOCK:
+				/* TODO: Vendor-Specific Data Block */
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	eld[5] |= sad_count << 4;
+	eld[2] = (20 + mnl + sad_count * 3 + 3) / 4;
+}
+
+bool rgb_quant_range_selectable(struct edid *edid)
+{
+	u8 *edid_ext;
+	int i, start, end;
+
+	edid_ext = find_cea_extension(edid);
+	if (!edid_ext)
+		return false;
+
+	if (cea_db_offsets(edid_ext, &start, &end))
+		return false;
+
+	for_each_cea_db(edid_ext, i, start, end) {
+		if (cea_db_tag(&edid_ext[i]) == VIDEO_CAPABILITY_BLOCK &&
+		    cea_db_payload_len(&edid_ext[i]) == 2) {
+			return edid_ext[i + 2] & EDID_CEA_VCDB_QS;
+		}
+	}
+
+	return false;
+}
+
+int hdmi_avi_infoframe_from_mode(struct hdmi_monitor *monitor,
+				const struct drm_mode_modeinfo *mode)
+{
+	int err = 0;
+
+	if (!mode)
+		return -EINVAL;
+
+	monitor->video_code = match_cea_mode(mode);
+
+	return err;
+}
+
+void parse_edid(struct hdmi_monitor *monitor, struct edid *raw_edid)
+{
+	int num_modes = 0;
+	u32 quirks;
+
+	if (raw_edid == NULL)
+		return;
+
+	if (!edid_is_valid(raw_edid)) {
+		pr_err("%s: EDID invalid.\n", __func__);
+		return;
+	}
+
+	quirks = edid_get_quirks(raw_edid);
+
+	/*
+	 * detailed modes are those described in 18-byte chunks,
+	 * both standard and extended
+	 */
+
+	num_modes += add_detailed_modes(monitor, raw_edid, quirks);
+	num_modes += add_cvt_modes(monitor, raw_edid);
+	num_modes += add_standard_modes(monitor, raw_edid);
+	num_modes += add_established_modes(monitor, raw_edid);
+	if (raw_edid->features & DRM_EDID_FEATURE_DEFAULT_GTF)
+		num_modes += add_inferred_modes(monitor, raw_edid);
+	num_modes += add_cea_modes(monitor, raw_edid);
+	num_modes += add_alternate_cea_modes(monitor, raw_edid);
+
+	if (quirks & (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))
+		edid_fixup_preferred(monitor, quirks);
+
+	edid_to_eld(monitor, raw_edid);
+	monitor->quant_range_selectable = rgb_quant_range_selectable(raw_edid);
+
+	monitor->screen_width_mm = raw_edid->width_cm * 10;
+	monitor->screen_height_mm = raw_edid->height_cm * 10;
+	pr_debug("In %s and width_cm=%d, height_cm=%d\n", __func__,
+		raw_edid->width_cm, raw_edid->height_cm);
+}
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_edid.h b/drivers/video/adf/intel/core/common/hdmi/hdmi_edid.h
new file mode 100644
index 0000000..1dda494
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_edid.h
@@ -0,0 +1,334 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#ifndef HDMI_EDID_H_
+#define HDMI_EDID_H_
+
+#define EDID_LENGTH 128
+#define DDC_ADDR 0x50
+#define DDC_SEGMENT_ADDR 0x30
+#include "hdmi_pipe.h"
+
+#define DEFINE_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \
+	.name = nm, .type = (t), .clock = (c), \
+	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
+	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
+	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
+	.vscan = (vs), .flags = (f), .vrefresh = 0
+
+struct est_timings {
+	u8 t1;
+	u8 t2;
+	u8 mfg_rsvd;
+} __packed;
+
+struct std_timing {
+	u8 hsize; /* need to multiply by 8 then add 248 */
+	u8 vfreq_aspect;
+} __packed;
+
+/* If detailed data is pixel timing */
+struct detailed_pixel_timing {
+	u8 hactive_lo;
+	u8 hblank_lo;
+	u8 hactive_hblank_hi;
+	u8 vactive_lo;
+	u8 vblank_lo;
+	u8 vactive_vblank_hi;
+	u8 hsync_offset_lo;
+	u8 hsync_pulse_width_lo;
+	u8 vsync_offset_pulse_width_lo;
+	u8 hsync_vsync_offset_pulse_width_hi;
+	u8 width_mm_lo;
+	u8 height_mm_lo;
+	u8 width_height_mm_hi;
+	u8 hborder;
+	u8 vborder;
+	u8 misc;
+} __packed;
+
+/* If it's not pixel timing, it'll be one of the below */
+struct detailed_data_string {
+	u8 str[13];
+} __packed;
+
+struct detailed_data_monitor_range {
+	u8 min_vfreq;
+	u8 max_vfreq;
+	u8 min_hfreq_khz;
+	u8 max_hfreq_khz;
+	u8 pixel_clock_mhz; /* need to multiply by 10 */
+	u8 flags;
+	union {
+		struct {
+			u8 reserved;
+			u8 hfreq_start_khz; /* need to multiply by 2 */
+			u8 c; /* need to divide by 2 */
+			__le16 m;
+			u8 k;
+			u8 j; /* need to divide by 2 */
+		} __packed gtf2;
+		struct {
+			u8 version;
+			u8 data1; /* high 6 bits: extra clock resolution */
+			u8 data2; /* plus low 2 of above: max hactive */
+			u8 supported_aspects;
+			u8 flags; /* preferred aspect and blanking support */
+			u8 supported_scalings;
+			u8 preferred_refresh;
+		} __packed cvt;
+	} formula;
+} __packed;
+
+struct detailed_data_wpindex {
+	u8 white_yx_lo; /* Lower 2 bits each */
+	u8 white_x_hi;
+	u8 white_y_hi;
+	u8 gamma; /* need to divide by 100 then add 1 */
+} __packed;
+
+struct cvt_timing {
+	u8 code[3];
+} __packed;
+
+struct detailed_non_pixel {
+	u8 pad1;
+	u8 type; /* ff=serial, fe=string, fd=monitor range, fc=monitor name
+		    fb=color point data, fa=standard timing data,
+		    f9=undefined, f8=mfg. reserved */
+	u8 pad2;
+	union {
+		struct detailed_data_string str;
+		struct detailed_data_monitor_range range;
+		struct detailed_data_wpindex color;
+		struct std_timing timings[6];
+		struct cvt_timing cvt[4];
+	} data;
+} __packed;
+
+struct detailed_timing {
+	__le16 pixel_clock; /* need to multiply by 10 KHz */
+	union {
+		struct detailed_pixel_timing pixel_data;
+		struct detailed_non_pixel other_data;
+	} data;
+} __packed;
+
+struct edid {
+	u8 header[8];
+	/* Vendor & product info */
+	u8 mfg_id[2];
+	u8 prod_code[2];
+	u32 serial; /* FIXME: byte order */
+	u8 mfg_week;
+	u8 mfg_year;
+	/* EDID version */
+	u8 version;
+	u8 revision;
+	/* Display info: */
+	u8 input;
+	u8 width_cm;
+	u8 height_cm;
+	u8 gamma;
+	u8 features;
+	/* Color characteristics */
+	u8 red_green_lo;
+	u8 black_white_lo;
+	u8 red_x;
+	u8 red_y;
+	u8 green_x;
+	u8 green_y;
+	u8 blue_x;
+	u8 blue_y;
+	u8 white_x;
+	u8 white_y;
+	/* Est. timings and mfg rsvd timings*/
+	struct est_timings established_timings;
+	/* Standard timings 1-8*/
+	struct std_timing standard_timings[8];
+	/* Detailing timings 1-4 */
+	struct detailed_timing detailed_timings[4];
+	/* Number of 128 byte ext. blocks */
+	u8 extensions;
+	/* Checksum */
+	u8 checksum;
+} __packed;
+
+#define HDMI_IDENTIFIER 0x000C03
+#define AUDIO_BLOCK	0x01
+#define VIDEO_BLOCK     0x02
+#define VENDOR_BLOCK    0x03
+#define SPEAKER_BLOCK	0x04
+#define VIDEO_CAPABILITY_BLOCK	0x07
+#define EDID_BASIC_AUDIO	(1 << 6)
+#define EDID_CEA_YCRCB444	(1 << 5)
+#define EDID_CEA_YCRCB422	(1 << 4)
+#define EDID_CEA_VCDB_QS	(1 << 6)
+
+#define CEA_EXT	    0x02
+#define VTB_EXT	    0x10
+#define DI_EXT	    0x40
+#define LS_EXT	    0x50
+#define MI_EXT	    0x60
+
+#define LEVEL_DMT	0
+#define LEVEL_GTF	1
+#define LEVEL_GTF2	2
+#define LEVEL_CVT	3
+
+/*
+ * EDID blocks out in the wild have a variety of bugs, try to collect
+ * them here (note that userspace may work around broken monitors first,
+ * but fixes should make their way here so that the kernel "just works"
+ * on as many displays as possible).
+ */
+/* First detailed mode wrong, use largest 60Hz mode */
+#define EDID_QUIRK_PREFER_LARGE_60		(1 << 0)
+/* Reported 135MHz pixel clock is too high, needs adjustment */
+#define EDID_QUIRK_135_CLOCK_TOO_HIGH		(1 << 1)
+/* Prefer the largest mode at 75 Hz */
+#define EDID_QUIRK_PREFER_LARGE_75		(1 << 2)
+/* Detail timing is in cm not mm */
+#define EDID_QUIRK_DETAILED_IN_CM		(1 << 3)
+/* Detailed timing descriptors have bogus size values, so just take the
+ * maximum size and use that.
+ */
+#define EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE	(1 << 4)
+/* Monitor forgot to set the first detailed is preferred bit. */
+#define EDID_QUIRK_FIRST_DETAILED_PREFERRED	(1 << 5)
+/* use +hsync +vsync for detailed mode */
+#define EDID_QUIRK_DETAILED_SYNC_PP		(1 << 6)
+/* Force reduced-blanking timings for detailed modes */
+#define EDID_QUIRK_FORCE_REDUCED_BLANKING	(1 << 7)
+
+#define EDID_DETAIL_EST_TIMINGS 0xf7
+#define EDID_DETAIL_CVT_3BYTE 0xf8
+#define EDID_DETAIL_COLOR_MGMT_DATA 0xf9
+#define EDID_DETAIL_STD_MODES 0xfa
+#define EDID_DETAIL_MONITOR_CPDATA 0xfb
+#define EDID_DETAIL_MONITOR_NAME 0xfc
+#define EDID_DETAIL_MONITOR_RANGE 0xfd
+#define EDID_DETAIL_MONITOR_STRING 0xfe
+#define EDID_DETAIL_MONITOR_SERIAL 0xff
+
+/* 00=16:10, 01=4:3, 10=5:4, 11=16:9 */
+#define EDID_TIMING_ASPECT_SHIFT 6
+#define EDID_TIMING_ASPECT_MASK  (0x3 << EDID_TIMING_ASPECT_SHIFT)
+
+/* need to add 60 */
+#define EDID_TIMING_VFREQ_SHIFT  0
+#define EDID_TIMING_VFREQ_MASK   (0x3f << EDID_TIMING_VFREQ_SHIFT)
+
+typedef void detailed_cb(struct detailed_timing *timing, void *closure);
+
+#define version_greater(edid, maj, min) \
+	(((edid)->version > (maj)) || \
+	 ((edid)->version == (maj) && (edid)->revision > (min)))
+
+#define EDID_EST_TIMINGS 16
+#define EDID_STD_TIMINGS 8
+#define EDID_DETAILED_TIMINGS 4
+
+#define DRM_EDID_INPUT_SERRATION_VSYNC (1 << 0)
+#define DRM_EDID_INPUT_SYNC_ON_GREEN   (1 << 1)
+#define DRM_EDID_INPUT_COMPOSITE_SYNC  (1 << 2)
+#define DRM_EDID_INPUT_SEPARATE_SYNCS  (1 << 3)
+#define DRM_EDID_INPUT_BLANK_TO_BLACK  (1 << 4)
+#define DRM_EDID_INPUT_VIDEO_LEVEL     (3 << 5)
+#define DRM_EDID_INPUT_DIGITAL         (1 << 7)
+#define DRM_EDID_DIGITAL_DEPTH_MASK    (7 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_UNDEF   (0 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_6       (1 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_8       (2 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_10      (3 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_12      (4 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_14      (5 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_16      (6 << 4)
+#define DRM_EDID_DIGITAL_DEPTH_RSVD    (7 << 4)
+#define DRM_EDID_DIGITAL_TYPE_UNDEF    (0)
+#define DRM_EDID_DIGITAL_TYPE_DVI      (1)
+#define DRM_EDID_DIGITAL_TYPE_HDMI_A   (2)
+#define DRM_EDID_DIGITAL_TYPE_HDMI_B   (3)
+#define DRM_EDID_DIGITAL_TYPE_MDDI     (4)
+#define DRM_EDID_DIGITAL_TYPE_DP       (5)
+
+#define DRM_EDID_FEATURE_DEFAULT_GTF      (1 << 0)
+#define DRM_EDID_FEATURE_PREFERRED_TIMING (1 << 1)
+#define DRM_EDID_FEATURE_STANDARD_COLOR   (1 << 2)
+/* If analog */
+/* 00=mono, 01=rgb, 10=non-rgb, 11=unknown */
+#define DRM_EDID_FEATURE_DISPLAY_TYPE     (3 << 3)
+/* If digital */
+#define DRM_EDID_FEATURE_COLOR_MASK	  (3 << 3)
+#define DRM_EDID_FEATURE_RGB		  (0 << 3)
+#define DRM_EDID_FEATURE_RGB_YCRCB444	  (1 << 3)
+#define DRM_EDID_FEATURE_RGB_YCRCB422	  (2 << 3)
+#define DRM_EDID_FEATURE_RGB_YCRCB	  (3 << 3) /* both 4:4:4 and 4:2:2 */
+
+#define DRM_EDID_FEATURE_PM_ACTIVE_OFF    (1 << 5)
+#define DRM_EDID_FEATURE_PM_SUSPEND       (1 << 6)
+#define DRM_EDID_FEATURE_PM_STANDBY       (1 << 7)
+
+#define DRM_EDID_PT_HSYNC_POSITIVE (1 << 1)
+#define DRM_EDID_PT_VSYNC_POSITIVE (1 << 2)
+#define DRM_EDID_PT_SEPARATE_SYNC  (3 << 3)
+#define DRM_EDID_PT_STEREO         (1 << 5)
+#define DRM_EDID_PT_INTERLACED     (1 << 7)
+
+#define DRM_MODE_TYPE_BUILTIN	(1<<0)
+#define DRM_MODE_TYPE_CLOCK_C	((1<<1) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_CRTC_C	((1<<2) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_PREFERRED	(1<<3)
+#define DRM_MODE_TYPE_DEFAULT	(1<<4)
+#define DRM_MODE_TYPE_USERDEF	(1<<5)
+#define DRM_MODE_TYPE_DRIVER	(1<<6)
+
+/* Video mode flags */
+/* bit compatible with the xorg definitions. */
+#define DRM_MODE_FLAG_PHSYNC	(1<<0)
+#define DRM_MODE_FLAG_NHSYNC	(1<<1)
+#define DRM_MODE_FLAG_PVSYNC	(1<<2)
+#define DRM_MODE_FLAG_NVSYNC	(1<<3)
+#define DRM_MODE_FLAG_INTERLACE	(1<<4)
+#define DRM_MODE_FLAG_DBLSCAN	(1<<5)
+#define DRM_MODE_FLAG_CSYNC	(1<<6)
+#define DRM_MODE_FLAG_PCSYNC	(1<<7)
+#define DRM_MODE_FLAG_NCSYNC	(1<<8)
+#define DRM_MODE_FLAG_HSKEW	(1<<9) /* hskew provided */
+#define DRM_MODE_FLAG_BCAST	(1<<10)
+#define DRM_MODE_FLAG_PIXMUX	(1<<11)
+#define DRM_MODE_FLAG_DBLCLK	(1<<12)
+#define DRM_MODE_FLAG_CLKDIV2	(1<<13)
+
+struct detailed_mode_closure {
+	struct hdmi_monitor *monitor;
+	struct edid *edid;
+	bool preferred;
+	u32 quirks;
+	int modes;
+};
+
+struct edid *get_edid(struct i2c_adapter *adapter);
+int probe_ddc_edid(struct i2c_adapter *adapter, unsigned char *buf,
+					int block, int len);
+bool detect_hdmi_monitor(struct edid *edid);
+void parse_edid(struct hdmi_monitor *monitor, struct edid *edid);
+bool edid_is_valid(struct edid *edid);
+int mode_vrefresh(const struct drm_mode_modeinfo *mode);
+int hdmi_avi_infoframe_from_mode(struct hdmi_monitor *monitor,
+					const struct drm_mode_modeinfo *mode);
+
+#endif /* HDMI_EDID_H_ */
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.c b/drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.c
new file mode 100644
index 0000000..d3d96c1
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.c
@@ -0,0 +1,1407 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+#include "psb_powermgmt.h"
+
+#include "hdmi_hdcp.h"
+#include "hdmi_edid.h"
+
+enum hdcp_event {
+	HDCP_ENABLE = 1,
+	HDCP_RESET,
+	HDCP_RI_CHECK,
+	HDCP_REPEATER_CHECK,
+	HDCP_REPEATER_WDT_EXPIRED,
+	HDCP_SET_POWER_SAVE_STATUS,
+	HDCP_SET_HPD_STATUS,
+	HDCP_SET_DPMS_STATUS
+};
+
+struct hdcp_rx_bcaps_t {
+	union {
+		uint8_t value;
+		struct {
+			uint8_t fast_reauthentication:1;
+			uint8_t b1_1_features:1;
+			uint8_t reserved:2;
+			uint8_t fast_transfer:1;
+			uint8_t ksv_fifo_ready:1;
+			uint8_t is_repeater:1;
+			uint8_t hdmi_reserved:1;
+		};
+	};
+};
+
+struct hdcp_rx_bstatus_t {
+	union {
+		uint16_t value;
+		struct {
+			uint16_t device_count:7;
+			uint16_t max_devs_exceeded:1;
+			uint16_t depth:3;
+			uint16_t max_cascade_exceeded:1;
+			uint16_t hdmi_mode:1;
+			uint16_t reserved2:1;
+			uint16_t rsvd:2;
+		};
+	};
+};
+/* = = = = = = = = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = */
+/*!  \brief Our local context.
+ */
+
+typedef struct hdcp_context_s {
+	unsigned int auth_id;
+	bool	is_enabled;/*if the hdcp context is enabled.*/
+	bool is_hdmi; /* HDMI or DVI*/
+
+	/*authentication stages enabled flag*/
+	bool	is_phase1_enabled;
+	bool	is_phase2_enabled;
+	bool	is_phase3_valid;
+	bool	previous_phase1_status;
+
+	/*stage 3 related members*/
+	bool	wdt_expired;
+	bool    force_reset;
+
+	/* time delay (msec) to re-try Ri check */
+	unsigned int ri_retry;
+	/* phase 3 ri-check interval based on mode*/
+	unsigned int	ri_check_interval;
+	/* upper bound of ri-check interval */
+	unsigned int	ri_check_interval_upper;
+	/* lower bound of ri-check interval */
+	unsigned int	ri_check_interval_lower;
+	/*Ri frame count in HDCP status register when doing previous Ri check*/
+	unsigned int	prev_ri_frm_cnt_status;
+	/* time interval (msec) of video refresh. */
+	unsigned int	video_refresh_interval;
+	/* the bksv from the down stream machine */
+	uint8_t bksv[HDCP_KSV_SIZE];
+
+	/* single-thread workqueue handling HDCP events */
+	struct workqueue_struct *hdcp_event_handler;
+
+	struct hdmi_pipe *pipe;/*the hdmi pipe.*/
+} hdcp_context;
+
+/*the event message for HDCP*/
+typedef struct hdcp_event_msg_s {
+	struct delayed_work dwork;
+	int msg;/*the event ID of HDCP*/
+	void *data;/*the data of HDCP event*/
+} hdcp_event_msg;
+
+static hdcp_context *g_pstHdcpContext; /* global context. */
+
+static int hdcp_ddc_read(uint8_t offset, uint8_t *buffer, int size);
+static int hdcp_ddc_write(uint8_t offset, uint8_t *buffer, int size);
+static int hdmi_ddc_read_write(bool read,
+							uint8_t i2c_addr,
+							uint8_t offset,
+							uint8_t *buffer,
+							int size);
+
+static bool hdcp_validate_ksv(uint8_t *ksv, uint32_t size);
+static bool hdcp_get_aksv(uint8_t *aksv, uint32_t size);
+
+static bool hdcp_enable_condition_ready(void);
+static void hdcp_task_event_handler(struct work_struct *work);
+
+static bool hdcp_wq_start(void);
+static bool hdcp_wq_ri_check(void);
+static bool hdcp_wq_repeater_authentication(void);
+static void hdcp_wq_reset(void);
+
+static bool hdcp_stage1_authentication(bool *is_repeater);
+static bool hdcp_stage2_start_repeater_authentication(void);
+static bool hdcp_stage3_schedule_ri_check(bool first_check);
+static bool hdcp_stage3_ri_check(void);
+
+static bool hdcp_rep_check(bool first);
+static bool hdcp_rep_watch_dog(void);
+
+static bool wq_send_message_delayed(int msg, void *msg_data,
+				   unsigned long delay);
+static bool wq_send_message(int msg, void *msg_data);
+
+/**
+ * Description: this function reads & write data to i2c hdcp device
+ * @read        is read or wirte.
+ * @i2c_addr  HDCP_PRIMARY_I2C_ADDR
+ * @offset	offset address on hdcp device
+ * @buffer	buffer to store data
+ * @size	size of buffer to be read
+ *
+ * Returns:	true on success else false
+ */
+static int hdmi_ddc_read_write(bool read,
+			uint8_t i2c_addr,
+			uint8_t offset,
+			uint8_t *buffer,
+			int size)
+{
+	struct i2c_adapter *adapter = i2c_get_adapter(HDMI_I2C_ADAPTER_NUM);
+	struct i2c_msg msgs[2];
+	int num_of_msgs = 0;
+	uint8_t wr_buffer[HDMI_MAX_DDC_WRITE_SIZE];
+
+	/* Use one i2c message to write and two to read as some
+	 * monitors don't handle two write messages properly
+	*/
+	if (read) {
+		msgs[0].addr   = i2c_addr,
+		msgs[0].flags  = 0,
+		msgs[0].len    = 1,
+		msgs[0].buf    = &offset,
+
+		msgs[1].addr   = i2c_addr,
+		msgs[1].flags  = ((read) ? I2C_M_RD : 0),
+		msgs[1].len    = size,
+		msgs[1].buf    = buffer,
+
+		num_of_msgs = 2;
+	} else {
+		BUG_ON(size + 1 > HDMI_MAX_DDC_WRITE_SIZE);
+
+		wr_buffer[0] = offset;
+		memcpy(&wr_buffer[1], buffer, size);
+
+		msgs[0].addr   = i2c_addr,
+		msgs[0].flags  = 0,
+		msgs[0].len    = size + 1,
+		msgs[0].buf    = wr_buffer,
+
+		num_of_msgs = 1;
+	}
+
+	if (adapter != NULL && i2c_transfer(adapter, msgs, num_of_msgs) ==
+								num_of_msgs)
+		return 1;
+
+	return 0;
+}
+
+/**
+ * Description: this function reads data from downstream i2c hdcp device
+ *
+ * @offset	offset address on hdcp device
+ * @buffer	buffer to store data
+ * @size	size of buffer to be read
+ *
+ * Returns:	true on success else false
+ */
+static int hdcp_ddc_read(uint8_t offset, uint8_t *buffer, int size)
+{
+	if (hdcp_enable_condition_ready() == true ||
+		(g_pstHdcpContext->is_enabled == true &&
+		 offset == HDCP_RX_BKSV_ADDR))
+		return hdmi_ddc_read_write(true, HDCP_PRIMARY_I2C_ADDR,
+			offset, buffer, size);
+	return false;
+}
+
+/**
+ * Description: this function writes data to downstream i2c hdcp device
+ *
+ * @offset	offset address on hdcp device
+ * @buffer	data to be written
+ * @size	size of data to be written
+ *
+ * Returns:	true on success else false
+ */
+static int hdcp_ddc_write(uint8_t offset, uint8_t *buffer, int size)
+{
+	if (hdcp_enable_condition_ready() == true)
+		return hdmi_ddc_read_write(false,	 HDCP_PRIMARY_I2C_ADDR,
+			offset, buffer, size);
+	return false;
+}
+
+/**
+ * Description: this function validates a ksv value
+ *		1. 20 1's & 20 o's
+ *		2. SRM check: check for revoked keys
+ *
+ * @ksv		ksv value
+ * @size	size of the ksv
+ *
+ * Returns:	true if valid else false
+ */
+static bool hdcp_validate_ksv(uint8_t *ksv, uint32_t size)
+{
+	int i = 0, count = 0;
+	uint8_t temp = 0;
+	bool ret = false;
+	if (ksv != NULL  && size == HDCP_KSV_SIZE) {
+		count = 0;
+		for (i = 0; i < 5; i++) {
+			temp = ksv[i];
+			while (temp) {
+				temp &= (temp-1);
+				count++;
+			}
+		}
+		if (count == HDCP_KSV_HAMMING_WT)
+			ret = true;
+	}
+	return ret;
+}
+
+/**
+ * Description: this function reads aksv from local hdcp tx device
+ *
+ * @aksv	buffer to store aksv
+ * @size	size of the aksv buffer
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_get_aksv(uint8_t *aksv, uint32_t size)
+{
+	bool ret = false;
+	if (mofd_hdcp_get_aksv(aksv, HDCP_KSV_SIZE) == true) {
+		if (hdcp_validate_ksv(aksv, size) == true)
+			ret = true;
+	}
+	return ret;
+}
+
+/**
+ * Description: this function reads bksv from downstream device
+ *
+ * @bksv	buffer to store bksv
+ * @size	size of the bksv buffer
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_read_bksv(uint8_t *bksv, uint32_t size)
+{
+	bool ret = false;
+	if (bksv != NULL  && size == HDCP_KSV_SIZE) {
+		if (hdcp_ddc_read(HDCP_RX_BKSV_ADDR,
+				bksv, HDCP_KSV_SIZE) == true) {
+			if (hdcp_validate_ksv(bksv, size) == true)
+				ret = true;
+		}
+	}
+	return ret;
+}
+
+/**
+ * Description: this function reads all ksv's from downstream repeater
+ *
+ * @ksv_list	buffer to store ksv list
+ * @size	size of the ksv_list to read into the buffer
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_read_rx_ksv_list(uint8_t *ksv_list, uint32_t size)
+{
+	bool ret = false;
+	if (ksv_list != NULL && size) {
+		if (hdcp_ddc_read(HDCP_RX_KSV_FIFO_ADDR, ksv_list, size) ==
+		    true)
+			ret = true;
+	}
+	return ret;
+}
+
+/**
+ * Description: this function reads bcaps from downstream device
+ *
+ * @bcaps	buffer to store bcaps
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_read_bcaps(uint8_t *bcaps)
+{
+	bool ret = false;
+	if (bcaps != NULL) {
+		if (hdcp_ddc_read(HDCP_RX_BCAPS_ADDR,
+				bcaps, HDCP_RX_BCAPS_SIZE) == true)
+			ret = true;
+	}
+	return ret;
+}
+
+/**
+ * Description: this function reads bstatus from downstream device
+ *
+ * @bstatus	buffer to store bstatus
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_read_bstatus(uint16_t *bstatus)
+{
+	bool ret = false;
+	if (bstatus != NULL) {
+		if (hdcp_ddc_read(HDCP_RX_BSTATUS_ADDR,
+			(uint8_t *)bstatus, HDCP_RX_BSTATUS_SIZE) == true)
+			ret = true;
+	}
+	return ret;
+}
+/**
+ * Description: this function reads ri from downstream device
+ *
+ * @rx_ri	buffer to store ri
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_read_rx_ri(uint16_t *rx_ri)
+{
+	bool ret = false;
+	if (rx_ri != NULL) {
+		if (hdcp_ddc_read(HDCP_RX_RI_ADDR,
+				(uint8_t *)rx_ri, HDCP_RI_SIZE) == true)
+			ret = true;
+	}
+	return ret;
+}
+
+/**
+ * Description: this function reads r0 from downstream device
+ *
+ * @rx_r0	buffer to store r0
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_read_rx_r0(uint16_t *rx_r0)
+{
+	return hdcp_read_rx_ri(rx_r0);
+}
+/**
+ * Description: this function reads sha1 value from downstream device
+ *
+ * @v		buffer to store the sha1 value
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_read_rx_v(uint8_t *v)
+{
+	bool ret = false;
+	uint8_t *buf = v;
+	uint8_t offset = HDCP_RX_V_H0_ADDR;
+
+	if (v != NULL) {
+		for (; offset <= HDCP_RX_V_H4_ADDR; offset += 4) {
+			if (hdcp_ddc_read(offset, buf, 4) == false) {
+				pr_debug("hdcp: read rx v failure\n");
+				break;
+			}
+			buf += 4;
+		}
+		if (offset > HDCP_RX_V_H4_ADDR)
+			ret = true;
+	}
+	return ret;
+}
+
+/**
+ * Description: this function sends an aksv to downstream device
+ *
+ * @an		AN value to send
+ * @an_size	size of an
+ * @aksv	AKSV value to send
+ * @aksv_size	size of aksv
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_send_an_aksv(uint8_t *an, uint8_t an_size,
+			uint8_t *aksv, uint8_t aksv_size)
+{
+	bool ret = false;
+	if (an != NULL && an_size == HDCP_AN_SIZE &&
+	   aksv != NULL  && aksv_size == HDCP_KSV_SIZE) {
+		if (hdcp_ddc_write(HDCP_RX_AN_ADDR, an, HDCP_AN_SIZE) ==
+			true) {
+			/* wait 20ms for i2c write for An to complete */
+			/* msleep(20); */
+			if (hdcp_ddc_write(HDCP_RX_AKSV_ADDR, aksv,
+					HDCP_KSV_SIZE) == true)
+				ret = true;
+		}
+	}
+	return ret;
+}
+
+/**
+ * Description: verify conditions necessary for re-authentication and
+ *		enable HDCP if favourable
+ *
+ * Returns:	none
+ */
+static void hdcp_retry_enable(void)
+{
+	int msg = HDCP_ENABLE;
+	if (hdcp_enable_condition_ready() == true &&
+		g_pstHdcpContext->is_phase1_enabled == false) {
+		wq_send_message_delayed(msg, NULL, 30);
+		pr_debug("hdcp: retry enable\n");
+	}
+}
+
+/**
+ * Description: this function verifies all conditions to enable hdcp
+ *
+ * Returns:	true if hdcp can be enabled else false
+ */
+static bool hdcp_enable_condition_ready(void)
+{
+	int is_connected =
+		atomic_read(&(g_pstHdcpContext->pipe->hpd_ctx.is_connected));
+	if (g_pstHdcpContext != NULL &&
+	    g_pstHdcpContext->is_enabled == true &&
+	    (bool)is_connected == true)
+		return true;
+
+	if (g_pstHdcpContext == NULL) {
+		pr_err("[%s,%d]hdcp: hdcp_context is NULL\n",
+		       __FILE__, __LINE__);
+	} else {
+		pr_err("[%s,%d]hdcp: condition not ready, enabled %d\n",
+			__FILE__, __LINE__,
+			g_pstHdcpContext->is_enabled);
+	}
+
+	return false;
+}
+
+/**
+ * Description: Main function that initiates all stages of HDCP authentication
+ *
+ * Returns:	true on succesful authentication else false
+ */
+static bool hdcp_wq_start(void)
+{
+	bool is_repeater = false;
+	hdcp_context *ctx = g_pstHdcpContext;
+
+	if (ctx == NULL) {
+		pr_debug("[%s,%d]hdcp: context was not initialized.\n",
+			 __FILE__, __LINE__);
+		return false;
+	}
+
+	/* Make sure TMDS is available
+	 * Remove this delay since HWC already has the delay
+	 */
+
+	/* Increment Auth Check Counter */
+	ctx->auth_id++;
+
+	/* Check HDCP Status */
+	if (mofd_hdcp_is_ready() == false) {
+		pr_err("hdcp: hdcp is not ready\n");
+		return false;
+	}
+
+
+	/* start 1st stage of hdcp authentication */
+	if (hdcp_stage1_authentication(&is_repeater) == false) {
+		pr_debug("hdcp: stage 1 authentication fails\n");
+		return false;
+	}
+
+	pr_debug("hdcp: initial authentication completed, repeater:%d\n",
+		is_repeater);
+
+	/* Branch Repeater Mode Authentication */
+	if (is_repeater == true)
+		if (hdcp_stage2_start_repeater_authentication() == false)
+			return false;
+
+	/* Initiate phase3_valid with true status */
+	g_pstHdcpContext->is_phase3_valid = true;
+	/* Branch Periodic Ri Check */
+	pr_debug("hdcp: starting periodic Ri check\n");
+
+	/* Schedule Ri check after 2 sec*/
+	if (hdcp_stage3_schedule_ri_check(false) == false) {
+		pr_err("hdcp: fail to schedule Ri check\n");
+		return false;
+	}
+
+	return true;
+}
+/* Based on hardware Ri frame count, adjust ri_check_interval.
+ * Also, make sure Ri check happens right after Ri frame count
+ * becomes multiples of 128.
+ *  */
+static bool hdcp_wq_ri_check(void)
+{
+	#define RI_FRAME_WAIT_LIMIT 150
+
+	hdcp_context *ctx = g_pstHdcpContext;
+	uint32_t prev_ri_frm_cnt_status = ctx->prev_ri_frm_cnt_status;
+	uint8_t  ri_frm_cnt_status;
+	int32_t  ri_frm_cnt;
+	int32_t  adj;  /* Adjustment of ri_check_interval in msec */
+	uint32_t cnt_ri_wait = 0;
+	bool     ret = false;
+
+
+	/* Query hardware Ri frame counter.
+	 * This value is used to adjust ri_check_interval
+	 * */
+	mofd_hdcp_get_ri_frame_count(&ri_frm_cnt_status);
+	/* (frm_cnt_ri - prev_frm_cnt_ri) is expected to be 128. If not,
+	 * we have to compensate the time difference, which is caused by async
+	 * behavior of CPU clock, scheduler and HDMI clock. If hardware can
+	 * provide interrupt signal for Ri check, then this compensation work
+	 * can be avoided.
+	 * Hardcode "256" is because hardware Ri frame counter is 8 bits.
+	 * Hardcode "128" is based on HDCP spec.
+	* */
+	ri_frm_cnt = ri_frm_cnt_status >= prev_ri_frm_cnt_status      ?
+		ri_frm_cnt_status - prev_ri_frm_cnt_status       :
+		256 - prev_ri_frm_cnt_status + ri_frm_cnt_status;
+	pr_debug("current ri_frm_cnt = %d, previous ri_frm_cnt = %d\n",
+			  ri_frm_cnt_status, prev_ri_frm_cnt_status);
+
+	/* Compute adjustment of ri_check_interval*/
+	adj = (128 - ri_frm_cnt) * ctx->video_refresh_interval;
+
+	/* Adjust ri_check_interval */
+	/* adj<0:  Ri check speed is slower than HDMI clock speed
+	 * adj>0:  Ri check speed is faster than HDMI clock speed
+	 * */
+	pr_debug("adjustment of ri_check_interval  = %d (ms)\n", adj);
+	ctx->ri_check_interval += adj;
+	if (ctx->ri_check_interval > ctx->ri_check_interval_upper)
+		ctx->ri_check_interval = ctx->ri_check_interval_upper;
+
+	if (ctx->ri_check_interval < ctx->ri_check_interval_lower)
+		ctx->ri_check_interval = ctx->ri_check_interval_lower;
+
+	pr_debug("ri_check_interval=%d(ms)\n", ctx->ri_check_interval);
+
+	/* Update prev_ri_frm_cnt_status*/
+	ctx->prev_ri_frm_cnt_status = ri_frm_cnt_status;
+
+	/* Queue next Ri check task with new ri_check_interval*/
+	ret = hdcp_stage3_schedule_ri_check(false);
+	if (!ret)
+		goto exit;
+
+	/* Now, check if ri_frm_cnt_status is multiples of 128.
+	 * If we are too fast, wait for frame 128 (or a few frames after
+	 * frame 128) to happen to make sure Ri' is ready.
+	 * Why using hardcode "64"? : if ri_frm_cnt_status is close to
+	 * multiples of 128 (ie, ri_frm_cnt_status % 128 > 64), we keep waiting.
+	 * Otherwise if ri_frm_cnt_status just passes 128
+	 * (ie, ri_frm_cnt_status % 128 < 64) we continue.
+	 * Note the assumption here is this thread is scheduled to run at least
+	 * once in one 64-frame period.
+	 *
+	 * RI_FRAME_WAIT_LIMIT is in case HW stops updating ri frame
+	 * count and causes infinite looping.
+	*/
+	while ((ri_frm_cnt_status % 128 >= 64) &&
+			(cnt_ri_wait < RI_FRAME_WAIT_LIMIT)) {
+		msleep(ctx->video_refresh_interval);
+		mofd_hdcp_get_ri_frame_count(&ri_frm_cnt_status);
+		cnt_ri_wait++;
+		pr_debug("current Ri frame count = %d\n", ri_frm_cnt_status);
+	}
+
+	if (RI_FRAME_WAIT_LIMIT == cnt_ri_wait) {
+		ret = false;
+		goto exit;
+	}
+
+	/* Match Ri with Ri'*/
+	ret = hdcp_stage3_ri_check();
+
+exit:
+	return ret;
+}
+
+/**
+ * Description: this function performs repeater authentication i.e. 2nd
+ *		stage HDCP authentication
+ *
+ * Returns:	true if repeater authentication is in progress or succesful
+ *		else false. If in progress repeater authentication would be
+ *		rescheduled
+ */
+static bool hdcp_wq_repeater_authentication(void)
+{
+	uint8_t *rep_ksv_list = NULL;
+	uint32_t rep_prime_v[HDCP_V_H_SIZE] = {0};
+	struct hdcp_rx_bstatus_t bstatus;
+	struct hdcp_rx_bcaps_t bcaps;
+	bool ret = false;
+
+	/* Repeater Authentication */
+	if (hdcp_enable_condition_ready() == false ||
+	    g_pstHdcpContext->is_phase1_enabled == false ||
+	    g_pstHdcpContext->wdt_expired == true) {
+		pr_debug("hdcp: stage2 auth condition not ready\n");
+		return false;
+	}
+
+	/* Read BCAPS */
+	if (hdcp_read_bcaps(&bcaps.value) == false)
+		return false;
+
+	if (!bcaps.is_repeater)
+		return false;
+
+	/* Check if fifo ready */
+	if (!bcaps.ksv_fifo_ready) {
+		/* not ready: reschedule but return true */
+		pr_debug("hdcp: rescheduling repeater auth\n");
+		hdcp_rep_check(false);
+		return true;
+	}
+
+	/* Read BSTATUS */
+	if (hdcp_read_bstatus(&bstatus.value) == false)
+		return false;
+
+	/* Check validity of repeater depth & device count */
+	if (bstatus.max_devs_exceeded)
+		return false;
+
+	if (bstatus.max_cascade_exceeded)
+		return false;
+
+	if (0 == bstatus.device_count)
+		return true;
+
+	if (bstatus.device_count > HDCP_MAX_DEVICES)
+		return false;
+
+	/* allocate memory for ksv_list */
+	rep_ksv_list = kzalloc(bstatus.device_count * HDCP_KSV_SIZE,
+				GFP_KERNEL);
+	if (!rep_ksv_list) {
+		pr_debug("hdcp: rep ksv list alloc failure\n");
+		return false;
+	}
+
+	/* Read ksv list from repeater */
+	if (hdcp_read_rx_ksv_list(rep_ksv_list,
+				  bstatus.device_count * HDCP_KSV_SIZE)
+				  == false) {
+		pr_debug("hdcp: rep ksv list read failure\n");
+		goto exit;
+	}
+
+	/* TODO: SRM check */
+
+	/* Compute tx sha1 (V) */
+	if (mofd_hdcp_compute_tx_v(rep_ksv_list,
+				   bstatus.device_count, bstatus.value) ==
+				   false) {
+		pr_debug("hdcp: rep compute tx v failure\n");
+		goto exit;
+	}
+
+	/* Read rx sha1 (V') */
+	if (hdcp_read_rx_v((uint8_t *)rep_prime_v) == false) {
+		pr_debug("hdcp: rep read rx v failure\n");
+		goto exit;
+	}
+
+	/* Verify SHA1 tx(V) = rx(V') */
+	if (mofd_hdcp_compare_v(rep_prime_v) == false) {
+		pr_debug("hdcp: rep compare v failure\n");
+		goto exit;
+	}
+
+	pr_debug("hdcp: repeater auth success\n");
+	g_pstHdcpContext->is_phase2_enabled = true;
+	ret = true;
+
+exit:
+	kfree(rep_ksv_list);
+	return ret;
+}
+
+/**
+ * Description: this function resets hdcp state machine to initial state
+ *
+ * Returns:	none
+ */
+static void hdcp_wq_reset(void)
+{
+	pr_debug("hdcp: reset\n");
+
+	/* blank TV screen */
+
+	/* Stop HDCP */
+	if (g_pstHdcpContext->is_phase1_enabled == true ||
+	    g_pstHdcpContext->force_reset == true) {
+		pr_debug("hdcp: off state\n");
+		mofd_hdcp_disable();
+		g_pstHdcpContext->force_reset = false;
+	}
+
+	g_pstHdcpContext->is_phase1_enabled = false;
+	g_pstHdcpContext->is_phase2_enabled = false;
+	g_pstHdcpContext->is_phase3_valid   = false;
+	g_pstHdcpContext->prev_ri_frm_cnt_status = 0;
+	memset(g_pstHdcpContext->bksv, 0, HDCP_KSV_SIZE);
+}
+
+/**
+ * Description: this function performs 1st stage HDCP authentication i.e.
+ *		exchanging keys and r0 match
+ *
+ * @is_repeater	variable to return type of downstream device, i.e. repeater
+ *		or not
+ *
+ * Returns:	true on successful authentication else false
+ */
+static bool hdcp_stage1_authentication(bool *is_repeater)
+{
+	uint8_t bksv[HDCP_KSV_SIZE], aksv[HDCP_KSV_SIZE], an[HDCP_AN_SIZE];
+	struct hdcp_rx_bstatus_t bstatus;
+	struct hdcp_rx_bcaps_t bcaps;
+	uint8_t retry = 0;
+	uint16_t rx_r0 = 0;
+	hdcp_context *ctx = g_pstHdcpContext;
+
+	/* Wait (up to 2s) for HDMI sink to be in HDMI mode */
+	retry = 40;
+	if (ctx->is_hdmi) {
+		while (retry--) {
+			if (hdcp_read_bstatus(&bstatus.value) == false) {
+				pr_err("hdcp: failed to read bstatus\n");
+				return false;
+			}
+			if (bstatus.hdmi_mode)
+				break;
+			msleep(50);
+			pr_debug("hdcp: waiting for sink to be in HDMI mode\n");
+		}
+	}
+
+	if (retry == 0)
+		pr_err("hdcp: sink is not in HDMI mode\n");
+
+	pr_debug("hdcp: bstatus: %04x\n", bstatus.value);
+
+	/* Read BKSV */
+	if (hdcp_read_bksv(bksv, HDCP_KSV_SIZE) == false) {
+		pr_err("hdcp: failed to read bksv\n");
+		return false;
+	}
+	pr_debug("hdcp: bksv: %02x%02x%02x%02x%02x\n",
+		bksv[0], bksv[1], bksv[2], bksv[3], bksv[4]);
+
+	memcpy(ctx->bksv, bksv, HDCP_KSV_SIZE);
+
+	/* Read An */
+	if (mofd_hdcp_get_an(an, HDCP_AN_SIZE) == false) {
+		pr_err("hdcp: failed to get an\n");
+		return false;
+	}
+	pr_debug("hdcp: an: %02x%02x%02x%02x%02x%02x%02x%02x\n",
+		an[0], an[1], an[2], an[3], an[4], an[5], an[6], an[7]);
+
+	/* Read AKSV */
+	if (hdcp_get_aksv(aksv, HDCP_KSV_SIZE) == false) {
+		pr_err("hdcp: failed to get aksv\n");
+		return false;
+	}
+	pr_debug("hdcp: aksv: %02x%02x%02x%02x%02x\n",
+			aksv[0], aksv[1], aksv[2], aksv[3], aksv[4]);
+
+	/* Write An AKSV to Downstream Rx */
+	if (hdcp_send_an_aksv(an, HDCP_AN_SIZE, aksv, HDCP_KSV_SIZE)
+						== false) {
+		pr_err("hdcp: failed to send an and aksv\n");
+		return false;
+	}
+	pr_debug("hdcp: sent an aksv\n");
+
+	/* Read BKSV */
+	if (hdcp_read_bksv(bksv, HDCP_KSV_SIZE) == false) {
+		pr_err("hdcp: failed to read bksv\n");
+		return false;
+	}
+	pr_debug("hdcp: bksv: %02x%02x%02x%02x%02x\n",
+			bksv[0], bksv[1], bksv[2], bksv[3], bksv[4]);
+
+	/* Read BCAPS */
+	if (hdcp_read_bcaps(&bcaps.value) == false) {
+		pr_err("hdcp: failed to read bcaps\n");
+		return false;
+	}
+	pr_debug("hdcp: bcaps: %x\n", bcaps.value);
+
+
+	/* Update repeater present status */
+	*is_repeater = bcaps.is_repeater;
+
+	/* Set Repeater Bit */
+	if (mofd_hdcp_set_repeater(bcaps.is_repeater) == false) {
+		pr_err("hdcp: failed to set repeater bit\n");
+		return false;
+	}
+
+	/* Write BKSV to Self (hdcp tx) */
+	if (mofd_hdcp_set_bksv(bksv) == false) {
+		pr_err("hdcp: failed to write bksv to self\n");
+		return false;
+	}
+
+	pr_debug("hdcp: set repeater & bksv\n");
+
+	/* Start Authentication i.e. computations using hdcp keys */
+	if (mofd_hdcp_start_authentication() == false) {
+		pr_err("hdcp: failed to start authentication\n");
+		return false;
+	}
+
+	pr_debug("hdcp: auth started\n");
+
+	/* Wait for 120ms before reading R0' */
+	msleep(120);
+
+	/* Check if R0 Ready in hdcp tx */
+	retry = 20;
+	do {
+		if (mofd_hdcp_is_r0_ready() == true)
+			break;
+		usleep_range(5000, 5500);
+		retry--;
+	} while (retry);
+
+	if (retry == 0 && mofd_hdcp_is_r0_ready() == false) {
+		pr_err("hdcp: R0 is not ready\n");
+		return false;
+	}
+
+	pr_debug("hdcp: tx_r0 ready\n");
+
+	/* Read Ro' from Receiver hdcp rx */
+	if (hdcp_read_rx_r0(&rx_r0) == false) {
+		pr_err("hdcp: failed to read R0 from receiver\n");
+		return false;
+	}
+
+	pr_debug("hdcp: rx_r0 = %04x\n", rx_r0);
+
+	/* Check if R0 Matches */
+	if (mofd_hdcp_does_ri_match(rx_r0) == false) {
+		pr_err("hdcp: R0 does not match\n");
+		return false;
+	}
+	pr_debug("hdcp: R0 matched\n");
+
+	/* Enable Encryption & Check status */
+	if (mofd_hdcp_enable_encryption() == false) {
+		pr_err("hdcp: failed to enable encryption\n");
+		return false;
+	}
+	pr_debug("hdcp: encryption enabled\n");
+
+	ctx->is_phase1_enabled = true;
+
+	return true;
+}
+
+/**
+ * Description: this function initiates repeater authentication
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_stage2_start_repeater_authentication(void)
+{
+	pr_debug("hdcp: initiating repeater check\n");
+	g_pstHdcpContext->wdt_expired = false;
+	if (hdcp_rep_check(true) == true) {
+		if (hdcp_rep_watch_dog() == true)
+			return true;
+		else
+			pr_debug("hdcp: failed to start repeater wdt\n");
+	} else
+		pr_debug("hdcp: failed to start repeater check\n");
+	return false;
+}
+
+/**
+ * Description:	this function schedules ri check
+ *
+ * @first_check	whether its the first time, interval is varied if first time
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_stage3_schedule_ri_check(bool first_check)
+{
+	enum hdcp_event msg = HDCP_RI_CHECK;
+	unsigned int *msg_data = kmalloc(sizeof(unsigned int), GFP_KERNEL);
+	/* Do the first check immediately while adding some randomness  */
+	int ri_check_interval = (first_check) ? (20 + (jiffies % 10)) :
+		g_pstHdcpContext->ri_check_interval;
+	if (msg_data != NULL) {
+		*msg_data = g_pstHdcpContext->auth_id;
+		return wq_send_message_delayed(msg,
+					(void *)msg_data, ri_check_interval);
+	}
+	return false;
+}
+
+/**
+ * Description: this function performs ri match
+ *
+ * Returns:	true on match else false
+ */
+static bool hdcp_stage3_ri_check(void)
+{
+	uint16_t rx_ri = 0;
+
+	if (hdcp_enable_condition_ready() == false ||
+	    g_pstHdcpContext->is_phase1_enabled == false)
+		return false;
+
+	if (hdcp_read_rx_ri(&rx_ri) == true) {
+		if (mofd_hdcp_does_ri_match(rx_ri) == true)
+			/* pr_debug("hdcp: Ri Matches %04x\n", rx_ri);*/
+			return true;
+
+		/* If first Ri check fails,we re-check it after ri_retry (msec).
+		 * This is because some receivers do not immediately have valid
+		 * Ri' at frame 128.
+		 * */
+		pr_debug("re-check Ri after %d (msec)\n",
+				g_pstHdcpContext->ri_retry);
+
+		msleep(g_pstHdcpContext->ri_retry);
+		if (hdcp_read_rx_ri(&rx_ri) == true)
+			if (mofd_hdcp_does_ri_match(rx_ri) == true)
+				return true;
+	}
+
+	/* ri check failed update phase3 status */
+	g_pstHdcpContext->is_phase3_valid = false;
+
+	pr_debug("hdcp: error!!!  Ri check failed %x\n", rx_ri);
+	return false;
+}
+
+/**
+ * Description: this function schedules repeater authentication
+ *
+ * @first	whether its first time schedule or not, delay for check is
+ *		varied between first and subsequent times
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_rep_check(bool first)
+{
+	int msg = HDCP_REPEATER_CHECK;
+	int delay = (first) ? 50 : 100;
+	unsigned int *auth_id = kmalloc(sizeof(unsigned int), GFP_KERNEL);
+	if (auth_id != NULL) {
+		*auth_id = g_pstHdcpContext->auth_id;
+		return wq_send_message_delayed(msg, (void *)auth_id, delay);
+	} else
+		pr_debug("hdcp: %s failed to alloc mem\n", __func__);
+	return false;
+}
+
+/**
+ * Description: this function creates a watch dog timer for repeater auth
+ *
+ * Returns:	true on success else false
+ */
+static bool hdcp_rep_watch_dog(void)
+{
+	int msg = HDCP_REPEATER_WDT_EXPIRED;
+	unsigned int *auth_id = kmalloc(sizeof(unsigned int), GFP_KERNEL);
+	if (auth_id != NULL) {
+		*auth_id = g_pstHdcpContext->auth_id;
+		/* set a watch dog timer for 5.2 secs, added additional
+		   0.2 seconds to be safe */
+		return wq_send_message_delayed(msg, (void *)auth_id, 5200);
+	} else
+		pr_debug("hdcp: %s failed to alloc mem\n", __func__);
+	return false;
+}
+
+/**
+ * Description: workqueue event handler to execute all hdcp tasks
+ *
+ * @work	work assigned from workqueue contains the task to be handled
+ *
+ * Returns:	none
+ */
+static void hdcp_task_event_handler(struct work_struct *work)
+{
+	struct delayed_work *delayed_work = to_delayed_work(work);
+	hdcp_event_msg *event = container_of(delayed_work,
+					     hdcp_event_msg, dwork);
+	int msg = 0;
+	void *data = NULL;
+	bool reset_hdcp = false;
+	hdcp_context *ctx = g_pstHdcpContext;
+	int is_connected =
+		atomic_read(&(g_pstHdcpContext->pipe->hpd_ctx.is_connected));
+
+	if (ctx == NULL || event == NULL)
+		goto EXIT_HDCP_HANDLER;
+
+	msg = event->msg;
+	data = event->data;
+
+	if (!is_connected) {
+		pr_err("[%s,%d]hdcp error: hdmi pipe is not enabled.\n",
+			__FILE__, __LINE__);
+		goto EXIT_HDCP_HANDLER;
+	}
+
+	switch (msg) {
+	case HDCP_ENABLE:
+		if (hdcp_enable_condition_ready() == true &&
+			ctx->is_phase1_enabled == false &&
+			hdcp_wq_start() == false) {
+			reset_hdcp = true;
+			pr_debug("[%s,%d]hdcp: failed to start hdcp\n",
+				__FILE__, __LINE__);
+		}
+		break;
+
+	case HDCP_REPEATER_CHECK:
+		pr_debug("hdcp: repeater check\n");
+		if (data == NULL ||
+			*(unsigned int *)data != ctx->auth_id)
+			/*pr_debug("hdcp: auth count %d mismatch %d\n",
+				*(unsigned int *)msg_data,
+				hdcp_context->auth_id);*/
+			break;
+
+		if (hdcp_wq_repeater_authentication() == false)
+			reset_hdcp = true;
+		break;
+
+	case HDCP_REPEATER_WDT_EXPIRED:
+		if (data != NULL && *(unsigned int *)data == ctx->auth_id) {
+			ctx->wdt_expired = true;
+			if (!ctx->is_phase2_enabled && ctx->is_phase1_enabled)
+				reset_hdcp = true;
+		}
+		break;
+	case HDCP_RI_CHECK:
+		if (data == NULL || *(unsigned int *)data != ctx->auth_id)
+			break;
+
+		/* Do phase 3 only if phase 1 was successful*/
+		if (ctx->is_phase1_enabled == false)
+			break;
+
+		if (hdcp_wq_ri_check() == false)
+			reset_hdcp = true;
+		break;
+
+	case HDCP_RESET:
+		hdcp_wq_reset();
+		break;
+	default:
+		break;
+	}
+
+	if (reset_hdcp == true) {
+		msg = HDCP_RESET;
+		wq_send_message(msg, NULL);
+	} else
+		/* if disabled retry HDCP authentication */
+		hdcp_retry_enable();
+
+EXIT_HDCP_HANDLER:
+	if (data != NULL)
+		kfree(data);
+	if (event != NULL)
+		kfree(event);
+
+	return;
+}
+
+/**
+ * Description: this function sends a message to the hdcp workqueue to be
+ *		processed with a delay
+ *
+ * @msg		message type
+ * @msg_data	any additional data accompanying the message
+ * @delay	amount of delay for before the message gets processed
+ *
+ * Returns:	true if message was successfully queued else false
+ */
+static bool wq_send_message_delayed(int msg, void *msg_data,
+				    unsigned long delay)
+{
+	hdcp_event_msg *pst_msg = NULL;
+	pst_msg = kmalloc(sizeof(hdcp_event_msg), GFP_KERNEL);
+	if (pst_msg == NULL) {
+		kfree(msg_data);
+		return false;
+	}
+
+	pst_msg->msg = msg;
+	pst_msg->data = msg_data;
+
+	INIT_DELAYED_WORK(&pst_msg->dwork, hdcp_task_event_handler);
+
+	if (queue_delayed_work(g_pstHdcpContext->hdcp_event_handler,
+		&(pst_msg->dwork),
+		(unsigned long)(msecs_to_jiffies(delay))) != 0)
+		return true;
+	else
+		pr_debug("hdcp: failed to add message to delayed wq\n");
+
+	kfree(msg_data);
+
+	return false;
+}
+
+/**
+ * Description: this function sends a message to the hdcp workqueue to be
+ *		processed without delay
+ *
+ * @msg		message type
+ * @msg_data	any additional data accompanying the message
+ *
+ * Returns:	true if message was successfully queued else false
+ */
+static bool wq_send_message(int msg, void *msg_data)
+{
+	return wq_send_message_delayed(msg, msg_data, 0);
+}
+/**
+ * Description: function to enable HDCP
+ *
+ * @hdmi_context handle hdmi_context
+ * @refresh_rate vertical refresh rate of the video mode
+ *
+ * Returns:	true on success
+ *		false on failure
+ */
+bool hdmi_hdcp_enable(struct hdmi_pipe *pipe)
+{
+	int  msg = HDCP_ENABLE;
+	hdcp_context *ctx = g_pstHdcpContext;
+
+	/* TODO: remove refresh cal here */
+
+	struct drm_mode_modeinfo *prefer_mode = pipe->monitor.preferred_mode;
+
+	u32 refresh_rate = mode_vrefresh(prefer_mode);
+	if (refresh_rate == 0)
+		return false;
+
+	if (pipe == NULL || ctx == NULL)
+		/* pipe and ctx is either not valid */
+		return false;
+
+	if (ctx->is_enabled == true) {
+		pr_err("[%s,%d]hdcp: already enabled\n", __FILE__, __LINE__);
+		return true;
+	}
+
+	do {/*set the hdcp context member value*/
+		ctx->is_enabled = true;/*enable the hdcp context*/
+
+		/* compute ri check interval based on refresh rate */
+		if (refresh_rate) {
+			/*compute msec time for 1 frame*/
+			ctx->video_refresh_interval = 1000 / refresh_rate;
+			/* compute msec time for 128 frames per HDCP spec */
+			ctx->ri_check_interval = ((128 * 1000) / refresh_rate);
+		} else {
+			/*
+			 * compute msec time for 1 frame,
+			 * assuming refresh rate of 60
+			 */
+			ctx->video_refresh_interval = 1000 / 60;
+			/* default to 128 frames @ 60 Hz */
+			ctx->ri_check_interval = ((128 * 1000) / 60);
+		}
+
+		/* Set upper and lower bounds for ri_check_interval to
+		 *  avoid dynamic adjustment to go wild.
+		 *  Set adjustment range to 100ms, which is safe if HZ <=100.
+		*/
+		ctx->ri_check_interval_lower =	ctx->ri_check_interval - 100;
+		ctx->ri_check_interval_upper =	ctx->ri_check_interval + 100;
+
+		/* Init prev_ri_frm_cnt_status*/
+		ctx->prev_ri_frm_cnt_status = 0;
+
+		/*
+		 * Set ri_retry
+		 * Default to interval of 3 frames if can not read
+		 * OTM_HDMI_ATTR_ID_HDCP_RI_RETRY
+		 *
+		 * 3 * hdcp_context->video_refresh_interval
+		 */
+		ctx->ri_retry = 40;
+
+		ctx->is_hdmi = pipe->monitor.is_hdmi; /*check if */
+	} while (0);
+
+	/* send message and wait for 1st stage authentication to complete */
+	if (wq_send_message(msg, NULL)) {
+		/* on any failure is_required flag will be reset */
+		while (ctx->is_enabled) {
+			/* wait for phase1 to be enabled before
+			 * returning from this function */
+			if (ctx->is_phase1_enabled)
+				return true;
+			ulseep_range(1000, 1500);
+		}
+	}
+
+	return false;
+}
+
+/**
+ * Description: function to disable HDCP
+ *
+ * @hdmi_context handle hdmi_context
+ *
+ * Returns:	true on success
+ *		false on failure
+ */
+bool hdmi_hdcp_disable(struct hdmi_pipe *pipe)
+{
+	int msg = HDCP_RESET;
+	hdcp_context *ctx = g_pstHdcpContext;
+
+	if (pipe == NULL ||  ctx == NULL)
+		return false;
+
+	if (ctx->is_enabled == false) {
+		pr_debug("hdcp: already disabled\n");
+		return true;
+	}
+
+	/* send reset message */
+	wq_send_message(msg, NULL);
+
+	/* Wait until hdcp is disabled.
+	 * No need to wait for workqueue flushed since it may block for 2sec
+	 * */
+	while (g_pstHdcpContext->is_phase1_enabled)
+		ulseep_range(1000, 1500);
+
+	ctx->is_enabled = false;
+
+	return true;
+}
+
+static void hdcp_reset_context(hdcp_context *ctx)
+{
+	if (ctx == NULL)
+		return;
+
+	/* this flag will be re-enabled by upper layers */
+	ctx->is_enabled = false;
+	ctx->is_phase1_enabled = false;
+	ctx->is_phase2_enabled = false;
+	ctx->is_phase3_valid = false;
+	ctx->prev_ri_frm_cnt_status = 0;
+	ctx->auth_id = 0; /* reset the auth id */
+
+	memset(ctx->bksv, 0, HDCP_KSV_SIZE);
+}
+
+/**
+ * Description: hdcp init function
+ *
+ * @hdmi_context handle hdmi_context
+ * @ddc_rd_wr:	pointer to ddc read write function
+ *
+ * Returns:	true on success
+ *		false on failure
+ */
+bool hdmi_hdcp_init(struct hdmi_pipe *pipe)
+{
+	hdcp_context *ctx = NULL;
+	bool ret = true;
+	if (pipe == NULL || g_pstHdcpContext != NULL) {
+		pr_err("[%s,%d]syp code left hdcp: init error!!!\n",
+			__FILE__, __LINE__);
+		return false;
+	}
+
+	do {
+		/* allocate hdcp context */
+		ctx = kmalloc(sizeof(hdcp_context), GFP_KERNEL);
+		if (ctx == NULL) {
+			pr_err("[%s,%d]init error: allocation.\n",
+				__FILE__, __LINE__);
+			ret = false;
+			break;
+		}
+		memset(ctx, 0, sizeof(hdcp_context));
+
+		/* Create hdcp workqueue to handle all hdcp tasks.
+		 * To avoid multiple threads created for multi-core CPU (eg CTP)
+		 * use create_singlethread_workqueue.
+		 */
+		ctx->hdcp_event_handler = create_singlethread_workqueue(
+							"HDCP_EVENT_WQ");
+		if (ctx->hdcp_event_handler == NULL) {
+			pr_err("[%s,%d]hdcp: init error: allocation.\n",
+				__FILE__, __LINE__);
+			ret = false;
+			break;
+		}
+		hdcp_reset_context(ctx);
+
+		/*save the hdmi pipe*/
+		ctx->pipe = pipe;
+	} while (0);
+
+	if (ret == false) {
+		pr_err("[%s,%d]syp code left:hdcp: init error: allocation.\n",
+			__FILE__, __LINE__);
+		goto EXIT_INIT;
+	}
+
+	g_pstHdcpContext = ctx;/*save the context to the global variable.*/
+
+
+	/* perform any hardware initializations */
+	if (mofd_hdcp_init() == true) {
+		pr_err("[%s,%d]syp code left:hdcp: initialized\n",
+			__FILE__, __LINE__);
+		return true;
+	}
+
+EXIT_INIT:
+	if (ctx != NULL) {/* Cleanup and exit */
+		if (ctx->hdcp_event_handler != NULL)
+			destroy_workqueue(ctx->hdcp_event_handler);
+
+		kfree(ctx);
+		ctx = NULL;
+	}
+	return false;
+}
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.h b/drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.h
new file mode 100644
index 0000000..423c06b
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_hdcp.h
@@ -0,0 +1,162 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2011 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  95054
+
+  BSD LICENSE
+
+  Copyright(c) 2011 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef HDMI_HDCP_H_
+#define HDMI_HDCP_H_
+
+#include <linux/types.h>
+#include "hdmi_pipe.h"
+
+#define HDCP_PRIMARY_I2C_ADDR	0x3A
+#define HDMI_MAX_DDC_WRITE_SIZE 20
+
+#define HDCP_MAX_RETRY_STATUS	(1500)
+#define HDCP_MAX_DEVICES        (127)
+
+#define HDCP_KSV_SIZE		5
+#define HDCP_KSV_HAMMING_WT	(20)
+#define HDCP_AN_SIZE		0x08
+#define HDCP_RI_SIZE		0x02
+#define HDCP_PJ_SIZE		0x01
+#define HDCP_V_H_SIZE		(20)
+
+#define HDCP_RX_BKSV_ADDR	0x00
+#define HDCP_RX_RI_ADDR		0x08
+#define HDCP_RX_PJ_ADDR		0x0A
+#define HDCP_RX_AKSV_ADDR	0x10
+
+#define HDCP_RX_AINFO_ADDR	0x15
+#define HDCP_RX_AINFO_SIZE	0x01
+
+#define HDCP_RX_AN_ADDR		0x18
+
+#define HDCP_RX_V_H_ADDR	0x20
+
+#define HDCP_RX_V_H0_ADDR	0x20
+#define HDCP_RX_V_H0_SIZE	0x04
+
+#define HDCP_RX_V_H1_ADDR	0x24
+#define HDCP_RX_V_H1_SIZE	0x04
+
+#define HDCP_RX_V_H2_ADDR	0x28
+#define HDCP_RX_V_H2_SIZE	0x04
+
+#define HDCP_RX_V_H3_ADDR	0x2C
+#define HDCP_RX_V_H3_SIZE	0x04
+
+#define HDCP_RX_V_H4_ADDR	0x30
+#define HDCP_RX_V_H4_SIZE	0x04
+
+#define HDCP_RX_BCAPS_ADDR	0x40
+#define HDCP_RX_BCAPS_SIZE	0x01
+
+#define HDCP_RX_BSTATUS_ADDR	0x41
+#define HDCP_RX_BSTATUS_SIZE	0x02
+
+#define HDCP_RX_KSV_FIFO_ADDR	0x43
+
+/**
+ * Description: function to enable HDCP
+ *
+ * @pipe  handle hdmi_pipe
+ * @refresh_rate vertical refresh rate of the video mode
+ *
+ * Returns:true on success  false on failure
+ */
+bool hdmi_hdcp_enable(struct hdmi_pipe *pipe);
+
+/**
+ * Description: function to disable HDCP
+ *
+ * @hdmi_context handle hdmi_context
+ *
+ * Returns: true on success, false on failure
+ */
+bool hdmi_hdcp_disable(struct hdmi_pipe *pipe);
+
+/**
+ * Description: hdcp init function
+ *
+ * @hdmi_context handle hdmi_context
+ * @ddc_rd_wr:  pointer to ddc read write function
+ *
+ * Returns:	true on success
+ *		false on failure
+ */
+bool hdmi_hdcp_init(struct hdmi_pipe *pipe);
+
+/************************************************
+**TODO: move mofd platform related code to interfaces.
+*************************************************/
+bool mofd_hdcp_compare_v(uint32_t *rep_prime_v);
+bool mofd_hdcp_compute_tx_v(uint8_t *rep_ksv_list,
+					   uint32_t rep_ksv_list_entries,
+					   uint16_t topology_data);
+bool mofd_hdcp_enable_encryption(void);
+bool mofd_hdcp_disable(void);
+bool mofd_hdcp_does_ri_match(uint16_t rx_ri);
+bool mofd_hdcp_is_r0_ready(void);
+bool mofd_hdcp_init(void);
+bool mofd_hdcp_is_ready(void);
+bool mofd_hdcp_get_ri_frame_count(uint8_t *count);
+bool mofd_hdcp_get_an(uint8_t *an, uint32_t size);
+bool mofd_hdcp_set_repeater(bool present);
+bool mofd_hdcp_set_bksv(uint8_t *bksv);
+bool mofd_hdcp_start_authentication(void);
+bool mofd_hdcp_get_aksv(uint8_t *aksv, int size);
+
+#endif /* HDMI_HDCP_H_ */
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.c b/drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.c
new file mode 100644
index 0000000..36a340f
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.c
@@ -0,0 +1,82 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#include "hdmi_hotplug.h"
+
+static irqreturn_t hdmi_hotplug_top(int irq, void *data)
+{
+	if (data == NULL)
+		return IRQ_HANDLED;
+	return IRQ_WAKE_THREAD;
+}
+
+void adf_hdmi_hpd_init_work(struct work_struct *work)
+{
+	struct hdmi_pipe *pipe;
+	int err = 0;
+	pipe = container_of(work, struct hdmi_pipe, hotplug_register_work);
+	err = pci_register_driver(&pipe->hdmi_hpd_driver);
+	if (err)
+		pr_err("%s: Error: Failed to register HDMI hotplug device\n",
+			__func__);
+}
+
+int hdmi_hpd_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	int err = 0;
+	struct hdmi_pipe *pipe;
+
+	pipe = (struct hdmi_pipe *)id->driver_data;
+	if (pdev == NULL || pipe == NULL) {
+		pr_err("%s: no device or context\n", __func__);
+		err =  -EINVAL;
+		return err;
+	}
+
+	err = pci_enable_device(pdev);
+	if (err) {
+		pr_err("%s: Failed to enable MSIC PCI device=0x%x\n",
+			__func__, pipe->config.pci_device_id);
+		err = -EIO;
+		goto out_err0;
+	}
+
+
+	err = irq_set_irq_type(pipe->config.irq_number, IRQ_TYPE_EDGE_BOTH);
+	if (err) {
+		pr_err("%s: Failed to set HDMI HPD IRQ type for IRQ %d\n",
+			 __func__, pipe->config.irq_number);
+		goto out_err1;
+	}
+
+	err = request_threaded_irq(pipe->config.irq_number, hdmi_hotplug_top,
+				   pipe->hotplug_irq_cb, IRQF_SHARED,
+				   HDMI_HPD_DRIVER_NAME,
+				   pipe->hotplug_data);
+	if (err) {
+		pr_err("%s: Register irq interrupt %d failed\n",
+		      __func__, pipe->config.irq_number);
+		goto out_err1;
+	}
+	return err;
+
+out_err1:
+	pci_disable_device(pdev);
+out_err0:
+	pci_dev_put(pdev);
+	return err;
+}
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.h b/drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.h
new file mode 100644
index 0000000..5d069ac
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_hotplug.h
@@ -0,0 +1,29 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#ifndef HDMI_HOTPLUG_H_
+#define HDMI_HOTPLUG_H_
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include "hdmi_pipe.h"
+
+#define HDMI_HPD_DRIVER_NAME "HDMI HPD DRIVER"
+
+void adf_hdmi_hpd_init_work(struct work_struct *work);
+int hdmi_hpd_probe(struct pci_dev *pdev, const struct pci_device_id *id);
+
+#endif /* HDMI_HOTPLUG_H_ */
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.c b/drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.c
new file mode 100644
index 0000000..e847bbb
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.c
@@ -0,0 +1,963 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include <linux/kernel.h>
+#include <video/adf_client.h>
+#include "hdmi_pipe.h"
+#include "hdmi_edid.h"
+#include "hdmi_hotplug.h"
+#include "hdmi_hdcp.h"
+
+static const struct drm_mode_modeinfo fake_mode = {
+	/* 4 - 1280x720@60Hz */
+	 DEFINE_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		   1430, 1650, 0, 720, 725, 730, 750, 0,
+		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC |
+		   DRM_MODE_FLAG_PAR4_3),
+	  .vrefresh = 60, };
+
+/*
+	return true if connection status changed
+	return false if else
+*/
+
+static u32 vsync_counter;
+#define VSYNC_COUNT_MAX_MASK 0xffffff
+
+
+static bool hdmi_check_connection_status(struct hdmi_pipe *pipe)
+{
+	bool is_current_connected;
+	bool last_status;
+
+	if (pipe == NULL)
+		return -EINVAL;
+
+	last_status = atomic_read(&pipe->hpd_ctx.is_connected);
+	is_current_connected = mofd_hdmi_get_cable_status(&pipe->config);
+
+	if (is_current_connected != last_status) {
+		if (is_current_connected)
+			atomic_set(&pipe->hpd_ctx.is_connected, 1);
+		else
+			atomic_set(&pipe->hpd_ctx.is_connected, 0);
+		return true;
+	}
+	return false;
+}
+
+static void populate_modes(struct hdmi_pipe *pipe)
+{
+	struct hdmi_monitor *monitor;
+	struct hdmi_mode_info *mode_info, *t, *saved_mode = NULL;
+	int active_region = 0;
+	int saved_region = 0;
+	int vrefresh = 0;
+	int saved_vrefresh = 0;
+	int modes_num = 0;
+	monitor = &pipe->monitor;
+
+	/*step 1: destroy all the modes that exceeds the limit*/
+	list_for_each_entry_safe(mode_info, t,
+					&monitor->probedModes,
+					head) {
+		modes_num++;
+		if (mode_info->drm_mode.hdisplay > HDMI_MAX_DISPLAY_H  ||
+			mode_info->drm_mode.vdisplay > HDMI_MAX_DISPLAY_V ||
+			mode_info->drm_mode.clock > pipe->config.max_clock ||
+			mode_info->drm_mode.clock < pipe->config.min_clock ||
+			mode_info->drm_mode.flags & DRM_MODE_FLAG_DBLSCAN ||
+			mode_info->drm_mode.flags & DRM_MODE_FLAG_INTERLACE) {
+
+			list_del(&mode_info->head);
+			kfree(mode_info);
+			modes_num--;
+		}
+	}
+
+	/*step 2: find the preferred mode with max display size */
+	list_for_each_entry_safe(mode_info, t,
+				&monitor->probedModes, head) {
+
+		active_region =
+			mode_info->drm_mode.hdisplay *
+						mode_info->drm_mode.vdisplay;
+
+			if (active_region > saved_region) {
+				saved_region = active_region;
+				vrefresh = mode_vrefresh(&mode_info->drm_mode);
+
+				pr_debug("%s:vrefresh=%d,saved_vrefresh = %d\n",
+					__func__, vrefresh, saved_vrefresh);
+
+				saved_vrefresh = vrefresh;
+				saved_mode = mode_info;
+			} else if (active_region == saved_region) {
+					vrefresh = mode_vrefresh(
+							&mode_info->drm_mode);
+					if (vrefresh > saved_vrefresh) {
+						saved_vrefresh = vrefresh;
+						saved_mode = mode_info;
+					}
+			}
+	}
+
+	if (saved_mode)
+		saved_mode->drm_mode.type |= DRM_MODE_TYPE_PREFERRED;
+
+
+	pr_debug("Left %d modes after validate\n", modes_num);
+	list_for_each_entry(mode_info,
+					&monitor->probedModes,
+					head) {
+		pr_debug("vdisplay=%d, hdisplay=%d, vtotal=%d, htotal=%d, vfresh=%d,"
+			"flags=%x, type=%x, name=%s, clock=%d\n",
+		mode_info->drm_mode.vdisplay,
+		mode_info->drm_mode.hdisplay, mode_info->drm_mode.vtotal,
+		mode_info->drm_mode.htotal, mode_info->drm_mode.vrefresh,
+		mode_info->drm_mode.flags, mode_info->drm_mode.type,
+		mode_info->drm_mode.name, mode_info->drm_mode.clock);
+
+		pipe->monitor.preferred_mode = &saved_mode->drm_mode;
+	}
+
+}
+
+static irqreturn_t hotplug_thread_fn(int irq, void *data)
+{
+	struct hdmi_pipe *pipe = (struct hdmi_pipe *)data;
+	struct hdmi_hotplug_context *hpd_ctx;
+	pid_t current_pid;
+
+	current_pid = task_pid_nr(current);
+
+	pr_debug("In %s and pipe=%p\n", __func__, pipe);
+
+	if (pipe == NULL) {
+		pr_err("%s: Hdmi hotplug context is empty\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	hpd_ctx = &pipe->hpd_ctx;
+
+	if (hdmi_check_connection_status(pipe)) {
+		atomic_set(&hpd_ctx->is_asserted, 1);
+		return intel_adf_context_on_event();
+	}
+	return IRQ_HANDLED;
+}
+
+static int hdmi_get_screen_size(struct intel_pipe *pipe,
+		u16 *width_mm, u16 *height_mm)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	*width_mm = hdmi_pipe->monitor.screen_width_mm;
+	*height_mm = hdmi_pipe->monitor.screen_height_mm;
+
+	pr_debug("%s: width=%d height=%d\n", __func__, *width_mm, *height_mm);
+	return 0;
+}
+
+static void gunit_iosf_write32(u32 ep_id, u32 reg, u32 val)
+{
+	u32 ret;
+	int retry = 0;
+	u32 sb_pkt = (1 << 16) | (ep_id << 8) | 0xf0;
+
+	/* Write value to side band register */
+	REG_WRITE(0x2108, reg);
+	REG_WRITE(0x2104, val);
+	REG_WRITE(0x2100, sb_pkt);
+
+	/* Check if transaction is complete */
+	ret = REG_READ(0x210C);
+	while ((retry++ < 0x1000) && (ret != 0x2)) {
+		usleep_range(500, 1000);
+		ret = REG_READ(0x210C);
+	}
+
+	if (ret != 2)
+		pr_err("%s: failed to program DPLL\n", __func__);
+}
+
+static u32 gunit_iosf_read32(u32 ep_id, u32 reg)
+{
+	u32 ret;
+	int retry = 0;
+	u32 sb_pkt = (0 << 16) | (ep_id << 8) | 0xf0;
+
+	/* Read side band register */
+	REG_WRITE(0x2108, reg);
+	REG_WRITE(0x2100, sb_pkt);
+
+	/* Check if transaction is complete */
+	ret = REG_READ(0x210C);
+	while ((retry++ < 0x1000) && (ret != 2)) {
+		usleep_range(500, 1000);
+		ret = REG_READ(0x210C);
+	}
+
+	if (ret != 2)
+		pr_err("%s: Failed to read\n", __func__);
+	else
+		ret = REG_READ(0x2104);
+
+	return ret;
+}
+
+static int  hdmi_setup_clock(u32 div)
+{
+	u32 tmp = 0;
+	u32 ret;
+	int retry = 0;
+
+	pr_debug("In %s div=%x\n", __func__, div);
+
+	/* Common reset */
+	REG_WRITE(DISP_PLL_CTRL, 0x70006800);  /* DPLLB */
+
+	/* Program DPLL registers via IOSF (TNG display HAS) */
+
+	/* Process monitor to 19.2MHz */
+	gunit_iosf_write32(DPLL_IOSF_EP, REF_DWORD22, 0x19080000);
+
+	/* LRC clock to 19.2MHz */
+	gunit_iosf_write32(DPLL_IOSF_EP, DPLL_LRC_CLK, 0x00000F10);
+
+	/* Disable periodic GRC IREF update for DPLL */
+	tmp = gunit_iosf_read32(DPLL_IOSF_EP, PLLB_DWORD8);
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLB_DWORD8, tmp & 0x00FFFFFF);
+
+	/* Enable Tx for periodic GRC update*/
+	gunit_iosf_write32(DPLL_IOSF_EP, DPLL_Tx_GRC, 0x00004000);
+
+	/* GRC cal clock set to 19.2MHZ */
+	gunit_iosf_write32(DPLL_IOSF_EP, REF_DWORD18, 0x30002400);
+
+	/* Set lock time to 53us.
+	 * Disable fast lock.
+	 */
+	gunit_iosf_write32(DPLL_IOSF_EP, CMN_DWORD8, 0x0);
+
+	/* Stagger Programming */
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_GROUP_1, 0x00001500);
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_GROUP_2, 0x40400000);
+	gunit_iosf_write32(DPLL_IOSF_EP, PCS_DWORD12_1, 0x00220F00);
+	gunit_iosf_write32(DPLL_IOSF_EP, PCS_DWORD12_2, 0x00750F00);
+
+	/* Set divisors*/
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLA_DWORD3_1, div);
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLA_DWORD3_2, div);
+
+	/* Set up LCPLL in digital mode */
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLA_DWORD5_1, 0x0DF44300);
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLA_DWORD5_2, 0x0DF44300);
+
+	/* LPF co-efficients for LCPLL in digital mode */
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLB_DWORD10_1, 0x005F0021);
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLB_DWORD10_2, 0x005F0021);
+
+	/* Disable unused TLine clocks on right side */
+	gunit_iosf_write32(DPLL_IOSF_EP, CMN_DWORD3, 0x14540000);
+
+	/* Enable DPLL */
+	tmp = REG_READ(DISP_PLL_CTRL);
+	REG_WRITE(DISP_PLL_CTRL, tmp | DPLL_EN);
+
+	/* Enable DCLP to core */
+	tmp = gunit_iosf_read32(DPLL_IOSF_EP, PLLA_DWORD7_1);
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLA_DWORD7_1, tmp | (1 << 24));
+	tmp = gunit_iosf_read32(DPLL_IOSF_EP, PLLA_DWORD7_2);
+	gunit_iosf_write32(DPLL_IOSF_EP, PLLA_DWORD7_2, tmp | (1 << 24));
+
+	/* Set HDMI lane CML clock */
+	gunit_iosf_write32(DPLL_IOSF_EP, DPLL_CML_CLK1, 0x07760018);
+	gunit_iosf_write32(DPLL_IOSF_EP, DPLL_CML_CLK2, 0x00400888);
+
+	/* Swing settings */
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_1, 0x00000000);
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_2, 0x2B245555);
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_3, 0x5578B83A);
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_4, 0x0C782040);
+	/*gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_5, 0x2B247878);*/
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_6, 0x00030000);
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_7, 0x00004000);
+	gunit_iosf_write32(DPLL_IOSF_EP, TX_SWINGS_1, 0x80000000);
+
+	/* Wait until DPLL is locked */
+	ret = REG_READ(DISP_PLL_CTRL);
+	ret &= 0x8000;
+	while ((retry++ < 1000) && (ret != 0x8000)) {
+		usleep_range(500, 1000);
+		ret = REG_READ(DISP_PLL_CTRL);
+		ret &= 0x8000;
+	}
+
+	if (ret != 0x8000)
+		return -EIO;
+	return 0;
+}
+
+static int __compute_check_sum(struct avi_info_packet *packet)
+{
+	uint8_t i = 0;
+	uint8_t sum = 0;
+
+	for (i = 0; i < 3; i++)
+		sum += packet->header[i];
+	for (i = 1; i < 28; i++)
+		sum += packet->data[i];
+
+	packet->data[0] = (uint8_t)(0xFF - sum + 1);
+
+	return (int)packet->data[0];
+}
+
+static int hdmi_build_avi_packet(struct hdmi_monitor *monitor,
+					struct drm_mode_modeinfo *mode)
+{
+	struct avi_info_packet *avi_pkt;
+	u8 par = 0;
+	unsigned int pf;
+	bool p;
+	int i = 0;
+
+	if (!mode)
+		return -EINVAL;
+
+	avi_pkt = &monitor->avi_packet;
+
+	/* Set header to AVI */
+	avi_pkt->header[0] = 0x82;
+	avi_pkt->header[1] = 0x02;
+	avi_pkt->header[2] = 0x0D;
+	/* Clear payload section */
+	memset(avi_pkt->data, 0, sizeof(avi_pkt->data));
+
+	/* RGB, Active Format Info valid, no bars */
+	/* use underscan as HDMI video is composed with all
+	 * active pixels and lines with or without border
+	 */
+	avi_pkt->data[1] = 0x12;
+	/* Set color component sample format */
+	pf = 0; /* 0: RGB444 1:YUV422 2:YUV444 */
+	avi_pkt->data[1] |= pf << 5;
+	/* Colorimetry */
+	avi_pkt->data[2] = 0;
+
+	/* Fill PAR for all supported modes
+	 * This is required for passing compliance tests
+	 */
+
+	if (mode->flags & DRM_MODE_FLAG_PAR16_9)
+		par = 2;
+	else if (mode->flags & DRM_MODE_FLAG_PAR4_3)
+		par = 1;
+
+	avi_pkt->data[2] |= par << 4;
+	/* Fill FAR */
+	avi_pkt->data[2] |= 8; /* same as par */
+
+	/* Fill extended colorimetry */
+	avi_pkt->data[3] = 0;
+
+	/* Fill quantization range */
+	if (monitor->quant_range_selectable)
+		avi_pkt->data[3] |= 0x01<<2;
+
+	/* Only support RGB output, 640x480: full range Q0=1, Q1=0
+	* other timing: limited range Q0=0, Q1=1 */
+	avi_pkt->data[3] &= ~0x0c;
+	if (mode->hdisplay == 640 && mode->vdisplay == 480)
+		avi_pkt->data[3] |= 0x02 << 2;
+	else
+		avi_pkt->data[3] |= 0x01 << 2;
+
+	/* Fill Video Identification Code [adjust VIC according to PAR] */
+	hdmi_avi_infoframe_from_mode(monitor, mode);
+	avi_pkt->data[4] = monitor->video_code;
+
+	/* Fill pixel repetition value: 2x for 480i and 546i */
+	p = ((mode->flags & DRM_MODE_FLAG_INTERLACE) == 0);
+	avi_pkt->data[5] = ((mode->hdisplay == 720) && !p) ? 0x01 : 0x00;
+
+	/* Compute and fill checksum */
+	avi_pkt->data[0] = __compute_check_sum(avi_pkt);
+	pr_debug("Dump avi_pkt");
+	pr_debug("%x,%x,%x\n", avi_pkt->header[0], avi_pkt->header[1],
+		avi_pkt->header[2]);
+	for (i = 0; i < 28; i++)
+		pr_debug("%x ", avi_pkt->data[i]);
+	pr_debug("\n");
+
+	return 0;
+}
+
+void hdmi_disable_avi_infoframe(void)
+{
+	uint32_t vid_dip_ctl = 0;
+	uint32_t dip_type = 0;
+	uint32_t index = 0;
+
+	dip_type = DIP_TYPE_AVI;
+	index = DIP_BUFFER_INDEX_AVI;
+
+	/* Disable DIP type & set the buffer index & reset access address */
+	vid_dip_ctl = REG_READ(VIDEO_DIP_CTRL);
+	vid_dip_ctl &= ~(dip_type |
+			DIP_BUFFER_INDEX_MASK |
+			DIP_ADDR_MASK |
+			DIP_TX_FREQ_MASK);
+	vid_dip_ctl |= (index |
+			PORT_B_SELECT |
+			EN_DIP);
+	REG_WRITE(VIDEO_DIP_CTRL, vid_dip_ctl);
+}
+
+int  hdmi_enable_avi_infoframe(struct avi_info_packet *pkt)
+{
+	int res = 0;
+	uint32_t vid_dip_ctl = 0;
+	uint32_t index = 0;
+	uint32_t dip_type = 0;
+	uint32_t dip_data = 0;
+
+	if (!pkt)
+		return -EINVAL;
+
+	hdmi_disable_avi_infoframe();
+
+	/* Add delay for any Pending transmissions ~ 2 VSync + 3 HSync */
+	msleep_interruptible(32 + 8);
+
+	dip_type = DIP_TYPE_AVI;
+	index = DIP_BUFFER_INDEX_AVI;
+
+
+	/* Disable DIP type & set the buffer index & reset access address */
+	vid_dip_ctl = REG_READ(VIDEO_DIP_CTRL);
+	vid_dip_ctl &= ~(dip_type |
+			DIP_BUFFER_INDEX_MASK |
+			DIP_ADDR_MASK |
+			DIP_TX_FREQ_MASK);
+	vid_dip_ctl |= (index |
+			PORT_B_SELECT |
+			EN_DIP);
+	REG_WRITE(VIDEO_DIP_CTRL, vid_dip_ctl);
+
+	/* Write Packet Data */
+	dip_data = 0;
+	dip_data = (pkt->header[0] << 0) |
+		   (pkt->header[1] << 8) |
+		   (pkt->header[2] << 16);
+	REG_WRITE(VIDEO_DIP_DATA, dip_data);
+
+	for (index = 0; index < (HDMI_DIP_PACKET_DATA_LEN / 4); index++) {
+		dip_data = pkt->data32[index];
+		REG_WRITE(VIDEO_DIP_DATA, dip_data);
+	}
+
+	/* Enable Packet Type & Transmission Frequency */
+	vid_dip_ctl = REG_READ(VIDEO_DIP_CTRL);
+	vid_dip_ctl |= (PORT_B_SELECT | EN_DIP);
+	vid_dip_ctl |= (dip_type | DIP_TX_FREQ_EVERY);
+	pr_debug("vid_dip_ctl %x\n", vid_dip_ctl);
+	REG_WRITE(VIDEO_DIP_CTRL, vid_dip_ctl);
+
+	return res;
+}
+
+static int hdmi_modeset(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	__u16 vblank_start;
+	__u16 vblank_end;
+	__u16 hblank_start;
+	__u16 hblank_end;
+	u32 m1 = 0, m2 = 0, n = 0, p1 = 0, p2 = 0;
+	int err = 0;
+
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	struct hdmi_hw_context *ctx = &hdmi_pipe->ctx;
+
+	if (!mode) {
+		pr_err("%s: invalid mode\n", __func__);
+		err = -EINVAL;
+		goto out_err;
+	}
+
+	pr_debug("%s\n", __func__);
+
+	/* TODO: calculate divisor here!! */
+	if (mode->clock == 148500) {
+		m1 = 2;
+		m2 = 116;
+		n = 1;
+		p1 = 3;
+		p2 = 2;
+	} else if (mode->clock == 74250) {
+		m1 = 2;
+		m2 = 145;
+		n = 1;
+		p1 = 3;
+		p2 = 5;
+	}
+
+	ctx->div = (0x11 << 24) | (p1 << 21) | (p2 << 16) | (n << 12) |
+		  (0x1 << 11)  | (m1 << 8)  | (m2);
+
+
+	/* TODO: setup audio clock */
+	hdmi_pipe->audio.tmds_clock = mode->clock;
+
+	vblank_start = min(mode->vsync_start, mode->vdisplay);
+	vblank_end = max(mode->vsync_end, mode->vtotal);
+	hblank_start = min(mode->hsync_start, mode->hdisplay);
+	hblank_end = max(mode->hsync_end, mode->htotal);
+
+	ctx->htotal =
+		(mode->hdisplay - 1) | ((mode->htotal - 1) << HORZ_TOTAL_SHIFT);
+	ctx->hblank =
+		(hblank_start - 1) | ((hblank_end - 1) << HORZ_BLANK_END_SHIFT);
+	ctx->hsync =
+		(mode->hsync_start - 1) |
+		((mode->hsync_end - 1) << HORZ_SYNC_END_SHIFT);
+	ctx->vtotal =
+		(mode->vdisplay - 1) | ((mode->vtotal - 1) << VERT_TOTAL_SHIFT);
+	ctx->vblank =
+		(vblank_start - 1) | ((vblank_end - 1) << VERT_BLANK_END_SHIFT);
+	ctx->vsync =
+		(mode->vsync_start - 1) |
+		((mode->vsync_end - 1) << VERT_SYNC_END_SHIFT);
+
+	ctx->pipesrc =
+		((mode->hdisplay - 1) << HORZ_SRC_SIZE_SHIFT) |
+							(mode->vdisplay - 1);
+	ctx->pipeconf = PIPEACONF_ENABLE;
+
+	ctx->hdmib = NULL_PACKET_EN | AUDIO_ENABLE | HDMI_PORT_EN;
+
+	/* FIXME: To make the aligned value DC independant. */
+	ctx->dspstride = ALIGN(mode->hdisplay * 4, 32);
+	ctx->dspsurf = 0;
+	ctx->dsplinoff = 0;
+	ctx->dspcntr = SRC_PIX_FMT_BGRX8888;
+	ctx->dsppos = 0;
+	ctx->dspsize = (mode->vdisplay-1) << HEIGHT_SHIFT | (mode->hdisplay-1);
+
+	ctx->pipestat = VERTICAL_SYNC_STATUS |
+		HDMI_AUDIO_UNDERRUN_STATUS |
+		HDMI_AUDIO_BUF_DONE_STATUS |
+		VERTICAL_SYNC_ENABLE |
+		HDMI_AUDIO_UNDERRUN_ENABLE |
+		HDMI_AUDIO_BUF_DONE_ENABLE;
+
+	hdmi_build_avi_packet(&hdmi_pipe->monitor, mode);
+	return 0;
+out_err:
+	return err;
+}
+
+static int hdmi_power_on(struct hdmi_pipe *pipe)
+{
+	int err = 0;
+	u32 power_island = 0;
+	struct hdmi_hw_context *ctx;
+	if (!pipe) {
+		pr_err("%s: invalid mode\n", __func__);
+		err = -EINVAL;
+		goto out_err;
+	}
+	ctx = &pipe->ctx;
+	power_island = pipe_to_island(pipe->base.base.idx);
+	if (power_island & OSPM_DISPLAY_B)
+		power_island |= OSPM_DISPLAY_HDMI;
+
+	if (!power_island_get(power_island)) {
+		err = -EIO;
+		goto out_err;
+	}
+
+	err = hdmi_setup_clock(pipe->ctx.div);
+	if (err)
+		goto out_err;
+
+	REG_WRITE(HTOTAL_B, ctx->htotal);
+	REG_WRITE(HBLANK_B, ctx->hblank);
+	REG_WRITE(HSYNC_B, ctx->hsync);
+	REG_WRITE(VTOTAL_B, ctx->vtotal);
+	REG_WRITE(VBLANK_B, ctx->vblank);
+	REG_WRITE(VSYNC_B, ctx->vsync);
+
+	REG_WRITE(SRCSZ_B, ctx->pipesrc);
+	REG_WRITE(PIPEBCONF, ctx->pipeconf);
+
+	REG_WRITE(HDMIB, ctx->hdmib);
+
+	REG_WRITE(DSPBSTRIDE, ctx->dspstride);
+	REG_WRITE(DSPBLINOFF, ctx->dsplinoff);
+	REG_WRITE(DSPBCNTR, ctx->dspcntr);
+	REG_WRITE(DSPBPOS, ctx->dsppos);
+	REG_WRITE(DSPBSIZE, ctx->dspsize);
+	REG_WRITE(DSPBSURF, ctx->dspsurf);
+
+	REG_WRITE(PIPEBSTAT, ctx->pipestat);
+	REG_WRITE(IMR, REG_READ(IMR) & ~IIR_PIPEB_EVENT);
+	REG_WRITE(IER, REG_READ(IER) | IIR_PIPEB_EVENT);
+
+	if (pipe->monitor.is_hdmi)
+		hdmi_enable_avi_infoframe(&pipe->monitor.avi_packet);
+out_err:
+	return err;
+}
+
+static int hdmi_dpms(struct intel_pipe *pipe, u8 state)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	int res = 0;
+
+	switch (state) {
+	case DRM_MODE_DPMS_ON:
+		res = hdmi_power_on(hdmi_pipe);
+		hdmi_hdcp_enable(hdmi_pipe);
+		break;
+	case DRM_MODE_DPMS_OFF:
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+	default:
+		pr_err("%s: unsupported dpms mode\n", __func__);
+		return -EOPNOTSUPP;
+	}
+	return res;
+}
+
+static bool hdmi_is_screen_connected(struct intel_pipe *pipe)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	if (atomic_read(&hdmi_pipe->hpd_ctx.is_connected))
+		return true;
+	else
+		return false;
+}
+
+static void hdmi_get_modelist(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **modelist, size_t *n_modes)
+{
+	/*TODO:  populate all the modes*/
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+
+	if (atomic_read(&hdmi_pipe->hpd_ctx.is_connected)) {
+		hdmi_pipe->monitor.raw_edid = get_edid(hdmi_pipe->adapter);
+		if (hdmi_pipe->monitor.raw_edid) {
+			hdmi_pipe->monitor.is_hdmi =
+				detect_hdmi_monitor(
+						hdmi_pipe->monitor.raw_edid);
+				parse_edid(&hdmi_pipe->monitor,
+					  hdmi_pipe->monitor.raw_edid);
+				populate_modes(hdmi_pipe);
+		} else {
+			pr_debug("TV is connected but no edid!!\n");
+			hdmi_pipe->monitor.preferred_mode = &fake_mode;
+			hdmi_pipe->monitor.screen_height_mm = 300;
+			hdmi_pipe->monitor.screen_width_mm = 500;
+		}
+	}
+	*modelist = hdmi_pipe->monitor.preferred_mode;
+	*n_modes = 1;
+}
+
+static void hdmi_get_preferred_mode(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **mode)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	*mode = hdmi_pipe->monitor.preferred_mode;
+}
+
+static void hdmi_pipe_hw_deinit(struct intel_pipe *pipe)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	struct hdmi_monitor *monitor;
+	struct hdmi_mode_info *mode_info, *t;
+	monitor = &hdmi_pipe->monitor;
+	/* delete all modes from list*/
+	list_for_each_entry_safe(mode_info, t,
+				&monitor->probedModes,
+				head) {
+		list_del(&mode_info->head);
+		kfree(mode_info);
+	}
+	monitor->preferred_mode = NULL;
+	monitor->raw_edid = NULL;
+	return;
+}
+
+static int hdmi_pipe_hw_init(struct intel_pipe *pipe)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+
+	hdmi_check_connection_status(hdmi_pipe);
+
+	if (atomic_read(&hdmi_pipe->hpd_ctx.is_connected)) {
+		hdmi_pipe->monitor.raw_edid = get_edid(hdmi_pipe->adapter);
+		if (hdmi_pipe->monitor.raw_edid) {
+			hdmi_pipe->monitor.is_hdmi =
+				detect_hdmi_monitor(
+						hdmi_pipe->monitor.raw_edid);
+			parse_edid(&hdmi_pipe->monitor,
+				  hdmi_pipe->monitor.raw_edid);
+			populate_modes(hdmi_pipe);
+		} else {
+			pr_debug("TV is connected but no edid!!\n");
+			hdmi_pipe->monitor.is_hdmi = true;
+			hdmi_pipe->monitor.preferred_mode = &fake_mode;
+			hdmi_pipe->monitor.screen_height_mm = 300;
+			hdmi_pipe->monitor.screen_width_mm = 500;
+		}
+	}
+	return 0;
+}
+
+static u32 hdmi_get_supported_events(struct intel_pipe *pipe)
+{
+	return INTEL_PIPE_EVENT_VSYNC |
+			INTEL_PIPE_EVENT_HOTPLUG_CONNECTED |
+			INTEL_PIPE_EVENT_HOTPLUG_DISCONNECTED |
+			INTEL_PIPE_EVENT_AUDIO_BUFFERDONE |
+			INTEL_PIPE_EVENT_AUDIO_UNDERRUN;
+}
+
+static int hdmi_set_event(struct intel_pipe *pipe, u8 event, bool enabled)
+{
+	return -EOPNOTSUPP;
+}
+
+static void hdmi_handle_events(struct intel_pipe *pipe, u32 events)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	pr_debug("%s: events=%d\n", __func__, events);
+	if (events & INTEL_PIPE_EVENT_AUDIO_BUFFERDONE)
+		schedule_work(&hdmi_pipe->audio.hdmi_bufferdone_work);
+
+	if (events & INTEL_PIPE_EVENT_AUDIO_UNDERRUN)
+		schedule_work(&hdmi_pipe->audio.hdmi_underrun_work);
+}
+static void hdmi_get_events(struct intel_pipe *pipe, u32 *events)
+{
+	struct hdmi_pipe *hdmi_pipe = to_hdmi_pipe(pipe);
+	u8 idx = pipe->base.idx;
+	u32 dc_events = REG_READ(IIR);
+	u32 event_bit;
+
+	*events = 0;
+
+	switch (idx) {
+	case 1:
+		event_bit = IIR_PIPEB_EVENT;
+		break;
+	default:
+		pr_err("%s: invalid pipe index %d\n", __func__, idx);
+		return;
+	}
+
+	/* first check if it's hotplug interrupt */
+	if (atomic_read(&hdmi_pipe->hpd_ctx.is_asserted)) {
+		if (atomic_read(&hdmi_pipe->hpd_ctx.is_connected)) {
+			*events |= INTEL_PIPE_EVENT_HOTPLUG_CONNECTED;
+			pr_debug("%s: HOTPLUG_CONNECTED\n", __func__);
+		} else {
+			*events |= INTEL_PIPE_EVENT_HOTPLUG_DISCONNECTED;
+			pr_debug("In %s disconnected!!\n", __func__);
+		}
+		/* clear hpd assertion */
+		atomic_set(&hdmi_pipe->hpd_ctx.is_asserted, 0);
+	}
+
+	if (!(dc_events & event_bit))
+		return;
+
+	/* Clear the 1st level interrupt. */
+	REG_WRITE(IIR, dc_events & IIR_PIPEB_EVENT);
+
+	if (VBLANK_STATUS & REG_READ(PIPEBSTAT))
+		*events = INTEL_PIPE_EVENT_VSYNC;
+
+	if (HDMI_AUDIO_UNDERRUN_STATUS & REG_READ(PIPEBSTAT)) {
+		*events |= INTEL_PIPE_EVENT_AUDIO_UNDERRUN;
+		pr_debug("%s: Underrun\n", __func__);
+	}
+
+	if (HDMI_AUDIO_BUF_DONE_STATUS & REG_READ(PIPEBSTAT)) {
+		*events |= INTEL_PIPE_EVENT_AUDIO_BUFFERDONE;
+		pr_debug("%s: Bufferdone\n", __func__);
+	}
+
+	REG_WRITE(PIPEBSTAT, REG_READ(PIPEBSTAT));
+
+	/**
+	 * FIXME: should use hardware vsync counter.
+	 */
+	if (*events & INTEL_PIPE_EVENT_VSYNC) {
+		if (++vsync_counter > VSYNC_COUNT_MAX_MASK)
+			vsync_counter = 0;
+	}
+}
+
+u32 hdmi_get_vsync_counter(struct intel_pipe *pipe, u32 interval)
+{
+
+	u32 count;
+	u32 max_count_mask = VSYNC_COUNT_MAX_MASK;
+
+	/* NOTE: PIPEFRAMEHIGH & PIPEFRAMEPIXEL regs are RESERVED in ANN DC. */
+#if 0
+	u32 count, high1, high2, low;
+	u32 max_count_mask = (PIPE_FRAME_HIGH_MASK | PIPE_FRAME_LOW_MASK);
+
+	if (!(PIPEACONF_ENABLE & REG_READ(PIPEBCONF))) {
+		pr_err("%s: pipe was disabled\n", __func__);
+		return 0;
+	}
+
+	/*
+	 * High & low register fields aren't synchronized, so make sure
+	 * we get a low value that's stable across two reads of the high
+	 * register.
+	 */
+	do {
+		high1 = ((REG_READ(PIPEBFRAMEHIGH) &
+			PIPE_FRAME_HIGH_MASK) >> PIPE_FRAME_HIGH_SHIFT);
+		low =  ((REG_READ(PIPEBFRAMEPIXEL) &
+			PIPE_FRAME_LOW_MASK) >> PIPE_FRAME_LOW_SHIFT);
+		high2 = ((REG_READ(PIPEBFRAMEHIGH) &
+			PIPE_FRAME_HIGH_MASK) >>  PIPE_FRAME_HIGH_SHIFT);
+	} while (high1 != high2);
+
+	count = (high1 << 8) | low;
+	count |= (~max_count_mask);
+	count += interval;
+	count &= max_count_mask;
+#endif
+
+	count = vsync_counter;
+	count |= (~max_count_mask);
+	count += interval;
+	count &= max_count_mask;
+
+	pr_debug("%s: count = %#x\n", __func__, count);
+
+	return count;
+}
+
+
+static struct intel_pipe_ops hdmi_base_ops = {
+	.hw_init = hdmi_pipe_hw_init,
+	.hw_deinit = hdmi_pipe_hw_deinit,
+	.get_preferred_mode = hdmi_get_preferred_mode,
+	.get_modelist = hdmi_get_modelist,
+	.dpms = hdmi_dpms,
+	.modeset = hdmi_modeset,
+	.get_screen_size = hdmi_get_screen_size,
+	.is_screen_connected = hdmi_is_screen_connected,
+	.get_supported_events = hdmi_get_supported_events,
+	.set_event = hdmi_set_event,
+	.get_events = hdmi_get_events,
+	.get_vsync_counter = hdmi_get_vsync_counter,
+	.handle_events = hdmi_handle_events,
+};
+
+void hdmi_pipe_destroy(struct hdmi_pipe *pipe)
+{
+	return;
+}
+
+int hdmi_pipe_init(struct hdmi_pipe *pipe, struct device *dev,
+	struct intel_plane *primary_plane, u8 idx)
+{
+	int err;
+
+	if (!pipe) {
+		pr_err("%s: invalid parameters\n", __func__);
+		return -EINVAL;
+	}
+
+	/* get platform dependent configs */
+	err = mofd_get_platform_configs(&pipe->config);
+	if (err) {
+		pr_err("%s: failed to init HDMI hw\n",
+			__func__);
+		goto out_err0;
+	}
+
+	pipe->adapter = i2c_get_adapter(HDMI_I2C_ADAPTER_NUM);
+	if (!pipe->adapter) {
+		pr_err("Unable to get i2c adapter for HDMI");
+		err = -EIO;
+		goto out_err0;
+	}
+
+	/* necessary init work */
+	INIT_LIST_HEAD(&pipe->monitor.probedModes);
+
+	/*
+		TODO put this thing to a more elegant place
+	*/
+	mofd_hdmi_enable_hpd(true);
+
+	/* init hotplug ctx */
+	atomic_set(&pipe->hpd_ctx.is_connected, 0);
+	atomic_set(&pipe->hpd_ctx.is_asserted, 0);
+
+	/* init hpd driver*/
+	pipe->hdmi_hpd_driver.name = HDMI_HPD_DRIVER_NAME;
+	pipe->hdmi_hpd_driver.probe = hdmi_hpd_probe;
+	pipe->id_table[0].vendor = 0x8086;
+	pipe->id_table[0].device = pipe->config.pci_device_id;
+	pipe->id_table[0].driver_data = (unsigned long)pipe;
+	pipe->hdmi_hpd_driver.id_table = pipe->id_table;
+
+	pipe->hotplug_data = pipe;
+	pipe->hotplug_irq_cb = hotplug_thread_fn;
+
+	/*
+		create workqueue for register hotplug device
+		1, Because we need it to schedue ASAP, so put a WQ_HIGHPRI
+		2, Max_active assigned as 1 because there will be only one
+		    work
+		3, We don't want concurrent execute so put a WQ_NON_REENTRANT
+	*/
+	pipe->hotplug_register_wq = alloc_workqueue("hotplug_device_register",
+				WQ_UNBOUND | WQ_NON_REENTRANT | WQ_HIGHPRI, 1);
+	if (!pipe->hotplug_register_wq) {
+		pr_err("failed to create hotplug device register workqueue\n");
+		err = -ENOMEM;
+		goto out_err0;
+	}
+
+	INIT_WORK(&pipe->hotplug_register_work, adf_hdmi_hpd_init_work);
+	schedule_work(&pipe->hotplug_register_work);
+
+	/*HDCP initialized, just allocate resources, no function working*/
+	hdmi_hdcp_init(pipe);
+
+	/* TODO: put it to a more elegant place */
+	adf_hdmi_audio_init(pipe);
+
+	return intel_pipe_init(&pipe->base, dev, idx, false, INTEL_PIPE_HDMI,
+		primary_plane, &hdmi_base_ops, "hdmi_pipe");
+
+out_err0:
+	return err;
+}
diff --git a/drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.h b/drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.h
new file mode 100644
index 0000000..878ea25
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/hdmi_pipe.h
@@ -0,0 +1,204 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef HDMI_PIPE_H_
+#define HDMI_PIPE_H_
+
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <video/adf.h>
+#include "core/intel_dc_config.h"
+#include "core/common/intel_dc_regs.h"
+#include "intel_adf_device.h"
+#include "pwr_mgmt.h"
+#include "adf_hdmi_audio_if.h"
+#include "intel_adf.h"
+
+#define MSIC_HPD_GPIO_PIN_NAME "HDMI_HPD"
+#define MSIC_LS_EN_GPIO_PIN_NAME "HDMI_LS_EN"
+#define HDMI_I2C_ADAPTER_NUM 10
+
+#define HDMI_MAX_DISPLAY_H 1920
+#define HDMI_MAX_DISPLAY_V 1080
+
+#define HDMI_MODE_INVALID 1
+
+/* DPLL registers on IOSF */
+#define PLLA_DWORD3_1   0x800C
+#define PLLA_DWORD3_2   0x802C
+#define PLLA_DWORD5_1   0x8014
+#define PLLA_DWORD5_2   0x8034
+#define PLLA_DWORD7_1   0x801C
+#define PLLA_DWORD7_2   0x803C
+#define PLLB_DWORD8     0x8040
+#define PLLB_DWORD10_1  0x8048
+#define PLLB_DWORD10_2  0x8068
+#define CMN_DWORD3      0x810C
+#define CMN_DWORD8      0x8100
+#define REF_DWORD18     0x80C0
+#define REF_DWORD22     0x80D0
+#define DPLL_CML_CLK1   0x8238
+#define DPLL_CML_CLK2   0x825C
+#define DPLL_LRC_CLK    0x824C
+#define DPLL_Tx_GRC     0x8244
+#define PCS_DWORD12_1   0x0230
+#define PCS_DWORD12_2   0x0430
+#define TX_SWINGS_1     0x8294
+#define TX_SWINGS_2     0x8290
+#define TX_SWINGS_3     0x8288
+#define TX_SWINGS_4     0x828C
+#define TX_SWINGS_5     0x0690
+#define TX_SWINGS_6     0x822C
+#define TX_SWINGS_7     0x8224
+#define TX_GROUP_1      0x82AC
+#define TX_GROUP_2      0x82B8
+
+#define DPLL_IOSF_EP 0x13
+
+#define MAX_ELD_LENGTH 128
+
+#define HDMI_DIP_PACKET_HEADER_LEN	3
+#define HDMI_DIP_PACKET_DATA_LEN	28
+
+struct  avi_info_packet {
+	uint8_t header[HDMI_DIP_PACKET_HEADER_LEN];
+	union {
+		uint8_t data[HDMI_DIP_PACKET_DATA_LEN];
+		uint32_t data32[HDMI_DIP_PACKET_DATA_LEN/4];
+	};
+};
+
+struct hdmi_platform_config {
+	u8 platform_id;  /* Medfield, Merrifield, CTP, Moorefield*/
+	int gpio_hpd_pin;
+	int gpio_ls_en_pin;
+	int last_pin_value;
+	uint32_t pci_device_id;
+	uint32_t irq_number;
+	uint32_t min_clock;
+	uint32_t max_clock;
+};
+
+struct hdmi_hw_context {
+	u32 vgacntr;
+
+	/*plane*/
+	u32 dspcntr;
+	u32 dspsize;
+	u32 dspsurf;
+	u32 dsppos;
+	u32 dspstride;
+	u32 dsplinoff;
+
+	/*pipe regs*/
+	u32 htotal;
+	u32 hblank;
+	u32 hsync;
+	u32 vtotal;
+	u32 vblank;
+	u32 vsync;
+	u32 pipestat;
+
+	u32 pipesrc;
+
+	u32 div;
+	u32 pipeconf;
+
+	/*hdmi port*/
+	u32 hdmib;
+
+};
+
+struct hdmi_mode_info {
+	struct list_head head;
+	struct drm_mode_modeinfo drm_mode;
+	int mode_status;
+};
+
+struct hdmi_hotplug_context {
+	atomic_t is_asserted;
+	atomic_t is_connected;
+};
+
+struct hdmi_monitor {
+	struct edid *raw_edid;
+
+	uint8_t eld[MAX_ELD_LENGTH];
+
+	/* information parsed from edid*/
+	bool is_hdmi;
+
+	struct list_head probedModes;
+
+	struct drm_mode_modeinfo *preferred_mode;
+	struct avi_info_packet avi_packet;
+
+	int screen_width_mm;
+	int screen_height_mm;
+	bool quant_range_selectable;
+	u8 video_code;
+};
+
+struct hdmi_audio {
+	had_event_call_back callbacks;
+	uint32_t tmds_clock;
+	struct snd_intel_had_interface *had_interface;
+	void *had_pvt_data;
+	struct work_struct hdmi_audio_work;
+	struct work_struct hdmi_bufferdone_work;
+	struct work_struct hdmi_underrun_work;
+};
+
+struct hdmi_pipe {
+	struct intel_pipe base;
+	struct hdmi_platform_config config;
+	struct hdmi_monitor monitor;
+	struct hdmi_audio audio;
+
+	struct hdmi_hw_context ctx;
+
+	struct workqueue_struct *hotplug_register_wq;
+	struct work_struct hotplug_register_work;
+	struct hdmi_hotplug_context hpd_ctx;
+
+	/* this is for HPD device */
+	struct pci_driver hdmi_hpd_driver;
+	struct pci_device_id id_table[1];
+	irqreturn_t (*hotplug_irq_cb)(int, void *);
+	void *hotplug_data;
+
+	/*this is for EDID R/W and HDCP control*/
+	struct i2c_adapter *adapter;
+};
+
+static inline struct hdmi_pipe *to_hdmi_pipe(struct intel_pipe *pipe)
+{
+	return container_of(pipe, struct hdmi_pipe, base);
+}
+
+extern int hdmi_pipe_init(struct hdmi_pipe *pipe, struct device *dev,
+	struct intel_plane *primary_plane, u8 idx);
+extern void hdmi_pipe_destroy(struct hdmi_pipe *pipe);
+int  mofd_get_platform_configs(struct hdmi_platform_config *config);
+bool mofd_hdmi_enable_hpd(bool enable);
+bool mofd_hdmi_get_cable_status(struct hdmi_platform_config *config);
+extern void adf_hdmi_audio_init(struct hdmi_pipe *hdmi_pipe);
+extern void adf_hdmi_audio_signal_event(enum had_event_type event);
+
+#endif /* HDMI_PIPE_H_ */
diff --git a/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp.c b/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp.c
new file mode 100644
index 0000000..8e065e8
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp.c
@@ -0,0 +1,809 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include <linux/gpio.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel-mid.h>
+#include <video/adf_client.h>
+
+#include "mofd_hdcp_reg.h"
+#include "../hdmi_hdcp.h"
+
+static void hdcp_off(void);
+static uint32_t hdcp_get_status(void);
+static void hdcp_read_an(uint8_t *an);
+static void hdcp_capture_an(void);
+static bool hdcp_is_an_ready(void);
+static void hdcp_enable_port(bool enable);
+static void hdcp_set_config(int val);
+static int hdcp_get_config(void);
+static void hdcp_write_rx_ri(uint16_t rx_ri);
+static bool hdcp_is_hdcp_on(void);
+static bool hdcp_config_is_encrypting(void);
+static uint8_t hdcp_get_repeater_status(void);
+static bool hdcp_repeater_rdy_for_nxt_data(void);
+static bool hdcp_repeater_wait_for_next_data(void);
+static void hdcp_set_repeater_control(int value);
+static bool hdcp_repeater_is_idle(void);
+static bool hdcp_repeater_wait_for_idle(void);
+
+/**
+ * Description: switch off hdcp by setting in the config register
+ *
+ * Returns:	none
+ */
+static void hdcp_off(void)
+{
+	hdcp_set_config(HDCP_Off);
+}
+
+/**
+ * Description: read register for hdcp status
+ *
+ * Returns:	value of hdcp status register
+ */
+static uint32_t hdcp_get_status(void)
+{
+	return REG_READ(HDCP_STATUS);
+}
+
+/**
+ * Description: read an from hdcp tx
+ *
+ * @an		buffer to copy the an into
+ *
+ * Returns:	none
+ */
+static void hdcp_read_an(uint8_t *an)
+{
+	uint8_t i = 0;
+	struct double_word_t temp;
+	temp.value = 0;
+	temp.low = REG_READ(HDCP_AN_LO);
+	temp.high = REG_READ(HDCP_AN_HI);
+	for (i = 0; i < HDCP_AN_SIZE; i++)
+		an[i] = temp.byte[i];
+}
+
+/**
+ * Description: generate an for new authentication
+ *
+ * Returns:	none
+ */
+static void hdcp_capture_an(void)
+{
+	REG_WRITE(HDCP_INIT, (uint32_t) jiffies);
+	REG_WRITE(HDCP_INIT, (uint32_t) (jiffies >> 1));
+	REG_WRITE(HDCP_CONFIG, HDCP_CFG_CAPTURE);
+}
+
+/**
+ * Description: check if an is ready for use
+ *
+ * Returns:	true if ready else false
+ */
+static bool hdcp_is_an_ready(void)
+{
+	struct mofd_hdcp_status_reg_t status;
+	status.value = hdcp_get_status();
+
+	if (status.an_ready)
+		return true;
+
+	return false;
+}
+
+/**
+ * Description: enable hdcp on hdmi port
+ *
+ * @enable	enable or disable hdcp on hdmi port
+ *
+ * Returns:	none
+ */
+static void hdcp_enable_port(bool enable)
+{
+	uint32_t hdmib_reg = REG_READ(HDMIB);
+	if (enable)
+		hdmib_reg |= ENABLE_HDCP;
+	else
+		hdmib_reg &= ~ENABLE_HDCP;
+	REG_WRITE(HDMIB, hdmib_reg);
+}
+
+/**
+ * Description: set config value in hdcp tx configuration register
+ *
+ * @val		value to be written into the configuration register's
+ *		config bits
+ *
+ * Returns:	none
+ */
+static void hdcp_set_config(int val)
+{
+	struct mofd_hdcp_config_reg_t config;
+	config.value = REG_READ(HDCP_CONFIG);
+	config.hdcp_config = val;
+	REG_WRITE(HDCP_CONFIG, config.value);
+}
+
+/**
+ * Description: read hdcp tx config bits
+ *
+ * Returns:	hdcp tx configuration register's config bits
+ */
+static int hdcp_get_config(void)
+{
+	struct mofd_hdcp_config_reg_t config;
+	config.value = REG_READ(HDCP_CONFIG);
+	return config.hdcp_config;
+}
+
+/**
+ * Description: write rx_ri into hdcp tx register
+ *
+ * @rx_ri	downstream device's ri value
+ *
+ * Returns:	none
+ */
+static void hdcp_write_rx_ri(uint16_t rx_ri)
+{
+	REG_WRITE(HDCP_RI, rx_ri);
+}
+
+/**
+ * Description: check if hdcp is enabled on hdmi port
+ *
+ * Returns:	true if enabled else false
+ */
+static bool hdcp_is_hdcp_on(void)
+{
+	struct mofd_hdcp_status_reg_t status;
+	status.value = hdcp_get_status();
+
+	if (status.hdcp_on)
+		return true;
+
+	return false;
+}
+
+/**
+ * Description: check whether hdcp configuration is set to encrypting
+ *
+ * Returns:	true if set to encrypting else false
+ */
+static bool hdcp_config_is_encrypting(void)
+{
+	if (hdcp_get_config() == HDCP_AUTHENTICATE_AND_ENCRYPT)
+		return true;
+	return false;
+}
+
+/**
+ * Description: get status bits of hdcp-tx repeater reguister
+ *
+ * Returns:	repeater status bits
+ */
+static uint8_t hdcp_get_repeater_status(void)
+{
+	struct mofd_hdcp_repeater_reg_t repeater;
+	repeater.value = REG_READ(HDCP_REP);
+	return repeater.status;
+}
+
+/**
+ * Description: check if repeater is ready for next data
+ *
+ * Returns:	true if ready else false
+ */
+static bool hdcp_repeater_rdy_for_nxt_data(void)
+{
+	uint8_t status = hdcp_get_repeater_status();
+	if (status == HDCP_REPEATER_STATUS_RDY_NEXT_DATA)
+		return true;
+	return false;
+}
+
+/**
+ * Description: wait for hdcp repeater to be ready for next data
+ *
+ * Returns:	true if ready else false
+ */
+static bool hdcp_repeater_wait_for_next_data(void)
+{
+	uint16_t i = 0;
+	for (; i < HDCP_MAX_RETRY_STATUS; i++) {
+		if (hdcp_repeater_rdy_for_nxt_data())
+			return true;
+	}
+	return false;
+}
+
+/**
+ * Description: set control bits of hdcp-tx repeater reguister
+ *
+ * @value	value of the control bits
+ *
+ * Returns:	none
+ */
+static void hdcp_set_repeater_control(int value)
+{
+	struct mofd_hdcp_repeater_reg_t repeater;
+	repeater.value = REG_READ(HDCP_REP);
+	repeater.control = value;
+	REG_WRITE(HDCP_REP, repeater.value);
+}
+
+/**
+ * Description: check if repeater is idle
+ *
+ * Returns:	true if idle else false
+ */
+#if 0
+static bool hdcp_repeater_is_idle(void)
+{
+	uint8_t status = hdcp_get_repeater_status();
+	if (status == HDCP_REPEATER_STATUS_IDLE)
+		return true;
+	return false;
+}
+#endif
+/**
+ * Description: check if repeater is idle
+ *
+ * Returns:	true if idle else false
+ */
+static bool hdcp_repeater_is_idle(void)
+{
+	uint8_t status = hdcp_get_repeater_status();
+	if (status == HDCP_REPEATER_STATUS_IDLE)
+		return true;
+	return false;
+}
+
+/**
+ * Description: wait for hdcp repeater to get into idle state
+ *
+ * Returns:	true if repeater is in idle state else false
+ */
+static bool hdcp_repeater_wait_for_idle(void)
+{
+	uint16_t i = 0;
+	for (; i < HDCP_MAX_RETRY_STATUS; i++) {
+		if (hdcp_repeater_is_idle())
+			return true;
+	}
+	return false;
+}
+
+/**
+ * Description: check the status of SHA1 match
+ *
+ * Returns:	0	on error
+ *		1	on match
+ *		-1	if busy
+ */
+static int hdcp_repeater_v_match_check(void)
+{
+	uint8_t status = hdcp_get_repeater_status();
+	switch (status) {
+	case HDCP_REPEATER_STATUS_COMPLETE_MATCH:
+		return 1;
+	case HDCP_REPEATER_STATUS_BUSY:
+		return -1;
+	default:
+		return 0;
+	}
+}
+
+/**
+ * Description: compare hdcp tx & hdcp rx sha1 results
+ *
+ * @rep_prime_v sha1 value from downstream repeater
+ *
+ * Returns:	true if same else false
+ */
+bool mofd_hdcp_compare_v(uint32_t *rep_prime_v)
+{
+	bool ret = false;
+	uint32_t i = 10, stat;
+
+	/* Load V' */
+	REG_WRITE(HDCP_V0, *rep_prime_v);
+
+	REG_WRITE(HDCP_V1, *(rep_prime_v + 1));
+
+	REG_WRITE(HDCP_V2, *(rep_prime_v + 2));
+
+	REG_WRITE(HDCP_V3, *(rep_prime_v + 3));
+
+	REG_WRITE(HDCP_V4, *(rep_prime_v + 4));
+
+	if (false == hdcp_repeater_wait_for_next_data())
+		goto exit;
+
+	/* Set HDCP_REP to do the comparison, start
+	 * transmitter's V calculation
+	 */
+	hdcp_set_repeater_control(HDCP_REPEATER_COMPLETE_SHA1);
+
+	usleep_range(5000, 5500)
+	do {
+		stat = hdcp_repeater_v_match_check();
+		if (1 == stat) {
+			ret = true; /* match */
+			break;
+		} else if (-1 == stat)
+			usleep_range(5000, 5500)
+		else
+			break; /* mismatch */
+	} while (--i);
+
+exit:
+	return ret;
+}
+
+/**
+ * Description: compute v for repeater authentication
+ *
+ * @rep_ksv_list	 ksv list from downstream repeater
+ * @rep_ksv_list_entries number of entries in the ksv list
+ * @topology_data	bstatus value
+ *
+ * Returns:	true on successfully computing v else false
+ */
+bool mofd_hdcp_compute_tx_v(uint8_t *rep_ksv_list,
+				   uint32_t rep_ksv_list_entries,
+				   uint16_t topology_data)
+{
+	bool ret = false;
+	const uint8_t BSTAT_M0_LEN = 18; /* 2 (bstatus) + 8 (M0) + 8 (length) */
+	const uint8_t BSTAT_M0 = 10; /* 2 (bstatus) + 8 (M0) */
+	const uint8_t M0 = 8; /* 8 (M0) */
+	uint32_t num_devices = rep_ksv_list_entries;
+	uint32_t lower_num_bytes_for_sha = 0, num_pad_bytes = 0, temp_data = 0;
+	uint32_t rem_text_data = 0, num_mo_bytes_left = M0, value = 0, i = 0;
+	uint8_t *buffer = NULL, *temp_buffer = NULL, *temp_data_ptr = NULL;
+	struct sqword_t buffer_len;
+
+	/* Clear SHA hash generator for new V calculation and
+	 * set the repeater to idle state
+	 */
+	REG_WRITE(HDCP_SHA1_IN, 0);
+
+	hdcp_set_repeater_control(HDCP_REPEATER_CTRL_IDLE);
+	if (!hdcp_repeater_wait_for_idle())
+		return false;
+
+	/* Start the SHA buffer creation to find the number of pad bytes */
+	num_pad_bytes = (64 - ((rep_ksv_list_entries * HDCP_KSV_SIZE)
+			 + BSTAT_M0_LEN)
+			 % 64);
+
+	/* Get the number of bytes for SHA */
+	lower_num_bytes_for_sha = (HDCP_KSV_SIZE * num_devices)
+				   + BSTAT_M0_LEN
+				   + num_pad_bytes; /* multiple of 64 bytes */
+
+	buffer = kzalloc(lower_num_bytes_for_sha, GFP_KERNEL);
+	if (!buffer)
+		return false;
+
+	/* 1. Copy the KSV buffer
+	 * Note: data is in little endian format
+	 */
+	temp_buffer = buffer;
+	memcpy((void *)temp_buffer, (void *)rep_ksv_list,
+		     num_devices * HDCP_KSV_SIZE);
+	temp_buffer += num_devices * HDCP_KSV_SIZE;
+
+	/* 2. Copy the topology_data
+	 */
+	memcpy((void *)temp_buffer, (void *)&topology_data, 2);
+	/* bstatus is copied in little endian format */
+	temp_buffer += 2;
+
+	/* 3. Offset the pointer buffer by 8 bytes
+	 * These 8 bytes are zeroed and are place holders for M0
+	 */
+	temp_buffer += 8;
+
+	/* 4. Pad the buffer with extra bytes
+	 * The first padding byte must be 0x80 based on SHA1 message digest
+	 * algorithm. HW automatically appends 0x80 while creating
+	 * the buffer if M0 is not 32-bit aligned
+	 * If M0 is 32-bit aligned we need to explicitly inject 0x80 to the
+	 * buffer
+	 */
+	if (num_pad_bytes &&
+			((num_devices * HDCP_KSV_SIZE + BSTAT_M0) % 4 == 0))
+		*temp_buffer = 0x80;
+	temp_buffer += num_pad_bytes;
+
+	/* 5. Construct the length byte */
+	buffer_len.quad_part = (unsigned long long)(rep_ksv_list_entries *
+				HDCP_KSV_SIZE + BSTAT_M0) * 8; /* in bits */
+	temp_data_ptr = (uint8_t *)&buffer_len.quad_part;
+	/* Store in big endian form, it is reversed to little endian
+	 * when fed to SHA1
+	 */
+	for (i = 1; i <= 8; i++) {
+		*temp_buffer = *(temp_data_ptr + 8 - i);
+		temp_buffer++;
+	}
+
+	/* 6. Write KSV's and bstatus into SHA */
+	temp_buffer = buffer;
+	for (i = 0; i < (HDCP_KSV_SIZE * num_devices + 2)/4; i++) {
+		hdcp_set_repeater_control(HDCP_REPEATER_32BIT_TEXT_IP);
+
+		/* As per HDCP spec sample SHA is in little endian format.
+		 * But the data fed to the cipher needs to be in big endian
+		 * format for it to compute it correctly
+		 */
+		memcpy(&value, temp_buffer, 4);
+		value = HDCP_CONVERT_ENDIANNESS(value);
+		REG_WRITE(HDCP_SHA1_IN, value);
+		temp_buffer += 4;
+
+		if (false == hdcp_repeater_wait_for_next_data())
+			goto exit;
+	}
+
+	/* 7. Write the remaining bstatus data and M0
+	 * Text input must be aligned to LSB of the SHA1
+	 * in register when inputting partial text and partial M0
+	 */
+	rem_text_data = (HDCP_KSV_SIZE * num_devices + 2) % 4;
+	if (rem_text_data) {
+		/* Update the number of M0 bytes */
+		num_mo_bytes_left = num_mo_bytes_left - (4-rem_text_data);
+
+		if (false == hdcp_repeater_wait_for_next_data())
+			goto exit;
+
+		switch (rem_text_data) {
+		case 1:
+			hdcp_set_repeater_control(
+					HDCP_REPEATER_8BIT_TEXT_24BIT_MO_IP);
+			break;
+		case 2:
+			hdcp_set_repeater_control(
+					HDCP_REPEATER_16BIT_TEXT_16BIT_MO_IP);
+			break;
+		case 3:
+			hdcp_set_repeater_control(
+					HDCP_REPEATER_24BIT_TEXT_8BIT_MO_IP);
+			break;
+		default:
+			goto exit;
+		}
+
+		memcpy(&value, temp_buffer, 4);
+
+		/* Swap the text data in big endian format leaving the M0 data
+		 * as it is. LSB should contain the data in big endian format.
+		 * Since the M0 specfic data is all zeros while it's fed to the
+		 * cipher, those bit don't need to be modified.
+		 */
+		temp_data = 0;
+		for (i = 0; i < rem_text_data; i++) {
+			temp_data |= ((value & 0xff << (i * 8)) >>
+					(i * 8)) <<
+					((rem_text_data - i - 1) * 8);
+		}
+		REG_WRITE(HDCP_SHA1_IN, temp_data);
+		temp_buffer += 4;
+	}
+
+	/* write 4 bytes of M0 */
+	if (false == hdcp_repeater_wait_for_next_data())
+		goto exit;
+
+	hdcp_set_repeater_control(HDCP_REPEATER_32BIT_MO_IP);
+	REG_WRITE(HDCP_SHA1_IN, (uint32_t)temp_buffer);
+	temp_buffer += 4;
+	num_mo_bytes_left -= 4;
+
+	if (num_mo_bytes_left) {
+		/* The remaining M0 + padding bytes need to be added */
+		num_pad_bytes = num_pad_bytes - (4 - num_mo_bytes_left);
+
+		/* write 4 bytes of M0 */
+		if (false == hdcp_repeater_wait_for_next_data())
+			goto exit;
+		switch (num_mo_bytes_left) {
+		case 1:
+			hdcp_set_repeater_control(
+					HDCP_REPEATER_24BIT_TEXT_8BIT_MO_IP);
+			break;
+		case 2:
+			hdcp_set_repeater_control(
+					HDCP_REPEATER_16BIT_TEXT_16BIT_MO_IP);
+			break;
+		case 3:
+			hdcp_set_repeater_control(
+					HDCP_REPEATER_8BIT_TEXT_24BIT_MO_IP);
+			break;
+		case 4:
+			hdcp_set_repeater_control(
+					HDCP_REPEATER_32BIT_MO_IP);
+			break;
+		default:
+			/* should never happen */
+			goto exit;
+		}
+
+		REG_WRITE(HDCP_SHA1_IN, (uint32_t)temp_buffer);
+		temp_buffer += 4;
+		num_mo_bytes_left = 0;
+	}
+
+	/* 8. Write the remaining padding bytes and length */
+	/* Remaining data = remaining padding data + 64 bits of length data */
+	rem_text_data = num_pad_bytes + 8;
+
+	if (rem_text_data % 4) {
+		/* Should not happen */
+		pr_debug("hdcp: compute_tx_v - data not aligned\n");
+		goto exit;
+	}
+
+	for (i = 0; i < rem_text_data / 4; i++) {
+		if (false == hdcp_repeater_wait_for_next_data())
+			goto exit;
+
+		hdcp_set_repeater_control(HDCP_REPEATER_32BIT_TEXT_IP);
+		memcpy(&value, temp_buffer, 4);
+		/* Do the big endian conversion */
+		value = HDCP_CONVERT_ENDIANNESS(value);
+		REG_WRITE(HDCP_SHA1_IN, value);
+		temp_buffer += 4;
+	}
+
+	/* Done */
+	ret = true;
+
+exit:
+	kfree(buffer);
+	return ret;
+}
+
+/**
+ * Description: Enable encryption once r0 matches
+ *
+ * Returns:	true on enabling encryption else false
+ */
+bool mofd_hdcp_enable_encryption(void)
+{
+	struct mofd_hdcp_status_reg_t status;
+	uint32_t hdmib_reg = REG_READ(HDMIB);
+	status.value = hdcp_get_status();
+
+	if (hdcp_is_hdcp_on() &&
+	    hdcp_config_is_encrypting() &&
+	    status.ri_match &&
+	    (hdmib_reg & ENABLE_HDCP))
+		return true;
+	return false;
+}
+
+/**
+ * Description: disable hdcp
+ *
+ * Returns:	true on successfully disabling hdcp else false
+ */
+bool mofd_hdcp_disable(void)
+{
+	hdcp_off();
+	/* Set Rx_Ri to 0 */
+	hdcp_write_rx_ri(0);
+	/* Set Repeater to Not Present */
+	mofd_hdcp_set_repeater(false);
+	/* Disable HDCP on this Port */
+	/* ips_hdcp_enable_port(false); */
+	return true;
+}
+
+/**
+ * Description: check if hdcp tx & rx ri matches
+ *
+ * @rx_ri	ri of downstream device
+ *
+ * Returns:	true if ri matches else false
+ */
+bool mofd_hdcp_does_ri_match(uint16_t rx_ri)
+{
+	struct mofd_hdcp_status_reg_t status;
+
+	hdcp_write_rx_ri(rx_ri);
+	status.value = hdcp_get_status();
+	if (status.ri_match)
+		return true;
+	return false;
+}
+
+/**
+ * Description: check if hdcp tx R0 is ready after starting authentication
+ *
+ * Returns:	true if r0 is ready else false
+ */
+bool mofd_hdcp_is_r0_ready(void)
+{
+	struct mofd_hdcp_status_reg_t status;
+	status.value = hdcp_get_status();
+
+	if (status.ri_ready)
+		return true;
+	return false;
+}
+
+/**
+ * Description: initialize hdcp tx for authentication
+ *
+ * Returns:	true success else false
+ */
+bool mofd_hdcp_init(void)
+{
+	return true;
+}
+
+/**
+ * Description: check whether hdcp hardware is ready
+ *
+ * Returns:	true if ready else false
+ */
+bool mofd_hdcp_is_ready(void)
+{
+	struct mofd_hdcp_status_reg_t status;
+	int count = 20;
+	bool ret  = false;
+
+	REG_WRITE(HDCP_CONFIG, HDCP_FUSE_PULL_ENABLE | HDCP_PULL_FUSE);
+	while ((count--) > 0) {
+		udelay(20);
+		status.value = hdcp_get_status();
+		if (status.fus_success && status.fus_complete) {
+			ret = true;
+			break;
+		}
+	}
+
+	pr_debug("hdcp: read count left = %d\n", count);
+	return ret;
+}
+
+/**
+ * Description: get hardware frame count for cipher Ri update
+ *
+ * @count   framer count for cipher Ri update
+ *
+ * Returns: true if successful else false
+ */
+bool mofd_hdcp_get_ri_frame_count(uint8_t *count)
+{
+	struct mofd_hdcp_status_reg_t status;
+
+	status.value = hdcp_get_status();
+	*count       = status.frame_count;
+
+	return true;
+}
+
+/**
+ * Description: read an from hdcp tx
+ *
+ * @an	  buffer to return an in
+ *
+ * Returns:	true on succesful read else false
+ */
+bool mofd_hdcp_get_an(uint8_t *an, uint32_t size)
+{
+	if (an != NULL && size == HDCP_AN_SIZE) {
+		bool ret = false;
+		hdcp_off();
+		hdcp_capture_an();
+		do {
+			ret = hdcp_is_an_ready();
+		} while (ret == false);
+		hdcp_read_an(an);
+
+		return true;
+	}
+	return false;
+}
+
+/**
+ * Description: set repeater bit in hdcp tx if downstream is a repeater else
+ *		reset the bit
+ *
+ * @present	indicates whether downstream is repeater or not
+ *
+ * Returns:	true on succesful write else false
+ */
+bool mofd_hdcp_set_repeater(bool present)
+{
+	struct mofd_hdcp_repeater_reg_t repeater;
+	repeater.value = REG_READ(HDCP_REP);
+	repeater.present = present;
+	REG_WRITE(HDCP_REP, repeater.value);
+	/* delay for hardware change of repeater status */
+	usleep_range(1000, 1500);
+	return true;
+}
+
+/**
+ * Description: set downstream bksv in hdcp tx
+ *
+ * @bksv	bksv from downstream device
+ *
+ * Returns:	true on succesful write else false
+ */
+bool mofd_hdcp_set_bksv(uint8_t *bksv)
+{
+	uint8_t i = 0;
+	struct double_word_t temp;
+	if (bksv == NULL)
+		return false;
+	temp.value = 0;
+	for (i = 0; i < HDCP_KSV_SIZE; i++)
+		temp.byte[i] = bksv[i];
+
+	REG_WRITE(HDCP_BKSV_LO, temp.low);
+	REG_WRITE(HDCP_BKSV_HI, temp.high);
+	return true;
+}
+
+/**
+ * Description: start first stage of authentication by writing an aksv
+ *
+ * Returns:	true on succesfully starting authentication else false
+ */
+bool mofd_hdcp_start_authentication(void)
+{
+	hdcp_enable_port(true);
+	hdcp_set_config(HDCP_AUTHENTICATE_AND_ENCRYPT);
+	return true;
+}
+
+/**
+ * Description: read aksv from hdcp tx
+ *
+ * @aksv	buffer to return aksv
+ *
+ * Returns:	true on succesful read else false
+ */
+bool mofd_hdcp_get_aksv(uint8_t *aksv, int size)
+{
+	int i = 0;
+	struct double_word_t temp;
+	static uint8_t save_aksv[HDCP_KSV_SIZE] = {0, 0, 0, 0, 0};
+	static bool aksv_read_once;
+
+	if (aksv == 0 || size != HDCP_KSV_SIZE)
+		return false;
+
+	if (aksv_read_once == false) {
+		temp.value = 0;
+		temp.low = REG_READ(HDCP_ASKV_LO);
+		temp.high = REG_READ(HDCP_AKSV_HI);
+		aksv_read_once = true;
+		for (i = 0; i < HDCP_KSV_SIZE; i++)
+			save_aksv[i] = temp.byte[i];
+	}
+	for (i = 0; i < HDCP_KSV_SIZE; i++)
+		aksv[i] = save_aksv[i];
+	return true;
+}
diff --git a/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp_reg.h b/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp_reg.h
new file mode 100644
index 0000000..663efac
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdcp_reg.h
@@ -0,0 +1,167 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2011 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  Contact Information:
+
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  95054
+
+  BSD LICENSE
+
+  Copyright(c) 2011 Intel Corporation. All rights reserved.
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef MOFD_HDCP_REG_H_
+#define MOFD_HDCP_REG_H_
+
+#define HDCP_CONVERT_ENDIANNESS(x)	(((x&0x000000ff)<<24)|\
+					((x&0x0000ff00)<<8)|\
+					((x&0x00ff0000)>>8)|\
+					((x&0xff000000)>>24))
+
+struct double_word_t {
+	union {
+		uint64_t value;
+		struct {
+			uint32_t low;
+			uint32_t high;
+		};
+		struct {
+			uint8_t byte[8];
+		};
+	};
+};
+
+struct sqword_t {
+	union {
+		unsigned long long quad_part;
+		struct {
+			unsigned long low_part;
+			unsigned long high_part;
+		} u;
+		struct {
+			uint8_t byte[8];
+		};
+	};
+};
+
+enum mofd_hdcp_config_enum {
+	HDCP_Off = 0,
+	HDCP_CAPTURE_AN = 1,
+	HDCP_DECRYPT_KEYS = 2,
+	HDCP_AUTHENTICATE_AND_ENCRYPT = 3,
+	HDCP_PULL_FUSE = 4,
+	HDCP_UNIQUE_MCH_ID = 5,
+	HDCP_ENCRYPT_KEYS = 6,
+	HDCP_CYPHER_CHECK_MODE = 7,
+	HDCP_FUSE_PULL_ENABLE = 0x20
+};
+
+struct mofd_hdcp_config_reg_t {
+		union {
+		uint32_t value;
+		struct {
+			uint32_t hdcp_config:3;
+			uint32_t reserved:29;
+		};
+	};
+};
+
+struct mofd_hdcp_status_reg_t {
+	union {
+		uint32_t value;
+		struct {
+			uint32_t ainfo:8;
+			uint32_t frame_count:8;
+			uint32_t hdcp_on:1;
+			uint32_t an_ready:1;
+			uint32_t ri_ready:1;
+			uint32_t ri_match:1;
+			uint32_t encrypting:1;
+			uint32_t ready_for_encr:1;
+			uint32_t umch_id_ready:1;
+			uint32_t mac_status:1;
+			uint32_t fus_complete:1;
+			uint32_t fus_success:1;
+			uint32_t reserved:6;
+		};
+	};
+};
+
+/* Repeater Control register */
+enum mofd_hdcp_repeater_status_enum {
+	HDCP_REPEATER_STATUS_IDLE = 0,
+	HDCP_REPEATER_STATUS_BUSY = 1,
+	HDCP_REPEATER_STATUS_RDY_NEXT_DATA = 2,
+	HDCP_REPEATER_STATUS_COMPLETE_NO_MATCH = 4,
+	HDCP_REPEATER_STATUS_COMPLETE_MATCH = 12
+};
+
+enum mofd_hdcp_repeater_ctrl_enum {
+	HDCP_REPEATER_CTRL_IDLE = 0,
+	HDCP_REPEATER_32BIT_TEXT_IP = 1,
+	HDCP_REPEATER_COMPLETE_SHA1 = 2,
+	HDCP_REPEATER_24BIT_TEXT_8BIT_MO_IP = 4,
+	HDCP_REPEATER_16BIT_TEXT_16BIT_MO_IP = 5,
+	HDCP_REPEATER_8BIT_TEXT_24BIT_MO_IP = 6,
+	HDCP_REPEATER_32BIT_MO_IP = 7
+};
+
+struct mofd_hdcp_repeater_reg_t {
+	union {
+		uint32_t value;
+		struct {
+			uint32_t present:1;
+			uint32_t control:3;
+			uint32_t reserved1:12;
+			const uint32_t status:4;
+			uint32_t reserved2:12;
+		};
+	};
+};
+
+#endif /* MOFD_HDCP_REG_H_ */
diff --git a/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdmi.c b/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdmi.c
new file mode 100644
index 0000000..cf42dcc
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/hdmi/platforms/mofd_hdmi.c
@@ -0,0 +1,171 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#include <linux/gpio.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel-mid.h>
+#include "../hdmi_pipe.h"
+
+#define MSIC_PCI_DEVICE_ID 0x11A6
+
+#define MSIC_HPD_GPIO_PIN 16
+#define MSIC_LS_EN_GPIO_PIN 177
+
+#define CLOCK_MIN 25174
+#define CLOCK_MAX 148500
+
+static void gpio_configure_edid_read(struct hdmi_platform_config *config);
+
+int get_gpio_pin(struct hdmi_platform_config *config)
+{
+	int err = 0;
+
+	config->gpio_hpd_pin = get_gpio_by_name(MSIC_HPD_GPIO_PIN_NAME);
+	if (config->gpio_hpd_pin == -1) {
+		config->gpio_hpd_pin = MSIC_HPD_GPIO_PIN;
+		pr_debug("get_gpio_by_name failed! Use default pin %d\n",
+			MSIC_HPD_GPIO_PIN);
+	}
+
+	if (INTEL_MID_BOARD(2, PHONE, MOFD, MP, PRO) ||
+		INTEL_MID_BOARD(2, PHONE, MOFD, MP, ENG)) {
+		/* VV board uses GPIO pin 192 for Level shifter HDMI_LS_EN */
+		config->gpio_ls_en_pin =
+				get_gpio_by_name(MSIC_LS_EN_GPIO_PIN_NAME);
+		if (config->gpio_ls_en_pin == -1) {
+			config->gpio_ls_en_pin = MSIC_LS_EN_GPIO_PIN;
+			pr_debug("get_gpio_by_name failed!Use default pin %d\n",
+					MSIC_LS_EN_GPIO_PIN);
+		}
+	} else {
+		/* PRh uses GPIO pin 177 for Level shifter HDMI_LS_EN */
+		config->gpio_ls_en_pin = MSIC_LS_EN_GPIO_PIN;
+	}
+
+	if (gpio_request(config->gpio_ls_en_pin, "HDMI_LS_EN")) {
+		pr_err("%s: Unable to request gpio %d\n", __func__,
+		       config->gpio_ls_en_pin);
+		err = -EIO;
+		goto out_err0;
+	}
+
+	if (!gpio_is_valid(config->gpio_ls_en_pin)) {
+		pr_err("%s: Unable to validate gpio %d\n", __func__,
+		       config->gpio_ls_en_pin);
+		err = -EIO;
+		gpio_free(config->gpio_ls_en_pin);
+		goto out_err0;
+	}
+
+	if (gpio_request(config->gpio_hpd_pin, "hdmi_hpd")) {
+		pr_err("%s: Unable to request gpio %d\n", __func__,
+			config->gpio_hpd_pin);
+		err = -EIO;
+		goto out_err0;
+	}
+
+	if (gpio_direction_input(config->gpio_hpd_pin)) {
+		pr_err("%s: Unable to set gpio %d as input\n", __func__,
+		config->gpio_hpd_pin);
+		err = -EIO;
+		gpio_free(config->gpio_hpd_pin);
+		goto out_err0;
+	}
+
+	config->irq_number = gpio_to_irq(config->gpio_hpd_pin);
+	pr_err("%s: IRQ number assigned = %d for HDMI HPD device\n",
+		__func__, config->irq_number);
+out_err0:
+	return err;
+}
+
+int mofd_get_platform_configs(struct hdmi_platform_config *config)
+{
+	int res = 0;
+	res = get_gpio_pin(config);
+	if (res)
+		goto out_err;
+
+	config->last_pin_value = -1;
+	config->pci_device_id = MSIC_PCI_DEVICE_ID;
+	config->min_clock = CLOCK_MIN;
+	config->max_clock = CLOCK_MAX;
+out_err:
+	return res;
+}
+
+bool mofd_hdmi_get_cable_status(struct hdmi_platform_config *config)
+{
+	if (config == NULL)
+		return false;
+
+	/* Read HDMI cable status from GPIO */
+	/* For Moorefield, it is required that SW pull up or pull down the
+	 * LS_OE GPIO pin based on cable status. This is needed before
+	 * performing any EDID read operation on Moorefield.
+	 */
+	gpio_configure_edid_read(config);
+
+	if (gpio_get_value(config->gpio_hpd_pin) == 0)
+		return  false;
+	else
+		return  true;
+}
+
+static void gpio_configure_edid_read(struct hdmi_platform_config *config)
+{
+	int current_pin_value;
+
+	/* TODO: err handling here */
+	if (config == NULL)
+		return;
+
+	current_pin_value = gpio_get_value(config->gpio_hpd_pin);
+	if (current_pin_value == config->last_pin_value)
+		return;
+
+	config->last_pin_value = current_pin_value;
+
+	if (current_pin_value == 0)
+		gpio_set_value(config->gpio_ls_en_pin, 0);
+	else
+		gpio_set_value(config->gpio_ls_en_pin, 1);
+
+	pr_debug("%s: MSIC_LS_OE pin = %d (%d)\n", __func__,
+		 gpio_get_value(config->gpio_ls_en_pin), current_pin_value);
+}
+
+
+bool mofd_hdmi_enable_hpd(bool enable)
+{
+	u8 pin = 0;
+
+	/* see ShadyCove PMIC spec and board schema */
+	if (INTEL_MID_BOARD(2, PHONE, MOFD, MP, PRO) ||
+		INTEL_MID_BOARD(2, PHONE, MOFD, MP, ENG)) {
+		/* VV board uses GPIO1 for CT_CP_HPD */
+		pin = 0x7f;
+	} else {
+		/* PRx uses GPIO0 for CT_CP_HPD */
+		pin = 0x7e;
+	}
+
+	if (enable)
+		intel_scu_ipc_iowrite8(pin, 0x31);
+	else
+		intel_scu_ipc_iowrite8(pin, 0x30);
+	return true;
+}
diff --git a/drivers/video/adf/intel/core/intel_dc_config.c b/drivers/video/adf/intel/core/intel_dc_config.c
new file mode 100644
index 0000000..61c8839
--- /dev/null
+++ b/drivers/video/adf/intel/core/intel_dc_config.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/pci.h>
+
+#include "core/intel_dc_config.h"
+
+struct intel_dc_config_entry {
+	const u32 id;
+	struct intel_dc_config * (*get_dc_config)(const struct pci_dev *pdev,
+		u32 id);
+	void (*destroy_dc_config)(struct intel_dc_config *config);
+};
+
+static const struct intel_dc_config_entry g_dc_configs[] = {
+};
+
+int intel_dc_component_init(struct intel_dc_component *component,
+	struct device *dev, u8 idx, const char *name)
+{
+	if (!component)
+		return -EINVAL;
+
+	component->dev = dev;
+	component->idx = idx;
+	component->name = name;
+
+	return 0;
+}
+
+void intel_dc_component_destroy(struct intel_dc_component *component)
+{
+	if (component)
+		memset(component, 0, sizeof(*component));
+}
+
+#define INTEL_DC_CHECK(dev, obj) ({	\
+	if (!obj) {	\
+		dev_err(dev, "%s: %s is missing\n", __func__, #obj);	\
+		return -EINVAL;		\
+	}	\
+})
+
+static int intel_plane_validate(const struct intel_plane *plane)
+{
+	INTEL_DC_CHECK(plane->base.dev, plane->caps);
+	INTEL_DC_CHECK(plane->base.dev, plane->ops);
+	INTEL_DC_CHECK(plane->base.dev, plane->ops->validate);
+	INTEL_DC_CHECK(plane->base.dev, plane->ops->flip);
+	INTEL_DC_CHECK(plane->base.dev, plane->ops->enable);
+	INTEL_DC_CHECK(plane->base.dev, plane->ops->disable);
+
+	return 0;
+}
+
+static int intel_pipe_validate(const struct intel_pipe *pipe)
+{
+	/*verify pipe type*/
+	if (pipe->type != INTEL_PIPE_DSI && pipe->type != INTEL_PIPE_HDMI) {
+		dev_err(pipe->base.dev, "%s: Invalid pipe type %d\n", __func__,
+			pipe->type);
+		return -EINVAL;
+	}
+
+	INTEL_DC_CHECK(pipe->base.dev, pipe->primary_plane);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->get_modelist);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->get_preferred_mode);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->dpms);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->modeset);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->get_screen_size);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->is_screen_connected);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->get_supported_events);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->set_event);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->get_events);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->is_screen_connected);
+	INTEL_DC_CHECK(pipe->base.dev, pipe->ops->get_vsync_counter);
+
+	return 0;
+}
+
+static int intel_dc_memory_validate(const struct intel_dc_memory *memory)
+{
+	if (!memory->total_pages) {
+		dev_err(memory->dev, "%s: Invalid total pages\n", __func__);
+		return -EINVAL;
+	}
+
+	if (memory->total_pages != memory->alloc_pages + memory->free_pages) {
+		dev_err(memory->dev, "%s: pages mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	INTEL_DC_CHECK(memory->dev, memory->ops);
+	INTEL_DC_CHECK(memory->dev, memory->ops->import);
+	INTEL_DC_CHECK(memory->dev, memory->ops->free);
+
+	return 0;
+}
+
+static int intel_dc_config_validate(const struct intel_dc_config *config)
+{
+	int err;
+	u8 i;
+
+	if (!config->planes || !config->n_planes) {
+		dev_err(config->dev, "%s: no planes found\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!config->pipes || !config->n_pipes) {
+		dev_err(config->dev, "%s: no pipes found\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!config->allowed_attachments || !config->n_allowed_attachments) {
+		dev_err(config->dev, "%s: no allowed attachments found\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	/*check integrity of all planes*/
+	for (i = 0; i < config->n_planes; i++) {
+		err = intel_plane_validate(config->planes[i]);
+		if (err) {
+			dev_err(config->dev, "%s: invalid plane %d\n",
+				__func__, i);
+			return -EINVAL;
+		}
+	}
+
+	/*check integrity of all pipes*/
+	for (i = 0; i < config->n_pipes; i++) {
+		err = intel_pipe_validate(config->pipes[i]);
+		if (err) {
+			dev_err(config->dev, "%s: invalid pipe %d\n",
+				__func__, i);
+			return -EINVAL;
+		}
+	}
+
+	/*check memory*/
+	INTEL_DC_CHECK(config->dev, config->memory);
+	err = intel_dc_memory_validate(config->memory);
+	if (err) {
+		dev_err(config->dev, "%s: invalid DC memory", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void intel_dc_config_add_plane(struct intel_dc_config *config,
+	struct intel_plane *plane, u8 idx)
+{
+	if (!config || !plane)
+		return;
+
+	if (config->planes[idx])
+		return;
+
+	config->planes[idx] = plane;
+	config->n_planes++;
+}
+
+void intel_dc_config_add_pipe(struct intel_dc_config *config,
+	struct intel_pipe *pipe, u8 idx)
+{
+	if (!config || !pipe)
+		return;
+
+	if (config->pipes[idx])
+		return;
+
+	config->pipes[idx] = pipe;
+	config->n_pipes++;
+}
+
+int intel_dc_config_init(struct intel_dc_config *config, struct device *dev,
+	u32 id, size_t n_planes, size_t n_pipes,
+	const struct intel_dc_attachment *allowed_attachments,
+	size_t n_allowed_attachments)
+{
+	struct intel_plane **planes;
+	struct intel_pipe **pipes;
+	int err;
+
+	if (!config || !dev || !n_planes || !n_pipes || !allowed_attachments ||
+		!n_allowed_attachments)
+		return -EINVAL;
+
+	if (n_planes > INTEL_DC_MAX_PLANE_COUNT)
+		return -EINVAL;
+
+	if (n_pipes > INTEL_DC_MAX_PIPE_COUNT)
+		return -EINVAL;
+
+	memset(config, 0, sizeof(*config));
+
+	planes = kzalloc(n_planes * sizeof(*planes), GFP_KERNEL);
+	if (!planes)
+		return -ENOMEM;
+
+	pipes = kzalloc(n_pipes * sizeof(*pipes), GFP_KERNEL);
+	if (!pipes) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	config->dev = dev;
+	config->id = id;
+	config->planes = planes;
+	config->n_planes = 0;
+	config->pipes = pipes;
+	config->n_pipes = 0;
+	config->allowed_attachments = allowed_attachments;
+	config->n_allowed_attachments = n_allowed_attachments;
+	return 0;
+err:
+	kfree(planes);
+	return err;
+}
+
+void intel_dc_config_destroy(struct intel_dc_config *config)
+{
+	if (config) {
+		config->dev = NULL;
+		kfree(config->planes);
+		kfree(config->pipes);
+		memset(config, 0, sizeof(*config));
+	}
+}
+
+struct intel_dc_config *intel_adf_get_dc_config(struct pci_dev *pdev, u32 id)
+{
+	struct intel_dc_config *config = NULL;
+	int err;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(g_dc_configs); i++) {
+		if (g_dc_configs[i].id != id)
+			continue;
+		if (g_dc_configs[i].get_dc_config) {
+			config = g_dc_configs[i].get_dc_config(pdev, id);
+			break;
+		}
+	}
+
+	if (!config)
+		return ERR_PTR(-EINVAL);
+
+	/*validate this config*/
+	err = intel_dc_config_validate(config);
+	if (err)
+		return ERR_PTR(err);
+
+	return config;
+}
+
+void intel_adf_destroy_config(struct intel_dc_config *config)
+{
+	u32 id;
+	int i;
+
+	if (config) {
+		id = config->id;
+		for (i = 0; i < ARRAY_SIZE(g_dc_configs); i++) {
+			if (g_dc_configs[i].id == id &&
+				g_dc_configs[i].destroy_dc_config) {
+				g_dc_configs[i].destroy_dc_config(config);
+				break;
+			}
+		}
+	}
+}
diff --git a/drivers/video/adf/intel/core/intel_dc_memory.c b/drivers/video/adf/intel/core/intel_dc_memory.c
new file mode 100644
index 0000000..87fc61f
--- /dev/null
+++ b/drivers/video/adf/intel/core/intel_dc_memory.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/rwlock.h>
+#include <linux/slab.h>
+
+#include "core/intel_dc_config.h"
+
+struct intel_dc_buffer *intel_dc_memory_import(struct intel_dc_memory *mem,
+	u32 handle, struct page **pages, size_t n_pages)
+{
+	struct intel_dc_buffer *buf;
+	u32 addr = 0;
+	size_t i;
+	int err;
+
+	if (!mem || !mem->ops || !pages || !n_pages)
+		return ERR_PTR(-EINVAL);
+
+	if (!mem->ops->import || !mem->ops->free)
+		return ERR_PTR(-EOPNOTSUPP);
+
+	err = mem->ops->import(mem, handle, pages, n_pages, &addr);
+	if (err) {
+		dev_err(mem->dev, "%s: failed to import pages\n", __func__);
+		goto out_err0;
+	}
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf) {
+		dev_err(mem->dev, "%s: failed to allocate buffer\n", __func__);
+		err = -ENOMEM;
+		goto out_err1;
+	}
+
+	buf->handle = handle;
+	buf->dc_mem_addr = addr;
+	buf->pages = pages;
+	buf->n_pages = n_pages;
+	INIT_LIST_HEAD(&buf->list);
+
+	for (i = 0; i < n_pages; i++)
+		get_page(pages[i]);
+
+	write_lock(&mem->lock);
+
+	mem->alloc_pages += n_pages;
+	mem->free_pages -= n_pages;
+	list_add_tail(&buf->list, &mem->buf_list);
+	mem->n_bufs++;
+
+	write_unlock(&mem->lock);
+
+	return buf;
+out_err1:
+	mem->ops->free(mem, handle);
+out_err0:
+	return ERR_PTR(err);
+}
+
+void intel_dc_memory_free(struct intel_dc_memory *mem,
+	struct intel_dc_buffer *buf)
+{
+	size_t i;
+
+	if (!mem || !buf)
+		return;
+
+	if (!mem->ops || !mem->ops->free)
+		return;
+
+	mem->ops->free(mem, buf->handle);
+
+	for (i = 0; i < buf->n_pages; i++)
+		put_page(buf->pages[i]);
+
+	kfree(buf->pages);
+
+	write_lock(&mem->lock);
+
+	mem->alloc_pages -= buf->n_pages;
+	mem->free_pages += buf->n_pages;
+	list_del(&buf->list);
+	mem->n_bufs--;
+
+	write_unlock(&mem->lock);
+
+	kfree(buf);
+}
+
+int intel_dc_memory_status(struct intel_dc_memory *mem, size_t *n_total,
+	size_t *n_alloc, size_t *n_free, size_t *n_bufs)
+{
+	if (!mem || !n_total || !n_alloc || !n_free || !n_bufs)
+		return -EINVAL;
+
+	read_lock(&mem->lock);
+
+	*n_total = mem->total_pages;
+	*n_alloc = mem->alloc_pages;
+	*n_free = mem->free_pages;
+	*n_bufs = mem->n_bufs;
+
+	read_unlock(&mem->lock);
+	return 0;
+}
+
+int intel_dc_memory_init(struct intel_dc_memory *mem, struct device *dev,
+	size_t total_pages, const struct intel_dc_memory_ops *ops)
+{
+	if (!mem || !dev || !total_pages)
+		return -EINVAL;
+
+	memset(mem, 0, sizeof(*mem));
+
+	mem->dev = dev;
+	mem->total_pages = total_pages;
+	mem->free_pages = total_pages;
+	mem->ops = ops;
+	INIT_LIST_HEAD(&mem->buf_list);
+	rwlock_init(&mem->lock);
+
+	return 0;
+}
+
+void intel_dc_memory_destroy(struct intel_dc_memory *mem)
+{
+	struct intel_dc_buffer *buf, *tmp;
+
+	if (!mem || !mem->ops)
+		return;
+
+	write_lock(&mem->lock);
+
+	if (!list_empty(&mem->buf_list)) {
+		list_for_each_entry_safe(buf, tmp, &mem->buf_list, list) {
+			if (mem->ops->free)
+				mem->ops->free(mem, buf->handle);
+			/*free buffer*/
+			kfree(buf);
+			list_del(&buf->list);
+		}
+		mem->total_pages = 0;
+		mem->alloc_pages = 0;
+		mem->free_pages = 0;
+		mem->n_bufs = 0;
+		INIT_LIST_HEAD(&mem->buf_list);
+	}
+
+	write_unlock(&mem->lock);
+}
+
+
+
diff --git a/drivers/video/adf/intel/core/intel_dc_power.c b/drivers/video/adf/intel/core/intel_dc_power.c
new file mode 100644
index 0000000..a6482eb
--- /dev/null
+++ b/drivers/video/adf/intel/core/intel_dc_power.c
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "core/intel_dc_config.h"
+
+int intel_dc_power_init(struct intel_dc_power *power, struct device *dev,
+	const struct intel_dc_config *config,
+	const struct intel_dc_power_ops *ops)
+{
+	if (!power || !dev || !ops)
+		return -EINVAL;
+
+	memset(power, 0, sizeof(*power));
+
+	power->dev = dev;
+	power->config = config;
+	power->ops = ops;
+
+	return 0;
+}
+
+void intel_dc_power_destroy(struct intel_dc_power *power)
+{
+	if (power) {
+		power->dev = NULL;
+		power->config = NULL;
+		power->ops = NULL;
+	}
+}
+
+void intel_dc_power_suspend(struct intel_dc_power *power)
+{
+	if (power && power->ops && power->ops->suspend)
+		power->ops->suspend(power);
+}
+
+void intel_dc_power_resume(struct intel_dc_power *power)
+{
+	if (power && power->ops && power->ops->resume)
+		power->ops->resume(power);
+}
diff --git a/drivers/video/adf/intel/core/intel_pipe.c b/drivers/video/adf/intel/core/intel_pipe.c
new file mode 100644
index 0000000..ffb3057
--- /dev/null
+++ b/drivers/video/adf/intel/core/intel_pipe.c
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "core/intel_dc_config.h"
+
+int intel_pipe_init(struct intel_pipe *pipe, struct device *dev,
+	u8 idx, bool primary, enum intel_pipe_type type,
+	const struct intel_plane *primary_plane,
+	const struct intel_pipe_ops *ops, const char *name)
+{
+	if (!pipe || !primary_plane || !ops)
+		return -EINVAL;
+
+	pipe->primary = primary;
+	pipe->type = type;
+	pipe->primary_plane = primary_plane;
+	pipe->ops = ops;
+
+	return intel_dc_component_init(&pipe->base, dev, idx, name);
+}
+
+void intel_pipe_destroy(struct intel_pipe *pipe)
+{
+	if (pipe) {
+		intel_dc_component_destroy(&pipe->base);
+		memset(pipe, 0, sizeof(*pipe));
+	}
+}
+
+int intel_pipe_hw_init(const struct intel_pipe *pipe)
+{
+	return 0;
+}
diff --git a/drivers/video/adf/intel/core/intel_plane.c b/drivers/video/adf/intel/core/intel_plane.c
new file mode 100644
index 0000000..be457a1
--- /dev/null
+++ b/drivers/video/adf/intel/core/intel_plane.c
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "core/intel_dc_config.h"
+
+int intel_adf_plane_init(struct intel_plane *plane, struct device *dev,
+	u8 idx, const struct intel_plane_capabilities *caps,
+	const struct intel_plane_ops *ops, const char *name)
+{
+	if (!plane || !caps || !ops)
+		return -EINVAL;
+
+	plane->caps = caps;
+	plane->ops = ops;
+
+	return intel_dc_component_init(&plane->base, dev, idx, name);
+}
+
+
+void intel_plane_destroy(struct intel_plane *plane)
+{
+	if (plane) {
+		intel_dc_component_destroy(&plane->base);
+		plane->caps = NULL;
+		plane->ops = NULL;
+	}
+}
+
diff --git a/drivers/video/adf/intel/include/core/common/backlight_dev.h b/drivers/video/adf/intel/include/core/common/backlight_dev.h
new file mode 100644
index 0000000..d43ffbb
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/backlight_dev.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef BACKLIGHT_DEV_H_
+#define BACKLIGHT_DEV_H_
+
+#include <linux/backlight.h>
+
+#define BRIGHTNESS_MIN_LEVEL 1
+#define BRIGHTNESS_INIT_LEVEL 50
+#define BRIGHTNESS_MAX_LEVEL 100
+
+struct intel_adf_context;
+
+int backlight_init(struct intel_adf_context *adf_ctx);
+extern void backlight_exit(struct backlight_device *bl_dev);
+
+#endif /* BACKLIGHT_DEV_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dc_mm.h b/drivers/video/adf/intel/include/core/common/dc_mm.h
new file mode 100644
index 0000000..3bb926e
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/dc_mm.h
@@ -0,0 +1,62 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef DC_MM_H_
+#define DC_MM_H_
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <drm/drm_mm.h>
+#include <drm/drm_hashtab.h>
+
+struct dc_mm;
+
+typedef void (*page_table_insert_t)(struct dc_mm *mm, u32 offset_pages,
+	struct page **pages, size_t n_pages);
+
+struct dc_mm {
+	struct drm_mm base;
+	struct drm_open_hash ht;
+	size_t n_entries;
+	page_table_insert_t insert;
+	struct page *blank_page;
+	struct mutex lock;
+};
+
+struct dc_mm_per_thread_entry {
+	struct kref ref;
+	struct drm_open_hash ht;
+	size_t n_entries;
+	struct drm_hash_item item;
+	struct drm_open_hash *parent;
+};
+
+struct dc_mm_buffer_mem_mapping {
+	struct kref ref;
+	struct drm_mm_node *node;
+	struct drm_hash_item item;
+	struct drm_open_hash *parent;
+};
+
+extern int dc_mm_buffer_import(struct dc_mm *mm, u32 handle,
+	struct page **pages, size_t n_pages, u32 *addr);
+extern void dc_mm_buffer_free(struct dc_mm *mm, u32 handle);
+extern int dc_mm_init(struct dc_mm *mm, u32 start, size_t n_pages,
+	page_table_insert_t insert_func);
+extern void dc_mm_destroy(struct dc_mm *mm);
+
+#endif /* DC_MM_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_config.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_config.h
new file mode 100644
index 0000000..05289c4
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_config.h
@@ -0,0 +1,319 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef DSI_CONFIG_H_
+#define DSI_CONFIG_H_
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+
+#include <video/adf.h>
+#include "core/common/intel_dc_regs.h"
+
+/*DSI data lane configuration*/
+enum {
+	DSI_DATA_LANE_4_0 = 0,
+	DSI_DATA_LANE_3_1 = 1,
+	DSI_DATA_LANE_2_2 = 2,
+};
+
+enum {
+	RESET_FROM_BOOT_UP = 0,
+	RESET_FROM_OSPM_RESUME,
+};
+
+enum {
+	DSI_VIDEO_NON_BURST_MODE_SYNC_PULSE = 1,
+	DSI_VIDEO_NON_BURST_MODE_SYNC_EVENTS = 2,
+	DSI_VIDEO_BURST_MODE = 3,
+};
+
+typedef enum {
+	DSI_DBI = 0,
+	DSI_DPI,
+} dsi_type_t;
+
+
+enum {
+	DSI_PANEL_SINGLE_LINK = 0,
+	DSI_PANEL_DUAL_LINK = 1,
+	DSI_PANEL_DUAL_PANEL = 2,
+};
+
+#define NO_GAMMA_CSC			0x0
+#define ENABLE_GAMMA			(0x1 << 0)
+#define ENABLE_CSC			(0x1 << 1)
+#define ENABLE_GAMMA_CSC		(ENABLE_GAMMA | ENABLE_CSC)
+
+struct dsi_registers {
+	u32 vgacntr_reg;
+
+	/*plane*/
+	u32 dspcntr_reg;
+	u32 dspsize_reg;
+	u32 dspsurf_reg;
+	u32 dsplinoff_reg;
+	u32 dsppos_reg;
+	u32 dspstride_reg;
+
+	/*Drain Latency*/
+	u32 ddl1_reg;
+	u32 ddl2_reg;
+	u32 ddl3_reg;
+	u32 ddl4_reg;
+
+	/*overlay*/
+	u32 ovaadd_reg;
+	u32 ovcadd_reg;
+
+	/* csc */
+	u32 color_coef_reg;
+
+	/*pipe regs*/
+	u32 htotal_reg;
+	u32 hblank_reg;
+	u32 hsync_reg;
+	u32 vtotal_reg;
+	u32 vblank_reg;
+	u32 vsync_reg;
+	u32 pipestat_reg;
+	u32 pipesrc_reg;
+	u32 pipeframehigh_reg;
+	u32 pipeframepixel_reg;
+
+	u32 dpll_reg;
+	u32 pipeconf_reg;
+	u32 palette_reg;
+	u32 gamma_red_max_reg;
+	u32 gamma_green_max_reg;
+	u32 gamma_blue_max_reg;
+
+	/*mipi port*/
+	u32 mipi_reg;
+
+	/*DSI controller regs*/
+	u32 device_ready_reg;
+	u32 intr_stat_reg;
+	u32 intr_en_reg;
+	u32 dsi_func_prg_reg;
+	u32 hs_tx_timeout_reg;
+	u32 lp_rx_timeout_reg;
+	u32 turn_around_timeout_reg;
+	u32 device_reset_timer_reg;
+	u32 dpi_resolution_reg;
+	u32 hsync_count_reg;
+	u32 hbp_count_reg;
+	u32 hfp_count_reg;
+	u32 hactive_count_reg;
+	u32 vsync_count_reg;
+	u32 vbp_count_reg;
+	u32 vfp_count_reg;
+	u32 high_low_switch_count_reg;
+	u32 dpi_control_reg;
+	u32 dpi_data_reg;
+	u32 init_count_reg;
+	u32 max_return_pack_size_reg;
+	u32 video_mode_format_reg;
+	u32 eot_disable_reg;
+	u32 lp_byteclk_reg;
+	u32 lp_gen_data_reg;
+	u32 hs_gen_data_reg;
+	u32 lp_gen_ctrl_reg;
+	u32 hs_gen_ctrl_reg;
+	u32 gen_fifo_stat_reg;
+	u32 hs_ls_dbi_enable_reg;
+	u32 dphy_param_reg;
+	u32 dbi_bw_ctrl_reg;
+	u32 clk_lane_switch_time_cnt_reg;
+
+	/*MIPI adapter regs*/
+	u32 mipi_control_reg;
+	u32 mipi_data_addr_reg;
+	u32 mipi_data_len_reg;
+	u32 mipi_cmd_addr_reg;
+	u32 mipi_cmd_len_reg;
+
+	/*dpst registers*/
+	u32 histogram_intr_ctrl_reg;
+	u32 histogram_logic_ctrl_reg;
+	u32 aimg_enhance_bin_reg;
+	u32 lvds_port_ctrl_reg;
+};
+
+
+struct dsi_context {
+	u32 vgacntr;
+
+	/*plane*/
+	u32 dspcntr;
+	u32 dspsize;
+	u32 dspsurf;
+	u32 dsppos;
+	u32 dspstride;
+	u32 dsplinoff;
+
+	/*plane*/
+	u32 sprite_dspcntr;
+	u32 sprite_dspsize;
+	u32 sprite_dspsurf;
+	u32 sprite_dsppos;
+	u32 sprite_dspstride;
+	u32 sprite_dsplinoff;
+
+	/*Drain Latency*/
+	u32 ddl1;
+	u32 ddl2;
+	u32 ddl3;
+	u32 ddl4;
+
+	/*overlay*/
+	u32 ovaadd;
+	u32 ovcadd;
+
+	/* gamma and csc */
+	u32 palette[256];
+	u32 color_coef[6];
+
+	/*pipe regs*/
+	u32 htotal;
+	u32 hblank;
+	u32 hsync;
+	u32 vtotal;
+	u32 vblank;
+	u32 vsync;
+	u32 pipestat;
+	u32 pipesrc;
+	u32 pipeframehigh;
+	u32 pipeframepixel;
+
+	u32 dpll;
+	u32 fp;
+	u32 pipeconf;
+
+	/*mipi port*/
+	u32 mipi;
+
+	/*DSI controller regs*/
+	u32 device_ready;
+	u32 intr_stat;
+	u32 intr_en;
+	u32 dsi_func_prg;
+	u32 hs_tx_timeout;
+	u32 lp_rx_timeout;
+	u32 turn_around_timeout;
+	u32 device_reset_timer;
+	u32 dpi_resolution;
+	u32 dbi_fifo_throttle;
+	u32 hsync_count;
+	u32 hbp_count;
+	u32 hfp_count;
+	u32 hactive_count;
+	u32 vsync_count;
+	u32 vbp_count;
+	u32 vfp_count;
+	u32 high_low_switch_count;
+	u32 dpi_control;
+	u32 dpi_data;
+	u32 init_count;
+	u32 max_return_pack_size;
+	u32 video_mode_format;
+	u32 eot_disable;
+	u32 lp_byteclk;
+	u32 lp_gen_data;
+	u32 hs_gen_data;
+	u32 lp_gen_ctrl;
+	u32 hs_gen_ctrl;
+	u32 gen_fifo_stat;
+	u32 hs_ls_dbi_enable;
+	u32 dphy_param;
+	u32 dbi_bw_ctrl;
+	u32 clk_lane_switch_time_cnt;
+
+	/*MIPI adapter regs*/
+	u32 mipi_control;
+	u32 mipi_data_addr;
+	u32 mipi_data_len;
+	u32 mipi_cmd_addr;
+	u32 mipi_cmd_len;
+
+	/*panel status*/
+	int panel_on;
+	int backlight_level;
+
+	u32 pll_bypass_mode;
+	u32 cck_div;
+	/*brightness*/
+	int lastbrightnesslevel;
+
+	/*dpst register values*/
+	u32 histogram_intr_ctrl;
+	u32 histogram_logic_ctrl;
+	u32 aimg_enhance_bin;
+	u32 lvds_port_ctrl;
+
+};
+
+struct dsi_config {
+	struct dsi_registers regs;
+	struct dsi_context ctx;
+	struct mutex ctx_lock;
+
+	struct drm_mode_modeinfo perferred_mode;
+
+	int pipe;
+	int changed;
+
+	int drv_ic_inited;
+
+	int bpp;
+	dsi_type_t type;
+	u8 lane_count;
+	u8 dual_link;
+
+	/*mipi data lane config*/
+	int lane_config;
+	/*Virtual channel number for this encoder*/
+	int channel_num;
+	/*video mode configure*/
+	int video_mode;
+	int enable_gamma_csc;
+	uint32_t s3d_format;
+
+	/*dsr*/
+	void *dsr;
+
+	/* SDO */
+	void *sdo;
+};
+
+static inline int is_dual_link(struct dsi_config *config)
+{
+	return config->dual_link == DSI_PANEL_DUAL_LINK;
+}
+
+static inline bool is_dual_panel(struct dsi_config *config)
+{
+	return config->dual_link == DSI_PANEL_DUAL_PANEL;
+}
+
+struct dsi_panel;
+
+extern int dsi_config_init(struct dsi_config *config,
+			struct dsi_panel *panel, u8 idx);
+extern void dsi_config_destroy(struct dsi_config *config);
+
+#endif /* DSI_CONFIG_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_dbi_dsr.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_dbi_dsr.h
new file mode 100644
index 0000000..f5ae7dc
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_dbi_dsr.h
@@ -0,0 +1,58 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#ifndef DSI_DBI_DSR_H_
+#define DSI_DBI_DSR_H_
+
+#include "dsi_pipe.h"
+
+enum {
+	DSR_INIT = 0,
+	DSR_EXITED,
+	DSR_ENTERED_LEVEL0,
+	DSR_ENTERED_LEVEL1,
+};
+
+/*protected by context_lock in dsi config*/
+struct dsi_dsr {
+	/*dsr reference count*/
+	int ref_count;
+
+	int free_count;
+
+	/*dsr enabled*/
+	int dsr_enabled;
+	/*dsr state*/
+	int dsr_state;
+	/*dsi config*/
+	void *config;
+
+	struct work_struct te_work;
+};
+
+int dsi_dsr_report_te(struct dsi_pipe *pipe);
+
+int dsi_dsr_forbid(struct dsi_pipe *pipe);
+int dsi_dsr_allow(struct dsi_pipe *pipe);
+int dsi_dsr_forbid_locked(struct dsi_pipe *pipe);
+int dsi_dsr_allow_locked(struct dsi_pipe *pipe);
+
+int dsi_dsr_init(struct dsi_pipe *pipe);
+void dsi_dsr_destroy(struct dsi_config *config);
+
+void dsi_dsr_enable(struct dsi_pipe *pipe);
+
+#endif /* DSI_DBI_DSR_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_dpi_sdo.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_dpi_sdo.h
new file mode 100644
index 0000000..b8f41a9
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_dpi_sdo.h
@@ -0,0 +1,56 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef DSI_DPI_SDO_H_
+#define DSI_DPI_SDO_H_
+
+#include "dsi_pipe.h"
+
+enum {
+	SDO_INIT = 0,
+	SDO_EXITED,
+	SDO_ENTERED_LEVEL0,
+};
+
+struct dsi_sdo {
+	/* SDO reference count */
+	int ref_count;
+
+	/* Check how many times of repeated frame to enter SDO */
+	int free_count;
+
+	int sdo_enabled;
+	int sdo_state;
+
+	/*dsi config*/
+	void *config;
+
+	struct work_struct repeated_frm_work;
+};
+
+int dsi_sdo_report_repeated_frame(struct dsi_pipe *pipe);
+
+int dsi_sdo_forbid(struct dsi_pipe *pipe);
+int dsi_sdo_allow(struct dsi_pipe *pipe);
+
+int dsi_sdo_init(struct dsi_pipe *pipe);
+void dsi_sdo_destroy(struct dsi_config *config);
+
+void dsi_sdo_enable(struct dsi_pipe *pipe);
+void dsi_sdo_disable(struct dsi_pipe *pipe);
+
+#endif /* DSI_DPI_SDO_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h
new file mode 100644
index 0000000..d4c9708
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h
@@ -0,0 +1,87 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+#ifndef DSI_PANEL_H_
+#define DSI_PANEL_H_
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <drm/drm_mode.h>
+#include <linux/panel_psb_drv.h>
+
+struct dsi_pipe;
+
+/*DSI panel connection status*/
+enum {
+	DSI_PANEL_CONNECTED = 0,
+	DSI_PANEL_DISCONNECTED,
+};
+
+struct panel_info {
+	/*panel physical size*/
+	u32 width_mm;
+	u32 height_mm;
+	/*DBI or DPI*/
+	u8 dsi_type;
+	/*number of data lanes*/
+	u8 lane_num;
+	/*bits per pixel*/
+	u8 bpp;
+	/*whether need dual link mode*/
+	u8 dual_link;
+};
+
+/**
+ *Panel specific operations.
+ *
+ *@get_config_mode: return the fixed display mode of panel.
+ *@update_fb: command mode panel only. update on-panel framebuffer.
+ *@get_panel_info: return panel information. such as physical size.
+ *@reset: panel hard reset.
+ *@drv_ic_init: initialize panel driver IC and additional HW initialization.
+ *@detect: return the panel physical connection status.
+ *@dsi_controller_init: Initialize MIPI IP for this panel.
+ *@power_on: turn on panel. e.g. send a TURN_ON special packet.
+ *@power_off: turn off panel. e.g. send a SHUT_DOWN special packet.
+ *
+ *When adding a new panel, the driver code should implement these callbacks
+ *according to corresponding panel specs. DPI and DBI implementation will
+ *call these callbacks to take the specific actions for the new panel.
+ */
+struct panel_ops {
+	int (*get_config_mode)(struct drm_mode_modeinfo *);
+	void (*dsi_controller_init)(struct dsi_pipe *intf);
+	void (*get_panel_info)(struct panel_info *);
+	int (*reset)(struct dsi_pipe *intf);
+	int (*exit_deep_standby)(struct dsi_pipe *intf);
+	int (*detect)(struct dsi_pipe *intf);
+	int (*power_on)(struct dsi_pipe *intf);
+	int (*power_off)(struct dsi_pipe *intf);
+	int (*set_brightness)(struct dsi_pipe *intf, int level);
+	int (*drv_ic_init)(struct dsi_pipe *intf);
+	int (*drv_set_panel_mode)(struct dsi_pipe *intf);
+};
+
+struct dsi_panel {
+	u8 panel_id;
+	struct panel_info info;
+	struct panel_ops *ops;
+};
+
+extern const struct dsi_panel *get_dsi_panel_by_id(u8 id);
+extern const struct dsi_panel *get_dsi_panel(void);
+
+#endif /* DSI_PANEL_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
new file mode 100644
index 0000000..0174194
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
@@ -0,0 +1,77 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef DSI_PIPE_H_
+#define DSI_PIPE_H_
+
+#include "core/intel_dc_config.h"
+#include "core/common/dsi/dsi_config.h"
+#include "core/common/dsi/dsi_pkg_sender.h"
+#include "core/common/dsi/dsi_panel.h"
+#include "pwr_mgmt.h"
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+#include "core/common/backlight_dev.h"
+#endif
+
+enum enum_ports {
+	PORT_A = 0,
+	PORT_C = 1
+};
+
+struct dsi_pipe;
+
+/**
+ * dsi_pipe_ops - required operations for a DSI pipe
+ * @power_on: [required]
+ * @power_off: [required]
+ * @mode_set: [required]
+ * @on_post: [optional]
+ * @vsync: [required]
+ */
+struct dsi_pipe_ops {
+	int (*power_on)(struct dsi_pipe *pipe);
+	int (*power_off)(struct dsi_pipe *pipe);
+	int (*mode_set)(struct dsi_pipe *pipe,
+		struct drm_mode_modeinfo *mode);
+	void (*pre_post)(struct dsi_pipe *pipe);
+	void (*on_post)(struct dsi_pipe *pipe);
+	int (*set_event)(struct dsi_pipe *pipe, u8 event, bool enabled);
+	void (*get_events)(struct dsi_pipe *pipe, u32 *events);
+	void (*handle_events)(struct dsi_pipe *pipe, u32 events);
+};
+
+struct dsi_pipe {
+	struct intel_pipe base;
+	struct dsi_pipe_ops ops;
+	struct dsi_config config;
+	struct dsi_pkg_sender sender;
+	struct dsi_panel *panel;
+};
+
+static inline struct dsi_pipe *to_dsi_pipe(struct intel_pipe *pipe)
+{
+	return container_of(pipe, struct dsi_pipe, base);
+}
+
+extern int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
+	struct intel_plane *primary_plane, u8 idx, u32 gtt_phy_addr);
+extern void dsi_pipe_destroy(struct dsi_pipe *pipe);
+
+extern bool dsi_pipe_enable_clocking(struct dsi_pipe *pipe);
+extern bool dsi_pipe_disable_clocking(struct dsi_pipe *pipe);
+
+#endif /* COMMON_DSI_PIPE_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_pkg_sender.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_pkg_sender.h
new file mode 100644
index 0000000..0bb6a85
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_pkg_sender.h
@@ -0,0 +1,230 @@
+/**************************************************************************
+ * Copyright (c) 2007, Intel Corporation.
+ * All Rights Reserved.
+ * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ **************************************************************************/
+
+#ifndef DSI_PKG_SENDER_H_
+#define DSI_PKG_SENDER_H_
+
+#include <linux/kthread.h>
+
+#if defined(CONFIG_ADF)
+#include "intel_adf_device.h"
+#endif
+#include "core/common/intel_dc_regs.h"
+#include "core/common/dsi/dsi_config.h"
+
+#define MAX_DCS_PARAM	8
+#define MAX_PKG_NUM	2048
+
+enum {
+	DSI_PKG_DCS,
+	DSI_DPI_SPK,
+	DSI_PKG_GEN_SHORT_WRITE_0 = 0x03,
+	DSI_PKG_GEN_SHORT_WRITE_1 = 0x13,
+	DSI_PKG_GEN_SHORT_WRITE_2 = 0x23,
+	DSI_PKG_GEN_READ_0 = 0x04,
+	DSI_PKG_GEN_READ_1 = 0x14,
+	DSI_PKG_GEN_READ_2 = 0x24,
+	DSI_PKG_GEN_LONG_WRITE = 0x29,
+	DSI_PKG_MCS_SHORT_WRITE_0 = 0x05,
+	DSI_PKG_MCS_SHORT_WRITE_1 = 0x15,
+	DSI_PKG_MCS_READ = 0x06,
+	DSI_PKG_MCS_LONG_WRITE = 0x39,
+};
+
+enum {
+	DSI_DPI_SPK_SHUT_DOWN = BIT0,
+	DSI_DPI_SPK_TURN_ON = BIT1,
+	DSI_DPI_SPK_COLOR_MODE_ON = BIT2,
+	DSI_DPI_SPK_COLOR_MODE_OFF = BIT3,
+	DSI_DPI_SPK_BACKLIGHT_ON = BIT4,
+	DSI_DPI_SPK_BACKLIGHT_OFF = BIT5,
+	DSI_DPI_SPK_RESET_TRIGGER = BIT6,
+};
+
+enum {
+	DSI_LP_TRANSMISSION,
+	DSI_HS_TRANSMISSION,
+	DSI_DCS,
+};
+
+enum {
+	DSI_PANEL_MODE_SLEEP = 0x1,
+};
+
+enum {
+	DSI_PKG_SENDER_FREE  = 0x0,
+	DSI_PKG_SENDER_BUSY  = 0x1,
+	DSI_CONTROL_ABNORMAL = 0x2,
+};
+
+enum {
+	DSI_SEND_PACKAGE,
+	DSI_QUEUE_PACKAGE,
+};
+
+#define CMD_MEM_ADDR_OFFSET	0
+
+#define CMD_DATA_SRC_SYSTEM_MEM		0
+#define CMD_DATA_SRC_PIPE		1
+
+struct dsi_gen_short_pkg {
+	u8 cmd;
+	u8 param;
+};
+
+struct dsi_gen_long_pkg {
+	u8 *data;
+	u32 len;
+};
+
+struct dsi_dcs_pkg {
+	u8 cmd;
+	u8 *param;
+	u32 param_num;
+	u8 data_src;
+};
+
+struct dsi_dpi_spk_pkg { u32 cmd; };
+
+struct dsi_pkg {
+	u8 pkg_type;
+	u8 transmission_type;
+
+	union {
+		struct dsi_gen_short_pkg short_pkg;
+		struct dsi_gen_long_pkg long_pkg;
+		struct dsi_dcs_pkg dcs_pkg;
+		struct dsi_dpi_spk_pkg spk_pkg;
+	} pkg;
+
+	struct list_head entry;
+};
+
+struct dsi_pkg_sender {
+	struct intel_adf_device *dev;
+	u32 status;
+
+	u32 panel_mode;
+
+	int pipe;
+	bool work_for_slave_panel;
+
+	struct mutex lock;
+	struct list_head pkg_list;
+	struct list_head free_list;
+
+	u32 pkg_num;
+
+	int dbi_pkg_support;
+
+	u32 dbi_cb_phy;
+	void *dbi_cb_addr;
+
+	atomic64_t te_seq;
+	atomic64_t last_screen_update;
+
+	/*registers*/
+	u32 dpll_reg;
+	u32 dspcntr_reg;
+	u32 pipeconf_reg;
+	u32 pipestat_reg;
+	u32 dsplinoff_reg;
+	u32 dspsurf_reg;
+
+	u32 mipi_intr_stat_reg;
+	u32 mipi_lp_gen_data_reg;
+	u32 mipi_hs_gen_data_reg;
+	u32 mipi_lp_gen_ctrl_reg;
+	u32 mipi_hs_gen_ctrl_reg;
+	u32 mipi_gen_fifo_stat_reg;
+	u32 mipi_data_addr_reg;
+	u32 mipi_data_len_reg;
+	u32 mipi_cmd_addr_reg;
+	u32 mipi_cmd_len_reg;
+	u32 mipi_dpi_control_reg;
+};
+
+extern int dsi_pkg_sender_init(struct dsi_pkg_sender *sender,
+	u32 gtt_phy_addr, int type, int pipe);
+extern void dsi_pkg_sender_destroy(struct dsi_pkg_sender *sender);
+extern int dsi_check_fifo_empty(struct dsi_pkg_sender *sender);
+extern int dsi_send_dcs(struct dsi_pkg_sender *sender,
+			u8 dcs, u8 *param, u32 param_num, u8 data_src,
+			int delay);
+extern int dsi_send_dual_dcs(struct dsi_pkg_sender *sender,
+			u8 dcs, u8 *param, u32 param_num, u8 data_src,
+			int delay, bool is_dual_link);
+extern int dsi_send_mcs_short_hs(struct dsi_pkg_sender *sender,
+					u8 cmd, u8 param, u8 param_num,
+					int delay);
+extern int dsi_send_mcs_short_lp(struct dsi_pkg_sender *sender,
+					u8 cmd, u8 param, u8 param_num,
+					int delay);
+extern int dsi_send_mcs_long_hs(struct dsi_pkg_sender *sender,
+					u8 *data,
+					u32 len,
+					int delay);
+extern int dsi_send_mcs_long_lp(struct dsi_pkg_sender *sender,
+					u8 *data,
+					u32 len,
+					int delay);
+extern int dsi_send_gen_short_hs(struct dsi_pkg_sender *sender,
+					u8 param0, u8 param1, u8 param_num,
+					int delay);
+extern int dsi_send_gen_short_lp(struct dsi_pkg_sender *sender,
+					u8 param0, u8 param1, u8 param_num,
+					int delay);
+extern int dsi_send_gen_long_hs(struct dsi_pkg_sender *sender,
+				u8 *data,
+				u32 len,
+				int delay);
+extern int dsi_send_gen_long_lp(struct dsi_pkg_sender *sender,
+				u8 *data,
+				u32 len,
+				int delay);
+extern int dsi_send_dpi_spk_pkg_hs(struct dsi_pkg_sender *sender,
+				u32 spk_pkg);
+extern int dsi_send_dpi_spk_pkg_lp(struct dsi_pkg_sender *sender,
+				u32 spk_pkg);
+extern int dsi_cmds_kick_out(struct dsi_pkg_sender *sender);
+extern void dsi_report_te(struct dsi_pkg_sender *sender);
+extern int dsi_status_check(struct dsi_pkg_sender *sender);
+
+/*read interfaces*/
+extern int dsi_read_gen_hs(struct dsi_pkg_sender *sender,
+			u8 param0,
+			u8 param1,
+			u8 param_num,
+			u8 *data,
+			u32 len);
+extern int dsi_read_gen_lp(struct dsi_pkg_sender *sender,
+			u8 param0,
+			u8 param1,
+			u8 param_num,
+			u8 *data,
+			u32 len);
+extern int dsi_read_mcs_hs(struct dsi_pkg_sender *sender,
+			u8 cmd,
+			u8 *data,
+			u32 len);
+extern int dsi_read_mcs_lp(struct dsi_pkg_sender *sender,
+			u8 cmd,
+			u8 *data,
+			u32 len);
+extern int dsi_wait_for_fifos_empty(struct dsi_pkg_sender *sender);
+
+#endif /* DSI_PKG_SENDER_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/intel_dc_regs.h b/drivers/video/adf/intel/include/core/common/intel_dc_regs.h
new file mode 100644
index 0000000..d971ca8
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/intel_dc_regs.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef INTEL_DC_REGS_H__
+#define INTEL_DC_REGS_H__
+
+#endif /* INTEL_DC_REGS_H__ */
diff --git a/drivers/video/adf/intel/include/core/common/overlay.h b/drivers/video/adf/intel/include/core/common/overlay.h
new file mode 100644
index 0000000..d3c4310
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/common/overlay.h
@@ -0,0 +1,133 @@
+/*
+ * overlay.h
+ *
+ *  Created on: Jul 9, 2014
+ *      Author: root
+ */
+
+#ifndef OVERLAY_H_
+#define OVERLAY_H_
+
+/*Polyphase filter coefficients*/
+#define N_HORIZ_Y_TAPS			5
+#define N_VERT_Y_TAPS			3
+#define N_HORIZ_UV_TAPS			3
+#define N_VERT_UV_TAPS			3
+#define N_PHASES			17
+#define MAX_TAPS			5
+
+/*Filter cutoff frequency limits*/
+#define MIN_CUTOFF_FREQ			1.0
+#define MAX_CUTOFF_FREQ			3.0
+
+/*Overlay init micros*/
+#define OVERLAY_INIT_CONTRAST		0x4b
+#define OVERLAY_INIT_BRIGHTNESS		-19
+#define OVERLAY_INIT_SATURATION		0x92
+#define OVERLAY_INIT_GAMMA0		0x080808
+#define OVERLAY_INIT_GAMMA1		0x101010
+#define OVERLAY_INIT_GAMMA2		0x202020
+#define OVERLAY_INIT_GAMMA3		0x404040
+#define OVERLAY_INIT_GAMMA4		0x808080
+#define OVERLAY_INIT_GAMMA5		0xc0c0c0
+#define OVERLAY_INIT_COLORKEY		0
+#define OVERLAY_INIT_COLORKEYMASK	((0x0 << 31) | (0X0 << 30))
+#define OVERLAY_INIT_CONFIG		((0x1 << 18) | (0x1 << 3))
+
+/*overlay register values*/
+#define OVERLAY_FORMAT_MASK		(0xf << 10)
+#define OVERLAY_FORMAT_PACKED_YUV422	(0x8 << 10)
+#define OVERLAY_FORMAT_PLANAR_NV12_1	(0x7 << 10)
+#define OVERLAY_FORMAT_PLANAR_NV12_2	(0xb << 10)
+#define OVERLAY_FORMAT_PLANAR_YUV420	(0xc << 10)
+#define OVERLAY_FORMAT_PLANAR_YUV422	(0xd << 10)
+#define OVERLAY_FORMAT_PLANAR_YUV41X	(0xe << 10)
+
+#define OVERLAY_PACKED_ORDER_YUYV	(0x0 << 14)
+#define OVERLAY_PACKED_ORDER_YVYU	(0x1 << 14)
+#define OVERLAY_PACKED_ORDER_UYVY	(0x2 << 14)
+#define OVERLAY_PACKED_ORDER_VYUY	(0x3 << 14)
+#define OVERLAY_PACKED_ORDER_MASK	(0x3 << 14)
+
+#define OVERLAY_MEMORY_LAYOUT_TILED	(0x1 << 19)
+#define OVERLAY_MEMORY_LAYOUT_LINEAR	(0x0 << 19)
+
+#define OVERLAY_MIRRORING_NORMAL	(0x0 << 17)
+#define OVERLAY_MIRRORING_HORIZONTAL	(0x1 << 17)
+#define OVERLAY_MIRRORING_VERTIACAL	(0x2 << 17)
+#define OVERLAY_MIRRORING_BOTH		(0x3 << 17)
+
+#define BUF_TYPE			(0x1<<5)
+#define BUF_TYPE_FRAME			(0x0<<5)
+#define BUF_TYPE_FIELD			(0x1<<5)
+#define TEST_MODE			(0x1<<4)
+#define BUFFER_SELECT			(0x3<<2)
+#define BUFFER0				(0x0<<2)
+#define BUFFER1				(0x1<<2)
+#define FIELD_SELECT			(0x1<<1)
+#define FIELD0				(0x0<<1)
+#define FIELD1				(0x1<<1)
+#define OVERLAY_ENABLE			0x1
+
+struct overlay_back_buffer {
+	u32 OBUF_0Y;
+	u32 OBUF_1Y;
+	u32 OBUF_0U;
+	u32 OBUF_0V;
+	u32 OBUF_1U;
+	u32 OBUF_1V;
+	u32 OSTRIDE;
+	u32 YRGB_VPH;
+	u32 UV_VPH;
+	u32 HORZ_PH;
+	u32 INIT_PHS;
+	u32 DWINPOS;
+	u32 DWINSZ;
+	u32 SWIDTH;
+	u32 SWIDTHSW;
+	u32 SHEIGHT;
+	u32 YRGBSCALE;
+	u32 UVSCALE;
+	u32 OCLRC0;
+	u32 OCLRC1;
+	u32 DCLRKV;
+	u32 DCLRKM;
+	u32 SCHRKVH;
+	u32 SCHRKVL;
+	u32 SCHRKEN;
+	u32 OCONFIG;
+	u32 OCMD;
+	u32 RESERVED1;
+	u32 OSTART_0Y;
+	u32 OSTART_1Y;
+	u32 OSTART_0U;
+	u32 OSTART_0V;
+	u32 OSTART_1U;
+	u32 OSTART_1V;
+	u32 OTILEOFF_0Y;
+	u32 OTILEOFF_1Y;
+	u32 OTILEOFF_0U;
+	u32 OTILEOFF_0V;
+	u32 OTILEOFF_1U;
+	u32 OTILEOFF_1V;
+	u32 FASTHSCALE;
+	u32 UVSCALEV;
+
+	u32 RESERVEDC[(0x200 - 0xA8) / 4];
+	u16 Y_VCOEFS[N_VERT_Y_TAPS * N_PHASES];
+	u16 RESERVEDD[0x100 / 2 - N_VERT_Y_TAPS * N_PHASES];
+	u16 Y_HCOEFS[N_HORIZ_Y_TAPS * N_PHASES];
+	u16 RESERVEDE[0x200 / 2 - N_HORIZ_Y_TAPS * N_PHASES];
+	u16 UV_VCOEFS[N_VERT_UV_TAPS * N_PHASES];
+	u16 RESERVEDF[0x100 / 2 - N_VERT_UV_TAPS * N_PHASES];
+	u16 UV_HCOEFS[N_HORIZ_UV_TAPS * N_PHASES];
+	u16 RESERVEDG[0x100 / 2 - N_HORIZ_UV_TAPS * N_PHASES];
+};
+
+typedef struct {
+	u8 sign;
+	u16 mantissa;
+	u8 exponent;
+} coeffRec, *coeffPtr;
+
+#endif /* OVERLAY_H_ */
diff --git a/drivers/video/adf/intel/include/core/intel_dc_config.h b/drivers/video/adf/intel/include/core/intel_dc_config.h
new file mode 100644
index 0000000..cc423dc
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/intel_dc_config.h
@@ -0,0 +1,345 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef INTEL_DC_CONFIG_H_
+#define INTEL_DC_CONFIG_H_
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#if defined(CONFIG_ADF)
+#include <video/adf.h>
+#endif
+
+#define INTEL_DC_MAX_PLANE_COUNT	0xff
+#define INTEL_DC_MAX_PIPE_COUNT		0xff
+
+struct intel_dc_component;
+struct intel_plane;
+struct intel_pipe;
+struct intel_dc_memory;
+
+enum intel_plane_blending {
+	INTEL_PLANE_BLENDING_NONE,
+	INTEL_PLANE_BLENDING_PREMULT,
+	INTEL_PLANE_BLENDING_COVERAGE,
+};
+
+enum intel_plane_scaling {
+	INTEL_PLANE_SCALING_DOWNSCALING,
+	INTEL_PLANE_SCALING_UPSCALING,
+};
+
+enum intel_plane_transform {
+	INTEL_PLANE_TRANSFORM_NONE,
+	INTEL_PLANE_TRANSFORM_FLIPH,
+	INTEL_PLANE_TRANSFORM_FLIPV,
+	INTEL_PLANE_TRANSFORM_ROT90,
+	INTEL_PLANE_TRANSFORM_ROT180,
+	INTEL_PLANE_TRANSFORM_ROT270,
+};
+
+enum intel_plane_compression {
+	INTEL_PLANE_DECOMPRESSION_16X4,
+};
+
+struct intel_plane_capabilities {
+	const u32 *supported_formats;
+	const size_t n_supported_formats;
+
+	const u32 *supported_blendings;
+	const size_t n_supported_blendings;
+
+	const u32 *supported_scalings;
+	const size_t n_supported_scalings;
+
+	const u32 *supported_transforms;
+	const size_t n_supported_transforms;
+
+	const u32 *supported_decompressions;
+	const size_t n_supported_decompressions;
+};
+
+struct intel_buffer {
+	u32 w;
+	u32 h;
+	u32 format;
+	u32 gtt_offset_in_pages;
+};
+
+struct intel_dc_buffer {
+	u32 handle;
+	u32 dc_mem_addr;
+	struct page **pages;
+	size_t n_pages;
+	struct list_head list;
+};
+
+struct intel_dc_memory_ops {
+	int (*import)(struct intel_dc_memory *mem, u32 handle,
+		struct page **pages, size_t n_pages, u32 *addr);
+	void (*free)(struct intel_dc_memory *mem, u32 handle);
+};
+
+struct intel_dc_memory {
+	struct device *dev;
+	size_t total_pages;
+	size_t alloc_pages;
+	size_t free_pages;
+	const struct intel_dc_memory_ops *ops;
+	struct list_head buf_list;
+	size_t n_bufs;
+	rwlock_t lock;
+};
+
+struct intel_dc_power {
+	struct device *dev;
+	const struct intel_dc_config *config;
+	const struct intel_dc_power_ops *ops;
+};
+
+struct intel_dc_power_ops {
+	void (*suspend)(struct intel_dc_power *power);
+	void (*resume)(struct intel_dc_power *power);
+};
+
+struct intel_plane_config {
+	s16 dst_x;
+	s16 dst_y;
+	u16 dst_w;
+	u16 dst_h;
+	s32 src_x;
+	s32 src_y;
+	u32 src_w;
+	u32 src_h;
+	u8 alpha;
+	enum intel_plane_compression compression:4;
+	enum intel_plane_blending blending:4;
+	enum intel_plane_transform transform:4;
+	struct intel_pipe *pipe;
+};
+
+struct intel_dc_component_ops {
+	void (*suspend)(struct intel_dc_component *component);
+	void (*resume)(struct intel_dc_component *component);
+};
+
+struct intel_dc_component {
+	struct device *dev;
+	u8 idx;
+	const char *name;
+};
+
+/**
+ * intel_plane_ops - plane operations.
+ * validate_custom_format: [optional]
+ * validate: [required]
+ * flip: [required]
+ * enable: [required]
+ * disable: [required]
+ */
+struct intel_plane_ops {
+	struct intel_dc_component_ops base;
+#if defined(CONFIG_ADF)
+	/*FIXME: Have to put adf overlay ops*/
+	const struct adf_overlay_engine_ops adf_ops;
+#endif
+	int (*validate_custom_format)(struct intel_plane *plane, u32 format,
+		u32 w, u32 h);
+	int (*validate)(struct intel_plane *plane,
+		struct intel_buffer *buf,
+		struct intel_plane_config *config);
+	void (*flip)(struct intel_plane *plane,
+		struct intel_buffer *buf,
+		struct intel_plane_config *config);
+	int (*enable)(struct intel_plane *plane);
+	int (*disable)(struct intel_plane *plane);
+};
+
+struct intel_plane {
+	struct intel_dc_component base;
+	const struct intel_plane_capabilities *caps;
+	const struct intel_plane_ops *ops;
+};
+
+enum intel_pipe_type {
+	INTEL_PIPE_DSI,
+	INTEL_PIPE_HDMI,
+};
+
+enum intel_pipe_event {
+	INTEL_PIPE_EVENT_UNKNOWN = 0x0,
+	INTEL_PIPE_EVENT_VSYNC = 0x01,
+	INTEL_PIPE_EVENT_HOTPLUG_CONNECTED = 0x2,
+	INTEL_PIPE_EVENT_HOTPLUG_DISCONNECTED = 0x4,
+	INTEL_PIPE_EVENT_AUDIO_BUFFERDONE = 0x8,
+	INTEL_PIPE_EVENT_AUDIO_UNDERRUN = 0x10,
+	INTEL_PIPE_EVENT_REPEATED_FRAME = 0x20,
+	/*TODO: add other known pipe events*/
+};
+
+/**
+ * struct intel_pipe_ops - Intel display controller pipe operations
+ *
+ * @hw_init: [optional]
+ * @hw_deinit: [optional]
+ * @get_modelist: [required]
+ * @get_preferred_mode: [required]
+ * @dpms: [required]
+ * @modeset: [required]
+ * @get_screen_size: [required]
+ * @is_screen_connected: [required]
+ * @get_supported_events: [required]
+ * @set_event: [required]
+ * @get_events: [required]
+ * @get_vsync_counter: [required]
+ * @handle_events: [optional]
+ */
+struct intel_pipe_ops {
+	struct intel_dc_component_ops base;
+	int (*hw_init)(struct intel_pipe *pipe);
+	void (*hw_deinit)(struct intel_pipe *pipe);
+
+	void (*get_modelist)(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **modelist, size_t *n_modes);
+	void (*get_preferred_mode)(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **mode);
+	int (*dpms)(struct intel_pipe *pipe, u8 state);
+	int (*modeset)(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo *mode);
+	int (*get_screen_size)(struct intel_pipe *pipe,
+		u16 *width_mm, u16 *height_mm);
+	bool (*is_screen_connected)(struct intel_pipe *pipe);
+
+	u32 (*get_supported_events)(struct intel_pipe *pipe);
+	int (*set_event)(struct intel_pipe *pipe, u8 event, bool enabled);
+	void (*get_events)(struct intel_pipe *pipe, u32 *active_events);
+	u32 (*get_vsync_counter)(struct intel_pipe *pipe, u32 interval);
+	void (*handle_events)(struct intel_pipe *pipe, u32 events);
+
+	void (*pre_post)(struct intel_pipe *pipe);
+	void (*on_post)(struct intel_pipe *pipe);
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+	int (*set_brightness)(struct intel_pipe *pipe, int level);
+#endif
+};
+
+struct intel_pipe {
+	struct intel_dc_component base;
+	bool primary;
+	enum intel_pipe_type type;
+	const struct intel_plane *primary_plane;
+	const struct intel_pipe_ops *ops;
+};
+
+struct intel_dc_attachment {
+	u8 plane_id;
+	u8 pipe_id;
+};
+
+struct intel_dc_config {
+	struct device *dev;
+
+	/*display controller unique ID*/
+	u32 id;
+
+	struct intel_plane **planes;
+	u8 n_planes;
+
+	struct intel_pipe **pipes;
+	u8 n_pipes;
+
+	const struct intel_dc_attachment *allowed_attachments;
+	u32 n_allowed_attachments;
+
+	struct intel_dc_memory *memory;
+
+	struct intel_dc_power *power;
+};
+
+static inline struct intel_plane *to_intel_plane(
+	struct intel_dc_component *component)
+{
+	return container_of(component, struct intel_plane, base);
+}
+
+static inline struct intel_pipe *to_intel_pipe(
+	struct intel_dc_component *component)
+{
+	return container_of(component, struct intel_pipe, base);
+}
+
+extern int intel_plane_init(struct intel_plane *plane, struct device *dev,
+	u8 idx, const struct intel_plane_capabilities *caps,
+	const struct intel_plane_ops *ops, const char *name);
+extern void intel_plane_destroy(struct intel_plane *plane);
+
+
+extern int intel_pipe_init(struct intel_pipe *pipe, struct device *dev,
+	u8 idx, bool primary, enum intel_pipe_type type,
+	const struct intel_plane *primary_plane,
+	const struct intel_pipe_ops *ops, const char *name);
+extern void intel_pipe_destroy(struct intel_pipe *pipe);
+
+extern int intel_dc_memory_init(struct intel_dc_memory *mem,
+	struct device *dev, size_t total_pages,
+	const struct intel_dc_memory_ops *ops);
+extern void intel_dc_memory_destroy(struct intel_dc_memory *mem);
+extern struct intel_dc_buffer *intel_dc_memory_import(
+	struct intel_dc_memory *mem, u32 handle, struct page **pages,
+	size_t n_pages);
+extern void intel_dc_memory_free(struct intel_dc_memory *mem,
+	struct intel_dc_buffer *buf);
+extern int intel_dc_memory_status(struct intel_dc_memory *mem,
+	size_t *n_total, size_t *n_alloc, size_t *n_free, size_t *n_bufs);
+
+extern int intel_dc_power_init(struct intel_dc_power *power,
+	struct device *dev, const struct intel_dc_config *config,
+	const struct intel_dc_power_ops *ops);
+extern void intel_dc_power_destroy(struct intel_dc_power *power);
+extern void intel_dc_power_suspend(struct intel_dc_power *power);
+extern void intel_dc_power_resume(struct intel_dc_power *power);
+
+extern int intel_dc_component_init(struct intel_dc_component *component,
+	struct device *dev, u8 idx, const char *name);
+extern void intel_dc_component_destroy(struct intel_dc_component *component);
+
+extern void intel_dc_config_add_plane(struct intel_dc_config *config,
+	struct intel_plane *plane, u8 idx);
+extern void intel_dc_config_add_pipe(struct intel_dc_config *config,
+	struct intel_pipe *pipe, u8 idx);
+static inline void intel_dc_config_add_memory(struct intel_dc_config *config,
+	struct intel_dc_memory *memory)
+{
+	if (config)
+		config->memory = memory;
+}
+static inline void intel_dc_config_add_power(struct intel_dc_config *config,
+	struct intel_dc_power *power)
+{
+	if (config)
+		config->power = power;
+}
+extern int intel_dc_config_init(struct intel_dc_config *config,
+	struct device *dev, const u32 id, size_t n_planes, size_t n_pipes,
+	const struct intel_dc_attachment *allowed_attachments,
+	size_t n_allowed_attachments);
+extern void intel_dc_config_destroy(struct intel_dc_config *config);
+
+extern struct intel_dc_config *intel_adf_get_dc_config(
+	struct pci_dev *pdev, const u32 id);
+extern void intel_adf_destroy_config(struct intel_dc_config *config);
+
+#endif /* INTEL_DC_CONFIG_H_ */
diff --git a/drivers/video/adf/intel/include/intel_adf.h b/drivers/video/adf/intel/include/intel_adf.h
new file mode 100644
index 0000000..088d8e9
--- /dev/null
+++ b/drivers/video/adf/intel/include/intel_adf.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef INTEL_ADF_H_
+#define INTEL_ADF_H_
+
+#include "core/intel_dc_config.h"
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+#include "core/common/backlight_dev.h"
+#endif
+#include "intel_adf_device.h"
+#include "intel_adf_interface.h"
+#include "intel_adf_overlay_engine.h"
+#if defined(CONFIG_ADF_FBDEV)
+#include "intel_adf_fbdev.h"
+#endif
+#include "uapi/intel_adf.h"
+
+struct intel_adf_context {
+	struct intel_dc_config *dc_config;
+	struct intel_adf_device *dev;
+	struct intel_adf_interface *intfs;
+	size_t n_intfs;
+	struct intel_adf_overlay_engine *engs;
+	size_t n_engs;
+#if defined(CONFIG_ADF_FBDEV)
+	struct adf_fbdev *fbdevs;
+	size_t n_fbdevs;
+#endif
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+	struct backlight_device *bl_dev;
+#endif
+};
+
+extern struct intel_adf_context *intel_adf_context_create(
+	struct pci_dev *pdev, void *pg);
+extern void intel_adf_context_destroy(struct intel_adf_context *ctx);
+extern int intel_adf_context_on_event(void);
+
+#endif /* INTEL_ADF_H_ */
diff --git a/drivers/video/adf/intel/include/intel_adf_device.h b/drivers/video/adf/intel/include/intel_adf_device.h
new file mode 100644
index 0000000..0e49baf
--- /dev/null
+++ b/drivers/video/adf/intel/include/intel_adf_device.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef INTEL_ADF_DEVICE_H_
+#define INTEL_ADF_DEVICE_H_
+
+#include <asm/intel-mid.h>
+#include <video/adf.h>
+#include <linux/pci.h>
+
+#include "intel_adf_mm.h"
+
+struct intel_adf_context;
+
+struct intel_adf_device {
+	struct adf_device base;
+	struct intel_adf_mm mm;
+	/*pci device*/
+	struct pci_dev *pdev;
+	/*display mmio virtual address*/
+	u8 *mmio;
+	/*timeline for sync up post operations*/
+	struct intel_adf_sync_timeline *post_timeline;
+
+	struct list_head active_intfs;
+	struct list_head active_engs;
+};
+
+static inline struct intel_adf_device *to_intel_dev(struct adf_device *dev)
+{
+	return container_of(dev, struct intel_adf_device, base);
+}
+
+static inline struct intel_adf_device *intf_to_dev(struct adf_interface *intf)
+{
+	return container_of(adf_interface_parent(intf),
+			struct intel_adf_device, base);
+}
+
+static inline struct intel_adf_device *eng_to_dev(
+		struct adf_overlay_engine *eng)
+{
+	return container_of(adf_overlay_engine_parent(eng),
+			struct intel_adf_device, base);
+}
+
+/*
+ * FIXME: remove these later
+ */
+#define IS_ANN() (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)
+
+extern struct intel_adf_device *intel_adf_device_create(struct pci_dev *pdev,
+	struct intel_dc_memory *mem);
+extern void intel_adf_device_destroy(struct intel_adf_device *dev);
+
+extern u32 REG_READ(u32 reg);
+extern void REG_WRITE(u32 reg, u32 val);
+
+#endif /* INTEL_ADF_DEVICE_H_ */
diff --git a/drivers/video/adf/intel/include/intel_adf_fbdev.h b/drivers/video/adf/intel/include/intel_adf_fbdev.h
new file mode 100644
index 0000000..b697acd
--- /dev/null
+++ b/drivers/video/adf/intel/include/intel_adf_fbdev.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef INTEL_ADF_FBDEV_H_
+#define INTEL_ADF_FBDEV_H_
+
+#include <video/adf_fbdev.h>
+
+extern int intel_adf_fbdev_init(struct adf_fbdev *fbdev,
+	struct intel_adf_interface *intf,
+	struct intel_adf_overlay_engine *eng);
+extern void intel_adf_fbdev_destroy(struct adf_fbdev *fbdev);
+
+#endif /* INTEL_ADF_FBDEV_H_ */
diff --git a/drivers/video/adf/intel/include/intel_adf_interface.h b/drivers/video/adf/intel/include/intel_adf_interface.h
new file mode 100644
index 0000000..f3296ab
--- /dev/null
+++ b/drivers/video/adf/intel/include/intel_adf_interface.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef INTEL_ADF_INTERFACE_H_
+#define INTEL_ADF_INTERFACE_H_
+
+#include <video/adf.h>
+#include <video/adf_format.h>
+
+#include "core/intel_dc_config.h"
+#include "intel_adf_device.h"
+#include "intel_adf_sync.h"
+
+struct intel_adf_interface {
+	struct adf_interface base;
+	struct intel_pipe *pipe;
+	struct task_struct *event_handling_thread;
+	struct kthread_worker event_handling_worker;
+	struct kthread_work hotplug_connected_work;
+	struct intel_adf_sync_timeline *vsync_timeline;
+	atomic_t post_seqno;
+	struct list_head active_list;
+};
+
+static inline struct intel_adf_interface *to_intel_intf(
+	struct adf_interface *intf)
+{
+	return container_of(intf, struct intel_adf_interface, base);
+}
+
+extern int intel_adf_interface_handle_event(struct intel_adf_interface *intf);
+extern struct sync_fence *intel_adf_interface_create_vsync_fence(
+	struct intel_adf_interface *intf, u32 interval);
+extern int intel_adf_interface_init(struct intel_adf_interface *intf,
+	struct intel_adf_device *dev, struct intel_pipe *pipe);
+extern void intel_adf_interface_destroy(struct intel_adf_interface *intf);
+
+#endif /* INTEL_ADF_INTERFACE_H_ */
diff --git a/drivers/video/adf/intel/include/intel_adf_mm.h b/drivers/video/adf/intel/include/intel_adf_mm.h
new file mode 100644
index 0000000..cf8275d
--- /dev/null
+++ b/drivers/video/adf/intel/include/intel_adf_mm.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef INTEL_ADF_MM_H_
+#define INTEL_ADF_MM_H_
+
+#include <linux/device.h>
+#include <linux/dma-buf.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+
+#include "core/intel_dc_config.h"
+
+enum intel_dma_buf_type {
+	INTEL_DMA_BUF_ALLOCATED,
+	INTEL_DMA_BUF_IMPORTED,
+};
+
+struct intel_adf_mm {
+	struct device *parent;
+	struct intel_dc_memory *mem;
+};
+
+extern int intel_adf_mm_alloc_buf(struct intel_adf_mm *mm,
+	u32 size, struct dma_buf **buf);
+extern void intel_adf_mm_free_buf(struct dma_buf *buf);
+extern int intel_adf_mm_export(struct intel_adf_mm *mm, struct page **pages,
+	u32 page_num, void *vaddr, enum intel_dma_buf_type type,
+	struct dma_buf **buf);
+extern int intel_adf_mm_fd(struct dma_buf *buf);
+extern int intel_adf_mm_gtt(struct dma_buf *buf, u32 *gtt);
+extern int intel_adf_mm_init(struct intel_adf_mm *mm, struct device *parent,
+			struct intel_dc_memory *mem);
+extern void intel_adf_mm_destroy(struct intel_adf_mm *mm);
+
+#endif /* INTEL_ADF_MM_H_ */
diff --git a/drivers/video/adf/intel/include/intel_adf_overlay_engine.h b/drivers/video/adf/intel/include/intel_adf_overlay_engine.h
new file mode 100644
index 0000000..c8391b0
--- /dev/null
+++ b/drivers/video/adf/intel/include/intel_adf_overlay_engine.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef INTEL_ADF_OVERLAY_ENGINE_H_
+#define INTEL_ADF_OVERLAY_ENGINE_H_
+
+#include <video/adf.h>
+
+#include "core/intel_dc_config.h"
+#include "intel_adf_device.h"
+
+struct intel_adf_overlay_engine {
+	struct adf_overlay_engine base;
+	struct intel_plane *plane;
+	struct list_head active_list;
+};
+
+static inline struct intel_adf_overlay_engine *to_intel_eng(
+	struct adf_overlay_engine *eng)
+{
+	return container_of(eng, struct intel_adf_overlay_engine, base);
+}
+
+extern int intel_adf_overlay_engine_init(
+	struct intel_adf_overlay_engine *eng, struct intel_adf_device *dev,
+	struct intel_plane *plane);
+extern void intel_adf_overlay_engine_destroy(
+	struct intel_adf_overlay_engine *eng);
+
+#endif /* INTEL_ADF_OVERLAY_ENGINE_H_ */
diff --git a/drivers/video/adf/intel/include/intel_adf_sync.h b/drivers/video/adf/intel/include/intel_adf_sync.h
new file mode 100644
index 0000000..a60834f
--- /dev/null
+++ b/drivers/video/adf/intel/include/intel_adf_sync.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef INTEL_ADF_SYNC_H_
+#define INTEL_ADF_SYNC_H_
+
+#include <android/sync.h>
+
+struct intel_adf_sync_timeline {
+	struct sync_timeline base;
+	atomic64_t value;
+};
+
+struct intel_adf_sync_pt {
+	struct sync_pt base;
+	atomic64_t value;
+};
+
+extern struct intel_adf_sync_timeline *intel_adf_sync_timeline_create(
+	const char *name);
+extern void intel_adf_sync_timeline_destroy(
+	struct intel_adf_sync_timeline *tl);
+extern struct sync_fence *intel_adf_sync_fence_create(
+	struct intel_adf_sync_timeline *tl, u64 value);
+extern void intel_adf_sync_fence_put(struct intel_adf_sync_timeline *tl,
+	struct sync_fence *fence);
+extern void intel_adf_sync_timeline_signal(
+	struct intel_adf_sync_timeline *tl, u64 value);
+
+#endif /* INTEL_ADF_SYNC_H_ */
diff --git a/drivers/video/adf/intel/include/uapi/intel_adf.h b/drivers/video/adf/intel/include/uapi/intel_adf.h
new file mode 100644
index 0000000..64d862a
--- /dev/null
+++ b/drivers/video/adf/intel/include/uapi/intel_adf.h
@@ -0,0 +1,218 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright 2014
+ * Intel Corporation All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents related to
+ * the source code ("Material") are owned by Intel Corporation or its suppliers
+ * or licensors. Title to the Material remains with Intel Corporation or its
+ * suppliers and licensors. The Material contains trade secrets and proprietary
+ * and confidential information of Intel or its suppliers and licensors. The
+ * Material is protected by worldwide copyright and trade secret laws and treaty
+ * provisions. No part of the Material may be used, copied, reproduced,
+ * modified, published, uploaded, posted, transmitted, distributed, or disclosed
+ * in any way without Intels prior express written permission.
+ *
+ * No license under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or delivery
+ * of the Materials, either expressly, by implication, inducement, estoppel
+ * or otherwise. Any license under such intellectual property rights must be
+ * express and approved by Intel in writing.
+ */
+
+#ifndef _VIDEO_INTEL_ADF_H_
+#define _VIDEO_INTEL_ADF_H_
+
+/*
+ * This identifier should be increased every time the contents of the this file
+ * change in any manner that could require detection from the client. This
+ * enables a kernel to reject any clients that are too old. Note that a failure
+ * to match compatible versions should result in the user mode falling back to
+ * the baseline simple post.
+ */
+#define INTEL_ADF_VERSION 1
+
+enum intel_adf_compression {
+	INTEL_ADF_UNCOMPRESSED,
+	INTEL_ADF_COMPRESSED,
+};
+
+enum intel_adf_blending {
+	INTEL_ADF_BLENDING_NONE,
+	INTEL_ADF_BLENDING_PREMULT,
+	INTEL_ADF_BLENDING_COVERAGE,
+};
+
+enum intel_adf_transform {
+	INTEL_ADF_TRANSFORM_NONE	= 0,
+	INTEL_ADF_TRANSFORM_FLIPH	= 1,
+	INTEL_ADF_TRANSFORM_FLIPV	= 2,
+	INTEL_ADF_TRANSFORM_ROT90	= 4,
+	/* INTEL_ADF_TRANSFORM_FLIPH | INTEL_ADF_TRANSFORM_FLIPV; */
+	INTEL_ADF_TRANSFORM_ROT180	= 3,
+	/*
+	 * INTEL_ADF_TRANSFORM_FLIPH | INTEL_ADF_TRANSFORM_FLIPV |
+	 * INTEL_ADF_TRANSFORM_ROT90;
+	 */
+	INTEL_ADF_TRANSFORM_ROT270	= 7,
+};
+
+/**
+ * intel_adf_color
+ * overlay_id:	index of the overlay engine
+ * zorder:	depth of the layer ion screen, lower is further back
+ * reserved:	set reserved bit
+ * color:	color
+ */
+struct intel_adf_color {
+	__u8	overlay_id;
+	__u8	zorder;
+	__u16	reserved;
+	__u32	color;
+};
+
+enum intel_adf_plane_flags {
+	INTEL_ADF_PLANE_DISABLE		= 0x0001,
+	/* User indication that this plane is unchanged since the last post */
+	INTEL_ADF_PLANE_UNCHANGED	= 0x0002,
+	/* Flags for any undefined HW specific usage */
+	INTEL_ADF_PLANE_HWSPECIFIC1	= 0x1000,
+	INTEL_ADF_PLANE_HWSPECIFIC2	= 0x2000,
+	INTEL_ADF_PLANE_HWSPECIFIC3	= 0x4000,
+	INTEL_ADF_PLANE_HWSPECIFIC4	= 0x8000,
+};
+
+/**
+ * struct intel_adf_plane - intel plane structure for adf
+ * overlay_id:	index of the overlay engine for this plane
+ * interface_id:index of interface
+ * buffer_id:	Index of the buffer to put on this plane
+ *		(within adf_post_config.bufs array)
+ * flags:	flags
+ * dst_x:	destination left
+ * dst_y:	destination top
+ * dst_w:	destination width
+ * dst_h:	destination_height
+ * src_x:	16.16 fixed point source left
+ * src_y:	16.16 fixed point source top
+ * src_w:	16.16 fixed point source width
+ * src_h:	16.16 fixed point source height
+ * alpha:	constant alpha value
+ * compression:	compiression mode
+ * blending:	blending mode
+ * transform:	transform mode
+ * pad:		struct padding, value is always zero.
+ */
+struct intel_adf_plane {
+	/*
+	 * NOTE: this field might be useless, already have
+	 * overlay engine assigned to adf_buffer
+	 **/
+	__u8	overlay_id;
+	__u8	inteface_id;
+	__u8	buffer_id;
+	__u16	flags;
+	__s16	dst_x;
+	__s16	dst_y;
+	__u16	dst_w;
+	__u16	dst_h;
+	__s32	src_x;
+	__s32	src_y;
+	__u32	src_w;
+	__u32	src_h;
+	__u8	alpha;
+	enum intel_adf_compression	compression:4;
+	enum intel_adf_blending		blending:4;
+	enum intel_adf_transform	transform:4;
+	__u8	pad:4;
+};
+
+enum intel_adf_pfitter_flags {
+	INTEL_ADF_PFIT_DISABLE		= 0x0001,
+	INTEL_ADF_PFIT_AUTO		= 0x0002,
+	INTEL_ADF_PFIT_LETTERBOX	= 0x0004,
+	INTEL_ADF_PFIT_PILLARBOX	= 0x0008,
+	/* Flags for any undefined HW specific usage */
+	INTEL_ADF_PFIT_HWSPECIFIC1	= 0x1000,
+	INTEL_ADF_PFIT_HWSPECIFIC2	= 0x2000,
+	INTEL_ADF_PFIT_HWSPECIFIC3	= 0x4000,
+	INTEL_ADF_PFIT_HWSPECIFIC4	= 0x8000,
+};
+
+/**
+ * struct intel_adf_panelfitter
+ * overlay_id:	index of the overlay engine for panel fitter
+ * pad:		for structure padding, should be zero
+ * flags:	flags
+ * dst_x:	destination left
+ * dst_y:	destination top
+ * dst_w:	destination width
+ * dst_h:	destination height
+ * src_x:	source left
+ * src_y:	source top
+ * src_w:	source width
+ * src_h:	source height
+ */
+struct intel_adf_panelfitter {
+	__u8	verlay_id;
+	__u8	pad;
+	__u16	flags;
+	__s16	dst_x;
+	__s16	dst_y;
+	__u16	dst_w;
+	__u16	dst_h;
+	__s16	src_x;
+	__s16	src_y;
+	__u16	src_w;
+	__u16	src_h;
+};
+
+/*
+ * All the overlay structures begin with a _u8 overlay_id element.
+ * The type of the specified overlay_engine will determine the type
+ * of this union
+ */
+struct intel_adf_overlay {
+	union {
+		__u8	overlay_id;
+		struct intel_adf_color		color;
+		struct intel_adf_plane		plane;
+		struct intel_adf_panelfitter	panelfitter;
+	};
+};
+
+enum intel_adf_post_flags {
+	/* Call the custom page flip handler when this flip has completed */
+	INTEL_ADF_POST_FLIPCALLBACK	= 0x0001,
+	/* Apply this immediately, without waiting for vsyn c*/
+	INTEL_ADF_POST_IMMEDIATE	= 0x0002,
+	/*
+	 * Discard anything currently queued and make this flip happen on
+	 * the next vsync
+	 */
+	INTEL_ADF_POST_DISCARDQUEUE	= 0x0004,
+	/* Flags for any undefined HW specific usage */
+	INTEL_ADF_POST_HWSPECIFIC	= 0xF000,
+};
+
+/**
+ * intel_adf_post_custom_data
+ * version:	INTEL_ADF_VERSION for backward compatibility support
+ * flags:	adf post flags
+ * num_overlays:number of overlays
+ * overlays:	overlay entried will follow this structure in memory
+ */
+struct intel_adf_post_custom_data {
+	__u32				version;
+	enum intel_adf_post_flags	flags;
+	__u32				num_overlays;
+
+	/* Z order (on hardware that supports it) is defined by the order of
+	 * these planes entry [0] is backmost, entry [num_overlays-1] is
+	 * frontmost
+	 */
+	struct intel_adf_overlay	overlays[0];
+};
+
+#endif /* _VIDEO_INTEL_ADF_H_ */
diff --git a/drivers/video/adf/intel/include/uapi/intel_custom_formats.h b/drivers/video/adf/intel/include/uapi/intel_custom_formats.h
new file mode 100644
index 0000000..d866602
--- /dev/null
+++ b/drivers/video/adf/intel/include/uapi/intel_custom_formats.h
@@ -0,0 +1,32 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright 2014
+ * Intel Corporation All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents related to
+ * the source code ("Material") are owned by Intel Corporation or its suppliers
+ * or licensors. Title to the Material remains with Intel Corporation or its
+ * suppliers and licensors. The Material contains trade secrets and proprietary
+ * and confidential information of Intel or its suppliers and licensors. The
+ * Material is protected by worldwide copyright and trade secret laws and treaty
+ * provisions. No part of the Material may be used, copied, reproduced,
+ * modified, published, uploaded, posted, transmitted, distributed, or disclosed
+ * in any way without Intels prior express written permission.
+ *
+ * No license under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or delivery
+ * of the Materials, either expressly, by implication, inducement, estoppel
+ * or otherwise. Any license under such intellectual property rights must be
+ * express and approved by Intel in writing.
+ *
+ */
+
+#ifndef INTEL_CUSTOM_FORMATS_H_
+#define INTEL_CUSTOM_FORMATS_H_
+
+#include <drm/drm_fourcc.h>
+
+#define DRM_FORMAT_NV12_INTEL fourcc_code('S', 'B', '1', '2')
+
+#endif /* INTEL_CUSTOM_FORMATS_H_ */
diff --git a/drivers/video/adf/intel/intel_adf.c b/drivers/video/adf/intel/intel_adf.c
new file mode 100644
index 0000000..f0e7126
--- /dev/null
+++ b/drivers/video/adf/intel/intel_adf.c
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <intel_adf.h>
+
+static const struct intel_adf_context *g_adf_context;
+
+static struct intel_adf_interface *create_interfaces(
+	struct intel_adf_device *dev,
+	struct intel_pipe **pipes, size_t n_pipes)
+{
+	struct intel_adf_interface *intfs;
+	int err;
+	size_t i;
+
+	intfs = kzalloc(n_pipes * sizeof(*intfs), GFP_KERNEL);
+	if (!intfs)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < n_pipes; i++) {
+		err = intel_adf_interface_init(&intfs[i], dev, pipes[i]);
+		if (err)
+			goto out_err0;
+	}
+	return intfs;
+out_err0:
+	for (; i >= 0; i--)
+		intel_adf_interface_destroy(&intfs[i]);
+	kfree(intfs);
+	return ERR_PTR(err);
+}
+
+static void destroy_interfaces(struct intel_adf_interface *intfs,
+	size_t n_intfs)
+{
+	size_t i;
+
+	for (i = 0; i < n_intfs; i++)
+		intel_adf_interface_destroy(&intfs[i]);
+	kfree(intfs);
+}
+
+static struct intel_adf_overlay_engine *create_overlay_engines(
+	struct intel_adf_device *dev,
+	struct intel_plane **planes, size_t n_planes)
+{
+	struct intel_adf_overlay_engine *engs;
+	int err;
+	size_t i;
+
+	engs = kzalloc(n_planes * sizeof(*engs), GFP_KERNEL);
+	if (!engs)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < n_planes; i++) {
+		err = intel_adf_overlay_engine_init(&engs[i], dev, planes[i]);
+		if (err)
+			goto out_err0;
+	}
+	return engs;
+out_err0:
+	for (; i >= 0; i--)
+		intel_adf_overlay_engine_destroy(&engs[i]);
+	kfree(engs);
+	return ERR_PTR(err);
+}
+
+static void destroy_overlay_engines(struct intel_adf_overlay_engine *engs,
+	size_t n_engs)
+{
+	int i;
+
+	for (i = 0; i < n_engs; i++)
+		intel_adf_overlay_engine_destroy(&engs[i]);
+	kfree(engs);
+}
+
+static int create_attachments(struct intel_adf_device *dev,
+	struct intel_adf_interface *intfs, size_t n_intfs,
+	struct intel_adf_overlay_engine *engs, size_t n_engs,
+	const struct intel_dc_attachment *allowed_attachments,
+	size_t n_allowed_attachments)
+{
+	u8 pipe_id, plane_id;
+	int err;
+	size_t i;
+
+	for (i = 0; i < n_allowed_attachments; i++) {
+		pipe_id = allowed_attachments[i].pipe_id;
+		plane_id = allowed_attachments[i].plane_id;
+
+		if (pipe_id >= n_intfs || plane_id >= n_engs)
+			return -EINVAL;
+		err = adf_attachment_allow(&dev->base, &engs[plane_id].base,
+				&intfs[pipe_id].base);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_ADF_FBDEV)
+static struct adf_fbdev *create_fbdevs(struct intel_adf_context *ctx)
+{
+	struct intel_adf_device *dev = ctx->dev;
+	struct intel_adf_interface *intfs = ctx->intfs;
+	struct intel_adf_overlay_engine *engs = ctx->engs;
+	size_t n_intfs = ctx->n_intfs;
+	size_t n_engs = ctx->n_engs;
+
+	struct adf_fbdev *fbdevs;
+	struct intel_pipe *pipe;
+	const struct intel_plane *primary_plane;
+	int err;
+	int i;
+
+	fbdevs = kzalloc(n_intfs * sizeof(*fbdevs), GFP_KERNEL);
+	if (!fbdevs)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < n_intfs; i++) {
+		pipe = intfs[i].pipe;
+		if (!pipe || !pipe->ops || !pipe->ops->is_screen_connected ||
+			!pipe->primary_plane) {
+			dev_err(dev->base.dev, "%s: invalid pipe\n", __func__);
+			err = -EINVAL;
+			goto out_err0;
+		}
+
+		/*if screen was disconnected, don't create fbdev for this intf*/
+		if (!pipe->ops->is_screen_connected(pipe))
+			continue;
+
+		primary_plane = pipe->primary_plane;
+		if (primary_plane->base.idx >= n_engs) {
+			dev_err(dev->base.dev, "%s: invalid plane\n", __func__);
+			err = -EINVAL;
+			goto out_err0;
+		}
+
+		err = intel_adf_fbdev_init(&fbdevs[i], &intfs[i],
+				&engs[primary_plane->base.idx]);
+		if (err) {
+			dev_err(dev->base.dev, "%s: failed to init fbdev %d\n",
+				__func__, i);
+			goto out_err0;
+		}
+	}
+	ctx->fbdevs = fbdevs;
+	ctx->n_fbdevs = n_intfs;
+	return fbdevs;
+out_err0:
+	for (; i >= 0; i--)
+		intel_adf_fbdev_destroy(&fbdevs[i]);
+	kfree(fbdevs);
+	return ERR_PTR(err);
+}
+
+static void destroy_fbdevs(struct adf_fbdev *fbdevs, size_t n_fbdevs)
+{
+	size_t i;
+	for (i = 0; i < n_fbdevs; i++)
+		intel_adf_fbdev_destroy(&fbdevs[i]);
+	kfree(fbdevs);
+}
+#endif
+
+void intel_adf_context_destroy(struct intel_adf_context *ctx)
+{
+
+	if (!ctx)
+		return;
+#if defined(CONFIG_ADF_FBDEV)
+	if (ctx->fbdevs)
+		destroy_fbdevs(ctx->fbdevs, ctx->n_fbdevs);
+#endif
+	if (ctx->engs)
+		destroy_overlay_engines(ctx->engs, ctx->n_engs);
+	if (ctx->intfs)
+		destroy_interfaces(ctx->intfs, ctx->n_intfs);
+	if (ctx->dev)
+		intel_adf_device_destroy(ctx->dev);
+	if (ctx->dc_config)
+		intel_adf_destroy_config(ctx->dc_config);
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+	if (ctx->bl_dev)
+		backlight_exit(ctx->bl_dev);
+#endif
+
+	kfree(ctx);
+	g_adf_context = NULL;
+}
+
+struct intel_adf_context *intel_adf_context_create(struct pci_dev *pdev,
+	void *pg)
+{
+	struct intel_adf_context *ctx;
+	struct intel_adf_device *dev;
+	struct intel_dc_config *config;
+	struct intel_adf_interface *intfs;
+	struct intel_adf_overlay_engine *engs;
+	int n_intfs, n_engs;
+#if defined(CONFIG_ADF_FBDEV)
+	struct adf_fbdev *fbdevs;
+#endif
+	/*TODO: use real platform ID*/
+	u32 platform_id = 0;
+	int err;
+
+	if (!pdev || !pg)
+		return ERR_PTR(-EINVAL);
+
+	/*create ADF context*/
+	ctx = kzalloc(sizeof(struct intel_adf_context), GFP_KERNEL);
+	if (!ctx) {
+		err = -ENOMEM;
+		goto err;
+	}
+
+	/*get display controller configure of this platform*/
+	config = intel_adf_get_dc_config(pdev, platform_id);
+	if (IS_ERR(config)) {
+		dev_err(&pdev->dev, "%s: failed to get DC config\n", __func__);
+		err = PTR_ERR(config);
+		goto err;
+	}
+
+	/*create ADF device*/
+	dev = intel_adf_device_create(pdev, config->memory);
+	if (IS_ERR(dev)) {
+		dev_err(&pdev->dev, "%s: failed to create adf device\n",
+			__func__);
+		err = PTR_ERR(dev);
+		goto err;
+	}
+
+	/*create ADF interfaces*/
+	n_intfs = config->n_pipes;
+	intfs = create_interfaces(dev, config->pipes, n_intfs);
+	if (IS_ERR(intfs)) {
+		dev_err(&pdev->dev, "%s: failed to create interfaces\n",
+			__func__);
+		err = PTR_ERR(intfs);
+		goto err;
+	}
+
+	dev_info(&pdev->dev, "%s: created interfaces %d\n", __func__, n_intfs);
+
+	/*create ADF overlay engines*/
+	n_engs = config->n_planes;
+	engs = create_overlay_engines(dev, config->planes, n_engs);
+	if (IS_ERR(engs)) {
+		dev_err(&pdev->dev, "%s: failed to create overlay engines\n",
+			__func__);
+		err = PTR_ERR(engs);
+		goto err;
+	}
+
+	dev_info(&pdev->dev, "%s: created engines %d\n", __func__, n_engs);
+
+	/*create allowed attachements*/
+	err = create_attachments(dev, intfs, n_intfs, engs, n_engs,
+			config->allowed_attachments,
+			config->n_allowed_attachments);
+	if (err) {
+		dev_err(&pdev->dev, "%s: failed to init allowed attachments\n",
+			__func__);
+		goto err;
+	}
+
+	ctx->dc_config = config;
+	ctx->dev = dev;
+	ctx->engs = engs;
+	ctx->n_engs = n_engs;
+	ctx->intfs = intfs;
+	ctx->n_intfs = n_intfs;
+
+	g_adf_context = ctx;
+
+#if defined(CONFIG_ADF_FBDEV)
+	fbdevs = create_fbdevs(ctx);
+	if (IS_ERR(fbdevs)) {
+		dev_err(&pdev->dev, "%s: failed to create FB devices\n",
+			__func__);
+		err = PTR_ERR(fbdevs);
+		goto err;
+	}
+#endif
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+	err = backlight_init(ctx);
+	if (err)
+		goto err;
+#endif
+
+	return ctx;
+err:
+	intel_adf_context_destroy(ctx);
+	return ERR_PTR(err);
+}
+
+int intel_adf_context_on_event(void)
+{
+	struct intel_adf_interface *intf;
+	bool handled;
+	size_t i;
+	int ret;
+
+	if (!g_adf_context)
+		return IRQ_NONE;
+
+	/*return intel_adf_handle_event(g_adf_context->event_handler);*/
+
+	pr_debug("%s\n", __func__);
+
+	handled = false;
+
+	for (i = 0; i < g_adf_context->n_intfs; i++) {
+		intf = &g_adf_context->intfs[i];
+		ret = intel_adf_interface_handle_event(intf);
+		if (ret == IRQ_HANDLED)
+			handled = true;
+	}
+
+	/*TODO: handle fbdev create/destroy*/
+
+	return handled ? IRQ_HANDLED : IRQ_NONE;
+}
+EXPORT_SYMBOL(intel_adf_context_on_event);
diff --git a/drivers/video/adf/intel/intel_adf_device.c b/drivers/video/adf/intel/intel_adf_device.c
new file mode 100644
index 0000000..8bf3369
--- /dev/null
+++ b/drivers/video/adf/intel/intel_adf_device.c
@@ -0,0 +1,649 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "intel_adf.h"
+
+#define INTEL_ADF_DEVICE_NAME		"intel-adf-dev"
+#define INTEL_DC_REG_OFFSET		0x0
+#define INTEL_DC_REG_SIZE		0x80000
+#define INTEL_VSYNC_FENCE_TIMEOUT	(5 * MSEC_PER_SEC)
+
+
+static struct intel_adf_device *g_intel_adf_dev;
+
+u32 REG_READ(u32 reg)
+{
+	return ioread32(g_intel_adf_dev->mmio + (reg));
+}
+
+void REG_WRITE(u32 reg, u32 val)
+{
+	iowrite32(val, g_intel_adf_dev->mmio + reg);
+}
+
+struct post_obj {
+	void *obj;
+	struct list_head next;
+};
+
+struct post_obj_set {
+	struct list_head objs;
+};
+
+struct flip {
+	struct intel_adf_overlay_engine *eng;
+	struct intel_buffer buf;
+	struct intel_plane_config config;
+	struct list_head list;
+};
+
+struct driver_state {
+	struct post_obj_set post_intfs;
+	struct post_obj_set post_engs;
+	struct list_head post_flips;
+	u64 timestamp;
+};
+
+/**
+ * for_each_post_obj - iterate over post object set
+ * @po: post_obj * to use as a loop cursor.
+ * @set: post_obj_set * for a post object set
+ */
+#define for_each_post_obj(po, set) \
+	list_for_each_entry(po, &((set)->objs), next)
+
+static struct post_obj *post_obj_set_find_obj(struct post_obj_set *set,
+	void *obj)
+{
+	bool existed = false;
+	struct post_obj *po;
+
+	for_each_post_obj(po, set) {
+		if (po->obj == obj) {
+			existed = true;
+			break;
+		}
+	}
+
+	return existed ? po : NULL;
+}
+
+static struct post_obj *create_add_post_obj(struct post_obj_set *set,
+	void *obj)
+{
+	struct post_obj *po;
+
+	if (!set || !obj)
+		return NULL;
+
+	po = post_obj_set_find_obj(set, obj);
+	if (!po) {
+		po = kzalloc(sizeof(*po), GFP_KERNEL);
+		if (po) {
+			po->obj = obj;
+			INIT_LIST_HEAD(&po->next);
+			list_add_tail(&po->next, &set->objs);
+		}
+	}
+
+	return po;
+}
+
+static void post_obj_set_init(struct post_obj_set *set)
+{
+	INIT_LIST_HEAD(&set->objs);
+}
+
+static void post_obj_set_destroy(struct post_obj_set *set)
+{
+	struct post_obj *po, *tmp;
+
+	if (!set)
+		return;
+
+	list_for_each_entry_safe(po, tmp, &set->objs, next) {
+		list_del(&po->next);
+		kfree(po);
+	}
+}
+
+/*----------------------------------------------------------------------------*/
+/*
+static int intel_adf_device_attach(struct adf_device *dev,
+				struct adf_overlay_engine *eng,
+				struct adf_interface *intf)
+{
+	return 0;
+}
+
+static int intel_adf_device_detach(struct adf_device *dev,
+				struct adf_overlay_engine *eng,
+				struct adf_interface *intf)
+{
+	return 0;
+}
+
+static int intel_adf_device_validate_custom_format(struct adf_device *dev,
+						struct adf_buffer *buf)
+{
+	return 0;
+}
+*/
+
+static int intel_adf_device_validate_custom_format(struct adf_device *dev,
+	struct adf_buffer *buf)
+{
+	struct intel_adf_overlay_engine *eng =
+		to_intel_eng(buf->overlay_engine);
+	struct intel_plane *plane = eng->plane;
+
+	if (plane && plane->ops && plane->ops->validate_custom_format)
+		return plane->ops->validate_custom_format(plane, buf->format,
+			buf->w, buf->h);
+	return 0;
+}
+
+static int adf_buffer_to_intel_buffer(struct adf_buffer *adf_buf,
+	struct intel_buffer *intel_buf)
+{
+	struct dma_buf *dma_buf = adf_buf->dma_bufs[0];
+	u32 gtt_in_pages = 0;
+	int err;
+
+	err = intel_adf_mm_gtt(dma_buf, &gtt_in_pages);
+	if (err)
+		return err;
+
+	intel_buf->format = adf_buf->format;
+	intel_buf->w = adf_buf->w;
+	intel_buf->h = adf_buf->h;
+	intel_buf->gtt_offset_in_pages = gtt_in_pages;
+
+	return 0;
+}
+
+static void adf_plane_to_intel_plane_config(
+	struct intel_adf_plane *adf_plane, struct intel_adf_interface *intf,
+	struct intel_plane_config *config)
+{
+	config->dst_x = adf_plane->dst_x;
+	config->dst_y = adf_plane->dst_y;
+	config->dst_w = adf_plane->dst_w;
+	config->dst_h = adf_plane->dst_h;
+	config->src_x = adf_plane->src_x;
+	config->src_y = adf_plane->src_y;
+	config->src_w = adf_plane->src_w;
+	config->src_h = adf_plane->src_h;
+	config->alpha = adf_plane->alpha;
+	/*TODO: map adf_plane to plane_config*/
+	config->compression = adf_plane->compression;
+	config->blending = adf_plane->blending;
+	config->transform = adf_plane->transform;
+	config->pipe = intf->pipe;
+}
+
+static struct driver_state *driver_state_create_and_init(void)
+{
+	struct driver_state *state = NULL;
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (state) {
+		post_obj_set_init(&state->post_intfs);
+		post_obj_set_init(&state->post_engs);
+		INIT_LIST_HEAD(&state->post_flips);
+	}
+
+	return state;
+}
+
+static void driver_state_destroy(struct driver_state *state)
+{
+	struct flip *f, *tmp;
+
+	if (!state)
+		return;
+
+	post_obj_set_destroy(&state->post_engs);
+	post_obj_set_destroy(&state->post_intfs);
+	list_for_each_entry_safe(f, tmp, &state->post_flips, list) {
+		list_del(&f->list);
+		kfree(f);
+	}
+
+	kfree(state);
+}
+
+static void driver_state_add_interface(struct driver_state *state,
+	struct intel_adf_interface *intf)
+{
+	create_add_post_obj(&state->post_intfs, intf);
+}
+
+static void driver_state_add_overlay_engine(struct driver_state *state,
+	struct intel_adf_overlay_engine *eng)
+{
+	create_add_post_obj(&state->post_engs, eng);
+}
+
+static struct flip *driver_state_create_add_flip(
+	struct driver_state *state, struct intel_adf_overlay_engine *eng,
+	struct intel_adf_interface *intf, struct adf_buffer *buf,
+	struct intel_adf_plane *plane)
+{
+	struct flip *f = NULL;
+	int err;
+
+	f = kzalloc(sizeof(*f), GFP_KERNEL);
+	if (f) {
+		f->eng = eng;
+		adf_buffer_to_intel_buffer(buf, &f->buf);
+		adf_plane_to_intel_plane_config(plane, intf, &f->config);
+
+		/*validate the buffer and config before adding it*/
+		if (eng->plane && eng->plane->ops &&
+			eng->plane->ops->validate) {
+			err = eng->plane->ops->validate(eng->plane, &f->buf,
+				&f->config);
+			if (err)
+				goto err;
+		}
+		INIT_LIST_HEAD(&f->list);
+		list_add_tail(&f->list, &state->post_flips);
+	}
+
+	return f;
+err:
+	kfree(f);
+	return NULL;
+}
+
+static int intel_adf_device_validate(struct adf_device *dev,
+				struct adf_post *cfg,
+				void **driver_state)
+{
+	struct intel_adf_post_custom_data *custom = cfg->custom_data;
+	struct intel_adf_overlay *custom_overlay;
+	struct intel_adf_overlay_engine *eng;
+	struct driver_state *state;
+	struct adf_interface *intf;
+	struct adf_buffer *buf;
+	struct flip *f;
+
+	size_t n_bufs = cfg->n_bufs;
+	u32 n_overlays;
+	size_t custom_size;
+	int err;
+	int i;
+
+	if (!custom) {
+		dev_err(dev->dev, "%s: no custom data found\n", __func__);
+		return -EINVAL;
+	}
+
+	/*verify version*/
+	if (custom->version != INTEL_ADF_VERSION) {
+		dev_err(dev->dev, "%s: version mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	n_overlays = custom->num_overlays;
+
+	/*verify custom size*/
+	custom_size = sizeof(struct intel_adf_post_custom_data) +
+		n_overlays * sizeof(struct intel_adf_overlay);
+	if (custom_size != cfg->custom_data_size) {
+		dev_err(dev->dev, "%s: invalid custom size\n", __func__);
+		return -EINVAL;
+	}
+
+	/*allocate driver state*/
+	state = driver_state_create_and_init();
+	if (!state) {
+		dev_err(dev->dev, "%s: failed to allocate driver state\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	/*verify custom overlays*/
+	for (i = 0; i < n_overlays; i++) {
+		custom_overlay = &custom->overlays[i];
+		/*verify buffer id set in plane*/
+		if (custom_overlay->plane.buffer_id > n_bufs) {
+			dev_err(dev->dev, "%s: invalid custom buffer id %d\n",
+				__func__, custom_overlay->plane.buffer_id);
+			err = -EINVAL;
+			goto err;
+		}
+		/*verify interface id set in plane*/
+		intf = idr_find(&dev->interfaces,
+			custom_overlay->plane.inteface_id);
+		if (!intf) {
+			dev_err(dev->dev, "%s: invalid interface id %d\n",
+				__func__, custom_overlay->plane.inteface_id);
+			err = -EINVAL;
+			goto err;
+		}
+		driver_state_add_interface(state, to_intel_intf(intf));
+
+		/*get adf_buffer for this overlay*/
+		buf = &cfg->bufs[custom_overlay->plane.buffer_id];
+		eng = to_intel_eng(buf->overlay_engine);
+		driver_state_add_overlay_engine(state, eng);
+
+		/*create and queue a flip for this overlay*/
+		f = driver_state_create_add_flip(state, eng,
+			to_intel_intf(intf), buf, &custom_overlay->plane);
+		if (!f) {
+			dev_err(dev->dev, "%s: failed to create flip\n",
+				__func__);
+			err = -ENOMEM;
+			goto err;
+		}
+	}
+
+	*driver_state = state;
+
+	return 0;
+err:
+	driver_state_destroy(state);
+	return err;
+}
+
+static struct sync_fence *intel_adf_device_complete_fence(
+	struct adf_device *dev, struct adf_post *cfg, void *driver_state)
+{
+	struct intel_adf_device *i_dev = to_intel_dev(dev);
+	struct intel_adf_sync_timeline *tl = i_dev->post_timeline;
+	struct driver_state *state = driver_state;
+	struct sync_fence *post_fence;
+	u64 timestamp;
+
+	timestamp = ktime_to_ns(ktime_get());
+	state->timestamp = timestamp;
+
+	post_fence = intel_adf_sync_fence_create(tl, timestamp);
+	if (!post_fence)
+		return ERR_PTR(-ENOMEM);
+
+	return post_fence;
+}
+
+static void disable_unused_overlay_engines(struct list_head *active_engs,
+	struct post_obj_set *post_engs)
+{
+	struct intel_adf_overlay_engine *eng;
+
+	list_for_each_entry(eng, active_engs, active_list) {
+		if (post_obj_set_find_obj(post_engs, eng))
+			continue;
+		/*disable this engine*/
+		eng->plane->ops->disable(eng->plane);
+	}
+}
+
+static void update_active_overlay_engines(struct list_head *active_engs,
+	struct post_obj_set *post_engs)
+{
+	struct intel_adf_overlay_engine *eng, *tmp;
+	struct post_obj *po;
+
+	list_for_each_entry_safe(eng, tmp, active_engs, active_list) {
+		list_del_init(&eng->active_list);
+	}
+
+	for_each_post_obj(po, post_engs) {
+		eng = po->obj;
+		INIT_LIST_HEAD(&eng->active_list);
+		list_add_tail(&eng->active_list, active_engs);
+	}
+}
+
+static void update_active_interfaces(struct list_head *active_intfs,
+	struct post_obj_set *post_intfs)
+{
+	struct intel_adf_interface *intf, *tmp;
+	struct post_obj *po;
+
+	list_for_each_entry_safe(intf, tmp, active_intfs, active_list) {
+		list_del_init(&intf->active_list);
+	}
+
+	for_each_post_obj(po, post_intfs) {
+		intf = po->obj;
+		INIT_LIST_HEAD(&intf->active_list);
+		list_add_tail(&intf->active_list, active_intfs);
+	}
+}
+
+static void intel_adf_device_post(struct adf_device *dev,
+				struct adf_post *cfg,
+				void *driver_state)
+{
+	struct intel_adf_device *i_dev = to_intel_dev(dev);
+	struct driver_state *state = driver_state;
+	struct intel_adf_overlay_engine *eng;
+	struct intel_adf_interface *intf;
+	struct post_obj *po;
+	struct flip *f;
+
+	/*disable unused overlay engines*/
+	disable_unused_overlay_engines(&i_dev->active_engs,
+		&state->post_engs);
+
+	/* To forbid DSR */
+	for_each_post_obj(po, &state->post_intfs) {
+		intf = po->obj;
+		if (intf->pipe && intf->pipe->ops && intf->pipe->ops->pre_post)
+			intf->pipe->ops->pre_post(intf->pipe);
+	}
+
+	/*flip planes*/
+	list_for_each_entry(f, &state->post_flips, list) {
+		eng = f->eng;
+		if (!eng->plane || !eng->plane->ops || !eng->plane->ops->flip) {
+			dev_err(dev->dev, "%s: invalid plane\n", __func__);
+			return;
+		}
+		eng->plane->ops->flip(eng->plane, &f->buf, &f->config);
+	}
+
+	/*trigger pipe processing, if necessary*/
+	for_each_post_obj(po, &state->post_intfs) {
+		intf = po->obj;
+		if (intf->pipe && intf->pipe->ops && intf->pipe->ops->on_post)
+			intf->pipe->ops->on_post(intf->pipe);
+	}
+
+	update_active_overlay_engines(&i_dev->active_engs,
+		&state->post_engs);
+	update_active_interfaces(&i_dev->active_intfs, &state->post_intfs);
+}
+
+static struct sync_fence *create_vsync_fence(struct post_obj_set *intfs_set)
+{
+	struct sync_fence *vsync_fence, *fence, *merged_fence;
+	struct intel_adf_interface *intf;
+	struct post_obj *po;
+
+	vsync_fence = NULL;
+	for_each_post_obj(po, intfs_set) {
+		intf = po->obj;
+		fence = intel_adf_interface_create_vsync_fence(intf, 1);
+		if (!fence)
+			continue;
+
+		if (!vsync_fence)
+			vsync_fence = fence;
+		else {
+			merged_fence = sync_fence_merge("intel-adf",
+				vsync_fence, fence);
+			if (!merged_fence)
+				continue;
+			sync_fence_put(vsync_fence);
+			sync_fence_put(fence);
+
+			vsync_fence = merged_fence;
+		}
+	}
+
+	return vsync_fence;
+}
+
+static void intel_adf_device_advance_timeline(struct adf_device *dev,
+	struct adf_post *cfg, void *driver_state)
+{
+	struct driver_state *state = driver_state;
+	struct sync_fence *vsync_fence;
+	int err;
+
+	vsync_fence = create_vsync_fence(&state->post_intfs);
+	if (!vsync_fence) {
+		dev_err(dev->dev, "%s: failed to create vsync fence\n",
+			__func__);
+		return;
+	}
+
+	/*wait for vsync fence*/
+	err = sync_fence_wait(vsync_fence, INTEL_VSYNC_FENCE_TIMEOUT);
+	if (err == -ETIME) {
+		dev_err(dev->dev, "%s: vsync fence wait timeout\n", __func__);
+		goto out_err0;
+	} else if (err < 0) {
+		dev_err(dev->dev, "%s: vsync fence wait err\n", __func__);
+		goto out_err0;
+	}
+out_err0:
+	sync_fence_put(vsync_fence);
+	return;
+}
+
+static void intel_adf_device_state_free(struct adf_device *dev,
+				void *driver_state)
+{
+	struct intel_adf_device *i_dev = to_intel_dev(dev);
+	struct driver_state *state = driver_state;
+
+	/*signal post timeline*/
+	intel_adf_sync_timeline_signal(i_dev->post_timeline,
+		state->timestamp);
+
+	driver_state_destroy(driver_state);
+}
+
+static const struct adf_device_ops intel_adf_device_ops = {
+	.owner = THIS_MODULE,
+	.validate_custom_format = intel_adf_device_validate_custom_format,
+	.validate = intel_adf_device_validate,
+	.post = intel_adf_device_post,
+	.complete_fence = intel_adf_device_complete_fence,
+	.advance_timeline = intel_adf_device_advance_timeline,
+	.state_free = intel_adf_device_state_free,
+};
+/*----------------------------------------------------------------------------*/
+struct intel_adf_device *intel_adf_device_create(struct pci_dev *pdev,
+	struct intel_dc_memory *mem)
+{
+	int err = 0;
+	struct intel_adf_device *dev;
+	unsigned long reg_phy;
+	u8 *mmio;
+
+	dev_info(&pdev->dev, "%s\n", __func__);
+
+	if (!pdev) {
+		dev_err(&pdev->dev, "%s: invalid pci device\n", __func__);
+		return ERR_PTR(-EINVAL);
+	}
+
+	/*allocate adf device*/
+	dev = kzalloc(sizeof(struct intel_adf_device), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&pdev->dev, "%s: failed to allocate adf device\n",
+			__func__);
+		goto err_out0;
+	}
+
+	INIT_LIST_HEAD(&dev->active_intfs);
+	INIT_LIST_HEAD(&dev->active_engs);
+	dev->pdev = pdev;
+
+	/*mmio init*/
+	reg_phy = pci_resource_start(dev->pdev, 0) + INTEL_DC_REG_OFFSET;
+	mmio = ioremap(reg_phy, INTEL_DC_REG_SIZE);
+	if (!mmio) {
+		dev_err(&pdev->dev, "%s: failed to map display mmio\n",
+			__func__);
+		err = -ENOMEM;
+		goto err_out1;
+	}
+	dev->mmio = mmio;
+
+	/*create post timeline*/
+	dev->post_timeline = intel_adf_sync_timeline_create("post");
+	if (!dev->post_timeline) {
+		dev_err(&pdev->dev, "%s: failed to create post timeline\n",
+			__func__);
+		err = -ENOMEM;
+		goto err_out2;
+	}
+	/*signal post timeline*/
+	intel_adf_sync_timeline_signal(dev->post_timeline,
+		ktime_to_ns(ktime_get()));
+
+	/*adf device init*/
+	err = adf_device_init(&dev->base, &pdev->dev,
+			&intel_adf_device_ops, INTEL_ADF_DEVICE_NAME);
+	if (err) {
+		dev_err(&pdev->dev, "%s: failed to init adf device, %d\n",
+			__func__, err);
+		goto err_out3;
+	}
+
+	/*init mm*/
+	err = intel_adf_mm_init(&dev->mm, &dev->base.base.dev, mem);
+	if (err) {
+		dev_err(&pdev->dev, "%s: failed to init adf memory manager\n",
+			__func__);
+		goto err_out4;
+	}
+
+	g_intel_adf_dev = dev;
+
+	dev_info(&pdev->dev, "%s: success\n", __func__);
+
+	return dev;
+err_out4:
+	adf_device_destroy(&dev->base);
+err_out3:
+	intel_adf_sync_timeline_destroy(dev->post_timeline);
+err_out2:
+	iounmap(mmio);
+err_out1:
+	kfree(dev);
+err_out0:
+	return ERR_PTR(err);
+}
+
+void intel_adf_device_destroy(struct intel_adf_device *dev)
+{
+	if (dev) {
+		intel_adf_mm_destroy(&dev->mm);
+		adf_device_destroy(&dev->base);
+		intel_adf_sync_timeline_destroy(dev->post_timeline);
+		iounmap(dev->mmio);
+		kfree(dev);
+	}
+}
diff --git a/drivers/video/adf/intel/intel_adf_fbdev.c b/drivers/video/adf/intel/intel_adf_fbdev.c
new file mode 100644
index 0000000..c759495
--- /dev/null
+++ b/drivers/video/adf/intel/intel_adf_fbdev.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <video/adf_client.h>
+#include <video/adf_fbdev.h>
+#include <video/adf_format.h>
+
+#include "intel_adf.h"
+
+static struct fb_ops intel_fbdev_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = adf_fbdev_open,
+	.fb_release = adf_fbdev_release,
+	.fb_check_var = adf_fbdev_check_var,
+	.fb_set_par = adf_fbdev_set_par,
+	.fb_blank = adf_fbdev_blank,
+	.fb_pan_display = adf_fbdev_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_mmap = adf_fbdev_mmap,
+};
+
+int intel_adf_fbdev_init(struct adf_fbdev *fbdev,
+			struct intel_adf_interface *intf,
+			struct intel_adf_overlay_engine *eng)
+{
+	struct drm_mode_modeinfo mode;
+	struct adf_device *parent;
+	struct device *dev;
+	int err;
+
+	if (!fbdev || !intf || !eng)
+		return -EINVAL;
+
+	parent = adf_interface_parent(&intf->base);
+	dev = &parent->base.dev;
+
+	/*get current mode*/
+	adf_interface_current_mode(&intf->base, &mode);
+
+	err = adf_fbdev_init(fbdev, &intf->base, &eng->base,
+			mode.hdisplay, mode.vdisplay,
+			DRM_FORMAT_XRGB8888,
+			&intel_fbdev_ops, "intel_fbdev");
+	if (err) {
+		dev_err(dev, "%s: failed to init fbdev\n", __func__);
+		goto out_err;
+	}
+
+	return 0;
+out_err:
+	return err;
+}
+
+void intel_adf_fbdev_destroy(struct adf_fbdev *fbdev)
+{
+	if (fbdev)
+		adf_fbdev_destroy(fbdev);
+}
+
diff --git a/drivers/video/adf/intel/intel_adf_interface.c b/drivers/video/adf/intel/intel_adf_interface.c
new file mode 100644
index 0000000..05bcff2
--- /dev/null
+++ b/drivers/video/adf/intel/intel_adf_interface.c
@@ -0,0 +1,460 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <video/adf_client.h>
+#include "intel_adf.h"
+
+static long intel_interface_obj_ioctl(struct adf_obj *obj,
+	unsigned int cmd, unsigned long arg)
+{
+	return -EOPNOTSUPP;
+}
+
+static u32 to_intel_pipe_event(enum adf_event_type event)
+{
+	u32 pipe_event;
+
+	switch (event) {
+	case ADF_EVENT_VSYNC:
+		pipe_event =  INTEL_PIPE_EVENT_VSYNC;
+		break;
+	case ADF_EVENT_HOTPLUG:
+		pipe_event = (INTEL_PIPE_EVENT_HOTPLUG_CONNECTED |
+			INTEL_PIPE_EVENT_HOTPLUG_DISCONNECTED);
+		break;
+	default:
+		pipe_event = INTEL_PIPE_EVENT_UNKNOWN;
+		break;
+	}
+
+	return pipe_event;
+}
+
+static bool intel_interface_obj_supports_event(struct adf_obj *obj,
+	enum adf_event_type type)
+{
+	u32 pipe_event = to_intel_pipe_event(type);
+	struct adf_interface *intf = adf_obj_to_interface(obj);
+	struct intel_adf_interface *i_intf = to_intel_intf(intf);
+	struct intel_pipe *pipe = i_intf->pipe;
+	u32 supported_events;
+
+	if (!pipe || !pipe->ops || !pipe->ops->get_supported_events)
+		return false;
+
+	if (pipe_event == INTEL_PIPE_EVENT_UNKNOWN)
+		return false;
+
+	supported_events = pipe->ops->get_supported_events(pipe);
+
+	if ((supported_events & pipe_event) != pipe_event)
+		return false;
+
+	return true;
+}
+
+static void intel_interface_obj_set_event(struct adf_obj *obj,
+	enum adf_event_type type, bool enabled)
+{
+	u32 pipe_event = to_intel_pipe_event(type);
+	struct adf_interface *intf = adf_obj_to_interface(obj);
+	struct intel_adf_interface *i_intf = to_intel_intf(intf);
+	struct intel_pipe *pipe = i_intf->pipe;
+
+	if (!pipe || !pipe->ops || !pipe->ops->set_event)
+		return;
+
+	if (pipe_event == INTEL_PIPE_EVENT_UNKNOWN)
+		return;
+
+	pipe->ops->set_event(pipe, pipe_event, enabled);
+}
+
+static int intel_interface_blank(struct adf_interface *intf, u8 state)
+{
+	struct adf_device *parent = adf_interface_parent(intf);
+	struct device *dev = &parent->base.dev;
+	struct intel_adf_interface *i_intf = to_intel_intf(intf);
+	struct intel_pipe *pipe = i_intf->pipe;
+
+	dev_info(dev, "%s: state %d\n", __func__, state);
+
+	if (!pipe || !pipe->ops || !pipe->ops->dpms)
+		return -EOPNOTSUPP;
+
+	return pipe->ops->dpms(pipe, state);
+}
+
+static int intel_interface_alloc_simple_buffer(struct adf_interface *intf,
+	u16 w, u16 h, u32 format, struct dma_buf **dma_buf, u32 *offset,
+	u32 *pitch)
+{
+	struct intel_adf_device *dev = intf_to_dev(intf);
+	struct intel_adf_mm *mm = &dev->mm;
+	u8 bpp = adf_format_bpp(format);
+	u32 stride = ((w * bpp / 8) + 63) & ~63;
+	u32 size = stride * h;
+
+	*offset = 0;
+	*pitch = stride;
+
+	dev_info(dev->base.dev, "%s: size %d\n", __func__, size);
+
+	/*allocate buffer*/
+	return intel_adf_mm_alloc_buf(mm, size, dma_buf);
+}
+
+static int intel_interface_describe_simple_post(
+					struct adf_interface *intf,
+					struct adf_buffer *fb,
+					void *data,
+					size_t *size)
+{
+	struct intel_adf_device *adf_dev = intf_to_dev(intf);
+	struct device *dev = adf_dev->base.dev;
+	struct intel_adf_post_custom_data *custom_data = data;
+	size_t custom_size;
+
+	dev_info(dev, "%s: buffer %dx%d\n", __func__, fb->w, fb->h);
+
+	custom_size = sizeof(struct intel_adf_post_custom_data) +
+			sizeof(struct intel_adf_overlay);
+
+	custom_data->version = INTEL_ADF_VERSION;
+	custom_data->flags = 0;
+	custom_data->num_overlays = 1;
+	custom_data->overlays[0].plane.overlay_id = -1;
+	custom_data->overlays[0].plane.inteface_id = intf->idx;
+	custom_data->overlays[0].plane.buffer_id = 0;
+	custom_data->overlays[0].plane.flags = 0;
+	custom_data->overlays[0].plane.dst_x = 0;
+	custom_data->overlays[0].plane.dst_y = 0;
+	custom_data->overlays[0].plane.dst_w = fb->w;
+	custom_data->overlays[0].plane.dst_h = fb->h;
+	custom_data->overlays[0].plane.src_x = 0;
+	custom_data->overlays[0].plane.src_y = 0;
+	custom_data->overlays[0].plane.src_w = fb->w;
+	custom_data->overlays[0].plane.src_h = fb->h;
+	custom_data->overlays[0].plane.alpha = 0xff;
+	custom_data->overlays[0].plane.compression = INTEL_ADF_UNCOMPRESSED;
+	custom_data->overlays[0].plane.blending = INTEL_ADF_BLENDING_NONE;
+	custom_data->overlays[0].plane.transform = INTEL_ADF_TRANSFORM_NONE;
+
+	*size = custom_size;
+
+	return 0;
+}
+
+static int intel_interface_modeset(struct adf_interface *intf,
+				struct drm_mode_modeinfo *mode)
+{
+	struct intel_adf_device *adf_dev = intf_to_dev(intf);
+	struct device *dev = adf_dev->base.dev;
+	struct intel_adf_interface *i_intf = to_intel_intf(intf);
+	struct intel_pipe *pipe = i_intf->pipe;
+
+	if (!mode) {
+		dev_err(dev, "%s: invalid mode\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!pipe || !pipe->ops || !pipe->ops->modeset)
+		return -EOPNOTSUPP;
+
+	return pipe->ops->modeset(pipe, mode);
+}
+
+static int intel_interface_screen_size(struct adf_interface *intf,
+				u16 *width_mm, u16 *height_mm)
+{
+	struct intel_adf_interface *i_intf = to_intel_intf(intf);
+	struct intel_pipe *pipe = i_intf->pipe;
+
+	if (!pipe || !pipe->ops || !pipe->ops->get_screen_size)
+		return -EOPNOTSUPP;
+
+	return pipe->ops->get_screen_size(pipe, width_mm, height_mm);
+}
+
+
+static const struct adf_interface_ops intel_adf_interface_ops = {
+	.base = {
+		.ioctl = intel_interface_obj_ioctl,
+		.supports_event = intel_interface_obj_supports_event,
+		.set_event = intel_interface_obj_set_event,
+	},
+	.blank = intel_interface_blank,
+	.alloc_simple_buffer = intel_interface_alloc_simple_buffer,
+	.describe_simple_post = intel_interface_describe_simple_post,
+	.modeset = intel_interface_modeset,
+	.screen_size = intel_interface_screen_size,
+	.type_str = adf_interface_type_str
+};
+
+static inline enum adf_interface_type to_adf_interface_type(
+		enum intel_pipe_type type)
+{
+	switch (type) {
+	case INTEL_PIPE_DSI:
+		return ADF_INTF_DSI;
+	case INTEL_PIPE_HDMI:
+		return ADF_INTF_HDMI;
+	default:
+		return ADF_INTF_TYPE_MAX;
+	}
+}
+
+static int set_preferred_mode(struct intel_adf_interface *intf)
+{
+	struct intel_pipe *pipe = intf->pipe;
+	struct drm_mode_modeinfo *preferred_mode;
+	struct drm_mode_modeinfo *modelist;
+	size_t n_modes;
+	int err;
+
+	if (!pipe || !pipe->ops || !pipe->ops->get_preferred_mode ||
+		!pipe->ops->get_modelist)
+		return -EINVAL;
+
+	pipe->ops->get_modelist(pipe, &modelist, &n_modes);
+	pipe->ops->get_preferred_mode(pipe, &preferred_mode);
+
+
+	err = adf_interface_set_mode(&intf->base, preferred_mode);
+	if (err)
+		goto out_err0;
+
+	err = adf_interface_blank(&intf->base, DRM_MODE_DPMS_ON);
+	if (err)
+		goto out_err0;
+
+	adf_hotplug_notify_connected(&intf->base, modelist, n_modes);
+
+	return 0;
+out_err0:
+	return err;
+}
+
+static void hotplug_connected_work_func(struct kthread_work *work)
+{
+	struct intel_adf_interface *intf =
+		container_of(work, struct intel_adf_interface,
+		hotplug_connected_work);
+
+	set_preferred_mode(intf);
+}
+
+static void handle_vsync_event(struct intel_adf_interface *intf)
+{
+	struct intel_pipe *pipe = intf->pipe;
+	ktime_t timestamp;
+	u32 seqno;
+
+	if (!pipe || !pipe->ops || !pipe->ops->get_vsync_counter)
+		return;
+
+	timestamp = ktime_get();
+	seqno = pipe->ops->get_vsync_counter(pipe, 0);
+
+	pr_debug("%s: get vsync event on %llu, seqno = %u\n", __func__,
+		ktime_to_ms(timestamp), seqno);
+
+	adf_vsync_notify(&intf->base, timestamp);
+
+	intel_adf_sync_timeline_signal(intf->vsync_timeline, seqno);
+}
+
+static void handle_hotplug_connected(struct intel_adf_interface *intf)
+{
+	struct intel_pipe *pipe = intf->pipe;
+
+	if (!pipe || !pipe->ops || !pipe->ops->is_screen_connected)
+		return;
+
+	if (pipe->ops->is_screen_connected(pipe))
+		queue_kthread_work(&intf->event_handling_worker,
+			&intf->hotplug_connected_work);
+}
+
+static void handle_hotplug_disconnected(struct intel_adf_interface *intf)
+{
+
+}
+
+int intel_adf_interface_handle_event(struct intel_adf_interface *intf)
+{
+	struct intel_pipe *pipe = intf->pipe;
+	u32 events = 0;
+
+	if (!pipe || !pipe->ops || !pipe->ops->get_events)
+		return IRQ_NONE;
+
+	pipe->ops->get_events(pipe, &events);
+
+	if (!events)
+		return IRQ_NONE;
+
+	if (events & INTEL_PIPE_EVENT_VSYNC) {
+		handle_vsync_event(intf);
+		events &= ~INTEL_PIPE_EVENT_VSYNC;
+	}
+
+	if (events & INTEL_PIPE_EVENT_HOTPLUG_CONNECTED) {
+		handle_hotplug_connected(intf);
+		events &= ~INTEL_PIPE_EVENT_HOTPLUG_CONNECTED;
+	}
+
+	if (events & INTEL_PIPE_EVENT_HOTPLUG_DISCONNECTED) {
+		handle_hotplug_disconnected(intf);
+		events &= ~INTEL_PIPE_EVENT_HOTPLUG_DISCONNECTED;
+	}
+
+	if (events && pipe->ops->handle_events)
+		pipe->ops->handle_events(pipe, events);
+
+	return IRQ_HANDLED;
+}
+
+struct sync_fence *intel_adf_interface_create_vsync_fence(
+	struct intel_adf_interface *intf, u32 interval)
+{
+	struct intel_pipe *pipe;
+	u64 value;
+
+	if (!intf || !interval)
+		return NULL;
+
+	pipe = intf->pipe;
+	if (!pipe || !pipe->ops || !pipe->ops->get_vsync_counter)
+		return NULL;
+
+	value = pipe->ops->get_vsync_counter(pipe, interval);
+
+	return intel_adf_sync_fence_create(intf->vsync_timeline, value);
+}
+
+int intel_adf_interface_init(struct intel_adf_interface *intf,
+		struct intel_adf_device *dev, struct intel_pipe *pipe)
+{
+	enum adf_interface_type type;
+	u32 flags = 0;
+	int err;
+
+	if (!intf || !dev || !pipe || !pipe->ops ||
+		!pipe->ops->is_screen_connected ||
+		!pipe->ops->get_vsync_counter)
+		return -EINVAL;
+
+	memset(intf, 0, sizeof(struct intel_adf_interface));
+
+	INIT_LIST_HEAD(&intf->active_list);
+
+	if (pipe->primary)
+		flags |= ADF_INTF_FLAG_PRIMARY;
+	else
+		flags |= ADF_INTF_FLAG_EXTERNAL;
+
+	type = to_adf_interface_type(pipe->type);
+	if (type == ADF_INTF_TYPE_MAX) {
+		dev_err(dev->base.dev, "%s: invalid pipe type %d\n",
+			__func__, pipe->type);
+		return -EINVAL;
+	}
+
+	if (pipe->ops->hw_init) {
+		err = pipe->ops->hw_init(pipe);
+		if (err) {
+			dev_err(dev->base.dev, "%s: failed to init pipe\n",
+				__func__);
+			goto out_err0;
+		}
+	}
+
+	intf->pipe = pipe;
+	init_kthread_worker(&intf->event_handling_worker);
+	init_kthread_work(&intf->hotplug_connected_work,
+		hotplug_connected_work_func);
+	intf->event_handling_thread = kthread_run(kthread_worker_fn,
+		&intf->event_handling_worker, "intf-worker-%d", pipe->base.idx);
+	if (IS_ERR(intf->event_handling_thread)) {
+		dev_err(dev->base.dev,
+			"%s: failed to create event handling thread\n",
+			__func__);
+		err = PTR_ERR(intf->event_handling_thread);
+		goto out_err1;
+	}
+
+	/*create vsync timeline*/
+	intf->vsync_timeline = intel_adf_sync_timeline_create("vsync");
+	if (IS_ERR(intf->vsync_timeline)) {
+		dev_err(dev->base.dev, "%s: failed to create vsync timeline\n",
+			__func__);
+		err = PTR_ERR(intf->vsync_timeline);
+		goto out_err2;
+	}
+	/*signal vsync timeline*/
+	intel_adf_sync_timeline_signal(intf->vsync_timeline,
+		pipe->ops->get_vsync_counter(pipe, 0));
+
+	err = adf_interface_init(&intf->base, &dev->base, type,
+				(u32)pipe->base.idx, flags,
+				&intel_adf_interface_ops, "intel_intf_%s",
+				pipe->base.name);
+	if (err)
+		goto out_err3;
+
+	/*turn on this interface if screen was connected*/
+	if (pipe->ops->is_screen_connected(pipe)) {
+		err = set_preferred_mode(intf);
+		if (err) {
+			dev_err(dev->base.dev, "%s: failed to handle hotplug\n",
+				__func__);
+			goto out_err4;
+		}
+	}
+	return 0;
+out_err4:
+	adf_interface_destroy(&intf->base);
+out_err3:
+	intel_adf_sync_timeline_destroy(intf->vsync_timeline);
+out_err2:
+	kthread_stop(intf->event_handling_thread);
+out_err1:
+	if (pipe->ops->hw_deinit)
+		pipe->ops->hw_deinit(pipe);
+out_err0:
+	return err;
+}
+
+void intel_adf_interface_destroy(struct intel_adf_interface *intf)
+{
+	struct intel_pipe *pipe;
+
+	if (intf) {
+		if (intf->event_handling_thread) {
+			flush_kthread_worker(&intf->event_handling_worker);
+			kthread_stop(intf->event_handling_thread);
+		}
+
+		pipe = intf->pipe;
+		if (pipe && pipe->ops && pipe->ops->hw_deinit)
+			pipe->ops->hw_deinit(pipe);
+
+		intel_adf_sync_timeline_destroy(intf->vsync_timeline);
+
+		intf->pipe = NULL;
+		adf_interface_destroy(&intf->base);
+	}
+}
diff --git a/drivers/video/adf/intel/intel_adf_mm.c b/drivers/video/adf/intel/intel_adf_mm.c
new file mode 100644
index 0000000..bae4361
--- /dev/null
+++ b/drivers/video/adf/intel/intel_adf_mm.c
@@ -0,0 +1,516 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/device.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+
+#include "intel_adf_device.h"
+#include "intel_adf_mm.h"
+
+#define INTEL_DMA_FD_FLAGS		O_CLOEXEC
+
+/*----------------------------------------------------------------------------*/
+struct intel_dma_buf {
+	struct intel_adf_mm *mm;
+
+	struct mutex lock;
+	struct kref buf_ref;
+	enum intel_dma_buf_type type;
+	/*back storage info*/
+	struct intel_dc_buffer *buf;
+
+	/*vmapping*/
+	void *vmapping;
+	int vmapping_ref;
+};
+
+static void intel_dma_buf_destroy(struct kref *ref)
+{
+	struct intel_dma_buf *priv =
+		container_of(ref, struct intel_dma_buf, buf_ref);
+	struct intel_dc_buffer *dc_buf = priv->buf;
+	struct intel_adf_mm *mm = priv->mm;
+
+	intel_dc_memory_free(mm->mem, dc_buf);
+	kfree(priv);
+}
+
+static struct intel_dma_buf *intel_dma_buf_alloc(struct intel_adf_mm *mm,
+	struct page **pages, u32 page_num, void *vaddr, u32 size,
+	enum intel_dma_buf_type type)
+{
+	struct device *dev = mm->parent;
+	struct intel_dma_buf *priv;
+	struct intel_dc_buffer *buf;
+	u32 handle;
+	int err = 0;
+
+	priv = kzalloc(sizeof(struct intel_dma_buf), GFP_KERNEL);
+	if (!priv) {
+		dev_err(dev, "%s: failed to allocate buffer private\n",
+			__func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/*import this buffer to DC memory*/
+	handle = (u32)priv;
+	buf = intel_dc_memory_import(mm->mem, handle, pages, page_num);
+	if (IS_ERR(buf)) {
+		dev_err(dev, "%s: failed to import pages\n", __func__);
+		err = PTR_ERR(buf);
+		goto out_err0;
+	}
+
+	priv->mm = mm;
+	priv->type = type;
+	priv->buf = buf;
+	if (vaddr && (type == INTEL_DMA_BUF_ALLOCATED)) {
+		priv->vmapping = vaddr;
+		priv->vmapping_ref++;
+	}
+	kref_init(&priv->buf_ref);
+	mutex_init(&priv->lock);
+
+	return priv;
+out_err0:
+	kfree(priv);
+	return ERR_PTR(err);
+}
+
+static inline void intel_dma_buf_get(struct intel_dma_buf *buf)
+{
+	kref_get(&buf->buf_ref);
+}
+
+static inline int intel_dma_buf_put(struct intel_dma_buf *buf)
+{
+	return kref_put(&buf->buf_ref, intel_dma_buf_destroy);
+}
+
+static inline u32 intel_dma_buf_get_gtt(struct intel_dma_buf *buf)
+{
+	struct intel_dc_buffer *dc_buf = buf->buf;
+	return dc_buf->dc_mem_addr;
+}
+
+static inline u32 intel_dma_buf_get_size(struct intel_dma_buf *buf)
+{
+	struct intel_dc_buffer *dc_buf = buf->buf;
+	return dc_buf->n_pages << PAGE_SHIFT;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static int intel_attach(struct dma_buf *buf, struct device *dev,
+	struct dma_buf_attachment *attachment)
+{
+	intel_dma_buf_get(buf->priv);
+	return 0;
+}
+
+static void intel_detach(struct dma_buf *buf,
+	struct dma_buf_attachment *attachment)
+{
+	intel_dma_buf_put(buf->priv);
+}
+
+static struct sg_table *intel_map_dma_buf(
+	struct dma_buf_attachment *attachment,
+	enum dma_data_direction direction)
+{
+	struct intel_dma_buf *priv = attachment->dmabuf->priv;
+	struct intel_dc_buffer *dc_buf = priv->buf;
+	struct sg_table *table;
+	int err;
+
+	table = kzalloc(sizeof(struct sg_table), GFP_KERNEL);
+	if (!table)
+		return ERR_PTR(-ENOMEM);
+
+	mutex_lock(&priv->lock);
+
+	err = sg_alloc_table_from_pages(table, dc_buf->pages,
+				dc_buf->n_pages,
+				0,
+				dc_buf->n_pages << PAGE_SHIFT,
+				GFP_KERNEL);
+	if (err)
+		goto out_err0;
+
+	mutex_unlock(&priv->lock);
+
+	return table;
+out_err0:
+	kfree(table);
+	mutex_unlock(&priv->lock);
+	return ERR_PTR(err);
+}
+
+static void intel_unmap_dma_buf(struct dma_buf_attachment *attachment,
+	struct sg_table *sg, enum dma_data_direction direction)
+{
+	struct intel_dma_buf *priv = attachment->dmabuf->priv;
+
+	mutex_lock(&priv->lock);
+
+	sg_free_table(sg);
+	kfree(sg);
+
+	mutex_unlock(&priv->lock);
+}
+
+static void intel_release(struct dma_buf *buf)
+{
+
+}
+
+static void *intel_kmap_atomic(struct dma_buf *buf, unsigned long page_num)
+{
+	return NULL;
+}
+
+static void *intel_kmap(struct dma_buf *buf, unsigned long page_num)
+{
+	return NULL;
+}
+
+static int intel_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	int page_num = 0;
+	int i;
+	unsigned long address = 0;
+	int ret;
+	unsigned long pfn;
+	struct intel_dma_buf *priv = vma->vm_private_data;
+	struct intel_dc_buffer *dc_buf = priv->buf;
+
+	page_num = PAGE_ALIGN((vma->vm_end - vma->vm_start)) >> PAGE_SHIFT;
+
+	if (page_num != dc_buf->n_pages)
+		return VM_FAULT_NOPAGE;
+
+	address = (unsigned long)vmf->virtual_address;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	for (i = 0; i < page_num; i++) {
+		pfn = page_to_pfn(dc_buf->pages[i]);
+
+		ret = vm_insert_mixed(vma, address, pfn);
+		if (unlikely((ret == -EBUSY) || (ret != 0 && i > 0)))
+			break;
+		else if (unlikely(ret != 0)) {
+			ret = (ret == -ENOMEM) ? VM_FAULT_OOM : VM_FAULT_SIGBUS;
+			return ret;
+		}
+
+		address += PAGE_SIZE;
+	}
+
+	return VM_FAULT_NOPAGE;
+}
+
+static void intel_vm_open(struct vm_area_struct *vma)
+{
+}
+
+static void intel_vm_close(struct vm_area_struct *vma)
+{
+}
+
+static struct vm_operations_struct intel_vm_ops = {
+	.fault = intel_vm_fault,
+	.open = intel_vm_open,
+	.close = intel_vm_close
+};
+
+static int intel_mmap(struct dma_buf *buf, struct vm_area_struct *vma)
+{
+	struct intel_dma_buf *priv = buf->priv;
+
+	if (vma->vm_pgoff != 0)
+		return -EACCES;
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+		return -EACCES;
+
+	vma->vm_ops = &intel_vm_ops;
+	vma->vm_private_data = (void *)priv;
+	vma->vm_flags |= VM_IO | VM_MIXEDMAP | VM_DONTEXPAND;
+
+	return 0;
+}
+
+static void *intel_vmap(struct dma_buf *buf)
+{
+	struct intel_dma_buf *priv = buf->priv;
+	struct intel_dc_buffer *dc_buf = priv->buf;
+
+	mutex_lock(&priv->lock);
+
+	if (priv->vmapping_ref)
+		goto out_success;
+
+	priv->vmapping = vmap(dc_buf->pages, dc_buf->n_pages,
+				0, PAGE_KERNEL);
+	if (!priv->vmapping) {
+		mutex_unlock(&priv->lock);
+		return ERR_PTR(-ENOMEM);
+	}
+out_success:
+	priv->vmapping_ref++;
+	mutex_unlock(&priv->lock);
+	return priv->vmapping;
+}
+
+static void intel_vunmap(struct dma_buf *buf, void *vaddr)
+{
+	struct intel_dma_buf *priv = buf->priv;
+
+	mutex_lock(&priv->lock);
+	if (--priv->vmapping_ref)
+		goto out_success;
+
+	vunmap(priv->vmapping);
+	priv->vmapping_ref = 0;
+	priv->vmapping = NULL;
+
+out_success:
+	mutex_unlock(&priv->lock);
+}
+
+static struct dma_buf_ops intel_dma_buf_ops = {
+	.attach = intel_attach,
+	.detach = intel_detach,
+	.map_dma_buf = intel_map_dma_buf,
+	.unmap_dma_buf = intel_unmap_dma_buf,
+	.release = intel_release,
+	.kmap_atomic = intel_kmap_atomic,
+	.kmap = intel_kmap,
+	.mmap = intel_mmap,
+	.vmap = intel_vmap,
+	.vunmap = intel_vunmap,
+};
+
+static int export_dma_buf(struct intel_dma_buf *priv, struct dma_buf **buf)
+{
+	struct dma_buf *dma_buf;
+
+	/*export dma buf*/
+	dma_buf = dma_buf_export((void *)priv, &intel_dma_buf_ops,
+		intel_dma_buf_get_size(priv), INTEL_DMA_FD_FLAGS);
+	if (IS_ERR(dma_buf))
+		return PTR_ERR(dma_buf);
+
+	*buf = dma_buf;
+
+	return 0;
+}
+
+/**
+ * intel_adf_mm_alloc_buf - allocate a buffer and export it as a dma buffer.
+ *
+ * @mm: memory manager
+ * @size: buffer size in bytes
+ * @buf: dma_buf which is exported
+ *
+ * Returns
+ */
+int intel_adf_mm_alloc_buf(struct intel_adf_mm *mm, u32 size,
+	struct dma_buf **buf)
+{
+	struct intel_dma_buf *priv;
+	struct device *dev;
+	struct page **pages;
+	u32 page_num;
+	void *vaddr;
+	int i;
+	int err = 0;
+
+	if (!mm || !buf)
+		return -EINVAL;
+
+	dev = mm->parent;
+
+	vaddr =  __vmalloc(size, (GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO),
+		__pgprot((pgprot_val(PAGE_KERNEL) & ~_PAGE_CACHE_MASK) |
+		_PAGE_CACHE_WC));
+	if (!vaddr) {
+		dev_err(dev, "%s: failed to allocate buffer\n", __func__);
+		return -ENOMEM;
+	}
+
+	/*get the page list*/
+	page_num = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	pages = kzalloc(page_num * sizeof(struct page *), GFP_KERNEL);
+	if (!pages) {
+		dev_err(dev, "%s: failed to allocate page list\n", __func__);
+		err = -ENOMEM;
+		goto out_err0;
+	}
+
+	/*populate the page list*/
+	for (i = 0; i < page_num; i++)
+		pages[i] = vmalloc_to_page(vaddr + i * PAGE_SIZE);
+
+	priv = intel_dma_buf_alloc(mm, pages, page_num, vaddr, size,
+		INTEL_DMA_BUF_ALLOCATED);
+	if (IS_ERR(priv)) {
+		dev_err(dev, "%s: failed to allocate private\n", __func__);
+		err = PTR_ERR(priv);
+		goto out_err1;
+	}
+
+	err = export_dma_buf(priv, buf);
+	if (err) {
+		dev_err(dev, "%s: failed to export dma buffer\n", __func__);
+		goto out_err2;
+	}
+
+	return 0;
+out_err2:
+	intel_dma_buf_put(priv);
+out_err1:
+	kfree(pages);
+out_err0:
+	vfree(vaddr);
+	return err;
+}
+
+void intel_adf_mm_free_buf(struct dma_buf *buf)
+{
+	struct intel_dma_buf *priv;
+
+	if (buf) {
+		priv = buf->priv;
+		intel_dma_buf_put(priv);
+	}
+}
+
+int intel_adf_mm_export(struct intel_adf_mm *mm, struct page **pages,
+	u32 page_num, void *vaddr, enum intel_dma_buf_type type,
+	struct dma_buf **buf)
+{
+	struct device *dev = mm->parent;
+	struct intel_dma_buf *priv;
+	u32 size;
+	int err;
+
+	if (!mm || !pages || !buf || !page_num)
+		return -EINVAL;
+
+	size = page_num << PAGE_SHIFT;
+
+	priv = intel_dma_buf_alloc(mm, pages, page_num, vaddr, size, type);
+	if (IS_ERR(priv)) {
+		dev_err(dev, "%s: failed to allocate private\n", __func__);
+		return PTR_ERR(priv);
+	}
+
+	err = export_dma_buf(priv, buf);
+	if (err) {
+		dev_err(dev, "%s: failed to export dma buffer\n", __func__);
+		goto err_out0;
+	}
+
+	return 0;
+err_out0:
+	intel_dma_buf_put(priv);
+	return err;
+}
+
+int intel_adf_mm_fd(struct dma_buf *buf)
+{
+	if (!buf)
+		return -EINVAL;
+
+	return dma_buf_fd(buf, INTEL_DMA_FD_FLAGS);
+}
+
+int intel_adf_mm_gtt(struct dma_buf *buf, u32 *gtt)
+{
+	struct intel_dma_buf *priv;
+
+	if (!buf || !gtt)
+		return -EINVAL;
+
+	priv = buf->priv;
+
+	if (!priv)
+		return -EINVAL;
+
+	*gtt = intel_dma_buf_get_gtt(priv);
+
+	return 0;
+}
+
+static inline struct adf_device *dev_to_adf_device(struct device *dev)
+{
+	return adf_obj_to_device(container_of(dev, struct adf_obj, dev));
+}
+
+static ssize_t display_memory_show(struct device *device,
+	struct device_attribute *attr, char *buf)
+{
+	struct intel_adf_device *dev =
+		to_intel_dev(dev_to_adf_device(device));
+	struct intel_adf_mm *mm = &dev->mm;
+	size_t n_total, n_alloc, n_free, n_bufs;
+
+	intel_dc_memory_status(mm->mem, &n_total, &n_alloc, &n_free,
+		&n_bufs);
+	return snprintf(buf, PAGE_SIZE,
+			"Total %lu MB, allocated %lu MB, free %lu MB, allocated %u buffers\n",
+		pages_to_mb(n_total),
+		pages_to_mb(n_alloc),
+		pages_to_mb(n_free),
+		(int) n_bufs);
+}
+
+static struct device_attribute mm_attrs[] = {
+	__ATTR_RO(display_memory),
+};
+
+int intel_adf_mm_init(struct intel_adf_mm *mm, struct device *parent,
+	struct intel_dc_memory *mem)
+{
+	int err;
+	int i;
+
+	if (!mm || !parent || !mem)
+		return -EINVAL;
+
+	memset(mm, 0, sizeof(struct intel_adf_mm));
+
+	mm->parent = parent;
+	mm->mem = mem;
+
+	for (i = 0; i < ARRAY_SIZE(mm_attrs); i++) {
+		err = device_create_file(parent, &mm_attrs[i]);
+		if (err)
+			goto out_err0;
+	}
+
+	return 0;
+out_err0:
+	return err;
+}
+
+void intel_adf_mm_destroy(struct intel_adf_mm *mm)
+{
+	if (mm) {
+		mm->parent = NULL;
+		mm->mem = NULL;
+	}
+}
+
diff --git a/drivers/video/adf/intel/intel_adf_overlay_engine.c b/drivers/video/adf/intel/intel_adf_overlay_engine.c
new file mode 100644
index 0000000..f1c90aa
--- /dev/null
+++ b/drivers/video/adf/intel/intel_adf_overlay_engine.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "intel_adf.h"
+
+int intel_adf_overlay_engine_init(struct intel_adf_overlay_engine *eng,
+			struct intel_adf_device *dev,
+			struct intel_plane *plane)
+{
+	if (!eng || !dev || !plane)
+		return -EINVAL;
+
+	memset(eng, 0, sizeof(struct intel_adf_overlay_engine));
+
+	INIT_LIST_HEAD(&eng->active_list);
+
+	eng->plane = plane;
+
+	return adf_overlay_engine_init(&eng->base, &dev->base,
+		&plane->ops->adf_ops, "intel_ov_eng_%s", plane->base.name);
+}
+
+void intel_adf_overlay_engine_destroy(
+			struct intel_adf_overlay_engine *eng)
+{
+	if (eng) {
+		eng->plane = NULL;
+		adf_overlay_engine_destroy(&eng->base);
+	}
+}
diff --git a/drivers/video/adf/intel/intel_adf_sync.c b/drivers/video/adf/intel/intel_adf_sync.c
new file mode 100644
index 0000000..73db3c7
--- /dev/null
+++ b/drivers/video/adf/intel/intel_adf_sync.c
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include "intel_adf_sync.h"
+
+static struct sync_pt *intel_adf_sync_pt_dup(struct sync_pt *pt)
+{
+	struct intel_adf_sync_pt *new_pt, *old_pt;
+	struct sync_timeline *tl;
+
+	tl = pt->parent;
+	old_pt = (struct intel_adf_sync_pt *)pt;
+
+	new_pt = (struct intel_adf_sync_pt *)sync_pt_create(tl,
+		sizeof(*new_pt));
+	if (!new_pt)
+		return NULL;
+
+	atomic64_set(&new_pt->value, atomic64_read(&old_pt->value));
+	return (struct sync_pt *)new_pt;
+}
+
+static int intel_adf_sync_pt_has_signaled(struct sync_pt *pt)
+{
+	struct intel_adf_sync_pt *i_pt = (struct intel_adf_sync_pt *)pt;
+	struct intel_adf_sync_timeline *tl =
+		(struct intel_adf_sync_timeline *)pt->parent;
+	u64 tl_value, pt_value;
+
+	tl_value = atomic64_read(&tl->value);
+	pt_value = atomic64_read(&i_pt->value);
+
+	return (tl_value >= pt_value) ? 1 : 0;
+}
+
+static int intel_adf_sync_pt_compare(struct sync_pt *a, struct sync_pt *b)
+{
+	struct intel_adf_sync_pt *a_pt = (struct intel_adf_sync_pt *)a;
+	struct intel_adf_sync_pt *b_pt = (struct intel_adf_sync_pt *)b;
+	u64 a_value, b_value, delta;
+	int ret;
+
+	a_value = atomic64_read(&a_pt->value);
+	b_value = atomic64_read(&b_pt->value);
+	delta = a_value - b_value;
+
+	if (delta > 0)
+		ret = 1;
+	else if (delta < 0)
+		ret = -1;
+	else
+		ret = 0;
+
+	return ret;
+}
+
+static void intel_adf_sync_timeline_value_str(struct sync_timeline *timeline,
+	char *str, int size)
+{
+	struct intel_adf_sync_timeline *tl =
+		(struct intel_adf_sync_timeline *)timeline;
+	snprintf(str, size, "%#lx", atomic64_read(&tl->value));
+}
+
+static void intel_adf_sync_pt_value_str(struct sync_pt *pt, char *str,
+	int size)
+{
+	struct intel_adf_sync_pt *i_pt =
+		(struct intel_adf_sync_pt *)pt;
+	snprintf(str, size, "%#lx", atomic64_read(&i_pt->value));
+}
+
+static const struct sync_timeline_ops intel_adf_sync_timeline_ops = {
+	.driver_name = "intel-adf-sync",
+	.dup = intel_adf_sync_pt_dup,
+	.has_signaled = intel_adf_sync_pt_has_signaled,
+	.compare = intel_adf_sync_pt_compare,
+	.timeline_value_str = intel_adf_sync_timeline_value_str,
+	.pt_value_str = intel_adf_sync_pt_value_str,
+};
+
+struct intel_adf_sync_timeline *intel_adf_sync_timeline_create(
+	const char *name)
+{
+	struct intel_adf_sync_timeline *tl;
+
+	tl = (struct intel_adf_sync_timeline *)sync_timeline_create(
+		&intel_adf_sync_timeline_ops, sizeof(*tl), name);
+	if (!tl)
+		return ERR_PTR(-ENOMEM);
+
+	atomic64_set(&tl->value, 0);
+	return tl;
+}
+
+void intel_adf_sync_timeline_destroy(struct intel_adf_sync_timeline *tl)
+{
+	if (tl)
+		sync_timeline_destroy(&tl->base);
+}
+
+struct sync_fence *intel_adf_sync_fence_create(
+	struct intel_adf_sync_timeline *tl, u64 value)
+{
+	struct sync_fence *fence;
+	struct intel_adf_sync_pt *pt;
+
+	if (!tl)
+		return NULL;
+
+	pt = (struct intel_adf_sync_pt *)sync_pt_create(&tl->base,
+		sizeof(*pt));
+	if (!pt)
+		return NULL;
+
+	atomic64_set(&pt->value, value);
+
+	fence = sync_fence_create("intel_adf", &pt->base);
+	if (!fence)
+		goto out_err0;
+
+	return fence;
+out_err0:
+	sync_pt_free(&pt->base);
+	return NULL;
+}
+
+void intel_adf_sync_fence_put(struct intel_adf_sync_timeline *tl,
+	struct sync_fence *fence)
+{
+	if (fence)
+		sync_fence_put(fence);
+}
+
+void intel_adf_sync_timeline_signal(struct intel_adf_sync_timeline *tl,
+	u64 value)
+{
+	if (tl) {
+		atomic64_set(&tl->value, value);
+		sync_timeline_signal(&tl->base);
+	}
+}
diff --git a/include/video/adf.h b/include/video/adf.h
index 2b742ab..3b13027 100644
--- a/include/video/adf.h
+++ b/include/video/adf.h
@@ -30,7 +30,6 @@
 #include <linux/wait.h>
 #include <linux/workqueue.h>
 #include <uapi/video/adf.h>
-#include "sync.h"
 
 struct adf_obj;
 struct adf_obj_ops;
-- 
1.7.9.5

