From 5355f76c20c1cf1c714facd2f9ed4ba4a78c2ab4 Mon Sep 17 00:00:00 2001
From: Andy Ross <andrew.j.ross@intel.com>
Date: Fri, 9 Jan 2015 13:35:08 -0800
Subject: [PATCH 1/3] gc0310/gc2155: Fork lift source from CTS

Original code provided by CTS for IRDA.  Not updated to gmin API nor
integrated in build yet.

Change-Id: I9f9b25044b288cb1d3a714737924f7e612a05ccb
Signed-off-by: Andy Ross <andrew.j.ross@intel.com>
---
 drivers/media/i2c/atomisp/Kconfig  |   17 +
 drivers/media/i2c/atomisp/Makefile |    2 +
 drivers/media/i2c/atomisp/gc0310.c | 1541 +++++++++++++++++++++++++++++++++++
 drivers/media/i2c/atomisp/gc0310.h |  460 +++++++++++
 drivers/media/i2c/atomisp/gc2155.c | 1577 ++++++++++++++++++++++++++++++++++++
 drivers/media/i2c/atomisp/gc2155.h | 1017 +++++++++++++++++++++++
 6 files changed, 4614 insertions(+)
 create mode 100644 drivers/media/i2c/atomisp/Kconfig
 create mode 100644 drivers/media/i2c/atomisp/Makefile
 create mode 100644 drivers/media/i2c/atomisp/gc0310.c
 create mode 100644 drivers/media/i2c/atomisp/gc0310.h
 create mode 100644 drivers/media/i2c/atomisp/gc2155.c
 create mode 100644 drivers/media/i2c/atomisp/gc2155.h

diff --git a/drivers/media/i2c/atomisp/Kconfig b/drivers/media/i2c/atomisp/Kconfig
new file mode 100644
index 0000000..3d37ff5
--- /dev/null
+++ b/drivers/media/i2c/atomisp/Kconfig
@@ -0,0 +1,17 @@
+config VIDEO_GC0310
+       tristate "GC0310 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Galaxycore
+         GC0310 0.3MP sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_GC2155
+       tristate "GC2155 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Galaxycore
+         GC2155 2MP sensor.
+
+         It currently only works with the atomisp driver.
diff --git a/drivers/media/i2c/atomisp/Makefile b/drivers/media/i2c/atomisp/Makefile
new file mode 100644
index 0000000..4b5a9d7
--- /dev/null
+++ b/drivers/media/i2c/atomisp/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_VIDEO_GC0310) += gc0310.o
+obj-$(CONFIG_VIDEO_GC2155) += gc2155.o
diff --git a/drivers/media/i2c/atomisp/gc0310.c b/drivers/media/i2c/atomisp/gc0310.c
new file mode 100644
index 0000000..1739c88
--- /dev/null
+++ b/drivers/media/i2c/atomisp/gc0310.c
@@ -0,0 +1,1541 @@
+/*
+ * Support for GalaxyCore GC0310 VGA camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/io.h>
+
+#include "gc0310.h"
+
+/* i2c read/write stuff */
+static int gc0310_read_reg(struct i2c_client *client,
+			   u16 data_length, u8 reg, u8 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[1];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != GC0310_8BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == GC0310_8BIT)
+		*val = (u8)data[0];
+
+	return 0;
+}
+
+static int gc0310_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int gc0310_write_reg(struct i2c_client *client, u16 data_length,
+							u8 reg, u8 val)
+{
+	int ret;
+	unsigned char data[2] = {0};
+	u8 *wreg = (u8 *)data;
+	const u16 len = data_length + sizeof(u8); /* 8-bit address + data */
+
+	if (data_length != GC0310_8BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = (u8)(reg & 0xff);
+
+	if (data_length == GC0310_8BIT) {
+		data[1] = (u8)(val);
+	}
+
+	ret = gc0310_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * gc0310_write_reg_array - Initializes a list of GC0310 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __gc0310_flush_reg_array, __gc0310_buf_reg_array() and
+ * __gc0310_write_reg_is_consecutive() are internal functions to
+ * gc0310_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __gc0310_flush_reg_array(struct i2c_client *client,
+				    struct gc0310_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u8) + ctrl->index; /* 8-bit address + data */
+	ctrl->buffer.addr = (u8)(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return gc0310_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __gc0310_buf_reg_array(struct i2c_client *client,
+				  struct gc0310_write_ctrl *ctrl,
+				  const struct gc0310_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case GC0310_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u8) >= GC0310_MAX_WRITE_BUF_SIZE)
+		return __gc0310_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int __gc0310_write_reg_is_consecutive(struct i2c_client *client,
+					     struct gc0310_write_ctrl *ctrl,
+					     const struct gc0310_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int gc0310_write_reg_array(struct i2c_client *client,
+				  const struct gc0310_reg *reglist)
+{
+	const struct gc0310_reg *next = reglist;
+	struct gc0310_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != GC0310_TOK_TERM; next++) {
+		switch (next->type & GC0310_TOK_MASK) {
+		case GC0310_TOK_DELAY:
+			err = __gc0310_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__gc0310_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __gc0310_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __gc0310_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __gc0310_flush_reg_array(client, &ctrl);
+}
+static int gc0310_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC0310_FOCAL_LENGTH_NUM << 16) | GC0310_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int gc0310_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (GC0310_F_NUMBER_DEFAULT_NUM << 16) | GC0310_F_NUMBER_DEM;
+	return 0;
+}
+
+static int gc0310_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC0310_F_NUMBER_DEFAULT_NUM << 24) |
+		(GC0310_F_NUMBER_DEM << 16) |
+		(GC0310_F_NUMBER_DEFAULT_NUM << 8) | GC0310_F_NUMBER_DEM;
+	return 0;
+}
+
+static int gc0310_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+
+	*val = gc0310_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int gc0310_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+
+	*val = gc0310_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+static int gc0310_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct gc0310_resolution *res)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	const unsigned int ext_clk_freq_hz = 19200000;
+	u16 val;
+	u8 reg_val;
+	int ret;
+	unsigned int hori_blanking;
+	unsigned int vert_blanking;
+	unsigned int sh_delay;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* pixel clock calculattion */
+	dev->vt_pix_clk_freq_mhz = ext_clk_freq_hz / 2;
+	buf->vt_pix_clk_freq_mhz = ext_clk_freq_hz / 2;
+	pr_info("vt_pix_clk_freq_mhz=%d\n", buf->vt_pix_clk_freq_mhz);
+
+	/* get integration time */
+	buf->coarse_integration_time_min = GC0310_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+					GC0310_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = GC0310_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					GC0310_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = GC0310_FINE_INTG_TIME_MIN;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	/* Getting crop_horizontal_start */
+	ret =  gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_H_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret =  gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_H_CROP_START_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = val | (reg_val & 0xFF);
+	pr_info("crop_horizontal_start=%d\n", buf->crop_horizontal_start);
+
+	/* Getting crop_vertical_start */
+	ret =  gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_V_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret =  gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_V_CROP_START_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = val | (reg_val & 0xFF);
+	pr_info("crop_vertical_start=%d\n", buf->crop_vertical_start);
+
+	/* Getting output_width */
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_H_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_H_OUTSIZE_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_width = val | (reg_val & 0xFF);
+	pr_info("output_width=%d\n", buf->output_width);
+
+	/* Getting output_height */
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_V_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0xFF) << 8;
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_V_OUTSIZE_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_height = val | (reg_val & 0xFF);
+	pr_info("output_height=%d\n", buf->output_height);
+
+	buf->crop_horizontal_end = buf->crop_horizontal_start + buf->output_width - 1;
+	buf->crop_vertical_end = buf->crop_vertical_start + buf->output_height - 1;
+	pr_info("crop_horizontal_end=%d\n", buf->crop_horizontal_end);
+	pr_info("crop_vertical_end=%d\n", buf->crop_vertical_end);
+
+	/* Getting line_length_pck */
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_H_BLANKING_H, &reg_val);
+	if (ret)
+		return ret;
+	val = ((reg_val & 0xF0) >> 4) << 8;
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_H_BLANKING_L, &reg_val);
+	if (ret)
+		return ret;
+	hori_blanking = val | (reg_val & 0xFF);
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_SH_DELAY, &reg_val);
+	if (ret)
+		return ret;
+	sh_delay = reg_val;
+	buf->line_length_pck = buf->output_width + hori_blanking + sh_delay + 4;
+	pr_info("hori_blanking=%d sh_delay=%d line_length_pck=%d\n", hori_blanking, sh_delay, buf->line_length_pck);
+
+	/* Getting frame_length_lines */
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_V_BLANKING_H, &reg_val);
+	if (ret)
+		return ret;
+	val = (reg_val & 0x0F) << 8;
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_V_BLANKING_L, &reg_val);
+	if (ret)
+		return ret;
+	vert_blanking = val | (reg_val & 0xFF);
+	buf->frame_length_lines = buf->output_height + vert_blanking;
+	pr_info("vert_blanking=%d frame_length_lines=%d\n", vert_blanking, buf->frame_length_lines);
+
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
+	return 0;
+}
+
+static int gc0310_set_gain(struct v4l2_subdev *sd, int gain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 again, dgain;
+
+	if (gain < 0x20)
+		gain = 0x20;
+	if (gain > 0x80)
+		gain = 0x80;
+
+	if (gain >= 0x20 && gain < 0x40) {
+		again = 0x0; /* sqrt(2) */
+		dgain = gain;
+	} else {
+		again = 0x2; /* 2 * sqrt(2) */
+		dgain = gain / 2;
+	}
+
+	pr_info("gain=0x%x again=0x%x dgain=0x%x\n", gain, again, dgain);
+
+	/* set analog gain */
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+					GC0310_AGC_ADJ, again);
+	if (ret)
+		return ret;
+
+	/* set digital gain */
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+					GC0310_DGC_ADJ, dgain);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int __gc0310_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	u16 vts;
+	int frame_length;
+	int ret;
+
+	pr_info("coarse_itg=%d gain=%d digitgain=%d\n", coarse_itg, gain, digitgain);
+
+#if 0
+	vts = gc0310_res[dev->fmt_idx].lines_per_frame;
+	if ((coarse_itg + GC0310_COARSE_INTG_TIME_MAX_MARGIN) >= vts)
+		frame_length = coarse_itg + GC0310_COARSE_INTG_TIME_MAX_MARGIN;
+	else
+		frame_length = vts;
+#endif
+
+#if 0
+	/* group hold start */
+	ret = gc0310_write_reg(client, GC0310_8BIT, GC0310_GROUP_ACCESS, 1);
+	if (ret)
+		return ret;
+#endif
+
+#if 0
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+				GC0310_VTS_DIFF_H, frame_length >> 8);
+	if (ret)
+		return ret;
+#endif
+
+	/* set exposure */
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+					GC0310_AEC_PK_EXPO_L,
+					coarse_itg & 0xff);
+	if (ret)
+		return ret;
+
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+					GC0310_AEC_PK_EXPO_H,
+					(coarse_itg >> 8) & 0x0f);
+	if (ret)
+		return ret;
+
+	ret = gc0310_set_gain(sd, gain);
+	if (ret)
+		return ret;
+
+#if 0
+	/* group hold end */
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+					GC0310_GROUP_ACCESS, 0x0);
+#endif
+
+	return ret;
+}
+
+static int gc0310_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __gc0310_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long gc0310_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	int exp = exposure->integration_time[0];
+	int gain = exposure->gain[0];
+	int digitgain = exposure->gain[1];
+
+	/* we should not accept the invalid value below. */
+	if (gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	return gc0310_set_exposure(sd, exp, gain, digitgain);
+}
+
+/* TO DO */
+static int gc0310_v_flip(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+/* TO DO */
+static int gc0310_h_flip(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+static long gc0310_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return gc0310_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int gc0310_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 reg_v;
+	int ret;
+
+	/* get exposure */
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_AEC_PK_EXPO_L,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	*value = reg_v;
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_AEC_PK_EXPO_H,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	*value = *value + (reg_v << 8);
+	pr_info("gc0310_q_exposure %d\n", *value);
+err:
+	return ret;
+}
+
+struct gc0310_control gc0310_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = gc0310_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc0310_v_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Mirror",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc0310_h_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = GC0310_FOCAL_LENGTH_DEFAULT,
+			.maximum = GC0310_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = GC0310_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc0310_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = GC0310_F_NUMBER_DEFAULT,
+			.maximum = GC0310_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = GC0310_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc0310_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = GC0310_F_NUMBER_RANGE,
+			.maximum =  GC0310_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = GC0310_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = gc0310_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = GC0310_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = gc0310_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = GC0310_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = gc0310_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(gc0310_controls))
+
+static struct gc0310_control *gc0310_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (gc0310_controls[i].qc.id == id)
+			return &gc0310_controls[i];
+	return NULL;
+}
+
+static int gc0310_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct gc0310_control *ctrl = gc0310_find_control(qc->id);
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int gc0310_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc0310_control *s_ctrl;
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = gc0310_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int gc0310_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc0310_control *octrl = gc0310_find_control(ctrl->id);
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int gc0310_init(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+
+	pr_info("%s S\n", __func__);
+	mutex_lock(&dev->input_lock);
+
+	/* set inital registers */
+	ret  = gc0310_write_reg_array(client, gc0310_reset_register);
+
+	/* restore settings */
+	gc0310_res = gc0310_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	mutex_unlock(&dev->input_lock);
+
+	pr_info("%s E\n", __func__);
+	return 0;
+}
+
+static int power_down(struct v4l2_subdev *sd);
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	pr_info("%s S\n", __func__);
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_gpio;
+	}
+
+	pr_info("%s E\n", __func__);
+	return 0;
+
+fail_gpio:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_clk:
+	dev->platform_data->power_ctrl(sd, 0);
+fail_power:
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int gc0310_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return gc0310_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct gc0310_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct gc0310_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &gc0310_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != gc0310_res[i].width)
+			continue;
+		if (h != gc0310_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int gc0310_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+					fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = gc0310_res[N_RES - 1].width;
+		fmt->height = gc0310_res[N_RES - 1].height;
+	} else {
+		fmt->width = gc0310_res[idx].width;
+		fmt->height = gc0310_res[idx].height;
+	}
+	fmt->code = V4L2_MBUS_FMT_SRGGB8_1X8;
+
+	return 0;
+}
+
+/* TODO: remove it. */
+static int startup(struct v4l2_subdev *sd)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	pr_info("%s S\n", __func__);
+#if 0
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+					GC0310_SW_RESET, 0x01);
+	if (ret) {
+		dev_err(&client->dev, "gc0310 reset err.\n");
+		return ret;
+	}
+#endif
+
+	ret = gc0310_write_reg_array(client, gc0310_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "gc0310 write register err.\n");
+		return ret;
+	}
+
+	pr_info("%s E\n", __func__);
+	return ret;
+}
+
+static int gc0310_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *gc0310_info = NULL;
+	int ret = 0;
+
+	pr_info("%s S\n", __func__);
+	gc0310_info = v4l2_get_subdev_hostdata(sd);
+	if (gc0310_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = gc0310_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width,
+					      fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	printk("%s: before gc0310_write_reg_array %s\n",__FUNCTION__, gc0310_res[dev->fmt_idx].desc);
+	ret = startup(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0310 startup err\n");
+		goto err;
+	}
+
+	ret = gc0310_get_intg_factor(client, gc0310_info,
+					&gc0310_res[dev->fmt_idx]);
+	if (ret) {
+		dev_err(&client->dev, "failed to get integration_factor\n");
+		goto err;
+	}
+
+	pr_info("%s E\n", __func__);
+err:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int gc0310_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = gc0310_res[dev->fmt_idx].width;
+	fmt->height = gc0310_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SRGGB8_1X8;
+
+	return 0;
+}
+
+static int gc0310_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u8 high, low;
+	int ret;
+	u16 id;
+
+	pr_info("%s S\n", __func__);
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_SC_CMMN_CHIP_ID_H, &high);
+	if (ret) {
+		dev_err(&client->dev, "read sensor_id_high failed\n");
+		return -ENODEV;
+	}
+	ret = gc0310_read_reg(client, GC0310_8BIT,
+					GC0310_SC_CMMN_CHIP_ID_L, &low);
+	if (ret) {
+		dev_err(&client->dev, "read sensor_id_low failed\n");
+		return -ENODEV;
+	}
+	id = ((((u16) high) << 8) | (u16) low);
+	pr_info("sensor ID = 0x%x\n", id);
+
+	if (id != GC0310_ID) {
+		dev_err(&client->dev, "sensor ID error, read id = 0x%x, target id = 0x%x\n", id, GC0310_ID);
+		return -ENODEV;
+	}
+
+	dev_dbg(&client->dev, "detect gc0310 success\n");
+
+	pr_info("%s E\n", __func__);
+
+	return 0;
+}
+
+static int gc0310_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	pr_info("%s S enable=%d\n", __func__, enable);
+	mutex_lock(&dev->input_lock);
+
+	if (enable) {
+		/* enable per frame MIPI and sensor ctrl reset  */
+		ret = gc0310_write_reg(client, GC0310_8BIT,
+						0xFE, 0x30);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+	}
+
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+				GC0310_RESET_RELATED, GC0310_REGISTER_PAGE_3);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = gc0310_write_reg(client, GC0310_8BIT, GC0310_SW_STREAM,
+				enable ? GC0310_START_STREAMING :
+				GC0310_STOP_STREAMING);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = gc0310_write_reg(client, GC0310_8BIT,
+				GC0310_RESET_RELATED, GC0310_REGISTER_PAGE_0);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	mutex_unlock(&dev->input_lock);
+	pr_info("%s E\n", __func__);
+	return ret;
+}
+
+/* gc0310 enum frame size, frame intervals */
+static int gc0310_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = gc0310_res[index].width;
+	fsize->discrete.height = gc0310_res[index].height;
+	fsize->reserved[0] = gc0310_res[index].used;
+
+	return 0;
+}
+
+static int gc0310_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = gc0310_res[index].width;
+	fival->height = gc0310_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = gc0310_res[index].fps;
+
+	return 0;
+}
+
+static int gc0310_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SRGGB8_1X8;
+
+	return 0;
+}
+
+static int gc0310_s_config(struct v4l2_subdev *sd,
+			   int irq, void *platform_data)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	pr_info("%s S\n", __func__);
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	dev->platform_data =
+		(struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "platform init err\n");
+			goto platform_init_failed;
+		}
+	}
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0310 power-off err.\n");
+		goto fail_power_off;
+	}
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0310 power-up err.\n");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = gc0310_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "gc0310_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc0310 power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	pr_info("%s E\n", __func__);
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+platform_init_failed:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int gc0310_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			gc0310_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int gc0310_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		gc0310_res = gc0310_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		gc0310_res = gc0310_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		gc0310_res = gc0310_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int gc0310_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = gc0310_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int gc0310_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_SRGGB8_1X8;
+	return 0;
+}
+
+static int gc0310_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = gc0310_res[index].width;
+	fse->min_height = gc0310_res[index].height;
+	fse->max_width = gc0310_res[index].width;
+	fse->max_height = gc0310_res[index].height;
+
+	return 0;
+
+}
+
+static struct v4l2_mbus_framefmt *
+__gc0310_get_pad_format(struct gc0310_device *sensor,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+			"__gc0310_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int gc0310_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct gc0310_device *snr = to_gc0310_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__gc0310_get_pad_format(snr, fh, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int gc0310_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct gc0310_device *snr = to_gc0310_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int gc0310_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = gc0310_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops gc0310_sensor_ops = {
+	.g_skip_frames	= gc0310_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops gc0310_video_ops = {
+	.s_stream = gc0310_s_stream,
+	.g_parm = gc0310_g_parm,
+	.s_parm = gc0310_s_parm,
+	.enum_framesizes = gc0310_enum_framesizes,
+	.enum_frameintervals = gc0310_enum_frameintervals,
+	.enum_mbus_fmt = gc0310_enum_mbus_fmt,
+	.try_mbus_fmt = gc0310_try_mbus_fmt,
+	.g_mbus_fmt = gc0310_g_mbus_fmt,
+	.s_mbus_fmt = gc0310_s_mbus_fmt,
+	.g_frame_interval = gc0310_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops gc0310_core_ops = {
+	.s_power = gc0310_s_power,
+	.queryctrl = gc0310_queryctrl,
+	.g_ctrl = gc0310_g_ctrl,
+	.s_ctrl = gc0310_s_ctrl,
+	.ioctl = gc0310_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops gc0310_pad_ops = {
+	.enum_mbus_code = gc0310_enum_mbus_code,
+	.enum_frame_size = gc0310_enum_frame_size,
+	.get_fmt = gc0310_get_pad_format,
+	.set_fmt = gc0310_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops gc0310_ops = {
+	.core = &gc0310_core_ops,
+	.video = &gc0310_video_ops,
+	.pad = &gc0310_pad_ops,
+	.sensor = &gc0310_sensor_ops,
+};
+
+static int gc0310_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc0310_device *dev = to_gc0310_sensor(sd);
+	dev_dbg(&client->dev, "gc0310_remove...\n");
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int gc0310_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct gc0310_device *dev;
+	int ret;
+
+	pr_info("%s S\n", __func__);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &gc0310_ops);
+
+	if (client->dev.platform_data) {
+		ret = gc0310_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SRGGB8_1X8;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		gc0310_remove(client);
+
+	pr_info("%s E\n", __func__);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, gc0310_id);
+static struct i2c_driver gc0310_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = GC0310_NAME,
+	},
+	.probe = gc0310_probe,
+	.remove = gc0310_remove,
+	.id_table = gc0310_id,
+};
+
+static int init_gc0310(void)
+{
+	return i2c_add_driver(&gc0310_driver);
+}
+
+static void exit_gc0310(void)
+{
+
+	i2c_del_driver(&gc0310_driver);
+}
+
+module_init(init_gc0310);
+module_exit(exit_gc0310);
+
+MODULE_AUTHOR("Lai, Angie <angie.lai@intel.com>");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GC0310 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/atomisp/gc0310.h b/drivers/media/i2c/atomisp/gc0310.h
new file mode 100644
index 0000000..ff03e71
--- /dev/null
+++ b/drivers/media/i2c/atomisp/gc0310.h
@@ -0,0 +1,460 @@
+/*
+ * Support for GalaxyCore GC0310 VGA camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GC0310_H__
+#define __GC0310_H__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+
+#include <linux/atomisp_platform.h>
+
+#define GC0310_NAME		"gc0310"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		1
+#define I2C_RETRY_COUNT		5
+
+#define GC0310_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define GC0310_FOCAL_LENGTH_DEM	100
+#define GC0310_F_NUMBER_DEFAULT_NUM	26
+#define GC0310_F_NUMBER_DEM	10
+
+#define MAX_FMTS		1
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC0310_FOCAL_LENGTH_DEFAULT 0x1160064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC0310_F_NUMBER_DEFAULT 0x1a000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define GC0310_F_NUMBER_RANGE 0x1a0a1a0a
+#define GC0310_ID	0xa310
+
+#define GC0310_RESET_RELATED		0xFE
+#define GC0310_REGISTER_PAGE_0		0x0
+#define GC0310_REGISTER_PAGE_3		0x3
+
+#define GC0310_FINE_INTG_TIME_MIN 0
+#define GC0310_FINE_INTG_TIME_MAX_MARGIN 0
+#define GC0310_COARSE_INTG_TIME_MIN 1
+#define GC0310_COARSE_INTG_TIME_MAX_MARGIN 6
+
+/*
+ * GC0310 System control registers
+ */
+#define GC0310_SW_STREAM			0x10
+
+#define GC0310_SC_CMMN_CHIP_ID_H		0xf0
+#define GC0310_SC_CMMN_CHIP_ID_L		0xf1
+
+#define GC0310_AEC_PK_EXPO_H			0x03
+#define GC0310_AEC_PK_EXPO_L			0x04
+#define GC0310_AGC_ADJ			0x48
+#define GC0310_DGC_ADJ			0x71
+#if 0
+#define GC0310_GROUP_ACCESS			0x3208
+#endif
+
+#define GC0310_H_CROP_START_H			0x09
+#define GC0310_H_CROP_START_L			0x0A
+#define GC0310_V_CROP_START_H			0x0B
+#define GC0310_V_CROP_START_L			0x0C
+#define GC0310_H_OUTSIZE_H			0x0F
+#define GC0310_H_OUTSIZE_L			0x10
+#define GC0310_V_OUTSIZE_H			0x0D
+#define GC0310_V_OUTSIZE_L			0x0E
+#define GC0310_H_BLANKING_H			0x05
+#define GC0310_H_BLANKING_L			0x06
+#define GC0310_V_BLANKING_H			0x07
+#define GC0310_V_BLANKING_L			0x08
+#define GC0310_SH_DELAY			0x11
+
+#define GC0310_START_STREAMING			0x96 /* 8-bit enable */
+#define GC0310_STOP_STREAMING			0x0 /* 8-bit disable */
+
+#define GC0310_BIN_FACTOR_MAX			3
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct gc0310_resolution {
+	u8 *desc;
+	const struct gc0310_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u32 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+};
+
+struct gc0310_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct gc0310_reg *regs;
+};
+
+struct gc0310_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * gc0310 device structure.
+ */
+struct gc0310_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u8 res;
+	u8 type;
+};
+
+enum gc0310_tok_type {
+	GC0310_8BIT  = 0x0001,
+	GC0310_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	GC0310_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	GC0310_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct gc0310_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct gc0310_reg {
+	enum gc0310_tok_type type;
+	u8 reg;
+	u8 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_gc0310_sensor(x) container_of(x, struct gc0310_device, sd)
+
+#define GC0310_MAX_WRITE_BUF_SIZE	30
+
+struct gc0310_write_buffer {
+	u8 addr;
+	u8 data[GC0310_MAX_WRITE_BUF_SIZE];
+};
+
+struct gc0310_write_ctrl {
+	int index;
+	struct gc0310_write_buffer buffer;
+};
+
+static const struct i2c_device_id gc0310_id[] = {
+	{GC0310_NAME, 0},
+	{}
+};
+
+/*
+ * Register settings for various resolution
+ */
+static const struct gc0310_reg gc0310_reset_register[] = {
+/////////////////////////////////////////////////
+/////////////////	system reg	/////////////////
+/////////////////////////////////////////////////
+	{GC0310_8BIT, 0xfe, 0xf0},
+	{GC0310_8BIT, 0xfe, 0xf0},
+	{GC0310_8BIT, 0xfe, 0x00},
+
+	{GC0310_8BIT, 0xfc, 0x0e}, //4e
+	{GC0310_8BIT, 0xfc, 0x0e}, //16//4e // [0]apwd [6]regf_clk_gate
+	{GC0310_8BIT, 0xf2, 0x80}, //sync output
+	{GC0310_8BIT, 0xf3, 0x00}, //1f//01 data output
+	{GC0310_8BIT, 0xf7, 0x33}, //f9
+	{GC0310_8BIT, 0xf8, 0x06}, //00
+	{GC0310_8BIT, 0xf9, 0x0e}, // 0x8e //0f
+	{GC0310_8BIT, 0xfa, 0x11},
+
+/////////////////////////////////////////////////
+/////////////////	CISCTL reg	/////////////////
+/////////////////////////////////////////////////
+	{GC0310_8BIT, 0x00, 0x2f}, //2f//0f//02//01
+	{GC0310_8BIT, 0x01, 0x0f}, //06
+	{GC0310_8BIT, 0x02, 0x04},
+	{GC0310_8BIT, 0x4f, 0x00}, //AEC 0FF
+	{GC0310_8BIT, 0x03, 0x02}, // 0x03 //04
+	{GC0310_8BIT, 0x04, 0x40}, // 0xe8 //58
+	{GC0310_8BIT, 0x05, 0x01},
+	{GC0310_8BIT, 0x06, 0x26}, // 0x0a //HB
+	{GC0310_8BIT, 0x07, 0x00},
+	{GC0310_8BIT, 0x08, 0x4e}, // 0x89 //VB
+	{GC0310_8BIT, 0x09, 0x01}, //row start
+	{GC0310_8BIT, 0x0a, 0xfc}, //
+	{GC0310_8BIT, 0x0b, 0x00}, //col start
+	{GC0310_8BIT, 0x0c, 0x00},
+	{GC0310_8BIT, 0x0d, 0x01}, //height
+	{GC0310_8BIT, 0x0e, 0xf2}, // 0xf7 //height
+	{GC0310_8BIT, 0x0f, 0x02}, //width
+	{GC0310_8BIT, 0x10, 0x94}, // 0xa0 //height
+	{GC0310_8BIT, 0x17, 0x14},
+	{GC0310_8BIT, 0x18, 0x1a}, //0a//[4]double reset
+	{GC0310_8BIT, 0x19, 0x14}, //AD pipeline
+	{GC0310_8BIT, 0x1b, 0x48},
+	{GC0310_8BIT, 0x1e, 0x6b}, //3b//col bias
+	{GC0310_8BIT, 0x1f, 0x28}, //20//00//08//txlow
+	{GC0310_8BIT, 0x20, 0x89}, //88//0c//[3:2]DA15
+	{GC0310_8BIT, 0x21, 0x49}, //48//[3] txhigh
+	{GC0310_8BIT, 0x22, 0xb0},
+	{GC0310_8BIT, 0x23, 0x04}, //[1:0]vcm_r
+	{GC0310_8BIT, 0x24, 0x16}, //15
+	{GC0310_8BIT, 0x34, 0x20}, //[6:4] rsg high//range
+
+/////////////////////////////////////////////////
+////////////////////   BLK	 ////////////////////
+/////////////////////////////////////////////////
+	{GC0310_8BIT, 0x26, 0x23}, //[1]dark_current_en [0]offset_en
+	{GC0310_8BIT, 0x28, 0xff}, //BLK_limie_value
+	{GC0310_8BIT, 0x29, 0x00}, //global offset
+	{GC0310_8BIT, 0x33, 0x18}, //offset_ratio
+	{GC0310_8BIT, 0x37, 0x20}, //dark_current_ratio
+	{GC0310_8BIT, 0x2a, 0x00},
+	{GC0310_8BIT, 0x2b, 0x00},
+	{GC0310_8BIT, 0x2c, 0x00},
+	{GC0310_8BIT, 0x2d, 0x00},
+	{GC0310_8BIT, 0x2e, 0x00},
+	{GC0310_8BIT, 0x2f, 0x00},
+	{GC0310_8BIT, 0x30, 0x00},
+	{GC0310_8BIT, 0x31, 0x00},
+	{GC0310_8BIT, 0x47, 0x80}, //a7
+	{GC0310_8BIT, 0x4e, 0x66}, //select_row
+	{GC0310_8BIT, 0xa8, 0x02}, //win_width_dark, same with crop_win_width
+	{GC0310_8BIT, 0xa9, 0x80},
+
+/////////////////////////////////////////////////
+//////////////////	 ISP reg  ///////////////////
+/////////////////////////////////////////////////
+	{GC0310_8BIT, 0x40, 0x00}, // 0xff //ff //48
+	{GC0310_8BIT, 0x41, 0x00}, // 0x21 //00//[0]curve_en
+	{GC0310_8BIT, 0x42, 0x00}, // 0xcf //0a//[1]awn_en
+	{GC0310_8BIT, 0x44, 0x18}, // 0x18 //02
+	{GC0310_8BIT, 0x46, 0x02}, // 0x03 //sync
+	{GC0310_8BIT, 0x49, 0x03},
+	{GC0310_8BIT, 0x4c, 0x20}, //00[5]pretect exp
+	{GC0310_8BIT, 0x50, 0x01}, //crop enable
+	{GC0310_8BIT, 0x51, 0x00},
+	{GC0310_8BIT, 0x52, 0x00},
+	{GC0310_8BIT, 0x53, 0x00},
+	{GC0310_8BIT, 0x54, 0x00},
+	{GC0310_8BIT, 0x55, 0x01}, //crop window height
+	{GC0310_8BIT, 0x56, 0xf0},
+	{GC0310_8BIT, 0x57, 0x02}, //crop window width
+	{GC0310_8BIT, 0x58, 0x90},
+
+/////////////////////////////////////////////////
+///////////////////   GAIN	 ////////////////////
+/////////////////////////////////////////////////
+	{GC0310_8BIT, 0x70, 0x50}, //70 //80//global gain
+	{GC0310_8BIT, 0x71, 0x20}, // pregain gain
+	{GC0310_8BIT, 0x72, 0x40}, // post gain
+	{GC0310_8BIT, 0x5a, 0x98}, //84//analog gain 0
+	{GC0310_8BIT, 0x5b, 0xdc}, //c9
+	{GC0310_8BIT, 0x5c, 0xfe}, //ed//not use pga gain highest level
+	{GC0310_8BIT, 0x77, 0x40}, // R gain 0x74 //awb gain
+	{GC0310_8BIT, 0x78, 0x40}, // G gain
+	{GC0310_8BIT, 0x79, 0x40}, // B gain 0x5f
+
+	{GC0310_8BIT, 0x48, 0x00},
+	{GC0310_8BIT, 0xfe, 0x01},
+	{GC0310_8BIT, 0x0a, 0x45}, //[7]col gain mode
+
+	{GC0310_8BIT, 0x3e, 0x40},
+	{GC0310_8BIT, 0x3f, 0x5c},
+	{GC0310_8BIT, 0x40, 0x7b},
+	{GC0310_8BIT, 0x41, 0xbd},
+	{GC0310_8BIT, 0x42, 0xf6},
+	{GC0310_8BIT, 0x43, 0x63},
+	{GC0310_8BIT, 0x03, 0x60},
+	{GC0310_8BIT, 0x44, 0x03},
+
+/////////////////////////////////////////////////
+/////////////////	dark sun   //////////////////
+/////////////////////////////////////////////////
+	{GC0310_8BIT, 0xfe, 0x01},
+	{GC0310_8BIT, 0x45, 0xa4}, // 0xf7
+	{GC0310_8BIT, 0x46, 0xf0}, // 0xff //f0//sun vaule th
+	{GC0310_8BIT, 0x48, 0x03}, //sun mode
+	{GC0310_8BIT, 0x4f, 0x60}, //sun_clamp
+	{GC0310_8BIT, 0xfe, 0x00},
+
+/////////////////////////////////////////////////
+///////////////////   MIPI	 ////////////////////
+/////////////////////////////////////////////////
+	{GC0310_8BIT, 0xfe, 0x03},
+	{GC0310_8BIT, 0x01, 0x03}, ///mipi 1lane
+	{GC0310_8BIT, 0x02, 0x22}, // 0x33
+	{GC0310_8BIT, 0x03, 0x94},
+	{GC0310_8BIT, 0x04, 0x01}, // fifo_prog
+	{GC0310_8BIT, 0x05, 0x00}, //fifo_prog
+	{GC0310_8BIT, 0x06, 0x80}, //b0  //YUV ISP data
+	{GC0310_8BIT, 0x11, 0x2a},//1e //LDI set YUV422
+	{GC0310_8BIT, 0x12, 0x90},//00 //04 //00 //04//00 //LWC[7:0]  //
+	{GC0310_8BIT, 0x13, 0x02},//05 //05 //LWC[15:8]
+	{GC0310_8BIT, 0x15, 0x12}, // 0x10 //DPHYY_MODE read_ready
+	{GC0310_8BIT, 0x17, 0x01},
+	{GC0310_8BIT, 0x42, 0x90},
+	{GC0310_8BIT, 0x43, 0x02},
+	{GC0310_8BIT, 0x21, 0x02}, // 0x01
+	{GC0310_8BIT, 0x22, 0x02}, // 0x01
+	{GC0310_8BIT, 0x23, 0x01}, // 0x05 //Nor:0x05 DOU:0x06
+	{GC0310_8BIT, 0x29, 0x01},
+	{GC0310_8BIT, 0x2A, 0x01}, // 0x05 //data zero 0x7a de
+
+	{GC0310_8BIT, 0xfe, 0x00},
+
+	{GC0310_TOK_TERM, 0, 0},
+};
+
+static struct gc0310_reg const gc0310_VGA_30fps[] = {
+	{GC0310_8BIT, 0xfe, 0x00},
+	{GC0310_8BIT, 0x0d, 0x01}, //height
+	{GC0310_8BIT, 0x0e, 0xf2}, // 0xf7 //height
+	{GC0310_8BIT, 0x0f, 0x02}, //width
+	{GC0310_8BIT, 0x10, 0x94}, // 0xa0 //height
+
+	{GC0310_8BIT, 0x50, 0x01}, //crop enable
+	{GC0310_8BIT, 0x51, 0x00},
+	{GC0310_8BIT, 0x52, 0x00},
+	{GC0310_8BIT, 0x53, 0x00},
+	{GC0310_8BIT, 0x54, 0x00},
+	{GC0310_8BIT, 0x55, 0x01}, //crop window height
+	{GC0310_8BIT, 0x56, 0xf0},
+	{GC0310_8BIT, 0x57, 0x02}, //crop window width
+	{GC0310_8BIT, 0x58, 0x90},
+
+	{GC0310_8BIT, 0xfe, 0x03},
+	{GC0310_8BIT, 0x12, 0x90},//00 //04 //00 //04//00 //LWC[7:0]  //
+	{GC0310_8BIT, 0x13, 0x02},//05 //05 //LWC[15:8]
+
+	{GC0310_8BIT, 0xfe, 0x00},
+
+	{GC0310_TOK_TERM, 0, 0},
+};
+
+
+struct gc0310_resolution gc0310_res_preview[] = {
+	{
+		.desc = "gc0310_VGA_30fps",
+		.width = 656, // 648,
+		.height = 496, // 488,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+#if 0
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+#endif
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0310_VGA_30fps,
+	},
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(gc0310_res_preview))
+
+struct gc0310_resolution gc0310_res_still[] = {
+	{
+		.desc = "gc0310_VGA_30fps",
+		.width = 656, // 648,
+		.height = 496, // 488,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+#if 0
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+#endif
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0310_VGA_30fps,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(gc0310_res_still))
+
+struct gc0310_resolution gc0310_res_video[] = {
+	{
+		.desc = "gc0310_VGA_30fps",
+		.width = 656, // 648,
+		.height = 496, // 488,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+#if 0
+		.pixels_per_line = 0x0314,
+		.lines_per_frame = 0x0213,
+#endif
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc0310_VGA_30fps,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(gc0310_res_video))
+
+static struct gc0310_resolution *gc0310_res = gc0310_res_preview;
+static int N_RES = N_RES_PREVIEW;
+#endif
+
diff --git a/drivers/media/i2c/atomisp/gc2155.c b/drivers/media/i2c/atomisp/gc2155.c
new file mode 100644
index 0000000..f0b5983
--- /dev/null
+++ b/drivers/media/i2c/atomisp/gc2155.c
@@ -0,0 +1,1577 @@
+/*
+ * Support for GalaxyCore GC2155 2M camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/io.h>
+
+#include "gc2155.h"
+
+static struct kobject *front_camera_dev_info_kobj;
+static u16 front_camera_sensorid = 0;
+
+static ssize_t sensor_vendor_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *str = buf;
+	str += sprintf(str, "%s\n", "GalaxyCore");
+	return (str - buf);
+}
+
+static ssize_t sensor_id_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *str = buf;
+	str += sprintf(str, "%s%x\n", "GC", front_camera_sensorid);
+	return (str - buf);
+}
+
+static struct kobj_attribute sensor_vendor_attr = {
+	.attr = {
+		.name = "vendor",
+		.mode = 0644,
+	},
+	.show = sensor_vendor_show,
+};
+
+static struct kobj_attribute sensor_id_attr = {
+	.attr = {
+		.name = "sensor_id",
+		.mode = 0644,
+	},
+	.show = sensor_id_show,
+};
+
+static struct attribute * sensor_group[] = {
+	&sensor_vendor_attr.attr,
+	&sensor_id_attr.attr,
+	NULL,
+};
+
+static struct attribute_group sensor_attr_group = {
+	.attrs = sensor_group,
+};
+
+/* i2c read/write stuff */
+static int gc2155_read_reg(struct i2c_client *client,
+		u16 data_length, u8 reg, u8 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+				__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != GC2155_8BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data+1;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+				"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == GC2155_8BIT)
+		*val = (u8)data[1];
+
+	return 0;
+}
+
+static int gc2155_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int gc2155_write_reg(struct i2c_client *client, u16 data_length,
+		u8 reg, u8 val)
+{
+	int ret;
+	unsigned char data[2] = {0};
+	u8 *wreg = (u8 *)data;
+	const u16 len = data_length + sizeof(u8); /* 8-bit address + data */
+
+	if (data_length != GC2155_8BIT) {
+		dev_err(&client->dev,
+				"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = (u8)(reg & 0xff);
+
+	if (data_length == GC2155_8BIT) {
+		data[1] = (u8)(val);
+	}
+
+	ret = gc2155_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+				"write error: wrote 0x%x to offset 0x%x error %d",
+				val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * gc2155_write_reg_array - Initializes a list of GC2155 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __gc2155_flush_reg_array, __gc2155_buf_reg_array() and
+ * __gc2155_write_reg_is_consecutive() are internal functions to
+ * gc2155_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __gc2155_flush_reg_array(struct i2c_client *client,
+		struct gc2155_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u8) + ctrl->index; /* 8-bit address + data */
+	ctrl->buffer.addr = (u8)(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return gc2155_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __gc2155_buf_reg_array(struct i2c_client *client,
+		struct gc2155_write_ctrl *ctrl,
+		const struct gc2155_reg *next)
+{
+	int size;
+
+	switch (next->type) {
+		case GC2155_8BIT:
+			size = 1;
+			ctrl->buffer.data[ctrl->index] = (u8)next->val;
+			break;
+		default:
+			return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u8) >= GC2155_MAX_WRITE_BUF_SIZE)
+		return __gc2155_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int __gc2155_write_reg_is_consecutive(struct i2c_client *client,
+		struct gc2155_write_ctrl *ctrl,
+		const struct gc2155_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int gc2155_write_reg_array(struct i2c_client *client,
+		const struct gc2155_reg *reglist)
+{
+	const struct gc2155_reg *next = reglist;
+	struct gc2155_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != GC2155_TOK_TERM; next++) {
+		switch (next->type & GC2155_TOK_MASK) {
+			case GC2155_TOK_DELAY:
+				err = __gc2155_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+				msleep(next->val);
+				break;
+			default:
+				/*
+				 * If next address is not consecutive, data needs to be
+				 * flushed before proceed.
+				 */
+				if (!__gc2155_write_reg_is_consecutive(client, &ctrl,
+							next)) {
+					err = __gc2155_flush_reg_array(client, &ctrl);
+					if (err)
+						return err;
+				}
+				err = __gc2155_buf_reg_array(client, &ctrl, next);
+				if (err) {
+					dev_err(&client->dev, "%s: write error, aborted\n",
+							__func__);
+					return err;
+				}
+				break;
+		}
+	}
+
+	return __gc2155_flush_reg_array(client, &ctrl);
+}
+static int gc2155_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC2155_FOCAL_LENGTH_NUM << 16) | GC2155_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int gc2155_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (GC2155_F_NUMBER_DEFAULT_NUM << 16) | GC2155_F_NUMBER_DEM;
+	return 0;
+}
+
+static int gc2155_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC2155_F_NUMBER_DEFAULT_NUM << 24) |
+		(GC2155_F_NUMBER_DEM << 16) |
+		(GC2155_F_NUMBER_DEFAULT_NUM << 8) | GC2155_F_NUMBER_DEM;
+	return 0;
+}
+
+static int gc2155_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+
+	*val = gc2155_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int gc2155_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+
+	*val = gc2155_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+static int gc2155_get_intg_factor(struct i2c_client *client,
+		struct camera_mipi_info *info,
+		const struct gc2155_resolution *res)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	unsigned int mclk_freq_hz = 19200000;
+	unsigned int hb, vb, sh_delay;
+	u8 pll_div;
+	u8 reg_val, reg_val2;
+	int ret;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	ret = gc2155_read_reg(client, GC2155_8BIT,  REG_RST_AND_PG_SELECT, &reg_val);
+	if (ret)
+		return ret;
+	pr_info("page = %d\n", reg_val);
+
+	/* vt_pix_clk_freq_mhz. TODO: don't know the real value exactly. */
+	ret = gc2155_read_reg(client, GC2155_8BIT,  0xf8, &pll_div);
+	if (ret)
+		return ret;
+
+	pll_div = pll_div & 0x1f;
+	pr_info("pll_div = %d\n",pll_div);
+
+	buf->vt_pix_clk_freq_mhz = (mclk_freq_hz >> 1) * (pll_div + 1);
+	pr_info("vt_pix_clk_freq_mhz = %u\n", buf->vt_pix_clk_freq_mhz);
+
+	ret = gc2155_write_reg(client, GC2155_8BIT, REG_RST_AND_PG_SELECT, 0x0);
+	if (ret) {
+		dev_err(&client->dev,"Page switch fail\n");
+		return ret;
+	}
+
+	/* get integration time. DIT doesn't use these vales. */
+	buf->coarse_integration_time_min = GC2155_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+		GC2155_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = GC2155_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+		GC2155_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = GC2155_FINE_INTG_TIME_MIN;
+
+	/* crop_horizontal_start */
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_COL_START_H, &reg_val);
+	ret |= gc2155_read_reg(client, GC2155_8BIT, REG_COL_START_L, &reg_val2);
+
+	if (ret) {
+		pr_info("Read COL_START fail\n");
+		return ret;
+	} else {
+		buf->crop_horizontal_start = ((reg_val << 8) & 0x0700) | reg_val2;
+		pr_info("crop_horizontal_start = %d\n", buf->crop_horizontal_start);
+	}
+
+	/* crop_vertical_start */
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_ROW_START_H, &reg_val);
+	ret |= gc2155_read_reg(client, GC2155_8BIT, REG_ROW_START_L, &reg_val2);
+
+	if (ret) {
+		pr_info("Read ROW_START fail\n");
+		return ret;
+	} else {
+		buf->crop_vertical_start = ((reg_val << 8) & 0x0700) | reg_val2;
+		pr_info("crop_vertical_start = %d\n", buf->crop_vertical_start);
+	}
+
+	/* output_width */
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_WIN_WIDTH_H, &reg_val);
+	ret |= gc2155_read_reg(client, GC2155_8BIT, REG_WIN_WIDTH_L, &reg_val2);
+	if (ret) {
+		pr_info("Read WIN_WIDTH fail\n");
+		return ret;
+	} else {
+		buf->output_width = ((reg_val << 8) & 0x0700) | reg_val2;
+		pr_info("output_width = %d\n", buf->output_width);
+	}
+
+	/* crop_horizontal_end */
+	buf->crop_horizontal_end =
+		buf->crop_horizontal_start + buf->output_width - 1;
+	pr_info("crop_horizontal_end = %d\n",buf->crop_horizontal_end);
+
+	/* output_height */
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_WIN_HEIGHT_H, &reg_val);
+	ret |= gc2155_read_reg(client, GC2155_8BIT, REG_WIN_HEIGHT_L, &reg_val2);
+	if (ret) {
+		pr_info("Read WIN_HEIGHT fail\n");
+		return ret;
+	} else {
+		buf->output_height = ((reg_val << 8) & 0x0700) | reg_val2;
+		pr_info("output_height = %d\n", buf->output_height);
+	}
+
+	/* crop_vertical_end */
+	buf->crop_vertical_end =
+		buf->crop_vertical_start + buf->output_height - 1;
+	pr_info("crop_vertical_end = %d\n", buf->crop_vertical_end);
+
+	/* H Blank */
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_H_BLANK_H, &reg_val);
+	ret |= gc2155_read_reg(client, GC2155_8BIT, REG_H_BLANK_L, &reg_val2);
+	if (ret) {
+		pr_info("Read H_BLANK fail\n");
+		return ret;
+	} else {
+		hb = ((reg_val << 8) & 0x0F00) | reg_val2;
+		pr_info("hb = %d\n", hb);
+	}
+
+	/* Sh_delay */
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_SH_DELAY_H, &reg_val);
+	ret |= gc2155_read_reg(client, GC2155_8BIT, REG_SH_DELAY_L, &reg_val2);
+	if (ret) {
+		pr_info("Read SH_DELAY fail\n");
+		return ret;
+	} else {
+		sh_delay = ((reg_val << 8) & 0x0300) | reg_val2;
+		pr_info("sh_delay = %d\n", sh_delay);
+	}
+
+	/* line_length_pck(row_time):
+	 *  row_time = Hb + Sh_delay + win_width + 4.
+	 *
+	 *   Hb: HBlank or dummy pixel, Setting by register P0:0x05 and P0:0x06.
+	 *   Sh_delay: Setting by registerP0:0x11[9:8], P0:0x12[7:0].
+	 *   win_width: Setting by register 0x0f and P0:0x10, win_width = 1600,
+	 *   final_output_width + 8. So for UXGA, we should set win_width as 1616.
+	 */
+	buf->line_length_pck = (hb + sh_delay + (buf->output_width + 16)/2 + 4) << 1;
+	pr_info("line_length_pck = %d\n", buf->line_length_pck);
+
+	/* V Blank */
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_V_BLANK_H, &reg_val);
+	ret |= gc2155_read_reg(client, GC2155_8BIT, REG_V_BLANK_L, &reg_val2);
+	if (ret) {
+		pr_info("Read V_BLANK fail\n");
+		return ret;
+	} else {
+		vb = ((reg_val << 8) & 0x1F00) | reg_val2;
+		pr_info("vb = %d\n", vb);
+	}
+
+	/* frame_length_lines (Frame time, Ft)
+	 * Ft = VB + Vt + 8 (unit is row_time)
+	 *  VB = Bt + St + Et, Vblank/Dummy line, from P0:0x07 and P0:0x08.
+	 *   Bt: Blank time, VSYNC no active time.
+	 *   St: Start time, setting by register P0:0x13
+	 *   Et: End time, setting by register P0:0x14
+	 *  Vt: valid line time. UXGA is 1200, Vt = win_height - 8, win_height
+	 *      is setting by register P0:0x0d and P0:0x0e(1232).
+	 */
+	buf->frame_length_lines = vb + buf->output_height;
+	pr_info("frame_length_lines = %d\n",buf->frame_length_lines);
+
+	buf->read_mode = res->bin_mode;
+	buf->binning_factor_x = res->bin_factor_x;
+	buf->binning_factor_y = res->bin_factor_x;
+
+	return 0;
+}
+
+static long gc2155_s_exposure(struct v4l2_subdev *sd,
+					struct atomisp_exposure *exposure)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 tmp, lsc;
+	int ret = 0;
+
+	unsigned int coarse_integration = 0;
+
+	//unsigned int AnalogGain, DigitalGain;
+
+	u8 expo_coarse_h,expo_coarse_l;
+	unsigned int gain, a_gain, d_gain;
+
+	dev_err(&client->dev, "%s(0x%X 0x%X 0x%X)\n", __func__,
+		exposure->integration_time[0], exposure->gain[0], exposure->gain[1]);
+
+	coarse_integration = exposure->integration_time[0];
+
+
+	gain = exposure->gain[0];
+	
+	if (gain < 16) gain = 16;
+	if (gain > 255) gain = 255;
+
+	if (gain < 23) {
+		a_gain = 0x0; //0x25 analog gain
+		d_gain = (gain*2  - 32) | 0x20; //0xb1 digital gain
+	} else if (gain < 32) {
+		a_gain = 0x1;
+		d_gain = ((gain* 10 / 7) - 32) | 0x20;
+	} else if (gain < 46) {
+		a_gain = 0x2;
+		d_gain = (gain - 32) | 0x20;
+	} else if (gain < 64) {
+		a_gain = 0x3;
+		d_gain = ((gain* 10 / 14) - 32) | 0x20;
+	} else if (gain < 91) {
+		a_gain = 0x4;
+		d_gain = ((gain / 2) - 32) | 0x20;
+	} else if (gain < 128) {
+		a_gain = 0x5;
+		d_gain = ((gain* 10 / 28) - 32) | 0x20;
+	} else if (gain < 192) {
+		a_gain = 0x6;
+		d_gain = ((gain / 4) - 32) | 0x20;
+	} else if (gain < 256) {
+		a_gain = 0x6;
+		d_gain = ((gain / 4) - 48) | 0x30;
+	}
+	printk("%s real %d a_gain %x d_gain %x\n", __func__, gain, a_gain, d_gain);
+
+	expo_coarse_h = (u8)((coarse_integration >> 8) & 0x1F);
+	expo_coarse_l = (u8)(coarse_integration & 0xff);
+
+
+	ret = gc2155_read_reg(client, GC2155_8BIT,  REG_RST_AND_PG_SELECT, &tmp);
+
+
+	ret = gc2155_write_reg(client, GC2155_8BIT, REG_RST_AND_PG_SELECT, 0x0);
+
+	ret = gc2155_read_reg(client, GC2155_8BIT,  REG_RST_AND_PG_SELECT, &tmp);
+
+
+	ret = gc2155_write_reg(client, GC2155_8BIT, REG_EXPO_COARSE_H, expo_coarse_h);
+	ret = gc2155_write_reg(client, GC2155_8BIT, REG_EXPO_COARSE_L, expo_coarse_l);
+	ret = gc2155_read_reg(client, GC2155_8BIT,  0x80, &lsc);
+
+	if (ret) {
+		 v4l2_err(client, "%s: fail to set exposure time\n", __func__);
+		 return -EINVAL;
+	}
+
+	/* Set Digital gain
+	 * Controlled by AEC, can be manually controlled when disable AEC
+	 * P0:0xb1 Auto_pregain
+	 * P0:0xb2 Auto_postgain
+	 */
+	/* Set Analog Gain
+	 *  Aec close: p0:0xb6 [0]
+	 *  Set gain to P0:0x25
+	 *  000: 1X
+	 *  001: 1.4X
+	 *  010: 2X
+	 *  011: 2.8X
+	 *  100: 4X
+	 */
+
+	gc2155_write_reg(client, GC2155_8BIT, 0x25, a_gain);
+	gc2155_write_reg(client, GC2155_8BIT, 0xb1, d_gain);
+
+	if (ret) {
+		v4l2_err(client, "%s: fail to set AnalogGainToWrite\n", __func__);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/* TO DO */
+static int gc2155_v_flip(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+/* TO DO */
+static int gc2155_h_flip(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+static long gc2155_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+		case ATOMISP_IOC_S_EXPOSURE:
+			return gc2155_s_exposure(sd, arg);
+		default:
+			return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int gc2155_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 reg_v;
+	int ret;
+
+	/* get exposure */
+	ret = gc2155_read_reg(client, GC2155_8BIT,
+			GC2155_AEC_PK_EXPO_L,
+			&reg_v);
+	if (ret)
+		goto err;
+
+	*value = reg_v;
+	ret = gc2155_read_reg(client, GC2155_8BIT,
+			GC2155_AEC_PK_EXPO_H,
+			&reg_v);
+	if (ret)
+		goto err;
+
+	*value = *value + (reg_v << 8);
+	//pr_info("gc2155_q_exposure %d\n", *value);
+err:
+	return ret;
+}
+struct gc2155_control gc2155_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = gc2155_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc2155_v_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Mirror",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = gc2155_h_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = GC2155_FOCAL_LENGTH_DEFAULT,
+			.maximum = GC2155_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = GC2155_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc2155_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = GC2155_F_NUMBER_DEFAULT,
+			.maximum = GC2155_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = GC2155_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc2155_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = GC2155_F_NUMBER_RANGE,
+			.maximum =  GC2155_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = GC2155_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = gc2155_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = GC2155_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = gc2155_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = GC2155_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = gc2155_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(gc2155_controls))
+
+static struct gc2155_control *gc2155_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (gc2155_controls[i].qc.id == id)
+			return &gc2155_controls[i];
+	return NULL;
+}
+
+static int gc2155_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct gc2155_control *ctrl = gc2155_find_control(qc->id);
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int gc2155_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc2155_control *s_ctrl;
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = gc2155_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int gc2155_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc2155_control *octrl = gc2155_find_control(ctrl->id);
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int gc2155_init(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+
+	/* set inital registers */
+	ret  = gc2155_write_reg_array(client, gc2155_reset_register);
+
+	/* restore settings */
+	gc2155_res = gc2155_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int power_down(struct v4l2_subdev *sd);
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+				"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	msleep(2);
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_gpio;
+	}
+
+	return 0;
+
+fail_gpio:
+	dev->platform_data->power_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_clk:
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+				"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int gc2155_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+
+	pr_info("%s: on %d\n", __func__, on);
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return gc2155_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct gc2155_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+			(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct gc2155_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &gc2155_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != gc2155_res[i].width)
+			continue;
+		if (h != gc2155_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int gc2155_try_mbus_fmt(struct v4l2_subdev *sd,
+		struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+			fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = gc2155_res[N_RES - 1].width;
+		fmt->height = gc2155_res[N_RES - 1].height;
+	} else {
+		fmt->width = gc2155_res[idx].width;
+		fmt->height = gc2155_res[idx].height;
+	}
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+/* TODO: remove it. */
+static int startup(struct v4l2_subdev *sd)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	ret = gc2155_write_reg_array(client, gc2155_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "gc2155 write register err.\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int gc2155_s_mbus_fmt(struct v4l2_subdev *sd,
+		struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *gc2155_info = NULL;
+	int ret = 0;
+
+	gc2155_info = v4l2_get_subdev_hostdata(sd);
+	if (gc2155_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = gc2155_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width,
+			fmt->height);
+
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	ret = startup(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2155 startup err\n");
+		goto err;
+	}
+
+	ret = gc2155_get_intg_factor(client, gc2155_info,
+			&gc2155_res[dev->fmt_idx]);
+	if (ret) {
+		dev_err(&client->dev, "failed to get integration_factor\n");
+		goto err;
+	}
+
+err:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int gc2155_g_mbus_fmt(struct v4l2_subdev *sd,
+		struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = gc2155_res[dev->fmt_idx].width;
+	fmt->height = gc2155_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int gc2155_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	int ret;
+	u8 chipid_H,chipid_L;
+	u16 id;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_CHIP_ID_H, &chipid_H);
+	if (ret) {
+		dev_err(&client->dev, "read sensor chipid_H failed\n");
+		return -ENODEV;
+	}
+
+	ret = gc2155_read_reg(client, GC2155_8BIT, REG_CHIP_ID_L, &chipid_L);
+	if (ret) {
+		dev_err(&client->dev, "read sensor chipid_L failed\n");
+		return -ENODEV;
+	}
+
+	id = ((chipid_H << 8) & 0xff00) | chipid_L;
+	if (id != GC2155_ID) {
+		dev_err(&client->dev, "sensor ID error, read id = 0x%x, target id = 0x%x\n", id, GC2155_ID);
+		return -ENODEV;
+	}
+
+	/* The first time enters the _detect that front_camera_dev_info_kobj
+	   is a NULL pointer. Then kobject_create_and_add will assign the buf address
+	   to the front_camera_dev_info_kobj. So the second time enters the gc2155_detect
+	   that front_camera_dev_info_kobj has buf address's value.
+	 */
+	front_camera_sensorid = id;
+	if (front_camera_dev_info_kobj == NULL) {
+		front_camera_dev_info_kobj = kobject_create_and_add("dev-info_front-camera", NULL);
+
+		if (front_camera_dev_info_kobj == NULL) {
+			dev_err(&client->dev, "%s: Create front_camera_dev_info_kobj failed\n", __func__);
+		} else {
+			ret = sysfs_create_group(front_camera_dev_info_kobj, &sensor_attr_group);
+			if (ret)
+				dev_err(&client->dev, "%s: Create camera_attr_group failed\n", __func__);
+		}
+        }
+
+	dev_dbg(&client->dev, "detect gc2155 success\n");
+
+	return 0;
+}
+
+static int gc2155_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	if (enable) {
+		pr_info("reset register.\n");
+		/* enable per frame MIPI and sensor ctrl reset  */
+		ret = gc2155_write_reg(client, GC2155_8BIT,  GC2155_REG_RST_AND_PG_SELECT, 0x30);
+		if (ret) {
+			dev_err(&client->dev, "reset register fail\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+	}
+
+	/*pege selsct*/
+	ret = gc2155_write_reg(client, GC2155_8BIT,  GC2155_REG_RST_AND_PG_SELECT, 0x03);
+	if (ret) {
+		dev_err(&client->dev, "pege selsct fail\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	/*stream on/off*/
+	ret = gc2155_write_reg(client, GC2155_8BIT, GC2155_SW_STREAM,
+			enable ? GC2155_START_STREAMING :
+			GC2155_STOP_STREAMING);
+	if (ret) {
+		dev_err(&client->dev, "streaming %d fail\n", enable);
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+/* gc2155 enum frame size, frame intervals */
+static int gc2155_enum_framesizes(struct v4l2_subdev *sd,
+		struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = gc2155_res[index].width;
+	fsize->discrete.height = gc2155_res[index].height;
+	fsize->reserved[0] = gc2155_res[index].used;
+
+	return 0;
+}
+
+static int gc2155_enum_frameintervals(struct v4l2_subdev *sd,
+		struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = gc2155_res[index].width;
+	fival->height = gc2155_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = gc2155_res[index].fps;
+
+	return 0;
+}
+
+static int gc2155_enum_mbus_fmt(struct v4l2_subdev *sd,
+		unsigned int index,
+		enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int gc2155_s_config(struct v4l2_subdev *sd,
+		int irq, void *platform_data)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	dev->platform_data =
+		(struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "platform init err\n");
+			return ret;
+		}
+	}
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2155 power-off err.\n");
+		goto fail_power_off;
+	}
+	msleep(20);
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2155 power-up err.\n");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = gc2155_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "gc2155_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2155 power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int gc2155_g_parm(struct v4l2_subdev *sd,
+		struct v4l2_streamparm *param)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			gc2155_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int gc2155_s_parm(struct v4l2_subdev *sd,
+		struct v4l2_streamparm *param)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+		case CI_MODE_VIDEO:
+			gc2155_res = gc2155_res_video;
+			N_RES = N_RES_VIDEO;
+			break;
+		case CI_MODE_STILL_CAPTURE:
+			gc2155_res = gc2155_res_still;
+			N_RES = N_RES_STILL;
+			break;
+		default:
+			gc2155_res = gc2155_res_preview;
+			N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int gc2155_g_frame_interval(struct v4l2_subdev *sd,
+		struct v4l2_subdev_frame_interval *interval)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = gc2155_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int gc2155_enum_mbus_code(struct v4l2_subdev *sd,
+		struct v4l2_subdev_fh *fh,
+		struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	return 0;
+}
+
+static int gc2155_enum_frame_size(struct v4l2_subdev *sd,
+		struct v4l2_subdev_fh *fh,
+		struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = gc2155_res[index].width;
+	fse->min_height = gc2155_res[index].height;
+	fse->max_width = gc2155_res[index].width;
+	fse->max_height = gc2155_res[index].height;
+
+	return 0;
+
+}
+
+	static struct v4l2_mbus_framefmt *
+__gc2155_get_pad_format(struct gc2155_device *sensor,
+		struct v4l2_subdev_fh *fh, unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+				"__gc2155_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
+	switch (which) {
+		case V4L2_SUBDEV_FORMAT_TRY:
+			return v4l2_subdev_get_try_format(fh, pad);
+		case V4L2_SUBDEV_FORMAT_ACTIVE:
+			return &sensor->format;
+		default:
+			return NULL;
+	}
+}
+
+static int gc2155_get_pad_format(struct v4l2_subdev *sd,
+		struct v4l2_subdev_fh *fh,
+		struct v4l2_subdev_format *fmt)
+{
+	struct gc2155_device *snr = to_gc2155_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+		__gc2155_get_pad_format(snr, fh, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int gc2155_set_pad_format(struct v4l2_subdev *sd,
+		struct v4l2_subdev_fh *fh,
+		struct v4l2_subdev_format *fmt)
+{
+	struct gc2155_device *snr = to_gc2155_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int gc2155_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = gc2155_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops gc2155_sensor_ops = {
+	.g_skip_frames	= gc2155_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops gc2155_video_ops = {
+	.s_stream = gc2155_s_stream,
+	.g_parm = gc2155_g_parm,
+	.s_parm = gc2155_s_parm,
+	.enum_framesizes = gc2155_enum_framesizes,
+	.enum_frameintervals = gc2155_enum_frameintervals,
+	.enum_mbus_fmt = gc2155_enum_mbus_fmt,
+	.try_mbus_fmt = gc2155_try_mbus_fmt,
+	.g_mbus_fmt = gc2155_g_mbus_fmt,
+	.s_mbus_fmt = gc2155_s_mbus_fmt,
+	.g_frame_interval = gc2155_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops gc2155_core_ops = {
+	.s_power = gc2155_s_power,
+	.queryctrl = gc2155_queryctrl,
+	.g_ctrl = gc2155_g_ctrl,
+	.s_ctrl = gc2155_s_ctrl,
+	.ioctl = gc2155_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops gc2155_pad_ops = {
+	.enum_mbus_code = gc2155_enum_mbus_code,
+	.enum_frame_size = gc2155_enum_frame_size,
+	.get_fmt = gc2155_get_pad_format,
+	.set_fmt = gc2155_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops gc2155_ops = {
+	.core = &gc2155_core_ops,
+	.video = &gc2155_video_ops,
+	.pad = &gc2155_pad_ops,
+	.sensor = &gc2155_sensor_ops,
+};
+
+static int gc2155_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2155_device *dev = to_gc2155_sensor(sd);
+	dev_dbg(&client->dev, "gc2155_remove...\n");
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int gc2155_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct gc2155_device *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &gc2155_ops);
+
+	if (client->dev.platform_data) {
+		ret = gc2155_s_config(&dev->sd, client->irq,
+				client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		gc2155_remove(client);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, gc2155_id);
+static struct i2c_driver gc2155_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = GC2155_NAME,
+	},
+	.probe = gc2155_probe,
+	.remove = gc2155_remove,
+	.id_table = gc2155_id,
+};
+
+static int init_gc2155(void)
+{
+	return i2c_add_driver(&gc2155_driver);
+}
+
+static void exit_gc2155(void)
+{
+
+	i2c_del_driver(&gc2155_driver);
+}
+
+module_init(init_gc2155);
+module_exit(exit_gc2155);
+
+MODULE_AUTHOR("Dean, Hsieh <dean.hsieh@intel.com>");
+MODULE_DESCRIPTION("A low-level driver for GalaxyCore GC2155 sensors");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/media/i2c/atomisp/gc2155.h b/drivers/media/i2c/atomisp/gc2155.h
new file mode 100644
index 0000000..872a1158
--- /dev/null
+++ b/drivers/media/i2c/atomisp/gc2155.h
@@ -0,0 +1,1017 @@
+/*
+ * Support for GalaxyCore GC2155 2M camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GC2155_H__
+#define __GC2155_H__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+
+#include <linux/atomisp_platform.h>
+
+#define GC2155_NAME		"gc2155"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		1
+#define I2C_RETRY_COUNT		5
+
+#define GC2155_FOCAL_LENGTH_NUM	260	/* 2.6mm */
+#define GC2155_FOCAL_LENGTH_DEM	100
+#define GC2155_F_NUMBER_DEFAULT_NUM	28
+#define GC2155_F_NUMBER_DEM	10
+
+#define MAX_FMTS		1
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC2155_FOCAL_LENGTH_DEFAULT 0x1160064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC2155_F_NUMBER_DEFAULT 0x1a000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define GC2155_F_NUMBER_RANGE 0x1a0a1a0a
+#define GC2155_ID	0x2155
+
+#define GC2155_FINE_INTG_TIME_MIN 0
+#define GC2155_FINE_INTG_TIME_MAX_MARGIN 0
+#define GC2155_COARSE_INTG_TIME_MIN 1
+#define GC2155_COARSE_INTG_TIME_MAX_MARGIN 6
+
+/*
+ * GC2155 System control registers
+ */
+#define GC2155_SW_STREAM			0x10
+
+#define GC2155_SC_CMMN_CHIP_ID		0x0
+
+#define GC2155_AEC_PK_EXPO_H			0x03
+#define GC2155_AEC_PK_EXPO_L			0x04
+#define GC2155_AGC_ADJ			0x50
+#if 0
+#define GC2155_GROUP_ACCESS			0x3208
+#endif
+
+/* gc2155 system registers */
+#define REG_CHIP_ID_H		0xF0
+#define REG_CHIP_ID_L		0xF1
+#define REG_RST_AND_PG_SELECT	0xFE
+
+/* gc2155 page0 registers */
+#define REG_EXPO_COARSE_H	0x03
+#define REG_EXPO_COARSE_L	0x04
+#define REG_H_BLANK_H		0x05
+#define REG_H_BLANK_L		0x06
+#define REG_V_BLANK_H		0x07
+#define REG_V_BLANK_L		0x08
+#define REG_ROW_START_H		0x09
+#define REG_ROW_START_L		0x0A
+#define REG_COL_START_H		0x0B
+#define REG_COL_START_L		0x0C
+#define REG_WIN_HEIGHT_H	0x0D
+#define REG_WIN_HEIGHT_L	0x0E
+#define REG_WIN_WIDTH_H		0x0F
+#define REG_WIN_WIDTH_L		0x10
+#define REG_SH_DELAY_H		0x11
+#define REG_SH_DELAY_L		0x12
+
+#define GC2155_START_STREAMING			0x90 /* 10-bit enable */
+#define GC2155_STOP_STREAMING			0x00 /* 10-bit disable */
+
+#define GC2155_REG_RST_AND_PG_SELECT	0xFE
+
+#define GC2155_BIN_FACTOR_MAX			3
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct gc2155_resolution {
+	u8 *desc;
+	const struct gc2155_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u32 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+};
+
+struct gc2155_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct gc2155_reg *regs;
+};
+
+struct gc2155_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * gc2155 device structure.
+ */
+struct gc2155_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u8 res;
+	u8 type;
+};
+
+enum gc2155_tok_type {
+	GC2155_8BIT  = 0x0001,
+	GC2155_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	GC2155_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	GC2155_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct gc2155_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct gc2155_reg {
+	enum gc2155_tok_type type;
+	u8 reg;
+	u8 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_gc2155_sensor(x) container_of(x, struct gc2155_device, sd)
+
+#define GC2155_MAX_WRITE_BUF_SIZE	30
+
+struct gc2155_write_buffer {
+	u8 addr;
+	u8 data[GC2155_MAX_WRITE_BUF_SIZE];
+};
+
+struct gc2155_write_ctrl {
+	int index;
+	struct gc2155_write_buffer buffer;
+};
+
+static const struct i2c_device_id gc2155_id[] = {
+	{GC2155_NAME, 0},
+	{}
+};
+
+/*
+ * Register settings for various resolution
+ */
+static const struct gc2155_reg gc2155_reset_register[] = {
+	{GC2155_8BIT, 0xfe, 0xf0},
+	{GC2155_8BIT, 0xfe, 0xf0},
+	{GC2155_8BIT, 0xfe, 0xf0},
+	{GC2155_8BIT, 0xfc, 0x06},
+	{GC2155_8BIT, 0xf6, 0x00},
+	{GC2155_8BIT, 0xf7, 0x1d},
+	{GC2155_8BIT, 0xf8, 0x85},
+	{GC2155_8BIT, 0xfa, 0x00},
+	{GC2155_8BIT, 0xf9, 0x8e},
+	{GC2155_8BIT, 0xf2, 0x0f},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0x03, 0x04},
+	{GC2155_8BIT, 0x04, 0x00},
+	{GC2155_8BIT, 0x05, 0x01},
+	{GC2155_8BIT, 0x06, 0x68},
+	{GC2155_8BIT, 0x09, 0x00},
+	{GC2155_8BIT, 0x0a, 0x00},
+	{GC2155_8BIT, 0x0b, 0x00},
+	{GC2155_8BIT, 0x0c, 0x00},
+	{GC2155_8BIT, 0x0d, 0x04},
+	{GC2155_8BIT, 0x0e, 0xd0},//src width
+	{GC2155_8BIT, 0x0f, 0x06},
+	{GC2155_8BIT, 0x10, 0x62},
+	{GC2155_8BIT, 0x12, 0x2e},
+	{GC2155_8BIT, 0x17, 0x14},
+	{GC2155_8BIT, 0x18, 0x0a},
+	{GC2155_8BIT, 0x19, 0x0b},
+	{GC2155_8BIT, 0x1a, 0x09},
+	{GC2155_8BIT, 0x1b, 0x4b},
+	{GC2155_8BIT, 0x1c, 0x07},
+	{GC2155_8BIT, 0x1d, 0x10},
+	{GC2155_8BIT, 0x1e, 0x98},
+	{GC2155_8BIT, 0x1f, 0x78},
+	{GC2155_8BIT, 0x20, 0x03},
+	{GC2155_8BIT, 0x21, 0x60},
+	{GC2155_8BIT, 0x22, 0xf0},
+	{GC2155_8BIT, 0x24, 0x16},
+	{GC2155_8BIT, 0x25, 0x01},
+	{GC2155_8BIT, 0x26, 0x10},
+	{GC2155_8BIT, 0x2d, 0x40},
+	{GC2155_8BIT, 0x30, 0x01},
+	{GC2155_8BIT, 0x33, 0x01},
+	{GC2155_8BIT, 0x34, 0x01},
+	{GC2155_8BIT, 0x80, 0x06},//ff//06
+	{GC2155_8BIT, 0x81, 0x80},//24//00
+	{GC2155_8BIT, 0x82, 0x30},//fa//03//J
+	{GC2155_8BIT, 0x83, 0x00},
+	{GC2155_8BIT, 0x84, 0x17},//DNDD mode
+	{GC2155_8BIT, 0x86, 0x16},//06
+	{GC2155_8BIT, 0x88, 0x03},
+	{GC2155_8BIT, 0x89, 0x03},// 0xb
+	{GC2155_8BIT, 0x85, 0x08},
+	{GC2155_8BIT, 0x8a, 0x00},
+	{GC2155_8BIT, 0x8b, 0x00},
+	{GC2155_8BIT, 0xb0, 0x55},
+	{GC2155_8BIT, 0xc3, 0x00},
+	{GC2155_8BIT, 0xc4, 0x80},
+	{GC2155_8BIT, 0xc5, 0x90},
+	{GC2155_8BIT, 0xc6, 0x38},
+	{GC2155_8BIT, 0xc7, 0x40},
+	{GC2155_8BIT, 0xec, 0x06},
+	{GC2155_8BIT, 0xed, 0x04},
+	{GC2155_8BIT, 0xee, 0x60},
+	{GC2155_8BIT, 0xef, 0x90},
+	{GC2155_8BIT, 0xb6, 0x00},//disable AEC
+	{GC2155_8BIT, 0x90, 0x01},
+	{GC2155_8BIT, 0x91, 0x00},
+	{GC2155_8BIT, 0x92, 0x00},//offset 0x10//00
+	{GC2155_8BIT, 0x93, 0x00},
+	{GC2155_8BIT, 0x94, 0x01},
+	{GC2155_8BIT, 0x95, 0x04},
+	{GC2155_8BIT, 0x96, 0xc0},//c0//d0
+	{GC2155_8BIT, 0x97, 0x06},
+	{GC2155_8BIT, 0x98, 0x50},
+	{GC2155_8BIT, 0x9a, 0x02},
+	{GC2155_8BIT, 0x18, 0x0a},
+	{GC2155_8BIT, 0x40, 0x43},
+	{GC2155_8BIT, 0x41, 0x28},
+	{GC2155_8BIT, 0x42, 0x60},
+	{GC2155_8BIT, 0x43, 0x54},
+	{GC2155_8BIT, 0x5e, 0x00},
+	{GC2155_8BIT, 0x5f, 0x00},
+	{GC2155_8BIT, 0x60, 0x00},
+	{GC2155_8BIT, 0x61, 0x00},
+	{GC2155_8BIT, 0x62, 0x00},
+	{GC2155_8BIT, 0x63, 0x00},
+	{GC2155_8BIT, 0x64, 0x00},
+	{GC2155_8BIT, 0x65, 0x00},
+	{GC2155_8BIT, 0x66, 0x20}, //BLK
+	{GC2155_8BIT, 0x67, 0x20}, //BLK
+	{GC2155_8BIT, 0x68, 0x20}, //BLK
+	{GC2155_8BIT, 0x69, 0x20}, //BLK
+	{GC2155_8BIT, 0x6a, 0x00},
+	{GC2155_8BIT, 0x6b, 0x00},
+	{GC2155_8BIT, 0x6c, 0x00},
+	{GC2155_8BIT, 0x6d, 0x00},
+	{GC2155_8BIT, 0x6e, 0x00},
+	{GC2155_8BIT, 0x6f, 0x00},
+	{GC2155_8BIT, 0x70, 0x00},
+	{GC2155_8BIT, 0x71, 0x00},
+	{GC2155_8BIT, 0x72, 0xf0},
+	{GC2155_8BIT, 0x7e, 0x00},
+	{GC2155_8BIT, 0x7f, 0x3c},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0x49, 0x00},
+	{GC2155_8BIT, 0x4b, 0x02},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0xfe, 0x01},
+	{GC2155_8BIT, 0x01, 0x04},
+	{GC2155_8BIT, 0x02, 0xc0},
+	{GC2155_8BIT, 0x03, 0x04},
+	{GC2155_8BIT, 0x04, 0x90},
+	{GC2155_8BIT, 0x05, 0x30},
+	{GC2155_8BIT, 0x06, 0x90},
+	{GC2155_8BIT, 0x07, 0x20},
+	{GC2155_8BIT, 0x08, 0x70},
+	{GC2155_8BIT, 0x09, 0x00},
+	{GC2155_8BIT, 0x0a, 0xc2},
+	{GC2155_8BIT, 0x0b, 0x11},
+	{GC2155_8BIT, 0x0c, 0x10},
+	{GC2155_8BIT, 0x13, 0x2a},
+	{GC2155_8BIT, 0x17, 0x00},
+	{GC2155_8BIT, 0x1c, 0x11},
+	{GC2155_8BIT, 0x1e, 0x61},
+	{GC2155_8BIT, 0x1f, 0x40},
+	{GC2155_8BIT, 0x20, 0x40},
+	{GC2155_8BIT, 0x22, 0x80},
+	{GC2155_8BIT, 0x23, 0x20},
+	{GC2155_8BIT, 0x12, 0x00},
+	{GC2155_8BIT, 0x15, 0x50},
+	{GC2155_8BIT, 0x10, 0x31},
+	{GC2155_8BIT, 0x3e, 0x28},
+	{GC2155_8BIT, 0x3f, 0xe0},
+	{GC2155_8BIT, 0x40, 0xe0},
+	{GC2155_8BIT, 0x41, 0x0f},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0x90, 0x6c},
+	{GC2155_8BIT, 0x91, 0x02},
+	{GC2155_8BIT, 0x92, 0x44},
+	{GC2155_8BIT, 0x97, 0x78},
+	{GC2155_8BIT, 0xa2, 0x11},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0x80, 0xc1},
+	{GC2155_8BIT, 0x81, 0x08},
+	{GC2155_8BIT, 0x82, 0x05},
+	{GC2155_8BIT, 0x83, 0x04},
+	{GC2155_8BIT, 0x84, 0x0a},
+	{GC2155_8BIT, 0x86, 0x80},
+	{GC2155_8BIT, 0x87, 0x30},
+	{GC2155_8BIT, 0x88, 0x15},
+	{GC2155_8BIT, 0x89, 0x80},
+	{GC2155_8BIT, 0x8a, 0x60},
+	{GC2155_8BIT, 0x8b, 0x30},
+	{GC2155_8BIT, 0xfe, 0x01},
+	{GC2155_8BIT, 0x21, 0x14},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0xa3, 0x60},
+	{GC2155_8BIT, 0xa4, 0x40},
+	{GC2155_8BIT, 0xa5, 0x40},
+	{GC2155_8BIT, 0xa6, 0x80},
+	{GC2155_8BIT, 0xab, 0x20},
+	{GC2155_8BIT, 0xae, 0x0c},
+	{GC2155_8BIT, 0xb3, 0x42},
+	{GC2155_8BIT, 0xb4, 0x24},
+	{GC2155_8BIT, 0xb6, 0x50},
+	{GC2155_8BIT, 0xb7, 0x01},
+	{GC2155_8BIT, 0xb9, 0x25},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0x10, 0x13},
+	{GC2155_8BIT, 0x11, 0x19},
+	{GC2155_8BIT, 0x12, 0x20},
+	{GC2155_8BIT, 0x13, 0x27},
+	{GC2155_8BIT, 0x14, 0x37},
+	{GC2155_8BIT, 0x15, 0x48},
+	{GC2155_8BIT, 0x16, 0x54},
+	{GC2155_8BIT, 0x17, 0x62},
+	{GC2155_8BIT, 0x18, 0x79},
+	{GC2155_8BIT, 0x19, 0x8a},
+	{GC2155_8BIT, 0x1a, 0x99},
+	{GC2155_8BIT, 0x1b, 0xa6},
+	{GC2155_8BIT, 0x1c, 0xb1},
+	{GC2155_8BIT, 0x1d, 0xc6},
+	{GC2155_8BIT, 0x1e, 0xd2},
+	{GC2155_8BIT, 0x1f, 0xde},
+	{GC2155_8BIT, 0x20, 0xe8},
+	{GC2155_8BIT, 0x21, 0xef},
+	{GC2155_8BIT, 0x22, 0xf4},
+	{GC2155_8BIT, 0x23, 0xfb},
+	{GC2155_8BIT, 0x24, 0xfd},
+	{GC2155_8BIT, 0x25, 0xff},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0x26, 0x0d},
+	{GC2155_8BIT, 0x27, 0x12},
+	{GC2155_8BIT, 0x28, 0x17},
+	{GC2155_8BIT, 0x29, 0x1c},
+	{GC2155_8BIT, 0x2a, 0x27},
+	{GC2155_8BIT, 0x2b, 0x34},
+	{GC2155_8BIT, 0x2c, 0x44},
+	{GC2155_8BIT, 0x2d, 0x55},
+	{GC2155_8BIT, 0x2e, 0x6e},
+	{GC2155_8BIT, 0x2f, 0x81},
+	{GC2155_8BIT, 0x30, 0x91},
+	{GC2155_8BIT, 0x31, 0x9c},
+	{GC2155_8BIT, 0x32, 0xaa},
+	{GC2155_8BIT, 0x33, 0xbb},
+	{GC2155_8BIT, 0x34, 0xca},
+	{GC2155_8BIT, 0x35, 0xd5},
+	{GC2155_8BIT, 0x36, 0xe0},
+	{GC2155_8BIT, 0x37, 0xe7},
+	{GC2155_8BIT, 0x38, 0xed},
+	{GC2155_8BIT, 0x39, 0xf6},
+	{GC2155_8BIT, 0x3a, 0xfb},
+	{GC2155_8BIT, 0x3b, 0xff},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0xd1, 0x20},
+	{GC2155_8BIT, 0xd2, 0x20},
+	{GC2155_8BIT, 0xdd, 0x80},
+	{GC2155_8BIT, 0xde, 0x84},
+	{GC2155_8BIT, 0xfe, 0x01},
+	{GC2155_8BIT, 0xc2, 0x15},
+	{GC2155_8BIT, 0xc3, 0x0c},
+	{GC2155_8BIT, 0xc4, 0x0b},
+	{GC2155_8BIT, 0xc8, 0x12},
+	{GC2155_8BIT, 0xc9, 0x0b},
+	{GC2155_8BIT, 0xca, 0x07},
+	{GC2155_8BIT, 0xbc, 0x3e},
+	{GC2155_8BIT, 0xbd, 0x2e},
+	{GC2155_8BIT, 0xbe, 0x2d},
+	{GC2155_8BIT, 0xb6, 0x3e},
+	{GC2155_8BIT, 0xb7, 0x2e},
+	{GC2155_8BIT, 0xb8, 0x2d},
+	{GC2155_8BIT, 0xc5, 0x00},
+	{GC2155_8BIT, 0xc6, 0x00},
+	{GC2155_8BIT, 0xc7, 0x00},
+	{GC2155_8BIT, 0xcb, 0x00},
+	{GC2155_8BIT, 0xcc, 0x00},
+	{GC2155_8BIT, 0xcd, 0x00},
+	{GC2155_8BIT, 0xbf, 0x09},
+	{GC2155_8BIT, 0xc0, 0x00},
+	{GC2155_8BIT, 0xc1, 0x00},
+	{GC2155_8BIT, 0xb9, 0x09},
+	{GC2155_8BIT, 0xba, 0x00},
+	{GC2155_8BIT, 0xbb, 0x00},
+	{GC2155_8BIT, 0xaa, 0x01},
+	{GC2155_8BIT, 0xab, 0x0f},
+	{GC2155_8BIT, 0xac, 0x0d},
+	{GC2155_8BIT, 0xad, 0x00},
+	{GC2155_8BIT, 0xae, 0x06},
+	{GC2155_8BIT, 0xaf, 0x08},
+	{GC2155_8BIT, 0xb0, 0x00},
+	{GC2155_8BIT, 0xb1, 0x06},
+	{GC2155_8BIT, 0xb2, 0x02},
+	{GC2155_8BIT, 0xb3, 0x01},
+	{GC2155_8BIT, 0xb4, 0x08},
+	{GC2155_8BIT, 0xb5, 0x05},
+	{GC2155_8BIT, 0xd0, 0x00},
+	{GC2155_8BIT, 0xd1, 0x00},
+	{GC2155_8BIT, 0xd2, 0x00},
+	{GC2155_8BIT, 0xd6, 0x00},
+	{GC2155_8BIT, 0xd7, 0x00},
+	{GC2155_8BIT, 0xd8, 0x00},
+	{GC2155_8BIT, 0xd9, 0x00},
+	{GC2155_8BIT, 0xda, 0x00},
+	{GC2155_8BIT, 0xdb, 0x00},
+	{GC2155_8BIT, 0xd3, 0x00},
+	{GC2155_8BIT, 0xd4, 0x00},
+	{GC2155_8BIT, 0xd5, 0x00},
+	{GC2155_8BIT, 0xa4, 0x00},
+	{GC2155_8BIT, 0xa5, 0x00},
+	{GC2155_8BIT, 0xa6, 0x77},
+	{GC2155_8BIT, 0xa7, 0x77},
+	{GC2155_8BIT, 0xa8, 0x77},
+	{GC2155_8BIT, 0xa9, 0x77},
+	{GC2155_8BIT, 0xa1, 0x80},
+	{GC2155_8BIT, 0xa2, 0x80},
+	{GC2155_8BIT, 0xfe, 0x01},
+	{GC2155_8BIT, 0xdc, 0x35},
+	{GC2155_8BIT, 0xdd, 0x28},
+	{GC2155_8BIT, 0xdf, 0x0c},
+	{GC2155_8BIT, 0xe0, 0x70},
+	{GC2155_8BIT, 0xe1, 0x80},
+	{GC2155_8BIT, 0xe2, 0x80},
+	{GC2155_8BIT, 0xe3, 0x80},
+	{GC2155_8BIT, 0xe6, 0x90},
+	{GC2155_8BIT, 0xe7, 0x50},
+	{GC2155_8BIT, 0xe8, 0x90},
+	{GC2155_8BIT, 0xe9, 0x60},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0xfe, 0x01},
+	{GC2155_8BIT, 0x4f, 0x00},
+	{GC2155_8BIT, 0x4f, 0x00},
+	{GC2155_8BIT, 0x4b, 0x01},
+	{GC2155_8BIT, 0x4f, 0x00},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x6f},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x70},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x8f},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x90},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x91},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xaf},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xb0},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xb1},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xcf},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xd0},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xed},
+	{GC2155_8BIT, 0x4e, 0x33},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xcd},
+	{GC2155_8BIT, 0x4e, 0x33},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xec},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x6c},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x6d},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x6e},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x8c},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x8d},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0x8e},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xab},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xac},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xad},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xae},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xcb},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xcc},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xce},
+	{GC2155_8BIT, 0x4e, 0x02},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xea},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xec},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xee},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x0c},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x0d},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x2c},
+	{GC2155_8BIT, 0x4e, 0x03},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xca},
+	{GC2155_8BIT, 0x4e, 0x34},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xcb},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xeb},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xc9},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xa9},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xe9},
+	{GC2155_8BIT, 0x4e, 0x04},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xc9},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x0a},
+	{GC2155_8BIT, 0x4e, 0x05},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x0b},
+	{GC2155_8BIT, 0x4e, 0x35},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x09},
+	{GC2155_8BIT, 0x4c, 0x01},
+	{GC2155_8BIT, 0x4d, 0xea},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x2a},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x49},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x29},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0xc8},
+	{GC2155_8BIT, 0x4e, 0x36},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0xa8},
+	{GC2155_8BIT, 0x4e, 0x36},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x88},
+	{GC2155_8BIT, 0x4e, 0x06},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0xa9},
+	{GC2155_8BIT, 0x4e, 0x06},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0xc9},
+	{GC2155_8BIT, 0x4e, 0x06},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x89},
+	{GC2155_8BIT, 0x4e, 0x06},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x69},
+	{GC2155_8BIT, 0x4e, 0x06},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0x6a},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0xc7},
+	{GC2155_8BIT, 0x4e, 0x07},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0xe7},
+	{GC2155_8BIT, 0x4e, 0x07},
+	{GC2155_8BIT, 0x4c, 0x03},
+	{GC2155_8BIT, 0x4d, 0x06},
+	{GC2155_8BIT, 0x4c, 0x03},
+	{GC2155_8BIT, 0x4d, 0x07},
+	{GC2155_8BIT, 0x4e, 0x37},
+	{GC2155_8BIT, 0x4c, 0x03},
+	{GC2155_8BIT, 0x4d, 0x08},
+	{GC2155_8BIT, 0x4e, 0x07},
+	{GC2155_8BIT, 0x4c, 0x02},
+	{GC2155_8BIT, 0x4d, 0xe8},
+	{GC2155_8BIT, 0x4e, 0x07},
+	{GC2155_8BIT, 0x4c, 0x03},
+	{GC2155_8BIT, 0x4d, 0x28},
+	{GC2155_8BIT, 0x4e, 0x07},
+	{GC2155_8BIT, 0x4f, 0x01},
+	{GC2155_8BIT, 0xfe, 0x01},
+	{GC2155_8BIT, 0x50, 0x80},
+	{GC2155_8BIT, 0x51, 0xa8},
+	{GC2155_8BIT, 0x52, 0x57},
+	{GC2155_8BIT, 0x53, 0x38},
+	{GC2155_8BIT, 0x54, 0xc7},
+	{GC2155_8BIT, 0x56, 0x0e},
+	{GC2155_8BIT, 0x58, 0x08},
+	{GC2155_8BIT, 0x5b, 0x00},
+	{GC2155_8BIT, 0x5c, 0x74},
+	{GC2155_8BIT, 0x5d, 0x8b},
+	{GC2155_8BIT, 0x61, 0xd3},
+	{GC2155_8BIT, 0x62, 0x90},
+	{GC2155_8BIT, 0x63, 0x04},
+	{GC2155_8BIT, 0x65, 0x04},
+	{GC2155_8BIT, 0x67, 0xb2},
+	{GC2155_8BIT, 0x68, 0xac},
+	{GC2155_8BIT, 0x69, 0x00},
+	{GC2155_8BIT, 0x6a, 0xb2},
+	{GC2155_8BIT, 0x6b, 0xac},
+	{GC2155_8BIT, 0x6c, 0xdc},
+	{GC2155_8BIT, 0x6d, 0xb0},
+	{GC2155_8BIT, 0x6e, 0x30},
+	{GC2155_8BIT, 0x6f, 0xff},
+	{GC2155_8BIT, 0x73, 0x00},
+	{GC2155_8BIT, 0x70, 0x05},
+	{GC2155_8BIT, 0x71, 0x80},
+	{GC2155_8BIT, 0x72, 0xc1},
+	{GC2155_8BIT, 0x74, 0x01},
+	{GC2155_8BIT, 0x75, 0x01},
+	{GC2155_8BIT, 0x7f, 0x0c},
+	{GC2155_8BIT, 0x76, 0x70},
+	{GC2155_8BIT, 0x77, 0x48},
+	{GC2155_8BIT, 0x78, 0x90},
+	{GC2155_8BIT, 0x79, 0x55},
+	{GC2155_8BIT, 0x7a, 0x48},
+	{GC2155_8BIT, 0x7b, 0x60},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0xfe, 0x02},
+	{GC2155_8BIT, 0xc0, 0x01},
+	{GC2155_8BIT, 0xc1, 0x50},
+	{GC2155_8BIT, 0xc2, 0xf8},
+	{GC2155_8BIT, 0xc3, 0x02},
+	{GC2155_8BIT, 0xc4, 0xe0},
+	{GC2155_8BIT, 0xc5, 0x45},
+	{GC2155_8BIT, 0xc6, 0xe8},
+	{GC2155_8BIT, 0xc7, 0x55},
+	{GC2155_8BIT, 0xc8, 0xf5},
+	{GC2155_8BIT, 0xc9, 0x00},
+	{GC2155_8BIT, 0xca, 0xea},
+	{GC2155_8BIT, 0xcb, 0x45},
+	{GC2155_8BIT, 0xcc, 0xf0},
+	{GC2155_8BIT, 0xCd, 0x45},
+	{GC2155_8BIT, 0xce, 0xf0},
+	{GC2155_8BIT, 0xcf, 0x00},
+	{GC2155_8BIT, 0xe3, 0xf0},
+	{GC2155_8BIT, 0xe4, 0x45},
+	{GC2155_8BIT, 0xe5, 0xe8},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0xf2, 0x0f},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0x05, 0x01},
+	{GC2155_8BIT, 0x06, 0x10},
+	{GC2155_8BIT, 0x07, 0x00},
+	{GC2155_8BIT, 0x08, 0x82},//VB : a0
+	{GC2155_8BIT, 0xfe, 0x01},
+	{GC2155_8BIT, 0x25, 0x00},
+	{GC2155_8BIT, 0x26, 0xd4},
+	{GC2155_8BIT, 0x27, 0x04},
+	{GC2155_8BIT, 0x28, 0xf8},
+	{GC2155_8BIT, 0x29, 0x08},
+	{GC2155_8BIT, 0x2a, 0x48},
+	{GC2155_8BIT, 0x2b, 0x0b},
+	{GC2155_8BIT, 0x2c, 0x98},
+	{GC2155_8BIT, 0x2d, 0x0f},
+	{GC2155_8BIT, 0x2e, 0xbc},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0xfe, 0x03},
+	{GC2155_8BIT, 0x01, 0x83},//discontin
+	{GC2155_8BIT, 0x02, 0x22},
+	{GC2155_8BIT, 0x03, 0x10},
+	{GC2155_8BIT, 0x04, 0x20},
+	{GC2155_8BIT, 0x05, 0x00},
+	{GC2155_8BIT, 0x06, 0x88},
+	{GC2155_8BIT, 0x10, 0x00},
+	{GC2155_8BIT, 0x11, 0x2b},
+	{GC2155_8BIT, 0x12, 0xe4},
+	{GC2155_8BIT, 0x13, 0x07},
+	{GC2155_8BIT, 0x15, 0x11},//discontin
+	{GC2155_8BIT, 0x17, 0xf1},
+	{GC2155_8BIT, 0x29, 0x01},//data prepare
+	{GC2155_8BIT, 0x22, 0x01},//clk prepare
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_TOK_TERM, 0, 0},
+};
+
+static struct gc2155_reg const gc2155_480p_30fps[] = {
+	/* window */
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0x09, 0x01},
+	{GC2155_8BIT, 0x0a, 0x68}, //Start Y
+	{GC2155_8BIT, 0x0b, 0x01},
+	{GC2155_8BIT, 0x0c, 0xB8}, //Start X
+	{GC2155_8BIT, 0x0d, 0x02},
+	{GC2155_8BIT, 0x0e, 0x00},
+	{GC2155_8BIT, 0x0f, 0x02},
+	{GC2155_8BIT, 0x10, 0xf0},
+	/* CROP */
+	{GC2155_8BIT, 0x90, 0x01},
+	{GC2155_8BIT, 0x92, 0x00},
+	{GC2155_8BIT, 0x94, 0x01},
+	{GC2155_8BIT, 0x95, 0x01},  //CROP H
+	{GC2155_8BIT, 0x96, 0xf0},
+	{GC2155_8BIT, 0x97, 0x02},  //CROP W 736
+	{GC2155_8BIT, 0x98, 0xe0},
+	/* PLL */
+	{GC2155_8BIT, 0xf8, 0x85},
+	/* MIPI */
+	{GC2155_8BIT, 0xfe, 0x03},
+	{GC2155_8BIT, 0x12, 0x98}, //1280*10/8
+	{GC2155_8BIT, 0x13, 0x03},
+	{GC2155_8BIT, 0xfe ,0x00},
+	{GC2155_TOK_TERM, 0, 0},
+};
+
+static struct gc2155_reg const gc2155_720p_30fps[] = {
+	/* window */
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0x0a, 0xd8},
+	{GC2155_8BIT, 0x0c, 0x88},
+	{GC2155_8BIT, 0x0d, 0x03},
+	{GC2155_8BIT, 0x0e, 0x00},
+	{GC2155_8BIT, 0x0f, 0x05},
+	{GC2155_8BIT, 0x10, 0x30},
+	/* subsample */
+	{GC2155_8BIT, 0x99, 0x11}, //OFF
+	/* CROP */
+	{GC2155_8BIT, 0x90, 0x01},
+	{GC2155_8BIT, 0x92, 0x00},
+	{GC2155_8BIT, 0x94, 0x01},
+	{GC2155_8BIT, 0x95, 0x02},  //CROP H
+	{GC2155_8BIT, 0x96, 0xe0},
+	{GC2155_8BIT, 0x97, 0x05},  //CROP W
+	{GC2155_8BIT, 0x98, 0x10},
+	/* MIPI */
+	{GC2155_8BIT, 0xfe, 0x03},
+	{GC2155_8BIT, 0x12, 0x54}, //1280*10/8
+	{GC2155_8BIT, 0x13, 0x06},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_TOK_TERM, 0, 0},
+};
+
+static struct gc2155_reg const gc2155_2M_30fps[] = {
+	/* window */
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0x0a, 0x00},
+	{GC2155_8BIT, 0x0c, 0x00},
+	{GC2155_8BIT, 0x0d, 0x04},
+	{GC2155_8BIT, 0x0e, 0xd0},
+	{GC2155_8BIT, 0x0f, 0x06},
+	{GC2155_8BIT, 0x10, 0x62},
+	/* subsample */
+	{GC2155_8BIT, 0x99, 0x11}, //OFF
+	/* CROP */
+	{GC2155_8BIT, 0x90, 0x01},
+	{GC2155_8BIT, 0x92, 0x00},
+	{GC2155_8BIT, 0x94, 0x01},
+	{GC2155_8BIT, 0x95, 0x04},  //CROP H    P H
+	{GC2155_8BIT, 0x96, 0xc0},
+	{GC2155_8BIT, 0x97, 0x06},  //CROP W    P W
+	{GC2155_8BIT, 0x98, 0x50},
+	/* MIPI */
+	{GC2155_8BIT, 0xfe, 0x03},
+	{GC2155_8BIT, 0x12, 0xe4}, //1280*10/8  *10/8
+	{GC2155_8BIT, 0x13, 0x07},
+        {GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_TOK_TERM, 0, 0},
+};
+
+static struct gc2155_reg const gc2155_1616x916_30fps[] = {
+	/* window */
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0x0a, 0x00},
+	{GC2155_8BIT, 0x0c, 0x00},
+	{GC2155_8BIT, 0x0d, 0x04}, //1232
+	{GC2155_8BIT, 0x0e, 0xd0},
+	{GC2155_8BIT, 0x0f, 0x06}, //1634
+	{GC2155_8BIT, 0x10, 0x62},
+	/* subsample */
+	{GC2155_8BIT, 0x99, 0x11}, //OFF
+	/* CROP */
+	{GC2155_8BIT, 0x90, 0x01},
+	{GC2155_8BIT, 0x92, 0x96}, //WinY 150
+	{GC2155_8BIT, 0x94, 0x01},
+	{GC2155_8BIT, 0x95, 0x03}, //CROP H    P H 916
+	{GC2155_8BIT, 0x96, 0x94},
+	{GC2155_8BIT, 0x97, 0x06}, //CROP W    P W  1616
+	{GC2155_8BIT, 0x98, 0x50},
+	/* MIPI */
+	{GC2155_8BIT, 0xfe, 0x03},
+	{GC2155_8BIT, 0x12, 0xe4}, //1280*10/8  *10/8
+	{GC2155_8BIT, 0x13, 0x07},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_TOK_TERM, 0, 0},
+};
+
+static struct gc2155_reg const gc2155_1616x1080_30fps[] = {
+	/* window */
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_8BIT, 0x0a, 0x00},
+	{GC2155_8BIT, 0x0c, 0x00},
+	{GC2155_8BIT, 0x0d, 0x04}, //1232
+	{GC2155_8BIT, 0x0e, 0xd0},
+	{GC2155_8BIT, 0x0f, 0x06}, //1634
+	{GC2155_8BIT, 0x10, 0x62},
+	/* subsample */
+	{GC2155_8BIT, 0x99, 0x11}, //OFF
+	/* CROP */
+	{GC2155_8BIT, 0x90, 0x01},
+	{GC2155_8BIT, 0x92, 0x00},
+	{GC2155_8BIT, 0x94, 0x01},
+	{GC2155_8BIT, 0x95, 0x04}, //CROP H    P H 1080
+	{GC2155_8BIT, 0x96, 0x38},
+	{GC2155_8BIT, 0x97, 0x06}, //CROP W    P W  1616
+	{GC2155_8BIT, 0x98, 0x50},
+	/* MIPI */
+	{GC2155_8BIT, 0xfe, 0x03},
+	{GC2155_8BIT, 0x12, 0xe4}, //1280*10/8  *10/8
+	{GC2155_8BIT, 0x13, 0x07},
+	{GC2155_8BIT, 0xfe, 0x00},
+	{GC2155_TOK_TERM, 0, 0},
+};
+
+struct gc2155_resolution gc2155_res_preview[] = {
+	{
+		.desc = "gc2155_2M_30fps",
+		.width = 1616,
+		.height = 1216,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 1632,
+		.lines_per_frame = 1248,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc2155_2M_30fps,
+	},
+	{
+		.desc = "gc2155_1616x916_30fps",
+		.width = 1616,
+		.height = 916,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 1632,
+		.lines_per_frame = 1248,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc2155_1616x916_30fps,
+	},
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(gc2155_res_preview))
+
+struct gc2155_resolution gc2155_res_still[] = {
+	{
+		.desc = "gc2155_2M_30fps",
+		.width = 1616,
+		.height = 1216,
+		.fps = 30,
+		//.pix_clk_freq = 73,//calculator in gc2155_get_intg_factor
+		.used = 0,
+		.pixels_per_line = 1632,//calculator in gc2155_get_intg_factor
+		.lines_per_frame = 1248,//calculator in gc2155_get_intg_factor
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc2155_2M_30fps,
+	},
+	{
+		.desc = "gc2155_1616x916_30fps",
+		.width = 1616,
+		.height = 916,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 1632,
+		.lines_per_frame = 1248,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc2155_1616x916_30fps,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(gc2155_res_still))
+
+struct gc2155_resolution gc2155_res_video[] = {
+	{
+		.desc = "gc2155_1616x916_30fps",
+		.width = 1616,
+		.height = 916,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 1632,
+		.lines_per_frame = 1248,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc2155_1616x916_30fps,
+	},
+	{
+		.desc = "gc2155_1616x1080_30fps",
+		.width = 1616,
+		.height = 1080,
+		.fps = 30,
+		//.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 1632,
+		.lines_per_frame = 1248,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 2,
+		.regs = gc2155_1616x1080_30fps,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(gc2155_res_video))
+
+static struct gc2155_resolution *gc2155_res = gc2155_res_preview;
+static int N_RES = N_RES_PREVIEW;
+#endif
-- 
2.1.0

