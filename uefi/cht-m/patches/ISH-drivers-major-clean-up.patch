From 9fd37f08653fd4ecbbd9997538b3fe194c35e619 Mon Sep 17 00:00:00 2001
From: Daniel Drubin <idaniel.drubin@intel.com>
Date: Sun, 17 Apr 2016 16:44:57 +0300
Subject: [PATCH 1/4] ISH drivers major clean-up

Major clean-up in ISH drivers in prep to upstream to Linux kernel
Cleaned up complilers warnings
Removed dead and unused code
Improved readability
Massive diagnostics moved from sysfs to debugfs
Renamed "HECI" to "ISHTP" (ISH Transport Protocol), to avoid confusion
with association of HECI with AMT
Moved to C99 stdint types
Removed ISH_PATH_IIO from defconfig

Change-Id: I9ab74c0fd65df839b03657122b88b0f859ff49ed
Tracked-On: https://jira01.devtools.intel.com/browse/OAM-23374
Signed-off-by: Daniel Drubin <daniel.drubin@intel.com>
Reviewed-on: https://android.intel.com:443/479041
---
 arch/x86/configs/x86_64_defconfig         |   1 -
 drivers/misc/intel-ish/Kconfig            |  42 +-
 drivers/misc/intel-ish/Makefile           |  30 +-
 drivers/misc/intel-ish/bus.c              | 525 ++++++++--------
 drivers/misc/intel-ish/bus.h              | 148 ++---
 drivers/misc/intel-ish/client.c           | 952 ++++++++++++-----------------
 drivers/misc/intel-ish/client.h           | 221 +++----
 drivers/misc/intel-ish/debugfs.c          | 206 +++++--
 drivers/misc/intel-ish/hbm.c              | 954 ++++++++++++++---------------
 drivers/misc/intel-ish/hbm.h              | 383 +++++-------
 drivers/misc/intel-ish/heci-api.c         | 692 ---------------------
 drivers/misc/intel-ish/heci-api.h         | 115 ----
 drivers/misc/intel-ish/heci-hid-client.c  | 807 ------------------------
 drivers/misc/intel-ish/heci-hid.c         | 251 --------
 drivers/misc/intel-ish/heci-hid.h         | 133 ----
 drivers/misc/intel-ish/heci_dev.h         | 352 -----------
 drivers/misc/intel-ish/hid-sens-ids.h     | 681 +++++++++++----------
 drivers/misc/intel-ish/hid-strings-def.h  |   4 +-
 drivers/misc/intel-ish/hw-ish-regs.h      | 107 ++--
 drivers/misc/intel-ish/hw-ish.c           | 980 ------------------------------
 drivers/misc/intel-ish/hw-ish.h           |  41 +-
 drivers/misc/intel-ish/init.c             | 239 ++------
 drivers/misc/intel-ish/ipc.c              | 679 +++++++++++++++++++++
 drivers/misc/intel-ish/ishtp-api.c        | 484 +++++++++++++++
 drivers/misc/intel-ish/ishtp-api.h        | 117 ++++
 drivers/misc/intel-ish/ishtp-hid-client.c | 612 +++++++++++++++++++
 drivers/misc/intel-ish/ishtp-hid.c        | 183 ++++++
 drivers/misc/intel-ish/ishtp-hid.h        | 131 ++++
 drivers/misc/intel-ish/ishtp_dev.h        | 269 ++++++++
 drivers/misc/intel-ish/pci-ish.c          | 765 +++++++----------------
 drivers/misc/intel-ish/platform-config.h  |  94 +--
 drivers/misc/intel-ish/senscol-core.c     |   4 +-
 drivers/misc/intel-ish/utils.h            |  62 +-
 33 files changed, 4795 insertions(+), 6469 deletions(-)
 delete mode 100644 drivers/misc/intel-ish/heci-api.c
 delete mode 100644 drivers/misc/intel-ish/heci-api.h
 delete mode 100644 drivers/misc/intel-ish/heci-hid-client.c
 delete mode 100644 drivers/misc/intel-ish/heci-hid.c
 delete mode 100644 drivers/misc/intel-ish/heci-hid.h
 delete mode 100644 drivers/misc/intel-ish/heci_dev.h
 delete mode 100644 drivers/misc/intel-ish/hw-ish.c
 create mode 100644 drivers/misc/intel-ish/ipc.c
 create mode 100644 drivers/misc/intel-ish/ishtp-api.c
 create mode 100644 drivers/misc/intel-ish/ishtp-api.h
 create mode 100644 drivers/misc/intel-ish/ishtp-hid-client.c
 create mode 100644 drivers/misc/intel-ish/ishtp-hid.c
 create mode 100644 drivers/misc/intel-ish/ishtp-hid.h
 create mode 100644 drivers/misc/intel-ish/ishtp_dev.h

diff --git a/arch/x86/configs/x86_64_defconfig b/arch/x86/configs/x86_64_defconfig
index ed720b6..7ac729a7 100644
--- a/arch/x86/configs/x86_64_defconfig
+++ b/arch/x86/configs/x86_64_defconfig
@@ -1230,7 +1230,6 @@ CONFIG_INTEL_MEI_ME=y
 CONFIG_INTEL_MEI_TXE=y
 CONFIG_INTEL_ISH=m
 CONFIG_ISH_PATH_SENSCOL=m
-# CONFIG_ISH_PATH_IIO is not set
 # CONFIG_VMWARE_VMCI is not set
 
 #
diff --git a/drivers/misc/intel-ish/Kconfig b/drivers/misc/intel-ish/Kconfig
index e19c2b7..30f5038 100644
--- a/drivers/misc/intel-ish/Kconfig
+++ b/drivers/misc/intel-ish/Kconfig
@@ -1,26 +1,34 @@
 config INTEL_ISH
-	tristate "Intel Integrated Sensors Solution"
+	tristate "Intel Integrated Sensor Hub"
 	depends on X86 && PCI
 	help
-	  ISS enabled sensors hub functionality on SoC/chipset level.
-	  Placeholder for description line 2.
-	  Placeholder for description line 3.
-	  Placeholder for description line 4.
+	  ISH enables sensors hub functionality on SoC/chipset level.
+	  Integrated Sensor Hub (ISH) allows connecting and streaming
+	  many sensors at once, adding algorithms (as custom sensors)
+	  and saving power by offloading sensors polling and algorithms
+	  to low-power complex in chipset.
+
+	  ISH can operate in low-power system modes and can aggregate
+	  sensors data in batches, optionally also providing wake event
+	  to CPU (wake sensors functionality).
+
+	  Chips that include ISH support: Cherrytrail, Skylake, Broxton
 
 config ISH_PATH_SENSCOL
-	tristate "ISS path through sensor-collection"
+	tristate "ISH path through sensor-collection"
 	depends on INTEL_ISH
 	help
 	  Enables sensor-collection path for ISH
-	  Placeholder for description line 2.
-	  Placeholder for description line 3.
-	  Placeholder for description line 4.
+	  Sensor-collection is a collection (hub) interface exposed to
+	  user-mode with multiplexed data and possibly aggregated properties
+	  setting/reading. Interface is provided through file/device POSIX
+	  system calls.
+
+	  Through sensor-collection custom sensors may be added only in
+	  firmware, no modification of kernel code is necessary; once sensor
+	  algorithm is added in firmware it will automatically expose to
+	  user-mode.
+
+	  Disable sensor-collection path if you want to expose a different
+	  interface to user-mode, such as IIO
 
-config ISH_PATH_IIO
-	tristate "ISS path through IIO"
-	depends on INTEL_ISH
-	help
-	  Enables IIO path for ISH
-	  Placeholder for description line 2.
-	  Placeholder for description line 3.
-	  Placeholder for description line 4.
diff --git a/drivers/misc/intel-ish/Makefile b/drivers/misc/intel-ish/Makefile
index 79076bd..b89631a 100644
--- a/drivers/misc/intel-ish/Makefile
+++ b/drivers/misc/intel-ish/Makefile
@@ -1,22 +1,22 @@
 #
-# Makefile - Intel HECI and ISS implementation
-# Copyright (c) 2010-2015, Intel Corporation.
+# Makefile - Intel ISH drivers
+# Copyright (c) 2014-2016, Intel Corporation.
 #
-obj-$(CONFIG_INTEL_ISH) += heci.o
-heci-objs := init.o
-heci-objs += hbm.o
-heci-objs += client.o
-heci-objs += heci-api.o
-heci-objs += bus.o
-heci-$(CONFIG_DEBUG_FS) += debugfs.o
+obj-$(CONFIG_INTEL_ISH) += ishtp.o
+ishtp-objs := init.o
+ishtp-objs += hbm.o
+ishtp-objs += client.o
+ishtp-objs += ishtp-api.o
+ishtp-objs += bus.o
+ishtp-$(CONFIG_DEBUG_FS) += debugfs.o
 
-obj-$(CONFIG_INTEL_ISH) += heci-ish.o
-heci-ish-objs := hw-ish.o
-heci-ish-objs += pci-ish.o
+obj-$(CONFIG_INTEL_ISH) += ish.o
+ish-objs := ipc.o
+ish-objs += pci-ish.o
 
-obj-$(CONFIG_INTEL_ISH) += hid-heci-ish.o
-hid-heci-ish-objs := heci-hid.o
-hid-heci-ish-objs += heci-hid-client.o
+obj-$(CONFIG_INTEL_ISH) += hid-ishtp.o
+hid-ishtp-objs := ishtp-hid.o
+hid-ishtp-objs += ishtp-hid-client.o
 
 obj-$(CONFIG_INTEL_ISH) += ish-hid-drv.o
 ish-hid-drv-objs := ish-hid-dd.o
diff --git a/drivers/misc/intel-ish/bus.c b/drivers/misc/intel-ish/bus.c
index 6c5a13b..b8fed50 100644
--- a/drivers/misc/intel-ish/bus.c
+++ b/drivers/misc/intel-ish/bus.c
@@ -1,7 +1,7 @@
 /*
- * HECI bus driver
+ * ISHTP bus driver
  *
- * Copyright (c) 2012-2015, Intel Corporation.
+ * Copyright (c) 2012-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,124 +9,196 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
-#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
-#include <linux/init.h>
-#include <linux/errno.h>
 #include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
+#include <asm/page.h>
 #include "bus.h"
-#include "heci_dev.h"
+#include "ishtp_dev.h"
 #include "client.h"
-#include <asm/page.h>
 #include "hbm.h"
-#include "utils.h"
+#include "hw-ish-regs.h"
+
+#define to_ishtp_cl_driver(d) container_of(d, struct ishtp_cl_driver, driver)
+#define to_ishtp_cl_device(d) container_of(d, struct ishtp_cl_device, dev)
+
+
+/* ISHTP Handler for IPC_RESET notification */
+int	ishtp_reset_handler(struct ishtp_device *dev)
+{
+	unsigned long	flags;
+
+	/* Handle FW-initiated reset */
+	dev->dev_state = ISHTP_DEV_RESETTING;
 
-#define to_heci_cl_driver(d) container_of(d, struct heci_cl_driver, driver)
-#define to_heci_cl_device(d) container_of(d, struct heci_cl_device, dev)
+	/* Clear BH processing queue - no further HBMs */
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	dev->rd_msg_fifo_head = dev->rd_msg_fifo_tail = 0;
+	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+
+	/* Handle ISH FW reset against upper layers */
+	ishtp_bus_remove_all_clients(dev);	/* Remove all client devices */
+
+	return	0;
+}
+EXPORT_SYMBOL(ishtp_reset_handler);
+
+/* ISHTP handler for IPC_RESET sequence completion  */
+int	ishtp_reset_compl_handler(struct ishtp_device *dev)
+{
+	dev->dev_state = ISHTP_DEV_INIT_CLIENTS;
+	dev->hbm_state = ISHTP_HBM_START;
+	ishtp_hbm_start_req(dev);
+
+	return	0;
+}
+EXPORT_SYMBOL(ishtp_reset_compl_handler);
+
+void	recv_ishtp(struct ishtp_device *dev)
+{
+	uint32_t	msg_hdr;
+	struct ishtp_msg_hdr	*ishtp_hdr;
+
+	/* Read ISHTP header dword */
+	msg_hdr = dev->ops->ishtp_read_hdr(dev);
+	if (!msg_hdr)
+		return;
+
+	dev->ops->sync_fw_clock(dev);
+
+	ishtp_hdr = (struct ishtp_msg_hdr *)&msg_hdr;
+	dev->ishtp_msg_hdr = msg_hdr;
+
+	/* Sanity check: ISHTP frag. length in header */
+	if (ishtp_hdr->length > dev->mtu) {
+		dev_err(dev->devc,
+			"ISHTP hdr - bad length: %u; dropped [%08X]\n",
+			(unsigned)ishtp_hdr->length, msg_hdr);
+		return;
+	}
+
+	/* ISHTP bus message */
+	if (!ishtp_hdr->host_addr && !ishtp_hdr->fw_addr)
+		recv_hbm(dev, ishtp_hdr);
+	/* ISHTP fixed-client message */
+	else if (!ishtp_hdr->host_addr)
+		recv_fixed_cl_msg(dev, ishtp_hdr);
+	else
+		/* ISHTP client message */
+		recv_ishtp_cl_msg(dev, ishtp_hdr);
+}
+EXPORT_SYMBOL(recv_ishtp);
+
+/* Write a multi-fragment message */
+int	send_ishtp_msg(struct ishtp_device *dev,
+	struct ishtp_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
+	void *ipc_send_compl_prm)
+{
+	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
+	uint32_t	drbl_val;
+
+	drbl_val = IPC_BUILD_HEADER(hdr->length + sizeof(struct ishtp_msg_hdr),
+		IPC_PROTOCOL_ISHTP, 1);
+
+	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
+	memcpy(ipc_msg + sizeof(uint32_t), hdr, sizeof(uint32_t));
+	memcpy(ipc_msg + 2 * sizeof(uint32_t), msg, hdr->length);
+	return	dev->ops->write(dev, ipc_send_compl, ipc_send_compl_prm,
+		ipc_msg, 2 * sizeof(uint32_t) + hdr->length);
+}
+
+/* Write a single-fragment message */
+int ishtp_write_message(struct ishtp_device *dev,
+	struct ishtp_msg_hdr *hdr, unsigned char *buf)
+{
+	return send_ishtp_msg(dev, hdr, buf, NULL, NULL);
+}
 
 /**
- * heci_me_cl_by_uuid - locate index of me client
+ * ishtp_fw_cl_by_uuid - locate index of fw client
  *
- * @dev: heci device
- * returns me client index or -ENOENT if not found
+ * @dev: ishtp device
+ * returns fw client index or -ENOENT if not found
  */
-int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *uuid)
+int ishtp_fw_cl_by_uuid(struct ishtp_device *dev, const uuid_le *uuid)
 {
 	int i, res = -ENOENT;
-	unsigned long	flags;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	for (i = 0; i < dev->me_clients_num; ++i) {
-		if (uuid_le_cmp(*uuid, dev->me_clients[i].props.protocol_name)
+	for (i = 0; i < dev->fw_clients_num; ++i) {
+		if (uuid_le_cmp(*uuid, dev->fw_clients[i].props.protocol_name)
 				== 0) {
 			res = i;
 			break;
 		}
 	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 	return res;
 }
-EXPORT_SYMBOL(heci_me_cl_by_uuid);
-
+EXPORT_SYMBOL(ishtp_fw_cl_by_uuid);
 
 /**
- * heci_me_cl_by_id return index to me_clients for client_id
+ * ishtp_fw_cl_by_id - return index to fw_clients for client_id
  *
  * @dev: the device structure
- * @client_id: me client id
+ * @client_id: fw client id
  *
  * returns index on success, -ENOENT on failure.
  */
 
-int heci_me_cl_by_id(struct heci_device *dev, u8 client_id)
+int ishtp_fw_cl_by_id(struct ishtp_device *dev, uint8_t client_id)
 {
 	int i;
 	unsigned long	flags;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	for (i = 0; i < dev->me_clients_num; i++)
-		if (dev->me_clients[i].client_id == client_id)
+	spin_lock_irqsave(&dev->fw_clients_lock, flags);
+	for (i = 0; i < dev->fw_clients_num; i++)
+		if (dev->fw_clients[i].client_id == client_id)
 			break;
-	if (WARN_ON(dev->me_clients[i].client_id != client_id)) {
-		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	if (WARN_ON(dev->fw_clients[i].client_id != client_id)) {
+		spin_unlock_irqrestore(&dev->fw_clients_lock, flags);
 		return -ENOENT;
 	}
 
-	if (i == dev->me_clients_num) {
-		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	if (i == dev->fw_clients_num) {
+		spin_unlock_irqrestore(&dev->fw_clients_lock, flags);
 		return -ENOENT;
 	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	spin_unlock_irqrestore(&dev->fw_clients_lock, flags);
 	return i;
 }
 
-static int heci_cl_device_match(struct device *dev, struct device_driver *drv)
+static int ishtp_cl_device_match(struct device *dev, struct device_driver *drv)
 {
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ returns 1\n", __func__);
-
 	/*
 	 * DD -- return true and let driver's probe() routine decide.
-	 * If this solution lives up, we can rearrange it
-	 * by simply removing match() routine at all
+	 * we can rearrange it by simply removing match() routine at all
 	 */
 	return	1;
 }
 
-static int heci_cl_device_probe(struct device *dev)
+static int ishtp_cl_device_probe(struct device *dev)
 {
-	struct heci_cl_device *device = to_heci_cl_device(dev);
-	struct heci_cl_driver *driver;
-	struct heci_cl_device_id id;
+	struct ishtp_cl_device *device = to_ishtp_cl_device(dev);
+	struct ishtp_cl_driver *driver;
 
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	if (!device)
 		return 0;
 
 	/* in many cases here will be NULL */
-	driver = to_heci_cl_driver(dev->driver);
+	driver = to_ishtp_cl_driver(dev->driver);
 	if (!driver || !driver->probe)
 		return -ENODEV;
 
-	dev_dbg(dev, "Device probe\n");
-
-	strncpy(id.name, dev_name(dev), HECI_CL_NAME_SIZE-1);
-	id.name[HECI_CL_NAME_SIZE-1] = '\0';
-
-	return driver->probe(device, &id);
+	return driver->probe(device);
 }
 
-static int heci_cl_device_remove(struct device *dev)
+static int ishtp_cl_device_remove(struct device *dev)
 {
-	struct heci_cl_device *device = to_heci_cl_device(dev);
-	struct heci_cl_driver *driver;
+	struct ishtp_cl_device *device = to_ishtp_cl_device(dev);
+	struct ishtp_cl_driver *driver;
 
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	if (!device || !dev->driver)
 		return 0;
 
@@ -135,7 +207,7 @@ static int heci_cl_device_remove(struct device *dev)
 		cancel_work_sync(&device->event_work);
 	}
 
-	driver = to_heci_cl_driver(dev->driver);
+	driver = to_ishtp_cl_driver(dev->driver);
 	if (!driver->remove) {
 		dev->driver = NULL;
 
@@ -150,67 +222,63 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
 {
 	int len;
 
-	len = snprintf(buf, PAGE_SIZE, "heci:%s\n", dev_name(dev));
+	len = snprintf(buf, PAGE_SIZE, "ishtp:%s\n", dev_name(dev));
 	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
 }
 
-static struct device_attribute heci_cl_dev_attrs[] = {
+static struct device_attribute ishtp_cl_dev_attrs[] = {
 	__ATTR_RO(modalias),
 	__ATTR_NULL,
 };
 
-static int heci_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
+static int ishtp_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
-	if (add_uevent_var(env, "MODALIAS=heci:%s", dev_name(dev)))
+	if (add_uevent_var(env, "MODALIAS=ishtp:%s", dev_name(dev)))
 		return -ENOMEM;
 
 	return 0;
 }
 
-static struct bus_type heci_cl_bus_type = {
-	.name		= "heci",
-	.dev_attrs	= heci_cl_dev_attrs,
-	.match		= heci_cl_device_match,
-	.probe		= heci_cl_device_probe,
-	.remove		= heci_cl_device_remove,
-	.uevent		= heci_cl_uevent,
+static struct bus_type ishtp_cl_bus_type = {
+	.name		= "ishtp",
+	.dev_attrs	= ishtp_cl_dev_attrs,
+	.match		= ishtp_cl_device_match,
+	.probe		= ishtp_cl_device_probe,
+	.remove		= ishtp_cl_device_remove,
+	.uevent		= ishtp_cl_uevent,
 };
 
-static void heci_cl_dev_release(struct device *dev)
+static void ishtp_cl_dev_release(struct device *dev)
 {
-	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
-	kfree(to_heci_cl_device(dev));
-	ISH_DBG_PRINT(KERN_ALERT "%s():---\n", __func__);
+	kfree(to_ishtp_cl_device(dev));
 }
 
-static struct device_type heci_cl_device_type = {
-	.release	= heci_cl_dev_release,
+static struct device_type ishtp_cl_device_type = {
+	.release	= ishtp_cl_dev_release,
 };
 
 /*
- * Allocate HECI bus client device, attach it to uuid and register with HECI bus
+ * Allocate ISHTP bus client device, attach it to uuid
+ * and register with ISHTP bus
  */
-struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
-	uuid_le uuid, char *name, struct heci_cl_dev_ops *ops)
+struct ishtp_cl_device *ishtp_bus_add_device(struct ishtp_device *dev,
+	uuid_le uuid, char *name)
 {
-	struct heci_cl_device *device;
+	struct ishtp_cl_device *device;
 	int status;
 	unsigned long flags;
 
-	device = kzalloc(sizeof(struct heci_cl_device), GFP_ATOMIC);
+	device = kzalloc(sizeof(struct ishtp_cl_device), GFP_KERNEL);
 	if (!device)
 		return NULL;
 
-	device->ops = ops;
-
-	device->dev.parent = &dev->pdev->dev;
-	device->dev.bus = &heci_cl_bus_type;
-	device->dev.type = &heci_cl_device_type;
-	device->heci_dev = dev;
+	device->dev.parent = dev->devc;
+	device->dev.bus = &ishtp_cl_bus_type;
+	device->dev.type = &ishtp_cl_device_type;
+	device->ishtp_dev = dev;
 
-	/* no need for spin lock here, the caller locked me_clients_lock */
 	device->fw_client =
-		&dev->me_clients[dev->me_client_presentation_num - 1];
+		&dev->fw_clients[dev->fw_client_presentation_num - 1];
 
 	dev_set_name(&device->dev, "%s", name);
 
@@ -223,44 +291,35 @@ struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
 		spin_lock_irqsave(&dev->device_list_lock, flags);
 		list_del(&device->device_link);
 		spin_unlock_irqrestore(&dev->device_list_lock, flags);
-		dev_err(&dev->pdev->dev, "Failed to register HECI device\n");
+		dev_err(dev->devc, "Failed to register ISHTP client device\n");
 		kfree(device);
 		return NULL;
 	}
-
-	dev_dbg(&device->dev, "client %s registered\n", name);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): Registered HECI device\n", __func__);
-
 	return device;
 }
-EXPORT_SYMBOL_GPL(heci_bus_add_device);
-
 
 /*
- * This is a counterpart of heci_bus_add_device.
- * Device is unregistered and its structure is also freed
+ * This is a counterpart of ishtp_bus_add_device.
+ * Device is unregistered.
+ * the device structure is freed in 'ishtp_cl_dev_release' function
  */
-void heci_bus_remove_device(struct heci_cl_device *device)
+void ishtp_bus_remove_device(struct ishtp_cl_device *device)
 {
 	device_unregister(&device->dev);
-	/*kfree(device);*/
 }
-EXPORT_SYMBOL_GPL(heci_bus_remove_device);
-
 
 /*
  * Part of reset flow
  */
-void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
+void	ishtp_bus_remove_all_clients(struct ishtp_device *ishtp_dev)
 {
-	struct heci_cl_device	*cl_device, *next_device;
-	struct heci_cl	*cl, *next;
+	struct ishtp_cl_device	*cl_device, *next_device;
+	struct ishtp_cl	*cl, *next;
 	unsigned long	flags;
 
-	spin_lock_irqsave(&heci_dev->cl_list_lock, flags);
-	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
-/*		list_del(&cl->link);*/
-		cl->state = HECI_CL_DISCONNECTED;
+	spin_lock_irqsave(&ishtp_dev->cl_list_lock, flags);
+	list_for_each_entry_safe(cl, next, &ishtp_dev->cl_list, link) {
+		cl->state = ISHTP_CL_DISCONNECTED;
 
 		/*
 		 * Wake any pending process. The waiter would check dev->state
@@ -272,14 +331,14 @@ void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
 		if (waitqueue_active(&cl->wait_ctrl_res))
 			wake_up(&cl->wait_ctrl_res);
 
-		/* Disband any pending read/write requests and free RB */
-		heci_cl_flush_queues(cl);
+		/* Disband any pending read/write requests and free rb */
+		ishtp_cl_flush_queues(cl);
 
 		/* Remove read_rb for user-mode API clients */
 		if (cl->read_rb) {
-			struct heci_cl_rb *rb = NULL;
+			struct ishtp_cl_rb *rb = NULL;
 
-			rb = heci_cl_find_read_rb(cl);
+			rb = ishtp_cl_find_read_rb(cl);
 			/* Remove entry from read list */
 			if (rb)
 				list_del(&rb->list);
@@ -288,176 +347,104 @@ void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
 			cl->read_rb = NULL;
 
 			if (rb) {
-				heci_io_rb_free(rb);
+				ishtp_io_rb_free(rb);
 				rb = NULL;
 			}
 		}
 
 		/* Remove all free and in_process rings, both Rx and Tx */
-		heci_cl_free_rx_ring(cl);
-		heci_cl_free_tx_ring(cl);
+		ishtp_cl_free_rx_ring(cl);
+		ishtp_cl_free_tx_ring(cl);
 
-		/* Free client and HECI bus client device structures */
+		/* Free client and ISHTP bus client device structures */
 		/* don't free host client because it is part of the OS fd
 		   structure */
 	}
-	spin_unlock_irqrestore(&heci_dev->cl_list_lock, flags);
+	spin_unlock_irqrestore(&ishtp_dev->cl_list_lock, flags);
 
 	/* remove bus clients */
-	spin_lock_irqsave(&heci_dev->device_list_lock, flags);
+	spin_lock_irqsave(&ishtp_dev->device_list_lock, flags);
 	list_for_each_entry_safe(cl_device, next_device,
-		&heci_dev->device_list, device_link) {
+		&ishtp_dev->device_list, device_link) {
 			list_del(&cl_device->device_link);
-			spin_unlock_irqrestore(&heci_dev->device_list_lock,
+			spin_unlock_irqrestore(&ishtp_dev->device_list_lock,
 				flags);
-			heci_bus_remove_device(cl_device);
-			spin_lock_irqsave(&heci_dev->device_list_lock, flags);
+			ishtp_bus_remove_device(cl_device);
+			spin_lock_irqsave(&ishtp_dev->device_list_lock, flags);
 		}
-	spin_unlock_irqrestore(&heci_dev->device_list_lock, flags);
+	spin_unlock_irqrestore(&ishtp_dev->device_list_lock, flags);
 
 	/* Free all client structures */
-	spin_lock_irqsave(&heci_dev->me_clients_lock, flags);
-	kfree(heci_dev->me_clients);
-	heci_dev->me_clients = NULL;
-	heci_dev->me_clients_num = 0;
-	heci_dev->me_client_presentation_num  = 0;
-	heci_dev->me_client_index = 0;
-	bitmap_zero(heci_dev->me_clients_map, HECI_CLIENTS_MAX);
-/*
-	bitmap_zero(heci_dev->host_clients_map, HECI_CLIENTS_MAX);
-	bitmap_set(heci_dev->host_clients_map, 0, 3);
-*/
-	spin_unlock_irqrestore(&heci_dev->me_clients_lock, flags);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	spin_lock_irqsave(&ishtp_dev->fw_clients_lock, flags);
+	kfree(ishtp_dev->fw_clients);
+	ishtp_dev->fw_clients = NULL;
+	ishtp_dev->fw_clients_num = 0;
+	ishtp_dev->fw_client_presentation_num = 0;
+	ishtp_dev->fw_client_index = 0;
+	bitmap_zero(ishtp_dev->fw_clients_map, ISHTP_CLIENTS_MAX);
+	spin_unlock_irqrestore(&ishtp_dev->fw_clients_lock, flags);
 }
-EXPORT_SYMBOL_GPL(heci_bus_remove_all_clients);
+EXPORT_SYMBOL(ishtp_bus_remove_all_clients);
 
-
-int __heci_cl_driver_register(struct heci_cl_driver *driver,
+int __ishtp_cl_driver_register(struct ishtp_cl_driver *driver,
 	struct module *owner)
 {
 	int err;
 
 	driver->driver.name = driver->name;
 	driver->driver.owner = owner;
-	driver->driver.bus = &heci_cl_bus_type;
+	driver->driver.bus = &ishtp_cl_bus_type;
 
 	err = driver_register(&driver->driver);
 	if (err)
 		return err;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): heci: driver [%s] registered\n",
-		__func__, driver->driver.name);
-	pr_debug("heci: driver [%s] registered\n", driver->driver.name);
 	return 0;
 }
-EXPORT_SYMBOL_GPL(__heci_cl_driver_register);
+EXPORT_SYMBOL(__ishtp_cl_driver_register);
 
-void heci_cl_driver_unregister(struct heci_cl_driver *driver)
+void ishtp_cl_driver_unregister(struct ishtp_cl_driver *driver)
 {
 	driver_unregister(&driver->driver);
-
-	pr_debug("heci: driver [%s] unregistered\n", driver->driver.name);
 }
-EXPORT_SYMBOL_GPL(heci_cl_driver_unregister);
+EXPORT_SYMBOL(ishtp_cl_driver_unregister);
 
-
-static void heci_bus_event_work(struct work_struct *work)
+static void ishtp_bus_event_work(struct work_struct *work)
 {
-	struct heci_cl_device *device;
+	struct ishtp_cl_device *device;
 
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	device = container_of(work, struct heci_cl_device, event_work);
+	device = container_of(work, struct ishtp_cl_device, event_work);
 
 	if (device->event_cb)
-		device->event_cb(device, device->events, device->event_context);
-
-	/*device->events = 0;*/
-}
-
-int heci_register_event_cb(struct heci_cl_device *device,
-	void (*event_cb)(struct heci_cl_device *, u32, void *), void *context)
-{
-	if (device->event_cb)
-		return -EALREADY;
-
-	/*device->events = 0;*/
-	device->event_cb = event_cb;
-	device->event_context = context;
-	INIT_WORK(&device->event_work, heci_bus_event_work);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(heci_register_event_cb);
-
-void *heci_cl_get_drvdata(const struct heci_cl_device *device)
-{
-	return dev_get_drvdata(&device->dev);
-}
-EXPORT_SYMBOL_GPL(heci_cl_get_drvdata);
-
-void heci_cl_set_drvdata(struct heci_cl_device *device, void *data)
-{
-	dev_set_drvdata(&device->dev, data);
-}
-EXPORT_SYMBOL_GPL(heci_cl_set_drvdata);
-
-/* What's this? */
-int heci_cl_enable_device(struct heci_cl_device *device)
-{
-	if (!device->ops || !device->ops->enable)
-		return 0;
-
-	return device->ops->enable(device);
+		device->event_cb(device);
 }
-EXPORT_SYMBOL_GPL(heci_cl_enable_device);
 
-int heci_cl_disable_device(struct heci_cl_device *device)
+void ishtp_cl_bus_rx_event(struct ishtp_cl_device *device)
 {
-	if (!device->ops || !device->ops->disable)
-		return 0;
-
-	return device->ops->disable(device);
-}
-EXPORT_SYMBOL_GPL(heci_cl_disable_device);
-/************************/
-
-void heci_cl_bus_rx_event(struct heci_cl_device *device)
-{
-	static int	rx_count;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ [%d]\n", __func__, rx_count++);
 	if (!device || !device->event_cb)
 		return;
 
-	set_bit(HECI_CL_EVENT_RX, &device->events);
-
 	if (device->event_cb)
 		schedule_work(&device->event_work);
 }
 
-int __init heci_cl_bus_init(void)
+int ishtp_register_event_cb(struct ishtp_cl_device *device,
+	void (*event_cb)(struct ishtp_cl_device *))
 {
-	int	rv;
+	if (device->event_cb)
+		return -EALREADY;
 
-	ISH_DBG_PRINT(KERN_ALERT "%s(): Registering HECI bus\n", __func__);
-	rv = bus_register(&heci_cl_bus_type);
-	return	rv;
-}
+	device->event_cb = event_cb;
+	INIT_WORK(&device->event_work, ishtp_bus_event_work);
 
-void __exit heci_cl_bus_exit(void)
-{
-ISH_DBG_PRINT(KERN_ALERT "%s(): Unregistering HECI bus\n", __func__);
-	bus_unregister(&heci_cl_bus_type);
+	return 0;
 }
-
+EXPORT_SYMBOL(ishtp_register_event_cb);
 
 ssize_t cl_prop_read(struct device *dev, struct device_attribute *dev_attr,
 	char *buf)
 {
 	ssize_t	rv = -EINVAL;
-	struct heci_cl_device	*cl_device = to_heci_cl_device(dev);
-	unsigned long	flags;
+	struct ishtp_cl_device	*cl_device = to_ishtp_cl_device(dev);
 
 	if (!strcmp(dev_attr->attr.name, "max_msg_length")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
@@ -467,39 +454,23 @@ ssize_t cl_prop_read(struct device *dev, struct device_attribute *dev_attr,
 		scnprintf(buf, PAGE_SIZE, "%u\n",
 			(unsigned)cl_device->fw_client->props.protocol_version);
 		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "max_number_of_connections")) {
+	} else if (!strcmp(dev_attr->attr.name, "max_number_of_connections")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
-(unsigned)cl_device->fw_client->props.max_number_of_connections);
+			(unsigned)cl_device->fw_client->props.max_number_of_connections);
 		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "fixed_address")) {
+	} else if (!strcmp(dev_attr->attr.name, "fixed_address")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
 			(unsigned)cl_device->fw_client->props.fixed_address);
 		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "single_recv_buf")) {
+	} else if (!strcmp(dev_attr->attr.name, "single_recv_buf")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
 			(unsigned)cl_device->fw_client->props.single_recv_buf);
 		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "dma_hdr_len")) {
+	} else if (!strcmp(dev_attr->attr.name, "dma_hdr_len")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
 			(unsigned)cl_device->fw_client->props.dma_hdr_len);
 		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "num_active_connections")) {
-		struct heci_cl	*cl, *next;
-		unsigned	count = 0;
-
-		spin_lock_irqsave(&cl_device->heci_dev->cl_list_lock, flags);
-		list_for_each_entry_safe(cl, next,
-				&cl_device->heci_dev->cl_list, link) {
-			if (cl->state == HECI_CL_CONNECTED &&
-					cl->device == cl_device)
-				++count;
-		}
-		spin_unlock_irqrestore(&cl_device->heci_dev->cl_list_lock,
-			flags);
-
-		scnprintf(buf, PAGE_SIZE, "%u\n", count);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "client_id")) {
+	} else if (!strcmp(dev_attr->attr.name, "client_id")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
 			(unsigned)cl_device->fw_client->client_id);
 		rv = strlen(buf);
@@ -568,15 +539,6 @@ static struct device_attribute	dma_hdr_len = {
 	.store = cl_prop_write
 };
 
-static struct device_attribute	num_active_connections = {
-	.attr = {
-		.name = "num_active_connections",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
 static struct device_attribute	client_id = {
 	.attr = {
 		.name = "client_id",
@@ -587,26 +549,25 @@ static struct device_attribute	client_id = {
 };
 
 /*
- * Enum-completion callback for HECI bus - heci_device has reported its clients
+ * Enum-completion callback for ISHTP bus -
+ * ishtp_device has reported its clients
  */
-int	heci_bus_new_client(struct heci_device *dev)
+int	ishtp_bus_new_client(struct ishtp_device *dev)
 {
 	int	i;
 	char	*dev_name;
-	struct heci_cl_device	*cl_device;
+	struct ishtp_cl_device	*cl_device;
 	uuid_le	device_uuid;
 
 	/*
 	 * For all reported clients, create an unconnected client and add its
-	 * device to HECI bus.
+	 * device to ISHTP bus.
 	 * If appropriate driver has loaded, this will trigger its probe().
 	 * Otherwise, probe() will be called when driver is loaded
 	 */
-	/* no need for spinlock here - the caller locked me_clients_lock */
-
-	i = dev->me_client_presentation_num - 1;
-	device_uuid = dev->me_clients[i].props.protocol_name;
-	dev_name = kasprintf(GFP_ATOMIC,
+	i = dev->fw_client_presentation_num - 1;
+	device_uuid = dev->fw_clients[i].props.protocol_name;
+	dev_name = kasprintf(GFP_KERNEL,
 		"{%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
 		device_uuid.b[3], device_uuid.b[2], device_uuid.b[1],
 		device_uuid.b[0], device_uuid.b[5], device_uuid.b[4],
@@ -617,7 +578,7 @@ int	heci_bus_new_client(struct heci_device *dev)
 	if (!dev_name)
 		return	-ENOMEM;
 
-	cl_device = heci_bus_add_device(dev, device_uuid, dev_name, NULL);
+	cl_device = ishtp_bus_add_device(dev, device_uuid, dev_name);
 	if (!cl_device) {
 		kfree(dev_name);
 		return	-ENOENT;
@@ -630,54 +591,52 @@ int	heci_bus_new_client(struct heci_device *dev)
 	device_create_file(&cl_device->dev, &fixed_address);
 	device_create_file(&cl_device->dev, &single_recv_buf);
 	device_create_file(&cl_device->dev, &dma_hdr_len);
-	device_create_file(&cl_device->dev, &num_active_connections);
 	device_create_file(&cl_device->dev, &client_id);
 	kfree(dev_name);
 
 	return	0;
 }
 
-
 static int	does_driver_bind_uuid(struct device *dev, void *id)
 {
 	uuid_le	*uuid = id;
-	struct heci_cl_device	*device;
+	struct ishtp_cl_device	*device;
 
 	if (!dev->driver)
 		return	0;
 
-	device = to_heci_cl_device(dev);
+	device = to_ishtp_cl_device(dev);
 	if (!uuid_le_cmp(device->fw_client->props.protocol_name, *uuid))
 		return	1;
 
 	return	0;
 }
 
-
-int	heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid)
+/* Checks if there is a driver attached to this uuid */
+int	ishtp_can_client_connect(struct ishtp_device *ishtp_dev, uuid_le *uuid)
 {
 	int	rv;
 
-	rv = bus_for_each_dev(&heci_cl_bus_type, NULL, uuid,
+	rv = bus_for_each_dev(&ishtp_cl_bus_type, NULL, uuid,
 		does_driver_bind_uuid);
 	return	!rv;
 }
 
-
-/* Binds connected heci_cl to HECI bus device */
-int	heci_cl_device_bind(struct heci_cl *cl)
+/* Binds connected ishtp_cl to ISHTP bus device */
+int	ishtp_cl_device_bind(struct ishtp_cl *cl)
 {
-	int	rv;
-	struct heci_cl_device	*cl_device, *next;
+	struct ishtp_cl_device	*cl_device, *next;
 	unsigned long flags;
-	if (!cl->me_client_id || cl->state != HECI_CL_CONNECTED)
+	int	rv;
+
+	if (!cl->fw_client_id || cl->state != ISHTP_CL_CONNECTED)
 		return	-EFAULT;
 
 	rv = -ENOENT;
 	spin_lock_irqsave(&cl->dev->device_list_lock, flags);
 	list_for_each_entry_safe(cl_device, next, &cl->dev->device_list,
 			device_link) {
-		if (cl_device->fw_client->client_id == cl->me_client_id) {
+		if (cl_device->fw_client->client_id == cl->fw_client_id) {
 			cl->device = cl_device;
 			rv = 0;
 			break;
@@ -687,3 +646,15 @@ int	heci_cl_device_bind(struct heci_cl *cl)
 	return	rv;
 }
 
+int __init ishtp_cl_bus_init(void)
+{
+	int	rv;
+
+	rv = bus_register(&ishtp_cl_bus_type);
+	return	rv;
+}
+
+void __exit ishtp_cl_bus_exit(void)
+{
+	bus_unregister(&ishtp_cl_bus_type);
+}
diff --git a/drivers/misc/intel-ish/bus.h b/drivers/misc/intel-ish/bus.h
index 2a39ec7..0ff7d23 100644
--- a/drivers/misc/intel-ish/bus.h
+++ b/drivers/misc/intel-ish/bus.h
@@ -1,7 +1,7 @@
 /*
- * HECI bus definitions
+ * ISHTP bus definitions
  *
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,117 +9,69 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
-#ifndef _LINUX_HECI_CL_BUS_H
-#define _LINUX_HECI_CL_BUS_H
+#ifndef _LINUX_ISHTP_CL_BUS_H
+#define _LINUX_ISHTP_CL_BUS_H
 
 #include <linux/device.h>
-#include <linux/uuid.h>
+#include <linux/mod_devicetable.h>
 
-/*typedef void (*heci_cl_event_cb_t)(struct heci_cl_device *device, u32 events,
-	void *context);*/
-
-struct heci_cl;
-struct heci_cl_device;
-struct heci_device;
-
-#define	HECI_CL_NAME_SIZE	32
-
-struct heci_cl_device_id {
-	char name[MEI_CL_NAME_SIZE];
-	kernel_ulong_t driver_info;
-};
+struct ishtp_cl;
+struct ishtp_cl_device;
+struct ishtp_device;
+struct ishtp_msg_hdr;
 
 /**
- * struct heci_cl_dev_ops - HECI CL device ops
- * This structure allows ME host clients to implement technology
- * specific operations.
- *
- * @enable: Enable an HECI CL device. Some devices require specific
- *	HECI commands to initialize completely.
- * @disable: Disable an HECI CL device.
- * @send: Tx hook for the device. This allows ME host clients to trap
- *	the device driver buffers before actually physically
- *	pushing it to the ME.
- * @recv: Rx hook for the device. This allows ME host clients to trap the
- *	ME buffers before forwarding them to the device driver.
+ * struct ishtp_cl_device - ISHTP device handle
+ * An ishtp_cl_device pointer is returned from ishtp_add_device()
+ * and links ISHTP bus clients to their actual host client pointer.
+ * Drivers for ISHTP devices will get an ishtp_cl_device pointer
+ * when being probed and shall use it for doing bus I/O.
  */
-struct heci_cl_dev_ops {
-	int (*enable)(struct heci_cl_device *device);
-	int (*disable)(struct heci_cl_device *device);
-	int (*send)(struct heci_cl_device *device, u8 *buf, size_t length);
-	int (*recv)(struct heci_cl_device *device, u8 *buf, size_t length);
-};
-
-struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
-	uuid_le uuid, char *name, struct heci_cl_dev_ops *ops);
-void heci_bus_remove_device(struct heci_cl_device *device);
-
-/**
- * struct heci_cl_device - HECI device handle
- * An heci_cl_device pointer is returned from heci_add_device()
- * and links HECI bus clients to their actual ME host client pointer.
- * Drivers for HECI devices will get an heci_cl_device pointer
- * when being probed and shall use it for doing ME bus I/O.
- *
- * @dev: linux driver model device pointer
- * @uuid: me client uuid
- * @cl: heci client
- * @ops: ME transport ops
- * @event_cb: Drivers register this callback to get asynchronous ME
- *	events (e.g. Rx buffer pending) notifications.
- * @events: Events bitmask sent to the driver.
- * @priv_data: client private data
- */
-struct heci_cl_device {
+struct ishtp_cl_device {
 	struct device dev;
-	/*struct heci_cl *cl;*/
-	struct heci_device	*heci_dev;
-	struct heci_me_client	*fw_client;	/* For easy reference */
+	struct ishtp_device	*ishtp_dev;
+	struct ishtp_fw_client	*fw_client;
 	struct list_head	device_link;
-	const struct heci_cl_dev_ops *ops;
 	struct work_struct event_work;
-	void (*event_cb)(struct heci_cl_device *device, u32 events,
-		void *context);
-	void *event_context;
-	unsigned long events;
-	void *priv_data;
+	void (*event_cb)(struct ishtp_cl_device *device);
 };
 
-struct heci_cl_driver {
+struct ishtp_cl_driver {
 	struct device_driver driver;
 	const char *name;
-	const struct heci_cl_device_id *id_table;
-	int (*probe)(struct heci_cl_device *dev,
-		const struct heci_cl_device_id *id);
-	int (*remove)(struct heci_cl_device *dev);
+	int (*probe)(struct ishtp_cl_device *dev);
+	int (*remove)(struct ishtp_cl_device *dev);
 };
 
-int __heci_cl_driver_register(struct heci_cl_driver *driver,
+int	__ishtp_cl_driver_register(struct ishtp_cl_driver *driver,
 	struct module *owner);
-#define heci_cl_driver_register(driver)             \
-	__heci_cl_driver_register(driver, THIS_MODULE)
-
-void heci_cl_driver_unregister(struct heci_cl_driver *driver);
-int heci_register_event_cb(struct heci_cl_device *device,
-	void (*read_cb)(struct heci_cl_device *, u32, void *), void *context);
-
-#define HECI_CL_EVENT_RX 0
-#define HECI_CL_EVENT_TX 1
-
-void *heci_cl_get_drvdata(const struct heci_cl_device *device);
-void heci_cl_set_drvdata(struct heci_cl_device *device, void *data);
-
-int heci_cl_enable_device(struct heci_cl_device *device);
-int heci_cl_disable_device(struct heci_cl_device *device);
-
-void heci_cl_bus_rx_event(struct heci_cl_device *device);
-int heci_cl_bus_init(void);
-void heci_cl_bus_exit(void);
-int	heci_bus_new_client(struct heci_device *dev);
-void	heci_remove_all_clients(struct heci_device *dev);
-int	heci_cl_device_bind(struct heci_cl *cl);
-
-#endif /* _LINUX_HECI_CL_BUS_H */
+#define ishtp_cl_driver_register(driver)		\
+	__ishtp_cl_driver_register(driver, THIS_MODULE)
+void	ishtp_cl_driver_unregister(struct ishtp_cl_driver *driver);
+
+int	ishtp_register_event_cb(struct ishtp_cl_device *device,
+	void (*read_cb)(struct ishtp_cl_device *));
+
+int	ishtp_cl_bus_init(void);
+void	ishtp_cl_bus_exit(void);
+int	ishtp_bus_new_client(struct ishtp_device *dev);
+void	ishtp_remove_all_clients(struct ishtp_device *dev);
+int	ishtp_cl_device_bind(struct ishtp_cl *cl);
+void	ishtp_cl_bus_rx_event(struct ishtp_cl_device *device);
+int	ishtp_reset_handler(struct ishtp_device *dev);
+int	ishtp_reset_compl_handler(struct ishtp_device *dev);
+void	recv_ishtp(struct ishtp_device *dev);
+
+/* Write a multi-fragment message */
+int	send_ishtp_msg(struct ishtp_device *dev,
+	struct ishtp_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
+	void *ipc_send_compl_prm);
+
+/* Write a single-fragment message */
+int	ishtp_write_message(struct ishtp_device *dev,
+	struct ishtp_msg_hdr *hdr, unsigned char *buf);
+
+#endif /* _LINUX_ISHTP_CL_BUS_H */
diff --git a/drivers/misc/intel-ish/client.c b/drivers/misc/intel-ish/client.c
index 57eafc1..82133ae9 100644
--- a/drivers/misc/intel-ish/client.c
+++ b/drivers/misc/intel-ish/client.c
@@ -1,7 +1,7 @@
 /*
- * HECI client logic (for both HECI bus driver and user-mode API)
+ * ISHTP client logic (for both ISHTP bus driver and user-mode API)
  *
- * Copyright (c) 2003-2015, Intel Corporation.
+ * Copyright (c) 2003-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,47 +9,41 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
  */
 
 #include <linux/export.h>
-#include <linux/pci.h>
+#include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include "heci_dev.h"
 #include "hbm.h"
 #include "client.h"
-#include "utils.h"
 
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-/* #define dev_dbg dev_err */
-
-int	host_dma_enabled;       /* New bi-directional DMA */
-int	dma_ready = 1;          /* Legacy host->FW only DMA */
+/* dma global vars */
+int	host_dma_enabled;
 
 void	*host_dma_tx_buf;
 unsigned	host_dma_tx_buf_size = (1024*1024);
 uint64_t	host_dma_tx_buf_phys;
 
+int	dma_num_slots;
+/* map of 4k blocks in Tx dma buf: 0-free, 1-caught */
+uint8_t	*dma_tx_map;
+spinlock_t	dma_tx_lock;
+
 void	*host_dma_rx_buf;
 unsigned	host_dma_rx_buf_size = (1024*1024);
 uint64_t	host_dma_rx_buf_phys;
 
-void	heci_cl_alloc_dma_buf(void)
+void	ishtp_cl_alloc_dma_buf(void)
 {
 	int	order;
 	unsigned	temp;
 
+	/* Allocate Tx buffer and init usage bitmap */
 	for (order = 0, temp = host_dma_tx_buf_size / PAGE_SIZE + 1; temp;
 			temp >>= 1)
 		++order;
@@ -57,6 +51,10 @@ void	heci_cl_alloc_dma_buf(void)
 	if (host_dma_tx_buf)
 		host_dma_tx_buf_phys = __pa(host_dma_tx_buf);
 
+	dma_num_slots = host_dma_tx_buf_size / DMA_SLOT_SIZE;
+	dma_tx_map = kzalloc(dma_num_slots * sizeof(uint8_t), GFP_KERNEL);
+	spin_lock_init(&dma_tx_lock);
+
 	for (order = 0, temp = host_dma_rx_buf_size / PAGE_SIZE + 1; temp;
 			temp >>= 1)
 		++order;
@@ -65,79 +63,53 @@ void	heci_cl_alloc_dma_buf(void)
 		host_dma_rx_buf_phys = __pa(host_dma_rx_buf);
 }
 
-
-/**
- * heci_read_list_flush - removes list entry belonging to cl.
- *
- * @list:  An instance of our list structure
- * @cl: host client
- */
-void heci_read_list_flush(struct heci_cl *cl)
+/* ishtp_read_list_flush - removes list entry belonging to cl */
+void ishtp_read_list_flush(struct ishtp_cl *cl)
 {
-	struct heci_cl_rb *rb;
-	struct heci_cl_rb *next;
-
+	struct ishtp_cl_rb *rb;
+	struct ishtp_cl_rb *next;
 	unsigned long	flags;
+
 	spin_lock_irqsave(&cl->dev->read_list_spinlock, flags);
 	list_for_each_entry_safe(rb, next, &cl->dev->read_list.list, list) {
-		if (rb->cl && heci_cl_cmp_id(cl, rb->cl)) {
+		if (rb->cl && ishtp_cl_cmp_id(cl, rb->cl)) {
 			list_del(&rb->list);
-			heci_io_rb_free(rb);
+			ishtp_io_rb_free(rb);
 		}
 	}
 	spin_unlock_irqrestore(&cl->dev->read_list_spinlock, flags);
 }
 
-/**
- * heci_io_rb_free - free heci_rb_private related memory
- *
- * @rb: heci callback struct
- */
-void heci_io_rb_free(struct heci_cl_rb *rb)
+/* ishtp_io_rb_free - free ishtp_rb_private related memory */
+void ishtp_io_rb_free(struct ishtp_cl_rb *rb)
 {
 	if (rb == NULL)
 		return;
-
 	kfree(rb->buffer.data);
 	kfree(rb);
 }
-EXPORT_SYMBOL(heci_io_rb_free);
 
 /**
- * heci_io_rb_init - allocate and initialize io callback
+ * ishtp_io_rb_init - allocate and initialize request block
  *
- * @cl - heci client
- * @file: pointer to file structure
- *
- * returns heci_cl_rb pointer or NULL;
+ * returns ishtp_cl_rb pointer or NULL;
  */
-struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl)
+struct ishtp_cl_rb *ishtp_io_rb_init(struct ishtp_cl *cl)
 {
-	struct heci_cl_rb *rb;
+	struct ishtp_cl_rb *rb;
 
-	rb = kzalloc(sizeof(struct heci_cl_rb), GFP_KERNEL);
+	rb = kzalloc(sizeof(struct ishtp_cl_rb), GFP_KERNEL);
 	if (!rb)
 		return NULL;
 
-	heci_io_list_init(rb);
-
+	INIT_LIST_HEAD(&rb->list);
 	rb->cl = cl;
 	rb->buf_idx = 0;
 	return rb;
 }
 
-
-/**
- * heci_io_rb_alloc_buf - allocate respose buffer
- *
- * @rb -  io callback structure
- * @size: size of the buffer
- *
- * returns 0 on success
- *         -EINVAL if rb is NULL
- *         -ENOMEM if allocation failed
- */
-int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length)
+/* ishtp_io_rb_alloc_buf - allocate respose buffer */
+int ishtp_io_rb_alloc_buf(struct ishtp_cl_rb *rb, size_t length)
 {
 	if (!rb)
 		return -EINVAL;
@@ -152,14 +124,13 @@ int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length)
 	return 0;
 }
 
-
 /*
- * heci_io_rb_recycle - re-append rb to its client's free list
+ * ishtp_io_rb_recycle - re-append rb to its client's free list
  * and send flow control if needed
  */
-int heci_io_rb_recycle(struct heci_cl_rb *rb)
+int ishtp_io_rb_recycle(struct ishtp_cl_rb *rb)
 {
-	struct heci_cl *cl;
+	struct ishtp_cl *cl;
 	int	rets = 0;
 	unsigned long	flags;
 
@@ -167,7 +138,6 @@ int heci_io_rb_recycle(struct heci_cl_rb *rb)
 		return	-EFAULT;
 
 	cl = rb->cl;
-
 	spin_lock_irqsave(&cl->free_list_spinlock, flags);
 	list_add_tail(&rb->list, &cl->free_rb_list.list);
 	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
@@ -177,41 +147,27 @@ int heci_io_rb_recycle(struct heci_cl_rb *rb)
 	 * send flow control
 	 */
 	if (!cl->out_flow_ctrl_creds)
-		rets = heci_cl_read_start(cl);
+		rets = ishtp_cl_read_start(cl);
 
 	return	rets;
 }
-EXPORT_SYMBOL(heci_io_rb_recycle);
+EXPORT_SYMBOL(ishtp_io_rb_recycle);
 
-
-/**
- * heci_cl_flush_queues - flushes queue lists belonging to cl.
- *
- * @dev: the device structure
- * @cl: host client
- */
-int heci_cl_flush_queues(struct heci_cl *cl)
+/* ishtp_cl_flush_queues - flushes queue lists belonging to cl */
+int ishtp_cl_flush_queues(struct ishtp_cl *cl)
 {
 	if (WARN_ON(!cl || !cl->dev))
 		return -EINVAL;
-
-	dev_dbg(&cl->dev->pdev->dev, "remove list entry belonging to cl\n");
-	heci_read_list_flush(cl);
+	ishtp_read_list_flush(cl);
 
 	return 0;
 }
-EXPORT_SYMBOL(heci_cl_flush_queues);
-
+EXPORT_SYMBOL(ishtp_cl_flush_queues);
 
-/**
- * heci_cl_init - initializes intialize cl.
- *
- * @cl: host client to be initialized
- * @dev: heci device
- */
-void heci_cl_init(struct heci_cl *cl, struct heci_device *dev)
+/* ishtp_cl_init - initializes cl */
+void ishtp_cl_init(struct ishtp_cl *cl, struct ishtp_device *dev)
 {
-	memset(cl, 0, sizeof(struct heci_cl));
+	memset(cl, 0, sizeof(struct ishtp_cl));
 	init_waitqueue_head(&cl->wait);
 	init_waitqueue_head(&cl->rx_wait);
 	init_waitqueue_head(&cl->wait_ctrl_res);
@@ -230,28 +186,35 @@ void heci_cl_init(struct heci_cl *cl, struct heci_device *dev)
 
 	cl->rx_ring_size = CL_DEF_RX_RING_SIZE;
 	cl->tx_ring_size = CL_DEF_TX_RING_SIZE;
+
+	/* dma */
+	/* CHANGEME: will change to "default" once validated */
+	cl->last_tx_path = CL_TX_PATH_IPC;
+	cl->last_dma_acked = 1;
+	cl->last_dma_addr = NULL;
+	cl->last_ipc_acked = 1;
 }
 
-int	heci_cl_free_rx_ring(struct heci_cl *cl)
+int	ishtp_cl_free_rx_ring(struct ishtp_cl *cl)
 {
-	struct heci_cl_rb *rb;
+	struct ishtp_cl_rb *rb;
 	unsigned long	flags;
 
-	/* relese allocated mem- pass over free_rb_list */
+	/* release allocated memory - pass over free_rb_list */
 	spin_lock_irqsave(&cl->free_list_spinlock, flags);
 	while (!list_empty(&cl->free_rb_list.list)) {
-		rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb,
+		rb = list_entry(cl->free_rb_list.list.next, struct ishtp_cl_rb,
 			list);
 		list_del(&rb->list);
 		kfree(rb->buffer.data);
 		kfree(rb);
 	}
 	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-	/* relese allocated mem- pass over in_process_list */
+	/* release allocated memory - pass over in_process_list */
 	spin_lock_irqsave(&cl->in_process_spinlock, flags);
 	while (!list_empty(&cl->in_process_list.list)) {
 		rb = list_entry(cl->in_process_list.list.next,
-			struct heci_cl_rb, list);
+			struct ishtp_cl_rb, list);
 		list_del(&rb->list);
 		kfree(rb->buffer.data);
 		kfree(rb);
@@ -260,16 +223,16 @@ int	heci_cl_free_rx_ring(struct heci_cl *cl)
 	return	0;
 }
 
-int	heci_cl_free_tx_ring(struct heci_cl *cl)
+int	ishtp_cl_free_tx_ring(struct ishtp_cl *cl)
 {
-	struct heci_cl_tx_ring  *tx_buf;
+	struct ishtp_cl_tx_ring	*tx_buf;
 	unsigned long	flags;
 
 	spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
-	/* relese allocated mem- pass over tx_free_list */
+	/* release allocated memory - pass over tx_free_list */
 	while (!list_empty(&cl->tx_free_list.list)) {
 		tx_buf = list_entry(cl->tx_free_list.list.next,
-			struct heci_cl_tx_ring, list);
+			struct ishtp_cl_tx_ring, list);
 		list_del(&tx_buf->list);
 		kfree(tx_buf->send_buf.data);
 		kfree(tx_buf);
@@ -277,10 +240,10 @@ int	heci_cl_free_tx_ring(struct heci_cl *cl)
 	spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
 
 	spin_lock_irqsave(&cl->tx_list_spinlock, flags);
-	/* relese allocated mem- pass over tx_list */
+	/* release allocated memory - pass over tx_list */
 	while (!list_empty(&cl->tx_list.list)) {
 		tx_buf = list_entry(cl->tx_list.list.next,
-			struct heci_cl_tx_ring, list);
+			struct ishtp_cl_tx_ring, list);
 		list_del(&tx_buf->list);
 		kfree(tx_buf->send_buf.data);
 		kfree(tx_buf);
@@ -290,22 +253,21 @@ int	heci_cl_free_tx_ring(struct heci_cl *cl)
 	return	0;
 }
 
-int	heci_cl_alloc_rx_ring(struct heci_cl *cl)
+int	ishtp_cl_alloc_rx_ring(struct ishtp_cl *cl)
 {
 	size_t	len = cl->device->fw_client->props.max_msg_length;
 	int	j;
-	struct heci_cl_rb *rb;
+	struct ishtp_cl_rb *rb;
 	int	ret = 0;
-	struct heci_device *dev = cl->dev;
 	unsigned long	flags;
 
 	for (j = 0; j < cl->rx_ring_size; ++j) {
-		rb = heci_io_rb_init(cl);
+		rb = ishtp_io_rb_init(cl);
 		if (!rb) {
 			ret = -ENOMEM;
 			goto out;
 		}
-		ret = heci_io_rb_alloc_buf(rb, len);
+		ret = ishtp_io_rb_alloc_buf(rb, len);
 		if (ret)
 			goto out;
 		spin_lock_irqsave(&cl->free_list_spinlock, flags);
@@ -313,112 +275,96 @@ int	heci_cl_alloc_rx_ring(struct heci_cl *cl)
 		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
 	}
 
-	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
-		__func__);
 	return	0;
 
 out:
-	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n",
-		__func__);
-	heci_cl_free_rx_ring(cl);
+	dev_err(&cl->device->dev, "error in allocating Rx buffers\n");
+	ishtp_cl_free_rx_ring(cl);
 	return	ret;
 }
 
-
-int	heci_cl_alloc_tx_ring(struct heci_cl *cl)
+int	ishtp_cl_alloc_tx_ring(struct ishtp_cl *cl)
 {
 	size_t	len = cl->device->fw_client->props.max_msg_length;
 	int	j;
-	struct heci_device *dev = cl->dev;
 	unsigned long	flags;
 
-	/*cl->send_fc_flag = 0;*/
-	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
-		__func__);
-
 	/* Allocate pool to free Tx bufs */
 	for (j = 0; j < cl->tx_ring_size; ++j) {
-		struct heci_cl_tx_ring	*tx_buf;
+		struct ishtp_cl_tx_ring	*tx_buf;
 
-		tx_buf = kmalloc(sizeof(struct heci_cl_tx_ring), GFP_KERNEL);
-		if (!tx_buf) {
-			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n",
-				__func__);
+		tx_buf = kmalloc(sizeof(struct ishtp_cl_tx_ring), GFP_KERNEL);
+		if (!tx_buf)
 			goto	out;
-		}
-		memset(tx_buf, 0, sizeof(struct heci_cl_tx_ring));
+
+		memset(tx_buf, 0, sizeof(struct ishtp_cl_tx_ring));
 		tx_buf->send_buf.data = kmalloc(len, GFP_KERNEL);
 		if (!tx_buf->send_buf.data) {
-			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n",
-				__func__);
 			kfree(tx_buf);
 			goto	out;
 		}
+
 		spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
 		list_add_tail(&tx_buf->list, &cl->tx_free_list.list);
 		spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
 	}
-	ISH_DBG_PRINT(KERN_ALERT "%s() allocated Tx  pool successfully\n",
-		__func__);
-
 	return	0;
-
 out:
-	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n",
-		__func__);
-	heci_cl_free_rx_ring(cl);
+	dev_err(&cl->device->dev, "error in allocating Tx pool\n");
+	ishtp_cl_free_rx_ring(cl);
 	return	-ENOMEM;
 }
 
-
 /**
- * heci_cl_allocate - allocates cl  structure and sets it up.
- *
- * @dev: heci device
- * returns  The allocated file or NULL on failure
+ * ishtp_cl_allocate - allocates cl structure and sets it up.
+ * returns The allocated file or NULL on failure
  */
-struct heci_cl *heci_cl_allocate(struct heci_device *dev)
+struct ishtp_cl *ishtp_cl_allocate(struct ishtp_device *dev)
 {
-	struct heci_cl *cl;
+	struct ishtp_cl *cl;
 
-	cl = kmalloc(sizeof(struct heci_cl), GFP_ATOMIC);
+	cl = kmalloc(sizeof(struct ishtp_cl), GFP_ATOMIC);
 	if (!cl)
 		return NULL;
 
-	heci_cl_init(cl, dev);
+	ishtp_cl_init(cl, dev);
 	return cl;
 }
-EXPORT_SYMBOL(heci_cl_allocate);
-
+EXPORT_SYMBOL(ishtp_cl_allocate);
 
-void	heci_cl_free(struct heci_cl *cl)
+void	ishtp_cl_free(struct ishtp_cl *cl)
 {
+	struct ishtp_device *dev;
+	unsigned long flags;
+
 	if (!cl)
 		return;
+	dev = cl->dev;
+	if (!dev)
+		return;
 
-	heci_cl_free_rx_ring(cl);
-	heci_cl_free_tx_ring(cl);
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	ishtp_cl_free_rx_ring(cl);
+	ishtp_cl_free_tx_ring(cl);
 	kfree(cl);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
-EXPORT_SYMBOL(heci_cl_free);
-
+EXPORT_SYMBOL(ishtp_cl_free);
 
 /**
- * heci_cl_find_read_rb - find this cl's callback in the read list
- *
- * @dev: device structure
+ * ishtp_cl_find_read_rb - find this cl's callback in the read list
  * returns rb on success, NULL on error
  */
-struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl)
+struct ishtp_cl_rb *ishtp_cl_find_read_rb(struct ishtp_cl *cl)
 {
-	struct heci_device *dev = cl->dev;
-	struct heci_cl_rb *rb = NULL;
-	struct heci_cl_rb *next = NULL;
-	unsigned long     dev_flags;
+	struct ishtp_device *dev = cl->dev;
+	struct ishtp_cl_rb *rb = NULL;
+	struct ishtp_cl_rb *next = NULL;
+	unsigned long	dev_flags;
 
 	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
 	list_for_each_entry_safe(rb, next, &dev->read_list.list, list)
-		if (heci_cl_cmp_id(cl, rb->cl)) {
+		if (ishtp_cl_cmp_id(cl, rb->cl)) {
 			spin_unlock_irqrestore(&dev->read_list_spinlock,
 				dev_flags);
 			return rb;
@@ -426,19 +372,14 @@ struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl)
 	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
 	return NULL;
 }
-EXPORT_SYMBOL(heci_cl_find_read_rb);
 
-/** heci_cl_link: allocte host id in the host map
- *
- * @cl - host client
- * @id - fixed host id or -1 for genereting one
- * returns 0 on success
- *	-EINVAL on incorrect values
- *	-ENONET if client not found
+/**
+ * ishtp_cl_link: allocate host id in the host map
+ * @id - fixed host id or (-1) for generating one
  */
-int heci_cl_link(struct heci_cl *cl, int id)
+int ishtp_cl_link(struct ishtp_cl *cl, int id)
 {
-	struct heci_device *dev;
+	struct ishtp_device *dev;
 	unsigned long	flags, flags_cl;
 
 	if (WARN_ON(!cl || !cl->dev))
@@ -448,26 +389,26 @@ int heci_cl_link(struct heci_cl *cl, int id)
 
 	spin_lock_irqsave(&dev->device_lock, flags);
 
-	if (dev->open_handle_count >= HECI_MAX_OPEN_HANDLE_COUNT) {
+	if (dev->open_handle_count >= ISHTP_MAX_OPEN_HANDLE_COUNT) {
 		spin_unlock_irqrestore(&dev->device_lock, flags);
 		return	-EMFILE;
 	}
 
-	/* If Id is not asigned get one*/
-	if (id == HECI_HOST_CLIENT_ID_ANY)
+	/* If Id is not assigned get one*/
+	if (id == ISHTP_HOST_CLIENT_ID_ANY)
 		id = find_first_zero_bit(dev->host_clients_map,
-			HECI_CLIENTS_MAX);
+			ISHTP_CLIENTS_MAX);
 
-	if (id >= HECI_CLIENTS_MAX) {
+	if (id >= ISHTP_CLIENTS_MAX) {
 		spin_unlock_irqrestore(&dev->device_lock, flags);
-		dev_err(&dev->pdev->dev, "id exceded %d", HECI_CLIENTS_MAX);
+		dev_err(&cl->device->dev, "id exceded %d", ISHTP_CLIENTS_MAX);
 		return -ENOENT;
 	}
 
 	dev->open_handle_count++;
 	cl->host_client_id = id;
 	spin_lock_irqsave(&dev->cl_list_lock, flags_cl);
-	if (dev->dev_state != HECI_DEV_ENABLED) {
+	if (dev->dev_state != ISHTP_DEV_ENABLED) {
 		spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
 		spin_unlock_irqrestore(&dev->device_lock, flags);
 		return -ENODEV;
@@ -475,24 +416,18 @@ int heci_cl_link(struct heci_cl *cl, int id)
 	list_add_tail(&cl->link, &dev->cl_list);
 	spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
 	set_bit(id, dev->host_clients_map);
-	cl->state = HECI_CL_INITIALIZING;
+	cl->state = ISHTP_CL_INITIALIZING;
 	spin_unlock_irqrestore(&dev->device_lock, flags);
 
-	dev_dbg(&dev->pdev->dev, "link cl host id = %d\n", cl->host_client_id);
-
 	return 0;
 }
-EXPORT_SYMBOL(heci_cl_link);
+EXPORT_SYMBOL(ishtp_cl_link);
 
-/**
- * heci_cl_unlink - remove me_cl from the list
- *
- * @dev: the device structure
- */
-int heci_cl_unlink(struct heci_cl *cl)
+/* ishtp_cl_unlink - remove fw_cl from the list */
+int ishtp_cl_unlink(struct ishtp_cl *cl)
 {
-	struct heci_device *dev;
-	struct heci_cl *pos, *next;
+	struct ishtp_device *dev;
+	struct ishtp_cl *pos, *next;
 	unsigned long	flags;
 
 	/* don't shout on error exit path */
@@ -523,219 +458,142 @@ int heci_cl_unlink(struct heci_cl *cl)
 
 	return 0;
 }
-EXPORT_SYMBOL(heci_cl_unlink);
-
+EXPORT_SYMBOL(ishtp_cl_unlink);
 
-/**
- * heci_cl_disconnect - disconnect host clinet form the me one
- *
- * @cl: host client
- *
- * Locking: called under "dev->device_lock" lock
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_cl_disconnect(struct heci_cl *cl)
+/* ishtp_cl_disconnect - disconnect host client form the fw one */
+int ishtp_cl_disconnect(struct ishtp_cl *cl)
 {
-	struct heci_device *dev;
-	int rets, err;
+	struct ishtp_device *dev;
+	int err;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
 	dev = cl->dev;
 
-	if (cl->state != HECI_CL_DISCONNECTING)
+	if (cl->state != ISHTP_CL_DISCONNECTING)
 		return 0;
 
-	rets = pm_runtime_get_sync(&dev->pdev->dev);
-	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
-	if (IS_ERR_VALUE(rets)) {
-		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
-		return rets;
-	}
-
-	if (heci_hbm_cl_disconnect_req(dev, cl)) {
-		rets = -ENODEV;
-		dev_err(&dev->pdev->dev, "failed to disconnect.\n");
-		goto free;
+	if (ishtp_hbm_cl_disconnect_req(dev, cl)) {
+		dev_err(&cl->device->dev, "failed to disconnect.\n");
+		return -ENODEV;
 	}
 
 	err = wait_event_timeout(cl->wait_ctrl_res,
-			(dev->dev_state != HECI_DEV_ENABLED ||
-			HECI_CL_DISCONNECTED == cl->state),
-			heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT));
+			(dev->dev_state != ISHTP_DEV_ENABLED ||
+			ISHTP_CL_DISCONNECTED == cl->state),
+			ishtp_secs_to_jiffies(ISHTP_CL_CONNECT_TIMEOUT));
 
 	/*
 	 * If FW reset arrived, this will happen. Don't check cl->,
 	 * as 'cl' may be freed already
 	 */
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto	free;
-	}
-
-	if (HECI_CL_DISCONNECTED == cl->state) {
-		rets = 0;
-		dev_dbg(&dev->pdev->dev, "successfully disconnected from FW client.\n");
-	} else {
-		rets = -ENODEV;
-		if (HECI_CL_DISCONNECTED != cl->state)
-			dev_dbg(&dev->pdev->dev, "wrong status client disconnect.\n");
-
-		if (err)
-			dev_dbg(&dev->pdev->dev,
-				"wait failed disconnect err=%08x\n", err);
-
-		dev_dbg(&dev->pdev->dev, "failed to disconnect from FW client.\n");
-	}
-
-free:
-	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
+	if (dev->dev_state != ISHTP_DEV_ENABLED)
+		return -ENODEV;
 
-	return rets;
+	if (ISHTP_CL_DISCONNECTED == cl->state)
+		return 0;
+	return -ENODEV;
 }
-EXPORT_SYMBOL(heci_cl_disconnect);
-
 
 /**
- * heci_cl_is_other_connecting - checks if other
- *    client with the same me client id is connecting
- *
- * @cl: private data of the file object
- *
- * returns ture if other client is connected, 0 - otherwise.
+ * ishtp_cl_is_other_connecting - checks if other
+ * client with the same fw client id is connecting
+ * returns true if other client is connected, 0 - otherwise.
  */
-bool heci_cl_is_other_connecting(struct heci_cl *cl)
+bool ishtp_cl_is_other_connecting(struct ishtp_cl *cl)
 {
-	struct heci_device *dev;
-	struct heci_cl *pos;
-	struct heci_cl *next;
+	struct ishtp_device *dev;
+	struct ishtp_cl *pos;
+	struct ishtp_cl *next;
 	unsigned long	flags;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return false;
 
 	dev = cl->dev;
-
 	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
-		if ((pos->state == HECI_CL_CONNECTING) && (pos != cl) &&
-				cl->me_client_id == pos->me_client_id) {
+		if ((pos->state == ISHTP_CL_CONNECTING) && (pos != cl) &&
+				cl->fw_client_id == pos->fw_client_id) {
 			spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 			return true;
 		}
-
 	}
 	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 
 	return false;
 }
 
-/**
- * heci_cl_connect - connect host clinet to the me one
- *
- * @cl: host client
- *
- * Locking: called under "dev->device_lock" lock
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_cl_connect(struct heci_cl *cl)
+/* ishtp_cl_connect - connect host client to the fw one */
+int ishtp_cl_connect(struct ishtp_cl *cl)
 {
-	struct heci_device *dev;
-	long timeout = heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT);
+	struct ishtp_device *dev;
+	long timeout = ishtp_secs_to_jiffies(ISHTP_CL_CONNECT_TIMEOUT);
 	int rets;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
-	if (heci_cl_is_other_connecting(cl))
+	if (ishtp_cl_is_other_connecting(cl))
 		return	-EBUSY;
 
 	dev = cl->dev;
 
-	rets = pm_runtime_get_sync(&dev->pdev->dev);
-	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
-	if (IS_ERR_VALUE(rets)) {
-		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
-		return rets;
-	}
+	if (ishtp_hbm_cl_connect_req(dev, cl))
+		return -ENODEV;
 
-	if (heci_hbm_cl_connect_req(dev, cl)) {
-		rets = -ENODEV;
-		goto out;
-	}
 
 	rets = wait_event_timeout(cl->wait_ctrl_res,
-				(dev->dev_state == HECI_DEV_ENABLED &&
-				 (cl->state == HECI_CL_CONNECTED ||
-				  cl->state == HECI_CL_DISCONNECTED)),
-				 timeout * HZ);
-
+		(dev->dev_state == ISHTP_DEV_ENABLED &&
+		(cl->state == ISHTP_CL_CONNECTED ||
+		cl->state == ISHTP_CL_DISCONNECTED)), timeout * HZ);
 	/*
 	 * If FW reset arrived, this will happen. Don't check cl->,
 	 * as 'cl' may be freed already
 	 */
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -EFAULT;
-		goto	out;
-	}
+	if (dev->dev_state != ISHTP_DEV_ENABLED)
+		return -EFAULT;
 
-	if (cl->state != HECI_CL_CONNECTED) {
-		rets = -EFAULT;
-		goto out;
-	}
+	if (cl->state != ISHTP_CL_CONNECTED)
+		return -EFAULT;
 
 	rets = cl->status;
 	if (rets)
-		goto	out;
+		return rets;
 
-	rets = heci_cl_device_bind(cl);
+	rets = ishtp_cl_device_bind(cl);
 	if (rets) {
-		heci_cl_disconnect(cl);
-		goto    out;
+		ishtp_cl_disconnect(cl);
+		return rets;
 	}
 
-	rets = heci_cl_alloc_rx_ring(cl);
+	rets = ishtp_cl_alloc_rx_ring(cl);
 	if (rets) {
 		/* if failed allocation, disconnect */
-		heci_cl_disconnect(cl);
-		goto	out;
+		ishtp_cl_disconnect(cl);
+		return rets;
 	}
 
-	rets = heci_cl_alloc_tx_ring(cl);
+	rets = ishtp_cl_alloc_tx_ring(cl);
 	if (rets) {
 		/* if failed allocation, disconnect */
-		heci_cl_free_rx_ring(cl);
-		heci_cl_disconnect(cl);
-		goto	out;
+		ishtp_cl_free_rx_ring(cl);
+		ishtp_cl_disconnect(cl);
+		return rets;
 	}
 
 	/* Upon successful connection and allocation, emit flow-control */
-	rets = heci_cl_read_start(cl);
-out:
-	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
-
+	rets = ishtp_cl_read_start(cl);
 	return rets;
 }
-EXPORT_SYMBOL(heci_cl_connect);
+EXPORT_SYMBOL(ishtp_cl_connect);
 
-/**
- * heci_cl_read_start - the start read client message function.
- *
- * @cl: host client
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_cl_read_start(struct heci_cl *cl)
+/* ishtp_cl_read_start - start to read client message */
+int ishtp_cl_read_start(struct ishtp_cl *cl)
 {
-	struct heci_device *dev;
-	struct heci_cl_rb *rb;
+	struct ishtp_device *dev;
+	struct ishtp_cl_rb *rb;
 	int rets;
 	int i;
 	unsigned long	flags;
@@ -746,54 +604,38 @@ int heci_cl_read_start(struct heci_cl *cl)
 
 	dev = cl->dev;
 
-	if (cl->state != HECI_CL_CONNECTED)
+	if (cl->state != ISHTP_CL_CONNECTED)
 		return -ENODEV;
 
-	if (dev->dev_state != HECI_DEV_ENABLED)
+	if (dev->dev_state != ISHTP_DEV_ENABLED)
 		return -ENODEV;
 
-/*
-	if (cl->read_rb) {
-		dev_dbg(&dev->pdev->dev, "read is pending.\n");
-		return -EBUSY;
-	}
-*/
-	i = heci_me_cl_by_id(dev, cl->me_client_id);
+	i = ishtp_fw_cl_by_id(dev, cl->fw_client_id);
 	if (i < 0) {
-		dev_err(&dev->pdev->dev, "no such me client %d\n",
-			cl->me_client_id);
-		return  -ENODEV;
-	}
-
-	rets = pm_runtime_get_sync(&dev->pdev->dev);
-	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
-	if (IS_ERR_VALUE(rets)) {
-		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
-		return rets;
+		dev_err(&cl->device->dev, "no such fw client %d\n",
+			cl->fw_client_id);
+		return -ENODEV;
 	}
 
 	/* The current rb is the head of the free rb list */
 	spin_lock_irqsave(&cl->free_list_spinlock, flags);
 	if (list_empty(&cl->free_rb_list.list)) {
-		dev_warn(&dev->pdev->dev, "[heci-ish] rb pool is empty\n");
+		dev_warn(&cl->device->dev, "[ishtp-ish] Rx buffers pool is empty\n");
 		rets = -ENOMEM;
 		rb = NULL;
 		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
 		goto out;
 	}
-	rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb, list);
+	rb = list_entry(cl->free_rb_list.list.next, struct ishtp_cl_rb, list);
 	list_del_init(&rb->list);
 	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-	/***************/
+
 	rb->cl = cl;
 	rb->buf_idx = 0;
-	/***************/
 
-	heci_io_list_init(rb);
+	INIT_LIST_HEAD(&rb->list);
 	rets = 0;
 
-	/*cl->read_rb = rb;*/
-
 	/*
 	 * This must be BEFORE sending flow control -
 	 * response in ISR may come too fast...
@@ -801,17 +643,12 @@ int heci_cl_read_start(struct heci_cl *cl)
 	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
 	list_add_tail(&rb->list, &dev->read_list.list);
 	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
-	if (heci_hbm_cl_flow_control_req(dev, cl)) {
+	if (ishtp_hbm_cl_flow_control_req(dev, cl)) {
 		rets = -ENODEV;
 		goto out;
 	}
-
 out:
-	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
-
-	/* heci_hbm_cl_flow_control_req failed, return rb to free list */
+	/* if ishtp_hbm_cl_flow_control_req failed, return rb to free list */
 	if (rets && rb) {
 		spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
 		list_del(&rb->list);
@@ -821,99 +658,42 @@ out:
 		list_add_tail(&rb->list, &cl->free_rb_list.list);
 		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
 	}
-
 	return rets;
 }
-EXPORT_SYMBOL(heci_cl_read_start);
-
 
-int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
+int ishtp_cl_send(struct ishtp_cl *cl, uint8_t *buf, size_t length)
 {
-	struct heci_device *dev;
-	int id;
-	struct heci_cl_tx_ring  *cl_msg;
+	struct ishtp_device	*dev;
+	int	id;
+	struct ishtp_cl_tx_ring	*cl_msg;
 	int	have_msg_to_send = 0;
-	unsigned long	me_flags, tx_flags, tx_free_flags;
+	unsigned long	tx_flags, tx_free_flags;
 
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
 	dev = cl->dev;
 
-	if (cl->state != HECI_CL_CONNECTED) {
+	if (cl->state != ISHTP_CL_CONNECTED) {
 		++cl->err_send_msg;
 		return -EPIPE;
 	}
 
-	if (dev->dev_state != HECI_DEV_ENABLED) {
+	if (dev->dev_state != ISHTP_DEV_ENABLED) {
 		++cl->err_send_msg;
 		return -ENODEV;
 	}
 
-	/* Check if we have an ME client device */
-	id = heci_me_cl_by_id(dev, cl->me_client_id);
+	/* Check if we have fw client device */
+	id = ishtp_fw_cl_by_id(dev, cl->fw_client_id);
 	if (id < 0) {
 		++cl->err_send_msg;
 		return -ENOENT;
 	}
 
-	spin_lock_irqsave(&dev->me_clients_lock, me_flags);
-	if (length > dev->me_clients[id].props.max_msg_length) {
-		/* If the client supports DMA, try to use it */
-		if (host_dma_enabled && dev->me_clients[id].props.dma_hdr_len &
-				HECI_CLIENT_DMA_ENABLED) {
-			struct heci_msg_hdr	hdr;
-			struct hbm_client_dma_request	heci_dma_request_msg;
-			unsigned len = sizeof(struct hbm_client_dma_request);
-			int	preview_len =
-				dev->me_clients[id].props.dma_hdr_len & 0x7F;
-			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
-			/* DMA max msg size is 1M */
-			if (length > host_dma_tx_buf_size) {
-				++cl->err_send_msg;
-				return	-EMSGSIZE;
-			}
-
-			/*
-			 * Client for some reason specified
-			 * props.dma_hdr_len > 12, mistake?
-			 */
-			if (preview_len > 12) {
-				++cl->err_send_msg;
-				return	-EINVAL;
-			}
-
-			/*If previous DMA transfer is in progress, go to sleep*/
-			wait_event_timeout(dev->wait_dma_ready, dma_ready,
-				10 * HZ);
-			dma_ready = 0;
-			/*
-			 * First 'preview_len' bytes of buffer are preview
-			 * bytes, omitted from DMA message
-			 */
-			memcpy(host_dma_tx_buf, buf + preview_len,
-				length - preview_len);
-			heci_hbm_hdr(&hdr, len);
-			heci_dma_request_msg.hbm_cmd = CLIENT_DMA_REQ_CMD;
-			heci_dma_request_msg.me_addr = cl->me_client_id;
-			heci_dma_request_msg.host_addr = cl->host_client_id;
-			heci_dma_request_msg.reserved = 0;
-			heci_dma_request_msg.msg_addr = host_dma_tx_buf_phys;
-			heci_dma_request_msg.msg_len = length - preview_len;
-			heci_dma_request_msg.reserved2 = 0;
-			memcpy(heci_dma_request_msg.msg_preview, buf,
-				preview_len);
-			heci_write_message(dev, &hdr,
-				(uint8_t *)&heci_dma_request_msg);
-			return 0;
-		} else {
-			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
-			++cl->err_send_msg;
-			return -EINVAL;		/* -EMSGSIZE? */
-		}
-	} else {
-		spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
+	if (length > dev->fw_clients[id].props.max_msg_length) {
+		++cl->err_send_msg;
+		return -EMSGSIZE;
 	}
 
 	/* No free bufs */
@@ -926,14 +706,13 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 	}
 
 	cl_msg = list_first_entry(&cl->tx_free_list.list,
-		struct heci_cl_tx_ring, list);
+		struct ishtp_cl_tx_ring, list);
 	if (!cl_msg->send_buf.data)
 		return	-EIO;		/* Should not happen,
 					as free list is pre-allocated */
-	++cl->send_msg_cnt;
 	/*
-	 * This is safe, as 'length' is already checked for not exceeding max.
-	 * HECI message size per client
+	 * This is safe, as 'length' is already checked for not exceeding
+	 * max ISHTP message size per client
 	 */
 	list_del_init(&cl_msg->list);
 	spin_unlock_irqrestore(&cl->tx_free_list_spinlock, tx_free_flags);
@@ -944,25 +723,19 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 	list_add_tail(&cl_msg->list, &cl->tx_list.list);
 	spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
 
-	if (!have_msg_to_send && cl->heci_flow_ctrl_creds > 0)
-		heci_cl_send_msg(dev, cl);
+	if (!have_msg_to_send && cl->ishtp_flow_ctrl_creds > 0)
+		ishtp_cl_send_msg(dev, cl);
 
 	return	0;
 }
-EXPORT_SYMBOL(heci_cl_send);
-
+EXPORT_SYMBOL(ishtp_cl_send);
 
-/**
- * heci_cl_read_complete - processes completed operation for a client
- *
- * @cl: private data of the file object.
- * @rb: callback block.
- */
-void heci_cl_read_complete(struct heci_cl_rb *rb)
+/* ishtp_cl_read_complete - processes completed operation for a client */
+void ishtp_cl_read_complete(struct ishtp_cl_rb *rb)
 {
 	unsigned long	flags;
 	int	schedule_work_flag = 0;
-	struct heci_cl	*cl = rb->cl;
+	struct ishtp_cl	*cl = rb->cl;
 
 	if (waitqueue_active(&cl->rx_wait)) {
 		cl->read_rb = rb;
@@ -978,153 +751,206 @@ void heci_cl_read_complete(struct heci_cl_rb *rb)
 		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
 
 		if (schedule_work_flag)
-			heci_cl_bus_rx_event(cl->device);
+			ishtp_cl_bus_rx_event(cl->device);
 	}
 }
-EXPORT_SYMBOL(heci_cl_read_complete);
 
-
-/**
- * heci_cl_all_disconnect - disconnect forcefully all connected clients
- *
- * @dev - heci device
- */
-void heci_cl_all_disconnect(struct heci_device *dev)
+/* ishtp_cl_all_disconnect - disconnect forcefully all connected clients */
+void ishtp_cl_all_disconnect(struct ishtp_device *dev)
 {
-	struct heci_cl *cl, *next;
+	struct ishtp_cl *cl, *next;
 	unsigned long	flags;
 
 	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		cl->state = HECI_CL_DISCONNECTED;
-		cl->heci_flow_ctrl_creds = 0;
+		cl->state = ISHTP_CL_DISCONNECTED;
+		cl->ishtp_flow_ctrl_creds = 0;
 		cl->read_rb = NULL;
 	}
 	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
-
-/**
- * heci_cl_all_read_wakeup  - wake up all readings so they can be interrupted
- *
- * @dev  - heci device
- */
-void heci_cl_all_read_wakeup(struct heci_device *dev)
+/* ishtp_cl_all_read_wakeup - wake up all readings so they can be interrupted */
+void ishtp_cl_all_read_wakeup(struct ishtp_device *dev)
 {
-	struct heci_cl *cl, *next;
+	struct ishtp_cl *cl, *next;
 	unsigned long	flags;
 
 	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (waitqueue_active(&cl->rx_wait)) {
-			dev_dbg(&dev->pdev->dev, "Waking up client!\n");
+		if (waitqueue_active(&cl->rx_wait))
 			wake_up_interruptible(&cl->rx_wait);
-		}
 	}
 	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
-/*##################################*/
-
 static void	ipc_tx_callback(void *prm)
 {
-	struct heci_cl	*cl = prm;
-	struct heci_cl_tx_ring	*cl_msg;
+	struct ishtp_cl	*cl = prm;
+	struct ishtp_cl_tx_ring	*cl_msg;
 	size_t	rem;
-	struct heci_device	*dev = (cl ? cl->dev : NULL);
-	struct heci_msg_hdr	heci_hdr;
-	unsigned long	flags, tx_flags, tx_free_flags;
+	struct ishtp_device	*dev = (cl ? cl->dev : NULL);
+	struct ishtp_msg_hdr	ishtp_hdr;
+	unsigned long	tx_flags, tx_free_flags;
 	unsigned char	*pmsg;
 
 	if (!dev)
 		return;
 
 	/*
-	 * FIXME: there may be other conditions if some critical error has
-	 * ocurred before this callback is called
+	 * Other conditions if some critical error has
+	 * occurred before this callback is called
 	 */
+	if (dev->dev_state != ISHTP_DEV_ENABLED)
+		return;
+
+	if (cl->state != ISHTP_CL_CONNECTED)
+		return;
+
 	spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
 	if (list_empty(&cl->tx_list.list)) {
 		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
 		return;
 	}
 
-	/* Last call check for fc credits */
-	if (cl->heci_flow_ctrl_creds != 1 && !cl->sending) {
+	if (cl->ishtp_flow_ctrl_creds != 1 && !cl->sending) {
 		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
 		return;
 	}
 
 	if (!cl->sending) {
-		--cl->heci_flow_ctrl_creds;
+		--cl->ishtp_flow_ctrl_creds;
+		cl->last_ipc_acked = 0;
+		cl->last_tx_path = CL_TX_PATH_IPC;
 		cl->sending = 1;
 	}
 
-	cl_msg = list_entry(cl->tx_list.list.next, struct heci_cl_tx_ring,
+	cl_msg = list_entry(cl->tx_list.list.next, struct ishtp_cl_tx_ring,
 		list);
 	rem = cl_msg->send_buf.size - cl->tx_offs;
 
-	heci_hdr.host_addr = cl->host_client_id;
-	heci_hdr.me_addr = cl->me_client_id;
-	heci_hdr.reserved = 0;
+	ishtp_hdr.host_addr = cl->host_client_id;
+	ishtp_hdr.fw_addr = cl->fw_client_id;
+	ishtp_hdr.reserved = 0;
 	pmsg = cl_msg->send_buf.data + cl->tx_offs;
 
 	if (rem <= dev->mtu) {
-		heci_hdr.length = rem;
-		heci_hdr.msg_complete = 1;
+		ishtp_hdr.length = rem;
+		ishtp_hdr.msg_complete = 1;
 		cl->sending = 0;
 		list_del_init(&cl_msg->list);	/* Must be before write */
 		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
 		/* Submit to IPC queue with no callback */
-		heci_write_message(dev, &heci_hdr, pmsg);
+		ishtp_write_message(dev, &ishtp_hdr, pmsg);
 		spin_lock_irqsave(&cl->tx_free_list_spinlock, tx_free_flags);
 		list_add_tail(&cl_msg->list, &cl->tx_free_list.list);
 		spin_unlock_irqrestore(&cl->tx_free_list_spinlock,
 			tx_free_flags);
 	} else {
-		/* FIXME: Send IPC fragment */
+		/* Send IPC fragment */
 		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
 		cl->tx_offs += dev->mtu;
-		heci_hdr.length = dev->mtu;
-		heci_hdr.msg_complete = 0;
-		dev->ops->write_ex(dev, &heci_hdr, pmsg, ipc_tx_callback, cl);
+		ishtp_hdr.length = dev->mtu;
+		ishtp_hdr.msg_complete = 0;
+		send_ishtp_msg(dev, &ishtp_hdr, pmsg, ipc_tx_callback, cl);
 	}
 }
 
-
-void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl)
+static void	ishtp_cl_send_msg_ipc(struct ishtp_device *dev,
+	struct ishtp_cl *cl)
 {
+	/* If last DMA message wasn't acked yet, leave this one in Tx queue */
+	if (cl->last_tx_path == CL_TX_PATH_DMA && cl->last_dma_acked == 0)
+		return;
+
 	cl->tx_offs = 0;
 	ipc_tx_callback(cl);
+	++cl->send_msg_cnt_ipc;
 }
-EXPORT_SYMBOL(heci_cl_send_msg);
-/*##################################*/
 
+static void	ishtp_cl_send_msg_dma(struct ishtp_device *dev,
+	struct ishtp_cl *cl)
+{
+	struct ishtp_msg_hdr	hdr;
+	struct dma_xfer_hbm	dma_xfer;
+	unsigned char	*msg_addr;
+	int off;
+	struct ishtp_cl_tx_ring	*cl_msg;
+
+	/* If last IPC message wasn't acked yet, leave this one in Tx queue */
+	if (cl->last_tx_path == CL_TX_PATH_IPC && cl->last_ipc_acked == 0)
+		return;
+
+	cl_msg = list_entry(cl->tx_list.list.next, struct ishtp_cl_tx_ring,
+		list);
+
+	msg_addr = get_dma_send_buf(dev, cl_msg->send_buf.size);
+	if (!msg_addr) {
+		if (dev->transfer_path == CL_TX_PATH_DEFAULT)
+			ishtp_cl_send_msg_ipc(dev, cl);
+		return;
+	}
+
+	--cl->ishtp_flow_ctrl_creds;
+	cl->last_dma_acked = 0;
+	cl->last_dma_addr = msg_addr;
+	cl->last_tx_path = CL_TX_PATH_DMA;
+
+	/* write msg to dma buf */
+	memcpy(msg_addr, cl_msg->send_buf.data, cl_msg->send_buf.size);
+
+	/* send dma_xfer hbm msg */
+	off = msg_addr - (unsigned char *)host_dma_tx_buf;
+	ishtp_hbm_hdr(&hdr, sizeof(struct dma_xfer_hbm));
+	dma_xfer.hbm = DMA_XFER;
+	dma_xfer.fw_client_id = cl->fw_client_id;
+	dma_xfer.host_client_id = cl->host_client_id;
+	dma_xfer.reserved = 0;
+	dma_xfer.msg_addr = host_dma_tx_buf_phys + off;
+	dma_xfer.msg_length = cl_msg->send_buf.size;
+	dma_xfer.reserved2 = 0;
+	ishtp_write_message(dev, &hdr, (unsigned char *)&dma_xfer);
+	++cl->send_msg_cnt_dma;
+}
+
+void ishtp_cl_send_msg(struct ishtp_device *dev, struct ishtp_cl *cl)
+{
+	/* CHANGEME: after enforcement path is validated */
+	if (dev->transfer_path == CL_TX_PATH_DMA /*||
+				dev->transfer_path == DEFAULT &&
+			length > dev->mtu * DMA_WORTH_THRESHOLD */)
+		ishtp_cl_send_msg_dma(dev, cl);
+	else
+		ishtp_cl_send_msg_ipc(dev, cl);
+}
+EXPORT_SYMBOL(ishtp_cl_send_msg);
 
 /*
- *	Receive and dispatch HECI client messages
+ * Receive and dispatch ISHTP client messages
  *
- *	(!) ISR context
+ * (!) ISR context
  */
-void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+void	recv_ishtp_cl_msg(struct ishtp_device *dev,
+		struct ishtp_msg_hdr *ishtp_hdr)
 {
-	struct heci_cl *cl;
-	struct heci_cl_rb *rb, *next;
-	struct heci_cl_rb *new_rb;
+	struct ishtp_cl *cl;
+	struct ishtp_cl_rb *rb, *next;
+	struct ishtp_cl_rb *new_rb;
 	unsigned char *buffer = NULL;
-	struct heci_cl_rb *complete_rb = NULL;
+	struct ishtp_cl_rb *complete_rb = NULL;
 	unsigned long	dev_flags;
 	unsigned long	flags;
 	int	rb_count;
 
 
-	if (heci_hdr->reserved) {
-		dev_err(&dev->pdev->dev, "corrupted message header.\n");
+	if (ishtp_hdr->reserved) {
+		dev_err(dev->devc, "corrupted message header.\n");
 		goto	eoi;
 	}
 
-	if (heci_hdr->length > IPC_PAYLOAD_SIZE) {
-		dev_err(&dev->pdev->dev, "HECI message length in hdr is too big for IPC MTU. Broken message\n");
+	if (ishtp_hdr->length > IPC_PAYLOAD_SIZE) {
+		dev_err(dev->devc,
+			"ISHTP message length in hdr exceeds IPC MTU\n");
 		goto	eoi;
 	}
 
@@ -1133,52 +959,53 @@ void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 	list_for_each_entry_safe(rb, next, &dev->read_list.list, list) {
 		++rb_count;
 		cl = rb->cl;
-		if (!cl || !(cl->host_client_id == heci_hdr->host_addr &&
-				cl->me_client_id == heci_hdr->me_addr) ||
-				!(cl->state == HECI_CL_CONNECTED))
+		if (!cl || !(cl->host_client_id == ishtp_hdr->host_addr &&
+				cl->fw_client_id == ishtp_hdr->fw_addr) ||
+				!(cl->state == ISHTP_CL_CONNECTED))
 			continue;
 
 		/*
-		 * FIXME: in both if() closes rb must return to free pool
-		 * and/or disband and/or disconnect client
+		 * If no Rx buffer is allocated, disband the rb
 		 */
 		if (rb->buffer.size == 0 || rb->buffer.data == NULL) {
 			spin_unlock_irqrestore(&dev->read_list_spinlock,
 				dev_flags);
-			dev_err(&dev->pdev->dev, "response buffer is not allocated.\n");
+			dev_err(&cl->device->dev, "Rx buffer is not allocated.\n");
 			list_del(&rb->list);
+			ishtp_io_rb_free(rb);
+			cl->status = -ENOMEM;
 			goto	eoi;
 		}
 
-		if (rb->buffer.size < heci_hdr->length + rb->buf_idx) {
+		/*
+		 * If message buffer overflown (exceeds max. client msg
+		 * size, drop message and return to free buffer.
+		 * Do we need to disconnect such a client? (We don't send
+		 * back FC, so communication will be stuck anyway)
+		 */
+		if (rb->buffer.size < ishtp_hdr->length + rb->buf_idx) {
 			spin_unlock_irqrestore(&dev->read_list_spinlock,
 				dev_flags);
-			dev_err(&dev->pdev->dev, "message overflow. size %d len %d idx %ld\n",
-				rb->buffer.size, heci_hdr->length, rb->buf_idx);
+			dev_err(&cl->device->dev,
+				"message overflow. size %d len %d idx %ld\n",
+				rb->buffer.size, ishtp_hdr->length,
+				rb->buf_idx);
 			list_del(&rb->list);
+			ishtp_io_rb_recycle(rb);
+			cl->status = -EIO;
 			goto	eoi;
 		}
 
 		buffer = rb->buffer.data + rb->buf_idx;
-		dev->ops->read(dev, buffer, heci_hdr->length);
-
-		/* Debug HID client */
-		if (cl->host_client_id == 3 && cl->me_client_id == 5)
-			dev->ipc_hid_in_msg = 1;
+		dev->ops->ishtp_read(dev, buffer, ishtp_hdr->length);
 
-		rb->buf_idx += heci_hdr->length;
-		if (heci_hdr->msg_complete) {
+		rb->buf_idx += ishtp_hdr->length;
+		if (ishtp_hdr->msg_complete) {
 			/* Last fragment in message - it's complete */
 			cl->status = 0;
 			list_del(&rb->list);
 			complete_rb = rb;
 
-			/* Debug HID client */
-			if (cl->host_client_id == 3 && cl->me_client_id == 5) {
-				dev->ipc_hid_in_msg = 0;
-				--dev->ipc_hid_out_fc;
-			}
-
 			--cl->out_flow_ctrl_creds;
 			/*
 			 * the whole msg arrived, send a new FC, and add a new
@@ -1188,7 +1015,7 @@ void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 
 			if (!list_empty(&cl->free_rb_list.list)) {
 				new_rb = list_entry(cl->free_rb_list.list.next,
-					struct heci_cl_rb, list);
+					struct ishtp_cl_rb, list);
 				list_del_init(&new_rb->list);
 				spin_unlock_irqrestore(&cl->free_list_spinlock,
 					flags);
@@ -1198,9 +1025,8 @@ void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 				list_add_tail(&new_rb->list,
 					&dev->read_list.list);
 
-				heci_hbm_cl_flow_control_req(dev, cl);
+				ishtp_hbm_cl_flow_control_req(dev, cl);
 			} else {
-				/*cl->send_fc_flag = 1;*/
 				spin_unlock_irqrestore(&cl->free_list_spinlock,
 					flags);
 			}
@@ -1218,11 +1044,10 @@ void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
 	/* If it's nobody's message, just read and discard it */
 	if (!buffer) {
-		uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
+		uint8_t	rd_msg_buf[ISHTP_RD_MSG_BUF_SIZE];
 
-		dev_err(&dev->pdev->dev, "%s(): Dropped msg - no request\n",
-			__func__);
-		dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
+		dev_err(dev->devc, "Dropped Rx msg - no request\n");
+		dev->ops->ishtp_read(dev, rd_msg_buf, ishtp_hdr->length);
 		goto	eoi;
 	}
 
@@ -1233,54 +1058,66 @@ void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 		cl->rx_sec = tv.tv_sec;
 		cl->rx_usec = tv.tv_usec;
 		++cl->recv_msg_cnt_ipc;
-		heci_cl_read_complete(complete_rb);
+		ishtp_cl_read_complete(complete_rb);
 	}
-
 eoi:
 	return;
 }
-EXPORT_SYMBOL(recv_heci_cl_msg);
 
-void	recv_heci_cl_msg_dma(struct heci_device *dev, void *msg,
+/*
+ * Receive and dispatch ISHTP client dma message
+ *
+ * (!) ISR context
+ */
+void	recv_ishtp_cl_msg_dma(struct ishtp_device *dev, void *msg,
 	struct dma_xfer_hbm *hbm)
 {
-	struct heci_cl *cl;
-	struct heci_cl_rb *rb, *next;
-	struct heci_cl_rb *new_rb;
+	struct ishtp_cl *cl;
+	struct ishtp_cl_rb *rb, *next;
+	struct ishtp_cl_rb *new_rb;
 	unsigned char *buffer = NULL;
-	struct heci_cl_rb *complete_rb = NULL;
-	unsigned long   dev_flags;
-	unsigned long   flags;
+	struct ishtp_cl_rb *complete_rb = NULL;
+	unsigned long	dev_flags;
+	unsigned long	flags;
 
 	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
 	list_for_each_entry_safe(rb, next, &dev->read_list.list, list) {
 		cl = rb->cl;
 		if (!cl || !(cl->host_client_id == hbm->host_client_id &&
-				cl->me_client_id == hbm->fw_client_id) ||
-				!(cl->state == HECI_CL_CONNECTED))
+				cl->fw_client_id == hbm->fw_client_id) ||
+				!(cl->state == ISHTP_CL_CONNECTED))
 			continue;
 
 		/*
-		 * FIXME: in both if() closes rb must return to free pool
-		 * and/or disband and/or disconnect client
+		 * If no Rx buffer is allocated, disband the rb
 		 */
 		if (rb->buffer.size == 0 || rb->buffer.data == NULL) {
 			spin_unlock_irqrestore(&dev->read_list_spinlock,
 				dev_flags);
-			dev_err(&dev->pdev->dev,
+			dev_err(&cl->device->dev,
 				"response buffer is not allocated.\n");
 			list_del(&rb->list);
-			goto    eoi;
+			ishtp_io_rb_free(rb);
+			cl->status = -ENOMEM;
+			goto	eoi;
 		}
 
+		/*
+		 * If message buffer overflown (exceeds max. client msg
+		 * size, drop message and return to free buffer.
+		 * Do we need to disconnect such a client? (We don't send
+		 * back FC, so communication will be stuck anyway)
+		 */
 		if (rb->buffer.size < hbm->msg_length) {
 			spin_unlock_irqrestore(&dev->read_list_spinlock,
 				dev_flags);
-			dev_err(&dev->pdev->dev,
+			dev_err(&cl->device->dev,
 				"message overflow. size %d len %d idx %ld\n",
 				rb->buffer.size, hbm->msg_length, rb->buf_idx);
 			list_del(&rb->list);
-			goto    eoi;
+			ishtp_io_rb_recycle(rb);
+			cl->status = -EIO;
+			goto	eoi;
 		}
 
 		buffer = rb->buffer.data;
@@ -1301,7 +1138,7 @@ void	recv_heci_cl_msg_dma(struct heci_device *dev, void *msg,
 
 		if (!list_empty(&cl->free_rb_list.list)) {
 			new_rb = list_entry(cl->free_rb_list.list.next,
-				struct heci_cl_rb, list);
+				struct ishtp_cl_rb, list);
 			list_del_init(&new_rb->list);
 			spin_unlock_irqrestore(&cl->free_list_spinlock,
 				flags);
@@ -1311,7 +1148,7 @@ void	recv_heci_cl_msg_dma(struct heci_device *dev, void *msg,
 			list_add_tail(&new_rb->list,
 				&dev->read_list.list);
 
-			heci_hbm_cl_flow_control_req(dev, cl);
+			ishtp_hbm_cl_flow_control_req(dev, cl);
 		} else {
 			spin_unlock_irqrestore(&cl->free_list_spinlock,
 				flags);
@@ -1330,22 +1167,19 @@ void	recv_heci_cl_msg_dma(struct heci_device *dev, void *msg,
 	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
 	/* If it's nobody's message, just read and discard it */
 	if (!buffer) {
-		dev_err(&dev->pdev->dev, "%s(): Dropped msg - no request\n",
-			__func__);
-		goto    eoi;
+		dev_err(dev->devc, "Dropped Rx (DMA) msg - no request\n");
+		goto	eoi;
 	}
 
 	/* Looks like this is interrupt-safe */
 	if (complete_rb) {
-		struct timeval  tv;
+		struct timeval	tv;
 		do_gettimeofday(&tv);
 		cl->rx_sec = tv.tv_sec;
 		cl->rx_usec = tv.tv_usec;
 		++cl->recv_msg_cnt_dma;
-		heci_cl_read_complete(complete_rb);
-		}
-
+		ishtp_cl_read_complete(complete_rb);
+	}
 eoi:
 	return;
 }
-EXPORT_SYMBOL(recv_heci_cl_msg_dma);
diff --git a/drivers/misc/intel-ish/client.h b/drivers/misc/intel-ish/client.h
index dbd71bb..e891869 100644
--- a/drivers/misc/intel-ish/client.h
+++ b/drivers/misc/intel-ish/client.h
@@ -1,7 +1,7 @@
 /*
- * HECI client logic
+ * ISHTP client logic
  *
- * Copyright (c) 2003-2015, Intel Corporation.
+ * Copyright (c) 2003-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -13,94 +13,110 @@
  * more details.
  */
 
-#ifndef _HECI_CLIENT_H_
-#define _HECI_CLIENT_H_
+#ifndef _ISHTP_CLIENT_H_
+#define _ISHTP_CLIENT_H_
 
 #include <linux/types.h>
-#include <linux/watchdog.h>
-#include <linux/poll.h>
-#include "heci_dev.h"
+#include "ishtp_dev.h"
 
 /* Client state */
 enum cl_state {
-	HECI_CL_INITIALIZING = 0,
-	HECI_CL_CONNECTING,
-	HECI_CL_CONNECTED,
-	HECI_CL_DISCONNECTING,
-	HECI_CL_DISCONNECTED
+	ISHTP_CL_INITIALIZING = 0,
+	ISHTP_CL_CONNECTING,
+	ISHTP_CL_CONNECTED,
+	ISHTP_CL_DISCONNECTING,
+	ISHTP_CL_DISCONNECTED
 };
 
+/* Tx and Rx ring size */
 #define	CL_DEF_RX_RING_SIZE	2
 #define	CL_DEF_TX_RING_SIZE	2
 #define	CL_MAX_RX_RING_SIZE	32
 #define	CL_MAX_TX_RING_SIZE	32
 
-/* Client Tx  buffer list entry */
-struct heci_cl_tx_ring {
-	struct list_head list;
-	struct heci_msg_data	send_buf;
+#define DMA_SLOT_SIZE		4096
+/* Number of IPC fragments after which it's worth sending via DMA */
+#define	DMA_WORTH_THRESHOLD	3
+
+/* DMA/IPC Tx paths. Other the default means enforcement */
+#define	CL_TX_PATH_DEFAULT	0
+#define	CL_TX_PATH_IPC		1
+#define	CL_TX_PATH_DMA		2
+
+/* Client Tx buffer list entry */
+struct ishtp_cl_tx_ring {
+	struct list_head	list;
+	struct ishtp_msg_data	send_buf;
 };
 
-/* HECI client instance carried as file->pirvate_data*/
-struct heci_cl {
-	struct list_head link;
-	struct heci_device *dev;
-	enum cl_state state;
-	wait_queue_head_t rx_wait;
-	wait_queue_head_t wait;
-	int status;
+/* ISHTP client instance carried as file->pirvate_data (in ishtp-api)*/
+struct ishtp_cl {
+	struct list_head	link;
+	struct ishtp_device	*dev;
+	enum cl_state	state;
+	int	status;
+
+	/* Link to ISHTP bus device */
+	struct ishtp_cl_device	*device;
+
 	/* ID of client connected */
-	u8 host_client_id;
-	u8 me_client_id;
-	u8 heci_flow_ctrl_creds;
-	u8 out_flow_ctrl_creds;
-	struct heci_cl_rb *read_rb;
+	uint8_t	host_client_id;
+	uint8_t	fw_client_id;
+	uint8_t	ishtp_flow_ctrl_creds;
+	uint8_t	out_flow_ctrl_creds;
+
+	wait_queue_head_t	rx_wait;
+	wait_queue_head_t	wait;
+	struct ishtp_cl_rb	*read_rb;
 
-	/* Link to HECI bus device */
-	struct heci_cl_device *device;
+	/* dma */
+	int	last_tx_path;
+	int	last_dma_acked;	/*0: ack wasn't received, 1: ack was received */
+	unsigned char	*last_dma_addr;
+	int	last_ipc_acked;	/*0: ack wasn't received, 1: ack was received */
 
 	/* Rx ring buffer pool */
 	unsigned	rx_ring_size;
-	struct heci_cl_rb	free_rb_list;
-	/*int     send_fc_flag;*/
-	spinlock_t      free_list_spinlock;
+	struct ishtp_cl_rb	free_rb_list;
+	spinlock_t	free_list_spinlock;
 	/* Rx in-process list */
-	struct heci_cl_rb       in_process_list;
-	spinlock_t      in_process_spinlock;
+	struct ishtp_cl_rb	in_process_list;
+	spinlock_t	in_process_spinlock;
 
 	/* Client Tx buffers list */
 	unsigned	tx_ring_size;
-	struct heci_cl_tx_ring	tx_list, tx_free_list;
-	spinlock_t      tx_list_spinlock;
-	spinlock_t      tx_free_list_spinlock;
+	struct ishtp_cl_tx_ring	tx_list, tx_free_list;
+	spinlock_t	tx_list_spinlock;
+	spinlock_t	tx_free_list_spinlock;
 	size_t	tx_offs;	/* Offset in buffer at head of 'tx_list' */
-	/*#############################*/
-	/* if we get a FC, and the list is not empty, we must know whether we
+
+	/**
+	 * if we get a FC, and the list is not empty, we must know whether we
 	 * are at the middle of sending.
 	 * if so - need to increase FC counter, otherwise, need to start sending
 	 * the first msg in list
 	 * (!) This is for counting-FC implementation only. Within single-FC the
 	 * other party may NOT send FC until it receives complete message
 	 */
-	int sending;
-	/*#############################*/
+	int	sending;
 
 	/* Send FC spinlock */
-	spinlock_t      fc_spinlock;
+	spinlock_t	fc_spinlock;
 
 	/* wait queue for connect and disconnect response from FW */
-	wait_queue_head_t wait_ctrl_res;
+	wait_queue_head_t	wait_ctrl_res;
 
 	/* Error stats */
 	unsigned	err_send_msg;
 	unsigned	err_send_fc;
 
 	/* Send/recv stats */
-	unsigned	send_msg_cnt;
+	unsigned	send_msg_cnt_ipc;
+	unsigned	send_msg_cnt_dma;
 	unsigned	recv_msg_cnt_ipc;
 	unsigned	recv_msg_cnt_dma;
 	unsigned	recv_msg_num_frags;
-	unsigned	heci_flow_ctrl_cnt;
+	unsigned	ishtp_flow_ctrl_cnt;
 	unsigned	out_flow_ctrl_cnt;
 
 	/* Rx msg ... out FC timing */
@@ -109,7 +125,8 @@ struct heci_cl {
 	unsigned long	max_fc_delay_sec, max_fc_delay_usec;
 };
 
-extern int	dma_ready;
+extern struct miscdevice	ishtp_misc_device;
+/* dma global vars */
 extern int	host_dma_enabled;
 extern void	*host_dma_tx_buf;
 extern unsigned	host_dma_tx_buf_size;
@@ -117,85 +134,69 @@ extern uint64_t	host_dma_tx_buf_phys;
 extern void	*host_dma_rx_buf;
 extern unsigned	host_dma_rx_buf_size;
 extern uint64_t	host_dma_rx_buf_phys;
+extern spinlock_t	dma_tx_lock;
+extern int	dma_num_slots;
+extern uint8_t	*dma_tx_map;
 
-int heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid);
-int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *cuuid);
-int heci_me_cl_by_id(struct heci_device *dev, u8 client_id);
+int ishtp_can_client_connect(struct ishtp_device *ishtp_dev, uuid_le *uuid);
+int ishtp_fw_cl_by_uuid(struct ishtp_device *dev, const uuid_le *cuuid);
+int ishtp_fw_cl_by_id(struct ishtp_device *dev, uint8_t client_id);
 
 /*
- * HECI IO Functions
- */
-struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl);
-void heci_io_rb_free(struct heci_cl_rb *priv_rb);
-int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length);
-int heci_io_rb_recycle(struct heci_cl_rb *rb);
-
-
-/**
- * heci_io_list_init - Sets up a queue list.
- *
- * @list: An instance cl callback structure
+ * ISHTP IO Functions
  */
-static inline void heci_io_list_init(struct heci_cl_rb *list)
-{
-	INIT_LIST_HEAD(&list->list);
-}
-void heci_read_list_flush(struct heci_cl *cl);
+struct ishtp_cl_rb	*ishtp_io_rb_init(struct ishtp_cl *cl);
+void	ishtp_io_rb_free(struct ishtp_cl_rb *priv_rb);
+int	ishtp_io_rb_alloc_buf(struct ishtp_cl_rb *rb, size_t length);
+int	ishtp_io_rb_recycle(struct ishtp_cl_rb *rb);
 
 /*
- * HECI Host Client Functions
+ * ISHTP Host Client Functions
  */
+struct ishtp_cl	*ishtp_cl_allocate(struct ishtp_device *dev);
+void	ishtp_cl_init(struct ishtp_cl *cl, struct ishtp_device *dev);
+void	ishtp_cl_free(struct ishtp_cl *cl);
 
-struct heci_cl *heci_cl_allocate(struct heci_device *dev);
-void heci_cl_init(struct heci_cl *cl, struct heci_device *dev);
-void	heci_cl_free(struct heci_cl *cl);
+int	ishtp_cl_alloc_rx_ring(struct ishtp_cl *cl);
+int	ishtp_cl_alloc_tx_ring(struct ishtp_cl *cl);
+int	ishtp_cl_free_rx_ring(struct ishtp_cl *cl);
+int	ishtp_cl_free_tx_ring(struct ishtp_cl *cl);
 
-int	heci_cl_alloc_rx_ring(struct heci_cl *cl);
-int	heci_cl_alloc_tx_ring(struct heci_cl *cl);
-int	heci_cl_free_rx_ring(struct heci_cl *cl);
-int	heci_cl_free_tx_ring(struct heci_cl *cl);
+int	ishtp_cl_link(struct ishtp_cl *cl, int id);
+int	ishtp_cl_unlink(struct ishtp_cl *cl);
 
-int heci_cl_link(struct heci_cl *cl, int id);
-int heci_cl_unlink(struct heci_cl *cl);
+int	ishtp_cl_flush_queues(struct ishtp_cl *cl);
+struct ishtp_cl_rb	*ishtp_cl_find_read_rb(struct ishtp_cl *cl);
+void	ishtp_read_list_flush(struct ishtp_cl *cl);
 
-int heci_cl_flush_queues(struct heci_cl *cl);
-struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl);
+/*
+ *  ISHTP input output function prototype
+ */
+bool	ishtp_cl_is_other_connecting(struct ishtp_cl *cl);
+int	ishtp_cl_disconnect(struct ishtp_cl *cl);
+int	ishtp_cl_connect(struct ishtp_cl *cl);
+int	ishtp_cl_read_start(struct ishtp_cl *cl);
+int	ishtp_cl_send(struct ishtp_cl *cl, uint8_t *buf, size_t length);
+void	ishtp_cl_read_complete(struct ishtp_cl_rb *rb);
+void	ishtp_cl_all_disconnect(struct ishtp_device *dev);
+void	ishtp_cl_all_read_wakeup(struct ishtp_device *dev);
+void	ishtp_cl_send_msg(struct ishtp_device *dev, struct ishtp_cl *cl);
+void	ishtp_cl_alloc_dma_buf(void);
+void	recv_ishtp_cl_msg(struct ishtp_device *dev,
+		struct ishtp_msg_hdr *ishtp_hdr);
+void	recv_ishtp_cl_msg_dma(struct ishtp_device *dev, void *msg,
+		struct dma_xfer_hbm *hbm);
 
 /**
- * heci_cl_cmp_id - tells if file private data have same id
- *
- * @fe1: private data of 1. file object
- * @fe2: private data of 2. file object
- *
+ * ishtp_cl_cmp_id - tells if file private data have same id
  * returns true  - if ids are the same and not NULL
  */
-static inline bool heci_cl_cmp_id(const struct heci_cl *cl1,
-				const struct heci_cl *cl2)
+static inline bool ishtp_cl_cmp_id(const struct ishtp_cl *cl1,
+				const struct ishtp_cl *cl2)
 {
 	return cl1 && cl2 &&
 		(cl1->host_client_id == cl2->host_client_id) &&
-		(cl1->me_client_id == cl2->me_client_id);
+		(cl1->fw_client_id == cl2->fw_client_id);
 }
 
-
-int heci_cl_flow_ctrl_creds(struct heci_cl *cl);
-
-/*
- *  HECI input output function prototype
- */
-bool heci_cl_is_other_connecting(struct heci_cl *cl);
-int heci_cl_disconnect(struct heci_cl *cl);
-int heci_cl_connect(struct heci_cl *cl);
-int heci_cl_read_start(struct heci_cl *cl);
-int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length);
-void heci_cl_read_complete(struct heci_cl_rb *rb);
-void heci_cl_all_disconnect(struct heci_device *dev);
-void heci_cl_all_read_wakeup(struct heci_device *dev);
-void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl);
-void heci_cl_alloc_dma_buf(void);
-void recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
-void recv_heci_cl_msg_dma(struct heci_device *dev, void *msg,
-	struct dma_xfer_hbm *hbm);
-
-#endif /* _HECI_CLIENT_H_ */
-
+#endif /* _ISHTP_CLIENT_H_ */
diff --git a/drivers/misc/intel-ish/debugfs.c b/drivers/misc/intel-ish/debugfs.c
index 1160d4f..f2de5ed 100644
--- a/drivers/misc/intel-ish/debugfs.c
+++ b/drivers/misc/intel-ish/debugfs.c
@@ -1,7 +1,7 @@
 /*
- * DebugFS for HECI driver
+ * DebugFS for ISHTP driver
  *
- * Copyright (c) 2012-2015, Intel Corporation.
+ * Copyright (c) 2012-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,7 +9,7 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
  */
@@ -17,120 +17,194 @@
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/debugfs.h>
-#include <linux/pci.h>
-#include "heci_dev.h"
+#include "ishtp_dev.h"
+#include "client.h"
 
-static ssize_t heci_dbgfs_read_meclients(struct file *fp, char __user *ubuf,
+static ssize_t ishtp_dbgfs_read_host_clients(struct file *fp, char __user *ubuf,
 					size_t cnt, loff_t *ppos)
 {
-	struct heci_device *dev = fp->private_data;
-	struct heci_me_client *cl;
+	struct ishtp_device *ishtp_dev = fp->private_data;
+	struct ishtp_cl *cl, *next;
+	struct ishtp_cl_rb *rb, *next_rb;
+	struct ishtp_cl_tx_ring *tx_rb, *next_tx_rb;
+	int	ret, pos = 0;
+	unsigned	count;
+	unsigned long	flags, flags2, tx_flags, tx_free_flags;
+	static const char * const cl_states[] = {"initializing", "connecting",
+		"connected", "disconnecting", "disconnected"};
 	const size_t bufsz = 1024;
 	char *buf = kzalloc(bufsz, GFP_KERNEL);
-	int i;
-	int pos = 0;
-	int ret;
-	unsigned long	flags;
-	if  (!buf)
+	if (!buf)
 		return -ENOMEM;
 
-	pos += scnprintf(buf + pos, bufsz - pos,
-			"  |id|addr|         UUID                       |con|msg len|\n");
+	scnprintf(buf, PAGE_SIZE, "Host clients:\n ------------\n");
+	spin_lock_irqsave(&ishtp_dev->device_lock, flags);
+	list_for_each_entry_safe(cl, next, &ishtp_dev->cl_list, link) {
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"id: %d\n", cl->host_client_id);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"state: %s\n", cl->state < 0 || cl->state >
+			ISHTP_CL_DISCONNECTED ? "unknown" :
+			cl_states[cl->state]);
+		if (cl->state == ISHTP_CL_CONNECTED) {
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"FW client id: %d\n", cl->fw_client_id);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Rx ring size: %u\n", cl->rx_ring_size);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Tx ring size: %u\n", cl->tx_ring_size);
 
-	/*  if the driver is not enabled the list won't b consitent */
-	if (dev->dev_state != HECI_DEV_ENABLED)
-		goto out;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	for (i = 0; i < dev->me_clients_num; i++) {
-		cl = &dev->me_clients[i];
-		/* skip me clients that cannot be connected */
-		if (cl->props.max_number_of_connections == 0)
-			continue;
+			count = 0;
+			spin_lock_irqsave(&cl->in_process_spinlock, flags2);
+			list_for_each_entry_safe(rb, next_rb,
+					&cl->in_process_list.list, list)
+				++count;
+			spin_unlock_irqrestore(&cl->in_process_spinlock,
+				flags2);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Rx in work: %u\n", count);
 
-		pos += scnprintf(buf + pos, bufsz - pos,
-			"%2d|%2d|%4d|%pUl|%3d|%7d|\n",
-			i, cl->client_id,
-			cl->props.fixed_address,
-			&cl->props.protocol_name,
-			cl->props.max_number_of_connections,
-			cl->props.max_msg_length);
+			count = 0;
+			spin_lock_irqsave(&cl->in_process_spinlock, flags2);
+			list_for_each_entry_safe(rb, next_rb,
+				&cl->free_rb_list.list, list)
+					++count;
+			spin_unlock_irqrestore(&cl->in_process_spinlock,
+				flags2);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Rx free: %u\n", count);
+
+			count = 0;
+			spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
+			list_for_each_entry_safe(tx_rb, next_tx_rb,
+				&cl->tx_list.list, list)
+				++count;
+			spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
+
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Tx pending: %u\n", count);
+			count = 0;
+			spin_lock_irqsave(&cl->tx_free_list_spinlock,
+				tx_free_flags);
+			list_for_each_entry_safe(tx_rb, next_tx_rb,
+					&cl->tx_free_list.list, list)
+				++count;
+			spin_unlock_irqrestore(&cl->tx_free_list_spinlock,
+				tx_free_flags);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Tx free: %u\n", count);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"FC: %u\n",
+				(unsigned)cl->ishtp_flow_ctrl_creds);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"out FC: %u\n",
+				(unsigned)cl->out_flow_ctrl_creds);
+			scnprintf(buf + strlen(buf),
+				PAGE_SIZE - strlen(buf), "Err snd msg: %u\n",
+				(unsigned)cl->err_send_msg);
+			scnprintf(buf + strlen(buf),
+				PAGE_SIZE - strlen(buf), "Err snd FC: %u\n",
+				(unsigned)cl->err_send_fc);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Tx IPC count: %u\n",
+				(unsigned)cl->send_msg_cnt_ipc);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Tx DMA count: %u\n",
+				(unsigned)cl->send_msg_cnt_dma);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Rx IPC count: %u\n",
+				(unsigned)cl->recv_msg_cnt_ipc);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Rx DMA count: %u\n",
+				(unsigned)cl->recv_msg_cnt_dma);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"FC count: %u\n",
+				(unsigned)cl->ishtp_flow_ctrl_cnt);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"out FC cnt: %u\n",
+				(unsigned)cl->out_flow_ctrl_cnt);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"Max FC delay: %lu.%06lu\n",
+				cl->max_fc_delay_sec, cl->max_fc_delay_usec);
+		}
 	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-out:
+	spin_unlock_irqrestore(&ishtp_dev->device_lock, flags);
+	pos = strlen(buf);
+
 	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
 	kfree(buf);
 	return ret;
 }
 
-static const struct file_operations heci_dbgfs_fops_meclients = {
+static const struct file_operations ishtp_dbgfs_fops_host_clients = {
 	.open = simple_open,
-	.read = heci_dbgfs_read_meclients,
+	.read = ishtp_dbgfs_read_host_clients,
 	.llseek = generic_file_llseek,
 };
 
-static ssize_t heci_dbgfs_read_devstate(struct file *fp, char __user *ubuf,
+static ssize_t ishtp_dbgfs_read_dev_stats(struct file *fp, char __user *ubuf,
 					size_t cnt, loff_t *ppos)
 {
-	struct heci_device *dev = fp->private_data;
+	struct ishtp_device *ishtp_dev = fp->private_data;
+	int ret, pos = 0;
 	const size_t bufsz = 1024;
 	char *buf = kzalloc(bufsz, GFP_KERNEL);
-	int pos = 0;
-	int ret;
-
-	if  (!buf)
+	if (!buf)
 		return -ENOMEM;
+	pos = scnprintf(buf + pos, PAGE_SIZE - strlen(buf),
+			"IPC Rx frames: %u; bytes: %llu\n",
+			ishtp_dev->ipc_rx_cnt, ishtp_dev->ipc_rx_bytes_cnt);
+	pos = scnprintf(buf + pos, PAGE_SIZE - strlen(buf),
+			"IPC Tx frames: %u; bytes: %llu\n",
+			ishtp_dev->ipc_tx_cnt, ishtp_dev->ipc_tx_bytes_cnt);
 
-	pos += scnprintf(buf + pos, bufsz - pos, "%s\n",
-			heci_dev_state_str(dev->dev_state));
 	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
 	kfree(buf);
 	return ret;
 }
-static const struct file_operations heci_dbgfs_fops_devstate = {
+static const struct file_operations ishtp_dbgfs_fops_dev_stats = {
 	.open = simple_open,
-	.read = heci_dbgfs_read_devstate,
+	.read = ishtp_dbgfs_read_dev_stats,
 	.llseek = generic_file_llseek,
 };
 
 /**
- * heci_dbgfs_deregister - Remove the debugfs files and directories
- * @heci - pointer to heci device private dat
- */
-void heci_dbgfs_deregister(struct heci_device *dev)
-{
-	if (!dev->dbgfs_dir)
-		return;
-	debugfs_remove_recursive(dev->dbgfs_dir);
-	dev->dbgfs_dir = NULL;
-}
-
-/**
  * Add the debugfs files
- *
  */
-int heci_dbgfs_register(struct heci_device *dev, const char *name)
+int ishtp_dbgfs_register(struct ishtp_device *dev, const char *name)
 {
 	struct dentry *dir, *f;
 	dir = debugfs_create_dir(name, NULL);
 	if (!dir)
 		return -ENOMEM;
 
-	f = debugfs_create_file("meclients", S_IRUSR, dir,
-				dev, &heci_dbgfs_fops_meclients);
+	f = debugfs_create_file("host_clients", S_IRUSR, dir,
+				dev, &ishtp_dbgfs_fops_host_clients);
 	if (!f) {
-		dev_err(&dev->pdev->dev, "meclients: registration failed\n");
+		dev_err(dev->devc, "host_clients: registration failed\n");
 		goto err;
 	}
-	f = debugfs_create_file("devstate", S_IRUSR, dir,
-				dev, &heci_dbgfs_fops_devstate);
+	f = debugfs_create_file("dev_stats", S_IRUSR, dir,
+				dev, &ishtp_dbgfs_fops_dev_stats);
 	if (!f) {
-		dev_err(&dev->pdev->dev, "devstate: registration failed\n");
+		dev_err(dev->devc, "dev_stats: registration failed\n");
 		goto err;
 	}
 	dev->dbgfs_dir = dir;
 	return 0;
 err:
-	heci_dbgfs_deregister(dev);
+	ishtp_dbgfs_deregister(dev);
 	return -ENODEV;
 }
 
+/**
+ * ishtp_dbgfs_deregister - Remove the debugfs files and directories
+ * @ishtp - pointer to ishtp device private data
+ */
+void ishtp_dbgfs_deregister(struct ishtp_device *dev)
+{
+	if (!dev->dbgfs_dir)
+		return;
+	debugfs_remove_recursive(dev->dbgfs_dir);
+	dev->dbgfs_dir = NULL;
+}
diff --git a/drivers/misc/intel-ish/hbm.c b/drivers/misc/intel-ish/hbm.c
index 21d9883..74975e4 100644
--- a/drivers/misc/intel-ish/hbm.c
+++ b/drivers/misc/intel-ish/hbm.c
@@ -1,7 +1,7 @@
 /*
- * HECI bus layer messages handling
+ * ISHTP bus layer messages handling
  *
- * Copyright (c) 2003-2015, Intel Corporation.
+ * Copyright (c) 2003-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,172 +9,113 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
  */
 
 #include <linux/export.h>
-#include <linux/pci.h>
+#include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
-#include "heci_dev.h"
+#include <linux/spinlock.h>
+#include <linux/miscdevice.h>
+#include "ishtp_dev.h"
 #include "hbm.h"
 #include "client.h"
-#include <linux/spinlock.h>
-/*
-#define	DEBUG_FW_BOOT_SEQ	1
-#define	DUMP_CL_PROP	1
-*/
-
-#ifdef DEBUG_FW_BOOT_SEQ
-unsigned char	static_fw_cl_props[6][32] = {
-
-{0x85, 0x01, 0x00, 0x00, 0x3B, 0x79, 0x63, 0xD9, 0xCF, 0x61, 0x8E, 0x4F, 0x8C,
-	0x02, 0xF2, 0xF7, 0xD0, 0x7F, 0x8E, 0x84, 0x01, 0x01, 0x00, 0x00, 0x00,
-	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x02, 0x00, 0x00, 0xB9, 0x78, 0xCC, 0xC1, 0x93, 0xB6, 0x54, 0x4E, 0x91,
-	0x91, 0x51, 0x69, 0xCB, 0x02, 0x7C, 0x25, 0x01, 0x01, 0x00, 0x00, 0x04,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x03, 0x00, 0x00, 0x26, 0x06, 0x05, 0x1F, 0x05, 0xD5, 0x94, 0x4E, 0xB1,
-	0x89, 0x53, 0x5D, 0x7D, 0xE1, 0x9C, 0xF2, 0x01, 0x01, 0x00, 0x00, 0x34,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x04, 0x00, 0x00, 0x54, 0x6C, 0x53, 0x28, 0x99, 0xCF, 0x27, 0x4F, 0xA6,
-	0xF3, 0x49, 0x97, 0x41, 0xBA, 0xAD, 0xFE, 0x01, 0x01, 0x00, 0x00, 0x80,
-	0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00},
-{0x85, 0x05, 0x00, 0x00, 0x58, 0xCD, 0xAE, 0x33, 0x79, 0xB6, 0x54, 0x4E, 0x9B,
-	0xD9, 0xA0, 0x4D, 0x34, 0xF0, 0xC2, 0x26, 0x01, 0x01, 0x00, 0x00, 0x00,
-	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x06, 0x00, 0x00, 0x2E, 0x9A, 0x57, 0xBB, 0x54, 0xCC, 0x50, 0x44, 0xB1,
-	0xD0, 0x5E, 0x75, 0x20, 0xDC, 0xAD, 0x25, 0x01, 0x01, 0x00, 0x00, 0x04,
-	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
-
-};
-
-#define	NUM_STATIC_CLIENTS	6
-
-#endif /* DEBUG_FW_BOOT_SEQ */
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static  void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-/* #define dev_dbg dev_err */
 
-/**
- * heci_hbm_me_cl_allocate - allocates storage for me clients
- *
- * @dev: the device structure
- *
-	 * returns none.
- */
-static void heci_hbm_me_cl_allocate(struct heci_device *dev)
+/* ishtp_hbm_fw_cl_allocate - allocates storage for fw clients */
+static void ishtp_hbm_fw_cl_allocate(struct ishtp_device *dev)
 {
-	struct heci_me_client *clients;
+	struct ishtp_fw_client *clients;
 	int b;
 
-	/* count how many ME clients we have */
-	for_each_set_bit(b, dev->me_clients_map, HECI_CLIENTS_MAX)
-		dev->me_clients_num++;
+	/* count how many ISH clients we have */
+	for_each_set_bit(b, dev->fw_clients_map, ISHTP_CLIENTS_MAX)
+		dev->fw_clients_num++;
 
-	if (dev->me_clients_num <= 0)
+	if (dev->fw_clients_num <= 0)
 		return;
 
-	kfree(dev->me_clients);
-	dev->me_clients = NULL;
-
-	dev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%zd.\n",
-		dev->me_clients_num * sizeof(struct heci_me_client));
+	kfree(dev->fw_clients);
+	dev->fw_clients = NULL;
 
-	/* allocate storage for ME clients representation */
-	clients = kcalloc(dev->me_clients_num, sizeof(struct heci_me_client),
+	/* allocate storage for fw clients representation */
+	clients = kcalloc(dev->fw_clients_num, sizeof(struct ishtp_fw_client),
 		GFP_ATOMIC);
 	if (!clients) {
-		dev_err(&dev->pdev->dev, "memory allocation for ME clients failed.\n");
-		dev->dev_state = HECI_DEV_RESETTING;
-		heci_reset(dev, 1);
+		dev_err(dev->devc, "memory allocation for FW clients failed.\n");
+		dev->dev_state = ISHTP_DEV_RESETTING;
+		ish_hw_reset(dev);
 		return;
 	}
-	dev->me_clients = clients;
+	dev->fw_clients = clients;
 	return;
 }
 
 /**
- * heci_hbm_cl_hdr - construct client hbm header
- * @cl: - client
+ * ishtp_hbm_cl_hdr - construct client hbm header
+ * @cl: client
  * @hbm_cmd: host bus message command
  * @buf: buffer for cl header
  * @len: buffer length
  */
-static inline void heci_hbm_cl_hdr(struct heci_cl *cl, u8 hbm_cmd, void *buf,
+static inline void ishtp_hbm_cl_hdr(struct ishtp_cl *cl, uint8_t hbm_cmd, void *buf,
 	size_t len)
 {
-	struct heci_hbm_cl_cmd *cmd = buf;
+	struct ishtp_hbm_cl_cmd *cmd = buf;
 
 	memset(cmd, 0, len);
 
 	cmd->hbm_cmd = hbm_cmd;
 	cmd->host_addr = cl->host_client_id;
-	cmd->me_addr = cl->me_client_id;
+	cmd->fw_addr = cl->fw_client_id;
 }
 
-/**
- * same_disconn_addr - tells if they have the same address
- *
- * @file: private data of the file object.
- * @disconn: disconnection request.
- *
- * returns true if addres are same
- */
-static inline bool heci_hbm_cl_addr_equal(struct heci_cl *cl, void *buf)
+/* ishtp_hbm_cl_addr_equal - tells if they have the same address */
+static inline bool ishtp_hbm_cl_addr_equal(struct ishtp_cl *cl, void *buf)
 {
-	struct heci_hbm_cl_cmd *cmd = buf;
+	struct ishtp_hbm_cl_cmd *cmd = buf;
 	return cl->host_client_id == cmd->host_addr &&
-		cl->me_client_id == cmd->me_addr;
+		cl->fw_client_id == cmd->fw_addr;
 }
 
-
-int heci_hbm_start_wait(struct heci_device *dev)
+int ishtp_hbm_start_wait(struct ishtp_device *dev)
 {
 	int ret;
-	if (dev->hbm_state > HECI_HBM_START)
+	if (dev->hbm_state > ISHTP_HBM_START)
 		return 0;
 
-	dev_err(&dev->pdev->dev, "Going to wait for heci start hbm_state=%08X\n",
+	dev_dbg(dev->devc, "Going to wait for ishtp start. hbm_state=%08X\n",
 		dev->hbm_state);
 	ret = wait_event_timeout(dev->wait_hbm_recvd_msg,
-			dev->hbm_state >= HECI_HBM_STARTED,
-			(HECI_INTEROP_TIMEOUT * HZ));
+			dev->hbm_state >= ISHTP_HBM_STARTED,
+			(ISHTP_INTEROP_TIMEOUT * HZ));
 
-	dev_err(&dev->pdev->dev, "Woke up from waiting for heci start ret=%d hbm_state=%08X\n",
-		ret, dev->hbm_state);
+	dev_dbg(dev->devc,
+		"Woke up from waiting for ishtp start. hbm_state=%08X\n",
+		dev->hbm_state);
 
-	if (ret <= 0 && (dev->hbm_state <= HECI_HBM_START)) {
-		dev->hbm_state = HECI_HBM_IDLE;
-		dev_err(&dev->pdev->dev, "wating for heci start failed ret=%d hbm_state=%08X\n",
+	if (ret <= 0 && (dev->hbm_state <= ISHTP_HBM_START)) {
+		dev->hbm_state = ISHTP_HBM_IDLE;
+		dev_err(dev->devc,
+			"wating for ishtp start failed. ret=%d hbm_state=%08X\n",
 			ret, dev->hbm_state);
 		return -ETIMEDOUT;
 	}
 	return 0;
 }
 
-/**
- * heci_hbm_start_req - sends start request message.
- *
- * @dev: the device structure
- */
-int heci_hbm_start_req(struct heci_device *dev)
+/* ishtp_hbm_start_req - sends start request message */
+int ishtp_hbm_start_req(struct ishtp_device *dev)
 {
-	struct heci_msg_hdr hdr;
+	struct ishtp_msg_hdr hdr;
 	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct ishtp_msg_hdr *ishtp_hdr = &hdr;
 	struct hbm_host_version_request *start_req;
 	const size_t len = sizeof(struct hbm_host_version_request);
 
-	heci_hbm_hdr(heci_hdr, len);
+	ishtp_hbm_hdr(ishtp_hdr, len);
 
 	/* host start message */
 	start_req = (struct hbm_host_version_request *)data;
@@ -185,93 +126,80 @@ int heci_hbm_start_req(struct heci_device *dev)
 
 	/*
 	 * (!) Response to HBM start may be so quick that this thread would get
-	 * preempted BEFORE managing to set hbm_state = HECI_HBM_START.
-	 * So set it at first, change back to HECI_HBM_IDLE upon failure
+	 * preempted BEFORE managing to set hbm_state = ISHTP_HBM_START.
+	 * So set it at first, change back to ISHTP_HBM_IDLE upon failure
 	 */
-	dev->hbm_state = HECI_HBM_START;
-	if (heci_write_message(dev, heci_hdr, data)) {
-		dev_err(&dev->pdev->dev, "version message write failed\n");
-		dev->dev_state = HECI_DEV_RESETTING;
-		dev->hbm_state = HECI_HBM_IDLE;
-		heci_reset(dev, 1);
+	dev->hbm_state = ISHTP_HBM_START;
+	if (ishtp_write_message(dev, ishtp_hdr, data)) {
+		dev_err(dev->devc, "version message send failed\n");
+		dev->dev_state = ISHTP_DEV_RESETTING;
+		dev->hbm_state = ISHTP_HBM_IDLE;
+		ish_hw_reset(dev);
 		return -ENODEV;
 	}
 
 	return 0;
 }
-EXPORT_SYMBOL(heci_hbm_start_req);
+EXPORT_SYMBOL(ishtp_hbm_start_req);
 
-/*
- * heci_hbm_enum_clients_req - sends enumeration client request message.
- *
- * @dev: the device structure
- *
- * returns none.
- */
-void heci_hbm_enum_clients_req(struct heci_device *dev)
+/* ishtp_hbm_enum_clients_req - sends enumeration client request message */
+void ishtp_hbm_enum_clients_req(struct ishtp_device *dev)
 {
-	struct heci_msg_hdr hdr;
+	struct ishtp_msg_hdr hdr;
 	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct ishtp_msg_hdr *ishtp_hdr = &hdr;
 	struct hbm_host_enum_request *enum_req;
 	const size_t len = sizeof(struct hbm_host_enum_request);
 	/* enumerate clients */
-	heci_hbm_hdr(heci_hdr, len);
+	ishtp_hbm_hdr(ishtp_hdr, len);
 
 	enum_req = (struct hbm_host_enum_request *)data;
 	memset(enum_req, 0, len);
 	enum_req->hbm_cmd = HOST_ENUM_REQ_CMD;
 
-	if (heci_write_message(dev, heci_hdr, data)) {
-		dev->dev_state = HECI_DEV_RESETTING;
-		dev_err(&dev->pdev->dev, "enumeration request write failed.\n");
-		heci_reset(dev, 1);
+	if (ishtp_write_message(dev, ishtp_hdr, data)) {
+		dev->dev_state = ISHTP_DEV_RESETTING;
+		dev_err(dev->devc, "enumeration request send failed\n");
+		ish_hw_reset(dev);
 	}
-	dev->hbm_state = HECI_HBM_ENUM_CLIENTS;
+	dev->hbm_state = ISHTP_HBM_ENUM_CLIENTS;
 	return;
 }
 
-/**
- * heci_hbm_prop_requsest - request property for a single client
- *
- * @dev: the device structure
- *
- * returns none.
- */
-
-static int heci_hbm_prop_req(struct heci_device *dev)
+/* ishtp_hbm_prop_requsest - request property for a single client */
+static int ishtp_hbm_prop_req(struct ishtp_device *dev)
 {
 
-	struct heci_msg_hdr hdr;
+	struct ishtp_msg_hdr hdr;
 	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct ishtp_msg_hdr *ishtp_hdr = &hdr;
 	struct hbm_props_request *prop_req;
 	const size_t len = sizeof(struct hbm_props_request);
 	unsigned long next_client_index;
-	u8 client_num;
+	uint8_t client_num;
 
-	client_num = dev->me_client_presentation_num;
+	client_num = dev->fw_client_presentation_num;
 
-	next_client_index = find_next_bit(dev->me_clients_map, HECI_CLIENTS_MAX,
-		dev->me_client_index);
+	next_client_index = find_next_bit(dev->fw_clients_map,
+		ISHTP_CLIENTS_MAX, dev->fw_client_index);
 
 	/* We got all client properties */
-	if (next_client_index == HECI_CLIENTS_MAX) {
-		dev->hbm_state = HECI_HBM_WORKING;
-		dev->dev_state = HECI_DEV_ENABLED;
+	if (next_client_index == ISHTP_CLIENTS_MAX) {
+		dev->hbm_state = ISHTP_HBM_WORKING;
+		dev->dev_state = ISHTP_DEV_ENABLED;
 
-		for (dev->me_client_presentation_num = 1;
-			dev->me_client_presentation_num < client_num + 1;
-				++dev->me_client_presentation_num)
+		for (dev->fw_client_presentation_num = 1;
+			dev->fw_client_presentation_num < client_num + 1;
+				++dev->fw_client_presentation_num)
 			/* Add new client device */
-			heci_bus_new_client(dev);
+			ishtp_bus_new_client(dev);
 		return 0;
 	}
 
-	dev->me_clients[client_num].client_id = next_client_index;
+	dev->fw_clients[client_num].client_id = next_client_index;
+
 
-#ifndef DEBUG_FW_BOOT_SEQ
-	heci_hbm_hdr(heci_hdr, len);
+	ishtp_hbm_hdr(ishtp_hdr, len);
 	prop_req = (struct hbm_props_request *)data;
 
 	memset(prop_req, 0, sizeof(struct hbm_props_request));
@@ -279,69 +207,51 @@ static int heci_hbm_prop_req(struct heci_device *dev)
 	prop_req->hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;
 	prop_req->address = next_client_index;
 
-	if (heci_write_message(dev, heci_hdr, data)) {
-		dev->dev_state = HECI_DEV_RESETTING;
-		dev_err(&dev->pdev->dev, "properties request write failed\n");
-		heci_reset(dev, 1);
+	if (ishtp_write_message(dev, ishtp_hdr, data)) {
+		dev->dev_state = ISHTP_DEV_RESETTING;
+		dev_err(dev->devc, "properties request send failed\n");
+		ish_hw_reset(dev);
 		return -EIO;
 	}
-#endif /*DEBUG_FW_BOOT_SEQ*/
 
-	dev->me_client_index = next_client_index;
-
-#ifdef DEBUG_FW_BOOT_SEQ
-	heci_hbm_dispatch(dev,
-		(struct heci_bus_message *)static_fw_cl_props[client_num]);
-#endif /*DEBUG_FW_BOOT_SEQ*/
+	dev->fw_client_index = next_client_index;
 
 	return 0;
 }
 
-/**
- * heci_hbm_stop_req_prepare - perpare stop request message
- *
- * @dev - heci device
- * @heci_hdr - heci message header
- * @data - hbm message body buffer
- */
-static void heci_hbm_stop_req_prepare(struct heci_device *dev,
-	struct heci_msg_hdr *heci_hdr, unsigned char *data)
+/* ishtp_hbm_stop_req - send stop request message */
+static void ishtp_hbm_stop_req(struct ishtp_device *dev)
 {
-	struct hbm_host_stop_request *req =
-		(struct hbm_host_stop_request *)data;
+	struct ishtp_msg_hdr hdr;
+	unsigned char data[128];
+	struct ishtp_msg_hdr *ishtp_hdr = &hdr;
+	struct hbm_host_stop_request *req;
 	const size_t len = sizeof(struct hbm_host_stop_request);
 
-	heci_hbm_hdr(heci_hdr, len);
+	ishtp_hbm_hdr(ishtp_hdr, len);
+	req = (struct hbm_host_stop_request *)data;
 
-	memset(req, 0, len);
+	memset(req, 0, sizeof(struct hbm_host_stop_request));
 	req->hbm_cmd = HOST_STOP_REQ_CMD;
 	req->reason = DRIVER_STOP_REQUEST;
+
+	ishtp_write_message(dev, ishtp_hdr, data);
 }
 
-/**
- * heci_hbm_cl_flow_control_req - sends flow control requst.
- *
- * @dev: the device structure
- * @cl: client info
- *
- * This function returns -EIO on write failure
- */
-int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
+/* ishtp_hbm_cl_flow_control_req - sends flow control requst */
+int ishtp_hbm_cl_flow_control_req(struct ishtp_device *dev, struct ishtp_cl *cl)
 {
-	struct heci_msg_hdr hdr;
+	struct ishtp_msg_hdr hdr;
 	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct ishtp_msg_hdr *ishtp_hdr = &hdr;
 	const size_t len = sizeof(struct hbm_flow_control);
 	int	rv;
 	unsigned	num_frags;
 	unsigned long	flags;
 
 	spin_lock_irqsave(&cl->fc_spinlock, flags);
-	heci_hbm_hdr(heci_hdr, len);
-	heci_hbm_cl_hdr(cl, HECI_FLOW_CONTROL_CMD, data, len);
-
-	dev_dbg(&dev->pdev->dev, "sending flow control host client = %d, ME client = %d\n",
-		cl->host_client_id, cl->me_client_id);
+	ishtp_hbm_hdr(ishtp_hdr, len);
+	ishtp_hbm_cl_hdr(cl, ISHTP_FLOW_CONTROL_CMD, data, len);
 
 	/* Sync possible race when RB recycle and packet receive paths
 	   both try to send an out FC */
@@ -353,7 +263,7 @@ int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
 	num_frags = cl->recv_msg_num_frags;
 	cl->recv_msg_num_frags = 0;
 
-	rv = heci_write_message(dev, heci_hdr, data);
+	rv = ishtp_write_message(dev, ishtp_hdr, data);
 	if (!rv) {
 		struct timeval	tv;
 
@@ -372,8 +282,8 @@ int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
 				--s;
 			}
 			if (s > cl->max_fc_delay_sec ||
-					s == cl->max_fc_delay_sec &&
-					us > cl->max_fc_delay_usec) {
+					(s == cl->max_fc_delay_sec &&
+					us > cl->max_fc_delay_usec)) {
 				cl->max_fc_delay_sec = s;
 				cl->max_fc_delay_usec = us;
 			}
@@ -385,54 +295,37 @@ int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
 	spin_unlock_irqrestore(&cl->fc_spinlock, flags);
 	return	rv;
 }
-EXPORT_SYMBOL(heci_hbm_cl_flow_control_req);
+EXPORT_SYMBOL(ishtp_hbm_cl_flow_control_req);
 
-/*
- * heci_hbm_cl_disconnect_req - sends disconnect message to fw.
- *
- * @dev: the device structure
- * @cl: a client to disconnect from
- *
- * This function returns -EIO on write failure
- */
-int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl)
+/* ishtp_hbm_cl_disconnect_req - sends disconnect message to fw */
+int ishtp_hbm_cl_disconnect_req(struct ishtp_device *dev, struct ishtp_cl *cl)
 {
-	struct heci_msg_hdr hdr;
+	struct ishtp_msg_hdr hdr;
 	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct ishtp_msg_hdr *ishtp_hdr = &hdr;
 	const size_t len = sizeof(struct hbm_client_connect_request);
 
-	heci_hbm_hdr(heci_hdr, len);
-	heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_REQ_CMD, data, len);
+	ishtp_hbm_hdr(ishtp_hdr, len);
+	ishtp_hbm_cl_hdr(cl, CLIENT_DISCONNECT_REQ_CMD, data, len);
 
-	return heci_write_message(dev, heci_hdr, data);
+	return ishtp_write_message(dev, ishtp_hdr, data);
 }
 
 /*
- * heci_hbm_cl_disconnect_res - disconnect response from ME
+ * ishtp_hbm_cl_disconnect_res - disconnect response from FW
  *
- * @dev: the device structure
  * @rs: disconnect response bus message
  */
-static void heci_hbm_cl_disconnect_res(struct heci_device *dev,
+static void ishtp_hbm_cl_disconnect_res(struct ishtp_device *dev,
 	struct hbm_client_connect_response *rs)
 {
-	struct heci_cl *cl = NULL, *next = NULL;
+	struct ishtp_cl *cl = NULL, *next = NULL;
 	unsigned long	flags;
 
-	dev_dbg(&dev->pdev->dev,
-			"disconnect_response:\n"
-			"ME Client = %d\n"
-			"Host Client = %d\n"
-			"Status = %d\n",
-			rs->me_addr,
-			rs->host_addr,
-			rs->status);
-
 	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (!rs->status && heci_hbm_cl_addr_equal(cl, rs)) {
-			cl->state = HECI_CL_DISCONNECTED;
+		if (!rs->status && ishtp_hbm_cl_addr_equal(cl, rs)) {
+			cl->state = ISHTP_CL_DISCONNECTED;
 			break;
 		}
 	}
@@ -441,57 +334,40 @@ static void heci_hbm_cl_disconnect_res(struct heci_device *dev,
 	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
-/**
- * heci_hbm_cl_connect_req - send connection request to specific me client
- *
- * @dev: the device structure
- * @cl: a client to connect to
- *
- * returns -EIO on write failure
- */
-int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl)
+/* ishtp_hbm_cl_connect_req - send connection request to specific fw client */
+int ishtp_hbm_cl_connect_req(struct ishtp_device *dev, struct ishtp_cl *cl)
 {
-	struct heci_msg_hdr hdr;
+	struct ishtp_msg_hdr hdr;
 	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct ishtp_msg_hdr *ishtp_hdr = &hdr;
 	const size_t len = sizeof(struct hbm_client_connect_request);
 
-	heci_hbm_hdr(heci_hdr, len);
-	heci_hbm_cl_hdr(cl, CLIENT_CONNECT_REQ_CMD, data, len);
+	ishtp_hbm_hdr(ishtp_hdr, len);
+	ishtp_hbm_cl_hdr(cl, CLIENT_CONNECT_REQ_CMD, data, len);
 
-	return heci_write_message(dev, heci_hdr,  data);
+	return ishtp_write_message(dev, ishtp_hdr, data);
 }
-EXPORT_SYMBOL(heci_hbm_cl_connect_req);
+EXPORT_SYMBOL(ishtp_hbm_cl_connect_req);
 
 /**
- * heci_hbm_cl_connect_res - connect resposne from the ME
+ * ishtp_hbm_cl_connect_res - connect resposne from the FW
  *
- * @dev: the device structure
  * @rs: connect response bus message
  */
-static void heci_hbm_cl_connect_res(struct heci_device *dev,
+static void ishtp_hbm_cl_connect_res(struct ishtp_device *dev,
 	struct hbm_client_connect_response *rs)
 {
-	struct heci_cl *cl = NULL, *next = NULL;
+	struct ishtp_cl *cl = NULL, *next = NULL;
 	unsigned long	flags;
 
-	dev_dbg(&dev->pdev->dev,
-			"connect_response:\n"
-			"ME Client = %d\n"
-			"Host Client = %d\n"
-			"Status = %d\n",
-			rs->me_addr,
-			rs->host_addr,
-			rs->status);
-
 	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (heci_hbm_cl_addr_equal(cl, rs)) {
+		if (ishtp_hbm_cl_addr_equal(cl, rs)) {
 			if (!rs->status) {
-				cl->state = HECI_CL_CONNECTED;
+				cl->state = ISHTP_CL_CONNECTED;
 				cl->status = 0;
 			} else {
-				cl->state = HECI_CL_DISCONNECTED;
+				cl->state = ISHTP_CL_DISCONNECTED;
 				cl->status = -ENODEV;
 			}
 			break;
@@ -502,212 +378,296 @@ static void heci_hbm_cl_connect_res(struct heci_device *dev,
 	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
-
 /**
- * heci_client_disconnect_request - disconnect request initiated by me
- *  host sends disoconnect response
+ * ishtp_client_disconnect_request - disconnect request initiated by fw
+ * host sends disconnect response
  *
  * @dev: the device structure.
- * @disconnect_req: disconnect request bus message from the me
+ * @disconnect_req: disconnect request bus message from the fw
  */
-static void heci_hbm_fw_disconnect_req(struct heci_device *dev,
+static void ishtp_hbm_fw_disconnect_req(struct ishtp_device *dev,
 	struct hbm_client_connect_request *disconnect_req)
 {
-	struct heci_cl *cl, *next;
+	struct ishtp_cl *cl, *next;
 	const size_t len = sizeof(struct hbm_client_connect_response);
 	unsigned long	flags;
-	struct heci_msg_hdr hdr;
+	struct ishtp_msg_hdr hdr;
 	unsigned char data[4];	/* All HBM messages are 4 bytes */
 
 	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (heci_hbm_cl_addr_equal(cl, disconnect_req)) {
-			cl->state = HECI_CL_DISCONNECTED;
+		if (ishtp_hbm_cl_addr_equal(cl, disconnect_req)) {
+			cl->state = ISHTP_CL_DISCONNECTED;
 
-			/* prepare disconnect response */
-			heci_hbm_hdr(&hdr, len);
-			heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_RES_CMD, data,
+			/* send disconnect response */
+			ishtp_hbm_hdr(&hdr, len);
+			ishtp_hbm_cl_hdr(cl, CLIENT_DISCONNECT_RES_CMD, data,
 				len);
-			heci_write_message(dev, &hdr, data);
+			ishtp_write_message(dev, &hdr, data);
 			break;
 		}
 	}
 	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
-
 /*
- * heci_hbm_dma_xfer_ack - receive ack for HECI-over-DMA client message
+ * get_dma_send_buf - find and return free address of "size" bytes
+ * in dma tx buffer.
+ * the function will mark this address as "in-used" memory
  *
- * Constraint:
- * First implementation is one HECI message per DMA transfer
+ * returns NULL when no free buffer is available
  */
-void heci_hbm_dma_xfer_ack(struct heci_device *dev,
-	struct dma_xfer_hbm *dma_xfer)
+void *get_dma_send_buf(struct ishtp_device *dev, uint32_t size)
 {
+	unsigned long	flags;
+	int i, j, free;
+	/* additional slot is needed if there is rem */
+	int required_slots = (size / DMA_SLOT_SIZE)
+		+ 1 * (size % DMA_SLOT_SIZE != 0);
+
+	spin_lock_irqsave(&dma_tx_lock, flags);
+	for (i = 0; i <= (dma_num_slots - required_slots); i++) {
+		free = 1;
+		for (j = 0; j < required_slots; j++)
+			if (dma_tx_map[i+j]) {
+				free = 0;
+				i += j;
+				break;
+			}
+		if (free) {
+			/* mark memory as "caught" */
+			for (j = 0; j < required_slots; j++)
+				dma_tx_map[i+j] = 1;
+			spin_unlock_irqrestore(&dma_tx_lock, flags);
+			return (i * DMA_SLOT_SIZE) +
+				(unsigned char *)host_dma_tx_buf;
+		}
+	}
+	spin_unlock_irqrestore(&dma_tx_lock, flags);
+	dev_err(dev->devc, "No free DMA buffer to send msg\n");
+	return NULL;
 }
 
+/*
+ * release_dma_acked_mem - returnes the acked memory to free list.
+ * (from msg_addr, size bytes long)
+ */
+void release_dma_acked_mem(struct ishtp_device *dev, void *msg_addr, uint32_t size)
+{
+	unsigned long	flags;
+	int acked_slots = (size / DMA_SLOT_SIZE)
+		+ 1 * (size % DMA_SLOT_SIZE != 0);
+	int i, j;
+
+	if ((msg_addr - host_dma_tx_buf) % DMA_SLOT_SIZE) {
+		dev_err(dev->devc, "Bad DMA Tx ack address\n");
+		return;
+	}
+
+	i = (msg_addr - host_dma_tx_buf) / DMA_SLOT_SIZE;
+	spin_lock_irqsave(&dma_tx_lock, flags);
+	for (j = 0; j < acked_slots; j++) {
+		if ((i + j) >= dma_num_slots || !dma_tx_map[i+j]) {
+			/* no such slot, or memory is already free */
+			spin_unlock_irqrestore(&dma_tx_lock, flags);
+			dev_err(dev->devc, "Bad DMA Tx ack address\n");
+			return;
+		}
+		dma_tx_map[i+j] = 0;
+	}
+	spin_unlock_irqrestore(&dma_tx_lock, flags);
+}
 
 /*
- * heci_hbm_dma_xfer - receive HECI-over-DMA client message
+ * ishtp_hbm_dma_xfer_ack - receive ack for ISHTP-over-DMA client message
+ *
+ * Constraint:
+ * First implementation is one ISHTP message per DMA transfer
  */
-void heci_hbm_dma_xfer(struct heci_device *dev, struct dma_xfer_hbm *dma_xfer)
+void ishtp_hbm_dma_xfer_ack(struct ishtp_device *dev,
+	struct dma_xfer_hbm *dma_xfer)
 {
-	void    *msg;
+	void	*msg;
 	uint64_t	offs;
-	struct heci_msg_hdr hdr;
-	struct heci_msg_hdr	*heci_hdr = (struct heci_msg_hdr *) &dev->heci_msg_hdr;
+	struct ishtp_msg_hdr	*ishtp_hdr =
+		(struct ishtp_msg_hdr *)&dev->ishtp_msg_hdr;
+	unsigned	msg_offs;
+	struct ishtp_cl *cl, *next;
+
+	for (msg_offs = 0; msg_offs < ishtp_hdr->length;
+		msg_offs += sizeof(struct dma_xfer_hbm)) {
+		offs = dma_xfer->msg_addr - host_dma_tx_buf_phys;
+		if (offs > host_dma_tx_buf_size) {
+			dev_err(dev->devc, "Bad DMA Tx ack message address\n");
+			return;
+		}
+		if (dma_xfer->msg_length > host_dma_tx_buf_size - offs) {
+			dev_err(dev->devc, "Bad DMA Tx ack message size\n");
+			return;
+		}
+
+		/* logical address of the acked mem */
+		msg = (unsigned char *)host_dma_tx_buf + offs;
+		release_dma_acked_mem(dev, msg, dma_xfer->msg_length);
+
+		list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+			if (cl->fw_client_id == dma_xfer->fw_client_id &&
+					cl->host_client_id ==
+						dma_xfer->host_client_id)
+				/* in case that a single ack may be sent
+				over several dma transfers, and the last msg
+				addr was inside the acked memory, but not in
+				its start */
+				if (cl->last_dma_addr >= (unsigned char *)msg &&
+						cl->last_dma_addr <
+						(unsigned char *)msg +
+						dma_xfer->msg_length) {
+					cl->last_dma_acked = 1;
+
+					if (!list_empty(&cl->tx_list.list) &&
+						cl->ishtp_flow_ctrl_creds) {
+						/*
+						 * start sending the first msg
+						 */
+						ishtp_cl_send_msg(dev, cl);
+					}
+				}
+		}
+		++dma_xfer;
+	}
+}
+
+/* ishtp_hbm_dma_xfer - receive ISHTP-over-DMA client message */
+void ishtp_hbm_dma_xfer(struct ishtp_device *dev, struct dma_xfer_hbm *dma_xfer)
+{
+	void	*msg;
+	uint64_t	offs;
+	struct ishtp_msg_hdr	hdr;
+	struct ishtp_msg_hdr	*ishtp_hdr =
+		(struct ishtp_msg_hdr *) &dev->ishtp_msg_hdr;
 	struct dma_xfer_hbm	*prm = dma_xfer;
 	unsigned	msg_offs;
 
-	for (msg_offs = 0; msg_offs < heci_hdr->length;
+	for (msg_offs = 0; msg_offs < ishtp_hdr->length;
 		msg_offs += sizeof(struct dma_xfer_hbm)) {
 
 		offs = dma_xfer->msg_addr - host_dma_rx_buf_phys;
 		if (offs > host_dma_rx_buf_size) {
-			dev_err(&dev->pdev->dev, "Bad DMA Rx message address\n");
+			dev_err(dev->devc, "Bad DMA Rx message address\n");
 			return;
 		}
 		if (dma_xfer->msg_length > host_dma_rx_buf_size - offs) {
-			dev_err(&dev->pdev->dev, "Bad DMA Rx message size\n");
+			dev_err(dev->devc, "Bad DMA Rx message size\n");
 			return;
 		}
 		msg = host_dma_rx_buf + offs;
-		recv_heci_cl_msg_dma(dev, msg, dma_xfer);
-		dma_xfer->hbm = DMA_XFER_ACK;   /* Prepare for response */
+		recv_ishtp_cl_msg_dma(dev, msg, dma_xfer);
+		dma_xfer->hbm = DMA_XFER_ACK;	/* Prepare for response */
 		++dma_xfer;
 	}
 
 	/* Send DMA_XFER_ACK [...] */
-	heci_hbm_hdr(&hdr, heci_hdr->length);
-	heci_write_message(dev, &hdr, (unsigned char *)prm);
+	ishtp_hbm_hdr(&hdr, ishtp_hdr->length);
+	ishtp_write_message(dev, &hdr, (unsigned char *)prm);
 }
 
-
 /**
- * heci_hbm_dispatch - bottom half read routine after ISR to
+ * ishtp_hbm_dispatch - bottom half read routine after ISR to
  * handle the read bus message cmd processing.
- *
- * @dev: the device structure
- * @hdr: header of bus message
  */
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
+void ishtp_hbm_dispatch(struct ishtp_device *dev, struct ishtp_bus_message *hdr)
 {
-	struct heci_bus_message *heci_msg;
-	struct heci_me_client *me_client;
+	struct ishtp_bus_message *ishtp_msg;
+	struct ishtp_fw_client *fw_client;
 	struct hbm_host_version_response *version_res;
 	struct hbm_client_connect_response *connect_res;
 	struct hbm_client_connect_response *disconnect_res;
 	struct hbm_client_connect_request *disconnect_req;
 	struct hbm_props_response *props_res;
 	struct hbm_host_enum_response *enum_res;
-	struct heci_msg_hdr heci_hdr;
-	unsigned char data[4];	/* All HBM messages are 4 bytes */
-	struct dma_alloc_notify   dma_alloc_notify;
-	struct dma_xfer_hbm     *dma_xfer;
+	struct ishtp_msg_hdr ishtp_hdr;
+	struct dma_alloc_notify	dma_alloc_notify;
+	struct dma_xfer_hbm	*dma_xfer;
 
-	heci_msg = hdr;
-	dev_dbg(&dev->pdev->dev, "bus cmd = %lu\n", heci_msg->hbm_cmd);
+	ishtp_msg = hdr;
 
-	switch (heci_msg->hbm_cmd) {
+	switch (ishtp_msg->hbm_cmd) {
 	case HOST_START_RES_CMD:
-		version_res = (struct hbm_host_version_response *)heci_msg;
+		version_res = (struct hbm_host_version_response *)ishtp_msg;
 		if (!version_res->host_version_supported) {
-			dev->version = version_res->me_max_version;
-			dev_dbg(&dev->pdev->dev, "version mismatch.\n");
+			dev->version = version_res->fw_max_version;
 
-			dev->hbm_state = HECI_HBM_STOPPED;
-			heci_hbm_stop_req_prepare(dev, &heci_hdr, data);
-			heci_write_message(dev, &heci_hdr, data);
+			dev->hbm_state = ISHTP_HBM_STOPPED;
+			ishtp_hbm_stop_req(dev);
 			return;
 		}
 
 		dev->version.major_version = HBM_MAJOR_VERSION;
 		dev->version.minor_version = HBM_MINOR_VERSION;
-		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
-		    dev->hbm_state == HECI_HBM_START) {
-			dev->hbm_state = HECI_HBM_STARTED;
-			heci_hbm_enum_clients_req(dev);
+		if (dev->dev_state == ISHTP_DEV_INIT_CLIENTS &&
+				dev->hbm_state == ISHTP_HBM_START) {
+			dev->hbm_state = ISHTP_HBM_STARTED;
+			ishtp_hbm_enum_clients_req(dev);
 		} else {
-			dev_err(&dev->pdev->dev, "reset: wrong host start response\n");
+			dev_err(dev->devc, "reset: wrong host start response\n");
 			/* BUG: why do we arrive here? */
-			heci_reset(dev, 1);
+			ish_hw_reset(dev);
 			return;
 		}
 
 		wake_up(&dev->wait_hbm_recvd_msg);
-		dev_dbg(&dev->pdev->dev, "host start response message received.\n");
 		break;
 
 	case CLIENT_CONNECT_RES_CMD:
-		connect_res = (struct hbm_client_connect_response *)heci_msg;
-		heci_hbm_cl_connect_res(dev, connect_res);
-		dev_dbg(&dev->pdev->dev, "client connect response message received.\n");
+		connect_res = (struct hbm_client_connect_response *)ishtp_msg;
+		ishtp_hbm_cl_connect_res(dev, connect_res);
 		break;
 
 	case CLIENT_DISCONNECT_RES_CMD:
-		disconnect_res = (struct hbm_client_connect_response *)heci_msg;
-		heci_hbm_cl_disconnect_res(dev, disconnect_res);
-		dev_dbg(&dev->pdev->dev, "client disconnect response message received.\n");
+		disconnect_res =
+			(struct hbm_client_connect_response *)ishtp_msg;
+		ishtp_hbm_cl_disconnect_res(dev, disconnect_res);
 		break;
 
 	case HOST_CLIENT_PROPERTIES_RES_CMD:
-		props_res = (struct hbm_props_response *)heci_msg;
-		me_client = &dev->me_clients[dev->me_client_presentation_num];
-
-#ifdef DUMP_CL_PROP
-		/* DEBUG -- dump complete response */
-		do {
-			int	i;
-
-			dev->print_log(dev,
-				"%s(): HOST_CLIENT_PROPERTIES_RES_CMD, client# = %d props: ",
-				__func__, dev->me_client_presentation_num);
-			for (i = 0; i < sizeof(struct hbm_props_response); ++i)
-				dev->print_log(dev, "%02X ",
-					*(((unsigned char *)props_res) + i));
-			dev->print_log(dev, "\n");
-		} while (0);
-#endif /*DUMP_CL_PROP*/
-
-		if (props_res->status || !dev->me_clients) {
-			dev_err(&dev->pdev->dev, "reset: properties response hbm wrong status.\n");
-			heci_reset(dev, 1);
+		props_res = (struct hbm_props_response *)ishtp_msg;
+		fw_client = &dev->fw_clients[dev->fw_client_presentation_num];
+
+		if (props_res->status || !dev->fw_clients) {
+			dev_err(dev->devc, "reset: properties response hbm "
+				"wrong status\n");
+			ish_hw_reset(dev);
 			return;
 		}
 
-		if (me_client->client_id != props_res->address) {
-			dev_err(&dev->pdev->dev,
-"reset: host properties response address mismatch [%02X %02X]\n",
-				me_client->client_id, props_res->address);
-			heci_reset(dev, 1);
+		if (fw_client->client_id != props_res->address) {
+			dev_err(dev->devc,
+				"reset: host properties response address "
+				"mismatch [%02X %02X]\n",
+				fw_client->client_id, props_res->address);
+			ish_hw_reset(dev);
 			return;
 		}
 
-		if (dev->dev_state != HECI_DEV_INIT_CLIENTS ||
-		    dev->hbm_state != HECI_HBM_CLIENT_PROPERTIES) {
-			dev_err(&dev->pdev->dev,
+		if (dev->dev_state != ISHTP_DEV_INIT_CLIENTS ||
+			dev->hbm_state != ISHTP_HBM_CLIENT_PROPERTIES) {
+			dev_err(dev->devc,
 				"reset: unexpected properties response\n");
-			heci_reset(dev, 1);
+			ish_hw_reset(dev);
 			return;
 		}
 
-		me_client->props = props_res->client_properties;
-		dev->me_client_index++;
-		dev->me_client_presentation_num++;
-
-#if 0
-		/* Add new client device */
-		heci_bus_new_client(dev);
-#endif
+		fw_client->props = props_res->client_properties;
+		dev->fw_client_index++;
+		dev->fw_client_presentation_num++;
 
 		/* request property for the next client */
-		heci_hbm_prop_req(dev);
+		ishtp_hbm_prop_req(dev);
 
-		if (dev->dev_state != HECI_DEV_ENABLED)
+		if (dev->dev_state != ISHTP_DEV_ENABLED)
 			break;
 
-		heci_cl_alloc_dma_buf();
+		ishtp_cl_alloc_dma_buf();
 		if (host_dma_rx_buf) {
 			const size_t len = sizeof(dma_alloc_notify);
 
@@ -715,60 +675,51 @@ void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
 			dma_alloc_notify.hbm = DMA_BUFFER_ALLOC_NOTIFY;
 			dma_alloc_notify.buf_size = host_dma_rx_buf_size;
 			dma_alloc_notify.buf_address = host_dma_rx_buf_phys;
-			heci_hbm_hdr(&heci_hdr, len);
-			heci_write_message(dev, &heci_hdr,
+			ishtp_hbm_hdr(&ishtp_hdr, len);
+			ishtp_write_message(dev, &ishtp_hdr,
 				(unsigned char *)&dma_alloc_notify);
 		}
 
 		break;
 
 	case HOST_ENUM_RES_CMD:
-		enum_res = (struct hbm_host_enum_response *) heci_msg;
-		memcpy(dev->me_clients_map, enum_res->valid_addresses, 32);
-		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
-		    dev->hbm_state == HECI_HBM_ENUM_CLIENTS) {
-				dev->me_client_presentation_num = 0;
-				dev->me_client_index = 0;
+		enum_res = (struct hbm_host_enum_response *) ishtp_msg;
+		memcpy(dev->fw_clients_map, enum_res->valid_addresses, 32);
+		if (dev->dev_state == ISHTP_DEV_INIT_CLIENTS &&
+			dev->hbm_state == ISHTP_HBM_ENUM_CLIENTS) {
+				dev->fw_client_presentation_num = 0;
+				dev->fw_client_index = 0;
 
-				heci_hbm_me_cl_allocate(dev);
-				dev->hbm_state = HECI_HBM_CLIENT_PROPERTIES;
+				ishtp_hbm_fw_cl_allocate(dev);
+				dev->hbm_state = ISHTP_HBM_CLIENT_PROPERTIES;
 
 				/* first property request */
-				heci_hbm_prop_req(dev);
+				ishtp_hbm_prop_req(dev);
 		} else {
-			dev_err(&dev->pdev->dev, "reset: unexpected enumeration response hbm.\n");
-			heci_reset(dev, 1);
+			dev_err(dev->devc,
+				"reset: unexpected enumeration response hbm\n");
+			ish_hw_reset(dev);
 			return;
 		}
 		break;
 
 	case HOST_STOP_RES_CMD:
-		if (dev->hbm_state != HECI_HBM_STOPPED)
-			dev_err(&dev->pdev->dev, "unexpected stop response.\n");
+		if (dev->hbm_state != ISHTP_HBM_STOPPED)
+			dev_err(dev->devc, "unexpected stop response\n");
 
-		dev->dev_state = HECI_DEV_DISABLED;
-		dev_info(&dev->pdev->dev, "reset: FW stop response.\n");
-		heci_reset(dev, 1);
+		dev->dev_state = ISHTP_DEV_DISABLED;
+		dev_info(dev->devc, "reset: FW stop response\n");
+		ish_hw_reset(dev);
 		break;
 
 	case CLIENT_DISCONNECT_REQ_CMD:
 		/* search for client */
-		disconnect_req = (struct hbm_client_connect_request *)heci_msg;
-		heci_hbm_fw_disconnect_req(dev, disconnect_req);
-		break;
-
-	case ME_STOP_REQ_CMD:
-		dev->hbm_state = HECI_HBM_STOPPED;
+		disconnect_req = (struct hbm_client_connect_request *)ishtp_msg;
+		ishtp_hbm_fw_disconnect_req(dev, disconnect_req);
 		break;
 
-	case CLIENT_DMA_RES_CMD:
-		/*
-		 * TODO: wake up anybody who could be
-		 * waiting for DMA completion
-		 */
-		dma_ready = 1;
-		if (waitqueue_active(&dev->wait_dma_ready))
-			wake_up(&dev->wait_dma_ready);
+	case FW_STOP_REQ_CMD:
+		dev->hbm_state = ISHTP_HBM_STOPPED;
 		break;
 
 	case DMA_BUFFER_ALLOC_RESPONSE:
@@ -776,106 +727,122 @@ void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
 		break;
 
 	case DMA_XFER:
-		dma_xfer = (struct dma_xfer_hbm *)heci_msg;
+		dma_xfer = (struct dma_xfer_hbm *)ishtp_msg;
 		if (!host_dma_enabled) {
-			dev_err(&dev->pdev->dev,
+			dev_err(dev->devc,
 				"DMA XFER requested but DMA is not enabled\n");
 			break;
 		}
-		heci_hbm_dma_xfer(dev, dma_xfer);
+		ishtp_hbm_dma_xfer(dev, dma_xfer);
 		break;
 
 	case DMA_XFER_ACK:
-		dma_xfer = (struct dma_xfer_hbm *)heci_msg;
+		dma_xfer = (struct dma_xfer_hbm *)ishtp_msg;
 		if (!host_dma_enabled || !host_dma_tx_buf) {
-			dev_err(&dev->pdev->dev,
-				"DMA XFER acknowledged but DMA Tx\n"
-				"is not enabled\n");
+			dev_err(dev->devc,
+				"DMA XFER acked but DMA Tx is not enabled\n");
 			break;
 		}
-		heci_hbm_dma_xfer_ack(dev, dma_xfer);
+		ishtp_hbm_dma_xfer_ack(dev, dma_xfer);
 		break;
 
 	default:
 		/*BUG();*/
-		dev_err(&dev->pdev->dev, "unknown HBM: %u\n",
-			(unsigned)heci_msg->hbm_cmd);
+		dev_err(dev->devc, "unknown HBM: %u\n",
+			(unsigned)ishtp_msg->hbm_cmd);
+
 		break;
 	}
 }
-EXPORT_SYMBOL(heci_hbm_dispatch);
 
+/*
+ * BH processing work function (instead of thread handler)
+ * for processing hbm messages
+ */
+void	bh_hbm_work_fn(struct work_struct *work)
+{
+	unsigned long	flags;
+	struct ishtp_device	*dev;
+	unsigned char	hbm[IPC_PAYLOAD_SIZE];
+
+	dev = container_of(work, struct ishtp_device, bh_hbm_work);
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	if (dev->rd_msg_fifo_head != dev->rd_msg_fifo_tail) {
+		memcpy(hbm, dev->rd_msg_fifo + dev->rd_msg_fifo_head,
+			IPC_PAYLOAD_SIZE);
+		dev->rd_msg_fifo_head =
+			(dev->rd_msg_fifo_head + IPC_PAYLOAD_SIZE) %
+			(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+		ishtp_hbm_dispatch(dev, (struct ishtp_bus_message *)hbm);
+	} else {
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+	}
+}
 
 /*
- *	Receive and process HECI bus messages
+ *	Receive and process ISHTP bus messages
  *
  *	(!) ISR context
  */
-void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+void	recv_hbm(struct ishtp_device *dev, struct ishtp_msg_hdr *ishtp_hdr)
 {
-	uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
-	struct heci_bus_message	*heci_msg =
-		(struct heci_bus_message *)rd_msg_buf;
+	uint8_t	rd_msg_buf[ISHTP_RD_MSG_BUF_SIZE];
+	struct ishtp_bus_message	*ishtp_msg =
+		(struct ishtp_bus_message *)rd_msg_buf;
 	unsigned long	flags;
 
-	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
+	dev->ops->ishtp_read(dev, rd_msg_buf, ishtp_hdr->length);
 
 	/* Flow control - handle in place */
-	if (heci_msg->hbm_cmd == HECI_FLOW_CONTROL_CMD) {
+	if (ishtp_msg->hbm_cmd == ISHTP_FLOW_CONTROL_CMD) {
 		struct hbm_flow_control *flow_control =
-			(struct hbm_flow_control *)heci_msg;
-		struct heci_cl *cl = NULL;
-		struct heci_cl *next = NULL;
+			(struct hbm_flow_control *)ishtp_msg;
+		struct ishtp_cl *cl = NULL;
+		struct ishtp_cl *next = NULL;
 		unsigned long	flags, tx_flags;
 
-		ISH_DBG_PRINT(KERN_ALERT
-			"%s(): HECI_FLOW_CONTROL_CMD, checking to whom (host_addr=%d me_addr=%d\n",
-			__func__, flow_control->host_addr,
-			flow_control->me_addr);
 		spin_lock_irqsave(&dev->cl_list_lock, flags);
 		list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
 			if (cl->host_client_id == flow_control->host_addr &&
-					cl->me_client_id ==
-					flow_control->me_addr) {
-				/*##########################################*/
+					cl->fw_client_id ==
+					flow_control->fw_addr) {
 				/*
-				 * FIXME: It's valid only for counting
+				 * NOTE: It's valid only for counting
 				 * flow-control implementation to receive a
-				 * FC in the middle of sending
+				 * FC in the middle of sending. Meanwhile not
+				 * supported
 				 */
-				if (cl->heci_flow_ctrl_creds)
-					dev_err(&dev->pdev->dev,
-						"recv extra FC from FW client %u (host client %u) (FC count was %u)\n",
-						(unsigned)cl->me_client_id,
+				if (cl->ishtp_flow_ctrl_creds)
+					dev_err(dev->devc,
+						"recv extra FC from FW client "
+						"%u (host client %u) "
+						"(FC count was %u)\n",
+						(unsigned)cl->fw_client_id,
 						(unsigned)cl->host_client_id,
-					(unsigned)cl->heci_flow_ctrl_creds);
+						(unsigned)cl->ishtp_flow_ctrl_creds);
 				else {
-					if (cl->host_client_id == 3 &&
-							cl->me_client_id == 5) {
-						++dev->ipc_hid_in_fc;
-						++dev->ipc_hid_in_fc_cnt;
-					}
-					++cl->heci_flow_ctrl_creds;
-					++cl->heci_flow_ctrl_cnt;
+					++cl->ishtp_flow_ctrl_creds;
+					++cl->ishtp_flow_ctrl_cnt;
+					cl->last_ipc_acked = 1;
 					spin_lock_irqsave(&cl->tx_list_spinlock,
 						tx_flags);
-				if (!list_empty(&cl->tx_list.list)) {
-					/*
-					 * start sending the first msg
-					 *	= the callback function
-					 */
-					spin_unlock_irqrestore(
+					if (!list_empty(&cl->tx_list.list)) {
+						/*
+						 * start sending the first msg
+						 *	= the callback function
+						 */
+						spin_unlock_irqrestore(
 							&cl->tx_list_spinlock,
 							tx_flags);
-					heci_cl_send_msg(dev, cl);
-				} else {
+						ishtp_cl_send_msg(dev, cl);
+					} else {
 						spin_unlock_irqrestore(
 							&cl->tx_list_spinlock,
 							tx_flags);
 					}
 				}
 				break;
-				/*##########################################*/
 			}
 		}
 		spin_unlock_irqrestore(&dev->cl_list_lock, flags);
@@ -886,32 +853,30 @@ void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 	 * Some messages that are safe for ISR processing and important
 	 * to be done "quickly" and in-order, go here
 	 */
-	if (heci_msg->hbm_cmd == CLIENT_CONNECT_RES_CMD ||
-			heci_msg->hbm_cmd == CLIENT_DISCONNECT_RES_CMD ||
-			heci_msg->hbm_cmd == CLIENT_DISCONNECT_REQ_CMD ||
-			heci_msg->hbm_cmd == DMA_XFER) {
-		heci_hbm_dispatch(dev, heci_msg);
+	if (ishtp_msg->hbm_cmd == CLIENT_CONNECT_RES_CMD ||
+			ishtp_msg->hbm_cmd == CLIENT_DISCONNECT_RES_CMD ||
+			ishtp_msg->hbm_cmd == CLIENT_DISCONNECT_REQ_CMD ||
+			ishtp_msg->hbm_cmd == DMA_XFER) {
+		ishtp_hbm_dispatch(dev, ishtp_msg);
 		goto	eoi;
 	}
 
-	/* TODO: revise, may be some don't need BH as well */
 	/*
 	 * All other HBMs go here.
-	 * We schedule HBMs for processing serially,
-	 * possibly there will be multiplpe HBMs scheduled at the same time.
-	 * System wq itself is a serializing means
+	 * We schedule HBMs for processing serially by using system wq,
+	 * possibly there will be multiple HBMs scheduled at the same time.
 	 */
 	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
 	if ((dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %
 			(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE) ==
 			dev->rd_msg_fifo_head) {
 		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-		dev_err(&dev->pdev->dev, "BH buffer overflow, dropping HBM %u\n",
-			(unsigned)heci_msg->hbm_cmd);
+		dev_err(dev->devc, "BH buffer overflow, dropping HBM %u\n",
+			(unsigned)ishtp_msg->hbm_cmd);
 		goto	eoi;
 	}
-	memcpy(dev->rd_msg_fifo + dev->rd_msg_fifo_tail, heci_msg,
-		heci_hdr->length);
+	memcpy(dev->rd_msg_fifo + dev->rd_msg_fifo_tail, ishtp_msg,
+		ishtp_hdr->length);
 	dev->rd_msg_fifo_tail = (dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %
 		(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
 	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
@@ -919,58 +884,56 @@ void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 eoi:
 	return;
 }
-EXPORT_SYMBOL(recv_hbm);
 
 /*
- *      Receive and process HECI fixed client messages
+ * Receive and process ISHTP fixed client messages
  *
- *      (!) ISR context
+ * (!) ISR context
  */
-void recv_fixed_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+void recv_fixed_cl_msg(struct ishtp_device *dev,
+	struct ishtp_msg_hdr *ishtp_hdr)
 {
-	uint8_t rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
+	uint8_t rd_msg_buf[ISHTP_RD_MSG_BUF_SIZE];
 
 	dev->print_log(dev,
 		"%s() got fixed client msg from client #%d\n",
-		__func__, heci_hdr->me_addr);
-	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
-	if (heci_hdr->me_addr == HECI_SYSTEM_STATE_CLIENT_ADDR) {
+		__func__, ishtp_hdr->fw_addr);
+	dev->ops->ishtp_read(dev, rd_msg_buf, ishtp_hdr->length);
+	if (ishtp_hdr->fw_addr == ISHTP_SYSTEM_STATE_CLIENT_ADDR) {
 		struct ish_system_states_header *msg_hdr =
 			(struct ish_system_states_header *)rd_msg_buf;
 		if (msg_hdr->cmd == SYSTEM_STATE_SUBSCRIBE)
-			send_resume(dev);       /* if FW request arrived here,
+			send_resume(dev);	/* if FW request arrived here,
 						the system is not suspended */
 		else
-			dev_err(&dev->pdev->dev,
-				"unknown fixed client msg [%02X]\n",
+			dev_err(dev->devc, "unknown fixed client msg [%02X]\n",
 				msg_hdr->cmd);
 	}
 }
-EXPORT_SYMBOL(recv_fixed_cl_msg);
 
-static inline void fix_cl_hdr(struct heci_msg_hdr *hdr, size_t length,
-	u8 cl_addr)
+static inline void fix_cl_hdr(struct ishtp_msg_hdr *hdr, size_t length,
+	uint8_t cl_addr)
 {
 	hdr->host_addr = 0;
-	hdr->me_addr = cl_addr;
+	hdr->fw_addr = cl_addr;
 	hdr->length = length;
 	hdr->msg_complete = 1;
 	hdr->reserved = 0;
 }
 
-/* Suspend and resume notification*/
+/*** Suspend and resume notification ***/
 
-/*Global var for suspend & resume*/
-u32 current_state = 0;
-u32 supported_states = 0 | SUSPEND_STATE_BIT;
+/* Global var for suspend & resume */
+uint32_t current_state = 0;
+uint32_t supported_states = 0 | SUSPEND_STATE_BIT;
 
-void send_suspend(struct heci_device *dev)
+void send_suspend(struct ishtp_device *dev)
 {
-	struct heci_msg_hdr     heci_hdr;
+	struct ishtp_msg_hdr	ishtp_hdr;
 	struct ish_system_states_status state_status_msg;
 	const size_t len = sizeof(struct ish_system_states_status);
 
-	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
+	fix_cl_hdr(&ishtp_hdr, len, ISHTP_SYSTEM_STATE_CLIENT_ADDR);
 
 	memset(&state_status_msg, 0, len);
 	state_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;
@@ -979,17 +942,18 @@ void send_suspend(struct heci_device *dev)
 	dev->print_log(dev, "%s() sends SUSPEND notification\n", __func__);
 	state_status_msg.states_status = current_state;
 
-	heci_write_message(dev, &heci_hdr, (unsigned char *)&state_status_msg);
+	ishtp_write_message(dev, &ishtp_hdr,
+		(unsigned char *)&state_status_msg);
 }
 EXPORT_SYMBOL(send_suspend);
 
-void send_resume(struct heci_device *dev)
+void send_resume(struct ishtp_device *dev)
 {
-	struct heci_msg_hdr     heci_hdr;
+	struct ishtp_msg_hdr	ishtp_hdr;
 	struct ish_system_states_status state_status_msg;
 	const size_t len = sizeof(struct ish_system_states_status);
 
-	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
+	fix_cl_hdr(&ishtp_hdr, len, ISHTP_SYSTEM_STATE_CLIENT_ADDR);
 
 	memset(&state_status_msg, 0, len);
 	state_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;
@@ -998,21 +962,23 @@ void send_resume(struct heci_device *dev)
 	dev->print_log(dev, "%s() sends RESUME notification\n", __func__);
 	state_status_msg.states_status = current_state;
 
-	heci_write_message(dev, &heci_hdr, (unsigned char *)&state_status_msg);
+	ishtp_write_message(dev, &ishtp_hdr,
+		(unsigned char *)&state_status_msg);
 }
 EXPORT_SYMBOL(send_resume);
 
-void query_subscribers(struct heci_device *dev)
+void query_subscribers(struct ishtp_device *dev)
 {
-	struct heci_msg_hdr     heci_hdr;
+	struct ishtp_msg_hdr	ishtp_hdr;
 	struct ish_system_states_query_subscribers query_subscribers_msg;
 	const size_t len = sizeof(struct ish_system_states_query_subscribers);
 
-	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
+	fix_cl_hdr(&ishtp_hdr, len, ISHTP_SYSTEM_STATE_CLIENT_ADDR);
 
 	memset(&query_subscribers_msg, 0, len);
 	query_subscribers_msg.hdr.cmd = SYSTEM_STATE_QUERY_SUBSCRIBERS;
 
-	heci_write_message(dev, &heci_hdr, (unsigned char *)&query_subscribers_msg);
+	ishtp_write_message(dev, &ishtp_hdr,
+		(unsigned char *)&query_subscribers_msg);
 }
 
diff --git a/drivers/misc/intel-ish/hbm.h b/drivers/misc/intel-ish/hbm.h
index 6be4044..3f7bc38 100644
--- a/drivers/misc/intel-ish/hbm.h
+++ b/drivers/misc/intel-ish/hbm.h
@@ -1,7 +1,7 @@
 /*
- * HECI bus layer messages handling
+ * ISHTP bus layer messages handling
  *
- * Copyright (c) 2003-2015, Intel Corporation.
+ * Copyright (c) 2003-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,48 +9,39 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
-#ifndef _HECI_HBM_H_
-#define _HECI_HBM_H_
+#ifndef _ISHTP_HBM_H_
+#define _ISHTP_HBM_H_
 
 #include <linux/uuid.h>
 
-struct heci_device;
-struct heci_msg_hdr;
-struct heci_cl;
+struct ishtp_device;
+struct ishtp_msg_hdr;
+struct ishtp_cl;
 
 /*
  * Timeouts in Seconds
  */
-#define HECI_INTEROP_TIMEOUT		7  /* Timeout on ready message */
-#define HECI_CONNECT_TIMEOUT		3  /* HPS: at least 2 seconds */
-
-#define HECI_CL_CONNECT_TIMEOUT		15  /* HPS: Client Connect Timeout */
-#define HECI_CLIENTS_INIT_TIMEOUT	15  /* HPS: Clients Enumeration Timeout */
-
-#if 0
-#define HECI_IAMTHIF_STALL_TIMER	12  /* HPS */
-#define HECI_IAMTHIF_READ_TIMER		10  /* HPS */
-#endif
+#define ISHTP_INTEROP_TIMEOUT		7 /* Timeout on ready message */
 
+#define ISHTP_CL_CONNECT_TIMEOUT	15 /* HPS: Client Connect Timeout */
 
 /*
- * HECI Version
+ * ISHTP Version
  */
 #define HBM_MINOR_VERSION		0
 #define HBM_MAJOR_VERSION		1
-#define HBM_TIMEOUT			1 /* 1 second */
 
 /* Host bus message command opcode */
-#define HECI_HBM_CMD_OP_MSK		0x7f
+#define ISHTP_HBM_CMD_OP_MSK		0x7f
 /* Host bus message command RESPONSE */
-#define HECI_HBM_CMD_RES_MSK		0x80
+#define ISHTP_HBM_CMD_RES_MSK		0x80
 
 /*
- * HECI Bus Message Command IDs
+ * ISHTP Bus Message Command IDs
  */
 #define HOST_START_REQ_CMD		0x01
 #define HOST_START_RES_CMD		0x81
@@ -58,7 +49,7 @@ struct heci_cl;
 #define HOST_STOP_REQ_CMD		0x02
 #define HOST_STOP_RES_CMD		0x82
 
-#define ME_STOP_REQ_CMD			0x03
+#define FW_STOP_REQ_CMD			0x03
 
 #define HOST_ENUM_REQ_CMD		0x04
 #define HOST_ENUM_RES_CMD		0x84
@@ -72,10 +63,7 @@ struct heci_cl;
 #define CLIENT_DISCONNECT_REQ_CMD	0x07
 #define CLIENT_DISCONNECT_RES_CMD	0x87
 
-#define HECI_FLOW_CONTROL_CMD		0x08
-
-#define CLIENT_DMA_REQ_CMD		0x10
-#define CLIENT_DMA_RES_CMD		0x90
+#define ISHTP_FLOW_CONTROL_CMD		0x08
 
 #define DMA_BUFFER_ALLOC_NOTIFY		0x11
 #define DMA_BUFFER_ALLOC_RESPONSE	0x91
@@ -84,55 +72,25 @@ struct heci_cl;
 #define DMA_XFER_ACK			0x92
 
 /*
- * HECI Stop Reason
+ * ISHTP Stop Reason
  * used by hbm_host_stop_request.reason
  */
-enum heci_stop_reason_types {
-	DRIVER_STOP_REQUEST = 0x00,
-	DEVICE_D1_ENTRY = 0x01,
-	DEVICE_D2_ENTRY = 0x02,
-	DEVICE_D3_ENTRY = 0x03,
-	SYSTEM_S1_ENTRY = 0x04,
-	SYSTEM_S2_ENTRY = 0x05,
-	SYSTEM_S3_ENTRY = 0x06,
-	SYSTEM_S4_ENTRY = 0x07,
-	SYSTEM_S5_ENTRY = 0x08
-};
+#define	DRIVER_STOP_REQUEST		0x00
 
 /*
- * Client Connect Status
- * used by hbm_client_connect_response.status
+ * ISHTP BUS Interface Section
  */
-enum client_connect_status_types {
-	CCS_SUCCESS = 0x00,
-	CCS_NOT_FOUND = 0x01,
-	CCS_ALREADY_STARTED = 0x02,
-	CCS_OUT_OF_RESOURCES = 0x03,
-	CCS_MESSAGE_SMALL = 0x04
-};
-
-/*
- * Client Disconnect Status
- */
-enum client_disconnect_status_types {
-	CDS_SUCCESS = 0x00
-};
-
-/*
- *  HECI BUS Interface Section
- */
-struct heci_msg_hdr {
-	u32 me_addr:8;
-	u32 host_addr:8;
-	u32 length:9;
-	u32 reserved:6;
-	u32 msg_complete:1;
+struct ishtp_msg_hdr {
+	uint32_t fw_addr:8;
+	uint32_t host_addr:8;
+	uint32_t length:9;
+	uint32_t reserved:6;
+	uint32_t msg_complete:1;
 } __packed;
 
-
-struct heci_bus_message {
-	u8 hbm_cmd;
-	u8 data[0];
+struct ishtp_bus_message {
+	uint8_t hbm_cmd;
+	uint8_t data[0];
 } __packed;
 
 /**
@@ -140,240 +98,167 @@ struct heci_bus_message {
  *	CONNECT, DISCONNECT, and FlOW CONTROL
  *
  * @hbm_cmd - bus message command header
- * @me_addr - address of the client in ME
+ * @fw_addr - address of the fw client
  * @host_addr - address of the client in the driver
  * @data
  */
-struct heci_hbm_cl_cmd {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 data;
+struct ishtp_hbm_cl_cmd {
+	uint8_t hbm_cmd;
+	uint8_t fw_addr;
+	uint8_t host_addr;
+	uint8_t data;
 };
 
 struct hbm_version {
-	u8 minor_version;
-	u8 major_version;
+	uint8_t minor_version;
+	uint8_t major_version;
 } __packed;
 
 struct hbm_host_version_request {
-	u8 hbm_cmd;
-	u8 reserved;
+	uint8_t hbm_cmd;
+	uint8_t reserved;
 	struct hbm_version host_version;
 } __packed;
 
 struct hbm_host_version_response {
-	u8 hbm_cmd;
-	u8 host_version_supported;
-	struct hbm_version me_max_version;
+	uint8_t hbm_cmd;
+	uint8_t host_version_supported;
+	struct hbm_version fw_max_version;
 } __packed;
 
 struct hbm_host_stop_request {
-	u8 hbm_cmd;
-	u8 reason;
-	u8 reserved[2];
+	uint8_t hbm_cmd;
+	uint8_t reason;
+	uint8_t reserved[2];
 } __packed;
 
 struct hbm_host_stop_response {
-	u8 hbm_cmd;
-	u8 reserved[3];
-} __packed;
-
-struct hbm_me_stop_request {
-	u8 hbm_cmd;
-	u8 reason;
-	u8 reserved[2];
+	uint8_t hbm_cmd;
+	uint8_t reserved[3];
 } __packed;
 
 struct hbm_host_enum_request {
-	u8 hbm_cmd;
-	u8 reserved[3];
+	uint8_t hbm_cmd;
+	uint8_t reserved[3];
 } __packed;
 
 struct hbm_host_enum_response {
-	u8 hbm_cmd;
-	u8 reserved[3];
-	u8 valid_addresses[32];
+	uint8_t hbm_cmd;
+	uint8_t reserved[3];
+	uint8_t valid_addresses[32];
 } __packed;
 
-struct heci_client_properties {
+struct ishtp_client_properties {
 	uuid_le protocol_name;
-	u8 protocol_version;
-	u8 max_number_of_connections;
-	u8 fixed_address;
-	u8 single_recv_buf;
-	u32 max_msg_length;
-	u8 dma_hdr_len;
-#define	HECI_CLIENT_DMA_ENABLED	0x80
-	u8 reserved4;
-	u8 reserved5;
-	u8 reserved6;
+	uint8_t protocol_version;
+	uint8_t max_number_of_connections;
+	uint8_t fixed_address;
+	uint8_t single_recv_buf;
+	uint32_t max_msg_length;
+	uint8_t dma_hdr_len;
+#define	ISHTP_CLIENT_DMA_ENABLED	0x80
+	uint8_t reserved4;
+	uint8_t reserved5;
+	uint8_t reserved6;
 } __packed;
 
 struct hbm_props_request {
-	u8 hbm_cmd;
-	u8 address;
-	u8 reserved[2];
+	uint8_t hbm_cmd;
+	uint8_t address;
+	uint8_t reserved[2];
 } __packed;
 
-
 struct hbm_props_response {
-	u8 hbm_cmd;
-	u8 address;
-	u8 status;
-	u8 reserved[1];
-	struct heci_client_properties client_properties;
+	uint8_t hbm_cmd;
+	uint8_t address;
+	uint8_t status;
+	uint8_t reserved[1];
+	struct ishtp_client_properties client_properties;
 } __packed;
 
 /**
  * struct hbm_client_connect_request - connect/disconnect request
  *
  * @hbm_cmd - bus message command header
- * @me_addr - address of the client in ME
+ * @fw_addr - address of the fw client
  * @host_addr - address of the client in the driver
  * @reserved
  */
 struct hbm_client_connect_request {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 reserved;
+	uint8_t hbm_cmd;
+	uint8_t fw_addr;
+	uint8_t host_addr;
+	uint8_t reserved;
 } __packed;
 
 /**
  * struct hbm_client_connect_response - connect/disconnect response
  *
  * @hbm_cmd - bus message command header
- * @me_addr - address of the client in ME
+ * @fw_addr - address of the fw client
  * @host_addr - address of the client in the driver
  * @status - status of the request
  */
 struct hbm_client_connect_response {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 status;
+	uint8_t hbm_cmd;
+	uint8_t fw_addr;
+	uint8_t host_addr;
+	uint8_t status;
 } __packed;
 
 
-#define HECI_FC_MESSAGE_RESERVED_LENGTH           5
+#define ISHTP_FC_MESSAGE_RESERVED_LENGTH		5
 
 struct hbm_flow_control {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 reserved[HECI_FC_MESSAGE_RESERVED_LENGTH];
-} __packed;
-
-struct hbm_client_dma_request {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 reserved;
-	u64 msg_addr;
-	u32 msg_len;
-	u16 reserved2;
-	u16 msg_preview_len;
-	u8 msg_preview[12];
-} __packed;
-
-struct hbm_client_dma_response {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 status;
-	u64 msg_addr;
-	u32 msg_len;
+	uint8_t hbm_cmd;
+	uint8_t fw_addr;
+	uint8_t host_addr;
+	uint8_t reserved[ISHTP_FC_MESSAGE_RESERVED_LENGTH];
 } __packed;
 
 struct dma_alloc_notify {
-	u8 hbm;
-	u8 status;
-	u8 reserved[2];
-	u32 buf_size;
+	uint8_t hbm;
+	uint8_t status;
+	uint8_t reserved[2];
+	uint32_t buf_size;
 	u64 buf_address;
 	/* [...] May come more size/address pairs */
 } __packed;
 
-
 struct dma_xfer_hbm {
-	u8 hbm;
-	u8 fw_client_id;
-	u8 host_client_id;
-	u8 reserved;
+	uint8_t hbm;
+	uint8_t fw_client_id;
+	uint8_t host_client_id;
+	uint8_t reserved;
 	u64 msg_addr;
-	u32 msg_length;
-	u32 reserved2;
+	uint32_t msg_length;
+	uint32_t reserved2;
 } __packed;
 
-
-/**
- * enum heci_hbm_state - host bus message protocol state
- *
- * @HECI_HBM_IDLE : protocol not started
- * @HECI_HBM_START : start request message was sent
- * @HECI_HBM_ENUM_CLIENTS : enumeration request was sent
- * @HECI_HBM_CLIENT_PROPERTIES : acquiring clients properties
- */
-enum heci_hbm_state {
-	HECI_HBM_IDLE = 0,
-	HECI_HBM_START,
-	HECI_HBM_STARTED,
-	HECI_HBM_ENUM_CLIENTS,
-	HECI_HBM_CLIENT_PROPERTIES,
-	HECI_HBM_WORKING,
-	HECI_HBM_STOPPED,
-};
-
-#if 0
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_msg_hdr *hdr);
-#else
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
-#endif
-
-static inline void heci_hbm_hdr(struct heci_msg_hdr *hdr, size_t length)
-{
-	hdr->host_addr = 0;
-	hdr->me_addr = 0;
-	hdr->length = length;
-	hdr->msg_complete = 1;
-	hdr->reserved = 0;
-}
-
-int heci_hbm_start_req(struct heci_device *dev);
-int heci_hbm_start_wait(struct heci_device *dev);
-int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl);
-int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl);
-int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl);
-void heci_hbm_enum_clients_req(struct heci_device *dev);
-void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
-
 /* System state */
-#define HECI_SYSTEM_STATE_CLIENT_ADDR 13
+#define ISHTP_SYSTEM_STATE_CLIENT_ADDR		13
 
-#define SYSTEM_STATE_SUBSCRIBE                  0x1
-#define SYSTEM_STATE_STATUS                     0x2
-#define SYSTEM_STATE_QUERY_SUBSCRIBERS          0x3
+#define SYSTEM_STATE_SUBSCRIBE			0x1
+#define SYSTEM_STATE_STATUS			0x2
+#define SYSTEM_STATE_QUERY_SUBSCRIBERS		0x3
 #define SYSTEM_STATE_STATE_CHANGE_REQ		0x4
-
-#define SUSPEND_STATE_BIT       (1<<1) /*indicates suspend and resume states*/
-
-#define ANDROID_EVENT_MASK	0xff000000
+/*indicates suspend and resume states*/
+#define SUSPEND_STATE_BIT			(1<<1)
 
 struct ish_system_states_header {
-	u32 cmd;
-	u32 cmd_status;  /*responses will have this set*/
+	uint32_t cmd;
+	uint32_t cmd_status;	/*responses will have this set*/
 } __packed;
 
 struct ish_system_states_subscribe {
 	struct ish_system_states_header hdr;
-	u32 states;
+	uint32_t states;
 } __packed;
 
 struct ish_system_states_status {
 	struct ish_system_states_header hdr;
-	u32 supported_states;
-	u32 states_status;
+	uint32_t supported_states;
+	uint32_t states_status;
 } __packed;
 
 struct ish_system_states_query_subscribers {
@@ -382,15 +267,55 @@ struct ish_system_states_query_subscribers {
 
 struct ish_system_states_state_change_req {
 	struct ish_system_states_header hdr;
-	u32 requested_states;
-	u32 states_status;
+	uint32_t requested_states;
+	uint32_t states_status;
 } __packed;
 
-void send_suspend(struct heci_device *dev);
-void send_resume(struct heci_device *dev);
-void query_subscribers(struct heci_device *dev);
+/**
+ * enum ishtp_hbm_state - host bus message protocol state
+ *
+ * @ISHTP_HBM_IDLE : protocol not started
+ * @ISHTP_HBM_START : start request message was sent
+ * @ISHTP_HBM_ENUM_CLIENTS : enumeration request was sent
+ * @ISHTP_HBM_CLIENT_PROPERTIES : acquiring clients properties
+ */
+enum ishtp_hbm_state {
+	ISHTP_HBM_IDLE = 0,
+	ISHTP_HBM_START,
+	ISHTP_HBM_STARTED,
+	ISHTP_HBM_ENUM_CLIENTS,
+	ISHTP_HBM_CLIENT_PROPERTIES,
+	ISHTP_HBM_WORKING,
+	ISHTP_HBM_STOPPED,
+};
+
+static inline void ishtp_hbm_hdr(struct ishtp_msg_hdr *hdr, size_t length)
+{
+	hdr->host_addr = 0;
+	hdr->fw_addr = 0;
+	hdr->length = length;
+	hdr->msg_complete = 1;
+	hdr->reserved = 0;
+}
 
-void recv_fixed_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
-#endif /* _HECI_HBM_H_ */
+int ishtp_hbm_start_req(struct ishtp_device *dev);
+int ishtp_hbm_start_wait(struct ishtp_device *dev);
+int ishtp_hbm_cl_flow_control_req(struct ishtp_device *dev,
+	struct ishtp_cl *cl);
+int ishtp_hbm_cl_disconnect_req(struct ishtp_device *dev, struct ishtp_cl *cl);
+int ishtp_hbm_cl_connect_req(struct ishtp_device *dev, struct ishtp_cl *cl);
+void ishtp_hbm_enum_clients_req(struct ishtp_device *dev);
+void bh_hbm_work_fn(struct work_struct *work);
+void recv_hbm(struct ishtp_device *dev, struct ishtp_msg_hdr *ishtp_hdr);
+void recv_fixed_cl_msg(struct ishtp_device *dev,
+	struct ishtp_msg_hdr *ishtp_hdr);
+void ishtp_hbm_dispatch(struct ishtp_device *dev,
+	struct ishtp_bus_message *hdr);
+void *get_dma_send_buf(struct ishtp_device *dev, uint32_t size);
+
+void send_suspend(struct ishtp_device *dev);
+void send_resume(struct ishtp_device *dev);
+void query_subscribers(struct ishtp_device *dev);
+
+#endif /* _ISHTP_HBM_H_ */
 
diff --git a/drivers/misc/intel-ish/heci-api.c b/drivers/misc/intel-ish/heci-api.c
deleted file mode 100644
index a056202..0000000
--- a/drivers/misc/intel-ish/heci-api.c
+++ /dev/null
@@ -1,692 +0,0 @@
-/*
- * User-mode HECI API
- *
- * Copyright (c) 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/aio.h>
-#include <linux/pci.h>
-#include <linux/poll.h>
-#include <linux/init.h>
-#include <linux/ioctl.h>
-#include <linux/cdev.h>
-#include <linux/sched.h>
-#include <linux/uuid.h>
-#include <linux/compat.h>
-#include <linux/jiffies.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include "heci-api.h"
-#include "heci_dev.h"
-#include "client.h"
-#include "platform-config.h"
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static  void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-/*#define dev_dbg dev_err*/
-
-/**
- * heci_open - the open function
- *
- * @inode: pointer to inode structure
- * @file: pointer to file structure
- e
- * returns 0 on success, <0 on error
- */
-static int heci_open(struct inode *inode, struct file *file)
-{
-	struct miscdevice *misc = file->private_data;
-	struct pci_dev *pdev;
-	struct heci_cl *cl;
-	struct heci_device *dev;
-	int err;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	/* Non-blocking semantics are not supported */
-	if (file->f_flags & O_NONBLOCK)
-		return	-EINVAL;
-
-	err = -ENODEV;
-	if (!misc->parent)
-		goto out;
-
-	pdev = container_of(misc->parent, struct pci_dev, dev);
-
-	dev = pci_get_drvdata(pdev);
-	if (!dev)
-		goto out;
-
-	err = -ENOMEM;
-	cl = heci_cl_allocate(dev);
-	if (!cl)
-		goto out_free;
-
-	/*
-	 * We may have a case of issued open() with
-	 * dev->dev_state == HECI_DEV_DISABLED, as part of re-enabling path
-	 */
-	err = -ENODEV;
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		dev_dbg(&dev->pdev->dev, "dev_state != HECI_ENABLED  dev_state = %s\n",
-		    heci_dev_state_str(dev->dev_state));
-		goto out_free;
-	}
-
-	err = heci_cl_link(cl, HECI_HOST_CLIENT_ID_ANY);
-	if (err)
-		goto out_free;
-
-	file->private_data = cl;
-
-	return nonseekable_open(inode, file);
-
-out_free:
-	kfree(cl);
-out:
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return err;
-}
-
-/**
- * heci_release - the release function
- *
- * @inode: pointer to inode structure
- * @file: pointer to file structure
- *
- * returns 0 on success, <0 on error
- */
-static int heci_release(struct inode *inode, struct file *file)
-{
-	struct heci_cl *cl = file->private_data;
-	struct heci_device *dev;
-	int rets = 0;
-	unsigned int flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	/*
-	 * May happen if device sent FW reset or was intentionally
-	 * halted by host SW. The client is then invalid
-	 */
-	if (dev->dev_state != HECI_DEV_ENABLED)
-		return	0;
-
-	if (cl->state == HECI_CL_CONNECTED) {
-		cl->state = HECI_CL_DISCONNECTING;
-		dev_dbg(&dev->pdev->dev, "disconnecting client host client = %d, ME client = %d\n",
-			cl->host_client_id, cl->me_client_id);
-		rets = heci_cl_disconnect(cl);
-	}
-
-	dev_dbg(&dev->pdev->dev, "remove client host client = %d, ME client = %d\n",
-	    cl->host_client_id,
-	    cl->me_client_id);
-
-	heci_cl_unlink(cl);
-	heci_cl_flush_queues(cl);
-	file->private_data = NULL;
-
-	/* disband and free all Tx and Rx client-level rings */
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	heci_cl_free(cl);
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return rets;
-}
-
-
-/**
- * heci_read - the read function.
- *
- * @file: pointer to file structure
- * @ubuf: pointer to user buffer
- * @length: buffer length
- * @offset: data offset in buffer
- *
- * returns >=0 data length on success , <0 on error
- */
-static ssize_t heci_read(struct file *file, char __user *ubuf,
-			size_t length, loff_t *offset)
-{
-	struct heci_cl *cl = file->private_data;
-	struct heci_cl_rb *rb = NULL;
-	struct heci_device *dev;
-	int rets;
-	unsigned long flags;
-
-	/* Non-blocking semantics are not supported */
-	if (file->f_flags & O_NONBLOCK)
-		return	-EINVAL;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-/*
- * EXPLAINME: handle reading message by fragments smaller than
- * actual message size. Why needed? Reportedly, doesn't work: why?
- */
-#if 0
-	if (cl->read_rb && cl->read_rb->buf_idx > *offset) {
-		rb = cl->read_rb;
-		goto copy_buffer;
-	} else if (cl->read_rb && cl->read_rb->buf_idx > 0 &&
-		   cl->read_rb->buf_idx <= *offset) {
-		rb = cl->read_rb;
-		rets = 0;
-		goto free;
-	} else if ((!cl->read_rb || !cl->read_rb->buf_idx) && *offset > 0) {
-		/*Offset needs to be cleaned for contiguous reads*/
-		*offset = 0;
-		rets = 0;
-		goto out;
-	}
-#endif
-
-	spin_lock_irqsave(&cl->in_process_spinlock, flags);
-	if (!list_empty(&cl->in_process_list.list)) {
-		rb = list_entry(cl->in_process_list.list.next,
-			struct heci_cl_rb, list);
-		list_del_init(&rb->list);
-		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
-		goto copy_buffer;
-	}
-	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
-
-	if (waitqueue_active(&cl->rx_wait)) {
-		rets = -EBUSY;
-		goto out;
-	}
-
-	if (wait_event_interruptible(cl->rx_wait,
-			(dev->dev_state == HECI_DEV_ENABLED &&
-			(cl->read_rb || HECI_CL_INITIALIZING == cl->state ||
-			HECI_CL_DISCONNECTED == cl->state ||
-			HECI_CL_DISCONNECTING == cl->state)))) {
-		dev_err(&dev->pdev->dev, "%s(): woke up not in success; sig. pending = %d signal = %08lX\n",
-			__func__, signal_pending(current),
-			current->pending.signal.sig[0]);
-		return	-ERESTARTSYS;
-	}
-
-	/*
-	 * If FW reset arrived, this will happen. Don't check cl->,
-	 * as 'cl' may be freed already
-	 */
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto	out;
-	}
-
-	if (HECI_CL_INITIALIZING == cl->state ||
-	    HECI_CL_DISCONNECTED == cl->state ||
-	    HECI_CL_DISCONNECTING == cl->state) {
-		rets = -EBUSY;
-		goto out;
-	}
-
-	rb = cl->read_rb;
-	if (!rb) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-	/* now copy the data to user space */
-copy_buffer:
-	dev_dbg(&dev->pdev->dev, "buf.size = %d buf.idx= %ld\n",
-	    rb->buffer.size, rb->buf_idx);
-	if (length == 0 || ubuf == NULL || *offset > rb->buf_idx) {
-		rets = -EMSGSIZE;
-		goto free;
-	}
-
-	/* length is being truncated to PAGE_SIZE,
-	 * however buf_idx may point beyond that */
-	length = min_t(size_t, length, rb->buf_idx - *offset);
-
-	if (copy_to_user(ubuf, rb->buffer.data + *offset, length)) {
-		rets = -EFAULT;
-		goto free;
-	}
-
-	rets = length;
-	*offset += length;
-	if ((unsigned long)*offset < rb->buf_idx)
-		goto out;
-
-free:
-	heci_io_rb_recycle(rb);
-
-	cl->read_rb = NULL;
-	*offset = 0;
-out:
-	dev_dbg(&dev->pdev->dev, "end heci read rets= %d\n", rets);
-	return rets;
-}
-
-
-/**
- * heci_write - the write function.
- *
- * @file: pointer to file structure
- * @ubuf: pointer to user buffer
- * @length: buffer length
- * @offset: data offset in buffer
- *
- * returns >=0 data length on success , <0 on error
- */
-static ssize_t heci_write(struct file *file, const char __user *ubuf,
-	size_t length, loff_t *offset)
-{
-	struct heci_cl *cl = file->private_data;
-
-	/*
-	 * TODO: we may further optimize write path by obtaining and directly
-	 * copy_from_user'ing to tx_ring's buffer
-	 */
-	void *write_buf = NULL;
-	struct heci_device *dev;
-	int rets;
-
-	/* Non-blocking semantics are not supported */
-	if (file->f_flags & O_NONBLOCK)
-		return	-EINVAL;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-	if (cl->state != HECI_CL_CONNECTED) {
-		dev_err(&dev->pdev->dev, "host client = %d,  is not connected to ME client = %d",
-			cl->host_client_id, cl->me_client_id);
-		rets = -ENODEV;
-		goto out;
-	}
-
-	if (length <= 0) {
-		rets = -EMSGSIZE;
-		goto out;
-	}
-
-	/* FIXME: check for DMA size for clients that accept DMA transfers */
-	if (length > cl->device->fw_client->props.max_msg_length) {
-		/* If the client supports DMA, try to use it */
-		if (!(host_dma_enabled &&
-				cl->device->fw_client->props.dma_hdr_len &
-				HECI_CLIENT_DMA_ENABLED)) {
-			rets = -EMSGSIZE;
-			goto out;
-		}
-	}
-
-	write_buf = kmalloc(length, GFP_KERNEL);
-	if (!write_buf) {
-		dev_err(&dev->pdev->dev, "write buffer allocation failed\n");
-		rets = -ENOMEM;
-		goto	out;
-	}
-
-	rets = copy_from_user(write_buf, ubuf, length);
-	if (rets)
-		goto out;
-	rets = heci_cl_send(cl, write_buf, length);
-	if (!rets)
-		rets = length;
-	else
-		rets = -EIO;
-out:
-	kfree(write_buf);
-	return rets;
-}
-
-/**
- * heci_ioctl_connect_client - the connect to fw client IOCTL function
- *
- * @dev: the device structure
- * @data: IOCTL connect data, input and output parameters
- * @file: private data of the file object
- *
- * Locking: called under "dev->device_lock" lock
- *
- * returns 0 on success, <0 on failure.
- */
-static int heci_ioctl_connect_client(struct file *file,
-	struct heci_connect_client_data *data)
-{
-	struct heci_device *dev;
-	struct heci_client *client;
-	struct heci_cl *cl;
-	int i;
-	int rets;
-	unsigned long flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	cl = file->private_data;
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto end;
-	}
-
-	if (cl->state != HECI_CL_INITIALIZING &&
-	    cl->state != HECI_CL_DISCONNECTED) {
-		rets = -EBUSY;
-		goto end;
-	}
-
-	/* find ME client we're trying to connect to */
-	i = heci_me_cl_by_uuid(dev, &data->in_client_uuid);
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	if (i < 0 || dev->me_clients[i].props.fixed_address) {
-		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
-				&data->in_client_uuid);
-		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-		rets = -ENODEV;
-		goto end;
-	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	/* Check if there's driver attached to this UUID */
-	if (!heci_can_client_connect(dev, &data->in_client_uuid))
-		return	-EBUSY;
-
-	cl->me_client_id = dev->me_clients[i].client_id;
-	cl->state = HECI_CL_CONNECTING;
-
-	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
-			cl->me_client_id);
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
-			dev->me_clients[i].props.protocol_version);
-	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
-			dev->me_clients[i].props.max_msg_length);
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	/* prepare the output buffer */
-	client = &data->out_client_properties;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
-	client->protocol_version = dev->me_clients[i].props.protocol_version;
-	dev_dbg(&dev->pdev->dev, "Can connect?\n");
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	rets = heci_cl_connect(cl);
-
-end:
-	ISH_DBG_PRINT(KERN_ALERT "%s(): --- (%d)\n", __func__, rets);
-	return	rets;
-}
-
-
-/**
- * heci_ioctl - the IOCTL function
- *
- * @file: pointer to file structure
- * @cmd: ioctl command
- * @data: pointer to heci message structure
- *
- * returns 0 on success , <0 on error
- */
-static long heci_ioctl(struct file *file, unsigned int cmd, unsigned long data)
-{
-	struct heci_device *dev;
-	struct heci_cl *cl = file->private_data;
-	struct heci_connect_client_data *connect_data = NULL;
-	int rets;
-	unsigned	ring_size;
-	char fw_stat_buf[20];
-
-	if (!cl)
-		return -EINVAL;
-
-	dev = cl->dev;
-	dev_dbg(&dev->pdev->dev, "IOCTL cmd = 0x%x", cmd);
-
-	/* Test API for triggering PCI reset */
-	if (cmd == 0x12341234) {
-		return	heci_hw_reset(dev);
-	}
-
-	/* Test API for triggering host-initiated IPC reset to ISS */
-	if (cmd == 0x12345678) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): ISS FW reset is requested\n",
-			__func__);
-		/* Re-init */
-		dev->dev_state = HECI_DEV_INITIALIZING;
-		heci_reset(dev, 1);
-
-		if (heci_hbm_start_wait(dev)) {
-			dev_err(&dev->pdev->dev, "HBM haven't started");
-			goto err;
-		}
-
-		if (!heci_host_is_ready(dev)) {
-			dev_err(&dev->pdev->dev, "host is not ready.\n");
-			goto err;
-		}
-
-		if (!heci_hw_is_ready(dev)) {
-			dev_err(&dev->pdev->dev, "ME is not ready.\n");
-			goto err;
-		}
-
-		return	0;
-err:
-		dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
-		dev->dev_state = HECI_DEV_DISABLED;
-		return -ENODEV;
-	}
-
-	/* Test API for triggering host disabling */
-	if (cmd == 0xAA55AA55) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): ISS host stop is requested\n",
-			__func__);
-		/* Handle ISS reset against upper layers */
-
-		/* Remove all client devices */
-		heci_bus_remove_all_clients(dev);
-		dev->dev_state = HECI_DEV_DISABLED;
-		return	0;
-	}
-
-	if (cmd == IOCTL_HECI_SET_RX_FIFO_SIZE) {
-		ring_size = data;
-		if (ring_size > CL_MAX_RX_RING_SIZE)
-			return	-EINVAL;
-		if (cl->state != HECI_CL_INITIALIZING)
-			return	-EBUSY;
-		cl->rx_ring_size = ring_size;
-		return	0;
-	}
-
-	if (cmd == IOCTL_HECI_SET_TX_FIFO_SIZE) {
-		ring_size = data;
-		if (ring_size > CL_MAX_TX_RING_SIZE)
-			return	-EINVAL;
-		if (cl->state != HECI_CL_INITIALIZING)
-			return	-EBUSY;
-		cl->tx_ring_size = ring_size;
-		return	0;
-	}
-
-	if (cmd == IOCTL_GET_FW_STATUS) {
-		scnprintf(fw_stat_buf, sizeof(fw_stat_buf),
-			"%08X\n", dev->ops->get_fw_status(dev));
-		copy_to_user((char __user *)data, fw_stat_buf,
-			strlen(fw_stat_buf));
-		return strlen(fw_stat_buf);
-	}
-
-	if (cmd != IOCTL_HECI_CONNECT_CLIENT)
-		return -EINVAL;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-	dev_dbg(&dev->pdev->dev, ": IOCTL_HECI_CONNECT_CLIENT.\n");
-
-	connect_data = kzalloc(sizeof(struct heci_connect_client_data),
-							GFP_KERNEL);
-	if (!connect_data) {
-		rets = -ENOMEM;
-		goto out;
-	}
-	dev_dbg(&dev->pdev->dev, "copy connect data from user\n");
-	if (copy_from_user(connect_data, (char __user *)data,
-			sizeof(struct heci_connect_client_data))) {
-		dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
-		rets = -EFAULT;
-		goto out;
-	}
-
-	rets = heci_ioctl_connect_client(file, connect_data);
-
-	/* if all is ok, copying the data back to user. */
-	if (rets)
-		goto out;
-
-	dev_dbg(&dev->pdev->dev, "copy connect data to user\n");
-	if (copy_to_user((char __user *)data, connect_data,
-				sizeof(struct heci_connect_client_data))) {
-		dev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");
-		rets = -EFAULT;
-		goto out;
-	}
-
-out:
-	kfree(connect_data);
-	return rets;
-}
-
-/**
- * heci_compat_ioctl - the compat IOCTL function
- *
- * @file: pointer to file structure
- * @cmd: ioctl command
- * @data: pointer to heci message structure
- *
- * returns 0 on success , <0 on error
- */
-#ifdef CONFIG_COMPAT
-static long heci_compat_ioctl(struct file *file,
-			unsigned int cmd, unsigned long data)
-{
-	return heci_ioctl(file, cmd, (unsigned long)compat_ptr(data));
-}
-#endif /*CONFIG_COMPAT*/
-
-
-/*
- * file operations structure will be used for heci char device.
- */
-static const struct file_operations heci_fops = {
-	.owner = THIS_MODULE,
-	.read = heci_read,
-	.unlocked_ioctl = heci_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = heci_compat_ioctl,
-#endif /*CONFIG_COMPAT*/
-	.open = heci_open,
-	.release = heci_release,
-	.write = heci_write,
-	.llseek = no_llseek
-};
-
-/*
- * Misc Device Struct
- */
-static struct miscdevice  heci_misc_device = {
-		.name = "ish",		/*"heci" changed to "ish", stuff it #2*/
-		.fops = &heci_fops,
-		.minor = MISC_DYNAMIC_MINOR,
-};
-
-int heci_register(struct heci_device *dev)
-{
-	int ret;
-	heci_misc_device.parent = &dev->pdev->dev;
-	ret = misc_register(&heci_misc_device);
-	if (ret)
-		return ret;
-
-	if (heci_dbgfs_register(dev, heci_misc_device.name))
-		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(heci_register);
-
-void heci_deregister(struct heci_device *dev)
-{
-	if (heci_misc_device.parent == NULL)
-		return;
-
-	heci_dbgfs_deregister(dev);
-	misc_deregister(&heci_misc_device);
-	heci_misc_device.parent = NULL;
-}
-EXPORT_SYMBOL_GPL(heci_deregister);
-
-static int __init heci_init(void)
-{
-	return heci_cl_bus_init();
-}
-
-static void __exit heci_exit(void)
-{
-	heci_cl_bus_exit();
-}
-
-module_init(heci_init);
-module_exit(heci_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("Intel(R) Management Engine Interface");
-MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/misc/intel-ish/heci-api.h b/drivers/misc/intel-ish/heci-api.h
deleted file mode 100644
index 7af16a5..0000000
--- a/drivers/misc/intel-ish/heci-api.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/******************************************************************************
- * Intel HECI Interface Header
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2003 - 2015 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program;
- *
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * Contact Information:
- *	Intel Corporation.
- *	linux-heci@linux.intel.com
- *	http://www.intel.com
- *
- * BSD LICENSE
- *
- * Copyright(c) 2003 - 2015 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name Intel Corporation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *****************************************************************************/
-
-#ifndef _LINUX_HECI_H
-#define _LINUX_HECI_H
-
-#include <linux/uuid.h>
-
-/*
- * This IOCTL is used to associate the current file descriptor with a
- * FW Client (given by UUID). This opens a communication channel
- * between a host client and a FW client. From this point every read and write
- * will communicate with the associated FW client.
- * Only in close() (file_operation release()) the communication between
- * the clients is disconnected
- *
- * The IOCTL argument is a struct with a union that contains
- * the input parameter and the output parameter for this IOCTL.
- *
- * The input parameter is UUID of the FW Client.
- * The output parameter is the properties of the FW client
- * (FW protocol version and max message size).
- *
- */
-#define IOCTL_HECI_CONNECT_CLIENT	_IOWR('H', 0x01,	\
-				struct heci_connect_client_data)
-
-/* Configuration: set number of Rx/Tx buffers. Must be used before conneciton */
-#define IOCTL_HECI_SET_RX_FIFO_SIZE	_IOWR('H', 0x02, long)
-#define IOCTL_HECI_SET_TX_FIFO_SIZE	_IOWR('H', 0x03, long)
-
-/* Get FW status */
-#define IOCTL_GET_FW_STATUS             _IO('H', 0x04)
-
-/*
- * Intel HECI client information struct
- */
-struct heci_client {
-	__u32 max_msg_length;
-	__u8 protocol_version;
-	__u8 reserved[3];
-};
-
-/*
- * IOCTL Connect Client Data structure
- */
-struct heci_connect_client_data {
-	union {
-		uuid_le in_client_uuid;
-		struct heci_client out_client_properties;
-	};
-};
-
-#endif /* _LINUX_HECI_H  */
-
diff --git a/drivers/misc/intel-ish/heci-hid-client.c b/drivers/misc/intel-ish/heci-hid-client.c
deleted file mode 100644
index 18dfba6..0000000
--- a/drivers/misc/intel-ish/heci-hid-client.c
+++ /dev/null
@@ -1,807 +0,0 @@
-/*
- * HECI client driver for HID (ISS)
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/hid.h>
-#include <linux/slab.h>
-#include <linux/timer.h>
-#include <linux/kthread.h>
-#include <linux/uuid.h>
-#include "heci_dev.h"
-#include "client.h"
-#include "heci-hid.h"
-
-/* Rx ring buffer pool size */
-#define RX_RING_SIZE	32
-#define TX_RING_SIZE	16
-
-/* Global vars, may eventually end up in a structure */
-struct heci_cl	*hid_heci_cl = NULL;			/* ISS HECI client */
-
-/* Set when ISS HECI client is successfully probed */
-int	hid_heci_client_found;
-int	may_send;		/* Global flag that determines if sender thread
-				can safely send something or it should
-				wait more */
-int	enum_devices_done;	/* Enum devices response complete flag */
-int	hid_descr_done;		/* Get HID descriptor complete flag */
-int	report_descr_done;	/* Get report descriptor complete flag */
-int	get_report_done;	/* Get Feature/Input report complete flag */
-
-struct device_info	*hid_devices;
-unsigned	cur_hid_dev;
-unsigned	hid_dev_count;
-unsigned	max_hid_devices = /*1*/ MAX_HID_DEVICES;
-unsigned	num_hid_devices;
-unsigned char	*hid_descr[MAX_HID_DEVICES];
-int	hid_descr_size[MAX_HID_DEVICES];
-unsigned char	*report_descr[MAX_HID_DEVICES];
-int	report_descr_size[MAX_HID_DEVICES];
-struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
-
-static wait_queue_head_t	init_wait;
-wait_queue_head_t	heci_hid_wait;
-static unsigned	bad_recv_cnt;
-static int	multi_packet_cnt;
-
-/*flush notification*/
-void (*flush_cb)(void);
-static int	init_done;
-
-
-static void	report_bad_packet(void *recv_buf, size_t cur_pos, size_t payload_len)
-{
-	struct hostif_msg	*recv_msg = recv_buf;
-
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: BAD packet %02X\n",
-		recv_msg->hdr.command);
-	dev_err(&hid_heci_cl->device->dev, "total_bad=%u cur_pos=%u\n",
-		bad_recv_cnt, cur_pos);
-	dev_err(&hid_heci_cl->device->dev, "[%02X %02X %02X %02X]\n",
-		((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1],
-		((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: payload_len=%u\n",
-		payload_len);
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: multi_packet_cnt=%u\n",
-		multi_packet_cnt);
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: is_response=%02X\n",
-		recv_msg->hdr.command & ~CMD_MASK);
-}
-
-
-/* HECI client driver structures and API for bus interface */
-static void	process_recv(void *recv_buf, size_t data_len)
-{
-	struct hostif_msg	*recv_msg;
-	unsigned char	*payload;
-	/*size_t	size;*/
-	struct device_info	*dev_info;
-	int	i, j;
-	size_t	payload_len, total_len, cur_pos;
-	int	report_type;
-
-	struct report_list *reports_list;
-	char *reports;
-	size_t report_len;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++ len=%u\n", __func__,
-		(unsigned)data_len);
-
-	if (data_len < sizeof(struct hostif_msg_hdr)) {
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: error, received %u which is ",
-			(unsigned)data_len);
-		dev_err(&hid_heci_cl->device->dev,
-			" less than data header %u\n",
-			(unsigned)sizeof(struct hostif_msg_hdr));
-		++bad_recv_cnt;
-		heci_hw_reset(hid_heci_cl->dev);
-		return;
-	}
-
-	payload = recv_buf + sizeof(struct hostif_msg_hdr);
-	total_len = data_len;
-	cur_pos = 0;
-
-	may_send = 0;
-
-	do {
-		recv_msg = (struct hostif_msg *)(recv_buf + cur_pos);
-		payload_len = recv_msg->hdr.size;
-
-		/* Sanity checks */
-		if (cur_pos + payload_len + sizeof(struct hostif_msg) >
-				total_len) {
-			++bad_recv_cnt;
-			report_bad_packet(recv_msg, cur_pos, payload_len);
-			heci_hw_reset(hid_heci_cl->dev);
-			break;
-		}
-
-
-		switch (recv_msg->hdr.command & CMD_MASK) {
-		default:
-			++bad_recv_cnt;
-			report_bad_packet(recv_msg, cur_pos, payload_len);
-			heci_hw_reset(hid_heci_cl->dev);
-			break;
-
-		case HOSTIF_DM_ENUM_DEVICES:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): HOSTIF_DM_ENUM_DEVICES [cur_pos=%u] [%02X %02X %02X %02X]\n",
-				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
-			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
-					init_done)) {
-				++bad_recv_cnt;
-				report_bad_packet(recv_msg, cur_pos,
-					payload_len);
-				heci_hw_reset(hid_heci_cl->dev);
-				break;
-			}
-			hid_dev_count = (unsigned)*payload;
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): hid_dev_count=%d\n",
-				__func__, hid_dev_count);
-			hid_devices = kmalloc(hid_dev_count *
-				sizeof(struct device_info), GFP_KERNEL);
-			if (hid_devices)
-				memset(hid_devices, 0, hid_dev_count *
-					sizeof(struct device_info));
-
-			for (i = 0; i < hid_dev_count; ++i) {
-				if (1 + sizeof(struct device_info) * i >=
-						payload_len) {
-					dev_err(&hid_heci_cl->device->dev,
-						"[hid-ish]: [ENUM_DEVICES]:");
-					dev_err(&hid_heci_cl->device->dev,
-						" content size %lu ", 1 +
-						sizeof(struct device_info) *
-						i);
-					dev_err(&hid_heci_cl->device->dev,
-						"is bigger than ");
-					dev_err(&hid_heci_cl->device->dev,
-						"payload_len %u\n",
-						(unsigned)payload_len);
-				}
-
-				if (1 + sizeof(struct device_info) * i >=
-						data_len)
-					break;
-
-				dev_info = (struct device_info *)(payload + 1 +
-					sizeof(struct device_info) * i);
-				ISH_DBG_PRINT(KERN_ALERT
-					"[hid-ish]: %s(): [%d] -- dev_id=%08X dev_class=%02X pid=%04X vid=%04X\n",
-					__func__, i, dev_info->dev_id,
-					dev_info->dev_class, dev_info->pid,
-					dev_info->vid);
-				if (hid_devices)
-					memcpy(hid_devices + i, dev_info,
-						sizeof(struct device_info));
-			}
-
-			enum_devices_done = 1;
-			if (waitqueue_active(&init_wait))
-				wake_up(&init_wait);
-
-			break;
-
-		case HOSTIF_GET_HID_DESCRIPTOR:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_GET_HID_DESCRIPTOR [cur_pos=%u] [%02X %02X %02X %02X]\n",
-				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): dump HID descriptor\n",
-				__func__);
-			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
-					init_done)) {
-				++bad_recv_cnt;
-				report_bad_packet(recv_msg, cur_pos,
-					payload_len);
-				heci_hw_reset(hid_heci_cl->dev);
-				break;
-			}
-			for (i = 0; i < payload_len; ++i)
-				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
-			ISH_DBG_PRINT(KERN_ALERT "\n");
-			hid_descr[cur_hid_dev] = kmalloc(payload_len,
-				GFP_KERNEL);
-			if (hid_descr[cur_hid_dev])
-				memcpy(hid_descr[cur_hid_dev], payload,
-					payload_len);
-			hid_descr_size[cur_hid_dev] = payload_len;
-
-			hid_descr_done = 1;
-			if (waitqueue_active(&init_wait))
-				wake_up(&init_wait);
-
-			break;
-
-		case HOSTIF_GET_REPORT_DESCRIPTOR:
-			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
-					init_done)) {
-				++bad_recv_cnt;
-				report_bad_packet(recv_msg, cur_pos,
-					payload_len);
-				heci_hw_reset(hid_heci_cl->dev);
-				break;
-			}
-			report_descr[cur_hid_dev] = kmalloc(payload_len,
-				GFP_KERNEL);
-			if (report_descr[cur_hid_dev])
-				memcpy(report_descr[cur_hid_dev], payload,
-					payload_len);
-			report_descr_size[cur_hid_dev] = payload_len;
-
-			report_descr_done = 1;
-			if (waitqueue_active(&init_wait))
-				wake_up(&init_wait);
-
-			break;
-
-		case HOSTIF_GET_FEATURE_REPORT:
-			report_type = HID_FEATURE_REPORT;
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_GET_FEATURE_REPORT\n",
-				__func__);
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): dump Get Feature Result\n",
-				__func__);
-			flush_cb(); /*each "GET_FEATURE_REPORT" ends a batch*/
-			goto	do_get_report;
-
-		case HOSTIF_GET_INPUT_REPORT:
-			report_type = HID_INPUT_REPORT;
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_GET_INPUT_REPORT\n",
-				__func__);
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): dump Get Input Result\n",
-				__func__);
-do_get_report:
-			for (i = 0; i < payload_len; ++i)
-				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
-			ISH_DBG_PRINT(KERN_ALERT "\n");
-
-
-			/* Get index of device that matches this id */
-			for (i = 0; i < num_hid_devices; ++i)
-				if (recv_msg->hdr.device_id ==
-						hid_devices[i].dev_id)
-					if (hid_sensor_hubs[i] != NULL) {
-						hid_input_report(
-							hid_sensor_hubs[i],
-							report_type, payload,
-							payload_len, 0);
-						break;
-					}
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): received input report, upstreaming\n",
-				__func__);
-			get_report_done = 1;
-			if (waitqueue_active(&heci_hid_wait))
-				wake_up(&heci_hid_wait);
-			break;
-
-		case HOSTIF_SET_FEATURE_REPORT:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): HOSTIF_SET_FEATURE_REPORT returned status=%02X\n",
-				__func__, recv_msg->hdr.status);
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): received feature report, upstreaming\n",
-				__func__);
-			get_report_done = 1;
-			if (waitqueue_active(&heci_hid_wait))
-				wake_up(&heci_hid_wait);
-			break;
-
-		case HOSTIF_PUBLISH_INPUT_REPORT:
-			report_type = HID_INPUT_REPORT;
-			do {
-				ISH_DBG_PRINT(KERN_ALERT
-					"[hid-ish]: %s(): received ASYNC DATA REPORT [payload_len=%u]. Dump data:\n",
-					__func__, (unsigned)payload_len);
-				for (i = 0; i < payload_len; ++i)
-					ISH_DBG_PRINT(KERN_ALERT "%02X\n",
-						payload[i]);
-			} while (0);
-
-			for (i = 0; i < num_hid_devices; ++i)
-				if (recv_msg->hdr.device_id ==
-						hid_devices[i].dev_id)
-					if (hid_sensor_hubs[i] != NULL)
-						hid_input_report(
-							hid_sensor_hubs[i],
-							report_type, payload,
-							payload_len, 0);
-			break;
-
-		case HOSTIF_PUBLISH_INPUT_REPORT_LIST:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_PUBLISH_INPUT_REPORT_LIST\n",
-				__func__);
-
-			report_type = HID_INPUT_REPORT;
-			reports_list = (struct report_list *)payload;
-			reports = (char *)reports_list->reports;
-
-			for (j = 0; j < reports_list->num_of_reports; j++) {
-				recv_msg = (struct hostif_msg *)(reports +
-					sizeof(uint16_t));
-				report_len = *(uint16_t *)reports;
-				payload = reports + sizeof(uint16_t) +
-					sizeof(struct hostif_msg_hdr);
-				payload_len = report_len -
-					sizeof(struct hostif_msg_hdr);
-
-				ISH_DBG_PRINT(KERN_ALERT
-					"[hid-ish]: %s(): report #%d, report_len: %d, payload_len: %d, device_id: %d, payload Data\n",
-					__func__, j, (int)report_len,
-					(int)payload_len,
-					(int)recv_msg->hdr.device_id);
-				for (i = 0; i < payload_len; ++i)
-					ISH_DBG_PRINT(KERN_ALERT "%02X ",
-						payload[i]);
-				ISH_DBG_PRINT(KERN_ALERT "\n");
-
-				for (i = 0; i < num_hid_devices; ++i)
-					if (recv_msg->hdr.device_id ==
-							hid_devices[i].dev_id &&
-							hid_sensor_hubs[i] !=
-							NULL) {
-						hid_input_report(
-							hid_sensor_hubs[i],
-							report_type,
-							payload, payload_len,
-							0);
-					}
-
-				reports += sizeof(uint16_t) + report_len;
-			}
-			break;
-
-		}
-
-		if (!cur_pos && cur_pos + payload_len +
-				sizeof(struct hostif_msg) < total_len)
-			++multi_packet_cnt;
-
-		cur_pos += payload_len + sizeof(struct hostif_msg);
-		payload += payload_len + sizeof(struct hostif_msg);
-
-	} while (cur_pos < total_len);
-	may_send = 1;
-}
-
-
-void ish_cl_event_cb(struct heci_cl_device *device, u32 events, void *context)
-{
-	size_t r_length;
-	struct heci_cl_rb *rb_in_proc;
-	unsigned long	flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s() +++\n", __func__);
-
-	if (!hid_heci_cl)
-		return;
-
-	spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
-	while (!list_empty(&hid_heci_cl->in_process_list.list)) {
-		rb_in_proc = list_entry(hid_heci_cl->in_process_list.list.next,
-			struct heci_cl_rb, list);
-		list_del_init(&rb_in_proc->list);
-		spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock,
-			flags);
-
-		if (!rb_in_proc->buffer.data) {
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): !rb_in_proc-->buffer.data, something's wrong\n",
-				__func__);
-			return;
-		}
-		r_length = rb_in_proc->buf_idx;
-		ISH_DBG_PRINT(KERN_ALERT
-			"%s(): OK received buffer of %u length\n", __func__,
-			(unsigned)r_length);
-
-		/* decide what to do with received data */
-		process_recv(rb_in_proc->buffer.data, r_length);
-
-		heci_io_rb_recycle(rb_in_proc);
-		spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
-	}
-	spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock, flags);
-}
-
-void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len,
-	int report_id)
-{
-	int	rv;
-	struct hostif_msg *msg = (struct hostif_msg *)buf;
-	int	i;
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): writing SET FEATURE REPORT\n", __func__);
-	memset(msg, 0, sizeof(struct hostif_msg));
-	msg->hdr.command = HOSTIF_SET_FEATURE_REPORT;
-	for (i = 0; i < num_hid_devices; ++i)
-		if (hid == hid_sensor_hubs[i]) {
-			msg->hdr.device_id = hid_devices[i].dev_id;
-			break;
-		}
-	if (i == num_hid_devices)
-		return;
-
-	rv = heci_cl_send(hid_heci_cl, buf, len);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
-}
-
-
-void hid_heci_get_report(struct hid_device *hid, int report_id, int report_type)
-{
-	int	rv;
-	static unsigned char	buf[10];
-	unsigned	len;
-	struct hostif_msg_to_sensor *msg = (struct hostif_msg_to_sensor *)buf;
-	int	i;
-
-	len = sizeof(struct hostif_msg_to_sensor);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): writing GET REPORT of type: %d\n", __func__,
-		report_type);
-	memset(msg, 0, sizeof(struct hostif_msg_to_sensor));
-	msg->hdr.command = (report_type == HID_FEATURE_REPORT) ?
-		HOSTIF_GET_FEATURE_REPORT : HOSTIF_GET_INPUT_REPORT;
-	for (i = 0; i < num_hid_devices; ++i)
-		if (hid == hid_sensor_hubs[i]) {
-			msg->hdr.device_id = hid_devices[i].dev_id;
-			/*
-			 * FIXME - temporary when single collection exists,
-			 * then has to be part of hid_device custom fields
-			 */
-			break;
-		}
-	if (i == num_hid_devices)
-		return;
-
-	msg->report_id = report_id;
-	rv = heci_cl_send(hid_heci_cl, buf, len);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
-}
-
-struct work_struct my_work;
-
-int	hid_heci_cl_probe(struct heci_cl_device *cl_device,
-	const struct heci_cl_device_id *id)
-{
-	int	rv;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	if (!cl_device)
-		return	-ENODEV;
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): dev != NULL && dev->cl != NULL /* OK */\n",
-		__func__);
-	if (uuid_le_cmp(ish_heci_guid,
-			cl_device->fw_client->props.protocol_name) != 0) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): device doesn't match\n",
-			__func__);
-		return	-ENODEV;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): device matches!\n", __func__);
-	hid_heci_cl = heci_cl_allocate(cl_device->heci_dev);
-	if (!hid_heci_cl)
-		return	-ENOMEM;
-
-	rv = heci_cl_link(hid_heci_cl, HECI_HOST_CLIENT_ID_ANY);
-	if (rv)
-		return	-ENOMEM;
-
-	hid_heci_client_found = 1;
-	if (waitqueue_active(&init_wait))
-		wake_up(&init_wait);
-
-	schedule_work(&my_work);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() enqueue init_work function\n",
-		__func__);
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return	0;
-
-	/*
-	 * Linux generic drivers framework doesn't like probe() functions
-	 * to start kernel threads
-	 */
-}
-
-
-int     hid_heci_cl_remove(struct heci_cl_device *dev)
-{
-	int i;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	heci_hid_remove();
-	hid_heci_client_found = 0;
-	hid_heci_cl = NULL;
-
-	for (i = 0; i < num_hid_devices ; ++i) {
-		/* kfree(NULL) is safe */
-		kfree(hid_descr[i]);
-		/* kfree(NULL) is safe */
-		kfree(report_descr[i]);
-	}
-	num_hid_devices = 0;
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return  0;
-}
-
-
-struct heci_cl_driver	hid_heci_cl_driver = {
-	.name = "ish",
-	.probe = hid_heci_cl_probe,
-	.remove = hid_heci_cl_remove,
-};
-
-
-/****************************************************************/
-
-static void workqueue_init_function(struct work_struct *work)
-{
-	int	rv;
-	static unsigned char	buf[4096];
-	unsigned	len;
-	struct hostif_msg	*msg = (struct hostif_msg *)buf;
-	int	i;
-	struct heci_device	*dev;
-	int	retry_count;
-
-	init_done = 0;
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() in workqueue func, continue initialization process\n",
-		__func__);
-
-	if (!hid_heci_client_found)
-		wait_event_timeout(init_wait, hid_heci_client_found, 30 * HZ);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() completed waiting for hid_heci_client_found[=%d]\n",
-		__func__, hid_heci_client_found);
-
-	if (!hid_heci_client_found) {
-		dev_err(NULL, "[hid-ish]: timed out waiting for hid_heci_client_found\n");
-		rv = -ENODEV;
-		goto	ret;
-	}
-
-	dev = hid_heci_cl->dev;
-
-	/* Connect to FW client */
-	hid_heci_cl->rx_ring_size = RX_RING_SIZE;
-	hid_heci_cl->tx_ring_size = TX_RING_SIZE;
-
-	i = heci_me_cl_by_uuid(dev, &ish_heci_guid);
-	hid_heci_cl->me_client_id = dev->me_clients[i].client_id;
-	hid_heci_cl->state = HECI_CL_CONNECTING;
-
-	rv = heci_cl_connect(hid_heci_cl);
-	if (rv)
-		goto	ret;
-
-	/* Register read callback */
-	heci_register_event_cb(hid_heci_cl->device, ish_cl_event_cb, NULL);
-
-#if 0
-	/*
-	 * Wait until we can send without risking flow-control break scenario
-	 * (sending OUR FC ahead of message, so that FW will respond)
-	 * We probably need here only a small delay in order to let our FC
-	 * to be sent over to FW
-	 */
-	schedule_timeout(WAIT_FOR_SEND_SLICE);
-#endif
-
-	/* Send HOSTIF_DM_ENUM_DEVICES */
-	memset(msg, 0, sizeof(struct hostif_msg));
-	msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
-	len = sizeof(struct hostif_msg);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() writing HOSTIF_DM_ENUM_DEVICES len = %u\n",
-		__func__, len);
-	rv = heci_cl_send(hid_heci_cl, buf, len);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() heci_cl_send() returned %d\n",
-		__func__, rv);
-	if (rv)
-		goto	ret;
-
-	rv = 0;
-
-	retry_count = 0;
-	while (!enum_devices_done && retry_count < 10) {
-		wait_event_timeout(init_wait, enum_devices_done, 3 * HZ);
-		++retry_count;
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
-			enum_devices_done, retry_count);
-		if (!enum_devices_done) {
-			/* Send HOSTIF_DM_ENUM_DEVICES */
-			memset(msg, 0, sizeof(struct hostif_msg));
-			msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
-			len = sizeof(struct hostif_msg);
-			rv = heci_cl_send(hid_heci_cl, buf, len);
-		}
-	}
-	dev_err(&hid_heci_cl->device->dev,
-		"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
-		enum_devices_done, retry_count);
-
-	if (!enum_devices_done) {
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: timed out waiting for enum_devices_done\n");
-		rv = -ETIMEDOUT;
-		goto	ret;
-	}
-	if (!hid_devices) {
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: failed to allocate HID dev structures\n");
-		rv = -ENOMEM;
-		goto	ret;
-	}
-
-	/* Send GET_HID_DESCRIPTOR for each device */
-	num_hid_devices = hid_dev_count;
-	dev_warn(&hid_heci_cl->device->dev,
-		"[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n",
-		num_hid_devices);
-
-
-	for (i = 0; i < num_hid_devices /*hid_dev_count*/; ++i) {
-		cur_hid_dev = i;
-
-		/* Get HID descriptor */
-		hid_descr_done = 0;
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): [%d] writing HOSTIF_GET_HID_DESCRIPTOR\n",
-			__func__, i);
-		memset(msg, 0, sizeof(struct hostif_msg));
-		msg->hdr.command = HOSTIF_GET_HID_DESCRIPTOR;
-		msg->hdr.device_id = hid_devices[i].dev_id;
-		len = sizeof(struct hostif_msg);
-		rv = heci_cl_send(hid_heci_cl, buf, len);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_HID_DESCRIPTOR] returned %d\n",
-			__func__, rv);
-		rv = 0;
-#ifdef HOST_VIRTUALBOX
-		timed_wait_for(WAIT_FOR_SEND_SLICE, hid_descr_done);
-#else
-		if (!hid_descr_done)
-			wait_event_timeout(init_wait, hid_descr_done, 30 * HZ);
-#endif
-		if (!hid_descr_done) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: timed out waiting for hid_descr_done\n");
-			continue;
-		}
-
-		if (!hid_descr[i]) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: failed to allocate HID descriptor buffer\n");
-			continue;
-		}
-
-		/* Get report descriptor */
-		report_descr_done = 0;
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): [%d] writing HOSTIF_GET_REPORT_DESCRIPTOR\n",
-			__func__, i);
-		memset(msg, 0, sizeof(struct hostif_msg));
-		msg->hdr.command = HOSTIF_GET_REPORT_DESCRIPTOR;
-		msg->hdr.device_id = hid_devices[i].dev_id;
-		len = sizeof(struct hostif_msg);
-		rv = heci_cl_send(hid_heci_cl, buf, len);
-
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_REPORT_DESCRIPTOR] returned %d\n",
-			__func__, rv);
-		rv = 0;
-#ifdef HOST_VIRTUALBOX
-		timed_wait_for(WAIT_FOR_SEND_SLICE, report_descr_done);
-#else
-		if (!report_descr_done)
-			wait_event_timeout(init_wait, report_descr_done,
-				30 * HZ);
-#endif
-		if (!report_descr_done) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: timed out wait for report descr\n");
-			continue;
-		}
-
-		if (!report_descr[i]) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: failed to alloc report descr\n");
-			continue;
-		}
-
-		rv = heci_hid_probe(i);
-		if (rv) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: HID probe for #%u failed: %d\n",
-				i, rv);
-			continue;
-		}
-	} /* for() */
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish] %s() in workqueue func, finished initialization process\n",
-		__func__);
-
-ret:
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish] %s() :in ret label --- returning %d\n", __func__,
-		rv);
-	init_done = 1;
-}
-/****************************************************************/
-
-
-static int __init ish_init(void)
-{
-	int	rv;
-
-	ISH_INFO_PRINT(KERN_ERR "[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
-		__func__);
-	g_ish_print_log(
-		"[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
-		__func__);
-
-	init_waitqueue_head(&init_wait);
-	init_waitqueue_head(&heci_hid_wait);
-	INIT_WORK(&my_work, workqueue_init_function);
-
-	/* Register HECI client device driver - ISS */
-	rv = heci_cl_driver_register(&hid_heci_cl_driver);
-
-	return rv;
-
-}
-
-
-static void __exit ish_exit(void)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++\n", __func__);
-	heci_cl_driver_unregister(&hid_heci_cl_driver);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): unregistered from HECI bus\n", __func__);
-	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():---\n", __func__);
-}
-
-module_init(ish_init);
-module_exit(ish_exit);
-
-MODULE_DESCRIPTION("ISS HECI client driver");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/misc/intel-ish/heci-hid.c b/drivers/misc/intel-ish/heci-hid.c
deleted file mode 100644
index 5b3760a..0000000
--- a/drivers/misc/intel-ish/heci-hid.c
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * HECI-HID glue driver.
- *
- * Copyright (c) 2012-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/device.h>
-#include <linux/hid.h>
-#include <linux/module.h>
-#include <linux/timer.h>
-#include <linux/kthread.h>
-#include "heci-hid.h"
-#include "platform-config.h"
-#include "client.h"
-
-/*
- * TODO - figure out if this number is used for anything but assignment.
- * BUS_I2C is not
- */
-#define	BUS_HECI	0x44
-/* TODO: just to bootstrap, numbers will probably change */
-#define	ISH_HID_VENDOR	0x8086
-#define	ISH_HID_PRODUCT	0x22D8
-#define	ISH_HID_VERSION	0x0200
-
-static int heci_hid_parse(struct hid_device *hid)
-{
-	int	rv;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
-
-	rv = hid_parse_report(hid, report_descr[cur_hid_dev],
-		report_descr_size[cur_hid_dev]);
-	if (rv) {
-		ISH_DBG_PRINT(KERN_ALERT
-			"[heci-hid] %s(): parsing report descriptor failed\n",
-			__func__);
-		return	rv;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[heci-hid] %s(): parsing report descriptor succeeded\n",
-		__func__);
-	return 0;
-}
-
-static int heci_hid_start(struct hid_device *hid)
-{
-	return 0;
-}
-
-/* should we free smth? */
-static void heci_hid_stop(struct hid_device *hid)
-{
-	return;
-}
-
-/* probably connect might be here (move from probe) */
-static int heci_hid_open(struct hid_device *hid)
-{
-	return 0;
-}
-
-
-/* naturally if connect in open, disconnect here */
-static void ish_heci_close(struct hid_device *hid)
-{
-	return;
-}
-
-static int heci_hid_power(struct hid_device *hid, int lvl)
-{
-	return 0;
-}
-
-
-
-static void heci_hid_request(struct hid_device *hid, struct hid_report *rep,
-	int reqtype)
-{
-	/* the specific report length, just HID part of it */
-	unsigned len = ((rep->size - 1) >> 3) + 1 + (rep->id > 0);
-	char *buf;
-	/* s32 checkValue = 0; */
-	/* int i = 0; */
-	unsigned header_size =  sizeof(struct hostif_msg);
-
-	len += header_size;
-
-	switch (reqtype) {
-	case HID_REQ_GET_REPORT:
-		hid_heci_get_report(hid, rep->id, rep->type);
-		break;
-	case HID_REQ_SET_REPORT:
-		/* Spare 7 bytes for 64b accesses thru
-		get/put_unaligned_le64() */
-		buf = kzalloc(len + 7, GFP_KERNEL);
-		if (!buf)
-			return;
-		hid_output_report(rep, buf + header_size);
-	/* checkValue = rep->field[3]->value[0]; */
-	/* ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): after hid_output_report value is %d\n",
-		__func__, checkValue);	 */
-	/* for(;i < len; i++) */
-	/*   ISH_DBG_PRINT("\n%d %d\n", i, (int) buf[i]); */
-		hid_heci_set_feature(hid, buf, len, rep->id);
-		kfree(buf);
-		break;
-	}
-
-	return;
-}
-
-
-static int heci_hid_hidinput_input_event(struct input_dev *dev,
-		unsigned int type, unsigned int code, int value)
-{
-	return 0;
-}
-
-
-static int heci_wait_for_response(struct hid_device *hid)
-{
-	ISH_DBG_PRINT(KERN_ALERT "%s() +++\n", __func__);
-#ifdef HOST_VIRTUALBOX
-	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, get_report_done, (10 * HZ));
-#else
-	if (!get_report_done)
-		wait_event_timeout(heci_hid_wait, get_report_done, 3 * HZ);
-
-#endif
-	if (!get_report_done) {
-		hid_err(hid, "timeout waiting for response from HECI device\n");
-		return -1;
-	}
-
-	get_report_done = 0;
-	return 0;
-}
-
-
-static struct hid_ll_driver heci_hid_ll_driver = {
-	.parse = heci_hid_parse,
-	.start = heci_hid_start,
-	.stop = heci_hid_stop,
-	.open = heci_hid_open,
-	.close = ish_heci_close,
-	.power = heci_hid_power,
-	.request = heci_hid_request,
-	.hidinput_input_event = heci_hid_hidinput_input_event,
-	.wait = heci_wait_for_response
-};
-
-
-struct tmp_heci_data {
-	int hdesc_length;
-	struct task_struct	*read_task;
-};
-
-static int heci_hid_get_raw_report(struct hid_device *hid,
-	unsigned char report_number, __u8 *buf, size_t count,
-	unsigned char report_type)
-{
-	return	0;
-}
-
-static int heci_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
-	size_t count, unsigned char report_type)
-{
-	return	0;
-}
-
-/*
- * probably the best way make it driver probe so it will create device with
- * itself as ll_driver, as usb and i2c do
- */
-int	heci_hid_probe(unsigned cur_hid_dev)
-{
-	int rv;
-	struct hid_device	*hid;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
-
-	hid = hid_allocate_device();
-	if (IS_ERR(hid)) {
-		rv = PTR_ERR(hid);
-		return	-ENOMEM;
-	}
-
-	hid_sensor_hubs[cur_hid_dev] = hid;
-
-	hid->ll_driver = &heci_hid_ll_driver;
-	hid->hid_get_raw_report = heci_hid_get_raw_report;
-	hid->hid_output_raw_report = heci_hid_output_raw_report;
-	hid->bus = BUS_HECI;
-	hid->version = le16_to_cpu(ISH_HID_VERSION);
-	hid->vendor = le16_to_cpu(ISH_HID_VENDOR);
-	hid->product = le16_to_cpu(ISH_HID_PRODUCT);
-
-	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX", "hid-heci",
-		hid->vendor, hid->product);
-
-	rv = hid_add_device(hid);
-	if (rv) {
-		if (rv != -ENODEV)
-			hid_err(hid, "[hid-heci]: can't add HID device: %d\n",
-				rv);
-		kfree(hid);
-		return	rv;
-	}
-
-#if 0
-	/* Initialize all reports */
-	list_for_each_entry(report,
-		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
-		hid_heci_get_report(hid, report->id, HID_FEATURE_REPORT);
-#endif
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
-	return 0;
-}
-
-void	heci_hid_remove(void)
-{
-	int	i;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
-	for (i = 0; i < num_hid_devices; ++i)
-		if (hid_sensor_hubs[i]) {
-			hid_destroy_device(hid_sensor_hubs[i]);
-			hid_sensor_hubs[i] = NULL;
-		}
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
-}
-
-void register_flush_cb(void (*flush_cb_func)(void))
-{
-	flush_cb = flush_cb_func;
-}
-EXPORT_SYMBOL_GPL(register_flush_cb);
-
diff --git a/drivers/misc/intel-ish/heci-hid.h b/drivers/misc/intel-ish/heci-hid.h
deleted file mode 100644
index 62c1e5b..0000000
--- a/drivers/misc/intel-ish/heci-hid.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * HECI-HID glue driver's definitions.
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-#ifndef HECI_HID__H
-#define	HECI_HID__H
-
-/*
- * Constraint 1: currently we support only 1 ISS HW controller in a system
- */
-
-static const uuid_le ish_heci_guid = UUID_LE(0x33AECD58, 0xB679, 0x4E54,
-						0x9B, 0xD9, 0xA0, 0x4D, 0x34,
-						0xF0, 0xC2, 0x26);
-
-extern wait_queue_head_t	heci_hid_wait;
-
-/*flush notification*/
-extern void (*flush_cb)(void);
-
-struct hostif_msg_hdr {
-	uint8_t	command;	/* Bit 7: is_response */
-#define	CMD_MASK	0x7F
-#define	IS_RESPONSE	0x80
-	uint8_t	device_id;
-	uint8_t	status;
-	uint8_t	flags;
-	uint16_t	size;
-} __packed;
-
-struct hostif_msg {
-	struct hostif_msg_hdr	hdr;
-} __packed;
-
-struct hostif_msg_to_sensor {
-	struct hostif_msg_hdr	hdr;
-	uint8_t	report_id;
-} __packed;
-
-struct device_info {
-	uint32_t	dev_id;
-	uint8_t		dev_class;
-	uint16_t	pid;
-	uint16_t	vid;
-} __packed;
-
-#if 0
-/* Needed? */
-struct heci_client {
-	uint32_t	max_msg_len;
-	uint8_t		proto_ver;
-} __packed;
-#endif
-
-struct heci_version {
-	uint8_t	major;
-	uint8_t	minor;
-	uint8_t	hotfix;
-	uint16_t	build;
-} __packed;
-
-/*
- * struct for heci aggregated input data
- */
-struct report_list {
-	uint16_t total_size;
-	uint8_t  num_of_reports;
-	uint8_t  flags;
-	struct {
-		uint16_t  size_of_report;
-		uint8_t report[1];
-	} __packed reports[1];
-} __packed;
-
-/* HOSTIF commands */
-#define	HOSTIF_HID_COMMAND_BASE		0
-#define	HOSTIF_GET_HID_DESCRIPTOR	0
-#define	HOSTIF_GET_REPORT_DESCRIPTOR	1
-#define HOSTIF_GET_FEATURE_REPORT	2
-#define	HOSTIF_SET_FEATURE_REPORT	3
-#define	HOSTIF_GET_INPUT_REPORT		4
-#define	HOSTIF_PUBLISH_INPUT_REPORT	5
-/*#define	HOSTIF_GET_OUTPUT_REPORT	6*/
-/*#define	HOSTIF_SET_OUTPUT_REPORT	7*/
-#define	HOSTIF_PUBLISH_INPUT_REPORT_LIST	6
-#define	HOSTIF_DM_COMMAND_BASE		32
-#define	HOSTIF_DM_ENUM_DEVICES		33
-#define	HOSTIF_DM_ADD_DEVICE		34
-
-/* Meaning, too large data source = "over 9000?" :-) */
-#define	MAX_DATA_BUF	9000
-
-#define	MAX_HID_DEVICES	32
-
-#include "utils.h"
-
-extern unsigned char	*report_descr[MAX_HID_DEVICES];
-extern int	report_descr_size[MAX_HID_DEVICES];
-extern struct device_info	*hid_devices;
-extern int	may_send;
-extern int	get_report_done; /* Get Feature/Input report complete flag */
-extern unsigned	cur_hid_dev;
-extern struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
-extern unsigned	num_hid_devices;
-extern struct heci_cl  *hid_heci_cl;	/* HECI client */
-
-void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len,
-	int report_id);
-void hid_heci_get_report(struct hid_device *hid, int report_id,
-	int report_type);
-
-int	heci_hid_probe(unsigned cur_hid_dev);
-void	heci_hid_remove(void);
-
-/*flush notification*/
-void register_flush_cb(void (*flush_cb_func)(void));
-
-/*********** Locally redirect ISH_DBG_PRINT **************/
-void g_ish_print_log(char *format, ...);
-/*********************************************************/
-
-#endif	/* HECI_HID__H */
-
diff --git a/drivers/misc/intel-ish/heci_dev.h b/drivers/misc/intel-ish/heci_dev.h
deleted file mode 100644
index db8f36d..0000000
--- a/drivers/misc/intel-ish/heci_dev.h
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- * Most HECI provider device and HECI logic declarations
- *
- * Copyright (c) 2003-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef _HECI_DEV_H_
-#define _HECI_DEV_H_
-
-#include "platform-config.h"
-#include <linux/types.h>
-#include <linux/watchdog.h>
-#include <linux/poll.h>
-#include "bus.h"
-#include "hbm.h"
-#include <linux/spinlock.h>
-
-#define	IPC_PAYLOAD_SIZE	128
-#define HECI_RD_MSG_BUF_SIZE	IPC_PAYLOAD_SIZE
-/* Number of messages to be held in ISR->BH FIFO */
-#define	RD_INT_FIFO_SIZE	64
-#define	IPC_FULL_MSG_SIZE	132
-/*
- * Number of IPC messages to be held in Tx FIFO, to be sent by ISR -
- * Tx complete interrupt or RX_COMPLETE handler
- */
-#define	IPC_TX_FIFO_SIZE	512
-
-/*
- * Number of Maximum HECI Clients
- */
-#define HECI_CLIENTS_MAX 256
-
-/*
- * Number of File descriptors/handles
- * that can be opened to the driver.
- *
- * Limit to 255: 256 Total Clients
- * minus internal client for HECI Bus Messags
- */
-#define  HECI_MAX_OPEN_HANDLE_COUNT (HECI_CLIENTS_MAX - 1)
-
-/*
- * Internal Clients Number
- */
-#define HECI_HOST_CLIENT_ID_ANY        (-1)
-#define HECI_HBM_HOST_CLIENT_ID         0 /* not used, just for documentation */
-
-/* HECI device states */
-enum heci_dev_state {
-	HECI_DEV_INITIALIZING = 0,
-	HECI_DEV_INIT_CLIENTS,
-	HECI_DEV_ENABLED,
-	HECI_DEV_RESETTING,
-	HECI_DEV_DISABLED,
-	HECI_DEV_POWER_DOWN,
-	HECI_DEV_POWER_UP
-};
-
-const char *heci_dev_state_str(int state);
-
-/**
- * struct heci_me_client - representation of me (fw) client
- *
- * @props  - client properties
- * @client_id - me client id
- */
-struct heci_me_client {
-	struct heci_client_properties props;
-	u8 client_id;
-};
-
-
-struct heci_cl;
-
-/*
- * Intel HECI message data struct
- */
-struct heci_msg_data {
-	u32 size;
-	int	dma_flag;	/* non-0 if this is DMA msg buf */
-	unsigned char *data;
-};
-
-/**
- * struct heci_cl_rb - request block (was: callback) structure
- *
- * @cl - client who is running this operation
- * @type - request type
- */
-struct heci_cl_rb {
-	struct list_head list;
-	struct heci_cl *cl;
-	struct heci_msg_data buffer;
-	unsigned long buf_idx;
-	unsigned long read_time;
-};
-
-
-struct wr_msg_ctl_info {
-	void	(*ipc_send_compl)(void *);	/* Will be called with
-					'ipc_send_compl_prm' as parameter */
-	void	*ipc_send_compl_prm;
-	size_t length;
-	struct list_head	link;
-	unsigned char	inline_data[IPC_FULL_MSG_SIZE];
-};
-
-/** struct heci_hw_ops
- *
- * @host_is_ready    - query for host readiness
- * @hw_is_ready      - query if hw is ready
- * @hw_reset         - reset hw
- * @hw_start         - start hw after reset
- * @hw_config        - configure hw
- * @write            - write a message to FW
- */
-struct heci_hw_ops {
-	bool (*host_is_ready)(struct heci_device *dev);
-	bool (*hw_is_ready)(struct heci_device *dev);
-	int (*hw_reset)(struct heci_device *dev);
-	int (*ipc_reset)(struct heci_device *dev);
-	int (*hw_start)(struct heci_device *dev);
-	void (*hw_config)(struct heci_device *dev);
-	int (*write)(struct heci_device *dev, struct heci_msg_hdr *hdr,
-		unsigned char *buf);
-	int (*write_ex)(struct heci_device *dev, struct heci_msg_hdr *hdr,
-		void *msg, void(*ipc_send_compl)(void *),
-		void *ipc_send_compl_prm);
-	int (*read)(struct heci_device *dev, unsigned char *buffer,
-		unsigned long buffer_length);
-	u32 (*get_fw_status)(struct heci_device *dev);
-};
-
-#define PRINT_BUFFER_SIZE 204800
-
-/**
- * struct heci_device -  HECI private device struct
- *
- * @hbm_state - state of host bus message protocol
- * @mem_addr - mem mapped base register address
- */
-struct heci_device {
-	struct pci_dev *pdev;	/* pointer to pci device struct */
-	/*
-	 * lists of queues
-	 */
-
-	/* array of pointers to aio lists */
-	struct heci_cl_rb read_list;		/* driver read queue */
-	spinlock_t      read_list_spinlock;
-
-	/*
-	 * list of heci_cl's (formerly: files)
-	 */
-	struct list_head cl_list;
-	spinlock_t      cl_list_lock;
-	long open_handle_count;			/* Why's this?.. */
-
-	/*
-	 * lock for the device
-	 * for everything that doesn't have a dedicated spinlock
-	 */
-	spinlock_t	device_lock;
-
-	bool recvd_hw_ready;
-	/*
-	 * waiting queue for receive message from FW
-	 */
-	wait_queue_head_t wait_hw_ready;
-	wait_queue_head_t wait_hbm_recvd_msg;
-	wait_queue_head_t wait_dma_ready;
-
-	/*
-	 * heci device  states
-	 */
-	enum heci_dev_state dev_state;
-	enum heci_hbm_state hbm_state;
-
-	/* FIFO for input messages for BH processing */
-	unsigned char	rd_msg_fifo[RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE];
-	unsigned	rd_msg_fifo_head, rd_msg_fifo_tail;
-	spinlock_t	rd_msg_spinlock;
-	struct work_struct	bh_hbm_work;
-
-#if 0
-	/*
-	 * FIFO for output IPC messages. Includes also HECI/IPC header
-	 * to be supplied in DRBL (first dword)
-	 */
-	unsigned char	wr_msg_fifo[IPC_TX_FIFO_SIZE * IPC_FULL_MSG_SIZE];
-#endif
-	/*
-	 * Control info for IPC messages HECI/IPC sending FIFO -
-	 * list with inline data buffer
-	 * This structure will be filled with parameters submitted
-	 * by the caller glue layer
-	 * 'buf' may be pointing to the external buffer or to 'inline_data'
-	 * 'offset' will be initialized to 0 by submitting
-	 *
-	 * 'ipc_send_compl' is intended for use by clients that send fragmented
-	 * messages. When a fragment is sent down to IPC msg regs,
-	 * it will be called.
-	 * If it has more fragments to send, it will do it. With last fragment
-	 * it will send appropriate HECI "message-complete" flag.
-	 * It will remove the outstanding message
-	 * (mark outstanding buffer as available).
-	 * If counting flow control is in work and there are more flow control
-	 * credits, it can put the next client message queued in cl.
-	 * structure for IPC processing.
-	 *
-	 * (!) We can work on FIFO list or cyclic FIFO in an array
-	 */
-
-	struct wr_msg_ctl_info wr_processing_list_head, wr_free_list_head;
-	spinlock_t wr_processing_spinlock;	/* For both processing
-						   and free lists */
-	spinlock_t	out_ipc_spinlock;
-/*
-	unsigned	wr_msg_fifo_head, wr_msg_fifo_tail;
-	spinlock_t	wr_msg_spinlock;
-*/
-	struct hbm_version version;
-	struct heci_me_client *me_clients; /* Note: memory has to be allocated*/
-	DECLARE_BITMAP(me_clients_map, HECI_CLIENTS_MAX);
-	DECLARE_BITMAP(host_clients_map, HECI_CLIENTS_MAX);
-	u8 me_clients_num;
-	u8 me_client_presentation_num;
-	u8 me_client_index;
-	spinlock_t      me_clients_lock;
-	/* List of bus devices */
-	struct list_head device_list;
-	spinlock_t      device_list_lock;
-
-	/* buffer to save prints from driver */
-	unsigned char log_buffer[PRINT_BUFFER_SIZE];
-	size_t log_head;
-	size_t log_tail;
-	void (*print_log)(struct heci_device *dev, char *format, ...);
-	spinlock_t      log_spinlock;   /* spinlock to protect prints buffer */
-	unsigned long	max_log_sec, max_log_usec;
-
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-	struct dentry *dbgfs_dir;
-#endif /* CONFIG_DEBUG_FS */
-
-	/* Debug stats */
-	unsigned	ipc_hid_out_fc;
-	int	ipc_hid_in_msg;
-	unsigned	ipc_hid_in_fc;
-	int	ipc_hid_out_msg;
-	unsigned	ipc_hid_out_fc_cnt;
-	unsigned	ipc_hid_in_fc_cnt;
-
-	unsigned	ipc_rx_cnt;
-	unsigned long long	ipc_rx_bytes_cnt;
-	unsigned	ipc_tx_cnt;
-	unsigned long long	ipc_tx_bytes_cnt;
-
-	const struct heci_hw_ops *ops;
-
-	size_t	mtu;
-	u32     heci_msg_hdr;
-	char hw[0] __aligned(sizeof(void *));
-};
-
-/*
- * heci init function prototypes
- */
-void heci_device_init(struct heci_device *dev);
-void heci_reset(struct heci_device *dev, int interrupts);
-int heci_start(struct heci_device *dev);
-void heci_stop(struct heci_device *dev);
-void	heci_device_disable(struct heci_device *dev);
-
-static inline unsigned long heci_secs_to_jiffies(unsigned long sec)
-{
-	return sec * HZ;	/*msecs_to_jiffies(sec * MSEC_PER_SEC);*/
-}
-
-/*
- * Register Access Function
- */
-static inline void heci_hw_config(struct heci_device *dev)
-{
-	dev->ops->hw_config(dev);
-}
-
-static inline int heci_ipc_reset(struct heci_device *dev)
-{
-	return dev->ops->ipc_reset(dev);
-}
-
-static inline int heci_hw_reset(struct heci_device *dev)
-{
-	return dev->ops->hw_reset(dev);
-}
-
-static inline int heci_hw_start(struct heci_device *dev)
-{
-	return dev->ops->hw_start(dev);
-}
-
-static inline bool heci_host_is_ready(struct heci_device *dev)
-{
-	return dev->ops->host_is_ready(dev);
-}
-
-static inline bool heci_hw_is_ready(struct heci_device *dev)
-{
-	return dev->ops->hw_is_ready(dev);
-}
-
-static inline int heci_write_message(struct heci_device *dev,
-	struct heci_msg_hdr *hdr, unsigned char *buf)
-{
-	return dev->ops->write_ex(dev, hdr, buf, NULL, NULL);
-}
-
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-int heci_dbgfs_register(struct heci_device *dev, const char *name);
-void heci_dbgfs_deregister(struct heci_device *dev);
-#else
-static inline int heci_dbgfs_register(struct heci_device *dev, const char *name)
-{
-	return 0;
-}
-static inline void heci_dbgfs_deregister(struct heci_device *dev) {}
-#endif /* CONFIG_DEBUG_FS */
-
-
-int heci_register(struct heci_device *dev);
-void heci_deregister(struct heci_device *dev);
-
-void    heci_bus_remove_all_clients(struct heci_device *heci_dev);
-
-#define HECI_HDR_FMT "hdr:host=%02d me=%02d len=%d comp=%1d"
-#define HECI_HDR_PRM(hdr)		\
-	((hdr)->host_addr, (hdr)->me_addr,	\
-	(hdr)->length, (hdr)->msg_complete)
-
-#endif /*_HECI_DEV_H_*/
-
diff --git a/drivers/misc/intel-ish/hid-sens-ids.h b/drivers/misc/intel-ish/hid-sens-ids.h
index bd866f5..b9fe6c7 100644
--- a/drivers/misc/intel-ish/hid-sens-ids.h
+++ b/drivers/misc/intel-ish/hid-sens-ids.h
@@ -8,7 +8,7 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
  * You should have received a copy of the GNU General Public License along with
@@ -19,8 +19,6 @@
 #ifndef _HID_SENSORS_IDS_H
 #define _HID_SENSORS_IDS_H
 
-/***************************/
-
 #define HID_MAX_PHY_DEVICES					0xFF
 
 /* Accel 3D (200073) */
@@ -125,234 +123,233 @@
 #define HID_USAGE_SENSOR_PROP_RANGE_MAXIMUM			0x200314
 #define HID_USAGE_SENSOR_PROP_RANGE_MINIMUM			0x200315
 #define HID_USAGE_SENSOR_PROP_REPORT_STATE			0x200316
-#define HID_USAGE_SENSOR_PROY_POWER_STATE			0x200319
+#define HID_USAGE_SENSOR_PROP_POWER_STATE			0x200319
 
 /* Per data field properties */
-#define HID_USAGE_SENSOR_DATA_MOD_NONE					0x00
-#define HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS		0x1000
+#define HID_USAGE_SENSOR_DATA_MOD_NONE				0x00
+#define HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS	0x1000
 
 /* Power state enumerations */
-#define HID_USAGE_SENSOR_PROP_POWER_STATE_UNDEFINED_ENUM       0x200850
-#define HID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM   0x200851
-#define HID_USAGE_SENSOR_PROP_POWER_STATE_D1_LOW_POWER_ENUM    0x200852
-#define HID_USAGE_SENSOR_PROP_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM 0x200853
-#define HID_USAGE_SENSOR_PROP_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM 0x200854
-#define HID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM    0x200855
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_UNDEFINED_ENUM	0x200850
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM	0x200851
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D1_LOW_POWER_ENUM	0x200852
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM	0x200853
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM	0x200854
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM	0x200855
 
 /* Report State enumerations */
-#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM   0x200840
-#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM  0x200841
-
-/**************************/
+#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM	0x200840
+#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM	0x200841
 
-
-#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_RELATIVE_HUMIDITY 0x200433
-#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_TEMPERATURE 0x200434
-#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_DIRECTION 0x200435
-#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_SPEED 0x200436
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_RELATIVE_HUMIDITY	0x200433
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_TEMPERATURE		0x200434
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_DIRECTION	0x200435
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_SPEED		0x200436
 /* property usages (get/set feature report) */
-#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL 0x200440
-#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL_REFERENCE_PRESSURE 0x200441
+#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL			0x200440
+#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL_REFERENCE_PRESSURE	0x200441
 
 /* data type motion */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_MOTION 0x200450
-#define HID_USAGE_SENSOR_DATA_MOTION_STATE 0x200451
-#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION 0x200452
-#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_X_AXIS 0x200453
-#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Y_AXIS 0x200454
-#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Z_AXIS 0x200455
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY 0x200456
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_X_AXIS 0x200457
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Y_AXIS 0x200458
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Z_AXIS 0x200459
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION 0x20045A
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_X_AXIS 0x20045B
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Y_AXIS 0x20045C
-#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Z_AXIS 0x20045D
-#define HID_USAGE_SENSOR_DATA_MOTION_SPEED 0x20045E
-#define HID_USAGE_SENSOR_DATA_MOTION_INTENSITY 0x20045F
+#define HID_USAGE_SENSOR_DATA_MOTION				0x200450
+#define HID_USAGE_SENSOR_DATA_MOTION_STATE			0x200451
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION		0x200452
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_X_AXIS	0x200453
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Y_AXIS	0x200454
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Z_AXIS	0x200455
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY		0x200456
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_X_AXIS	0x200457
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Y_AXIS	0x200458
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Z_AXIS	0x200459
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION		0x20045A
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_X_AXIS	0x20045B
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Y_AXIS	0x20045C
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Z_AXIS	0x20045D
+#define HID_USAGE_SENSOR_DATA_MOTION_SPEED			0x20045E
+#define HID_USAGE_SENSOR_DATA_MOTION_INTENSITY			0x20045F
 
 /* data type orientation */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_ORIENTATION 0x200470
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING 0x200471
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_X 0x200472
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Y 0x200473
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Z 0x200474
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_MAGNETIC_NORTH 0x200475
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_TRUE_NORTH 0x200476
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_NORTH 0x200477
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_TRUE_NORTH 0x200478
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE 0x200479
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_X 0x20047A
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Y 0x20047B
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Z 0x20047C
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_OUT_OF_RANGE 0x20047D
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT 0x20047E
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_X 0x20047F
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Y 0x200480
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Z 0x200481
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_ROTATION_MATRIX 0x200482
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_QUATERNION 0x200483
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX 0x200484
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_X_AXIS 0x200485
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Y_AXIS 0x200486
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Z_AXIS 0x200487
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY 0x200488
+#define HID_USAGE_SENSOR_DATA_ORIENTATION			0x200470
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING	0x200471
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_X	0x200472
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Y	0x200473
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Z	0x200474
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_MAGNETIC_NORTH	0x200475
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_TRUE_NORTH	0x200476
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_NORTH	0x200477
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TRUE_NORTH		0x200478
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE		0x200479
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_X		0x20047A
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Y		0x20047B
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Z		0x20047C
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_OUT_OF_RANGE	0x20047D
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT			0x20047E
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_X		0x20047F
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Y		0x200480
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Z		0x200481
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_ROTATION_MATRIX	0x200482
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_QUATERNION		0x200483
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX		0x200484
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_X_AXIS	0x200485
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Y_AXIS	0x200486
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Z_AXIS	0x200487
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY	0x200488
 
 /* data type mechanical */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_MECHANICAL 0x200490
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_STATE 0x200491
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_ARRAY_STATES 0x200492
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_MULTIVALUE_SWITCH_VALUE 0x200493
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_FORCE 0x200494
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_ABSOLUTE_PRESSURE 0x200495
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_GAUGE_PRESSURE 0x200496
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_STRAIN 0x200497
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_WEIGHT 0x200498
+#define HID_USAGE_SENSOR_DATA_MECHANICA				0x200490
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_STATE	0x200491
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_ARRAY_STATES	0x200492
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_MULTIVALUE_SWITCH_VALUE	0x200493
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_FORCE			0x200494
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_ABSOLUTE_PRESSURE	0x200495
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_GAUGE_PRESSURE		0x200496
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_STRAIN			0x200497
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_WEIGHT			0x200498
 /* property usages (get/set feature report) */
-#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL 0x2004A0
-#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL_VIBRATION_STATE 0x2004A1
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_FORWARD 0x2004A2
-#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_BACKWARD 0x2004A3
+#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL			0x2004A0
+#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL_VIBRATION_STATE	0x2004A1
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_FORWARD	0x2004A2
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_BACKWARD	0x2004A3
 
 /* data type biometric */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_BIOMETRIC 0x2004B0
-#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PRESENCE 0x2004B1
-#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_RANGE 0x2004B2
-#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_OUT_OF_RANGE 0x2004B3
-#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_TOUCH_STATE 0x2004B4
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC				0x2004B0
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PRESENCE		0x2004B1
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_RANGE	0x2004B2
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_OUT_OF_RANGE	0x2004B3
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_TOUCH_STATE	0x2004B4
 
 /* data type light sensor */
 /* data field usages (input report) */
-/*#define HID_USAGE_SENSOR_DATA_LIGHT 0x2004D0*/
-#define HID_USAGE_SENSOR_DATA_LIGHT_ILLUMINANCE 0x2004D1
-#define HID_USAGE_SENSOR_DATA_LIGHT_COLOR_TEMPERATURE 0x2004D2
-#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY 0x2004D3
-#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_X 0x2004D4
-#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_Y 0x2004D5
-#define HID_USAGE_SENSOR_DATA_LIGHT_CONSUMER_IR_SENTENCE_RECEIVE 0x2004D6
+/*#define HID_USAGE_SENSOR_DATA_LIGHT				0x2004D0*/
+#define HID_USAGE_SENSOR_DATA_LIGHT_ILLUMINANCE			0x2004D1
+#define HID_USAGE_SENSOR_DATA_LIGHT_COLOR_TEMPERATURE		0x2004D2
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY		0x2004D3
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_X		0x2004D4
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_Y		0x2004D5
+#define HID_USAGE_SENSOR_DATA_LIGHT_CONSUMER_IR_SENTENCE_RECEIVE	0x2004D6
 /* property usages (get/set feature report) */
-#define HID_USAGE_SENSOR_PROPERTY_LIGHT 0x2004E0
-#define HID_USAGE_SENSOR_PROPERTY_LIGHT_CONSUMER_IR_SENTENCE_SEND 0x2004E1
+#define HID_USAGE_SENSOR_PROPERTY_LIGHT				0x2004E0
+#define HID_USAGE_SENSOR_PROPERTY_LIGHT_CONSUMER_IR_SENTENCE_SEND	0x2004E1
 
 /* data type scanner */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_SCANNER 0x2004F0
-#define HID_USAGE_SENSOR_DATA_SCANNER_RFID_TAG 0x2004F1
-#define HID_USAGE_SENSOR_DATA_SCANNER_NFC_SENTENCE_RECEIVE 0x2004F2
+#define HID_USAGE_SENSOR_DATA_SCANNER				0x2004F0
+#define HID_USAGE_SENSOR_DATA_SCANNER_RFID_TAG			0x2004F1
+#define HID_USAGE_SENSOR_DATA_SCANNER_NFC_SENTENCE_RECEIVE	0x2004F2
 /* property usages (get/set feature report) */
-#define HID_USAGE_SENSOR_PROPERTY_SCANNER 0x2004F8
-#define HID_USAGE_SENSOR_PROPERTY_SCANNER_NFC_SENTENCE_SEND 0x2004F9
+#define HID_USAGE_SENSOR_PROPERTY_SCANNER			0x2004F8
+#define HID_USAGE_SENSOR_PROPERTY_SCANNER_NFC_SENTENCE_SEND	0x2004F9
 
 /* data type electrical */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL 0x200500
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CAPACITANCE 0x200501
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CURRENT 0x200502
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_POWER 0x200503
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_INDUCTANCE 0x200504
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_RESISTANCE 0x200505
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_VOLTAGE 0x200506
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_FREQUENCY 0x200507
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERIOD 0x200508
-#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERCENT_OF_RANGE 0x200509
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL			0x200500
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CAPACITANCE		0x200501
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CURRENT		0x200502
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_POWER			0x200503
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_INDUCTANCE		0x200504
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_RESISTANCE		0x200505
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_VOLTAGE		0x200506
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_FREQUENCY		0x200507
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERIOD			0x200508
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERCENT_OF_RANGE	0x200509
 
 /* data type time */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_TIME 0x200520
-#define HID_USAGE_SENSOR_DATA_TIME_YEAR 0x200521
-#define HID_USAGE_SENSOR_DATA_TIME_MONTH 0x200522
-#define HID_USAGE_SENSOR_DATA_TIME_DAY 0x200523
-#define HID_USAGE_SENSOR_DATA_TIME_DAY_OF_WEEK 0x200524
-#define HID_USAGE_SENSOR_DATA_TIME_HOUR 0x200525
-#define HID_USAGE_SENSOR_DATA_TIME_MINUTE 0x200526
-#define HID_USAGE_SENSOR_DATA_TIME_SECOND 0x200527
-#define HID_USAGE_SENSOR_DATA_TIME_MILLISECOND 0x200528
-#define HID_USAGE_SENSOR_DATA_TIME_TIMESTAMP 0x200529
-#define HID_USAGE_SENSOR_DATA_TIME_JULIAN_DAY_OF_YEAR 0x20052A
+#define HID_USAGE_SENSOR_DATA_TIME				0x200520
+#define HID_USAGE_SENSOR_DATA_TIME_YEAR				0x200521
+#define HID_USAGE_SENSOR_DATA_TIME_MONTH			0x200522
+#define HID_USAGE_SENSOR_DATA_TIME_DAY				0x200523
+#define HID_USAGE_SENSOR_DATA_TIME_DAY_OF_WEEK			0x200524
+#define HID_USAGE_SENSOR_DATA_TIME_HOUR				0x200525
+#define HID_USAGE_SENSOR_DATA_TIME_MINUTE			0x200526
+#define HID_USAGE_SENSOR_DATA_TIME_SECOND			0x200527
+#define HID_USAGE_SENSOR_DATA_TIME_MILLISECOND			0x200528
+#define HID_USAGE_SENSOR_DATA_TIME_TIMESTAMP			0x200529
+#define HID_USAGE_SENSOR_DATA_TIME_JULIAN_DAY_OF_YEAR		0x20052A
 /* property usages (get/set feature report) */
-#define HID_USAGE_SENSOR_PROPERTY_TIME 0x200530
-#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_OFFSET_FROM_UTC 0x200531
-#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_NAME 0x200532
-#define HID_USAGE_SENSOR_PROPERTY_TIME_DAYLIGHT_SAVINGS_TIME_OBSERVED 0x200533
-#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_TRIM_ADJUSTMENT 0x200534
-#define HID_USAGE_SENSOR_PROPERTY_TIME_ARM_ALARM 0x200535
+#define HID_USAGE_SENSOR_PROPERTY_TIME				0x200530
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_OFFSET_FROM_UTC	0x200531
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_NAME		0x200532
+#define HID_USAGE_SENSOR_PROPERTY_TIME_DAYLIGHT_SAVINGS_TIME_OBSERVED	0x200533
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_TRIM_ADJUSTMENT	0x200534
+#define HID_USAGE_SENSOR_PROPERTY_TIME_ARM_ALARM		0x200535
 
 /* data type custom */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_CUSTOM 0x200540
-#define HID_USAGE_SENSOR_DATA_CUSTOM_USAGE 0x200541
-#define HID_USAGE_SENSOR_DATA_CUSTOM_BOOLEAN_ARRAY 0x200542
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE 0x200543
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_1 0x200544
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_2 0x200545
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_3 0x200546
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_4 0x200547
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_5 0x200548
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_6 0x200549
+#define HID_USAGE_SENSOR_DATA_CUSTOM				0x200540
+#define HID_USAGE_SENSOR_DATA_CUSTOM_USAGE			0x200541
+#define HID_USAGE_SENSOR_DATA_CUSTOM_BOOLEAN_ARRAY		0x200542
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE			0x200543
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_1			0x200544
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_2			0x200545
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_3			0x200546
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_4			0x200547
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_5			0x200548
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_6			0x200549
 
 #if 1 /* define vendor-specific (non-spec) custom datafields */
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_7 0x20054A
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_8 0x20054B
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_9 0x20054C
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_10 0x20054D
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_11 0x20054E
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_12 0x20054F
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_13 0x200550
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_14 0x200551
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_15 0x200552
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_16 0x200553
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_17 0x200554
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_18 0x200555
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_19 0x200556
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_20 0x200557
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_21 0x200558
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_22 0x200559
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_23 0x20055A
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_24 0x20055B
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_25 0x20055C
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_26 0x20055D
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_27 0x20055E
-#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_28 0x20055F
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_7			0x20054A
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_8			0x20054B
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_9			0x20054C
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_10			0x20054D
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_11			0x20054E
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_12			0x20054F
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_13			0x200550
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_14			0x200551
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_15			0x200552
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_16			0x200553
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_17			0x200554
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_18			0x200555
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_19			0x200556
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_20			0x200557
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_21			0x200558
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_22			0x200559
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_23			0x20055A
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_24			0x20055B
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_25			0x20055C
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_26			0x20055D
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_27			0x20055E
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_28			0x20055F
 #endif
 
-#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_MONITOR 0x200583
-#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_SYSTOLIC_BLOOD_PRESSURE 0x200584
-#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_DYSTOLIC_BLOOD_PRESSURE 0x200585
-#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_HEART_BEAT 0x200586
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_MONITOR	0x200583
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_SYSTOLIC_BLOOD_PRESSURE \
+								0x200584
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_DYSTOLIC_BLOOD_PRESSURE \
+								0x200585
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_HEART_BEAT	0x200586
 
 /* data type generic */
 /* data field usages (input report) */
-#define HID_USAGE_SENSOR_DATA_GENERIC 0x200560
-#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY 0x200561
-#define HID_USAGE_SENSOR_DATA_GENERIC_CATEGORY_GUID 0x200562
-#define HID_USAGE_SENSOR_DATA_GENERIC_TYPE_GUID 0x200563
-#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT_PROPERTYKEY 0x200564
-#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY_PROPERTYKEY 0x200565
-#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD_PROPERTYKEY 0x200566
-#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT 0x200567
-#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY 0x200568
-#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD 0x200569
-#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_INDEX 0x20056A
-#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_COUNT 0x20056B
-#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY_KIND 0x20056C
+#define HID_USAGE_SENSOR_DATA_GENERIC				0x200560
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY	0x200561
+#define HID_USAGE_SENSOR_DATA_GENERIC_CATEGORY_GUID		0x200562
+#define HID_USAGE_SENSOR_DATA_GENERIC_TYPE_GUID			0x200563
+#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT_PROPERTYKEY		0x200564
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY_PROPERTYKEY	0x200565
+#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD_PROPERTYKEY	0x200566
+#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT			0x200567
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY			0x200568
+#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD			0x200569
+#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_INDEX	0x20056A
+#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_COUNT	0x20056B
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY_KIND	0x20056C
 /* begin GorPK kind selectors */
-#define HID_USAGE_SENSOR_GORPK_KIND_CATEGORY 0x2008D0
-#define HID_USAGE_SENSOR_GORPK_KIND_TYPE 0x2008D1
-#define HID_USAGE_SENSOR_GORPK_KIND_EVENT 0x2008D2
-#define HID_USAGE_SENSOR_GORPK_KIND_PROPERTY 0x2008D3
-#define HID_USAGE_SENSOR_GORPK_KIND_DATAFIELD 0x2008D4
+#define HID_USAGE_SENSOR_GORPK_KIND_CATEGORY			0x2008D0
+#define HID_USAGE_SENSOR_GORPK_KIND_TYPE			0x2008D1
+#define HID_USAGE_SENSOR_GORPK_KIND_EVENT			0x2008D2
+#define HID_USAGE_SENSOR_GORPK_KIND_PROPERTY			0x2008D3
+#define HID_USAGE_SENSOR_GORPK_KIND_DATAFIELD			0x2008D4
 /* end GorPK kind selectors */
-#define HID_USAGE_SENSOR_DATA_GENERIC_GUID 0x20056D
-#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTYKEY 0x20056E
-#define HID_USAGE_SENSOR_DATA_GENERIC_TOP_LEVEL_COLLECTION_ID 0x20056F
-#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ID 0x200570
-#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ITEM_POSITION_INDEX 0x200571
-#define HID_USAGE_SENSOR_DATA_GENERIC_FIRMWARE_VARTYPE 0x200572
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID			0x20056D
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTYKEY		0x20056E
+#define HID_USAGE_SENSOR_DATA_GENERIC_TOP_LEVEL_COLLECTION_ID	0x20056F
+#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ID			0x200570
+#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ITEM_POSITION_INDEX	0x200571
+#define HID_USAGE_SENSOR_DATA_GENERIC_FIRMWARE_VARTYPE		0x200572
 
 /* Units */
 #define HID_USAGE_SENSOR_UNITS_NOT_SPECIFIED			0x00
@@ -401,186 +398,208 @@
 #define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_PERCENT_RANGE	0xD000
 #define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_PERCENT_REL	0xE000
 
-/*state usages*/
-#define HID_USAGE_SENSOR_STATE 0x200201
+/* state usages */
+#define HID_USAGE_SENSOR_STATE					0x200201
 /* state selectors */
-#define HID_USAGE_SENSOR_STATE_UNKNOWN_SEL 0x200800
-#define HID_USAGE_SENSOR_STATE_READY_SEL 0x200801
-#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_SEL 0x200802
-#define HID_USAGE_SENSOR_STATE_NO_DATA_SEL 0x200803
-#define HID_USAGE_SENSOR_STATE_INITIALIZING_SEL 0x200804
-#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_SEL 0x200805
-#define HID_USAGE_SENSOR_STATE_ERROR_SEL 0x200806
+#define HID_USAGE_SENSOR_STATE_UNKNOWN_SEL			0x200800
+#define HID_USAGE_SENSOR_STATE_READY_SEL			0x200801
+#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_SEL		0x200802
+#define HID_USAGE_SENSOR_STATE_NO_DATA_SEL			0x200803
+#define HID_USAGE_SENSOR_STATE_INITIALIZING_SEL			0x200804
+#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_SEL		0x200805
+#define HID_USAGE_SENSOR_STATE_ERROR_SEL			0x200806
 
 /* state enums */
-#define HID_USAGE_SENSOR_STATE_UNKNOWN_ENUM                                             0x01
-#define HID_USAGE_SENSOR_STATE_READY_ENUM                                               0x02
-#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_ENUM                                       0x03
-#define HID_USAGE_SENSOR_STATE_NO_DATA_ENUM                                             0x04
-#define HID_USAGE_SENSOR_STATE_INITIALIZING_ENUM                                        0x05
-#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_ENUM                                       0x06
-#define HID_USAGE_SENSOR_STATE_ERROR_ENUM                                               0x07
-
+#define HID_USAGE_SENSOR_STATE_UNKNOWN_ENUM			0x01
+#define HID_USAGE_SENSOR_STATE_READY_ENUM			0x02
+#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_ENUM		0x03
+#define HID_USAGE_SENSOR_STATE_NO_DATA_ENUM			0x04
+#define HID_USAGE_SENSOR_STATE_INITIALIZING_ENUM		0x05
+#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_ENUM		0x06
+#define HID_USAGE_SENSOR_STATE_ERROR_ENUM			0x07
 
 /* event usages */
-#define HID_USAGE_SENSOR_EVENT 0x200202
+#define HID_USAGE_SENSOR_EVENT					0x200202
 /* event selectors */
-#define HID_USAGE_SENSOR_EVENT_UNKNOWN_SEL 0x200810
-#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_SEL 0x200811
-#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_SEL 0x200812
-#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_SEL 0x200813
-#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_SEL 0x200814
-#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_SEL 0x200815
-#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_SEL 0x200816
-#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_SEL 0x200817
-#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL 0x200818
-#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_SEL        HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL
-#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL 0x200819
-#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_SEL       HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL 0x20081A
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_SEL        HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL 0x20081B
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_SEL        HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL 0x20081C
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_SEL       HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL 0x20081D
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_SEL       HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL
-#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_SEL 0x20081E
-#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_SEL 0x20081F
-#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_SEL 0x200820
+#define HID_USAGE_SENSOR_EVENT_UNKNOWN_SEL			0x200810
+#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_SEL		0x200811
+#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_SEL		0x200812
+#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_SEL			0x200813
+#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_SEL		0x200814
+#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_SEL		0x200815
+#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_SEL			0x200816
+#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_SEL			0x200817
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL	0x200818
+#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_SEL	\
+			HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL	0x200819
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_SEL	\
+			HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL		0x20081A
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_SEL	\
+			HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL	0x20081B
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_SEL	\
+			HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL	0x20081C
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_SEL	\
+			HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL	0x20081D
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_SEL	\
+			HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_SEL		0x20081E
+#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_SEL		0x20081F
+#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_SEL		0x200820
 
 /* event enums */
-#define HID_USAGE_SENSOR_EVENT_UNKNOWN_ENUM                                             0x01
-#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_ENUM                                       0x02
-#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_ENUM                                    0x03
-#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_ENUM                                        0x04
-#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_ENUM                                       0x05
-#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_ENUM                                  0x06
-#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_ENUM                                         0x07
-#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_ENUM                                         0x08
-#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM 0x200009
-#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_ENUM   HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM
-#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM 0x200A00
-#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_ENUM  HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM                          0x0B
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_ENUM   HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM                        0x0C
-#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_ENUM   HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM                         0x0D
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_ENUM  HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM                       0x0E
-#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_ENUM  HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM
-#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_ENUM                                     0x0F
-#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_ENUM                                  0x10
-#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_ENUM                                     0x11
-
+#define HID_USAGE_SENSOR_EVENT_UNKNOWN_ENUM			0x01
+#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_ENUM		0x02
+#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_ENUM		0x03
+#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_ENUM		0x04
+#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_ENUM		0x05
+#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_ENUM		0x06
+#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_ENUM			0x07
+#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_ENUM			0x08
+
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM	0x200009
+#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_ENUM	\
+			HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM	0x200A00
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_ENUM	\
+		HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM	0x0B
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_ENUM	\
+			HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM	0x0C
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_ENUM	\
+			HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM	0x0D
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_ENUM	\
+			HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM	0x0E
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_ENUM	\
+		HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_ENUM		0x0F
+#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_ENUM		0x10
+#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_ENUM		0x11
 
 /* property usages (get/set feature report) */
-#define HID_USAGE_SENSOR_PROPERTY 0x200300
-#define HID_USAGE_SENSOR_PROPERTY_FRIENDLY_NAME 0x200301
-#define HID_USAGE_SENSOR_PROPERTY_PERSISTENT_UNIQUE_ID 0x200302
-#define HID_USAGE_SENSOR_PROPERTY_SENSOR_STATUS 0x200303
-#define HID_USAGE_SENSOR_PROPERTY_MINIMUM_REPORT_INTERVAL 0x200304
-#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MANUFACTURER 0x200305
-#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MODEL 0x200306
-#define HID_USAGE_SENSOR_PROPERTY_SENSOR_SERIAL_NUMBER 0x200307
-#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DESCRIPTION 0x200308
-#define HID_USAGE_SENSOR_PROPERTY_SENSOR_CONNECTION_TYPE 0x200309
+#define HID_USAGE_SENSOR_PROPERTY				0x200300
+#define HID_USAGE_SENSOR_PROPERTY_FRIENDLY_NAME			0x200301
+#define HID_USAGE_SENSOR_PROPERTY_PERSISTENT_UNIQUE_ID		0x200302
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_STATUS			0x200303
+#define HID_USAGE_SENSOR_PROPERTY_MINIMUM_REPORT_INTERVAL	0x200304
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MANUFACTURER		0x200305
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MODEL			0x200306
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_SERIAL_NUMBER		0x200307
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DESCRIPTION		0x200308
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_CONNECTION_TYPE	0x200309
 /* begin connection type selectors */
-#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_SEL 0x200830
-#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_SEL 0x200831
-#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_SEL 0x200832
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_SEL	0x200830
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_SEL	0x200831
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_SEL	0x200832
 /* end connection type selectors */
 
 /* begin connection type enums */
-#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_ENUM                    0x01
-#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_ENUM                      0x02
-#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_ENUM                      0x03
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_ENUM	0x01
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_ENUM	0x02
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_ENUM	0x03
 /* end connection type enums */
 
-#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DEVICE_PATH 0x20030A
-#define HID_USAGE_SENSOR_PROPERTY_HARDWARE_REVISION 0x20030B
-#define HID_USAGE_SENSOR_PROPERTY_FIRMWARE_VERSION 0x20030C
-#define HID_USAGE_SENSOR_PROPERTY_RELEASE_DATE 0x20030D
-#define HID_USAGE_SENSOR_PROPERTY_REPORT_INTERVAL 0x20030E
-#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_ABS 0x20030F
-#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_RANGE_PCT 0x200310
-#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_REL_PCT 0x200311
-#define HID_USAGE_SENSOR_PROPERTY_ACCURACY 0x200312
-#define HID_USAGE_SENSOR_PROPERTY_RESOLUTION 0x200313
-#define HID_USAGE_SENSOR_PROPERTY_RANGE_MAXIMUM 0x200314
-#define HID_USAGE_SENSOR_PROPERTY_RANGE_MINIMUM 0x200315
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE 0x200316
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DEVICE_PATH		0x20030A
+#define HID_USAGE_SENSOR_PROPERTY_HARDWARE_REVISION		0x20030B
+#define HID_USAGE_SENSOR_PROPERTY_FIRMWARE_VERSION		0x20030C
+#define HID_USAGE_SENSOR_PROPERTY_RELEASE_DATE			0x20030D
+#define HID_USAGE_SENSOR_PROPERTY_REPORT_INTERVAL		0x20030E
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_ABS	0x20030F
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_RANGE_PCT	0x200310
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_REL_PCT	0x200311
+#define HID_USAGE_SENSOR_PROPERTY_ACCURACY			0x200312
+#define HID_USAGE_SENSOR_PROPERTY_RESOLUTION			0x200313
+#define HID_USAGE_SENSOR_PROPERTY_RANGE_MAXIMUM			0x200314
+#define HID_USAGE_SENSOR_PROPERTY_RANGE_MINIMUM			0x200315
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE		0x200316
 
 /* begin reporting state selectors */
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL 0x200840
-#define HID_USAGE_REPORTING_STATE_ON_NONE_SEL       HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL 0x200841
-#define HID_USAGE_REPORTING_STATE_ON_ALL_SEL        HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL 0x200842
-#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_SEL  HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_SEL 0x200843
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_SEL 0x200844
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_SEL 0x200845
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL	0x200840
+#define HID_USAGE_REPORTING_STATE_ON_NONE_SEL	\
+			HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL	0x200841
+#define HID_USAGE_REPORTING_STATE_ON_ALL_SEL	\
+			HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL	0x200842
+#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_SEL	\
+		HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_SEL	0x200843
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_SEL	0x200844
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_SEL \
+									0x200845
 /* end reporting state selectors */
 
 /* begin reporting state enums */
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM                        0x01
-#define HID_USAGE_REPORTING_STATE_ON_NONE_ENUM      HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM                       0x02
-#define HID_USAGE_REPORTING_STATE_ON_ALL_ENUM       HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM                 0x03
-#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_ENUM HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_ENUM                   0x04
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_ENUM                  0x05
-#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_ENUM            0x06
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM	0x01
+#define HID_USAGE_REPORTING_STATE_ON_NONE_ENUM	\
+			HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM	0x02
+#define HID_USAGE_REPORTING_STATE_ON_ALL_ENUM	\
+		HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM	0x03
+#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_ENUM	\
+		HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_ENUM	0x04
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_ENUM	0x05
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_ENUM \
+									0x06
 /* end reporting state enums */
 
-#define HID_USAGE_SENSOR_PROPERTY_SAMPLING_RATE 0x200317
-#define HID_USAGE_SENSOR_PROPERTY_RESPONSE_CURVE 0x200318
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE 0x200319
+#define HID_USAGE_SENSOR_PROPERTY_SAMPLING_RATE			0x200317
+#define HID_USAGE_SENSOR_PROPERTY_RESPONSE_CURVE		0x200318
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE			0x200319
 /* begin power state selectors */
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_SEL 0x200850
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_SEL 0x200851
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_SEL 0x200852
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_SEL 0x200853
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_SEL 0x200854
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_SEL 0x200855
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_SEL	0x200850
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_SEL	0x200851
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_SEL	0x200852
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_SEL	0x200853
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_SEL	0x200854
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_SEL	0x200855
 /* end power state selectors */
 
 /* begin power state enums */
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_ENUM                            0x01
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_ENUM                        0x02
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_ENUM                         0x03
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM                 0x04
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM                   0x05
-#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_ENUM                         0x06
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_ENUM	0x01
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_ENUM	0x02
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_ENUM	0x03
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM	0x04
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM	0x05
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_ENUM	0x06
 /* end power state enums */
 
 /* begin orientation magnetometer accuracy selectors */
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_LOW 0x02008E0
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_MEDIUM 0x02008E1
-#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_HIGH 0x02008E2
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_LOW	\
+								0x02008E0
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_MEDIUM	\
+								0x02008E1
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_HIGH	\
+								0x02008E2
 /* end orientation magnetometer accuracy selectors */
 
-#define HID_USAGE_SENSOR_DATA_GENERIC_UNIT_EXPONENT 0x200574
+#define HID_USAGE_SENSOR_DATA_GENERIC_UNIT_EXPONENT		0x200574
 /* begin unit exponent selectors */
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_0 0x200970
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_1 0x200971
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_2 0x200972
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_3 0x200973
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_4 0x200974
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_5 0x200975
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_6 0x200976
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_7 0x200977
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_8 0x200978
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_9 0x200979
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_A 0x20097A
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_B 0x20097B
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_C 0x20097C
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_D 0x20097D
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_E 0x20097E
-#define HID_USAGE_SENSOR_GENERIC_EXPONENT_F 0x20097F
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_0			0x200970
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_1			0x200971
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_2			0x200972
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_3			0x200973
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_4			0x200974
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_5			0x200975
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_6			0x200976
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_7			0x200977
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_8			0x200978
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_9			0x200979
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_A			0x20097A
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_B			0x20097B
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_C			0x20097C
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_D			0x20097D
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_E			0x20097E
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_F			0x20097F
 /* end unit exponent selectors */
 
-#endif
+#endif /* _HID_SENSORS_IDS_H */
diff --git a/drivers/misc/intel-ish/hid-strings-def.h b/drivers/misc/intel-ish/hid-strings-def.h
index c058f34..62e5fd1 100644
--- a/drivers/misc/intel-ish/hid-strings-def.h
+++ b/drivers/misc/intel-ish/hid-strings-def.h
@@ -1,7 +1,7 @@
 /*
  * HID sensor-related constants and names translations
  *
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,7 +9,7 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
diff --git a/drivers/misc/intel-ish/hw-ish-regs.h b/drivers/misc/intel-ish/hw-ish-regs.h
index e1c50cdd..e1dc5f1 100644
--- a/drivers/misc/intel-ish/hw-ish-regs.h
+++ b/drivers/misc/intel-ish/hw-ish-regs.h
@@ -1,7 +1,7 @@
 /*
  * ISH registers definitions
  *
- * Copyright (c) 2012-2015, Intel Corporation.
+ * Copyright (c) 2012-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,61 +9,63 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
-#ifndef _HECI_ISH_REGS_H_
-#define _HECI_ISH_REGS_H_
+#ifndef _ISHTP_ISH_REGS_H_
+#define _ISHTP_ISH_REGS_H_
 
 
-/* IPC PCI Offsets and sizes */
-#define IPC_REG_BASE             0x0000 /* Ish IPC Base Address */
-/*Peripheral Interrupt Status Register */
-#define IPC_REG_PISR             (IPC_REG_BASE + 0x00)
+/*** IPC PCI Offsets and sizes ***/
+/* ISH IPC Base Address */
+#define IPC_REG_BASE		0x0000
+/* Peripheral Interrupt Status Register */
+#define IPC_REG_PISR		(IPC_REG_BASE + 0x00)
 /* Peripheral Interrupt Mask Register */
-#define IPC_REG_PIMR             (IPC_REG_BASE + 0x04)
+#define IPC_REG_PIMR		(IPC_REG_BASE + 0x04)
 /* ISH Host Firmware status Register */
-#define IPC_REG_ISH_HOST_FWSTS   (IPC_REG_BASE + 0x34)
+#define IPC_REG_ISH_HOST_FWSTS	(IPC_REG_BASE + 0x34)
 /* Host Communication Register */
-#define IPC_REG_HOST_COMM        (IPC_REG_BASE + 0x38)
+#define IPC_REG_HOST_COMM	(IPC_REG_BASE + 0x38)
 /* Reset register */
-#define IPC_REG_ISH_RST          (IPC_REG_BASE + 0x44)
+#define IPC_REG_ISH_RST		(IPC_REG_BASE + 0x44)
 
-/*Inbound doorbell register Host to ISH */
-#define IPC_REG_HOST2ISH_DRBL    (IPC_REG_BASE + 0x48)
-/*Outbound doorbell register ISH to Host */
-#define IPC_REG_ISH2HOST_DRBL    (IPC_REG_BASE + 0x54)
+/* Inbound doorbell register Host to ISH */
+#define IPC_REG_HOST2ISH_DRBL	(IPC_REG_BASE + 0x48)
+/* Outbound doorbell register ISH to Host */
+#define IPC_REG_ISH2HOST_DRBL	(IPC_REG_BASE + 0x54)
 /* ISH to HOST message registers */
-#define IPC_REG_ISH2HOST_MSG     (IPC_REG_BASE + 0x60)
+#define IPC_REG_ISH2HOST_MSG	(IPC_REG_BASE + 0x60)
 /* HOST to ISH message registers */
-#define IPC_REG_HOST2ISH_MSG     (IPC_REG_BASE + 0xE0)
+#define IPC_REG_HOST2ISH_MSG	(IPC_REG_BASE + 0xE0)
 /* REMAP2 to enable DMA (D3 RCR) */
-#define	IPC_REG_ISH_RMP2	 (IPC_REG_BASE + 0x368)
+#define	IPC_REG_ISH_RMP2	(IPC_REG_BASE + 0x368)
 
-/* register bits - HISR */
+#define	IPC_REG_MAX		(IPC_REG_BASE + 0x400)
 
+/*** register bits - HISR ***/
 /* bit corresponds HOST2ISH interrupt in PISR and PIMR registers */
-#define IPC_INT_HOST2ISH_BIT            (1<<0)
+#define IPC_INT_HOST2ISH_BIT	(1<<0)
 /* bit corresponds ISH2HOST interrupt in PISR and PIMR registers */
-#define IPC_INT_ISH2HOST_BIT            (1<<3)
+#define IPC_INT_ISH2HOST_BIT	(1<<3)
 /* bit corresponds ISH2HOST busy clear interrupt in PIMR register */
-#define IPC_INT_ISH2HOST_CLR_MASK_BIT   (1<<11)
+#define IPC_INT_ISH2HOST_CLR_MASK_BIT	(1<<11)
 
 /* offset of ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
-#define IPC_INT_ISH2HOST_CLR_OFFS       (0)
+#define IPC_INT_ISH2HOST_CLR_OFFS	(0)
 
 /* bit corresponds ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
-#define IPC_INT_ISH2HOST_CLR_BIT        (1<<IPC_INT_ISH2HOST_CLR_OFFS)
+#define IPC_INT_ISH2HOST_CLR_BIT	(1<<IPC_INT_ISH2HOST_CLR_OFFS)
 
 /* bit corresponds busy bit in doorbell registers */
-#define IPC_DRBL_BUSY_OFFS              (31)
-#define IPC_DRBL_BUSY_BIT               (1<<IPC_DRBL_BUSY_OFFS)
+#define IPC_DRBL_BUSY_OFFS		(31)
+#define IPC_DRBL_BUSY_BIT		(1<<IPC_DRBL_BUSY_OFFS)
 
 #define	IPC_HOST_OWNS_MSG_OFFS		(30)
 
 /* A0: bit means that host owns MSGnn registers and is reading them.
-ISS FW may not write to them */
+ISH FW may not write to them */
 #define	IPC_HOST_OWNS_MSG_BIT		(1<<IPC_HOST_OWNS_MSG_OFFS)
 
 /*
@@ -77,7 +79,7 @@ ISS FW may not write to them */
 #define	IPC_HOSTCOMM_INT_EN_BIT		(1<<IPC_HOSTCOMM_INT_EN_OFFS)
 
 /*
- * as of now, both Host and ISS have ILUP at bit 0
+ * both Host and ISH have ILUP at bit 0
  * bit corresponds host ready bit in both status registers
  */
 #define IPC_ILUP_OFFS			(0)
@@ -87,7 +89,7 @@ ISS FW may not write to them */
  * FW status bits (relevant)
  */
 #define	IPC_FWSTS_ILUP		0x1
-#define	IPC_FWSTS_HECI_UP	(1<<1)
+#define	IPC_FWSTS_ISHTP_UP	(1<<1)
 #define	IPC_FWSTS_DMA0		(1<<16)
 #define	IPC_FWSTS_DMA1		(1<<17)
 #define	IPC_FWSTS_DMA2		(1<<18)
@@ -96,22 +98,22 @@ ISS FW may not write to them */
 #define	IPC_ISH_IN_DMA		\
 	(IPC_FWSTS_DMA0 | IPC_FWSTS_DMA1 | IPC_FWSTS_DMA2 | IPC_FWSTS_DMA3)
 
-/* bit corresponds host ready bit in ISS FW Status Register */
-#define IPC_ISH_HECI_READY_OFFS              (1)
-#define IPC_ISH_HECI_READY_BIT               (1<<IPC_ISH_HECI_READY_OFFS)
+/* bit corresponds host ready bit in ISH FW Status Register */
+#define IPC_ISH_ISHTP_READY_OFFS		(1)
+#define IPC_ISH_ISHTP_READY_BIT		(1<<IPC_ISH_ISHTP_READY_OFFS)
 
 #define	IPC_RMP2_DMA_ENABLED	0x1	/* Value to enable DMA, per D3 RCR */
 
 #define IPC_MSG_MAX_SIZE	0x80
 
 
-#define IPC_HEADER_LENGTH_MASK          (0x03FF)
-#define IPC_HEADER_PROTOCOL_MASK        (0x0F)
-#define IPC_HEADER_MNG_CMD_MASK         (0x0F)
+#define IPC_HEADER_LENGTH_MASK		0x03FF
+#define IPC_HEADER_PROTOCOL_MASK	0x0F
+#define IPC_HEADER_MNG_CMD_MASK		0x0F
 
-#define IPC_HEADER_LENGTH_OFFSET         0
-#define IPC_HEADER_PROTOCOL_OFFSET      10
-#define IPC_HEADER_MNG_CMD_OFFSET       16
+#define IPC_HEADER_LENGTH_OFFSET	0
+#define IPC_HEADER_PROTOCOL_OFFSET	10
+#define IPC_HEADER_MNG_CMD_OFFSET	16
 
 #define IPC_HEADER_GET_LENGTH(drbl_reg)		\
 	(((drbl_reg) >> IPC_HEADER_LENGTH_OFFSET)&IPC_HEADER_LENGTH_MASK)
@@ -121,12 +123,10 @@ ISS FW may not write to them */
 	(((drbl_reg) >> IPC_HEADER_MNG_CMD_OFFSET)&IPC_HEADER_MNG_CMD_MASK)
 
 #define IPC_IS_BUSY(drbl_reg)			\
-	(((drbl_reg)&IPC_DRBL_BUSY_BIT) == ((u32)IPC_DRBL_BUSY_BIT))
-
-#define IPC_SET_BUSY(drbl_reg)		((drbl_reg) | (IPC_DRBL_BUSY_BIT))
+	(((drbl_reg)&IPC_DRBL_BUSY_BIT) == ((uint32_t)IPC_DRBL_BUSY_BIT))
 
 #define IPC_INT_FROM_ISH_TO_HOST(drbl_reg)	\
-	(((drbl_reg)&IPC_INT_ISH2HOST_BIT) == ((u32)IPC_INT_ISH2HOST_BIT))
+	(((drbl_reg)&IPC_INT_ISH2HOST_BIT) == ((uint32_t)IPC_INT_ISH2HOST_BIT))
 
 #define IPC_BUILD_HEADER(length, protocol, busy)		\
 	(((busy)<<IPC_DRBL_BUSY_OFFS) |				\
@@ -152,7 +152,7 @@ ISS FW may not write to them */
 				((host_status) ^= (IPC_ILUP_BIT))
 
 /* todo - temp until PIMR HW ready */
-#define IPC_HOST_BUSY_READING_OFFS				(6)
+#define IPC_HOST_BUSY_READING_OFFS	6
 
 /* bit corresponds host ready bit in Host Status Register (HOST_COMM) */
 #define IPC_HOST_BUSY_READING_BIT	(1<<IPC_HOST_BUSY_READING_OFFS)
@@ -164,23 +164,24 @@ ISS FW may not write to them */
 				((host_status) ^= (IPC_HOST_BUSY_READING_BIT))
 
 
-#define IPC_IS_ISH_HECI_READY(ish_status)       \
-		(((ish_status)&IPC_ISH_HECI_READY_BIT) == ((u32)IPC_ISH_HECI_READY_BIT))
+#define IPC_IS_ISH_ISHTP_READY(ish_status)	\
+		(((ish_status) & IPC_ISH_ISHTP_READY_BIT) ==	\
+			((uint32_t)IPC_ISH_ISHTP_READY_BIT))
 
 #define IPC_IS_ISH_ILUP(ish_status)		\
-			(((ish_status)&IPC_ILUP_BIT) == ((u32)IPC_ILUP_BIT))
+			(((ish_status) & IPC_ILUP_BIT) == ((uint32_t)IPC_ILUP_BIT))
 
 
-#define IPC_PROTOCOL_HECI               1
-#define IPC_PROTOCOL_MNG                3
+#define IPC_PROTOCOL_ISHTP		1
+#define IPC_PROTOCOL_MNG		3
 
-#define MNG_RX_CMPL_ENABLE              0
-#define MNG_RX_CMPL_DISABLE             1
-#define MNG_RX_CMPL_INDICATION          2
+#define MNG_RX_CMPL_ENABLE		0
+#define MNG_RX_CMPL_DISABLE		1
+#define MNG_RX_CMPL_INDICATION		2
 #define MNG_RESET_NOTIFY		3
 #define MNG_RESET_NOTIFY_ACK		4
 #define MNG_SYNC_FW_CLOCK		5
 #define MNG_ILLEGAL_CMD			0xFF
 
-#endif /* _HECI_ISH_REGS_H_ */
+#endif /* _ISHTP_ISH_REGS_H_ */
 
diff --git a/drivers/misc/intel-ish/hw-ish.c b/drivers/misc/intel-ish/hw-ish.c
deleted file mode 100644
index b029e71..0000000
--- a/drivers/misc/intel-ish/hw-ish.c
+++ /dev/null
@@ -1,980 +0,0 @@
-/*
- * H/W layer of HECI provider device (ISS)
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include "client.h"
-#include "hw-ish.h"
-#include "utils.h"
-#include "heci_dev.h"
-#include "hbm.h"
-#include <linux/spinlock.h>
-#include <linux/jiffies.h>
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static void no_dev_dbg(void *v, char *s, ...)
-{
-}
-/*#define dev_dbg dev_err*/
-#define dev_dbg no_dev_dbg
-
-#include <linux/delay.h>
-
-/**
- * ish_reg_read - reads 32bit register
- *
- * @dev: the device structure
- * @offset: offset from which to read the data
- */
-static inline u32 ish_reg_read(const struct heci_device *dev,
-	unsigned long offset)
-{
-	struct ish_hw *hw = to_ish_hw(dev);
-	return readl(hw->mem_addr + offset);
-}
-
-/**
- * ish_reg_write - Writes 32bit register
- *
- * @dev: the device structure
- * @offset: offset from which to write the data
- * @value: the byte to write
- */
-static inline void ish_reg_write(struct heci_device *dev, unsigned long offset,
-	u32 value)
-{
-	struct ish_hw *hw = to_ish_hw(dev);
-	writel(value, hw->mem_addr + offset);
-}
-
-static inline u32 ish_read_fw_sts_reg(struct heci_device *dev)
-{
-	return ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
-}
-
-bool check_generated_interrupt(struct heci_device *dev)
-{
-	bool interrupt_generated = true;
-	u32 pisr_val = 0;
-
-	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
-	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
-
-	return interrupt_generated;
-}
-
-
-u32 ipc_output_payload_read(struct heci_device *dev, unsigned long index)
-{
-	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG +	(index * sizeof(u32)));
-}
-
-/**
- * ish_read - reads a message from heci device.
- *
- * @dev: the device structure
- * @buffer: message buffer will be written
- * @buffer_length: message size will be read
- */
-static int ish_read(struct heci_device *dev, unsigned char *buffer,
-	unsigned long buffer_length)
-{
-	u32	i;
-	u32	*r_buf = (u32 *)buffer;
-	u32	msg_offs;
-
-	dev_dbg(&dev->pdev->dev, "buffer-length = %lu buf[0]0x%08X\n",
-		buffer_length, ipc_output_payload_read(dev, 0));
-
-	msg_offs = IPC_REG_ISH2HOST_MSG + sizeof(struct heci_msg_hdr);
-	for (i = 0; i < buffer_length; i += sizeof(u32))
-		*r_buf++ = ish_reg_read(dev, msg_offs + i);
-
-	return 0;
-}
-
-/**
- * ish_is_input_ready - check if ISS FW is ready for receiving data
- *
- * @dev: the device structure
- */
-static bool ish_is_input_ready(struct heci_device *dev)
-{
-	u32 doorbell_val;
-
-	doorbell_val = ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL);
-	return !IPC_IS_BUSY(doorbell_val);
-}
-
-/**
- * ish_intr_enable - enables heci device interrupts
- *
- * @dev: the device structure
- */
-void ish_intr_enable(struct heci_device *dev)
-{
-/*	u32 host_status = 0; */
-
-	dev_dbg(&dev->pdev->dev, "ish_intr_enable\n");
-	if (dev->pdev->revision == REVISION_ID_CHT_A0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Ax_SI)
-		ish_reg_write(dev, IPC_REG_HOST_COMM, 0x81);
-	else if (dev->pdev->revision == REVISION_ID_CHT_B0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Bx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Kx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Dx_SI) {
-		uint32_t	host_comm_val;
-
-		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
-		host_comm_val |= IPC_HOSTCOMM_INT_EN_BIT | 0x81;
-		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
-	}
-}
-
-/**
- * ish_intr_disable - disables heci device interrupts
- *
- * @dev: the device structure
- */
-void ish_intr_disable(struct heci_device *dev)
-{
-	dev_dbg(&dev->pdev->dev, "ish_intr_disable\n");
-	if (dev->pdev->revision == REVISION_ID_CHT_A0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Ax_SI)
-		/*ish_reg_write(dev, IPC_REG_HOST_COMM, 0xC1)*/;
-	else if (dev->pdev->revision == REVISION_ID_CHT_B0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Bx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Kx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Dx_SI) {
-		uint32_t	host_comm_val;
-
-		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
-		host_comm_val &= ~IPC_HOSTCOMM_INT_EN_BIT;
-		host_comm_val |= 0xC1;
-		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
-	}
-}
-
-/*
- * BH processing work function (instead of thread handler)
- */
-static void	bh_hbm_work_fn(struct work_struct *work)
-{
-	unsigned long	flags;
-	struct heci_device	*dev;
-	unsigned char	hbm[IPC_PAYLOAD_SIZE];
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): work=%p +++\n", __func__, work);
-	dev = container_of(work, struct heci_device, bh_hbm_work);
-	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
-	if (dev->rd_msg_fifo_head != dev->rd_msg_fifo_tail) {
-		memcpy(hbm, dev->rd_msg_fifo + dev->rd_msg_fifo_head,
-			IPC_PAYLOAD_SIZE);
-		dev->rd_msg_fifo_head =
-			(dev->rd_msg_fifo_head + IPC_PAYLOAD_SIZE) %
-			(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
-		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-		heci_hbm_dispatch(dev, (struct heci_bus_message *)hbm);
-	} else {
-		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-	}
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-}
-/*#####################################################*/
-
-/*
- * Got msg with IPC (and upper protocol) header
- * and add it to the device Tx-to-write list
- * then try to send the first IPC waiting msg (if DRBL is cleared)
- * RETURN VALUE:	negative -	fail (means free links list is empty,
- *					or msg too long)
- *			0 -	succeed
- */
-static int write_ipc_to_queue(struct heci_device *dev,
-	void (*ipc_send_compl)(void *), void *ipc_send_compl_prm,
-	unsigned char *msg, int length)
-{
-	struct wr_msg_ctl_info *ipc_link;
-	unsigned long   flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ length=%u\n", __func__, length);
-	if (length > IPC_FULL_MSG_SIZE)
-		return -EMSGSIZE;
-
-	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
-	if (list_empty(&dev->wr_free_list_head.link)) {
-		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-		return -ENOMEM;
-	}
-	ipc_link = list_entry(dev->wr_free_list_head.link.next,
-		struct wr_msg_ctl_info, link);
-	list_del_init(&ipc_link->link);
-
-	ipc_link->ipc_send_compl = ipc_send_compl;
-	ipc_link->ipc_send_compl_prm = ipc_send_compl_prm;
-	ipc_link->length = length;
-	memcpy(ipc_link->inline_data, msg, length);
-
-	list_add_tail(&ipc_link->link, &dev->wr_processing_list_head.link);
-	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-
-	write_ipc_from_queue(dev);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return 0;
-}
-
-/* check if DRBL is cleared. if it is - write the first IPC msg,
- * then call the callback function (if it isn't NULL)
- */
-int write_ipc_from_queue(struct heci_device *dev)
-{
-	u32	doorbell_val;
-	unsigned long length;
-	unsigned long rem;
-	u32	*r_buf;
-	int i;
-	struct wr_msg_ctl_info	*ipc_link;
-	u32	reg_addr;
-	unsigned long	flags;
-	void	(*ipc_send_compl)(void *);
-	void	*ipc_send_compl_prm;
-	static int	out_ipc_locked;
-	unsigned long	out_ipc_flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-
-	if (dev->dev_state == HECI_DEV_DISABLED)
-		return	-EINVAL;
-
-	spin_lock_irqsave(&dev->out_ipc_spinlock, out_ipc_flags);
-	if (out_ipc_locked) {
-		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
-		return -EBUSY;
-	}
-	out_ipc_locked = 1;
-	if (!ish_is_input_ready(dev)) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): --- EBUSY\n", __func__);
-		out_ipc_locked = 0;
-		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
-		return -EBUSY;
-	}
-	spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
-
-	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
-	/*
-	 * if empty list - return 0; may happen, as RX_COMPLETE handler doesn't
-	 * check list emptiness
-	 */
-	if (list_empty(&dev->wr_processing_list_head.link)) {
-		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-		ISH_DBG_PRINT(KERN_ALERT "%s(): --- empty\n", __func__);
-		out_ipc_locked = 0;
-		return	0;
-	}
-
-	ipc_link = list_entry(dev->wr_processing_list_head.link.next,
-		struct wr_msg_ctl_info, link);
-	length = ipc_link->length - sizeof(u32);
-	/*first 4 bytes of the data is the doorbell value (IPC header)*/
-	doorbell_val = *(u32 *)ipc_link->inline_data;
-	r_buf = (u32 *)(ipc_link->inline_data + sizeof(u32));
-
-	/* If sending MNG_SYNC_FW_CLOCK, update clock again */
-	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG &&
-		IPC_HEADER_GET_MNG_CMD(doorbell_val) == MNG_SYNC_FW_CLOCK) {
-
-		struct timespec	ts;
-		uint64_t	usec;
-
-		get_monotonic_boottime(&ts);
-		usec = (uint64_t)ts.tv_sec * 1000000 +
-			(uint64_t)ts.tv_nsec / 1000;
-		r_buf[0] = (u32)(usec & 0xFFFFFFFF);
-		r_buf[1] = (u32)(usec >> 32);
-	}
-
-	for (i = 0, reg_addr = IPC_REG_HOST2ISH_MSG; i < length >> 2; i++,
-			reg_addr += 4)
-		ish_reg_write(dev, reg_addr, r_buf[i]);
-
-	rem = length & 0x3;
-	if (rem > 0) {
-		u32 reg = 0;
-		memcpy(&reg, &r_buf[length >> 2], rem);
-		ish_reg_write(dev, reg_addr, reg);
-	}
-
-	/* HID client debug */
-	if (doorbell_val == 0x8000040C &&
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG) == 0x80080000 &&
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+4) == 0x00030508) {
-			++dev->ipc_hid_out_fc;
-			++dev->ipc_hid_out_fc_cnt;
-		}
-	else if ((doorbell_val & 0xFFFFFC00) == 0x80000400 &&
-		(ish_reg_read(dev, IPC_REG_HOST2ISH_MSG) & 0x8000FFFF) ==
-				0x80000305)
-			--dev->ipc_hid_in_fc;
-
-	/* Update IPC counters */
-	++dev->ipc_tx_cnt;
-	dev->ipc_tx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
-
-	ish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, doorbell_val);
-	out_ipc_locked = 0;
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): in msg. registers: %08X ! %08X %08X %08X %08X... hostcomm reg: %08X\n",
-		__func__, ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 4),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 8),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 0xC),
-		ish_reg_read(dev, IPC_REG_HOST_COMM));
-
-	ipc_send_compl = ipc_link->ipc_send_compl;
-	ipc_send_compl_prm = ipc_link->ipc_send_compl_prm;
-	list_del_init(&ipc_link->link);
-	list_add_tail(&ipc_link->link, &dev->wr_free_list_head.link);
-	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-
-	/*
-	 * callback will be called out of spinlock,
-	 * after ipc_link returned to free list
-	 */
-	if (ipc_send_compl)
-		ipc_send_compl(ipc_send_compl_prm);
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): --- written %lu bytes [%08X ! %08X %08X %08X %08X...]\n",
-		__func__, length, *(u32 *)ipc_link->inline_data, r_buf[0],
-		r_buf[1], r_buf[2], r_buf[3]);
-	return 0;
-}
-
-/*#####################################################*/
-
-static int	ish_fw_reset_handler(struct heci_device *dev)
-{
-	uint32_t	reset_id;
-	unsigned long	flags;
-	struct wr_msg_ctl_info *processing, *next;
-	/* Read reset ID */
-	reset_id = ish_reg_read(dev, IPC_REG_ISH2HOST_MSG) & 0xFFFF;
-
-	/* Handle FW-initiated reset */
-	dev->dev_state = HECI_DEV_RESETTING;
-
-	/* Clear HOST2ISH.ILUP (what's it?) */
-	/*ish_clr_host_rdy(dev);*/
-
-	/* Clear IPC output queue */
-	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
-	list_for_each_entry_safe(processing, next,
-			&dev->wr_processing_list_head.link, link) {
-		list_del(&processing->link);
-		list_add_tail(&processing->link, &dev->wr_free_list_head.link);
-	}
-	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-
-	/* Clear BH processing queue - no further HBMs */
-	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
-	dev->rd_msg_fifo_head = dev->rd_msg_fifo_tail = 0;
-	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-
-	/* Handle ISS FW reset against upper layers */
-	heci_bus_remove_all_clients(dev);	/* Remove all client devices */
-
-	/* Send RESET_NOTIFY_ACK (with reset_id) */
-/*#####################################*/
-	if (!ish_is_input_ready(dev))
-		timed_wait_for_timeout(WAIT_FOR_SEND_SLICE,
-			ish_is_input_ready(dev), (2 * HZ));
-
-	/* ISS FW is dead (?) */
-	if (!ish_is_input_ready(dev)) {
-		return	-EPIPE;
-	} else {
-		/*
-		 * Set HOST2ISH.ILUP. Apparently we need this BEFORE sending
-		 * RESET_NOTIFY_ACK - FW will be checking for it
-		 */
-		ish_set_host_rdy(dev);
-		ipc_send_mng_msg(dev, MNG_RESET_NOTIFY_ACK, &reset_id,
-			sizeof(uint32_t));
-	}
-/*####################################*/
-
-	/* Wait for ISS FW'es ILUP and HECI_READY */
-	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, ish_hw_is_ready(dev),
-		(2 * HZ));
-	if (!ish_hw_is_ready(dev)) {
-		/* ISS FW is dead */
-		uint32_t	ish_status;
-		ish_status = ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
-		dev_err(&dev->pdev->dev,
-		"[heci-ish]: completed reset, ISS is dead (FWSTS = %08X)\n",
-		ish_status);
-		return -ENODEV;
-	}
-
-	return	0;
-}
-
-struct work_struct	fw_reset_work;
-struct heci_device	*heci_dev;
-
-static void	fw_reset_work_fn(struct work_struct *unused)
-{
-	int	rv;
-	static int reset_cnt;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	reset_cnt++;
-
-	rv = ish_fw_reset_handler(heci_dev);
-	if (!rv) {
-		/* ISS is ILUP & HECI-ready. Restart HECI */
-	/* bug fix here: when reset flow occurs, sometimes, the sysfs entries
-		which were removed in ish_fw_reset_handler were still up,
-		but the driver tried to create the same entries and failed.
-		so wait some time here and then the sysfs entries removal will
-		be done */
-		if (reset_cnt != 0) /* not the boot flow */
-			schedule_timeout(HZ / 3);
-		heci_dev->recvd_hw_ready = 1;
-		if (waitqueue_active(&heci_dev->wait_hw_ready))
-			wake_up(&heci_dev->wait_hw_ready);
-
-		heci_dev->dev_state = HECI_DEV_INIT_CLIENTS;
-		heci_dev->hbm_state = HECI_HBM_START;
-		heci_hbm_start_req(heci_dev);
-		ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n",
-			__func__);
-
-	} else
-		dev_err(&heci_dev->pdev->dev,
-			"[heci-ish]: FW reset failed (%d)\n", rv);
-}
-
-
-static void	sync_fw_clock(struct heci_device *dev)
-{
-	static unsigned long	prev_sync;
-	struct timespec	ts;
-	uint64_t	usec;
-
-	if (prev_sync && jiffies - prev_sync < 20 * HZ)
-		return;
-
-	prev_sync = jiffies;
-	get_monotonic_boottime(&ts);
-	usec = (uint64_t)ts.tv_sec * 1000000 + (uint64_t)ts.tv_nsec / 1000;
-	ipc_send_mng_msg(dev, MNG_SYNC_FW_CLOCK, &usec, sizeof(uint64_t));
-}
-
-
-/*
- *	Receive and process IPC management messages
- *
- *	NOTE: Any other mng command than reset_notify and reset_notify_ack
- *	won't wake BH handler
- */
-static void	recv_ipc(struct heci_device *dev, uint32_t doorbell_val)
-{
-	uint32_t	mng_cmd;
-
-	mng_cmd = IPC_HEADER_GET_MNG_CMD(doorbell_val);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): handled IPC mng_cmd=%08X\n", __func__,
-		mng_cmd);
-
-	switch (mng_cmd) {
-	default:
-		break;
-
-	case MNG_RX_CMPL_INDICATION:
-		ISH_DBG_PRINT(KERN_ALERT
-			"%s(): RX_COMPLETE -- IPC_REG_ISH2HOST_MSG[0] = %08X\n",
-			__func__, ish_reg_read(dev, IPC_REG_ISH2HOST_MSG));
-		if (suspend_flag) {
-			suspend_flag = 0;
-			if (waitqueue_active(&suspend_wait))
-				wake_up(&suspend_wait);
-		}
-		write_ipc_from_queue(dev);
-		break;
-
-	case MNG_RESET_NOTIFY:
-		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY\n", __func__);
-		if (!heci_dev) {
-			heci_dev = dev;
-			INIT_WORK(&fw_reset_work, fw_reset_work_fn);
-		}
-		schedule_work(&fw_reset_work);
-		break;
-
-	case MNG_RESET_NOTIFY_ACK:
-		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY_ACK\n",
-			__func__);
-		dev->recvd_hw_ready = 1;
-		if (waitqueue_active(&dev->wait_hw_ready))
-			wake_up(&dev->wait_hw_ready);
-		break;
-	}
-}
-
-
-/**
- * ish_irq_handler - ISR of the HECI device
- *
- * @irq: irq number
- * @dev_id: pointer to the device structure
- *
- * returns irqreturn_t
- */
-irqreturn_t ish_irq_handler(int irq, void *dev_id)
-{
-	struct heci_device *dev = dev_id;
-	uint32_t	doorbell_val;
-	struct heci_msg_hdr	*heci_hdr;
-	bool interrupt_generated;
-	u32 pisr_val;
-	u32	msg_hdr;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): irq=%d +++\n", __func__, irq);
-
-	/* Check that it's interrupt from ISH (may be shared) */
-	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
-	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): interrupt_generated=%d [PIMR=%08X]\n",
-		__func__, (int)interrupt_generated,
-		ish_reg_read(dev, IPC_REG_PIMR));
-	if (!interrupt_generated)
-		return IRQ_NONE;
-
-	doorbell_val = ish_reg_read(dev, IPC_REG_ISH2HOST_DRBL);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): IPC_IS_BUSY=%d\n", __func__,
-		(int)IPC_IS_BUSY(doorbell_val));
-	if (!IPC_IS_BUSY(doorbell_val))
-		return IRQ_HANDLED;
-
-	ISH_DBG_PRINT("%s(): doorbell is busy - YES\n", __func__);
-
-	/* CHECKME: double check this */
-	if (dev->dev_state == HECI_DEV_DISABLED)
-		return	IRQ_HANDLED;
-
-	ish_intr_disable(dev);
-
-	/* Sanity check: IPC dgram length in header */
-	if (IPC_HEADER_GET_LENGTH(doorbell_val) > IPC_PAYLOAD_SIZE) {
-		dev_err(&dev->pdev->dev,
-			"%s(): IPC hdr - bad length: %u; dropped\n",
-			__func__,
-			(unsigned)IPC_HEADER_GET_LENGTH(doorbell_val));
-		goto	eoi;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): protocol=%u\n", __func__,
-		IPC_HEADER_GET_PROTOCOL(doorbell_val));
-
-	/* IPC message */
-	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG) {
-		recv_ipc(dev, doorbell_val);
-		goto	eoi;
-	}
-
-	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) != IPC_PROTOCOL_HECI)
-		goto	eoi;
-
-	/* Read HECI header dword */
-	msg_hdr = ish_read_hdr(dev);
-	if (!msg_hdr)
-		goto	eoi;
-
-	sync_fw_clock(dev);
-
-	heci_hdr = (struct heci_msg_hdr *)&msg_hdr;
-	dev->heci_msg_hdr = msg_hdr;
-
-	/* Sanity check: HECI frag. length in header */
-	if (heci_hdr->length > dev->mtu) {
-		dev_err(&dev->pdev->dev,
-			"%s(): HECI hdr - bad length: %u; dropped [%08X]\n",
-			__func__,
-			(unsigned)heci_hdr->length, msg_hdr);
-		goto	eoi;
-	}
-
-	/* HECI bus message */
-	if (!heci_hdr->host_addr && !heci_hdr->me_addr) {
-		recv_hbm(dev, heci_hdr);
-		goto	eoi;
-
-	/* HECI fixed-client message */
-	} else if (!heci_hdr->host_addr) {
-		recv_fixed_cl_msg(dev, heci_hdr);
-		goto	eoi;
-	} else {
-		/* HECI client message */
-		recv_heci_cl_msg(dev, heci_hdr);
-		goto	eoi;
-	}
-
-eoi:
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): Doorbell cleared, busy reading cleared\n", __func__);
-	/* Update IPC counters */
-	++dev->ipc_rx_cnt;
-	dev->ipc_rx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
-
-	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
-	/*
-	 * Here and above: we need to actually read this register
-	 * in order to unblock further interrupts on CHT A0
-	 */
-	ish_intr_enable(dev);
-	return	IRQ_HANDLED;
-}
-
-
-static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code,
-	void *msg, size_t size)
-{
-	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
-	uint32_t	drbl_val = IPC_BUILD_MNG_MSG(msg_code, size);
-
-	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
-	memcpy(ipc_msg + sizeof(uint32_t), msg, size);
-	return	write_ipc_to_queue(dev, NULL, NULL, ipc_msg,
-		sizeof(uint32_t) + size);
-}
-
-
-static int	ipc_send_heci_msg(struct heci_device *dev,
-	struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
-	void *ipc_send_compl_prm)
-{
-	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
-	uint32_t	drbl_val;
-
-	drbl_val = IPC_BUILD_HEADER(hdr->length + sizeof(struct heci_msg_hdr),
-		IPC_PROTOCOL_HECI, 1);
-
-	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
-	memcpy(ipc_msg + sizeof(uint32_t), hdr, sizeof(uint32_t));
-	memcpy(ipc_msg + 2 * sizeof(uint32_t), msg, hdr->length);
-	return	write_ipc_to_queue(dev, ipc_send_compl, ipc_send_compl_prm,
-		ipc_msg, 2 * sizeof(uint32_t) + hdr->length);
-}
-
-
-/**
- * ish_hw_is_ready - check if the hw is ready
- *
- * @dev: the device structure
- */
-bool ish_hw_is_ready(struct heci_device *dev)
-{
-	u32 ish_status =  ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
-	return IPC_IS_ISH_ILUP(ish_status) && IPC_IS_ISH_HECI_READY(ish_status);
-}
-
-/**
- * ish_host_is_ready - check if the host is ready
- *
- * @dev: the device structure
- */
-bool ish_host_is_ready(struct heci_device *dev)
-{
-	return true;
-}
-
-void ish_set_host_rdy(struct heci_device *dev)
-{
-	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n",
-		host_status);
-	IPC_SET_HOST_READY(host_status);
-	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
-	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n",
-		host_status);
-}
-
-void ish_clr_host_rdy(struct heci_device *dev)
-{
-	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n",
-		host_status);
-	IPC_CLEAR_HOST_READY(host_status);
-	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
-	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n",
-		host_status);
-}
-
-
-static int ish_hw_reset(struct heci_device *dev)
-{
-	struct pci_dev *pdev = dev->pdev;
-	struct ish_hw *hw = to_ish_hw(dev);
-	int	rv;
-	u16 csr;
-
-#define	MAX_DMA_DELAY	20
-	unsigned	dma_delay;
-
-	if (!pdev)
-		return	-ENODEV;
-
-	rv = pci_reset_function(pdev);
-	if (!rv)
-		dev->dev_state = HECI_DEV_RESETTING;
-
-	if (!pdev->pm_cap) {
-		dev_err(&pdev->dev, "Can't reset - no PM caps\n");
-		return	-EINVAL;
-	}
-
-	/* Now trigger reset to FW */
-	writel(0, hw->mem_addr + IPC_REG_ISH_RMP2);
-
-	for (dma_delay = 0; dma_delay < MAX_DMA_DELAY &&
-			ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS) &
-				(IPC_ISH_IN_DMA);
-			dma_delay += 5)
-		mdelay(5);
-
-	if (dma_delay >= MAX_DMA_DELAY) {
-		dev_err(&pdev->dev,
-			"Can't reset - stuck with DMA in-progress\n");
-		return	-EBUSY;
-	}
-
-	pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &csr);
-
-	csr &= ~PCI_PM_CTRL_STATE_MASK;
-	csr |= PCI_D3hot;
-	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
-
-	mdelay(pdev->d3_delay);
-
-	csr &= ~PCI_PM_CTRL_STATE_MASK;
-	csr |= PCI_D0;
-	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
-
-	writel(IPC_RMP2_DMA_ENABLED, hw->mem_addr + IPC_REG_ISH_RMP2);
-
-	/* Send 0 IPC message so that ISS FW wakes up if it was already
-	 asleep */
-	writel(IPC_DRBL_BUSY_BIT, hw->mem_addr + IPC_REG_HOST2ISH_DRBL);
-
-	return	0;
-}
-
-
-/**
- * ish_ipc_reset - resets host and fw IPC and upper layers.
- *
- * @dev: the device structure
- */
-static int ish_ipc_reset(struct heci_device *dev)
-{
-	struct ipc_rst_payload_type ipc_mng_msg;
-	int	rv = 0;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
-	dev_dbg(&dev->pdev->dev, "ish_hw_reset\n");
-	/*temporary we'll send reset*/
-
-	ipc_mng_msg.reset_id = 1;
-	ipc_mng_msg.reserved = 0;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): before ish_intr_enable()\n", __func__);
-	ish_intr_enable(dev);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): after ish_intr_enable()\n", __func__);
-
-/* DEBUG: send self-interrupt and wait 100 (ms) for it to appear in klog */
-/*	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0x80000000);
-	mdelay(100);
-************************/
-
-	/* Clear the incoming doorbell */
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): Doorbell cleared, busy reading cleared\n", __func__);
-	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): cleared doorbell reg.\n", __func__);
-
-	/*
-	 * Fixed: this should be set BEFORE writing RESET_NOTIFY,
-	 * lest response will be received BEFORE this clearing...
-	 */
-	dev->recvd_hw_ready = 0;
-
-	/*send message */
-	rv = ipc_send_mng_msg(dev, MNG_RESET_NOTIFY, &ipc_mng_msg,
-		sizeof(struct ipc_rst_payload_type));
-	if (rv) {
-		dev_err(&dev->pdev->dev, "Failed to send IPC MNG_RESET_NOTIFY\n");
-		return	rv;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): going to wait for hw_ready.\n",
-		__func__);
-	/*wait_event_interruptible(dev->wait_hw_ready, dev->recvd_hw_ready);*/
-	wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready, 2*HZ);
-	if (!dev->recvd_hw_ready) {
-		dev_err(&dev->pdev->dev, "Timed out waiting for HW ready\n");
-		rv = -ENODEV;
-	}
-	ISH_DBG_PRINT(KERN_ALERT "%s(): woke up from hw_ready.\n", __func__);
-
-	dev_dbg(&dev->pdev->dev, "exit initial link wait\n");
-
-	return rv;
-}
-
-/* Dummy. Do we need it? */
-static void ish_hw_config(struct heci_device *dev)
-{
-	ISH_DBG_PRINT(KERN_ALERT "%s()+++ [ish_hw_reset=%p]\n",
-		__func__, ish_hw_reset);
-	dev_dbg(&dev->pdev->dev, "ish_hw_config\n");
-}
-
-static int ish_hw_start(struct heci_device *dev)
-{
-	struct ish_hw *hw = to_ish_hw(dev);
-
-	dev_dbg(&dev->pdev->dev, "ish_hw_start\n");
-	ish_set_host_rdy(dev);
-#ifdef	D3_RCR
-	/* After that we can enable ISH DMA operation */
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): writing DMA_ENABLED\n",
-		__func__);
-	writel(IPC_RMP2_DMA_ENABLED, hw->mem_addr + IPC_REG_ISH_RMP2);
-
-	/* Send 0 IPC message so that ISS FW wakes up if it was already
-	 asleep */
-	writel(IPC_DRBL_BUSY_BIT, hw->mem_addr + IPC_REG_HOST2ISH_DRBL);
-#endif /*D3_RCR*/
-	ish_intr_enable(dev);
-	return 0;
-}
-
-
-static u32 ish_read_hdr(const struct heci_device *dev)
-{
-	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG);
-}
-
-
-/**
- * ish_write - writes a message to heci device.
- *
- * @dev: the device structure
- * @header: header of message
- * @buf: message buffer will be written
- * returns 1 if success, 0 - otherwise.
- */
-
-static int ish_write(struct heci_device *dev, struct heci_msg_hdr *header,
-	unsigned char *buf)
-{
-/*#####################################################################*/
-	unsigned char ipc_msg[IPC_FULL_MSG_SIZE];
-	u32 doorbell_val;
-
-	doorbell_val = IPC_BUILD_HEADER(header->length +
-		sizeof(struct heci_msg_hdr), IPC_PROTOCOL_HECI, 1);
-	memcpy(ipc_msg, (char *)&doorbell_val, sizeof(u32));
-	memcpy(ipc_msg + sizeof(u32), (char *)header,
-		sizeof(struct heci_msg_hdr));
-	memcpy(ipc_msg + sizeof(u32) + sizeof(struct heci_msg_hdr), buf,
-		header->length);
-
-	return write_ipc_to_queue(dev, NULL, NULL, ipc_msg,
-		sizeof(u32) + sizeof(struct heci_msg_hdr) + header->length);
-/*#####################################################################*/
-}
-
-
-static const struct heci_hw_ops ish_hw_ops = {
-	.host_is_ready = ish_host_is_ready,
-	.hw_is_ready = ish_hw_is_ready,
-	.hw_reset = ish_hw_reset,
-	.ipc_reset = ish_ipc_reset,
-	.hw_config = ish_hw_config,
-	.hw_start = ish_hw_start,
-	.read = ish_read,
-	.write = ish_write,
-	.write_ex = ipc_send_heci_msg,
-	.get_fw_status = ish_read_fw_sts_reg
-};
-
-
-struct heci_device *ish_dev_init(struct pci_dev *pdev)
-{
-
-	struct heci_device *dev;
-
-	dev = kzalloc(sizeof(struct heci_device) +  sizeof(struct ish_hw),
-		GFP_KERNEL);
-	if (!dev)
-		return NULL;
-
-	heci_device_init(dev);
-
-	/* Rx INT->BH FIFO pointers */
-	dev->rd_msg_fifo_head = 0;
-	dev->rd_msg_fifo_tail = 0;
-	spin_lock_init(&dev->rd_msg_spinlock);
-	spin_lock_init(&dev->wr_processing_spinlock);
-	spin_lock_init(&dev->out_ipc_spinlock);
-	spin_lock_init(&dev->read_list_spinlock);
-	spin_lock_init(&dev->device_lock);
-	spin_lock_init(&dev->device_list_lock);
-	spin_lock_init(&dev->cl_list_lock);
-	spin_lock_init(&dev->me_clients_lock);
-	INIT_WORK(&dev->bh_hbm_work, bh_hbm_work_fn);
-
-	dev->ops = &ish_hw_ops;
-	dev->pdev = pdev;
-	dev->mtu = IPC_PAYLOAD_SIZE - sizeof(struct heci_msg_hdr);
-	return dev;
-}
-
-
-void	heci_device_disable(struct heci_device *dev)
-{
-	dev->dev_state = HECI_DEV_DISABLED;
-	ish_clr_host_rdy(dev);
-	ish_intr_disable(dev);
-
-	/* Free all other allocations */
-	kfree(dev->me_clients);
-}
-
diff --git a/drivers/misc/intel-ish/hw-ish.h b/drivers/misc/intel-ish/hw-ish.h
index 6b2c516..f8f4756 100644
--- a/drivers/misc/intel-ish/hw-ish.h
+++ b/drivers/misc/intel-ish/hw-ish.h
@@ -1,7 +1,7 @@
 /*
- * H/W layer of HECI provider device (ISS)
+ * H/W layer of ISHTP provider device (ISH)
  *
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,24 +9,25 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
-#ifndef _HECI_HW_ISH_H_
-#define _HECI_HW_ISH_H_
+#ifndef _ISHTP_HW_ISH_H_
+#define _ISHTP_HW_ISH_H_
 
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include "hw-ish-regs.h"
-#include "heci_dev.h"
+#include "ishtp_dev.h"
 
+extern struct pci_dev *ishtp_pci_device;
 extern int	suspend_flag;
 extern wait_queue_head_t	suspend_wait;
 
 struct ipc_rst_payload_type {
-	u16            reset_id;
-	u16            reserved;
+	uint16_t	reset_id;
+	uint16_t	reserved;
 };
 
 struct ish_hw {
@@ -35,29 +36,11 @@ struct ish_hw {
 
 #define to_ish_hw(dev) (struct ish_hw *)((dev)->hw)
 
-
-struct heci_device *ish_dev_init(struct pci_dev *pdev);
-
 irqreturn_t ish_irq_handler(int irq, void *dev_id);
-
-void ish_clr_host_rdy(struct heci_device *dev);
-void ish_set_host_rdy(struct heci_device *dev);
-bool ish_hw_is_ready(struct heci_device *dev);
-void ish_intr_enable(struct heci_device *dev);
-void ish_intr_disable(struct heci_device *dev);
-
-int	write_ipc_from_queue(struct heci_device *dev);
-
-static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code,
-	void *msg, size_t size);
-
-static int	ipc_send_heci_msg(struct heci_device *dev,
-	struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
-	void *ipc_send_compl_prm);
-
-static u32	ish_read_hdr(const struct heci_device *dev);
+struct ishtp_device *ish_dev_init(struct pci_dev *pdev);
+int ish_hw_start(struct ishtp_device *dev);
 
 void g_ish_print_log(char *format, ...);
 
-#endif /* _HECI_HW_ISH_H_ */
+#endif /* _ISHTP_HW_ISH_H_ */
 
diff --git a/drivers/misc/intel-ish/init.c b/drivers/misc/intel-ish/init.c
index 2547c2a..766175c 100644
--- a/drivers/misc/intel-ish/init.c
+++ b/drivers/misc/intel-ish/init.c
@@ -1,7 +1,7 @@
 /*
- * Initialization protocol for HECI driver
+ * Initialization protocol for ISHTP driver
  *
- * Copyright (c) 2003-2015, Intel Corporation.
+ * Copyright (c) 2003-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,242 +9,87 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
 #include <linux/export.h>
-#include <linux/pci.h>
+#include <linux/slab.h>
 #include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/delay.h>
-#include "heci_dev.h"
+#include <linux/miscdevice.h>
+#include "ishtp_dev.h"
 #include "hbm.h"
 #include "client.h"
-#include "utils.h"
-#include "platform-config.h"
 
-const char *heci_dev_state_str(int state)
+const char *ishtp_dev_state_str(int state)
 {
 	switch (state) {
-	case HECI_DEV_INITIALIZING:
+	case ISHTP_DEV_INITIALIZING:
 		return	"INITIALIZING";
-	case HECI_DEV_INIT_CLIENTS:
+	case ISHTP_DEV_INIT_CLIENTS:
 		return	"INIT_CLIENTS";
-	case HECI_DEV_ENABLED:
+	case ISHTP_DEV_ENABLED:
 		return	"ENABLED";
-	case HECI_DEV_RESETTING:
+	case ISHTP_DEV_RESETTING:
 		return	"RESETTING";
-	case HECI_DEV_DISABLED:
+	case ISHTP_DEV_DISABLED:
 		return	"DISABLED";
-	case HECI_DEV_POWER_DOWN:
+	case ISHTP_DEV_POWER_DOWN:
 		return	"POWER_DOWN";
-	case HECI_DEV_POWER_UP:
+	case ISHTP_DEV_POWER_UP:
 		return	"POWER_UP";
 	default:
-		return "unkown";
+		return "unknown";
 	}
 }
-EXPORT_SYMBOL(heci_dev_state_str);
+EXPORT_SYMBOL(ishtp_dev_state_str);
 
-void heci_device_init(struct heci_device *dev)
+void ishtp_device_init(struct ishtp_device *dev)
 {
-	/* setup our list array */
+	dev->dev_state = ISHTP_DEV_INITIALIZING;
 	INIT_LIST_HEAD(&dev->cl_list);
 	INIT_LIST_HEAD(&dev->device_list);
-	init_waitqueue_head(&dev->wait_hw_ready);
-	init_waitqueue_head(&dev->wait_hbm_recvd_msg);
-	init_waitqueue_head(&dev->wait_dma_ready);
-	dev->dev_state = HECI_DEV_INITIALIZING;
+	dev->rd_msg_fifo_head = 0;
+	dev->rd_msg_fifo_tail = 0;
+	spin_lock_init(&dev->rd_msg_spinlock);
 
-	/*
-	 * We need to reserve something, because client #0
-	 * is reserved for HECI bus messages
-	 */
-	bitmap_zero(dev->host_clients_map, HECI_CLIENTS_MAX);
+	init_waitqueue_head(&dev->wait_hbm_recvd_msg);
+	spin_lock_init(&dev->read_list_spinlock);
+	spin_lock_init(&dev->device_lock);
+	spin_lock_init(&dev->device_list_lock);
+	spin_lock_init(&dev->cl_list_lock);
+	spin_lock_init(&dev->fw_clients_lock);
+	INIT_WORK(&dev->bh_hbm_work, bh_hbm_work_fn);
+
+	bitmap_zero(dev->host_clients_map, ISHTP_CLIENTS_MAX);
 	dev->open_handle_count = 0;
 
 	/*
-	 * Reserving the first three client IDs
-	 * 0: Reserved for HECI Bus Message communications
-	 * 1: Reserved for Watchdog
-	 * 2: Reserved for AMTHI
+	 * Reserving client ID 0 for ISHTP Bus Message communications
 	 */
-	bitmap_set(dev->host_clients_map, 0, 3);
-	/*****************************/
-
-	heci_io_list_init(&dev->read_list);
-
-	/* Init IPC processing and free lists */
-	INIT_LIST_HEAD(&dev->wr_processing_list_head.link);
-	INIT_LIST_HEAD(&dev->wr_free_list_head.link);
-	do {
-		int	i;
+	bitmap_set(dev->host_clients_map, 0, 1);
 
-		for (i = 0; i < IPC_TX_FIFO_SIZE; ++i) {
-			struct wr_msg_ctl_info	*tx_buf;
+	INIT_LIST_HEAD(&dev->read_list.list);
 
-			tx_buf = kmalloc(sizeof(struct wr_msg_ctl_info),
-				GFP_KERNEL);
-			if (!tx_buf) {
-				/*
-				 * ERROR: decide what to do with it.
-				 * IPC buffers may be limited or not available
-				 * at all - although this shouldn't happen
-				 */
-				dev_err(&dev->pdev->dev, "[heci-ish]: failure in Tx FIFO allocations (%d)\n",
-					i);
-				break;
-			}
-			memset(tx_buf, 0, sizeof(struct wr_msg_ctl_info));
-			list_add_tail(&tx_buf->link,
-				&dev->wr_free_list_head.link);
-		}
-		dev_dbg(&dev->pdev->dev, "[heci-ish]: success Tx FIFO allocations\n");
-	} while (0);
 }
-EXPORT_SYMBOL_GPL(heci_device_init);
+EXPORT_SYMBOL(ishtp_device_init);
 
-/**
- * heci_start - initializes host and fw to start work.
- *
- * @dev: the device structure
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_start(struct heci_device *dev)
+/* ishtp_start - initializes host and fw to start work */
+int ishtp_start(struct ishtp_device *dev)
 {
-	heci_hw_config(dev);
-#ifdef FORCE_FW_INIT_RESET
-	/* wait for FW-initiated reset flow, indefinitely */
-	heci_hw_start(dev);
-	/* 16/6/2014: changed this 2->5 seconds following MCG assertion.
-	 * Once this was 10 seconds, lowered to 2.
-	 * TODO: check out all FW ISS/SEC path how much it should be */
-
-	/*timed_wait_for_timeout(WAIT_FOR_CONNECT_SLICE, dev->recvd_hw_ready,
-		(10*HZ));*/
-	if (!dev->recvd_hw_ready)
-		wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready,
-			10*HZ);
-	/*
-	 * Lock only after FW-reset flow worked or failed.
-	 * otherwise interrupts BH will be locked
-	 */
-	if (dev->recvd_hw_ready)
-		goto	reset_done;
-	dev_err(&dev->pdev->dev, "[heci-ish] %s(): Timed out waiting for FW-initiated reset\n",
-		__func__);
-#if 1
-	goto	err;	/* DEBUGDEBUGDEBUG: raise timeout for FW-initiated reset
-			 * to 10 s and don't sent host-initiated reset flow */
-#endif
-	/* DEBUGDEBUGDEBUG: Below code until 'reset_done:' is defunct */
-#else
-#endif
-	/* acknowledge interrupt and stop interupts */
-	dev_dbg(&dev->pdev->dev, "reset in start the heci device.\n");
-	heci_reset(dev, 1);
-
-reset_done:
-	if (heci_hbm_start_wait(dev)) {
-		dev_err(&dev->pdev->dev, "HBM haven't started");
-		goto err;
-	}
-
-	if (!heci_host_is_ready(dev)) {
-		dev_err(&dev->pdev->dev, "host is not ready.\n");
+	if (ishtp_hbm_start_wait(dev)) {
+		dev_err(dev->devc, "HBM haven't started");
 		goto err;
 	}
 
-	if (!heci_hw_is_ready(dev)) {
-		dev_err(&dev->pdev->dev, "ISH is not ready (FWSTS).\n");
-		goto err;
-	}
-
-	/*if (dev->version.major_version != HBM_MAJOR_VERSION ||
-	    dev->version.minor_version != HBM_MINOR_VERSION) {
-		dev_dbg(&dev->pdev->dev, "HECI start failed.\n");
-		goto err;
-	}*/
-
-	dev_dbg(&dev->pdev->dev, "link layer has been established.\n");
-
-	/*suspend & resume notification - send QUERY_SUBSCRIBERS msg*/
+	/* suspend & resume notification - send QUERY_SUBSCRIBERS msg */
 	query_subscribers(dev);
 
 	return 0;
 err:
-	dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
-	dev->dev_state = HECI_DEV_DISABLED;
+	dev_err(dev->devc, "link layer initialization failed.\n");
+	dev->dev_state = ISHTP_DEV_DISABLED;
 	return -ENODEV;
 }
-EXPORT_SYMBOL_GPL(heci_start);
-
-/**
- * heci_reset - resets host and fw.
- *
- * @dev: the device structure
- * @interrupts_enabled: if interrupt should be enabled after reset.
- */
-void heci_reset(struct heci_device *dev, int interrupts_enabled)
-{
-	bool unexpected;
-	int ret;
-
-	unexpected = (dev->dev_state != HECI_DEV_INITIALIZING &&
-			dev->dev_state != HECI_DEV_DISABLED &&
-			dev->dev_state != HECI_DEV_POWER_DOWN &&
-			dev->dev_state != HECI_DEV_POWER_UP);
-
-	ret = heci_hw_reset(dev);
-	if (ret) {
-		dev_err(&dev->pdev->dev, "hw reset failed disabling the device\n");
-		interrupts_enabled = false;
-		dev->dev_state = HECI_DEV_DISABLED;
-	}
-
-	dev->hbm_state = HECI_HBM_IDLE;
-
-	if (dev->dev_state != HECI_DEV_INITIALIZING) {
-		if (dev->dev_state != HECI_DEV_DISABLED &&
-		    dev->dev_state != HECI_DEV_POWER_DOWN)
-			dev->dev_state = HECI_DEV_RESETTING;
-
-		heci_cl_all_disconnect(dev);
-	}
-
-	if (unexpected)
-		dev_warn(&dev->pdev->dev, "unexpected reset: dev_state = %s\n",
-			 heci_dev_state_str(dev->dev_state));
-
-	if (!interrupts_enabled) {
-		dev_dbg(&dev->pdev->dev, "intr not enabled end of reset\n");
-		return;
-	}
-	dev_dbg(&dev->pdev->dev, "before sending HOST start\n");
-	ret = heci_hw_start(dev);
-	if (ret) {
-		dev_err(&dev->pdev->dev, "hw_start failed disabling the device\n");
-		dev->dev_state = HECI_DEV_DISABLED;
-		return;
-	}
-
-	dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
-	/* link is established * start sending messages.  */
-
-	dev->dev_state = HECI_DEV_INIT_CLIENTS;
-	dev->hbm_state = HECI_HBM_START;
-	heci_hbm_start_req(dev);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n",
-		__func__);
-	/* wake up all readings so they can be interrupted */
-	heci_cl_all_read_wakeup(dev);
-}
-EXPORT_SYMBOL_GPL(heci_reset);
-
-void heci_stop(struct heci_device *dev)
-{
-}
-EXPORT_SYMBOL_GPL(heci_stop);
+EXPORT_SYMBOL(ishtp_start);
 
diff --git a/drivers/misc/intel-ish/ipc.c b/drivers/misc/intel-ish/ipc.c
new file mode 100644
index 0000000..ad7c2d8
--- /dev/null
+++ b/drivers/misc/intel-ish/ipc.c
@@ -0,0 +1,679 @@
+/*
+ * H/W layer of ISHTP provider device (ISH)
+ *
+ * Copyright (c) 2014-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include "client.h"
+#include "hw-ish.h"
+#include "utils.h"
+#include "hbm.h"
+
+/* global vars for reset flow */
+struct work_struct	fw_reset_work;
+struct ishtp_device	*ishtp_dev;
+
+/* ish_reg_read - reads 32bit register */
+static inline uint32_t ish_reg_read(const struct ishtp_device *dev,
+	unsigned long offset)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+	return readl(hw->mem_addr + offset);
+}
+
+/* ish_reg_write - writes 32bit register */
+static inline void ish_reg_write(struct ishtp_device *dev, unsigned long offset,
+	uint32_t value)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+	writel(value, hw->mem_addr + offset);
+}
+
+static inline uint32_t _ish_read_fw_sts_reg(struct ishtp_device *dev)
+{
+	return ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
+}
+
+bool check_generated_interrupt(struct ishtp_device *dev)
+{
+	bool interrupt_generated = true;
+	uint32_t pisr_val = 0;
+
+	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
+	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
+
+	return interrupt_generated;
+}
+
+/* ish_is_input_ready - check if ISH FW is ready for receiving data */
+static bool ish_is_input_ready(struct ishtp_device *dev)
+{
+	uint32_t doorbell_val;
+
+	doorbell_val = ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL);
+	return !IPC_IS_BUSY(doorbell_val);
+}
+
+/* ish_intr_enable - enables ishtp device interrupts */
+void ish_intr_enable(struct ishtp_device *dev)
+{
+	if (ishtp_pci_device->revision == REVISION_ID_CHT_A0 ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Ax_SI)
+		ish_reg_write(dev, IPC_REG_HOST_COMM, 0x81);
+	else if (ishtp_pci_device->revision == REVISION_ID_CHT_B0 ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Bx_SI ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Kx_SI ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Dx_SI) {
+		uint32_t host_comm_val;
+		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
+		host_comm_val |= IPC_HOSTCOMM_INT_EN_BIT | 0x81;
+		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
+	}
+}
+
+/* ish_intr_disable - disables ishtp device interrupts */
+void ish_intr_disable(struct ishtp_device *dev)
+{
+	if (ishtp_pci_device->revision == REVISION_ID_CHT_A0 ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Ax_SI)
+		/* Do nothing */;
+	else if (ishtp_pci_device->revision == REVISION_ID_CHT_B0 ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Bx_SI ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Kx_SI ||
+			(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Dx_SI) {
+		uint32_t host_comm_val;
+		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
+		host_comm_val &= ~IPC_HOSTCOMM_INT_EN_BIT;
+		host_comm_val |= 0xC1;
+		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
+	}
+}
+
+/* ishtp_fw_is_ready - check if the hw is ready */
+static bool ishtp_fw_is_ready(struct ishtp_device *dev)
+{
+	uint32_t ish_status = _ish_read_fw_sts_reg(dev);
+	return IPC_IS_ISH_ILUP(ish_status) &&
+		IPC_IS_ISH_ISHTP_READY(ish_status);
+}
+
+void ish_set_host_rdy(struct ishtp_device *dev)
+{
+	uint32_t host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	IPC_SET_HOST_READY(host_status);
+	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
+}
+
+void ish_clr_host_rdy(struct ishtp_device *dev)
+{
+	uint32_t host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	IPC_CLEAR_HOST_READY(host_status);
+	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
+}
+
+/* _ish_read_hdr - reads hdr of 32 bit length. */
+static uint32_t _ishtp_read_hdr(const struct ishtp_device *dev)
+{
+	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG);
+}
+
+/* ish_read - reads a message from ishtp device. */
+static int _ishtp_read(struct ishtp_device *dev, unsigned char *buffer,
+	unsigned long buffer_length)
+{
+	uint32_t	i;
+	uint32_t	*r_buf = (uint32_t *)buffer;
+	uint32_t	msg_offs;
+
+	msg_offs = IPC_REG_ISH2HOST_MSG + sizeof(struct ishtp_msg_hdr);
+	for (i = 0; i < buffer_length; i += sizeof(uint32_t))
+		*r_buf++ = ish_reg_read(dev, msg_offs + i);
+
+	return 0;
+}
+
+/*
+ * write_ipc_from_queue - try to write ipc msg from Tx queue to device
+ *
+ * check if DRBL is cleared. if it is - write the first IPC msg,
+ * then call the callback function (unless it's NULL)
+ */
+int write_ipc_from_queue(struct ishtp_device *dev)
+{
+	struct wr_msg_ctl_info	*ipc_link;
+	unsigned long	length;
+	unsigned long	rem;
+	unsigned long	flags;
+	uint32_t	doorbell_val;
+	uint32_t	*r_buf;
+	uint32_t	reg_addr;
+	int	i;
+	void	(*ipc_send_compl)(void *);
+	void	*ipc_send_compl_prm;
+	static int	out_ipc_locked;
+	unsigned long	out_ipc_flags;
+
+	if (dev->dev_state == ISHTP_DEV_DISABLED)
+		return	-EINVAL;
+
+	spin_lock_irqsave(&dev->out_ipc_spinlock, out_ipc_flags);
+	if (out_ipc_locked) {
+		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
+		return -EBUSY;
+	}
+	out_ipc_locked = 1;
+	if (!ish_is_input_ready(dev)) {
+		out_ipc_locked = 0;
+		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
+		return -EBUSY;
+	}
+	spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
+
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	/*
+	 * if tx send list is empty - return 0;
+	 * may happen, as RX_COMPLETE handler doesn't check list emptiness.
+	 */
+	if (list_empty(&dev->wr_processing_list_head.link)) {
+		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+		out_ipc_locked = 0;
+		return	0;
+	}
+
+	ipc_link = list_entry(dev->wr_processing_list_head.link.next,
+		struct wr_msg_ctl_info, link);
+	/* first 4 bytes of the data is the doorbell value (IPC header) */
+	length = ipc_link->length - sizeof(uint32_t);
+	doorbell_val = *(uint32_t *)ipc_link->inline_data;
+	r_buf = (uint32_t *)(ipc_link->inline_data + sizeof(uint32_t));
+
+	/* If sending MNG_SYNC_FW_CLOCK, update clock again */
+	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG &&
+		IPC_HEADER_GET_MNG_CMD(doorbell_val) == MNG_SYNC_FW_CLOCK) {
+
+		struct timespec	ts;
+		uint64_t	usec;
+
+		get_monotonic_boottime(&ts);
+		usec = (uint64_t)ts.tv_sec * 1000000 +
+			(uint32_t)ts.tv_nsec / 1000;
+		r_buf[0] = (uint32_t)(usec & 0xFFFFFFFF);
+		r_buf[1] = (uint32_t)(usec >> 32);
+	}
+
+	for (i = 0, reg_addr = IPC_REG_HOST2ISH_MSG; i < length >> 2; i++,
+			reg_addr += 4)
+		ish_reg_write(dev, reg_addr, r_buf[i]);
+
+	rem = length & 0x3;
+	if (rem > 0) {
+		uint32_t reg = 0;
+		memcpy(&reg, &r_buf[length >> 2], rem);
+		ish_reg_write(dev, reg_addr, reg);
+	}
+
+	/* Update IPC counters */
+	++dev->ipc_tx_cnt;
+	dev->ipc_tx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
+
+	ish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, doorbell_val);
+	out_ipc_locked = 0;
+
+	ipc_send_compl = ipc_link->ipc_send_compl;
+	ipc_send_compl_prm = ipc_link->ipc_send_compl_prm;
+	list_del_init(&ipc_link->link);
+	list_add_tail(&ipc_link->link, &dev->wr_free_list_head.link);
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	/*
+	 * callback will be called out of spinlock,
+	 * after ipc_link returned to free list
+	 */
+	if (ipc_send_compl)
+		ipc_send_compl(ipc_send_compl_prm);
+	return 0;
+}
+
+/*
+ * write_ipc_to_queue - write ipc msg to Tx queue
+ *
+ * Got msg with IPC (and upper protocol) header
+ * and add it to the device Tx-to-write list
+ * then try to send the first IPC waiting msg (if DRBL is cleared)
+ * RETURN VALUE:	negative -	fail (means free links list is empty,
+ *					or msg too long)
+ *			0 -		succeed
+ */
+static int write_ipc_to_queue(struct ishtp_device *dev,
+	void (*ipc_send_compl)(void *), void *ipc_send_compl_prm,
+	unsigned char *msg, int length)
+{
+	struct wr_msg_ctl_info *ipc_link;
+	unsigned long	flags;
+
+	if (length > IPC_FULL_MSG_SIZE)
+		return -EMSGSIZE;
+
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	if (list_empty(&dev->wr_free_list_head.link)) {
+		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+		return -ENOMEM;
+	}
+	ipc_link = list_entry(dev->wr_free_list_head.link.next,
+		struct wr_msg_ctl_info, link);
+	list_del_init(&ipc_link->link);
+
+	ipc_link->ipc_send_compl = ipc_send_compl;
+	ipc_link->ipc_send_compl_prm = ipc_send_compl_prm;
+	ipc_link->length = length;
+	memcpy(ipc_link->inline_data, msg, length);
+
+	list_add_tail(&ipc_link->link, &dev->wr_processing_list_head.link);
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	write_ipc_from_queue(dev);
+	return 0;
+}
+
+static int	ipc_send_mng_msg(struct ishtp_device *dev, uint32_t msg_code,
+	void *msg, size_t size)
+{
+	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
+	uint32_t	drbl_val = IPC_BUILD_MNG_MSG(msg_code, size);
+
+	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
+	memcpy(ipc_msg + sizeof(uint32_t), msg, size);
+	return	write_ipc_to_queue(dev, NULL, NULL, ipc_msg,
+		sizeof(uint32_t) + size);
+}
+
+static int	ish_fw_reset_handler(struct ishtp_device *dev)
+{
+	uint32_t	reset_id;
+	unsigned long	flags;
+	struct wr_msg_ctl_info *processing, *next;
+
+	/* Read reset ID */
+	reset_id = ish_reg_read(dev, IPC_REG_ISH2HOST_MSG) & 0xFFFF;
+
+	/* Clear IPC output queue */
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	list_for_each_entry_safe(processing, next,
+			&dev->wr_processing_list_head.link, link) {
+		list_del(&processing->link);
+		list_add_tail(&processing->link, &dev->wr_free_list_head.link);
+	}
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	/* ISHTP notification in IPC_RESET */
+	ishtp_reset_handler(dev);
+
+	if (!ish_is_input_ready(dev))
+		timed_wait_for_timeout(WAIT_FOR_SEND_SLICE,
+			ish_is_input_ready(dev), (2 * HZ));
+
+	/* ISH FW is dead */
+	if (!ish_is_input_ready(dev)) {
+		return	-EPIPE;
+	} else {
+		/*
+		 * Set HOST2ISH.ILUP. Apparently we need this BEFORE sending
+		 * RESET_NOTIFY_ACK - FW will be checking for it
+		 */
+		ish_set_host_rdy(dev);
+		/* Send RESET_NOTIFY_ACK (with reset_id) */
+		ipc_send_mng_msg(dev, MNG_RESET_NOTIFY_ACK, &reset_id,
+			sizeof(uint32_t));
+	}
+
+	/* Wait for ISH FW'es ILUP and ISHTP_READY */
+	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, ishtp_fw_is_ready(dev),
+		(2 * HZ));
+	if (!ishtp_fw_is_ready(dev)) {
+		/* ISH FW is dead */
+		uint32_t	ish_status;
+		ish_status = _ish_read_fw_sts_reg(dev);
+		dev_err(dev->devc,
+			"[ishtp-ish]: completed reset, ISH is dead "
+			"(FWSTS = %08X)\n",
+			ish_status);
+		return -ENODEV;
+	}
+	return	0;
+}
+
+static void	fw_reset_work_fn(struct work_struct *unused)
+{
+	int	rv;
+	static int reset_cnt;
+
+	reset_cnt++;
+
+	rv = ish_fw_reset_handler(ishtp_dev);
+	if (!rv) {
+		/* ISH is ILUP & ISHTP-ready. Restart ISHTP */
+		/*
+		 * when reset flow occurs, sometimes the sysfs entries which
+		 * were removed in ish_fw_reset_handler are still up,
+		 * but the driver tries to create the same entries and fails.
+		 * so wait some time here and then the sysfs entries removal
+		 * will	be done.
+		 */
+		if (reset_cnt != 0) /* not the boot flow */
+			schedule_timeout(HZ / 3);
+		ishtp_dev->recvd_hw_ready = 1;
+		if (waitqueue_active(&ishtp_dev->wait_hw_ready))
+			wake_up(&ishtp_dev->wait_hw_ready);
+
+		/* ISHTP notification in IPC_RESET sequence completion */
+		ishtp_reset_compl_handler(ishtp_dev);
+	} else
+		dev_err(ishtp_dev->devc, "[ishtp-ish]: FW reset failed (%d)\n",
+			rv);
+}
+
+static void	_ish_sync_fw_clock(struct ishtp_device *dev)
+{
+	static unsigned long	prev_sync;
+	struct timespec	ts;
+	uint64_t	usec;
+
+	if (prev_sync && jiffies - prev_sync < 20 * HZ)
+		return;
+
+	prev_sync = jiffies;
+	get_monotonic_boottime(&ts);
+	usec = (uint64_t)ts.tv_sec * 1000000 + ((uint32_t)ts.tv_nsec / 1000);
+	ipc_send_mng_msg(dev, MNG_SYNC_FW_CLOCK, &usec, sizeof(uint64_t));
+}
+
+/*
+ * recv_ipc - Receive and process IPC management messages
+ *
+ * (!) ISR context
+ *
+ * NOTE: Any other mng command than reset_notify and reset_notify_ack
+ * won't wake BH handler
+ */
+static void	recv_ipc(struct ishtp_device *dev, uint32_t doorbell_val)
+{
+	uint32_t	mng_cmd;
+
+	mng_cmd = IPC_HEADER_GET_MNG_CMD(doorbell_val);
+
+	switch (mng_cmd) {
+	default:
+		break;
+
+	case MNG_RX_CMPL_INDICATION:
+		if (suspend_flag) {
+			suspend_flag = 0;
+			if (waitqueue_active(&suspend_wait))
+				wake_up(&suspend_wait);
+		}
+		write_ipc_from_queue(dev);
+		break;
+
+	case MNG_RESET_NOTIFY:
+		if (!ishtp_dev) {
+			ishtp_dev = dev;
+			INIT_WORK(&fw_reset_work, fw_reset_work_fn);
+		}
+		schedule_work(&fw_reset_work);
+		break;
+
+	case MNG_RESET_NOTIFY_ACK:
+		dev->recvd_hw_ready = 1;
+		if (waitqueue_active(&dev->wait_hw_ready))
+			wake_up(&dev->wait_hw_ready);
+		break;
+	}
+}
+
+/* ish_irq_handler - ISR of the ISHTP device */
+irqreturn_t ish_irq_handler(int irq, void *dev_id)
+{
+	struct ishtp_device	*dev = dev_id;
+	uint32_t	doorbell_val;
+	bool	interrupt_generated;
+
+	/* Check that it's interrupt from ISH (may be shared) */
+	interrupt_generated = check_generated_interrupt(dev);
+
+	if (!interrupt_generated)
+		return IRQ_NONE;
+
+	doorbell_val = ish_reg_read(dev, IPC_REG_ISH2HOST_DRBL);
+	if (!IPC_IS_BUSY(doorbell_val))
+		return IRQ_HANDLED;
+
+	if (dev->dev_state == ISHTP_DEV_DISABLED)
+		return	IRQ_HANDLED;
+
+	ish_intr_disable(dev);
+
+	/* Sanity check: IPC dgram length in header */
+	if (IPC_HEADER_GET_LENGTH(doorbell_val) > IPC_PAYLOAD_SIZE) {
+		dev_err(dev->devc,
+			"IPC hdr - bad length: %u; dropped\n",
+			(unsigned)IPC_HEADER_GET_LENGTH(doorbell_val));
+		goto	eoi;
+	}
+
+	switch (IPC_HEADER_GET_PROTOCOL(doorbell_val)) {
+	default:
+		break;
+	case IPC_PROTOCOL_MNG:
+		recv_ipc(dev, doorbell_val);
+		break;
+	case IPC_PROTOCOL_ISHTP:
+		recv_ishtp(dev);
+		break;
+	}
+
+eoi:
+	/* Update IPC counters */
+	++dev->ipc_rx_cnt;
+	dev->ipc_rx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
+
+	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
+	ish_intr_enable(dev);
+	return	IRQ_HANDLED;
+}
+
+static int _ish_hw_reset(struct ishtp_device *dev)
+{
+	struct pci_dev *pdev = ishtp_pci_device;
+	int	rv;
+	unsigned	dma_delay;
+	uint16_t csr;
+
+	if (!pdev)
+		return	-ENODEV;
+
+	rv = pci_reset_function(pdev);
+	if (!rv)
+		dev->dev_state = ISHTP_DEV_RESETTING;
+
+	if (!pdev->pm_cap) {
+		dev_err(&pdev->dev, "Can't reset - no PM caps\n");
+		return	-EINVAL;
+	}
+
+	/* Now trigger reset to FW */
+	ish_reg_write(dev, IPC_REG_ISH_RMP2, 0);
+
+	for (dma_delay = 0; dma_delay < MAX_DMA_DELAY &&
+		_ish_read_fw_sts_reg(dev) & (IPC_ISH_IN_DMA);
+		dma_delay += 5)
+			mdelay(5);
+
+	if (dma_delay >= MAX_DMA_DELAY) {
+		dev_err(&pdev->dev,
+			"Can't reset - stuck with DMA in-progress\n");
+		return	-EBUSY;
+	}
+
+	pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &csr);
+
+	csr &= ~PCI_PM_CTRL_STATE_MASK;
+	csr |= PCI_D3hot;
+	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
+
+	mdelay(pdev->d3_delay);
+
+	csr &= ~PCI_PM_CTRL_STATE_MASK;
+	csr |= PCI_D0;
+	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
+
+	ish_reg_write(dev, IPC_REG_ISH_RMP2, IPC_RMP2_DMA_ENABLED);
+
+	/* Send 0 IPC message so that ISH FW wakes up if it was already
+	 asleep */
+	ish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, IPC_DRBL_BUSY_BIT);
+
+	return	0;
+}
+
+/* _ish_ipc_reset - resets host and fw IPC and upper layers. */
+static int _ish_ipc_reset(struct ishtp_device *dev)
+{
+	struct ipc_rst_payload_type ipc_mng_msg;
+	int	rv = 0;
+
+	ipc_mng_msg.reset_id = 1;
+	ipc_mng_msg.reserved = 0;
+
+	ish_intr_enable(dev);
+
+	/* Clear the incoming doorbell */
+	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
+
+	dev->recvd_hw_ready = 0;
+
+	/* send message */
+	rv = ipc_send_mng_msg(dev, MNG_RESET_NOTIFY, &ipc_mng_msg,
+		sizeof(struct ipc_rst_payload_type));
+	if (rv) {
+		dev_err(dev->devc, "Failed to send IPC MNG_RESET_NOTIFY\n");
+		return	rv;
+	}
+
+	wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready, 2*HZ);
+	if (!dev->recvd_hw_ready) {
+		dev_err(dev->devc, "Timed out waiting for HW ready\n");
+		rv = -ENODEV;
+	}
+
+	return rv;
+}
+
+int ish_hw_start(struct ishtp_device *dev)
+{
+	ish_set_host_rdy(dev);
+	/* After that we can enable ISH DMA operation */
+	ish_reg_write(dev, IPC_REG_ISH_RMP2, IPC_RMP2_DMA_ENABLED);
+
+	/* Send 0 IPC message so that ISH FW wakes up if it was already
+	 asleep */
+	ish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, IPC_DRBL_BUSY_BIT);
+	ish_intr_enable(dev);
+
+	/* wait for FW-initiated reset flow */
+	if (!dev->recvd_hw_ready)
+		wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready,
+			10 * HZ);
+
+	if (!dev->recvd_hw_ready) {
+		dev_err(dev->devc,
+			"[ishtp-ish]: Timed out waiting for "
+			"FW-initiated reset\n");
+		return	-ENODEV;
+	}
+
+	return 0;
+}
+
+static const struct ishtp_hw_ops ish_hw_ops = {
+	.hw_reset = _ish_hw_reset,
+	.ipc_reset = _ish_ipc_reset,
+	.ishtp_read = _ishtp_read,
+	.write = write_ipc_to_queue,
+	.get_fw_status = _ish_read_fw_sts_reg,
+	.sync_fw_clock = _ish_sync_fw_clock,
+	.ishtp_read_hdr = _ishtp_read_hdr
+};
+
+struct ishtp_device *ish_dev_init(struct pci_dev *pdev)
+{
+	struct ishtp_device *dev;
+	int	i;
+
+	dev = kzalloc(sizeof(struct ishtp_device) + sizeof(struct ish_hw),
+		GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	ishtp_device_init(dev);
+
+	init_waitqueue_head(&dev->wait_hw_ready);
+
+	spin_lock_init(&dev->wr_processing_spinlock);
+	spin_lock_init(&dev->out_ipc_spinlock);
+
+	/* Init IPC processing and free lists */
+	INIT_LIST_HEAD(&dev->wr_processing_list_head.link);
+	INIT_LIST_HEAD(&dev->wr_free_list_head.link);
+	for (i = 0; i < IPC_TX_FIFO_SIZE; ++i) {
+		struct wr_msg_ctl_info	*tx_buf;
+
+		tx_buf = kmalloc(sizeof(struct wr_msg_ctl_info), GFP_KERNEL);
+		if (!tx_buf) {
+			/*
+			 * IPC buffers may be limited or not available
+			 * at all - although this shouldn't happen
+			 */
+			dev_err(dev->devc,
+				"[ishtp-ish]: failure in Tx FIFO "
+				"allocations (%d)\n", i);
+			break;
+		}
+		memset(tx_buf, 0, sizeof(struct wr_msg_ctl_info));
+		list_add_tail(&tx_buf->link, &dev->wr_free_list_head.link);
+	}
+
+	dev->ops = &ish_hw_ops;
+	dev->devc = &pdev->dev;
+	dev->mtu = IPC_PAYLOAD_SIZE - sizeof(struct ishtp_msg_hdr);
+	return dev;
+}
+
+void	ishtp_device_disable(struct ishtp_device *dev)
+{
+	dev->dev_state = ISHTP_DEV_DISABLED;
+	ish_clr_host_rdy(dev);
+	ish_intr_disable(dev);
+	kfree(dev->fw_clients);
+}
+
diff --git a/drivers/misc/intel-ish/ishtp-api.c b/drivers/misc/intel-ish/ishtp-api.c
new file mode 100644
index 0000000..eacca37
--- /dev/null
+++ b/drivers/misc/intel-ish/ishtp-api.c
@@ -0,0 +1,484 @@
+/*
+ * User-mode ISHTP API
+ *
+ * Copyright (c) 2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/uuid.h>
+#include <linux/compat.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include "ishtp-api.h"
+#include "ishtp_dev.h"
+#include "client.h"
+
+/* ishtp_open - the open function */
+static int ishtp_open(struct inode *inode, struct file *file)
+{
+	struct miscdevice *misc = file->private_data;
+	struct ishtp_cl *cl;
+	struct ishtp_device *dev;
+	int err;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	err = -ENODEV;
+	if (!misc->parent)
+		goto out;
+
+	dev = dev_get_drvdata(misc->parent);
+	if (!dev)
+		goto out;
+
+	err = -ENOMEM;
+	cl = ishtp_cl_allocate(dev);
+	if (!cl)
+		goto out_free;
+
+	/*
+	 * We may have a case of issued open() with
+	 * dev->dev_state == ISHTP_DEV_DISABLED, as part of re-enabling path
+	 */
+	err = -ENODEV;
+	if (dev->dev_state != ISHTP_DEV_ENABLED)
+		goto out_free;
+
+	err = ishtp_cl_link(cl, ISHTP_HOST_CLIENT_ID_ANY);
+	if (err)
+		goto out_free;
+
+	file->private_data = cl;
+
+	return nonseekable_open(inode, file);
+
+out_free:
+	kfree(cl);
+out:
+	return err;
+}
+
+/* ishtp_release - the release function */
+static int ishtp_release(struct inode *inode, struct file *file)
+{
+	struct ishtp_cl *cl = file->private_data;
+	struct ishtp_device *dev;
+	int rets = 0;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	/*
+	 * May happen if device sent FW reset or was intentionally
+	 * halted by host SW. The client is then invalid
+	 */
+	if ((dev->dev_state == ISHTP_DEV_ENABLED) &&
+			(cl->state == ISHTP_CL_CONNECTED)) {
+		cl->state = ISHTP_CL_DISCONNECTING;
+		rets = ishtp_cl_disconnect(cl);
+	}
+
+	ishtp_cl_unlink(cl);
+	ishtp_cl_flush_queues(cl);
+	file->private_data = NULL;
+
+	/* disband and free all Tx and Rx client-level rings */
+	ishtp_cl_free(cl);
+
+	return rets;
+}
+
+/* ishtp_read - the read function */
+static ssize_t ishtp_read(struct file *file, char __user *ubuf,
+			size_t length, loff_t *offset)
+{
+	struct ishtp_cl *cl = file->private_data;
+	struct ishtp_cl_rb *rb = NULL;
+	struct ishtp_device *dev;
+	unsigned long flags;
+	int rets = 0;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+	if (dev->dev_state != ISHTP_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	spin_lock_irqsave(&cl->in_process_spinlock, flags);
+	if (!list_empty(&cl->in_process_list.list)) {
+		rb = list_entry(cl->in_process_list.list.next,
+			struct ishtp_cl_rb, list);
+		list_del_init(&rb->list);
+		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+		goto copy_buffer;
+	}
+	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+
+	if (waitqueue_active(&cl->rx_wait)) {
+		rets = -EBUSY;
+		goto out;
+	}
+
+	if (wait_event_interruptible(cl->rx_wait,
+			(dev->dev_state == ISHTP_DEV_ENABLED &&
+			(cl->read_rb || ISHTP_CL_INITIALIZING == cl->state ||
+			ISHTP_CL_DISCONNECTED == cl->state ||
+			ISHTP_CL_DISCONNECTING == cl->state)))) {
+		dev_err(ishtp_misc_device.this_device,
+			"Woke up not in success; signal pending = %d signal = %08lX\n",
+			signal_pending(current),
+			current->pending.signal.sig[0]);
+		return	-ERESTARTSYS;
+	}
+
+	/*
+	 * If FW reset arrived, this will happen. Don't check cl->,
+	 * as 'cl' may be freed already
+	 */
+	if (dev->dev_state != ISHTP_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto	out;
+	}
+
+	if (ISHTP_CL_INITIALIZING == cl->state ||
+			ISHTP_CL_DISCONNECTED == cl->state ||
+			ISHTP_CL_DISCONNECTING == cl->state) {
+		rets = -EBUSY;
+		goto out;
+	}
+
+	rb = cl->read_rb;
+	if (!rb) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+copy_buffer:
+	/* now copy the data to user space */
+	if (length == 0 || ubuf == NULL || *offset > rb->buf_idx) {
+		rets = -EMSGSIZE;
+		goto free;
+	}
+
+	/* length is being truncated, however buf_idx may point beyond that */
+	length = min_t(size_t, length, rb->buf_idx - *offset);
+
+	if (copy_to_user(ubuf, rb->buffer.data + *offset, length)) {
+		rets = -EFAULT;
+		goto free;
+	}
+
+	rets = length;
+	*offset += length;
+	if ((unsigned long)*offset < rb->buf_idx)
+		goto out;
+
+free:
+	ishtp_io_rb_recycle(rb);
+	cl->read_rb = NULL;
+	*offset = 0;
+out:
+	return rets;
+}
+
+/* ishtp_write - the write function */
+static ssize_t ishtp_write(struct file *file, const char __user *ubuf,
+	size_t length, loff_t *offset)
+{
+	struct ishtp_cl *cl = file->private_data;
+	void *write_buf = NULL;
+	struct ishtp_device *dev;
+	int rets;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (dev->dev_state != ISHTP_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	if (cl->state != ISHTP_CL_CONNECTED) {
+		dev_err(ishtp_misc_device.this_device,
+			"host client = %d, is not connected to fw client = %d",
+			cl->host_client_id, cl->fw_client_id);
+		rets = -ENODEV;
+		goto out;
+	}
+
+	if (length <= 0) {
+		rets = -EMSGSIZE;
+		goto out;
+	}
+
+	if (length > cl->device->fw_client->props.max_msg_length) {
+		rets = -EMSGSIZE;
+		goto out;
+	}
+
+	write_buf = kmalloc(length, GFP_KERNEL);
+	if (!write_buf) {
+		dev_err(ishtp_misc_device.this_device,
+			"write buffer allocation failed\n");
+		rets = -ENOMEM;
+		goto	out;
+	}
+
+	rets = copy_from_user(write_buf, ubuf, length);
+	if (rets)
+		goto out;
+	rets = ishtp_cl_send(cl, write_buf, length);
+	if (!rets)
+		rets = length;
+	else
+		rets = -EIO;
+out:
+	kfree(write_buf);
+	return rets;
+}
+
+/* ishtp_ioctl_connect_client - the connect to fw client IOCTL function */
+static int ishtp_ioctl_connect_client(struct file *file,
+	struct ishtp_connect_client_data *data)
+{
+	struct ishtp_device *dev;
+	struct ishtp_client *client;
+	struct ishtp_cl *cl = file->private_data;
+	unsigned long flags;
+	int i;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (dev->dev_state != ISHTP_DEV_ENABLED)
+		return -ENODEV;
+
+	if (cl->state != ISHTP_CL_INITIALIZING &&
+			cl->state != ISHTP_CL_DISCONNECTED)
+		return -EBUSY;
+
+	/* find the fw client we're trying to connect to */
+	spin_lock_irqsave(&dev->fw_clients_lock, flags);
+	i = ishtp_fw_cl_by_uuid(dev, &data->in_client_uuid);
+	if (i < 0 || dev->fw_clients[i].props.fixed_address) {
+		spin_unlock_irqrestore(&dev->fw_clients_lock, flags);
+		return -ENODEV;
+	}
+	/* Check if there's driver attached to this UUID */
+	if (!ishtp_can_client_connect(dev, &data->in_client_uuid))
+		return -EBUSY;
+
+	cl->fw_client_id = dev->fw_clients[i].client_id;
+	cl->state = ISHTP_CL_CONNECTING;
+
+	/* prepare the output buffer */
+	client = &data->out_client_properties;
+	client->max_msg_length = dev->fw_clients[i].props.max_msg_length;
+	client->protocol_version = dev->fw_clients[i].props.protocol_version;
+	spin_unlock_irqrestore(&dev->fw_clients_lock, flags);
+
+	return ishtp_cl_connect(cl);
+}
+
+/* ishtp_ioctl - the IOCTL function */
+static long ishtp_ioctl(struct file *file, unsigned int cmd, unsigned long data)
+{
+	struct ishtp_device *dev;
+	struct ishtp_cl *cl = file->private_data;
+	struct ishtp_connect_client_data *connect_data = NULL;
+	unsigned ring_size;
+	int rets = 0;
+
+	if (!cl)
+		return -EINVAL;
+
+	dev = cl->dev;
+
+	/* Test API for triggering PCI reset */
+	if (cmd == IOCTL_ISH_HW_RESET)
+		return	ish_hw_reset(dev);
+
+	if (cmd == IOCTL_ISHTP_SET_RX_FIFO_SIZE) {
+		ring_size = data;
+		if (ring_size > CL_MAX_RX_RING_SIZE)
+			return	-EINVAL;
+		if (cl->state != ISHTP_CL_INITIALIZING)
+			return	-EBUSY;
+		cl->rx_ring_size = ring_size;
+		return	0;
+	}
+
+	if (cmd == IOCTL_ISHTP_SET_TX_FIFO_SIZE) {
+		ring_size = data;
+		if (ring_size > CL_MAX_TX_RING_SIZE)
+			return	-EINVAL;
+		if (cl->state != ISHTP_CL_INITIALIZING)
+			return	-EBUSY;
+		cl->tx_ring_size = ring_size;
+		return	0;
+	}
+
+	if (cmd == IOCTL_ISH_GET_FW_STATUS) {
+		char fw_stat_buf[20];
+		scnprintf(fw_stat_buf, sizeof(fw_stat_buf),
+			"%08X\n", dev->ops->get_fw_status(dev));
+		if (copy_to_user((char __user *)data, fw_stat_buf,
+				strlen(fw_stat_buf)))
+			return -EFAULT;
+		return strlen(fw_stat_buf);
+	}
+
+	if (cmd != IOCTL_ISHTP_CONNECT_CLIENT)
+		return -EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	if (dev->dev_state != ISHTP_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	connect_data = kzalloc(sizeof(struct ishtp_connect_client_data),
+							GFP_KERNEL);
+	if (!connect_data) {
+		rets = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(connect_data, (char __user *)data,
+			sizeof(struct ishtp_connect_client_data))) {
+		rets = -EFAULT;
+		goto out;
+	}
+
+	rets = ishtp_ioctl_connect_client(file, connect_data);
+
+	/* if all is ok, copying the data back to user. */
+	if (rets)
+		goto out;
+
+	if (copy_to_user((char __user *)data, connect_data,
+				sizeof(struct ishtp_connect_client_data))) {
+		rets = -EFAULT;
+		goto out;
+	}
+
+out:
+	kfree(connect_data);
+	return rets;
+}
+
+/* ishtp_compat_ioctl - the compat IOCTL function */
+#ifdef CONFIG_COMPAT
+static long ishtp_compat_ioctl(struct file *file,
+			unsigned int cmd, unsigned long data)
+{
+	return ishtp_ioctl(file, cmd, (unsigned long)compat_ptr(data));
+}
+#endif /* CONFIG_COMPAT */
+
+
+/*
+ * file operations structure will be used for ishtp char device.
+ */
+static const struct file_operations ishtp_fops = {
+	.owner = THIS_MODULE,
+	.read = ishtp_read,
+	.unlocked_ioctl = ishtp_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ishtp_compat_ioctl,
+#endif /* CONFIG_COMPAT */
+	.open = ishtp_open,
+	.release = ishtp_release,
+	.write = ishtp_write,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+struct miscdevice	ishtp_misc_device = {
+		.name = "ish",
+		.fops = &ishtp_fops,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+int ishtp_register(struct ishtp_device *dev)
+{
+	int ret;
+	ishtp_misc_device.parent = dev->devc;
+	ret = misc_register(&ishtp_misc_device);
+	if (ret)
+		return ret;
+
+	if (ishtp_dbgfs_register(dev, ishtp_misc_device.name))
+		dev_err(ishtp_misc_device.this_device,
+			"cannot register debugfs\n");
+	return 0;
+}
+EXPORT_SYMBOL(ishtp_register);
+
+void ishtp_deregister(struct ishtp_device *dev)
+{
+	if (ishtp_misc_device.parent == NULL)
+		return;
+
+	ishtp_dbgfs_deregister(dev);
+	misc_deregister(&ishtp_misc_device);
+	ishtp_misc_device.parent = NULL;
+}
+EXPORT_SYMBOL(ishtp_deregister);
+
+static int __init ishtp_init(void)
+{
+	return ishtp_cl_bus_init();
+}
+
+static void __exit ishtp_exit(void)
+{
+	ishtp_cl_bus_exit();
+}
+
+module_init(ishtp_init);
+module_exit(ishtp_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R)ISHTP user-mode API ");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/intel-ish/ishtp-api.h b/drivers/misc/intel-ish/ishtp-api.h
new file mode 100644
index 0000000..15c9658
--- /dev/null
+++ b/drivers/misc/intel-ish/ishtp-api.h
@@ -0,0 +1,117 @@
+/******************************************************************************
+ * Intel ISHTP Interface Header
+ *
+ * This file is provided under a dual BSD/GPLv2 license. When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2003 - 2016 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program;
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-ishtp@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2003 - 2016 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef _LINUX_ISHTP_H
+#define _LINUX_ISHTP_H
+
+#include <linux/uuid.h>
+
+/*
+ * This IOCTL is used to associate the current file descriptor with a
+ * FW Client (given by UUID). This opens a communication channel
+ * between a host client and a FW client. From this point every read and write
+ * will communicate with the associated FW client.
+ * Only in close() (file_operation release()) the communication between
+ * the clients is disconnected
+ *
+ * The IOCTL argument is a struct with a union that contains
+ * the input parameter and the output parameter for this IOCTL.
+ *
+ * The input parameter is UUID of the FW Client.
+ * The output parameter is the properties of the FW client
+ * (FW protocol version and max message size).
+ *
+ */
+#define IOCTL_ISHTP_CONNECT_CLIENT	_IOWR('H', 0x01,	\
+				struct ishtp_connect_client_data)
+
+/* Configuration: set number of Rx/Tx buffers. Must be used before connection */
+#define IOCTL_ISHTP_SET_RX_FIFO_SIZE	_IOWR('H', 0x02, long)
+#define IOCTL_ISHTP_SET_TX_FIFO_SIZE	_IOWR('H', 0x03, long)
+
+/* Get FW status */
+#define IOCTL_ISH_GET_FW_STATUS	_IO('H', 0x04)
+
+#define IOCTL_ISH_HW_RESET	_IO('H', 0x05)
+
+/*
+ * Intel ISHTP client information struct
+ */
+struct ishtp_client {
+	uint32_t max_msg_length;
+	uint8_t protocol_version;
+	uint8_t reserved[3];
+};
+
+/*
+ * IOCTL Connect Client Data structure
+ */
+struct ishtp_connect_client_data {
+	union {
+		uuid_le in_client_uuid;
+		struct ishtp_client out_client_properties;
+	};
+};
+
+#endif /* _LINUX_ISHTP_H */
+
diff --git a/drivers/misc/intel-ish/ishtp-hid-client.c b/drivers/misc/intel-ish/ishtp-hid-client.c
new file mode 100644
index 0000000..9954300
--- /dev/null
+++ b/drivers/misc/intel-ish/ishtp-hid-client.c
@@ -0,0 +1,612 @@
+/*
+ * ISHTP client driver for HID (ISH)
+ *
+ * Copyright (c) 2014-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/uuid.h>
+#include "ishtp_dev.h"
+#include "client.h"
+#include "ishtp-hid.h"
+
+/* Rx ring buffer pool size */
+#define HID_CL_RX_RING_SIZE	32
+#define HID_CL_TX_RING_SIZE	16
+
+/*
+ * Currently this driver works as long as there is only a single ISHTP client
+ * device
+ */
+struct ishtp_cl	*hid_ishtp_cl = NULL;			/* ISH ISHTP client */
+
+/* Set when ISH ISHTP client is successfully probed */
+int	hid_ishtp_client_found;
+int	enum_devices_done;	/* Enum devices response complete flag */
+int	hid_descr_done;		/* Get HID descriptor complete flag */
+int	report_descr_done;	/* Get report descriptor complete flag */
+int	get_report_done;	/* Get Feature/Input report complete flag */
+
+struct device_info	*hid_devices;
+struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
+unsigned	cur_hid_dev;
+unsigned	hid_dev_count;
+unsigned	num_hid_devices;
+unsigned char	*hid_descr[MAX_HID_DEVICES];
+int		hid_descr_size[MAX_HID_DEVICES];
+unsigned char	*report_descr[MAX_HID_DEVICES];
+int		report_descr_size[MAX_HID_DEVICES];
+
+static int	init_done;
+static wait_queue_head_t	init_wait;
+wait_queue_head_t	ishtp_hid_wait;
+struct work_struct hid_init_work;
+static unsigned	bad_recv_cnt;
+static int	multi_packet_cnt;
+
+void (*flush_cb)(void); /* flush notification */
+
+static void	report_bad_packet(void *recv_buf, size_t cur_pos,
+	size_t payload_len)
+{
+	struct hostif_msg	*recv_msg = recv_buf;
+
+	dev_err(&hid_ishtp_cl->device->dev, "[hid-ish]: BAD packet %02X\n"
+		"total_bad=%u cur_pos=%u\n"
+		"[%02X %02X %02X %02X]\n"
+		"payload_len=%u\n"
+		"multi_packet_cnt=%u\n"
+		"is_response=%02X\n",
+		recv_msg->hdr.command, bad_recv_cnt, (unsigned)cur_pos,
+		((unsigned char *)recv_msg)[0], ((unsigned char *)recv_msg)[1],
+		((unsigned char *)recv_msg)[2], ((unsigned char *)recv_msg)[3],
+		(unsigned)payload_len, multi_packet_cnt,
+		recv_msg->hdr.command & ~CMD_MASK);
+}
+
+/* ISHTP client driver structures and API for bus interface */
+static void	process_recv(void *recv_buf, size_t data_len)
+{
+	struct hostif_msg	*recv_msg;
+	unsigned char	*payload;
+
+	struct device_info	*dev_info;
+	int	i, j;
+	size_t	payload_len, total_len, cur_pos;
+	int	report_type;
+
+	struct report_list *reports_list;
+	char *reports;
+	size_t report_len;
+
+	if (data_len < sizeof(struct hostif_msg_hdr)) {
+		dev_err(&hid_ishtp_cl->device->dev,
+			"[hid-ish]: error, received %u which is "
+			"less than data header %u\n",
+			(unsigned)data_len,
+			(unsigned)sizeof(struct hostif_msg_hdr));
+		++bad_recv_cnt;
+		ish_hw_reset(hid_ishtp_cl->dev);
+		return;
+	}
+
+	payload = recv_buf + sizeof(struct hostif_msg_hdr);
+	total_len = data_len;
+	cur_pos = 0;
+
+	do {
+		recv_msg = (struct hostif_msg *)(recv_buf + cur_pos);
+		payload_len = recv_msg->hdr.size;
+
+		/* Sanity checks */
+		if (cur_pos + payload_len + sizeof(struct hostif_msg) >
+				total_len) {
+			++bad_recv_cnt;
+			report_bad_packet(recv_msg, cur_pos, payload_len);
+			ish_hw_reset(hid_ishtp_cl->dev);
+			break;
+		}
+
+
+		switch (recv_msg->hdr.command & CMD_MASK) {
+		default:
+			++bad_recv_cnt;
+			report_bad_packet(recv_msg, cur_pos, payload_len);
+			ish_hw_reset(hid_ishtp_cl->dev);
+			break;
+
+		case HOSTIF_DM_ENUM_DEVICES:
+			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
+					init_done)) {
+				++bad_recv_cnt;
+				report_bad_packet(recv_msg, cur_pos,
+					payload_len);
+				ish_hw_reset(hid_ishtp_cl->dev);
+				break;
+			}
+			hid_dev_count = (unsigned)*payload;
+			hid_devices = kmalloc(hid_dev_count *
+				sizeof(struct device_info), GFP_KERNEL);
+			if (hid_devices)
+				memset(hid_devices, 0, hid_dev_count *
+					sizeof(struct device_info));
+
+			for (i = 0; i < hid_dev_count; ++i) {
+				if (1 + sizeof(struct device_info) * i >=
+						payload_len) {
+					dev_err(&hid_ishtp_cl->device->dev,
+						"[hid-ish]: [ENUM_DEVICES]:"
+						" content size %lu "
+						"is bigger than "
+						"payload_len %u\n",
+						1 + sizeof(struct device_info)
+						* i,
+						(unsigned)payload_len);
+				}
+
+				if (1 + sizeof(struct device_info) * i >=
+						data_len)
+					break;
+
+				dev_info = (struct device_info *)(payload + 1 +
+					sizeof(struct device_info) * i);
+				if (hid_devices)
+					memcpy(hid_devices + i, dev_info,
+						sizeof(struct device_info));
+			}
+
+			enum_devices_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_HID_DESCRIPTOR:
+			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
+					init_done)) {
+				++bad_recv_cnt;
+				report_bad_packet(recv_msg, cur_pos,
+					payload_len);
+				ish_hw_reset(hid_ishtp_cl->dev);
+				break;
+			}
+			hid_descr[cur_hid_dev] = kmalloc(payload_len,
+				GFP_KERNEL);
+			if (hid_descr[cur_hid_dev])
+				memcpy(hid_descr[cur_hid_dev], payload,
+					payload_len);
+			hid_descr_size[cur_hid_dev] = payload_len;
+
+			hid_descr_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_REPORT_DESCRIPTOR:
+			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
+					init_done)) {
+				++bad_recv_cnt;
+				report_bad_packet(recv_msg, cur_pos,
+					payload_len);
+				ish_hw_reset(hid_ishtp_cl->dev);
+				break;
+			}
+			report_descr[cur_hid_dev] = kmalloc(payload_len,
+				GFP_KERNEL);
+			if (report_descr[cur_hid_dev])
+				memcpy(report_descr[cur_hid_dev], payload,
+					payload_len);
+			report_descr_size[cur_hid_dev] = payload_len;
+
+			report_descr_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_FEATURE_REPORT:
+			report_type = HID_FEATURE_REPORT;
+			flush_cb(); /* each "GET_FEATURE_REPORT" may indicate
+					a flush complete event */
+			goto	do_get_report;
+
+		case HOSTIF_GET_INPUT_REPORT:
+			report_type = HID_INPUT_REPORT;
+do_get_report:
+			/* Get index of device that matches this id */
+			for (i = 0; i < num_hid_devices; ++i)
+				if (recv_msg->hdr.device_id ==
+						hid_devices[i].dev_id)
+					if (hid_sensor_hubs[i] != NULL) {
+						hid_input_report(
+							hid_sensor_hubs[i],
+							report_type, payload,
+							payload_len, 0);
+						break;
+					}
+			get_report_done = 1;
+			if (waitqueue_active(&ishtp_hid_wait))
+				wake_up(&ishtp_hid_wait);
+			break;
+
+		case HOSTIF_SET_FEATURE_REPORT:
+			get_report_done = 1;
+			if (waitqueue_active(&ishtp_hid_wait))
+				wake_up(&ishtp_hid_wait);
+			break;
+
+		case HOSTIF_PUBLISH_INPUT_REPORT:
+			report_type = HID_INPUT_REPORT;
+			for (i = 0; i < num_hid_devices; ++i)
+				if (recv_msg->hdr.device_id ==
+						hid_devices[i].dev_id)
+					if (hid_sensor_hubs[i] != NULL)
+						hid_input_report(
+							hid_sensor_hubs[i],
+							report_type, payload,
+							payload_len, 0);
+			break;
+
+		case HOSTIF_PUBLISH_INPUT_REPORT_LIST:
+			report_type = HID_INPUT_REPORT;
+			reports_list = (struct report_list *)payload;
+			reports = (char *)reports_list->reports;
+
+			for (j = 0; j < reports_list->num_of_reports; j++) {
+				recv_msg = (struct hostif_msg *)(reports +
+					sizeof(uint16_t));
+				report_len = *(uint16_t *)reports;
+				payload = reports + sizeof(uint16_t) +
+					sizeof(struct hostif_msg_hdr);
+				payload_len = report_len -
+					sizeof(struct hostif_msg_hdr);
+
+				for (i = 0; i < num_hid_devices; ++i)
+					if (recv_msg->hdr.device_id ==
+							hid_devices[i].dev_id &&
+							hid_sensor_hubs[i] !=
+							NULL) {
+						hid_input_report(
+							hid_sensor_hubs[i],
+							report_type,
+							payload, payload_len,
+							0);
+					}
+
+				reports += sizeof(uint16_t) + report_len;
+			}
+			break;
+		}
+
+		if (!cur_pos && cur_pos + payload_len +
+				sizeof(struct hostif_msg) < total_len)
+			++multi_packet_cnt;
+
+		cur_pos += payload_len + sizeof(struct hostif_msg);
+		payload += payload_len + sizeof(struct hostif_msg);
+
+	} while (cur_pos < total_len);
+}
+
+void ish_cl_event_cb(struct ishtp_cl_device *device)
+{
+	size_t r_length;
+	struct ishtp_cl_rb *rb_in_proc;
+	unsigned long	flags;
+
+	if (!hid_ishtp_cl)
+		return;
+
+	spin_lock_irqsave(&hid_ishtp_cl->in_process_spinlock, flags);
+	while (!list_empty(&hid_ishtp_cl->in_process_list.list)) {
+		rb_in_proc = list_entry(hid_ishtp_cl->in_process_list.list.next,
+			struct ishtp_cl_rb, list);
+		list_del_init(&rb_in_proc->list);
+		spin_unlock_irqrestore(&hid_ishtp_cl->in_process_spinlock,
+			flags);
+
+		if (!rb_in_proc->buffer.data)
+			return;
+
+		r_length = rb_in_proc->buf_idx;
+
+		/* decide what to do with received data */
+		process_recv(rb_in_proc->buffer.data, r_length);
+
+		ishtp_io_rb_recycle(rb_in_proc);
+		spin_lock_irqsave(&hid_ishtp_cl->in_process_spinlock, flags);
+	}
+	spin_unlock_irqrestore(&hid_ishtp_cl->in_process_spinlock, flags);
+}
+
+void hid_ishtp_set_feature(struct hid_device *hid, char *buf, unsigned len,
+	int report_id)
+{
+	int	rv;
+	struct hostif_msg *msg = (struct hostif_msg *)buf;
+	int	i;
+
+	memset(msg, 0, sizeof(struct hostif_msg));
+	msg->hdr.command = HOSTIF_SET_FEATURE_REPORT;
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid == hid_sensor_hubs[i]) {
+			msg->hdr.device_id = hid_devices[i].dev_id;
+			break;
+		}
+	if (i == num_hid_devices)
+		return;
+
+	rv = ishtp_cl_send(hid_ishtp_cl, buf, len);
+}
+
+void hid_ishtp_get_report(struct hid_device *hid, int report_id,
+	int report_type)
+{
+	int	rv;
+	static unsigned char	buf[10];
+	unsigned	len;
+	struct hostif_msg_to_sensor *msg = (struct hostif_msg_to_sensor *)buf;
+	int	i;
+
+	len = sizeof(struct hostif_msg_to_sensor);
+
+	memset(msg, 0, sizeof(struct hostif_msg_to_sensor));
+	msg->hdr.command = (report_type == HID_FEATURE_REPORT) ?
+		HOSTIF_GET_FEATURE_REPORT : HOSTIF_GET_INPUT_REPORT;
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid == hid_sensor_hubs[i]) {
+			msg->hdr.device_id = hid_devices[i].dev_id;
+			break;
+		}
+	if (i == num_hid_devices)
+		return;
+
+	msg->report_id = report_id;
+	rv = ishtp_cl_send(hid_ishtp_cl, buf, len);
+}
+
+int	hid_ishtp_cl_probe(struct ishtp_cl_device *cl_device)
+{
+	int	rv;
+
+	if (!cl_device)
+		return	-ENODEV;
+
+	if (uuid_le_cmp(hid_ishtp_guid,
+			cl_device->fw_client->props.protocol_name) != 0)
+		return	-ENODEV;
+
+	hid_ishtp_cl = ishtp_cl_allocate(cl_device->ishtp_dev);
+	if (!hid_ishtp_cl)
+		return	-ENOMEM;
+
+	rv = ishtp_cl_link(hid_ishtp_cl, ISHTP_HOST_CLIENT_ID_ANY);
+	if (rv)
+		return	-ENOMEM;
+
+	hid_ishtp_client_found = 1;
+	if (waitqueue_active(&init_wait))
+		wake_up(&init_wait);
+
+	schedule_work(&hid_init_work);
+
+	return	0;
+}
+
+int	hid_ishtp_cl_remove(struct ishtp_cl_device *dev)
+{
+	int i;
+
+	ishtp_hid_remove();
+	hid_ishtp_client_found = 0;
+
+	ishtp_cl_unlink(hid_ishtp_cl);
+	ishtp_cl_flush_queues(hid_ishtp_cl);
+
+	/* disband and free all Tx and Rx client-level rings */
+	ishtp_cl_free(hid_ishtp_cl);
+	hid_ishtp_cl = NULL;
+
+	for (i = 0; i < num_hid_devices ; ++i) {
+		kfree(hid_descr[i]);
+		kfree(report_descr[i]);
+	}
+	num_hid_devices = 0;
+	return 0;
+}
+
+
+struct ishtp_cl_driver	hid_ishtp_cl_driver = {
+	.name = "ish",
+	.probe = hid_ishtp_cl_probe,
+	.remove = hid_ishtp_cl_remove,
+};
+
+static void workqueue_init_function(struct work_struct *work)
+{
+	int	rv;
+	static unsigned char	buf[512];
+	unsigned	len;
+	struct hostif_msg	*msg = (struct hostif_msg *)buf;
+	int	i;
+	struct ishtp_device	*dev;
+	int	retry_count;
+	unsigned long	flags;
+
+	init_done = 0;
+
+	if (!hid_ishtp_client_found)
+		wait_event_timeout(init_wait, hid_ishtp_client_found, 30 * HZ);
+
+	if (!hid_ishtp_client_found) {
+		dev_err(NULL,
+			"[hid-ish]: timed out waiting for hid-ishtp-client\n");
+		rv = -ENODEV;
+		goto	ret;
+	}
+
+	dev = hid_ishtp_cl->dev;
+
+	/* Connect to FW client */
+	hid_ishtp_cl->rx_ring_size = HID_CL_RX_RING_SIZE;
+	hid_ishtp_cl->tx_ring_size = HID_CL_TX_RING_SIZE;
+
+	spin_lock_irqsave(&dev->fw_clients_lock, flags);
+	i = ishtp_fw_cl_by_uuid(dev, &hid_ishtp_guid);
+	hid_ishtp_cl->fw_client_id = dev->fw_clients[i].client_id;
+	spin_unlock_irqrestore(&dev->fw_clients_lock, flags);
+	hid_ishtp_cl->state = ISHTP_CL_CONNECTING;
+
+	rv = ishtp_cl_connect(hid_ishtp_cl);
+	if (rv)
+		goto	ret;
+
+	/* Register read callback */
+	ishtp_register_event_cb(hid_ishtp_cl->device, ish_cl_event_cb);
+
+	/* Send HOSTIF_DM_ENUM_DEVICES */
+	memset(msg, 0, sizeof(struct hostif_msg));
+	msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
+	len = sizeof(struct hostif_msg);
+	rv = ishtp_cl_send(hid_ishtp_cl, buf, len);
+	if (rv)
+		goto	ret;
+
+	rv = 0;
+
+	retry_count = 0;
+	while (!enum_devices_done && retry_count < 10) {
+		wait_event_timeout(init_wait, enum_devices_done, 3 * HZ);
+		++retry_count;
+		if (!enum_devices_done)
+			/* Send HOSTIF_DM_ENUM_DEVICES */
+			rv = ishtp_cl_send(hid_ishtp_cl, buf, len);
+	}
+	if (!enum_devices_done) {
+		dev_err(&hid_ishtp_cl->device->dev,
+			"[hid-ish]: timed out waiting for enum_devices_done\n");
+		rv = -ETIMEDOUT;
+		goto	ret;
+	}
+	if (!hid_devices) {
+		dev_err(&hid_ishtp_cl->device->dev,
+			"[hid-ish]: failed to allocate HID dev structures\n");
+		rv = -ENOMEM;
+		goto	ret;
+	}
+
+	/* Send GET_HID_DESCRIPTOR for each device */
+	num_hid_devices = hid_dev_count;
+	dev_warn(&hid_ishtp_cl->device->dev,
+		"[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n",
+		num_hid_devices);
+
+	for (i = 0; i < num_hid_devices; ++i) {
+		cur_hid_dev = i;
+
+		/* Get HID descriptor */
+		hid_descr_done = 0;
+		memset(msg, 0, sizeof(struct hostif_msg));
+		msg->hdr.command = HOSTIF_GET_HID_DESCRIPTOR;
+		msg->hdr.device_id = hid_devices[i].dev_id;
+		len = sizeof(struct hostif_msg);
+		rv = ishtp_cl_send(hid_ishtp_cl, buf, len);
+		rv = 0;
+
+		if (!hid_descr_done)
+			wait_event_timeout(init_wait, hid_descr_done, 30 * HZ);
+		if (!hid_descr_done) {
+			dev_err(&hid_ishtp_cl->device->dev,
+				"[hid-ish]: timed out waiting for hid_descr_done\n");
+			continue;
+		}
+
+		if (!hid_descr[i]) {
+			dev_err(&hid_ishtp_cl->device->dev,
+				"[hid-ish]: failed to allocate HID descriptor buffer\n");
+			continue;
+		}
+
+		/* Get report descriptor */
+		report_descr_done = 0;
+		memset(msg, 0, sizeof(struct hostif_msg));
+		msg->hdr.command = HOSTIF_GET_REPORT_DESCRIPTOR;
+		msg->hdr.device_id = hid_devices[i].dev_id;
+		len = sizeof(struct hostif_msg);
+		rv = ishtp_cl_send(hid_ishtp_cl, buf, len);
+
+		rv = 0;
+
+		if (!report_descr_done)
+			wait_event_timeout(init_wait, report_descr_done,
+				30 * HZ);
+		if (!report_descr_done) {
+			dev_err(&hid_ishtp_cl->device->dev,
+				"[hid-ish]: timed out wait for report descr\n");
+			continue;
+		}
+
+		if (!report_descr[i]) {
+			dev_err(&hid_ishtp_cl->device->dev,
+				"[hid-ish]: failed to alloc report descr\n");
+			continue;
+		}
+
+		rv = ishtp_hid_probe(i);
+		if (rv) {
+			dev_err(&hid_ishtp_cl->device->dev,
+				"[hid-ish]: HID probe for #%u failed: %d\n",
+				i, rv);
+			continue;
+		}
+	} /* for() on all hid devices */
+
+ret:
+	init_done = 1;
+}
+
+static int __init ish_init(void)
+{
+	int	rv;
+
+	ISH_INFO_PRINT(KERN_ERR "[hid-ish]: Build " BUILD_ID "\n");
+	g_ish_print_log(
+		"[hid-ish]: %s():+++ [Build " BUILD_ID "]\n", __func__);
+
+	init_waitqueue_head(&init_wait);
+	init_waitqueue_head(&ishtp_hid_wait);
+	INIT_WORK(&hid_init_work, workqueue_init_function);
+
+	/* Register ISHTP client device driver - ISH */
+	rv = ishtp_cl_driver_register(&hid_ishtp_cl_driver);
+
+	return rv;
+
+}
+late_initcall(ish_init);
+
+static void __exit ish_exit(void)
+{
+	ishtp_cl_driver_unregister(&hid_ishtp_cl_driver);
+}
+module_exit(ish_exit);
+
+MODULE_DESCRIPTION("ISH ISHTP client driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/intel-ish/ishtp-hid.c b/drivers/misc/intel-ish/ishtp-hid.c
new file mode 100644
index 0000000..c9e5314
--- /dev/null
+++ b/drivers/misc/intel-ish/ishtp-hid.c
@@ -0,0 +1,183 @@
+/*
+ * ISHTP-HID glue driver.
+ *
+ * Copyright (c) 2012-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/hid.h>
+#include <linux/sched.h>
+#include "ishtp-hid.h"
+
+static int ishtp_hid_parse(struct hid_device *hid)
+{
+	int	rv;
+
+	rv = hid_parse_report(hid, report_descr[cur_hid_dev],
+		report_descr_size[cur_hid_dev]);
+	if (rv)
+		return	rv;
+
+	return 0;
+}
+
+static int ishtp_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void ishtp_hid_stop(struct hid_device *hid)
+{
+	return;
+}
+
+static int ishtp_hid_open(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void ishtp_hid_close(struct hid_device *hid)
+{
+	return;
+}
+
+static int ishtp_hid_power(struct hid_device *hid, int lvl)
+{
+	return 0;
+}
+
+static void ishtp_hid_request(struct hid_device *hid, struct hid_report *rep,
+	int reqtype)
+{
+	/* the specific report length, just HID part of it */
+	unsigned len = ((rep->size - 1) >> 3) + 1 + (rep->id > 0);
+	char *buf;
+	unsigned header_size = sizeof(struct hostif_msg);
+
+	len += header_size;
+
+	switch (reqtype) {
+	case HID_REQ_GET_REPORT:
+		hid_ishtp_get_report(hid, rep->id, rep->type);
+		break;
+	case HID_REQ_SET_REPORT:
+		/* Spare 7 bytes for 64b accesses through
+		get/put_unaligned_le64() */
+		buf = kzalloc(len + 7, GFP_KERNEL);
+		if (!buf)
+			return;
+		hid_output_report(rep, buf + header_size);
+		hid_ishtp_set_feature(hid, buf, len, rep->id);
+		kfree(buf);
+		break;
+	}
+
+	return;
+}
+
+static int ishtp_hid_hidinput_input_event(struct input_dev *dev,
+		unsigned int type, unsigned int code, int value)
+{
+	return 0;
+}
+
+static int ishtp_wait_for_response(struct hid_device *hid)
+{
+	if (!get_report_done)
+		wait_event_timeout(ishtp_hid_wait, get_report_done, 3 * HZ);
+
+	if (!get_report_done) {
+		hid_err(hid, "timeout waiting for response from ISHTP device\n");
+		return -1;
+	}
+
+	get_report_done = 0;
+	return 0;
+}
+
+static struct hid_ll_driver ishtp_hid_ll_driver = {
+	.parse = ishtp_hid_parse,
+	.start = ishtp_hid_start,
+	.stop = ishtp_hid_stop,
+	.open = ishtp_hid_open,
+	.close = ishtp_hid_close,
+	.power = ishtp_hid_power,
+	.request = ishtp_hid_request,
+	.hidinput_input_event = ishtp_hid_hidinput_input_event,
+	.wait = ishtp_wait_for_response
+};
+
+static int ishtp_hid_get_raw_report(struct hid_device *hid,
+	unsigned char report_number, uint8_t *buf, size_t count,
+	unsigned char report_type)
+{
+	return	0;
+}
+
+static int ishtp_hid_output_raw_report(struct hid_device *hid, uint8_t *buf,
+	size_t count, unsigned char report_type)
+{
+	return	0;
+}
+
+int	ishtp_hid_probe(unsigned cur_hid_dev)
+{
+	int rv;
+	struct hid_device	*hid;
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid)) {
+		rv = PTR_ERR(hid);
+		return	-ENOMEM;
+	}
+
+	hid_sensor_hubs[cur_hid_dev] = hid;
+
+	hid->ll_driver = &ishtp_hid_ll_driver;
+	hid->hid_get_raw_report = ishtp_hid_get_raw_report;
+	hid->hid_output_raw_report = ishtp_hid_output_raw_report;
+	hid->bus = BUS_ISHTP;
+	hid->version = le16_to_cpu(ISH_HID_VERSION);
+	hid->vendor = le16_to_cpu(ISH_HID_VENDOR);
+	hid->product = le16_to_cpu(ISH_HID_PRODUCT);
+
+	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX", "hid-ishtp",
+		hid->vendor, hid->product);
+
+	rv = hid_add_device(hid);
+	if (rv) {
+		if (rv != -ENODEV)
+			hid_err(hid, "[hid-ishtp]: can't add HID device: %d\n",
+				rv);
+		kfree(hid);
+		return	rv;
+	}
+
+	return 0;
+}
+
+void	ishtp_hid_remove(void)
+{
+	int	i;
+
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid_sensor_hubs[i]) {
+			hid_destroy_device(hid_sensor_hubs[i]);
+			hid_sensor_hubs[i] = NULL;
+		}
+}
+
+void register_flush_cb(void (*flush_cb_func)(void))
+{
+	flush_cb = flush_cb_func;
+}
+EXPORT_SYMBOL(register_flush_cb);
+
diff --git a/drivers/misc/intel-ish/ishtp-hid.h b/drivers/misc/intel-ish/ishtp-hid.h
new file mode 100644
index 0000000..eb08534
--- /dev/null
+++ b/drivers/misc/intel-ish/ishtp-hid.h
@@ -0,0 +1,131 @@
+/*
+ * ISHTP-HID glue driver's definitions.
+ *
+ * Copyright (c) 2014-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+#ifndef ISHTP_HID__H
+#define	ISHTP_HID__H
+
+/*
+ * Currently we support only 1 ISH HW controller in a system
+ */
+
+/*
+ * TODO: figure out if this number is used for anything but assignment.
+ * (http://www.lanana.org)
+ */
+#define	BUS_ISHTP	0x44
+/*
+ * TODO: just to bootstrap, numbers will probably change
+ * (http://www.lanana.org)
+ */
+#define	ISH_HID_VENDOR	0x8086
+#define	ISH_HID_PRODUCT	0x22D8
+#define	ISH_HID_VERSION	0x0200
+
+#define	CMD_MASK	0x7F
+#define	IS_RESPONSE	0x80
+
+static const uuid_le hid_ishtp_guid = UUID_LE(0x33AECD58, 0xB679, 0x4E54,
+						0x9B, 0xD9, 0xA0, 0x4D, 0x34,
+						0xF0, 0xC2, 0x26);
+
+extern wait_queue_head_t	ishtp_hid_wait;
+
+/* flush notification */
+extern void (*flush_cb)(void);
+
+struct hostif_msg_hdr {
+	uint8_t	command;	/* Bit 7: is_response */
+	uint8_t	device_id;
+	uint8_t	status;
+	uint8_t	flags;
+	uint16_t	size;
+} __packed;
+
+struct hostif_msg {
+	struct hostif_msg_hdr	hdr;
+} __packed;
+
+struct hostif_msg_to_sensor {
+	struct hostif_msg_hdr	hdr;
+	uint8_t	report_id;
+} __packed;
+
+struct device_info {
+	uint32_t dev_id;
+	uint8_t dev_class;
+	uint16_t pid;
+	uint16_t vid;
+} __packed;
+
+struct ishtp_version {
+	uint8_t	major;
+	uint8_t	minor;
+	uint8_t	hotfix;
+	uint16_t build;
+} __packed;
+
+/*
+ * struct for ishtp aggregated input data
+ */
+struct report_list {
+	uint16_t total_size;
+	uint8_t	num_of_reports;
+	uint8_t	flags;
+	struct {
+		uint16_t	size_of_report;
+		uint8_t report[1];
+	} __packed reports[1];
+} __packed;
+
+/* HOSTIF commands */
+#define	HOSTIF_HID_COMMAND_BASE		0
+#define	HOSTIF_GET_HID_DESCRIPTOR	0
+#define	HOSTIF_GET_REPORT_DESCRIPTOR	1
+#define HOSTIF_GET_FEATURE_REPORT	2
+#define	HOSTIF_SET_FEATURE_REPORT	3
+#define	HOSTIF_GET_INPUT_REPORT		4
+#define	HOSTIF_PUBLISH_INPUT_REPORT	5
+#define	HOSTIF_PUBLISH_INPUT_REPORT_LIST	6
+#define	HOSTIF_DM_COMMAND_BASE		32
+#define	HOSTIF_DM_ENUM_DEVICES		33
+#define	HOSTIF_DM_ADD_DEVICE		34
+
+#define	MAX_HID_DEVICES	32
+
+extern unsigned char	*report_descr[MAX_HID_DEVICES];
+extern int	report_descr_size[MAX_HID_DEVICES];
+extern struct device_info	*hid_devices;
+extern int	get_report_done; /* Get Feature/Input report complete flag */
+extern unsigned	cur_hid_dev;
+extern struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
+extern unsigned	num_hid_devices;
+extern struct ishtp_cl	*hid_ishtp_cl;	/* ISHTP client */
+
+void hid_ishtp_set_feature(struct hid_device *hid, char *buf, unsigned len,
+	int report_id);
+void hid_ishtp_get_report(struct hid_device *hid, int report_id,
+	int report_type);
+
+int	ishtp_hid_probe(unsigned cur_hid_dev);
+void	ishtp_hid_remove(void);
+
+/* flush notification */
+void register_flush_cb(void (*flush_cb_func)(void));
+
+/*********** Locally redirect ish_print_log **************/
+void g_ish_print_log(char *format, ...);
+/*********************************************************/
+
+#endif	/* ISHTP_HID__H */
+
diff --git a/drivers/misc/intel-ish/ishtp_dev.h b/drivers/misc/intel-ish/ishtp_dev.h
new file mode 100644
index 0000000..4ba1f39
--- /dev/null
+++ b/drivers/misc/intel-ish/ishtp_dev.h
@@ -0,0 +1,269 @@
+/*
+ * Most ISHTP provider device and ISHTP logic declarations
+ *
+ * Copyright (c) 2003-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _ISHTP_DEV_H_
+#define _ISHTP_DEV_H_
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include "platform-config.h"
+#include "bus.h"
+#include "hbm.h"
+
+#define	IPC_PAYLOAD_SIZE	128
+#define ISHTP_RD_MSG_BUF_SIZE	IPC_PAYLOAD_SIZE
+#define	IPC_FULL_MSG_SIZE	132
+/* Number of messages to be held in ISR->BH FIFO */
+#define	RD_INT_FIFO_SIZE	64
+/*
+ * Number of IPC messages to be held in Tx FIFO, to be sent by ISR -
+ * Tx complete interrupt or RX_COMPLETE handler
+ */
+#define	IPC_TX_FIFO_SIZE	512
+
+/*
+ * Number of Maximum ISHTP Clients
+ */
+#define ISHTP_CLIENTS_MAX 256
+
+/*
+ * Number of File descriptors/handles
+ * that can be opened to the driver.
+ *
+ * Limit to 255: 256 Total Clients
+ * minus internal client for ISHTP Bus Messags
+ */
+#define ISHTP_MAX_OPEN_HANDLE_COUNT (ISHTP_CLIENTS_MAX - 1)
+
+/*
+ * Internal Clients Number
+ */
+#define ISHTP_HOST_CLIENT_ID_ANY		(-1)
+#define ISHTP_HBM_HOST_CLIENT_ID		0
+
+#define	MAX_DMA_DELAY	20
+/* size of ISH internal log (if enabled) */
+#define PRINT_BUFFER_SIZE 204800
+
+/* ISHTP device states */
+enum ishtp_dev_state {
+	ISHTP_DEV_INITIALIZING = 0,
+	ISHTP_DEV_INIT_CLIENTS,
+	ISHTP_DEV_ENABLED,
+	ISHTP_DEV_RESETTING,
+	ISHTP_DEV_DISABLED,
+	ISHTP_DEV_POWER_DOWN,
+	ISHTP_DEV_POWER_UP
+};
+const char *ishtp_dev_state_str(int state);
+
+struct ishtp_cl;
+
+/**
+ * struct ishtp_fw_client - representation of fw client
+ *
+ * @props - client properties
+ * @client_id - fw client id
+ */
+struct ishtp_fw_client {
+	struct ishtp_client_properties props;
+	uint8_t client_id;
+};
+
+/*
+ * Intel ISHTP message data struct
+ */
+struct ishtp_msg_data {
+	uint32_t size;
+	unsigned char *data;
+};
+
+/**
+ * struct ishtp_cl_rb - request block structure
+ */
+struct ishtp_cl_rb {
+	struct list_head list;
+	struct ishtp_cl *cl;
+	struct ishtp_msg_data buffer;
+	unsigned long buf_idx;
+	unsigned long read_time;
+};
+
+/*
+ * Control info for IPC messages ISHTP/IPC sending FIFO -
+ * list with inline data buffer
+ * This structure will be filled with parameters submitted
+ * by the caller glue layer
+ * 'buf' may be pointing to the external buffer or to 'inline_data'
+ * 'offset' will be initialized to 0 by submitting
+ *
+ * 'ipc_send_compl' is intended for use by clients that send fragmented
+ * messages. When a fragment is sent down to IPC msg regs,
+ * it will be called.
+ * If it has more fragments to send, it will do it. With last fragment
+ * it will send appropriate ISHTP "message-complete" flag.
+ * It will remove the outstanding message
+ * (mark outstanding buffer as available).
+ * If counting flow control is in work and there are more flow control
+ * credits, it can put the next client message queued in cl.
+ * structure for IPC processing.
+ *
+ * (!) We can work on FIFO list or cyclic FIFO in an array
+ */
+struct wr_msg_ctl_info {
+	void (*ipc_send_compl)(void *);	/* Will be called with
+					'ipc_send_compl_prm' as parameter */
+	void *ipc_send_compl_prm;
+	size_t length;
+	struct list_head	link;
+	unsigned char	inline_data[IPC_FULL_MSG_SIZE];
+};
+
+struct ishtp_hw_ops {
+	int	(*hw_reset)(struct ishtp_device *dev);
+	int	(*ipc_reset)(struct ishtp_device *dev);
+	int	(*write)(struct ishtp_device *dev,
+		void (*ipc_send_compl)(void *), void *ipc_send_compl_prm,
+		unsigned char *msg, int length);
+	uint32_t	(*ishtp_read_hdr)(const struct ishtp_device *dev);
+	int	(*ishtp_read)(struct ishtp_device *dev, unsigned char *buffer,
+			unsigned long buffer_length);
+	uint32_t	(*get_fw_status)(struct ishtp_device *dev);
+	void	(*sync_fw_clock)(struct ishtp_device *dev);
+};
+
+/**
+ * struct ishtp_device - ISHTP private device struct
+ */
+struct ishtp_device {
+	struct device *devc;	/* pointer to lowest device */
+
+	/*
+	 * lock for the device, for everything that doesn't have
+	 * a dedicated spinlock
+	 */
+	spinlock_t device_lock;
+
+	bool recvd_hw_ready;
+	struct hbm_version version;
+	int transfer_path; /* Choice of transfer path: IPC or DMA */
+
+	/* ishtp device states */
+	enum ishtp_dev_state dev_state;
+	enum ishtp_hbm_state hbm_state;
+
+	/* driver read queue */
+	struct ishtp_cl_rb read_list;
+	spinlock_t read_list_spinlock;
+
+	/* list of ishtp_cl's */
+	struct list_head cl_list;
+	spinlock_t cl_list_lock;
+	long open_handle_count;
+
+	/* List of bus devices */
+	struct list_head device_list;
+	spinlock_t device_list_lock;
+
+	/* waiting queues for receive message from FW */
+	wait_queue_head_t wait_hw_ready;
+	wait_queue_head_t wait_hbm_recvd_msg;
+
+	/* FIFO for input messages for BH processing */
+	unsigned char rd_msg_fifo[RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE];
+	unsigned rd_msg_fifo_head, rd_msg_fifo_tail;
+	spinlock_t rd_msg_spinlock;
+	struct work_struct bh_hbm_work;
+
+	/* IPC write queue */
+	struct wr_msg_ctl_info wr_processing_list_head, wr_free_list_head;
+	spinlock_t wr_processing_spinlock;	/* For both processing list
+							and free list */
+	spinlock_t out_ipc_spinlock;
+
+	struct ishtp_fw_client *fw_clients; /*Note: memory has to be allocated*/
+	DECLARE_BITMAP(fw_clients_map, ISHTP_CLIENTS_MAX);
+	DECLARE_BITMAP(host_clients_map, ISHTP_CLIENTS_MAX);
+	uint8_t fw_clients_num;
+	uint8_t fw_client_presentation_num;
+	uint8_t fw_client_index;
+	spinlock_t fw_clients_lock;
+
+#if ISH_LOG
+	/* buffer to save prints from driver */
+	unsigned char log_buffer[PRINT_BUFFER_SIZE];
+	size_t log_head;
+	size_t log_tail;
+	spinlock_t log_spinlock;	/* spinlock to protect prints buffer */
+#endif /* ISH_LOG */
+	/* the print_log function will be defined anyway.
+	 * if the log is disabled, it will point to empty function */
+	void (*print_log)(struct ishtp_device *dev, char *format, ...);
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+	struct dentry *dbgfs_dir;
+#endif /* CONFIG_DEBUG_FS */
+
+	/* Debug stats */
+	unsigned	ipc_rx_cnt;
+	unsigned long long	ipc_rx_bytes_cnt;
+	unsigned	ipc_tx_cnt;
+	unsigned long long	ipc_tx_bytes_cnt;
+
+	const struct ishtp_hw_ops *ops;
+	size_t	mtu;
+	uint32_t	ishtp_msg_hdr;
+	char hw[0] __aligned(sizeof(void *));
+};
+
+void	ishtp_device_init(struct ishtp_device *dev);
+int	ishtp_start(struct ishtp_device *dev);
+void	ishtp_device_disable(struct ishtp_device *dev);
+void	ishtp_bus_remove_all_clients(struct ishtp_device *ishtp_dev);
+int	ishtp_register(struct ishtp_device *dev);
+void	ishtp_deregister(struct ishtp_device *dev);
+
+static inline unsigned long ishtp_secs_to_jiffies(unsigned long sec)
+{
+	return sec * HZ;	/*msecs_to_jiffies(sec * MSEC_PER_SEC);*/
+}
+
+/*
+ * Register Access Function
+ */
+static inline int ish_ipc_reset(struct ishtp_device *dev)
+{
+	return dev->ops->ipc_reset(dev);
+}
+
+static inline int ish_hw_reset(struct ishtp_device *dev)
+{
+	return dev->ops->hw_reset(dev);
+}
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+int ishtp_dbgfs_register(struct ishtp_device *dev, const char *name);
+void ishtp_dbgfs_deregister(struct ishtp_device *dev);
+#else
+static inline int ishtp_dbgfs_register(struct ishtp_device *dev,
+	const char *name)
+{
+	return 0;
+}
+static inline void ishtp_dbgfs_deregister(struct ishtp_device *dev) {}
+#endif /* CONFIG_DEBUG_FS */
+
+#endif /*_ISHTP_DEV_H_*/
+
diff --git a/drivers/misc/intel-ish/pci-ish.c b/drivers/misc/intel-ish/pci-ish.c
index 6e149e4..9f18b50 100644
--- a/drivers/misc/intel-ish/pci-ish.c
+++ b/drivers/misc/intel-ish/pci-ish.c
@@ -1,7 +1,7 @@
 /*
- * PCI glue for HECI provider device (ISS) driver
+ * PCI glue for ISHTP provider device (ISH) driver
  *
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,7 +9,7 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
@@ -20,97 +20,49 @@
 #include <linux/fs.h>
 #include <linux/errno.h>
 #include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/aio.h>
 #include <linux/pci.h>
-#include <linux/poll.h>
-#include <linux/init.h>
-#include <linux/ioctl.h>
-#include <linux/cdev.h>
-#include <linux/version.h>
 #include <linux/sched.h>
-#include <linux/uuid.h>
-#include <linux/compat.h>
-#include <linux/jiffies.h>
 #include <linux/interrupt.h>
 #include <linux/workqueue.h>
-#include "client.h"
-#include "heci_dev.h"
-#include "hw-ish.h"
-#include "hbm.h"
-#include "utils.h"
 #include <linux/miscdevice.h>
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-
-/*#define dev_dbg dev_err*/
+#include "ishtp_dev.h"
+#include "hw-ish.h"
 
 /*
- *  heci driver strings
+ * ishtp driver strings
  */
 static bool nomsi;
 module_param_named(nomsi, nomsi, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(nomsi, "don't use msi (default = false)");
 
-/* Currently this driver works as long as there is only a single HECI device. */
-static struct pci_dev *heci_pci_device;
+/* Currently this driver works as long as there is only a single ISHTP device */
+struct pci_dev *ishtp_pci_device;
 
 static const struct pci_device_id ish_pci_tbl[] = {
 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x22D8)},
 	{0, }
 };
-
 MODULE_DEVICE_TABLE(pci, ish_pci_tbl);
 
-static DEFINE_MUTEX(heci_mutex);
+static DEFINE_MUTEX(ishtp_mutex);
+struct init_work_t {
+	struct work_struct init_work;
+	struct ishtp_device *dev;
+};
+struct init_work_t *pci_init_work;
 struct workqueue_struct *workqueue_for_init;
 
-/*global variables for suspend*/
+/* global variables for suspend */
 int	suspend_flag = 0;
 wait_queue_head_t	suspend_wait;
 
-#ifdef TIMER_POLLING
+#if ISH_DEBUGGER
 /*
- * DD -- ISS timer-polling workaround for H-FPGA
- * (and other platforms that fail to deliver interrupts)
- * NOTE: currently this will break (crash) if driver is unloaded
+ * view or modify registers content from user space
  */
-
-#include <linux/timer.h>
-
-struct timer_list	ish_poll_timer;
-void	*timer_data;
-struct work_struct	ish_poll_work;
-
-void	ish_poll_work_fn(void *prm)
-{
-}
-
-void	ish_poll_timer_fn(unsigned long unused)
-{
-	irqreturn_t	rv;
-
-	rv = ish_irq_handler(0, timer_data);
-	/*ISH_DBG_PRINT(KERN_ALERT "%s(): ish_irq_handler() returned %08X\n",
-		__func__, rv);*/
-
-	/* Reschedule timer */
-	ish_poll_timer.expires += 2;
-	add_timer(&ish_poll_timer);
-}
-
-#endif	/* TIMER_POLLING */
-
-
-#if ISH_DEBUGGER
-
 struct ish_hw *hw_dbg;
+static char	dbg_resp_buf[2048];
+static int	resp_buf_read;
 
 static int ishdbg_open(struct inode *inode, struct file *file)
 {
@@ -122,9 +74,6 @@ static int ishdbg_release(struct inode *inode, struct file *file)
 	return	0;
 }
 
-static char	dbg_resp_buf[2048];
-static int	resp_buf_read;
-
 static ssize_t ishdbg_read(struct file *file, char __user *ubuf, size_t length,
 	loff_t *offset)
 {
@@ -137,18 +86,18 @@ static ssize_t ishdbg_read(struct file *file, char __user *ubuf, size_t length,
 		strlen(dbg_resp_buf) : length;
 	rv = copy_to_user(ubuf, dbg_resp_buf, copy_len);
 	if (rv)
-		return  -EINVAL;
+		return -EINVAL;
 	resp_buf_read = 1;
-	return  copy_len;
+	return copy_len;
 }
 
 static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
 	size_t length, loff_t *offset)
 {
-	char    dbg_req_buf[768];
-	char    cmd[768];
-	int     rv;
-	unsigned     addr, count;
+	char	dbg_req_buf[400];
+	char	cmd[400];
+	int	rv;
+	unsigned	addr, count;
 	int	sscanf_match, i, cur_index;
 	uint32_t __iomem *reg_data;
 
@@ -156,23 +105,33 @@ static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
 		length = sizeof(dbg_req_buf);
 	rv = copy_from_user(dbg_req_buf, ubuf, length);
 	if (rv)
-		return  -EINVAL;
+		return -EINVAL;
 	if (sscanf(dbg_req_buf, "%s ", cmd) != 1) {
-		dev_err(&heci_pci_device->dev, "[ish-dbg]) sscanf failed\n");
-		return  -EINVAL;
+		dev_err(&ishtp_pci_device->dev,
+			"[ish-dbg] getting request failed\n");
+		return -EINVAL;
 	}
 	sscanf_match = sscanf(dbg_req_buf + 2, "%x %u", &addr, &count);
+
+	if (addr >= IPC_REG_MAX) {
+		dev_err(&ishtp_pci_device->dev,
+			"[ish-dbg] address %08X out of range\n", addr);
+		return	-EINVAL;
+	}
+
 	if (!strcmp(cmd, "d")) {
 		/* Dump values: d <addr> [count] */
 		if (sscanf_match == 1)
 			count = 1;
 		else if (sscanf_match != 2) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanf_match = %d\n",
+			dev_err(&ishtp_pci_device->dev,
+				"[ish-dbg] bad parameters number (%d)\n",
 				sscanf_match);
-			return  -EINVAL;
+			return -EINVAL;
 		}
 		if (addr % 4) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
+			dev_err(&ishtp_pci_device->dev,
+				"[ish-dbg] address isn't aligned to 4 bytes\n");
 			return -EINVAL;
 		}
 		cur_index = 0;
@@ -189,12 +148,14 @@ static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
 	} else if (!strcmp(cmd, "e")) {
 		/* Enter values e <addr> <value> */
 		if (sscanf_match != 2) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanfMatch = %d\n",
+			dev_err(&ishtp_pci_device->dev,
+				"[ish-dbg] bad parameters number (%d)\n",
 				sscanf_match);
-			return  -EINVAL;
+			return -EINVAL;
 		}
 		if (addr % 4) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
+			dev_err(&ishtp_pci_device->dev,
+				"[ish-dbg] address isn't aligned to 4 bytes\n");
 			return -EINVAL;
 		}
 		reg_data = (uint32_t __iomem *)((char *)hw_dbg->mem_addr
@@ -203,8 +164,7 @@ static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
 		scnprintf(dbg_resp_buf, sizeof(dbg_resp_buf), "OK\n");
 		resp_buf_read = 0;
 	}
-
-	return  length;
+	return length;
 }
 
 static long ishdbg_ioctl(struct file *file, unsigned int cmd,
@@ -214,7 +174,7 @@ static long ishdbg_ioctl(struct file *file, unsigned int cmd,
 }
 
 /*
- * file operations structure will be used for heci char device.
+ * file operations structure will be used for ishtp char device.
  */
 static const struct file_operations ishdbg_fops = {
 	.owner = THIS_MODULE,
@@ -229,7 +189,7 @@ static const struct file_operations ishdbg_fops = {
 /*
  * Misc Device Struct
  */
-static struct miscdevice  ishdbg_misc_device = {
+static struct miscdevice ishdbg_misc_device = {
 		.name = "ishdbg",
 		.fops = &ishdbg_fops,
 		.minor = MISC_DYNAMIC_MINOR,
@@ -238,8 +198,10 @@ static struct miscdevice  ishdbg_misc_device = {
 #endif /* ISH_DEBUGGER */
 
 #if ISH_LOG
-
-void delete_from_log(struct heci_device *dev, size_t min_chars)
+/*
+ * ish internal log, without impact on performance
+ */
+void delete_from_log(struct ishtp_device *dev, size_t min_chars)
 {
 	int i;
 	/* set log_tail to point at the last char to be deleted */
@@ -250,18 +212,16 @@ void delete_from_log(struct heci_device *dev, size_t min_chars)
 	dev->log_tail = (i+1) % PRINT_BUFFER_SIZE;
 }
 
-static void ish_print_log(struct heci_device *dev, char *format, ...)
+static void ish_print_log(struct ishtp_device *dev, char *format, ...)
 {
-	char tmp_buf[1024];
+	char tmp_buf[900];
 	va_list args;
 	int length, i, full_space, free_space;
 	unsigned long	flags;
 	struct timeval tv;
-	struct timeval tv1, tv2, tv_diff;
 
-	do_gettimeofday(&tv1);
 	/* Fix for power-off path */
-	if (!heci_pci_device)
+	if (!ishtp_pci_device)
 		return;
 
 	do_gettimeofday(&tv);
@@ -288,8 +248,7 @@ static void ish_print_log(struct heci_device *dev, char *format, ...)
 
 	if (free_space <= length)
 		/*
-		 * not enougth space.
-		 * needed at least 1 empty char to recognize
+		 * not enougth space. needed at least 1 empty char to recognize
 		 * whether buffer is full or empty
 		 */
 		delete_from_log(dev, (length - free_space) + 1);
@@ -306,34 +265,20 @@ static void ish_print_log(struct heci_device *dev, char *format, ...)
 	dev->log_head = (dev->log_head + length) % PRINT_BUFFER_SIZE;
 
 	spin_unlock_irqrestore(&dev->log_spinlock, flags);
-
-	do_gettimeofday(&tv2);
-	tv_diff.tv_sec = tv2.tv_sec - tv1.tv_sec;
-	tv_diff.tv_usec = tv2.tv_usec - tv1.tv_usec;
-	if (tv1.tv_usec > tv2.tv_usec) {
-		tv_diff.tv_usec += 1000000UL;
-		--tv_diff.tv_sec;
-	}
-	if (tv_diff.tv_sec > dev->max_log_sec ||
-			tv_diff.tv_sec == dev->max_log_sec &&
-			tv_diff.tv_usec > dev->max_log_usec) {
-		dev->max_log_sec = tv_diff.tv_sec;
-		dev->max_log_usec = tv_diff.tv_usec;
-	}
 }
 
-
+/* print to log without need to send ishtp_dev */
 void	g_ish_print_log(char *fmt, ...)
 {
-	char tmp_buf[1024];
+	char tmp_buf[900];
 	va_list args;
-	struct heci_device	*dev;
+	struct ishtp_device	*dev;
 
 	/* Fix for power-off path */
-	if (!heci_pci_device)
+	if (!ishtp_pci_device)
 		return;
 
-	dev = pci_get_drvdata(heci_pci_device);
+	dev = pci_get_drvdata(ishtp_pci_device);
 	va_start(args, fmt);
 	vsnprintf(tmp_buf, sizeof(tmp_buf), fmt, args);
 	va_end(args);
@@ -341,8 +286,7 @@ void	g_ish_print_log(char *fmt, ...)
 }
 EXPORT_SYMBOL(g_ish_print_log);
 
-
-static ssize_t ish_read_log(struct heci_device *dev, char *buf, size_t size)
+static ssize_t ish_read_log(struct ishtp_device *dev, char *buf, size_t size)
 {
 	int i, full_space, ret_val;
 
@@ -359,12 +303,16 @@ static ssize_t ish_read_log(struct heci_device *dev, char *buf, size_t size)
 		/* log has less than 'size' bytes, i = dev->log_head */
 	else
 		i = (dev->log_tail + size) % PRINT_BUFFER_SIZE;
+
 	/* i is the last character to be readen */
 	i = (i-1) % PRINT_BUFFER_SIZE;
 
 	/* read from tail to last '\n' before i */
-	for (; dev->log_buffer[i] != '\n'; i = (i-1) % PRINT_BUFFER_SIZE)
+	for (; dev->log_buffer[i] != '\n' && i != dev->log_tail;
+			i = (i-1) % PRINT_BUFFER_SIZE)
 		;
+	if (i == dev->log_tail) /* buffer is not big enough, no '\n' found */
+		return 0;
 
 	if (dev->log_tail < i) {
 		memcpy(buf, dev->log_buffer + dev->log_tail,
@@ -380,7 +328,7 @@ static ssize_t ish_read_log(struct heci_device *dev, char *buf, size_t size)
 	return ret_val;
 }
 
-static ssize_t ish_read_flush_log(struct heci_device *dev, char *buf,
+static ssize_t ish_read_flush_log(struct ishtp_device *dev, char *buf,
 	size_t size)
 {
 	int ret;
@@ -394,18 +342,16 @@ static ssize_t ish_read_flush_log(struct heci_device *dev, char *buf,
 ssize_t show_read(struct device *dev, struct device_attribute *dev_attr,
 	char *buf)
 {
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	ssize_t retval;
+	struct ishtp_device *ishtp_dev;
+	ssize_t ret;
 	unsigned long	flags;
 
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-	spin_lock_irqsave(&heci_dev->log_spinlock, flags);
-	retval = ish_read_log(heci_dev, buf, PAGE_SIZE);
-	spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
+	ishtp_dev = dev_get_drvdata(dev);
+	spin_lock_irqsave(&ishtp_dev->log_spinlock, flags);
+	ret = ish_read_log(ishtp_dev, buf, PAGE_SIZE);
+	spin_unlock_irqrestore(&ishtp_dev->log_spinlock, flags);
 
-	return retval;
+	return ret;
 }
 
 ssize_t store_read(struct device *dev, struct device_attribute *dev_attr,
@@ -426,34 +372,31 @@ static struct device_attribute read_attr = {
 ssize_t show_flush(struct device *dev, struct device_attribute *dev_attr,
 	char *buf)
 {
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
+	struct ishtp_device *ishtp_dev;
 	unsigned long	flags;
-	ssize_t retval;
+	ssize_t ret;
 
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-	spin_lock_irqsave(&heci_dev->log_spinlock, flags);
-	retval = ish_read_flush_log(heci_dev, buf, PAGE_SIZE);
-	spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
+	ishtp_dev = dev_get_drvdata(dev);
+	spin_lock_irqsave(&ishtp_dev->log_spinlock, flags);
+	ret = ish_read_flush_log(ishtp_dev, buf, PAGE_SIZE);
+	spin_unlock_irqrestore(&ishtp_dev->log_spinlock, flags);
 
-	return retval;
+	return ret;
 }
 
 ssize_t store_flush(struct device *dev, struct device_attribute *dev_attr,
 	const char *buf, size_t count)
 {
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	unsigned long   flags;
+	struct ishtp_device *ishtp_dev;
+	unsigned long	flags;
 
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
+	ishtp_dev = dev_get_drvdata(dev);
 
+	/* empty the log */
 	if (!strncmp(buf, "empty", 5)) {
-		spin_lock_irqsave(&heci_dev->log_spinlock, flags);
-		heci_dev->log_tail = heci_dev->log_head;
-		spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
+		spin_lock_irqsave(&ishtp_dev->log_spinlock, flags);
+		ishtp_dev->log_tail = ishtp_dev->log_head;
+		spin_unlock_irqrestore(&ishtp_dev->log_spinlock, flags);
 	}
 	return count;
 }
@@ -468,7 +411,7 @@ static struct device_attribute flush_attr = {
 };
 #else
 
-static void ish_print_log_nolog(struct heci_device *dev, char *format, ...)
+static void ish_print_log_nolog(struct ishtp_device *dev, char *format, ...)
 {
 }
 
@@ -479,257 +422,82 @@ EXPORT_SYMBOL(g_ish_print_log);
 
 #endif /* ISH_LOG */
 
-ssize_t show_heci_dev_props(struct device *dev,
+ssize_t show_ishtp_dev_props(struct device *dev,
 	struct device_attribute *dev_attr, char *buf)
 {
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
+	struct ishtp_device *ishtp_dev;
 	ssize_t	ret = -ENOENT;
 	unsigned	count;
-	unsigned long   flags, flags2, tx_flags, tx_free_flags;
+	unsigned long	flags;
 
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
+	ishtp_dev = dev_get_drvdata(dev);
 
-	if (!strcmp(dev_attr->attr.name, "heci_dev_state")) {
+	if (!strcmp(dev_attr->attr.name, "ishtp_dev_state")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)heci_dev->dev_state);
+			(unsigned)ishtp_dev->dev_state);
 		ret = strlen(buf);
 	} else if (!strcmp(dev_attr->attr.name, "hbm_state")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)heci_dev->hbm_state);
+			(unsigned)ishtp_dev->hbm_state);
 		ret = strlen(buf);
 	} else if (!strcmp(dev_attr->attr.name, "fw_status")) {
 		scnprintf(buf, PAGE_SIZE, "%08X\n",
-			heci_dev->ops->get_fw_status(heci_dev));
+			ishtp_dev->ops->get_fw_status(ishtp_dev));
 		ret = strlen(buf);
 	} else if (!strcmp(dev_attr->attr.name, "ipc_buf")) {
 		struct wr_msg_ctl_info *ipc_link, *ipc_link_next;
 
 		count = 0;
-		spin_lock_irqsave(&heci_dev->wr_processing_spinlock, flags);
+		spin_lock_irqsave(&ishtp_dev->wr_processing_spinlock, flags);
 		list_for_each_entry_safe(ipc_link, ipc_link_next,
-			&heci_dev->wr_processing_list_head.link, link)
+			&ishtp_dev->wr_processing_list_head.link, link)
 			++count;
-		spin_unlock_irqrestore(&heci_dev->wr_processing_spinlock,
+		spin_unlock_irqrestore(&ishtp_dev->wr_processing_spinlock,
 			flags);
 		scnprintf(buf, PAGE_SIZE, "outstanding %u messages\n", count);
 		ret = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "host_clients")) {
-		struct heci_cl *cl, *next;
-		static const char * const cl_states[] = {"initializing",
-			"connecting", "connected", "disconnecting",
-			"disconnected"};
-		struct heci_cl_rb	*rb, *next_rb;
-		struct heci_cl_tx_ring	*tx_rb, *next_tx_rb;
-
-		scnprintf(buf, PAGE_SIZE, "Host clients:\n"
-				"------------\n");
-		spin_lock_irqsave(&heci_dev->device_lock, flags);
-		list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
-			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-				"id: %d\n",
-				cl->host_client_id);
-			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-				"state: %s\n", cl->state < 0 || cl->state >
-					HECI_CL_DISCONNECTED ?
-					"unknown" : cl_states[cl->state]);
-			if (cl->state == HECI_CL_CONNECTED) {
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"FW client id: %d\n", cl->me_client_id);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"RX ring size: %u\n", cl->rx_ring_size);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"TX ring size: %u\n", cl->tx_ring_size);
-
-				count = 0;
-				spin_lock_irqsave(&cl->in_process_spinlock,
-					flags2);
-				list_for_each_entry_safe(rb, next_rb,
-						&cl->in_process_list.list, list)
-					++count;
-				spin_unlock_irqrestore(&cl->in_process_spinlock,
-					flags2);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"RX in work: %u\n", count);
-
-				count = 0;
-				spin_lock_irqsave(&cl->in_process_spinlock,
-					flags2);
-				list_for_each_entry_safe(rb, next_rb,
-						&cl->free_rb_list.list, list)
-					++count;
-				spin_unlock_irqrestore(&cl->in_process_spinlock,
-					flags2);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"RX free: %u\n", count);
-
-				count = 0;
-				spin_lock_irqsave(&cl->tx_list_spinlock,
-					tx_flags);
-				list_for_each_entry_safe(tx_rb, next_tx_rb,
-						&cl->tx_list.list, list)
-					++count;
-				spin_unlock_irqrestore(&cl->tx_list_spinlock,
-					tx_flags);
-
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"TX pending: %u\n", count);
-				count = 0;
-				spin_lock_irqsave(
-					&cl->tx_free_list_spinlock,
-					tx_free_flags);
-				list_for_each_entry_safe(tx_rb, next_tx_rb,
-						&cl->tx_free_list.list, list)
-					++count;
-				spin_unlock_irqrestore(
-					&cl->tx_free_list_spinlock,
-					tx_free_flags);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"TX free: %u\n", count);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"FC: %u\n",
-					(unsigned)cl->heci_flow_ctrl_creds);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					 "out FC: %u\n",
-					(unsigned)cl->out_flow_ctrl_creds);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Err snd msg: %u\n",
-					(unsigned)cl->err_send_msg);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Err snd FC: %u\n",
-					(unsigned)cl->err_send_fc);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Tx count: %u\n",
-					(unsigned)cl->send_msg_cnt);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Rx IPC count: %u\n",
-					(unsigned)cl->recv_msg_cnt_ipc);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Rx DMA count: %u\n",
-					(unsigned)cl->recv_msg_cnt_dma);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"FC count: %u\n",
-					(unsigned)cl->heci_flow_ctrl_cnt);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"out FC cnt: %u\n",
-					(unsigned)cl->out_flow_ctrl_cnt);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Max FC delay: %lu.%06lu\n",
-					cl->max_fc_delay_sec,
-					cl->max_fc_delay_usec);
-			}
-		}
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID out FC: %u\n",
-			(unsigned)heci_dev->ipc_hid_out_fc);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID out FC count: %u\n",
-			(unsigned)heci_dev->ipc_hid_out_fc_cnt);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID in msg: %u\n",
-			(unsigned)heci_dev->ipc_hid_in_msg);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID in FC: %u\n",
-			(unsigned)heci_dev->ipc_hid_in_fc);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID in FC count: %u\n",
-			(unsigned)heci_dev->ipc_hid_in_fc_cnt);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID out msg: %u\n",
-			(unsigned)heci_dev->ipc_hid_out_msg);
-		spin_unlock_irqrestore(&heci_dev->device_lock, flags);
-		ret = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "stats")) {
-		scnprintf(buf, PAGE_SIZE, "Max. log time: %lu.%06lu\n",
-			heci_dev->max_log_sec, heci_dev->max_log_usec);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC Rx frames: %u; bytes: %llu\n",
-			heci_dev->ipc_rx_cnt, heci_dev->ipc_rx_bytes_cnt);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC Tx frames: %u; bytes: %llu\n",
-			heci_dev->ipc_tx_cnt, heci_dev->ipc_tx_bytes_cnt);
+	} else if (!strcmp(dev_attr->attr.name, "transfer_path")) {
+		/* transfer path is DMA or ipc */
+		scnprintf(buf, PAGE_SIZE, "%u\n", ishtp_dev->transfer_path);
 		ret = strlen(buf);
 	}
 
 	return	ret;
 }
 
-ssize_t store_heci_dev_props(struct device *dev,
+ssize_t store_ishtp_dev_props(struct device *dev,
 	struct device_attribute *dev_attr, const char *buf, size_t count)
 {
 	return	-EINVAL;
 }
 
-/* Debug interface to force flow-control to HID client */
-static unsigned	num_force_hid_fc;
-
-ssize_t show_force_hid_fc(struct device *dev, struct device_attribute *dev_attr,
-	char *buf)
-{
-	scnprintf(buf, PAGE_SIZE, "%u\n", num_force_hid_fc);
-	return	 strlen(buf);
-}
-
-ssize_t store_force_hid_fc(struct device *dev,
+/*
+ * store function for transfer_path attribute.
+ * this is the only attribute the user may set
+ */
+ssize_t store_transfer_path(struct device *dev,
 	struct device_attribute *dev_attr, const char *buf, size_t count)
 {
 	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	struct heci_cl *cl, *next;
-	unsigned long	tx_flags;
+	struct ishtp_device *ishtp_dev;
+	int	rv;
 
 	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-
-	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
-		if (cl->host_client_id == 3 && cl->me_client_id == 5) {
-			dev_warn(dev, "HID FC %u, forced to 1\n",
-				(unsigned)cl->heci_flow_ctrl_creds);
-			cl->heci_flow_ctrl_creds = 1;
-			++num_force_hid_fc;
-			spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
-			if (!list_empty(&cl->tx_list.list)) {
-				/* start sending the first msg
-				 = the callback function */
-				spin_unlock_irqrestore(&cl->tx_list_spinlock,
-					tx_flags);
-				heci_cl_send_msg(heci_dev, cl);
-			} else {
-				spin_unlock_irqrestore(&cl->tx_list_spinlock,
-					tx_flags);
-			}
-			break;
-		}
-	}
+	ishtp_dev = pci_get_drvdata(pdev);
 
-	return	 strlen(buf);
+	rv = sscanf(buf, " %d ", &ishtp_dev->transfer_path);
+	if (!rv)
+		return	-EINVAL;
+	return	strlen(buf);
 }
 
-static struct device_attribute heci_dev_state_attr = {
+static struct device_attribute ishtp_dev_state_attr = {
 	.attr = {
-		.name = "heci_dev_state",
+		.name = "ishtp_dev_state",
 		.mode = (S_IWUSR | S_IRUGO)
 	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
+	.show = show_ishtp_dev_props,
+	.store = store_ishtp_dev_props
 };
 
 static struct device_attribute hbm_state_attr = {
@@ -737,8 +505,8 @@ static struct device_attribute hbm_state_attr = {
 		.name = "hbm_state",
 		.mode = (S_IWUSR | S_IRUGO)
 	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
+	.show = show_ishtp_dev_props,
+	.store = store_ishtp_dev_props
 };
 
 static struct device_attribute fw_status_attr = {
@@ -746,17 +514,8 @@ static struct device_attribute fw_status_attr = {
 		.name = "fw_status",
 		.mode = (S_IWUSR | S_IRUGO)
 	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
-};
-
-static struct device_attribute host_clients_attr = {
-	.attr = {
-		.name = "host_clients",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
+	.show = show_ishtp_dev_props,
+	.store = store_ishtp_dev_props
 };
 
 static struct device_attribute ipc_buf_attr = {
@@ -764,117 +523,89 @@ static struct device_attribute ipc_buf_attr = {
 		.name = "ipc_buf",
 		.mode = (S_IWUSR | S_IRUGO)
 	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
+	.show = show_ishtp_dev_props,
+	.store = store_ishtp_dev_props
 };
 
-static struct device_attribute stats_attr = {
+static struct device_attribute transfer_path = {
 	.attr = {
-		.name = "stats",
+		.name = "transfer_path",
 		.mode = (S_IWUSR | S_IRUGO)
 	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
+	.show = show_ishtp_dev_props,
+	.store = store_transfer_path
 };
 
-static struct device_attribute force_hid_fc_attr = {
-	.attr = {
-		.name = "force_hid_fc",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_force_hid_fc,
-	.store = store_force_hid_fc
-};
 /**********************************/
 
-struct my_work_t {
-	struct work_struct my_work;
-	struct heci_device *dev;
-};
-
-struct my_work_t *work;
-
 static void workqueue_init_function(struct work_struct *work)
 {
-	struct heci_device *dev = ((struct my_work_t *)work)->dev;
+	struct ishtp_device *dev = ((struct init_work_t *)work)->dev;
 	int err;
 
-	ISH_DBG_PRINT(KERN_ALERT
-		"[pci driver] %s() in workqueue func, continue initialization process\n",
-		__func__);
+	dev_set_drvdata(dev->devc, dev);
 
-	pci_set_drvdata(dev->pdev, dev);
-/*	dev_dbg(&dev->pdev->dev, "heci: after pci_set_drvdata\n");*/
-
-	device_create_file(&dev->pdev->dev, &heci_dev_state_attr);
-	device_create_file(&dev->pdev->dev, &hbm_state_attr);
-	device_create_file(&dev->pdev->dev, &fw_status_attr);
-	device_create_file(&dev->pdev->dev, &host_clients_attr);
-	device_create_file(&dev->pdev->dev, &ipc_buf_attr);
-	device_create_file(&dev->pdev->dev, &stats_attr);
-	device_create_file(&dev->pdev->dev, &force_hid_fc_attr);
+	device_create_file(dev->devc, &ishtp_dev_state_attr);
+	device_create_file(dev->devc, &hbm_state_attr);
+	device_create_file(dev->devc, &fw_status_attr);
+	device_create_file(dev->devc, &ipc_buf_attr);
+	device_create_file(dev->devc, &transfer_path);
 
 #if ISH_LOG
-
-	device_create_file(&dev->pdev->dev, &read_attr);
-	device_create_file(&dev->pdev->dev, &flush_attr);
+	device_create_file(dev->devc, &read_attr);
+	device_create_file(dev->devc, &flush_attr);
 
 	dev->log_head = dev->log_tail = 0;
 	dev->print_log = ish_print_log;
-
 	spin_lock_init(&dev->log_spinlock);
 
-	dev->print_log(dev,
-		"[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
-		__func__);
-	dev->print_log(dev, "[heci-ish] %s() running on %s revision [%02X]\n",
-		__func__,
-		dev->pdev->revision == REVISION_ID_CHT_A0 ||
-		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+	dev->print_log(dev, "[pci-ish]: Build "BUILD_ID "\n");
+	dev->print_log(dev, "[pci-ish]: running on %s revision [%02X]\n",
+		ishtp_pci_device->revision == REVISION_ID_CHT_A0 ||
+		(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
 		REVISION_ID_CHT_Ax_SI ? "CHT Ax" :
-		dev->pdev->revision == REVISION_ID_CHT_B0 ||
-		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+		ishtp_pci_device->revision == REVISION_ID_CHT_B0 ||
+		(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
 		REVISION_ID_CHT_Bx_SI ? "CHT Bx" :
-		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+		(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
 		REVISION_ID_CHT_Kx_SI ? "CHT Kx/Cx" :
-		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+		(ishtp_pci_device->revision & REVISION_ID_SI_MASK) ==
 		REVISION_ID_CHT_Dx_SI ? "CHT Dx" : "Unknown",
-		dev->pdev->revision);
+		ishtp_pci_device->revision);
 #else
 	dev->print_log = ish_print_log_nolog;
-#endif /*ISH_LOG*/
+#endif /* ISH_LOG */
 
 	init_waitqueue_head(&suspend_wait);
 
-	mutex_lock(&heci_mutex);
-	if (heci_start(dev)) {
-		dev_err(&dev->pdev->dev, "heci: Init hw failure.\n");
+	mutex_lock(&ishtp_mutex);
+
+	if (ish_hw_start(dev)) {
+		dev_err(dev->devc, "ISH: Init hw failed.\n");
 		err = -ENODEV;
 		goto out_err;
 	}
-/*	dev_dbg(&dev->pdev->dev, "heci: after heci_start\n");*/
 
-	err = heci_register(dev);
-	if (err)
+	if (ishtp_start(dev)) {
+		dev_err(dev->devc, "ISHTP: Protocol init failed.\n");
+		err = -ENOENT;
 		goto out_err;
-/*	dev_dbg(&dev->pdev->dev, "heci: after heci_register\n");*/
+	}
 
+	err = ishtp_register(dev);
+	if (err)
+		goto out_err;
 
-	mutex_unlock(&heci_mutex);
+	mutex_unlock(&ishtp_mutex);
 
-	ISH_DBG_PRINT(KERN_ALERT
-		"[pci driver] %s() in workqueue func, finished initialization process\n",
-		__func__);
 	kfree((void *)work);
 	return;
 
 out_err:
-	mutex_unlock(&heci_mutex);
+	mutex_unlock(&ishtp_mutex);
 	kfree((void *)work);
 }
 
-/**********************************/
-
 /**
  * ish_probe - Device Initialization Routine
  *
@@ -885,17 +616,14 @@ out_err:
  */
 static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	struct heci_device *dev;
+	struct ishtp_device *dev;
 	struct ish_hw *hw;
-	int err;
+	int	err;
 	int	rv;
 
-	ISH_INFO_PRINT(
-	KERN_ERR "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
-		__func__);
-	ISH_INFO_PRINT(KERN_ERR
-		"[heci-ish] %s() running on %s revision [%02X]\n", __func__,
-		pdev->revision == REVISION_ID_CHT_A0 ||
+	dev_alert(&pdev->dev, "[ish]: Build "BUILD_ID "\n");
+	dev_alert(&pdev->dev, "[ish]: running on %s revision [%02X]\n",
+		 pdev->revision == REVISION_ID_CHT_A0 ||
 		(pdev->revision & REVISION_ID_SI_MASK) ==
 			REVISION_ID_CHT_Ax_SI ? "CHT A0" :
 		pdev->revision == REVISION_ID_CHT_B0 ||
@@ -906,36 +634,28 @@ static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		(pdev->revision & REVISION_ID_SI_MASK) ==
 			REVISION_ID_CHT_Dx_SI ? "CHT Dx" : "Unknown",
 		pdev->revision);
-#if defined(SUPPORT_Ax_ONLY)
-	pdev->revision = REVISION_ID_CHT_A0;
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to A0\n",
-		__func__);
-#elif defined(SUPPORT_Bx_ONLY)
-	pdev->revision = REVISION_ID_CHT_B0;
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to B0\n",
-		__func__);
-#endif
-	mutex_lock(&heci_mutex);
-	if (heci_pci_device) {
+
+	mutex_lock(&ishtp_mutex);
+	if (ishtp_pci_device) {
 		err = -EEXIST;
 		goto end;
 	}
 	/* enable pci dev */
 	err = pci_enable_device(pdev);
 	if (err) {
-		dev_err(&pdev->dev, "heci: Failed to enable pci device.\n");
+		dev_err(&pdev->dev, "ISH: Failed to enable PCI device\n");
 		goto end;
 	}
-	/* set PCI host mastering  */
+	/* set PCI host mastering */
 	pci_set_master(pdev);
-	/* pci request regions for heci driver */
+	/* pci request regions for ISH driver */
 	err = pci_request_regions(pdev, KBUILD_MODNAME);
 	if (err) {
-		dev_err(&pdev->dev, "heci: Failed to get pci regions.\n");
+		dev_err(&pdev->dev, "ISH: Failed to get PCI regions\n");
 		goto disable_device;
 	}
 
-	/* allocates and initializes the heci dev structure */
+	/* allocates and initializes the ISH dev structure */
 	dev = ish_dev_init(pdev);
 	if (!dev) {
 		err = -ENOMEM;
@@ -943,94 +663,59 @@ static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 	hw = to_ish_hw(dev);
 
-	/* mapping  IO device memory */
+	/* mapping IO device memory */
 	hw->mem_addr = pci_iomap(pdev, 0, 0);
 	if (!hw->mem_addr) {
-		dev_err(&pdev->dev, "mapping I/O device memory failure.\n");
+		dev_err(&pdev->dev, "ISH: mapping I/O range failure\n");
 		err = -ENOMEM;
 		goto free_device;
 	}
 
-#if ISH_DEBUGGER
-	ishdbg_misc_device.parent = &pdev->dev;
-	rv = misc_register(&ishdbg_misc_device);
-	if (rv)
-		dev_err(&pdev->dev,
-			"error starting ISS debugger (misc_register): %d\n",
-			rv);
-	hw_dbg = hw;
-#endif /*ISH_DEBUGGER*/
+	ishtp_pci_device = pdev;
+	/* PCI quirk: prevent from being put into D3 state */
+	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
 
-	heci_pci_device = pdev;
 
-	/* request and enable interrupt   */
-#ifndef TIMER_POLLING
+	/* request and enable interrupt */
 	err = request_irq(pdev->irq, ish_irq_handler, IRQF_NO_SUSPEND,
 		KBUILD_MODNAME, dev);
 	if (err) {
-		dev_err(&pdev->dev, "heci: request_irq failure. irq = %d\n",
+		dev_err(&pdev->dev, "ISH: request IRQ failure (%d)\n",
 			pdev->irq);
 		goto free_device;
 	}
-	dev_alert(&pdev->dev, "[heci-ish]: uses IRQ %d\n", pdev->irq);
-
-	/* Diagnostic output */
-	do {
-		uint32_t	msg_addr;
-		uint32_t	msg_data;
-
-		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_LO,
-			&msg_addr);
-		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_DATA_32,
-			&msg_data);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[heci-ish] %s(): assigned IRQ = %d, [PCI_MSI_ADDRESS_LO] = %08X [PCI_MSI_DATA_32] = %08X\n",
-			__func__, pdev->irq, msg_addr, msg_data);
-	} while (0);
-	/*********************/
-#else
-	/* Init & prepare workqueue */
-	INIT_WORK(&ish_poll_work, ish_poll_work_fn);
-
-	/* Create and schedule ISS polling timer */
-	init_timer(&ish_poll_timer);
-	ish_poll_timer.data = 0;
-	ish_poll_timer.function = ish_poll_timer_fn;
-	ish_poll_timer.expires = jiffies + 2;
-	timer_data = dev;
-	add_timer(&ish_poll_timer);
-
-	/* Init ISS polling timers workqueue */
-#endif
-
-	/* PCI quirk: prevent from being put into D3 state */
-	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
 
+#if ISH_DEBUGGER
+	ishdbg_misc_device.parent = &pdev->dev;
+	rv = misc_register(&ishdbg_misc_device);
+	if (rv)
+		dev_err(&pdev->dev,
+			"error starting ISH debugger: %d\n", rv);
+	hw_dbg = hw;
+#endif /* ISH_DEBUGGER */
 
 	/*
-	 * 7/7/2014: in order to not stick Android boot,
+	 * in order to not stick Android boot,
 	 * from here & below needs to run in work queue
 	 * and here we should return success
 	 */
-	/****************************************************************/
-	work = kmalloc(sizeof(struct my_work_t), GFP_KERNEL);
-	if (!work)
-		return -ENOMEM;
-	work->dev = dev;
+	pci_init_work = kmalloc(sizeof(struct init_work_t), GFP_KERNEL);
+	if (!pci_init_work) {
+		err = -ENOMEM;
+		goto free_device;
+	}
+	pci_init_work->dev = dev;
 	workqueue_for_init = create_workqueue("workqueue_for_init");
 	if (!workqueue_for_init) {
-		kfree(work);
-		return -ENOMEM;
+		kfree(pci_init_work);
+		err = -ENOMEM;
+		goto free_device;
 	}
-	INIT_WORK(&work->my_work, workqueue_init_function);
-	queue_work(workqueue_for_init, &work->my_work);
+	INIT_WORK(&pci_init_work->init_work, workqueue_init_function);
+	queue_work(workqueue_for_init, &pci_init_work->init_work);
 
-	ISH_DBG_PRINT("[pci driver] %s() enqueue init_work function\n",
-		__func__);
-
-	mutex_unlock(&heci_mutex);
+	mutex_unlock(&ishtp_mutex);
 	return 0;
-	/****************************************************************/
 
 free_device:
 	pci_iounmap(pdev, hw->mem_addr);
@@ -1040,58 +725,58 @@ release_regions:
 disable_device:
 	pci_disable_device(pdev);
 end:
-	mutex_unlock(&heci_mutex);
-	dev_err(&pdev->dev, "heci: Driver initialization failed.\n");
+	mutex_unlock(&ishtp_mutex);
+	dev_err(&pdev->dev, "ISH: PCI driver initialization failed.\n");
 	return err;
 }
 
 /**
- * heci_remove - Device Removal Routine
+ * ishtp_remove - Device Removal Routine
  *
  * @pdev: PCI device structure
  *
- * heci_remove is called by the PCI subsystem to alert the driver
+ * ishtp_remove is called by the PCI subsystem to alert the driver
  * that it should release a PCI device.
  */
 static void ish_remove(struct pci_dev *pdev)
 {
-	struct heci_device *dev;
+	struct ishtp_device *dev;
 	struct ish_hw *hw;
 
 	/*
 	 * This happens during power-off/reboot and may be at the same time as
 	 * a lot of bi-directional communication happens
 	 */
-	if (heci_pci_device != pdev) {
-		dev_err(&pdev->dev, "heci: heci_pci_device != pdev\n");
+	if (ishtp_pci_device != pdev) {
+		dev_err(&pdev->dev, "ISH: wrong PCI device in remove\n");
 		return;
 	}
 
 	dev = pci_get_drvdata(pdev);
 	if (!dev) {
-		dev_err(&pdev->dev, "heci: dev =NULL\n");
+		dev_err(&pdev->dev, "ISH: dev is NULL\n");
 		return;
 	}
 
 	hw = to_ish_hw(dev);
 
 	/*
-	 * Set HECI device state to disabled.
+	 * Set ISHTP device state to disabled.
 	 * Invalidate all other possible communication in both directions
 	 */
-	heci_device_disable(dev);
+	ishtp_device_disable(dev);
 
 	free_irq(pdev->irq, dev);
 	pci_disable_msi(pdev);
 	pci_iounmap(pdev, hw->mem_addr);
-	heci_pci_device = NULL;
+	ishtp_pci_device = NULL;
 	if (workqueue_for_init) {
 		flush_workqueue(workqueue_for_init);
 		destroy_workqueue(workqueue_for_init);
 		workqueue_for_init = NULL;
 	}
 	pci_set_drvdata(pdev, NULL);
-	heci_deregister(dev);
+	ishtp_deregister(dev);
 	kfree(dev);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
@@ -1100,7 +785,7 @@ static void ish_remove(struct pci_dev *pdev)
 int ish_suspend(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
-	struct heci_device *dev = pci_get_drvdata(pdev);
+	struct ishtp_device *dev = pci_get_drvdata(pdev);
 
 	enable_irq_wake(pdev->irq);
 
@@ -1121,7 +806,7 @@ int ish_suspend(struct device *device)
 int ish_resume(struct device *device)
 {
 	struct pci_dev *pdev = to_pci_dev(device);
-	struct heci_device *dev = pci_get_drvdata(pdev);
+	struct ishtp_device *dev = pci_get_drvdata(pdev);
 
 	disable_irq_wake(pdev->irq);
 	send_resume(dev);
@@ -1133,15 +818,13 @@ static const struct dev_pm_ops ish_pm_ops = {
 	.suspend = ish_suspend,
 	.resume = ish_resume,
 };
-
-#define HECI_ISH_PM_OPS	(&ish_pm_ops)
+#define ISHTP_ISH_PM_OPS	(&ish_pm_ops)
 #else
-#define HECI_ISH_PM_OPS	NULL
+#define ISHTP_ISH_PM_OPS	NULL
 #endif /* CONFIG_PM */
 
-
 /*
- *  PCI driver structure
+ * PCI driver structure
  */
 static struct pci_driver ish_driver = {
 	.name = KBUILD_MODNAME,
@@ -1149,12 +832,12 @@ static struct pci_driver ish_driver = {
 	.probe = ish_probe,
 	.remove = ish_remove,
 	.shutdown = ish_remove,
-	.driver.pm = HECI_ISH_PM_OPS,
+	.driver.pm = ISHTP_ISH_PM_OPS,
 };
 
 module_pci_driver(ish_driver);
 
 MODULE_AUTHOR("Intel Corporation");
 MODULE_DESCRIPTION("Intel(R) Integrated Sensor Hub PCI Device Driver");
-MODULE_LICENSE("GPL v2");
+MODULE_LICENSE("GPL");
 
diff --git a/drivers/misc/intel-ish/platform-config.h b/drivers/misc/intel-ish/platform-config.h
index 49c3261..2f03699 100644
--- a/drivers/misc/intel-ish/platform-config.h
+++ b/drivers/misc/intel-ish/platform-config.h
@@ -1,7 +1,7 @@
 /*
- * ISS platform-specific definitions
+ * ISH platform-specific definitions
  *
- * Copyright (c) 2012-2015, Intel Corporation.
+ * Copyright (c) 2012-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,7 +9,7 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
@@ -17,15 +17,9 @@
 #define PLATFORM_CONFIG__H
 
 /* Build ID string */
-#define BUILD_ID        "236-dx-si-dma-impl-upstream-rc"
+#define BUILD_ID	"260-stdint"
 
-#define	ISH_DEBUG	0
-#if ISH_DEBUG
-#define	ISH_DBG_PRINT	printk
-#else
 #define	ISH_DBG_PRINT	no_printk
-#endif
-
 #define	ISH_INFO	1
 #if ISH_INFO
 #define	ISH_INFO_PRINT	printk
@@ -33,21 +27,6 @@
 #define	ISH_INFO_PRINT	no_printk
 #endif
 
-#define ISH_LOG		0
-
-#if 0
-/*
- * Define if running on VirtualBox -
- * may solve imprecise timer emulation problems
- */
-#define	HOST_VIRTUALBOX	1
-#endif
-
-#if 0
-/* Timer-polling workaround for DUTs with non-functional interrupts reporting */
-#define	TIMER_POLLING	1
-#endif
-
 #define	REVISION_ID_CHT_A0	0x6
 #define	REVISION_ID_CHT_Ax_SI	0x0
 #define	REVISION_ID_CHT_Bx_SI	0x10
@@ -57,69 +36,10 @@
 
 #define	REVISION_ID_SI_MASK	0x70
 
-/* For buggy (pre-)silicon, select model rather than retrieve it */
-#if 0
-/* If defined, will support A0 only, will not check revision ID */
-#define	SUPPORT_Ax_ONLY	1
-
-#else
-
-#if  0
-/* If defined, will support B0 only, will not check revision ID */
-#define	SUPPORT_B0_ONLY	1
-#endif
-#endif
-
-#if defined(SUPPORT_A0_ONLY) && defined(SUPPORT_B0_ONLY)
-#error Only one of SUPPORT_A0_ONLY and SUPPORT_B0_ONLY may be defined
-#endif
-
-/* D3 RCR */
-#define	D3_RCR	1
-
-/* Define in order to force FW-initated reset */
-#define	FORCE_FW_INIT_RESET	1
-
-/* Include ISH register debugger */
+/* Enable ISH register debugger */
 #define	ISH_DEBUGGER	1
-
-/* Debug mutex locking/unlocking */
-#define	DEBUG_LOCK	0
-
-#if DEBUG_LOCK
-
-static void	do_mutex_lock(void *m)
-{
-	mutex_lock(m);
-}
-
-static void	do_mutex_unlock(void *m)
-{
-	mutex_unlock(m);
-}
-
-#ifdef mutex_lock
-#undef mutex_lock
-#endif
-#ifdef mutex_unlock
-#undef mutex_unlock
-#endif
-
-#define mutex_lock(a) \
-	do {\
-		dev_warn(NULL, "%s:%d[%s] -- mutex_lock(%p)\n",	\
-			__FILE__, __LINE__, __func__, a);	\
-		do_mutex_lock(a);	\
-	} while (0)
-
-#define mutex_unlock(a) \
-	do {\
-		dev_warn(NULL, "%s:%d[%s] -- mutex_unlock(%p)\n",	\
-			__FILE__, __LINE__, __func__, a);	\
-		do_mutex_unlock(a);	\
-	} while (0)
-#endif /* DEBUG_LOCK */
-/*************************************/
+/* Enable ISH internal log */
+#define ISH_LOG		0
 
 #endif /* PLATFORM_CONFIG__H*/
 
diff --git a/drivers/misc/intel-ish/senscol-core.c b/drivers/misc/intel-ish/senscol-core.c
index 8d20977..00582bf4 100644
--- a/drivers/misc/intel-ish/senscol-core.c
+++ b/drivers/misc/intel-ish/senscol-core.c
@@ -25,7 +25,7 @@
 #include <linux/poll.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
-#include "heci-hid.h"
+#include "ishtp-hid.h"
 
 struct list_head	senscol_impl_list;
 struct list_head	senscol_sensors_list;
@@ -1066,7 +1066,7 @@ void senscol_flush_cb(void)
 
 
 /*
- * file operations structure will be used for heci char device.
+ * file operations structure will be used for ishtp char device.
  */
 static const struct file_operations senscol_fops = {
 	.owner = THIS_MODULE,
diff --git a/drivers/misc/intel-ish/utils.h b/drivers/misc/intel-ish/utils.h
index 04b814e..cc646de 100644
--- a/drivers/misc/intel-ish/utils.h
+++ b/drivers/misc/intel-ish/utils.h
@@ -1,7 +1,7 @@
 /*
- * Utility macros of ISS
+ * Utility macros of ISH
  *
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,11 +9,11 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 #ifndef UTILS__H
- #define UTILS__H
+#define UTILS__H
 
 #define	WAIT_FOR_SEND_SLICE	(HZ / 10)
 #define	WAIT_FOR_CONNECT_SLICE	(HZ / 10)
@@ -22,20 +22,20 @@
  * Waits for specified event when a thread that triggers event can't signal
  * Also, waits *at_least* `timeinc` after condition is satisfied
  */
-#define	timed_wait_for(timeinc, condition) \
-	do { \
-		int completed = 0; \
-		do { \
-			unsigned long	j; \
-			int	done = 0; \
-\
-			completed = (condition); \
-			for (j = jiffies, done = 0; !done; ) { \
-				schedule_timeout(timeinc); \
+#define	timed_wait_for(timeinc, condition)			\
+	do {							\
+		int completed = 0;				\
+		do {						\
+			unsigned long	j;			\
+			int	done = 0;			\
+								\
+			completed = (condition);		\
+			for (j = jiffies, done = 0; !done; ) {	\
+				schedule_timeout(timeinc);	\
 				if (time_is_before_eq_jiffies(j + timeinc)) \
-					done = 1; \
-			} \
-		} while (!(completed)); \
+					done = 1;		\
+			}					\
+		} while (!(completed));				\
 	} while (0)
 
 
@@ -43,22 +43,22 @@
  * Waits for specified event when a thread that triggers event
  * can't signal with timeout (use whenever we may hang)
  */
-#define	timed_wait_for_timeout(timeinc, condition, timeout) \
-	do { \
-		int	t = timeout; \
-		do { \
-			unsigned long	j; \
-			int	done = 0; \
-\
-			for (j = jiffies, done = 0; !done; ) { \
-				schedule_timeout(timeinc); \
+#define	timed_wait_for_timeout(timeinc, condition, timeout)	\
+	do {							\
+		int	t = timeout;				\
+		do {						\
+			unsigned long	j;			\
+			int	done = 0;			\
+								\
+			for (j = jiffies, done = 0; !done; ) {	\
+				schedule_timeout(timeinc);	\
 				if (time_is_before_eq_jiffies(j + timeinc)) \
-					done = 1; \
+					done = 1;		\
 			} \
-			t -= timeinc; \
-			if (t <= 0) \
-				break; \
-		} while (!(condition)); \
+			t -= timeinc;				\
+			if (t <= 0)				\
+				break;				\
+		} while (!(condition));				\
 	} while (0)
 
 #endif /* UTILS__H */
-- 
1.9.1

