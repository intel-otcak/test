From 2a23114e3df6d26e65dcafc6edff5569e7dc6ad4 Mon Sep 17 00:00:00 2001
From: Andy Ross <andrew.j.ross@intel.com>
Date: Fri, 11 Apr 2014 13:16:12 -0700
Subject: [PATCH 003/117] Fork lift of MCG
 drivers/external_drivers/camera/drivers/media/i2c

Just the sensor drivers in this commit.  The atomisp driver itself is
rebased separately.

From ssh://jfumg-gcrmirror.jf.intel.com/a/bsp/linux/modules/camera
Branch platform/android/main
Current as of commit 42dc892bb51d357aec8527ea97d94ea88cf1d837

    Author: Tommi Franttila <tommi.franttila@intel.com>
    Date:   Wed Apr 9 12:57:29 2014 +0300

    m10mo: FW checksum printing

Signed-off-by: Andy Ross <andrew.j.ross@intel.com>
---
 .../camera/drivers/media/i2c/Kconfig               |  207 +
 .../camera/drivers/media/i2c/Makefile              |   47 +
 .../camera/drivers/media/i2c/ap1302.c              | 1359 ++++++
 .../camera/drivers/media/i2c/ap1302.h              |  198 +
 .../camera/drivers/media/i2c/gc2235.c              | 1282 ++++++
 .../camera/drivers/media/i2c/gc2235.h              |  556 +++
 .../camera/drivers/media/i2c/imx/Kconfig           |    9 +
 .../camera/drivers/media/i2c/imx/Makefile          |    5 +
 .../camera/drivers/media/i2c/imx/ad5816g.c         |  226 +
 .../camera/drivers/media/i2c/imx/ad5816g.h         |   49 +
 .../camera/drivers/media/i2c/imx/common.h          |   65 +
 .../camera/drivers/media/i2c/imx/drv201.c          |  219 +
 .../camera/drivers/media/i2c/imx/drv201.h          |   38 +
 .../camera/drivers/media/i2c/imx/dw9714.c          |  221 +
 .../camera/drivers/media/i2c/imx/dw9714.h          |   62 +
 .../camera/drivers/media/i2c/imx/dw9718.c          |  175 +
 .../camera/drivers/media/i2c/imx/dw9718.h          |   54 +
 .../camera/drivers/media/i2c/imx/dw9719.c          |  209 +
 .../camera/drivers/media/i2c/imx/dw9719.h          |   58 +
 .../camera/drivers/media/i2c/imx/imx.c             | 2348 ++++++++++
 .../camera/drivers/media/i2c/imx/imx.h             |  625 +++
 .../camera/drivers/media/i2c/imx/imx132.h          |  799 ++++
 .../camera/drivers/media/i2c/imx/imx134.h          | 2072 +++++++++
 .../camera/drivers/media/i2c/imx/imx135.h          | 2599 +++++++++++
 .../camera/drivers/media/i2c/imx/imx135vb.h        | 1889 ++++++++
 .../camera/drivers/media/i2c/imx/imx175.h          | 1959 ++++++++
 .../camera/drivers/media/i2c/imx/otp.c             |   40 +
 .../camera/drivers/media/i2c/imx/otp_e2prom.c      |   91 +
 .../camera/drivers/media/i2c/imx/otp_imx.c         |  146 +
 .../camera/drivers/media/i2c/imx/vcm.c             |   45 +
 .../camera/drivers/media/i2c/imx135VB/Kconfig      |   12 +
 .../camera/drivers/media/i2c/imx135VB/Makefile     |    8 +
 .../camera/drivers/media/i2c/imx135VB/dw9719.c     |  182 +
 .../camera/drivers/media/i2c/imx135VB/dw9719.h     |   39 +
 .../camera/drivers/media/i2c/imx135VB/imx.c        | 1702 +++++++
 .../camera/drivers/media/i2c/imx135VB/imx.h        |  289 ++
 .../camera/drivers/media/i2c/imx135VB/imx135.h     | 4784 ++++++++++++++++++++
 .../camera/drivers/media/i2c/libmsrlisthelper.c    |  209 +
 .../camera/drivers/media/i2c/lm3554.c              |  916 ++++
 .../camera/drivers/media/i2c/lm3559.c              | 1023 +++++
 .../camera/drivers/media/i2c/m10mo.c               | 1622 +++++++
 .../camera/drivers/media/i2c/m10mo.h               |  359 ++
 .../camera/drivers/media/i2c/m10mo_fw.c            |  718 +++
 .../camera/drivers/media/i2c/m10mo_spi.c           |  230 +
 .../camera/drivers/media/i2c/m10mo_tables.c        |  154 +
 .../camera/drivers/media/i2c/mt9d113.c             | 2004 ++++++++
 .../camera/drivers/media/i2c/mt9d113.h             | 2146 +++++++++
 .../camera/drivers/media/i2c/mt9e013/Kconfig       |   27 +
 .../camera/drivers/media/i2c/mt9e013/Makefile      |    2 +
 .../camera/drivers/media/i2c/mt9e013/mt9e013.c     | 2226 +++++++++
 .../camera/drivers/media/i2c/mt9e013/mt9e013.h     |  454 ++
 .../drivers/media/i2c/mt9e013/mt9e013_blackbay.h   |  810 ++++
 .../drivers/media/i2c/mt9e013/mt9e013_enzo.h       |  814 ++++
 .../drivers/media/i2c/mt9e013/mt9e013_lexington.h  |  783 ++++
 .../camera/drivers/media/i2c/mt9m114.c             | 1518 +++++++
 .../camera/drivers/media/i2c/mt9m114.h             | 1686 +++++++
 .../camera/drivers/media/i2c/mt9v113.c             | 1761 +++++++
 .../camera/drivers/media/i2c/mt9v113.h             | 1036 +++++
 .../camera/drivers/media/i2c/ov2722.c              | 1449 ++++++
 .../camera/drivers/media/i2c/ov2722.h              | 1058 +++++
 .../camera/drivers/media/i2c/ov5640.c              | 2239 +++++++++
 .../camera/drivers/media/i2c/ov5640.h              | 1904 ++++++++
 .../camera/drivers/media/i2c/ov5693/Kconfig        |   11 +
 .../camera/drivers/media/i2c/ov5693/Makefile       |    5 +
 .../camera/drivers/media/i2c/ov5693/ad5823.c       |  226 +
 .../camera/drivers/media/i2c/ov5693/ad5823.h       |   92 +
 .../camera/drivers/media/i2c/ov5693/ov5693.c       | 1473 ++++++
 .../camera/drivers/media/i2c/ov5693/ov5693.h       |  849 ++++
 .../camera/drivers/media/i2c/ov680.c               | 1199 +++++
 .../camera/drivers/media/i2c/ov680.h               |  253 ++
 .../camera/drivers/media/i2c/ov8830.c              | 1958 ++++++++
 .../camera/drivers/media/i2c/ov8830.h              | 1685 +++++++
 .../camera/drivers/media/i2c/ov8835.h              |  943 ++++
 .../camera/drivers/media/i2c/ov8858.c              | 1901 ++++++++
 .../camera/drivers/media/i2c/ov8858.h              |  837 ++++
 .../camera/drivers/media/i2c/ov9724.c              | 1595 +++++++
 .../camera/drivers/media/i2c/ov9724.h              | 1457 ++++++
 .../camera/drivers/media/i2c/pixter.c              | 1046 +++++
 .../camera/drivers/media/i2c/pixter.h              |  184 +
 .../camera/drivers/media/i2c/s5k6b2yx.c            | 1407 ++++++
 .../camera/drivers/media/i2c/s5k6b2yx.h            |  344 ++
 .../camera/drivers/media/i2c/s5k8aay.c             | 1003 ++++
 .../camera/drivers/media/i2c/s5k8aay_settings.h    |  248 +
 .../camera/drivers/media/i2c/xactor_x.c            |  627 +++
 .../camera/drivers/media/i2c/xactor_x.h            |   62 +
 85 files changed, 71221 insertions(+)
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/Kconfig
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/Makefile
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ap1302.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ap1302.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/Kconfig
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/common.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/imx175.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx/vcm.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Kconfig
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Makefile
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx135.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/libmsrlisthelper.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9d113.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9d113.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9v113.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/mt9v113.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov2722.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov2722.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5640.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5640.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov680.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov680.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov8830.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov8835.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov9724.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov9724.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/pixter.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/pixter.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/xactor_x.h

diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
new file mode 100644
index 0000000..1271fd9
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
@@ -0,0 +1,207 @@
+#
+# Kconfig for sensor drivers
+#
+
+source "drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig"
+source "drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig"
+source "drivers/external_drivers/camera/drivers/media/i2c/imx/Kconfig"
+source "drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Kconfig"
+
+config VIDEO_OV9724
+       tristate "OVT ov9724 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the OVT
+         OV9724 raw camera.
+
+         OVT is a 720P raw sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_OV2722
+       tristate "OVT ov2722 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the OVT
+         OV2722 raw camera.
+
+         OVT is a 2M raw sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_M10MO
+	tristate "Fujitsu M10MO driver"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 isp driver for the Fujitsu.
+
+	  It currently depends on internal V4L2 extensions defined in
+	  atomisp driver.
+
+config VIDEO_M10MO_FAKE_SFI_TABLE
+	bool "Add fake SFI entry for Fujitsu M10MO on VV board + AOB"
+	depends on VIDEO_M10MO
+	---help---
+	  Enable this when working with VV board with Fujitsu AOB.
+
+	  Not needed if device IFWI already has M10MO in the SFI table.
+
+config VIDEO_GC2235
+       tristate "Galaxy gc2235 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the OVT
+         GC2235 raw camera.
+
+         GC2235 is a 2M raw sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_OV8830
+       tristate "Omnivision ov8830 sensor support"
+       depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Omnivision
+         ov8830 8MP RAW sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_OV8858
+       tristate "Omnivision ov8858 sensor support"
+       depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Omnivision
+         ov8858 8MP RAW sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_CSI_XACTOR
+        tristate "csi xactor"
+        depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP
+        ---help---
+          Use this if you need to send data through external csi data generator
+
+          To compile this driver as a module, choose M here.
+
+config VIDEO_MSRLIST_HELPER
+       tristate "Helper library to load, parse and apply large register lists."
+       depends on I2C
+       ---help---
+         This is a helper library to be used from a sensor driver to load, parse
+         and apply large register lists.
+
+         To compile this driver as a module, choose M here: the
+         module will be called libmsrlisthelper.
+
+config VIDEO_S5K8AAY
+       tristate "Samsung S5K8AAY (EVT1) sensor support"
+       depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP && VIDEO_MSRLIST_HELPER
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Samsung
+         S5K8AAY (EVT1) 1/8" 1.2MP SoC sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_S5K6B2YX
+       tristate "Samsung S5K6B2YX (VS) sensor support"
+       depends on I2C && VIDEO_V4L2 && VIDEO_ATOMISP && VIDEO_MSRLIST_HELPER
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Samsung
+         S5K6B2YX (VS) 1/6" 2MP RAW sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_MT9D113
+       tristate "Aptina mt9d113 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Micron
+         mt9d113 2M camera.
+
+         mt9d113 is video camera sensor.
+
+         It currently only works with the atomisp driver.
+config VIDEO_MT9M114
+       tristate "Aptina mt9m114 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Micron
+         mt9m114 1.3 Mpixel camera.
+
+         mt9m114 is video camrea sensor.
+config VIDEO_MT9V113
+       tristate "Aptina mt9v113 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Micron
+         mt9v113 vga camera.
+
+         mt9v113 is video camerea sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_OV5640
+       tristate "Omnivision ov5640 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Micron
+         ov5640 5 Mpixel camera.
+
+         ov5640 is video camrea sensor.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_AP1302
+       tristate "AP1302 external ISP support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the external
+         ISP AP1302.
+
+         AP1302 is an exteral ISP.
+
+         It currently only works with the atomisp driver.
+
+config VIDEO_PIXTER
+       tristate "Pixter 2+ MIPI CSI simulator"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for Pixter2+.
+         Pixter 2+ is a MIPI CSI simulator.
+
+config VIDEO_OV680
+       tristate "OV680 external ISP support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the external
+         ISP OV680.
+
+         OV680 is an external ISP.
+
+         It currently only works with the atomisp driver.
+
+#
+# Kconfig for flash drivers
+#
+
+config VIDEO_LM3554
+       tristate "LM3554 flash light driver"
+       depends on VIDEO_V4L2 && I2C
+       ---help---
+         This is a Video4Linux2 sub-dev driver for the LM3554
+         flash light driver.
+
+         To compile this driver as a module, choose M here: the
+         module will be called lm3554
+
+config VIDEO_LM3559
+       tristate "LM3559 flash light driver"
+       depends on VIDEO_V4L2 && I2C
+       ---help---
+         This is a Video4Linux2 sub-dev driver for the LM3559
+         flash light driver.
+
+         To compile this driver as a module, choose M here: the
+         module will be called lm3559
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
new file mode 100644
index 0000000..275eee8
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
@@ -0,0 +1,47 @@
+#
+# Makefile for sensor drivers
+#
+
+obj-$(CONFIG_VIDEO_IMX)        += imx/
+obj-$(CONFIG_VIDEO_IMXVB)      += imx135VB/
+obj-$(CONFIG_VIDEO_OV5693)     += ov5693/
+
+obj-$(CONFIG_VIDEO_MT9M114)    += mt9m114.o
+obj-$(CONFIG_VIDEO_MT9E013)    += mt9e013/
+
+obj-$(CONFIG_VIDEO_MT9D113)    += mt9d113.o
+
+obj-$(CONFIG_VIDEO_MT9V113)    += mt9v113.o
+
+obj-$(CONFIG_VIDEO_OV5640)     += ov5640.o
+
+obj-$(CONFIG_VIDEO_GC2235)     += gc2235.o
+obj-$(CONFIG_VIDEO_OV9724)     += ov9724.o
+obj-$(CONFIG_VIDEO_OV2722)     += ov2722.o
+obj-$(CONFIG_VIDEO_OV8830)     += ov8830.o
+obj-$(CONFIG_VIDEO_OV8858)     += ov8858_driver.o
+ov8858_driver-objs := ov8858.o imx/dw9718.o imx/vcm.o
+
+obj-$(CONFIG_VIDEO_S5K8AAY)    += s5k8aay.o
+obj-$(CONFIG_VIDEO_S5K6B2YX)    += s5k6b2yx.o
+
+m10mo_isp-objs := m10mo.o m10mo_fw.o m10mo_tables.o
+obj-$(CONFIG_VIDEO_M10MO)    += m10mo_isp.o
+obj-$(CONFIG_VIDEO_M10MO)    += m10mo_spi.o
+
+obj-$(CONFIG_VIDEO_MSRLIST_HELPER) += libmsrlisthelper.o
+
+obj-$(CONFIG_VIDEO_AP1302)     += ap1302.o
+obj-$(CONFIG_VIDEO_OV680)     += ov680.o
+
+obj-$(CONFIG_VIDEO_CSI_XACTOR) += xactor_x.o
+obj-$(CONFIG_VIDEO_PIXTER) += pixter.o
+
+#
+# Makefile for flash drivers
+#
+
+obj-$(CONFIG_VIDEO_LM3554) += lm3554.o
+obj-$(CONFIG_VIDEO_LM3559) += lm3559.o
+
+ccflags-y += -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ap1302.c b/drivers/external_drivers/camera/drivers/media/i2c/ap1302.c
new file mode 100644
index 0000000..6974154
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ap1302.c
@@ -0,0 +1,1359 @@
+/*
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include "ap1302.h"
+
+#define to_ap1302_device(sub_dev) container_of(sub_dev, struct ap1302_device, sd)
+
+/* Static definitions */
+static struct regmap_config ap1302_reg16_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+};
+
+static struct regmap_config ap1302_reg32_config = {
+	.reg_bits = 16,
+	.val_bits = 32,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+};
+
+static enum ap1302_contexts ap1302_cntx_mapping[] = {
+	CONTEXT_PREVIEW,	/* Invalid atomisp run mode */
+	CONTEXT_VIDEO,		/* ATOMISP_RUN_MODE_VIDEO */
+	CONTEXT_SNAPSHOT,	/* ATOMISP_RUN_MODE_STILL_CAPTURE */
+	CONTEXT_SNAPSHOT,	/* ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE */
+	CONTEXT_PREVIEW,	/* ATOMISP_RUN_MODE_PREVIEW */
+};
+
+static struct ap1302_res_struct ap1302_preview_res[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.fps = 30,
+	},
+	{
+		.width = 720,
+		.height = 480,
+		.fps = 30,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.fps = 30,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.fps = 30,
+	}
+};
+
+static struct ap1302_res_struct ap1302_snapshot_res[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.fps = 30,
+	},
+	{
+		.width = 720,
+		.height = 480,
+		.fps = 30,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.fps = 30,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.fps = 30,
+	}
+};
+
+static struct ap1302_res_struct ap1302_video_res[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.fps = 30,
+	},
+	{
+		.width = 720,
+		.height = 480,
+		.fps = 30,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.fps = 30,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.fps = 30,
+	}
+};
+
+static enum ap1302_contexts stream_to_context[] = {
+	CONTEXT_SNAPSHOT,
+	CONTEXT_PREVIEW,
+	CONTEXT_PREVIEW,
+	CONTEXT_VIDEO
+};
+
+static u16 aux_stream_config[CONTEXT_NUM][CONTEXT_NUM] = {
+	{0, 0, 0},	/* Preview: No aux streams. */
+	{1, 0, 2},	/* Snapshot: 1 for postview. 2 for video */
+	{1, 0, 0},	/* Video: 1 for preview. */
+};
+
+static struct ap1302_context_info context_info[] = {
+	{CNTX_WIDTH, AP1302_REG16, "width"},
+	{CNTX_HEIGHT, AP1302_REG16, "height"},
+	{CNTX_ROI_X0, AP1302_REG16, "roi_x0"},
+	{CNTX_ROI_X1, AP1302_REG16, "roi_x1"},
+	{CNTX_ROI_Y0, AP1302_REG16, "roi_y0"},
+	{CNTX_ROI_Y1, AP1302_REG16, "roi_y1"},
+	{CNTX_ASPECT, AP1302_REG16, "aspect"},
+	{CNTX_LOCK, AP1302_REG16, "lock"},
+	{CNTX_ENABLE, AP1302_REG16, "enable"},
+	{CNTX_OUT_FMT, AP1302_REG16, "out_fmt"},
+	{CNTX_SENSOR_MODE, AP1302_REG16, "sensor_mode"},
+	{CNTX_MIPI_CTRL, AP1302_REG16, "mipi_ctrl"},
+	{CNTX_MIPI_II_CTRL, AP1302_REG16, "mipi_ii_ctrl"},
+	{CNTX_LINE_TIME, AP1302_REG32, "line_time"},
+	{CNTX_MAX_FPS, AP1302_REG16, "max_fps"},
+	{CNTX_AE_USG, AP1302_REG16, "ae_usg"},
+	{CNTX_AE_UPPER_ET, AP1302_REG32, "ae_upper_et"},
+	{CNTX_AE_MAX_ET, AP1302_REG32, "ae_max_et"},
+	{CNTX_SS, AP1302_REG16, "ss"},
+	{CNTX_S1_SENSOR_MODE, AP1302_REG16, "s1_sensor_mode"},
+	{CNTX_HINF_CTRL, AP1302_REG16, "hinf_ctrl"},
+};
+
+/* This array stores the description list for metadata.
+   The metadata contains exposure settings and face
+   detection results. */
+static u16 ap1302_ss_list[] = {
+	0xb01c, /* From 0x0186 with size 0x1C are exposure settings. */
+	0x0186,
+	0xb002, /* 0x71c0 is for F-number */
+	0x71c0,
+	0xb010, /* From 0x03dc with size 0x10 are face general infos. */
+	0x03dc,
+	0xb0a0, /* From 0x03e4 with size 0xa0 are face detail infos. */
+	0x03e4,
+	0xb020, /* From 0x0604 with size 0x20 are smile rate infos. */
+	0x0604,
+	0x0000
+};
+
+/* End of static definitions */
+
+static int ap1302_i2c_read_reg(struct v4l2_subdev *sd,
+				u16 reg, u16 len, void *val)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (len == AP1302_REG16)
+		ret = regmap_read(dev->regmap16, reg, val);
+	else if (len == AP1302_REG32)
+		ret = regmap_read(dev->regmap32, reg, val);
+	else
+		ret = -EINVAL;
+	if (ret) {
+		dev_dbg(&client->dev, "Read reg failed. reg=0x%04X\n", reg);
+		return ret;
+	}
+	if (len == AP1302_REG16)
+		dev_dbg(&client->dev, "read_reg[0x%04X] = 0x%04X\n",
+			reg, *(u16*)val);
+	else
+		dev_dbg(&client->dev, "read_reg[0x%04X] = 0x%08X\n",
+			reg, *(u32*)val);
+	return ret;
+}
+
+static int ap1302_i2c_write_reg(struct v4l2_subdev *sd,
+				u16 reg, u16 len, u32 val)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	if (len == AP1302_REG16)
+		ret = regmap_write(dev->regmap16, reg, val);
+	else if (len == AP1302_REG32)
+		ret = regmap_write(dev->regmap32, reg, val);
+	else
+		ret = -EINVAL;
+	if (ret) {
+		dev_dbg(&client->dev, "Write reg failed. reg=0x%04X\n", reg);
+		return ret;
+	}
+	if (len == AP1302_REG16)
+		dev_dbg(&client->dev, "write_reg[0x%04X] = 0x%04X\n",
+			reg, (u16)val);
+	else
+		dev_dbg(&client->dev, "write_reg[0x%04X] = 0x%08X\n",
+			reg, (u32)val);
+	return ret;
+}
+
+static u16
+ap1302_calculate_context_reg_addr(enum ap1302_contexts context, u16 offset)
+{
+	u16 reg_addr;
+	/* The register offset is defined according to preview/video registers.
+	   Preview and video context have the same register definition.
+	   But snapshot context does not have register S1_SENSOR_MODE.
+	   When setting snapshot registers, if the offset exceeds
+	   S1_SENSOR_MODE, the actual offset needs to minus 2. */
+	if (context == CONTEXT_SNAPSHOT) {
+		if (offset == CNTX_S1_SENSOR_MODE)
+			return 0;
+		if (offset > CNTX_S1_SENSOR_MODE)
+			offset -= 2;
+	}
+	if (context == CONTEXT_PREVIEW)
+		reg_addr = REG_PREVIEW_BASE + offset;
+	else if (context == CONTEXT_VIDEO)
+		reg_addr = REG_VIDEO_BASE + offset;
+	else
+		reg_addr = REG_SNAPSHOT_BASE + offset;
+	return reg_addr;
+}
+
+static int ap1302_read_context_reg(struct v4l2_subdev *sd,
+		enum ap1302_contexts context, u16 offset, u16 len)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	u16 reg_addr = ap1302_calculate_context_reg_addr(context, offset);
+	if (reg_addr == 0)
+		return -EINVAL;
+	return ap1302_i2c_read_reg(sd, reg_addr, len,
+			    ((u8*)&dev->cntx_config[context]) + offset);
+}
+
+static int ap1302_write_context_reg(struct v4l2_subdev *sd,
+		enum ap1302_contexts context, u16 offset, u16 len)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	u16 reg_addr = ap1302_calculate_context_reg_addr(context, offset);
+	if (reg_addr == 0)
+		return -EINVAL;
+	return ap1302_i2c_write_reg(sd, reg_addr, len,
+			*(u32*)(((u8*)&dev->cntx_config[context]) + offset));
+}
+
+static int ap1302_dump_context_reg(struct v4l2_subdev *sd,
+				   enum ap1302_contexts context)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	int i;
+	dev_dbg(&client->dev, "Dump registers for context[%d]:\n", context);
+	for (i = 0; i < ARRAY_SIZE(context_info); i++) {
+		struct ap1302_context_info *info = &context_info[i];
+		u8 *var = (u8*)&dev->cntx_config[context] + info->offset;
+		/* Snapshot context does not have s1_sensor_mode register. */
+		if (context == CONTEXT_SNAPSHOT &&
+			info->offset == CNTX_S1_SENSOR_MODE)
+			continue;
+		ap1302_read_context_reg(sd, context, info->offset, info->len);
+		if (info->len == AP1302_REG16)
+			dev_dbg(&client->dev, "context.%s = 0x%04X (%d)\n",
+				info->name, *(u16*)var, *(u16*)var);
+		else
+			dev_dbg(&client->dev, "context.%s = 0x%08X (%d)\n",
+				info->name, *(u32*)var, *(u32*)var);
+	}
+	return 0;
+}
+
+static int ap1302_request_firmware(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	int ret;
+	ret = request_firmware(&dev->fw, "ap1302_fw.bin", &client->dev);
+	if (ret)
+		dev_err(&client->dev,
+			"ap1302_request_firmware failed. ret=%d\n", ret);
+	return ret;
+}
+
+/* When loading firmware, host writes firmware data from address 0x8000.
+   When the address reaches 0x9FFF, the next address should return to 0x8000.
+   This function handles this address window and load firmware data to AP1302.
+   win_pos indicates the offset within this window. Firmware loading procedure
+   may call this function several times. win_pos records the current position
+   that has been written to.*/
+static int ap1302_write_fw_window(struct v4l2_subdev *sd,
+				  u16 *win_pos, const u8 *buf, u32 len)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	int ret;
+	u32 pos;
+	u32 sub_len;
+	for (pos = 0; pos < len; pos += sub_len) {
+		if (len - pos < AP1302_FW_WINDOW_SIZE - *win_pos)
+			sub_len = len - pos;
+		else
+			sub_len = AP1302_FW_WINDOW_SIZE - *win_pos;
+		ret = regmap_raw_write(dev->regmap16,
+					*win_pos + AP1302_FW_WINDOW_OFFSET,
+					buf + pos, sub_len);
+		if (ret)
+			return ret;
+		*win_pos += sub_len;
+		if (*win_pos >= AP1302_FW_WINDOW_SIZE)
+			*win_pos = 0;
+	}
+	return 0;
+}
+
+static int ap1302_load_firmware(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	const struct ap1302_firmware *fw;
+	const u8* fw_data;
+	u16 reg_val = 0;
+	u16 win_pos = 0;
+	int ret;
+
+	dev_info(&client->dev, "Start to load firmware.\n");
+	if (!dev->fw) {
+		dev_err(&client->dev, "firmware not requested.\n");
+		return -EINVAL;
+	}
+	fw = (const struct ap1302_firmware*) dev->fw->data;
+	if (dev->fw->size != (sizeof(*fw) + fw->total_size)) {
+		dev_err(&client->dev, "firmware size does not match.\n");
+		return -EINVAL;
+	}
+	/* The fw binary contains a header of struct ap1302_firmware.
+	   Following the header is the bootdata of AP1302.
+	   The bootdata pointer can be referenced as &fw[1]. */
+	fw_data = (u8*)&fw[1];
+
+	/* Clear crc register. */
+	ret = ap1302_i2c_write_reg(sd, REG_SIP_CRC, AP1302_REG16, 0xFFFF);
+	if (ret)
+		return ret;
+
+	/* Load FW data for PLL init stage. */
+	ret = ap1302_write_fw_window(sd, &win_pos, fw_data, fw->pll_init_size);
+	if (ret)
+		return ret;
+
+	/* Write 2 to bootdata_stage register to apply basic_init_hp
+	   settings and enable PLL. */
+	ret = ap1302_i2c_write_reg(sd, REG_BOOTDATA_STAGE,
+				   AP1302_REG16, 0x0002);
+	if (ret)
+		return ret;
+
+	/* Wait 1ms for PLL to lock. */
+	msleep(1);
+
+	/* Load the rest of bootdata content. */
+	ret = ap1302_write_fw_window(sd, &win_pos, fw_data + fw->pll_init_size,
+				     fw->total_size - fw->pll_init_size);
+	if (ret)
+		return ret;
+
+	/* Check crc. */
+	ret = ap1302_i2c_read_reg(sd, REG_SIP_CRC, AP1302_REG16, &reg_val);
+	if (ret)
+		return ret;
+	if (reg_val != fw->crc) {
+		dev_err(&client->dev,
+			"crc does not match. T:0x%04X F:0x%04X\n",
+			fw->crc, reg_val);
+		return -EAGAIN;
+	}
+
+	/* Write 0xFFFF to bootdata_stage register to indicate AP1302 that
+	   the whole bootdata content has been loaded. */
+	ret = ap1302_i2c_write_reg(sd, REG_BOOTDATA_STAGE,
+				   AP1302_REG16, 0xFFFF);
+	if (ret)
+		return ret;
+	dev_info(&client->dev, "Load firmware successfully.\n");
+
+	return 0;
+}
+
+static int __ap1302_s_power(struct v4l2_subdev *sd, int on, int load_fw)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret, i;
+	u16 ss_ptr;
+
+	dev_info(&client->dev, "ap1302_s_power is called.\n");
+	ret = dev->platform_data->power_ctrl(sd, on);
+	if (ret) {
+		dev_err(&client->dev,
+			"ap1302_s_power error. on=%d ret=%d\n", on, ret);
+		return ret;
+	}
+	dev->power_on = on;
+	if (!on || !load_fw)
+		return 0;
+	/* Load firmware after power on. */
+	ret = ap1302_load_firmware(sd);
+	if (ret) {
+		dev_err(&client->dev,
+			"ap1302_load_firmware failed. ret=%d\n", ret);
+		return ret;
+	}
+	ret = ap1302_i2c_read_reg(sd, REG_SS_HEAD_PT0, AP1302_REG16, &ss_ptr);
+	if (ret)
+		return ret;
+	for (i = 0; i < ARRAY_SIZE(ap1302_ss_list); i++) {
+		ret = ap1302_i2c_write_reg(sd, ss_ptr + i * 2,
+			AP1302_REG16, ap1302_ss_list[i]);
+		if (ret)
+			return ret;
+	}
+	return ret;
+}
+
+static int ap1302_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ap1302_s_power(sd, on, 1);
+	dev->sys_activated = 0;
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ap1302_s_config(struct v4l2_subdev *sd, void *pdata)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *mipi_info;
+	u16 reg_val = 0;
+	int ret;
+
+	dev_info(&client->dev, "ap1302_s_config is called.\n");
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret)
+			goto fail_power;
+	}
+
+	ret = __ap1302_s_power(sd, 1, 0);
+	if (ret)
+		goto fail_power;
+
+	/* Detect for AP1302 */
+	ret = ap1302_i2c_read_reg(sd, REG_CHIP_VERSION, AP1302_REG16, &reg_val);
+	if (ret || (reg_val != AP1302_CHIP_ID)) {
+		dev_err(&client->dev,
+			"Chip version does no match. ret=%d ver=0x%04x\n",
+			ret, reg_val);
+		goto fail_config;
+	}
+	dev_info(&client->dev, "AP1302 Chip ID is 0x%X\n", reg_val);
+
+	/* Detect revision for AP1302 */
+	ret = ap1302_i2c_read_reg(sd, REG_CHIP_REV, AP1302_REG16, &reg_val);
+	if (ret)
+		goto fail_config;
+	dev_info(&client->dev, "AP1302 Chip Rev is 0x%X\n", reg_val);
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_config;
+
+	mipi_info = v4l2_get_subdev_hostdata(sd);
+	if (!mipi_info)
+		goto fail_config;
+	dev->num_lanes = mipi_info->num_lanes;
+
+	ret = __ap1302_s_power(sd, 0, 0);
+	if (ret)
+		goto fail_power;
+
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+
+fail_config:
+	__ap1302_s_power(sd, 0, 0);
+fail_power:
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "ap1302_s_config failed\n");
+	return ret;
+}
+
+static enum ap1302_contexts ap1302_get_context(struct v4l2_subdev *sd)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	return dev->cur_context;
+}
+
+static int ap1302_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int ap1302_match_resolution(struct ap1302_context_res *res,
+				   struct v4l2_mbus_framefmt *fmt)
+{
+	s32 w0, h0, mismatch, distance;
+	s32 w1 = fmt->width;
+	s32 h1 = fmt->height;
+	s32 min_distance = INT_MAX;
+	s32 i, idx = -1;
+
+	if (w1 == 0 || h1 == 0)
+		return -1;
+
+	for (i = 0; i < res->res_num; i++) {
+		w0 = res->res_table[i].width;
+		h0 = res->res_table[i].height;
+		if (w0 < w1 || h0 < h1)
+			continue;
+		mismatch = abs(w0 * h1 - w1 * h0) * 8192 / w1 / h0;
+		if (mismatch > 8192 * AP1302_MAX_RATIO_MISMATCH / 100)
+			continue;
+		distance = (w0 *h1 + w1 * h0) * 8192 / w1 / h1;
+		if (distance < min_distance) {
+			min_distance = distance;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static s32 ap1302_try_mbus_fmt_locked(struct v4l2_subdev *sd,
+				enum ap1302_contexts context,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct ap1302_res_struct *res_table;
+	s32 res_num, idx = -1;
+
+	res_table = dev->cntx_res[context].res_table;
+	res_num = dev->cntx_res[context].res_num;
+
+	if ((fmt->width <= res_table[res_num - 1].width) &&
+		(fmt->height <= res_table[res_num - 1].height))
+		idx = ap1302_match_resolution(&dev->cntx_res[context], fmt);
+	if (idx == -1)
+		idx = res_num - 1;
+
+	fmt->width = res_table[idx].width;
+	fmt->height = res_table[idx].height;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+	return idx;
+}
+
+static int ap1302_try_mbus_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	enum ap1302_contexts context;
+	mutex_lock(&dev->input_lock);
+	context = ap1302_get_context(sd);
+	ap1302_try_mbus_fmt_locked(sd, context, fmt);
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ap1302_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	enum ap1302_contexts context;
+	struct ap1302_res_struct *res_table;
+	s32 cur_res;
+
+	mutex_lock(&dev->input_lock);
+	context = ap1302_get_context(sd);
+	res_table = dev->cntx_res[context].res_table;
+	cur_res = dev->cntx_res[context].cur_res;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+	fmt->width = res_table[cur_res].width;
+	fmt->height = res_table[cur_res].height;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ap1302_set_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+		(struct atomisp_input_stream_info*)fmt->reserved;
+	enum ap1302_contexts context, main_context;
+
+	mutex_lock(&dev->input_lock);
+	context = stream_to_context[stream_info->stream];
+	dev_dbg(&client->dev, "ap1302_set_mbus_fmt. stream=%d context=%d\n",
+		stream_info->stream, context);
+	dev->cntx_res[context].cur_res =
+		ap1302_try_mbus_fmt_locked(sd, context, fmt);
+	dev->cntx_config[context].width = fmt->width;
+	dev->cntx_config[context].height = fmt->height;
+	ap1302_write_context_reg(sd, context, CNTX_WIDTH, AP1302_REG16);
+	ap1302_write_context_reg(sd, context, CNTX_HEIGHT, AP1302_REG16);
+	ap1302_read_context_reg(sd, context, CNTX_OUT_FMT, AP1302_REG16);
+	dev->cntx_config[context].out_fmt &= ~OUT_FMT_TYPE_MASK;
+	dev->cntx_config[context].out_fmt |= AP1302_FMT_UYVY422;
+	ap1302_write_context_reg(sd, context, CNTX_OUT_FMT, AP1302_REG16);
+
+	main_context = ap1302_get_context(sd);
+	if (context == main_context) {
+		ap1302_read_context_reg(sd, context,
+			CNTX_MIPI_CTRL, AP1302_REG16);
+		dev->cntx_config[context].mipi_ctrl &= ~MIPI_CTRL_IMGVC_MASK;
+		dev->cntx_config[context].mipi_ctrl |=
+			(context << MIPI_CTRL_IMGVC_OFFSET);
+		dev->cntx_config[context].mipi_ctrl &= ~MIPI_CTRL_SSVC_MASK;
+		dev->cntx_config[context].mipi_ctrl |=
+			(context << MIPI_CTRL_SSVC_OFFSET);
+		dev->cntx_config[context].mipi_ctrl &= ~MIPI_CTRL_SSTYPE_MASK;
+		dev->cntx_config[context].mipi_ctrl |=
+			(0x12 << MIPI_CTRL_SSTYPE_OFFSET);
+		ap1302_write_context_reg(sd, context,
+			CNTX_MIPI_CTRL, AP1302_REG16);
+		ap1302_read_context_reg(sd, context,
+			CNTX_SS, AP1302_REG16);
+		dev->cntx_config[context].ss = AP1302_SS_CTRL;
+		ap1302_write_context_reg(sd, context,
+			CNTX_SS, AP1302_REG16);
+	} else {
+		/* Configure aux stream */
+		ap1302_read_context_reg(sd, context,
+			CNTX_MIPI_II_CTRL, AP1302_REG16);
+		dev->cntx_config[context].mipi_ii_ctrl &= ~MIPI_CTRL_IMGVC_MASK;
+		dev->cntx_config[context].mipi_ii_ctrl |=
+			(context << MIPI_CTRL_IMGVC_OFFSET);
+		ap1302_write_context_reg(sd, context,
+			CNTX_MIPI_II_CTRL, AP1302_REG16);
+		if (stream_info->enable) {
+			ap1302_read_context_reg(sd, main_context,
+				CNTX_OUT_FMT, AP1302_REG16);
+			dev->cntx_config[context].out_fmt |=
+				(aux_stream_config[main_context][context]
+				 << OUT_FMT_IIS_OFFSET);
+			ap1302_write_context_reg(sd, main_context,
+				CNTX_OUT_FMT, AP1302_REG16);
+		}
+	}
+	stream_info->ch_id = context;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int
+ap1302_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	s32 index = fsize->index;
+	enum ap1302_contexts context;
+	struct ap1302_res_struct *res_table;
+
+	mutex_lock(&dev->input_lock);
+	context = ap1302_get_context(sd);
+	if (index >= dev->cntx_res[context].res_num) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	res_table = dev->cntx_res[context].res_table;
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = res_table[index].width;
+	fsize->discrete.height = res_table[index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ap1302_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	enum ap1302_contexts context;
+	struct ap1302_res_struct *res_table;
+	unsigned int index = fival->index;
+	s32 res_num, i;
+
+	if (index > 0)
+		return -EINVAL;
+	mutex_lock(&dev->input_lock);
+	context = ap1302_get_context(sd);
+	res_table = dev->cntx_res[context].res_table;
+	res_num = dev->cntx_res[context].res_num;
+	/* find out the first equal or bigger size */
+	for (i = 0; i < res_num; i++) {
+		if ((res_table[i].width >= fival->width) &&
+		    (res_table[i].height >= fival->height))
+			break;
+	}
+	if (i == res_num)
+		i--;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = res_table[i].width;
+	fival->height = res_table[i].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = res_table[i].fps;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ap1302_g_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	enum ap1302_contexts context;
+	struct ap1302_res_struct *res_table;
+	u32 cur_res;
+
+	mutex_lock(&dev->input_lock);
+	context = ap1302_get_context(sd);
+	res_table = dev->cntx_res[context].res_table;
+	cur_res = dev->cntx_res[context].cur_res;
+	interval->interval.denominator = res_table[cur_res].fps;
+	interval->interval.numerator = 1;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ap1302_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	enum ap1302_contexts context;
+	struct ap1302_res_struct *res_table;
+	int index = fse->index;
+
+	mutex_lock(&dev->input_lock);
+	context = ap1302_get_context(sd);
+	if (index >= dev->cntx_res[context].res_num) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	res_table = dev->cntx_res[context].res_table;
+	fse->min_width = res_table[index].width;
+	fse->min_height = res_table[index].height;
+	fse->max_width = res_table[index].width;
+	fse->max_height = res_table[index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__ap1302_get_pad_format(struct ap1302_device *dev,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+	else
+		return &dev->format;
+}
+
+static int
+ap1302_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		      struct v4l2_subdev_format *fmt)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct v4l2_mbus_framefmt *format =
+			__ap1302_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	mutex_lock(&dev->input_lock);
+	fmt->format = *format;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int
+ap1302_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		      struct v4l2_subdev_format *fmt)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ap1302_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	*frames = 0;
+	return 0;
+}
+
+static int ap1302_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	enum ap1302_contexts context;
+	u32 reg_val;
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	context = ap1302_get_context(sd);
+	dev_dbg(&client->dev, "ap1302_s_stream. context=%d enable=%d\n", context, enable);
+	/* Switch context */
+	ap1302_i2c_read_reg(sd, REG_CTRL,
+			    AP1302_REG16, &reg_val);
+	reg_val &= ~CTRL_CNTX_MASK;
+	reg_val |= (context<<CTRL_CNTX_OFFSET);
+	ap1302_i2c_write_reg(sd, REG_CTRL,
+			    AP1302_REG16, reg_val);
+	/* Select sensor */
+	ap1302_i2c_read_reg(sd, REG_SENSOR_SELECT,
+			    AP1302_REG16, &reg_val);
+	reg_val &= ~SENSOR_SELECT_MASK;
+	reg_val |= (AP1302_SENSOR_PRI<<SENSOR_SELECT_OFFSET);
+	ap1302_i2c_write_reg(sd, REG_SENSOR_SELECT,
+			    AP1302_REG16, reg_val);
+	if (enable) {
+		dev_info(&client->dev, "Start stream. context=%d\n", context);
+		ap1302_dump_context_reg(sd, context);
+		if (!dev->sys_activated) {
+			reg_val = AP1302_SYS_ACTIVATE;
+			dev->sys_activated = 1;
+		} else {
+			reg_val = AP1302_SYS_SWITCH;
+		}
+	} else {
+		dev_info(&client->dev, "Stop stream. context=%d\n", context);
+		reg_val = AP1302_SYS_SWITCH;
+	}
+	ret = ap1302_i2c_write_reg(sd, REG_SYS_START, AP1302_REG16, reg_val);
+	if (ret)
+		dev_err(&client->dev,
+			"AP1302 set stream failed. enable=%d\n", enable);
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static u16 ap1302_ev_values[] = {0xfd00, 0xfe80, 0x0, 0x180, 0x300};
+
+static int ap1302_set_exposure_off(struct v4l2_subdev *sd, s32 val)
+{
+	val -= AP1302_MIN_EV;
+	return ap1302_i2c_write_reg(sd, REG_AE_BV_OFF, AP1302_REG16,
+				ap1302_ev_values[val]);
+}
+
+static u16 ap1302_wb_values[] = {
+	0, /* V4L2_WHITE_BALANCE_MANUAL */
+	0xf, /* V4L2_WHITE_BALANCE_AUTO */
+	0x2, /* V4L2_WHITE_BALANCE_INCANDESCENT */
+	0x4, /* V4L2_WHITE_BALANCE_FLUORESCENT */
+	0x5, /* V4L2_WHITE_BALANCE_FLUORESCENT_H */
+	0x1, /* V4L2_WHITE_BALANCE_HORIZON */
+	0x5, /* V4L2_WHITE_BALANCE_DAYLIGHT */
+	0xf, /* V4L2_WHITE_BALANCE_FLASH */
+	0x6, /* V4L2_WHITE_BALANCE_CLOUDY */
+	0x6, /* V4L2_WHITE_BALANCE_SHADE */
+};
+
+static int ap1302_set_wb_mode(struct v4l2_subdev *sd, s32 val)
+{
+	int ret = 0;
+	u16 reg_val;
+
+	ret = ap1302_i2c_read_reg(sd, REG_AWB_CTRL, AP1302_REG16, &reg_val);
+	if (ret)
+		return ret;
+	reg_val &= ~AWB_CTRL_MODE_MASK;
+	reg_val |= ap1302_wb_values[val] << AWB_CTRL_MODE_OFFSET;
+	if (val == V4L2_WHITE_BALANCE_FLASH)
+		reg_val |= AWB_CTRL_FLASH_MASK;
+	else
+		reg_val &= ~AWB_CTRL_FLASH_MASK;
+	ret = ap1302_i2c_write_reg(sd, REG_AWB_CTRL, AP1302_REG16, reg_val);
+	return ret;
+}
+
+static int ap1302_set_zoom(struct v4l2_subdev *sd, s32 val)
+{
+	ap1302_i2c_write_reg(sd, REG_DZ_TGT_FCT, AP1302_REG16,
+		val * 4 + 0x100);
+	return 0;
+}
+
+static u16 ap1302_sfx_values[] = {
+	0x00, /* V4L2_COLORFX_NONE */
+	0x03, /* V4L2_COLORFX_BW */
+	0x0d, /* V4L2_COLORFX_SEPIA */
+	0x07, /* V4L2_COLORFX_NEGATIVE */
+	0x04, /* V4L2_COLORFX_EMBOSS */
+	0x0f, /* V4L2_COLORFX_SKETCH */
+	0x08, /* V4L2_COLORFX_SKY_BLUE */
+	0x09, /* V4L2_COLORFX_GRASS_GREEN */
+	0x0a, /* V4L2_COLORFX_SKIN_WHITEN */
+	0x00, /* V4L2_COLORFX_VIVID */
+	0x00, /* V4L2_COLORFX_AQUA */
+	0x00, /* V4L2_COLORFX_ART_FREEZE */
+	0x00, /* V4L2_COLORFX_SILHOUETTE */
+	0x10, /* V4L2_COLORFX_SOLARIZATION */
+	0x02, /* V4L2_COLORFX_ANTIQUE */
+	0x00, /* V4L2_COLORFX_SET_CBCR */
+};
+
+static int ap1302_set_special_effect(struct v4l2_subdev *sd, s32 val)
+{
+	ap1302_i2c_write_reg(sd, REG_SFX_MODE, AP1302_REG16,
+		ap1302_sfx_values[val]);
+	return 0;
+}
+
+static u16 ap1302_scene_mode_values[] = {
+	0x00, /* V4L2_SCENE_MODE_NONE */
+	0x07, /* V4L2_SCENE_MODE_BACKLIGHT */
+	0x0a, /* V4L2_SCENE_MODE_BEACH_SNOW */
+	0x06, /* V4L2_SCENE_MODE_CANDLE_LIGHT */
+	0x00, /* V4L2_SCENE_MODE_DAWN_DUSK */
+	0x00, /* V4L2_SCENE_MODE_FALL_COLORS */
+	0x0d, /* V4L2_SCENE_MODE_FIREWORKS */
+	0x02, /* V4L2_SCENE_MODE_LANDSCAPE */
+	0x05, /* V4L2_SCENE_MODE_NIGHT */
+	0x0c, /* V4L2_SCENE_MODE_PARTY_INDOOR */
+	0x01, /* V4L2_SCENE_MODE_PORTRAIT */
+	0x03, /* V4L2_SCENE_MODE_SPORTS */
+	0x0e, /* V4L2_SCENE_MODE_SUNSET */
+	0x0b, /* V4L2_SCENE_MODE_TEXT */
+};
+
+static int ap1302_set_scene_mode(struct v4l2_subdev *sd, s32 val)
+{
+	ap1302_i2c_write_reg(sd, REG_SCENE_CTRL, AP1302_REG16,
+		ap1302_scene_mode_values[val]);
+	return 0;
+}
+
+static u16 ap1302_flicker_values[] = {
+	0x0,    /* OFF */
+	0x3201, /* 50HZ */
+	0x3c01, /* 60HZ */
+	0x2     /* AUTO */
+};
+
+static int ap1302_set_flicker_freq(struct v4l2_subdev *sd, s32 val)
+{
+	ap1302_i2c_write_reg(sd, REG_FLICK_CTRL, AP1302_REG16,
+		ap1302_flicker_values[val]);
+	return 0;
+}
+
+static int ap1302_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ap1302_device *dev = container_of(
+		ctrl->handler, struct ap1302_device, ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		dev->cur_context = ap1302_cntx_mapping[ctrl->val];
+		break;
+	case V4L2_CID_EXPOSURE:
+		ap1302_set_exposure_off(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		ap1302_set_wb_mode(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_ZOOM_ABSOLUTE:
+		ap1302_set_zoom(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_COLORFX:
+		ap1302_set_special_effect(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_SCENE_MODE:
+		ap1302_set_scene_mode(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		ap1302_set_flicker_freq(&dev->sd, ctrl->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ap1302_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	int ret;
+	u32 reg_val;
+
+	if (reg->size != AP1302_REG16 &&
+	    reg->size != AP1302_REG32)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power_on)
+		ret = ap1302_i2c_read_reg(sd, reg->reg, reg->size, &reg_val);
+	else
+		ret = -EIO;
+	mutex_unlock(&dev->input_lock);
+	if (ret)
+		return ret;
+
+	reg->val = reg_val;
+
+	return 0;
+}
+
+static int ap1302_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct ap1302_device *dev = to_ap1302_device(sd);
+	int ret;
+
+	if (reg->size != AP1302_REG16 &&
+	    reg->size != AP1302_REG32)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power_on)
+		ret = ap1302_i2c_write_reg(sd, reg->reg, reg->size, reg->val);
+	else
+		ret = -EIO;
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static long ap1302_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	long ret = 0;
+	switch (cmd) {
+	case VIDIOC_DBG_G_REGISTER:
+		ret = ap1302_g_register(sd, arg);
+		break;
+	case VIDIOC_DBG_S_REGISTER:
+		ret = ap1302_s_register(sd, arg);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = ap1302_s_ctrl,
+};
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_RUN_MODE,
+		.name = "Run Mode",
+		.type = V4L2_CTRL_TYPE_MENU,
+		.min = 1,
+		.def = 4,
+		.max = 4,
+		.qmenu = ctrl_run_mode_menu,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = AP1302_MIN_EV,
+		.def = 0,
+		.max = AP1302_MAX_EV,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+		.name = "White Balance",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 9,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_ZOOM_ABSOLUTE,
+		.name = "Zoom Absolute",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 1024,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_COLORFX,
+		.name = "Color Special Effect",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 15,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_SCENE_MODE,
+		.name = "Scene Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 13,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_POWER_LINE_FREQUENCY,
+		.name = "Light frequency filter",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 3,
+		.max = 3,
+		.step = 1,
+	},
+};
+
+static struct v4l2_subdev_sensor_ops ap1302_sensor_ops = {
+	.g_skip_frames	= ap1302_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops ap1302_video_ops = {
+	.try_mbus_fmt = ap1302_try_mbus_fmt,
+	.s_mbus_fmt = ap1302_set_mbus_fmt,
+	.g_mbus_fmt = ap1302_get_mbus_fmt,
+	.s_stream = ap1302_s_stream,
+	.enum_framesizes = ap1302_enum_framesizes,
+	.enum_frameintervals = ap1302_enum_frameintervals,
+	.g_frame_interval = ap1302_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops ap1302_core_ops = {
+	.s_power	= ap1302_s_power,
+	.queryctrl	= v4l2_subdev_queryctrl,
+	.g_ctrl		= v4l2_subdev_g_ctrl,
+	.s_ctrl		= v4l2_subdev_s_ctrl,
+	.ioctl		= ap1302_ioctl,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= ap1302_g_register,
+	.s_register	= ap1302_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_pad_ops ap1302_pad_ops = {
+	.enum_mbus_code	 = ap1302_enum_mbus_code,
+	.enum_frame_size = ap1302_enum_frame_size,
+	.get_fmt	 = ap1302_get_pad_format,
+	.set_fmt	 = ap1302_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ap1302_ops = {
+	.core		= &ap1302_core_ops,
+	.pad		= &ap1302_pad_ops,
+	.video		= &ap1302_video_ops,
+	.sensor		= &ap1302_sensor_ops
+};
+
+static int ap1302_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ap1302_device *dev = to_ap1302_device(sd);
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	release_firmware(dev->fw);
+
+	media_entity_cleanup(&dev->sd.entity);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+
+	return 0;
+}
+
+static int ap1302_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct ap1302_device *dev;
+	int ret;
+	unsigned int i;
+
+	dev_info(&client->dev, "ap1302 probe called.\n");
+
+	/* allocate device & init sub device */
+	dev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ap1302_ops);
+
+	ret = ap1302_request_firmware(&(dev->sd));
+	if (ret) {
+		dev_err(&client->dev, "Cannot request ap1302 firmware.\n");
+		goto out_free;
+	}
+
+	dev->regmap16 = devm_regmap_init_i2c(client, &ap1302_reg16_config);
+	if (IS_ERR(dev->regmap16)) {
+		ret = PTR_ERR(dev->regmap16);
+		dev_err(&client->dev,
+			"Failed to allocate 16bit register map: %d\n", ret);
+		return ret;
+	}
+
+	dev->regmap32 = devm_regmap_init_i2c(client, &ap1302_reg32_config);
+	if (IS_ERR(dev->regmap32)) {
+		ret = PTR_ERR(dev->regmap32);
+		dev_err(&client->dev,
+			"Failed to allocate 32bit register map: %d\n", ret);
+		return ret;
+	}
+
+	if (client->dev.platform_data) {
+		ret = ap1302_s_config(&dev->sd, client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	dev->cntx_res[CONTEXT_PREVIEW].res_num = ARRAY_SIZE(ap1302_preview_res);
+	dev->cntx_res[CONTEXT_PREVIEW].res_table = ap1302_preview_res;
+	dev->cntx_res[CONTEXT_SNAPSHOT].res_num =
+		ARRAY_SIZE(ap1302_snapshot_res);
+	dev->cntx_res[CONTEXT_SNAPSHOT].res_table = ap1302_snapshot_res;
+	dev->cntx_res[CONTEXT_VIDEO].res_num = ARRAY_SIZE(ap1302_video_res);
+	dev->cntx_res[CONTEXT_VIDEO].res_table = ap1302_video_res;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls));
+	if (ret) {
+		ap1302_remove(client);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		ap1302_remove(client);
+		return dev->ctrl_handler.error;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+
+	dev->run_mode = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_RUN_MODE);
+	v4l2_ctrl_s_ctrl(dev->run_mode, ATOMISP_RUN_MODE_PREVIEW);
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		ap1302_remove(client);
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	return ret;
+}
+
+static const struct i2c_device_id ap1302_id[] = {
+	{AP1302_NAME, 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ap1302_id);
+
+static struct i2c_driver ap1302_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = AP1302_NAME,
+	},
+	.probe = ap1302_probe,
+	.remove = ap1302_remove,
+	.id_table = ap1302_id,
+};
+
+module_i2c_driver(ap1302_driver);
+
+MODULE_AUTHOR("Tianshu Qiu <tian.shu.qiu@intel.com>");
+MODULE_DESCRIPTION("AP1302 Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ap1302.h b/drivers/external_drivers/camera/drivers/media/i2c/ap1302.h
new file mode 100644
index 0000000..3ccad29
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ap1302.h
@@ -0,0 +1,198 @@
+/*
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __AP1302_H__
+#define __AP1302_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/regmap.h>
+#include <linux/types.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-subdev.h>
+
+#define AP1302_NAME		"ap1302"
+#define AP1302_CHIP_ID		0x265
+#define AP1302_I2C_MAX_LEN	65534
+#define AP1302_FW_WINDOW_OFFSET	0x8000
+#define AP1302_FW_WINDOW_SIZE	0x2000
+
+#define AP1302_REG16		2
+#define AP1302_REG32		4
+
+#define REG_CHIP_VERSION	0x0000
+#define REG_CHIP_REV		0x0050
+#define REG_MF_ID		0x0004
+#define REG_ERROR		0x0006
+#define REG_CTRL		0x1000
+#define REG_DZ_TGT_FCT		0x1010
+#define REG_SFX_MODE		0x1016
+#define REG_SS_HEAD_PT0		0x1174
+#define REG_AE_BV_OFF		0x5014
+#define REG_AE_BV_BIAS		0x5016
+#define REG_AWB_CTRL		0x5100
+#define REG_FLICK_CTRL		0x5440
+#define REG_SCENE_CTRL		0x5454
+#define REG_BOOTDATA_STAGE	0x6002
+#define REG_SENSOR_SELECT	0x600C
+#define REG_SYS_START		0x601A
+#define REG_SIP_CRC		0xF052
+
+#define REG_PREVIEW_BASE	0x2000
+#define REG_SNAPSHOT_BASE	0x3000
+#define REG_VIDEO_BASE		0x4000
+#define CNTX_WIDTH		0x00
+#define CNTX_HEIGHT		0x02
+#define CNTX_ROI_X0		0x04
+#define CNTX_ROI_Y0		0x06
+#define CNTX_ROI_X1		0x08
+#define CNTX_ROI_Y1		0x0A
+#define CNTX_ASPECT		0x0C
+#define CNTX_LOCK		0x0E
+#define CNTX_ENABLE		0x10
+#define CNTX_OUT_FMT		0x12
+#define CNTX_SENSOR_MODE	0x14
+#define CNTX_MIPI_CTRL		0x16
+#define CNTX_MIPI_II_CTRL	0x18
+#define CNTX_LINE_TIME		0x1C
+#define CNTX_MAX_FPS		0x20
+#define CNTX_AE_USG		0x22
+#define CNTX_AE_UPPER_ET	0x24
+#define CNTX_AE_MAX_ET		0x28
+#define CNTX_SS			0x2C
+#define CNTX_S1_SENSOR_MODE	0x2E
+#define CNTX_HINF_CTRL		0x30
+
+#define CTRL_CNTX_MASK		0x03
+#define CTRL_CNTX_OFFSET	0x00
+#define HINF_CTRL_LANE_MASK	0x07
+#define HINF_CTRL_LANE_OFFSET	0x00
+#define MIPI_CTRL_IMGVC_MASK	0xC0
+#define MIPI_CTRL_IMGVC_OFFSET	0x06
+#define MIPI_CTRL_IMGTYPE_AUTO	0x3F
+#define MIPI_CTRL_SSVC_MASK	0xC000
+#define MIPI_CTRL_SSVC_OFFSET	0x0E
+#define MIPI_CTRL_SSTYPE_MASK	0x3F00
+#define MIPI_CTRL_SSTYPE_OFFSET	0x08
+#define OUT_FMT_IIS_MASK	0x30
+#define OUT_FMT_IIS_OFFSET	0x08
+#define OUT_FMT_SS_MASK		0x1000
+#define OUT_FMT_SS_OFFSET	0x12
+#define OUT_FMT_TYPE_MASK	0xFF
+#define SENSOR_SELECT_MASK	0x03
+#define SENSOR_SELECT_OFFSET	0x00
+#define AWB_CTRL_MODE_MASK	0x0F
+#define AWB_CTRL_MODE_OFFSET	0x00
+#define AWB_CTRL_FLASH_MASK	0x100
+
+#define AP1302_FMT_UYVY422	0x50
+
+#define AP1302_SYS_ACTIVATE	0x8010
+#define AP1302_SYS_SWITCH	0x8140
+#define AP1302_SENSOR_PRI	0x01
+#define AP1302_SENSOR_SEC	0x02
+#define AP1302_SS_CTRL		0x31
+
+#define AP1302_MAX_RATIO_MISMATCH	10 /* Unit in percentage */
+#define AP1302_MAX_EV		2
+#define AP1302_MIN_EV		-2
+
+enum ap1302_contexts {
+	CONTEXT_PREVIEW = 0,
+	CONTEXT_SNAPSHOT,
+	CONTEXT_VIDEO,
+	CONTEXT_NUM
+};
+
+/* The context registers are defined according to preview/video registers.
+   Preview and video context have the same register definition.
+   But snapshot context does not have register S1_SENSOR_MODE.
+   When setting snapshot registers, if the offset exceeds
+   S1_SENSOR_MODE, the actual offset needs to minus 2. */
+struct ap1302_context_config {
+	u16 width;
+	u16 height;
+	u16 roi_x0;
+	u16 roi_y0;
+	u16 roi_x1;
+	u16 roi_y1;
+	u16 aspect_factor;
+	u16 lock;
+	u16 enable;
+	u16 out_fmt;
+	u16 sensor_mode;
+	u16 mipi_ctrl;
+	u16 mipi_ii_ctrl;
+	u16 padding;
+	u32 line_time;
+	u16 max_fps;
+	u16 ae_usg;
+	u32 ae_upper_et;
+	u32 ae_max_et;
+	u16 ss;
+	u16 s1_sensor_mode;
+	u16 hinf_ctrl;
+	u32 reserved;
+};
+
+struct ap1302_res_struct {
+	u16 width;
+	u16 height;
+	u16 fps;
+};
+
+struct ap1302_context_res {
+	s32 res_num;
+	s32 cur_res;
+	struct ap1302_res_struct *res_table;
+};
+
+struct ap1302_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct camera_sensor_platform_data *platform_data;
+	const struct firmware *fw;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	struct v4l2_mbus_framefmt format;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *run_mode;
+	struct ap1302_context_config cntx_config[CONTEXT_NUM];
+	struct ap1302_context_res cntx_res[CONTEXT_NUM];
+	enum ap1302_contexts cur_context;
+	unsigned int num_lanes;
+	struct regmap *regmap16;
+	struct regmap *regmap32;
+	bool sys_activated;
+	bool power_on;
+};
+
+struct ap1302_firmware {
+	u32 crc;
+	u32 pll_init_size;
+	u32 total_size;
+	u32 reserved;
+};
+
+struct ap1302_context_info {
+	u16 offset;
+	u16 len;
+	char *name;
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
new file mode 100644
index 0000000..b4baa55
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.c
@@ -0,0 +1,1282 @@
+/*
+ * Support for GalaxyCore GC2235 2M camera sensor.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/io.h>
+
+#include "gc2235.h"
+
+/* i2c read/write stuff */
+static int gc2235_read_reg(struct i2c_client *client,
+			   u16 data_length, u16 reg, u16 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[6];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != GC2235_8BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == GC2235_8BIT)
+		*val = (u8)data[0];
+
+	return 0;
+}
+
+static int gc2235_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int gc2235_write_reg(struct i2c_client *client, u16 data_length,
+							u8 reg, u8 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	const u16 len = data_length + sizeof(u8); /* 16-bit address + data */
+
+	if (data_length != GC2235_8BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	data[0] = reg;
+	data[1] = val;
+
+	ret = gc2235_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+static int __gc2235_flush_reg_array(struct i2c_client *client,
+				    struct gc2235_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u8) + ctrl->index; /* 8-bit address + data */
+	ctrl->index = 0;
+
+	return gc2235_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __gc2235_buf_reg_array(struct i2c_client *client,
+				  struct gc2235_write_ctrl *ctrl,
+				  const struct gc2235_reg *next)
+{
+	int size;
+
+	if (next->type != GC2235_8BIT)
+		return -EINVAL;
+
+	size = 1;
+	ctrl->buffer.data[ctrl->index] = (u8)next->val;
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u8) >= GC2235_MAX_WRITE_BUF_SIZE)
+		return __gc2235_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+static int __gc2235_write_reg_is_consecutive(struct i2c_client *client,
+					     struct gc2235_write_ctrl *ctrl,
+					     const struct gc2235_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+static int gc2235_write_reg_array(struct i2c_client *client,
+				  const struct gc2235_reg *reglist)
+{
+	const struct gc2235_reg *next = reglist;
+	struct gc2235_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != GC2235_TOK_TERM; next++) {
+		switch (next->type & GC2235_TOK_MASK) {
+		case GC2235_TOK_DELAY:
+			err = __gc2235_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__gc2235_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __gc2235_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __gc2235_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __gc2235_flush_reg_array(client, &ctrl);
+}
+
+static int gc2235_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC2235_FOCAL_LENGTH_NUM << 16) | GC2235_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int gc2235_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 16) | GC2235_F_NUMBER_DEM;
+	return 0;
+}
+
+static int gc2235_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (GC2235_F_NUMBER_DEFAULT_NUM << 24) |
+		(GC2235_F_NUMBER_DEM << 16) |
+		(GC2235_F_NUMBER_DEFAULT_NUM << 8) | GC2235_F_NUMBER_DEM;
+	return 0;
+}
+
+
+static int gc2235_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct gc2235_resolution *res)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	u16 reg_val, reg_val_h, dummy;
+	int ret;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* pixel clock calculattion */
+	buf->vt_pix_clk_freq_mhz = dev->vt_pix_clk_freq_mhz = 43750000;
+
+	/* get integration time */
+	buf->coarse_integration_time_min = GC2235_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+					GC2235_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = GC2235_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					GC2235_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = GC2235_FINE_INTG_TIME_MIN;
+	buf->frame_length_lines = res->lines_per_frame;
+	buf->line_length_pck = res->pixels_per_line;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_H_CROP_START_H, &reg_val_h);
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_H_CROP_START_L, &reg_val);
+	if (ret)
+		return ret;
+
+	buf->crop_horizontal_start = ((u16)reg_val_h << 8) | (u16)reg_val;
+
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_V_CROP_START_H, &reg_val_h);
+	ret =  gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_V_CROP_START_L, &reg_val);
+	if (ret)
+		return ret;
+
+	buf->crop_vertical_start = ((u16)reg_val_h << 8) | (u16)reg_val;
+
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_H_OUTSIZE_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_H_OUTSIZE_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_width = ((u16)reg_val_h << 8) | (u16)reg_val;
+
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_V_OUTSIZE_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_V_OUTSIZE_L, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_height = ((u16)reg_val_h << 8) | (u16)reg_val;
+
+	buf->crop_horizontal_end = buf->crop_horizontal_start +
+						buf->output_width - 1;
+	buf->crop_vertical_end = buf->crop_vertical_start +
+						buf->output_height - 1;
+
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_HB_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_HB_L, &reg_val);
+	if (ret)
+		return ret;
+
+	dummy = ((u16)reg_val_h << 8) | (u16)reg_val;
+
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_SH_DELAY_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_SH_DELAY_L, &reg_val);
+
+	buf->line_length_pck = buf->output_width + 16 + dummy +
+				(((u16)reg_val_h << 8) | (u16)reg_val) + 4;
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_VB_H, &reg_val_h);
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+                                        GC2235_VB_L, &reg_val);
+	if (ret)
+		return ret;
+
+	buf->frame_length_lines = buf->output_height + 32 +
+				(((u16)reg_val_h << 8) | (u16)reg_val);
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
+	return 0;
+}
+
+static long __gc2235_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse_integration = (u16)coarse_itg;
+	int ret = 0;
+	u16 expo_coarse_h,expo_coarse_l, gain_val = 0xF0, gain_val2 = 0xF0;
+	expo_coarse_h = coarse_integration>>8;
+	expo_coarse_l = coarse_integration & 0xff;
+
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_H, expo_coarse_h);
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_L, expo_coarse_l);
+
+	if (gain <= 0x58) {
+		gain_val = 0x40;
+		gain_val2 = 0x58;
+	} else if (gain < 256) {
+		gain_val = 0x40;
+		gain_val2 = gain;
+	} else {
+		gain_val2 = 64 * gain / 256;
+		gain_val = 0xff;
+	}
+
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+					GC2235_GLOBAL_GAIN, (u8)gain_val);
+	ret = gc2235_write_reg(client, GC2235_8BIT,
+					GC2235_PRE_GAIN, (u8)gain_val2);
+
+	return ret;
+}
+
+static int gc2235_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __gc2235_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long gc2235_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	int exp = exposure->integration_time[0];
+	int gain = exposure->gain[0];
+	int digitgain = exposure->gain[1];
+
+	/* we should not accept the invalid value below. */
+	if (gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	return gc2235_set_exposure(sd, exp, gain, digitgain);
+}
+
+static long gc2235_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return gc2235_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int gc2235_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 reg_v, reg_v2;
+	int ret;
+
+	/* get exposure */
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_L,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_EXPOSURE_H,
+					&reg_v2);
+	if (ret)
+		goto err;
+
+	reg_v += reg_v2 << 8;
+
+	*value = reg_v;
+err:
+	return ret;
+}
+
+struct gc2235_control gc2235_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = gc2235_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = GC2235_FOCAL_LENGTH_DEFAULT,
+			.maximum = GC2235_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = GC2235_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc2235_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = GC2235_F_NUMBER_DEFAULT,
+			.maximum = GC2235_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = GC2235_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = gc2235_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = GC2235_F_NUMBER_RANGE,
+			.maximum =  GC2235_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = GC2235_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = gc2235_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(gc2235_controls))
+
+static struct gc2235_control *gc2235_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (gc2235_controls[i].qc.id == id)
+			return &gc2235_controls[i];
+	return NULL;
+}
+
+static int gc2235_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct gc2235_control *ctrl = gc2235_find_control(qc->id);
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int gc2235_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc2235_control *s_ctrl;
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = gc2235_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int gc2235_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct gc2235_control *octrl = gc2235_find_control(ctrl->id);
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+static int __gc2235_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	/* restore settings */
+	gc2235_res = gc2235_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	return gc2235_write_reg_array(client, gc2235_init_settings);
+}
+
+static int gc2235_init(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+	ret = __gc2235_init(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
+	usleep_range(5000, 6000);
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+	usleep_range(5000, 6000);
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_power;
+	}
+
+	msleep(50);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int gc2235_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return gc2235_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct gc2235_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct gc2235_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &gc2235_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != gc2235_res[i].width)
+			continue;
+		if (h != gc2235_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int gc2235_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+					fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = gc2235_res[N_RES - 1].width;
+		fmt->height = gc2235_res[N_RES - 1].height;
+	} else {
+		fmt->width = gc2235_res[idx].width;
+		fmt->height = gc2235_res[idx].height;
+	}
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int startup(struct v4l2_subdev *sd)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	ret = gc2235_write_reg_array(client, gc2235_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 write register err.\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int gc2235_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *gc2235_info = NULL;
+	int ret = 0;
+
+	gc2235_info = v4l2_get_subdev_hostdata(sd);
+	if (gc2235_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = gc2235_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width,
+					      fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	ret = startup(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 startup err\n");
+		goto err;
+	}
+
+	ret = gc2235_get_intg_factor(client, gc2235_info,
+					&gc2235_res[dev->fmt_idx]);
+	if (ret)
+		dev_err(&client->dev, "failed to get integration_factor\n");
+
+err:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int gc2235_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = gc2235_res[dev->fmt_idx].width;
+	fmt->height = gc2235_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int gc2235_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 high, low;
+	int ret;
+	u16 id;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_SENSOR_ID_H, &high);
+	if (ret) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", high);
+		return -ENODEV;
+	}
+	ret = gc2235_read_reg(client, GC2235_8BIT,
+					GC2235_SENSOR_ID_L, &low);
+	id = ((((u16) high) << 8) | (u16) low);
+
+	if (id != GC2235_ID) {
+		dev_err(&client->dev, "sensor ID error, 0x%x\n", id);
+		return -ENODEV;
+	}
+
+	dev_dbg(&client->dev, "detect gc2235 success\n");
+	return 0;
+}
+
+static int gc2235_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	if (enable)
+		ret = gc2235_write_reg_array(client, gc2235_stream_on);
+	else
+		ret = gc2235_write_reg_array(client, gc2235_stream_off);
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+/* gc2235 enum frame size, frame intervals */
+static int gc2235_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = gc2235_res[index].width;
+	fsize->discrete.height = gc2235_res[index].height;
+	fsize->reserved[0] = gc2235_res[index].used;
+
+	return 0;
+}
+
+static int gc2235_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = gc2235_res[index].width;
+	fival->height = gc2235_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = gc2235_res[index].fps;
+
+	return 0;
+}
+
+static int gc2235_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int gc2235_s_config(struct v4l2_subdev *sd,
+			   int irq, void *platform_data)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	dev->platform_data =
+		(struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "platform init err\n");
+			goto platform_init_failed;
+		}
+	}
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 power-off err.\n");
+		goto fail_power_off;
+	}
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 power-up err.\n");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = gc2235_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "gc2235_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "gc2235 power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+platform_init_failed:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int gc2235_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			gc2235_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int gc2235_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		gc2235_res = gc2235_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		gc2235_res = gc2235_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		gc2235_res = gc2235_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int gc2235_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = gc2235_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int gc2235_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int gc2235_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = gc2235_res[index].width;
+	fse->min_height = gc2235_res[index].height;
+	fse->max_width = gc2235_res[index].width;
+	fse->max_height = gc2235_res[index].height;
+
+	return 0;
+
+}
+
+static struct v4l2_mbus_framefmt *
+__gc2235_get_pad_format(struct gc2235_device *sensor,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+			"__gc2235_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int gc2235_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct gc2235_device *snr = to_gc2235_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__gc2235_get_pad_format(snr, fh, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int gc2235_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct gc2235_device *snr = to_gc2235_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int gc2235_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = gc2235_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops gc2235_sensor_ops = {
+	.g_skip_frames	= gc2235_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops gc2235_video_ops = {
+	.s_stream = gc2235_s_stream,
+	.g_parm = gc2235_g_parm,
+	.s_parm = gc2235_s_parm,
+	.enum_framesizes = gc2235_enum_framesizes,
+	.enum_frameintervals = gc2235_enum_frameintervals,
+	.enum_mbus_fmt = gc2235_enum_mbus_fmt,
+	.try_mbus_fmt = gc2235_try_mbus_fmt,
+	.g_mbus_fmt = gc2235_g_mbus_fmt,
+	.s_mbus_fmt = gc2235_s_mbus_fmt,
+	.g_frame_interval = gc2235_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops gc2235_core_ops = {
+	.s_power = gc2235_s_power,
+	.queryctrl = gc2235_queryctrl,
+	.g_ctrl = gc2235_g_ctrl,
+	.s_ctrl = gc2235_s_ctrl,
+	.ioctl = gc2235_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops gc2235_pad_ops = {
+	.enum_mbus_code = gc2235_enum_mbus_code,
+	.enum_frame_size = gc2235_enum_frame_size,
+	.get_fmt = gc2235_get_pad_format,
+	.set_fmt = gc2235_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops gc2235_ops = {
+	.core = &gc2235_core_ops,
+	.video = &gc2235_video_ops,
+	.pad = &gc2235_pad_ops,
+	.sensor = &gc2235_sensor_ops,
+};
+
+static int gc2235_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct gc2235_device *dev = to_gc2235_sensor(sd);
+	dev_dbg(&client->dev, "gc2235_remove...\n");
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int gc2235_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct gc2235_device *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &gc2235_ops);
+
+	if (client->dev.platform_data) {
+		ret = gc2235_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		gc2235_remove(client);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, gc2235_id);
+static struct i2c_driver gc2235_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = GC2235_NAME,
+	},
+	.probe = gc2235_probe,
+	.remove = gc2235_remove,
+	.id_table = gc2235_id,
+};
+
+static int init_gc2235(void)
+{
+	return i2c_add_driver(&gc2235_driver);
+}
+
+static void exit_gc2235(void)
+{
+
+	i2c_del_driver(&gc2235_driver);
+}
+
+module_init(init_gc2235);
+module_exit(exit_gc2235);
+
+MODULE_AUTHOR("Shuguang Gong <Shuguang.Gong@intel.com>");
+MODULE_DESCRIPTION("A low-level driver for GC2235 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
new file mode 100644
index 0000000..3e7ee62
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/gc2235.h
@@ -0,0 +1,556 @@
+/*
+ * Support for GalaxyCore GC2235 2M camera sensor.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __GC2235_H__
+#define __GC2235_H__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+
+#include <linux/atomisp_platform.h>
+
+#define GC2235_NAME		"gc2235"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		0x2
+#define I2C_RETRY_COUNT		5
+
+#define GC2235_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define GC2235_FOCAL_LENGTH_DEM	100
+#define GC2235_F_NUMBER_DEFAULT_NUM	26
+#define GC2235_F_NUMBER_DEM	10
+
+#define MAX_FMTS		1
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC2235_FOCAL_LENGTH_DEFAULT 0x1160064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define GC2235_F_NUMBER_DEFAULT 0x1a000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define GC2235_F_NUMBER_RANGE 0x1a0a1a0a
+#define GC2235_ID	0x2235
+
+#define GC2235_FINE_INTG_TIME_MIN 0
+#define GC2235_FINE_INTG_TIME_MAX_MARGIN 0
+#define GC2235_COARSE_INTG_TIME_MIN 1
+#define GC2235_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
+
+/*
+ * GC2235 System control registers
+ */
+/*
+ * GC2235 System control registers
+ */
+#define GC2235_SENSOR_ID_H		0xF0
+#define GC2235_SENSOR_ID_L		0xF1
+#define GC2235_RESET_RELATED		0xFE
+#define GC2235_SW_RESET			0x8
+#define GC2235_MIPI_RESET		0x3
+#define GC2235_RESET_BIT		0x4
+#define GC2235_REGISTER_PAGE_0		0x0
+#define GC2235_REGISTER_PAGE_3		0x3
+
+#define GC2235_V_CROP_START_H		0x91
+#define GC2235_V_CROP_START_L		0x92
+#define GC2235_H_CROP_START_H		0x93
+#define GC2235_H_CROP_START_L		0x94
+#define GC2235_V_OUTSIZE_H		0x95
+#define GC2235_V_OUTSIZE_L		0x96
+#define GC2235_H_OUTSIZE_H 		0x97
+#define GC2235_H_OUTSIZE_L 		0x98
+
+#define GC2235_HB_H			0x5
+#define GC2235_HB_L			0x6
+#define GC2235_VB_H			0x7
+#define GC2235_VB_L			0x8
+#define GC2235_SH_DELAY_H		0x11
+#define GC2235_SH_DELAY_L		0x12
+
+#define GC2235_CSI2_MODE		0x10
+
+#define GC2235_EXPOSURE_H		0x3
+#define GC2235_EXPOSURE_L		0x4
+#define GC2235_GLOBAL_GAIN		0xB0
+#define GC2235_PRE_GAIN			0xB1
+#define GC2235_AWB_R_GAIN		0xB3
+#define GC2235_AWB_G_GAIN		0xB4
+#define GC2235_AWB_B_GAIN		0xB5
+
+#define GC2235_START_STREAMING		0x91
+#define GC2235_STOP_STREAMING		0x0
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct gc2235_resolution {
+	u8 *desc;
+	const struct gc2235_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u32 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+};
+
+struct gc2235_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct gc2235_reg *regs;
+};
+
+struct gc2235_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * gc2235 device structure.
+ */
+struct gc2235_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u8 res;
+	u8 type;
+};
+
+enum gc2235_tok_type {
+	GC2235_8BIT  = 0x0001,
+	GC2235_16BIT = 0x0002,
+	GC2235_32BIT = 0x0004,
+	GC2235_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	GC2235_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	GC2235_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct gc2235_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 8-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct gc2235_reg {
+	enum gc2235_tok_type type;
+	u8 reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_gc2235_sensor(x) container_of(x, struct gc2235_device, sd)
+
+#define GC2235_MAX_WRITE_BUF_SIZE	30
+
+struct gc2235_write_buffer {
+	u8 addr;
+	u8 data[GC2235_MAX_WRITE_BUF_SIZE];
+};
+
+struct gc2235_write_ctrl {
+	int index;
+	struct gc2235_write_buffer buffer;
+};
+
+static const struct i2c_device_id gc2235_id[] = {
+	{GC2235_NAME, 0},
+	{}
+};
+
+static struct gc2235_reg const gc2235_stream_on[] = {
+	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
+	{ GC2235_8BIT, 0x10, 0x91}, /* start mipi */
+	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
+
+static struct gc2235_reg const gc2235_stream_off[] = {
+	{ GC2235_8BIT, 0xfe, 0x03}, /* switch to P3 */
+	{ GC2235_8BIT, 0x10, 0x81}, /* stop mipi */
+	{ GC2235_8BIT, 0xfe, 0x00}, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
+
+static struct gc2235_reg const gc2235_init_settings[] = {
+	/* Sysytem */
+	{ GC2235_8BIT, 0xfe, 0x80 },
+	{ GC2235_8BIT, 0xfe, 0x80 },
+	{ GC2235_8BIT, 0xfe, 0x80 },
+	{ GC2235_8BIT, 0xf2, 0x00 },
+	{ GC2235_8BIT, 0xf6, 0x00 },
+	{ GC2235_8BIT, 0xfc, 0x06 },
+	{ GC2235_8BIT, 0xf7, 0x15 },
+	{ GC2235_8BIT, 0xf8, 0x85 },
+	{ GC2235_8BIT, 0xf9, 0xfe },
+	{ GC2235_8BIT, 0xfa, 0x00 },
+	{ GC2235_8BIT, 0xfe, 0x00 },
+	/* Analog & cisctl */
+	{ GC2235_8BIT, 0x03, 0x04 },
+	{ GC2235_8BIT, 0x04, 0x9e },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x06, 0xf4 },
+	{ GC2235_8BIT, 0x07, 0x00 },
+	{ GC2235_8BIT, 0x08, 0x88 },
+	{ GC2235_8BIT, 0x0a, 0x00 }, /* row start */
+	{ GC2235_8BIT, 0x0c, 0x00 }, /* col start */
+	{ GC2235_8BIT, 0x0d, 0x04 }, /* win height 1232 */
+	{ GC2235_8BIT, 0x0e, 0xd0 },
+	{ GC2235_8BIT, 0x0f, 0x06 }, /* win width: 1616 */
+	{ GC2235_8BIT, 0x10, 0x60 },
+	{ GC2235_8BIT, 0x17, 0x15 }, /* mirror flip */
+	{ GC2235_8BIT, 0x18, 0x12 },
+	{ GC2235_8BIT, 0x19, 0x06 },
+	{ GC2235_8BIT, 0x1a, 0x01 },
+	{ GC2235_8BIT, 0x1b, 0x4d },
+	{ GC2235_8BIT, 0x1e, 0x88 },
+	{ GC2235_8BIT, 0x1f, 0x48 },
+	{ GC2235_8BIT, 0x20, 0x03 },
+	{ GC2235_8BIT, 0x21, 0x7f },
+	{ GC2235_8BIT, 0x22, 0x83 },
+	{ GC2235_8BIT, 0x23, 0x42 },
+	{ GC2235_8BIT, 0x24, 0x16 },
+	{ GC2235_8BIT, 0x26, 0x01 }, /*analog gain*/
+	{ GC2235_8BIT, 0x27, 0x30 },
+	{ GC2235_8BIT, 0x3f, 0x00 }, /* PRC */
+	/* blk */
+	{ GC2235_8BIT, 0x40, 0x03 },
+	{ GC2235_8BIT, 0x41, 0x00 },
+	{ GC2235_8BIT, 0x43, 0x20 },
+	{ GC2235_8BIT, 0x5e, 0x00 },
+	{ GC2235_8BIT, 0x5f, 0x00 },
+	{ GC2235_8BIT, 0x60, 0x00 },
+	{ GC2235_8BIT, 0x61, 0x00 },
+	{ GC2235_8BIT, 0x62, 0x00 },
+	{ GC2235_8BIT, 0x63, 0x00 },
+	{ GC2235_8BIT, 0x64, 0x00 },
+	{ GC2235_8BIT, 0x65, 0x00 },
+	{ GC2235_8BIT, 0x66, 0x20 },
+	{ GC2235_8BIT, 0x67, 0x20 },
+	{ GC2235_8BIT, 0x68, 0x20 },
+	{ GC2235_8BIT, 0x69, 0x20 },
+	/* Gain */
+	{ GC2235_8BIT, 0xb2, 0x00 },
+	{ GC2235_8BIT, 0xb3, 0x40 },
+	{ GC2235_8BIT, 0xb4, 0x40 },
+	{ GC2235_8BIT, 0xb5, 0x40 },
+	/* Dark sun */
+	{ GC2235_8BIT, 0xbc, 0x00 },
+
+	{ GC2235_8BIT, 0xfe, 0x03 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
+/*
+ * Register settings for various resolution
+ */
+static struct gc2235_reg const gc2235_1616_916_30fps[] = {
+	{ GC2235_8BIT, 0x8b, 0xa0 },
+	{ GC2235_8BIT, 0x8c, 0x02 },
+	{ GC2235_8BIT, 0x90, 0x01 },
+	{ GC2235_8BIT, 0x92, 0x96 },
+	{ GC2235_8BIT, 0x94, 0x00 },
+	{ GC2235_8BIT, 0x95, 0x03 }, /* crop win height 900 */
+	{ GC2235_8BIT, 0x96, 0x94 },
+	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1600 */
+	{ GC2235_8BIT, 0x98, 0x50 },
+	/* mimi init */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x01, 0x07 },
+	{ GC2235_8BIT, 0x02, 0x11 },
+	{ GC2235_8BIT, 0x03, 0x11 },
+	{ GC2235_8BIT, 0x06, 0x80 },
+	{ GC2235_8BIT, 0x11, 0x2b },
+	/* set mipi buffer */
+	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
+	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
+
+	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
+	{ GC2235_8BIT, 0x04, 0x20 },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x17, 0x01 },
+	{ GC2235_8BIT, 0x21, 0x01 },
+	{ GC2235_8BIT, 0x22, 0x02 },
+	{ GC2235_8BIT, 0x23, 0x01 },
+	{ GC2235_8BIT, 0x29, 0x02 },
+	{ GC2235_8BIT, 0x2a, 0x01 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
+
+static struct gc2235_reg const gc2235_1616_1082_30fps[] = {
+	{ GC2235_8BIT, 0x8b, 0xa0 },
+	{ GC2235_8BIT, 0x8c, 0x02 },
+	{ GC2235_8BIT, 0x90, 0x01 },
+	{ GC2235_8BIT, 0x92, 0x4a },
+	{ GC2235_8BIT, 0x94, 0x00 },
+	{ GC2235_8BIT, 0x95, 0x04 }, /* crop win height 1082 */
+	{ GC2235_8BIT, 0x96, 0x3a },
+	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1616 */
+	{ GC2235_8BIT, 0x98, 0x50 },
+	/* mimi init */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x01, 0x07 },
+	{ GC2235_8BIT, 0x02, 0x11 },
+	{ GC2235_8BIT, 0x03, 0x11 },
+	{ GC2235_8BIT, 0x06, 0x80 },
+	{ GC2235_8BIT, 0x11, 0x2b },
+	/* set mipi buffer */
+	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
+	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
+
+	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
+	{ GC2235_8BIT, 0x04, 0x20 },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x17, 0x01 },
+	{ GC2235_8BIT, 0x21, 0x01 },
+	{ GC2235_8BIT, 0x22, 0x02 },
+	{ GC2235_8BIT, 0x23, 0x01 },
+	{ GC2235_8BIT, 0x29, 0x02 },
+	{ GC2235_8BIT, 0x2a, 0x01 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
+
+static struct gc2235_reg const gc2235_1616_1216_30fps[] = {
+	{ GC2235_8BIT, 0x8b, 0xa0 },
+	{ GC2235_8BIT, 0x8c, 0x02 },
+	{ GC2235_8BIT, 0x90, 0x01 },
+	{ GC2235_8BIT, 0x92, 0x02 },
+	{ GC2235_8BIT, 0x94, 0x00 },
+	{ GC2235_8BIT, 0x95, 0x04 }, /* crop win height 1216 */
+	{ GC2235_8BIT, 0x96, 0xc0 },
+	{ GC2235_8BIT, 0x97, 0x06 }, /* crop win width 1616 */
+	{ GC2235_8BIT, 0x98, 0x50 },
+	/* mimi init */
+	{ GC2235_8BIT, 0xfe, 0x03 }, /* switch to P3 */
+	{ GC2235_8BIT, 0x01, 0x07 },
+	{ GC2235_8BIT, 0x02, 0x11 },
+	{ GC2235_8BIT, 0x03, 0x11 },
+	{ GC2235_8BIT, 0x06, 0x80 },
+	{ GC2235_8BIT, 0x11, 0x2b },
+	/* set mipi buffer */
+	{ GC2235_8BIT, 0x12, 0xe4 }, /* val_low = (width * 10 / 8) & 0xFF */
+	{ GC2235_8BIT, 0x13, 0x07 }, /* val_high = (width * 10 / 8) >> 8 */
+
+	{ GC2235_8BIT, 0x15, 0x12 }, /* DPHY mode*/
+	{ GC2235_8BIT, 0x04, 0x20 },
+	{ GC2235_8BIT, 0x05, 0x00 },
+	{ GC2235_8BIT, 0x17, 0x01 },
+	{ GC2235_8BIT, 0x21, 0x01 },
+	{ GC2235_8BIT, 0x22, 0x02 },
+	{ GC2235_8BIT, 0x23, 0x01 },
+	{ GC2235_8BIT, 0x29, 0x02 },
+	{ GC2235_8BIT, 0x2a, 0x01 },
+	{ GC2235_8BIT, 0x10, 0x81 }, /* disable mipi */
+	{ GC2235_8BIT, 0xfe, 0x00 }, /* switch to P0 */
+	{ GC2235_TOK_TERM, 0, 0 }
+};
+
+struct gc2235_resolution gc2235_res_preview[] = {
+	{
+		.desc = "gc2235_1600_900_30fps",
+		.width = 1616,
+		.height = 916,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 932,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_916_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1066_30fps",
+		.width = 1616,
+		.height = 1082,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1098,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1082_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1200_30fps",
+		.width = 1616,
+		.height = 1216,
+		.pix_clk_freq = 75,
+		.fps = 27,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1232,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1216_30fps,
+	},
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(gc2235_res_preview))
+
+struct gc2235_resolution gc2235_res_still[] = {
+	{
+		.desc = "gc2235_1600_900_30fps",
+		.width = 1616,
+		.height = 916,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 932,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_916_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1066_30fps",
+		.width = 1616,
+		.height = 1082,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1098,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1082_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1200_30fps",
+		.width = 1616,
+		.height = 1216,
+		.pix_clk_freq = 75,
+		.fps = 27,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1232,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1216_30fps,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(gc2235_res_still))
+
+struct gc2235_resolution gc2235_res_video[] = {
+	{
+		.desc = "gc2235_1600_900_30fps",
+		.width = 1616,
+		.height = 916,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 932,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_916_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1066_30fps",
+		.width = 1616,
+		.height = 1082,
+		.pix_clk_freq = 75,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1098,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1082_30fps,
+	},
+	{
+		.desc = "gc2235_1600_1200_30fps",
+		.width = 1616,
+		.height = 1216,
+		.pix_clk_freq = 75,
+		.fps = 27,
+		.used = 0,
+		.pixels_per_line = 1616,
+		.lines_per_frame = 1232,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = gc2235_1616_1216_30fps,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(gc2235_res_video))
+
+static struct gc2235_resolution *gc2235_res = gc2235_res_preview;
+static int N_RES = N_RES_PREVIEW;
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/imx/Kconfig
new file mode 100644
index 0000000..9134ead
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/Kconfig
@@ -0,0 +1,9 @@
+config VIDEO_IMX
+	tristate "sony imx sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_MSRLIST_HELPER
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Sony
+	  IMX RAW sensor.
+
+	  It currently depends on internal V4L2 extensions defined in
+	  atomisp driver.
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile
new file mode 100644
index 0000000..12fabd6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_VIDEO_IMX) += imx1x5.o
+
+imx1x5-objs := imx.o drv201.o ad5816g.o dw9714.o dw9719.o vcm.o otp.o otp_imx.o otp_e2prom.o
+
+ccflags-y += -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
new file mode 100644
index 0000000..fdd0ebe
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.c
@@ -0,0 +1,226 @@
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+
+#include "ad5816g.h"
+
+struct ad5816g_device ad5816g_dev;
+
+static int ad5816g_i2c_rd8(struct i2c_client *client, u8 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = 0;
+
+	msg[0].addr = AD5816G_VCM_ADDR;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = &buf[0];
+
+	msg[1].addr = AD5816G_VCM_ADDR;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = &buf[1];
+	*val = 0;
+	if (i2c_transfer(client->adapter, msg, 2) != 2)
+		return -EIO;
+	*val = buf[1];
+	return 0;
+}
+
+static int ad5816g_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct i2c_msg msg;
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = val;
+	msg.addr = AD5816G_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = &buf[0];
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+	return 0;
+}
+
+static int ad5816g_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
+{
+	struct i2c_msg msg;
+	u8 buf[3];
+	buf[0] = reg;
+	buf[1] = (u8)(val >> 8);
+	buf[2] = (u8)(val & 0xff);
+	msg.addr = AD5816G_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 3;
+	msg.buf = &buf[0];
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+	return 0;
+}
+
+static int ad5816g_set_arc_mode(struct i2c_client *client)
+{
+	int ret;
+
+	ret = ad5816g_i2c_wr8(client, AD5816G_CONTROL, AD5816G_ARC_EN);
+	if (ret)
+		return ret;
+
+	ret = ad5816g_i2c_wr8(client, AD5816G_MODE,
+				AD5816G_MODE_2_5M_SWITCH_CLOCK);
+	if (ret)
+		return ret;
+
+	ret = ad5816g_i2c_wr8(client, AD5816G_VCM_FREQ, AD5816G_DEF_FREQ);
+	return ret;
+}
+
+int ad5816g_vcm_power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 ad5816g_id;
+
+	/* Enable power */
+	ret = ad5816g_dev.platform_data->power_ctrl(sd, 1);
+	if (ret)
+		return ret;
+	/* waiting time AD5816G(vcm) - t1 + t2
+	  * t1(1ms) -Time from VDD high to first i2c cmd
+	  * t2(100us) - exit power-down mode time
+	  */
+	usleep_range(1100, 1100);
+	/* Detect device */
+	ret = ad5816g_i2c_rd8(client, AD5816G_IC_INFO, &ad5816g_id);
+	if (ret < 0)
+		goto fail_powerdown;
+	if (ad5816g_id != AD5816G_ID) {
+		ret = -ENXIO;
+		goto fail_powerdown;
+	}
+	ret = ad5816g_set_arc_mode(client);
+	if (ret)
+		return ret;
+
+	/* set the VCM_THRESHOLD */
+	ret = ad5816g_i2c_wr8(client, AD5816G_VCM_THRESHOLD,
+		AD5816G_DEF_THRESHOLD);
+
+	return ret;
+
+fail_powerdown:
+	ad5816g_dev.platform_data->power_ctrl(sd, 0);
+	return ret;
+}
+
+int ad5816g_vcm_power_down(struct v4l2_subdev *sd)
+{
+	return ad5816g_dev.platform_data->power_ctrl(sd, 0);
+}
+
+
+int ad5816g_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 data = val & VCM_CODE_MASK;
+
+	return ad5816g_i2c_wr16(client, AD5816G_VCM_CODE_MSB, data);
+}
+
+int ad5816g_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	int ret;
+
+	value = clamp(value, 0, AD5816G_MAX_FOCUS_POS);
+	ret = ad5816g_t_focus_vcm(sd, value);
+	if (ret == 0) {
+		ad5816g_dev.number_of_steps = value - ad5816g_dev.focus;
+		ad5816g_dev.focus = value;
+		getnstimeofday(&(ad5816g_dev.timestamp_t_focus_abs));
+	}
+
+	return ret;
+}
+
+int ad5816g_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+
+	return ad5816g_t_focus_abs(sd, ad5816g_dev.focus + value);
+}
+
+int ad5816g_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 status = 0;
+	struct timespec temptime;
+	const struct timespec timedelay = {
+		0,
+		min_t(u32, abs(ad5816g_dev.number_of_steps) * DELAY_PER_STEP_NS,
+			DELAY_MAX_PER_STEP_NS),
+	};
+
+	ktime_get_ts(&temptime);
+
+	temptime = timespec_sub(temptime, (ad5816g_dev.timestamp_t_focus_abs));
+
+	if (timespec_compare(&temptime, &timedelay) <= 0) {
+		status |= ATOMISP_FOCUS_STATUS_MOVING;
+		status |= ATOMISP_FOCUS_HP_IN_PROGRESS;
+	} else {
+		status |= ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+		status |= ATOMISP_FOCUS_HP_COMPLETE;
+	}
+	*value = status;
+
+	return 0;
+}
+
+int ad5816g_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	s32 val;
+
+	ad5816g_q_focus_status(sd, &val);
+
+	if (val & ATOMISP_FOCUS_STATUS_MOVING)
+		*value  = ad5816g_dev.focus - ad5816g_dev.number_of_steps;
+	else
+		*value  = ad5816g_dev.focus ;
+
+	return 0;
+}
+
+int ad5816g_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int ad5816g_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int ad5816g_vcm_init(struct v4l2_subdev *sd)
+{
+	ad5816g_dev.platform_data = camera_get_af_platform_data();
+	return (NULL == ad5816g_dev.platform_data) ? -ENODEV : 0;
+
+}
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.h
new file mode 100644
index 0000000..7410628
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/ad5816g.h
@@ -0,0 +1,49 @@
+#ifndef __AD5816G_H__
+#define __AD5816G_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+#include <linux/time.h>
+
+#define AD5816G_VCM_ADDR	0x0e
+
+/* ad5816g device structure */
+struct ad5816g_device {
+	const struct camera_af_platform_data *platform_data;
+	struct timespec timestamp_t_focus_abs;
+	struct timespec focus_time;	/* Time when focus was last time set */
+	s32 focus;			/* Current focus value */
+	s16 number_of_steps;
+};
+
+#define AD5816G_INVALID_CONFIG	0xffffffff
+#define AD5816G_MAX_FOCUS_POS	1023
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+
+/* Register Definitions */
+#define AD5816G_IC_INFO			0x00
+#define AD5816G_IC_VERSION		0x01
+#define AD5816G_CONTROL			0x02
+#define AD5816G_VCM_CODE_MSB	0x03
+#define AD5816G_VCM_CODE_LSB	0x04
+#define AD5816G_STATUS			0x05
+#define AD5816G_MODE			0x06
+#define AD5816G_VCM_FREQ		0x07
+#define AD5816G_VCM_THRESHOLD	0x08
+
+/* ARC MODE ENABLE */
+#define AD5816G_ARC_EN			0x02
+/* ARC RES2 MODE */
+#define AD5816G_ARC_RES2			0x01
+/* ARC VCM FREQ - 78.1Hz */
+#define AD5816G_DEF_FREQ			0x7a
+/* ARC VCM THRESHOLD - 0x08 << 1 */
+#define AD5816G_DEF_THRESHOLD		0x64
+#define AD5816G_ID			0x24
+#define VCM_CODE_MASK	0x03ff
+
+#define AD5816G_MODE_2_5M_SWITCH_CLOCK	0x14
+
+#endif
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/common.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/common.h
new file mode 100644
index 0000000..7e525ce
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/common.h
@@ -0,0 +1,65 @@
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+#define MAX_FPS_OPTIONS_SUPPORTED	3
+#define I2C_MSG_LENGTH		0x2
+#define E2PROM_2ADDR 0x80000000
+#define E2PROM_ADDR_MASK 0x7fffffff
+
+/* Defines for register writes and register array processing */
+#define IMX_BYTE_MAX	32
+#define IMX_SHORT_MAX	16
+#define I2C_RETRY_COUNT		5
+#define IMX_TOK_MASK	0xfff0
+
+enum imx_tok_type {
+	IMX_8BIT  = 0x0001,
+	IMX_16BIT = 0x0002,
+	IMX_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	IMX_TOK_DELAY  = 0xfe00	/* delay token for reg list */
+};
+
+/**
+ * struct imx_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct imx_reg {
+	enum imx_tok_type type;
+	u16 sreg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+struct imx_fps_setting {
+	int fps;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	int mipi_freq;			/* MIPI lane frequency in kHz */
+	const struct imx_reg *regs; /* regs that the fps setting needs */
+};
+
+struct imx_resolution {
+	const struct imx_fps_setting fps_options[MAX_FPS_OPTIONS_SUPPORTED];
+	u8 *desc;
+	const struct imx_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	int mipi_freq;			/* MIPI lane frequency in kHz */
+	unsigned short skip_frames;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	bool used;
+};
+
+#define GROUPED_PARAMETER_HOLD_ENABLE  {IMX_8BIT, 0x0104, 0x1}
+#define GROUPED_PARAMETER_HOLD_DISABLE  {IMX_8BIT, 0x0104, 0x0}
+
+int imx_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val);
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
new file mode 100644
index 0000000..fa74749
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.c
@@ -0,0 +1,219 @@
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <asm/intel-mid.h>
+
+#include "drv201.h"
+
+static struct drv201_device drv201_dev;
+
+static int drv201_i2c_rd8(struct i2c_client *client, u8 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = 0;
+
+	msg[0].addr = DRV201_VCM_ADDR;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = &buf[0];
+
+	msg[1].addr = DRV201_VCM_ADDR;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = &buf[1];
+	*val = 0;
+	if (i2c_transfer(client->adapter, msg, 2) != 2)
+		return -EIO;
+	*val = buf[1];
+	return 0;
+}
+
+static int drv201_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct i2c_msg msg;
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = val;
+	msg.addr = DRV201_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = &buf[0];
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+	return 0;
+}
+
+static int drv201_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
+{
+	struct i2c_msg msg;
+	u8 buf[3];
+	buf[0] = reg;
+	buf[1] = (u8)(val >> 8);
+	buf[2] = (u8)(val & 0xff);
+	msg.addr = DRV201_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 3;
+	msg.buf = &buf[0];
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+	return 0;
+}
+
+int drv201_vcm_power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 value;
+
+	/* Enable power */
+	ret = drv201_dev.platform_data->power_ctrl(sd, 1);
+	if (ret)
+		return ret;
+	/* Wait for VBAT to stabilize */
+	udelay(1);
+	/*
+	 * Jiggle SCL pin to wake up device.
+	 * Drv201 expect SCL from low to high to wake device up.
+	 * So the 1st access to i2c would fail.
+	 * Using following function to wake device up.
+	 */
+	drv201_i2c_wr8(client, DRV201_CONTROL, DRV201_RESET);
+
+	/* Need 100us to transit from SHUTDOWN to STANDBY*/
+	usleep_range(WAKEUP_DELAY_US, WAKEUP_DELAY_US * 10);
+
+	/* Reset device */
+	ret = drv201_i2c_wr8(client, DRV201_CONTROL, DRV201_RESET);
+	if (ret < 0)
+		goto fail_powerdown;
+
+	/* Detect device */
+	ret = drv201_i2c_rd8(client, DRV201_CONTROL, &value);
+	if (ret < 0)
+		goto fail_powerdown;
+	if (value != DEFAULT_CONTROL_VAL) {
+		ret = -ENXIO;
+		goto fail_powerdown;
+	}
+
+	drv201_dev.focus = DRV201_MAX_FOCUS_POS;
+	drv201_dev.initialized = true;
+
+	return 0;
+fail_powerdown:
+	drv201_dev.platform_data->power_ctrl(sd, 0);
+	return ret;
+}
+
+int drv201_vcm_power_down(struct v4l2_subdev *sd)
+{
+	return drv201_dev.platform_data->power_ctrl(sd, 0);
+}
+
+
+int drv201_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 data = val & VCM_CODE_MASK;
+
+	if (!drv201_dev.initialized)
+		return -ENODEV;
+	return drv201_i2c_wr16(client, DRV201_VCM_CURRENT, data);
+}
+
+int drv201_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	int ret;
+
+	value = clamp(value, 0, DRV201_MAX_FOCUS_POS);
+	ret = drv201_t_focus_vcm(sd, value);
+	if (ret == 0) {
+		drv201_dev.number_of_steps = value - drv201_dev.focus;
+		drv201_dev.focus = value;
+		getnstimeofday(&(drv201_dev.timestamp_t_focus_abs));
+	}
+
+	return ret;
+}
+
+int drv201_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	return drv201_t_focus_abs(sd, drv201_dev.focus + value);
+}
+
+int drv201_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 status = 0;
+	struct timespec temptime;
+	const struct timespec timedelay = {
+		0,
+		min_t(u32, abs(drv201_dev.number_of_steps)*DELAY_PER_STEP_NS,
+			DELAY_MAX_PER_STEP_NS),
+	};
+
+	ktime_get_ts(&temptime);
+
+	temptime = timespec_sub(temptime, (drv201_dev.timestamp_t_focus_abs));
+
+	if (timespec_compare(&temptime, &timedelay) <= 0) {
+		status |= ATOMISP_FOCUS_STATUS_MOVING;
+		status |= ATOMISP_FOCUS_HP_IN_PROGRESS;
+	} else {
+		status |= ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+		status |= ATOMISP_FOCUS_HP_COMPLETE;
+	}
+	*value = status;
+
+	return 0;
+}
+
+int drv201_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	s32 val;
+
+	drv201_q_focus_status(sd, &val);
+
+	if (val & ATOMISP_FOCUS_STATUS_MOVING)
+		*value  = drv201_dev.focus - drv201_dev.number_of_steps;
+	else
+		*value  = drv201_dev.focus ;
+
+	return 0;
+}
+
+int drv201_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int drv201_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int drv201_vcm_init(struct v4l2_subdev *sd)
+{
+	drv201_dev.platform_data = camera_get_af_platform_data();
+	return (NULL == drv201_dev.platform_data) ? -ENODEV : 0;
+}
+
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.h
new file mode 100644
index 0000000..f5f5eec
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/drv201.h
@@ -0,0 +1,38 @@
+#ifndef __DRV201_H__
+#define __DRV201_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+#include <linux/time.h>
+
+#define DRV201_VCM_ADDR	0x0e
+
+/* drv201 device structure */
+struct drv201_device {
+	const struct camera_af_platform_data *platform_data;
+	struct timespec timestamp_t_focus_abs;
+	struct timespec focus_time;	/* Time when focus was last time set */
+	s32 focus;			/* Current focus value */
+	s16 number_of_steps;
+	bool initialized;		/* true if drv201 is detected */
+};
+
+#define DRV201_INVALID_CONFIG	0xffffffff
+#define DRV201_MAX_FOCUS_POS	1023
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+
+#define DRV201_CONTROL				2
+#define DRV201_VCM_CURRENT		3
+#define DRV201_STATUS				5
+#define DRV201_MODE				6
+#define DRV201_VCM_FREQ			7
+
+#define DEFAULT_CONTROL_VAL		2
+#define DRV201_RESET				1
+#define WAKEUP_DELAY_US			100
+#define VCM_CODE_MASK	0x03ff
+
+#endif
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
new file mode 100644
index 0000000..3cb72ee
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.c
@@ -0,0 +1,221 @@
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <asm/intel-mid.h>
+
+#include "dw9714.h"
+
+static struct dw9714_device dw9714_dev;
+static int dw9714_i2c_write(struct i2c_client *client, u16 data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	u16 val;
+
+	val = cpu_to_be16(data);
+	msg.addr = DW9714_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = DW9714_16BIT;
+	msg.buf = (u8 *)&val;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+int dw9714_vcm_power_up(struct v4l2_subdev *sd)
+{
+	int ret;
+
+	/* Enable power */
+	ret = dw9714_dev.platform_data->power_ctrl(sd, 1);
+	/* waiting time requested by DW9714A(vcm) */
+	usleep_range(12000, 12500);
+	return ret;
+}
+
+int dw9714_vcm_power_down(struct v4l2_subdev *sd)
+{
+	return dw9714_dev.platform_data->power_ctrl(sd, 0);
+}
+
+
+int dw9714_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = -EINVAL;
+	u8 mclk = vcm_step_mclk(dw9714_dev.vcm_settings.step_setting);
+	u8 s = vcm_step_s(dw9714_dev.vcm_settings.step_setting);
+
+	/*
+	 * For different mode, VCM_PROTECTION_OFF/ON required by the
+	 * control procedure. For DW9714_DIRECT/DLC mode, slew value is
+	 * VCM_DEFAULT_S(0).
+	 */
+	switch (dw9714_dev.vcm_mode) {
+	case DW9714_DIRECT:
+		if (dw9714_dev.vcm_settings.update) {
+			ret = dw9714_i2c_write(client, VCM_PROTECTION_OFF);
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client, DIRECT_VCM);
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client, VCM_PROTECTION_ON);
+			if (ret)
+				return ret;
+			dw9714_dev.vcm_settings.update = false;
+		}
+		ret = dw9714_i2c_write(client,
+					vcm_val(val, VCM_DEFAULT_S));
+		break;
+	case DW9714_LSC:
+		if (dw9714_dev.vcm_settings.update) {
+			ret = dw9714_i2c_write(client, VCM_PROTECTION_OFF);
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client,
+				vcm_dlc_mclk(DLC_DISABLE, mclk));
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client,
+				vcm_tsrc(dw9714_dev.vcm_settings.t_src));
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client, VCM_PROTECTION_ON);
+			if (ret)
+				return ret;
+			dw9714_dev.vcm_settings.update = false;
+		}
+		ret = dw9714_i2c_write(client, vcm_val(val, s));
+		break;
+	case DW9714_DLC:
+		if (dw9714_dev.vcm_settings.update) {
+			ret = dw9714_i2c_write(client, VCM_PROTECTION_OFF);
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client,
+					vcm_dlc_mclk(DLC_ENABLE, mclk));
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client,
+				vcm_tsrc(dw9714_dev.vcm_settings.t_src));
+			if (ret)
+				return ret;
+			ret = dw9714_i2c_write(client, VCM_PROTECTION_ON);
+			if (ret)
+				return ret;
+			dw9714_dev.vcm_settings.update = false;
+		}
+		ret = dw9714_i2c_write(client,
+					vcm_val(val, VCM_DEFAULT_S));
+		break;
+	}
+	return ret;
+}
+
+int dw9714_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	int ret;
+
+	value = clamp(value, 0, DW9714_MAX_FOCUS_POS);
+	ret = dw9714_t_focus_vcm(sd, value);
+	if (ret == 0) {
+		dw9714_dev.number_of_steps = value - dw9714_dev.focus;
+		dw9714_dev.focus = value;
+		getnstimeofday(&(dw9714_dev.timestamp_t_focus_abs));
+	}
+
+	return ret;
+}
+
+int dw9714_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+
+	return dw9714_t_focus_abs(sd, dw9714_dev.focus + value);
+}
+
+int dw9714_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 status = 0;
+	struct timespec temptime;
+	const struct timespec timedelay = {
+		0,
+		min_t(u32, abs(dw9714_dev.number_of_steps)*DELAY_PER_STEP_NS,
+			DELAY_MAX_PER_STEP_NS),
+	};
+
+	ktime_get_ts(&temptime);
+
+	temptime = timespec_sub(temptime, (dw9714_dev.timestamp_t_focus_abs));
+
+	if (timespec_compare(&temptime, &timedelay) <= 0) {
+		status |= ATOMISP_FOCUS_STATUS_MOVING;
+		status |= ATOMISP_FOCUS_HP_IN_PROGRESS;
+	} else {
+		status |= ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+		status |= ATOMISP_FOCUS_HP_COMPLETE;
+	}
+	*value = status;
+
+	return 0;
+}
+
+int dw9714_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	s32 val;
+
+	dw9714_q_focus_status(sd, &val);
+
+	if (val & ATOMISP_FOCUS_STATUS_MOVING)
+		*value  = dw9714_dev.focus - dw9714_dev.number_of_steps;
+	else
+		*value  = dw9714_dev.focus ;
+
+	return 0;
+}
+
+int dw9714_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	dw9714_dev.vcm_settings.step_setting = value;
+	dw9714_dev.vcm_settings.update = true;
+
+	return 0;
+}
+
+int dw9714_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	dw9714_dev.vcm_settings.t_src = value;
+	dw9714_dev.vcm_settings.update = true;
+
+	return 0;
+}
+
+int dw9714_vcm_init(struct v4l2_subdev *sd)
+{
+
+	/* set VCM to home position and vcm mode to direct*/
+	dw9714_dev.vcm_mode = DW9714_DIRECT;
+	dw9714_dev.vcm_settings.update = false;
+	dw9714_dev.platform_data = camera_get_af_platform_data();
+	return (NULL == dw9714_dev.platform_data) ? -ENODEV : 0;
+
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.h
new file mode 100644
index 0000000..972eed1
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9714.h
@@ -0,0 +1,62 @@
+#ifndef __DW9714_H__
+#define __DW9714_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+
+
+#define DW9714_VCM_ADDR	0x0c
+
+enum dw9714_tok_type {
+	DW9714_8BIT  = 0x0001,
+	DW9714_16BIT = 0x0002,
+};
+
+struct dw9714_vcm_settings {
+	u16 code;	/* bit[9:0]: Data[9:0] */
+	u8 t_src;	/* bit[4:0]: T_SRC[4:0] */
+	u8 step_setting;	/* bit[3:0]: S[3:0]/bit[5:4]: MCLK[1:0] */
+	bool update;
+};
+
+enum dw9714_vcm_mode {
+	DW9714_DIRECT = 0x1,	/* direct control */
+	DW9714_LSC = 0x2,	/* linear slope control */
+	DW9714_DLC = 0x3,	/* dual level control */
+};
+
+/* dw9714 device structure */
+struct dw9714_device {
+	struct dw9714_vcm_settings vcm_settings;
+	struct timespec timestamp_t_focus_abs;
+	enum dw9714_vcm_mode vcm_mode;
+	s16 number_of_steps;
+	bool initialized;		/* true if dw9714 is detected */
+	s32 focus;			/* Current focus value */
+	struct timespec focus_time;	/* Time when focus was last time set */
+	__u8 buffer[4];			/* Used for i2c transactions */
+	const struct camera_af_platform_data *platform_data;
+};
+
+#define DW9714_INVALID_CONFIG	0xffffffff
+#define DW9714_MAX_FOCUS_POS	1023
+
+
+/* MCLK[1:0] = 01 T_SRC[4:0] = 00001 S[3:0] = 0111 */
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+
+#define DLC_ENABLE 1
+#define DLC_DISABLE 0
+#define VCM_PROTECTION_OFF	0xeca3
+#define VCM_PROTECTION_ON	0xdc51
+#define VCM_DEFAULT_S 0x0
+
+#define vcm_step_s(a) (u8)(a & 0xf)
+#define vcm_step_mclk(a) (u8)((a >> 4) & 0x3)
+#define vcm_dlc_mclk(dlc, mclk) (u16)((dlc << 3) | mclk | 0xa104)
+#define vcm_tsrc(tsrc) (u16)(tsrc << 3 | 0xf200)
+#define vcm_val(data, s) (u16)(data << 4 | s)
+#define DIRECT_VCM vcm_dlc_mclk(0, 0)
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
new file mode 100644
index 0000000..1e59ccb
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.c
@@ -0,0 +1,175 @@
+/*
+ * Support for dw9718 vcm driver.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/delay.h>
+#include "dw9718.h"
+
+static struct dw9718_device dw9718_dev;
+
+static int dw9718_i2c_rd8(struct i2c_client *client, u8 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2] = { reg };
+
+	msg[0].addr = DW9718_VCM_ADDR;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = DW9718_VCM_ADDR;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = &buf[1];
+	*val = 0;
+
+	if (i2c_transfer(client->adapter, msg, 2) != 2)
+		return -EIO;
+	*val = buf[1];
+
+	return 0;
+}
+
+static int dw9718_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
+{
+	struct i2c_msg msg;
+	u8 buf[3] = { reg, (u8)(val >> 8), (u8)(val & 0xff)};
+
+	msg.addr = DW9718_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = sizeof(buf);
+	msg.buf = buf;
+
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+
+	return 0;
+}
+
+int dw9718_vcm_power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 value;
+
+	/* Enable power */
+	ret = dw9718_dev.platform_data->power_ctrl(sd, 1);
+	if (ret)
+		return ret;
+	/* Wait for VBAT to stabilize */
+	udelay(100);
+
+	/* Detect device */
+	ret = dw9718_i2c_rd8(client, DW9718_SACT, &value);
+	if (ret < 0)
+		goto fail_powerdown;
+	if (value != DW9718_SACT_DEFAULT_VAL) {
+		dev_err(&client->dev, "%s error, incorrect ID\n", __func__);
+		return -ENXIO;
+	}
+
+	dw9718_dev.focus = DW9718_MAX_FOCUS_POS;
+	dw9718_dev.initialized = true;
+
+	return 0;
+
+fail_powerdown:
+	dev_err(&client->dev, "%s error, detection failed\n", __func__);
+	dw9718_dev.platform_data->power_ctrl(sd, 0);
+	return ret;
+}
+
+int dw9718_vcm_power_down(struct v4l2_subdev *sd)
+{
+	return dw9718_dev.platform_data->power_ctrl(sd, 0);
+}
+
+int dw9718_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	static const struct timespec move_time = {
+		.tv_sec = 0,
+		.tv_nsec = 60000000
+	};
+	struct timespec current_time, finish_time, delta_time;
+
+	getnstimeofday(&current_time);
+	finish_time = timespec_add(dw9718_dev.focus_time, move_time);
+	delta_time = timespec_sub(current_time, finish_time);
+	if (delta_time.tv_sec >= 0 && delta_time.tv_nsec >= 0) {
+		*value = ATOMISP_FOCUS_HP_COMPLETE |
+			 ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+	} else {
+		*value = ATOMISP_FOCUS_STATUS_MOVING |
+			 ATOMISP_FOCUS_HP_IN_PROGRESS;
+	}
+
+	return 0;
+}
+
+int dw9718_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
+{
+	return -EINVAL;
+}
+
+int dw9718_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/*
+	 * TODO: Need to check here whether there is a need to test the
+	 * Flag bit (bit 0 or register 0x10) before writing the new
+	 * absolute vcm value */
+	value = clamp(value, 0, DW9718_MAX_FOCUS_POS);
+	ret = dw9718_i2c_wr16(client, DW9718_DATA_M, value);
+	if (ret < 0)
+		return ret;
+
+	getnstimeofday(&dw9718_dev.focus_time);
+	dw9718_dev.focus = value;
+
+	return 0;
+}
+
+int dw9718_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	return dw9718_t_focus_abs(sd, dw9718_dev.focus + value);
+}
+
+int dw9718_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	*value  = dw9718_dev.focus ;
+	return 0;
+}
+int dw9718_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int dw9718_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int dw9718_vcm_init(struct v4l2_subdev *sd)
+{
+	dw9718_dev.platform_data = camera_get_af_platform_data();
+	return (NULL == dw9718_dev.platform_data) ? -ENODEV : 0;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
new file mode 100644
index 0000000..5657dad
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9718.h
@@ -0,0 +1,54 @@
+/*
+ * Support for dw9719 vcm driver.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DW9718_H__
+#define __DW9718_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+
+#define DW9718_VCM_ADDR	 (0x18 >> 1)
+
+/* dw9718 device structure */
+struct dw9718_device {
+	struct timespec timestamp_t_focus_abs;
+	s16 number_of_steps;
+	bool initialized;		/* true if dw9718 is detected */
+	s32 focus;			/* Current focus value */
+	struct timespec focus_time;	/* Time when focus was last time set */
+	__u8 buffer[4];			/* Used for i2c transactions */
+	const struct camera_af_platform_data *platform_data;
+};
+
+#define DW9718_MAX_FOCUS_POS	1023
+
+/* Register addresses */
+#define DW9718_PD			0x00
+#define DW9718_CONTROL			0x01
+#define DW9718_DATA_M			0x02
+#define DW9718_DATA_L			0x03
+#define DW9718_SW			0x04
+#define DW9718_SACT			0x05
+#define DW9718_FLAG			0x10
+
+#define DW9718_SACT_DEFAULT_VAL 	0x60
+
+#endif /* __DW9718_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c
new file mode 100644
index 0000000..ce149f4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.c
@@ -0,0 +1,209 @@
+/*
+ * Support for dw9719 vcm driver.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/delay.h>
+#include "dw9719.h"
+
+static struct dw9719_device dw9719_dev;
+
+static int dw9719_i2c_rd8(struct i2c_client *client, u8 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2] = { reg };
+
+	msg[0].addr = DW9719_VCM_ADDR;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = DW9719_VCM_ADDR;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = &buf[1];
+	*val = 0;
+
+	if (i2c_transfer(client->adapter, msg, 2) != 2)
+		return -EIO;
+	*val = buf[1];
+
+	return 0;
+}
+
+static int dw9719_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct i2c_msg msg;
+	u8 buf[2] = { reg, val };
+
+	msg.addr = DW9719_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = sizeof(buf);
+	msg.buf = buf;
+
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+
+	return 0;
+}
+
+static int dw9719_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
+{
+	struct i2c_msg msg;
+	u8 buf[3] = { reg, (u8)(val >> 8), (u8)(val & 0xff)};
+
+	msg.addr = DW9719_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = sizeof(buf);
+	msg.buf = buf;
+
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+
+	return 0;
+}
+
+int dw9719_vcm_power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 value;
+
+	/* Enable power */
+	ret = dw9719_dev.platform_data->power_ctrl(sd, 1);
+	/* waiting time requested by DW9714A(vcm) */
+	if (ret)
+		return ret;
+	/* Wait for VBAT to stabilize */
+	udelay(1);
+
+	/*
+	 * Jiggle SCL pin to wake up device.
+	 */
+	ret = dw9719_i2c_wr8(client, DW9719_CONTROL, 1);
+	/* Need 100us to transit from SHUTDOWN to STANDBY*/
+	usleep_range(100, 1000);
+
+	/* Enable the ringing compensation */
+	ret = dw9719_i2c_wr8(client, DW9719_CONTROL, DW9719_ENABLE_RINGING);
+	if (ret < 0)
+		goto fail_powerdown;
+
+	/* Use SAC3 mode */
+	ret = dw9719_i2c_wr8(client, DW9719_MODE, DW9719_MODE_SAC3);
+	if (ret < 0)
+		goto fail_powerdown;
+
+	/* Set the resonance frequency */
+	ret = dw9719_i2c_wr8(client, DW9719_VCM_FREQ, DW9719_DEFAULT_VCM_FREQ);
+	if (ret < 0)
+		goto fail_powerdown;
+
+	/* Detect device */
+	ret = dw9719_i2c_rd8(client, DW9719_INFO, &value);
+	if (ret < 0)
+		goto fail_powerdown;
+	if (value != DW9719_ID) {
+		ret = -ENXIO;
+		goto fail_powerdown;
+	}
+	dw9719_dev.focus = 0;
+	dw9719_dev.initialized = true;
+
+	return 0;
+
+fail_powerdown:
+	dw9719_dev.platform_data->power_ctrl(sd, 0);
+	return ret;
+}
+
+int dw9719_vcm_power_down(struct v4l2_subdev *sd)
+{
+	return dw9719_dev.platform_data->power_ctrl(sd, 0);
+}
+
+int dw9719_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	static const struct timespec move_time = {
+
+		.tv_sec = 0,
+		.tv_nsec = 60000000
+	};
+	struct timespec current_time, finish_time, delta_time;
+
+	getnstimeofday(&current_time);
+	finish_time = timespec_add(dw9719_dev.focus_time, move_time);
+	delta_time = timespec_sub(current_time, finish_time);
+	if (delta_time.tv_sec >= 0 && delta_time.tv_nsec >= 0) {
+		*value = ATOMISP_FOCUS_HP_COMPLETE |
+			 ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+	} else {
+		*value = ATOMISP_FOCUS_STATUS_MOVING |
+			 ATOMISP_FOCUS_HP_IN_PROGRESS;
+	}
+
+	return 0;
+}
+
+int dw9719_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
+{
+	return -EINVAL;
+}
+
+int dw9719_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	value = clamp(value, 0, DW9719_MAX_FOCUS_POS);
+	ret = dw9719_i2c_wr16(client, DW9719_VCM_CURRENT, value);
+	if (ret < 0)
+		return ret;
+
+	getnstimeofday(&dw9719_dev.focus_time);
+	dw9719_dev.focus = value;
+
+	return 0;
+}
+
+int dw9719_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	return dw9719_t_focus_abs(sd, dw9719_dev.focus + value);
+}
+
+int dw9719_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	*value  = dw9719_dev.focus ;
+	return 0;
+}
+int dw9719_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int dw9719_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int dw9719_vcm_init(struct v4l2_subdev *sd)
+{
+	dw9719_dev.platform_data = camera_get_af_platform_data();
+	return (NULL == dw9719_dev.platform_data) ? -ENODEV : 0;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.h
new file mode 100644
index 0000000..cde6275
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/dw9719.h
@@ -0,0 +1,58 @@
+/*
+ * Support for dw9719 vcm driver.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __DW9719_H__
+#define __DW9719_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+
+#define DW9719_VCM_ADDR	 (0x18 >> 1)
+
+/* dw9719 device structure */
+struct dw9719_device {
+	struct timespec timestamp_t_focus_abs;
+	s16 number_of_steps;
+	bool initialized;		/* true if dw9719 is detected */
+	s32 focus;			/* Current focus value */
+	struct timespec focus_time;	/* Time when focus was last time set */
+	__u8 buffer[4];			/* Used for i2c transactions */
+	const struct camera_af_platform_data *platform_data;
+};
+
+#define DW9719_INVALID_CONFIG	0xffffffff
+#define DW9719_MAX_FOCUS_POS	1023
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+
+#define DW9719_INFO			0
+#define DW9719_ID			0xF1
+#define DW9719_CONTROL			2
+#define DW9719_VCM_CURRENT		3
+
+#define DW9719_MODE			6
+#define DW9719_VCM_FREQ			7
+
+#define DW9719_MODE_SAC3		0x40
+#define DW9719_DEFAULT_VCM_FREQ		0x04
+#define DW9719_ENABLE_RINGING		0x02
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
new file mode 100644
index 0000000..d0f1db7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.c
@@ -0,0 +1,2348 @@
+/*
+ * Support for Sony imx 8MP camera sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <asm/intel-mid.h>
+#include <linux/atomisp_platform.h>
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/libmsrlisthelper.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include "imx.h"
+
+
+static enum atomisp_bayer_order imx_bayer_order_mapping[] = {
+	atomisp_bayer_order_rggb,
+	atomisp_bayer_order_grbg,
+	atomisp_bayer_order_gbrg,
+	atomisp_bayer_order_bggr
+};
+
+static int
+imx_read_reg(struct i2c_client *client, u16 len, u16 reg, u16 *val)
+{
+	struct i2c_msg msg[2];
+	u16 data[IMX_SHORT_MAX];
+	int err, i;
+
+	if (len > IMX_BYTE_MAX) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+	memset(data, 0 , sizeof(data));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
+
+	msg[1].addr = client->addr;
+	msg[1].len = len;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (u8 *)data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		goto error;
+	}
+
+	/* high byte comes first */
+	if (len == IMX_8BIT) {
+		*val = (u8)data[0];
+	} else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			val[i] = be16_to_cpu(data[i]);
+	}
+
+	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int imx_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+int
+imx_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg = (u16 *)data;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (data_length != IMX_8BIT && data_length != IMX_16BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == IMX_8BIT)
+		data[2] = (u8)(val);
+	else {
+		/* IMX_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
+
+	ret = imx_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * imx_write_reg_array - Initializes a list of imx registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __imx_flush_reg_array, __imx_buf_reg_array() and
+ * __imx_write_reg_is_consecutive() are internal functions to
+ * imx_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __imx_flush_reg_array(struct i2c_client *client,
+				     struct imx_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return imx_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __imx_buf_reg_array(struct i2c_client *client,
+				   struct imx_write_ctrl *ctrl,
+				   const struct imx_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case IMX_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case IMX_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->sreg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= IMX_MAX_WRITE_BUF_SIZE)
+		return __imx_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int
+__imx_write_reg_is_consecutive(struct i2c_client *client,
+				   struct imx_write_ctrl *ctrl,
+				   const struct imx_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->sreg;
+}
+
+static int imx_write_reg_array(struct i2c_client *client,
+				   const struct imx_reg *reglist)
+{
+	const struct imx_reg *next = reglist;
+	struct imx_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != IMX_TOK_TERM; next++) {
+		switch (next->type & IMX_TOK_MASK) {
+		case IMX_TOK_DELAY:
+			err = __imx_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__imx_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __imx_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __imx_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __imx_flush_reg_array(client, &ctrl);
+}
+
+static int __imx_min_fps_diff(int fps, const struct imx_fps_setting *fps_list)
+{
+	int diff = INT_MAX;
+	int i;
+
+	if (fps == 0)
+		return 0;
+
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (!fps_list[i].fps)
+			break;
+		if (abs(fps_list[i].fps - fps) < diff)
+			diff = abs(fps_list[i].fps - fps);
+	}
+
+	return diff;
+}
+
+static int __imx_nearest_fps_index(int fps,
+					const struct imx_fps_setting *fps_list)
+{
+	int fps_index = 0;
+	int i;
+
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (!fps_list[i].fps)
+			break;
+		if (abs(fps_list[i].fps - fps)
+		    < abs(fps_list[fps_index].fps - fps))
+			fps_index = i;
+	}
+	return fps_index;
+}
+
+/*
+ * This is to choose the nearest fps setting above the requested fps
+ * fps_list should be in ascendant order.
+ */
+static int __imx_above_nearest_fps_index(int fps,
+					const struct imx_fps_setting *fps_list)
+{
+	int fps_index = 0;
+	int i;
+
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (!fps_list[i].fps)
+			break;
+		if (fps <= fps_list[i].fps) {
+			fps_index = i;
+			break;
+		}
+	}
+
+	return fps_index;
+}
+
+static int __imx_get_max_fps_index(
+				const struct imx_fps_setting *fps_settings)
+{
+	int i;
+
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (fps_settings[i].fps == 0)
+			break;
+	}
+
+	return i - 1;
+}
+
+static int __imx_update_exposure_timing(struct i2c_client *client, u16 exposure,
+			u16 llp, u16 fll)
+{
+	int ret = 0;
+
+	/* Increase the VTS to match exposure + margin */
+	if (exposure > fll - IMX_INTEGRATION_TIME_MARGIN)
+		fll = exposure + IMX_INTEGRATION_TIME_MARGIN;
+
+	ret = imx_write_reg(client, IMX_16BIT, IMX_LINE_LENGTH_PIXELS, llp);
+	if (ret)
+		return ret;
+
+	ret = imx_write_reg(client, IMX_16BIT, IMX_FRAME_LENGTH_LINES, fll);
+	if (ret)
+		return ret;
+
+	if (exposure)
+		ret = imx_write_reg(client, IMX_16BIT,
+			IMX_COARSE_INTEGRATION_TIME, exposure);
+	return ret;
+}
+
+static int __imx_update_gain(struct v4l2_subdev *sd, u16 gain)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* set global gain */
+	ret = imx_write_reg(client, IMX_8BIT, IMX_GLOBAL_GAIN, gain);
+	if (ret)
+		return ret;
+
+	/* set short analog gain */
+	if (dev->sensor_id == IMX135_ID)
+		ret = imx_write_reg(client, IMX_8BIT, IMX_SHORT_AGC_GAIN, gain);
+
+	return ret;
+}
+
+static int __imx_update_digital_gain(struct i2c_client *client, u16 digitgain)
+{
+	struct imx_write_buffer digit_gain;
+
+	digit_gain.addr = cpu_to_be16(IMX_DGC_ADJ);
+	digit_gain.data[0] = (digitgain >> 8) & 0xFF;
+	digit_gain.data[1] = digitgain & 0xFF;
+	digit_gain.data[2] = (digitgain >> 8) & 0xFF;
+	digit_gain.data[3] = digitgain & 0xFF;
+	digit_gain.data[4] = (digitgain >> 8) & 0xFF;
+	digit_gain.data[5] = digitgain & 0xFF;
+	digit_gain.data[6] = (digitgain >> 8) & 0xFF;
+	digit_gain.data[7] = digitgain & 0xFF;
+
+	return imx_i2c_write(client, IMX_DGC_LEN, (u8 *)&digit_gain);
+}
+
+static int imx_set_exposure_gain(struct v4l2_subdev *sd, u16 coarse_itg,
+	u16 gain, u16 digitgain)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	/* Validate exposure:  cannot exceed VTS-4 where VTS is 16bit */
+	coarse_itg = clamp_t(u16, coarse_itg, 0, IMX_MAX_EXPOSURE_SUPPORTED);
+
+	/* Validate gain: must not exceed maximum 8bit value */
+	gain = clamp_t(u16, gain, 0, IMX_MAX_GLOBAL_GAIN_SUPPORTED);
+
+	/* Validate digital gain: must not exceed 12 bit value*/
+	digitgain = clamp_t(u16, digitgain, 0, IMX_MAX_DIGITAL_GAIN_SUPPORTED);
+
+	mutex_lock(&dev->input_lock);
+
+	ret = __imx_update_exposure_timing(client, coarse_itg,
+			dev->pixels_per_line, dev->lines_per_frame);
+	if (ret)
+		goto out;
+	dev->coarse_itg = coarse_itg;
+
+	if (dev->sensor_id == IMX175_ID)
+		ret = __imx_update_gain(sd, dev->gain);
+	else
+		ret = __imx_update_gain(sd, gain);
+	if (ret)
+		goto out;
+	dev->gain = gain;
+
+	if ((dev->sensor_id == IMX175_ID) && dev->digital_gain)
+		ret = __imx_update_digital_gain(client, dev->digital_gain);
+	else
+		ret = __imx_update_digital_gain(client, digitgain);
+	if (ret)
+		goto out;
+	dev->digital_gain = digitgain;
+
+out:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static long imx_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	return imx_set_exposure_gain(sd, exposure->integration_time[0],
+				exposure->gain[0], exposure->gain[1]);
+}
+
+/* FIXME -To be updated with real OTP reading */
+static int imx_g_priv_int_data(struct v4l2_subdev *sd,
+				   struct v4l2_private_int_data *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+	u8 __user *to = priv->data;
+	u32 read_size = priv->size;
+	int ret;
+
+	/* No need to copy data if size is 0 */
+	if (!read_size)
+		goto out;
+
+	if (IS_ERR(dev->otp_data)) {
+		dev_err(&client->dev, "OTP data not available");
+		return PTR_ERR(dev->otp_data);
+	}
+	/* Correct read_size value only if bigger than maximum */
+	if (read_size > dev->otp_driver->size)
+		read_size = dev->otp_driver->size;
+
+	ret = copy_to_user(to, dev->otp_data, read_size);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to copy OTP data to user\n",
+			 __func__);
+		return -EFAULT;
+	}
+out:
+	/* Return correct size */
+	priv->size = dev->otp_driver->size;
+
+	return 0;
+}
+
+static int __imx_init(struct v4l2_subdev *sd, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	if (dev->sensor_id == IMX_ID_DEFAULT)
+		return 0;
+
+	/* Sets the default FPS */
+	dev->fps_index = 0;
+	dev->curr_res_table = dev->mode_tables->res_preview;
+	dev->entries_curr_table = dev->mode_tables->n_res_preview;
+
+	ret = imx_write_reg_array(client, dev->mode_tables->init_settings);
+	if (ret)
+		return ret;
+
+	if (dev->sensor_id == IMX132_ID) {
+		static const unsigned int IMX132_DEFAULT_LANES = 1;
+		struct camera_mipi_info *imx_info =
+						v4l2_get_subdev_hostdata(sd);
+		static const u8 imx132_rglanesel[] = {
+			IMX132_RGLANESEL_1LANE,		/* 1 lane */
+			IMX132_RGLANESEL_2LANES,	/* 2 lanes */
+			IMX132_RGLANESEL_1LANE,		/* undefined */
+			IMX132_RGLANESEL_4LANES,	/* 4 lanes */
+		};
+		unsigned int lanes = (imx_info ? imx_info->num_lanes
+						: IMX132_DEFAULT_LANES) - 1;
+		if (lanes >= ARRAY_SIZE(imx132_rglanesel))
+			lanes = IMX132_DEFAULT_LANES - 1;
+		ret = imx_write_reg(client, IMX_8BIT,
+				    IMX132_RGLANESEL, imx132_rglanesel[lanes]);
+	}
+
+	return ret;
+}
+
+static int imx_init(struct v4l2_subdev *sd, u32 val)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+	ret = __imx_init(sd, val);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long imx_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return imx_s_exposure(sd, arg);
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		return imx_g_priv_int_data(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+       /* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "gpio failed\n");
+		goto fail_gpio;
+	}
+
+	return 0;
+fail_gpio:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int __imx_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret = 0;
+	int r = 0;
+
+	if (on == 0) {
+		ret = power_down(sd);
+		if (dev->vcm_driver && dev->vcm_driver->power_down)
+			r = dev->vcm_driver->power_down(sd);
+		if (ret == 0)
+			ret = r;
+		dev->power = 0;
+	} else {
+		if (dev->vcm_driver && dev->vcm_driver->power_up)
+			ret = dev->vcm_driver->power_up(sd);
+		if (ret)
+			return ret;
+		ret = power_up(sd);
+		if (!ret) {
+			dev->power = 1;
+			return __imx_init(sd, 0);
+		}
+	}
+
+	return ret;
+}
+
+static int imx_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __imx_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int imx_g_chip_ident(struct v4l2_subdev *sd,
+				struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!chip)
+		return -EINVAL;
+
+	v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_IMX, 0);
+
+	return 0;
+}
+
+static int imx_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct imx_reg *reglist)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx_device *dev = to_imx_sensor(sd);
+	u32 vt_pix_clk_div;
+	u32 vt_sys_clk_div;
+	u32 pre_pll_clk_div;
+	u32 pll_multiplier;
+
+	const int ext_clk_freq_hz = 19200000;
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	int ret;
+	u16 data[IMX_INTG_BUF_COUNT];
+
+	u32 vt_pix_clk_freq_mhz;
+	u32 coarse_integration_time_min;
+	u32 coarse_integration_time_max_margin;
+	u32 read_mode;
+	u32 div;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
+	ret = imx_read_reg(client, 1, IMX_VT_PIX_CLK_DIV, data);
+	if (ret)
+		return ret;
+	vt_pix_clk_div = data[0] & IMX_MASK_5BIT;
+
+	if (dev->sensor_id == IMX132_ID)
+		ret = imx_read_reg(client, 1, IMX132_VT_RGPLTD, data);
+	else
+		ret = imx_read_reg(client, 1, IMX_VT_SYS_CLK_DIV, data);
+	if (ret)
+		return ret;
+	vt_sys_clk_div = data[0] & IMX_MASK_2BIT;
+	ret = imx_read_reg(client, 1, IMX_PRE_PLL_CLK_DIV, data);
+	if (ret)
+		return ret;
+	pre_pll_clk_div = data[0] & IMX_MASK_4BIT;
+	ret = imx_read_reg(client, 2,
+		(dev->sensor_id == IMX132_ID) ?
+		IMX132_PLL_MULTIPLIER : IMX_PLL_MULTIPLIER, data);
+	if (ret)
+		return ret;
+	pll_multiplier = data[0] & IMX_MASK_11BIT;
+
+	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
+	ret = imx_read_reg(client, 4, IMX_COARSE_INTG_TIME_MIN, data);
+	if (ret)
+		return ret;
+	coarse_integration_time_min = data[0];
+	coarse_integration_time_max_margin = data[1];
+
+	/* Get the cropping and output resolution to ISP for this mode. */
+	ret =  imx_read_reg(client, 2, IMX_HORIZONTAL_START_H, data);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = data[0];
+
+	ret = imx_read_reg(client, 2, IMX_VERTICAL_START_H, data);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = data[0];
+
+	ret = imx_read_reg(client, 2, IMX_HORIZONTAL_END_H, data);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_end = data[0];
+
+	ret = imx_read_reg(client, 2, IMX_VERTICAL_END_H, data);
+	if (ret)
+		return ret;
+	buf->crop_vertical_end = data[0];
+
+	ret = imx_read_reg(client, 2, IMX_HORIZONTAL_OUTPUT_SIZE_H, data);
+	if (ret)
+		return ret;
+	buf->output_width = data[0];
+
+	ret = imx_read_reg(client, 2, IMX_VERTICAL_OUTPUT_SIZE_H, data);
+	if (ret)
+		return ret;
+	buf->output_height = data[0];
+
+	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
+	if (dev->sensor_id == IMX132_ID)
+		read_mode = 0;
+	else {
+		ret = imx_read_reg(client, 1, IMX_READ_MODE, data);
+		if (ret)
+			return ret;
+		read_mode = data[0] & IMX_MASK_2BIT;
+	}
+
+	div = pre_pll_clk_div*vt_sys_clk_div*vt_pix_clk_div;
+	if (div == 0)
+		return -EINVAL;
+
+	vt_pix_clk_freq_mhz = 2 * ext_clk_freq_hz / div;
+	vt_pix_clk_freq_mhz *= pll_multiplier;
+
+	dev->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+
+	buf->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf->coarse_integration_time_min = coarse_integration_time_min;
+	buf->coarse_integration_time_max_margin =
+				coarse_integration_time_max_margin;
+
+	buf->fine_integration_time_min = IMX_FINE_INTG_TIME;
+	buf->fine_integration_time_max_margin = IMX_FINE_INTG_TIME;
+	buf->fine_integration_time_def = IMX_FINE_INTG_TIME;
+	buf->frame_length_lines = dev->lines_per_frame;
+	buf->line_length_pck = dev->pixels_per_line;
+	buf->read_mode = read_mode;
+
+	if (dev->sensor_id == IMX132_ID) {
+		buf->binning_factor_x = 1;
+		buf->binning_factor_y = 1;
+	} else {
+		ret = imx_read_reg(client, 1, IMX_BINNING_ENABLE, data);
+		if (ret)
+			return ret;
+		/* 1:binning enabled, 0:disabled */
+		if (data[0] == 1) {
+			ret = imx_read_reg(client, 1, IMX_BINNING_TYPE, data);
+			if (ret)
+				return ret;
+			buf->binning_factor_x = data[0] >> 4 & 0x0f;
+			if (!buf->binning_factor_x)
+				buf->binning_factor_x = 1;
+			buf->binning_factor_y = data[0] & 0xf;
+			if (!buf->binning_factor_y)
+				buf->binning_factor_y = 1;
+		} else {
+			buf->binning_factor_x = 1;
+			buf->binning_factor_y = 1;
+		}
+	}
+
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int imx_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse;
+	int ret;
+
+	/* the fine integration time is currently not calculated */
+	ret = imx_read_reg(client, IMX_16BIT,
+			       IMX_COARSE_INTEGRATION_TIME, &coarse);
+	*value = coarse;
+
+	return ret;
+}
+
+static int imx_test_pattern(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return imx_write_reg(client, IMX_16BIT, IMX_TEST_PATTERN_MODE, value);
+}
+
+static enum v4l2_mbus_pixelcode
+imx_translate_bayer_order(enum atomisp_bayer_order code)
+{
+	switch (code) {
+	case atomisp_bayer_order_rggb:
+		return V4L2_MBUS_FMT_SRGGB10_1X10;
+	case atomisp_bayer_order_grbg:
+		return V4L2_MBUS_FMT_SGRBG10_1X10;
+	case atomisp_bayer_order_bggr:
+		return V4L2_MBUS_FMT_SBGGR10_1X10;
+	case atomisp_bayer_order_gbrg:
+		return V4L2_MBUS_FMT_SGBRG10_1X10;
+	}
+	return 0;
+}
+
+static int imx_v_flip(struct v4l2_subdev *sd, s32 value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct camera_mipi_info *imx_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val;
+
+	ret = imx_write_reg_array(client, imx_param_hold);
+	if (ret)
+		return ret;
+	ret = imx_read_reg(client, IMX_8BIT, IMX_IMG_ORIENTATION, &val);
+	if (ret)
+		return ret;
+	if (value)
+		val |= IMX_VFLIP_BIT;
+	else
+		val &= ~IMX_VFLIP_BIT;
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
+
+	imx_info = v4l2_get_subdev_hostdata(sd);
+	if (imx_info) {
+		val &= (IMX_VFLIP_BIT|IMX_HFLIP_BIT);
+		imx_info->raw_bayer_order = imx_bayer_order_mapping[val];
+		dev->format.code = imx_translate_bayer_order(
+			imx_info->raw_bayer_order);
+	}
+
+	return imx_write_reg_array(client, imx_param_update);
+}
+
+static int imx_h_flip(struct v4l2_subdev *sd, s32 value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct camera_mipi_info *imx_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val;
+
+	ret = imx_write_reg_array(client, imx_param_hold);
+	if (ret)
+		return ret;
+	ret = imx_read_reg(client, IMX_8BIT, IMX_IMG_ORIENTATION, &val);
+	if (ret)
+		return ret;
+	if (value)
+		val |= IMX_HFLIP_BIT;
+	else
+		val &= ~IMX_HFLIP_BIT;
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
+
+	imx_info = v4l2_get_subdev_hostdata(sd);
+	if (imx_info) {
+		val &= (IMX_VFLIP_BIT|IMX_HFLIP_BIT);
+		imx_info->raw_bayer_order = imx_bayer_order_mapping[val];
+		dev->format.code = imx_translate_bayer_order(
+		imx_info->raw_bayer_order);
+	}
+
+	return imx_write_reg_array(client, imx_param_update);
+}
+
+static int imx_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (IMX_FOCAL_LENGTH_NUM << 16) | IMX_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int imx_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (IMX_F_NUMBER_DEFAULT_NUM << 16) | IMX_F_NUMBER_DEM;
+	return 0;
+}
+
+static int imx_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (IMX_F_NUMBER_DEFAULT_NUM << 24) |
+		(IMX_F_NUMBER_DEM << 16) |
+		(IMX_F_NUMBER_DEFAULT_NUM << 8) | IMX_F_NUMBER_DEM;
+	return 0;
+}
+
+static int imx_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	*val = dev->curr_res_table[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int imx_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	*val = dev->curr_res_table[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+int imx_vcm_power_up(struct v4l2_subdev *sd)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->power_up)
+		return dev->vcm_driver->power_up(sd);
+	return 0;
+}
+
+int imx_vcm_power_down(struct v4l2_subdev *sd)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->power_down)
+		return dev->vcm_driver->power_down(sd);
+	return 0;
+}
+
+int imx_vcm_init(struct v4l2_subdev *sd)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->init)
+		return dev->vcm_driver->init(sd);
+	return 0;
+}
+
+int imx_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->t_focus_vcm)
+		return dev->vcm_driver->t_focus_vcm(sd, val);
+	return 0;
+}
+
+int imx_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->t_focus_abs)
+		return dev->vcm_driver->t_focus_abs(sd, value);
+	return 0;
+}
+int imx_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->t_focus_rel)
+		return dev->vcm_driver->t_focus_rel(sd, value);
+	return 0;
+}
+
+int imx_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->q_focus_status)
+		return dev->vcm_driver->q_focus_status(sd, value);
+	return 0;
+}
+
+int imx_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->q_focus_abs)
+		return dev->vcm_driver->q_focus_abs(sd, value);
+	return 0;
+}
+
+int imx_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->t_vcm_slew)
+		return dev->vcm_driver->t_vcm_slew(sd, value);
+	return 0;
+}
+
+int imx_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (dev->vcm_driver && dev->vcm_driver->t_vcm_timing)
+		return dev->vcm_driver->t_vcm_timing(sd, value);
+	return 0;
+}
+
+struct imx_control imx_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = imx_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_TEST_PATTERN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Test pattern",
+			.minimum = 0,
+			.maximum = 0xffff,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = imx_test_pattern,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = imx_v_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Mirror",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = imx_h_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move absolute",
+			.minimum = 0,
+			.maximum = IMX_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = imx_t_focus_abs,
+		.query = imx_q_focus_abs,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_RELATIVE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move relative",
+			.minimum = IMX_MAX_FOCUS_NEG,
+			.maximum = IMX_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = imx_t_focus_rel,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 100, /* allow enum to grow in the future */
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = imx_q_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VCM_SLEW,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vcm slew",
+			.minimum = 0,
+			.maximum = IMX_VCM_SLEW_STEP_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = imx_t_vcm_slew,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VCM_TIMEING,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vcm step time",
+			.minimum = 0,
+			.maximum = IMX_VCM_SLEW_TIME_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = imx_t_vcm_timing,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = IMX_FOCAL_LENGTH_DEFAULT,
+			.maximum = IMX_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = IMX_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = imx_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = IMX_F_NUMBER_DEFAULT,
+			.maximum = IMX_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = IMX_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = imx_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = IMX_F_NUMBER_RANGE,
+			.maximum =  IMX_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = IMX_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = imx_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = IMX_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = imx_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = IMX_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = imx_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(imx_controls))
+
+static struct imx_control *imx_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (imx_controls[i].qc.id == id)
+			return &imx_controls[i];
+	return NULL;
+}
+
+static int imx_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct imx_control *ctrl = imx_find_control(qc->id);
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int imx_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct imx_control *s_ctrl;
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = imx_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int imx_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct imx_control *octrl = imx_find_control(ctrl->id);
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 600
+static int distance(struct imx_resolution const *res, u32 w, u32 h)
+{
+	unsigned int w_ratio;
+	unsigned int h_ratio;
+	int match;
+
+	if (w == 0)
+		return -1;
+	w_ratio = (res->width << 13) / w;
+	if (h == 0)
+		return -1;
+	h_ratio = (res->height << 13) / h;
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(struct v4l2_subdev *sd, int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int fps_diff;
+	int min_fps_diff = INT_MAX;
+	int min_dist = INT_MAX;
+	const struct imx_resolution *tmp_res = NULL;
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	for (i = 0; i < dev->entries_curr_table; i++) {
+		tmp_res = &dev->curr_res_table[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+		if (dist == min_dist) {
+			fps_diff = __imx_min_fps_diff(dev->fps,
+						tmp_res->fps_options);
+			if (fps_diff < min_fps_diff) {
+				min_fps_diff = fps_diff;
+				idx = i;
+			}
+		}
+	}
+
+	return idx;
+}
+
+static int imx_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	int idx = 0;
+
+	mutex_lock(&dev->input_lock);
+
+	if ((fmt->width > imx_max_res[dev->sensor_id].res_max_width)
+		|| (fmt->height > imx_max_res[dev->sensor_id].res_max_height)) {
+		fmt->width =  imx_max_res[dev->sensor_id].res_max_width;
+		fmt->height = imx_max_res[dev->sensor_id].res_max_height;
+	} else {
+		idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 *  resolutions. If it fails, it means the requested
+		 *  resolution is higher than wecan support. Fallback
+		 *  to highest possible resolution in this case.
+		 */
+		if (idx == -1)
+			idx = dev->entries_curr_table - 1;
+
+		fmt->width = dev->curr_res_table[idx].width;
+		fmt->height = dev->curr_res_table[idx].height;
+	}
+
+	fmt->code = dev->format.code;
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+/* Call with ctrl_handler.lock hold */
+static int __adjust_hvblank(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+	u16 new_frame_length_lines, new_line_length_pck;
+	int ret;
+
+	/*
+	 * No need to adjust h/v blank if not set dbg value
+	 * Note that there is no other checking on the h/v blank value,
+	 * as h/v blank can be set to any value above zero for debug purpose
+	 */
+	if (!dev->v_blank->val || !dev->h_blank->val)
+		return 0;
+
+	new_frame_length_lines = dev->curr_res_table[dev->fmt_idx].height +
+		dev->v_blank->val;
+	new_line_length_pck = dev->curr_res_table[dev->fmt_idx].width +
+		dev->h_blank->val;
+
+	ret = imx_write_reg(client, IMX_16BIT, IMX_LINE_LENGTH_PIXELS,
+			    new_line_length_pck);
+	if (ret)
+		return ret;
+	ret = imx_write_reg(client, IMX_16BIT, IMX_FRAME_LENGTH_LINES,
+			    new_frame_length_lines);
+	if (ret)
+		return ret;
+
+	dev->lines_per_frame = new_frame_length_lines;
+	dev->pixels_per_line = new_line_length_pck;
+
+	return 0;
+}
+
+static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct camera_mipi_info *imx_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct imx_resolution *res;
+	int ret;
+	u16 val;
+
+	imx_info = v4l2_get_subdev_hostdata(sd);
+	if (imx_info == NULL)
+		return -EINVAL;
+	ret = imx_try_mbus_fmt(sd, fmt);
+	if (ret)
+		return ret;
+
+	mutex_lock(&dev->input_lock);
+
+	dev->fmt_idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+	if (dev->fmt_idx == -1) {
+		ret = -EINVAL;
+		goto out;
+	}
+	res = &dev->curr_res_table[dev->fmt_idx];
+
+	/* Adjust the FPS selection based on the resolution selected */
+	dev->fps_index = __imx_nearest_fps_index(dev->fps, res->fps_options);
+	dev->fps = res->fps_options[dev->fps_index].fps;
+	dev->regs = res->fps_options[dev->fps_index].regs;
+	if (!dev->regs)
+		dev->regs = res->regs;
+
+	ret = imx_write_reg_array(client, dev->regs);
+	if (ret)
+		goto out;
+
+	dev->pixels_per_line = res->fps_options[dev->fps_index].pixels_per_line;
+	dev->lines_per_frame = res->fps_options[dev->fps_index].lines_per_frame;
+
+	/* dbg h/v blank time */
+	mutex_lock(dev->ctrl_handler.lock);
+	__adjust_hvblank(sd);
+	mutex_unlock(dev->ctrl_handler.lock);
+
+	ret = __imx_update_exposure_timing(client, dev->coarse_itg,
+		dev->pixels_per_line, dev->lines_per_frame);
+	if (ret)
+		goto out;
+
+	ret = imx_write_reg_array(client, imx_param_update);
+	if (ret)
+		goto out;
+
+	ret = imx_get_intg_factor(client, imx_info, dev->regs);
+	if (ret)
+		goto out;
+
+	ret = imx_read_reg(client, IMX_8BIT, IMX_IMG_ORIENTATION, &val);
+	if (ret)
+		goto out;
+	val &= (IMX_VFLIP_BIT|IMX_HFLIP_BIT);
+	imx_info->raw_bayer_order = imx_bayer_order_mapping[val];
+	dev->format.code = imx_translate_bayer_order(
+		imx_info->raw_bayer_order);
+out:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+
+static int imx_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fmt->width = dev->curr_res_table[dev->fmt_idx].width;
+	fmt->height = dev->curr_res_table[dev->fmt_idx].height;
+	fmt->code = dev->format.code;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int imx_detect(struct i2c_client *client, u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+
+	/* i2c check */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	/* check sensor chip ID	 */
+	if (imx_read_reg(client, IMX_16BIT, IMX132_175_CHIP_ID, id)) {
+		v4l2_err(client, "sensor_id = 0x%x\n", *id);
+		return -ENODEV;
+	}
+	if (*id == IMX132_ID || *id == IMX175_ID)
+		goto found;
+
+	if (imx_read_reg(client, IMX_16BIT, IMX134_135_CHIP_ID, id)) {
+		v4l2_err(client, "sensor_id = 0x%x\n", *id);
+		return -ENODEV;
+	}
+	if (*id != IMX134_ID && *id != IMX135_ID) {
+		v4l2_err(client, "no imx sensor found\n");
+		return -ENODEV;
+	}
+found:
+	v4l2_info(client, "sensor_id = 0x%x\n", *id);
+
+	/* TODO - need to be updated */
+	*revision = 0;
+
+	return 0;
+}
+
+static void __imx_print_timing(struct v4l2_subdev *sd)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 width = dev->curr_res_table[dev->fmt_idx].width;
+	u16 height = dev->curr_res_table[dev->fmt_idx].height;
+
+	dev_dbg(&client->dev, "Dump imx timing in stream on:\n");
+	dev_dbg(&client->dev, "width: %d:\n", width);
+	dev_dbg(&client->dev, "height: %d:\n", height);
+	dev_dbg(&client->dev, "pixels_per_line: %d:\n", dev->pixels_per_line);
+	dev_dbg(&client->dev, "line per frame: %d:\n", dev->lines_per_frame);
+	dev_dbg(&client->dev, "pix freq: %d:\n", dev->vt_pix_clk_freq_mhz);
+	dev_dbg(&client->dev, "init fps: %d:\n", dev->vt_pix_clk_freq_mhz /
+			dev->pixels_per_line / dev->lines_per_frame);
+	dev_dbg(&client->dev, "HBlank: %d nS:\n",
+			1000 * (dev->pixels_per_line - width) /
+			(dev->vt_pix_clk_freq_mhz / 1000000));
+	dev_dbg(&client->dev, "VBlank: %d uS:\n",
+			(dev->lines_per_frame - height) * dev->pixels_per_line /
+			(dev->vt_pix_clk_freq_mhz / 1000000));
+}
+
+/*
+ * imx stream on/off
+ */
+static int imx_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (enable) {
+		/* Noise reduction & dead pixel applied before streaming */
+		if (dev->fw == NULL) {
+			dev_warn(&client->dev, "No MSR loaded from library");
+		} else {
+			ret = apply_msr_data(client, dev->fw);
+			if (ret) {
+				mutex_unlock(&dev->input_lock);
+				return ret;
+			}
+		}
+		__imx_print_timing(sd);
+		ret = imx_write_reg_array(client, imx_streaming);
+		if (ret != 0) {
+			v4l2_err(client, "write_reg_array err\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		dev->streaming = 1;
+	} else {
+		ret = imx_write_reg_array(client, imx_soft_standby);
+		if (ret != 0) {
+			v4l2_err(client, "write_reg_array err\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		dev->streaming = 0;
+		dev->fps_index = 0;
+		dev->fps = 0;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/*
+ * imx enum frame size, frame intervals
+ */
+static int imx_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= dev->entries_curr_table) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = dev->curr_res_table[index].width;
+	fsize->discrete.height = dev->curr_res_table[index].height;
+	fsize->reserved[0] = dev->curr_res_table[index].used;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int imx_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	/* since the isp will donwscale the resolution to the right size,
+	  * find the nearest one that will allow the isp to do so
+	  * important to ensure that the resolution requested is padded
+	  * correctly by the requester, which is the atomisp driver in
+	  * this case.
+	  */
+	i = nearest_resolution_index(sd, fival->width, fival->height);
+
+	if (i == -1)
+		goto out;
+
+	/* Check if this index is supported */
+	if (index > __imx_get_max_fps_index(dev->curr_res_table[i].fps_options))
+		goto out;
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = dev->curr_res_table[i].width;
+	fival->height = dev->curr_res_table[i].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = dev->curr_res_table[i].fps_options[index].fps;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+out:
+	mutex_unlock(&dev->input_lock);
+	return -EINVAL;
+}
+
+static int imx_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (index >= MAX_FMTS)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*code = dev->format.code;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int __update_imx_device_settings(struct imx_device *dev, u16 sensor_id)
+{
+	switch (sensor_id) {
+	case IMX175_ID:
+		if (INTEL_MID_BOARD(1, TABLET, CHT) ||
+		    INTEL_MID_BOARD(1, PHONE, BYT) ||
+		    INTEL_MID_BOARD(1, TABLET, BYT)) {
+			dev->mode_tables = &imx_sets[IMX175_VALLEYVIEW];
+			dev->vcm_driver = &imx_vcms[IMX175_VALLEYVIEW];
+			dev->otp_driver = &imx_otps[IMX175_VALLEYVIEW];
+		} else {
+			dev->mode_tables = &imx_sets[IMX175_MERRFLD];
+			dev->vcm_driver = &imx_vcms[IMX175_MERRFLD];
+			dev->otp_driver = &imx_otps[IMX175_MERRFLD];
+		}
+		break;
+	case IMX135_ID:
+		if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW ||
+		    dev->i2c_id == IMX135_FUJI_ID) {
+			dev->mode_tables = &imx_sets[IMX135_VICTORIABAY];
+			dev->vcm_driver = &imx_vcms[IMX135_VICTORIABAY];
+			dev->otp_driver = &imx_otps[IMX135_VICTORIABAY];
+		} else {
+			dev->mode_tables = &imx_sets[IMX135_SALTBAY];
+			dev->vcm_driver = &imx_vcms[IMX135_SALTBAY];
+			dev->otp_driver = &imx_otps[IMX135_SALTBAY];
+		}
+		break;
+	case IMX134_ID:
+		dev->mode_tables = &imx_sets[IMX134_VALLEYVIEW];
+		dev->vcm_driver = &imx_vcms[IMX134_VALLEYVIEW];
+		dev->otp_driver = &imx_otps[IMX134_VALLEYVIEW];
+		break;
+	case IMX132_ID:
+		dev->mode_tables = &imx_sets[IMX132_SALTBAY];
+		dev->otp_driver = &imx_otps[IMX132_SALTBAY];
+		dev->vcm_driver = NULL;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	return dev->vcm_driver->init(&dev->sd);
+}
+
+static int imx_s_config(struct v4l2_subdev *sd,
+			    int irq, void *pdata)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			dev_err(&client->dev, "imx platform init err\n");
+			return ret;
+		}
+	}
+	/*
+	 * power off the module first.
+	 *
+	 * As first power on by board have undecided state of power/gpio pins.
+	 */
+	ret = __imx_s_power(sd, 0);
+	if (ret) {
+		v4l2_err(client, "imx power-down err.\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = __imx_s_power(sd, 1);
+	if (ret) {
+		v4l2_err(client, "imx power-up err.\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = imx_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		v4l2_err(client, "imx_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	/* Resolution settings depend on sensor type and platform */
+	ret = __update_imx_device_settings(dev, dev->sensor_id);
+	if (ret)
+		goto fail_detect;
+	/* Read sensor's OTP data */
+	dev->otp_data = dev->otp_driver->otp_read(sd,
+		dev->otp_driver->dev_addr, dev->otp_driver->start_addr,
+		dev->otp_driver->size);
+
+	/* power off sensor */
+	ret = __imx_s_power(sd, 0);
+
+	mutex_unlock(&dev->input_lock);
+	if (ret)
+		v4l2_err(client, "imx power-down err.\n");
+
+	return ret;
+
+fail_detect:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_csi_cfg:
+	__imx_s_power(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int
+imx_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	code->code = dev->format.code;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int
+imx_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= dev->entries_curr_table) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fse->min_width = dev->curr_res_table[index].width;
+	fse->min_height = dev->curr_res_table[index].height;
+	fse->max_width = dev->curr_res_table[index].width;
+	fse->max_height = dev->curr_res_table[index].height;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__imx_get_pad_format(struct imx_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+imx_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__imx_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+imx_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+
+	return 0;
+}
+
+static int
+imx_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		dev->curr_res_table = dev->mode_tables->res_video;
+		dev->entries_curr_table = dev->mode_tables->n_res_video;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		dev->curr_res_table = dev->mode_tables->res_still;
+		dev->entries_curr_table = dev->mode_tables->n_res_still;
+		break;
+	default:
+		dev->curr_res_table = dev->mode_tables->res_preview;
+		dev->entries_curr_table = dev->mode_tables->n_res_preview;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+int
+imx_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	const struct imx_resolution *res =
+				&dev->curr_res_table[dev->fmt_idx];
+
+	mutex_lock(&dev->input_lock);
+	interval->interval.denominator = res->fps_options[dev->fps_index].fps;
+	interval->interval.numerator = 1;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int __imx_s_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct imx_resolution *res =
+				&dev->curr_res_table[dev->fmt_idx];
+	struct camera_mipi_info *imx_info = NULL;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	unsigned int fps_index;
+	int fps;
+	int ret = 0;
+
+
+	imx_info = v4l2_get_subdev_hostdata(sd);
+	if (imx_info == NULL)
+		return -EINVAL;
+
+	if (!interval->interval.numerator)
+		interval->interval.numerator = 1;
+
+	fps = interval->interval.denominator / interval->interval.numerator;
+
+	if (!fps)
+		return -EINVAL;
+
+	/* No need to proceed further if we are not streaming */
+	if (!dev->streaming) {
+		/* Save the new FPS and use it while selecting setting */
+		dev->fps = fps;
+		return 0;
+	}
+
+	 /* Ignore if we are already using the required FPS. */
+	if (fps == dev->fps)
+		return 0;
+
+	/*
+	 * Start here, sensor is already streaming, so adjust fps dynamically
+	 */
+	fps_index = __imx_above_nearest_fps_index(fps, res->fps_options);
+	if (fps > res->fps_options[fps_index].fps) {
+		/*
+		 * if does not have high fps setting, not support increase fps
+		 * by adjust lines per frame.
+		 */
+		dev_err(&client->dev, "Could not support fps: %d.\n", fps);
+		return -EINVAL;
+	}
+
+	if (res->fps_options[fps_index].regs &&
+	    res->fps_options[fps_index].regs != dev->regs) {
+		/*
+		 * if need a new setting, but the new setting has difference
+		 * with current setting, not use this one, as may have
+		 * unexpected result, e.g. PLL, IQ.
+		 */
+		dev_dbg(&client->dev, "Sensor is streaming, not apply new sensor setting\n");
+		if (fps > res->fps_options[dev->fps_index].fps) {
+			/*
+			 * Does not support increase fps based on low fps
+			 * setting, as the high fps setting could not be used,
+			 * and fps requested is above current setting fps.
+			 */
+			dev_warn(&client->dev, "Could not support fps: %d, keep current: %d.\n",
+					fps, dev->fps);
+			return 0;
+		}
+	} else {
+		dev->fps_index = fps_index;
+		dev->fps = res->fps_options[dev->fps_index].fps;
+	}
+
+	/* Update the new frametimings based on FPS */
+	pixels_per_line = res->fps_options[dev->fps_index].pixels_per_line;
+	lines_per_frame = res->fps_options[dev->fps_index].lines_per_frame;
+
+	if (fps > res->fps_options[fps_index].fps) {
+		/*
+		 * if does not have high fps setting, not support increase fps
+		 * by adjust lines per frame.
+		 */
+		dev_warn(&client->dev, "Could not support fps: %d. Use:%d.\n",
+				fps, res->fps_options[fps_index].fps);
+		goto done;
+	}
+
+	/* if the new setting does not match exactly */
+	if (dev->fps != fps) {
+#define MAX_LINES_PER_FRAME	0xffff
+		dev_dbg(&client->dev, "adjusting fps using lines_per_frame\n");
+		/*
+		 * FIXME!
+		 * 1: check DS on max value of lines_per_frame
+		 * 2: consider use pixel per line for more range?
+		 */
+		if (dev->lines_per_frame * dev->fps / fps >
+				MAX_LINES_PER_FRAME) {
+			dev_warn(&client->dev,
+					"adjust lines_per_frame out of range, try to use max value.\n");
+			lines_per_frame = MAX_LINES_PER_FRAME;
+		} else {
+			lines_per_frame = lines_per_frame * dev->fps / fps;
+		}
+	}
+done:
+	/* Update the new frametimings based on FPS */
+	dev->pixels_per_line = pixels_per_line;
+	dev->lines_per_frame = lines_per_frame;
+
+	/* Update the new values so that user side knows the current settings */
+	ret = __imx_update_exposure_timing(client,
+		dev->coarse_itg, dev->pixels_per_line, dev->lines_per_frame);
+	if (ret)
+		return ret;
+
+	dev->fps = fps;
+
+	ret = imx_get_intg_factor(client, imx_info, dev->regs);
+	if (ret)
+		return ret;
+
+	interval->interval.denominator = res->fps_options[dev->fps_index].fps;
+	interval->interval.numerator = 1;
+	__imx_print_timing(sd);
+
+	return ret;
+}
+
+static int imx_s_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __imx_s_frame_interval(sd, interval);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+static int imx_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = dev->curr_res_table[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops imx_sensor_ops = {
+	.g_skip_frames	= imx_g_skip_frames,
+};
+
+static int imx_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	return 0;
+}
+
+static int imx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct imx_device *dev = container_of(ctrl->handler, struct imx_device,
+			ctrl_handler);
+	unsigned int val;
+
+	switch (ctrl->id) {
+	case V4L2_CID_VBLANK:
+		ctrl->val = dev->lines_per_frame -
+			dev->curr_res_table[dev->fmt_idx].height;
+		break;
+	case V4L2_CID_HBLANK:
+		ctrl->val = dev->pixels_per_line -
+			dev->curr_res_table[dev->fmt_idx].width;
+		break;
+	case V4L2_CID_PIXEL_RATE:
+		ctrl->val = dev->vt_pix_clk_freq_mhz;
+		break;
+	case V4L2_CID_LINK_FREQ:
+		val = dev->curr_res_table[dev->fmt_idx].
+					fps_options[dev->fps_index].mipi_freq;
+		if (val == 0)
+			val = dev->curr_res_table[dev->fmt_idx].mipi_freq;
+		if (val == 0)
+			return -EINVAL;
+		ctrl->val = val * 1000;			/* To Hz */
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct v4l2_ctrl_ops imx_ctrl_ops = {
+	.s_ctrl = imx_set_ctrl,
+	.g_volatile_ctrl = imx_g_volatile_ctrl,
+};
+
+static const struct v4l2_subdev_video_ops imx_video_ops = {
+	.s_stream = imx_s_stream,
+	.enum_framesizes = imx_enum_framesizes,
+	.enum_frameintervals = imx_enum_frameintervals,
+	.enum_mbus_fmt = imx_enum_mbus_fmt,
+	.try_mbus_fmt = imx_try_mbus_fmt,
+	.g_mbus_fmt = imx_g_mbus_fmt,
+	.s_mbus_fmt = imx_s_mbus_fmt,
+	.s_parm = imx_s_parm,
+	.g_frame_interval = imx_g_frame_interval,
+	.s_frame_interval = imx_s_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops imx_core_ops = {
+	.g_chip_ident = imx_g_chip_ident,
+	.queryctrl = imx_queryctrl,
+	.g_ctrl = imx_g_ctrl,
+	.s_ctrl = imx_s_ctrl,
+	.s_power = imx_s_power,
+	.ioctl = imx_ioctl,
+	.init = imx_init,
+};
+
+static const struct v4l2_subdev_pad_ops imx_pad_ops = {
+	.enum_mbus_code = imx_enum_mbus_code,
+	.enum_frame_size = imx_enum_frame_size,
+	.get_fmt = imx_get_pad_format,
+	.set_fmt = imx_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops imx_ops = {
+	.core = &imx_core_ops,
+	.video = &imx_video_ops,
+	.pad = &imx_pad_ops,
+	.sensor = &imx_sensor_ops,
+};
+
+static const struct media_entity_operations imx_entity_ops = {
+	.link_setup = NULL,
+};
+
+static const struct v4l2_ctrl_config v4l2_ctrl_link_freq = {
+	.ops = &imx_ctrl_ops,
+	.id = V4L2_CID_LINK_FREQ,
+	.name = "Link Frequency",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 1,
+	.max = 1500000 * 1000,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static int imx_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	media_entity_cleanup(&dev->sd.entity);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	release_msr_list(client, dev->fw);
+	kfree(dev);
+
+	return 0;
+}
+
+static int __imx_init_ctrl_handler(struct imx_device *dev)
+{
+	struct v4l2_ctrl_handler *hdl;
+
+	hdl = &dev->ctrl_handler;
+
+	v4l2_ctrl_handler_init(&dev->ctrl_handler, 3);
+
+	dev->pixel_rate = v4l2_ctrl_new_std(&dev->ctrl_handler,
+					    &imx_ctrl_ops,
+					    V4L2_CID_PIXEL_RATE,
+					    0, UINT_MAX, 1, 0);
+
+	dev->h_blank = v4l2_ctrl_new_std(&dev->ctrl_handler,
+					  &imx_ctrl_ops,
+					  V4L2_CID_HBLANK, 0, SHRT_MAX, 1, 0);
+
+	dev->v_blank = v4l2_ctrl_new_std(&dev->ctrl_handler,
+					  &imx_ctrl_ops,
+					  V4L2_CID_VBLANK, 0, SHRT_MAX, 1, 0);
+	dev->link_freq = v4l2_ctrl_new_custom(&dev->ctrl_handler,
+					      &v4l2_ctrl_link_freq,
+					      NULL);
+
+	if (dev->ctrl_handler.error || dev->pixel_rate == NULL
+		|| dev->h_blank == NULL || dev->v_blank == NULL
+		|| dev->link_freq == NULL) {
+		return dev->ctrl_handler.error;
+	}
+
+	dev->sd.ctrl_handler = hdl;
+
+	dev->pixel_rate->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	dev->h_blank->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	dev->v_blank->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	return 0;
+}
+
+static int imx_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct imx_device *dev;
+	struct camera_mipi_info *imx_info = NULL;
+	int ret;
+	char *msr_file_name = NULL;
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		v4l2_err(client, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->i2c_id = id->driver_data;
+	dev->fmt_idx = 0;
+	dev->sensor_id = IMX_ID_DEFAULT;
+	dev->vcm_driver = &imx_vcms[IMX_ID_DEFAULT];
+
+	v4l2_i2c_subdev_init(&(dev->sd), client, &imx_ops);
+
+	if (client->dev.platform_data) {
+		ret = imx_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+	imx_info = v4l2_get_subdev_hostdata(&dev->sd);
+
+	/*
+	 * sd->name is updated with sensor driver name by the v4l2.
+	 * change it to sensor name in this case.
+	 */
+	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s%x %d-%04x",
+		IMX_SUBDEV_PREFIX, dev->sensor_id,
+		i2c_adapter_id(client->adapter), client->addr);
+
+	ret = __imx_init_ctrl_handler(dev);
+	if (ret)
+		goto out_ctrl_handler_free;
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = imx_translate_bayer_order(
+		imx_info->raw_bayer_order);
+	dev->sd.entity.ops = &imx_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		imx_remove(client);
+		return ret;
+	}
+
+	/* Load the Noise reduction, Dead pixel registers from cpf file*/
+	if (dev->platform_data->msr_file_name != NULL)
+		msr_file_name = dev->platform_data->msr_file_name();
+	if (msr_file_name) {
+		ret = load_msr_list(client, msr_file_name, &dev->fw);
+		if (ret) {
+			imx_remove(client);
+			return ret;
+		}
+	} else {
+		dev_warn(&client->dev, "Drvb file not present");
+	}
+
+	return ret;
+
+out_ctrl_handler_free:
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+static const struct i2c_device_id imx_ids[] = {
+	{IMX_NAME_175, IMX175_ID},
+	{IMX_NAME_135, IMX135_ID},
+	{IMX_NAME_135_FUJI, IMX135_FUJI_ID},
+	{IMX_NAME_134, IMX134_ID},
+	{IMX_NAME_132, IMX132_ID},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, imx_ids);
+
+static struct i2c_driver imx_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = IMX_DRIVER,
+	},
+	.probe = imx_probe,
+	.remove = imx_remove,
+	.id_table = imx_ids,
+};
+
+
+static __init int init_imx(void)
+{
+	return i2c_add_driver(&imx_driver);
+}
+
+static __exit void exit_imx(void)
+{
+	i2c_del_driver(&imx_driver);
+}
+
+module_init(init_imx);
+module_exit(exit_imx);
+
+MODULE_DESCRIPTION("A low-level driver for Sony IMX sensors");
+MODULE_AUTHOR("Shenbo Huang <shenbo.huang@intel.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
new file mode 100644
index 0000000..d01ae04
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx.h
@@ -0,0 +1,625 @@
+/*
+ * Support for Sony IMX camera sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IMX_H__
+#define __IMX_H__
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include "imx175.h"
+#include "imx135.h"
+#include "imx135vb.h"
+#include "imx134.h"
+#include "imx132.h"
+
+#define IMX_MCLK		192
+
+/* TODO - This should be added into include/linux/videodev2.h */
+#ifndef V4L2_IDENT_IMX
+#define V4L2_IDENT_IMX	8245
+#endif
+
+/*
+ * imx System control registers
+ */
+#define IMX_MASK_5BIT	0x1F
+#define IMX_MASK_4BIT	0xF
+#define IMX_MASK_2BIT	0x3
+#define IMX_MASK_11BIT	0x7FF
+#define IMX_INTG_BUF_COUNT		2
+
+#define IMX_FINE_INTG_TIME		0x1E8
+
+#define IMX_VT_PIX_CLK_DIV			0x0301
+#define IMX_VT_SYS_CLK_DIV			0x0303
+#define IMX_PRE_PLL_CLK_DIV			0x0305
+#define IMX_PLL_MULTIPLIER			0x030C
+#define IMX_OP_PIX_DIV			0x0309
+#define IMX_OP_SYS_DIV			0x030B
+#define IMX_FRAME_LENGTH_LINES		0x0340
+#define IMX_LINE_LENGTH_PIXELS		0x0342
+#define IMX_COARSE_INTG_TIME_MIN	0x1004
+#define IMX_COARSE_INTG_TIME_MAX	0x1006
+#define IMX_BINNING_ENABLE		0x0390
+#define IMX_BINNING_TYPE		0x0391
+
+#define IMX_READ_MODE				0x0390
+
+#define IMX_HORIZONTAL_START_H 0x0344
+#define IMX_VERTICAL_START_H 0x0346
+#define IMX_HORIZONTAL_END_H 0x0348
+#define IMX_VERTICAL_END_H 0x034a
+#define IMX_HORIZONTAL_OUTPUT_SIZE_H 0x034c
+#define IMX_VERTICAL_OUTPUT_SIZE_H 0x034e
+
+#define IMX_COARSE_INTEGRATION_TIME		0x0202
+#define IMX_TEST_PATTERN_MODE			0x0600
+#define IMX_IMG_ORIENTATION			0x0101
+#define IMX_VFLIP_BIT			2
+#define IMX_HFLIP_BIT			1
+#define IMX_GLOBAL_GAIN			0x0205
+#define IMX_SHORT_AGC_GAIN		0x0233
+#define IMX_DGC_ADJ		0x020E
+#define IMX_DGC_LEN		10
+#define IMX_MAX_EXPOSURE_SUPPORTED 0xfffb
+#define IMX_MAX_GLOBAL_GAIN_SUPPORTED 0x00ff
+#define IMX_MAX_DIGITAL_GAIN_SUPPORTED 0x0fff
+
+#define MAX_FMTS 1
+#define IMX_OTP_DATA_SIZE		1280
+
+#define IMX_SUBDEV_PREFIX "imx"
+#define IMX_DRIVER	"imx1x5"
+
+/* Sensor ids from identification register */
+#define IMX_NAME_134	"imx134"
+#define IMX_NAME_135	"imx135"
+#define IMX_NAME_175	"imx175"
+#define IMX_NAME_132	"imx132"
+#define IMX175_ID	0x0175
+#define IMX135_ID	0x0135
+#define IMX134_ID	0x0134
+#define IMX132_ID	0x0132
+
+/* Sensor id based on i2c_device_id table
+ * (Fuji module can not be detected based on sensor registers) */
+#define IMX135_FUJI_ID			0x0136
+#define IMX_NAME_135_FUJI		"imx135fuji"
+
+/* imx175 - use dw9714 vcm */
+#define IMX175_MERRFLD 0x175
+#define IMX175_VALLEYVIEW 0x176
+#define IMX135_SALTBAY 0x135
+#define IMX135_VICTORIABAY 0x136
+#define IMX132_SALTBAY 0x132
+#define IMX134_VALLEYVIEW 0x134
+
+/* otp - specific settings */
+#define E2PROM_ADDR 0xa0
+#define E2PROM_LITEON_12P1BA869D_ADDR 0xa0
+#define E2PROM_ABICO_SS89A839_ADDR 0xa8
+#define DEFAULT_OTP_SIZE 1280
+#define IMX135_OTP_SIZE 1280
+#define E2PROM_LITEON_12P1BA869D_SIZE 544
+
+#define IMX_ID_DEFAULT	0x0000
+#define IMX132_175_CHIP_ID	0x0000
+#define IMX134_135_CHIP_ID	0x0016
+
+#define IMX175_RES_WIDTH_MAX	3280
+#define IMX175_RES_HEIGHT_MAX	2464
+#define IMX135_RES_WIDTH_MAX	4208
+#define IMX135_RES_HEIGHT_MAX	3120
+#define IMX132_RES_WIDTH_MAX	1936
+#define IMX132_RES_HEIGHT_MAX	1096
+#define IMX134_RES_WIDTH_MAX	3280
+#define IMX134_RES_HEIGHT_MAX	2464
+
+/* Defines for lens/VCM */
+#define IMX_FOCAL_LENGTH_NUM	369	/*3.69mm*/
+#define IMX_FOCAL_LENGTH_DEM	100
+#define IMX_F_NUMBER_DEFAULT_NUM	22
+#define IMX_F_NUMBER_DEM	10
+#define IMX_INVALID_CONFIG	0xffffffff
+#define IMX_MAX_FOCUS_POS	1023
+#define IMX_MAX_FOCUS_NEG	(-1023)
+#define IMX_VCM_SLEW_STEP_MAX	0x3f
+#define IMX_VCM_SLEW_TIME_MAX	0x1f
+
+#define IMX_BIN_FACTOR_MAX			4
+#define IMX_INTEGRATION_TIME_MARGIN	4
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_FOCAL_LENGTH_DEFAULT 0x1710064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_F_NUMBER_DEFAULT 0x16000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define IMX_F_NUMBER_RANGE 0x160a160a
+
+struct imx_vcm {
+	int (*power_up)(struct v4l2_subdev *sd);
+	int (*power_down)(struct v4l2_subdev *sd);
+	int (*init)(struct v4l2_subdev *sd);
+	int (*t_focus_vcm)(struct v4l2_subdev *sd, u16 val);
+	int (*t_focus_abs)(struct v4l2_subdev *sd, s32 value);
+	int (*t_focus_rel)(struct v4l2_subdev *sd, s32 value);
+	int (*q_focus_status)(struct v4l2_subdev *sd, s32 *value);
+	int (*q_focus_abs)(struct v4l2_subdev *sd, s32 *value);
+	int (*t_vcm_slew)(struct v4l2_subdev *sd, s32 value);
+	int (*t_vcm_timing)(struct v4l2_subdev *sd, s32 value);
+};
+
+struct imx_otp {
+	void *(*otp_read)(struct v4l2_subdev *sd, u8 dev_addr,
+		u32 start_addr, u32 size);
+	u32 start_addr;
+	u32 size;
+	u8 dev_addr;
+};
+
+struct max_res {
+	int res_max_width;
+	int res_max_height;
+};
+
+struct max_res imx_max_res[] = {
+	[IMX175_ID] = {
+		.res_max_width = IMX175_RES_WIDTH_MAX,
+		.res_max_height = IMX175_RES_HEIGHT_MAX,
+	},
+	[IMX135_ID] = {
+		.res_max_width = IMX135_RES_WIDTH_MAX,
+		.res_max_height = IMX135_RES_HEIGHT_MAX,
+	},
+	[IMX132_ID] = {
+		.res_max_width = IMX132_RES_WIDTH_MAX,
+		.res_max_height = IMX132_RES_HEIGHT_MAX,
+	},
+	[IMX134_ID] = {
+		.res_max_width = IMX134_RES_WIDTH_MAX,
+		.res_max_height = IMX134_RES_HEIGHT_MAX,
+	},
+};
+
+struct imx_settings {
+	struct imx_reg const *init_settings;
+	struct imx_resolution *res_preview;
+	struct imx_resolution *res_still;
+	struct imx_resolution *res_video;
+	int n_res_preview;
+	int n_res_still;
+	int n_res_video;
+};
+
+struct imx_settings imx_sets[] = {
+	[IMX175_MERRFLD] = {
+		.init_settings = imx175_init_settings,
+		.res_preview = imx175_res_preview,
+		.res_still = imx175_res_still,
+		.res_video = imx175_res_video,
+		.n_res_preview = ARRAY_SIZE(imx175_res_preview),
+		.n_res_still = ARRAY_SIZE(imx175_res_still),
+		.n_res_video = ARRAY_SIZE(imx175_res_video),
+	},
+	[IMX175_VALLEYVIEW] = {
+		.init_settings = imx175_init_settings,
+		.res_preview = imx175_res_preview,
+		.res_still = imx175_res_still,
+		.res_video = imx175_res_video,
+		.n_res_preview = ARRAY_SIZE(imx175_res_preview),
+		.n_res_still = ARRAY_SIZE(imx175_res_still),
+		.n_res_video = ARRAY_SIZE(imx175_res_video),
+	},
+	[IMX135_SALTBAY] = {
+		.init_settings = imx135_init_settings,
+		.res_preview = imx135_res_preview,
+		.res_still = imx135_res_still,
+		.res_video = imx135_res_video,
+		.n_res_preview = ARRAY_SIZE(imx135_res_preview),
+		.n_res_still = ARRAY_SIZE(imx135_res_still),
+		.n_res_video = ARRAY_SIZE(imx135_res_video),
+	},
+	[IMX135_VICTORIABAY] = {
+		.init_settings = imx135vb_init_settings,
+		.res_preview = imx135vb_res_preview,
+		.res_still = imx135vb_res_still,
+		.res_video = imx135vb_res_video,
+		.n_res_preview = ARRAY_SIZE(imx135vb_res_preview),
+		.n_res_still = ARRAY_SIZE(imx135vb_res_still),
+		.n_res_video = ARRAY_SIZE(imx135vb_res_video),
+	},
+	[IMX132_SALTBAY] = {
+		.init_settings = imx132_init_settings,
+		.res_preview = imx132_res_preview,
+		.res_still = imx132_res_still,
+		.res_video = imx132_res_video,
+		.n_res_preview = ARRAY_SIZE(imx132_res_preview),
+		.n_res_still = ARRAY_SIZE(imx132_res_still),
+		.n_res_video = ARRAY_SIZE(imx132_res_video),
+	},
+	[IMX134_VALLEYVIEW] = {
+		.init_settings = imx134_init_settings,
+		.res_preview = imx134_res_preview,
+		.res_still = imx134_res_still,
+		.res_video = imx134_res_video,
+		.n_res_preview = ARRAY_SIZE(imx134_res_preview),
+		.n_res_still = ARRAY_SIZE(imx134_res_still),
+		.n_res_video = ARRAY_SIZE(imx134_res_video),
+	},
+};
+
+#define	v4l2_format_capture_type_entry(_width, _height, \
+		_pixelformat, _bytesperline, _colorspace) \
+	{\
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\
+		.fmt.pix.width = (_width),\
+		.fmt.pix.height = (_height),\
+		.fmt.pix.pixelformat = (_pixelformat),\
+		.fmt.pix.bytesperline = (_bytesperline),\
+		.fmt.pix.colorspace = (_colorspace),\
+		.fmt.pix.sizeimage = (_height)*(_bytesperline),\
+	}
+
+#define	s_output_format_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps) \
+	{\
+		.v4l2_fmt = v4l2_format_capture_type_entry(_width, \
+			_height, _pixelformat, _bytesperline, \
+				_colorspace),\
+		.fps = (_fps),\
+	}
+
+#define	s_output_format_reg_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps, _reg_setting) \
+	{\
+		.s_fmt = s_output_format_entry(_width, _height,\
+				_pixelformat, _bytesperline, \
+				_colorspace, _fps),\
+		.reg_setting = (_reg_setting),\
+	}
+
+struct s_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
+};
+
+#define	v4l2_queryctrl_entry_integer(_id, _name,\
+		_minimum, _maximum, _step, \
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_INTEGER, \
+		.name = _name, \
+		.minimum = (_minimum), \
+		.maximum = (_maximum), \
+		.step = (_step), \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+#define	v4l2_queryctrl_entry_boolean(_id, _name,\
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_BOOLEAN, \
+		.name = _name, \
+		.minimum = 0, \
+		.maximum = 1, \
+		.step = 1, \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+
+#define	s_ctrl_id_entry_integer(_id, _name, \
+		_minimum, _maximum, _step, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
+				_minimum, _maximum, _step,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+#define	s_ctrl_id_entry_boolean(_id, _name, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+
+struct imx_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/* imx device structure */
+struct imx_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct camera_sensor_platform_data *platform_data;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	int fmt_idx;
+	int status;
+	int streaming;
+	int power;
+	int run_mode;
+	int vt_pix_clk_freq_mhz;
+	int fps_index;
+	u32 focus;
+	u16 sensor_id;			/* Sensor id from registers */
+	u16 i2c_id;			/* Sensor id from i2c_device_id */
+	u16 coarse_itg;
+	u16 fine_itg;
+	u16 digital_gain;
+	u16 gain;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 fps;
+	const struct imx_reg *regs;
+	u8 res;
+	u8 type;
+	u8 sensor_revision;
+	u8 *otp_data;
+	struct imx_settings *mode_tables;
+	struct imx_vcm *vcm_driver;
+	struct imx_otp *otp_driver;
+	const struct imx_resolution *curr_res_table;
+	int entries_curr_table;
+	const struct firmware *fw;
+
+	/* used for h/b blank tuning */
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *h_blank;
+	struct v4l2_ctrl *v_blank;
+	struct v4l2_ctrl *link_freq;
+};
+
+#define to_imx_sensor(x) container_of(x, struct imx_device, sd)
+
+#define IMX_MAX_WRITE_BUF_SIZE	32
+struct imx_write_buffer {
+	u16 addr;
+	u8 data[IMX_MAX_WRITE_BUF_SIZE];
+};
+
+struct imx_write_ctrl {
+	int index;
+	struct imx_write_buffer buffer;
+};
+
+static const struct imx_reg imx_soft_standby[] = {
+	{IMX_8BIT, 0x0100, 0x00},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx_streaming[] = {
+	{IMX_8BIT, 0x0100, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx_param_hold[] = {
+	{IMX_8BIT, 0x0104, 0x01},	/* GROUPED_PARAMETER_HOLD */
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx_param_update[] = {
+	{IMX_8BIT, 0x0104, 0x00},	/* GROUPED_PARAMETER_HOLD */
+	{IMX_TOK_TERM, 0, 0}
+};
+
+extern int ad5816g_vcm_power_up(struct v4l2_subdev *sd);
+extern int ad5816g_vcm_power_down(struct v4l2_subdev *sd);
+extern int ad5816g_vcm_init(struct v4l2_subdev *sd);
+
+extern int ad5816g_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+extern int ad5816g_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+extern int ad5816g_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+extern int ad5816g_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+extern int ad5816g_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+extern int ad5816g_t_vcm_slew(struct v4l2_subdev *sd, s32 value);
+extern int ad5816g_t_vcm_timing(struct v4l2_subdev *sd, s32 value);
+
+extern int drv201_vcm_power_up(struct v4l2_subdev *sd);
+extern int drv201_vcm_power_down(struct v4l2_subdev *sd);
+extern int drv201_vcm_init(struct v4l2_subdev *sd);
+
+extern int drv201_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+extern int drv201_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+extern int drv201_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+extern int drv201_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+extern int drv201_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+extern int drv201_t_vcm_slew(struct v4l2_subdev *sd, s32 value);
+extern int drv201_t_vcm_timing(struct v4l2_subdev *sd, s32 value);
+
+extern int dw9714_vcm_power_up(struct v4l2_subdev *sd);
+extern int dw9714_vcm_power_down(struct v4l2_subdev *sd);
+extern int dw9714_vcm_init(struct v4l2_subdev *sd);
+
+extern int dw9714_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+extern int dw9714_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+extern int dw9714_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+extern int dw9714_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+extern int dw9714_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+extern int dw9714_t_vcm_slew(struct v4l2_subdev *sd, s32 value);
+extern int dw9714_t_vcm_timing(struct v4l2_subdev *sd, s32 value);
+
+extern int dw9719_vcm_power_up(struct v4l2_subdev *sd);
+extern int dw9719_vcm_power_down(struct v4l2_subdev *sd);
+extern int dw9719_vcm_init(struct v4l2_subdev *sd);
+
+extern int dw9719_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+extern int dw9719_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+extern int dw9719_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+extern int dw9719_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+extern int dw9719_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+extern int dw9719_t_vcm_slew(struct v4l2_subdev *sd, s32 value);
+extern int dw9719_t_vcm_timing(struct v4l2_subdev *sd, s32 value);
+
+extern int vcm_power_up(struct v4l2_subdev *sd);
+extern int vcm_power_down(struct v4l2_subdev *sd);
+
+struct imx_vcm imx_vcms[] = {
+	[IMX175_MERRFLD] = {
+		.power_up = drv201_vcm_power_up,
+		.power_down = drv201_vcm_power_down,
+		.init = drv201_vcm_init,
+		.t_focus_vcm = drv201_t_focus_vcm,
+		.t_focus_abs = drv201_t_focus_abs,
+		.t_focus_rel = drv201_t_focus_rel,
+		.q_focus_status = drv201_q_focus_status,
+		.q_focus_abs = drv201_q_focus_abs,
+		.t_vcm_slew = drv201_t_vcm_slew,
+		.t_vcm_timing = drv201_t_vcm_timing,
+	},
+	[IMX175_VALLEYVIEW] = {
+		.power_up = dw9714_vcm_power_up,
+		.power_down = dw9714_vcm_power_down,
+		.init = dw9714_vcm_init,
+		.t_focus_vcm = dw9714_t_focus_vcm,
+		.t_focus_abs = dw9714_t_focus_abs,
+		.t_focus_rel = dw9714_t_focus_rel,
+		.q_focus_status = dw9714_q_focus_status,
+		.q_focus_abs = dw9714_q_focus_abs,
+		.t_vcm_slew = dw9714_t_vcm_slew,
+		.t_vcm_timing = dw9714_t_vcm_timing,
+	},
+	[IMX135_SALTBAY] = {
+		.power_up = ad5816g_vcm_power_up,
+		.power_down = ad5816g_vcm_power_down,
+		.init = ad5816g_vcm_init,
+		.t_focus_vcm = ad5816g_t_focus_vcm,
+		.t_focus_abs = ad5816g_t_focus_abs,
+		.t_focus_rel = ad5816g_t_focus_rel,
+		.q_focus_status = ad5816g_q_focus_status,
+		.q_focus_abs = ad5816g_q_focus_abs,
+		.t_vcm_slew = ad5816g_t_vcm_slew,
+		.t_vcm_timing = ad5816g_t_vcm_timing,
+	},
+	[IMX135_VICTORIABAY] = {
+		.power_up = dw9719_vcm_power_up,
+		.power_down = dw9719_vcm_power_down,
+		.init = dw9719_vcm_init,
+		.t_focus_vcm = dw9719_t_focus_vcm,
+		.t_focus_abs = dw9719_t_focus_abs,
+		.t_focus_rel = dw9719_t_focus_rel,
+		.q_focus_status = dw9719_q_focus_status,
+		.q_focus_abs = dw9719_q_focus_abs,
+		.t_vcm_slew = dw9719_t_vcm_slew,
+		.t_vcm_timing = dw9719_t_vcm_timing,
+	},
+	[IMX134_VALLEYVIEW] = {
+		.power_up = dw9714_vcm_power_up,
+		.power_down = dw9714_vcm_power_down,
+		.init = dw9714_vcm_init,
+		.t_focus_vcm = dw9714_t_focus_vcm,
+		.t_focus_abs = dw9714_t_focus_abs,
+		.t_focus_rel = dw9714_t_focus_rel,
+		.q_focus_status = dw9714_q_focus_status,
+		.q_focus_abs = dw9714_q_focus_abs,
+		.t_vcm_slew = dw9714_t_vcm_slew,
+		.t_vcm_timing = dw9714_t_vcm_timing,
+	},
+	[IMX_ID_DEFAULT] = {
+		.power_up = vcm_power_up,
+		.power_down = vcm_power_down,
+	},
+};
+
+extern void *dummy_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size);
+extern void *imx_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size);
+extern void *e2prom_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size);
+struct imx_otp imx_otps[] = {
+	[IMX175_MERRFLD] = {
+		.otp_read = imx_otp_read,
+		.dev_addr = E2PROM_ADDR,
+		.start_addr = 0,
+		.size = DEFAULT_OTP_SIZE,
+	},
+	[IMX175_VALLEYVIEW] = {
+		.otp_read = e2prom_otp_read,
+		.dev_addr = E2PROM_ABICO_SS89A839_ADDR,
+		.start_addr = E2PROM_2ADDR,
+		.size = DEFAULT_OTP_SIZE,
+	},
+	[IMX135_SALTBAY] = {
+		.otp_read = e2prom_otp_read,
+		.dev_addr = E2PROM_ADDR,
+		.start_addr = 0,
+		.size = DEFAULT_OTP_SIZE,
+	},
+	[IMX135_VICTORIABAY] = {
+		.otp_read = imx_otp_read,
+		.size = DEFAULT_OTP_SIZE,
+	},
+	[IMX134_VALLEYVIEW] = {
+		.otp_read = e2prom_otp_read,
+		.dev_addr = E2PROM_LITEON_12P1BA869D_ADDR,
+		.start_addr = 0,
+		.size = E2PROM_LITEON_12P1BA869D_SIZE,
+	},
+	[IMX132_SALTBAY] = {
+		.otp_read = dummy_otp_read,
+		.size = DEFAULT_OTP_SIZE,
+	},
+	[IMX_ID_DEFAULT] = {
+		.otp_read = dummy_otp_read,
+		.size = DEFAULT_OTP_SIZE,
+	},
+};
+
+#endif
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h
new file mode 100644
index 0000000..f950413
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx132.h
@@ -0,0 +1,799 @@
+/*
+ * Support for Sony IMX camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IMX132_H__
+#define __IMX132_H__
+#include "common.h"
+
+/********************** registers define ********************************/
+#define IMX132_PLL_MULTIPLIER			0x0306
+#define IMX132_VT_RGPLTD			0x30A4
+#define IMX132_RGLANESEL			0x3301	/* Number of lanes */
+#define IMX132_RGLANESEL_1LANE			0x01
+#define IMX132_RGLANESEL_2LANES			0x00
+#define IMX132_RGLANESEL_4LANES			0x03
+
+/********************** settings for imx from vendor*********************/
+static struct imx_reg imx132_1080p_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Global Settings */
+	{IMX_8BIT, 0x3087, 0x53},
+	{IMX_8BIT, 0x308B, 0x5A},
+	{IMX_8BIT, 0x3094, 0x11},
+	{IMX_8BIT, 0x309D, 0xA4},
+	{IMX_8BIT, 0x30AA, 0x01},
+	{IMX_8BIT, 0x30C6, 0x00},
+	{IMX_8BIT, 0x30C7, 0x00},
+	{IMX_8BIT, 0x3118, 0x2F},
+	{IMX_8BIT, 0x312A, 0x00},
+	{IMX_8BIT, 0x312B, 0x0B},
+	{IMX_8BIT, 0x312C, 0x0B},
+	{IMX_8BIT, 0x312D, 0x13},
+	/* PLL setting */
+	{IMX_8BIT, 0x0305, 0x02},
+	{IMX_8BIT, 0x0307, 0x50},
+	{IMX_8BIT, 0x30A4, 0x02},
+	{IMX_8BIT, 0x303C, 0x3C},
+	/* Mode setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x14},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x32},
+	{IMX_8BIT, 0x0348, 0x07},
+	{IMX_8BIT, 0x0349, 0xA3},
+	{IMX_8BIT, 0x034A, 0x04},
+	{IMX_8BIT, 0x034B, 0x79},
+	{IMX_8BIT, 0x034C, 0x07},
+	{IMX_8BIT, 0x034D, 0x90},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0x48},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x303D, 0x10},
+	{IMX_8BIT, 0x303E, 0x5A},
+	{IMX_8BIT, 0x3040, 0x00},
+	{IMX_8BIT, 0x3041, 0x00},
+	{IMX_8BIT, 0x3048, 0x00},
+	{IMX_8BIT, 0x304C, 0x2F},
+	{IMX_8BIT, 0x304D, 0x02},
+	{IMX_8BIT, 0x3064, 0x92},
+	{IMX_8BIT, 0x306A, 0x10},
+	{IMX_8BIT, 0x309B, 0x00},
+	{IMX_8BIT, 0x309E, 0x41},
+	{IMX_8BIT, 0x30A0, 0x10},
+	{IMX_8BIT, 0x30A1, 0x0B},
+	{IMX_8BIT, 0x30B2, 0x00},
+	{IMX_8BIT, 0x30D5, 0x00},
+	{IMX_8BIT, 0x30D6, 0x00},
+	{IMX_8BIT, 0x30D7, 0x00},
+	{IMX_8BIT, 0x30D8, 0x00},
+	{IMX_8BIT, 0x30D9, 0x00},
+	{IMX_8BIT, 0x30DA, 0x00},
+	{IMX_8BIT, 0x30DB, 0x00},
+	{IMX_8BIT, 0x30DC, 0x00},
+	{IMX_8BIT, 0x30DD, 0x00},
+	{IMX_8BIT, 0x30DE, 0x00},
+	{IMX_8BIT, 0x3102, 0x0C},
+	{IMX_8BIT, 0x3103, 0x33},
+	{IMX_8BIT, 0x3104, 0x18},
+	{IMX_8BIT, 0x3105, 0x00},
+	{IMX_8BIT, 0x3106, 0x65},
+	{IMX_8BIT, 0x3107, 0x00},
+	{IMX_8BIT, 0x3108, 0x06},
+	{IMX_8BIT, 0x3109, 0x04},
+	{IMX_8BIT, 0x310A, 0x04},
+	{IMX_8BIT, 0x315C, 0x3D},
+	{IMX_8BIT, 0x315D, 0x3C},
+	{IMX_8BIT, 0x316E, 0x3E},
+	{IMX_8BIT, 0x316F, 0x3D},
+	/* Global timing */
+	{IMX_8BIT, 0x3304, 0x07}, /* RGTLPX[5:0] TLPX */
+	{IMX_8BIT, 0x3305, 0x06}, /* RGTCLKPREPARE[3:0] TCLK-PREPARE */
+	{IMX_8BIT, 0x3306, 0x19}, /* RGTCLKZERO[5:0] TCLK-ZERO */
+	{IMX_8BIT, 0x3307, 0x03}, /* RGTCLKPRE[5:0] TCLK-PRE */
+	{IMX_8BIT, 0x3308, 0x0F}, /* RGTCLKPOST[5:0] TCLK-POST */
+	{IMX_8BIT, 0x3309, 0x07}, /* RGTCLKTRAIL[3:0] TCLK-TRAIL */
+	{IMX_8BIT, 0x330A, 0x0C}, /* RGTHSEXIT[5:0] THS-EXIT */
+	{IMX_8BIT, 0x330B, 0x06}, /* RGTHSPREPARE[3:0] THS-PREPARE */
+	{IMX_8BIT, 0x330C, 0x0B}, /* RGTHSZERO[5:0] THS-ZERO */
+	{IMX_8BIT, 0x330D, 0x07}, /* RGTHSTRAIL[3:0] THS-TRAIL */
+	{IMX_8BIT, 0x330E, 0x03},
+	{IMX_8BIT, 0x3318, 0x62},
+	{IMX_8BIT, 0x3322, 0x09},
+	{IMX_8BIT, 0x3342, 0x00},
+	{IMX_8BIT, 0x3348, 0xE0},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0202, 0x04},
+	{IMX_8BIT, 0x0203, 0x50},
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01}, /* R */
+	{IMX_8BIT, 0x0211, 0xA0},
+	{IMX_8BIT, 0x0212, 0x02}, /* B */
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
+	{IMX_8BIT, 0x0215, 0x00},
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx132_1456x1096_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Global Settings */
+	{IMX_8BIT, 0x3087, 0x53},
+	{IMX_8BIT, 0x308B, 0x5A},
+	{IMX_8BIT, 0x3094, 0x11},
+	{IMX_8BIT, 0x309D, 0xA4},
+	{IMX_8BIT, 0x30AA, 0x01},
+	{IMX_8BIT, 0x30C6, 0x00},
+	{IMX_8BIT, 0x30C7, 0x00},
+	{IMX_8BIT, 0x3118, 0x2F},
+	{IMX_8BIT, 0x312A, 0x00},
+	{IMX_8BIT, 0x312B, 0x0B},
+	{IMX_8BIT, 0x312C, 0x0B},
+	{IMX_8BIT, 0x312D, 0x13},
+	/* PLL setting */
+	{IMX_8BIT, 0x0305, 0x02},
+	{IMX_8BIT, 0x0307, 0x50},
+	{IMX_8BIT, 0x30A4, 0x02},
+	{IMX_8BIT, 0x303C, 0x3C},
+	/* Mode setting */
+	{IMX_8BIT, 0x0344, 0x01},
+	{IMX_8BIT, 0x0345, 0x04},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x32},
+	{IMX_8BIT, 0x0348, 0x06},
+	{IMX_8BIT, 0x0349, 0xB3},
+	{IMX_8BIT, 0x034A, 0x04},
+	{IMX_8BIT, 0x034B, 0x79},
+	{IMX_8BIT, 0x034C, 0x05},
+	{IMX_8BIT, 0x034D, 0xB0},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0x48},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x303D, 0x10},
+	{IMX_8BIT, 0x303E, 0x5A},
+	{IMX_8BIT, 0x3040, 0x00},
+	{IMX_8BIT, 0x3041, 0x00},
+	{IMX_8BIT, 0x3048, 0x00},
+	{IMX_8BIT, 0x304C, 0x2F},
+	{IMX_8BIT, 0x304D, 0x02},
+	{IMX_8BIT, 0x3064, 0x92},
+	{IMX_8BIT, 0x306A, 0x10},
+	{IMX_8BIT, 0x309B, 0x00},
+	{IMX_8BIT, 0x309E, 0x41},
+	{IMX_8BIT, 0x30A0, 0x10},
+	{IMX_8BIT, 0x30A1, 0x0B},
+	{IMX_8BIT, 0x30B2, 0x00},
+	{IMX_8BIT, 0x30D5, 0x00},
+	{IMX_8BIT, 0x30D6, 0x00},
+	{IMX_8BIT, 0x30D7, 0x00},
+	{IMX_8BIT, 0x30D8, 0x00},
+	{IMX_8BIT, 0x30D9, 0x00},
+	{IMX_8BIT, 0x30DA, 0x00},
+	{IMX_8BIT, 0x30DB, 0x00},
+	{IMX_8BIT, 0x30DC, 0x00},
+	{IMX_8BIT, 0x30DD, 0x00},
+	{IMX_8BIT, 0x30DE, 0x00},
+	{IMX_8BIT, 0x3102, 0x0C},
+	{IMX_8BIT, 0x3103, 0x33},
+	{IMX_8BIT, 0x3104, 0x18},
+	{IMX_8BIT, 0x3105, 0x00},
+	{IMX_8BIT, 0x3106, 0x65},
+	{IMX_8BIT, 0x3107, 0x00},
+	{IMX_8BIT, 0x3108, 0x06},
+	{IMX_8BIT, 0x3109, 0x04},
+	{IMX_8BIT, 0x310A, 0x04},
+	{IMX_8BIT, 0x315C, 0x3D},
+	{IMX_8BIT, 0x315D, 0x3C},
+	{IMX_8BIT, 0x316E, 0x3E},
+	{IMX_8BIT, 0x316F, 0x3D},
+	/* Global timing */
+	{IMX_8BIT, 0x3304, 0x07}, /* RGTLPX[5:0] TLPX */
+	{IMX_8BIT, 0x3305, 0x06}, /* RGTCLKPREPARE[3:0] TCLK-PREPARE */
+	{IMX_8BIT, 0x3306, 0x19}, /* RGTCLKZERO[5:0] TCLK-ZERO */
+	{IMX_8BIT, 0x3307, 0x03}, /* RGTCLKPRE[5:0] TCLK-PRE */
+	{IMX_8BIT, 0x3308, 0x0F}, /* RGTCLKPOST[5:0] TCLK-POST */
+	{IMX_8BIT, 0x3309, 0x07}, /* RGTCLKTRAIL[3:0] TCLK-TRAIL */
+	{IMX_8BIT, 0x330A, 0x0C}, /* RGTHSEXIT[5:0] THS-EXIT */
+	{IMX_8BIT, 0x330B, 0x06}, /* RGTHSPREPARE[3:0] THS-PREPARE */
+	{IMX_8BIT, 0x330C, 0x0B}, /* RGTHSZERO[5:0] THS-ZERO */
+	{IMX_8BIT, 0x330D, 0x07}, /* RGTHSTRAIL[3:0] THS-TRAIL */
+	{IMX_8BIT, 0x330E, 0x03},
+	{IMX_8BIT, 0x3318, 0x62},
+	{IMX_8BIT, 0x3322, 0x09},
+	{IMX_8BIT, 0x3342, 0x00},
+	{IMX_8BIT, 0x3348, 0xE0},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0202, 0x04},
+	{IMX_8BIT, 0x0203, 0x50},
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01}, /* R */
+	{IMX_8BIT, 0x0211, 0xA0},
+	{IMX_8BIT, 0x0212, 0x02}, /* B */
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
+	{IMX_8BIT, 0x0215, 0x00},
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx132_1636x1096_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Global Settings */
+	{IMX_8BIT, 0x3087, 0x53},
+	{IMX_8BIT, 0x308B, 0x5A},
+	{IMX_8BIT, 0x3094, 0x11},
+	{IMX_8BIT, 0x309D, 0xA4},
+	{IMX_8BIT, 0x30AA, 0x01},
+	{IMX_8BIT, 0x30C6, 0x00},
+	{IMX_8BIT, 0x30C7, 0x00},
+	{IMX_8BIT, 0x3118, 0x2F},
+	{IMX_8BIT, 0x312A, 0x00},
+	{IMX_8BIT, 0x312B, 0x0B},
+	{IMX_8BIT, 0x312C, 0x0B},
+	{IMX_8BIT, 0x312D, 0x13},
+	/* PLL setting */
+	{IMX_8BIT, 0x0305, 0x02},
+	{IMX_8BIT, 0x0307, 0x50},
+	{IMX_8BIT, 0x30A4, 0x02},
+	{IMX_8BIT, 0x303C, 0x3C},
+	/* Mode setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0xAA},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x32},
+	{IMX_8BIT, 0x0348, 0x07},
+	{IMX_8BIT, 0x0349, 0x0D},
+	{IMX_8BIT, 0x034A, 0x04},
+	{IMX_8BIT, 0x034B, 0x79},
+	{IMX_8BIT, 0x034C, 0x06},
+	{IMX_8BIT, 0x034D, 0x64},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0x48},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x303D, 0x10},
+	{IMX_8BIT, 0x303E, 0x5A},
+	{IMX_8BIT, 0x3040, 0x00},
+	{IMX_8BIT, 0x3041, 0x00},
+	{IMX_8BIT, 0x3048, 0x00},
+	{IMX_8BIT, 0x304C, 0x2F},
+	{IMX_8BIT, 0x304D, 0x02},
+	{IMX_8BIT, 0x3064, 0x92},
+	{IMX_8BIT, 0x306A, 0x10},
+	{IMX_8BIT, 0x309B, 0x00},
+	{IMX_8BIT, 0x309E, 0x41},
+	{IMX_8BIT, 0x30A0, 0x10},
+	{IMX_8BIT, 0x30A1, 0x0B},
+	{IMX_8BIT, 0x30B2, 0x00},
+	{IMX_8BIT, 0x30D5, 0x00},
+	{IMX_8BIT, 0x30D6, 0x00},
+	{IMX_8BIT, 0x30D7, 0x00},
+	{IMX_8BIT, 0x30D8, 0x00},
+	{IMX_8BIT, 0x30D9, 0x00},
+	{IMX_8BIT, 0x30DA, 0x00},
+	{IMX_8BIT, 0x30DB, 0x00},
+	{IMX_8BIT, 0x30DC, 0x00},
+	{IMX_8BIT, 0x30DD, 0x00},
+	{IMX_8BIT, 0x30DE, 0x00},
+	{IMX_8BIT, 0x3102, 0x0C},
+	{IMX_8BIT, 0x3103, 0x33},
+	{IMX_8BIT, 0x3104, 0x18},
+	{IMX_8BIT, 0x3105, 0x00},
+	{IMX_8BIT, 0x3106, 0x65},
+	{IMX_8BIT, 0x3107, 0x00},
+	{IMX_8BIT, 0x3108, 0x06},
+	{IMX_8BIT, 0x3109, 0x04},
+	{IMX_8BIT, 0x310A, 0x04},
+	{IMX_8BIT, 0x315C, 0x3D},
+	{IMX_8BIT, 0x315D, 0x3C},
+	{IMX_8BIT, 0x316E, 0x3E},
+	{IMX_8BIT, 0x316F, 0x3D},
+	/* Global timing */
+	{IMX_8BIT, 0x3304, 0x07}, /* RGTLPX[5:0] TLPX */
+	{IMX_8BIT, 0x3305, 0x06}, /* RGTCLKPREPARE[3:0] TCLK-PREPARE */
+	{IMX_8BIT, 0x3306, 0x19}, /* RGTCLKZERO[5:0] TCLK-ZERO */
+	{IMX_8BIT, 0x3307, 0x03}, /* RGTCLKPRE[5:0] TCLK-PRE */
+	{IMX_8BIT, 0x3308, 0x0F}, /* RGTCLKPOST[5:0] TCLK-POST */
+	{IMX_8BIT, 0x3309, 0x07}, /* RGTCLKTRAIL[3:0] TCLK-TRAIL */
+	{IMX_8BIT, 0x330A, 0x0C}, /* RGTHSEXIT[5:0] THS-EXIT */
+	{IMX_8BIT, 0x330B, 0x06}, /* RGTHSPREPARE[3:0] THS-PREPARE */
+	{IMX_8BIT, 0x330C, 0x0B}, /* RGTHSZERO[5:0] THS-ZERO */
+	{IMX_8BIT, 0x330D, 0x07}, /* RGTHSTRAIL[3:0] THS-TRAIL */
+	{IMX_8BIT, 0x330E, 0x03},
+	{IMX_8BIT, 0x3318, 0x62},
+	{IMX_8BIT, 0x3322, 0x09},
+	{IMX_8BIT, 0x3342, 0x00},
+	{IMX_8BIT, 0x3348, 0xE0},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0202, 0x04},
+	{IMX_8BIT, 0x0203, 0x50},
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01}, /* R */
+	{IMX_8BIT, 0x0211, 0xA0},
+	{IMX_8BIT, 0x0212, 0x02}, /* B */
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
+	{IMX_8BIT, 0x0215, 0x00},
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx132_1336x1096_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Global Settings */
+	{IMX_8BIT, 0x3087, 0x53},
+	{IMX_8BIT, 0x308B, 0x5A},
+	{IMX_8BIT, 0x3094, 0x11},
+	{IMX_8BIT, 0x309D, 0xA4},
+	{IMX_8BIT, 0x30AA, 0x01},
+	{IMX_8BIT, 0x30C6, 0x00},
+	{IMX_8BIT, 0x30C7, 0x00},
+	{IMX_8BIT, 0x3118, 0x2F},
+	{IMX_8BIT, 0x312A, 0x00},
+	{IMX_8BIT, 0x312B, 0x0B},
+	{IMX_8BIT, 0x312C, 0x0B},
+	{IMX_8BIT, 0x312D, 0x13},
+	/* PLL setting */
+	{IMX_8BIT, 0x0305, 0x02},
+	{IMX_8BIT, 0x0307, 0x50},
+	{IMX_8BIT, 0x30A4, 0x02},
+	{IMX_8BIT, 0x303C, 0x3C},
+	/* Mode setting */
+	{IMX_8BIT, 0x0344, 0x01},
+	{IMX_8BIT, 0x0345, 0x2C},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x32},
+	{IMX_8BIT, 0x0348, 0x06},
+	{IMX_8BIT, 0x0349, 0x77},
+	{IMX_8BIT, 0x034A, 0x04},
+	{IMX_8BIT, 0x034B, 0x79},
+	{IMX_8BIT, 0x034C, 0x05},
+	{IMX_8BIT, 0x034D, 0x38},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0x48},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x303D, 0x10},
+	{IMX_8BIT, 0x303E, 0x5A},
+	{IMX_8BIT, 0x3040, 0x00},
+	{IMX_8BIT, 0x3041, 0x00},
+	{IMX_8BIT, 0x3048, 0x00},
+	{IMX_8BIT, 0x304C, 0x2F},
+	{IMX_8BIT, 0x304D, 0x02},
+	{IMX_8BIT, 0x3064, 0x92},
+	{IMX_8BIT, 0x306A, 0x10},
+	{IMX_8BIT, 0x309B, 0x00},
+	{IMX_8BIT, 0x309E, 0x41},
+	{IMX_8BIT, 0x30A0, 0x10},
+	{IMX_8BIT, 0x30A1, 0x0B},
+	{IMX_8BIT, 0x30B2, 0x00},
+	{IMX_8BIT, 0x30D5, 0x00},
+	{IMX_8BIT, 0x30D6, 0x00},
+	{IMX_8BIT, 0x30D7, 0x00},
+	{IMX_8BIT, 0x30D8, 0x00},
+	{IMX_8BIT, 0x30D9, 0x00},
+	{IMX_8BIT, 0x30DA, 0x00},
+	{IMX_8BIT, 0x30DB, 0x00},
+	{IMX_8BIT, 0x30DC, 0x00},
+	{IMX_8BIT, 0x30DD, 0x00},
+	{IMX_8BIT, 0x30DE, 0x00},
+	{IMX_8BIT, 0x3102, 0x0C},
+	{IMX_8BIT, 0x3103, 0x33},
+	{IMX_8BIT, 0x3104, 0x18},
+	{IMX_8BIT, 0x3105, 0x00},
+	{IMX_8BIT, 0x3106, 0x65},
+	{IMX_8BIT, 0x3107, 0x00},
+	{IMX_8BIT, 0x3108, 0x06},
+	{IMX_8BIT, 0x3109, 0x04},
+	{IMX_8BIT, 0x310A, 0x04},
+	{IMX_8BIT, 0x315C, 0x3D},
+	{IMX_8BIT, 0x315D, 0x3C},
+	{IMX_8BIT, 0x316E, 0x3E},
+	{IMX_8BIT, 0x316F, 0x3D},
+	/* Global timing */
+	{IMX_8BIT, 0x3304, 0x07}, /* RGTLPX[5:0] TLPX */
+	{IMX_8BIT, 0x3305, 0x06}, /* RGTCLKPREPARE[3:0] TCLK-PREPARE */
+	{IMX_8BIT, 0x3306, 0x19}, /* RGTCLKZERO[5:0] TCLK-ZERO */
+	{IMX_8BIT, 0x3307, 0x03}, /* RGTCLKPRE[5:0] TCLK-PRE */
+	{IMX_8BIT, 0x3308, 0x0F}, /* RGTCLKPOST[5:0] TCLK-POST */
+	{IMX_8BIT, 0x3309, 0x07}, /* RGTCLKTRAIL[3:0] TCLK-TRAIL */
+	{IMX_8BIT, 0x330A, 0x0C}, /* RGTHSEXIT[5:0] THS-EXIT */
+	{IMX_8BIT, 0x330B, 0x06}, /* RGTHSPREPARE[3:0] THS-PREPARE */
+	{IMX_8BIT, 0x330C, 0x0B}, /* RGTHSZERO[5:0] THS-ZERO */
+	{IMX_8BIT, 0x330D, 0x07}, /* RGTHSTRAIL[3:0] THS-TRAIL */
+	{IMX_8BIT, 0x330E, 0x03},
+	{IMX_8BIT, 0x3318, 0x62},
+	{IMX_8BIT, 0x3322, 0x09},
+	{IMX_8BIT, 0x3342, 0x00},
+	{IMX_8BIT, 0x3348, 0xE0},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0202, 0x04},
+	{IMX_8BIT, 0x0203, 0x50},
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01}, /* R */
+	{IMX_8BIT, 0x0211, 0xA0},
+	{IMX_8BIT, 0x0212, 0x02}, /* B */
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
+	{IMX_8BIT, 0x0215, 0x00},
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg imx132_1200p_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Global Settings */
+	{IMX_8BIT, 0x3087, 0x53},
+	{IMX_8BIT, 0x308B, 0x5A},
+	{IMX_8BIT, 0x3094, 0x11},
+	{IMX_8BIT, 0x309D, 0xA4},
+	{IMX_8BIT, 0x30AA, 0x01},
+	{IMX_8BIT, 0x30C6, 0x00},
+	{IMX_8BIT, 0x30C7, 0x00},
+	{IMX_8BIT, 0x3118, 0x2F},
+	{IMX_8BIT, 0x312A, 0x00},
+	{IMX_8BIT, 0x312B, 0x0B},
+	{IMX_8BIT, 0x312C, 0x0B},
+	{IMX_8BIT, 0x312D, 0x13},
+	/* PLL setting */
+	{IMX_8BIT, 0x0305, 0x02},
+	{IMX_8BIT, 0x0307, 0x54},
+	{IMX_8BIT, 0x30A4, 0x02},
+	{IMX_8BIT, 0x303C, 0x3C},
+	/* Mode setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x14},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x07},
+	{IMX_8BIT, 0x0349, 0xA3},
+	{IMX_8BIT, 0x034A, 0x04},
+	{IMX_8BIT, 0x034B, 0xAF},
+	{IMX_8BIT, 0x034C, 0x07},
+	{IMX_8BIT, 0x034D, 0x90},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0xB0},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x303D, 0x10},
+	{IMX_8BIT, 0x303E, 0x5A},
+	{IMX_8BIT, 0x3040, 0x00},
+	{IMX_8BIT, 0x3041, 0x00},
+	{IMX_8BIT, 0x3048, 0x00},
+	{IMX_8BIT, 0x304C, 0x2F},
+	{IMX_8BIT, 0x304D, 0x02},
+	{IMX_8BIT, 0x3064, 0x92},
+	{IMX_8BIT, 0x306A, 0x10},
+	{IMX_8BIT, 0x309B, 0x00},
+	{IMX_8BIT, 0x309E, 0x41},
+	{IMX_8BIT, 0x30A0, 0x10},
+	{IMX_8BIT, 0x30A1, 0x0B},
+	{IMX_8BIT, 0x30B2, 0x00},
+	{IMX_8BIT, 0x30D5, 0x00},
+	{IMX_8BIT, 0x30D6, 0x00},
+	{IMX_8BIT, 0x30D7, 0x00},
+	{IMX_8BIT, 0x30D8, 0x00},
+	{IMX_8BIT, 0x30D9, 0x00},
+	{IMX_8BIT, 0x30DA, 0x00},
+	{IMX_8BIT, 0x30DB, 0x00},
+	{IMX_8BIT, 0x30DC, 0x00},
+	{IMX_8BIT, 0x30DD, 0x00},
+	{IMX_8BIT, 0x30DE, 0x00},
+	{IMX_8BIT, 0x3102, 0x0C},
+	{IMX_8BIT, 0x3103, 0x33},
+	{IMX_8BIT, 0x3104, 0x18},
+	{IMX_8BIT, 0x3105, 0x00},
+	{IMX_8BIT, 0x3106, 0x65},
+	{IMX_8BIT, 0x3107, 0x00},
+	{IMX_8BIT, 0x3108, 0x06},
+	{IMX_8BIT, 0x3109, 0x04},
+	{IMX_8BIT, 0x310A, 0x04},
+	{IMX_8BIT, 0x315C, 0x3D},
+	{IMX_8BIT, 0x315D, 0x3C},
+	{IMX_8BIT, 0x316E, 0x3E},
+	{IMX_8BIT, 0x316F, 0x3D},
+	/* Global timing */
+	{IMX_8BIT, 0x3304, 0x07}, /* RGTLPX[5:0] TLPX */
+	{IMX_8BIT, 0x3305, 0x06}, /* RGTCLKPREPARE[3:0] TCLK-PREPARE */
+	{IMX_8BIT, 0x3306, 0x19}, /* RGTCLKZERO[5:0] TCLK-ZERO */
+	{IMX_8BIT, 0x3307, 0x03}, /* RGTCLKPRE[5:0] TCLK-PRE */
+	{IMX_8BIT, 0x3308, 0x0F}, /* RGTCLKPOST[5:0] TCLK-POST */
+	{IMX_8BIT, 0x3309, 0x07}, /* RGTCLKTRAIL[3:0] TCLK-TRAIL */
+	{IMX_8BIT, 0x330A, 0x0C}, /* RGTHSEXIT[5:0] THS-EXIT */
+	{IMX_8BIT, 0x330B, 0x06}, /* RGTHSPREPARE[3:0] THS-PREPARE */
+	{IMX_8BIT, 0x330C, 0x0B}, /* RGTHSZERO[5:0] THS-ZERO */
+	{IMX_8BIT, 0x330D, 0x07}, /* RGTHSTRAIL[3:0] THS-TRAIL */
+	{IMX_8BIT, 0x330E, 0x03},
+	{IMX_8BIT, 0x3318, 0x62},
+	{IMX_8BIT, 0x3322, 0x09},
+	{IMX_8BIT, 0x3342, 0x00},
+	{IMX_8BIT, 0x3348, 0xE0},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0202, 0x04},
+	{IMX_8BIT, 0x0203, 0x50},
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01}, /* Gr */
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01}, /* R */
+	{IMX_8BIT, 0x0211, 0xA0},
+	{IMX_8BIT, 0x0212, 0x02}, /* B */
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01}, /* Gb */
+	{IMX_8BIT, 0x0215, 0x00},
+
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/********************** settings for imx - reference *********************/
+static struct imx_reg const imx132_init_settings[] = {
+	/* sw reset */
+	{ IMX_8BIT, 0x0100, 0x00 },
+	{ IMX_8BIT, 0x0103, 0x01 },
+	{ IMX_TOK_DELAY, 0, 5},
+	{ IMX_8BIT, 0x0103, 0x00 },
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Global Settings */
+	{IMX_8BIT, 0x3087, 0x53},
+	{IMX_8BIT, 0x308B, 0x5A},
+	{IMX_8BIT, 0x3094, 0x11},
+	{IMX_8BIT, 0x309D, 0xA4},
+	{IMX_8BIT, 0x30AA, 0x01},
+	{IMX_8BIT, 0x30C6, 0x00},
+	{IMX_8BIT, 0x30C7, 0x00},
+	{IMX_8BIT, 0x3118, 0x2F},
+	{IMX_8BIT, 0x312A, 0x00},
+	{IMX_8BIT, 0x312B, 0x0B},
+	{IMX_8BIT, 0x312C, 0x0B},
+	{IMX_8BIT, 0x312D, 0x13},
+	GROUPED_PARAMETER_HOLD_DISABLE,
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+struct imx_resolution imx132_res_preview[] = {
+	{
+		.desc = "imx132_1080p_30fps",
+		.regs = imx132_1080p_30fps,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+	{
+		.desc = "imx132_1200p_30fps",
+		.regs = imx132_1200p_30fps,
+		.width = 1936,
+		.height = 1200,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x0966,
+				.lines_per_frame = 0x04B8,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx132_1456x1096_30fps",
+		.regs = imx132_1456x1096_30fps,
+		.width = 1456,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+};
+
+struct imx_resolution imx132_res_still[] = {
+	{
+		.desc = "imx132_1080p_30fps",
+		.regs = imx132_1080p_30fps,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+	{
+		.desc = "imx132_1200p_30fps",
+		.regs = imx132_1200p_30fps,
+		.width = 1936,
+		.height = 1200,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x0966,
+				.lines_per_frame = 0x04B8,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 403200,
+	},
+	{
+		.desc = "imx132_1456x1096_30fps",
+		.regs = imx132_1456x1096_30fps,
+		.width = 1456,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+};
+
+struct imx_resolution imx132_res_video[] = {
+	{
+		.desc = "imx132_1336x1096_30fps",
+		.regs = imx132_1336x1096_30fps,
+		.width = 1336,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+	{
+		.desc = "imx132_1456x1096_30fps",
+		.regs = imx132_1456x1096_30fps,
+		.width = 1456,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+	{
+		.desc = "imx132_1636x1096_30fps",
+		.regs = imx132_1636x1096_30fps,
+		.width = 1636,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+	{
+		.desc = "imx132_1080p_30fps",
+		.regs = imx132_1080p_30fps,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 0x08F2,
+				.lines_per_frame = 0x045C,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 2,
+		.mipi_freq = 384000,
+	},
+};
+#endif
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
new file mode 100644
index 0000000..29323b3b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx134.h
@@ -0,0 +1,2072 @@
+#ifndef __IMX134_H__
+#define __IMX134_H__
+
+/********************** imx134 setting - version 1 *********************/
+static struct imx_reg const imx134_init_settings[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Basic settings */
+	{ IMX_8BIT, 0x0105, 0x01 },
+	{ IMX_8BIT, 0x0220, 0x01 },
+	{ IMX_8BIT, 0x3302, 0x11 },
+	{ IMX_8BIT, 0x3833, 0x20 },
+	{ IMX_8BIT, 0x3893, 0x00 },
+	{ IMX_8BIT, 0x3906, 0x08 },
+	{ IMX_8BIT, 0x3907, 0x01 },
+	{ IMX_8BIT, 0x391B, 0x01 },
+	{ IMX_8BIT, 0x3C09, 0x01 },
+	{ IMX_8BIT, 0x600A, 0x00 },
+
+	/* Analog settings */
+	{ IMX_8BIT, 0x3008, 0xB0 },
+	{ IMX_8BIT, 0x320A, 0x01 },
+	{ IMX_8BIT, 0x320D, 0x10 },
+	{ IMX_8BIT, 0x3216, 0x2E },
+	{ IMX_8BIT, 0x322C, 0x02 },
+	{ IMX_8BIT, 0x3409, 0x0C },
+	{ IMX_8BIT, 0x340C, 0x2D },
+	{ IMX_8BIT, 0x3411, 0x39 },
+	{ IMX_8BIT, 0x3414, 0x1E },
+	{ IMX_8BIT, 0x3427, 0x04 },
+	{ IMX_8BIT, 0x3480, 0x1E },
+	{ IMX_8BIT, 0x3484, 0x1E },
+	{ IMX_8BIT, 0x3488, 0x1E },
+	{ IMX_8BIT, 0x348C, 0x1E },
+	{ IMX_8BIT, 0x3490, 0x1E },
+	{ IMX_8BIT, 0x3494, 0x1E },
+	{ IMX_8BIT, 0x3511, 0x8F },
+	{ IMX_8BIT, 0x3617, 0x2D },
+
+	GROUPED_PARAMETER_HOLD_DISABLE,
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane 3280x2464 8M 30fps, vendor provide */
+static struct imx_reg const imx134_8M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* clock setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },
+	{ IMX_8BIT, 0x0391, 0x11 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 }, /* down scaling 16/16 = 1 */
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /*	x_addr_start[15:8]:0	*/
+	{ IMX_8BIT, 0x0345, 0x00 },      /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x00 },      /*	y_addr_start[15:8]:0	*/
+	{ IMX_8BIT, 0x0347, 0x00 },      /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },      /*	x_addr_end[15:8]:3279	*/
+	{ IMX_8BIT, 0x0349, 0xCF },      /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x09 },      /*	y_addr_end[15:8]:2463	*/
+	{ IMX_8BIT, 0x034B, 0x9F },      /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x0C },      /*	x_output_size[15:8]: 3280*/
+	{ IMX_8BIT, 0x034D, 0xD0 },      /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x09 },      /*	y_output_size[15:8]:2464 */
+	{ IMX_8BIT, 0x034F, 0xA0 },      /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x0C },
+	{ IMX_8BIT, 0x0355, 0xD0 },
+	{ IMX_8BIT, 0x0356, 0x09 },
+	{ IMX_8BIT, 0x0357, 0xA0 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x0C },
+	{ IMX_8BIT, 0x3311, 0xD0 },
+	{ IMX_8BIT, 0x3312, 0x09 },
+	{ IMX_8BIT, 0x3313, 0xA0 },
+	{ IMX_8BIT, 0x331C, 0x01 },
+	{ IMX_8BIT, 0x331D, 0xAE },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global timing setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration time setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane, 1/2 binning 30fps 1640x1232, vendor provide */
+static struct imx_reg const imx134_1640_1232_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning */
+	{ IMX_8BIT, 0x0391, 0x22 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },	/* no resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /* x_addr_start[15:8]:0 */
+	{ IMX_8BIT, 0x0345, 0x00 },      /* x_addr_start[7:0] */
+	{ IMX_8BIT, 0x0346, 0x00 },      /* y_addr_start[15:8]:0 */
+	{ IMX_8BIT, 0x0347, 0x00 },      /* y_addr_start[7:0] */
+	{ IMX_8BIT, 0x0348, 0x0C },      /* x_addr_end[15:8]:3279 */
+	{ IMX_8BIT, 0x0349, 0xCF },      /* x_addr_end[7:0] */
+	{ IMX_8BIT, 0x034A, 0x09 },      /* y_addr_end[15:8]:2463 */
+	{ IMX_8BIT, 0x034B, 0x9F },      /* y_addr_end[7:0] */
+	{ IMX_8BIT, 0x034C, 0x06 },      /* x_output_size[15:8]:1640 */
+	{ IMX_8BIT, 0x034D, 0x68 },      /* x_output_size[7:0] */
+	{ IMX_8BIT, 0x034E, 0x04 },      /* y_output_size[15:8]:1232 */
+	{ IMX_8BIT, 0x034F, 0xD0 },      /* y_output_size[7:0] */
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x06 },
+	{ IMX_8BIT, 0x0355, 0x68 },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0xD0 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x06 },
+	{ IMX_8BIT, 0x3311, 0x68 },
+	{ IMX_8BIT, 0x3312, 0x04 },
+	{ IMX_8BIT, 0x3313, 0xD0 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0x06 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane, 1/4 binning 30fps 820x616, vendor provide */
+static struct imx_reg const imx134_820_616_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning */
+	{ IMX_8BIT, 0x0391, 0x44 },	/* 4x4 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },	/* no resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /* x_addr_start[15:8]:0 */
+	{ IMX_8BIT, 0x0345, 0x00 },      /* x_addr_start[7:0] */
+	{ IMX_8BIT, 0x0346, 0x00 },      /* y_addr_start[15:8]:0 */
+	{ IMX_8BIT, 0x0347, 0x00 },      /* y_addr_start[7:0] */
+	{ IMX_8BIT, 0x0348, 0x0C },      /* x_addr_end[15:8]:3279 */
+	{ IMX_8BIT, 0x0349, 0xCF },      /* x_addr_end[7:0] */
+	{ IMX_8BIT, 0x034A, 0x09 },      /* y_addr_end[15:8]:2463 */
+	{ IMX_8BIT, 0x034B, 0x9F },      /* y_addr_end[7:0] */
+	{ IMX_8BIT, 0x034C, 0x03 },      /* x_output_size[15:8]:820 */
+	{ IMX_8BIT, 0x034D, 0x34 },      /* x_output_size[7:0] */
+	{ IMX_8BIT, 0x034E, 0x02 },      /* y_output_size[15:8]:616 */
+	{ IMX_8BIT, 0x034F, 0x68 },      /* y_output_size[7:0] */
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x03 },
+	{ IMX_8BIT, 0x0355, 0x34 },
+	{ IMX_8BIT, 0x0356, 0x02 },
+	{ IMX_8BIT, 0x0357, 0x68 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x03 },
+	{ IMX_8BIT, 0x3311, 0x34 },
+	{ IMX_8BIT, 0x3312, 0x02 },
+	{ IMX_8BIT, 0x3313, 0x68 },
+	{ IMX_8BIT, 0x331C, 0x02 },
+	{ IMX_8BIT, 0x331D, 0xD0 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane, 1/4 binning 30fps 720x592 */
+static struct imx_reg const imx134_720_592_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning */
+	{ IMX_8BIT, 0x0391, 0x44 },	/* 4x4 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },	/* no resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /* x_addr_start[15:8]:200 */
+	{ IMX_8BIT, 0x0345, 0xC8 },      /* x_addr_start[7:0] */
+	{ IMX_8BIT, 0x0346, 0x00 },      /* y_addr_start[15:8]:40 */
+	{ IMX_8BIT, 0x0347, 0x28 },      /* y_addr_start[7:0] */
+	{ IMX_8BIT, 0x0348, 0x0C },      /* x_addr_end[15:8]:2880+200-1 */
+	{ IMX_8BIT, 0x0349, 0x07 },      /* x_addr_end[7:0] */
+	{ IMX_8BIT, 0x034A, 0x09 },      /* y_addr_end[15:8]:2368+40-1 */
+	{ IMX_8BIT, 0x034B, 0x67 },      /* y_addr_end[7:0] */
+	{ IMX_8BIT, 0x034C, 0x02 },      /* x_output_size[15:8]: */
+	{ IMX_8BIT, 0x034D, 0xD0 },      /* x_output_size[7:0] */
+	{ IMX_8BIT, 0x034E, 0x02 },      /* y_output_size[15:8]:616 */
+	{ IMX_8BIT, 0x034F, 0x50 },      /* y_output_size[7:0] */
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x02 },
+	{ IMX_8BIT, 0x0355, 0xD0 },
+	{ IMX_8BIT, 0x0356, 0x02 },
+	{ IMX_8BIT, 0x0357, 0x50 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x02 },
+	{ IMX_8BIT, 0x3311, 0xD0 },
+	{ IMX_8BIT, 0x3312, 0x02 },
+	{ IMX_8BIT, 0x3313, 0x50 },
+	{ IMX_8BIT, 0x331C, 0x02 },
+	{ IMX_8BIT, 0x331D, 0xD0 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane, 1/4 binning, 16/35 down scaling, 30fps, dvs */
+static struct imx_reg const imx134_240_196_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/*4x4 binning */
+	{ IMX_8BIT, 0x0391, 0x44 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },	/* resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x23 },	/* down scaling = 16/35 */
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x02 },      /* x_addr_start[15:8]:590 */
+	{ IMX_8BIT, 0x0345, 0x4E },      /* x_addr_start[7:0] */
+	{ IMX_8BIT, 0x0346, 0x01 },      /* y_addr_start[15:8]:366 */
+	{ IMX_8BIT, 0x0347, 0x6E },      /* y_addr_start[7:0] */
+	{ IMX_8BIT, 0x0348, 0x0A },      /* x_addr_end[15:8]:2104+590-1 */
+	{ IMX_8BIT, 0x0349, 0x85 },      /* x_addr_end[7:0] */
+	{ IMX_8BIT, 0x034A, 0x08 },      /* y_addr_end[15:8]:1720+366-1 */
+	{ IMX_8BIT, 0x034B, 0x25 },      /* y_addr_end[7:0] */
+	{ IMX_8BIT, 0x034C, 0x00 },      /* x_output_size[15:8]: 240*/
+	{ IMX_8BIT, 0x034D, 0xF0 },      /* x_output_size[7:0] */
+	{ IMX_8BIT, 0x034E, 0x00 },      /* y_output_size[15:8]:196 */
+	{ IMX_8BIT, 0x034F, 0xC4 },      /* y_output_size[7:0] */
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x02 },	/* crop_x: 526 */
+	{ IMX_8BIT, 0x0355, 0x0E },
+	{ IMX_8BIT, 0x0356, 0x01 },	/* crop_y: 430 */
+	{ IMX_8BIT, 0x0357, 0xAE },
+
+	{ IMX_8BIT, 0x301D, 0x30 },
+
+	{ IMX_8BIT, 0x3310, 0x00 },
+	{ IMX_8BIT, 0x3311, 0xF0 },
+	{ IMX_8BIT, 0x3312, 0x00 },
+	{ IMX_8BIT, 0x3313, 0xC4 },
+
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0x4C },
+
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0xF0 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0xC4 },
+
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x0A },
+	{ IMX_8BIT, 0x0203, 0x88 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane, 1/2 binning, 16/38 downscaling, 30fps, dvs */
+static struct imx_reg const imx134_448_366_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },	/* resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x26 },	/* down scaling = 16/38 */
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x02 },      /* x_addr_start[15:8]:590 */
+	{ IMX_8BIT, 0x0345, 0x4E },      /* x_addr_start[7:0] */
+	{ IMX_8BIT, 0x0346, 0x01 },      /* y_addr_start[15:8]:366 */
+	{ IMX_8BIT, 0x0347, 0x6E },      /* y_addr_start[7:0] */
+	{ IMX_8BIT, 0x0348, 0x0A },      /* x_addr_end[15:8]:2128+590-1 */
+	{ IMX_8BIT, 0x0349, 0x9D },      /* x_addr_end[7:0] */
+	{ IMX_8BIT, 0x034A, 0x08 },      /* y_addr_end[15:8]:1740+366-1 */
+	{ IMX_8BIT, 0x034B, 0x39 },      /* y_addr_end[7:0] */
+	{ IMX_8BIT, 0x034C, 0x01 },      /* x_output_size[15:8]: 448*/
+	{ IMX_8BIT, 0x034D, 0xC0 },      /* x_output_size[7:0] */
+	{ IMX_8BIT, 0x034E, 0x01 },      /* y_output_size[15:8]:366 */
+	{ IMX_8BIT, 0x034F, 0x6E },      /* y_output_size[7:0] */
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x04 },	/* crop_x: 1064 */
+	{ IMX_8BIT, 0x0355, 0x28 },
+	{ IMX_8BIT, 0x0356, 0x03 },	/* crop_y: 870 */
+	{ IMX_8BIT, 0x0357, 0x66 },
+
+	{ IMX_8BIT, 0x301D, 0x30 },
+
+	{ IMX_8BIT, 0x3310, 0x01 },
+	{ IMX_8BIT, 0x3311, 0xC0 },
+	{ IMX_8BIT, 0x3312, 0x01 },
+	{ IMX_8BIT, 0x3313, 0x6E },
+
+	{ IMX_8BIT, 0x331C, 0x02 },
+	{ IMX_8BIT, 0x331D, 0xD0 },
+
+	{ IMX_8BIT, 0x4084, 0x01 },
+	{ IMX_8BIT, 0x4085, 0xC0 },
+	{ IMX_8BIT, 0x4086, 0x01 },
+	{ IMX_8BIT, 0x4087, 0x6E },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane 2336x1312, 30fps, for 1080p dvs,  vendor provide */
+static struct imx_reg const imx134_2336_1312_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },	/* disable binning */
+	{ IMX_8BIT, 0x0391, 0x11 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x16 },	/* down scaling = 16/22 = 8/11 */
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },  /*	x_addr_start[15:8]:34	*/
+	{ IMX_8BIT, 0x0345, 0x22 },  /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x01 },  /*	y_addr_start[15:8]:332	*/
+	{ IMX_8BIT, 0x0347, 0x4C },  /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },  /*	x_addr_end[15:8]:3245	*/
+	{ IMX_8BIT, 0x0349, 0xAD },  /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x08 },  /*	y_addr_end[15:8]:2135	*/
+	{ IMX_8BIT, 0x034B, 0x57 },  /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x09 },  /*	x_output_size[15:8]:2336 */
+	{ IMX_8BIT, 0x034D, 0x20 },  /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x05 },  /*	y_output_size[15:8]:1312 */
+	{ IMX_8BIT, 0x034F, 0x20 },  /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x0C },
+	{ IMX_8BIT, 0x0355, 0x8C },
+	{ IMX_8BIT, 0x0356, 0x07 },
+	{ IMX_8BIT, 0x0357, 0x0C },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x09 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x05 },
+	{ IMX_8BIT, 0x3313, 0x20 },
+	{ IMX_8BIT, 0x331C, 0x03 },
+	{ IMX_8BIT, 0x331D, 0xEB },
+	{ IMX_8BIT, 0x4084, 0x09 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x05 },
+	{ IMX_8BIT, 0x4087, 0x20 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane 1920x1080, 30fps, for 720p still capture */
+static struct imx_reg const imx134_1936_1096_30fps_v1[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },	/* disable binning */
+	{ IMX_8BIT, 0x0391, 0x11 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x1A },	/* downscaling 16/26*/
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },  /*	x_addr_start[15:8]:64	*/
+	{ IMX_8BIT, 0x0345, 0x40 },  /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x01 },  /*	y_addr_start[15:8]:340	*/
+	{ IMX_8BIT, 0x0347, 0x54 },  /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },  /*	x_addr_end[15:8]:3209	*/
+	{ IMX_8BIT, 0x0349, 0x89 },  /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x08 },  /*	y_addr_end[15:8]:2121	*/
+	{ IMX_8BIT, 0x034B, 0x49 },  /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x07 },  /*	x_output_size[15:8]:1936 */
+	{ IMX_8BIT, 0x034D, 0x90 },  /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x04 },  /*	y_output_size[15:8]:1096 */
+	{ IMX_8BIT, 0x034F, 0x48 },  /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x0C }, /* crop x:3146 */
+	{ IMX_8BIT, 0x0355, 0x4A },
+	{ IMX_8BIT, 0x0356, 0x06 }, /* xrop y:1782 */
+	{ IMX_8BIT, 0x0357, 0xF6 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x07 },
+	{ IMX_8BIT, 0x3311, 0x80 },
+	{ IMX_8BIT, 0x3312, 0x04 },
+	{ IMX_8BIT, 0x3313, 0x38 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0x1E },
+	{ IMX_8BIT, 0x4084, 0x07 },
+	{ IMX_8BIT, 0x4085, 0x80 },
+	{ IMX_8BIT, 0x4086, 0x04 },
+	{ IMX_8BIT, 0x4087, 0x38 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane 1920x1080, 30fps, for 720p still capture,  vendor provide */
+static struct imx_reg const imx134_1936_1096_30fps_v2[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 }, /* disable binning */
+	{ IMX_8BIT, 0x0391, 0x11 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 }, /* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x1B }, /* downscaling 16/27*/
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* Optionnal Function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },  /*	x_addr_start[15:8]:64	*/
+	{ IMX_8BIT, 0x0345, 0x06 },  /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x01 },  /*	y_addr_start[15:8]:340	*/
+	{ IMX_8BIT, 0x0347, 0x34 },  /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },  /*	x_addr_end[15:8]:3209	*/
+	{ IMX_8BIT, 0x0349, 0xC9 },  /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x08 },  /*	y_addr_end[15:8]:2121	*/
+	{ IMX_8BIT, 0x034B, 0x6F },  /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x07 },  /*	x_output_size[15:8]:1936 */
+	{ IMX_8BIT, 0x034D, 0x90 },  /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x04 },  /*	y_output_size[15:8]:1096 */
+	{ IMX_8BIT, 0x034F, 0x48 },  /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x0C }, /* crop x:3146 */
+	{ IMX_8BIT, 0x0355, 0xC4 },
+	{ IMX_8BIT, 0x0356, 0x07 }, /* xrop y:1782 */
+	{ IMX_8BIT, 0x0357, 0x3A },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x07 }, /* decide by mode and output size */
+	{ IMX_8BIT, 0x3311, 0x90 },
+	{ IMX_8BIT, 0x3312, 0x04 },
+	{ IMX_8BIT, 0x3313, 0x48 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0x1E },
+	{ IMX_8BIT, 0x4084, 0x07 },
+	{ IMX_8BIT, 0x4085, 0x90 },
+	{ IMX_8BIT, 0x4086, 0x04 },
+	{ IMX_8BIT, 0x4087, 0x48 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane 1296x736, 30fps, for 720p still capture,  vendor provide */
+static struct imx_reg const imx134_1296_736_30fps_v2[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning */
+	{ IMX_8BIT, 0x0391, 0x22 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x14 },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* OptionnalFunction settig */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /*	x_addr_start[15:8]:40	*/
+	{ IMX_8BIT, 0x0345, 0x14 },      /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x01 },      /*	y_addr_start[15:8]:332	*/
+	{ IMX_8BIT, 0x0347, 0x38 },      /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },      /*	x_addr_end[15:8]:3239	*/
+	{ IMX_8BIT, 0x0349, 0xBB },      /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x08 },      /*	y_addr_end[15:8]:2131	*/
+	{ IMX_8BIT, 0x034B, 0x67 },      /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x05 },      /*	x_output_size[15:8]:1280 */
+	{ IMX_8BIT, 0x034D, 0x10 },      /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x02 },      /*	y_output_size[15:8]:720 */
+	{ IMX_8BIT, 0x034F, 0xE0 },      /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x06 },
+	{ IMX_8BIT, 0x0355, 0x54 },
+	{ IMX_8BIT, 0x0356, 0x03 },
+	{ IMX_8BIT, 0x0357, 0x98 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x05 },
+	{ IMX_8BIT, 0x3311, 0x10 },
+	{ IMX_8BIT, 0x3312, 0x02 },
+	{ IMX_8BIT, 0x3313, 0xE0 },
+	{ IMX_8BIT, 0x331C, 0x01 },
+	{ IMX_8BIT, 0x331D, 0x10 },
+	{ IMX_8BIT, 0x4084, 0x05 },
+	{ IMX_8BIT, 0x4085, 0x10 },
+	{ IMX_8BIT, 0x4086, 0x02 },
+	{ IMX_8BIT, 0x4087, 0xE0 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Settin */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+/* 4 lane 1280x720, 30fps, for 720p dvs,  vendor provide */
+static struct imx_reg const imx134_1568_880_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xA9 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning*/
+	{ IMX_8BIT, 0x0391, 0x22 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },	/* down scaling 16/16 = 1 */
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* OptionnalFunction settig */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /*	x_addr_start[15:8]:72	*/
+	{ IMX_8BIT, 0x0345, 0x48 },      /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x01 },      /*	y_addr_start[15:8]:356	*/
+	{ IMX_8BIT, 0x0347, 0x64 },      /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },      /*	x_addr_end[15:8]:3207	*/
+	{ IMX_8BIT, 0x0349, 0x87 },      /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x08 },      /*	y_addr_end[15:8]:2115	*/
+	{ IMX_8BIT, 0x034B, 0x43 },      /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x06 },      /*	x_output_size[15:8]:1568 */
+	{ IMX_8BIT, 0x034D, 0x20 },      /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x03 },      /*	y_output_size[15:8]:880 */
+	{ IMX_8BIT, 0x034F, 0x70 },      /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x06 },
+	{ IMX_8BIT, 0x0355, 0x20 },
+	{ IMX_8BIT, 0x0356, 0x03 },
+	{ IMX_8BIT, 0x0357, 0x70 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x06 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x03 },
+	{ IMX_8BIT, 0x3313, 0x70 },
+	{ IMX_8BIT, 0x331C, 0x03 },
+	{ IMX_8BIT, 0x331D, 0xF2 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Settin */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+static struct imx_reg const imx134_1568_876_60fps_0625[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0x8F },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning*/
+	{ IMX_8BIT, 0x0391, 0x22 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },	/* down scaling 16/16 = 1 */
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* OptionnalFunction settig */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /*	x_addr_start[15:8]:72	*/
+	{ IMX_8BIT, 0x0345, 0x48 },      /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x01 },      /*	y_addr_start[15:8]:356	*/
+	{ IMX_8BIT, 0x0347, 0x64 },      /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },      /*	x_addr_end[15:8]:3207	*/
+	{ IMX_8BIT, 0x0349, 0x87 },      /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x08 },      /*	y_addr_end[15:8]:2115	*/
+	{ IMX_8BIT, 0x034B, 0x3B },      /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x06 },      /*	x_output_size[15:8]:1568 */
+	{ IMX_8BIT, 0x034D, 0x20 },      /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x03 },      /*	y_output_size[15:8]:880 */
+	{ IMX_8BIT, 0x034F, 0x6C },      /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x06 },
+	{ IMX_8BIT, 0x0355, 0x20 },
+	{ IMX_8BIT, 0x0356, 0x03 },
+	{ IMX_8BIT, 0x0357, 0x6C },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x06 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x03 },
+	{ IMX_8BIT, 0x3313, 0x6C },
+	{ IMX_8BIT, 0x331C, 0x03 },
+	{ IMX_8BIT, 0x331D, 0xF2 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x6F },
+	{ IMX_8BIT, 0x0831, 0x27 },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x2F },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x2F },
+	{ IMX_8BIT, 0x0836, 0x9F },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Settin */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+
+/* 4 lane for 720p dvs,  vendor provide */
+static struct imx_reg const imx134_1568_880[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xC8 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning*/
+	{ IMX_8BIT, 0x0391, 0x22 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },	/* down scaling 16/16 = 1 */
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* OptionnalFunction settig */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /*	x_addr_start[15:8]:72	*/
+	{ IMX_8BIT, 0x0345, 0x48 },      /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x01 },      /*	y_addr_start[15:8]:356	*/
+	{ IMX_8BIT, 0x0347, 0x64 },      /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },      /*	x_addr_end[15:8]:3207	*/
+	{ IMX_8BIT, 0x0349, 0x87 },      /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x08 },      /*	y_addr_end[15:8]:2115	*/
+	{ IMX_8BIT, 0x034B, 0x43 },      /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x06 },      /*	x_output_size[15:8]:1568 */
+	{ IMX_8BIT, 0x034D, 0x20 },      /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x03 },      /*	y_output_size[15:8]:880 */
+	{ IMX_8BIT, 0x034F, 0x70 },      /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x06 },
+	{ IMX_8BIT, 0x0355, 0x20 },
+	{ IMX_8BIT, 0x0356, 0x03 },
+	{ IMX_8BIT, 0x0357, 0x70 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x06 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x03 },
+	{ IMX_8BIT, 0x3313, 0x70 },
+	{ IMX_8BIT, 0x331C, 0x03 },
+	{ IMX_8BIT, 0x331D, 0xF2 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x5F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x37 },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xBF },
+	{ IMX_8BIT, 0x0837, 0x3F },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+
+	/* Integration Time Settin */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0xD2 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+/* 4 lane for 480p dvs, default 60fps,  vendor provide */
+static struct imx_reg const imx134_880_592[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* mode set clear */
+	{ IMX_8BIT, 0x3A43, 0x01 },
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xC8 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },	/* binning*/
+	{ IMX_8BIT, 0x0391, 0x22 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x1D },	/* downscaling ratio = 16/29 */
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* OptionnalFunction settig */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x00 },      /*	x_addr_start[15:8]:44	*/
+	{ IMX_8BIT, 0x0345, 0x2C },      /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x00 },      /*	y_addr_start[15:8]:160	*/
+	{ IMX_8BIT, 0x0347, 0xA0 },      /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0C },      /*	x_addr_end[15:8]:3235	*/
+	{ IMX_8BIT, 0x0349, 0xA3 },      /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x09 },      /*	y_addr_end[15:8]:2307	*/
+	{ IMX_8BIT, 0x034B, 0x03 },      /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x03 },      /*	x_output_size[15:8]:880 */
+	{ IMX_8BIT, 0x034D, 0x70 },      /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x02 },      /*	y_output_size[15:8]:592 */
+	{ IMX_8BIT, 0x034F, 0x50 },      /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x06 },
+	{ IMX_8BIT, 0x0355, 0x3C },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0x32 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x03 },
+	{ IMX_8BIT, 0x3311, 0x70 },
+	{ IMX_8BIT, 0x3312, 0x02 },
+	{ IMX_8BIT, 0x3313, 0x50 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0x4C },
+	{ IMX_8BIT, 0x4084, 0x03 },
+	{ IMX_8BIT, 0x4085, 0x70 },
+	{ IMX_8BIT, 0x4086, 0x02 },
+	{ IMX_8BIT, 0x4087, 0x50 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x5F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x37 },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xBF },
+	{ IMX_8BIT, 0x0837, 0x3F },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+
+	/* Integration Time Settin */
+	{ IMX_8BIT, 0x0202, 0x05 },
+	{ IMX_8BIT, 0x0203, 0x42 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+static struct imx_reg const imx134_2336_1308_60fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0C },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0xC8 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+
+	/* Mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },	/* binning*/
+	{ IMX_8BIT, 0x0391, 0x11 },	/* 2x2 binning */
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },	/* H/V resize */
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },	/* down scaling 16/16 = 1 */
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+
+	/* OptionnalFunction settig */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+
+	/* Size setting */
+	{ IMX_8BIT, 0x0344, 0x01 },      /*	x_addr_start[15:8]:72	*/
+	{ IMX_8BIT, 0x0345, 0xD8 },      /*	x_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0346, 0x02 },      /*	y_addr_start[15:8]:356	*/
+	{ IMX_8BIT, 0x0347, 0x44 },      /*	y_addr_start[7:0]	*/
+	{ IMX_8BIT, 0x0348, 0x0A },      /*	x_addr_end[15:8]:3207	*/
+	{ IMX_8BIT, 0x0349, 0xF7 },      /*	x_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034A, 0x07 },      /*	y_addr_end[15:8]:2107	*/
+	{ IMX_8BIT, 0x034B, 0x5F+4 },      /*	y_addr_end[7:0]		*/
+	{ IMX_8BIT, 0x034C, 0x09 },      /*	x_output_size[15:8]:1568 */
+	{ IMX_8BIT, 0x034D, 0x20 },      /*	x_output_size[7:0]	*/
+	{ IMX_8BIT, 0x034E, 0x05 },      /*	y_output_size[15:8]:876 */
+	{ IMX_8BIT, 0x034F, 0x1C+4 },      /*	y_output_size[7:0]	*/
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x09 },
+	{ IMX_8BIT, 0x0355, 0x20 },
+	{ IMX_8BIT, 0x0356, 0x05 },
+	{ IMX_8BIT, 0x0357, 0x1C+4 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x09 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x05 },
+	{ IMX_8BIT, 0x3313, 0x1C+4 },
+	{ IMX_8BIT, 0x331C, 0x03 },
+	{ IMX_8BIT, 0x331D, 0xE8 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+
+	/* Global Timing Setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	{ IMX_8BIT, 0x0831, 0x2F },
+	{ IMX_8BIT, 0x0832, 0x5F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x37 },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xBF },
+	{ IMX_8BIT, 0x0837, 0x3F },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+
+	/* Integration Time Settin */
+	{ IMX_8BIT, 0x0202, 0x05 },
+	{ IMX_8BIT, 0x0203, 0x42 },
+
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+	{ IMX_TOK_TERM, 0, 0 }
+};
+
+struct imx_resolution imx134_res_preview[] = {
+	{
+		.desc = "imx134_CIF_30fps",
+		.regs = imx134_720_592_30fps,
+		.width = 720,
+		.height = 592,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_820_616_preview_30fps",
+		.regs = imx134_820_616_30fps,
+		.width = 820,
+		.height = 616,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_1080p_preview_30fps",
+		.regs = imx134_1936_1096_30fps_v2,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_1640_1232_preview_30fps",
+		.regs = imx134_1640_1232_30fps,
+		.width = 1640,
+		.height = 1232,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_8M_preview_30fps",
+		.regs = imx134_8M_30fps,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+struct imx_resolution imx134_res_still[] = {
+	{
+		.desc = "imx134_CIF_30fps",
+		.regs = imx134_720_592_30fps,
+		.width = 720,
+		.height = 592,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_VGA_still_30fps",
+		.regs = imx134_820_616_30fps,
+		.width = 820,
+		.height = 616,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_1080p_still_30fps",
+		.regs = imx134_1936_1096_30fps_v2,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_1640_1232_still_30fps",
+		.regs = imx134_1640_1232_30fps,
+		.width = 1640,
+		.height = 1232,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_8M_still_30fps",
+		.regs = imx134_8M_30fps,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+                        {
+				/* WORKAROUND for FW performance limitation */
+                                 .fps = 8,
+                                 .pixels_per_line = 6400,
+                                 .lines_per_frame = 5312,
+                        },
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+struct imx_resolution imx134_res_video[] = {
+	{
+		.desc = "imx134_QCIF_DVS_30fps",
+		.regs = imx134_240_196_30fps,
+		.width = 240,
+		.height = 196,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_CIF_DVS_30fps",
+		.regs = imx134_448_366_30fps,
+		.width = 448,
+		.height = 366,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_VGA_30fps",
+		.regs = imx134_820_616_30fps,
+		.width = 820,
+		.height = 616,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_480p",
+		.regs = imx134_880_592,
+		.width = 880,
+		.height = 592,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2700,
+			},
+			{
+				 .fps = 60,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 1350,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_1568_880",
+		.regs = imx134_1568_880,
+		.width = 1568,
+		.height = 880,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2700,
+			},
+			{
+				 .fps = 60,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 1350,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_1080p_dvs_30fps",
+		.regs = imx134_2336_1312_30fps,
+		.width = 2336,
+		.height = 1312,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 2518,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx134_1080p_dvs_60fps",
+		.regs = imx134_2336_1308_60fps,
+		.width = 2336,
+		.height = 1312,
+		.fps_options = {
+			{
+				 .fps = 60,
+				 .pixels_per_line = 3600,
+				 .lines_per_frame = 1350,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+#endif
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h
new file mode 100644
index 0000000..c58e6a6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135.h
@@ -0,0 +1,2599 @@
+/*
+ * Support for Sony IMX camera sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IMX135_H__
+#define __IMX135_H__
+
+#include "common.h"
+
+#define IMX_SC_CMMN_CHIP_ID_H	0x0016
+#define IMX_SC_CMMN_CHIP_ID_L	0x0017
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_FOCAL_LENGTH_DEFAULT 0x1710064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_F_NUMBER_DEFAULT 0x16000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define IMX_F_NUMBER_RANGE 0x160a160a
+
+#define GROUPED_PARAMETER_HOLD_ENABLE  {IMX_8BIT, 0x0104, 0x1}
+#define GROUPED_PARAMETER_HOLD_DISABLE  {IMX_8BIT, 0x0104, 0x0}
+
+/*
+ * We use three different MIPI rates for our modes based on the resolution and
+ * FPS requirements. So we have three PLL configurationa and these are based
+ * on the EMC friendly MIPI values.
+ *
+ * Maximum clock: Pix clock @ 360.96MHz MIPI @ 451.2MHz 902.4mbps
+ * Reduced clock: Pix clock @ 273.00MHz MIPI @ 342.0MHz 684.0mbps
+ * Binning modes: Pix clock @ 335.36MHz MIPI @ 209.6MHz 419.2mbps
+ * Global Timing registers are based on the data rates and these are part of
+ * the below clock definitions.
+ */
+/* MIPI 499.2MHz 998.4mbps PIXCLK: 399.36MHz */
+#define PLL_SETTINGS_FOR_MIPI_499_2MHZ_SALTBAY \
+	{IMX_8BIT, 0x011e, 0x13}, \
+	{IMX_8BIT, 0x011f, 0x33}, \
+	{IMX_8BIT, 0x0301, 0x05}, \
+	{IMX_8BIT, 0x0303, 0x01}, \
+	{IMX_8BIT, 0x0305, 0x0c}, \
+	{IMX_8BIT, 0x0309, 0x05}, \
+	{IMX_8BIT, 0x030b, 0x01}, \
+	{IMX_8BIT, 0x030c, 0x02}, \
+	{IMX_8BIT, 0x030d, 0x70}, \
+	{IMX_8BIT, 0x030e, 0x01}, \
+	{IMX_8BIT, 0x3a06, 0x11}, \
+	{IMX_8BIT, 0x0830, 0x7f}, \
+	{IMX_8BIT, 0x0831, 0x37}, \
+	{IMX_8BIT, 0x0832, 0x67}, \
+	{IMX_8BIT, 0x0833, 0x3f}, \
+	{IMX_8BIT, 0x0834, 0x3f}, \
+	{IMX_8BIT, 0x0835, 0x47}, \
+	{IMX_8BIT, 0x0836, 0xdf}, \
+	{IMX_8BIT, 0x0837, 0x47}, \
+	{IMX_8BIT, 0x0839, 0x1f}, \
+	{IMX_8BIT, 0x083a, 0x17}, \
+	{IMX_8BIT, 0x083b, 0x02}
+
+/* MIPI 451.2MHz 902.4mbps PIXCLK: 360.96MHz */
+#define PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY \
+	{IMX_8BIT, 0x011e, 0x13}, \
+	{IMX_8BIT, 0x011f, 0x33}, \
+	{IMX_8BIT, 0x0301, 0x05}, \
+	{IMX_8BIT, 0x0303, 0x01}, \
+	{IMX_8BIT, 0x0305, 0x0c}, \
+	{IMX_8BIT, 0x0309, 0x05}, \
+	{IMX_8BIT, 0x030b, 0x01}, \
+	{IMX_8BIT, 0x030c, 0x02}, \
+	{IMX_8BIT, 0x030d, 0x34}, \
+	{IMX_8BIT, 0x030e, 0x01}, \
+	{IMX_8BIT, 0x3a06, 0x11}, \
+	{IMX_8BIT, 0x0830, 0x7f}, \
+	{IMX_8BIT, 0x0831, 0x37}, \
+	{IMX_8BIT, 0x0832, 0x67}, \
+	{IMX_8BIT, 0x0833, 0x3f}, \
+	{IMX_8BIT, 0x0834, 0x3f}, \
+	{IMX_8BIT, 0x0835, 0x47}, \
+	{IMX_8BIT, 0x0836, 0xdf}, \
+	{IMX_8BIT, 0x0837, 0x47}, \
+	{IMX_8BIT, 0x0839, 0x1f}, \
+	{IMX_8BIT, 0x083a, 0x17}, \
+	{IMX_8BIT, 0x083b, 0x02}
+
+/* MIPI 209.6MHz, 419.2mbps PIXCLK: 335.36 MHz */
+#define PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY \
+	{IMX_8BIT, 0x011e, 0x13}, \
+	{IMX_8BIT, 0x011f, 0x33}, \
+	{IMX_8BIT, 0x0301, 0x05}, \
+	{IMX_8BIT, 0x0303, 0x01}, \
+	{IMX_8BIT, 0x0305, 0x06}, \
+	{IMX_8BIT, 0x0309, 0x05}, \
+	{IMX_8BIT, 0x030b, 0x02}, \
+	{IMX_8BIT, 0x030c, 0x01}, \
+	{IMX_8BIT, 0x030d, 0x06}, \
+	{IMX_8BIT, 0x030e, 0x01}, \
+	{IMX_8BIT, 0x3a06, 0x12}, \
+	{IMX_8BIT, 0x0830, 0x5f}, \
+	{IMX_8BIT, 0x0831, 0x1f}, \
+	{IMX_8BIT, 0x0832, 0x3f}, \
+	{IMX_8BIT, 0x0833, 0x1f}, \
+	{IMX_8BIT, 0x0834, 0x1f}, \
+	{IMX_8BIT, 0x0835, 0x17}, \
+	{IMX_8BIT, 0x0836, 0x67}, \
+	{IMX_8BIT, 0x0837, 0x27}, \
+	{IMX_8BIT, 0x0839, 0x1f}, \
+	{IMX_8BIT, 0x083a, 0x17}, \
+	{IMX_8BIT, 0x083b, 0x02}
+
+/* MIPI 342MHz 684mbps PIXCLK: 273.6MHz */
+#define PLL_SETTINGS_FOR_MIPI_342MHZ_SALTBAY \
+	{IMX_8BIT, 0x011e, 0x13}, \
+	{IMX_8BIT, 0x011f, 0x33}, \
+	{IMX_8BIT, 0x0301, 0x05}, \
+	{IMX_8BIT, 0x0303, 0x01}, \
+	{IMX_8BIT, 0x0305, 0x08}, \
+	{IMX_8BIT, 0x0309, 0x05}, \
+	{IMX_8BIT, 0x030b, 0x01}, \
+	{IMX_8BIT, 0x030c, 0x01}, \
+	{IMX_8BIT, 0x030d, 0x1d}, \
+	{IMX_8BIT, 0x030e, 0x01}, \
+	{IMX_8BIT, 0x3a06, 0x11}, \
+	{IMX_8BIT, 0x0830, 0x77}, \
+	{IMX_8BIT, 0x0831, 0x2f}, \
+	{IMX_8BIT, 0x0832, 0x4f}, \
+	{IMX_8BIT, 0x0833, 0x37}, \
+	{IMX_8BIT, 0x0834, 0x2f}, \
+	{IMX_8BIT, 0x0835, 0x37}, \
+	{IMX_8BIT, 0x0836, 0xa7}, \
+	{IMX_8BIT, 0x0837, 0x37}, \
+	{IMX_8BIT, 0x0839, 0x1f}, \
+	{IMX_8BIT, 0x083a, 0x17}, \
+	{IMX_8BIT, 0x083b, 0x02}
+
+/* Basic settings: Applied only once after the sensor power up */
+static struct imx_reg const imx135_init_settings[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x0220, 0x01},
+	{ IMX_8BIT, 0x3008, 0xB0},
+	{ IMX_8BIT, 0x320A, 0x01},
+	{ IMX_8BIT, 0x320D, 0x10},
+	{ IMX_8BIT, 0x3216, 0x2E},
+	{ IMX_8BIT, 0x3230, 0x0A},
+	{ IMX_8BIT, 0x3228, 0x05},
+	{ IMX_8BIT, 0x3229, 0x02},
+	{ IMX_8BIT, 0x322C, 0x02},
+	{ IMX_8BIT, 0x3302, 0x10},
+	{ IMX_8BIT, 0x3390, 0x45},
+	{ IMX_8BIT, 0x3409, 0x0C},
+	{ IMX_8BIT, 0x340B, 0xF5},
+	{ IMX_8BIT, 0x340C, 0x2D},
+	{ IMX_8BIT, 0x3412, 0x41},
+	{ IMX_8BIT, 0x3413, 0xAD},
+	{ IMX_8BIT, 0x3414, 0x1E},
+	{ IMX_8BIT, 0x3427, 0x04},
+	{ IMX_8BIT, 0x3480, 0x1E},
+	{ IMX_8BIT, 0x3484, 0x1E},
+	{ IMX_8BIT, 0x3488, 0x1E},
+	{ IMX_8BIT, 0x348C, 0x1E},
+	{ IMX_8BIT, 0x3490, 0x1E},
+	{ IMX_8BIT, 0x3494, 0x1E},
+	{ IMX_8BIT, 0x349C, 0x38},
+	{ IMX_8BIT, 0x34A3, 0x38},
+	{ IMX_8BIT, 0x3511, 0x8F},
+	{ IMX_8BIT, 0x3518, 0x00},
+	{ IMX_8BIT, 0x3519, 0x94},
+	{ IMX_8BIT, 0x3833, 0x20},
+	{ IMX_8BIT, 0x3893, 0x01},
+	{ IMX_8BIT, 0x38C2, 0x08},
+	{ IMX_8BIT, 0x38C3, 0x08},
+	{ IMX_8BIT, 0x3C09, 0x01},
+	{ IMX_8BIT, 0x4000, 0x0E},
+	{ IMX_8BIT, 0x4300, 0x00},
+	{ IMX_8BIT, 0x4316, 0x12},
+	{ IMX_8BIT, 0x4317, 0x22},
+	{ IMX_8BIT, 0x4318, 0x00},
+	{ IMX_8BIT, 0x4319, 0x00},
+	{ IMX_8BIT, 0x431A, 0x00},
+	{ IMX_8BIT, 0x4324, 0x03},
+	{ IMX_8BIT, 0x4325, 0x20},
+	{ IMX_8BIT, 0x4326, 0x03},
+	{ IMX_8BIT, 0x4327, 0x84},
+	{ IMX_8BIT, 0x4328, 0x03},
+	{ IMX_8BIT, 0x4329, 0x20},
+	{ IMX_8BIT, 0x432A, 0x03},
+	{ IMX_8BIT, 0x432B, 0x84},
+	{ IMX_8BIT, 0x432C, 0x01},
+	{ IMX_8BIT, 0x4401, 0x3F},
+	{ IMX_8BIT, 0x4402, 0xFF},
+	{ IMX_8BIT, 0x4412, 0x3F},
+	{ IMX_8BIT, 0x4413, 0xFF},
+	{ IMX_8BIT, 0x441D, 0x28},
+	{ IMX_8BIT, 0x4444, 0x00},
+	{ IMX_8BIT, 0x4445, 0x00},
+	{ IMX_8BIT, 0x4446, 0x3F},
+	{ IMX_8BIT, 0x4447, 0xFF},
+	{ IMX_8BIT, 0x4452, 0x00},
+	{ IMX_8BIT, 0x4453, 0xA0},
+	{ IMX_8BIT, 0x4454, 0x08},
+	{ IMX_8BIT, 0x4455, 0x00},
+	{ IMX_8BIT, 0x4458, 0x18},
+	{ IMX_8BIT, 0x4459, 0x18},
+	{ IMX_8BIT, 0x445A, 0x3F},
+	{ IMX_8BIT, 0x445B, 0x3A},
+	{ IMX_8BIT, 0x4462, 0x00},
+	{ IMX_8BIT, 0x4463, 0x00},
+	{ IMX_8BIT, 0x4464, 0x00},
+	{ IMX_8BIT, 0x4465, 0x00},
+	{ IMX_8BIT, 0x446E, 0x01},
+	{ IMX_8BIT, 0x4500, 0x1F},
+	{ IMX_8BIT, 0x600a, 0x00},
+	{ IMX_8BIT, 0x380a, 0x00},
+	{ IMX_8BIT, 0x380b, 0x00},
+	{ IMX_8BIT, 0x4103, 0x00},
+	{ IMX_8BIT, 0x4243, 0x9a},
+	{ IMX_8BIT, 0x4330, 0x01},
+	{ IMX_8BIT, 0x4331, 0x90},
+	{ IMX_8BIT, 0x4332, 0x02},
+	{ IMX_8BIT, 0x4333, 0x58},
+	{ IMX_8BIT, 0x4334, 0x03},
+	{ IMX_8BIT, 0x4335, 0x20},
+	{ IMX_8BIT, 0x4336, 0x03},
+	{ IMX_8BIT, 0x4337, 0x84},
+	{ IMX_8BIT, 0x433C, 0x01},
+	{ IMX_8BIT, 0x4340, 0x02},
+	{ IMX_8BIT, 0x4341, 0x58},
+	{ IMX_8BIT, 0x4342, 0x03},
+	{ IMX_8BIT, 0x4343, 0x52},
+	{ IMX_8BIT, 0x4364, 0x0b},
+	{ IMX_8BIT, 0x4368, 0x00},
+	{ IMX_8BIT, 0x4369, 0x0f},
+	{ IMX_8BIT, 0x436a, 0x03},
+	{ IMX_8BIT, 0x436b, 0xa8},
+	{ IMX_8BIT, 0x436c, 0x00},
+	{ IMX_8BIT, 0x436d, 0x00},
+	{ IMX_8BIT, 0x436e, 0x00},
+	{ IMX_8BIT, 0x436f, 0x06},
+	{ IMX_8BIT, 0x4281, 0x21},
+	{ IMX_8BIT, 0x4282, 0x18},
+	{ IMX_8BIT, 0x4283, 0x04},
+	{ IMX_8BIT, 0x4284, 0x08},
+	{ IMX_8BIT, 0x4287, 0x7f},
+	{ IMX_8BIT, 0x4288, 0x08},
+	{ IMX_8BIT, 0x428c, 0x08},
+	{ IMX_8BIT, 0x4297, 0x00},
+	{ IMX_8BIT, 0x4299, 0x7E},
+	{ IMX_8BIT, 0x42A4, 0xFB},
+	{ IMX_8BIT, 0x42A5, 0x7E},
+	{ IMX_8BIT, 0x42A6, 0xDF},
+	{ IMX_8BIT, 0x42A7, 0xB7},
+	{ IMX_8BIT, 0x42AF, 0x03},
+	{ IMX_8BIT, 0x4207, 0x03},
+	{ IMX_8BIT, 0x4218, 0x00},
+	{ IMX_8BIT, 0x421B, 0x20},
+	{ IMX_8BIT, 0x421F, 0x04},
+	{ IMX_8BIT, 0x4222, 0x02},
+	{ IMX_8BIT, 0x4223, 0x22},
+	{ IMX_8BIT, 0x422E, 0x54},
+	{ IMX_8BIT, 0x422F, 0xFB},
+	{ IMX_8BIT, 0x4230, 0xFF},
+	{ IMX_8BIT, 0x4231, 0xFE},
+	{ IMX_8BIT, 0x4232, 0xFF},
+	{ IMX_8BIT, 0x4235, 0x58},
+	{ IMX_8BIT, 0x4236, 0xF7},
+	{ IMX_8BIT, 0x4237, 0xFD},
+	{ IMX_8BIT, 0x4239, 0x4E},
+	{ IMX_8BIT, 0x423A, 0xFC},
+	{ IMX_8BIT, 0x423B, 0xFD},
+	{ IMX_8BIT, 0x4300, 0x00},
+	{ IMX_8BIT, 0x4316, 0x12},
+	{ IMX_8BIT, 0x4317, 0x22},
+	{ IMX_8BIT, 0x4318, 0x00},
+	{ IMX_8BIT, 0x4319, 0x00},
+	{ IMX_8BIT, 0x431A, 0x00},
+	{ IMX_8BIT, 0x4324, 0x03},
+	{ IMX_8BIT, 0x4325, 0x20},
+	{ IMX_8BIT, 0x4326, 0x03},
+	{ IMX_8BIT, 0x4327, 0x84},
+	{ IMX_8BIT, 0x4328, 0x03},
+	{ IMX_8BIT, 0x4329, 0x20},
+	{ IMX_8BIT, 0x432A, 0x03},
+	{ IMX_8BIT, 0x432B, 0x20},
+	{ IMX_8BIT, 0x432C, 0x01},
+	{ IMX_8BIT, 0x432D, 0x01},
+	{ IMX_8BIT, 0x4338, 0x02},
+	{ IMX_8BIT, 0x4339, 0x00},
+	{ IMX_8BIT, 0x433A, 0x00},
+	{ IMX_8BIT, 0x433B, 0x02},
+	{ IMX_8BIT, 0x435A, 0x03},
+	{ IMX_8BIT, 0x435B, 0x84},
+	{ IMX_8BIT, 0x435E, 0x01},
+	{ IMX_8BIT, 0x435F, 0xFF},
+	{ IMX_8BIT, 0x4360, 0x01},
+	{ IMX_8BIT, 0x4361, 0xF4},
+	{ IMX_8BIT, 0x4362, 0x03},
+	{ IMX_8BIT, 0x4363, 0x84},
+	{ IMX_8BIT, 0x437B, 0x01},
+	{ IMX_8BIT, 0x4400, 0x00}, /* STATS off ISP do not support STATS*/
+	{ IMX_8BIT, 0x4401, 0x3F},
+	{ IMX_8BIT, 0x4402, 0xFF},
+	{ IMX_8BIT, 0x4404, 0x13},
+	{ IMX_8BIT, 0x4405, 0x26},
+	{ IMX_8BIT, 0x4406, 0x07},
+	{ IMX_8BIT, 0x4408, 0x20},
+	{ IMX_8BIT, 0x4409, 0xE5},
+	{ IMX_8BIT, 0x440A, 0xFB},
+	{ IMX_8BIT, 0x440C, 0xF6},
+	{ IMX_8BIT, 0x440D, 0xEA},
+	{ IMX_8BIT, 0x440E, 0x20},
+	{ IMX_8BIT, 0x4410, 0x00},
+	{ IMX_8BIT, 0x4411, 0x00},
+	{ IMX_8BIT, 0x4412, 0x3F},
+	{ IMX_8BIT, 0x4413, 0xFF},
+	{ IMX_8BIT, 0x4414, 0x1F},
+	{ IMX_8BIT, 0x4415, 0xFF},
+	{ IMX_8BIT, 0x4416, 0x20},
+	{ IMX_8BIT, 0x4417, 0x00},
+	{ IMX_8BIT, 0x4418, 0x1F},
+	{ IMX_8BIT, 0x4419, 0xFF},
+	{ IMX_8BIT, 0x441A, 0x20},
+	{ IMX_8BIT, 0x441B, 0x00},
+	{ IMX_8BIT, 0x441D, 0x40},
+	{ IMX_8BIT, 0x441E, 0x1E},
+	{ IMX_8BIT, 0x441F, 0x38},
+	{ IMX_8BIT, 0x4420, 0x01},
+	{ IMX_8BIT, 0x4444, 0x00},
+	{ IMX_8BIT, 0x4445, 0x00},
+	{ IMX_8BIT, 0x4446, 0x1D},
+	{ IMX_8BIT, 0x4447, 0xF9},
+	{ IMX_8BIT, 0x4452, 0x00},
+	{ IMX_8BIT, 0x4453, 0xA0},
+	{ IMX_8BIT, 0x4454, 0x08},
+	{ IMX_8BIT, 0x4455, 0x00},
+	{ IMX_8BIT, 0x4456, 0x0F},
+	{ IMX_8BIT, 0x4457, 0xFF},
+	{ IMX_8BIT, 0x4458, 0x18},
+	{ IMX_8BIT, 0x4459, 0x18},
+	{ IMX_8BIT, 0x445A, 0x3F},
+	{ IMX_8BIT, 0x445B, 0x3A},
+	{ IMX_8BIT, 0x445C, 0x00},
+	{ IMX_8BIT, 0x445D, 0x28},
+	{ IMX_8BIT, 0x445E, 0x01},
+	{ IMX_8BIT, 0x445F, 0x90},
+	{ IMX_8BIT, 0x4460, 0x00},
+	{ IMX_8BIT, 0x4461, 0x60},
+	{ IMX_8BIT, 0x4462, 0x00},
+	{ IMX_8BIT, 0x4463, 0x00},
+	{ IMX_8BIT, 0x4464, 0x00},
+	{ IMX_8BIT, 0x4465, 0x00},
+	{ IMX_8BIT, 0x446C, 0x00},
+	{ IMX_8BIT, 0x446D, 0x00},
+	{ IMX_8BIT, 0x446E, 0x00},
+	{ IMX_8BIT, 0x452A, 0x02},
+	{ IMX_8BIT, 0x0712, 0x01},
+	{ IMX_8BIT, 0x0713, 0x00},
+	{ IMX_8BIT, 0x0714, 0x01},
+	{ IMX_8BIT, 0x0715, 0x00},
+	{ IMX_8BIT, 0x0716, 0x01},
+	{ IMX_8BIT, 0x0717, 0x00},
+	{ IMX_8BIT, 0x0718, 0x01},
+	{ IMX_8BIT, 0x0719, 0x00},
+	{ IMX_8BIT, 0x4500, 0x1F },
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x02},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x02},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00},
+	{ IMX_8BIT, 0x0231, 0x00},
+	{ IMX_8BIT, 0x0233, 0x00},
+	{ IMX_8BIT, 0x0234, 0x00},
+	{ IMX_8BIT, 0x0235, 0x40},
+	{ IMX_8BIT, 0x0238, 0x00},
+	{ IMX_8BIT, 0x0239, 0x04},
+	{ IMX_8BIT, 0x023B, 0x00},
+	{ IMX_8BIT, 0x023C, 0x01},
+	{ IMX_8BIT, 0x33B0, 0x04},
+	{ IMX_8BIT, 0x33B1, 0x00},
+	{ IMX_8BIT, 0x33B3, 0x00},
+	{ IMX_8BIT, 0x33B4, 0x01},
+	{ IMX_8BIT, 0x3800, 0x00},
+	GROUPED_PARAMETER_HOLD_DISABLE,
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/********* Preview, continuous capture and still modes *****************/
+
+static struct imx_reg const imx135_13m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size Setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 0, 0, 4207,3119 4208x3120 */
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x10},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x0C},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* 4208x3120 */
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x30},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x0C},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00}, /* If scaling, Fill this */
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/* 13MP reduced pixel clock MIPI 342MHz is EMC friendly*/
+static struct imx_reg const imx135_13m_for_mipi_342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size Setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x10},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x0C},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x30},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x0C},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00}, /* If scaling, Fill this */
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_10m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 0, 376, 4207, 2743 */
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x78},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6f},
+	{IMX_8BIT, 0x034A, 0x0a},
+	{IMX_8BIT, 0x034B, 0xb7},
+	{IMX_8BIT, 0x034C, 0x10}, /* 4208x2368 */
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0x40},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x40},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0x40},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x68},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_10m_for_mipi_342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 0, 376, 4207, 2743 */
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x78},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6f},
+	{IMX_8BIT, 0x034A, 0x0a},
+	{IMX_8BIT, 0x034B, 0xb7},
+	{IMX_8BIT, 0x034C, 0x10}, /* 4208x2368 */
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0x40},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x40},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0x40},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x68},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_8m_cropped[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x01},
+	{IMX_8BIT, 0x0345, 0xD0},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x48},
+	{IMX_8BIT, 0x0348, 0x0E},
+	{IMX_8BIT, 0x0349, 0x9F},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0xE7},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x2464 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0xA0},
+	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x0C}, /* Cut out size same as the size after crop */
+	{IMX_8BIT, 0x0355, 0xD0},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0xA0},
+	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
+	{IMX_8BIT, 0x3310, 0x0C}, /* Write H and V size  same as output size? */
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0xA0},
+	{IMX_8BIT, 0x331C, 0x00}, /* ?? */
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00}, /* Scaling related? */
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_8m_scaled_from_12m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x2464 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0xA0},
+	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* Cut out size same as the size after crop */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x08},
+	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
+	{IMX_8BIT, 0x3310, 0x0C}, /* Write H and V size  same as output size? */
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0xA0},
+	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C}, /* Scaling related? */
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x09},
+	{IMX_8BIT, 0x4087, 0xA0},
+	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_8m_scaled_from_12m_for_mipi342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x2464 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0xA0},
+	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* Cut out size same as the size after crop */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x08},
+	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
+	{IMX_8BIT, 0x3310, 0x0C}, /* Write H and V size  same as output size? */
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0xA0},
+	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C}, /* Resize IMG Hand V size-> Scaling related?*/
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x09},
+	{IMX_8BIT, 0x4087, 0xA0},
+	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_6m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 36, 194, 1039, a9f 4100x2316 */
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x94},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0x9F},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x1852 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x07},
+	{IMX_8BIT, 0x034F, 0x3C},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* 4100x2316 */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x0C},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x0C},
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x07},
+	{IMX_8BIT, 0x3313, 0x3C},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C},
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x07},
+	{IMX_8BIT, 0x4087, 0x3C},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_6m_for_mipi_342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 36, 194, 1039, a9f 4100x2316 */
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x94},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0x9F},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x1852 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x07},
+	{IMX_8BIT, 0x034F, 0x3C},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* 4100x2316 */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x0C},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x0C},
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x07},
+	{IMX_8BIT, 0x3313, 0x3C},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C},
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x07},
+	{IMX_8BIT, 0x4087, 0x3C},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_1m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x1F},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x58},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x28},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x17},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x07},
+	{IMX_8BIT, 0x034C, 0x04},
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x03},
+	{IMX_8BIT, 0x034F, 0x10},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x07},
+	{IMX_8BIT, 0x0355, 0xE0},
+	{IMX_8BIT, 0x0356, 0x05},
+	{IMX_8BIT, 0x0357, 0xF0},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x04},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x03},
+	{IMX_8BIT, 0x3313, 0x10},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x4E},
+	{IMX_8BIT, 0x4084, 0x04},
+	{IMX_8BIT, 0x4085, 0x10},
+	{IMX_8BIT, 0x4086, 0x03},
+	{IMX_8BIT, 0x4087, 0x10},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_976x736[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x21},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x58},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x28},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x17},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x07}, /* 88,40  4119,3079  4032,3040*/
+	{IMX_8BIT, 0x034C, 0x03}, /* 976x736 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x02},
+	{IMX_8BIT, 0x034F, 0xE0},
+	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x07}, /* 2016,1520 */
+	{IMX_8BIT, 0x0355, 0xE0},
+	{IMX_8BIT, 0x0356, 0x05},
+	{IMX_8BIT, 0x0357, 0xF0},
+	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
+	{IMX_8BIT, 0x3310, 0x03},
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x02},
+	{IMX_8BIT, 0x3313, 0xE0},
+	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
+	{IMX_8BIT, 0x331D, 0x4E},
+	{IMX_8BIT, 0x4084, 0x03}, /* Scaling related? */
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x02},
+	{IMX_8BIT, 0x4087, 0xE0},
+	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_3m_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01}, /* Binning */
+	{IMX_8BIT, 0x0391, 0x22}, /* 2x2 binning */
+	{IMX_8BIT, 0x0392, 0x00}, /* average */
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x28},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x08},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x47},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x27},
+	{IMX_8BIT, 0x034C, 0x08},
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x06},
+	{IMX_8BIT, 0x034F, 0x10},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x10},
+	{IMX_8BIT, 0x0356, 0x06},
+	{IMX_8BIT, 0x0357, 0x10},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x08},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x06},
+	{IMX_8BIT, 0x3313, 0x10},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0xAA},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/* 1080P 1936x1104 */
+static struct imx_reg const imx135_1080p_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x11},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x2E},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x84},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x41},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0xAF},
+	{IMX_8BIT, 0x034C, 0x07},
+	{IMX_8BIT, 0x034D, 0x90},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0x50},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x0A},
+	{IMX_8BIT, 0x0356, 0x04},
+	{IMX_8BIT, 0x0357, 0x96},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x07},
+	{IMX_8BIT, 0x3311, 0x90},
+	{IMX_8BIT, 0x3312, 0x04},
+	{IMX_8BIT, 0x3313, 0x50},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x00},
+	{IMX_8BIT, 0x4084, 0x07},
+	{IMX_8BIT, 0x4085, 0x90},
+	{IMX_8BIT, 0x4086, 0x04},
+	{IMX_8BIT, 0x4087, 0x50},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static const struct imx_reg imx135_1080p_nodvs_fullfov_max_clock[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 168,464,4039,2655: 3872x2192 */
+	{ IMX_8BIT, 0x0345, 0xA8 },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0xD0 },
+	{ IMX_8BIT, 0x0348, 0x0F },
+	{ IMX_8BIT, 0x0349, 0xC7 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0x5F },
+	{ IMX_8BIT, 0x034C, 0x07 }, /*1936 x 1096 */
+	{ IMX_8BIT, 0x034D, 0x90 },
+	{ IMX_8BIT, 0x034E, 0x04 },
+	{ IMX_8BIT, 0x034F, 0x48 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x07 }, /*1936 x 1096 */
+	{ IMX_8BIT, 0x0355, 0x90 },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0x48 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x07 },
+	{ IMX_8BIT, 0x3311, 0x90 },
+	{ IMX_8BIT, 0x3312, 0x04 },
+	{ IMX_8BIT, 0x3313, 0x48 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0xB0 },
+	{ IMX_8BIT, 0x4084, 0x07 },
+	{ IMX_8BIT, 0x4085, 0x90 },
+	{ IMX_8BIT, 0x4086, 0x04 },
+	{ IMX_8BIT, 0x4087, 0x48 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* 1080P NODVS 1936x1096 */
+static const struct imx_reg imx135_1080p_nodvs_max_clock[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x11 },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 46,396,4161,2727: 4116x2332 */
+	{ IMX_8BIT, 0x0345, 0x2E },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x8C },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x41 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0xA7 },
+	{ IMX_8BIT, 0x034C, 0x07 }, /*1936 x 1096 */
+	{ IMX_8BIT, 0x034D, 0x90 },
+	{ IMX_8BIT, 0x034E, 0x04 },
+	{ IMX_8BIT, 0x034F, 0x48 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x08 }, /* 2058x1166 */
+	{ IMX_8BIT, 0x0355, 0x0A },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0x8E },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x07 },
+	{ IMX_8BIT, 0x3311, 0x90 },
+	{ IMX_8BIT, 0x3312, 0x04 },
+	{ IMX_8BIT, 0x3313, 0x48 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0xB0 },
+	{ IMX_8BIT, 0x4084, 0x07 },
+	{ IMX_8BIT, 0x4085, 0x90 },
+	{ IMX_8BIT, 0x4086, 0x04 },
+	{ IMX_8BIT, 0x4087, 0x48 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* 1080P 10%DVS 2104x1184 */
+static const struct imx_reg imx135_1080p_10_dvs_max_clock[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x00 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x10 },
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 0,376,4207,2743: 4208x2368 */
+	{ IMX_8BIT, 0x0345, 0x00 },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x78 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x6F },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0xB7 },
+	{ IMX_8BIT, 0x034C, 0x08 }, /* 2104 x 1184 */
+	{ IMX_8BIT, 0x034D, 0x38 },
+	{ IMX_8BIT, 0x034E, 0x04 },
+	{ IMX_8BIT, 0x034F, 0xA0 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x08 }, /* 2104 x 1184 */
+	{ IMX_8BIT, 0x0355, 0x38 },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0xA0 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x08 },
+	{ IMX_8BIT, 0x3311, 0x38 },
+	{ IMX_8BIT, 0x3312, 0x04 },
+	{ IMX_8BIT, 0x3313, 0xA0 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0xB0 },
+	{ IMX_8BIT, 0x4084, 0x00 },
+	{ IMX_8BIT, 0x4085, 0x00 },
+	{ IMX_8BIT, 0x4086, 0x00 },
+	{ IMX_8BIT, 0x4087, 0x00 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx135_720pdvs_max_clock[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x15 },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 46,404,4161,2715: 4116x2312 */
+	{ IMX_8BIT, 0x0345, 0x2E },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x94 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x41 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0x9B },
+	{ IMX_8BIT, 0x034C, 0x06 }, /*1568 x 880 */
+	{ IMX_8BIT, 0x034D, 0x20 },
+	{ IMX_8BIT, 0x034E, 0x03 },
+	{ IMX_8BIT, 0x034F, 0x70 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x08 }, /*2058 x 1156 */
+	{ IMX_8BIT, 0x0355, 0x0A },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0x84 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x06 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x03 },
+	{ IMX_8BIT, 0x3313, 0x70 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0x4C },
+	{ IMX_8BIT, 0x4084, 0x06 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x03 },
+	{ IMX_8BIT, 0x4087, 0x70 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/******************* Video Modes ******************/
+
+/* 1080P DVS 2336x1320 */
+static const struct imx_reg imx135_2336x1320_max_clock[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },
+	{ IMX_8BIT, 0x0391, 0x11 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x1C },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 60,404,4147,2715: 4088x2312 */
+	{ IMX_8BIT, 0x0345, 0x3C },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x94 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x33 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0x9B },
+	{ IMX_8BIT, 0x034C, 0x09 }, /*2336 x 1320 */
+	{ IMX_8BIT, 0x034D, 0x20 },
+	{ IMX_8BIT, 0x034E, 0x05 },
+	{ IMX_8BIT, 0x034F, 0x28 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x0F }, /* 4088x2312 */
+	{ IMX_8BIT, 0x0355, 0xF8 },
+	{ IMX_8BIT, 0x0356, 0x09 },
+	{ IMX_8BIT, 0x0357, 0x08 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x09 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x05 },
+	{ IMX_8BIT, 0x3313, 0x28 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0xE2 },
+	{ IMX_8BIT, 0x4084, 0x09 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x05 },
+	{ IMX_8BIT, 0x4087, 0x28 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* 1080P DVS 2336x1320 Cropped */
+static const struct imx_reg imx135_2336x1320_cropped_mipi499[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_499_2MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },
+	{ IMX_8BIT, 0x0391, 0x11 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x1C },
+	{ IMX_8BIT, 0x4082, 0x01 },
+	{ IMX_8BIT, 0x4083, 0x01 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x03 }, /* 936,900,3271,2219: 2336x1320 */
+	{ IMX_8BIT, 0x0345, 0xA8 },
+	{ IMX_8BIT, 0x0346, 0x03 },
+	{ IMX_8BIT, 0x0347, 0x84 },
+	{ IMX_8BIT, 0x0348, 0x0C },
+	{ IMX_8BIT, 0x0349, 0xC7 },
+	{ IMX_8BIT, 0x034A, 0x08 },
+	{ IMX_8BIT, 0x034B, 0xAB },
+	{ IMX_8BIT, 0x034C, 0x09 }, /* 2336 x 1320 */
+	{ IMX_8BIT, 0x034D, 0x20 },
+	{ IMX_8BIT, 0x034E, 0x05 },
+	{ IMX_8BIT, 0x034F, 0x28 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x09 }, /* 2336 x 1320 */
+	{ IMX_8BIT, 0x0355, 0x20 },
+	{ IMX_8BIT, 0x0356, 0x05 },
+	{ IMX_8BIT, 0x0357, 0x28 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x09 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x05 },
+	{ IMX_8BIT, 0x3313, 0x28 },
+	{ IMX_8BIT, 0x331C, 0x00 },
+	{ IMX_8BIT, 0x331D, 0xB4 },
+	{ IMX_8BIT, 0x4084, 0x09 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x05 },
+	{ IMX_8BIT, 0x4087, 0x28 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* 720P DVS 1568 x 880 */
+static const struct imx_reg imx135_720p_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x15 },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 46,404,4161,2715: 4116x2312 */
+	{ IMX_8BIT, 0x0345, 0x2e },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x94 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x41 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0x9B },
+	{ IMX_8BIT, 0x034C, 0x06 }, /*1568 x 880 */
+	{ IMX_8BIT, 0x034D, 0x20 },
+	{ IMX_8BIT, 0x034E, 0x03 },
+	{ IMX_8BIT, 0x034F, 0x70 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x08 }, /* 2058x1156 */
+	{ IMX_8BIT, 0x0355, 0x0a },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0x84 },
+	{ IMX_8BIT, 0x301D, 0x30 }, /* TODO! */
+	{ IMX_8BIT, 0x3310, 0x06 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x03 },
+	{ IMX_8BIT, 0x3313, 0x70 },
+	{ IMX_8BIT, 0x331C, 0x01 }, /* TODO! */
+	{ IMX_8BIT, 0x331D, 0xd6 }, /* TODO! */
+	{ IMX_8BIT, 0x4084, 0x06 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x03 },
+	{ IMX_8BIT, 0x4087, 0x70 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* wvga: H : 1640 V : 1024 */
+static const struct imx_reg imx135_wvga_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x36 },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x18 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x39 },
+	{IMX_8BIT, 0x034A, 0x0B },
+	{IMX_8BIT, 0x034B, 0x17 },
+	{IMX_8BIT, 0x034C, 0x06 },
+	{IMX_8BIT, 0x034D, 0x68 },
+	{IMX_8BIT, 0x034E, 0x04 },
+	{IMX_8BIT, 0x034F, 0x00 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x05 },
+	{IMX_8BIT, 0x0357, 0x00 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x06 },
+	{IMX_8BIT, 0x3311, 0x68 },
+	{IMX_8BIT, 0x3312, 0x04 },
+	{IMX_8BIT, 0x3313, 0x00 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0xBD },
+	{IMX_8BIT, 0x4084, 0x06 },
+	{IMX_8BIT, 0x4085, 0x68 },
+	{IMX_8BIT, 0x4086, 0x04 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* 480P DVS 936 x 602 */
+static const struct imx_reg imx135_480p_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x23 },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 56,244,4151,2877: 4096x2634 */
+	{ IMX_8BIT, 0x0345, 0x38 },
+	{ IMX_8BIT, 0x0346, 0x00 },
+	{ IMX_8BIT, 0x0347, 0xf4 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x37 },
+	{ IMX_8BIT, 0x034A, 0x0b },
+	{ IMX_8BIT, 0x034B, 0x3d },
+	{ IMX_8BIT, 0x034C, 0x03 }, /* 936 x 602 */
+	{ IMX_8BIT, 0x034D, 0xa8 },
+	{ IMX_8BIT, 0x034E, 0x02 },
+	{ IMX_8BIT, 0x034F, 0x5a },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x08 }, /* 2058x1156 */
+	{ IMX_8BIT, 0x0355, 0x00 },
+	{ IMX_8BIT, 0x0356, 0x05 },
+	{ IMX_8BIT, 0x0357, 0x25 },
+	{ IMX_8BIT, 0x301D, 0x30 }, /* TODO! */
+	{ IMX_8BIT, 0x3310, 0x03 },
+	{ IMX_8BIT, 0x3311, 0xa8 },
+	{ IMX_8BIT, 0x3312, 0x02 },
+	{ IMX_8BIT, 0x3313, 0x5a },
+	{ IMX_8BIT, 0x331C, 0x01 }, /* TODO! */
+	{ IMX_8BIT, 0x331D, 0xd6 },
+	{ IMX_8BIT, 0x4084, 0x03 },
+	{ IMX_8BIT, 0x4085, 0xa8 },
+	{ IMX_8BIT, 0x4086, 0x02 },
+	{ IMX_8BIT, 0x4087, 0x5a },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* VGA: H : 820 V : 616 */
+static const struct imx_reg imx135_vga_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 }, /* 52,20,4155, 3099 4104x3080*/
+	{IMX_8BIT, 0x0345, 0x34 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x3B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x03 }, /* 820x616 */
+	{IMX_8BIT, 0x034D, 0x34 },
+	{IMX_8BIT, 0x034E, 0x02 },
+	{IMX_8BIT, 0x034F, 0x68 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x04 }, /* 1026x770 */
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x03 },
+	{IMX_8BIT, 0x3311, 0x34 },
+	{IMX_8BIT, 0x3312, 0x02 },
+	{IMX_8BIT, 0x3313, 0x68 },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0x21 },
+	{IMX_8BIT, 0x4084, 0x03 },
+	{IMX_8BIT, 0x4085, 0x34 },
+	{IMX_8BIT, 0x4086, 0x02 },
+	{IMX_8BIT, 0x4087, 0x68 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* VGA: H : 436 V : 360 */
+static const struct imx_reg imx135_436x360_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x22 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 }, /* 212,0,3995,3119 3784x3120 */
+	{IMX_8BIT, 0x0345, 0xD4 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x00 },
+	{IMX_8BIT, 0x0348, 0x0F },
+	{IMX_8BIT, 0x0349, 0x9B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x2F },
+
+	{IMX_8BIT, 0x034C, 0x01 }, /* 436x360 */
+	{IMX_8BIT, 0x034D, 0xB4 },
+	{IMX_8BIT, 0x034E, 0x01 },
+	{IMX_8BIT, 0x034F, 0x68 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x12 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x0C },
+
+	{IMX_8BIT, 0x0354, 0x03 }, /* 928x768 crop from 946x780*/
+	{IMX_8BIT, 0x0355, 0xA0 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x00 },
+
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x01 },
+	{IMX_8BIT, 0x3311, 0xB4 },
+	{IMX_8BIT, 0x3312, 0x01 },
+	{IMX_8BIT, 0x3313, 0x68 },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0x21 },
+	{IMX_8BIT, 0x4084, 0x01 },
+	{IMX_8BIT, 0x4085, 0xB4 },
+	{IMX_8BIT, 0x4086, 0x01 },
+	{IMX_8BIT, 0x4087, 0x68 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* QVGA: H : 408 V : 308 */
+static const struct imx_reg imx135_qvga__dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x28 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 }, /* 64,20,4143,3099 4080x3080 */
+	{IMX_8BIT, 0x0345, 0x40 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x2F },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x01 }, /* 408x308 */
+	{IMX_8BIT, 0x034D, 0x98 },
+	{IMX_8BIT, 0x034E, 0x01 },
+	{IMX_8BIT, 0x034F, 0x34 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 }, /* 1020x770 */
+	{IMX_8BIT, 0x0355, 0xFC },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x01 },
+	{IMX_8BIT, 0x3311, 0x98 },
+	{IMX_8BIT, 0x3312, 0x01 },
+	{IMX_8BIT, 0x3313, 0x34 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0x68 },
+	{IMX_8BIT, 0x4084, 0x01 },
+	{IMX_8BIT, 0x4085, 0x98 },
+	{IMX_8BIT, 0x4086, 0x01 },
+	{IMX_8BIT, 0x4087, 0x34 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* CIF H : 368 V : 304 */
+static const struct imx_reg imx135_cif_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x28 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x01 }, /* 264,42,3943,3081 3680x3040 */
+	{IMX_8BIT, 0x0345, 0x08 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x2a },
+	{IMX_8BIT, 0x0348, 0x0F },
+	{IMX_8BIT, 0x0349, 0x67 },
+	{IMX_8BIT, 0x034A, 0x0c },
+	{IMX_8BIT, 0x034B, 0x09 },
+	{IMX_8BIT, 0x034C, 0x01 }, /* 368x304 */
+	{IMX_8BIT, 0x034D, 0x70 },
+	{IMX_8BIT, 0x034E, 0x01 },
+	{IMX_8BIT, 0x034F, 0x30 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 }, /* 920x760 */
+	{IMX_8BIT, 0x0355, 0x98 },
+	{IMX_8BIT, 0x0356, 0x02 },
+	{IMX_8BIT, 0x0357, 0xf8 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x01 },
+	{IMX_8BIT, 0x3311, 0x70 },
+	{IMX_8BIT, 0x3312, 0x01 },
+	{IMX_8BIT, 0x3313, 0x30 },
+	{IMX_8BIT, 0x331C, 0x02 }, /* TODO! binning 4x4 must be 021c? */
+	{IMX_8BIT, 0x331D, 0x1C },
+	{IMX_8BIT, 0x4084, 0x01 },
+	{IMX_8BIT, 0x4085, 0x70 },
+	{IMX_8BIT, 0x4086, 0x01 },
+	{IMX_8BIT, 0x4087, 0x30 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* QCIF H : 216 V : 176 */
+static const struct imx_reg imx135_qcif_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ_SALTBAY,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x46 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 }, /* 212,20,3995,3099 3784x3080 */
+	{IMX_8BIT, 0x0345, 0xD4 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x0F },
+	{IMX_8BIT, 0x0349, 0x9B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x00 }, /* 216x176 */
+	{IMX_8BIT, 0x034D, 0xD8 },
+	{IMX_8BIT, 0x034E, 0x00 },
+	{IMX_8BIT, 0x034F, 0xB0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 }, /* 946x770 */
+	{IMX_8BIT, 0x0355, 0xB2 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x00 },
+	{IMX_8BIT, 0x3311, 0xD8 },
+	{IMX_8BIT, 0x3312, 0x00 },
+	{IMX_8BIT, 0x3313, 0xB0 },
+	{IMX_8BIT, 0x331C, 0x02 }, /* TODO! binning 4x4 must be 021c */
+	{IMX_8BIT, 0x331D, 0x1C },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0xD8 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0xB0 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/*
+ * ISP Scaling is now supported in offine capture use cases. Because of that
+ * we need only few modes to cover the different aspect ratios from the
+ * sensor and the ISP will scale it based on the requested resolution from HAL.
+ *
+ * There is a performance impact when continuous view finder option is chose
+ * for resolutions above 8MP. So 8MP and 6MP resolution are kept, so that lower
+ * than these take 8MP or 6MP espectively for down scaling based on the
+ * aspect ratio.
+ */
+struct imx_resolution imx135_res_preview[] = {
+	{
+		.desc = "imx135_cif_binning_preview",
+		.regs = imx135_cif_binning,
+		.width = 368,
+		.height = 304,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		 .desc = "imx135_480p_binning_preview",
+		 .regs = imx135_480p_dvs_binning,
+		 .width = 936,
+		 .height = 602,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_vga_dvs_binning_preview",
+		.regs = imx135_vga_dvs_binning,
+		.width = 820,
+		.height = 616,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_976x736_preview",
+		.regs = imx135_976x736,
+		.width = 976,
+		.height = 736,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_1m_preview",
+		.regs = imx135_1m,
+		.width = 1040,
+		.height = 784,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_1080p_binning_preview",
+		.regs = imx135_1080p_binning,
+		.width = 1936,
+		.height = 1104,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_3m__cont_cap",
+		.regs = imx135_3m_binning,
+		.width = 2064,
+		.height = 1552,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_6m_cont_cap",
+		.regs = imx135_6m,
+		.width = 3280,
+		.height = 1852,
+		.fps_options = {
+			{ /* Binning Pixel clock: 360.96MHz */
+				 .fps = 30,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 2624,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 451200,
+	},
+	{
+		.desc = "imx135_8m_scaled_from_12m__cont_cap",
+		.regs = imx135_8m_scaled_from_12m,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+			{ /* Pixel clock: 360.96MHz */
+				 .fps = 24,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 3280,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 451200,
+	},
+	{
+		.desc = "imx135_10m__cont_cap",
+		.regs = imx135_10m,
+		.width = 4208,
+		.height = 2368,
+		.fps_options = {
+			{ /* Pixel clock: 360.96MHz */
+				 .fps = 30,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 2632,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 451200,
+	},
+	{
+		.desc = "imx135_13m__cont_cap",
+		.regs = imx135_13m,
+		.width = 4208,
+		.height = 3120,
+		.fps_options = {
+			{ /* Pixel clock: 360.96MHz */
+				 .fps = 24,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 3290,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 451200,
+	},
+};
+
+/*
+ * ISP Scaling is now supported in online capture use cases. Because of that
+ * we need only few modes to cover the different aspect ratios from the
+ * sensor and the ISP will scale it based on the requested resolution from HAL.
+ *
+ * There is a performance impact when continuous view finder option is chose
+ * for resolutions above 8MP. So 8MP and 6MP resolution are kept, so that lower
+ * than these take 8MP or 6MP espectively for down scaling based on the
+ * aspect ratio.
+ */
+struct imx_resolution imx135_res_still[] = {
+	{
+		.desc = "imx135_cif_binning_still",
+		.regs = imx135_cif_binning,
+		.width = 368,
+		.height = 304,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		 .desc = "imx135_480p_binning_still",
+		 .regs = imx135_480p_dvs_binning,
+		 .width = 936,
+		 .height = 602,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2453,
+			},
+			{
+			}
+		},
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_1m_still",
+		.regs = imx135_1m,
+		.width = 1040,
+		.height = 784,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_1080p_binning_still",
+		.regs = imx135_1080p_binning,
+		.width = 1936,
+		.height = 1104,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 15,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2453,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_3m__still",
+		.regs = imx135_3m_binning,
+		.width = 2064,
+		.height = 1552,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 15,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2453,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_6m_for_mipi_342_still",
+		.regs = imx135_6m_for_mipi_342,
+		.width = 3280,
+		.height = 1852,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 11,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2664,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 342000,
+	},
+	{
+		.desc = "imx135_8m_scaled_from_12m_for_mipi342_still",
+		.regs = imx135_8m_scaled_from_12m_for_mipi342,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 8,
+				 .pixels_per_line = 7672,
+				 .lines_per_frame = 4458,
+			},
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 15,
+				 .pixels_per_line = 5500,
+				 .lines_per_frame = 3314,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 342000,
+	},
+	{
+		.desc = "imx135_10m_for_mipi_342_still",
+		.regs = imx135_10m_for_mipi_342,
+		.width = 4208,
+		.height = 2368,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 11,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 2664,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 342000,
+	},
+	{
+		.desc = "imx135_13m_still",
+		.regs = imx135_13m_for_mipi_342,
+		.width = 4208,
+		.height = 3120,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 5,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 5990,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 342000,
+	},
+};
+
+/*
+ * ISP scaling is not supported in case of video modes. So we need to have
+ * separate sensor mode for video use cases
+ */
+struct imx_resolution imx135_res_video[] = {
+	/* For binning modes pix clock is 335.36 MHz. */
+	{
+		.desc = "imx135_qcif_dvs_binning_video",
+		.regs = imx135_qcif_dvs_binning,
+		.width = 216,
+		.height = 176,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_cif_binning_video",
+		.regs = imx135_cif_binning,
+		.width = 368,
+		.height = 304,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_qvga__dvs_binning_video",
+		.regs = imx135_qvga__dvs_binning,
+		.width = 408,
+		.height = 308,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_436x360_binning_video",
+		.regs = imx135_436x360_binning,
+		.width = 436,
+		.height = 360,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_vga_dvs_binning_video",
+		.regs = imx135_vga_dvs_binning,
+		.width = 820,
+		.height = 616,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_480p_dvs_binning_video",
+		.regs = imx135_480p_dvs_binning,
+		.width = 936,
+		.height = 602,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_720P_dvs_video",
+		.regs = imx135_720pdvs_max_clock,
+		.width = 1568,
+		.height = 880,
+		.fps_options = {
+			{/* Pixel Clock : 360.96 MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5850,
+				 .lines_per_frame = 2000,
+			},
+			{/* Pixel Clock : 360.96 MHz */
+				 .fps = 60,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 1310,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.mipi_freq = 451200,
+	},
+	{
+		.desc = "imx135_wvga_dvs_binning_video",
+		.regs = imx135_wvga_dvs_binning,
+		.width = 1640,
+		.height = 1024,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.mipi_freq = 209600,
+	},
+	{
+		.desc = "imx135_1936_1096_fullfov_max_clock",
+		.regs = imx135_1080p_nodvs_max_clock,
+		.width = 1936,
+		.height = 1096,
+		.fps_options = {
+			{/* Pixel Clock : 360.96 MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5850,
+				 .lines_per_frame = 2000,
+			},
+			{/* Pixel Clock : 360.96 MHz */
+				 .fps = 60,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 1310,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.mipi_freq = 451200,
+	},
+	{
+		.desc = "imx135_1080P_dvs_video",
+		.regs = imx135_2336x1320_max_clock,
+		.width = 2336,
+		.height = 1320,
+		.fps_options = {
+			{/* Pixel Clock : 360.96 MHz */
+				 .fps = 30,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 2632,
+				 .regs = imx135_2336x1320_max_clock,
+				.mipi_freq = 451200,
+			},
+			{/* Pixel Clock : 399.36MHz */
+				 .fps = 60,
+				 .pixels_per_line = 4754,
+				 .lines_per_frame = 1400,
+				 .regs = imx135_2336x1320_cropped_mipi499,
+				.mipi_freq = 499200,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.mipi_freq = 451200,
+	},
+	{
+		.desc = "imx135_8m_cropped_video",
+		.regs = imx135_8m_cropped,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+			{ /* Pixel clock: 360.96MHz */
+				 .fps = 30,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 2624,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.mipi_freq = 451200,
+	},
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h
new file mode 100644
index 0000000..cd0e9e4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx135vb.h
@@ -0,0 +1,1889 @@
+/*
+ * Support for Sony IMX camera sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IMX135VB_H__
+#define __IMX135VB_H__
+
+#include "common.h"
+
+#define IMX_SC_CMMN_CHIP_ID_H	0x0016
+#define IMX_SC_CMMN_CHIP_ID_L	0x0017
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_FOCAL_LENGTH_DEFAULT 0x1710064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_F_NUMBER_DEFAULT 0x16000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define IMX_F_NUMBER_RANGE 0x160a160a
+
+#define GROUPED_PARAMETER_HOLD_ENABLE  {IMX_8BIT, 0x0104, 0x1}
+#define GROUPED_PARAMETER_HOLD_DISABLE  {IMX_8BIT, 0x0104, 0x0}
+
+/*
+ * We use three different MIPI rates for our modes based on the resolution and
+ * FPS requirements. So we have three PLL configurationa and these are based
+ * on the EMC friendly MIPI values.
+ *
+ * Maximum clock: Pix clock @ 360.96MHz MIPI @ 451.2MHz 902.4mbps
+ * Reduced clock: Pix clock @ 273.00MHz MIPI @ 342.0MHz 684.0mbps
+ * Binning modes: Pix clock @ 335.36MHz MIPI @ 209.6MHz 419.2mbps
+ * Global Timing registers are based on the data rates and these are part of
+ * the below clock definitions.
+ */
+
+/* MIPI 451.2MHz 902.4mbps PIXCLK: 360.96MHz */
+#define PLL_SETTINGS_FOR_MIPI_451_2MHZ \
+	{IMX_8BIT, 0x011e, 0x13}, \
+	{IMX_8BIT, 0x011f, 0x33}, \
+	{IMX_8BIT, 0x0301, 0x05}, \
+	{IMX_8BIT, 0x0303, 0x01}, \
+	{IMX_8BIT, 0x0305, 0x0c}, \
+	{IMX_8BIT, 0x0309, 0x05}, \
+	{IMX_8BIT, 0x030b, 0x01}, \
+	{IMX_8BIT, 0x030c, 0x02}, \
+	{IMX_8BIT, 0x030d, 0x34}, \
+	{IMX_8BIT, 0x030e, 0x01}, \
+	{IMX_8BIT, 0x3a06, 0x11}, \
+	{IMX_8BIT, 0x0830, 0x7f}, \
+	{IMX_8BIT, 0x0831, 0x37}, \
+	{IMX_8BIT, 0x0832, 0x67}, \
+	{IMX_8BIT, 0x0833, 0x3f}, \
+	{IMX_8BIT, 0x0834, 0x3f}, \
+	{IMX_8BIT, 0x0835, 0x47}, \
+	{IMX_8BIT, 0x0836, 0xdf}, \
+	{IMX_8BIT, 0x0837, 0x47}, \
+	{IMX_8BIT, 0x0839, 0x1f}, \
+	{IMX_8BIT, 0x083a, 0x17}, \
+	{IMX_8BIT, 0x083b, 0x02}
+
+/* MIPI 209.6MHz, 419.2mbps PIXCLK: 335.36 MHz */
+#define PLL_SETTINGS_FOR_MIPI_209_6MHZ \
+	{IMX_8BIT, 0x011e, 0x13}, \
+	{IMX_8BIT, 0x011f, 0x33}, \
+	{IMX_8BIT, 0x0301, 0x05}, \
+	{IMX_8BIT, 0x0303, 0x01}, \
+	{IMX_8BIT, 0x0305, 0x06}, \
+	{IMX_8BIT, 0x0309, 0x05}, \
+	{IMX_8BIT, 0x030b, 0x02}, \
+	{IMX_8BIT, 0x030c, 0x01}, \
+	{IMX_8BIT, 0x030d, 0x06}, \
+	{IMX_8BIT, 0x030e, 0x01}, \
+	{IMX_8BIT, 0x3a06, 0x12}, \
+	{IMX_8BIT, 0x0830, 0x5f}, \
+	{IMX_8BIT, 0x0831, 0x1f}, \
+	{IMX_8BIT, 0x0832, 0x3f}, \
+	{IMX_8BIT, 0x0833, 0x1f}, \
+	{IMX_8BIT, 0x0834, 0x1f}, \
+	{IMX_8BIT, 0x0835, 0x17}, \
+	{IMX_8BIT, 0x0836, 0x67}, \
+	{IMX_8BIT, 0x0837, 0x27}, \
+	{IMX_8BIT, 0x0839, 0x1f}, \
+	{IMX_8BIT, 0x083a, 0x17}, \
+	{IMX_8BIT, 0x083b, 0x02}
+
+/* MIPI 342MHz 684mbps PIXCLK: 273.6MHz */
+#define PLL_SETTINGS_FOR_MIPI_342MHZ \
+	{IMX_8BIT, 0x011e, 0x13}, \
+	{IMX_8BIT, 0x011f, 0x33}, \
+	{IMX_8BIT, 0x0301, 0x05}, \
+	{IMX_8BIT, 0x0303, 0x01}, \
+	{IMX_8BIT, 0x0305, 0x08}, \
+	{IMX_8BIT, 0x0309, 0x05}, \
+	{IMX_8BIT, 0x030b, 0x01}, \
+	{IMX_8BIT, 0x030c, 0x01}, \
+	{IMX_8BIT, 0x030d, 0x1d}, \
+	{IMX_8BIT, 0x030e, 0x01}, \
+	{IMX_8BIT, 0x3a06, 0x11}, \
+	{IMX_8BIT, 0x0830, 0x77}, \
+	{IMX_8BIT, 0x0831, 0x2f}, \
+	{IMX_8BIT, 0x0832, 0x4f}, \
+	{IMX_8BIT, 0x0833, 0x37}, \
+	{IMX_8BIT, 0x0834, 0x2f}, \
+	{IMX_8BIT, 0x0835, 0x37}, \
+	{IMX_8BIT, 0x0836, 0xa7}, \
+	{IMX_8BIT, 0x0837, 0x37}, \
+	{IMX_8BIT, 0x0839, 0x1f}, \
+	{IMX_8BIT, 0x083a, 0x17}, \
+	{IMX_8BIT, 0x083b, 0x02}
+
+/* Basic settings: Applied only once after the sensor power up */
+static struct imx_reg const imx135vb_init_settings[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x0220, 0x01},
+	{ IMX_8BIT, 0x3008, 0xB0},
+	{ IMX_8BIT, 0x320A, 0x01},
+	{ IMX_8BIT, 0x320D, 0x10},
+	{ IMX_8BIT, 0x3216, 0x2E},
+	{ IMX_8BIT, 0x3230, 0x0A},
+	{ IMX_8BIT, 0x3228, 0x05},
+	{ IMX_8BIT, 0x3229, 0x02},
+	{ IMX_8BIT, 0x322C, 0x02},
+	{ IMX_8BIT, 0x3302, 0x10},
+	{ IMX_8BIT, 0x3390, 0x45},
+	{ IMX_8BIT, 0x3409, 0x0C},
+	{ IMX_8BIT, 0x340B, 0xF5},
+	{ IMX_8BIT, 0x340C, 0x2D},
+	{ IMX_8BIT, 0x3412, 0x41},
+	{ IMX_8BIT, 0x3413, 0xAD},
+	{ IMX_8BIT, 0x3414, 0x1E},
+	{ IMX_8BIT, 0x3427, 0x04},
+	{ IMX_8BIT, 0x3480, 0x1E},
+	{ IMX_8BIT, 0x3484, 0x1E},
+	{ IMX_8BIT, 0x3488, 0x1E},
+	{ IMX_8BIT, 0x348C, 0x1E},
+	{ IMX_8BIT, 0x3490, 0x1E},
+	{ IMX_8BIT, 0x3494, 0x1E},
+	{ IMX_8BIT, 0x349C, 0x38},
+	{ IMX_8BIT, 0x34A3, 0x38},
+	{ IMX_8BIT, 0x3511, 0x8F},
+	{ IMX_8BIT, 0x3518, 0x00},
+	{ IMX_8BIT, 0x3519, 0x94},
+	{ IMX_8BIT, 0x3833, 0x20},
+	{ IMX_8BIT, 0x3893, 0x01},
+	{ IMX_8BIT, 0x38C2, 0x08},
+	{ IMX_8BIT, 0x38C3, 0x08},
+	{ IMX_8BIT, 0x3C09, 0x01},
+	{ IMX_8BIT, 0x4000, 0x0E},
+	{ IMX_8BIT, 0x4300, 0x00},
+	{ IMX_8BIT, 0x4316, 0x12},
+	{ IMX_8BIT, 0x4317, 0x22},
+	{ IMX_8BIT, 0x4318, 0x00},
+	{ IMX_8BIT, 0x4319, 0x00},
+	{ IMX_8BIT, 0x431A, 0x00},
+	{ IMX_8BIT, 0x4324, 0x03},
+	{ IMX_8BIT, 0x4325, 0x20},
+	{ IMX_8BIT, 0x4326, 0x03},
+	{ IMX_8BIT, 0x4327, 0x84},
+	{ IMX_8BIT, 0x4328, 0x03},
+	{ IMX_8BIT, 0x4329, 0x20},
+	{ IMX_8BIT, 0x432A, 0x03},
+	{ IMX_8BIT, 0x432B, 0x84},
+	{ IMX_8BIT, 0x432C, 0x01},
+	{ IMX_8BIT, 0x4401, 0x3F},
+	{ IMX_8BIT, 0x4402, 0xFF},
+	{ IMX_8BIT, 0x4412, 0x3F},
+	{ IMX_8BIT, 0x4413, 0xFF},
+	{ IMX_8BIT, 0x441D, 0x28},
+	{ IMX_8BIT, 0x4444, 0x00},
+	{ IMX_8BIT, 0x4445, 0x00},
+	{ IMX_8BIT, 0x4446, 0x3F},
+	{ IMX_8BIT, 0x4447, 0xFF},
+	{ IMX_8BIT, 0x4452, 0x00},
+	{ IMX_8BIT, 0x4453, 0xA0},
+	{ IMX_8BIT, 0x4454, 0x08},
+	{ IMX_8BIT, 0x4455, 0x00},
+	{ IMX_8BIT, 0x4458, 0x18},
+	{ IMX_8BIT, 0x4459, 0x18},
+	{ IMX_8BIT, 0x445A, 0x3F},
+	{ IMX_8BIT, 0x445B, 0x3A},
+	{ IMX_8BIT, 0x4462, 0x00},
+	{ IMX_8BIT, 0x4463, 0x00},
+	{ IMX_8BIT, 0x4464, 0x00},
+	{ IMX_8BIT, 0x4465, 0x00},
+	{ IMX_8BIT, 0x446E, 0x01},
+	{ IMX_8BIT, 0x4500, 0x1F},
+	{ IMX_8BIT, 0x600a, 0x00},
+	{ IMX_8BIT, 0x380a, 0x00},
+	{ IMX_8BIT, 0x380b, 0x00},
+	{ IMX_8BIT, 0x4103, 0x00},
+	{ IMX_8BIT, 0x4243, 0x9a},
+	{ IMX_8BIT, 0x4330, 0x01},
+	{ IMX_8BIT, 0x4331, 0x90},
+	{ IMX_8BIT, 0x4332, 0x02},
+	{ IMX_8BIT, 0x4333, 0x58},
+	{ IMX_8BIT, 0x4334, 0x03},
+	{ IMX_8BIT, 0x4335, 0x20},
+	{ IMX_8BIT, 0x4336, 0x03},
+	{ IMX_8BIT, 0x4337, 0x84},
+	{ IMX_8BIT, 0x433C, 0x01},
+	{ IMX_8BIT, 0x4340, 0x02},
+	{ IMX_8BIT, 0x4341, 0x58},
+	{ IMX_8BIT, 0x4342, 0x03},
+	{ IMX_8BIT, 0x4343, 0x52},
+	{ IMX_8BIT, 0x4364, 0x0b},
+	{ IMX_8BIT, 0x4368, 0x00},
+	{ IMX_8BIT, 0x4369, 0x0f},
+	{ IMX_8BIT, 0x436a, 0x03},
+	{ IMX_8BIT, 0x436b, 0xa8},
+	{ IMX_8BIT, 0x436c, 0x00},
+	{ IMX_8BIT, 0x436d, 0x00},
+	{ IMX_8BIT, 0x436e, 0x00},
+	{ IMX_8BIT, 0x436f, 0x06},
+	{ IMX_8BIT, 0x4281, 0x21},
+	{ IMX_8BIT, 0x4282, 0x18},
+	{ IMX_8BIT, 0x4283, 0x04},
+	{ IMX_8BIT, 0x4284, 0x08},
+	{ IMX_8BIT, 0x4287, 0x7f},
+	{ IMX_8BIT, 0x4288, 0x08},
+	{ IMX_8BIT, 0x428b, 0x7f},
+	{ IMX_8BIT, 0x428c, 0x08},
+	{ IMX_8BIT, 0x428f, 0x7f},
+	{ IMX_8BIT, 0x4297, 0x00},
+	{ IMX_8BIT, 0x4298, 0x7E},
+	{ IMX_8BIT, 0x4299, 0x7E},
+	{ IMX_8BIT, 0x429A, 0x7E},
+	{ IMX_8BIT, 0x42A4, 0xFB},
+	{ IMX_8BIT, 0x42A5, 0x7E},
+	{ IMX_8BIT, 0x42A6, 0xDF},
+	{ IMX_8BIT, 0x42A7, 0xB7},
+	{ IMX_8BIT, 0x42AF, 0x03},
+	{ IMX_8BIT, 0x4207, 0x03},
+	{ IMX_8BIT, 0x4216, 0x08},
+	{ IMX_8BIT, 0x4217, 0x08},
+	{ IMX_8BIT, 0x4218, 0x00},
+	{ IMX_8BIT, 0x421B, 0x20},
+	{ IMX_8BIT, 0x421F, 0x04},
+	{ IMX_8BIT, 0x4222, 0x02},
+	{ IMX_8BIT, 0x4223, 0x22},
+	{ IMX_8BIT, 0x422E, 0x54},
+	{ IMX_8BIT, 0x422F, 0xFB},
+	{ IMX_8BIT, 0x4230, 0xFF},
+	{ IMX_8BIT, 0x4231, 0xFE},
+	{ IMX_8BIT, 0x4232, 0xFF},
+	{ IMX_8BIT, 0x4235, 0x58},
+	{ IMX_8BIT, 0x4236, 0xF7},
+	{ IMX_8BIT, 0x4237, 0xFD},
+	{ IMX_8BIT, 0x4239, 0x4E},
+	{ IMX_8BIT, 0x423A, 0xFC},
+	{ IMX_8BIT, 0x423B, 0xFD},
+	{ IMX_8BIT, 0x4300, 0x00},
+	{ IMX_8BIT, 0x4316, 0x12},
+	{ IMX_8BIT, 0x4317, 0x22},
+	{ IMX_8BIT, 0x4318, 0x00},
+	{ IMX_8BIT, 0x4319, 0x00},
+	{ IMX_8BIT, 0x431A, 0x00},
+	{ IMX_8BIT, 0x4324, 0x03},
+	{ IMX_8BIT, 0x4325, 0x20},
+	{ IMX_8BIT, 0x4326, 0x03},
+	{ IMX_8BIT, 0x4327, 0x84},
+	{ IMX_8BIT, 0x4328, 0x03},
+	{ IMX_8BIT, 0x4329, 0x20},
+	{ IMX_8BIT, 0x432A, 0x03},
+	{ IMX_8BIT, 0x432B, 0x20},
+	{ IMX_8BIT, 0x432C, 0x01},
+	{ IMX_8BIT, 0x432D, 0x01},
+	{ IMX_8BIT, 0x4338, 0x02},
+	{ IMX_8BIT, 0x4339, 0x00},
+	{ IMX_8BIT, 0x433A, 0x00},
+	{ IMX_8BIT, 0x433B, 0x02},
+	{ IMX_8BIT, 0x435A, 0x03},
+	{ IMX_8BIT, 0x435B, 0x84},
+	{ IMX_8BIT, 0x435E, 0x01},
+	{ IMX_8BIT, 0x435F, 0xFF},
+	{ IMX_8BIT, 0x4360, 0x01},
+	{ IMX_8BIT, 0x4361, 0xF4},
+	{ IMX_8BIT, 0x4362, 0x03},
+	{ IMX_8BIT, 0x4363, 0x84},
+	{ IMX_8BIT, 0x437B, 0x01},
+	{ IMX_8BIT, 0x4400, 0x00}, /* STATS off ISP do not support STATS*/
+	{ IMX_8BIT, 0x4401, 0x3F},
+	{ IMX_8BIT, 0x4402, 0xFF},
+	{ IMX_8BIT, 0x4404, 0x13},
+	{ IMX_8BIT, 0x4405, 0x26},
+	{ IMX_8BIT, 0x4406, 0x07},
+	{ IMX_8BIT, 0x4408, 0x20},
+	{ IMX_8BIT, 0x4409, 0xE5},
+	{ IMX_8BIT, 0x440A, 0xFB},
+	{ IMX_8BIT, 0x440C, 0xF6},
+	{ IMX_8BIT, 0x440D, 0xEA},
+	{ IMX_8BIT, 0x440E, 0x20},
+	{ IMX_8BIT, 0x4410, 0x00},
+	{ IMX_8BIT, 0x4411, 0x00},
+	{ IMX_8BIT, 0x4412, 0x3F},
+	{ IMX_8BIT, 0x4413, 0xFF},
+	{ IMX_8BIT, 0x4414, 0x1F},
+	{ IMX_8BIT, 0x4415, 0xFF},
+	{ IMX_8BIT, 0x4416, 0x20},
+	{ IMX_8BIT, 0x4417, 0x00},
+	{ IMX_8BIT, 0x4418, 0x1F},
+	{ IMX_8BIT, 0x4419, 0xFF},
+	{ IMX_8BIT, 0x441A, 0x20},
+	{ IMX_8BIT, 0x441B, 0x00},
+	{ IMX_8BIT, 0x441D, 0x40},
+	{ IMX_8BIT, 0x441E, 0x1E},
+	{ IMX_8BIT, 0x441F, 0x38},
+	{ IMX_8BIT, 0x4420, 0x01},
+	{ IMX_8BIT, 0x4444, 0x00},
+	{ IMX_8BIT, 0x4445, 0x00},
+	{ IMX_8BIT, 0x4446, 0x1D},
+	{ IMX_8BIT, 0x4447, 0xF9},
+	{ IMX_8BIT, 0x4452, 0x00},
+	{ IMX_8BIT, 0x4453, 0xA0},
+	{ IMX_8BIT, 0x4454, 0x08},
+	{ IMX_8BIT, 0x4455, 0x00},
+	{ IMX_8BIT, 0x4456, 0x0F},
+	{ IMX_8BIT, 0x4457, 0xFF},
+	{ IMX_8BIT, 0x4458, 0x18},
+	{ IMX_8BIT, 0x4459, 0x18},
+	{ IMX_8BIT, 0x445A, 0x3F},
+	{ IMX_8BIT, 0x445B, 0x3A},
+	{ IMX_8BIT, 0x445C, 0x00},
+	{ IMX_8BIT, 0x445D, 0x28},
+	{ IMX_8BIT, 0x445E, 0x01},
+	{ IMX_8BIT, 0x445F, 0x90},
+	{ IMX_8BIT, 0x4460, 0x00},
+	{ IMX_8BIT, 0x4461, 0x60},
+	{ IMX_8BIT, 0x4462, 0x00},
+	{ IMX_8BIT, 0x4463, 0x00},
+	{ IMX_8BIT, 0x4464, 0x00},
+	{ IMX_8BIT, 0x4465, 0x00},
+	{ IMX_8BIT, 0x446C, 0x00},
+	{ IMX_8BIT, 0x446D, 0x00},
+	{ IMX_8BIT, 0x446E, 0x00},
+	{ IMX_8BIT, 0x452A, 0x02},
+	{ IMX_8BIT, 0x0712, 0x01},
+	{ IMX_8BIT, 0x0713, 0x00},
+	{ IMX_8BIT, 0x0714, 0x01},
+	{ IMX_8BIT, 0x0715, 0x00},
+	{ IMX_8BIT, 0x0716, 0x01},
+	{ IMX_8BIT, 0x0717, 0x00},
+	{ IMX_8BIT, 0x0718, 0x01},
+	{ IMX_8BIT, 0x0719, 0x00},
+	{ IMX_8BIT, 0x4500, 0x1F },
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x02},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x02},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00},
+	{ IMX_8BIT, 0x0231, 0x00},
+	{ IMX_8BIT, 0x0233, 0x00},
+	{ IMX_8BIT, 0x0234, 0x00},
+	{ IMX_8BIT, 0x0235, 0x40},
+	{ IMX_8BIT, 0x0238, 0x00},
+	{ IMX_8BIT, 0x0239, 0x04},
+	{ IMX_8BIT, 0x023B, 0x00},
+	{ IMX_8BIT, 0x023C, 0x01},
+	{ IMX_8BIT, 0x33B0, 0x04},
+	{ IMX_8BIT, 0x33B1, 0x00},
+	{ IMX_8BIT, 0x33B3, 0x00},
+	{ IMX_8BIT, 0x33B4, 0x01},
+	{ IMX_8BIT, 0x3800, 0x00},
+	GROUPED_PARAMETER_HOLD_DISABLE,
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/********* Preview, continuous capture and still modes *****************/
+
+static struct imx_reg const imx135vb_13m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size Setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 0, 0, 4207,3119 4208x3120 */
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x10},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x0C},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* 4208x3120 */
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x30},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x0C},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00}, /* If scaling, Fill this */
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/* 13MP reduced pixel clock MIPI 342MHz is EMC friendly*/
+static struct imx_reg const imx135vb_13m_for_mipi_342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size Setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x10},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x0C},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x30},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x0C},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00}, /* If scaling, Fill this */
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135vb_10m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 0, 376, 4207, 2743 */
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x78},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6f},
+	{IMX_8BIT, 0x034A, 0x0a},
+	{IMX_8BIT, 0x034B, 0xb7},
+	{IMX_8BIT, 0x034C, 0x10}, /* 4208x2368 */
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0x40},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x40},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0x40},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x68},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135vb_10m_for_mipi_342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 0, 376, 4207, 2743 */
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x78},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6f},
+	{IMX_8BIT, 0x034A, 0x0a},
+	{IMX_8BIT, 0x034B, 0xb7},
+	{IMX_8BIT, 0x034C, 0x10}, /* 4208x2368 */
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0x40},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x40},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0x40},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x68},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135vb_8m_scaled_from_12m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x2464 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0xA0},
+	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* Cut out size same as the size after crop */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x08},
+	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
+	{IMX_8BIT, 0x3310, 0x0C}, /* Write H and V size  same as output size? */
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0xA0},
+	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C}, /* Scaling related? */
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x09},
+	{IMX_8BIT, 0x4087, 0xA0},
+	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135vb_8m_scaled_from_12m_for_mipi342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02}, /* Scaling */
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x2464 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x09},
+	{IMX_8BIT, 0x034F, 0xA0},
+	{IMX_8BIT, 0x0350, 0x00}, /* No Dig crop */
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* Cut out size same as the size after crop */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x08},
+	{IMX_8BIT, 0x301D, 0x30}, /* ?? */
+	{IMX_8BIT, 0x3310, 0x0C}, /* Write H and V size  same as output size? */
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x09},
+	{IMX_8BIT, 0x3313, 0xA0},
+	{IMX_8BIT, 0x331C, 0x02}, /* ?? */
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C}, /* Resize IMG Hand V size-> Scaling related?*/
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x09},
+	{IMX_8BIT, 0x4087, 0xA0},
+	{IMX_8BIT, 0x4400, 0x00}, /* STATS off */
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135vb_6m[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 36, 194, 1039, a9f 4100x2316 */
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x94},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0x9F},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x1852 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x07},
+	{IMX_8BIT, 0x034F, 0x3C},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* 4100x2316 */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x0C},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x0C},
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x07},
+	{IMX_8BIT, 0x3313, 0x3C},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C},
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x07},
+	{IMX_8BIT, 0x4087, 0x3C},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135vb_6m_for_mipi_342[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_342MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00}, /* 36, 194, 1039, a9f 4100x2316 */
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x94},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0x9F},
+	{IMX_8BIT, 0x034C, 0x0C}, /* 3280x1852 */
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x07},
+	{IMX_8BIT, 0x034F, 0x3C},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10}, /* 4100x2316 */
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x0C},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x0C},
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x07},
+	{IMX_8BIT, 0x3313, 0x3C},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C},
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x07},
+	{IMX_8BIT, 0x4087, 0x3C},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135vb_3m_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01}, /* Binning */
+	{IMX_8BIT, 0x0391, 0x22}, /* 2x2 binning */
+	{IMX_8BIT, 0x0392, 0x00}, /* average */
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x28},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x08},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x47},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x27},
+	{IMX_8BIT, 0x034C, 0x08},
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x06},
+	{IMX_8BIT, 0x034F, 0x10},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x10},
+	{IMX_8BIT, 0x0356, 0x06},
+	{IMX_8BIT, 0x0357, 0x10},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x08},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x06},
+	{IMX_8BIT, 0x3313, 0x10},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0xAA},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/* 1080P 1936x1104 */
+static struct imx_reg const imx135vb_1080p_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x11},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x2E},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x84},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x41},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0xAF},
+	{IMX_8BIT, 0x034C, 0x07},
+	{IMX_8BIT, 0x034D, 0x90},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0x50},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x0A},
+	{IMX_8BIT, 0x0356, 0x04},
+	{IMX_8BIT, 0x0357, 0x96},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x07},
+	{IMX_8BIT, 0x3311, 0x90},
+	{IMX_8BIT, 0x3312, 0x04},
+	{IMX_8BIT, 0x3313, 0x50},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x00},
+	{IMX_8BIT, 0x4084, 0x07},
+	{IMX_8BIT, 0x4085, 0x90},
+	{IMX_8BIT, 0x4086, 0x04},
+	{IMX_8BIT, 0x4087, 0x50},
+	{IMX_8BIT, 0x4400, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/******************* Video Modes ******************/
+
+/* 1080P DVS 2336x1320 */
+static const struct imx_reg imx135vb_2336x1320_max_clock[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_451_2MHZ,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },
+	{ IMX_8BIT, 0x0391, 0x11 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x1C },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 60,404,4147,2715: 4088x2312 */
+	{ IMX_8BIT, 0x0345, 0x3C },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x94 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x33 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0x9B },
+	{ IMX_8BIT, 0x034C, 0x09 }, /*2336 x 1320 */
+	{ IMX_8BIT, 0x034D, 0x20 },
+	{ IMX_8BIT, 0x034E, 0x05 },
+	{ IMX_8BIT, 0x034F, 0x28 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x0F }, /* 4088x2312 */
+	{ IMX_8BIT, 0x0355, 0xF8 },
+	{ IMX_8BIT, 0x0356, 0x09 },
+	{ IMX_8BIT, 0x0357, 0x08 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x09 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x05 },
+	{ IMX_8BIT, 0x3313, 0x28 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0xE2 },
+	{ IMX_8BIT, 0x4084, 0x09 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x05 },
+	{ IMX_8BIT, 0x4087, 0x28 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* 720P DVS 1568 x 880 */
+static const struct imx_reg imx135vb_720p_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x15 },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 46,404,4161,2715: 4116x2312 */
+	{ IMX_8BIT, 0x0345, 0x2e },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x94 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x41 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0x9B },
+	{ IMX_8BIT, 0x034C, 0x06 }, /*1568 x 880 */
+	{ IMX_8BIT, 0x034D, 0x20 },
+	{ IMX_8BIT, 0x034E, 0x03 },
+	{ IMX_8BIT, 0x034F, 0x70 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x08 }, /* 2058x1156 */
+	{ IMX_8BIT, 0x0355, 0x0a },
+	{ IMX_8BIT, 0x0356, 0x04 },
+	{ IMX_8BIT, 0x0357, 0x84 },
+	{ IMX_8BIT, 0x301D, 0x30 }, /* TODO! */
+	{ IMX_8BIT, 0x3310, 0x06 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x03 },
+	{ IMX_8BIT, 0x3313, 0x70 },
+	{ IMX_8BIT, 0x331C, 0x01 }, /* TODO! */
+	{ IMX_8BIT, 0x331D, 0xd6 }, /* TODO! */
+	{ IMX_8BIT, 0x4084, 0x06 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x03 },
+	{ IMX_8BIT, 0x4087, 0x70 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* wvga: H : 1640 V : 1024 */
+static const struct imx_reg imx135vb_wvga_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x36 },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x18 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x39 },
+	{IMX_8BIT, 0x034A, 0x0B },
+	{IMX_8BIT, 0x034B, 0x17 },
+	{IMX_8BIT, 0x034C, 0x06 },
+	{IMX_8BIT, 0x034D, 0x68 },
+	{IMX_8BIT, 0x034E, 0x04 },
+	{IMX_8BIT, 0x034F, 0x00 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x05 },
+	{IMX_8BIT, 0x0357, 0x00 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x06 },
+	{IMX_8BIT, 0x3311, 0x68 },
+	{IMX_8BIT, 0x3312, 0x04 },
+	{IMX_8BIT, 0x3313, 0x00 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0xBD },
+	{IMX_8BIT, 0x4084, 0x06 },
+	{IMX_8BIT, 0x4085, 0x68 },
+	{IMX_8BIT, 0x4086, 0x04 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* 480P DVS 936 x 602 */
+static const struct imx_reg imx135vb_480p_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x01 },
+	{ IMX_8BIT, 0x0391, 0x22 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x23 },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* size setting */
+	{ IMX_8BIT, 0x0344, 0x00 }, /* 56,244,4151,2877: 4096x2634 */
+	{ IMX_8BIT, 0x0345, 0x38 },
+	{ IMX_8BIT, 0x0346, 0x00 },
+	{ IMX_8BIT, 0x0347, 0xf4 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x37 },
+	{ IMX_8BIT, 0x034A, 0x0b },
+	{ IMX_8BIT, 0x034B, 0x3d },
+	{ IMX_8BIT, 0x034C, 0x03 }, /* 936 x 602 */
+	{ IMX_8BIT, 0x034D, 0xa8 },
+	{ IMX_8BIT, 0x034E, 0x02 },
+	{ IMX_8BIT, 0x034F, 0x5a },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x08 }, /* 2058x1156 */
+	{ IMX_8BIT, 0x0355, 0x00 },
+	{ IMX_8BIT, 0x0356, 0x05 },
+	{ IMX_8BIT, 0x0357, 0x25 },
+	{ IMX_8BIT, 0x301D, 0x30 }, /* TODO! */
+	{ IMX_8BIT, 0x3310, 0x03 },
+	{ IMX_8BIT, 0x3311, 0xa8 },
+	{ IMX_8BIT, 0x3312, 0x02 },
+	{ IMX_8BIT, 0x3313, 0x5a },
+	{ IMX_8BIT, 0x331C, 0x01 }, /* TODO! */
+	{ IMX_8BIT, 0x331D, 0xd6 },
+	{ IMX_8BIT, 0x4084, 0x03 },
+	{ IMX_8BIT, 0x4085, 0xa8 },
+	{ IMX_8BIT, 0x4086, 0x02 },
+	{ IMX_8BIT, 0x4087, 0x5a },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* VGA: H : 820 V : 616 */
+static const struct imx_reg imx135vb_vga_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 }, /* 52,20,4155, 3099 4104x3080*/
+	{IMX_8BIT, 0x0345, 0x34 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x3B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x03 }, /* 820x616 */
+	{IMX_8BIT, 0x034D, 0x34 },
+	{IMX_8BIT, 0x034E, 0x02 },
+	{IMX_8BIT, 0x034F, 0x68 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x04 }, /* 1026x770 */
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x03 },
+	{IMX_8BIT, 0x3311, 0x34 },
+	{IMX_8BIT, 0x3312, 0x02 },
+	{IMX_8BIT, 0x3313, 0x68 },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0x21 },
+	{IMX_8BIT, 0x4084, 0x03 },
+	{IMX_8BIT, 0x4085, 0x34 },
+	{IMX_8BIT, 0x4086, 0x02 },
+	{IMX_8BIT, 0x4087, 0x68 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* QVGA: H : 408 V : 308 */
+static const struct imx_reg imx135vb_qvga__dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x28 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 }, /* 64,20,4143,3099 4080x3080 */
+	{IMX_8BIT, 0x0345, 0x40 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x2F },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x01 }, /* 408x308 */
+	{IMX_8BIT, 0x034D, 0x98 },
+	{IMX_8BIT, 0x034E, 0x01 },
+	{IMX_8BIT, 0x034F, 0x34 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 }, /* 1020x770 */
+	{IMX_8BIT, 0x0355, 0xFC },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x01 },
+	{IMX_8BIT, 0x3311, 0x98 },
+	{IMX_8BIT, 0x3312, 0x01 },
+	{IMX_8BIT, 0x3313, 0x34 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0x68 },
+	{IMX_8BIT, 0x4084, 0x01 },
+	{IMX_8BIT, 0x4085, 0x98 },
+	{IMX_8BIT, 0x4086, 0x01 },
+	{IMX_8BIT, 0x4087, 0x34 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* CIF H : 368 V : 304 */
+static const struct imx_reg imx135vb_cif_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x28 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x01 }, /* 264,42,3943,3081 3680x3040 */
+	{IMX_8BIT, 0x0345, 0x08 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x2a },
+	{IMX_8BIT, 0x0348, 0x0F },
+	{IMX_8BIT, 0x0349, 0x67 },
+	{IMX_8BIT, 0x034A, 0x0c },
+	{IMX_8BIT, 0x034B, 0x09 },
+	{IMX_8BIT, 0x034C, 0x01 }, /* 368x304 */
+	{IMX_8BIT, 0x034D, 0x70 },
+	{IMX_8BIT, 0x034E, 0x01 },
+	{IMX_8BIT, 0x034F, 0x30 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 }, /* 920x760 */
+	{IMX_8BIT, 0x0355, 0x98 },
+	{IMX_8BIT, 0x0356, 0x02 },
+	{IMX_8BIT, 0x0357, 0xf8 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x01 },
+	{IMX_8BIT, 0x3311, 0x70 },
+	{IMX_8BIT, 0x3312, 0x01 },
+	{IMX_8BIT, 0x3313, 0x30 },
+	{IMX_8BIT, 0x331C, 0x02 }, /* TODO! binning 4x4 must be 021c? */
+	{IMX_8BIT, 0x331D, 0x1C },
+	{IMX_8BIT, 0x4084, 0x01 },
+	{IMX_8BIT, 0x4085, 0x70 },
+	{IMX_8BIT, 0x4086, 0x01 },
+	{IMX_8BIT, 0x4087, 0x30 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* QCIF H : 216 V : 176 */
+static const struct imx_reg imx135vb_qcif_dvs_binning[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	PLL_SETTINGS_FOR_MIPI_209_6MHZ,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x46 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0344, 0x00 }, /* 212,20,3995,3099 3784x3080 */
+	{IMX_8BIT, 0x0345, 0xD4 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x0F },
+	{IMX_8BIT, 0x0349, 0x9B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x00 }, /* 216x176 */
+	{IMX_8BIT, 0x034D, 0xD8 },
+	{IMX_8BIT, 0x034E, 0x00 },
+	{IMX_8BIT, 0x034F, 0xB0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 }, /* 946x770 */
+	{IMX_8BIT, 0x0355, 0xB2 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x00 },
+	{IMX_8BIT, 0x3311, 0xD8 },
+	{IMX_8BIT, 0x3312, 0x00 },
+	{IMX_8BIT, 0x3313, 0xB0 },
+	{IMX_8BIT, 0x331C, 0x02 }, /* TODO! binning 4x4 must be 021c */
+	{IMX_8BIT, 0x331D, 0x1C },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0xD8 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0xB0 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/*
+ * ISP Scaling is now supported in offine capture use cases. Because of that
+ * we need only few modes to cover the different aspect ratios from the
+ * sensor and the ISP will scale it based on the requested resolution from HAL.
+ *
+ * There is a performance impact when continuous view finder option is chose
+ * for resolutions above 8MP. So 8MP and 6MP resolution are kept, so that lower
+ * than these take 8MP or 6MP espectively for down scaling based on the
+ * aspect ratio.
+ */
+struct imx_resolution imx135vb_res_preview[] = {
+	{
+		.desc = "imx135vb_cif_binning_preview",
+		.regs = imx135vb_cif_binning,
+		.width = 368,
+		.height = 304,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+	},
+	{
+		 .desc = "imx135vb_480p_binning_preview",
+		 .regs = imx135vb_480p_dvs_binning,
+		 .width = 936,
+		 .height = 602,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+	},
+	{
+		.desc = "imx135vb_1080p_binning_preview",
+		.regs = imx135vb_1080p_binning,
+		.width = 1936,
+		.height = 1104,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_3m__cont_cap",
+		.regs = imx135vb_3m_binning,
+		.width = 2064,
+		.height = 1552,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_6m_cont_cap",
+		.regs = imx135vb_6m,
+		.width = 3280,
+		.height = 1852,
+		.fps_options = {
+			{ /* Binning Pixel clock: 360.96MHz */
+				 .fps = 30,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 2624,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_8m_scaled_from_12m__cont_cap",
+		.regs = imx135vb_8m_scaled_from_12m,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+			{ /* Pixel clock: 360.96MHz */
+				 .fps = 24,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 3280,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_10m__cont_cap",
+		.regs = imx135vb_10m,
+		.width = 4208,
+		.height = 2368,
+		.fps_options = {
+			{ /* Pixel clock: 360.96MHz */
+				 .fps = 30,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 2632,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_13m__cont_cap",
+		.regs = imx135vb_13m,
+		.width = 4208,
+		.height = 3120,
+		.fps_options = {
+			{ /* Pixel clock: 360.96MHz */
+				 .fps = 24,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 3290,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+/*
+ * ISP Scaling is now supported in online capture use cases. Because of that
+ * we need only few modes to cover the different aspect ratios from the
+ * sensor and the ISP will scale it based on the requested resolution from HAL.
+ *
+ * There is a performance impact when continuous view finder option is chose
+ * for resolutions above 8MP. So 8MP and 6MP resolution are kept, so that lower
+ * than these take 8MP or 6MP espectively for down scaling based on the
+ * aspect ratio.
+ */
+struct imx_resolution imx135vb_res_still[] = {
+	{
+		.desc = "imx135vb_cif_binning_preview",
+		.regs = imx135vb_cif_binning,
+		.width = 368,
+		.height = 304,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+	},
+	{
+		 .desc = "imx135vb_480p_binning_still",
+		 .regs = imx135vb_480p_dvs_binning,
+		 .width = 936,
+		 .height = 602,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 30,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2453,
+			},
+			{
+			}
+		},
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+	},
+	{
+		.desc = "imx135vb_1080p_binning_still",
+		.regs = imx135vb_1080p_binning,
+		.width = 1936,
+		.height = 1104,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 15,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2453,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_3m__still",
+		.regs = imx135vb_3m_binning,
+		.width = 2064,
+		.height = 1552,
+		.fps_options = {
+			{ /* Binning Pixel clock: 335.36MHz */
+				 .fps = 15,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2453,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_6m_for_mipi_342_still",
+		.regs = imx135vb_6m_for_mipi_342,
+		.width = 3280,
+		.height = 1852,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 11,
+				 .pixels_per_line = 9114,
+				 .lines_per_frame = 2664,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_8m_scaled_from_12m_for_mipi342_still",
+		.regs = imx135vb_8m_scaled_from_12m_for_mipi342,
+		.width = 3280,
+		.height = 2464,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 15,
+				 .pixels_per_line = 5500,
+				 .lines_per_frame = 3314,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_10m_for_mipi_342_still",
+		.regs = imx135vb_10m_for_mipi_342,
+		.width = 4208,
+		.height = 2368,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 11,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 2664,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135vb_13m_still",
+		.regs = imx135vb_13m_for_mipi_342,
+		.width = 4208,
+		.height = 3120,
+		.fps_options = {
+			{ /* Pixel clock: 273.6MHz */
+				 .fps = 9,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 3328,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+/*
+ * ISP scaling is not supported in case of video modes. So we need to have
+ * separate sensor mode for video use cases
+ */
+struct imx_resolution imx135vb_res_video[] = {
+	/* For binning modes pix clock is 335.36 MHz. */
+	{
+		.desc = "imx135vb_qcif_dvs_binning_video",
+		.regs = imx135vb_qcif_dvs_binning,
+		.width = 216,
+		.height = 176,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+	},
+	{
+		.desc = "imx135vb_cif_binning_video",
+		.regs = imx135vb_cif_binning,
+		.width = 368,
+		.height = 304,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+	},
+	{
+		.desc = "imx135vb_qvga__dvs_binning_video",
+		.regs = imx135vb_qvga__dvs_binning,
+		.width = 408,
+		.height = 308,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+	},
+	{
+		.desc = "imx135vb_vga_dvs_binning_video",
+		.regs = imx135vb_vga_dvs_binning,
+		.width = 820,
+		.height = 616,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 9144,
+				 .lines_per_frame = 1226,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+	},
+	{
+		.desc = "imx135vb_480p_dvs_binning_video",
+		.regs = imx135vb_480p_dvs_binning,
+		.width = 936,
+		.height = 602,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+	},
+	{
+		.desc = "imx135vb_720p_dvs_binning_video",
+		.regs = imx135vb_720p_dvs_binning,
+		.width = 1568,
+		.height = 880,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+	},
+	{
+		.desc = "imx135_wvga_dvs_binning_video",
+		.regs = imx135vb_wvga_dvs_binning,
+		.width = 1640,
+		.height = 1024,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5464,
+				 .lines_per_frame = 2046,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+	},
+	{
+		.desc = "imx135vb_1080P_dvs_video",
+		.regs = imx135vb_2336x1320_max_clock,
+		.width = 2336,
+		.height = 1320,
+		.fps_options = {
+			{/* Pixel Clock : 360.96 MHz */
+				 .fps = 30,
+				 .pixels_per_line = 4572,
+				 .lines_per_frame = 2632,
+			},
+			{
+			}
+		},
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+	},
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/imx175.h b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx175.h
new file mode 100644
index 0000000..5f409cc
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/imx175.h
@@ -0,0 +1,1959 @@
+#ifndef __IMX175_H__
+#define __IMX175_H__
+#include "common.h"
+
+/************************** settings for imx *************************/
+static struct imx_reg const imx_STILL_8M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xFC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x09},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xC4},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x66},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x0C},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0xD0},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x09},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0xA0},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_8M_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xFC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x0B},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xB8},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x16},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x44},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x0C},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0xD0},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x09},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0xA0},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_3M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xEF},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x09},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xC4},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x66},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x08},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x10},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x06},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x10},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x02}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x19}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_3M_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xEF},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x0B},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xB8},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x16},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x44},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x08},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x10},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x06},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x10},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x02}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x19}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+
+static struct imx_reg const imx_STILL_5M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xEF},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x09},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xC4},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x66},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x0A},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x10},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x07},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x90},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x02}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x14}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_5M_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xEF},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x0B},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xB8},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x16},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x44},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x0A},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x10},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x07},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x90},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x14}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_6M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xEF},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x09},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xC4},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x66},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x01},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x32},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x6D},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x0C},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0xD0},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x07},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x3C},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_6M_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xEF},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x0B},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xB8},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x16},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x44},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x01},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x32},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x6D},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x0C},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0xD0},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x07},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x3C},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_2M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x8C},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x09},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xC4},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x66},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x06},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x68},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x04},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0xD0},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x01}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_2M_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x0A},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x8C},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x2c},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x0B},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xB8},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x16},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x44},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x06},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x68},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x04},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0xD0},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x01}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x77},
+	{IMX_8BIT, 0x3371, 0x2F},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x2F},
+	{IMX_8BIT, 0x3375, 0x37},
+	{IMX_8BIT, 0x3376, 0x9F},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x09},
+	{IMX_8BIT, 0x33D7, 0xA0},
+
+	{IMX_8BIT, 0x030e, 0x01},
+	{IMX_8BIT, 0x41c0, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_PREVIEW_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x44},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x06},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x05},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x48},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x70},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x03},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x34},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x02},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x68},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x02}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x03},
+	{IMX_8BIT, 0x33D5, 0x34},
+	{IMX_8BIT, 0x33D6, 0x02},
+	{IMX_8BIT, 0x33D7, 0x68},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_WIDE_PREVIEW_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x44},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x06},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x0D},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x70},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x10},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x00},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x14},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x8C},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x06},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x68},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x03},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0xBC},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x01}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x06},
+	{IMX_8BIT, 0x33D5, 0x68},
+	{IMX_8BIT, 0x33D6, 0x03},
+	{IMX_8BIT, 0x33D7, 0xBC},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/*****************************video************************/
+static struct imx_reg const imx_1080p_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x06},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x4C},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x12},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x06},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xA4},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x11},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0xC6},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x01},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0xDB},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x02},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x42},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0A},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xEA},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x07},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x61},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x09},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x10},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x05},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x20},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x6F},
+	{IMX_8BIT, 0x3371, 0x27},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x27},
+	{IMX_8BIT, 0x3375, 0x2F},
+	{IMX_8BIT, 0x3376, 0x97},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x07},
+	{IMX_8BIT, 0x33D7, 0x38},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_1080p_no_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x08},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xD5},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x12},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x07},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xD0},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0F},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x3C},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x01},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x34},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x6B},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x07},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x94},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x04},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x44},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x02}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x1B}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x6F},
+	{IMX_8BIT, 0x3371, 0x27},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x27},
+	{IMX_8BIT, 0x3375, 0x2F},
+	{IMX_8BIT, 0x3376, 0x97},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x07},
+	{IMX_8BIT, 0x33D7, 0x38},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_1080p_no_dvs_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x08},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xD5},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x12},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x09},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xA6},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x18},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x9C},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x01},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x34},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x6B},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x07},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x94},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x04},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x44},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x02}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x1B}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x6F},
+	{IMX_8BIT, 0x3371, 0x27},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x27},
+	{IMX_8BIT, 0x3375, 0x2F},
+	{IMX_8BIT, 0x3376, 0x97},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x07},
+	{IMX_8BIT, 0x33D7, 0x38},
+	{IMX_TOK_TERM, 0, 0}
+};
+/*****************************video************************/
+static struct imx_reg const imx_720p_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xFC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x12},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x06},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x00},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x13},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x9C},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x01},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0xD7},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x02},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x3E},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0A},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xEE},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x07},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x65},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x06},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x10},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x03},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x70},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x00}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x02}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x18}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x6F},
+	{IMX_8BIT, 0x3371, 0x27},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x27},
+	{IMX_8BIT, 0x3375, 0x2F},
+	{IMX_8BIT, 0x3376, 0x97},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x07},
+	{IMX_8BIT, 0x33D7, 0x38},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_480p_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xFC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x12},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x06},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x00},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x13},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x9C},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x01},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0xD4},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x01},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0xC8},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0A},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xF1},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x07},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0xDB},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x03},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x70},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x02},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x50},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x01}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x02}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x15}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x6F},
+	{IMX_8BIT, 0x3371, 0x27},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x27},
+	{IMX_8BIT, 0x3375, 0x2F},
+	{IMX_8BIT, 0x3376, 0x97},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x07},
+	{IMX_8BIT, 0x33D7, 0x38},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_720p_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x44},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x04},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x05},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x48},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x14},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x28},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x48},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x01},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x64},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0x87},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x3B},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x06},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x20},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x03},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x6C},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x01}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x06},
+	{IMX_8BIT, 0x33D5, 0x20},
+	{IMX_8BIT, 0x33D6, 0x03},
+	{IMX_8BIT, 0x33D7, 0x6C},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_STILL_720p_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x44},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x04},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x08},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0xCA},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x18},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x38},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x48},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x01},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x64},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0x87},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x3B},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x06},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x20},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x03},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x6C},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x01}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x06},
+	{IMX_8BIT, 0x33D5, 0x20},
+	{IMX_8BIT, 0x33D6, 0x03},
+	{IMX_8BIT, 0x33D7, 0x6C},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_WVGA_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xEC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x09},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x12},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x06},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x00},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x13},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x9C},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0xD0},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x08},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0xCF},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x06},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x68},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x04},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x00},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x01}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x57},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x6F},
+	{IMX_8BIT, 0x3371, 0x27},
+	{IMX_8BIT, 0x3372, 0x4F},
+	{IMX_8BIT, 0x3373, 0x2F},
+	{IMX_8BIT, 0x3374, 0x27},
+	{IMX_8BIT, 0x3375, 0x2F},
+	{IMX_8BIT, 0x3376, 0x97},
+	{IMX_8BIT, 0x3377, 0x37},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x0C},
+	{IMX_8BIT, 0x33D5, 0xD0},
+	{IMX_8BIT, 0x33D6, 0x07},
+	{IMX_8BIT, 0x33D7, 0x38},
+	{IMX_TOK_TERM, 0, 0}
+};
+static struct imx_reg const imx_CIF_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xFC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x04},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x06},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x00},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x11},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0xDB},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x01},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x70},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x01},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x30},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x02}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x06},
+	{IMX_8BIT, 0x33D5, 0x20},
+	{IMX_8BIT, 0x33D6, 0x03},
+	{IMX_8BIT, 0x33D7, 0x6C},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_VGA_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xFC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x04},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x06},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x00},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x11},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x94},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x03},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x34},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x02},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x68},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x02}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x06},
+	{IMX_8BIT, 0x33D5, 0x20},
+	{IMX_8BIT, 0x33D6, 0x03},
+	{IMX_8BIT, 0x33D7, 0x6C},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_VGA_strong_dvs_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0xFC},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x04},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x07},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x9E},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x1C},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0xB6},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x00},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x00},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x00},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x00},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x0C},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0xCF},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x09},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x9F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x03},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x34},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x02},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x68},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x02}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x06},
+	{IMX_8BIT, 0x33D5, 0x20},
+	{IMX_8BIT, 0x33D6, 0x03},
+	{IMX_8BIT, 0x33D7, 0x6C},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_QVGA_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x44},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x06},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x05},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x48},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x70},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x03},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0x38},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x02},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x68},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x09},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0x97},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x07},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x37},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x01},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0x98},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x01},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0x34},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x02}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x01},
+	{IMX_8BIT, 0x33D5, 0x98},
+	{IMX_8BIT, 0x33D6, 0x01},
+	{IMX_8BIT, 0x33D7, 0x34},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx_QCIF_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0100, 0x00},  /*	mode_select	*/
+	/* shutter */
+	{IMX_8BIT, 0x0202, 0x05},  /* coarse _integration_time[15:8] */
+	{IMX_8BIT, 0x0203, 0x44},  /* coarse _integration_time[7:0] */
+	/* pll */
+	{IMX_8BIT, 0x0301, 0x05},  /*	vt_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0303, 0x01},  /*	vt_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0305, 0x06},  /*	pre_pll_clk_div[7:0]	*/
+	{IMX_8BIT, 0x0309, 0x05},  /*	op_pix_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030B, 0x01},  /*	op_sys_clk_div[7:0]	*/
+	{IMX_8BIT, 0x030C, 0x00},
+	{IMX_8BIT, 0x030D, 0x6D},
+	/* image sizing */
+	{IMX_8BIT, 0x0340, 0x05},  /* frame_length_lines[15:8] */
+	{IMX_8BIT, 0x0341, 0x48},  /*	frame_length_lines[7:0]	*/
+	{IMX_8BIT, 0x0342, 0x0D},  /*	line_length_pck[15:8]	*/
+	{IMX_8BIT, 0x0343, 0x70},  /*	line_length_pck[7:0]	*/
+	{IMX_8BIT, 0x0344, 0x04},  /*	x_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0345, 0xB8},  /*	x_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0346, 0x03},  /*	y_addr_start[15:8]	*/
+	{IMX_8BIT, 0x0347, 0x70},  /*	y_addr_start[7:0]	*/
+	{IMX_8BIT, 0x0348, 0x08},  /*	x_addr_end[15:8]	*/
+	{IMX_8BIT, 0x0349, 0x17},  /*	x_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034A, 0x06},  /*	y_addr_end[15:8]	*/
+	{IMX_8BIT, 0x034B, 0x2F},  /*	y_addr_end[7:0]	*/
+	{IMX_8BIT, 0x034C, 0x00},  /*	x_output_size[15:8]	*/
+	{IMX_8BIT, 0x034D, 0xD8},  /*	x_output_size[7:0]	*/
+	{IMX_8BIT, 0x034E, 0x00},  /*	y_output_size[15:8]	*/
+	{IMX_8BIT, 0x034F, 0xB0},  /*	y_output_size[7:0]	*/
+	/* binning & scaling */
+	{IMX_8BIT, 0x0390, 0x02}, /* binning mode */
+	{IMX_8BIT, 0x0401, 0x00}, /* scaling mode*/
+	{IMX_8BIT, 0x0405, 0x10}, /* scale_m[7:0] */
+	/* timer */
+	{IMX_8BIT, 0x3344, 0x37},
+	{IMX_8BIT, 0x3345, 0x1F},
+	/* timing */
+	{IMX_8BIT, 0x3370, 0x5F},
+	{IMX_8BIT, 0x3371, 0x17},
+	{IMX_8BIT, 0x3372, 0x37},
+	{IMX_8BIT, 0x3373, 0x17},
+	{IMX_8BIT, 0x3374, 0x17},
+	{IMX_8BIT, 0x3375, 0x0F},
+	{IMX_8BIT, 0x3376, 0x57},
+	{IMX_8BIT, 0x3377, 0x27},
+	{IMX_8BIT, 0x33C8, 0x01},
+	{IMX_8BIT, 0x33D4, 0x00},
+	{IMX_8BIT, 0x33D5, 0xD8},
+	{IMX_8BIT, 0x33D6, 0x00},
+	{IMX_8BIT, 0x33D7, 0xB0},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static struct imx_reg const imx175_init_settings[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x0103, 0x01},
+	/* misc control */
+	{IMX_8BIT, 0x3020, 0x10},
+	{IMX_8BIT, 0x302D, 0x02},
+	{IMX_8BIT, 0x302F, 0x80},
+	{IMX_8BIT, 0x3032, 0xA3},
+	{IMX_8BIT, 0x3033, 0x20},
+	{IMX_8BIT, 0x3034, 0x24},
+	{IMX_8BIT, 0x3041, 0x15},
+	{IMX_8BIT, 0x3042, 0x87},
+	{IMX_8BIT, 0x3050, 0x35},
+	{IMX_8BIT, 0x3056, 0x57},
+	{IMX_8BIT, 0x305D, 0x41},
+	{IMX_8BIT, 0x3097, 0x69},
+	{IMX_8BIT, 0x3109, 0x41},
+	{IMX_8BIT, 0x3148, 0x3F},
+	{IMX_8BIT, 0x330F, 0x07},
+	/* csi & inck */
+	{IMX_8BIT, 0x3364, 0x00},
+	{IMX_8BIT, 0x3368, 0x13},
+	{IMX_8BIT, 0x3369, 0x33},
+	/* znr */
+	{IMX_8BIT, 0x4100, 0x0E},
+	{IMX_8BIT, 0x4104, 0x32},
+	{IMX_8BIT, 0x4105, 0x32},
+	{IMX_8BIT, 0x4108, 0x01},
+	{IMX_8BIT, 0x4109, 0x7C},
+	{IMX_8BIT, 0x410A, 0x00},
+	{IMX_8BIT, 0x410B, 0x00},
+	GROUPED_PARAMETER_HOLD_DISABLE,
+	{IMX_TOK_TERM, 0, 0}
+};
+/* TODO settings of preview/still/video will be updated with new use case */
+struct imx_resolution imx175_res_preview[] = {
+	{
+		.desc = "CIF_strong_dvs_30fps",
+		.regs = imx_CIF_strong_dvs_30fps,
+		.width = 368,
+		.height = 304,
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x11DB,
+				 .lines_per_frame = 0x0600,
+			},
+			{
+			}
+		},
+		.mipi_freq = 261500,
+
+	},
+	{
+		.desc = "VGA_strong_dvs_30fps",
+		.regs = imx_VGA_strong_dvs_30fps,
+		.width = 820,
+		.height = 616,
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x11DB,
+				 .lines_per_frame = 0x0600,
+			},
+			{
+			}
+		},
+		.mipi_freq = 261500,
+	},
+	{
+		.desc = "WIDE_PREVIEW_30fps",
+		.regs = imx_WIDE_PREVIEW_30fps,
+		.width = 1640,
+		.height = 956,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x1000,
+				 .lines_per_frame = 0x0D70,
+			},
+			{
+			}
+		},
+		.mipi_freq = 174500,
+	},
+	{
+		.desc = "STILL_720p_30fps",
+		.regs = imx_STILL_720p_30fps,
+		.width = 1568,
+		.height = 876,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x1428,
+				 .lines_per_frame = 0x0548,
+			},
+			{
+			}
+		},
+		.mipi_freq = 261500,
+	},
+	{
+		.desc = "STILL_2M_30fps",
+		.regs = imx_STILL_2M_30fps,
+		.width = 1640,
+		.height = 1232,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D66,
+				 .lines_per_frame = 0x09C4,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "1080p_strong_dvs_30fps",
+		.regs = imx_1080p_no_dvs_30fps,
+		.width = 1940,
+		.height = 1092,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0F3C,
+				 .lines_per_frame = 0x07D0,
+			},
+			{
+			}
+		},
+		.mipi_freq = 292500,
+	},
+	{
+		.desc = "STILL_3M_30fps",
+		.regs = imx_STILL_3M_30fps,
+		.width = 2064,
+		.height = 1552,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D66,
+				 .lines_per_frame = 0x09C4,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "STILL_5M_30fps",
+		.regs = imx_STILL_5M_30fps,
+		.width = 2576,
+		.height = 1936,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D66,
+				 .lines_per_frame = 0x09C4,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "STILL_6M_30fps",
+		.regs = imx_STILL_6M_30fps,
+		.width = 3280,
+		.height = 1852,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D66,
+				 .lines_per_frame = 0x09C4,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "STILL_8M_30fps",
+		.regs = imx_STILL_8M_30fps,
+		.width = 3280,
+		.height = 2464,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D66,
+				 .lines_per_frame = 0x09C4,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+};
+
+struct imx_resolution imx175_res_still[] = {
+	{
+		.desc = "CIF_strong_dvs_30fps",
+		.regs = imx_CIF_strong_dvs_30fps,
+		.width = 368,
+		.height = 304,
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x11DB,
+				 .lines_per_frame = 0x0600,
+			},
+			{
+			}
+		},
+		.mipi_freq = 261000,
+	},
+	{
+		.desc = "VGA_strong_dvs_15fps",
+		.regs = imx_VGA_strong_dvs_15fps,
+		.width = 820,
+		.height = 616,
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x1C86,
+				 .lines_per_frame = 0x079E,
+			},
+			{
+			}
+		},
+		.mipi_freq = 261500,
+	},
+	{
+		.desc = "imx_STILL_720p_15fps",
+		.regs = imx_STILL_720p_15fps,
+		.width = 1568,
+		.height = 876,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x1838,
+				 .lines_per_frame = 0x08CA,
+			},
+			{
+			}
+		},
+		.mipi_freq = 261500,
+	},
+	{
+		.desc = "STILL_2M_15fps",
+		.regs = imx_STILL_2M_15fps,
+		.width = 1640,
+		.height = 1232,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x1646,
+				 .lines_per_frame = 0x0BB8,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "1080p_strong_dvs_15fps",
+		.regs = imx_1080p_no_dvs_15fps,
+		.width = 1940,
+		.height = 1092,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x189C,
+				 .lines_per_frame = 0x09A6,
+			},
+			{
+			}
+		},
+		.mipi_freq = 292500,
+	},
+	{
+		.desc = "STILL_3M_15fps",
+		.regs = imx_STILL_3M_15fps,
+		.width = 2064,
+		.height = 1552,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x1646,
+				 .lines_per_frame = 0x0BB8,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "STILL_5M_15fps",
+		.regs = imx_STILL_5M_15fps,
+		.width = 2576,
+		.height = 1936,
+		.fps = 15,
+		.pixels_per_line = 0x1646, /* consistent with regs arrays */
+		.lines_per_frame = 0x0BB8, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x1646,
+				 .lines_per_frame = 0x0BB8,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "STILL_6M_15fps",
+		.regs = imx_STILL_6M_15fps,
+		.width = 3280,
+		.height = 1852,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x1646,
+				 .lines_per_frame = 0x0BB8,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+	{
+		.desc = "STILL_8M_15fps",
+		.regs = imx_STILL_8M_15fps,
+		.width = 3280,
+		.height = 2464,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 15,
+				 .pixels_per_line = 0x1646,
+				 .lines_per_frame = 0x0BB8,
+			},
+			{
+			}
+		},
+		.mipi_freq = 320000,
+	},
+};
+
+struct imx_resolution imx175_res_video[] = {
+	{
+		.desc = "QCIF_strong_dvs_30fps",
+		.regs = imx_QCIF_strong_dvs_30fps,
+		.width = 216,
+		.height = 176,
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D70,
+				 .lines_per_frame = 0x0548,
+			},
+			{
+			}
+		},
+		.mipi_freq = 174500,
+	},
+	{
+		.desc =	"QVGA_strong_dvs_30fps",
+		.regs = imx_QVGA_strong_dvs_30fps,
+		.width = 408,
+		.height = 308,
+		.bin_factor_x =	4,
+		.bin_factor_y =	4,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x0D70,
+				 .lines_per_frame = 0x0548,
+			},
+			{
+			}
+		},
+		.mipi_freq = 174500,
+	},
+	{
+		.desc = "VGA_strong_dvs_30fps",
+		.regs = imx_VGA_strong_dvs_30fps,
+		.width = 820,
+		.height = 616,
+		.bin_factor_x = 4,
+		.bin_factor_y = 4,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x1194,
+				 .lines_per_frame = 0x0600,
+			},
+			{
+			}
+		},
+		.mipi_freq = 261500,
+	},
+	{
+		.desc = "720p_strong_dvs_30fps",
+		.regs = imx_720p_strong_dvs_30fps,
+		.width = 1552,
+		.height = 880,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x139C,
+				 .lines_per_frame = 0x0600,
+			},
+			{
+				 .fps = 60,
+				 .pixels_per_line = 0xD70,
+				 .lines_per_frame = 0x444,
+			},
+			{
+			}
+		},
+		.mipi_freq = 292500,
+	},
+	{
+		.desc = "480p_strong_dvs_30fps",
+		.regs = imx_480p_strong_dvs_30fps,
+		.width = 880,
+		.height = 592,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x139C,
+				 .lines_per_frame = 0x0600,
+			},
+			{
+			}
+		},
+		.mipi_freq = 292500,
+	},
+	{
+		.desc = "WVGA_strong_dvs_30fps",
+		.regs = imx_WVGA_strong_dvs_30fps,
+		.width = 1640,
+		.height = 1024,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x139C,
+				 .lines_per_frame = 0x0600,
+			},
+			{
+			}
+		},
+		.mipi_freq = 292500,
+	},
+	{
+		.desc = "1080p_strong_dvs_30fps",
+		.regs = imx_1080p_strong_dvs_30fps,
+		.width = 2320,
+		.height = 1312,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 0x11C6,
+				 .lines_per_frame = 0x06A4,
+			},
+			{
+			}
+		},
+		.mipi_freq = 292500,
+	},
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c
new file mode 100644
index 0000000..5bec690
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+
+void *dummy_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 *buf;
+
+	buf = devm_kzalloc(&client->dev, size, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	return buf;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c
new file mode 100644
index 0000000..3668533
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_e2prom.c
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include "common.h"
+
+/*
+ * Read EEPROM data from the gerneral e2prom chip(eg.
+ * CAT24C08, CAT24C128, le24l042cs, and store
+ * it into a kmalloced buffer. On error return NULL.
+ * @size: set to the size of the returned EEPROM data.
+ */
+void *e2prom_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int e2prom_i2c_addr = dev_addr >> 1;
+	static const unsigned int max_read_size = 30;
+	int addr;
+	u32 s_addr = start_addr & E2PROM_ADDR_MASK;
+	bool two_addr = (start_addr & E2PROM_2ADDR) >> 31;
+	char *buffer;
+
+	buffer = devm_kzalloc(&client->dev, size, GFP_KERNEL);
+	if (!buffer)
+		return NULL;
+
+	for (addr = s_addr; addr < size; addr += max_read_size) {
+		struct i2c_msg msg[2];
+		unsigned int i2c_addr = e2prom_i2c_addr;
+		u16 addr_buf;
+		int r;
+
+		msg[0].flags = 0;
+		if (two_addr) {
+			msg[0].addr = i2c_addr;
+			addr_buf = cpu_to_be16(addr & 0xFFFF);
+			msg[0].len = 2;
+			msg[0].buf = (u8 *)&addr_buf;
+		} else {
+			i2c_addr |= (addr >> 8) & 0x7;
+			msg[0].addr = i2c_addr;
+			addr_buf = addr & 0xFF;
+			msg[0].len = 1;
+			msg[0].buf = (u8 *)&addr_buf;
+		}
+
+		msg[1].addr = i2c_addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].len = min(max_read_size, size - addr);
+		msg[1].buf = &buffer[addr];
+
+		r = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+		if (r != ARRAY_SIZE(msg)) {
+			kfree(buffer);
+			dev_err(&client->dev, "read failed at 0x%03x\n", addr);
+			return NULL;
+		}
+	}
+	return buffer;
+}
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c
new file mode 100644
index 0000000..e527445
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/otp_imx.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <asm/intel-mid.h>
+#include "common.h"
+
+/* Defines for OTP Data Registers */
+#define IMX_OTP_START_ADDR		0x3B04
+#define IMX_OTP_PAGE_SIZE		64
+#define IMX_OTP_READY_REG		0x3B01
+#define IMX_OTP_PAGE_REG		0x3B02
+#define IMX_OTP_MODE_REG		0x3B00
+#define IMX_OTP_PAGE_MAX		20
+#define IMX_OTP_READY_REG_DONE		1
+#define IMX_OTP_READ_ONETIME		32
+#define IMX_OTP_MODE_READ		1
+
+static int
+imx_read_otp_data(struct i2c_client *client, u16 len, u16 reg, void *val)
+{
+	struct i2c_msg msg[2];
+	u16 data[IMX_SHORT_MAX] = { 0 };
+	int err;
+
+	if (len > IMX_BYTE_MAX) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+	memset(data, 0 , sizeof(data));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
+
+	msg[1].addr = client->addr;
+	msg[1].len = len;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (u8 *)data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		goto error;
+	}
+
+	memcpy(val, data, len);
+	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int imx_read_otp_reg_array(struct i2c_client *client, u16 size, u16 addr,
+				  u8 *buf)
+{
+	u16 index;
+	int ret;
+
+	for (index = 0; index + IMX_OTP_READ_ONETIME <= size;
+					index += IMX_OTP_READ_ONETIME) {
+		ret = imx_read_otp_data(client, IMX_OTP_READ_ONETIME,
+					addr + index, &buf[index]);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+void *imx_otp_read(struct v4l2_subdev *sd, u8 dev_addr,
+	u32 start_addr, u32 size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 *buf;
+	int ret;
+	int i;
+
+	buf = devm_kzalloc(&client->dev, size, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	for (i = 0; i < IMX_OTP_PAGE_MAX; i++) {
+
+		/*set page NO.*/
+		ret = imx_write_reg(client, IMX_8BIT,
+			       IMX_OTP_PAGE_REG, i & 0xff);
+		if (ret)
+			goto fail;
+
+		/*set read mode*/
+		ret = imx_write_reg(client, IMX_8BIT,
+			       IMX_OTP_MODE_REG, IMX_OTP_MODE_READ);
+		if (ret)
+			goto fail;
+
+		/* Reading the OTP data array */
+		ret = imx_read_otp_reg_array(client, IMX_OTP_PAGE_SIZE,
+			IMX_OTP_START_ADDR, buf + i * IMX_OTP_PAGE_SIZE);
+		if (ret)
+			goto fail;
+	}
+
+	return buf;
+fail:
+	/* Driver has failed to find valid data */
+	dev_err(&client->dev, "sensor found no valid OTP data\n");
+	return ERR_PTR(ret);
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx/vcm.c b/drivers/external_drivers/camera/drivers/media/i2c/imx/vcm.c
new file mode 100644
index 0000000..9836513
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx/vcm.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <media/v4l2-device.h>
+#include <linux/atomisp_platform.h>
+
+int vcm_power_up(struct v4l2_subdev *sd)
+{
+	const struct camera_af_platform_data *vcm_platform_data;
+
+	vcm_platform_data = camera_get_af_platform_data();
+	if (NULL == vcm_platform_data)
+		return -ENODEV;
+	/* Enable power */
+	return vcm_platform_data->power_ctrl(sd, 1);
+}
+
+int vcm_power_down(struct v4l2_subdev *sd)
+{
+	const struct camera_af_platform_data *vcm_platform_data;
+
+	vcm_platform_data = camera_get_af_platform_data();
+	if (NULL == vcm_platform_data)
+		return -ENODEV;
+	return vcm_platform_data->power_ctrl(sd, 0);
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Kconfig
new file mode 100644
index 0000000..c32b5d3
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Kconfig
@@ -0,0 +1,12 @@
+config VIDEO_IMXVB
+	tristate "sony imx sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Sony
+	  IMX RAW sensor.
+
+	  It currently depends on internal V4L2 extensions defined in
+	  atomisp driver.
+
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Makefile
new file mode 100644
index 0000000..a09624d
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/Makefile
@@ -0,0 +1,8 @@
+obj-$(CONFIG_VIDEO_IMXVB) += imx1x5.o
+
+# Select the correct sensor objects.
+imx1x5-objs-$(CONFIG_VIDEO_IMXVB)	+= dw9719.o
+
+imx1x5-objs	:= imx.o $(imx1x5-objs-m)
+
+ccflags-y += -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c
new file mode 100644
index 0000000..0236089
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.c
@@ -0,0 +1,182 @@
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+
+#include "dw9719.h"
+
+static struct dw9719_device dw9719_dev;
+static int dw9719_i2c_rd8(struct i2c_client *client, u8 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2] = { reg };
+
+	msg[0].addr = DW9719_VCM_ADDR;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = &buf[0];
+
+	msg[1].addr = DW9719_VCM_ADDR;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = &buf[1];
+	*val = 0;
+	if (i2c_transfer(client->adapter, msg, 2) != 2)
+		return -EIO;
+	*val = buf[1];
+	return 0;
+}
+
+static int dw9719_i2c_wr8(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct i2c_msg msg;
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = val;
+	msg.addr = DW9719_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 2;
+	msg.buf = &buf[0];
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+	return 0;
+}
+static int dw9719_i2c_wr16(struct i2c_client *client, u8 reg, u16 val)
+{
+	struct i2c_msg msg;
+	u8 buf[3];
+	buf[0] = reg;
+	buf[1] = (u8)(val >> 8);
+	buf[2] = (u8)(val & 0xff);
+	msg.addr = DW9719_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = 3;
+	msg.buf = &buf[0];
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+	return 0;
+}
+
+int imx_vcm_power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 value;
+
+	/* Enable power */
+	ret = dw9719_dev.platform_data->power_ctrl(sd, 1);
+	/* waiting time requested by DW9714A(vcm) */
+	if (ret)
+		return ret;
+	/* Wait for VBAT to stabilize */
+	udelay(1);
+	/*
+	 * Jiggle SCL pin to wake up device.
+	 */
+	ret = dw9719_i2c_wr8(client, DW9719_CONTROL, 1);
+	/* Need 100us to transit from SHUTDOWN to STANDBY*/
+	usleep_range(100, 1000);
+
+	/* Reset device */
+	ret = dw9719_i2c_wr8(client, DW9719_CONTROL, 1);
+	if (ret < 0)
+		goto fail_powerdown;
+
+	/* Detect device */
+	ret = dw9719_i2c_rd8(client, DW9719_INFO, &value);
+	if (ret < 0)
+		goto fail_powerdown;
+	if (value != DW9719_ID) {
+		ret = -ENXIO;
+		goto fail_powerdown;
+	}
+	dw9719_dev.focus = DW9719_MAX_FOCUS_POS;
+	dw9719_dev.initialized = true;
+
+	return 0;
+fail_powerdown:
+	dw9719_dev.platform_data->power_ctrl(sd, 0);
+	return ret;
+
+}
+
+int imx_vcm_power_down(struct v4l2_subdev *sd)
+{
+	return dw9719_dev.platform_data->power_ctrl(sd, 0);
+}
+
+int imx_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	static const struct timespec move_time = {
+
+		.tv_sec = 0,
+		.tv_nsec = 60000000
+	};
+	struct timespec current_time, finish_time, delta_time;
+	getnstimeofday(&current_time);
+	finish_time = timespec_add(dw9719_dev.focus_time, move_time);
+	delta_time = timespec_sub(current_time, finish_time);
+	if (delta_time.tv_sec >= 0 && delta_time.tv_nsec >= 0) {
+		*value = ATOMISP_FOCUS_HP_COMPLETE |
+			 ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+	} else {
+		*value = ATOMISP_FOCUS_STATUS_MOVING |
+			 ATOMISP_FOCUS_HP_IN_PROGRESS;
+	}
+	return 0;
+}
+
+int imx_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	value = clamp(value, 0, DW9719_MAX_FOCUS_POS);
+	ret = dw9719_i2c_wr16(client, DW9719_VCM_CURRENT, DW9719_MAX_FOCUS_POS - value);
+	if (ret < 0)
+		return ret;
+	getnstimeofday(&dw9719_dev.focus_time);
+	dw9719_dev.focus = value;
+	return 0;
+}
+
+int imx_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	return imx_t_focus_abs(sd, dw9719_dev.focus + value);
+}
+
+int imx_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	*value  = dw9719_dev.focus ;
+	return 0;
+}
+int imx_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int imx_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+int imx_vcm_init(struct v4l2_subdev *sd)
+{
+	dw9719_dev.platform_data = camera_get_af_platform_data();
+	return (NULL == dw9719_dev.platform_data) ? -ENODEV : 0;
+
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.h b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.h
new file mode 100644
index 0000000..6439203
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/dw9719.h
@@ -0,0 +1,39 @@
+#ifndef __DW9719_H__
+#define __DW9719_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+
+
+#define DW9719_VCM_ADDR	 (0x18 >> 1)
+
+/* dw9719 device structure */
+struct dw9719_device {
+	struct timespec timestamp_t_focus_abs;
+	s16 number_of_steps;
+	bool initialized;		/* true if dw9719 is detected */
+	s32 focus;			/* Current focus value */
+	struct timespec focus_time;	/* Time when focus was last time set */
+	__u8 buffer[4];			/* Used for i2c transactions */
+	const struct camera_af_platform_data *platform_data;
+};
+
+#define DW9719_INVALID_CONFIG	0xffffffff
+#define DW9719_MAX_FOCUS_POS	1023
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+
+#define DW9719_INFO			0
+#define DW9719_ID			0xF1
+#define DW9719_CONTROL			2
+#define DW9719_VCM_CURRENT		3
+
+#define DW9719_MODE			6
+#define DW9719_VCM_FREQ			7
+
+#define DW9719_DEFAULT_VCM_FREQ		0xe6
+#define DW9719_MIN_DEFAULT_VCM_FREQ	0x00
+#define DW9719_MAX_DEFAULT_VCM_FREQ	0xff
+#define DW9719_MODE_LINEAR		2
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.c b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.c
new file mode 100644
index 0000000..50213dc
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.c
@@ -0,0 +1,1702 @@
+/*
+ * Support for Sony imx 8MP camera sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include "imx.h"
+
+static int
+imx_read_reg(struct i2c_client *client, u16 len, u16 reg, void *val, bool otpck)
+{
+	struct i2c_msg msg[2];
+	u16 data[IMX_SHORT_MAX] = { 0 };
+	int err, i;
+
+	if (len > IMX_BYTE_MAX) {
+		v4l2_err(client, "%s error, invalid data length\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
+
+	msg[1].addr = client->addr;
+	msg[1].len = len;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (u8 *)data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		goto error;
+	}
+
+	if (otpck == 1) {
+		memcpy(val, data, len);
+		otpck = 0;
+	} else if (len == IMX_8BIT) {
+		*((u16 *)val) = (u8)data[0];
+	} else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			((u16 *)val)[i] = be16_to_cpu(data[i]);
+	}
+
+	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int imx_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int
+imx_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg = (u16 *)data;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (data_length != IMX_8BIT && data_length != IMX_16BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == IMX_8BIT)
+		data[2] = (u8)(val);
+	else {
+		/* IMX_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
+
+	ret = imx_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * imx_write_reg_array - Initializes a list of imx registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __imx_flush_reg_array, __imx_buf_reg_array() and
+ * __imx_write_reg_is_consecutive() are internal functions to
+ * imx_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __imx_flush_reg_array(struct i2c_client *client,
+				     struct imx_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return imx_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __imx_buf_reg_array(struct i2c_client *client,
+				   struct imx_write_ctrl *ctrl,
+				   const struct imx_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case IMX_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case IMX_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = (u16)next->val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->sreg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= IMX_MAX_WRITE_BUF_SIZE)
+		return __imx_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int
+__imx_write_reg_is_consecutive(struct i2c_client *client,
+				   struct imx_write_ctrl *ctrl,
+				   const struct imx_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->sreg;
+}
+
+static int imx_write_reg_array(struct i2c_client *client,
+				   const struct imx_reg *reglist)
+{
+	const struct imx_reg *next = reglist;
+	struct imx_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != IMX_TOK_TERM; next++) {
+		switch (next->type & IMX_TOK_MASK) {
+		case IMX_TOK_DELAY:
+			err = __imx_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__imx_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __imx_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __imx_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __imx_flush_reg_array(client, &ctrl);
+}
+
+static int imx_read_otp_reg_array(struct i2c_client *client, u16 size, u16 addr,
+				  u8 *buf)
+{
+	u16 index;
+	int ret;
+
+	for (index = 0; index + IMX_OTP_READ_ONETIME <= size;
+					index += IMX_OTP_READ_ONETIME) {
+		ret = imx_read_reg(client, IMX_OTP_READ_ONETIME, addr + index,
+					&buf[index], 1);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static int __imx_otp_read(struct v4l2_subdev *sd, u8 *buf)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	int i;
+
+	for (i = 0; i < IMX_OTP_PAGE_MAX; i++) {
+
+		/*set page NO.*/
+		ret = imx_write_reg(client, IMX_8BIT,
+			       IMX_OTP_PAGE_REG, i & 0xff);
+		if (ret) {
+			dev_err(&client->dev, "failed to prepare OTP page\n");
+			return ret;
+		}
+
+		/*set read mode*/
+		ret = imx_write_reg(client, IMX_8BIT,
+			       IMX_OTP_MODE_REG, IMX_OTP_MODE_READ);
+		if (ret) {
+			dev_err(&client->dev, "failed to set OTP reading mode page");
+			return ret;
+		}
+
+		/* Reading the OTP data array */
+		ret = imx_read_otp_reg_array(client, IMX_OTP_PAGE_SIZE,
+			IMX_OTP_START_ADDR, buf + i * IMX_OTP_PAGE_SIZE);
+		if (ret) {
+			dev_err(&client->dev, "failed to read OTP data\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void *imx_otp_read(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 *buf;
+	int ret;
+
+	buf = devm_kzalloc(&client->dev, IMX_OTP_DATA_SIZE, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	ret = __imx_otp_read(sd, buf);
+
+	/* Driver has failed to find valid data */
+	if (ret) {
+		dev_err(&client->dev, "sensor found no valid OTP data\n");
+		return ERR_PTR(ret);
+	}
+
+	return buf;
+}
+static long __imx_set_exposure(struct v4l2_subdev *sd, unsigned int coarse_itg,
+			       unsigned int gain, unsigned int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	struct imx_device *dev = to_imx_sensor(sd);
+	u16 vts = dev->lines_per_frame;
+
+	/* enable group hold */
+	ret = imx_write_reg_array(client, imx_param_hold);
+	if (ret)
+		goto out;
+
+	/* imx max exposure is VTS-4 */
+	if (coarse_itg > dev->lines_per_frame - IMX_INTEGRATION_TIME_MARGIN)
+		vts = coarse_itg + IMX_INTEGRATION_TIME_MARGIN;
+
+	ret = imx_write_reg(client, IMX_16BIT, IMX_FRAME_LENGTH_LINES, vts);
+	if (ret)
+		return ret;
+
+	ret = imx_write_reg(client, IMX_16BIT,
+		IMX_COARSE_INTEGRATION_TIME, coarse_itg);
+	if (ret)
+		goto out;
+
+	/* set global gain */
+	ret = imx_write_reg(client, IMX_8BIT,
+		IMX_GLOBAL_GAIN, gain);
+	if (ret)
+		goto out_disable;
+
+	/* digital gain: GR */
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ, (digitgain >> 8) & 0xFF);
+	if (ret)
+		return ret;
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ+1, digitgain & 0xFF);
+	if (ret)
+		return ret;
+	/* digital gain: R */
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ+2, (digitgain >> 8) & 0xFF);
+	if (ret)
+		return ret;
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ+3, digitgain & 0xFF);
+	if (ret)
+		return ret;
+	/*  digital gain: B */
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ+4, (digitgain >> 8) & 0xFF);
+	if (ret)
+		return ret;
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ+5, digitgain & 0xFF);
+	if (ret)
+		return ret;
+	/* digital gain: GB */
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ+6, (digitgain >> 8) & 0xFF);
+	if (ret)
+		return ret;
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_DGC_ADJ+7, digitgain & 0xFF);
+	if (ret)
+		return ret;
+
+	dev->gain = gain;
+	dev->digital_gain = digitgain;
+	dev->coarse_itg = coarse_itg;
+
+out_disable:
+	/* disable group hold */
+	imx_write_reg_array(client, imx_param_update);
+out:
+	return ret;
+}
+
+static int imx_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __imx_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long imx_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	unsigned int exp = exposure->integration_time[0];
+	unsigned int gain = exposure->gain[0];
+	unsigned int digitgain = exposure->gain[1];
+
+	return imx_set_exposure(sd, exp, gain, digitgain);
+}
+
+static int imx_g_priv_int_data(struct v4l2_subdev *sd,
+				   struct v4l2_private_int_data *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+	u8 __user *to = priv->data;
+	u32 read_size = priv->size;
+	int ret;
+
+	/* No need to copy data if size is 0 */
+	if (!read_size)
+		goto out;
+
+	if (IS_ERR(dev->otp_data)) {
+		dev_err(&client->dev, "OTP data not available");
+		return PTR_ERR(dev->otp_data);
+	}
+	/* Correct read_size value only if bigger than maximum */
+	if (read_size > IMX_OTP_DATA_SIZE)
+		read_size = IMX_OTP_DATA_SIZE;
+
+	ret = copy_to_user(to, dev->otp_data, read_size);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to copy OTP data to user\n",
+			 __func__);
+		return -EFAULT;
+	}
+out:
+	/* Return correct size */
+	priv->size = IMX_OTP_DATA_SIZE;
+
+	return 0;
+}
+
+static int imx_init_registers(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = imx_write_reg_array(client, imx135_SwReset);
+	ret |= imx_write_reg_array(client, imx_init_settings);
+
+	return ret;
+}
+
+static int __imx_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+
+	/* restore settings */
+	imx_res = imx_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	ret = imx_init_registers(sd);
+
+	return ret;
+}
+
+static int imx_init(struct v4l2_subdev *sd, u32 val)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+	ret = __imx_init(sd, val);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long imx_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return imx_s_exposure(sd, arg);
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		return imx_g_priv_int_data(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+       /* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "gpio failed\n");
+		goto fail_gpio;
+	}
+
+	return 0;
+fail_gpio:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int __imx_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret, r;
+
+	if (on == 0) {
+		ret = power_down(sd);
+
+		r = imx_vcm_power_down(sd);
+		if (ret == 0)
+			ret = r;
+		dev->power = 0;
+	} else {
+		ret = imx_vcm_power_up(sd);
+		if (ret)
+			return ret;
+		ret = power_up(sd);
+		if (!ret) {
+			dev->power = 1;
+			return __imx_init(sd, 0);
+		}
+	}
+
+	return ret;
+}
+
+static int imx_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __imx_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int imx_g_chip_ident(struct v4l2_subdev *sd,
+				struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!chip)
+		return -EINVAL;
+
+	v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_IMX, 0);
+
+	return 0;
+}
+
+static int imx_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct imx_reg *reglist)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx_device *dev = to_imx_sensor(sd);
+	u32 vt_pix_clk_div;
+	u32 vt_sys_clk_div;
+	u32 pre_pll_clk_div;
+	u32 pll_multiplier;
+	u32 op_pix_clk_div;
+	u32 op_sys_clk_div;
+
+	const int ext_clk_freq_hz = 19200000;
+	struct atomisp_sensor_mode_data buf;
+	int vt_pix_clk_freq_mhz, ret = 0;
+	u16 data[IMX_INTG_BUF_COUNT];
+
+	u32 coarse_integration_time_min;
+	u32 coarse_integration_time_max_margin;
+	u32 frame_length_lines;
+	u32 line_length_pck;
+	u32 read_mode;
+	u32 div;
+
+	if (info == NULL) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
+	ret = imx_read_reg(client, 1, IMX_VT_PIX_CLK_DIV, data, 0);
+	if (ret)
+		goto out;
+	vt_pix_clk_div = data[0] & IMX_MASK_5BIT;
+	ret = imx_read_reg(client, 1, IMX_VT_SYS_CLK_DIV, data, 0);
+	if (ret)
+		goto out;
+	vt_sys_clk_div = data[0] & IMX_MASK_2BIT;
+	ret = imx_read_reg(client, 1, IMX_PRE_PLL_CLK_DIV, data, 0);
+	if (ret)
+		goto out;
+	pre_pll_clk_div = data[0] & IMX_MASK_4BIT;
+	ret = imx_read_reg(client, 2, IMX_PLL_MULTIPLIER, data, 0);
+	if (ret)
+		goto out;
+	pll_multiplier = data[0] & IMX_MASK_11BIT;
+	ret = imx_read_reg(client, 1, IMX_OP_PIX_DIV, data, 0);
+	if (ret)
+		goto out;
+	op_pix_clk_div = data[0] & IMX_MASK_5BIT;
+	ret = imx_read_reg(client, 1, IMX_OP_SYS_DIV, data, 0);
+	if (ret)
+		goto out;
+	op_sys_clk_div = data[0] & IMX_MASK_2BIT;
+
+	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
+	ret = imx_read_reg(client, 4, IMX_FRAME_LENGTH_LINES, data, 0);
+	if (ret)
+		return ret;
+	frame_length_lines = data[0];
+	line_length_pck = data[1];
+	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
+	ret = imx_read_reg(client, 2, IMX_COARSE_INTG_TIME_MIN, data, 0);
+	if (ret)
+		goto out;
+	coarse_integration_time_min = data[0];
+	ret = imx_read_reg(client, 2, IMX_COARSE_INTG_TIME_MAX, data, 0);
+	if (ret)
+		goto out;
+	coarse_integration_time_max_margin = data[0];
+	ret = imx_read_reg(client, 2, IMX_CROP_X_START, data, 0);
+	if (ret)
+		goto out;
+	buf.crop_horizontal_start = data[0];
+	ret = imx_read_reg(client, 2, IMX_CROP_X_END, data, 0);
+	if (ret)
+		goto out;
+	buf.crop_horizontal_end = data[0];
+	ret = imx_read_reg(client, 2, IMX_CROP_Y_START, data, 0);
+	if (ret)
+		goto out;
+	buf.crop_vertical_start = data[0];
+	ret = imx_read_reg(client, 2, IMX_CROP_Y_END, data, 0);
+	if (ret)
+		goto out;
+	buf.crop_vertical_end = data[0];
+	ret = imx_read_reg(client, 2, IMX_OUTPUT_WIDTH, data, 0);
+	if (ret)
+		goto out;
+	buf.output_width = data[0];
+	ret = imx_read_reg(client, 2, IMX_OUTPUT_HEIGHT, data, 0);
+	if (ret)
+		goto out;
+	buf.output_height = data[0];
+
+	memset(data, 0, IMX_INTG_BUF_COUNT * sizeof(u16));
+	ret = imx_read_reg(client, 1, IMX_READ_MODE, data, 0);
+	if (ret)
+		goto out;
+	read_mode = data[0] & IMX_MASK_2BIT;
+
+	div = pre_pll_clk_div*vt_sys_clk_div*vt_pix_clk_div;
+	if (div == 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+	/*
+	 * imx135 uses vt_pix_clk * 2 for calculations, i.e. integration
+	 * time: coarse_int_time * line_length_pck/(2*vt_pix_clk).
+	 * Provide correct value to user.
+	 */
+	vt_pix_clk_freq_mhz = ext_clk_freq_hz / div * pll_multiplier * 2;
+
+	dev->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf.coarse_integration_time_min = coarse_integration_time_min;
+	buf.coarse_integration_time_max_margin
+		= coarse_integration_time_max_margin;
+	buf.fine_integration_time_min = IMX_FINE_INTG_TIME;
+	buf.fine_integration_time_max_margin = IMX_FINE_INTG_TIME;
+	buf.fine_integration_time_def = IMX_FINE_INTG_TIME;
+	buf.vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf.line_length_pck = line_length_pck;
+	buf.frame_length_lines = frame_length_lines;
+	buf.read_mode = read_mode;
+
+	ret = imx_read_reg(client, 1, IMX_BINNING_ENABLE, data, 0);
+	if (ret)
+		return ret;
+	/* 1:binning enabled, 0:disabled */
+	if (data[0] == 1) {
+		ret = imx_read_reg(client, 1, IMX_BINNING_TYPE, data, 0);
+		if (ret)
+			return ret;
+		buf.binning_factor_x = data[0] >> 4 & 0x0f;
+		buf.binning_factor_y = data[0] & 0xf;
+	} else {
+		buf.binning_factor_x = 1;
+		buf.binning_factor_y = 1;
+	}
+
+	memcpy(&info->data, &buf, sizeof(buf));
+
+out:
+	return ret;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int imx_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse;
+	int ret;
+
+	/* the fine integration time is currently not calculated */
+	ret = imx_read_reg(client, IMX_16BIT,
+			       IMX_COARSE_INTEGRATION_TIME, &coarse, 0);
+	*value = coarse;
+
+	return ret;
+}
+
+static int imx_test_pattern(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return imx_write_reg(client, IMX_16BIT,
+			IMX_TEST_PATTERN_MODE, value);
+}
+
+static int imx_v_flip(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val;
+
+	ret = imx_write_reg_array(client, imx_param_hold);
+	if (ret)
+		return ret;
+	ret = imx_read_reg(client, IMX_8BIT, IMX_IMG_ORIENTATION, &val, 0);
+	if (ret)
+		return ret;
+	if (value)
+		val |= IMX_VFLIP_BIT;
+	else
+		val &= ~IMX_VFLIP_BIT;
+	ret = imx_write_reg(client, IMX_8BIT,
+			IMX_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
+	return imx_write_reg_array(client, imx_param_update);
+}
+
+static int imx_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (IMX_FOCAL_LENGTH_NUM << 16) | IMX_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int imx_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (IMX_F_NUMBER_DEFAULT_NUM << 16) | IMX_F_NUMBER_DEM;
+	return 0;
+}
+
+static int imx_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (IMX_F_NUMBER_DEFAULT_NUM << 24) |
+		(IMX_F_NUMBER_DEM << 16) |
+		(IMX_F_NUMBER_DEFAULT_NUM << 8) | IMX_F_NUMBER_DEM;
+	return 0;
+}
+
+static int imx_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	*val = imx_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int imx_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	*val = imx_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+struct imx_control imx_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = imx_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_TEST_PATTERN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Test pattern",
+			.minimum = 0,
+			.maximum = 0xffff,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = imx_test_pattern,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = imx_v_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move absolute",
+			.minimum = 0,
+			.maximum = IMX_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = imx_t_focus_abs,
+		.query = imx_q_focus_abs,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_RELATIVE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move relative",
+			.minimum = IMX_MAX_FOCUS_NEG,
+			.maximum = IMX_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = imx_t_focus_rel,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 100, /* allow enum to grow in the future */
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = imx_q_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = IMX_FOCAL_LENGTH_DEFAULT,
+			.maximum = IMX_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = IMX_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = imx_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = IMX_F_NUMBER_DEFAULT,
+			.maximum = IMX_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = IMX_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = imx_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = IMX_F_NUMBER_RANGE,
+			.maximum =  IMX_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = IMX_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = imx_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = IMX_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = imx_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = IMX_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = imx_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(imx_controls))
+
+static struct imx_control *imx_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (imx_controls[i].qc.id == id)
+			return &imx_controls[i];
+	return NULL;
+}
+
+static int imx_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct imx_control *ctrl = imx_find_control(qc->id);
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int imx_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct imx_control *s_ctrl;
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = imx_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int imx_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct imx_control *octrl = imx_find_control(ctrl->id);
+	struct imx_device *dev = to_imx_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH  600
+static int distance(struct imx_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct imx_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &imx_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != imx_res[i].width)
+			continue;
+		if (h != imx_res[i].height)
+			continue;
+		/* Found it */
+		return i;
+	}
+	return -1;
+}
+
+static int imx_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int idx = 0;
+
+	if ((fmt->width > IMX_RES_WIDTH_MAX)
+		|| (fmt->height > IMX_RES_HEIGHT_MAX)) {
+		fmt->width = IMX_RES_WIDTH_MAX;
+		fmt->height = IMX_RES_HEIGHT_MAX;
+	} else {
+		idx = nearest_resolution_index(fmt->width, fmt->height);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 *  resolutions. If it fails, it means the requested
+		 *  resolution is higher than wecan support. Fallback
+		 *  to highest possible resolution in this case.
+		 */
+		if (idx == -1)
+			idx = N_RES - 1;
+
+		fmt->width = imx_res[idx].width;
+		fmt->height = imx_res[idx].height;
+	}
+	fmt->code = V4L2_MBUS_FMT_SGBRG10_1X10;
+
+	return 0;
+}
+
+static int imx_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	const struct imx_reg *imx_def_reg;
+	struct camera_mipi_info *imx_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	imx_info = v4l2_get_subdev_hostdata(sd);
+	if (imx_info == NULL)
+		return -EINVAL;
+	ret = imx_try_mbus_fmt(sd, fmt);
+	if (ret) {
+		v4l2_err(sd, "try fmt fail\n");
+		return ret;
+	}
+
+	mutex_lock(&dev->input_lock);
+	dev->fmt_idx = get_resolution_index(fmt->width, fmt->height);
+
+	/* Sanity check */
+	if (unlikely(dev->fmt_idx == -1)) {
+		v4l2_err(sd, "get resolution fail\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	imx_def_reg = imx_res[dev->fmt_idx].regs;
+
+	ret = imx_write_reg_array(client, imx_def_reg);
+	if (ret) {
+		ret = -EINVAL;
+		goto out;
+	}
+	/* FIXME: workround for MERR Pre-alpha due to ISP perf - start */
+
+	ret = imx_write_reg_array(client, imx_param_update);
+	if (ret) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	dev->fps = imx_res[dev->fmt_idx].fps;
+	dev->pixels_per_line = imx_res[dev->fmt_idx].pixels_per_line;
+	dev->lines_per_frame = imx_res[dev->fmt_idx].lines_per_frame;
+
+	ret = __imx_set_exposure(sd, dev->coarse_itg, dev->gain,
+				 dev->digital_gain);
+	if (ret)
+		goto out;
+
+	ret = imx_get_intg_factor(client, imx_info, imx_def_reg);
+	if (ret) {
+		v4l2_err(sd, "failed to get integration_factor\n");
+		goto out;
+	}
+out:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+
+static int imx_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = imx_res[dev->fmt_idx].width;
+	fmt->height = imx_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SGBRG10_1X10;
+
+	return 0;
+}
+
+static int imx_detect(struct i2c_client *client, u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 high, low;
+
+	/* i2c check */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	/* check sensor chip ID	 */
+	if (imx_read_reg(client, IMX_8BIT, IMX_SC_CMMN_CHIP_ID_H, &high, 0)) {
+		v4l2_err(client, "sensor_id_high = 0x%x\n", high);
+		return -ENODEV;
+	}
+
+	if (imx_read_reg(client, IMX_8BIT, IMX_SC_CMMN_CHIP_ID_L, &low, 0)) {
+		v4l2_err(client, "sensor_id_low = 0x%x\n", low);
+		return -ENODEV;
+	}
+
+	*id = (((u8) high) << 8) | (u8) low;
+	v4l2_info(client, "sensor_id = 0x%x\n", *id);
+
+	if (*id != IMX_ID) {
+		v4l2_err(client, "sensor ID error\n");
+		return -ENODEV;
+	}
+
+	v4l2_info(client, "detect imx success\n");
+
+	/* TODO - need to be updated */
+	*revision = 0;
+
+	return 0;
+}
+
+/*
+ * imx stream on/off
+ */
+static int imx_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (enable) {
+		ret = imx_write_reg_array(client, imx_streaming);
+		if (ret != 0) {
+			v4l2_err(client, "write_reg_array err\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		dev->streaming = 1;
+	} else {
+		ret = imx_write_reg_array(client, imx_soft_standby);
+		if (ret != 0) {
+			v4l2_err(client, "write_reg_array err\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		dev->streaming = 0;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/*
+ * imx enum frame size, frame intervals
+ */
+static int imx_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = imx_res[index].width;
+	fsize->discrete.height = imx_res[index].height;
+	fsize->reserved[0] = imx_res[index].used;
+
+	return 0;
+}
+
+static int imx_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	int i;
+
+	/* since the isp will donwscale the resolution to the right size,
+	  * find the nearest one that will allow the isp to do so
+	  * important to ensure that the resolution requested is padded
+	  * correctly by the requester, which is the atomisp driver in
+	  * this case.
+	  */
+	i = nearest_resolution_index(fival->width, fival->height);
+
+	if (i == -1)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = imx_res[i].width;
+	fival->height = imx_res[i].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = imx_res[i].fps;
+
+	return 0;
+}
+
+static int imx_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= MAX_FMTS)
+		return -EINVAL;
+
+	*code = V4L2_MBUS_FMT_SGBRG10_1X10;
+	return 0;
+}
+
+static int imx_s_config(struct v4l2_subdev *sd,
+			    int irq, void *pdata)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			v4l2_err(client, "imx platform init err\n");
+			return ret;
+		}
+	}
+	ret = __imx_s_power(sd, 1);
+	if (ret) {
+		v4l2_err(client, "imx power-up err.\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = imx_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		v4l2_err(client, "imx_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+	/* Read sensor's OTP data */
+	dev->otp_data = imx_otp_read(sd);
+	/* power off sensor */
+	ret = __imx_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	if (ret)
+		v4l2_err(client, "imx power-down err.\n");
+
+	return ret;
+
+fail_detect:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_csi_cfg:
+	__imx_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int
+imx_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SGBRG10_1X10;
+
+	return 0;
+}
+
+static int
+imx_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = imx_res[index].width;
+	fse->min_height = imx_res[index].height;
+	fse->max_width = imx_res[index].width;
+	fse->max_height = imx_res[index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__imx_get_pad_format(struct imx_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+imx_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__imx_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+imx_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+
+	return 0;
+}
+
+static int
+imx_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		imx_res = imx_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		imx_res = imx_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		imx_res = imx_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+int
+imx_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct imx_device *dev = to_imx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 lines_per_frame;
+	/*
+	 * if no specific information to calculate the fps,
+	 * just used the value in sensor settings
+	 */
+
+	if (!dev->pixels_per_line || !dev->lines_per_frame) {
+		interval->interval.numerator = 1;
+		interval->interval.denominator = dev->fps;
+		return 0;
+	}
+
+	/*
+	 * DS: if coarse_integration_time is set larger than
+	 * lines_per_frame the frame_size will be expanded to
+	 * coarse_integration_time+1
+	 */
+	if (dev->coarse_itg > dev->lines_per_frame) {
+		if (dev->coarse_itg == 0xFFFF) {
+			/*
+			 * we can not add 4 according to ds, as this will
+			 * cause over flow
+			 */
+			v4l2_warn(client, "%s: abnormal coarse_itg:0x%x\n",
+				  __func__, dev->coarse_itg);
+			lines_per_frame = dev->coarse_itg;
+		} else {
+			lines_per_frame = dev->coarse_itg + 4;
+		}
+	} else {
+		lines_per_frame = dev->lines_per_frame;
+	}
+	interval->interval.numerator = dev->pixels_per_line *
+					lines_per_frame;
+	interval->interval.denominator = dev->vt_pix_clk_freq_mhz;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops imx_video_ops = {
+	.s_stream = imx_s_stream,
+	.enum_framesizes = imx_enum_framesizes,
+	.enum_frameintervals = imx_enum_frameintervals,
+	.enum_mbus_fmt = imx_enum_mbus_fmt,
+	.try_mbus_fmt = imx_try_mbus_fmt,
+	.g_mbus_fmt = imx_g_mbus_fmt,
+	.s_mbus_fmt = imx_s_mbus_fmt,
+	.s_parm = imx_s_parm,
+	.g_frame_interval = imx_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops imx_core_ops = {
+	.g_chip_ident = imx_g_chip_ident,
+	.queryctrl = imx_queryctrl,
+	.g_ctrl = imx_g_ctrl,
+	.s_ctrl = imx_s_ctrl,
+	.s_power = imx_s_power,
+	.ioctl = imx_ioctl,
+	.init = imx_init,
+};
+
+static const struct v4l2_subdev_pad_ops imx_pad_ops = {
+	.enum_mbus_code = imx_enum_mbus_code,
+	.enum_frame_size = imx_enum_frame_size,
+	.get_fmt = imx_get_pad_format,
+	.set_fmt = imx_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops imx_ops = {
+	.core = &imx_core_ops,
+	.video = &imx_video_ops,
+	.pad = &imx_pad_ops,
+};
+
+static const struct media_entity_operations imx_entity_ops = {
+	.link_setup = NULL,
+};
+
+static int imx_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx_device *dev = to_imx_sensor(sd);
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	media_entity_cleanup(&dev->sd.entity);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static int imx_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct imx_device *dev;
+	int ret;
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		v4l2_err(client, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &imx_ops);
+
+	ret = imx_vcm_init(&dev->sd);
+	if (ret < 0)
+		goto out_free;
+
+	if (client->dev.platform_data) {
+		ret = imx_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SGBRG10_1X10;
+	dev->sd.entity.ops = &imx_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		imx_remove(client);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+static const struct i2c_device_id imx_id[] = {
+	{IMX_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, imx_id);
+
+static struct i2c_driver imx_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = IMX_NAME,
+	},
+	.probe = imx_probe,
+	.remove = imx_remove,
+	.id_table = imx_id,
+};
+
+
+static __init int init_imx(void)
+{
+	return i2c_add_driver(&imx_driver);
+}
+
+static __exit void exit_imx(void)
+{
+	i2c_del_driver(&imx_driver);
+}
+
+module_init(init_imx);
+module_exit(exit_imx);
+
+MODULE_DESCRIPTION("A low-level driver for Sony IMX sensors");
+MODULE_AUTHOR("Shenbo Huang <shenbo.huang@intel.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.h b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.h
new file mode 100644
index 0000000..afec9ad
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx.h
@@ -0,0 +1,289 @@
+/*
+ * Support for Sony IMX camera sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IMX_H__
+#define __IMX_H__
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include "imx135.h"
+
+#define I2C_MSG_LENGTH		0x2
+
+#define IMX_MCLK		192
+
+/* TODO - This should be added into include/linux/videodev2.h */
+#ifndef V4L2_IDENT_IMX
+#define V4L2_IDENT_IMX	8245
+#endif
+
+/*
+ * imx System control registers
+ */
+#define IMX_MASK_5BIT	0x1F
+#define IMX_MASK_4BIT	0xF
+#define IMX_MASK_2BIT	0x3
+#define IMX_MASK_11BIT	0x7FF
+#define IMX_INTG_BUF_COUNT		2
+
+#define IMX_INTEGRATION_TIME_MARGIN	4
+
+#define IMX_FINE_INTG_TIME		0x1E8
+
+#define IMX_VT_PIX_CLK_DIV			0x0301
+#define IMX_VT_SYS_CLK_DIV			0x0303
+#define IMX_PRE_PLL_CLK_DIV			0x0305
+#define IMX_PLL_MULTIPLIER			0x030C
+#define IMX_OP_PIX_DIV			0x0309
+#define IMX_OP_SYS_DIV			0x030B
+#define IMX_FRAME_LENGTH_LINES		0x0340
+#define IMX_LINE_LENGTH_PIXELS		0x0342
+#define IMX_COARSE_INTG_TIME_MIN	0x1004
+#define IMX_COARSE_INTG_TIME_MAX	0x1006
+#define IMX_BINNING_ENABLE		0x0390
+#define IMX_BINNING_TYPE		0x0391
+
+#define IMX_CROP_X_START		0x0344
+#define IMX_CROP_Y_START		0x0346
+#define IMX_CROP_X_END			0x0348
+#define IMX_CROP_Y_END			0x034A
+#define IMX_OUTPUT_WIDTH		0x034C
+#define IMX_OUTPUT_HEIGHT		0x034E
+
+#define IMX_READ_MODE			0x0390
+
+#define IMX_COARSE_INTEGRATION_TIME		0x0202
+#define IMX_TEST_PATTERN_MODE			0x0600
+#define IMX_IMG_ORIENTATION			0x0101
+#define IMX_VFLIP_BIT			1
+#define IMX_GLOBAL_GAIN			0x0205
+#define IMX_DGC_ADJ			0x020E
+
+/* Defines for register writes and register array processing */
+#define IMX_BYTE_MAX	32 /* change to 32 as needed by otpdata */
+#define IMX_SHORT_MAX	16
+#define I2C_RETRY_COUNT		5
+#define IMX_TOK_MASK	0xfff0
+
+#define MAX_FMTS 1
+
+/* Defines for OTP Data Registers */
+#define IMX_OTP_START_ADDR		0x3B04
+#define IMX_OTP_DATA_SIZE		1280
+#define IMX_OTP_PAGE_SIZE		64
+#define IMX_OTP_READY_REG		0x3B01
+#define IMX_OTP_PAGE_REG		0x3B02
+#define IMX_OTP_MODE_REG		0x3B00
+#define IMX_OTP_PAGE_MAX		20
+#define IMX_OTP_READY_REG_DONE		1
+#define IMX_OTP_READ_ONETIME		32
+#define IMX_OTP_MODE_READ		1
+
+#define	v4l2_format_capture_type_entry(_width, _height, \
+		_pixelformat, _bytesperline, _colorspace) \
+	{\
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\
+		.fmt.pix.width = (_width),\
+		.fmt.pix.height = (_height),\
+		.fmt.pix.pixelformat = (_pixelformat),\
+		.fmt.pix.bytesperline = (_bytesperline),\
+		.fmt.pix.colorspace = (_colorspace),\
+		.fmt.pix.sizeimage = (_height)*(_bytesperline),\
+	}
+
+#define	s_output_format_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps) \
+	{\
+		.v4l2_fmt = v4l2_format_capture_type_entry(_width, \
+			_height, _pixelformat, _bytesperline, \
+				_colorspace),\
+		.fps = (_fps),\
+	}
+
+#define	s_output_format_reg_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps, _reg_setting) \
+	{\
+		.s_fmt = s_output_format_entry(_width, _height,\
+				_pixelformat, _bytesperline, \
+				_colorspace, _fps),\
+		.reg_setting = (_reg_setting),\
+	}
+
+struct s_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
+};
+
+#define	v4l2_queryctrl_entry_integer(_id, _name,\
+		_minimum, _maximum, _step, \
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_INTEGER, \
+		.name = _name, \
+		.minimum = (_minimum), \
+		.maximum = (_maximum), \
+		.step = (_step), \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+#define	v4l2_queryctrl_entry_boolean(_id, _name,\
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_BOOLEAN, \
+		.name = _name, \
+		.minimum = 0, \
+		.maximum = 1, \
+		.step = 1, \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+
+#define	s_ctrl_id_entry_integer(_id, _name, \
+		_minimum, _maximum, _step, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
+				_minimum, _maximum, _step,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+#define	s_ctrl_id_entry_boolean(_id, _name, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+
+struct imx_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/* imx device structure */
+struct imx_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct camera_sensor_platform_data *platform_data;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	int fmt_idx;
+	int status;
+	int streaming;
+	int power;
+	int run_mode;
+	int vt_pix_clk_freq_mhz;
+	u32 focus;
+	u16 sensor_id;
+	u16 coarse_itg;
+	u16 fine_itg;
+	u16 gain;
+	u16 digital_gain;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 fps;
+	u8 res;
+	u8 type;
+	u8 sensor_revision;
+	u8 *otp_data;
+};
+
+#define to_imx_sensor(x) container_of(x, struct imx_device, sd)
+
+#define IMX_MAX_WRITE_BUF_SIZE	32
+struct imx_write_buffer {
+	u16 addr;
+	u8 data[IMX_MAX_WRITE_BUF_SIZE];
+};
+
+struct imx_write_ctrl {
+	int index;
+	struct imx_write_buffer buffer;
+};
+
+struct sensor_mode_data {
+	u32 coarse_integration_time_min;
+	u32 coarse_integration_time_max_margin;
+	u32 fine_integration_time_min;
+	u32 fine_integration_time_max_margin;
+	u32 fine_integration_time_def;
+	u32 frame_length_lines;
+	u32 line_length_pck;
+	u32 read_mode;
+	int vt_pix_clk_freq_mhz;
+};
+
+static const struct imx_reg imx_soft_standby[] = {
+	{IMX_8BIT, 0x0100, 0x00},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx_streaming[] = {
+	{IMX_8BIT, 0x0100, 0x01},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx_param_hold[] = {
+	{IMX_8BIT, 0x0104, 0x01},	/* GROUPED_PARAMETER_HOLD */
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx_param_update[] = {
+	{IMX_8BIT, 0x0104, 0x00},	/* GROUPED_PARAMETER_HOLD */
+	{IMX_TOK_TERM, 0, 0}
+};
+
+#define IMX_INVALID_CONFIG	0xffffffff
+#define IMX_MAX_FOCUS_POS	1023
+#define IMX_MAX_FOCUS_NEG	(-1023)
+#define IMX_VCM_SLEW_STEP_MAX	0x3f
+#define IMX_VCM_SLEW_TIME_MAX	0x1f
+
+extern int imx_vcm_power_up(struct v4l2_subdev *sd);
+extern int imx_vcm_power_down(struct v4l2_subdev *sd);
+extern int imx_vcm_init(struct v4l2_subdev *sd);
+extern int imx_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+extern int imx_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+extern int imx_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+extern int imx_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+
+#endif
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx135.h b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx135.h
new file mode 100644
index 0000000..2c9d582
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/imx135VB/imx135.h
@@ -0,0 +1,4784 @@
+#ifndef __IMX135_H__
+#define __IMX135_H__
+
+#define IMX_NAME	"imx135"
+#define IMX_ID	0x0135
+
+#define IMX_SC_CMMN_CHIP_ID_H	0x0016
+#define IMX_SC_CMMN_CHIP_ID_L	0x0017
+#define IMX_FOCAL_LENGTH_NUM	369	/*3.69mm*/
+#define IMX_FOCAL_LENGTH_DEM	100
+#define IMX_F_NUMBER_DEFAULT_NUM	22
+#define IMX_F_NUMBER_DEM	10
+
+#define IMX_RES_WIDTH_MAX	4208
+#define IMX_RES_HEIGHT_MAX	3120
+#define IMX_BIN_FACTOR_MAX			4
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_FOCAL_LENGTH_DEFAULT 0x1710064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define IMX_F_NUMBER_DEFAULT 0x16000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define IMX_F_NUMBER_RANGE 0x160a160a
+
+enum imx_tok_type {
+	IMX_8BIT  = 0x0001,
+	IMX_16BIT = 0x0002,
+	IMX_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	IMX_TOK_DELAY  = 0xfe00	/* delay token for reg list */
+};
+
+/**
+ * struct imx_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct imx_reg {
+	enum imx_tok_type type;
+	u16 sreg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+struct imx_resolution {
+	u8 *desc;
+	const struct imx_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	bool used;
+};
+#define GROUPED_PARAMETER_HOLD_ENABLE  {IMX_8BIT, 0x0104, 0x1}
+#define GROUPED_PARAMETER_HOLD_DISABLE  {IMX_8BIT, 0x0104, 0x0}
+
+/********************** settings for imx from vendor*********************/
+
+static struct imx_reg const imx135_SwReset[] = {
+	{ IMX_8BIT,  0x0100 , 0x00 },
+	{ IMX_8BIT,  0x0103 , 0x01 },
+	{ IMX_TOK_DELAY, 0, 5},
+	{ IMX_8BIT,  0x0103 , 0x00 },
+	{ IMX_TOK_TERM, 0, 0},
+};
+static struct imx_reg const imx135_13M_25fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0C},
+	{IMX_8BIT, 0x0341, 0x46},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x10},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x0C},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x30},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x0C},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x87},
+	{IMX_8BIT, 0x0831, 0x3F},
+	{IMX_8BIT, 0x0832, 0x67},
+	{IMX_8BIT, 0x0833, 0x3F},
+	{IMX_8BIT, 0x0834, 0x3F},
+	{IMX_8BIT, 0x0835, 0x4F},
+	{IMX_8BIT, 0x0836, 0xDF},
+	{IMX_8BIT, 0x0837, 0x47},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0C},
+	{IMX_8BIT, 0x0203, 0x42},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_13M_3fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock Setting */
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0C},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x01},
+	{IMX_8BIT, 0x030C, 0x02},
+	{IMX_8BIT, 0x030D, 0x08},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x11},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x20},
+	{IMX_8BIT, 0x0341, 0x00},
+	{IMX_8BIT, 0x0342, 0x30},
+	{IMX_8BIT, 0x0343, 0x00},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x10},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x0C},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x30},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x0C},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x7F},
+	{IMX_8BIT, 0x0831, 0x37},
+	{IMX_8BIT, 0x0832, 0x67},
+	{IMX_8BIT, 0x0833, 0x3F},
+	{IMX_8BIT, 0x0834, 0x3F},
+	{IMX_8BIT, 0x0835, 0x47},
+	{IMX_8BIT, 0x0836, 0xDF},
+	{IMX_8BIT, 0x0837, 0x47},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0D},
+	{IMX_8BIT, 0x0203, 0xFC},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_13M_24fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock Setting */
+	{IMX_8BIT, 0x011E, 0x13}, /* exck_freq [15:8]integer item */
+	{IMX_8BIT, 0x011F, 0x33}, /* exck_freq [7:0] decimal fraction item */
+	{IMX_8BIT, 0x0301, 0x05}, /* vt_pix_clk_div */
+	{IMX_8BIT, 0x0303, 0x01}, /* vt_sys_clk_div */
+	{IMX_8BIT, 0x0305, 0x0C}, /* op_pre_pll_clk_div */
+	{IMX_8BIT, 0x0309, 0x05}, /* op_pix_clk_div */
+	{IMX_8BIT, 0x030B, 0x01}, /* op_sys_clk_div */
+	{IMX_8BIT, 0x030C, 0x02}, /* op_pll_multiplier [10:8] */
+	{IMX_8BIT, 0x030D, 0x38}, /* op_pll_multiplier [7:0] */
+	{IMX_8BIT, 0x030E, 0x01}, /* pll_singledrive-enable 0:double,1:single */
+	/*
+	 * ckdiv_mode/src2div
+	 * [4] mdbck clock setting,0:auto,1:manual
+	 * [1:0] when ckdiv_mode is1, set same with opsys_div, only 1 or 2
+	 */
+	{IMX_8BIT, 0x3A06, 0x11},
+
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0C},
+	{IMX_8BIT, 0x0341, 0xF0},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x00},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x6F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x10},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x0C},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x70},
+	{IMX_8BIT, 0x0356, 0x0C},
+	{IMX_8BIT, 0x0357, 0x30},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x10},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x0C},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0x10},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x87},
+	{IMX_8BIT, 0x0831, 0x3F},
+	{IMX_8BIT, 0x0832, 0x67},
+	{IMX_8BIT, 0x0833, 0x3F},
+	{IMX_8BIT, 0x0834, 0x3F},
+	{IMX_8BIT, 0x0835, 0x4F},
+	{IMX_8BIT, 0x0836, 0xDF},
+	{IMX_8BIT, 0x0837, 0x47},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0C},
+	{IMX_8BIT, 0x0203, 0x42},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_8M_3fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock Setting */
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0C},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x01},
+	{ IMX_8BIT, 0x030C, 0x02},
+	{ IMX_8BIT, 0x030D, 0x32},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x11},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x00 },
+	{IMX_8BIT, 0x0391, 0x11 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x00 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x10 },
+	{IMX_8BIT, 0x4082, 0x01 },
+	{IMX_8BIT, 0x4083, 0x01 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A },
+	{IMX_8BIT, 0x0341, 0x3C },
+	{IMX_8BIT, 0x0342, 0x27 }, /* quick fix, causing low fps*/
+	{IMX_8BIT, 0x0343, 0x10 }, /* to be furnished later */
+	{IMX_8BIT, 0x0344, 0x01 },
+	{IMX_8BIT, 0x0345, 0xd0 },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x48 },
+	{IMX_8BIT, 0x0348, 0x0e },
+	{IMX_8BIT, 0x0349, 0x9f },
+	{IMX_8BIT, 0x034A, 0x0a },
+	{IMX_8BIT, 0x034B, 0xe7 },
+	{IMX_8BIT, 0x034C, 0x0c },
+	{IMX_8BIT, 0x034D, 0xd0 },
+	{IMX_8BIT, 0x034E, 0x09 },
+	{IMX_8BIT, 0x034F, 0xA0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x0c },
+	{IMX_8BIT, 0x0355, 0xd0 },
+	{IMX_8BIT, 0x0356, 0x09 },
+	{IMX_8BIT, 0x0357, 0xa0 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x0C },
+	{IMX_8BIT, 0x3311, 0xD0 },
+	{IMX_8BIT, 0x3312, 0x09 },
+	{IMX_8BIT, 0x3313, 0xA0 },
+	{IMX_8BIT, 0x331C, 0x00 },
+	{IMX_8BIT, 0x331D, 0x10 },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0x00 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x87 },
+	{IMX_8BIT, 0x0831, 0x3F },
+	{IMX_8BIT, 0x0832, 0x67 },
+	{IMX_8BIT, 0x0833, 0x3F },
+	{IMX_8BIT, 0x0834, 0x3F },
+	{IMX_8BIT, 0x0835, 0x4f },
+	{IMX_8BIT, 0x0836, 0xdf },
+	{IMX_8BIT, 0x0837, 0x47 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0a },
+	{IMX_8BIT, 0x0203, 0x38 },
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{IMX_8BIT, 0x0230, 0x00},
+	{IMX_8BIT, 0x0231, 0x00},
+	{IMX_8BIT, 0x0233, 0x00},
+	{IMX_8BIT, 0x0234, 0x00},
+	{IMX_8BIT, 0x0235, 0x40},
+	{IMX_8BIT, 0x0238, 0x00},
+	{IMX_8BIT, 0x0239, 0x04},
+	{IMX_8BIT, 0x023B, 0x00},
+	{IMX_8BIT, 0x023C, 0x01},
+	{IMX_8BIT, 0x33B0, 0x04},
+	{IMX_8BIT, 0x33B1, 0x00},
+	{IMX_8BIT, 0x33B3, 0x00},
+	{IMX_8BIT, 0x33B4, 0x01},
+	{IMX_8BIT, 0x3800, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_5M_26fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x19},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0B},
+	{IMX_8BIT, 0x0341, 0xEA},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x5C},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x30},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x15},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x03},
+	{IMX_8BIT, 0x034C, 0x0A},
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x07},
+	{IMX_8BIT, 0x034F, 0x90},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x01},
+	{IMX_8BIT, 0x0354, 0x0F},
+	{IMX_8BIT, 0x0355, 0xBA},
+	{IMX_8BIT, 0x0356, 0x0B},
+	{IMX_8BIT, 0x0357, 0xD2},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x0A},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x07},
+	{IMX_8BIT, 0x3313, 0x90},
+	{IMX_8BIT, 0x331C, 0x03},
+	{IMX_8BIT, 0x331D, 0xAE},
+	{IMX_8BIT, 0x4084, 0x0A},
+	{IMX_8BIT, 0x4085, 0x10},
+	{IMX_8BIT, 0x4086, 0x07},
+	{IMX_8BIT, 0x4087, 0x90},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x87},
+	{IMX_8BIT, 0x0831, 0x3F},
+	{IMX_8BIT, 0x0832, 0x67},
+	{IMX_8BIT, 0x0833, 0x3F},
+	{IMX_8BIT, 0x0834, 0x3F},
+	{IMX_8BIT, 0x0835, 0x4F},
+	{IMX_8BIT, 0x0836, 0xDF},
+	{IMX_8BIT, 0x0837, 0x47},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0B},
+	{IMX_8BIT, 0x0203, 0xE6},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_1080p_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x1C},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x3C},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x94},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x33},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0x9B},
+	{IMX_8BIT, 0x034C, 0x09},
+	{IMX_8BIT, 0x034D, 0x20},
+	{IMX_8BIT, 0x034E, 0x05},
+	{IMX_8BIT, 0x034F, 0x28},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x01},
+	{IMX_8BIT, 0x0354, 0x0F},
+	{IMX_8BIT, 0x0355, 0xF8},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x06},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x09},
+	{IMX_8BIT, 0x3311, 0x20},
+	{IMX_8BIT, 0x3312, 0x05},
+	{IMX_8BIT, 0x3313, 0x28},
+	{IMX_8BIT, 0x331C, 0x04},
+	{IMX_8BIT, 0x331D, 0xE2},
+	{IMX_8BIT, 0x4084, 0x09},
+	{IMX_8BIT, 0x4085, 0x20},
+	{IMX_8BIT, 0x4086, 0x05},
+	{IMX_8BIT, 0x4087, 0x28},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x87},
+	{IMX_8BIT, 0x0831, 0x3F},
+	{IMX_8BIT, 0x0832, 0x67},
+	{IMX_8BIT, 0x0833, 0x3F},
+	{IMX_8BIT, 0x0834, 0x3F},
+	{IMX_8BIT, 0x0835, 0x4F},
+	{IMX_8BIT, 0x0836, 0xDF},
+	{IMX_8BIT, 0x0837, 0x47},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_wide_preview_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x1A},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x18},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x88},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x57},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0xAB},
+	{IMX_8BIT, 0x034C, 0x05},
+	{IMX_8BIT, 0x034D, 0x00},
+	{IMX_8BIT, 0x034E, 0x02},
+	{IMX_8BIT, 0x034F, 0xD0},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x20},
+	{IMX_8BIT, 0x0356, 0x04},
+	{IMX_8BIT, 0x0357, 0x92},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x05},
+	{IMX_8BIT, 0x3311, 0x00},
+	{IMX_8BIT, 0x3312, 0x02},
+	{IMX_8BIT, 0x3313, 0xD0},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x18},
+	{IMX_8BIT, 0x4084, 0x05},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x02},
+	{IMX_8BIT, 0x4087, 0xD0},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_D1_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x11},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x70},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x18},
+	{IMX_8BIT, 0x0348, 0x0F},
+	{IMX_8BIT, 0x0349, 0xFF},
+	{IMX_8BIT, 0x034A, 0x0B},
+	{IMX_8BIT, 0x034B, 0x17},
+	{IMX_8BIT, 0x034C, 0x03},
+	{IMX_8BIT, 0x034D, 0xA8},
+	{IMX_8BIT, 0x034E, 0x02},
+	{IMX_8BIT, 0x034F, 0x5A},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xE4},
+	{IMX_8BIT, 0x0356, 0x02},
+	{IMX_8BIT, 0x0357, 0x80},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x03},
+	{IMX_8BIT, 0x3311, 0xA8},
+	{IMX_8BIT, 0x3312, 0x02},
+	{IMX_8BIT, 0x3313, 0x5A},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x3A},
+	{IMX_8BIT, 0x4084, 0x03},
+	{IMX_8BIT, 0x4085, 0xA8},
+	{IMX_8BIT, 0x4086, 0x02},
+	{IMX_8BIT, 0x4087, 0x5A},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_preview_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x13},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x58},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x60},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x17},
+	{IMX_8BIT, 0x034A, 0x0B},
+	{IMX_8BIT, 0x034B, 0xCF},
+	{IMX_8BIT, 0x034C, 0x03},
+	{IMX_8BIT, 0x034D, 0x50},
+	{IMX_8BIT, 0x034E, 0x02},
+	{IMX_8BIT, 0x034F, 0x68},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xF0},
+	{IMX_8BIT, 0x0356, 0x02},
+	{IMX_8BIT, 0x0357, 0xDC},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x03},
+	{IMX_8BIT, 0x3311, 0x50},
+	{IMX_8BIT, 0x3312, 0x02},
+	{IMX_8BIT, 0x3313, 0x68},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x1C},
+	{IMX_8BIT, 0x4084, 0x03},
+	{IMX_8BIT, 0x4085, 0x50},
+	{IMX_8BIT, 0x4086, 0x02},
+	{IMX_8BIT, 0x4087, 0x68},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_VGA_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock setting */
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0C},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x01},
+	{IMX_8BIT, 0x030C, 0x02},
+	{IMX_8BIT, 0x030D, 0x32},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x11},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x34},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x3B},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x03},
+	{IMX_8BIT, 0x034D, 0x34},
+	{IMX_8BIT, 0x034E, 0x02},
+	{IMX_8BIT, 0x034F, 0x68},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x04},
+	{IMX_8BIT, 0x0355, 0x02},
+	{IMX_8BIT, 0x0356, 0x03},
+	{IMX_8BIT, 0x0357, 0x02},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x03},
+	{IMX_8BIT, 0x3311, 0x34},
+	{IMX_8BIT, 0x3312, 0x02},
+	{IMX_8BIT, 0x3313, 0x68},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x21},
+	{IMX_8BIT, 0x4084, 0x03},
+	{IMX_8BIT, 0x4085, 0x34},
+	{IMX_8BIT, 0x4086, 0x02},
+	{IMX_8BIT, 0x4087, 0x68},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{IMX_8BIT, 0x0230, 0x00},
+	{IMX_8BIT, 0x0231, 0x00},
+	{IMX_8BIT, 0x0233, 0x00},
+	{IMX_8BIT, 0x0234, 0x00},
+	{IMX_8BIT, 0x0235, 0x40},
+	{IMX_8BIT, 0x0238, 0x00},
+	{IMX_8BIT, 0x0239, 0x04},
+	{IMX_8BIT, 0x023B, 0x00},
+	{IMX_8BIT, 0x023C, 0x01},
+	{IMX_8BIT, 0x33B0, 0x04},
+	{IMX_8BIT, 0x33B1, 0x00},
+	{IMX_8BIT, 0x33B3, 0x00},
+	{IMX_8BIT, 0x33B4, 0x01},
+	{IMX_8BIT, 0x3800, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_CIF_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x23},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0xA0},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x24},
+	{IMX_8BIT, 0x0348, 0x0F},
+	{IMX_8BIT, 0x0349, 0xCF},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x0B},
+	{IMX_8BIT, 0x034C, 0x01},
+	{IMX_8BIT, 0x034D, 0xBC},
+	{IMX_8BIT, 0x034E, 0x01},
+	{IMX_8BIT, 0x034F, 0x5C},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xCC},
+	{IMX_8BIT, 0x0356, 0x02},
+	{IMX_8BIT, 0x0357, 0xFA},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x01},
+	{IMX_8BIT, 0x3311, 0xBC},
+	{IMX_8BIT, 0x3312, 0x01},
+	{IMX_8BIT, 0x3313, 0x5C},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x7C},
+	{IMX_8BIT, 0x4084, 0x01},
+	{IMX_8BIT, 0x4085, 0xBC},
+	{IMX_8BIT, 0x4086, 0x01},
+	{IMX_8BIT, 0x4087, 0x5C},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_QVGA_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x28},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x40},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x2F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x01},
+	{IMX_8BIT, 0x034D, 0x98},
+	{IMX_8BIT, 0x034E, 0x01},
+	{IMX_8BIT, 0x034F, 0x34},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xFC},
+	{IMX_8BIT, 0x0356, 0x03},
+	{IMX_8BIT, 0x0357, 0x02},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x01},
+	{IMX_8BIT, 0x3311, 0x98},
+	{IMX_8BIT, 0x3312, 0x01},
+	{IMX_8BIT, 0x3313, 0x34},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x68},
+	{IMX_8BIT, 0x4084, 0x01},
+	{IMX_8BIT, 0x4085, 0x98},
+	{IMX_8BIT, 0x4086, 0x01},
+	{IMX_8BIT, 0x4087, 0x34},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_QCIF_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x46},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0xD4},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x0F},
+	{IMX_8BIT, 0x0349, 0x9B},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x00},
+	{IMX_8BIT, 0x034D, 0xD8},
+	{IMX_8BIT, 0x034E, 0x00},
+	{IMX_8BIT, 0x034F, 0xB0},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xB2},
+	{IMX_8BIT, 0x0356, 0x03},
+	{IMX_8BIT, 0x0357, 0x02},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x00},
+	{IMX_8BIT, 0x3311, 0xD8},
+	{IMX_8BIT, 0x3312, 0x00},
+	{IMX_8BIT, 0x3313, 0xB0},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0xD4},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0xD8},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0xB0},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_6M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x00},
+	{IMX_8BIT, 0x0391, 0x11},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x94},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0x9F},
+	{IMX_8BIT, 0x034C, 0x0C},
+	{IMX_8BIT, 0x034D, 0xD0},
+	{IMX_8BIT, 0x034E, 0x07},
+	{IMX_8BIT, 0x034F, 0x3C},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x10},
+	{IMX_8BIT, 0x0355, 0x04},
+	{IMX_8BIT, 0x0356, 0x09},
+	{IMX_8BIT, 0x0357, 0x0C},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x0C},
+	{IMX_8BIT, 0x3311, 0xD0},
+	{IMX_8BIT, 0x3312, 0x07},
+	{IMX_8BIT, 0x3313, 0x3C},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0xA0},
+	{IMX_8BIT, 0x4084, 0x0C},
+	{IMX_8BIT, 0x4085, 0xD0},
+	{IMX_8BIT, 0x4086, 0x07},
+	{IMX_8BIT, 0x4087, 0x3C},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x87},
+	{IMX_8BIT, 0x0831, 0x3F},
+	{IMX_8BIT, 0x0832, 0x67},
+	{IMX_8BIT, 0x0833, 0x3F},
+	{IMX_8BIT, 0x0834, 0x3F},
+	{IMX_8BIT, 0x0835, 0x4F},
+	{IMX_8BIT, 0x0836, 0xDF},
+	{IMX_8BIT, 0x0837, 0x47},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_3M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock setting */
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0B},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x02},
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x00},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x10},
+	{IMX_8BIT, 0x4082, 0x01},
+	{IMX_8BIT, 0x4083, 0x01},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x28},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x08},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x47},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x27},
+	{IMX_8BIT, 0x034C, 0x08},
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x06},
+	{IMX_8BIT, 0x034F, 0x10},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x10},
+	{IMX_8BIT, 0x0356, 0x06},
+	{IMX_8BIT, 0x0357, 0x10},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x08},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x06},
+	{IMX_8BIT, 0x3313, 0x10},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0xAA},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5F},
+	{IMX_8BIT, 0x0831, 0x0C},
+	{IMX_8BIT, 0x0832, 0x3F},
+	{IMX_8BIT, 0x0833, 0x1F},
+	{IMX_8BIT, 0x0834, 0x1F},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x06},
+	{IMX_8BIT, 0x0203, 0x22},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{IMX_8BIT, 0x0230, 0x00},
+	{IMX_8BIT, 0x0231, 0x00},
+	{IMX_8BIT, 0x0233, 0x00},
+	{IMX_8BIT, 0x0234, 0x00},
+	{IMX_8BIT, 0x0235, 0x40},
+	{IMX_8BIT, 0x0238, 0x00},
+	{IMX_8BIT, 0x0239, 0x04},
+	{IMX_8BIT, 0x023B, 0x00},
+	{IMX_8BIT, 0x023C, 0x01},
+	{IMX_8BIT, 0x33B0, 0x04},
+	{IMX_8BIT, 0x33B1, 0x00},
+	{IMX_8BIT, 0x33B3, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_1080p_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock setting */
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0B},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x02},
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x83},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x11},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x04},
+	{IMX_8BIT, 0x0341, 0xAC},
+	{IMX_8BIT, 0x0342, 0x12},
+	{IMX_8BIT, 0x0343, 0x58},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x2E},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x84},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x41},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0xAF},
+	{IMX_8BIT, 0x034C, 0x07},
+	{IMX_8BIT, 0x034D, 0x90},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0x50},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x0A},
+	{IMX_8BIT, 0x0356, 0x04},
+	{IMX_8BIT, 0x0357, 0x96},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x07},
+	{IMX_8BIT, 0x3311, 0x90},
+	{IMX_8BIT, 0x3312, 0x04},
+	{IMX_8BIT, 0x3313, 0x50},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x00},
+	{IMX_8BIT, 0x4084, 0x07},
+	{IMX_8BIT, 0x4085, 0x90},
+	{IMX_8BIT, 0x4086, 0x04},
+	{IMX_8BIT, 0x4087, 0x50},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5F},
+	{IMX_8BIT, 0x0831, 0x0C},
+	{IMX_8BIT, 0x0832, 0x3F},
+	{IMX_8BIT, 0x0833, 0x1F},
+	{IMX_8BIT, 0x0834, 0x1F},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x04},
+	{IMX_8BIT, 0x0203, 0xA8},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{IMX_8BIT, 0x0230, 0x00},
+	{IMX_8BIT, 0x0231, 0x00},
+	{IMX_8BIT, 0x0233, 0x00},
+	{IMX_8BIT, 0x0234, 0x00},
+	{IMX_8BIT, 0x0235, 0x40},
+	{IMX_8BIT, 0x0238, 0x00},
+	{IMX_8BIT, 0x0239, 0x04},
+	{IMX_8BIT, 0x023B, 0x00},
+	{IMX_8BIT, 0x023C, 0x01},
+	{IMX_8BIT, 0x33B0, 0x04},
+	{IMX_8BIT, 0x33B1, 0x00},
+	{IMX_8BIT, 0x33B3, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_2M_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0C},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x02},
+	{IMX_8BIT, 0x030C, 0x02},
+	{IMX_8BIT, 0x030D, 0x38},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0C},
+	{IMX_8BIT, 0x0341, 0x1C},
+	{IMX_8BIT, 0x0342, 0x17},
+	{IMX_8BIT, 0x0343, 0xD4},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x36},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x39},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x06},
+	{IMX_8BIT, 0x034D, 0x68},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0xD0},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x08},
+	{IMX_8BIT, 0x0355, 0x02},
+	{IMX_8BIT, 0x0356, 0x06},
+	{IMX_8BIT, 0x0357, 0x04},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x06},
+	{IMX_8BIT, 0x3311, 0x68},
+	{IMX_8BIT, 0x3312, 0x04},
+	{IMX_8BIT, 0x3313, 0xD0},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0xC2},
+	{IMX_8BIT, 0x4084, 0x06},
+	{IMX_8BIT, 0x4085, 0x68},
+	{IMX_8BIT, 0x4086, 0x04},
+	{IMX_8BIT, 0x4087, 0xD0},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5f},
+	{IMX_8BIT, 0x0831, 0x0c},
+	{IMX_8BIT, 0x0832, 0x3f},
+	{IMX_8BIT, 0x0833, 0x1f},
+	{IMX_8BIT, 0x0834, 0x1f},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0c},
+	{IMX_8BIT, 0x0203, 0x18},
+	/* Gain Setting */
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x01},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x01},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00},
+	{ IMX_8BIT, 0x0231, 0x00},
+	{ IMX_8BIT, 0x0233, 0x00},
+	{ IMX_8BIT, 0x0234, 0x00},
+	{ IMX_8BIT, 0x0235, 0x40},
+	{ IMX_8BIT, 0x0238, 0x00},
+	{ IMX_8BIT, 0x0239, 0x04},
+	{ IMX_8BIT, 0x023B, 0x00},
+	{ IMX_8BIT, 0x023C, 0x01},
+	{ IMX_8BIT, 0x33B0, 0x04},
+	{ IMX_8BIT, 0x33B1, 0x00},
+	{ IMX_8BIT, 0x33B3, 0x00},
+	{ IMX_8BIT, 0x33B4, 0x01},
+	{ IMX_8BIT, 0x3800, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_1600x1200_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0B},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x02},
+	{ IMX_8BIT, 0x030C, 0x01},
+	{ IMX_8BIT, 0x030D, 0x83},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x14},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x08},
+	{IMX_8BIT, 0x0341, 0xb8},
+	{IMX_8BIT, 0x0342, 0x15},
+	{IMX_8BIT, 0x0343, 0x18},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x40},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x20},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x2F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x13},
+	{IMX_8BIT, 0x034C, 0x06},
+	{IMX_8BIT, 0x034D, 0x60},
+	{IMX_8BIT, 0x034E, 0x04},
+	{IMX_8BIT, 0x034F, 0xC8},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x07},
+	{IMX_8BIT, 0x0355, 0xF8},
+	{IMX_8BIT, 0x0356, 0x05},
+	{IMX_8BIT, 0x0357, 0xFA},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x06},
+	{IMX_8BIT, 0x3311, 0x60},
+	{IMX_8BIT, 0x3312, 0x04},
+	{IMX_8BIT, 0x3313, 0xC8},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x9A},
+	{IMX_8BIT, 0x4084, 0x06},
+	{IMX_8BIT, 0x4085, 0x60},
+	{IMX_8BIT, 0x4086, 0x04},
+	{IMX_8BIT, 0x4087, 0xC8},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_720p_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Clock setting */
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0B},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x02},
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x83},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x19},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* optimal function setting */
+	{IMX_8BIT, 0x0700, 0x00},
+	{IMX_8BIT, 0x3A63, 0x00},
+	{IMX_8BIT, 0x4100, 0xF8},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x4344, 0x00},
+	{IMX_8BIT, 0x441C, 0x01},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x04},
+	{IMX_8BIT, 0x0341, 0xAC},
+	{IMX_8BIT, 0x0342, 0x12},
+	{IMX_8BIT, 0x0343, 0x58},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x4E},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x9C},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x21},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0x97},
+	{IMX_8BIT, 0x034C, 0x05},
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x02},
+	{IMX_8BIT, 0x034F, 0xE0},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x07},
+	{IMX_8BIT, 0x0355, 0xEA},
+	{IMX_8BIT, 0x0356, 0x04},
+	{IMX_8BIT, 0x0357, 0x7E},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x05},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x02},
+	{IMX_8BIT, 0x3313, 0xE0},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x26},
+	{IMX_8BIT, 0x4084, 0x05},
+	{IMX_8BIT, 0x4085, 0x10},
+	{IMX_8BIT, 0x4086, 0x02},
+	{IMX_8BIT, 0x4087, 0xE0},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5F},
+	{IMX_8BIT, 0x0831, 0x0C},
+	{IMX_8BIT, 0x0832, 0x3F},
+	{IMX_8BIT, 0x0833, 0x1F},
+	{IMX_8BIT, 0x0834, 0x1F},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0C},
+	{IMX_8BIT, 0x0203, 0x18},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{IMX_8BIT, 0x0230, 0x00},
+	{IMX_8BIT, 0x0231, 0x00},
+	{IMX_8BIT, 0x0233, 0x00},
+	{IMX_8BIT, 0x0234, 0x00},
+	{IMX_8BIT, 0x0235, 0x40},
+	{IMX_8BIT, 0x0238, 0x00},
+	{IMX_8BIT, 0x0239, 0x04},
+	{IMX_8BIT, 0x023B, 0x00},
+	{IMX_8BIT, 0x023C, 0x01},
+	{IMX_8BIT, 0x33B0, 0x04},
+	{IMX_8BIT, 0x33B1, 0x00},
+	{IMX_8BIT, 0x33B3, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_1M_4_3_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0B},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x02},
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x83},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x22},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x1F},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07},
+	{IMX_8BIT, 0x0341, 0x08},
+	{IMX_8BIT, 0x0342, 0x12},
+	{IMX_8BIT, 0x0343, 0x58},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x58},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x28},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x17},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x07},
+	{IMX_8BIT, 0x034C, 0x04},
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x03},
+	{IMX_8BIT, 0x034F, 0x10},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x07},
+	{IMX_8BIT, 0x0355, 0xE0},
+	{IMX_8BIT, 0x0356, 0x05},
+	{IMX_8BIT, 0x0357, 0xF0},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x04},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x03},
+	{IMX_8BIT, 0x3313, 0x10},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x4E},
+	{IMX_8BIT, 0x4084, 0x04},
+	{IMX_8BIT, 0x4085, 0x10},
+	{IMX_8BIT, 0x4086, 0x03},
+	{IMX_8BIT, 0x4087, 0x10},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5F},
+	{IMX_8BIT, 0x0831, 0x0C},
+	{IMX_8BIT, 0x0832, 0x3F},
+	{IMX_8BIT, 0x0833, 0x1F},
+	{IMX_8BIT, 0x0834, 0x1F},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x06},
+	{IMX_8BIT, 0x0203, 0x02},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{IMX_8BIT, 0x0230, 0x00},
+	{IMX_8BIT, 0x0231, 0x00},
+	{IMX_8BIT, 0x0233, 0x00},
+	{IMX_8BIT, 0x0234, 0x00},
+	{IMX_8BIT, 0x0235, 0x40},
+	{IMX_8BIT, 0x0238, 0x00},
+	{IMX_8BIT, 0x0239, 0x04},
+	{IMX_8BIT, 0x023B, 0x00},
+	{IMX_8BIT, 0x023C, 0x01},
+	{IMX_8BIT, 0x33B0, 0x04},
+	{IMX_8BIT, 0x33B1, 0x00},
+	{IMX_8BIT, 0x33B3, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_D1_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x16},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x50},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0xC4},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x1F},
+	{IMX_8BIT, 0x034A, 0x0B},
+	{IMX_8BIT, 0x034B, 0x6B},
+	{IMX_8BIT, 0x034C, 0x02},
+	{IMX_8BIT, 0x034D, 0xE0},
+	{IMX_8BIT, 0x034E, 0x01},
+	{IMX_8BIT, 0x034F, 0xF0},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xF4},
+	{IMX_8BIT, 0x0356, 0x02},
+	{IMX_8BIT, 0x0357, 0xAA},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x02},
+	{IMX_8BIT, 0x3311, 0xE0},
+	{IMX_8BIT, 0x3312, 0x01},
+	{IMX_8BIT, 0x3313, 0xF0},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0xFE},
+	{IMX_8BIT, 0x4084, 0x02},
+	{IMX_8BIT, 0x4085, 0xE0},
+	{IMX_8BIT, 0x4086, 0x01},
+	{IMX_8BIT, 0x4087, 0xF0},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_VGA_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0B},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x02},
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x83},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x19},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x03},
+	{IMX_8BIT, 0x0341, 0x1E},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x34},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x08},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x3B},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x27},
+	{IMX_8BIT, 0x034C, 0x02},
+	{IMX_8BIT, 0x034D, 0x90},
+	{IMX_8BIT, 0x034E, 0x01},
+	{IMX_8BIT, 0x034F, 0xF0},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x04},
+	{IMX_8BIT, 0x0355, 0x02},
+	{IMX_8BIT, 0x0356, 0x03},
+	{IMX_8BIT, 0x0357, 0x08},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x02},
+	{IMX_8BIT, 0x3311, 0x90},
+	{IMX_8BIT, 0x3312, 0x01},
+	{IMX_8BIT, 0x3313, 0xF0},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0xDC},
+	{IMX_8BIT, 0x4084, 0x02},
+	{IMX_8BIT, 0x4085, 0x90},
+	{IMX_8BIT, 0x4086, 0x01},
+	{IMX_8BIT, 0x4087, 0xF0},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5F},
+	{IMX_8BIT, 0x0831, 0x0C},
+	{IMX_8BIT, 0x0832, 0x3F},
+	{IMX_8BIT, 0x0833, 0x1F},
+	{IMX_8BIT, 0x0834, 0x1F},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x03},
+	{IMX_8BIT, 0x0203, 0x1A},
+	/* Gain Setting */
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x01},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x01},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00},
+	{ IMX_8BIT, 0x0231, 0x00},
+	{ IMX_8BIT, 0x0233, 0x00},
+	{ IMX_8BIT, 0x0234, 0x00},
+	{ IMX_8BIT, 0x0235, 0x40},
+	{ IMX_8BIT, 0x0238, 0x00},
+	{ IMX_8BIT, 0x0239, 0x04},
+	{ IMX_8BIT, 0x023B, 0x00},
+	{ IMX_8BIT, 0x023C, 0x01},
+	{ IMX_8BIT, 0x33B0, 0x04},
+	{ IMX_8BIT, 0x33B1, 0x00},
+	{ IMX_8BIT, 0x33B3, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_CIF_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x29},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0xD8},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x0F},
+	{IMX_8BIT, 0x0349, 0x97},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x01},
+	{IMX_8BIT, 0x034D, 0x70},
+	{IMX_8BIT, 0x034E, 0x01},
+	{IMX_8BIT, 0x034F, 0x30},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xB0},
+	{IMX_8BIT, 0x0356, 0x03},
+	{IMX_8BIT, 0x0357, 0x0C},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x01},
+	{IMX_8BIT, 0x3311, 0x70},
+	{IMX_8BIT, 0x3312, 0x01},
+	{IMX_8BIT, 0x3313, 0x30},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x4A},
+	{IMX_8BIT, 0x4084, 0x01},
+	{IMX_8BIT, 0x4085, 0x70},
+	{IMX_8BIT, 0x4086, 0x01},
+	{IMX_8BIT, 0x4087, 0x30},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_QVGA_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{IMX_8BIT, 0x011E, 0x13},
+	{IMX_8BIT, 0x011F, 0x33},
+	{IMX_8BIT, 0x0301, 0x05},
+	{IMX_8BIT, 0x0303, 0x01},
+	{IMX_8BIT, 0x0305, 0x0B},
+	{IMX_8BIT, 0x0309, 0x05},
+	{IMX_8BIT, 0x030B, 0x02},
+	{IMX_8BIT, 0x030C, 0x01},
+	{IMX_8BIT, 0x030D, 0x83},
+	{IMX_8BIT, 0x030E, 0x01},
+	{IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x28},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0x00},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0x40},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x14},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x2F},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x1B},
+	{IMX_8BIT, 0x034C, 0x01},
+	{IMX_8BIT, 0x034D, 0x50},
+	{IMX_8BIT, 0x034E, 0x01},
+	{IMX_8BIT, 0x034F, 0x00},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xFC},
+	{IMX_8BIT, 0x0356, 0x03},
+	{IMX_8BIT, 0x0357, 0x02},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x01},
+	{IMX_8BIT, 0x3311, 0x98},
+	{IMX_8BIT, 0x3312, 0x01},
+	{IMX_8BIT, 0x3313, 0x34},
+	{IMX_8BIT, 0x331C, 0x01},
+	{IMX_8BIT, 0x331D, 0x68},
+	{IMX_8BIT, 0x4084, 0x01},
+	{IMX_8BIT, 0x4085, 0x98},
+	{IMX_8BIT, 0x4086, 0x01},
+	{IMX_8BIT, 0x4087, 0x34},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5F},
+	{IMX_8BIT, 0x0831, 0x0C},
+	{IMX_8BIT, 0x0832, 0x3F},
+	{IMX_8BIT, 0x0833, 0x1F},
+	{IMX_8BIT, 0x0834, 0x1F},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07},
+	{IMX_8BIT, 0x0203, 0xA4},
+	/* Gain Setting */
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x01},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x01},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00},
+	{ IMX_8BIT, 0x0231, 0x00},
+	{ IMX_8BIT, 0x0233, 0x00},
+	{ IMX_8BIT, 0x0234, 0x00},
+	{ IMX_8BIT, 0x0235, 0x40},
+	{ IMX_8BIT, 0x0238, 0x00},
+	{ IMX_8BIT, 0x0239, 0x04},
+	{ IMX_8BIT, 0x023B, 0x00},
+	{ IMX_8BIT, 0x023C, 0x01},
+	{ IMX_8BIT, 0x33B0, 0x04},
+	{ IMX_8BIT, 0x33B1, 0x00},
+	{ IMX_8BIT, 0x33B3, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx135_QCIF_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+	{IMX_8BIT, 0x0390, 0x01},
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x02},
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x4E},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	{IMX_8BIT, 0x4203, 0xFF},
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A},
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00},
+	{IMX_8BIT, 0x0345, 0xE8},
+	{IMX_8BIT, 0x0346, 0x00},
+	{IMX_8BIT, 0x0347, 0x00},
+	{IMX_8BIT, 0x0348, 0x0F},
+	{IMX_8BIT, 0x0349, 0x87},
+	{IMX_8BIT, 0x034A, 0x0C},
+	{IMX_8BIT, 0x034B, 0x2F},
+	{IMX_8BIT, 0x034C, 0x00},
+	{IMX_8BIT, 0x034D, 0xC0},
+	{IMX_8BIT, 0x034E, 0x00},
+	{IMX_8BIT, 0x034F, 0xA0},
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x03},
+	{IMX_8BIT, 0x0355, 0xA8},
+	{IMX_8BIT, 0x0356, 0x03},
+	{IMX_8BIT, 0x0357, 0x0C},
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x00},
+	{IMX_8BIT, 0x3311, 0xC0},
+	{IMX_8BIT, 0x3312, 0x00},
+	{IMX_8BIT, 0x3313, 0xA0},
+	{IMX_8BIT, 0x331C, 0x00},
+	{IMX_8BIT, 0x331D, 0xC0},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0xC0},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0xA0},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x67},
+	{IMX_8BIT, 0x0831, 0x27},
+	{IMX_8BIT, 0x0832, 0x47},
+	{IMX_8BIT, 0x0833, 0x27},
+	{IMX_8BIT, 0x0834, 0x27},
+	{IMX_8BIT, 0x0835, 0x1F},
+	{IMX_8BIT, 0x0836, 0x87},
+	{IMX_8BIT, 0x0837, 0x2F},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A},
+	{IMX_8BIT, 0x0203, 0x56},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+static struct imx_reg const imx_init_settings_bak[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Basic Config */
+	{IMX_8BIT, 0x0101, 0x00},
+	{IMX_8BIT, 0x0105, 0x01},
+	{IMX_8BIT, 0x0110, 0x00},
+	{IMX_8BIT, 0x0220, 0x01},
+	{IMX_8BIT, 0x3302, 0x11},
+	{IMX_8BIT, 0x3833, 0x20},
+	{IMX_8BIT, 0x3893, 0x00},
+	{IMX_8BIT, 0x3906, 0x08},
+	{IMX_8BIT, 0x3907, 0x01},
+	{IMX_8BIT, 0x391B, 0x01},
+	{IMX_8BIT, 0x3C09, 0x01},
+	{IMX_8BIT, 0x600A, 0x00},
+	/* Analog Sensor Optimization */
+	{IMX_8BIT, 0x320A, 0x01},
+	{IMX_8BIT, 0x320D, 0x10},
+	{IMX_8BIT, 0x3216, 0x2E},
+	{IMX_8BIT, 0x322C, 0x02},
+	{IMX_8BIT, 0x3409, 0x0C},
+	{IMX_8BIT, 0x340C, 0x2D},
+	{IMX_8BIT, 0x3411, 0x39},
+	{IMX_8BIT, 0x3414, 0x1E},
+	{IMX_8BIT, 0x3427, 0x04},
+	{IMX_8BIT, 0x3480, 0x1E},
+	{IMX_8BIT, 0x3484, 0x1E},
+	{IMX_8BIT, 0x3488, 0x1E},
+	{IMX_8BIT, 0x348C, 0x1E},
+	{IMX_8BIT, 0x3490, 0x1E},
+	{IMX_8BIT, 0x3494, 0x1E},
+	{IMX_8BIT, 0x3511, 0x8F},
+	{IMX_8BIT, 0x364F, 0x2D},
+	GROUPED_PARAMETER_HOLD_DISABLE,
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/********************** settings for imx - reference *********************/
+static struct imx_reg const imx_init_settings[] = {
+	/* basic settings */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x0220, 0x01},
+	{ IMX_8BIT, 0x3008, 0xB0},
+	{ IMX_8BIT, 0x320A, 0x01},
+	{ IMX_8BIT, 0x320D, 0x10},
+	{ IMX_8BIT, 0x3216, 0x2E},
+	{ IMX_8BIT, 0x3230, 0x0A},
+	{ IMX_8BIT, 0x3228, 0x05},
+	{ IMX_8BIT, 0x3229, 0x02},
+	{ IMX_8BIT, 0x322C, 0x02},
+	{ IMX_8BIT, 0x3302, 0x10},
+	{ IMX_8BIT, 0x3390, 0x45},
+	{ IMX_8BIT, 0x3409, 0x0C},
+	{ IMX_8BIT, 0x340B, 0xF5},
+	{ IMX_8BIT, 0x340C, 0x2D},
+	{ IMX_8BIT, 0x3412, 0x41},
+	{ IMX_8BIT, 0x3413, 0xAD},
+	{ IMX_8BIT, 0x3414, 0x1E},
+	{ IMX_8BIT, 0x3427, 0x04},
+	{ IMX_8BIT, 0x3480, 0x1E},
+	{ IMX_8BIT, 0x3484, 0x1E},
+	{ IMX_8BIT, 0x3488, 0x1E},
+	{ IMX_8BIT, 0x348C, 0x1E},
+	{ IMX_8BIT, 0x3490, 0x1E},
+	{ IMX_8BIT, 0x3494, 0x1E},
+	{ IMX_8BIT, 0x349C, 0x38},
+	{ IMX_8BIT, 0x34A3, 0x38},
+	{ IMX_8BIT, 0x3511, 0x8F},
+	{ IMX_8BIT, 0x3518, 0x00},
+	{ IMX_8BIT, 0x3519, 0x94},
+	{ IMX_8BIT, 0x3833, 0x20},
+	{ IMX_8BIT, 0x3893, 0x01},
+	{ IMX_8BIT, 0x38C2, 0x08},
+	{ IMX_8BIT, 0x38C3, 0x08},
+	{ IMX_8BIT, 0x3C09, 0x01},
+	{ IMX_8BIT, 0x4000, 0x0E},
+	{ IMX_8BIT, 0x4300, 0x00},
+	{ IMX_8BIT, 0x4316, 0x12},
+	{ IMX_8BIT, 0x4317, 0x22},
+	{ IMX_8BIT, 0x4318, 0x00},
+	{ IMX_8BIT, 0x4319, 0x00},
+	{ IMX_8BIT, 0x431A, 0x00},
+	{ IMX_8BIT, 0x4324, 0x03},
+	{ IMX_8BIT, 0x4325, 0x20},
+	{ IMX_8BIT, 0x4326, 0x03},
+	{ IMX_8BIT, 0x4327, 0x84},
+	{ IMX_8BIT, 0x4328, 0x03},
+	{ IMX_8BIT, 0x4329, 0x20},
+	{ IMX_8BIT, 0x432A, 0x03},
+	{ IMX_8BIT, 0x432B, 0x84},
+	{ IMX_8BIT, 0x432C, 0x01},
+	{ IMX_8BIT, 0x4401, 0x3F},
+	{ IMX_8BIT, 0x4402, 0xFF},
+	{ IMX_8BIT, 0x4412, 0x3F},
+	{ IMX_8BIT, 0x4413, 0xFF},
+	{ IMX_8BIT, 0x441D, 0x28},
+	{ IMX_8BIT, 0x4444, 0x00},
+	{ IMX_8BIT, 0x4445, 0x00},
+	{ IMX_8BIT, 0x4446, 0x3F},
+	{ IMX_8BIT, 0x4447, 0xFF},
+	{ IMX_8BIT, 0x4452, 0x00},
+	{ IMX_8BIT, 0x4453, 0xA0},
+	{ IMX_8BIT, 0x4454, 0x08},
+	{ IMX_8BIT, 0x4455, 0x00},
+	{ IMX_8BIT, 0x4458, 0x18},
+	{ IMX_8BIT, 0x4459, 0x18},
+	{ IMX_8BIT, 0x445A, 0x3F},
+	{ IMX_8BIT, 0x445B, 0x3A},
+	{ IMX_8BIT, 0x4462, 0x00},
+	{ IMX_8BIT, 0x4463, 0x00},
+	{ IMX_8BIT, 0x4464, 0x00},
+	{ IMX_8BIT, 0x4465, 0x00},
+	{ IMX_8BIT, 0x446E, 0x01},
+	{ IMX_8BIT, 0x4500, 0x1F},
+	{ IMX_8BIT, 0x600a, 0x00},
+	{ IMX_8BIT, 0x380a, 0x00},
+	{ IMX_8BIT, 0x380b, 0x00},
+	{ IMX_8BIT, 0x4103, 0x00},
+	{ IMX_8BIT, 0x4243, 0x9a},
+	{ IMX_8BIT, 0x4330, 0x01},
+	{ IMX_8BIT, 0x4331, 0x90},
+	{ IMX_8BIT, 0x4332, 0x02},
+	{ IMX_8BIT, 0x4333, 0x58},
+	{ IMX_8BIT, 0x4334, 0x03},
+	{ IMX_8BIT, 0x4335, 0x20},
+	{ IMX_8BIT, 0x4336, 0x03},
+	{ IMX_8BIT, 0x4337, 0x84},
+	{ IMX_8BIT, 0x433C, 0x01},
+	{ IMX_8BIT, 0x4340, 0x02},
+	{ IMX_8BIT, 0x4341, 0x58},
+	{ IMX_8BIT, 0x4342, 0x03},
+	{ IMX_8BIT, 0x4343, 0x52},
+	{ IMX_8BIT, 0x4364, 0x0b},
+	{ IMX_8BIT, 0x4368, 0x00},
+	{ IMX_8BIT, 0x4369, 0x0f},
+	{ IMX_8BIT, 0x436a, 0x03},
+	{ IMX_8BIT, 0x436b, 0xa8},
+	{ IMX_8BIT, 0x436c, 0x00},
+	{ IMX_8BIT, 0x436d, 0x00},
+	{ IMX_8BIT, 0x436e, 0x00},
+	{ IMX_8BIT, 0x436f, 0x06},
+	{ IMX_8BIT, 0x4281, 0x21},
+	{ IMX_8BIT, 0x4282, 0x18},
+	{ IMX_8BIT, 0x4283, 0x04},
+	{ IMX_8BIT, 0x4284, 0x08},
+	{ IMX_8BIT, 0x4287, 0x7f},
+	{ IMX_8BIT, 0x4288, 0x08},
+	{ IMX_8BIT, 0x428b, 0x7f},
+	{ IMX_8BIT, 0x428c, 0x08},
+	{ IMX_8BIT, 0x428f, 0x7f},
+	{ IMX_8BIT, 0x4297, 0x00},
+	{ IMX_8BIT, 0x4298, 0x7E},
+	{ IMX_8BIT, 0x4299, 0x7E},
+	{ IMX_8BIT, 0x429A, 0x7E},
+	{ IMX_8BIT, 0x42A4, 0xFB},
+	{ IMX_8BIT, 0x42A5, 0x7E},
+	{ IMX_8BIT, 0x42A6, 0xDF},
+	{ IMX_8BIT, 0x42A7, 0xB7},
+	{ IMX_8BIT, 0x42AF, 0x03},
+	{ IMX_8BIT, 0x4207, 0x03},
+	{ IMX_8BIT, 0x4216, 0x08},
+	{ IMX_8BIT, 0x4217, 0x08},
+	{ IMX_8BIT, 0x4218, 0x00},
+	{ IMX_8BIT, 0x421B, 0x20},
+	{ IMX_8BIT, 0x421F, 0x04},
+	{ IMX_8BIT, 0x4222, 0x02},
+	{ IMX_8BIT, 0x4223, 0x22},
+	{ IMX_8BIT, 0x422E, 0x54},
+	{ IMX_8BIT, 0x422F, 0xFB},
+	{ IMX_8BIT, 0x4230, 0xFF},
+	{ IMX_8BIT, 0x4231, 0xFE},
+	{ IMX_8BIT, 0x4232, 0xFF},
+	{ IMX_8BIT, 0x4235, 0x58},
+	{ IMX_8BIT, 0x4236, 0xF7},
+	{ IMX_8BIT, 0x4237, 0xFD},
+	{ IMX_8BIT, 0x4239, 0x4E},
+	{ IMX_8BIT, 0x423A, 0xFC},
+	{ IMX_8BIT, 0x423B, 0xFD},
+	{ IMX_8BIT, 0x4300, 0x00},
+	{ IMX_8BIT, 0x4316, 0x12},
+	{ IMX_8BIT, 0x4317, 0x22},
+	{ IMX_8BIT, 0x4318, 0x00},
+	{ IMX_8BIT, 0x4319, 0x00},
+	{ IMX_8BIT, 0x431A, 0x00},
+	{ IMX_8BIT, 0x4324, 0x03},
+	{ IMX_8BIT, 0x4325, 0x20},
+	{ IMX_8BIT, 0x4326, 0x03},
+	{ IMX_8BIT, 0x4327, 0x84},
+	{ IMX_8BIT, 0x4328, 0x03},
+	{ IMX_8BIT, 0x4329, 0x20},
+	{ IMX_8BIT, 0x432A, 0x03},
+	{ IMX_8BIT, 0x432B, 0x20},
+	{ IMX_8BIT, 0x432C, 0x01},
+	{ IMX_8BIT, 0x432D, 0x01},
+	{ IMX_8BIT, 0x4338, 0x02},
+	{ IMX_8BIT, 0x4339, 0x00},
+	{ IMX_8BIT, 0x433A, 0x00},
+	{ IMX_8BIT, 0x433B, 0x02},
+	{ IMX_8BIT, 0x435A, 0x03},
+	{ IMX_8BIT, 0x435B, 0x84},
+	{ IMX_8BIT, 0x435E, 0x01},
+	{ IMX_8BIT, 0x435F, 0xFF},
+	{ IMX_8BIT, 0x4360, 0x01},
+	{ IMX_8BIT, 0x4361, 0xF4},
+	{ IMX_8BIT, 0x4362, 0x03},
+	{ IMX_8BIT, 0x4363, 0x84},
+	{ IMX_8BIT, 0x437B, 0x01},
+	{ IMX_8BIT, 0x4401, 0x3F},
+	{ IMX_8BIT, 0x4402, 0xFF},
+	{ IMX_8BIT, 0x4404, 0x13},
+	{ IMX_8BIT, 0x4405, 0x26},
+	{ IMX_8BIT, 0x4406, 0x07},
+	{ IMX_8BIT, 0x4408, 0x20},
+	{ IMX_8BIT, 0x4409, 0xE5},
+	{ IMX_8BIT, 0x440A, 0xFB},
+	{ IMX_8BIT, 0x440C, 0xF6},
+	{ IMX_8BIT, 0x440D, 0xEA},
+	{ IMX_8BIT, 0x440E, 0x20},
+	{ IMX_8BIT, 0x4410, 0x00},
+	{ IMX_8BIT, 0x4411, 0x00},
+	{ IMX_8BIT, 0x4412, 0x3F},
+	{ IMX_8BIT, 0x4413, 0xFF},
+	{ IMX_8BIT, 0x4414, 0x1F},
+	{ IMX_8BIT, 0x4415, 0xFF},
+	{ IMX_8BIT, 0x4416, 0x20},
+	{ IMX_8BIT, 0x4417, 0x00},
+	{ IMX_8BIT, 0x4418, 0x1F},
+	{ IMX_8BIT, 0x4419, 0xFF},
+	{ IMX_8BIT, 0x441A, 0x20},
+	{ IMX_8BIT, 0x441B, 0x00},
+	{ IMX_8BIT, 0x441D, 0x40},
+	{ IMX_8BIT, 0x441E, 0x1E},
+	{ IMX_8BIT, 0x441F, 0x38},
+	{ IMX_8BIT, 0x4420, 0x01},
+	{ IMX_8BIT, 0x4444, 0x00},
+	{ IMX_8BIT, 0x4445, 0x00},
+	{ IMX_8BIT, 0x4446, 0x1D},
+	{ IMX_8BIT, 0x4447, 0xF9},
+	{ IMX_8BIT, 0x4452, 0x00},
+	{ IMX_8BIT, 0x4453, 0xA0},
+	{ IMX_8BIT, 0x4454, 0x08},
+	{ IMX_8BIT, 0x4455, 0x00},
+	{ IMX_8BIT, 0x4456, 0x0F},
+	{ IMX_8BIT, 0x4457, 0xFF},
+	{ IMX_8BIT, 0x4458, 0x18},
+	{ IMX_8BIT, 0x4459, 0x18},
+	{ IMX_8BIT, 0x445A, 0x3F},
+	{ IMX_8BIT, 0x445B, 0x3A},
+	{ IMX_8BIT, 0x445C, 0x00},
+	{ IMX_8BIT, 0x445D, 0x28},
+	{ IMX_8BIT, 0x445E, 0x01},
+	{ IMX_8BIT, 0x445F, 0x90},
+	{ IMX_8BIT, 0x4460, 0x00},
+	{ IMX_8BIT, 0x4461, 0x60},
+	{ IMX_8BIT, 0x4462, 0x00},
+	{ IMX_8BIT, 0x4463, 0x00},
+	{ IMX_8BIT, 0x4464, 0x00},
+	{ IMX_8BIT, 0x4465, 0x00},
+	{ IMX_8BIT, 0x446C, 0x00},
+	{ IMX_8BIT, 0x446D, 0x00},
+	{ IMX_8BIT, 0x446E, 0x00},
+	{ IMX_8BIT, 0x452A, 0x02},
+	{ IMX_8BIT, 0x0712, 0x01},
+	{ IMX_8BIT, 0x0713, 0x00},
+	{ IMX_8BIT, 0x0714, 0x01},
+	{ IMX_8BIT, 0x0715, 0x00},
+	{ IMX_8BIT, 0x0716, 0x01},
+	{ IMX_8BIT, 0x0717, 0x00},
+	{ IMX_8BIT, 0x0718, 0x01},
+	{ IMX_8BIT, 0x0719, 0x00},
+	{ IMX_8BIT, 0x4500, 0x1F },
+
+	/*clock*/
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0B},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x02},
+	{ IMX_8BIT, 0x030C, 0x01},
+	{ IMX_8BIT, 0x030D, 0x83},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x12},
+
+	/* Gain Setting */
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x02},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x02},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{ IMX_8BIT, 0x0230, 0x00},
+	{ IMX_8BIT, 0x0231, 0x00},
+	{ IMX_8BIT, 0x0233, 0x00},
+	{ IMX_8BIT, 0x0234, 0x00},
+	{ IMX_8BIT, 0x0235, 0x40},
+	{ IMX_8BIT, 0x0238, 0x00},
+	{ IMX_8BIT, 0x0239, 0x04},
+	{ IMX_8BIT, 0x023B, 0x00},
+	{ IMX_8BIT, 0x023C, 0x01},
+	{ IMX_8BIT, 0x33B0, 0x04},
+	{ IMX_8BIT, 0x33B1, 0x00},
+	{ IMX_8BIT, 0x33B3, 0x00},
+	{ IMX_8BIT, 0x33B4, 0x01},
+	{ IMX_8BIT, 0x3800, 0x00},
+	GROUPED_PARAMETER_HOLD_DISABLE,
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/*****************************STILL********************************/
+
+/* Capture1: H : 656 V : 496 */
+static const struct imx_reg imx135_VGA_STILL_74fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x19 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x03 },
+	{IMX_8BIT, 0x0341, 0x1E },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xDC },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x34 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x08 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x3B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x27 },
+	{IMX_8BIT, 0x034C, 0x02 },
+	{IMX_8BIT, 0x034D, 0x90 },
+	{IMX_8BIT, 0x034E, 0x01 },
+	{IMX_8BIT, 0x034F, 0xF0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x04 },
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x08 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x02 },
+	{IMX_8BIT, 0x3311, 0x90 },
+	{IMX_8BIT, 0x3312, 0x01 },
+	{IMX_8BIT, 0x3313, 0xF0 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0xDC },
+	{IMX_8BIT, 0x4084, 0x02 },
+	{IMX_8BIT, 0x4085, 0x90 },
+	{IMX_8BIT, 0x4086, 0x01 },
+	{IMX_8BIT, 0x4087, 0xF0 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x03 },
+	{IMX_8BIT, 0x0203, 0x1A },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture2: H : 1936 V : 1104 */
+static const struct imx_reg imx135_1080P_STILL_48fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x11 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x04 },
+	{IMX_8BIT, 0x0341, 0xAC },
+	{IMX_8BIT, 0x0342, 0x12 },
+	{IMX_8BIT, 0x0343, 0x58 },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x2E },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x84 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x41 },
+	{IMX_8BIT, 0x034A, 0x0A },
+	{IMX_8BIT, 0x034B, 0xAF },
+	{IMX_8BIT, 0x034C, 0x07 },
+	{IMX_8BIT, 0x034D, 0x90 },
+	{IMX_8BIT, 0x034E, 0x04 },
+	{IMX_8BIT, 0x034F, 0x50 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x0A },
+	{IMX_8BIT, 0x0356, 0x04 },
+	{IMX_8BIT, 0x0357, 0x96 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x07 },
+	{IMX_8BIT, 0x3311, 0x90 },
+	{IMX_8BIT, 0x3312, 0x04 },
+	{IMX_8BIT, 0x3313, 0x50 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0x00 },
+	{IMX_8BIT, 0x4084, 0x07 },
+	{IMX_8BIT, 0x4085, 0x90 },
+	{IMX_8BIT, 0x4086, 0x04 },
+	{IMX_8BIT, 0x4087, 0x50 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x04 },
+	{IMX_8BIT, 0x0203, 0xA8 },
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture3: H : 1040 V : 784 */
+static const struct imx_reg imx135_1M_STILL_37fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x1F },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x06 },
+	{IMX_8BIT, 0x0341, 0x06 },
+	{IMX_8BIT, 0x0342, 0x12 },
+	{IMX_8BIT, 0x0343, 0x58 },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x58 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x28 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x17 },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x07 },
+	{IMX_8BIT, 0x034C, 0x04 },
+	{IMX_8BIT, 0x034D, 0x10 },
+	{IMX_8BIT, 0x034E, 0x03 },
+	{IMX_8BIT, 0x034F, 0x10 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x07 },
+	{IMX_8BIT, 0x0355, 0xE0 },
+	{IMX_8BIT, 0x0356, 0x05 },
+	{IMX_8BIT, 0x0357, 0xF0 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x04 },
+	{IMX_8BIT, 0x3311, 0x10 },
+	{IMX_8BIT, 0x3312, 0x03 },
+	{IMX_8BIT, 0x3313, 0x10 },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0x4E },
+	{IMX_8BIT, 0x4084, 0x04 },
+	{IMX_8BIT, 0x4085, 0x10 },
+	{IMX_8BIT, 0x4086, 0x03 },
+	{IMX_8BIT, 0x4087, 0x10 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x06 },
+	{IMX_8BIT, 0x0203, 0x02 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture4: H : 1640 V : 1232 */
+static const struct imx_reg imx135_2M_STILL_37fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x06 },
+	{IMX_8BIT, 0x0341, 0x1A },
+	{IMX_8BIT, 0x0342, 0x12 },
+	{IMX_8BIT, 0x0343, 0x58 },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x36 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x39 },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x06 },
+	{IMX_8BIT, 0x034D, 0x68 },
+	{IMX_8BIT, 0x034E, 0x04 },
+	{IMX_8BIT, 0x034F, 0xD0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x06 },
+	{IMX_8BIT, 0x0357, 0x04 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x06 },
+	{IMX_8BIT, 0x3311, 0x68 },
+	{IMX_8BIT, 0x3312, 0x04 },
+	{IMX_8BIT, 0x3313, 0xD0 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0xC2 },
+	{IMX_8BIT, 0x4084, 0x06 },
+	{IMX_8BIT, 0x4085, 0x68 },
+	{IMX_8BIT, 0x4086, 0x04 },
+	{IMX_8BIT, 0x4087, 0xD0 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x06 },
+	{IMX_8BIT, 0x0203, 0x16 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture5: H : 2064 V : 1552 */
+static const struct imx_reg imx135_3M_STILL_37fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x00 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x10 },
+	{IMX_8BIT, 0x4082, 0x01 },
+	{IMX_8BIT, 0x4083, 0x01 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x06 },
+	{IMX_8BIT, 0x0341, 0x26 },
+	{IMX_8BIT, 0x0342, 0x12 },
+	{IMX_8BIT, 0x0343, 0x58 },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x28 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x08 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x47 },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x27 },
+	{IMX_8BIT, 0x034C, 0x08 },
+	{IMX_8BIT, 0x034D, 0x10 },
+	{IMX_8BIT, 0x034E, 0x06 },
+	{IMX_8BIT, 0x034F, 0x10 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x10 },
+	{IMX_8BIT, 0x0356, 0x06 },
+	{IMX_8BIT, 0x0357, 0x10 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x08 },
+	{IMX_8BIT, 0x3311, 0x10 },
+	{IMX_8BIT, 0x3312, 0x06 },
+	{IMX_8BIT, 0x3313, 0x10 },
+	{IMX_8BIT, 0x331C, 0x00 },
+	{IMX_8BIT, 0x331D, 0xAA },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0x00 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x06 },
+	{IMX_8BIT, 0x0203, 0x22 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture6: H : 2576 V : 1936 */
+static const struct imx_reg imx135_5M_STILL_19fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0C},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x01},
+	{ IMX_8BIT, 0x030C, 0x02},
+	{ IMX_8BIT, 0x030D, 0x32},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x11},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x00 },
+	{IMX_8BIT, 0x0391, 0x11 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x19 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0B },
+	{IMX_8BIT, 0x0341, 0xEA },
+	{IMX_8BIT, 0x0342, 0x12 },
+	{IMX_8BIT, 0x0343, 0x58 },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x5C },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x30 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x15 },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x03 },
+	{IMX_8BIT, 0x034C, 0x0A },
+	{IMX_8BIT, 0x034D, 0x10 },
+	{IMX_8BIT, 0x034E, 0x07 },
+	{IMX_8BIT, 0x034F, 0x90 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x01 },
+	{IMX_8BIT, 0x0354, 0x0F },
+	{IMX_8BIT, 0x0355, 0xBA },
+	{IMX_8BIT, 0x0356, 0x0B },
+	{IMX_8BIT, 0x0357, 0xD2 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x0A },
+	{IMX_8BIT, 0x3311, 0x10 },
+	{IMX_8BIT, 0x3312, 0x07 },
+	{IMX_8BIT, 0x3313, 0x90 },
+	{IMX_8BIT, 0x331C, 0x03 },
+	{IMX_8BIT, 0x331D, 0xAE },
+	{IMX_8BIT, 0x4084, 0x0A },
+	{IMX_8BIT, 0x4085, 0x10 },
+	{IMX_8BIT, 0x4086, 0x07 },
+	{IMX_8BIT, 0x4087, 0x90 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x77 },
+	{IMX_8BIT, 0x0831, 0x2F },
+	{IMX_8BIT, 0x0832, 0x4F },
+	{IMX_8BIT, 0x0833, 0x2F },
+	{IMX_8BIT, 0x0834, 0x2F },
+	{IMX_8BIT, 0x0835, 0x37 },
+	{IMX_8BIT, 0x0836, 0xA7 },
+	{IMX_8BIT, 0x0837, 0x37 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0B },
+	{IMX_8BIT, 0x0203, 0xE6 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture7: H : 3264 V : 1836 */
+static const struct imx_reg imx135_6M_STILL_20fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0C},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x01},
+	{ IMX_8BIT, 0x030C, 0x02},
+	{ IMX_8BIT, 0x030D, 0x32},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x11},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x00 },
+	{IMX_8BIT, 0x0391, 0x11 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x4203, 0xFF },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0b }, /* 0c */
+	{IMX_8BIT, 0x0341, 0xea }, /* c0 */
+	{IMX_8BIT, 0x0342, 0x27 }, /* 27 */
+	{IMX_8BIT, 0x0343, 0x10 }, /* 10 */
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x36 },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x94 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x39 },
+	{IMX_8BIT, 0x034A, 0x0a },
+	{IMX_8BIT, 0x034B, 0x9f },
+	{IMX_8BIT, 0x034C, 0x0C },
+	{IMX_8BIT, 0x034D, 0xd0 },
+	{IMX_8BIT, 0x034E, 0x07 },
+	{IMX_8BIT, 0x034F, 0x3c },
+	{IMX_8BIT, 0x0350, 0x00 }, /* crop x */
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 }, /* crop y */
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x10 }, /* crop size */
+	{IMX_8BIT, 0x0355, 0x04 },
+	{IMX_8BIT, 0x0356, 0x09 }, /* crop size */
+	{IMX_8BIT, 0x0357, 0x0c },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x0C },
+	{IMX_8BIT, 0x3311, 0xd0 },
+	{IMX_8BIT, 0x3312, 0x07 },
+	{IMX_8BIT, 0x3313, 0x3C },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0xa0 },
+	{IMX_8BIT, 0x4084, 0x0C },
+	{IMX_8BIT, 0x4085, 0xd0 },
+	{IMX_8BIT, 0x4086, 0x07 },
+	{IMX_8BIT, 0x4087, 0x3C },
+	{IMX_8BIT, 0x4400, 0x00 },
+	{IMX_8BIT, 0x0830, 0x87 },
+	{IMX_8BIT, 0x0831, 0x3F },
+	{IMX_8BIT, 0x0832, 0x67 },
+	{IMX_8BIT, 0x0833, 0x3F },
+	{IMX_8BIT, 0x0834, 0x3F },
+	{IMX_8BIT, 0x0835, 0x4F },
+	{IMX_8BIT, 0x0836, 0xDF },
+	{IMX_8BIT, 0x0837, 0x47 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0A },
+	{IMX_8BIT, 0x0203, 0x56 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture8: H : 3280 V : 2464 */
+static const struct imx_reg imx135_8M_STILL_15fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0C},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x01},
+	{ IMX_8BIT, 0x030C, 0x02},
+	{ IMX_8BIT, 0x030D, 0x32},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x11},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x00 },
+	{IMX_8BIT, 0x0391, 0x11 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x00 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x10 },
+	{IMX_8BIT, 0x4082, 0x01 },
+	{IMX_8BIT, 0x4083, 0x01 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0a },
+	{IMX_8BIT, 0x0341, 0x3c },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xdc },
+	{IMX_8BIT, 0x0344, 0x01 },
+	{IMX_8BIT, 0x0345, 0xd0 },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x48 },
+	{IMX_8BIT, 0x0348, 0x0e },
+	{IMX_8BIT, 0x0349, 0x9f },
+	{IMX_8BIT, 0x034A, 0x0a },
+	{IMX_8BIT, 0x034B, 0xe7 },
+	{IMX_8BIT, 0x034C, 0x0c },
+	{IMX_8BIT, 0x034D, 0xd0 },
+	{IMX_8BIT, 0x034E, 0x09 },
+	{IMX_8BIT, 0x034F, 0xA0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x0c },
+	{IMX_8BIT, 0x0355, 0xd0 },
+	{IMX_8BIT, 0x0356, 0x09 },
+	{IMX_8BIT, 0x0357, 0xa0 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x0C },
+	{IMX_8BIT, 0x3311, 0xD0 },
+	{IMX_8BIT, 0x3312, 0x09 },
+	{IMX_8BIT, 0x3313, 0xA0 },
+	{IMX_8BIT, 0x331C, 0x00 },
+	{IMX_8BIT, 0x331D, 0x10 },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0x00 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x87 },
+	{IMX_8BIT, 0x0831, 0x3F },
+	{IMX_8BIT, 0x0832, 0x67 },
+	{IMX_8BIT, 0x0833, 0x3F },
+	{IMX_8BIT, 0x0834, 0x3F },
+	{IMX_8BIT, 0x0835, 0x4f },
+	{IMX_8BIT, 0x0836, 0xdf },
+	{IMX_8BIT, 0x0837, 0x47 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0a },
+	{IMX_8BIT, 0x0203, 0x38 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Capture9: H : 4208 V : 3120 */
+static const struct imx_reg imx135_13M_STILL_7fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x00 },
+	{IMX_8BIT, 0x0391, 0x11 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x00 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x10 },
+	{IMX_8BIT, 0x4082, 0x01 },
+	{IMX_8BIT, 0x4083, 0x01 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0E },
+	{IMX_8BIT, 0x0341, 0xD8 },
+	{IMX_8BIT, 0x0342, 0x27 },
+	{IMX_8BIT, 0x0343, 0x10 },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x00 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x00 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x6F },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x2F },
+	{IMX_8BIT, 0x034C, 0x10 },
+	{IMX_8BIT, 0x034D, 0x70 },
+	{IMX_8BIT, 0x034E, 0x0C },
+	{IMX_8BIT, 0x034F, 0x30 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x10 },
+	{IMX_8BIT, 0x0355, 0x70 },
+	{IMX_8BIT, 0x0356, 0x0C },
+	{IMX_8BIT, 0x0357, 0x30 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x10 },
+	{IMX_8BIT, 0x3311, 0x70 },
+	{IMX_8BIT, 0x3312, 0x0C },
+	{IMX_8BIT, 0x3313, 0x30 },
+	{IMX_8BIT, 0x331C, 0x00 },
+	{IMX_8BIT, 0x331D, 0x10 },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0x00 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x77 },
+	{IMX_8BIT, 0x0831, 0x2F },
+	{IMX_8BIT, 0x0832, 0x4F },
+	{IMX_8BIT, 0x0833, 0x2F },
+	{IMX_8BIT, 0x0834, 0x2F },
+	{IMX_8BIT, 0x0835, 0x37 },
+	{IMX_8BIT, 0x0836, 0xA7 },
+	{IMX_8BIT, 0x0837, 0x37 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x0E },
+	{IMX_8BIT, 0x0203, 0xD4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/*****************************IMX135 PREVIEW********************************/
+
+/* Preview1: H : 848 V : 616 */
+static struct imx_reg const imx135_PREVIEW_848x616_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0B},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x02},
+	{ IMX_8BIT, 0x030C, 0x01},
+	{ IMX_8BIT, 0x030D, 0x83},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x13 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x08 },
+	{IMX_8BIT, 0x0341, 0xB8 },
+	{IMX_8BIT, 0x0342, 0x15 },
+	{IMX_8BIT, 0x0343, 0x18 },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x58 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x60 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x17 },
+	{IMX_8BIT, 0x034A, 0x0B },
+	{IMX_8BIT, 0x034B, 0xCF },
+	{IMX_8BIT, 0x034C, 0x03 },
+	{IMX_8BIT, 0x034D, 0x50 },
+	{IMX_8BIT, 0x034E, 0x02 },
+	{IMX_8BIT, 0x034F, 0x68 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 },
+	{IMX_8BIT, 0x0355, 0xF0 },
+	{IMX_8BIT, 0x0356, 0x02 },
+	{IMX_8BIT, 0x0357, 0xDC },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x03 },
+	{IMX_8BIT, 0x3311, 0x50 },
+	{IMX_8BIT, 0x3312, 0x02 },
+	{IMX_8BIT, 0x3313, 0x68 },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0x1C },
+	{IMX_8BIT, 0x4084, 0x03 },
+	{IMX_8BIT, 0x4085, 0x50 },
+	{IMX_8BIT, 0x4086, 0x02 },
+	{IMX_8BIT, 0x4087, 0x68 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x0C },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	/* Gain Setting */
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x02},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x02},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	{IMX_TOK_TERM, 0, 0}
+};
+/* Preview2: H : 1040 V : 592 */
+static struct imx_reg const imx135_1M_16_9_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0B},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x02},
+	{ IMX_8BIT, 0x030C, 0x01},
+	{ IMX_8BIT, 0x030D, 0x83},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x12},
+	/*mode setting*/
+	{IMX_8BIT, 0x0108, 0x03},
+	{IMX_8BIT, 0x0112, 0x0A},
+	{IMX_8BIT, 0x0113, 0x0A},
+	{IMX_8BIT, 0x0381, 0x01},
+	{IMX_8BIT, 0x0383, 0x01},
+	{IMX_8BIT, 0x0385, 0x01},
+	{IMX_8BIT, 0x0387, 0x01},
+
+	{IMX_8BIT, 0x0390, 0x01}, /* Binning 0x22 : 1/2 ox44: 1/4 */
+	{IMX_8BIT, 0x0391, 0x44},
+	{IMX_8BIT, 0x0392, 0x00},
+	{IMX_8BIT, 0x0401, 0x00}, /* SCALING */
+	{IMX_8BIT, 0x0404, 0x00},
+	{IMX_8BIT, 0x0405, 0x00},
+	{IMX_8BIT, 0x4082, 0x00},
+	{IMX_8BIT, 0x4083, 0x00},
+	/*{IMX_8BIT, 0x4203, 0xFF},*/
+	{IMX_8BIT, 0x7006, 0x04},
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x0A}, /* VTS HTS*/
+	{IMX_8BIT, 0x0341, 0x5A},
+	{IMX_8BIT, 0x0342, 0x11},
+	{IMX_8BIT, 0x0343, 0xDC},
+	{IMX_8BIT, 0x0344, 0x00}, /* xo-y1 */
+	{IMX_8BIT, 0x0345, 0x18},
+	{IMX_8BIT, 0x0346, 0x01},
+	{IMX_8BIT, 0x0347, 0x78},
+	{IMX_8BIT, 0x0348, 0x10},
+	{IMX_8BIT, 0x0349, 0x57},
+	{IMX_8BIT, 0x034A, 0x0A},
+	{IMX_8BIT, 0x034B, 0xB7},
+
+	{IMX_8BIT, 0x034C, 0x04}, /* out */
+	{IMX_8BIT, 0x034D, 0x10},
+	{IMX_8BIT, 0x034E, 0x02},
+	{IMX_8BIT, 0x034F, 0x50},
+
+	{IMX_8BIT, 0x0350, 0x00},
+	{IMX_8BIT, 0x0351, 0x00},
+	{IMX_8BIT, 0x0352, 0x00},
+	{IMX_8BIT, 0x0353, 0x00},
+	{IMX_8BIT, 0x0354, 0x04}, /* Dig Crop */
+	{IMX_8BIT, 0x0355, 0x10},
+	{IMX_8BIT, 0x0356, 0x02},
+	{IMX_8BIT, 0x0357, 0x50},
+
+	{IMX_8BIT, 0x301D, 0x30},
+	{IMX_8BIT, 0x3310, 0x04},
+	{IMX_8BIT, 0x3311, 0x10},
+	{IMX_8BIT, 0x3312, 0x02},
+	{IMX_8BIT, 0x3313, 0x50},
+	{IMX_8BIT, 0x331C, 0x02},
+	{IMX_8BIT, 0x331D, 0x3F},
+	{IMX_8BIT, 0x4084, 0x00},
+	{IMX_8BIT, 0x4085, 0x00},
+	{IMX_8BIT, 0x4086, 0x00},
+	{IMX_8BIT, 0x4087, 0x00},
+	{IMX_8BIT, 0x4400, 0x00},
+	/* Global Timing */
+	{IMX_8BIT, 0x0830, 0x5F},
+	{IMX_8BIT, 0x0831, 0x0C},
+	{IMX_8BIT, 0x0832, 0x3F},
+	{IMX_8BIT, 0x0833, 0x1F},
+	{IMX_8BIT, 0x0834, 0x1F},
+	{IMX_8BIT, 0x0835, 0x17},
+	{IMX_8BIT, 0x0836, 0x67},
+	{IMX_8BIT, 0x0837, 0x27},
+	{IMX_8BIT, 0x0839, 0x1F},
+	{IMX_8BIT, 0x083A, 0x17},
+	{IMX_8BIT, 0x083B, 0x02},
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x06},
+	{IMX_8BIT, 0x0203, 0x02},
+	/* Gain Setting */
+	{IMX_8BIT, 0x0205, 0x00},
+	{IMX_8BIT, 0x020E, 0x01},
+	{IMX_8BIT, 0x020F, 0x00},
+	{IMX_8BIT, 0x0210, 0x01},
+	{IMX_8BIT, 0x0211, 0x00},
+	{IMX_8BIT, 0x0212, 0x01},
+	{IMX_8BIT, 0x0213, 0x00},
+	{IMX_8BIT, 0x0214, 0x01},
+	{IMX_8BIT, 0x0215, 0x00},
+	/* HDR Setting */
+	{IMX_8BIT, 0x0230, 0x00},
+	{IMX_8BIT, 0x0231, 0x00},
+	{IMX_8BIT, 0x0233, 0x00},
+	{IMX_8BIT, 0x0234, 0x00},
+	{IMX_8BIT, 0x0235, 0x40},
+	{IMX_8BIT, 0x0238, 0x00},
+	{IMX_8BIT, 0x0239, 0x04},
+	{IMX_8BIT, 0x023B, 0x00},
+	{IMX_8BIT, 0x023C, 0x01},
+	{IMX_8BIT, 0x33B0, 0x04},
+	{IMX_8BIT, 0x33B1, 0x00},
+	{IMX_8BIT, 0x33B3, 0x00},
+	{IMX_8BIT, 0x33B4, 0x01},
+	{IMX_8BIT, 0x3800, 0x00},
+	{IMX_TOK_TERM, 0, 0},
+};
+
+/* Preview3: H : 1280 V : 720 */
+static struct imx_reg const imx135_PREVIEW_WIDE_PREVIEW_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0C},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x01},
+	{ IMX_8BIT, 0x030C, 0x02},
+	{ IMX_8BIT, 0x030D, 0x32},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x11},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x1A },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07 },
+	{IMX_8BIT, 0x0341, 0xA8 },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xDC },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x18 },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x88 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x57 },
+	{IMX_8BIT, 0x034A, 0x0A },
+	{IMX_8BIT, 0x034B, 0xAB },
+	{IMX_8BIT, 0x034C, 0x05 },
+	{IMX_8BIT, 0x034D, 0x00 },
+	{IMX_8BIT, 0x034E, 0x02 },
+	{IMX_8BIT, 0x034F, 0xD0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x20 },
+	{IMX_8BIT, 0x0356, 0x04 },
+	{IMX_8BIT, 0x0357, 0x92 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x05 },
+	{IMX_8BIT, 0x3311, 0x00 },
+	{IMX_8BIT, 0x3312, 0x02 },
+	{IMX_8BIT, 0x3313, 0xD0 },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0x18 },
+	{IMX_8BIT, 0x4084, 0x05 },
+	{IMX_8BIT, 0x4085, 0x00 },
+	{IMX_8BIT, 0x4086, 0x02 },
+	{IMX_8BIT, 0x4087, 0xD0 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Preview4: H : 1632 V : 1224 */
+static struct imx_reg const imx135_PREVIEW_1632x1224_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{ IMX_8BIT, 0x011E, 0x13},
+	{ IMX_8BIT, 0x011F, 0x33},
+	{ IMX_8BIT, 0x0301, 0x05},
+	{ IMX_8BIT, 0x0303, 0x01},
+	{ IMX_8BIT, 0x0305, 0x0B},
+	{ IMX_8BIT, 0x0309, 0x05},
+	{ IMX_8BIT, 0x030B, 0x02},
+	{ IMX_8BIT, 0x030C, 0x01},
+	{ IMX_8BIT, 0x030D, 0x83},
+	{ IMX_8BIT, 0x030E, 0x01},
+	{ IMX_8BIT, 0x3A06, 0x12},
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x08 },
+	{IMX_8BIT, 0x0341, 0xb8 },
+	{IMX_8BIT, 0x0342, 0x15 },
+	{IMX_8BIT, 0x0343, 0x18 },
+
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x40 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x20 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x2F },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x13 },
+
+	{IMX_8BIT, 0x034C, 0x06 },
+	{IMX_8BIT, 0x034D, 0x60 },
+	{IMX_8BIT, 0x034E, 0x04 },
+	{IMX_8BIT, 0x034F, 0xC8 },
+
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+
+	{IMX_8BIT, 0x0354, 0x07 },
+	{IMX_8BIT, 0x0355, 0xF8 },
+	{IMX_8BIT, 0x0356, 0x05 },
+	{IMX_8BIT, 0x0357, 0xFA },
+
+	{IMX_8BIT, 0x301D, 0x30 },
+
+	{IMX_8BIT, 0x3310, 0x06 },
+	{IMX_8BIT, 0x3311, 0x60 },
+	{IMX_8BIT, 0x3312, 0x04 },
+	{IMX_8BIT, 0x3313, 0xC8 },
+
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0x9A },
+	{IMX_8BIT, 0x4084, 0x06 },
+	{IMX_8BIT, 0x4085, 0x60 },
+	{IMX_8BIT, 0x4086, 0x04 },
+	{IMX_8BIT, 0x4087, 0xC8 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x0C },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	/* Gain Setting */
+	{ IMX_8BIT, 0x0205, 0x00},
+	{ IMX_8BIT, 0x020E, 0x01},
+	{ IMX_8BIT, 0x020F, 0x00},
+	{ IMX_8BIT, 0x0210, 0x02},
+	{ IMX_8BIT, 0x0211, 0x00},
+	{ IMX_8BIT, 0x0212, 0x02},
+	{ IMX_8BIT, 0x0213, 0x00},
+	{ IMX_8BIT, 0x0214, 0x01},
+	{ IMX_8BIT, 0x0215, 0x00},
+	{IMX_TOK_TERM, 0, 0}
+};
+
+
+/***************** IMX135 VIDEO ***************************************/
+
+/* Video1: H : 216 V : 176 */
+static const struct imx_reg imx135_QCIF_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x46 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07 },
+	{IMX_8BIT, 0x0341, 0xA8 },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xDC },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0xD4 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x0F },
+	{IMX_8BIT, 0x0349, 0x9B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x00 },
+	{IMX_8BIT, 0x034D, 0xD8 },
+	{IMX_8BIT, 0x034E, 0x00 },
+	{IMX_8BIT, 0x034F, 0xB0 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 },
+	{IMX_8BIT, 0x0355, 0xB2 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x00 },
+	{IMX_8BIT, 0x3311, 0xD8 },
+	{IMX_8BIT, 0x3312, 0x00 },
+	{IMX_8BIT, 0x3313, 0xB0 },
+	{IMX_8BIT, 0x331C, 0x00 },
+	{IMX_8BIT, 0x331D, 0xD4 },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0xD8 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0xB0 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Video2: H : 408 V : 308 */
+static const struct imx_reg imx135_QVGA_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x28 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07 },
+	{IMX_8BIT, 0x0341, 0xA8 },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xDC },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x40 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x2F },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x01 },
+	{IMX_8BIT, 0x034D, 0x98 },
+	{IMX_8BIT, 0x034E, 0x01 },
+	{IMX_8BIT, 0x034F, 0x34 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x03 },
+	{IMX_8BIT, 0x0355, 0xFC },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x01 },
+	{IMX_8BIT, 0x3311, 0x98 },
+	{IMX_8BIT, 0x3312, 0x01 },
+	{IMX_8BIT, 0x3313, 0x34 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0x68 },
+	{IMX_8BIT, 0x4084, 0x01 },
+	{IMX_8BIT, 0x4085, 0x98 },
+	{IMX_8BIT, 0x4086, 0x01 },
+	{IMX_8BIT, 0x4087, 0x34 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Video3: H : 820 V : 616 */
+static const struct imx_reg imx135_VGA_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x44 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07 },
+	{IMX_8BIT, 0x0341, 0xA8 },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xDC },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x34 },
+	{IMX_8BIT, 0x0346, 0x00 },
+	{IMX_8BIT, 0x0347, 0x14 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x3B },
+	{IMX_8BIT, 0x034A, 0x0C },
+	{IMX_8BIT, 0x034B, 0x1B },
+	{IMX_8BIT, 0x034C, 0x03 },
+	{IMX_8BIT, 0x034D, 0x34 },
+	{IMX_8BIT, 0x034E, 0x02 },
+	{IMX_8BIT, 0x034F, 0x68 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x04 },
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x03 },
+	{IMX_8BIT, 0x0357, 0x02 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x03 },
+	{IMX_8BIT, 0x3311, 0x34 },
+	{IMX_8BIT, 0x3312, 0x02 },
+	{IMX_8BIT, 0x3313, 0x68 },
+	{IMX_8BIT, 0x331C, 0x02 },
+	{IMX_8BIT, 0x331D, 0x21 },
+	{IMX_8BIT, 0x4084, 0x03 },
+	{IMX_8BIT, 0x4085, 0x34 },
+	{IMX_8BIT, 0x4086, 0x02 },
+	{IMX_8BIT, 0x4087, 0x68 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Video4: H : 1640 V : 1024 */
+static const struct imx_reg imx135_WVGA_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x14 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07 },
+	{IMX_8BIT, 0x0341, 0xA8 },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xDC },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x36 },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x18 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x39 },
+	{IMX_8BIT, 0x034A, 0x0B },
+	{IMX_8BIT, 0x034B, 0x17 },
+	{IMX_8BIT, 0x034C, 0x06 },
+	{IMX_8BIT, 0x034D, 0x68 },
+	{IMX_8BIT, 0x034E, 0x04 },
+	{IMX_8BIT, 0x034F, 0x00 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x02 },
+	{IMX_8BIT, 0x0356, 0x05 },
+	{IMX_8BIT, 0x0357, 0x00 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x06 },
+	{IMX_8BIT, 0x3311, 0x68 },
+	{IMX_8BIT, 0x3312, 0x04 },
+	{IMX_8BIT, 0x3313, 0x00 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0xBD },
+	{IMX_8BIT, 0x4084, 0x06 },
+	{IMX_8BIT, 0x4085, 0x68 },
+	{IMX_8BIT, 0x4086, 0x04 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Video5: H : 1568 V : 880 */
+static const struct imx_reg imx135_720p_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x01 },
+	{IMX_8BIT, 0x0391, 0x22 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x02 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x15 },
+	{IMX_8BIT, 0x4082, 0x00 },
+	{IMX_8BIT, 0x4083, 0x00 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07 },
+	{IMX_8BIT, 0x0341, 0xA8 },
+	{IMX_8BIT, 0x0342, 0x11 },
+	{IMX_8BIT, 0x0343, 0xDC },
+	{IMX_8BIT, 0x0344, 0x00 },
+	{IMX_8BIT, 0x0345, 0x2E },
+	{IMX_8BIT, 0x0346, 0x01 },
+	{IMX_8BIT, 0x0347, 0x94 },
+	{IMX_8BIT, 0x0348, 0x10 },
+	{IMX_8BIT, 0x0349, 0x41 },
+	{IMX_8BIT, 0x034A, 0x0A },
+	{IMX_8BIT, 0x034B, 0x9B },
+	{IMX_8BIT, 0x034C, 0x06 },
+	{IMX_8BIT, 0x034D, 0x20 },
+	{IMX_8BIT, 0x034E, 0x03 },
+	{IMX_8BIT, 0x034F, 0x70 },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x08 },
+	{IMX_8BIT, 0x0355, 0x0A },
+	{IMX_8BIT, 0x0356, 0x04 },
+	{IMX_8BIT, 0x0357, 0x84 },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x06 },
+	{IMX_8BIT, 0x3311, 0x20 },
+	{IMX_8BIT, 0x3312, 0x03 },
+	{IMX_8BIT, 0x3313, 0x70 },
+	{IMX_8BIT, 0x331C, 0x01 },
+	{IMX_8BIT, 0x331D, 0xD6 },
+	{IMX_8BIT, 0x4084, 0x06 },
+	{IMX_8BIT, 0x4085, 0x20 },
+	{IMX_8BIT, 0x4086, 0x03 },
+	{IMX_8BIT, 0x4087, 0x70 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x5F },
+	{IMX_8BIT, 0x0831, 0x1F },
+	{IMX_8BIT, 0x0832, 0x3F },
+	{IMX_8BIT, 0x0833, 0x1F },
+	{IMX_8BIT, 0x0834, 0x1F },
+	{IMX_8BIT, 0x0835, 0x17 },
+	{IMX_8BIT, 0x0836, 0x67 },
+	{IMX_8BIT, 0x0837, 0x27 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+/* Video6: H : 2336V : 1308 */
+static const struct imx_reg imx135_1080p_strong_dvs_30fps[] = {
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Mode setting */
+	{IMX_8BIT, 0x0108, 0x03 },
+	{IMX_8BIT, 0x0112, 0x0A },
+	{IMX_8BIT, 0x0113, 0x0A },
+	{IMX_8BIT, 0x0381, 0x01 },
+	{IMX_8BIT, 0x0383, 0x01 },
+	{IMX_8BIT, 0x0385, 0x01 },
+	{IMX_8BIT, 0x0387, 0x01 },
+	{IMX_8BIT, 0x0390, 0x00 },
+	{IMX_8BIT, 0x0391, 0x11 },
+	{IMX_8BIT, 0x0392, 0x00 },
+	{IMX_8BIT, 0x0401, 0x00 },
+	{IMX_8BIT, 0x0404, 0x00 },
+	{IMX_8BIT, 0x0405, 0x10 },
+	{IMX_8BIT, 0x4082, 0x01 },
+	{IMX_8BIT, 0x4083, 0x01 },
+	{IMX_8BIT, 0x7006, 0x04 },
+	/* Size setting */
+	{IMX_8BIT, 0x0340, 0x07 },
+	{IMX_8BIT, 0x0341, 0xA8 },
+	{IMX_8BIT, 0x0342, 0x27 },
+	{IMX_8BIT, 0x0343, 0x10 },
+	{IMX_8BIT, 0x0344, 0x03 },
+	{IMX_8BIT, 0x0345, 0xA8 },
+	{IMX_8BIT, 0x0346, 0x03 },
+	{IMX_8BIT, 0x0347, 0x8C },
+	{IMX_8BIT, 0x0348, 0x0C },
+	{IMX_8BIT, 0x0349, 0xC7 },
+	{IMX_8BIT, 0x034A, 0x08 },
+	{IMX_8BIT, 0x034B, 0xA7 },
+	{IMX_8BIT, 0x034C, 0x09 },
+	{IMX_8BIT, 0x034D, 0x20 },
+	{IMX_8BIT, 0x034E, 0x05 },
+	{IMX_8BIT, 0x034F, 0x1C },
+	{IMX_8BIT, 0x0350, 0x00 },
+	{IMX_8BIT, 0x0351, 0x00 },
+	{IMX_8BIT, 0x0352, 0x00 },
+	{IMX_8BIT, 0x0353, 0x00 },
+	{IMX_8BIT, 0x0354, 0x09 },
+	{IMX_8BIT, 0x0355, 0x20 },
+	{IMX_8BIT, 0x0356, 0x05 },
+	{IMX_8BIT, 0x0357, 0x1C },
+	{IMX_8BIT, 0x301D, 0x30 },
+	{IMX_8BIT, 0x3310, 0x09 },
+	{IMX_8BIT, 0x3311, 0x20 },
+	{IMX_8BIT, 0x3312, 0x05 },
+	{IMX_8BIT, 0x3313, 0x1C },
+	{IMX_8BIT, 0x331C, 0x00 },
+	{IMX_8BIT, 0x331D, 0xB4 },
+	{IMX_8BIT, 0x4084, 0x00 },
+	{IMX_8BIT, 0x4085, 0x00 },
+	{IMX_8BIT, 0x4086, 0x00 },
+	{IMX_8BIT, 0x4087, 0x00 },
+	{IMX_8BIT, 0x4400, 0x00 },
+	/* Global Timing Setting */
+	{IMX_8BIT, 0x0830, 0x77 },
+	{IMX_8BIT, 0x0831, 0x2F },
+	{IMX_8BIT, 0x0832, 0x4F },
+	{IMX_8BIT, 0x0833, 0x2F },
+	{IMX_8BIT, 0x0834, 0x2F },
+	{IMX_8BIT, 0x0835, 0x37 },
+	{IMX_8BIT, 0x0836, 0xA7 },
+	{IMX_8BIT, 0x0837, 0x37 },
+	{IMX_8BIT, 0x0839, 0x1F },
+	{IMX_8BIT, 0x083A, 0x17 },
+	{IMX_8BIT, 0x083B, 0x02 },
+	/* Integration Time Setting */
+	{IMX_8BIT, 0x0202, 0x07 },
+	{IMX_8BIT, 0x0203, 0xA4 },
+	{IMX_TOK_TERM, 0, 0}
+};
+
+static const struct imx_reg imx135_2336x1320_30fps[] = {
+	/* Video */
+	/* H : 2336 */
+	/* V : 1320 */
+	/* clock setting */
+	{ IMX_8BIT, 0x011E, 0x13 },
+	{ IMX_8BIT, 0x011F, 0x33 },
+	{ IMX_8BIT, 0x0301, 0x05 },
+	{ IMX_8BIT, 0x0303, 0x01 },
+	{ IMX_8BIT, 0x0305, 0x0B },
+	{ IMX_8BIT, 0x0309, 0x05 },
+	{ IMX_8BIT, 0x030B, 0x01 },
+	{ IMX_8BIT, 0x030C, 0x01 },
+	{ IMX_8BIT, 0x030D, 0x91 },
+	{ IMX_8BIT, 0x030E, 0x01 },
+	{ IMX_8BIT, 0x3A06, 0x11 },
+	/* mode setting */
+	{ IMX_8BIT, 0x0108, 0x03 },
+	{ IMX_8BIT, 0x0112, 0x0A },
+	{ IMX_8BIT, 0x0113, 0x0A },
+	{ IMX_8BIT, 0x0381, 0x01 },
+	{ IMX_8BIT, 0x0383, 0x01 },
+	{ IMX_8BIT, 0x0385, 0x01 },
+	{ IMX_8BIT, 0x0387, 0x01 },
+	{ IMX_8BIT, 0x0390, 0x00 },
+	{ IMX_8BIT, 0x0391, 0x11 },
+	{ IMX_8BIT, 0x0392, 0x00 },
+	{ IMX_8BIT, 0x0401, 0x02 },
+	{ IMX_8BIT, 0x0404, 0x00 },
+	{ IMX_8BIT, 0x0405, 0x1C },
+	{ IMX_8BIT, 0x4082, 0x00 },
+	{ IMX_8BIT, 0x4083, 0x00 },
+	{ IMX_8BIT, 0x7006, 0x04 },
+	/* function setting */
+	{ IMX_8BIT, 0x0700, 0x00 },
+	{ IMX_8BIT, 0x3A63, 0x00 },
+	{ IMX_8BIT, 0x4100, 0xF8 },
+	{ IMX_8BIT, 0x4203, 0xFF },
+	{ IMX_8BIT, 0x4344, 0x00 },
+	{ IMX_8BIT, 0x441C, 0x01 },
+	/* size setting */
+	{ IMX_8BIT, 0x0340, 0x09 },
+	{ IMX_8BIT, 0x0341, 0x1E },
+	{ IMX_8BIT, 0x0342, 0x11 },
+	{ IMX_8BIT, 0x0343, 0xDC },
+	{ IMX_8BIT, 0x0344, 0x00 },
+	{ IMX_8BIT, 0x0345, 0x3C },
+	{ IMX_8BIT, 0x0346, 0x01 },
+	{ IMX_8BIT, 0x0347, 0x94 },
+	{ IMX_8BIT, 0x0348, 0x10 },
+	{ IMX_8BIT, 0x0349, 0x33 },
+	{ IMX_8BIT, 0x034A, 0x0A },
+	{ IMX_8BIT, 0x034B, 0x9B },
+	{ IMX_8BIT, 0x034C, 0x09 },
+	{ IMX_8BIT, 0x034D, 0x20 },
+	{ IMX_8BIT, 0x034E, 0x05 },
+	{ IMX_8BIT, 0x034F, 0x28 },
+	{ IMX_8BIT, 0x0350, 0x00 },
+	{ IMX_8BIT, 0x0351, 0x00 },
+	{ IMX_8BIT, 0x0352, 0x00 },
+	{ IMX_8BIT, 0x0353, 0x00 },
+	{ IMX_8BIT, 0x0354, 0x0F },
+	{ IMX_8BIT, 0x0355, 0xF8 },
+	{ IMX_8BIT, 0x0356, 0x09 },
+	{ IMX_8BIT, 0x0357, 0x06 },
+	{ IMX_8BIT, 0x301D, 0x30 },
+	{ IMX_8BIT, 0x3310, 0x09 },
+	{ IMX_8BIT, 0x3311, 0x20 },
+	{ IMX_8BIT, 0x3312, 0x05 },
+	{ IMX_8BIT, 0x3313, 0x28 },
+	{ IMX_8BIT, 0x331C, 0x04 },
+	{ IMX_8BIT, 0x331D, 0xE2 },
+	{ IMX_8BIT, 0x4084, 0x09 },
+	{ IMX_8BIT, 0x4085, 0x20 },
+	{ IMX_8BIT, 0x4086, 0x05 },
+	{ IMX_8BIT, 0x4087, 0x28 },
+	{ IMX_8BIT, 0x4400, 0x00 },
+	/* global timing setting */
+	{ IMX_8BIT, 0x0830, 0x77 },
+	/* { IMX_8BIT, { 0x0831 }, 0x2F }, */
+	{ IMX_8BIT, 0x0831, 0x19 },
+	{ IMX_8BIT, 0x0832, 0x4F },
+	{ IMX_8BIT, 0x0833, 0x37 },
+	{ IMX_8BIT, 0x0834, 0x2F },
+	{ IMX_8BIT, 0x0835, 0x37 },
+	{ IMX_8BIT, 0x0836, 0xAF },
+	{ IMX_8BIT, 0x0837, 0x37 },
+	{ IMX_8BIT, 0x0839, 0x1F },
+	{ IMX_8BIT, 0x083A, 0x17 },
+	{ IMX_8BIT, 0x083B, 0x02 },
+	/* integration timing setting */
+	{ IMX_8BIT, 0x0202, 0x09 },
+	{ IMX_8BIT, 0x0203, 0x1A },
+	/* gain setting */
+	{ IMX_8BIT, 0x0205, 0x00 },
+	{ IMX_8BIT, 0x020E, 0x01 },
+	{ IMX_8BIT, 0x020F, 0x00 },
+	{ IMX_8BIT, 0x0210, 0x01 },
+	{ IMX_8BIT, 0x0211, 0x00 },
+	{ IMX_8BIT, 0x0212, 0x01 },
+	{ IMX_8BIT, 0x0213, 0x00 },
+	{ IMX_8BIT, 0x0214, 0x01 },
+	{ IMX_8BIT, 0x0215, 0x00 },
+	/* HDR setting */
+	{ IMX_8BIT, 0x0230, 0x00 },
+	{ IMX_8BIT, 0x0231, 0x00 },
+	{ IMX_8BIT, 0x0233, 0x00 },
+	{ IMX_8BIT, 0x0234, 0x00 },
+	{ IMX_8BIT, 0x0235, 0x40 },
+	{ IMX_8BIT, 0x0238, 0x00 },
+	{ IMX_8BIT, 0x0239, 0x04 },
+	{ IMX_8BIT, 0x023B, 0x00 },
+	{ IMX_8BIT, 0x023C, 0x01 },
+	{ IMX_8BIT, 0x33B0, 0x04 },
+	{ IMX_8BIT, 0x33B1, 0x00 },
+	{ IMX_8BIT, 0x33B3, 0x00 },
+	{ IMX_8BIT, 0x33B4, 0x01 },
+	{ IMX_8BIT, 0x3800, 0x00 },
+
+	{ IMX_TOK_TERM, 0, 0}
+};
+
+struct imx_resolution imx_res_preview[] = {
+
+	{
+		.desc = "imx135_PREVIEW_848x616_30fps",
+		.regs = imx135_PREVIEW_848x616_30fps,
+		.width = 848,
+		.height = 616,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 1960,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_PREVIEW_WIDE_PREVIEW_30fps",
+		.regs = imx135_PREVIEW_WIDE_PREVIEW_30fps,
+		.width = 1280,
+		.height = 720,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 1960,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_720p_30fps",
+		.regs = imx135_720p_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 2650,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1M_16_9_30fps",
+		.regs = imx135_1M_16_9_30fps,
+		.width = 1040,
+		.height = 592,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 2650,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1M_4_3_30fps",
+		.regs = imx135_1M_4_3_30fps,
+		.width = 1640,
+		.height = 1232,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 2650,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1080p_30fps",
+		.regs = imx135_1080p_30fps,
+		.width = 1936,
+		.height = 1104,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 2650,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_PREVIEW_1632x1224_30fps",
+		.regs = imx135_PREVIEW_1632x1224_30fps,
+		.width = 1632,
+		.height = 1224,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 1960,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_2M_30fps",
+		.regs = imx135_2M_30fps,
+		.width = 1640,
+		.height = 1232,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_5M_19fps",
+		.regs = imx135_5M_STILL_19fps,
+		.width = 2576,
+		.height = 1936,
+		.fps = 19,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 3050, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_6M_STILL_20fps",
+		.regs = imx135_6M_STILL_20fps,
+		.width = 3280,
+		.height = 1852,
+		.fps = 20,
+		.pixels_per_line = 4696, /* consistent with regs arrays */
+		.lines_per_frame = 2318, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_8M_15fps",
+		.regs = imx135_8M_STILL_15fps,
+		.width = 3280,
+		.height = 2464,
+		.fps = 15,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2620, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_13M_24fps",
+		.regs = imx135_13M_24fps,
+		.width = 4208,
+		.height = 3120,
+		.fps = 24,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 3310,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+struct imx_resolution imx_res_still[] = {
+	{
+		.desc = "imx135_QCIF_30fps",
+		.regs = imx135_QCIF_30fps,
+		.width = 192,
+		.height = 160,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_QVGA_30fps",
+		.regs = imx135_QVGA_30fps,
+		.width = 336,
+		.height = 256,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_CIF_30fps",
+		.regs = imx135_CIF_30fps,
+		.width = 368,
+		.height = 304,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_VGA_30fps",
+		.regs = imx135_VGA_30fps,
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_D1_30fps",
+		.regs = imx135_D1_30fps,
+		.width = 736,
+		.height = 496,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_VGA_dvs_30fps",
+		.regs = imx135_VGA_dvs_30fps,
+		.width = 820,
+		.height = 616,
+		.fps = 30,
+		.pixels_per_line = 4572,
+		.lines_per_frame = 2650,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1M_16_9_30fps",
+		.regs = imx135_1M_16_9_30fps,
+		.width = 1040,
+		.height = 592,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1M_4_3_30fps",
+		.regs = imx135_1M_4_3_30fps,
+		.width = 1040,
+		.height = 784,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_720p_30fps",
+		.regs = imx135_720p_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1600x1200_30fps",
+		.regs = imx135_1600x1200_30fps,
+		.width = 1632,
+		.height = 1224,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1080p_30fps",
+		.regs = imx135_1080p_30fps,
+		.width = 1936,
+		.height = 1104,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_3M_30fps",
+		.regs = imx135_3M_30fps,
+		.width = 2064,
+		.height = 1552,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_5M_26fps",
+		.regs = imx135_5M_STILL_19fps,
+		.width = 2576	,
+		.height = 1936,
+		.fps = 26,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 3050, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_6M_STILL_20fps",
+		.regs = imx135_6M_STILL_20fps,
+		.width = 3280,
+		.height = 1852,
+		.fps = 20,
+		.pixels_per_line = 4696, /* consistent with regs arrays */
+		.lines_per_frame = 2318, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_8M_3fps",
+		.regs = imx135_8M_3fps,
+		.width = 3280,
+		.height = 2464,
+		.fps = 3,
+		.pixels_per_line = 10000, /* consistent with regs arrays */
+		.lines_per_frame = 2620, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_13M_3fps",
+		.regs = imx135_13M_3fps,
+		.width = 4208,
+		.height = 3120,
+		.fps = 3,
+		.pixels_per_line = 0x3000,
+		.lines_per_frame = 0x2000,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+struct imx_resolution imx_res_video[] = {
+	{
+		.desc = "imx135_2336x1320_30fps",
+		.regs = imx135_2336x1320_30fps,
+		.width = 2336,
+		.height = 1320,
+		.fps = 26,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2334, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+	},
+};
+
+struct imx_resolution imx_res_video_nodvs[] = {
+	{
+		.desc = "imx135_QCIF_30fps",
+		.regs = imx135_QCIF_30fps,
+		.width = 192,
+		.height = 160,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_QVGA_30fps",
+		.regs = imx135_QVGA_30fps,
+		.width = 336,
+		.height = 256,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_CIF_30fps",
+		.regs = imx135_CIF_30fps,
+		.width = 368,
+		.height = 304,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_VGA_30fps",
+		.regs = imx135_VGA_30fps,
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_D1_30fps",
+		.regs = imx135_D1_30fps,
+		.width = 736,
+		.height = 496,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_720p_30fps",
+		.regs = imx135_720p_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+	{
+		.desc = "imx135_1080p_30fps",
+		.regs = imx135_1080p_30fps,
+		.width = 1936,
+		.height = 1104,
+		.fps = 30,
+		.pixels_per_line = 4572, /* consistent with regs arrays */
+		.lines_per_frame = 2650, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+	},
+};
+
+#define N_RES_PREVIEW (ARRAY_SIZE(imx_res_preview))
+#define N_RES_STILL (ARRAY_SIZE(imx_res_still))
+#define N_RES_VIDEO (ARRAY_SIZE(imx_res_video))
+
+struct imx_resolution *imx_res = imx_res_preview;
+static int N_RES = N_RES_PREVIEW;
+
+
+#endif
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/libmsrlisthelper.c b/drivers/external_drivers/camera/drivers/media/i2c/libmsrlisthelper.c
new file mode 100644
index 0000000..e04cefd
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/libmsrlisthelper.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/i2c.h>
+#include <linux/firmware.h>
+#include <linux/device.h>
+#include <linux/export.h>
+#include <linux/libmsrlisthelper.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+/* Tagged binary data container structure definitions. */
+struct tbd_header {
+	uint32_t tag;          /*!< Tag identifier, also checks endianness */
+	uint32_t size;         /*!< Container size including this header */
+	uint32_t version;      /*!< Version, format 0xYYMMDDVV */
+	uint32_t revision;     /*!< Revision, format 0xYYMMDDVV */
+	uint32_t config_bits;  /*!< Configuration flag bits set */
+	uint32_t checksum;     /*!< Global checksum, header included */
+} __packed;
+
+struct tbd_record_header {
+	uint32_t size;        /*!< Size of record including header */
+	uint8_t format_id;    /*!< tbd_format_t enumeration values used */
+	uint8_t packing_key;  /*!< Packing method; 0 = no packing */
+	uint16_t class_id;    /*!< tbd_class_t enumeration values used */
+} __packed;
+
+struct tbd_data_record_header {
+	uint16_t next_offset;
+	uint16_t flags;
+	uint16_t data_offset;
+	uint16_t data_size;
+} __packed;
+
+#define TBD_CLASS_DRV_ID 2
+
+static int set_msr_configuration(struct i2c_client *client, uint8_t *bufptr,
+		unsigned int size)
+{
+	/* The configuration data contains any number of sequences where
+	 * the first byte (that is, uint8_t) that marks the number of bytes
+	 * in the sequence to follow, is indeed followed by the indicated
+	 * number of bytes of actual data to be written to sensor.
+	 * By convention, the first two bytes of actual data should be
+	 * understood as an address in the sensor address space (hibyte
+	 * followed by lobyte) where the remaining data in the sequence
+	 * will be written. */
+
+	uint8_t *ptr = bufptr;
+	while (ptr < bufptr + size) {
+		struct i2c_msg msg = {
+			.addr = client->addr,
+			.flags = 0,
+		};
+		int ret;
+
+		/* How many bytes */
+		msg.len = *ptr++;
+		/* Where the bytes are located */
+		msg.buf = ptr;
+		ptr += msg.len;
+
+		if (ptr > bufptr + size)
+			/* Accessing data beyond bounds is not tolerated */
+			return -EINVAL;
+
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret < 0) {
+			dev_err(&client->dev, "i2c write error: %d", ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int parse_and_apply(struct i2c_client *client, uint8_t *buffer,
+		unsigned int size)
+{
+	uint8_t *endptr8 = buffer + size;
+	struct tbd_data_record_header *header =
+		(struct tbd_data_record_header *)buffer;
+
+	/* There may be any number of datasets present */
+	unsigned int dataset = 0;
+
+	do {
+		/* In below, four variables are read from buffer */
+		if ((uint8_t *)header + sizeof(*header) > endptr8)
+			return -EINVAL;
+
+		/* All data should be located within given buffer */
+		if ((uint8_t *)header + header->data_offset +
+				header->data_size > endptr8)
+			return -EINVAL;
+
+		/* We have a new valid dataset */
+		dataset++;
+		/* See whether there is MSR data */
+		/* If yes, update the reg info */
+		if (header->data_size && (header->flags & 1)) {
+			int ret;
+
+			dev_info(&client->dev,
+				"New MSR data for sensor driver (dataset %02d) size:%d\n",
+				dataset, header->data_size);
+			ret = set_msr_configuration(client,
+						buffer + header->data_offset,
+						header->data_size);
+			if (ret)
+				return ret;
+		}
+		header = (struct tbd_data_record_header *)(buffer +
+			header->next_offset);
+	} while (header->next_offset);
+
+	return 0;
+}
+
+int apply_msr_data(struct i2c_client *client, const struct firmware *fw)
+{
+	struct tbd_header *header;
+	struct tbd_record_header *record;
+
+	if (!fw) {
+		dev_warn(&client->dev, "Drv data is not loaded.\n");
+		return -EINVAL;
+	}
+
+	if (sizeof(*header) > fw->size)
+		return -EINVAL;
+
+	header = (struct tbd_header *)fw->data;
+	/* Check that we have drvb block. */
+	if (memcmp(&header->tag, "DRVB", 4))
+		return -EINVAL;
+
+	/* Check the size */
+	if (header->size != fw->size)
+		return -EINVAL;
+
+	if (sizeof(*header) + sizeof(*record) > fw->size)
+		return -EINVAL;
+
+	record = (struct tbd_record_header *)(header + 1);
+	/* Check that class id mathes tbd's drv id. */
+	if (record->class_id != TBD_CLASS_DRV_ID)
+		return -EINVAL;
+
+	/* Size 0 shall not be treated as an error */
+	if (!record->size)
+		return 0;
+
+	return parse_and_apply(client, (uint8_t *)(record + 1), record->size);
+}
+EXPORT_SYMBOL_GPL(apply_msr_data);
+
+int load_msr_list(struct i2c_client *client, char *name,
+		const struct firmware **fw)
+{
+	int ret = request_firmware(fw, name, &client->dev);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error %d while requesting firmware %s\n",
+			ret, name);
+		return ret;
+	}
+	dev_info(&client->dev, "Received %lu bytes drv data\n",
+			(unsigned long)(*fw)->size);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(load_msr_list);
+
+void release_msr_list(struct i2c_client *client, const struct firmware *fw)
+{
+	release_firmware(fw);
+}
+EXPORT_SYMBOL_GPL(release_msr_list);
+
+static int init_msrlisthelper(void)
+{
+	return 0;
+}
+
+static void exit_msrlisthelper(void)
+{
+}
+
+module_init(init_msrlisthelper);
+module_exit(exit_msrlisthelper);
+
+MODULE_AUTHOR("Jukka Kaartinen <jukka.o.kaartinen@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
new file mode 100644
index 0000000..f06d064
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3554.c
@@ -0,0 +1,916 @@
+/*
+ * LED flash driver for LM3554
+ *
+ * Copyright (c) 2010-2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <media/lm3554.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+
+#include <linux/atomisp.h>
+
+struct lm3554_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl) (struct v4l2_subdev *sd, __u32 val);
+	int (*g_ctrl) (struct v4l2_subdev *sd, __s32 *val);
+};
+
+/* Registers */
+
+#define LM3554_TORCH_BRIGHTNESS_REG	0xA0
+#define LM3554_TORCH_MODE_SHIFT		0
+#define LM3554_TORCH_CURRENT_SHIFT	3
+#define LM3554_INDICATOR_CURRENT_SHIFT	6
+
+#define LM3554_FLASH_BRIGHTNESS_REG	0xB0
+#define LM3554_FLASH_MODE_SHIFT		0
+#define LM3554_FLASH_CURRENT_SHIFT	3
+#define LM3554_STROBE_SENSITIVITY_SHIFT	7
+
+#define LM3554_FLASH_DURATION_REG	0xC0
+#define LM3554_FLASH_TIMEOUT_SHIFT	0
+#define LM3554_CURRENT_LIMIT_SHIFT	5
+
+#define LM3554_FLAGS_REG		0xD0
+#define LM3554_FLAG_TIMEOUT		(1 << 0)
+#define LM3554_FLAG_THERMAL_SHUTDOWN	(1 << 1)
+#define LM3554_FLAG_LED_FAULT		(1 << 2)
+#define LM3554_FLAG_TX1_INTERRUPT	(1 << 3)
+#define LM3554_FLAG_TX2_INTERRUPT	(1 << 4)
+#define LM3554_FLAG_LED_THERMAL_FAULT	(1 << 5)
+#define LM3554_FLAG_UNUSED		(1 << 6)
+#define LM3554_FLAG_INPUT_VOLTAGE_LOW	(1 << 7)
+
+#define LM3554_CONFIG_REG_1		0xE0
+#define LM3554_ENVM_TX2_SHIFT		5
+#define LM3554_TX2_POLARITY_SHIFT	6
+
+struct lm3554 {
+	struct v4l2_subdev sd;
+
+	struct mutex power_lock;
+	int power_count;
+
+	unsigned int mode;
+	int timeout;
+	u8 torch_current;
+	u8 indicator_current;
+	u8 flash_current;
+
+	struct timer_list flash_off_delay;
+	struct lm3554_platform_data *pdata;
+};
+
+#define to_lm3554(p_sd)	container_of(p_sd, struct lm3554, sd)
+
+/* Return negative errno else zero on success */
+static int lm3554_write(struct lm3554 *flash, u8 addr, u8 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, addr, val);
+
+	dev_dbg(&client->dev, "Write Addr:%02X Val:%02X %s\n", addr, val,
+		ret < 0 ? "fail" : "ok");
+
+	return ret;
+}
+
+/* Return negative errno else a data byte received from the device. */
+static int lm3554_read(struct lm3554 *flash, u8 addr)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, addr);
+
+	dev_dbg(&client->dev, "Read Addr:%02X Val:%02X %s\n", addr, ret,
+		ret < 0 ? "fail" : "ok");
+
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * Hardware configuration
+ */
+
+static int lm3554_set_mode(struct lm3554 *flash, unsigned int mode)
+{
+	u8 val;
+	int ret;
+
+	val = (mode << LM3554_FLASH_MODE_SHIFT) |
+	      (flash->flash_current << LM3554_FLASH_CURRENT_SHIFT);
+
+	ret = lm3554_write(flash, LM3554_FLASH_BRIGHTNESS_REG, val);
+	if (ret == 0)
+		flash->mode = mode;
+	return ret;
+}
+
+static int lm3554_set_torch(struct lm3554 *flash)
+{
+	u8 val;
+
+	val = (flash->mode << LM3554_TORCH_MODE_SHIFT) |
+	      (flash->torch_current << LM3554_TORCH_CURRENT_SHIFT) |
+	      (flash->indicator_current << LM3554_INDICATOR_CURRENT_SHIFT);
+
+	return lm3554_write(flash, LM3554_TORCH_BRIGHTNESS_REG, val);
+}
+
+static int lm3554_set_flash(struct lm3554 *flash)
+{
+	u8 val;
+
+	val = (flash->mode << LM3554_FLASH_MODE_SHIFT) |
+	      (flash->flash_current << LM3554_FLASH_CURRENT_SHIFT);
+
+	return lm3554_write(flash, LM3554_FLASH_BRIGHTNESS_REG, val);
+}
+
+static int lm3554_set_duration(struct lm3554 *flash)
+{
+	u8 val;
+
+	val = (flash->timeout << LM3554_FLASH_TIMEOUT_SHIFT) |
+	      (flash->pdata->current_limit << LM3554_CURRENT_LIMIT_SHIFT);
+
+	return lm3554_write(flash, LM3554_FLASH_DURATION_REG, val);
+}
+
+static int lm3554_set_config1(struct lm3554 *flash)
+{
+	u8 val;
+
+	val = (flash->pdata->envm_tx2 << LM3554_ENVM_TX2_SHIFT) |
+	      (flash->pdata->tx2_polarity << LM3554_TX2_POLARITY_SHIFT);
+	return lm3554_write(flash, LM3554_CONFIG_REG_1, val);
+}
+
+/* -----------------------------------------------------------------------------
+ * Hardware reset and trigger
+ */
+
+static void lm3554_hw_reset(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3554 *flash = to_lm3554(sd);
+	struct lm3554_platform_data *pdata = flash->pdata;
+
+	gpio_set_value(pdata->gpio_reset, 0);
+	msleep(50);
+
+	gpio_set_value(pdata->gpio_reset, 1);
+	msleep(50);
+}
+
+static void lm3554_flash_off_delay(long unsigned int arg)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata((struct i2c_client *)arg);
+	struct lm3554 *flash = to_lm3554(sd);
+	struct lm3554_platform_data *pdata = flash->pdata;
+
+	gpio_set_value(pdata->gpio_strobe, 0);
+}
+
+static int lm3554_hw_strobe(struct i2c_client *client, bool strobe)
+{
+	int ret, timer_pending;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3554 *flash = to_lm3554(sd);
+	struct lm3554_platform_data *pdata = flash->pdata;
+
+	/*
+	 * An abnormal high flash current is observed when strobe off the
+	 * flash. Workaround here is firstly set flash current to lower level,
+	 * wait a short moment, and then strobe off the flash.
+	 */
+
+	timer_pending = del_timer_sync(&flash->flash_off_delay);
+
+	/* Flash off */
+	if (!strobe) {
+		/* set current to 70mA and wait a while */
+		ret = lm3554_write(flash, LM3554_FLASH_BRIGHTNESS_REG, 0);
+		if (ret < 0)
+			goto err;
+		mod_timer(&flash->flash_off_delay,
+			  jiffies + msecs_to_jiffies(LM3554_TIMER_DELAY));
+		return 0;
+	}
+
+	/* Flash on */
+
+	/*
+	 * If timer is killed before run, flash is not strobe off,
+	 * so must strobe off here
+	 */
+	if (timer_pending)
+		gpio_set_value(pdata->gpio_strobe, 0);
+
+	/* Restore flash current settings */
+	ret = lm3554_set_flash(flash);
+	if (ret < 0)
+		goto err;
+
+	/* Strobe on Flash */
+	gpio_set_value(pdata->gpio_strobe, 1);
+
+	return 0;
+err:
+	dev_err(&client->dev, "failed to %s flash strobe (%d)\n",
+		strobe ? "on" : "off", ret);
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 controls
+ */
+
+static int lm3554_read_status(struct lm3554 *flash)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+
+	/* NOTE: reading register clear fault status */
+	ret = lm3554_read(flash, LM3554_FLAGS_REG);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Accordingly to datasheet we read back '1' in bit 6.
+	 * Clear it first.
+	 */
+	ret &= ~LM3554_FLAG_UNUSED;
+
+	/*
+	 * Do not take TX1/TX2 signal as an error
+	 * because MSIC will not turn off flash, but turn to
+	 * torch mode according to gsm modem signal by hardware.
+	 */
+	ret &= ~(LM3554_FLAG_TX1_INTERRUPT | LM3554_FLAG_TX2_INTERRUPT);
+
+	if (ret > 0)
+		dev_dbg(&client->dev, "LM3554 flag status: %02x\n", ret);
+
+	return ret;
+}
+
+static int lm3554_s_flash_timeout(struct v4l2_subdev *sd, u32 val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	val = clamp(val, LM3554_MIN_TIMEOUT, LM3554_MAX_TIMEOUT);
+	val = val / LM3554_TIMEOUT_STEPSIZE - 1;
+
+	flash->timeout = val;
+
+	return lm3554_set_duration(flash);
+}
+
+static int lm3554_g_flash_timeout(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	*val = (u32)(flash->timeout + 1) * LM3554_TIMEOUT_STEPSIZE;
+
+	return 0;
+}
+
+static int lm3554_s_flash_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	intensity = LM3554_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3554_PERCENT_TO_VALUE(intensity, LM3554_FLASH_STEP);
+
+	flash->flash_current = intensity;
+
+	return lm3554_set_flash(flash);
+}
+
+static int lm3554_g_flash_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	*val = LM3554_VALUE_TO_PERCENT((u32)flash->flash_current,
+			LM3554_FLASH_STEP);
+
+	return 0;
+}
+
+static int lm3554_s_torch_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	intensity = LM3554_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3554_PERCENT_TO_VALUE(intensity, LM3554_TORCH_STEP);
+
+	flash->torch_current = intensity;
+
+	return lm3554_set_torch(flash);
+}
+
+static int lm3554_g_torch_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	*val = LM3554_VALUE_TO_PERCENT((u32)flash->torch_current,
+			LM3554_TORCH_STEP);
+
+	return 0;
+}
+
+static int lm3554_s_indicator_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	intensity = LM3554_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3554_PERCENT_TO_VALUE(intensity, LM3554_INDICATOR_STEP);
+
+	flash->indicator_current = intensity;
+
+	return lm3554_set_torch(flash);
+}
+
+static int lm3554_g_indicator_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+
+	*val = LM3554_VALUE_TO_PERCENT((u32)flash->indicator_current,
+			LM3554_INDICATOR_STEP);
+
+	return 0;
+}
+
+static int lm3554_s_flash_strobe(struct v4l2_subdev *sd, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return lm3554_hw_strobe(client, val);
+}
+
+static int lm3554_s_flash_mode(struct v4l2_subdev *sd, u32 new_mode)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+	unsigned int mode;
+
+	switch (new_mode) {
+	case ATOMISP_FLASH_MODE_OFF:
+		mode = LM3554_MODE_SHUTDOWN;
+		break;
+	case ATOMISP_FLASH_MODE_FLASH:
+		mode = LM3554_MODE_FLASH;
+		break;
+	case ATOMISP_FLASH_MODE_INDICATOR:
+		mode = LM3554_MODE_INDICATOR;
+		break;
+	case ATOMISP_FLASH_MODE_TORCH:
+		mode = LM3554_MODE_TORCH;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lm3554_set_mode(flash, mode);
+}
+
+static int lm3554_g_flash_mode(struct v4l2_subdev *sd, s32 * val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+	*val = flash->mode;
+	return 0;
+}
+
+static int lm3554_g_flash_status(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+	int value;
+
+	value = lm3554_read_status(flash);
+	if (value < 0)
+		return value;
+
+	if (value & LM3554_FLAG_TIMEOUT)
+		*val = ATOMISP_FLASH_STATUS_TIMEOUT;
+	else if (value > 0)
+		*val = ATOMISP_FLASH_STATUS_HW_ERROR;
+	else
+		*val = ATOMISP_FLASH_STATUS_OK;
+
+	return 0;
+}
+
+static int lm3554_g_flash_status_register(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+	int ret;
+
+	ret = lm3554_read(flash, LM3554_FLAGS_REG);
+
+	if (ret < 0)
+		return ret;
+
+	*val = ret;
+	return 0;
+}
+
+static const struct lm3554_ctrl_id lm3554_ctrls[] = {
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TIMEOUT,
+				"Flash Timeout",
+				0,
+				LM3554_MAX_TIMEOUT,
+				1,
+				LM3554_DEFAULT_TIMEOUT,
+				0,
+				lm3554_s_flash_timeout,
+				lm3554_g_flash_timeout),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_INTENSITY,
+				"Flash Intensity",
+				LM3554_MIN_PERCENT,
+				LM3554_MAX_PERCENT,
+				1,
+				LM3554_FLASH_DEFAULT_BRIGHTNESS,
+				0,
+				lm3554_s_flash_intensity,
+				lm3554_g_flash_intensity),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TORCH_INTENSITY,
+				"Torch Intensity",
+				LM3554_MIN_PERCENT,
+				LM3554_MAX_PERCENT,
+				1,
+				LM3554_TORCH_DEFAULT_BRIGHTNESS,
+				0,
+				lm3554_s_torch_intensity,
+				lm3554_g_torch_intensity),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_INDICATOR_INTENSITY,
+				"Indicator Intensity",
+				LM3554_MIN_PERCENT,
+				LM3554_MAX_PERCENT,
+				1,
+				LM3554_INDICATOR_DEFAULT_BRIGHTNESS,
+				0,
+				lm3554_s_indicator_intensity,
+				lm3554_g_indicator_intensity),
+	s_ctrl_id_entry_boolean(V4L2_CID_FLASH_STROBE,
+				"Flash Strobe",
+				0,
+				0,
+				lm3554_s_flash_strobe,
+				NULL),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_MODE,
+				"Flash Mode",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				ATOMISP_FLASH_MODE_OFF,
+				0,
+				lm3554_s_flash_mode,
+				lm3554_g_flash_mode),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_STATUS,
+				"Flash Status",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				ATOMISP_FLASH_STATUS_OK,
+				0,
+				NULL,
+				lm3554_g_flash_status),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_STATUS_REGISTER,
+				"Flash Status Register",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				0,
+				0,
+				NULL,
+				lm3554_g_flash_status_register),
+};
+
+static const struct lm3554_ctrl_id *find_ctrl_id(unsigned int id)
+{
+	int i;
+	int num;
+
+	num = ARRAY_SIZE(lm3554_ctrls);
+	for (i = 0; i < num; i++) {
+		if (lm3554_ctrls[i].qc.id == id)
+			return &lm3554_ctrls[i];
+	}
+
+	return NULL;
+}
+
+static int lm3554_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	int num;
+
+	if (!qc)
+		return -EINVAL;
+
+	num = ARRAY_SIZE(lm3554_ctrls);
+	if (qc->id >= num)
+		return -EINVAL;
+
+	*qc = lm3554_ctrls[qc->id].qc;
+
+	return 0;
+}
+
+static int lm3554_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	const struct lm3554_ctrl_id *s_ctrl;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = find_ctrl_id(ctrl->id);
+	if (!s_ctrl)
+		return -EINVAL;
+
+	return s_ctrl->s_ctrl(sd, ctrl->value);
+}
+
+static int lm3554_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	const struct lm3554_ctrl_id *s_ctrl;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = find_ctrl_id(ctrl->id);
+	if (s_ctrl == NULL)
+		return -EINVAL;
+
+	return s_ctrl->g_ctrl(sd, &ctrl->value);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 subdev core operations
+ */
+
+/* Put device into known state. */
+static int lm3554_setup(struct lm3554 *flash)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	/* clear the flags register */
+	ret = lm3554_read(flash, LM3554_FLAGS_REG);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "Fault info: %02x\n", ret);
+
+	ret = lm3554_set_config1(flash);
+	if (ret < 0)
+		return ret;
+
+	ret = lm3554_set_duration(flash);
+	if (ret < 0)
+		return ret;
+
+	ret = lm3554_set_torch(flash);
+	if (ret < 0)
+		return ret;
+
+	ret = lm3554_set_flash(flash);
+	if (ret < 0)
+		return ret;
+
+	/* read status */
+	ret = lm3554_read_status(flash);
+	if (ret < 0)
+		return ret;
+
+	return ret ? -EIO : 0;
+}
+
+static int __lm3554_s_power(struct lm3554 *flash, int power)
+{
+	return 0;
+}
+
+static int lm3554_s_power(struct v4l2_subdev *sd, int power)
+{
+	struct lm3554 *flash = to_lm3554(sd);
+	int ret = 0;
+
+	mutex_lock(&flash->power_lock);
+
+	if (flash->power_count == !power) {
+		ret = __lm3554_s_power(flash, !!power);
+		if (ret < 0)
+			goto done;
+	}
+
+	flash->power_count += power ? 1 : -1;
+	WARN_ON(flash->power_count < 0);
+
+done:
+	mutex_unlock(&flash->power_lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops lm3554_core_ops = {
+	.queryctrl = lm3554_queryctrl,
+	.g_ctrl = lm3554_g_ctrl,
+	.s_ctrl = lm3554_s_ctrl,
+	.s_power = lm3554_s_power,
+};
+
+static const struct v4l2_subdev_ops lm3554_ops = {
+	.core = &lm3554_core_ops,
+};
+
+static int lm3554_detect(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *adapter = client->adapter;
+	struct lm3554 *flash = to_lm3554(sd);
+	int ret;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "lm3554_detect i2c error\n");
+		return -ENODEV;
+	}
+
+	/* Power up the flash driver and reset it */
+	ret = lm3554_s_power(&flash->sd, 1);
+	if (ret < 0)
+		return ret;
+
+	lm3554_hw_reset(client);
+
+	/* Setup default values. This makes sure that the chip is in a known
+	 * state.
+	 */
+	ret = lm3554_setup(flash);
+	if (ret < 0)
+		goto fail;
+
+	dev_dbg(&client->dev, "Successfully detected lm3554 LED flash\n");
+	lm3554_s_power(&flash->sd, 0);
+	return 0;
+
+fail:
+	lm3554_s_power(&flash->sd, 0);
+	return ret;
+}
+
+static int lm3554_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return lm3554_s_power(sd, 1);
+}
+
+static int lm3554_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return lm3554_s_power(sd, 0);
+}
+
+static const struct v4l2_subdev_internal_ops lm3554_internal_ops = {
+	.registered = lm3554_detect,
+	.open = lm3554_open,
+	.close = lm3554_close,
+};
+
+/* -----------------------------------------------------------------------------
+ *  I2C driver
+ */
+#ifdef CONFIG_PM
+
+static int lm3554_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct lm3554 *flash = to_lm3554(subdev);
+	int rval;
+
+	if (flash->power_count == 0)
+		return 0;
+
+	rval = __lm3554_s_power(flash, 0);
+
+	dev_dbg(&client->dev, "Suspend %s\n", rval < 0 ? "failed" : "ok");
+
+	return rval;
+}
+
+static int lm3554_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct lm3554 *flash = to_lm3554(subdev);
+	int rval;
+
+	if (flash->power_count == 0)
+		return 0;
+
+	rval = __lm3554_s_power(flash, 1);
+
+	dev_dbg(&client->dev, "Resume %s\n", rval < 0 ? "fail" : "ok");
+
+	return rval;
+}
+
+#else
+
+#define lm3554_suspend NULL
+#define lm3554_resume  NULL
+
+#endif /* CONFIG_PM */
+
+static int lm3554_gpio_init(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3554 *flash = to_lm3554(sd);
+	struct lm3554_platform_data *pdata = flash->pdata;
+	int ret;
+
+	ret = gpio_request(pdata->gpio_reset, "flash reset");
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(pdata->gpio_reset, 1);
+	if (ret < 0)
+		goto err_gpio_reset;
+
+	ret = gpio_request(pdata->gpio_strobe, "flash");
+	if (ret < 0)
+		goto err_gpio_dir_reset;
+
+	ret = gpio_direction_output(pdata->gpio_strobe, 0);
+	if (ret < 0)
+		goto err_gpio_strobe;
+
+	return 0;
+
+err_gpio_strobe:
+	gpio_free(pdata->gpio_strobe);
+err_gpio_dir_reset:
+	gpio_direction_output(pdata->gpio_reset, 0);
+err_gpio_reset:
+	gpio_free(pdata->gpio_reset);
+
+	return ret;
+}
+
+static int lm3554_gpio_uninit(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3554 *flash = to_lm3554(sd);
+	struct lm3554_platform_data *pdata = flash->pdata;
+	int ret;
+
+	ret = gpio_direction_output(pdata->gpio_strobe, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(pdata->gpio_reset, 0);
+	if (ret < 0)
+		return ret;
+
+	gpio_free(pdata->gpio_strobe);
+	gpio_free(pdata->gpio_reset);
+	return 0;
+}
+
+static int lm3554_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	int err;
+	struct lm3554 *flash;
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "no platform data\n");
+		return -ENODEV;
+	}
+
+	flash = kzalloc(sizeof(*flash), GFP_KERNEL);
+	if (!flash) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	flash->pdata = client->dev.platform_data;
+
+	v4l2_i2c_subdev_init(&flash->sd, client, &lm3554_ops);
+	flash->sd.internal_ops = &lm3554_internal_ops;
+	flash->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	flash->mode = ATOMISP_FLASH_MODE_OFF;
+	flash->timeout = LM3554_MAX_TIMEOUT / LM3554_TIMEOUT_STEPSIZE - 1;
+
+	err = media_entity_init(&flash->sd.entity, 0, NULL, 0);
+	if (err) {
+		dev_err(&client->dev, "error initialize a media entity.\n");
+		goto fail1;
+	}
+
+	flash->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_FLASH;
+
+	mutex_init(&flash->power_lock);
+
+	setup_timer(&flash->flash_off_delay, lm3554_flash_off_delay,
+		    (unsigned long)client);
+
+	err = lm3554_gpio_init(client);
+	if (err) {
+		dev_err(&client->dev, "gpio request/direction_output fail");
+		goto fail2;
+	}
+
+	return 0;
+fail2:
+	media_entity_cleanup(&flash->sd.entity);
+fail1:
+	v4l2_device_unregister_subdev(&flash->sd);
+	kfree(flash);
+
+	return err;
+}
+
+static int lm3554_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3554 *flash = to_lm3554(sd);
+	int ret;
+
+	media_entity_cleanup(&flash->sd.entity);
+	v4l2_device_unregister_subdev(sd);
+
+	del_timer_sync(&flash->flash_off_delay);
+
+	ret = lm3554_gpio_uninit(client);
+	if (ret < 0)
+		goto fail;
+
+	kfree(flash);
+
+	return 0;
+fail:
+	dev_err(&client->dev, "gpio request/direction_output fail");
+	return ret;
+}
+
+static const struct i2c_device_id lm3554_id[] = {
+	{LM3554_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, lm3554_id);
+
+static const struct dev_pm_ops lm3554_pm_ops = {
+	.suspend = lm3554_suspend,
+	.resume = lm3554_resume,
+};
+
+static struct i2c_driver lm3554_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LM3554_NAME,
+		.pm   = &lm3554_pm_ops,
+	},
+	.probe = lm3554_probe,
+	.remove = lm3554_remove,
+	.id_table = lm3554_id,
+};
+
+static __init int init_lm3554(void)
+{
+	return i2c_add_driver(&lm3554_driver);
+}
+
+static __exit void exit_lm3554(void)
+{
+	i2c_del_driver(&lm3554_driver);
+}
+
+module_init(init_lm3554);
+module_exit(exit_lm3554);
+MODULE_AUTHOR("Jing Tao <jing.tao@intel.com>");
+MODULE_DESCRIPTION("LED flash driver for LM3554");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c b/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
new file mode 100644
index 0000000..45579d7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/lm3559.c
@@ -0,0 +1,1023 @@
+/*
+ * LED flash driver for LM3559
+ *
+ * Copyright (c) 2010-2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <media/lm3559.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+
+#include <linux/atomisp.h>
+
+struct lm3559_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl) (struct v4l2_subdev *sd, __u32 val);
+	int (*g_ctrl) (struct v4l2_subdev *sd, __s32 *val);
+};
+
+/* Registers */
+
+#define LM3559_MODE_SHIFT		0
+#define LM3559_MODE_MASK		0x3
+
+#define LM3559_TORCH_BRIGHTNESS_REG	0xa0
+#define LM3559_TORCH_LED1_CURRENT_SHIFT	0
+#define LM3559_TORCH_LED2_CURRENT_SHIFT	3
+
+#define LM3559_INDICATOR_PRIVACY_REG	0x11
+
+#define LM3559_INDICATOR_BACK_ON	3
+#define LM3559_INDICATOR_CURRENT_SHIFT	0
+#define LM3559_INDICATOR_LED1_SHIFT	4
+#define LM3559_INDICATOR_LED2_SHIFT	5
+#define LM3559_INDICATOR_BLINKING_PERIOD_SHIFT	5
+
+#define LM3559_INDICATOR_PWM_PERIOD_REG	0x14
+#define LM3559_INDICATOR_PWM_PERIOD_SHIFT	0
+
+
+#define LM3559_INDICATOR_CURRENT_SHIFT	0
+
+#define LM3559_ENABLE_REG	0x10
+
+#define LM3559_FLASH_BRIGHTNESS_REG	0xb0
+#define LM3559_FLASH_LED1_CURRENT_SHIFT	0
+#define LM3559_FLASH_LED2_CURRENT_SHIFT	4
+#define LM3559_FLASH_MAX_CURRENT	15
+#define LM3560_FLASH_MAX_CURRENT	13
+#define LM3560_TORCH_MAX_CURRENT	2
+
+#define LM3559_FLASH_DURATION_REG	0xc0
+#define LM3559_FLASH_TIMEOUT_SHIFT	0
+#define LM3559_CURRENT_LIMIT_SHIFT	5
+
+#define LM3559_FLAGS_REG		0xd0
+#define LM3559_FLAG_TIMEOUT		(1 << 0)
+#define LM3559_FLAG_THERMAL_SHUTDOWN	(1 << 1)
+#define LM3559_FLAG_LED_FAULT		(1 << 2)
+#define LM3559_FLAG_TX1_INTERRUPT	(1 << 3)
+#define LM3559_FLAG_TX2_INTERRUPT	(1 << 4)
+#define LM3559_FLAG_LED_THERMAL_FAULT	(1 << 5)
+#define LM3559_FLAG_INPUT_FLASH_VOLTAGE_LOW		(1 << 6)
+#define LM3559_FLAG_INPUT_VOLTAGE_LOW	(1 << 7)
+
+#define LM3559_CONFIG_REG_1		0xe0
+#define LM3559_CONFIG_REG_2		0xf0
+
+#define LM3559_CONFIG_REG_1_INIT_SETTING	0x6c
+#define LM3559_CONFIG_REG_2_INIT_SETTING	0x01
+#define LM3559_CONFIG_REG_2_INIT_SETTING_LM3560	0x11
+#define LM3559_GPIO_REG_INIT_SETTING		0x00
+
+#define LM3559_ENVM_TX2_SHIFT		0
+#define LM3559_ENVM_TX2_MASK		0x01
+#define LM3559_TX2_POLARITY_SHIFT	6
+#define LM3559_TX2_POLARITY_MASK	0x40
+
+#define LM3559_GPIO_REG			0x20
+#define LM3559_GPIO_DISABLE_TX2_SHIFT	3
+#define LM3559_GPIO_DISABLE_TX2_MASK	(1 << LM3559_GPIO_DISABLE_TX2_SHIFT)
+
+enum lm3559_hw_type {
+	lm3559_hw_type_lm3559,
+	lm3559_hw_type_lm3560,
+};
+
+struct privacy_indicator {
+	u8 indicator_current;
+	u8 blinking_period;
+	u8 pwm_period;
+	u8 led1_enable;
+	u8 led2_enable;
+	u8 back_on;
+};
+struct lm3559 {
+	struct v4l2_subdev sd;
+
+	struct mutex power_lock;
+	int power_count;
+
+	unsigned int mode;
+	int timeout;
+	u8 torch_current;
+	u8 indicator_current;
+	u8 flash_current;
+
+	struct privacy_indicator indicator;
+	struct timer_list flash_off_delay;
+	struct lm3559_platform_data *pdata;
+	enum lm3559_hw_type hw_type;
+};
+
+#define to_lm3559(p_sd)	container_of(p_sd, struct lm3559, sd)
+
+/* Return negative errno else zero on success */
+static int lm3559_write(struct lm3559 *flash, u8 addr, u8 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, addr, val);
+
+	dev_dbg(&client->dev, "Write Addr:%02X Val:%02X %s\n", addr, val,
+		ret < 0 ? "fail" : "ok");
+
+	return ret;
+}
+
+/* Return negative errno else a data byte received from the device. */
+static int lm3559_read(struct lm3559 *flash, u8 addr)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, addr);
+
+	dev_dbg(&client->dev, "Read Addr:%02X Val:%02X %s\n", addr, ret,
+		ret < 0 ? "fail" : "ok");
+
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * Hardware configuration
+ */
+
+static int lm3559_set_mode(struct lm3559 *flash, unsigned int mode)
+{
+	u8 val;
+	int ret;
+
+	val = lm3559_read(flash, LM3559_ENABLE_REG);
+	val &= ~LM3559_MODE_MASK;
+	val |= (mode & LM3559_MODE_MASK) << LM3559_MODE_SHIFT;
+
+	ret = lm3559_write(flash, LM3559_ENABLE_REG, val);
+	if (ret == 0)
+		flash->mode = mode;
+	return ret;
+}
+
+static int lm3559_set_indicator(struct lm3559 *flash)
+{
+	int ret;
+	u8 val;
+
+	/* Clear flags register. */
+	lm3559_read(flash, LM3559_FLAGS_REG);
+	val = (flash->indicator.indicator_current
+			<< LM3559_INDICATOR_CURRENT_SHIFT) |
+		(flash->indicator.led1_enable << LM3559_INDICATOR_LED1_SHIFT) |
+		(flash->indicator.led2_enable << LM3559_INDICATOR_LED2_SHIFT) |
+		(flash->indicator.back_on << LM3559_INDICATOR_BACK_ON) |
+		(flash->indicator.blinking_period
+			<< LM3559_INDICATOR_BLINKING_PERIOD_SHIFT);
+	ret = lm3559_write(flash, LM3559_INDICATOR_PRIVACY_REG, val);
+	if (ret)
+		return ret;
+	val = flash->indicator.pwm_period << LM3559_INDICATOR_PWM_PERIOD_SHIFT;
+	ret = lm3559_write(flash, LM3559_INDICATOR_PWM_PERIOD_REG, val);
+
+	return ret;
+}
+static int lm3559_set_torch(struct lm3559 *flash)
+{
+	u8 val;
+
+	/* Clear flags register. */
+	lm3559_read(flash, LM3559_FLAGS_REG);
+	val = (flash->torch_current << LM3559_TORCH_LED1_CURRENT_SHIFT) |
+	      (flash->torch_current << LM3559_TORCH_LED2_CURRENT_SHIFT);
+
+	return lm3559_write(flash, LM3559_TORCH_BRIGHTNESS_REG, val);
+}
+
+static int lm3559_set_flash(struct lm3559 *flash)
+{
+	u8 val;
+
+	/* Clear flags register. */
+	lm3559_read(flash, LM3559_FLAGS_REG);
+	val = (flash->flash_current << LM3559_FLASH_LED1_CURRENT_SHIFT) |
+		(flash->flash_current << LM3559_FLASH_LED2_CURRENT_SHIFT);
+
+	return lm3559_write(flash, LM3559_FLASH_BRIGHTNESS_REG, val);
+}
+
+static int lm3559_set_duration(struct lm3559 *flash)
+{
+	u8 val;
+
+	val = (flash->timeout << LM3559_FLASH_TIMEOUT_SHIFT) |
+	      (flash->pdata->current_limit << LM3559_CURRENT_LIMIT_SHIFT);
+
+	return lm3559_write(flash, LM3559_FLASH_DURATION_REG, val);
+}
+
+static int lm3559_set_config(struct lm3559 *flash)
+{
+	int ret;
+	u8 val;
+
+	val = LM3559_CONFIG_REG_1_INIT_SETTING & ~LM3559_TX2_POLARITY_MASK;
+	val |= flash->pdata->tx2_polarity << LM3559_TX2_POLARITY_SHIFT;
+	ret = lm3559_write(flash, LM3559_CONFIG_REG_1, val);
+	if (ret)
+		return ret;
+
+	if (flash->hw_type == lm3559_hw_type_lm3560)
+		val = LM3559_CONFIG_REG_2_INIT_SETTING_LM3560 &
+		      ~LM3559_ENVM_TX2_MASK;
+	else
+		val = LM3559_CONFIG_REG_2_INIT_SETTING & ~LM3559_ENVM_TX2_MASK;
+	val |= flash->pdata->envm_tx2 << LM3559_ENVM_TX2_SHIFT;
+	ret = lm3559_write(flash, LM3559_CONFIG_REG_2, val);
+	if (ret)
+		return ret;
+
+	val = LM3559_GPIO_REG_INIT_SETTING & ~LM3559_GPIO_DISABLE_TX2_MASK;
+	val |= flash->pdata->disable_tx2 << LM3559_GPIO_DISABLE_TX2_SHIFT;
+	return lm3559_write(flash, LM3559_GPIO_REG, val);
+}
+
+/* -----------------------------------------------------------------------------
+ * Hardware trigger
+ */
+
+static void lm3559_flash_off_delay(long unsigned int arg)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata((struct i2c_client *)arg);
+	struct lm3559 *flash = to_lm3559(sd);
+	struct lm3559_platform_data *pdata = flash->pdata;
+
+	gpio_set_value(pdata->gpio_strobe, 0);
+}
+
+static int lm3559_hw_strobe(struct i2c_client *client, bool strobe)
+{
+	int ret, timer_pending;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3559 *flash = to_lm3559(sd);
+	struct lm3559_platform_data *pdata = flash->pdata;
+
+	/*
+	 * An abnormal high flash current is observed on lm3554 when
+	 * strobe off the flash. Workaround here is firstly set flash
+	 * current to lower level, wait a short moment, and then strobe
+	 * off the flash.
+	 * FIXME: The same issue exists with lm3559?
+	 */
+
+	timer_pending = del_timer_sync(&flash->flash_off_delay);
+
+	/* Flash off */
+	if (!strobe) {
+		/* set current to 70mA and wait a while */
+		ret = lm3559_write(flash, LM3559_FLASH_BRIGHTNESS_REG, 0);
+		if (ret < 0)
+			goto err;
+		mod_timer(&flash->flash_off_delay,
+			  jiffies + msecs_to_jiffies(LM3559_TIMER_DELAY));
+		return 0;
+	}
+
+	/* Flash on */
+
+	/*
+	 * If timer is killed before run, flash is not strobe off,
+	 * so must strobe off here
+	 */
+	if (timer_pending)
+		gpio_set_value(pdata->gpio_strobe, 0);
+
+	/* Restore flash current settings */
+	ret = lm3559_set_flash(flash);
+	if (ret < 0)
+		goto err;
+
+	/* Strobe on Flash */
+	gpio_set_value(pdata->gpio_strobe, 1);
+
+	return 0;
+err:
+	dev_err(&client->dev, "failed to %s flash strobe (%d)\n",
+		strobe ? "on" : "off", ret);
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 controls
+ */
+
+static int lm3559_read_status(struct lm3559 *flash)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+
+	/* NOTE: reading register clear fault status */
+	ret = lm3559_read(flash, LM3559_FLAGS_REG);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Do not take TX1/TX2 signal as an error
+	 * because MSIC will not turn off flash, but turn to
+	 * torch mode according to gsm modem signal by hardware.
+	 */
+	ret &= ~(LM3559_FLAG_TX1_INTERRUPT | LM3559_FLAG_TX2_INTERRUPT);
+
+	if (ret > 0)
+		dev_dbg(&client->dev, "LM3559 flag status: %02x\n", ret);
+
+	return ret;
+}
+
+static int lm3559_s_flash_timeout(struct v4l2_subdev *sd, u32 val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+
+	val = clamp(val, LM3559_MIN_TIMEOUT, LM3559_MAX_TIMEOUT);
+	val = val / LM3559_TIMEOUT_STEPSIZE - 1;
+
+	flash->timeout = val;
+
+	return lm3559_set_duration(flash);
+}
+
+static int lm3559_g_flash_timeout(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+
+	*val = (u32)(flash->timeout + 1) * LM3559_TIMEOUT_STEPSIZE;
+
+	return 0;
+}
+
+static int lm3559_s_flash_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+	unsigned int limit = flash->pdata->flash_current_limit;
+
+	if (limit == 0)
+		limit = LM3559_FLASH_MAX_CURRENT;
+
+	if (flash->hw_type == lm3559_hw_type_lm3560 &&
+	    limit > LM3560_FLASH_MAX_CURRENT)
+		limit = LM3560_FLASH_MAX_CURRENT;
+
+	intensity = LM3559_CLAMP_PERCENTAGE(intensity);
+	intensity = intensity * limit / LM3559_MAX_PERCENT;
+	flash->flash_current = intensity;
+
+	return lm3559_set_flash(flash);
+}
+
+static int lm3559_g_flash_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+	unsigned int limit = flash->pdata->flash_current_limit;
+
+	if (limit == 0)
+		limit = LM3559_FLASH_MAX_CURRENT;
+
+	if (flash->hw_type == lm3559_hw_type_lm3560 &&
+	    limit > LM3560_FLASH_MAX_CURRENT)
+		limit = LM3560_FLASH_MAX_CURRENT;
+
+	*val = flash->flash_current * LM3559_MAX_PERCENT / limit;
+
+	return 0;
+}
+
+static int lm3559_s_torch_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+
+	intensity = LM3559_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3559_PERCENT_TO_VALUE(intensity, LM3559_TORCH_STEP);
+
+	if (flash->hw_type == lm3559_hw_type_lm3560 &&
+	   intensity > LM3560_TORCH_MAX_CURRENT)
+		intensity = LM3560_TORCH_MAX_CURRENT;
+
+	flash->torch_current = intensity;
+
+	return lm3559_set_torch(flash);
+}
+
+static int lm3559_g_torch_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+
+	*val = LM3559_VALUE_TO_PERCENT((u32)flash->torch_current,
+			LM3559_TORCH_STEP);
+
+	return 0;
+}
+
+static int lm3559_s_indicator_intensity(struct v4l2_subdev *sd, u32 intensity)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+
+	intensity = LM3559_CLAMP_PERCENTAGE(intensity);
+	intensity = LM3559_PERCENT_TO_VALUE(intensity, LM3559_INDICATOR_STEP);
+
+	flash->indicator.indicator_current = intensity;
+
+	return lm3559_set_indicator(flash);
+}
+
+static int lm3559_g_indicator_intensity(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+
+	*val = LM3559_VALUE_TO_PERCENT(
+		(u32)flash->indicator.indicator_current, LM3559_INDICATOR_STEP);
+
+	return 0;
+}
+
+static int lm3559_s_flash_strobe(struct v4l2_subdev *sd, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return lm3559_hw_strobe(client, val);
+}
+
+static int lm3559_s_flash_mode(struct v4l2_subdev *sd, u32 new_mode)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+	unsigned int mode;
+
+	switch (new_mode) {
+	case ATOMISP_FLASH_MODE_OFF:
+		mode = LM3559_MODE_SHUTDOWN;
+		break;
+	case ATOMISP_FLASH_MODE_FLASH:
+		mode = LM3559_MODE_FLASH;
+		break;
+	case ATOMISP_FLASH_MODE_INDICATOR:
+		mode = LM3559_MODE_INDICATOR;
+		break;
+	case ATOMISP_FLASH_MODE_TORCH:
+		mode = LM3559_MODE_TORCH;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return lm3559_set_mode(flash, mode);
+}
+
+static int lm3559_g_flash_mode(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+	*val = flash->mode;
+	return 0;
+}
+
+static int lm3559_g_flash_status(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+	int value;
+
+	value = lm3559_read_status(flash);
+	if (value < 0)
+		return value;
+
+	if (value & LM3559_FLAG_TIMEOUT)
+		*val = ATOMISP_FLASH_STATUS_TIMEOUT;
+	else if (value > 0)
+		*val = ATOMISP_FLASH_STATUS_HW_ERROR;
+	else
+		*val = ATOMISP_FLASH_STATUS_OK;
+
+	return 0;
+}
+
+static int lm3559_g_flash_status_register(struct v4l2_subdev *sd, s32 *val)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+	int ret;
+
+	ret = lm3559_read(flash, LM3559_FLAGS_REG);
+
+	if (ret < 0)
+		return ret;
+
+	*val = ret;
+	return 0;
+}
+
+static const struct lm3559_ctrl_id lm3559_ctrls[] = {
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TIMEOUT,
+				"Flash Timeout",
+				0,
+				LM3559_MAX_TIMEOUT,
+				1,
+				LM3559_DEFAULT_TIMEOUT,
+				0,
+				lm3559_s_flash_timeout,
+				lm3559_g_flash_timeout),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_INTENSITY,
+				"Flash Intensity",
+				LM3559_MIN_PERCENT,
+				LM3559_MAX_PERCENT,
+				1,
+				LM3559_FLASH_DEFAULT_BRIGHTNESS,
+				0,
+				lm3559_s_flash_intensity,
+				lm3559_g_flash_intensity),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_TORCH_INTENSITY,
+				"Torch Intensity",
+				LM3559_MIN_PERCENT,
+				LM3559_MAX_PERCENT,
+				1,
+				LM3559_TORCH_DEFAULT_BRIGHTNESS,
+				0,
+				lm3559_s_torch_intensity,
+				lm3559_g_torch_intensity),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_INDICATOR_INTENSITY,
+				"Indicator Intensity",
+				LM3559_MIN_PERCENT,
+				LM3559_MAX_PERCENT,
+				1,
+				LM3559_INDICATOR_DEFAULT_BRIGHTNESS,
+				0,
+				lm3559_s_indicator_intensity,
+				lm3559_g_indicator_intensity),
+	s_ctrl_id_entry_boolean(V4L2_CID_FLASH_STROBE,
+				"Flash Strobe",
+				0,
+				0,
+				lm3559_s_flash_strobe,
+				NULL),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_MODE,
+				"Flash Mode",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				ATOMISP_FLASH_MODE_OFF,
+				0,
+				lm3559_s_flash_mode,
+				lm3559_g_flash_mode),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_STATUS,
+				"Flash Status",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				ATOMISP_FLASH_STATUS_OK,
+				0,
+				NULL,
+				lm3559_g_flash_status),
+	s_ctrl_id_entry_integer(V4L2_CID_FLASH_STATUS_REGISTER,
+				"Flash Status Register",
+				0,   /* don't assume any enum ID is first */
+				100, /* enum value, may get extended */
+				1,
+				0,
+				0,
+				NULL,
+				lm3559_g_flash_status_register),
+};
+
+static const struct lm3559_ctrl_id *find_ctrl_id(unsigned int id)
+{
+	int i;
+	int num;
+
+	num = ARRAY_SIZE(lm3559_ctrls);
+	for (i = 0; i < num; i++) {
+		if (lm3559_ctrls[i].qc.id == id)
+			return &lm3559_ctrls[i];
+	}
+
+	return NULL;
+}
+
+static int lm3559_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	int num;
+
+	if (!qc)
+		return -EINVAL;
+
+	num = ARRAY_SIZE(lm3559_ctrls);
+	if (qc->id >= num)
+		return -EINVAL;
+
+	*qc = lm3559_ctrls[qc->id].qc;
+
+	return 0;
+}
+
+static int lm3559_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	const struct lm3559_ctrl_id *s_ctrl;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = find_ctrl_id(ctrl->id);
+	if (!s_ctrl)
+		return -EINVAL;
+
+	return s_ctrl->s_ctrl(sd, ctrl->value);
+}
+
+static int lm3559_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	const struct lm3559_ctrl_id *s_ctrl;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = find_ctrl_id(ctrl->id);
+	if (s_ctrl == NULL)
+		return -EINVAL;
+
+	return s_ctrl->g_ctrl(sd, &ctrl->value);
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 subdev core operations
+ */
+
+/* Put device into known state. */
+static int lm3559_setup(struct lm3559 *flash)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&flash->sd);
+	unsigned int flash_current_limit = flash->pdata->flash_current_limit;
+	int ret;
+
+	/* clear the flags register */
+	ret = lm3559_read(flash, LM3559_FLAGS_REG);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(&client->dev, "Fault info: %02x\n", ret);
+
+	ret = lm3559_set_config(flash);
+	if (ret < 0)
+		return ret;
+
+	flash->timeout = LM3559_DEFAULT_TIMEOUT_SETTING;
+	ret = lm3559_set_duration(flash);
+	if (ret < 0)
+		return ret;
+
+	flash->torch_current = LM3559_TORCH_DEFAULT;
+	ret = lm3559_set_torch(flash);
+	if (ret < 0)
+		return ret;
+
+	if (flash_current_limit == 0)
+		flash_current_limit = LM3559_FLASH_MAX_CURRENT;
+	flash->flash_current = LM3559_FLASH_DEFAULT_BRIGHTNESS *
+				flash_current_limit / LM3559_MAX_PERCENT;
+	ret = lm3559_set_flash(flash);
+	if (ret < 0)
+		return ret;
+
+	/* read status */
+	ret = lm3559_read_status(flash);
+	if (ret < 0)
+		return ret;
+
+	return ret ? -EIO : 0;
+}
+
+static int __lm3559_s_power(struct lm3559 *flash, int power)
+{
+	struct lm3559_platform_data *pdata = flash->pdata;
+	int ret;
+
+	ret = gpio_request(pdata->gpio_reset, "flash reset");
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(pdata->gpio_reset, power);
+	if (ret < 0) {
+		gpio_free(pdata->gpio_reset);
+		return ret;
+	}
+	gpio_set_value(pdata->gpio_reset, power);
+	gpio_free(pdata->gpio_reset);
+	usleep_range(100, 100);
+
+	if (power) {
+		/* Setup default values. This makes sure that the chip
+		 * is in a known state.
+		 */
+		ret = lm3559_setup(flash);
+		if (ret < 0) {
+			__lm3559_s_power(flash, 0);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int lm3559_s_power(struct v4l2_subdev *sd, int power)
+{
+	struct lm3559 *flash = to_lm3559(sd);
+	int ret = 0;
+
+	mutex_lock(&flash->power_lock);
+
+	if (flash->power_count == !power) {
+		ret = __lm3559_s_power(flash, !!power);
+		if (ret < 0)
+			goto done;
+	}
+
+	flash->power_count += power ? 1 : -1;
+	WARN_ON(flash->power_count < 0);
+
+done:
+	mutex_unlock(&flash->power_lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops lm3559_core_ops = {
+	.queryctrl = lm3559_queryctrl,
+	.g_ctrl = lm3559_g_ctrl,
+	.s_ctrl = lm3559_s_ctrl,
+	.s_power = lm3559_s_power,
+};
+
+static const struct v4l2_subdev_ops lm3559_ops = {
+	.core = &lm3559_core_ops,
+};
+
+static int lm3559_detect(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_adapter *adapter = client->adapter;
+	struct lm3559 *flash = to_lm3559(sd);
+	int ret;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&client->dev, "lm3559_detect i2c error\n");
+		return -ENODEV;
+	}
+
+	/* Make sure the power is initially off to ensure chip is resetted */
+	__lm3559_s_power(flash, 0);
+
+	/* Power up the flash driver, resetting and initializing it. */
+	ret = lm3559_s_power(&flash->sd, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to power on lm3559 LED flash\n");
+	} else {
+		dev_dbg(&client->dev, "Successfully detected lm3559 LED flash\n");
+		lm3559_s_power(&flash->sd, 0);
+	}
+
+	return ret;
+}
+
+static int lm3559_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return lm3559_s_power(sd, 1);
+}
+
+static int lm3559_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	return lm3559_s_power(sd, 0);
+}
+
+static const struct v4l2_subdev_internal_ops lm3559_internal_ops = {
+	.registered = lm3559_detect,
+	.open = lm3559_open,
+	.close = lm3559_close,
+};
+
+/* -----------------------------------------------------------------------------
+ *  I2C driver
+ */
+#ifdef CONFIG_PM
+
+static int lm3559_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct lm3559 *flash = to_lm3559(subdev);
+	int rval;
+
+	if (flash->power_count == 0)
+		return 0;
+
+	rval = __lm3559_s_power(flash, 0);
+
+	dev_dbg(&client->dev, "Suspend %s\n", rval < 0 ? "failed" : "ok");
+
+	return rval;
+}
+
+static int lm3559_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *subdev = i2c_get_clientdata(client);
+	struct lm3559 *flash = to_lm3559(subdev);
+	int rval;
+
+	if (flash->power_count == 0)
+		return 0;
+
+	rval = __lm3559_s_power(flash, 1);
+
+	dev_dbg(&client->dev, "Resume %s\n", rval < 0 ? "fail" : "ok");
+
+	return rval;
+}
+
+#else
+
+#define lm3559_suspend NULL
+#define lm3559_resume  NULL
+
+#endif /* CONFIG_PM */
+
+static int lm3559_gpio_init(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3559 *flash = to_lm3559(sd);
+	struct lm3559_platform_data *pdata = flash->pdata;
+	int ret;
+
+	ret = gpio_request(pdata->gpio_strobe, "flash");
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(pdata->gpio_strobe, 0);
+	if (ret < 0)
+		goto err_gpio_flash;
+
+	return 0;
+
+err_gpio_flash:
+	gpio_free(pdata->gpio_strobe);
+	return ret;
+}
+
+static int lm3559_gpio_uninit(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3559 *flash = to_lm3559(sd);
+	struct lm3559_platform_data *pdata = flash->pdata;
+	int ret;
+
+	ret = gpio_direction_output(pdata->gpio_strobe, 0);
+	if (ret < 0)
+		return ret;
+
+	gpio_free(pdata->gpio_strobe);
+
+	return 0;
+}
+
+static int lm3559_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	int err;
+	struct lm3559 *flash;
+
+	if (client->dev.platform_data == NULL) {
+		dev_err(&client->dev, "no platform data\n");
+		return -ENODEV;
+	}
+
+	flash = kzalloc(sizeof(*flash), GFP_KERNEL);
+	if (!flash) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	flash->hw_type = id->driver_data;
+	flash->pdata = client->dev.platform_data;
+
+	v4l2_i2c_subdev_init(&flash->sd, client, &lm3559_ops);
+	flash->sd.internal_ops = &lm3559_internal_ops;
+	flash->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	flash->mode = ATOMISP_FLASH_MODE_OFF;
+
+	err = media_entity_init(&flash->sd.entity, 0, NULL, 0);
+	if (err) {
+		dev_err(&client->dev, "error initialize a media entity.\n");
+		goto fail1;
+	}
+
+	flash->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_FLASH;
+
+	mutex_init(&flash->power_lock);
+
+	setup_timer(&flash->flash_off_delay, lm3559_flash_off_delay,
+		    (unsigned long)client);
+
+	err = lm3559_gpio_init(client);
+	if (err) {
+		dev_err(&client->dev, "gpio request/direction_output fail");
+		goto fail2;
+	}
+
+	if (flash->hw_type == lm3559_hw_type_lm3560 &&
+	    (flash->pdata->flash_current_limit == 0 ||
+	     flash->pdata->flash_current_limit > LM3560_FLASH_MAX_CURRENT))
+		flash->pdata->flash_current_limit = LM3560_FLASH_MAX_CURRENT;
+
+	return 0;
+fail2:
+	media_entity_cleanup(&flash->sd.entity);
+fail1:
+	v4l2_device_unregister_subdev(&flash->sd);
+	kfree(flash);
+
+	return err;
+}
+
+static int lm3559_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct lm3559 *flash = to_lm3559(sd);
+	int ret;
+
+	media_entity_cleanup(&flash->sd.entity);
+	v4l2_device_unregister_subdev(sd);
+
+	del_timer_sync(&flash->flash_off_delay);
+
+	ret = lm3559_gpio_uninit(client);
+	if (ret < 0)
+		goto fail;
+
+	kfree(flash);
+
+	return 0;
+fail:
+	dev_err(&client->dev, "gpio request/direction_output fail");
+	return ret;
+}
+
+static const struct i2c_device_id lm3559_id[] = {
+	{ LM3559_NAME, lm3559_hw_type_lm3559 },
+	{ LM3560_NAME, lm3559_hw_type_lm3560 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(i2c, lm3559_id);
+
+static const struct dev_pm_ops lm3559_pm_ops = {
+	.suspend = lm3559_suspend,
+	.resume = lm3559_resume,
+};
+
+static struct i2c_driver lm3559_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = LM3559_NAME,
+		.pm   = &lm3559_pm_ops,
+	},
+	.probe = lm3559_probe,
+	.remove = lm3559_remove,
+	.id_table = lm3559_id,
+};
+
+static __init int init_lm3559(void)
+{
+	return i2c_add_driver(&lm3559_driver);
+}
+
+static __exit void exit_lm3559(void)
+{
+	i2c_del_driver(&lm3559_driver);
+}
+
+module_init(init_lm3559);
+module_exit(exit_lm3559);
+MODULE_AUTHOR("Shenbo Huang <shenbo.huang@intel.com>");
+MODULE_DESCRIPTION("LED flash driver for LM3559");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
new file mode 100644
index 0000000..faf319a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.c
@@ -0,0 +1,1622 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Partially based on m-5mols kernel driver,
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ *
+ * Partially based on jc_v4l2 kernel driver from http://opensource.samsung.com
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/intel-mid.h>
+#include <asm/irq.h>
+#include <linux/atomisp_platform.h>
+#include <media/m10mo_atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include "m10mo.h"
+
+#define M10MO_FORMAT	V4L2_MBUS_FMT_UYVY8_1X16
+
+/*
+ * m10mo_read -  I2C read function
+ * @reg: combination of size, category and command for the I2C packet
+ * @size: desired size of I2C packet
+ * @val: read value
+ *
+ * Returns 0 on success, or else negative errno.
+*/
+
+static int m10mo_read(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned char data[5];
+	struct i2c_msg msg[2];
+	unsigned char recv_data[len + 1];
+	int ret;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	if (len != 1 && len != 2 && len != 4)	{
+		dev_err(&client->dev, "Wrong data size\n");
+		return -EINVAL;
+	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = sizeof(data);
+	msg[0].buf = data;
+
+	data[0] = 5;
+	data[1] = M10MO_BYTE_READ;
+	data[2] = category;
+	data[3] = reg;
+        data[4] = len;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = len + 1;
+	msg[1].buf = recv_data;
+
+	/* isp firmware becomes stable during this time*/
+	usleep_range(200, 200);
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+
+	if (ret == 2) {
+		if (len == 0x01)
+			*val = recv_data[1];
+		else if (len == 0x02)
+			*val = recv_data[1] << 8 | recv_data[2];
+		else
+			*val = recv_data[1] << 24 | recv_data[2] << 16
+				| recv_data[3] << 8 | recv_data[4];
+	}
+	return 0;
+}
+
+/**
+ * m10mo_write - I2C command write function
+ * @reg: combination of size, category and command for the I2C packet
+ * @val: value to write
+ *
+ * Returns 0 on success, or else negative errno.
+ */
+static int m10mo_write(struct v4l2_subdev *sd, u8 len, u8 category, u8 reg, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[len + 4];
+	struct i2c_msg msg;
+	int ret;
+	const int num_msg = 1;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	if (len != 1 && len != 2 && len != 4) {
+		dev_err(&client->dev, "Wrong data size\n");
+		return -EINVAL;
+	}
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = sizeof(data);
+	msg.buf = data;
+
+	data[0] = msg.len;
+	data[1] = M10MO_BYTE_WRITE;
+	data[2] = category;
+	data[3] = reg;
+	switch (len) {
+	case 1:
+		data[4] = val;
+		break;
+	case 2:
+		data[4] = ((val >> 8) & 0xFF);
+		data[5] = (val & 0xFF);
+		break;
+	case 4:
+		data[4] = ((val >> 24) & 0xFF);
+		data[5] = ((val >> 16) & 0xFF);
+		data[6] = ((val >> 8) & 0xFF);
+		data[7] = (val & 0xFF);
+		break;
+	default:
+		/* No possible to happen - len is already validated */
+		break;
+	}
+
+	/* isp firmware becomes stable during this time*/
+	usleep_range(200, 200);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+int m10mo_writeb(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val)
+{
+	return m10mo_write(sd, 1, category, reg, val);
+}
+
+int m10mo_writew(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val)
+{
+	return m10mo_write(sd, 2, category, reg, val);
+}
+
+int m10mo_writel(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val)
+{
+	return m10mo_write(sd, 4, category, reg, val);
+}
+
+int m10mo_readb(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val)
+{
+	return m10mo_read(sd, 1, category, reg, val);
+}
+
+int m10mo_readw(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val)
+{
+	return m10mo_read(sd, 2, category, reg, val);
+}
+
+int m10mo_readl(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val)
+{
+	return m10mo_read(sd, 4, category, reg, val);
+}
+
+int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct m10mo_device *m10mo_dev =  to_m10mo_sensor(sd);
+	struct i2c_msg msg;
+	u8 *data = m10mo_dev->message_buffer;
+	int i, ret;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	if ((len + 8) > sizeof(m10mo_dev->message_buffer))
+		return -ENOMEM;
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len + 8;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	data[0] = 0x00;
+	data[1] = cmd;
+	data[2] = (u8)((addr >> 24) & 0xFF);
+	data[3] = (u8)((addr >> 16) & 0xFF);
+	data[4] = (u8)((addr >> 8) & 0xFF);
+	data[5] = (u8)(addr & 0xFF);
+	data[6] = len >> 8;
+	data[7] = len;
+	/* Payload starts at offset 8 */
+	memcpy(data + 8, val, len);
+
+	usleep_range(200, 200);
+
+	for (i = M10MO_I2C_RETRY; i; i--) {
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret == 1) {
+			return 0;
+		}
+		msleep(20);
+	}
+
+	return ret;
+}
+
+int m10mo_memory_read(struct v4l2_subdev *sd, u16 len, u32 addr, u8 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct m10mo_device *m10mo_dev =  to_m10mo_sensor(sd);
+	struct i2c_msg msg;
+	unsigned char data[8];
+	u8 *recv_data = m10mo_dev->message_buffer;
+	int i, err = 0;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	if (len <= 0)
+		return -EINVAL;
+
+	if ((len + 3) > sizeof(m10mo_dev->message_buffer))
+		return -ENOMEM;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = sizeof(data);
+	msg.buf = data;
+
+	/* high byte goes out first */
+	data[0] = 0x00;
+	data[1] = 0x03;
+	data[2] = (addr >> 24) & 0xFF;
+	data[3] = (addr >> 16) & 0xFF;
+	data[4] = (addr >> 8) & 0xFF;
+	data[5] = addr & 0xFF;
+	data[6] = (len >> 8) & 0xFF;
+	data[7] = len & 0xFF;
+
+	for (i = M10MO_I2C_RETRY; i; i--) {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err == 1)
+			break;
+		msleep(20);
+	}
+
+	if (err == 0)
+		return -EIO;
+
+	if (err != 1)
+		return err;
+
+	msg.flags = I2C_M_RD;
+	msg.len = len + 3;
+	msg.buf = recv_data;
+	for (i = M10MO_I2C_RETRY; i; i--) {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err == 1)
+			break;
+		msleep(20);
+	}
+
+	if (err == 0)
+		return -EIO;
+
+	if (err != 1)
+		return err;
+
+	if (len != (recv_data[1] << 8 | recv_data[2])) {
+		dev_err(&client->dev,
+			"expected length %d, but return length %d\n",
+			len, recv_data[1] << 8 | recv_data[2]);
+		return -EIO;
+	}
+
+	memcpy(val, recv_data + 3, len);
+
+	return 0;
+}
+
+/**
+ * m10mo_setup_flash_controller - initialize flash controller
+ *
+ * Flash controller requires additional setup before
+ * the use.
+ */
+int m10mo_setup_flash_controller(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data = 0x7F;
+	int res;
+
+	res = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT,
+				 1, 0x13000005, &data);
+	if (res < 0)
+		dev_err(&client->dev, "Setup flash controller failed\n");
+	return res;
+}
+
+/**
+ * m10mo_wait_interrupt - Clear interrupt pending bits and unmask interrupts
+ *
+ * Before writing desired interrupt value the INT_FACTOR register should
+ * be read to clear pending interrupts.
+ */
+
+static int m10mo_request_mode_change(struct v4l2_subdev *sd, u8 requested_mode)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	dev->requested_mode = requested_mode;
+
+	switch (dev->requested_mode) {
+	case M10MO_FLASH_WRITE_MODE:
+		break;
+	case M10MO_PARAM_SETTING_MODE:
+		ret = m10mo_write(sd, 1, CATEGORY_FLASHROM, FLASH_CAM_START, 0x01);
+		if (ret < 0)
+			dev_err(&client->dev, "Unable to change to PARAM_SETTING_MODE\n");
+		break;
+	case M10MO_MONITOR_MODE:
+		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x02);
+		if (ret < 0)
+			dev_err(&client->dev, "Unable to change to MONITOR_MODE\n");
+		break;
+	case M10MO_SINGLE_CAPTURE_MODE:
+		ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_SYSMODE, 0x03);
+		if (ret < 0)
+			dev_err(&client->dev, "Unable to change to SINGLE_CAPTURE_MODE\n");
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int m10mo_wait_mode_change(struct v4l2_subdev *sd, u8 mode, u32 timeout)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = wait_event_interruptible_timeout(dev->irq_waitq,
+					       dev->mode == mode,
+					       msecs_to_jiffies(timeout));
+	if (ret <= 0) {
+		dev_err(&client->dev, "m10mo_wait_mode_change timed out");
+		return -ETIMEDOUT;
+	}
+
+	return ret;
+}
+
+static int m10mo_detect(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct m10mo_version *ver = &dev->ver;
+	int ret;
+
+        ret = m10mo_read(sd, 1, CATEGORY_SYSTEM, SYSTEM_CUSTOMER_CODE,
+			&ver->customer);
+	if (!ret)
+		ret = m10mo_read(sd, 1, CATEGORY_SYSTEM, SYSTEM_PROJECT_CODE,
+				&ver->project);
+	dev_info(&client->dev, "Customer/Project[0x%x/0x%x]", dev->ver.customer,
+				dev->ver.project);
+	return 0;
+}
+
+static int __m10mo_fw_start(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = m10mo_setup_flash_controller(sd);
+	if (ret < 0)
+		return ret;
+
+	ret = m10mo_request_mode_change(sd, M10MO_PARAM_SETTING_MODE);
+	if (ret)
+		return ret;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_PARAM_SETTING_MODE,
+				     M10MO_INIT_TIMEOUT);
+	if (ret < 0) {
+		dev_err(&client->dev, "Initialization timeout");
+		return ret;
+	}
+
+	ret = m10mo_detect(sd);
+	if (ret)
+		return ret;
+
+	dev_info(&client->dev, "ISP Booted Successfully\n");
+	return 0;
+}
+
+static int m10mo_fw_start(struct v4l2_subdev *sd, u32 val)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __m10mo_fw_start(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	if (dev->pdata->common.flisclk_ctrl) {
+		ret = dev->pdata->common.flisclk_ctrl(sd, 1);
+		if (ret)
+			goto fail_clk_off;
+	}
+
+	/**ISP RESET**/
+	ret = dev->pdata->common.gpio_ctrl(sd, 1);
+	if (ret)
+		goto fail_power_off;
+	return 0;
+
+fail_power_off:
+	dev->pdata->common.gpio_ctrl(sd, 0);
+fail_clk_off:
+	if (dev->pdata->common.flisclk_ctrl)
+		ret = dev->pdata->common.flisclk_ctrl(sd, 0);
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->pdata->common.gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed");
+
+	/* Even if the first one fails we still want to turn clock off */
+	if (dev->pdata->common.flisclk_ctrl) {
+		ret = dev->pdata->common.flisclk_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "stop clock failed");
+	}
+	return ret;
+}
+
+static int __m10mo_bootrom_mode_start(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	u32 dummy;
+	int ret;
+
+	ret = m10mo_wait_mode_change(sd, M10MO_FLASH_WRITE_MODE,
+				     M10MO_BOOT_TIMEOUT);
+	if (ret < 0) {
+		dev_err(&client->dev, "Flash rom mode timeout\n");
+		return ret;
+	}
+
+	/* Dummy read to verify I2C functionality */
+	ret = m10mo_readl(sd, CATEGORY_FLASHROM,  REG_FLASH_ADD, &dummy);
+	if (ret < 0)
+		dev_err(&client->dev, "Dummy I2C access fails\n");
+
+	return ret;
+}
+
+static int __m10mo_s_power(struct v4l2_subdev *sd, int on, bool fw_update_mode)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	if (on) {
+		dev->mode = M10MO_POWERING_ON;
+		m10mo_request_mode_change(sd, M10MO_FLASH_WRITE_MODE);
+
+		ret = power_up(sd);
+		if (!ret) {
+			dev->power = 1;
+			ret = __m10mo_bootrom_mode_start(sd);
+			if (ret)
+				return ret;
+			if (!fw_update_mode)
+				ret = __m10mo_fw_start(sd);
+		}
+	} else {
+		ret = power_down(sd);
+		dev->power = 0;
+	}
+
+	return ret;
+}
+
+static int m10mo_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __m10mo_s_power(sd, on, false);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int m10mo_single_capture_process(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	/* Select frame */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+			  CAPC_SEL_FRAME_MAIN, 0x01);
+
+	if (ret)
+		return ret;
+
+	/* Image format */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM,
+			  CAPP_YUVOUT_MAIN, CAPP_YUVOUT_MAIN);
+
+	if (ret)
+		return ret;
+
+	/* Image size */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_PARAM, CAPP_MAIN_IMAGE_SIZE,
+			  dev->curr_res_table[dev->fmt_idx].command);
+
+	if (ret)
+		return ret;
+
+	/* Start image transfer */
+	ret = m10mo_writeb(sd, CATEGORY_CAPTURE_CTRL,
+			  CAPC_TRANSFER_START, 0x01);
+
+	return ret;
+}
+
+static irqreturn_t m10mo_irq_thread(int irq, void *dev_id)
+{
+	struct v4l2_subdev *sd = (struct v4l2_subdev *)dev_id;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	u32 int_factor;
+
+	/* Clear interrupt by reading interrupt factor register */
+	(void) m10mo_read(sd, 1, CATEGORY_SYSTEM, SYSTEM_INT_FACTOR,
+			  &int_factor);
+
+	dev_info(&client->dev, "INT_FACTOR: 0x%x\n", int_factor);
+
+	switch (dev->requested_mode) {
+	case M10MO_FLASH_WRITE_MODE:
+		if (dev->mode == M10MO_POWERING_ON)
+			dev->mode = M10MO_FLASH_WRITE_MODE;
+		else
+			dev_err(&client->dev, "Illegal flash write mode request\n");
+		break;
+	case M10MO_PARAM_SETTING_MODE:
+		if (int_factor & REG_INT_STATUS_MODE) {
+			dev->mode = M10MO_PARAM_SETTING_MODE;
+		}
+		break;
+	case M10MO_MONITOR_MODE:
+		if (int_factor & REG_INT_STATUS_MODE) {
+			dev->mode = M10MO_MONITOR_MODE;
+		}
+		break;
+	case M10MO_SINGLE_CAPTURE_MODE:
+		if (int_factor & REG_INT_STATUS_CAPTURE) {
+			dev->mode = M10MO_SINGLE_CAPTURE_MODE;
+			m10mo_single_capture_process(sd);
+		}
+		break;
+	default:
+		return IRQ_HANDLED;
+	}
+
+	if (dev->requested_mode == dev->mode)
+		dev->requested_mode = M10MO_NO_MODE_REQUEST;
+
+	wake_up_interruptible(&dev->irq_waitq);
+
+	return IRQ_HANDLED;
+}
+
+static int m10mo_setup_irq(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int pin, ret;
+
+	if (!dev->pdata->common.gpio_intr_ctrl) {
+		dev_err(&client->dev,
+			"Missing gpio information in interrupt setup!\n");
+		return -ENODEV;
+	}
+
+	pin = dev->pdata->common.gpio_intr_ctrl(sd);
+	if (pin < 0) {
+		ret = pin;
+		goto out;
+	}
+
+	ret = gpio_to_irq(pin);
+
+	if (ret < 0) {
+		dev_err(&client->dev, "Configure gpio to irq failed!\n");
+		goto out;
+	}
+	client->irq = ret;
+
+	ret = request_threaded_irq(client->irq, NULL, m10mo_irq_thread,
+			  IRQF_TRIGGER_RISING | IRQF_ONESHOT, M10MO_NAME, sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "Cannot register IRQ: %d\n", ret);
+		goto out;
+	}
+	return 0;
+
+out:
+	return ret;
+}
+
+#define LARGEST_ALLOWED_RATIO_MISMATCH 500
+static int distance(struct m10mo_resolution const *res, const u32 w,
+				const u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13) / w);
+	unsigned int h_ratio = ((res->height << 13) / h);
+	int match = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < 8192) || (h_ratio < 8192)
+		|| (match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+static int nearest_resolution_index(struct v4l2_subdev *sd, u32 w, u32 h)
+{
+	const struct m10mo_resolution *tmp_res = NULL;
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int min_dist = INT_MAX;
+	int idx = -1;
+	int i, dist;
+
+	for (i = 0; i < dev->entries_curr_table; i++) {
+		tmp_res = &dev->curr_res_table[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+	return idx;
+}
+
+static int get_resolution_index(struct v4l2_subdev *sd, int w, int h)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int i;
+
+	for (i = 0; i < dev->entries_curr_table; i++) {
+		if (w != dev->curr_res_table[i].width)
+			continue;
+		if (h != dev->curr_res_table[i].height)
+			continue;
+		/* Found it */
+		return i;
+	}
+	return -1;
+}
+
+static int __m10mo_try_mbus_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_framefmt *fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+
+	idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+
+	/* Fall back to the last if not found */
+	if (idx == -1)
+		idx = dev->entries_curr_table - 1;
+
+	fmt->width = dev->curr_res_table[idx].width;
+	fmt->height = dev->curr_res_table[idx].height;
+	fmt->code = M10MO_FORMAT;
+	return 0;
+}
+
+static int m10mo_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int r;
+
+	mutex_lock(&dev->input_lock);
+	r = __m10mo_try_mbus_fmt(sd, fmt);
+	mutex_unlock(&dev->input_lock);
+
+	return r;
+}
+
+static int m10mo_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+
+	fmt->width = dev->curr_res_table[dev->fmt_idx].width;
+	fmt->height = dev->curr_res_table[dev->fmt_idx].height;
+	fmt->code = M10MO_FORMAT;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int m10mo_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = __m10mo_try_mbus_fmt(sd, fmt);
+	if (ret)
+		goto out;
+
+	/* This will be set during the next stream on call */
+	dev->fmt_idx = get_resolution_index(sd, fmt->width, fmt->height);
+	if (dev->fmt_idx == -1) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+out:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int m10mo_identify_fw_type(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct m10mo_fw_id *fw_ids = NULL;
+	char buffer[M10MO_MAX_FW_ID_STRING];
+	int ret;
+
+	fw_ids = dev->pdata->fw_ids;
+	if (!fw_ids)
+		return 0;
+
+	ret = m10mo_get_isp_fw_version_string(dev, buffer, sizeof(buffer));
+	if (ret)
+		return ret;
+
+	while(fw_ids->id_string) {
+		/*
+		 * Null char is skipped (strlen - 1) because the string in
+		 * platform data can be shorter than the string in the FW.
+		 * There can be some additional information
+		 * after the match.
+		 */
+		if (!strncmp(fw_ids->id_string, buffer,
+			     strlen(fw_ids->id_string) - 1))
+		{
+			dev_info(&client->dev, "FW id %s detected\n", buffer);
+			dev->fw_type = fw_ids->fw_type;
+			return 0;
+		}
+		fw_ids++;
+	}
+	dev_err(&client->dev, "FW id string table given but no match found");
+	return 0;
+}
+
+static int m10mo_s_config(struct v4l2_subdev *sd, int irq)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 result = M10MO_INVALID_CHECKSUM;
+
+	mutex_lock(&dev->input_lock);
+
+	init_waitqueue_head(&dev->irq_waitq);
+
+	dev->fw_type = M10MO_FW_TYPE_0;
+	dev->ref_clock = dev->pdata->ref_clock_rate;
+
+	if (dev->pdata->common.platform_init) {
+		ret = dev->pdata->common.platform_init(client);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+	}
+
+	/* set up irq */
+	ret = m10mo_setup_irq(sd);
+	if (ret) {
+		dev_err(&client->dev, "IRQ err.\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = __m10mo_s_power(sd, 1, true);
+	if (ret) {
+		dev_err(&client->dev, "power-up err.\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	if (dev->pdata->common.csi_cfg) {
+		ret = dev->pdata->common.csi_cfg(sd, 1);
+		if (ret)
+			goto fail;
+	}
+
+	ret = m10mo_fw_checksum(dev, &result);
+	if (ret) {
+		dev_err(&client->dev, "Checksum calculation fails.\n");
+		goto fail;
+	}
+	if (result != M10MO_VALID_CHECKSUM)
+		dev_err(&client->dev, "Firmware checksum is not 0.\n");
+		/* TBD: Trig FW update here */
+
+	/*
+	 * We don't care about the return value here. Even in case of
+	 * wrong or non-existent fw this phase must pass.
+	 * FW can be updated later.
+	 */
+	m10mo_identify_fw_type(sd);
+
+	ret = __m10mo_s_power(sd, 0, true);
+	mutex_unlock(&dev->input_lock);
+	if (ret) {
+		dev_err(&client->dev, "power-down err.\n");
+		return ret;
+	}
+
+	return 0;
+
+fail:
+	__m10mo_s_power(sd, 0, true);
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "External ISP power-gating failed\n");
+	return ret;
+
+}
+
+static int m10mo_set_monitor_mode(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	dev_info(&client->dev," Width: %d, height: %d, command: 0x%x\n",
+		dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command);
+
+	/*Change to Monitor Size (e,g. VGA) */
+	ret = m10mo_write(sd, 1, CATEGORY_PARAM, PARAM_MON_SIZE,
+			dev->curr_res_table[dev->fmt_idx].command);
+	if (ret)
+		goto out;
+
+	if (dev->fw_type == M10MO_FW_TYPE_0) {
+		/* TODO: FPS setting must be changed */
+		ret = m10mo_write(sd, 1, CATEGORY_PARAM, PARAM_MON_FPS, 0x02);
+		if (ret)
+			goto out;
+
+		ret = m10mo_write(sd, 1, CATEGORY_PARAM, 0x67, 0x00);
+		if (ret)
+			goto out;
+	}
+
+	/* Enable interrupt signal */
+	ret = m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x01);
+	if (ret)
+		goto out;
+	/* Go to Monitor mode and output YUV Data */
+	ret = m10mo_request_mode_change(sd, M10MO_MONITOR_MODE);
+	if (ret)
+		goto out;
+
+	return 0;
+out:
+	dev_err(&client->dev, "Streaming failed %d\n", ret);
+	return ret;
+}
+
+static int m10mo_set_still_capture(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	dev_info(&client->dev," Width: %d, height: %d, command: 0x%x\n",
+		dev->curr_res_table[dev->fmt_idx].width,
+		dev->curr_res_table[dev->fmt_idx].height,
+		dev->curr_res_table[dev->fmt_idx].command);
+
+	ret= m10mo_write(sd, 1, CATEGORY_SYSTEM, SYSTEM_INT_ENABLE, 0x08);
+	if (ret)
+		goto out;
+
+	/* Set capture mode */
+	ret = m10mo_request_mode_change(sd, M10MO_SINGLE_CAPTURE_MODE);
+
+out:
+	return ret;
+}
+
+static int __m10mo_set_run_mode(struct v4l2_subdev *sd)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret;
+
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		/* TODO: Differentiate the video mode */
+		ret = m10mo_set_monitor_mode(sd);
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		ret = m10mo_set_still_capture(sd);
+		break;
+	default:
+		ret = m10mo_set_monitor_mode(sd);
+	}
+	return ret;
+}
+
+static int m10mo_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int ret = 0;
+
+	/* TODO: Handle Stream OFF case */
+	mutex_lock(&dev->input_lock);
+	if (enable)
+		ret = __m10mo_set_run_mode(sd);
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int
+m10mo_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	if (fsize->index >= dev->entries_curr_table)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = dev->curr_res_table[fsize->index].width;
+	fsize->discrete.height = dev->curr_res_table[fsize->index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int m10mo_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__m10mo_get_pad_format(struct m10mo_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+m10mo_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct m10mo_device *snr = to_m10mo_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__m10mo_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&snr->input_lock);
+	fmt->format = *format;
+	mutex_unlock(&snr->input_lock);
+
+	return 0;
+}
+
+static int
+m10mo_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct m10mo_device *snr = to_m10mo_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__m10mo_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&snr->input_lock);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+	mutex_unlock(&snr->input_lock);
+
+	return 0;
+}
+
+static const struct media_entity_operations m10mo_entity_ops = {
+	.link_setup = NULL,
+};
+
+static int m10mo_set_flicker_freq(struct v4l2_subdev *sd, s32 val)
+{
+	unsigned int flicker_freq;
+
+	switch (val) {
+	case V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
+		flicker_freq = M10MO_FLICKER_OFF;
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY_50HZ:
+		flicker_freq = M10MO_FLICKER_50HZ;
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY_60HZ:
+		flicker_freq = M10MO_FLICKER_60HZ;
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY_AUTO:
+		flicker_freq = M10MO_FLICKER_AUTO;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return m10mo_writeb(sd, CATEGORY_AE, AE_FLICKER, flicker_freq);
+}
+
+static int m10mo_set_metering(struct v4l2_subdev *sd, s32 val)
+{
+	unsigned int metering;
+
+	switch (val) {
+	case V4L2_EXPOSURE_METERING_CENTER_WEIGHTED:
+		metering = M10MO_METERING_CENTER;
+		break;
+	case V4L2_EXPOSURE_METERING_SPOT:
+		metering = M10MO_METERING_SPOT;
+		break;
+	case V4L2_EXPOSURE_METERING_AVERAGE:
+		metering = M10MO_METERING_AVERAGE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return m10mo_writeb(sd, CATEGORY_AE, AE_MODE, metering);
+}
+
+static int m10mo_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct m10mo_device *dev = container_of(
+		ctrl->handler, struct m10mo_device, ctrl_handler);
+	int ret;
+
+	switch (ctrl->id) {
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		ret = m10mo_set_flicker_freq(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE_METERING:
+		ret = m10mo_set_metering(&dev->sd, ctrl->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int m10mo_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_LINK_FREQ:
+		ctrl->val = M10MO_MIPI_FREQ;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct v4l2_ctrl_ops m10mo_ctrl_ops = {
+	.g_volatile_ctrl = m10mo_g_volatile_ctrl,
+	.s_ctrl = m10mo_s_ctrl,
+};
+
+/* TODO: To move this to s_ctrl framework */
+static int m10mo_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+	int index;
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		index = M10MO_MODE_VIDEO_INDEX;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		index = M10MO_MODE_CAPTURE_INDEX;
+		break;
+	default:
+		index = M10MO_MODE_PREVIEW_INDEX;
+		break;
+	}
+	dev->entries_curr_table = resolutions_sizes[dev->fw_type][index];
+	dev->curr_res_table = resolutions[dev->fw_type][index];
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_LINK_FREQ,
+		.name = "Link Frequency",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 1500000 * 1000,
+		.step = 1,
+		.def = 1,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_POWER_LINE_FREQUENCY,
+		.name = "Light frequency filter",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 3,
+		.max = 3,
+		.step = 1,
+	},
+	{
+		.ops = &m10mo_ctrl_ops,
+		.id = V4L2_CID_EXPOSURE_METERING,
+		.name = "Metering",
+		.type = V4L2_CTRL_TYPE_MENU,
+		.min = 0,
+		.max = 2,
+	},
+
+};
+
+static int __m10mo_init_ctrl_handler(struct m10mo_device *dev)
+{
+	struct v4l2_ctrl_handler *hdl;
+	int ret, i;
+
+	hdl = &dev->ctrl_handler;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls));
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		ret = dev->ctrl_handler.error;
+		v4l2_ctrl_handler_free(&dev->ctrl_handler);
+		return ret;
+	}
+
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = hdl;
+	v4l2_ctrl_handler_setup(hdl);
+
+	dev->link_freq = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_LINK_FREQ);
+	v4l2_ctrl_s_ctrl(dev->link_freq, V4L2_CID_LINK_FREQ);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops m10mo_video_ops = {
+	.try_mbus_fmt = m10mo_try_mbus_fmt,
+	.s_mbus_fmt = m10mo_set_mbus_fmt,
+	.g_mbus_fmt = m10mo_get_mbus_fmt,
+	.s_stream = m10mo_s_stream,
+	.s_parm = m10mo_s_parm,
+	.enum_framesizes = m10mo_enum_framesizes,
+};
+
+static const struct v4l2_subdev_core_ops m10mo_core_ops = {
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
+	.s_power = m10mo_s_power,
+	.init	= m10mo_fw_start,
+};
+
+static const struct v4l2_subdev_pad_ops m10mo_pad_ops = {
+	.enum_mbus_code = m10mo_enum_mbus_code,
+	.get_fmt = m10mo_get_pad_format,
+	.set_fmt = m10mo_set_pad_format,
+
+};
+
+static const struct v4l2_subdev_ops m10mo_ops = {
+	.core	= &m10mo_core_ops,
+	.pad	= &m10mo_pad_ops,
+	.video	= &m10mo_video_ops,
+};
+
+static int dump_fw(struct m10mo_device *dev)
+{
+	int ret = 0;
+	mutex_lock(&dev->input_lock);
+	if (dev->power == 1) {
+		ret = -EBUSY;
+		goto leave;
+	}
+	__m10mo_s_power(&dev->sd, 1, true);
+	m10mo_dump_fw(dev);
+	__m10mo_s_power(&dev->sd, 0, true);
+leave:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int read_fw_checksum(struct m10mo_device *dev, u16 *result)
+{
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power == 1) {
+		ret = -EBUSY;
+		goto leave;
+	}
+	__m10mo_s_power(&dev->sd, 1, true);
+	ret = m10mo_fw_checksum(dev, result);
+	__m10mo_s_power(&dev->sd, 0, true);
+leave:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int read_fw_version(struct m10mo_device *dev, char *buf)
+{
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power == 1) {
+		ret = -EBUSY;
+		goto leave;
+	}
+	__m10mo_s_power(&dev->sd, 1, true);
+	ret = m10mo_get_isp_fw_version_string(dev, buf, M10MO_MAX_FW_ID_STRING);
+	__m10mo_s_power(&dev->sd, 0, true);
+leave:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int update_fw(struct m10mo_device *dev)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int ret = 0;
+	u16 result;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power == 1) {
+		ret = -EBUSY;
+		goto leave;
+	}
+	__m10mo_s_power(&dev->sd, 1, true);
+	ret = m10mo_program_device(dev);
+	__m10mo_s_power(&dev->sd, 0, true);
+	if (ret)
+		goto leave;
+	/* Power cycle chip and re-identify the version */
+	__m10mo_s_power(&dev->sd, 1, true);
+	ret = m10mo_identify_fw_type(&dev->sd);
+	__m10mo_s_power(&dev->sd, 0, true);
+	if (ret)
+		goto leave;
+
+	__m10mo_s_power(&dev->sd, 1, true);
+	ret = m10mo_fw_checksum(dev, &result);
+	__m10mo_s_power(&dev->sd, 0, true);
+	dev_info(&client->dev, "m10mo FW checksum: %d\n", result);
+
+leave:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static ssize_t m10mo_flash_rom_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "flash\n");
+}
+
+static ssize_t m10mo_flash_rom_store(struct device *dev,
+                                  struct device_attribute *attr,
+                                  const char *buf, size_t len)
+{
+	struct m10mo_device *m10mo_dev = dev_get_drvdata(dev);
+
+	if (!strncmp(buf, "flash", 5)) {
+		update_fw(m10mo_dev);
+		return len;
+	}
+	return -EINVAL;
+}
+static DEVICE_ATTR(isp_flashfw, S_IRUGO | S_IWUSR, m10mo_flash_rom_show,
+		   m10mo_flash_rom_store);
+
+static ssize_t m10mo_flash_spi_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct m10mo_device *m10mo_dev = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", m10mo_get_spi_state(m10mo_dev));
+}
+
+static ssize_t m10mo_flash_spi_store(struct device *dev,
+                                  struct device_attribute *attr,
+                                  const char *buf, size_t len)
+{
+	struct m10mo_device *m10mo_dev = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	if (strict_strtoul(buf, 0, &value))
+		return -EINVAL;
+
+	ret = m10mo_set_spi_state(m10mo_dev, value);
+	if (ret)
+		return ret;
+	return len;
+}
+static DEVICE_ATTR(isp_spi, S_IRUGO | S_IWUSR, m10mo_flash_spi_show,
+		   m10mo_flash_spi_store);
+
+static ssize_t m10mo_flash_checksum_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct m10mo_device *m10_dev = dev_get_drvdata(dev);
+	ssize_t ret;
+	u16 result;
+
+	ret  = read_fw_checksum(m10_dev, &result);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%04x\n", result);
+}
+static DEVICE_ATTR(isp_checksum, S_IRUGO, m10mo_flash_checksum_show, NULL);
+
+static ssize_t m10mo_flash_version_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct m10mo_device *m10_dev = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	ret  = read_fw_version(m10_dev, buf);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%s\n", buf);
+}
+static DEVICE_ATTR(isp_version, S_IRUGO, m10mo_flash_version_show, NULL);
+
+static ssize_t m10mo_flash_dump_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct m10mo_device *m10_dev = dev_get_drvdata(dev);
+	dump_fw(m10_dev);
+	return sprintf(buf, "done\n");
+}
+static DEVICE_ATTR(isp_fw_dump, S_IRUGO, m10mo_flash_dump_show, NULL);
+
+static struct attribute *sysfs_attrs_ctrl[] = {
+	&dev_attr_isp_flashfw.attr,
+	&dev_attr_isp_checksum.attr,
+	&dev_attr_isp_fw_dump.attr,
+	&dev_attr_isp_spi.attr,
+	&dev_attr_isp_version.attr,
+	NULL
+};
+
+static struct attribute_group m10mo_attribute_group[] = {
+	{.attrs = sysfs_attrs_ctrl },
+};
+
+static int m10mo_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct m10mo_device *dev = to_m10mo_sensor(sd);
+
+	sysfs_remove_group(&client->dev.kobj,
+			   m10mo_attribute_group);
+
+	if (dev->pdata->common.platform_deinit)
+		dev->pdata->common.platform_deinit();
+
+	media_entity_cleanup(&dev->sd.entity);
+	v4l2_device_unregister_subdev(sd);
+	free_irq(client->irq, sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static int m10mo_probe(struct i2c_client *client,
+				  const struct i2c_device_id *id)
+{
+	struct m10mo_device *dev;
+	struct camera_mipi_info *mipi_info = NULL;
+	int ret;
+
+	if (!client->dev.platform_data) {
+		dev_err(&client->dev, "platform data missing\n");
+		return -ENODEV;
+	}
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	/*
+	 * This I2C device is created by atomisp driver. Atomisp driver has
+	 * a nasty assumption that all sensors uses similar platform data.
+	 * For this driver we need more information. Platform data what was
+	 * received with I2C device data structure points to the common
+	 * structure. Pick the real platform data for this driver.
+	 */
+	dev->pdata = container_of(client->dev.platform_data,
+				  struct m10mo_platform_data,
+				  common);
+
+	dev->mode = M10MO_POWERED_OFF;
+	dev->requested_mode = M10MO_NO_MODE_REQUEST;
+
+	mutex_init(&dev->input_lock);
+
+	v4l2_i2c_subdev_init(&(dev->sd), client, &m10mo_ops);
+
+	ret = m10mo_s_config(&dev->sd, client->irq);
+	if (ret)
+		goto out_free;
+
+	/*
+	 * We must have a way to reset the chip. If that is missing we
+	 * simply can't continue.
+	 */
+	if (!dev->pdata->common.gpio_ctrl) {
+		dev_err(&client->dev, "gpio control function missing\n");
+		ret = -ENODEV;
+		goto out_free_irq;
+	}
+
+	mipi_info = v4l2_get_subdev_hostdata(&dev->sd);
+
+	ret = __m10mo_init_ctrl_handler(dev);
+	if (ret)
+		goto out_free_irq;
+
+	if (mipi_info)
+		dev->num_lanes = mipi_info->num_lanes;
+
+	dev->curr_res_table = resolutions[0][M10MO_MODE_PREVIEW_INDEX];
+	dev->entries_curr_table = resolutions_sizes[0][M10MO_MODE_PREVIEW_INDEX];
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.ops = &m10mo_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	dev->format.code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		goto out_free_irq;
+
+	ret = sysfs_create_group(&client->dev.kobj,
+				m10mo_attribute_group);
+	if (ret) {
+		dev_err(&client->dev, "%s Failed to create sysfs\n", __func__);
+		goto out_sysfs_fail;
+	}
+
+	/* Request SPI interface to enable FW update over the SPI */
+	if (dev->pdata->spi_setup)
+		dev->pdata->spi_setup(&dev->pdata->spi_pdata, dev);
+
+	return 0;
+
+out_sysfs_fail:
+	media_entity_cleanup(&dev->sd.entity);
+out_free_irq:
+	free_irq(client->irq, &dev->sd);
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+static const struct i2c_device_id m10mo_id[] = {
+	{ M10MO_NAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, m10mo_id);
+
+static struct i2c_driver m10mo_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = M10MO_NAME,
+	},
+	.probe = m10mo_probe,
+	.remove = m10mo_remove,
+	.id_table = m10mo_id,
+};
+
+static __init int init_m10mo(void)
+{
+	return i2c_add_driver(&m10mo_driver);
+}
+
+static __exit void exit_m10mo(void)
+{
+	i2c_del_driver(&m10mo_driver);
+}
+
+module_init(init_m10mo);
+module_exit(exit_m10mo);
+
+MODULE_DESCRIPTION("M10MO ISP driver");
+MODULE_AUTHOR("Kriti Pachhandara <kriti.pachhandara@intel.com>");
+MODULE_LICENSE("GPL");
+
+
+
+
+
+
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
new file mode 100644
index 0000000..a41d18f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo.h
@@ -0,0 +1,359 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Partially based on m-5mols kernel driver,
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ *
+ * Partially based on jc_v4l2 kernel driver from http://opensource.samsung.com
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef M10MO_REG_H
+#define M10MO_REG_H
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define M10MO_NAME 			"m10mo"
+#define M10MO_ADDR   			0x1f
+#define M10MO_I2C_RETRY			5
+#define M10MO_MIPI_FREQ			(963000000/2)
+#define M10MO_INIT_TIMEOUT		500
+#define M10MO_BOOT_TIMEOUT		50
+
+#define M10MO_MIN_EV -3
+#define M10MO_MAX_EV  3
+#define M10MO_FLICKER_AUTO 		0x00
+#define M10MO_FLICKER_50HZ 		0x01
+#define M10MO_FLICKER_60HZ 		0x02
+#define M10MO_FLICKER_OFF 		0x03
+#define M10MO_METERING_CENTER		0x00
+#define M10MO_METERING_SPOT		0x01
+#define M10MO_METERING_AVERAGE		0x02
+
+#define M10MO_INVALID_CHECKSUM          0xffff
+#define M10MO_VALID_CHECKSUM            0
+
+/* M10MO I2C commands */
+#define M10MO_BYTE_READ			0x01
+#define M10MO_BYTE_WRITE		0x02
+#define M10MO_MEMORY_READ_8BIT		0x03
+#define M10MO_MEMORY_WRITE_8BIT		0x04
+#define M10MO_MEMORY_READ_16BIT		0x05
+#define M10MO_MEMORY_WRITE_16BIT	0x06
+#define M10MO_MEMORY_READ_32BIT		0x07
+#define M10MO_MEMORY_WRITE_32BIT	0x08
+
+struct m10mo_spi {
+	int spi_enabled;
+	struct spi_device *spi_device;
+	int (*write)(struct spi_device *spi, const u8 *addr,
+		     const int len, const int txSize);
+	int (*read)(struct spi_device *spi, u8 *buf, size_t len,
+		    const int rxSize);
+};
+
+struct m10mo_version {
+	int customer;
+	int project;
+	int firmware;
+	int hardware;
+	int parameter;
+	int awb;
+};
+
+struct m10mo_resolution {
+	u32 width;
+	u32 height;
+	u32 command;
+};
+
+struct m10mo_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct m10mo_platform_data *pdata;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	struct m10mo_spi *spi;
+	u8 message_buffer[256]; /* Real buffer size TBD */
+	int res_type;
+	int power;
+	u8 fps;
+	u8 requested_mode;
+	u8 mode;
+	int fmt_idx;
+	wait_queue_head_t irq_waitq;
+	unsigned int bad_fw:1;
+	unsigned int isp_ready:1;
+	unsigned int initialized;
+	struct m10mo_version ver;
+	struct v4l2_ctrl_handler ctrl_handler;
+	int run_mode;
+	struct v4l2_ctrl *link_freq;
+	unsigned int num_lanes;
+	const struct m10mo_resolution *curr_res_table;
+	int entries_curr_table;
+	int ref_clock;
+	int fw_type;
+};
+
+#define to_m10mo_sensor(x) container_of(x, struct m10mo_device, sd)
+
+int m10mo_memory_read(struct v4l2_subdev *sd, u16 len, u32 addr, u8 *val);
+int m10mo_memory_write(struct v4l2_subdev *sd, u8 cmd, u16 len, u32 addr, u8 *val);
+int m10mo_writeb(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val);
+int m10mo_writew(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val);
+int m10mo_writel(struct v4l2_subdev *sd, u8 category, u8 reg, u32 val);
+int m10mo_readb(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val);
+int m10mo_readw(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val);
+int m10mo_readl(struct v4l2_subdev *sd, u8 category, u8 reg, u32 *val);
+int m10mo_setup_flash_controller(struct v4l2_subdev *sd);
+
+void m10mo_register_spi_fw_flash_interface(struct m10mo_device *dev,
+					   struct m10mo_spi *m10mo_spi_dev);
+
+int m10mo_dump_fw(struct m10mo_device *m10mo_dev);
+int m10mo_get_isp_fw_version_string(struct m10mo_device *dev, char *buf, int len);
+int m10mo_fw_checksum(struct m10mo_device *dev, u16 *result);
+int m10mo_program_device(struct m10mo_device *m10mo_dev);
+
+int m10mo_get_spi_state(struct m10mo_device *m10mo_dev);
+int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled);
+
+/* Below contents are based on the M10MO_categoryParameter-a1.xls */
+
+/* Category register */
+#define CATEGORY_SYSTEM		0x00
+#define CATEGORY_PARAM		0x01	/* Monitor & Still Parameter A */
+#define CATEGORY_MONITOR	0x02  /* Monitor & Still Parameter B */
+#define CATEGORY_AE		0x03
+#define CATEGORY_WB		0x06
+#define CATEGORY_EXIF		0x07  /* Exif Information */
+#define CATEGORY_LENS		0x0a	/* AF Control */
+#define CATEGORY_CAPTURE_PARAM	0x0b	/* Still Picture parameter */
+#define CATEGORY_CAPTURE_CTRL	0x0c  /* Still picture control */
+#define CATEGORY_FLASHROM	0x0f	/* FlashROM-Writer Mode only */
+
+/* Category 0_SYSTEM mode */
+#define SYSTEM_CUSTOMER_CODE	0x00
+#define SYSTEM_PROJECT_CODE	0x01
+#define SYSTEM_VER_FIRMWARE	0x02
+#define SYSTEM_VER_HARDWARE	0x04
+#define SYSTEM_VER_PARAMETER	0x06
+#define SYSTEM_VER_AWB		0x08
+
+#define SYSTEM_SYSMODE			0x0b
+/* SYSTEM mode status */
+#define SYSTEM_STATUS			0x0c
+
+/* interrupt enable register */
+#define SYSTEM_INT_ENABLE		0x10
+#define REG_INT_EN_MODE			(1 << 0)
+#define REG_INT_AF			(1 << 1)
+#define REG_INT_EN_ZOOM			(1 << 2)
+#define REG_INT_EN_CAPTURE		(1 << 3)
+#define REG_INT_EN_FRAMESYNC		(1 << 4)
+#define REG_INT_EN_FD			(1 << 5)
+#define REG_INT_EN_SOUND		(1 << 7)
+#define REG_REG_INT_MASK		0x0f
+
+/* Interrupt factor (pending) register */
+#define SYSTEM_INT_FACTOR	0x1c
+#define REG_INT_STATUS_MODE	(1 << 0)
+#define REG_INT_STATUS_ZOOM	(1 << 2)
+#define REG_INT_STATUS_CAPTURE	(1 << 3)
+#define REG_INT_STATUS_FRAMESYNC (1 << 4)
+#define REG_INT_STATUS_FD	(1 << 5)
+#define REG_INT_STATUS_SOUND	(1 << 7)
+
+/* category 1_PARAMETER mode */
+#define PARAM_MON_SIZE			0x01
+#define PARAM_MON_FPS			0x02
+#define REG_FPS_30			0x02
+#define PARAM_OUTPUT_IF_SEL		0x00
+#define REG_OUTPUT_INTERFACE_MIPI	0x02
+#define PARAM_MIPI_OUT_LANE_NUM		0x3e
+#define REG_OUTPUT_MIPI_4LANE		0x04
+
+/* Category 2_MONITOR mode */
+
+#define MONITOR_ZOOM		0x01
+#define MONITOR_CFIXR		0x0a
+#define MONITOR_CFIXB		0x09
+#define MONITOR_COLOR_EFFECT	0x0b
+#define MONITOR_ZSL_MODE_STATUS	0x5f
+#define REG_NORMAL_MONITOR	0x00
+#define REG_ZSL_MONITOR 	0x01
+
+
+/* Category 3_Auto Exposure */
+
+#define AE_LOCK			0x00
+#define REG_AE_UNLOCK		0x00
+#define REG_AE_LOCK		0x01
+#define AE_MODE			0x01
+#define REG_AE_OFF		0x00
+#define AE_TARGET		0x02
+#define AE_SPEED		0x03
+#define AE_FLICKER		0x06
+#define AE_FLICKER_AUTO		0x07
+#define AE_EV_BIAS		0x09
+#define AE_AUTO_BRACKET_EV1	0x20
+#define AE_AUTO_BRACKET_EV2	0x21
+
+
+
+/* Category 6_White Balance */
+
+#define AWB_LOCK		0x00
+#define REG_AWB_OFF		0x00
+#define REG_AWB_ON		0x01
+#define AWB_ADJUST_MODE 	0x01
+#define AWB_MODE		0x02
+#define REG_AWB_AUTO		0x01
+#define AWB_MANUAL		0x03
+#define REG_AWB_INCANDESCENT	0x01
+#define REG_AWB_FLUORESCENT_1	0x02
+#define REG_AWB_FLUORESCENT_2	0x03
+#define REG_AWB_DAYLIGHT	0x04
+#define REG_AWB_CLOUDY		0x05
+#define REG_AWB_SHADE		0x06
+#define REG_AWB_HORIZON		0x07
+#define REG_AWB_LEDLIGHT	0x09
+#define AWB_SPEED		0x04
+#define AWB_RANGE		0x05
+
+/* Category 7_EXIF */
+#define EXIF_INFO_EXPTIME_NU	0x00
+#define EXIF_INFO_EXPTIME_DE	0x04
+#define EXIF_INFO_TV_NU		0x08
+#define EXIF_INFO_TV_DE		0x0c
+#define EXIF_INFO_AV_NU		0x10
+#define EXIF_INFO_AV_DE		0x14
+#define EXIF_INFO_BV_NU		0x18
+#define EXIF_INFO_BV_DE		0x1c
+#define EXIF_INFO_EBV_NU	0x20
+#define EXIF_INFO_EBV_DE	0x24
+#define EXIF_INFO_ISO		0x28
+#define EXIF_INFO_FLASH		0x2a
+#define EXIF_INFO_SDR		0x2c
+#define EXIF_INFO_QVAL		0x2e
+
+
+/* Category A_Lens Parameter */
+#define AF_MODE			0x01
+#define REG_AF_NORMAL		0x01
+#define REG_AF_MACRO		0x03
+#define REG_AF_POWEROFF		0x07
+
+#define AF_START		0x02
+#define REG_AF_STOP		0x00
+#define REG_AF_EXE_AUTO		0x01
+#define REG_AF_EXE_CAF		0x02
+
+#define AF_RESULT		0x03
+#define REG_AF_FAIL		0x02
+#define REG_AF_SUCCESS		0x01
+#define REG_AF_IDLE		0x03
+#define REG_AF_BUSY		0x04
+
+/* Category B_CAPTURE Parameter */
+#define CAPP_YUVOUT_MAIN	0x00
+#define REG_YUV422		0x00
+#define REG_BAYER10		0x07
+#define REG_BAYER8		0x08
+#define REG_JPEG		0x01
+
+#define CAPP_MAIN_IMAGE_SIZE	0x01
+#define CAPP_JPEG_SIZE_MAX	0x0f
+#define CAPP_JPEG_RATIO		0x17
+#define CAPP_JPEG_DUAL_RATIO	0x18
+
+/* Category C_CAPTURE Control */
+#define CAPC_MODE		0x00
+#define REG_CAP_NONE		0x00
+#define REG_CAP_ANTI_SHAKE	0x02
+#define CAPC_SEL_FRAME_MAIN	0x06
+#define CAPC_TRANSFER_START	0x09
+#define REG_CAP_START_MAIN	0x01
+
+/* Category F_Flash */
+#define REG_FLASH_ADD           0x00
+#define REG_FLASH_BYTE          0x04
+#define REG_FLASH_ERASE         0x06
+#define REG_FLASH_WRITE         0x07
+#define REG_FLASH_CHECK         0x09
+#define REG_FLASH_SUM           0x0a
+#define REG_CAM_START_ADD       0x0c
+#define REG_CAM_START           0x12
+#define REG_DATA_RAM_ADDR       0x14
+#define REG_DATA_TRANS_SIZE     0x18
+#define REG_PLL_VALUES          0x1c /* 2 dividers, 2 multipliers */
+#define REG_SDRAM_CFG           0x48
+#define REG_RAM_START           0x4a
+#define REG_SIO_MODE            0x4b
+#define REG_FW_READ             0x57
+#define REG_CHECK_SUM_SIZE      0x5c
+
+#define REG_RAM_START_SRAM      0x01
+#define REG_RAM_START_SDRAM     0x02
+
+#define REG_FLASH_WRITE_START_PRG      0x01
+
+#define REG_FLASH_ERASE_SECTOR_ERASE   0x01
+#define REG_FLASH_ERASE_CHIP_ERASE     0x02
+#define REG_FLASH_ERASE_BLOCK64k_ERASE 0x04
+#define REG_FLASH_ERASE_BLOCK32k_ERASE 0x08
+
+#define REG_FW_READ_CMD_READ    0x01
+#define REG_FW_READ_CMD_NONE    0x00
+
+#define REG_SIO_MODE_RISING_LATCH 0x4c
+#define REG_SIO_MODE_FALLING_LATCH 0x44
+
+/* Starts internal ARM core, 1st command to be sent to ISP */
+#define FLASH_CAM_START		REG_CAM_START
+
+/* Internal modes of M10MO */
+enum M10MO_MODES {
+	M10MO_NO_MODE_REQUEST,
+	M10MO_POWERED_OFF,
+	M10MO_POWERING_ON,
+	M10MO_FLASH_WRITE_MODE,
+	M10MO_PARAM_SETTING_MODE,
+	M10MO_MONITOR_MODE,
+	M10MO_SINGLE_CAPTURE_MODE
+};
+
+#define M10MO_MODE_PREVIEW_INDEX	0
+#define M10MO_MODE_CAPTURE_INDEX	1
+#define M10MO_MODE_VIDEO_INDEX		2
+extern const struct m10mo_resolution *resolutions[][3];
+extern const ssize_t resolutions_sizes[][3];
+
+#endif	/* M10MO_H */
+
+
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
new file mode 100644
index 0000000..161017c
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_fw.c
@@ -0,0 +1,718 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Partially based on m-5mols kernel driver,
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ *
+ * Partially based on jc_v4l2 kernel driver from http://opensource.samsung.com
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/atomisp_platform.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/spi/spi.h>
+#include <media/v4l2-device.h>
+#include <linux/sizes.h>
+#include "m10mo.h"
+
+
+/*
+ * Currently the FW image and dump paths are hardcoded here.
+ * TBD: flexible interface for defining proper path as needed
+ */
+#define M10MO_FW_DUMP_PATH "/data/M10MO_dump.bin"
+#define M10MO_FW_NAME "M10MO_fw.bin"
+
+#define SRAM_BUFFER_ADDRESS 0x01100000
+#define SDRAM_BUFFER_ADDRESS 0x20000000
+
+#define M10MO_FLASH_READ_BASE_ADDR	0x18000000
+#define PLL_SETTINGS_24MHZ 0x00170141
+#define PLL_SETTINGS_19_2MHZ 0x001d0152
+
+#define PORT_SETTINGS0_ADDR  0x90001200
+#define PORT_SETTINGS1_ADDR  0x90001000
+#define PORT_SETTINGS2_ADDR  0x90001100
+
+#define PORT_SETTING_DELAY   (10*1000)
+#define I2C_DELAY	     (10*1000)
+
+#define I2C_DUMP_SIZE	     0x20 /* keep as power of 2 values */
+#define FW_SIZE		     0x00200000
+#define FLASH_BLOCK_SIZE     0x10000
+#define SIO_BLOCK_SIZE	     8192
+#define DUMP_BLOCK_SIZE      0x1000
+
+#define FW_VERSION_INFO_ADDR 0x181EF080
+
+#define ONE_WRITE_SIZE	     64
+
+#define ONE_WAIT_LOOP_TIME   10 /* milliseconds */
+#define CHIP_ERASE_TIMEOUT (15000 / ONE_WAIT_LOOP_TIME)
+#define SECTOR_ERASE_TIMEOUT (5000 / ONE_WAIT_LOOP_TIME)
+#define PROGRAMMING_TIMEOUT (15000 / ONE_WAIT_LOOP_TIME)
+#define CHECKSUM_TIMEOUT   (5000 / ONE_WAIT_LOOP_TIME)
+#define STATE_TRANSITION_TIMEOUT (3000 / ONE_WAIT_LOOP_TIME)
+
+/* Tables for m10mo pin configurations */
+static const u8 buf_port_settings0_m10mo[] = {
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C,
+		  0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x05,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
+		 };
+
+static const u8 buf_port_settings1_m10mo[] = {
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		 };
+
+static const u8 buf_port_settings2_m10mo[] = {
+		  0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x14,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		 };
+
+static int m10mo_set_flash_address(struct v4l2_subdev *sd, u32 addr)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	ret = m10mo_writel(sd, CATEGORY_FLASHROM, REG_FLASH_ADD, addr);
+	if (ret)
+		dev_err(&client->dev, "Set flash address failed\n");
+	return ret;
+}
+
+static u32 m10mo_get_pll_cfg(u32 freq)
+{
+	u32 ret;
+	switch(freq) {
+	case 24000000:
+		ret = PLL_SETTINGS_24MHZ;
+		break;
+	case 19200000:
+		ret = PLL_SETTINGS_19_2MHZ;
+		break;
+	default:
+		/* Defaults to development board xtal freq */
+		ret = PLL_SETTINGS_24MHZ;
+		break;
+	}
+	return ret;
+}
+
+static int m10mo_wait_operation_complete(struct v4l2_subdev *sd, u8 reg,
+					 u32 timeout)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int res;
+	do {
+		msleep(ONE_WAIT_LOOP_TIME);
+		m10mo_readb(sd, CATEGORY_FLASHROM, reg, &res);
+	} while ((res != 0) && --timeout);
+
+	if (!timeout) {
+		dev_err(&client->dev,
+			"timeout while waiting for chip op to finish");
+		return -ETIME;
+	}
+	return 0;
+}
+
+static int m10mo_to_fw_access_mode(struct m10mo_device *m10mo_dev)
+{
+	struct v4l2_subdev *sd = &m10mo_dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT, SZ_64,
+				 PORT_SETTINGS0_ADDR , (u8 *)buf_port_settings0_m10mo);
+	if (err)
+		goto fail;
+
+	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY);
+
+	err = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT, SZ_64,
+				 PORT_SETTINGS1_ADDR, (u8 *)buf_port_settings1_m10mo);
+	if (err)
+		goto fail;
+
+	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY);
+
+	err = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT, SZ_64,
+				 PORT_SETTINGS2_ADDR, (u8 *)buf_port_settings2_m10mo);
+	if (err)
+		goto fail;
+	usleep_range(PORT_SETTING_DELAY, PORT_SETTING_DELAY);
+
+	err = m10mo_writel(sd, CATEGORY_FLASHROM,
+			   REG_PLL_VALUES,
+			   m10mo_get_pll_cfg(m10mo_dev->ref_clock));
+	if (err)
+		goto fail;
+	return 0;
+fail:
+	dev_err(&client->dev, "transition to fw mode failed\n");
+	return err;
+}
+
+
+static int m10mo_memory_dump(struct m10mo_device *m10mo_dev, u16 len,
+			     u32 addr, u8 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&m10mo_dev->sd);
+	struct i2c_msg msg;
+	unsigned char data[8];
+	u16 len_received;
+	int i, err = 0;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	if (len >= (sizeof(m10mo_dev->message_buffer) - 3))
+		return -EINVAL;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = sizeof(data);
+	msg.buf = data;
+
+	/* high byte goes out first */
+	data[0] = 0x00;
+	data[1] = M10MO_MEMORY_READ_8BIT;
+	data[2] = (addr >> 24) & 0xFF;
+	data[3] = (addr >> 16) & 0xFF;
+	data[4] = (addr >> 8) & 0xFF;
+	data[5] = addr & 0xFF;
+	data[6] = (len >> 8) & 0xFF;
+	data[7] = len & 0xFF;
+
+	for (i = M10MO_I2C_RETRY; i; i--) {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err == 1)
+			break;
+		usleep_range(I2C_DELAY, I2C_DELAY);
+	}
+
+	if (err != 1)
+		return err;
+
+	msg.flags = I2C_M_RD;
+	msg.len = len + 3;
+	msg.buf = m10mo_dev->message_buffer;
+	for (i = M10MO_I2C_RETRY; i; i--) {
+		err = i2c_transfer(client->adapter, &msg, 1);
+		if (err == 1)
+			break;
+		usleep_range(I2C_DELAY, I2C_DELAY);
+	}
+
+	if (err != 1)
+		return err;
+
+	len_received = m10mo_dev->message_buffer[1] << 8 |
+		m10mo_dev->message_buffer[2];
+	if (len != len_received)
+		dev_err(&client->dev,
+			"expected length %d, but return length %d\n",
+			len, len_received);
+
+	memcpy(val, m10mo_dev->message_buffer + 3, len);
+	return err;
+}
+
+int m10mo_dump_fw(struct m10mo_device *m10mo_dev)
+{
+	struct v4l2_subdev *sd = &m10mo_dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct file *fp;
+	mm_segment_t old_fs;
+	u8 *buf;
+	u32 addr, unit, count;
+	int i;
+	int err;
+
+	dev_dbg(&client->dev, "Begin FW dump to file %s\n", M10MO_FW_DUMP_PATH);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	fp = filp_open(M10MO_FW_DUMP_PATH,
+		O_WRONLY|O_CREAT|O_TRUNC, S_IRUGO|S_IWUGO|S_IXUSR);
+	if (IS_ERR(fp)) {
+		dev_err(&client->dev,
+			"failed to open %s, err %ld\n",
+			M10MO_FW_DUMP_PATH, PTR_ERR(fp));
+		err = -ENOENT;
+		goto out_file;
+	}
+
+	err = m10mo_to_fw_access_mode(m10mo_dev);
+	if (err)
+		goto out_close;
+
+	buf = kmalloc(DUMP_BLOCK_SIZE, GFP_KERNEL);
+	if (!buf) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		err = -ENOMEM;
+		goto out_close;
+	}
+
+	err = m10mo_writeb(sd, CATEGORY_FLASHROM,
+			   REG_FW_READ, REG_FW_READ_CMD_READ);
+
+	if (err) {
+		dev_err(&client->dev, "FW read cmd failed %d\n", err);
+		goto out_mem_free;
+	}
+
+	addr = M10MO_FLASH_READ_BASE_ADDR;
+	unit = I2C_DUMP_SIZE;
+	count = FW_SIZE / I2C_DUMP_SIZE;
+	for (i = 0; i < count; i++) {
+		err = m10mo_memory_dump(m10mo_dev,
+					unit,
+					addr + (i * unit),
+					buf);
+		if (err < 0) {
+			dev_err(&client->dev, "Memory dump failed %d\n", err);
+			goto out_mem_free;
+		}
+		vfs_write(fp, buf, unit, &fp->f_pos);
+	}
+	dev_dbg(&client->dev, "End of FW dump to file\n");
+
+out_mem_free:
+	kfree(buf);
+out_close:
+	if (!IS_ERR(fp))
+		filp_close(fp, current->files);
+out_file:
+	set_fs(old_fs);
+
+	return err;
+}
+
+int m10mo_get_isp_fw_version_string(struct m10mo_device *dev, char *buf, int len)
+{
+	int err;
+	struct v4l2_subdev *sd = &dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	err = m10mo_to_fw_access_mode(dev);
+	if (err)
+		return err;
+
+	err = m10mo_writeb(sd, CATEGORY_FLASHROM,
+				REG_FW_READ, REG_FW_READ_CMD_READ);
+	if (err) {
+		dev_err(&client->dev, "Read mode transition fail: %d\n", err);
+		return err;
+	}
+	msleep(10);
+
+	memset(buf, 0, len);
+	err = m10mo_memory_read(sd, len - 1, FW_VERSION_INFO_ADDR,
+				buf);
+	if (err)
+		dev_err(&client->dev, "version read failed\n");
+
+	/* Return value checking intentionally omitted */
+	(void) m10mo_writeb(sd, CATEGORY_FLASHROM,
+			    REG_FW_READ, REG_FW_READ_CMD_NONE);
+	return err;
+}
+
+int m10mo_fw_checksum(struct m10mo_device *dev, u16 *result)
+{
+	int err;
+	struct v4l2_subdev *sd = &dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int res = 0;
+
+	err = m10mo_setup_flash_controller(sd);
+	if (err)
+		goto leave;
+
+	err = m10mo_to_fw_access_mode(dev);
+	if (err)
+		goto leave;
+
+	/* Set start address to 0*/
+	err = m10mo_set_flash_address(sd, 0x0);
+	if (err)
+		goto leave;
+
+	/* request checksum */
+	err = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_FLASH_CHECK, 4);
+	if (err) {
+		dev_err(&client->dev, "Request checksum failed\n");
+		goto leave;
+	}
+
+	err = m10mo_wait_operation_complete(sd, REG_FLASH_CHECK,
+					    CHECKSUM_TIMEOUT);
+	if (err)
+		goto leave;
+
+	err = m10mo_readw(sd, CATEGORY_FLASHROM, REG_FLASH_SUM , &res);
+	if (err) {
+		dev_err(&client->dev, "Checksum read failed\n");
+		goto leave;
+	}
+	*result = (u16)res;
+leave:
+	return err;
+}
+
+int m10mo_sector_erase_flash(struct m10mo_device *dev, u32 sector_addr)
+{
+	int ret;
+	struct v4l2_subdev *sd = &dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	/*
+	 * Preconditions - system is already in flash access mode,
+	 * plls configured
+	 */
+
+	/* Set start address */
+	ret = m10mo_set_flash_address(sd, sector_addr);
+	if (ret)
+		return ret;
+
+	ret = m10mo_writeb(sd, CATEGORY_FLASHROM,
+			   REG_FLASH_ERASE,
+			   REG_FLASH_ERASE_SECTOR_ERASE);
+	if (ret) {
+		dev_err(&client->dev, "Checksum cmd failed\n");
+		return ret;
+	}
+
+	ret = m10mo_wait_operation_complete(sd, REG_FLASH_ERASE,
+					    SECTOR_ERASE_TIMEOUT);
+	return ret;
+}
+
+/* Full chip erase */
+int m10mo_chip_erase_flash(struct m10mo_device *dev)
+{
+	struct v4l2_subdev *sd = &dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	/*
+	 * Preconditions - system is already in flash access mode,
+	 * plls configured
+	 */
+
+	/* Setup internal RAM */
+	ret = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_RAM_START,
+			   REG_RAM_START_SRAM);
+	if (ret) {
+		dev_err(&client->dev, "Ram setup failed\n");
+		return ret;
+	}
+
+	/* Set start address to 0*/
+	ret = m10mo_set_flash_address(sd, 0x0);
+	if (ret)
+		return ret;
+
+	/* chip erase command */
+	ret = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_FLASH_ERASE,
+			   REG_FLASH_ERASE_CHIP_ERASE);
+	if (ret) {
+		dev_err(&client->dev, "Chip erase cmd failed\n");
+		return ret;
+	}
+	ret = m10mo_wait_operation_complete(sd, REG_FLASH_ERASE,
+					    CHIP_ERASE_TIMEOUT);
+	return ret;
+}
+
+int m10mo_flash_write_block(struct m10mo_device *dev, u32 target_addr,
+			    u8 *block, u32 block_size)
+{
+	struct v4l2_subdev *sd = &dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	int ret;
+	u32 ram_buffer = SRAM_BUFFER_ADDRESS;
+	int i;
+
+	ret = m10mo_set_flash_address(sd, target_addr);
+	if (ret)
+		return ret;
+
+	/* Set block size of 64k == 0 as reg value */
+	ret = m10mo_writew(sd, CATEGORY_FLASHROM, REG_FLASH_BYTE, 0);
+	if (ret) {
+		dev_err(&client->dev, "Set flash block size failed\n");
+		return ret;
+	}
+
+	for (i = 0; i < block_size / ONE_WRITE_SIZE; i++) {
+		ret = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT,
+					 ONE_WRITE_SIZE,
+					 ram_buffer, block);
+		if (ret) {
+			/* Retry once */
+			dev_err(&client->dev,
+				"Write block data send retry\n");
+			ret = m10mo_memory_write(sd, M10MO_MEMORY_WRITE_8BIT,
+						 ONE_WRITE_SIZE,
+						 ram_buffer, block);
+			if (ret) {
+				dev_err(&client->dev,
+					"Write block data send failed\n");
+				return ret;
+			}
+		}
+		ram_buffer += ONE_WRITE_SIZE;
+		block += ONE_WRITE_SIZE;
+	}
+
+	/* Program block */
+	ret = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_FLASH_WRITE,
+			   REG_FLASH_WRITE_START_PRG);
+	if (ret) {
+		dev_err(&client->dev, "FW program block failed\n");
+		return ret;
+	}
+
+	ret = m10mo_wait_operation_complete(sd, REG_FLASH_WRITE, PROGRAMMING_TIMEOUT);
+
+	return ret;
+}
+
+static int m10mo_sio_write(struct m10mo_device *m10mo_dev, u8 *buf)
+{
+	int ret;
+	struct v4l2_subdev *sd = &m10mo_dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!m10mo_dev->spi) {
+		dev_err(&client->dev, "No spi device available");
+		return -ENODEV;
+	}
+
+	/* Set SIO destination address */
+	ret = m10mo_writel(sd, CATEGORY_FLASHROM, REG_DATA_RAM_ADDR,
+			   SDRAM_BUFFER_ADDRESS);
+	if (ret) {
+		dev_err(&client->dev, "sio address setting failed\n");
+		return ret;
+	}
+
+	/* Set programming size - multiples of 16 bytes */
+	ret = m10mo_writel(sd, CATEGORY_FLASHROM, REG_DATA_TRANS_SIZE,
+			   FW_SIZE / 16);
+	if (ret) {
+		dev_err(&client->dev, "set program size failed\n");
+		return ret;
+	}
+
+	/* Set SDRAM - mystical value from flow picture */
+	ret = m10mo_writew(sd, CATEGORY_FLASHROM, REG_SDRAM_CFG, 0x0608);
+	if (ret) {
+		dev_err(&client->dev, "set sdram failed\n");
+		return ret;
+	}
+
+	/* Set sio mode: */
+	ret = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_SIO_MODE,
+			   REG_SIO_MODE_RISING_LATCH);
+	if (ret) {
+		dev_err(&client->dev, "set sio mode failed\n");
+		return ret;
+	}
+
+	/* Start sio mode */
+	ret = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_RAM_START,
+			   REG_RAM_START_SDRAM);
+	if (ret) {
+		dev_err(&client->dev, "start sio mode failed \n");
+		return ret;
+	}
+
+	ret = m10mo_wait_operation_complete(sd, REG_RAM_START,
+					    STATE_TRANSITION_TIMEOUT);
+	if (ret)
+		return ret;
+
+	usleep_range(30000, 30000);  /* TDB: is that required */
+
+	ret = m10mo_dev->spi->write(m10mo_dev->spi->spi_device,
+				    buf, FW_SIZE, SIO_BLOCK_SIZE);
+	if (ret)
+		return ret;
+
+	msleep(5); /* TDB: is that required */
+
+	/* Flash address to 0*/
+	ret = m10mo_set_flash_address(sd, 0);
+	if (ret)
+		return ret;
+
+	/* Programming size */
+	ret = m10mo_writel(sd, CATEGORY_FLASHROM, REG_DATA_TRANS_SIZE, FW_SIZE);
+	if (ret) {
+		dev_err(&client->dev, "set sio programming size failed \n");
+		return ret;
+	}
+
+	/* Start programming */
+	ret = m10mo_writeb(sd, CATEGORY_FLASHROM, REG_FLASH_WRITE,
+			   REG_FLASH_WRITE_START_PRG);
+	if (ret) {
+		dev_err(&client->dev, "SIO start programming failed\n");
+		return ret;
+	}
+	ret = m10mo_wait_operation_complete(sd, REG_FLASH_WRITE,
+					    PROGRAMMING_TIMEOUT);
+	return ret;
+}
+
+static const struct firmware *
+m10mo_load_firmware(struct m10mo_device *m10mo_dev)
+{
+	struct v4l2_subdev *sd = &m10mo_dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct firmware *fw;
+	int i, ret;
+	u16 *fw_ptr, csum = 0;
+
+	ret = request_firmware(&fw, M10MO_FW_NAME, &client->dev);
+	if (ret) {
+		dev_err(&client->dev,
+			"Error %d while requesting firmware %s\n",
+			ret, M10MO_FW_NAME);
+		return NULL;
+	}
+
+	if (fw->size != FW_SIZE) {
+		dev_err(&client->dev,
+			"Illegal FW size detected\n");
+		release_firmware(fw);
+		return NULL;
+	}
+
+	fw_ptr = (u16 *)fw->data;
+	for (i = 0; i < FW_SIZE/2; i++, fw_ptr++)
+		csum += be16_to_cpup(fw_ptr);
+
+	if (csum) {
+		dev_err(&client->dev,
+			"Illegal FW csum: %d\n", csum);
+	}
+
+	return fw;
+}
+
+int m10mo_program_device(struct m10mo_device *m10mo_dev)
+{
+	struct v4l2_subdev *sd = &m10mo_dev->sd;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = -ENODEV;
+	u32 i;
+	const struct firmware *fw;
+
+	dev_info(&client->dev, "Start FW update\n");
+
+	fw = m10mo_load_firmware(m10mo_dev);
+	if (!fw)
+		return -ENOENT;
+
+	ret = m10mo_to_fw_access_mode(m10mo_dev);
+	if (ret)
+		goto release_fw;
+
+	ret = m10mo_chip_erase_flash(m10mo_dev);
+	if (ret) {
+		dev_err(&client->dev, "Erase failed\n");
+		goto release_fw;
+	}
+
+	if (m10mo_dev->spi && m10mo_dev->spi->spi_enabled) {
+		ret = m10mo_sio_write(m10mo_dev, (u8 *)fw->data);
+		if (ret) {
+			dev_err(&client->dev, "Flash write failed\n");
+			goto release_fw;
+		}
+	} else {
+		for (i = 0 ; i < FW_SIZE; i = i + FLASH_BLOCK_SIZE) {
+			dev_dbg(&client->dev, "Writing block %d\n", i / FLASH_BLOCK_SIZE);
+			ret = m10mo_flash_write_block(m10mo_dev,
+						      i, (u8 *)&fw->data[i],
+						      FLASH_BLOCK_SIZE);
+			if (ret) {
+				dev_err(&client->dev, "Flash write failed\n");
+				goto release_fw;
+			}
+		}
+	}
+
+	dev_info(&client->dev, "Flashing done");
+	msleep(50);
+
+	ret = 0;
+
+release_fw:
+	release_firmware(fw);
+	return ret;
+}
+
+int m10mo_get_spi_state(struct m10mo_device *m10mo_dev)
+{
+	if (m10mo_dev->spi && m10mo_dev->spi->spi_enabled)
+		return 1;
+	return 0;
+}
+
+int m10mo_set_spi_state(struct m10mo_device *m10mo_dev, bool enabled)
+{
+	if (m10mo_dev->spi) {
+		m10mo_dev->spi->spi_enabled = !!enabled;
+		return 0;
+	}
+	return -ENODEV;
+}
+
+void m10mo_register_spi_fw_flash_interface(struct m10mo_device *dev,
+					   struct m10mo_spi *m10mo_spi_dev)
+{
+	pr_debug("m10mo: Spi interface registered\n");
+	dev->spi = m10mo_spi_dev;
+}
+EXPORT_SYMBOL_GPL(m10mo_register_spi_fw_flash_interface);
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c
new file mode 100644
index 0000000..eb3fc72
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_spi.c
@@ -0,0 +1,230 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Partially based on m-5mols kernel driver,
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ *
+ * Partially based on jc_v4l2 kernel driver from http://opensource.samsung.com
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/atomisp_platform.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <media/v4l2-device.h>
+#include <media/m10mo_atomisp.h>
+#include "m10mo.h"
+
+static inline int spi_xmit(struct spi_device *spi, const u8 *addr, const int len)
+{
+	int ret;
+	struct spi_message msg;
+
+	struct spi_transfer xfer = {
+		.len = len,
+		.tx_buf = addr,
+		.bits_per_word = 32,
+	};
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+
+	ret = spi_sync(spi, &msg);
+
+	if (ret < 0)
+		dev_err(&spi->dev, "error %d\n", ret);
+
+	return ret;
+}
+
+static inline int spi_xmit_rx(struct spi_device *spi, u8 *in_buf, size_t len)
+{
+	int ret;
+	u8 read_out_buf[2];
+
+	struct spi_message msg;
+	struct spi_transfer xfer = {
+		.tx_buf = read_out_buf,
+		.rx_buf = in_buf,
+		.len	= len,
+		.cs_change = 0,
+	};
+
+	spi_message_init(&msg);
+
+	spi_message_add_tail(&xfer, &msg);
+
+	ret = spi_sync(spi, &msg);
+
+	if (ret < 0)
+		dev_err(&spi->dev, "%s - error %d\n", __func__, ret);
+
+	return ret;
+}
+
+/* TDB: Not tested */
+int m10mo_spi_read(struct spi_device *spi, u8 *buf, size_t len,
+		   const int rxSize)
+{
+	int k;
+	int ret = 0;
+	u8 temp_buf[4] = {0};
+	u32 count = len / rxSize;
+	u32 extra = len % rxSize;
+
+	for (k = 0; k < count; k++) {
+		ret = spi_xmit_rx(spi, &buf[rxSize * k], rxSize);
+		if (ret < 0) {
+			dev_err(&spi->dev, "%s - error %d\n", __func__, ret);
+			return -EINVAL;
+		}
+	}
+
+	if (extra != 0) {
+		ret = spi_xmit_rx(spi, &buf[rxSize * k], extra);
+		if (ret < 0) {
+			dev_err(&spi->dev, "%s - error %d\n", __func__, ret);
+			return -EINVAL;
+		}
+	}
+
+	for (k = 0; k < len - 3; k += 4) {
+		memcpy(temp_buf, (char *)&buf[k], sizeof(temp_buf));
+		buf[k] = temp_buf[3];
+		buf[k+1] = temp_buf[2];
+		buf[k+2] = temp_buf[1];
+		buf[k+3] = temp_buf[0];
+	}
+	return 0;
+}
+
+int m10mo_spi_write(struct spi_device *spi, const u8 *addr,
+		    const int len, const int txSize)
+{
+	int i, j = 0;
+	int ret = 0;
+	u8 paddingData[8];
+	u32 count = len / txSize;
+	u32 extra = len % txSize;
+	dev_dbg(&spi->dev, "Entered to spi write with count = %d extra = %d\n",
+	       count, extra);
+
+	for (i = 0 ; i < count ; i++) {
+		ret = spi_xmit(spi, &addr[j], txSize);
+		j += txSize;
+		if (ret < 0) {
+			dev_err(&spi->dev, "failed to write spi_xmit\n");
+			goto exit_err;
+		}
+	}
+
+	if (extra) {
+		ret = spi_xmit(spi, &addr[j], extra);
+		if (ret < 0) {
+			dev_err(&spi->dev, "failed to write spi_xmit\n");
+			goto exit_err;
+		}
+	}
+
+	for (i = 0; i < 4; i++) {
+		memset(paddingData, 0, sizeof(paddingData));
+		ret = spi_xmit(spi, paddingData, 8);
+		if (ret < 0) {
+			dev_err(&spi->dev, "failed to write spi_xmit\n");
+			goto exit_err;
+		}
+	}
+	dev_dbg(&spi->dev, "FW upload done!!\n");
+exit_err:
+	return ret;
+}
+
+static int m10mo_spi_probe(struct spi_device *spi)
+{
+	int ret = -ENODEV;
+	struct m10mo_spi *m10mo_spi_dev;
+	struct m10mo_atomisp_spi_platform_data *pdata;
+
+	dev_dbg(&spi->dev, "Probe M10MO SPI\n");
+
+	pdata = dev_get_platdata(&spi->dev);
+	if (!pdata) {
+		dev_err(&spi->dev, "Missing platform data. Can't continue");
+		return -ENODEV;
+	}
+	if (!pdata->device_data) {
+		dev_err(&spi->dev, "Missing link to m10mo main driver. Can't continue");
+		return -ENODEV;
+	}
+
+	m10mo_spi_dev = kzalloc(sizeof(struct m10mo_spi), GFP_KERNEL);
+	if (!m10mo_spi_dev) {
+		dev_err(&spi->dev, "Can't get memory\n");
+		return -ENOMEM;
+	}
+
+	if (spi_setup(spi)) {
+		dev_err(&spi->dev, "failed to setup spi for m10mo_spi\n");
+		ret = -EINVAL;
+		goto err_setup;
+	}
+
+	spi_set_drvdata(spi, m10mo_spi_dev);
+	m10mo_spi_dev->spi_device  = spi;
+	m10mo_spi_dev->read        = m10mo_spi_read;
+	m10mo_spi_dev->write       = m10mo_spi_write;
+	m10mo_spi_dev->spi_enabled = pdata->spi_enabled;
+
+	m10mo_register_spi_fw_flash_interface(pdata->device_data,
+					      m10mo_spi_dev);
+
+	dev_err(&spi->dev, "m10mo_spi successfully probed\n");
+
+	return 0;
+err_setup:
+	kfree(m10mo_spi_dev);
+	return ret;
+}
+
+static int m10mo_spi_remove(struct spi_device *spi)
+{
+	struct m10mo_spi *m10mo_spi_dev;
+	m10mo_spi_dev = spi_get_drvdata(spi);
+	kfree(m10mo_spi_dev);
+	return 0;
+}
+
+static const struct spi_device_id m10mo_spi_id_table[] = {
+	{ "m10mo_spi",	0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, m10mo_spi_id_table);
+
+static struct spi_driver m10mo_spi_driver = {
+	.driver = {
+		.name	= "m10mo_spi",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= m10mo_spi_probe,
+	.remove		= m10mo_spi_remove,
+	.id_table	= m10mo_spi_id_table,
+};
+module_spi_driver(m10mo_spi_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_DESCRIPTION("m10mo spi interface driver");
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c
new file mode 100644
index 0000000..bda2130
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/m10mo_tables.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * Partially based on m-5mols kernel driver,
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ *
+ * Partially based on jc_v4l2 kernel driver from http://opensource.samsung.com
+ * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include "m10mo.h"
+
+static const struct m10mo_resolution const m10mo_preview_modes_fw0[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.command = 0x17,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.command = 0x21,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x40,
+	},
+};
+
+static const struct m10mo_resolution const m10mo_preview_modes_fw1[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.command = 0x17,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.command = 0x21,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x28,
+	},
+};
+
+static const struct m10mo_resolution const m10mo_capture_modes_fw0[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.command = 0x09,
+	},
+	{
+		.width = 960,
+		.height = 720,
+		.command = 0x2f,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.command = 0x10,
+	},
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x19,
+	},
+	{
+		.width = 2048,
+		.height = 1536,
+		.command = 0x1b,
+	},
+	{
+		.width = 4128,
+		.height = 2336,
+		.command = 0x30,
+	},
+	{
+		.width = 4128,
+		.height = 3096,
+		.command = 0x2c,
+	},
+};
+
+static const struct m10mo_resolution const m10mo_capture_modes_fw1[] = {
+	{
+		.width = 640,
+		.height = 480,
+		.command = 0x09,
+	},
+	{
+		.width = 1280,
+		.height = 720,
+		.command = 0x10,
+	},
+	{
+		.width = 2048,
+		.height = 1536,
+		.command = 0x1b,
+	},
+	{
+		.width = 4128,
+		.height = 3096,
+		.command = 0x2c,
+	},
+};
+
+static const struct m10mo_resolution const m10mo_video_modes_fw0[] = {
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x40,
+	},
+};
+
+static const struct m10mo_resolution const m10mo_video_modes_fw1[] = {
+	{
+		.width = 1920,
+		.height = 1080,
+		.command = 0x28,
+	},
+};
+
+const struct m10mo_resolution *resolutions[][3] = {
+	{ m10mo_preview_modes_fw0,
+	  m10mo_capture_modes_fw0,
+	  m10mo_video_modes_fw0 } ,
+	{ m10mo_preview_modes_fw1,
+	  m10mo_capture_modes_fw1,
+	  m10mo_video_modes_fw1 }
+};
+
+const ssize_t resolutions_sizes[][3] = {
+	{ ARRAY_SIZE(m10mo_preview_modes_fw0),
+	  ARRAY_SIZE(m10mo_capture_modes_fw0),
+	  ARRAY_SIZE(m10mo_video_modes_fw0) } ,
+	{ ARRAY_SIZE(m10mo_preview_modes_fw1),
+	  ARRAY_SIZE(m10mo_capture_modes_fw1),
+	  ARRAY_SIZE(m10mo_video_modes_fw1) }
+};
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9d113.c b/drivers/external_drivers/camera/drivers/media/i2c/mt9d113.c
new file mode 100644
index 0000000..58d1dd2
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9d113.c
@@ -0,0 +1,2004 @@
+/*
+ * Support for mt9d113 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "mt9d113.h"
+
+#define to_mt9d113_sensor(sd) container_of(sd, struct mt9d113_device, sd)
+
+/*
+ * TODO: use debug parameter to actually define when debug messages should
+ * be printed.
+ */
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+/*
+ * mt9d113_read_reg - read a register value through i2c
+ * @client: i2c_client
+ * @data_length: register data width, e.g.: 8bit/16bit/32bit
+ * @reg: register address
+ * @val: register read value
+ *
+ * The function return 0 for success, < 0 for err
+ */
+static int
+mt9d113_read_reg(struct i2c_client *client, u16 data_length, u32 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u16) (reg >> 8);
+	data[1] = (u16) (reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	if (err >= 0) {
+		*val = 0;
+		/* high byte comes first */
+		if (data_length == MISENSOR_8BIT)
+			*val = data[0];
+		else if (data_length == MISENSOR_16BIT)
+			*val = data[1] + (data[0] << 8);
+		else
+			*val = data[3] + (data[2] << 8) +
+			    (data[1] << 16) + (data[0] << 24);
+
+		return 0;
+	}
+
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+/*
+ * mt9d113_write_reg - write a register value through i2c
+ * @client: i2c_client
+ * @data_length: register data width, e.g.: 8bit/16bit/32bit
+ * @reg: register address
+ * @val: register write value
+ *
+ * The function return 0 for success, < 0 for err
+ */
+static int
+mt9d113_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = be16_to_cpu((u16)val);
+	} else {
+		/* MISENSOR_32BIT */
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = be32_to_cpu(val);
+	}
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return num_msg;
+}
+
+/**
+ * misensor_rmw_reg - Read/Modify/Write a value to a register in the sensor
+ * device
+ * @client: i2c driver client structure
+ * @data_length: 8/16/32-bits length
+ * @reg: register address
+ * @mask: masked out bits
+ * @set: bits set
+ *
+ * Read/modify/write a value to a register in the  sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int
+misensor_rmw_reg(struct i2c_client *client, u16 data_length, u16 reg,
+		     u32 mask, u32 set)
+{
+	int err;
+	u32 val;
+
+	/* Exit when no mask */
+	if (mask == 0)
+		return 0;
+
+	/* @mask must not exceed data length */
+	switch (data_length) {
+	case MISENSOR_8BIT:
+		if (mask & ~0xff)
+			return -EINVAL;
+		break;
+	case MISENSOR_16BIT:
+		if (mask & ~0xffff)
+			return -EINVAL;
+		break;
+	case MISENSOR_32BIT:
+		break;
+	default:
+		/* Wrong @data_length */
+		return -EINVAL;
+	}
+
+	err = mt9d113_read_reg(client, data_length, reg, &val);
+	if (err) {
+		dev_err(&client->dev, "misensor_rmw_reg error, read failed");
+		return -EINVAL;
+	}
+
+	val &= ~mask;
+
+	/*
+	 * Perform the OR function if the @set exists.
+	 * Shift @set value to target bit location. @set should set only
+	 * bits included in @mask.
+	 *
+	 * REVISIT: This function expects @set to be non-shifted. Its shift
+	 * value is then defined to be equal to mask's LSB position.
+	 * How about to inform values in their right offset position and avoid
+	 * this unneeded shift operation?
+	 */
+	set <<= ffs(mask) - 1;
+	val |= set & mask;
+
+	err = mt9d113_write_reg(client, data_length, reg, val);
+	if (err) {
+		dev_err(&client->dev, "misensor_rmw_reg error, write failed");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __mt9d113_flush_reg_array(struct i2c_client *client,
+				     struct mt9d113_write_ctrl *ctrl)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	int retry = 0;
+
+	if (ctrl->index == 0)
+		return 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + ctrl->index;
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	msg.buf = (u8 *)&ctrl->buffer;
+
+	ret = i2c_transfer(client->adapter, &msg, num_msg);
+	if (ret != num_msg) {
+		if (++retry <= I2C_RETRY_COUNT) {
+			dev_dbg(&client->dev, "retrying... %d\n", retry);
+			msleep(20);
+			goto again;
+		}
+		dev_err(&client->dev, "%s: i2c transfer error\n", __func__);
+		return -EIO;
+	}
+
+	ctrl->index = 0;
+
+	/*
+	 * REVISIT: Previously we had a delay after writing data to sensor.
+	 * But it was removed as our tests have shown it is not necessary
+	 * anymore.
+	 */
+
+	return 0;
+}
+
+static int __mt9d113_buf_reg_array(struct i2c_client *client,
+				   struct mt9d113_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	u16 *data16;
+	u32 *data32;
+	int err;
+
+	/* Insufficient buffer? Let's flush and get more free space. */
+	if (ctrl->index + next->length >= MT9D113_MAX_WRITE_BUF_SIZE) {
+		err = __mt9d113_flush_reg_array(client, ctrl);
+		if (err)
+			return err;
+	}
+
+	switch (next->length) {
+	case MISENSOR_8BIT:
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case MISENSOR_16BIT:
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	case MISENSOR_32BIT:
+		data32 = (u32 *)&ctrl->buffer.data[ctrl->index];
+		*data32 = cpu_to_be32(next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += next->length;
+
+	return 0;
+}
+
+static int
+__mt9d113_write_reg_is_consecutive(struct i2c_client *client,
+				   struct mt9d113_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+/*
+ * mt9d113_write_reg_array - Initializes a list of mt9d113 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ * @poll: completion polling requirement
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __mt9d113_flush_reg_array, __mt9d113_buf_reg_array() and
+ * __mt9d113_write_reg_is_consecutive() are internal functions to
+ * mt9d113_write_reg_array() and should be not used anywhere else.
+ *
+ */
+static int mt9d113_write_reg_array(struct i2c_client *client,
+				const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	struct mt9d113_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		switch (next->length & MISENSOR_TOK_MASK) {
+		case MISENSOR_TOK_DELAY:
+			err = __mt9d113_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		case MISENSOR_TOK_RMW:
+			err = __mt9d113_flush_reg_array(client, &ctrl);
+			err |= misensor_rmw_reg(client,
+						next->length &
+							~MISENSOR_TOK_RMW,
+						next->reg, next->val,
+						next->val2);
+			if (err) {
+				dev_err(&client->dev, "%s read err. aborted\n",
+					__func__);
+				return -EINVAL;
+			}
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__mt9d113_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __mt9d113_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __mt9d113_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write aborted",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	err = __mt9d113_flush_reg_array(client, &ctrl);
+	if (err)
+		return err;
+	return 0;
+}
+
+static int mt9d113_wait_standby(struct v4l2_subdev *sd, int flag)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 100;
+	int ret, status;
+
+	while (i--) {
+		ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+				       MT9D113_REG_STBY_CTRL, &status);
+		if (ret) {
+			dev_err(&client->dev, "err read SEQ_CMD: %d", ret);
+			return ret;
+		}
+
+		if (((status & STBY_CTRL_MASK_STBY_STAT)
+			>> STBY_CTRL_BIT_STBY_STAT) == flag)
+			return 0;
+		msleep(20);
+	}
+
+	dev_err(&client->dev, "wait standby %d timeout.", flag);
+	return -EBUSY;
+}
+
+static int mt9d113_set_suspend(struct v4l2_subdev *sd, bool val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9D113_REG_STBY_CTRL,
+			       STBY_CTRL_MASK_STBY_REQ, val);
+	if (ret) {
+		dev_err(&client->dev, "err set standby bit: %d", ret);
+		return -EINVAL;
+	}
+
+	ret = mt9d113_wait_standby(sd, val);
+
+	return ret;
+}
+
+static int mt9d113_s_color_effect(struct v4l2_subdev *sd, int effect)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+	int reg_val;
+	int ret = 0;
+
+	if (dev->color_effect == effect)
+		return 0;
+
+	/* Read col effect register */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_COL_EFF_A);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_DATA0,
+				&reg_val);
+	if (ret) {
+		dev_err(&client->dev, "err read COL_EFF_A: %d", ret);
+		return ret;
+	}
+
+	reg_val &= ~MT9D113_COL_EFF_MASK;
+
+	switch (effect) {
+	case V4L2_COLORFX_NONE:
+		reg_val |= MT9D113_COL_EFF_DISABLE;
+		break;
+	case V4L2_COLORFX_SEPIA:
+		reg_val |= MT9D113_COL_EFF_SEPIA;
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		reg_val |= MT9D113_COL_EFF_NEG;
+		break;
+	case V4L2_COLORFX_BW:
+		reg_val |= MT9D113_COL_EFF_MONO;
+		break;
+	default:
+		dev_err(&client->dev, "invalid col eff: %d", effect);
+		return -ERANGE;
+	}
+
+	/* Write col effect register */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_COL_EFF_A);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_DATA0,
+				reg_val);
+	if (ret) {
+		dev_err(&client->dev, "err read COL_EFF_A: %d", ret);
+		return ret;
+	}
+
+	/* Refresh sequencer */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_SEQ_CMD);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_MCU_VAR_DATA0,
+				 SEQ_CMD_REFRESH);
+	if (ret) {
+		dev_err(&client->dev, "err refresh seq: %d", ret);
+		return ret;
+	}
+
+	dev->color_effect = effect;
+
+	return 0;
+}
+
+static int mt9d113_g_color_effect(struct v4l2_subdev *sd, int *effect)
+{
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+
+	*effect = dev->color_effect;
+
+	return 0;
+}
+
+static int mt9d113_wait_patch(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 100;
+	int ret, status;
+
+	while (i--) {
+		ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+					MT9D113_MCU_VAR_ADDR,
+					MT9D113_VAR_MON_ID_0);
+		ret |= mt9d113_read_reg(client, MISENSOR_16BIT,
+					MT9D113_MCU_VAR_DATA0, &status);
+		if (ret) {
+			dev_err(&client->dev, "err read patch status: %d", ret);
+			return -EINVAL;
+		}
+		/*
+		 * Aptina:
+		 * POLL_FIELD=MON_PATCH_ID_0,==0,DELAY=10,TIMEOUT=100
+		 */
+		if (status)
+			return 0;
+
+		usleep_range(10000, 12000);
+	}
+
+	dev_err(&client->dev, "wait patch status timeout:0x%x.\n", status);
+	return -EBUSY;
+}
+
+static int mt9d113_patch(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/*
+	 * Load SOC2030 patch data
+	 */
+	ret = mt9d113_write_reg_array(client, patch_soc2030);
+	if (ret) {
+		dev_err(&client->dev, "err write soc 2030 patch: %d", ret);
+		return ret;
+	}
+
+	if (mt9d113_wait_patch(sd))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int mt9d113_wait_refresh(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 50;
+	int ret, status;
+
+	while (i--) {
+		ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+					MT9D113_MCU_VAR_ADDR,
+					MT9D113_VAR_SEQ_CMD);
+		if (ret) {
+			dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+			return ret;
+		}
+
+		ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+					MT9D113_MCU_VAR_DATA0,
+					&status);
+		if (ret) {
+			dev_err(&client->dev, "err read SEQ_CMD: %d", ret);
+			return ret;
+		}
+
+		if (!status)
+			return 0;
+		msleep(20);
+	}
+
+	dev_err(&client->dev, "wait refresh timeout");
+	return -EBUSY;
+}
+
+static int mt9d113_refresh(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* Refresh sequencer Mode */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_SEQ_CMD);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_MCU_VAR_DATA0,
+				 SEQ_CMD_REFRESH_MODE);
+	if (ret) {
+		dev_err(&client->dev, "err refresh seq mode: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_wait_refresh(sd);
+	if (ret)
+		return ret;
+	/* Refresh sequencer */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_SEQ_CMD);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_MCU_VAR_DATA0,
+				 SEQ_CMD_REFRESH);
+	if (ret) {
+		dev_err(&client->dev, "err refresh seq: %d", ret);
+		return ret;
+	}
+	if (mt9d113_wait_refresh(sd))
+		return ret;
+
+	return 0;
+}
+
+static int mt9d113_wait_pll_lock(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 10;
+	int ret, status_pll;
+
+	while (i--) {
+		ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+			MT9D113_REG_PLL_CTRL, &status_pll);
+		if (ret) {
+			dev_err(&client->dev, "err read pll status: %d", ret);
+			return ret;
+		}
+		if (status_pll & PLL_CTRL_MASK_PLL_STAT)
+			return 0;
+		msleep(20);
+	}
+
+	dev_err(&client->dev, "pll can't lock, err: %d", ret);
+	return -EBUSY;
+}
+
+static int mt9d113_init_pll(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* Bypass PLL */
+	/* Arbitrary value from Aptina */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_REG_PLL_CTRL,
+				0x21F9);
+	if (ret)
+		goto err;
+
+	/*
+	 * PLL Setting:
+	 * Input: 19.2M
+	 * M=53, N=3, P3=0, P1=5, WCD=8
+	 * fbit/MIPI: 508M
+	 * fword: 63.6M
+	 * system: 85M
+	 * sensor: 42.5M
+	 */
+	/* PLL Dividers: M=53, N=3 */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_REG_PLL_DIV,
+				0x0335);
+	if (ret)
+		goto err;
+
+	/* PLL P3 = 0, P1 = 5, WCD = 8 */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_REG_PLL_P,
+				0x00f5);
+	if (ret)
+		goto err;
+
+	/* PLL control: PLL_ENABLE on = 8699 */
+	/* Arbitrary value from Aptina */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_REG_PLL_CTRL,
+				0x21fb);
+	if (ret)
+		goto err;
+
+	/* PLL control: SEL_LOCK_DET on = 8443 */
+	/* Arbitrary value from Aptina */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_REG_PLL_CTRL,
+				0x20fb);
+	if (ret)
+		goto err;
+
+	/* Poll PLL Lock state */
+	ret = mt9d113_wait_pll_lock(sd);
+	if (ret)
+		return ret;
+
+	/* PLL Bypass off */
+	/* Arbitrary value from Aptina */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_REG_PLL_CTRL,
+				0x20fa);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	dev_err(&client->dev, "reg pll access err: %d", ret);
+	return ret;
+}
+
+static int mt9d113_wait_mipi_standby(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 100;
+	int ret, status;
+
+	while (i--) {
+		ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+				       MT9D113_REG_MIPI_STAT, &status);
+		if (ret) {
+			dev_err(&client->dev, "err read SEQ_CMD: %d", ret);
+			return ret;
+		}
+
+		if (status & MIPI_STAT_MASK_MIPI_STBY)
+			return 0;
+		msleep(20);
+	}
+
+	dev_err(&client->dev, "wait mipi standby %d timeout.", status);
+	return -EBUSY;
+}
+
+static int mt9d113_mipi_standby(struct v4l2_subdev *sd, int state)
+{
+	int ret = 0;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+
+	ret = misensor_rmw_reg(c, MISENSOR_16BIT, MT9D113_REG_MIPI_CTRL,
+			       MIPI_CTRL_MASK_MIPI_STBY, state);
+	if (ret)
+		dev_err(&c->dev, "err set mipi standby bit: %d",
+			ret);
+
+	return ret;
+}
+
+static int mt9d113_init_common(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/*
+	 * Soft reset and basic sys ctl
+	 */
+	ret = mt9d113_write_reg_array(client, mt9d113_reset);
+	if (ret)
+		return ret;
+
+	/*
+	 * MIPI Port Config
+	 */
+	/* Disable Parallel */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9D113_REG_MISC_CTRL,
+			       MISC_CTRL_MASK_EN_PARALL, 0x0);
+	if (ret) {
+		dev_err(&client->dev, "err disable parallel: %d", ret);
+		return ret;
+	}
+
+	/* Enable MIPI TX */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9D113_REG_MISC_CTRL,
+				MISC_CTRL_MASK_EN_MIPI_TX, 0x1);
+	if (ret) {
+		dev_err(&client->dev, "err init mipi: %d", ret);
+		return ret;
+	}
+
+	/* MIPI Stop EOF */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9D113_REG_MIPI_CTRL,
+			       MIPI_CTRL_MASK_MIPI_EOF, 0x1);
+	if (ret) {
+		dev_err(&client->dev, "err set mipi EOF bit: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * PLL Init
+	 */
+	ret = mt9d113_init_pll(sd);
+	if (ret) {
+		dev_err(&client->dev, "err init pll: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * when standby pin is asserted, the sensor can enter two standby
+	 * modes, which mode is determined by the value of reg 0x0028:
+	 * [1]. when reg 0x0028 == 0x0000, the reg and state variables are
+	 * retained standby is asserted.
+	 * [2]. when reg 0x0028 == 0x0001, the reg and state variables are
+	 * not retained when standby is asserted, which result in the lowest
+	 * power consumption.
+	 * we set 0 to reg 0x0028 here.
+	 */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT, MT9D113_REG_STBY_MODE,
+							MT9D113_STBY_MODE_1);
+	if (ret) {
+		dev_err(&client->dev, "err set standby mode: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * Load=MCU Powerup Stop Enable
+	 */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9D113_REG_STBY_CTRL,
+			       STBY_CTRL_MASK_STOP_MCU, 0x1);
+	if (ret) {
+		dev_err(&client->dev, "err set powerup stop bit: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * Load GO
+	 */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9D113_REG_STBY_CTRL,
+			       STBY_CTRL_MASK_STBY_REQ, 0x0);
+	if (ret) {
+		dev_err(&client->dev, "err release MCU from standby: %d", ret);
+		return ret;
+	}
+	ret = mt9d113_wait_standby(sd, 0);
+
+	/*
+	 * Low light settings
+	 */
+	ret = mt9d113_write_reg_array(client, mt9d113_lowlight);
+	if (ret) {
+		dev_err(&client->dev, "err set lowlight: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * AWB and CCM Settings
+	 */
+	ret = mt9d113_write_reg_array(client, mt9d113_awb_ccm);
+	if (ret) {
+		dev_err(&client->dev, "err set awb ccm: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * Noise settings
+	 */
+	ret = mt9d113_write_reg_array(client, mt9d113_noise_reduce);
+	if (ret) {
+		dev_err(&client->dev, "err set noise reduce: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * Sharpness
+	 */
+	ret = mt9d113_write_reg_array(client, mt9d113_sharpness);
+	if (ret) {
+		dev_err(&client->dev, "err set sharpness: %d", ret);
+		return ret;
+	}
+
+
+	/*
+	 * LSC 95%
+	 */
+	ret = mt9d113_write_reg_array(client, mt9d113_lsc_95);
+	if (ret) {
+		dev_err(&client->dev, "err set lsc: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * Load soc2030 patch
+	 */
+	ret = mt9d113_patch(sd);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/*
+	 * DS: 6000 EXTCLK is needed after HW reset
+	 * EXTCLK: 19.2MHZ -> 6000 / 19.2E6 = 0.31mS
+	 */
+	usleep_range(310, 1000);
+
+	return ret;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+
+	return ret;
+}
+
+static int mt9d113_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+
+	if (power_up(sd))
+		return -EINVAL;
+
+	return mt9d113_init_common(sd);
+}
+
+static int mt9d113_try_res(u32 *w, u32 *h)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9d113_res[i].width >= *w) &&
+		    (mt9d113_res[i].height >= *h))
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = mt9d113_res[i].width;
+	*h = mt9d113_res[i].height;
+
+	return 0;
+}
+
+static struct mt9d113_res_struct *mt9d113_to_res(u32 w, u32 h)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if ((mt9d113_res[index].width == w) &&
+		    (mt9d113_res[index].height == h))
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &mt9d113_res[index];
+}
+
+static int mt9d113_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	return mt9d113_try_res(&fmt->width, &fmt->height);
+}
+
+static int mt9d113_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case MT9D113_RES_QCIF:
+		hsize = MT9D113_RES_QCIF_SIZE_H;
+		vsize = MT9D113_RES_QCIF_SIZE_V;
+		break;
+	case MT9D113_RES_QVGA:
+		hsize = MT9D113_RES_QVGA_SIZE_H;
+		vsize = MT9D113_RES_QVGA_SIZE_V;
+		break;
+	case MT9D113_RES_CIF:
+		hsize = MT9D113_RES_CIF_SIZE_H;
+		vsize = MT9D113_RES_CIF_SIZE_V;
+		break;
+	case MT9D113_RES_VGA_WIDE:
+		hsize = MT9D113_RES_VGA_SIZE_H;
+		vsize = MT9D113_RES_VGA_WIDE_SIZE_V;
+		break;
+	case MT9D113_RES_VGA:
+		hsize = MT9D113_RES_VGA_SIZE_H;
+		vsize = MT9D113_RES_VGA_SIZE_V;
+		break;
+	case MT9D113_RES_480P:
+		hsize = MT9D113_RES_480P_SIZE_H;
+		vsize = MT9D113_RES_480P_SIZE_V;
+		break;
+	case MT9D113_RES_SVGA:
+		hsize = MT9D113_RES_SVGA_SIZE_H;
+		vsize = MT9D113_RES_SVGA_SIZE_V;
+		break;
+	case MT9D113_RES_720P:
+		hsize = MT9D113_RES_720P_SIZE_H;
+		vsize = MT9D113_RES_720P_SIZE_V;
+		break;
+	case MT9D113_RES_1M:
+		hsize = MT9D113_RES_1M_SIZE_H;
+		vsize = MT9D113_RES_1M_SIZE_V;
+		break;
+	case MT9D113_RES_2M:
+		hsize = MT9D113_RES_2M_SIZE_H;
+		vsize = MT9D113_RES_2M_SIZE_V;
+		break;
+	default:
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+	return 0;
+}
+
+static int mt9d113_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = mt9d113_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int mt9d113_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+	struct mt9d113_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	int ret;
+
+	mt9d113_try_res(&width, &height);
+	res_index = mt9d113_to_res(width, height);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	switch (res_index->res) {
+	case MT9D113_RES_QCIF:
+		ret = mt9d113_write_reg_array(c, mt9d113_qcif_30_init);
+		dev_info(&c->dev, "%s: set for qcif\n", __func__);
+		break;
+	case MT9D113_RES_QVGA:
+		ret = mt9d113_write_reg_array(c, mt9d113_qvga_30_init);
+		dev_info(&c->dev, "%s: set for qvga\n", __func__);
+		break;
+	case MT9D113_RES_CIF:
+		ret = mt9d113_write_reg_array(c, mt9d113_cif_30_init);
+		dev_info(&c->dev, "%s: set for cif\n", __func__);
+		break;
+	case MT9D113_RES_VGA_WIDE:
+		ret = mt9d113_write_reg_array(c, mt9d113_vga_wide_29_init);
+		dev_info(&c->dev, "%s: set for vga wide\n", __func__);
+		break;
+	case MT9D113_RES_VGA:
+		ret = mt9d113_write_reg_array(c, mt9d113_vga_30_init);
+		dev_info(&c->dev, "%s: set for vga\n", __func__);
+		break;
+	case MT9D113_RES_SVGA:
+		ret = mt9d113_write_reg_array(c, mt9d113_svga_30_init);
+		dev_info(&c->dev, "%s: set for svga\n", __func__);
+		break;
+	case MT9D113_RES_720P:
+		ret = mt9d113_write_reg_array(c, mt9d113_720p_29_init);
+		dev_info(&c->dev, "%s: set for 720p\n", __func__);
+		break;
+	case MT9D113_RES_1M:
+		ret = mt9d113_write_reg_array(c, mt9d113_1m_15_init);
+		dev_info(&c->dev, "%s: set for 1m\n", __func__);
+		break;
+	case MT9D113_RES_2M:
+		ret = mt9d113_write_reg_array(c, mt9d113_2m_15_init);
+		dev_info(&c->dev, "%s: set for 2m\n", __func__);
+		break;
+	default:
+		dev_err(&c->dev, "set resolution: %d failed!\n",
+			res_index->res);
+		return -EINVAL;
+	}
+
+	if (ret)
+		return ret;
+
+	/*
+	 * In video mode, max exposure time is limited as to achieve
+	 * stable 30 fps. and gain is increased to large value by sensor's
+	 * 3A in dark environment;
+	 *
+	 * When switch back to preview, though the max exposure time is not
+	 * limited, it would not increase as gain value is already large
+	 * enougth to make the picture bright, which will make a lot noise
+	 * in picture.
+	 *
+	 * We need to reset the gain value to small value, as in preview mode
+	 * exposure value, instead of gain value, should take priority to
+	 * adjust picture brightness.
+	 *
+	 * The reset should only happen in switch from video to preview, and
+	 * not in other switchings, like preview to still.
+	 */
+	if (dev->last_run_mode == CI_MODE_VIDEO
+	    && dev->run_mode == CI_MODE_PREVIEW) {
+		/* write preview noise setting in preview/still mode */
+		ret = mt9d113_write_reg_array(c,
+					mt9d113_preview_noise_setting);
+		if (ret) {
+			dev_err(&c->dev,
+				"err write preview noise setting: %d", ret);
+			return ret;
+		}
+
+		/* write default ae_d_gain */
+		ret = mt9d113_write_reg_array(c, mt9d113_default_gain);
+		if (ret) {
+			dev_err(&c->dev,
+				"err Write default gain: %d", ret);
+			return ret;
+		}
+	} else if (dev->run_mode == CI_MODE_VIDEO) {
+		/* write video noise setting in video mode */
+		ret = mt9d113_write_reg_array(c,
+					mt9d113_video_noise_setting);
+		if (ret) {
+			dev_err(&c->dev,
+				"err write video noise setting: %d", ret);
+			return ret;
+		}
+	}
+
+	/* Limit max exposure if in video mode */
+	ret = mt9d113_write_reg(c, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_AE_MAX_INDEX);
+	if (ret) {
+		dev_err(&c->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	if (dev->run_mode == CI_MODE_VIDEO)
+		ret = mt9d113_write_reg(c, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_DATA0,
+				MT9D113_AE_MAX_INDEX_0);
+	else
+		ret = mt9d113_write_reg(c, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_DATA0,
+				MT9D113_AE_MAX_INDEX_1);
+
+	if (ret) {
+		dev_err(&c->dev, "err write ae_max_index: %d", ret);
+		return ret;
+	}
+
+	/* Clear power up stop bit */
+	ret = misensor_rmw_reg(c, MISENSOR_16BIT, MT9D113_REG_STBY_CTRL,
+			       STBY_CTRL_MASK_STOP_MCU, 0x0);
+	if (ret) {
+		dev_err(&c->dev, "err clear powerup stop bit: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_refresh(sd);
+	if (ret) {
+		dev_err(&c->dev, "refresh failed: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_set_suspend(sd, true);
+	if (ret) {
+		dev_err(&c->dev, "err enter suspend: %d", ret);
+		return ret;
+	}
+
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int mt9d113_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (MT9D113_FOCAL_LENGTH_NUM << 16) | MT9D113_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int mt9d113_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const f number for MT9D113 */
+	*val = (MT9D113_F_NUMBER_DEFAULT_NUM << 16) | MT9D113_F_NUMBER_DEM;
+	return 0;
+}
+
+static int mt9d113_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (MT9D113_F_NUMBER_DEFAULT_NUM << 24) |
+		(MT9D113_F_NUMBER_DEM << 16) |
+		(MT9D113_F_NUMBER_DEFAULT_NUM << 8) | MT9D113_F_NUMBER_DEM;
+	return 0;
+}
+
+/* read shutter, in number of line period */
+static int mt9d113_get_shutter(struct v4l2_subdev *sd, s32 *shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+	u32 inte_time, row_time;
+	int ret, i;
+
+	/* read integration time */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_INTEGRATION_TIME);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_DATA0,
+				&inte_time);
+	if (ret) {
+		dev_err(&client->dev,
+				"err read integration time: %d", ret);
+		return ret;
+	}
+
+	/* get row time */
+	for (i = 0; i < N_RES; i++) {
+		if (mt9d113_res[i].res == dev->res) {
+			row_time = mt9d113_res[i].row_time;
+			break;
+		}
+	}
+	if (i == N_RES)	{
+		dev_err(&client->dev,
+				"err get row  time: %d", ret);
+		return -EINVAL;
+	}
+
+	/* return exposure value is in units of 100us */
+	*shutter = inte_time * row_time / 100;
+
+	return 0;
+}
+
+/*
+ * This returns the exposure compensation value, which is expressed in
+ * terms of EV. The default EV value is 0, and driver don't support
+ * adjust EV value.
+ */
+static int mt9d113_get_exposure_bias(struct v4l2_subdev *sd, s32 *value)
+{
+	*value = 0;
+
+	return 0;
+}
+
+/*
+ * This returns ISO sensitivity.
+ */
+static int mt9d113_get_iso(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 ae_gain, ae_d_gain;
+	int ret;
+
+	/* read ae virtual gain */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_AE_GAIN);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_DATA0,
+				&ae_gain);
+	if (ret) {
+		dev_err(&client->dev,
+				"err read ae virtual gain: %d", ret);
+		return ret;
+	}
+
+	/* read ae_d_gain */
+	ret = mt9d113_write_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_ADDR,
+				MT9D113_VAR_AE_D_GAIN);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9d113_read_reg(client, MISENSOR_16BIT,
+				MT9D113_MCU_VAR_DATA0,
+				&ae_d_gain);
+	if (ret) {
+		dev_err(&client->dev,
+				"err read ae_d_gain: %d", ret);
+		return ret;
+	}
+
+	*value = ((ae_gain * 25) >> 4) + (((ae_d_gain - 128) * 200) >> 7);
+
+	return 0;
+}
+
+static struct mt9d113_control mt9d113_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9d113_get_shutter,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure bias",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9d113_get_exposure_bias,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_ISO_SENSITIVITY,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "iso",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9d113_get_iso,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_COLORFX,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "color effect",
+			.minimum = 0,
+			.maximum = 9,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = mt9d113_s_color_effect,
+		.query = mt9d113_g_color_effect,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = MT9D113_FOCAL_LENGTH_DEFAULT,
+			.maximum = MT9D113_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9D113_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9d113_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = MT9D113_F_NUMBER_DEFAULT,
+			.maximum = MT9D113_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9D113_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9d113_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = MT9D113_F_NUMBER_RANGE,
+			.maximum =  MT9D113_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = MT9D113_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = mt9d113_g_fnumber_range,
+	},
+
+};
+
+#define N_CONTROLS (ARRAY_SIZE(mt9d113_controls))
+
+static struct mt9d113_control *mt9d113_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (mt9d113_controls[i].qc.id == id)
+			return &mt9d113_controls[i];
+	}
+	return NULL;
+}
+
+static int mt9d113_detect(struct mt9d113_device *dev, struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+	/*
+	 * Read Device ID
+	 * SYSCTL: 0x0
+	 * contains the MT9D113 device ID Number, 0x2280
+	 * Read-Only
+	 */
+	mt9d113_read_reg(client, MISENSOR_16BIT, 0x0, &retvalue);
+	dev->real_model_id = retvalue;
+
+	if (retvalue != V4L2_IDENT_MT9D113) {
+		dev_err(&client->dev, "%s: failed: client->addr = 0x%x\n",
+			__func__, client->addr);
+		dev_err(&client->dev, "%s: bad device id: 0x%x\n",
+			__func__, retvalue);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int
+mt9d113_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "mt9d113 platform init err\n");
+			return ret;
+		}
+	}
+	ret = mt9d113_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "mt9d113 power-up err");
+		return ret;
+	}
+	/*
+	 * Soft reset and basic sys ctl
+	 */
+	ret = mt9d113_write_reg_array(client, mt9d113_reset);
+	if (ret)
+		return ret;
+
+	/* config & detect sensor */
+	ret = mt9d113_detect(dev, client);
+	if (ret) {
+		dev_err(&client->dev, "mt9d113_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = mt9d113_s_power(sd, 0);
+	if (ret) {
+		dev_err(&client->dev, "mt9d113 power down err");
+		return ret;
+	}
+
+	dev->color_effect = V4L2_COLORFX_NONE;
+	dev->run_mode = CI_MODE_PREVIEW;
+	dev->last_run_mode = CI_MODE_PREVIEW;
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	mt9d113_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int mt9d113_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct mt9d113_control *ctrl = mt9d113_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+static int mt9d113_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9d113_control *octrl = mt9d113_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9d113_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9d113_control *octrl = mt9d113_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9d113_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret = 0;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9d113_device *dev = to_mt9d113_sensor(sd);
+
+	if (enable) {
+		ret = mt9d113_set_suspend(sd, false);
+		if (ret) {
+			dev_err(&c->dev, "err leave suspend: %d", ret);
+			return ret;
+		}
+	} else {
+		ret = mt9d113_mipi_standby(sd, 1);
+		if (ret)
+			return ret;
+
+		ret = mt9d113_wait_mipi_standby(sd);
+		if (ret)
+			return ret;
+
+		ret = misensor_rmw_reg(c, MISENSOR_16BIT, MT9D113_REG_STBY_CTRL,
+				       STBY_CTRL_MASK_STOP_MCU, 0x1);
+		if (ret) {
+			dev_err(&c->dev, "err set powerup stop bit: %d",
+				 ret);
+			return ret;
+		}
+
+		dev->last_run_mode = dev->run_mode;
+	}
+
+	return 0;
+}
+
+static int
+mt9d113_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = mt9d113_res[index].width;
+	fsize->discrete.height = mt9d113_res[index].height;
+
+	return 0;
+}
+
+static int mt9d113_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9d113_res[i].width >= fival->width) &&
+		    (mt9d113_res[i].height >= fival->height))
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = mt9d113_res[index].fps;
+
+	return 0;
+}
+
+static int
+mt9d113_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_MT9D113, 0);
+}
+
+static int mt9d113_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int mt9d113_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+
+	unsigned int index = fse->index;
+
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = mt9d113_res[index].width;
+	fse->min_height = mt9d113_res[index].height;
+	fse->max_width = mt9d113_res[index].width;
+	fse->max_height = mt9d113_res[index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mt9d113_get_pad_format(struct mt9d113_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,  "%s err. pad %x\n", __func__, pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+mt9d113_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9d113_device *snr = to_mt9d113_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9d113_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+mt9d113_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9d113_device *snr = to_mt9d113_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9d113_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int mt9d113_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct mt9d113_device *snr = to_mt9d113_sensor(sd);
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	snr->run_mode = param->parm.capture.capturemode;
+
+	return 0;
+}
+
+static int mt9d113_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct mt9d113_device *snr = to_mt9d113_sensor(sd);
+
+	if (frames == NULL)
+		return -EINVAL;
+
+	for (index = 0; index < N_RES; index++) {
+		if (mt9d113_res[index].res == snr->res)
+			break;
+	}
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	*frames = mt9d113_res[index].skip_frames;
+
+	return 0;
+}
+static const struct v4l2_subdev_video_ops mt9d113_video_ops = {
+	.try_mbus_fmt = mt9d113_try_mbus_fmt,
+	.s_mbus_fmt = mt9d113_set_mbus_fmt,
+	.g_mbus_fmt = mt9d113_get_mbus_fmt,
+	.s_stream = mt9d113_s_stream,
+	.s_parm = mt9d113_s_parm,
+	.enum_framesizes = mt9d113_enum_framesizes,
+	.enum_frameintervals = mt9d113_enum_frameintervals,
+};
+
+static struct v4l2_subdev_sensor_ops mt9d113_sensor_ops = {
+	.g_skip_frames	= mt9d113_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops mt9d113_core_ops = {
+	.g_chip_ident = mt9d113_g_chip_ident,
+	.queryctrl = mt9d113_queryctrl,
+	.g_ctrl = mt9d113_g_ctrl,
+	.s_ctrl = mt9d113_s_ctrl,
+	.s_power = mt9d113_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops mt9d113_pad_ops = {
+	.enum_mbus_code = mt9d113_enum_mbus_code,
+	.enum_frame_size = mt9d113_enum_frame_size,
+	.get_fmt = mt9d113_get_pad_format,
+	.set_fmt = mt9d113_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops mt9d113_ops = {
+	.core = &mt9d113_core_ops,
+	.video = &mt9d113_video_ops,
+	.pad = &mt9d113_pad_ops,
+	.sensor = &mt9d113_sensor_ops,
+};
+
+static const struct media_entity_operations mt9d113_entity_ops;
+
+
+static int mt9d113_remove(struct i2c_client *client)
+{
+	struct mt9d113_device *dev;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	dev = container_of(sd, struct mt9d113_device, sd);
+	dev->platform_data->csi_cfg(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+	return 0;
+}
+
+static int mt9d113_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct mt9d113_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &mt9d113_ops);
+	if (client->dev.platform_data) {
+		ret = mt9d113_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		mt9d113_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	return 0;
+}
+
+
+MODULE_DEVICE_TABLE(i2c, mt9d113_id);
+
+static struct i2c_driver mt9d113_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mt9d113"
+	},
+	.probe = mt9d113_probe,
+	.remove = __exit_p(mt9d113_remove),
+	.id_table = mt9d113_id,
+};
+
+static __init int init_mt9d113(void)
+{
+	return i2c_add_driver(&mt9d113_driver);
+}
+
+static __exit void exit_mt9d113(void)
+{
+	i2c_del_driver(&mt9d113_driver);
+}
+
+module_init(init_mt9d113);
+module_exit(exit_mt9d113);
+
+MODULE_AUTHOR("Tao Jing <jing.tao@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9d113.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9d113.h
new file mode 100644
index 0000000..03e70d7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9d113.h
@@ -0,0 +1,2146 @@
+/*
+ * Support for mt9d113 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MT9D113_H__
+#define __MT9D113_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define V4L2_IDENT_MT9D113 0x2580
+
+#define MT9D113_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define MT9D113_FOCAL_LENGTH_DEM	100
+#define MT9D113_F_NUMBER_DEFAULT_NUM	24
+#define MT9D113_F_NUMBER_DEM	10
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9D113_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9D113_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define MT9D113_F_NUMBER_RANGE 0x180a180a
+
+#define MT9D113_COL_EFF_MASK	0x7
+#define MT9D113_COL_EFF_DISABLE	0x0
+#define MT9D113_COL_EFF_MONO	0x1
+#define MT9D113_COL_EFF_SEPIA	0x2
+#define MT9D113_COL_EFF_NEG	0x3
+
+#define MT9D113_BIT_FD_MANUAL	7
+#define MT9D113_MASK_FD_MANUAL	(1 << MT9D113_BIT_FD_MANUAL)
+enum {
+	MT9D113_FD_MANUAL_DIS,
+	MT9D113_FD_MANUAL_EN,
+};
+#define MT9D113_BIT_FD_SET	6
+#define MT9D113_MASK_FD_SET	(1 << MT9D113_BIT_FD_SET)
+enum {
+	MT9D113_FD_60HZ,
+	MT9D113_FD_50HZ,
+};
+
+#define MT9D113_REG_CHIPID	0x0
+#define MT9D113_REG_PLL_DIV	0x0010
+#define MT9D113_REG_PLL_P	0x0012
+#define MT9D113_REG_PLL_CTRL	0x0014
+#define MT9D113_REG_STBY_CTRL	0x0018
+#define MT9D113_REG_MISC_CTRL	0x001a
+#define MT9D113_REG_STBY_MODE	0x0028
+
+#define MT9D113_REG_MIPI_CTRL	0x3400
+#define MT9D113_REG_MIPI_STAT	0x3402
+
+#define MT9D113_STBY_MODE_1	0x0
+
+#define MIPI_STAT_BIT_MIPI_STBY	0
+#define MIPI_STAT_MASK_MIPI_STBY	(1 << MIPI_STAT_BIT_MIPI_STBY)
+
+#define MIPI_CTRL_BIT_MIPI_STBY	1
+#define MIPI_CTRL_MASK_MIPI_STBY	(1 << MIPI_CTRL_BIT_MIPI_STBY)
+
+#define MIPI_CTRL_BIT_MIPI_EOF	4
+#define MIPI_CTRL_MASK_MIPI_EOF	(1 << MIPI_CTRL_BIT_MIPI_EOF)
+
+#define STBY_CTRL_BIT_STBY_STAT	14
+#define STBY_CTRL_MASK_STBY_STAT	(1 << STBY_CTRL_BIT_STBY_STAT)
+
+#define STBY_CTRL_BIT_STBY_REQ	0
+#define STBY_CTRL_MASK_STBY_REQ	(1 << STBY_CTRL_BIT_STBY_REQ)
+
+#define PLL_CTRL_BIT_PLL_STAT	15
+#define PLL_CTRL_MASK_PLL_STAT	(1 << PLL_CTRL_BIT_PLL_STAT)
+
+#define MISC_CTRL_BIT_EN_PARALL	9
+#define MISC_CTRL_MASK_EN_PARALL	(1 << MISC_CTRL_BIT_EN_PARALL)
+
+#define MISC_CTRL_BIT_EN_MIPI_TX	3
+#define MISC_CTRL_MASK_EN_MIPI_TX	(1 << MISC_CTRL_BIT_EN_MIPI_TX)
+
+
+#define STBY_CTRL_BIT_STOP_MCU	2
+#define STBY_CTRL_MASK_STOP_MCU	(1 << STBY_CTRL_BIT_STOP_MCU)
+
+#define MT9D113_MCU_VAR_ADDR	0x098c
+#define MT9D113_MCU_VAR_DATA0	0x0990
+#define MT9D113_MCU_VAR_DATA1	0x0992
+#define MT9D113_MCU_VAR_DATA2	0x0994
+#define MT9D113_MCU_VAR_DATA3	0x0996
+#define MT9D113_MCU_VAR_DATA4	0x0998
+#define MT9D113_MCU_VAR_DATA5	0x099a
+#define MT9D113_MCU_VAR_DATA6	0x099c
+#define MT9D113_MCU_VAR_DATA7	0x099e
+
+#define MT9D113_VAR_MON_ID_0	0xa024
+#define MT9D113_VAR_SEQ_CMD	0xa103
+#define SEQ_CMD_RUN		0x0
+#define SEQ_CMD_REFRESH_MODE	0x0006
+#define SEQ_CMD_REFRESH		0x0005
+#define MT9D113_VAR_SEQ_STATE	0xa104
+
+#define MT9D113_VAR_COL_EFF_A	0x2759
+#define MT9D113_VAR_FD_MODE	0x2404
+
+/* current integration time access */
+#define MT9D113_VAR_INTEGRATION_TIME	0x2222
+
+#define MT9D113_VAR_AE_MAX_INDEX	0xa20c
+#define MT9D113_AE_MAX_INDEX_0	0x0003
+#define MT9D113_AE_MAX_INDEX_1	0x000b
+
+#define MT9D113_VAR_AE_GAIN	0xa21c
+#define MT9D113_VAR_AE_D_GAIN	0x221f
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_FWBURST0	0x80
+#define MISENSOR_FWBURST1	0x81
+#define MISENSOR_FWBURST4	0x84
+#define MISENSOR_FWBURST	0x88
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+#define MISENSOR_TOK_RMW	0x0010  /* RMW operation */
+#define MISENSOR_TOK_MASK	0xfff0
+#define MISENSOR_AWB_STEADY	(1<<0)	/* awb steady */
+#define MISENSOR_AE_READY	(1<<3)	/* ae status ready */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+/* Resolution Table */
+enum {
+	MT9D113_RES_QCIF,
+	MT9D113_RES_QVGA,
+	MT9D113_RES_CIF,
+	MT9D113_RES_VGA_WIDE,
+	MT9D113_RES_VGA,
+	MT9D113_RES_480P,
+	MT9D113_RES_SVGA,
+	MT9D113_RES_720P,
+	MT9D113_RES_1M,
+	MT9D113_RES_2M,
+};
+
+#define MT9D113_RES_2M_SIZE_H		1600
+#define MT9D113_RES_2M_SIZE_V		1200
+#define MT9D113_RES_1M_SIZE_H		1024
+#define MT9D113_RES_1M_SIZE_V		768
+#define MT9D113_RES_720P_SIZE_H		1280
+#define MT9D113_RES_720P_SIZE_V		720
+#define MT9D113_RES_SVGA_SIZE_H		800
+#define MT9D113_RES_SVGA_SIZE_V		600
+#define MT9D113_RES_480P_SIZE_H		768
+#define MT9D113_RES_480P_SIZE_V		480
+#define MT9D113_RES_VGA_SIZE_H		640
+#define MT9D113_RES_VGA_SIZE_V		480
+#define MT9D113_RES_VGA_WIDE_SIZE_V		360
+#define MT9D113_RES_CIF_SIZE_H		352
+#define MT9D113_RES_CIF_SIZE_V		288
+#define MT9D113_RES_QVGA_SIZE_H		320
+#define MT9D113_RES_QVGA_SIZE_V		240
+#define MT9D113_RES_QCIF_SIZE_H		176
+#define MT9D113_RES_QCIF_SIZE_V		144
+
+/* completion status polling requirements, usage based on Aptina .INI Rev2 */
+enum poll_reg {
+	NO_POLLING,
+	PRE_POLLING,
+	POST_POLLING,
+};
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u32 length;
+	u32 reg;
+	u32 val;	/* value or for read/mod/write, AND mask */
+	u32 val2;	/* optional; for rmw, OR mask */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct mt9d113_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int real_model_id;
+	unsigned int res;
+	int color_effect;
+	int run_mode;
+	int last_run_mode;
+};
+
+struct mt9d113_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct mt9d113_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int skip_frames;
+	int row_time;
+	bool used;
+	struct regval_list *regs;
+};
+
+struct mt9d113_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define MT9D113_MAX_WRITE_BUF_SIZE	32
+struct mt9d113_write_buffer {
+	u16 addr;
+	u8 data[MT9D113_MAX_WRITE_BUF_SIZE];
+};
+
+struct mt9d113_write_ctrl {
+	int index;
+	struct mt9d113_write_buffer buffer;
+};
+
+/*
+ * Modes supported by the mt9d113 driver.
+ * Please, keep them in ascending order.
+ */
+static struct mt9d113_res_struct mt9d113_res[] = {
+	{
+	.desc	= "QCIF",
+	.res	= MT9D113_RES_QCIF,
+	.width	= 176,
+	.height	= 144,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 48,
+	},
+	{
+	.desc	= "QVGA",
+	.res	= MT9D113_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 48,
+	},
+	{
+	.desc	= "CIF",
+	.res	= MT9D113_RES_CIF,
+	.width	= 352,
+	.height	= 288,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 48,
+	},
+	{
+	.desc	= "VGA_WIDE",
+	.res	= MT9D113_RES_VGA_WIDE,
+	.width	= 640,
+	.height	= 360,
+	.fps	= 29,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 48,
+	},
+	{
+	.desc	= "VGA",
+	.res	= MT9D113_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 48,
+	},
+	{
+	.desc	= "SVGA",
+	.res	= MT9D113_RES_SVGA,
+	.width	= 800,
+	.height	= 600,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 48,
+	},
+	{
+	.desc	= "720p",
+	.res	= MT9D113_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.fps	= 29,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 42,
+	},
+	{
+	.desc	= "1M",
+	.res	= MT9D113_RES_1M,
+	.width	= 1024,
+	.height	= 768,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 52,
+	},
+	{
+	.desc	= "2M",
+	.res	= MT9D113_RES_2M,
+	.width	= 1600,
+	.height	= 1200,
+	.fps	= 10,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	.row_time = 52,
+	},
+};
+#define N_RES (ARRAY_SIZE(mt9d113_res))
+
+static const struct i2c_device_id mt9d113_id[] = {
+	{"mt9d113", 0},
+	{}
+};
+
+/*
+ * Context A setting for 176x144
+ *
+; Max Frame Time: 33.3333 msec
+; Max Frame Clocks: 1413333.3 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 2x cols, 2x rows, Bin Mode: Yes
+; Horiz clks:  808 active + 1237 blank = 2045 total
+; Vert  rows:  608 active + 83 blank = 691 total
+; Extra Delay: 238 clocks
+;
+; Actual Frame Clocks: 1413333 clocks
+; Row Time: 48.231 usec / 2045 clocks
+; Frame time: 33.333325 msec
+; Frames per Sec: 30 fps
+;
+; 50Hz Flicker Period: 207.33 lines
+; 60Hz Flicker Period: 172.78 lines
+
+; hblank: 29.17us
+; vblank: 4ms
+ */
+static struct misensor_reg const mt9d113_qcif_30_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00b0},/*      = 176*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0090},/*      = 144*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04bd},/*      = 1213*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x064d},/*      = 1613*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x046f},/*      = 1135*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x005a},/*      = 90*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01be},/*      = 446*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0131},/*      = 305*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02b3},/*      = 691*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x07fd},/*      = 2045*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x031f},/*      = 799*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0257},/*      = 599*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x2c},/*      = 44*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x32},/*      = 50*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x34},/*      = 52*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00cf},/*      = 207*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Context A setting for 352x288
+ *
+; Max Frame Time: 33.3333 msec
+; Max Frame Clocks: 1413333.3 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 2x cols, 2x rows, Bin Mode: Yes
+; Horiz clks:  808 active + 1237 blank = 2045 total
+; Vert  rows:  608 active + 83 blank = 691 total
+; Extra Delay: 238 clocks
+;
+; Actual Frame Clocks: 1413333 clocks
+; Row Time: 48.231 usec / 2045 clocks
+; Frame time: 33.333325 msec
+; Frames per Sec: 30 fps
+;
+; 50Hz Flicker Period: 207.33 lines
+; 60Hz Flicker Period: 172.78 lines
+
+; hblank: 29.17us
+; vblank: 4ms
+ */
+static struct misensor_reg const mt9d113_cif_30_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0160},/*      = 352*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0120},/*      = 288*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04bd},/*      = 1213*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x064d},/*      = 1613*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x046f},/*      = 1135*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x005a},/*      = 90*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01be},/*      = 446*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0131},/*      = 305*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02b3},/*      = 691*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x07fd},/*      = 2045*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x031f},/*      = 799*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0257},/*      = 599*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x2c},/*      = 44*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x32},/*      = 50*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x34},/*      = 52*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00cf},/*      = 207*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Context A setting for 320x240
+ *
+; Max Frame Time: 33.3333 msec
+; Max Frame Clocks: 1413333.3 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 2x cols, 2x rows, Bin Mode: Yes
+; Horiz clks:  808 active + 1237 blank = 2045 total
+; Vert  rows:  608 active + 83 blank = 691 total
+; Extra Delay: 238 clocks
+;
+; Actual Frame Clocks: 1413333 clocks
+; Row Time: 48.231 usec / 2045 clocks
+; Frame time: 33.333325 msec
+; Frames per Sec: 30 fps
+;
+; 50Hz Flicker Period: 207.33 lines
+; 60Hz Flicker Period: 172.78 lines
+
+; hblank: 29.17us
+; vblank: 4ms
+ */
+static struct misensor_reg const mt9d113_qvga_30_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0140},/*      = 320*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00f0},/*      = 240*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04bd},/*      = 1213*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x064d},/*      = 1613*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x046f},/*      = 1135*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x005a},/*      = 90*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01be},/*      = 446*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0131},/*      = 305*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02b3},/*      = 691*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x07fd},/*      = 2045*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x031f},/*      = 799*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0257},/*      = 599*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x2c},/*      = 44*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x32},/*      = 50*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x34},/*      = 52*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00cf},/*      = 207*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Context A setting for 640x480
+ *
+; Max Frame Time: 33.3333 msec
+; Max Frame Clocks: 1413333.3 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 2x cols, 2x rows, Bin Mode: Yes
+; Horiz clks:  808 active + 1237 blank = 2045 total
+; Vert  rows:  608 active + 83 blank = 691 total
+; Extra Delay: 238 clocks
+;
+; Actual Frame Clocks: 1413333 clocks
+; Row Time: 48.231 usec / 2045 clocks
+; Frame time: 33.333325 msec
+; Frames per Sec: 30 fps
+;
+; 50Hz Flicker Period: 207.33 lines
+; 60Hz Flicker Period: 172.78 lines
+
+; hblank: 29.17us
+; vblank: 4ms
+ */
+static struct misensor_reg const mt9d113_vga_30_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0280},/*      = 640*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01e0},/*      = 480*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04bd},/*      = 1213*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x064d},/*      = 1613*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x046f},/*      = 1135*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x005a},/*      = 90*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01be},/*      = 446*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0131},/*      = 305*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02b3},/*      = 691*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x07fd},/*      = 2045*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x031f},/*      = 799*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0257},/*      = 599*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x2c},/*      = 44*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x32},/*      = 50*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x34},/*      = 52*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00cf},/*      = 207*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9d113_vga_wide_29_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0280},/*      = 640*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0168},/*      = 360*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0a6},/*      = 166*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x03cd},/*      = 973*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x05ad},/*      = 1453*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0027},/*      = 39*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x032d},/*      = 813*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0706},/*      = 1798*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04ff},/*      = 1279*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02cf},/*      = 719*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00c5},/*      = 197*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x30},/*      = 48*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x32},/*      = 50*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x3a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x3c},/*      = 60*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00c5},/*      = 197*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00ec},/*      = 236*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Context A setting for 1280x720
+; Max Frame Time: 34.4828 msec
+; Max Frame Clocks: 1462068.9 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 1x cols, 1x rows, Bin Mode: No
+; Horiz clks:  1288 active + 510 blank = 1798 total
+; Vert  rows:  728 active + 85 blank = 813 total
+; Extra Delay: 294 clocks
+;
+; Actual Frame Clocks: 1462068 clocks
+; Row Time: 42.406 usec / 1798 clocks
+; Frame time: 34.482736 msec
+; Frames per Sec: 29 fps
+;
+; 50Hz Flicker Period: 235.82 lines
+; 60Hz Flicker Period: 196.51 lines
+
+; hblank: 12us
+; vblank: 3.6ms
+ */
+static struct misensor_reg const mt9d113_720p_29_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0500},/*      = 1280*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02d0},/*      = 720*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0a6},/*      = 166*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x03cd},/*      = 973*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x05ad},/*      = 1453*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0027},/*      = 39*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x032d},/*      = 813*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0706},/*      = 1798*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04ff},/*      = 1279*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02cf},/*      = 719*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00c5},/*      = 197*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x30},/*      = 48*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x32},/*      = 50*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x3a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x3c},/*      = 60*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00c5},/*      = 197*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00ec},/*      = 236*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Context A setting for 800x600
+; Max Frame Time: 33.3333 msec
+; Max Frame Clocks: 1413333.3 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 2x cols, 2x rows, Bin Mode: Yes
+; Horiz clks:  808 active + 1237 blank = 2045 total
+; Vert  rows:  608 active + 83 blank = 691 total
+; Extra Delay: 238 clocks
+;
+; Actual Frame Clocks: 1413333 clocks
+; Row Time: 48.231 usec / 2045 clocks
+; Frame time: 33.333325 msec
+; Frames per Sec: 30 fps
+;
+; 50Hz Flicker Period: 207.33 lines
+; 60Hz Flicker Period: 172.78 lines
+
+; hblank: 29.17us
+; vblank: 4ms
+ */
+static struct misensor_reg const mt9d113_svga_30_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0320},/*      = 800*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0258},/*      = 600*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04bd},/*      = 1213*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x064d},/*      = 1613*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x046f},/*      = 1135*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x005a},/*      = 90*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01be},/*      = 446*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0131},/*      = 305*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x02b3},/*      = 691*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x07fd},/*      = 2045*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x031f},/*      = 799*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0257},/*      = 599*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x2c},/*      = 44*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x32},/*      = 50*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x34},/*      = 52*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00ad},/*      = 173*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00cf},/*      = 207*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Context A setting for 1024x768
+; Max Frame Time: 66.8896 msec
+; Max Frame Clocks: 2836120.4 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 1x cols, 1x rows, Bin Mode: No
+; Horiz clks:  1608 active + 585 blank = 2193 total
+; Vert  rows:  1208 active + 85 blank = 1293 total
+; Extra Delay: 571 clocks
+;
+; Actual Frame Clocks: 2836120 clocks
+; Row Time: 51.722 usec / 2193 clocks
+; Frame time: 66.889623 msec
+; Frames per Sec: 14.950 fps
+;
+; 50Hz Flicker Period: 193.34 lines
+; 60Hz Flicker Period: 161.12 lines
+
+; hblank: 13.79us
+; vblank: 4.4ms
+ */
+static struct misensor_reg const mt9d113_1m_15_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0400},/*      = 1024*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0300},/*      = 768*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270D},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0027},/*      = 39*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x271D},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0891},/*      = 2193*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272D},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050D},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x273D},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274D},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222D},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00a1},/*      = 161*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x27},/*      = 39*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x29},/*      = 41*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x2f},/*      = 47*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x31},/*      = 49*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00a1},/*      = 161*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00c1},/*      = 193*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fD Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40D},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Context A setting for 1600x1200
+; Max Frame Time: 66.8896 msec
+; Max Frame Clocks: 2836120.4 clocks (42.400 MHz)
+; Pixel Clock: divided by 1
+; Skip Mode: 1x cols, 1x rows, Bin Mode: No
+; Horiz clks:  1608 active + 585 blank = 2193 total
+; Vert  rows:  1208 active + 85 blank = 1293 total
+; Extra Delay: 571 clocks
+;
+; Actual Frame Clocks: 2836120 clocks
+; Row Time: 51.722 usec / 2193 clocks
+; Frame time: 66.889623 msec
+; Frames per Sec: 14.950 fps
+;
+; 50Hz Flicker Period: 193.34 lines
+; 60Hz Flicker Period: 161.12 lines
+
+; hblank: 13.79us
+; vblank: 4.4ms
+ */
+static struct misensor_reg const mt9d113_2m_15_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0640},/*      = 1600*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04b0},/*      = 1200*/
+	{MISENSOR_16BIT, 0x98c, 0x270D},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0027},/*      = 39*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x271D},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x050d},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0891},/*      = 2193*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0004},/*      = 4*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04bb},/*      = 1211*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x064b},/*      = 1611*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0111},/*      = 273*/
+	{MISENSOR_16BIT, 0x98c, 0x272D},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0024},/*      = 36*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x003a},/*      = 58*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00f6},/*      = 246*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x050D},/*      = 1293*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0c24},/*      = 3108*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x273D},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x063f},/*      = 1599*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274D},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x04af},/*      = 1199*/
+	{MISENSOR_16BIT, 0x98c, 0x222D},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x00a1},/*      = 161*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x27},/*      = 39*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x29},/*      = 41*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x2f},/*      = 47*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x31},/*      = 49*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00a1},/*      = 161*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00c1},/*      = 193*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0071},/*      = 113*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0087},/*      = 135*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fD Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40D},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9d113_default_gain[] = {
+	{MISENSOR_16BIT, 0x098c, 0x221f}, /* ae_d_gain */
+	{MISENSOR_16BIT, 0x0990, 0x80},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Soft Reset
+ * 1: Set SYSCTL 0x001A[1:0] to 0x3 to initiate internal reset cycle.
+ * 2: Wait 6000 EXTCLK cycles.
+ * 3: Reset SYSCTL 0x001A[1:0] to 0x0 for normal operation.
+ *
+ * SYSCTL
+ * bit9=0: Parallel output port is disabled.
+ * bit8=0: Output is enabled (gpio ?
+ * bit6=1: running at full speed
+ * bit4=1: GPIO not remained power on in standby
+ * bit3=0: MIPI Transmitter disabled by default
+ * bit1=0: MIPI Transmitter not in reset
+ * bit0: toggle for SOC soft reset
+ */
+static struct misensor_reg const mt9d113_reset[] = {
+	{MISENSOR_16BIT, 0x001a, 0x0051},
+	{MISENSOR_TOK_DELAY, 0, 1},
+	{MISENSOR_16BIT, 0x001a, 0x0050},
+	{MISENSOR_TOK_DELAY, 0, 1}, /* wait for normal operation */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* AWB_CCM initialization */
+static struct misensor_reg const mt9d113_awb_ccm[] = {
+	{MISENSOR_16BIT, 0x098c, 0x2306}, /* MCU_ADDRESS [AWB_CCM_L_0]*/
+	{MISENSOR_16BIT, 0x0990, 0x02a2}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x231c}, /* MCU_ADDRESS [AWB_CCM_RL_0]*/
+	{MISENSOR_16BIT, 0x0990, 0x00b3}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2308}, /* MCU_ADDRESS [AWB_CCM_L_1]*/
+	{MISENSOR_16BIT, 0x0990, 0xfef7}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x231e}, /* MCU_ADDRESS [AWB_CCM_RL_1]*/
+	{MISENSOR_16BIT, 0x0990, 0xfefb}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x230a}, /* MCU_ADDRESS [AWB_CCM_L_2]*/
+	{MISENSOR_16BIT, 0x0990, 0xffa1}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2320}, /* MCU_ADDRESS [AWB_CCM_RL_2]*/
+	{MISENSOR_16BIT, 0x0990, 0x0057}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x230c}, /* MCU_ADDRESS [AWB_CCM_L_3]*/
+	{MISENSOR_16BIT, 0x0990, 0xff38}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2322}, /* MCU_ADDRESS [AWB_CCM_RL_3]*/
+	{MISENSOR_16BIT, 0x0990, 0x0046}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x230e}, /* MCU_ADDRESS [AWB_CCM_L_4]*/
+	{MISENSOR_16BIT, 0x0990, 0x02e1}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2324}, /* MCU_ADDRESS [AWB_CCM_RL_4]*/
+	{MISENSOR_16BIT, 0x0990, 0xffe1}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2310}, /* MCU_ADDRESS [AWB_CCM_L_5]*/
+	{MISENSOR_16BIT, 0x0990, 0xff3d}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2326}, /* MCU_ADDRESS [AWB_CCM_RL_5]*/
+	{MISENSOR_16BIT, 0x0990, 0xffc0}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2312}, /* MCU_ADDRESS [AWB_CCM_L_6]*/
+	{MISENSOR_16BIT, 0x0990, 0xffbd}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2328}, /* MCU_ADDRESS [AWB_CCM_RL_6]*/
+	{MISENSOR_16BIT, 0x0990, 0x001a}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2314}, /* MCU_ADDRESS [AWB_CCM_L_7]*/
+	{MISENSOR_16BIT, 0x0990, 0xfe81}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x232a}, /* MCU_ADDRESS [AWB_CCM_RL_7]*/
+	{MISENSOR_16BIT, 0x0990, 0x0091}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2316}, /* MCU_ADDRESS [AWB_CCM_L_8]*/
+	{MISENSOR_16BIT, 0x0990, 0x0307}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x232c}, /* MCU_ADDRESS [AWB_CCM_RL_8]*/
+	{MISENSOR_16BIT, 0x0990, 0xff48}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2318}, /* MCU_ADDRESS [AWB_CCM_L_9]*/
+	{MISENSOR_16BIT, 0x0990, 0x0020}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x231a}, /* MCU_ADDRESS [AWB_CCM_L_10]*/
+	{MISENSOR_16BIT, 0x0990, 0x0033}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x232e}, /* MCU_ADDRESS [AWB_CCM_RL_9]*/
+	{MISENSOR_16BIT, 0x0990, 0x0008}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2330}, /* MCU_ADDRESS [AWB_CCM_RL_10]*/
+	{MISENSOR_16BIT, 0x0990, 0xfff7}, /* MCU_DATA_0*/
+
+	{MISENSOR_16BIT, 0x098c, 0xa363}, /* MCU_ADDRESS [aWb_TG_MIN0]*/
+	{MISENSOR_16BIT, 0x0990, 0x00d2}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa364}, /* MCU_ADDRESS [aWb_TG_MaX0]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ee}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa369}, /* MCU_ADDRESS [AWB_KR_R] */
+	{MISENSOR_16BIT, 0x0990, 0x0080}, /* MCU_DATA_0 */
+	{MISENSOR_16BIT, 0x098c, 0xa36a}, /* MCU_ADDRESS [AWB_KG_R] */
+	{MISENSOR_16BIT, 0x0990, 0x0090}, /* MCU_DATA_0 */
+	{MISENSOR_16BIT, 0x098c, 0xa36b}, /* MCU_ADDRESS [AWB_KB_R] */
+	{MISENSOR_16BIT, 0x0990, 0x0088}, /* MCU_DATA_0 */
+
+
+	/* NO dS, aptinal private */
+	{MISENSOR_16BIT, 0x3244, 0x0328}, /* aWb_CONFIG4, aWb fine tuning*/
+	{MISENSOR_16BIT, 0x323e, 0xc22c}, /* aWb fine tuning, bit[11-15]*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* Low light settings */
+static struct misensor_reg const mt9d113_lowlight[] = {
+	{MISENSOR_16BIT, 0x098c, 0x2b28}, /* MCU_ADDRESS [hg_ll_bg_start]*/
+	{MISENSOR_16BIT, 0x0990, 0x35e8}, /* 13800*/
+	{MISENSOR_16BIT, 0x098c, 0x2b2a}, /* MCU_ADDRESS [hg_ll_bg_stop]*/
+	{MISENSOR_16BIT, 0x0990, 0xb3b0}, /* 46000*/
+
+	{MISENSOR_16BIT, 0x098c, 0xab20}, /* MCU_ADDRESS [hg_ll_sat1]*/
+	{MISENSOR_16BIT, 0x0990, 0x004b}, /* 75*/
+	{MISENSOR_16BIT, 0x098c, 0xab24}, /* MCU_ADDRESS [hg_ll_sat2]*/
+	{MISENSOR_16BIT, 0x0990, 0x0000}, /* 0*/
+	{MISENSOR_16BIT, 0x098c, 0xab25}, /* MCU_ADDRESS [hg_ll_thresh2]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* 255*/
+
+	{MISENSOR_16BIT, 0x098c, 0xab30}, /* MCU_ADDRESS [hg_nr_stop_r]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* 255*/
+	{MISENSOR_16BIT, 0x098c, 0xab31}, /* MCU_ADDRESS [hg_nr_stop_g]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* 255*/
+	{MISENSOR_16BIT, 0x098c, 0xab32}, /* MCU_ADDRESS [hg_nr_stop_b]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* 255*/
+	{MISENSOR_16BIT, 0x098c, 0xab33}, /* MCU_ADDRESS [hg_nr_stop_ol]*/
+	{MISENSOR_16BIT, 0x0990, 0x0057}, /* 87*/
+
+	{MISENSOR_16BIT, 0x098c, 0xab34}, /* MCU_ADDRESS [hg_nr_gainstart]*/
+	{MISENSOR_16BIT, 0x0990, 0x0080}, /* 128*/
+	{MISENSOR_16BIT, 0x098c, 0xab35}, /* MCU_ADDRESS [hg_nr_gainstop]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* 255*/
+
+	{MISENSOR_16BIT, 0x098c, 0xab36}, /* MCU_ADDRESS [hg_cluster_dc_th]*/
+	{MISENSOR_16BIT, 0x0990, 0x0014}, /* 20*/
+
+	{MISENSOR_16BIT, 0x098c, 0xab37}, /* MCU_ADDRESS [hg_gamma_mor_ctrl]*/
+	{MISENSOR_16BIT, 0x0990, 0x0003}, /* 3*/
+
+	{MISENSOR_16BIT, 0x098c, 0x2b38}, /* MCU_ADDRESS [hg_gammastartmor]*/
+	{MISENSOR_16BIT, 0x0990, 0x32c8}, /* 13000 [100 lux]*/
+	{MISENSOR_16BIT, 0x098c, 0x2b3a}, /* MCU_ADDRESS [hg_gammastopmor]*/
+	{MISENSOR_16BIT, 0x0990, 0x7918}, /* 31000 [20 lux]*/
+
+	{MISENSOR_16BIT, 0x098c, 0x2b62}, /* MCU_ADDRESS [hg_ftb_start_bm]*/
+	{MISENSOR_16BIT, 0x0990, 0xfffe}, /* Disable FTB*/
+	{MISENSOR_16BIT, 0x098c, 0x2b64}, /* MCU_ADDRESS [hg_ftb_stop_bm]*/
+	{MISENSOR_16BIT, 0x0990, 0xffff}, /* Disable FTB*/
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* SOC2030 patch */
+static struct misensor_reg const patch_soc2030[] = {
+	{MISENSOR_16BIT, 0x98c, 0x415},
+	{MISENSOR_16BIT, 0x990, 0xf601},
+	{MISENSOR_16BIT, 0x992, 0x42c1},
+	{MISENSOR_16BIT, 0x994, 0x326},
+	{MISENSOR_16BIT, 0x996, 0x11f6},
+	{MISENSOR_16BIT, 0x998, 0x143},
+	{MISENSOR_16BIT, 0x99a, 0xc104},
+	{MISENSOR_16BIT, 0x99c, 0x260a},
+	{MISENSOR_16BIT, 0x99e, 0xcc04},
+
+	{MISENSOR_16BIT, 0x98c, 0x425},
+	{MISENSOR_16BIT, 0x990, 0x33bd},
+	{MISENSOR_16BIT, 0x992, 0xa362},
+	{MISENSOR_16BIT, 0x994, 0xbd04},
+	{MISENSOR_16BIT, 0x996, 0x3339},
+	{MISENSOR_16BIT, 0x998, 0xc6ff},
+	{MISENSOR_16BIT, 0x99a, 0xf701},
+	{MISENSOR_16BIT, 0x99c, 0x6439},
+	{MISENSOR_16BIT, 0x99e, 0xde5d},
+
+	{MISENSOR_16BIT, 0x98c, 0x435},
+	{MISENSOR_16BIT, 0x990, 0x18ce},
+	{MISENSOR_16BIT, 0x992, 0x325},
+	{MISENSOR_16BIT, 0x994, 0xcc00},
+	{MISENSOR_16BIT, 0x996, 0x27bd},
+	{MISENSOR_16BIT, 0x998, 0xc2b8},
+	{MISENSOR_16BIT, 0x99a, 0xcc04},
+	{MISENSOR_16BIT, 0x99c, 0xbdfd},
+	{MISENSOR_16BIT, 0x99e, 0x33b},
+
+	{MISENSOR_16BIT, 0x98c, 0x445},
+	{MISENSOR_16BIT, 0x990, 0xcc06},
+	{MISENSOR_16BIT, 0x992, 0x6bfd},
+	{MISENSOR_16BIT, 0x994, 0x32f},
+	{MISENSOR_16BIT, 0x996, 0xcc03},
+	{MISENSOR_16BIT, 0x998, 0x25dd},
+	{MISENSOR_16BIT, 0x99a, 0x5dc6},
+	{MISENSOR_16BIT, 0x99c, 0x1ed7},
+	{MISENSOR_16BIT, 0x99e, 0x6cd7},
+
+	{MISENSOR_16BIT, 0x98c, 0x455},
+	{MISENSOR_16BIT, 0x990, 0x6d5f},
+	{MISENSOR_16BIT, 0x992, 0xd76e},
+	{MISENSOR_16BIT, 0x994, 0xd78d},
+	{MISENSOR_16BIT, 0x996, 0x8620},
+	{MISENSOR_16BIT, 0x998, 0x977a},
+	{MISENSOR_16BIT, 0x99a, 0xd77b},
+	{MISENSOR_16BIT, 0x99c, 0x979a},
+	{MISENSOR_16BIT, 0x99e, 0xc621},
+
+	{MISENSOR_16BIT, 0x98c, 0x465},
+	{MISENSOR_16BIT, 0x990, 0xd79b},
+	{MISENSOR_16BIT, 0x992, 0xfe01},
+	{MISENSOR_16BIT, 0x994, 0x6918},
+	{MISENSOR_16BIT, 0x996, 0xce03},
+	{MISENSOR_16BIT, 0x998, 0x4dcc},
+	{MISENSOR_16BIT, 0x99a, 0x13},
+	{MISENSOR_16BIT, 0x99c, 0xbdc2},
+	{MISENSOR_16BIT, 0x99e, 0xb8cc},
+
+	{MISENSOR_16BIT, 0x98c, 0x475},
+	{MISENSOR_16BIT, 0x990, 0x5e9},
+	{MISENSOR_16BIT, 0x992, 0xfd03},
+	{MISENSOR_16BIT, 0x994, 0x4fcc},
+	{MISENSOR_16BIT, 0x996, 0x34d},
+	{MISENSOR_16BIT, 0x998, 0xfd01},
+	{MISENSOR_16BIT, 0x99a, 0x69fe},
+	{MISENSOR_16BIT, 0x99c, 0x2bd},
+	{MISENSOR_16BIT, 0x99e, 0x18ce},
+
+	{MISENSOR_16BIT, 0x98c, 0x485},
+	{MISENSOR_16BIT, 0x990, 0x361},
+	{MISENSOR_16BIT, 0x992, 0xcc00},
+	{MISENSOR_16BIT, 0x994, 0x11bd},
+	{MISENSOR_16BIT, 0x996, 0xc2b8},
+	{MISENSOR_16BIT, 0x998, 0xcc06},
+	{MISENSOR_16BIT, 0x99a, 0x28fd},
+	{MISENSOR_16BIT, 0x99c, 0x36f},
+	{MISENSOR_16BIT, 0x99e, 0xcc03},
+
+	{MISENSOR_16BIT, 0x98c, 0x495},
+	{MISENSOR_16BIT, 0x990, 0x61fd},
+	{MISENSOR_16BIT, 0x992, 0x2bd},
+	{MISENSOR_16BIT, 0x994, 0xde00},
+	{MISENSOR_16BIT, 0x996, 0x18ce},
+	{MISENSOR_16BIT, 0x998, 0xc2},
+	{MISENSOR_16BIT, 0x99a, 0xcc00},
+	{MISENSOR_16BIT, 0x99c, 0x37bd},
+	{MISENSOR_16BIT, 0x99e, 0xc2b8},
+
+	{MISENSOR_16BIT, 0x98c, 0x4a5},
+	{MISENSOR_16BIT, 0x990, 0xcc06},
+	{MISENSOR_16BIT, 0x992, 0x4fdd},
+	{MISENSOR_16BIT, 0x994, 0xe6cc},
+	{MISENSOR_16BIT, 0x996, 0xc2},
+	{MISENSOR_16BIT, 0x998, 0xdd00},
+	{MISENSOR_16BIT, 0x99a, 0xc601},
+	{MISENSOR_16BIT, 0x99c, 0xf701},
+	{MISENSOR_16BIT, 0x99e, 0x64c6},
+
+	{MISENSOR_16BIT, 0x98c, 0x4b5},
+	{MISENSOR_16BIT, 0x990, 0x5f7},
+	{MISENSOR_16BIT, 0x992, 0x165},
+	{MISENSOR_16BIT, 0x994, 0x7f01},
+	{MISENSOR_16BIT, 0x996, 0x6639},
+	{MISENSOR_16BIT, 0x998, 0x373c},
+	{MISENSOR_16BIT, 0x99a, 0x3c3c},
+	{MISENSOR_16BIT, 0x99c, 0x3c3c},
+	{MISENSOR_16BIT, 0x99e, 0x30ec},
+
+	{MISENSOR_16BIT, 0x98c, 0x4c5},
+	{MISENSOR_16BIT, 0x990, 0x11ed},
+	{MISENSOR_16BIT, 0x992, 0x2ec},
+	{MISENSOR_16BIT, 0x994, 0xfed},
+	{MISENSOR_16BIT, 0x996, 0x8f},
+	{MISENSOR_16BIT, 0x998, 0x30ed},
+	{MISENSOR_16BIT, 0x99a, 0x4ec},
+	{MISENSOR_16BIT, 0x99c, 0xdee},
+	{MISENSOR_16BIT, 0x99e, 0x4bd},
+
+	{MISENSOR_16BIT, 0x98c, 0x4d5},
+	{MISENSOR_16BIT, 0x990, 0xa406},
+	{MISENSOR_16BIT, 0x992, 0x30ec},
+	{MISENSOR_16BIT, 0x994, 0x2ed},
+	{MISENSOR_16BIT, 0x996, 0x6fc},
+	{MISENSOR_16BIT, 0x998, 0x10c0},
+	{MISENSOR_16BIT, 0x99a, 0x2705},
+	{MISENSOR_16BIT, 0x99c, 0xccff},
+	{MISENSOR_16BIT, 0x99e, 0xffed},
+
+	{MISENSOR_16BIT, 0x98c, 0x4e5},
+	{MISENSOR_16BIT, 0x990, 0x6f6},
+	{MISENSOR_16BIT, 0x992, 0x256},
+	{MISENSOR_16BIT, 0x994, 0x8616},
+	{MISENSOR_16BIT, 0x996, 0x3dc3},
+	{MISENSOR_16BIT, 0x998, 0x261},
+	{MISENSOR_16BIT, 0x99a, 0x8fe6},
+	{MISENSOR_16BIT, 0x99c, 0x9c4},
+	{MISENSOR_16BIT, 0x99e, 0x7c1},
+
+	{MISENSOR_16BIT, 0x98c, 0x4f5},
+	{MISENSOR_16BIT, 0x990, 0x226},
+	{MISENSOR_16BIT, 0x992, 0x1dfc},
+	{MISENSOR_16BIT, 0x994, 0x10c2},
+	{MISENSOR_16BIT, 0x996, 0x30ed},
+	{MISENSOR_16BIT, 0x998, 0x2fc},
+	{MISENSOR_16BIT, 0x99a, 0x10c0},
+	{MISENSOR_16BIT, 0x99c, 0xed00},
+	{MISENSOR_16BIT, 0x99e, 0xc602},
+
+	{MISENSOR_16BIT, 0x98c, 0x505},
+	{MISENSOR_16BIT, 0x990, 0xbdc2},
+	{MISENSOR_16BIT, 0x992, 0x5330},
+	{MISENSOR_16BIT, 0x994, 0xec00},
+	{MISENSOR_16BIT, 0x996, 0xfd10},
+	{MISENSOR_16BIT, 0x998, 0xc0ec},
+	{MISENSOR_16BIT, 0x99a, 0x2fd},
+	{MISENSOR_16BIT, 0x99c, 0x10c2},
+	{MISENSOR_16BIT, 0x99e, 0x201b},
+
+	{MISENSOR_16BIT, 0x98c, 0x515},
+	{MISENSOR_16BIT, 0x990, 0xfc10},
+	{MISENSOR_16BIT, 0x992, 0xc230},
+	{MISENSOR_16BIT, 0x994, 0xed02},
+	{MISENSOR_16BIT, 0x996, 0xfc10},
+	{MISENSOR_16BIT, 0x998, 0xc0ed},
+	{MISENSOR_16BIT, 0x99a, 0xc6},
+	{MISENSOR_16BIT, 0x99c, 0x1bd},
+	{MISENSOR_16BIT, 0x99e, 0xc253},
+
+	{MISENSOR_16BIT, 0x98c, 0x525},
+	{MISENSOR_16BIT, 0x990, 0x30ec},
+	{MISENSOR_16BIT, 0x992, 0xfd},
+	{MISENSOR_16BIT, 0x994, 0x10c0},
+	{MISENSOR_16BIT, 0x996, 0xec02},
+	{MISENSOR_16BIT, 0x998, 0xfd10},
+	{MISENSOR_16BIT, 0x99a, 0xc2c6},
+	{MISENSOR_16BIT, 0x99c, 0x80d7},
+	{MISENSOR_16BIT, 0x99e, 0x85c6},
+
+	{MISENSOR_16BIT, 0x98c, 0x535},
+	{MISENSOR_16BIT, 0x990, 0x40f7},
+	{MISENSOR_16BIT, 0x992, 0x10c4},
+	{MISENSOR_16BIT, 0x994, 0xf602},
+	{MISENSOR_16BIT, 0x996, 0x5686},
+	{MISENSOR_16BIT, 0x998, 0x163d},
+	{MISENSOR_16BIT, 0x99a, 0xc302},
+	{MISENSOR_16BIT, 0x99c, 0x618f},
+	{MISENSOR_16BIT, 0x99e, 0xec14},
+
+	{MISENSOR_16BIT, 0x98c, 0x545},
+	{MISENSOR_16BIT, 0x990, 0xfd10},
+	{MISENSOR_16BIT, 0x992, 0xc501},
+	{MISENSOR_16BIT, 0x994, 0x101},
+	{MISENSOR_16BIT, 0x996, 0x101},
+	{MISENSOR_16BIT, 0x998, 0xfc10},
+	{MISENSOR_16BIT, 0x99a, 0xc2dd},
+	{MISENSOR_16BIT, 0x99c, 0x7ffc},
+	{MISENSOR_16BIT, 0x99e, 0x10c7},
+
+	{MISENSOR_16BIT, 0x98c, 0x555},
+	{MISENSOR_16BIT, 0x990, 0xdd76},
+	{MISENSOR_16BIT, 0x992, 0xf602},
+	{MISENSOR_16BIT, 0x994, 0x5686},
+	{MISENSOR_16BIT, 0x996, 0x163d},
+	{MISENSOR_16BIT, 0x998, 0xc302},
+	{MISENSOR_16BIT, 0x99a, 0x618f},
+	{MISENSOR_16BIT, 0x99c, 0xec14},
+	{MISENSOR_16BIT, 0x99e, 0x939f},
+
+	{MISENSOR_16BIT, 0x98c, 0x565},
+	{MISENSOR_16BIT, 0x990, 0x30ed},
+	{MISENSOR_16BIT, 0x992, 0x8dc},
+	{MISENSOR_16BIT, 0x994, 0x7693},
+	{MISENSOR_16BIT, 0x996, 0x9d25},
+	{MISENSOR_16BIT, 0x998, 0x8f6},
+	{MISENSOR_16BIT, 0x99a, 0x2bc},
+	{MISENSOR_16BIT, 0x99c, 0x4f93},
+	{MISENSOR_16BIT, 0x99e, 0x7f23},
+
+	{MISENSOR_16BIT, 0x98c, 0x575},
+	{MISENSOR_16BIT, 0x990, 0x3df6},
+	{MISENSOR_16BIT, 0x992, 0x2bc},
+	{MISENSOR_16BIT, 0x994, 0x4f93},
+	{MISENSOR_16BIT, 0x996, 0x7f23},
+	{MISENSOR_16BIT, 0x998, 0x6f6},
+	{MISENSOR_16BIT, 0x99a, 0x2bc},
+	{MISENSOR_16BIT, 0x99c, 0x4fdd},
+	{MISENSOR_16BIT, 0x99e, 0x7fdc},
+
+	{MISENSOR_16BIT, 0x98c, 0x585},
+	{MISENSOR_16BIT, 0x990, 0x9ddd},
+	{MISENSOR_16BIT, 0x992, 0x76f6},
+	{MISENSOR_16BIT, 0x994, 0x2bc},
+	{MISENSOR_16BIT, 0x996, 0x4f93},
+	{MISENSOR_16BIT, 0x998, 0x7f26},
+	{MISENSOR_16BIT, 0x99a, 0xfe6},
+	{MISENSOR_16BIT, 0x99c, 0xac1},
+	{MISENSOR_16BIT, 0x99e, 0x226},
+
+	{MISENSOR_16BIT, 0x98c, 0x595},
+	{MISENSOR_16BIT, 0x990, 0x9d6},
+	{MISENSOR_16BIT, 0x992, 0x85c1},
+	{MISENSOR_16BIT, 0x994, 0x8026},
+	{MISENSOR_16BIT, 0x996, 0x314},
+	{MISENSOR_16BIT, 0x998, 0x7401},
+	{MISENSOR_16BIT, 0x99a, 0xf602},
+	{MISENSOR_16BIT, 0x99c, 0xbc4f},
+	{MISENSOR_16BIT, 0x99e, 0x937f},
+
+	{MISENSOR_16BIT, 0x98c, 0x5a5},
+	{MISENSOR_16BIT, 0x990, 0x2416},
+	{MISENSOR_16BIT, 0x992, 0xde7f},
+	{MISENSOR_16BIT, 0x994, 0x9df},
+	{MISENSOR_16BIT, 0x996, 0x7f30},
+	{MISENSOR_16BIT, 0x998, 0xec08},
+	{MISENSOR_16BIT, 0x99a, 0xdd76},
+	{MISENSOR_16BIT, 0x99c, 0x200a},
+	{MISENSOR_16BIT, 0x99e, 0xdc76},
+
+	{MISENSOR_16BIT, 0x98c, 0x5b5},
+	{MISENSOR_16BIT, 0x990, 0xa308},
+	{MISENSOR_16BIT, 0x992, 0x2304},
+	{MISENSOR_16BIT, 0x994, 0xec08},
+	{MISENSOR_16BIT, 0x996, 0xdd76},
+	{MISENSOR_16BIT, 0x998, 0x1274},
+	{MISENSOR_16BIT, 0x99a, 0x122},
+	{MISENSOR_16BIT, 0x99c, 0xde5d},
+	{MISENSOR_16BIT, 0x99e, 0xee14},
+
+	{MISENSOR_16BIT, 0x98c, 0x5c5},
+	{MISENSOR_16BIT, 0x990, 0xad00},
+	{MISENSOR_16BIT, 0x992, 0x30ed},
+	{MISENSOR_16BIT, 0x994, 0x11ec},
+	{MISENSOR_16BIT, 0x996, 0x6ed},
+	{MISENSOR_16BIT, 0x998, 0x2cc},
+	{MISENSOR_16BIT, 0x99a, 0x80},
+	{MISENSOR_16BIT, 0x99c, 0xed00},
+	{MISENSOR_16BIT, 0x99e, 0x8f30},
+
+	{MISENSOR_16BIT, 0x98c, 0x5d5},
+	{MISENSOR_16BIT, 0x990, 0xed04},
+	{MISENSOR_16BIT, 0x992, 0xec11},
+	{MISENSOR_16BIT, 0x994, 0xee04},
+	{MISENSOR_16BIT, 0x996, 0xbda4},
+	{MISENSOR_16BIT, 0x998, 0x630},
+	{MISENSOR_16BIT, 0x99a, 0xe603},
+	{MISENSOR_16BIT, 0x99c, 0xd785},
+	{MISENSOR_16BIT, 0x99e, 0x30c6},
+
+	{MISENSOR_16BIT, 0x98c, 0x5e5},
+	{MISENSOR_16BIT, 0x990, 0xb3a},
+	{MISENSOR_16BIT, 0x992, 0x3539},
+	{MISENSOR_16BIT, 0x994, 0x3c3c},
+	{MISENSOR_16BIT, 0x996, 0x3c34},
+	{MISENSOR_16BIT, 0x998, 0xcc32},
+	{MISENSOR_16BIT, 0x99a, 0x3ebd},
+	{MISENSOR_16BIT, 0x99c, 0xa558},
+	{MISENSOR_16BIT, 0x99e, 0x30ed},
+
+	{MISENSOR_16BIT, 0x98c, 0x5f5},
+	{MISENSOR_16BIT, 0x990, 0x4bd},
+	{MISENSOR_16BIT, 0x992, 0xb2d7},
+	{MISENSOR_16BIT, 0x994, 0x30e7},
+	{MISENSOR_16BIT, 0x996, 0x6cc},
+	{MISENSOR_16BIT, 0x998, 0x323e},
+	{MISENSOR_16BIT, 0x99a, 0xed00},
+	{MISENSOR_16BIT, 0x99c, 0xec04},
+	{MISENSOR_16BIT, 0x99e, 0xbda5},
+
+	{MISENSOR_16BIT, 0x98c, 0x605},
+	{MISENSOR_16BIT, 0x990, 0x44cc},
+	{MISENSOR_16BIT, 0x992, 0x3244},
+	{MISENSOR_16BIT, 0x994, 0xbda5},
+	{MISENSOR_16BIT, 0x996, 0x585f},
+	{MISENSOR_16BIT, 0x998, 0x30ed},
+	{MISENSOR_16BIT, 0x99a, 0x2cc},
+	{MISENSOR_16BIT, 0x99c, 0x3244},
+	{MISENSOR_16BIT, 0x99e, 0xed00},
+
+	{MISENSOR_16BIT, 0x98c, 0x615},
+	{MISENSOR_16BIT, 0x990, 0xf601},
+	{MISENSOR_16BIT, 0x992, 0xd54f},
+	{MISENSOR_16BIT, 0x994, 0xea03},
+	{MISENSOR_16BIT, 0x996, 0xaa02},
+	{MISENSOR_16BIT, 0x998, 0xbda5},
+	{MISENSOR_16BIT, 0x99a, 0x4430},
+	{MISENSOR_16BIT, 0x99c, 0xe606},
+	{MISENSOR_16BIT, 0x99e, 0x3838},
+
+	{MISENSOR_16BIT, 0x98c, 0x625},
+	{MISENSOR_16BIT, 0x990, 0x3831},
+	{MISENSOR_16BIT, 0x992, 0x39bd},
+	{MISENSOR_16BIT, 0x994, 0xd661},
+	{MISENSOR_16BIT, 0x996, 0xf602},
+	{MISENSOR_16BIT, 0x998, 0xf4c1},
+	{MISENSOR_16BIT, 0x99a, 0x126},
+	{MISENSOR_16BIT, 0x99c, 0xbfe},
+	{MISENSOR_16BIT, 0x99e, 0x2bd},
+
+	{MISENSOR_16BIT, 0x98c, 0x635},
+	{MISENSOR_16BIT, 0x990, 0xee10},
+	{MISENSOR_16BIT, 0x992, 0xfc02},
+	{MISENSOR_16BIT, 0x994, 0xf5ad},
+	{MISENSOR_16BIT, 0x996, 0x39},
+	{MISENSOR_16BIT, 0x998, 0xf602},
+	{MISENSOR_16BIT, 0x99a, 0xf4c1},
+	{MISENSOR_16BIT, 0x99c, 0x226},
+	{MISENSOR_16BIT, 0x99e, 0xafe},
+
+	{MISENSOR_16BIT, 0x98c, 0x645},
+	{MISENSOR_16BIT, 0x990, 0x2bd},
+	{MISENSOR_16BIT, 0x992, 0xee10},
+	{MISENSOR_16BIT, 0x994, 0xfc02},
+	{MISENSOR_16BIT, 0x996, 0xf7ad},
+	{MISENSOR_16BIT, 0x998, 0x39},
+	{MISENSOR_16BIT, 0x99a, 0x3cbd},
+	{MISENSOR_16BIT, 0x99c, 0xb059},
+	{MISENSOR_16BIT, 0x99e, 0xcc00},
+
+	{MISENSOR_16BIT, 0x98c, 0x655},
+	{MISENSOR_16BIT, 0x990, 0x28bd},
+	{MISENSOR_16BIT, 0x992, 0xa558},
+	{MISENSOR_16BIT, 0x994, 0x8300},
+	{MISENSOR_16BIT, 0x996, 0x27},
+	{MISENSOR_16BIT, 0x998, 0xbcc},
+	{MISENSOR_16BIT, 0x99a, 0x26},
+	{MISENSOR_16BIT, 0x99c, 0x30ed},
+	{MISENSOR_16BIT, 0x99e, 0xc6},
+
+	{MISENSOR_16BIT, 0x98c, 0x665},
+	{MISENSOR_16BIT, 0x990, 0x3bd},
+	{MISENSOR_16BIT, 0x992, 0xa544},
+	{MISENSOR_16BIT, 0x994, 0x3839},
+	{MISENSOR_16BIT, 0x996, 0xbdd9},
+	{MISENSOR_16BIT, 0x998, 0x42d6},
+	{MISENSOR_16BIT, 0x99a, 0x9acb},
+	{MISENSOR_16BIT, 0x99c, 0x1d7},
+	{MISENSOR_16BIT, 0x99e, 0x9b39},
+
+	/* hard coded start address of the patch at "patchSetup" */
+	{MISENSOR_16BIT, 0x98c, 0x2006},
+	{MISENSOR_16BIT, 0x990, 0x415},
+	/* execute the patch */
+	{MISENSOR_16BIT, 0x98c, 0xa005},
+	{MISENSOR_16BIT, 0x990, 0x1},
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* Noise settings */
+static struct misensor_reg const mt9d113_noise_reduce[] = {
+	{MISENSOR_16BIT, 0x33f4, 0x005b}, /* KeRNeL_cONfIG*/
+	{MISENSOR_16BIT, 0x098c, 0xa20e}, /* MCU_ADDRESS [ae_MaX_VIRTGaIN]*/
+	{MISENSOR_16BIT, 0x0990, 0x00a0}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2212}, /* MCU_ADDRESS [ae_MaX_dGaIN_ae1]*/
+	{MISENSOR_16BIT, 0x0990, 0x01ee}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab30}, /* MCU_ADDRESS [HG_NR_STOP_R]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab31}, /* MCU_ADDRESS [HG_NR_STOP_G]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab32}, /* MCU_ADDRESS [HG_NR_STOP_b]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* MCU_DATA_0*/
+	/*{MISENSOR_16BIT, 0x098c, 0xab33}, // MCU_ADDRESS [HG_NR_STOP_OL]*/
+	/*{MISENSOR_16BIT, 0x0990, 0x00ff}, // MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab35}, /* MCU_ADDRESS [HG_NR_GaINSTOP]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* MCU_DATA_0*/
+
+	{MISENSOR_16BIT, 0x098c, 0x2b2a}, /* MCU_ADDRESS[HG_LL_bRIGHTNeSSSTOP]*/
+	{MISENSOR_16BIT, 0x0990, 0x3e80}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab20}, /* MCU_ADDRESS [HG_LL_SaT1]*/
+	{MISENSOR_16BIT, 0x0990, 0x0048}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab24}, /* MCU_ADDRESS [HG_LL_SaT2]*/
+	{MISENSOR_16BIT, 0x0990, 0x0000}, /* MCU_DATA_0*/
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* Noise setting in video mode */
+static struct misensor_reg const mt9d113_video_noise_setting[] = {
+	{MISENSOR_16BIT, 0x098c, 0x2212}, /* MCU_ADDRESS [AE_MAX_DGAIN_AE1]*/
+	{MISENSOR_16BIT, 0x0990, 0x00c0}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab34}, /* MCU_ADDRESS [HG_NR_GAINSTART]*/
+	{MISENSOR_16BIT, 0x0990, 0x00b0}, /* MCU_DATA_0*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* Noise setting in preview/still mode */
+static struct misensor_reg const mt9d113_preview_noise_setting[] = {
+	{MISENSOR_16BIT, 0x098c, 0x2212}, /* MCU_ADDRESS [AE_MAX_DGAIN_AE1]*/
+	{MISENSOR_16BIT, 0x0990, 0x01ee}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab34}, /* MCU_ADDRESS [HG_NR_GAINSTART]*/
+	{MISENSOR_16BIT, 0x0990, 0x0080}, /* MCU_DATA_0*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* Sharpness */
+static struct misensor_reg const mt9d113_sharpness[] = {
+	{MISENSOR_16BIT, 0x326c, 0x1304}, /* APERTURE_PARAMETERS */
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* LSC 95% */
+static struct misensor_reg const mt9d113_lsc_95[] = {
+	{MISENSOR_16BIT, 0x3210, 0x01b0},
+	{MISENSOR_16BIT, 0x364e, 0x04d0},
+	{MISENSOR_16BIT, 0x3650, 0xe7ac},
+	{MISENSOR_16BIT, 0x3652, 0x3332},
+	{MISENSOR_16BIT, 0x3654, 0x1e6d},
+	{MISENSOR_16BIT, 0x3656, 0xd751},
+	{MISENSOR_16BIT, 0x3658, 0x00d0},
+	{MISENSOR_16BIT, 0x365a, 0x656b},
+	{MISENSOR_16BIT, 0x365c, 0x4292},
+	{MISENSOR_16BIT, 0x365e, 0x1908},
+	{MISENSOR_16BIT, 0x3660, 0xff30},
+	{MISENSOR_16BIT, 0x3662, 0x00d0},
+	{MISENSOR_16BIT, 0x3664, 0xfc68},
+	{MISENSOR_16BIT, 0x3666, 0x1892},
+	{MISENSOR_16BIT, 0x3668, 0x254e},
+	{MISENSOR_16BIT, 0x366a, 0x42cf},
+	{MISENSOR_16BIT, 0x366c, 0x00d0},
+	{MISENSOR_16BIT, 0x366e, 0xfd6b},
+	{MISENSOR_16BIT, 0x3670, 0x2a12},
+	{MISENSOR_16BIT, 0x3672, 0x3aaa},
+	{MISENSOR_16BIT, 0x3674, 0xce91},
+	{MISENSOR_16BIT, 0x3676, 0x8b2d},
+	{MISENSOR_16BIT, 0x3678, 0x91cf},
+	{MISENSOR_16BIT, 0x367a, 0xa04f},
+	{MISENSOR_16BIT, 0x367c, 0x1c50},
+	{MISENSOR_16BIT, 0x367e, 0x09b3},
+	{MISENSOR_16BIT, 0x3680, 0xc0ad},
+	{MISENSOR_16BIT, 0x3682, 0x262f},
+	{MISENSOR_16BIT, 0x3684, 0x8150},
+	{MISENSOR_16BIT, 0x3686, 0xa911},
+	{MISENSOR_16BIT, 0x3688, 0x1252},
+	{MISENSOR_16BIT, 0x368a, 0xb1cd},
+	{MISENSOR_16BIT, 0x368c, 0xa64e},
+	{MISENSOR_16BIT, 0x368e, 0x8731},
+	{MISENSOR_16BIT, 0x3690, 0x0c70},
+	{MISENSOR_16BIT, 0x3692, 0x0d93},
+	{MISENSOR_16BIT, 0x3694, 0x8a6d},
+	{MISENSOR_16BIT, 0x3696, 0x4c2f},
+	{MISENSOR_16BIT, 0x3698, 0x846e},
+	{MISENSOR_16BIT, 0x369a, 0x9491},
+	{MISENSOR_16BIT, 0x369c, 0x14b2},
+	{MISENSOR_16BIT, 0x369e, 0x7152},
+	{MISENSOR_16BIT, 0x36a0, 0xb44f},
+	{MISENSOR_16BIT, 0x36a2, 0x3a55},
+	{MISENSOR_16BIT, 0x36a4, 0x3813},
+	{MISENSOR_16BIT, 0x36a6, 0xb898},
+	{MISENSOR_16BIT, 0x36a8, 0x0313},
+	{MISENSOR_16BIT, 0x36aa, 0x9891},
+	{MISENSOR_16BIT, 0x36ac, 0x46d5},
+	{MISENSOR_16BIT, 0x36ae, 0x6bb3},
+	{MISENSOR_16BIT, 0x36b0, 0xcd58},
+	{MISENSOR_16BIT, 0x36b2, 0x6152},
+	{MISENSOR_16BIT, 0x36b4, 0xc951},
+	{MISENSOR_16BIT, 0x36b6, 0x5d75},
+	{MISENSOR_16BIT, 0x36b8, 0x6534},
+	{MISENSOR_16BIT, 0x36ba, 0xcb78},
+	{MISENSOR_16BIT, 0x36bc, 0x7052},
+	{MISENSOR_16BIT, 0x36be, 0x9ab0},
+	{MISENSOR_16BIT, 0x36c0, 0x3c35},
+	{MISENSOR_16BIT, 0x36c2, 0x27b3},
+	{MISENSOR_16BIT, 0x36c4, 0xbe18},
+	{MISENSOR_16BIT, 0x36c6, 0xae50},
+	{MISENSOR_16BIT, 0x36c8, 0xa2d1},
+	{MISENSOR_16BIT, 0x36ca, 0x33b0},
+	{MISENSOR_16BIT, 0x36cc, 0x6614},
+	{MISENSOR_16BIT, 0x36ce, 0xf234},
+	{MISENSOR_16BIT, 0x36d0, 0x8b51},
+	{MISENSOR_16BIT, 0x36d2, 0x8572},
+	{MISENSOR_16BIT, 0x36d4, 0x2133},
+	{MISENSOR_16BIT, 0x36d6, 0x3e34},
+	{MISENSOR_16BIT, 0x36d8, 0x0835},
+	{MISENSOR_16BIT, 0x36da, 0xce30},
+	{MISENSOR_16BIT, 0x36dc, 0xb66e},
+	{MISENSOR_16BIT, 0x36de, 0x6b33},
+	{MISENSOR_16BIT, 0x36e0, 0x1b73},
+	{MISENSOR_16BIT, 0x36e2, 0x00d5},
+	{MISENSOR_16BIT, 0x36e4, 0xe5cf},
+	{MISENSOR_16BIT, 0x36e6, 0xb1d1},
+	{MISENSOR_16BIT, 0x36e8, 0xe4b2},
+	{MISENSOR_16BIT, 0x36ea, 0x00f3},
+	{MISENSOR_16BIT, 0x36ec, 0x21d4},
+	{MISENSOR_16BIT, 0x36ee, 0x99f3},
+	{MISENSOR_16BIT, 0x36f0, 0x4a33},
+	{MISENSOR_16BIT, 0x36f2, 0x8a99},
+	{MISENSOR_16BIT, 0x36f4, 0xee36},
+	{MISENSOR_16BIT, 0x36f6, 0x33fb},
+	{MISENSOR_16BIT, 0x36f8, 0x9972},
+	{MISENSOR_16BIT, 0x36fa, 0x16f5},
+	{MISENSOR_16BIT, 0x36fc, 0xa839},
+	{MISENSOR_16BIT, 0x36fe, 0xf297},
+	{MISENSOR_16BIT, 0x3700, 0x64bb},
+	{MISENSOR_16BIT, 0x3702, 0xb5ef},
+	{MISENSOR_16BIT, 0x3704, 0x4375},
+	{MISENSOR_16BIT, 0x3706, 0xa7d9},
+	{MISENSOR_16BIT, 0x3708, 0xcef8},
+	{MISENSOR_16BIT, 0x370a, 0x5abb},
+	{MISENSOR_16BIT, 0x370c, 0x9fb3},
+	{MISENSOR_16BIT, 0x370e, 0x7eb3},
+	{MISENSOR_16BIT, 0x3710, 0x90f9},
+	{MISENSOR_16BIT, 0x3712, 0xde76},
+	{MISENSOR_16BIT, 0x3714, 0x49db},
+	{MISENSOR_16BIT, 0x3644, 0x0320},
+	{MISENSOR_16BIT, 0x3642, 0x0258},
+	{MISENSOR_16BIT, 0x3210, 0x01b8},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig
new file mode 100644
index 0000000..406f38f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Kconfig
@@ -0,0 +1,27 @@
+config VIDEO_MT9E013
+	tristate "Micron mt9e013 sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the Aptina
+	  MT9E013 8MP RAW sensor.
+
+	  It currently depends on internal V4L2 extensions defined in
+	  atomisp driver.
+
+choice
+	prompt "Select sensor settings"
+	depends on VIDEO_MT9E013
+
+config VIDEO_MT9E013_BLACKBAY
+	bool "MT9E013 settings for Blackbay"
+	---help---
+	  Default mt9e013 sensor settings for Blackbay
+config VIDEO_MT9E013_LEXINGTON
+	bool "MT9E013 settings for Lexington"
+	---help---
+	  Default mt9e013 sensor settings for Lexington
+config VIDEO_MT9E013_ENZO
+	bool "MT9E013 settings for Enzo"
+	---help---
+	  Default mt9e013 sensor settings for Enzo
+endchoice
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile
new file mode 100644
index 0000000..32edaf8
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_VIDEO_MT9E013) += mt9e013.o
+EXTRA_CFLAGS := -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c
new file mode 100644
index 0000000..0acd65e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.c
@@ -0,0 +1,2226 @@
+/*
+ * Support for Aptina mt9e013 1080p HD camera sensor.
+ *
+ * Copyright (c) 2011 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_mid_rpmsg.h>
+
+#if defined(CONFIG_VIDEO_MT9E013_LEXINGTON)
+#include "mt9e013_lexington.h"
+#elif defined(CONFIG_VIDEO_MT9E013_ENZO)
+#include "mt9e013_enzo.h"
+#else /* CONFIG_VIDEO_MT9E013_BLACKBAY */
+#include "mt9e013_blackbay.h"
+#endif
+
+#define to_mt9e013_sensor(sd) container_of(sd, struct mt9e013_device, sd)
+
+#define HOME_POS 255
+#define PR3_2_FW 0x0400
+#define PR3_3_FW 0x0500
+
+/* divides a by b using half up rounding and div/0 prevention
+ * (result is 0 if b == 0) */
+#define divsave_rounded(a, b)	(((b) != 0) ? (((a)+((b)>>1))/(b)) : (-1))
+
+static int
+mt9e013_read_reg(struct i2c_client *client, u16 len, u16 reg, u16 *val)
+{
+	u16 data[MT9E013_SHORT_MAX];
+	int err, i;
+
+	struct i2c_msg msg[2] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = I2C_MSG_LENGTH,
+			.buf = (unsigned char *)&reg,
+		}, {
+			.addr = client->addr,
+			.len = len,
+			.flags = I2C_M_RD,
+			.buf = (u8 *)data,
+		}
+	};
+
+	reg = cpu_to_be16(reg);
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	/* @len should be even when > 1 */
+	if (len > MT9E013_BYTE_MAX) {
+		v4l2_err(client, "%s error, invalid data length\n", __func__);
+		return -EINVAL;
+	}
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		goto error;
+	}
+
+	/* high byte comes first */
+	if (len == MT9E013_8BIT) {
+		*val = (u8)data[0];
+	} else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			val[i] = be16_to_cpu(data[i]);
+	}
+
+	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int mt9e013_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	int retry = 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (ret == num_msg)
+		return 0;
+
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying i2c write transfer... %d",
+			retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return ret;
+}
+
+static int
+mt9e013_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MT9E013_8BIT && data_length != MT9E013_16BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+	/* high byte goes out first */
+	*(u16 *)data = cpu_to_be16(reg);
+	switch (data_length) {
+	case MT9E013_8BIT:
+		data[2] = (u8)val;
+		break;
+	case MT9E013_16BIT:
+		*(u16 *)&data[2] = cpu_to_be16(val);
+		break;
+	default:
+		dev_err(&client->dev,
+			"write error: invalid length type %d\n", data_length);
+	}
+
+	ret = mt9e013_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+
+/**
+ * mt9e013_rmw_reg - Read/Modify/Write a value to a register in the sensor
+ * device
+ * @client: i2c driver client structure
+ * @data_length: 8/16-bits length
+ * @reg: register address
+ * @mask: masked out bits
+ * @set: bits set
+ *
+ * Read/modify/write a value to a register in the  sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int mt9e013_rmw_reg(struct i2c_client *client, u16 data_length, u16 reg,
+			   u16 mask, u16 set)
+{
+	int err;
+	u16 val;
+
+	/* Exit when no mask */
+	if (mask == 0)
+		return 0;
+
+	/* @mask must not exceed data length */
+	if (data_length == MT9E013_8BIT && mask & ~0xff)
+		return -EINVAL;
+
+	err = mt9e013_read_reg(client, data_length, reg, &val);
+	if (err) {
+		v4l2_err(client, "mt9e013_rmw_reg error exit, read failed\n");
+		return -EINVAL;
+	}
+
+	val &= ~mask;
+
+	/*
+	 * Perform the OR function if the @set exists.
+	 * Shift @set value to target bit location. @set should set only
+	 * bits included in @mask.
+	 *
+	 * REVISIT: This function expects @set to be non-shifted. Its shift
+	 * value is then defined to be equal to mask's LSB position.
+	 * How about to inform values in their right offset position and avoid
+	 * this unneeded shift operation?
+	 */
+	set <<= ffs(mask) - 1;
+	val |= set & mask;
+
+	err = mt9e013_write_reg(client, data_length, reg, val);
+	if (err) {
+		v4l2_err(client, "mt9e013_rmw_reg error exit, write failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+/*
+ * mt9e013_write_reg_array - Initializes a list of mt9e013 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __mt9e013_flush_reg_array, __mt9e013_buf_reg_array() and
+ * __mt9e013_write_reg_is_consecutive() are internal functions to
+ * mt9e013_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __mt9e013_flush_reg_array(struct i2c_client *client,
+				     struct mt9e013_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return mt9e013_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __mt9e013_buf_reg_array(struct i2c_client *client,
+				   struct mt9e013_write_ctrl *ctrl,
+				   const struct mt9e013_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case MT9E013_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case MT9E013_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg.sreg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= MT9E013_MAX_WRITE_BUF_SIZE)
+		return __mt9e013_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int
+__mt9e013_write_reg_is_consecutive(struct i2c_client *client,
+				   struct mt9e013_write_ctrl *ctrl,
+				   const struct mt9e013_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg.sreg;
+}
+
+static int mt9e013_write_reg_array(struct i2c_client *client,
+				   const struct mt9e013_reg *reglist)
+{
+	const struct mt9e013_reg *next = reglist;
+	struct mt9e013_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != MT9E013_TOK_TERM; next++) {
+		switch (next->type & MT9E013_TOK_MASK) {
+		case MT9E013_TOK_DELAY:
+			err = __mt9e013_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+
+		case MT9E013_RMW:
+			err = __mt9e013_flush_reg_array(client, &ctrl);
+			err |= mt9e013_rmw_reg(client,
+					       next->type & ~MT9E013_RMW,
+					       next->reg.sreg, next->val,
+					       next->val2);
+			if (err) {
+				v4l2_err(client, "%s: rwm error, "
+						"aborted\n", __func__);
+				return err;
+			}
+			break;
+
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__mt9e013_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __mt9e013_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __mt9e013_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __mt9e013_flush_reg_array(client, &ctrl);
+}
+
+static int mt9e013_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	int ret;
+
+	value = min(value, MT9E013_MAX_FOCUS_POS);
+
+	ret = mt9e013_write_reg(client, MT9E013_16BIT, MT9E013_VCM_CODE, value);
+	if (ret == 0) {
+		dev->number_of_steps = value - dev->focus;
+		dev->focus = value;
+		getnstimeofday(&(dev->timestamp_t_focus_abs));
+	}
+	return ret;
+}
+
+static int mt9e013_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	return mt9e013_t_focus_abs(sd, dev->focus + value);
+}
+
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000*40)
+static int mt9e013_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 status = 0;
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct timespec temptime;
+	const struct timespec timedelay = {
+		0,
+		min((u32)abs(dev->number_of_steps)*DELAY_PER_STEP_NS,
+			(u32)DELAY_MAX_PER_STEP_NS),
+	};
+
+	getnstimeofday(&temptime);
+
+	temptime = timespec_sub(temptime, (dev->timestamp_t_focus_abs));
+
+	if (timespec_compare(&temptime, &timedelay) <= 0) {
+		status |= ATOMISP_FOCUS_STATUS_MOVING;
+		status |= ATOMISP_FOCUS_HP_IN_PROGRESS;
+	} else {
+		status |= ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+		status |= ATOMISP_FOCUS_HP_COMPLETE;
+	}
+	*value = status;
+	return 0;
+}
+
+static int mt9e013_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	s32 val;
+
+	mt9e013_q_focus_status(sd, &val);
+
+	if (val & ATOMISP_FOCUS_STATUS_MOVING)
+		*value  = dev->focus - dev->number_of_steps;
+	else
+		*value  = dev->focus ;
+
+	return 0;
+}
+
+static long mt9e013_set_exposure(struct v4l2_subdev *sd, u16 coarse_itg,
+				 u16 fine_itg, u16 gain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 frame_length;
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+
+	ret = mt9e013_read_reg(client, MT9E013_16BIT,
+			       MT9E013_FRAME_LENGTH_LINES, &frame_length);
+	if (ret)
+		goto out;
+
+	/* enable group hold */
+	ret = mt9e013_write_reg_array(client, mt9e013_param_hold);
+	if (ret)
+		goto out;
+
+	/* set coarse integration time */
+	ret = mt9e013_write_reg(client, MT9E013_16BIT,
+			MT9E013_COARSE_INTEGRATION_TIME, coarse_itg);
+	if (ret)
+		goto out_disable;
+
+	/* set fine integration time */
+	ret = mt9e013_write_reg(client, MT9E013_16BIT,
+			MT9E013_FINE_INTEGRATION_TIME, fine_itg);
+	if (ret)
+		goto out_disable;
+
+	/* set global gain */
+	ret = mt9e013_write_reg(client, MT9E013_16BIT,
+			MT9E013_GLOBAL_GAIN, gain);
+
+	if (ret)
+		goto out_disable;
+	dev->gain       = gain;
+	dev->coarse_itg = coarse_itg;
+	dev->fine_itg   = fine_itg;
+
+out_disable:
+	/* disable group hold */
+	mt9e013_write_reg_array(client, mt9e013_param_update);
+out:
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long mt9e013_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	u16 coarse_itg, fine_itg, gain;
+
+	coarse_itg = exposure->integration_time[0];
+	fine_itg = exposure->integration_time[1];
+	gain = exposure->gain[0];
+
+	/* we should not accept the invalid value below */
+	if (fine_itg == 0 || gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+	return mt9e013_set_exposure(sd, coarse_itg, fine_itg, gain);
+}
+
+static int mt9e013_read_reg_array(struct i2c_client *client, u16 size, u16 addr,
+				  void *data)
+{
+	u8 *buf = data;
+	u16 index;
+	int ret = 0;
+
+	for (index = 0; index + MT9E013_BYTE_MAX <= size;
+	     index += MT9E013_BYTE_MAX) {
+		ret = mt9e013_read_reg(client, MT9E013_BYTE_MAX, addr + index,
+				       (u16 *)&buf[index]);
+		if (ret)
+			return ret;
+	}
+
+	if (size - index > 0)
+		ret = mt9e013_read_reg(client, size - index, addr + index,
+				       (u16 *)&buf[index]);
+
+	return ret;
+}
+
+static unsigned long
+mt9e013_otp_sum(struct v4l2_subdev *sd, u8 *buf, u16 start, u16 end)
+{
+	unsigned long sum = 0;
+	u16 i;
+
+	for (i = start; i <= end; i++)
+		sum += buf[i];
+
+	return sum;
+}
+
+static int mt9e013_otp_checksum(struct v4l2_subdev *sd, u8 *buf, int list_len,
+				const struct mt9e013_otp_checksum_format *list)
+{
+	unsigned long sum;
+	u8 checksum;
+	int i;
+	int zero_flag = 1;
+
+	for (i = 0; i < list_len; i++) {
+		sum = mt9e013_otp_sum(sd, buf, list[i].start, list[i].end);
+		checksum = sum % MT9E013_OTP_MOD_CHECKSUM;
+		if (buf[list[i].checksum] != checksum)
+			return -EINVAL;
+		/*
+		 * Checksum must fail if whole data is 0.
+		 * Clear zero_flag if data != 0 is found.
+		 */
+		if (unlikely(zero_flag && (sum > 0)))
+			zero_flag = 0;
+	}
+
+	return !zero_flag ? 0 : -EINVAL;
+}
+
+static int
+__mt9e013_otp_read(struct v4l2_subdev *sd, const struct mt9e013_reg *type,
+		   void *buf)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	int retry = 100;
+	u16 ready;
+
+	ret = mt9e013_write_reg_array(client, type);
+	if (ret) {
+		v4l2_err(client, "%s: failed to prepare OTP memory\n",
+			 __func__);
+		return ret;
+	}
+
+	do {
+		ret = mt9e013_read_reg(client, MT9E013_16BIT,
+				       MT9E013_OTP_READY_REG, &ready);
+		if (ret) {
+			v4l2_err(client, "%s: failed to read OTP memory "
+					 "status\n", __func__);
+			return ret;
+		}
+		if (ready & MT9E013_OTP_READY_REG_DONE)
+			break;
+	} while (--retry);
+
+	if (!retry) {
+		v4l2_err(client, "%s: OTP memory read timeout.\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	if (!(ready & MT9E013_OTP_READY_REG_OK)) {
+		v4l2_err(client, "%s: OTP memory was initialized with error\n",
+			  __func__);
+		return -EIO;
+	}
+	ret = mt9e013_read_reg_array(client, MT9E013_OTP_DATA_SIZE,
+				     MT9E013_OTP_START_ADDR, buf);
+	if (ret) {
+		v4l2_err(client, "%s: failed to read OTP data\n", __func__);
+		return ret;
+	}
+
+	if (MT9E013_OTP_CHECKSUM) {
+		ret = mt9e013_otp_checksum(sd, buf,
+				ARRAY_SIZE(mt9e013_otp_checksum_list),
+				mt9e013_otp_checksum_list);
+		if (ret) {
+			v4l2_err(client, "%s: OTP checksum failed\n", __func__);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void *mt9e013_otp_read(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	void *buf;
+	int ret;
+
+	buf = kmalloc(MT9E013_OTP_DATA_SIZE, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	/*
+	 * Try all banks in reverse order and return after first success.
+	 * Last used bank has most up-to-date data.
+	 */
+	ret = __mt9e013_otp_read(sd, mt9e013_otp_type32, buf);
+	if (!ret)
+		return buf;
+	ret = __mt9e013_otp_read(sd, mt9e013_otp_type31, buf);
+	if (!ret)
+		return buf;
+	ret = __mt9e013_otp_read(sd, mt9e013_otp_type30, buf);
+
+	/* Driver has failed to find valid data */
+	if (ret) {
+		v4l2_err(client, "%s: sensor found no valid OTP data\n",
+			  __func__);
+		kfree(buf);
+		return ERR_PTR(ret);
+	}
+
+	return buf;
+}
+
+static u8 *mt9e013_fuseid_read(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 data[MT9E013_FUSEID_SIZE];
+	u8 *fuseid;
+	int ret, i;
+
+	ret = mt9e013_read_reg_array(client, MT9E013_FUSEID_SIZE,
+				     MT9E013_FUSEID_START_ADDR, &data);
+	if (ret < 0) {
+		v4l2_err(client, "%s: error reading FUSEID.\n", __func__);
+		return ERR_PTR(ret);
+	}
+
+	fuseid = kmalloc(sizeof(*fuseid) * MT9E013_FUSEID_SIZE, GFP_KERNEL);
+
+	if (!fuseid) {
+		v4l2_err(client, "%s: no memory available when reading "
+				 "FUSEID.\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* FUSEID is in reverse order */
+	for (i = 0; i < MT9E013_FUSEID_SIZE; i++)
+		fuseid[i] = data[MT9E013_FUSEID_SIZE - i - 1];
+
+	return fuseid;
+}
+
+static int mt9e013_g_priv_int_data(struct v4l2_subdev *sd,
+				   struct v4l2_private_int_data *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	u8 __user *to = priv->data;
+	u32 read_size = priv->size;
+	int ret;
+
+	/* No OTP data available on sensor */
+	if (!dev->otp_data || !dev->fuseid)
+		return -EIO;
+
+	/* No need to copy data if size is 0 */
+	if (!read_size)
+		goto out;
+
+	/* Correct read_size value only if bigger than maximum */
+	if (read_size > MT9E013_OTP_DATA_SIZE)
+		read_size = MT9E013_OTP_DATA_SIZE;
+
+	ret = copy_to_user(to, dev->otp_data, read_size);
+	if (ret) {
+		v4l2_err(client, "%s: failed to copy OTP data to user\n",
+			 __func__);
+		return -EFAULT;
+	}
+
+	/* No room for FUSEID */
+	if (priv->size <= MT9E013_OTP_DATA_SIZE)
+		goto out;
+
+	read_size = priv->size - MT9E013_OTP_DATA_SIZE;
+	if (read_size > MT9E013_FUSEID_SIZE)
+		read_size = MT9E013_FUSEID_SIZE;
+	to += MT9E013_OTP_DATA_SIZE;
+
+	ret = copy_to_user(to, dev->fuseid, read_size);
+	if (ret) {
+		v4l2_err(client, "%s: failed to copy FUSEID to user\n",
+			 __func__);
+		return -EFAULT;
+	}
+
+out:
+	/* Return correct size */
+	priv->size = MT9E013_OTP_DATA_SIZE + MT9E013_FUSEID_SIZE;
+
+	return 0;
+}
+
+static long mt9e013_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return mt9e013_s_exposure(sd, (struct atomisp_exposure *)arg);
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		return mt9e013_g_priv_int_data(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mt9e013_init_registers(struct v4l2_subdev *sd)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	ret  = mt9e013_write_reg_array(client, mt9e013_reset_register);
+	ret |= mt9e013_write_reg_array(client, mt9e013_pll_timing);
+	ret |= mt9e013_write_reg_array(client, mt9e013_raw_10);
+	ret |= mt9e013_write_reg_array(client, mt9e013_mipi_config);
+	ret |= mt9e013_write_reg_array(client, mt9e013_recommended_settings);
+	ret |= mt9e013_write_reg_array(client, mt9e013_mipi_timing);
+	ret |= mt9e013_write_reg_array(client, mt9e013_scaler);
+	ret |= mt9e013_write_reg_array(client, mt9e013_init_vcm);
+
+	return ret;
+}
+
+static int __mt9e013_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	u8 fw_rev[16];
+
+	/* set inital registers */
+	ret = mt9e013_init_registers(sd);
+
+	/*set VCM to home position */
+	ret |= mt9e013_t_focus_abs(sd, HOME_POS);
+
+	/* restore settings */
+	mt9e013_res = mt9e013_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	/* The only way to detect whether this VCM maintains focus after putting
+	 * the sensor into standby mode is by looking at the SCU FW version.
+	 * PR3.3 or higher runs on FW version 05.00 or higher.
+	 * We cannot distinguish between PR3.2 and PR3.25, so we need to be
+	 * conservative. PR3.25 owners can change the comparison to compare
+	 * to PR3_2_FW instead of PR3_3_FW for testing purposes.
+	 */
+	dev->keeps_focus_pos = false;
+	ret |= rpmsg_send_generic_command(IPCMSG_FW_REVISION, 0, NULL, 0,
+				       (u32 *)fw_rev, 4);
+	if (ret == 0) {
+		u16 fw_version = (fw_rev[15] << 8) | fw_rev[14];
+		dev->keeps_focus_pos = fw_version >= PR3_3_FW;
+	}
+	if (!dev->keeps_focus_pos) {
+		v4l2_warn(sd, "VCM does not maintain focus position in standby"
+			      "mode, using software workaround\n");
+	}
+
+	return ret;
+}
+
+static int mt9e013_init(struct v4l2_subdev *sd, u32 val)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __mt9e013_init(sd, val);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static void mt9e013_uninit(struct v4l2_subdev *sd)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	dev->coarse_itg = 0;
+	dev->fine_itg   = 0;
+	dev->gain       = 0;
+	dev->focus      = MT9E013_INVALID_CONFIG;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	int ret;
+
+       /* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int __mt9e013_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	int ret;
+
+	if (on == 0) {
+		mt9e013_uninit(sd);
+		ret = power_down(sd);
+		dev->power = 0;
+	} else {
+		ret = power_up(sd);
+		if (!ret) {
+			dev->power = 1;
+			/* init motor initial position */
+			return __mt9e013_init(sd, 0);
+		}
+	}
+
+	return ret;
+}
+
+static int mt9e013_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __mt9e013_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int mt9e013_g_chip_ident(struct v4l2_subdev *sd,
+				struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!chip)
+		return -EINVAL;
+
+	v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_MT9E013, 0);
+
+	return 0;
+}
+
+static int
+mt9e013_get_intg_factor(struct i2c_client *client,
+			struct camera_mipi_info *info,
+			const struct mt9e013_reg *reglist)
+{
+	unsigned int	vt_pix_clk_div;
+	unsigned int	vt_sys_clk_div;
+	unsigned int	pre_pll_clk_div;
+	unsigned int	pll_multiplier;
+	unsigned int	op_pix_clk_div;
+	unsigned int	op_sys_clk_div;
+
+    /* TODO: this should not be a constant but should be set by a call to
+     * MSIC's driver to get the ext_clk that MSIC supllies to the sensor.
+     */
+	const int ext_clk_freq_mhz = 19200000;
+	struct atomisp_sensor_mode_data buf;
+	const struct mt9e013_reg *next = reglist;
+	int vt_pix_clk_freq_mhz;
+	u16 data[MT9E013_SHORT_MAX];
+
+	unsigned int coarse_integration_time_min;
+	unsigned int coarse_integration_time_max_margin;
+	unsigned int fine_integration_time_min;
+	unsigned int fine_integration_time_max_margin;
+	unsigned int frame_length_lines;
+	unsigned int line_length_pck;
+	unsigned int read_mode;
+	u16 value;
+	int ret;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	memset(data, 0, MT9E013_SHORT_MAX * sizeof(u16));
+	if (mt9e013_read_reg(client, 12, MT9E013_VT_PIX_CLK_DIV, data))
+		return -EINVAL;
+	vt_pix_clk_div = data[0];
+	vt_sys_clk_div = data[1];
+	pre_pll_clk_div = data[2];
+	pll_multiplier = data[3];
+	op_pix_clk_div = data[4];
+	op_sys_clk_div = data[5];
+
+	memset(data, 0, MT9E013_SHORT_MAX * sizeof(u16));
+	if (mt9e013_read_reg(client, 4, MT9E013_FRAME_LENGTH_LINES, data))
+		return -EINVAL;
+	frame_length_lines = data[0];
+	line_length_pck = data[1];
+
+	memset(data, 0, MT9E013_SHORT_MAX * sizeof(u16));
+	if (mt9e013_read_reg(client, 8, MT9E013_COARSE_INTG_TIME_MIN, data))
+		return -EINVAL;
+	coarse_integration_time_min = data[0];
+	coarse_integration_time_max_margin = data[1];
+	fine_integration_time_min = data[2];
+	fine_integration_time_max_margin = data[3];
+
+	memset(data, 0, MT9E013_SHORT_MAX * sizeof(u16));
+	if (mt9e013_read_reg(client, 2, MT9E013_READ_MODE, data))
+		return -EINVAL;
+	read_mode = data[0];
+
+	vt_pix_clk_freq_mhz = divsave_rounded(ext_clk_freq_mhz*pll_multiplier,
+				pre_pll_clk_div*vt_sys_clk_div*vt_pix_clk_div);
+
+	for (; next->type != MT9E013_TOK_TERM; next++) {
+		if (next->type == MT9E013_16BIT) {
+			if (next->reg.sreg == MT9E013_FINE_INTEGRATION_TIME) {
+				buf.fine_integration_time_def = next->val;
+				break;
+			}
+		}
+	}
+
+	/* something's wrong here, this mode does not have fine_igt set! */
+	if (next->type == MT9E013_TOK_TERM)
+		return -EINVAL;
+
+	buf.coarse_integration_time_min = coarse_integration_time_min;
+	buf.coarse_integration_time_max_margin =
+					coarse_integration_time_max_margin;
+	buf.fine_integration_time_min = fine_integration_time_min;
+	buf.fine_integration_time_max_margin = fine_integration_time_max_margin;
+	buf.vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf.line_length_pck = line_length_pck;
+	buf.frame_length_lines = frame_length_lines;
+	buf.read_mode = read_mode;
+
+	/* 1: normal 3:inc 2, 7:inc 4 addresses in X direction*/
+	buf.binning_factor_x =
+		(((read_mode & MT9E013_READ_MODE_X_ODD_INC) >> 6) + 1) / 2;
+
+	/*
+	 * 1:normal 3:inc 2, 7:inc 4, 15:inc 8, 31:inc 16, 63:inc 32 addresses
+	 * in Y direction
+	 */
+	buf.binning_factor_y =
+			((read_mode & MT9E013_READ_MODE_Y_ODD_INC) + 1) / 2;
+
+	/* Get the cropping and output resolution to ISP for this mode. */
+	ret = mt9e013_read_reg(client, MT9E013_16BIT,
+				MT9E013_HORIZONTAL_START_H, &value);
+	if (ret)
+		return ret;
+	buf.crop_horizontal_start = value;
+
+	ret = mt9e013_read_reg(client, MT9E013_16BIT, MT9E013_VERTICAL_START_H,
+				&value);
+	if (ret)
+		return ret;
+	buf.crop_vertical_start = value;
+
+	ret = mt9e013_read_reg(client, MT9E013_16BIT, MT9E013_HORIZONTAL_END_H,
+				&value);
+	if (ret)
+		return ret;
+	buf.crop_horizontal_end = value;
+
+	ret = mt9e013_read_reg(client, MT9E013_16BIT, MT9E013_VERTICAL_END_H,
+				&value);
+	if (ret)
+		return ret;
+	buf.crop_vertical_end = value;
+
+	ret = mt9e013_read_reg(client, MT9E013_16BIT,
+				MT9E013_HORIZONTAL_OUTPUT_SIZE_H, &value);
+	if (ret)
+		return ret;
+	buf.output_width = value;
+
+	ret = mt9e013_read_reg(client, MT9E013_16BIT,
+				MT9E013_VERTICAL_OUTPUT_SIZE_H, &value);
+	if (ret)
+		return ret;
+	buf.output_height = value;
+
+	memcpy(&info->data, &buf, sizeof(buf));
+
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int mt9e013_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse;
+	int ret;
+
+	/* the fine integration time is currently not calculated */
+	ret = mt9e013_read_reg(client, MT9E013_16BIT,
+			       MT9E013_COARSE_INTEGRATION_TIME, &coarse);
+	*value = coarse;
+
+	return ret;
+}
+
+static int mt9e013_test_pattern(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9e013_write_reg(client, MT9E013_16BIT, 0x3070, value);
+}
+
+static int mt9e013_v_flip(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (value > 1)
+		return -EINVAL;
+
+	ret = mt9e013_write_reg_array(client, mt9e013_param_hold);
+	if (ret)
+		return ret;
+	ret = mt9e013_rmw_reg(client, MT9E013_16BIT & ~MT9E013_RMW,
+			       0x3040, 0x8000, value);
+	if (ret)
+		return ret;
+	return mt9e013_write_reg_array(client, mt9e013_param_update);
+}
+
+
+static int mt9e013_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (value > MT9E013_VCM_SLEW_STEP_MAX)
+		return -EINVAL;
+
+	return mt9e013_rmw_reg(client, MT9E013_16BIT, MT9E013_VCM_SLEW_STEP,
+				MT9E013_VCM_SLEW_STEP_MASK, value);
+}
+
+static int mt9e013_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	/* Max 16 bits */
+	if (value > MT9E013_VCM_SLEW_TIME_MAX)
+		return -EINVAL;
+
+	return mt9e013_write_reg(client, MT9E013_16BIT, MT9E013_VCM_SLEW_TIME,
+				 value);
+}
+
+static int mt9e013_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (MT9E013_FOCAL_LENGTH_NUM << 16) | MT9E013_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int mt9e013_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for mt9e013*/
+	*val = (MT9E013_F_NUMBER_DEFAULT_NUM << 16) | MT9E013_F_NUMBER_DEM;
+	return 0;
+}
+
+static int mt9e013_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (MT9E013_F_NUMBER_DEFAULT_NUM << 24) |
+		(MT9E013_F_NUMBER_DEM << 16) |
+		(MT9E013_F_NUMBER_DEFAULT_NUM << 8) | MT9E013_F_NUMBER_DEM;
+	return 0;
+}
+
+static int mt9e013_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	*val = mt9e013_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int mt9e013_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	*val = mt9e013_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+static struct mt9e013_control mt9e013_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9e013_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_TEST_PATTERN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Test pattern",
+			.minimum = 0,
+			.maximum = 0xffff,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = mt9e013_test_pattern,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = mt9e013_v_flip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move absolute",
+			.minimum = 0,
+			.maximum = MT9E013_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = mt9e013_t_focus_abs,
+		.query = mt9e013_q_focus_abs,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_RELATIVE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus move relative",
+			.minimum = MT9E013_MAX_FOCUS_NEG,
+			.maximum = MT9E013_MAX_FOCUS_POS,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = mt9e013_t_focus_rel,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 100, /* allow enum to grow in the future */
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = mt9e013_q_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VCM_SLEW,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vcm slew",
+			.minimum = 0,
+			.maximum = MT9E013_VCM_SLEW_STEP_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = mt9e013_t_vcm_slew,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VCM_TIMEING,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vcm step time",
+			.minimum = 0,
+			.maximum = MT9E013_VCM_SLEW_TIME_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.tweak = mt9e013_t_vcm_timing,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = MT9E013_FOCAL_LENGTH_DEFAULT,
+			.maximum = MT9E013_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9E013_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9e013_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = MT9E013_F_NUMBER_DEFAULT,
+			.maximum = MT9E013_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9E013_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9e013_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = MT9E013_F_NUMBER_RANGE,
+			.maximum =  MT9E013_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = MT9E013_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = mt9e013_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = MT9E013_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = mt9e013_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = MT9E013_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = mt9e013_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(mt9e013_controls))
+
+static struct mt9e013_control *mt9e013_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (mt9e013_controls[i].qc.id == id)
+			return &mt9e013_controls[i];
+	return NULL;
+}
+
+static int mt9e013_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct mt9e013_control *ctrl = mt9e013_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* mt9e013 control set/get */
+static int mt9e013_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct mt9e013_control *s_ctrl;
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = mt9e013_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int mt9e013_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct mt9e013_control *octrl = mt9e013_find_control(ctrl->id);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+static int distance(struct mt9e013_resolution const *res, const u32 w,
+		    const u32 h, const s32 m)
+{
+	u32 w_ratio = ((res->width<<13)/w);
+	u32 h_ratio = ((res->height<<13)/h);
+	s32 match   = abs(((w_ratio<<13)/h_ratio) - ((s32)8192));
+
+	if ((w_ratio < (s32)8192) || (h_ratio < (s32)8192)  || (match > m))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+
+/*
+ * Tune this value so that the DVS resolutions get selected properly,
+ * but make sure 16:9 does not match 4:3
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 140
+
+/*
+ * Returns the nearest higher resolution index.
+ * @w: width
+ * @h: height
+ * matching is done based on enveloping resolution and
+ * aspect ratio. If the aspect ratio cannot be matched
+ * to any index, the search is done again using envelopel
+ * matching only. if no match can be found again, -1 is
+ * returned.
+ */
+static int nearest_resolution_index(int w, int h)
+{
+	int i, j;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct mt9e013_resolution *tmp_res = NULL;
+	s32 m = LARGEST_ALLOWED_RATIO_MISMATCH;
+
+#ifdef CONFIG_VIDEO_MT9E013_ENZO
+	/*
+	 * For 1080p or 1088p resolutions, we must select index 6.
+	 * This is an exception. If we let algorithm to run, this case
+	 * will fail.
+	 */
+	if (h == 1080 || h == 1088)
+		return 6;
+#endif
+
+	for (j = 0; j < 2; ++j) {
+		for (i = 0; i < N_RES; i++) {
+			tmp_res = &mt9e013_res[i];
+			dist = distance(tmp_res, w, h, m);
+			if (dist == -1)
+				continue;
+			if (dist < min_dist) {
+				min_dist = dist;
+				idx = i;
+			}
+		}
+		if (idx != -1)
+			break;
+		m = LONG_MAX;
+	}
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != mt9e013_res[i].width)
+			continue;
+		if (h != mt9e013_res[i].height)
+			continue;
+		/* Found it */
+		return i;
+	}
+	return -1;
+}
+
+static int __mt9e013_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+
+	if (fmt->width > MT9E013_RES_WIDTH_MAX ||
+	    fmt->height > MT9E013_RES_HEIGHT_MAX) {
+		fmt->width = MT9E013_RES_WIDTH_MAX;
+		fmt->height = MT9E013_RES_HEIGHT_MAX;
+	} else {
+		idx = nearest_resolution_index(fmt->width, fmt->height);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 * resolutions. If it fails, it means the requested
+		 * resolution is higher than we can support.
+		 * Fallback to highest possible resolution in this case.
+		 */
+		if (idx == -1)
+			idx = N_RES - 1;
+
+		fmt->width = mt9e013_res[idx].width;
+		fmt->height = mt9e013_res[idx].height;
+	}
+
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int mt9e013_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __mt9e013_try_mbus_fmt(sd, fmt);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int mt9e013_get_mbus_format_code(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	u16 reg;
+
+	if (!dev->power)
+		return -EIO;
+
+	/*
+	 * Get the order of color pixel readout.
+	 * Change with mirror and flip.
+	 */
+	if (mt9e013_read_reg(client, MT9E013_8BIT,
+			MT9E013_PIXEL_ORDER, &reg)) {
+		return -EIO;
+	}
+	switch (reg) {
+	case MT9E013_PIXEL_ORDER0:
+		return V4L2_MBUS_FMT_SGRBG10_1X10;
+	case MT9E013_PIXEL_ORDER1:
+		return V4L2_MBUS_FMT_SRGGB10_1X10;
+	case MT9E013_PIXEL_ORDER2:
+		return V4L2_MBUS_FMT_SBGGR10_1X10;
+	case MT9E013_PIXEL_ORDER3:
+		return V4L2_MBUS_FMT_SGBRG10_1X10;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int mt9e013_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	const struct mt9e013_reg *mt9e013_def_reg;
+	struct camera_mipi_info *mt9e013_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mt9e013_info = v4l2_get_subdev_hostdata(sd);
+	if (mt9e013_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = __mt9e013_try_mbus_fmt(sd, fmt);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		v4l2_err(sd, "try fmt fail\n");
+		return ret;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width, fmt->height);
+
+	/* Sanity check */
+	if (unlikely(dev->fmt_idx == -1)) {
+		mutex_unlock(&dev->input_lock);
+		v4l2_err(sd, "get resolution fail\n");
+		return -EINVAL;
+	}
+
+	mt9e013_def_reg = mt9e013_res[dev->fmt_idx].regs;
+
+	ret = mt9e013_write_reg_array(client, mt9e013_def_reg);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fmt->code = mt9e013_get_mbus_format_code(sd);
+	if (fmt->code < 0) {
+		mutex_unlock(&dev->input_lock);
+		return fmt->code;
+	}
+	dev->fps = mt9e013_res[dev->fmt_idx].fps;
+	dev->pixels_per_line = mt9e013_res[dev->fmt_idx].pixels_per_line;
+	dev->lines_per_frame = mt9e013_res[dev->fmt_idx].lines_per_frame;
+	dev->coarse_itg = 0;
+	dev->fine_itg = 0;
+	dev->gain = 0;
+
+	ret = mt9e013_get_intg_factor(client, mt9e013_info, mt9e013_def_reg);
+	mutex_unlock(&dev->input_lock);
+	if (ret) {
+		v4l2_err(sd, "failed to get integration_factor\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mt9e013_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fmt->width = mt9e013_res[dev->fmt_idx].width;
+	fmt->height = mt9e013_res[dev->fmt_idx].height;
+	fmt->code = mt9e013_get_mbus_format_code(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return fmt->code < 0 ? fmt->code : 0;
+}
+
+static int mt9e013_detect(struct i2c_client *client, u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 reg;
+
+	/* i2c check */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	/* check sensor chip model and revision IDs */
+	if (mt9e013_read_reg(client, MT9E013_16BIT, MT9E013_SC_CMMN_CHIP_ID,
+				id)) {
+		v4l2_err(client, "Reading sensor_id error.\n");
+		return -ENODEV;
+	}
+
+	if (*id != MT9E013_ID && *id != MT9E013_ID2) {
+		v4l2_err(client,
+			"sensor ID error, sensor_id = 0x%x\n", *id);
+		return -ENODEV;
+	}
+
+	if (mt9e013_read_reg(client, MT9E013_8BIT, MT9E013_SC_CMMN_REV_ID,
+				&reg)) {
+		v4l2_err(client, "Reading sensor_rev_id error.\n");
+		return -ENODEV;
+	}
+	*revision = (u8)reg;
+
+	return 0;
+}
+
+/*
+ * mt9e013 stream on/off
+ */
+static int mt9e013_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (enable) {
+		if (!dev->keeps_focus_pos) {
+			struct mt9e013_reg mt9e013_stream_enable[] = {
+				mt9e013_streaming[0],
+				{MT9E013_16BIT, {0x30F2}, 0x0000}, /* VCM_NEW_CODE */
+				INIT_VCM_CONTROL,
+				{MT9E013_16BIT, {0x30F2}, 0x0000}, /* VCM_NEW_CODE */
+				{MT9E013_TOK_DELAY, {0}, 60},
+				{MT9E013_TOK_TERM, {0}, 0}
+			};
+
+			mt9e013_stream_enable[1].val = dev->focus + 1;
+			mt9e013_stream_enable[3].val = dev->focus;
+
+			ret = mt9e013_write_reg_array(client, mt9e013_stream_enable);
+		} else {
+			ret = mt9e013_write_reg_array(client, mt9e013_streaming);
+		}
+
+		if (ret != 0) {
+			mutex_unlock(&dev->input_lock);
+			v4l2_err(client, "write_reg_array err\n");
+			return ret;
+		}
+		dev->streaming = 1;
+	} else {
+
+		ret = mt9e013_write_reg_array(client, mt9e013_soft_standby);
+		if (ret != 0) {
+			mutex_unlock(&dev->input_lock);
+			v4l2_err(client, "write_reg_array err\n");
+			return ret;
+		}
+		dev->streaming = 0;
+	}
+
+	/* restore settings */
+	mt9e013_res = mt9e013_res_preview;
+	N_RES = N_RES_PREVIEW;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/*
+ * mt9e013 enum frame size, frame intervals
+ */
+static int mt9e013_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = mt9e013_res[index].width;
+	fsize->discrete.height = mt9e013_res[index].height;
+	fsize->reserved[0] = mt9e013_res[index].used;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int mt9e013_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+
+	/*
+	 * Since the isp will donwscale the resolution to the right size,
+	 * find the nearest one that will allow the isp to do so important
+	 * to ensure that the resolution requested is padded correctly by
+	 * the requester, which is the atomisp driver in this case.
+	 */
+	index = nearest_resolution_index(fival->width, fival->height);
+
+	if (-1 == index) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+/*	fival->width = mt9e013_res[index].width;
+	fival->height = mt9e013_res[index].height; */
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = mt9e013_res[index].fps;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int mt9e013_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*code = mt9e013_get_mbus_format_code(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return *code < 0 ? *code : 0;
+}
+
+static int mt9e013_s_config(struct v4l2_subdev *sd,
+			    int irq, void *pdata)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+	void *otp_data;
+	void *fuseid;
+
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	/*
+	 * The initial state of physical power is unknown
+	 * so first power down it to make it to a known
+	 * state, and then start the power up sequence
+	 */
+	power_down(sd);
+	msleep(20);
+
+	ret = __mt9e013_s_power(sd, 1);
+	if (ret) {
+		v4l2_err(client, "mt9e013 power-up err.\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = mt9e013_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		v4l2_err(client, "mt9e013_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	/* Read sensor's OTP data */
+	otp_data = mt9e013_otp_read(sd);
+	if (!IS_ERR(otp_data))
+		dev->otp_data = otp_data;
+
+	fuseid = mt9e013_fuseid_read(sd);
+	if (!IS_ERR(fuseid))
+		dev->fuseid = fuseid;
+
+	/* power off sensor */
+	ret = __mt9e013_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	if (ret) {
+		v4l2_err(client, "mt9e013 power-down err.\n");
+		return ret;
+	}
+
+	return 0;
+
+fail_detect:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_csi_cfg:
+	__mt9e013_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int
+mt9e013_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	code->code = mt9e013_get_mbus_format_code(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return code->code < 0 ? code->code : 0;
+}
+
+static int
+mt9e013_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fse->min_width = mt9e013_res[index].width;
+	fse->min_height = mt9e013_res[index].height;
+	fse->max_width = mt9e013_res[index].width;
+	fse->max_height = mt9e013_res[index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mt9e013_get_pad_format(struct mt9e013_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		v4l2_err(client, "%s err. pad %x\n", __func__, pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+mt9e013_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9e013_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+mt9e013_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9e013_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+
+	return 0;
+}
+
+static int
+mt9e013_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->streaming) {
+		mutex_unlock(&dev->input_lock);
+		return -EBUSY;
+	}
+
+	dev->run_mode = param->parm.capture.capturemode;
+
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		mt9e013_res = mt9e013_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		mt9e013_res = mt9e013_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		mt9e013_res = mt9e013_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+
+	/* Reset sensor mode */
+	dev->fmt_idx = 0;
+	dev->fps = mt9e013_res[dev->fmt_idx].fps;
+	dev->pixels_per_line = mt9e013_res[dev->fmt_idx].pixels_per_line;
+	dev->lines_per_frame = mt9e013_res[dev->fmt_idx].lines_per_frame;
+	dev->coarse_itg = 0;
+	dev->fine_itg = 0;
+	dev->gain = 0;
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int
+mt9e013_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 lines_per_frame;
+
+	mutex_lock(&dev->input_lock);
+
+	/*
+	 * if no specific information to calculate the fps,
+	 * just used the value in sensor settings
+	 */
+	if (!dev->pixels_per_line || !dev->lines_per_frame) {
+		interval->interval.numerator = 1;
+		interval->interval.denominator = dev->fps;
+		mutex_unlock(&dev->input_lock);
+		return 0;
+	}
+
+	/*
+	 * DS: if coarse_integration_time is set larger than
+	 * lines_per_frame the frame_size will be expanded to
+	 * coarse_integration_time+1
+	 */
+	if (dev->coarse_itg > dev->lines_per_frame) {
+		if (dev->coarse_itg == 0xFFFF) {
+			/*
+			 * we can not add 1 according to ds, as this will
+			 * cause over flow
+			 */
+			v4l2_warn(client, "%s: abnormal coarse_itg:0x%x\n",
+				  __func__, dev->coarse_itg);
+			lines_per_frame = dev->coarse_itg;
+		} else
+			lines_per_frame = dev->coarse_itg + 1;
+	} else
+		lines_per_frame = dev->lines_per_frame;
+
+	interval->interval.numerator = dev->pixels_per_line *
+					lines_per_frame;
+	interval->interval.denominator = MT9E013_MCLK * 1000000;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int mt9e013_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	if (frames == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*frames = mt9e013_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+static const struct v4l2_subdev_video_ops mt9e013_video_ops = {
+	.s_stream = mt9e013_s_stream,
+	.enum_framesizes = mt9e013_enum_framesizes,
+	.enum_frameintervals = mt9e013_enum_frameintervals,
+	.enum_mbus_fmt = mt9e013_enum_mbus_fmt,
+	.try_mbus_fmt = mt9e013_try_mbus_fmt,
+	.g_mbus_fmt = mt9e013_g_mbus_fmt,
+	.s_mbus_fmt = mt9e013_s_mbus_fmt,
+	.s_parm = mt9e013_s_parm,
+	.g_frame_interval = mt9e013_g_frame_interval,
+};
+
+static struct v4l2_subdev_sensor_ops mt9e013_sensor_ops = {
+	.g_skip_frames	= mt9e013_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops mt9e013_core_ops = {
+	.g_chip_ident = mt9e013_g_chip_ident,
+	.queryctrl = mt9e013_queryctrl,
+	.g_ctrl = mt9e013_g_ctrl,
+	.s_ctrl = mt9e013_s_ctrl,
+	.s_power = mt9e013_s_power,
+	.ioctl = mt9e013_ioctl,
+	.init = mt9e013_init,
+};
+
+/* REVISIT: Do we need pad operations? */
+static const struct v4l2_subdev_pad_ops mt9e013_pad_ops = {
+	.enum_mbus_code = mt9e013_enum_mbus_code,
+	.enum_frame_size = mt9e013_enum_frame_size,
+	.get_fmt = mt9e013_get_pad_format,
+	.set_fmt = mt9e013_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops mt9e013_ops = {
+	.core = &mt9e013_core_ops,
+	.video = &mt9e013_video_ops,
+	.pad = &mt9e013_pad_ops,
+	.sensor = &mt9e013_sensor_ops,
+};
+
+static const struct media_entity_operations mt9e013_entity_ops = {
+	.link_setup = NULL,
+};
+
+static int mt9e013_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct mt9e013_device *dev = to_mt9e013_sensor(sd);
+
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	kfree(dev->otp_data);
+	kfree(dev->fuseid);
+	kfree(dev);
+
+	return 0;
+}
+
+static int mt9e013_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct mt9e013_device *dev;
+	int ret;
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		v4l2_err(client, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &mt9e013_ops);
+
+	if (client->dev.platform_data) {
+		ret = mt9e013_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.ops = &mt9e013_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	dev->format.code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		mt9e013_remove(client);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id mt9e013_id[] = {
+	{MT9E013_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, mt9e013_id);
+
+static struct i2c_driver mt9e013_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = MT9E013_NAME,
+	},
+	.probe = mt9e013_probe,
+	.remove = mt9e013_remove,
+	.id_table = mt9e013_id,
+};
+
+static __init int init_mt9e013(void)
+{
+	return i2c_add_driver(&mt9e013_driver);
+}
+
+static __exit void exit_mt9e013(void)
+{
+	i2c_del_driver(&mt9e013_driver);
+}
+
+module_init(init_mt9e013);
+module_exit(exit_mt9e013);
+
+MODULE_DESCRIPTION("A low-level driver for Aptina MT9E013 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h
new file mode 100644
index 0000000..ea36b0d
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013.h
@@ -0,0 +1,454 @@
+/*
+ * Support for Aptina MT9E013 camera sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MT9E013_H__
+#define __MT9E013_H__
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/types.h>
+#include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define	MT9E013_NAME	"mt9e013"
+#define	MT9E013_ADDR	0x36
+#define MT9E013_ID	0x4b00
+#define MT9E013_ID2	0x4b01
+
+#define	LAST_REG_SETING		{0xffff, 0xff}
+#define	is_last_reg_setting(item) ((item).reg == 0xffff)
+#define I2C_MSG_LENGTH		0x2
+
+#define MT9E013_INVALID_CONFIG	0xffffffff
+
+#define MT9E013_MAX_FOCUS_POS	255
+#define MT9E013_MAX_FOCUS_NEG	(-255)
+
+#define MT9E013_INTG_UNIT_US	100
+#define MT9E013_MCLK		192
+
+#define MT9E013_REG_BITS	16
+#define MT9E013_REG_MASK	0xFFFF
+
+/* This should be added into include/linux/videodev2.h */
+#ifndef V4L2_IDENT_MT9E013
+#define V4L2_IDENT_MT9E013	8245
+#endif
+
+/*
+ * mt9e013 System control registers
+ */
+#define MT9E013_SC_CMMN_CHIP_ID                 0x0000
+#define MT9E013_SC_CMMN_REV_ID		        0x0002
+
+#define GROUPED_PARAMETER_UPDATE		0x0000
+#define GROUPED_PARAMETER_HOLD			0x0100
+#define MT9E013_GROUPED_PARAMETER_HOLD		0x0104
+
+#define MT9E013_VT_PIX_CLK_DIV			0x0300
+#define MT9E013_VT_SYS_CLK_DIV			0x0302
+#define MT9E013_PRE_PLL_CLK_DIV			0x0304
+#define MT9E013_PLL_MULTIPLIER			0x0306
+#define MT9E013_OP_PIX_DIV			0x0308
+#define MT9E013_OP_SYS_DIV			0x030A
+#define MT9E013_FRAME_LENGTH_LINES		0x0340
+#define MT9E013_LINE_LENGTH_PCK			0x0342
+#define MT9E013_COARSE_INTG_TIME_MIN		0x1004
+#define MT9E013_COARSE_INTG_TIME_MAX		0x1006
+#define MT9E013_FINE_INTG_TIME_MIN		0x1008
+#define MT9E013_FINE_INTG_MIN_DEF		0x4FE
+#define MT9E013_FINE_INTG_TIME_MAX		0x100A
+#define MT9E013_FINE_INTG_MAX_DEF		0x3EE
+
+#define MT9E013_READ_MODE				0x3040
+#define MT9E013_READ_MODE_X_ODD_INC		(BIT(6) | BIT(7) | BIT(8))
+#define MT9E013_READ_MODE_Y_ODD_INC		(BIT(0) | BIT(1) | BIT(2) |\
+						BIT(3) | BIT(4) | BIT(5))
+
+#define MT9E013_HORIZONTAL_START_H		0x0344
+#define MT9E013_VERTICAL_START_H		0x0346
+#define MT9E013_HORIZONTAL_END_H		0x0348
+#define MT9E013_VERTICAL_END_H			0x034a
+#define MT9E013_HORIZONTAL_OUTPUT_SIZE_H	0x034c
+#define MT9E013_VERTICAL_OUTPUT_SIZE_H		0x034e
+
+#define MT9E013_COARSE_INTEGRATION_TIME		0x3012
+#define MT9E013_FINE_INTEGRATION_TIME		0x3014
+#define MT9E013_ROW_SPEED			0x3016
+#define MT9E013_PIXEL_ORDER			0x0006
+#define MT9E013_GLOBAL_GAIN			0x305e
+#define MT9E013_GLOBAL_GAIN_WR			0x1000
+#define MT9E013_TEST_PATTERN_MODE		0x3070
+#define MT9E013_VCM_SLEW_STEP			0x30F0
+#define MT9E013_VCM_SLEW_STEP_MAX		0x7
+#define MT9E013_VCM_SLEW_STEP_MASK		0x7
+#define MT9E013_VCM_CODE			0x30F2
+#define MT9E013_VCM_SLEW_TIME			0x30F4
+#define MT9E013_VCM_SLEW_TIME_MAX		0xffff
+#define MT9E013_VCM_ENABLE			0x8000
+
+/* mt9e013 SCCB */
+#define MT9E013_SCCB_CTRL			0x3100
+#define MT9E013_AEC_PK_EXPO_H			0x3500
+#define MT9E013_AEC_PK_EXPO_M			0x3501
+#define MT9E013_AEC_PK_EXPO_L			0x3502
+#define MT9E013_AEC_MANUAL_CTRL			0x3503
+#define MT9E013_AGC_ADJ_H			0x3508
+#define MT9E013_AGC_ADJ_L			0x3509
+
+#define MT9E013_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define MT9E013_FOCAL_LENGTH_DEM	100
+#define MT9E013_F_NUMBER_DEFAULT_NUM	24
+#define MT9E013_F_NUMBER_DEM	10
+
+#define MT9E013_X_ADDR_MIN	0X1180
+#define MT9E013_Y_ADDR_MIN	0X1182
+#define MT9E013_X_ADDR_MAX	0X1184
+#define MT9E013_Y_ADDR_MAX	0X1186
+
+#define MT9E013_MIN_FRAME_LENGTH_LINES	0x1140
+#define MT9E013_MAX_FRAME_LENGTH_LINES	0x1142
+#define MT9E013_MIN_LINE_LENGTH_PCK	0x1144
+#define MT9E013_MAX_LINE_LENGTH_PCK	0x1146
+#define MT9E013_MIN_LINE_BLANKING_PCK	0x1148
+#define MT9E013_MIN_FRAME_BLANKING_LINES 0x114A
+#define MT9E013_X_OUTPUT_SIZE	0x034C
+#define MT9E013_Y_OUTPUT_SIZE	0x034E
+
+#define MT9E013_BIN_FACTOR_MAX			3
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9E013_FOCAL_LENGTH_DEFAULT 0x1B70064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9E013_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define MT9E013_F_NUMBER_RANGE 0x180a180a
+#define OTPM_ADD_START_1		0x1000
+#define OTPM_DATA_LENGTH_1		0x0100
+#define OTPM_COUNT 0x200
+
+/* Defines for register writes and register array processing */
+#define MT9E013_BYTE_MAX	30
+#define MT9E013_SHORT_MAX	16
+#define I2C_RETRY_COUNT		5
+#define MT9E013_TOK_MASK	0xfff0
+
+#define	MT9E013_STATUS_POWER_DOWN	0x0
+#define	MT9E013_STATUS_STANDBY		0x2
+#define	MT9E013_STATUS_ACTIVE		0x3
+#define	MT9E013_STATUS_VIEWFINDER	0x4
+
+#define MT9E013_PIXEL_ORDER0	0x0
+#define MT9E013_PIXEL_ORDER1	0x1
+#define MT9E013_PIXEL_ORDER2	0x2
+#define MT9E013_PIXEL_ORDER3	0x3
+
+struct s_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
+};
+
+enum mt9e013_tok_type {
+	MT9E013_8BIT  = 0x0001,
+	MT9E013_16BIT = 0x0002,
+	MT9E013_RMW   = 0x0010,
+	MT9E013_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	MT9E013_TOK_DELAY  = 0xfe00	/* delay token for reg list */
+};
+
+/*
+ * If register address or register width is not 32 bit width,
+ * user needs to convert it manually
+ */
+
+struct s_register_setting {
+	u32 reg;
+	u32 val;
+};
+
+struct s_output_format {
+	struct v4l2_format v4l2_fmt;
+	int fps;
+};
+
+/**
+ * struct mt9e013_fwreg - Firmware burst command
+ * @type: FW burst or 8/16 bit register
+ * @addr: 16-bit offset to register or other values depending on type
+ * @val: data value for burst (or other commands)
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct mt9e013_fwreg {
+	enum mt9e013_tok_type type; /* value, register or FW burst string */
+	u16 addr;	/* target address */
+	u32 val[8];
+};
+
+/**
+ * struct mt9e013_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct mt9e013_reg {
+	enum mt9e013_tok_type type;
+	union {
+		u16 sreg;
+		struct mt9e013_fwreg *fwreg;
+	} reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+	u32 val2;	/* optional: for rmw, OR mask */
+};
+
+/* Store macro values' debug names */
+struct macro_string {
+	u8 val;
+	char *string;
+};
+
+static inline const char *
+macro_to_string(const struct macro_string *array, int size, u8 val)
+{
+	int i;
+	for (i = 0; i < size; i++) {
+		if (array[i].val == val)
+			return array[i].string;
+	}
+	return "Unknown VAL";
+}
+
+struct mt9e013_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+struct mt9e013_resolution {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	bool used;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	const struct mt9e013_reg *regs;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	unsigned short skip_frames;
+};
+
+struct mt9e013_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct s_register_setting *regs;
+};
+
+#define MT9E013_FUSEID_SIZE		8
+#define MT9E013_FUSEID_START_ADDR	0x31f4
+
+/* mt9e013 device structure */
+struct mt9e013_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int fmt_idx;
+	int status;
+	int streaming;
+	int power;
+	u16 sensor_id;
+	u8 sensor_revision;
+	u16 coarse_itg;
+	u16 fine_itg;
+	u16 gain;
+	u32 focus;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 fps;
+	int run_mode;
+	struct timespec timestamp_t_focus_abs;
+	s16 number_of_steps;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	void *otp_data;
+	void *fuseid;
+	/* Older VCMs could not maintain the focus position in standby mode. */
+	bool keeps_focus_pos;
+};
+
+#define MT9E013_MAX_WRITE_BUF_SIZE	32
+struct mt9e013_write_buffer {
+	u16 addr;
+	u8 data[MT9E013_MAX_WRITE_BUF_SIZE];
+};
+
+struct mt9e013_write_ctrl {
+	int index;
+	struct mt9e013_write_buffer buffer;
+};
+
+#define MT9E013_OTP_START_ADDR		0x3800
+#define MT9E013_OTP_DATA_SIZE		456
+#define MT9E013_OTP_READY_REG		0x304a
+#define MT9E013_OTP_READY_REG_DONE	(1 << 5)
+#define MT9E013_OTP_READY_REG_OK	(1 << 6)
+
+static const struct mt9e013_reg mt9e013_otp_type30[] = {
+	{MT9E013_16BIT, {0x3134}, 0xcd95},
+	{MT9E013_16BIT, {0x304c}, 0x3000},
+	{MT9E013_16BIT, {0x304a}, 0x0010},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_otp_type31[] = {
+	{MT9E013_16BIT, {0x3134}, 0xcd95},
+	{MT9E013_16BIT, {0x304c}, 0x3100},
+	{MT9E013_16BIT, {0x304a}, 0x0010},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_otp_type32[] = {
+	{MT9E013_16BIT, {0x3134}, 0xcd95},
+	{MT9E013_16BIT, {0x304c}, 0x3200},
+	{MT9E013_16BIT, {0x304a}, 0x0010},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+#define MT9E013_OTP_CHECKSUM		1
+#define MT9E013_OTP_MOD_CHECKSUM	255
+
+/*
+ * Checksum entries in OTP data:
+ * @start: start offset of checksum's input data
+ * @end: end offset of checksum's input data
+ * @checksum: offset where checksum is placed
+ */
+struct mt9e013_otp_checksum_format {
+	u16 start;
+	u16 end;
+	u16 checksum;
+};
+
+static const struct mt9e013_otp_checksum_format
+mt9e013_otp_checksum_list[] = {
+	{0x0004, 0x00d7, 0x00e1},
+	{0x00d8, 0x00df, 0x00e0},
+	{0x00e4, 0x01b7, 0x01c1},
+	{0x01b8, 0x01bf, 0x01c0},
+	{0x0000, 0x01c3, 0x01c4},
+};
+
+/* Start Streaming
+ * reset_register_restart_bad = 1
+ * reset_register_mask_bad = 1
+ * reset_register_lock_reg = 1
+ * grouped_parameter_hold = 0
+ * reset_register_stream = 1 */
+
+static const struct mt9e013_reg mt9e013_start_streaming[] = {
+	{MT9E013_16BIT+MT9E013_RMW, {0x301A}, 0x0200, 0x1},
+	{MT9E013_16BIT+MT9E013_RMW, {0x301A}, 0x0400, 0x1},
+	{MT9E013_16BIT+MT9E013_RMW, {0x301A}, 0x8, 0x1},
+	{MT9E013_16BIT, {0x0104}, 0x0},
+	{MT9E013_16BIT+MT9E013_RMW, {0x301A}, 0x4, 0x1},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+#define GROUPED_PARAMETER_HOLD_ENABLE	{MT9E013_8BIT, {0x0104}, 0x1}
+
+#define GROUPED_PARAMETER_HOLD_DISABLE	{MT9E013_8BIT, {0x0104}, 0x0}
+
+#define INIT_VCM_CONTROL {MT9E013_16BIT, {0x30F0}, 0x800C} /* slew_rate[2:0] */
+static const struct mt9e013_reg mt9e013_init_vcm[] = {
+	INIT_VCM_CONTROL,				   /* VCM_CONTROL */
+	{MT9E013_16BIT, {0x30F2}, 0x0000}, /* VCM_NEW_CODE */
+	{MT9E013_16BIT, {0x30F4}, 0x0080}, /* VCM_STEP_TIME */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+#define RESET_REGISTER	{MT9E013_16BIT, {0x301A}, 0x4A38}
+static const struct mt9e013_reg mt9e013_reset_register[] = {
+	RESET_REGISTER,
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_raw_10[] = {
+	{MT9E013_16BIT, {0x0112}, 0x0A0A}, /* CCP_DATA_FORMAT, set to RAW10 mode */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_scaler[] = {
+	{MT9E013_16BIT, {0x0400}, 0x0000}, /* SCALE_MODE: 0:disable */
+	{MT9E013_16BIT, {0x0404}, 0x0010}, /* SCALE_M = 16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+
+static const struct mt9e013_reg mt9e013_soft_standby[] = {
+	{MT9E013_8BIT, {0x301C}, 0x00},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_streaming[] = {
+	{MT9E013_8BIT, {0x301C}, 0x01},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_param_hold[] = {
+	{MT9E013_8BIT, {0x0104}, 0x01},	/* GROUPED_PARAMETER_HOLD */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_param_update[] = {
+	{MT9E013_8BIT, {0x0104}, 0x00},	/* GROUPED_PARAMETER_HOLD */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h
new file mode 100644
index 0000000..b80299b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_blackbay.h
@@ -0,0 +1,810 @@
+/*
+ * Support for Aptina MT9E013 camera sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MT9E013_BLACKBAY_H__
+#define __MT9E013_BLACKBAY_H__
+
+#include "mt9e013.h"
+
+#define MAX_FMTS 1
+
+#define MT9E013_RES_WIDTH_MAX	3280
+#define MT9E013_RES_HEIGHT_MAX	2464
+
+/* Recommended Settings 29 Mar 2011*/
+static const struct mt9e013_reg mt9e013_recommended_settings[] = {
+	{MT9E013_16BIT, {0x3044}, 0x0590},
+	{MT9E013_16BIT, {0x306E}, 0xFC80},
+	{MT9E013_16BIT, {0x30B2}, 0xC000},
+	{MT9E013_16BIT, {0x30D6}, 0x0800},
+	{MT9E013_16BIT, {0x316C}, 0xB42F},
+	{MT9E013_16BIT, {0x316E}, 0x869A},
+	{MT9E013_16BIT, {0x3170}, 0x210E},
+	{MT9E013_16BIT, {0x317A}, 0x010E},
+	{MT9E013_16BIT, {0x31E0}, 0x1FB9},
+	{MT9E013_16BIT, {0x31E6}, 0x07FC},
+	{MT9E013_16BIT, {0x37C0}, 0x0000},
+	{MT9E013_16BIT, {0x37C2}, 0x0000},
+	{MT9E013_16BIT, {0x37C4}, 0x0000},
+	{MT9E013_16BIT, {0x37C6}, 0x0000},
+	{MT9E013_16BIT, {0x3E00}, 0x0011},
+	{MT9E013_16BIT, {0x3E02}, 0x8801},
+	{MT9E013_16BIT, {0x3E04}, 0x2801},
+	{MT9E013_16BIT, {0x3E06}, 0x8449},
+	{MT9E013_16BIT, {0x3E08}, 0x6841},
+	{MT9E013_16BIT, {0x3E0A}, 0x400C},
+	{MT9E013_16BIT, {0x3E0C}, 0x1001},
+	{MT9E013_16BIT, {0x3E0E}, 0x2603},
+	{MT9E013_16BIT, {0x3E10}, 0x4B41},
+	{MT9E013_16BIT, {0x3E12}, 0x4B24},
+	{MT9E013_16BIT, {0x3E14}, 0xA3CF},
+	{MT9E013_16BIT, {0x3E16}, 0x8802},
+	{MT9E013_16BIT, {0x3E18}, 0x84FF},
+	{MT9E013_16BIT, {0x3E1A}, 0x8601},
+	{MT9E013_16BIT, {0x3E1C}, 0x8401},
+	{MT9E013_16BIT, {0x3E1E}, 0x840A},
+	{MT9E013_16BIT, {0x3E20}, 0xFF00},
+	{MT9E013_16BIT, {0x3E22}, 0x8401},
+	{MT9E013_16BIT, {0x3E24}, 0x00FF},
+	{MT9E013_16BIT, {0x3E26}, 0x0088},
+	{MT9E013_16BIT, {0x3E28}, 0x2E8A},
+	{MT9E013_16BIT, {0x3E30}, 0x0000},
+	{MT9E013_16BIT, {0x3E32}, 0x8801},
+	{MT9E013_16BIT, {0x3E34}, 0x4029},
+	{MT9E013_16BIT, {0x3E36}, 0x00FF},
+	{MT9E013_16BIT, {0x3E38}, 0x8469},
+	{MT9E013_16BIT, {0x3E3A}, 0x00FF},
+	{MT9E013_16BIT, {0x3E3C}, 0x2801},
+	{MT9E013_16BIT, {0x3E3E}, 0x3E2A},
+	{MT9E013_16BIT, {0x3E40}, 0x1C01},
+	{MT9E013_16BIT, {0x3E42}, 0xFF84},
+	{MT9E013_16BIT, {0x3E44}, 0x8401},
+	{MT9E013_16BIT, {0x3E46}, 0x0C01},
+	{MT9E013_16BIT, {0x3E48}, 0x8401},
+	{MT9E013_16BIT, {0x3E4A}, 0x00FF},
+	{MT9E013_16BIT, {0x3E4C}, 0x8402},
+	{MT9E013_16BIT, {0x3E4E}, 0x8984},
+	{MT9E013_16BIT, {0x3E50}, 0x6628},
+	{MT9E013_16BIT, {0x3E52}, 0x8340},
+	{MT9E013_16BIT, {0x3E54}, 0x00FF},
+	{MT9E013_16BIT, {0x3E56}, 0x4A42},
+	{MT9E013_16BIT, {0x3E58}, 0x2703},
+	{MT9E013_16BIT, {0x3E5A}, 0x6752},
+	{MT9E013_16BIT, {0x3E5C}, 0x3F2A},
+	{MT9E013_16BIT, {0x3E5E}, 0x846A},
+	{MT9E013_16BIT, {0x3E60}, 0x4C01},
+	{MT9E013_16BIT, {0x3E62}, 0x8401},
+	{MT9E013_16BIT, {0x3E66}, 0x3901},
+	{MT9E013_16BIT, {0x3E90}, 0x2C01},
+	{MT9E013_16BIT, {0x3E98}, 0x2B02},
+	{MT9E013_16BIT, {0x3E92}, 0x2A04},
+	{MT9E013_16BIT, {0x3E94}, 0x2509},
+	{MT9E013_16BIT, {0x3E96}, 0x0000},
+	{MT9E013_16BIT, {0x3E9A}, 0x2905},
+	{MT9E013_16BIT, {0x3E9C}, 0x00FF},
+	{MT9E013_16BIT, {0x3ECC}, 0x00EB},
+	{MT9E013_16BIT, {0x3ED0}, 0x1E24},
+	{MT9E013_16BIT, {0x3ED4}, 0xAFC4},
+	{MT9E013_16BIT, {0x3ED6}, 0x909B},
+	{MT9E013_16BIT, {0x3EE0}, 0x2424},
+	{MT9E013_16BIT, {0x3EE2}, 0x9797},
+	{MT9E013_16BIT, {0x3EE4}, 0xC100},
+	{MT9E013_16BIT, {0x3EE6}, 0x0540},
+	{MT9E013_16BIT, {0x3174}, 0x8000},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_pll_timing[] = {
+	/* pixelrate into the isp = 153.600.000 Hz */
+	{MT9E013_16BIT, {0x0300}, 0x0004}, /* vt_pix_clk_div = 4, internal pixel clk freq = 192.000MHz */
+	{MT9E013_16BIT, {0x0302}, 0x0001}, /* vt_sys_clk_div = 1 */
+	{MT9E013_16BIT, {0x0304}, 0x0001}, /* pre_pll_clk_div = 1 PLL input clock freq = 19.200MHz */
+	{MT9E013_16BIT, {0x0306}, 0x0028}, /* pll_multiplier = 40 mipi bus speed = 768.000MHz */
+	{MT9E013_16BIT, {0x0308}, 0x000A}, /* op_pix_clk_div = 10, output pixel clk freq = 76.800MHz */
+	{MT9E013_16BIT, {0x030A}, 0x0001}, /* op_sys_clk_div = 1 */
+	{MT9E013_16BIT, {0x3016}, 0x0111}, /* row_speed = 273 */
+	{MT9E013_TOK_DELAY, {0}, 1},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*2-lane MIPI Interface Configuration*/
+static const struct mt9e013_reg mt9e013_mipi_config[] = {
+	{MT9E013_16BIT+MT9E013_RMW, {0x3064}, 0x0100, 0x0000},
+	{MT9E013_16BIT, {0x31AE}, 0x0202},
+	{MT9E013_16BIT, {0x31B8}, 0x03EF},
+	/*{MT9E013_16BIT, {0x31B8}, 0x2FEF}, */
+	{MT9E013_TOK_DELAY, {0}, 5},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/* MIPI Timing Settings */
+static const struct mt9e013_reg mt9e013_mipi_timing[] = {
+	{MT9E013_16BIT, {0x31B0}, 0x0083},
+	{MT9E013_16BIT, {0x31B2}, 0x004D},
+	{MT9E013_16BIT, {0x31B4}, 0x0E88},
+	{MT9E013_16BIT, {0x31B6}, 0x0D24},
+	{MT9E013_16BIT, {0x31B8}, 0x020E},
+	{MT9E013_16BIT, {0x31BA}, 0x0710},
+	{MT9E013_16BIT, {0x31BC}, 0x2A0D},
+	{MT9E013_16BIT, {0x31BE}, 0xC007},
+	{MT9E013_TOK_DELAY, {0}, 5},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************still15ok*****************************/
+static struct mt9e013_reg const mt9e013_STILL_8M_15fps[] = {
+	/*	STILL 8M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
+	{MT9E013_16BIT, {0x034E},	0x09A0	}, /*	Y_OUTPUT_SIZE	2464 */
+	{MT9E013_16BIT, {0x3040},	0x0041	}, /*	READ_MODE	0 0 0 0 0 0 0 1 1 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_STILL_6M_15fps[] = {
+	/*	STILL 6M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0134	}, /*	Y_ADDR_START	308 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x086D	}, /*	Y_ADDR_END	2157 */
+	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
+	{MT9E013_16BIT, {0x034E},	0x0738	}, /*	Y_OUTPUT_SIZE	1848 */
+	{MT9E013_16BIT, {0x3040},	0x0041	}, /*	READ_MODE	0 0 0 0 0 0 0 1 1 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_STILL_2M_15fps[] = {
+	/*	STILL 2M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x0C1C	}, /*	FRAME_LENGTH_LINES	3100 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CD1	}, /*	X_ADDR_END	3281 */
+	{MT9E013_16BIT, {0x034A},	0x09A1	}, /*	Y_ADDR_END	2465 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
+	{MT9E013_16BIT, {0x034E},	0x04D0	}, /*	Y_OUTPUT_SIZE	1232 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************preview30ok********************************/
+static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
+	/* PREVIEW */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
+	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
+	/* WIDE PREVIEW */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
+	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_PREVIEW1640_30fps[] = {
+	/*	PREVIEW 1640x1232 */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CD1	}, /*	X_ADDR_END	3281 */
+	{MT9E013_16BIT, {0x034A},	0x09A1	}, /*	Y_ADDR_END	2465 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
+	{MT9E013_16BIT, {0x034E},	0x04D0	}, /*	Y_OUTPUT_SIZE	1232 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************video************************/
+static struct mt9e013_reg const mt9e013_1080p_strong_dvs_30fps[] = {
+	/*	1080p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x05AB	}, /*	FRAME_LENGTH_LINES	1451 */
+	{MT9E013_16BIT, {0x0342},	0x113A	}, /*	LINE_LENGTH_PCK	4410 */
+	{MT9E013_16BIT, {0x0344},	0x01D8	}, /*	X_ADDR_START	472 */
+	{MT9E013_16BIT, {0x0346},	0x0242	}, /*	Y_ADDR_START	578 */
+	{MT9E013_16BIT, {0x0348},	0x0AF7	}, /*	X_ADDR_END	2807 */
+	{MT9E013_16BIT, {0x034A},	0x075D	}, /*	Y_ADDR_END	1885 */
+	{MT9E013_16BIT, {0x034C},	0x0920	}, /*	X_OUTPUT_SIZE	2336 */
+	{MT9E013_16BIT, {0x034E},	0x051C	}, /*	Y_OUTPUT_SIZE	1308 */
+	{MT9E013_16BIT, {0x3040},	0x0041	}, /*	READ_MODE	0 0 0 0 0 0 0 1 1  */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
+	{MT9E013_16BIT, {0X3012},	0x05AB	}, /*	COARSE_INTEGRATION_TIME	1451 */
+	{MT9E013_16BIT, {0X3014},	0x0442	}, /*	FINE_INTEGRATION_TIME	1090 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
+	/*	720p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0048	}, /*	X_ADDR_START	72 */
+	{MT9E013_16BIT, {0x0346},	0x0160	}, /*	Y_ADDR_START	352 */
+	{MT9E013_16BIT, {0x0348},	0x0C89	}, /*	X_ADDR_END	3209 */
+	{MT9E013_16BIT, {0x034A},	0x083F	}, /*	Y_ADDR_END	2111 */
+	{MT9E013_16BIT, {0x034C},	0x0620	}, /*	X_OUTPUT_SIZE	1568 */
+	{MT9E013_16BIT, {0x034E},	0x0370	}, /*	Y_OUTPUT_SIZE	880 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
+	/*	PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1050 */
+	{MT9E013_16BIT, {0x034E},	0x0400	}, /*	Y_OUTPUT_SIZE	778 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	25 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
+	/*	WVGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x00D0	}, /*	Y_ADDR_START	208 */
+	{MT9E013_16BIT, {0x0348},	0x0CCD	}, /*	X_ADDR_END	3277 */
+	{MT9E013_16BIT, {0x034A},	0x08CD	}, /*	Y_ADDR_END	2253 */
+	{MT9E013_16BIT, {0x034C},	0x03F0	}, /*	X_OUTPUT_SIZE	1008 */
+	{MT9E013_16BIT, {0x034E},	0x0276	}, /*	Y_OUTPUT_SIZE	630 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x001A	}, /*	SCALE_M	26 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
+	/*	480p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0388	}, /*	X_OUTPUT_SIZE	904 */
+	{MT9E013_16BIT, {0x034E},	0x025A	}, /*	Y_OUTPUT_SIZE	602 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	  304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x001D	}, /*	SCALE_M	29 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
+	/*	VGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
+	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
+	/*	QVGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0008	}, /*	X_ADDR_START	8 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CC7	}, /*	X_ADDR_END	3271 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0198	}, /*	X_OUTPUT_SIZE	408 */
+	{MT9E013_16BIT, {0x034E},	0x0134	}, /*	Y_OUTPUT_SIZE	308 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0040	}, /*	SCALE_M	64 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
+	/* QCIF strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0080	}, /*	X_ADDR_START	128 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CB3	}, /*	X_ADDR_END	3251 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x00D8	}, /*	X_OUTPUT_SIZE	216 */
+	{MT9E013_16BIT, {0x034E},	0x00B0	}, /*	Y_OUTPUT_SIZE	176 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0070	}, /*	SCALE_M	112 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+
+static const struct mt9e013_reg mt9e013_lens_shading[] = {
+	{MT9E013_16BIT | MT9E013_RMW, {0x3780}, 0x8000, 0}, /* POLY_SC_ENABLE */
+	{MT9E013_16BIT, {0x3600}, 0x0430},	/* P_GR_P0Q0 */
+	{MT9E013_16BIT, {0x3602}, 0x1BEE},	/* P_GR_P0Q1 */
+	{MT9E013_16BIT, {0x3604}, 0x39F0},	/* P_GR_P0Q2 */
+	{MT9E013_16BIT, {0x3606}, 0xC7AD},	/* P_GR_P0Q3 */
+	{MT9E013_16BIT, {0x3608}, 0xC390},	/* P_GR_P0Q4 */
+	{MT9E013_16BIT, {0x360A}, 0x03D0},	/* P_RD_P0Q0 */
+	{MT9E013_16BIT, {0x360C}, 0xA0CE},	/* P_RD_P0Q1 */
+	{MT9E013_16BIT, {0x360E}, 0x2850},	/* P_RD_P0Q2 */
+	{MT9E013_16BIT, {0x3610}, 0x6A0E},	/* P_RD_P0Q3 */
+	{MT9E013_16BIT, {0x3612}, 0xAF30},	/* P_RD_P0Q4 */
+	{MT9E013_16BIT, {0x3614}, 0x03D0},	/* P_BL_P0Q0 */
+	{MT9E013_16BIT, {0x3616}, 0x36AE},	/* P_BL_P0Q1 */
+	{MT9E013_16BIT, {0x3618}, 0x5E6F},	/* P_BL_P0Q2 */
+	{MT9E013_16BIT, {0x361A}, 0xA22E},	/* P_BL_P0Q3 */
+	{MT9E013_16BIT, {0x361C}, 0xF6EF},	/* P_BL_P0Q4 */
+	{MT9E013_16BIT, {0x361E}, 0x02F0},	/* P_GB_P0Q0 */
+	{MT9E013_16BIT, {0x3620}, 0xA00E},	/* P_GB_P0Q1 */
+	{MT9E013_16BIT, {0x3622}, 0x3CD0},	/* P_GB_P0Q2 */
+	{MT9E013_16BIT, {0x3624}, 0x530E},	/* P_GB_P0Q3 */
+	{MT9E013_16BIT, {0x3626}, 0xCEF0},	/* P_GB_P0Q4 */
+	{MT9E013_16BIT, {0x3640}, 0xAB2D},	/* P_GR_P1Q0 */
+	{MT9E013_16BIT, {0x3642}, 0xB72E},	/* P_GR_P1Q1 */
+	{MT9E013_16BIT, {0x3644}, 0x988D},	/* P_GR_P1Q2 */
+	{MT9E013_16BIT, {0x3646}, 0x6E2E},	/* P_GR_P1Q3 */
+	{MT9E013_16BIT, {0x3648}, 0x53EE},	/* P_GR_P1Q4 */
+	{MT9E013_16BIT, {0x364A}, 0xDA2C},	/* P_RD_P1Q0 */
+	{MT9E013_16BIT, {0x364C}, 0x3E8D},	/* P_RD_P1Q1 */
+	{MT9E013_16BIT, {0x364E}, 0xAFAD},	/* P_RD_P1Q2 */
+	{MT9E013_16BIT, {0x3650}, 0x874E},	/* P_RD_P1Q3 */
+	{MT9E013_16BIT, {0x3652}, 0x5B4E},	/* P_RD_P1Q4 */
+	{MT9E013_16BIT, {0x3654}, 0x740D},	/* P_BL_P1Q0 */
+	{MT9E013_16BIT, {0x3656}, 0x310E},	/* P_BL_P1Q1 */
+	{MT9E013_16BIT, {0x3658}, 0x280B},	/* P_BL_P1Q2 */
+	{MT9E013_16BIT, {0x365A}, 0xE06E},	/* P_BL_P1Q3 */
+	{MT9E013_16BIT, {0x365C}, 0xEA0D},	/* P_BL_P1Q4 */
+	{MT9E013_16BIT, {0x365E}, 0x182D},	/* P_GB_P1Q0 */
+	{MT9E013_16BIT, {0x3660}, 0xAD0E},	/* P_GB_P1Q1 */
+	{MT9E013_16BIT, {0x3662}, 0x032E},	/* P_GB_P1Q2 */
+	{MT9E013_16BIT, {0x3664}, 0x7EEE},	/* P_GB_P1Q3 */
+	{MT9E013_16BIT, {0x3666}, 0xF34E},	/* P_GB_P1Q4 */
+	{MT9E013_16BIT, {0x3680}, 0x0E31},	/* P_GR_P2Q0 */
+	{MT9E013_16BIT, {0x3682}, 0x104F},	/* P_GR_P2Q1 */
+	{MT9E013_16BIT, {0x3684}, 0x92D3},	/* P_GR_P2Q2 */
+	{MT9E013_16BIT, {0x3686}, 0xA030},	/* P_GR_P2Q3 */
+	{MT9E013_16BIT, {0x3688}, 0x3873},	/* P_GR_P2Q4 */
+	{MT9E013_16BIT, {0x368A}, 0x1971},	/* P_RD_P2Q0 */
+	{MT9E013_16BIT, {0x368C}, 0x750C},	/* P_RD_P2Q1 */
+	{MT9E013_16BIT, {0x368E}, 0xFFF2},	/* P_RD_P2Q2 */
+	{MT9E013_16BIT, {0x3690}, 0xEDAF},	/* P_RD_P2Q3 */
+	{MT9E013_16BIT, {0x3692}, 0x1D73},	/* P_RD_P2Q4 */
+	{MT9E013_16BIT, {0x3694}, 0x0031},	/* P_BL_P2Q0 */
+	{MT9E013_16BIT, {0x3696}, 0x1A2F},	/* P_BL_P2Q1 */
+	{MT9E013_16BIT, {0x3698}, 0xF792},	/* P_BL_P2Q2 */
+	{MT9E013_16BIT, {0x369A}, 0x8530},	/* P_BL_P2Q3 */
+	{MT9E013_16BIT, {0x369C}, 0x1F73},	/* P_BL_P2Q4 */
+	{MT9E013_16BIT, {0x369E}, 0x08B1},	/* P_GB_P2Q0 */
+	{MT9E013_16BIT, {0x36A0}, 0x11AE},	/* P_GB_P2Q1 */
+	{MT9E013_16BIT, {0x36A2}, 0x9093},	/* P_GB_P2Q2 */
+	{MT9E013_16BIT, {0x36A4}, 0x9030},	/* P_GB_P2Q3 */
+	{MT9E013_16BIT, {0x36A6}, 0x36D3},	/* P_GB_P2Q4 */
+	{MT9E013_16BIT, {0x36C0}, 0x5F2D},	/* P_GR_P3Q0 */
+	{MT9E013_16BIT, {0x36C2}, 0x314F},	/* P_GR_P3Q1 */
+	{MT9E013_16BIT, {0x36C4}, 0x684E},	/* P_GR_P3Q2 */
+	{MT9E013_16BIT, {0x36C6}, 0x88B0},	/* P_GR_P3Q3 */
+	{MT9E013_16BIT, {0x36C8}, 0xDAF0},	/* P_GR_P3Q4 */
+	{MT9E013_16BIT, {0x36CA}, 0x636E},	/* P_RD_P3Q0 */
+	{MT9E013_16BIT, {0x36CC}, 0xAD0C},	/* P_RD_P3Q1 */
+	{MT9E013_16BIT, {0x36CE}, 0xEEEE},	/* P_RD_P3Q2 */
+	{MT9E013_16BIT, {0x36D0}, 0x500E},	/* P_RD_P3Q3 */
+	{MT9E013_16BIT, {0x36D2}, 0xDDCE},	/* P_RD_P3Q4 */
+	{MT9E013_16BIT, {0x36D4}, 0xA3AC},	/* P_BL_P3Q0 */
+	{MT9E013_16BIT, {0x36D6}, 0xC06E},	/* P_BL_P3Q1 */
+	{MT9E013_16BIT, {0x36D8}, 0xC04F},	/* P_BL_P3Q2 */
+	{MT9E013_16BIT, {0x36DA}, 0x49AF},	/* P_BL_P3Q3 */
+	{MT9E013_16BIT, {0x36DC}, 0x4830},	/* P_BL_P3Q4 */
+	{MT9E013_16BIT, {0x36DE}, 0x0F6B},	/* P_GB_P3Q0 */
+	{MT9E013_16BIT, {0x36E0}, 0x1DEF},	/* P_GB_P3Q1 */
+	{MT9E013_16BIT, {0x36E2}, 0x8730},	/* P_GB_P3Q2 */
+	{MT9E013_16BIT, {0x36E4}, 0x9E50},	/* P_GB_P3Q3 */
+	{MT9E013_16BIT, {0x36E6}, 0x7110},	/* P_GB_P3Q4 */
+	{MT9E013_16BIT, {0x3700}, 0xF4F1},	/* P_GR_P4Q0 */
+	{MT9E013_16BIT, {0x3702}, 0xF090},	/* P_GR_P4Q1 */
+	{MT9E013_16BIT, {0x3704}, 0x6493},	/* P_GR_P4Q2 */
+	{MT9E013_16BIT, {0x3706}, 0x5FB1},	/* P_GR_P4Q3 */
+	{MT9E013_16BIT, {0x3708}, 0xADB3},	/* P_GR_P4Q4 */
+	{MT9E013_16BIT, {0x370A}, 0xFEF1},	/* P_RD_P4Q0 */
+	{MT9E013_16BIT, {0x370C}, 0x134B},	/* P_RD_P4Q1 */
+	{MT9E013_16BIT, {0x370E}, 0x4D33},	/* P_RD_P4Q2 */
+	{MT9E013_16BIT, {0x3710}, 0x9B8E},	/* P_RD_P4Q3 */
+	{MT9E013_16BIT, {0x3712}, 0x88B3},	/* P_RD_P4Q4 */
+	{MT9E013_16BIT, {0x3714}, 0xEBB1},	/* P_BL_P4Q0 */
+	{MT9E013_16BIT, {0x3716}, 0x8131},	/* P_BL_P4Q1 */
+	{MT9E013_16BIT, {0x3718}, 0x5AD3},	/* P_BL_P4Q2 */
+	{MT9E013_16BIT, {0x371A}, 0x54F1},	/* P_BL_P4Q3 */
+	{MT9E013_16BIT, {0x371C}, 0xB193},	/* P_BL_P4Q4 */
+	{MT9E013_16BIT, {0x371E}, 0xE6D1},	/* P_GB_P4Q0 */
+	{MT9E013_16BIT, {0x3720}, 0xE0EC},	/* P_GB_P4Q1 */
+	{MT9E013_16BIT, {0x3722}, 0x6033},	/* P_GB_P4Q2 */
+	{MT9E013_16BIT, {0x3724}, 0x9DCE},	/* P_GB_P4Q3 */
+	{MT9E013_16BIT, {0x3726}, 0xA453},	/* P_GB_P4Q4 */
+	{MT9E013_16BIT, {0x3782}, 0x0614},	/* POLY_ORIGIN_C */
+	{MT9E013_16BIT, {0x3784}, 0x0494},	/* POLY_ORIGIN_R */
+	{MT9E013_16BIT, {0x37C0}, 0xC40A},	/* P_GR_Q5 */
+	{MT9E013_16BIT, {0x37C2}, 0xCE6A},	/* P_RD_Q5 */
+	{MT9E013_16BIT, {0x37C4}, 0xDBAA},	/* P_BL_Q5 */
+	{MT9E013_16BIT, {0x37C6}, 0xCCEA},	/* P_GB_Q5 */
+
+	/*STATE= Lens Correction Falloff, 70 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x3780}, 0x8000, 1}, /* POLY_SC_ENABLE */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_resolution mt9e013_res_preview[] = {
+	{
+		 .desc =	"PREVIEW_30fps"	,
+		 .width =	820	,
+		 .height =	616	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_PREVIEW_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		.skip_frames = 0, /*change skip num from 1 to 0 after 3A init
+				    param invalid issue fixed*/
+	},
+	{
+		 .desc =	"WIDE_PREVIEW_30fps"	,
+		 .width =	1640	,
+		 .height =	956	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_WIDE_PREVIEW_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"PREVIEW1640_30fps"	,
+		 .width =	1640	,
+		 .height =	1232	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_PREVIEW1640_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+};
+
+#define N_RES_PREVIEW (ARRAY_SIZE(mt9e013_res_preview))
+
+static struct mt9e013_resolution mt9e013_res_still[] = {
+	{
+		 .desc =	"STILL_2M_15fps"	,
+		 .width =	1640	,
+		 .height =	1232	,
+		 .fps =		15	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x0C1C, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_2M_15fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 1,
+	},
+	{
+		 .desc =	"STILL_6M_15fps"	,
+		 .width =	3280	,
+		 .height =	1848	,
+		 .fps =		15	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1258, /* consistent with regs arrays */
+		 .lines_per_frame = 0x0AA4, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_6M_15fps	,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 1,
+	},
+	{
+		 .desc =	"STILL_8M_15fps"	,
+		 .width =	3280	,
+		 .height =	2464	,
+		 .fps =		15	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1258, /* consistent with regs arrays */
+		 .lines_per_frame = 0x0AA4, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_8M_15fps	,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 1,
+	},
+};
+
+#define N_RES_STILL (ARRAY_SIZE(mt9e013_res_still))
+
+static struct mt9e013_resolution mt9e013_res_video[] = {
+	{
+		 .desc =	"QCIF_strong_dvs_30fps"	,
+		 .width =	216	,
+		 .height =	176	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_QCIF_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"QVGA_strong_dvs_30fps"	,
+		 .width =	408	,
+		 .height =	308	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_QVGA_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"VGA_strong_dvs_30fps"	,
+		 .width =	820	,
+		 .height =	616	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_VGA_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		.desc = "480p_strong_dvs_30fps"	,
+		.width =	904	,
+		.height =	602	,
+		.fps =	30	,
+		.used =	0	,
+		.pixels_per_line = 0x1020, /* consistent with regs arrays */
+		.lines_per_frame = 0x060E, /* consistent with regs arrays */
+		.regs = mt9e013_480p_strong_dvs_30fps	,
+		.bin_factor_x =	2,
+		.bin_factor_y =	2,
+		.skip_frames = 0,
+	},
+	{
+		 .desc =	"WVGA_strong_dvs_30fps"	,
+		 .width =	1008	,
+		 .height =	630	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_WVGA_strong_dvs_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"3RD_PARTY_PREVIEW1024_30fps"	,
+		 .width =	1050	,
+		 .height =	778	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_3RD_PARTY_PREVIEW1024_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"720p_strong_dvs_30fps"	,
+		 .width =	1568	,
+		 .height =	880	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_720p_strong_dvs_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"1080p_strong_dvs_30fps",
+		 .width =	2336,
+		 .height =	1308,
+		 .fps =		30,
+		 .used =	0,
+		 .pixels_per_line = 0x113A, /* consistent with regs arrays */
+		 .lines_per_frame = 0x05AB, /* consistent with regs arrays */
+		 .regs =	mt9e013_1080p_strong_dvs_30fps,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 0,
+	},
+};
+
+#define N_RES_VIDEO (ARRAY_SIZE(mt9e013_res_video))
+
+static struct mt9e013_resolution *mt9e013_res = mt9e013_res_preview;
+static int N_RES = N_RES_PREVIEW;
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h
new file mode 100644
index 0000000..1ff2616
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_enzo.h
@@ -0,0 +1,814 @@
+/*
+ * Support for Aptina MT9E013 camera sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MT9E013_ENZO_H__
+#define __MT9E013_ENZO_H__
+
+#include "mt9e013.h"
+
+#define MAX_FMTS 1
+
+#define MT9E013_RES_WIDTH_MAX	3280
+#define MT9E013_RES_HEIGHT_MAX	2464
+
+/* Recommended Settings: release 2 - updated  on 06/22/2012 */
+static const struct mt9e013_reg mt9e013_recommended_settings[] = {
+	{MT9E013_16BIT, {0x3044}, 0x0590},
+	{MT9E013_16BIT, {0x306E}, 0xFC80},
+	{MT9E013_16BIT, {0x30B2}, 0xC000},
+	{MT9E013_16BIT, {0x30D6}, 0x0800},
+	{MT9E013_16BIT, {0x316C}, 0xB214},
+	{MT9E013_16BIT, {0x316E}, 0x869A},
+	{MT9E013_16BIT, {0x3170}, 0x210E},
+	{MT9E013_16BIT, {0x3174}, 0x8000},
+	{MT9E013_16BIT, {0x317A}, 0x010E},
+	{MT9E013_16BIT, {0x31E0}, 0x1FB9},
+	{MT9E013_16BIT, {0x31E6}, 0x07FC},
+	{MT9E013_16BIT, {0x37C0}, 0x0000},
+	{MT9E013_16BIT, {0x37C2}, 0x0000},
+	{MT9E013_16BIT, {0x37C4}, 0x0000},
+	{MT9E013_16BIT, {0x37C6}, 0x0000},
+	{MT9E013_16BIT, {0x3E00}, 0x0011},
+	{MT9E013_16BIT, {0x3E02}, 0x8801},
+	{MT9E013_16BIT, {0x3E04}, 0x2801},
+	{MT9E013_16BIT, {0x3E06}, 0x8449},
+	{MT9E013_16BIT, {0x3E08}, 0x6B41},
+	{MT9E013_16BIT, {0x3E0A}, 0x400C},
+	{MT9E013_16BIT, {0x3E0C}, 0x1001},
+	{MT9E013_16BIT, {0x3E0E}, 0x2603},
+	{MT9E013_16BIT, {0x3E10}, 0x4B41},
+	{MT9E013_16BIT, {0x3E12}, 0x4B24},
+	{MT9E013_16BIT, {0x3E14}, 0xA3CF},
+	{MT9E013_16BIT, {0x3E16}, 0x8802},
+	{MT9E013_16BIT, {0x3E18}, 0x8401},
+	{MT9E013_16BIT, {0x3E1A}, 0x8601},
+	{MT9E013_16BIT, {0x3E1C}, 0x8401},
+	{MT9E013_16BIT, {0x3E1E}, 0x840A},
+	{MT9E013_16BIT, {0x3E20}, 0xFF00},
+	{MT9E013_16BIT, {0x3E22}, 0x8401},
+	{MT9E013_16BIT, {0x3E24}, 0x00FF},
+	{MT9E013_16BIT, {0x3E26}, 0x0088},
+	{MT9E013_16BIT, {0x3E28}, 0x2E8A},
+	{MT9E013_16BIT, {0x3E30}, 0x0000},
+	{MT9E013_16BIT, {0x3E32}, 0x8801},
+	{MT9E013_16BIT, {0x3E34}, 0x4029},
+	{MT9E013_16BIT, {0x3E36}, 0x00FF},
+	{MT9E013_16BIT, {0x3E38}, 0x846C},
+	{MT9E013_16BIT, {0x3E3A}, 0x00FF},
+	{MT9E013_16BIT, {0x3E3C}, 0x2801},
+	{MT9E013_16BIT, {0x3E3E}, 0x3E2A},
+	{MT9E013_16BIT, {0x3E40}, 0x1C01},
+	{MT9E013_16BIT, {0x3E42}, 0x8486},
+	{MT9E013_16BIT, {0x3E44}, 0x8401},
+	{MT9E013_16BIT, {0x3E46}, 0x0C01},
+	{MT9E013_16BIT, {0x3E48}, 0x8401},
+	{MT9E013_16BIT, {0x3E4A}, 0x00FF},
+	{MT9E013_16BIT, {0x3E4C}, 0x8402},
+	{MT9E013_16BIT, {0x3E4E}, 0x8984},
+	{MT9E013_16BIT, {0x3E50}, 0x6928},
+	{MT9E013_16BIT, {0x3E52}, 0x8340},
+	{MT9E013_16BIT, {0x3E54}, 0x00FF},
+	{MT9E013_16BIT, {0x3E56}, 0x4A42},
+	{MT9E013_16BIT, {0x3E58}, 0x2703},
+	{MT9E013_16BIT, {0x3E5A}, 0x6752},
+	{MT9E013_16BIT, {0x3E5C}, 0x3F2A},
+	{MT9E013_16BIT, {0x3E5E}, 0x846D},
+	{MT9E013_16BIT, {0x3E60}, 0x4C01},
+	{MT9E013_16BIT, {0x3E62}, 0x8401},
+	{MT9E013_16BIT, {0x3E66}, 0x3901},
+	{MT9E013_16BIT, {0x3E90}, 0x2C01},
+	{MT9E013_16BIT, {0x3E92}, 0x2A04},
+	{MT9E013_16BIT, {0x3E94}, 0x2509},
+	{MT9E013_16BIT, {0x3E96}, 0xF000},
+	{MT9E013_16BIT, {0x3E98}, 0x2B02},
+	{MT9E013_16BIT, {0x3E9A}, 0x2905},
+	{MT9E013_16BIT, {0x3E9C}, 0x00FF},
+	{MT9E013_16BIT, {0x3ECC}, 0x00E2},
+	{MT9E013_16BIT, {0x3ED0}, 0x2424},
+	{MT9E013_16BIT, {0x3ED4}, 0xF4B2},
+	{MT9E013_16BIT, {0x3ED6}, 0x909B},
+	{MT9E013_16BIT, {0x3EDE}, 0x2430},
+	{MT9E013_16BIT, {0x3EE0}, 0x3030},
+	{MT9E013_16BIT, {0x3EE4}, 0xC100},
+	{MT9E013_16BIT, {0x3EE6}, 0x0540},
+	{MT9E013_16BIT+MT9E013_RMW, {0x3EDA}, 0x4000, 0x0001},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_pll_timing[] = {
+	/*			pixelrate into the isp =	153.600.000 Hz*/
+	{MT9E013_16BIT, {0x0300},	0x0004	}, /*	vt_pix_clk_div=	4	internal pixel clock freq =	192.000.000 Hz*/
+	{MT9E013_16BIT, {0x0302},	0x0001	}, /*	vt_sys_clk_div=	1*/
+	{MT9E013_16BIT, {0x0304},	0x0001	}, /*	pre_pll_clk_div=	1	PLL input clock freq =	19.200.000 Hz*/
+	{MT9E013_16BIT, {0x0306},	0x0028	}, /*	pll_multiplier=	40	mipi bus speed =	768.000.000 Hz*/
+	{MT9E013_16BIT, {0x0308},	0x000A	}, /*	op_pix_clk_div=	10	output pixel clock freq =	76.800.000 Hz*/
+	{MT9E013_16BIT, {0x030A},	0x0001	}, /*	op_sys_clk_div=	1*/
+	{MT9E013_16BIT, {0x3016},	0x111	}, /*	row_speed=	273*/
+	{MT9E013_TOK_DELAY, {0}, 1},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*2-lane MIPI Interface Configuration*/
+static const struct mt9e013_reg mt9e013_mipi_config[] = {
+	{MT9E013_16BIT+MT9E013_RMW, {0x3064}, 0x0100, 0x0000},
+	{MT9E013_16BIT, {0x31AE}, 0x0202},
+	{MT9E013_16BIT, {0x31B8}, 0x03EF},
+	/*{MT9E013_16BIT, {0x31B8}, 0x2FEF}, */
+	{MT9E013_TOK_DELAY, {0}, 5},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/* MIPI Timing Settings */
+static const struct mt9e013_reg mt9e013_mipi_timing[] = {
+	{MT9E013_16BIT, {0x31B0}, 0x0083},
+	{MT9E013_16BIT, {0x31B2}, 0x004D},
+	{MT9E013_16BIT, {0x31B4}, 0x0E67},
+	{MT9E013_16BIT, {0x31B6}, 0x0D24},
+	{MT9E013_16BIT, {0x31B8}, 0x020E},
+	{MT9E013_16BIT, {0x31BA}, 0x0710},
+	{MT9E013_16BIT, {0x31BC}, 0x2A0D},
+	{MT9E013_16BIT, {0x31BE}, 0xC007},
+	{MT9E013_TOK_DELAY, {0}, 5},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+
+/*****************************still15ok*****************************/
+static struct mt9e013_reg const mt9e013_STILL_8M_15fps[] = {
+	/*	STILL 8M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
+	{MT9E013_16BIT, {0x034E},	0x09A0	}, /*	Y_OUTPUT_SIZE	2464 */
+	{MT9E013_16BIT, {0x3040},	0x4041	}, /*	READ_MODE	0 1 1 0 0 0 0 1 1 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_STILL_6M_15fps[] = {
+	/*	STILL 6M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x0AA4	}, /*	FRAME_LENGTH_LINES	2724 */
+	{MT9E013_16BIT, {0x0342},	0x1258	}, /*	LINE_LENGTH_PCK	4696 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0134	}, /*	Y_ADDR_START	308 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x086D	}, /*	Y_ADDR_END	2157 */
+	{MT9E013_16BIT, {0x034C},	0x0CD0	}, /*	X_OUTPUT_SIZE	3280 */
+	{MT9E013_16BIT, {0x034E},	0x0738	}, /*	Y_OUTPUT_SIZE	1848 */
+	{MT9E013_16BIT, {0x3040},	0x4041	}, /*	READ_MODE	0 1 1 0 0 0 0 1 1 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
+	{MT9E013_16BIT, {0X3012},	0x04CA	}, /*	COARSE_INTEGRATION_TIME	1226 */
+	{MT9E013_16BIT, {0X3014},	0x03F6	}, /*	FINE_INTEGRATION_TIME	1014 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_STILL_2M_15fps[] = {
+	/*	STILL 2M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x0C1C	}, /*	FRAME_LENGTH_LINES	3100 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CD1	}, /*	X_ADDR_END	3281 */
+	{MT9E013_16BIT, {0x034A},	0x09A1	}, /*	Y_ADDR_END	2465 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
+	{MT9E013_16BIT, {0x034E},	0x04D0	}, /*	Y_OUTPUT_SIZE	1232 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************preview30ok********************************/
+static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
+	/* PREVIEW */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
+	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
+	/* WIDE PREVIEW */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
+	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************video************************/
+static struct mt9e013_reg const mt9e013_1080p_strong_dvs_30fps[] = {
+	/*	1080p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x05AB	}, /*	FRAME_LENGTH_LINES	1451 */
+	{MT9E013_16BIT, {0x0342},	0x113A	}, /*	LINE_LENGTH_PCK	4410 */
+	{MT9E013_16BIT, {0x0344},	0x01D8	}, /*	X_ADDR_START	472 */
+	{MT9E013_16BIT, {0x0346},	0x0242	}, /*	Y_ADDR_START	578 */
+	{MT9E013_16BIT, {0x0348},	0x0AF7	}, /*	X_ADDR_END	2807 */
+	{MT9E013_16BIT, {0x034A},	0x075D	}, /*	Y_ADDR_END	1885 */
+	{MT9E013_16BIT, {0x034C},	0x0920	}, /*	X_OUTPUT_SIZE	2336 */
+	{MT9E013_16BIT, {0x034E},	0x051C	}, /*	Y_OUTPUT_SIZE	1308 */
+	{MT9E013_16BIT, {0x3040},	0x4041	}, /*	READ_MODE	0 1 1 0 0 0 0 1 1  */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0078	}, /*	FINE_CORRECTION	120 */
+	{MT9E013_16BIT, {0X3012},	0x05AB	}, /*	COARSE_INTEGRATION_TIME	1451 */
+	{MT9E013_16BIT, {0X3014},	0x0442	}, /*	FINE_INTEGRATION_TIME	1090 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
+	/*	720p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0048	}, /*	X_ADDR_START	72 */
+	{MT9E013_16BIT, {0x0346},	0x0160	}, /*	Y_ADDR_START	352 */
+	{MT9E013_16BIT, {0x0348},	0x0C89	}, /*	X_ADDR_END	3209 */
+	{MT9E013_16BIT, {0x034A},	0x083F	}, /*	Y_ADDR_END	2111 */
+	{MT9E013_16BIT, {0x034C},	0x0620	}, /*	X_OUTPUT_SIZE	1568 */
+	{MT9E013_16BIT, {0x034E},	0x0370	}, /*	Y_OUTPUT_SIZE	880 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
+	/*	PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1050 */
+	{MT9E013_16BIT, {0x034E},	0x0400	}, /*	Y_OUTPUT_SIZE	778 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	25 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
+	/*	WVGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x00D0	}, /*	Y_ADDR_START	208 */
+	{MT9E013_16BIT, {0x0348},	0x0CCD	}, /*	X_ADDR_END	3277 */
+	{MT9E013_16BIT, {0x034A},	0x08CD	}, /*	Y_ADDR_END	2253 */
+	{MT9E013_16BIT, {0x034C},	0x03F0	}, /*	X_OUTPUT_SIZE	1008 */
+	{MT9E013_16BIT, {0x034E},	0x0276	}, /*	Y_OUTPUT_SIZE	630 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x001A	}, /*	SCALE_M	26 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
+	/*	480p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0388	}, /*	X_OUTPUT_SIZE	904 */
+	{MT9E013_16BIT, {0x034E},	0x025A	}, /*	Y_OUTPUT_SIZE	602 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	  304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x001D	}, /*	SCALE_M	29 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
+	/*	VGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
+	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
+	/*	QVGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0008	}, /*	X_ADDR_START	8 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CC7	}, /*	X_ADDR_END	3271 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0198	}, /*	X_OUTPUT_SIZE	408 */
+	{MT9E013_16BIT, {0x034E},	0x0134	}, /*	Y_OUTPUT_SIZE	308 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0040	}, /*	SCALE_M	64 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
+	/* QCIF strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0080	}, /*	X_ADDR_START	128 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CB3	}, /*	X_ADDR_END	3251 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x00D8	}, /*	X_OUTPUT_SIZE	216 */
+	{MT9E013_16BIT, {0x034E},	0x00B0	}, /*	Y_OUTPUT_SIZE	176 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0070	}, /*	SCALE_M	112 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const enzofullhd_strong_dvs_30fps[] = {
+	/* enzofullhd_strong_dvs_30fps */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
+	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
+	{MT9E013_16BIT, {0x3040},	0x44C3	}, /*	READ_MODE	0 1 1 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+
+static const struct mt9e013_reg mt9e013_lens_shading[] = {
+	{MT9E013_16BIT | MT9E013_RMW, {0x3780}, 0x8000, 0}, /* POLY_SC_ENABLE */
+	{MT9E013_16BIT, {0x3600}, 0x0430},	/* P_GR_P0Q0 */
+	{MT9E013_16BIT, {0x3602}, 0x1BEE},	/* P_GR_P0Q1 */
+	{MT9E013_16BIT, {0x3604}, 0x39F0},	/* P_GR_P0Q2 */
+	{MT9E013_16BIT, {0x3606}, 0xC7AD},	/* P_GR_P0Q3 */
+	{MT9E013_16BIT, {0x3608}, 0xC390},	/* P_GR_P0Q4 */
+	{MT9E013_16BIT, {0x360A}, 0x03D0},	/* P_RD_P0Q0 */
+	{MT9E013_16BIT, {0x360C}, 0xA0CE},	/* P_RD_P0Q1 */
+	{MT9E013_16BIT, {0x360E}, 0x2850},	/* P_RD_P0Q2 */
+	{MT9E013_16BIT, {0x3610}, 0x6A0E},	/* P_RD_P0Q3 */
+	{MT9E013_16BIT, {0x3612}, 0xAF30},	/* P_RD_P0Q4 */
+	{MT9E013_16BIT, {0x3614}, 0x03D0},	/* P_BL_P0Q0 */
+	{MT9E013_16BIT, {0x3616}, 0x36AE},	/* P_BL_P0Q1 */
+	{MT9E013_16BIT, {0x3618}, 0x5E6F},	/* P_BL_P0Q2 */
+	{MT9E013_16BIT, {0x361A}, 0xA22E},	/* P_BL_P0Q3 */
+	{MT9E013_16BIT, {0x361C}, 0xF6EF},	/* P_BL_P0Q4 */
+	{MT9E013_16BIT, {0x361E}, 0x02F0},	/* P_GB_P0Q0 */
+	{MT9E013_16BIT, {0x3620}, 0xA00E},	/* P_GB_P0Q1 */
+	{MT9E013_16BIT, {0x3622}, 0x3CD0},	/* P_GB_P0Q2 */
+	{MT9E013_16BIT, {0x3624}, 0x530E},	/* P_GB_P0Q3 */
+	{MT9E013_16BIT, {0x3626}, 0xCEF0},	/* P_GB_P0Q4 */
+	{MT9E013_16BIT, {0x3640}, 0xAB2D},	/* P_GR_P1Q0 */
+	{MT9E013_16BIT, {0x3642}, 0xB72E},	/* P_GR_P1Q1 */
+	{MT9E013_16BIT, {0x3644}, 0x988D},	/* P_GR_P1Q2 */
+	{MT9E013_16BIT, {0x3646}, 0x6E2E},	/* P_GR_P1Q3 */
+	{MT9E013_16BIT, {0x3648}, 0x53EE},	/* P_GR_P1Q4 */
+	{MT9E013_16BIT, {0x364A}, 0xDA2C},	/* P_RD_P1Q0 */
+	{MT9E013_16BIT, {0x364C}, 0x3E8D},	/* P_RD_P1Q1 */
+	{MT9E013_16BIT, {0x364E}, 0xAFAD},	/* P_RD_P1Q2 */
+	{MT9E013_16BIT, {0x3650}, 0x874E},	/* P_RD_P1Q3 */
+	{MT9E013_16BIT, {0x3652}, 0x5B4E},	/* P_RD_P1Q4 */
+	{MT9E013_16BIT, {0x3654}, 0x740D},	/* P_BL_P1Q0 */
+	{MT9E013_16BIT, {0x3656}, 0x310E},	/* P_BL_P1Q1 */
+	{MT9E013_16BIT, {0x3658}, 0x280B},	/* P_BL_P1Q2 */
+	{MT9E013_16BIT, {0x365A}, 0xE06E},	/* P_BL_P1Q3 */
+	{MT9E013_16BIT, {0x365C}, 0xEA0D},	/* P_BL_P1Q4 */
+	{MT9E013_16BIT, {0x365E}, 0x182D},	/* P_GB_P1Q0 */
+	{MT9E013_16BIT, {0x3660}, 0xAD0E},	/* P_GB_P1Q1 */
+	{MT9E013_16BIT, {0x3662}, 0x032E},	/* P_GB_P1Q2 */
+	{MT9E013_16BIT, {0x3664}, 0x7EEE},	/* P_GB_P1Q3 */
+	{MT9E013_16BIT, {0x3666}, 0xF34E},	/* P_GB_P1Q4 */
+	{MT9E013_16BIT, {0x3680}, 0x0E31},	/* P_GR_P2Q0 */
+	{MT9E013_16BIT, {0x3682}, 0x104F},	/* P_GR_P2Q1 */
+	{MT9E013_16BIT, {0x3684}, 0x92D3},	/* P_GR_P2Q2 */
+	{MT9E013_16BIT, {0x3686}, 0xA030},	/* P_GR_P2Q3 */
+	{MT9E013_16BIT, {0x3688}, 0x3873},	/* P_GR_P2Q4 */
+	{MT9E013_16BIT, {0x368A}, 0x1971},	/* P_RD_P2Q0 */
+	{MT9E013_16BIT, {0x368C}, 0x750C},	/* P_RD_P2Q1 */
+	{MT9E013_16BIT, {0x368E}, 0xFFF2},	/* P_RD_P2Q2 */
+	{MT9E013_16BIT, {0x3690}, 0xEDAF},	/* P_RD_P2Q3 */
+	{MT9E013_16BIT, {0x3692}, 0x1D73},	/* P_RD_P2Q4 */
+	{MT9E013_16BIT, {0x3694}, 0x0031},	/* P_BL_P2Q0 */
+	{MT9E013_16BIT, {0x3696}, 0x1A2F},	/* P_BL_P2Q1 */
+	{MT9E013_16BIT, {0x3698}, 0xF792},	/* P_BL_P2Q2 */
+	{MT9E013_16BIT, {0x369A}, 0x8530},	/* P_BL_P2Q3 */
+	{MT9E013_16BIT, {0x369C}, 0x1F73},	/* P_BL_P2Q4 */
+	{MT9E013_16BIT, {0x369E}, 0x08B1},	/* P_GB_P2Q0 */
+	{MT9E013_16BIT, {0x36A0}, 0x11AE},	/* P_GB_P2Q1 */
+	{MT9E013_16BIT, {0x36A2}, 0x9093},	/* P_GB_P2Q2 */
+	{MT9E013_16BIT, {0x36A4}, 0x9030},	/* P_GB_P2Q3 */
+	{MT9E013_16BIT, {0x36A6}, 0x36D3},	/* P_GB_P2Q4 */
+	{MT9E013_16BIT, {0x36C0}, 0x5F2D},	/* P_GR_P3Q0 */
+	{MT9E013_16BIT, {0x36C2}, 0x314F},	/* P_GR_P3Q1 */
+	{MT9E013_16BIT, {0x36C4}, 0x684E},	/* P_GR_P3Q2 */
+	{MT9E013_16BIT, {0x36C6}, 0x88B0},	/* P_GR_P3Q3 */
+	{MT9E013_16BIT, {0x36C8}, 0xDAF0},	/* P_GR_P3Q4 */
+	{MT9E013_16BIT, {0x36CA}, 0x636E},	/* P_RD_P3Q0 */
+	{MT9E013_16BIT, {0x36CC}, 0xAD0C},	/* P_RD_P3Q1 */
+	{MT9E013_16BIT, {0x36CE}, 0xEEEE},	/* P_RD_P3Q2 */
+	{MT9E013_16BIT, {0x36D0}, 0x500E},	/* P_RD_P3Q3 */
+	{MT9E013_16BIT, {0x36D2}, 0xDDCE},	/* P_RD_P3Q4 */
+	{MT9E013_16BIT, {0x36D4}, 0xA3AC},	/* P_BL_P3Q0 */
+	{MT9E013_16BIT, {0x36D6}, 0xC06E},	/* P_BL_P3Q1 */
+	{MT9E013_16BIT, {0x36D8}, 0xC04F},	/* P_BL_P3Q2 */
+	{MT9E013_16BIT, {0x36DA}, 0x49AF},	/* P_BL_P3Q3 */
+	{MT9E013_16BIT, {0x36DC}, 0x4830},	/* P_BL_P3Q4 */
+	{MT9E013_16BIT, {0x36DE}, 0x0F6B},	/* P_GB_P3Q0 */
+	{MT9E013_16BIT, {0x36E0}, 0x1DEF},	/* P_GB_P3Q1 */
+	{MT9E013_16BIT, {0x36E2}, 0x8730},	/* P_GB_P3Q2 */
+	{MT9E013_16BIT, {0x36E4}, 0x9E50},	/* P_GB_P3Q3 */
+	{MT9E013_16BIT, {0x36E6}, 0x7110},	/* P_GB_P3Q4 */
+	{MT9E013_16BIT, {0x3700}, 0xF4F1},	/* P_GR_P4Q0 */
+	{MT9E013_16BIT, {0x3702}, 0xF090},	/* P_GR_P4Q1 */
+	{MT9E013_16BIT, {0x3704}, 0x6493},	/* P_GR_P4Q2 */
+	{MT9E013_16BIT, {0x3706}, 0x5FB1},	/* P_GR_P4Q3 */
+	{MT9E013_16BIT, {0x3708}, 0xADB3},	/* P_GR_P4Q4 */
+	{MT9E013_16BIT, {0x370A}, 0xFEF1},	/* P_RD_P4Q0 */
+	{MT9E013_16BIT, {0x370C}, 0x134B},	/* P_RD_P4Q1 */
+	{MT9E013_16BIT, {0x370E}, 0x4D33},	/* P_RD_P4Q2 */
+	{MT9E013_16BIT, {0x3710}, 0x9B8E},	/* P_RD_P4Q3 */
+	{MT9E013_16BIT, {0x3712}, 0x88B3},	/* P_RD_P4Q4 */
+	{MT9E013_16BIT, {0x3714}, 0xEBB1},	/* P_BL_P4Q0 */
+	{MT9E013_16BIT, {0x3716}, 0x8131},	/* P_BL_P4Q1 */
+	{MT9E013_16BIT, {0x3718}, 0x5AD3},	/* P_BL_P4Q2 */
+	{MT9E013_16BIT, {0x371A}, 0x54F1},	/* P_BL_P4Q3 */
+	{MT9E013_16BIT, {0x371C}, 0xB193},	/* P_BL_P4Q4 */
+	{MT9E013_16BIT, {0x371E}, 0xE6D1},	/* P_GB_P4Q0 */
+	{MT9E013_16BIT, {0x3720}, 0xE0EC},	/* P_GB_P4Q1 */
+	{MT9E013_16BIT, {0x3722}, 0x6033},	/* P_GB_P4Q2 */
+	{MT9E013_16BIT, {0x3724}, 0x9DCE},	/* P_GB_P4Q3 */
+	{MT9E013_16BIT, {0x3726}, 0xA453},	/* P_GB_P4Q4 */
+	{MT9E013_16BIT, {0x3782}, 0x0614},	/* POLY_ORIGIN_C */
+	{MT9E013_16BIT, {0x3784}, 0x0494},	/* POLY_ORIGIN_R */
+	{MT9E013_16BIT, {0x37C0}, 0xC40A},	/* P_GR_Q5 */
+	{MT9E013_16BIT, {0x37C2}, 0xCE6A},	/* P_RD_Q5 */
+	{MT9E013_16BIT, {0x37C4}, 0xDBAA},	/* P_BL_Q5 */
+	{MT9E013_16BIT, {0x37C6}, 0xCCEA},	/* P_GB_Q5 */
+
+	/*STATE= Lens Correction Falloff, 70 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x3780}, 0x8000, 1}, /* POLY_SC_ENABLE */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_resolution mt9e013_res_preview[] = {
+	{
+		 .desc =	"PREVIEW_30fps"	,
+		 .width =	820	,
+		 .height =	616	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_PREVIEW_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"WIDE_PREVIEW_30fps"	,
+		 .width =	1640	,
+		 .height =	956	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_WIDE_PREVIEW_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0
+	},
+};
+
+#define N_RES_PREVIEW (ARRAY_SIZE(mt9e013_res_preview))
+
+static struct mt9e013_resolution mt9e013_res_still[] = {
+	{
+		 .desc =	"STILL_2M_15fps"	,
+		 .width =	1640	,
+		 .height =	1232	,
+		 .fps =		15	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x0C1C, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_2M_15fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 1,
+	},
+	{
+		 .desc =	"STILL_6M_15fps"	,
+		 .width =	3280	,
+		 .height =	1848	,
+		 .fps =		15	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1258, /* consistent with regs arrays */
+		 .lines_per_frame = 0x0AA4, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_6M_15fps	,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 1,
+	},
+	{
+		 .desc =	"STILL_8M_15fps"	,
+		 .width =	3280	,
+		 .height =	2464	,
+		 .fps =		15	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1258, /* consistent with regs arrays */
+		 .lines_per_frame = 0x0AA4, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_8M_15fps	,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 1,
+	},
+};
+
+#define N_RES_STILL (ARRAY_SIZE(mt9e013_res_still))
+
+static struct mt9e013_resolution mt9e013_res_video[] = {
+	{
+		 .desc =	"QCIF_strong_dvs_30fps"	,
+		 .width =	216	,
+		 .height =	176	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_QCIF_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"QVGA_strong_dvs_30fps"	,
+		 .width =	408	,
+		 .height =	308	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_QVGA_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"VGA_strong_dvs_30fps"	,
+		 .width =	820	,
+		 .height =	616	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_VGA_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		.desc = "480p_strong_dvs_30fps"	,
+		.width =	904	,
+		.height =	602	,
+		.fps =	30	,
+		.used =	0	,
+		.pixels_per_line = 0x1020, /* consistent with regs arrays */
+		.lines_per_frame = 0x060E, /* consistent with regs arrays */
+		.regs = mt9e013_480p_strong_dvs_30fps	,
+		.bin_factor_x =	2,
+		.bin_factor_y =	2,
+		.skip_frames = 0,
+	},
+	{
+		 .desc =	"WVGA_strong_dvs_30fps"	,
+		 .width =	1008	,
+		 .height =	630	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_WVGA_strong_dvs_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"3RD_PARTY_PREVIEW1024_30fps"	,
+		 .width =	1050	,
+		 .height =	778	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_3RD_PARTY_PREVIEW1024_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"720p_strong_dvs_30fps"	,
+		 .width =	1568	,
+		 .height =	880	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_720p_strong_dvs_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"1080p_strong_dvs_30fps",
+		 .width =	2336,
+		 .height =	1308,
+		 .fps =		30,
+		 .used =	0,
+		 .pixels_per_line = 0x113A, /* consistent with regs arrays */
+		 .lines_per_frame = 0x05AB, /* consistent with regs arrays */
+		 .regs =	mt9e013_1080p_strong_dvs_30fps,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"enzofullhd_strong_dvs_30fps",
+		 .width =	1640	,
+		 .height =	956	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	enzofullhd_strong_dvs_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+};
+
+#define N_RES_VIDEO (ARRAY_SIZE(mt9e013_res_video))
+
+static struct mt9e013_resolution *mt9e013_res = mt9e013_res_preview;
+static int N_RES = N_RES_PREVIEW;
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h
new file mode 100644
index 0000000..f93986e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9e013/mt9e013_lexington.h
@@ -0,0 +1,783 @@
+/*
+ * Support for Aptina MT9E013 camera sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MT9E013_LEXINGTON_H__
+#define __MT9E013_LEXINGTON_H__
+
+#include "mt9e013.h"
+
+#define MAX_FMTS 1
+
+#define MT9E013_RES_WIDTH_MAX	3280
+#define MT9E013_RES_HEIGHT_MAX	2464
+
+/* Recommended Settings 29 Mar 2011*/
+static const struct mt9e013_reg mt9e013_recommended_settings[] = {
+	{MT9E013_16BIT, {0x3044}, 0x0590},
+	{MT9E013_16BIT, {0x306E}, 0xFC80},
+	{MT9E013_16BIT, {0x30B2}, 0xC000},
+	{MT9E013_16BIT, {0x30D6}, 0x0800},
+	{MT9E013_16BIT, {0x316C}, 0xB42F},
+	{MT9E013_16BIT, {0x316E}, 0x869A},
+	{MT9E013_16BIT, {0x3170}, 0x210E},
+	{MT9E013_16BIT, {0x317A}, 0x010E},
+	{MT9E013_16BIT, {0x31E0}, 0x1FB9},
+	{MT9E013_16BIT, {0x31E6}, 0x07FC},
+	{MT9E013_16BIT, {0x37C0}, 0x0000},
+	{MT9E013_16BIT, {0x37C2}, 0x0000},
+	{MT9E013_16BIT, {0x37C4}, 0x0000},
+	{MT9E013_16BIT, {0x37C6}, 0x0000},
+	{MT9E013_16BIT, {0x3E00}, 0x0011},
+	{MT9E013_16BIT, {0x3E02}, 0x8801},
+	{MT9E013_16BIT, {0x3E04}, 0x2801},
+	{MT9E013_16BIT, {0x3E06}, 0x8449},
+	{MT9E013_16BIT, {0x3E08}, 0x6841},
+	{MT9E013_16BIT, {0x3E0A}, 0x400C},
+	{MT9E013_16BIT, {0x3E0C}, 0x1001},
+	{MT9E013_16BIT, {0x3E0E}, 0x2603},
+	{MT9E013_16BIT, {0x3E10}, 0x4B41},
+	{MT9E013_16BIT, {0x3E12}, 0x4B24},
+	{MT9E013_16BIT, {0x3E14}, 0xA3CF},
+	{MT9E013_16BIT, {0x3E16}, 0x8802},
+	{MT9E013_16BIT, {0x3E18}, 0x84FF},
+	{MT9E013_16BIT, {0x3E1A}, 0x8601},
+	{MT9E013_16BIT, {0x3E1C}, 0x8401},
+	{MT9E013_16BIT, {0x3E1E}, 0x840A},
+	{MT9E013_16BIT, {0x3E20}, 0xFF00},
+	{MT9E013_16BIT, {0x3E22}, 0x8401},
+	{MT9E013_16BIT, {0x3E24}, 0x00FF},
+	{MT9E013_16BIT, {0x3E26}, 0x0088},
+	{MT9E013_16BIT, {0x3E28}, 0x2E8A},
+	{MT9E013_16BIT, {0x3E30}, 0x0000},
+	{MT9E013_16BIT, {0x3E32}, 0x8801},
+	{MT9E013_16BIT, {0x3E34}, 0x4029},
+	{MT9E013_16BIT, {0x3E36}, 0x00FF},
+	{MT9E013_16BIT, {0x3E38}, 0x8469},
+	{MT9E013_16BIT, {0x3E3A}, 0x00FF},
+	{MT9E013_16BIT, {0x3E3C}, 0x2801},
+	{MT9E013_16BIT, {0x3E3E}, 0x3E2A},
+	{MT9E013_16BIT, {0x3E40}, 0x1C01},
+	{MT9E013_16BIT, {0x3E42}, 0xFF84},
+	{MT9E013_16BIT, {0x3E44}, 0x8401},
+	{MT9E013_16BIT, {0x3E46}, 0x0C01},
+	{MT9E013_16BIT, {0x3E48}, 0x8401},
+	{MT9E013_16BIT, {0x3E4A}, 0x00FF},
+	{MT9E013_16BIT, {0x3E4C}, 0x8402},
+	{MT9E013_16BIT, {0x3E4E}, 0x8984},
+	{MT9E013_16BIT, {0x3E50}, 0x6628},
+	{MT9E013_16BIT, {0x3E52}, 0x8340},
+	{MT9E013_16BIT, {0x3E54}, 0x00FF},
+	{MT9E013_16BIT, {0x3E56}, 0x4A42},
+	{MT9E013_16BIT, {0x3E58}, 0x2703},
+	{MT9E013_16BIT, {0x3E5A}, 0x6752},
+	{MT9E013_16BIT, {0x3E5C}, 0x3F2A},
+	{MT9E013_16BIT, {0x3E5E}, 0x846A},
+	{MT9E013_16BIT, {0x3E60}, 0x4C01},
+	{MT9E013_16BIT, {0x3E62}, 0x8401},
+	{MT9E013_16BIT, {0x3E66}, 0x3901},
+	{MT9E013_16BIT, {0x3E90}, 0x2C01},
+	{MT9E013_16BIT, {0x3E98}, 0x2B02},
+	{MT9E013_16BIT, {0x3E92}, 0x2A04},
+	{MT9E013_16BIT, {0x3E94}, 0x2509},
+	{MT9E013_16BIT, {0x3E96}, 0x0000},
+	{MT9E013_16BIT, {0x3E9A}, 0x2905},
+	{MT9E013_16BIT, {0x3E9C}, 0x00FF},
+	{MT9E013_16BIT, {0x3ECC}, 0x00EB},
+	{MT9E013_16BIT, {0x3ED0}, 0x1E24},
+	{MT9E013_16BIT, {0x3ED4}, 0xAFC4},
+	{MT9E013_16BIT, {0x3ED6}, 0x909B},
+	{MT9E013_16BIT, {0x3EE0}, 0x2424},
+	{MT9E013_16BIT, {0x3EE2}, 0x9797},
+	{MT9E013_16BIT, {0x3EE4}, 0xC100},
+	{MT9E013_16BIT, {0x3EE6}, 0x0540},
+	{MT9E013_16BIT, {0x3174}, 0x8000},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static const struct mt9e013_reg mt9e013_pll_timing[] = {
+	/* pixelrate into the isp = 153.600.000 Hz */
+	{MT9E013_16BIT, {0x0300}, 0x0004}, /* vt_pix_clk_div = 4, internal
+					    * pixel clk freq = 192.000MHz
+					    */
+	{MT9E013_16BIT, {0x0302}, 0x0001}, /* vt_sys_clk_div = 1 */
+	{MT9E013_16BIT, {0x0304}, 0x0001}, /* pre_pll_clk_div = 1
+					    * PLL input clock freq = 19.200MHz
+					    */
+	{MT9E013_16BIT, {0x0306}, 0x0028}, /* pll_multiplier = 40
+					    * mipi bus speed = 768.000MHz
+					    */
+	{MT9E013_16BIT, {0x0308}, 0x000A}, /* op_pix_clk_div = 10, output
+					    * pixel clk freq = 76.800MHz
+					    */
+	{MT9E013_16BIT, {0x030A}, 0x0001}, /* op_sys_clk_div = 1 */
+	{MT9E013_16BIT, {0x3016}, 0x0111}, /* row_speed = 273 */
+	{MT9E013_TOK_DELAY, {0}, 1},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*2-lane MIPI Interface Configuration*/
+static const struct mt9e013_reg mt9e013_mipi_config[] = {
+	{MT9E013_16BIT+MT9E013_RMW, {0x3064}, 0x0100, 0x0000},
+	{MT9E013_16BIT, {0x31AE}, 0x0202},
+	{MT9E013_16BIT, {0x31B8}, 0x03EF},
+	/*{MT9E013_16BIT, {0x31B8}, 0x2FEF}, */
+	{MT9E013_TOK_DELAY, {0}, 5},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/* MIPI Timing Settings */
+static const struct mt9e013_reg mt9e013_mipi_timing[] = {
+	{MT9E013_16BIT, {0x31B0}, 0x0083},
+	{MT9E013_16BIT, {0x31B2}, 0x004D},
+	{MT9E013_16BIT, {0x31B4}, 0x0E88},
+	{MT9E013_16BIT, {0x31B6}, 0x0D24},
+	{MT9E013_16BIT, {0x31B8}, 0x020E},
+	{MT9E013_16BIT, {0x31BA}, 0x0710},
+	{MT9E013_16BIT, {0x31BC}, 0x2A0D},
+	{MT9E013_16BIT, {0x31BE}, 0xC007},
+	{MT9E013_TOK_DELAY, {0}, 5},
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/**********************still 5fps for Lexington*********************/
+static struct mt9e013_reg const mt9e013_STILL_8M_5fps[] = {
+	/* STILL 8M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340}, 0x1FEA}, /* FRAME_LENGTH_LINES 8170 */
+	{MT9E013_16BIT, {0x0342}, 0x1258}, /* LINE_LENGTH_PCK 4696 */
+	{MT9E013_16BIT, {0x0344}, 0x0000}, /* X_ADDR_START 0 */
+	{MT9E013_16BIT, {0x0346}, 0x0000}, /* Y_ADDR_START 0 */
+	{MT9E013_16BIT, {0x0348}, 0x0CCF}, /* X_ADDR_END 3279 */
+	{MT9E013_16BIT, {0x034A}, 0x099F}, /* Y_ADDR_END 2463 */
+	{MT9E013_16BIT, {0x034C}, 0x0CD0}, /* X_OUTPUT_SIZE 3280 */
+	{MT9E013_16BIT, {0x034E}, 0x09A0}, /* Y_OUTPUT_SIZE 2464 */
+	{MT9E013_16BIT, {0x3040}, 0x0041}, /* READ_MODE 0 0 0 0 0 0 0 1 1 */
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010}, 0x0078}, /* FINE_CORRECTION 120 */
+	{MT9E013_16BIT, {0X3012}, 0x4CA}, /* COARSE_INTEGRATION_TIME 1226 */
+	{MT9E013_16BIT, {0X3014}, 0x03F6}, /* FINE_INTEGRATION_TIME 1014 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400}, 0x0000}, /* SCALE_MODE 0 */
+	{MT9E013_16BIT, {0x0404}, 0x0010}, /* SCALE_M 16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_STILL_6M_5fps[] = {
+	/* STILL 6M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340}, 0x1FEA}, /* FRAME_LENGTH_LINES 8170 */
+	{MT9E013_16BIT, {0x0342}, 0x1258}, /* LINE_LENGTH_PCK 4696 */
+	{MT9E013_16BIT, {0x0344}, 0x0000}, /* X_ADDR_START 0 */
+	{MT9E013_16BIT, {0x0346}, 0x0134}, /* Y_ADDR_START 308 */
+	{MT9E013_16BIT, {0x0348}, 0x0CCF}, /* X_ADDR_END 3279 */
+	{MT9E013_16BIT, {0x034A}, 0x086D}, /* Y_ADDR_END 2157 */
+	{MT9E013_16BIT, {0x034C}, 0x0CD0}, /* X_OUTPUT_SIZE 3280 */
+	{MT9E013_16BIT, {0x034E}, 0x0738}, /* Y_OUTPUT_SIZE 1848 */
+	{MT9E013_16BIT, {0x3040}, 0x0041}, /* READ_MODE	0 0 0 0 0 0 0 1 1 */
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010}, 0x0078}, /* FINE_CORRECTION 120 */
+	{MT9E013_16BIT, {0X3012}, 0x4CA}, /* COARSE_INTEGRATION_TIME 1226 */
+	{MT9E013_16BIT, {0X3014}, 0x03F6}, /* FINE_INTEGRATION_TIME 1014 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400}, 0x0000}, /* SCALE_MODE 0 */
+	{MT9E013_16BIT, {0x0404}, 0x0010}, /* SCALE_M 16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_STILL_2M_5fps[] = {
+	/* STILL 2M */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration */
+	{MT9E013_16BIT, {0x0340}, 0x1FEA}, /* FRAME_LENGTH_LINES 8170 */
+	{MT9E013_16BIT, {0x0342}, 0x1258}, /* LINE_LENGTH_PCK 4696 */
+	{MT9E013_16BIT, {0x0344}, 0x0000}, /* X_ADDR_START 0 */
+	{MT9E013_16BIT, {0x0346}, 0x0000}, /* Y_ADDR_START 0 */
+	{MT9E013_16BIT, {0x0348}, 0x0CD1}, /* X_ADDR_END 3281 */
+	{MT9E013_16BIT, {0x034A}, 0x09A1}, /* Y_ADDR_END 2465 */
+	{MT9E013_16BIT, {0x034C}, 0x0668}, /* X_OUTPUT_SIZE 1640 */
+	{MT9E013_16BIT, {0x034E}, 0x04D0}, /* Y_OUTPUT_SIZE 1232 */
+	{MT9E013_16BIT, {0x3040}, 0x04C3}, /* READ_MODE	0 0 0 0 0 1 0 3 3 */
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010}, 0x0130}, /* FINE_CORRECTION 304 */
+	{MT9E013_16BIT, {0X3012}, 0x573}, /* COARSE_INTEGRATION_TIME 1395 */
+	{MT9E013_16BIT, {0X3014}, 0x0846}, /* FINE_INTEGRATION_TIME 2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400}, 0x0000}, /* SCALE_MODE 0 */
+	{MT9E013_16BIT, {0x0404}, 0x0010}, /* SCALE_M 16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************preview30ok********************************/
+static struct mt9e013_reg const mt9e013_PREVIEW_30fps[] = {
+	/* PREVIEW */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
+	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_WIDE_PREVIEW_30fps[] = {
+	/* WIDE PREVIEW */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0114	}, /*	Y_ADDR_START	276 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x088D	}, /*	Y_ADDR_END	2189 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1640 */
+	{MT9E013_16BIT, {0x034E},	0x03BC	}, /*	Y_OUTPUT_SIZE	956 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	0 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************video************************/
+static struct mt9e013_reg const mt9e013_1080p_strong_dvs_30fps[] = {
+	/*	1080p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340}, 0x05F3}, /* FRAME_LENGTH_LINES 1523 */
+	{MT9E013_16BIT, {0x0342}, 0x1068}, /* LINE_LENGTH_PCK 4200 */
+	{MT9E013_16BIT, {0x0344}, 0x01D8}, /* X_ADDR_START 472 */
+	{MT9E013_16BIT, {0x0346}, 0x0242}, /* Y_ADDR_START 578 */
+	{MT9E013_16BIT, {0x0348}, 0x0AF7}, /* X_ADDR_END 2807 */
+	{MT9E013_16BIT, {0x034A}, 0x075D}, /* Y_ADDR_END 1885 */
+	{MT9E013_16BIT, {0x034C}, 0x0920}, /* X_OUTPUT_SIZE 2336 */
+	{MT9E013_16BIT, {0x034E}, 0x051C}, /* Y_OUTPUT_SIZE 1308 */
+	{MT9E013_16BIT, {0x3040}, 0x0041}, /* READ_MODE	0 0 0 0 0 0 0 1 1 */
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x0},
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010}, 0x0078}, /* FINE_CORRECTION120 */
+	{MT9E013_16BIT, {0X3012}, 0x05F2}, /* COARSE_INTEGRATION_TIME 1522 */
+	{MT9E013_16BIT, {0X3014}, 0x0442}, /* FINE_INTEGRATION_TIME 1090 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400}, 0x0000}, /* SCALE_MODE 0 */
+	{MT9E013_16BIT, {0x0404}, 0x0010}, /* SCALE_M 16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_720p_strong_dvs_30fps[] = {
+	/* 720p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	{MT9E013_16BIT, {0x0340}, 0x04E2}, /* FRAME_LENGTH_LINES 1250 */
+	{MT9E013_16BIT, {0x0342}, 0x1400}, /* LINE_LENGTH_PCK 5120 */
+	{MT9E013_16BIT, {0x0344}, 0x0048}, /* X_ADDR_START 72 */
+	{MT9E013_16BIT, {0x0346}, 0x0160}, /* Y_ADDR_START 352 */
+	{MT9E013_16BIT, {0x0348}, 0x0C89}, /* X_ADDR_END 3209 */
+	{MT9E013_16BIT, {0x034A}, 0x083F}, /* Y_ADDR_END 2111 */
+	{MT9E013_16BIT, {0x034C}, 0x0620}, /* X_OUTPUT_SIZE 1568 */
+	{MT9E013_16BIT, {0x034E}, 0x0370}, /* Y_OUTPUT_SIZE 880 */
+	{MT9E013_16BIT, {0x3040}, 0x04C3}, /* READ_MODE	0 0 0 0 0 1 0 3 3 */
+	/* DATAPATH_SELECT_TRUE_BAYER */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1},
+	{MT9E013_16BIT, {0x3010}, 0x0130}, /* FINE_CORRECTION 304 */
+	{MT9E013_16BIT, {0x3012}, 0x0464}, /* COARSE_INTEGRATION_TIME 1124 */
+	{MT9E013_16BIT, {0X3014}, 0x0846}, /* FINE_INTEGRATION_TIME 2118 */
+	{MT9E013_16BIT, {0x0400}, 0x0002}, /* SCALE_MODE 2 */
+	{MT9E013_16BIT, {0x0404}, 0x0010}, /* SCALE_M 16 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_3RD_PARTY_PREVIEW1024_30fps[] = {
+	/*	PREVIEW 1024x576 special 'preview' mode to support 3rd party apps*/
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0668	}, /*	X_OUTPUT_SIZE	1050 */
+	{MT9E013_16BIT, {0x034E},	0x0400	}, /*	Y_OUTPUT_SIZE	778 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0000	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0010	}, /*	SCALE_M	25 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_WVGA_strong_dvs_30fps[] = {
+	/*	WVGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x00D0	}, /*	Y_ADDR_START	208 */
+	{MT9E013_16BIT, {0x0348},	0x0CCD	}, /*	X_ADDR_END	3277 */
+	{MT9E013_16BIT, {0x034A},	0x08CD	}, /*	Y_ADDR_END	2253 */
+	{MT9E013_16BIT, {0x034C},	0x03F0	}, /*	X_OUTPUT_SIZE	1008 */
+	{MT9E013_16BIT, {0x034E},	0x0276	}, /*	Y_OUTPUT_SIZE	630 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x001A	}, /*	SCALE_M	26 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_480p_strong_dvs_30fps[] = {
+	/*	480p strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0388	}, /*	X_OUTPUT_SIZE	904 */
+	{MT9E013_16BIT, {0x034E},	0x025A	}, /*	Y_OUTPUT_SIZE	602 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	  304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x001D	}, /*	SCALE_M	29 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_VGA_strong_dvs_30fps[] = {
+	/*	VGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0000	}, /*	X_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CCF	}, /*	X_ADDR_END	3279 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0334	}, /*	X_OUTPUT_SIZE	820 */
+	{MT9E013_16BIT, {0x034E},	0x0268	}, /*	Y_OUTPUT_SIZE	616 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0020	}, /*	SCALE_M	32 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_QVGA_strong_dvs_30fps[] = {
+	/*	QVGA strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0008	}, /*	X_ADDR_START	8 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CC7	}, /*	X_ADDR_END	3271 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x0198	}, /*	X_OUTPUT_SIZE	408 */
+	{MT9E013_16BIT, {0x034E},	0x0134	}, /*	Y_OUTPUT_SIZE	308 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0040	}, /*	SCALE_M	64 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_reg const mt9e013_QCIF_strong_dvs_30fps[] = {
+	/* QCIF strong dvs */
+	GROUPED_PARAMETER_HOLD_ENABLE,
+	/* Frame size & Timing Configuration*/
+	{MT9E013_16BIT, {0x0340},	0x060E	}, /*	FRAME_LENGTH_LINES	1550 */
+	{MT9E013_16BIT, {0x0342},	0x1020	}, /*	LINE_LENGTH_PCK	4128 */
+	{MT9E013_16BIT, {0x0344},	0x0080	}, /*	X_ADDR_START	128 */
+	{MT9E013_16BIT, {0x0346},	0x0000	}, /*	Y_ADDR_START	0 */
+	{MT9E013_16BIT, {0x0348},	0x0CB3	}, /*	X_ADDR_END	3251 */
+	{MT9E013_16BIT, {0x034A},	0x099F	}, /*	Y_ADDR_END	2463 */
+	{MT9E013_16BIT, {0x034C},	0x00D8	}, /*	X_OUTPUT_SIZE	216 */
+	{MT9E013_16BIT, {0x034E},	0x00B0	}, /*	Y_OUTPUT_SIZE	176 */
+	{MT9E013_16BIT, {0x3040},	0x04C3	}, /*	READ_MODE	0 0 0 0 0 1 0 3 3 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x306E}, 0x0010, 0x1}, /* DATAPATH_SELECT_TRUE_BAYER */
+	/* Initial integration time */
+	{MT9E013_16BIT, {0x3010},	0x0130	}, /*	FINE_CORRECTION	304 */
+	{MT9E013_16BIT, {0X3012},	0x0573	}, /*	COARSE_INTEGRATION_TIME	1395 */
+	{MT9E013_16BIT, {0X3014},	0x0846	}, /*	FINE_INTEGRATION_TIME	2118 */
+	/* Scaler configuration */
+	{MT9E013_16BIT, {0x0400},	0x0002	}, /*	SCALE_MODE	2 */
+	{MT9E013_16BIT, {0x0404},	0x0070	}, /*	SCALE_M	112 */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+
+static const struct mt9e013_reg mt9e013_lens_shading[] = {
+	{MT9E013_16BIT | MT9E013_RMW, {0x3780}, 0x8000, 0}, /* POLY_SC_ENABLE */
+	{MT9E013_16BIT, {0x3600}, 0x0430},	/* P_GR_P0Q0 */
+	{MT9E013_16BIT, {0x3602}, 0x1BEE},	/* P_GR_P0Q1 */
+	{MT9E013_16BIT, {0x3604}, 0x39F0},	/* P_GR_P0Q2 */
+	{MT9E013_16BIT, {0x3606}, 0xC7AD},	/* P_GR_P0Q3 */
+	{MT9E013_16BIT, {0x3608}, 0xC390},	/* P_GR_P0Q4 */
+	{MT9E013_16BIT, {0x360A}, 0x03D0},	/* P_RD_P0Q0 */
+	{MT9E013_16BIT, {0x360C}, 0xA0CE},	/* P_RD_P0Q1 */
+	{MT9E013_16BIT, {0x360E}, 0x2850},	/* P_RD_P0Q2 */
+	{MT9E013_16BIT, {0x3610}, 0x6A0E},	/* P_RD_P0Q3 */
+	{MT9E013_16BIT, {0x3612}, 0xAF30},	/* P_RD_P0Q4 */
+	{MT9E013_16BIT, {0x3614}, 0x03D0},	/* P_BL_P0Q0 */
+	{MT9E013_16BIT, {0x3616}, 0x36AE},	/* P_BL_P0Q1 */
+	{MT9E013_16BIT, {0x3618}, 0x5E6F},	/* P_BL_P0Q2 */
+	{MT9E013_16BIT, {0x361A}, 0xA22E},	/* P_BL_P0Q3 */
+	{MT9E013_16BIT, {0x361C}, 0xF6EF},	/* P_BL_P0Q4 */
+	{MT9E013_16BIT, {0x361E}, 0x02F0},	/* P_GB_P0Q0 */
+	{MT9E013_16BIT, {0x3620}, 0xA00E},	/* P_GB_P0Q1 */
+	{MT9E013_16BIT, {0x3622}, 0x3CD0},	/* P_GB_P0Q2 */
+	{MT9E013_16BIT, {0x3624}, 0x530E},	/* P_GB_P0Q3 */
+	{MT9E013_16BIT, {0x3626}, 0xCEF0},	/* P_GB_P0Q4 */
+	{MT9E013_16BIT, {0x3640}, 0xAB2D},	/* P_GR_P1Q0 */
+	{MT9E013_16BIT, {0x3642}, 0xB72E},	/* P_GR_P1Q1 */
+	{MT9E013_16BIT, {0x3644}, 0x988D},	/* P_GR_P1Q2 */
+	{MT9E013_16BIT, {0x3646}, 0x6E2E},	/* P_GR_P1Q3 */
+	{MT9E013_16BIT, {0x3648}, 0x53EE},	/* P_GR_P1Q4 */
+	{MT9E013_16BIT, {0x364A}, 0xDA2C},	/* P_RD_P1Q0 */
+	{MT9E013_16BIT, {0x364C}, 0x3E8D},	/* P_RD_P1Q1 */
+	{MT9E013_16BIT, {0x364E}, 0xAFAD},	/* P_RD_P1Q2 */
+	{MT9E013_16BIT, {0x3650}, 0x874E},	/* P_RD_P1Q3 */
+	{MT9E013_16BIT, {0x3652}, 0x5B4E},	/* P_RD_P1Q4 */
+	{MT9E013_16BIT, {0x3654}, 0x740D},	/* P_BL_P1Q0 */
+	{MT9E013_16BIT, {0x3656}, 0x310E},	/* P_BL_P1Q1 */
+	{MT9E013_16BIT, {0x3658}, 0x280B},	/* P_BL_P1Q2 */
+	{MT9E013_16BIT, {0x365A}, 0xE06E},	/* P_BL_P1Q3 */
+	{MT9E013_16BIT, {0x365C}, 0xEA0D},	/* P_BL_P1Q4 */
+	{MT9E013_16BIT, {0x365E}, 0x182D},	/* P_GB_P1Q0 */
+	{MT9E013_16BIT, {0x3660}, 0xAD0E},	/* P_GB_P1Q1 */
+	{MT9E013_16BIT, {0x3662}, 0x032E},	/* P_GB_P1Q2 */
+	{MT9E013_16BIT, {0x3664}, 0x7EEE},	/* P_GB_P1Q3 */
+	{MT9E013_16BIT, {0x3666}, 0xF34E},	/* P_GB_P1Q4 */
+	{MT9E013_16BIT, {0x3680}, 0x0E31},	/* P_GR_P2Q0 */
+	{MT9E013_16BIT, {0x3682}, 0x104F},	/* P_GR_P2Q1 */
+	{MT9E013_16BIT, {0x3684}, 0x92D3},	/* P_GR_P2Q2 */
+	{MT9E013_16BIT, {0x3686}, 0xA030},	/* P_GR_P2Q3 */
+	{MT9E013_16BIT, {0x3688}, 0x3873},	/* P_GR_P2Q4 */
+	{MT9E013_16BIT, {0x368A}, 0x1971},	/* P_RD_P2Q0 */
+	{MT9E013_16BIT, {0x368C}, 0x750C},	/* P_RD_P2Q1 */
+	{MT9E013_16BIT, {0x368E}, 0xFFF2},	/* P_RD_P2Q2 */
+	{MT9E013_16BIT, {0x3690}, 0xEDAF},	/* P_RD_P2Q3 */
+	{MT9E013_16BIT, {0x3692}, 0x1D73},	/* P_RD_P2Q4 */
+	{MT9E013_16BIT, {0x3694}, 0x0031},	/* P_BL_P2Q0 */
+	{MT9E013_16BIT, {0x3696}, 0x1A2F},	/* P_BL_P2Q1 */
+	{MT9E013_16BIT, {0x3698}, 0xF792},	/* P_BL_P2Q2 */
+	{MT9E013_16BIT, {0x369A}, 0x8530},	/* P_BL_P2Q3 */
+	{MT9E013_16BIT, {0x369C}, 0x1F73},	/* P_BL_P2Q4 */
+	{MT9E013_16BIT, {0x369E}, 0x08B1},	/* P_GB_P2Q0 */
+	{MT9E013_16BIT, {0x36A0}, 0x11AE},	/* P_GB_P2Q1 */
+	{MT9E013_16BIT, {0x36A2}, 0x9093},	/* P_GB_P2Q2 */
+	{MT9E013_16BIT, {0x36A4}, 0x9030},	/* P_GB_P2Q3 */
+	{MT9E013_16BIT, {0x36A6}, 0x36D3},	/* P_GB_P2Q4 */
+	{MT9E013_16BIT, {0x36C0}, 0x5F2D},	/* P_GR_P3Q0 */
+	{MT9E013_16BIT, {0x36C2}, 0x314F},	/* P_GR_P3Q1 */
+	{MT9E013_16BIT, {0x36C4}, 0x684E},	/* P_GR_P3Q2 */
+	{MT9E013_16BIT, {0x36C6}, 0x88B0},	/* P_GR_P3Q3 */
+	{MT9E013_16BIT, {0x36C8}, 0xDAF0},	/* P_GR_P3Q4 */
+	{MT9E013_16BIT, {0x36CA}, 0x636E},	/* P_RD_P3Q0 */
+	{MT9E013_16BIT, {0x36CC}, 0xAD0C},	/* P_RD_P3Q1 */
+	{MT9E013_16BIT, {0x36CE}, 0xEEEE},	/* P_RD_P3Q2 */
+	{MT9E013_16BIT, {0x36D0}, 0x500E},	/* P_RD_P3Q3 */
+	{MT9E013_16BIT, {0x36D2}, 0xDDCE},	/* P_RD_P3Q4 */
+	{MT9E013_16BIT, {0x36D4}, 0xA3AC},	/* P_BL_P3Q0 */
+	{MT9E013_16BIT, {0x36D6}, 0xC06E},	/* P_BL_P3Q1 */
+	{MT9E013_16BIT, {0x36D8}, 0xC04F},	/* P_BL_P3Q2 */
+	{MT9E013_16BIT, {0x36DA}, 0x49AF},	/* P_BL_P3Q3 */
+	{MT9E013_16BIT, {0x36DC}, 0x4830},	/* P_BL_P3Q4 */
+	{MT9E013_16BIT, {0x36DE}, 0x0F6B},	/* P_GB_P3Q0 */
+	{MT9E013_16BIT, {0x36E0}, 0x1DEF},	/* P_GB_P3Q1 */
+	{MT9E013_16BIT, {0x36E2}, 0x8730},	/* P_GB_P3Q2 */
+	{MT9E013_16BIT, {0x36E4}, 0x9E50},	/* P_GB_P3Q3 */
+	{MT9E013_16BIT, {0x36E6}, 0x7110},	/* P_GB_P3Q4 */
+	{MT9E013_16BIT, {0x3700}, 0xF4F1},	/* P_GR_P4Q0 */
+	{MT9E013_16BIT, {0x3702}, 0xF090},	/* P_GR_P4Q1 */
+	{MT9E013_16BIT, {0x3704}, 0x6493},	/* P_GR_P4Q2 */
+	{MT9E013_16BIT, {0x3706}, 0x5FB1},	/* P_GR_P4Q3 */
+	{MT9E013_16BIT, {0x3708}, 0xADB3},	/* P_GR_P4Q4 */
+	{MT9E013_16BIT, {0x370A}, 0xFEF1},	/* P_RD_P4Q0 */
+	{MT9E013_16BIT, {0x370C}, 0x134B},	/* P_RD_P4Q1 */
+	{MT9E013_16BIT, {0x370E}, 0x4D33},	/* P_RD_P4Q2 */
+	{MT9E013_16BIT, {0x3710}, 0x9B8E},	/* P_RD_P4Q3 */
+	{MT9E013_16BIT, {0x3712}, 0x88B3},	/* P_RD_P4Q4 */
+	{MT9E013_16BIT, {0x3714}, 0xEBB1},	/* P_BL_P4Q0 */
+	{MT9E013_16BIT, {0x3716}, 0x8131},	/* P_BL_P4Q1 */
+	{MT9E013_16BIT, {0x3718}, 0x5AD3},	/* P_BL_P4Q2 */
+	{MT9E013_16BIT, {0x371A}, 0x54F1},	/* P_BL_P4Q3 */
+	{MT9E013_16BIT, {0x371C}, 0xB193},	/* P_BL_P4Q4 */
+	{MT9E013_16BIT, {0x371E}, 0xE6D1},	/* P_GB_P4Q0 */
+	{MT9E013_16BIT, {0x3720}, 0xE0EC},	/* P_GB_P4Q1 */
+	{MT9E013_16BIT, {0x3722}, 0x6033},	/* P_GB_P4Q2 */
+	{MT9E013_16BIT, {0x3724}, 0x9DCE},	/* P_GB_P4Q3 */
+	{MT9E013_16BIT, {0x3726}, 0xA453},	/* P_GB_P4Q4 */
+	{MT9E013_16BIT, {0x3782}, 0x0614},	/* POLY_ORIGIN_C */
+	{MT9E013_16BIT, {0x3784}, 0x0494},	/* POLY_ORIGIN_R */
+	{MT9E013_16BIT, {0x37C0}, 0xC40A},	/* P_GR_Q5 */
+	{MT9E013_16BIT, {0x37C2}, 0xCE6A},	/* P_RD_Q5 */
+	{MT9E013_16BIT, {0x37C4}, 0xDBAA},	/* P_BL_Q5 */
+	{MT9E013_16BIT, {0x37C6}, 0xCCEA},	/* P_GB_Q5 */
+
+	/*STATE= Lens Correction Falloff, 70 */
+	{MT9E013_16BIT | MT9E013_RMW, {0x3780}, 0x8000, 1}, /* POLY_SC_ENABLE */
+	{MT9E013_TOK_TERM, {0}, 0}
+};
+
+static struct mt9e013_resolution mt9e013_res_preview[] = {
+	{
+		 .desc =	"PREVIEW_30fps"	,
+		 .width =	820	,
+		 .height =	616	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_PREVIEW_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"WIDE_PREVIEW_30fps"	,
+		 .width =	1640	,
+		 .height =	956	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_WIDE_PREVIEW_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+
+};
+
+#define N_RES_PREVIEW (ARRAY_SIZE(mt9e013_res_preview))
+
+static struct mt9e013_resolution mt9e013_res_still[] = {
+	{
+		 .desc =	"STILL_2M_5fps"	,
+		 .width =	1640	,
+		 .height =	1232	,
+		 .fps =		5	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1258, /* consistent with regs arrays */
+		 .lines_per_frame = 0x1FEA, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_2M_5fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 1,
+	},
+	{
+		 .desc =	"STILL_6M_5fps"	,
+		 .width =	3280	,
+		 .height =	1848	,
+		 .fps =		5	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1258, /* consistent with regs arrays */
+		 .lines_per_frame = 0x1FEA, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_6M_5fps	,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 1,
+	},
+	{
+		 .desc =	"STILL_8M_5fps"	,
+		 .width =	3280	,
+		 .height =	2464	,
+		 .fps =		5	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1258, /* consistent with regs arrays */
+		 .lines_per_frame = 0x1FEA, /* consistent with regs arrays */
+		 .regs =	mt9e013_STILL_8M_5fps	,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 1,
+	},
+};
+
+#define N_RES_STILL (ARRAY_SIZE(mt9e013_res_still))
+
+static struct mt9e013_resolution mt9e013_res_video[] = {
+	{
+		 .desc =	"QCIF_strong_dvs_30fps"	,
+		 .width =	216	,
+		 .height =	176	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_QCIF_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"QVGA_strong_dvs_30fps"	,
+		 .width =	408	,
+		 .height =	308	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_QVGA_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"VGA_strong_dvs_30fps"	,
+		 .width =	820	,
+		 .height =	616	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_VGA_strong_dvs_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		.desc = "480p_strong_dvs_30fps"	,
+		.width =	904	,
+		.height =	602	,
+		.fps =	30	,
+		.used =	0	,
+		.pixels_per_line = 0x1020, /* consistent with regs arrays */
+		.lines_per_frame = 0x060E, /* consistent with regs arrays */
+		.regs = mt9e013_480p_strong_dvs_30fps	,
+		.bin_factor_x =	2,
+		.bin_factor_y =	2,
+		.skip_frames = 0,
+	},
+	{
+		 .desc =	"WVGA_strong_dvs_30fps"	,
+		 .width =	1008	,
+		 .height =	630	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_WVGA_strong_dvs_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"3RD_PARTY_PREVIEW1024_30fps"	,
+		 .width =	1050	,
+		 .height =	778	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1020, /* consistent with regs arrays */
+		 .lines_per_frame = 0x060E, /* consistent with regs arrays */
+		 .regs =	mt9e013_3RD_PARTY_PREVIEW1024_30fps	,
+		 .bin_factor_x =	2,
+		 .bin_factor_y =	2,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"720p_strong_dvs_30fps"	,
+		 .width =	1568	,
+		 .height =	880	,
+		 .fps =		30	,
+		 .used =	0	,
+		 .pixels_per_line = 0x1400, /* consistent with regs arrays */
+		 .lines_per_frame = 0x04E2, /* consistent with regs arrays */
+		 .regs =	mt9e013_720p_strong_dvs_30fps	,
+		 .bin_factor_x =	1,
+		 .bin_factor_y =	1,
+		 .skip_frames = 0,
+	},
+	{
+		 .desc =	"1080p_strong_dvs_30fps",
+		 .width =	2336,
+		 .height =	1308,
+		 .fps =		30,
+		 .used =	0,
+		 .pixels_per_line = 0x05F3, /* consistent with regs arrays */
+		 .lines_per_frame = 0x1068, /* consistent with regs arrays */
+		 .regs =	mt9e013_1080p_strong_dvs_30fps,
+		 .bin_factor_x =	0,
+		 .bin_factor_y =	0,
+		 .skip_frames = 0,
+	},
+};
+
+#define N_RES_VIDEO (ARRAY_SIZE(mt9e013_res_video))
+
+static struct mt9e013_resolution *mt9e013_res = mt9e013_res_preview;
+static int N_RES = N_RES_PREVIEW;
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
new file mode 100644
index 0000000..4933811
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.c
@@ -0,0 +1,1518 @@
+/*
+ * Support for mt9m114 Camera Sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "mt9m114.h"
+
+#define to_mt9m114_sensor(sd) container_of(sd, struct mt9m114_device, sd)
+
+/*
+ * TODO: use debug parameter to actually define when debug messages should
+ * be printed.
+ */
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+static int mt9m114_t_vflip(struct v4l2_subdev *sd, int value);
+static int mt9m114_t_hflip(struct v4l2_subdev *sd, int value);
+static int mt9m114_wait_state(struct i2c_client *client, int timeout);
+
+static int
+mt9m114_read_reg(struct i2c_client *client, u16 data_length, u32 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		v4l2_err(client, "%s error, invalid data length\n", __func__);
+		return -EINVAL;
+	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u16) (reg >> 8);
+	data[1] = (u16) (reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	if (err >= 0) {
+		*val = 0;
+		/* high byte comes first */
+		if (data_length == MISENSOR_8BIT)
+			*val = data[0];
+		else if (data_length == MISENSOR_16BIT)
+			*val = data[1] + (data[0] << 8);
+		else
+			*val = data[3] + (data[2] << 8) +
+			    (data[1] << 16) + (data[0] << 24);
+
+		return 0;
+	}
+
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int
+mt9m114_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = be16_to_cpu((u16)val);
+	} else {
+		/* MISENSOR_32BIT */
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = be32_to_cpu(val);
+	}
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * HACK: Need some delay here for Rev 2 sensors otherwise some
+	 * registers do not seem to load correctly.
+	 */
+	mdelay(1);
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return num_msg;
+}
+
+/**
+ * misensor_rmw_reg - Read/Modify/Write a value to a register in the sensor
+ * device
+ * @client: i2c driver client structure
+ * @data_length: 8/16/32-bits length
+ * @reg: register address
+ * @mask: masked out bits
+ * @set: bits set
+ *
+ * Read/modify/write a value to a register in the  sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int
+misensor_rmw_reg(struct i2c_client *client, u16 data_length, u16 reg,
+		     u32 mask, u32 set)
+{
+	int err;
+	u32 val;
+
+	/* Exit when no mask */
+	if (mask == 0)
+		return 0;
+
+	/* @mask must not exceed data length */
+	switch (data_length) {
+	case MISENSOR_8BIT:
+		if (mask & ~0xff)
+			return -EINVAL;
+		break;
+	case MISENSOR_16BIT:
+		if (mask & ~0xffff)
+			return -EINVAL;
+		break;
+	case MISENSOR_32BIT:
+		break;
+	default:
+		/* Wrong @data_length */
+		return -EINVAL;
+	}
+
+	err = mt9m114_read_reg(client, data_length, reg, &val);
+	if (err) {
+		v4l2_err(client, "misensor_rmw_reg error exit, read failed\n");
+		return -EINVAL;
+	}
+
+	val &= ~mask;
+
+	/*
+	 * Perform the OR function if the @set exists.
+	 * Shift @set value to target bit location. @set should set only
+	 * bits included in @mask.
+	 *
+	 * REVISIT: This function expects @set to be non-shifted. Its shift
+	 * value is then defined to be equal to mask's LSB position.
+	 * How about to inform values in their right offset position and avoid
+	 * this unneeded shift operation?
+	 */
+	set <<= ffs(mask) - 1;
+	val |= set & mask;
+
+	err = mt9m114_write_reg(client, data_length, reg, val);
+	if (err) {
+		v4l2_err(client, "misensor_rmw_reg error exit, write failed\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int __mt9m114_flush_reg_array(struct i2c_client *client,
+				     struct mt9m114_write_ctrl *ctrl)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	int retry = 0;
+
+	if (ctrl->index == 0)
+		return 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + ctrl->index;
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	msg.buf = (u8 *)&ctrl->buffer;
+
+	ret = i2c_transfer(client->adapter, &msg, num_msg);
+	if (ret != num_msg) {
+		if (++retry <= I2C_RETRY_COUNT) {
+			dev_dbg(&client->dev, "retrying... %d\n", retry);
+			msleep(20);
+			goto again;
+		}
+		dev_err(&client->dev, "%s: i2c transfer error\n", __func__);
+		return -EIO;
+	}
+
+	ctrl->index = 0;
+
+	/*
+	 * REVISIT: Previously we had a delay after writing data to sensor.
+	 * But it was removed as our tests have shown it is not necessary
+	 * anymore.
+	 */
+
+	return 0;
+}
+
+static int __mt9m114_buf_reg_array(struct i2c_client *client,
+				   struct mt9m114_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	u16 *data16;
+	u32 *data32;
+	int err;
+
+	/* Insufficient buffer? Let's flush and get more free space. */
+	if (ctrl->index + next->length >= MT9M114_MAX_WRITE_BUF_SIZE) {
+		err = __mt9m114_flush_reg_array(client, ctrl);
+		if (err)
+			return err;
+	}
+
+	switch (next->length) {
+	case MISENSOR_8BIT:
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case MISENSOR_16BIT:
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	case MISENSOR_32BIT:
+		data32 = (u32 *)&ctrl->buffer.data[ctrl->index];
+		*data32 = cpu_to_be32(next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += next->length;
+
+	return 0;
+}
+
+static int
+__mt9m114_write_reg_is_consecutive(struct i2c_client *client,
+				   struct mt9m114_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+/*
+ * mt9m114_write_reg_array - Initializes a list of mt9m114 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ * @poll: completion polling requirement
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __mt9m114_flush_reg_array, __mt9m114_buf_reg_array() and
+ * __mt9m114_write_reg_is_consecutive() are internal functions to
+ * mt9m114_write_reg_array() and should be not used anywhere else.
+ *
+ */
+static int mt9m114_write_reg_array(struct i2c_client *client,
+				const struct misensor_reg *reglist,
+				int poll)
+{
+	const struct misensor_reg *next = reglist;
+	struct mt9m114_write_ctrl ctrl;
+	int err;
+
+	if (poll == PRE_POLLING) {
+		err = mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);
+		if (err)
+			return err;
+	}
+
+	ctrl.index = 0;
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		switch (next->length & MISENSOR_TOK_MASK) {
+		case MISENSOR_TOK_DELAY:
+			err = __mt9m114_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		case MISENSOR_TOK_RMW:
+			err = __mt9m114_flush_reg_array(client, &ctrl);
+			err |= misensor_rmw_reg(client,
+						next->length &
+							~MISENSOR_TOK_RMW,
+						next->reg, next->val,
+						next->val2);
+			if (err) {
+				dev_err(&client->dev, "%s read err. aborted\n",
+					__func__);
+				return -EINVAL;
+			}
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__mt9m114_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __mt9m114_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __mt9m114_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	err = __mt9m114_flush_reg_array(client, &ctrl);
+	if (err)
+		return err;
+
+	if (poll == POST_POLLING)
+		return mt9m114_wait_state(client, MT9M114_WAIT_STAT_TIMEOUT);
+
+	return 0;
+}
+
+static int mt9m114_wait_state(struct i2c_client *client, int timeout)
+{
+	int ret;
+	unsigned int val;
+
+	while (timeout-- > 0) {
+		ret = mt9m114_read_reg(client, MISENSOR_16BIT, 0x0080, &val);
+		if (ret)
+			return ret;
+		if ((val & 0x2) == 0)
+			return 0;
+		msleep(20);
+	}
+
+	return -EINVAL;
+
+}
+
+static int mt9m114_set_suspend(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9m114_write_reg_array(client, mt9m114_suspend, POST_POLLING);
+}
+
+static int mt9m114_set_streaming(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return mt9m114_write_reg_array(client, mt9m114_streaming, POST_POLLING);
+}
+
+static int mt9m114_init_common(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = mt9m114_write_reg_array(client, mt9m114_common, PRE_POLLING);
+	if (ret)
+		return ret;
+	ret = mt9m114_write_reg_array(client, mt9m114_iq, NO_POLLING);
+
+	return ret;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+	/*
+	 * according to DS, 44ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(50);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int mt9m114_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+	else {
+		if (power_up(sd))
+			return -EINVAL;
+
+		return mt9m114_init_common(sd);
+	}
+}
+
+static int mt9m114_try_res(u32 *w, u32 *h)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9m114_res[i].width >= *w) &&
+		    (mt9m114_res[i].height >= *h))
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = mt9m114_res[i].width;
+	*h = mt9m114_res[i].height;
+
+	return 0;
+}
+
+static struct mt9m114_res_struct *mt9m114_to_res(u32 w, u32 h)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if ((mt9m114_res[index].width == w) &&
+		    (mt9m114_res[index].height == h))
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &mt9m114_res[index];
+}
+
+static int mt9m114_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	return mt9m114_try_res(&fmt->width, &fmt->height);
+}
+
+static int mt9m114_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case MT9M114_RES_QCIF:
+		hsize = MT9M114_RES_QCIF_SIZE_H;
+		vsize = MT9M114_RES_QCIF_SIZE_V;
+		break;
+	case MT9M114_RES_QVGA:
+		hsize = MT9M114_RES_QVGA_SIZE_H;
+		vsize = MT9M114_RES_QVGA_SIZE_V;
+		break;
+	case MT9M114_RES_VGA:
+		hsize = MT9M114_RES_VGA_SIZE_H;
+		vsize = MT9M114_RES_VGA_SIZE_V;
+		break;
+	case MT9M114_RES_480P:
+		hsize = MT9M114_RES_480P_SIZE_H;
+		vsize = MT9M114_RES_480P_SIZE_V;
+		break;
+	case MT9M114_RES_576P:
+		hsize = MT9M114_RES_576P_SIZE_H;
+		vsize = MT9M114_RES_576P_SIZE_V;
+		break;
+	case MT9M114_RES_720P:
+		hsize = MT9M114_RES_720P_SIZE_H;
+		vsize = MT9M114_RES_720P_SIZE_V;
+		break;
+	case MT9M114_RES_960P:
+		hsize = MT9M114_RES_960P_SIZE_H;
+		vsize = MT9M114_RES_960P_SIZE_V;
+		break;
+	default:
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int mt9m114_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int width, height;
+	int ret;
+
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	ret = mt9m114_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+
+	return 0;
+}
+
+static int mt9m114_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct mt9m114_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	int ret;
+
+	mt9m114_try_res(&width, &height);
+	res_index = mt9m114_to_res(width, height);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	switch (res_index->res) {
+	case MT9M114_RES_QCIF:
+		ret = mt9m114_write_reg_array(c, mt9m114_qcif_init, NO_POLLING);
+		break;
+	case MT9M114_RES_QVGA:
+		ret = mt9m114_write_reg_array(c, mt9m114_qvga_init, NO_POLLING);
+		/* set sensor read_mode to Skipping */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_SKIPPING_SET);
+		break;
+	case MT9M114_RES_VGA:
+		ret = mt9m114_write_reg_array(c, mt9m114_vga_init, NO_POLLING);
+		/* set sensor read_mode to Summing */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_SUMMING_SET);
+		break;
+	case MT9M114_RES_480P:
+		ret = mt9m114_write_reg_array(c, mt9m114_480p_init, NO_POLLING);
+		break;
+	case MT9M114_RES_576P:
+		ret = mt9m114_write_reg_array(c, mt9m114_576p_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_720P:
+		ret = mt9m114_write_reg_array(c, mt9m114_720p_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	case MT9M114_RES_960P:
+		ret = mt9m114_write_reg_array(c, mt9m114_960P_init, NO_POLLING);
+		/* set sensor read_mode to Normal */
+		ret += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+				MISENSOR_R_MODE_MASK, MISENSOR_NORMAL_SET);
+		break;
+	default:
+		v4l2_err(sd, "set resolution: %d failed!\n", res_index->res);
+		return -EINVAL;
+	}
+
+	if (ret)
+		return -EINVAL;
+
+	ret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg, POST_POLLING);
+	if (ret < 0)
+		return ret;
+
+	if (mt9m114_set_suspend(sd))
+		return -EINVAL;
+
+	if (dev->res != res_index->res) {
+		int index;
+
+		/* Switch to different size */
+		if (width <= 640) {
+			dev->nctx = 0x00; /* Set for context A */
+		} else {
+			/*
+			 * Context B is used for resolutions larger than 640x480
+			 * Using YUV for Context B.
+			 */
+			dev->nctx = 0x01; /* set for context B */
+		}
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if ((width == mt9m114_res[index].width) &&
+			    (height == mt9m114_res[index].height)) {
+				mt9m114_res[index].used = 1;
+				continue;
+			}
+			mt9m114_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * mt9m114 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+/* TODO: Update to SOC functions, remove exposure and gain */
+static int mt9m114_g_focal(struct v4l2_subdev *sd, s32 * val)
+{
+	*val = (MT9M114_FOCAL_LENGTH_NUM << 16) | MT9M114_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int mt9m114_g_fnumber(struct v4l2_subdev *sd, s32 * val)
+{
+	/*const f number for mt9m114*/
+	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 16) | MT9M114_F_NUMBER_DEM;
+	return 0;
+}
+
+static int mt9m114_g_fnumber_range(struct v4l2_subdev *sd, s32 * val)
+{
+	*val = (MT9M114_F_NUMBER_DEFAULT_NUM << 24) |
+		(MT9M114_F_NUMBER_DEM << 16) |
+		(MT9M114_F_NUMBER_DEFAULT_NUM << 8) | MT9M114_F_NUMBER_DEM;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int mt9m114_g_hflip(struct v4l2_subdev *sd, s32 * val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u32 data;
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT,
+			(u32)MISENSOR_READ_MODE, &data);
+	if (ret)
+		return ret;
+	*val = !!(data & MISENSOR_HFLIP_MASK);
+
+	return 0;
+}
+
+static int mt9m114_g_vflip(struct v4l2_subdev *sd, s32 * val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u32 data;
+
+	ret = mt9m114_read_reg(c, MISENSOR_16BIT,
+			(u32)MISENSOR_READ_MODE, &data);
+	if (ret)
+		return ret;
+	*val = !!(data & MISENSOR_VFLIP_MASK);
+
+	return 0;
+}
+
+static int mt9m114_s_freq(struct v4l2_subdev *sd, s32  val)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int ret;
+
+	if (val != MT9M114_FLICKER_MODE_50HZ &&
+			val != MT9M114_FLICKER_MODE_60HZ)
+		return -EINVAL;
+
+	if (val == MT9M114_FLICKER_MODE_50HZ) {
+		ret = mt9m114_write_reg_array(c, mt9m114_antiflicker_50hz,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+	} else {
+		ret = mt9m114_write_reg_array(c, mt9m114_antiflicker_60hz,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (ret == 0)
+		dev->lightfreq = val;
+
+	return ret;
+}
+
+static int mt9m114_g_2a_status(struct v4l2_subdev *sd, s32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	unsigned int status_exp, status_wb;
+	*val = 0;
+
+	ret = mt9m114_read_reg(client, MISENSOR_16BIT,
+			MISENSOR_AE_TRACK_STATUS, &status_exp);
+	if (ret)
+		return ret;
+
+	ret = mt9m114_read_reg(client, MISENSOR_16BIT,
+			MISENSOR_AWB_STATUS, &status_wb);
+	if (ret)
+		return ret;
+
+	if (status_exp & MISENSOR_AE_READY)
+		*val = V4L2_2A_STATUS_AE_READY;
+
+	if (status_wb & MISENSOR_AWB_STEADY)
+		*val |= V4L2_2A_STATUS_AWB_READY;
+
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int mt9m114_g_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 coarse;
+	int ret;
+
+	/* the fine integration time is currently not calculated */
+	ret = mt9m114_read_reg(client, MISENSOR_16BIT,
+			       MISENSOR_COARSE_INTEGRATION_TIME, &coarse);
+	if (ret)
+		return ret;
+
+	*value = coarse;
+	return 0;
+}
+
+static struct mt9m114_control mt9m114_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image v-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = mt9m114_g_vflip,
+		.tweak = mt9m114_t_vflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image h-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = mt9m114_g_hflip,
+		.tweak = mt9m114_t_hflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.maximum = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9M114_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9m114_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = MT9M114_F_NUMBER_DEFAULT,
+			.maximum = MT9M114_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9M114_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9m114_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = MT9M114_F_NUMBER_RANGE,
+			.maximum =  MT9M114_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = MT9M114_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = mt9m114_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_POWER_LINE_FREQUENCY,
+			.type = V4L2_CTRL_TYPE_MENU,
+			.name = "Light frequency filter",
+			.minimum = 1,
+			.maximum =  2, /* 1: 50Hz, 2:60Hz */
+			.step = 1,
+			.default_value = 1,
+			.flags = 0,
+		},
+		.tweak = mt9m114_s_freq,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_2A_STATUS,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "AE and AWB status",
+			.minimum = 0,
+			.maximum = V4L2_2A_STATUS_AE_READY |
+				V4L2_2A_STATUS_AWB_READY,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = mt9m114_g_2a_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9m114_g_exposure,
+	},
+
+};
+#define N_CONTROLS (ARRAY_SIZE(mt9m114_controls))
+
+static struct mt9m114_control *mt9m114_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (mt9m114_controls[i].qc.id == id)
+			return &mt9m114_controls[i];
+	}
+	return NULL;
+}
+
+static int mt9m114_detect(struct mt9m114_device *dev, struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+	mt9m114_read_reg(client, MISENSOR_16BIT, (u32)MT9M114_PID, &retvalue);
+	dev->real_model_id = retvalue;
+
+	if (retvalue != MT9M114_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int
+mt9m114_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			v4l2_err(client, "mt9m114 platform init err\n");
+			return ret;
+		}
+	}
+	ret = mt9m114_s_power(sd, 1);
+	if (ret) {
+		v4l2_err(client, "mt9m114 power-up err");
+		return ret;
+	}
+
+	/* config & detect sensor */
+	ret = mt9m114_detect(dev, client);
+	if (ret) {
+		v4l2_err(client, "mt9m114_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = mt9m114_set_suspend(sd);
+	if (ret) {
+		v4l2_err(client, "mt9m114 suspend err");
+		return ret;
+	}
+
+	ret = mt9m114_s_power(sd, 0);
+	if (ret) {
+		v4l2_err(client, "mt9m114 power down err");
+		return ret;
+	}
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	mt9m114_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int mt9m114_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct mt9m114_control *ctrl = mt9m114_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int mt9m114_t_hflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9m114_device *dev = to_mt9m114_sensor(sd);
+	int err;
+	/* set for direct mode */
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);
+	if (value) {
+		/* enable H flip ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x01);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x01);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_HFLIP_MASK, MISENSOR_FLIP_EN);
+
+		dev->bpat = MT9M114_BPAT_GRGRBGBG;
+	} else {
+		/* disable H flip ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x01, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x01, 0x00);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x01, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x01, 0x00);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_HFLIP_MASK, MISENSOR_FLIP_DIS);
+
+		dev->bpat = MT9M114_BPAT_BGBGGRGR;
+	}
+
+	err += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);
+	udelay(10);
+
+	return !!err;
+}
+
+/* Vertically flip the image */
+static int mt9m114_t_vflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int err;
+	/* set for direct mode */
+	err = mt9m114_write_reg(c, MISENSOR_16BIT, 0x098E, 0xC850);
+	if (value >= 1) {
+		/* enable H flip - ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x01);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x01);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x01);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_VFLIP_MASK, MISENSOR_FLIP_EN);
+	} else {
+		/* disable H flip - ctx A */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC850, 0x02, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC851, 0x02, 0x00);
+		/* ctx B */
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC888, 0x02, 0x00);
+		err += misensor_rmw_reg(c, MISENSOR_8BIT, 0xC889, 0x02, 0x00);
+
+		err += misensor_rmw_reg(c, MISENSOR_16BIT, MISENSOR_READ_MODE,
+					MISENSOR_VFLIP_MASK, MISENSOR_FLIP_DIS);
+	}
+
+	err += mt9m114_write_reg(c, MISENSOR_8BIT, 0x8404, 0x06);
+	udelay(10);
+
+	return !!err;
+}
+
+static int mt9m114_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9m114_control *octrl = mt9m114_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9m114_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9m114_control *octrl = mt9m114_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9m114_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+
+	if (enable) {
+		ret = mt9m114_write_reg_array(c, mt9m114_chgstat_reg,
+					POST_POLLING);
+		if (ret < 0)
+			return ret;
+
+		ret = mt9m114_set_streaming(sd);
+	} else {
+		ret = mt9m114_set_suspend(sd);
+	}
+
+	return ret;
+}
+
+static int
+mt9m114_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = mt9m114_res[index].width;
+	fsize->discrete.height = mt9m114_res[index].height;
+
+	/* FIXME: Wrong way to know used mode */
+	fsize->reserved[0] = mt9m114_res[index].used;
+
+	return 0;
+}
+
+static int mt9m114_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9m114_res[i].width >= fival->width) &&
+		    (mt9m114_res[i].height >= fival->height))
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = mt9m114_res[index].fps;
+
+	return 0;
+}
+
+static int
+mt9m114_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_MT9M114, 0);
+}
+
+static int mt9m114_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int mt9m114_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+
+	unsigned int index = fse->index;
+
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = mt9m114_res[index].width;
+	fse->min_height = mt9m114_res[index].height;
+	fse->max_width = mt9m114_res[index].width;
+	fse->max_height = mt9m114_res[index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mt9m114_get_pad_format(struct mt9m114_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,  "%s err. pad %x\n", __func__, pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+mt9m114_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9m114_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+mt9m114_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9m114_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int mt9m114_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct mt9m114_device *snr = to_mt9m114_sensor(sd);
+
+	if (frames == NULL)
+		return -EINVAL;
+
+	for (index = 0; index < N_RES; index++) {
+		if (mt9m114_res[index].res == snr->res)
+			break;
+	}
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	*frames = mt9m114_res[index].skip_frames;
+
+	return 0;
+}
+static const struct v4l2_subdev_video_ops mt9m114_video_ops = {
+	.try_mbus_fmt = mt9m114_try_mbus_fmt,
+	.s_mbus_fmt = mt9m114_set_mbus_fmt,
+	.g_mbus_fmt = mt9m114_get_mbus_fmt,
+	.s_stream = mt9m114_s_stream,
+	.enum_framesizes = mt9m114_enum_framesizes,
+	.enum_frameintervals = mt9m114_enum_frameintervals,
+};
+
+static struct v4l2_subdev_sensor_ops mt9m114_sensor_ops = {
+	.g_skip_frames	= mt9m114_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops mt9m114_core_ops = {
+	.g_chip_ident = mt9m114_g_chip_ident,
+	.queryctrl = mt9m114_queryctrl,
+	.g_ctrl = mt9m114_g_ctrl,
+	.s_ctrl = mt9m114_s_ctrl,
+	.s_power = mt9m114_s_power,
+};
+
+/* REVISIT: Do we need pad operations? */
+static const struct v4l2_subdev_pad_ops mt9m114_pad_ops = {
+	.enum_mbus_code = mt9m114_enum_mbus_code,
+	.enum_frame_size = mt9m114_enum_frame_size,
+	.get_fmt = mt9m114_get_pad_format,
+	.set_fmt = mt9m114_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops mt9m114_ops = {
+	.core = &mt9m114_core_ops,
+	.video = &mt9m114_video_ops,
+	.pad = &mt9m114_pad_ops,
+	.sensor = &mt9m114_sensor_ops,
+};
+
+static const struct media_entity_operations mt9m114_entity_ops = {
+	.link_setup = NULL,
+};
+
+
+static int mt9m114_remove(struct i2c_client *client)
+{
+	struct mt9m114_device *dev;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	dev = container_of(sd, struct mt9m114_device, sd);
+	dev->platform_data->csi_cfg(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+	return 0;
+}
+
+static int mt9m114_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct mt9m114_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &mt9m114_ops);
+	if (client->dev.platform_data) {
+		ret = mt9m114_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* REVISIT: Do we need media controller? */
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		mt9m114_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, mt9m114_id);
+
+static struct i2c_driver mt9m114_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mt9m114"
+	},
+	.probe = mt9m114_probe,
+	.remove = mt9m114_remove,
+	.id_table = mt9m114_id,
+};
+
+static __init int init_mt9m114(void)
+{
+	return i2c_add_driver(&mt9m114_driver);
+}
+
+static __exit void exit_mt9m114(void)
+{
+	i2c_del_driver(&mt9m114_driver);
+}
+
+module_init(init_mt9m114);
+module_exit(exit_mt9m114);
+
+MODULE_AUTHOR("Shuguang Gong <Shuguang.gong@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
new file mode 100644
index 0000000..bcf1974
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9m114.h
@@ -0,0 +1,1686 @@
+/*
+ * Support for mt9m114 Camera Sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __A1040_H__
+#define __A1040_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define V4L2_IDENT_MT9M114 8245
+
+#define MT9P111_REV3
+#define FULLINISUPPORT
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_FWBURST0	0x80
+#define MISENSOR_FWBURST1	0x81
+#define MISENSOR_FWBURST4	0x84
+#define MISENSOR_FWBURST	0x88
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+#define MISENSOR_TOK_RMW	0x0010  /* RMW operation */
+#define MISENSOR_TOK_MASK	0xfff0
+#define MISENSOR_AWB_STEADY	(1<<0)	/* awb steady */
+#define MISENSOR_AE_READY	(1<<3)	/* ae status ready */
+
+/* mask to set sensor read_mode via misensor_rmw_reg */
+#define MISENSOR_R_MODE_MASK	0x0330
+/* mask to set sensor vert_flip and horz_mirror */
+#define MISENSOR_VFLIP_MASK	0x0002
+#define MISENSOR_HFLIP_MASK	0x0001
+#define MISENSOR_FLIP_EN	1
+#define MISENSOR_FLIP_DIS	0
+
+/* bits set to set sensor read_mode via misensor_rmw_reg */
+#define MISENSOR_SKIPPING_SET	0x0011
+#define MISENSOR_SUMMING_SET	0x0033
+#define MISENSOR_NORMAL_SET	0x0000
+
+/* sensor register that control sensor read-mode and mirror */
+#define MISENSOR_READ_MODE	0xC834
+/* sensor ae-track status register */
+#define MISENSOR_AE_TRACK_STATUS	0xA800
+/* sensor awb status register */
+#define MISENSOR_AWB_STATUS	0xAC00
+/* sensor coarse integration time register */
+#define MISENSOR_COARSE_INTEGRATION_TIME 0xC83C
+
+
+#define SENSOR_DETECTED		1
+#define SENSOR_NOT_DETECTED	0
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+#ifndef MIPI_CONTROL
+#define MIPI_CONTROL		0x3400	/* MIPI_Control */
+#endif
+
+/* GPIO pin on Moorestown */
+#define GPIO_SCLK_25		44
+#define GPIO_STB_PIN		47
+
+#define GPIO_STDBY_PIN		49   /* ab:new */
+#define GPIO_RESET_PIN		50
+
+/* System control register for Aptina A-1040SOC*/
+#define MT9M114_PID		0x0
+
+/* MT9P111_DEVICE_ID */
+#define MT9M114_MOD_ID		0x2481
+
+/* ulBPat; */
+
+#define MT9M114_BPAT_RGRGGBGB	(1 << 0)
+#define MT9M114_BPAT_GRGRBGBG	(1 << 1)
+#define MT9M114_BPAT_GBGBRGRG	(1 << 2)
+#define MT9M114_BPAT_BGBGGRGR	(1 << 3)
+
+#define MT9M114_FOCAL_LENGTH_NUM	208	/*2.08mm*/
+#define MT9M114_FOCAL_LENGTH_DEM	100
+#define MT9M114_F_NUMBER_DEFAULT_NUM	24
+#define MT9M114_F_NUMBER_DEM	10
+#define MT9M114_WAIT_STAT_TIMEOUT	100
+#define MT9M114_FLICKER_MODE_50HZ	1
+#define MT9M114_FLICKER_MODE_60HZ	2
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9M114_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9M114_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define MT9M114_F_NUMBER_RANGE 0x180a180a
+
+/* Supported resolutions */
+enum {
+	MT9M114_RES_QCIF,
+	MT9M114_RES_QVGA,
+	MT9M114_RES_VGA,
+	MT9M114_RES_480P,
+	MT9M114_RES_576P,
+	MT9M114_RES_720P,
+	MT9M114_RES_960P,
+};
+#define MT9M114_RES_960P_SIZE_H		1280
+#define MT9M114_RES_960P_SIZE_V		960
+#define MT9M114_RES_720P_SIZE_H		1280
+#define MT9M114_RES_720P_SIZE_V		720
+#define MT9M114_RES_576P_SIZE_H		1024
+#define MT9M114_RES_576P_SIZE_V		576
+#define MT9M114_RES_480P_SIZE_H		768
+#define MT9M114_RES_480P_SIZE_V		480
+#define MT9M114_RES_VGA_SIZE_H		640
+#define MT9M114_RES_VGA_SIZE_V		480
+#define MT9M114_RES_QVGA_SIZE_H		320
+#define MT9M114_RES_QVGA_SIZE_V		240
+#define MT9M114_RES_QCIF_SIZE_H		176
+#define MT9M114_RES_QCIF_SIZE_V		144
+
+/* completion status polling requirements, usage based on Aptina .INI Rev2 */
+enum poll_reg {
+	NO_POLLING,
+	PRE_POLLING,
+	POST_POLLING,
+};
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u32 length;
+	u32 reg;
+	u32 val;	/* value or for read/mod/write, AND mask */
+	u32 val2;	/* optional; for rmw, OR mask */
+};
+
+/*
+ * struct misensor_fwreg - Firmware burst command
+ * @type: FW burst or 8/16 bit register
+ * @addr: 16-bit offset to register or other values depending on type
+ * @valx: data value for burst (or other commands)
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_fwreg {
+	u32	type;	/* type of value, register or FW burst string */
+	u32	addr;	/* target address */
+	u32	val0;
+	u32	val1;
+	u32	val2;
+	u32	val3;
+	u32	val4;
+	u32	val5;
+	u32	val6;
+	u32	val7;
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct mt9m114_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int real_model_id;
+	int nctx;
+	int power;
+
+	unsigned int bus_width;
+	unsigned int mode;
+	unsigned int field_inv;
+	unsigned int field_sel;
+	unsigned int ycseq;
+	unsigned int conv422;
+	unsigned int bpat;
+	unsigned int hpol;
+	unsigned int vpol;
+	unsigned int edge;
+	unsigned int bls;
+	unsigned int gamma;
+	unsigned int cconv;
+	unsigned int res;
+	unsigned int dwn_sz;
+	unsigned int blc;
+	unsigned int agc;
+	unsigned int awb;
+	unsigned int aec;
+	/* extention SENSOR version 2 */
+	unsigned int cie_profile;
+
+	/* extention SENSOR version 3 */
+	unsigned int flicker_freq;
+
+	/* extension SENSOR version 4 */
+	unsigned int smia_mode;
+	unsigned int mipi_mode;
+
+	/* Add name here to load shared library */
+	unsigned int type;
+
+	/*Number of MIPI lanes*/
+	unsigned int mipi_lanes;
+	char name[32];
+
+	u8 lightfreq;
+};
+
+struct mt9m114_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct mt9m114_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+struct mt9m114_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+/* 2 bytes used for address: 256 bytes total */
+#define MT9M114_MAX_WRITE_BUF_SIZE	254
+struct mt9m114_write_buffer {
+	u16 addr;
+	u8 data[MT9M114_MAX_WRITE_BUF_SIZE];
+};
+
+struct mt9m114_write_ctrl {
+	int index;
+	struct mt9m114_write_buffer buffer;
+};
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * Please, keep them in ascending order.
+ */
+static struct mt9m114_res_struct mt9m114_res[] = {
+	{
+	.desc	= "QCIF",
+	.res	= MT9M114_RES_QCIF,
+	.width	= 176,
+	.height	= 144,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "QVGA",
+	.res	= MT9M114_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "VGA",
+	.res	= MT9M114_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "480p",
+	.res	= MT9M114_RES_480P,
+	.width	= 768,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "576p",
+	.res	= MT9M114_RES_576P,
+	.width	= 1024,
+	.height	= 576,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 3,
+	},
+	{
+	.desc	= "720p",
+	.res	= MT9M114_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+	{
+	.desc	= "960P",
+	.res	= MT9M114_RES_960P,
+	.width	= 1280,
+	.height	= 960,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	},
+};
+#define N_RES (ARRAY_SIZE(mt9m114_res))
+
+static const struct i2c_device_id mt9m114_id[] = {
+	{"mt9m114", 0},
+	{}
+};
+
+static struct misensor_reg const mt9m114_suspend[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x40},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_streaming[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x34},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_standby_reg[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x50},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_wakeup_reg[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xDC00},
+	 {MISENSOR_8BIT,  0xDC00, 0x54},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_chgstat_reg[] = {
+	{MISENSOR_16BIT,  0x098E, 0xDC00},
+	{MISENSOR_8BIT,  0xDC00, 0x28},
+	{MISENSOR_16BIT,  0x0080, 0x8002},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+static struct misensor_reg const mt9m114_qcif_init[] = {
+
+	{MISENSOR_16BIT,  0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0034},
+	{MISENSOR_16BIT,  0xC802, 0x0074},
+	{MISENSOR_16BIT,  0xC804, 0x039B},
+	{MISENSOR_16BIT,  0xC806, 0x049B},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x04D1},
+	{MISENSOR_16BIT,  0xC812, 0x0495},
+	{MISENSOR_16BIT,  0xC814, 0x0554},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x0363},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0420},
+	{MISENSOR_16BIT,  0xC85A, 0x0360},
+	{MISENSOR_8BIT,  0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x00B0},
+	{MISENSOR_16BIT,  0xC86A, 0x0090},
+	{MISENSOR_8BIT,  0xC878, 0x0E},
+	{MISENSOR_16BIT,  0xC88C, 0x1E00},
+	{MISENSOR_16BIT,  0xC88E, 0x1E00},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x00AF},
+	{MISENSOR_16BIT,  0xC91A, 0x008F},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x0022},
+	{MISENSOR_16BIT,  0xC922, 0x001B},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_qvga_init[] = {
+
+	{MISENSOR_16BIT,  0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0000},
+	{MISENSOR_16BIT,  0xC802, 0x0000},
+	{MISENSOR_16BIT,  0xC804, 0x03CD},
+	{MISENSOR_16BIT,  0xC806, 0x050D},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x05B3},
+	{MISENSOR_16BIT,  0xC812, 0x03E8},
+	{MISENSOR_16BIT,  0xC814, 0x0640},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x01E3},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0x11},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0280},
+	{MISENSOR_16BIT,  0xC85A, 0x01E0},
+	{MISENSOR_8BIT,  0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x0140},
+	{MISENSOR_16BIT,  0xC86A, 0x00F0},
+	{MISENSOR_8BIT,  0xC878, 0xE},
+	{MISENSOR_16BIT,  0xC88C, 0x1E03},
+	{MISENSOR_16BIT,  0xC88E, 0x1E03},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x013F},
+	{MISENSOR_16BIT,  0xC91A, 0x00EF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x003F},
+	{MISENSOR_16BIT,  0xC922, 0x002F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_720p_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x007C},
+	{MISENSOR_16BIT,  0xC802, 0x0004},
+	{MISENSOR_16BIT,  0xC804, 0x0353},
+	{MISENSOR_16BIT,  0xC806, 0x050B},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x05BD},
+	{MISENSOR_16BIT,  0xC812, 0x03E8},
+	{MISENSOR_16BIT,  0xC814, 0x0640},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x02D3},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0500},
+	{MISENSOR_16BIT,  0xC85A, 0x02D0},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x0500},
+	{MISENSOR_16BIT,  0xC86A, 0x02D0},
+	{MISENSOR_16BIT,  0xC88C, 0x1E00},
+	{MISENSOR_16BIT,  0xC88E, 0x1E00},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x04FF},
+	{MISENSOR_16BIT,  0xC91A, 0x02CF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x00FF},
+	{MISENSOR_16BIT,  0xC922, 0x008F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_576p_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x4000},
+	{MISENSOR_16BIT,  0xC800, 0x007C},
+	{MISENSOR_16BIT,  0xC802, 0x0004},
+	{MISENSOR_16BIT,  0xC804, 0x0353},
+	{MISENSOR_16BIT,  0xC806, 0x050B},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x05BD},
+	{MISENSOR_16BIT,  0xC812, 0x03E8},
+	{MISENSOR_16BIT,  0xC814, 0x0640},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x02D3},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0500},
+	{MISENSOR_16BIT,  0xC85A, 0x02D0},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x0400},
+	{MISENSOR_16BIT,  0xC86A, 0x0240},
+	{MISENSOR_16BIT,  0xC88C, 0x1E00},
+	{MISENSOR_16BIT,  0xC88E, 0x1E00},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x03FF},
+	{MISENSOR_16BIT,  0xC91A, 0x023F},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x00CC},
+	{MISENSOR_16BIT,  0xC922, 0x0073},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_480p_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,  0xC800, 0x0054},
+	{MISENSOR_16BIT,  0xC802, 0x0004},
+	{MISENSOR_16BIT,  0xC804, 0x037B},
+	{MISENSOR_16BIT,  0xC806, 0x050B},
+	{MISENSOR_32BIT,  0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,  0xC80C, 0x0001},
+	{MISENSOR_16BIT,  0xC80E, 0x00DB},
+	{MISENSOR_16BIT,  0xC810, 0x05B1},
+	{MISENSOR_16BIT,  0xC812, 0x03EF},
+	{MISENSOR_16BIT,  0xC814, 0x0634},
+	{MISENSOR_16BIT,  0xC816, 0x0060},
+	{MISENSOR_16BIT,  0xC818, 0x0323},
+	{MISENSOR_16BIT,  0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT,  0xC854, 0x0000},
+	{MISENSOR_16BIT,  0xC856, 0x0000},
+	{MISENSOR_16BIT,  0xC858, 0x0500},
+	{MISENSOR_16BIT,  0xC85A, 0x0320},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,  0xC868, 0x0300},
+	{MISENSOR_16BIT,  0xC86A, 0x01E0},
+	{MISENSOR_16BIT,  0xC88C, 0x1E04},
+	{MISENSOR_16BIT,  0xC88E, 0x1E04},
+	{MISENSOR_16BIT,  0xC914, 0x0000},
+	{MISENSOR_16BIT,  0xC916, 0x0000},
+	{MISENSOR_16BIT,  0xC918, 0x02FF},
+	{MISENSOR_16BIT,  0xC91A, 0x01DF},
+	{MISENSOR_16BIT,  0xC91C, 0x0000},
+	{MISENSOR_16BIT,  0xC91E, 0x0000},
+	{MISENSOR_16BIT,  0xC920, 0x0098},
+	{MISENSOR_16BIT,  0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_vga_init[] = {
+
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_16BIT,   0xC800, 0x0000},
+	{MISENSOR_16BIT,   0xC802, 0x0000},
+	{MISENSOR_16BIT,   0xC804, 0x03CD},
+	{MISENSOR_16BIT,   0xC806, 0x050D},
+	{MISENSOR_32BIT,   0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT,   0xC80C, 0x0001},
+	{MISENSOR_16BIT,   0xC80E, 0x01C3},
+	{MISENSOR_16BIT,   0xC810, 0x03B3},
+	{MISENSOR_16BIT,   0xC812, 0x0549},
+	{MISENSOR_16BIT,   0xC814, 0x049E},
+	{MISENSOR_16BIT,   0xC816, 0x00E0},
+	{MISENSOR_16BIT,   0xC818, 0x01E3},
+	{MISENSOR_16BIT,   0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0x33},
+	{MISENSOR_16BIT,   0xC854, 0x0000},
+	{MISENSOR_16BIT,   0xC856, 0x0000},
+	{MISENSOR_16BIT,   0xC858, 0x0280},
+	{MISENSOR_16BIT,   0xC85A, 0x01E0},
+	{MISENSOR_8BIT,   0xC85C, 0x03},
+	{MISENSOR_16BIT,   0xC868, 0x0280},
+	{MISENSOR_16BIT,   0xC86A, 0x01E0},
+	{MISENSOR_8BIT,   0xC878, 0x0E},
+	{MISENSOR_16BIT,   0xC88C, 0x1E04},
+	{MISENSOR_16BIT,   0xC88E, 0x1E04},
+	{MISENSOR_16BIT,   0xC914, 0x0000},
+	{MISENSOR_16BIT,   0xC916, 0x0000},
+	{MISENSOR_16BIT,   0xC918, 0x027F},
+	{MISENSOR_16BIT,   0xC91A, 0x01DF},
+	{MISENSOR_16BIT,   0xC91C, 0x0000},
+	{MISENSOR_16BIT,   0xC91E, 0x0000},
+	{MISENSOR_16BIT,   0xC920, 0x007F},
+	{MISENSOR_16BIT,   0xC922, 0x005F},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_960P_init[] = {
+	{MISENSOR_16BIT, 0x98E, 0x1000},
+	{MISENSOR_16BIT, 0xC800, 0x0004},
+	{MISENSOR_16BIT, 0xC802, 0x0004},
+	{MISENSOR_16BIT, 0xC804, 0x03CB},
+	{MISENSOR_16BIT, 0xC806, 0x050B},
+	{MISENSOR_32BIT, 0xC808, 0x2DC6C00},
+	{MISENSOR_16BIT, 0xC80C, 0x0001},
+	{MISENSOR_16BIT, 0xC80E, 0x00DB},
+	{MISENSOR_16BIT, 0xC810, 0x062E},
+	{MISENSOR_16BIT, 0xC812, 0x074C},
+	{MISENSOR_16BIT, 0xC814, 0x06B1},
+	{MISENSOR_16BIT, 0xC816, 0x0060},
+	{MISENSOR_16BIT, 0xC818, 0x03C3},
+	{MISENSOR_16BIT, 0xC826, 0x0020},
+	{MISENSOR_16BIT | MISENSOR_TOK_RMW, 0xC834, 0x0330, 0},
+	{MISENSOR_16BIT, 0xC854, 0x0000},
+	{MISENSOR_16BIT, 0xC856, 0x0000},
+	{MISENSOR_16BIT, 0xC858, 0x0500},
+	{MISENSOR_16BIT, 0xC85A, 0x03C0},
+	{MISENSOR_8BIT, 0xC85C, 0x03},
+	{MISENSOR_16BIT, 0xC868, 0x0500},
+	{MISENSOR_16BIT, 0xC86A, 0x03C0},
+	{MISENSOR_8BIT, 0xC878, 0x0E},
+	{MISENSOR_16BIT, 0xC88C, 0x0F00},
+	{MISENSOR_16BIT, 0xC88E, 0x0F00},
+	{MISENSOR_16BIT, 0xC914, 0x0000},
+	{MISENSOR_16BIT, 0xC916, 0x0000},
+	{MISENSOR_16BIT, 0xC918, 0x04FF},
+	{MISENSOR_16BIT, 0xC91A, 0x03BF},
+	{MISENSOR_16BIT, 0xC91C, 0x0000},
+	{MISENSOR_16BIT, 0xC91E, 0x0000},
+	{MISENSOR_16BIT, 0xC920, 0x00FF},
+	{MISENSOR_16BIT, 0xC922, 0x00BF},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+
+static struct misensor_reg const mt9m114_common[] = {
+	/* reset */
+	{MISENSOR_16BIT,  0x301A, 0x0234},
+	/* pll settings for MT9M114 */
+	{MISENSOR_16BIT,   0x98E, 0x1000},
+	{MISENSOR_8BIT,   0xC97E, 0x01},
+	{MISENSOR_16BIT,   0xC980, 0x0128},
+	{MISENSOR_16BIT,   0xC982, 0x0700},
+	/*MIPI settings for MT9M114*/
+	{MISENSOR_16BIT,  0xC984, 0x8041},
+	{MISENSOR_16BIT,  0xC988, 0x0F00},
+	{MISENSOR_16BIT,  0xC98A, 0x0B07},
+	{MISENSOR_16BIT,  0xC98C, 0x0D01},
+	{MISENSOR_16BIT,  0xC98E, 0x071D},
+	{MISENSOR_16BIT,  0xC990, 0x0006},
+	{MISENSOR_16BIT,  0xC992, 0x0A0C},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_antiflicker_50hz[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xC88B},
+	 {MISENSOR_8BIT,  0xC88B, 0x32},
+	 {MISENSOR_8BIT,  0xDC00, 0x28},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_antiflicker_60hz[] = {
+	 {MISENSOR_16BIT,  0x098E, 0xC88B},
+	 {MISENSOR_8BIT,  0xC88B, 0x3C},
+	 {MISENSOR_8BIT,  0xDC00, 0x28},
+	 {MISENSOR_16BIT,  0x0080, 0x8002},
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const mt9m114_iq[] = {
+	/* [Step3-Recommended] [Sensor optimization] */
+	{MISENSOR_16BIT,	0x316A, 0x8270},
+	{MISENSOR_16BIT,	0x316C, 0x8270},
+	{MISENSOR_16BIT,	0x3ED0, 0x2305},
+	{MISENSOR_16BIT,	0x3ED2, 0x77CF},
+	{MISENSOR_16BIT,	0x316E, 0x8202},
+	{MISENSOR_16BIT,	0x3180, 0x87FF},
+	{MISENSOR_16BIT,	0x30D4, 0x6080},
+	{MISENSOR_16BIT,	0xA802, 0x0008},
+
+	/* This register is from vender to avoid low light color noise */
+	{MISENSOR_16BIT,	0x31E0, 0x0001},
+
+	/* LOAD=Errata item 1 */
+	{MISENSOR_16BIT,	0x3E14, 0xFF39},
+
+	/* LOAD=Errata item 2 */
+	{MISENSOR_16BIT,	0x301A, 0x8234},
+
+	/*
+	 * LOAD=Errata item 3
+	 * LOAD=Patch 0202;
+	 * Feature Recommended; Black level correction fix
+	 */
+	{MISENSOR_16BIT,	0x0982, 0x0001},
+	{MISENSOR_16BIT,	0x098A, 0x5000},
+	{MISENSOR_16BIT,	0xD000, 0x70CF},
+	{MISENSOR_16BIT,	0xD002, 0xFFFF},
+	{MISENSOR_16BIT,	0xD004, 0xC5D4},
+	{MISENSOR_16BIT,	0xD006, 0x903A},
+	{MISENSOR_16BIT,	0xD008, 0x2144},
+	{MISENSOR_16BIT,	0xD00A, 0x0C00},
+	{MISENSOR_16BIT,	0xD00C, 0x2186},
+	{MISENSOR_16BIT,	0xD00E, 0x0FF3},
+	{MISENSOR_16BIT,	0xD010, 0xB844},
+	{MISENSOR_16BIT,	0xD012, 0xB948},
+	{MISENSOR_16BIT,	0xD014, 0xE082},
+	{MISENSOR_16BIT,	0xD016, 0x20CC},
+	{MISENSOR_16BIT,	0xD018, 0x80E2},
+	{MISENSOR_16BIT,	0xD01A, 0x21CC},
+	{MISENSOR_16BIT,	0xD01C, 0x80A2},
+	{MISENSOR_16BIT,	0xD01E, 0x21CC},
+	{MISENSOR_16BIT,	0xD020, 0x80E2},
+	{MISENSOR_16BIT,	0xD022, 0xF404},
+	{MISENSOR_16BIT,	0xD024, 0xD801},
+	{MISENSOR_16BIT,	0xD026, 0xF003},
+	{MISENSOR_16BIT,	0xD028, 0xD800},
+	{MISENSOR_16BIT,	0xD02A, 0x7EE0},
+	{MISENSOR_16BIT,	0xD02C, 0xC0F1},
+	{MISENSOR_16BIT,	0xD02E, 0x08BA},
+
+	{MISENSOR_16BIT,	0xD030, 0x0600},
+	{MISENSOR_16BIT,	0xD032, 0xC1A1},
+	{MISENSOR_16BIT,	0xD034, 0x76CF},
+	{MISENSOR_16BIT,	0xD036, 0xFFFF},
+	{MISENSOR_16BIT,	0xD038, 0xC130},
+	{MISENSOR_16BIT,	0xD03A, 0x6E04},
+	{MISENSOR_16BIT,	0xD03C, 0xC040},
+	{MISENSOR_16BIT,	0xD03E, 0x71CF},
+	{MISENSOR_16BIT,	0xD040, 0xFFFF},
+	{MISENSOR_16BIT,	0xD042, 0xC790},
+	{MISENSOR_16BIT,	0xD044, 0x8103},
+	{MISENSOR_16BIT,	0xD046, 0x77CF},
+	{MISENSOR_16BIT,	0xD048, 0xFFFF},
+	{MISENSOR_16BIT,	0xD04A, 0xC7C0},
+	{MISENSOR_16BIT,	0xD04C, 0xE001},
+	{MISENSOR_16BIT,	0xD04E, 0xA103},
+	{MISENSOR_16BIT,	0xD050, 0xD800},
+	{MISENSOR_16BIT,	0xD052, 0x0C6A},
+	{MISENSOR_16BIT,	0xD054, 0x04E0},
+	{MISENSOR_16BIT,	0xD056, 0xB89E},
+	{MISENSOR_16BIT,	0xD058, 0x7508},
+	{MISENSOR_16BIT,	0xD05A, 0x8E1C},
+	{MISENSOR_16BIT,	0xD05C, 0x0809},
+	{MISENSOR_16BIT,	0xD05E, 0x0191},
+
+	{MISENSOR_16BIT,	0xD060, 0xD801},
+	{MISENSOR_16BIT,	0xD062, 0xAE1D},
+	{MISENSOR_16BIT,	0xD064, 0xE580},
+	{MISENSOR_16BIT,	0xD066, 0x20CA},
+	{MISENSOR_16BIT,	0xD068, 0x0022},
+	{MISENSOR_16BIT,	0xD06A, 0x20CF},
+	{MISENSOR_16BIT,	0xD06C, 0x0522},
+	{MISENSOR_16BIT,	0xD06E, 0x0C5C},
+	{MISENSOR_16BIT,	0xD070, 0x04E2},
+	{MISENSOR_16BIT,	0xD072, 0x21CA},
+	{MISENSOR_16BIT,	0xD074, 0x0062},
+	{MISENSOR_16BIT,	0xD076, 0xE580},
+	{MISENSOR_16BIT,	0xD078, 0xD901},
+	{MISENSOR_16BIT,	0xD07A, 0x79C0},
+	{MISENSOR_16BIT,	0xD07C, 0xD800},
+	{MISENSOR_16BIT,	0xD07E, 0x0BE6},
+	{MISENSOR_16BIT,	0xD080, 0x04E0},
+	{MISENSOR_16BIT,	0xD082, 0xB89E},
+	{MISENSOR_16BIT,	0xD084, 0x70CF},
+	{MISENSOR_16BIT,	0xD086, 0xFFFF},
+	{MISENSOR_16BIT,	0xD088, 0xC8D4},
+	{MISENSOR_16BIT,	0xD08A, 0x9002},
+	{MISENSOR_16BIT,	0xD08C, 0x0857},
+	{MISENSOR_16BIT,	0xD08E, 0x025E},
+
+	{MISENSOR_16BIT,	0xD090, 0xFFDC},
+	{MISENSOR_16BIT,	0xD092, 0xE080},
+	{MISENSOR_16BIT,	0xD094, 0x25CC},
+	{MISENSOR_16BIT,	0xD096, 0x9022},
+	{MISENSOR_16BIT,	0xD098, 0xF225},
+	{MISENSOR_16BIT,	0xD09A, 0x1700},
+	{MISENSOR_16BIT,	0xD09C, 0x108A},
+	{MISENSOR_16BIT,	0xD09E, 0x73CF},
+	{MISENSOR_16BIT,	0xD0A0, 0xFF00},
+	{MISENSOR_16BIT,	0xD0A2, 0x3174},
+	{MISENSOR_16BIT,	0xD0A4, 0x9307},
+	{MISENSOR_16BIT,	0xD0A6, 0x2A04},
+	{MISENSOR_16BIT,	0xD0A8, 0x103E},
+	{MISENSOR_16BIT,	0xD0AA, 0x9328},
+	{MISENSOR_16BIT,	0xD0AC, 0x2942},
+	{MISENSOR_16BIT,	0xD0AE, 0x7140},
+	{MISENSOR_16BIT,	0xD0B0, 0x2A04},
+	{MISENSOR_16BIT,	0xD0B2, 0x107E},
+	{MISENSOR_16BIT,	0xD0B4, 0x9349},
+	{MISENSOR_16BIT,	0xD0B6, 0x2942},
+	{MISENSOR_16BIT,	0xD0B8, 0x7141},
+	{MISENSOR_16BIT,	0xD0BA, 0x2A04},
+	{MISENSOR_16BIT,	0xD0BC, 0x10BE},
+	{MISENSOR_16BIT,	0xD0BE, 0x934A},
+
+	{MISENSOR_16BIT,	0xD0C0, 0x2942},
+	{MISENSOR_16BIT,	0xD0C2, 0x714B},
+	{MISENSOR_16BIT,	0xD0C4, 0x2A04},
+	{MISENSOR_16BIT,	0xD0C6, 0x10BE},
+	{MISENSOR_16BIT,	0xD0C8, 0x130C},
+	{MISENSOR_16BIT,	0xD0CA, 0x010A},
+	{MISENSOR_16BIT,	0xD0CC, 0x2942},
+	{MISENSOR_16BIT,	0xD0CE, 0x7142},
+	{MISENSOR_16BIT,	0xD0D0, 0x2250},
+	{MISENSOR_16BIT,	0xD0D2, 0x13CA},
+	{MISENSOR_16BIT,	0xD0D4, 0x1B0C},
+	{MISENSOR_16BIT,	0xD0D6, 0x0284},
+	{MISENSOR_16BIT,	0xD0D8, 0xB307},
+	{MISENSOR_16BIT,	0xD0DA, 0xB328},
+	{MISENSOR_16BIT,	0xD0DC, 0x1B12},
+	{MISENSOR_16BIT,	0xD0DE, 0x02C4},
+	{MISENSOR_16BIT,	0xD0E0, 0xB34A},
+	{MISENSOR_16BIT,	0xD0E2, 0xED88},
+	{MISENSOR_16BIT,	0xD0E4, 0x71CF},
+	{MISENSOR_16BIT,	0xD0E6, 0xFF00},
+	{MISENSOR_16BIT,	0xD0E8, 0x3174},
+	{MISENSOR_16BIT,	0xD0EA, 0x9106},
+	{MISENSOR_16BIT,	0xD0EC, 0xB88F},
+	{MISENSOR_16BIT,	0xD0EE, 0xB106},
+
+	{MISENSOR_16BIT,	0xD0F0, 0x210A},
+	{MISENSOR_16BIT,	0xD0F2, 0x8340},
+	{MISENSOR_16BIT,	0xD0F4, 0xC000},
+	{MISENSOR_16BIT,	0xD0F6, 0x21CA},
+	{MISENSOR_16BIT,	0xD0F8, 0x0062},
+	{MISENSOR_16BIT,	0xD0FA, 0x20F0},
+	{MISENSOR_16BIT,	0xD0FC, 0x0040},
+	{MISENSOR_16BIT,	0xD0FE, 0x0B02},
+	{MISENSOR_16BIT,	0xD100, 0x0320},
+	{MISENSOR_16BIT,	0xD102, 0xD901},
+	{MISENSOR_16BIT,	0xD104, 0x07F1},
+	{MISENSOR_16BIT,	0xD106, 0x05E0},
+	{MISENSOR_16BIT,	0xD108, 0xC0A1},
+	{MISENSOR_16BIT,	0xD10A, 0x78E0},
+	{MISENSOR_16BIT,	0xD10C, 0xC0F1},
+	{MISENSOR_16BIT,	0xD10E, 0x71CF},
+	{MISENSOR_16BIT,	0xD110, 0xFFFF},
+	{MISENSOR_16BIT,	0xD112, 0xC7C0},
+	{MISENSOR_16BIT,	0xD114, 0xD840},
+	{MISENSOR_16BIT,	0xD116, 0xA900},
+	{MISENSOR_16BIT,	0xD118, 0x71CF},
+	{MISENSOR_16BIT,	0xD11A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD11C, 0xD02C},
+	{MISENSOR_16BIT,	0xD11E, 0xD81E},
+
+	{MISENSOR_16BIT,	0xD120, 0x0A5A},
+	{MISENSOR_16BIT,	0xD122, 0x04E0},
+	{MISENSOR_16BIT,	0xD124, 0xDA00},
+	{MISENSOR_16BIT,	0xD126, 0xD800},
+	{MISENSOR_16BIT,	0xD128, 0xC0D1},
+	{MISENSOR_16BIT,	0xD12A, 0x7EE0},
+
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xE000, 0x010C},
+	{MISENSOR_16BIT,	0xE002, 0x0202},
+	{MISENSOR_16BIT,	0xE004, 0x4103},
+	{MISENSOR_16BIT,	0xE006, 0x0202},
+	{MISENSOR_16BIT,	0x0080, 0xFFF0},
+	{MISENSOR_16BIT,	0x0080, 0xFFF1},
+
+	/* LOAD=Patch 0302; Feature Recommended; Adaptive Sensitivity */
+	{MISENSOR_16BIT,	0x0982, 0x0001},
+	{MISENSOR_16BIT,	0x098A, 0x512C},
+	{MISENSOR_16BIT,	0xD12C, 0x70CF},
+	{MISENSOR_16BIT,	0xD12E, 0xFFFF},
+	{MISENSOR_16BIT,	0xD130, 0xC5D4},
+	{MISENSOR_16BIT,	0xD132, 0x903A},
+	{MISENSOR_16BIT,	0xD134, 0x2144},
+	{MISENSOR_16BIT,	0xD136, 0x0C00},
+	{MISENSOR_16BIT,	0xD138, 0x2186},
+	{MISENSOR_16BIT,	0xD13A, 0x0FF3},
+	{MISENSOR_16BIT,	0xD13C, 0xB844},
+	{MISENSOR_16BIT,	0xD13E, 0x262F},
+	{MISENSOR_16BIT,	0xD140, 0xF008},
+	{MISENSOR_16BIT,	0xD142, 0xB948},
+	{MISENSOR_16BIT,	0xD144, 0x21CC},
+	{MISENSOR_16BIT,	0xD146, 0x8021},
+	{MISENSOR_16BIT,	0xD148, 0xD801},
+	{MISENSOR_16BIT,	0xD14A, 0xF203},
+	{MISENSOR_16BIT,	0xD14C, 0xD800},
+	{MISENSOR_16BIT,	0xD14E, 0x7EE0},
+	{MISENSOR_16BIT,	0xD150, 0xC0F1},
+	{MISENSOR_16BIT,	0xD152, 0x71CF},
+	{MISENSOR_16BIT,	0xD154, 0xFFFF},
+	{MISENSOR_16BIT,	0xD156, 0xC610},
+	{MISENSOR_16BIT,	0xD158, 0x910E},
+	{MISENSOR_16BIT,	0xD15A, 0x208C},
+	{MISENSOR_16BIT,	0xD15C, 0x8014},
+	{MISENSOR_16BIT,	0xD15E, 0xF418},
+	{MISENSOR_16BIT,	0xD160, 0x910F},
+	{MISENSOR_16BIT,	0xD162, 0x208C},
+	{MISENSOR_16BIT,	0xD164, 0x800F},
+	{MISENSOR_16BIT,	0xD166, 0xF414},
+	{MISENSOR_16BIT,	0xD168, 0x9116},
+	{MISENSOR_16BIT,	0xD16A, 0x208C},
+	{MISENSOR_16BIT,	0xD16C, 0x800A},
+	{MISENSOR_16BIT,	0xD16E, 0xF410},
+	{MISENSOR_16BIT,	0xD170, 0x9117},
+	{MISENSOR_16BIT,	0xD172, 0x208C},
+	{MISENSOR_16BIT,	0xD174, 0x8807},
+	{MISENSOR_16BIT,	0xD176, 0xF40C},
+	{MISENSOR_16BIT,	0xD178, 0x9118},
+	{MISENSOR_16BIT,	0xD17A, 0x2086},
+	{MISENSOR_16BIT,	0xD17C, 0x0FF3},
+	{MISENSOR_16BIT,	0xD17E, 0xB848},
+	{MISENSOR_16BIT,	0xD180, 0x080D},
+	{MISENSOR_16BIT,	0xD182, 0x0090},
+	{MISENSOR_16BIT,	0xD184, 0xFFEA},
+	{MISENSOR_16BIT,	0xD186, 0xE081},
+	{MISENSOR_16BIT,	0xD188, 0xD801},
+	{MISENSOR_16BIT,	0xD18A, 0xF203},
+	{MISENSOR_16BIT,	0xD18C, 0xD800},
+	{MISENSOR_16BIT,	0xD18E, 0xC0D1},
+	{MISENSOR_16BIT,	0xD190, 0x7EE0},
+	{MISENSOR_16BIT,	0xD192, 0x78E0},
+	{MISENSOR_16BIT,	0xD194, 0xC0F1},
+	{MISENSOR_16BIT,	0xD196, 0x71CF},
+	{MISENSOR_16BIT,	0xD198, 0xFFFF},
+	{MISENSOR_16BIT,	0xD19A, 0xC610},
+	{MISENSOR_16BIT,	0xD19C, 0x910E},
+	{MISENSOR_16BIT,	0xD19E, 0x208C},
+	{MISENSOR_16BIT,	0xD1A0, 0x800A},
+	{MISENSOR_16BIT,	0xD1A2, 0xF418},
+	{MISENSOR_16BIT,	0xD1A4, 0x910F},
+	{MISENSOR_16BIT,	0xD1A6, 0x208C},
+	{MISENSOR_16BIT,	0xD1A8, 0x8807},
+	{MISENSOR_16BIT,	0xD1AA, 0xF414},
+	{MISENSOR_16BIT,	0xD1AC, 0x9116},
+	{MISENSOR_16BIT,	0xD1AE, 0x208C},
+	{MISENSOR_16BIT,	0xD1B0, 0x800A},
+	{MISENSOR_16BIT,	0xD1B2, 0xF410},
+	{MISENSOR_16BIT,	0xD1B4, 0x9117},
+	{MISENSOR_16BIT,	0xD1B6, 0x208C},
+	{MISENSOR_16BIT,	0xD1B8, 0x8807},
+	{MISENSOR_16BIT,	0xD1BA, 0xF40C},
+	{MISENSOR_16BIT,	0xD1BC, 0x9118},
+	{MISENSOR_16BIT,	0xD1BE, 0x2086},
+	{MISENSOR_16BIT,	0xD1C0, 0x0FF3},
+	{MISENSOR_16BIT,	0xD1C2, 0xB848},
+	{MISENSOR_16BIT,	0xD1C4, 0x080D},
+	{MISENSOR_16BIT,	0xD1C6, 0x0090},
+	{MISENSOR_16BIT,	0xD1C8, 0xFFD9},
+	{MISENSOR_16BIT,	0xD1CA, 0xE080},
+	{MISENSOR_16BIT,	0xD1CC, 0xD801},
+	{MISENSOR_16BIT,	0xD1CE, 0xF203},
+	{MISENSOR_16BIT,	0xD1D0, 0xD800},
+	{MISENSOR_16BIT,	0xD1D2, 0xF1DF},
+	{MISENSOR_16BIT,	0xD1D4, 0x9040},
+	{MISENSOR_16BIT,	0xD1D6, 0x71CF},
+	{MISENSOR_16BIT,	0xD1D8, 0xFFFF},
+	{MISENSOR_16BIT,	0xD1DA, 0xC5D4},
+	{MISENSOR_16BIT,	0xD1DC, 0xB15A},
+	{MISENSOR_16BIT,	0xD1DE, 0x9041},
+	{MISENSOR_16BIT,	0xD1E0, 0x73CF},
+	{MISENSOR_16BIT,	0xD1E2, 0xFFFF},
+	{MISENSOR_16BIT,	0xD1E4, 0xC7D0},
+	{MISENSOR_16BIT,	0xD1E6, 0xB140},
+	{MISENSOR_16BIT,	0xD1E8, 0x9042},
+	{MISENSOR_16BIT,	0xD1EA, 0xB141},
+	{MISENSOR_16BIT,	0xD1EC, 0x9043},
+	{MISENSOR_16BIT,	0xD1EE, 0xB142},
+	{MISENSOR_16BIT,	0xD1F0, 0x9044},
+	{MISENSOR_16BIT,	0xD1F2, 0xB143},
+	{MISENSOR_16BIT,	0xD1F4, 0x9045},
+	{MISENSOR_16BIT,	0xD1F6, 0xB147},
+	{MISENSOR_16BIT,	0xD1F8, 0x9046},
+	{MISENSOR_16BIT,	0xD1FA, 0xB148},
+	{MISENSOR_16BIT,	0xD1FC, 0x9047},
+	{MISENSOR_16BIT,	0xD1FE, 0xB14B},
+	{MISENSOR_16BIT,	0xD200, 0x9048},
+	{MISENSOR_16BIT,	0xD202, 0xB14C},
+	{MISENSOR_16BIT,	0xD204, 0x9049},
+	{MISENSOR_16BIT,	0xD206, 0x1958},
+	{MISENSOR_16BIT,	0xD208, 0x0084},
+	{MISENSOR_16BIT,	0xD20A, 0x904A},
+	{MISENSOR_16BIT,	0xD20C, 0x195A},
+	{MISENSOR_16BIT,	0xD20E, 0x0084},
+	{MISENSOR_16BIT,	0xD210, 0x8856},
+	{MISENSOR_16BIT,	0xD212, 0x1B36},
+	{MISENSOR_16BIT,	0xD214, 0x8082},
+	{MISENSOR_16BIT,	0xD216, 0x8857},
+	{MISENSOR_16BIT,	0xD218, 0x1B37},
+	{MISENSOR_16BIT,	0xD21A, 0x8082},
+	{MISENSOR_16BIT,	0xD21C, 0x904C},
+	{MISENSOR_16BIT,	0xD21E, 0x19A7},
+	{MISENSOR_16BIT,	0xD220, 0x009C},
+	{MISENSOR_16BIT,	0xD222, 0x881A},
+	{MISENSOR_16BIT,	0xD224, 0x7FE0},
+	{MISENSOR_16BIT,	0xD226, 0x1B54},
+	{MISENSOR_16BIT,	0xD228, 0x8002},
+	{MISENSOR_16BIT,	0xD22A, 0x78E0},
+	{MISENSOR_16BIT,	0xD22C, 0x71CF},
+	{MISENSOR_16BIT,	0xD22E, 0xFFFF},
+	{MISENSOR_16BIT,	0xD230, 0xC350},
+	{MISENSOR_16BIT,	0xD232, 0xD828},
+	{MISENSOR_16BIT,	0xD234, 0xA90B},
+	{MISENSOR_16BIT,	0xD236, 0x8100},
+	{MISENSOR_16BIT,	0xD238, 0x01C5},
+	{MISENSOR_16BIT,	0xD23A, 0x0320},
+	{MISENSOR_16BIT,	0xD23C, 0xD900},
+	{MISENSOR_16BIT,	0xD23E, 0x78E0},
+	{MISENSOR_16BIT,	0xD240, 0x220A},
+	{MISENSOR_16BIT,	0xD242, 0x1F80},
+	{MISENSOR_16BIT,	0xD244, 0xFFFF},
+	{MISENSOR_16BIT,	0xD246, 0xD4E0},
+	{MISENSOR_16BIT,	0xD248, 0xC0F1},
+	{MISENSOR_16BIT,	0xD24A, 0x0811},
+	{MISENSOR_16BIT,	0xD24C, 0x0051},
+	{MISENSOR_16BIT,	0xD24E, 0x2240},
+	{MISENSOR_16BIT,	0xD250, 0x1200},
+	{MISENSOR_16BIT,	0xD252, 0xFFE1},
+	{MISENSOR_16BIT,	0xD254, 0xD801},
+	{MISENSOR_16BIT,	0xD256, 0xF006},
+	{MISENSOR_16BIT,	0xD258, 0x2240},
+	{MISENSOR_16BIT,	0xD25A, 0x1900},
+	{MISENSOR_16BIT,	0xD25C, 0xFFDE},
+	{MISENSOR_16BIT,	0xD25E, 0xD802},
+	{MISENSOR_16BIT,	0xD260, 0x1A05},
+	{MISENSOR_16BIT,	0xD262, 0x1002},
+	{MISENSOR_16BIT,	0xD264, 0xFFF2},
+	{MISENSOR_16BIT,	0xD266, 0xF195},
+	{MISENSOR_16BIT,	0xD268, 0xC0F1},
+	{MISENSOR_16BIT,	0xD26A, 0x0E7E},
+	{MISENSOR_16BIT,	0xD26C, 0x05C0},
+	{MISENSOR_16BIT,	0xD26E, 0x75CF},
+	{MISENSOR_16BIT,	0xD270, 0xFFFF},
+	{MISENSOR_16BIT,	0xD272, 0xC84C},
+	{MISENSOR_16BIT,	0xD274, 0x9502},
+	{MISENSOR_16BIT,	0xD276, 0x77CF},
+	{MISENSOR_16BIT,	0xD278, 0xFFFF},
+	{MISENSOR_16BIT,	0xD27A, 0xC344},
+	{MISENSOR_16BIT,	0xD27C, 0x2044},
+	{MISENSOR_16BIT,	0xD27E, 0x008E},
+	{MISENSOR_16BIT,	0xD280, 0xB8A1},
+	{MISENSOR_16BIT,	0xD282, 0x0926},
+	{MISENSOR_16BIT,	0xD284, 0x03E0},
+	{MISENSOR_16BIT,	0xD286, 0xB502},
+	{MISENSOR_16BIT,	0xD288, 0x9502},
+	{MISENSOR_16BIT,	0xD28A, 0x952E},
+	{MISENSOR_16BIT,	0xD28C, 0x7E05},
+	{MISENSOR_16BIT,	0xD28E, 0xB5C2},
+	{MISENSOR_16BIT,	0xD290, 0x70CF},
+	{MISENSOR_16BIT,	0xD292, 0xFFFF},
+	{MISENSOR_16BIT,	0xD294, 0xC610},
+	{MISENSOR_16BIT,	0xD296, 0x099A},
+	{MISENSOR_16BIT,	0xD298, 0x04A0},
+	{MISENSOR_16BIT,	0xD29A, 0xB026},
+	{MISENSOR_16BIT,	0xD29C, 0x0E02},
+	{MISENSOR_16BIT,	0xD29E, 0x0560},
+	{MISENSOR_16BIT,	0xD2A0, 0xDE00},
+	{MISENSOR_16BIT,	0xD2A2, 0x0A12},
+	{MISENSOR_16BIT,	0xD2A4, 0x0320},
+	{MISENSOR_16BIT,	0xD2A6, 0xB7C4},
+	{MISENSOR_16BIT,	0xD2A8, 0x0B36},
+	{MISENSOR_16BIT,	0xD2AA, 0x03A0},
+	{MISENSOR_16BIT,	0xD2AC, 0x70C9},
+	{MISENSOR_16BIT,	0xD2AE, 0x9502},
+	{MISENSOR_16BIT,	0xD2B0, 0x7608},
+	{MISENSOR_16BIT,	0xD2B2, 0xB8A8},
+	{MISENSOR_16BIT,	0xD2B4, 0xB502},
+	{MISENSOR_16BIT,	0xD2B6, 0x70CF},
+	{MISENSOR_16BIT,	0xD2B8, 0x0000},
+	{MISENSOR_16BIT,	0xD2BA, 0x5536},
+	{MISENSOR_16BIT,	0xD2BC, 0x7860},
+	{MISENSOR_16BIT,	0xD2BE, 0x2686},
+	{MISENSOR_16BIT,	0xD2C0, 0x1FFB},
+	{MISENSOR_16BIT,	0xD2C2, 0x9502},
+	{MISENSOR_16BIT,	0xD2C4, 0x78C5},
+	{MISENSOR_16BIT,	0xD2C6, 0x0631},
+	{MISENSOR_16BIT,	0xD2C8, 0x05E0},
+	{MISENSOR_16BIT,	0xD2CA, 0xB502},
+	{MISENSOR_16BIT,	0xD2CC, 0x72CF},
+	{MISENSOR_16BIT,	0xD2CE, 0xFFFF},
+	{MISENSOR_16BIT,	0xD2D0, 0xC5D4},
+	{MISENSOR_16BIT,	0xD2D2, 0x923A},
+	{MISENSOR_16BIT,	0xD2D4, 0x73CF},
+	{MISENSOR_16BIT,	0xD2D6, 0xFFFF},
+	{MISENSOR_16BIT,	0xD2D8, 0xC7D0},
+	{MISENSOR_16BIT,	0xD2DA, 0xB020},
+	{MISENSOR_16BIT,	0xD2DC, 0x9220},
+	{MISENSOR_16BIT,	0xD2DE, 0xB021},
+	{MISENSOR_16BIT,	0xD2E0, 0x9221},
+	{MISENSOR_16BIT,	0xD2E2, 0xB022},
+	{MISENSOR_16BIT,	0xD2E4, 0x9222},
+	{MISENSOR_16BIT,	0xD2E6, 0xB023},
+	{MISENSOR_16BIT,	0xD2E8, 0x9223},
+	{MISENSOR_16BIT,	0xD2EA, 0xB024},
+	{MISENSOR_16BIT,	0xD2EC, 0x9227},
+	{MISENSOR_16BIT,	0xD2EE, 0xB025},
+	{MISENSOR_16BIT,	0xD2F0, 0x9228},
+	{MISENSOR_16BIT,	0xD2F2, 0xB026},
+	{MISENSOR_16BIT,	0xD2F4, 0x922B},
+	{MISENSOR_16BIT,	0xD2F6, 0xB027},
+	{MISENSOR_16BIT,	0xD2F8, 0x922C},
+	{MISENSOR_16BIT,	0xD2FA, 0xB028},
+	{MISENSOR_16BIT,	0xD2FC, 0x1258},
+	{MISENSOR_16BIT,	0xD2FE, 0x0101},
+	{MISENSOR_16BIT,	0xD300, 0xB029},
+	{MISENSOR_16BIT,	0xD302, 0x125A},
+	{MISENSOR_16BIT,	0xD304, 0x0101},
+	{MISENSOR_16BIT,	0xD306, 0xB02A},
+	{MISENSOR_16BIT,	0xD308, 0x1336},
+	{MISENSOR_16BIT,	0xD30A, 0x8081},
+	{MISENSOR_16BIT,	0xD30C, 0xA836},
+	{MISENSOR_16BIT,	0xD30E, 0x1337},
+	{MISENSOR_16BIT,	0xD310, 0x8081},
+	{MISENSOR_16BIT,	0xD312, 0xA837},
+	{MISENSOR_16BIT,	0xD314, 0x12A7},
+	{MISENSOR_16BIT,	0xD316, 0x0701},
+	{MISENSOR_16BIT,	0xD318, 0xB02C},
+	{MISENSOR_16BIT,	0xD31A, 0x1354},
+	{MISENSOR_16BIT,	0xD31C, 0x8081},
+	{MISENSOR_16BIT,	0xD31E, 0x7FE0},
+	{MISENSOR_16BIT,	0xD320, 0xA83A},
+	{MISENSOR_16BIT,	0xD322, 0x78E0},
+	{MISENSOR_16BIT,	0xD324, 0xC0F1},
+	{MISENSOR_16BIT,	0xD326, 0x0DC2},
+	{MISENSOR_16BIT,	0xD328, 0x05C0},
+	{MISENSOR_16BIT,	0xD32A, 0x7608},
+	{MISENSOR_16BIT,	0xD32C, 0x09BB},
+	{MISENSOR_16BIT,	0xD32E, 0x0010},
+	{MISENSOR_16BIT,	0xD330, 0x75CF},
+	{MISENSOR_16BIT,	0xD332, 0xFFFF},
+	{MISENSOR_16BIT,	0xD334, 0xD4E0},
+	{MISENSOR_16BIT,	0xD336, 0x8D21},
+	{MISENSOR_16BIT,	0xD338, 0x8D00},
+	{MISENSOR_16BIT,	0xD33A, 0x2153},
+	{MISENSOR_16BIT,	0xD33C, 0x0003},
+	{MISENSOR_16BIT,	0xD33E, 0xB8C0},
+	{MISENSOR_16BIT,	0xD340, 0x8D45},
+	{MISENSOR_16BIT,	0xD342, 0x0B23},
+	{MISENSOR_16BIT,	0xD344, 0x0000},
+	{MISENSOR_16BIT,	0xD346, 0xEA8F},
+	{MISENSOR_16BIT,	0xD348, 0x0915},
+	{MISENSOR_16BIT,	0xD34A, 0x001E},
+	{MISENSOR_16BIT,	0xD34C, 0xFF81},
+	{MISENSOR_16BIT,	0xD34E, 0xE808},
+	{MISENSOR_16BIT,	0xD350, 0x2540},
+	{MISENSOR_16BIT,	0xD352, 0x1900},
+	{MISENSOR_16BIT,	0xD354, 0xFFDE},
+	{MISENSOR_16BIT,	0xD356, 0x8D00},
+	{MISENSOR_16BIT,	0xD358, 0xB880},
+	{MISENSOR_16BIT,	0xD35A, 0xF004},
+	{MISENSOR_16BIT,	0xD35C, 0x8D00},
+	{MISENSOR_16BIT,	0xD35E, 0xB8A0},
+	{MISENSOR_16BIT,	0xD360, 0xAD00},
+	{MISENSOR_16BIT,	0xD362, 0x8D05},
+	{MISENSOR_16BIT,	0xD364, 0xE081},
+	{MISENSOR_16BIT,	0xD366, 0x20CC},
+	{MISENSOR_16BIT,	0xD368, 0x80A2},
+	{MISENSOR_16BIT,	0xD36A, 0xDF00},
+	{MISENSOR_16BIT,	0xD36C, 0xF40A},
+	{MISENSOR_16BIT,	0xD36E, 0x71CF},
+	{MISENSOR_16BIT,	0xD370, 0xFFFF},
+	{MISENSOR_16BIT,	0xD372, 0xC84C},
+	{MISENSOR_16BIT,	0xD374, 0x9102},
+	{MISENSOR_16BIT,	0xD376, 0x7708},
+	{MISENSOR_16BIT,	0xD378, 0xB8A6},
+	{MISENSOR_16BIT,	0xD37A, 0x2786},
+	{MISENSOR_16BIT,	0xD37C, 0x1FFE},
+	{MISENSOR_16BIT,	0xD37E, 0xB102},
+	{MISENSOR_16BIT,	0xD380, 0x0B42},
+	{MISENSOR_16BIT,	0xD382, 0x0180},
+	{MISENSOR_16BIT,	0xD384, 0x0E3E},
+	{MISENSOR_16BIT,	0xD386, 0x0180},
+	{MISENSOR_16BIT,	0xD388, 0x0F4A},
+	{MISENSOR_16BIT,	0xD38A, 0x0160},
+	{MISENSOR_16BIT,	0xD38C, 0x70C9},
+	{MISENSOR_16BIT,	0xD38E, 0x8D05},
+	{MISENSOR_16BIT,	0xD390, 0xE081},
+	{MISENSOR_16BIT,	0xD392, 0x20CC},
+	{MISENSOR_16BIT,	0xD394, 0x80A2},
+	{MISENSOR_16BIT,	0xD396, 0xF429},
+	{MISENSOR_16BIT,	0xD398, 0x76CF},
+	{MISENSOR_16BIT,	0xD39A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD39C, 0xC84C},
+	{MISENSOR_16BIT,	0xD39E, 0x082D},
+	{MISENSOR_16BIT,	0xD3A0, 0x0051},
+	{MISENSOR_16BIT,	0xD3A2, 0x70CF},
+	{MISENSOR_16BIT,	0xD3A4, 0xFFFF},
+	{MISENSOR_16BIT,	0xD3A6, 0xC90C},
+	{MISENSOR_16BIT,	0xD3A8, 0x8805},
+	{MISENSOR_16BIT,	0xD3AA, 0x09B6},
+	{MISENSOR_16BIT,	0xD3AC, 0x0360},
+	{MISENSOR_16BIT,	0xD3AE, 0xD908},
+	{MISENSOR_16BIT,	0xD3B0, 0x2099},
+	{MISENSOR_16BIT,	0xD3B2, 0x0802},
+	{MISENSOR_16BIT,	0xD3B4, 0x9634},
+	{MISENSOR_16BIT,	0xD3B6, 0xB503},
+	{MISENSOR_16BIT,	0xD3B8, 0x7902},
+	{MISENSOR_16BIT,	0xD3BA, 0x1523},
+	{MISENSOR_16BIT,	0xD3BC, 0x1080},
+	{MISENSOR_16BIT,	0xD3BE, 0xB634},
+	{MISENSOR_16BIT,	0xD3C0, 0xE001},
+	{MISENSOR_16BIT,	0xD3C2, 0x1D23},
+	{MISENSOR_16BIT,	0xD3C4, 0x1002},
+	{MISENSOR_16BIT,	0xD3C6, 0xF00B},
+	{MISENSOR_16BIT,	0xD3C8, 0x9634},
+	{MISENSOR_16BIT,	0xD3CA, 0x9503},
+	{MISENSOR_16BIT,	0xD3CC, 0x6038},
+	{MISENSOR_16BIT,	0xD3CE, 0xB614},
+	{MISENSOR_16BIT,	0xD3D0, 0x153F},
+	{MISENSOR_16BIT,	0xD3D2, 0x1080},
+	{MISENSOR_16BIT,	0xD3D4, 0xE001},
+	{MISENSOR_16BIT,	0xD3D6, 0x1D3F},
+	{MISENSOR_16BIT,	0xD3D8, 0x1002},
+	{MISENSOR_16BIT,	0xD3DA, 0xFFA4},
+	{MISENSOR_16BIT,	0xD3DC, 0x9602},
+	{MISENSOR_16BIT,	0xD3DE, 0x7F05},
+	{MISENSOR_16BIT,	0xD3E0, 0xD800},
+	{MISENSOR_16BIT,	0xD3E2, 0xB6E2},
+	{MISENSOR_16BIT,	0xD3E4, 0xAD05},
+	{MISENSOR_16BIT,	0xD3E6, 0x0511},
+	{MISENSOR_16BIT,	0xD3E8, 0x05E0},
+	{MISENSOR_16BIT,	0xD3EA, 0xD800},
+	{MISENSOR_16BIT,	0xD3EC, 0xC0F1},
+	{MISENSOR_16BIT,	0xD3EE, 0x0CFE},
+	{MISENSOR_16BIT,	0xD3F0, 0x05C0},
+	{MISENSOR_16BIT,	0xD3F2, 0x0A96},
+	{MISENSOR_16BIT,	0xD3F4, 0x05A0},
+	{MISENSOR_16BIT,	0xD3F6, 0x7608},
+	{MISENSOR_16BIT,	0xD3F8, 0x0C22},
+	{MISENSOR_16BIT,	0xD3FA, 0x0240},
+	{MISENSOR_16BIT,	0xD3FC, 0xE080},
+	{MISENSOR_16BIT,	0xD3FE, 0x20CA},
+	{MISENSOR_16BIT,	0xD400, 0x0F82},
+	{MISENSOR_16BIT,	0xD402, 0x0000},
+	{MISENSOR_16BIT,	0xD404, 0x190B},
+	{MISENSOR_16BIT,	0xD406, 0x0C60},
+	{MISENSOR_16BIT,	0xD408, 0x05A2},
+	{MISENSOR_16BIT,	0xD40A, 0x21CA},
+	{MISENSOR_16BIT,	0xD40C, 0x0022},
+	{MISENSOR_16BIT,	0xD40E, 0x0C56},
+	{MISENSOR_16BIT,	0xD410, 0x0240},
+	{MISENSOR_16BIT,	0xD412, 0xE806},
+	{MISENSOR_16BIT,	0xD414, 0x0E0E},
+	{MISENSOR_16BIT,	0xD416, 0x0220},
+	{MISENSOR_16BIT,	0xD418, 0x70C9},
+	{MISENSOR_16BIT,	0xD41A, 0xF048},
+	{MISENSOR_16BIT,	0xD41C, 0x0896},
+	{MISENSOR_16BIT,	0xD41E, 0x0440},
+	{MISENSOR_16BIT,	0xD420, 0x0E96},
+	{MISENSOR_16BIT,	0xD422, 0x0400},
+	{MISENSOR_16BIT,	0xD424, 0x0966},
+	{MISENSOR_16BIT,	0xD426, 0x0380},
+	{MISENSOR_16BIT,	0xD428, 0x75CF},
+	{MISENSOR_16BIT,	0xD42A, 0xFFFF},
+	{MISENSOR_16BIT,	0xD42C, 0xD4E0},
+	{MISENSOR_16BIT,	0xD42E, 0x8D00},
+	{MISENSOR_16BIT,	0xD430, 0x084D},
+	{MISENSOR_16BIT,	0xD432, 0x001E},
+	{MISENSOR_16BIT,	0xD434, 0xFF47},
+	{MISENSOR_16BIT,	0xD436, 0x080D},
+	{MISENSOR_16BIT,	0xD438, 0x0050},
+	{MISENSOR_16BIT,	0xD43A, 0xFF57},
+	{MISENSOR_16BIT,	0xD43C, 0x0841},
+	{MISENSOR_16BIT,	0xD43E, 0x0051},
+	{MISENSOR_16BIT,	0xD440, 0x8D04},
+	{MISENSOR_16BIT,	0xD442, 0x9521},
+	{MISENSOR_16BIT,	0xD444, 0xE064},
+	{MISENSOR_16BIT,	0xD446, 0x790C},
+	{MISENSOR_16BIT,	0xD448, 0x702F},
+	{MISENSOR_16BIT,	0xD44A, 0x0CE2},
+	{MISENSOR_16BIT,	0xD44C, 0x05E0},
+	{MISENSOR_16BIT,	0xD44E, 0xD964},
+	{MISENSOR_16BIT,	0xD450, 0x72CF},
+	{MISENSOR_16BIT,	0xD452, 0xFFFF},
+	{MISENSOR_16BIT,	0xD454, 0xC700},
+	{MISENSOR_16BIT,	0xD456, 0x9235},
+	{MISENSOR_16BIT,	0xD458, 0x0811},
+	{MISENSOR_16BIT,	0xD45A, 0x0043},
+	{MISENSOR_16BIT,	0xD45C, 0xFF3D},
+	{MISENSOR_16BIT,	0xD45E, 0x080D},
+	{MISENSOR_16BIT,	0xD460, 0x0051},
+	{MISENSOR_16BIT,	0xD462, 0xD801},
+	{MISENSOR_16BIT,	0xD464, 0xFF77},
+	{MISENSOR_16BIT,	0xD466, 0xF025},
+	{MISENSOR_16BIT,	0xD468, 0x9501},
+	{MISENSOR_16BIT,	0xD46A, 0x9235},
+	{MISENSOR_16BIT,	0xD46C, 0x0911},
+	{MISENSOR_16BIT,	0xD46E, 0x0003},
+	{MISENSOR_16BIT,	0xD470, 0xFF49},
+	{MISENSOR_16BIT,	0xD472, 0x080D},
+	{MISENSOR_16BIT,	0xD474, 0x0051},
+	{MISENSOR_16BIT,	0xD476, 0xD800},
+	{MISENSOR_16BIT,	0xD478, 0xFF72},
+	{MISENSOR_16BIT,	0xD47A, 0xF01B},
+	{MISENSOR_16BIT,	0xD47C, 0x0886},
+	{MISENSOR_16BIT,	0xD47E, 0x03E0},
+	{MISENSOR_16BIT,	0xD480, 0xD801},
+	{MISENSOR_16BIT,	0xD482, 0x0EF6},
+	{MISENSOR_16BIT,	0xD484, 0x03C0},
+	{MISENSOR_16BIT,	0xD486, 0x0F52},
+	{MISENSOR_16BIT,	0xD488, 0x0340},
+	{MISENSOR_16BIT,	0xD48A, 0x0DBA},
+	{MISENSOR_16BIT,	0xD48C, 0x0200},
+	{MISENSOR_16BIT,	0xD48E, 0x0AF6},
+	{MISENSOR_16BIT,	0xD490, 0x0440},
+	{MISENSOR_16BIT,	0xD492, 0x0C22},
+	{MISENSOR_16BIT,	0xD494, 0x0400},
+	{MISENSOR_16BIT,	0xD496, 0x0D72},
+	{MISENSOR_16BIT,	0xD498, 0x0440},
+	{MISENSOR_16BIT,	0xD49A, 0x0DC2},
+	{MISENSOR_16BIT,	0xD49C, 0x0200},
+	{MISENSOR_16BIT,	0xD49E, 0x0972},
+	{MISENSOR_16BIT,	0xD4A0, 0x0440},
+	{MISENSOR_16BIT,	0xD4A2, 0x0D3A},
+	{MISENSOR_16BIT,	0xD4A4, 0x0220},
+	{MISENSOR_16BIT,	0xD4A6, 0xD820},
+	{MISENSOR_16BIT,	0xD4A8, 0x0BFA},
+	{MISENSOR_16BIT,	0xD4AA, 0x0260},
+	{MISENSOR_16BIT,	0xD4AC, 0x70C9},
+	{MISENSOR_16BIT,	0xD4AE, 0x0451},
+	{MISENSOR_16BIT,	0xD4B0, 0x05C0},
+	{MISENSOR_16BIT,	0xD4B2, 0x78E0},
+	{MISENSOR_16BIT,	0xD4B4, 0xD900},
+	{MISENSOR_16BIT,	0xD4B6, 0xF00A},
+	{MISENSOR_16BIT,	0xD4B8, 0x70CF},
+	{MISENSOR_16BIT,	0xD4BA, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4BC, 0xD520},
+	{MISENSOR_16BIT,	0xD4BE, 0x7835},
+	{MISENSOR_16BIT,	0xD4C0, 0x8041},
+	{MISENSOR_16BIT,	0xD4C2, 0x8000},
+	{MISENSOR_16BIT,	0xD4C4, 0xE102},
+	{MISENSOR_16BIT,	0xD4C6, 0xA040},
+	{MISENSOR_16BIT,	0xD4C8, 0x09F1},
+	{MISENSOR_16BIT,	0xD4CA, 0x8114},
+	{MISENSOR_16BIT,	0xD4CC, 0x71CF},
+	{MISENSOR_16BIT,	0xD4CE, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4D0, 0xD4E0},
+	{MISENSOR_16BIT,	0xD4D2, 0x70CF},
+	{MISENSOR_16BIT,	0xD4D4, 0xFFFF},
+	{MISENSOR_16BIT,	0xD4D6, 0xC594},
+	{MISENSOR_16BIT,	0xD4D8, 0xB03A},
+	{MISENSOR_16BIT,	0xD4DA, 0x7FE0},
+	{MISENSOR_16BIT,	0xD4DC, 0xD800},
+	{MISENSOR_16BIT,	0xD4DE, 0x0000},
+	{MISENSOR_16BIT,	0xD4E0, 0x0000},
+	{MISENSOR_16BIT,	0xD4E2, 0x0500},
+	{MISENSOR_16BIT,	0xD4E4, 0x0500},
+	{MISENSOR_16BIT,	0xD4E6, 0x0200},
+	{MISENSOR_16BIT,	0xD4E8, 0x0330},
+	{MISENSOR_16BIT,	0xD4EA, 0x0000},
+	{MISENSOR_16BIT,	0xD4EC, 0x0000},
+	{MISENSOR_16BIT,	0xD4EE, 0x03CD},
+	{MISENSOR_16BIT,	0xD4F0, 0x050D},
+	{MISENSOR_16BIT,	0xD4F2, 0x01C5},
+	{MISENSOR_16BIT,	0xD4F4, 0x03B3},
+	{MISENSOR_16BIT,	0xD4F6, 0x00E0},
+	{MISENSOR_16BIT,	0xD4F8, 0x01E3},
+	{MISENSOR_16BIT,	0xD4FA, 0x0280},
+	{MISENSOR_16BIT,	0xD4FC, 0x01E0},
+	{MISENSOR_16BIT,	0xD4FE, 0x0109},
+	{MISENSOR_16BIT,	0xD500, 0x0080},
+	{MISENSOR_16BIT,	0xD502, 0x0500},
+	{MISENSOR_16BIT,	0xD504, 0x0000},
+	{MISENSOR_16BIT,	0xD506, 0x0000},
+	{MISENSOR_16BIT,	0xD508, 0x0000},
+	{MISENSOR_16BIT,	0xD50A, 0x0000},
+	{MISENSOR_16BIT,	0xD50C, 0x0000},
+	{MISENSOR_16BIT,	0xD50E, 0x0000},
+	{MISENSOR_16BIT,	0xD510, 0x0000},
+	{MISENSOR_16BIT,	0xD512, 0x0000},
+	{MISENSOR_16BIT,	0xD514, 0x0000},
+	{MISENSOR_16BIT,	0xD516, 0x0000},
+	{MISENSOR_16BIT,	0xD518, 0x0000},
+	{MISENSOR_16BIT,	0xD51A, 0x0000},
+	{MISENSOR_16BIT,	0xD51C, 0x0000},
+	{MISENSOR_16BIT,	0xD51E, 0x0000},
+	{MISENSOR_16BIT,	0xD520, 0xFFFF},
+	{MISENSOR_16BIT,	0xD522, 0xC9B4},
+	{MISENSOR_16BIT,	0xD524, 0xFFFF},
+	{MISENSOR_16BIT,	0xD526, 0xD324},
+	{MISENSOR_16BIT,	0xD528, 0xFFFF},
+	{MISENSOR_16BIT,	0xD52A, 0xCA34},
+	{MISENSOR_16BIT,	0xD52C, 0xFFFF},
+	{MISENSOR_16BIT,	0xD52E, 0xD3EC},
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xE000, 0x04B4},
+	{MISENSOR_16BIT,	0xE002, 0x0302},
+	{MISENSOR_16BIT,	0xE004, 0x4103},
+	{MISENSOR_16BIT,	0xE006, 0x0202},
+	{MISENSOR_16BIT,	0x0080, 0xFFF0},
+	{MISENSOR_16BIT,	0x0080, 0xFFF1},
+
+	/* PGA parameter and APGA
+	 * [Step4-APGA] [TP101_MT9M114_APGA]
+	 */
+	{MISENSOR_16BIT,	0x098E, 0x495E},
+	{MISENSOR_16BIT,	0xC95E, 0x0000},
+	{MISENSOR_16BIT,	0x3640, 0x02B0},
+	{MISENSOR_16BIT,	0x3642, 0x8063},
+	{MISENSOR_16BIT,	0x3644, 0x78D0},
+	{MISENSOR_16BIT,	0x3646, 0x50CC},
+	{MISENSOR_16BIT,	0x3648, 0x3511},
+	{MISENSOR_16BIT,	0x364A, 0x0110},
+	{MISENSOR_16BIT,	0x364C, 0xBD8A},
+	{MISENSOR_16BIT,	0x364E, 0x0CD1},
+	{MISENSOR_16BIT,	0x3650, 0x24ED},
+	{MISENSOR_16BIT,	0x3652, 0x7C11},
+	{MISENSOR_16BIT,	0x3654, 0x0150},
+	{MISENSOR_16BIT,	0x3656, 0x124C},
+	{MISENSOR_16BIT,	0x3658, 0x3130},
+	{MISENSOR_16BIT,	0x365A, 0x508C},
+	{MISENSOR_16BIT,	0x365C, 0x21F1},
+	{MISENSOR_16BIT,	0x365E, 0x0090},
+	{MISENSOR_16BIT,	0x3660, 0xBFCA},
+	{MISENSOR_16BIT,	0x3662, 0x0A11},
+	{MISENSOR_16BIT,	0x3664, 0x4F4B},
+	{MISENSOR_16BIT,	0x3666, 0x28B1},
+	{MISENSOR_16BIT,	0x3680, 0x50A9},
+	{MISENSOR_16BIT,	0x3682, 0xA04B},
+	{MISENSOR_16BIT,	0x3684, 0x0E2D},
+	{MISENSOR_16BIT,	0x3686, 0x73EC},
+	{MISENSOR_16BIT,	0x3688, 0x164F},
+	{MISENSOR_16BIT,	0x368A, 0xF829},
+	{MISENSOR_16BIT,	0x368C, 0xC1A8},
+	{MISENSOR_16BIT,	0x368E, 0xB0EC},
+	{MISENSOR_16BIT,	0x3690, 0xE76A},
+	{MISENSOR_16BIT,	0x3692, 0x69AF},
+	{MISENSOR_16BIT,	0x3694, 0x378C},
+	{MISENSOR_16BIT,	0x3696, 0xA70D},
+	{MISENSOR_16BIT,	0x3698, 0x884F},
+	{MISENSOR_16BIT,	0x369A, 0xEE8B},
+	{MISENSOR_16BIT,	0x369C, 0x5DEF},
+	{MISENSOR_16BIT,	0x369E, 0x27CC},
+	{MISENSOR_16BIT,	0x36A0, 0xCAAC},
+	{MISENSOR_16BIT,	0x36A2, 0x840E},
+	{MISENSOR_16BIT,	0x36A4, 0xDAA9},
+	{MISENSOR_16BIT,	0x36A6, 0xF00C},
+	{MISENSOR_16BIT,	0x36C0, 0x1371},
+	{MISENSOR_16BIT,	0x36C2, 0x272F},
+	{MISENSOR_16BIT,	0x36C4, 0x2293},
+	{MISENSOR_16BIT,	0x36C6, 0xE6D0},
+	{MISENSOR_16BIT,	0x36C8, 0xEC32},
+	{MISENSOR_16BIT,	0x36CA, 0x11B1},
+	{MISENSOR_16BIT,	0x36CC, 0x7BAF},
+	{MISENSOR_16BIT,	0x36CE, 0x5813},
+	{MISENSOR_16BIT,	0x36D0, 0xB871},
+	{MISENSOR_16BIT,	0x36D2, 0x8913},
+	{MISENSOR_16BIT,	0x36D4, 0x4610},
+	{MISENSOR_16BIT,	0x36D6, 0x7EEE},
+	{MISENSOR_16BIT,	0x36D8, 0x0DF3},
+	{MISENSOR_16BIT,	0x36DA, 0xB84F},
+	{MISENSOR_16BIT,	0x36DC, 0xB532},
+	{MISENSOR_16BIT,	0x36DE, 0x1171},
+	{MISENSOR_16BIT,	0x36E0, 0x13CF},
+	{MISENSOR_16BIT,	0x36E2, 0x22F3},
+	{MISENSOR_16BIT,	0x36E4, 0xE090},
+	{MISENSOR_16BIT,	0x36E6, 0x8133},
+	{MISENSOR_16BIT,	0x3700, 0x88AE},
+	{MISENSOR_16BIT,	0x3702, 0x00EA},
+	{MISENSOR_16BIT,	0x3704, 0x344F},
+	{MISENSOR_16BIT,	0x3706, 0xEC88},
+	{MISENSOR_16BIT,	0x3708, 0x3E91},
+	{MISENSOR_16BIT,	0x370A, 0xF12D},
+	{MISENSOR_16BIT,	0x370C, 0xB0EF},
+	{MISENSOR_16BIT,	0x370E, 0x77CD},
+	{MISENSOR_16BIT,	0x3710, 0x7930},
+	{MISENSOR_16BIT,	0x3712, 0x5C12},
+	{MISENSOR_16BIT,	0x3714, 0x500C},
+	{MISENSOR_16BIT,	0x3716, 0x22CE},
+	{MISENSOR_16BIT,	0x3718, 0x2370},
+	{MISENSOR_16BIT,	0x371A, 0x258F},
+	{MISENSOR_16BIT,	0x371C, 0x3D30},
+	{MISENSOR_16BIT,	0x371E, 0x370C},
+	{MISENSOR_16BIT,	0x3720, 0x03ED},
+	{MISENSOR_16BIT,	0x3722, 0x9AD0},
+	{MISENSOR_16BIT,	0x3724, 0x7ECF},
+	{MISENSOR_16BIT,	0x3726, 0x1093},
+	{MISENSOR_16BIT,	0x3740, 0x2391},
+	{MISENSOR_16BIT,	0x3742, 0xAAD0},
+	{MISENSOR_16BIT,	0x3744, 0x28F2},
+	{MISENSOR_16BIT,	0x3746, 0xBA4F},
+	{MISENSOR_16BIT,	0x3748, 0xC536},
+	{MISENSOR_16BIT,	0x374A, 0x1472},
+	{MISENSOR_16BIT,	0x374C, 0xD110},
+	{MISENSOR_16BIT,	0x374E, 0x2933},
+	{MISENSOR_16BIT,	0x3750, 0xD0D1},
+	{MISENSOR_16BIT,	0x3752, 0x9F37},
+	{MISENSOR_16BIT,	0x3754, 0x34D1},
+	{MISENSOR_16BIT,	0x3756, 0x1C6C},
+	{MISENSOR_16BIT,	0x3758, 0x3FD2},
+	{MISENSOR_16BIT,	0x375A, 0xCB72},
+	{MISENSOR_16BIT,	0x375C, 0xBA96},
+	{MISENSOR_16BIT,	0x375E, 0x1551},
+	{MISENSOR_16BIT,	0x3760, 0xB74F},
+	{MISENSOR_16BIT,	0x3762, 0x1672},
+	{MISENSOR_16BIT,	0x3764, 0x84F1},
+	{MISENSOR_16BIT,	0x3766, 0xC2D6},
+	{MISENSOR_16BIT,	0x3782, 0x01E0},
+	{MISENSOR_16BIT,	0x3784, 0x0280},
+	{MISENSOR_16BIT,	0x37C0, 0xA6EA},
+	{MISENSOR_16BIT,	0x37C2, 0x874B},
+	{MISENSOR_16BIT,	0x37C4, 0x85CB},
+	{MISENSOR_16BIT,	0x37C6, 0x968A},
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xC960, 0x0AF0},
+	{MISENSOR_16BIT,	0xC962, 0x79E2},
+	{MISENSOR_16BIT,	0xC964, 0x5EC8},
+	{MISENSOR_16BIT,	0xC966, 0x791F},
+	{MISENSOR_16BIT,	0xC968, 0x76EE},
+	{MISENSOR_16BIT,	0xC96A, 0x0FA0},
+	{MISENSOR_16BIT,	0xC96C, 0x7DFA},
+	{MISENSOR_16BIT,	0xC96E, 0x7DAF},
+	{MISENSOR_16BIT,	0xC970, 0x7E02},
+	{MISENSOR_16BIT,	0xC972, 0x7E0A},
+	{MISENSOR_16BIT,	0xC974, 0x1964},
+	{MISENSOR_16BIT,	0xC976, 0x7CDC},
+	{MISENSOR_16BIT,	0xC978, 0x7838},
+	{MISENSOR_16BIT,	0xC97A, 0x7C2F},
+	{MISENSOR_16BIT,	0xC97C, 0x7792},
+	{MISENSOR_16BIT,	0xC95E, 0x0003},
+
+	/* [Step4-APGA] */
+	{MISENSOR_16BIT,	0x098E, 0x0000},
+	{MISENSOR_16BIT,	0xC95E, 0x0003},
+
+	/* [Step5-AWB_CCM]1: LOAD=CCM */
+	{MISENSOR_16BIT,	0xC892, 0x0267},
+	{MISENSOR_16BIT,	0xC894, 0xFF1A},
+	{MISENSOR_16BIT,	0xC896, 0xFFB3},
+	{MISENSOR_16BIT,	0xC898, 0xFF80},
+	{MISENSOR_16BIT,	0xC89A, 0x0166},
+	{MISENSOR_16BIT,	0xC89C, 0x0003},
+	{MISENSOR_16BIT,	0xC89E, 0xFF9A},
+	{MISENSOR_16BIT,	0xC8A0, 0xFEB4},
+	{MISENSOR_16BIT,	0xC8A2, 0x024D},
+	{MISENSOR_16BIT,	0xC8A4, 0x01BF},
+	{MISENSOR_16BIT,	0xC8A6, 0xFF01},
+	{MISENSOR_16BIT,	0xC8A8, 0xFFF3},
+	{MISENSOR_16BIT,	0xC8AA, 0xFF75},
+	{MISENSOR_16BIT,	0xC8AC, 0x0198},
+	{MISENSOR_16BIT,	0xC8AE, 0xFFFD},
+	{MISENSOR_16BIT,	0xC8B0, 0xFF9A},
+	{MISENSOR_16BIT,	0xC8B2, 0xFEE7},
+	{MISENSOR_16BIT,	0xC8B4, 0x02A8},
+	{MISENSOR_16BIT,	0xC8B6, 0x01D9},
+	{MISENSOR_16BIT,	0xC8B8, 0xFF26},
+	{MISENSOR_16BIT,	0xC8BA, 0xFFF3},
+	{MISENSOR_16BIT,	0xC8BC, 0xFFB3},
+	{MISENSOR_16BIT,	0xC8BE, 0x0132},
+	{MISENSOR_16BIT,	0xC8C0, 0xFFE8},
+	{MISENSOR_16BIT,	0xC8C2, 0xFFDA},
+	{MISENSOR_16BIT,	0xC8C4, 0xFECD},
+	{MISENSOR_16BIT,	0xC8C6, 0x02C2},
+	{MISENSOR_16BIT,	0xC8C8, 0x0075},
+	{MISENSOR_16BIT,	0xC8CA, 0x011C},
+	{MISENSOR_16BIT,	0xC8CC, 0x009A},
+	{MISENSOR_16BIT,	0xC8CE, 0x0105},
+	{MISENSOR_16BIT,	0xC8D0, 0x00A4},
+	{MISENSOR_16BIT,	0xC8D2, 0x00AC},
+	{MISENSOR_16BIT,	0xC8D4, 0x0A8C},
+	{MISENSOR_16BIT,	0xC8D6, 0x0F0A},
+	{MISENSOR_16BIT,	0xC8D8, 0x1964},
+
+	/* LOAD=AWB */
+	{MISENSOR_16BIT,	0xC914, 0x0000},
+	{MISENSOR_16BIT,	0xC916, 0x0000},
+	{MISENSOR_16BIT,	0xC918, 0x04FF},
+	{MISENSOR_16BIT,	0xC91A, 0x02CF},
+	{MISENSOR_16BIT,	0xC904, 0x0033},
+	{MISENSOR_16BIT,	0xC906, 0x0040},
+	{MISENSOR_8BIT,   0xC8F2, 0x03},
+	{MISENSOR_8BIT,   0xC8F3, 0x02},
+	{MISENSOR_16BIT,	0xC906, 0x003C},
+	{MISENSOR_16BIT,	0xC8F4, 0x0000},
+	{MISENSOR_16BIT,	0xC8F6, 0x0000},
+	{MISENSOR_16BIT,	0xC8F8, 0x0000},
+	{MISENSOR_16BIT,	0xC8FA, 0xE724},
+	{MISENSOR_16BIT,	0xC8FC, 0x1583},
+	{MISENSOR_16BIT,	0xC8FE, 0x2045},
+	{MISENSOR_16BIT,	0xC900, 0x05DC},
+	{MISENSOR_16BIT,	0xC902, 0x007C},
+	{MISENSOR_8BIT,   0xC90C, 0x80},
+	{MISENSOR_8BIT,   0xC90D, 0x80},
+	{MISENSOR_8BIT,   0xC90E, 0x80},
+	{MISENSOR_8BIT,   0xC90F, 0x88},
+	{MISENSOR_8BIT,   0xC910, 0x80},
+	{MISENSOR_8BIT,   0xC911, 0x80},
+
+	/* LOAD=Step7-CPIPE_Preference */
+	{MISENSOR_16BIT,	0xC926, 0x0020},
+	{MISENSOR_16BIT,	0xC928, 0x009A},
+	{MISENSOR_16BIT,	0xC946, 0x0070},
+	{MISENSOR_16BIT,	0xC948, 0x00F3},
+	{MISENSOR_16BIT,	0xC952, 0x0020},
+	{MISENSOR_16BIT,	0xC954, 0x009A},
+	{MISENSOR_8BIT,   0xC92A, 0x80},
+	{MISENSOR_8BIT,   0xC92B, 0x4B},
+	{MISENSOR_8BIT,   0xC92C, 0x00},
+	{MISENSOR_8BIT,   0xC92D, 0xFF},
+	{MISENSOR_8BIT,   0xC92E, 0x3C},
+	{MISENSOR_8BIT,   0xC92F, 0x02},
+	{MISENSOR_8BIT,   0xC930, 0x06},
+	{MISENSOR_8BIT,   0xC931, 0x64},
+	{MISENSOR_8BIT,   0xC932, 0x01},
+	{MISENSOR_8BIT,   0xC933, 0x0C},
+	{MISENSOR_8BIT,   0xC934, 0x3C},
+	{MISENSOR_8BIT,   0xC935, 0x3C},
+	{MISENSOR_8BIT,   0xC936, 0x3C},
+	{MISENSOR_8BIT,   0xC937, 0x0F},
+	{MISENSOR_8BIT,   0xC938, 0x64},
+	{MISENSOR_8BIT,   0xC939, 0x64},
+	{MISENSOR_8BIT,   0xC93A, 0x64},
+	{MISENSOR_8BIT,   0xC93B, 0x32},
+	{MISENSOR_16BIT,	0xC93C, 0x0020},
+	{MISENSOR_16BIT,	0xC93E, 0x009A},
+	{MISENSOR_16BIT,	0xC940, 0x00DC},
+	{MISENSOR_8BIT,   0xC942, 0x38},
+	{MISENSOR_8BIT,   0xC943, 0x30},
+	{MISENSOR_8BIT,   0xC944, 0x50},
+	{MISENSOR_8BIT,   0xC945, 0x19},
+	{MISENSOR_16BIT,	0xC94A, 0x0230},
+	{MISENSOR_16BIT,	0xC94C, 0x0010},
+	{MISENSOR_16BIT,	0xC94E, 0x01CD},
+	{MISENSOR_8BIT,   0xC950, 0x05},
+	{MISENSOR_8BIT,   0xC951, 0x40},
+	{MISENSOR_8BIT,   0xC87B, 0x1B},
+	{MISENSOR_8BIT,   0xC878, 0x0E},
+	{MISENSOR_16BIT,	0xC890, 0x0080},
+	{MISENSOR_16BIT,	0xC886, 0x0100},
+	{MISENSOR_16BIT,	0xC87C, 0x005A},
+	{MISENSOR_8BIT,   0xB42A, 0x05},
+	{MISENSOR_8BIT,   0xA80A, 0x20},
+
+	/* Speed up AE/AWB */
+	{MISENSOR_16BIT,	0x098E, 0x2802},
+	{MISENSOR_16BIT,	0xA802, 0x0008},
+	{MISENSOR_8BIT,   0xC908, 0x01},
+	{MISENSOR_8BIT,   0xC879, 0x01},
+	{MISENSOR_8BIT,   0xC909, 0x02},
+	{MISENSOR_8BIT,   0xA80A, 0x18},
+	{MISENSOR_8BIT,   0xA80B, 0x18},
+	{MISENSOR_8BIT,   0xAC16, 0x18},
+	{MISENSOR_8BIT,   0xC878, 0x0E},
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9v113.c b/drivers/external_drivers/camera/drivers/media/i2c/mt9v113.c
new file mode 100644
index 0000000..c7689be
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9v113.c
@@ -0,0 +1,1761 @@
+/*
+ * Support for mt9v113 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "mt9v113.h"
+
+#define to_mt9v113_sensor(sd) container_of(sd, struct mt9v113_device, sd)
+
+/*
+ * TODO: use debug parameter to actually define when debug messages should
+ * be printed.
+ */
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+/*
+ * mt9v113_read_reg - read a register value through i2c
+ * @client: i2c_client
+ * @data_length: register data width, e.g.: 8bit/16bit/32bit
+ * @reg: register address
+ * @val: register read value
+ *
+ * The function return 0 for success, < 0 for err
+ */
+static int
+mt9v113_read_reg(struct i2c_client *client, u16 data_length, u32 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			 __func__);
+		return -EINVAL;
+	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u16) (reg >> 8);
+	data[1] = (u16) (reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+
+	if (err >= 0) {
+		*val = 0;
+		/* high byte comes first */
+		if (data_length == MISENSOR_8BIT)
+			*val = data[0];
+		else if (data_length == MISENSOR_16BIT)
+			*val = data[1] + (data[0] << 8);
+		else
+			*val = data[3] + (data[2] << 8) +
+			    (data[1] << 16) + (data[0] << 24);
+
+		return 0;
+	}
+
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+/*
+ * mt9v113_write_reg - write a register value through i2c
+ * @client: i2c_client
+ * @data_length: register data width, e.g.: 8bit/16bit/32bit
+ * @reg: register address
+ * @val: register write value
+ *
+ * The function return 0 for success, < 0 for err
+ */
+static int
+mt9v113_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = be16_to_cpu((u16)val);
+	} else {
+		/* MISENSOR_32BIT */
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = be32_to_cpu(val);
+	}
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return num_msg;
+}
+
+/**
+ * misensor_rmw_reg - Read/Modify/Write a value to a register in the sensor
+ * device
+ * @client: i2c driver client structure
+ * @data_length: 8/16/32-bits length
+ * @reg: register address
+ * @mask: masked out bits
+ * @set: bits set
+ *
+ * Read/modify/write a value to a register in the  sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int
+misensor_rmw_reg(struct i2c_client *client, u16 data_length, u16 reg,
+		     u32 mask, u32 set)
+{
+	int err;
+	u32 val;
+
+	/* Exit when no mask */
+	if (mask == 0)
+		return 0;
+
+	/* @mask must not exceed data length */
+	switch (data_length) {
+	case MISENSOR_8BIT:
+		if (mask & ~0xff)
+			return -EINVAL;
+		break;
+	case MISENSOR_16BIT:
+		if (mask & ~0xffff)
+			return -EINVAL;
+		break;
+	case MISENSOR_32BIT:
+		break;
+	default:
+		/* Wrong @data_length */
+		return -EINVAL;
+	}
+
+	err = mt9v113_read_reg(client, data_length, reg, &val);
+	if (err) {
+		dev_err(&client->dev, "misensor_rmw_reg error exit");
+		return -EINVAL;
+	}
+
+	val &= ~mask;
+
+	/*
+	 * Perform the OR function if the @set exists.
+	 * Shift @set value to target bit location. @set should set only
+	 * bits included in @mask.
+	 *
+	 * REVISIT: This function expects @set to be non-shifted. Its shift
+	 * value is then defined to be equal to mask's LSB position.
+	 * How about to inform values in their right offset position and avoid
+	 * this unneeded shift operation?
+	 */
+	set <<= ffs(mask) - 1;
+	val |= set & mask;
+
+	err = mt9v113_write_reg(client, data_length, reg, val);
+	if (err) {
+		dev_err(&client->dev, "misensor_rmw_reg error exit");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __mt9v113_flush_reg_array(struct i2c_client *client,
+				     struct mt9v113_write_ctrl *ctrl)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	int retry = 0;
+
+	if (ctrl->index == 0)
+		return 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + ctrl->index;
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	msg.buf = (u8 *)&ctrl->buffer;
+
+	ret = i2c_transfer(client->adapter, &msg, num_msg);
+	if (ret != num_msg) {
+		if (++retry <= I2C_RETRY_COUNT) {
+			dev_dbg(&client->dev, "retrying... %d\n", retry);
+			msleep(20);
+			goto again;
+		}
+		dev_err(&client->dev, "%s: i2c transfer error\n", __func__);
+		return -EIO;
+	}
+
+	ctrl->index = 0;
+
+	/*
+	 * REVISIT: Previously we had a delay after writing data to sensor.
+	 * But it was removed as our tests have shown it is not necessary
+	 * anymore.
+	 */
+
+	return 0;
+}
+
+static int __mt9v113_buf_reg_array(struct i2c_client *client,
+				   struct mt9v113_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	u16 *data16;
+	u32 *data32;
+	int err;
+
+	/* Insufficient buffer? Let's flush and get more free space. */
+	if (ctrl->index + next->length >= MT9V113_MAX_WRITE_BUF_SIZE) {
+		err = __mt9v113_flush_reg_array(client, ctrl);
+		if (err)
+			return err;
+	}
+
+	switch (next->length) {
+	case MISENSOR_8BIT:
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case MISENSOR_16BIT:
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	case MISENSOR_32BIT:
+		data32 = (u32 *)&ctrl->buffer.data[ctrl->index];
+		*data32 = cpu_to_be32(next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += next->length;
+
+	return 0;
+}
+
+static int
+__mt9v113_write_reg_is_consecutive(struct i2c_client *client,
+				   struct mt9v113_write_ctrl *ctrl,
+				   const struct misensor_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+/*
+ * mt9v113_write_reg_array - Initializes a list of mt9v113 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __mt9v113_flush_reg_array, __mt9v113_buf_reg_array() and
+ * __mt9v113_write_reg_is_consecutive() are internal functions to
+ * mt9v113_write_reg_array() and should be not used anywhere else.
+ *
+ */
+static int mt9v113_write_reg_array(struct i2c_client *client,
+				const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	struct mt9v113_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		switch (next->length & MISENSOR_TOK_MASK) {
+		case MISENSOR_TOK_DELAY:
+			err = __mt9v113_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		case MISENSOR_TOK_RMW:
+			err = __mt9v113_flush_reg_array(client, &ctrl);
+			err |= misensor_rmw_reg(client,
+						next->length &
+							~MISENSOR_TOK_RMW,
+						next->reg, next->val,
+						next->val2);
+			if (err) {
+				dev_err(&client->dev, "%s read err. aborted\n",
+					__func__);
+				return -EINVAL;
+			}
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__mt9v113_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __mt9v113_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __mt9v113_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write aborted",
+					__func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	err = __mt9v113_flush_reg_array(client, &ctrl);
+	if (err)
+		return err;
+	return 0;
+}
+
+static int mt9v113_wait_standby(struct v4l2_subdev *sd, int flag)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 100;
+	int ret, status;
+
+	while (i--) {
+		ret = mt9v113_read_reg(client, MISENSOR_16BIT,
+				       MT9V113_REG_STBY_CTRL, &status);
+		if (ret) {
+			dev_err(&client->dev, "err read SEQ_CMD: %d", ret);
+			return -ret;
+		}
+
+		if (((status & STBY_CTRL_MASK_STBY_STAT)
+			>> STBY_CTRL_BIT_STBY_STAT) == flag)
+			return 0;
+		msleep(20);
+	}
+
+	dev_err(&client->dev, "wait standby %d timeout.", flag);
+	return -EBUSY;
+}
+
+static int mt9v113_set_suspend(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9V113_REG_STBY_CTRL,
+			       STBY_CTRL_MASK_STBY_REQ, 0x01);
+	if (ret) {
+		dev_err(&client->dev, "err set standby bit: %d", ret);
+		return -EINVAL;
+	}
+
+	return mt9v113_wait_standby(sd, 1);
+}
+
+static int mt9v113_wait_refresh(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 100;
+	int ret, status;
+
+	while (i--) {
+		ret = mt9v113_write_reg(client, MISENSOR_16BIT,
+					MT9V113_MCU_VAR_ADDR,
+					MT9V113_VAR_SEQ_CMD);
+		if (ret) {
+			dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+			return ret;
+		}
+
+		ret = mt9v113_read_reg(client, MISENSOR_16BIT,
+					MT9V113_MCU_VAR_DATA0, &status);
+		if (ret) {
+			dev_err(&client->dev, "err read SEQ_CMD: %d", ret);
+			return ret;
+		}
+
+		if (status == SEQ_CMD_RUN)
+			return 0;
+		msleep(20);
+	}
+
+	dev_err(&client->dev, "wait refresh timeout: 0x%x", status);
+	return -EBUSY;
+}
+
+static int mt9v113_refresh(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* Refresh sequencer Mode */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_MCU_VAR_ADDR,
+				MT9V113_VAR_SEQ_CMD);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_MCU_VAR_DATA0,
+				 SEQ_CMD_REFRESH_MODE);
+	if (ret) {
+		dev_err(&client->dev, "err refresh seq mode: %d", ret);
+		return ret;
+	}
+
+	ret = mt9v113_wait_refresh(sd);
+	if (ret)
+		return ret;
+	/* Refresh sequencer */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_MCU_VAR_ADDR,
+				MT9V113_VAR_SEQ_CMD);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_MCU_VAR_DATA0,
+				 SEQ_CMD_REFRESH);
+	if (ret) {
+		dev_err(&client->dev, "err refresh seq: %d", ret);
+		return ret;
+	}
+	ret = mt9v113_wait_refresh(sd);
+	if (ret)
+		return ret;
+	return 0;
+}
+
+static int mt9v113_wait_pll_lock(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 10;
+	int ret, status_pll;
+
+	while (i--) {
+		ret = mt9v113_read_reg(client, MISENSOR_16BIT,
+			MT9V113_REG_PLL_CTRL, &status_pll);
+		if (ret) {
+			dev_err(&client->dev, "err read pll status: %d", ret);
+			return -EINVAL;
+		}
+		if (status_pll & PLL_CTRL_MASK_PLL_STAT)
+			return 0;
+		usleep_range(8000, 12000);
+	}
+
+	dev_err(&client->dev, "pll can't lock, err: %d", ret);
+	return -EBUSY;
+}
+
+static int mt9v113_init_pll(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* Bypass PLL */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9V113_REG_PLL_CTRL,
+			       PLL_CTRL_MASK_INIT_PLL, 0x1);
+	if (ret)
+		goto err;
+	/* Disable PLL */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9V113_REG_PLL_CTRL,
+			       PLL_CTRL_MASK_EN_PLL, 0x0);
+	if (ret)
+		goto err;
+
+	/*
+	 * PLL Setting:
+	 * Input: 19.2M
+	 * M=35, N=2 P=0
+	 * Target: 28M
+	 * fbit: 224M
+	 * fword: 28M
+	 * sensor: 14M
+	 */
+	/* PLL Dividers: M=35, N=2 */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_REG_PLL_DIV,
+				0x0223);
+	if (ret)
+		goto err;
+
+	/* PLL P Divider = 0 */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_REG_PLL_P, 0x0);
+	if (ret)
+		goto err;
+
+	/* PLL control: TEST_BYPASS on = 9291 */
+	/* Arbitrary value from Aptina */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_REG_PLL_CTRL,
+				0x244b);
+	if (ret)
+		goto err;
+
+	/*
+	 * wait PLL lock
+	 * Aptina: min require 1ms delay
+	 */
+	usleep_range(1000, 2000);
+
+	/* PLL control: PLL Enable on = 12363 */
+	/* Abitrary value from Aptina */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_REG_PLL_CTRL,
+				0x304b);
+	if (ret)
+		goto err;
+
+	/* Poll PLL Lock state */
+	ret = mt9v113_wait_pll_lock(sd);
+	if (ret)
+		return ret;
+
+	/* PLL Bypass off */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9V113_REG_PLL_CTRL,
+			       PLL_CTRL_MASK_INIT_PLL, 0x0);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	dev_err(&client->dev, "reg pll access err: %d", ret);
+	return ret;
+}
+
+static int mt9v113_wait_mipi_standby(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i = 100;
+	int ret, status;
+
+	while (i--) {
+		ret = mt9v113_read_reg(client, MISENSOR_16BIT,
+				       MT9V113_REG_MIPI_STAT, &status);
+		if (ret) {
+			dev_err(&client->dev, "err read SEQ_CMD: %d", ret);
+			return ret;
+		}
+
+		if (status & MIPI_STAT_MASK_MIPI_STBY_STAT)
+			return 0;
+		usleep_range(8000, 12000);
+	}
+
+	dev_err(&client->dev, "wait mipi standby %d timeout.", status);
+	return -EBUSY;
+}
+
+static int mt9v113_mipi_standby(struct v4l2_subdev *sd, int state)
+{
+	int ret = 0;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+
+	ret = misensor_rmw_reg(c, MISENSOR_16BIT, MT9V113_REG_MIPI_CTRL,
+			       MIPI_CTRL_MASK_MIPI_STBY_REQ, state);
+	if (ret)
+		dev_err(&c->dev, "err set mipi standby bit: %d", ret);
+
+	return ret;
+}
+
+static int mt9v113_init_common(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/*
+	 * Soft reset and basic sys ctl
+	 */
+	ret = mt9v113_write_reg_array(client, mt9v113_reset);
+	if (ret)
+		return ret;
+
+	/*
+	 * PLL Init
+	 */
+	ret = mt9v113_init_pll(sd);
+	if (ret) {
+		dev_err(&client->dev, "err init pll: %d", ret);
+		return ret;
+	}
+	/*
+	 * Enable MIPI interface
+	 */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_REG_MISC_CTRL,
+				0x0018);
+	if (ret) {
+		dev_err(&client->dev, "err MIPI interface");
+		return ret;
+	}
+	/*
+	 * Take out of standby with MCU power up stop
+	 * Arbitrary value from Aptina
+	 */
+	if (mt9v113_write_reg(client, MISENSOR_16BIT, MT9V113_REG_STBY_CTRL,
+			      0x402c))
+		dev_warn(&client->dev, "err leave standby");
+	if (mt9v113_wait_standby(sd, 0))
+		dev_warn(&client->dev, "err leave standby");
+
+	/*
+	 * MIPI setting
+	 */
+	/* Enable MIPI */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9V113_REG_MIPI_CTRL,
+			       MIPI_CTRL_MASK_EN_MIPI, 0x1);
+	if (ret) {
+		dev_err(&client->dev, "err Enable mipi: %d", ret);
+		return ret;
+	}
+
+	/* Use IFP */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9V113_REG_OFIFO_CTRL,
+				OFIFO_CTRL_MASK_SENS_OUT, 0x0);
+	if (ret) {
+		dev_err(&client->dev, "err init mipi: %d", ret);
+		return ret;
+	}
+
+	/* MIPI Stop EOF */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, MT9V113_REG_MIPI_CTRL,
+			       MIPI_CTRL_MASK_MIPI_EOF_REQ, 0x1);
+	if (ret) {
+		dev_err(&client->dev, "err set mipi EOF bit: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * REDUCE_IO_CURRENT
+	 */
+	ret = mt9v113_write_reg_array(client, mt9v113_reduce_current);
+	if (ret) {
+		dev_err(&client->dev, "err init io current: %d", ret);
+		return ret;
+	}
+
+	/* core only tags defects, SOC will correct them. */
+	/* From Aptina: reserved register */
+	ret = misensor_rmw_reg(client, MISENSOR_16BIT, 0x31E0, 0x0002, 0x0);
+	if (ret) {
+		dev_err(&client->dev, "err reduce io current: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * LSC 95%
+	 */
+	ret = mt9v113_write_reg_array(client, mt9v113_lsc_95);
+	if (ret) {
+		dev_err(&client->dev, "err set lsc: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * COLOR PIPE CONTROL
+	 */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT,
+				MT9V113_REG_COL_PIPE_CTL,
+				MT9V113_REG_COL_PIPE_CTL_VAL);
+	if (ret) {
+		dev_err(&client->dev, "err set color pipe");
+		return ret;
+	}
+
+	/*
+	 * MT9V113 KERNEL CONFIG
+	 * For Noise reduction
+	 */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT,
+				MT9V113_REG_KERNEL_CONFIG,
+				MT9V113_REG_KERNEL_CONFIG_VAL);
+	if (ret) {
+		dev_err(&client->dev, "err set kernel config");
+		return ret;
+	}
+
+	/*
+	 * AWB_CCM
+	 */
+	ret = mt9v113_write_reg_array(client, mt9v113_awb_ccm);
+	if (ret) {
+		dev_err(&client->dev, "err set awb & ccm: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * CPIE_Calibration
+	 */
+	ret = mt9v113_write_reg_array(client, mt9v113_cpipe_calibration);
+	if (ret) {
+		dev_err(&client->dev, "err set cpipe_calibration: %d", ret);
+		return ret;
+	}
+
+	/*
+	 * CPIPE_Preference
+	 */
+	ret = mt9v113_write_reg_array(client, mt9v113_cpipe_perference);
+	if (ret) {
+		dev_err(&client->dev, "err set cpipe_perference: %d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct mt9v113_device *dev = to_mt9v113_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/*
+	 * DS: 6000 EXTCLK is needed after HW reset
+	 * EXTCLK: 19.2MHZ -> 6000 / 19.2E6 = 0.31mS
+	 */
+	usleep_range(310, 1000);
+
+	return ret;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct mt9v113_device *dev = to_mt9v113_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int mt9v113_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+
+	if (power_up(sd))
+		return -EINVAL;
+
+	return mt9v113_init_common(sd);
+}
+
+static int mt9v113_try_res(u32 *w, u32 *h)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9v113_res[i].width >= *w) &&
+		    (mt9v113_res[i].height >= *h))
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = mt9v113_res[i].width;
+	*h = mt9v113_res[i].height;
+
+	return 0;
+}
+
+static struct mt9v113_res_struct *mt9v113_to_res(u32 w, u32 h)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if ((mt9v113_res[index].width == w) &&
+		    (mt9v113_res[index].height == h))
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &mt9v113_res[index];
+}
+
+static int mt9v113_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	return mt9v113_try_res(&fmt->width, &fmt->height);
+}
+
+static int mt9v113_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case MT9V113_RES_QCIF:
+		hsize = MT9V113_RES_QCIF_SIZE_H;
+		vsize = MT9V113_RES_QCIF_SIZE_V;
+		break;
+	case MT9V113_RES_QVGA:
+		hsize = MT9V113_RES_QVGA_SIZE_H;
+		vsize = MT9V113_RES_QVGA_SIZE_V;
+		break;
+	case MT9V113_RES_CIF:
+		hsize = MT9V113_RES_CIF_SIZE_H;
+		vsize = MT9V113_RES_CIF_SIZE_V;
+		break;
+	case MT9V113_RES_VGA:
+		hsize = MT9V113_RES_VGA_SIZE_H;
+		vsize = MT9V113_RES_VGA_SIZE_V;
+		break;
+	default:
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+	return 0;
+}
+
+static int mt9v113_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct mt9v113_device *dev = to_mt9v113_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = mt9v113_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int mt9v113_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct mt9v113_device *dev = to_mt9v113_sensor(sd);
+	struct mt9v113_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	int ret;
+
+	mt9v113_try_res(&width, &height);
+	res_index = mt9v113_to_res(width, height);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	switch (res_index->res) {
+	case MT9V113_RES_QCIF:
+		dev_info(&c->dev, "%s: set for qcif\n", __func__);
+		ret = mt9v113_write_reg_array(c, mt9v113_qcif_init);
+		break;
+	case MT9V113_RES_QVGA:
+		dev_info(&c->dev, "%s: set for qvga\n", __func__);
+		ret = mt9v113_write_reg_array(c, mt9v113_qvga_init);
+		break;
+	case MT9V113_RES_CIF:
+		dev_info(&c->dev, "%s: set for cif\n", __func__);
+		ret = mt9v113_write_reg_array(c, mt9v113_cif_init);
+		break;
+	case MT9V113_RES_VGA:
+		dev_info(&c->dev, "%s: set for vga\n", __func__);
+		ret = mt9v113_write_reg_array(c, mt9v113_vga_init);
+		break;
+	default:
+		dev_err(&c->dev, "set resolution: %d failed!\n",
+			res_index->res);
+		return -EINVAL;
+	}
+
+	if (ret)
+		return ret;
+
+	/* Limit max exposure if in video mode */
+	ret = mt9v113_write_reg(c, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_ADDR,
+				MT9V113_VAR_AE_MAX_INDEX);
+	if (ret) {
+		dev_err(&c->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	if (dev->run_mode == CI_MODE_VIDEO) {
+		ret = mt9v113_write_reg(c, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_DATA0,
+				MT9V113_AE_MAX_INDEX_0);
+		/*
+		 * Need to increase Flicker Detection sensitivity
+		 * as keeping 30fps will have no enough exposure
+		 * time
+		 *
+		 * DS: How to adjust Auto Flicker Detection Sensitivity:
+		 * 1: Decrease the value of 0x000D to 2 or 1
+		 * 2: Decrease 0x0010 to 3 or 2
+		 * 3: Make the search range wider
+		 */
+		ret = mt9v113_write_reg_array(c, mt9v113_high_flicker);
+		if (ret) {
+			dev_err(&c->dev, "err set high flicker: %d", ret);
+			return ret;
+		}
+	} else {
+		ret = mt9v113_write_reg(c, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_DATA0,
+				MT9V113_AE_MAX_INDEX_1);
+	}
+
+	if (ret) {
+		dev_err(&c->dev, "err write ae_max_index: %d", ret);
+		return ret;
+	}
+
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int mt9v113_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const focal length for MT9V113 */
+	*val = (MT9V113_FOCAL_LENGTH_NUM << 16) | MT9V113_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int mt9v113_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const f-number for MT9V113 */
+	*val = (MT9V113_F_NUMBER_DEFAULT_NUM << 16) | MT9V113_F_NUMBER_DEM;
+	return 0;
+}
+
+static int mt9v113_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (MT9V113_F_NUMBER_DEFAULT_NUM << 24) |
+		(MT9V113_F_NUMBER_DEM << 16) |
+		(MT9V113_F_NUMBER_DEFAULT_NUM << 8) | MT9V113_F_NUMBER_DEM;
+	return 0;
+}
+
+/* read shutter, in number of line period */
+static int mt9v113_get_shutter(struct v4l2_subdev *sd, s32 *shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct mt9v113_device *dev = to_mt9v113_sensor(sd);
+	u32 inte_time, row_time;
+	int ret, i;
+
+	/* read integration time */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_ADDR,
+				MT9V113_VAR_INTEGRATION_TIME);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9v113_read_reg(client, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_DATA0,
+				&inte_time);
+	if (ret) {
+		dev_err(&client->dev,
+				"err read integration time: %d", ret);
+		return ret;
+	}
+
+	/* get row time */
+	for (i = 0; i < N_RES; i++) {
+		if (mt9v113_res[i].res == dev->res) {
+			row_time = mt9v113_res[i].row_time;
+			break;
+		}
+	}
+	if (i == N_RES)	{
+		dev_err(&client->dev,
+				"err get row  time: %d", ret);
+		return -EINVAL;
+	}
+
+	/* return exposure value is in units of 100us */
+	*shutter = inte_time * row_time / 100;
+
+	return 0;
+}
+
+/*
+ * This returns the exposure compensation value, which is expressed in
+ * terms of EV. The default EV value is 0, and driver don't support
+ * adjust EV value.
+ */
+static int mt9v113_get_exposure_bias(struct v4l2_subdev *sd, s32 *value)
+{
+	*value = 0;
+
+	return 0;
+}
+
+/*
+ * This returns ISO sensitivity.
+ */
+static int mt9v113_get_iso(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 ae_gain, ae_d_gain;
+	int ret;
+
+	/* read ae virtual gain */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_ADDR,
+				MT9V113_VAR_AE_GAIN);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9v113_read_reg(client, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_DATA0,
+				&ae_gain);
+	if (ret) {
+		dev_err(&client->dev,
+				"err read ae virtual gain: %d", ret);
+		return ret;
+	}
+
+	/* read ae_d_gain */
+	ret = mt9v113_write_reg(client, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_ADDR,
+				MT9V113_VAR_AE_D_GAIN);
+	if (ret) {
+		dev_err(&client->dev, "err Write VAR ADDR: %d", ret);
+		return ret;
+	}
+
+	ret = mt9v113_read_reg(client, MISENSOR_16BIT,
+				MT9V113_MCU_VAR_DATA0,
+				&ae_d_gain);
+	if (ret) {
+		dev_err(&client->dev,
+				"err read ae_d_gain: %d", ret);
+		return ret;
+	}
+
+	*value = ((ae_gain * 25) >> 4) + (((ae_d_gain - 128) * 200) >> 7);
+
+	return 0;
+}
+
+/*
+ * More will be added in future
+ */
+static struct mt9v113_control mt9v113_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9v113_get_shutter,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure bias",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9v113_get_exposure_bias,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_ISO_SENSITIVITY,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "iso",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = mt9v113_get_iso,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = 0,
+			.maximum = MT9V113_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9V113_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9v113_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = 0,
+			.maximum = MT9V113_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = MT9V113_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = mt9v113_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = 0,
+			.maximum =  MT9V113_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = MT9V113_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = mt9v113_g_fnumber_range,
+	},
+};
+
+#define N_CONTROLS (ARRAY_SIZE(mt9v113_controls))
+
+static struct mt9v113_control *mt9v113_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (mt9v113_controls[i].qc.id == id)
+			return &mt9v113_controls[i];
+	}
+	return NULL;
+}
+
+static int mt9v113_detect(struct mt9v113_device *dev, struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+	/*
+	 * Read Device ID
+	 * SYSCTL: 0x0
+	 * contains the MT9V113 device ID Number, 0x2280
+	 * Read-Only
+	 */
+	mt9v113_read_reg(client, MISENSOR_16BIT, MT9V113_REG_CHIPID, &retvalue);
+	dev->real_model_id = retvalue;
+
+	if (retvalue != V4L2_IDENT_MT9V113) {
+		dev_err(&client->dev, "%s: failed: client->addr = 0x%x\n",
+			__func__, client->addr);
+		dev_err(&client->dev, "%s: bad device id: 0x%x\n",
+			__func__, retvalue);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int
+mt9v113_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct mt9v113_device *dev = to_mt9v113_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "mt9v113 platform init err\n");
+			return ret;
+		}
+	}
+	ret = mt9v113_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "mt9v113 power-up err");
+		return ret;
+	}
+
+	/*
+	 * Soft reset and basic sys ctl
+	 */
+	ret = mt9v113_write_reg_array(client, mt9v113_reset);
+	if (ret)
+		return ret;
+
+	/* config & detect sensor */
+	ret = mt9v113_detect(dev, client);
+	if (ret) {
+		dev_err(&client->dev, "mt9v113_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+
+	ret = mt9v113_s_power(sd, 0);
+	if (ret) {
+		dev_err(&client->dev, "mt9v113 power down err");
+		return ret;
+	}
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	mt9v113_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int mt9v113_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct mt9v113_control *ctrl = mt9v113_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+static int mt9v113_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9v113_control *octrl = mt9v113_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9v113_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct mt9v113_control *octrl = mt9v113_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mt9v113_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret = 0;
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	if (enable) {
+
+		/* Make sure MCU will be turn on after LSC */
+		/* Arbitrary value from Aptina */
+		if (mt9v113_write_reg(c, MISENSOR_16BIT, MT9V113_REG_STBY_CTRL,
+				      0x0028))
+			dev_err(&c->dev, "err standby control");
+
+		ret = mt9v113_refresh(sd);
+		if (ret)
+			return ret;
+
+		ret = mt9v113_mipi_standby(sd, 0);
+		if (ret)
+			return ret;
+
+	} else {
+		ret = mt9v113_mipi_standby(sd, 1);
+		if (ret)
+			return ret;
+
+		ret = mt9v113_wait_mipi_standby(sd);
+		if (ret)
+			return ret;
+
+	}
+
+	return ret;
+}
+
+static int
+mt9v113_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = mt9v113_res[index].width;
+	fsize->discrete.height = mt9v113_res[index].height;
+
+	return 0;
+}
+
+static int mt9v113_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if ((mt9v113_res[i].width >= fival->width) &&
+		    (mt9v113_res[i].height >= fival->height))
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = mt9v113_res[index].fps;
+
+	return 0;
+}
+
+static int
+mt9v113_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_MT9V113, 0);
+}
+
+static int mt9v113_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int mt9v113_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+
+	unsigned int index = fse->index;
+
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = mt9v113_res[index].width;
+	fse->min_height = mt9v113_res[index].height;
+	fse->max_width = mt9v113_res[index].width;
+	fse->max_height = mt9v113_res[index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__mt9v113_get_pad_format(struct mt9v113_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,  "%s err. pad %x\n", __func__, pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+mt9v113_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9v113_device *snr = to_mt9v113_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9v113_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+mt9v113_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct mt9v113_device *snr = to_mt9v113_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__mt9v113_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int mt9v113_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct mt9v113_device *snr = to_mt9v113_sensor(sd);
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	snr->run_mode = param->parm.capture.capturemode;
+
+	return 0;
+}
+
+static int mt9v113_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct mt9v113_device *snr = to_mt9v113_sensor(sd);
+
+	if (frames == NULL)
+		return -EINVAL;
+
+	for (index = 0; index < N_RES; index++) {
+		if (mt9v113_res[index].res == snr->res)
+			break;
+	}
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	*frames = mt9v113_res[index].skip_frames;
+
+	return 0;
+}
+static const struct v4l2_subdev_video_ops mt9v113_video_ops = {
+	.try_mbus_fmt = mt9v113_try_mbus_fmt,
+	.s_mbus_fmt = mt9v113_set_mbus_fmt,
+	.g_mbus_fmt = mt9v113_get_mbus_fmt,
+	.s_stream = mt9v113_s_stream,
+	.s_parm = mt9v113_s_parm,
+	.enum_framesizes = mt9v113_enum_framesizes,
+	.enum_frameintervals = mt9v113_enum_frameintervals,
+};
+
+static struct v4l2_subdev_sensor_ops mt9v113_sensor_ops = {
+	.g_skip_frames	= mt9v113_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops mt9v113_core_ops = {
+	.g_chip_ident = mt9v113_g_chip_ident,
+	.queryctrl = mt9v113_queryctrl,
+	.g_ctrl = mt9v113_g_ctrl,
+	.s_ctrl = mt9v113_s_ctrl,
+	.s_power = mt9v113_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops mt9v113_pad_ops = {
+	.enum_mbus_code = mt9v113_enum_mbus_code,
+	.enum_frame_size = mt9v113_enum_frame_size,
+	.get_fmt = mt9v113_get_pad_format,
+	.set_fmt = mt9v113_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops mt9v113_ops = {
+	.core = &mt9v113_core_ops,
+	.video = &mt9v113_video_ops,
+	.pad = &mt9v113_pad_ops,
+	.sensor = &mt9v113_sensor_ops,
+};
+
+static const struct media_entity_operations mt9v113_entity_ops;
+
+
+static int mt9v113_remove(struct i2c_client *client)
+{
+	struct mt9v113_device *dev;
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+
+	dev = container_of(sd, struct mt9v113_device, sd);
+	dev->platform_data->csi_cfg(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+	return 0;
+}
+
+static int mt9v113_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct mt9v113_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &mt9v113_ops);
+	if (client->dev.platform_data) {
+		ret = mt9v113_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* REVISIT: Do we need media controller? */
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		mt9v113_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+	dev->run_mode = CI_MODE_PREVIEW;
+
+	return 0;
+}
+
+
+MODULE_DEVICE_TABLE(i2c, mt9v113_id);
+
+static struct i2c_driver mt9v113_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mt9v113"
+	},
+	.probe = mt9v113_probe,
+	.remove = __exit_p(mt9v113_remove),
+	.id_table = mt9v113_id,
+};
+
+static __init int init_mt9v113(void)
+{
+	return i2c_add_driver(&mt9v113_driver);
+}
+
+static __exit void exit_mt9v113(void)
+{
+	i2c_del_driver(&mt9v113_driver);
+}
+
+module_init(init_mt9v113);
+module_exit(exit_mt9v113);
+
+MODULE_AUTHOR("Tao Jing <jing.tao@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/mt9v113.h b/drivers/external_drivers/camera/drivers/media/i2c/mt9v113.h
new file mode 100644
index 0000000..5b09443
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/mt9v113.h
@@ -0,0 +1,1036 @@
+/*
+ * Support for mt9v113 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __MT9V113_H__
+#define __MT9V113_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+
+#define V4L2_IDENT_MT9V113 0x2280
+
+#define MT9V113_FOCAL_LENGTH_NUM	439	/* 4.39mm */
+#define MT9V113_FOCAL_LENGTH_DEM	100
+#define MT9V113_F_NUMBER_DEFAULT_NUM	24
+#define MT9V113_F_NUMBER_DEM	10
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9V113_FOCAL_LENGTH_DEFAULT 0xd00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define MT9V113_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define MT9V113_F_NUMBER_RANGE 0x180a180a
+
+#define MT9V113_REG_CHIPID	0x0
+#define MT9V113_REG_PLL_DIV	0x0010
+#define MT9V113_REG_PLL_P	0x0012
+#define MT9V113_REG_PLL_CTRL	0x0014
+#define MT9V113_REG_STBY_CTRL	0x0018
+#define MT9V113_REG_MISC_CTRL	0x001a
+
+#define MT9V113_REG_COL_PIPE_CTL	0x3210
+#define MT9V113_REG_OFIFO_CTRL	0x321c
+#define MT9V113_REG_KERNEL_CONFIG	0x33f4
+#define MT9V113_REG_MIPI_CTRL	0x3400
+#define MT9V113_REG_MIPI_STAT	0x3402
+
+#define MT9V113_REG_KERNEL_CONFIG_VAL	0x001b
+#define MT9V113_REG_COL_PIPE_CTL_VAL	0x9b8
+
+#define MIPI_STAT_BIT_MIPI_STBY_STAT	0
+#define MIPI_STAT_MASK_MIPI_STBY_STAT	(1 << MIPI_STAT_BIT_MIPI_STBY_STAT)
+
+#define MIPI_CTRL_BIT_MIPI_STBY_REQ	1
+#define MIPI_CTRL_MASK_MIPI_STBY_REQ	(1 << MIPI_CTRL_BIT_MIPI_STBY_REQ)
+
+#define MIPI_CTRL_BIT_MIPI_EOF_REQ	4
+#define MIPI_CTRL_MASK_MIPI_EOF_REQ	(1 << MIPI_CTRL_BIT_MIPI_EOF_REQ)
+
+#define STBY_CTRL_BIT_STBY_STAT	14
+#define STBY_CTRL_MASK_STBY_STAT	(1 << STBY_CTRL_BIT_STBY_STAT)
+
+#define STBY_CTRL_BIT_STBY_REQ	0
+#define STBY_CTRL_MASK_STBY_REQ	(1 << STBY_CTRL_BIT_STBY_REQ)
+
+#define PLL_CTRL_BIT_PLL_STAT	15
+#define PLL_CTRL_MASK_PLL_STAT	(1 << PLL_CTRL_BIT_PLL_STAT)
+
+#define PLL_CTRL_BIT_INIT_PLL	0
+#define PLL_CTRL_MASK_INIT_PLL	(1 << PLL_CTRL_BIT_INIT_PLL)
+
+#define PLL_CTRL_BIT_EN_PLL	1
+#define PLL_CTRL_MASK_EN_PLL	(1 << PLL_CTRL_BIT_EN_PLL)
+
+#define MIPI_CTRL_BIT_EN_MIPI	9
+#define MIPI_CTRL_MASK_EN_MIPI	(1 << MIPI_CTRL_BIT_EN_MIPI)
+
+#define OFIFO_CTRL_BIT_SENS_OUT	7
+#define OFIFO_CTRL_MASK_SENS_OUT	(1 << OFIFO_CTRL_BIT_SENS_OUT)
+
+#define MT9V113_MCU_VAR_ADDR	0x098c
+#define MT9V113_MCU_VAR_DATA0	0x0990
+#define MT9V113_MCU_VAR_DATA1	0x0992
+#define MT9V113_MCU_VAR_DATA2	0x0994
+#define MT9V113_MCU_VAR_DATA3	0x0996
+#define MT9V113_MCU_VAR_DATA4	0x0998
+#define MT9V113_MCU_VAR_DATA5	0x099a
+#define MT9V113_MCU_VAR_DATA6	0x099c
+#define MT9V113_MCU_VAR_DATA7	0x099e
+
+#define MT9V113_VAR_SEQ_CMD	0xa103
+#define SEQ_CMD_RUN		0x0
+#define SEQ_CMD_REFRESH_MODE	0x0006
+#define SEQ_CMD_REFRESH		0x0005
+#define MT9V113_VAR_SEQ_STATE	0xa104
+
+/* current integration time access */
+#define MT9V113_VAR_INTEGRATION_TIME	0x2222
+
+/* current virt_gain and d_gain access */
+#define MT9V113_VAR_AE_GAIN	0xa21c
+#define MT9V113_VAR_AE_D_GAIN	0x221f
+
+#define MT9V113_VAR_AE_MAX_INDEX	0xa20c
+#define MT9V113_AE_MAX_INDEX_0	0x0003
+#define MT9V113_AE_MAX_INDEX_1	0x000e
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+#define MISENSOR_TOK_RMW	0x0010  /* RMW operation */
+#define MISENSOR_TOK_MASK	0xfff0
+#define MISENSOR_AWB_STEADY	(1<<0)	/* awb steady */
+#define MISENSOR_AE_READY	(1<<3)	/* ae status ready */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+/* Supported resolutions */
+enum {
+	MT9V113_RES_QCIF,
+	MT9V113_RES_QVGA,
+	MT9V113_RES_CIF,
+	MT9V113_RES_VGA,
+};
+#define MT9V113_RES_VGA_SIZE_H		640
+#define MT9V113_RES_VGA_SIZE_V		480
+#define MT9V113_RES_CIF_SIZE_H		352
+#define MT9V113_RES_CIF_SIZE_V		288
+#define MT9V113_RES_QVGA_SIZE_H		320
+#define MT9V113_RES_QVGA_SIZE_V		240
+#define MT9V113_RES_QCIF_SIZE_H		176
+#define MT9V113_RES_QCIF_SIZE_V		144
+
+/* completion status polling requirements, usage based on Aptina .INI Rev2 */
+enum poll_reg {
+	NO_POLLING,
+	PRE_POLLING,
+	POST_POLLING,
+};
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u32 length;
+	u32 reg;
+	u32 val;	/* value or for read/mod/write, AND mask */
+	u32 val2;	/* optional; for rmw, OR mask */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct mt9v113_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int real_model_id;
+	int run_mode;
+
+	unsigned int res;
+};
+
+struct mt9v113_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct mt9v113_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int skip_frames;
+	int row_time;
+	bool used;
+	struct regval_list *regs;
+};
+
+struct mt9v113_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define MT9V113_MAX_WRITE_BUF_SIZE	32
+struct mt9v113_write_buffer {
+	u16 addr;
+	u8 data[MT9V113_MAX_WRITE_BUF_SIZE];
+};
+
+struct mt9v113_write_ctrl {
+	int index;
+	struct mt9v113_write_buffer buffer;
+};
+
+/*
+ * Modes supported by the mt9v113 driver.
+ * Please, keep them in ascending order.
+ */
+static struct mt9v113_res_struct mt9v113_res[] = {
+	{
+	.desc	= "QCIF",
+	.res	= MT9V113_RES_QCIF,
+	.width	= 176,
+	.height	= 144,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	.row_time = 62,
+	},
+	{
+	.desc	= "QVGA",
+	.res	= MT9V113_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	.row_time = 62,
+	},
+	{
+	.desc	= "CIF",
+	.res	= MT9V113_RES_CIF,
+	.width	= 352,
+	.height	= 288,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	.row_time = 62,
+	},
+	{
+	.desc	= "VGA",
+	.res	= MT9V113_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	.row_time = 62,
+	},
+};
+#define N_RES (ARRAY_SIZE(mt9v113_res))
+
+static const struct i2c_device_id mt9v113_id[] = {
+	{"mt9v113", 0},
+	{}
+};
+
+
+/*
+ * TBD
+ * Optimize for two context config
+ * Sensor pixel clock: 14MHZ
+ * Row Time: 62.286 / 872 clocks
+ * hblank time: (853-648) * ( 1 / 14E6) = 14.6uS
+ * vblank time: (547 - 488) * (853 / 14E6 ) = 3.59mS
+ * frame time: 516 * (853 / 14E6) = 33.3mS
+ */
+static struct misensor_reg const mt9v113_qcif_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00b0},/*      = 176*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0090},/*      = 144*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0280},/*      = 640*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01e0},/*      = 480*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0223},/*      = 547*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0355},/*      = 853*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0204},/*      = 516*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0354},/*      = 852*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x21},/*      = 33*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x23},/*      = 35*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x28},/*      = 40*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00a4},/*      = 164*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00a6},/*      = 166*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * TBD
+ * Optimize for two context config
+ *
+ * Sensor pixel clock: 14MHZ
+ * Row Time: 62.286 / 872 clocks
+ * hblank time: (853-648) * ( 1 / 14E6) = 14.6uS
+ * vblank time: (547 - 488) * (853 / 14E6 ) = 3.59mS
+ * frame time: 516 * (853 / 14E6) = 33.3mS
+ */
+static struct misensor_reg const mt9v113_cif_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0160},/*      = 352*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0120},/*      = 288*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0280},/*      = 640*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01e0},/*      = 480*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0223},/*      = 547*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0355},/*      = 853*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0204},/*      = 516*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0354},/*      = 852*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x21},/*      = 33*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x23},/*      = 35*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x28},/*      = 40*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00a4},/*      = 164*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00a6},/*      = 166*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * TBD
+ * Optimize for two context config
+ * Sensor pixel clock: 14MHZ
+ * Row Time: 62.286 / 872 clocks
+ * hblank time: (853-648) * ( 1 / 14E6) = 14.6uS
+ * vblank time: (547 - 488) * (853 / 14E6 ) = 3.59mS
+ * frame time: 516 * (853 / 14E6) = 33.3mS
+ */
+static struct misensor_reg const mt9v113_qvga_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0140},/*      = 320*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00f0},/*      = 240*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0280},/*      = 640*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01e0},/*      = 480*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0223},/*      = 547*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0355},/*      = 853*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0204},/*      = 516*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0354},/*      = 852*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x21},/*      = 33*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x23},/*      = 35*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x28},/*      = 40*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00a4},/*      = 164*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00a6},/*      = 166*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * TBD
+ * Optimize for two context config
+ *
+ * Sensor pixel clock: 14MHZ
+ * Row Time: 62.286 / 872 clocks
+ * hblank time: (853-648) * ( 1 / 14E6) = 14.6uS
+ * vblank time: (547 - 488) * (853 / 14E6 ) = 3.59mS
+ * frame time: 516 * (853 / 14E6) = 33.3mS
+ */
+static struct misensor_reg const mt9v113_vga_init[] = {
+	{MISENSOR_16BIT, 0x98c, 0x2703},/*Output Width (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0280},/*      = 640*/
+	{MISENSOR_16BIT, 0x98c, 0x2705},/*Output Height (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01e0},/*      = 480*/
+	{MISENSOR_16BIT, 0x98c, 0x2707},/*Output Width (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0280},/*      = 640*/
+	{MISENSOR_16BIT, 0x98c, 0x2709},/*Output Height (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01e0},/*      = 480*/
+	{MISENSOR_16BIT, 0x98c, 0x270d},/*Row Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x270f},/*column Start (a)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2711},/*Row end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2713},/*column end (a)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x2715},/*Row Speed (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x2717},/*Read Mode (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x2719},/*sensor_fine_correction (a)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x271b},/*sensor_fine_IT_min (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271d},/*sensor_fine_IT_max_margin (a)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x271f},/*frame Lines (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0223},/*      = 547*/
+	{MISENSOR_16BIT, 0x98c, 0x2721},/*Line Length (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0355},/*      = 853*/
+	{MISENSOR_16BIT, 0x98c, 0x2723},/*Row Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2725},/*column Start (b)*/
+	{MISENSOR_16BIT, 0x990, 0x000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2727},/*Row end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x1e7},/*      = 487*/
+	{MISENSOR_16BIT, 0x98c, 0x2729},/*column end (b)*/
+	{MISENSOR_16BIT, 0x990, 0x287},/*      = 647*/
+	{MISENSOR_16BIT, 0x98c, 0x272b},/*Row Speed (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0001},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0x272d},/*Read Mode (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0026},/*      = 38*/
+	{MISENSOR_16BIT, 0x98c, 0x272f},/*sensor_fine_correction (b)*/
+	{MISENSOR_16BIT, 0x990, 0x001a},/*      = 26*/
+	{MISENSOR_16BIT, 0x98c, 0x2731},/*sensor_fine_IT_min (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2733},/*sensor_fine_IT_max_margin (b)*/
+	{MISENSOR_16BIT, 0x990, 0x006b},/*      = 107*/
+	{MISENSOR_16BIT, 0x98c, 0x2735},/*frame Lines (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0204},/*      = 516*/
+	{MISENSOR_16BIT, 0x98c, 0x2737},/*Line Length (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0354},/*      = 852*/
+	{MISENSOR_16BIT, 0x98c, 0x2739},/*crop_X0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273b},/*crop_X1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x273d},/*crop_Y0 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x273f},/*crop_Y1 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x2747},/*crop_X0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x2749},/*crop_X1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x027f},/*      = 639*/
+	{MISENSOR_16BIT, 0x98c, 0x274b},/*crop_Y0 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x0000},/*      = 0*/
+	{MISENSOR_16BIT, 0x98c, 0x274d},/*crop_Y1 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x01df},/*      = 479*/
+	{MISENSOR_16BIT, 0x98c, 0x222d},/*R9 Step*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0xa408},/*search_f1_50*/
+	{MISENSOR_16BIT, 0x990, 0x21},/*      = 33*/
+	{MISENSOR_16BIT, 0x98c, 0xa409},/*search_f2_50*/
+	{MISENSOR_16BIT, 0x990, 0x23},/*      = 35*/
+	{MISENSOR_16BIT, 0x98c, 0xa40a},/*search_f1_60*/
+	{MISENSOR_16BIT, 0x990, 0x28},/*      = 40*/
+	{MISENSOR_16BIT, 0x98c, 0xa40b},/*search_f2_60*/
+	{MISENSOR_16BIT, 0x990, 0x2a},/*      = 42*/
+	{MISENSOR_16BIT, 0x98c, 0x2411},/*R9_Step_60 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x0089},/*      = 137*/
+	{MISENSOR_16BIT, 0x98c, 0x2413},/*R9_Step_50 (a)*/
+	{MISENSOR_16BIT, 0x990, 0x00a4},/*      = 164*/
+	{MISENSOR_16BIT, 0x98c, 0x2415},/*R9_Step_60 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x008b},/*      = 139*/
+	{MISENSOR_16BIT, 0x98c, 0x2417},/*R9_Step_50 (b)*/
+	{MISENSOR_16BIT, 0x990, 0x00a6},/*      = 166*/
+	{MISENSOR_16BIT, 0x98c, 0xa404},/*fd Mode*/
+	{MISENSOR_16BIT, 0x990, 0x10},/*      = 16*/
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_16BIT, 0x98c, 0xa40e},/*Stat_max*/
+	{MISENSOR_16BIT, 0x990, 0x03},/*      = 3*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x0a},/*      = 10*/
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/*
+ * Soft Reset
+ * 1: Set SYSCTL 0x001A[1:0] to 0x3 to initiate internal reset cycle.
+ * 2: Wait 6000 EXTCLK cycles.
+ * 3: Reset SYSCTL 0x001A[1:0] to 0x0 for normal operation.
+ *
+ * SYSCTL
+ * 1: bit9=0: Parallel output port is disabled.
+ * 2: bit8=0: Output is enabled (gpio ?)
+ * 3: bit4=1: GPIO not remained power on in standby
+ * 4: bit3=1: Reserved in DS, MIPI enabled ?
+ */
+static struct misensor_reg const mt9v113_reset[] = {
+	{MISENSOR_16BIT, 0x001a, 0x0011},
+	{MISENSOR_TOK_DELAY, 0, 1},
+	{MISENSOR_16BIT, 0x001a, 0x0010},
+	{MISENSOR_TOK_DELAY, 0, 1}, /* wait for normal operation */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/*
+ * Reduce IO Current
+ */
+static struct misensor_reg const mt9v113_reduce_current[] = {
+	{MISENSOR_16BIT, 0x098c, 0x02f0}, /* MCU_ADDRESS*/
+	{MISENSOR_16BIT, 0x0990, 0x0000}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x02f2}, /* MCU_ADDRESS*/
+	{MISENSOR_16BIT, 0x0990, 0x0210}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x02f4}, /* MCU_ADDRESS*/
+	{MISENSOR_16BIT, 0x0990, 0x001a}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2145}, /* [SEQ_ADVSEQ_CALLLIST_5]*/
+	{MISENSOR_16BIT, 0x0990, 0x02f4}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2134}, /* [SEQ_ADVSEQ_STACKOPTIONS]*/
+	{MISENSOR_16BIT, 0x0990, 0x0001}, /* MCU_DATA_0*/
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* AWB_CCM initialization */
+static struct misensor_reg const mt9v113_awb_ccm[] = {
+	{MISENSOR_16BIT, 0x098c, 0x2306}, /* MCU_ADDRESS [aWb_ccM_L_0]*/
+	{MISENSOR_16BIT, 0x0990, 0x0313}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2308}, /* MCU_ADDRESS [aWb_ccM_L_1]*/
+	{MISENSOR_16BIT, 0x0990, 0xff07}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x230a}, /* MCU_ADDRESS [aWb_ccM_L_2]*/
+	{MISENSOR_16BIT, 0x0990, 0xff39}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x230c}, /* MCU_ADDRESS [aWb_ccM_L_3]*/
+	{MISENSOR_16BIT, 0x0990, 0xff33}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x230e}, /* MCU_ADDRESS [aWb_ccM_L_4]*/
+	{MISENSOR_16BIT, 0x0990, 0x0369}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2310}, /* MCU_ADDRESS [aWb_ccM_L_5]*/
+	{MISENSOR_16BIT, 0x0990, 0xfed9}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2312}, /* MCU_ADDRESS [aWb_ccM_L_6]*/
+	{MISENSOR_16BIT, 0x0990, 0xff41}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2314}, /* MCU_ADDRESS [aWb_ccM_L_7]*/
+	{MISENSOR_16BIT, 0x0990, 0xfde3}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2316}, /* MCU_ADDRESS [aWb_ccM_L_8]*/
+	{MISENSOR_16BIT, 0x0990, 0x040e}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2318}, /* MCU_ADDRESS [aWb_ccM_L_9]*/
+	{MISENSOR_16BIT, 0x0990, 0x001c}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x231a}, /* MCU_ADDRESS [aWb_ccM_L_10]*/
+	{MISENSOR_16BIT, 0x0990, 0x0039}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x231c}, /* MCU_ADDRESS [aWb_ccM_RL_0]*/
+	{MISENSOR_16BIT, 0x0990, 0x0016}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x231e}, /* MCU_ADDRESS [aWb_ccM_RL_1]*/
+	{MISENSOR_16BIT, 0x0990, 0xff1a}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2320}, /* MCU_ADDRESS [aWb_ccM_RL_2]*/
+	{MISENSOR_16BIT, 0x0990, 0x00a8}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2322}, /* MCU_ADDRESS [aWb_ccM_RL_3]*/
+	{MISENSOR_16BIT, 0x0990, 0x0065}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2324}, /* MCU_ADDRESS [aWb_ccM_RL_4]*/
+	{MISENSOR_16BIT, 0x0990, 0xff2d}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2326}, /* MCU_ADDRESS [aWb_ccM_RL_5]*/
+	{MISENSOR_16BIT, 0x0990, 0x0036}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2328}, /* MCU_ADDRESS [aWb_ccM_RL_6]*/
+	{MISENSOR_16BIT, 0x0990, 0x008b}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x232a}, /* MCU_ADDRESS [aWb_ccM_RL_7]*/
+	{MISENSOR_16BIT, 0x0990, 0x014b}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x232c}, /* MCU_ADDRESS [aWb_ccM_RL_8]*/
+	{MISENSOR_16BIT, 0x0990, 0xfe49}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x232e}, /* MCU_ADDRESS [aWb_ccM_RL_9]*/
+	{MISENSOR_16BIT, 0x0990, 0x0001}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2330}, /* MCU_ADDRESS [aWb_ccM_RL_10]*/
+	{MISENSOR_16BIT, 0x0990, 0xffef}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa348}, /* [aWb_GaIN_bUffeR_SPeed]*/
+	{MISENSOR_16BIT, 0x0990, 0x0008}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa349}, /* MCU_ADDRESS [aWb_JUMP_dIVISOR]*/
+	{MISENSOR_16BIT, 0x0990, 0x0002}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa34a}, /* MCU_ADDRESS [aWb_GaIN_MIN]*/
+	{MISENSOR_16BIT, 0x0990, 0x0090}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa34b}, /* MCU_ADDRESS [aWb_GaIN_MaX]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ff}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa34c}, /* MCU_ADDRESS [aWb_GaINMIN_b]*/
+	{MISENSOR_16BIT, 0x0990, 0x0075}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa34d}, /* MCU_ADDRESS [aWb_GaINMaX_b]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ef}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa351}, /* [aWb_ccM_POSITION_MIN]*/
+	{MISENSOR_16BIT, 0x0990, 0x0000}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa352}, /* [aWb_ccM_POSITION_MaX]*/
+	{MISENSOR_16BIT, 0x0990, 0x007f}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa354}, /* MCU_ADDRESS [aWb_SaTURaTION]*/
+	{MISENSOR_16BIT, 0x0990, 0x0043}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa355}, /* MCU_ADDRESS [aWb_MOde]*/
+	{MISENSOR_16BIT, 0x0990, 0x0001}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa35d}, /* [aWb_STeadY_bGaIN_OUT_MIN]*/
+	{MISENSOR_16BIT, 0x0990, 0x0078}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa35e}, /* [aWb_STeadY_bGaIN_OUT_MaX]*/
+	{MISENSOR_16BIT, 0x0990, 0x0086}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa35f}, /* [aWb_STeadY_bGaIN_IN_MIN]*/
+	{MISENSOR_16BIT, 0x0990, 0x007e}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa360}, /* [aWb_STeadY_bGaIN_IN_MaX]*/
+	{MISENSOR_16BIT, 0x0990, 0x0082}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0x2361}, /* MCU_ADDRESS [aWb_cNT_PXL_TH]*/
+	{MISENSOR_16BIT, 0x0990, 0x0040}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa363}, /* MCU_ADDRESS [aWb_TG_MIN0]*/
+	{MISENSOR_16BIT, 0x0990, 0x00d2}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa364}, /* MCU_ADDRESS [aWb_TG_MaX0]*/
+	{MISENSOR_16BIT, 0x0990, 0x00f6}, /* MCU_DATA_0*/
+
+	/* AWB Adjust */
+	{MISENSOR_16BIT, 0x098c, 0xa369}, /* MCU_ADDRESS [aWb_KR_R] */
+	{MISENSOR_16BIT, 0x0990, 0x0082}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa36a}, /* MCU_ADDRESS [aWb_KG_R]*/
+	{MISENSOR_16BIT, 0x0990, 0x0082}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa36b}, /* MCU_ADDRESS [aWb_KB_R] */
+	{MISENSOR_16BIT, 0x0990, 0x0078}, /* MCU_DATA_0*/
+
+	/* AE */
+	{MISENSOR_16BIT, 0x098c, 0xa24f}, /* MCU_ADDRESS [AE_BASETARGET] */
+	{MISENSOR_16BIT, 0x0990, 0x0038}, /* MCU_DATA_0*/
+
+	{MISENSOR_16BIT, 0x098c, 0xa302}, /* MCU_ADDRESS [aWb_WINdOW_POS]*/
+	{MISENSOR_16BIT, 0x0990, 0x0000}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa303}, /* MCU_ADDRESS [aWb_WINdOW_SIZe]*/
+	{MISENSOR_16BIT, 0x0990, 0x00ef}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xab20}, /* MCU_ADDRESS [HG_LL_SaT1]*/
+	{MISENSOR_16BIT, 0x0990, 0x0024}, /* MCU_DATA_0*/
+
+/*force aWb Setting for fW bootup*/
+	{MISENSOR_16BIT, 0x098c, 0xa353}, /* MCU_ADDRESS [aWb_ccM_POSITION]*/
+	{MISENSOR_16BIT, 0x0990, 0x0063}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa34e}, /* MCU_ADDRESS [aWb_GaIN_R]*/
+	{MISENSOR_16BIT, 0x0990, 0x00fd}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa34f}, /* MCU_ADDRESS [aWb_GaIN_G]*/
+	{MISENSOR_16BIT, 0x0990, 0x0080}, /* MCU_DATA_0*/
+	{MISENSOR_16BIT, 0x098c, 0xa350}, /* MCU_ADDRESS [aWb_GaIN_b]*/
+	{MISENSOR_16BIT, 0x0990, 0x007d}, /* MCU_DATA_0*/
+
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* CPIPE_Calibration */
+static struct misensor_reg const mt9v113_cpipe_calibration[] = {
+	{MISENSOR_16BIT, 0x098c, 0x274f}, /*MOde_dec_cTRL_b*/
+	{MISENSOR_16BIT, 0x0990, 0x0004},
+	{MISENSOR_16BIT, 0x098c, 0x2741}, /*MOde_dec_cTRL_a*/
+	{MISENSOR_16BIT, 0x0990, 0x0004},
+	{MISENSOR_16BIT, 0x098c, 0x275f}, /*MOde_cOMMONMOde*/
+	{MISENSOR_16BIT, 0x0990, 0x0594},
+	{MISENSOR_16BIT, 0x098c, 0x2761}, /*MOde_cOMMONMOde*/
+	{MISENSOR_16BIT, 0x0990, 0x0094},
+	{MISENSOR_TOK_TERM, 0, 0},
+};
+
+static struct misensor_reg const mt9v113_cpipe_perference[] = {
+	{MISENSOR_16BIT, 0x098c, 0xab1f}, /*HG_LLMOde*/
+	{MISENSOR_16BIT, 0x0990, 0x00c7},
+	{MISENSOR_16BIT, 0x098c, 0xab31}, /*HG_NR_STOP_G*/
+	{MISENSOR_16BIT, 0x0990, 0x001e},
+	{MISENSOR_16BIT, 0x098c, 0xab20}, /*HG_LL_SaT1*/
+	{MISENSOR_16BIT, 0x0990, 0x0054},
+	{MISENSOR_16BIT, 0x098c, 0xab21}, /*HG_LL_INTeRPTHReSH1*/
+	{MISENSOR_16BIT, 0x0990, 0x0016},
+	{MISENSOR_16BIT, 0x098c, 0xab22}, /*HG_LL_aPcORR1*/
+	{MISENSOR_16BIT, 0x0990, 0x0002},
+	{MISENSOR_16BIT, 0x098c, 0xab24}, /*HG_LL_STaT2*/
+	{MISENSOR_16BIT, 0x0990, 0x0005},
+	{MISENSOR_16BIT, 0x098c, 0xab25}, /*HG_LL_INTeRPTHReSH2*/
+	{MISENSOR_16BIT, 0x0990, 0x0034},
+	{MISENSOR_16BIT, 0x098c, 0x2b28}, /*HG_LL_bRIGHTNeSSSTaRT*/
+	{MISENSOR_16BIT, 0x0990, 0x170c},
+	{MISENSOR_16BIT, 0x098c, 0x2b2a}, /*HG_LL_bRIGHTNeSSSSTOP*/
+	{MISENSOR_16BIT, 0x0990, 0x3e80},
+
+	{MISENSOR_TOK_TERM, 0, 0},
+};
+
+/* Increase Flicker detection */
+static struct misensor_reg const mt9v113_high_flicker[] = {
+	{MISENSOR_16BIT, 0x98c, 0xa40d},/*Stat_min*/
+	{MISENSOR_16BIT, 0x990, 0x01},/*      = 1*/
+	{MISENSOR_16BIT, 0x98c, 0xa410},/*Min_amplitude*/
+	{MISENSOR_16BIT, 0x990, 0x02},/*      = 2*/
+	{MISENSOR_TOK_TERM, 0, 0},
+};
+
+/* LSC 95% */
+static struct misensor_reg const mt9v113_lsc_95[] = {
+	{MISENSOR_16BIT, 0x364e, 0x00f0},
+	{MISENSOR_16BIT, 0x3650, 0x954D},
+	{MISENSOR_16BIT, 0x3652, 0x6213},
+	{MISENSOR_16BIT, 0x3654, 0x9391},
+	{MISENSOR_16BIT, 0x3656, 0xb2D5},
+	{MISENSOR_16BIT, 0x3658, 0x00b0},
+	{MISENSOR_16BIT, 0x365a, 0x816c},
+	{MISENSOR_16BIT, 0x365c, 0x6e13},
+	{MISENSOR_16BIT, 0x365e, 0x9411},
+	{MISENSOR_16BIT, 0x3660, 0x9D75},
+	{MISENSOR_16BIT, 0x3662, 0x00D0},
+	{MISENSOR_16BIT, 0x3664, 0x20cc},
+	{MISENSOR_16BIT, 0x3666, 0x5953},
+	{MISENSOR_16BIT, 0x3668, 0x8131},
+	{MISENSOR_16BIT, 0x366a, 0xDD55},
+	{MISENSOR_16BIT, 0x366c, 0x00D0},
+	{MISENSOR_16BIT, 0x366e, 0xe4cD},
+	{MISENSOR_16BIT, 0x3670, 0x6473},
+	{MISENSOR_16BIT, 0x3672, 0x87b1},
+	{MISENSOR_16BIT, 0x3674, 0xaD95},
+	{MISENSOR_16BIT, 0x3676, 0x68ac},
+	{MISENSOR_16BIT, 0x3678, 0xa130},
+	{MISENSOR_16BIT, 0x367a, 0x7251},
+	{MISENSOR_16BIT, 0x367c, 0xcb11},
+	{MISENSOR_16BIT, 0x367e, 0x64eb},
+	{MISENSOR_16BIT, 0x3680, 0x44eD},
+	{MISENSOR_16BIT, 0x3682, 0x9350},
+	{MISENSOR_16BIT, 0x3684, 0x7152},
+	{MISENSOR_16BIT, 0x3686, 0x8eb2},
+	{MISENSOR_16BIT, 0x3688, 0xa634},
+	{MISENSOR_16BIT, 0x368a, 0x7e4D},
+	{MISENSOR_16BIT, 0x368c, 0xec6f},
+	{MISENSOR_16BIT, 0x368e, 0x0691},
+	{MISENSOR_16BIT, 0x3690, 0x5070},
+	{MISENSOR_16BIT, 0x3692, 0xffae},
+	{MISENSOR_16BIT, 0x3694, 0x016D},
+	{MISENSOR_16BIT, 0x3696, 0x9970},
+	{MISENSOR_16BIT, 0x3698, 0x1112},
+	{MISENSOR_16BIT, 0x369a, 0x8072},
+	{MISENSOR_16BIT, 0x369c, 0x8072},
+	{MISENSOR_16BIT, 0x369e, 0x1b94},
+	{MISENSOR_16BIT, 0x36a0, 0xb9f3},
+	{MISENSOR_16BIT, 0x36a2, 0x88b7},
+	{MISENSOR_16BIT, 0x36a4, 0x1c37},
+	{MISENSOR_16BIT, 0x36a6, 0x2b99},
+	{MISENSOR_16BIT, 0x36a8, 0x22b4},
+	{MISENSOR_16BIT, 0x36aa, 0xe573},
+	{MISENSOR_16BIT, 0x36ac, 0x8f36},
+	{MISENSOR_16BIT, 0x36ae, 0x0eb7},
+	{MISENSOR_16BIT, 0x36b0, 0x0ff7},
+	{MISENSOR_16BIT, 0x36b2, 0x0f74},
+	{MISENSOR_16BIT, 0x36b4, 0xc6b3},
+	{MISENSOR_16BIT, 0x36b6, 0xacb7},
+	{MISENSOR_16BIT, 0x36b8, 0x0797},
+	{MISENSOR_16BIT, 0x36ba, 0x73b9},
+	{MISENSOR_16BIT, 0x36bc, 0x1694},
+	{MISENSOR_16BIT, 0x36be, 0xDa13},
+	{MISENSOR_16BIT, 0x36c0, 0xf636},
+	{MISENSOR_16BIT, 0x36c2, 0x2f17},
+	{MISENSOR_16BIT, 0x36c4, 0x7af8},
+	{MISENSOR_16BIT, 0x36c6, 0x9bD1},
+	{MISENSOR_16BIT, 0x36c8, 0x8973},
+	{MISENSOR_16BIT, 0x36ca, 0x13D6},
+	{MISENSOR_16BIT, 0x36cc, 0x55D6},
+	{MISENSOR_16BIT, 0x36ce, 0xb7f9},
+	{MISENSOR_16BIT, 0x36D0, 0xc94D},
+	{MISENSOR_16BIT, 0x36D2, 0xc913},
+	{MISENSOR_16BIT, 0x36D4, 0x5D35},
+	{MISENSOR_16BIT, 0x36D6, 0x0277},
+	{MISENSOR_16BIT, 0x36D8, 0xebf7},
+	{MISENSOR_16BIT, 0x36Da, 0x63b0},
+	{MISENSOR_16BIT, 0x36Dc, 0xcbf1},
+	{MISENSOR_16BIT, 0x36De, 0x25b6},
+	{MISENSOR_16BIT, 0x36e0, 0x3135},
+	{MISENSOR_16BIT, 0x36e2, 0xa8f9},
+	{MISENSOR_16BIT, 0x36e4, 0xf630},
+	{MISENSOR_16BIT, 0x36e6, 0xca13},
+	{MISENSOR_16BIT, 0x36e8, 0x7315},
+	{MISENSOR_16BIT, 0x36ea, 0x6296},
+	{MISENSOR_16BIT, 0x36ec, 0x8999},
+	{MISENSOR_16BIT, 0x36ee, 0xa0D5},
+	{MISENSOR_16BIT, 0x36f0, 0x7bf6},
+	{MISENSOR_16BIT, 0x36f2, 0x3459},
+	{MISENSOR_16BIT, 0x36f4, 0x8f3a},
+	{MISENSOR_16BIT, 0x36f6, 0xcfDc},
+	{MISENSOR_16BIT, 0x36f8, 0xaa74},
+	{MISENSOR_16BIT, 0x36fa, 0x01D7},
+	{MISENSOR_16BIT, 0x36fc, 0x82D8},
+	{MISENSOR_16BIT, 0x36fe, 0xa359},
+	{MISENSOR_16BIT, 0x3700, 0x187b},
+	{MISENSOR_16BIT, 0x3702, 0xecf5},
+	{MISENSOR_16BIT, 0x3704, 0x0e37},
+	{MISENSOR_16BIT, 0x3706, 0x0DDa},
+	{MISENSOR_16BIT, 0x3708, 0xacfa},
+	{MISENSOR_16BIT, 0x370a, 0x81fD},
+	{MISENSOR_16BIT, 0x370c, 0x84f5},
+	{MISENSOR_16BIT, 0x370e, 0x1137},
+	{MISENSOR_16BIT, 0x3710, 0x0619},
+	{MISENSOR_16BIT, 0x3712, 0xae5a},
+	{MISENSOR_16BIT, 0x3714, 0xDe5b},
+	{MISENSOR_16BIT, 0x3644, 0x0130},
+	{MISENSOR_16BIT, 0x3642, 0x00f0},
+
+	{MISENSOR_TOK_TERM, 0, 0},
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov2722.c b/drivers/external_drivers/camera/drivers/media/i2c/ov2722.c
new file mode 100644
index 0000000..79ddfd1
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov2722.c
@@ -0,0 +1,1449 @@
+/*
+ * Support for OmniVision OV2722 1080p HD camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/io.h>
+
+#include "ov2722.h"
+
+/* i2c read/write stuff */
+static int ov2722_read_reg(struct i2c_client *client,
+			   u16 data_length, u16 reg, u16 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[6];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != OV2722_8BIT && data_length != OV2722_16BIT
+					&& data_length != OV2722_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == OV2722_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == OV2722_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int ov2722_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int ov2722_write_reg(struct i2c_client *client, u16 data_length,
+							u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg = (u16 *)data;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (data_length != OV2722_8BIT && data_length != OV2722_16BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == OV2722_8BIT) {
+		data[2] = (u8)(val);
+	} else {
+		/* OV2722_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
+
+	ret = ov2722_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * ov2722_write_reg_array - Initializes a list of OV2722 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __ov2722_flush_reg_array, __ov2722_buf_reg_array() and
+ * __ov2722_write_reg_is_consecutive() are internal functions to
+ * ov2722_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __ov2722_flush_reg_array(struct i2c_client *client,
+				    struct ov2722_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov2722_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __ov2722_buf_reg_array(struct i2c_client *client,
+				  struct ov2722_write_ctrl *ctrl,
+				  const struct ov2722_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case OV2722_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case OV2722_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= OV2722_MAX_WRITE_BUF_SIZE)
+		return __ov2722_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int __ov2722_write_reg_is_consecutive(struct i2c_client *client,
+					     struct ov2722_write_ctrl *ctrl,
+					     const struct ov2722_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int ov2722_write_reg_array(struct i2c_client *client,
+				  const struct ov2722_reg *reglist)
+{
+	const struct ov2722_reg *next = reglist;
+	struct ov2722_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != OV2722_TOK_TERM; next++) {
+		switch (next->type & OV2722_TOK_MASK) {
+		case OV2722_TOK_DELAY:
+			err = __ov2722_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__ov2722_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __ov2722_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __ov2722_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __ov2722_flush_reg_array(client, &ctrl);
+}
+static int ov2722_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV2722_FOCAL_LENGTH_NUM << 16) | OV2722_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov2722_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (OV2722_F_NUMBER_DEFAULT_NUM << 16) | OV2722_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov2722_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV2722_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV2722_F_NUMBER_DEM << 16) |
+		(OV2722_F_NUMBER_DEFAULT_NUM << 8) | OV2722_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov2722_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct ov2722_resolution *res)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	const unsigned int ext_clk_freq_hz = 19200000;
+	const unsigned int pll_invariant_div = 10;
+	unsigned int pix_clk_freq_hz;
+	u16 pre_pll_clk_div;
+	u16 pll_multiplier;
+	u16 op_pix_clk_div;
+	u16 reg_val;
+	int ret;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* pixel clock calculattion */
+	ret =  ov2722_read_reg(client, OV2722_8BIT,
+				OV2722_SC_CMMN_PLL_CTRL3, &pre_pll_clk_div);
+	if (ret)
+		return ret;
+
+	ret =  ov2722_read_reg(client, OV2722_8BIT,
+				OV2722_SC_CMMN_PLL_MULTIPLIER, &pll_multiplier);
+	if (ret)
+		return ret;
+
+	ret =  ov2722_read_reg(client, OV2722_8BIT,
+				OV2722_SC_CMMN_PLL_DEBUG_OPT, &op_pix_clk_div);
+	if (ret)
+		return ret;
+
+	pre_pll_clk_div = (pre_pll_clk_div & 0x70) >> 4;
+	if (0 == pre_pll_clk_div)
+		return -EINVAL;
+
+	pll_multiplier = pll_multiplier & 0x7f;
+	op_pix_clk_div = op_pix_clk_div & 0x03;
+	pix_clk_freq_hz = ext_clk_freq_hz / pre_pll_clk_div * pll_multiplier
+				* op_pix_clk_div/pll_invariant_div;
+
+	dev->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+	buf->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+
+	/* get integration time */
+	buf->coarse_integration_time_min = OV2722_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+					OV2722_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = OV2722_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					OV2722_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = OV2722_FINE_INTG_TIME_MIN;
+	buf->frame_length_lines = res->lines_per_frame;
+	buf->line_length_pck = res->pixels_per_line;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	ret =  ov2722_read_reg(client, OV2722_16BIT,
+					OV2722_H_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = reg_val;
+
+	ret =  ov2722_read_reg(client, OV2722_16BIT,
+					OV2722_V_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = reg_val;
+
+	ret = ov2722_read_reg(client, OV2722_16BIT,
+					OV2722_H_CROP_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_end = reg_val;
+
+	ret = ov2722_read_reg(client, OV2722_16BIT,
+					OV2722_V_CROP_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_end = reg_val;
+
+	ret = ov2722_read_reg(client, OV2722_16BIT,
+					OV2722_H_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_width = reg_val;
+
+	ret = ov2722_read_reg(client, OV2722_16BIT,
+					OV2722_V_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_height = reg_val;
+
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
+	return 0;
+}
+
+static long __ov2722_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 vts;
+	int frame_length;
+	int ret;
+
+	ret = ov2722_read_reg(client, OV2722_16BIT,
+					OV2722_VTS_DIFF_H, &vts);
+	if (ret)
+		return ret;
+
+	if ((coarse_itg + 6) >= vts)
+		frame_length = (coarse_itg + 6) - vts;
+	else
+		frame_length = 0;
+	coarse_itg <<= 4;
+	digitgain <<= 2;
+
+	/* group hold start */
+	ret = ov2722_write_reg(client, OV2722_8BIT, OV2722_GROUP_ACCESS, 0);
+	if (ret)
+		return ret;
+
+	ret = ov2722_write_reg(client, OV2722_16BIT,
+				OV2722_VTS_DIFF_H, frame_length >> 8);
+	if (ret)
+		return ret;
+
+	/* set exposure */
+	ret = ov2722_write_reg(client, OV2722_8BIT,
+					OV2722_AEC_PK_EXPO_L,
+					coarse_itg & 0xff);
+	if (ret)
+		return ret;
+
+	ret = ov2722_write_reg(client, OV2722_16BIT,
+					OV2722_AEC_PK_EXPO_H,
+					(coarse_itg >> 8) & 0xfff);
+	if (ret)
+		return ret;
+
+	/* set analog gain */
+	ret = ov2722_write_reg(client, OV2722_16BIT,
+					OV2722_AGC_ADJ_H, gain);
+	if (ret)
+		return ret;
+
+	/* set digital gain */
+	ret = ov2722_write_reg(client, OV2722_16BIT,
+				OV2722_MWB_GAIN_R_H, digitgain);
+	if (ret)
+		return ret;
+
+	ret = ov2722_write_reg(client, OV2722_16BIT,
+				OV2722_MWB_GAIN_G_H, digitgain);
+	if (ret)
+		return ret;
+
+	ret = ov2722_write_reg(client, OV2722_16BIT,
+				OV2722_MWB_GAIN_B_H, digitgain);
+	if (ret)
+		return ret;
+
+	/* group hold end */
+	ret = ov2722_write_reg(client, OV2722_8BIT,
+					OV2722_GROUP_ACCESS, 0x10);
+	if (ret)
+		return ret;
+
+	/* group hold launch */
+	ret = ov2722_write_reg(client, OV2722_8BIT,
+					OV2722_GROUP_ACCESS, 0xa0);
+
+	return ret;
+}
+
+static int ov2722_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov2722_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long ov2722_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	int exp = exposure->integration_time[0];
+	int gain = exposure->gain[0];
+	int digitgain = exposure->gain[1];
+
+	/* we should not accept the invalid value below. */
+	if (gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	return ov2722_set_exposure(sd, exp, gain, digitgain);
+}
+
+static long ov2722_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return ov2722_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int ov2722_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 reg_v, reg_v2;
+	int ret;
+
+	/* get exposure */
+	ret = ov2722_read_reg(client, OV2722_8BIT,
+					OV2722_AEC_PK_EXPO_L,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	ret = ov2722_read_reg(client, OV2722_8BIT,
+					OV2722_AEC_PK_EXPO_M,
+					&reg_v2);
+	if (ret)
+		goto err;
+
+	reg_v += reg_v2 << 8;
+	ret = ov2722_read_reg(client, OV2722_8BIT,
+					OV2722_AEC_PK_EXPO_H,
+					&reg_v2);
+	if (ret)
+		goto err;
+
+	*value = reg_v + (((u32)reg_v2 << 16));
+err:
+	return ret;
+}
+struct ov2722_control ov2722_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov2722_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = OV2722_FOCAL_LENGTH_DEFAULT,
+			.maximum = OV2722_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV2722_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov2722_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = OV2722_F_NUMBER_DEFAULT,
+			.maximum = OV2722_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV2722_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov2722_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = OV2722_F_NUMBER_RANGE,
+			.maximum =  OV2722_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV2722_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov2722_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov2722_controls))
+
+static int ov2722_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov2722_device *dev = container_of(ctrl->handler, struct ov2722_device,
+			ctrl_handler);
+	unsigned int val;
+
+	switch (ctrl->id) {
+	case V4L2_CID_LINK_FREQ:
+		val = ov2722_res[dev->fmt_idx].mipi_freq;
+		if (val == 0)
+			return -EINVAL;
+
+		ctrl->val = val * 1000;			/* To Hz */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static struct ov2722_control *ov2722_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (ov2722_controls[i].qc.id == id)
+			return &ov2722_controls[i];
+	return NULL;
+}
+
+static int ov2722_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov2722_control *ctrl = ov2722_find_control(qc->id);
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int ov2722_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov2722_control *s_ctrl;
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = ov2722_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov2722_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov2722_control *octrl = ov2722_find_control(ctrl->id);
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov2722_init(struct v4l2_subdev *sd)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+
+	/* restore settings */
+	ov2722_res = ov2722_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
+	usleep_range(5000, 6000);
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_power;
+	}
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* according to DS, 20ms is needed between PWDN and i2c access */
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int ov2722_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return ov2722_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct ov2722_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct ov2722_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &ov2722_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != ov2722_res[i].width)
+			continue;
+		if (h != ov2722_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int ov2722_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+					fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = ov2722_res[N_RES - 1].width;
+		fmt->height = ov2722_res[N_RES - 1].height;
+	} else {
+		fmt->width = ov2722_res[idx].width;
+		fmt->height = ov2722_res[idx].height;
+	}
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+/* TODO: remove it. */
+static int startup(struct v4l2_subdev *sd)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	ret = ov2722_write_reg(client, OV2722_8BIT,
+					OV2722_SW_RESET, 0x01);
+	if (ret) {
+		dev_err(&client->dev, "ov2722 reset err.\n");
+		return ret;
+	}
+
+	ret = ov2722_write_reg_array(client, ov2722_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "ov2722 write register err.\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ov2722_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *ov2722_info = NULL;
+	int ret = 0;
+
+	ov2722_info = v4l2_get_subdev_hostdata(sd);
+	if (ov2722_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = ov2722_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width,
+					      fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	ret = startup(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov2722 startup err\n");
+		goto err;
+	}
+
+	ret = ov2722_get_intg_factor(client, ov2722_info,
+					&ov2722_res[dev->fmt_idx]);
+	if (ret)
+		dev_err(&client->dev, "failed to get integration_factor\n");
+
+err:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int ov2722_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = ov2722_res[dev->fmt_idx].width;
+	fmt->height = ov2722_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov2722_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 high, low;
+	int ret;
+	u16 id;
+	u8 revision;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = ov2722_read_reg(client, OV2722_8BIT,
+					OV2722_SC_CMMN_CHIP_ID_H, &high);
+	if (ret) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", high);
+		return -ENODEV;
+	}
+	ret = ov2722_read_reg(client, OV2722_8BIT,
+					OV2722_SC_CMMN_CHIP_ID_L, &low);
+	id = ((((u16) high) << 8) | (u16) low);
+
+	if ((id != OV2722_ID) && (id != OV2720_ID)) {
+		dev_err(&client->dev, "sensor ID error\n");
+		return -ENODEV;
+	}
+
+	ret = ov2722_read_reg(client, OV2722_8BIT,
+					OV2722_SC_CMMN_SUB_ID, &high);
+	revision = (u8) high & 0x0f;
+
+	dev_dbg(&client->dev, "sensor_revision = 0x%x\n", revision);
+	dev_dbg(&client->dev, "detect ov2722 success\n");
+	return 0;
+}
+
+static int ov2722_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = ov2722_write_reg(client, OV2722_8BIT, OV2722_SW_STREAM,
+				enable ? OV2722_START_STREAMING :
+				OV2722_STOP_STREAMING);
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+/* ov2722 enum frame size, frame intervals */
+static int ov2722_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov2722_res[index].width;
+	fsize->discrete.height = ov2722_res[index].height;
+	fsize->reserved[0] = ov2722_res[index].used;
+
+	return 0;
+}
+
+static int ov2722_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = ov2722_res[index].width;
+	fival->height = ov2722_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov2722_res[index].fps;
+
+	return 0;
+}
+
+static int ov2722_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov2722_s_config(struct v4l2_subdev *sd,
+			   int irq, void *platform_data)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	dev->platform_data =
+		(struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "platform init err\n");
+			goto platform_init_failed;
+		}
+	}
+
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov2722 power-off err.\n");
+		goto fail_power_off;
+	}
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov2722 power-up err.\n");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = ov2722_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "ov2722_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov2722 power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+platform_init_failed:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int ov2722_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			ov2722_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int ov2722_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		ov2722_res = ov2722_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		ov2722_res = ov2722_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		ov2722_res = ov2722_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov2722_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = ov2722_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int ov2722_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int ov2722_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov2722_res[index].width;
+	fse->min_height = ov2722_res[index].height;
+	fse->max_width = ov2722_res[index].width;
+	fse->max_height = ov2722_res[index].height;
+
+	return 0;
+
+}
+
+static struct v4l2_mbus_framefmt *
+__ov2722_get_pad_format(struct ov2722_device *sensor,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+			"__ov2722_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int ov2722_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct ov2722_device *snr = to_ov2722_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__ov2722_get_pad_format(snr, fh, fmt->pad, fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int ov2722_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct ov2722_device *snr = to_ov2722_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int ov2722_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = ov2722_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops ov2722_sensor_ops = {
+	.g_skip_frames	= ov2722_g_skip_frames,
+};
+
+static struct v4l2_ctrl_ops ov2722_ctrl_ops = {
+	.g_volatile_ctrl = ov2722_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config v4l2_ctrl_link_freq = {
+	.ops = &ov2722_ctrl_ops,
+	.id = V4L2_CID_LINK_FREQ,
+	.name = "Link Frequency",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 1,
+	.max = 1500000 * 1000,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_subdev_video_ops ov2722_video_ops = {
+	.s_stream = ov2722_s_stream,
+	.g_parm = ov2722_g_parm,
+	.s_parm = ov2722_s_parm,
+	.enum_framesizes = ov2722_enum_framesizes,
+	.enum_frameintervals = ov2722_enum_frameintervals,
+	.enum_mbus_fmt = ov2722_enum_mbus_fmt,
+	.try_mbus_fmt = ov2722_try_mbus_fmt,
+	.g_mbus_fmt = ov2722_g_mbus_fmt,
+	.s_mbus_fmt = ov2722_s_mbus_fmt,
+	.g_frame_interval = ov2722_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops ov2722_core_ops = {
+	.s_power = ov2722_s_power,
+	.queryctrl = ov2722_queryctrl,
+	.g_ctrl = ov2722_g_ctrl,
+	.s_ctrl = ov2722_s_ctrl,
+	.ioctl = ov2722_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops ov2722_pad_ops = {
+	.enum_mbus_code = ov2722_enum_mbus_code,
+	.enum_frame_size = ov2722_enum_frame_size,
+	.get_fmt = ov2722_get_pad_format,
+	.set_fmt = ov2722_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ov2722_ops = {
+	.core = &ov2722_core_ops,
+	.video = &ov2722_video_ops,
+	.pad = &ov2722_pad_ops,
+	.sensor = &ov2722_sensor_ops,
+};
+
+static int ov2722_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov2722_device *dev = to_ov2722_sensor(sd);
+	dev_dbg(&client->dev, "ov2722_remove...\n");
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int __ov2722_init_ctrl_handler(struct ov2722_device *dev)
+{
+	struct v4l2_ctrl_handler *hdl;
+
+	hdl = &dev->ctrl_handler;
+
+	v4l2_ctrl_handler_init(&dev->ctrl_handler, 3);
+
+	dev->link_freq = v4l2_ctrl_new_custom(&dev->ctrl_handler,
+					      &v4l2_ctrl_link_freq,
+					      NULL);
+
+	if (dev->ctrl_handler.error || dev->link_freq == NULL) {
+		return dev->ctrl_handler.error;
+	}
+
+	dev->sd.ctrl_handler = hdl;
+
+	return 0;
+}
+static int ov2722_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct ov2722_device *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov2722_ops);
+
+	if (client->dev.platform_data) {
+		ret = ov2722_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	ret = __ov2722_init_ctrl_handler(dev);
+	if (ret)
+		goto out_ctrl_handler_free;
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		ov2722_remove(client);
+
+	return ret;
+
+out_ctrl_handler_free:
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov2722_id);
+static struct i2c_driver ov2722_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV2722_NAME,
+	},
+	.probe = ov2722_probe,
+	.remove = ov2722_remove,
+	.id_table = ov2722_id,
+};
+
+static int init_ov2722(void)
+{
+	return i2c_add_driver(&ov2722_driver);
+}
+
+static void exit_ov2722(void)
+{
+
+	i2c_del_driver(&ov2722_driver);
+}
+
+module_init(init_ov2722);
+module_exit(exit_ov2722);
+
+MODULE_AUTHOR("Wei Liu <wei.liu@intel.com>");
+MODULE_DESCRIPTION("A low-level driver for OmniVision 2722 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov2722.h b/drivers/external_drivers/camera/drivers/media/i2c/ov2722.h
new file mode 100644
index 0000000..ae0a5c5
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov2722.h
@@ -0,0 +1,1058 @@
+/*
+ * Support for OmniVision OV2722 1080p HD camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV2722_H__
+#define __OV2722_H__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+
+#include <linux/atomisp_platform.h>
+
+#define OV2722_NAME		"ov2722"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		0x2
+#define I2C_RETRY_COUNT		5
+
+#define OV2722_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define OV2722_FOCAL_LENGTH_DEM	100
+#define OV2722_F_NUMBER_DEFAULT_NUM	26
+#define OV2722_F_NUMBER_DEM	10
+
+#define MAX_FMTS		1
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV2722_FOCAL_LENGTH_DEFAULT 0x1160064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV2722_F_NUMBER_DEFAULT 0x1a000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV2722_F_NUMBER_RANGE 0x1a0a1a0a
+#define OV2720_ID	0x2720
+#define OV2722_ID	0x2722
+
+#define OV2722_FINE_INTG_TIME_MIN 0
+#define OV2722_FINE_INTG_TIME_MAX_MARGIN 0
+#define OV2722_COARSE_INTG_TIME_MIN 1
+#define OV2722_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
+
+/*
+ * OV2722 System control registers
+ */
+#define OV2722_SW_SLEEP				0x0100
+#define OV2722_SW_RESET				0x0103
+#define OV2722_SW_STREAM			0x0100
+
+#define OV2722_SC_CMMN_CHIP_ID_H		0x300A
+#define OV2722_SC_CMMN_CHIP_ID_L		0x300B
+#define OV2722_SC_CMMN_SCCB_ID			0x300C
+#define OV2722_SC_CMMN_SUB_ID			0x302A /* process, version*/
+
+#define OV2722_SC_CMMN_PAD_OEN0			0x3000
+#define OV2722_SC_CMMN_PAD_OEN1			0x3001
+#define OV2722_SC_CMMN_PAD_OEN2			0x3002
+#define OV2722_SC_CMMN_PAD_OUT0			0x3008
+#define OV2722_SC_CMMN_PAD_OUT1			0x3009
+#define OV2722_SC_CMMN_PAD_OUT2			0x300D
+#define OV2722_SC_CMMN_PAD_SEL0			0x300E
+#define OV2722_SC_CMMN_PAD_SEL1			0x300F
+#define OV2722_SC_CMMN_PAD_SEL2			0x3010
+
+#define OV2722_SC_CMMN_PAD_PK			0x3011
+#define OV2722_SC_CMMN_A_PWC_PK_O_13		0x3013
+#define OV2722_SC_CMMN_A_PWC_PK_O_14		0x3014
+
+#define OV2722_SC_CMMN_CLKRST0			0x301A
+#define OV2722_SC_CMMN_CLKRST1			0x301B
+#define OV2722_SC_CMMN_CLKRST2			0x301C
+#define OV2722_SC_CMMN_CLKRST3			0x301D
+#define OV2722_SC_CMMN_CLKRST4			0x301E
+#define OV2722_SC_CMMN_CLKRST5			0x3005
+#define OV2722_SC_CMMN_PCLK_DIV_CTRL		0x3007
+#define OV2722_SC_CMMN_CLOCK_SEL		0x3020
+#define OV2722_SC_SOC_CLKRST5			0x3040
+
+#define OV2722_SC_CMMN_PLL_CTRL0		0x3034
+#define OV2722_SC_CMMN_PLL_CTRL1		0x3035
+#define OV2722_SC_CMMN_PLL_CTRL2		0x3039
+#define OV2722_SC_CMMN_PLL_CTRL3		0x3037
+#define OV2722_SC_CMMN_PLL_MULTIPLIER		0x3036
+#define OV2722_SC_CMMN_PLL_DEBUG_OPT		0x3038
+#define OV2722_SC_CMMN_PLLS_CTRL0		0x303A
+#define OV2722_SC_CMMN_PLLS_CTRL1		0x303B
+#define OV2722_SC_CMMN_PLLS_CTRL2		0x303C
+#define OV2722_SC_CMMN_PLLS_CTRL3		0x303D
+
+#define OV2722_SC_CMMN_MIPI_PHY_16		0x3016
+#define OV2722_SC_CMMN_MIPI_PHY_17		0x3017
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_18		0x3018
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_19		0x3019
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_21		0x3021
+#define OV2722_SC_CMMN_MIPI_SC_CTRL_22		0x3022
+
+#define OV2722_AEC_PK_EXPO_H			0x3500
+#define OV2722_AEC_PK_EXPO_M			0x3501
+#define OV2722_AEC_PK_EXPO_L			0x3502
+#define OV2722_AEC_MANUAL_CTRL			0x3503
+#define OV2722_AGC_ADJ_H			0x3508
+#define OV2722_AGC_ADJ_L			0x3509
+#define OV2722_VTS_DIFF_H			0x350c
+#define OV2722_VTS_DIFF_L			0x350d
+#define OV2722_GROUP_ACCESS			0x3208
+
+#define OV2722_MWB_GAIN_R_H			0x5186
+#define OV2722_MWB_GAIN_R_L			0x5187
+#define OV2722_MWB_GAIN_G_H			0x5188
+#define OV2722_MWB_GAIN_G_L			0x5189
+#define OV2722_MWB_GAIN_B_H			0x518a
+#define OV2722_MWB_GAIN_B_L			0x518b
+
+#define OV2722_H_CROP_START_H			0x3800
+#define OV2722_H_CROP_START_L			0x3801
+#define OV2722_V_CROP_START_H			0x3802
+#define OV2722_V_CROP_START_L			0x3803
+#define OV2722_H_CROP_END_H			0x3804
+#define OV2722_H_CROP_END_L			0x3805
+#define OV2722_V_CROP_END_H			0x3806
+#define OV2722_V_CROP_END_L			0x3807
+#define OV2722_H_OUTSIZE_H			0x3808
+#define OV2722_H_OUTSIZE_L			0x3809
+#define OV2722_V_OUTSIZE_H			0x380a
+#define OV2722_V_OUTSIZE_L			0x380b
+
+#define OV2722_START_STREAMING			0x01
+#define OV2722_STOP_STREAMING			0x00
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov2722_resolution {
+	u8 *desc;
+	const struct ov2722_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u32 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+	int mipi_freq;
+};
+
+struct ov2722_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct ov2722_reg *regs;
+};
+
+struct ov2722_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * ov2722 device structure.
+ */
+struct ov2722_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u8 res;
+	u8 type;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *link_freq;
+};
+
+enum ov2722_tok_type {
+	OV2722_8BIT  = 0x0001,
+	OV2722_16BIT = 0x0002,
+	OV2722_32BIT = 0x0004,
+	OV2722_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	OV2722_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	OV2722_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct ov2722_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov2722_reg {
+	enum ov2722_tok_type type;
+	u16 reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_ov2722_sensor(x) container_of(x, struct ov2722_device, sd)
+
+#define OV2722_MAX_WRITE_BUF_SIZE	30
+
+struct ov2722_write_buffer {
+	u16 addr;
+	u8 data[OV2722_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov2722_write_ctrl {
+	int index;
+	struct ov2722_write_buffer buffer;
+};
+
+static const struct i2c_device_id ov2722_id[] = {
+	{OV2722_NAME, 0},
+	{}
+};
+
+/*
+ * Register settings for various resolution
+ */
+static struct ov2722_reg const ov2722_QVGA_30fps[] = {
+	{OV2722_8BIT, 0x3718, 0x10},
+	{OV2722_8BIT, 0x3702, 0x0c},
+	{OV2722_8BIT, 0x373a, 0x1c},
+	{OV2722_8BIT, 0x3715, 0x01},
+	{OV2722_8BIT, 0x3703, 0x0c},
+	{OV2722_8BIT, 0x3705, 0x06},
+	{OV2722_8BIT, 0x3730, 0x0e},
+	{OV2722_8BIT, 0x3704, 0x1c},
+	{OV2722_8BIT, 0x3f06, 0x00},
+	{OV2722_8BIT, 0x371c, 0x00},
+	{OV2722_8BIT, 0x371d, 0x46},
+	{OV2722_8BIT, 0x371e, 0x00},
+	{OV2722_8BIT, 0x371f, 0x63},
+	{OV2722_8BIT, 0x3708, 0x61},
+	{OV2722_8BIT, 0x3709, 0x12},
+	{OV2722_8BIT, 0x3800, 0x01},
+	{OV2722_8BIT, 0x3801, 0x42}, /* H crop start: 322 */
+	{OV2722_8BIT, 0x3802, 0x00},
+	{OV2722_8BIT, 0x3803, 0x20}, /* V crop start: 32 */
+	{OV2722_8BIT, 0x3804, 0x06},
+	{OV2722_8BIT, 0x3805, 0x95}, /* H crop end:  1685 */
+	{OV2722_8BIT, 0x3806, 0x04},
+	{OV2722_8BIT, 0x3807, 0x27}, /* V crop end:  1063 */
+	{OV2722_8BIT, 0x3808, 0x01},
+	{OV2722_8BIT, 0x3809, 0x50}, /* H output size: 336 */
+	{OV2722_8BIT, 0x380a, 0x01},
+	{OV2722_8BIT, 0x380b, 0x00}, /* V output size: 256 */
+
+	/* H blank timing */
+	{OV2722_8BIT, 0x380c, 0x08},
+	{OV2722_8BIT, 0x380d, 0x00}, /* H total size: 2048 */
+	{OV2722_8BIT, 0x380e, 0x04},
+	{OV2722_8BIT, 0x380f, 0xa0}, /* V total size: 1184 */
+	{OV2722_8BIT, 0x3810, 0x00},
+	{OV2722_8BIT, 0x3811, 0x04}, /* H window offset: 5 */
+	{OV2722_8BIT, 0x3812, 0x00},
+	{OV2722_8BIT, 0x3813, 0x01}, /* V window offset: 2 */
+	{OV2722_8BIT, 0x3820, 0xc0},
+	{OV2722_8BIT, 0x3821, 0x06}, /* flip isp*/
+	{OV2722_8BIT, 0x3814, 0x71},
+	{OV2722_8BIT, 0x3815, 0x71},
+	{OV2722_8BIT, 0x3612, 0x49},
+	{OV2722_8BIT, 0x3618, 0x00},
+	{OV2722_8BIT, 0x3a08, 0x01},
+	{OV2722_8BIT, 0x3a09, 0xc3},
+	{OV2722_8BIT, 0x3a0a, 0x01},
+	{OV2722_8BIT, 0x3a0b, 0x77},
+	{OV2722_8BIT, 0x3a0d, 0x00},
+	{OV2722_8BIT, 0x3a0e, 0x00},
+	{OV2722_8BIT, 0x4520, 0x09},
+	{OV2722_8BIT, 0x4837, 0x1b},
+	{OV2722_8BIT, 0x3000, 0xff},
+	{OV2722_8BIT, 0x3001, 0xff},
+	{OV2722_8BIT, 0x3002, 0xf0},
+	{OV2722_8BIT, 0x3600, 0x08},
+	{OV2722_8BIT, 0x3621, 0xc0},
+	{OV2722_8BIT, 0x3632, 0x53}, /* added for power opt */
+	{OV2722_8BIT, 0x3633, 0x63},
+	{OV2722_8BIT, 0x3634, 0x24},
+	{OV2722_8BIT, 0x3f01, 0x0c},
+	{OV2722_8BIT, 0x5001, 0xc1}, /* v_en, h_en, blc_en */
+	{OV2722_8BIT, 0x3614, 0xf0},
+	{OV2722_8BIT, 0x3630, 0x2d},
+	{OV2722_8BIT, 0x370b, 0x62},
+	{OV2722_8BIT, 0x3706, 0x61},
+	{OV2722_8BIT, 0x4000, 0x02},
+	{OV2722_8BIT, 0x4002, 0xc5},
+	{OV2722_8BIT, 0x4005, 0x08},
+	{OV2722_8BIT, 0x404f, 0x84},
+	{OV2722_8BIT, 0x4051, 0x00},
+	{OV2722_8BIT, 0x5000, 0xff},
+	{OV2722_8BIT, 0x3a18, 0x00},
+	{OV2722_8BIT, 0x3a19, 0x80},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x4521, 0x00},
+	{OV2722_8BIT, 0x5183, 0xb0}, /* AWB red */
+	{OV2722_8BIT, 0x5184, 0xb0}, /* AWB green */
+	{OV2722_8BIT, 0x5185, 0xb0}, /* AWB blue */
+	{OV2722_8BIT, 0x5180, 0x03}, /* AWB manual mode */
+	{OV2722_8BIT, 0x370c, 0x0c},
+	{OV2722_8BIT, 0x4800, 0x24}, /* clk lane gate enable */
+	{OV2722_8BIT, 0x3035, 0x00},
+	{OV2722_8BIT, 0x3036, 0x26},
+	{OV2722_8BIT, 0x3037, 0xa1},
+	{OV2722_8BIT, 0x303e, 0x19},
+	{OV2722_8BIT, 0x3038, 0x06},
+	{OV2722_8BIT, 0x3018, 0x04},
+
+	/* Added for power optimization */
+	{OV2722_8BIT, 0x3000, 0x00},
+	{OV2722_8BIT, 0x3001, 0x00},
+	{OV2722_8BIT, 0x3002, 0x00},
+	{OV2722_8BIT, 0x3a0f, 0x40},
+	{OV2722_8BIT, 0x3a10, 0x38},
+	{OV2722_8BIT, 0x3a1b, 0x48},
+	{OV2722_8BIT, 0x3a1e, 0x30},
+	{OV2722_8BIT, 0x3a11, 0x90},
+	{OV2722_8BIT, 0x3a1f, 0x10},
+	{OV2722_8BIT, 0x3011, 0x22},
+	{OV2722_8BIT, 0x3a00, 0x58},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x3500, 0x00},
+	{OV2722_8BIT, 0x3501, 0x46},
+	{OV2722_8BIT, 0x3502, 0x00},
+	{OV2722_8BIT, 0x3508, 0x00},
+	{OV2722_8BIT, 0x3509, 0x10},
+	{OV2722_TOK_TERM, 0, 0},
+
+};
+
+static struct ov2722_reg const ov2722_VGA_30fps[] = {
+	{OV2722_8BIT, 0x3718, 0x10},
+	{OV2722_8BIT, 0x3702, 0x18},
+	{OV2722_8BIT, 0x373a, 0x3c},
+	{OV2722_8BIT, 0x3715, 0x01},
+	{OV2722_8BIT, 0x3703, 0x1d},
+	{OV2722_8BIT, 0x3705, 0x12},
+	{OV2722_8BIT, 0x3730, 0x1f},
+	{OV2722_8BIT, 0x3704, 0x3f},
+	{OV2722_8BIT, 0x3f06, 0x1d},
+	{OV2722_8BIT, 0x371c, 0x00},
+	{OV2722_8BIT, 0x371d, 0x83},
+	{OV2722_8BIT, 0x371e, 0x00},
+	{OV2722_8BIT, 0x371f, 0xbd},
+	{OV2722_8BIT, 0x3708, 0x63},
+	{OV2722_8BIT, 0x3709, 0x52},
+	{OV2722_8BIT, 0x3800, 0x01},
+	{OV2722_8BIT, 0x3801, 0x42}, /* H crop start: 322 */
+	{OV2722_8BIT, 0x3802, 0x00},
+	{OV2722_8BIT, 0x3803, 0x20}, /* V crop start:  32*/
+	{OV2722_8BIT, 0x3804, 0x06},
+	{OV2722_8BIT, 0x3805, 0x6B}, /* H crop end:   1643*/
+	{OV2722_8BIT, 0x3806, 0x04},
+	{OV2722_8BIT, 0x3807, 0x03}, /* V crop end:   1027*/
+	{OV2722_8BIT, 0x3808, 0x02},
+	{OV2722_8BIT, 0x3809, 0x90}, /* H output size: 656 */
+	{OV2722_8BIT, 0x380a, 0x01},
+	{OV2722_8BIT, 0x380b, 0xF0}, /* V output size: 496 */
+
+	/* H blank timing */
+	{OV2722_8BIT, 0x380c, 0x08},
+	{OV2722_8BIT, 0x380d, 0x00}, /* H total size: 2048 */
+	{OV2722_8BIT, 0x380e, 0x04},
+	{OV2722_8BIT, 0x380f, 0xa0}, /* V total size: 1184 */
+	{OV2722_8BIT, 0x3810, 0x00},
+	{OV2722_8BIT, 0x3811, 0x04}, /* H window offset: 5 */
+	{OV2722_8BIT, 0x3812, 0x00},
+	{OV2722_8BIT, 0x3813, 0x01}, /* V window offset: 2 */
+	{OV2722_8BIT, 0x3820, 0x80},
+	{OV2722_8BIT, 0x3821, 0x06}, /* flip isp*/
+	{OV2722_8BIT, 0x3814, 0x31},
+	{OV2722_8BIT, 0x3815, 0x31},
+	{OV2722_8BIT, 0x3612, 0x4b},
+	{OV2722_8BIT, 0x3618, 0x04},
+	{OV2722_8BIT, 0x3a08, 0x02},
+	{OV2722_8BIT, 0x3a09, 0x67},
+	{OV2722_8BIT, 0x3a0a, 0x02},
+	{OV2722_8BIT, 0x3a0b, 0x00},
+	{OV2722_8BIT, 0x3a0d, 0x00},
+	{OV2722_8BIT, 0x3a0e, 0x00},
+	{OV2722_8BIT, 0x4520, 0x0a},
+	{OV2722_8BIT, 0x4837, 0x29},
+	{OV2722_8BIT, 0x3000, 0xff},
+	{OV2722_8BIT, 0x3001, 0xff},
+	{OV2722_8BIT, 0x3002, 0xf0},
+	{OV2722_8BIT, 0x3600, 0x08},
+	{OV2722_8BIT, 0x3621, 0xc0},
+	{OV2722_8BIT, 0x3632, 0x53}, /* added for power opt */
+	{OV2722_8BIT, 0x3633, 0x63},
+	{OV2722_8BIT, 0x3634, 0x24},
+	{OV2722_8BIT, 0x3f01, 0x0c},
+	{OV2722_8BIT, 0x5001, 0xc1}, /* v_en, h_en, blc_en */
+	{OV2722_8BIT, 0x3614, 0xf0},
+	{OV2722_8BIT, 0x3630, 0x2d},
+	{OV2722_8BIT, 0x370b, 0x62},
+	{OV2722_8BIT, 0x3706, 0x61},
+	{OV2722_8BIT, 0x4000, 0x02},
+	{OV2722_8BIT, 0x4002, 0xc5},
+	{OV2722_8BIT, 0x4005, 0x08},
+	{OV2722_8BIT, 0x404f, 0x84},
+	{OV2722_8BIT, 0x4051, 0x00},
+	{OV2722_8BIT, 0x5000, 0xff},
+	{OV2722_8BIT, 0x3a18, 0x00},
+	{OV2722_8BIT, 0x3a19, 0x80},
+	{OV2722_8BIT, 0x3503, 0x00},
+	{OV2722_8BIT, 0x4521, 0x00},
+	{OV2722_8BIT, 0x5183, 0xb0}, /* AWB red */
+	{OV2722_8BIT, 0x5184, 0xb0}, /* AWB green */
+	{OV2722_8BIT, 0x5185, 0xb0}, /* AWB blue */
+	{OV2722_8BIT, 0x5180, 0x03}, /* AWB manual mode */
+	{OV2722_8BIT, 0x370c, 0x0c},
+	{OV2722_8BIT, 0x4800, 0x24}, /* clk lane gate enable */
+	{OV2722_8BIT, 0x3035, 0x00},
+	{OV2722_8BIT, 0x3036, 0x26},
+	{OV2722_8BIT, 0x3037, 0xa1},
+	{OV2722_8BIT, 0x303e, 0x19},
+	{OV2722_8BIT, 0x3038, 0x06},
+	{OV2722_8BIT, 0x3018, 0x04},
+
+	/* Added for power optimization */
+	{OV2722_8BIT, 0x3000, 0x00},
+	{OV2722_8BIT, 0x3001, 0x00},
+	{OV2722_8BIT, 0x3002, 0x00},
+	{OV2722_8BIT, 0x3a0f, 0x40},
+	{OV2722_8BIT, 0x3a10, 0x38},
+	{OV2722_8BIT, 0x3a1b, 0x48},
+	{OV2722_8BIT, 0x3a1e, 0x30},
+	{OV2722_8BIT, 0x3a11, 0x90},
+	{OV2722_8BIT, 0x3a1f, 0x10},
+	{OV2722_8BIT, 0x3011, 0x22},
+	{OV2722_8BIT, 0x3a00, 0x58},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x3500, 0x00},
+	{OV2722_8BIT, 0x3501, 0x46},
+	{OV2722_8BIT, 0x3502, 0x00},
+	{OV2722_8BIT, 0x3508, 0x00},
+	{OV2722_8BIT, 0x3509, 0x10},
+	{OV2722_TOK_TERM, 0, 0},
+};
+
+static struct ov2722_reg const ov2722_1452_1092_30fps[] = {
+	{OV2722_8BIT, 0x3021, 0x03}, /* For stand wait for
+				a whole frame complete.(vblank) */
+	{OV2722_8BIT, 0x3718, 0x10},
+	{OV2722_8BIT, 0x3702, 0x24},
+	{OV2722_8BIT, 0x373a, 0x60},
+	{OV2722_8BIT, 0x3715, 0x01},
+	{OV2722_8BIT, 0x3703, 0x2e},
+	{OV2722_8BIT, 0x3705, 0x10},
+	{OV2722_8BIT, 0x3730, 0x30},
+	{OV2722_8BIT, 0x3704, 0x62},
+	{OV2722_8BIT, 0x3f06, 0x3a},
+	{OV2722_8BIT, 0x371c, 0x00},
+	{OV2722_8BIT, 0x371d, 0xc4},
+	{OV2722_8BIT, 0x371e, 0x01},
+	{OV2722_8BIT, 0x371f, 0x0d},
+	{OV2722_8BIT, 0x3708, 0x61},
+	{OV2722_8BIT, 0x3709, 0x12},
+	{OV2722_8BIT, 0x3800, 0x00},
+	{OV2722_8BIT, 0x3801, 0xF8}, /* H crop start: 248 */
+	{OV2722_8BIT, 0x3802, 0x00},
+	{OV2722_8BIT, 0x3803, 0x01}, /* V crop start: 1 */
+	{OV2722_8BIT, 0x3804, 0x06},
+	{OV2722_8BIT, 0x3805, 0xab}, /* H crop end: 1707 */
+	{OV2722_8BIT, 0x3806, 0x04},
+	{OV2722_8BIT, 0x3807, 0x45}, /* V crop end: 1093 */
+	{OV2722_8BIT, 0x3808, 0x05},
+	{OV2722_8BIT, 0x3809, 0xac}, /* H output size: 1452 */
+	{OV2722_8BIT, 0x380a, 0x04},
+	{OV2722_8BIT, 0x380b, 0x44}, /* V output size: 1092 */
+	{OV2722_8BIT, 0x380c, 0x08},
+	{OV2722_8BIT, 0x380d, 0xd4}, /* H timing: 2260 */
+	{OV2722_8BIT, 0x380e, 0x04},
+	{OV2722_8BIT, 0x380f, 0xdc}, /* V timing: 1244 */
+	{OV2722_8BIT, 0x3810, 0x00},
+	{OV2722_8BIT, 0x3811, 0x03}, /* H window offset: 3 */
+	{OV2722_8BIT, 0x3812, 0x00},
+	{OV2722_8BIT, 0x3813, 0x02}, /* V window offset: 2 */
+	{OV2722_8BIT, 0x3820, 0x80},
+	{OV2722_8BIT, 0x3821, 0x06}, /*  mirror */
+	{OV2722_8BIT, 0x3814, 0x11},
+	{OV2722_8BIT, 0x3815, 0x11},
+	{OV2722_8BIT, 0x3612, 0x0b},
+	{OV2722_8BIT, 0x3618, 0x04},
+	{OV2722_8BIT, 0x3a08, 0x01},
+	{OV2722_8BIT, 0x3a09, 0x50},
+	{OV2722_8BIT, 0x3a0a, 0x01},
+	{OV2722_8BIT, 0x3a0b, 0x18},
+	{OV2722_8BIT, 0x3a0d, 0x03},
+	{OV2722_8BIT, 0x3a0e, 0x03},
+	{OV2722_8BIT, 0x4520, 0x00},
+	{OV2722_8BIT, 0x4837, 0x1b},
+	{OV2722_8BIT, 0x3600, 0x08},
+	{OV2722_8BIT, 0x3621, 0xc0},
+	{OV2722_8BIT, 0x3632, 0xd2}, /* added for power opt */
+	{OV2722_8BIT, 0x3633, 0x23},
+	{OV2722_8BIT, 0x3634, 0x54},
+	{OV2722_8BIT, 0x3f01, 0x0c},
+	{OV2722_8BIT, 0x5001, 0xc1},
+	{OV2722_8BIT, 0x3614, 0xf0},
+	{OV2722_8BIT, 0x3630, 0x2d},
+	{OV2722_8BIT, 0x370b, 0x62},
+	{OV2722_8BIT, 0x3706, 0x61},
+	{OV2722_8BIT, 0x4000, 0x02},
+	{OV2722_8BIT, 0x4002, 0xc5},
+	{OV2722_8BIT, 0x4005, 0x08},
+	{OV2722_8BIT, 0x404f, 0x84},
+	{OV2722_8BIT, 0x4051, 0x00},
+	{OV2722_8BIT, 0x5000, 0xcf}, /* manual 3a */
+	{OV2722_8BIT, 0x301d, 0xf0}, /* enable group hold */
+	{OV2722_8BIT, 0x3a18, 0x00},
+	{OV2722_8BIT, 0x3a19, 0x80},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x4521, 0x00},
+	{OV2722_8BIT, 0x5183, 0xb0},
+	{OV2722_8BIT, 0x5184, 0xb0},
+	{OV2722_8BIT, 0x5185, 0xb0},
+	{OV2722_8BIT, 0x370c, 0x0c},
+	{OV2722_8BIT, 0x3035, 0x00},
+	{OV2722_8BIT, 0x3036, 0x2c}, /* 422.4 MHz */
+	{OV2722_8BIT, 0x3037, 0xa1},
+	{OV2722_8BIT, 0x303e, 0x19},
+	{OV2722_8BIT, 0x3038, 0x06},
+	{OV2722_8BIT, 0x3018, 0x04},
+	{OV2722_8BIT, 0x3000, 0x00}, /* added for power optimization */
+	{OV2722_8BIT, 0x3001, 0x00},
+	{OV2722_8BIT, 0x3002, 0x00},
+	{OV2722_8BIT, 0x3a0f, 0x40},
+	{OV2722_8BIT, 0x3a10, 0x38},
+	{OV2722_8BIT, 0x3a1b, 0x48},
+	{OV2722_8BIT, 0x3a1e, 0x30},
+	{OV2722_8BIT, 0x3a11, 0x90},
+	{OV2722_8BIT, 0x3a1f, 0x10},
+	{OV2722_8BIT, 0x3503, 0x07}, /* manual 3a */
+	{OV2722_8BIT, 0x3500, 0x00},
+	{OV2722_8BIT, 0x3501, 0x3F},
+	{OV2722_8BIT, 0x3502, 0x00},
+	{OV2722_8BIT, 0x3508, 0x00},
+	{OV2722_8BIT, 0x3509, 0x00},
+	{OV2722_TOK_TERM, 0, 0}
+};
+static struct ov2722_reg const ov2722_1M3_30fps[] = {
+	{OV2722_8BIT, 0x3718, 0x10},
+	{OV2722_8BIT, 0x3702, 0x24},
+	{OV2722_8BIT, 0x373a, 0x60},
+	{OV2722_8BIT, 0x3715, 0x01},
+	{OV2722_8BIT, 0x3703, 0x2e},
+	{OV2722_8BIT, 0x3705, 0x10},
+	{OV2722_8BIT, 0x3730, 0x30},
+	{OV2722_8BIT, 0x3704, 0x62},
+	{OV2722_8BIT, 0x3f06, 0x3a},
+	{OV2722_8BIT, 0x371c, 0x00},
+	{OV2722_8BIT, 0x371d, 0xc4},
+	{OV2722_8BIT, 0x371e, 0x01},
+	{OV2722_8BIT, 0x371f, 0x0d},
+	{OV2722_8BIT, 0x3708, 0x61},
+	{OV2722_8BIT, 0x3709, 0x12},
+	{OV2722_8BIT, 0x3800, 0x01},
+	{OV2722_8BIT, 0x3801, 0x4a},	/* H crop start: 330 */
+	{OV2722_8BIT, 0x3802, 0x00},
+	{OV2722_8BIT, 0x3803, 0x03},	/* V crop start: 3 */
+	{OV2722_8BIT, 0x3804, 0x06},
+	{OV2722_8BIT, 0x3805, 0xe1},	/* H crop end:  1761 */
+	{OV2722_8BIT, 0x3806, 0x04},
+	{OV2722_8BIT, 0x3807, 0x47},	/* V crop end:  1095 */
+	{OV2722_8BIT, 0x3808, 0x05},
+	{OV2722_8BIT, 0x3809, 0x88},	/* H output size: 1416 */
+	{OV2722_8BIT, 0x380a, 0x04},
+	{OV2722_8BIT, 0x380b, 0x0a},	/* V output size: 1034 */
+
+	/* H blank timing */
+	{OV2722_8BIT, 0x380c, 0x08},
+	{OV2722_8BIT, 0x380d, 0x00},	/* H total size: 2048 */
+	{OV2722_8BIT, 0x380e, 0x04},
+	{OV2722_8BIT, 0x380f, 0xa0},	/* V total size: 1184 */
+	{OV2722_8BIT, 0x3810, 0x00},
+	{OV2722_8BIT, 0x3811, 0x05},	/* H window offset: 5 */
+	{OV2722_8BIT, 0x3812, 0x00},
+	{OV2722_8BIT, 0x3813, 0x02},	/* V window offset: 2 */
+	{OV2722_8BIT, 0x3820, 0x80},
+	{OV2722_8BIT, 0x3821, 0x06},	/* flip isp */
+	{OV2722_8BIT, 0x3814, 0x11},
+	{OV2722_8BIT, 0x3815, 0x11},
+	{OV2722_8BIT, 0x3612, 0x0b},
+	{OV2722_8BIT, 0x3618, 0x04},
+	{OV2722_8BIT, 0x3a08, 0x01},
+	{OV2722_8BIT, 0x3a09, 0x50},
+	{OV2722_8BIT, 0x3a0a, 0x01},
+	{OV2722_8BIT, 0x3a0b, 0x18},
+	{OV2722_8BIT, 0x3a0d, 0x03},
+	{OV2722_8BIT, 0x3a0e, 0x03},
+	{OV2722_8BIT, 0x4520, 0x00},
+	{OV2722_8BIT, 0x4837, 0x1b},
+	{OV2722_8BIT, 0x3000, 0xff},
+	{OV2722_8BIT, 0x3001, 0xff},
+	{OV2722_8BIT, 0x3002, 0xf0},
+	{OV2722_8BIT, 0x3600, 0x08},
+	{OV2722_8BIT, 0x3621, 0xc0},
+	{OV2722_8BIT, 0x3632, 0xd2},	/* added for power opt */
+	{OV2722_8BIT, 0x3633, 0x23},
+	{OV2722_8BIT, 0x3634, 0x54},
+	{OV2722_8BIT, 0x3f01, 0x0c},
+	{OV2722_8BIT, 0x5001, 0xc1},	/* v_en, h_en, blc_en */
+	{OV2722_8BIT, 0x3614, 0xf0},
+	{OV2722_8BIT, 0x3630, 0x2d},
+	{OV2722_8BIT, 0x370b, 0x62},
+	{OV2722_8BIT, 0x3706, 0x61},
+	{OV2722_8BIT, 0x4000, 0x02},
+	{OV2722_8BIT, 0x4002, 0xc5},
+	{OV2722_8BIT, 0x4005, 0x08},
+	{OV2722_8BIT, 0x404f, 0x84},
+	{OV2722_8BIT, 0x4051, 0x00},
+	{OV2722_8BIT, 0x5000, 0xcf},
+	{OV2722_8BIT, 0x3a18, 0x00},
+	{OV2722_8BIT, 0x3a19, 0x80},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x4521, 0x00},
+	{OV2722_8BIT, 0x5183, 0xb0},	/* AWB red */
+	{OV2722_8BIT, 0x5184, 0xb0},	/* AWB green */
+	{OV2722_8BIT, 0x5185, 0xb0},	/* AWB blue */
+	{OV2722_8BIT, 0x5180, 0x03},	/* AWB manual mode */
+	{OV2722_8BIT, 0x370c, 0x0c},
+	{OV2722_8BIT, 0x4800, 0x24},	/* clk lane gate enable */
+	{OV2722_8BIT, 0x3035, 0x00},
+	{OV2722_8BIT, 0x3036, 0x26},
+	{OV2722_8BIT, 0x3037, 0xa1},
+	{OV2722_8BIT, 0x303e, 0x19},
+	{OV2722_8BIT, 0x3038, 0x06},
+	{OV2722_8BIT, 0x3018, 0x04},
+
+	/* Added for power optimization */
+	{OV2722_8BIT, 0x3000, 0x00},
+	{OV2722_8BIT, 0x3001, 0x00},
+	{OV2722_8BIT, 0x3002, 0x00},
+	{OV2722_8BIT, 0x3a0f, 0x40},
+	{OV2722_8BIT, 0x3a10, 0x38},
+	{OV2722_8BIT, 0x3a1b, 0x48},
+	{OV2722_8BIT, 0x3a1e, 0x30},
+	{OV2722_8BIT, 0x3a11, 0x90},
+	{OV2722_8BIT, 0x3a1f, 0x10},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x3500, 0x00},
+	{OV2722_8BIT, 0x3501, 0x46},
+	{OV2722_8BIT, 0x3502, 0x00},
+	{OV2722_8BIT, 0x3508, 0x00},
+	{OV2722_8BIT, 0x3509, 0x10},
+	{OV2722_TOK_TERM, 0, 0},
+};
+
+static struct ov2722_reg const ov2722_1080p_30fps[] = {
+	{OV2722_8BIT, 0x3021, 0x03}, /* For stand wait for
+				a whole frame complete.(vblank) */
+	{OV2722_8BIT, 0x3718, 0x10},
+	{OV2722_8BIT, 0x3702, 0x24},
+	{OV2722_8BIT, 0x373a, 0x60},
+	{OV2722_8BIT, 0x3715, 0x01},
+	{OV2722_8BIT, 0x3703, 0x2e},
+	{OV2722_8BIT, 0x3705, 0x10},
+	{OV2722_8BIT, 0x3730, 0x30},
+	{OV2722_8BIT, 0x3704, 0x62},
+	{OV2722_8BIT, 0x3f06, 0x3a},
+	{OV2722_8BIT, 0x371c, 0x00},
+	{OV2722_8BIT, 0x371d, 0xc4},
+	{OV2722_8BIT, 0x371e, 0x01},
+	{OV2722_8BIT, 0x371f, 0x0d},
+	{OV2722_8BIT, 0x3708, 0x61},
+	{OV2722_8BIT, 0x3709, 0x12},
+	{OV2722_8BIT, 0x3800, 0x00},
+	{OV2722_8BIT, 0x3801, 0x08}, /* H crop start: 8 */
+	{OV2722_8BIT, 0x3802, 0x00},
+	{OV2722_8BIT, 0x3803, 0x01}, /* V crop start: 1 */
+	{OV2722_8BIT, 0x3804, 0x07},
+	{OV2722_8BIT, 0x3805, 0x9b}, /* H crop end: 1947 */
+	{OV2722_8BIT, 0x3806, 0x04},
+	{OV2722_8BIT, 0x3807, 0x45}, /* V crop end: 1093 */
+	{OV2722_8BIT, 0x3808, 0x07},
+	{OV2722_8BIT, 0x3809, 0x8c}, /* H output size: 1932 */
+	{OV2722_8BIT, 0x380a, 0x04},
+	{OV2722_8BIT, 0x380b, 0x44}, /* V output size: 1092 */
+	{OV2722_8BIT, 0x380c, 0x08},
+	{OV2722_8BIT, 0x380d, 0xd4}, /* H timing: 2260 */
+	{OV2722_8BIT, 0x380e, 0x04},
+	{OV2722_8BIT, 0x380f, 0xdc}, /* V timing: 1244 */
+	{OV2722_8BIT, 0x3810, 0x00},
+	{OV2722_8BIT, 0x3811, 0x03}, /* H window offset: 3 */
+	{OV2722_8BIT, 0x3812, 0x00},
+	{OV2722_8BIT, 0x3813, 0x02}, /* V window offset: 2 */
+	{OV2722_8BIT, 0x3820, 0x80},
+	{OV2722_8BIT, 0x3821, 0x06}, /*  mirror */
+	{OV2722_8BIT, 0x3814, 0x11},
+	{OV2722_8BIT, 0x3815, 0x11},
+	{OV2722_8BIT, 0x3612, 0x0b},
+	{OV2722_8BIT, 0x3618, 0x04},
+	{OV2722_8BIT, 0x3a08, 0x01},
+	{OV2722_8BIT, 0x3a09, 0x50},
+	{OV2722_8BIT, 0x3a0a, 0x01},
+	{OV2722_8BIT, 0x3a0b, 0x18},
+	{OV2722_8BIT, 0x3a0d, 0x03},
+	{OV2722_8BIT, 0x3a0e, 0x03},
+	{OV2722_8BIT, 0x4520, 0x00},
+	{OV2722_8BIT, 0x4837, 0x1b},
+	{OV2722_8BIT, 0x3600, 0x08},
+	{OV2722_8BIT, 0x3621, 0xc0},
+	{OV2722_8BIT, 0x3632, 0xd2}, /* added for power opt */
+	{OV2722_8BIT, 0x3633, 0x23},
+	{OV2722_8BIT, 0x3634, 0x54},
+	{OV2722_8BIT, 0x3f01, 0x0c},
+	{OV2722_8BIT, 0x5001, 0xc1},
+	{OV2722_8BIT, 0x3614, 0xf0},
+	{OV2722_8BIT, 0x3630, 0x2d},
+	{OV2722_8BIT, 0x370b, 0x62},
+	{OV2722_8BIT, 0x3706, 0x61},
+	{OV2722_8BIT, 0x4000, 0x02},
+	{OV2722_8BIT, 0x4002, 0xc5},
+	{OV2722_8BIT, 0x4005, 0x08},
+	{OV2722_8BIT, 0x404f, 0x84},
+	{OV2722_8BIT, 0x4051, 0x00},
+	{OV2722_8BIT, 0x5000, 0xcf}, /* manual 3a */
+	{OV2722_8BIT, 0x301d, 0xf0}, /* enable group hold */
+	{OV2722_8BIT, 0x3a18, 0x00},
+	{OV2722_8BIT, 0x3a19, 0x80},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x4521, 0x00},
+	{OV2722_8BIT, 0x5183, 0xb0},
+	{OV2722_8BIT, 0x5184, 0xb0},
+	{OV2722_8BIT, 0x5185, 0xb0},
+	{OV2722_8BIT, 0x370c, 0x0c},
+	{OV2722_8BIT, 0x3035, 0x00},
+	{OV2722_8BIT, 0x3036, 0x2c}, /* 422.4 MHz */
+	{OV2722_8BIT, 0x3037, 0xa1},
+	{OV2722_8BIT, 0x303e, 0x19},
+	{OV2722_8BIT, 0x3038, 0x06},
+	{OV2722_8BIT, 0x3018, 0x04},
+	{OV2722_8BIT, 0x3000, 0x00}, /* added for power optimization */
+	{OV2722_8BIT, 0x3001, 0x00},
+	{OV2722_8BIT, 0x3002, 0x00},
+	{OV2722_8BIT, 0x3a0f, 0x40},
+	{OV2722_8BIT, 0x3a10, 0x38},
+	{OV2722_8BIT, 0x3a1b, 0x48},
+	{OV2722_8BIT, 0x3a1e, 0x30},
+	{OV2722_8BIT, 0x3a11, 0x90},
+	{OV2722_8BIT, 0x3a1f, 0x10},
+	{OV2722_8BIT, 0x3503, 0x07}, /* manual 3a */
+	{OV2722_8BIT, 0x3500, 0x00},
+	{OV2722_8BIT, 0x3501, 0x3F},
+	{OV2722_8BIT, 0x3502, 0x00},
+	{OV2722_8BIT, 0x3508, 0x00},
+	{OV2722_8BIT, 0x3509, 0x00},
+	{OV2722_TOK_TERM, 0, 0}
+};
+
+static struct ov2722_reg const ov2722_720p_30fps[] = {
+	{OV2722_8BIT, 0x3021, 0x03},
+	{OV2722_8BIT, 0x3718, 0x10},
+	{OV2722_8BIT, 0x3702, 0x24},
+	{OV2722_8BIT, 0x373a, 0x60},
+	{OV2722_8BIT, 0x3715, 0x01},
+	{OV2722_8BIT, 0x3703, 0x2e},
+	{OV2722_8BIT, 0x3705, 0x10},
+	{OV2722_8BIT, 0x3730, 0x30},
+	{OV2722_8BIT, 0x3704, 0x62},
+	{OV2722_8BIT, 0x3f06, 0x3a},
+	{OV2722_8BIT, 0x371c, 0x00},
+	{OV2722_8BIT, 0x371d, 0xc4},
+	{OV2722_8BIT, 0x371e, 0x01},
+	{OV2722_8BIT, 0x371f, 0x0d},
+	{OV2722_8BIT, 0x3708, 0x61},
+	{OV2722_8BIT, 0x3709, 0x12},
+	{OV2722_8BIT, 0x3800, 0x01},
+	{OV2722_8BIT, 0x3801, 0x40}, /* H crop start: 320 */
+	{OV2722_8BIT, 0x3802, 0x00},
+	{OV2722_8BIT, 0x3803, 0xb1}, /* V crop start: 177 */
+	{OV2722_8BIT, 0x3804, 0x06},
+	{OV2722_8BIT, 0x3805, 0x55}, /* H crop end: 1621 */
+	{OV2722_8BIT, 0x3806, 0x03},
+	{OV2722_8BIT, 0x3807, 0x95}, /* V crop end: 918 */
+	{OV2722_8BIT, 0x3808, 0x05},
+	{OV2722_8BIT, 0x3809, 0x10}, /* H output size: 0x0788==1928 */
+	{OV2722_8BIT, 0x380a, 0x02},
+	{OV2722_8BIT, 0x380b, 0xe0}, /* output size: 0x02DE==734 */
+	{OV2722_8BIT, 0x380c, 0x08},
+	{OV2722_8BIT, 0x380d, 0x00}, /* H timing: 2048 */
+	{OV2722_8BIT, 0x380e, 0x04},
+	{OV2722_8BIT, 0x380f, 0xa3}, /* V timing: 1187 */
+	{OV2722_8BIT, 0x3810, 0x00},
+	{OV2722_8BIT, 0x3811, 0x03}, /* H window offset: 3 */
+	{OV2722_8BIT, 0x3812, 0x00},
+	{OV2722_8BIT, 0x3813, 0x02}, /* V window offset: 2 */
+	{OV2722_8BIT, 0x3820, 0x80},
+	{OV2722_8BIT, 0x3821, 0x06}, /* mirror */
+	{OV2722_8BIT, 0x3814, 0x11},
+	{OV2722_8BIT, 0x3815, 0x11},
+	{OV2722_8BIT, 0x3612, 0x0b},
+	{OV2722_8BIT, 0x3618, 0x04},
+	{OV2722_8BIT, 0x3a08, 0x01},
+	{OV2722_8BIT, 0x3a09, 0x50},
+	{OV2722_8BIT, 0x3a0a, 0x01},
+	{OV2722_8BIT, 0x3a0b, 0x18},
+	{OV2722_8BIT, 0x3a0d, 0x03},
+	{OV2722_8BIT, 0x3a0e, 0x03},
+	{OV2722_8BIT, 0x4520, 0x00},
+	{OV2722_8BIT, 0x4837, 0x1b},
+	{OV2722_8BIT, 0x3600, 0x08},
+	{OV2722_8BIT, 0x3621, 0xc0},
+	{OV2722_8BIT, 0x3632, 0xd2}, /* added for power opt */
+	{OV2722_8BIT, 0x3633, 0x23},
+	{OV2722_8BIT, 0x3634, 0x54},
+	{OV2722_8BIT, 0x3f01, 0x0c},
+	{OV2722_8BIT, 0x5001, 0xc1},
+	{OV2722_8BIT, 0x3614, 0xf0},
+	{OV2722_8BIT, 0x3630, 0x2d},
+	{OV2722_8BIT, 0x370b, 0x62},
+	{OV2722_8BIT, 0x3706, 0x61},
+	{OV2722_8BIT, 0x4000, 0x02},
+	{OV2722_8BIT, 0x4002, 0xc5},
+	{OV2722_8BIT, 0x4005, 0x08},
+	{OV2722_8BIT, 0x404f, 0x84},
+	{OV2722_8BIT, 0x4051, 0x00},
+	{OV2722_8BIT, 0x5000, 0xcf}, /* manual 3a */
+	{OV2722_8BIT, 0x301d, 0xf0}, /* enable group hold */
+	{OV2722_8BIT, 0x3a18, 0x00},
+	{OV2722_8BIT, 0x3a19, 0x80},
+	{OV2722_8BIT, 0x3503, 0x07},
+	{OV2722_8BIT, 0x4521, 0x00},
+	{OV2722_8BIT, 0x5183, 0xb0},
+	{OV2722_8BIT, 0x5184, 0xb0},
+	{OV2722_8BIT, 0x5185, 0xb0},
+	{OV2722_8BIT, 0x370c, 0x0c},
+	{OV2722_8BIT, 0x3035, 0x00},
+	{OV2722_8BIT, 0x3036, 0x26}, /* {0x3036, 0x2c}, //422.4 MHz */
+	{OV2722_8BIT, 0x3037, 0xa1},
+	{OV2722_8BIT, 0x303e, 0x19},
+	{OV2722_8BIT, 0x3038, 0x06},
+	{OV2722_8BIT, 0x3018, 0x04},
+	{OV2722_8BIT, 0x3000, 0x00}, /* added for power optimization */
+	{OV2722_8BIT, 0x3001, 0x00},
+	{OV2722_8BIT, 0x3002, 0x00},
+	{OV2722_8BIT, 0x3a0f, 0x40},
+	{OV2722_8BIT, 0x3a10, 0x38},
+	{OV2722_8BIT, 0x3a1b, 0x48},
+	{OV2722_8BIT, 0x3a1e, 0x30},
+	{OV2722_8BIT, 0x3a11, 0x90},
+	{OV2722_8BIT, 0x3a1f, 0x10},
+	{OV2722_8BIT, 0x3503, 0x07}, /* manual 3a */
+	{OV2722_8BIT, 0x3500, 0x00},
+	{OV2722_8BIT, 0x3501, 0x3F},
+	{OV2722_8BIT, 0x3502, 0x00},
+	{OV2722_8BIT, 0x3508, 0x00},
+	{OV2722_8BIT, 0x3509, 0x00},
+	{OV2722_TOK_TERM, 0, 0},
+};
+
+struct ov2722_resolution ov2722_res_preview[] = {
+	{
+		.desc = "ov2722_1452_1092_30fps",
+		.width = 1452,
+		.height = 1092,
+		.fps = 30,
+		.pix_clk_freq = 85,
+		.used = 0,
+		.pixels_per_line = 2260,
+		.lines_per_frame = 1244,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_1452_1092_30fps,
+		.mipi_freq = 422400,
+	},
+	{
+		.desc = "ov2722_1080P_30fps",
+		.width = 1932,
+		.height = 1092,
+		.pix_clk_freq = 85,
+		.fps = 30,
+		.used = 0,
+		.pixels_per_line = 2260,
+		.lines_per_frame = 1244,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_1080p_30fps,
+		.mipi_freq = 422400,
+	},
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(ov2722_res_preview))
+
+struct ov2722_resolution ov2722_res_still[] = {
+	{
+		.desc = "ov2722_1452_1092_30fps",
+		.width = 1452,
+		.height = 1092,
+		.fps = 30,
+		.pix_clk_freq = 85,
+		.used = 0,
+		.pixels_per_line = 2260,
+		.lines_per_frame = 1244,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_1452_1092_30fps,
+		.mipi_freq = 422400,
+	},
+	{
+		.desc = "ov2722_1080P_30fps",
+		.width = 1932,
+		.height = 1092,
+		.fps = 30,
+		.pix_clk_freq = 85,
+		.used = 0,
+		.pixels_per_line = 2260,
+		.lines_per_frame = 1244,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_1080p_30fps,
+		.mipi_freq = 422400,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(ov2722_res_still))
+
+struct ov2722_resolution ov2722_res_video[] = {
+	{
+		.desc = "ov2722_QVGA_30fps",
+		.width = 336,
+		.height = 256,
+		.fps = 30,
+		.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 2048,
+		.lines_per_frame = 1184,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_QVGA_30fps,
+		.mipi_freq = 364800,
+	},
+	{
+		.desc = "ov2722_VGA_30fps",
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 2048,
+		.lines_per_frame = 1184,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_VGA_30fps,
+		.mipi_freq = 364800,
+	},
+	{
+		.desc = "ov2722_720p_30fps",
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pix_clk_freq = 75,
+		.used = 0,
+		.pixels_per_line = 2048,
+		.lines_per_frame = 1187,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_720p_30fps,
+		.mipi_freq = 364800,
+	},
+	{
+		.desc = "ov2722_1M3_30fps",
+		.width = 1416,
+		.height = 1034,
+		.fps = 30,
+		.pix_clk_freq = 73,
+		.used = 0,
+		.pixels_per_line = 2048,
+		.lines_per_frame = 1184,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_1M3_30fps,
+		.mipi_freq = 364800,
+	},
+	{
+		.desc = "ov2722_1080P_30fps",
+		.width = 1932,
+		.height = 1092,
+		.fps = 30,
+		.pix_clk_freq = 85,
+		.used = 0,
+		.pixels_per_line = 2260,
+		.lines_per_frame = 1244,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov2722_1080p_30fps,
+		.mipi_freq = 422400,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(ov2722_res_video))
+
+static struct ov2722_resolution *ov2722_res = ov2722_res_preview;
+static int N_RES = N_RES_PREVIEW;
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5640.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5640.c
new file mode 100644
index 0000000..0da671b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5640.c
@@ -0,0 +1,2239 @@
+/*
+ * Support for ov5640 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/firmware.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "ov5640.h"
+
+#define to_ov5640_sensor(sd) container_of(sd, struct ov5640_device, sd)
+
+static int
+ov5640_read_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err < 0) {
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == MISENSOR_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == MISENSOR_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int
+ov5640_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16((u16)val);
+	} else {
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = cpu_to_be32(val);
+	}
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_err(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return num_msg;
+}
+
+static int ov5640_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	int ret;
+	int retry = 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (ret == 1)
+		return 0;
+
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_dbg(&client->dev, "retrying i2c write transfer... %d",
+			retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return ret;
+}
+
+/*
+ * __ov5640_flush_reg_array() is internal function to make writing reg
+ * faster and should be not used anywhere else.
+ */
+static int __ov5640_flush_reg_array(struct i2c_client *client,
+				     struct ov5640_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov5640_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+/*
+ * ov5640_write_reg_array - Initializes a list of MT9T111 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * Initializes a list of MT9T111 registers. The list of registers is
+ * terminated by MISENSOR_TOK_TERM.
+ */
+static int ov5640_write_reg_array(struct i2c_client *client,
+			    const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	int err;
+
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		if (next->length == MISENSOR_TOK_DELAY) {
+			msleep(next->val);
+		} else {
+			err = ov5640_write_reg(client, next->length, next->reg,
+						next->val);
+			/* REVISIT: Do we need this delay? */
+			udelay(10);
+			if (err) {
+				dev_err(&client->dev, "%s err. aborted\n",
+					__func__);
+				return err;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static const struct firmware *
+load_firmware(struct device *dev)
+{
+	const struct firmware *fw;
+	int rc;
+
+	rc = request_firmware(&fw, AF_FW_PATH, dev);
+	if (rc) {
+		if (rc == -ENOENT)
+			dev_err(dev, "Error AF firmware %s not found.\n",
+					AF_FW_PATH);
+		else
+			dev_err(dev,
+				"Error %d while requesting firmware %s\n",
+				rc, AF_FW_PATH);
+		return NULL;
+	}
+
+	return fw;
+}
+
+static int ov5640_af_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	const struct firmware *firmware;
+	struct ov5640_write_ctrl ctrl;
+	int err;
+	int i;
+	int group_length;
+
+	/* reset MCU */
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+				OV5640_REG_SYS_RESET, OV5640_MCU_RESET);
+	if (err)
+		return err;
+
+	/* download firmware */
+	if (dev->firmware) {
+		firmware = dev->firmware;
+	} else {
+		firmware = load_firmware(&client->dev);
+		if (!firmware) {
+			dev_err(&client->dev, "Load firmwares failed\n");
+			return -EINVAL;
+		}
+		dev->firmware = firmware;
+	}
+
+	/* download firmware in group */
+	group_length = (firmware->size) / (OV5640_MAX_WRITE_BUF_SIZE - 2);
+	for (i = 0; i < group_length; i++) {
+		ctrl.buffer.addr = OV5640_REG_FW_START
+				    + i * (OV5640_MAX_WRITE_BUF_SIZE - 2);
+		memcpy(ctrl.buffer.data,
+			&firmware->data[i * (OV5640_MAX_WRITE_BUF_SIZE - 2)],
+			(OV5640_MAX_WRITE_BUF_SIZE - 2));
+		ctrl.index = (OV5640_MAX_WRITE_BUF_SIZE - 2);
+		err = __ov5640_flush_reg_array(client, &ctrl);
+		if (err) {
+			dev_err(&client->dev, "write firmwares reg failed\n");
+			return err;
+		}
+	}
+
+	/* download firmware less than 1 group */
+	ctrl.buffer.addr = OV5640_REG_FW_START +
+				i * (OV5640_MAX_WRITE_BUF_SIZE - 2);
+	memcpy(ctrl.buffer.data,
+		&firmware->data[i * (OV5640_MAX_WRITE_BUF_SIZE - 2)],
+		firmware->size - i * (OV5640_MAX_WRITE_BUF_SIZE - 2));
+	ctrl.index = firmware->size - i * (OV5640_MAX_WRITE_BUF_SIZE - 2);
+	err = __ov5640_flush_reg_array(client, &ctrl);
+	if (err) {
+		dev_err(&client->dev, "write firmwares reg failed\n");
+		return err;
+	}
+	return ov5640_write_reg_array(client, ov5640_focus_init);
+}
+
+static int ov5640_s_focus_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int err = 0;
+
+	/*
+	 * if sensor streamoff, writing focus mode reg is invalid.
+	 * only writing focus mode reg is valid after streamon.
+	 */
+	if (dev->streaming == false) {
+		dev->focus_mode = mode;
+		dev->focus_mode_change = true;
+		return 0;
+	}
+
+	switch (mode) {
+	case V4L2_CID_AUTO_FOCUS_START:
+		/* start single focus */
+		err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_FOCUS_MODE,
+						OV5640_SINGLE_FOCUS);
+		break;
+	case V4L2_CID_FOCUS_AUTO:
+		/* start continuous focus */
+		err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_FOCUS_MODE,
+						OV5640_CONTINUE_FOCUS);
+		break;
+	case V4L2_CID_3A_LOCK:
+		/* pause focus */
+		err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_FOCUS_MODE,
+						OV5640_PAUSE_FOCUS);
+		break;
+	case V4L2_CID_AUTO_FOCUS_STOP:
+		/* release focus to infinity */
+		err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_FOCUS_MODE,
+						OV5640_RELEASE_FOCUS);
+		break;
+	default:
+		dev_err(&client->dev, "invalid mode.\n");
+		return -EINVAL;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting focus mode fails.\n");
+		return err;
+	}
+
+	dev->focus_mode = mode;
+	dev->focus_mode_change = false;
+
+	return 0;
+}
+
+static int ov5640_s_single_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_START);
+}
+
+static int ov5640_s_cont_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_s_focus_mode(sd, V4L2_CID_FOCUS_AUTO);
+}
+
+static int ov5640_pause_focus(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (value != V4L2_LOCK_FOCUS) {
+		dev_err(&client->dev, "invalid focus cmd.\n");
+		return -EINVAL;
+	}
+
+	return ov5640_s_focus_mode(sd, V4L2_CID_3A_LOCK);
+}
+
+static int ov5640_release_focus(struct v4l2_subdev *sd, s32 value)
+{
+	return ov5640_s_focus_mode(sd, V4L2_CID_AUTO_FOCUS_STOP);
+}
+
+static int ov5640_s_color_effect(struct v4l2_subdev *sd, int effect)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int err = 0;
+
+	if (dev->color_effect == effect)
+		return 0;
+
+	switch (effect) {
+	case V4L2_COLORFX_NONE:
+		err = ov5640_write_reg_array(client, ov5640_normal_effect);
+		break;
+	case V4L2_COLORFX_SEPIA:
+		err = ov5640_write_reg_array(client, ov5640_sepia_effect);
+		break;
+	case V4L2_COLORFX_NEGATIVE:
+		err = ov5640_write_reg_array(client, ov5640_negative_effect);
+		break;
+	case V4L2_COLORFX_BW:
+		err = ov5640_write_reg_array(client, ov5640_bw_effect);
+		break;
+	case V4L2_COLORFX_SKY_BLUE:
+		err = ov5640_write_reg_array(client, ov5640_blue_effect);
+		break;
+	case V4L2_COLORFX_GRASS_GREEN:
+		err = ov5640_write_reg_array(client, ov5640_green_effect);
+		break;
+	default:
+		dev_err(&client->dev, "invalid color effect.\n");
+		return -ERANGE;
+	}
+	if (err) {
+		dev_err(&client->dev, "setting color effect fails.\n");
+		return err;
+	}
+
+	dev->color_effect = effect;
+	return 0;
+}
+
+static int ov5640_g_color_effect(struct v4l2_subdev *sd, int *effect)
+{
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+
+	*effect = dev->color_effect;
+
+	return 0;
+}
+
+static int ov5640_g_image_brightness(struct v4l2_subdev *sd, int *brightness)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	/* get target image luminance average */
+	return ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_AVERAGE, brightness);
+}
+
+static int ov5640_g_focus_status(struct v4l2_subdev *sd, int *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val = 0;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_FOCUS_STATUS, &val);
+	if (err)
+		return err;
+
+	switch (val & 0xff) {
+	case OV5640_FOCUS_FW_DL:
+		/* firmware is downloaded and not to be initialized */
+		*status = V4L2_AUTO_FOCUS_STATUS_FAILED;
+		break;
+	case OV5640_FOCUS_FW_INIT:
+		/* firmware is initializing */
+	case OV5640_FOCUS_FW_IDLE:
+		/* firmware is idle */
+		*status = V4L2_AUTO_FOCUS_STATUS_IDLE;
+		break;
+	case OV5640_FOCUS_FW_RUN:
+		/* focus is running */
+		*status = V4L2_AUTO_FOCUS_STATUS_BUSY;
+		break;
+	case OV5640_FOCUS_FW_FINISH:
+		/* focus is finished */
+		*status = V4L2_AUTO_FOCUS_STATUS_REACHED;
+		break;
+	default:
+		/*
+		 * when focus is idle, the status value is variable,
+		 * but it is different with status value above, and
+		 * the value is 0x20 in most of cases.
+		 */
+		*status = V4L2_AUTO_FOCUS_STATUS_IDLE;
+	}
+
+	return 0;
+}
+
+/* calculate sysclk */
+static int ov5640_get_sysclk(struct v4l2_subdev *sd, unsigned int *sysclk)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp1 = 0, temp2 = 0;
+	u32 multiplier = 0, prediv = 0, vco = 0, sysdiv = 0;
+	u32 pll_rdiv = 0, bit_div2x = 0, sclk_rdiv = 0;
+
+	static int sclk_rdiv_map[] = {1, 2, 4, 8};
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_PLL_CTRL_0, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10)
+		bit_div2x = temp2 >> 1;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_PLL_CTRL_1, &temp1);
+	if (err)
+		return err;
+	sysdiv = temp1 >> 4;
+	if (sysdiv == 0)
+		sysdiv = 16;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_PLL_CTRL_2, &temp1);
+	if (err)
+		return err;
+	multiplier = temp1;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_PLL_CTRL_3, &temp1);
+	if (err)
+		return err;
+	prediv = temp1 & 0x0f;
+	pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_CLK_DIVIDER, &temp1);
+	if (err)
+		return err;
+	temp2 = temp1 & 0x03;
+	sclk_rdiv = sclk_rdiv_map[temp2];
+
+	if ((prediv && sclk_rdiv && bit_div2x) == 0)
+		return -EINVAL;
+
+	vco = OV5640_XVCLK * multiplier / prediv;
+
+	*sysclk = vco / sysdiv / pll_rdiv * 2 / bit_div2x / sclk_rdiv;
+
+	if (*sysclk < MIN_SYSCLK)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read HTS from register settings */
+static int ov5640_get_hts(struct v4l2_subdev *sd, unsigned int *hts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_read_reg(client, MISENSOR_16BIT,
+				OV5640_REG_TIMING_HTS, hts);
+	if (err)
+		return err;
+
+	if (*hts < MIN_HTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* read VTS from register settings */
+static int ov5640_get_vts(struct v4l2_subdev *sd, unsigned int *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_read_reg(client, MISENSOR_16BIT,
+				OV5640_REG_TIMING_VTS, vts);
+	if (err)
+		return err;
+
+	if (*vts < MIN_VTS)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write VTS to registers */
+static int ov5640_set_vts(struct v4l2_subdev *sd, unsigned int vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_write_reg(client, MISENSOR_16BIT,
+					OV5640_REG_TIMING_VTS, vts);
+}
+
+/* read shutter, in number of line period */
+static int ov5640_get_shutter(struct v4l2_subdev *sd, unsigned int *shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val, temp;
+
+	err = ov5640_read_reg(client, MISENSOR_16BIT,
+					OV5640_REG_EXPOSURE_0, &val);
+	if (err)
+		return err;
+	temp = (val & 0x0fff);
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_EXPOSURE_1, &val);
+	if (err)
+		return err;
+
+	*shutter = (temp << 4) + (val >> 4);
+
+	if (*shutter < MIN_SHUTTER)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write shutter, in number of line period */
+static int ov5640_set_shutter(struct v4l2_subdev *sd, unsigned int shutter)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	shutter = shutter & 0xffff;
+	temp = shutter & 0x0f;
+	temp = temp << 4;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_EXPOSURE_1, temp);
+	if (err)
+		return err;
+
+	temp = shutter >> 4;
+	return ov5640_write_reg(client, MISENSOR_16BIT,
+					OV5640_REG_EXPOSURE_0, temp);
+}
+
+/* read gain, 16 = 1x */
+static int ov5640_get_gain16(struct v4l2_subdev *sd, unsigned int *gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 val;
+
+	err = ov5640_read_reg(client, MISENSOR_16BIT,
+					OV5640_REG_GAIN, &val);
+	if (err)
+		return err;
+
+	*gain16 = val & 0x3ff;
+
+	if (*gain16 < MIN_GAIN)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* write gain, 16 = 1x */
+static int ov5640_set_gain16(struct v4l2_subdev *sd, unsigned int gain16)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	gain16 = gain16 & 0x3ff;
+
+	return ov5640_write_reg(client, MISENSOR_16BIT,
+					OV5640_REG_GAIN, gain16);
+}
+
+/*
+ * This returns the exposure compensation value, which is expressed in
+ * terms of EV. The default EV value is 0, and driver don't support
+ * adjust EV value.
+ */
+static int ov5640_get_exposure_bias(struct v4l2_subdev *sd, s32 *value)
+{
+	*value = 0;
+
+	return 0;
+}
+
+/*
+ * This returns ISO sensitivity.
+ */
+static int ov5640_get_iso(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 gain;
+	int err;
+
+	err = ov5640_get_gain16(sd, &gain);
+	if (err)
+		return err;
+
+	*value = gain / 16 * 100;
+
+	return 0;
+}
+
+/* get banding filter value */
+static int ov5640_get_light_frequency(struct v4l2_subdev *sd,
+				unsigned int *light_frequency)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+	u32 temp;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_LIGHT_CTRL_0, &temp);
+	if (err)
+		return err;
+
+	if (temp & OV5640_AUTO_BAND) {
+		/* manual */
+		err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_LIGHT_CTRL_1, &temp);
+		if (err)
+			return err;
+		if (temp & 0x04)
+			/* 50Hz */
+			*light_frequency = OV5640_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_LIGHT_60HZ;
+	} else {
+		/* auto */
+		err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_LIGHT_CTRL_2, &temp);
+		if (err)
+			return err;
+		if (temp & 0x01)
+			/* 50Hz */
+			*light_frequency = OV5640_LIGHT_50HZ;
+		else
+			/* 60Hz */
+			*light_frequency = OV5640_LIGHT_60HZ;
+	}
+
+	return 0;
+}
+
+static int ov5640_set_bandingfilter(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	u32 band_step60, max_band60, band_step50, max_band50;
+	int err;
+
+	/* read preview PCLK */
+	err = ov5640_get_sysclk(sd, &dev->preview_sysclk);
+	if (err)
+		return err;
+
+	/* read preview HTS */
+	err = ov5640_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	/* read preview VTS */
+	err = ov5640_get_vts(sd, &dev->preview_vts);
+	if (err)
+		return err;
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = dev->preview_sysclk * 100 / dev->preview_hts * 100 / 120;
+	if (band_step60 == 0)
+		return -EINVAL;
+
+	err = ov5640_write_reg(client, MISENSOR_16BIT, OV5640_REG_B60_STEP,
+								band_step60);
+	if (err)
+		return err;
+
+	max_band60 = (dev->preview_vts - 4) / band_step60;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_B60_MAX, max_band60);
+	if (err)
+		return err;
+
+	/* 50Hz */
+	band_step50 = dev->preview_sysclk * 100 / dev->preview_hts;
+	if (band_step50 == 0)
+		return -EINVAL;
+
+	err = ov5640_write_reg(client, MISENSOR_16BIT, OV5640_REG_B50_STEP,
+								band_step50);
+	if (err)
+		return err;
+
+	max_band50 = (dev->preview_vts - 4) / band_step50;
+	return ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_B50_MAX, max_band50);
+}
+
+/* stable in high */
+static int ov5640_set_ae_target(struct v4l2_subdev *sd, unsigned int target)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int err;
+	u32 fast_high, fast_low;
+	dev->ae_low = target * 23 / 25;	 /* 0.92 */
+	dev->ae_high = target * 27 / 25; /* 1.08 */
+
+	fast_high = dev->ae_high << 1;
+	if (fast_high > 255)
+		fast_high = 255;
+
+	fast_low = dev->ae_low >> 1;
+
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_STAB_IN_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_STAB_IN_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_STAB_OUT_H, dev->ae_high);
+	if (err)
+		return err;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_STAB_OUT_L, dev->ae_low);
+	if (err)
+		return err;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_FAST_H, fast_high);
+	if (err)
+		return err;
+	return ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_FAST_L, fast_low);
+}
+
+static int
+ov5640_set_ag_ae(struct i2c_client *client, int enable)
+{
+	return ov5640_write_reg(client, MISENSOR_8BIT,
+			OV5640_REG_AE_MODE_CTRL,
+			enable ? OV5640_AUTO_AG_AE : OV5640_MANUAL_AG_AE);
+}
+
+static int ov5640_set_night_mode(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_SYS_CTRL, &temp);
+	if (err)
+		return err;
+
+	if (enable) {
+		temp = temp | 0x04;
+		return ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_SYS_CTRL, temp);
+	} else {
+		temp = temp & 0xfb;
+		return ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AE_SYS_CTRL, temp);
+	}
+}
+
+static int ov5640_set_awb_gain_mode(struct v4l2_subdev *sd, int mode)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int temp;
+	int err;
+
+	err = ov5640_read_reg(client, MISENSOR_8BIT,
+					OV5640_REG_AWB_CTRL, &temp);
+	if (err)
+		return err;
+
+	switch (mode) {
+	case OV5640_AWB_GAIN_AUTO:
+		/* set awb gain to auto */
+		temp = temp & 0xfe;
+		err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_AWB_CTRL, temp);
+		break;
+	case OV5640_AWB_GAIN_MANUAL:
+		/* set awb gain to manual */
+		temp = temp | 0x01;
+		err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_AWB_CTRL, temp);
+		break;
+	default:
+		dev_err(&client->dev, "invalid awb gain mode.\n");
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int ov5640_start_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int ret;
+
+	dev->preview_ag_ae = false;
+
+	ret = ov5640_set_awb_gain_mode(sd, OV5640_AWB_GAIN_AUTO);
+	if (ret)
+		return ret;
+
+	ret = ov5640_set_gain16(sd, dev->preview_gain16);
+	if (ret)
+		return ret;
+
+	ret = ov5640_set_shutter(sd, dev->preview_shutter);
+	if (ret)
+		return ret;
+
+	ret = ov5640_set_ag_ae(client, 1);
+	if (ret)
+		return ret;
+
+	ret = ov5640_set_bandingfilter(sd);
+	if (ret)
+		return ret;
+
+	ret = ov5640_set_ae_target(sd, OV5640_AE_TARGET);
+	if (ret)
+		return ret;
+
+	return ov5640_set_night_mode(sd, dev->night_mode);
+}
+
+static int ov5640_stop_preview(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int err;
+
+	/* read preview shutter */
+	err = ov5640_get_shutter(sd, &dev->preview_shutter);
+	if (err)
+		return err;
+
+	err = ov5640_get_gain16(sd, &dev->preview_gain16);
+	if (err)
+		return err;
+
+	err = ov5640_get_hts(sd, &dev->preview_hts);
+	if (err)
+		return err;
+
+	dev->preview_ag_ae = true;
+
+	err = ov5640_set_awb_gain_mode(sd, OV5640_AWB_GAIN_MANUAL);
+	if (err)
+		return err;
+
+	/* get average */
+	return ov5640_read_reg(client, MISENSOR_8BIT,
+				OV5640_REG_AE_AVERAGE, &dev->average);
+}
+
+static int ov5640_start_video(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int err;
+
+	err = ov5640_set_awb_gain_mode(sd, OV5640_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_set_ag_ae(client, 1);
+	if (err)
+		return err;
+
+	err = ov5640_set_bandingfilter(sd);
+	if (err)
+		return err;
+
+	err = ov5640_set_ae_target(sd, OV5640_AE_TARGET);
+	if (err)
+		return err;
+
+	return ov5640_set_night_mode(sd, 0);
+}
+
+static int ov5640_start_capture(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	u32 capture_sysclk, capture_hts, capture_vts;
+	u32 capture_shutter, capture_gain16;
+	u32 light_frequency, capture_bandingfilter, capture_max_band;
+	long capture_gain16_shutter;
+	int err;
+
+	if (!dev->preview_ag_ae) {
+		dev_err(&client->dev, "preview gain and shutter are not available.\n");
+		return -EINVAL;
+	}
+
+	err = ov5640_set_awb_gain_mode(sd, OV5640_AWB_GAIN_AUTO);
+	if (err)
+		return err;
+
+	err = ov5640_set_ag_ae(client, 0);
+	if (err)
+		return err;
+
+	/* read capture VTS */
+	err = ov5640_get_vts(sd, &capture_vts);
+	if (err)
+		return err;
+
+	err = ov5640_get_hts(sd, &capture_hts);
+	if (err)
+		return err;
+
+	err = ov5640_get_sysclk(sd, &capture_sysclk);
+	if (err)
+		return err;
+
+	/* calculate capture banding filter */
+	err = ov5640_get_light_frequency(sd, &light_frequency);
+	if (err)
+		return err;
+
+	if (light_frequency == OV5640_LIGHT_60HZ) {
+		/* 60Hz */
+		capture_bandingfilter = capture_sysclk * 100 /
+						capture_hts * 100 / 120;
+	} else {
+		/* 50Hz */
+		capture_bandingfilter = capture_sysclk * 100 / capture_hts;
+	}
+
+	if (capture_bandingfilter == 0)
+		return -EINVAL;
+
+	capture_max_band = (int)((capture_vts - 4) / capture_bandingfilter);
+	if (capture_max_band == 0)
+		return -EINVAL;
+
+	/* calculate capture shutter/gain16 */
+	if (dev->average > dev->ae_low && dev->average < dev->ae_high) {
+		/* in stable range */
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts *
+					OV5640_AE_TARGET / dev->average;
+	} else {
+		capture_gain16_shutter = dev->preview_gain16 *
+					dev->preview_shutter *
+					capture_sysclk / dev->preview_sysclk *
+					dev->preview_hts / capture_hts;
+	}
+	/* gain to shutter */
+	if (capture_gain16_shutter < (capture_bandingfilter * 16)) {
+		/* shutter < 1/100 */
+		capture_shutter = capture_gain16_shutter / 16;
+		if (capture_shutter < 1)
+			capture_shutter = 1;
+		capture_gain16 = capture_gain16_shutter / capture_shutter;
+		if (capture_gain16 < 16)
+			capture_gain16 = 16;
+	} else {
+		if (capture_gain16_shutter >
+			(capture_bandingfilter * capture_max_band * 16)) {
+			/* exposure reach max */
+			capture_shutter = capture_bandingfilter *
+							capture_max_band;
+			capture_gain16 = capture_gain16_shutter /
+							capture_shutter;
+		} else {
+			/*
+			 * 1/100 < capture_shutter =< max,
+			 * capture_shutter = n/100
+			 */
+			capture_shutter = ((int)(capture_gain16_shutter / 16 /
+						capture_bandingfilter)) *
+						capture_bandingfilter;
+			if (capture_shutter == 0)
+				return -EINVAL;
+
+			capture_gain16 = capture_gain16_shutter /
+						capture_shutter;
+		}
+	}
+
+	/* write capture gain */
+	err = ov5640_set_gain16(sd, capture_gain16);
+	if (err)
+		return err;
+
+	/* write capture shutter */
+	if (capture_shutter > (capture_vts - 4)) {
+		capture_vts = capture_shutter + 4;
+		err = ov5640_set_vts(sd, capture_vts);
+		if (err)
+			return err;
+	}
+
+	return ov5640_set_shutter(sd, capture_shutter);
+}
+
+static int ov5640_standby(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_write_reg_array(client, ov5640_standby_reg);
+}
+
+static int ov5640_wakeup(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov5640_write_reg_array(client, ov5640_wakeup_reg);
+}
+
+static int __ov5640_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = ov5640_write_reg_array(client, ov5640_init);
+	if (ret)
+		return ret;
+
+	/*
+	 * delay 5ms to wait for sensor initialization finish.
+	 */
+	usleep_range(5000, 6000);
+
+	ret = ov5640_af_init(sd);
+	if (ret)
+		return ret;
+	msleep(20);
+
+	return ov5640_standby(sd);
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/*
+	 * according to DS, 20ms is needed between power up and first i2c
+	 * commend
+	 */
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	/*according to DS, 20ms is needed after power down*/
+	msleep(20);
+
+	return ret;
+}
+
+static int ov5640_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+
+	if (power_up(sd))
+		return -EINVAL;
+
+	return __ov5640_init(sd);
+}
+
+static int ov5640_try_res(u32 *w, u32 *h)
+{
+	int i;
+
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_res[i].width >= *w &&
+		    ov5640_res[i].height >= *h)
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = ov5640_res[i].width;
+	*h = ov5640_res[i].height;
+
+	return 0;
+}
+
+static struct ov5640_res_struct *ov5640_to_res(u32 w, u32 h)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_res[index].width == w &&
+		    ov5640_res[index].height == h)
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		return NULL;
+
+	return &ov5640_res[index];
+}
+
+static int ov5640_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	return ov5640_try_res(&fmt->width, &fmt->height);
+}
+
+static int ov5640_res2size(unsigned int res, int *h_size, int *v_size)
+{
+	unsigned short hsize;
+	unsigned short vsize;
+
+	switch (res) {
+	case OV5640_RES_QVGA:
+		hsize = OV5640_RES_QVGA_SIZE_H;
+		vsize = OV5640_RES_QVGA_SIZE_V;
+		break;
+	case OV5640_RES_DVGA:
+		hsize = OV5640_RES_DVGA_SIZE_H;
+		vsize = OV5640_RES_DVGA_SIZE_V;
+		break;
+	case OV5640_RES_320P:
+		hsize = OV5640_RES_320P_SIZE_H;
+		vsize = OV5640_RES_320P_SIZE_V;
+		break;
+	case OV5640_RES_360P:
+		hsize = OV5640_RES_360P_SIZE_H;
+		vsize = OV5640_RES_360P_SIZE_V;
+		break;
+	case OV5640_RES_VGA:
+		hsize = OV5640_RES_VGA_SIZE_H;
+		vsize = OV5640_RES_VGA_SIZE_V;
+		break;
+	case OV5640_RES_480P:
+		hsize = OV5640_RES_480P_SIZE_H;
+		vsize = OV5640_RES_480P_SIZE_V;
+		break;
+	case OV5640_RES_720P:
+		hsize = OV5640_RES_720P_SIZE_H;
+		vsize = OV5640_RES_720P_SIZE_V;
+		break;
+	case OV5640_RES_1080P:
+		hsize = OV5640_RES_1080P_SIZE_H;
+		vsize = OV5640_RES_1080P_SIZE_V;
+		break;
+	case OV5640_RES_1088P:
+		hsize = OV5640_RES_1088P_SIZE_H;
+		vsize = OV5640_RES_1088P_SIZE_V;
+		break;
+	case OV5640_RES_D3M:
+		hsize = OV5640_RES_D3M_SIZE_H;
+		vsize = OV5640_RES_D3M_SIZE_V;
+		break;
+	case OV5640_RES_3M:
+		hsize = OV5640_RES_3M_SIZE_H;
+		vsize = OV5640_RES_3M_SIZE_V;
+		break;
+	case OV5640_RES_D5M:
+		hsize = OV5640_RES_D5M_SIZE_H;
+		vsize = OV5640_RES_D5M_SIZE_V;
+		break;
+	case OV5640_RES_5M:
+		hsize = OV5640_RES_5M_SIZE_H;
+		vsize = OV5640_RES_5M_SIZE_V;
+		break;
+	default:
+		/* QVGA mode is still unsupported */
+		WARN(1, "%s: Resolution 0x%08x unknown\n", __func__, res);
+		return -EINVAL;
+	}
+
+	if (h_size != NULL)
+		*h_size = hsize;
+	if (v_size != NULL)
+		*v_size = vsize;
+
+	return 0;
+}
+
+static int ov5640_g_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int width, height;
+	int ret;
+
+	ret = ov5640_res2size(dev->res, &width, &height);
+	if (ret)
+		return ret;
+	fmt->width = width;
+	fmt->height = height;
+
+	return 0;
+}
+
+static int ov5640_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	struct ov5640_res_struct *res_index;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	int ret;
+
+	ov5640_try_res(&width, &height);
+	res_index = ov5640_to_res(width, height);
+
+	/* Sanity check */
+	if (unlikely(!res_index)) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	switch (res_index->res) {
+	case OV5640_RES_QVGA:
+		ret = ov5640_write_reg_array(c, ov5640_qvga_init);
+		break;
+	case OV5640_RES_DVGA:
+		ret = ov5640_write_reg_array(c, ov5640_dvga_init);
+		break;
+	case OV5640_RES_320P:
+		ret = ov5640_write_reg_array(c, ov5640_320p_init);
+		break;
+	case OV5640_RES_360P:
+		ret = ov5640_write_reg_array(c, ov5640_360p_init);
+		break;
+	case OV5640_RES_VGA:
+		ret = ov5640_write_reg_array(c, ov5640_vga_init);
+		break;
+	case OV5640_RES_480P:
+		ret = ov5640_write_reg_array(c, ov5640_480p_init);
+		break;
+	case OV5640_RES_720P:
+		ret = ov5640_write_reg_array(c, ov5640_720p_init);
+		break;
+	case OV5640_RES_1080P:
+		ret = ov5640_write_reg_array(c, ov5640_1080p_init);
+		break;
+	case OV5640_RES_1088P:
+		ret = ov5640_write_reg_array(c, ov5640_1088p_init);
+		break;
+	case OV5640_RES_D3M:
+		ret = ov5640_write_reg_array(c, ov5640_D3M_init);
+		break;
+	case OV5640_RES_3M:
+		ret = ov5640_write_reg_array(c, ov5640_3M_init);
+		break;
+	case OV5640_RES_D5M:
+		ret = ov5640_write_reg_array(c, ov5640_D5M_init);
+		break;
+	case OV5640_RES_5M:
+		ret = ov5640_write_reg_array(c, ov5640_5M_init);
+		break;
+	default:
+		/* QVGA is not implemented yet */
+		dev_err(&c->dev, "set resolution: %d failed!\n",
+							res_index->res);
+		return -EINVAL;
+	}
+	if (ret)
+		return -EINVAL;
+
+	if (dev->res != res_index->res) {
+		int index;
+
+		/*
+		 * Marked current sensor res as being "used"
+		 *
+		 * REVISIT: We don't need to use an "used" field on each mode
+		 * list entry to know which mode is selected. If this
+		 * information is really necessary, how about to use a single
+		 * variable on sensor dev struct?
+		 */
+		for (index = 0; index < N_RES; index++) {
+			if (width == ov5640_res[index].width &&
+			    height == ov5640_res[index].height) {
+				ov5640_res[index].used = 1;
+				continue;
+			}
+			ov5640_res[index].used = 0;
+		}
+	}
+
+	/*
+	 * ov5640 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->res = res_index->res;
+
+	fmt->width = width;
+	fmt->height = height;
+
+	/* relaunch default focus zone */
+	ret = ov5640_write_reg(c, MISENSOR_8BIT,
+					OV5640_REG_FOCUS_MODE,
+					OV5640_RELAUNCH_FOCUS);
+	if (ret)
+		return -EINVAL;
+
+	return ov5640_wakeup(sd);
+}
+
+static int ov5640_detect(struct i2c_client *client,  u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 retvalue;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+
+	if (ov5640_read_reg(client, MISENSOR_16BIT,
+		OV5640_REG_PID, &retvalue)) {
+		dev_err(&client->dev, "sensor_id_high = 0x%x\n", retvalue);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "sensor_id = 0x%x\n", retvalue);
+	if (retvalue != OV5640_MOD_ID) {
+		dev_err(&client->dev, "%s: failed: client->addr = %x\n",
+			__func__, client->addr);
+		return -ENODEV;
+	}
+
+	/* REVISIT: HACK: Driver is currently forcing revision to 0 */
+	*revision = 0;
+
+	return 0;
+}
+
+static int
+ov5640_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	ret = ov5640_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "power_ctrl failed");
+		return ret;
+	}
+
+	/* config & detect sensor */
+	ret = ov5640_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		dev_err(&client->dev, "ov5640_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = ov5640_s_power(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "sensor power-gating failed\n");
+
+	return ret;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	ov5640_s_power(sd, 0);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+
+static int ov5640_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_FOCAL_LENGTH_NUM << 16) | OV5640_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov5640_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/* const f number for OV5640 */
+	*val = (OV5640_F_NUMBER_DEFAULT_NUM << 16) | OV5640_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5640_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5640_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV5640_F_NUMBER_DEM << 16) |
+		(OV5640_F_NUMBER_DEFAULT_NUM << 8) | OV5640_F_NUMBER_DEM;
+	return 0;
+}
+
+static struct ov5640_control ov5640_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_get_shutter,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_EXPOSURE_BIAS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure bias",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_get_exposure_bias,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_ISO_SENSITIVITY,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "iso",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov5640_get_iso,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_START,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "single focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_s_single_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCUS_AUTO,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "continuous focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_s_cont_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_3A_LOCK,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "pause focus",
+			.minimum = 0,
+			.maximum = 1 << 2,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_pause_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STOP,
+			.type = V4L2_CTRL_TYPE_BUTTON,
+			.name = "release focus",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_release_focus,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_FOCUS_STATUS,
+			.type = V4L2_CTRL_TYPE_BITMASK,
+			.name = "focus status",
+			.minimum = 0,
+			.maximum = 0x07,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov5640_g_focus_status,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BRIGHTNESS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "target image luminance",
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov5640_g_image_brightness,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_COLORFX,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "color effect",
+			.minimum = 0,
+			.maximum = 9,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov5640_s_color_effect,
+		.query = ov5640_g_color_effect,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = 0,
+			.maximum = OV5640_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = 0,
+			.maximum = OV5640_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV5640_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov5640_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = 0,
+			.maximum =  OV5640_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV5640_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov5640_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov5640_controls))
+
+static struct ov5640_control *ov5640_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (ov5640_controls[i].qc.id == id)
+			return &ov5640_controls[i];
+	}
+	return NULL;
+}
+
+static int ov5640_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov5640_control *ctrl = ov5640_find_control(qc->id);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	return 0;
+}
+
+static int ov5640_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_control *octrl = ov5640_find_control(ctrl->id);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	ret = octrl->query(sd, &ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov5640_control *octrl = ov5640_find_control(ctrl->id);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+
+	ret = octrl->tweak(sd, ctrl->value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov5640_mipi_stream(struct i2c_client *client, int enable)
+{
+	return ov5640_write_reg(client, MISENSOR_8BIT,
+			OV5640_REG_FRAME_CTRL,
+			enable ? OV5640_FRAME_START : OV5640_FRAME_STOP);
+}
+
+static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int err;
+
+	if (enable) {
+		switch (dev->run_mode) {
+		case CI_MODE_PREVIEW:
+			err = ov5640_start_preview(sd);
+			break;
+		case CI_MODE_VIDEO:
+			err = ov5640_start_video(sd);
+			break;
+		case CI_MODE_STILL_CAPTURE:
+			err = ov5640_start_capture(sd);
+			break;
+		default:
+			dev_err(&client->dev,
+				"invalid run mode.\n");
+			return -EINVAL;
+		}
+		if (err)
+			dev_warn(&client->dev,
+				"fail to start preview/video/capture.\n");
+
+		err = ov5640_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		dev->streaming = true;
+		if (dev->focus_mode_change) {
+			err = ov5640_s_focus_mode(sd, dev->focus_mode);
+			if (err) {
+				dev_err(&client->dev,
+					"writing focus mode reg fails.\n");
+				return err;
+			}
+			dev->focus_mode_change = false;
+		}
+	} else {
+		if (dev->run_mode == CI_MODE_PREVIEW) {
+			err = ov5640_stop_preview(sd);
+			if (err)
+				dev_warn(&client->dev,
+					"fail to stop preview\n");
+		}
+
+		err = ov5640_mipi_stream(client, enable);
+		if (err)
+			return err;
+
+		err = ov5640_standby(sd);
+		if (err)
+			return err;
+		dev->streaming = false;
+		dev->focus_mode = V4L2_CID_3A_LOCK;
+	}
+
+	return 0;
+}
+
+static int
+ov5640_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov5640_res[index].width;
+	fsize->discrete.height = ov5640_res[index].height;
+
+	fsize->reserved[0] = ov5640_res[index].used;
+
+	return 0;
+}
+
+static int ov5640_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	/* find out the first equal or bigger size */
+	for (i = 0; i < N_RES; i++) {
+		if (ov5640_res[i].width >= fival->width &&
+		    ov5640_res[i].height >= fival->height)
+			break;
+	}
+	if (i == N_RES)
+		i--;
+
+	index = i;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov5640_res[index].fps;
+
+	return 0;
+}
+
+static int
+ov5640_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV5640, 0);
+}
+
+static int ov5640_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov5640_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	unsigned int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov5640_res[index].width;
+	fse->min_height = ov5640_res[index].height;
+	fse->max_width = ov5640_res[index].width;
+	fse->max_height = ov5640_res[index].height;
+
+	return 0;
+}
+
+static int
+ov5640_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_device *snr = to_ov5640_sensor(sd);
+
+	switch (fmt->which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		fmt->format = *v4l2_subdev_get_try_format(fh, fmt->pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		fmt->format = snr->format;
+	}
+
+	return 0;
+}
+
+static int
+ov5640_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov5640_device *snr = to_ov5640_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+/* set focus zone */
+static int
+ov5640_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+	int focus_width_step, focus_height_step;
+	u32 x_center, y_center;
+	int width, height;
+	int err, index;
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE) {
+		dev_err(&client->dev,
+				"invalid selection format.\n");
+		return -EINVAL;
+	}
+
+	if (sel->target != V4L2_SEL_TGT_COMPOSE) {
+		dev_err(&client->dev,
+				"invalid selection compose.\n");
+		return -EINVAL;
+	}
+
+	for (index = 0; index < N_RES; index++) {
+		if (dev->res == ov5640_res[index].res) {
+			width = ov5640_res[index].width;
+			height = ov5640_res[index].height;
+			break;
+		}
+	}
+
+	focus_width_step = width / OV5640_FOCUS_ZONE_ARRAY_WIDTH;
+	focus_height_step = height / OV5640_FOCUS_ZONE_ARRAY_HEIGHT;
+
+	/* calculate the center coordinate of selection rectangle */
+	x_center = DIV_ROUND_UP((sel->r.left + sel->r.width / 2),
+						focus_width_step);
+	y_center = DIV_ROUND_UP((sel->r.top + sel->r.height / 2),
+						focus_height_step);
+
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_FOCUS_ZONE_X,
+					x_center);
+	if (err)
+		return err;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+					OV5640_REG_FOCUS_ZONE_Y,
+					y_center);
+	if (err)
+		return err;
+	err = ov5640_write_reg(client, MISENSOR_8BIT,
+						OV5640_REG_FOCUS_MODE,
+						OV5640_S_FOCUS_ZONE);
+	if (err)
+		return err;
+
+	return ov5640_s_focus_mode(sd, dev->focus_mode);
+}
+
+static int
+ov5640_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->res >= 0 && dev->res < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			ov5640_res[dev->res].fps;
+	}
+	return 0;
+}
+
+static int
+ov5640_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov5640_device *dev = to_ov5640_sensor(sd);
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	dev->run_mode = param->parm.capture.capturemode;
+	return ov5640_g_parm(sd, param);
+}
+
+static int
+ov5640_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	int index;
+	struct ov5640_device *snr = to_ov5640_sensor(sd);
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov5640_res[index].res == snr->res) {
+			*frames = ov5640_res[index].skip_frames;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static const struct v4l2_subdev_video_ops ov5640_video_ops = {
+	.try_mbus_fmt = ov5640_try_mbus_fmt,
+	.g_mbus_fmt = ov5640_g_mbus_fmt,
+	.s_mbus_fmt = ov5640_s_mbus_fmt,
+	.s_parm = ov5640_s_parm,
+	.g_parm = ov5640_g_parm,
+	.s_stream = ov5640_s_stream,
+	.enum_framesizes = ov5640_enum_framesizes,
+	.enum_frameintervals = ov5640_enum_frameintervals,
+};
+
+static const struct v4l2_subdev_sensor_ops ov5640_sensor_ops = {
+	.g_skip_frames	= ov5640_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops ov5640_core_ops = {
+	.g_chip_ident = ov5640_g_chip_ident,
+	.queryctrl = ov5640_queryctrl,
+	.g_ctrl = ov5640_g_ctrl,
+	.s_ctrl = ov5640_s_ctrl,
+	.s_power = ov5640_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops ov5640_pad_ops = {
+	.enum_mbus_code = ov5640_enum_mbus_code,
+	.enum_frame_size = ov5640_enum_frame_size,
+	.get_fmt = ov5640_get_pad_format,
+	.set_fmt = ov5640_set_pad_format,
+	.set_selection = ov5640_set_selection,
+};
+
+static const struct v4l2_subdev_ops ov5640_ops = {
+	.core = &ov5640_core_ops,
+	.video = &ov5640_video_ops,
+	.sensor = &ov5640_sensor_ops,
+	.pad = &ov5640_pad_ops,
+};
+
+static const struct media_entity_operations ov5640_entity_ops;
+
+static int ov5640_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5640_device *dev = container_of(sd,
+					struct ov5640_device, sd);
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	release_firmware(dev->firmware);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov5640_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct ov5640_device *dev;
+	int ret;
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &ov5640_ops);
+	if (client->dev.platform_data) {
+		ret = ov5640_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret) {
+			v4l2_device_unregister_subdev(&dev->sd);
+			kfree(dev);
+			return ret;
+		}
+	}
+	/*TODO add format code here*/
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.ops = &ov5640_entity_ops;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		ov5640_remove(client);
+		return ret;
+	}
+
+	/* set res index to be invalid */
+	dev->res = -1;
+
+	/* set focus mode to be invalid */
+	dev->focus_mode = -1;
+
+	/* set color_effect to be invalid */
+	dev->color_effect = -1;
+	dev->preview_gain16 = OV5640_DEFAULT_GAIN;
+	dev->preview_shutter = OV5640_DEFAULT_SHUTTER;
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov5640_id);
+static struct i2c_driver ov5640_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV5640_NAME,
+	},
+	.probe = ov5640_probe,
+	.remove = __exit_p(ov5640_remove),
+	.id_table = ov5640_id,
+};
+
+static __init int ov5640_init_mod(void)
+{
+	return i2c_add_driver(&ov5640_driver);
+}
+
+static __exit void ov5640_exit_mod(void)
+{
+	i2c_del_driver(&ov5640_driver);
+}
+
+module_init(ov5640_init_mod);
+module_exit(ov5640_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV5640 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5640.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5640.h
new file mode 100644
index 0000000..26403f2
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5640.h
@@ -0,0 +1,1904 @@
+/*
+ * Support for ov5640 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV5640_H__
+#define __OV5640_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define OV5640_NAME	"ov5640"
+
+#define V4L2_IDENT_OV5640 1111
+#define	LAST_REG_SETING	{0xffff, 0xff}
+
+#define OV5640_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define OV5640_FOCAL_LENGTH_DEM	100
+#define OV5640_F_NUMBER_DEFAULT_NUM	24
+#define OV5640_F_NUMBER_DEM	10
+#define OV5640_FOCUS_ZONE_ARRAY_WIDTH	80
+#define OV5640_FOCUS_ZONE_ARRAY_HEIGHT	60
+
+#define OV5640_XVCLK		1920
+#define OV5640_AE_TARGET	45
+#define OV5640_DEFAULT_GAIN	50
+#define OV5640_DEFAULT_SHUTTER	1000
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_FOCAL_LENGTH_DEFAULT 0xD00064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5640_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV5640_F_NUMBER_RANGE 0x180a180a
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+#define OV5640_REG_PID		0x300a
+#define OV5640_REG_SYS_RESET	0x3000
+#define OV5640_REG_FW_START	0x8000
+#define OV5640_REG_FOCUS_MODE	0x3022	/* focus mode reg */
+#define OV5640_REG_FOCUS_ZONE_X	0x3024	/* X coordinate of focus zone center */
+#define OV5640_REG_FOCUS_ZONE_Y	0x3025	/* Y coordinate of focus zone center */
+#define OV5640_REG_FOCUS_STATUS	0x3029	/* focus status reg */
+
+/* system pll control reg */
+#define OV5640_REG_PLL_CTRL_0	0x3034
+#define OV5640_REG_PLL_CTRL_1	0x3035
+#define OV5640_REG_PLL_CTRL_2	0x3036
+#define OV5640_REG_PLL_CTRL_3	0x3037
+
+/* pad clock divider for SCCB clock */
+#define OV5640_REG_CLK_DIVIDER	0x3108
+
+/* total horizontal size reg */
+#define OV5640_REG_TIMING_HTS	0x380c
+
+/* total vertical size reg */
+#define OV5640_REG_TIMING_VTS	0x380e
+
+/* exposure output reg */
+#define OV5640_REG_EXPOSURE_0	0x3500
+#define OV5640_REG_EXPOSURE_1	0x3502
+
+/* gain reg */
+#define OV5640_REG_GAIN	0x350a
+
+/* light frequency control reg */
+#define OV5640_REG_LIGHT_CTRL_0	0x3c01
+#define OV5640_REG_LIGHT_CTRL_1	0x3c00
+#define OV5640_REG_LIGHT_CTRL_2	0x3c0c
+
+/* light frequency */
+#define OV5640_LIGHT_50HZ	50
+#define OV5640_LIGHT_60HZ	60
+
+/* automatic banding filter */
+#define OV5640_AUTO_BAND	0x80
+
+/* 60HZ band step reg and 60HZ max bands */
+#define OV5640_REG_B60_STEP	0x3a0a
+#define OV5640_REG_B60_MAX	0x3a0d
+
+/* 50HZ band step reg and 50HZ max bands */
+#define OV5640_REG_B50_STEP	0x3a08
+#define OV5640_REG_B50_MAX	0x3a0e
+
+/* AEC domain control reg */
+#define OV5640_REG_AE_STAB_IN_H	0x3a0f	/* stable in high */
+#define OV5640_REG_AE_STAB_IN_L	0x3a10	/* stable in low */
+#define OV5640_REG_AE_STAB_OUT_H	0x3a1b	/* stable out high */
+#define OV5640_REG_AE_STAB_OUT_L	0x3a1e	/* stable out low */
+#define OV5640_REG_AE_FAST_H	0x3a11	/* fast zone high */
+#define OV5640_REG_AE_FAST_L	0x3a1f	/* fast zone low */
+
+/* AEC mode control reg */
+#define OV5640_REG_AE_MODE_CTRL	0x3503
+
+#define OV5640_AUTO_AG_AE	0x00	/* auto AG&AE */
+#define OV5640_MANUAL_AG_AE	0x03	/* manual AG&AE */
+
+/* AEC system control reg */
+#define OV5640_REG_AE_SYS_CTRL	0x3a00
+
+/* image exposure average readout reg */
+#define OV5640_REG_AE_AVERAGE	0x56a1
+
+/* frame control reg */
+#define OV5640_REG_FRAME_CTRL	0x4202
+
+#define OV5640_FRAME_START	0x00
+#define OV5640_FRAME_STOP	0x0f
+
+#define OV5640_MCU_RESET	0x20
+#define OV5640_SINGLE_FOCUS	0x03
+#define OV5640_CONTINUE_FOCUS	0x04
+#define OV5640_PAUSE_FOCUS	0x06
+#define OV5640_RELEASE_FOCUS	0x08
+#define OV5640_RELAUNCH_FOCUS	0x12
+#define OV5640_S_FOCUS_ZONE	0x81
+
+/* focus firmware is downloaded but not to be initialized */
+#define OV5640_FOCUS_FW_DL	0x7f
+#define OV5640_FOCUS_FW_INIT	0x7e	/* focus firmware is initializing */
+#define OV5640_FOCUS_FW_IDLE	0x70	/* focus firmware is idle */
+#define OV5640_FOCUS_FW_RUN	0x00	/* focus firmware is running */
+#define OV5640_FOCUS_FW_FINISH	0x10	/* focus is finished */
+
+#define OV5640_REG_AWB_CTRL	0x3406
+
+#define OV5640_AWB_GAIN_AUTO	0
+#define OV5640_AWB_GAIN_MANUAL	1
+
+#define MIN_SYSCLK		10
+#define MIN_VTS			8
+#define MIN_HTS			8
+#define MIN_SHUTTER		0
+#define MIN_GAIN		0
+
+/* OV5640_DEVICE_ID */
+#define OV5640_MOD_ID		0x5640
+
+#define AF_FW_PATH	"OV5640_AF_FW.bin"
+
+/* Supported resolutions */
+enum {
+	OV5640_RES_QVGA,
+	OV5640_RES_DVGA,
+	OV5640_RES_320P,
+	OV5640_RES_360P,
+	OV5640_RES_VGA,
+	OV5640_RES_480P,
+	OV5640_RES_720P,
+	OV5640_RES_1080P,
+	OV5640_RES_1088P,
+	OV5640_RES_D3M,
+	OV5640_RES_3M,
+	OV5640_RES_D5M,
+	OV5640_RES_5M,
+};
+#define OV5640_RES_5M_SIZE_H		2560
+#define OV5640_RES_5M_SIZE_V		1920
+#define OV5640_RES_D5M_SIZE_H		2496
+#define OV5640_RES_D5M_SIZE_V		1664
+#define OV5640_RES_D3M_SIZE_H		2112
+#define OV5640_RES_D3M_SIZE_V		1408
+#define OV5640_RES_3M_SIZE_H		2048
+#define OV5640_RES_3M_SIZE_V		1536
+#define OV5640_RES_1088P_SIZE_H		1920
+#define OV5640_RES_1088P_SIZE_V		1088
+#define OV5640_RES_1080P_SIZE_H		1920
+#define OV5640_RES_1080P_SIZE_V		1080
+#define OV5640_RES_720P_SIZE_H		1280
+#define OV5640_RES_720P_SIZE_V		720
+#define OV5640_RES_480P_SIZE_H		720
+#define OV5640_RES_480P_SIZE_V		480
+#define OV5640_RES_VGA_SIZE_H		640
+#define OV5640_RES_VGA_SIZE_V		480
+#define OV5640_RES_360P_SIZE_H		640
+#define OV5640_RES_360P_SIZE_V		360
+#define OV5640_RES_320P_SIZE_H		480
+#define OV5640_RES_320P_SIZE_V		320
+#define OV5640_RES_DVGA_SIZE_H		416
+#define OV5640_RES_DVGA_SIZE_V		312
+#define OV5640_RES_QVGA_SIZE_H		320
+#define OV5640_RES_QVGA_SIZE_V		240
+
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u16 length;
+	u16 reg;
+	u32 val;	/* value or for read/mod/write */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov5640_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct firmware *firmware;
+
+	struct camera_sensor_platform_data *platform_data;
+	int run_mode;
+	int focus_mode;
+	int night_mode;
+	bool focus_mode_change;
+	int color_effect;
+	bool streaming;
+	bool preview_ag_ae;
+	u16 sensor_id;
+	u8 sensor_revision;
+	unsigned int ae_high;
+	unsigned int ae_low;
+	unsigned int preview_shutter;
+	unsigned int preview_gain16;
+	unsigned int average;
+	unsigned int preview_sysclk;
+	unsigned int preview_hts;
+	unsigned int preview_vts;
+	unsigned int res;
+};
+
+struct ov5640_priv_data {
+	u32 port;
+	u32 num_of_lane;
+	u32 input_format;
+	u32 raw_bayer_order;
+};
+
+struct ov5640_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct ov5640_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int skip_frames;
+	bool used;
+	struct regval_list *regs;
+};
+
+#define OV5640_MAX_WRITE_BUF_SIZE	32
+struct ov5640_write_buffer {
+	u16 addr;
+	u8 data[OV5640_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov5640_write_ctrl {
+	int index;
+	struct ov5640_write_buffer buffer;
+};
+
+struct ov5640_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+#define N_ov5640_FMTS ARRAY_SIZE(ov5640_formats)
+
+/*
+ * Modes supported by the mt9m114 driver.
+ * Please, keep them in ascending order.
+ */
+static struct ov5640_res_struct ov5640_res[] = {
+	{
+	.desc	= "QVGA",
+	.res	= OV5640_RES_QVGA,
+	.width	= 320,
+	.height	= 240,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "DVGA",
+	.res	= OV5640_RES_DVGA,
+	.width	= 416,
+	.height	= 312,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "320P",
+	.res	= OV5640_RES_320P,
+	.width	= 480,
+	.height	= 320,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "360P",
+	.res	= OV5640_RES_360P,
+	.width	= 640,
+	.height	= 360,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 5,
+	},
+	{
+	.desc	= "VGA",
+	.res	= OV5640_RES_VGA,
+	.width	= 640,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "480P",
+	.res	= OV5640_RES_480P,
+	.width	= 720,
+	.height	= 480,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "720p",
+	.res	= OV5640_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "1080P",
+	.res	= OV5640_RES_1080P,
+	.width	= 1920,
+	.height	= 1080,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "1088P",
+	.res	= OV5640_RES_1088P,
+	.width	= 1920,
+	.height	= 1088,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D3M",
+	.res	= OV5640_RES_D3M,
+	.width	= 2112,
+	.height	= 1408,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "3M",
+	.res	= OV5640_RES_3M,
+	.width	= 2048,
+	.height	= 1536,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "D5M",
+	.res	= OV5640_RES_D5M,
+	.width	= 2496,
+	.height	= 1664,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+	{
+	.desc	= "5M",
+	.res	= OV5640_RES_5M,
+	.width	= 2560,
+	.height	= 1920,
+	.fps	= 15,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 4,
+	},
+};
+#define N_RES (ARRAY_SIZE(ov5640_res))
+
+static const struct i2c_device_id ov5640_id[] = {
+	{"ov5640", 0},
+	{}
+};
+
+static struct misensor_reg const ov5640_standby_reg[] = {
+	 {MISENSOR_8BIT,  0x300e, 0x5d},
+	 {MISENSOR_8BIT,  0x3008, 0x42},	/* software powerdown */
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_wakeup_reg[] = {
+	{MISENSOR_8BIT,  0x3008, 0x02},
+	{MISENSOR_8BIT,  0x300e, 0x45},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_normal_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x06},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_sepia_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0xA0},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_negative_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x46},
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_bw_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x80},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x80},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_blue_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0xA0},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x40},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_green_effect[] = {
+	{MISENSOR_8BIT, 0x3212, 0x03},	/* start group 3 */
+	{MISENSOR_8BIT, 0x5580, 0x1E},
+	{MISENSOR_8BIT, 0x5583, 0x60},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x60},	/* sat V */
+	{MISENSOR_8BIT, 0x5003, 0x08},
+	{MISENSOR_8BIT, 0x3212, 0x13},	/* end group 3 */
+	{MISENSOR_8BIT, 0x3212, 0xA3},	/* lanuch group 3 */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 5M, yuv422, 2lanes, mipi, 12fps */
+static struct misensor_reg const ov5640_5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x0A},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2560 */
+	{MISENSOR_8BIT, 0x380A, 0x07},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1920 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x06},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x08},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xB4},	/* total H-size is 2740 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xE8},	/* total v-size is 2024 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xE4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xE4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x2F},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFD},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D5M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_D5M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x09},
+	{MISENSOR_8BIT, 0x3809, 0xC0},	/* DVP output H_width, value is 2496 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1664 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0x83},	/* isp ctrl */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* 3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of input size. value is 2591 */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1927 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width, value is 2048 */
+	{MISENSOR_8BIT, 0x380A, 0x06},
+	{MISENSOR_8BIT, 0x380B, 0x00},	/* DVP output V_heigh, value is 1536 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0A},
+	{MISENSOR_8BIT, 0x380D, 0xA0},	/* total H-size is 2720 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0xF6},	/* total v-size is 2038 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xF2},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xF2},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x31},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xFE},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x08},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* D3M, yuv422, 2lanes, mipi, 15fps */
+static struct misensor_reg const ov5640_D3M_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* X start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of input size. value is 0 */
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},	/* X end of input size. value is 2527 */
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of input size. value is 1671 */
+	{MISENSOR_8BIT, 0x3808, 0x08},
+	{MISENSOR_8BIT, 0x3809, 0x40},	/* DVP output H_width, value is 2112 */
+	{MISENSOR_8BIT, 0x380A, 0x05},
+	{MISENSOR_8BIT, 0x380B, 0x80},	/* DVP output V_heigh, value is 1408 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0xB0},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},	/* 50HZ band steps */
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},	/* 60HZ band steps */
+	{MISENSOR_8BIT, 0x3A0E, 0x08},	/* 50HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A0D, 0x09},	/* 60HZ max band in one frame */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0xB0},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x0B},
+	{MISENSOR_8BIT, 0x380D, 0x1C},	/* total H-size is 2844 */
+	{MISENSOR_8BIT, 0x380E, 0x07},
+	{MISENSOR_8BIT, 0x380F, 0x95},	/* total v-size is 1941 */
+	{MISENSOR_8BIT, 0x3A02, 0x07},
+	{MISENSOR_8BIT, 0x3A03, 0x91},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x07},
+	{MISENSOR_8BIT, 0x3A15, 0x91},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x24},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF3},
+	{MISENSOR_8BIT, 0x3A0E, 0x06},
+	{MISENSOR_8BIT, 0x3A0D, 0x07},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1088p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1088p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06}, /* disable binning */
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of isp input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF9},	/* Y end of isp input size */
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* 1920 */
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x40},	/* 1088 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0x60},
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0x60},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 1080p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_1080p_init[] = {
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},
+	{MISENSOR_8BIT, 0x3C04, 0x28},
+	{MISENSOR_8BIT, 0x3C05, 0x98},
+	{MISENSOR_8BIT, 0x3C06, 0x00},
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3C08, 0x00},
+	{MISENSOR_8BIT, 0x3C09, 0x1C},
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},
+	{MISENSOR_8BIT, 0x3C0B, 0x40},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},
+	{MISENSOR_8BIT, 0x3808, 0x07},
+	{MISENSOR_8BIT, 0x3809, 0x80},
+	{MISENSOR_8BIT, 0x380A, 0x04},
+	{MISENSOR_8BIT, 0x380B, 0x38},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x06},
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x62},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x06},
+	{MISENSOR_8BIT, 0x4005, 0x1A}, /* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},
+	{MISENSOR_8BIT, 0x501F, 0x00},
+	{MISENSOR_8BIT, 0x4713, 0x02},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x5001, 0x83},
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x77},	/* h-size is 2423 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xCA},	/* v-size is 1226 */
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xC6},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xC6},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x57},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x1E},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 720p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_720p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x05},
+	{MISENSOR_8BIT, 0x3809, 0x00},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x02},
+	{MISENSOR_8BIT, 0x380B, 0xD0},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x97},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x53},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x06},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling*/
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},	/* same with 1080p */
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x18},	/* total H-size is 2328 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xA8},	/* total v-size is 1192 */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x66},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2A},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xA4},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xA4},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 480p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_480p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x04},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x3F},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0xD9},
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0xD0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x0B},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera: 320p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_320p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x09},
+	{MISENSOR_8BIT, 0x3805, 0xDF},
+	{MISENSOR_8BIT, 0x3806, 0x06},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xE0},
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x40},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x0B},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera: 360p, yuv422, 2lanes, mipi, 30fps */
+static struct misensor_reg const ov5640_360p_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x40},
+	{MISENSOR_8BIT, 0x3821, 0x06},
+	{MISENSOR_8BIT, 0x3814, 0x11},
+	{MISENSOR_8BIT, 0x3815, 0x11},
+	{MISENSOR_8BIT, 0x3800, 0x01},
+	{MISENSOR_8BIT, 0x3801, 0x50},	/* X start of input size */
+	{MISENSOR_8BIT, 0x3802, 0x01},
+	{MISENSOR_8BIT, 0x3803, 0xB2},	/* Y start of input size */
+	{MISENSOR_8BIT, 0x3804, 0x08},
+	{MISENSOR_8BIT, 0x3805, 0xEF},	/* X end of input size */
+	{MISENSOR_8BIT, 0x3806, 0x05},
+	{MISENSOR_8BIT, 0x3807, 0xF2},	/* Y end of input size */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output H_width */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x68},	/* DVP output V_heigh */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* X offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x04},	/* Y offset of pre-scaling */
+	{MISENSOR_8BIT, 0x3618, 0x04},
+	{MISENSOR_8BIT, 0x3612, 0x2B},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x12},
+	{MISENSOR_8BIT, 0x370C, 0x00},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4004, 0x02},	/* BLC line number */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x00},	/* system reset */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* enable all clock */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* enable clocks */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI enable, 2lane mode */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x02},	/* jepg mode select. JPEG mode 2 */
+	{MISENSOR_8BIT, 0x4407, 0x0C},	/* jpeg ctrl */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x37},	/* debug mode */
+	{MISENSOR_8BIT, 0x460C, 0x20},	/* VFIFO ctrl */
+	{MISENSOR_8BIT, 0x4837, 0x2C},	/* PCLK PERIOD */
+	{MISENSOR_8BIT, 0x3824, 0x01},	/* VFIFO */
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* isp ctrl, enable downscaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},	/* BLC ctrl */
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x11},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x01},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x09},
+	{MISENSOR_8BIT, 0x380D, 0x05},	/* total H-size is 2309 */
+	{MISENSOR_8BIT, 0x380E, 0x04},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total v-size is 1200*/
+	{MISENSOR_8BIT, 0x3A02, 0x04},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x04},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x68},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x2C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x0C},
+	{MISENSOR_8BIT, 0x5306, 0x18},
+	{MISENSOR_8BIT, 0x5308, 0x10},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+/* camera vga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_vga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* x start of isp input */
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},	/* Y start of isp input */
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},	/* X end of isp input */
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},	/* Y end of isp input */
+	{MISENSOR_8BIT, 0x3808, 0x02},
+	{MISENSOR_8BIT, 0x3809, 0x80},	/* DVP output */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0xE0},	/* DVP output */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},	/* X offset */
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},	/* Y offset */
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera qvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_qvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0x40},
+	{MISENSOR_8BIT, 0x380A, 0x00},
+	{MISENSOR_8BIT, 0x380B, 0xF0},
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x68},	/* total h_size is 1896 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB6},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6D},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x03},
+	{MISENSOR_8BIT, 0x4837, 0x30},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera dvga 30fps, yuv, 2lanes */
+static struct misensor_reg const ov5640_dvga_init[] = {
+	{MISENSOR_8BIT, 0x3C07, 0x08},
+	{MISENSOR_8BIT, 0x3820, 0x41},
+	{MISENSOR_8BIT, 0x3821, 0x07},	/* enable binning */
+	{MISENSOR_8BIT, 0x3814, 0x31},
+	{MISENSOR_8BIT, 0x3815, 0x31},	/* 2X2 binning */
+	{MISENSOR_8BIT, 0x3800, 0x00},
+	{MISENSOR_8BIT, 0x3801, 0x00},
+	{MISENSOR_8BIT, 0x3802, 0x00},
+	{MISENSOR_8BIT, 0x3803, 0x00},
+	{MISENSOR_8BIT, 0x3804, 0x0A},
+	{MISENSOR_8BIT, 0x3805, 0x1F},
+	{MISENSOR_8BIT, 0x3806, 0x07},
+	{MISENSOR_8BIT, 0x3807, 0x87},
+	{MISENSOR_8BIT, 0x3808, 0x01},
+	{MISENSOR_8BIT, 0x3809, 0xA0},	/* DVP output, value is 416 */
+	{MISENSOR_8BIT, 0x380A, 0x01},
+	{MISENSOR_8BIT, 0x380B, 0x38},	/* DVP output, value is 312 */
+	{MISENSOR_8BIT, 0x3810, 0x00},
+	{MISENSOR_8BIT, 0x3811, 0x08},
+	{MISENSOR_8BIT, 0x3812, 0x00},
+	{MISENSOR_8BIT, 0x3813, 0x02},
+	{MISENSOR_8BIT, 0x3618, 0x00},
+	{MISENSOR_8BIT, 0x3612, 0x29},
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3709, 0x52},
+	{MISENSOR_8BIT, 0x370C, 0x03},
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0x27},
+	{MISENSOR_8BIT, 0x3A0A, 0x00},
+	{MISENSOR_8BIT, 0x3A0B, 0xF6},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4001, 0x02},
+	{MISENSOR_8BIT, 0x4004, 0x02},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},
+	{MISENSOR_8BIT, 0x3004, 0xFF},
+	{MISENSOR_8BIT, 0x3006, 0xC3},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4713, 0x03},
+	{MISENSOR_8BIT, 0x4407, 0x04},
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	{MISENSOR_8BIT, 0x460B, 0x35},
+	{MISENSOR_8BIT, 0x460C, 0x22},
+	{MISENSOR_8BIT, 0x3824, 0x02},
+	{MISENSOR_8BIT, 0x5001, 0xA3},	/* enable scaling */
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	/* PLL */
+	{MISENSOR_8BIT, 0x3034, 0x18},
+	{MISENSOR_8BIT, 0x3035, 0x14},
+	{MISENSOR_8BIT, 0x3036, 0x68},
+	{MISENSOR_8BIT, 0x3037, 0x13},
+	{MISENSOR_8BIT, 0x3108, 0x01},
+	{MISENSOR_8BIT, 0x3824, 0x04},
+	{MISENSOR_8BIT, 0x460C, 0x20},
+	{MISENSOR_8BIT, 0x300E, 0x45},
+	{MISENSOR_8BIT, 0x303B, 0x14},
+	{MISENSOR_8BIT, 0x303C, 0x11},
+	{MISENSOR_8BIT, 0x303D, 0x17},
+	{MISENSOR_8BIT, 0x380C, 0x07},
+	{MISENSOR_8BIT, 0x380D, 0x70},	/* total h_size is 1904 */
+	{MISENSOR_8BIT, 0x380E, 0x05},
+	{MISENSOR_8BIT, 0x380F, 0xB0},	/* total V-size is 1456 */
+	{MISENSOR_8BIT, 0x3A02, 0x05},
+	{MISENSOR_8BIT, 0x3A03, 0xAC},	/* 60HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A14, 0x05},
+	{MISENSOR_8BIT, 0x3A15, 0xAC},	/* 50HZ max exposure output limit */
+	{MISENSOR_8BIT, 0x3A08, 0x01},
+	{MISENSOR_8BIT, 0x3A09, 0xB4},
+	{MISENSOR_8BIT, 0x3A0A, 0x01},
+	{MISENSOR_8BIT, 0x3A0B, 0x6C},
+	{MISENSOR_8BIT, 0x3A0E, 0x03},
+	{MISENSOR_8BIT, 0x3A0D, 0x04},
+	{MISENSOR_8BIT, 0x4837, 0x31},
+	{MISENSOR_8BIT, 0x5306, 0x08},
+	{MISENSOR_8BIT, 0x5308, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_common[] = {
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_iq[] = {
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_init[] = {
+	/* init software */
+	{MISENSOR_8BIT, 0x3103, 0x11},
+	{MISENSOR_TOK_DELAY, {0}, 5},
+	{MISENSOR_8BIT, 0x3008, 0x82},
+	{MISENSOR_TOK_DELAY, {0}, 5},
+	{MISENSOR_8BIT, 0x3008, 0x42},	/* software power down */
+	{MISENSOR_8BIT, 0x3103, 0x03},	/* SCCB system control */
+	/* set Frex Vsync href PCLK D[9:6} input */
+	{MISENSOR_8BIT, 0x3017, 0x00},
+	{MISENSOR_8BIT, 0x3018, 0x00},	/* set d[5:0] GPIO[1:0] input */
+	{MISENSOR_8BIT, 0x3034, 0x18},	/* MIPI 8-bit mode*/
+	{MISENSOR_8BIT, 0x3037, 0x13},	/* PLL */
+	{MISENSOR_8BIT, 0x3108, 0x01},	/* system divider */
+	{MISENSOR_8BIT, 0x3630, 0x36},
+	{MISENSOR_8BIT, 0x3631, 0x0E},
+	{MISENSOR_8BIT, 0x3632, 0xE2},
+	{MISENSOR_8BIT, 0x3633, 0x12},
+	{MISENSOR_8BIT, 0x3621, 0xE0},
+	{MISENSOR_8BIT, 0x3704, 0xA0},
+	{MISENSOR_8BIT, 0x3703, 0x5A},
+	{MISENSOR_8BIT, 0x3715, 0x78},
+	{MISENSOR_8BIT, 0x3717, 0x01},
+	{MISENSOR_8BIT, 0x370B, 0x60},
+	{MISENSOR_8BIT, 0x3705, 0x1A},
+	{MISENSOR_8BIT, 0x3905, 0x02},
+	{MISENSOR_8BIT, 0x3906, 0x10},
+	{MISENSOR_8BIT, 0x3901, 0x0A},
+	{MISENSOR_8BIT, 0x3731, 0x12},
+	{MISENSOR_8BIT, 0x3600, 0x08},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x3601, 0x33},	/* VCM debug mode */
+	{MISENSOR_8BIT, 0x302D, 0x60},	/* system control */
+	{MISENSOR_8BIT, 0x3620, 0x52},
+	{MISENSOR_8BIT, 0x371B, 0x20},
+	{MISENSOR_8BIT, 0x471C, 0x50},
+	{MISENSOR_8BIT, 0x3A13, 0x43},	/* AGC pre-gain 40 = 1x */
+	{MISENSOR_8BIT, 0x3A18, 0x00},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3A19, 0xF8},	/* gain ceiling */
+	{MISENSOR_8BIT, 0x3635, 0x13},
+	{MISENSOR_8BIT, 0x3636, 0x03},
+	{MISENSOR_8BIT, 0x3634, 0x40},
+	{MISENSOR_8BIT, 0x3622, 0x01},
+	{MISENSOR_8BIT, 0x3C00, 0x04},	/* 50Hz/60Hz */
+	{MISENSOR_8BIT, 0x3C01, 0xB4},	/* 50/60Hz */
+	{MISENSOR_8BIT, 0x3C04, 0x28},	/* threshold for low sum */
+	{MISENSOR_8BIT, 0x3C05, 0x98},	/* threshold for high sum */
+	{MISENSOR_8BIT, 0x3C06, 0x00},	/* light meter 1 threshold high */
+	{MISENSOR_8BIT, 0x3C08, 0x00},	/* light meter 2 threshold high */
+	{MISENSOR_8BIT, 0x3C09, 0x1C},	/* light meter 2 threshold low */
+	{MISENSOR_8BIT, 0x3C0A, 0x9C},	/* sample number high */
+	{MISENSOR_8BIT, 0x3C0B, 0x40},	/* sample number low */
+	/* timing */
+	{MISENSOR_8BIT, 0x3800, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3801, 0x00},	/* HS */
+	{MISENSOR_8BIT, 0x3802, 0x00},	/* VS */
+	{MISENSOR_8BIT, 0x3804, 0x0A},	/* HW */
+	{MISENSOR_8BIT, 0x3805, 0x3F},	/* HW */
+	{MISENSOR_8BIT, 0x3810, 0x00},	/* H offset high */
+	{MISENSOR_8BIT, 0x3811, 0x10},	/* H offset low */
+	{MISENSOR_8BIT, 0x3812, 0x00},	/* V offset high */
+	{MISENSOR_8BIT, 0x3708, 0x64},
+	{MISENSOR_8BIT, 0x3A08, 0x01},	/* B50 */
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4005, 0x1A},	/* BLC always update */
+	{MISENSOR_8BIT, 0x3000, 0x00},	/* system reset 0 */
+	{MISENSOR_8BIT, 0x3001, 0x08},	/* system reset 1 */
+	{MISENSOR_8BIT, 0x3002, 0x1C},	/* system reset 2 */
+	{MISENSOR_8BIT, 0x3004, 0xFF},	/* clock enable 00 */
+	{MISENSOR_8BIT, 0x3006, 0xC3},	/* clock enable 2 */
+	{MISENSOR_8BIT, 0x300E, 0x45},	/* MIPI control 2 lane MIPI on */
+	{MISENSOR_8BIT, 0x302E, 0x08},
+	{MISENSOR_8BIT, 0x4300, 0x32},	/* YUV 422 UYVY */
+	{MISENSOR_8BIT, 0x501F, 0x00},	/* ISP YUV 422 */
+	{MISENSOR_8BIT, 0x4407, 0x04},	/* JPEG QS */
+	{MISENSOR_8BIT, 0x440E, 0x00},
+	/* ISP control LENC on GAMMA on BPC on WPC on CIP on */
+	{MISENSOR_8BIT, 0x5000, 0xA7},
+	/* AWB */
+	{MISENSOR_8BIT, 0x5180, 0xFF},
+	{MISENSOR_8BIT, 0x5181, 0xF2},
+	{MISENSOR_8BIT, 0x5182, 0x00},
+	{MISENSOR_8BIT, 0x5183, 0x14},
+	{MISENSOR_8BIT, 0x5184, 0x25},
+	{MISENSOR_8BIT, 0x5185, 0x24},
+	{MISENSOR_8BIT, 0x5189, 0x8D},
+	{MISENSOR_8BIT, 0x518A, 0x61},
+	{MISENSOR_8BIT, 0x518C, 0x94},
+	{MISENSOR_8BIT, 0x518B, 0xAF},
+	{MISENSOR_8BIT, 0x5187, 0x17},
+	{MISENSOR_8BIT, 0x5188, 0x0F},
+	{MISENSOR_8BIT, 0x518D, 0x41},
+	{MISENSOR_8BIT, 0x518F, 0x75},
+	{MISENSOR_8BIT, 0x518E, 0x34},
+	{MISENSOR_8BIT, 0x5190, 0x43},
+	{MISENSOR_8BIT, 0x5191, 0xF5},
+	{MISENSOR_8BIT, 0x5192, 0x0A},
+	{MISENSOR_8BIT, 0x5186, 0x16},
+	{MISENSOR_8BIT, 0x5193, 0x70},
+	{MISENSOR_8BIT, 0x5194, 0xF0},
+	{MISENSOR_8BIT, 0x5195, 0xF0},
+	{MISENSOR_8BIT, 0x5196, 0x03},
+	{MISENSOR_8BIT, 0x5197, 0x01},
+	{MISENSOR_8BIT, 0x5198, 0x05},
+	{MISENSOR_8BIT, 0x5199, 0xDB},
+	{MISENSOR_8BIT, 0x519A, 0x04},
+	{MISENSOR_8BIT, 0x519B, 0x00},
+	{MISENSOR_8BIT, 0x519C, 0x08},
+	{MISENSOR_8BIT, 0x519D, 0x20},
+	{MISENSOR_8BIT, 0x519E, 0x38},
+	/* color matrix */
+	{MISENSOR_8BIT, 0x5381, 0x1F},
+	{MISENSOR_8BIT, 0x5382, 0x5C},
+	{MISENSOR_8BIT, 0x5383, 0x05},
+	{MISENSOR_8BIT, 0x5384, 0x03},
+	{MISENSOR_8BIT, 0x5385, 0x6C},
+	{MISENSOR_8BIT, 0x5386, 0x6F},
+	{MISENSOR_8BIT, 0x5387, 0x6E},
+	{MISENSOR_8BIT, 0x5388, 0x62},
+	{MISENSOR_8BIT, 0x5389, 0x0C},
+	{MISENSOR_8BIT, 0x538A, 0x01},
+	{MISENSOR_8BIT, 0x538B, 0x98},
+	/* CIP */
+	{MISENSOR_8BIT, 0x5300, 0x08},	/* sharpen MT th1 */
+	{MISENSOR_8BIT, 0x5301, 0x30},	/* sharpen MT th2 */
+	{MISENSOR_8BIT, 0x5302, 0x18},	/* sharpen MT offset 1 */
+	{MISENSOR_8BIT, 0x5303, 0x0E},	/* sharpen MT offset 2 */
+	{MISENSOR_8BIT, 0x5304, 0x08},	/* DNS threshold 1 */
+	{MISENSOR_8BIT, 0x5305, 0x30},	/* DNS threshold 2 */
+	{MISENSOR_8BIT, 0x5306, 0x08},	/* DNS offset 1 */
+	{MISENSOR_8BIT, 0x5307, 0x16},	/* DNS offset 2 */
+	{MISENSOR_8BIT, 0x5308, 0x00},	/* auto de-noise */
+	{MISENSOR_8BIT, 0x5309, 0x08},	/* sharpen TH th1 */
+	{MISENSOR_8BIT, 0x530A, 0x30},	/* sharpen TH th2 */
+	{MISENSOR_8BIT, 0x530B, 0x04},	/* sharpen TH offset 1 */
+	{MISENSOR_8BIT, 0x530C, 0x06},	/* sharpen TH offset 2 */
+	/* gamma */
+	{MISENSOR_8BIT, 0x5480, 0x01},
+	{MISENSOR_8BIT, 0x5481, 0x08},
+	{MISENSOR_8BIT, 0x5482, 0x14},
+	{MISENSOR_8BIT, 0x5483, 0x28},
+	{MISENSOR_8BIT, 0x5484, 0x51},
+	{MISENSOR_8BIT, 0x5485, 0x65},
+	{MISENSOR_8BIT, 0x5486, 0x71},
+	{MISENSOR_8BIT, 0x5487, 0x7D},
+	{MISENSOR_8BIT, 0x5488, 0x87},
+	{MISENSOR_8BIT, 0x5489, 0x91},
+	{MISENSOR_8BIT, 0x548A, 0x9A},
+	{MISENSOR_8BIT, 0x548B, 0xAA},
+	{MISENSOR_8BIT, 0x548C, 0xB8},
+	{MISENSOR_8BIT, 0x548D, 0xCD},
+	{MISENSOR_8BIT, 0x548E, 0xDD},
+	{MISENSOR_8BIT, 0x548F, 0xEA},
+	{MISENSOR_8BIT, 0x5490, 0x1D},
+	/* UV adjust */
+	{MISENSOR_8BIT, 0x5580, 0x06},	/* sat on contrast on */
+	{MISENSOR_8BIT, 0x5583, 0x40},	/* sat U */
+	{MISENSOR_8BIT, 0x5584, 0x10},	/* sat VV */
+	{MISENSOR_8BIT, 0x5589, 0x10},	/* UV adjust th1 */
+	{MISENSOR_8BIT, 0x558A, 0x00},	/* UV adjust th2[8] */
+	{MISENSOR_8BIT, 0x558B, 0xF8},	/* UV adjust th2[7:0] */
+	{MISENSOR_8BIT, 0x501D, 0x40},	/* enable manual offset of contrast */
+	/* lens correction */
+	{MISENSOR_8BIT, 0x5800, 0x3D},
+	{MISENSOR_8BIT, 0x5801, 0x1E},
+	{MISENSOR_8BIT, 0x5802, 0x15},
+	{MISENSOR_8BIT, 0x5803, 0x17},
+	{MISENSOR_8BIT, 0x5804, 0x1E},
+	{MISENSOR_8BIT, 0x5805, 0x3F},
+	{MISENSOR_8BIT, 0x5806, 0x10},
+	{MISENSOR_8BIT, 0x5807, 0x0A},
+	{MISENSOR_8BIT, 0x5808, 0x07},
+	{MISENSOR_8BIT, 0x5809, 0x07},
+	{MISENSOR_8BIT, 0x580A, 0x0B},
+	{MISENSOR_8BIT, 0x580B, 0x13},
+	{MISENSOR_8BIT, 0x580C, 0x0A},
+	{MISENSOR_8BIT, 0x580D, 0x04},
+	{MISENSOR_8BIT, 0x580E, 0x00},
+	{MISENSOR_8BIT, 0x580F, 0x00},
+	{MISENSOR_8BIT, 0x5810, 0x04},
+	{MISENSOR_8BIT, 0x5811, 0x0C},
+	{MISENSOR_8BIT, 0x5812, 0x0A},
+	{MISENSOR_8BIT, 0x5813, 0x04},
+	{MISENSOR_8BIT, 0x5814, 0x00},
+	{MISENSOR_8BIT, 0x5815, 0x00},
+	{MISENSOR_8BIT, 0x5816, 0x04},
+	{MISENSOR_8BIT, 0x5817, 0x0C},
+	{MISENSOR_8BIT, 0x5818, 0x10},
+	{MISENSOR_8BIT, 0x5819, 0x0B},
+	{MISENSOR_8BIT, 0x581A, 0x07},
+	{MISENSOR_8BIT, 0x581B, 0x07},
+	{MISENSOR_8BIT, 0x581C, 0x0A},
+	{MISENSOR_8BIT, 0x581D, 0x14},
+	{MISENSOR_8BIT, 0x581E, 0x37},
+	{MISENSOR_8BIT, 0x581F, 0x1F},
+	{MISENSOR_8BIT, 0x5820, 0x18},
+	{MISENSOR_8BIT, 0x5821, 0x18},
+	{MISENSOR_8BIT, 0x5822, 0x1F},
+	{MISENSOR_8BIT, 0x5823, 0x2F},
+	{MISENSOR_8BIT, 0x5824, 0x48},
+	{MISENSOR_8BIT, 0x5825, 0x2A},
+	{MISENSOR_8BIT, 0x5826, 0x2C},
+	{MISENSOR_8BIT, 0x5827, 0x08},
+	{MISENSOR_8BIT, 0x5828, 0x66},
+	{MISENSOR_8BIT, 0x5829, 0x0A},
+	{MISENSOR_8BIT, 0x582A, 0x26},
+	{MISENSOR_8BIT, 0x582B, 0x24},
+	{MISENSOR_8BIT, 0x582C, 0x26},
+	{MISENSOR_8BIT, 0x582D, 0x08},
+	{MISENSOR_8BIT, 0x582E, 0x08},
+	{MISENSOR_8BIT, 0x582F, 0x42},
+	{MISENSOR_8BIT, 0x5830, 0x40},
+	{MISENSOR_8BIT, 0x5831, 0x22},
+	{MISENSOR_8BIT, 0x5832, 0x06},
+	{MISENSOR_8BIT, 0x5833, 0x0A},
+	{MISENSOR_8BIT, 0x5834, 0x24},
+	{MISENSOR_8BIT, 0x5835, 0x24},
+	{MISENSOR_8BIT, 0x5836, 0x26},
+	{MISENSOR_8BIT, 0x5837, 0x06},
+	{MISENSOR_8BIT, 0x5838, 0x48},
+	{MISENSOR_8BIT, 0x5839, 0x08},
+	{MISENSOR_8BIT, 0x583A, 0x28},
+	{MISENSOR_8BIT, 0x583B, 0x06},
+	{MISENSOR_8BIT, 0x583C, 0x4A},
+	{MISENSOR_8BIT, 0x583D, 0xCE},
+	/* AE */
+	{MISENSOR_8BIT, 0x5025, 0x00},
+	{MISENSOR_8BIT, 0x3A0F, 0x30},	/* stable in high */
+	{MISENSOR_8BIT, 0x3A10, 0x28},	/* stable in low */
+	{MISENSOR_8BIT, 0x3A1B, 0x30},	/* stable out high */
+	{MISENSOR_8BIT, 0x3A1E, 0x26},	/* stable out low */
+	{MISENSOR_8BIT, 0x3A11, 0x60},	/* fast zone high */
+	{MISENSOR_8BIT, 0x3A1F, 0x14},	/* fast zone low */
+	{MISENSOR_8BIT, 0x350A, 0x00},
+	{MISENSOR_8BIT, 0x350B, 0x32},	/* default gain 50 */
+	{MISENSOR_8BIT, 0x3500, 0x00},
+	{MISENSOR_8BIT, 0x3501, 0x03},
+	{MISENSOR_8BIT, 0x3502, 0xE8},	/* default shutter 1000 */
+	/* BLC */
+	{MISENSOR_8BIT, 0x4000, 0x89},
+	{MISENSOR_8BIT, 0x4001, 0x02},	/* BLC start line */
+	{MISENSOR_8BIT, 0x4002, 0x45},
+	{MISENSOR_8BIT, 0x4003, 0x08},
+	{MISENSOR_8BIT, 0x4005, 0x18},
+	{MISENSOR_8BIT, 0x4009, 0x10},
+	{MISENSOR_8BIT, 0x4202, 0x00},	/* stream on */
+	{MISENSOR_8BIT, 0x4202, 0x0F},	/* stream off */
+	{MISENSOR_8BIT, 0x3008, 0x02},	/* wake up */
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov5640_focus_init[] = {
+	{MISENSOR_8BIT, 0x3022, 0x00},
+	{MISENSOR_8BIT, 0x3023, 0x00},
+	{MISENSOR_8BIT, 0x3024, 0x00},
+	{MISENSOR_8BIT, 0x3025, 0x00},
+	{MISENSOR_8BIT, 0x3026, 0x00},
+	{MISENSOR_8BIT, 0x3027, 0x00},
+	{MISENSOR_8BIT, 0x3028, 0x00},
+	{MISENSOR_8BIT, 0x3029, 0x7F},
+	{MISENSOR_8BIT, 0x3000, 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig
new file mode 100644
index 0000000..9fb1bff
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Kconfig
@@ -0,0 +1,11 @@
+config VIDEO_OV5693
+       tristate "Omnivision ov5693 sensor support"
+       depends on I2C && VIDEO_V4L2
+       ---help---
+         This is a Video4Linux2 sensor-level driver for the Micron
+         ov5693 5 Mpixel camera.
+
+         ov5693 is video camera sensor.
+
+         It currently only works with the atomisp driver.
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile
new file mode 100644
index 0000000..d8a63fa
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_VIDEO_OV5693) += ov569x.o
+
+ov569x-objs := ov5693.o ad5823.o
+
+ccflags-y += -Werror
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
new file mode 100644
index 0000000..e1d02a8
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.c
@@ -0,0 +1,226 @@
+#include <asm/intel-mid.h>
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+
+#include "ad5823.h"
+
+static struct ad5823_device ad5823_dev;
+static int ad5823_i2c_write(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct i2c_msg msg;
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = val;
+	msg.addr = AD5823_VCM_ADDR;
+	msg.flags = 0;
+	msg.len = AD5823_REG_LENGTH + AD5823_8BIT;
+	msg.buf = &buf[0];
+
+	if (i2c_transfer(client->adapter, &msg, 1) != 1)
+		return -EIO;
+	return 0;
+}
+
+static int ad5823_i2c_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = 0;
+
+	msg[0].addr = AD5823_VCM_ADDR;
+	msg[0].flags = 0;
+	msg[0].len = AD5823_REG_LENGTH;
+	msg[0].buf = &buf[0];
+
+	msg[1].addr = AD5823_VCM_ADDR;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = AD5823_8BIT;
+	msg[1].buf = &buf[1];
+	*val = 0;
+	if (i2c_transfer(client->adapter, msg, 2) != 2)
+		return -EIO;
+	*val = buf[1];
+	return 0;
+}
+
+int ad5823_vcm_power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = -EINVAL;
+	u8 vcm_mode_reg_val[4] = {
+		AD5823_ARC_RES0,
+		AD5823_ARC_RES1,
+		AD5823_ARC_RES2,
+		AD5823_ESRC
+	};
+
+	/* Enable power */
+	if (ad5823_dev.platform_data) {
+		ret = ad5823_dev.platform_data->power_ctrl(sd, 1);
+		if (ret)
+			return ret;
+	}
+	/*
+	 * waiting time requested by AD5823(vcm)
+	 */
+	usleep_range(1000, 2000);
+
+	/*
+	 * Set vcm ringing control mode.
+	 */
+	if (ad5823_dev.vcm_mode != AD5823_DIRECT) {
+		ret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_MSB,
+						AD5823_RING_CTRL_ENABLE);
+		if (ret)
+			return ret;
+
+		ret = ad5823_i2c_write(client, AD5823_REG_MODE,
+					vcm_mode_reg_val[ad5823_dev.vcm_mode]);
+		if (ret)
+			return ret;
+	} else {
+		ret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_MSB,
+						AD5823_RING_CTRL_DISABLE);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+int ad5823_vcm_power_down(struct v4l2_subdev *sd)
+{
+	int ret = -ENODEV;
+
+	if (ad5823_dev.platform_data)
+		ret = ad5823_dev.platform_data->power_ctrl(sd, 0);
+
+	return ret;
+}
+
+
+int ad5823_t_focus_vcm(struct v4l2_subdev *sd, u16 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = -EINVAL;
+	u8 vcm_code;
+
+	ret = ad5823_i2c_read(client, AD5823_REG_VCM_CODE_MSB, &vcm_code);
+	if (ret)
+		return ret;
+
+	/* set reg VCM_CODE_MSB Bit[1:0] */
+	vcm_code = (vcm_code & VCM_CODE_MSB_MASK) | ((val >> 8) & ~VCM_CODE_MSB_MASK);
+	ret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_MSB, vcm_code);
+	if (ret)
+		return ret;
+
+	/* set reg VCM_CODE_LSB Bit[7:0] */
+	ret = ad5823_i2c_write(client, AD5823_REG_VCM_CODE_LSB, (val & 0xff));
+	if (ret)
+		return ret;
+
+	/* set required vcm move time */
+	vcm_code = AD5823_RESONANCE_PERIOD / AD5823_RESONANCE_COEF
+		   - AD5823_HIGH_FREQ_RANGE;
+	ret = ad5823_i2c_write(client, AD5823_REG_VCM_MOVE_TIME, vcm_code);
+
+	return ret;
+}
+
+int ad5823_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	int ret;
+
+	value = min(value, AD5823_MAX_FOCUS_POS);
+	ret = ad5823_t_focus_vcm(sd, AD5823_MAX_FOCUS_POS - value);
+	if (ret == 0) {
+		ad5823_dev.number_of_steps = value - ad5823_dev.focus;
+		ad5823_dev.focus = value;
+		ktime_get_ts(&ad5823_dev.timestamp_t_focus_abs);
+	}
+
+	return ret;
+}
+
+int ad5823_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	return ad5823_t_focus_abs(sd, ad5823_dev.focus + value);
+}
+
+int ad5823_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	u32 status = 0;
+	struct timespec temptime;
+	const struct timespec timedelay = {
+		0,
+		min_t(u32, abs(ad5823_dev.number_of_steps)*DELAY_PER_STEP_NS,
+			DELAY_MAX_PER_STEP_NS),
+	};
+
+	ktime_get_ts(&temptime);
+
+	temptime = timespec_sub(temptime, (ad5823_dev.timestamp_t_focus_abs));
+
+	if (timespec_compare(&temptime, &timedelay) <= 0)
+		status = ATOMISP_FOCUS_STATUS_MOVING
+			| ATOMISP_FOCUS_HP_IN_PROGRESS;
+	else
+		status = ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE
+			| ATOMISP_FOCUS_HP_COMPLETE;
+
+	*value = status;
+
+	return 0;
+}
+
+int ad5823_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	s32 val;
+
+	ad5823_q_focus_status(sd, &val);
+
+	if (val & ATOMISP_FOCUS_STATUS_MOVING)
+		*value  = ad5823_dev.focus - ad5823_dev.number_of_steps;
+	else
+		*value  = ad5823_dev.focus ;
+
+	return 0;
+}
+
+int ad5823_t_vcm_slew(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int ad5823_t_vcm_timing(struct v4l2_subdev *sd, s32 value)
+{
+	return 0;
+}
+
+int ad5823_vcm_init(struct v4l2_subdev *sd)
+{
+	/* set vcm mode to ARC RES0.5 */
+	ad5823_dev.vcm_mode = AD5823_ARC_RES1;
+	ad5823_dev.platform_data = camera_get_af_platform_data();
+	return ad5823_dev.platform_data ? 0 : -ENODEV;
+}
+
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h
new file mode 100644
index 0000000..794f91f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ad5823.h
@@ -0,0 +1,92 @@
+/*
+ * Support for AD5823 VCM.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __AD5823_H__
+#define __AD5823_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/types.h>
+
+
+#define AD5823_VCM_ADDR	0x0c
+
+#define AD5823_REG_RESET		0x01
+#define AD5823_REG_MODE			0x02
+#define AD5823_REG_VCM_MOVE_TIME	0x03
+#define AD5823_REG_VCM_CODE_MSB		0x04
+#define AD5823_REG_VCM_CODE_LSB		0x05
+#define AD5823_REG_VCM_THRESHOLD_MSB	0x06
+#define AD5823_REG_VCM_THRESHOLD_LSB	0x07
+
+#define AD5823_REG_LENGTH		0x1
+
+#define AD5823_RING_CTRL_ENABLE		0x04
+#define AD5823_RING_CTRL_DISABLE	0x00
+
+#define AD5823_RESONANCE_PERIOD		100000
+#define AD5823_RESONANCE_COEF		512
+#define AD5823_HIGH_FREQ_RANGE		0x80
+
+#define VCM_CODE_MSB_MASK		0xfc
+
+enum ad5823_tok_type {
+	AD5823_8BIT  = 0x1,
+	AD5823_16BIT = 0x2,
+};
+
+enum ad5823_vcm_mode {
+	AD5823_ARC_RES0 = 0x0,	/* Actuator response control RES1 */
+	AD5823_ARC_RES1 = 0x1,	/* Actuator response control RES0.5 */
+	AD5823_ARC_RES2 = 0x2,	/* Actuator response control RES2 */
+	AD5823_ESRC = 0x3,	/* Enhanced slew rate control */
+	AD5823_DIRECT = 0x4,	/* Direct control */
+};
+
+/* ad5823 device structure */
+struct ad5823_device {
+	struct timespec timestamp_t_focus_abs;
+	enum ad5823_vcm_mode vcm_mode;
+	s16 number_of_steps;
+	bool initialized;		/* true if ad5823 is detected */
+	s32 focus;			/* Current focus value */
+	struct timespec focus_time;	/* Time when focus was last time set */
+	__u8 buffer[4];			/* Used for i2c transactions */
+	const struct camera_af_platform_data *platform_data;
+};
+
+#define AD5823_INVALID_CONFIG	0xffffffff
+#define AD5823_MAX_FOCUS_POS	1023
+
+
+#define DELAY_PER_STEP_NS	1000000
+#define DELAY_MAX_PER_STEP_NS	(1000000 * 1023)
+
+int ad5823_vcm_power_up(struct v4l2_subdev *sd);
+int ad5823_vcm_power_down(struct v4l2_subdev *sd);
+int ad5823_vcm_init(struct v4l2_subdev *sd);
+
+int ad5823_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+int ad5823_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+int ad5823_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+int ad5823_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+int ad5823_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
new file mode 100644
index 0000000..1459571
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.c
@@ -0,0 +1,1473 @@
+/*
+ * Support for OmniVision OV5693 5M HD camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "ov5693.h"
+
+static const uint32_t ov5693_embedded_effective_size = 28;
+
+/* i2c read/write stuff */
+static int ov5693_read_reg(struct i2c_client *client,
+			   u16 data_length, u16 reg, u16 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[6];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != OV5693_8BIT && data_length != OV5693_16BIT
+					&& data_length != OV5693_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == OV5693_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == OV5693_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int ov5693_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int ov5693_write_reg(struct i2c_client *client, u16 data_length,
+							u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg = (u16 *)data;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (data_length != OV5693_8BIT && data_length != OV5693_16BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == OV5693_8BIT) {
+		data[2] = (u8)(val);
+	} else {
+		/* OV5693_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
+
+	ret = ov5693_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * ov5693_write_reg_array - Initializes a list of OV5693 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __ov5693_flush_reg_array, __ov5693_buf_reg_array() and
+ * __ov5693_write_reg_is_consecutive() are internal functions to
+ * ov5693_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+static int __ov5693_flush_reg_array(struct i2c_client *client,
+				    struct ov5693_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov5693_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __ov5693_buf_reg_array(struct i2c_client *client,
+				  struct ov5693_write_ctrl *ctrl,
+				  const struct ov5693_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case OV5693_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case OV5693_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= OV5693_MAX_WRITE_BUF_SIZE)
+		return __ov5693_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int __ov5693_write_reg_is_consecutive(struct i2c_client *client,
+					     struct ov5693_write_ctrl *ctrl,
+					     const struct ov5693_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int ov5693_write_reg_array(struct i2c_client *client,
+				  const struct ov5693_reg *reglist)
+{
+	const struct ov5693_reg *next = reglist;
+	struct ov5693_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != OV5693_TOK_TERM; next++) {
+		switch (next->type & OV5693_TOK_MASK) {
+		case OV5693_TOK_DELAY:
+			err = __ov5693_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			usleep_range(next->val * 1000, (next->val + 1) * 1000);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__ov5693_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __ov5693_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __ov5693_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __ov5693_flush_reg_array(client, &ctrl);
+}
+static int ov5693_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5693_FOCAL_LENGTH_NUM << 16) | OV5693_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov5693_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for ov5693*/
+	*val = (OV5693_F_NUMBER_DEFAULT_NUM << 16) | OV5693_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov5693_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (OV5693_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV5693_F_NUMBER_DEM << 16) |
+		(OV5693_F_NUMBER_DEFAULT_NUM << 8) | OV5693_F_NUMBER_DEM;
+	return 0;
+}
+
+
+static int ov5693_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct ov5693_resolution *res)
+{
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	unsigned int pix_clk_freq_hz;
+	u16 reg_val;
+	int ret;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* pixel clock calculattion */
+	pix_clk_freq_hz = res->pix_clk_freq * 1000000;
+
+	buf->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+
+	/* get integration time */
+	buf->coarse_integration_time_min = OV5693_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+					OV5693_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = OV5693_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					OV5693_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = OV5693_FINE_INTG_TIME_MIN;
+	buf->frame_length_lines = res->lines_per_frame;
+	buf->line_length_pck = res->pixels_per_line;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	ret =  ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_H_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = reg_val;
+
+	ret =  ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_V_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_H_CROP_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_end = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_V_CROP_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_end = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_H_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_width = reg_val;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_V_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_height = reg_val;
+
+	/*
+	 * we can't return 0 for bin_factor, this is because camera
+	 * HAL will use them as denominator, bin_factor = 0 will
+	 * cause camera HAL crash. So we return bin_factor as this
+	 * rules:
+	 * [1]. res->bin_factor = 0, return 1 for bin_factor.
+	 * [2]. res->bin_factor > 0, return res->bin_factor.
+	 */
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
+	return 0;
+}
+
+static long __ov5693_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 vts;
+	int ret;
+
+	/*
+	 * According to spec, the low 4 bits of exposure/gain reg are
+	 * fraction bits, so need to take 4 bits left shift to align
+	 * reg integer bits.
+	 */
+	coarse_itg <<= 4;
+	gain <<= 4;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_VTS_H, &vts);
+	if (ret)
+		return ret;
+
+	if (coarse_itg + OV5693_INTEGRATION_TIME_MARGIN >= vts)
+		vts = coarse_itg + OV5693_INTEGRATION_TIME_MARGIN;
+
+	ret = ov5693_write_reg(client, OV5693_16BIT, OV5693_VTS_H, vts);
+	if (ret)
+		return ret;
+
+	/* group hold start */
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_GROUP_ACCESS, 0);
+	if (ret)
+		return ret;
+
+	/* set exposure */
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+					OV5693_AEC_PK_EXPO_L,
+					coarse_itg & 0xff);
+	if (ret)
+		return ret;
+
+	ret = ov5693_write_reg(client, OV5693_16BIT,
+					OV5693_AEC_PK_EXPO_H,
+					(coarse_itg >> 8) & 0xfff);
+	if (ret)
+		return ret;
+
+	/* set analog gain */
+	ret = ov5693_write_reg(client, OV5693_16BIT,
+					OV5693_AGC_ADJ_H, gain);
+	if (ret)
+		return ret;
+
+	/* set digital gain */
+	ret = ov5693_write_reg(client, OV5693_16BIT,
+				OV5693_MWB_GAIN_R_H, digitgain);
+	if (ret)
+		return ret;
+
+	ret = ov5693_write_reg(client, OV5693_16BIT,
+				OV5693_MWB_GAIN_G_H, digitgain);
+	if (ret)
+		return ret;
+
+	ret = ov5693_write_reg(client, OV5693_16BIT,
+				OV5693_MWB_GAIN_B_H, digitgain);
+	if (ret)
+		return ret;
+
+	/* group hold end */
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+					OV5693_GROUP_ACCESS, 0x10);
+	if (ret)
+		return ret;
+
+	/* group hold launch */
+	ret = ov5693_write_reg(client, OV5693_8BIT,
+					OV5693_GROUP_ACCESS, 0xa0);
+
+	return ret;
+}
+
+static int ov5693_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov5693_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long ov5693_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int exp = exposure->integration_time[0];
+	int gain = exposure->gain[0];
+	int digitgain = exposure->gain[1];
+
+	/* we should not accept the invalid value below. */
+	if (gain == 0) {
+		dev_err(&client->dev, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	return ov5693_set_exposure(sd, exp, gain, digitgain);
+}
+
+static long ov5693_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return ov5693_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int ov5693_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 reg_v, reg_v2;
+	int ret;
+
+	/* get exposure */
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_AEC_PK_EXPO_L,
+					&reg_v);
+	if (ret)
+		goto err;
+
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_AEC_PK_EXPO_M,
+					&reg_v2);
+	if (ret)
+		goto err;
+
+	reg_v += reg_v2 << 8;
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_AEC_PK_EXPO_H,
+					&reg_v2);
+	if (ret)
+		goto err;
+
+	*value = (reg_v + (((u32)reg_v2 << 16))) >> 4;
+err:
+	return ret;
+}
+
+/*
+ * This below focus func don't need input_lock mutex_lock
+ * since they are just called in v4l2 s_ctrl/g_ctrl framework
+ * where mutex input_lock have been done.
+ */
+int ov5693_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret = 0;
+
+	if (dev->vcm_driver && dev->vcm_driver->t_focus_abs)
+		ret = dev->vcm_driver->t_focus_abs(sd, value);
+
+	return ret;
+}
+
+int ov5693_t_focus_rel(struct v4l2_subdev *sd, s32 value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret = 0;
+
+	if (dev->vcm_driver && dev->vcm_driver->t_focus_rel)
+		ret = dev->vcm_driver->t_focus_rel(sd, value);
+
+	return ret;
+}
+
+int ov5693_q_focus_status(struct v4l2_subdev *sd, s32 *value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret = 0;
+
+	if (dev->vcm_driver && dev->vcm_driver->q_focus_status)
+		ret = dev->vcm_driver->q_focus_status(sd, value);
+
+	return ret;
+}
+
+int ov5693_q_focus_abs(struct v4l2_subdev *sd, s32 *value)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret = 0;
+
+	if (dev->vcm_driver && dev->vcm_driver->q_focus_abs)
+		ret = dev->vcm_driver->q_focus_abs(sd, value);
+
+	return ret;
+}
+
+/* ov5693 control set/get */
+static int ov5693_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5693_device *dev = container_of(
+		ctrl->handler, struct ov5693_device, ctrl_handler);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		ret = ov5693_q_exposure(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		ret = ov5693_q_focus_abs(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FOCUS_STATUS:
+		ret = ov5693_q_focus_status(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FOCAL_ABSOLUTE:
+		ret = ov5693_g_focal(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FNUMBER_ABSOLUTE:
+		ret = ov5693_g_fnumber(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_FNUMBER_RANGE:
+		ret = ov5693_g_fnumber_range(&dev->sd, &ctrl->val);
+		break;
+	case V4L2_CID_BIN_FACTOR_HORZ:
+		ctrl->val = dev->ov5693_res[dev->fmt_idx].bin_factor_x;
+		break;
+	case V4L2_CID_BIN_FACTOR_VERT:
+		ctrl->val = dev->ov5693_res[dev->fmt_idx].bin_factor_y;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int ov5693_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov5693_device *dev = container_of(
+		ctrl->handler, struct ov5693_device, ctrl_handler);
+	int ret = 0;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		switch (ctrl->val) {
+		case ATOMISP_RUN_MODE_VIDEO:
+			dev->ov5693_res = ov5693_res_video;
+			dev->curr_res_num = N_RES_VIDEO;
+			break;
+		case ATOMISP_RUN_MODE_STILL_CAPTURE:
+			dev->ov5693_res = ov5693_res_still;
+			dev->curr_res_num = N_RES_STILL;
+			break;
+		default:
+			dev->ov5693_res = ov5693_res_preview;
+			dev->curr_res_num = N_RES_PREVIEW;
+		}
+		break;
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		ret = ov5693_t_focus_abs(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_FOCUS_RELATIVE:
+		ret = ov5693_t_focus_rel(&dev->sd, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int ov5693_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret = 0;
+
+	/* restore settings */
+	dev->ov5693_res = ov5693_res_preview;
+	dev->curr_res_num = N_RES_PREVIEW;
+
+	ret = ov5693_write_reg_array(client, ov5693_init_setting);
+	if (ret)
+		dev_err(&client->dev, "ov5693 write init setting reg err.\n");
+
+	return ret;
+}
+
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* according to DS, 20ms is needed between PWDN and i2c access */
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed.\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int ov5693_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+	if (on == 0) {
+		if (dev->vcm_driver && dev->vcm_driver->power_down)
+			ret = dev->vcm_driver->power_down(sd);
+		if (ret)
+			dev_err(&client->dev, "vcm power-down failed.\n");
+
+		ret = power_down(sd);
+	} else {
+		ret = power_up(sd);
+		if (ret)
+			goto done;
+
+		ret = ov5693_init(sd);
+		if (ret)
+			goto done;
+
+		if (dev->vcm_driver && dev->vcm_driver->power_up)
+			ret = dev->vcm_driver->power_up(sd);
+		if (ret)
+			dev_err(&client->dev, "vcm power-up failed.\n");
+	}
+
+done:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+static int distance(struct ov5693_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << RATIO_SHIFT_BITS)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << RATIO_SHIFT_BITS) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << RATIO_SHIFT_BITS) / h_ratio)
+			- ((int)(1 << RATIO_SHIFT_BITS)));
+
+	if ((w_ratio < (int)(1 << RATIO_SHIFT_BITS))
+	    || (h_ratio < (int)(1 << RATIO_SHIFT_BITS))  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(struct v4l2_subdev *sd,
+				    int w, int h)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int i;
+	int idx = dev->curr_res_num-1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct ov5693_resolution *tmp_res = NULL;
+
+	for (i = 0; i < dev->curr_res_num; i++) {
+		tmp_res = &dev->ov5693_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(struct v4l2_subdev *sd,
+				int w, int h)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int i;
+
+	for (i = 0; i < dev->curr_res_num; i++) {
+		if (w != dev->ov5693_res[i].width)
+			continue;
+		if (h != dev->ov5693_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int __ov5693_try_mbus_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+
+	idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+	fmt->width = dev->ov5693_res[idx].width;
+	fmt->height = dev->ov5693_res[idx].height;
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int ov5693_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov5693_try_mbus_fmt(sd, fmt);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov5693_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *ov5693_info = NULL;
+	int ret = 0;
+
+	ov5693_info = v4l2_get_subdev_hostdata(sd);
+	if (ov5693_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov5693_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto done;
+	}
+
+	dev->fmt_idx = get_resolution_index(sd, fmt->width, fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		goto done;
+	}
+
+	ret = ov5693_write_reg_array(client, dev->ov5693_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 write fmt register err.\n");
+		goto done;
+	}
+
+	ret = ov5693_get_intg_factor(client, ov5693_info,
+					&dev->ov5693_res[dev->fmt_idx]);
+	if (ret)
+		dev_err(&client->dev, "failed to get integration_factor\n");
+
+	ov5693_info->metadata_width = fmt->width * 10 / 8;
+	ov5693_info->metadata_height = 1;
+	ov5693_info->metadata_effective_width = &ov5693_embedded_effective_size;
+
+done:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int ov5693_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	fmt->width = dev->ov5693_res[dev->fmt_idx].width;
+	fmt->height = dev->ov5693_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov5693_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	int ret = 0;
+	u16 id;
+	u8 revision;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = ov5693_read_reg(client, OV5693_16BIT,
+					OV5693_SC_CMMN_CHIP_ID, &id);
+	if (ret) {
+		dev_err(&client->dev, "read sensor_id err.\n");
+		return -ENODEV;
+	}
+
+	if (id != OV5693_ID) {
+		dev_err(&client->dev, "sensor ID error\n");
+		return -ENODEV;
+	}
+
+	ret = ov5693_read_reg(client, OV5693_8BIT,
+					OV5693_SC_CMMN_SUB_ID, &id);
+	revision = (u8)id & 0x0f;
+
+	dev_dbg(&client->dev, "sensor_revision = 0x%x\n", revision);
+	dev_dbg(&client->dev, "detect ov5693 success\n");
+	return ret;
+}
+
+static int ov5693_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = ov5693_write_reg(client, OV5693_8BIT, OV5693_SW_STREAM,
+				enable ? OV5693_START_STREAMING :
+				OV5693_STOP_STREAMING);
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+/* ov5693 enum frame size, frame intervals */
+static int ov5693_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	unsigned int index = fsize->index;
+
+	mutex_lock(&dev->input_lock);
+
+	if (index >= dev->curr_res_num) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = dev->ov5693_res[index].width;
+	fsize->discrete.height = dev->ov5693_res[index].height;
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov5693_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	unsigned int index = fival->index;
+
+	mutex_lock(&dev->input_lock);
+
+	if (index >= dev->curr_res_num) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = dev->ov5693_res[index].width;
+	fival->height = dev->ov5693_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = dev->ov5693_res[index].fps;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov5693_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov5693_s_config(struct v4l2_subdev *sd,
+			   int irq, void *platform_data)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	mutex_lock(&dev->input_lock);
+
+	dev->platform_data = platform_data;
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 power-up err.\n");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = ov5693_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "ov5693_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "ov5693 power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int ov5693_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < dev->curr_res_num) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode->val;
+		param->parm.capture.timeperframe.denominator =
+					dev->ov5693_res[dev->fmt_idx].fps;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov5693_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	interval->interval.numerator = 1;
+	interval->interval.denominator = dev->ov5693_res[dev->fmt_idx].fps;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov5693_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int ov5693_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	int index = fse->index;
+
+	mutex_lock(&dev->input_lock);
+
+	if (index >= dev->curr_res_num) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fse->min_width = dev->ov5693_res[index].width;
+	fse->min_height = dev->ov5693_res[index].height;
+	fse->max_width = dev->ov5693_res[index].width;
+	fse->max_height = dev->ov5693_res[index].height;
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov5693_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	mutex_lock(&dev->input_lock);
+
+	switch (fmt->which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		format = v4l2_subdev_get_try_format(fh, fmt->pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		format = &dev->format;
+		break;
+	default:
+		format = NULL;
+	}
+
+	mutex_unlock(&dev->input_lock);
+
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int ov5693_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov5693_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = dev->ov5693_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = ov5693_s_ctrl,
+	.g_volatile_ctrl = ov5693_g_ctrl,
+};
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrl_run_mode = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_RUN_MODE,
+	.name = "run mode",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 1,
+	.def = 4,
+	.max = 4,
+	.qmenu = ctrl_run_mode_menu,
+};
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+		.name = "absolute exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0x0,
+		.max = 0xffff,
+		.step = 0x01,
+		.def = 0x00,
+		.flags = 0,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focus move absolute",
+		.min = 0,
+		.max = OV5693_MAX_FOCUS_POS,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_RELATIVE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focus move relative",
+		.min = OV5693_MAX_FOCUS_NEG,
+		.max = OV5693_MAX_FOCUS_POS,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_STATUS,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focus status",
+		.min = 0,
+		.max = 100,
+		.step = 1,
+		.def = 0,
+		.flags = 0,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCAL_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "focal length",
+		.min = OV5693_FOCAL_LENGTH_DEFAULT,
+		.max = OV5693_FOCAL_LENGTH_DEFAULT,
+		.step = 0x01,
+		.def = OV5693_FOCAL_LENGTH_DEFAULT,
+		.flags = 0,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_ABSOLUTE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "f-number",
+		.min = OV5693_F_NUMBER_DEFAULT,
+		.max = OV5693_F_NUMBER_DEFAULT,
+		.step = 0x01,
+		.def = OV5693_F_NUMBER_DEFAULT,
+		.flags = 0,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_RANGE,
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.name = "f-number range",
+		.min = OV5693_F_NUMBER_RANGE,
+		.max =  OV5693_F_NUMBER_RANGE,
+		.step = 0x01,
+		.def = OV5693_F_NUMBER_RANGE,
+		.flags = 0,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_HORZ,
+		.name = "horizontal binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = OV5693_BIN_FACTOR_MAX,
+		.step = 2,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_VERT,
+		.name = "vertical binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = OV5693_BIN_FACTOR_MAX,
+		.step = 2,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}
+};
+
+static const struct v4l2_subdev_sensor_ops ov5693_sensor_ops = {
+	.g_skip_frames	= ov5693_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops ov5693_video_ops = {
+	.s_stream = ov5693_s_stream,
+	.g_parm = ov5693_g_parm,
+	.enum_framesizes = ov5693_enum_framesizes,
+	.enum_frameintervals = ov5693_enum_frameintervals,
+	.enum_mbus_fmt = ov5693_enum_mbus_fmt,
+	.try_mbus_fmt = ov5693_try_mbus_fmt,
+	.g_mbus_fmt = ov5693_g_mbus_fmt,
+	.s_mbus_fmt = ov5693_s_mbus_fmt,
+	.g_frame_interval = ov5693_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops ov5693_core_ops = {
+	.s_power = ov5693_s_power,
+	.queryctrl = v4l2_subdev_queryctrl,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
+	.ioctl = ov5693_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops ov5693_pad_ops = {
+	.enum_mbus_code = ov5693_enum_mbus_code,
+	.enum_frame_size = ov5693_enum_frame_size,
+	.get_fmt = ov5693_get_pad_format,
+	.set_fmt = ov5693_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ov5693_ops = {
+	.core = &ov5693_core_ops,
+	.video = &ov5693_video_ops,
+	.pad = &ov5693_pad_ops,
+	.sensor = &ov5693_sensor_ops,
+};
+
+static int ov5693_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5693_device *dev = to_ov5693_sensor(sd);
+	dev_dbg(&client->dev, "ov5693_remove...\n");
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	devm_kfree(&client->dev, dev);
+
+	return 0;
+}
+
+static int ov5693_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct ov5693_device *dev;
+	int i;
+	int ret;
+
+	dev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	/*
+	 * Initialize related res members of dev.
+	 */
+	dev->fmt_idx = 0;
+	dev->ov5693_res = ov5693_res_preview;
+	dev->curr_res_num = N_RES_PREVIEW;
+
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov5693_ops);
+
+	if (client->dev.platform_data) {
+		ret = ov5693_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	dev->vcm_driver = &ov5693_vcm_ops;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls) + 1);
+	if (ret) {
+		ov5693_remove(client);
+		return ret;
+	}
+
+	dev->run_mode = v4l2_ctrl_new_custom(&dev->ctrl_handler,
+					     &ctrl_run_mode, NULL);
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		ov5693_remove(client);
+		return dev->ctrl_handler.error;
+	}
+
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		ov5693_remove(client);
+
+	/* vcm initialization */
+	if (dev->vcm_driver && dev->vcm_driver->init)
+		ret = dev->vcm_driver->init(&dev->sd);
+	if (ret) {
+		dev_err(&client->dev, "vcm init failed.\n");
+		ov5693_remove(client);
+	}
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	devm_kfree(&client->dev, dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov5693_id);
+static struct i2c_driver ov5693_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV5693_NAME,
+	},
+	.probe = ov5693_probe,
+	.remove = ov5693_remove,
+	.id_table = ov5693_id,
+};
+
+module_i2c_driver(ov5693_driver);
+
+MODULE_DESCRIPTION("A low-level driver for OmniVision 5693 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
new file mode 100644
index 0000000..3a91b60
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov5693/ov5693.h
@@ -0,0 +1,849 @@
+/*
+ * Support for OmniVision OV5693 5M HD camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV5693_H__
+#define __OV5693_H__
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <media/media-entity.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+
+#include <linux/atomisp_platform.h>
+#include "ad5823.h"
+
+#define OV5693_NAME		"ov5693"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		0x2
+
+#define OV5693_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define OV5693_FOCAL_LENGTH_DEM	100
+#define OV5693_F_NUMBER_DEFAULT_NUM	26
+#define OV5693_F_NUMBER_DEM	10
+
+#define OV5693_MAX_FOCUS_POS	1023
+#define OV5693_MAX_FOCUS_POS	1023
+#define OV5693_MAX_FOCUS_NEG	(-1023)
+
+#define LARGEST_ALLOWED_RATIO_MISMATCH	800
+#define RATIO_SHIFT_BITS		13
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5693_FOCAL_LENGTH_DEFAULT 0x1160064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV5693_F_NUMBER_DEFAULT 0x1a000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV5693_F_NUMBER_RANGE 0x1a0a1a0a
+#define OV5693_ID	0x5690
+
+#define OV5693_FINE_INTG_TIME_MIN 0
+#define OV5693_FINE_INTG_TIME_MAX_MARGIN 0
+#define OV5693_COARSE_INTG_TIME_MIN 1
+#define OV5693_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
+#define OV5693_INTEGRATION_TIME_MARGIN	8
+
+#define OV5693_BIN_FACTOR_MAX	2
+
+/*
+ * OV5693 System control registers
+ */
+#define OV5693_SW_RESET				0x0103
+#define OV5693_SW_STREAM			0x0100
+
+#define OV5693_SC_CMMN_CHIP_ID			0x300a
+#define OV5693_SC_CMMN_SUB_ID			0x302a /* process, version*/
+
+#define OV5693_AEC_PK_EXPO_H			0x3500
+#define OV5693_AEC_PK_EXPO_M			0x3501
+#define OV5693_AEC_PK_EXPO_L			0x3502
+#define OV5693_AGC_ADJ_H			0x350a
+#define OV5693_VTS_H				0x380e
+#define OV5693_GROUP_ACCESS			0x3208
+
+#define OV5693_MWB_GAIN_R_H			0x3400
+#define OV5693_MWB_GAIN_G_H			0x3402
+#define OV5693_MWB_GAIN_B_H			0x3404
+
+#define OV5693_H_CROP_START_H			0x3800
+#define OV5693_V_CROP_START_H			0x3802
+#define OV5693_H_CROP_END_H			0x3804
+#define OV5693_V_CROP_END_H			0x3806
+#define OV5693_H_OUTSIZE_H			0x3808
+#define OV5693_V_OUTSIZE_H			0x380a
+
+#define OV5693_START_STREAMING			0x01
+#define OV5693_STOP_STREAMING			0x00
+
+struct ov5693_vcm {
+	int (*power_up)(struct v4l2_subdev *sd);
+	int (*power_down)(struct v4l2_subdev *sd);
+	int (*init)(struct v4l2_subdev *sd);
+	int (*t_focus_vcm)(struct v4l2_subdev *sd, u16 val);
+	int (*t_focus_abs)(struct v4l2_subdev *sd, s32 value);
+	int (*t_focus_rel)(struct v4l2_subdev *sd, s32 value);
+	int (*q_focus_status)(struct v4l2_subdev *sd, s32 *value);
+	int (*q_focus_abs)(struct v4l2_subdev *sd, s32 *value);
+};
+
+struct ov5693_resolution {
+	u8 *desc;
+	const struct ov5693_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u16 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+};
+
+struct ov5693_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * ov5693 device structure.
+ */
+struct ov5693_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	struct ov5693_vcm *vcm_driver;
+	int fmt_idx;
+	u8 res;
+	u8 type;
+
+	struct ov5693_resolution *ov5693_res;
+	int curr_res_num;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *run_mode;
+};
+
+enum ov5693_tok_type {
+	OV5693_8BIT  = 0x0001,
+	OV5693_16BIT = 0x0002,
+	OV5693_32BIT = 0x0004,
+	OV5693_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	OV5693_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	OV5693_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct ov5693_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov5693_reg {
+	enum ov5693_tok_type type;
+	u16 reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_ov5693_sensor(x) container_of(x, struct ov5693_device, sd)
+
+#define OV5693_MAX_WRITE_BUF_SIZE	30
+
+struct ov5693_write_buffer {
+	u16 addr;
+	u8 data[OV5693_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov5693_write_ctrl {
+	int index;
+	struct ov5693_write_buffer buffer;
+};
+
+static const struct i2c_device_id ov5693_id[] = {
+	{OV5693_NAME, 0},
+	{}
+};
+
+/* ov5693 sensor initialization setting */
+static struct ov5693_reg const ov5693_init_setting[] = {
+	{OV5693_8BIT, 0x0103, 0x01},
+	{OV5693_8BIT, 0x3001, 0x0a},
+	{OV5693_8BIT, 0x3002, 0x80},
+	{OV5693_8BIT, 0x3006, 0x00},
+	{OV5693_8BIT, 0x3011, 0x21},
+	{OV5693_8BIT, 0x3012, 0x09},
+	{OV5693_8BIT, 0x3013, 0x10},
+	{OV5693_8BIT, 0x3014, 0x00},
+	{OV5693_8BIT, 0x3015, 0x08},
+	{OV5693_8BIT, 0x3016, 0xf0},
+	{OV5693_8BIT, 0x3017, 0xf0},
+	{OV5693_8BIT, 0x3018, 0xf0},
+	{OV5693_8BIT, 0x3019, 0x10},
+	{OV5693_8BIT, 0x301b, 0xb4},
+	{OV5693_8BIT, 0x301d, 0x02},
+	{OV5693_8BIT, 0x3021, 0x00},
+	{OV5693_8BIT, 0x3022, 0x01},
+	{OV5693_8BIT, 0x3028, 0x44},
+	{OV5693_8BIT, 0x3098, 0x02},
+	{OV5693_8BIT, 0x3099, 0x19},
+	{OV5693_8BIT, 0x309a, 0x02},
+	{OV5693_8BIT, 0x309b, 0x01},
+	{OV5693_8BIT, 0x309c, 0x00},
+	{OV5693_8BIT, 0x30a0, 0xd2},
+	{OV5693_8BIT, 0x30a2, 0x01},
+	{OV5693_8BIT, 0x30b2, 0x00},
+	{OV5693_8BIT, 0x30b3, 0x7d},
+	{OV5693_8BIT, 0x30b4, 0x03},
+	{OV5693_8BIT, 0x30b5, 0x04},
+	{OV5693_8BIT, 0x30b6, 0x01},
+	{OV5693_8BIT, 0x3104, 0x21},
+	{OV5693_8BIT, 0x3106, 0x00},
+
+	/* Manual white balance */
+	{OV5693_8BIT, 0x3400, 0x04},
+	{OV5693_8BIT, 0x3401, 0x00},
+	{OV5693_8BIT, 0x3402, 0x04},
+	{OV5693_8BIT, 0x3403, 0x00},
+	{OV5693_8BIT, 0x3404, 0x04},
+	{OV5693_8BIT, 0x3405, 0x00},
+	{OV5693_8BIT, 0x3406, 0x01},
+
+	/* Manual exposure control */
+	{OV5693_8BIT, 0x3500, 0x00},
+	{OV5693_8BIT, 0x3503, 0x07},
+	{OV5693_8BIT, 0x3504, 0x00},
+	{OV5693_8BIT, 0x3505, 0x00},
+	{OV5693_8BIT, 0x3506, 0x00},
+	{OV5693_8BIT, 0x3507, 0x02},
+	{OV5693_8BIT, 0x3508, 0x00},
+
+	/* Manual gain control */
+	{OV5693_8BIT, 0x3509, 0x10},
+	{OV5693_8BIT, 0x350a, 0x00},
+	{OV5693_8BIT, 0x350b, 0x40},
+
+	{OV5693_8BIT, 0x3601, 0x0a},
+	{OV5693_8BIT, 0x3602, 0x38},
+	{OV5693_8BIT, 0x3612, 0x80},
+	{OV5693_8BIT, 0x3620, 0x54},
+	{OV5693_8BIT, 0x3621, 0xc7},
+	{OV5693_8BIT, 0x3622, 0x0f},
+	{OV5693_8BIT, 0x3625, 0x10},
+	{OV5693_8BIT, 0x3630, 0x55},
+	{OV5693_8BIT, 0x3631, 0xf4},
+	{OV5693_8BIT, 0x3632, 0x00},
+	{OV5693_8BIT, 0x3633, 0x34},
+	{OV5693_8BIT, 0x3634, 0x02},
+	{OV5693_8BIT, 0x364d, 0x0d},
+	{OV5693_8BIT, 0x364f, 0xdd},
+	{OV5693_8BIT, 0x3660, 0x04},
+	{OV5693_8BIT, 0x3662, 0x10},
+	{OV5693_8BIT, 0x3663, 0xf1},
+	{OV5693_8BIT, 0x3665, 0x00},
+	{OV5693_8BIT, 0x3666, 0x20},
+	{OV5693_8BIT, 0x3667, 0x00},
+	{OV5693_8BIT, 0x366a, 0x80},
+	{OV5693_8BIT, 0x3680, 0xe0},
+	{OV5693_8BIT, 0x3681, 0x00},
+	{OV5693_8BIT, 0x3700, 0x42},
+	{OV5693_8BIT, 0x3701, 0x14},
+	{OV5693_8BIT, 0x3702, 0xa0},
+	{OV5693_8BIT, 0x3703, 0xd8},
+	{OV5693_8BIT, 0x3704, 0x78},
+	{OV5693_8BIT, 0x3705, 0x02},
+	{OV5693_8BIT, 0x370a, 0x00},
+	{OV5693_8BIT, 0x370b, 0x20},
+	{OV5693_8BIT, 0x370c, 0x0c},
+	{OV5693_8BIT, 0x370d, 0x11},
+	{OV5693_8BIT, 0x370e, 0x00},
+	{OV5693_8BIT, 0x370f, 0x40},
+	{OV5693_8BIT, 0x3710, 0x00},
+	{OV5693_8BIT, 0x371a, 0x1c},
+	{OV5693_8BIT, 0x371b, 0x05},
+	{OV5693_8BIT, 0x371c, 0x01},
+	{OV5693_8BIT, 0x371e, 0xa1},
+	{OV5693_8BIT, 0x371f, 0x0c},
+	{OV5693_8BIT, 0x3721, 0x00},
+	{OV5693_8BIT, 0x3724, 0x10},
+	{OV5693_8BIT, 0x3726, 0x00},
+	{OV5693_8BIT, 0x372a, 0x01},
+	{OV5693_8BIT, 0x3730, 0x10},
+	{OV5693_8BIT, 0x3738, 0x22},
+	{OV5693_8BIT, 0x3739, 0xe5},
+	{OV5693_8BIT, 0x373a, 0x50},
+	{OV5693_8BIT, 0x373b, 0x02},
+	{OV5693_8BIT, 0x373c, 0x41},
+	{OV5693_8BIT, 0x373f, 0x02},
+	{OV5693_8BIT, 0x3740, 0x42},
+	{OV5693_8BIT, 0x3741, 0x02},
+	{OV5693_8BIT, 0x3742, 0x18},
+	{OV5693_8BIT, 0x3743, 0x01},
+	{OV5693_8BIT, 0x3744, 0x02},
+	{OV5693_8BIT, 0x3747, 0x10},
+	{OV5693_8BIT, 0x374c, 0x04},
+	{OV5693_8BIT, 0x3751, 0xf0},
+	{OV5693_8BIT, 0x3752, 0x00},
+	{OV5693_8BIT, 0x3753, 0x00},
+	{OV5693_8BIT, 0x3754, 0xc0},
+	{OV5693_8BIT, 0x3755, 0x00},
+	{OV5693_8BIT, 0x3756, 0x1a},
+	{OV5693_8BIT, 0x3758, 0x00},
+	{OV5693_8BIT, 0x3759, 0x0f},
+	{OV5693_8BIT, 0x376b, 0x44},
+	{OV5693_8BIT, 0x375c, 0x04},
+	{OV5693_8BIT, 0x3774, 0x10},
+	{OV5693_8BIT, 0x3776, 0x00},
+	{OV5693_8BIT, 0x377f, 0x08},
+	{OV5693_8BIT, 0x3780, 0x22},
+	{OV5693_8BIT, 0x3781, 0x0c},
+	{OV5693_8BIT, 0x3784, 0x2c},
+	{OV5693_8BIT, 0x3785, 0x1e},
+	{OV5693_8BIT, 0x378f, 0xf5},
+	{OV5693_8BIT, 0x3791, 0xb0},
+	{OV5693_8BIT, 0x3795, 0x00},
+	{OV5693_8BIT, 0x3796, 0x64},
+	{OV5693_8BIT, 0x3797, 0x11},
+	{OV5693_8BIT, 0x3798, 0x30},
+	{OV5693_8BIT, 0x3799, 0x41},
+	{OV5693_8BIT, 0x379a, 0x07},
+	{OV5693_8BIT, 0x379b, 0xb0},
+	{OV5693_8BIT, 0x379c, 0x0c},
+	{OV5693_8BIT, 0x37c5, 0x00},
+	{OV5693_8BIT, 0x37c6, 0x00},
+	{OV5693_8BIT, 0x37c7, 0x00},
+	{OV5693_8BIT, 0x37c9, 0x00},
+	{OV5693_8BIT, 0x37ca, 0x00},
+	{OV5693_8BIT, 0x37cb, 0x00},
+	{OV5693_8BIT, 0x37de, 0x00},
+	{OV5693_8BIT, 0x37df, 0x00},
+	{OV5693_8BIT, 0x3800, 0x00},
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},
+	{OV5693_8BIT, 0x3804, 0x0a},
+	{OV5693_8BIT, 0x3805, 0x3f},
+	{OV5693_8BIT, 0x3810, 0x00},
+	{OV5693_8BIT, 0x3812, 0x00},
+	{OV5693_8BIT, 0x3823, 0x00},
+	{OV5693_8BIT, 0x3824, 0x00},
+	{OV5693_8BIT, 0x3825, 0x00},
+	{OV5693_8BIT, 0x3826, 0x00},
+	{OV5693_8BIT, 0x3827, 0x00},
+	{OV5693_8BIT, 0x382a, 0x04},
+	{OV5693_8BIT, 0x3a04, 0x06},
+	{OV5693_8BIT, 0x3a05, 0x14},
+	{OV5693_8BIT, 0x3a06, 0x00},
+	{OV5693_8BIT, 0x3a07, 0xfe},
+	{OV5693_8BIT, 0x3b00, 0x00},
+	{OV5693_8BIT, 0x3b02, 0x00},
+	{OV5693_8BIT, 0x3b03, 0x00},
+	{OV5693_8BIT, 0x3b04, 0x00},
+	{OV5693_8BIT, 0x3b05, 0x00},
+	{OV5693_8BIT, 0x3e07, 0x20},
+	{OV5693_8BIT, 0x4000, 0x08},
+	{OV5693_8BIT, 0x4001, 0x04},
+	{OV5693_8BIT, 0x4002, 0x45},
+	{OV5693_8BIT, 0x4004, 0x08},
+	{OV5693_8BIT, 0x4005, 0x18},
+	{OV5693_8BIT, 0x4006, 0x20},
+	{OV5693_8BIT, 0x4008, 0x24},
+	{OV5693_8BIT, 0x4009, 0x10},
+	{OV5693_8BIT, 0x400c, 0x00},
+	{OV5693_8BIT, 0x400d, 0x00},
+	{OV5693_8BIT, 0x4058, 0x00},
+	{OV5693_8BIT, 0x404e, 0x37},
+	{OV5693_8BIT, 0x404f, 0x8f},
+	{OV5693_8BIT, 0x4058, 0x00},
+	{OV5693_8BIT, 0x4101, 0xb2},
+	{OV5693_8BIT, 0x4303, 0x00},
+	{OV5693_8BIT, 0x4304, 0x08},
+	{OV5693_8BIT, 0x4307, 0x31},
+	{OV5693_8BIT, 0x4311, 0x04},
+	{OV5693_8BIT, 0x4315, 0x01},
+	{OV5693_8BIT, 0x4511, 0x05},
+	{OV5693_8BIT, 0x4512, 0x01},
+	{OV5693_8BIT, 0x4806, 0x00},
+	{OV5693_8BIT, 0x4816, 0x52},
+	{OV5693_8BIT, 0x481f, 0x30},
+	{OV5693_8BIT, 0x4826, 0x2c},
+	{OV5693_8BIT, 0x4831, 0x64},
+	{OV5693_8BIT, 0x4d00, 0x04},
+	{OV5693_8BIT, 0x4d01, 0x71},
+	{OV5693_8BIT, 0x4d02, 0xfd},
+	{OV5693_8BIT, 0x4d03, 0xf5},
+	{OV5693_8BIT, 0x4d04, 0x0c},
+	{OV5693_8BIT, 0x4d05, 0xcc},
+	{OV5693_8BIT, 0x4837, 0x0a},
+	{OV5693_8BIT, 0x5000, 0x06},
+	{OV5693_8BIT, 0x5001, 0x01},
+	{OV5693_8BIT, 0x5003, 0x20},
+	{OV5693_8BIT, 0x5046, 0x0a},
+	{OV5693_8BIT, 0x5013, 0x00},
+	{OV5693_8BIT, 0x5046, 0x0a},
+	{OV5693_8BIT, 0x5780, 0x1c},
+	{OV5693_8BIT, 0x5786, 0x20},
+	{OV5693_8BIT, 0x5787, 0x10},
+	{OV5693_8BIT, 0x5788, 0x18},
+	{OV5693_8BIT, 0x578a, 0x04},
+	{OV5693_8BIT, 0x578b, 0x02},
+	{OV5693_8BIT, 0x578c, 0x02},
+	{OV5693_8BIT, 0x578e, 0x06},
+	{OV5693_8BIT, 0x578f, 0x02},
+	{OV5693_8BIT, 0x5790, 0x02},
+	{OV5693_8BIT, 0x5791, 0xff},
+	{OV5693_8BIT, 0x5842, 0x01},
+	{OV5693_8BIT, 0x5843, 0x2b},
+	{OV5693_8BIT, 0x5844, 0x01},
+	{OV5693_8BIT, 0x5845, 0x92},
+	{OV5693_8BIT, 0x5846, 0x01},
+	{OV5693_8BIT, 0x5847, 0x8f},
+	{OV5693_8BIT, 0x5848, 0x01},
+	{OV5693_8BIT, 0x5849, 0x0c},
+	{OV5693_8BIT, 0x5e00, 0x00},
+	{OV5693_8BIT, 0x5e10, 0x0c},
+	{OV5693_8BIT, 0x0100, 0x00},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+ * Register settings for various resolution
+ */
+
+/*
+------------------------------------
+@@ FULL QSXGA (2592x1944) 15fps 33.33ms VBlank 2lane 10Bit
+100 99 2592 1944
+100 98 1 0
+102 3601 bb8 ;Pather tool use only
+c8  1 f2 ; New FPGA Board
+c8 20 22 ; New FPGA Board
+c8 10 42 ; MIPI DFGA CYCY3 Board use only
+;
+c8 f 32  ; input clock to 19.2MHz
+;
+; OV5690 setting version History
+;
+;
+; V18b
+*/
+static struct ov5693_reg const ov5693_5M_15fps[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3800, 0x00},	/* x_addr_start: 0 */
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},	/* y_addr_start: 0 */
+	{OV5693_8BIT, 0x3803, 0x00},
+	{OV5693_8BIT, 0x3804, 0x0a},	/* x_addr_end: 2623 */
+	{OV5693_8BIT, 0x3805, 0x3f},
+	{OV5693_8BIT, 0x3806, 0x07},	/* y_addr_end: 1955 */
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x0a},	/* x output size: 2592 */
+	{OV5693_8BIT, 0x3809, 0x20},
+	{OV5693_8BIT, 0x380a, 0x07},	/* y output size: 1944 */
+	{OV5693_8BIT, 0x380b, 0x98},
+	{OV5693_8BIT, 0x380c, 0x0e},	/* total x output size: 3688 */
+	{OV5693_8BIT, 0x380d, 0x68},
+	{OV5693_8BIT, 0x380e, 0x0f},	/* total y output size: 3968 */
+	{OV5693_8BIT, 0x380f, 0x80},
+	{OV5693_8BIT, 0x3810, 0x00},	/* x offset: 16 */
+	{OV5693_8BIT, 0x3811, 0x10},
+	{OV5693_8BIT, 0x3812, 0x00},	/* y offset: 6 */
+	{OV5693_8BIT, 0x3813, 0x06},
+	{OV5693_8BIT, 0x3814, 0x11},
+	{OV5693_8BIT, 0x3815, 0x11},
+	{OV5693_8BIT, 0x3820, 0x00},
+	{OV5693_8BIT, 0x3821, 0x1e},
+	{OV5693_8BIT, 0x5002, 0x00},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+@@ OV5693 1940x1096 30fps 8.8ms VBlanking 2lane 10Bit(Scaling)
+100 99 1940 1096
+100 98 1 0
+102 3601 bb8 ;Pather tool use only
+102 40 0 ; HDR Mode off
+c8  1 f2 ; New FPGA Board
+c8 20 22 ; New FPGA Board
+c8 10 42 ; MIPI DFGA CYCY3 Board use only
+;
+c8 f 32  ; input clock to 19.2MHz
+;
+; OV5690 setting version History
+;
+;
+; V18b
+*/
+static struct ov5693_reg const ov5693_1080p_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x7b},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe2},
+	{OV5693_8BIT, 0x3709, 0xc3},
+	{OV5693_8BIT, 0x3800, 0x00},	/* x_addr_start: 0 */
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},	/* y_addr_start: 240 */
+	{OV5693_8BIT, 0x3803, 0xf0},
+	{OV5693_8BIT, 0x3804, 0x0a},	/* x_addr_end: 2591 */
+	{OV5693_8BIT, 0x3805, 0x1f},
+	{OV5693_8BIT, 0x3806, 0x06},	/* y_addr_end: 1703 */
+	{OV5693_8BIT, 0x3807, 0xa7},
+	{OV5693_8BIT, 0x3808, 0x07},	/* x output size: 1940 */
+	{OV5693_8BIT, 0x3809, 0x94},
+	{OV5693_8BIT, 0x380a, 0x04},	/* y output size: 1096 */
+	{OV5693_8BIT, 0x380b, 0x48},
+	{OV5693_8BIT, 0x380c, 0x0e},	/* total x output size: 3688 */
+	{OV5693_8BIT, 0x380d, 0x68},
+	{OV5693_8BIT, 0x380e, 0x0b},	/* total y output size: 2984 */
+	{OV5693_8BIT, 0x380f, 0xa8},
+	{OV5693_8BIT, 0x3810, 0x00},	/* x offset: 2 */
+	{OV5693_8BIT, 0x3811, 0x02},
+	{OV5693_8BIT, 0x3812, 0x00},	/* y offset: 2 */
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x11},
+	{OV5693_8BIT, 0x3815, 0x11},
+	{OV5693_8BIT, 0x3820, 0x00},
+	{OV5693_8BIT, 0x3821, 0x1e},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+ * 1296x736 30fps 8.8ms VBlanking 2lane 10Bit (Scaling)
+ */
+static struct ov5693_reg const ov5693_720p_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x3d},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe6},
+	{OV5693_8BIT, 0x3709, 0xc7},
+	{OV5693_8BIT, 0x3800, 0x00},	/* x_addr_start: 0 */
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},	/* y_addr_start: 0 */
+	{OV5693_8BIT, 0x3803, 0x00},
+	{OV5693_8BIT, 0x3804, 0x0a},	/* x_addr_end: 2623 */
+	{OV5693_8BIT, 0x3805, 0x3f},
+	{OV5693_8BIT, 0x3806, 0x07},	/* y_addr_end: 1955 */
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x05},	/* x output size: 1296 */
+	{OV5693_8BIT, 0x3809, 0x10},
+	{OV5693_8BIT, 0x380a, 0x02},	/* y output size: 736 */
+	{OV5693_8BIT, 0x380b, 0xe0},
+	{OV5693_8BIT, 0x380c, 0x0a},	/* total x output size: 2688 */
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},	/* total y output size: 1984 */
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3810, 0x00},	/* x offset: 8 */
+	{OV5693_8BIT, 0x3811, 0x08},
+	{OV5693_8BIT, 0x3812, 0x00},	/* y offset: 2 */
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x31},
+	{OV5693_8BIT, 0x3815, 0x31},
+	{OV5693_8BIT, 0x3820, 0x04},
+	{OV5693_8BIT, 0x3821, 0x1f},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+ * 736x496 30fps 8.8ms VBlanking 2lane 10Bit (Scaling)
+ */
+static struct ov5693_reg const ov5693_480p_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x3d},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe6},
+	{OV5693_8BIT, 0x3709, 0xc7},
+	{OV5693_8BIT, 0x3800, 0x00},	/* x_addr_start: 0 */
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},	/* y_addr_start: 7 */
+	{OV5693_8BIT, 0x3803, 0x07},
+	{OV5693_8BIT, 0x3804, 0x0a},	/* x_addr_end: 2623 */
+	{OV5693_8BIT, 0x3805, 0x3f},
+	{OV5693_8BIT, 0x3806, 0x07},	/* y_addr_end: 1955 */
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x02},	/* x output size: 736 */
+	{OV5693_8BIT, 0x3809, 0xe0},
+	{OV5693_8BIT, 0x380a, 0x01},	/* y output size: 496 */
+	{OV5693_8BIT, 0x380b, 0xf0},
+	{OV5693_8BIT, 0x380c, 0x0a},	/* total x output size: 2688 */
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},	/* total y output size: 1984 */
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3810, 0x00},	/* x offset: 8 */
+	{OV5693_8BIT, 0x3811, 0x08},
+	{OV5693_8BIT, 0x3812, 0x00},	/* y offset: 2 */
+	{OV5693_8BIT, 0x3813, 0x02},
+	{OV5693_8BIT, 0x3814, 0x31},
+	{OV5693_8BIT, 0x3815, 0x31},
+	{OV5693_8BIT, 0x3820, 0x04},
+	{OV5693_8BIT, 0x3821, 0x1f},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+/*
+@@ OV5693 656x496 30fps 17ms VBlanking 2lane 10Bit(Scaling)
+100 99 656 496
+100 98 1 0
+102 3601 BB8 ;Pather tool use only
+c8  1 f2 ; New FPGA Board
+c8 20 22 ; New FPGA Board
+; OV5690 setting version History
+;
+c8 f 32  ; input clock to 19.2MHz
+;
+; V18b
+*/
+static struct ov5693_reg const ov5693_VGA_30fps[] = {
+	{OV5693_8BIT, 0x3501, 0x3d},
+	{OV5693_8BIT, 0x3502, 0x00},
+	{OV5693_8BIT, 0x3708, 0xe6},
+	{OV5693_8BIT, 0x3709, 0xc7},
+	{OV5693_8BIT, 0x3800, 0x00},	/* x_addr_start: 0 */
+	{OV5693_8BIT, 0x3801, 0x00},
+	{OV5693_8BIT, 0x3802, 0x00},	/* y_addr_start: 0 */
+	{OV5693_8BIT, 0x3803, 0x00},
+	{OV5693_8BIT, 0x3804, 0x0a},	/* x_addr_end: 2623 */
+	{OV5693_8BIT, 0x3805, 0x3f},
+	{OV5693_8BIT, 0x3806, 0x07},	/* y_addr_end: 1955 */
+	{OV5693_8BIT, 0x3807, 0xa3},
+	{OV5693_8BIT, 0x3808, 0x02},	/* x output size: 656 */
+	{OV5693_8BIT, 0x3809, 0x90},
+	{OV5693_8BIT, 0x380a, 0x01},	/* y output size: 496 */
+	{OV5693_8BIT, 0x380b, 0xf0},
+	{OV5693_8BIT, 0x380c, 0x0a},	/* total x output size: 2688 */
+	{OV5693_8BIT, 0x380d, 0x80},
+	{OV5693_8BIT, 0x380e, 0x07},	/* total y output size: 1984 */
+	{OV5693_8BIT, 0x380f, 0xc0},
+	{OV5693_8BIT, 0x3810, 0x00},	/* x offset: 13 */
+	{OV5693_8BIT, 0x3811, 0x0d},
+	{OV5693_8BIT, 0x3812, 0x00},	/* y offset: 3 */
+	{OV5693_8BIT, 0x3813, 0x03},
+	{OV5693_8BIT, 0x3814, 0x31},
+	{OV5693_8BIT, 0x3815, 0x31},
+	{OV5693_8BIT, 0x3820, 0x04},
+	{OV5693_8BIT, 0x3821, 0x1f},
+	{OV5693_8BIT, 0x5002, 0x80},
+	{OV5693_TOK_TERM, 0, 0}
+};
+
+struct ov5693_resolution ov5693_res_preview[] = {
+	{
+		.desc = "ov5693_VGA_30fps",
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_VGA_30fps,
+	},
+	{
+		.desc = "ov5693_1080P_30fps",
+		.width = 1940,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 3688,
+		.lines_per_frame = 2984,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_1080p_30fps,
+	},
+	{
+		.desc = "ov5693_5M_15fps",
+		.width = 2592,
+		.height = 1944,
+		.fps = 15,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 3688,
+		.lines_per_frame = 3968,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_5M_15fps,
+	},
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(ov5693_res_preview))
+
+struct ov5693_resolution ov5693_res_still[] = {
+	{
+		.desc = "ov5693_VGA_30fps",
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_VGA_30fps,
+	},
+	{
+		.desc = "ov5693_1080P_30fps",
+		.width = 1940,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 3688,
+		.lines_per_frame = 2984,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_1080p_30fps,
+	},
+	{
+		.desc = "ov5693_5M_15fps",
+		.width = 2592,
+		.height = 1944,
+		.fps = 15,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 3688,
+		.lines_per_frame = 3968,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_5M_15fps,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(ov5693_res_still))
+
+struct ov5693_resolution ov5693_res_video[] = {
+	{
+		.desc = "ov5693_VGA_30fps",
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_VGA_30fps,
+	},
+	{
+		.desc = "ov5693_480P_30fps",
+		.width = 736,
+		.height = 496,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.bin_mode = 0,
+		.skip_frames = 1,
+		.regs = ov5693_480p_30fps,
+	},
+	{
+		.desc = "ov5693_720p_30fps",
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 2688,
+		.lines_per_frame = 1984,
+		.bin_factor_x = 2,
+		.bin_factor_y = 2,
+		.bin_mode = 0,
+		.skip_frames = 1,
+		.regs = ov5693_720p_30fps,
+	},
+	{
+		.desc = "ov5693_1080P_30fps",
+		.width = 1940,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 81,
+		.used = 0,
+		.pixels_per_line = 3688,
+		.lines_per_frame = 2984,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = ov5693_1080p_30fps,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(ov5693_res_video))
+
+struct ov5693_vcm ov5693_vcm_ops = {
+	.power_up = ad5823_vcm_power_up,
+	.power_down = ad5823_vcm_power_down,
+	.init = ad5823_vcm_init,
+	.t_focus_vcm = ad5823_t_focus_vcm,
+	.t_focus_abs = ad5823_t_focus_abs,
+	.t_focus_rel = ad5823_t_focus_rel,
+	.q_focus_status = ad5823_q_focus_status,
+	.q_focus_abs = ad5823_q_focus_abs,
+};
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov680.c b/drivers/external_drivers/camera/drivers/media/i2c/ov680.c
new file mode 100644
index 0000000..d9f99ba
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov680.c
@@ -0,0 +1,1199 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include "ov680.h"
+
+#define to_ov680_device(sub_dev) container_of(sub_dev, struct ov680_device, sd)
+
+static int ov680_i2c_read_reg(struct v4l2_subdev *sd,
+			      u16 reg, u8 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	struct i2c_msg msg[2];
+	u16 data[2];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "error, no client->adapter\n");
+		return -ENODEV;
+	}
+
+	memset(msg, 0, sizeof(msg));
+	memset(data, 0, sizeof(data));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
+
+	msg[1].addr = client->addr;
+	msg[1].len = OV680_16BIT;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (u8 *)data;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret != 2) {
+		if (ret >= 0)
+			ret = -EIO;
+		goto error;
+	}
+
+	*val = (u8)data[0];
+
+	return 0;
+
+error:
+	dev_err(&client->dev, "read offset 0x%x error %d\n", reg, ret);
+	return ret;
+}
+
+static int ov680_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int ov680_i2c_write_reg(struct v4l2_subdev *sd,
+			       u16 reg, u8 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg;
+	const u16 len = 1 + sizeof(u16); /* 16-bit address + data */
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "error, no client->adapter\n");
+		return -ENODEV;
+	}
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	data[2] = val;
+
+	ret = ov680_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * ov680_write_reg_array - Initializes a list of registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __ov680_flush_reg_array(), __ov680_buf_reg_array() and
+ * __ov680_write_reg_is_consecutive() are internal functions to
+ * ov680_write_reg_array() and should be not used anywhere else.
+ */
+#ifdef OV680_FAST_I2C_REG_ARRAY
+static int __ov680_flush_reg_array(struct i2c_client *client,
+				   struct ov680_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov680_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __ov680_buf_reg_array(struct i2c_client *client,
+				   struct ov680_write_ctrl *ctrl,
+				   const struct ov680_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case OV680_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case OV680_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= OV680_MAX_WRITE_BUF_SIZE)
+		__ov680_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int
+__ov680_write_reg_is_consecutive(struct i2c_client *client,
+				 struct ov680_write_ctrl *ctrl,
+				 const struct ov680_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int ov680_write_reg_array(struct v4l2_subdev *sd,
+				 const struct ov680_reg *reglist)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct ov680_reg *next = reglist;
+	struct ov680_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != OV680_TOK_TERM; next++) {
+		switch (next->type & OV680_TOK_MASK) {
+		case OV680_TOK_DELAY:
+			err = __ov680_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__ov680_write_reg_is_consecutive(client, &ctrl,
+							      next)) {
+				err = __ov680_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __ov680_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "write error, aborted\n");
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __ov680_flush_reg_array(client, &ctrl);
+}
+#else
+static int ov680_write_reg_array(struct v4l2_subdev *sd,
+				 const struct ov680_reg *reglist)
+{
+	const struct ov680_reg *next = reglist;
+	int err = 0;
+	for (; next->type != OV680_TOK_TERM; next++) {
+		switch (next->type & OV680_TOK_MASK) {
+		case OV680_TOK_DELAY:
+			msleep(next->val);
+			break;
+		default:
+			err = ov680_i2c_write_reg(sd, next->reg, next->val);
+			if (err)
+				return err;
+			break;
+		}
+	}
+	return err;
+}
+#endif
+
+static int ov680_read_sensor(struct v4l2_subdev *sd, int sid,
+			     u16 reg, u8 *data) {
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = ov680_i2c_write_reg(sd, OV680_CMD_OP_REG, OV680_CMD_READ_SENSOR);
+	if (ret)
+		dev_dbg(&client->dev, "1%s - reg = %x failed\n", __func__, reg);
+	ret = ov680_i2c_write_reg(sd, OV680_CMD_SUB_OP_REG, sid);
+	if (ret)
+		dev_dbg(&client->dev, "2%s - reg = %x failed\n", __func__, reg);
+	/* high address */
+	ret = ov680_i2c_write_reg(sd, OV680_CMD_PARAMETER_1, reg >> 8);
+	if (ret)
+		dev_dbg(&client->dev, "3%s - reg = %x failed\n", __func__, reg);
+	/* low address */
+	ret = ov680_i2c_write_reg(sd, OV680_CMD_PARAMETER_2, reg & 0xff);
+	if (ret)
+		dev_dbg(&client->dev, "4%s - reg = %x failed\n", __func__, reg);
+	msleep(20);
+	ret = ov680_i2c_write_reg(sd, OV680_CMD_CIR_REG,
+				  OV680_CMD_CIR_SENSOR_ACCESS_STATE);
+	if (ret)
+		dev_dbg(&client->dev, "5%s - reg = %x failed\n", __func__, reg);
+	msleep(20);
+	ret = ov680_i2c_read_reg(sd, OV680_CMD_PARAMETER_4, data);
+	if (ret)
+		dev_dbg(&client->dev, "6%s - reg = %x failed\n", __func__, reg);
+	dev_dbg(&client->dev, "%s - sid = %x, reg = %x, data= %x successfully\n",
+		__func__, sid, reg, *data);
+	return ret;
+}
+
+static int ov680_dump_snr_regs(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 data;
+
+	/* sensor0 is 0x20, sensor 1 is 6c */
+	int sid = 0x20;
+	ret = ov680_read_sensor(sd, sid, 0x0000, &data); /* 0x97 */
+	ret = ov680_read_sensor(sd, sid, 0x0001, &data); /* 0x28 */
+	ret = ov680_read_sensor(sd, sid, 0x0100, &data);
+
+	sid = 0x6c;
+	ret = ov680_read_sensor(sd, sid, 0x0000, &data); /* 0x97 */
+	ret = ov680_read_sensor(sd, sid, 0x0001, &data); /* 0x28 */
+
+	ret = ov680_read_sensor(sd, sid, 0x0100, &data);
+	dev_dbg(&client->dev, "OV680 dump sns reg\n");
+	return 0;
+}
+
+static int ov680_dump_res_regs(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 reg_val;
+	u16 reg;
+
+	for (reg = REG_SC_90; reg <= REG_SC_93; reg++) {
+		ov680_i2c_read_reg(sd, reg, &reg_val);
+		dev_dbg(&client->dev, "%s: reg 0x%4x - with value 0x%2x\n",
+			__func__, reg, reg_val);
+	}
+
+	return 0;
+}
+
+static int ov680_dump_rx_regs(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 reg_val;
+	u16 reg;
+
+	for (reg = REG_YUV_CROP1_08; reg <= REG_YUV_CROP1_0B; reg++) {
+		ov680_i2c_read_reg(sd, reg, &reg_val);
+		dev_dbg(&client->dev, "%s: reg %x - with value %x\n",
+			__func__, reg, reg_val);
+	}
+
+	for (reg = REG_YUV_CROP1_08; reg <= REG_YUV_CROP1_0B; reg++) {
+		ov680_i2c_read_reg(sd, reg, &reg_val);
+		dev_dbg(&client->dev, "%s: reg %x - with value %x\n",
+			__func__, reg, reg_val);
+	}
+	return 0;
+}
+
+static int ov680_load_firmware(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov680_device *dev = to_ov680_device(sd);
+	int ret;
+
+	dev_info(&client->dev, "Start to load firmware.\n");
+
+	ret = ov680_write_reg_array(sd, dev->ov680_fw);
+	if (ret) {
+		dev_dbg(&client->dev, "%s - debug fw load failed\n", __func__);
+		return ret;
+	}
+
+	dev_info(&client->dev, "firmware load successfully.\n");
+	ov680_dump_res_regs(sd);
+	ov680_dump_rx_regs(sd);
+
+	return ret;
+}
+
+static int __ov680_s_power(struct v4l2_subdev *sd, int on, int load_fw)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	dev_info(&client->dev, "%s - on-%d.\n", __func__, on);
+	ret = dev->platform_data->power_ctrl(sd, on);
+	if (ret) {
+		dev_err(&client->dev,
+			"ov680_s_power error. on=%d ret=%d\n", on, ret);
+		return ret;
+	}
+
+	ret = dev->platform_data->gpio_ctrl(sd, on);
+	if (ret) {
+		dev_err(&client->dev,
+			"%s - gpio control failed\n", __func__);
+		return ret;
+	}
+
+	dev->power_on = on;
+	return ret;
+}
+
+static int ov680_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov680_s_power(sd, on, 0);
+	mutex_unlock(&dev->input_lock);
+
+	dev_dbg(&client->dev, "%s -flag =%d,  ret = %d\n", __func__, on, ret);
+
+	return ret;
+}
+
+static int ov680_s_config(struct v4l2_subdev *sd, void *pdata)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *mipi_info;
+	u8 reg_val = 0;
+	int ret;
+
+	dev_info(&client->dev, "ov680_s_config is called.\n");
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = (struct camera_sensor_platform_data *)pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret)
+			goto fail_power;
+	}
+
+	ret = __ov680_s_power(sd, 1, 0);
+	if (ret)
+		goto fail_power;
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_config;
+
+	msleep(200);
+	/* Detect for OV680 */
+	ret = ov680_i2c_read_reg(sd, REG_SC_00, &reg_val);
+	if (ret || (reg_val != 0x1E)) { /* defalut value of REG_SC_00*/
+		dev_err(&client->dev,
+			"reg SC_00 does no match with default value 0x1E. ret=%d sc_00=0x%04x\n",
+			ret, reg_val);
+		goto fail_config;
+	}
+	/* reg access test purpose */
+	ret = ov680_i2c_write_reg(sd, REG_SC_00, 0x03);
+	if (ret) {
+		dev_err(&client->dev, "ov680 write reg failed\n");
+		goto fail_config;
+	}
+
+	ret = ov680_i2c_read_reg(sd, REG_SC_00, &reg_val);
+
+	if (ret || (reg_val != 0x03)) { /* defalut value of REG_SC_00*/
+		dev_err(&client->dev,
+			"reg SC_00 is incorrect. ret=%d sc_00=0x%04x\n",
+			ret, reg_val);
+		goto fail_config;
+	}
+	ov680_i2c_write_reg(sd, REG_SC_00, 0x1E); /* write back value */
+	dev_info(&client->dev, "OV680 Chip was detected with reg access ok\n");
+
+	mipi_info = v4l2_get_subdev_hostdata(sd);
+	if (!mipi_info) {
+		dev_err(&client->dev, "ov680_s_config get mipi info failed\n");
+		goto fail_config;
+	}
+	dev->num_lanes = mipi_info->num_lanes;
+	/* bayer output or soc output */
+	if (mipi_info->input_format == ATOMISP_INPUT_FORMAT_YUV422_8) {
+		dev_dbg(&client->dev, "ov680_s_config - yuv output\n");
+		dev->bayer_fmt = 0;
+		dev->mbus_pixelcode = V4L2_MBUS_FMT_UYVY8_1X16;
+	} else {
+		dev_dbg(&client->dev, "ov680_s_config - bayer output\n");
+		dev->bayer_fmt = 1;
+		dev->mbus_pixelcode = V4L2_MBUS_FMT_SBGGR10_1X10;
+	 }
+
+	ret = __ov680_s_power(sd, 0, 0);
+	if (ret)
+		dev_err(&client->dev, "ov680 power-down err.\n");
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+
+fail_config:
+	dev->platform_data->csi_cfg(sd, 0);
+	__ov680_s_power(sd, 0, 0);
+fail_power:
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "ov680_s_config failed\n");
+	return ret;
+}
+
+static int ov680_enum_mbus_fmt(struct v4l2_subdev *sd,
+			       unsigned int index,
+			       enum v4l2_mbus_pixelcode *code)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	*code = dev->mbus_pixelcode;
+	return 0;
+}
+
+static int ov680_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+
+	if (code->index >= N_FW)
+		return -EINVAL;
+
+	code->code = dev->mbus_pixelcode;
+	return 0;
+}
+
+static int ov680_match_resolution(struct v4l2_mbus_framefmt *fmt)
+{
+	s32 w0, h0, mismatch, distance;
+	s32 w1 = fmt->width;
+	s32 h1 = fmt->height;
+	s32 min_distance = INT_MAX;
+	s32 i, idx = -1;
+
+	if (w1 == 0 || h1 == 0)
+		return -1;
+
+	for (i = 0; i < N_FW; i++) {
+		w0 = ov680_res_list[i].width;
+		h0 = ov680_res_list[i].height;
+		if (w0 < w1 || h0 < h1)
+			continue;
+		mismatch = abs(w0 * h1 - w1 * h0) * 8192 / w1 / h0;
+		if (mismatch > 8192 * OV680_MAX_RATIO_MISMATCH / 100)
+			continue;
+		distance = (w0 * h1 + w1 * h0) * 8192 / w1 / h1;
+		if (distance < min_distance) {
+			min_distance = distance;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static s32 ov680_try_mbus_fmt_locked(struct v4l2_subdev *sd,
+				     struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov680_device *dev = to_ov680_device(sd);
+	s32 res_num, idx = -1;
+
+	res_num = N_FW;
+
+	if ((fmt->width <= ov680_res_list[res_num - 1].width) &&
+	    (fmt->height <= ov680_res_list[res_num - 1].height))
+		idx = ov680_match_resolution(fmt);
+	if (idx == -1)
+		idx = res_num - 1;
+
+	fmt->width = ov680_res_list[idx].width;
+	fmt->height = ov680_res_list[idx].height;
+	fmt->code = dev->mbus_pixelcode;
+	dev_dbg(&client->dev, "%s - w = %d, h = %d, idx = %d\n",
+		__func__, fmt->width, fmt->height, idx);
+	return idx;
+}
+
+static int ov680_try_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov680_device *dev = to_ov680_device(sd);
+
+	dev_dbg(&client->dev, "%s- mbus format\n", __func__);
+	mutex_lock(&dev->input_lock);
+	dev->fw_index = ov680_try_mbus_fmt_locked(sd, fmt);
+	dev_dbg(&client->dev, "%s - w = %d, h = %d, code=%x\n",
+		__func__, fmt->width, fmt->height, fmt->code);
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov680_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+
+	mutex_lock(&dev->input_lock);
+	fmt->code = dev->mbus_pixelcode;
+	fmt->width = ov680_res_list[dev->fw_index].width;
+	fmt->height = ov680_res_list[dev->fw_index].height;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov680_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *ov680_info = NULL;
+	int ret;
+
+	dev_dbg(&client->dev, "%s - mbusf\n", __func__);
+
+	ov680_info = v4l2_get_subdev_hostdata(sd);
+	if (ov680_info == NULL) {
+		dev_dbg(&client->dev, "%s - mipi failed\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = ov680_try_mbus_fmt(sd, fmt);
+	if (ret)
+		goto out;
+
+	/* Sanity check */
+	if (unlikely(dev->fw_index == -1)) {
+		dev_dbg(&client->dev, "%s - fw_index failed\n", __func__);
+		ret = -EINVAL;
+	}
+out:
+	dev_dbg(&client->dev, "%s - mbusf done ret %d\n", __func__, ret);
+	return ret;
+}
+
+static int ov680_enum_framesizes(struct v4l2_subdev *sd,
+				 struct v4l2_frmsizeenum *fsize)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	s32 index = fsize->index;
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+
+	if (index >= N_FW) {
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->input_lock);
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov680_res_list[index].width;
+	fsize->discrete.height = ov680_res_list[index].height;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov680_enum_frameintervals(struct v4l2_subdev *sd,
+				     struct v4l2_frmivalenum *fival)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int i = fival->index;
+
+	dev_dbg(&client->dev, "%s - i = %d\n", __func__, i);
+
+	if (i >= N_FW)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = ov680_res_list[i].width;
+	fival->height = ov680_res_list[i].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov680_res_list[i].fps;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov680_g_frame_interval(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_frame_interval *interval)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov680_device *dev = to_ov680_device(sd);
+	dev_dbg(&client->dev, "%s\n", __func__);
+
+	mutex_lock(&dev->input_lock);
+	interval->interval.denominator = ov680_res_list[dev->fw_index].fps;
+	interval->interval.numerator = 1;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov680_enum_frame_size(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int index = fse->index;
+
+	dev_dbg(&client->dev, "%s - index = %d\n", __func__, index);
+
+	if (index >= N_FW)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fse->min_width = ov680_res_list[index].width;
+	fse->min_height = ov680_res_list[index].height;
+	fse->max_width = ov680_res_list[index].width;
+	fse->max_height = ov680_res_list[index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static struct
+v4l2_mbus_framefmt *__ov680_get_pad_format(struct ov680_device *dev,
+					   struct v4l2_subdev_fh *fh,
+					   unsigned int pad,
+					   enum v4l2_subdev_format_whence which)
+{
+	dev_dbg((struct device *)dev, "%s\n", __func__);
+
+	if (pad != 0)
+		dev_err((struct device *)dev,
+			"%s err, pad %x\n", __func__, pad);
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+
+	return &dev->format;
+}
+
+static int ov680_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct v4l2_mbus_framefmt *format =
+			__ov680_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+
+	if (!format) {
+		dev_dbg(&client->dev, "%s - failed\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->input_lock);
+	fmt->format = *format;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov680_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov680_device *dev = to_ov680_device(sd);
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+
+	mutex_lock(&dev->input_lock);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov680_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s\n", __func__);
+
+	*frames = 0;
+	return 0;
+}
+
+static int ov680_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	dev_dbg(&client->dev, "ov680_s_stream. enable=%d\n", enable);
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power_on && enable) {
+		/* Load firmware after power on. */
+		ret = ov680_load_firmware(sd);
+		if (ret) {
+			dev_err(&client->dev,
+				"ov680_load_firmware failed. ret=%d\n", ret);
+			dev->sys_activated = 0;
+		}
+		ov680_dump_rx_regs(sd);
+		ov680_dump_res_regs(sd);
+
+		dev->sys_activated = 1; /* fw loaded */
+		/* to be removed after get ov680 fw handshake document */
+		msleep(20000); /* wait enough for finish fw downloading */
+		ov680_dump_snr_regs(sd);
+		ov680_dump_rx_regs(sd);
+
+	} else { /* stream off */
+		dev->sys_activated = 0; /* fw loaded */
+	}
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int ov680_set_exposure(struct v4l2_subdev *sd, s32 val)
+{
+	/* to do: to control ov9729 exposure */
+	return 0;
+}
+
+static int ov680_set_wb_mode(struct v4l2_subdev *sd, s32 val)
+{
+	/* to do: to set wb mode */
+	return 0;
+}
+
+static int ov680_set_special_effect(struct v4l2_subdev *sd, s32 val)
+{
+	/* to do: to enable digital effects SDE */
+	return 0;
+}
+
+static int ov680_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	if (!ctrl)
+		return -EINVAL;
+
+	switch (ctrl->id) {
+	case V4L2_CID_FOCUS_STATUS:
+		ctrl->val = 0;
+		break;
+	case V4L2_CID_BIN_FACTOR_HORZ:
+	case V4L2_CID_BIN_FACTOR_VERT:
+		ctrl->val = 0;
+		break;
+	case V4L2_CID_LINK_FREQ:
+		ctrl->val = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ov680_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov680_device *dev = container_of(
+		ctrl->handler, struct ov680_device, ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		dev->fw_index = 0;
+		break;
+	case V4L2_CID_EXPOSURE:
+		ov680_set_exposure(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		ov680_set_wb_mode(&dev->sd, ctrl->val);
+		break;
+	case V4L2_CID_COLORFX:
+		ov680_set_special_effect(&dev->sd, ctrl->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+
+static int ov680_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	int ret;
+	u8 reg_val;
+
+	if (reg->size != 2)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power_on)
+		ret = ov680_i2c_read_reg(sd, reg->reg, &reg_val);
+	else
+		ret = -EIO;
+	mutex_unlock(&dev->input_lock);
+	if (ret)
+		return ret;
+
+	reg->val = reg_val;
+
+	return 0;
+}
+
+static int ov680_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct ov680_device *dev = to_ov680_device(sd);
+	int ret;
+
+	if (reg->size != 2)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->power_on)
+		ret = ov680_i2c_write_reg(sd, reg->reg, reg->val);
+	else
+		ret = -EIO;
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static long ov680_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	long ret = 0;
+	switch (cmd) {
+	case VIDIOC_DBG_G_REGISTER:
+		ret = ov680_g_register(sd, arg);
+		break;
+	case VIDIOC_DBG_S_REGISTER:
+		ret = ov680_s_register(sd, arg);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = ov680_s_ctrl,
+	.g_volatile_ctrl = ov680_g_ctrl,
+};
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_RUN_MODE,
+		.name = "Run Mode",
+		.type = V4L2_CTRL_TYPE_MENU,
+		.min = 1,
+		.def = 4,
+		.max = 4,
+		.qmenu = ctrl_run_mode_menu,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 5,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+		.name = "White Balance",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 9,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_COLORFX,
+		.name = "Color Special Effect",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.def = 0,
+		.max = 15,
+		.step = 1,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_HORZ,
+		.name = "horizontal binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = 1,
+		.step = 1,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_VERT,
+		.name = "vertical binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = 1,
+		.step = 1,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	},
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_LINK_FREQ,
+		.name = "Link Frequency",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 1,
+		.max = 1,
+		.step = 1,
+		.def = 1,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+	},
+};
+
+static struct v4l2_subdev_sensor_ops ov680_sensor_ops = {
+	.g_skip_frames	= ov680_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops ov680_video_ops = {
+	.try_mbus_fmt = ov680_try_mbus_fmt,
+	.s_mbus_fmt = ov680_set_mbus_fmt,
+	.g_mbus_fmt = ov680_get_mbus_fmt,
+	.s_stream = ov680_s_stream,
+	.enum_framesizes = ov680_enum_framesizes,
+	.enum_frameintervals = ov680_enum_frameintervals,
+	.enum_mbus_fmt = ov680_enum_mbus_fmt,
+	.g_frame_interval = ov680_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops ov680_core_ops = {
+	.s_power	= ov680_s_power,
+	.queryctrl	= v4l2_subdev_queryctrl,
+	.g_ctrl		= v4l2_subdev_g_ctrl,
+	.s_ctrl		= v4l2_subdev_s_ctrl,
+	.ioctl		= ov680_ioctl,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= ov680_g_register,
+	.s_register	= ov680_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_pad_ops ov680_pad_ops = {
+	.enum_mbus_code	 = ov680_enum_mbus_code,
+	.enum_frame_size = ov680_enum_frame_size,
+	.get_fmt	 = ov680_get_pad_format,
+	.set_fmt	 = ov680_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ov680_ops = {
+	.core		= &ov680_core_ops,
+	.pad		= &ov680_pad_ops,
+	.video		= &ov680_video_ops,
+	.sensor		= &ov680_sensor_ops
+};
+
+static int ov680_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov680_device *dev = to_ov680_device(sd);
+
+	release_firmware(dev->fw);
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	media_entity_cleanup(&dev->sd.entity);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	mutex_destroy(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov680_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct ov680_device *dev;
+	int ret;
+	unsigned int i;
+
+	const struct ov680_firmware *ov680_fw_header;
+	unsigned int ov680_fw_data_size;
+
+	dev_info(&client->dev, "ov680 probe called.\n");
+
+	/* allocate device & init sub device */
+	dev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	/* Request firmware */
+	ret = request_firmware(&dev->fw, "ov680_fw.bin", &client->dev);
+	if (ret || !dev->fw) {
+		dev_err(&client->dev,
+			"Requesting ov680_fw.bin failed, ret=%d.\n", ret);
+		goto out_free_dev;
+	}
+	ov680_fw_header = (const struct ov680_firmware *)dev->fw->data;
+	ov680_fw_data_size = ov680_fw_header->cmd_count *
+				ov680_fw_header->cmd_size;
+
+	/* Check firmware size: FW header size + FW data size */
+	if (dev->fw->size != (sizeof(*ov680_fw_header)+ov680_fw_data_size)) {
+		dev_err(&client->dev,
+			"Firmware size does not match: %lu<->%lu.\n",
+			dev->fw->size,
+			sizeof(*ov680_fw_header)+ov680_fw_data_size);
+		ret = -EINVAL;
+		goto out_free_dev;
+	}
+
+	/* Save firmware address */
+	dev->fw_index = 0;
+	dev->ov680_fw = (const struct ov680_reg *)&(ov680_fw_header[1]);
+
+	mutex_init(&dev->input_lock);
+
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov680_ops);
+
+	if (client->dev.platform_data) {
+		ret = ov680_s_config(&dev->sd, client->dev.platform_data);
+		if (ret) {
+			dev_dbg(&client->dev, "s_config failed\n");
+			goto out_free;
+		}
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls));
+	if (ret) {
+		dev_dbg(&client->dev, "v4l2_ctrl_handler_init failed\n");
+		ov680_remove(client);
+		goto out_free;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		dev_dbg(&client->dev, "%s: ctrl_handler error\n", __func__);
+		ov680_remove(client);
+		ret = dev->ctrl_handler.error;
+		goto out_free;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		dev_dbg(&client->dev, "media_entity_init failed\n");
+		ov680_remove(client);
+	}
+	dev_dbg(&client->dev, "%s - driver load done\n", __func__);
+	return ret;
+
+out_free:
+	release_firmware(dev->fw);
+	v4l2_device_unregister_subdev(&dev->sd);
+	mutex_destroy(&dev->input_lock);
+out_free_dev:
+	kfree(dev);
+	return ret;
+}
+
+static const struct i2c_device_id ov680_id[] = {
+	{OV680_NAME, 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ov680_id);
+
+static struct i2c_driver ov680_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV680_NAME,
+	},
+	.probe = ov680_probe,
+	.remove = ov680_remove,
+	.id_table = ov680_id,
+};
+
+module_i2c_driver(ov680_driver);
+
+MODULE_DESCRIPTION("OV680 4 Channel MIPI Bridge Controller Driver");
+MODULE_AUTHOR("Xiaolin Zhang<xiaolin.zhang@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov680.h b/drivers/external_drivers/camera/drivers/media/i2c/ov680.h
new file mode 100644
index 0000000..06e4d0b
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov680.h
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __OV680_H__
+#define __OV680_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/types.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define OV680_NAME "ov680"
+#define OV680_CHIP_ID 0x680
+
+#define I2C_MSG_LENGTH 0x2
+
+#define REG_SC_BASE 0x6000
+#define REG_SCCB_SLAVE_BASE 0x6100
+#define REG_MIPI_RX1_BASE 0x6200
+#define REG_MIPI_RX0_BASE 0x6300
+#define REG_MIPI_RX3_BASE 0x6400
+#define REG_MIPI_RX2_BASE 0x6500
+#define REG_IMAGE_STITCH1_BASE 0x6600
+#define REG_IMAGE_STITCH2_BASE 0x6700
+#define REG_IMAGE_STITCH3_BASE 0x6800
+#define REG_MIPI_TX_BASE 0x6900
+#define REG_MIPI_BIST_BASE 0x6a00
+#define REG_SCCB_MASTER_BASE 0x6af0
+#define REG_MC_BASE 0x6b00
+#define REG_AVERAGE1_BASE 0x6c00
+#define REG_AVERAGE2_BASE 0x6c80
+#define REG_AEC1_BASE 0x6d00
+#define REG_AEC2_BASE 0x6d80
+#define REG_AEC1_PK_BASE 0x6e00
+#define REG_AWB1_PK_BASE 0x6f00
+#define REG_AWB2_PK_BASE 0x6f80
+#define REG_ISP_CONTRL_BASE 0x7000
+#define REG_LSC_BASE 0x7180
+#define REG_AWB1_BASE 0x7200
+#define REG_CONTRAST1_BASE 0x7280
+#define REG_DPC1_BASE 0x7300
+#define REG_DNS1_BASE 0x7380
+#define REG_CIP1_BASE 0x7400
+#define REG_CMX1_BASE 0x7480
+#define REG_GAMMA1_BASE 0x7500
+#define REG_UVDARK1_BASE 0x7580
+#define REG_SDE1_BASE 0x7600
+#define REG_SCALE1_BASE 0x7680
+#define REG_YUV_CROP1_BASE 0x7700
+#define REG_PRE_ISP_2_BASE 0x7800
+#define REG_LSC2_BASE 0x7880
+#define REG_AWB2_BASE 0x7900
+#define REG_CONSTRAST2_BASE 0x7980
+#define REG_DPC2_BASE 0x7a00
+#define REG_DNS2_BASE 0x7a80
+#define REG_CIP2_BASE 0x7b00
+#define REG_COLOR_MATRIX2_BASE 0x7b80
+#define REG_GAMMA2_BASE 0x7c00
+#define REG_UVDARK2_BASE 0x7c80
+#define REG_SDE2_BASE 0x7d00
+#define REG_SCALE2_BASE 0x7d80
+#define REG_YUV_CROP2_BASE 0x7e00
+#define REG_FIRWWARE_BASE 0x8000
+
+#define REG_SC_00 (REG_SC_BASE + 0x00)
+#define REG_SC_03 (REG_SC_BASE + 0x03)
+#define REG_SC_06 (REG_SC_BASE + 0x06)
+#define REG_SC_0A (REG_SC_BASE + 0x0a)
+#define REG_SC_90 (REG_SC_BASE + 0x90)
+#define REG_SC_93 (REG_SC_BASE + 0x93)
+
+#define REG_SCCB_SLAVE_03 (REG_SCCB_SLAVE_BASE + 0x03)
+
+#define REG_MC_17 (REG_MC_BASE + 0x17)
+#define REG_MC_18 (REG_MC_BASE + 0x18)
+#define REG_MC_19 (REG_MC_BASE + 0x19)
+#define REG_MC_1A (REG_MC_BASE + 0x1a)
+#define REG_MC_1B (REG_MC_BASE + 0x1b)
+#define REG_MC_1C (REG_MC_BASE + 0x1c)
+#define REG_MC_1D (REG_MC_BASE + 0x1d)
+
+#define REG_YUV_CROP1_08 (REG_YUV_CROP1_BASE + 0x08)
+#define REG_YUV_CROP1_0B (REG_YUV_CROP1_BASE + 0x0b)
+
+/* ov680 command set definition */
+#define OV680_CMD_CIR_REG REG_MC_17 /* command interrupt register */
+#define OV680_CMD_OP_REG REG_MC_18 /* operation function */
+#define OV680_CMD_SUB_OP_REG REG_MC_19 /* sub function */
+#define OV680_CMD_PARAMETER_1 REG_MC_1A
+#define OV680_CMD_PARAMETER_2 REG_MC_1B
+#define OV680_CMD_PARAMETER_3 REG_MC_1C
+#define OV680_CMD_PARAMETER_4 REG_MC_1D
+
+#define OV680_CMD_CIR_IDLE_STATE 0x10
+#define OV680_CMD_CIR_OP_STATE 0x80
+#define OV680_CMD_CIR_SENSOR_ACCESS_STATE 0xf0
+
+#define OV680_CMD_SENSOR_CONFIG 0x81
+#define OV680_CMD_STREAM_CONFIG 0x82
+#define OV680_CMD_ISP_CONFIG 0x83
+#define OV680_CMD_READ_SENSOR 0x84
+#define OV680_CMD_WRITE_SENSOR 0x85
+
+#define OV680_CONFIG_SENSOR_720p 0x00
+#define OV680_CONFIG_SENSOR_VGA 0x01
+#define OV680_CONFIG_SENSOR_15FPS 0x11
+#define OV680_CONFIG_SENSOR_30FPS 0x13
+#define OV680_CONFIG_SENSOR_60FPS 0x15
+
+/* stream config sub function */
+#define OV680_CONFIG_STREAM_DEFAULT 0x01
+#define OV680_CONFIG_STREAM_S0_S0_A 0x00
+#define OV680_CONFIG_STREAM_S1_S1_A 0x11
+#define OV680_CONFIG_STREAM_S0_S1_A 0x01
+#define OV680_CONFIG_STREAM_S1_S0_A 0x10
+/* for 0x6b1b - virtual channel*/
+#define OV680_CONFIG_STREAM_INDEX_VC0 0x00
+#define OV680_CONFIG_STREAM_INDEX_VC1 0x55
+#define OV680_CONFIG_STREAM_INDEX_VC2 0xAA
+#define OV680_CONFIG_STREAM_INDEX_VC3 0xFF
+/* for 0x6b1c - index output group*/
+#define OV680_CONFIG_STREAM_INDEX_GROUP_1_SENSOR 0x01 /* 1280 x 720 */
+#define OV680_CONFIG_STREAM_INDEX_GROUP_2_SENSOR 0x02 /* 2560 x 720 */
+#define OV680_CONFIG_STREAM_INDEX_GROUP_NA_1 0x03
+#define OV680_CONFIG_STREAM_INDEX_GROUP_NA_2 0x04
+/* for 0x6b1d - index output group*/
+#define OV680_CONFIG_STREAM_INDEX_GROUP_720P 0x00 /* 1280 x 720 */
+#define OV680_CONFIG_STREAM_INDEX_GROUP_VGA 0x01 /* 640 x 480 */
+
+/* config isp */
+#define OV680_CONFIG_ISP_AEC_AGC_ON 0x00
+#define OV680_CONFIG_ISP_AEC_AGC_OFF 0x01
+#define OV680_CONFIG_ISP_AEC_TARGET_SET 0x02
+#define OV680_CONFIG_ISP_AEC_WEIGHT_SET 0x03
+
+#define OV680_CONFIG_ISP_DPC_ON 0x00
+#define OV680_CONFIG_ISP_DPC_OFF 0x01
+#define OV680_CONFIG_ISP_ISP_ON 0x02
+#define OV680_CONFIG_ISP_ISP_OFF 0x03
+#define OV680_CONFIG_ISP_LENC_ON 0x02
+#define OV680_CONFIG_ISP_LENS_OFF 0x03
+
+/* Todo:  to define more ov680 register names */
+
+#define OV680_FIRMWARE_SIZE (33020) /* size =0xb610 - 0x8000 */
+#define OV680_MAX_RATIO_MISMATCH 10 /* Unit in percentage */
+
+enum ov680_tok_type {
+	OV680_8BIT  = 0x0001,
+	OV680_16BIT = 0x0002,
+	OV680_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	OV680_TOK_DELAY  = 0xfe00	/* delay token for reg list */
+};
+#define OV680_TOK_MASK	0xfff0
+
+/**
+ * struct ov680_reg - 680 sensor  register format
+ * @reg: 16-bit offset to register
+ * @val: 8-bit register value
+ */
+struct ov680_reg {
+	enum ov680_tok_type type;
+	u16 reg;
+	u8 val;
+};
+
+#define OV680_MAX_WRITE_BUF_SIZE	32
+struct ov680_write_buffer {
+	u16 addr;
+	u8 data[OV680_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov680_write_ctrl {
+	int index;
+	struct ov680_write_buffer buffer;
+};
+
+enum ov680_contexts {
+	CONTEXT_PREVIEW = 0,
+	CONTEXT_SNAPSHOT,
+	CONTEXT_VIDEO,
+	CONTEXT_NUM
+};
+
+struct ov680_res_struct {
+	u16 width;
+	u16 height;
+	u16 fps;
+};
+
+struct ov680_firmware {
+	u32 cmd_count; /* The total count of commands stored in FW */
+	u32 cmd_size; /* The size of each command's storing space */
+};
+
+struct ov680_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct mutex input_lock; /* Serialize access to the device settings */
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int fw_index;
+	int streaming;
+	unsigned int num_lanes;
+	int bayer_fmt;
+	enum v4l2_mbus_pixelcode mbus_pixelcode;
+	bool sys_activated;
+	bool power_on;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *run_mode;
+
+	enum ov680_contexts cur_context;
+
+	const struct firmware *fw;
+	const struct ov680_reg *ov680_fw;
+};
+
+static struct ov680_res_struct ov680_res_list[] = {
+	{
+		.width = 1280,
+		.height = 1440,
+		.fps = 15,
+	},
+};
+#define N_FW (ARRAY_SIZE(ov680_res_list))
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
new file mode 100644
index 0000000..98f37b0
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.c
@@ -0,0 +1,1958 @@
+/*
+ * Support for OmniVision ov8830 1080p HD camera sensor.
+ *
+ * Copyright (c) 2011 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <asm/intel-mid.h>
+
+#include "ov8830.h"
+#include "ov8835.h"
+
+#define OV8830_BIN_FACTOR_MAX	2
+
+#define to_ov8830_sensor(sd) container_of(sd, struct ov8830_device, sd)
+
+static int
+ov8830_read_reg(struct i2c_client *client, u16 len, u16 reg, u16 *val)
+{
+	struct i2c_msg msg[2];
+	u16 data[OV8830_SHORT_MAX];
+	int err, i;
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	/* @len should be even when > 1 */
+	if (len > OV8830_BYTE_MAX) {
+		v4l2_err(client, "%s error, invalid data length\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0, sizeof(msg));
+	memset(data, 0, sizeof(data));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
+
+	msg[1].addr = client->addr;
+	msg[1].len = len;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (u8 *)data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err < 0)
+		goto error;
+
+	/* high byte comes first */
+	if (len == OV8830_8BIT) {
+		*val = (u8)data[0];
+	} else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			val[i] = be16_to_cpu(data[i]);
+	}
+
+	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int ov8830_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+	int retry = 0;
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (ret == num_msg)
+		return 0;
+
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_err(&client->dev, "retrying i2c write transfer... %d",
+			retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return ret;
+}
+
+static int
+ov8830_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (!client->adapter) {
+		v4l2_err(client, "%s error, no client->adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != OV8830_8BIT && data_length != OV8830_16BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == OV8830_8BIT) {
+		data[2] = (u8)(val);
+	} else {
+		/* OV8830_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = be16_to_cpu(val);
+	}
+
+	ret = ov8830_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+
+/*
+ * ov8830_write_reg_array - Initializes a list of MT9M114 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __ov8830_flush_reg_array, __ov8830_buf_reg_array() and
+ * __ov8830_write_reg_is_consecutive() are internal functions to
+ * ov8830_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __ov8830_flush_reg_array(struct i2c_client *client,
+				     struct ov8830_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov8830_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __ov8830_buf_reg_array(struct i2c_client *client,
+				   struct ov8830_write_ctrl *ctrl,
+				   const struct ov8830_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case OV8830_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case OV8830_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg.sreg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= OV8830_MAX_WRITE_BUF_SIZE)
+		__ov8830_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int
+__ov8830_write_reg_is_consecutive(struct i2c_client *client,
+				   struct ov8830_write_ctrl *ctrl,
+				   const struct ov8830_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg.sreg;
+}
+
+static int ov8830_write_reg_array(struct i2c_client *client,
+				   const struct ov8830_reg *reglist)
+{
+	const struct ov8830_reg *next = reglist;
+	struct ov8830_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != OV8830_TOK_TERM; next++) {
+		switch (next->type & OV8830_TOK_MASK) {
+		case OV8830_TOK_DELAY:
+			err = __ov8830_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__ov8830_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __ov8830_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __ov8830_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __ov8830_flush_reg_array(client, &ctrl);
+}
+
+static int drv201_write8(struct v4l2_subdev *sd, int reg, int val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct drv201_device *dev = to_drv201_device(sd);
+	struct i2c_msg msg;
+
+	memset(&msg, 0 , sizeof(msg));
+	msg.addr = DRV201_I2C_ADDR;
+	msg.len = 2;
+	msg.buf = dev->buffer;
+	msg.buf[0] = reg;
+	msg.buf[1] = val;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static int drv201_write16(struct v4l2_subdev *sd, int reg, int val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct drv201_device *dev = to_drv201_device(sd);
+	struct i2c_msg msg;
+
+	memset(&msg, 0 , sizeof(msg));
+	msg.addr = DRV201_I2C_ADDR;
+	msg.len = 3;
+	msg.buf = dev->buffer;
+	msg.buf[0] = reg;
+	msg.buf[1] = val >> 8;
+	msg.buf[2] = val & 0xFF;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static int drv201_read8(struct v4l2_subdev *sd, int reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct drv201_device *dev = to_drv201_device(sd);
+	struct i2c_msg msg[2];
+	int r;
+
+	memset(msg, 0 , sizeof(msg));
+	msg[0].addr = DRV201_I2C_ADDR;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = dev->buffer;
+	msg[0].buf[0] = reg;
+
+	msg[1].addr = DRV201_I2C_ADDR;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = dev->buffer;
+
+	r = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (r != ARRAY_SIZE(msg))
+		return -EIO;
+
+	return dev->buffer[0];
+}
+
+static int drv201_init(struct v4l2_subdev *sd)
+{
+	struct drv201_device *dev = to_drv201_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev->platform_data = camera_get_af_platform_data();
+	if (!dev->platform_data) {
+		v4l2_err(client, "failed to get platform data\n");
+		return -ENXIO;
+	}
+	return 0;
+}
+
+static int drv201_power_up(struct v4l2_subdev *sd)
+{
+	/* Transition time required from shutdown to standby state */
+	const int WAKEUP_DELAY_US = 100;
+	const int DEFAULT_CONTROL_VAL = 0x02;
+
+	struct drv201_device *dev = to_drv201_device(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int r;
+
+	/* Enable power */
+	r = dev->platform_data->power_ctrl(sd, 1);
+	if (r)
+		return r;
+
+	udelay(1);		/* Wait for VBAT to stabilize */
+
+	/* jiggle SCL pin to wake up device */
+	drv201_write8(sd, DRV201_CONTROL, 1);
+
+	usleep_range(WAKEUP_DELAY_US, WAKEUP_DELAY_US * 10);
+
+	/* Reset device */
+	r = drv201_write8(sd, DRV201_CONTROL, 1);
+	if (r < 0)
+		goto fail_powerdown;
+
+	/* Detect device */
+	r = drv201_read8(sd, DRV201_CONTROL);
+	if (r < 0)
+		goto fail_powerdown;
+	if (r != DEFAULT_CONTROL_VAL) {
+		r = -ENXIO;
+		goto fail_powerdown;
+	}
+
+	/* Use the liner mode to reduce the noise */
+	r = drv201_write8(sd, DRV201_MODE, DRV201_MODE_LINEAR);
+	if (r < 0)
+		goto fail_powerdown;
+
+	/* VCM RESONANCE FREQUENCY REGISTER (VCM_FREQ) */
+	r = drv201_write8(sd, DRV201_VCM_FREQ, DRV201_DEFAULT_VCM_FREQ);
+	if (r < 0)
+		goto fail_powerdown;
+
+	dev->focus = DRV201_MAX_FOCUS_POS;
+	dev->initialized = true;
+
+	v4l2_info(client, "detected drv201\n");
+	return 0;
+
+fail_powerdown:
+	dev->platform_data->power_ctrl(sd, 0);
+	return r;
+}
+
+static int drv201_power_down(struct v4l2_subdev *sd)
+{
+	struct drv201_device *dev = to_drv201_device(sd);
+
+	return dev->platform_data->power_ctrl(sd, 0);
+}
+
+static int drv201_t_focus_abs(struct v4l2_subdev *sd, s32 value)
+{
+	struct drv201_device *dev = to_drv201_device(sd);
+	int r;
+
+	if (!dev->initialized)
+		return -ENODEV;
+
+	value = clamp(value, 0, DRV201_MAX_FOCUS_POS);
+	r = drv201_write16(sd, DRV201_VCM_CURRENT, value);
+	if (r < 0)
+		return r;
+
+	getnstimeofday(&dev->focus_time);
+	dev->focus = value;
+	return 0;
+}
+
+/* Start group hold for the following register writes */
+static int ov8830_grouphold_start(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const int group = 0;
+
+	return ov8830_write_reg(client, OV8830_8BIT,
+				OV8830_GROUP_ACCESS,
+				group | OV8830_GROUP_ACCESS_HOLD_START);
+}
+
+/* End group hold and delay launch it */
+static int ov8830_grouphold_launch(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const int group = 0;
+	int ret;
+
+	/* End group */
+	ret = ov8830_write_reg(client, OV8830_8BIT,
+			       OV8830_GROUP_ACCESS,
+			       group | OV8830_GROUP_ACCESS_HOLD_END);
+	if (ret)
+		return ret;
+
+	/* Delay launch group (during next vertical blanking) */
+	return ov8830_write_reg(client, OV8830_8BIT,
+				OV8830_GROUP_ACCESS,
+				group | OV8830_GROUP_ACCESS_DELAY_LAUNCH);
+}
+
+/*
+ * Read EEPROM data from the le24l042cs chip and store
+ * it into a kmalloced buffer. On error return NULL.
+ * The caller must kfree the buffer when no more needed.
+ * @size: set to the size of the returned EEPROM data.
+ */
+static void *le24l042cs_read(struct i2c_client *client, u32 *size)
+{
+	static const unsigned int LE24L042CS_I2C_ADDR = 0xA0 >> 1;
+	static const unsigned int LE24L042CS_EEPROM_SIZE = 512;
+	static const unsigned int MAX_READ_SIZE = OV8830_MAX_WRITE_BUF_SIZE;
+	struct i2c_msg msg[2];
+	int addr;
+	char *buffer;
+
+	buffer = kmalloc(LE24L042CS_EEPROM_SIZE, GFP_KERNEL);
+	if (!buffer)
+		return NULL;
+
+	memset(msg, 0, sizeof(msg));
+	for (addr = 0; addr < LE24L042CS_EEPROM_SIZE; addr += MAX_READ_SIZE) {
+		unsigned int i2c_addr = LE24L042CS_I2C_ADDR;
+		unsigned char addr_buf;
+		int r;
+
+		i2c_addr |= (addr >> 8) & 1;
+		addr_buf = addr & 0xFF;
+
+		msg[0].addr = i2c_addr;
+		msg[0].flags = 0;
+		msg[0].len = 1;
+		msg[0].buf = &addr_buf;
+
+		msg[1].addr = i2c_addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].len = min(MAX_READ_SIZE, LE24L042CS_EEPROM_SIZE - addr);
+		msg[1].buf = &buffer[addr];
+
+		r = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+		if (r != ARRAY_SIZE(msg)) {
+			kfree(buffer);
+			dev_err(&client->dev, "read failed at 0x%03x\n", addr);
+			return NULL;
+		}
+	}
+
+	if (size)
+		*size = LE24L042CS_EEPROM_SIZE;
+	return buffer;
+}
+
+static int ov8830_g_priv_int_data(struct v4l2_subdev *sd,
+				  struct v4l2_private_int_data *priv)
+{
+	u32 size;
+	void *b = le24l042cs_read(v4l2_get_subdevdata(sd), &size);
+	int r = 0;
+
+	if (!b)
+		return -EIO;
+
+	if (copy_to_user(priv->data, b, min_t(__u32, priv->size, size)))
+		r = -EFAULT;
+
+	priv->size = size;
+	kfree(b);
+
+	return r;
+}
+
+static int __ov8830_get_max_fps_index(
+				const struct ov8830_fps_setting *fps_settings)
+{
+	int i;
+
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (fps_settings[i].fps == 0)
+			break;
+	}
+
+	return i - 1;
+}
+
+static int __ov8830_update_frame_timing(struct v4l2_subdev *sd, int exposure,
+			u16 *hts, u16 *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* Increase the VTS to match exposure + 14 */
+	if (exposure > *vts - OV8830_INTEGRATION_TIME_MARGIN)
+		*vts = (u16) exposure + OV8830_INTEGRATION_TIME_MARGIN;
+
+	ret = ov8830_write_reg(client, OV8830_16BIT, OV8830_TIMING_HTS, *hts);
+	if (ret)
+		return ret;
+
+	return ov8830_write_reg(client, OV8830_16BIT, OV8830_TIMING_VTS, *vts);
+}
+
+static int __ov8830_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
+			int dig_gain, u16 *hts, u16 *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int exp_val, ret;
+
+	/* Update frame timings. Expsure must be minimum <  vts-14 */
+	ret = __ov8830_update_frame_timing(sd, exposure, hts, vts);
+	if (ret)
+		return ret;
+
+	/* For OV8835, the low 4 bits are fraction bits and must be kept 0 */
+	exp_val = exposure << 4;
+	ret = ov8830_write_reg(client, OV8830_8BIT,
+			       OV8830_LONG_EXPO+2, exp_val & 0xFF);
+	if (ret)
+		return ret;
+
+	ret = ov8830_write_reg(client, OV8830_8BIT,
+			       OV8830_LONG_EXPO+1, (exp_val >> 8) & 0xFF);
+	if (ret)
+		return ret;
+
+	ret = ov8830_write_reg(client, OV8830_8BIT,
+			       OV8830_LONG_EXPO, (exp_val >> 16) & 0x0F);
+	if (ret)
+		return ret;
+
+	/* Digital gain : to all MWB channel gains */
+	if (dig_gain) {
+		ret = ov8830_write_reg(client, OV8830_16BIT,
+				OV8830_MWB_RED_GAIN_H, dig_gain);
+		if (ret)
+			return ret;
+
+		ret = ov8830_write_reg(client, OV8830_16BIT,
+				OV8830_MWB_GREEN_GAIN_H, dig_gain);
+		if (ret)
+			return ret;
+
+		ret = ov8830_write_reg(client, OV8830_16BIT,
+				OV8830_MWB_BLUE_GAIN_H, dig_gain);
+		if (ret)
+			return ret;
+	}
+
+	/* set global gain */
+	return ov8830_write_reg(client, OV8830_8BIT, OV8830_AGC_ADJ, gain);
+}
+
+static int ov8830_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
+				int dig_gain)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	const struct ov8830_resolution *res;
+	u16 hts, vts;
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	/* Validate exposure:  cannot exceed 16bit value */
+	exposure = clamp_t(int, exposure, 0, OV8830_MAX_EXPOSURE_VALUE);
+
+	/* Validate gain: must not exceed maximum 8bit value */
+	gain = clamp_t(int, gain, 0, OV8830_MAX_GAIN_VALUE);
+
+	/* Validate digital gain: must not exceed 12 bit value*/
+	dig_gain = clamp_t(int, dig_gain, 0, OV8830_MWB_GAIN_MAX);
+
+	/* Group hold is valid only if sensor is streaming. */
+	if (dev->streaming) {
+		ret = ov8830_grouphold_start(sd);
+		if (ret)
+			goto out;
+	}
+
+	res = &dev->curr_res_table[dev->fmt_idx];
+	hts = res->fps_options[dev->fps_index].pixels_per_line;
+	vts = res->fps_options[dev->fps_index].lines_per_frame;
+
+	ret = __ov8830_set_exposure(sd, exposure, gain, dig_gain, &hts, &vts);
+	if (ret)
+		goto out;
+
+	/* Updated the device variable. These are the current values. */
+	dev->gain = gain;
+	dev->exposure = exposure;
+	dev->digital_gain = dig_gain;
+
+out:
+	/* Group hold launch - delayed launch */
+	if (dev->streaming)
+		ret = ov8830_grouphold_launch(sd);
+
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov8830_s_exposure(struct v4l2_subdev *sd,
+			      struct atomisp_exposure *exposure)
+{
+	return ov8830_set_exposure(sd, exposure->integration_time[0],
+				exposure->gain[0], exposure->gain[1]);
+}
+
+static long ov8830_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return ov8830_s_exposure(sd, (struct atomisp_exposure *)arg);
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		return ov8830_g_priv_int_data(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ov8830_init_registers(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	if (dev->sensor_id == OV8835_CHIP_ID)
+		dev->basic_settings_list = ov8835_basic_settings;
+	else
+		dev->basic_settings_list = ov8830_BasicSettings;
+
+	return ov8830_write_reg_array(client, dev->basic_settings_list);
+}
+
+static int ov8830_init(struct v4l2_subdev *sd, u32 val)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = ov8830_init_registers(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static void ov8830_uninit(struct v4l2_subdev *sd)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	dev->exposure = 0;
+	dev->gain     = 0;
+	dev->digital_gain = 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	int ret;
+
+	/* Enable power */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* Release reset */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* Enable clock */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* Minumum delay is 8192 clock cycles before first i2c transaction,
+	 * which is 1.37 ms at the lowest allowed clock rate 6 MHz */
+	msleep(2);
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int __ov8830_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	int ret, r;
+
+	if (on == 0) {
+		ov8830_uninit(sd);
+		ret = power_down(sd);
+		r = drv201_power_down(sd);
+		if (ret == 0)
+			ret = r;
+		dev->power = 0;
+	} else {
+		ret = power_up(sd);
+		if (ret)
+			return ret;
+		ret = drv201_power_up(sd);
+		if (ret) {
+			power_down(sd);
+			return ret;
+		}
+
+		dev->power = 1;
+
+		/* Initalise sensor settings */
+		ret = ov8830_init_registers(sd);
+	}
+
+	return ret;
+}
+
+static int ov8830_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov8830_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	/*
+	 * FIXME: Compatibility with old behaviour: return to preview
+	 * when the device is power cycled.
+	 */
+	if (!ret && on)
+		v4l2_ctrl_s_ctrl(dev->run_mode, ATOMISP_RUN_MODE_PREVIEW);
+
+	return ret;
+}
+
+static int ov8830_g_chip_ident(struct v4l2_subdev *sd,
+				struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV8830, 0);
+
+	return 0;
+}
+
+/* Return value of the specified register, first try getting it from
+ * the register list and if not found, get from the sensor via i2c.
+ */
+static int ov8830_get_register(struct v4l2_subdev *sd, int reg,
+			       const struct ov8830_reg *reglist)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct ov8830_reg *next;
+	u16 val;
+
+	/* Try if the values is in the register list */
+	for (next = reglist; next->type != OV8830_TOK_TERM; next++) {
+		if (next->type != OV8830_8BIT) {
+			v4l2_err(sd, "only 8-bit registers supported\n");
+			return -ENXIO;
+		}
+		if (next->reg.sreg == reg)
+			return next->val;
+	}
+
+	/* If not, read from sensor */
+	if (ov8830_read_reg(client, OV8830_8BIT, reg, &val)) {
+		v4l2_err(sd, "failed to read register 0x%04X\n", reg);
+		return -EIO;
+	}
+
+	return val;
+}
+
+static int ov8830_get_register_16bit(struct v4l2_subdev *sd, int reg,
+		const struct ov8830_reg *reglist, unsigned int *value)
+{
+	int high, low;
+
+	high = ov8830_get_register(sd, reg, reglist);
+	if (high < 0)
+		return high;
+
+	low = ov8830_get_register(sd, reg + 1, reglist);
+	if (low < 0)
+		return low;
+
+	*value = ((u8) high << 8) | (u8) low;
+	return 0;
+}
+
+static int ov8830_get_intg_factor(struct v4l2_subdev *sd,
+				  struct camera_mipi_info *info,
+				  const struct ov8830_reg *reglist)
+{
+	const int ext_clk = 19200000; /* MHz */
+	struct atomisp_sensor_mode_data *m = &info->data;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	const struct ov8830_resolution *res =
+				&dev->curr_res_table[dev->fmt_idx];
+	int pll2_prediv;
+	int pll2_multiplier;
+	int pll2_divs;
+	int pll2_seld5;
+	int t1, t2, t3;
+	int sclk;
+	int ret;
+
+	memset(&info->data, 0, sizeof(info->data));
+
+	pll2_prediv     = ov8830_get_register(sd, OV8830_PLL_PLL10, reglist);
+	pll2_multiplier = ov8830_get_register(sd, OV8830_PLL_PLL11, reglist);
+	pll2_divs       = ov8830_get_register(sd, OV8830_PLL_PLL12, reglist);
+	pll2_seld5      = ov8830_get_register(sd, OV8830_PLL_PLL13, reglist);
+
+	if (pll2_prediv < 0 || pll2_multiplier < 0 ||
+	    pll2_divs < 0 || pll2_seld5 < 0)
+		return -EIO;
+
+	pll2_prediv &= 0x07;
+	pll2_multiplier &= 0x3F;
+	pll2_divs = (pll2_divs & 0x0F) + 1;
+	pll2_seld5 &= 0x03;
+
+	if (pll2_prediv <= 0)
+		return -EIO;
+
+	t1 = ext_clk / pll2_prediv;
+	t2 = t1 * pll2_multiplier;
+	t3 = t2 / pll2_divs;
+	sclk = t3;
+	if (pll2_seld5 == 0)
+		sclk = t3;
+	else if (pll2_seld5 == 3)
+		sclk = t3 * 2 / 5;
+	else
+		sclk = t3 / pll2_seld5;
+	m->vt_pix_clk_freq_mhz = sclk;
+
+	/* HTS and VTS */
+	m->frame_length_lines =
+			res->fps_options[dev->fps_index].lines_per_frame;
+	m->line_length_pck = res->fps_options[dev->fps_index].pixels_per_line;
+
+	m->coarse_integration_time_min = 0;
+	m->coarse_integration_time_max_margin = OV8830_INTEGRATION_TIME_MARGIN;
+
+	/* OV Sensor do not use fine integration time. */
+	m->fine_integration_time_min = 0;
+	m->fine_integration_time_max_margin = 0;
+
+	/*
+	 * read_mode indicate whether binning is used for calculating
+	 * the correct exposure value from the user side. So adapt the
+	 * read mode values accordingly.
+	 */
+	m->read_mode = res->bin_factor_x ?
+		OV8830_READ_MODE_BINNING_ON : OV8830_READ_MODE_BINNING_OFF;
+
+	ret = ov8830_get_register(sd, OV8830_TIMING_X_INC, res->regs);
+	if (ret < 0)
+		return ret;
+	m->binning_factor_x = ((ret >> 4) + 1) / 2;
+
+	ret = ov8830_get_register(sd, OV8830_TIMING_Y_INC, res->regs);
+	if (ret < 0)
+		return ret;
+	m->binning_factor_y = ((ret >> 4) + 1) / 2;
+
+	/* Get the cropping and output resolution to ISP for this mode. */
+	ret =  ov8830_get_register_16bit(sd, OV8830_HORIZONTAL_START_H,
+		res->regs, &m->crop_horizontal_start);
+	if (ret)
+		return ret;
+
+	ret = ov8830_get_register_16bit(sd, OV8830_VERTICAL_START_H,
+		res->regs, &m->crop_vertical_start);
+	if (ret)
+		return ret;
+
+	ret = ov8830_get_register_16bit(sd, OV8830_HORIZONTAL_END_H,
+		res->regs, &m->crop_horizontal_end);
+	if (ret)
+		return ret;
+
+	ret = ov8830_get_register_16bit(sd, OV8830_VERTICAL_END_H,
+		res->regs, &m->crop_vertical_end);
+	if (ret)
+		return ret;
+
+	ret = ov8830_get_register_16bit(sd, OV8830_HORIZONTAL_OUTPUT_SIZE_H,
+		res->regs, &m->output_width);
+	if (ret)
+		return ret;
+
+	return ov8830_get_register_16bit(sd, OV8830_VERTICAL_OUTPUT_SIZE_H,
+		res->regs, &m->output_height);
+}
+
+static int __ov8830_s_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	struct camera_mipi_info *info = v4l2_get_subdev_hostdata(sd);
+	const struct ov8830_resolution *res =
+		res = &dev->curr_res_table[dev->fmt_idx];
+	int i;
+	int ret;
+	int fps;
+	u16 hts;
+	u16 vts;
+
+	if (!interval->interval.numerator)
+		interval->interval.numerator = 1;
+
+	fps = interval->interval.denominator / interval->interval.numerator;
+
+	/* Ignore if we are already using the required FPS. */
+	if (fps == res->fps_options[dev->fps_index].fps)
+		return 0;
+
+	dev->fps_index = 0;
+
+	/* Go through the supported FPS list */
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (!res->fps_options[i].fps)
+			break;
+		if (abs(res->fps_options[i].fps - fps)
+		    < abs(res->fps_options[dev->fps_index].fps - fps))
+			dev->fps_index = i;
+	}
+
+	/* Get the new Frame timing values for new exposure */
+	hts = res->fps_options[dev->fps_index].pixels_per_line;
+	vts = res->fps_options[dev->fps_index].lines_per_frame;
+
+	/* update frametiming. Conside the curren exposure/gain as well */
+	ret = __ov8830_set_exposure(sd, dev->exposure, dev->gain,
+					dev->digital_gain, &hts, &vts);
+	if (ret)
+		return ret;
+
+	/* Update the new values so that user side knows the current settings */
+	ret = ov8830_get_intg_factor(sd, info, dev->basic_settings_list);
+	if (ret)
+		return ret;
+
+	interval->interval.denominator = res->fps_options[dev->fps_index].fps;
+	interval->interval.numerator = 1;
+
+	return 0;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+/* tune this value so that the DVS resolutions get selected properly,
+ * but make sure 16:9 does not match 4:3.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 500
+static int distance(struct ov8830_resolution const *res, const u32 w,
+				const u32 h)
+{
+	unsigned int w_ratio = ((res->width<<13)/w);
+	unsigned int h_ratio = ((res->height<<13)/h);
+	int match   = abs(((w_ratio<<13)/h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)
+		|| (match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/*
+ * Returns the nearest higher resolution index.
+ * @w: width
+ * @h: height
+ * matching is done based on enveloping resolution and
+ * aspect ratio. If the aspect ratio cannot be matched
+ * to any index, -1 is returned.
+ */
+static int nearest_resolution_index(struct v4l2_subdev *sd, int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	const struct ov8830_resolution *tmp_res = NULL;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	for (i = 0; i < dev->entries_curr_table; i++) {
+		tmp_res = &dev->curr_res_table[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+	return idx;
+}
+
+static int get_resolution_index(struct v4l2_subdev *sd, int w, int h)
+{
+	int i;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	for (i = 0; i < dev->entries_curr_table; i++) {
+		if (w != dev->curr_res_table[i].width)
+			continue;
+		if (h != dev->curr_res_table[i].height)
+			continue;
+		/* Found it */
+		return i;
+	}
+	return -1;
+}
+
+static int __ov8830_try_mbus_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	if ((fmt->width > OV8830_RES_WIDTH_MAX) ||
+	    (fmt->height > OV8830_RES_HEIGHT_MAX)) {
+		fmt->width = OV8830_RES_WIDTH_MAX;
+		fmt->height = OV8830_RES_HEIGHT_MAX;
+	} else {
+		idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller resolutions.
+		 * If it fails, it means the requested resolution is higher than we
+		 * can support. Fallback to highest possible resolution in this case.
+		 */
+		if (idx == -1)
+			idx = dev->entries_curr_table - 1;
+
+		fmt->width = dev->curr_res_table[idx].width;
+		fmt->height = dev->curr_res_table[idx].height;
+	}
+
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int ov8830_try_mbus_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	int r;
+
+	mutex_lock(&dev->input_lock);
+	r = __ov8830_try_mbus_fmt(sd, fmt);
+	mutex_unlock(&dev->input_lock);
+
+	return r;
+}
+
+static int ov8830_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	struct camera_mipi_info *ov8830_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 hts, vts;
+	int ret;
+	const struct ov8830_resolution *res;
+
+	ov8830_info = v4l2_get_subdev_hostdata(sd);
+	if (ov8830_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = __ov8830_try_mbus_fmt(sd, fmt);
+	if (ret)
+		goto out;
+
+	dev->fmt_idx = get_resolution_index(sd, fmt->width, fmt->height);
+	/* Sanity check */
+	if (unlikely(dev->fmt_idx == -1)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* Sets the default FPS */
+	dev->fps_index = 0;
+
+	/* Get the current resolution setting */
+	res = &dev->curr_res_table[dev->fmt_idx];
+
+	/* Write the selected resolution table values to the registers */
+	ret = ov8830_write_reg_array(client, res->regs);
+	if (ret)
+		goto out;
+
+	/* Frame timing registers are updates as part of exposure */
+	hts = res->fps_options[dev->fps_index].pixels_per_line;
+	vts = res->fps_options[dev->fps_index].lines_per_frame;
+
+	/*
+	 * update hts, vts, exposure and gain as one block. Note that the vts
+	 * will be changed according to the exposure used. But the maximum vts
+	 * dev->curr_res_table[dev->fmt_idx] should not be changed at all.
+	 */
+	ret = __ov8830_set_exposure(sd, dev->exposure, dev->gain,
+					dev->digital_gain, &hts, &vts);
+	if (ret)
+		goto out;
+
+	ret = ov8830_get_intg_factor(sd, ov8830_info, dev->basic_settings_list);
+
+out:
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov8830_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fmt->width = dev->curr_res_table[dev->fmt_idx].width;
+	fmt->height = dev->curr_res_table[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov8830_detect(struct i2c_client *client, u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 id35;
+	int ret, s_ret;
+
+	/* i2c check */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	/* check sensor chip ID - are same for both 8830 and 8835 modules */
+	ret = ov8830_read_reg(client, OV8830_16BIT, OV8830_CHIP_ID_HIGH, id);
+	if (ret)
+		return ret;
+
+	/* This always reads as 0x8830, even on 8835. */
+	dev_info(&client->dev, "chip_id = 0x%4.4x\n", *id);
+	if (*id != OV8830_CHIP_ID)
+		return -ENODEV;
+
+	/*
+	 * Check which module is attached OV8835 or OV8830.
+	 * We need to support OV8830 for a while.
+	 *
+	 * For correctly identifying the OV8835 module, sensor needs
+	 * to start streaming, OTP read enabled and wait for about 10ms
+	 * before reading the OTB Bank 0 for OV8835 module identification.
+	 *
+	 * TODO/FIXME Revisit OTP support is added or OV8830 not needed anymore.
+	 */
+	ret = ov8830_write_reg_array(client, ov8835_module_detection);
+	if (ret)
+		return ret;
+
+	msleep(20);
+
+	ret = ov8830_read_reg(client, OV8830_8BIT, OV8830_OTP_BANK0_PID, &id35);
+	if (ret)
+		goto out;
+
+	/* OTP BANK0 read will return 0x35 for OV8835 else 0*/
+	if (id35 == 0x35)
+		*id = OV8835_CHIP_ID;
+
+	dev_info(&client->dev, "sensor is ov%4.4x\n", *id);
+
+	/* REVISIT: HACK: Driver is currently forcing revision to 0 */
+	*revision = 0;
+
+out:
+	/* Stream off now. */
+	s_ret = ov8830_write_reg(client, OV8830_8BIT, OV8830_STREAM_MODE, 0);
+
+	return ret ? ret : s_ret;
+}
+
+/*
+ * ov8830 stream on/off
+ */
+static int ov8830_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = ov8830_write_reg(client, OV8830_8BIT, 0x0100, enable ? 1 : 0);
+	if (ret != 0) {
+		mutex_unlock(&dev->input_lock);
+		v4l2_err(client, "failed to set streaming\n");
+		return ret;
+	}
+
+	dev->streaming = enable;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/*
+ * ov8830 enum frame size, frame intervals
+ */
+static int ov8830_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= dev->entries_curr_table) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = dev->curr_res_table[index].width;
+	fsize->discrete.height = dev->curr_res_table[index].height;
+	fsize->reserved[0] = dev->curr_res_table[index].used;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov8830_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int fmt_index;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	const struct ov8830_resolution *res;
+
+	mutex_lock(&dev->input_lock);
+
+	/*
+	 * since the isp will donwscale the resolution to the right size,
+	 * find the nearest one that will allow the isp to do so important to
+	 * ensure that the resolution requested is padded correctly by the
+	 * requester, which is the atomisp driver in this case.
+	 */
+	fmt_index = nearest_resolution_index(sd, fival->width, fival->height);
+	if (-1 == fmt_index)
+		fmt_index = dev->entries_curr_table - 1;
+
+	res = &dev->curr_res_table[fmt_index];
+
+	/* Check if this index is supported */
+	if (index > __ov8830_get_max_fps_index(res->fps_options)) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = res->fps_options[index].fps;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov8830_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int ov8830_s_config(struct v4l2_subdev *sd,
+			    int irq, void *pdata)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			v4l2_err(client, "ov8830 platform init err\n");
+			return ret;
+		}
+	}
+
+	ret = __ov8830_s_power(sd, 1);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		v4l2_err(client, "ov8830 power-up err.\n");
+		return ret;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = ov8830_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		v4l2_err(client, "ov8830_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	/* power off sensor */
+	ret = __ov8830_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	if (ret) {
+		v4l2_err(client, "ov8830 power-down err.\n");
+		return ret;
+	}
+
+	return 0;
+
+fail_detect:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_csi_cfg:
+	__ov8830_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int
+ov8830_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int
+ov8830_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= dev->entries_curr_table) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fse->min_width = dev->curr_res_table[index].width;
+	fse->min_height = dev->curr_res_table[index].height;
+	fse->max_width = dev->curr_res_table[index].width;
+	fse->max_height = dev->curr_res_table[index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__ov8830_get_pad_format(struct ov8830_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+
+	return &sensor->format;
+}
+
+static int
+ov8830_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	fmt->format = *__ov8830_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	return 0;
+}
+
+static int
+ov8830_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__ov8830_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	*format = fmt->format;
+
+	return 0;
+}
+
+static int ov8830_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov8830_device *dev = container_of(
+		ctrl->handler, struct ov8830_device, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+	/* input_lock is taken by the control framework, so it
+	 * doesn't need to be taken here.
+	 */
+
+	/* We only handle V4L2_CID_RUN_MODE for now. */
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		switch (ctrl->val) {
+		case ATOMISP_RUN_MODE_VIDEO:
+			dev->curr_res_table = dev->sensor_id == OV8835_CHIP_ID ?
+				ov8835_res_video : ov8830_res_video;
+			dev->entries_curr_table =
+				dev->sensor_id == OV8835_CHIP_ID ?
+				ARRAY_SIZE(ov8835_res_video) :
+				ARRAY_SIZE(ov8830_res_video);
+			break;
+		case ATOMISP_RUN_MODE_STILL_CAPTURE:
+			dev->curr_res_table = dev->sensor_id == OV8835_CHIP_ID ?
+				ov8835_res_still : ov8830_res_still;
+			dev->entries_curr_table =
+				dev->sensor_id == OV8835_CHIP_ID ?
+				ARRAY_SIZE(ov8835_res_still) :
+				ARRAY_SIZE(ov8830_res_still);
+			break;
+		default:
+			dev->curr_res_table = dev->sensor_id == OV8835_CHIP_ID ?
+				ov8835_res_preview : ov8830_res_preview;
+			dev->entries_curr_table =
+				dev->sensor_id == OV8835_CHIP_ID ?
+				ARRAY_SIZE(ov8835_res_preview) :
+				ARRAY_SIZE(ov8830_res_preview);
+		}
+
+		dev->fmt_idx = 0;
+		dev->fps_index = 0;
+
+		return 0;
+	case V4L2_CID_TEST_PATTERN:
+		return ov8830_write_reg(client, OV8830_16BIT, 0x3070,
+					ctrl->val);
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		return drv201_t_focus_abs(&dev->sd, ctrl->val);
+	}
+
+	return -EINVAL; /* Should not happen. */
+}
+
+static int ov8830_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov8830_device *dev = container_of(
+		ctrl->handler, struct ov8830_device, ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_FOCUS_STATUS: {
+		static const struct timespec move_time = {
+			/* The time required for focus motor to move the lens */
+			.tv_sec = 0,
+			.tv_nsec = 60000000,
+		};
+		struct drv201_device *drv201 = to_drv201_device(&dev->sd);
+		struct timespec current_time, finish_time, delta_time;
+
+		getnstimeofday(&current_time);
+		finish_time = timespec_add(drv201->focus_time, move_time);
+		delta_time = timespec_sub(current_time, finish_time);
+		if (delta_time.tv_sec >= 0 && delta_time.tv_nsec >= 0) {
+			/* VCM motor is not moving */
+			ctrl->val = ATOMISP_FOCUS_HP_COMPLETE |
+				ATOMISP_FOCUS_STATUS_ACCEPTS_NEW_MOVE;
+		} else {
+			/* VCM motor is still moving */
+			ctrl->val = ATOMISP_FOCUS_STATUS_MOVING |
+				ATOMISP_FOCUS_HP_IN_PROGRESS;
+		}
+		return 0;
+	}
+	case V4L2_CID_BIN_FACTOR_HORZ:
+	case V4L2_CID_BIN_FACTOR_VERT: {
+		uint16_t reg = ctrl->id == V4L2_CID_BIN_FACTOR_VERT ?
+			OV8830_TIMING_X_INC : OV8830_TIMING_Y_INC;
+		int r = ov8830_get_register(
+			&dev->sd, reg, dev->curr_res_table[dev->fmt_idx].regs);
+
+		if (r < 0)
+			return r;
+
+		ctrl->val = fls((r >> 4) + (r & 0xf)) - 2;
+
+		return 0;
+	}
+	}
+
+	return 0;
+}
+
+static int
+ov8830_g_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	const struct ov8830_resolution *res;
+
+	mutex_lock(&dev->input_lock);
+
+	/* Return the currently selected settings' maximum frame interval */
+	res = &dev->curr_res_table[dev->fmt_idx];
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = res->fps_options[dev->fps_index].fps;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov8830_s_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov8830_s_frame_interval(sd, interval);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov8830_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = dev->curr_res_table[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov8830_video_ops = {
+	.s_stream = ov8830_s_stream,
+	.enum_framesizes = ov8830_enum_framesizes,
+	.enum_frameintervals = ov8830_enum_frameintervals,
+	.enum_mbus_fmt = ov8830_enum_mbus_fmt,
+	.try_mbus_fmt = ov8830_try_mbus_fmt,
+	.g_mbus_fmt = ov8830_g_mbus_fmt,
+	.s_mbus_fmt = ov8830_s_mbus_fmt,
+	.g_frame_interval = ov8830_g_frame_interval,
+	.s_frame_interval = ov8830_s_frame_interval,
+};
+
+static const struct v4l2_subdev_sensor_ops ov8830_sensor_ops = {
+	.g_skip_frames	= ov8830_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops ov8830_core_ops = {
+	.g_chip_ident = ov8830_g_chip_ident,
+	.queryctrl = v4l2_subdev_queryctrl,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
+	.s_power = ov8830_s_power,
+	.ioctl = ov8830_ioctl,
+	.init = ov8830_init,
+};
+
+/* REVISIT: Do we need pad operations? */
+static const struct v4l2_subdev_pad_ops ov8830_pad_ops = {
+	.enum_mbus_code = ov8830_enum_mbus_code,
+	.enum_frame_size = ov8830_enum_frame_size,
+	.get_fmt = ov8830_get_pad_format,
+	.set_fmt = ov8830_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ov8830_ops = {
+	.core = &ov8830_core_ops,
+	.video = &ov8830_video_ops,
+	.pad = &ov8830_pad_ops,
+	.sensor = &ov8830_sensor_ops,
+};
+
+static int ov8830_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov8830_device *dev = to_ov8830_sensor(sd);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	media_entity_cleanup(&dev->sd.entity);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = ov8830_s_ctrl,
+	.g_volatile_ctrl = ov8830_g_ctrl,
+};
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrl_run_mode = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_RUN_MODE,
+	.name = "run mode",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 1,
+	.def = 4,
+	.max = 4,
+	.qmenu = ctrl_run_mode_menu,
+};
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+		.name = "Absolute exposure",
+		.type = V4L2_CTRL_TYPE_MENU,
+		.max = 0xffff,
+		.qmenu = ctrl_run_mode_menu,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN,
+		.name = "Test pattern",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.step = 1,
+		.max = 0xffff,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_ABSOLUTE,
+		.name = "Focus absolute",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.step = 1,
+		.max = DRV201_MAX_FOCUS_POS,
+	}, {
+		/* This one is junk: see the spec for proper use of this CID. */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_STATUS,
+		.name = "Focus status",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.step = 1,
+		.max = 100,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}, {
+		/* This is crap. For compatibility use only. */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCAL_ABSOLUTE,
+		.name = "Focal lenght",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = (OV8830_FOCAL_LENGTH_NUM << 16) | OV8830_FOCAL_LENGTH_DEM,
+		.max = (OV8830_FOCAL_LENGTH_NUM << 16) | OV8830_FOCAL_LENGTH_DEM,
+		.step = 1,
+		.def = (OV8830_FOCAL_LENGTH_NUM << 16) | OV8830_FOCAL_LENGTH_DEM,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		/* This one is crap, too. For compatibility use only. */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_ABSOLUTE,
+		.name = "F-number",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = (OV8830_F_NUMBER_DEFAULT_NUM << 16) | OV8830_F_NUMBER_DEM,
+		.max = (OV8830_F_NUMBER_DEFAULT_NUM << 16) | OV8830_F_NUMBER_DEM,
+		.step = 1,
+		.def = (OV8830_F_NUMBER_DEFAULT_NUM << 16) | OV8830_F_NUMBER_DEM,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		/*
+		 * The most utter crap. _Never_ use this, even for
+		 * compatibility reasons!
+		 */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_RANGE,
+		.name = "F-number range",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = (OV8830_F_NUMBER_DEFAULT_NUM << 24) | (OV8830_F_NUMBER_DEM << 16) | (OV8830_F_NUMBER_DEFAULT_NUM << 8) | OV8830_F_NUMBER_DEM,
+		.max = (OV8830_F_NUMBER_DEFAULT_NUM << 24) | (OV8830_F_NUMBER_DEM << 16) | (OV8830_F_NUMBER_DEFAULT_NUM << 8) | OV8830_F_NUMBER_DEM,
+		.step = 1,
+		.def = (OV8830_F_NUMBER_DEFAULT_NUM << 24) | (OV8830_F_NUMBER_DEM << 16) | (OV8830_F_NUMBER_DEFAULT_NUM << 8) | OV8830_F_NUMBER_DEM,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_HORZ,
+		.name = "Horizontal binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = OV8830_BIN_FACTOR_MAX,
+		.step = 1,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_VERT,
+		.name = "Vertical binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = OV8830_BIN_FACTOR_MAX,
+		.step = 1,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}
+};
+
+static int ov8830_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct ov8830_device *dev;
+	unsigned int i;
+	int ret;
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		v4l2_err(client, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov8830_ops);
+
+	ret = drv201_init(&dev->sd);
+	if (ret < 0)
+		goto out_free;
+
+	if (client->dev.platform_data) {
+		ret = ov8830_s_config(&dev->sd, client->irq,
+				      client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls) + 1);
+	if (ret) {
+		ov8830_remove(client);
+		return ret;
+	}
+
+	dev->run_mode = v4l2_ctrl_new_custom(&dev->ctrl_handler,
+					     &ctrl_run_mode, NULL);
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		ov8830_remove(client);
+		return dev->ctrl_handler.error;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		ov8830_remove(client);
+		return ret;
+	}
+
+	return 0;
+
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+static const struct i2c_device_id ov8830_id[] = {
+	{OV8830_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ov8830_id);
+
+static struct i2c_driver ov8830_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV8830_NAME,
+	},
+	.probe = ov8830_probe,
+	.remove = ov8830_remove,
+	.id_table = ov8830_id,
+};
+
+static __init int ov8830_init_mod(void)
+{
+	return i2c_add_driver(&ov8830_driver);
+}
+
+static __exit void ov8830_exit_mod(void)
+{
+	i2c_del_driver(&ov8830_driver);
+}
+
+module_init(ov8830_init_mod);
+module_exit(ov8830_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV8830 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8830.h b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.h
new file mode 100644
index 0000000..833f1ab
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8830.h
@@ -0,0 +1,1685 @@
+/*
+ * Support for Omnivision OV8830 camera sensor.
+ * Based on Aptina mt9e013 driver.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV8830_H__
+#define __OV8830_H__
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/types.h>
+
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define to_drv201_device(_sd) (&(container_of(_sd, struct ov8830_device, sd) \
+				 ->drv201))
+
+#define DRV201_I2C_ADDR				0x0E
+#define DRV201_CONTROL				2
+#define DRV201_VCM_CURRENT			3
+#define DRV201_STATUS				5
+#define DRV201_MODE				6
+#define DRV201_VCM_FREQ				7
+
+#define DRV201_DEFAULT_VCM_FREQ			0xe6
+#define DRV201_MIN_DEFAULT_VCM_FREQ		0x00
+#define DRV201_MAX_DEFAULT_VCM_FREQ		0xff
+
+#define DRV201_MAX_FOCUS_POS			1023
+#define DRV201_MODE_LINEAR			2
+
+/* drv201 device structure */
+struct drv201_device {
+	bool initialized;		/* true if drv201 is detected */
+	s32 focus;			/* Current focus value */
+	struct timespec focus_time;	/* Time when focus was last time set */
+	__u8 buffer[4];			/* Used for i2c transactions */
+	const struct camera_af_platform_data *platform_data;
+};
+
+#define	OV8830_NAME	"ov8830"
+#define	OV8830_ADDR	0x36
+#define OV8830_ID	0x4b00
+
+#define OV8830_CHIP_ID	0x8830
+#define OV8835_CHIP_ID	0x8835
+
+#define	LAST_REG_SETING		{0xffff, 0xff}
+#define	is_last_reg_setting(item) ((item).reg == 0xffff)
+#define I2C_MSG_LENGTH		0x2
+
+#define OV8830_INVALID_CONFIG	0xffffffff
+
+#define OV8830_INTG_UNIT_US	100
+#define OV8830_MCLK		192
+
+#define OV8830_REG_BITS	16
+#define OV8830_REG_MASK	0xFFFF
+
+/* This should be added into include/linux/videodev2.h */
+#ifndef V4L2_IDENT_OV8830
+#define V4L2_IDENT_OV8830	8245
+#endif
+
+/*
+ * ov8830 System control registers
+ */
+#define OV8830_PLL_PLL10			0x3090
+#define OV8830_PLL_PLL11			0x3091
+#define OV8830_PLL_PLL12			0x3092
+#define OV8830_PLL_PLL13			0x3093
+#define OV8830_TIMING_VTS			0x380e
+#define OV8830_TIMING_HTS			0x380C
+
+#define OV8830_HORIZONTAL_START_H		0x3800
+#define OV8830_HORIZONTAL_START_L		0x3801
+#define OV8830_VERTICAL_START_H			0x3802
+#define OV8830_VERTICAL_START_L			0x3803
+#define OV8830_HORIZONTAL_END_H			0x3804
+#define OV8830_HORIZONTAL_END_L			0x3805
+#define OV8830_VERTICAL_END_H			0x3806
+#define OV8830_VERTICAL_END_L			0x3807
+#define OV8830_HORIZONTAL_OUTPUT_SIZE_H		0x3808
+#define OV8830_HORIZONTAL_OUTPUT_SIZE_L		0x3809
+#define OV8830_VERTICAL_OUTPUT_SIZE_H		0x380a
+#define OV8830_VERTICAL_OUTPUT_SIZE_L		0x380b
+
+#define OV8830_SC_CMMN_CHIP_ID_H		0x0000
+#define OV8830_SC_CMMN_CHIP_ID_L		0x0001
+
+#define OV8830_GROUP_ACCESS			0x3208
+#define OV8830_GROUP_ACCESS_HOLD_START		0x00
+#define OV8830_GROUP_ACCESS_HOLD_END		0x10
+#define OV8830_GROUP_ACCESS_DELAY_LAUNCH	0xA0
+#define OV8830_GROUP_ACCESS_QUICK_LAUNCH	0xE0
+
+#define OV8830_LONG_EXPO			0x3500
+#define OV8830_AGC_ADJ				0x350B
+#define OV8830_TEST_PATTERN_MODE		0x3070
+
+/* ov8830 SCCB */
+#define OV8830_SCCB_CTRL			0x3100
+#define OV8830_AEC_PK_EXPO_H			0x3500
+#define OV8830_AEC_PK_EXPO_M			0x3501
+#define OV8830_AEC_PK_EXPO_L			0x3502
+#define OV8830_AEC_MANUAL_CTRL			0x3503
+#define OV8830_AGC_ADJ_H			0x3508
+#define OV8830_AGC_ADJ_L			0x3509
+
+#define OV8830_MWB_RED_GAIN_H			0x3400
+#define OV8830_MWB_GREEN_GAIN_H			0x3402
+#define OV8830_MWB_BLUE_GAIN_H			0x3404
+#define OV8830_MWB_GAIN_MAX			0x0fff
+
+#define OV8830_OTP_BANK0_PID			0x3d00
+#define OV8830_CHIP_ID_HIGH			0x300a
+#define OV8830_CHIP_ID_LOW			0x300b
+#define OV8830_STREAM_MODE			0x0100
+
+#define OV8830_FOCAL_LENGTH_NUM	439	/*4.39mm*/
+#define OV8830_FOCAL_LENGTH_DEM	100
+#define OV8830_F_NUMBER_DEFAULT_NUM	24
+#define OV8830_F_NUMBER_DEM	10
+
+#define OV8830_TIMING_X_INC		0x3814
+#define OV8830_TIMING_Y_INC		0x3815
+
+/* sensor_mode_data read_mode adaptation */
+#define OV8830_READ_MODE_BINNING_ON	0x0400
+#define OV8830_READ_MODE_BINNING_OFF	0x00
+#define OV8830_INTEGRATION_TIME_MARGIN	14
+
+#define OV8830_MAX_VTS_VALUE		0x7FFF
+#define OV8830_MAX_EXPOSURE_VALUE \
+		(OV8830_MAX_VTS_VALUE - OV8830_INTEGRATION_TIME_MARGIN)
+#define OV8830_MAX_GAIN_VALUE		0xFF
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV8830_FOCAL_LENGTH_DEFAULT 0x1B70064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV8830_F_NUMBER_DEFAULT 0x18000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV8830_F_NUMBER_RANGE 0x180a180a
+#define OTPM_ADD_START_1		0x1000
+#define OTPM_DATA_LENGTH_1		0x0100
+#define OTPM_COUNT 0x200
+
+/* Defines for register writes and register array processing */
+#define OV8830_BYTE_MAX	32
+#define OV8830_SHORT_MAX	16
+#define I2C_RETRY_COUNT		5
+#define OV8830_TOK_MASK	0xfff0
+
+#define	OV8830_STATUS_POWER_DOWN	0x0
+#define	OV8830_STATUS_STANDBY		0x2
+#define	OV8830_STATUS_ACTIVE		0x3
+#define	OV8830_STATUS_VIEWFINDER	0x4
+
+#define MAX_FPS_OPTIONS_SUPPORTED	3
+
+#define	v4l2_format_capture_type_entry(_width, _height, \
+		_pixelformat, _bytesperline, _colorspace) \
+	{\
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\
+		.fmt.pix.width = (_width),\
+		.fmt.pix.height = (_height),\
+		.fmt.pix.pixelformat = (_pixelformat),\
+		.fmt.pix.bytesperline = (_bytesperline),\
+		.fmt.pix.colorspace = (_colorspace),\
+		.fmt.pix.sizeimage = (_height)*(_bytesperline),\
+	}
+
+#define	s_output_format_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps) \
+	{\
+		.v4l2_fmt = v4l2_format_capture_type_entry(_width, \
+			_height, _pixelformat, _bytesperline, \
+				_colorspace),\
+		.fps = (_fps),\
+	}
+
+#define	s_output_format_reg_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps, _reg_setting) \
+	{\
+		.s_fmt = s_output_format_entry(_width, _height,\
+				_pixelformat, _bytesperline, \
+				_colorspace, _fps),\
+		.reg_setting = (_reg_setting),\
+	}
+
+struct s_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
+};
+
+#define	v4l2_queryctrl_entry_integer(_id, _name,\
+		_minimum, _maximum, _step, \
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_INTEGER, \
+		.name = _name, \
+		.minimum = (_minimum), \
+		.maximum = (_maximum), \
+		.step = (_step), \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+#define	v4l2_queryctrl_entry_boolean(_id, _name,\
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_BOOLEAN, \
+		.name = _name, \
+		.minimum = 0, \
+		.maximum = 1, \
+		.step = 1, \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+
+#define	s_ctrl_id_entry_integer(_id, _name, \
+		_minimum, _maximum, _step, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
+				_minimum, _maximum, _step,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+#define	s_ctrl_id_entry_boolean(_id, _name, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+
+#define	macro_string_entry(VAL)	\
+	{ \
+		.val = VAL, \
+		.string = #VAL, \
+	}
+
+enum ov8830_tok_type {
+	OV8830_8BIT  = 0x0001,
+	OV8830_16BIT = 0x0002,
+	OV8830_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	OV8830_TOK_DELAY  = 0xfe00	/* delay token for reg list */
+};
+
+/*
+ * If register address or register width is not 32 bit width,
+ * user needs to convert it manually
+ */
+
+struct s_register_setting {
+	u32 reg;
+	u32 val;
+};
+
+struct s_output_format {
+	struct v4l2_format v4l2_fmt;
+	int fps;
+};
+
+/**
+ * struct ov8830_fwreg - Firmware burst command
+ * @type: FW burst or 8/16 bit register
+ * @addr: 16-bit offset to register or other values depending on type
+ * @val: data value for burst (or other commands)
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov8830_fwreg {
+	enum ov8830_tok_type type; /* value, register or FW burst string */
+	u16 addr;	/* target address */
+	u32 val[8];
+};
+
+/**
+ * struct ov8830_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov8830_reg {
+	enum ov8830_tok_type type;
+	union {
+		u16 sreg;
+		struct ov8830_fwreg *fwreg;
+	} reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+	u32 val2;	/* optional: for rmw, OR mask */
+};
+
+struct ov8830_fps_setting {
+	int fps;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+};
+
+/* Store macro values' debug names */
+struct macro_string {
+	u8 val;
+	char *string;
+};
+
+static inline const char *
+macro_to_string(const struct macro_string *array, int size, u8 val)
+{
+	int i;
+	for (i = 0; i < size; i++) {
+		if (array[i].val == val)
+			return array[i].string;
+	}
+	return "Unknown VAL";
+}
+
+struct ov8830_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+struct ov8830_resolution {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	bool used;
+	const struct ov8830_reg *regs;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	unsigned short skip_frames;
+	const struct ov8830_fps_setting fps_options[MAX_FPS_OPTIONS_SUPPORTED];
+};
+
+struct ov8830_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct s_register_setting *regs;
+};
+
+/* ov8830 device structure */
+struct ov8830_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	int fmt_idx;
+	int streaming;
+	int power;
+	u16 sensor_id;
+	u8 sensor_revision;
+	int exposure;
+	int gain;
+	u16 digital_gain;
+	struct drv201_device drv201;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+
+	const struct ov8830_reg *basic_settings_list;
+	const struct ov8830_resolution *curr_res_table;
+	int entries_curr_table;
+	int fps_index;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *run_mode;
+};
+
+/*
+ * The i2c adapter on Intel Medfield can transfer 32 bytes maximum
+ * at a time. In burst mode we require that the buffer is transferred
+ * in one shot, so limit the buffer size to 32 bytes minus a safety.
+ */
+#define OV8830_MAX_WRITE_BUF_SIZE	30
+struct ov8830_write_buffer {
+	u16 addr;
+	u8 data[OV8830_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov8830_write_ctrl {
+	int index;
+	struct ov8830_write_buffer buffer;
+};
+
+#define OV8830_RES_WIDTH_MAX	3280
+#define OV8830_RES_HEIGHT_MAX	2464
+
+static const struct ov8830_reg ov8835_module_detection[] = {
+	{ OV8830_8BIT, { OV8830_STREAM_MODE }, 0x01 }, /* Stream on */
+	{ OV8830_8BIT, { 0x3d84 }, 0xc0 }, /* Select Bank 0 */
+	{ OV8830_8BIT, { 0x3d81 }, 0x01 }, /* OTP read enable */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_BasicSettings[] = {
+	{ OV8830_8BIT, { 0x0103 }, 0x01 },
+	{ OV8830_8BIT, { 0x0100 }, 0x00 },
+	{ OV8830_8BIT, { 0x0102 }, 0x01 },
+	{ OV8830_8BIT, { 0x3000 }, 0x00 },
+	{ OV8830_8BIT, { 0x3001 }, 0x2a },
+	{ OV8830_8BIT, { 0x3002 }, 0x88 },
+	{ OV8830_8BIT, { 0x3003 }, 0x00 },
+	{ OV8830_8BIT, { 0x3004 }, 0x00 },
+	{ OV8830_8BIT, { 0x3005 }, 0x00 },
+	{ OV8830_8BIT, { 0x3006 }, 0x00 },
+	{ OV8830_8BIT, { 0x3007 }, 0x00 },
+	{ OV8830_8BIT, { 0x3008 }, 0x00 },
+	{ OV8830_8BIT, { 0x3009 }, 0x00 },
+	{ OV8830_8BIT, { 0x3011 }, 0x41 },
+	{ OV8830_8BIT, { 0x3012 }, 0x08 },
+	{ OV8830_8BIT, { 0x3013 }, 0x10 },
+	{ OV8830_8BIT, { 0x3014 }, 0x00 },
+	{ OV8830_8BIT, { 0x3015 }, 0x08 },
+	{ OV8830_8BIT, { 0x3016 }, 0xf0 },
+	{ OV8830_8BIT, { 0x3017 }, 0xf0 },
+	{ OV8830_8BIT, { 0x3018 }, 0xf0 },
+	{ OV8830_8BIT, { 0x301b }, 0xb4 },
+	{ OV8830_8BIT, { 0x301d }, 0x02 },
+	{ OV8830_8BIT, { 0x3021 }, 0x00 },
+	{ OV8830_8BIT, { 0x3022 }, 0x00 },
+	{ OV8830_8BIT, { 0x3024 }, 0x00 },
+	{ OV8830_8BIT, { 0x3026 }, 0x00 },
+	{ OV8830_8BIT, { 0x3027 }, 0x00 },
+	{ OV8830_8BIT, { 0x3081 }, 0x02 },
+	{ OV8830_8BIT, { 0x3083 }, 0x01 },
+	{ OV8830_8BIT, { 0x3090 }, 0x01 }, /* PLL2 Settings SCLK 192mhZ*/
+	{ OV8830_8BIT, { 0x3091 }, 0x14 },
+	{ OV8830_8BIT, { 0x3094 }, 0x00 },
+	{ OV8830_8BIT, { 0x3092 }, 0x01 },
+	{ OV8830_8BIT, { 0x3093 }, 0x00 },
+	{ OV8830_8BIT, { 0x3098 }, 0x03 }, /* PLL3 Settings REF_CLK */
+	{ OV8830_8BIT, { 0x3099 }, 0x13 },
+	{ OV8830_8BIT, { 0x309a }, 0x00 },
+	{ OV8830_8BIT, { 0x309b }, 0x00 },
+	{ OV8830_8BIT, { 0x309c }, 0x01 },
+	{ OV8830_8BIT, { 0x30b3 }, 0x6b }, /* MIPI PLL1 Settings 684.4Mbps */
+	{ OV8830_8BIT, { 0x30b4 }, 0x03 },
+	{ OV8830_8BIT, { 0x30b5 }, 0x04 },
+	{ OV8830_8BIT, { 0x30b6 }, 0x01 },
+	{ OV8830_8BIT, { 0x3104 }, 0xa1 },
+	{ OV8830_8BIT, { 0x3106 }, 0x01 },
+	{ OV8830_8BIT, { 0x3300 }, 0x00 },
+	{ OV8830_8BIT, { 0x3400 }, 0x04 },
+	{ OV8830_8BIT, { 0x3401 }, 0x00 },
+	{ OV8830_8BIT, { 0x3402 }, 0x04 },
+	{ OV8830_8BIT, { 0x3403 }, 0x00 },
+	{ OV8830_8BIT, { 0x3404 }, 0x04 },
+	{ OV8830_8BIT, { 0x3405 }, 0x00 },
+	{ OV8830_8BIT, { 0x3406 }, 0x01 },
+	{ OV8830_8BIT, { 0x3500 }, 0x00 },
+	{ OV8830_8BIT, { 0x3501 }, 0x30 },
+	{ OV8830_8BIT, { 0x3502 }, 0x00 },
+	{ OV8830_8BIT, { 0x3503 }, 0x07 },
+	{ OV8830_8BIT, { 0x3504 }, 0x00 },
+	{ OV8830_8BIT, { 0x3505 }, 0x30 },
+	{ OV8830_8BIT, { 0x3506 }, 0x00 },
+	{ OV8830_8BIT, { 0x3507 }, 0x10 },
+	{ OV8830_8BIT, { 0x3508 }, 0x80 },
+	{ OV8830_8BIT, { 0x3509 }, 0x10 },
+	{ OV8830_8BIT, { 0x350a }, 0x00 },
+	{ OV8830_8BIT, { 0x350b }, 0x38 },
+	{ OV8830_8BIT, { 0x350c }, 0x00 },
+	{ OV8830_8BIT, { 0x350d }, 0x00 },
+	{ OV8830_8BIT, { 0x3600 }, 0x78 },
+	/* Next 2 values As Per OV recomm. Only for OV8830 */
+	{ OV8830_8BIT, { 0x3601 }, 0x0a },
+	{ OV8830_8BIT, { 0x3602 }, 0x9c },
+	{ OV8830_8BIT, { 0x3604 }, 0x38 },
+	{ OV8830_8BIT, { 0x3620 }, 0x64 },
+	{ OV8830_8BIT, { 0x3621 }, 0xb5 },
+	{ OV8830_8BIT, { 0x3622 }, 0x03 },
+	{ OV8830_8BIT, { 0x3625 }, 0x64 },
+	{ OV8830_8BIT, { 0x3630 }, 0x55 },
+	{ OV8830_8BIT, { 0x3631 }, 0xd2 },
+	{ OV8830_8BIT, { 0x3632 }, 0x00 },
+	{ OV8830_8BIT, { 0x3633 }, 0x34 },
+	{ OV8830_8BIT, { 0x3634 }, 0x03 },
+	{ OV8830_8BIT, { 0x3660 }, 0x80 },
+	{ OV8830_8BIT, { 0x3662 }, 0x10 },
+	{ OV8830_8BIT, { 0x3665 }, 0x00 },
+	{ OV8830_8BIT, { 0x3666 }, 0x00 },
+	{ OV8830_8BIT, { 0x3667 }, 0x00 },
+	{ OV8830_8BIT, { 0x366a }, 0x80 },
+	{ OV8830_8BIT, { 0x366c }, 0x00 },
+	{ OV8830_8BIT, { 0x366d }, 0x00 },
+	{ OV8830_8BIT, { 0x366e }, 0x00 },
+	{ OV8830_8BIT, { 0x366f }, 0x20 },
+	{ OV8830_8BIT, { 0x3680 }, 0xe0 },
+	{ OV8830_8BIT, { 0x3681 }, 0x00 },
+	{ OV8830_8BIT, { 0x3701 }, 0x14 },
+	{ OV8830_8BIT, { 0x3702 }, 0xbf },
+	{ OV8830_8BIT, { 0x3703 }, 0x8c },
+	{ OV8830_8BIT, { 0x3704 }, 0x78 },
+	{ OV8830_8BIT, { 0x3705 }, 0x02 },
+	{ OV8830_8BIT, { 0x3708 }, 0xe4 },
+	{ OV8830_8BIT, { 0x3709 }, 0x03 },
+	{ OV8830_8BIT, { 0x370a }, 0x00 },
+	{ OV8830_8BIT, { 0x370b }, 0x20 },
+	{ OV8830_8BIT, { 0x370c }, 0x0c },
+	{ OV8830_8BIT, { 0x370d }, 0x11 },
+	{ OV8830_8BIT, { 0x370e }, 0x00 },
+	{ OV8830_8BIT, { 0x370f }, 0x00 },
+	{ OV8830_8BIT, { 0x3710 }, 0x00 },
+	{ OV8830_8BIT, { 0x371c }, 0x01 },
+	{ OV8830_8BIT, { 0x371f }, 0x0c },
+	{ OV8830_8BIT, { 0x3721 }, 0x00 },
+	{ OV8830_8BIT, { 0x3724 }, 0x10 },
+	{ OV8830_8BIT, { 0x3726 }, 0x00 },
+	{ OV8830_8BIT, { 0x372a }, 0x01 },
+	{ OV8830_8BIT, { 0x3730 }, 0x18 },
+	{ OV8830_8BIT, { 0x3738 }, 0x22 },
+	{ OV8830_8BIT, { 0x3739 }, 0x08 },
+	{ OV8830_8BIT, { 0x373a }, 0x51 },
+	{ OV8830_8BIT, { 0x373b }, 0x02 },
+	{ OV8830_8BIT, { 0x373c }, 0x20 },
+	{ OV8830_8BIT, { 0x373f }, 0x02 },
+	{ OV8830_8BIT, { 0x3740 }, 0x42 },
+	{ OV8830_8BIT, { 0x3741 }, 0x02 },
+	{ OV8830_8BIT, { 0x3742 }, 0x18 },
+	{ OV8830_8BIT, { 0x3743 }, 0x01 },
+	{ OV8830_8BIT, { 0x3744 }, 0x02 },
+	{ OV8830_8BIT, { 0x3747 }, 0x10 },
+	{ OV8830_8BIT, { 0x374c }, 0x04 },
+	{ OV8830_8BIT, { 0x3751 }, 0xf0 },
+	{ OV8830_8BIT, { 0x3752 }, 0x00 },
+	{ OV8830_8BIT, { 0x3753 }, 0x00 },
+	{ OV8830_8BIT, { 0x3754 }, 0xc0 },
+	{ OV8830_8BIT, { 0x3755 }, 0x00 },
+	{ OV8830_8BIT, { 0x3756 }, 0x1a },
+	{ OV8830_8BIT, { 0x3758 }, 0x00 },
+	{ OV8830_8BIT, { 0x3759 }, 0x0f },
+	{ OV8830_8BIT, { 0x375c }, 0x04 },
+	{ OV8830_8BIT, { 0x3767 }, 0x01 },
+	{ OV8830_8BIT, { 0x376b }, 0x44 },
+	{ OV8830_8BIT, { 0x3774 }, 0x10 },
+	{ OV8830_8BIT, { 0x3776 }, 0x00 },
+	{ OV8830_8BIT, { 0x377f }, 0x08 },
+	{ OV8830_8BIT, { 0x3780 }, 0x22 },
+	{ OV8830_8BIT, { 0x3781 }, 0x0c },
+	{ OV8830_8BIT, { 0x3784 }, 0x2c },
+	{ OV8830_8BIT, { 0x3785 }, 0x1e },
+	{ OV8830_8BIT, { 0x378f }, 0xf5 },
+	{ OV8830_8BIT, { 0x3791 }, 0xb0 },
+	{ OV8830_8BIT, { 0x3795 }, 0x00 },
+	{ OV8830_8BIT, { 0x3796 }, 0x64 },
+	{ OV8830_8BIT, { 0x3797 }, 0x11 },
+	{ OV8830_8BIT, { 0x3798 }, 0x30 },
+	{ OV8830_8BIT, { 0x3799 }, 0x41 },
+	{ OV8830_8BIT, { 0x379a }, 0x07 },
+	{ OV8830_8BIT, { 0x379b }, 0xb0 },
+	{ OV8830_8BIT, { 0x379c }, 0x0c },
+	{ OV8830_8BIT, { 0x37c0 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c1 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c2 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c3 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c4 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c5 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c6 }, 0xa0 },
+	{ OV8830_8BIT, { 0x37c7 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c8 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c9 }, 0x00 },
+	{ OV8830_8BIT, { 0x37ca }, 0x00 },
+	{ OV8830_8BIT, { 0x37cb }, 0x00 },
+	{ OV8830_8BIT, { 0x37cc }, 0x00 },
+	{ OV8830_8BIT, { 0x37cd }, 0x00 },
+	{ OV8830_8BIT, { 0x37ce }, 0x01 },
+	{ OV8830_8BIT, { 0x37cf }, 0x00 },
+	{ OV8830_8BIT, { 0x37d1 }, 0x01 },
+	{ OV8830_8BIT, { 0x37de }, 0x00 },
+	{ OV8830_8BIT, { 0x37df }, 0x00 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_8BIT, { 0x3823 }, 0x00 },
+	{ OV8830_8BIT, { 0x3824 }, 0x00 },
+	{ OV8830_8BIT, { 0x3825 }, 0x00 },
+	{ OV8830_8BIT, { 0x3826 }, 0x00 },
+	{ OV8830_8BIT, { 0x3827 }, 0x00 },
+	{ OV8830_8BIT, { 0x382a }, 0x04 },
+	{ OV8830_8BIT, { 0x3a04 }, 0x09 },
+	{ OV8830_8BIT, { 0x3a05 }, 0xa9 },
+	{ OV8830_8BIT, { 0x3a06 }, 0x00 },
+	{ OV8830_8BIT, { 0x3a07 }, 0xf8 },
+	{ OV8830_8BIT, { 0x3a18 }, 0x00 },
+	{ OV8830_8BIT, { 0x3a19 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b00 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b01 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b02 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b03 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b04 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b05 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d00 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d01 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d02 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d03 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d04 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d05 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d06 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d07 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d08 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d09 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0a }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0b }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0c }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0d }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0e }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0f }, 0x00 },
+	{ OV8830_8BIT, { 0x3d80 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d81 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d84 }, 0x00 },
+	{ OV8830_8BIT, { 0x3e07 }, 0x20 },
+	{ OV8830_8BIT, { 0x4000 }, 0x18 },
+	{ OV8830_8BIT, { 0x4001 }, 0x04 },
+	{ OV8830_8BIT, { 0x4002 }, 0x45 },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 },
+	{ OV8830_8BIT, { 0x4005 }, 0x18 },
+	{ OV8830_8BIT, { 0x4006 }, 0x16 },
+	{ OV8830_8BIT, { 0x4008 }, 0x20 },
+	{ OV8830_8BIT, { 0x4009 }, 0x10 },
+	{ OV8830_8BIT, { 0x400c }, 0x00 },
+	{ OV8830_8BIT, { 0x400d }, 0x00 },
+	{ OV8830_8BIT, { 0x4058 }, 0x00 },
+	{ OV8830_8BIT, { 0x4101 }, 0x12 },
+	{ OV8830_8BIT, { 0x4104 }, 0x5b },
+	{ OV8830_8BIT, { 0x4303 }, 0x00 },
+	{ OV8830_8BIT, { 0x4304 }, 0x08 },
+	{ OV8830_8BIT, { 0x4307 }, 0x30 },
+	{ OV8830_8BIT, { 0x4315 }, 0x00 },
+	{ OV8830_8BIT, { 0x4511 }, 0x05 },
+	{ OV8830_8BIT, { 0x4512 }, 0x01 }, /* Binning option = Average */
+	{ OV8830_8BIT, { 0x4750 }, 0x00 },
+	{ OV8830_8BIT, { 0x4751 }, 0x00 },
+	{ OV8830_8BIT, { 0x4752 }, 0x00 },
+	{ OV8830_8BIT, { 0x4753 }, 0x00 },
+	{ OV8830_8BIT, { 0x4805 }, 0x01 },
+	{ OV8830_8BIT, { 0x4806 }, 0x00 },
+	{ OV8830_8BIT, { 0x481f }, 0x36 },
+	{ OV8830_8BIT, { 0x4831 }, 0x6c },
+	{ OV8830_8BIT, { 0x4837 }, 0x0c }, /* MIPI global timing */
+	{ OV8830_8BIT, { 0x4a00 }, 0xaa },
+	{ OV8830_8BIT, { 0x4a03 }, 0x01 },
+	{ OV8830_8BIT, { 0x4a05 }, 0x08 },
+	{ OV8830_8BIT, { 0x4a0a }, 0x88 },
+	{ OV8830_8BIT, { 0x5000 }, 0x06 },
+	{ OV8830_8BIT, { 0x5001 }, 0x01 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 },
+	{ OV8830_8BIT, { 0x5003 }, 0x20 },
+	{ OV8830_8BIT, { 0x5013 }, 0x00 },
+	{ OV8830_8BIT, { 0x5046 }, 0x4a },
+	{ OV8830_8BIT, { 0x5780 }, 0x1c },
+	{ OV8830_8BIT, { 0x5786 }, 0x20 },
+	{ OV8830_8BIT, { 0x5787 }, 0x10 },
+	{ OV8830_8BIT, { 0x5788 }, 0x18 },
+	{ OV8830_8BIT, { 0x578a }, 0x04 },
+	{ OV8830_8BIT, { 0x578b }, 0x02 },
+	{ OV8830_8BIT, { 0x578c }, 0x02 },
+	{ OV8830_8BIT, { 0x578e }, 0x06 },
+	{ OV8830_8BIT, { 0x578f }, 0x02 },
+	{ OV8830_8BIT, { 0x5790 }, 0x02 },
+	{ OV8830_8BIT, { 0x5791 }, 0xff },
+	{ OV8830_8BIT, { 0x5a08 }, 0x02 },
+	{ OV8830_8BIT, { 0x5e00 }, 0x00 },
+	{ OV8830_8BIT, { 0x5e10 }, 0x0c },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+/*****************************STILL********************************/
+
+static const struct ov8830_reg ov8830_cont_cap_720P[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x0c },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x40 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xe3 },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x75 },
+	{ OV8830_8BIT, { 0x3808 }, 0x05 }, /* Output size 1296x736 */
+	{ OV8830_8BIT, { 0x3809 }, 0x10 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0xe0 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Binning on */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_1080P_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x0c },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x40 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xe3 },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x75 },
+	{ OV8830_8BIT, { 0x3808 }, 0x07 }, /* Output size 1936x1104 */
+	{ OV8830_8BIT, { 0x3809 }, 0x90 },
+	{ OV8830_8BIT, { 0x380a }, 0x04 },
+	{ OV8830_8BIT, { 0x380b }, 0x50 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_cont_cap_qvga[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x01 }, /* O/p 336x256 Bin+skip+scale */
+	{ OV8830_8BIT, { 0x3809 }, 0x50 },
+	{ OV8830_8BIT, { 0x380a }, 0x01 },
+	{ OV8830_8BIT, { 0x380b }, 0x00 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x71 },
+	{ OV8830_8BIT, { 0x3815 }, 0x71 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Binning+skipping on */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_VGA_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x02 }, /* Ouput Size 656x496 */
+	{ OV8830_8BIT, { 0x3809 }, 0x90 },
+	{ OV8830_8BIT, { 0x380a }, 0x01 },
+	{ OV8830_8BIT, { 0x380b }, 0xf0 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Binning on */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_1M_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x04 }, /* Ouput Size 1040x784 1229x922 */
+	{ OV8830_8BIT, { 0x3809 }, 0x10 },
+	{ OV8830_8BIT, { 0x380a }, 0x03 },
+	{ OV8830_8BIT, { 0x380b }, 0x10 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_2M_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x06 }, /* Ouput Size 1640x1232 */
+	{ OV8830_8BIT, { 0x3809 }, 0x68 },
+	{ OV8830_8BIT, { 0x380a }, 0x04 },
+	{ OV8830_8BIT, { 0x380b }, 0xd0 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_3M_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x08 }, /* Ouput Size 2064x1552 */
+	{ OV8830_8BIT, { 0x3809 }, 0x10 },
+	{ OV8830_8BIT, { 0x380a }, 0x06 },
+	{ OV8830_8BIT, { 0x380b }, 0x10 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_5M_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x0a }, /* Ouput Size 2576x1936 */
+	{ OV8830_8BIT, { 0x3809 }, 0x10 },
+	{ OV8830_8BIT, { 0x380a }, 0x07 },
+	{ OV8830_8BIT, { 0x380b }, 0x90 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_6M_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x36 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x79 }, /* Read Array: 3291 x 2169 */
+	{ OV8830_8BIT, { 0x3808 }, 0x0c }, /* Output size 3280x1852 */
+	{ OV8830_8BIT, { 0x3809 }, 0xd0 },
+	{ OV8830_8BIT, { 0x380a }, 0x07 },
+	{ OV8830_8BIT, { 0x380b }, 0x3c },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_8M_STILL[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x0c }, /* Output size 3280x2464 */
+	{ OV8830_8BIT, { 0x3809 }, 0xd0 },
+	{ OV8830_8BIT, { 0x380a }, 0x09 },
+	{ OV8830_8BIT, { 0x380b }, 0xa0 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+/*****************************OV8830 PREVIEW********************************/
+
+static struct ov8830_reg const ov8830_PREVIEW_848x616[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x08 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x08 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xd7 },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 }, /* 8, 3287, 8, 2471 Binning*/
+	{ OV8830_8BIT, { 0x3807 }, 0xa7 }, /* Actual Size 3280x2464 */
+	{ OV8830_8BIT, { 0x3808 }, 0x03 },
+	{ OV8830_8BIT, { 0x3809 }, 0x50 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0x68 }, /* O/p 848x616 Binning+Scaling */
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Vertical Binning 0n */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f }, /* Horizontal Binning 0n */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_reg const ov8830_PREVIEW_WIDE_PREVIEW[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x0c },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x40 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xd3 },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x73 }, /* 3268x1840 */
+	{ OV8830_8BIT, { 0x3808 }, 0x05 },
+	{ OV8830_8BIT, { 0x3809 }, 0x00 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0xd0 }, /* 1280X720*/
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Binning on */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_reg const ov8830_PREVIEW_1632x1224[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x08 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x08 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xd7 },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xa7 }, /* Actual Size 3280x2464 */
+	{ OV8830_8BIT, { 0x3808 }, 0x06 },
+	{ OV8830_8BIT, { 0x3809 }, 0x60 },
+	{ OV8830_8BIT, { 0x380a }, 0x04 },
+	{ OV8830_8BIT, { 0x380b }, 0xc8 }, /* Output size: 1632x1224 */
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Vertical Binning 0n */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f }, /* Horizontal Binning 0n */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+/***************** OV8830 VIDEO ***************************************/
+
+static const struct ov8830_reg ov8830_QCIF_strong_dvs[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x08 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x08 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xd7 },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 }, /* 8, 3287, 8, 2471 Binning on*/
+	{ OV8830_8BIT, { 0x3807 }, 0xa7 }, /* Actual Size 3280x2464 */
+	{ OV8830_8BIT, { 0x3808 }, 0x00 }, /* O/p Binning + Scaling 216x176 */
+	{ OV8830_8BIT, { 0x3809 }, 0xd8 },
+	{ OV8830_8BIT, { 0x380a }, 0x00 },
+	{ OV8830_8BIT, { 0x380b }, 0xb0 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_QVGA_strong_dvs[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x08 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x08 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xd7 },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 }, /* 8, 3287, 8, 2471 Binning on*/
+	{ OV8830_8BIT, { 0x3807 }, 0xa7 }, /* Actual Size 3280x2464 */
+	{ OV8830_8BIT, { 0x3808 }, 0x01 }, /* 408x308 Binning+Scaling */
+	{ OV8830_8BIT, { 0x3809 }, 0x98 },
+	{ OV8830_8BIT, { 0x380a }, 0x01 },
+	{ OV8830_8BIT, { 0x380b }, 0x34 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_VGA_strong_dvs[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x08 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x08 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xd7 },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 }, /* 8, 3287, 8, 2471 Binning on*/
+	{ OV8830_8BIT, { 0x3807 }, 0xa7 }, /* Actual Size 3280x2464 */
+	{ OV8830_8BIT, { 0x3808 }, 0x03 }, /* 820x616 Binning + Scaling */
+	{ OV8830_8BIT, { 0x3809 }, 0x34 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0x68 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_reg const ov8830_480p_strong_dvs[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x01 },
+	{ OV8830_8BIT, { 0x3801 }, 0x09 },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x40 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0b },
+	{ OV8830_8BIT, { 0x3805 }, 0xd6 },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x73 }, /* TODO! 2766 x 1844 */
+	{ OV8830_8BIT, { 0x3808 }, 0x03 }, /* 936x602 Binning + Scaling */
+	{ OV8830_8BIT, { 0x3809 }, 0xa8 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0x5a },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Binning on */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_reg const ov8830_720p_strong_dvs[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x00 },
+	{ OV8830_8BIT, { 0x3801 }, 0x0c },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x40 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xd3 },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x73 },
+	{ OV8830_8BIT, { 0x3808 }, 0x06 }, /* O/p 1568*880 Bin+Scale */
+	{ OV8830_8BIT, { 0x3809 }, 0x20 },
+	{ OV8830_8BIT, { 0x380a }, 0x03 },
+	{ OV8830_8BIT, { 0x380b }, 0x70 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8830_1080p_strong_dvs[] = {
+	{ OV8830_8BIT, { 0x3800 }, 0x01 },
+	{ OV8830_8BIT, { 0x3801 }, 0xd8 },
+	{ OV8830_8BIT, { 0x3802 }, 0x02 },
+	{ OV8830_8BIT, { 0x3803 }, 0x36 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0a },
+	{ OV8830_8BIT, { 0x3805 }, 0xff },
+	{ OV8830_8BIT, { 0x3806 }, 0x07 },
+	{ OV8830_8BIT, { 0x3807 }, 0x65 }, /* 2344 x 1328 Crop */
+	{ OV8830_8BIT, { 0x3808 }, 0x09 }, /* 2336x1320 DVS O/p */
+	{ OV8830_8BIT, { 0x3809 }, 0x20 },
+	{ OV8830_8BIT, { 0x380a }, 0x05 },
+	{ OV8830_8BIT, { 0x380b }, 0x28 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_resolution ov8830_res_preview[] = {
+	{
+		 .desc = "OV8830_PREVIEW_848x616",
+		 .width = 848,
+		 .height = 616,
+		 .used = 0,
+		 .regs = ov8830_PREVIEW_848x616,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 3608,
+				.lines_per_frame = 2773,
+			},
+			{
+			}
+		}
+	},
+	{
+		 .desc = "ov8830_wide_preview",
+		 .width = 1280,
+		 .height = 720,
+		 .used = 0,
+		 .regs = ov8830_PREVIEW_WIDE_PREVIEW,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 3608,
+				.lines_per_frame = 2773,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8830_cont_cap_qvga",
+		 .width = 336,
+		 .height = 256,
+		 .used = 0,
+		 .regs = ov8830_cont_cap_qvga,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8830_cont_cap_vga",
+		 .width = 656,
+		 .height = 496,
+		 .used = 0,
+		 .regs = ov8830_VGA_STILL,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		}
+	},
+	{
+		 .desc = "OV8830_PREVIEW1600x1200",
+		 .width = 1632,
+		 .height = 1224,
+		 .used = 0,
+		 .regs = ov8830_PREVIEW_1632x1224,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 3608,
+				.lines_per_frame = 2773,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8830_cont_cap_720P",
+		 .width = 1296,
+		 .height = 736,
+		 .used = 0,
+		 .regs = ov8830_cont_cap_720P,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8830_cont_cap_1M",
+		 .width = 1040,
+		 .height = 784,
+		 .used = 0,
+		 .regs = ov8830_1M_STILL,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 0,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8830_cont_cap_1080P",
+		 .width = 1936,
+		 .height = 1104,
+		 .used = 0,
+		 .regs = ov8830_1080P_STILL,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 0,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8830_cont_cap_3M",
+		.width = 2064,
+		.height = 1552,
+		.used = 0,
+		.regs = ov8830_3M_STILL,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 0,
+		.fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8830_cont_cap_5M",
+		.width = 2576,
+		.height = 1936,
+		.used = 0,
+		.regs = ov8830_5M_STILL,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 0,
+		.fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8830_cont_cap_6M",
+		 .width = 3280,
+		 .height = 1852,
+		 .used = 0,
+		 .regs = ov8830_6M_STILL,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 0,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8830_cont_cap_8M",
+		.width = 3280,
+		.height = 2464,
+		.used = 0,
+		.regs = ov8830_8M_STILL,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 0,
+		.fps_options = {
+			{
+				.fps = 15,
+				.pixels_per_line = 4464,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+};
+
+static struct ov8830_resolution ov8830_res_still[] = {
+	{
+		 .desc = "STILL_VGA",
+		 .width = 656,
+		 .height = 496,
+		 .used = 0,
+		 .regs = ov8830_VGA_STILL,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "STILL_1080P",
+		 .width = 1936,
+		 .height = 1104,
+		 .used = 0,
+		 .regs = ov8830_1080P_STILL,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "STILL_1M",
+		 .width = 1040,
+		 .height = 784,
+		 .used = 0,
+		 .regs = ov8830_1M_STILL,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "STILL_2M",
+		 .width = 1640,
+		 .height = 1232,
+		 .used = 0,
+		 .regs = ov8830_2M_STILL,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "STILL_3M",
+		.width = 2064,
+		.height = 1552,
+		.used = 0,
+		.regs = ov8830_3M_STILL,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "STILL_5M",
+		.width = 2576,
+		.height = 1936,
+		.used = 0,
+		.regs = ov8830_5M_STILL,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "STILL_6M",
+		 .width = 3280,
+		 .height = 1852,
+		 .used = 0,
+		 .regs = ov8830_6M_STILL,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options =  {
+			{
+				.fps = 15,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "STILL_8M",
+		.width = 3280,
+		.height = 2464,
+		.used = 0,
+		.regs = ov8830_8M_STILL,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options = {
+			{
+				.fps = 15,
+				.pixels_per_line = 4464,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+};
+
+static struct ov8830_resolution ov8830_res_video[] = {
+	{
+		 .desc = "QCIF_strong_dvs",
+		 .width = 216,
+		 .height = 176,
+		 .used = 0,
+		 .regs = ov8830_QCIF_strong_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4128,
+				 .lines_per_frame = 1550,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "QVGA_strong_dvs",
+		 .width = 408,
+		 .height = 308,
+		 .used = 0,
+		 .regs = ov8830_QVGA_strong_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4128,
+				 .lines_per_frame = 1550,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "VGA_strong_dvs",
+		 .width = 820,
+		 .height = 616,
+		 .used = 0,
+		 .regs = ov8830_VGA_strong_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4128,
+				 .lines_per_frame = 1550,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "480p_strong_dvs",
+		.width = 936,
+		.height = 602,
+		.regs = ov8830_480p_strong_dvs,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.skip_frames = 0,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4128,
+				 .lines_per_frame = 1550,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "720p_strong_dvs",
+		 .width = 1568,
+		 .height = 880,
+		 .used = 0,
+		 .regs = ov8830_720p_strong_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4128,
+				 .lines_per_frame = 1550,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "MODE1920x1080",
+		 .width = 2336,
+		 .height = 1320,
+		 .used = 0,
+		 .regs = ov8830_1080p_strong_dvs,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 0,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4100,
+				 .lines_per_frame = 1561,
+			},
+			{
+			}
+		},
+	},
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8835.h b/drivers/external_drivers/camera/drivers/media/i2c/ov8835.h
new file mode 100644
index 0000000..08d4b6f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8835.h
@@ -0,0 +1,943 @@
+/*
+ * Support for Omnivision OV8830 camera sensor.
+ * Based on Aptina mt9e013 driver.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV8835_H__
+#define __OV8835_H__
+
+#include "ov8830.h"
+
+static const struct ov8830_reg ov8835_basic_settings[] = {
+	{ OV8830_8BIT, { 0x0103 }, 0x01 },
+	{ OV8830_8BIT, { 0x0100 }, 0x00 },
+	{ OV8830_8BIT, { 0x0102 }, 0x01 },
+	{ OV8830_8BIT, { 0x3001 }, 0x2a },
+	{ OV8830_8BIT, { 0x3002 }, 0x88 },
+	{ OV8830_8BIT, { 0x3005 }, 0x00 },
+	{ OV8830_8BIT, { 0x3011 }, 0x41 },
+	{ OV8830_8BIT, { 0x3015 }, 0x08 },
+	{ OV8830_8BIT, { 0x301b }, 0xb4 },
+	{ OV8830_8BIT, { 0x301d }, 0x02 },
+	{ OV8830_8BIT, { 0x3021 }, 0x00 },
+	{ OV8830_8BIT, { 0x3022 }, 0x02 },
+	{ OV8830_8BIT, { 0x3081 }, 0x02 },
+	{ OV8830_8BIT, { 0x3083 }, 0x01 },
+	{ OV8830_8BIT, { 0x3090 }, 0x02 }, /* PLL2 Settings 278.4MHz*/
+	{ OV8830_8BIT, { 0x3091 }, 0x1d },
+	{ OV8830_8BIT, { 0x3094 }, 0x00 },
+	{ OV8830_8BIT, { 0x3092 }, 0x00 },
+	{ OV8830_8BIT, { 0x3093 }, 0x00 },
+	{ OV8830_8BIT, { 0x3098 }, 0x03 }, /* PLL3 Settings REF_CLK 256Mhz*/
+	{ OV8830_8BIT, { 0x3099 }, 0x14 },
+	{ OV8830_8BIT, { 0x309a }, 0x00 },
+	{ OV8830_8BIT, { 0x309b }, 0x00 },
+	{ OV8830_8BIT, { 0x309c }, 0x01 },
+	{ OV8830_8BIT, { 0x30a2 }, 0x01 }, /* Ref Clk -> Manual mode enabled */
+	{ OV8830_8BIT, { 0x30b0 }, 0x05 },
+	{ OV8830_8BIT, { 0x30b2 }, 0x00 },
+	{ OV8830_8BIT, { 0x30b3 }, 0x6b }, /* MIPI PLL1 Settings 684.4Mbps*/
+	{ OV8830_8BIT, { 0x30b4 }, 0x03 },
+	{ OV8830_8BIT, { 0x30b5 }, 0x04 },
+	{ OV8830_8BIT, { 0x30b6 }, 0x01 },
+	{ OV8830_8BIT, { 0x3104 }, 0xa1 },
+	{ OV8830_8BIT, { 0x3106 }, 0x01 },
+	{ OV8830_8BIT, { 0x3400 }, 0x04 },
+	{ OV8830_8BIT, { 0x3401 }, 0x00 },
+	{ OV8830_8BIT, { 0x3402 }, 0x04 },
+	{ OV8830_8BIT, { 0x3403 }, 0x00 },
+	{ OV8830_8BIT, { 0x3404 }, 0x04 },
+	{ OV8830_8BIT, { 0x3405 }, 0x00 },
+	{ OV8830_8BIT, { 0x3406 }, 0x01 },
+	{ OV8830_8BIT, { 0x3503 }, 0x07 },
+	{ OV8830_8BIT, { 0x3504 }, 0x00 },
+	{ OV8830_8BIT, { 0x3505 }, 0x30 },
+	{ OV8830_8BIT, { 0x3506 }, 0x00 },
+	{ OV8830_8BIT, { 0x3507 }, 0x10 },
+	{ OV8830_8BIT, { 0x3508 }, 0x80 },
+	{ OV8830_8BIT, { 0x3509 }, 0x10 },
+	{ OV8830_8BIT, { 0x350a }, 0x00 },
+	{ OV8830_8BIT, { 0x350b }, 0x38 },
+	{ OV8830_8BIT, { 0x3600 }, 0x98 },
+	{ OV8830_8BIT, { 0x3601 }, 0x02 },
+	{ OV8830_8BIT, { 0x3602 }, 0x7c },
+	{ OV8830_8BIT, { 0x3604 }, 0x38 },
+	{ OV8830_8BIT, { 0x3612 }, 0x80 },
+	{ OV8830_8BIT, { 0x3620 }, 0x41 },
+	{ OV8830_8BIT, { 0x3621 }, 0xa4 },
+	{ OV8830_8BIT, { 0x3622 }, 0x0f },
+	{ OV8830_8BIT, { 0x3625 }, 0x44 },
+	{ OV8830_8BIT, { 0x3630 }, 0x55 },
+	{ OV8830_8BIT, { 0x3631 }, 0xf2 },
+	{ OV8830_8BIT, { 0x3632 }, 0x00 },
+	{ OV8830_8BIT, { 0x3633 }, 0x34 },
+	{ OV8830_8BIT, { 0x3634 }, 0x03 },
+	{ OV8830_8BIT, { 0x364d }, 0x0d },
+	{ OV8830_8BIT, { 0x364f }, 0x60 },
+	{ OV8830_8BIT, { 0x3660 }, 0x80 },
+	{ OV8830_8BIT, { 0x3662 }, 0x10 },
+	{ OV8830_8BIT, { 0x3665 }, 0x00 },
+	{ OV8830_8BIT, { 0x3666 }, 0x00 },
+	{ OV8830_8BIT, { 0x3667 }, 0x00 },
+	{ OV8830_8BIT, { 0x366a }, 0x80 },
+	{ OV8830_8BIT, { 0x366c }, 0x00 },
+	{ OV8830_8BIT, { 0x366d }, 0x00 },
+	{ OV8830_8BIT, { 0x366e }, 0x00 },
+	{ OV8830_8BIT, { 0x366f }, 0x20 },
+	{ OV8830_8BIT, { 0x3680 }, 0xb5 },
+	{ OV8830_8BIT, { 0x3681 }, 0x00 },
+	{ OV8830_8BIT, { 0x3701 }, 0x14 },
+	{ OV8830_8BIT, { 0x3702 }, 0x50 },
+	{ OV8830_8BIT, { 0x3703 }, 0x8c },
+	{ OV8830_8BIT, { 0x3704 }, 0x68 },
+	{ OV8830_8BIT, { 0x3705 }, 0x02 },
+	{ OV8830_8BIT, { 0x3709 }, 0x43 },
+	{ OV8830_8BIT, { 0x370a }, 0x00 },
+	{ OV8830_8BIT, { 0x370b }, 0x20 },
+	{ OV8830_8BIT, { 0x370c }, 0x0c },
+	{ OV8830_8BIT, { 0x370d }, 0x11 },
+	{ OV8830_8BIT, { 0x370e }, 0x00 },
+	{ OV8830_8BIT, { 0x370f }, 0x00 },
+	{ OV8830_8BIT, { 0x3710 }, 0x00 },
+	{ OV8830_8BIT, { 0x371c }, 0x01 },
+	{ OV8830_8BIT, { 0x371f }, 0x0c },
+	{ OV8830_8BIT, { 0x3721 }, 0x00 },
+	{ OV8830_8BIT, { 0x3724 }, 0x10 },
+	{ OV8830_8BIT, { 0x3726 }, 0x00 },
+	{ OV8830_8BIT, { 0x372a }, 0x01 },
+	{ OV8830_8BIT, { 0x3730 }, 0x18 },
+	{ OV8830_8BIT, { 0x3738 }, 0x22 },
+	{ OV8830_8BIT, { 0x3739 }, 0xd0 },
+	{ OV8830_8BIT, { 0x373a }, 0x50 },
+	{ OV8830_8BIT, { 0x373b }, 0x02 },
+	{ OV8830_8BIT, { 0x373c }, 0x20 },
+	{ OV8830_8BIT, { 0x373f }, 0x02 },
+	{ OV8830_8BIT, { 0x3740 }, 0x42 },
+	{ OV8830_8BIT, { 0x3741 }, 0x02 },
+	{ OV8830_8BIT, { 0x3742 }, 0x18 },
+	{ OV8830_8BIT, { 0x3743 }, 0x01 },
+	{ OV8830_8BIT, { 0x3744 }, 0x02 },
+	{ OV8830_8BIT, { 0x3747 }, 0x10 },
+	{ OV8830_8BIT, { 0x374c }, 0x04 },
+	{ OV8830_8BIT, { 0x3751 }, 0xf0 },
+	{ OV8830_8BIT, { 0x3752 }, 0x00 },
+	{ OV8830_8BIT, { 0x3753 }, 0x00 },
+	{ OV8830_8BIT, { 0x3754 }, 0xc0 },
+	{ OV8830_8BIT, { 0x3755 }, 0x00 },
+	{ OV8830_8BIT, { 0x3756 }, 0x1a },
+	{ OV8830_8BIT, { 0x3758 }, 0x00 },
+	{ OV8830_8BIT, { 0x3759 }, 0x0f },
+	{ OV8830_8BIT, { 0x375c }, 0x04 },
+	{ OV8830_8BIT, { 0x3767 }, 0x01 },
+	{ OV8830_8BIT, { 0x376b }, 0x44 },
+	{ OV8830_8BIT, { 0x3774 }, 0x10 },
+	{ OV8830_8BIT, { 0x3776 }, 0x00 },
+	{ OV8830_8BIT, { 0x377f }, 0x08 },
+	{ OV8830_8BIT, { 0x3780 }, 0x22 },
+	{ OV8830_8BIT, { 0x3781 }, 0xcc },
+	{ OV8830_8BIT, { 0x3784 }, 0x2c },
+	{ OV8830_8BIT, { 0x3785 }, 0x08 },
+	{ OV8830_8BIT, { 0x3786 }, 0x16 },
+	{ OV8830_8BIT, { 0x378f }, 0xf5 },
+	{ OV8830_8BIT, { 0x3791 }, 0xb0 },
+	{ OV8830_8BIT, { 0x3795 }, 0x00 },
+	{ OV8830_8BIT, { 0x3796 }, 0x94 },
+	{ OV8830_8BIT, { 0x3797 }, 0x11 },
+	{ OV8830_8BIT, { 0x3798 }, 0x30 },
+	{ OV8830_8BIT, { 0x3799 }, 0x41 },
+	{ OV8830_8BIT, { 0x379a }, 0x07 },
+	{ OV8830_8BIT, { 0x379b }, 0xb0 },
+	{ OV8830_8BIT, { 0x379c }, 0x0c },
+	{ OV8830_8BIT, { 0x37c5 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c6 }, 0xa0 },
+	{ OV8830_8BIT, { 0x37c7 }, 0x00 },
+	{ OV8830_8BIT, { 0x37c9 }, 0x00 },
+	{ OV8830_8BIT, { 0x37ca }, 0x00 },
+	{ OV8830_8BIT, { 0x37cb }, 0x00 },
+	{ OV8830_8BIT, { 0x37cc }, 0x00 },
+	{ OV8830_8BIT, { 0x37cd }, 0x00 },
+	{ OV8830_8BIT, { 0x37ce }, 0x01 },
+	{ OV8830_8BIT, { 0x37cf }, 0x00 },
+	{ OV8830_8BIT, { 0x37d1 }, 0x01 },
+	{ OV8830_8BIT, { 0x37de }, 0x00 },
+	{ OV8830_8BIT, { 0x37df }, 0x00 },
+	{ OV8830_8BIT, { 0x3810 }, 0x00 },
+	{ OV8830_8BIT, { 0x3811 }, 0x04 },
+	{ OV8830_8BIT, { 0x3812 }, 0x00 },
+	{ OV8830_8BIT, { 0x3813 }, 0x04 },
+	{ OV8830_8BIT, { 0x3823 }, 0x00 },
+	{ OV8830_8BIT, { 0x3824 }, 0x00 },
+	{ OV8830_8BIT, { 0x3825 }, 0x00 },
+	{ OV8830_8BIT, { 0x3826 }, 0x00 },
+	{ OV8830_8BIT, { 0x3827 }, 0x00 },
+	{ OV8830_8BIT, { 0x382a }, 0x04 },
+	{ OV8830_8BIT, { 0x3a04 }, 0x09 },
+	{ OV8830_8BIT, { 0x3a05 }, 0xa9 },
+	{ OV8830_8BIT, { 0x3a06 }, 0x00 },
+	{ OV8830_8BIT, { 0x3a07 }, 0xf8 },
+	{ OV8830_8BIT, { 0x3b00 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b02 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b03 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b04 }, 0x00 },
+	{ OV8830_8BIT, { 0x3b05 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d00 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d01 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d02 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d03 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d04 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d05 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d06 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d07 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d08 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d09 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0a }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0b }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0c }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0d }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0e }, 0x00 },
+	{ OV8830_8BIT, { 0x3d0f }, 0x00 },
+	{ OV8830_8BIT, { 0x3d80 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d81 }, 0x00 },
+	{ OV8830_8BIT, { 0x3d84 }, 0x00 },
+	{ OV8830_8BIT, { 0x4000 }, 0x18 },
+	{ OV8830_8BIT, { 0x4001 }, 0x04 },
+	{ OV8830_8BIT, { 0x4002 }, 0x45 },
+	{ OV8830_8BIT, { 0x4005 }, 0x18 },
+	{ OV8830_8BIT, { 0x4006 }, 0x20 },
+	{ OV8830_8BIT, { 0x4008 }, 0x24 },
+	{ OV8830_8BIT, { 0x4009 }, 0x10 },
+	{ OV8830_8BIT, { 0x4100 }, 0x17 },
+	{ OV8830_8BIT, { 0x4101 }, 0x03 },
+	{ OV8830_8BIT, { 0x4102 }, 0x04 },
+	{ OV8830_8BIT, { 0x4103 }, 0x03 },
+	{ OV8830_8BIT, { 0x4104 }, 0x5a },
+	{ OV8830_8BIT, { 0x4307 }, 0x30 },
+	{ OV8830_8BIT, { 0x4315 }, 0x00 },
+	{ OV8830_8BIT, { 0x4511 }, 0x05 },
+	{ OV8830_8BIT, { 0x4512 }, 0x01 }, /* Binning option Average */
+	{ OV8830_8BIT, { 0x4805 }, 0x21 },
+	{ OV8830_8BIT, { 0x4806 }, 0x00 },
+	{ OV8830_8BIT, { 0x481f }, 0x36 },
+	{ OV8830_8BIT, { 0x4831 }, 0x6c },
+	{ OV8830_8BIT, { 0x4837 }, 0x0c }, /* MIPI Global timing */
+	{ OV8830_8BIT, { 0x4a00 }, 0xaa },
+	{ OV8830_8BIT, { 0x4a03 }, 0x01 },
+	{ OV8830_8BIT, { 0x4a05 }, 0x08 },
+	{ OV8830_8BIT, { 0x4a0a }, 0x88 },
+	{ OV8830_8BIT, { 0x4d03 }, 0xbb },
+	{ OV8830_8BIT, { 0x5000 }, 0x06 },
+	{ OV8830_8BIT, { 0x5001 }, 0x01 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 },
+	{ OV8830_8BIT, { 0x5003 }, 0x20 },
+	{ OV8830_8BIT, { 0x5013 }, 0x00 },
+	{ OV8830_8BIT, { 0x5046 }, 0x4a },
+	{ OV8830_8BIT, { 0x5780 }, 0x1c },
+	{ OV8830_8BIT, { 0x5786 }, 0x20 },
+	{ OV8830_8BIT, { 0x5787 }, 0x10 },
+	{ OV8830_8BIT, { 0x5788 }, 0x18 },
+	{ OV8830_8BIT, { 0x578a }, 0x04 },
+	{ OV8830_8BIT, { 0x578b }, 0x02 },
+	{ OV8830_8BIT, { 0x578c }, 0x02 },
+	{ OV8830_8BIT, { 0x578e }, 0x06 },
+	{ OV8830_8BIT, { 0x578f }, 0x02 },
+	{ OV8830_8BIT, { 0x5790 }, 0x02 },
+	{ OV8830_8BIT, { 0x5791 }, 0xff },
+	{ OV8830_8BIT, { 0x5a08 }, 0x02 },
+	{ OV8830_8BIT, { 0x5e00 }, 0x00 },
+	{ OV8830_8BIT, { 0x5e10 }, 0x0c },
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+/*****************************OV8835 STILL & PREVIEW**************************/
+
+static const struct ov8830_reg ov8835_cif_mode[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 172, 20, 3123, 2459 2944x2432 */
+	{ OV8830_8BIT, { 0x3801 }, 0xac },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x14 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0x33 },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0x9b },
+	{ OV8830_8BIT, { 0x3808 }, 0x01 }, /* 368x304 O/p Binning+Scaling */
+	{ OV8830_8BIT, { 0x3809 }, 0x70 },
+	{ OV8830_8BIT, { 0x380a }, 0x01 },
+	{ OV8830_8BIT, { 0x380b }, 0x30 },
+	{ OV8830_8BIT, { 0x3814 }, 0x71 },
+	{ OV8830_8BIT, { 0x3815 }, 0x71 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0xa0 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+
+static struct ov8830_reg const ov8835_binning_4x3_mode[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 4, 3291, 2475, 3288X2472 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x06 }, /* Output size: 1632x1224 */
+	{ OV8830_8BIT, { 0x3809 }, 0x60 },
+	{ OV8830_8BIT, { 0x380a }, 0x04 },
+	{ OV8830_8BIT, { 0x380b }, 0xc8 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Vertical Binning 0n */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f }, /* Horizontal Binning 0n */
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0xa0 },
+	{ OV8830_8BIT, { 0x5002 }, 0x00 }, /* Scale disable */
+	{ OV8830_8BIT, { 0x5041 }, 0x84 }, /* Set manual scale and disable */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8835_binning_16x9_mode[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 310, 3291, 2169 3288x1860 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x36 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x79 },
+	{ OV8830_8BIT, { 0x3808 }, 0x06 }, /* Output size 1632x 916 */
+	{ OV8830_8BIT, { 0x3809 }, 0x60 },
+	{ OV8830_8BIT, { 0x380a }, 0x03 },
+	{ OV8830_8BIT, { 0x380b }, 0x94 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x08 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0x90 },
+	{ OV8830_8BIT, { 0x5002 }, 0x00 }, /* Scale disable */
+	{ OV8830_8BIT, { 0x5041 }, 0x84 }, /* Set manual scale and disable */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8835_8M_mode[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe3 }, /* Binning Related */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 4, 3291, 2475, 3288X2472 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x0c }, /* Output size 3280x2464 */
+	{ OV8830_8BIT, { 0x3809 }, 0xd0 },
+	{ OV8830_8BIT, { 0x380a }, 0x09 },
+	{ OV8830_8BIT, { 0x380b }, 0xa0 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_8BIT, { 0x4004 }, 0x08 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0xa0 },
+	{ OV8830_8BIT, { 0x5002 }, 0x00 }, /* Scale disable */
+	{ OV8830_8BIT, { 0x5041 }, 0x84 }, /* Set manual scale and disable */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8835_6M_mode[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe3 }, /* Binning Related */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 310, 3291, 2169 3288x1860 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x36 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x79 },
+	{ OV8830_8BIT, { 0x3808 }, 0x0c }, /* Output size 3280x1852 */
+	{ OV8830_8BIT, { 0x3809 }, 0xd0 },
+	{ OV8830_8BIT, { 0x380a }, 0x07 },
+	{ OV8830_8BIT, { 0x380b }, 0x3c },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 }, /* Binning off */
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_8BIT, { 0x4004 }, 0x08 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0x90 },
+	{ OV8830_8BIT, { 0x5002 }, 0x00 }, /* Scale disable */
+	{ OV8830_8BIT, { 0x5041 }, 0x84 }, /* Set manual scale and disable */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+/***************** OV8835 VIDEO ***************************************/
+
+static const struct ov8830_reg ov8835_video_qcif[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 180, 16,3115, 2463 2928x2440 */
+	{ OV8830_8BIT, { 0x3801 }, 0xb4 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x10 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0x2b },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0x9f },
+	{ OV8830_8BIT, { 0x3808 }, 0x00 }, /* O/p Binning + Scaling 192x160 */
+	{ OV8830_8BIT, { 0x3809 }, 0xc0 },
+	{ OV8830_8BIT, { 0x380a }, 0x00 },
+	{ OV8830_8BIT, { 0x380b }, 0xa0 },
+	{ OV8830_8BIT, { 0x3814 }, 0x71 },
+	{ OV8830_8BIT, { 0x3815 }, 0x71 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0xa0 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8835_video_qvga_dvs[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 4, 3291, 2475 3288x2472 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x01 }, /* 408x308 Binning+Scaling */
+	{ OV8830_8BIT, { 0x3809 }, 0x98 },
+	{ OV8830_8BIT, { 0x380a }, 0x01 },
+	{ OV8830_8BIT, { 0x380b }, 0x34 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0xa0 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8835_video_vga_dvs[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 4, 3291, 2475 3288x2472 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x00 },
+	{ OV8830_8BIT, { 0x3803 }, 0x04 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x09 },
+	{ OV8830_8BIT, { 0x3807 }, 0xab },
+	{ OV8830_8BIT, { 0x3808 }, 0x03 }, /* 820x616 Binning + Scaling */
+	{ OV8830_8BIT, { 0x3809 }, 0x34 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0x68 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0xa0 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_reg const ov8835_video_480p_dvs[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x01 },
+	{ OV8830_8BIT, { 0x3801 }, 0x08 },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x40 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0b },
+	{ OV8830_8BIT, { 0x3805 }, 0xd5 },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x73 }, /* TODO! 2766 x 1844 */
+	{ OV8830_8BIT, { 0x3808 }, 0x03 }, /* 936x602 Binning + Scaling */
+	{ OV8830_8BIT, { 0x3809 }, 0xa8 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0x5a },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 }, /* Binning on */
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0xa0 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_reg const ov8835_video_800x600_dvs[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x01 }, /* 414, 310, 2881, 2169 2468x1860 */
+	{ OV8830_8BIT, { 0x3801 }, 0x9e },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x36 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0b },
+	{ OV8830_8BIT, { 0x3805 }, 0x41 },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x79 },
+	{ OV8830_8BIT, { 0x3808 }, 0x03 }, /* O/p 976x736 Bin+Scale */
+	{ OV8830_8BIT, { 0x3809 }, 0xD0 },
+	{ OV8830_8BIT, { 0x380a }, 0x02 },
+	{ OV8830_8BIT, { 0x380b }, 0xe0 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0x90 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_reg const ov8835_video_720p_dvs[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe6 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 310, 3291, 2169 3288x1860 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x36 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x79 },
+	{ OV8830_8BIT, { 0x3808 }, 0x06 }, /* O/p 1568*880 Bin+Scale */
+	{ OV8830_8BIT, { 0x3809 }, 0x20 },
+	{ OV8830_8BIT, { 0x380a }, 0x03 },
+	{ OV8830_8BIT, { 0x380b }, 0x70 },
+	{ OV8830_8BIT, { 0x3814 }, 0x31 },
+	{ OV8830_8BIT, { 0x3815 }, 0x31 },
+	{ OV8830_8BIT, { 0x3820 }, 0x11 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0f },
+	{ OV8830_8BIT, { 0x4004 }, 0x02 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0x90 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static const struct ov8830_reg ov8835_video_1080p_dvs[] = {
+	{ OV8830_8BIT, { 0x3708 }, 0xe3 }, /* Binning Related e6 : e3 */
+	{ OV8830_8BIT, { 0x3800 }, 0x00 }, /* 4, 310, 3291, 2169 3288x1860 */
+	{ OV8830_8BIT, { 0x3801 }, 0x04 },
+	{ OV8830_8BIT, { 0x3802 }, 0x01 },
+	{ OV8830_8BIT, { 0x3803 }, 0x36 },
+	{ OV8830_8BIT, { 0x3804 }, 0x0c },
+	{ OV8830_8BIT, { 0x3805 }, 0xdb },
+	{ OV8830_8BIT, { 0x3806 }, 0x08 },
+	{ OV8830_8BIT, { 0x3807 }, 0x79 },
+	{ OV8830_8BIT, { 0x3808 }, 0x09 }, /* 2336x1336 DVS O/p */
+	{ OV8830_8BIT, { 0x3809 }, 0x20 },
+	{ OV8830_8BIT, { 0x380a }, 0x05 },
+	{ OV8830_8BIT, { 0x380b }, 0x38 },
+	{ OV8830_8BIT, { 0x3814 }, 0x11 },
+	{ OV8830_8BIT, { 0x3815 }, 0x11 },
+	{ OV8830_8BIT, { 0x3820 }, 0x10 },
+	{ OV8830_8BIT, { 0x3821 }, 0x0e },
+	{ OV8830_8BIT, { 0x4004 }, 0x08 }, /* BLC No. of blacklines used. */
+	{ OV8830_8BIT, { 0x404f }, 0x90 },
+	{ OV8830_8BIT, { 0x5002 }, 0x80 }, /* Scale enable */
+	{ OV8830_8BIT, { 0x5041 }, 0x04 }, /* Auto scale */
+	{ OV8830_TOK_TERM, {0}, 0}
+};
+
+static struct ov8830_resolution ov8835_res_preview[] = {
+	{
+		 .desc = "ov8835_cif_mode_for_preview",
+		 .width = 368,
+		 .height = 304,
+		 .used = 0,
+		 .regs = ov8835_cif_mode,
+		 .bin_factor_x = 2,
+		 .bin_factor_y = 2,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_binning_16x9_mode_for_preview",
+		 .width = 1632,
+		 .height = 916,
+		 .used = 0,
+		 .regs = ov8835_binning_16x9_mode,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4496,
+				 .lines_per_frame = 2064,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_bnning_4x3_mode",
+		 .width = 1632,
+		 .height = 1224,
+		 .used = 0,
+		 .regs = ov8835_binning_4x3_mode,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4400,
+				 .lines_per_frame = 2100,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_6M_mode_for_cont_capture",
+		 .width = 3280,
+		 .height = 1852,
+		 .used = 0,
+		 .regs = ov8835_6M_mode,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4496,
+				 .lines_per_frame = 2064,
+			},
+			{
+				 .fps = 24,
+				 .pixels_per_line = 5496,
+				 .lines_per_frame = 2064,
+			},
+			{
+				 .fps = 19,
+				 .pixels_per_line = 5800,
+				 .lines_per_frame = 2500,
+			}
+		},
+	},
+	{
+		.desc = "ov8835_8M_mode_for_cont_capture",
+		.width = 3280,
+		.height = 2464,
+		.used = 0,
+		.regs = ov8835_8M_mode,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options = {
+			{
+				.fps = 25,
+				.pixels_per_line = 4450,
+				.lines_per_frame = 2500,
+			},
+			{
+				.fps = 19,
+				.pixels_per_line = 5800,
+				.lines_per_frame = 2500,
+			},
+			{
+			}
+		},
+	},
+};
+
+static struct ov8830_resolution ov8835_res_still[] = {
+	{
+		 .desc = "ov8835_cif_mode_for_still",
+		 .width = 368,
+		 .height = 304,
+		 .used = 0,
+		 .regs = ov8835_cif_mode,
+		 .bin_factor_x = 2,
+		 .bin_factor_y = 2,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 6814,
+				 .lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_binning_16x9_mode_for_still",
+		 .width = 1632,
+		 .height = 916,
+		 .used = 0,
+		 .regs = ov8835_binning_16x9_mode,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				.fps = 15,
+				.pixels_per_line = 6814,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_bnning_4x3_mode_for_still",
+		 .width = 1632,
+		 .height = 1224,
+		 .used = 0,
+		 .regs = ov8835_binning_4x3_mode,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				.fps = 15,
+				.pixels_per_line = 6474,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_6M_mode_for_still",
+		 .width = 3280,
+		 .height = 1852,
+		 .used = 0,
+		 .regs = ov8835_6M_mode,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				.fps = 15,
+				.pixels_per_line = 6814,
+				.lines_per_frame = 2724,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8835_cont_cap_8M_for_still",
+		.width = 3280,
+		.height = 2464,
+		.used = 0,
+		.regs = ov8835_8M_mode,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options = {
+			{
+				.fps = 15,
+				.pixels_per_line = 6474,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+};
+
+static struct ov8830_resolution ov8835_res_video[] = {
+	{
+		 .desc = "ov8835_video_qcif",
+		 .width = 192,
+		 .height = 160,
+		 .used = 0,
+		 .regs = ov8835_video_qcif,
+		 .bin_factor_x = 2,
+		 .bin_factor_y = 2,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_video_cif_dvs",
+		 .width = 368,
+		 .height = 304,
+		 .used = 0,
+		 .regs = ov8835_cif_mode,
+		 .bin_factor_x = 2,
+		 .bin_factor_y = 2,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_video_qvga_dvs",
+		 .width = 408,
+		 .height = 308,
+		 .used = 0,
+		 .regs = ov8835_video_qvga_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_video_vga_dvs",
+		 .width = 820,
+		 .height = 616,
+		 .used = 0,
+		 .regs = ov8835_video_vga_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8835_video_480p_dvs",
+		.width = 936,
+		.height = 602,
+		.used = 0,
+		.regs = ov8835_video_480p_dvs,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.skip_frames = 1,
+		.fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_video_800x600_dvs",
+		 .width = 976,
+		 .height = 736,
+		 .used = 0,
+		 .regs = ov8835_video_800x600_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_video_720p_dvs",
+		 .width = 1568,
+		 .height = 880,
+		 .used = 0,
+		 .regs = ov8835_video_720p_dvs,
+		 .bin_factor_x = 1,
+		 .bin_factor_y = 1,
+		 .skip_frames = 1,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 5458,
+				 .lines_per_frame = 1700,
+			},
+			{
+			}
+		},
+	},
+	{
+		 .desc = "ov8835_video_1080p_dvs",
+		 .width = 2336,
+		 .height = 1336,
+		 .used = 0,
+		 .regs = ov8835_video_1080p_dvs,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 2,
+		 .fps_options = {
+			{
+				 .fps = 30,
+				 .pixels_per_line = 4300,
+				 .lines_per_frame = 2158,
+			},
+			{
+				 .fps = 24,
+				 .pixels_per_line = 5300,
+				 .lines_per_frame = 2158,
+			},
+
+			{
+			}
+		},
+	},
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
new file mode 100644
index 0000000..527bf3a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.c
@@ -0,0 +1,1901 @@
+/*
+ * Support for OmniVision ov8858 camera sensor.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include "ov8858.h"
+
+static int
+ov8858_read_reg(struct i2c_client *client, u16 len, u16 reg, u16 *val)
+{
+	struct i2c_msg msg[2];
+	u16 data[OV8858_SHORT_MAX];
+	int err, i;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	/* @len should be even when > 1 */
+	if (len > OV8858_BYTE_MAX) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0, sizeof(msg));
+	memset(data, 0, sizeof(data));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
+
+	msg[1].addr = client->addr;
+	msg[1].len = len;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (u8 *)data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		goto error;
+	}
+
+	/* high byte comes first */
+	if (len == OV8858_8BIT) {
+		*val = (u8)data[0];
+	} else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			val[i] = be16_to_cpu(data[i]);
+	}
+
+	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int ov8858_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int
+ov8858_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no adapter\n", __func__);
+		return -ENODEV;
+	}
+
+	if (data_length != OV8858_8BIT && data_length != OV8858_16BIT) {
+		dev_err(&client->dev, "%s error, invalid length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == OV8858_8BIT) {
+		data[2] = (u8)(val);
+	} else {
+		/* OV8858_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = be16_to_cpu(val);
+	}
+
+	ret = ov8858_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * ov8858_write_reg_array - Initializes a list of registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __ov8858_flush_reg_array(), __ov8858_buf_reg_array() and
+ * __ov8858_write_reg_is_consecutive() are internal functions to
+ * ov8858_write_reg_array() and should be not used anywhere else.
+ *
+ */
+static int __ov8858_flush_reg_array(struct i2c_client *client,
+				    struct ov8858_write_ctrl *ctrl)
+{
+	u16 size;
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov8858_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __ov8858_buf_reg_array(struct i2c_client *client,
+				  struct ov8858_write_ctrl *ctrl,
+				  const struct ov8858_reg *next)
+{
+	int size;
+	u16 *data16;
+	switch (next->type) {
+	case OV8858_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case OV8858_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->sreg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= OV8858_MAX_WRITE_BUF_SIZE)
+		__ov8858_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int
+__ov8858_write_reg_is_consecutive(struct i2c_client *client,
+				  struct ov8858_write_ctrl *ctrl,
+				  const struct ov8858_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->sreg;
+}
+
+static int ov8858_write_reg_array(struct i2c_client *client,
+				  const struct ov8858_reg *reglist)
+{
+	const struct ov8858_reg *next = reglist;
+	struct ov8858_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != OV8858_TOK_TERM; next++) {
+		switch (next->type & OV8858_TOK_MASK) {
+		case OV8858_TOK_DELAY:
+			err = __ov8858_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceeding
+			 */
+			if (!__ov8858_write_reg_is_consecutive(client,
+							       &ctrl, next)) {
+				err = __ov8858_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __ov8858_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error\n",
+					__func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __ov8858_flush_reg_array(client, &ctrl);
+}
+
+static int __ov8858_min_fps_diff(int fps,
+				 const struct ov8858_fps_setting *fps_list)
+{
+	int diff = INT_MAX;
+	int i;
+
+	if (fps == 0)
+		return 0;
+
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (!fps_list[i].fps)
+			break;
+		if (abs(fps_list[i].fps - fps) < diff)
+			diff = abs(fps_list[i].fps - fps);
+	}
+
+	return diff;
+}
+
+static int __ov8858_nearest_fps_index(int fps,
+				      const struct ov8858_fps_setting *fps_list)
+{
+	int fps_index = 0;
+	int i;
+
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (!fps_list[i].fps)
+			break;
+		if (abs(fps_list[i].fps - fps)
+		    < abs(fps_list[fps_index].fps - fps))
+			fps_index = i;
+	}
+	return fps_index;
+}
+
+static int __ov8858_get_max_fps_index(
+				const struct ov8858_fps_setting *fps_settings)
+{
+	int i;
+	for (i = 0; i < MAX_FPS_OPTIONS_SUPPORTED; i++) {
+		if (fps_settings[i].fps == 0)
+			break;
+	}
+
+	return i - 1;
+}
+
+static int __ov8858_update_frame_timing(struct v4l2_subdev *sd, int exposure,
+					u16 *hts, u16 *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* Increase the VTS to match exposure + 14 */
+	if (exposure > *vts - OV8858_INTEGRATION_TIME_MARGIN)
+		*vts = (u16) exposure + OV8858_INTEGRATION_TIME_MARGIN;
+
+	ret = ov8858_write_reg(client, OV8858_16BIT, OV8858_TIMING_HTS, *hts);
+	if (ret)
+		return ret;
+	return ov8858_write_reg(client, OV8858_16BIT, OV8858_TIMING_VTS, *vts);
+}
+
+static int __ov8858_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
+				 int dig_gain, u16 *hts, u16 *vts)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int exp_val, ret;
+
+	/* Update frame timings. Exposure must be minimum <  vts-14 */
+	ret = __ov8858_update_frame_timing(sd, exposure, hts, vts);
+	if (ret)
+		return ret;
+
+	/* For OV8835, the low 4 bits are fraction bits and must be kept 0 */
+	exp_val = exposure << 4;
+	ret = ov8858_write_reg(client, OV8858_8BIT,
+			       OV8858_LONG_EXPO+2, exp_val & 0xFF);
+	if (ret)
+		return ret;
+
+	ret = ov8858_write_reg(client, OV8858_8BIT,
+			       OV8858_LONG_EXPO+1, (exp_val >> 8) & 0xFF);
+	if (ret)
+		return ret;
+
+	ret = ov8858_write_reg(client, OV8858_8BIT,
+			       OV8858_LONG_EXPO, (exp_val >> 16) & 0x0F);
+	if (ret)
+		return ret;
+
+	/* Digital gain : to all MWB channel gains */
+	if (dig_gain) {
+		ret = ov8858_write_reg(client, OV8858_16BIT,
+				OV8858_MWB_RED_GAIN_H, dig_gain);
+		if (ret)
+			return ret;
+
+		ret = ov8858_write_reg(client, OV8858_16BIT,
+				OV8858_MWB_GREEN_GAIN_H, dig_gain);
+		if (ret)
+			return ret;
+
+		ret = ov8858_write_reg(client, OV8858_16BIT,
+				OV8858_MWB_BLUE_GAIN_H, dig_gain);
+		if (ret)
+			return ret;
+	}
+
+	/* set global gain */
+	return ov8858_write_reg(client, OV8858_8BIT, OV8858_AGC_ADJ, gain);
+}
+
+static int ov8858_set_exposure(struct v4l2_subdev *sd, int exposure, int gain,
+				int dig_gain)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct ov8858_resolution *res;
+	u16 hts, vts;
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	/* Validate exposure:  cannot exceed 16bit value */
+	exposure = clamp_t(int, exposure, 0, OV8858_MAX_EXPOSURE_VALUE);
+
+	/* Validate gain: must not exceed maximum 8bit value */
+	gain = clamp_t(int, gain, 0, OV8858_MAX_GAIN_VALUE);
+
+	/* Validate digital gain: must not exceed 12 bit value*/
+	dig_gain = clamp_t(int, dig_gain, 0, OV8858_MWB_GAIN_MAX);
+
+	/* Group hold is valid only if sensor is streaming. */
+	if (dev->streaming) {
+		ret = ov8858_write_reg_array(client, ov8858_param_hold);
+		if (ret)
+			goto out;
+	}
+
+	res = &dev->curr_res_table[dev->fmt_idx];
+	hts = res->fps_options[dev->fps_index].pixels_per_line;
+	vts = res->fps_options[dev->fps_index].lines_per_frame;
+
+	ret = __ov8858_set_exposure(sd, exposure, gain, dig_gain, &hts, &vts);
+	if (ret)
+		goto out;
+
+	/* Updated the device variable. These are the current values. */
+	dev->gain = gain;
+	dev->exposure = exposure;
+	dev->digital_gain = dig_gain;
+
+out:
+	/* Group hold launch - delayed launch */
+	if (dev->streaming)
+		ret = ov8858_write_reg_array(client, ov8858_param_update);
+
+
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov8858_s_exposure(struct v4l2_subdev *sd,
+			     struct atomisp_exposure *exposure)
+{
+	return ov8858_set_exposure(sd, exposure->integration_time[0],
+				exposure->gain[0], exposure->gain[1]);
+}
+
+static int ov8858_g_priv_int_data(struct v4l2_subdev *sd,
+				  struct v4l2_private_int_data *priv)
+{
+	u32 size;
+	/* TODO: Need to add reading of OTP data here */
+	void *b = NULL; /*le24l042cs_read(v4l2_get_subdevdata(sd), &size);*/
+	int r = 0;
+
+	if (!b)
+		return -EIO;
+
+	if (copy_to_user(priv->data, b, min_t(__u32, priv->size, size)))
+		r = -EFAULT;
+
+	priv->size = size;
+	kfree(b);
+
+	return r;
+}
+
+static int __ov8858_init(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	if (dev->sensor_id == OV8858_ID_DEFAULT)
+		return 0;
+
+	/* Sets the default FPS */
+	dev->fps_index = 0;
+	return ov8858_write_reg_array(client, ov8858_BasicSettings);
+}
+
+static int ov8858_init(struct v4l2_subdev *sd, u32 val)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov8858_init(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static void ov8858_uninit(struct v4l2_subdev *sd)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	dev->exposure = 0;
+	dev->gain     = 0;
+	dev->digital_gain = 0;
+}
+
+static long ov8858_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return ov8858_s_exposure(sd, (struct atomisp_exposure *)arg);
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		return ov8858_g_priv_int_data(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	int ret;
+
+	/* Enable power */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* Enable clock */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* Release reset */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		goto fail_gpio;
+
+	/* Minumum delay is 8192 clock cycles before first i2c transaction,
+	 * which is 1.37 ms at the lowest allowed clock rate 6 MHz */
+	usleep_range(2000, 2500);
+	return 0;
+
+fail_gpio:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "Sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "Failed to set reset line off\n");
+
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int __ov8858_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	int ret, r;
+
+	if (on == 0) {
+		ov8858_uninit(sd);
+		ret = power_down(sd);
+		if (dev->vcm_driver && dev->vcm_driver->power_down) {
+			r = dev->vcm_driver->power_down(sd);
+			if (ret == 0)
+				ret = r;
+		}
+	} else {
+		ret = power_up(sd);
+		if (ret)
+			power_down(sd);
+		if (dev->vcm_driver && dev->vcm_driver->power_up) {
+			ret = dev->vcm_driver->power_up(sd);
+			if (ret) {
+				power_down(sd);
+				return ret;
+			}
+		}
+		return __ov8858_init(sd);
+	}
+
+	return ret;
+}
+
+static int ov8858_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov8858_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	/*
+	 * FIXME: Compatibility with old behaviour: return to preview
+	 * when the device is power cycled.
+	 */
+	if (!ret && on)
+		v4l2_ctrl_s_ctrl(dev->run_mode, ATOMISP_RUN_MODE_PREVIEW);
+
+	return ret;
+}
+
+static int ov8858_g_chip_ident(struct v4l2_subdev *sd,
+			       struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!chip)
+		return -EINVAL;
+
+	v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV8858, 0);
+
+	return 0;
+}
+
+/* Return value of the specified register, first try getting it from
+ * the register list and if not found, get from the sensor via i2c.
+ */
+static int ov8858_get_register(struct v4l2_subdev *sd, int reg,
+			       const struct ov8858_reg *reglist)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct ov8858_reg *next;
+	u16 val;
+
+	/* Try if the values are in the register list */
+	for (next = reglist; next->type != OV8858_TOK_TERM; next++) {
+		if (next->type != OV8858_8BIT) {
+			dev_err(&client->dev, "register not 8-bit\n");
+			return -ENXIO;
+		}
+		if (next->sreg == reg)
+			return next->val;
+	}
+
+	/* If not, read from sensor */
+	if (ov8858_read_reg(client, OV8858_8BIT, reg, &val)) {
+		dev_err(&client->dev, "failed to read register 0x%04X\n", reg);
+		return -EIO;
+	}
+
+	return val;
+}
+
+static int ov8858_get_register_16bit(struct v4l2_subdev *sd, int reg,
+				     const struct ov8858_reg *reglist,
+				     unsigned int *value)
+{
+	int high, low;
+	high = ov8858_get_register(sd, reg, reglist);
+	if (high < 0)
+		return high;
+
+	low = ov8858_get_register(sd, reg + 1, reglist);
+	if (low < 0)
+		return low;
+
+	*value = ((u8) high << 8) | (u8) low;
+	return 0;
+}
+
+static int __ov8858_get_pll1_values(struct v4l2_subdev *sd,
+				    int *value,
+				    const struct ov8858_reg *reglist)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int prediv_idx;
+	unsigned int multiplier;
+	unsigned int sys_prediv;
+	unsigned int prediv_coef[] = {2, 3, 4, 5, 6, 8, 12, 16};
+	int ret;
+
+	ret = ov8858_get_register(sd, OV8858_PLL1_PREDIV0, reglist);
+
+	if (ret < 0)
+		return ret;
+
+	if (ret & OV8858_PLL1_PREDIV0_MASK)
+		*value /= 2;
+
+	ret = ov8858_get_register(sd, OV8858_PLL1_PREDIV, reglist);
+
+	if (ret < 0)
+		return ret;
+
+	prediv_idx = ret & OV8858_PLL1_PREDIV_MASK;
+	*value = *value * 2 / prediv_coef[prediv_idx];
+
+	ret = ov8858_get_register_16bit(sd, OV8858_PLL1_MULTIPLIER, reglist,
+					&multiplier);
+	if (ret < 0)
+		return ret;
+
+	*value *= multiplier & OV8858_PLL1_MULTIPLIER_MASK;
+	ret = ov8858_get_register(sd, OV8858_PLL1_SYS_PRE_DIV, reglist);
+
+	if (ret < 0)
+		return ret;
+
+	sys_prediv = ret & OV8858_PLL1_SYS_PRE_DIV_MASK;
+	*value /= (sys_prediv + 3);
+	ret = ov8858_get_register(sd, OV8858_PLL1_SYS_DIVIDER, reglist);
+
+	if (ret < 0)
+		return ret;
+
+	if (ret & OV8858_PLL1_SYS_DIVIDER_MASK)
+		*value /= 2;
+
+	dev_dbg(&client->dev, "%s: *value: %d\n", __func__, *value);
+
+	return 0;
+}
+
+static int __ov8858_get_pll2a_values(struct v4l2_subdev *sd, int *value,
+				     const struct ov8858_reg *reglist)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int prediv_idx;
+	unsigned int multiplier;
+	unsigned int prediv_coef[] = {2, 3, 4, 5, 6, 8, 12, 16};
+	int ret;
+
+	ret = ov8858_get_register(sd, OV8858_PLL2_PREDIV0, reglist);
+	if (ret < 0)
+		return ret;
+
+	if (ret & OV8858_PLL2_PREDIV0_MASK)
+		*value /= 2;
+
+	ret = ov8858_get_register(sd, OV8858_PLL2_PREDIV, reglist);
+	if (ret < 0)
+		return ret;
+
+	prediv_idx = (ret & OV8858_PLL2_PREDIV_MASK);
+	*value = *value * 2 / prediv_coef[prediv_idx];
+
+	ret = ov8858_get_register_16bit(sd, OV8858_PLL2_MULTIPLIER, reglist,
+					&multiplier);
+	if (ret < 0)
+		return ret;
+
+	*value *= multiplier & OV8858_PLL2_MULTIPLIER_MASK;
+	dev_dbg(&client->dev, "%s: *value: %d\n", __func__, *value);
+
+	return 0;
+}
+static int __ov8858_get_pll2b_values(struct v4l2_subdev *sd, int *value,
+				     const struct ov8858_reg *reglist)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int dac_divider;
+	int ret;
+
+	ret = ov8858_get_register(sd, OV8858_PLL2_DAC_DIVIDER, reglist);
+	if (ret < 0)
+		return ret;
+
+	dac_divider = (ret & OV8858_PLL2_DAC_DIVIDER_MASK) + 1;
+	*value /= dac_divider;
+
+	dev_dbg(&client->dev, "%s: *value: %d\n", __func__, *value);
+
+	return 0;
+}
+static int __ov8858_get_pll2c_values(struct v4l2_subdev *sd, int *value,
+				     const struct ov8858_reg *reglist)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	unsigned int sys_pre_div;
+	unsigned int sys_divider_idx;
+	unsigned int sys_divider_coef[] = {2, 3, 4, 5, 6, 7, 8, 10};
+	int ret;
+
+	ret = ov8858_get_register(sd, OV8858_PLL2_SYS_PRE_DIV, reglist);
+	if (ret < 0)
+		return ret;
+
+	sys_pre_div = (ret & OV8858_PLL2_SYS_PRE_DIV_MASK) + 1;
+	*value /= sys_pre_div;
+
+	ret = ov8858_get_register(sd, OV8858_PLL2_SYS_DIVIDER, reglist);
+	if (ret < 0)
+		return ret;
+
+	sys_divider_idx = ret & OV8858_PLL2_SYS_DIVIDER_MASK;
+	*value *= 2 /  sys_divider_coef[sys_divider_idx];
+
+	dev_dbg(&client->dev, "%s: *value: %d\n", __func__, *value);
+
+	return 0;
+}
+
+static int ov8858_get_intg_factor(struct v4l2_subdev *sd,
+				  struct camera_mipi_info *info,
+				  const struct ov8858_reg *reglist)
+{
+	const unsigned int ext_clk = 19200000; /* Hz */
+	struct atomisp_sensor_mode_data *m = &info->data;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct device *d = &client->dev;
+	const struct ov8858_resolution *res =
+				&dev->curr_res_table[dev->fmt_idx];
+	unsigned int pll_sclksel1;
+	unsigned int pll_sclksel2;
+	unsigned int sys_pre_div;
+	unsigned int sclk_pdiv;
+	unsigned int sclk = ext_clk;
+	int ret;
+
+	memset(&info->data, 0, sizeof(info->data));
+
+	ret = ov8858_get_register(sd, OV8858_PLL_SCLKSEL1, reglist);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(d, "%s: OV8858_PLL_SCLKSEL1: 0x%02x\n", __func__, ret);
+	pll_sclksel1 = ret & OV8858_PLL_SCLKSEL1_MASK;
+
+	ret = ov8858_get_register(sd, OV8858_PLL_SCLKSEL2, reglist);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(d, "%s: OV8858_PLL_SCLKSEL2: 0x%02x\n", __func__, ret);
+	pll_sclksel2 = ret & OV8858_PLL_SCLKSEL2_MASK;
+
+	if (pll_sclksel2) {
+		ret = __ov8858_get_pll2a_values(sd, &sclk, reglist);
+		if (ret < 0)
+			return ret;
+		ret = __ov8858_get_pll2b_values(sd, &sclk, reglist);
+		if (ret < 0)
+			return ret;
+	} else if (pll_sclksel1) {
+		ret = __ov8858_get_pll2a_values(sd, &sclk, reglist);
+		if (ret < 0)
+			return ret;
+		ret = __ov8858_get_pll2c_values(sd, &sclk, reglist);
+		if (ret < 0)
+			return ret;
+	} else {
+		ret = __ov8858_get_pll1_values(sd, &sclk, reglist);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ov8858_get_register(sd, OV8858_SRB_HOST_INPUT_DIS, reglist);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(d, "%s: OV8858_SRB_HOST_INPUT_DIS: 0x%02x\n", __func__, ret);
+
+	sys_pre_div = ret & OV8858_SYS_PRE_DIV_MASK;
+	sys_pre_div >>= OV8858_SYS_PRE_DIV_OFFSET;
+
+	if (sys_pre_div == 1)
+		sclk /= 2;
+	else if (sys_pre_div == 2)
+		sclk /= 4;
+
+	sclk_pdiv = ret & OV8858_SCLK_PDIV_MASK;
+	sclk_pdiv >>= OV8858_SCLK_PDIV_OFFSET;
+
+	if (sclk_pdiv > 1)
+		sclk /= sclk_pdiv;
+
+	dev_dbg(d, "%s: sclk: %d\n", __func__, sclk);
+
+	m->vt_pix_clk_freq_mhz = sclk;
+
+	/* HTS and VTS */
+	m->frame_length_lines =
+			res->fps_options[dev->fps_index].lines_per_frame;
+	m->line_length_pck = res->fps_options[dev->fps_index].pixels_per_line;
+
+	m->coarse_integration_time_min = 0;
+	m->coarse_integration_time_max_margin = OV8858_INTEGRATION_TIME_MARGIN;
+
+	/* OV Sensor do not use fine integration time. */
+	m->fine_integration_time_min = 0;
+	m->fine_integration_time_max_margin = 0;
+
+	/*
+	 * read_mode indicate whether binning is used for calculating
+	 * the correct exposure value from the user side. So adapt the
+	 * read mode values accordingly.
+	 */
+	m->read_mode = res->bin_factor_x ?
+		OV8858_READ_MODE_BINNING_ON : OV8858_READ_MODE_BINNING_OFF;
+
+	ret = ov8858_get_register(sd, OV8858_H_INC_ODD, res->regs);
+	if (ret < 0)
+		return ret;
+	m->binning_factor_x = (ret + 1) / 2;
+
+	ret = ov8858_get_register(sd, OV8858_V_INC_ODD, res->regs);
+	if (ret < 0)
+		return ret;
+	m->binning_factor_y = (ret + 1) / 2;
+
+	/* Get the cropping and output resolution to ISP for this mode. */
+	ret =  ov8858_get_register_16bit(sd, OV8858_HORIZONTAL_START_H,
+		res->regs, &m->crop_horizontal_start);
+	if (ret)
+		return ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_VERTICAL_START_H,
+		res->regs, &m->crop_vertical_start);
+	if (ret)
+		return ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_HORIZONTAL_END_H,
+		res->regs, &m->crop_horizontal_end);
+	if (ret)
+		return ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_VERTICAL_END_H,
+		res->regs, &m->crop_vertical_end);
+	if (ret)
+		return ret;
+
+	ret = ov8858_get_register_16bit(sd, OV8858_HORIZONTAL_OUTPUT_SIZE_H,
+		res->regs, &m->output_width);
+	if (ret)
+		return ret;
+
+	return ov8858_get_register_16bit(sd, OV8858_VERTICAL_OUTPUT_SIZE_H,
+		res->regs, &m->output_height);
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+/* tune this value so that the DVS resolutions get selected properly,
+ * but make sure 16:9 does not match 4:3.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 500
+static int distance(struct ov8858_resolution const *res, const u32 w,
+		    const u32 h)
+{
+	unsigned int w_ratio = ((res->width<<13)/w);
+	unsigned int h_ratio = ((res->height<<13)/h);
+	int match   = abs(((w_ratio<<13)/h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) ||
+	    (h_ratio < (int)8192) || (match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/*
+ * Returns the nearest higher resolution index.
+ * @w: width
+ * @h: height
+ * matching is done based on enveloping resolution and
+ * aspect ratio. If the aspect ratio cannot be matched
+ * to any index, -1 is returned.
+ */
+static int nearest_resolution_index(struct v4l2_subdev *sd, int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int fps_diff;
+	int min_fps_diff = INT_MAX;
+	int min_dist = INT_MAX;
+	const struct ov8858_resolution *tmp_res = NULL;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	for (i = 0; i < dev->entries_curr_table; i++) {
+		tmp_res = &dev->curr_res_table[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+		if (dist == min_dist) {
+			fps_diff = __ov8858_min_fps_diff(dev->fps,
+						tmp_res->fps_options);
+			if (fps_diff < min_fps_diff) {
+				min_fps_diff = fps_diff;
+				idx = i;
+			}
+		}
+	}
+	return idx;
+}
+
+static int __ov8858_try_mbus_fmt(struct v4l2_subdev *sd,
+				 struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	if (!fmt)
+		return -EINVAL;
+
+	if ((fmt->width > OV8858_RES_WIDTH_MAX) ||
+	    (fmt->height > OV8858_RES_HEIGHT_MAX)) {
+		fmt->width = OV8858_RES_WIDTH_MAX;
+		fmt->height = OV8858_RES_HEIGHT_MAX;
+	} else {
+		idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 * resolutions. If it fails, it means the requested resolution
+		 * is higher than we can support. Fallback to highest possible
+		 * resolution in this case.
+		 */
+		if (idx == -1)
+			idx = dev->entries_curr_table - 1;
+
+		fmt->width = dev->curr_res_table[idx].width;
+		fmt->height = dev->curr_res_table[idx].height;
+	}
+
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int ov8858_try_mbus_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	int r;
+
+	mutex_lock(&dev->input_lock);
+	r = __ov8858_try_mbus_fmt(sd, fmt);
+	mutex_unlock(&dev->input_lock);
+
+	return r;
+}
+
+static int ov8858_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct camera_mipi_info *ov8858_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct ov8858_resolution *res;
+	int ret;
+
+	ov8858_info = v4l2_get_subdev_hostdata(sd);
+	if (ov8858_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = __ov8858_try_mbus_fmt(sd, fmt);
+	if (ret)
+		goto out;
+
+	dev->fmt_idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+	if (dev->fmt_idx == -1) {
+		ret = -EINVAL;
+		goto out;
+	}
+	res = &dev->curr_res_table[dev->fmt_idx];
+
+	/* Adjust the FPS selection based on the resolution selected */
+	dev->fps_index = __ov8858_nearest_fps_index(dev->fps, res->fps_options);
+	dev->fps = res->fps_options[dev->fps_index].fps;
+	dev->regs = res->fps_options[dev->fps_index].regs;
+	if (!dev->regs)
+		dev->regs = res->regs;
+
+	ret = ov8858_write_reg_array(client, dev->regs);
+	if (ret)
+		goto out;
+
+	dev->pixels_per_line = res->fps_options[dev->fps_index].pixels_per_line;
+	dev->lines_per_frame = res->fps_options[dev->fps_index].lines_per_frame;
+
+	ret = __ov8858_set_exposure(sd, dev->exposure, dev->gain,
+				    dev->digital_gain, &dev->pixels_per_line,
+				    &dev->lines_per_frame);
+	if (ret)
+		goto out;
+
+	ret = ov8858_get_intg_factor(sd, ov8858_info, dev->regs);
+
+out:
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov8858_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fmt->width = dev->curr_res_table[dev->fmt_idx].width;
+	fmt->height = dev->curr_res_table[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov8858_detect(struct i2c_client *client, u16 *id)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 id_hi = 0;
+	u16 id_low = 0;
+	int ret;
+	/* i2c check */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = ov8858_read_reg(client, OV8858_8BIT, OV8858_CHIP_ID_HIGH, &id_hi);
+	if (ret)
+		return ret;
+	ret = ov8858_read_reg(client, OV8858_8BIT, OV8858_CHIP_ID_LOW, &id_low);
+	if (ret)
+		return ret;
+	*id = (id_hi << 8) | id_low;
+
+	dev_info(&client->dev, "%s: chip_id = 0x%4.4x\n", __func__, *id);
+	if (*id != OV8858_CHIP_ID)
+		return -ENODEV;
+
+	/* Stream off now. */
+	return ov8858_write_reg(client, OV8858_8BIT, OV8858_STREAM_MODE, 0);
+}
+
+static void __ov8858_print_timing(struct v4l2_subdev *sd)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 width = dev->curr_res_table[dev->fmt_idx].width;
+	u16 height = dev->curr_res_table[dev->fmt_idx].height;
+
+	dev_dbg(&client->dev, "Dump imx timing in stream on:\n");
+	dev_dbg(&client->dev, "width: %d:\n", width);
+	dev_dbg(&client->dev, "height: %d:\n", height);
+	dev_dbg(&client->dev, "pixels_per_line: %d:\n", dev->pixels_per_line);
+	dev_dbg(&client->dev, "line per frame: %d:\n", dev->lines_per_frame);
+	dev_dbg(&client->dev, "pix freq: %d:\n", dev->vt_pix_clk_freq_mhz);
+	dev_dbg(&client->dev, "init fps: %d:\n", dev->vt_pix_clk_freq_mhz /
+		dev->pixels_per_line / dev->lines_per_frame);
+	dev_dbg(&client->dev, "HBlank: %d nS:\n",
+		1000 * (dev->pixels_per_line - width) /
+		(dev->vt_pix_clk_freq_mhz / 1000000));
+	dev_dbg(&client->dev, "VBlank: %d uS:\n",
+		(dev->lines_per_frame - height) * dev->pixels_per_line /
+		(dev->vt_pix_clk_freq_mhz / 1000000));
+}
+
+/*
+ * ov8858 stream on/off
+ */
+static int ov8858_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	if (enable) {
+		__ov8858_print_timing(sd);
+		ret = ov8858_write_reg_array(client, ov8858_streaming);
+		if (ret != 0) {
+			dev_err(&client->dev, "write_reg_array err\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		dev->streaming = 1;
+	} else {
+		ret = ov8858_write_reg_array(client, ov8858_soft_standby);
+		if (ret != 0) {
+			dev_err(&client->dev, "write_reg_array err\n");
+			mutex_unlock(&dev->input_lock);
+			return ret;
+		}
+		dev->streaming = 0;
+		dev->fps_index = 0;
+		dev->fps = 0;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/*
+ * ov8858 enum frame size, frame intervals
+ */
+static int ov8858_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= dev->entries_curr_table) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = dev->curr_res_table[index].width;
+	fsize->discrete.height = dev->curr_res_table[index].height;
+	fsize->reserved[0] = dev->curr_res_table[index].used;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov8858_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+	int i;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	/* since the isp will donwscale the resolution to the right size,
+	  * find the nearest one that will allow the isp to do so
+	  * important to ensure that the resolution requested is padded
+	  * correctly by the requester, which is the atomisp driver in
+	  * this case.
+	  */
+	i = nearest_resolution_index(sd, fival->width, fival->height);
+
+	if (i == -1)
+		i = dev->entries_curr_table - 1;
+
+	/* Check if this index is supported */
+	if (index >
+	    __ov8858_get_max_fps_index(dev->curr_res_table[i].fps_options))
+		goto out;
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator =
+			dev->curr_res_table[i].fps_options[index].fps;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+out:
+	mutex_unlock(&dev->input_lock);
+	return -EINVAL;
+}
+
+static int ov8858_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int __update_ov8858_device_settings(struct ov8858_device *dev,
+					   u16 sensor_id)
+{
+	if (sensor_id == OV8858_CHIP_ID)
+		dev->vcm_driver = &ov8858_vcms[OV8858_SUNNY];
+	else
+		return -ENODEV;
+
+	return dev->vcm_driver->init(&dev->sd);
+}
+
+static int ov8858_s_config(struct v4l2_subdev *sd,
+			   int irq, void *pdata)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 sensor_id;
+	int ret;
+
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			dev_err(&client->dev, "ov8858 platform init err\n");
+			return ret;
+		}
+	}
+
+	ret = __ov8858_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "ov8858 power-up err.\n");
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = ov8858_detect(client, &sensor_id);
+	if (ret) {
+		dev_err(&client->dev, "ov8858_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	dev->sensor_id = sensor_id;
+
+	/* Resolution settings depend on sensor type and platform */
+	ret = __update_ov8858_device_settings(dev, dev->sensor_id);
+	if (ret)
+		goto fail_detect;
+
+	/* power off sensor */
+	ret = __ov8858_s_power(sd, 0);
+
+	mutex_unlock(&dev->input_lock);
+	if (ret)
+		dev_err(&client->dev, "ov8858 power-down err.\n");
+
+	return ret;
+
+fail_detect:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_csi_cfg:
+	__ov8858_s_power(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int
+ov8858_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		      struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int
+ov8858_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= dev->entries_curr_table) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fse->min_width = dev->curr_res_table[index].width;
+	fse->min_height = dev->curr_res_table[index].height;
+	fse->max_width = dev->curr_res_table[index].width;
+	fse->max_height = dev->curr_res_table[index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__ov8858_get_pad_format(struct ov8858_device *sensor,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(fh, pad);
+
+	return &sensor->format;
+}
+
+static int
+ov8858_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		      struct v4l2_subdev_format *fmt)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	fmt->format = *__ov8858_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	return 0;
+}
+
+static int
+ov8858_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		      struct v4l2_subdev_format *fmt)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__ov8858_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	*format = fmt->format;
+
+	return 0;
+}
+
+static int ov8858_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov8858_device *dev = container_of(
+		ctrl->handler, struct ov8858_device, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+
+	/* input_lock is taken by the control framework, so it
+	 * doesn't need to be taken here.
+	 */
+
+	/* We only handle V4L2_CID_RUN_MODE for now. */
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		switch (ctrl->val) {
+		case ATOMISP_RUN_MODE_VIDEO:
+			dev->curr_res_table = ov8858_res_video;
+			dev->entries_curr_table = ARRAY_SIZE(ov8858_res_video);
+			break;
+		case ATOMISP_RUN_MODE_STILL_CAPTURE:
+			dev->curr_res_table = ov8858_res_still;
+			dev->entries_curr_table = ARRAY_SIZE(ov8858_res_still);
+			break;
+		default:
+			dev->curr_res_table = ov8858_res_preview;
+			dev->entries_curr_table =
+					ARRAY_SIZE(ov8858_res_preview);
+		}
+
+		dev->fmt_idx = 0;
+		dev->fps_index = 0;
+
+		return 0;
+	case V4L2_CID_TEST_PATTERN:
+		return ov8858_write_reg(client, OV8858_16BIT,
+					OV8858_TEST_PATTERN_REG, ctrl->val);
+	case V4L2_CID_FOCUS_ABSOLUTE:
+		if (dev->vcm_driver && dev->vcm_driver->t_focus_abs)
+			return dev->vcm_driver->t_focus_abs(&dev->sd,
+							    ctrl->val);
+	default:
+		dev_err(&client->dev, "%s: Error: Invalid ctrl: 0x%X\n",
+			__func__, ctrl->id);
+		return -EINVAL;
+	}
+}
+
+static int ov8858_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov8858_device *dev = container_of(
+		ctrl->handler, struct ov8858_device, ctrl_handler);
+	int r_odd, r_even;
+
+	switch (ctrl->id) {
+	case V4L2_CID_FOCUS_STATUS: {
+		if (dev->vcm_driver && dev->vcm_driver->q_focus_status)
+			return dev->vcm_driver->q_focus_status(
+						&dev->sd, &(ctrl->val));
+	}
+	case V4L2_CID_BIN_FACTOR_HORZ:
+		r_odd = ov8858_get_register(&dev->sd, OV8858_H_INC_ODD,
+					dev->curr_res_table[dev->fmt_idx].regs);
+		if (r_odd < 0)
+			return r_odd;
+		r_even = ov8858_get_register(&dev->sd, OV8858_H_INC_EVEN,
+					dev->curr_res_table[dev->fmt_idx].regs);
+		if (r_even < 0)
+			return r_even;
+		ctrl->val = fls(r_odd + (r_even)) - 2;
+		return 0;
+
+	case V4L2_CID_BIN_FACTOR_VERT: {
+		r_odd = ov8858_get_register(&dev->sd, OV8858_V_INC_ODD,
+					dev->curr_res_table[dev->fmt_idx].regs);
+		if (r_odd < 0)
+			return r_odd;
+		r_even = ov8858_get_register(&dev->sd, OV8858_V_INC_EVEN,
+					dev->curr_res_table[dev->fmt_idx].regs);
+		if (r_even < 0)
+			return r_even;
+		ctrl->val = fls(r_odd + (r_even)) - 2;
+		return 0;
+	}
+	default: {
+		return -EINVAL;
+	}
+	}
+
+	return 0;
+}
+
+static int
+ov8858_g_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	const struct ov8858_resolution *res =
+				&dev->curr_res_table[dev->fmt_idx];
+
+	mutex_lock(&dev->input_lock);
+	interval->interval.denominator = res->fps_options[dev->fps_index].fps;
+	interval->interval.numerator = 1;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int __ov8858_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	const struct ov8858_resolution *res =
+				&dev->curr_res_table[dev->fmt_idx];
+	struct camera_mipi_info *info = NULL;
+	unsigned int fps_index;
+	int ret = 0;
+	int fps;
+
+	info = v4l2_get_subdev_hostdata(sd);
+	if (info == NULL)
+		return -EINVAL;
+
+	if (!interval->interval.numerator)
+		interval->interval.numerator = 1;
+
+	fps = interval->interval.denominator / interval->interval.numerator;
+
+	/* No need to proceed further if we are not streaming */
+	if (!dev->streaming) {
+		/* Save the new FPS and use it while selecting setting */
+		dev->fps = fps;
+		return 0;
+	}
+
+	 /* Ignore if we are already using the required FPS. */
+	if (fps == res->fps_options[dev->fps_index].fps)
+		return 0;
+
+	fps_index = __ov8858_nearest_fps_index(fps, res->fps_options);
+
+	if (res->fps_options[fps_index].regs &&
+	    res->fps_options[fps_index].regs != dev->regs) {
+		dev_err(&client->dev,
+			"Sensor is streaming, can't apply new configuration\n");
+		return -EBUSY;
+	}
+
+	dev->fps_index = fps_index;
+	dev->fps = res->fps_options[dev->fps_index].fps;
+
+	/* Update the new frametimings based on FPS */
+	dev->pixels_per_line =
+		res->fps_options[dev->fps_index].pixels_per_line;
+	dev->lines_per_frame =
+		res->fps_options[dev->fps_index].lines_per_frame;
+
+	/* update frametiming. Conside the curren exposure/gain as well */
+	ret = __ov8858_set_exposure(sd, dev->exposure, dev->gain,
+	      dev->digital_gain, &dev->pixels_per_line, &dev->lines_per_frame);
+	if (ret)
+		return ret;
+
+	/* Update the new values so that user side knows the current settings */
+	ret = ov8858_get_intg_factor(sd, info, dev->regs);
+	if (ret)
+		return ret;
+
+	interval->interval.denominator = res->fps_options[dev->fps_index].fps;
+	interval->interval.numerator = 1;
+	__ov8858_print_timing(sd);
+
+	return ret;
+}
+
+static int ov8858_s_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov8858_s_frame_interval(sd, interval);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov8858_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = dev->curr_res_table[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops ov8858_sensor_ops = {
+	.g_skip_frames	= ov8858_g_skip_frames,
+};
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = ov8858_s_ctrl,
+	.g_volatile_ctrl = ov8858_g_ctrl,
+};
+
+static const struct v4l2_subdev_video_ops ov8858_video_ops = {
+	.s_stream = ov8858_s_stream,
+	.enum_framesizes = ov8858_enum_framesizes,
+	.enum_frameintervals = ov8858_enum_frameintervals,
+	.enum_mbus_fmt = ov8858_enum_mbus_fmt,
+	.try_mbus_fmt = ov8858_try_mbus_fmt,
+	.g_mbus_fmt = ov8858_g_mbus_fmt,
+	.s_mbus_fmt = ov8858_s_mbus_fmt,
+	.g_frame_interval = ov8858_g_frame_interval,
+	.s_frame_interval = ov8858_s_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops ov8858_core_ops = {
+	.g_chip_ident = ov8858_g_chip_ident,
+	.queryctrl = v4l2_subdev_queryctrl,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
+	.s_power = ov8858_s_power,
+	.ioctl = ov8858_ioctl,
+	.init = ov8858_init,
+};
+
+static const struct v4l2_subdev_pad_ops ov8858_pad_ops = {
+	.enum_mbus_code = ov8858_enum_mbus_code,
+	.enum_frame_size = ov8858_enum_frame_size,
+	.get_fmt = ov8858_get_pad_format,
+	.set_fmt = ov8858_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ov8858_ops = {
+	.core = &ov8858_core_ops,
+	.video = &ov8858_video_ops,
+	.pad = &ov8858_pad_ops,
+	.sensor = &ov8858_sensor_ops,
+};
+
+static const struct media_entity_operations ov_entity_ops = {
+	.link_setup = NULL,
+};
+
+static int ov8858_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov8858_device *dev = to_ov8858_sensor(sd);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	media_entity_cleanup(&dev->sd.entity);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrl_run_mode = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_RUN_MODE,
+	.name = "run mode",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 1,
+	.def = 4,
+	.max = 4,
+	.qmenu = ctrl_run_mode_menu,
+};
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+		.name = "Absolute exposure",
+		.type = V4L2_CTRL_TYPE_MENU,
+		.max = 0xffff,
+		.qmenu = ctrl_run_mode_menu,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_TEST_PATTERN,
+		.name = "Test pattern",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.step = 1,
+		.max = 0xffff,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_ABSOLUTE,
+		.name = "Focus absolute",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.step = 1,
+		.max = OV8858_MAX_FOCUS_POS,
+	}, {
+		/* This one is junk: see the spec for proper use of this CID. */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCUS_STATUS,
+		.name = "Focus status",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.step = 1,
+		.max = 100,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}, {
+		/* This is crap. For compatibility use only. */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FOCAL_ABSOLUTE,
+		.name = "Focal lenght",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = (OV8858_FOCAL_LENGTH_NUM << 16) |
+		       OV8858_FOCAL_LENGTH_DEM,
+		.max = (OV8858_FOCAL_LENGTH_NUM << 16) |
+		       OV8858_FOCAL_LENGTH_DEM,
+		.step = 1,
+		.def = (OV8858_FOCAL_LENGTH_NUM << 16) |
+		       OV8858_FOCAL_LENGTH_DEM,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		/* This one is crap, too. For compatibility use only. */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_ABSOLUTE,
+		.name = "F-number",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = (OV8858_F_NUMBER_DEFAULT_NUM << 16) |
+		       OV8858_F_NUMBER_DEM,
+		.max = (OV8858_F_NUMBER_DEFAULT_NUM << 16) |
+		       OV8858_F_NUMBER_DEM,
+		.step = 1,
+		.def = (OV8858_F_NUMBER_DEFAULT_NUM << 16) |
+		       OV8858_F_NUMBER_DEM,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		/*
+		 * The most utter crap. _Never_ use this, even for
+		 * compatibility reasons!
+		 */
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_FNUMBER_RANGE,
+		.name = "F-number range",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = (OV8858_F_NUMBER_DEFAULT_NUM << 24) |
+		       (OV8858_F_NUMBER_DEM << 16) |
+		       (OV8858_F_NUMBER_DEFAULT_NUM << 8) |
+		       OV8858_F_NUMBER_DEM,
+		.max = (OV8858_F_NUMBER_DEFAULT_NUM << 24) |
+		       (OV8858_F_NUMBER_DEM << 16) |
+		       (OV8858_F_NUMBER_DEFAULT_NUM << 8) |
+		       OV8858_F_NUMBER_DEM,
+		.step = 1,
+		.def = (OV8858_F_NUMBER_DEFAULT_NUM << 24) |
+		       (OV8858_F_NUMBER_DEM << 16) |
+		       (OV8858_F_NUMBER_DEFAULT_NUM << 8) |
+		       OV8858_F_NUMBER_DEM,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_HORZ,
+		.name = "Horizontal binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = OV8858_BIN_FACTOR_MAX,
+		.step = 1,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}, {
+		.ops = &ctrl_ops,
+		.id = V4L2_CID_BIN_FACTOR_VERT,
+		.name = "Vertical binning factor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.max = OV8858_BIN_FACTOR_MAX,
+		.step = 1,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY | V4L2_CTRL_FLAG_VOLATILE,
+	}
+};
+
+static int ov8858_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct ov8858_device *dev;
+	unsigned int i;
+	int ret;
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->i2c_id = id->driver_data;
+	dev->fmt_idx = 0;
+	dev->sensor_id = OV_ID_DEFAULT;
+	dev->vcm_driver = &ov8858_vcms[OV8858_ID_DEFAULT];
+
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov8858_ops);
+
+	if (client->dev.platform_data) {
+		ret = ov8858_s_config(&dev->sd, client->irq,
+				      client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	/*
+	 * sd->name is updated with sensor driver name by the v4l2.
+	 * change it to sensor name in this case.
+	 */
+	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s%x %d-%04x",
+		 OV_SUBDEV_PREFIX, dev->sensor_id,
+		 i2c_adapter_id(client->adapter), client->addr);
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->sd.entity.ops = &ov_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls) + 1);
+	if (ret) {
+		ov8858_remove(client);
+		return ret;
+	}
+
+	dev->run_mode = v4l2_ctrl_new_custom(&dev->ctrl_handler,
+					     &ctrl_run_mode, NULL);
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		ov8858_remove(client);
+		return dev->ctrl_handler.error;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		ov8858_remove(client);
+		return ret;
+	}
+
+	return 0;
+
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+static const struct i2c_device_id ov8858_id[] = {
+	{OV8858_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ov8858_id);
+
+static struct i2c_driver ov8858_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV8858_NAME,
+	},
+	.probe = ov8858_probe,
+	.remove = ov8858_remove,
+	.id_table = ov8858_id,
+};
+
+static __init int ov8858_init_mod(void)
+{
+	int ret;
+	ret = i2c_add_driver(&ov8858_driver);
+	return ret;
+}
+
+static __exit void ov8858_exit_mod(void)
+{
+	i2c_del_driver(&ov8858_driver);
+}
+
+module_init(ov8858_init_mod);
+module_exit(ov8858_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV8858 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
new file mode 100644
index 0000000..0bd52d6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov8858.h
@@ -0,0 +1,837 @@
+/*
+ * Support for the Omnivision OV8858 camera sensor.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV8858_H__
+#define __OV8858_H__
+#include <linux/atomisp_platform.h>
+#include <media/v4l2-ctrls.h>
+
+#define I2C_MSG_LENGTH		0x2
+
+/*
+ * This should be added into include/linux/videodev2.h
+ * NOTE: This is most likely not used anywhere.
+ * */
+#define V4L2_IDENT_OV8858	V4L2_IDENT_UNKNOWN
+
+/*
+ * Indexes for VCM driver lists
+ */
+#define OV8858_ID_DEFAULT	0
+#define OV8858_SUNNY		1
+
+/*
+ * ov8858 System control registers
+ */
+#define OV8858_PLL1_PREDIV0		0x030A
+#define OV8858_PLL1_PREDIV		0x0300
+#define OV8858_PLL1_MULTIPLIER		0x0301
+#define OV8858_PLL1_SYS_PRE_DIV		0x0305
+#define OV8858_PLL1_SYS_DIVIDER		0x0306
+
+#define OV8858_PLL1_PREDIV0_MASK	BIT(0)
+#define OV8858_PLL1_PREDIV_MASK		(BIT(0) | BIT(1) | BIT(2))
+#define OV8858_PLL1_MULTIPLIER_MASK	0x01FF
+#define OV8858_PLL1_SYS_PRE_DIV_MASK	(BIT(0) | BIT(1))
+#define OV8858_PLL1_SYS_DIVIDER_MASK	BIT(0)
+
+#define OV8858_PLL2_PREDIV0		0x0312
+#define OV8858_PLL2_PREDIV		0x030B
+#define OV8858_PLL2_MULTIPLIER		0x030C
+#define OV8858_PLL2_DAC_DIVIDER		0x0312
+#define OV8858_PLL2_SYS_PRE_DIV		0x030F
+#define OV8858_PLL2_SYS_DIVIDER		0x030E
+
+#define OV8858_PLL2_PREDIV0_MASK	BIT(4)
+#define OV8858_PLL2_PREDIV_MASK		(BIT(0) | BIT(1) | BIT(2))
+#define OV8858_PLL2_MULTIPLIER_MASK	0x01FF
+#define OV8858_PLL2_DAC_DIVIDER_MASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+#define OV8858_PLL2_SYS_PRE_DIV_MASK	(BIT(0) | BIT(1) | BIT(2) | BIT(3))
+#define OV8858_PLL2_SYS_DIVIDER_MASK	(BIT(0) | BIT(1) | BIT(2))
+
+#define OV8858_PLL_SCLKSEL1		0x3032
+#define OV8858_PLL_SCLKSEL2		0x3033
+#define OV8858_SRB_HOST_INPUT_DIS	0x3106
+
+#define OV8858_PLL_SCLKSEL1_MASK	BIT(7)
+#define OV8858_PLL_SCLKSEL2_MASK	BIT(1)
+
+#define OV8858_SYS_PRE_DIV_OFFSET	2
+#define OV8858_SYS_PRE_DIV_MASK		(BIT(2) | BIT(3))
+#define OV8858_SCLK_PDIV_OFFSET		4
+#define OV8858_SCLK_PDIV_MASK		(BIT(4) | BIT(5) | BIT(6) | BIT(7))
+
+#define OV8858_TIMING_HTS			0x380C
+#define OV8858_TIMING_VTS			0x380E
+
+#define OV8858_HORIZONTAL_START_H		0x3800
+#define OV8858_VERTICAL_START_H			0x3802
+#define OV8858_HORIZONTAL_END_H			0x3804
+#define OV8858_VERTICAL_END_H			0x3806
+#define OV8858_HORIZONTAL_OUTPUT_SIZE_H		0x3808
+#define OV8858_VERTICAL_OUTPUT_SIZE_H		0x380A
+
+#define OV8858_GROUP_ACCESS			0x3208
+#define OV8858_GROUP_ZERO			0x00
+#define OV8858_GROUP_ACCESS_HOLD_START		0x00
+#define OV8858_GROUP_ACCESS_HOLD_END		0x10
+#define OV8858_GROUP_ACCESS_DELAY_LAUNCH	0xA0
+#define OV8858_GROUP_ACCESS_QUICK_LAUNCH	0xE0
+
+#define OV_SUBDEV_PREFIX			"ov"
+#define OV_ID_DEFAULT				0x0000
+#define	OV8858_NAME				"ov8858"
+#define OV8858_CHIP_ID				0x8858
+
+#define OV8858_LONG_EXPO			0x3500
+#define OV8858_AGC_ADJ				0x3508 /* OV Long Gain? */
+
+#define OV8858_MWB_RED_GAIN_H			0x5032 /* ToDo: Fixed? */
+#define OV8858_MWB_GREEN_GAIN_H			0x5034 /* ToDo: Fixed? */
+#define OV8858_MWB_BLUE_GAIN_H			0x5036 /* ToDo: Fixed? */
+#define OV8858_MWB_GAIN_MAX			0x0FFF /* ToDo: Fixed? */
+
+#define OV8858_CHIP_ID_HIGH			0x300B
+#define OV8858_CHIP_ID_LOW			0x300C
+#define OV8858_STREAM_MODE			0x0100
+
+#define OV8858_FOCAL_LENGTH_NUM			294	/* 2.94mm */
+#define OV8858_FOCAL_LENGTH_DEM			100
+#define OV8858_F_NUMBER_DEFAULT_NUM		24	/* 2.4 */
+#define OV8858_F_NUMBER_DEM			10
+
+#define OV8858_H_INC_ODD			0x3814
+#define OV8858_H_INC_EVEN			0x3815
+#define OV8858_V_INC_ODD			0x382A
+#define OV8858_V_INC_EVEN			0x382B
+
+#define OV8858_READ_MODE_BINNING_ON		0x0400 /* ToDo: Check this */
+#define OV8858_READ_MODE_BINNING_OFF		0x00   /* ToDo: Check this */
+#define OV8858_BIN_FACTOR_MAX			2
+#define OV8858_INTEGRATION_TIME_MARGIN		14
+
+#define OV8858_MAX_VTS_VALUE			0x7FFF /* ToDo: ?? */
+#define OV8858_MAX_EXPOSURE_VALUE \
+		(OV8858_MAX_VTS_VALUE - OV8858_INTEGRATION_TIME_MARGIN)
+#define OV8858_MAX_GAIN_VALUE			0xFF   /* ToDo: ?? */
+
+#define OV8858_MAX_FOCUS_POS			1023
+
+#define OV8858_TEST_PATTERN_REG			0x5E00
+
+struct ov8858_vcm {
+	int (*power_up)(struct v4l2_subdev *sd);
+	int (*power_down)(struct v4l2_subdev *sd);
+	int (*init)(struct v4l2_subdev *sd);
+	int (*t_focus_vcm)(struct v4l2_subdev *sd, u16 val);
+	int (*t_focus_abs)(struct v4l2_subdev *sd, s32 value);
+	int (*t_focus_rel)(struct v4l2_subdev *sd, s32 value);
+	int (*q_focus_status)(struct v4l2_subdev *sd, s32 *value);
+	int (*q_focus_abs)(struct v4l2_subdev *sd, s32 *value);
+	int (*t_vcm_slew)(struct v4l2_subdev *sd, s32 value);
+	int (*t_vcm_timing)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * Defines for register writes and register array processing
+ * */
+#define OV8858_BYTE_MAX				32
+#define OV8858_SHORT_MAX			16
+#define OV8858_TOK_MASK				0xFFF0
+
+#define MAX_FPS_OPTIONS_SUPPORTED		3
+
+enum ov8858_tok_type {
+	OV8858_8BIT  = 0x0001,
+	OV8858_16BIT = 0x0002,
+	OV8858_TOK_TERM   = 0xF000,	/* terminating token for reg list */
+	OV8858_TOK_DELAY  = 0xFE00	/* delay token for reg list */
+};
+
+/*
+ * If register address or register width is not 32 bit width,
+ * user needs to convert it manually
+ */
+struct s_register_setting {
+	u32 reg;
+	u32 val;
+};
+
+/**
+ * struct ov8858_reg - MI sensor register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov8858_reg {
+	enum ov8858_tok_type type;
+	u16 sreg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+struct ov8858_fps_setting {
+	int fps;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	const struct ov8858_reg *regs; /* regs that the fps setting needs */
+};
+
+struct ov8858_resolution {
+	u8 *desc;
+	const struct ov8858_reg *regs;
+	int res;
+	int width;
+	int height;
+	bool used;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	unsigned short skip_frames;
+	const struct ov8858_fps_setting fps_options[MAX_FPS_OPTIONS_SUPPORTED];
+};
+
+/*
+ * ov8858 device structure
+ * */
+struct ov8858_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	int fmt_idx;
+	int streaming;
+	int vt_pix_clk_freq_mhz;
+	int fps_index;
+	u16 sensor_id;			/* Sensor id from registers */
+	u16 i2c_id;			/* Sensor id from i2c_device_id */
+	int exposure;
+	int gain;
+	u16 digital_gain;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 fps;
+	const struct ov8858_reg *regs;
+	struct ov8858_vcm *vcm_driver;
+	const struct ov8858_resolution *curr_res_table;
+	int entries_curr_table;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *run_mode;
+};
+
+#define to_ov8858_sensor(x) container_of(x, struct ov8858_device, sd)
+
+#define OV8858_MAX_WRITE_BUF_SIZE	32
+struct ov8858_write_buffer {
+	u16 addr;
+	u8 data[OV8858_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov8858_write_ctrl {
+	int index;
+	struct ov8858_write_buffer buffer;
+};
+
+static const struct ov8858_reg ov8858_soft_standby[] = {
+	{OV8858_8BIT, 0x0100, 0x00},
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+static const struct ov8858_reg ov8858_streaming[] = {
+	{OV8858_8BIT, 0x0100, 0x01},
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+static const struct ov8858_reg ov8858_param_hold[] = {
+	{OV8858_8BIT, OV8858_GROUP_ACCESS,
+			OV8858_GROUP_ZERO | OV8858_GROUP_ACCESS_HOLD_START},
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+static const struct ov8858_reg ov8858_param_update[] = {
+	{OV8858_8BIT, OV8858_GROUP_ACCESS,
+			OV8858_GROUP_ZERO | OV8858_GROUP_ACCESS_HOLD_END},
+	{OV8858_8BIT, OV8858_GROUP_ACCESS,
+			OV8858_GROUP_ZERO | OV8858_GROUP_ACCESS_DELAY_LAUNCH},
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+extern int dw9718_vcm_power_up(struct v4l2_subdev *sd);
+extern int dw9718_vcm_power_down(struct v4l2_subdev *sd);
+extern int dw9718_vcm_init(struct v4l2_subdev *sd);
+extern int dw9718_t_focus_vcm(struct v4l2_subdev *sd, u16 val);
+extern int dw9718_t_focus_abs(struct v4l2_subdev *sd, s32 value);
+extern int dw9718_t_focus_rel(struct v4l2_subdev *sd, s32 value);
+extern int dw9718_q_focus_status(struct v4l2_subdev *sd, s32 *value);
+extern int dw9718_q_focus_abs(struct v4l2_subdev *sd, s32 *value);
+extern int dw9718_t_vcm_slew(struct v4l2_subdev *sd, s32 value);
+extern int dw9718_t_vcm_timing(struct v4l2_subdev *sd, s32 value);
+
+extern int vcm_power_up(struct v4l2_subdev *sd);
+extern int vcm_power_down(struct v4l2_subdev *sd);
+
+static struct ov8858_vcm ov8858_vcms[] = {
+	[OV8858_SUNNY] = {
+		.power_up = dw9718_vcm_power_up,
+		.power_down = dw9718_vcm_power_down,
+		.init = dw9718_vcm_init,
+		.t_focus_vcm = dw9718_t_focus_vcm,
+		.t_focus_abs = dw9718_t_focus_abs,
+		.t_focus_rel = dw9718_t_focus_rel,
+		.q_focus_status = dw9718_q_focus_status,
+		.q_focus_abs = dw9718_q_focus_abs,
+		.t_vcm_slew = dw9718_t_vcm_slew,
+		.t_vcm_timing = dw9718_t_vcm_timing,
+	},
+	[OV8858_ID_DEFAULT] = {
+		.power_up = vcm_power_up,
+		.power_down = vcm_power_down,
+	},
+};
+
+
+#define OV8858_RES_WIDTH_MAX	3280
+#define OV8858_RES_HEIGHT_MAX	2464
+
+static const struct ov8858_reg ov8858_module_detection[] = {
+	{OV8858_8BIT, OV8858_STREAM_MODE, 0x01}, /* Stream on */
+	{OV8858_8BIT, 0x3d84, 0xc0}, /* Select Bank 0 */
+	{OV8858_8BIT, 0x3d81, 0x01}, /* OTP read enable */
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+static const struct ov8858_reg ov8858_BasicSettings[] = {
+	{OV8858_8BIT, 0x0103, 0x01}, /* software_reset */
+	{OV8858_8BIT, 0x0100, 0x00}, /* software_standby */
+	/* PLL settings */
+	{OV8858_8BIT, 0x0300, 0x02}, /* pll1_pre_div = /2 */
+	{OV8858_8BIT, 0x0302, 0x50}, /* pll1_multiplier = 80 */
+	{OV8858_8BIT, 0x0303, 0x00}, /* pll1_divm = /(1 + 0) */
+	{OV8858_8BIT, 0x0304, 0x03}, /* pll1_div_mipi = /8 */
+	{OV8858_8BIT, 0x030B, 0x02}, /* pll2_pre_div = /2 */
+	{OV8858_8BIT, 0x030D, 0x4B}, /* pll2_r_divp = 75 */
+	{OV8858_8BIT, 0x030E, 0x00}, /* pll2_r_divs = /1 */
+	{OV8858_8BIT, 0x030F, 0x04}, /* pll2_r_divsp = /(1 + 4) */
+	/* pll2_pre_div0 = /1, pll2_r_divdac = /(1 + 1) */
+	{OV8858_8BIT, 0x0312, 0x01},
+	{OV8858_8BIT, 0x031E, 0x0C}, /* pll1_no_lat = 1, mipi_bitsel_man = 0 */
+
+	{OV8858_8BIT, 0x300D, 0x00}, /* PAD SEL2, VSYNC out value = 0 */
+	{OV8858_8BIT, 0x3002, 0x80}, /* PAD OEN2, VSYNC out enable */
+	{OV8858_8BIT, 0x3010, 0x00}, /* PAD OUT2, VSYNC out select = 0 */
+
+	{OV8858_8BIT, 0x3600, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3601, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3602, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3603, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3604, 0x22}, /* Unknown */
+	{OV8858_8BIT, 0x3605, 0x30}, /* Unknown */
+	{OV8858_8BIT, 0x3606, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3607, 0x20}, /* Unknown */
+	{OV8858_8BIT, 0x3608, 0x11}, /* Unknown */
+	{OV8858_8BIT, 0x3609, 0x28}, /* Unknown */
+	{OV8858_8BIT, 0x360A, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x360B, 0x06}, /* Unknown */
+	{OV8858_8BIT, 0x360C, 0xDC}, /* Unknown */
+	{OV8858_8BIT, 0x360D, 0x40}, /* Unknown */
+	{OV8858_8BIT, 0x360E, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x360F, 0x20}, /* Unknown */
+	{OV8858_8BIT, 0x3610, 0x07}, /* Unknown */
+	{OV8858_8BIT, 0x3611, 0x20}, /* Unknown */
+	{OV8858_8BIT, 0x3612, 0x88}, /* Unknown */
+	{OV8858_8BIT, 0x3613, 0x80}, /* Unknown */
+	{OV8858_8BIT, 0x3614, 0x58}, /* Unknown */
+	{OV8858_8BIT, 0x3615, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3616, 0x4A}, /* Unknown */
+	{OV8858_8BIT, 0x3617, 0x90}, /* Unknown */
+	{OV8858_8BIT, 0x3618, 0x56}, /* Unknown */
+	{OV8858_8BIT, 0x3619, 0x70}, /* Unknown */
+	{OV8858_8BIT, 0x361A, 0x99}, /* Unknown */
+	{OV8858_8BIT, 0x361B, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x361C, 0x07}, /* Unknown */
+	{OV8858_8BIT, 0x361D, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x361E, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x361F, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3633, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x3634, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x3635, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x3636, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x3638, 0xFF}, /* Unknown */
+	{OV8858_8BIT, 0x3645, 0x13}, /* Unknown */
+	{OV8858_8BIT, 0x3646, 0x83}, /* Unknown */
+	{OV8858_8BIT, 0x364A, 0x07}, /* Unknown */
+
+	/* Npump clock div = /2, Ppump clock div = /4 */
+	{OV8858_8BIT, 0x3015, 0x01},
+	/* mipi_lane_mode = 1+3, mipi_lvds_sel = 1 = MIPI enable,
+	 * r_phy_pd_mipi_man = 0, lane_dis_option = 0 */
+	{OV8858_8BIT, 0x3018, 0x72},
+	/*Clock switch output = normal, pclk_div = /1 */
+	{OV8858_8BIT, 0x3020, 0x93},
+	/* lvds_mode_o = 0, clock lane disable when pd_mipi = 0,
+	 * pd_mipi enable when rst_sync = 1 */
+	{OV8858_8BIT, 0x3022, 0x01},
+	{OV8858_8BIT, 0x3031, 0x0A}, /* mipi_bit_sel = 10 */
+	{OV8858_8BIT, 0x3034, 0x00}, /* Unknown */
+	/* sclk_div = /1, sclk_pre_div = /1, chip debug = 1 */
+	{OV8858_8BIT, 0x3106, 0x01},
+
+	{OV8858_8BIT, 0x3305, 0xF1}, /* Unknown */
+	{OV8858_8BIT, 0x3307, 0x04}, /* Unknown */
+	{OV8858_8BIT, 0x3308, 0x28}, /* Unknown */
+	{OV8858_8BIT, 0x3309, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330A, 0x20}, /* Unknown */
+	{OV8858_8BIT, 0x330B, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330C, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330D, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x330E, 0x40}, /* Unknown */
+	{OV8858_8BIT, 0x330F, 0x04}, /* Unknown */
+
+	{OV8858_8BIT, 0x3500, 0x00}, /* long exposure = 0x9A20 */
+	{OV8858_8BIT, 0x3501, 0x9A}, /* long exposure = 0x9A20 */
+	{OV8858_8BIT, 0x3502, 0x20}, /* long exposure = 0x9A20 */
+	/* Digital fraction gain delay option = Delay 1 frame,
+	 * Gain change delay option = Delay 1 frame,
+	 * Gain delay option = Delay 1 frame,
+	 * Gain manual as sensor gain = Input gain as real gain format,
+	 * Exposure delay option (must be 0 = Delay 1 frame,
+	 * Exposure change delay option (must be 0) = Delay 1 frame */
+	{OV8858_8BIT, 0x3503, 0x00},
+	{OV8858_8BIT, 0x3505, 0x80}, /* gain conversation option */
+	/* [10:7] are integer gain, [6:0] are fraction gain. For example:
+	 * 0x80 is 1x gain, 0x100 is 2x gain, 0x1C0 is 3.5x gain */
+	{OV8858_8BIT, 0x3508, 0x02}, /* long gain = 0x0200 */
+	{OV8858_8BIT, 0x3509, 0x00}, /* long gain = 0x0200 */
+	{OV8858_8BIT, 0x350C, 0x00}, /* short gain = 0x0080 */
+	{OV8858_8BIT, 0x350D, 0x80}, /* short gain = 0x0080 */
+	{OV8858_8BIT, 0x3510, 0x00}, /* short exposure = 0x000200 */
+	{OV8858_8BIT, 0x3511, 0x02}, /* short exposure = 0x000200 */
+	{OV8858_8BIT, 0x3512, 0x00}, /* short exposure = 0x000200 */
+
+	{OV8858_8BIT, 0x3700, 0x30}, /* Unknown */
+	{OV8858_8BIT, 0x3701, 0x18}, /* Unknown */
+	{OV8858_8BIT, 0x3702, 0x50}, /* Unknown */
+	{OV8858_8BIT, 0x3703, 0x32}, /* Unknown */
+	{OV8858_8BIT, 0x3704, 0x28}, /* Unknown */
+	{OV8858_8BIT, 0x3705, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3706, 0x6A}, /* Unknown */
+	{OV8858_8BIT, 0x3707, 0x08}, /* Unknown */
+	{OV8858_8BIT, 0x3708, 0x48}, /* Unknown */
+	{OV8858_8BIT, 0x3709, 0x66}, /* Unknown */
+	{OV8858_8BIT, 0x370A, 0x01}, /* Unknown */
+	{OV8858_8BIT, 0x370B, 0x6A}, /* Unknown */
+	{OV8858_8BIT, 0x370C, 0x07}, /* Unknown */
+	{OV8858_8BIT, 0x3712, 0x44}, /* Unknown */
+	{OV8858_8BIT, 0x3714, 0x24}, /* Unknown */
+	{OV8858_8BIT, 0x3718, 0x14}, /* Unknown */
+	{OV8858_8BIT, 0x3719, 0x31}, /* Unknown */
+	{OV8858_8BIT, 0x371E, 0x31}, /* Unknown */
+	{OV8858_8BIT, 0x371F, 0x7F}, /* Unknown */
+	{OV8858_8BIT, 0x3720, 0x0A}, /* Unknown */
+	{OV8858_8BIT, 0x3721, 0x0A}, /* Unknown */
+	{OV8858_8BIT, 0x3724, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x3725, 0x02}, /* Unknown */
+	{OV8858_8BIT, 0x3726, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x3728, 0x0A}, /* Unknown */
+	{OV8858_8BIT, 0x3729, 0x03}, /* Unknown */
+	{OV8858_8BIT, 0x372A, 0x06}, /* Unknown */
+	{OV8858_8BIT, 0x372B, 0xA6}, /* Unknown */
+	{OV8858_8BIT, 0x372C, 0xA6}, /* Unknown */
+	{OV8858_8BIT, 0x372D, 0xA6}, /* Unknown */
+	{OV8858_8BIT, 0x372E, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x372F, 0x20}, /* Unknown */
+	{OV8858_8BIT, 0x3730, 0x02}, /* Unknown */
+	{OV8858_8BIT, 0x3731, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x3732, 0x28}, /* Unknown */
+	{OV8858_8BIT, 0x3733, 0x10}, /* Unknown */
+	{OV8858_8BIT, 0x3734, 0x40}, /* Unknown */
+	{OV8858_8BIT, 0x3736, 0x30}, /* Unknown */
+	{OV8858_8BIT, 0x373A, 0x0A}, /* Unknown */
+	{OV8858_8BIT, 0x373B, 0x0B}, /* Unknown */
+	{OV8858_8BIT, 0x373C, 0x14}, /* Unknown */
+	{OV8858_8BIT, 0x373E, 0x06}, /* Unknown */
+	{OV8858_8BIT, 0x3755, 0x10}, /* Unknown */
+	{OV8858_8BIT, 0x3758, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3759, 0x4C}, /* Unknown */
+	{OV8858_8BIT, 0x375A, 0x0C}, /* Unknown */
+	{OV8858_8BIT, 0x375B, 0x26}, /* Unknown */
+	{OV8858_8BIT, 0x375C, 0x20}, /* Unknown */
+	{OV8858_8BIT, 0x375D, 0x04}, /* Unknown */
+	{OV8858_8BIT, 0x375E, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x375F, 0x28}, /* Unknown */
+	{OV8858_8BIT, 0x3760, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3761, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3762, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3763, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3766, 0xFF}, /* Unknown */
+	{OV8858_8BIT, 0x3768, 0x22}, /* Unknown */
+	{OV8858_8BIT, 0x3769, 0x44}, /* Unknown */
+	{OV8858_8BIT, 0x376A, 0x44}, /* Unknown */
+	{OV8858_8BIT, 0x376B, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x376F, 0x01}, /* Unknown */
+	{OV8858_8BIT, 0x3772, 0x46}, /* Unknown */
+	{OV8858_8BIT, 0x3773, 0x04}, /* Unknown */
+	{OV8858_8BIT, 0x3774, 0x2C}, /* Unknown */
+	{OV8858_8BIT, 0x3775, 0x13}, /* Unknown */
+	{OV8858_8BIT, 0x3776, 0x08}, /* Unknown */
+	{OV8858_8BIT, 0x3777, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x3778, 0x16}, /* Unknown */
+	{OV8858_8BIT, 0x37A0, 0x88}, /* Unknown */
+	{OV8858_8BIT, 0x37A1, 0x7A}, /* Unknown */
+	{OV8858_8BIT, 0x37A2, 0x7A}, /* Unknown */
+	{OV8858_8BIT, 0x37A3, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37A4, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37A5, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37A6, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37A7, 0x88}, /* Unknown */
+	{OV8858_8BIT, 0x37A8, 0x98}, /* Unknown */
+	{OV8858_8BIT, 0x37A9, 0x98}, /* Unknown */
+	{OV8858_8BIT, 0x37AA, 0x88}, /* Unknown */
+	{OV8858_8BIT, 0x37AB, 0x5C}, /* Unknown */
+	{OV8858_8BIT, 0x37AC, 0x5C}, /* Unknown */
+	{OV8858_8BIT, 0x37AD, 0x55}, /* Unknown */
+	{OV8858_8BIT, 0x37AE, 0x19}, /* Unknown */
+	{OV8858_8BIT, 0x37AF, 0x19}, /* Unknown */
+	{OV8858_8BIT, 0x37B0, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37B1, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37B2, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37B3, 0x84}, /* Unknown */
+	{OV8858_8BIT, 0x37B4, 0x84}, /* Unknown */
+	{OV8858_8BIT, 0x37B5, 0x66}, /* Unknown */
+	{OV8858_8BIT, 0x37B6, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37B7, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37B8, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x37B9, 0xFF}, /* Unknown */
+
+	{OV8858_8BIT, 0x3800, 0x00}, /* h_crop_start high */
+	{OV8858_8BIT, 0x3801, 0x0C}, /* h_crop_start low */
+	{OV8858_8BIT, 0x3802, 0x00}, /* v_crop_start high */
+	{OV8858_8BIT, 0x3803, 0x0C}, /* v_crop_start low */
+	{OV8858_8BIT, 0x3804, 0x0C}, /* h_crop_end high */
+	{OV8858_8BIT, 0x3805, 0xD3}, /* h_crop_end low */
+	{OV8858_8BIT, 0x3806, 0x09}, /* v_crop_end high */
+	{OV8858_8BIT, 0x3807, 0xA3}, /* v_crop_end low */
+	{OV8858_8BIT, 0x3808, 0x0C}, /* h_output_size high */
+	{OV8858_8BIT, 0x3809, 0xC0}, /* h_output_size low */
+	{OV8858_8BIT, 0x380A, 0x09}, /* v_output_size high */
+	{OV8858_8BIT, 0x380B, 0x90}, /* v_output_size low */
+	{OV8858_8BIT, 0x380C, 0x07}, /* horizontal timing size high */
+	{OV8858_8BIT, 0x380D, 0x94}, /* horizontal timing size low */
+	{OV8858_8BIT, 0x380E, 0x09}, /* vertical timing size high */
+	{OV8858_8BIT, 0x380F, 0xAA}, /* vertical timing size low */
+	{OV8858_8BIT, 0x3810, 0x00}, /* h_win offset high */
+	{OV8858_8BIT, 0x3811, 0x04}, /* h_win offset low */
+	{OV8858_8BIT, 0x3812, 0x00}, /* v_win offset high */
+	{OV8858_8BIT, 0x3813, 0x02}, /* v_win offset low */
+	{OV8858_8BIT, 0x3814, 0x01}, /* h_odd_inc */
+	{OV8858_8BIT, 0x3815, 0x01}, /* h_even_inc */
+	{OV8858_8BIT, 0x3820, 0x00}, /* format1 */
+	{OV8858_8BIT, 0x3821, 0x46}, /* format2 */
+	{OV8858_8BIT, 0x382A, 0x01}, /* v_odd_inc */
+	{OV8858_8BIT, 0x382B, 0x01}, /* v_even_inc */
+
+	{OV8858_8BIT, 0x3830, 0x06}, /* Unknown */
+	{OV8858_8BIT, 0x3836, 0x01}, /* Unknown */
+	{OV8858_8BIT, 0x3837, 0x18}, /* Unknown */
+	{OV8858_8BIT, 0x3841, 0xFF}, /* AUTO_SIZE_CTRL */
+	{OV8858_8BIT, 0x3846, 0x48}, /* Unknown */
+
+	{OV8858_8BIT, 0x3D85, 0x14}, /* OTP_REG85 */
+	{OV8858_8BIT, 0x3F08, 0x10}, /* PSRAM control register */
+
+	{OV8858_8BIT, 0x4000, 0xF1}, /* BLC CTRL00 = default */
+	{OV8858_8BIT, 0x4001, 0x00}, /* BLC CTRL01 */
+	{OV8858_8BIT, 0x4002, 0x27}, /* BLC offset = 0x27 */
+	{OV8858_8BIT, 0x4005, 0x10}, /* BLC target = 0x0010 */
+	{OV8858_8BIT, 0x4009, 0x81}, /* BLC CTRL09 */
+	{OV8858_8BIT, 0x400B, 0x0C}, /* BLC CTRL0B = default */
+	{OV8858_8BIT, 0x401B, 0x00}, /* Zero line R coeff. = 0x0000 */
+	{OV8858_8BIT, 0x401D, 0x00}, /* Zero line T coeff. = 0x0000 */
+	{OV8858_8BIT, 0x401F, 0x00}, /* BLC CTRL1F */
+	{OV8858_8BIT, 0x4020, 0x00}, /* Anchor left start = 0x0004 */
+	{OV8858_8BIT, 0x4021, 0x04}, /* Anchor left start = 0x0004 */
+	{OV8858_8BIT, 0x4022, 0x0B}, /* Anchor left end = 0x0BC3 */
+	{OV8858_8BIT, 0x4023, 0xC3}, /* Anchor left end = 0x0BC3 */
+	{OV8858_8BIT, 0x4024, 0x0C}, /* Anchor right start = 0x0C36 */
+	{OV8858_8BIT, 0x4025, 0x36}, /* Anchor right start = 0x0C36 */
+	{OV8858_8BIT, 0x4026, 0x0C}, /* Anchor right end = 0x0C37 */
+	{OV8858_8BIT, 0x4027, 0x37}, /* Anchor right end = 0x0C37 */
+	{OV8858_8BIT, 0x4028, 0x00}, /* Top zero line start = 0 */
+	{OV8858_8BIT, 0x4029, 0x02}, /* Top zero line number = 2 */
+	{OV8858_8BIT, 0x402A, 0x04}, /* Top black line start = 4 */
+	{OV8858_8BIT, 0x402B, 0x08}, /* Top black line number = 8 */
+	{OV8858_8BIT, 0x402C, 0x02}, /* Bottom zero start line = 2 */
+	{OV8858_8BIT, 0x402D, 0x02}, /* Bottom zero line number = 2 */
+	{OV8858_8BIT, 0x402E, 0x0C}, /* Bottom black line start = 12 */
+	{OV8858_8BIT, 0x402F, 0x02}, /* Bottom black line number = 2 */
+
+	{OV8858_8BIT, 0x4034, 0x3F}, /* Unknown */
+	{OV8858_8BIT, 0x403D, 0x04}, /* BLC CTRL3D */
+	{OV8858_8BIT, 0x4300, 0xFF}, /* clip_max[11:4] = 0xFFF */
+	{OV8858_8BIT, 0x4301, 0x00}, /* clip_min[11:4] = 0 */
+	{OV8858_8BIT, 0x4302, 0x0F}, /* clip_min/max[3:0] */
+	{OV8858_8BIT, 0x4316, 0x00}, /* CTRL16 = default */
+	{OV8858_8BIT, 0x4503, 0x18}, /* Unknown */
+	{OV8858_8BIT, 0x4600, 0x01}, /* Unknown */
+	{OV8858_8BIT, 0x4601, 0x97}, /* Unknown */
+	/* wkup_dly = Mark1 wakeup delay/2^10 = 0x25 */
+	{OV8858_8BIT, 0x4808, 0x25},
+	{OV8858_8BIT, 0x481F, 0x32}, /* clk_prepare_min = 0x32 */
+	{OV8858_8BIT, 0x4825, 0x3A}, /* lpx_p_min = 0x3A */
+	{OV8858_8BIT, 0x4826, 0x40}, /* hs_prepare_min = 0x40 */
+	{OV8858_8BIT, 0x4837, 0x16}, /* pclk_period = 0x16 */
+	{OV8858_8BIT, 0x4850, 0x10}, /* LANE SEL01 */
+	{OV8858_8BIT, 0x4851, 0x32}, /* LANE SEL02 */
+
+	{OV8858_8BIT, 0x4B00, 0x2A}, /* Unknown */
+	{OV8858_8BIT, 0x4B0D, 0x00}, /* Unknown */
+	{OV8858_8BIT, 0x4D00, 0x04}, /* TPM_CTRL_REG */
+	{OV8858_8BIT, 0x4D01, 0x18}, /* TPM_CTRL_REG */
+	{OV8858_8BIT, 0x4D02, 0xC3}, /* TPM_CTRL_REG */
+	{OV8858_8BIT, 0x4D03, 0xFF}, /* TPM_CTRL_REG */
+	{OV8858_8BIT, 0x4D04, 0xFF}, /* TPM_CTRL_REG */
+	{OV8858_8BIT, 0x4D05, 0xFF}, /* TPM_CTRL_REG */
+
+	/* Lens correction (LENC) function enable = 0
+	 * Slave sensor AWB Gain function enable = 1
+	 * Slave sensor AWB Statistics function enable = 1
+	 * Master sensor AWB Gain function enable = 1
+	 * Master sensor AWB Statistics function enable = 1
+	 * Black DPC function enable = 1
+	 * White DPC function enable =1 */
+	{OV8858_8BIT, 0x5000, 0x7E},
+	{OV8858_8BIT, 0x5001, 0x01}, /* BLC function enable = 1 */
+	/* Horizontal scale function enable = 0
+	 * WBMATCH bypass mode = Select slave sensor's gain
+	 * WBMATCH function enable = 0
+	 * Master MWB gain support RGBC = 0
+	 * OTP_DPC function enable = 1
+	 * Manual mode of VarioPixel function enable = 0
+	 * Manual enable of VarioPixel function enable = 0
+	 * Use VSYNC to latch ISP modules's function enable signals = 0 */
+	{OV8858_8BIT, 0x5002, 0x08},
+	/* Bypass all ISP modules after BLC module = 0
+	 * DPC_DBC buffer control enable = 1
+	 * WBMATCH VSYNC selection = Select master sensor's VSYNC fall
+	 * Select master AWB gain to embed line = AWB gain before manual mode
+	 * Enable BLC's input flip_i signal = 0 */
+	{OV8858_8BIT, 0x5003, 0x20},
+	{OV8858_8BIT, 0x5046, 0x12}, /* ISP CTRL46 = default */
+	/* Tail enable = 1
+	 * Saturate cross cluster enable = 1
+	 * Remove cross cluster enable = 1
+	 * Enable to remove connected defect pixels in same channel = 1
+	 * Enable to remove connected defect pixels in different channel = 1
+	 * Smooth enable, use average G for recovery = 1
+	 * Black/white sensor mode enable = 0
+	 * Manual mode enable = 0 */
+	{OV8858_8BIT, 0x5780, 0xFC},
+	{OV8858_8BIT, 0x5784, 0x0C}, /* DPC CTRL04 */
+	{OV8858_8BIT, 0x5787, 0x40}, /* DPC CTRL07 */
+	{OV8858_8BIT, 0x5788, 0x08}, /* DPC CTRL08 */
+	{OV8858_8BIT, 0x578A, 0x02}, /* DPC CTRL0A */
+	{OV8858_8BIT, 0x578B, 0x01}, /* DPC CTRL0B */
+	{OV8858_8BIT, 0x578C, 0x01}, /* DPC CTRL0C */
+	{OV8858_8BIT, 0x578E, 0x02}, /* DPC CTRL0E */
+	{OV8858_8BIT, 0x578F, 0x01}, /* DPC CTRL0F */
+	{OV8858_8BIT, 0x5790, 0x01}, /* DPC CTRL10 */
+	{OV8858_8BIT, 0x5901, 0x00}, /* VAP CTRL01 = default */
+	{OV8858_8BIT, 0x5B00, 0x02}, /* OTP CTRL00 */
+	{OV8858_8BIT, 0x5B01, 0x10}, /* OTP CTRL01 */
+	{OV8858_8BIT, 0x5B02, 0x03}, /* OTP CTRL02 */
+	{OV8858_8BIT, 0x5B03, 0xCF}, /* OTP CTRL03 */
+	{OV8858_8BIT, 0x5B05, 0x6C}, /* OTP CTRL05 = default */
+	{OV8858_8BIT, 0x5E00, 0x00}, /* PRE CTRL00 = default */
+	{OV8858_8BIT, 0x5E01, 0x41}, /* PRE_CTRL01 = default */
+
+	{OV8858_8BIT, 0x0100, 0x01}, /* Streaming enable */
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+/*****************************STILL********************************/
+
+static const struct ov8858_reg ov8858_8M[] = {
+	{OV8858_8BIT, 0x3800, 0x00}, /* h_crop_start high */
+	{OV8858_8BIT, 0x3801, 0x0C}, /* h_crop_start low */
+	{OV8858_8BIT, 0x3802, 0x00}, /* v_crop_start high */
+	{OV8858_8BIT, 0x3803, 0x0C}, /* v_crop_start low */
+	{OV8858_8BIT, 0x3804, 0x0C}, /* h_crop_end high */
+	{OV8858_8BIT, 0x3805, 0xD3}, /* h_crop_end low */
+	{OV8858_8BIT, 0x3806, 0x09}, /* v_crop_end high */
+	{OV8858_8BIT, 0x3807, 0xA3}, /* v_crop_end low */
+	{OV8858_8BIT, 0x3808, 0x0C}, /* h_output_size high 3280 x 2448 */
+	{OV8858_8BIT, 0x3809, 0xD0}, /* h_output_size low */
+	{OV8858_8BIT, 0x380A, 0x09}, /* v_output_size high */
+	{OV8858_8BIT, 0x380B, 0xa0}, /* v_output_size low */
+	{OV8858_8BIT, 0x3810, 0x00}, /* h_win offset high */
+	{OV8858_8BIT, 0x3811, 0x04}, /* h_win offset low */
+	{OV8858_8BIT, 0x3812, 0x00}, /* v_win offset high */
+	{OV8858_8BIT, 0x3813, 0x02}, /* v_win offset low */
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+static const struct ov8858_reg ov8858_6M[] = {
+	{OV8858_8BIT, 0x3800, 0x00}, /* h_crop_start high */
+	{OV8858_8BIT, 0x3801, 0x0C}, /* h_crop_start low */
+	{OV8858_8BIT, 0x3802, 0x01}, /* v_crop_start high */
+	{OV8858_8BIT, 0x3803, 0x3E}, /* v_crop_start low */
+	{OV8858_8BIT, 0x3804, 0x0C}, /* h_crop_end high */
+	{OV8858_8BIT, 0x3805, 0xD3}, /* h_crop_end low */
+	{OV8858_8BIT, 0x3806, 0x08}, /* v_crop_end high */
+	{OV8858_8BIT, 0x3807, 0x71}, /* v_crop_end low */
+	{OV8858_8BIT, 0x3808, 0x0C}, /* h_output_size high 3280 x 1852 */
+	{OV8858_8BIT, 0x3809, 0xD0}, /* h_output_size low */
+	{OV8858_8BIT, 0x380A, 0x07}, /* v_output_size high */
+	{OV8858_8BIT, 0x380B, 0x3C}, /* v_output_size low */
+	{OV8858_8BIT, 0x3810, 0x00}, /* h_win offset high */
+	{OV8858_8BIT, 0x3811, 0x04}, /* h_win offset low */
+	{OV8858_8BIT, 0x3812, 0x00}, /* v_win offset high */
+	{OV8858_8BIT, 0x3813, 0x02}, /* v_win offset low */
+	{OV8858_TOK_TERM, 0, 0}
+};
+
+static struct ov8858_resolution ov8858_res_preview[] = {
+	{
+		.desc = "ov8858_6M_PREVIEW",
+		.width = 3280,
+		.height = 1852,
+		.used = 0,
+		.regs = ov8858_6M,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 0,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 4696,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8858_8M_PREVIEW",
+		.width = 3280,
+		.height = 2464,
+		.used = 0,
+		.regs = ov8858_8M,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 0,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 4464,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+};
+
+static struct ov8858_resolution ov8858_res_still[] = {
+	{
+		 .desc = "ov8858_6M_STILL",
+		 .width = 3280,
+		 .height = 1852,
+		 .used = 0,
+		 .regs = ov8858_6M,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options =  {
+			{
+				.fps = 30,
+				.pixels_per_line = 4464,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8858_8M_STILL",
+		.width = 3280,
+		.height = 2464,
+		.used = 0,
+		.regs = ov8858_8M,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 4464,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+};
+
+static struct ov8858_resolution ov8858_res_video[] = {
+	{
+		 .desc = "ov8858_6M_STILL",
+		 .width = 3280,
+		 .height = 1852,
+		 .used = 0,
+		 .regs = ov8858_6M,
+		 .bin_factor_x = 0,
+		 .bin_factor_y = 0,
+		 .skip_frames = 1,
+		 .fps_options =  {
+			{
+				.fps = 30,
+				.pixels_per_line = 4464,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+	{
+		.desc = "ov8858_8M_VIDEO",
+		.width = 3280,
+		.height = 2464,
+		.used = 0,
+		.regs = ov8858_8M,
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.skip_frames = 1,
+		.fps_options = {
+			{
+				.fps = 30,
+				.pixels_per_line = 4464,
+				.lines_per_frame = 2867,
+			},
+			{
+			}
+		},
+	},
+};
+
+#endif /* __OV8858_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov9724.c b/drivers/external_drivers/camera/drivers/media/i2c/ov9724.c
new file mode 100644
index 0000000..dd14157
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov9724.c
@@ -0,0 +1,1595 @@
+/*
+ * Support for OV9724 720P camera sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+
+#include "ov9724.h"
+
+/* the bayer order mapping table
+ *          hflip=0                  hflip=1
+ * vflip=0  atomisp_bayer_order_bggr atomisp_bayer_order_gbrg
+ * vflip=1  atomisp_bayer_order_grbg atomisp_bayer_order_rggb
+ *
+ * usage: ov9724_bayer_order_mapping[vflip][hflip]
+ */
+static const int ov9724_bayer_order_mapping[2][2] = {
+	{atomisp_bayer_order_bggr, atomisp_bayer_order_gbrg},
+	{atomisp_bayer_order_grbg, atomisp_bayer_order_rggb}
+};
+
+static int
+ov9724_read_reg(struct i2c_client *client, u16 len, u16 reg, u16 *val)
+{
+	struct i2c_msg msg[2];
+	u16 data[OV9724_SHORT_MAX] = {0};
+	int err, i;
+
+	if (len > OV9724_BYTE_MAX) {
+		v4l2_err(client, "%s error, invalid data length\n", __func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = (u8 *)data;
+	/* high byte goes first */
+	data[0] = cpu_to_be16(reg);
+
+	msg[1].addr = client->addr;
+	msg[1].len = len;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (u8 *)data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		goto error;
+	}
+
+	/* high byte comes first */
+	if (len == OV9724_8BIT)
+		*val = (u8)data[0];
+	else {
+		/* 16-bit access is default when len > 1 */
+		for (i = 0; i < (len >> 1); i++)
+			val[i] = be16_to_cpu(data[i]);
+	}
+
+	return 0;
+
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int ov9724_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int
+ov9724_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg = (u16 *)data;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (data_length != OV9724_8BIT && data_length != OV9724_16BIT) {
+		v4l2_err(client, "%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == OV9724_8BIT) {
+		data[2] = (u8)(val);
+	} else {
+		/* OV9724_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
+
+	ret = ov9724_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * ov9724_write_reg_array - Initializes a list of OV9724 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __ov9724_flush_reg_array, __ov9724_buf_reg_array() and
+ * __ov9724_write_reg_is_consecutive() are internal functions to
+ * ov9724_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __ov9724_flush_reg_array(struct i2c_client *client,
+				     struct ov9724_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return ov9724_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __ov9724_buf_reg_array(struct i2c_client *client,
+				   struct ov9724_write_ctrl *ctrl,
+				   const struct ov9724_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case OV9724_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case OV9724_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = (u16)next->val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg.sreg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= OV9724_MAX_WRITE_BUF_SIZE)
+		return __ov9724_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int
+__ov9724_write_reg_is_consecutive(struct i2c_client *client,
+				   struct ov9724_write_ctrl *ctrl,
+				   const struct ov9724_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg.sreg;
+}
+
+static int ov9724_write_reg_array(struct i2c_client *client,
+				   const struct ov9724_reg *reglist)
+{
+	const struct ov9724_reg *next = reglist;
+	struct ov9724_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != OV9724_TOK_TERM; next++) {
+		switch (next->type & OV9724_TOK_MASK) {
+		case OV9724_TOK_DELAY:
+			err = __ov9724_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__ov9724_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __ov9724_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __ov9724_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				v4l2_err(client, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __ov9724_flush_reg_array(client, &ctrl);
+}
+
+static int __ov9724_init(struct v4l2_subdev *sd, u32 val)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	ret = ov9724_write_reg_array(client, ov9724_init_config);
+	if (ret)
+		return ret;
+
+	/* restore settings */
+	ov9724_res = ov9724_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	return 0;
+}
+
+static int ov9724_init(struct v4l2_subdev *sd, u32 val)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	int ret = 0;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov9724_init(sd, val);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static void ov9724_uninit(struct v4l2_subdev *sd)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	dev->coarse_itg = 0;
+	dev->fine_itg   = 0;
+	dev->gain       = 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "gpio failed 1\n");
+		goto fail_gpio;
+	}
+
+	return 0;
+fail_gpio:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed 1\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int __ov9724_s_power(struct v4l2_subdev *sd, int power)
+{
+
+	if (power == 0) {
+		ov9724_uninit(sd);
+		return power_down(sd);
+	} else {
+		if (power_up(sd))
+			return -EINVAL;
+		return __ov9724_init(sd, 0);
+	}
+}
+
+static int ov9724_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov9724_s_power(sd, on);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int ov9724_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse;
+	int ret;
+
+	/* the fine integration time is currently not calculated */
+	ret = ov9724_read_reg(client, OV9724_16BIT,
+			       OV9724_COARSE_INTEGRATION_TIME, &coarse);
+	*value = coarse;
+
+	return ret;
+}
+
+static int ov9724_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	int ret;
+	u32	vt_pix_clk_div;
+	u32	vt_sys_clk_div;
+	u32	pre_pll_clk_div;
+	u32	pll_multiplier;
+	u32	op_pix_clk_div;
+	u32	op_sys_clk_div;
+
+	const int ext_clk_freq_hz = 19200000;
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	int vt_pix_clk_freq_mhz;
+	u16 data[OV9724_INTG_BUF_COUNT];
+
+	u32 coarse_integration_time_min;
+	u32 coarse_integration_time_max_margin;
+	u32 fine_integration_time_min;
+	u32 fine_integration_time_max_margin;
+	u32 frame_length_lines;
+	u32 line_length_pck;
+	u32 read_mode;
+	u32 div;
+	u16 tmp;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	memset(data, 0, OV9724_INTG_BUF_COUNT * sizeof(u16));
+	ret = ov9724_read_reg(client, 2, OV9724_VT_PIX_CLK_DIV, data);
+	if (ret)
+		return ret;
+	ret = ov9724_read_reg(client, 1, OV9724_VT_PIX_CLK_DIV, &tmp);
+	if (ret)
+		return ret;
+
+	vt_pix_clk_div = data[0];
+	ret = ov9724_read_reg(client, 2, OV9724_VT_SYS_CLK_DIV, data);
+	if (ret)
+		return ret;
+	vt_sys_clk_div = data[0];
+	ret = ov9724_read_reg(client, 2, OV9724_PRE_PLL_CLK_DIV, data);
+	if (ret)
+		return ret;
+	pre_pll_clk_div = data[0];
+	ret = ov9724_read_reg(client, 2, OV9724_PLL_MULTIPLIER, data);
+	if (ret)
+		return ret;
+	pll_multiplier = data[0];
+
+	ret = ov9724_read_reg(client, 2, OV9724_OP_PIX_DIV, data);
+	if (ret)
+		return ret;
+	op_pix_clk_div = data[0];
+	ret = ov9724_read_reg(client, 2, OV9724_OP_SYS_DIV, data);
+	if (ret)
+		return ret;
+	op_sys_clk_div = data[0];
+
+	memset(data, 0, OV9724_INTG_BUF_COUNT * sizeof(u16));
+	ret = ov9724_read_reg(client, 4, OV9724_FRAME_LENGTH_LINES, data);
+	if (ret)
+		return ret;
+	ret = ov9724_read_reg(client, 1, OV9724_FRAME_LENGTH_LINES, &tmp);
+	if (ret)
+		return ret;
+
+	frame_length_lines = data[0];
+	line_length_pck = data[1];
+
+	memset(data, 0, OV9724_INTG_BUF_COUNT * sizeof(u16));
+	ret = ov9724_read_reg(client, 4, OV9724_COARSE_INTG_TIME_MIN, data);
+	if (ret)
+		return ret;
+	coarse_integration_time_min = data[0];
+	coarse_integration_time_max_margin = data[1];
+
+	memset(data, 0, OV9724_INTG_BUF_COUNT * sizeof(u16));
+	ret = ov9724_read_reg(client, 4, OV9724_FINE_INTG_TIME_MIN, data);
+	if (ret)
+		return ret;
+	fine_integration_time_min = data[0];
+	fine_integration_time_max_margin = data[1];
+
+	memset(data, 0, OV9724_INTG_BUF_COUNT * sizeof(u16));
+	ret = ov9724_read_reg(client, 2, OV9724_READ_MODE, data);
+	if (ret)
+		return ret;
+	read_mode = data[0];
+
+	div = pre_pll_clk_div*vt_sys_clk_div*vt_pix_clk_div;
+	if (div == 0)
+		return -EINVAL;
+	vt_pix_clk_freq_mhz = ext_clk_freq_hz*pll_multiplier/div;
+
+	dev->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf->coarse_integration_time_min = coarse_integration_time_min;
+	buf->coarse_integration_time_max_margin
+		= coarse_integration_time_max_margin;
+	buf->fine_integration_time_min = fine_integration_time_min;
+	buf->fine_integration_time_max_margin =
+					fine_integration_time_max_margin;
+	buf->fine_integration_time_def = fine_integration_time_max_margin;
+	buf->vt_pix_clk_freq_mhz = vt_pix_clk_freq_mhz;
+	buf->line_length_pck = line_length_pck;
+	buf->frame_length_lines = frame_length_lines;
+	buf->read_mode = read_mode;
+
+	buf->binning_factor_x = ov9724_res[dev->fmt_idx].bin_factor_x ? 2 : 1;
+	buf->binning_factor_y = ov9724_res[dev->fmt_idx].bin_factor_y ? 2 : 1;
+
+	/* Get the cropping and output resolution to ISP for this mode. */
+	ret =  ov9724_read_reg(client, 2, OV9724_HORIZONTAL_START_H, data);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = data[0];
+
+	ret = ov9724_read_reg(client, 2, OV9724_VERTICAL_START_H, data);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = data[0];
+
+	ret = ov9724_read_reg(client, 2, OV9724_HORIZONTAL_END_H, data);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_end = data[0];
+
+	ret = ov9724_read_reg(client, 2, OV9724_VERTICAL_END_H, data);
+	if (ret)
+		return ret;
+	buf->crop_vertical_end = data[0];
+
+	ret = ov9724_read_reg(client, 2, OV9724_HORIZONTAL_OUTPUT_SIZE_H, data);
+	if (ret)
+		return ret;
+	buf->output_width = data[0];
+
+	ret = ov9724_read_reg(client, 2, OV9724_VERTICAL_OUTPUT_SIZE_H, data);
+	if (ret)
+		return ret;
+	buf->output_height = data[0];
+
+	return 0;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 140
+static int distance(struct ov9724_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13) / w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct ov9724_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &ov9724_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != ov9724_res[i].width)
+			continue;
+		if (h != ov9724_res[i].height)
+			continue;
+		/* Found it */
+		return i;
+	}
+	return -1;
+}
+
+static int ov9724_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if ((fmt->width > OV9724_RES_WIDTH_MAX)
+		|| (fmt->height > OV9724_RES_HEIGHT_MAX)) {
+		fmt->width = OV9724_RES_WIDTH_MAX;
+		fmt->height = OV9724_RES_HEIGHT_MAX;
+	} else {
+		idx = nearest_resolution_index(fmt->width, fmt->height);
+
+		/*
+		 * nearest_resolution_index() doesn't return smaller
+		 *  resolutions. If it fails, it means the requested
+		 *  resolution is higher than wecan support. Fallback
+		 *  to highest possible resolution in this case.
+		 */
+		if (idx == -1)
+			idx = N_RES - 1;
+
+		fmt->width = ov9724_res[idx].width;
+		fmt->height = ov9724_res[idx].height;
+	}
+
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+
+	return 0;
+}
+
+static int ov9724_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	const struct ov9724_reg *ov9724_def_reg;
+	struct camera_mipi_info *ov9724_info = NULL;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 tmp;
+	int vflip, hflip;
+
+	ov9724_info = v4l2_get_subdev_hostdata(sd);
+	if (ov9724_info == NULL)
+		return -EINVAL;
+
+	ret = ov9724_try_mbus_fmt(sd, fmt);
+	if (ret) {
+		v4l2_err(sd, "try fmt fail\n");
+		return ret;
+	}
+
+	mutex_lock(&dev->input_lock);
+	dev->fmt_idx = get_resolution_index(fmt->width, fmt->height);
+
+	/* Sanity check */
+	if (unlikely(dev->fmt_idx == -1)) {
+		mutex_unlock(&dev->input_lock);
+		v4l2_err(sd, "get resolution fail\n");
+		return -EINVAL;
+	}
+
+	ov9724_def_reg = ov9724_res[dev->fmt_idx].regs;
+	/* enable group hold */
+	ret = ov9724_write_reg_array(client, ov9724_param_hold);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	ret = ov9724_write_reg_array(client, ov9724_def_reg);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+
+	/* disable group hold */
+	ret = ov9724_write_reg_array(client, ov9724_param_update);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+	dev->fps = ov9724_res[dev->fmt_idx].fps;
+	dev->pixels_per_line = ov9724_res[dev->fmt_idx].pixels_per_line;
+	dev->lines_per_frame = ov9724_res[dev->fmt_idx].lines_per_frame;
+	dev->coarse_itg = 0;
+	dev->fine_itg = 0;
+	dev->gain = 0;
+
+	ret = ov9724_read_reg(client, OV9724_8BIT,
+				OV9724_IMG_ORIENTATION, &tmp);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		return ret;
+	}
+	hflip = tmp & OV9724_HFLIP_BIT;
+	vflip = (tmp & OV9724_VFLIP_BIT) >> OV9724_VFLIP_OFFSET;
+	ov9724_info->raw_bayer_order =
+		ov9724_bayer_order_mapping[vflip][hflip];
+
+	ret = ov9724_get_intg_factor(client, ov9724_info);
+	mutex_unlock(&dev->input_lock);
+	if (ret) {
+		v4l2_err(sd, "failed to get integration_factor\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ov9724_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = ov9724_res[dev->fmt_idx].width;
+	fmt->height = ov9724_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov9724_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+
+	*val = (OV9724_FOCAL_LENGTH_NUM << 16) | OV9724_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int ov9724_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for ov9724*/
+	*val = (OV9724_F_NUMBER_DEFAULT_NUM << 16) | OV9724_F_NUMBER_DEM;
+	return 0;
+}
+
+static int ov9724_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+
+	*val = (OV9724_F_NUMBER_DEFAULT_NUM << 24) |
+		(OV9724_F_NUMBER_DEM << 16) |
+		(OV9724_F_NUMBER_DEFAULT_NUM << 8) | OV9724_F_NUMBER_DEM;
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int ov9724_t_hflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val;
+
+	/* enable group hold */
+	ret = ov9724_write_reg_array(c, ov9724_param_hold);
+
+	ret = ov9724_read_reg(c, OV9724_8BIT, OV9724_IMG_ORIENTATION, &val);
+	if (ret)
+		return ret;
+	if (value)
+		val |= OV9724_HFLIP_BIT;
+	else
+		val &= ~OV9724_HFLIP_BIT;
+	ret = ov9724_write_reg(c, OV9724_8BIT, OV9724_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
+
+	ret = ov9724_write_reg_array(c, ov9724_param_update);
+
+	return ret;
+}
+
+/* Vertically flip the image */
+static int ov9724_t_vflip(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val;
+
+	/* enable group hold */
+	ret = ov9724_write_reg_array(c, ov9724_param_hold);
+
+	ret = ov9724_read_reg(c, OV9724_8BIT, OV9724_IMG_ORIENTATION, &val);
+	if (ret)
+		return ret;
+	if (value)
+		val |= OV9724_VFLIP_BIT;
+	else
+		val &= ~OV9724_VFLIP_BIT;
+	ret = ov9724_write_reg(c, OV9724_8BIT, OV9724_IMG_ORIENTATION, val);
+	if (ret)
+		return ret;
+
+	ret = ov9724_write_reg_array(c, ov9724_param_update);
+	return ret;
+}
+
+static int ov9724_test_pattern(struct v4l2_subdev *sd, s32 value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return ov9724_write_reg(client, OV9724_8BIT,
+			OV9724_TEST_PATTERN_MODE, value);
+}
+
+static int ov9724_g_bin_factor_x(struct v4l2_subdev *sd, s32 *val)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	*val = ov9724_res[dev->fmt_idx].bin_factor_x;
+
+	return 0;
+}
+
+static int ov9724_g_bin_factor_y(struct v4l2_subdev *sd, s32 *val)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	*val = ov9724_res[dev->fmt_idx].bin_factor_y;
+
+	return 0;
+}
+
+
+static struct ov9724_control ov9724_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = ov9724_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image v-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov9724_t_vflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image h-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov9724_t_hflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_TEST_PATTERN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Test pattern",
+			.minimum = 0,
+			.maximum = 0xffff,
+			.step = 1,
+			.default_value = 0,
+		},
+		.tweak = ov9724_test_pattern,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = OV9724_FOCAL_LENGTH_DEFAULT,
+			.maximum = OV9724_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = OV9724_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov9724_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = OV9724_F_NUMBER_DEFAULT,
+			.maximum = OV9724_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = OV9724_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = ov9724_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = OV9724_F_NUMBER_RANGE,
+			.maximum =  OV9724_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = OV9724_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = ov9724_g_fnumber_range,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_HORZ,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "horizontal binning factor",
+			.minimum = 0,
+			.maximum = OV9724_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = ov9724_g_bin_factor_x,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_BIN_FACTOR_VERT,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "vertical binning factor",
+			.minimum = 0,
+			.maximum = OV9724_BIN_FACTOR_MAX,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = ov9724_g_bin_factor_y,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov9724_controls))
+
+static long __ov9724_set_exposure(struct v4l2_subdev *sd, u16 coarse_itg,
+				 u16 gain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	/* enable group hold */
+	ret = ov9724_write_reg_array(client, ov9724_param_hold);
+	if (ret)
+		goto out;
+
+	/* set coarse integration time */
+	if (coarse_itg > (dev->lines_per_frame - 5))
+		ov9724_write_reg(client, OV9724_16BIT,
+			OV9724_FRAME_LENGTH_LINES, coarse_itg + 5);
+	else
+		ov9724_write_reg(client, OV9724_16BIT,
+			OV9724_FRAME_LENGTH_LINES, dev->lines_per_frame);
+
+	ret = ov9724_write_reg(client, OV9724_16BIT,
+			OV9724_COARSE_INTEGRATION_TIME, coarse_itg);
+	if (ret)
+		goto out_disable;
+
+	/* set global gain */
+	ret = ov9724_write_reg(client, OV9724_8BIT,
+			OV9724_GLOBAL_GAIN, gain);
+	if (ret)
+		goto out_disable;
+	dev->gain       = gain;
+	dev->coarse_itg = coarse_itg;
+
+out_disable:
+	/* disable group hold */
+	ov9724_write_reg_array(client, ov9724_param_update);
+out:
+	return ret;
+}
+
+static int ov9724_set_exposure(struct v4l2_subdev *sd, u16 exposure, u16 gain)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __ov9724_set_exposure(sd, exposure, gain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+static long ov9724_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	u16 coarse_itg, gain;
+
+	coarse_itg = exposure->integration_time[0];
+	gain = exposure->gain[0];
+
+	return ov9724_set_exposure(sd, coarse_itg, gain);
+}
+
+static long ov9724_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return ov9724_s_exposure(sd, (struct atomisp_exposure *)arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct ov9724_control *ov9724_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (ov9724_controls[i].qc.id == id)
+			return &ov9724_controls[i];
+	}
+	return NULL;
+}
+
+static int ov9724_detect(struct i2c_client *client, u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 high, low, rev;
+
+	/* i2c check */
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	/* check sensor chip ID	 */
+	if (ov9724_read_reg(client, OV9724_8BIT, OV9724_PID_HIGH,
+			     &high)) {
+		v4l2_err(client, "sensor_id_high = 0x%x\n", high);
+		return -ENODEV;
+	}
+
+	if (ov9724_read_reg(client, OV9724_8BIT, OV9724_PID_LOW,
+			     &low)) {
+		v4l2_err(client, "sensor_id_low = 0x%x\n", low);
+		return -ENODEV;
+	}
+
+	*id = (((u8) high) << 8) | (u8) low;
+	v4l2_info(client, "sensor_id = 0x%x\n", *id);
+
+	if (*id != OV9724_MOD_ID) {
+		v4l2_err(client, "sensor ID error\n");
+		return -ENODEV;
+	}
+
+	v4l2_info(client, "detect ov9724 success\n");
+
+	if (ov9724_read_reg(client, OV9724_8BIT, OV9724_REV,
+			     &rev)) {
+		v4l2_err(client, "sensor_id_low = 0x%x\n", rev);
+		return -ENODEV;
+	}
+
+	/* TODO - need to be updated */
+	*revision = rev;
+
+	return 0;
+}
+
+static int
+ov9724_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id;
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			mutex_unlock(&dev->input_lock);
+			dev_err(&client->dev, "imx platform init err\n");
+			return ret;
+		}
+	}
+
+	ret = __ov9724_s_power(sd, 1);
+	if (ret) {
+		mutex_unlock(&dev->input_lock);
+		v4l2_err(client, "ov9724 power-up err");
+		return ret;
+	}
+
+	/* config & detect sensor */
+	ret = ov9724_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		v4l2_err(client, "ov9724_detect err s_config.\n");
+		goto fail_detect;
+	}
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = __ov9724_s_power(sd, 0);
+	mutex_unlock(&dev->input_lock);
+	if (ret) {
+		v4l2_err(client, "ov9724 power down err");
+		return ret;
+	}
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	__ov9724_s_power(sd, 0);
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int ov9724_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov9724_control *ctrl = ov9724_find_control(qc->id);
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (ctrl == NULL)
+		return -EINVAL;
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov9724_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov9724_control *octrl = ov9724_find_control(ctrl->id);
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	int ret;
+
+	if (octrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov9724_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov9724_control *octrl = ov9724_find_control(ctrl->id);
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	int ret;
+
+	if (!octrl || !octrl->tweak)
+		return -EINVAL;
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int ov9724_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int ret;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (enable) {
+		ret = ov9724_write_reg_array(client, ov9724_streaming);
+		if (ret != 0) {
+			mutex_unlock(&dev->input_lock);
+			v4l2_err(client, "write_reg_array err\n");
+			return ret;
+		}
+
+		dev->streaming = 1;
+	} else {
+		ret = ov9724_write_reg_array(client, ov9724_suspend);
+		if (ret != 0) {
+			mutex_unlock(&dev->input_lock);
+			v4l2_err(client, "write_reg_array err\n");
+			return ret;
+		}
+		dev->streaming = 0;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+/*
+ * ov9724 enum frame size, frame intervals
+ */
+static int ov9724_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov9724_res[index].width;
+	fsize->discrete.height = ov9724_res[index].height;
+	fsize->reserved[0] = ov9724_res[index].used;
+
+	return 0;
+}
+
+static int ov9724_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	int i;
+
+	/* since the isp will donwscale the resolution to the right size,
+	  * find the nearest one that will allow the isp to do so
+	  * important to ensure that the resolution requested is padded
+	  * correctly by the requester, which is the atomisp driver in
+	  * this case.
+	  */
+	i = nearest_resolution_index(fival->width, fival->height);
+
+	if (i == -1)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = ov9724_res[i].width;
+	fival->height = ov9724_res[i].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov9724_res[i].fps;
+
+	return 0;
+}
+
+static int ov9724_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
+{
+	if (index >= MAX_FMTS)
+		return -EINVAL;
+
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+
+static int
+ov9724_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV9724, 0);
+}
+
+static int
+ov9724_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int
+ov9724_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov9724_res[index].width;
+	fse->min_height = ov9724_res[index].height;
+	fse->max_width = ov9724_res[index].width;
+	fse->max_height = ov9724_res[index].height;
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__ov9724_get_pad_format(struct ov9724_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+ov9724_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__ov9724_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int
+ov9724_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+
+	return 0;
+}
+
+static int
+ov9724_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		ov9724_res = ov9724_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		ov9724_res = ov9724_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		ov9724_res = ov9724_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+int
+ov9724_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 lines_per_frame;
+	/*
+	 * if no specific information to calculate the fps,
+	 * just used the value in sensor settings
+	 */
+	if (!dev->pixels_per_line || !dev->lines_per_frame) {
+		interval->interval.numerator = 1;
+		interval->interval.denominator = dev->fps;
+		return 0;
+	}
+
+	/*
+	 * DS: if coarse_integration_time is set larger than
+	 * lines_per_frame the frame_size will be expanded to
+	 * coarse_integration_time+1
+	 */
+	if (dev->coarse_itg > dev->lines_per_frame) {
+		if (dev->coarse_itg == 0xFFFF) {
+			/*
+			 * we can not add 1 according to ds, as this will
+			 * cause over flow
+			 */
+			v4l2_warn(client, "%s: abnormal coarse_itg:0x%x\n",
+				  __func__, dev->coarse_itg);
+			lines_per_frame = dev->coarse_itg;
+		} else {
+			lines_per_frame = dev->coarse_itg + 1;
+		}
+	} else {
+		lines_per_frame = dev->lines_per_frame;
+	}
+
+	interval->interval.numerator = dev->pixels_per_line *
+					lines_per_frame;
+	interval->interval.denominator = dev->vt_pix_clk_freq_mhz;
+
+	return 0;
+}
+
+static int ov9724_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = ov9724_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops ov9724_sensor_ops = {
+	.g_skip_frames = ov9724_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops ov9724_video_ops = {
+	.try_mbus_fmt = ov9724_try_mbus_fmt,
+	.s_mbus_fmt = ov9724_set_mbus_fmt,
+	.s_stream = ov9724_s_stream,
+	.enum_framesizes = ov9724_enum_framesizes,
+	.enum_frameintervals = ov9724_enum_frameintervals,
+	.s_parm = ov9724_s_parm,
+	.g_mbus_fmt = ov9724_g_mbus_fmt,
+	.enum_mbus_fmt = ov9724_enum_mbus_fmt,
+	.g_frame_interval = ov9724_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops ov9724_core_ops = {
+	.g_chip_ident = ov9724_g_chip_ident,
+	.queryctrl = ov9724_queryctrl,
+	.g_ctrl = ov9724_g_ctrl,
+	.s_ctrl = ov9724_s_ctrl,
+	.ioctl = ov9724_ioctl,
+	.s_power = ov9724_s_power,
+	.init = ov9724_init,
+};
+
+static const struct v4l2_subdev_pad_ops ov9724_pad_ops = {
+	.enum_mbus_code = ov9724_enum_mbus_code,
+	.enum_frame_size = ov9724_enum_frame_size,
+	.get_fmt = ov9724_get_pad_format,
+	.set_fmt = ov9724_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops ov9724_ops = {
+	.core = &ov9724_core_ops,
+	.video = &ov9724_video_ops,
+	.pad = &ov9724_pad_ops,
+	.sensor = &ov9724_sensor_ops,
+};
+
+static const struct media_entity_operations ov9724_entity_ops = {
+	.link_setup = NULL,
+};
+
+static int ov9724_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov9724_device *dev = to_ov9724_sensor(sd);
+
+	dev->platform_data->csi_cfg(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	v4l2_device_unregister_subdev(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov9724_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct ov9724_device *dev;
+	int ret;
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		v4l2_err(client, "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov9724_ops);
+
+
+	if (client->dev.platform_data) {
+		ret = ov9724_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->sd.entity.ops = &ov9724_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		ov9724_remove(client);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+
+static const struct i2c_device_id ov9724_id[] = {
+	{OV9724_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ov9724_id);
+
+static struct i2c_driver ov9724_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV9724_NAME,
+	},
+	.probe = ov9724_probe,
+	.remove = ov9724_remove,
+	.id_table = ov9724_id,
+};
+
+
+static __init int init_ov9724(void)
+{
+	return i2c_add_driver(&ov9724_driver);
+}
+
+static __exit void exit_ov9724(void)
+{
+
+	i2c_del_driver(&ov9724_driver);
+}
+
+module_init(init_ov9724);
+module_exit(exit_ov9724);
+
+MODULE_DESCRIPTION("A low-level driver for OV9724 sensor");
+MODULE_AUTHOR("Shenbo Huang <shenbo.huang@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov9724.h b/drivers/external_drivers/camera/drivers/media/i2c/ov9724.h
new file mode 100644
index 0000000..922eba3
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov9724.h
@@ -0,0 +1,1457 @@
+/*
+ * Support for Sony OV9724 camera sensor.
+ *
+ * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __OV9724_H__
+#define __OV9724_H__
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define OV9724_NAME	"ov9724"
+#define V4L2_IDENT_OV9724 8245
+
+/* Defines for register writes and register array processing */
+#define OV9724_BYTE_MAX	30
+#define OV9724_SHORT_MAX	16
+#define I2C_MSG_LENGTH		0x2
+#define I2C_RETRY_COUNT		5
+
+#define OV9724_READ_MODE	0x3820
+#define OV9724_TEST_PATTERN_MODE			0x0601
+
+#define OV9724_HFLIP_BIT	0x1
+#define OV9724_VFLIP_BIT	0x2
+#define OV9724_VFLIP_OFFSET	1
+#define OV9724_IMG_ORIENTATION	0x0101
+
+#define I2C_RETRY_COUNT		5
+#define MAX_FMTS		1
+
+#define OV9724_PID_LOW		0x1
+#define OV9724_PID_HIGH		0x0
+#define OV9724_REV		0x2
+#define OV9724_MOD_ID		0x9724
+
+#define OV9724_RES_WIDTH_MAX	1296
+#define OV9724_RES_HEIGHT_MAX	736
+
+#define OV9724_FOCAL_LENGTH_NUM	166	/*1.66mm*/
+#define OV9724_FOCAL_LENGTH_DEM	100
+#define OV9724_F_NUMBER_DEFAULT_NUM	280
+#define OV9724_F_NUMBER_DEM	100
+
+#define OV9724_COARSE_INTEGRATION_TIME		0x0202
+#define OV9724_GLOBAL_GAIN			0x0205
+
+#define OV9724_INTG_BUF_COUNT		2
+
+#define OV9724_VT_PIX_CLK_DIV			0x0300
+#define OV9724_VT_SYS_CLK_DIV			0x0302
+#define OV9724_PRE_PLL_CLK_DIV			0x0304
+#define OV9724_PLL_MULTIPLIER			0x0306
+#define OV9724_OP_PIX_DIV			0x0300
+#define OV9724_OP_SYS_DIV			0x0302
+#define OV9724_FRAME_LENGTH_LINES		0x0340
+#define OV9724_COARSE_INTG_TIME_MIN		0x1004
+#define OV9724_FINE_INTG_TIME_MIN		0x1008
+
+#define OV9724_BIN_FACTOR_MAX			1
+#define OV9724_MCLK		192
+
+#define OV9724_HORIZONTAL_START_H 0x0344
+#define OV9724_VERTICAL_START_H 0x0346
+#define OV9724_HORIZONTAL_END_H 0x0348
+#define OV9724_VERTICAL_END_H 0x034a
+#define OV9724_HORIZONTAL_OUTPUT_SIZE_H 0x034c
+#define OV9724_VERTICAL_OUTPUT_SIZE_H 0x034e
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV9724_FOCAL_LENGTH_DEFAULT 0xA60064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define OV9724_F_NUMBER_DEFAULT 0x1200064
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define OV9724_F_NUMBER_RANGE 0x1D0a1D0a
+
+#define	v4l2_format_capture_type_entry(_width, _height, \
+		_pixelformat, _bytesperline, _colorspace) \
+	{\
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,\
+		.fmt.pix.width = (_width),\
+		.fmt.pix.height = (_height),\
+		.fmt.pix.pixelformat = (_pixelformat),\
+		.fmt.pix.bytesperline = (_bytesperline),\
+		.fmt.pix.colorspace = (_colorspace),\
+		.fmt.pix.sizeimage = (_height)*(_bytesperline),\
+	}
+
+#define	s_output_format_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps) \
+	{\
+		.v4l2_fmt = v4l2_format_capture_type_entry(_width, \
+			_height, _pixelformat, _bytesperline, \
+				_colorspace),\
+		.fps = (_fps),\
+	}
+
+#define	s_output_format_reg_entry(_width, _height, _pixelformat, \
+		_bytesperline, _colorspace, _fps, _reg_setting) \
+	{\
+		.s_fmt = s_output_format_entry(_width, _height,\
+				_pixelformat, _bytesperline, \
+				_colorspace, _fps),\
+		.reg_setting = (_reg_setting),\
+	}
+
+struct s_ctrl_id {
+	struct v4l2_queryctrl qc;
+	int (*s_ctrl)(struct v4l2_subdev *sd, u32 val);
+	int (*g_ctrl)(struct v4l2_subdev *sd, u32 *val);
+};
+
+#define	v4l2_queryctrl_entry_integer(_id, _name,\
+		_minimum, _maximum, _step, \
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_INTEGER, \
+		.name = _name, \
+		.minimum = (_minimum), \
+		.maximum = (_maximum), \
+		.step = (_step), \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+#define	v4l2_queryctrl_entry_boolean(_id, _name,\
+		_default_value, _flags)	\
+	{\
+		.id = (_id), \
+		.type = V4L2_CTRL_TYPE_BOOLEAN, \
+		.name = _name, \
+		.minimum = 0, \
+		.maximum = 1, \
+		.step = 1, \
+		.default_value = (_default_value),\
+		.flags = (_flags),\
+	}
+
+#define	s_ctrl_id_entry_integer(_id, _name, \
+		_minimum, _maximum, _step, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_integer(_id, _name,\
+				_minimum, _maximum, _step,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+#define	s_ctrl_id_entry_boolean(_id, _name, \
+		_default_value, _flags, \
+		_s_ctrl, _g_ctrl)	\
+	{\
+		.qc = v4l2_queryctrl_entry_boolean(_id, _name,\
+				_default_value, _flags), \
+		.s_ctrl = _s_ctrl, \
+		.g_ctrl = _g_ctrl, \
+	}
+
+enum ov9724_tok_type {
+	OV9724_8BIT  = 0x0001,
+	OV9724_16BIT = 0x0002,
+	OV9724_RMW   = 0x0010,
+	OV9724_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	OV9724_TOK_DELAY  = 0xfe00, /* delay token for reg list */
+	OV9724_TOK_MASK = 0xfff0
+};
+
+/*
+ * If register address or register width is not 32 bit width,
+ * user needs to convert it manually
+ */
+
+struct s_register_setting {
+	u32 reg;
+	u32 val;
+};
+
+struct s_output_format {
+	struct v4l2_format v4l2_fmt;
+	int fps;
+};
+
+/**
+ * struct ov9724_fwreg - Fisare burst command
+ * @type: FW burst or 8/16 bit register
+ * @addr: 16-bit offset to register or other values depending on type
+ * @val: data value for burst (or other commands)
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov9724_fwreg {
+	enum ov9724_tok_type type; /* value, register or FW burst string */
+	u16 addr;	/* target address */
+	u32 val[8];
+};
+
+/**
+ * struct ov9724_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct ov9724_reg {
+	enum ov9724_tok_type type;
+	union {
+		u16 sreg;
+		struct ov9724_fwreg *fwreg;
+	} reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_ov9724_sensor(x) container_of(x, struct ov9724_device, sd)
+
+#define OV9724_MAX_WRITE_BUF_SIZE	30
+struct ov9724_write_buffer {
+	u16 addr;
+	u8 data[OV9724_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov9724_write_ctrl {
+	int index;
+	struct ov9724_write_buffer buffer;
+};
+
+
+struct ov9724_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct camera_sensor_platform_data *platform_data;
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	int fmt_idx;
+	int status;
+	int streaming;
+	int power;
+	int run_mode;
+	int vt_pix_clk_freq_mhz;
+	u16 sensor_id;
+	u16 coarse_itg;
+	u16 fine_itg;
+	u16 gain;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 fps;
+	u8 res;
+	u8 type;
+	u8 sensor_revision;
+};
+
+struct ov9724_format_struct {
+	u8 *desc;
+	struct regval_list *regs;
+	u32 pixelformat;
+};
+
+struct ov9724_resolution {
+	u8 *desc;
+	const struct ov9724_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	unsigned short pixels_per_line;
+	unsigned short lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	bool used;
+	u32 skip_frames;
+};
+
+struct ov9724_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+
+/************************** settings for ov9724 *************************/
+static struct ov9724_reg const ov9724_1040_592_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x7e},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x44},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x8d},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0x97},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x04},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x10},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x50},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+static struct ov9724_reg const ov9724_736_496_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x01},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x1e},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x98},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x55},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0x9b},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x02},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0xe0},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x01},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xf0},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+static struct ov9724_reg const ov9724_656_496_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x01},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x1e},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x98},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x55},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0x9b},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x02},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x90},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x01},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xf0},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_368_304_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x00},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0xff},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xcf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x01},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x70},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x01},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x30},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x20},
+	{OV9724_8BIT, {0x4909},	0x14},
+	{OV9724_8BIT, {0x3811},	0xf8},
+	{OV9724_8BIT, {0x3813},	0x3e},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x03},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x03},
+	{OV9724_8BIT, {0x3821},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x3820},	0xa1},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+static struct ov9724_reg const ov9724_336_256_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x10},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x14},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0xff},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xcf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x01},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x50},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x01},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x00},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x20},
+	{OV9724_8BIT, {0x4909},	0x14},
+	{OV9724_8BIT, {0x3811},	0xf8},
+	{OV9724_8BIT, {0x3813},	0x3e},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x03},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x03},
+	{OV9724_8BIT, {0x3821},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x3820},	0xa1},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+static struct ov9724_reg const ov9724_848_616_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0xe6},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x34},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x55},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0x9b},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x03},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x50},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x68},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+static struct ov9724_reg const ov9724_444_348_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x00},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0xff},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xcf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x01},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0xc0},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x01},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x5c},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x20},
+	{OV9724_8BIT, {0x4909},	0x14},
+	{OV9724_8BIT, {0x3811},	0x10},
+	{OV9724_8BIT, {0x3813},	0x0a},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x03},
+	{OV9724_8BIT, {0x3821},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x3820},	0xa1},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+static struct ov9724_reg const ov9724_936_602_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0xae},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x44},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x9d},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xa6},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x03},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0xa8},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x5a},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_720p_15fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x00},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x05},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x0b},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xdb},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x05},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x0c},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xdc},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x05},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0xf0},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x06},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x28},/* Horizontal length - Low */
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+
+	{OV9724_8BIT, {0x0202},	0x02},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0xf0},/* Integration time - Low */
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_8BIT, {0x0205},	0x3f},/* Analog gain - Low */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_960x720_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0xa0},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x6f},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xdf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x03},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0xd0},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xe0},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x10},
+	{OV9724_8BIT, {0x4909},	0x04},
+	{OV9724_8BIT, {0x3811},	0x08},
+	{OV9724_8BIT, {0x3813},	0x02},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+
+static struct ov9724_reg const ov9724_720p_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x00},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x05},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x0f},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xdf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x05},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x10},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xe0},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x10},
+	{OV9724_8BIT, {0x4909},	0x04},
+	{OV9724_8BIT, {0x3811},	0x08},
+	{OV9724_8BIT, {0x3813},	0x02},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_D1NTSC_strong_dvs_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0xae},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x44},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x9d},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xa6},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x03},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x88},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x5a},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_D1PAL_strong_dvs_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0xc8},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x06},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x37},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xc9},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x03},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x70},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xc4},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4801},	0x8f},/* Mipi ctrl01 */
+	{OV9724_8BIT, {0x4814},	0x2b},/* Mipi ctrl14 */
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},/* Isp ctrl0 */
+	{OV9724_8BIT, {0x5001},	0x73},/* Isp ctrl1 */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_VGA_strong_dvs_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0xe6},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x34},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x55},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0x9b},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x03},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x34},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x68},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},
+	{OV9724_8BIT, {0x4801},	0x8f},
+	{OV9724_8BIT, {0x4814},	0x2b},
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},
+	{OV9724_8BIT, {0x5001},	0x73},
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_WIDE_PREVIEW_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x7e},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x44},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0x8d},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0x97},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x04},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x10},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x02},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x54},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x14},
+	{OV9724_8BIT, {0x4909},	0x08},
+	{OV9724_8BIT, {0x3811},	0x0a},
+	{OV9724_8BIT, {0x3813},	0x04},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x01},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x01},
+	{OV9724_8BIT, {0x3821},	0x00},
+	{OV9724_8BIT, {0x4501},	0x08},
+	{OV9724_8BIT, {0x3820},	0xa0},
+
+	{OV9724_8BIT, {0x4801},	0x0f},
+	{OV9724_8BIT, {0x4801},	0x8f},
+	{OV9724_8BIT, {0x4814},	0x2b},
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},
+	{OV9724_8BIT, {0x5001},	0x73},
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+
+static struct ov9724_reg const ov9724_QVGA_strong_dvs_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x00},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0xff},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xcf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x01},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0x98},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x01},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0x34},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x20},
+	{OV9724_8BIT, {0x4909},	0x14},
+	{OV9724_8BIT, {0x3811},	0xf8},
+	{OV9724_8BIT, {0x3813},	0x3e},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x03},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x0385},	0x01},
+	{OV9724_8BIT, {0x0387},	0x03},
+	{OV9724_8BIT, {0x3821},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x3820},	0xa1},
+
+	{OV9724_8BIT, {0x4801},	0x0f},
+	{OV9724_8BIT, {0x4801},	0x8f},
+	{OV9724_8BIT, {0x4814},	0x2b},
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0x23},
+
+	{OV9724_8BIT, {0x5000},	0x06},
+	{OV9724_8BIT, {0x5001},	0x73},
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_QCIF_strong_dvs_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x00},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0xff},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xcf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x00},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0xd8},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x00},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xb0},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x20},
+	{OV9724_8BIT, {0x4909},	0x14},
+	{OV9724_8BIT, {0x3811},	0xe0},
+	{OV9724_8BIT, {0x3813},	0x12},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+
+	{OV9724_8BIT, {0x0383},	0x07},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x0385},	0x05},
+	{OV9724_8BIT, {0x0387},	0x03},
+	{OV9724_8BIT, {0x3821},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x3820},	0xa1},
+
+
+	{OV9724_8BIT, {0x4801},	0x0f},
+	{OV9724_8BIT, {0x4801},	0x8f},
+	{OV9724_8BIT, {0x4814},	0x2b},
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0xa2},
+
+
+	{OV9724_8BIT, {0x5000},	0x06},
+	{OV9724_8BIT, {0x5001},	0x73},
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_LOW_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x00},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0xff},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xcf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x00},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0xd0},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x00},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xa0},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x20},
+	{OV9724_8BIT, {0x4909},	0x14},
+	{OV9724_8BIT, {0x3811},	0xe0},
+	{OV9724_8BIT, {0x3813},	0x12},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x07},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x0385},	0x05},
+	{OV9724_8BIT, {0x0387},	0x03},
+	{OV9724_8BIT, {0x3821},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x3820},	0xa1},
+
+	{OV9724_8BIT, {0x4801},	0x0f},
+	{OV9724_8BIT, {0x4801},	0x8f},
+	{OV9724_8BIT, {0x4814},	0x2b},
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0xa2},
+
+	{OV9724_8BIT, {0x5000},	0x06},
+	{OV9724_8BIT, {0x5001},	0x73},
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_QCIF_30fps[] = {
+	{OV9724_8BIT, {0x0344},	0x00},/* Horizontal start - Hi */
+	{OV9724_8BIT, {0x0345},	0x20},/* Horizontal start - Low */
+	{OV9724_8BIT, {0x0346},	0x00},/* Vertical start - Hi */
+	{OV9724_8BIT, {0x0347},	0x00},/* Vertical start - Low */
+	{OV9724_8BIT, {0x0348},	0x04},/* Horizontal end - Hi */
+	{OV9724_8BIT, {0x0349},	0xff},/* Horizontal end - Low */
+	{OV9724_8BIT, {0x034a},	0x02},/* Vertical end - Hi */
+	{OV9724_8BIT, {0x034b},	0xcf},/* Vertical end - Low */
+	{OV9724_8BIT, {0x034c},	0x00},/* Image width - Hi */
+	{OV9724_8BIT, {0x034d},	0xc0},/* Image width - Low */
+	{OV9724_8BIT, {0x034e},	0x00},/* Image Height - Hi */
+	{OV9724_8BIT, {0x034f},	0xa0},/* Image Height - Low */
+	{OV9724_8BIT, {0x4908},	0x20},
+	{OV9724_8BIT, {0x4909},	0x14},
+	{OV9724_8BIT, {0x3811},	0xe0},
+	{OV9724_8BIT, {0x3813},	0x12},
+	{OV9724_8BIT, {0x0340},	0x03},/* Vertical length - Hi */
+	{OV9724_8BIT, {0x0341},	0x68},/* Vertical length - Low */
+	{OV9724_8BIT, {0x0342},	0x05},/* Horizontal length - Hi */
+	{OV9724_8BIT, {0x0343},	0x60},/* Horizontal length - Low */
+
+	{OV9724_8BIT, {0x0301},	0x0a},
+	{OV9724_8BIT, {0x0303},	0x02},
+	{OV9724_8BIT, {0x0305},	0x02},/* Pre-pll divider -Low */
+	{OV9724_8BIT, {0x0307},	0x4b},/* Pll multi -Low */
+	{OV9724_8BIT, {0x0310},	0x00},
+
+	{OV9724_8BIT, {0x0202},	0x01},/* Integration time - Hi */
+	{OV9724_8BIT, {0x0203},	0x80},/* Integration time - Low */
+	{OV9724_8BIT, {0x0205},	0x3f},
+
+	{OV9724_8BIT, {0x0383},	0x07},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x0385},	0x05},
+	{OV9724_8BIT, {0x0387},	0x03},
+	{OV9724_8BIT, {0x3821},	0x01},
+	{OV9724_8BIT, {0x4501},	0x09},
+	{OV9724_8BIT, {0x3820},	0xa1},
+
+	{OV9724_8BIT, {0x4801},	0x0f},
+	{OV9724_8BIT, {0x4801},	0x8f},
+	{OV9724_8BIT, {0x4814},	0x2b},
+	{OV9724_8BIT, {0x4307},	0x3a},
+	{OV9724_8BIT, {0x370a},	0xa2},
+
+	{OV9724_8BIT, {0x5000},	0x06},
+	{OV9724_8BIT, {0x5001},	0x73},
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+/* TODO settings of preview/still/video will be updated with new use case */
+struct ov9724_resolution ov9724_res_preview[] = {
+	{
+		.desc = "ov9724_960x720_30fps",
+		.regs = ov9724_960x720_30fps,
+		.width = 976,
+		.height = 736,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+	{
+		.desc = "ov9724_720p_30fps",
+		.regs = ov9724_720p_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(ov9724_res_preview))
+
+struct ov9724_resolution ov9724_res_still[] = {
+	{
+		.desc = "ov9724_960x720_30fps",
+		.regs = ov9724_960x720_30fps,
+		.width = 976,
+		.height = 736,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+	{
+		.desc = "ov9724_720p_30fps",
+		.regs = ov9724_720p_30fps,
+		.width = 1296,
+		.height = 736,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(ov9724_res_still))
+
+struct ov9724_resolution ov9724_res_video[] = {
+	{
+		.desc = "QCIF_30fps",
+		.regs = ov9724_QCIF_30fps,
+		.width = 192,
+		.height = 160,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.used = 0,
+		.skip_frames = 0,
+	},
+	{
+		.desc = "VGA_strong_dvs_30fps",
+		.regs = ov9724_336_256_30fps,
+		.width = 336,
+		.height = 256,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+	{
+		.desc = "VGA_strong_dvs_30fps",
+		.regs = ov9724_368_304_30fps,
+		.width = 368,
+		.height = 304,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+	{
+		.desc = "VGA_strong_dvs_30fps",
+		.regs = ov9724_656_496_30fps,
+		.width = 656,
+		.height = 496,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+	{
+		.desc = "VGA_strong_dvs_30fps",
+		.regs = ov9724_736_496_30fps,
+		.width = 736,
+		.height = 496,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+	{
+		.desc = "ov9724_720p_30fps",
+		.regs = ov9724_720p_30fps,
+		.width = 1296,
+		.height =	736,
+		.fps = 30,
+		.pixels_per_line = 0x0560, /* consistent with regs arrays */
+		.lines_per_frame = 0x0368, /* consistent with regs arrays */
+		.bin_factor_x = 0,
+		.bin_factor_y = 0,
+		.used = 0,
+		.skip_frames = 0,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(ov9724_res_video))
+
+struct ov9724_resolution *ov9724_res = ov9724_res_preview;
+static int N_RES = N_RES_PREVIEW;
+
+
+static struct ov9724_reg const ov9724_suspend[] = {
+	 {OV9724_8BIT,  {0x0100}, 0x0},
+	 {OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_streaming[] = {
+	 {OV9724_8BIT,  {0x0100}, 0x1},
+	 {OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_param_hold[] = {
+	{OV9724_8BIT,  {0x0104}, 0x1},	/* GROUPED_PARAMETER_HOLD */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+static struct ov9724_reg const ov9724_param_update[] = {
+	{OV9724_8BIT,  {0x0104}, 0x0},	/* GROUPED_PARAMETER_HOLD */
+	{OV9724_TOK_TERM, {0}, 0}
+};
+
+/* init settings */
+static struct ov9724_reg const ov9724_init_config[] = {
+	{OV9724_8BIT, {0x0103},	0x01},/* Soft reset */
+	{OV9724_8BIT, {0x3210},	0x43},
+	{OV9724_8BIT, {0x3606},	0x75},
+	{OV9724_8BIT, {0x3705},	0x41},
+	{OV9724_8BIT, {0x3601},	0x34},
+	{OV9724_8BIT, {0x3607},	0x94},
+	{OV9724_8BIT, {0x3608},	0x20},
+	{OV9724_TOK_TERM, {0}, 0}
+};
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/pixter.c b/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
new file mode 100644
index 0000000..275d35f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/pixter.c
@@ -0,0 +1,1046 @@
+/*
+ * Support for mipi CSI data generator.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <asm/div64.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "pixter.h"
+
+#define to_pixter_dev(sd) container_of(sd, struct pixter_device, sd)
+#define dev_off(m) offsetof(struct pixter_device, m)
+
+static struct regmap_config pixter_reg_config = {
+	.reg_bits = 8,
+	.val_bits = 32,
+	.val_format_endian = REGMAP_ENDIAN_NATIVE,
+};
+
+static struct pixter_format_bridge format_bridge[] = {
+	{"", 0, ATOMISP_INPUT_FORMAT_BINARY_8, 8},
+	{"RGGB10", V4L2_MBUS_FMT_SRGGB10_1X10, ATOMISP_INPUT_FORMAT_RAW_10, 10},
+	{"GRBG10", V4L2_MBUS_FMT_SGRBG10_1X10, ATOMISP_INPUT_FORMAT_RAW_10, 10},
+	{"GBRG10", V4L2_MBUS_FMT_SGBRG10_1X10, ATOMISP_INPUT_FORMAT_RAW_10, 10},
+	{"BGGR10", V4L2_MBUS_FMT_SBGGR10_1X10, ATOMISP_INPUT_FORMAT_RAW_10, 10},
+	{"RGGB8", V4L2_MBUS_FMT_SRGGB10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"GRBG8", V4L2_MBUS_FMT_SGRBG10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"GBRG8", V4L2_MBUS_FMT_SGBRG10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"BGGR8", V4L2_MBUS_FMT_SBGGR10_1X10, ATOMISP_INPUT_FORMAT_RAW_8, 8},
+	{"YUV422_8", V4L2_MBUS_FMT_UYVY8_1X16, ATOMISP_INPUT_FORMAT_YUV422_8, 16},
+	{"YUV420_8", 0x8001/*For YUV420*/, ATOMISP_INPUT_FORMAT_YUV420_8, 16},
+};
+
+static u32 port_to_channel[4] = {1, 0, 2, 0};
+
+static struct pixter_dbgfs dbgfs[] = {
+	{"root", NULL, DBGFS_DIR, 0},
+	{"fps", "root", DBGFS_DIR, 0},
+	{"blank", "root", DBGFS_DIR, 0},
+	{"timing", "root", DBGFS_DIR, 0},
+	{"fps_ovrd", "fps", DBGFS_FILE, dev_off(dbg_fps.fps_ovrd)},
+	{"fps", "fps", DBGFS_FILE, dev_off(dbg_fps.fps)},
+	{"blank_ovrd", "blank", DBGFS_FILE, dev_off(dbg_blank.blank_ovrd)},
+	{"h_blank", "blank", DBGFS_FILE, dev_off(dbg_blank.h_blank)},
+	{"v_blank_pre", "blank", DBGFS_FILE, dev_off(dbg_blank.v_blank_pre)},
+	{"v_blank_post", "blank", DBGFS_FILE, dev_off(dbg_blank.v_blank_post)},
+	{"mipi_clk", "timing", DBGFS_FILE, dev_off(dbg_timing.mipi_clk)},
+	{"cont_hs_clk", "timing", DBGFS_FILE, dev_off(dbg_timing.cont_hs_clk)},
+	{"timing_ovrd", "timing", DBGFS_FILE, dev_off(dbg_timing.timing_ovrd)},
+	{"pre", "timing", DBGFS_FILE, dev_off(dbg_timing.pre)},
+	{"post", "timing", DBGFS_FILE, dev_off(dbg_timing.post)},
+	{"gap", "timing", DBGFS_FILE, dev_off(dbg_timing.gap)},
+	{"ck_lpx", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_lpx)},
+	{"ck_prep", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_prep)},
+	{"ck_zero", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_zero)},
+	{"ck_trail", "timing", DBGFS_FILE, dev_off(dbg_timing.ck_trail)},
+	{"dat_lpx", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_lpx)},
+	{"dat_prep", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_prep)},
+	{"dat_zero", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_zero)},
+	{"dat_trail", "timing", DBGFS_FILE, dev_off(dbg_timing.dat_trail)},
+	{"twakeup", "timing", DBGFS_FILE, dev_off(dbg_timing.twakeup)},
+};
+
+static u32 pixter_get_tx_freq_sel(u32 freq)
+{
+	u32 sel;
+
+	freq /= 1000000; /* To MHz */
+	if (freq < 20) {
+		sel = 1;
+	} else if (freq <= 100) {
+		sel = (freq + 9) / 10 - 1;
+	} else if (freq <= 750) {
+		sel = (freq + 24) / 25 + 5;
+	} else {
+		sel = 35;
+	}
+
+	return sel;
+}
+
+static int pixter_read_reg(struct v4l2_subdev *sd, u32 reg, u32 *val)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (!dev->regmap)
+		return -EIO;
+
+	ret = regmap_write(dev->regmap, PIXTER_I2C_ADDR, reg | 1);
+	ret |= regmap_read(dev->regmap, PIXTER_I2C_DATA_R, val);
+	if (ret) {
+		dev_dbg(&client->dev, "Read reg failed. reg=0x%04X\n", reg);
+		return ret;
+	}
+	dev_dbg(&client->dev, "read_reg[0x%04X] = 0x%08X\n",
+		reg, *val);
+	return ret;
+}
+
+static int pixter_write_reg(struct v4l2_subdev *sd, u32 reg, u32 val)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (!dev->regmap)
+		return -EIO;
+
+	ret = regmap_write(dev->regmap, PIXTER_I2C_DATA_W, val);
+	ret |= regmap_write(dev->regmap, PIXTER_I2C_ADDR, reg);
+	if (ret) {
+		dev_dbg(&client->dev, "Write reg failed. reg=0x%04X\n", reg);
+		return ret;
+	}
+	dev_dbg(&client->dev, "write_reg[0x%04X] = 0x%08X\n",
+		reg, (u32)val);
+	return ret;
+}
+
+static int pixter_read_buf(struct v4l2_subdev *sd,
+			u32 addr, u32 size, void *buf)
+{
+	u32 i;
+	int ret = 0;
+
+	for (i = 0; i < size; i += 4) {
+		ret = pixter_read_reg(sd, addr + i, (u32*)((u8*)buf + i));
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
+static int pixter_read_mipi_timing(struct v4l2_subdev *sd)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	u32 reg_val, ch;
+	ch = port_to_channel[dev->mipi_info->port];
+	pixter_read_reg(sd, PIXTER_TX_CTRL_TIMING(ch), &reg_val);
+	dev->dbg_timing.pre = reg_val & 0x7F;
+	dev->dbg_timing.post = (reg_val >> 8) & 0x7F;
+	dev->dbg_timing.gap = (reg_val >> 16) & 0x7F;
+	pixter_read_reg(sd, PIXTER_TX_CK_TIMING(ch), &reg_val);
+	dev->dbg_timing.ck_lpx = reg_val & 0x7F;
+	dev->dbg_timing.ck_prep = (reg_val >> 8) & 0x7F;
+	dev->dbg_timing.ck_zero = (reg_val >> 16) & 0x7F;
+	dev->dbg_timing.ck_trail = (reg_val >> 24) & 0x7F;
+	pixter_read_reg(sd, PIXTER_TX_DAT_TIMING(ch), &reg_val);
+	dev->dbg_timing.dat_lpx = reg_val & 0x7F;
+	dev->dbg_timing.dat_prep = (reg_val >> 8) & 0x7F;
+	dev->dbg_timing.dat_zero = (reg_val >> 16) & 0x7F;
+	dev->dbg_timing.dat_trail = (reg_val >> 24) & 0x7F;
+	pixter_read_reg(sd, PIXTER_TX_ULPS_TIMING(ch), &reg_val);
+	dev->dbg_timing.twakeup = reg_val & 0x7FFFF;
+	return 0;
+}
+
+static int pixter_config_rx(struct v4l2_subdev *sd)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct pixter_setting *setting;
+	u32 h_blank, v_blank_pre, v_blank_post;
+	u32 i, reg_val, ch, vc = 0;
+	u32 line_interval;
+	u32 width_bits;
+	u32 bit_rate;
+	u32 line_bits;
+
+	setting = &dev->settings[dev->cur_setting];
+	ch = port_to_channel[dev->mipi_info->port];
+
+	/* Set setting start and end address in DDR SDRAM. */
+	pixter_write_reg(sd, PIXTER_RDR_START(ch), setting->start);
+	pixter_write_reg(sd, PIXTER_RDR_END(ch), setting->end);
+
+	/* Set FPS. */
+	if (dev->dbg_fps.fps_ovrd)
+		reg_val = dev->dbg_fps.fps << 24;
+	else
+		reg_val = setting->vc[setting->def_vc].fps << 24;
+
+	if (setting->block_mode)
+		reg_val |= PIXTER_DFT_BLOCK_MODE;
+
+	if (dev->caps->sensor[0].stream_num > 1) {
+		/* Select the channel with the largest width. */
+		for (i = 1; i < 4; i++) {
+			if (setting->vc[i].width > setting->vc[vc].width)
+				vc = i;
+		}
+	}
+	width_bits = setting->vc[vc].width *
+		format_bridge[setting->vc[vc].format].bpp;
+	bit_rate = dev->dbg_timing.mipi_clk / 1000000 * 2 *
+		dev->mipi_info->num_lanes;
+	if (bit_rate == 0 || bit_rate > PIXTER_MAX_BITRATE_MBPS) {
+		dev_err(&client->dev, "Invalid bit rate %dMbps.\n", bit_rate);
+		return -EINVAL;
+	}
+
+	if (dev->dbg_blank.blank_ovrd) {
+		h_blank = dev->dbg_blank.h_blank;
+		line_bits = 1000 * (width_bits + h_blank *
+                        format_bridge[setting->vc[vc].format].bpp);
+		line_interval = line_bits / bit_rate;
+		v_blank_pre = dev->dbg_blank.v_blank_pre;
+		v_blank_post = dev->dbg_blank.v_blank_post;
+	} else {
+		line_bits = 1200 * width_bits;
+		line_interval = line_bits / bit_rate;
+		v_blank_pre = PIXTER_DEF_VBPRE;
+		v_blank_post = line_interval;
+	}
+
+	/* Set line interval */
+	reg_val |= (line_interval / 8) << 8;
+	pixter_write_reg(sd, PIXTER_DFT_CTRL(ch), reg_val);
+
+	/* Set vertical blanking */
+	reg_val = ((v_blank_post / 8) << 16) + v_blank_pre / 8;
+	pixter_write_reg(sd, PIXTER_VERT_BLANK(ch), reg_val);
+
+	return 0;
+}
+
+static int pixter_config_tx(struct v4l2_subdev *sd)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 reg_val, ch;
+	u32 cnt = 500;
+
+	/* Set the parameters in the tx_csi2_ctrl. */
+	ch = port_to_channel[dev->mipi_info->port];
+	reg_val = dev->mipi_info->num_lanes - 1;
+	reg_val |= (dev->dbg_timing.cont_hs_clk << 4);
+	if (!dev->dbg_timing.timing_ovrd)
+		reg_val |= 1 << 8;
+	pixter_write_reg(sd, PIXTER_TX_CSI2_CTRL(ch), reg_val);
+
+	/* Set MIPI timing if overided. */
+	if (dev->dbg_timing.timing_ovrd) {
+		reg_val = dev->dbg_timing.pre;
+		reg_val |= dev->dbg_timing.post << 8;
+		reg_val |= dev->dbg_timing.gap << 16;
+		pixter_write_reg(sd, PIXTER_TX_CTRL_TIMING(ch), reg_val);
+		reg_val = dev->dbg_timing.ck_lpx;
+		reg_val |= dev->dbg_timing.ck_prep << 8;
+		reg_val |= dev->dbg_timing.ck_zero << 16;
+		reg_val |= dev->dbg_timing.ck_trail << 24;
+		pixter_write_reg(sd, PIXTER_TX_CK_TIMING(ch), reg_val);
+		reg_val = dev->dbg_timing.dat_lpx;
+		reg_val |= dev->dbg_timing.dat_prep << 8;
+		reg_val |= dev->dbg_timing.dat_zero << 16;
+		reg_val |= dev->dbg_timing.dat_trail << 24;
+		pixter_write_reg(sd, PIXTER_TX_DAT_TIMING(ch), reg_val);
+		reg_val = dev->dbg_timing.twakeup;
+		pixter_write_reg(sd, PIXTER_TX_ULPS_TIMING(ch), reg_val);
+	}
+
+	/* Config MIPI clock. */
+	reg_val = pixter_get_tx_freq_sel(dev->dbg_timing.mipi_clk);
+	pixter_write_reg(sd, PIXTER_TX_CTRL(ch), reg_val);
+	/* Wait MIPI clock to be ready. Timeout=5s. */
+	while (cnt) {
+		pixter_write_reg(sd, PIXTER_TX_CTRL_NNS(ch), 1);
+		pixter_read_reg(sd, PIXTER_TX_STATUS(ch), &reg_val);
+		if (reg_val & PIXTER_TX_READY)
+			break;
+		usleep_range(10000, 10000);
+		cnt--;
+	}
+	if (cnt == 0) {
+		dev_err(&client->dev, "Wait MIPI clock ready timeout.\n");
+		return -EBUSY;
+	}
+	pixter_read_mipi_timing(sd);
+
+	return 0;
+}
+
+static int pixter_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+	u32 reg_val;
+
+	dev_dbg(&client->dev, "Set stream for pixter. enable=%d\n", enable);
+
+	mutex_lock(&dev->input_lock);
+
+	if (enable) {
+		ret = pixter_config_rx(sd);
+		if (ret)
+			goto out;
+		ret = pixter_config_tx(sd);
+		if (ret)
+			goto out;
+	}
+
+	/* Enable stream output. */
+	reg_val = 1 << port_to_channel[dev->mipi_info->port];
+	if (!enable)
+		reg_val <<= 4;
+	pixter_write_reg(sd, PIXTER_CPX_CTRL, reg_val);
+
+	if (!enable)
+		memset(dev->vc_setting, 0, sizeof(dev->vc_setting));
+out:
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int pixter_g_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct pixter_setting *setting;
+
+	mutex_lock(&dev->input_lock);
+	setting = &dev->settings[dev->cur_setting];
+
+	/* Return the currently selected settings' maximum frame interval */
+
+	interval->interval.numerator = 1;
+	if (dev->dbg_fps.fps_ovrd)
+		interval->interval.denominator = dev->dbg_fps.fps;
+	else
+		interval->interval.denominator =
+			setting->vc[setting->def_vc].fps;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int pixter_s_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct pixter_setting *setting;
+
+	if (interval->interval.numerator == 0)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	setting = &dev->settings[dev->cur_setting];
+	setting->vc[setting->def_vc].fps = interval->interval.denominator /
+		interval->interval.numerator;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int pixter_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct pixter_setting *setting = &dev->settings[dev->cur_setting];
+
+	*code = format_bridge[setting->vc[0].format].v4l2_format;
+
+	return 0;
+}
+
+static u32 pixter_try_mbus_fmt_locked(struct v4l2_subdev *sd,
+				      struct v4l2_mbus_framefmt *fmt)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+		(struct atomisp_input_stream_info*)fmt->reserved;
+	struct pixter_setting *settings = dev->settings;
+	struct pixter_vc_setting *vc_setting = dev->vc_setting;
+	u32 vc, i, j, idx;
+	s64 w0, h0, mismatch, distance;
+	s64 w1 = fmt->width;
+	s64 h1 = fmt->height;
+	s64 min_distance = LLONG_MAX;
+
+	dev_dbg(&client->dev, "pixter_try_mbus_fmt. size=%dx%d stream=%d\n",
+		fmt->width, fmt->height, stream_info->stream);
+	if (dev->caps->sensor[0].stream_num == 1)
+		vc = 0;
+	else
+		vc = stream_info->stream;
+	for (i = 0, idx = dev->setting_num - 1; i < dev->setting_num; i++) {
+		if (dev->setting_en[i] == 0)
+			continue;
+		for (j = 0; j < 4; j++) {
+			if (!vc_setting[j].width)
+				continue;
+			if (vc_setting[j].width != settings[i].vc[j].width ||
+			    vc_setting[j].height != settings[i].vc[j].height)
+				break;
+		}
+		if (j < 4)
+			continue;
+		w0 = settings[i].vc[vc].width;
+		h0 = settings[i].vc[vc].height;
+		if (w0 < w1 || h0 < h1)
+			continue;
+		mismatch = abs(w0 * h1 - w1 * h0) * 8192;
+		do_div(mismatch, w1 * h0);
+		if (mismatch > 8192 * PIXTER_MAX_RATIO_MISMATCH / 100)
+			continue;
+		distance = (w0 * h1 + w1 * h0) * 8192;
+		do_div(distance, w1 * h1);
+		if (distance < min_distance) {
+			min_distance = distance;
+			idx = i;
+		}
+	}
+	fmt->width = settings[idx].vc[vc].width;
+	fmt->height = settings[idx].vc[vc].height;
+	fmt->code = format_bridge[settings[idx].vc[vc].format].v4l2_format;
+	return idx;
+}
+
+static int pixter_try_mbus_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+
+	mutex_lock(&dev->input_lock);
+	pixter_try_mbus_fmt_locked(sd, fmt);
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int pixter_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct atomisp_input_stream_info *stream_info =
+		(struct atomisp_input_stream_info*)fmt->reserved;
+	struct pixter_setting *setting;
+	u32 vc;
+
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->caps->sensor[0].stream_num == 1)
+		vc = 0;
+	else
+		vc = stream_info->stream;
+
+	setting = &dev->settings[dev->cur_setting];
+	fmt->width = setting->vc[vc].width;
+	fmt->height = setting->vc[vc].height;
+	fmt->code = format_bridge[setting->vc[vc].format].v4l2_format;
+	mutex_unlock(&dev->input_lock);
+
+	dev_dbg(&client->dev, "%s w:%d h:%d code: 0x%x stream: %d\n", __func__,
+			fmt->width, fmt->height, fmt->code,
+			stream_info->stream);
+
+	return 0;
+}
+
+static int pixter_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+		(struct atomisp_input_stream_info*)fmt->reserved;
+
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	dev->cur_setting = pixter_try_mbus_fmt_locked(sd, fmt);
+	if (dev->caps->sensor[0].stream_num == 1)
+		stream_info->ch_id = 0;
+	else
+		stream_info->ch_id = stream_info->stream;
+	dev->vc_setting[stream_info->ch_id] =
+		dev->settings[dev->cur_setting].vc[stream_info->ch_id];
+	mutex_unlock(&dev->input_lock);
+	dev_dbg(&client->dev, "%s w:%d h:%d code: 0x%x stream: %d\n", __func__,
+			fmt->width, fmt->height, fmt->code,
+			stream_info->stream);
+
+	return 0;
+}
+
+static int pixter_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	int ret;
+	u32 reg_val;
+
+	if (reg->size != 4)
+		return -EINVAL;
+
+	ret = pixter_read_reg(sd, reg->reg, &reg_val);
+	if (ret)
+		return ret;
+
+	reg->val = reg_val;
+
+	return 0;
+}
+
+static int pixter_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	if (reg->size != 4)
+		return -EINVAL;
+
+	return pixter_write_reg(sd, reg->reg, reg->val);
+}
+
+static long pixter_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		break;
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		break;
+	case VIDIOC_DBG_G_REGISTER:
+		pixter_g_register(sd, arg);
+		break;
+	case VIDIOC_DBG_S_REGISTER:
+		pixter_s_register(sd, arg);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int
+pixter_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	if (code->index >= 1)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	code->code = dev->format.code;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int
+pixter_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+	struct pixter_device *dev = to_pixter_dev(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= 1) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fse->min_width = dev->settings[dev->cur_setting].vc[0].width;
+	fse->min_height = dev->settings[dev->cur_setting].vc[0].height;
+	fse->max_width = fse->min_width;
+	fse->max_height = fse->min_height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__pixter_get_pad_format(struct pixter_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+pixter_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+
+	return 0;
+}
+
+static int
+pixter_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct v4l2_mbus_framefmt *format =
+			__pixter_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int pixter_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+	struct pixter_device *dev = to_pixter_dev(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= 1) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = dev->settings[dev->cur_setting].vc[0].width;
+	fsize->discrete.height = dev->settings[dev->cur_setting].vc[0].height;
+	fsize->reserved[0] = 1;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int pixter_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+
+	mutex_lock(&dev->input_lock);
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = dev->settings[dev->cur_setting].vc[0].width;
+	fival->height = dev->settings[dev->cur_setting].vc[0].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = 30;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int pixter_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct pixter_device *dev = to_pixter_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 reg_val;
+
+	dev_dbg(&client->dev, "Set power for pixter. on=%d\n", on);
+	/* Disable channel output. */
+	reg_val = 1 << (port_to_channel[dev->mipi_info->port] + 4);
+	pixter_write_reg(sd, PIXTER_CPX_CTRL, reg_val);
+	memset(dev->vc_setting, 0, sizeof(dev->vc_setting));
+	return 0;
+}
+
+static ssize_t pixter_dbgfs_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
+{
+	struct pixter_dbgfs_data *data = file->f_inode->i_private;
+	struct pixter_device *dev = data->dev;
+	ssize_t ret = 0;
+	u32 *val = (u32*) data->ptr;
+	u32 i;
+
+	char *str = kzalloc(1024, GFP_KERNEL);
+	if (!str)
+		return 0;
+	if (val >= dev->setting_en &&
+	    val < &dev->setting_en[dev->setting_num]) {
+		u32 idx = (val - dev->setting_en);
+		struct pixter_setting *setting = &dev->settings[idx];
+		char sub_str[128];
+		if (idx >= dev->setting_num)
+			goto out;
+		snprintf(str, 1024, "Valid VCs: %d\n", setting->valid_vc_num);
+		for (i = 0; i < 4; i++) {
+			struct pixter_vc_setting *vc =
+				&setting->vc[i];
+			if (vc->width == 0)
+				continue;
+			snprintf(sub_str, 128, "VC%d: %dx%d @ %dfps - %s\n",
+				i, vc->width, vc->height, vc->fps,
+				format_bridge[vc->format].name);
+			strncat(str, sub_str, 1023 - strlen(str));
+		}
+		snprintf(sub_str, 128, "Def: VC%d\nState: %s\n",
+			setting->def_vc,
+			dev->setting_en[idx] ? "Enabled" : "Disabled");
+		strncat(str, sub_str, 1023 - strlen(str));
+	} else {
+		snprintf(str, 1024, "%d\n", *val);
+	}
+	ret = simple_read_from_buffer(buf, size, ppos, str, strlen(str));
+out:
+	kfree(str);
+	return ret;
+}
+
+static ssize_t pixter_dbgfs_write(struct file *file, const char __user *buf, size_t size, loff_t *ppos)
+{
+	struct pixter_dbgfs_data *data = file->f_inode->i_private;
+	struct pixter_device *dev = data->dev;
+	u32 *val = (u32*) data->ptr;
+	char str[16] = {0};
+	ssize_t ret;
+
+	ret =  simple_write_to_buffer(str, 16, ppos, buf, size);
+	sscanf(str, "%d", val);
+	if (val == &dev->dbg_timing.timing_ovrd && *val == 0)
+		pixter_config_tx(&dev->sd);
+
+	return ret;
+}
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.id = V4L2_CID_RUN_MODE,
+		.name = "Run Mode",
+		.type = V4L2_CTRL_TYPE_MENU,
+		.min = 1,
+		.def = 4,
+		.max = 4,
+		.qmenu = ctrl_run_mode_menu,
+	}
+};
+
+static const struct v4l2_subdev_core_ops pixter_core_ops = {
+	.s_power	= pixter_s_power,
+	.queryctrl	= v4l2_subdev_queryctrl,
+	.g_ctrl		= v4l2_subdev_g_ctrl,
+	.s_ctrl		= v4l2_subdev_s_ctrl,
+	.ioctl = pixter_ioctl,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= pixter_g_register,
+	.s_register	= pixter_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_video_ops pixter_video_ops = {
+	.s_stream = pixter_s_stream,
+	.enum_framesizes = pixter_enum_framesizes,
+	.enum_frameintervals = pixter_enum_frameintervals,
+	.enum_mbus_fmt = pixter_enum_mbus_fmt,
+	.try_mbus_fmt = pixter_try_mbus_fmt,
+	.g_mbus_fmt = pixter_g_mbus_fmt,
+	.s_mbus_fmt = pixter_s_mbus_fmt,
+	.g_frame_interval = pixter_g_frame_interval,
+	.s_frame_interval = pixter_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops pixter_pad_ops = {
+	.enum_mbus_code = pixter_enum_mbus_code,
+	.enum_frame_size = pixter_enum_frame_size,
+	.get_fmt = pixter_get_pad_format,
+	.set_fmt = pixter_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops pixter_ops = {
+	.core = &pixter_core_ops,
+	.video = &pixter_video_ops,
+	.pad = &pixter_pad_ops,
+};
+
+static const struct media_entity_operations pixter_entity_ops = {
+	.link_setup = NULL,
+};
+
+static const struct file_operations pixter_dbgfs_fops = {
+	.read = pixter_dbgfs_read,
+	.write = pixter_dbgfs_write,
+	.llseek = generic_file_llseek,
+};
+
+static int pixter_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct pixter_device *dev = to_pixter_dev(sd);
+
+	if (dev->sd.entity.links)
+		media_entity_cleanup(&dev->sd.entity);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	if (dev->dbgfs_data)
+		debugfs_remove_recursive(dev->dbgfs_data[0].entry);
+
+	return 0;
+}
+
+static int pixter_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct pixter_device *dev;
+	const struct atomisp_camera_caps *caps = NULL;
+	char *pixter_name = NULL;
+	struct pixter_setting *settings;
+	struct pixter_dbgfs_data *dbgfs_data;
+	u32 reg_val, i, j;
+	int ret;
+
+	/* allocate sensor device & init sub device */
+	dev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	mutex_init(&dev->input_lock);
+
+	dev->dbg_timing.mipi_clk = PIXTER_DEF_CLOCK;
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &pixter_ops);
+
+	if (client->dev.platform_data) {
+		dev->platform_data = client->dev.platform_data;
+		ret = dev->platform_data->csi_cfg(&dev->sd, 1);
+		if (ret)
+			goto out_free;
+		if (dev->platform_data->get_camera_caps)
+			caps = dev->platform_data->get_camera_caps();
+		else
+			caps = atomisp_get_default_camera_caps();
+		dev->caps = caps;
+	}
+
+	dev->mipi_info = v4l2_get_subdev_hostdata(&dev->sd);
+	if (!dev->mipi_info) {
+		dev_err(&client->dev, "Faild to get mipi info.\n");
+		goto out_free;
+	}
+
+	dev->regmap = devm_regmap_init_i2c(client,
+					   &pixter_reg_config);
+	if (IS_ERR(dev->regmap)) {
+		ret = PTR_ERR(dev->regmap);
+		dev_err(&client->dev,
+			"Failed to allocate register map: %d\n", ret);
+		goto out_free;
+	}
+
+	/* Load Pixter settings */
+	pixter_write_reg(&dev->sd, PIXTER_SDRAM_BASE, 0);
+	pixter_read_reg(&dev->sd, PIXTER_MAGIC_ADDR, &reg_val);
+	if (reg_val != PIXTER_MAGIC) {
+		dev_err(&client->dev,
+			"PIXTER magic does not match. Got 0x%X\n", reg_val);
+		ret = -EIO;
+		goto out_free;
+	}
+	pixter_read_reg(&dev->sd, PIXTER_SETTING_NUM, &dev->setting_num);
+	dev->settings = devm_kzalloc(&client->dev,
+		sizeof(struct pixter_setting) *
+		dev->setting_num, GFP_KERNEL);
+	if (!dev->settings) {
+		dev_err(&client->dev, "OOM when allocating settings.\n");
+		ret = -ENOMEM;
+		goto out_free;
+	}
+	settings = dev->settings;
+
+	ret = pixter_read_buf(&dev->sd, PIXTER_SETTING_START,
+			sizeof(struct pixter_setting) * dev->setting_num,
+			settings);
+	if (ret) {
+		dev_err(&client->dev, "Failed to read Pixter settings\n");
+		goto out_free;
+	}
+
+	/* Find settings that match the current device. */
+	for (i = 0, j = 0; i < dev->setting_num; i++) {
+		if (caps->sensor[0].stream_num == settings[i].valid_vc_num &&
+		   (dev->mipi_info->input_format == format_bridge[
+		   settings[i].vc[settings[i].def_vc].format].atomisp_format))
+			settings[j++] = settings[i];
+	}
+	dev->setting_num = j;
+	dev_info(&client->dev, "Setting num=%d\n", dev->setting_num);
+	if (!dev->setting_num) {
+		dev_err(&client->dev, "No matched settings loaded.\n");
+		ret = -ENODEV;
+		goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	dev->format.code = format_bridge[
+		settings[0].vc[settings[0].def_vc].format].v4l2_format;
+
+	/*
+	 * sd->name is updated with sensor driver name by the v4l2.
+	 * change it to sensor name in this case.
+	 */
+	if (dev->mipi_info->port == ATOMISP_CAMERA_PORT_PRIMARY)
+		pixter_name = PIXTER_0;
+	else if(dev->mipi_info->port == ATOMISP_CAMERA_PORT_SECONDARY)
+		pixter_name = PIXTER_1;
+	else
+		pixter_name = PIXTER_2;
+	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s %d-%04x",
+		pixter_name, i2c_adapter_id(client->adapter), client->addr);
+
+        dev_info(&client->dev, "%s dev->sd.name: %s\n", __func__, dev->sd.name);
+
+	dev->sd.entity.ops = &pixter_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls));
+	if (ret)
+		goto out_free;
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		ret = -EINVAL;
+		goto out_free;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		goto out_free;
+
+	/* Create debugfs nodes. */
+	dev->dbgfs_data = devm_kzalloc(&client->dev,
+		sizeof(struct pixter_dbgfs_data) *
+		(ARRAY_SIZE(dbgfs) + dev->setting_num + 1), GFP_KERNEL);
+	if (!dev->dbgfs_data)
+		goto out_free;
+	dbgfs_data = dev->dbgfs_data;
+	dbgfs_data[0].entry = debugfs_create_dir(pixter_name, NULL);
+	for (i = 1; i < ARRAY_SIZE(dbgfs); i++) {
+		struct dentry *parent;
+		for (j = 0; j < i; j++) {
+			if (!strcmp(dbgfs[i].parent, dbgfs[j].name))
+				break;
+		}
+		if (j == i)
+			continue;
+		parent = dbgfs_data[j].entry;
+		dbgfs_data[i].dev = dev;
+		dbgfs_data[i].ptr = (u8*)dev + dbgfs[i].offset;
+		if (dbgfs[i].type == DBGFS_DIR)
+			dbgfs_data[i].entry = debugfs_create_dir(dbgfs[i].name,
+				parent);
+		else
+			dbgfs_data[i].entry = debugfs_create_file(dbgfs[i].name,
+				S_IRUSR|S_IWUSR, parent,
+				&dbgfs_data[i], &pixter_dbgfs_fops);
+	}
+	/* Create setting nodes. */
+	dev->setting_en = devm_kzalloc(&client->dev,
+		sizeof(u32) * dev->setting_num, GFP_KERNEL);
+	if (!dev->setting_en)
+		goto out_free;
+	dbgfs_data[i].entry = debugfs_create_dir("settings",
+		dbgfs_data[0].entry);
+	for (j = 0; j < dev->setting_num; j++) {
+		char setting_name[32];
+		u32 idx = i + j + 1;
+		struct pixter_vc_setting *vc =
+			&settings[j].vc[settings[j].def_vc];
+
+		dev->setting_en[j] = 1;
+		snprintf(setting_name, 32, "%d.%dx%d_%s@%d", j, vc->width,
+			vc->height, format_bridge[vc->format].name, vc->fps);
+		dbgfs_data[idx].dev = dev;
+		dbgfs_data[idx].ptr = &dev->setting_en[j];
+		dbgfs_data[idx].entry = debugfs_create_file(setting_name,
+				S_IRUSR|S_IWUSR, dbgfs_data[i].entry,
+				&dbgfs_data[idx], &pixter_dbgfs_fops);
+	}
+	pixter_read_mipi_timing(&dev->sd);
+
+	return 0;
+
+out_free:
+	pixter_remove(client);
+	return ret;
+}
+
+static const struct i2c_device_id pixter_ids[] = {
+	{PIXTER_0, 0},
+	{PIXTER_1, 0},
+	{PIXTER_2, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, pixter_ids);
+
+static struct i2c_driver pixter_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = PIXTER_DRV,
+	},
+	.probe = pixter_probe,
+	.remove = pixter_remove,
+	.id_table = pixter_ids,
+};
+
+module_i2c_driver(pixter_driver);
+
+MODULE_DESCRIPTION("Pixter MIPI CSI simulator driver.");
+MODULE_AUTHOR("Tianshu Qiu <tian.shu.qiu@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/pixter.h b/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
new file mode 100644
index 0000000..189b0c6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/pixter.h
@@ -0,0 +1,184 @@
+/*
+ * Support for Pixter MIPI CSI simulator.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __PIXTER_H__
+#define __PIXTER_H__
+
+#include <linux/atomisp_platform.h>
+#include <linux/regmap.h>
+#include <linux/debugfs.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define PIXTER_0	"pixter_0"
+#define PIXTER_1	"pixter_1"
+#define PIXTER_2	"pixter_2"
+#define PIXTER_DRV	"pixter_drv"
+
+#define PIXTER_MAX_RATIO_MISMATCH	10
+#define PIXTER_MAX_BITRATE_MBPS	6000 /* 1.5Gb x 4 lanes */
+#define PIXTER_DEF_CLOCK	400000000 /* 400MHz */
+#define PIXTER_DEF_VBPRE	0x60
+
+#define PIXTER_I2C_ADDR		0x0
+#define PIXTER_I2C_DATA_W	0x20
+#define PIXTER_I2C_DATA_R	0x40
+
+#define PIXTER_CHANNEL_BASE(c)	(((c) + 1) * 0x200)
+
+#define PIXTER_MAGIC		0x54584950
+#define PIXTER_CPX_CTRL		0x14
+#define PIXTER_SDRAM_BASE	0x20
+
+#define PIXTER_CH_SRC_DEST	(PIXTER_CHANNEL_BASE(c) + 0x0)
+#define PIXTER_DFT_CTRL(c)	(PIXTER_CHANNEL_BASE(c) + 0x40)
+#define PIXTER_RDR_START(c)	(PIXTER_CHANNEL_BASE(c) + 0x48)
+#define PIXTER_RDR_END(c)	(PIXTER_CHANNEL_BASE(c) + 0x4C)
+#define PIXTER_VERT_BLANK(c)	(PIXTER_CHANNEL_BASE(c) + 0x54)
+#define PIXTER_TX_CTRL(c)	(PIXTER_CHANNEL_BASE(c) + 0x100)
+#define PIXTER_TX_CTRL_NNS(c)	(PIXTER_CHANNEL_BASE(c) + 0x104)
+#define PIXTER_TX_STATUS(c)	(PIXTER_CHANNEL_BASE(c) + 0x108)
+#define PIXTER_TX_CSI2_CTRL(c)	(PIXTER_CHANNEL_BASE(c) + 0x110)
+#define PIXTER_TX_CTRL_TIMING(c)	(PIXTER_CHANNEL_BASE(c) + 0x114)
+#define PIXTER_TX_CK_TIMING(c)	(PIXTER_CHANNEL_BASE(c) + 0x118)
+#define PIXTER_TX_DAT_TIMING(c)	(PIXTER_CHANNEL_BASE(c) + 0x11C)
+#define PIXTER_TX_ULPS_TIMING(c)	(PIXTER_CHANNEL_BASE(c) + 0x120)
+
+#define PIXTER_TX_READY		0x1
+#define PIXTER_SRC_DEST_DEF	0x110 /* Select DFT mode. Enable CSI2 output */
+#define PIXTER_DFT_BLOCK_MODE  0x2
+
+#define PIXTER_MAGIC_ADDR	0x80000000
+#define PIXTER_SETTING_NUM	0x80000004
+#define PIXTER_SETTING_START	0x80000008
+
+enum pixter_image_format {
+	PIXTER_UNKNOWN_FMT,
+	PIXTER_RGGB10,
+	PIXTER_GRBG10,
+	PIXTER_GBRG10,
+	PIXTER_BGGR10,
+	PIXTER_RGGB8,
+	PIXTER_GRBG8,
+	PIXTER_GBRG8,
+	PIXTER_BGGR8,
+	PIXTER_YUV422_8,
+	PIXTER_YUV420_8
+};
+
+enum pixter_dbgfs_type {
+	DBGFS_DIR,
+	DBGFS_FILE
+};
+
+struct pixter_format_bridge {
+	char *name;
+	enum v4l2_mbus_pixelcode v4l2_format;
+	enum atomisp_input_format atomisp_format;
+	u32 bpp;
+};
+
+struct pixter_vc_setting {
+	u32 width;
+	u32 height;
+	u32 fps;
+	enum pixter_image_format format;
+};
+
+struct pixter_setting {
+	u32 start;
+	u32 end;
+	u32 valid_vc_num;
+	u32 def_vc;
+	u32 block_mode;
+	struct pixter_vc_setting vc[4];
+};
+
+struct pixter_fps {
+	u32 fps_ovrd;
+	u32 fps;
+};
+
+struct pixter_blank {
+	u32 blank_ovrd;
+	u32 h_blank;
+	u32 v_blank_pre;
+	u32 v_blank_post;
+};
+
+struct pixter_timing {
+	u32 mipi_clk;
+	u32 cont_hs_clk;
+	u32 timing_ovrd;
+	u32 pre;
+	u32 post;
+	u32 gap;
+	u32 ck_lpx;
+	u32 ck_prep;
+	u32 ck_zero;
+	u32 ck_trail;
+	u32 dat_lpx;
+	u32 dat_prep;
+	u32 dat_zero;
+	u32 dat_trail;
+	u32 twakeup;
+};
+
+struct pixter_dbgfs {
+	char *name;
+	char *parent;
+	enum pixter_dbgfs_type type;
+	u32  offset;
+};
+
+struct pixter_dbgfs_data {
+	struct pixter_device *dev;
+	struct dentry *entry;
+	void *ptr;
+};
+
+/* pixter device structure */
+struct pixter_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct camera_sensor_platform_data *platform_data;
+	const struct atomisp_camera_caps *caps;
+	struct camera_mipi_info *mipi_info;
+	struct mutex input_lock;
+	struct regmap *regmap;
+	struct v4l2_ctrl_handler ctrl_handler;
+
+	u32 setting_num;
+	u32 cur_setting;
+	u32 cur_ch;
+	struct pixter_vc_setting vc_setting[4];
+	struct pixter_setting *settings;
+	u32 *setting_en;
+
+	struct pixter_fps dbg_fps;
+	struct pixter_blank dbg_blank;
+	struct pixter_timing dbg_timing;
+	struct pixter_dbgfs_data *dbgfs_data;
+};
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
new file mode 100644
index 0000000..a499c79
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.c
@@ -0,0 +1,1407 @@
+/*
+ * Support for OmniVision S5K6B2YX 1080p HD camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/moduleparam.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/io.h>
+
+#include "s5k6b2yx.h"
+
+/* i2c read/write stuff */
+static int s5k6b2yx_read_reg(struct i2c_client *client,
+			   u16 data_length, u16 reg, u16 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[6];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != S5K6B2YX_8BIT && data_length != S5K6B2YX_16BIT
+					&& data_length != S5K6B2YX_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = I2C_MSG_LENGTH;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == S5K6B2YX_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == S5K6B2YX_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+}
+
+static int s5k6b2yx_i2c_write(struct i2c_client *client, u16 len, u8 *data)
+{
+	struct i2c_msg msg;
+	const int num_msg = 1;
+	int ret;
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = len;
+	msg.buf = data;
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return ret == num_msg ? 0 : -EIO;
+}
+
+static int s5k6b2yx_write_reg(struct i2c_client *client, u16 data_length,
+							u16 reg, u16 val)
+{
+	int ret;
+	unsigned char data[4] = {0};
+	u16 *wreg = (u16 *)data;
+	const u16 len = data_length + sizeof(u16); /* 16-bit address + data */
+
+	if (data_length != S5K6B2YX_8BIT && data_length != S5K6B2YX_16BIT) {
+		dev_err(&client->dev,
+			"%s error, invalid data_length\n", __func__);
+		return -EINVAL;
+	}
+
+	/* high byte goes out first */
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == S5K6B2YX_8BIT) {
+		data[2] = (u8)(val);
+	} else {
+		/* S5K6B2YX_16BIT */
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16(val);
+	}
+
+	ret = s5k6b2yx_i2c_write(client, len, data);
+	if (ret)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, ret);
+
+	return ret;
+}
+
+/*
+ * s5k6b2yx_write_reg_array - Initializes a list of S5K6B2YX registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * This function initializes a list of registers. When consecutive addresses
+ * are found in a row on the list, this function creates a buffer and sends
+ * consecutive data in a single i2c_transfer().
+ *
+ * __s5k6b2yx_flush_reg_array, __s5k6b2yx_buf_reg_array() and
+ * __s5k6b2yx_write_reg_is_consecutive() are internal functions to
+ * s5k6b2yx_write_reg_array_fast() and should be not used anywhere else.
+ *
+ */
+
+static int __s5k6b2yx_flush_reg_array(struct i2c_client *client,
+				    struct s5k6b2yx_write_ctrl *ctrl)
+{
+	u16 size;
+
+	if (ctrl->index == 0)
+		return 0;
+
+	size = sizeof(u16) + ctrl->index; /* 16-bit address + data */
+	ctrl->buffer.addr = cpu_to_be16(ctrl->buffer.addr);
+	ctrl->index = 0;
+
+	return s5k6b2yx_i2c_write(client, size, (u8 *)&ctrl->buffer);
+}
+
+static int __s5k6b2yx_buf_reg_array(struct i2c_client *client,
+				  struct s5k6b2yx_write_ctrl *ctrl,
+				  const struct s5k6b2yx_reg *next)
+{
+	int size;
+	u16 *data16;
+
+	switch (next->type) {
+	case S5K6B2YX_8BIT:
+		size = 1;
+		ctrl->buffer.data[ctrl->index] = (u8)next->val;
+		break;
+	case S5K6B2YX_16BIT:
+		size = 2;
+		data16 = (u16 *)&ctrl->buffer.data[ctrl->index];
+		*data16 = cpu_to_be16((u16)next->val);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* When first item is added, we need to store its starting address */
+	if (ctrl->index == 0)
+		ctrl->buffer.addr = next->reg;
+
+	ctrl->index += size;
+
+	/*
+	 * Buffer cannot guarantee free space for u32? Better flush it to avoid
+	 * possible lack of memory for next item.
+	 */
+	if (ctrl->index + sizeof(u16) >= S5K6B2YX_MAX_WRITE_BUF_SIZE)
+		return __s5k6b2yx_flush_reg_array(client, ctrl);
+
+	return 0;
+}
+
+static int __s5k6b2yx_write_reg_is_consecutive(struct i2c_client *client,
+					     struct s5k6b2yx_write_ctrl *ctrl,
+					     const struct s5k6b2yx_reg *next)
+{
+	if (ctrl->index == 0)
+		return 1;
+
+	return ctrl->buffer.addr + ctrl->index == next->reg;
+}
+
+static int s5k6b2yx_write_reg_array(struct i2c_client *client,
+				  const struct s5k6b2yx_reg *reglist)
+{
+	const struct s5k6b2yx_reg *next = reglist;
+	struct s5k6b2yx_write_ctrl ctrl;
+	int err;
+
+	ctrl.index = 0;
+	for (; next->type != S5K6B2YX_TOK_TERM; next++) {
+		switch (next->type & S5K6B2YX_TOK_MASK) {
+		case S5K6B2YX_TOK_DELAY:
+			err = __s5k6b2yx_flush_reg_array(client, &ctrl);
+			if (err)
+				return err;
+			msleep(next->val);
+			break;
+		default:
+			/*
+			 * If next address is not consecutive, data needs to be
+			 * flushed before proceed.
+			 */
+			if (!__s5k6b2yx_write_reg_is_consecutive(client, &ctrl,
+								next)) {
+				err = __s5k6b2yx_flush_reg_array(client, &ctrl);
+				if (err)
+					return err;
+			}
+			err = __s5k6b2yx_buf_reg_array(client, &ctrl, next);
+			if (err) {
+				dev_err(&client->dev, "%s: write error, aborted\n",
+					 __func__);
+				return err;
+			}
+			break;
+		}
+	}
+
+	return __s5k6b2yx_flush_reg_array(client, &ctrl);
+}
+static int s5k6b2yx_g_focal(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (S5K6B2YX_FOCAL_LENGTH_NUM << 16) | S5K6B2YX_FOCAL_LENGTH_DEM;
+	return 0;
+}
+
+static int s5k6b2yx_g_fnumber(struct v4l2_subdev *sd, s32 *val)
+{
+	/*const f number for imx*/
+	*val = (S5K6B2YX_F_NUMBER_DEFAULT_NUM << 16) | S5K6B2YX_F_NUMBER_DEM;
+	return 0;
+}
+
+static int s5k6b2yx_g_fnumber_range(struct v4l2_subdev *sd, s32 *val)
+{
+	*val = (S5K6B2YX_F_NUMBER_DEFAULT_NUM << 24) |
+		(S5K6B2YX_F_NUMBER_DEM << 16) |
+		(S5K6B2YX_F_NUMBER_DEFAULT_NUM << 8) | S5K6B2YX_F_NUMBER_DEM;
+	return 0;
+}
+
+static int s5k6b2yx_get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info,
+				const struct s5k6b2yx_resolution *res)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct atomisp_sensor_mode_data *buf = &info->data;
+	const unsigned int ext_clk_freq_hz = 19200000;
+	unsigned int pix_clk_freq_hz;
+	u16 pre_pll_clk_div;
+	u16 pll_multiplier;
+	u16 vt_sys_clk_div;
+	u16 vt_pix_clk_div;
+	u16 reg_val;
+	int ret;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* pixel clock calculattion */
+	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+				S5K6B2YX_REG_PRE_PLL_CLK_DIV_H,
+				&pre_pll_clk_div);
+	if (ret)
+		return ret;
+
+	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+				S5K6B2YX_REG_PLL_MULTIPLIER_H,
+				&pll_multiplier);
+	if (ret)
+		return ret;
+
+	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+				S5K6B2YX_REG_VT_PIX_CLK_DIV_H,
+				&vt_pix_clk_div);
+	if (ret)
+		return ret;
+
+	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+				S5K6B2YX_REG_VT_SYS_CLK_DIV_H,
+				&vt_sys_clk_div);
+	if (ret)
+		return ret;
+
+	pre_pll_clk_div = (pre_pll_clk_div & 0x70) >> 4;
+	if (0 == pre_pll_clk_div)
+		return -EINVAL;
+
+	pix_clk_freq_hz = ext_clk_freq_hz * pll_multiplier / pre_pll_clk_div
+				/ vt_sys_clk_div / vt_pix_clk_div;
+
+	dev->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+	buf->vt_pix_clk_freq_mhz = pix_clk_freq_hz;
+
+	/* get integration time */
+	buf->coarse_integration_time_min = S5K6B2YX_COARSE_INTG_TIME_MIN;
+	buf->coarse_integration_time_max_margin =
+					S5K6B2YX_COARSE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_min = S5K6B2YX_FINE_INTG_TIME_MIN;
+	buf->fine_integration_time_max_margin =
+					S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN;
+
+	buf->fine_integration_time_def = S5K6B2YX_FINE_INTG_TIME_MIN;
+	buf->frame_length_lines = res->lines_per_frame;
+	buf->line_length_pck = res->pixels_per_line;
+	buf->read_mode = res->bin_mode;
+
+	/* get the cropping and output resolution to ISP for this mode. */
+	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_H_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_start = reg_val;
+
+	ret =  s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_V_CROP_START_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_start = reg_val;
+
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_H_CROP_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_horizontal_end = reg_val;
+
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_V_CROP_END_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->crop_vertical_end = reg_val;
+
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_H_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_width = reg_val;
+
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_V_OUTSIZE_H, &reg_val);
+	if (ret)
+		return ret;
+	buf->output_height = reg_val;
+
+	buf->binning_factor_x = res->bin_factor_x ?
+					res->bin_factor_x : 1;
+	buf->binning_factor_y = res->bin_factor_y ?
+					res->bin_factor_y : 1;
+	return 0;
+}
+
+static long __s5k6b2yx_set_exposure(struct v4l2_subdev *sd, int coarse_itg,
+				 int gain, int digitgain)
+
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+
+	/*
+	 * FIXME!
+	 * TBD: Tuning for exposure and gain control
+	 */
+
+	/* group hold start */
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
+			S5K6B2YX_REG_GROUND_HOLD, 1);
+	if (ret)
+		return ret;
+
+	/* set exposure */
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_COARSE_INTEG,
+					coarse_itg);
+	if (ret)
+		return ret;
+
+	/* set analog gain */
+	/*
+	 * DS: the gain of pixel signal is controlled by Analog Gain Control
+	 * Register (analogue_gain_code_global), here is the equation:
+	 * Analog Gain = (m0 * x + c0) / (m1 * x + c1)
+	 *
+	 * S5K6N2YX specifies analog gain by coefficients of m0 = 1, m1 = 0,
+	 * c1 = 32. As a result, here is the equation:
+	 * Analog Gain = analogue_gain_code_global[12:0] / 32
+	 *
+	 * The miminum value of analogure_gain_code_global[12:0] is
+	 * recommended to 32d, which means that the analog gain should be less
+	 * than x1.
+	 */
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_ANALOG_GAIN, gain);
+	if (ret)
+		return ret;
+
+	/* There is no digital gain control */
+
+	/* group hold end */
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
+					S5K6B2YX_REG_GROUND_HOLD, 0);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static int s5k6b2yx_set_exposure(struct v4l2_subdev *sd, int exposure,
+	int gain, int digitgain)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	ret = __s5k6b2yx_set_exposure(sd, exposure, gain, digitgain);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static long s5k6b2yx_s_exposure(struct v4l2_subdev *sd,
+			       struct atomisp_exposure *exposure)
+{
+	int exp = exposure->integration_time[0];
+	int gain = exposure->gain[0];
+	int digitgain = exposure->gain[1];
+
+	/* we should not accept the invalid value below. */
+	if (gain == 0) {
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		v4l2_err(client, "%s: invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	return s5k6b2yx_set_exposure(sd, exp, gain, digitgain);
+}
+
+static long s5k6b2yx_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return s5k6b2yx_s_exposure(sd, arg);
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* This returns the exposure time being used. This should only be used
+   for filling in EXIF data, not for actual image processing. */
+static int s5k6b2yx_q_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u16 coarse;
+	int ret;
+
+	/* get exposure */
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_COARSE_INTEG,
+					&coarse);
+	if (ret)
+		goto err;
+
+	*value = coarse;
+err:
+	return ret;
+}
+struct s5k6b2yx_control s5k6b2yx_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 0x01,
+			.default_value = 0x00,
+			.flags = 0,
+		},
+		.query = s5k6b2yx_q_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FOCAL_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "focal length",
+			.minimum = S5K6B2YX_FOCAL_LENGTH_DEFAULT,
+			.maximum = S5K6B2YX_FOCAL_LENGTH_DEFAULT,
+			.step = 0x01,
+			.default_value = S5K6B2YX_FOCAL_LENGTH_DEFAULT,
+			.flags = 0,
+		},
+		.query = s5k6b2yx_g_focal,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_ABSOLUTE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number",
+			.minimum = S5K6B2YX_F_NUMBER_DEFAULT,
+			.maximum = S5K6B2YX_F_NUMBER_DEFAULT,
+			.step = 0x01,
+			.default_value = S5K6B2YX_F_NUMBER_DEFAULT,
+			.flags = 0,
+		},
+		.query = s5k6b2yx_g_fnumber,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_FNUMBER_RANGE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "f-number range",
+			.minimum = S5K6B2YX_F_NUMBER_RANGE,
+			.maximum =  S5K6B2YX_F_NUMBER_RANGE,
+			.step = 0x01,
+			.default_value = S5K6B2YX_F_NUMBER_RANGE,
+			.flags = 0,
+		},
+		.query = s5k6b2yx_g_fnumber_range,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(s5k6b2yx_controls))
+
+static int s5k6b2yx_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct s5k6b2yx_device *dev = container_of(ctrl->handler,
+			struct s5k6b2yx_device, ctrl_handler);
+	unsigned int val;
+
+	switch (ctrl->id) {
+	case V4L2_CID_LINK_FREQ:
+		val = s5k6b2yx_res[dev->fmt_idx].mipi_freq;
+		if (val == 0)
+			return -EINVAL;
+
+		ctrl->val = val * 1000;			/* To Hz */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static struct s5k6b2yx_control *s5k6b2yx_find_control(u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++)
+		if (s5k6b2yx_controls[i].qc.id == id)
+			return &s5k6b2yx_controls[i];
+	return NULL;
+}
+
+static int s5k6b2yx_queryctrl(struct v4l2_subdev *sd,
+		struct v4l2_queryctrl *qc)
+{
+	struct s5k6b2yx_control *ctrl = s5k6b2yx_find_control(qc->id);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	if (ctrl == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+/* imx control set/get */
+static int s5k6b2yx_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct s5k6b2yx_control *s_ctrl;
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int ret;
+
+	if (!ctrl)
+		return -EINVAL;
+
+	s_ctrl = s5k6b2yx_find_control(ctrl->id);
+	if ((s_ctrl == NULL) || (s_ctrl->query == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s_ctrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int s5k6b2yx_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct s5k6b2yx_control *octrl = s5k6b2yx_find_control(ctrl->id);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	int ret;
+
+	if ((octrl == NULL) || (octrl->tweak == NULL))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int __s5k6b2yx_init(struct v4l2_subdev *sd)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	/* restore settings */
+	s5k6b2yx_res = s5k6b2yx_res_preview;
+	N_RES = N_RES_PREVIEW;
+
+	ret = s5k6b2yx_write_reg_array(client, s5k6b2yx_init);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx write init registers err.\n");
+		return ret;
+	}
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* according to DS, at least 5ms is needed between DOVDD and PWDN */
+	usleep_range(5000, 6000);
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 1);
+		if (ret)
+			goto fail_power;
+	}
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	/* according to DS, 20ms is needed between PWDN and i2c access */
+	msleep(20);
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->gpio_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev,
+			"no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret) {
+		ret = dev->platform_data->gpio_ctrl(sd, 0);
+		if (ret)
+			dev_err(&client->dev, "gpio failed 2\n");
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int s5k6b2yx_s_power(struct v4l2_subdev *sd, int on)
+{
+	int ret;
+	if (on == 0)
+		return power_down(sd);
+	else {
+		ret = power_up(sd);
+		if (!ret)
+			return __s5k6b2yx_init(sd);
+	}
+	return ret;
+}
+
+/*
+ * distance - calculate the distance
+ * @res: resolution
+ * @w: width
+ * @h: height
+ *
+ * Get the gap between resolution and w/h.
+ * res->width/height smaller than w/h wouldn't be considered.
+ * Returns the value of gap or -1 if fail.
+ */
+#define LARGEST_ALLOWED_RATIO_MISMATCH 800
+static int distance(struct s5k6b2yx_resolution *res, u32 w, u32 h)
+{
+	unsigned int w_ratio = ((res->width << 13)/w);
+	unsigned int h_ratio;
+	int match;
+
+	if (h == 0)
+		return -1;
+	h_ratio = ((res->height << 13) / h);
+	if (h_ratio == 0)
+		return -1;
+	match   = abs(((w_ratio << 13) / h_ratio) - ((int)8192));
+
+	if ((w_ratio < (int)8192) || (h_ratio < (int)8192)  ||
+		(match > LARGEST_ALLOWED_RATIO_MISMATCH))
+		return -1;
+
+	return w_ratio + h_ratio;
+}
+
+/* Return the nearest higher resolution index */
+static int nearest_resolution_index(int w, int h)
+{
+	int i;
+	int idx = -1;
+	int dist;
+	int min_dist = INT_MAX;
+	struct s5k6b2yx_resolution *tmp_res = NULL;
+
+	for (i = 0; i < N_RES; i++) {
+		tmp_res = &s5k6b2yx_res[i];
+		dist = distance(tmp_res, w, h);
+		if (dist == -1)
+			continue;
+		if (dist < min_dist) {
+			min_dist = dist;
+			idx = i;
+		}
+	}
+
+	return idx;
+}
+
+static int get_resolution_index(int w, int h)
+{
+	int i;
+
+	for (i = 0; i < N_RES; i++) {
+		if (w != s5k6b2yx_res[i].width)
+			continue;
+		if (h != s5k6b2yx_res[i].height)
+			continue;
+
+		return i;
+	}
+
+	return -1;
+}
+
+static int s5k6b2yx_try_mbus_fmt(struct v4l2_subdev *sd,
+			struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+
+	if (!fmt)
+		return -EINVAL;
+	idx = nearest_resolution_index(fmt->width,
+					fmt->height);
+	if (idx == -1) {
+		/* return the largest resolution */
+		fmt->width = s5k6b2yx_res[N_RES - 1].width;
+		fmt->height = s5k6b2yx_res[N_RES - 1].height;
+	} else {
+		fmt->width = s5k6b2yx_res[idx].width;
+		fmt->height = s5k6b2yx_res[idx].height;
+	}
+	fmt->code = V4L2_MBUS_FMT_SGRBG10_1X10;
+
+	return 0;
+}
+
+static int s5k6b2yx_s_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *s5k6b2yx_info = NULL;
+	int ret = 0;
+
+	s5k6b2yx_info = v4l2_get_subdev_hostdata(sd);
+	if (s5k6b2yx_info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	ret = s5k6b2yx_try_mbus_fmt(sd, fmt);
+	if (ret == -1) {
+		dev_err(&client->dev, "try fmt fail\n");
+		goto err;
+	}
+
+	dev->fmt_idx = get_resolution_index(fmt->width,
+					      fmt->height);
+	if (dev->fmt_idx == -1) {
+		dev_err(&client->dev, "get resolution fail\n");
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	ret = s5k6b2yx_write_reg_array(client,
+			s5k6b2yx_res[dev->fmt_idx].regs);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx write fmt register err.\n");
+		return ret;
+	}
+
+	ret = s5k6b2yx_get_intg_factor(client, s5k6b2yx_info,
+					&s5k6b2yx_res[dev->fmt_idx]);
+	if (ret)
+		dev_err(&client->dev, "failed to get integration_factor\n");
+
+err:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+static int s5k6b2yx_g_mbus_fmt(struct v4l2_subdev *sd,
+			     struct v4l2_mbus_framefmt *fmt)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = s5k6b2yx_res[dev->fmt_idx].width;
+	fmt->height = s5k6b2yx_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int s5k6b2yx_detect(struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u16 id;
+	u16 revision;
+	int ret;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_16BIT,
+					S5K6B2YX_REG_CHIP_ID_H, &id);
+	if (ret) {
+		dev_err(&client->dev, "Err read sensor_id 0x%x\n", ret);
+		return -ENODEV;
+	}
+
+	if ((id != S5K6B2YX_ID)) {
+		dev_err(&client->dev, "sensor ID error\n");
+		return -ENODEV;
+	}
+
+	ret = s5k6b2yx_read_reg(client, S5K6B2YX_8BIT,
+					S5K6B2YX_REG_REVISION, &revision);
+	if (ret) {
+		dev_err(&client->dev, "Err read sensor revision 0x%x\n", ret);
+		return -ENODEV;
+	}
+
+	dev_dbg(&client->dev, "sensor_revision = 0x%x\n", revision);
+	dev_dbg(&client->dev, "detect s5k6b2yx success\n");
+	return 0;
+}
+
+static int s5k6b2yx_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = s5k6b2yx_write_reg(client, S5K6B2YX_8BIT,
+			S5K6B2YX_REG_MODE_SELECT,
+			enable ? S5K6B2YX_START_STREAMING :
+			S5K6B2YX_STOP_STREAMING);
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+/* s5k6b2yx enum frame size, frame intervals */
+static int s5k6b2yx_enum_framesizes(struct v4l2_subdev *sd,
+				  struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = s5k6b2yx_res[index].width;
+	fsize->discrete.height = s5k6b2yx_res[index].height;
+	fsize->reserved[0] = s5k6b2yx_res[index].used;
+
+	return 0;
+}
+
+static int s5k6b2yx_enum_frameintervals(struct v4l2_subdev *sd,
+				      struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = s5k6b2yx_res[index].width;
+	fival->height = s5k6b2yx_res[index].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = s5k6b2yx_res[index].fps;
+
+	return 0;
+}
+
+static int s5k6b2yx_enum_mbus_fmt(struct v4l2_subdev *sd,
+				unsigned int index,
+				enum v4l2_mbus_pixelcode *code)
+{
+	*code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int s5k6b2yx_s_config(struct v4l2_subdev *sd,
+			   int irq, void *platform_data)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	if (platform_data == NULL)
+		return -ENODEV;
+
+	dev->platform_data =
+		(struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "platform init err\n");
+			goto platform_init_failed;
+		}
+	}
+
+	/* power off the module, then power on it in future
+	 * as first power on by board may not fulfill the
+	 * power on sequqence needed by the module
+	 */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx power-off err.\n");
+		goto fail_power_off;
+	}
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx power-up err.\n");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = s5k6b2yx_detect(client);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	/* turn off sensor, after probed */
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "s5k6b2yx power-off err.\n");
+		goto fail_csi_cfg;
+	}
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+platform_init_failed:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int s5k6b2yx_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (dev->fmt_idx >= 0 && dev->fmt_idx < N_RES) {
+		param->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+		param->parm.capture.timeperframe.numerator = 1;
+		param->parm.capture.capturemode = dev->run_mode;
+		param->parm.capture.timeperframe.denominator =
+			s5k6b2yx_res[dev->fmt_idx].fps;
+	}
+	return 0;
+}
+
+static int s5k6b2yx_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	dev->run_mode = param->parm.capture.capturemode;
+
+	mutex_lock(&dev->input_lock);
+	switch (dev->run_mode) {
+	case CI_MODE_VIDEO:
+		s5k6b2yx_res = s5k6b2yx_res_video;
+		N_RES = N_RES_VIDEO;
+		break;
+	case CI_MODE_STILL_CAPTURE:
+		s5k6b2yx_res = s5k6b2yx_res_still;
+		N_RES = N_RES_STILL;
+		break;
+	default:
+		s5k6b2yx_res = s5k6b2yx_res_preview;
+		N_RES = N_RES_PREVIEW;
+	}
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int s5k6b2yx_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = s5k6b2yx_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int s5k6b2yx_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index >= MAX_FMTS)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int s5k6b2yx_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = s5k6b2yx_res[index].width;
+	fse->min_height = s5k6b2yx_res[index].height;
+	fse->max_width = s5k6b2yx_res[index].width;
+	fse->max_height = s5k6b2yx_res[index].height;
+
+	return 0;
+
+}
+
+static struct v4l2_mbus_framefmt *
+__s5k6b2yx_get_pad_format(struct s5k6b2yx_device *sensor,
+			struct v4l2_subdev_fh *fh, unsigned int pad,
+			enum v4l2_subdev_format_whence which)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
+
+	if (pad != 0) {
+		dev_err(&client->dev,
+			"__s5k6b2yx_get_pad_format err. pad %x\n", pad);
+		return NULL;
+	}
+
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int s5k6b2yx_get_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct s5k6b2yx_device *snr = to_s5k6b2yx_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__s5k6b2yx_get_pad_format(snr, fh, fmt->pad,
+					fmt->which);
+	if (!format)
+		return -EINVAL;
+
+	fmt->format = *format;
+	return 0;
+}
+
+static int s5k6b2yx_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_format *fmt)
+{
+	struct s5k6b2yx_device *snr = to_s5k6b2yx_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+static int s5k6b2yx_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	*frames = s5k6b2yx_res[dev->fmt_idx].skip_frames;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_sensor_ops s5k6b2yx_sensor_ops = {
+	.g_skip_frames	= s5k6b2yx_g_skip_frames,
+};
+
+static struct v4l2_ctrl_ops s5k6b2yx_ctrl_ops = {
+	.g_volatile_ctrl = s5k6b2yx_g_volatile_ctrl,
+};
+
+static const struct v4l2_ctrl_config v4l2_ctrl_link_freq = {
+	.ops = &s5k6b2yx_ctrl_ops,
+	.id = V4L2_CID_LINK_FREQ,
+	.name = "Link Frequency",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 1,
+	.max = 1500000 * 1000,
+	.step = 1,
+	.def = 1,
+	.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+};
+
+static const struct v4l2_subdev_video_ops s5k6b2yx_video_ops = {
+	.s_stream = s5k6b2yx_s_stream,
+	.g_parm = s5k6b2yx_g_parm,
+	.s_parm = s5k6b2yx_s_parm,
+	.enum_framesizes = s5k6b2yx_enum_framesizes,
+	.enum_frameintervals = s5k6b2yx_enum_frameintervals,
+	.enum_mbus_fmt = s5k6b2yx_enum_mbus_fmt,
+	.try_mbus_fmt = s5k6b2yx_try_mbus_fmt,
+	.g_mbus_fmt = s5k6b2yx_g_mbus_fmt,
+	.s_mbus_fmt = s5k6b2yx_s_mbus_fmt,
+	.g_frame_interval = s5k6b2yx_g_frame_interval,
+};
+
+static const struct v4l2_subdev_core_ops s5k6b2yx_core_ops = {
+	.s_power = s5k6b2yx_s_power,
+	.queryctrl = s5k6b2yx_queryctrl,
+	.g_ctrl = s5k6b2yx_g_ctrl,
+	.s_ctrl = s5k6b2yx_s_ctrl,
+	.ioctl = s5k6b2yx_ioctl,
+};
+
+static const struct v4l2_subdev_pad_ops s5k6b2yx_pad_ops = {
+	.enum_mbus_code = s5k6b2yx_enum_mbus_code,
+	.enum_frame_size = s5k6b2yx_enum_frame_size,
+	.get_fmt = s5k6b2yx_get_pad_format,
+	.set_fmt = s5k6b2yx_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops s5k6b2yx_ops = {
+	.core = &s5k6b2yx_core_ops,
+	.video = &s5k6b2yx_video_ops,
+	.pad = &s5k6b2yx_pad_ops,
+	.sensor = &s5k6b2yx_sensor_ops,
+};
+
+static int s5k6b2yx_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct s5k6b2yx_device *dev = to_s5k6b2yx_sensor(sd);
+	dev_dbg(&client->dev, "s5k6b2yx_remove...\n");
+
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int __s5k6b2yx_init_ctrl_handler(struct s5k6b2yx_device *dev)
+{
+	struct v4l2_ctrl_handler *hdl;
+
+	hdl = &dev->ctrl_handler;
+
+	v4l2_ctrl_handler_init(&dev->ctrl_handler, 3);
+
+	dev->link_freq = v4l2_ctrl_new_custom(&dev->ctrl_handler,
+					      &v4l2_ctrl_link_freq,
+					      NULL);
+
+	if (dev->ctrl_handler.error || dev->link_freq == NULL)
+		return dev->ctrl_handler.error;
+
+	dev->sd.ctrl_handler = hdl;
+
+	return 0;
+}
+static int s5k6b2yx_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct s5k6b2yx_device *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	dev->fmt_idx = 0;
+	v4l2_i2c_subdev_init(&(dev->sd), client, &s5k6b2yx_ops);
+
+	if (client->dev.platform_data) {
+		ret = s5k6b2yx_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	ret = __s5k6b2yx_init_ctrl_handler(dev);
+	if (ret)
+		goto out_ctrl_handler_free;
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		s5k6b2yx_remove(client);
+
+	return ret;
+
+out_ctrl_handler_free:
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, s5k6b2yx_id);
+static struct i2c_driver s5k6b2yx_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = S5K6B2YX_NAME,
+	},
+	.probe = s5k6b2yx_probe,
+	.remove = s5k6b2yx_remove,
+	.id_table = s5k6b2yx_id,
+};
+
+static int init_s5k6b2yx(void)
+{
+	return i2c_add_driver(&s5k6b2yx_driver);
+}
+
+static void exit_s5k6b2yx(void)
+{
+
+	i2c_del_driver(&s5k6b2yx_driver);
+}
+
+module_init(init_s5k6b2yx);
+module_exit(exit_s5k6b2yx);
+
+MODULE_AUTHOR("Tao Jing <jing.tao@intel.com>");
+MODULE_DESCRIPTION("A low-level driver for SANGSUME S5K6B2YX sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
new file mode 100644
index 0000000..7ba5952
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k6b2yx.h
@@ -0,0 +1,344 @@
+/*
+ * Support for OmniVision S5K6B2YX 1080p HD camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __S5K6B2YX_H__
+#define __S5K6B2YX_H__
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <media/v4l2-ctrls.h>
+
+#include <linux/atomisp_platform.h>
+
+#define S5K6B2YX_NAME		"s5k6b2yx"
+
+/* Defines for register writes and register array processing */
+#define I2C_MSG_LENGTH		0x2
+#define I2C_RETRY_COUNT		5
+
+#define S5K6B2YX_FOCAL_LENGTH_NUM	278	/*2.78mm*/
+#define S5K6B2YX_FOCAL_LENGTH_DEM	100
+#define S5K6B2YX_F_NUMBER_DEFAULT_NUM	26
+#define S5K6B2YX_F_NUMBER_DEM	10
+
+#define MAX_FMTS		1
+
+/*
+ * focal length bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define S5K6B2YX_FOCAL_LENGTH_DEFAULT 0x1160064
+
+/*
+ * current f-number bits definition:
+ * bits 31-16: numerator, bits 15-0: denominator
+ */
+#define S5K6B2YX_F_NUMBER_DEFAULT 0x1a000a
+
+/*
+ * f-number range bits definition:
+ * bits 31-24: max f-number numerator
+ * bits 23-16: max f-number denominator
+ * bits 15-8: min f-number numerator
+ * bits 7-0: min f-number denominator
+ */
+#define S5K6B2YX_F_NUMBER_RANGE 0x1a0a1a0a
+#define S5K6B2YX_ID	0x6b20
+
+#define S5K6B2YX_FINE_INTG_TIME_MIN 0
+#define S5K6B2YX_FINE_INTG_TIME_MAX_MARGIN 0
+#define S5K6B2YX_COARSE_INTG_TIME_MIN 1
+#define S5K6B2YX_COARSE_INTG_TIME_MAX_MARGIN (0xffff - 6)
+
+/*
+ * S5K6B2YX System control registers
+ */
+#define S5K6B2YX_REG_CHIP_ID_H		0x0000
+#define S5K6B2YX_REG_REVISION		0x0002
+
+#define S5K6B2YX_REG_MODE_SELECT	0x0100
+#define S5K6B2YX_REG_IMG_ORI		0x0101
+#define S5K6B2YX_REG_SOFT_RESET		0x0103
+#define S5K6B2YX_REG_GROUND_HOLD	0x0104
+
+#define S5K6B2YX_REG_FINE_INTEG		0x0200
+#define S5K6B2YX_REG_COARSE_INTEG	0x0202
+#define S5K6B2YX_REG_ANALOG_GAIN	0x0204
+
+#define S5K6B2YX_REG_VT_PIX_CLK_DIV_H	0x0300
+#define S5K6B2YX_REG_VT_SYS_CLK_DIV_H	0x0302
+#define S5K6B2YX_REG_PRE_PLL_CLK_DIV_H	0x0304
+#define S5K6B2YX_REG_PLL_MULTIPLIER_H	0x0306
+#define S5K6B2YX_REG_OP_PIX_CLK_DIV_H	0x0308
+#define S5K6B2YX_REG_OP_SYS_CLK_DIV_H	0x030a
+
+#define S5K6B2YX_REG_H_CROP_START_H	0x0344
+#define S5K6B2YX_REG_V_CROP_START_H	0x0346
+#define S5K6B2YX_REG_H_CROP_END_H	0x0348
+#define S5K6B2YX_REG_V_CROP_END_H	0x034a
+#define S5K6B2YX_REG_H_OUTSIZE_H	0x034c
+#define S5K6B2YX_REG_V_OUTSIZE_H	0x034e
+
+#define S5K6B2YX_START_STREAMING	0x01
+#define S5K6B2YX_STOP_STREAMING		0x00
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct s5k6b2yx_resolution {
+	u8 *desc;
+	const struct s5k6b2yx_reg *regs;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int pix_clk_freq;
+	u32 skip_frames;
+	u16 pixels_per_line;
+	u16 lines_per_frame;
+	u8 bin_factor_x;
+	u8 bin_factor_y;
+	u8 bin_mode;
+	bool used;
+	int mipi_freq;
+};
+
+struct s5k6b2yx_format {
+	u8 *desc;
+	u32 pixelformat;
+	struct s5k6b2yx_reg *regs;
+};
+
+struct s5k6b2yx_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, s32 value);
+};
+
+/*
+ * s5k6b2yx device structure.
+ */
+struct s5k6b2yx_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+
+	struct camera_sensor_platform_data *platform_data;
+	int vt_pix_clk_freq_mhz;
+	int fmt_idx;
+	int run_mode;
+	u8 res;
+	u8 type;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *link_freq;
+};
+
+enum s5k6b2yx_tok_type {
+	S5K6B2YX_8BIT  = 0x0001,
+	S5K6B2YX_16BIT = 0x0002,
+	S5K6B2YX_32BIT = 0x0004,
+	S5K6B2YX_TOK_TERM   = 0xf000,	/* terminating token for reg list */
+	S5K6B2YX_TOK_DELAY  = 0xfe00,	/* delay token for reg list */
+	S5K6B2YX_TOK_MASK = 0xfff0
+};
+
+/**
+ * struct s5k6b2yx_reg - MI sensor  register format
+ * @type: type of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ *
+ * Define a structure for sensor register initialization values
+ */
+struct s5k6b2yx_reg {
+	enum s5k6b2yx_tok_type type;
+	u16 reg;
+	u32 val;	/* @set value for read/mod/write, @mask */
+};
+
+#define to_s5k6b2yx_sensor(x) container_of(x, struct s5k6b2yx_device, sd)
+
+#define S5K6B2YX_MAX_WRITE_BUF_SIZE	30
+
+struct s5k6b2yx_write_buffer {
+	u16 addr;
+	u8 data[S5K6B2YX_MAX_WRITE_BUF_SIZE];
+};
+
+struct s5k6b2yx_write_ctrl {
+	int index;
+	struct s5k6b2yx_write_buffer buffer;
+};
+
+static const struct i2c_device_id s5k6b2yx_id[] = {
+	{S5K6B2YX_NAME, 0},
+	{}
+};
+
+/*
+ * Register settings for one-time initialization
+ */
+static struct s5k6b2yx_reg const s5k6b2yx_init[] = {
+	/* Vendor specific */
+	{S5K6B2YX_8BIT, 0x31d3, 0x01}, /* efuse read en */
+	{S5K6B2YX_8BIT, 0x3426, 0x3a}, /* [4]corr_en[3:2]gain_b_sel,[1:0]gain_r_sel */
+	{S5K6B2YX_8BIT, 0x340d, 0x30}, /* efuse clock off */
+
+	{S5K6B2YX_8BIT, 0x3067, 0x25}, /* adc_sat[mV]=617mV */
+	{S5K6B2YX_8BIT, 0x307d, 0x08}, /* dbr_tune_tgs */
+	{S5K6B2YX_8BIT, 0x307e, 0x08}, /* dbr_tune_rg */
+	{S5K6B2YX_8BIT, 0x307f, 0x08}, /* dbr_tune_fdb */
+	{S5K6B2YX_8BIT, 0x3080, 0x04}, /* dbr_tune_ntg */
+	{S5K6B2YX_8BIT, 0x3073, 0x73}, /* comp1_bias, comp2_bias */
+	{S5K6B2YX_8BIT, 0x3074, 0x45}, /* pix_bias, pix_bias_boost */
+	{S5K6B2YX_8BIT, 0x3075, 0xd4}, /* clp_lvl */
+	{S5K6B2YX_8BIT, 0x3085, 0xf0}, /* rdv_option; LOB_PLA enable */
+	{S5K6B2YX_8BIT, 0x3068, 0x55}, /* ms[15:8]; x4~ */
+	{S5K6B2YX_8BIT, 0x3069, 0x00}, /* ms[7:0]; x1~x4 */
+	{S5K6B2YX_8BIT, 0x3063, 0x08}, /* cds_option[15:8];[11]ldb nmos sw enable=1 */
+	{S5K6B2YX_8BIT, 0x3064, 0x00}, /* cds_option[7:0]; */
+	{S5K6B2YX_8BIT, 0x3010, 0x04}, /* FD start 2->4 for low lux fluctuation */
+
+	{S5K6B2YX_8BIT, 0x3247, 0x11}, /*[4] fadlc_blst_en */
+	{S5K6B2YX_8BIT, 0x3083, 0x00}, /* blst_en_cintr = 16 */
+	{S5K6B2YX_8BIT, 0x3084, 0x10},
+
+	/* PLL Setting: ext_clk = 19.2MHz; PLL output = 744MHz */
+	{S5K6B2YX_8BIT, 0x0305, 0x04}, /* pll_pre_pre_div = 4 */
+	{S5K6B2YX_8BIT, 0x0306, 0x00},
+	{S5K6B2YX_8BIT, 0x0307, 0x9B}, /* pll_multiplier = 155 */
+
+	/* Vendor specific */
+	{S5K6B2YX_8BIT, 0x3351, 0x02},
+	{S5K6B2YX_8BIT, 0x3352, 0xdc},
+	{S5K6B2YX_8BIT, 0x3353, 0x00},
+	{S5K6B2YX_8BIT, 0x3354, 0x00},
+
+	/* others */
+	{S5K6B2YX_8BIT, 0x7339, 0x03}, /* [2]dphy_en1, [1]dphy_en0, [0] dhpy_en_clk */
+
+	{S5K6B2YX_8BIT, 0x0202, 0x03},
+	{S5K6B2YX_8BIT, 0x0203, 0x88}, /* TBD: Coarse_integration_time */
+	{S5K6B2YX_8BIT, 0x0204, 0x00},
+	{S5K6B2YX_8BIT, 0x0205, 0x2a}, /* TBD: Analogue_gain_code_global */
+	{S5K6B2YX_TOK_TERM, 0, 0},
+};
+/*
+ * Register settings for various resolution
+ */
+static struct s5k6b2yx_reg const s5k6b2yx_1936_1096_30fps[] = {
+	{S5K6B2YX_8BIT, 0x0344, 0x00}, /* x_addr_start MSB */
+	{S5K6B2YX_8BIT, 0x0345, 0x00}, /* x_addr_start LSB */
+	{S5K6B2YX_8BIT, 0x0346, 0x00}, /* y_addr_start MSB */
+	{S5K6B2YX_8BIT, 0x0347, 0x02}, /* y_addr_start LSB */
+
+	{S5K6B2YX_8BIT, 0x0348, 0x07}, /* x_addr_end MSB */
+	{S5K6B2YX_8BIT, 0x0349, 0x8F}, /* x_addr_end LSB */
+	{S5K6B2YX_8BIT, 0x034a, 0x04}, /* y_addr_end MSB */
+	{S5K6B2YX_8BIT, 0x034b, 0x47}, /* y_addr_end LSB */
+
+	{S5K6B2YX_8BIT, 0x034c, 0x07}, /* x_output_size MSB */
+	{S5K6B2YX_8BIT, 0x034d, 0x90}, /* x_output_size LSB */
+	{S5K6B2YX_8BIT, 0x034e, 0x04}, /* y_output_size MSB */
+	{S5K6B2YX_8BIT, 0x034f, 0x48}, /* y_output_size LSB */
+
+	{S5K6B2YX_8BIT, 0x0340, 0x04}, /* frame_length_lines MSB */
+	{S5K6B2YX_8BIT, 0x0341, 0x66}, /* frame_length_lines LSB */
+	{S5K6B2YX_8BIT, 0x0342, 0x08}, /* line_length_pck MSB */
+	{S5K6B2YX_8BIT, 0x0343, 0x9b}, /* line_length_pck LSB */
+	{S5K6B2YX_TOK_TERM, 0, 0},
+};
+
+struct s5k6b2yx_resolution s5k6b2yx_res_preview[] = {
+	{
+		.desc = "s5k6b2yx_1936_1096_30fps",
+		.width = 1936,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 74,
+		.used = 0,
+		.pixels_per_line = 2203,
+		.lines_per_frame = 1126,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = s5k6b2yx_1936_1096_30fps,
+		.mipi_freq = 372000,
+	},
+};
+#define N_RES_PREVIEW (ARRAY_SIZE(s5k6b2yx_res_preview))
+
+struct s5k6b2yx_resolution s5k6b2yx_res_still[] = {
+	{
+		.desc = "s5k6b2yx_1936_1096_30fps",
+		.width = 1936,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 74,
+		.used = 0,
+		.pixels_per_line = 2203,
+		.lines_per_frame = 1126,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = s5k6b2yx_1936_1096_30fps,
+		.mipi_freq = 372000,
+	},
+};
+#define N_RES_STILL (ARRAY_SIZE(s5k6b2yx_res_still))
+
+struct s5k6b2yx_resolution s5k6b2yx_res_video[] = {
+	{
+		.desc = "s5k6b2yx_1936_1096_30fps",
+		.width = 1936,
+		.height = 1096,
+		.fps = 30,
+		.pix_clk_freq = 74,
+		.used = 0,
+		.pixels_per_line = 2203,
+		.lines_per_frame = 1126,
+		.bin_factor_x = 1,
+		.bin_factor_y = 1,
+		.bin_mode = 0,
+		.skip_frames = 3,
+		.regs = s5k6b2yx_1936_1096_30fps,
+		.mipi_freq = 372000,
+	},
+};
+#define N_RES_VIDEO (ARRAY_SIZE(s5k6b2yx_res_video))
+
+static struct s5k6b2yx_resolution *s5k6b2yx_res = s5k6b2yx_res_preview;
+static int N_RES = N_RES_PREVIEW;
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c
new file mode 100644
index 0000000..f34e47f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay.c
@@ -0,0 +1,1003 @@
+/*
+ * Support for s5k8aay CMOS camera sensor.
+ *
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <linux/atomisp_platform.h>
+#include <linux/libmsrlisthelper.h>
+
+#define S5K8AAY_TOK_16BIT	2
+#define S5K8AAY_TOK_TERM	0xf0	/* terminating token for reg list */
+#define S5K8AAY_TOK_DELAY	0xfe	/* delay token for reg list */
+
+#define S5K8AAY_FORMAT		V4L2_MBUS_FMT_UYVY8_1X16
+
+struct s5k8aay_reg {
+	u8 tok;
+	u16 reg;
+	u16 val;
+};
+
+struct s5k8aay_resolution {
+	u8 *desc;
+	unsigned int width;
+	unsigned int height;
+	unsigned int skip_frames;
+	const struct s5k8aay_reg *mode_regs;
+};
+
+#include "s5k8aay_settings.h"
+
+#define S5K8AAY_REG_CHIP_ID			0x00000040
+#define S5K8AAY_REG_CHIP_ID_VAL			0x08AA
+#define S5K8AAY_REG_ROM_REVISION		0x00000042 /* 0x00A0 / 0x00B0 */
+#define S5K8AAY_REG_TC_IPRM_ERRORINFO		0x70000166
+#define S5K8AAY_REG_TC_GP_ERRORPREVCONFIG	0x700001AE
+#define S5K8AAY_REG_TC_GP_ERRORCAPCONFIG	0x700001B4
+#define S5K8AAY_REG_TC_IPRM_INITHWERR		0x70000144
+#define S5K8AAY_REG_TC_PZOOM_ERRORZOOM		0x700003A2
+#define S5K8AAY_REG_TNP_SVNVERSION		0x700027C0
+#define S5K8AAY_REG_TC_GP_ENABLEPREVIEW		0x7000019e
+#define S5K8AAY_REG_TC_GP_ENABLEPREVIEWCHANGED	0x700001a0
+#define S5K8AAY_REG_MON_AAIO_PREVACQCTX_T_LEI_EXP   0x700020dc
+
+#define S5K8AAY_R16_AHB_MSB_ADDR_PTR		0xfcfc
+
+#define S5K8AAY_FOCAL_LENGTH_NUM		167 /* 1.67mm */
+#define S5K8AAY_FOCAL_LENGTH_DEM		100
+#define S5K8AAY_F_NUMBER_NUM			26  /* 2.6 */
+#define S5K8AAY_F_NUMBER_DEM			10
+
+#define S5K8AAY_FOCAL_LENGTH	    ((S5K8AAY_FOCAL_LENGTH_NUM << 16) | \
+		S5K8AAY_FOCAL_LENGTH_DEM)
+
+#define S5K8AAY_F_NUMBER_ABSOLUTE   ((S5K8AAY_F_NUMBER_NUM << 16) | \
+		S5K8AAY_F_NUMBER_DEM)
+
+#define S5K8AAY_F_NUMBER_RANGE	    ((S5K8AAY_F_NUMBER_NUM << 24) | \
+		(S5K8AAY_F_NUMBER_DEM << 16) | \
+		(S5K8AAY_F_NUMBER_NUM << 8) | \
+		S5K8AAY_F_NUMBER_DEM)
+
+#define to_s5k8aay_sensor(_sd) container_of(_sd, struct s5k8aay_device, sd)
+
+struct s5k8aay_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct camera_sensor_platform_data *platform_data;
+	struct mutex input_lock;
+	struct mutex power_lock;
+	bool streaming;
+	int fmt_idx;
+	struct v4l2_ctrl_handler ctrl_handler;
+	const struct firmware *fw;
+};
+
+/*
+ * Biggest resolution should be last.
+ *
+ * NOTE: Currently sensor outputs only one size per aspect ratio. */
+static const struct s5k8aay_resolution const s5k8aay_res_modes[] = {
+	{
+		.desc = "s5k8aay_1056x864",
+		.width = 1056,
+		.height = 864,
+		.skip_frames = 3,
+		.mode_regs = s5k8aay_regs_19_1056x864,
+	},
+	{
+		.desc = "s5k8aay_1200x800",
+		.width = 1200,
+		.height = 800,
+		.skip_frames = 3,
+		.mode_regs = s5k8aay_regs_19_1200x800,
+	},
+	{
+		.desc = "s5k8aay_1280x720",
+		.width = 1280,
+		.height = 720,
+		.skip_frames = 3,
+		.mode_regs = s5k8aay_regs_19_1280x720,
+	},
+	{
+		.desc = "s5k8aay_1280x960",
+		.width = 1280,
+		.height = 960,
+		.skip_frames = 3,
+		.mode_regs = s5k8aay_regs_19_1280x960,
+	}
+};
+
+static int
+s5k8aay_simple_read16(struct i2c_client *client, int reg, u16 *val)
+{
+	unsigned char buffer[] = {
+		reg >> 8, reg & 0xff
+	};
+	struct i2c_msg msg[] = { {
+		.addr = client->addr,
+		.len = ARRAY_SIZE(buffer),
+		.flags = 0,
+		.buf = buffer,
+	}, {
+		.addr = client->addr,
+		.len = ARRAY_SIZE(buffer),
+		.flags = I2C_M_RD,
+		.buf = buffer,
+	} };
+	int err;
+
+	err = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (err < 0) {
+		dev_err(&client->dev,
+			"read from offset 0x%x error %d", reg, err);
+		return err;
+	}
+
+	*val = buffer[1] + (buffer[0] << 8);
+	return 0;
+}
+
+static int
+s5k8aay_simple_write16(struct i2c_client *client, int reg, int val)
+{
+	unsigned char buffer[] = {
+		reg >> 8, reg & 0xff,
+		val >> 8, val & 0xff
+	};
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.len = ARRAY_SIZE(buffer),
+		.flags = 0,
+		.buf = buffer,
+	};
+	int err;
+
+	err = i2c_transfer(client->adapter, &msg, 1);
+	if (err < 0)
+		dev_err(&client->dev,
+			"write error: wrote 0x%x to offset 0x%x error %d",
+			val, reg, err);
+	return 0;
+}
+
+static int s5k8aay_write_array(struct i2c_client *client,
+			       const struct s5k8aay_reg *reglist)
+{
+	const struct s5k8aay_reg *next = reglist;
+	int ret;
+
+	for (; next->tok != S5K8AAY_TOK_TERM; next++) {
+		if (next->tok == S5K8AAY_TOK_DELAY) {
+			usleep_range(next->val * 1000, next->val * 1000);
+			continue;
+		}
+		ret = s5k8aay_simple_write16(client, next->reg, next->val);
+		if (ret) {
+			dev_err(&client->dev, "register write failed\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int s5k8aay_write(struct i2c_client *client, u32 addr, u16 val)
+{
+	int ret;
+
+	ret = s5k8aay_simple_write16(client, S5K8AAY_R16_AHB_MSB_ADDR_PTR,
+				     addr >> 16);
+	if (ret < 0)
+		return ret;
+
+	return s5k8aay_simple_write16(client, addr & 0xffff, val);
+}
+
+static int s5k8aay_read(struct i2c_client *client, u32 addr, u16 *val)
+{
+	int ret;
+
+	ret = s5k8aay_simple_write16(client, S5K8AAY_R16_AHB_MSB_ADDR_PTR,
+				     addr >> 16);
+	if (ret < 0)
+		return ret;
+
+	return s5k8aay_simple_read16(client, addr & 0xffff, val);
+}
+
+static int s5k8aay_check_error(struct s5k8aay_device *dev,
+			       struct i2c_client *client)
+{
+	static struct {
+		char *error;
+		int address;
+	} error_codes[] = {
+		{ "ErrorInfo",		S5K8AAY_REG_TC_IPRM_ERRORINFO },
+		{ "ErrorPrevConfig",	S5K8AAY_REG_TC_GP_ERRORPREVCONFIG },
+		{ "ErrorCapConfig",	S5K8AAY_REG_TC_GP_ERRORCAPCONFIG },
+		{ "InitHwErr",		S5K8AAY_REG_TC_IPRM_INITHWERR },
+		{ "ErrorZoom",		S5K8AAY_REG_TC_PZOOM_ERRORZOOM },
+		{ "TnP_SvnVersion",	S5K8AAY_REG_TNP_SVNVERSION },
+	};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(error_codes); i++) {
+		u16 v;
+		int ret = s5k8aay_read(client, error_codes[i].address, &v);
+		if (ret)
+			return ret;
+		dev_info(&client->dev, "%s: %i\n", error_codes[i].error, v);
+	}
+
+	return 0;
+}
+
+static int s5k8aay_reset(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* Reset */
+	ret = s5k8aay_write(client, 0xd0000010, 0x0001);
+	if (ret < 0)
+		return ret;
+
+	/* Clear host interrupt */
+	ret = s5k8aay_write(client, 0xd0001030, 0x0000);
+	if (ret < 0)
+		return ret;
+
+	/* ARM go */
+	ret = s5k8aay_write(client, 0xd0000014, 0x0001);
+	if (ret < 0)
+		return ret;
+
+	/* Allow startup code to run */
+	usleep_range(1000, 1000);
+
+	return 0;
+}
+
+static int s5k8aay_set_suspend(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	int ret;
+
+	dev->streaming = false;
+	ret = s5k8aay_write(client, S5K8AAY_REG_TC_GP_ENABLEPREVIEW, 0x0000);
+	if (ret < 0)
+		return ret;
+
+	return s5k8aay_write(client, S5K8AAY_REG_TC_GP_ENABLEPREVIEWCHANGED,
+			     0x0001);
+}
+
+static int s5k8aay_write_array_list(struct v4l2_subdev *sd,
+		struct s5k8aay_reg const *regs[], unsigned int size)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int i;
+
+	for (i = 0; i < size; i++) {
+		int ret = s5k8aay_write_array(client, regs[i]);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static int s5k8aay_set_streaming(struct v4l2_subdev *sd)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	static struct s5k8aay_reg const *pre_regs[] = {
+		s5k8aay_regs_1,
+	};
+
+	const struct s5k8aay_reg const *mode_regs[] = {
+		s5k8aay_res_modes[dev->fmt_idx].mode_regs,
+	};
+
+	static struct s5k8aay_reg const *post_regs[] = {
+		s5k8aay_regs_21,
+	};
+	int ret;
+
+	ret = s5k8aay_write_array_list(sd, pre_regs, ARRAY_SIZE(pre_regs));
+	if (ret)
+		return ret;
+
+	if (dev->fw) {
+		ret = apply_msr_data(client, dev->fw);
+		if (ret)
+			return ret;
+	}
+
+	ret = s5k8aay_write_array_list(sd, mode_regs, ARRAY_SIZE(mode_regs));
+	if (ret)
+		return ret;
+
+	ret = s5k8aay_write_array_list(sd, post_regs, ARRAY_SIZE(post_regs));
+	if (ret)
+		return ret;
+
+	ret = s5k8aay_check_error(dev, client);
+	if (ret)
+		return ret;
+
+	dev->streaming = true;
+
+	return 0;
+}
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	usleep_range(15, 15);
+
+	/* Release reset */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		goto fail_gpio;
+
+	/* 100 us is needed between power up and first i2c transaction. */
+	usleep_range(100, 100);
+
+	return 0;
+
+fail_gpio:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_clk:
+	dev->platform_data->power_ctrl(sd, 0);
+fail_power:
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio off failed\n");
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk off failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "power off failed\n");
+
+	return ret;
+}
+
+static int __s5k8aay_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0) {
+		return power_down(sd);
+	} else {
+		int ret = power_up(sd);
+		if (ret)
+			return ret;
+
+		ret = s5k8aay_reset(sd);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int s5k8aay_s_power(struct v4l2_subdev *sd, int power)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->power_lock);
+	ret = __s5k8aay_s_power(sd, power);
+	if (ret)
+		goto out;
+
+	ret = v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+	if (ret)
+		goto out;
+
+out:
+	mutex_unlock(&dev->power_lock);
+
+	return ret;
+}
+
+#define ASPECT_RATIO(w, h)  (((w) << 13) / (h))
+
+static bool check_aspect_ratio(struct s5k8aay_resolution const *res,
+		unsigned int width, unsigned int height)
+{
+	return ASPECT_RATIO(res->width, res->height) == ASPECT_RATIO(width,
+			height);
+}
+
+/*
+ * Returns the nearest higher resolution index.
+ * @w: width
+ * @h: height
+ * matching is done based on aspect ratio.
+ * If the aspect ratio cannot be matched to any index, -1 is returned.
+ */
+static int nearest_resolution_index(struct v4l2_subdev *sd, int w, int h)
+{
+	int i;
+	int idx = -1;
+
+	for (i = 0; i < ARRAY_SIZE(s5k8aay_res_modes); i++) {
+		if (check_aspect_ratio(&s5k8aay_res_modes[i], w, h)) {
+			idx = i;
+			break;
+		}
+	}
+	return idx;
+}
+
+static int s5k8aay_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	int idx;
+	const struct s5k8aay_resolution *biggest =
+		&s5k8aay_res_modes[ARRAY_SIZE(s5k8aay_res_modes) - 1];
+
+	if ((fmt->width > biggest->width) ||
+	    (fmt->height > biggest->height)) {
+		fmt->width = biggest->width;
+		fmt->height = biggest->height;
+	} else {
+		/* Find nearest resolution with same aspect ratio. */
+		idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+
+		/* Same aspect ratio was not found from the list.
+		 * Take last defined resolution. */
+		if (idx == -1) {
+			idx = ARRAY_SIZE(s5k8aay_res_modes) - 1;
+			WARN_ONCE(1, "Correct aspect ratio was not found.");
+		}
+
+		fmt->width = s5k8aay_res_modes[idx].width;
+		fmt->height = s5k8aay_res_modes[idx].height;
+	}
+
+	fmt->code = S5K8AAY_FORMAT;
+	return 0;
+}
+
+static int s5k8aay_get_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	fmt->width = s5k8aay_res_modes[dev->fmt_idx].width;
+	fmt->height = s5k8aay_res_modes[dev->fmt_idx].height;
+	fmt->code = S5K8AAY_FORMAT;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int s5k8aay_set_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	int ret;
+	int tmp_idx;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = s5k8aay_try_mbus_fmt(sd, fmt);
+	if (ret)
+		goto out;
+
+	tmp_idx = nearest_resolution_index(sd, fmt->width, fmt->height);
+	/* Sanity check */
+	if (unlikely(tmp_idx == -1)) {
+		ret = -EINVAL;
+		goto out;
+	}
+	dev->fmt_idx = tmp_idx;
+
+out:
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int s5k8aay_detect(struct s5k8aay_device *dev, struct i2c_client *client)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	u32 ret;
+	u16 id = -1, revision = -1;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+
+	ret = s5k8aay_read(client, S5K8AAY_REG_CHIP_ID, &id);
+	if (ret)
+		return ret;
+
+	ret = s5k8aay_read(client, S5K8AAY_REG_ROM_REVISION, &revision);
+	if (ret)
+		return ret;
+
+	dev_info(&client->dev, "chip id 0x%4.4x, ROM revision 0x%4.4x\n",
+		 id, revision);
+
+	if (id != S5K8AAY_REG_CHIP_ID_VAL) {
+		dev_err(&client->dev, "failed to detect sensor\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int
+s5k8aay_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	dev->platform_data = platform_data;
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "s5k8aay platform init err\n");
+			return ret;
+		}
+	}
+
+	ret = __s5k8aay_s_power(sd, 1);
+	if (ret) {
+		dev_err(&client->dev, "s5k8aay power-up err %i\n", ret);
+		return ret;
+	}
+
+	/* config & detect sensor */
+	ret = s5k8aay_detect(dev, client);
+	if (ret) {
+		dev_err(&client->dev, "s5k8aay_detect err s_config.\n");
+		goto fail_detect;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	ret = s5k8aay_set_suspend(sd);
+	if (ret) {
+		dev_err(&client->dev, "s5k8aay suspend err");
+		return ret;
+	}
+
+	ret = __s5k8aay_s_power(sd, 0);
+	if (ret) {
+		dev_err(&client->dev, "s5k8aay power down err");
+		return ret;
+	}
+
+	return 0;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_detect:
+	__s5k8aay_s_power(sd, 0);
+	dev_err(&client->dev, "sensor detection failed\n");
+	return ret;
+}
+
+static int s5k8aay_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	if (enable)
+		ret = s5k8aay_set_streaming(sd);
+	else
+		ret = s5k8aay_set_suspend(sd);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int
+s5k8aay_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+
+	if (fsize->index >= ARRAY_SIZE(s5k8aay_res_modes))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = s5k8aay_res_modes[fsize->index].width;
+	fsize->discrete.height = s5k8aay_res_modes[fsize->index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int s5k8aay_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+
+	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int s5k8aay_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+
+	if (fse->index >= ARRAY_SIZE(s5k8aay_res_modes))
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fse->min_width = s5k8aay_res_modes[fse->index].width;
+	fse->min_height = s5k8aay_res_modes[fse->index].height;
+	fse->max_width = s5k8aay_res_modes[fse->index].width;
+	fse->max_height = s5k8aay_res_modes[fse->index].height;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__s5k8aay_get_pad_format(struct s5k8aay_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+s5k8aay_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct s5k8aay_device *snr = to_s5k8aay_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__s5k8aay_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&snr->input_lock);
+	fmt->format = *format;
+	mutex_unlock(&snr->input_lock);
+
+	return 0;
+}
+
+static int
+s5k8aay_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct s5k8aay_device *snr = to_s5k8aay_sensor(sd);
+	struct v4l2_mbus_framefmt *format =
+			__s5k8aay_get_pad_format(snr, fh, fmt->pad, fmt->which);
+
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&snr->input_lock);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+	mutex_unlock(&snr->input_lock);
+
+	return 0;
+}
+
+static int s5k8aay_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct s5k8aay_device *snr = to_s5k8aay_sensor(sd);
+
+	mutex_lock(&snr->input_lock);
+	*frames = s5k8aay_res_modes[snr->fmt_idx].skip_frames;
+	mutex_unlock(&snr->input_lock);
+
+	return 0;
+}
+
+
+static const struct v4l2_subdev_sensor_ops s5k8aay_sensor_ops = {
+	.g_skip_frames = s5k8aay_g_skip_frames,
+};
+
+static const struct v4l2_subdev_video_ops s5k8aay_video_ops = {
+	.try_mbus_fmt = s5k8aay_try_mbus_fmt,
+	.s_mbus_fmt = s5k8aay_set_mbus_fmt,
+	.g_mbus_fmt = s5k8aay_get_mbus_fmt,
+	.s_stream = s5k8aay_s_stream,
+	.enum_framesizes = s5k8aay_enum_framesizes,
+};
+
+static const struct v4l2_subdev_core_ops s5k8aay_core_ops = {
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_power = s5k8aay_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops s5k8aay_pad_ops = {
+	.enum_mbus_code = s5k8aay_enum_mbus_code,
+	.enum_frame_size = s5k8aay_enum_frame_size,
+	.get_fmt = s5k8aay_get_pad_format,
+	.set_fmt = s5k8aay_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops s5k8aay_ops = {
+	.core = &s5k8aay_core_ops,
+	.video = &s5k8aay_video_ops,
+	.pad = &s5k8aay_pad_ops,
+	.sensor = &s5k8aay_sensor_ops,
+};
+
+static int s5k8aay_g_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct s5k8aay_device *dev = container_of(
+		ctrl->handler, struct s5k8aay_device, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&dev->sd);
+	int ret;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE_ABSOLUTE:
+		{
+		u16 val;
+		ret = s5k8aay_read(client,
+			S5K8AAY_REG_MON_AAIO_PREVACQCTX_T_LEI_EXP, &val);
+		if (ret)
+			return ret;
+
+		/* Exposure time of the previous frame (400 = 1ms)
+		 * x * (1 / 400)ms */
+		/* Returned value is in units of 100us */
+		ctrl->val = val / 40;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops s5k8aay_ctrl_ops = {
+	.g_volatile_ctrl = &s5k8aay_g_ctrl,
+};
+
+static const struct v4l2_ctrl_config ctrls[] = {
+	{
+		.id = V4L2_CID_FOCAL_ABSOLUTE,
+		.name = "Focal length",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = S5K8AAY_FOCAL_LENGTH,
+		.step = 1,
+		.max = S5K8AAY_FOCAL_LENGTH,
+		.def = S5K8AAY_FOCAL_LENGTH,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.id = V4L2_CID_FNUMBER_ABSOLUTE,
+		.name = "F-number",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = S5K8AAY_F_NUMBER_ABSOLUTE,
+		.step = 1,
+		.max = S5K8AAY_F_NUMBER_ABSOLUTE,
+		.def = S5K8AAY_F_NUMBER_ABSOLUTE,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.id = V4L2_CID_FNUMBER_RANGE,
+		.name = "F-number range",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = S5K8AAY_F_NUMBER_RANGE,
+		.step = 1,
+		.max = S5K8AAY_F_NUMBER_RANGE,
+		.def = S5K8AAY_F_NUMBER_RANGE,
+		.flags = V4L2_CTRL_FLAG_READ_ONLY,
+	}, {
+		.id = V4L2_CID_EXPOSURE_ABSOLUTE,
+		.name = "Absolute exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.min = 0,
+		.step = 1,
+		.max = 0xffffff,
+		.def = 0,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.ops = &s5k8aay_ctrl_ops,
+	},
+};
+
+static int s5k8aay_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct s5k8aay_device *dev = to_s5k8aay_sensor(sd);
+
+	dev->platform_data->csi_cfg(sd, 0);
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+	media_entity_cleanup(&dev->sd.entity);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	v4l2_device_unregister_subdev(sd);
+	mutex_destroy(&dev->input_lock);
+	if (dev->fw)
+		release_msr_list(client, dev->fw);
+	kfree(dev);
+	return 0;
+}
+
+static int s5k8aay_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct s5k8aay_device *dev;
+	char *msr_file_name = NULL;
+	unsigned int i;
+	int ret;
+
+	if (!client->dev.platform_data) {
+		dev_err(&client->dev, "no platform data\n");
+		return -ENODEV;
+	}
+
+	/* Setup sensor configuration structure */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+	mutex_init(&dev->power_lock);
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &s5k8aay_ops);
+
+	ret = s5k8aay_s_config(&dev->sd, client->irq,
+			       client->dev.platform_data);
+	if (ret) {
+		kfree(dev);
+		return ret;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	dev->format.code = V4L2_MBUS_FMT_UYVY8_1X16;
+	/* Set default resolution to biggest resolution. */
+	dev->fmt_idx = ARRAY_SIZE(s5k8aay_res_modes) - 1;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		kfree(dev);
+		return ret;
+	}
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, ARRAY_SIZE(ctrls));
+	if (ret) {
+		s5k8aay_remove(client);
+		return ret;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ctrls); i++)
+		v4l2_ctrl_new_custom(&dev->ctrl_handler, &ctrls[i], NULL);
+
+	if (dev->ctrl_handler.error) {
+		s5k8aay_remove(client);
+		return dev->ctrl_handler.error;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+
+	if (dev->platform_data->msr_file_name)
+		msr_file_name = dev->platform_data->msr_file_name();
+	if (msr_file_name) {
+		ret = load_msr_list(client, msr_file_name, &dev->fw);
+		if (ret) {
+			s5k8aay_remove(client);
+			return ret;
+		}
+	} else
+		dev_warn(&client->dev, "%s: MSR data not available", __func__);
+
+	return ret;
+}
+
+static const struct i2c_device_id s5k8aay_id[] = {
+	{ "s5k8aay", 0 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, s5k8aay_id);
+
+static struct i2c_driver s5k8aay_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "s5k8aay"
+	},
+	.probe = s5k8aay_probe,
+	.remove = s5k8aay_remove,
+	.id_table = s5k8aay_id,
+};
+
+static int init_s5k8aay(void)
+{
+	return i2c_add_driver(&s5k8aay_driver);
+}
+
+static void exit_s5k8aay(void)
+{
+	i2c_del_driver(&s5k8aay_driver);
+}
+
+module_init(init_s5k8aay);
+module_exit(exit_s5k8aay);
+
+MODULE_AUTHOR("Tuukka Toivonen <tuukka.toivonen@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h
new file mode 100644
index 0000000..e593a3c
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/s5k8aay_settings.h
@@ -0,0 +1,248 @@
+/*
+ * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+/* Source:
+ * 8AA_EVT1prev_Cap_1280x960_30fps_M19 2_S58_P116_130530_1_FINAL_REAL.TSET
+ *
+ *  [8AA_EVT1]Preview 640x480_30fps_Capture 1280x960_30fps_M19.2_S58_P116.nset
+ */
+
+static struct s5k8aay_reg const s5k8aay_regs_1[] = {		/* 01.Start Setting */
+	/* $MIPI[Width:1280,Height:720,Format:YUV422,Lane:1,ErrorCheck:0,PolarityData:0,PolarityClock:0,Buffer:2] */
+
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /* Default page address setting */
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /* Enable Address Auto-Increase */
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /* Default page address setting */
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /* Enable Address Auto-Increase */
+
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 }, /* Default page address setting */
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0000 }, /* Enable Address Auto-Increase */
+
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
+	{ S5K8AAY_TOK_16BIT, 0x0010, 0x0001 }, /* S/W Reset */
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0x0000 },
+	{ S5K8AAY_TOK_16BIT, 0x0000, 0x0000 }, /* Simmian bug workaround */
+
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
+	{ S5K8AAY_TOK_16BIT, 0x1030, 0x0000 }, /* contint_host_int */
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
+	{ S5K8AAY_TOK_16BIT, 0x0014, 0x0001 },
+
+	{ S5K8AAY_TOK_DELAY, 0, 20 },	       /* Delay 20ms */
+
+	{ S5K8AAY_TOK_TERM, 0, 0 }
+};
+
+static struct s5k8aay_reg const s5k8aay_regs_19_1056x864[] = {		/* 19.Input Size Setting */
+	{ S5K8AAY_TOK_16BIT, 0x0138, 0x0420 },	/* REG_TC_IPRM_InputWidthSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x0360 },	/* REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0070 },	/* REG_TC_IPRM_InputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0030 },	/* REG_TC_IPRM_InputHeightOfs */
+
+
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x04B0 },	/* REG_TC_PZOOM_ZoomInputWidth */
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x0320 },	/* REG_TC_PZOOM_ZoomInputHeight */
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0000 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+
+	/* Preview config[0] 1056X864  xxfps // */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0420 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x0360 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+
+	/* // Capture config[0] 1056x864  xxfps */
+	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0420 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x0360 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+
+	{ S5K8AAY_TOK_TERM, 0, 0 }
+};
+
+static struct s5k8aay_reg const s5k8aay_regs_19_1200x800[] = {		/* 19.Input Size Setting */
+	{ S5K8AAY_TOK_16BIT, 0x0138, 0x04B0 },	/* REG_TC_IPRM_InputWidthSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x0320 },	/* REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0028 },	/* REG_TC_IPRM_InputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0080 },	/* REG_TC_IPRM_InputHeightOfs */
+
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x04B0 },	/* REG_TC_PZOOM_ZoomInputWidth */
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x0320 },	/* REG_TC_PZOOM_ZoomInputHeight */
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0080 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+
+	/* Preview config[0] 1200X800  xxfps // */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x04B0 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x0320 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+
+	/* // Capture config[0] 1200x800  xxfps */
+	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x04B0 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x0320 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+
+	{ S5K8AAY_TOK_TERM, 0, 0 }
+};
+
+static struct s5k8aay_reg const s5k8aay_regs_19_1280x720[] = {		/* 19.Input Size Setting */
+	{ S5K8AAY_TOK_16BIT, 0x0138, 0x0500 },	/* REG_TC_IPRM_InputWidthSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x02D0 },	/* 03C0 //REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0000 },	/* REG_TC_IPRM_InputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0078 },	/* REG_TC_IPRM_InputHeightOfs */
+
+
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x0500 },	/* REG_TC_PZOOM_ZoomInputWidth */
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x02D0 },	/* 03C0 //REG_TC_PZOOM_ZoomInputHeight */
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0078 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+
+	/* Preview config[0] 1280X720  30fps // */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0500 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x02D0 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0000 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x014D },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+
+	/* // Capture config[0] 1280x720  30fps */
+	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0500 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x02D0 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0042 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0002 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+
+	{ S5K8AAY_TOK_TERM, 0, 0 }
+};
+
+
+static struct s5k8aay_reg const s5k8aay_regs_19_1280x960[] = {		/* 19.Input Size Setting */
+
+	{ S5K8AAY_TOK_16BIT, 0x0138, 0x0500 },	/* REG_TC_IPRM_InputWidthSize */
+	{ S5K8AAY_TOK_16BIT, 0x013A, 0x03C0 },	/* REG_TC_IPRM_InputHeightSize */
+	{ S5K8AAY_TOK_16BIT, 0x013C, 0x0000 },	/* REG_TC_IPRM_InputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x013E, 0x0000 },	/* REG_TC_IPRM_InputHeightOfs */
+
+	{ S5K8AAY_TOK_16BIT, 0x03A6, 0x0500 },	/* REG_TC_PZOOM_ZoomInputWidth */
+	{ S5K8AAY_TOK_16BIT, 0x03A8, 0x03C0 },	/* REG_TC_PZOOM_ZoomInputHeight */
+	{ S5K8AAY_TOK_16BIT, 0x03AA, 0x0000 },	/* REG_TC_PZOOM_ZoomInputWidthOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03AC, 0x0000 },	/* REG_TC_PZOOM_ZoomInputHeightOfs */
+	{ S5K8AAY_TOK_16BIT, 0x03A0, 0x0001 },	/* REG_TC_PZOOM_ZoomPanTiltRequest */
+
+	/* Preview config[0] 1280X960  30fps // */
+	{ S5K8AAY_TOK_16BIT, 0x01BE, 0x0500 },	/* REG_0TC_PCFG_usWidth 500:1280; 280:640  0500 */
+	{ S5K8AAY_TOK_16BIT, 0x01C0, 0x03C0 },	/* REG_0TC_PCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x01C2, 0x0005 },	/* REG_0TC_PCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x01C8, 0x0000 },	/* REG_0TC_PCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x01C4, 0x0052 },	/* REG_0TC_PCFG_PVIMask 52:YUV422, 42:RAW10   42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x01D4, 0x0002 },	/* REG_0TC_PCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x01D2, 0x0001 },	/* REG_0TC_PCFG_usFrTimeType  0:dynamic; 1:fixed not accurate; 2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x01D8, 0x014D },	/* 02BA	// REG_0TC_PCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x01D6, 0x0000 },	/* 014D// REG_0TC_PCFG_usMinFrTimeMsecMult10 */
+	{ S5K8AAY_TOK_16BIT, 0x01E8, 0x0000 },	/* REG_0TC_PCFG_uPrevMirror */
+	{ S5K8AAY_TOK_16BIT, 0x01EA, 0x0000 },	/* REG_0TC_PCFG_uCaptureMirror */
+
+	/* // Capture config[0] 1280x960  xxfps */
+	{ S5K8AAY_TOK_16BIT, 0x02AE, 0x0001 },	/* Capture mode AE On */
+	{ S5K8AAY_TOK_16BIT, 0x02B0, 0x0500 },	/* REG_0TC_CCFG_usWidth 500:1280; 280:640 */
+	{ S5K8AAY_TOK_16BIT, 0x02B2, 0x03C0 },	/* REG_0TC_CCFG_usHeight 3C0:960; 1E0:480 */
+	{ S5K8AAY_TOK_16BIT, 0x02B4, 0x0005 },	/* REG_0TC_CCFG_Format 5:YUV422; 7:RAW10 */
+	{ S5K8AAY_TOK_16BIT, 0x02BA, 0x0000 },	/* REG_0TC_CCFG_uClockInd */
+	/* debug liao */
+	{ S5K8AAY_TOK_16BIT, 0x02B6, 0x0052 },	/* REG_0TC_CCFG_PVIMask 52:YUV422; 42:RAW10  42;40;4E;4A;46 */
+	{ S5K8AAY_TOK_16BIT, 0x02C6, 0x0002 },	/* REG_0TC_CCFG_FrRateQualityType  1b:FR(bin) 2b:Quality(no-bin) */
+	{ S5K8AAY_TOK_16BIT, 0x02C4, 0x0001 },	/* REG_0TC_CCFG_usFrTimeType  0:dynamic; 1:fixed not accurate;	2:fixed accurate */
+	{ S5K8AAY_TOK_16BIT, 0x02CA, 0x014D },	/* 014D	// REG_0TC_CCFG_usMaxFrTimeMsecMult10  30fps-014D; 15fps-029A; 7.5-0535; 6.0-0682; 3.75-0A6A */
+	{ S5K8AAY_TOK_16BIT, 0x02C8, 0x0000 },	/* REG_0TC_CCFG_usMinFrTimeMsecMult10 */
+
+	{ S5K8AAY_TOK_TERM, 0, 0 }
+};
+
+
+static struct s5k8aay_reg const s5k8aay_regs_21[] = {		/* 21.Select Cofigration Display */
+	{ S5K8AAY_TOK_16BIT, 0x01A8, 0x0000 },	/* REG_TC_GP_ActivePreviewConfig */
+	{ S5K8AAY_TOK_16BIT, 0x01AC, 0x0001 },	/* REG_TC_GP_PrevOpenAfterChange */
+	{ S5K8AAY_TOK_16BIT, 0x01A6, 0x0001 },	/* REG_TC_GP_NewConfigSync */
+	{ S5K8AAY_TOK_16BIT, 0x01AC, 0x0001 },	/* REG_TC_GP_PrevOpenAfterChange */
+	{ S5K8AAY_TOK_16BIT, 0x01A6, 0x0001 },	/* REG_TC_GP_NewConfigSync */
+	{ S5K8AAY_TOK_16BIT, 0x01AA, 0x0001 },	/* REG_TC_GP_PreviewConfigChanged */
+	{ S5K8AAY_TOK_16BIT, 0x019E, 0x0001 },	/* REG_TC_GP_EnablePreview */
+	{ S5K8AAY_TOK_16BIT, 0x01A0, 0x0001 },	/* REG_TC_GP_EnablePreviewChanged */
+
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
+	{ S5K8AAY_TOK_16BIT, 0x1000, 0x0001 },	/* Set host interrupt */
+
+	{ S5K8AAY_TOK_DELAY, 0, 150 },	/* mdelay(150  //p150 //delay 150ms */
+
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0001 },
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0001 },
+	{ S5K8AAY_TOK_16BIT, 0xFCFC, 0xD000 },
+	{ S5K8AAY_TOK_16BIT, 0x0004, 0x0001 },
+
+	{ S5K8AAY_TOK_TERM, 0, 0 }
+};
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c b/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c
new file mode 100644
index 0000000..c76f644
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.c
@@ -0,0 +1,627 @@
+/*
+ * Support for mipi CSI data generator.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include <linux/atomisp_platform.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+
+#include "xactor_x.h"
+
+#define MODE_DEFAULT 1
+#define MODE_PIXTER 1
+#define MODE_XACTOR 2
+unsigned int mode = MODE_DEFAULT;
+module_param(mode, uint, 0644);
+MODULE_PARM_DESC(mode,
+		"Control the mode how xactor driver operates default = 1. (1=Pixter, 2=SLE csi xactor)");
+
+#define to_csi_xactor_dev(sd) container_of(sd, struct csi_xactor_device, sd)
+
+static int csi_xactor_s_config(struct v4l2_subdev *sd,
+			    int irq, void *pdata)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (pdata == NULL)
+		return -ENODEV;
+
+	dev->platform_data = pdata;
+
+	mutex_lock(&dev->input_lock);
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+
+fail_csi_cfg:
+	mutex_unlock(&dev->input_lock);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+	return ret;
+}
+
+static int csi_xactor_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+
+	media_entity_cleanup(&dev->sd.entity);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	dev->platform_data->csi_cfg(sd, 0);
+	v4l2_device_unregister_subdev(sd);
+	kfree(dev);
+
+	return 0;
+}
+
+static enum xactor_contexts xactor_get_context(struct v4l2_subdev *sd)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	return dev->cur_context;
+}
+
+static int csi_xactor_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (mode == MODE_XACTOR) {
+		/* This is the CSI xactor test code for SLE */
+		void __iomem *base;
+		unsigned int xactor_on;
+
+#define CSI_XACTOR_UNPAUSE_REG_ADDR    0x100000
+		/* lane can only be 4, 1, 2*/
+#define CSI_XACTOR_PAUSE(lane, pause_en) \
+		(0xc5180000 | (lane<<16) | (((pause_en) ? 7 : 0)<<8))
+
+		if (strcmp(client->name, CSI_XACTOR_A_NAME) == 0) {
+			dev_dbg(&client->dev, "set stream on to %d port a\n", enable);
+			xactor_on = CSI_XACTOR_PAUSE(1, !enable);
+		} else if (strcmp(client->name, CSI_XACTOR_B_NAME) == 0) {
+			dev_dbg(&client->dev, "set stream on to %d port b\n", enable);
+			xactor_on = CSI_XACTOR_PAUSE(2, !enable);
+		} else if (strcmp(client->name, CSI_XACTOR_C_NAME) == 0) {
+			dev_dbg(&client->dev, "set stream on to %d port c\n", enable);
+			xactor_on = CSI_XACTOR_PAUSE(4, !enable);
+		} else {
+			dev_err(&client->dev, "xactor driver doesn't match!\n");
+			return -EINVAL;
+		}
+
+		base = phys_to_virt(CSI_XACTOR_UNPAUSE_REG_ADDR);
+		if (!base) {
+			dev_dbg(&client->dev, "Failed to phys_to_virt(CSI_XACTOR_UNPAUSE_REG_ADDR)\n");
+			return -EINVAL;
+		}
+
+		if (enable) {
+			dev_dbg(&client->dev, "waiting  for sensor to start sending data\n");
+			usleep_range(40000000, 55000000);
+		}
+
+		/* only for SLE to stop MIPI xactor */
+		dev_dbg(&client->dev, "%s_stream: 0x%x\n", __func__, xactor_on);
+		*(s32 __force *)((unsigned int)base) = xactor_on;
+
+		dev_dbg(&client->dev, "vir: 0x%x, phy: 0x%x, data: 0x%x\n",
+				(unsigned int)base,
+				(unsigned int)virt_to_phys(base),
+				*(s32 __force *)((unsigned int)base));
+	} else {
+		dev_dbg(&client->dev, "stream on for pixter\n");
+	}
+
+	return 0;
+}
+
+static int get_intg_factor(struct i2c_client *client,
+				struct camera_mipi_info *info)
+{
+	struct atomisp_sensor_mode_data *buf = &info->data;
+
+	if (info == NULL)
+		return -EINVAL;
+
+	/* Dummy values for tuning. */
+	buf->crop_horizontal_start = 0;
+	buf->crop_vertical_start = 0;
+
+	buf->crop_horizontal_end = 1000;
+
+	buf->crop_vertical_end = 1000;
+
+	buf->output_width = 1000;
+
+	buf->output_height = 1000;
+
+	buf->vt_pix_clk_freq_mhz = 19000000;
+	buf->coarse_integration_time_min = 0;
+	buf->coarse_integration_time_max_margin = 0;
+
+	buf->fine_integration_time_min = 1;
+	buf->fine_integration_time_max_margin = 1000;
+	buf->fine_integration_time_def = 1;
+	buf->frame_length_lines = 100000;
+	buf->line_length_pck = 10000;
+	buf->read_mode = 0;
+
+	buf->binning_factor_x = 1;
+	buf->binning_factor_y = 1;
+
+	return 0;
+}
+
+static int csi_xactor_g_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_frame_interval *interval)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *info = v4l2_get_subdev_hostdata(sd);
+	if (info == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+
+	/* Return the currently selected settings' maximum frame interval */
+
+	get_intg_factor(client, info);
+	interval->interval.numerator = 1;
+	interval->interval.denominator = 15;
+
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int csi_xactor_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
+				 enum v4l2_mbus_pixelcode *code)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	*code = dev->cntx_config[0].mbus_fmt;
+	return 0;
+}
+
+static int csi_xactor_try_mbus_fmt(struct v4l2_subdev *sd,
+			       struct v4l2_mbus_framefmt *fmt)
+{
+	return 0;
+}
+
+static int csi_xactor_g_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	struct atomisp_input_stream_info *stream_info =
+		(struct atomisp_input_stream_info*)fmt->reserved;
+
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	fmt->width = dev->cntx_config[stream_info->stream].width;
+	fmt->height = dev->cntx_config[stream_info->stream].height;
+	fmt->code = dev->cntx_config[stream_info->stream].mbus_fmt;
+	mutex_unlock(&dev->input_lock);
+
+	dev_dbg(&client->dev, "%s w:%d h:%d code: 0x%x stream: %d\n", __func__,
+			fmt->width, fmt->height, fmt->code,
+			stream_info->stream);
+
+	return 0;
+}
+
+static enum xactor_contexts xactor_cntx_mapping[] = {
+	CONTEXT_PREVIEW,	/* Invalid atomisp run mode */
+	CONTEXT_VIDEO,		/* ATOMISP_RUN_MODE_VIDEO */
+	CONTEXT_SNAPSHOT,	/* ATOMISP_RUN_MODE_STILL_CAPTURE */
+	CONTEXT_SNAPSHOT,	/* ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE */
+	CONTEXT_PREVIEW,	/* ATOMISP_RUN_MODE_PREVIEW */
+};
+
+static enum xactor_contexts stream_to_context[] = {
+	CONTEXT_SNAPSHOT,
+	CONTEXT_PREVIEW,
+	CONTEXT_PREVIEW,
+	CONTEXT_VIDEO
+};
+
+static int csi_xactor_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_mipi_info *info = v4l2_get_subdev_hostdata(sd);
+	struct atomisp_input_stream_info *stream_info =
+		(struct atomisp_input_stream_info*)fmt->reserved;
+
+	if (!fmt)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	dev->cntx_config[stream_info->stream].width = fmt->width;
+	dev->cntx_config[stream_info->stream].height = fmt->height;
+	dev->cntx_config[stream_info->stream].mbus_fmt = fmt->code;
+	get_intg_factor(client, info);
+	stream_info->ch_id = stream_to_context[stream_info->stream];
+	mutex_unlock(&dev->input_lock);
+	dev_dbg(&client->dev, "%s w:%d h:%d code: 0x%x stream: %d\n", __func__,
+			fmt->width, fmt->height, fmt->code,
+			stream_info->stream);
+
+	return 0;
+}
+
+static int csi_xactor_s_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static long csi_xactor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case ATOMISP_IOC_S_EXPOSURE:
+		return 0;
+	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int
+csi_xactor_enum_mbus_code(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	if (code->index >= 1)
+		return -EINVAL;
+
+	mutex_lock(&dev->input_lock);
+	code->code = dev->format.code;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int
+csi_xactor_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_frame_size_enum *fse)
+{
+	int index = fse->index;
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	enum xactor_contexts context = xactor_get_context(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= 1) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fse->min_width = dev->cntx_config[context].width;
+	fse->min_height = dev->cntx_config[context].height;
+	fse->max_width = dev->cntx_config[context].width;
+	fse->max_height = dev->cntx_config[context].height;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__csi_xactor_get_pad_format(struct csi_xactor_device *sensor,
+			 struct v4l2_subdev_fh *fh, unsigned int pad,
+			 enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &sensor->format;
+	default:
+		return NULL;
+	}
+}
+
+static int
+csi_xactor_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		dev->format = fmt->format;
+
+	return 0;
+}
+
+static int
+csi_xactor_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	struct v4l2_mbus_framefmt *format =
+			__csi_xactor_get_pad_format(dev, fh, fmt->pad, fmt->which);
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int csi_xactor_enum_framesizes(struct v4l2_subdev *sd,
+				   struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	enum xactor_contexts context = xactor_get_context(sd);
+
+	mutex_lock(&dev->input_lock);
+	if (index >= 1) {
+		mutex_unlock(&dev->input_lock);
+		return -EINVAL;
+	}
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = dev->cntx_config[context].width;
+	fsize->discrete.height = dev->cntx_config[context].height;
+	fsize->reserved[0] = 1;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int csi_xactor_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	struct csi_xactor_device *dev = to_csi_xactor_dev(sd);
+	enum xactor_contexts context = xactor_get_context(sd);
+
+	mutex_lock(&dev->input_lock);
+	/* since the isp will donwscale the resolution to the right size,
+	  * find the nearest one that will allow the isp to do so
+	  * important to ensure that the resolution requested is padded
+	  * correctly by the requester, which is the atomisp driver in
+	  * this case.
+	  */
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->width = dev->cntx_config[context].width;
+	fival->height = dev->cntx_config[context].height;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = 15;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops xactor_core_ops = {
+	.queryctrl = v4l2_subdev_queryctrl,
+	.g_ctrl = v4l2_subdev_g_ctrl,
+	.s_ctrl = v4l2_subdev_s_ctrl,
+	.s_power = csi_xactor_s_power,
+	.ioctl = csi_xactor_ioctl,
+};
+
+static const struct v4l2_subdev_video_ops xactor_video_ops = {
+	.s_stream = csi_xactor_s_stream,
+	.enum_framesizes = csi_xactor_enum_framesizes,
+	.enum_frameintervals = csi_xactor_enum_frameintervals,
+	.enum_mbus_fmt = csi_xactor_enum_mbus_fmt,
+	.try_mbus_fmt = csi_xactor_try_mbus_fmt,
+	.g_mbus_fmt = csi_xactor_g_mbus_fmt,
+	.s_mbus_fmt = csi_xactor_s_mbus_fmt,
+	.g_frame_interval = csi_xactor_g_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops csi_xactor_pad_ops = {
+	.enum_mbus_code = csi_xactor_enum_mbus_code,
+	.enum_frame_size = csi_xactor_enum_frame_size,
+	.get_fmt = csi_xactor_get_pad_format,
+	.set_fmt = csi_xactor_set_pad_format,
+};
+
+static const struct v4l2_subdev_ops xactor_ops = {
+	.core = &xactor_core_ops,
+	.video = &xactor_video_ops,
+	.pad = &csi_xactor_pad_ops,
+};
+
+static int csi_xactor_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct csi_xactor_device *dev = container_of(
+		ctrl->handler, struct csi_xactor_device, ctrl_handler);
+
+	switch (ctrl->id) {
+	case V4L2_CID_RUN_MODE:
+		dev->cur_context = xactor_cntx_mapping[ctrl->val];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ctrl_ops = {
+	.s_ctrl = csi_xactor_s_ctrl,
+};
+
+static const char * const ctrl_run_mode_menu[] = {
+	NULL,
+	"Video",
+	"Still capture",
+	"Continuous capture",
+	"Preview",
+};
+
+static const struct v4l2_ctrl_config ctrl_run_mode = {
+	.ops = &ctrl_ops,
+	.id = V4L2_CID_RUN_MODE,
+	.name = "run mode",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 1,
+	.def = 4,
+	.max = 4,
+	.qmenu = ctrl_run_mode_menu,
+};
+
+static const struct media_entity_operations csi_xactor_entity_ops = {
+	.link_setup = NULL,
+};
+
+static int csi_xactor_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct csi_xactor_device *dev;
+	struct camera_mipi_info *csi;
+	char name[2] = {0};
+	int ret;
+
+
+	/* allocate sensor device & init sub device */
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	mutex_init(&dev->input_lock);
+
+	v4l2_i2c_subdev_init(&dev->sd, client, &xactor_ops);
+
+	if (client->dev.platform_data) {
+		ret = csi_xactor_s_config(&dev->sd, client->irq,
+				      client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	switch(mode) {
+	case MODE_PIXTER:
+		dev_info(&client->dev, "Driver in Pixter mode\n");
+		break;
+	case MODE_XACTOR:
+		dev_info(&client->dev, "Driver in SLE CSI xactor mode\n");
+		break;
+	default:
+		dev_err(&client->dev, "Mode %d is not supported setting to default mode.\n",
+				mode);
+		mode = MODE_DEFAULT;
+		break;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	dev->format.code = V4L2_MBUS_FMT_SBGGR10_1X10;
+
+	ret = v4l2_ctrl_handler_init(&dev->ctrl_handler, 1);
+	if (ret) {
+		csi_xactor_remove(client);
+		return ret;
+	}
+
+	dev->run_mode = v4l2_ctrl_new_custom(&dev->ctrl_handler,
+					     &ctrl_run_mode, NULL);
+	if (dev->ctrl_handler.error) {
+		csi_xactor_remove(client);
+		return dev->ctrl_handler.error;
+	}
+
+	/* Use same lock for controls as for everything else. */
+	dev->ctrl_handler.lock = &dev->input_lock;
+	dev->sd.ctrl_handler = &dev->ctrl_handler;
+	v4l2_ctrl_handler_setup(&dev->ctrl_handler);
+
+	/*
+	 * sd->name is updated with sensor driver name by the v4l2.
+	 * change it to sensor name in this case.
+	 */
+	csi = v4l2_get_subdev_hostdata(&dev->sd);
+
+	if (csi->port == ATOMISP_CAMERA_PORT_PRIMARY)
+	    name[0] = 'a';
+	else if(csi->port == ATOMISP_CAMERA_PORT_SECONDARY)
+	    name[0] = 'b';
+	else
+	    name[0] = 'c';
+
+	snprintf(dev->sd.name, sizeof(dev->sd.name), "%s%s %d-%04x",
+		"xactor", name,
+		i2c_adapter_id(client->adapter), client->addr);
+
+        dev_info(&client->dev, "%s dev->sd.name: %s\n", __func__, dev->sd.name);
+
+	dev->sd.entity.ops = &csi_xactor_entity_ops;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret) {
+		csi_xactor_remove(client);
+		return ret;
+	}
+
+	return 0;
+
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+static const struct i2c_device_id csi_xactor_ids[] = {
+	{CSI_XACTOR_A_NAME, 0},
+	{CSI_XACTOR_B_NAME, 0},
+	{CSI_XACTOR_C_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, csi_xactor_ids);
+
+static struct i2c_driver csi_xactor_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = CSI_XACTOR_NAME,
+	},
+	.probe = csi_xactor_probe,
+	.remove = csi_xactor_remove,
+	.id_table = csi_xactor_ids,
+};
+
+static __init int csi_xactor_init_mod(void)
+{
+	int r = i2c_add_driver(&csi_xactor_driver);
+
+	return r;
+}
+
+static __exit void csi_xactor_exit_mod(void)
+{
+	i2c_del_driver(&csi_xactor_driver);
+}
+
+module_init(csi_xactor_init_mod);
+module_exit(csi_xactor_exit_mod);
+
+MODULE_DESCRIPTION("A dummy sensor driver for csi data generators");
+MODULE_AUTHOR("Jukka Kaartinen <jukka.o.kaartinen@intel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.h b/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.h
new file mode 100644
index 0000000..3a3db46
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/xactor_x.h
@@ -0,0 +1,62 @@
+/*
+ * Support for mipi CSI_data generator.
+ *
+ * Copyright (c) 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __CSI_XACTOR_H__
+#define __CSI_XACTOR_H__
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#define	CSI_XACTOR_A_NAME	"xactor_a"
+#define	CSI_XACTOR_B_NAME	"xactor_b"
+#define	CSI_XACTOR_C_NAME	"xactor_c"
+#define	CSI_XACTOR_NAME		"xactor_x"
+
+enum xactor_contexts {
+	CONTEXT_SNAPSHOT = 0,
+	CONTEXT_PREVIEW,
+	CONTEXT_VIDEO,
+	CONTEXT_NUM
+};
+
+struct xactor_context_config {
+	unsigned int width;
+	unsigned int height;
+	unsigned int lines_per_frame;
+	unsigned int mbus_fmt;
+};
+
+/* csi_xactor device structure */
+struct csi_xactor_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+
+	struct camera_sensor_platform_data *platform_data;
+	struct xactor_context_config cntx_config[3];
+	struct mutex input_lock; /* serialize sensor's ioctl */
+	enum xactor_contexts cur_context;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *run_mode;
+};
+
+#endif
-- 
1.9.3

