From ae9ea5b1276baf1f105b23d949560c58b00d01bf Mon Sep 17 00:00:00 2001
From: Faouaz TENOUTIT <faouaz.tenoutit@intel.com>
Date: Fri, 4 Apr 2014 10:43:51 +0200
Subject: [PATCH] STPK-1372: [Asus T100] No sound can be heard while playing
 audio files

Port BYT-T sound card driver from:

http://git.kernel.org/cgit/linux/kernel/git/lrg/asoc.git/log/?h=intel/test

Issue: STPK-1372

Change-Id: If4ecea22bca71ba7dbb0aaacff514677c6222fdb
Signed-off-by: Faouaz TENOUTIT <faouaz.tenoutit@intel.com>
---
 arch/x86/configs/i386_bigcore_android_defconfig |    9 
 include/sound/pcm.h                             |    1 
 include/sound/simple_card.h                     |    6 
 include/sound/soc-dai.h                         |    2 
 include/sound/soc-dapm.h                        |    1 
 include/sound/soc.h                             |   64 +-
 include/trace/events/intel-sst.h                |  148 ++++
 sound/core/pcm_lib.c                            |    1 
 sound/core/pcm_native.c                         |    2 
 sound/soc/codecs/max98088.c                     |   41 -
 sound/soc/codecs/max98090.c                     |  375 +++++++++---
 sound/soc/codecs/max98090.h                     |    2 
 sound/soc/codecs/max98095.c                     |   56 +
 sound/soc/codecs/rt5640.c                       |   75 +-
 sound/soc/generic/simple-card.c                 |  232 ++++---
 sound/soc/intel/Kconfig                         |   31 -
 sound/soc/intel/Makefile                        |    6 
 sound/soc/intel/byt-max98090.c                  |  254 ++++++++
 sound/soc/intel/byt-rt5640.c                    |  127 +---
 sound/soc/intel/sst-acpi.c                      |  152 +++--
 sound/soc/intel/sst-baytrail-dsp.c              |  126 +---
 sound/soc/intel/sst-baytrail-ipc.c              |  253 +++++++-
 sound/soc/intel/sst-baytrail-ipc.h              |    9 
 sound/soc/intel/sst-baytrail-pcm.c              |  211 +++++--
 sound/soc/intel/sst-dsp-priv.h                  |   31 -
 sound/soc/intel/sst-dsp.c                       |  201 +++---
 sound/soc/intel/sst-dsp.h                       |   28 
 sound/soc/intel/sst-firmware.c                  |  340 ++---------
 sound/soc/intel/sst-haswell-dsp.c               |   65 --
 sound/soc/intel/sst-haswell-ipc.c               |  712 +++++++-----------------
 sound/soc/intel/sst-haswell-ipc.h               |  455 +++++----------
 sound/soc/intel/sst-haswell-pcm.c               |  527 +----------------
 sound/soc/soc-core.c                            |  234 +++++++
 sound/soc/soc-dapm.c                            |   58 +
 sound/soc/soc-jack.c                            |    5 
 35 files changed, 2545 insertions(+), 2295 deletions(-)
 create mode 100644 include/trace/events/intel-sst.h
 create mode 100644 sound/soc/intel/byt-max98090.c

Index: b/arch/x86/configs/i386_bigcore_android_defconfig
===================================================================
--- a/arch/x86/configs/i386_bigcore_android_defconfig	2016-06-02 12:28:43.401170186 +0800
+++ b/arch/x86/configs/i386_bigcore_android_defconfig	2016-06-02 12:28:43.385170228 +0800
@@ -3071,16 +3071,17 @@
 # CONFIG_SND_USB_US122L is not set
 # CONFIG_SND_USB_6FIRE is not set
 CONFIG_SND_USB_HIFACE=m
-CONFIG_SND_SOC=m
+CONFIG_SND_SOC=y
 CONFIG_SND_ATMEL_SOC=m
 CONFIG_SND_DESIGNWARE_I2S=m
-CONFIG_SND_SOC_INTEL_SST=m
+CONFIG_SND_SOC_INTEL_SST=y
 CONFIG_SND_SOC_INTEL_SST_ACPI=m
 CONFIG_SND_SOC_INTEL_HASWELL=m
-CONFIG_SND_SOC_INTEL_BAYTRAIL=m
+CONFIG_SND_SOC_INTEL_BAYTRAIL=y
 CONFIG_SND_SOC_INTEL_HASWELL_MACH=m
 CONFIG_SND_SOC_INTEL_BROADWELL_MACH=m
-CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH=m
+CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH=y
+CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH=y
 CONFIG_SND_SOC_I2C_AND_SPI=m
 CONFIG_SND_SOC_RT286=m
 CONFIG_SND_SOC_RT5640=m
Index: b/include/sound/pcm.h
===================================================================
--- a/include/sound/pcm.h	2016-06-02 12:28:43.401170186 +0800
+++ b/include/sound/pcm.h	2016-06-02 12:28:43.385170228 +0800
@@ -286,6 +286,7 @@
 	unsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
 	u64 hw_ptr_wrap;                /* offset for hw_ptr due to boundary wrap-around */
+	snd_pcm_state_t pending_state;
 
 	/* -- HW params -- */
 	snd_pcm_access_t access;	/* access mode */
Index: b/include/sound/simple_card.h
===================================================================
--- a/include/sound/simple_card.h	2016-06-02 12:28:43.401170186 +0800
+++ b/include/sound/simple_card.h	2016-06-02 12:28:43.385170228 +0800
@@ -18,6 +18,8 @@
 	const char *name;
 	unsigned int fmt;
 	unsigned int sysclk;
+	int slots;
+	int slot_width;
 };
 
 struct asoc_simple_card_info {
@@ -29,10 +31,6 @@
 	unsigned int daifmt;
 	struct asoc_simple_dai cpu_dai;
 	struct asoc_simple_dai codec_dai;
-
-	/* used in simple-card.c */
-	struct snd_soc_dai_link snd_link;
-	struct snd_soc_card snd_card;
 };
 
 #endif /* __SIMPLE_CARD_H */
Index: b/include/sound/soc-dai.h
===================================================================
--- a/include/sound/soc-dai.h	2016-06-02 12:28:43.401170186 +0800
+++ b/include/sound/soc-dai.h	2016-06-02 12:28:43.385170228 +0800
@@ -142,6 +142,8 @@
 	 * Called by soc_card drivers, normally in their hw_params.
 	 */
 	int (*set_fmt)(struct snd_soc_dai *dai, unsigned int fmt);
+	int (*of_xlate_tdm_slot_mask)(unsigned int slots,
+		unsigned int *tx_mask, unsigned int *rx_mask);
 	int (*set_tdm_slot)(struct snd_soc_dai *dai,
 		unsigned int tx_mask, unsigned int rx_mask,
 		int slots, int slot_width);
Index: b/include/sound/soc-dapm.h
===================================================================
--- a/include/sound/soc-dapm.h	2016-06-02 12:28:43.401170186 +0800
+++ b/include/sound/soc-dapm.h	2016-06-02 12:28:43.385170228 +0800
@@ -461,6 +461,7 @@
 int snd_soc_dapm_get_pin_status(struct snd_soc_dapm_context *dapm,
 				const char *pin);
 int snd_soc_dapm_sync(struct snd_soc_dapm_context *dapm);
+int snd_soc_dapm_sync_unlocked(struct snd_soc_dapm_context *dapm);
 int snd_soc_dapm_force_enable_pin(struct snd_soc_dapm_context *dapm,
 				  const char *pin);
 int snd_soc_dapm_force_enable_pin_unlocked(struct snd_soc_dapm_context *dapm,
Index: b/include/sound/soc.h
===================================================================
--- a/include/sound/soc.h	2016-06-02 12:28:43.401170186 +0800
+++ b/include/sound/soc.h	2016-06-02 12:28:43.385170228 +0800
@@ -45,6 +45,11 @@
 	((unsigned long)&(struct soc_mixer_control) \
 	{.reg = xlreg, .rreg = xrreg, .shift = xshift, .rshift = xshift, \
 	.max = xmax, .platform_max = xmax, .invert = xinvert})
+#define SOC_DOUBLE_R_S_VALUE(xlreg, xrreg, xshift, xmin, xmax, xsign_bit, xinvert) \
+	((unsigned long)&(struct soc_mixer_control) \
+	{.reg = xlreg, .rreg = xrreg, .shift = xshift, .rshift = xshift, \
+	.max = xmax, .min = xmin, .platform_max = xmax, .sign_bit = xsign_bit, \
+	.invert = xinvert})
 #define SOC_DOUBLE_R_RANGE_VALUE(xlreg, xrreg, xshift, xmin, xmax, xinvert) \
 	((unsigned long)&(struct soc_mixer_control) \
 	{.reg = xlreg, .rreg = xrreg, .shift = xshift, .rshift = xshift, \
@@ -152,6 +157,15 @@
 		{.reg = xreg, .rreg = xrreg, \
 		.shift = xshift, .rshift = xshift, \
 		.max = xmax, .min = xmin} }
+#define SOC_DOUBLE_R_S_TLV(xname, reg_left, reg_right, xshift, xmin, xmax, xsign_bit, xinvert, tlv_array) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
+		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.tlv.p = (tlv_array), \
+	.info = snd_soc_info_volsw, \
+	.get = snd_soc_get_volsw, .put = snd_soc_put_volsw, \
+	.private_value = SOC_DOUBLE_R_S_VALUE(reg_left, reg_right, xshift, \
+					    xmin, xmax, xsign_bit, xinvert) }
 #define SOC_DOUBLE_S8_TLV(xname, xreg, xmin, xmax, tlv_array) \
 {	.iface  = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
@@ -162,19 +176,19 @@
 	.private_value = (unsigned long)&(struct soc_mixer_control) \
 		{.reg = xreg, .min = xmin, .max = xmax, \
 		 .platform_max = xmax} }
-#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmax, xtexts) \
+#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xitems, xtexts) \
 {	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
-	.max = xmax, .texts = xtexts, \
-	.mask = xmax ? roundup_pow_of_two(xmax) - 1 : 0}
-#define SOC_ENUM_SINGLE(xreg, xshift, xmax, xtexts) \
-	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmax, xtexts)
-#define SOC_ENUM_SINGLE_EXT(xmax, xtexts) \
-{	.max = xmax, .texts = xtexts }
-#define SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xmax, xtexts, xvalues) \
+	.items = xitems, .texts = xtexts, \
+	.mask = xitems ? roundup_pow_of_two(xitems) - 1 : 0}
+#define SOC_ENUM_SINGLE(xreg, xshift, xitems, xtexts) \
+	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xitems, xtexts)
+#define SOC_ENUM_SINGLE_EXT(xitems, xtexts) \
+{	.items = xitems, .texts = xtexts }
+#define SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xitems, xtexts, xvalues) \
 {	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
-	.mask = xmask, .max = xmax, .texts = xtexts, .values = xvalues}
-#define SOC_VALUE_ENUM_SINGLE(xreg, xshift, xmask, xmax, xtexts, xvalues) \
-	SOC_VALUE_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xmax, xtexts, xvalues)
+	.mask = xmask, .items = xitems, .texts = xtexts, .values = xvalues}
+#define SOC_VALUE_ENUM_SINGLE(xreg, xshift, xmask, xnitmes, xtexts, xvalues) \
+	SOC_VALUE_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xnitmes, xtexts, xvalues)
 #define SOC_ENUM(xname, xenum) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
 	.info = snd_soc_info_enum_double, \
@@ -272,14 +286,14 @@
  * ARRAY_SIZE internally
  */
 #define SOC_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xtexts) \
-	struct soc_enum name = SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, \
+	const struct soc_enum name = SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, \
 						ARRAY_SIZE(xtexts), xtexts)
 #define SOC_ENUM_SINGLE_DECL(name, xreg, xshift, xtexts) \
 	SOC_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xtexts)
 #define SOC_ENUM_SINGLE_EXT_DECL(name, xtexts) \
-	struct soc_enum name = SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(xtexts), xtexts)
+	const struct soc_enum name = SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(xtexts), xtexts)
 #define SOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift_l, xshift_r, xmask, xtexts, xvalues) \
-	struct soc_enum name = SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, \
+	const struct soc_enum name = SOC_VALUE_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, \
 							ARRAY_SIZE(xtexts), xtexts, xvalues)
 #define SOC_VALUE_ENUM_SINGLE_DECL(name, xreg, xshift, xmask, xtexts, xvalues) \
 	SOC_VALUE_ENUM_DOUBLE_DECL(name, xreg, xshift, xshift, xmask, xtexts, xvalues)
@@ -600,7 +614,8 @@
 	struct snd_soc_jack *jack;
 	struct delayed_work work;
 
-	int (*jack_status_check)(void);
+	void *data;
+	int (*jack_status_check)(void *data);
 };
 
 struct snd_soc_jack {
@@ -1067,6 +1082,7 @@
 	int min, max, platform_max;
 	int reg, rreg;
 	unsigned int shift, rshift;
+	unsigned int sign_bit;
 	unsigned int invert:1;
 	unsigned int autodisable:1;
 };
@@ -1089,7 +1105,7 @@
 	unsigned short reg2;
 	unsigned char shift_l;
 	unsigned char shift_r;
-	unsigned int max;
+	unsigned int items;
 	unsigned int mask;
 	const char * const *texts;
 	const unsigned int *values;
@@ -1173,6 +1189,11 @@
 
 int snd_soc_of_parse_card_name(struct snd_soc_card *card,
 			       const char *propname);
+int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
+					  const char *propname);
+int snd_soc_of_parse_tdm_slot(struct device_node *np,
+			      unsigned int *slots,
+			      unsigned int *slot_width);
 int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname);
 unsigned int snd_soc_of_parse_daifmt(struct device_node *np,
@@ -1188,4 +1209,15 @@
 
 extern const struct dev_pm_ops snd_soc_pm_ops;
 
+/* Helper functions */
+static inline void snd_soc_dapm_mutex_lock(struct snd_soc_dapm_context *dapm)
+{
+	mutex_lock(&dapm->card->dapm_mutex);
+}
+
+static inline void snd_soc_dapm_mutex_unlock(struct snd_soc_dapm_context *dapm)
+{
+	mutex_unlock(&dapm->card->dapm_mutex);
+}
+
 #endif
Index: b/include/trace/events/intel-sst.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ b/include/trace/events/intel-sst.h	2016-06-02 12:28:43.389170218 +0800
@@ -0,0 +1,148 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM intel-sst
+
+#if !defined(_TRACE_INTEL_SST_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_INTEL_SST_H
+
+#include <linux/types.h>
+#include <linux/ktime.h>
+#include <linux/tracepoint.h>
+
+DECLARE_EVENT_CLASS(sst_ipc_msg,
+
+	TP_PROTO(unsigned int val),
+
+	TP_ARGS(val),
+
+	TP_STRUCT__entry(
+		__field(	unsigned int,	val		)
+	),
+
+	TP_fast_assign(
+		__entry->val = val;
+	),
+
+	TP_printk("0x%8.8x", (unsigned int)__entry->val)
+);
+
+DEFINE_EVENT(sst_ipc_msg, sst_ipc_msg_tx,
+
+	TP_PROTO(unsigned int val),
+
+	TP_ARGS(val)
+
+);
+
+DEFINE_EVENT(sst_ipc_msg, sst_ipc_msg_rx,
+
+	TP_PROTO(unsigned int val),
+
+	TP_ARGS(val)
+
+);
+
+DECLARE_EVENT_CLASS(sst_ipc_mailbox,
+
+	TP_PROTO(unsigned int offset, unsigned int val),
+
+	TP_ARGS(offset, val),
+
+	TP_STRUCT__entry(
+		__field(	unsigned int,	offset		)
+		__field(	unsigned int,	val		)
+	),
+
+	TP_fast_assign(
+		__entry->offset = offset;
+		__entry->val = val;
+	),
+
+	TP_printk(" 0x%4.4x = 0x%8.8x",
+		(unsigned int)__entry->offset, (unsigned int)__entry->val)
+);
+
+DEFINE_EVENT(sst_ipc_mailbox, sst_ipc_inbox_rdata,
+
+	TP_PROTO(unsigned int offset, unsigned int val),
+
+	TP_ARGS(offset, val)
+
+);
+
+DEFINE_EVENT(sst_ipc_mailbox, sst_ipc_inbox_wdata,
+
+	TP_PROTO(unsigned int offset, unsigned int val),
+
+	TP_ARGS(offset, val)
+
+);
+
+DEFINE_EVENT(sst_ipc_mailbox, sst_ipc_outbox_rdata,
+
+	TP_PROTO(unsigned int offset, unsigned int val),
+
+	TP_ARGS(offset, val)
+
+);
+
+DEFINE_EVENT(sst_ipc_mailbox, sst_ipc_outbox_wdata,
+
+	TP_PROTO(unsigned int offset, unsigned int val),
+
+	TP_ARGS(offset, val)
+
+);
+
+DECLARE_EVENT_CLASS(sst_ipc_mailbox_info,
+
+	TP_PROTO(unsigned int size),
+
+	TP_ARGS(size),
+
+	TP_STRUCT__entry(
+		__field(	unsigned int,	size		)
+	),
+
+	TP_fast_assign(
+		__entry->size = size;
+	),
+
+	TP_printk("Mailbox bytes 0x%8.8x", (unsigned int)__entry->size)
+);
+
+DEFINE_EVENT(sst_ipc_mailbox_info, sst_ipc_inbox_read,
+
+	TP_PROTO(unsigned int size),
+
+	TP_ARGS(size)
+
+);
+
+DEFINE_EVENT(sst_ipc_mailbox_info, sst_ipc_inbox_write,
+
+	TP_PROTO(unsigned int size),
+
+	TP_ARGS(size)
+
+);
+
+DEFINE_EVENT(sst_ipc_mailbox_info, sst_ipc_outbox_read,
+
+	TP_PROTO(unsigned int size),
+
+	TP_ARGS(size)
+
+);
+
+DEFINE_EVENT(sst_ipc_mailbox_info, sst_ipc_outbox_write,
+
+	TP_PROTO(unsigned int size),
+
+	TP_ARGS(size)
+
+);
+
+#endif /* _TRACE_SST_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
Index: b/sound/core/pcm_lib.c
===================================================================
--- a/sound/core/pcm_lib.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/core/pcm_lib.c	2016-06-02 12:28:43.389170218 +0800
@@ -1242,6 +1242,7 @@
 		return -EINVAL;
 	return 0;
 }
+EXPORT_SYMBOL(snd_pcm_hw_constraint_mask64);
 
 /**
  * snd_pcm_hw_constraint_integer - apply an integer constraint to an interval
Index: b/sound/core/pcm_native.c
===================================================================
--- a/sound/core/pcm_native.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/core/pcm_native.c	2016-06-02 12:28:43.389170218 +0800
@@ -855,6 +855,7 @@
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
 	    !snd_pcm_playback_data(substream))
 		return -EPIPE;
+	runtime->pending_state = state;
 	runtime->trigger_master = substream;
 	return 0;
 }
@@ -915,6 +916,7 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	if (runtime->status->state == SNDRV_PCM_STATE_OPEN)
 		return -EBADFD;
+	runtime->pending_state = state;
 	runtime->trigger_master = substream;
 	return 0;
 }
Index: b/sound/soc/codecs/max98088.c
===================================================================
--- a/sound/soc/codecs/max98088.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/codecs/max98088.c	2016-06-02 12:28:43.389170218 +0800
@@ -597,28 +597,27 @@
        0x00, 0x43, 0x10, 0x20, 0x30, 0x40, 0x11, 0x22, 0x32
 };
 
-static const struct soc_enum max98088_exmode_enum =
-       SOC_VALUE_ENUM_SINGLE(M98088_REG_41_SPKDHP, 0, 127,
-                             ARRAY_SIZE(max98088_exmode_texts),
-                             max98088_exmode_texts,
-                             max98088_exmode_values);
+static SOC_VALUE_ENUM_SINGLE_DECL(max98088_exmode_enum,
+				  M98088_REG_41_SPKDHP, 0, 127,
+				  max98088_exmode_texts,
+				  max98088_exmode_values);
 
 static const char *max98088_ex_thresh[] = { /* volts PP */
        "0.6", "1.2", "1.8", "2.4", "3.0", "3.6", "4.2", "4.8"};
-static const struct soc_enum max98088_ex_thresh_enum[] = {
-       SOC_ENUM_SINGLE(M98088_REG_42_SPKDHP_THRESH, 0, 8,
-               max98088_ex_thresh),
-};
+static SOC_ENUM_SINGLE_DECL(max98088_ex_thresh_enum,
+			    M98088_REG_42_SPKDHP_THRESH, 0,
+			    max98088_ex_thresh);
 
 static const char *max98088_fltr_mode[] = {"Voice", "Music" };
-static const struct soc_enum max98088_filter_mode_enum[] = {
-       SOC_ENUM_SINGLE(M98088_REG_18_DAI1_FILTERS, 7, 2, max98088_fltr_mode),
-};
+static SOC_ENUM_SINGLE_DECL(max98088_filter_mode_enum,
+			    M98088_REG_18_DAI1_FILTERS, 7,
+			    max98088_fltr_mode);
 
 static const char *max98088_extmic_text[] = { "None", "MIC1", "MIC2" };
 
-static const struct soc_enum max98088_extmic_enum =
-       SOC_ENUM_SINGLE(M98088_REG_48_CFG_MIC, 0, 3, max98088_extmic_text);
+static SOC_ENUM_SINGLE_DECL(max98088_extmic_enum,
+			    M98088_REG_48_CFG_MIC, 0,
+			    max98088_extmic_text);
 
 static const struct snd_kcontrol_new max98088_extmic_mux =
        SOC_DAPM_ENUM("External MIC Mux", max98088_extmic_enum);
@@ -626,12 +625,12 @@
 static const char *max98088_dai1_fltr[] = {
        "Off", "fc=258/fs=16k", "fc=500/fs=16k",
        "fc=258/fs=8k", "fc=500/fs=8k", "fc=200"};
-static const struct soc_enum max98088_dai1_dac_filter_enum[] = {
-       SOC_ENUM_SINGLE(M98088_REG_18_DAI1_FILTERS, 0, 6, max98088_dai1_fltr),
-};
-static const struct soc_enum max98088_dai1_adc_filter_enum[] = {
-       SOC_ENUM_SINGLE(M98088_REG_18_DAI1_FILTERS, 4, 6, max98088_dai1_fltr),
-};
+static SOC_ENUM_SINGLE_DECL(max98088_dai1_dac_filter_enum,
+			    M98088_REG_18_DAI1_FILTERS, 0,
+			    max98088_dai1_fltr);
+static SOC_ENUM_SINGLE_DECL(max98088_dai1_adc_filter_enum,
+			    M98088_REG_18_DAI1_FILTERS, 4,
+			    max98088_dai1_fltr);
 
 static int max98088_mic1pre_set(struct snd_kcontrol *kcontrol,
                                struct snd_ctl_elem_value *ucontrol)
@@ -1849,7 +1848,7 @@
 
        /* Now point the soc_enum to .texts array items */
        max98088->eq_enum.texts = max98088->eq_texts;
-       max98088->eq_enum.max = max98088->eq_textcnt;
+       max98088->eq_enum.items = max98088->eq_textcnt;
 
        ret = snd_soc_add_codec_controls(codec, controls, ARRAY_SIZE(controls));
        if (ret != 0)
Index: b/sound/soc/codecs/max98090.c
===================================================================
--- a/sound/soc/codecs/max98090.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/codecs/max98090.c	2016-06-02 12:28:43.393170207 +0800
@@ -15,6 +15,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
+#include <linux/acpi.h>
 #include <sound/jack.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -390,6 +391,7 @@
 static const DECLARE_TLV_DB_SCALE(max98090_alcmakeup_tlv, 0, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_alccomp_tlv, -3100, 100, 0);
 static const DECLARE_TLV_DB_SCALE(max98090_drcexp_tlv, -6600, 100, 0);
+static const DECLARE_TLV_DB_SCALE(max98090_sdg_tlv, 50, 200, 0);
 
 static const unsigned int max98090_mixout_tlv[] = {
 	TLV_DB_RANGE_HEAD(2),
@@ -509,72 +511,107 @@
 	return 0;
 }
 
+static int test2 = 0;
+
+static int max98090_get_test2(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = test2;
+	return 0;
+}
+
+static int max98090_put_test2(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	test2 = ucontrol->value.integer.value[0];
+	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+		M98090_SHDNN_MASK, test2 << M98090_SHDNN_SHIFT);
+
+	return 0;
+}
+
 static const char *max98090_perf_pwr_text[] =
 	{ "High Performance", "Low Power" };
 static const char *max98090_pwr_perf_text[] =
 	{ "Low Power", "High Performance" };
 
-static const struct soc_enum max98090_vcmbandgap_enum =
-	SOC_ENUM_SINGLE(M98090_REG_BIAS_CONTROL, M98090_VCM_MODE_SHIFT,
-		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+static SOC_ENUM_SINGLE_DECL(max98090_vcmbandgap_enum,
+			    M98090_REG_BIAS_CONTROL,
+			    M98090_VCM_MODE_SHIFT,
+			    max98090_pwr_perf_text);
 
 static const char *max98090_osr128_text[] = { "64*fs", "128*fs" };
 
-static const struct soc_enum max98090_osr128_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_CONTROL, M98090_OSR128_SHIFT,
-		ARRAY_SIZE(max98090_osr128_text), max98090_osr128_text);
+static SOC_ENUM_SINGLE_DECL(max98090_osr128_enum,
+			    M98090_REG_ADC_CONTROL,
+			    M98090_OSR128_SHIFT,
+			    max98090_osr128_text);
 
 static const char *max98090_mode_text[] = { "Voice", "Music" };
 
-static const struct soc_enum max98090_mode_enum =
-	SOC_ENUM_SINGLE(M98090_REG_FILTER_CONFIG, M98090_MODE_SHIFT,
-		ARRAY_SIZE(max98090_mode_text), max98090_mode_text);
-
-static const struct soc_enum max98090_filter_dmic34mode_enum =
-	SOC_ENUM_SINGLE(M98090_REG_FILTER_CONFIG,
-		M98090_FLT_DMIC34MODE_SHIFT,
-		ARRAY_SIZE(max98090_mode_text), max98090_mode_text);
+static SOC_ENUM_SINGLE_DECL(max98090_mode_enum,
+			    M98090_REG_FILTER_CONFIG,
+			    M98090_MODE_SHIFT,
+			    max98090_mode_text);
+
+static SOC_ENUM_SINGLE_DECL(max98090_filter_dmic34mode_enum,
+			    M98090_REG_FILTER_CONFIG,
+			    M98090_FLT_DMIC34MODE_SHIFT,
+			    max98090_mode_text);
 
 static const char *max98090_drcatk_text[] =
 	{ "0.5ms", "1ms", "5ms", "10ms", "25ms", "50ms", "100ms", "200ms" };
 
-static const struct soc_enum max98090_drcatk_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCATK_SHIFT,
-		ARRAY_SIZE(max98090_drcatk_text), max98090_drcatk_text);
+static SOC_ENUM_SINGLE_DECL(max98090_drcatk_enum,
+			    M98090_REG_DRC_TIMING,
+			    M98090_DRCATK_SHIFT,
+			    max98090_drcatk_text);
 
 static const char *max98090_drcrls_text[] =
 	{ "8s", "4s", "2s", "1s", "0.5s", "0.25s", "0.125s", "0.0625s" };
 
-static const struct soc_enum max98090_drcrls_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_TIMING, M98090_DRCRLS_SHIFT,
-		ARRAY_SIZE(max98090_drcrls_text), max98090_drcrls_text);
+static SOC_ENUM_SINGLE_DECL(max98090_drcrls_enum,
+			    M98090_REG_DRC_TIMING,
+			    M98090_DRCRLS_SHIFT,
+			    max98090_drcrls_text);
 
 static const char *max98090_alccmp_text[] =
 	{ "1:1", "1:1.5", "1:2", "1:4", "1:INF" };
 
-static const struct soc_enum max98090_alccmp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_COMPRESSOR, M98090_DRCCMP_SHIFT,
-		ARRAY_SIZE(max98090_alccmp_text), max98090_alccmp_text);
+static SOC_ENUM_SINGLE_DECL(max98090_alccmp_enum,
+			    M98090_REG_DRC_COMPRESSOR,
+			    M98090_DRCCMP_SHIFT,
+			    max98090_alccmp_text);
 
 static const char *max98090_drcexp_text[] = { "1:1", "2:1", "3:1" };
 
-static const struct soc_enum max98090_drcexp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DRC_EXPANDER, M98090_DRCEXP_SHIFT,
-		ARRAY_SIZE(max98090_drcexp_text), max98090_drcexp_text);
-
-static const struct soc_enum max98090_dac_perfmode_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DAC_CONTROL, M98090_PERFMODE_SHIFT,
-		ARRAY_SIZE(max98090_perf_pwr_text), max98090_perf_pwr_text);
-
-static const struct soc_enum max98090_dachp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_DAC_CONTROL, M98090_DACHP_SHIFT,
-		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
-
-static const struct soc_enum max98090_adchp_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_CONTROL, M98090_ADCHP_SHIFT,
-		ARRAY_SIZE(max98090_pwr_perf_text), max98090_pwr_perf_text);
+static SOC_ENUM_SINGLE_DECL(max98090_drcexp_enum,
+			    M98090_REG_DRC_EXPANDER,
+			    M98090_DRCEXP_SHIFT,
+			    max98090_drcexp_text);
+
+static SOC_ENUM_SINGLE_DECL(max98090_dac_perfmode_enum,
+			    M98090_REG_DAC_CONTROL,
+			    M98090_PERFMODE_SHIFT,
+			    max98090_perf_pwr_text);
+
+static SOC_ENUM_SINGLE_DECL(max98090_dachp_enum,
+			    M98090_REG_DAC_CONTROL,
+			    M98090_DACHP_SHIFT,
+			    max98090_pwr_perf_text);
+
+static SOC_ENUM_SINGLE_DECL(max98090_adchp_enum,
+			    M98090_REG_ADC_CONTROL,
+			    M98090_ADCHP_SHIFT,
+			    max98090_pwr_perf_text);
 
 static const struct snd_kcontrol_new max98090_snd_controls[] = {
+
+	SOC_SINGLE_EXT("AB Test2", 0, 0, 1, 0,
+		max98090_get_test2, max98090_put_test2),
+
 	SOC_ENUM("MIC Bias VCM Bandgap", max98090_vcmbandgap_enum),
 
 	SOC_SINGLE("DMIC MIC Comp Filter Config", M98090_REG_DIGITAL_MIC_CONFIG,
@@ -656,7 +693,7 @@
 	SOC_SINGLE_EXT_TLV("Digital Sidetone Volume",
 		M98090_REG_ADC_SIDETONE, M98090_DVST_SHIFT,
 		M98090_DVST_NUM - 1, 1, max98090_get_enab_tlv,
-		max98090_put_enab_tlv, max98090_micboost_tlv),
+		max98090_put_enab_tlv, max98090_sdg_tlv),
 	SOC_SINGLE_TLV("Digital Coarse Volume", M98090_REG_DAI_PLAYBACK_LEVEL,
 		M98090_DVG_SHIFT, M98090_DVG_NUM - 1, 0,
 		max98090_dvg_tlv),
@@ -843,39 +880,42 @@
 
 static const char *mic1_mux_text[] = { "IN12", "IN56" };
 
-static const struct soc_enum mic1_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_INPUT_MODE, M98090_EXTMIC1_SHIFT,
-		ARRAY_SIZE(mic1_mux_text), mic1_mux_text);
+static SOC_ENUM_SINGLE_DECL(mic1_mux_enum,
+			    M98090_REG_INPUT_MODE,
+			    M98090_EXTMIC1_SHIFT,
+			    mic1_mux_text);
 
 static const struct snd_kcontrol_new max98090_mic1_mux =
 	SOC_DAPM_ENUM("MIC1 Mux", mic1_mux_enum);
 
 static const char *mic2_mux_text[] = { "IN34", "IN56" };
 
-static const struct soc_enum mic2_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_INPUT_MODE, M98090_EXTMIC2_SHIFT,
-		ARRAY_SIZE(mic2_mux_text), mic2_mux_text);
+static SOC_ENUM_SINGLE_DECL(mic2_mux_enum,
+			    M98090_REG_INPUT_MODE,
+			    M98090_EXTMIC2_SHIFT,
+			    mic2_mux_text);
 
 static const struct snd_kcontrol_new max98090_mic2_mux =
 	SOC_DAPM_ENUM("MIC2 Mux", mic2_mux_enum);
 
 static const char *dmic_mux_text[] = { "ADC", "DMIC" };
 
-static const struct soc_enum dmic_mux_enum =
-	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(dmic_mux_text), dmic_mux_text);
+static SOC_ENUM_SINGLE_EXT_DECL(dmic_mux_enum, dmic_mux_text);
 
 static const struct snd_kcontrol_new max98090_dmic_mux =
 	SOC_DAPM_ENUM_VIRT("DMIC Mux", dmic_mux_enum);
 
 static const char *max98090_micpre_text[] = { "Off", "On" };
 
-static const struct soc_enum max98090_pa1en_enum =
-	SOC_ENUM_SINGLE(M98090_REG_MIC1_INPUT_LEVEL, M98090_MIC_PA1EN_SHIFT,
-		ARRAY_SIZE(max98090_micpre_text), max98090_micpre_text);
-
-static const struct soc_enum max98090_pa2en_enum =
-	SOC_ENUM_SINGLE(M98090_REG_MIC2_INPUT_LEVEL, M98090_MIC_PA2EN_SHIFT,
-		ARRAY_SIZE(max98090_micpre_text), max98090_micpre_text);
+static SOC_ENUM_SINGLE_DECL(max98090_pa1en_enum,
+			    M98090_REG_MIC1_INPUT_LEVEL,
+			    M98090_MIC_PA1EN_SHIFT,
+			    max98090_micpre_text);
+
+static SOC_ENUM_SINGLE_DECL(max98090_pa2en_enum,
+			    M98090_REG_MIC2_INPUT_LEVEL,
+			    M98090_MIC_PA2EN_SHIFT,
+			    max98090_micpre_text);
 
 /* LINEA mixer switch */
 static const struct snd_kcontrol_new max98090_linea_mixer_controls[] = {
@@ -939,13 +979,15 @@
 
 static const char *lten_mux_text[] = { "Normal", "Loopthrough" };
 
-static const struct soc_enum ltenl_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LTEN_SHIFT,
-		ARRAY_SIZE(lten_mux_text), lten_mux_text);
-
-static const struct soc_enum ltenr_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LTEN_SHIFT,
-		ARRAY_SIZE(lten_mux_text), lten_mux_text);
+static SOC_ENUM_SINGLE_DECL(ltenl_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LTEN_SHIFT,
+			    lten_mux_text);
+
+static SOC_ENUM_SINGLE_DECL(ltenr_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LTEN_SHIFT,
+			    lten_mux_text);
 
 static const struct snd_kcontrol_new max98090_ltenl_mux =
 	SOC_DAPM_ENUM("LTENL Mux", ltenl_mux_enum);
@@ -955,13 +997,15 @@
 
 static const char *lben_mux_text[] = { "Normal", "Loopback" };
 
-static const struct soc_enum lbenl_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LBEN_SHIFT,
-		ARRAY_SIZE(lben_mux_text), lben_mux_text);
-
-static const struct soc_enum lbenr_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_IO_CONFIGURATION, M98090_LBEN_SHIFT,
-		ARRAY_SIZE(lben_mux_text), lben_mux_text);
+static SOC_ENUM_SINGLE_DECL(lbenl_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LBEN_SHIFT,
+			    lben_mux_text);
+
+static SOC_ENUM_SINGLE_DECL(lbenr_mux_enum,
+			    M98090_REG_IO_CONFIGURATION,
+			    M98090_LBEN_SHIFT,
+			    lben_mux_text);
 
 static const struct snd_kcontrol_new max98090_lbenl_mux =
 	SOC_DAPM_ENUM("LBENL Mux", lbenl_mux_enum);
@@ -973,13 +1017,15 @@
 
 static const char *stenr_mux_text[] = { "Normal", "Sidetone Right" };
 
-static const struct soc_enum stenl_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_SIDETONE, M98090_DSTSL_SHIFT,
-		ARRAY_SIZE(stenl_mux_text), stenl_mux_text);
-
-static const struct soc_enum stenr_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_ADC_SIDETONE, M98090_DSTSR_SHIFT,
-		ARRAY_SIZE(stenr_mux_text), stenr_mux_text);
+static SOC_ENUM_SINGLE_DECL(stenl_mux_enum,
+			    M98090_REG_ADC_SIDETONE,
+			    M98090_DSTSL_SHIFT,
+			    stenl_mux_text);
+
+static SOC_ENUM_SINGLE_DECL(stenr_mux_enum,
+			    M98090_REG_ADC_SIDETONE,
+			    M98090_DSTSR_SHIFT,
+			    stenr_mux_text);
 
 static const struct snd_kcontrol_new max98090_stenl_mux =
 	SOC_DAPM_ENUM("STENL Mux", stenl_mux_enum);
@@ -1087,9 +1133,10 @@
 
 static const char *linmod_mux_text[] = { "Left Only", "Left and Right" };
 
-static const struct soc_enum linmod_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_LOUTR_MIXER, M98090_LINMOD_SHIFT,
-		ARRAY_SIZE(linmod_mux_text), linmod_mux_text);
+static SOC_ENUM_SINGLE_DECL(linmod_mux_enum,
+			    M98090_REG_LOUTR_MIXER,
+			    M98090_LINMOD_SHIFT,
+			    linmod_mux_text);
 
 static const struct snd_kcontrol_new max98090_linmod_mux =
 	SOC_DAPM_ENUM("LINMOD Mux", linmod_mux_enum);
@@ -1099,16 +1146,18 @@
 /*
  * This is a mux as it selects the HP output, but to DAPM it is a Mixer enable
  */
-static const struct soc_enum mixhplsel_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_HP_CONTROL, M98090_MIXHPLSEL_SHIFT,
-		ARRAY_SIZE(mixhpsel_mux_text), mixhpsel_mux_text);
+static SOC_ENUM_SINGLE_DECL(mixhplsel_mux_enum,
+			    M98090_REG_HP_CONTROL,
+			    M98090_MIXHPLSEL_SHIFT,
+			    mixhpsel_mux_text);
 
 static const struct snd_kcontrol_new max98090_mixhplsel_mux =
 	SOC_DAPM_ENUM("MIXHPLSEL Mux", mixhplsel_mux_enum);
 
-static const struct soc_enum mixhprsel_mux_enum =
-	SOC_ENUM_SINGLE(M98090_REG_HP_CONTROL, M98090_MIXHPRSEL_SHIFT,
-		ARRAY_SIZE(mixhpsel_mux_text), mixhpsel_mux_text);
+static SOC_ENUM_SINGLE_DECL(mixhprsel_mux_enum,
+			    M98090_REG_HP_CONTROL,
+			    M98090_MIXHPRSEL_SHIFT,
+			    mixhpsel_mux_text);
 
 static const struct snd_kcontrol_new max98090_mixhprsel_mux =
 	SOC_DAPM_ENUM("MIXHPRSEL Mux", mixhprsel_mux_enum);
@@ -1131,8 +1180,8 @@
 
 	SND_SOC_DAPM_SUPPLY("MICBIAS", M98090_REG_INPUT_ENABLE,
 		M98090_MBEN_SHIFT, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("SHDN", M98090_REG_DEVICE_SHUTDOWN,
-		M98090_SHDNN_SHIFT, 0, NULL, 0),
+	//SND_SOC_DAPM_SUPPLY("SHDN", M98090_REG_DEVICE_SHUTDOWN,
+	//	M98090_SHDNN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SDIEN", M98090_REG_IO_CONFIGURATION,
 		M98090_SDIEN_SHIFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("SDOEN", M98090_REG_IO_CONFIGURATION,
@@ -1652,6 +1701,7 @@
 				M98090_REG_CLOCK_RATIO_NI_LSB, 0x00);
 			snd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,
 				M98090_USE_M1_MASK, 0);
+			max98090->master = false;
 			break;
 		case SND_SOC_DAIFMT_CBM_CFM:
 			/* Set to master mode */
@@ -1668,6 +1718,7 @@
 				regval |= M98090_MAS_MASK |
 					M98090_BSEL_32;
 			}
+			max98090->master = true;
 			break;
 		case SND_SOC_DAIFMT_CBS_CFM:
 		case SND_SOC_DAIFMT_CBM_CFS:
@@ -1767,7 +1818,8 @@
 				   enum snd_soc_bias_level level)
 {
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
-	int ret;
+	int ret, i;
+	unsigned int pll;
 
 	switch (level) {
 	case SND_SOC_BIAS_ON:
@@ -1781,6 +1833,29 @@
 		break;
 
 	case SND_SOC_BIAS_PREPARE:
+		if (codec->dapm.bias_level != SND_SOC_BIAS_ON) {
+			for (i = 0; i < 10; i ++) {
+
+				/* unmask the PLL interrupt */
+				snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+					M98090_IULK_MASK, 0);
+
+				/* toggle shutdown OFF then ON */
+				snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+					M98090_SHDNN_MASK, 0);
+				snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+					M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+				ret = regmap_read(max98090->regmap,
+					M98090_REG_DEVICE_STATUS, &pll);
+				if (!(pll & M98090_ULK_MASK))
+					break;
+			}
+			/* unmask the PLL interrupt */
+			snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+				M98090_IULK_MASK, 1 << M98090_IULK_SHIFT);
+
+			dev_err(codec->dev, "PLL after bias active fix %d is  0x%x\n", i, pll);
+		}
 		break;
 
 	case SND_SOC_BIAS_STANDBY:
@@ -1791,6 +1866,9 @@
 					"Failed to sync cache: %d\n", ret);
 				return ret;
 			}
+		} else {
+			snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, 0);
 		}
 		break;
 
@@ -1851,7 +1929,8 @@
 		return -EINVAL;
 	}
 
-	max98090_configure_bclk(codec);
+	if (max98090->master)
+		max98090_configure_bclk(codec);
 
 	cdata->rate = max98090->lrclk;
 
@@ -1930,8 +2009,6 @@
 
 	max98090->sysclk = freq;
 
-	max98090_configure_bclk(codec);
-
 	return 0;
 }
 
@@ -2036,13 +2113,38 @@
 	snd_soc_dapm_sync(dapm);
 }
 
+
+static void max98090_pll_work(struct work_struct *work)
+{
+	struct max98090_priv *max98090 = container_of(work,
+		struct max98090_priv,
+		pll_work);
+	struct snd_soc_codec *codec = max98090->codec;
+
+	dev_err(codec->dev, "PLL unlocked\n");
+
+	if (!codec->active)
+		return;
+
+	/* toggle shutdown OFF then ON */
+	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+		M98090_SHDNN_MASK, 0);
+
+	msleep(2);
+	snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+		M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+
+	/* give PLL time to lock */
+	msleep(2);
+}
+
 static irqreturn_t max98090_interrupt(int irq, void *data)
 {
 	struct snd_soc_codec *codec = data;
 	struct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);
-	int ret;
+	int ret, i;
 	unsigned int mask;
-	unsigned int active;
+	unsigned int active, pll;
 
 	dev_dbg(codec->dev, "***** max98090_interrupt *****\n");
 
@@ -2078,9 +2180,35 @@
 	if (active & M98090_SLD_MASK)
 		dev_dbg(codec->dev, "M98090_SLD_MASK\n");
 
-	if (active & M98090_ULK_MASK)
-		dev_err(codec->dev, "M98090_ULK_MASK\n");
+	if (active & M98090_ULK_MASK) {
+		/* try and recover immediately to minimise audio artifacts
+		  may have to move this to workq when issue resolved */
+		if (!codec->active)
+			goto jack;
+
+		for (i = 0; i < 10; i ++) {
+
+			/* mask the PLL interrupt */
+			snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+				M98090_IULK_MASK, 0);
+
+			/* toggle shutdown OFF then ON */
+			snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, 0);
+			snd_soc_update_bits(codec, M98090_REG_DEVICE_SHUTDOWN,
+				M98090_SHDNN_MASK, M98090_SHDNN_MASK);
+			ret = regmap_read(max98090->regmap,
+				M98090_REG_DEVICE_STATUS, &pll);
+			if (!(pll & M98090_ULK_MASK))
+				break;
+		}
+		/* unmask the PLL interrupt */
+		snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+			M98090_IULK_MASK, 1 << M98090_IULK_SHIFT);
+		dev_err(codec->dev, "PLL after IRQ active fix %d is  0x%x\n", i, pll);
+	}
 
+jack:
 	if (active & M98090_JDET_MASK) {
 		dev_dbg(codec->dev, "M98090_JDET_MASK\n");
 
@@ -2211,6 +2339,7 @@
 	/* Initialize private data */
 
 	max98090->sysclk = (unsigned)-1;
+	max98090->master = false;
 
 	cdata = &max98090->dai[0];
 	cdata->rate = (unsigned)-1;
@@ -2280,6 +2409,9 @@
 	snd_soc_write(codec, M98090_REG_BIAS_CONTROL,
 		M98090_VCM_MODE_MASK);
 
+	snd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,
+		M98090_MBVSEL_MASK, M98090_MBVSEL_2V8);
+
 	max98090_handle_pdata(codec);
 
 	max98090_add_widgets(codec);
@@ -2316,9 +2448,11 @@
 };
 
 static int max98090_i2c_probe(struct i2c_client *i2c,
-				 const struct i2c_device_id *id)
+				 const struct i2c_device_id *i2c_id)
 {
 	struct max98090_priv *max98090;
+	const struct acpi_device_id *acpi_id;
+	kernel_ulong_t driver_data = 0;
 	int ret;
 
 	pr_debug("max98090_i2c_probe\n");
@@ -2328,7 +2462,19 @@
 	if (max98090 == NULL)
 		return -ENOMEM;
 
-	max98090->devtype = id->driver_data;
+	if (ACPI_HANDLE(&i2c->dev)) {
+		acpi_id = acpi_match_device(i2c->dev.driver->acpi_match_table,
+					    &i2c->dev);
+		if (!acpi_id) {
+			dev_err(&i2c->dev, "No driver data\n");
+			return -EINVAL;
+		}
+		driver_data = acpi_id->driver_data;
+	} else if (i2c_id) {
+		driver_data = i2c_id->driver_data;
+	}
+
+	max98090->devtype = driver_data;
 	i2c_set_clientdata(i2c, max98090);
 	max98090->control_data = i2c;
 	max98090->pdata = i2c->dev.platform_data;
@@ -2378,9 +2524,37 @@
 }
 #endif
 
+#ifdef CONFIG_PM
+static int max98090_resume(struct device *dev)
+{
+	struct max98090_priv *max98090 = dev_get_drvdata(dev);
+	unsigned int status;
+
+	/* TODO: Is this wait really needed */
+	msleep(870);
+
+	regcache_mark_dirty(max98090->regmap);
+
+	max98090_reset(max98090);
+
+	/* clear IRQ status */
+	regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &status);
+
+	regcache_sync(max98090->regmap);
+
+	return 0;
+}
+
+static int max98090_suspend(struct device *dev)
+{
+	return 0;
+}
+#endif
+
 static const struct dev_pm_ops max98090_pm = {
 	SET_RUNTIME_PM_OPS(max98090_runtime_suspend,
 		max98090_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(max98090_suspend, max98090_resume)
 };
 
 static const struct i2c_device_id max98090_i2c_id[] = {
@@ -2389,11 +2563,20 @@
 };
 MODULE_DEVICE_TABLE(i2c, max98090_i2c_id);
 
+#ifdef CONFIG_ACPI
+static struct acpi_device_id max98090_acpi_match[] = {
+	{ "193C9890", MAX98090 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, max98090_acpi_match);
+#endif
+
 static struct i2c_driver max98090_i2c_driver = {
 	.driver = {
 		.name = "max98090",
 		.owner = THIS_MODULE,
 		.pm = &max98090_pm,
+		.acpi_match_table = ACPI_PTR(max98090_acpi_match),
 	},
 	.probe  = max98090_i2c_probe,
 	.remove = max98090_i2c_remove,
Index: b/sound/soc/codecs/max98090.h
===================================================================
--- a/sound/soc/codecs/max98090.h	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/codecs/max98090.h	2016-06-02 12:28:43.393170207 +0800
@@ -1532,6 +1532,7 @@
 	int irq;
 	int jack_state;
 	struct delayed_work jack_work;
+	struct work_struct pll_work;
 	struct snd_soc_jack *jack;
 	unsigned int dai_fmt;
 	int tdm_slots;
@@ -1541,6 +1542,7 @@
 	unsigned int pa2en;
 	unsigned int extmic_mux;
 	unsigned int sidetone;
+	bool master;
 };
 
 int max98090_mic_detect(struct snd_soc_codec *codec,
Index: b/sound/soc/codecs/max98095.c
===================================================================
--- a/sound/soc/codecs/max98095.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/codecs/max98095.c	2016-06-02 12:28:43.393170207 +0800
@@ -560,25 +560,27 @@
 }
 
 static const char * const max98095_fltr_mode[] = { "Voice", "Music" };
-static const struct soc_enum max98095_dai1_filter_mode_enum[] = {
-	SOC_ENUM_SINGLE(M98095_02E_DAI1_FILTERS, 7, 2, max98095_fltr_mode),
-};
-static const struct soc_enum max98095_dai2_filter_mode_enum[] = {
-	SOC_ENUM_SINGLE(M98095_038_DAI2_FILTERS, 7, 2, max98095_fltr_mode),
-};
+static SOC_ENUM_SINGLE_DECL(max98095_dai1_filter_mode_enum,
+			    M98095_02E_DAI1_FILTERS, 7,
+			    max98095_fltr_mode);
+static SOC_ENUM_SINGLE_DECL(max98095_dai2_filter_mode_enum,
+			    M98095_038_DAI2_FILTERS, 7,
+			    max98095_fltr_mode);
 
 static const char * const max98095_extmic_text[] = { "None", "MIC1", "MIC2" };
 
-static const struct soc_enum max98095_extmic_enum =
-	SOC_ENUM_SINGLE(M98095_087_CFG_MIC, 0, 3, max98095_extmic_text);
+static SOC_ENUM_SINGLE_DECL(max98095_extmic_enum,
+			    M98095_087_CFG_MIC, 0,
+			    max98095_extmic_text);
 
 static const struct snd_kcontrol_new max98095_extmic_mux =
 	SOC_DAPM_ENUM("External MIC Mux", max98095_extmic_enum);
 
 static const char * const max98095_linein_text[] = { "INA", "INB" };
 
-static const struct soc_enum max98095_linein_enum =
-	SOC_ENUM_SINGLE(M98095_086_CFG_LINE, 6, 2, max98095_linein_text);
+static SOC_ENUM_SINGLE_DECL(max98095_linein_enum,
+			    M98095_086_CFG_LINE, 6,
+			    max98095_linein_text);
 
 static const struct snd_kcontrol_new max98095_linein_mux =
 	SOC_DAPM_ENUM("Linein Input Mux", max98095_linein_enum);
@@ -586,24 +588,26 @@
 static const char * const max98095_line_mode_text[] = {
 	"Stereo", "Differential"};
 
-static const struct soc_enum max98095_linein_mode_enum =
-	SOC_ENUM_SINGLE(M98095_086_CFG_LINE, 7, 2, max98095_line_mode_text);
-
-static const struct soc_enum max98095_lineout_mode_enum =
-	SOC_ENUM_SINGLE(M98095_086_CFG_LINE, 4, 2, max98095_line_mode_text);
+static SOC_ENUM_SINGLE_DECL(max98095_linein_mode_enum,
+			    M98095_086_CFG_LINE, 7,
+			    max98095_line_mode_text);
+
+static SOC_ENUM_SINGLE_DECL(max98095_lineout_mode_enum,
+			    M98095_086_CFG_LINE, 4,
+			    max98095_line_mode_text);
 
 static const char * const max98095_dai_fltr[] = {
 	"Off", "Elliptical-HPF-16k", "Butterworth-HPF-16k",
 	"Elliptical-HPF-8k", "Butterworth-HPF-8k", "Butterworth-HPF-Fs/240"};
-static const struct soc_enum max98095_dai1_dac_filter_enum[] = {
-	SOC_ENUM_SINGLE(M98095_02E_DAI1_FILTERS, 0, 6, max98095_dai_fltr),
-};
-static const struct soc_enum max98095_dai2_dac_filter_enum[] = {
-	SOC_ENUM_SINGLE(M98095_038_DAI2_FILTERS, 0, 6, max98095_dai_fltr),
-};
-static const struct soc_enum max98095_dai3_dac_filter_enum[] = {
-	SOC_ENUM_SINGLE(M98095_042_DAI3_FILTERS, 0, 6, max98095_dai_fltr),
-};
+static SOC_ENUM_SINGLE_DECL(max98095_dai1_dac_filter_enum,
+			    M98095_02E_DAI1_FILTERS, 0,
+			    max98095_dai_fltr);
+static SOC_ENUM_SINGLE_DECL(max98095_dai2_dac_filter_enum,
+			    M98095_038_DAI2_FILTERS, 0,
+			    max98095_dai_fltr);
+static SOC_ENUM_SINGLE_DECL(max98095_dai3_dac_filter_enum,
+			    M98095_042_DAI3_FILTERS, 0,
+			    max98095_dai_fltr);
 
 static int max98095_mic1pre_set(struct snd_kcontrol *kcontrol,
 				struct snd_ctl_elem_value *ucontrol)
@@ -1861,7 +1865,7 @@
 
 	/* Now point the soc_enum to .texts array items */
 	max98095->eq_enum.texts = max98095->eq_texts;
-	max98095->eq_enum.max = max98095->eq_textcnt;
+	max98095->eq_enum.items = max98095->eq_textcnt;
 
 	ret = snd_soc_add_codec_controls(codec, controls, ARRAY_SIZE(controls));
 	if (ret != 0)
@@ -2016,7 +2020,7 @@
 
 	/* Now point the soc_enum to .texts array items */
 	max98095->bq_enum.texts = max98095->bq_texts;
-	max98095->bq_enum.max = max98095->bq_textcnt;
+	max98095->bq_enum.items = max98095->bq_textcnt;
 
 	ret = snd_soc_add_codec_controls(codec, controls, ARRAY_SIZE(controls));
 	if (ret != 0)
Index: b/sound/soc/codecs/rt5640.c
===================================================================
--- a/sound/soc/codecs/rt5640.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/codecs/rt5640.c	2016-06-02 12:39:40.651465758 +0800
@@ -361,25 +361,24 @@
 static const char * const rt5640_data_select[] = {
 	"Normal", "Swap", "left copy to right", "right copy to left"};
 
-static const SOC_ENUM_SINGLE_DECL(rt5640_if1_dac_enum, RT5640_DIG_INF_DATA,
-				RT5640_IF1_DAC_SEL_SFT, rt5640_data_select);
+static SOC_ENUM_SINGLE_DECL(rt5640_if1_dac_enum, RT5640_DIG_INF_DATA,
+			    RT5640_IF1_DAC_SEL_SFT, rt5640_data_select);
 
-static const SOC_ENUM_SINGLE_DECL(rt5640_if1_adc_enum, RT5640_DIG_INF_DATA,
-				RT5640_IF1_ADC_SEL_SFT, rt5640_data_select);
+static SOC_ENUM_SINGLE_DECL(rt5640_if1_adc_enum, RT5640_DIG_INF_DATA,
+			    RT5640_IF1_ADC_SEL_SFT, rt5640_data_select);
 
-static const SOC_ENUM_SINGLE_DECL(rt5640_if2_dac_enum, RT5640_DIG_INF_DATA,
-				RT5640_IF2_DAC_SEL_SFT, rt5640_data_select);
+static SOC_ENUM_SINGLE_DECL(rt5640_if2_dac_enum, RT5640_DIG_INF_DATA,
+			    RT5640_IF2_DAC_SEL_SFT, rt5640_data_select);
 
-static const SOC_ENUM_SINGLE_DECL(rt5640_if2_adc_enum, RT5640_DIG_INF_DATA,
-				RT5640_IF2_ADC_SEL_SFT, rt5640_data_select);
+static SOC_ENUM_SINGLE_DECL(rt5640_if2_adc_enum, RT5640_DIG_INF_DATA,
+			    RT5640_IF2_ADC_SEL_SFT, rt5640_data_select);
 
 /* Class D speaker gain ratio */
 static const char * const rt5640_clsd_spk_ratio[] = {"1.66x", "1.83x", "1.94x",
 	"2x", "2.11x", "2.22x", "2.33x", "2.44x", "2.55x", "2.66x", "2.77x"};
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_clsd_spk_ratio_enum, RT5640_CLS_D_OUT,
-	RT5640_CLSD_RATIO_SFT, rt5640_clsd_spk_ratio);
+static SOC_ENUM_SINGLE_DECL(rt5640_clsd_spk_ratio_enum, RT5640_CLS_D_OUT,
+			    RT5640_CLSD_RATIO_SFT, rt5640_clsd_spk_ratio);
 
 static const struct snd_kcontrol_new rt5640_snd_controls[] = {
 	/* Speaker Output Volume */
@@ -753,9 +752,8 @@
 	"DIG MIX", "ADC"
 };
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_stereo_adc1_enum, RT5640_STO_ADC_MIXER,
-	RT5640_ADC_1_SRC_SFT, rt5640_stereo_adc1_src);
+static SOC_ENUM_SINGLE_DECL(rt5640_stereo_adc1_enum, RT5640_STO_ADC_MIXER,
+			    RT5640_ADC_1_SRC_SFT, rt5640_stereo_adc1_src);
 
 static const struct snd_kcontrol_new rt5640_sto_adc_1_mux =
 	SOC_DAPM_ENUM("Stereo ADC1 Mux", rt5640_stereo_adc1_enum);
@@ -764,9 +762,8 @@
 	"DMIC1", "DMIC2", "DIG MIX"
 };
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_stereo_adc2_enum, RT5640_STO_ADC_MIXER,
-	RT5640_ADC_2_SRC_SFT, rt5640_stereo_adc2_src);
+static SOC_ENUM_SINGLE_DECL(rt5640_stereo_adc2_enum, RT5640_STO_ADC_MIXER,
+			    RT5640_ADC_2_SRC_SFT, rt5640_stereo_adc2_src);
 
 static const struct snd_kcontrol_new rt5640_sto_adc_2_mux =
 	SOC_DAPM_ENUM("Stereo ADC2 Mux", rt5640_stereo_adc2_enum);
@@ -776,9 +773,8 @@
 	"Mono DAC MIXL", "ADCL"
 };
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_mono_adc_l1_enum, RT5640_MONO_ADC_MIXER,
-	RT5640_MONO_ADC_L1_SRC_SFT, rt5640_mono_adc_l1_src);
+static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_l1_enum, RT5640_MONO_ADC_MIXER,
+			    RT5640_MONO_ADC_L1_SRC_SFT, rt5640_mono_adc_l1_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_l1_mux =
 	SOC_DAPM_ENUM("Mono ADC1 left source", rt5640_mono_adc_l1_enum);
@@ -787,9 +783,8 @@
 	"DMIC L1", "DMIC L2", "Mono DAC MIXL"
 };
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_mono_adc_l2_enum, RT5640_MONO_ADC_MIXER,
-	RT5640_MONO_ADC_L2_SRC_SFT, rt5640_mono_adc_l2_src);
+static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_l2_enum, RT5640_MONO_ADC_MIXER,
+			    RT5640_MONO_ADC_L2_SRC_SFT, rt5640_mono_adc_l2_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_l2_mux =
 	SOC_DAPM_ENUM("Mono ADC2 left source", rt5640_mono_adc_l2_enum);
@@ -798,9 +793,8 @@
 	"Mono DAC MIXR", "ADCR"
 };
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_mono_adc_r1_enum, RT5640_MONO_ADC_MIXER,
-	RT5640_MONO_ADC_R1_SRC_SFT, rt5640_mono_adc_r1_src);
+static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_r1_enum, RT5640_MONO_ADC_MIXER,
+			    RT5640_MONO_ADC_R1_SRC_SFT, rt5640_mono_adc_r1_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_r1_mux =
 	SOC_DAPM_ENUM("Mono ADC1 right source", rt5640_mono_adc_r1_enum);
@@ -809,9 +803,8 @@
 	"DMIC R1", "DMIC R2", "Mono DAC MIXR"
 };
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_mono_adc_r2_enum, RT5640_MONO_ADC_MIXER,
-	RT5640_MONO_ADC_R2_SRC_SFT, rt5640_mono_adc_r2_src);
+static SOC_ENUM_SINGLE_DECL(rt5640_mono_adc_r2_enum, RT5640_MONO_ADC_MIXER,
+			    RT5640_MONO_ADC_R2_SRC_SFT, rt5640_mono_adc_r2_src);
 
 static const struct snd_kcontrol_new rt5640_mono_adc_r2_mux =
 	SOC_DAPM_ENUM("Mono ADC2 right source", rt5640_mono_adc_r2_enum);
@@ -826,9 +819,9 @@
 	3,
 };
 
-static const SOC_VALUE_ENUM_SINGLE_DECL(
-	rt5640_dac_l2_enum, RT5640_DSP_PATH2, RT5640_DAC_L2_SEL_SFT,
-	0x3, rt5640_dac_l2_src, rt5640_dac_l2_values);
+static SOC_VALUE_ENUM_SINGLE_DECL(rt5640_dac_l2_enum,
+				  RT5640_DSP_PATH2, RT5640_DAC_L2_SEL_SFT,
+				  0x3, rt5640_dac_l2_src, rt5640_dac_l2_values);
 
 static const struct snd_kcontrol_new rt5640_dac_l2_mux =
 	SOC_DAPM_VALUE_ENUM("DAC2 left channel source", rt5640_dac_l2_enum);
@@ -841,9 +834,9 @@
 	0,
 };
 
-static const SOC_VALUE_ENUM_SINGLE_DECL(
-	rt5640_dac_r2_enum, RT5640_DSP_PATH2, RT5640_DAC_R2_SEL_SFT,
-	0x3, rt5640_dac_r2_src, rt5640_dac_r2_values);
+static SOC_VALUE_ENUM_SINGLE_DECL(rt5640_dac_r2_enum,
+				  RT5640_DSP_PATH2, RT5640_DAC_R2_SEL_SFT,
+				  0x3, rt5640_dac_r2_src, rt5640_dac_r2_values);
 
 static const struct snd_kcontrol_new rt5640_dac_r2_mux =
 	SOC_DAPM_ENUM("DAC2 right channel source", rt5640_dac_r2_enum);
@@ -860,9 +853,10 @@
 	7,
 };
 
-static const SOC_VALUE_ENUM_SINGLE_DECL(
-	rt5640_dai_iis_map_enum, RT5640_I2S1_SDP, RT5640_I2S_IF_SFT,
-	0x7, rt5640_dai_iis_map, rt5640_dai_iis_map_values);
+static SOC_VALUE_ENUM_SINGLE_DECL(rt5640_dai_iis_map_enum,
+				  RT5640_I2S1_SDP, RT5640_I2S_IF_SFT,
+				  0x7, rt5640_dai_iis_map,
+				  rt5640_dai_iis_map_values);
 
 static const struct snd_kcontrol_new rt5640_dai_mux =
 	SOC_DAPM_VALUE_ENUM("DAI select", rt5640_dai_iis_map_enum);
@@ -872,9 +866,8 @@
 	"IF1", "IF2"
 };
 
-static const SOC_ENUM_SINGLE_DECL(
-	rt5640_sdi_sel_enum, RT5640_I2S2_SDP,
-	RT5640_I2S2_SDI_SFT, rt5640_sdi_sel);
+static SOC_ENUM_SINGLE_DECL(rt5640_sdi_sel_enum, RT5640_I2S2_SDP,
+			    RT5640_I2S2_SDI_SFT, rt5640_sdi_sel);
 
 static const struct snd_kcontrol_new rt5640_sdi_mux =
 	SOC_DAPM_ENUM("SDI select", rt5640_sdi_sel_enum);
Index: b/sound/soc/generic/simple-card.c
===================================================================
--- a/sound/soc/generic/simple-card.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/generic/simple-card.c	2016-06-02 12:28:43.393170207 +0800
@@ -9,48 +9,73 @@
  * published by the Free Software Foundation.
  */
 #include <linux/clk.h>
+#include <linux/device.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/string.h>
 #include <sound/simple_card.h>
+#include <sound/soc-dai.h>
+#include <sound/soc.h>
+
+struct simple_card_data {
+	struct snd_soc_card snd_card;
+	unsigned int daifmt;
+	struct asoc_simple_dai cpu_dai;
+	struct asoc_simple_dai codec_dai;
+	struct snd_soc_dai_link snd_link;
+};
 
 static int __asoc_simple_card_dai_init(struct snd_soc_dai *dai,
-				       struct asoc_simple_dai *set,
-				       unsigned int daifmt)
+				       struct asoc_simple_dai *set)
 {
-	int ret = 0;
+	int ret;
 
-	daifmt |= set->fmt;
+	if (set->fmt) {
+		ret = snd_soc_dai_set_fmt(dai, set->fmt);
+		if (ret && ret != -ENOTSUPP) {
+			dev_err(dai->dev, "simple-card: set_fmt error\n");
+			goto err;
+		}
+	}
 
-	if (daifmt)
-		ret = snd_soc_dai_set_fmt(dai, daifmt);
+	if (set->sysclk) {
+		ret = snd_soc_dai_set_sysclk(dai, 0, set->sysclk, 0);
+		if (ret && ret != -ENOTSUPP) {
+			dev_err(dai->dev, "simple-card: set_sysclk error\n");
+			goto err;
+		}
+	}
 
-	if (ret == -ENOTSUPP) {
-		dev_dbg(dai->dev, "ASoC: set_fmt is not supported\n");
-		ret = 0;
+	if (set->slots) {
+		ret = snd_soc_dai_set_tdm_slot(dai, 0, 0,
+						set->slots,
+						set->slot_width);
+		if (ret && ret != -ENOTSUPP) {
+			dev_err(dai->dev, "simple-card: set_tdm_slot error\n");
+			goto err;
+		}
 	}
 
-	if (!ret && set->sysclk)
-		ret = snd_soc_dai_set_sysclk(dai, 0, set->sysclk, 0);
+	ret = 0;
 
+err:
 	return ret;
 }
 
 static int asoc_simple_card_dai_init(struct snd_soc_pcm_runtime *rtd)
 {
-	struct asoc_simple_card_info *info =
+	struct simple_card_data *priv =
 				snd_soc_card_get_drvdata(rtd->card);
 	struct snd_soc_dai *codec = rtd->codec_dai;
 	struct snd_soc_dai *cpu = rtd->cpu_dai;
-	unsigned int daifmt = info->daifmt;
 	int ret;
 
-	ret = __asoc_simple_card_dai_init(codec, &info->codec_dai, daifmt);
+	ret = __asoc_simple_card_dai_init(codec, &priv->codec_dai);
 	if (ret < 0)
 		return ret;
 
-	ret = __asoc_simple_card_dai_init(cpu, &info->cpu_dai, daifmt);
+	ret = __asoc_simple_card_dai_init(cpu, &priv->cpu_dai);
 	if (ret < 0)
 		return ret;
 
@@ -59,9 +84,12 @@
 
 static int
 asoc_simple_card_sub_parse_of(struct device_node *np,
+			      unsigned int daifmt,
 			      struct asoc_simple_dai *dai,
-			      struct device_node **node)
+			      const struct device_node **p_node,
+			      const char **name)
 {
+	struct device_node *node;
 	struct clk *clk;
 	int ret;
 
@@ -69,21 +97,28 @@
 	 * get node via "sound-dai = <&phandle port>"
 	 * it will be used as xxx_of_node on soc_bind_dai_link()
 	 */
-	*node = of_parse_phandle(np, "sound-dai", 0);
-	if (!*node)
+	node = of_parse_phandle(np, "sound-dai", 0);
+	if (!node)
 		return -ENODEV;
+	*p_node = node;
 
 	/* get dai->name */
-	ret = snd_soc_of_get_dai_name(np, &dai->name);
+	ret = snd_soc_of_get_dai_name(np, name);
 	if (ret < 0)
 		goto parse_error;
 
+	/* parse TDM slot */
+	ret = snd_soc_of_parse_tdm_slot(np, &dai->slots, &dai->slot_width);
+	if (ret)
+		goto parse_error;
+
 	/*
 	 * bitclock-inversion, frame-inversion
 	 * bitclock-master,    frame-master
 	 * and specific "format" if it has
 	 */
 	dai->fmt = snd_soc_of_parse_daifmt(np, NULL);
+	dai->fmt |= daifmt;
 
 	/*
 	 * dai->sysclk come from
@@ -104,7 +139,7 @@
 				     "system-clock-frequency",
 				     &dai->sysclk);
 	} else {
-		clk = of_clk_get(*node, 0);
+		clk = of_clk_get(node, 0);
 		if (!IS_ERR(clk))
 			dai->sysclk = clk_get_rate(clk);
 	}
@@ -112,29 +147,38 @@
 	ret = 0;
 
 parse_error:
-	of_node_put(*node);
+	of_node_put(node);
 
 	return ret;
 }
 
 static int asoc_simple_card_parse_of(struct device_node *node,
-				     struct asoc_simple_card_info *info,
-				     struct device *dev,
-				     struct device_node **of_cpu,
-				     struct device_node **of_codec,
-				     struct device_node **of_platform)
+				     struct simple_card_data *priv,
+				     struct device *dev)
 {
+	struct snd_soc_dai_link *dai_link = priv->snd_card.dai_link;
 	struct device_node *np;
 	char *name;
 	int ret;
 
+	/* parsing the card name from DT */
+	snd_soc_of_parse_card_name(&priv->snd_card, "simple-audio-card,name");
+
 	/* get CPU/CODEC common format via simple-audio-card,format */
-	info->daifmt = snd_soc_of_parse_daifmt(node, "simple-audio-card,") &
+	priv->daifmt = snd_soc_of_parse_daifmt(node, "simple-audio-card,") &
 		(SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK);
 
+	/* off-codec widgets */
+	if (of_property_read_bool(node, "simple-audio-card,widgets")) {
+		ret = snd_soc_of_parse_audio_simple_widgets(&priv->snd_card,
+					"simple-audio-card,widgets");
+		if (ret)
+			return ret;
+	}
+
 	/* DAPM routes */
 	if (of_property_read_bool(node, "simple-audio-card,routing")) {
-		ret = snd_soc_of_parse_audio_routing(&info->snd_card,
+		ret = snd_soc_of_parse_audio_routing(&priv->snd_card,
 					"simple-audio-card,routing");
 		if (ret)
 			return ret;
@@ -144,9 +188,10 @@
 	ret = -EINVAL;
 	np = of_get_child_by_name(node, "simple-audio-card,cpu");
 	if (np)
-		ret = asoc_simple_card_sub_parse_of(np,
-						  &info->cpu_dai,
-						  of_cpu);
+		ret = asoc_simple_card_sub_parse_of(np, priv->daifmt,
+						  &priv->cpu_dai,
+						  &dai_link->cpu_of_node,
+						  &dai_link->cpu_dai_name);
 	if (ret < 0)
 		return ret;
 
@@ -154,114 +199,113 @@
 	ret = -EINVAL;
 	np = of_get_child_by_name(node, "simple-audio-card,codec");
 	if (np)
-		ret = asoc_simple_card_sub_parse_of(np,
-						  &info->codec_dai,
-						  of_codec);
+		ret = asoc_simple_card_sub_parse_of(np, priv->daifmt,
+						  &priv->codec_dai,
+						  &dai_link->codec_of_node,
+						  &dai_link->codec_dai_name);
 	if (ret < 0)
 		return ret;
 
-	if (!info->cpu_dai.name || !info->codec_dai.name)
+	if (!dai_link->cpu_dai_name || !dai_link->codec_dai_name)
 		return -EINVAL;
 
 	/* card name is created from CPU/CODEC dai name */
 	name = devm_kzalloc(dev,
-			    strlen(info->cpu_dai.name)   +
-			    strlen(info->codec_dai.name) + 2,
+			    strlen(dai_link->cpu_dai_name)   +
+			    strlen(dai_link->codec_dai_name) + 2,
 			    GFP_KERNEL);
-	sprintf(name, "%s-%s", info->cpu_dai.name, info->codec_dai.name);
-	info->name = info->card = name;
+	sprintf(name, "%s-%s", dai_link->cpu_dai_name,
+				dai_link->codec_dai_name);
+	if (!priv->snd_card.name)
+		priv->snd_card.name = name;
+	dai_link->name = dai_link->stream_name = name;
 
 	/* simple-card assumes platform == cpu */
-	*of_platform = *of_cpu;
+	dai_link->platform_of_node = dai_link->cpu_of_node;
 
-	dev_dbg(dev, "card-name : %s\n", info->card);
-	dev_dbg(dev, "platform : %04x\n", info->daifmt);
+	dev_dbg(dev, "card-name : %s\n", name);
+	dev_dbg(dev, "platform : %04x\n", priv->daifmt);
 	dev_dbg(dev, "cpu : %s / %04x / %d\n",
-		info->cpu_dai.name,
-		info->cpu_dai.fmt,
-		info->cpu_dai.sysclk);
+		dai_link->cpu_dai_name,
+		priv->cpu_dai.fmt,
+		priv->cpu_dai.sysclk);
 	dev_dbg(dev, "codec : %s / %04x / %d\n",
-		info->codec_dai.name,
-		info->codec_dai.fmt,
-		info->codec_dai.sysclk);
+		dai_link->codec_dai_name,
+		priv->codec_dai.fmt,
+		priv->codec_dai.sysclk);
 
 	return 0;
 }
 
 static int asoc_simple_card_probe(struct platform_device *pdev)
 {
-	struct asoc_simple_card_info *cinfo;
+	struct simple_card_data *priv;
+	struct snd_soc_dai_link *dai_link;
 	struct device_node *np = pdev->dev.of_node;
-	struct device_node *of_cpu, *of_codec, *of_platform;
 	struct device *dev = &pdev->dev;
 	int ret;
 
-	cinfo		= NULL;
-	of_cpu		= NULL;
-	of_codec	= NULL;
-	of_platform	= NULL;
-
-	cinfo = devm_kzalloc(dev, sizeof(*cinfo), GFP_KERNEL);
-	if (!cinfo)
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
 		return -ENOMEM;
 
+	/*
+	 * init snd_soc_card
+	 */
+	priv->snd_card.owner = THIS_MODULE;
+	priv->snd_card.dev = dev;
+	dai_link = &priv->snd_link;
+	priv->snd_card.dai_link = dai_link;
+	priv->snd_card.num_links = 1;
+
 	if (np && of_device_is_available(np)) {
-		cinfo->snd_card.dev = dev;
 
-		ret = asoc_simple_card_parse_of(np, cinfo, dev,
-						&of_cpu,
-						&of_codec,
-						&of_platform);
+		ret = asoc_simple_card_parse_of(np, priv, dev);
 		if (ret < 0) {
 			if (ret != -EPROBE_DEFER)
 				dev_err(dev, "parse error %d\n", ret);
 			return ret;
 		}
 	} else {
-		if (!dev->platform_data) {
+		struct asoc_simple_card_info *cinfo;
+
+		cinfo = dev->platform_data;
+		if (!cinfo) {
 			dev_err(dev, "no info for asoc-simple-card\n");
 			return -EINVAL;
 		}
 
-		memcpy(cinfo, dev->platform_data, sizeof(*cinfo));
-		cinfo->snd_card.dev = dev;
-	}
+		if (!cinfo->name	||
+		    !cinfo->card	||
+		    !cinfo->codec_dai.name	||
+		    !cinfo->codec	||
+		    !cinfo->platform	||
+		    !cinfo->cpu_dai.name) {
+			dev_err(dev, "insufficient asoc_simple_card_info settings\n");
+			return -EINVAL;
+		}
 
-	if (!cinfo->name	||
-	    !cinfo->card	||
-	    !cinfo->codec_dai.name	||
-	    !(cinfo->codec		|| of_codec)	||
-	    !(cinfo->platform		|| of_platform)	||
-	    !(cinfo->cpu_dai.name	|| of_cpu)) {
-		dev_err(dev, "insufficient asoc_simple_card_info settings\n");
-		return -EINVAL;
+		priv->snd_card.name	= cinfo->card;
+		dai_link->name		= cinfo->name;
+		dai_link->stream_name	= cinfo->name;
+		dai_link->platform_name	= cinfo->platform;
+		dai_link->codec_name	= cinfo->codec;
+		dai_link->cpu_dai_name	= cinfo->cpu_dai.name;
+		dai_link->codec_dai_name = cinfo->codec_dai.name;
+		memcpy(&priv->cpu_dai, &cinfo->cpu_dai,
+						sizeof(priv->cpu_dai));
+		memcpy(&priv->codec_dai, &cinfo->codec_dai,
+						sizeof(priv->codec_dai));
 	}
 
 	/*
 	 * init snd_soc_dai_link
 	 */
-	cinfo->snd_link.name		= cinfo->name;
-	cinfo->snd_link.stream_name	= cinfo->name;
-	cinfo->snd_link.cpu_dai_name	= cinfo->cpu_dai.name;
-	cinfo->snd_link.platform_name	= cinfo->platform;
-	cinfo->snd_link.codec_name	= cinfo->codec;
-	cinfo->snd_link.codec_dai_name	= cinfo->codec_dai.name;
-	cinfo->snd_link.cpu_of_node	= of_cpu;
-	cinfo->snd_link.codec_of_node	= of_codec;
-	cinfo->snd_link.platform_of_node = of_platform;
-	cinfo->snd_link.init		= asoc_simple_card_dai_init;
-
-	/*
-	 * init snd_soc_card
-	 */
-	cinfo->snd_card.name		= cinfo->card;
-	cinfo->snd_card.owner		= THIS_MODULE;
-	cinfo->snd_card.dai_link	= &cinfo->snd_link;
-	cinfo->snd_card.num_links	= 1;
+	dai_link->init = asoc_simple_card_dai_init;
 
-	snd_soc_card_set_drvdata(&cinfo->snd_card, cinfo);
+	snd_soc_card_set_drvdata(&priv->snd_card, priv);
 
-	return devm_snd_soc_register_card(&pdev->dev, &cinfo->snd_card);
+	return devm_snd_soc_register_card(&pdev->dev, &priv->snd_card);
 }
 
 static const struct of_device_id asoc_simple_of_match[] = {
Index: b/sound/soc/intel/Kconfig
===================================================================
--- a/sound/soc/intel/Kconfig	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/Kconfig	2016-06-02 12:28:43.393170207 +0800
@@ -15,6 +15,7 @@
 config SND_SOC_INTEL_SST
 	tristate "ASoC support for Intel(R) Smart Sound Technology"
 	select SND_SOC_INTEL_SST_ACPI if ACPI
+	depends on (X86 || COMPILE_TEST)
 	help
           This adds support for Intel(R) Smart Sound Technology (SST).
           Say Y if you have such a device
@@ -40,23 +41,33 @@
           Say Y if you have such a device
           If unsure select "N".
 
+config SND_SOC_INTEL_BYT_RT5640_MACH
+	tristate "ASoC Audio driver for Intel Baytrail with RT5640 codec"
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
+	select SND_SOC_INTEL_BAYTRAIL
+	select SND_SOC_RT5640
+	help
+	  This adds audio driver for Intel Baytrail platform based boards
+	  with the RT5640 audio codec.
+
 config SND_SOC_INTEL_BROADWELL_MACH
-        tristate "ASoC Audio DSP support for Intel Broadwell Wildcatpoint"
-        depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
+	tristate "ASoC Audio DSP support for Intel Broadwell Wildcatpoint"
+	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_HASWELL
 	select SND_COMPRESS_OFFLOAD
 	select SND_SOC_RT286
 	help
-          This adds support for the Wilcatpoint Audio DSP on Intel(R) Broadwell
+	  This adds support for the Wilcatpoint Audio DSP on Intel(R) Broadwell
 	  Ultrabook platforms.
-          Say Y if you have such a device
-          If unsure select "N".
+	  Say Y if you have such a device
+	  If unsure select "N".
 
-config SND_SOC_INTEL_BYT_RT5640_MACH
-	tristate "ASoC Audio driver for Intel Baytrail with RT5640 codec"
+config SND_SOC_INTEL_BYT_MAX98090_MACH
+	tristate "ASoC Audio driver for Intel Baytrail with MAX98090 codec"
 	depends on SND_SOC_INTEL_SST && X86_INTEL_LPSS
 	select SND_SOC_INTEL_BAYTRAIL
-	select SND_SOC_RT5640
+	select SND_SOC_MAX98090
+	select VLV2_PLAT_CLK
 	help
-          This adds audio driver for Intel Baytrail platform based boards
-          with the RT5640 audio codec.
+	  This adds audio driver for Intel Baytrail platform based boards
+	  with the MAX98090 audio codec.
Index: b/sound/soc/intel/Makefile
===================================================================
--- a/sound/soc/intel/Makefile	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/Makefile	2016-06-02 12:28:43.393170207 +0800
@@ -22,9 +22,11 @@
 
 # Machine support
 snd-soc-sst-haswell-objs := haswell.o
-snd-soc-sst-broadwell-objs := broadwell.o
 snd-soc-sst-byt-rt5640-mach-objs := byt-rt5640.o
+snd-soc-sst-broadwell-objs := broadwell.o
+snd-soc-sst-byt-max98090-mach-objs := byt-max98090.o
 
 obj-$(CONFIG_SND_SOC_INTEL_HASWELL_MACH) += snd-soc-sst-haswell.o
-obj-$(CONFIG_SND_SOC_INTEL_BROADWELL_MACH) += snd-soc-sst-broadwell.o
 obj-$(CONFIG_SND_SOC_INTEL_BYT_RT5640_MACH) += snd-soc-sst-byt-rt5640-mach.o
+obj-$(CONFIG_SND_SOC_INTEL_BROADWELL_MACH) += snd-soc-sst-broadwell.o
+obj-$(CONFIG_SND_SOC_INTEL_BYT_MAX98090_MACH) += snd-soc-sst-byt-max98090-mach.o
Index: b/sound/soc/intel/byt-max98090.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ b/sound/soc/intel/byt-max98090.c	2016-06-02 12:28:43.393170207 +0800
@@ -0,0 +1,254 @@
+/*
+ * Intel Baytrail SST MAX98090 machine driver
+ * Copyright (c) 2014, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include "../codecs/max98090.h"
+
+struct byt_max98090_private {
+	struct snd_soc_jack jack;
+};
+
+static const struct snd_soc_dapm_widget byt_max98090_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Int Mic", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+};
+
+static const struct snd_soc_dapm_route byt_max98090_audio_map[] = {
+	{"IN34", NULL, "Headset Mic"},
+	{"IN34", NULL, "MICBIAS"},
+	{"MICBIAS", NULL, "Headset Mic"},
+	{"DMICL", NULL, "Int Mic"},
+	{"Headphone", NULL, "HPL"},
+	{"Headphone", NULL, "HPR"},
+	{"Ext Spk", NULL, "SPKL"},
+	{"Ext Spk", NULL, "SPKR"},
+};
+
+static const struct snd_kcontrol_new byt_max98090_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Int Mic"),
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
+static struct snd_soc_jack_pin hs_jack_pins[] = {
+	{
+		.pin	= "Headphone",
+		.mask	= SND_JACK_HEADPHONE,
+	},
+	{
+		.pin	= "Headset Mic",
+		.mask	= SND_JACK_MICROPHONE,
+	},
+	{
+		.pin	= "Ext Spk",
+		.mask	= SND_JACK_LINEOUT,
+	},
+	{
+		.pin	= "Int Mic",
+		.mask	= SND_JACK_LINEIN,
+	},
+};
+
+static struct snd_soc_jack_gpio hs_jack_gpios[] = {
+	{
+		.name		= "hp-gpio",
+		.report		= SND_JACK_HEADPHONE | SND_JACK_LINEOUT,
+		.debounce_time	= 200,
+	},
+	{
+		.name		= "mic-gpio",
+		.report		= SND_JACK_MICROPHONE | SND_JACK_LINEIN,
+		.debounce_time	= 200,
+	},
+};
+
+static int byt_max98090_init(struct snd_soc_pcm_runtime *runtime)
+{
+	int ret;
+	struct snd_soc_codec *codec = runtime->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct snd_soc_card *card = runtime->card;
+	struct byt_max98090_private *drv = snd_soc_card_get_drvdata(card);
+	struct snd_soc_jack *jack = &drv->jack;
+	struct gpio_desc *mic_desc;
+	struct gpio_desc *hp_desc;
+
+	card->dapm.idle_bias_off = true;
+
+	ret = snd_soc_dai_set_sysclk(runtime->codec_dai,
+				     M98090_REG_SYSTEM_CLOCK,
+				     19200000, SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		dev_err(card->dev, "Can't set codec clock %d\n", ret);
+		return ret;
+	}
+
+	snd_soc_dapm_enable_pin(dapm, "Headset Mic");
+	snd_soc_dapm_enable_pin(dapm, "Headphone");
+	snd_soc_dapm_enable_pin(dapm, "Ext Spk");
+	snd_soc_dapm_enable_pin(dapm, "Int Mic");
+
+	snd_soc_dapm_sync(dapm);
+
+	/*
+	 * ASoC still uses legacy GPIOs so we look both GPIOs using
+	 * descriptors here, convert them to numbers and release the
+	 * acquired descriptors. Once ASoC switches over to GPIO descriptor
+	 * APIs we can pass them directly.
+	 */
+	hp_desc = gpiod_get_index(card->dev->parent, NULL, 0);
+	if (IS_ERR(hp_desc))
+		return 0;
+	mic_desc = gpiod_get_index(card->dev->parent, NULL, 1);
+	if (IS_ERR(mic_desc)) {
+		gpiod_put(hp_desc);
+		return 0;
+	}
+
+	hs_jack_gpios[0].gpio = desc_to_gpio(hp_desc);
+	hs_jack_gpios[1].gpio = desc_to_gpio(mic_desc);
+
+	gpiod_put(mic_desc);
+	gpiod_put(hp_desc);
+
+	/* Enable jack detection */
+	ret = snd_soc_jack_new(codec, "Headphone", SND_JACK_HEADPHONE, jack);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_jack_add_pins(jack, ARRAY_SIZE(hs_jack_pins),
+				    hs_jack_pins);
+	if (ret)
+		return ret;
+
+	/* enabled codec jack and PLL interrupts */
+	snd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,
+		M98090_IJDET_MASK | M98090_IULK_MASK,
+		1 << M98090_IJDET_SHIFT | 1 << M98090_IULK_SHIFT);
+
+	snd_soc_jack_report(jack, SND_JACK_LINEOUT | SND_JACK_LINEIN,
+			    SND_JACK_HEADSET | SND_JACK_LINEOUT |
+			    SND_JACK_LINEIN);
+
+	ret = snd_soc_jack_add_gpios(jack, ARRAY_SIZE(hs_jack_gpios),
+				     hs_jack_gpios);
+
+	return ret;
+}
+
+static struct snd_soc_dai_link byt_max98090_dais[] = {
+	{
+		.name = "Baytrail Audio",
+		.stream_name = "Audio",
+		.cpu_dai_name = "baytrail-pcm-audio",
+		.codec_dai_name = "HiFi",
+		.codec_name = "i2c-193C9890:00:1c",
+		.platform_name = "baytrail-pcm-audio",
+		.init = byt_max98090_init,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			SND_SOC_DAIFMT_CBS_CFS,
+	},
+};
+
+static struct snd_soc_card byt_max98090_card = {
+	.name = "byt-max98090",
+	.dai_link = byt_max98090_dais,
+	.num_links = ARRAY_SIZE(byt_max98090_dais),
+	.dapm_widgets = byt_max98090_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(byt_max98090_widgets),
+	.dapm_routes = byt_max98090_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(byt_max98090_audio_map),
+	.controls = byt_max98090_controls,
+	.num_controls = ARRAY_SIZE(byt_max98090_controls),
+};
+
+#ifdef CONFIG_PM_SLEEP
+static const struct dev_pm_ops byt_max98090_pm_ops = {
+	.suspend = snd_soc_suspend,
+	.resume = snd_soc_resume,
+};
+
+#define BYT_MAX98090_PM_OPS	(&byt_max98090_pm_ops)
+#else
+#define BYT_MAX98090_PM_OPS	NULL
+#endif
+
+static int byt_max98090_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	struct byt_max98090_private *drv;
+
+	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);
+	if (!drv) {
+		dev_err(&pdev->dev, "allocation failed\n");
+		return -ENOMEM;
+	}
+
+	/* register the soc card */
+	byt_max98090_card.dev = &pdev->dev;
+	snd_soc_card_set_drvdata(&byt_max98090_card, drv);
+	ret_val = snd_soc_register_card(&byt_max98090_card);
+	if (ret_val) {
+		dev_err(&pdev->dev,
+			"snd_soc_register_card failed %d\n", ret_val);
+		return ret_val;
+	}
+	platform_set_drvdata(pdev, &byt_max98090_card);
+
+	return ret_val;
+}
+
+static int byt_max98090_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct byt_max98090_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	snd_soc_jack_free_gpios(&drv->jack, ARRAY_SIZE(hs_jack_gpios),
+				hs_jack_gpios);
+
+	snd_soc_card_set_drvdata(soc_card, NULL);
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct platform_driver byt_max98090_driver = {
+	.probe = byt_max98090_probe,
+	.remove = byt_max98090_remove,
+	.driver = {
+		.name = "byt-max98090",
+		.owner = THIS_MODULE,
+		.pm = BYT_MAX98090_PM_OPS,
+	},
+};
+module_platform_driver(byt_max98090_driver)
+
+MODULE_DESCRIPTION("ASoC Intel(R) Baytrail Machine driver");
+MODULE_AUTHOR("Omair Md Abdullah, Jarkko Nikula");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:byt-max98090");
Index: b/sound/soc/intel/byt-rt5640.c
===================================================================
--- a/sound/soc/intel/byt-rt5640.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/byt-rt5640.c	2016-06-02 12:28:43.393170207 +0800
@@ -26,57 +26,44 @@
 
 #include "sst-dsp.h"
 
-static const struct snd_soc_dapm_widget byt_dapm_widgets[] = {
+static const struct snd_soc_dapm_widget byt_rt5640_widgets[] = {
 	SND_SOC_DAPM_HP("Headphone", NULL),
 	SND_SOC_DAPM_MIC("Headset Mic", NULL),
-	SND_SOC_DAPM_MIC("Int Mic", NULL),
-	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_MIC("Internal Mic", NULL),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
 };
 
-static const struct snd_soc_dapm_route byt_audio_map[] = {
+static const struct snd_soc_dapm_route byt_rt5640_audio_map[] = {
 	{"IN2P", NULL, "Headset Mic"},
 	{"IN2N", NULL, "Headset Mic"},
-	{"DMIC1", NULL, "Int Mic"},
+	{"DMIC1", NULL, "Internal Mic"},
 	{"Headphone", NULL, "HPOL"},
 	{"Headphone", NULL, "HPOR"},
-	{"Ext Spk", NULL, "SPOLP"},
-	{"Ext Spk", NULL, "SPOLN"},
-	{"Ext Spk", NULL, "SPORP"},
-	{"Ext Spk", NULL, "SPORN"},
+	{"Speaker", NULL, "SPOLP"},
+	{"Speaker", NULL, "SPOLN"},
+	{"Speaker", NULL, "SPORP"},
+	{"Speaker", NULL, "SPORN"},
 };
 
-static const struct snd_kcontrol_new byt_mc_controls[] = {
+static const struct snd_kcontrol_new byt_rt5640_controls[] = {
 	SOC_DAPM_PIN_SWITCH("Headphone"),
 	SOC_DAPM_PIN_SWITCH("Headset Mic"),
-	SOC_DAPM_PIN_SWITCH("Int Mic"),
-	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+	SOC_DAPM_PIN_SWITCH("Internal Mic"),
+	SOC_DAPM_PIN_SWITCH("Speaker"),
 };
 
-static int byt_aif1_hw_params(struct snd_pcm_substream *substream,
-			     struct snd_pcm_hw_params *params)
+static int byt_rt5640_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
-	unsigned int fmt;
 	int ret;
 
-	/* I2S Slave Mode`*/
-	fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
-	      SND_SOC_DAIFMT_CBS_CFS;
-
-	/* Set codec DAI configuration */
-	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
-	if (ret < 0) {
-		dev_err(codec_dai->dev,
-			"can't set codec DAI configuration %d\n", ret);
-		return ret;
-	}
-
 	ret = snd_soc_dai_set_sysclk(codec_dai, RT5640_SCLK_S_PLL1,
 				     params_rate(params) * 256,
 				     SND_SOC_CLOCK_IN);
 	if (ret < 0) {
-		dev_err(codec_dai->dev, "Can't set codec clock %d\n", ret);
+		dev_err(codec_dai->dev, "can't set codec clock %d\n", ret);
 		return ret;
 	}
 	ret = snd_soc_dai_set_pll(codec_dai, 0, RT5640_PLL1_S_BCLK1,
@@ -89,7 +76,7 @@
 	return 0;
 }
 
-static int byt_init(struct snd_soc_pcm_runtime *runtime)
+static int byt_rt5640_init(struct snd_soc_pcm_runtime *runtime)
 {
 	int ret;
 	struct snd_soc_codec *codec = runtime->codec;
@@ -98,16 +85,13 @@
 
 	card->dapm.idle_bias_off = true;
 
-	ret = snd_soc_add_card_controls(card, byt_mc_controls,
-					ARRAY_SIZE(byt_mc_controls));
+	ret = snd_soc_add_card_controls(card, byt_rt5640_controls,
+					ARRAY_SIZE(byt_rt5640_controls));
 	if (ret) {
 		dev_err(card->dev, "unable to add card controls\n");
 		return ret;
 	}
 
-	/* Keep the voice call paths active during
-	suspend. Mark the end points ignore_suspend */
-	/*TODO: CHECK this */
 	snd_soc_dapm_ignore_suspend(dapm, "HPOL");
 	snd_soc_dapm_ignore_suspend(dapm, "HPOR");
 
@@ -118,56 +102,56 @@
 
 	snd_soc_dapm_enable_pin(dapm, "Headset Mic");
 	snd_soc_dapm_enable_pin(dapm, "Headphone");
-	snd_soc_dapm_enable_pin(dapm, "Ext Spk");
-	snd_soc_dapm_enable_pin(dapm, "Int Mic");
+	snd_soc_dapm_enable_pin(dapm, "Speaker");
+	snd_soc_dapm_enable_pin(dapm, "Internal Mic");
 
 	snd_soc_dapm_sync(dapm);
 	return ret;
 }
 
-static struct snd_soc_ops byt_aif1_ops = {
-	.hw_params = byt_aif1_hw_params,
+static struct snd_soc_ops byt_rt5640_ops = {
+	.hw_params = byt_rt5640_hw_params,
 };
 
-static struct snd_soc_dai_link byt_dailink[] = {
+static struct snd_soc_dai_link byt_rt5640_dais[] = {
 	{
 		.name = "Baytrail Audio",
 		.stream_name = "Audio",
-		.cpu_dai_name = "Front-cpu-dai",
+		.cpu_dai_name = "baytrail-pcm-audio",
 		.codec_dai_name = "rt5640-aif1",
-		.codec_name = "i2c-10EC5640:00",
+		.codec_name = "i2c-10EC5640:00:1c",
 		.platform_name = "baytrail-pcm-audio",
-		.init = byt_init,
-		.ignore_suspend = 1,
-		.ops = &byt_aif1_ops,
-	},
-	{
-		.name = "Baytrail Voice",
-		.stream_name = "Voice",
-		.cpu_dai_name = "Mic1-cpu-dai",
-		.codec_dai_name = "rt5640-aif1",
-		.codec_name = "i2c-10EC5640:00",
-		.platform_name = "baytrail-pcm-audio",
-		.init = NULL,
-		.ignore_suspend = 1,
-		.ops = &byt_aif1_ops,
+		.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+			   SND_SOC_DAIFMT_CBS_CFS,
+		.init = byt_rt5640_init,
+		.ops = &byt_rt5640_ops,
 	},
 };
 
-/* SoC card */
-static struct snd_soc_card snd_soc_card_byt = {
+static struct snd_soc_card byt_rt5640_card = {
 	.name = "byt-rt5640",
-	.dai_link = byt_dailink,
-	.num_links = ARRAY_SIZE(byt_dailink),
-	.dapm_widgets = byt_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(byt_dapm_widgets),
-	.dapm_routes = byt_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(byt_audio_map),
-};
+	.dai_link = byt_rt5640_dais,
+	.num_links = ARRAY_SIZE(byt_rt5640_dais),
+	.dapm_widgets = byt_rt5640_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(byt_rt5640_widgets),
+	.dapm_routes = byt_rt5640_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(byt_rt5640_audio_map),
+};
+
+#ifdef CONFIG_PM_SLEEP
+static const struct dev_pm_ops byt_rt5640_pm_ops = {
+	.suspend = snd_soc_suspend,
+	.resume = snd_soc_resume,
+};
+
+#define BYT_RT5640_PM_OPS	(&byt_rt5640_pm_ops)
+#else
+#define BYT_RT5640_PM_OPS	NULL
+#endif
 
-static int byt_audio_probe(struct platform_device *pdev)
+static int byt_rt5640_probe(struct platform_device *pdev)
 {
-	struct snd_soc_card *card = &snd_soc_card_byt;
+	struct snd_soc_card *card = &byt_rt5640_card;
 	struct device *dev = &pdev->dev;
 
 	card->dev = &pdev->dev;
@@ -175,7 +159,7 @@
 	return snd_soc_register_card(card);
 }
 
-static int byt_audio_remove(struct platform_device *pdev)
+static int byt_rt5640_remove(struct platform_device *pdev)
 {
 	struct snd_soc_card *card = platform_get_drvdata(pdev);
 
@@ -184,15 +168,16 @@
 	return 0;
 }
 
-static struct platform_driver byt_audio = {
-	.probe = byt_audio_probe,
-	.remove = byt_audio_remove,
+static struct platform_driver byt_rt5640_audio = {
+	.probe = byt_rt5640_probe,
+	.remove = byt_rt5640_remove,
 	.driver = {
 		.name = "byt-rt5640",
 		.owner = THIS_MODULE,
+		.pm = BYT_RT5640_PM_OPS,
 	},
 };
-module_platform_driver(byt_audio)
+module_platform_driver(byt_rt5640_audio)
 
 MODULE_DESCRIPTION("ASoC Intel(R) Baytrail Machine driver");
 MODULE_AUTHOR("Omair Md Abdullah, Jarkko Nikula");
Index: b/sound/soc/intel/sst-acpi.c
===================================================================
--- a/sound/soc/intel/sst-acpi.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-acpi.c	2016-06-02 12:28:43.393170207 +0800
@@ -16,6 +16,7 @@
 
 #include <linux/acpi.h>
 #include <linux/device.h>
+#include <linux/firmware.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 
@@ -25,9 +26,20 @@
 #define SST_WPT_DSP_DMA_ADDR_OFFSET	0x0FE000
 #define SST_LPT_DSP_DMA_SIZE		(1024 - 1)
 
+/* Descriptor for SST ASoC machine driver */
+struct sst_acpi_mach {
+	/* ACPI ID for the matching machine driver. Audio codec for instance */
+	const u8 id[ACPI_ID_LEN];
+	/* machine driver name */
+	const char *drv_name;
+	/* firmware file name */
+	const char *fw_filename;
+};
+
 /* Descriptor for setting up SST platform data */
 struct sst_acpi_desc {
 	const char *drv_name;
+	struct sst_acpi_mach *machines;
 	/* Platform resource indexes. Must set to -1 if not used */
 	int resindex_lpe_base;
 	int resindex_pcicfg_base;
@@ -36,26 +48,68 @@
 	int resindex_dma_base;
 	/* Unique number identifying the SST core on platform */
 	int sst_id;
-	/* firmware file name */
-	const char *fw_filename;
 	/* DMA only valid when resindex_dma_base != -1*/
 	int dma_engine;
 	int dma_size;
 };
 
-/* Descriptor for SST ASoC machine driver */
-struct sst_acpi_mach {
-	const char *drv_name;
-	struct sst_acpi_desc *res_desc;
-};
-
 struct sst_acpi_priv {
 	struct platform_device *pdev_mach;
 	struct platform_device *pdev_pcm;
 	struct sst_pdata sst_pdata;
 	struct sst_acpi_desc *desc;
+	struct sst_acpi_mach *mach;
 };
 
+static void sst_acpi_fw_cb(const struct firmware *fw, void *context)
+{
+	struct platform_device *pdev = context;
+	struct device *dev = &pdev->dev;
+	struct sst_acpi_priv *sst_acpi = platform_get_drvdata(pdev);
+	struct sst_pdata *sst_pdata = &sst_acpi->sst_pdata;
+	struct sst_acpi_desc *desc = sst_acpi->desc;
+	struct sst_acpi_mach *mach = sst_acpi->mach;
+
+	sst_pdata->fw = fw;
+	if (!fw) {
+		dev_err(dev, "Cannot load firmware %s\n", mach->fw_filename);
+		return;
+	}
+
+	/* register PCM and DAI driver */
+	sst_acpi->pdev_pcm =
+		platform_device_register_data(dev, desc->drv_name, -1,
+					      sst_pdata, sizeof(*sst_pdata));
+	if (IS_ERR(sst_acpi->pdev_pcm)) {
+		dev_err(dev, "Cannot register device %s. Error %d\n",
+			desc->drv_name, (int)PTR_ERR(sst_acpi->pdev_pcm));
+	}
+
+	return;
+}
+
+static acpi_status sst_acpi_mach_match(acpi_handle handle, u32 level,
+				       void *context, void **ret)
+{
+	*(bool *)context = true;
+	return AE_OK;
+}
+
+static struct sst_acpi_mach *sst_acpi_find_machine(
+	struct sst_acpi_mach *machines)
+{
+	struct sst_acpi_mach *mach;
+	bool found = false;
+
+	for (mach = machines; mach->id[0]; mach++)
+		if (ACPI_SUCCESS(acpi_get_devices(mach->id,
+						  sst_acpi_mach_match,
+						  &found, NULL)) && found)
+			return mach;
+
+	return NULL;
+}
+
 static int sst_acpi_probe(struct platform_device *pdev)
 {
 	const struct acpi_device_id *id;
@@ -75,12 +129,17 @@
 	if (!id)
 		return -ENODEV;
 
-	mach = (struct sst_acpi_mach *)id->driver_data;
-	desc = mach->res_desc;
+	desc = (struct sst_acpi_desc *)id->driver_data;
+	mach = sst_acpi_find_machine(desc->machines);
+	if (mach == NULL) {
+		dev_err(dev, "No matching ASoC machine driver found\n");
+		return -ENODEV;
+	}
+
 	sst_pdata = &sst_acpi->sst_pdata;
 	sst_pdata->id = desc->sst_id;
-	sst_pdata->fw_filename = desc->fw_filename;
 	sst_acpi->desc = desc;
+	sst_acpi->mach = mach;
 
 	if (desc->resindex_dma_base >= 0) {
 		sst_pdata->dma_engine = desc->dma_engine;
@@ -118,97 +177,94 @@
 		}
 	}
 
-	/* register PCM and DAI driver */
-	sst_acpi->pdev_pcm =
-		platform_device_register_data(dev, desc->drv_name, -1,
-					      sst_pdata, sizeof(*sst_pdata));
-	if (IS_ERR(sst_acpi->pdev_pcm))
-		return PTR_ERR(sst_acpi->pdev_pcm);
-
-	/* register machine driver */
 	platform_set_drvdata(pdev, sst_acpi);
 
+	/* register machine driver */
 	sst_acpi->pdev_mach =
 		platform_device_register_data(dev, mach->drv_name, -1,
 					      sst_pdata, sizeof(*sst_pdata));
-	if (IS_ERR(sst_acpi->pdev_mach)) {
-		ret = PTR_ERR(sst_acpi->pdev_mach);
-		goto sst_err;
-	}
+	if (IS_ERR(sst_acpi->pdev_mach))
+		return PTR_ERR(sst_acpi->pdev_mach);
 
-	return ret;
+	/* continue SST probing after firmware is loaded */
+	ret = request_firmware_nowait(THIS_MODULE, true, mach->fw_filename,
+				      dev, GFP_KERNEL, pdev, sst_acpi_fw_cb);
+	if (ret)
+		platform_device_unregister(sst_acpi->pdev_mach);
 
-sst_err:
-	platform_device_unregister(sst_acpi->pdev_pcm);
 	return ret;
 }
 
 static int sst_acpi_remove(struct platform_device *pdev)
 {
 	struct sst_acpi_priv *sst_acpi = platform_get_drvdata(pdev);
+	struct sst_pdata *sst_pdata = &sst_acpi->sst_pdata;
 
 	platform_device_unregister(sst_acpi->pdev_mach);
-	platform_device_unregister(sst_acpi->pdev_pcm);
+	if (!IS_ERR_OR_NULL(sst_acpi->pdev_pcm))
+		platform_device_unregister(sst_acpi->pdev_pcm);
+	release_firmware(sst_pdata->fw);
 
 	return 0;
 }
 
+static struct sst_acpi_mach haswell_machines[] = {
+	{ "INT33CA", "haswell-audio", "intel/IntcSST1.bin" },
+	{}
+};
+
 static struct sst_acpi_desc sst_acpi_haswell_desc = {
 	.drv_name = "haswell-pcm-audio",
+	.machines = haswell_machines,
 	.resindex_lpe_base = 0,
 	.resindex_pcicfg_base = 1,
 	.resindex_fw_base = -1,
 	.irqindex_host_ipc = 0,
 	.sst_id = SST_DEV_ID_LYNX_POINT,
-	.fw_filename = "IntcSST1.bin",
 	.dma_engine = SST_DMA_TYPE_DW,
 	.resindex_dma_base = SST_LPT_DSP_DMA_ADDR_OFFSET,
 	.dma_size = SST_LPT_DSP_DMA_SIZE,
 };
 
+static struct sst_acpi_mach broadwell_machines[] = {
+	{ "INT343A", "broadwell-audio", "intel/IntcSST2.bin" },
+	{}
+};
+
 static struct sst_acpi_desc sst_acpi_broadwell_desc = {
 	.drv_name = "haswell-pcm-audio",
+	.machines = broadwell_machines,
 	.resindex_lpe_base = 0,
 	.resindex_pcicfg_base = 1,
 	.resindex_fw_base = -1,
 	.irqindex_host_ipc = 0,
 	.sst_id = SST_DEV_ID_WILDCAT_POINT,
-	.fw_filename = "IntcSST2.bin",
 	.dma_engine = SST_DMA_TYPE_DW,
 	.resindex_dma_base = SST_WPT_DSP_DMA_ADDR_OFFSET,
 	.dma_size = SST_LPT_DSP_DMA_SIZE,
 };
 
+static struct sst_acpi_mach baytrail_machines[] = {
+	{ "10EC5640", "byt-rt5640", "intel/fw_sst_0f28.bin-i2s_master" },
+	{ "193C9890", "byt-max98090", "intel/fw_sst_0f28.bin-i2s_master" },
+	{}
+};
+
 static struct sst_acpi_desc sst_acpi_baytrail_desc = {
 	.drv_name = "baytrail-pcm-audio",
+	.machines = baytrail_machines,
 	.resindex_lpe_base = 0,
 	.resindex_pcicfg_base = 1,
 	.resindex_fw_base = 2,
 	.irqindex_host_ipc = 5,
 	.sst_id = SST_DEV_ID_BYT,
-	.fw_filename = "intel/fw_sst_0f28.bin-i2s_master",
 	.resindex_dma_base = -1,
 };
 
-static struct sst_acpi_mach haswell_mach = {
-	.drv_name = "haswell-audio",
-	.res_desc = &sst_acpi_haswell_desc,
-};
-
-static struct sst_acpi_mach broadwell_mach = {
-	.drv_name = "broadwell-audio",
-	.res_desc = &sst_acpi_broadwell_desc,
-};
-
-static struct sst_acpi_mach byt_rt5640 = {
-	.drv_name = "byt-rt5640",
-	.res_desc = &sst_acpi_baytrail_desc,
-};
-
 static struct acpi_device_id sst_acpi_match[] = {
-	{ "INT33C8", (unsigned long)&haswell_mach },
-	{ "INT3438", (unsigned long)&broadwell_mach },
-	{ "80860F28", (unsigned long)&byt_rt5640 },
+	{ "INT33C8", (unsigned long)&sst_acpi_haswell_desc },
+	{ "INT3438", (unsigned long)&sst_acpi_broadwell_desc },
+	{ "80860F28", (unsigned long)&sst_acpi_baytrail_desc },
 	{ }
 };
 MODULE_DEVICE_TABLE(acpi, sst_acpi_match);
Index: b/sound/soc/intel/sst-baytrail-dsp.c
===================================================================
--- a/sound/soc/intel/sst-baytrail-dsp.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-baytrail-dsp.c	2016-06-02 12:28:43.393170207 +0800
@@ -12,6 +12,7 @@
  * more details.
  */
 
+#include <linux/acpi.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
@@ -47,7 +48,7 @@
 };
 
 struct fw_header {
-	unsigned char signature[SST_BYT_FW_SIGNATURE_SIZE]; /* FW signature */
+	unsigned char signature[SST_BYT_FW_SIGNATURE_SIZE];
 	u32 file_size; /* size of fw minus this header */
 	u32 modules; /*  # of modules */
 	u32 file_format; /* version of header format */
@@ -55,67 +56,13 @@
 };
 
 struct sst_byt_fw_module_header {
-	unsigned char signature[SST_BYT_FW_SIGNATURE_SIZE]; /* module signature */
+	unsigned char signature[SST_BYT_FW_SIGNATURE_SIZE];
 	u32 mod_size; /* size of module */
 	u32 blocks; /* # of blocks */
 	u32 type; /* codec type, pp lib */
 	u32 entry_point;
 };
 
-/* Internal Generic SST IO functions - can be overidden */
-void shim_write(void __iomem *addr, u32 offset, u32 value)
-{
-	writel(value, addr + offset);
-}
-
-u32 shim_read(void __iomem *addr, u32 offset)
-{
-	return readl(addr + offset);
-}
-
-void shim_write64(void __iomem *addr, u32 offset, u64 value)
-{
-	memcpy_toio(addr + offset, &value, sizeof(value));
-}
-
-u64 shim_read64(void __iomem *addr, u32 offset)
-{
-	u64 val;
-
-	memcpy_fromio(&val, addr + offset, sizeof(val));
-	return val;
-}
-
-static inline void _sst_memcpy_toio_32(volatile u32 __iomem *dest,
-	u32 *src, size_t bytes)
-{
-	int i, words = bytes >> 2;
-
-	for (i = 0; i < words; i++)
-		writel(src[i], dest + i);
-}
-
-static inline void _sst_memcpy_fromio_32(u32 *dest,
-	const volatile __iomem u32 *src, size_t bytes)
-{
-	int i, words = bytes >> 2;
-
-	for (i = 0; i < words; i++)
-		dest[i] = readl(src + i);
-}
-
-void sst_memcpy_toio_32(struct sst_dsp *sst,
-	void __iomem *dest, void *src, size_t bytes)
-{
-	_sst_memcpy_toio_32(dest, src, bytes);
-}
-
-void sst_memcpy_fromio_32(struct sst_dsp *sst, void *dest,
-	void __iomem *src, size_t bytes)
-{
-	_sst_memcpy_fromio_32(dest, src, bytes);
-}
-
 static int sst_byt_parse_module(struct sst_dsp *dsp, struct sst_fw *fw,
 				struct sst_byt_fw_module_header *module)
 {
@@ -216,7 +163,7 @@
 	return 0;
 }
 
-static void sst_byt_dump_shim(struct sst_dsp *sst)
+void sst_byt_dump_shim(struct sst_dsp *sst)
 {
 	int i;
 	u64 reg;
@@ -245,6 +192,7 @@
 	spin_lock(&sst->spinlock);
 
 	isrx = sst_dsp_shim_read64_unlocked(sst, SST_ISRX);
+
 	if (isrx & SST_ISRX_DONE) {
 		/* ADSP has processed the message request from IA */
 		sst_dsp_shim_update_bits64_unlocked(sst, SST_IPCX,
@@ -268,6 +216,13 @@
 {
 	int tries = 10;
 
+	/*
+	 * save the physical address of extended firmware block in the first
+	 * 4 bytes of the mailbox
+	 */
+	memcpy_toio(sst->addr.lpe + SST_BYT_MAILBOX_OFFSET,
+	       &sst->pdata->fw_base, sizeof(u32));
+
 	/* release stall and wait to unstall */
 	sst_dsp_shim_update_bits64(sst, SST_CSR, SST_BYT_CSR_STALL, 0x0);
 	while (tries--) {
@@ -284,11 +239,19 @@
 
 static void sst_byt_reset(struct sst_dsp *sst)
 {
-	/* put DSP into reset, set reset vector and stall */
+	/* set reset vector and stall */
+	sst_dsp_shim_update_bits64(sst, SST_CSR,
+		SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL,
+		SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL);
+
+	udelay(10);
+
+	/* put DSP into reset */
 	sst_dsp_shim_update_bits64(sst, SST_CSR,
-		SST_BYT_CSR_RST | SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL,
-		SST_BYT_CSR_RST | SST_BYT_CSR_VECTOR_SEL | SST_BYT_CSR_STALL);
+		SST_BYT_CSR_RST, SST_BYT_CSR_RST);
 
+	/* dummy read to make sure clock is ungated */
+	sst_dsp_shim_read64_unlocked(sst, SST_IPCD);
 	udelay(10);
 
 	/* take DSP out of reset and keep stalled for FW loading */
@@ -343,6 +306,31 @@
 	return 0;
 }
 
+static int byt_enable_shim(struct sst_dsp *sst)
+{
+	/* enable shim - do dummy read */
+	writel(0, sst->addr.pci_cfg + 0x84);
+	dev_err(sst->dev, "PMCS read 0x%x\n", readl(sst->addr.pci_cfg + 0x84));
+
+	/* make sure that ADSP shim is enabled */
+	mdelay(11);
+
+	/* enable Interrupt from both sides */
+	sst_dsp_shim_update_bits64(sst, SST_IMRX, 0x3, 0x0);
+	sst_dsp_shim_update_bits64(sst, SST_IMRD, 0x3, 0x0);
+
+	sst_dsp_shim_update_bits64(sst, 0x10, 0x20, 0x0); // unMask SSP2
+	sst_dsp_shim_update_bits64(sst, 0x78, 0x7, 0x5); // 200MHz
+
+	sst_byt_dump_shim(sst);
+	return 0;
+}
+
+int sst_byt_d0(struct sst_dsp *sst)
+{
+	return byt_enable_shim(sst);
+}
+
 static int sst_byt_init(struct sst_dsp *sst, struct sst_pdata *pdata)
 {
 	const struct sst_adsp_memregion *region;
@@ -371,12 +359,7 @@
 		return ret;
 	}
 
-	/*
-	 * save the physical address of extended firmware block in the first
-	 * 4 bytes of the mailbox
-	 */
-	memcpy(sst->addr.lpe + SST_BYT_MAILBOX_OFFSET,
-	       &pdata->fw_base, sizeof(u32));
+	sst_byt_d0(sst);
 
 	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
 	if (ret)
@@ -386,7 +369,7 @@
 	sst_dsp_shim_update_bits64(sst, SST_IMRX, 0x3, 0x0);
 	sst_dsp_shim_update_bits64(sst, SST_IMRD, 0x3, 0x0);
 
-	/* register the DSP memory blocks - ideally we should get this from ACPI */
+	/* register DSP memory blocks - ideally we should get this from ACPI */
 	for (i = 0; i < region_count; i++) {
 		offset = region[i].start;
 		size = (region[i].end - region[i].start) / region[i].blocks;
@@ -413,14 +396,15 @@
 struct sst_ops sst_byt_ops = {
 	.reset = sst_byt_reset,
 	.boot = sst_byt_boot,
-	.write = shim_write,
-	.read = shim_read,
-	.write64 = shim_write64,
-	.read64 = shim_read64,
+	.write = sst_shim32_write,
+	.read = sst_shim32_read,
+	.write64 = sst_shim32_write64,
+	.read64 = sst_shim32_read64,
 	.ram_read = sst_memcpy_fromio_32,
 	.ram_write = sst_memcpy_toio_32,
 	.irq_handler = sst_byt_irq,
 	.init = sst_byt_init,
 	.free = sst_byt_free,
 	.parse_fw = sst_byt_parse_fw_image,
+	.dump = sst_byt_dump_shim,
 };
Index: b/sound/soc/intel/sst-baytrail-ipc.c
===================================================================
--- a/sound/soc/intel/sst-baytrail-ipc.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-baytrail-ipc.c	2016-06-02 12:28:43.393170207 +0800
@@ -69,7 +69,7 @@
 struct sst_byt_address_info {
 	u32 addr;
 	u32 size;
-} __attribute__((packed));
+} __packed;
 
 struct sst_byt_str_type {
 	u8 codec_type;
@@ -79,7 +79,7 @@
 	u8 time_slots;
 	u8 reserved;
 	u16 result;
-} __attribute__((packed));
+} __packed;
 
 struct sst_byt_pcm_params {
 	u8 num_chan;
@@ -88,29 +88,29 @@
 	u8 reserved;
 	u32 sfreq;
 	u8 channel_map[8];
-} __attribute__((packed));
+} __packed;
 
 struct sst_byt_frames_info {
 	u16 num_entries;
 	u16 rsrvd;
 	u32 frag_size;
 	struct sst_byt_address_info ring_buf_info[8];
-} __attribute__((packed));
+} __packed;
 
 struct sst_byt_alloc_params {
 	struct sst_byt_str_type str_type;
 	struct sst_byt_pcm_params pcm_params;
 	struct sst_byt_frames_info frame_info;
-} __attribute__((packed));
+} __packed;
 
 struct sst_byt_alloc_response {
 	struct sst_byt_str_type str_type;
 	u8 reserved[88];
-} __attribute__((packed));
+} __packed;
 
 struct sst_byt_start_stream_params {
 	u32 byte_offset;
-} __attribute__((packed));
+} __packed;
 
 struct sst_byt_tstamp {
 	u64 ring_buffer_counter;
@@ -120,7 +120,27 @@
 	u64 bytes_copied;
 	u32 sampling_frequency;
 	u32 channel_peak[8];
-} __attribute__((packed));
+} __packed;
+
+struct sst_byt_fw_version {
+	u8 build;
+	u8 minor;
+	u8 major;
+	u8 type;
+} __packed;
+
+struct sst_byt_fw_build_info {
+	unsigned char date[16];
+	unsigned char time[16];
+} __packed;
+
+struct sst_byt_fw_init {
+	struct sst_byt_fw_version fw_version;
+	struct sst_byt_fw_build_info build_info;
+	u16 result;
+	u8 module_id;
+	u8 debug_info;
+} __packed;
 
 /* driver internal IPC message structure */
 struct ipc_message {
@@ -145,6 +165,7 @@
 /* stream infomation */
 struct sst_byt_stream {
 	struct list_head node;
+	struct work_struct notify_work;
 
 	/* configuration */
 	struct sst_byt_alloc_params request;
@@ -155,6 +176,7 @@
 	int str_id;
 	bool commited;
 	bool running;
+	u32 start_offset;
 
 	/* driver callback */
 	u32 (*notify_position)(struct sst_byt_stream *stream, void *data);
@@ -172,6 +194,7 @@
 	/* boot */
 	wait_queue_head_t boot_wait;
 	bool boot_complete;
+	struct sst_fw *fw;
 
 	/* IPC messaging */
 	struct list_head tx_list;
@@ -182,6 +205,11 @@
 	struct kthread_worker kworker;
 	struct kthread_work kwork;
 	struct ipc_message *msg;
+
+	/* can be used to notfy that LRCLK and BCLK have started */
+	void (*notify_start)(struct sst_dsp *dsp, void *);
+	void (*notify_stop)(struct sst_dsp *dsp, void *);
+	void *notify_data;
 };
 
 static inline u64 sst_byt_header(int msg_id, int data, bool large, int str_id)
@@ -209,7 +237,7 @@
 
 static inline u16 sst_byt_header_data(u64 header)
 {
-	return ((header >> IPC_HEADER_DATA_SHIFT) & IPC_HEADER_DATA_MASK);
+	return (header >> IPC_HEADER_DATA_SHIFT) & IPC_HEADER_DATA_MASK;
 }
 
 static struct sst_byt_stream *sst_byt_get_stream(struct sst_byt *byt,
@@ -292,15 +320,32 @@
 {
 	msg->complete = true;
 
-	if (!msg->wait) {
+	if (!msg->wait)
 		list_add_tail(&msg->list, &byt->empty_list);
-	} else {
+	else
 		wake_up(&msg->waitq);
+}
+
+static void sst_byt_drop_all(struct sst_byt *byt)
+{
+	struct ipc_message *msg, *tmp;
+	unsigned long flags;
+
+	/* drop all TX and Rx messages before we stall + reset DSP */
+	spin_lock_irqsave(&byt->dsp->spinlock, flags);
+	list_for_each_entry_safe(msg, tmp, &byt->tx_list, list) {
+		list_move(&msg->list, &byt->empty_list);
 	}
+
+	list_for_each_entry_safe(msg, tmp, &byt->rx_list, list) {
+		list_move(&msg->list, &byt->empty_list);
+	}
+
+	spin_unlock_irqrestore(&byt->dsp->spinlock, flags);
 }
 
 static int sst_byt_tx_wait_done(struct sst_byt *byt, struct ipc_message *msg,
-			        void *rx_data)
+				void *rx_data)
 {
 	unsigned long flags;
 	int ret;
@@ -383,7 +428,8 @@
 				      NULL, 0, 0);
 }
 
-static struct ipc_message *sst_byt_reply_find_msg(struct sst_byt *byt, u64 header)
+static struct ipc_message *sst_byt_reply_find_msg(struct sst_byt *byt,
+						  u64 header)
 {
 	struct ipc_message *msg = NULL, *_msg;
 	u64 mask;
@@ -410,6 +456,21 @@
 	return msg;
 }
 
+static void sst_byt_notify_work(struct work_struct *work)
+{
+	struct sst_byt_stream *stream =
+		container_of(work, struct sst_byt_stream, notify_work);
+	struct sst_byt *byt  = stream->byt;
+
+	if (stream->running) {
+		if (byt->notify_start)
+			byt->notify_start(byt->dsp, byt->notify_data);
+	} else {
+		if (byt->notify_stop)
+			byt->notify_stop(byt->dsp, byt->notify_data);
+	}
+}
+
 static void sst_byt_stream_update(struct sst_byt *byt, struct ipc_message *msg)
 {
 	struct sst_byt_stream *stream;
@@ -426,10 +487,12 @@
 	case IPC_IA_PAUSE_STREAM:
 	case IPC_IA_FREE_STREAM:
 		stream->running = false;
+		schedule_work(&stream->notify_work);
 		break;
 	case IPC_IA_START_STREAM:
 	case IPC_IA_RESUME_STREAM:
 		stream->running = true;
+		schedule_work(&stream->notify_work);
 		break;
 	}
 }
@@ -481,10 +544,11 @@
 	case IPC_SST_PERIOD_ELAPSED:
 		stream_id = sst_byt_header_str_id(header);
 		stream = sst_byt_get_stream(byt, stream_id);
-		spin_unlock_irqrestore(&sst->spinlock, *flags);
-		if (stream && stream->running && stream->notify_position)
+		if (stream && stream->running && stream->notify_position) {
+			spin_unlock_irqrestore(&sst->spinlock, *flags);
 			stream->notify_position(stream, stream->pdata);
-		spin_lock_irqsave(&sst->spinlock, *flags);
+			spin_lock_irqsave(&sst->spinlock, *flags);
+		}
 		break;
 	case IPC_IA_FW_INIT_CMPLT:
 		sst_byt_fw_ready(byt, header);
@@ -546,6 +610,7 @@
 		return NULL;
 
 	list_add(&stream->node, &byt->stream_list);
+	INIT_WORK(&stream->notify_work, sst_byt_notify_work);
 	stream->notify_position = notify_position;
 	stream->pdata = data;
 	stream->byt = byt;
@@ -575,6 +640,13 @@
 	return 0;
 }
 
+int sst_byt_stream_set_offset(struct sst_byt *byt,
+	struct sst_byt_stream *stream, u32 offset)
+{
+	stream->start_offset = offset;
+	return 0;
+}
+
 /* stream sonfiguration */
 int sst_byt_stream_type(struct sst_byt *byt, struct sst_byt_stream *stream,
 			int codec_type, int stream_type, int operation)
@@ -642,6 +714,7 @@
 
 	stream->commited = false;
 out:
+	cancel_work_sync(&stream->notify_work);
 	list_del(&stream->node);
 	kfree(stream);
 
@@ -649,7 +722,7 @@
 }
 
 static int sst_byt_stream_operations(struct sst_byt *byt, int type,
-				     int stream_id, int wait)
+				    struct sst_byt_stream *stream, int wait)
 {
 	struct sst_byt_start_stream_params start_stream;
 	u64 header;
@@ -657,18 +730,19 @@
 	size_t size = 0;
 
 	if (type != IPC_IA_START_STREAM) {
-		header = sst_byt_header(type, 0, false, stream_id);
+		header = sst_byt_header(type, 0, false, stream->str_id);
 	} else {
-		start_stream.byte_offset = 0;
+		start_stream.byte_offset = stream->start_offset;
 		header = sst_byt_header(IPC_IA_START_STREAM,
 					sizeof(start_stream) + sizeof(u32),
-					true, stream_id);
+					true, stream->str_id);
 		tx_msg = &start_stream;
 		size = sizeof(start_stream);
 	}
 
 	if (wait)
-		return sst_byt_ipc_tx_msg_wait(byt, header, tx_msg, size, NULL, 0);
+		return sst_byt_ipc_tx_msg_wait(byt, header,
+					       tx_msg, size, NULL, 0);
 	else
 		return sst_byt_ipc_tx_msg_nowait(byt, header, tx_msg, size);
 }
@@ -678,12 +752,13 @@
 {
 	int ret;
 
-	ret = sst_byt_stream_operations(byt, IPC_IA_START_STREAM,
-					stream->str_id, 0);
+	ret = sst_byt_stream_operations(byt, IPC_IA_START_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to start stream %d\n",
 			stream->str_id);
 
+	/* reset start offset */
+	stream->start_offset = 0;
 	return ret;
 }
 
@@ -695,8 +770,7 @@
 	if (!stream->commited)
 		return 0;
 
-	ret = sst_byt_stream_operations(byt, IPC_IA_DROP_STREAM,
-					stream->str_id, 0);
+	ret = sst_byt_stream_operations(byt, IPC_IA_DROP_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to stop stream %d\n",
 			stream->str_id);
@@ -707,8 +781,7 @@
 {
 	int ret;
 
-	ret = sst_byt_stream_operations(byt, IPC_IA_PAUSE_STREAM,
-					stream->str_id, 0);
+	ret = sst_byt_stream_operations(byt, IPC_IA_PAUSE_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to pause stream %d\n",
 			stream->str_id);
@@ -720,8 +793,7 @@
 {
 	int ret;
 
-	ret = sst_byt_stream_operations(byt, IPC_IA_RESUME_STREAM,
-					stream->str_id, 0);
+	ret = sst_byt_stream_operations(byt, IPC_IA_RESUME_STREAM, stream, 0);
 	if (ret < 0)
 		dev_err(byt->dev, "ipc: error failed to resume stream %d\n",
 			stream->str_id);
@@ -775,7 +847,7 @@
 {
 	struct sst_byt *byt;
 	struct sst_fw *byt_sst_fw;
-	const struct firmware *fw;
+	struct sst_byt_fw_init init;
 	int err;
 
 	dev_dbg(dev, "initialising Byt DSP IPC\n");
@@ -794,7 +866,7 @@
 
 	err = msg_empty_list_init(byt);
 	if (err < 0)
-		goto list_err;
+		return err;
 
 	/* start the IPC message thread */
 	init_kthread_worker(&byt->kworker);
@@ -802,8 +874,9 @@
 				     &byt->kworker,
 				     dev_name(byt->dev));
 	if (IS_ERR(byt->tx_thread)) {
+		err = PTR_ERR(byt->tx_thread);
 		dev_err(byt->dev, "error failed to create message TX task\n");
-		goto list_err;
+		goto thread_err;
 	}
 	init_kthread_work(&byt->kwork, sst_byt_ipc_tx_msgs);
 
@@ -811,21 +884,17 @@
 
 	/* init SST shim */
 	byt->dsp = sst_dsp_new(dev, &byt_dev, pdata);
-	if (byt->dsp == NULL)
-		goto list_err;
-
-	/* load DSP FW */
-	err = request_firmware(&fw, pdata->fw_filename, dev);
-	if (err < 0) {
-		dev_err(dev, "request fw failed %d\n", err);
-		goto fw_err;
+	if (byt->dsp == NULL) {
+		err = -ENODEV;
+		goto thread_err;
 	}
 
 	/* keep the DSP in reset state for base FW loading */
 	sst_dsp_reset(byt->dsp);
 
-	byt_sst_fw = sst_fw_new(byt->dsp, fw, byt);
+	byt_sst_fw = sst_fw_new(byt->dsp, pdata->fw, byt);
 	if (byt_sst_fw  == NULL) {
+		err = -ENODEV;
 		dev_err(dev, "error: failed to load firmware\n");
 		goto fw_err;
 	}
@@ -835,11 +904,22 @@
 	err = wait_event_timeout(byt->boot_wait, byt->boot_complete,
 				 msecs_to_jiffies(IPC_BOOT_MSECS));
 	if (err == 0) {
+		err = -EIO;
 		dev_err(byt->dev, "ipc: error DSP boot timeout\n");
 		goto boot_err;
 	}
 
+	/* show firmware information */
+	sst_dsp_inbox_read(byt->dsp, &init, sizeof(init));
+	dev_info(byt->dev, "FW version: %02x.%02x.%02x.%02x\n",
+		 init.fw_version.major, init.fw_version.minor,
+		 init.fw_version.build, init.fw_version.type);
+	dev_info(byt->dev, "Build type: %x\n", init.fw_version.type);
+	dev_info(byt->dev, "Build date: %s %s\n",
+		 init.build_info.date, init.build_info.time);
+
 	pdata->dsp = byt;
+	byt->fw = byt_sst_fw;
 
 	return 0;
 
@@ -848,9 +928,8 @@
 	sst_fw_free(byt_sst_fw);
 fw_err:
 	sst_dsp_free(byt->dsp);
+thread_err:
 	kfree(byt->msg);
-list_err:
-	kfree(byt);
 	return err;
 }
 EXPORT_SYMBOL_GPL(sst_byt_dsp_init);
@@ -865,3 +944,91 @@
 	kfree(byt->msg);
 }
 EXPORT_SYMBOL_GPL(sst_byt_dsp_free);
+
+/* IRQs must be off here */
+int sst_byt_dsp_suspend_noirq(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+
+	dev_dbg(byt->dev, "dsp reset\n");
+	sst_dsp_reset(byt->dsp);
+	sst_byt_drop_all(byt);
+	dev_dbg(byt->dev, "dsp in reset\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_suspend_noirq);
+
+int sst_byt_d0(struct sst_dsp *sst);
+
+int sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+
+	dev_dbg(byt->dev, "free all blocks and unload fw\n");
+	sst_fw_unload(byt->fw);
+	
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_suspend_late);
+
+int sst_byt_dsp_boot(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+	int ret;
+
+	ret = sst_byt_d0(byt->dsp);
+	if (ret < 0) {
+		dev_err(dev, "cannot wake SHIM up\n");
+		return ret;
+	}
+
+	dev_dbg(byt->dev, "reload dsp fw\n");
+
+	sst_dsp_reset(byt->dsp);
+
+	ret = sst_fw_reload(byt->fw);
+	if (ret <  0) {
+		dev_err(dev, "error: failed to reload firmware\n");
+		return ret;
+	}
+
+	/* wait for DSP boot completion */
+	byt->boot_complete = false;
+	sst_dsp_boot(byt->dsp);
+	dev_dbg(byt->dev, "dsp booting...\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_boot);
+
+int sst_byt_dsp_wait_for_ready(struct device *dev, struct sst_pdata *pdata)
+{
+	struct sst_byt *byt = pdata->dsp;
+	int err;
+
+	dev_dbg(byt->dev, "wait for dsp reboot\n");
+
+	err = wait_event_timeout(byt->boot_wait, byt->boot_complete,
+				 msecs_to_jiffies(IPC_BOOT_MSECS));
+	if (err == 0) {
+		dev_err(byt->dev, "ipc: error DSP boot timeout\n");
+		return -EIO;
+	}
+
+	dev_dbg(byt->dev, "dsp rebooted\n");
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_byt_dsp_wait_for_ready);
+
+void sst_byt_register_notifier(struct device *dev, struct sst_pdata *pdata,
+	void (*start)(struct sst_dsp *, void *),
+	void (*stop)(struct sst_dsp *, void *), void *data)
+{
+	struct sst_byt *byt = pdata->dsp;
+
+	byt->notify_start = start;
+	byt->notify_stop = stop;
+	byt->notify_data = data;
+}
+EXPORT_SYMBOL_GPL(sst_byt_register_notifier);
Index: b/sound/soc/intel/sst-baytrail-ipc.h
===================================================================
--- a/sound/soc/intel/sst-baytrail-ipc.h	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-baytrail-ipc.h	2016-06-02 12:28:43.393170207 +0800
@@ -34,7 +34,8 @@
 
 /* stream API */
 struct sst_byt_stream *sst_byt_stream_new(struct sst_byt *byt, int id,
-	uint32_t (*get_write_position)(struct sst_byt_stream *stream, void *data),
+	uint32_t (*get_write_position)(struct sst_byt_stream *stream,
+				       void *data),
 	void *data);
 
 /* stream configuration */
@@ -50,6 +51,8 @@
 			  uint32_t buffer_addr, uint32_t buffer_size);
 int sst_byt_stream_commit(struct sst_byt *byt, struct sst_byt_stream *stream);
 int sst_byt_stream_free(struct sst_byt *byt, struct sst_byt_stream *stream);
+int sst_byt_stream_set_offset(struct sst_byt *byt,
+	struct sst_byt_stream *stream, u32 offset);
 
 /* stream ALSA trigger operations */
 int sst_byt_stream_start(struct sst_byt *byt, struct sst_byt_stream *stream);
@@ -64,5 +67,9 @@
 int sst_byt_dsp_init(struct device *dev, struct sst_pdata *pdata);
 void sst_byt_dsp_free(struct device *dev, struct sst_pdata *pdata);
 struct sst_dsp *sst_byt_get_dsp(struct sst_byt *byt);
+int sst_byt_dsp_suspend_noirq(struct device *dev, struct sst_pdata *pdata);
+int sst_byt_dsp_suspend_late(struct device *dev, struct sst_pdata *pdata);
+int sst_byt_dsp_boot(struct device *dev, struct sst_pdata *pdata);
+int sst_byt_dsp_wait_for_ready(struct device *dev, struct sst_pdata *pdata);
 
 #endif
Index: b/sound/soc/intel/sst-baytrail-pcm.c
===================================================================
--- a/sound/soc/intel/sst-baytrail-pcm.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-baytrail-pcm.c	2016-06-02 12:28:43.393170207 +0800
@@ -45,6 +45,15 @@
 	struct sst_byt_stream *stream;
 	struct snd_pcm_substream *substream;
 	struct mutex mutex;
+
+	/* DSP suspend context */
+	u32 suspend_offset;
+
+	struct work_struct work;
+
+	bool resume;
+	bool resume_stop;
+	bool xrun;
 };
 
 /* private data for the driver */
@@ -52,8 +61,8 @@
 	/* runtime DSP */
 	struct sst_byt *byt;
 
-	/* DAI data */
-	struct sst_byt_pcm_data pcm[BYT_PCM_COUNT];
+	/* DAI data per stream direction */
+	struct sst_byt_pcm_data pcm[2];
 };
 
 /* this may get called several times by oss emulation */
@@ -63,7 +72,8 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct sst_byt_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sst_byt_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
+	struct sst_byt_pcm_data *pcm_data =
+		&pdata->pcm[substream->stream];
 	struct sst_byt *byt = pdata->byt;
 	u32 rate, bits;
 	u8 channels;
@@ -130,28 +140,91 @@
 	return 0;
 }
 
+static int sst_byt_pcm_restore_stream_context(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct sst_byt_priv_data *pdata =
+		snd_soc_platform_get_drvdata(rtd->platform);
+	struct sst_byt_pcm_data *pcm_data =
+		&pdata->pcm[substream->stream];
+	struct sst_byt *byt = pdata->byt;
+	int ret;
+
+	/* commit stream using existing stream params */
+	ret = sst_byt_stream_commit(byt, pcm_data->stream);
+	if (ret < 0) {
+		dev_err(rtd->dev, "PCM: failed stream commit %d\n", ret);
+		return ret;
+	}
+
+	/* set stream position to last offset */
+	ret =  sst_byt_stream_set_offset(byt, pcm_data->stream,
+		pcm_data->suspend_offset);
+	if (ret < 0) {
+		dev_err(rtd->dev, "PCM: failed stream offset %d\n", ret);
+		return ret;
+	}
+
+	sst_byt_stream_start(byt, pcm_data->stream);
+	pcm_data->resume = false;
+	dev_dbg(rtd->dev, "stream context restored at offset %d\n",
+		pcm_data->suspend_offset);
+
+	return 0;
+}
+
+static void sst_byt_pcm_work(struct work_struct *work)
+{
+	struct sst_byt_pcm_data *pcm_data =
+		container_of(work, struct sst_byt_pcm_data, work);
+
+	sst_byt_pcm_restore_stream_context(pcm_data->substream);
+}
+
 static int sst_byt_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sst_byt_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sst_byt_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
+	struct sst_byt_pcm_data *pcm_data =
+		&pdata->pcm[substream->stream];
 	struct sst_byt *byt = pdata->byt;
 
 	dev_dbg(rtd->dev, "PCM: trigger %d\n", cmd);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-		sst_byt_stream_start(byt, pcm_data->stream);
+		if (pcm_data->xrun) {
+			pcm_data->xrun = false;
+			break;
+		}
+		if (!pcm_data->resume) {
+			if (pcm_data->resume_stop)
+				pcm_data->resume_stop = false;
+			else
+				sst_byt_stream_start(byt, pcm_data->stream);
+		}
 		break;
 	case SNDRV_PCM_TRIGGER_RESUME:
+		schedule_work(&pcm_data->work);
+		break;
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 		sst_byt_stream_resume(byt, pcm_data->stream);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-		sst_byt_stream_stop(byt, pcm_data->stream);
+		if (runtime->pending_state == SNDRV_PCM_STATE_XRUN) {
+			pcm_data->xrun = true;
+			break;
+		}
+
+		if (!pcm_data->resume)
+			sst_byt_stream_stop(byt, pcm_data->stream);
+		else
+			pcm_data->resume_stop = true;
 		break;
 	case SNDRV_PCM_TRIGGER_SUSPEND:
+		pcm_data->resume = true;
 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 		sst_byt_stream_pause(byt, pcm_data->stream);
 		break;
@@ -186,14 +259,20 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct sst_byt_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sst_byt_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
+	struct sst_byt_pcm_data *pcm_data =
+		&pdata->pcm[substream->stream];
 	struct sst_byt *byt = pdata->byt;
 	snd_pcm_uframes_t offset;
 	int pos;
 
+	/* IPC delays can cause this to be called after close */
+	if (pcm_data->stream == NULL)
+		return 0;
+
 	pos = sst_byt_get_dsp_position(byt, pcm_data->stream,
 				       snd_pcm_lib_buffer_bytes(substream));
 	offset = bytes_to_frames(runtime, pos);
+	pcm_data->suspend_offset = pos;
 
 	dev_dbg(rtd->dev, "PCM: DMA pointer %zu bytes\n",
 		frames_to_bytes(runtime, (u32)offset));
@@ -205,20 +284,19 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct sst_byt_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sst_byt_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
+	struct sst_byt_pcm_data *pcm_data =
+		&pdata->pcm[substream->stream];
 	struct sst_byt *byt = pdata->byt;
 
 	dev_dbg(rtd->dev, "PCM: open\n");
 
-	pcm_data = &pdata->pcm[rtd->cpu_dai->id];
 	mutex_lock(&pcm_data->mutex);
 
-	snd_soc_pcm_set_drvdata(rtd, pcm_data);
 	pcm_data->substream = substream;
 
 	snd_soc_set_runtime_hwparams(substream, &sst_byt_pcm_hardware);
 
-	pcm_data->stream = sst_byt_stream_new(byt, rtd->cpu_dai->id + 1,
+	pcm_data->stream = sst_byt_stream_new(byt, substream->stream + 1,
 					      byt_notify_pointer, pcm_data);
 	if (pcm_data->stream == NULL) {
 		dev_err(rtd->dev, "failed to create stream\n");
@@ -235,7 +313,8 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct sst_byt_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct sst_byt_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
+	struct sst_byt_pcm_data *pcm_data =
+		&pdata->pcm[substream->stream];
 	struct sst_byt *byt = pdata->byt;
 	int ret;
 
@@ -306,27 +385,22 @@
 	return ret;
 }
 
-static struct snd_soc_dai_driver byt_dais[] = {
-	{
-		.name  = "Front-cpu-dai",
-		.playback = {
-			.stream_name = "System Playback",
-			.channels_min = 2,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FMTBIT_S24_3LE |
-				   SNDRV_PCM_FMTBIT_S16_LE,
-		},
+static struct snd_soc_dai_driver byt_dai = {
+	.name  = "Baytrail LPE",
+	.playback = {
+		.stream_name = "HiFi Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_3LE |
+			   SNDRV_PCM_FMTBIT_S16_LE,
 	},
-	{
-		.name  = "Mic1-cpu-dai",
-		.capture = {
-			.stream_name = "Analog Capture",
-			.channels_min = 2,
-			.channels_max = 2,
-			.rates = SNDRV_PCM_RATE_48000,
-			.formats = SNDRV_PCM_FMTBIT_S16_LE,
-		},
+	.capture = {
+		.stream_name = "HiFi Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
 	},
 };
 
@@ -344,8 +418,10 @@
 	priv_data->byt = plat_data->dsp;
 	snd_soc_platform_set_drvdata(platform, priv_data);
 
-	for (i = 0; i < ARRAY_SIZE(byt_dais); i++)
+	for (i = 0; i < 2; i++) {
 		mutex_init(&priv_data->pcm[i].mutex);
+		INIT_WORK(&priv_data->pcm[i].work ,sst_byt_pcm_work);
+	}
 
 	return 0;
 }
@@ -381,7 +457,7 @@
 		goto err_plat;
 
 	ret = snd_soc_register_component(&pdev->dev, &byt_dai_component,
-					 byt_dais, ARRAY_SIZE(byt_dais));
+					 &byt_dai, 1);
 	if (ret < 0)
 		goto err_comp;
 
@@ -405,10 +481,77 @@
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int sst_byt_pcm_dev_suspend_noirq(struct device *dev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
+	int ret;
+
+	dev_dbg(dev, "suspending noirq\n");
+
+	/* at this point all streams will be stopped and context saved */
+	ret = sst_byt_dsp_suspend_noirq(dev, sst_pdata);
+	if (ret < 0) {
+		dev_err(dev, "failed to suspend %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int sst_byt_pcm_dev_suspend_late(struct device *dev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
+	int ret;
+
+	dev_dbg(dev, "suspending late\n");
+
+	ret = sst_byt_dsp_suspend_late(dev, sst_pdata);
+	if (ret < 0) {
+		dev_err(dev, "failed to suspend %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int sst_byt_pcm_dev_resume_early(struct device *dev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
+
+	dev_dbg(dev, "resume early\n");
+
+	/* load fw and boot DSP */
+	return sst_byt_dsp_boot(dev, sst_pdata);
+}
+
+static int sst_byt_pcm_dev_resume(struct device *dev)
+{
+	struct sst_pdata *sst_pdata = dev_get_platdata(dev);
+
+	dev_dbg(dev, "resume\n");
+
+	/* wait for FW to finish booting */
+	return sst_byt_dsp_wait_for_ready(dev, sst_pdata);
+}
+
+static const struct dev_pm_ops sst_byt_pm_ops = {
+	.suspend_noirq = sst_byt_pcm_dev_suspend_noirq,
+	.suspend_late = sst_byt_pcm_dev_suspend_late,
+	.resume_early = sst_byt_pcm_dev_resume_early,
+	.resume = sst_byt_pcm_dev_resume,
+};
+
+#define SST_BYT_PM_OPS	(&sst_byt_pm_ops)
+#else
+#define SST_BYT_PM_OPS	NULL
+#endif
+
 static struct platform_driver sst_byt_pcm_driver = {
 	.driver = {
 		.name = "baytrail-pcm-audio",
 		.owner = THIS_MODULE,
+		.pm = SST_BYT_PM_OPS,
 	},
 
 	.probe = sst_byt_pcm_dev_probe,
Index: b/sound/soc/intel/sst-dsp-priv.h
===================================================================
--- a/sound/soc/intel/sst-dsp-priv.h	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-dsp-priv.h	2016-06-02 12:28:43.393170207 +0800
@@ -41,8 +41,10 @@
 	u64 (*read64)(void __iomem *addr, u32 offset);
 
 	/* DSP I/DRAM IO */
-	void (*ram_read)(struct sst_dsp *sst, void *dest, void *src, size_t bytes);
-	void (*ram_write)(struct sst_dsp *sst, void *dest, void *src, size_t bytes);
+	void (*ram_read)(struct sst_dsp *sst, void  *dest, void __iomem *src,
+		size_t bytes);
+	void (*ram_write)(struct sst_dsp *sst, void __iomem *dest, void *src,
+		size_t bytes);
 
 	void (*dump)(struct sst_dsp *);
 
@@ -258,11 +260,31 @@
 	bool fw_use_dma;
 };
 
+/* Size optimised DRAM/IRAM memcpy */
+static inline void sst_dsp_write(struct sst_dsp *sst, void *src,
+	u32 dest_offset, size_t bytes)
+{
+	sst->ops->ram_write(sst, sst->addr.lpe + dest_offset, src, bytes);
+}
+
+static inline void sst_dsp_read(struct sst_dsp *sst, void *dest,
+	u32 src_offset, size_t bytes)
+{
+	sst->ops->ram_read(sst, dest, sst->addr.lpe + src_offset, bytes);
+}
+
+static inline void *sst_dsp_get_thread_context(struct sst_dsp *sst)
+{
+	return sst->thread_context;
+}
+
 /* Create/Free FW files - can contain multiple modules */
 struct sst_fw *sst_fw_new(struct sst_dsp *dsp,
 	const struct firmware *fw, void *private);
 void sst_fw_free(struct sst_fw *sst_fw);
 void sst_fw_free_all(struct sst_dsp *dsp);
+int sst_fw_reload(struct sst_fw *sst_fw);
+void sst_fw_unload(struct sst_fw *sst_fw);
 
 /* Create/Free firmware modules */
 struct sst_module *sst_module_new(struct sst_fw *sst_fw,
@@ -278,6 +300,7 @@
 struct sst_module *sst_mem_block_alloc_scratch(struct sst_dsp *dsp);
 void sst_mem_block_free_scratch(struct sst_dsp *dsp,
 	struct sst_module *scratch);
+int sst_block_module_remove(struct sst_module *module);
 
 /* Register the DSPs memory blocks - would be nice to read from ACPI */
 struct sst_mem_block *sst_mem_block_register(struct sst_dsp *dsp, u32 offset,
@@ -285,8 +308,4 @@
 	void *private);
 void sst_mem_block_unregister_all(struct sst_dsp *dsp);
 
-/* DMA */
-int sst_dma_new(struct sst_dsp *sst);
-void sst_dma_free(struct sst_dma *dma);
-
 #endif
Index: b/sound/soc/intel/sst-dsp.c
===================================================================
--- a/sound/soc/intel/sst-dsp.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-dsp.c	2016-06-02 12:28:43.393170207 +0800
@@ -19,12 +19,73 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/io.h>
 
 #include "sst-dsp.h"
 #include "sst-dsp-priv.h"
 
 #define CREATE_TRACE_POINTS
-#include <trace/events/sst.h>
+#include <trace/events/intel-sst.h>
+
+/* Internal generic low-level SST IO functions - can be overidden */
+void sst_shim32_write(void __iomem *addr, u32 offset, u32 value)
+{
+	writel(value, addr + offset);
+}
+EXPORT_SYMBOL_GPL(sst_shim32_write);
+
+u32 sst_shim32_read(void __iomem *addr, u32 offset)
+{
+	return readl(addr + offset);
+}
+EXPORT_SYMBOL_GPL(sst_shim32_read);
+
+void sst_shim32_write64(void __iomem *addr, u32 offset, u64 value)
+{
+	memcpy_toio(addr + offset, &value, sizeof(value));
+}
+EXPORT_SYMBOL_GPL(sst_shim32_write64);
+
+u64 sst_shim32_read64(void __iomem *addr, u32 offset)
+{
+	u64 val;
+
+	memcpy_fromio(&val, addr + offset, sizeof(val));
+	return val;
+}
+EXPORT_SYMBOL_GPL(sst_shim32_read64);
+
+static inline void _sst_memcpy_toio_32(volatile u32 __iomem *dest,
+	u32 *src, size_t bytes)
+{
+	int i, words = bytes >> 2;
+
+	for (i = 0; i < words; i++)
+		writel(src[i], dest + i);
+}
+
+static inline void _sst_memcpy_fromio_32(u32 *dest,
+	const volatile __iomem u32 *src, size_t bytes)
+{
+	int i, words = bytes >> 2;
+
+	for (i = 0; i < words; i++)
+		dest[i] = readl(src + i);
+}
+
+void sst_memcpy_toio_32(struct sst_dsp *sst,
+	void __iomem *dest, void *src, size_t bytes)
+{
+	_sst_memcpy_toio_32(dest, src, bytes);
+}
+EXPORT_SYMBOL_GPL(sst_memcpy_toio_32);
+
+void sst_memcpy_fromio_32(struct sst_dsp *sst, void *dest,
+	void __iomem *src, size_t bytes)
+{
+	_sst_memcpy_fromio_32(dest, src, bytes);
+}
+EXPORT_SYMBOL_GPL(sst_memcpy_fromio_32);
 
 /* Public API */
 void sst_dsp_shim_write(struct sst_dsp *sst, u32 offset, u32 value)
@@ -35,7 +96,7 @@
 	sst->ops->write(sst->addr.shim, offset, value);
 	spin_unlock_irqrestore(&sst->spinlock, flags);
 }
-EXPORT_SYMBOL(sst_dsp_shim_write);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_write);
 
 u32 sst_dsp_shim_read(struct sst_dsp *sst, u32 offset)
 {
@@ -48,7 +109,7 @@
 
 	return val;
 }
-EXPORT_SYMBOL(sst_dsp_shim_read);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_read);
 
 void sst_dsp_shim_write64(struct sst_dsp *sst, u32 offset, u64 value)
 {
@@ -58,7 +119,7 @@
 	sst->ops->write64(sst->addr.shim, offset, value);
 	spin_unlock_irqrestore(&sst->spinlock, flags);
 }
-EXPORT_SYMBOL(sst_dsp_shim_write64);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_write64);
 
 u64 sst_dsp_shim_read64(struct sst_dsp *sst, u32 offset)
 {
@@ -71,61 +132,58 @@
 
 	return val;
 }
-EXPORT_SYMBOL(sst_dsp_shim_read64);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_read64);
 
 void sst_dsp_shim_write_unlocked(struct sst_dsp *sst, u32 offset, u32 value)
 {
 	sst->ops->write(sst->addr.shim, offset, value);
 }
-EXPORT_SYMBOL(sst_dsp_shim_write_unlocked);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_write_unlocked);
 
 u32 sst_dsp_shim_read_unlocked(struct sst_dsp *sst, u32 offset)
 {
 	return sst->ops->read(sst->addr.shim, offset);
 }
-EXPORT_SYMBOL(sst_dsp_shim_read_unlocked);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_read_unlocked);
 
 void sst_dsp_shim_write64_unlocked(struct sst_dsp *sst, u32 offset, u64 value)
 {
 	sst->ops->write64(sst->addr.shim, offset, value);
 }
-EXPORT_SYMBOL(sst_dsp_shim_write64_unlocked);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_write64_unlocked);
 
 u64 sst_dsp_shim_read64_unlocked(struct sst_dsp *sst, u32 offset)
 {
 	return sst->ops->read64(sst->addr.shim, offset);
 }
-EXPORT_SYMBOL(sst_dsp_shim_read64_unlocked);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_read64_unlocked);
 
-int sst_dsp_shim_update_bits(struct sst_dsp *sst, u32 offset,
+int sst_dsp_shim_update_bits_unlocked(struct sst_dsp *sst, u32 offset,
 				u32 mask, u32 value)
 {
-	unsigned long flags;
 	bool change;
-	u32 old, new;
+	unsigned int old, new;
+	u32 ret;
 
-	spin_lock_irqsave(&sst->spinlock, flags);
-	old = sst_dsp_shim_read_unlocked(sst, offset);
+	ret = sst_dsp_shim_read_unlocked(sst, offset);
 
+	old = ret;
 	new = (old & (~mask)) | (value & mask);
 
 	change = (old != new);
 	if (change)
 		sst_dsp_shim_write_unlocked(sst, offset, new);
 
-	spin_unlock_irqrestore(&sst->spinlock, flags);
 	return change;
 }
-EXPORT_SYMBOL(sst_dsp_shim_update_bits);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits_unlocked);
 
-int sst_dsp_shim_update_bits64(struct sst_dsp *sst, u32 offset,
+int sst_dsp_shim_update_bits64_unlocked(struct sst_dsp *sst, u32 offset,
 				u64 mask, u64 value)
 {
-	unsigned long flags;
 	bool change;
 	u64 old, new;
 
-	spin_lock_irqsave(&sst->spinlock, flags);
 	old = sst_dsp_shim_read64_unlocked(sst, offset);
 
 	new = (old & (~mask)) | (value & mask);
@@ -134,67 +192,54 @@
 	if (change)
 		sst_dsp_shim_write64_unlocked(sst, offset, new);
 
-	spin_unlock_irqrestore(&sst->spinlock, flags);
 	return change;
 }
-EXPORT_SYMBOL(sst_dsp_shim_update_bits64);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits64_unlocked);
 
-int sst_dsp_shim_update_bits_unlocked(struct sst_dsp *sst, u32 offset,
+int sst_dsp_shim_update_bits(struct sst_dsp *sst, u32 offset,
 				u32 mask, u32 value)
 {
+	unsigned long flags;
 	bool change;
-	unsigned int old, new;
-	u32 ret;
-
-	ret = sst_dsp_shim_read_unlocked(sst, offset);
-
-	old = ret;
-	new = (old & (~mask)) | (value & mask);
-
-	change = (old != new);
-	if (change)
-		sst_dsp_shim_write_unlocked(sst, offset, new);
 
+	spin_lock_irqsave(&sst->spinlock, flags);
+	change = sst_dsp_shim_update_bits_unlocked(sst, offset, mask, value);
+	spin_unlock_irqrestore(&sst->spinlock, flags);
 	return change;
 }
-EXPORT_SYMBOL(sst_dsp_shim_update_bits_unlocked);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits);
 
-int sst_dsp_shim_update_bits64_unlocked(struct sst_dsp *sst, u32 offset,
+int sst_dsp_shim_update_bits64(struct sst_dsp *sst, u32 offset,
 				u64 mask, u64 value)
 {
+	unsigned long flags;
 	bool change;
-	u64 old, new;
-
-	old = sst_dsp_shim_read64_unlocked(sst, offset);
-
-	new = (old & (~mask)) | (value & mask);
-
-	change = (old != new);
-	if (change)
-		sst_dsp_shim_write64_unlocked(sst, offset, new);
 
+	spin_lock_irqsave(&sst->spinlock, flags);
+	change = sst_dsp_shim_update_bits64_unlocked(sst, offset, mask, value);
+	spin_unlock_irqrestore(&sst->spinlock, flags);
 	return change;
 }
-EXPORT_SYMBOL(sst_dsp_shim_update_bits64_unlocked);
+EXPORT_SYMBOL_GPL(sst_dsp_shim_update_bits64);
 
 void sst_dsp_dump(struct sst_dsp *sst)
 {
 	sst->ops->dump(sst);
 }
-EXPORT_SYMBOL(sst_dsp_dump);
+EXPORT_SYMBOL_GPL(sst_dsp_dump);
 
 void sst_dsp_reset(struct sst_dsp *sst)
 {
 	sst->ops->reset(sst);
 }
-EXPORT_SYMBOL(sst_dsp_reset);
+EXPORT_SYMBOL_GPL(sst_dsp_reset);
 
 int sst_dsp_boot(struct sst_dsp *sst)
 {
 	sst->ops->boot(sst);
 	return 0;
 }
-EXPORT_SYMBOL(sst_dsp_boot);
+EXPORT_SYMBOL_GPL(sst_dsp_boot);
 
 void sst_dsp_ipc_msg_tx(struct sst_dsp *dsp, u32 msg)
 {
@@ -214,20 +259,6 @@
 }
 EXPORT_SYMBOL_GPL(sst_dsp_ipc_msg_rx);
 
-void sst_dsp_write(struct sst_dsp *sst, void *src, u32 dest_offset,
-	size_t bytes)
-{
-	sst->ops->ram_write(sst, sst->addr.lpe + dest_offset, src, bytes);
-}
-EXPORT_SYMBOL(sst_dsp_write);
-
-void sst_dsp_read(struct sst_dsp *sst, void *dest, u32 src_offset,
-	size_t bytes)
-{
-	sst->ops->ram_read(sst, dest, sst->addr.lpe + src_offset, bytes);
-}
-EXPORT_SYMBOL(sst_dsp_read);
-
 int sst_dsp_mailbox_init(struct sst_dsp *sst, u32 inbox_offset, size_t inbox_size,
 	u32 outbox_offset, size_t outbox_size)
 {
@@ -237,65 +268,59 @@
 	sst->mailbox.out_size = outbox_size;
 	return 0;
 }
-EXPORT_SYMBOL(sst_dsp_mailbox_init);
+EXPORT_SYMBOL_GPL(sst_dsp_mailbox_init);
 
 void sst_dsp_outbox_write(struct sst_dsp *sst, void *message, size_t bytes)
 {
-	int i;
+	u32 i;
 
 	trace_sst_ipc_outbox_write(bytes);
 
 	memcpy_toio(sst->mailbox.out_base, message, bytes);
 
 	for (i = 0; i < bytes; i += 4)
-		trace_sst_ipc_outbox_wdata(i, *(uint32_t *)(message + i));
+		trace_sst_ipc_outbox_wdata(i, *(u32 *)(message + i));
 }
-EXPORT_SYMBOL(sst_dsp_outbox_write);
+EXPORT_SYMBOL_GPL(sst_dsp_outbox_write);
 
 void sst_dsp_outbox_read(struct sst_dsp *sst, void *message, size_t bytes)
 {
-	int i;
+	u32 i;
 
 	trace_sst_ipc_outbox_read(bytes);
 
 	memcpy_fromio(message, sst->mailbox.out_base, bytes);
 
 	for (i = 0; i < bytes; i += 4)
-		trace_sst_ipc_outbox_rdata(i, *(uint32_t *)(message + i));
+		trace_sst_ipc_outbox_rdata(i, *(u32 *)(message + i));
 }
-EXPORT_SYMBOL(sst_dsp_outbox_read);
+EXPORT_SYMBOL_GPL(sst_dsp_outbox_read);
 
 void sst_dsp_inbox_write(struct sst_dsp *sst, void *message, size_t bytes)
 {
-	int i;
+	u32 i;
 
 	trace_sst_ipc_inbox_write(bytes);
 
 	memcpy_toio(sst->mailbox.in_base, message, bytes);
 
 	for (i = 0; i < bytes; i += 4)
-		trace_sst_ipc_inbox_wdata(i, *(uint32_t *)(message + i));
+		trace_sst_ipc_inbox_wdata(i, *(u32 *)(message + i));
 }
-EXPORT_SYMBOL(sst_dsp_inbox_write);
+EXPORT_SYMBOL_GPL(sst_dsp_inbox_write);
 
 void sst_dsp_inbox_read(struct sst_dsp *sst, void *message, size_t bytes)
 {
-	int i;
+	u32 i;
 
 	trace_sst_ipc_inbox_read(bytes);
 
 	memcpy_fromio(message, sst->mailbox.in_base, bytes);
 
 	for (i = 0; i < bytes; i += 4)
-		trace_sst_ipc_inbox_rdata(i, *(uint32_t *)(message + i));
-}
-EXPORT_SYMBOL(sst_dsp_inbox_read);
-
-void *sst_dsp_get_thread_context(struct sst_dsp *sst)
-{
-	return sst->thread_context;
+		trace_sst_ipc_inbox_rdata(i, *(u32 *)(message + i));
 }
-EXPORT_SYMBOL(sst_dsp_get_thread_context);
+EXPORT_SYMBOL_GPL(sst_dsp_inbox_read);
 
 struct sst_dsp *sst_dsp_new(struct device *dev,
 	struct sst_dsp_device *sst_dev, struct sst_pdata *pdata)
@@ -336,33 +361,23 @@
 	if (err)
 		goto irq_err;
 
-	/* Register the FW loader DMA controller if we have one */
-	if (pdata->dma_engine)
-		err = sst_dma_new(sst);
-	if (err)
-		goto dma_err;
-
 	return sst;
 
-dma_err:
-	free_irq(sst->irq, sst);
 irq_err:
 	if (sst->ops->free)
 		sst->ops->free(sst);
 
 	return NULL;
 }
-EXPORT_SYMBOL(sst_dsp_new);
+EXPORT_SYMBOL_GPL(sst_dsp_new);
 
 void sst_dsp_free(struct sst_dsp *sst)
 {
-	if (sst->pdata->dma_engine)
-		sst_dma_free(sst->dma);
 	free_irq(sst->irq, sst);
 	if (sst->ops->free)
 		sst->ops->free(sst);
 }
-EXPORT_SYMBOL(sst_dsp_free);
+EXPORT_SYMBOL_GPL(sst_dsp_free);
 
 /* Module information */
 MODULE_AUTHOR("Liam Girdwood");
Index: b/sound/soc/intel/sst-dsp.h
===================================================================
--- a/sound/soc/intel/sst-dsp.h	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-dsp.h	2016-06-02 12:28:43.393170207 +0800
@@ -158,12 +158,12 @@
 	u32 lpe_size;
 	u32 pcicfg_base;
 	u32 pcicfg_size;
+	u32 fw_base;
+	u32 fw_size;
 	int irq;
 
 	/* Firmware */
-	const char *fw_filename;
-	u32 fw_base;
-	u32 fw_size;
+	const struct firmware *fw;
 
 	/* DMA */
 	u32 dma_base;
@@ -200,12 +200,15 @@
 int sst_dsp_shim_update_bits64_unlocked(struct sst_dsp *sst, u32 offset,
 					u64 mask, u64 value);
 
-/* Size optimised DRAM/IRAM memcpy */
-void sst_dsp_write(struct sst_dsp *sst, void *src, u32 dest_offset,
-	size_t bytes);
-void sst_dsp_bzero(struct sst_dsp *sst, u32 src_offset, size_t bytes);
-void sst_dsp_read(struct sst_dsp *sst, void *dest, u32 src_offset,
-	size_t bytes);
+/* Internal generic low-level SST IO functions - can be overidden */
+void sst_shim32_write(void __iomem *addr, u32 offset, u32 value);
+u32 sst_shim32_read(void __iomem *addr, u32 offset);
+void sst_shim32_write64(void __iomem *addr, u32 offset, u64 value);
+u64 sst_shim32_read64(void __iomem *addr, u32 offset);
+void sst_memcpy_toio_32(struct sst_dsp *sst,
+			void __iomem *dest, void *src, size_t bytes);
+void sst_memcpy_fromio_32(struct sst_dsp *sst,
+			  void *dest, void __iomem *src, size_t bytes);
 
 /* DSP reset & boot */
 void sst_dsp_reset(struct sst_dsp *sst);
@@ -214,7 +217,6 @@
 /* Msg IO */
 void sst_dsp_ipc_msg_tx(struct sst_dsp *dsp, u32 msg);
 u32 sst_dsp_ipc_msg_rx(struct sst_dsp *dsp);
-void *sst_dsp_get_thread_context(struct sst_dsp *sst);
 
 /* Mailbox management */
 int sst_dsp_mailbox_init(struct sst_dsp *dsp, u32 inbox_offset,
@@ -225,12 +227,6 @@
 void sst_dsp_outbox_read(struct sst_dsp *dsp, void *message, size_t bytes);
 void sst_dsp_mailbox_dump(struct sst_dsp *dsp, size_t bytes);
 
-/* DMA FW maangement */
-int sst_dsp_dma_copy(struct sst_dsp *sst, dma_addr_t src_addr,
-	dma_addr_t dstn_addr, size_t size);
-int sst_dsp_dma_get_channel(struct sst_dsp *dsp, int chan_id);
-void sst_dsp_dma_put_channel(struct sst_dsp *dsp);
-
 /* Debug */
 void sst_dsp_dump(struct sst_dsp *sst);
 
Index: b/sound/soc/intel/sst-firmware.c
===================================================================
--- a/sound/soc/intel/sst-firmware.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-firmware.c	2016-06-02 12:28:43.397170197 +0800
@@ -13,7 +13,7 @@
  * GNU General Public License for more details.
  *
  */
-
+#define DEBUG
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
@@ -24,206 +24,23 @@
 #include <linux/dmaengine.h>
 #include <linux/pci.h>
 
-/* supported DMA engine drivers */
-#include <linux/dw_dmac.h>
-
 #include <asm/page.h>
 #include <asm/pgtable.h>
 
 #include "sst-dsp.h"
 #include "sst-dsp-priv.h"
 
-#define SST_DMA_RESOURCES	2
-#define SST_DSP_DMA_MAX_BURST	0x3
-
-struct sst_dma {
-	struct sst_dsp *sst;
-
-	struct platform_device *dma_dev;
-	struct resource dma_resource[SST_DMA_RESOURCES];
-	struct dma_async_tx_descriptor *desc;
-	struct dma_chan *ch;
-};
+static void block_module_remove(struct sst_module *module);
 
-static void sst_memcpy32(void *dest, void *src, int bytes)
+static void sst_memcpy32(volatile void __iomem *dest, void *src, u32 bytes)
 {
-	int i;
+	u32 i;
 
 	/* copy one 32 bit word at a time as 64 bit access is not supported */
 	for (i = 0; i < bytes; i += 4)
 		memcpy_toio(dest + i, src + i, 4);
 }
 
-static void sst_dma_transfer_complete(void *arg)
-{
-	struct sst_dsp *sst = (struct sst_dsp *)arg;
-
-	dev_dbg(sst->dev, "DMA: callback\n");
-}
-
-int sst_dsp_dma_copy(struct sst_dsp *sst, dma_addr_t src_addr,
-	dma_addr_t dest_addr, size_t size)
-{
-	struct dma_async_tx_descriptor *desc;
-	struct sst_dma *dma = sst->dma;
-
-	if (dma->ch == NULL) {
-		dev_err(sst->dev, "error: no DMA channel\n");
-		return -ENODEV;
-	}
-
-	dev_dbg(sst->dev, "DMA: src: 0x%lx dest 0x%lx size %zu\n",
-		(unsigned long)src_addr, (unsigned long)dest_addr, size);
-
-	desc = dma->ch->device->device_prep_dma_memcpy(dma->ch, dest_addr,
-		src_addr, size, DMA_CTRL_ACK);
-	if (!desc){
-		dev_err(sst->dev, "error: dma prep memcpy failed\n");
-		return -EINVAL;
-	}
-
-	desc->callback = sst_dma_transfer_complete;
-	desc->callback_param = sst;
-
-	desc->tx_submit(desc);
-	dma_wait_for_async_tx(desc);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sst_dsp_dma_copy);
-
-static bool dma_chan_filter(struct dma_chan *chan, void *param)
-{
-	struct sst_dsp *dsp = (struct sst_dsp *)param;
-	struct sst_dma *dma = dsp->dma;
-
-	/* only accept channels from this device */
-	if (chan->device->dev != &dma->dma_dev->dev)
-		return false;
-
-	/* todo: add chan_id testing */
-	return true;
-}
-
-int sst_dsp_dma_get_channel(struct sst_dsp *dsp, int chan_id)
-{
-	struct sst_dma *dma = dsp->dma;
-	struct dma_slave_config slave;
-	dma_cap_mask_t mask;
-	int ret;
-
-	/* The Intel MID DMA engine driver needs the slave config set but
-	 * Synopsis DMA engine driver safely ignores the slave config */
-	dma_cap_zero(mask);
-	dma_cap_set(DMA_SLAVE, mask);
-	dma_cap_set(DMA_MEMCPY, mask);
-
-	dma->ch = dma_request_channel(mask, dma_chan_filter, dsp);
-	if (dma->ch == NULL) {
-		dev_err(dsp->dev, "error: DMA request channel failed\n");
-		return -EIO;
-	}
-
-	memset(&slave, 0, sizeof(slave));
-	slave.direction = DMA_MEM_TO_DEV;
-	slave.src_addr_width =
-		slave.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	slave.src_maxburst = slave.dst_maxburst = SST_DSP_DMA_MAX_BURST;
-
-	ret = dmaengine_slave_config(dma->ch, &slave);
-	if (ret) {
-		dev_err(dsp->dev, "error: unable to set DMA slave config %d\n",
-			ret);
-		dma_release_channel(dma->ch);
-		dma->ch = NULL;
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(sst_dsp_dma_get_channel);
-
-void sst_dsp_dma_put_channel(struct sst_dsp *dsp)
-{
-	struct sst_dma *dma = dsp->dma;
-
-	dma_release_channel(dma->ch);
-	dma->ch = NULL;
-}
-EXPORT_SYMBOL_GPL(sst_dsp_dma_put_channel);
-
-/* platform data for DesignWare DMA Engine */
-static struct dw_dma_platform_data dw_pdata = {
-	.chan_allocation_order = CHAN_ALLOCATION_ASCENDING,
-	.chan_priority = CHAN_PRIORITY_ASCENDING,
-};
-
-int sst_dma_new(struct sst_dsp *sst)
-{
-	struct sst_pdata *sst_pdata = sst->pdata;
-	struct sst_dma *dma;
-	const char *dma_dev_name;
-	size_t dma_pdata_size;
-	void *dma_pdata;
-
-	/* configure the correct platform data for whatever DMA engine
-	* is attached to the ADSP IP. */
-	switch (sst->pdata->dma_engine) {
-	case SST_DMA_TYPE_DW:
-		dma_pdata = &dw_pdata;
-		dma_pdata_size = sizeof(dw_pdata);
-		dma_dev_name = "dw_dmac";
-		break;
-	case SST_DMA_TYPE_MID:
-		dma_pdata = NULL;
-		dma_pdata_size = 0;
-		dma_dev_name = "Intel MID DMA";
-		break;
-	default:
-		dev_err(sst->dev, "error: invalid DMA engine %d\n",
-			sst->pdata->dma_engine);
-		return -EINVAL;
-	}
-
-	dma = devm_kzalloc(sst->dev, sizeof(struct sst_dma), GFP_KERNEL);
-	if (!dma)
-		return -ENOMEM;
-
-	dma->sst = sst;
-	sst->dma = dma;
-
-	dma->dma_resource[0].start = sst->addr.lpe_base +
-					sst_pdata->dma_base;
-	dma->dma_resource[0].end   = sst->addr.lpe_base +
-					sst_pdata->dma_base +
-					sst_pdata->dma_size;
-	dma->dma_resource[0].flags = IORESOURCE_MEM;
-	dma->dma_resource[1].start = sst_pdata->irq;
-	dma->dma_resource[1].end = sst_pdata->irq;
-	dma->dma_resource[1].flags = IORESOURCE_IRQ;
-
-	/* now register DMA engine device */
-	dma->dma_dev = platform_device_register_resndata(sst->dev,
-		dma_dev_name, -1, dma->dma_resource, 2,
-		dma_pdata, dma_pdata_size);
-
-	if (dma->dma_dev == NULL) {
-		dev_err(sst->dev, "error: DMA device register failed\n");
-		return -ENODEV;
-	}
-
-	sst->fw_use_dma = true;
-	return 0;
-}
-EXPORT_SYMBOL(sst_dma_new);
-
-void sst_dma_free(struct sst_dma *dma)
-{
-	if (dma->ch)
-		dma_release_channel(dma->ch);
-	platform_device_unregister(dma->dma_dev);
-}
-EXPORT_SYMBOL(sst_dma_free);
-
 /* create new generic firmware object */
 struct sst_fw *sst_fw_new(struct sst_dsp *dsp, 
 	const struct firmware *fw, void *private)
@@ -250,7 +67,7 @@
 
 	/* allocate DMA buffer to store FW data */
 	sst_fw->dma_buf = dma_alloc_coherent(dsp->dev, sst_fw->size,
-				&sst_fw->dmable_fw_paddr, GFP_DMA);
+				&sst_fw->dmable_fw_paddr, GFP_DMA | GFP_KERNEL);
 	if (!sst_fw->dma_buf) {
 		dev_err(dsp->dev, "error: DMA alloc failed\n");
 		kfree(sst_fw);
@@ -259,13 +76,6 @@
 
 	/* copy FW data to DMA-able memory */
 	memcpy((void *)sst_fw->dma_buf, (void *)fw->data, fw->size);
-	release_firmware(fw);
-
-	if (dsp->fw_use_dma) {
-		err = sst_dsp_dma_get_channel(dsp, 0);
-		if (err < 0)
-			goto chan_err;
-	}
 
 	/* call core specific FW paser to load FW data into DSP */
 	err = dsp->ops->parse_fw(sst_fw);
@@ -274,9 +84,6 @@
 		goto parse_err;
 	}
 
-	if (dsp->fw_use_dma)
-		sst_dsp_dma_put_channel(dsp);
-
 	mutex_lock(&dsp->mutex);
 	list_add(&sst_fw->list, &dsp->fw_list);
 	mutex_unlock(&dsp->mutex);
@@ -284,9 +91,6 @@
 	return sst_fw;
 
 parse_err:
-	if (dsp->fw_use_dma)
-		sst_dsp_dma_put_channel(dsp);
-chan_err:
 	dma_free_coherent(dsp->dev, sst_fw->size,
 				sst_fw->dma_buf,
 				sst_fw->dmable_fw_paddr);
@@ -295,6 +99,42 @@
 }
 EXPORT_SYMBOL_GPL(sst_fw_new);
 
+int sst_fw_reload(struct sst_fw *sst_fw)
+{
+	struct sst_dsp *dsp = sst_fw->dsp;
+	int ret;
+
+	dev_dbg(dsp->dev, "reloading firmware\n");
+
+	/* call core specific FW paser to load FW data into DSP */
+	ret = dsp->ops->parse_fw(sst_fw);
+	if (ret < 0)
+		dev_err(dsp->dev, "error: parse fw failed %d\n", ret);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sst_fw_reload);
+
+void sst_fw_unload(struct sst_fw *sst_fw)
+{
+        struct sst_dsp *dsp = sst_fw->dsp;
+        struct sst_module *module, *tmp;
+
+        dev_dbg(dsp->dev, "unloading firmware\n");
+
+        mutex_lock(&dsp->mutex);
+        list_for_each_entry_safe(module, tmp, &dsp->module_list, list) {
+                if (module->sst_fw == sst_fw) {
+                        block_module_remove(module);
+                        list_del(&module->list);
+                        kfree(module);
+                }
+        }
+
+        mutex_unlock(&dsp->mutex);
+}
+EXPORT_SYMBOL_GPL(sst_fw_unload);
+
 /* free single firmware object */
 void sst_fw_free(struct sst_fw *sst_fw)
 {
@@ -368,50 +208,44 @@
 }
 EXPORT_SYMBOL_GPL(sst_module_free);
 
-/* allocate contiguous free DSP blocks - callers hold locks */
-static int block_alloc_contiguous(struct sst_module *module,
-	struct sst_module_data *data, u32 next_offset, int size)
+static struct sst_mem_block *find_block(struct sst_dsp *dsp, int type,
+	u32 offset)
 {
-	struct sst_dsp *dsp = module->dsp;
-	struct sst_mem_block *block, *tmp;
-	int ret;
-
-	/* find first free blocks that can hold module */
-	list_for_each_entry_safe(block, tmp, &dsp->free_block_list, list) {
+	struct sst_mem_block *block;
 
-		/* ignore blocks that dont match type */
-		if (block->type != data->type)
-			continue;
+	list_for_each_entry(block, &dsp->free_block_list, list) {
+		if (block->type == type && block->offset == offset)
+			return block;
+	}
 
-		/* is block next after parent ? */
-		if (next_offset == block->offset) {
+	return NULL;
+}
 
-			/* do we need more blocks */
-			if (size > block->size) {
-				ret = block_alloc_contiguous(module,
-					data, block->offset + block->size,
-					size - block->size);
-				if (ret < 0)
-					return ret;
-			}
+static int block_alloc_contiguous(struct sst_module *module,
+	struct sst_module_data *data, u32 offset, int size)
+{
+	struct list_head tmp = LIST_HEAD_INIT(tmp);
+	struct sst_dsp *dsp = module->dsp;
+	struct sst_mem_block *block;
 
-			/* add block to module */
-			block->data_type = data->data_type;
-			block->bytes_used = block->size;
-			list_move(&block->list, &dsp->used_block_list);
-			list_add(&block->module_list, &module->block_list);
-			dev_dbg(dsp->dev, " module %d added block %d:%d\n",
-				module->id, block->type, block->index);
-			return 0;
+	while (size > 0) {
+		block = find_block(dsp, data->type, offset);
+		if (!block) {
+			list_splice(&tmp, &dsp->free_block_list);
+			return -ENOMEM;
 		}
-	}
 
-	/* free any allocated blocks on failure */
-	list_for_each_entry_safe(block, tmp, &module->block_list, module_list) {
-		list_del(&block->module_list);
-		list_move(&block->list, &dsp->free_block_list);
+		list_move_tail(&block->list, &tmp);
+		offset += block->size;
+		size -= block->size;
 	}
-	return -ENOMEM;
+
+	list_for_each_entry(block, &tmp, list)
+		list_add(&block->module_list, &module->block_list);
+
+	list_splice(&tmp, &dsp->used_block_list);
+
+	return 0;
 }
 
 /* allocate free DSP blocks for module data - callers hold locks */
@@ -455,8 +289,7 @@
 		/* do we span > 1 blocks */
 		if (data->size > block->size) {
 			ret = block_alloc_contiguous(module, data,
-				block->offset + block->size,
-				data->size - block->size);
+				block->offset, data->size);
 			if (ret == 0)
 				return ret;
 		}
@@ -501,7 +334,7 @@
 	/* enable each block so that's it'e ready for module P/S data */
 	list_for_each_entry(block, &module->block_list, module_list) {
 
-		if (block->ops && block->ops->enable)
+		if (block->ops && block->ops->enable) {
 			ret = block->ops->enable(block);
 			if (ret < 0) {
 				dev_err(module->dsp->dev,
@@ -509,6 +342,7 @@
 					block->type, block->index);
 				goto err;
 			}
+		}
 	}
 	return ret;
 
@@ -548,10 +382,9 @@
 
 		/* does block span more than 1 section */
 		if (data->offset >= block->offset && data->offset < block_end) {
-
 			err = block_alloc_contiguous(module, data,
 				block->offset + block->size,
-				data->size - block->size + data->offset - block->offset);
+				data->size - block->size);
 			if (err < 0)
 				return -ENOMEM;
 
@@ -578,15 +411,9 @@
 		if (data->offset >= block->offset && data->offset < block_end) {
 
 			err = block_alloc_contiguous(module, data,
-				block->offset + block->size,
-				data->size - block->size);
+				block->offset, data->size);
 			if (err < 0)
 				return -ENOMEM;
-
-			/* add block */
-			block->data_type = data->data_type;
-			list_move(&block->list, &dsp->used_block_list);
-			list_add(&block->module_list, &module->block_list);
 			return 0;
 		}
 
@@ -600,7 +427,6 @@
 	struct sst_module_data *data)
 {
 	struct sst_dsp *dsp = module->dsp;
-	struct sst_fw *sst_fw = module->sst_fw;
 	int ret;
 
 	mutex_lock(&dsp->mutex);
@@ -623,20 +449,10 @@
 	}
 
 	/* copy partial module data to blocks */
-	if (dsp->fw_use_dma) {
-		ret = sst_dsp_dma_copy(dsp,
-			sst_fw->dmable_fw_paddr + data->data_offset,
-			dsp->addr.lpe_base + data->offset, data->size);
-		if (ret < 0) {
-			dev_err(dsp->dev, "error: module copy failed\n");
-			goto err;
-		}
-	} else
-		sst_memcpy32(dsp->addr.lpe + data->offset, data->data,
-			data->size);
+	sst_memcpy32(dsp->addr.lpe + data->offset, data->data, data->size);
 
 	mutex_unlock(&dsp->mutex);
-	return ret;
+	return 0;
 
 err:
 	block_module_remove(module);
Index: b/sound/soc/intel/sst-haswell-dsp.c
===================================================================
--- a/sound/soc/intel/sst-haswell-dsp.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-haswell-dsp.c	2016-06-02 12:28:43.397170197 +0800
@@ -84,61 +84,6 @@
 
 static void hsw_free(struct sst_dsp *sst);
 
-/* Internal Generic SST IO functions - can be overidden */
-static void shim_write(void __iomem *addr, u32 offset, u32 value)
-{
-	writel(value, addr + offset);
-}
-
-static u32 shim_read(void __iomem *addr, u32 offset)
-{
-	return readl(addr + offset);
-}
-
-static void shim_write64(void __iomem *addr, u32 offset, u64 value)
-{
-	memcpy_toio(addr + offset, &value, sizeof(value));
-}
-
-static u64 shim_read64(void __iomem *addr, u32 offset)
-{
-	u64 val;
-
-	memcpy_fromio(&val, addr + offset, sizeof(val));
-	return val;
-}
-
-/* Internal Generic SST memcpy functions - can be overidden */
-static inline void _sst_memcpy_toio_32(volatile u32 __iomem *dest,
-	u32 *src, size_t bytes)
-{
-	int i, words = bytes >> 2;
-
-	for (i = 0; i < words; i++)
-		writel(src[i], dest + i);
-}
-
-static inline void _sst_memcpy_fromio_32(u32 *dest,
-	const volatile __iomem u32 *src, size_t bytes)
-{
-	int i, words = bytes >> 2;
-
-	for (i = 0; i < words; i++)
-		dest[i] = readl(src + i);
-}
-
-void sst_memcpy_toio_32(struct sst_dsp *sst,
-	void __iomem *dest, void *src, size_t bytes)
-{
-	_sst_memcpy_toio_32(dest, src, bytes);
-}
-
-void sst_memcpy_fromio_32(struct sst_dsp *sst, void *dest,
-	void __iomem *src, size_t bytes)
-{
-	_sst_memcpy_fromio_32(dest, src, bytes);
-}
-
 static int hsw_parse_module(struct sst_dsp *dsp, struct sst_fw *fw,
 	struct fw_module_header *module)
 {
@@ -558,11 +503,11 @@
 
 struct sst_ops haswell_ops = {
 	.reset = hsw_reset,
-        .boot = hsw_boot,
-        .write = shim_write,
-        .read = shim_read,
-        .write64 = shim_write64,
-        .read64 = shim_read64,
+	.boot = hsw_boot,
+	.write = sst_shim32_write,
+	.read = sst_shim32_read,
+	.write64 = sst_shim32_write64,
+	.read64 = sst_shim32_read64,
 	.ram_read = sst_memcpy_fromio_32,
 	.ram_write = sst_memcpy_toio_32,
 	.irq_handler = hsw_irq,
Index: b/sound/soc/intel/sst-haswell-ipc.c
===================================================================
--- a/sound/soc/intel/sst-haswell-ipc.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-haswell-ipc.c	2016-06-02 12:28:43.397170197 +0800
@@ -78,7 +78,7 @@
 #define IPC_LOG_ID_MASK		(0xf << IPC_LOG_ID_SHIFT)
 #define IPC_LOG_ID(x)		(x << IPC_LOG_ID_SHIFT)
 
-/* IPC message timeout (msecs) TODO: get better value */
+/* IPC message timeout (msecs) */
 #define IPC_TIMEOUT_MSECS	300
 #define IPC_BOOT_MSECS		200
 #define IPC_MSG_WAIT		0
@@ -91,40 +91,43 @@
 #define IPC_EMPTY_LIST_SIZE	8
 #define IPC_MAX_STREAMS		4
 
+/* Mailbox */
+#define IPC_MAX_MAILBOX_BYTES	256
+
 /* Global Message - Types and Replies */
 enum ipc_glb_type {
-	IPC_GLB_GET_FW_VERSION = 0,		/**< Retrieves firmware version */
-	IPC_GLB_PERFORMANCE_MONITOR = 1, /**< Performance monitoring actions */
-	IPC_GLB_ALLOCATE_STREAM = 3,		/**< Request to allocate new stream */
-	IPC_GLB_FREE_STREAM = 4,			/**< Request to free stream */
-	IPC_GLB_GET_FW_CAPABILITIES = 5,		/**< Retrieves firmware capabilities */
-	IPC_GLB_STREAM_MESSAGE = 6,		/**< Message directed to stream or its stages */
-	/** Request to store firmware context during D0->D3 transition */
+	IPC_GLB_GET_FW_VERSION = 0,		/* Retrieves firmware version */
+	IPC_GLB_PERFORMANCE_MONITOR = 1,	/* Performance monitoring actions */
+	IPC_GLB_ALLOCATE_STREAM = 3,		/* Request to allocate new stream */
+	IPC_GLB_FREE_STREAM = 4,		/* Request to free stream */
+	IPC_GLB_GET_FW_CAPABILITIES = 5,	/* Retrieves firmware capabilities */
+	IPC_GLB_STREAM_MESSAGE = 6,		/* Message directed to stream or its stages */
+	/* Request to store firmware context during D0->D3 transition */
 	IPC_GLB_REQUEST_DUMP = 7,
-	/** Request to restore firmware context during D3->D0 transition */
+	/* Request to restore firmware context during D3->D0 transition */
 	IPC_GLB_RESTORE_CONTEXT = 8,
-	IPC_GLB_GET_DEVICE_FORMATS = 9,		/**< TODO: Add description */
-	IPC_GLB_SET_DEVICE_FORMATS = 10,		/**< TODO: Add description */
+	IPC_GLB_GET_DEVICE_FORMATS = 9,		/* Set device format */
+	IPC_GLB_SET_DEVICE_FORMATS = 10,	/* Get device format */
 	IPC_GLB_SHORT_REPLY = 11,
 	IPC_GLB_ENTER_DX_STATE = 12,
-	IPC_GLB_GET_MIXER_STREAM_INFO = 13,	/** < Request mixer stream params */
+	IPC_GLB_GET_MIXER_STREAM_INFO = 13,	/* Request mixer stream params */
 	IPC_GLB_DEBUG_LOG_MESSAGE = 14,		/* Message to or from the debug logger. */
-	IPC_GLB_REQUEST_TRANSFER = 16, /** < Request Transfer for host */
-	IPC_GLB_MAX_IPC_MESSAGE_TYPE = 17,	/**< Maximum message number */
+	IPC_GLB_REQUEST_TRANSFER = 16, 		/* < Request Transfer for host */
+	IPC_GLB_MAX_IPC_MESSAGE_TYPE = 17,	/* Maximum message number */
 };
 
 enum ipc_glb_reply {
-	IPC_GLB_REPLY_SUCCESS = 0,		/**< The operation was successful. */
-	IPC_GLB_REPLY_ERROR_INVALID_PARAM = 1,	/**< Invalid parameter was passed. */
-	IPC_GLB_REPLY_UNKNOWN_MESSAGE_TYPE = 2,		/**< Uknown message type was resceived. */
-	IPC_GLB_REPLY_OUT_OF_RESOURCES = 3,	/**< No resources to satisfy the request. */
-	IPC_GLB_REPLY_BUSY = 4,				/**< The system or resource is busy. */
-	IPC_GLB_REPLY_PENDING = 5,		/**< The action was scheduled for processing.  */
-	IPC_GLB_REPLY_FAILURE = 6,		/**< Critical error happened. */
-	IPC_GLB_REPLY_INVALID_REQUEST = 7,	/**< Request can not be completed. */
-	IPC_GLB_REPLY_STAGE_UNINITIALIZED = 8,	/**< Processing stage was uninitialized. */
-	IPC_GLB_REPLY_NOT_FOUND = 9,		/**< Required resource can not be found. */
-	IPC_GLB_REPLY_SOURCE_NOT_STARTED = 10,	/**< Source was not started. */
+	IPC_GLB_REPLY_SUCCESS = 0,		/* The operation was successful. */
+	IPC_GLB_REPLY_ERROR_INVALID_PARAM = 1,	/* Invalid parameter was passed. */
+	IPC_GLB_REPLY_UNKNOWN_MESSAGE_TYPE = 2,	/* Uknown message type was resceived. */
+	IPC_GLB_REPLY_OUT_OF_RESOURCES = 3,	/* No resources to satisfy the request. */
+	IPC_GLB_REPLY_BUSY = 4,			/* The system or resource is busy. */
+	IPC_GLB_REPLY_PENDING = 5,		/* The action was scheduled for processing.  */
+	IPC_GLB_REPLY_FAILURE = 6,		/* Critical error happened. */
+	IPC_GLB_REPLY_INVALID_REQUEST = 7,	/* Request can not be completed. */
+	IPC_GLB_REPLY_STAGE_UNINITIALIZED = 8,	/* Processing stage was uninitialized. */
+	IPC_GLB_REPLY_NOT_FOUND = 9,		/* Required resource can not be found. */
+	IPC_GLB_REPLY_SOURCE_NOT_STARTED = 10,	/* Source was not started. */
 };
 
 /* Stream Message - Types */
@@ -176,12 +179,12 @@
 
 /* Firmware Ready */
 struct sst_hsw_ipc_fw_ready {
-	uint32_t inbox_offset;
-	uint32_t outbox_offset;
-	uint32_t inbox_size;
-	uint32_t outbox_size;
-	uint32_t fw_info_size;
-	uint8_t fw_info[1];
+	u32 inbox_offset;
+	u32 outbox_offset;
+	u32 inbox_size;
+	u32 outbox_size;
+	u32 fw_info_size;
+	u8 fw_info[1];
 } __attribute__((packed));
 
 struct ipc_message {
@@ -189,9 +192,9 @@
 	u32 header;
 
 	/* direction wrt host CPU */
-	char tx_data[256];
+	char tx_data[IPC_MAX_MAILBOX_BYTES];
 	size_t tx_size;
-	char rx_data[256];
+	char rx_data[IPC_MAX_MAILBOX_BYTES];
 	size_t rx_size;
 
 	wait_queue_head_t waitq;
@@ -258,7 +261,7 @@
 	u32 reader_pos;
 
 	/* fw log config */
-	uint32_t config[SST_HSW_FW_LOG_CONFIG_DWORDS];
+	u32 config[SST_HSW_FW_LOG_CONFIG_DWORDS];
 
 	struct sst_hsw *hsw;
 };
@@ -280,7 +283,7 @@
 
 	/* global mixer */
 	struct sst_hsw_ipc_stream_info_reply mixer_info;
-	enum sst_hsw_ipc_volume_curve_type curve_type;
+	enum sst_hsw_volume_curve curve_type;
 	u32 curve_duration;
 	u32 mute[SST_HSW_NO_CHANNELS];
 	u32 mute_volume[SST_HSW_NO_CHANNELS];
@@ -432,7 +435,8 @@
 	struct ipc_message *msg = NULL;
 
 	if (!list_empty(&hsw->empty_list)) {
-		msg = list_first_entry(&hsw->empty_list, struct ipc_message, list);
+		msg = list_first_entry(&hsw->empty_list, struct ipc_message,
+			list);
 		list_del(&msg->list);
 	}
 
@@ -473,7 +477,7 @@
 }
 
 /* locks held by caller */
-static inline void tx_msg_reply_complete(struct sst_hsw *hsw, struct ipc_message *msg)
+static void tx_msg_reply_complete(struct sst_hsw *hsw, struct ipc_message *msg)
 {
 	msg->complete = true;
 	trace_ipc_reply("completed", msg->header);
@@ -523,7 +527,7 @@
 
 	msg = msg_get_empty(hsw);
 	if (msg == NULL) {
-		spin_unlock(&hsw->dsp->spinlock);
+		spin_unlock_irqrestore(&hsw->dsp->spinlock, flags);
 		return -EBUSY;
 	}
 
@@ -569,7 +573,8 @@
 
 	offset = (header & 0x1FFFFFFF) << 3;
 
-	dev_dbg(hsw->dev, "ipc: DSP is ready 0x%8.8x offset %d\n", header, offset);
+	dev_dbg(hsw->dev, "ipc: DSP is ready 0x%8.8x offset %d\n",
+		header, offset);
 
 	/* copy data from the DSP FW ready offset */
 	sst_dsp_read(hsw->dsp, &fw_ready, offset, sizeof(fw_ready));
@@ -600,7 +605,7 @@
 
 	switch (reason) {
 	case IPC_STG_GLITCH:
-		trace_ipc_notification("DSP stream glitch",
+		trace_ipc_notification("DSP stream under/overrun",
 			stream->reply.stream_hw_id);
 		sst_dsp_inbox_read(hsw->dsp, glitch, sizeof(*glitch));
 
@@ -612,14 +617,15 @@
 	case IPC_POSITION_CHANGED:
 		trace_ipc_notification("DSP stream position changed for",
 			stream->reply.stream_hw_id);
-		sst_dsp_inbox_read(hsw->dsp, pos, sizeof(&pos));
+		sst_dsp_inbox_read(hsw->dsp, pos, sizeof(pos));
 
 		if (stream->notify_position)
 			stream->notify_position(stream, stream->pdata);
 
 		break;
 	default:
-		dev_err(hsw->dev, "unknown notification 0x%x\n", stream->header);
+		dev_err(hsw->dev, "error: unknown notification 0x%x\n",
+			stream->header);
 		break;
 	}
 
@@ -631,26 +637,6 @@
 	sst_dsp_shim_update_bits_unlocked(hsw->dsp, SST_IMRX, SST_IMRX_BUSY, 0);
 }
 
-static void hsw_log_notification_work(struct work_struct *work)
-{
-	struct sst_hsw_log_stream *stream = container_of(work,
-	struct sst_hsw_log_stream, notify_work);
-	struct sst_hsw *hsw = stream->hsw;
-	u32 header;
-	int ret;
-
-	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
-	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_NOTIFY_LOG_DUMP);
-	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
-	ret = ipc_tx_message_nowait(hsw, header,
-		&stream->curr_pos, sizeof(stream->curr_pos));
-	if (ret < 0)
-		dev_err(hsw->dev,
-			"ipc: send ipc to notify fw log position failed\n");
-
-	wake_up_interruptible(&stream->readers_wait_q);
-}
-
 static struct ipc_message *reply_find_msg(struct sst_hsw *hsw, u32 header)
 {
 	struct ipc_message *msg;
@@ -659,7 +645,7 @@
 	header &= ~(IPC_STATUS_MASK | IPC_GLB_REPLY_MASK);
 
 	if (list_empty(&hsw->rx_list)) {
-		dev_err(hsw->dev, "ipc: rx list is empty but received 0x%x\n",
+		dev_err(hsw->dev, "error: rx list empty but received 0x%x\n",
 			header);
 		return NULL;
 	}
@@ -690,11 +676,13 @@
 		break;
 	case IPC_STR_PAUSE:
 		stream->running = false;
-		trace_ipc_notification("stream paused", stream->reply.stream_hw_id);
+		trace_ipc_notification("stream paused",
+			stream->reply.stream_hw_id);
 		break;
 	case IPC_STR_RESUME:
 		stream->running = true;
-		trace_ipc_notification("stream running", stream->reply.stream_hw_id);
+		trace_ipc_notification("stream running",
+			stream->reply.stream_hw_id);
 		break;
 	}
 }
@@ -705,10 +693,11 @@
 	u32 reply = msg_get_global_reply(header);
 
 	trace_ipc_reply("processing -->", header);
+
 	msg = reply_find_msg(hsw, header);
 	if (msg == NULL) {
-		trace_ipc_error("can't find message for header", header);
-		return 1;
+		trace_ipc_error("error: can't find message header", header);
+		return -EIO;
 	}
 
 	/* first process the header */
@@ -721,52 +710,54 @@
 	case IPC_GLB_REPLY_SUCCESS:
 		if (msg->pending) {
 			trace_ipc_pending_reply("completed", header);
-			sst_dsp_inbox_read(hsw->dsp, msg->rx_data, msg->rx_size);
+			sst_dsp_inbox_read(hsw->dsp, msg->rx_data,
+				msg->rx_size);
 			hsw->pending = false;
 		} else {
 			/* copy data from the DSP */
-			sst_dsp_outbox_read(hsw->dsp, msg->rx_data, msg->rx_size);
+			sst_dsp_outbox_read(hsw->dsp, msg->rx_data,
+				msg->rx_size);
 		}
 		break;
 	/* these will be rare - but useful for debug */
 	case IPC_GLB_REPLY_UNKNOWN_MESSAGE_TYPE:
-		trace_ipc_error("unknown message type", header);
+		trace_ipc_error("error: unknown message type", header);
 		msg->errno = -EBADMSG;
 		break;
 	case IPC_GLB_REPLY_OUT_OF_RESOURCES:
-		trace_ipc_error("out of resources", header);
+		trace_ipc_error("error: out of resources", header);
 		msg->errno = -ENOMEM;
 		break;
 	case IPC_GLB_REPLY_BUSY:
-		trace_ipc_error("reply busy", header);
+		trace_ipc_error("error: reply busy", header);
 		msg->errno = -EBUSY;
 		break;
 	case IPC_GLB_REPLY_FAILURE:
-		trace_ipc_error("reply failure", header);
+		trace_ipc_error("error: reply failure", header);
 		msg->errno = -EINVAL;
 		break;
 	case IPC_GLB_REPLY_STAGE_UNINITIALIZED:
-		trace_ipc_error("stage uninitialized", header);
+		trace_ipc_error("error: stage uninitialized", header);
 		msg->errno = -EINVAL;
 		break;
 	case IPC_GLB_REPLY_NOT_FOUND:
-		trace_ipc_error("reply not found", header);
+		trace_ipc_error("error: reply not found", header);
 		msg->errno = -EINVAL;
 		break;
 	case IPC_GLB_REPLY_SOURCE_NOT_STARTED:
-		trace_ipc_error("source not started", header);
+		trace_ipc_error("error: source not started", header);
 		msg->errno = -EINVAL;
 		break;
 	case IPC_GLB_REPLY_INVALID_REQUEST:
-		trace_ipc_error("invalid request", header);
+		trace_ipc_error("error: invalid request", header);
 		msg->errno = -EINVAL;
 		break;
 	case IPC_GLB_REPLY_ERROR_INVALID_PARAM:
-		trace_ipc_error("invalid parameter", header);
+		trace_ipc_error("error: invalid parameter", header);
 		msg->errno = -EINVAL;
 		break;
 	default:
-		trace_ipc_error("unknown reply", header);
+		trace_ipc_error("error: unknown reply", header);
 		msg->errno = -EINVAL;
 		break;
 	}
@@ -799,7 +790,8 @@
 
 	switch (stream_msg) {
 	case IPC_STR_STAGE_MESSAGE:
-		dev_err(hsw->dev, "ipc: stage msg not implemented 0x%8.8x\n", header);
+		dev_err(hsw->dev, "error: stage msg not implemented 0x%8.8x\n",
+			header);
 		break;
 	case IPC_STR_NOTIFICATION:
 		schedule_work(&stream->notify_work);
@@ -821,7 +813,7 @@
 
 	if (operation != IPC_DEBUG_REQUEST_LOG_DUMP) {
 		dev_err(hsw->dev,
-			"ipc: FW log msg not implemented 0x%8.8x\n", header);
+			"error: log msg not implemented 0x%8.8x\n", header);
 		return 0;
 	}
 
@@ -866,7 +858,7 @@
 	case IPC_GLB_MAX_IPC_MESSAGE_TYPE:
 	case IPC_GLB_RESTORE_CONTEXT:
 	case IPC_GLB_SHORT_REPLY:
-		dev_err(hsw->dev, "ipc: error received message type %d header 0x%x not supported\n",
+		dev_err(hsw->dev, "error: message type %d header 0x%x\n",
 			type, header);
 		break;
 	case IPC_GLB_STREAM_MESSAGE:
@@ -876,7 +868,7 @@
 		handled = hsw_log_message(hsw, header);
 		break;
 	default:
-		dev_err(hsw->dev, "ipc: error received unexpected type %d hdr 0x%8.8x\n",
+		dev_err(hsw->dev, "error: unexpected type %d hdr 0x%8.8x\n",
 			type, header);
 		break;
 	}
@@ -903,8 +895,8 @@
 		/* Handle Immediate reply from DSP Core */
 		handled = hsw_process_reply(hsw, ipcx);
 
-		if (handled) {
-			/* clear DONE bit - tell DSP we have completed the operation */
+		if (handled > 0) {
+			/* clear DONE bit - tell DSP we have completed */
 			sst_dsp_shim_update_bits_unlocked(sst, SST_IPCX,
 				SST_IPCX_DONE, 0);
 
@@ -920,8 +912,8 @@
 		/* Handle Notification and Delayed reply from DSP Core */
 		handled = hsw_process_notification(hsw);
 
-		/* clear BUSY bit and set DONE bit - tell DSP we can accept new messages */
-		if (handled) {
+		/* clear BUSY bit and set DONE bit - accept new messages */
+		if (handled > 0) {
 			sst_dsp_shim_update_bits_unlocked(sst, SST_IPCD,
 				SST_IPCD_BUSY | SST_IPCD_DONE, SST_IPCD_DONE);
 
@@ -947,7 +939,7 @@
 	ret = ipc_tx_message_wait(hsw, IPC_GLB_TYPE(IPC_GLB_GET_FW_VERSION),
 		NULL, 0, version, sizeof(*version));
 	if (ret < 0)
-		dev_err(hsw->dev, "ipc: get version failed\n");
+		dev_err(hsw->dev, "error: get version failed\n");
 
 	return ret;
 }
@@ -965,7 +957,7 @@
 
 	ret = sst_hsw_stream_set_volume(hsw, stream, stage_id, channel, 0);
 	if (ret < 0) {
-		dev_err(hsw->dev, "failed to unmute stream %d channel %d\n",
+		dev_err(hsw->dev, "error: can't unmute stream %d channel %d\n",
 			stream->reply.stream_hw_id, channel);
 		return ret;
 	}
@@ -984,7 +976,7 @@
 	ret = sst_hsw_stream_set_volume(hsw, stream, stage_id, channel,
 		stream->mute_volume[channel]);
 	if (ret < 0) {
-		dev_err(hsw->dev, "failed to unmute stream %d channel %d\n",
+		dev_err(hsw->dev, "error: can't unmute stream %d channel %d\n",
 			stream->reply.stream_hw_id, channel);
 		return ret;
 	}
@@ -1004,8 +996,9 @@
 	return 0;
 }
 
-int sst_hsw_stream_set_volume_curve(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	 u64 curve_duration, enum sst_hsw_volume_curve curve)
+int sst_hsw_stream_set_volume_curve(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u64 curve_duration,
+	enum sst_hsw_volume_curve curve)
 {
 	/* curve duration in steps of 100ns */
 	stream->vol_req.curve_duration = curve_duration;
@@ -1015,8 +1008,8 @@
 }
 
 /* stream volume */
-int sst_hsw_stream_set_volume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 stage_id, u32 channel, u32 volume)
+int sst_hsw_stream_set_volume(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 volume)
 {
 	struct sst_hsw_ipc_volume_req *req;
 	u32 header;
@@ -1044,7 +1037,7 @@
 
 	ret = ipc_tx_message_wait(hsw, header, req, sizeof(*req), NULL, 0);
 	if (ret < 0) {
-		dev_err(hsw->dev, "ipc: set stream volume failed\n");
+		dev_err(hsw->dev, "error: set stream volume failed\n");
 		return ret;
 	}
 
@@ -1062,7 +1055,7 @@
 
 	ret = sst_hsw_mixer_set_volume(hsw, stage_id, channel, 0);
 	if (ret < 0) {
-		dev_err(hsw->dev, "failed to unmute mixer channel %d\n",
+		dev_err(hsw->dev, "error: failed to unmute mixer channel %d\n",
 			channel);
 		return ret;
 	}
@@ -1075,15 +1068,15 @@
 {
 	int ret;
 
-	hsw->mute[channel] = 0;
 	ret = sst_hsw_mixer_set_volume(hsw, stage_id, channel,
 		hsw->mixer_info.volume_register_address[channel]);
 	if (ret < 0) {
-		dev_err(hsw->dev, "failed to unmute mixer channel %d\n",
+		dev_err(hsw->dev, "error: failed to unmute mixer channel %d\n",
 			channel);
 		return ret;
 	}
 
+	hsw->mute[channel] = 0;
 	return 0;
 }
 
@@ -1094,7 +1087,8 @@
 		return -EINVAL;
 
 	sst_dsp_read(hsw->dsp, volume,
-		hsw->mixer_info.volume_register_address[channel], sizeof(*volume));
+		hsw->mixer_info.volume_register_address[channel],
+		sizeof(*volume));
 
 	return 0;
 }
@@ -1119,8 +1113,7 @@
 
 	trace_ipc_request("set mixer volume", volume);
 
-	/* set both at same time */
-	// TODO: mute not required as in db scale
+	/* set both at same time ? */
 	if (channel == 2) {
 		if (hsw->mute[0] && hsw->mute[1]) {
 			hsw->mute_volume[0] = hsw->mute_volume[1] = volume;
@@ -1132,6 +1125,7 @@
 		else
 			req.channel = 0xffffffff;
 	} else {
+		/* set only 1 channel */
 		if (hsw->mute[channel]) {
 			hsw->mute_volume[channel] = volume;
 			return 0;
@@ -1151,14 +1145,14 @@
 
 	ret = ipc_tx_message_wait(hsw, header, &req, sizeof(req), NULL, 0);
 	if (ret < 0) {
-		dev_err(hsw->dev, "ipc: set mixer volume failed\n");
+		dev_err(hsw->dev, "error: set mixer volume failed\n");
 		return ret;
 	}
 
 	return 0;
 }
 
-/* Stream API - TODO: rework mutexes, get ID from struct HSW */
+/* Stream API */
 struct sst_hsw_stream *sst_hsw_stream_new(struct sst_hsw *hsw, int id,
 	u32 (*notify_position)(struct sst_hsw_stream *stream, void *data),
 	void *data)
@@ -1198,7 +1192,7 @@
 	ret = ipc_tx_message_wait(hsw, header, &stream->free_req,
 		sizeof(stream->free_req), NULL, 0);
 	if (ret < 0) {
-		dev_err(hsw->dev, "ipc: free stream %d failed\n",
+		dev_err(hsw->dev, "error: free stream %d failed\n",
 			stream->free_req.stream_id);
 		return -EAGAIN;
 	}
@@ -1212,45 +1206,80 @@
 	return ret;
 }
 
-int sst_hsw_stream_set_bits(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum bitdepth bits)
+int sst_hsw_stream_set_bits(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, enum sst_hsw_bitdepth bits)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set bits\n");
+		return -EINVAL;
+	}
+
 	stream->request.format.bitdepth = bits;
 	return 0;
 }
 
-int sst_hsw_stream_set_channels(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u8 channels)
+int sst_hsw_stream_set_channels(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, int channels)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set channels\n");
+		return -EINVAL;
+	}
+
+	/* stereo is only supported atm */
+	if (channels != 2)
+		return -EINVAL;
+
 	stream->request.format.ch_num = channels;
 	return 0;
 }
 
-int sst_hsw_stream_set_rate(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum sample_frequency rate)
+int sst_hsw_stream_set_rate(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, int rate)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set rate\n");
+		return -EINVAL;
+	}
+
 	stream->request.format.frequency = rate;
 	return 0;
 }
 
-int sst_hsw_stream_set_map_config(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 map, enum sst_hsw_channel_config config)
+int sst_hsw_stream_set_map_config(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 map,
+	enum sst_hsw_channel_config config)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set map\n");
+		return -EINVAL;
+	}
+
 	stream->request.format.map = map;
 	stream->request.format.config = config;
 	return 0;
 }
 
-int sst_hsw_stream_set_style(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum sst_hsw_interleaving style)
+int sst_hsw_stream_set_style(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, enum sst_hsw_interleaving style)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set style\n");
+		return -EINVAL;
+	}
+
 	stream->request.format.style = style;
 	return 0;
 }
 
-int sst_hsw_stream_set_valid(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 bits)
+int sst_hsw_stream_set_valid(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 bits)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set valid bits\n");
+		return -EINVAL;
+	}
+
 	stream->request.format.valid_bit = bits;
 	return 0;
 }
@@ -1261,6 +1290,11 @@
 	enum sst_hsw_stream_type stream_type,
 	enum sst_hsw_stream_format format_id)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set format\n");
+		return -EINVAL;
+	}
+
 	stream->request.path_id = path_id;
 	stream->request.stream_type = stream_type;
 	stream->request.format_id = format_id;
@@ -1274,6 +1308,11 @@
 	u32 ring_pt_address, u32 num_pages,
 	u32 ring_size, u32 ring_offset, u32 ring_first_pfn)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for buffer\n");
+		return -EINVAL;
+	}
+
 	stream->request.ringinfo.ring_pt_address = ring_pt_address;
 	stream->request.ringinfo.num_pages = num_pages;
 	stream->request.ringinfo.ring_size = ring_size;
@@ -1291,6 +1330,12 @@
 {
 	struct sst_hsw_module_map *map = &stream->request.map;
 
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set module\n");
+		return -EINVAL;
+	}
+
+	/* only support initial module atm */
 	map->module_entries_count = 1;
 	map->module_entries[0].module_id = module_id;
 	map->module_entries[0].entry_point = entry_point;
@@ -1301,6 +1346,11 @@
 int sst_hsw_stream_set_pmemory_info(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 offset, u32 size)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set pmem\n");
+		return -EINVAL;
+	}
+
 	stream->request.persistent_mem.offset = offset;
 	stream->request.persistent_mem.size = size;
 
@@ -1310,6 +1360,11 @@
 int sst_hsw_stream_set_smemory_info(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 offset, u32 size)
 {
+	if (stream->commited) {
+		dev_err(hsw->dev, "error: stream committed for set smem\n");
+		return -EINVAL;
+	}
+
 	stream->request.scratch_mem.offset = offset;
 	stream->request.scratch_mem.size = size;
 
@@ -1330,7 +1385,7 @@
 	ret = ipc_tx_message_wait(hsw, header, str_req, sizeof(*str_req),
 		reply, sizeof(*reply));
 	if (ret < 0) {
-		dev_err(hsw->dev, "ipc: error stream commit failed\n");
+		dev_err(hsw->dev, "error: stream commit failed\n");
 		return ret;
 	}
 
@@ -1340,44 +1395,48 @@
 	return 0;
 }
 
-/* Stream Information */
-int sst_hsw_stream_get_hw_id(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
+/* Stream Information - these calls could be inline but we want the IPC
+ ABI to be opaque to client PCM drivers to cope with any future ABI changes */
+int sst_hsw_stream_get_hw_id(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream)
 {
 	return stream->reply.stream_hw_id;
 }
 
-int sst_hsw_stream_get_mixer_id(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
+int sst_hsw_stream_get_mixer_id(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream)
 {
 	return stream->reply.mixer_hw_id;
 }
 
-int sst_hsw_stream_get_read_reg(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	 u32 *reg)
+u32 sst_hsw_stream_get_read_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream)
 {
-	*reg = stream->reply.read_position_register_address;
-	return 0;
+	return stream->reply.read_position_register_address;
 }
 
-int sst_hsw_stream_get_pointer_reg(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	 u32 *reg)
+u32 sst_hsw_stream_get_pointer_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream)
 {
-	*reg = stream->reply.presentation_position_register_address;
-	return 0;
+	return stream->reply.presentation_position_register_address;
 }
 
-/* These info are from Mixer stream info reply */
-int sst_hsw_stream_get_peak_reg(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	 u32 channel, u32 *reg)
+u32 sst_hsw_stream_get_peak_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel)
 {
-	*reg = stream->reply.peak_meter_register_address[channel];
-	return 0;
+	if (channel >= 2)
+		return 0;
+
+	return stream->reply.peak_meter_register_address[channel];
 }
 
-int sst_hsw_stream_get_vol_reg(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 channel, u32 *reg)
+u32 sst_hsw_stream_get_vol_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel)
 {
-	*reg = stream->reply.volume_register_address[channel];
-	return 0;
+	if (channel >= 2)
+		return 0;
+
+	return stream->reply.volume_register_address[channel];
 }
 
 int sst_hsw_mixer_get_info(struct sst_hsw *hsw)
@@ -1393,7 +1452,7 @@
 
 	ret = ipc_tx_message_wait(hsw, header, NULL, 0, reply, sizeof(*reply));
 	if (ret < 0) {
-		dev_err(hsw->dev, "ipc: get stream info failed\n");
+		dev_err(hsw->dev, "error: get stream info failed\n");
 		return ret;
 	}
 
@@ -1418,7 +1477,8 @@
 }
 
 /* Stream ALSA trigger operations */
-int sst_hsw_stream_pause(struct sst_hsw *hsw, struct sst_hsw_stream *stream, int wait)
+int sst_hsw_stream_pause(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	int wait)
 {
 	int ret;
 
@@ -1427,21 +1487,23 @@
 	ret = sst_hsw_stream_operations(hsw, IPC_STR_PAUSE,
 		stream->reply.stream_hw_id, wait);
 	if (ret < 0)
-		dev_err(hsw->dev, "ipc: error failed to pause stream %d\n",
+		dev_err(hsw->dev, "error: failed to pause stream %d\n",
 			stream->reply.stream_hw_id);
 
 	return ret;
 }
 
-int sst_hsw_stream_resume(struct sst_hsw *hsw, struct sst_hsw_stream *stream, int wait)
+int sst_hsw_stream_resume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	int wait)
 {
 	int ret;
 
 	trace_ipc_request("stream resume", stream->reply.stream_hw_id);
 
-	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESUME, stream->reply.stream_hw_id, wait);
+	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESUME,
+		stream->reply.stream_hw_id, wait);
 	if (ret < 0)
-		dev_err(hsw->dev, "ipc: error failed to resume stream %d\n",
+		dev_err(hsw->dev, "error: failed to resume stream %d\n",
 			stream->reply.stream_hw_id);
 
 	return ret;
@@ -1459,28 +1521,30 @@
 	while (stream->running && tries--)
 		msleep(1);
 	if (!tries) {
-		dev_err(hsw->dev, "ipc: can't reset stream %d still running\n",
+		dev_err(hsw->dev, "error: reset stream %d still running\n",
 			stream->reply.stream_hw_id);
 		return -EINVAL;
 	}
 
 	trace_ipc_request("stream reset", stream->reply.stream_hw_id);
 
-	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESET, stream->reply.stream_hw_id, 1);
+	ret = sst_hsw_stream_operations(hsw, IPC_STR_RESET,
+		stream->reply.stream_hw_id, 1);
 	if (ret < 0)
-		dev_err(hsw->dev, "ipc: error failed to reset stream %d\n",
+		dev_err(hsw->dev, "error: failed to reset stream %d\n",
 			stream->reply.stream_hw_id);
 	return ret;
 }
 
 /* Stream pointer positions */
-int sst_hsw_get_dsp_position(struct sst_hsw *hsw, struct sst_hsw_stream *stream)
+int sst_hsw_get_dsp_position(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream)
 {
 	return stream->rpos.position;
 }
 
-int sst_hsw_stream_set_write_position(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	u32 stage_id, u32 position)
+int sst_hsw_stream_set_write_position(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 stage_id, u32 position)
 {
 	u32 header;
 	int ret;
@@ -1494,15 +1558,16 @@
 	header |= (stage_id << IPC_STG_ID_SHIFT);
 	stream->wpos.position = position;
 
-	ret = ipc_tx_message_nowait(hsw, header, &stream->wpos, sizeof(stream->wpos));
+	ret = ipc_tx_message_nowait(hsw, header, &stream->wpos,
+		sizeof(stream->wpos));
 	if (ret < 0)
-		dev_err(hsw->dev, "ipc: error stream %d set position %d failed\n",
+		dev_err(hsw->dev, "error: stream %d set position %d failed\n",
 			stream->reply.stream_hw_id, position);
 
 	return ret;
 }
 
-/* HW port config */
+/* physical BE config */
 int sst_hsw_device_set_config(struct sst_hsw *hsw,
 	enum sst_hsw_device_id dev, enum sst_hsw_device_mclk mclk,
 	enum sst_hsw_device_mode mode, u32 clock_divider)
@@ -1522,32 +1587,14 @@
 
 	header = IPC_GLB_TYPE(IPC_GLB_SET_DEVICE_FORMATS);
 
-	ret = ipc_tx_message_wait(hsw, header, &config, sizeof(config), NULL, 0);
+	ret = ipc_tx_message_wait(hsw, header, &config, sizeof(config),
+		NULL, 0);
 	if (ret < 0)
-		dev_err(hsw->dev, "ipc: error set device formats failed\n");
+		dev_err(hsw->dev, "error: set device formats failed\n");
 
 	return ret;
 }
-EXPORT_SYMBOL(sst_hsw_device_set_config);
-
-void sst_hsw_dx_state_dump(struct sst_hsw *hsw)
-{
-	u32 item, size, offset, source;
-	int ret;
-
-	trace_ipc_request("PM state dump. Items #", SST_HSW_MAX_DX_REGIONS);
-
-	for (item = 0; item < SST_HSW_MAX_DX_REGIONS; item++) {
-		ret = sst_hsw_dx_get_state(hsw, item, &offset, &size, &source);
-		if (ret < 0) {
-			dev_err(hsw->dev, "ipc: failed to get dx state item %d\n",
-				item);
-			return;
-		}
-		dev_dbg(hsw->dev, " Item[%d] offset[%x] - size[%x] - source[%x]\n",
-				item, offset, size, source);
-	}
-}
+EXPORT_SYMBOL_GPL(sst_hsw_device_set_config);
 
 /* DX Config */
 int sst_hsw_dx_set_state(struct sst_hsw *hsw,
@@ -1599,301 +1646,6 @@
 	return 0;
 }
 
-static int fw_log_open_data(struct inode *inode, struct file *file)
-{
-	struct sst_hsw_log_stream *log_stream = inode->i_private;
-	struct sst_hsw_ipc_debug_log_enable_req req;
-	u32 header;
-	int ret;
-
-	file->private_data = inode->i_private;
-
-	req.ringinfo.ring_pt_address = virt_to_phys(log_stream->ring_descr);
-	req.ringinfo.num_pages = log_stream->pages;
-	req.ringinfo.ring_size = log_stream->size;
-	req.ringinfo.ring_offset = 0;
-	req.ringinfo.ring_first_pfn = virt_to_phys(log_stream->dma_area);
-	memcpy(req.config, log_stream->config, sizeof(log_stream->config));
-
-	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
-	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_ENABLE_LOG);
-	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
-
-	dev_info(log_stream->hsw->dev, "send ipc to enable fw log\n");
-
-	ret = ipc_tx_message_wait(log_stream->hsw, header, &req, sizeof(req), NULL, 0);
-	if (ret < 0) {
-		dev_err(log_stream->hsw->dev, "ipc: enable fw log failed\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-static int fw_log_release(struct inode *inode, struct file *file)
-{
-	struct sst_hsw_log_stream *log_stream = inode->i_private;
-	u32 header;
-	int ret;
-
-	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
-	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_DISABLE_LOG);
-	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
-
-	dev_info(log_stream->hsw->dev, "send ipc to disable fw log\n");
-
-	ret = ipc_tx_message_nowait(log_stream->hsw, header, NULL, 0);
-	if (ret < 0) {
-		dev_err(log_stream->hsw->dev, "ipc: disable fw log failed, returned %d\n", ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static ssize_t fw_log_copy_to_user(struct sst_hsw_log_stream *log_stream,
-					char __user *user_buf, size_t count)
-{
-	/* check for reader buffer wrap */
-	if (log_stream->reader_pos + count > log_stream->size) {
-		size_t size = log_stream->size - log_stream->reader_pos;
-
-		/* wrap */
-		if (copy_to_user(user_buf,
-			log_stream->dma_area + log_stream->reader_pos, size))
-			return -EFAULT;
-
-		if (copy_to_user(user_buf + size,
-			log_stream->dma_area, count - size))
-			return -EFAULT;
-
-		log_stream->reader_pos = count - size;
-
-		return count;
-
-	} else {
-		/* no wrap */
-		if (copy_to_user(user_buf,
-			log_stream->dma_area + log_stream->reader_pos, count))
-			return -EFAULT;
-
-		log_stream->reader_pos += count;
-
-		return count;
-	}
-}
-
-static ssize_t fw_log_read_data(struct file *file, char __user *user_buf,
-					size_t count, loff_t *ppos)
-{
-	struct sst_hsw_log_stream *log_stream = file->private_data;
-	size_t bytes;
-	ssize_t ret = 0;
-
-	do {
-		mutex_lock(&log_stream->rw_mutex);
-
-		if (log_stream->last_pos < log_stream->curr_pos) {
-			if (log_stream->reader_pos < log_stream->last_pos
-			|| log_stream->reader_pos > log_stream->curr_pos)
-
-				log_stream->reader_pos = log_stream->last_pos;
-		} else {
-			if (log_stream->reader_pos < log_stream->last_pos
-			&& log_stream->reader_pos > log_stream->curr_pos)
-
-				log_stream->reader_pos = log_stream->last_pos;
-		}
-
-		if (log_stream->curr_pos >= log_stream->reader_pos) {
-			bytes = log_stream->curr_pos - log_stream->reader_pos;
-		} else {
-			bytes = log_stream->curr_pos + log_stream->size -
-				log_stream->reader_pos;
-		}
-		mutex_unlock(&log_stream->rw_mutex);
-
-		if (bytes > count)
-			bytes = count;
-
-		if (bytes > 0) {
-			ret = fw_log_copy_to_user(log_stream, user_buf, bytes);
-			break;
-		}
-
-		if (file->f_flags & O_NONBLOCK) {
-			ret = -EAGAIN;
-			break;
-		}
-
-		if (wait_event_interruptible(log_stream->readers_wait_q,
-			log_stream->curr_pos != log_stream->reader_pos)) {
-			ret = -ERESTARTSYS;
-			break;
-		}
-
-	} while (1);
-
-	return ret;
-}
-
-static const struct file_operations fw_log_fops = {
-	.open = fw_log_open_data,
-	.read = fw_log_read_data,
-	.release = fw_log_release,
-};
-
-static int fw_log_config_open(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static ssize_t fw_log_config_read(struct file *file, char __user *buffer,
-						size_t count, loff_t *ppos)
-{
-	struct sst_hsw_log_stream *log_stream = file->private_data;
-	int max_size = sizeof(log_stream->config);
-
-	if (*ppos >= max_size)
-		return 0;
-	if (*ppos + count > max_size)
-		count = max_size - *ppos;
-
-	if (copy_to_user(buffer, log_stream->config + *ppos, count))
-		return -EFAULT;
-
-	*ppos += count;
-
-	return count;
-}
-
-static ssize_t fw_log_config_write(struct file *file, const char __user *buffer,
-						size_t count, loff_t *ppos)
-{
-	struct sst_hsw_log_stream *log_stream = file->private_data;
-	struct sst_hsw_ipc_debug_log_enable_req req;
-	u32 header;
-	int max_size = sizeof(log_stream->config);
-	int ret;
-
-	if (*ppos >= max_size)
-		return 0;
-	if (*ppos + count > max_size)
-		count = max_size - *ppos;
-
-	if (copy_from_user(log_stream->config + *ppos, buffer, count))
-		return -EFAULT;
-
-	*ppos += count;
-
-	req.ringinfo.ring_pt_address = virt_to_phys(log_stream->ring_descr);
-	req.ringinfo.num_pages = log_stream->pages;
-	req.ringinfo.ring_size = log_stream->size;
-	req.ringinfo.ring_offset = 0;
-	req.ringinfo.ring_first_pfn = virt_to_phys(log_stream->dma_area);
-	memcpy(req.config, log_stream->config, sizeof(log_stream->config));
-
-	header = IPC_GLB_TYPE(IPC_GLB_DEBUG_LOG_MESSAGE);
-	header |= IPC_LOG_OP_TYPE(IPC_DEBUG_ENABLE_LOG);
-	header |= IPC_LOG_ID(SST_HSW_GLOBAL_LOG);
-
-	dev_info(log_stream->hsw->dev, "send ipc to configure fw log\n");
-
-	ret = ipc_tx_message_nowait(log_stream->hsw, header, &req, sizeof(req));
-	if (ret < 0) {
-		dev_err(log_stream->hsw->dev, "ipc: setting config fw log failed\n");
-		return ret;
-	}
-
-	return count;
-}
-
-static const struct file_operations fw_log_config_fops = {
-	.open = fw_log_config_open,
-	.read = fw_log_config_read,
-	.write = fw_log_config_write,
-};
-
-/* debug control - sysFS */
-int sst_hsw_dbg_enable(struct sst_hsw *hsw, struct dentry *debugfs_card_root)
-{
-	struct sst_hsw_log_stream *log_stream = &hsw->log_stream;
-	int i;
-
-	memset(log_stream->config, 0xFF, sizeof(log_stream->config));
-	log_stream->size = 32 * PAGE_SIZE;
-	log_stream->hsw = hsw;
-
-	log_stream->dma_area = dma_alloc_coherent(log_stream->hsw->dev,
-		log_stream->size, &log_stream->dma_addr, GFP_KERNEL);
-	dev_info(log_stream->hsw->dev,
-		"alloc dma buffer: area=%p, addr=%p, size=%d\n",
-		(void *)log_stream->dma_area,
-		(void *)log_stream->dma_addr,
-		log_stream->size);
-
-	if (!log_stream->dma_area) {
-		dev_err(log_stream->hsw->dev, "alloc dma buffer failed\n");
-		return -EINVAL;
-	}
-
-	log_stream->ring_descr = kzalloc(PAGE_SIZE, GFP_DMA);
-	if (!log_stream->ring_descr) {
-		dev_err(log_stream->hsw->dev, "alloc ring descriptor failed\n");
-		return -EINVAL;
-	}
-
-	if (log_stream->size % PAGE_SIZE)
-		log_stream->pages = (log_stream->size / PAGE_SIZE) + 1;
-	else
-		log_stream->pages = log_stream->size / PAGE_SIZE;
-
-	dev_info(log_stream->hsw->dev,
-		"generating page table for %p size 0x%x pages %d\n",
-		log_stream->dma_area, log_stream->size, log_stream->pages);
-
-	for (i = 0; i < log_stream->pages; i++) {
-		u32 idx = (((i << 2) + i)) >> 1;
-		u32 pfn = (virt_to_phys(log_stream->dma_area + i * PAGE_SIZE))
-				>> PAGE_SHIFT;
-		u32 *pg_table;
-
-		pg_table = (u32 *)(log_stream->ring_descr + idx);
-
-		if (i & 1)
-			*pg_table |= (pfn << 4);
-		else
-			*pg_table |= pfn;
-	}
-
-	INIT_WORK(&log_stream->notify_work, hsw_log_notification_work);
-	init_waitqueue_head(&log_stream->readers_wait_q);
-	mutex_init(&log_stream->rw_mutex);
-
-	if (!debugfs_create_file("fw_log", 0444, debugfs_card_root,
-			&hsw->log_stream, &fw_log_fops))
-		pr_warn("ASoC: Failed to create fw_log debugfs file\n");
-
-	if (!debugfs_create_file("fw_log_config", 0644, debugfs_card_root,
-			&hsw->log_stream, &fw_log_config_fops))
-		pr_warn("ASoC: Failed to create fw_log_config debugfs file\n");
-
-	return 0;
-}
-EXPORT_SYMBOL(sst_hsw_dbg_enable);
-
-int sst_hsw_dbg_disable(struct sst_hsw *hsw, struct sst_hsw_stream *stream, u32 log_id)
-{
-	return 0;
-}
-
-int sst_hsw_dbg_log_dump(struct sst_hsw *hsw, struct sst_hsw_stream *stream, u32 log_id,
-	struct sst_hsw_ipc_debug_log_reply *reply)
-{
-	return 0;
-}
-
 static int msg_empty_list_init(struct sst_hsw *hsw)
 {
 	int i;
@@ -1932,7 +1684,6 @@
 	struct sst_hsw_ipc_fw_version version;
 	struct sst_hsw *hsw;
 	struct sst_fw *hsw_sst_fw;
-	const struct firmware *fw;
 	int ret;
 
 	dev_dbg(dev, "initialising Audio DSP IPC\n");
@@ -1960,7 +1711,7 @@
 					   dev_name(hsw->dev));
 	if (IS_ERR(hsw->tx_thread)) {
 		ret = PTR_ERR(hsw->tx_thread);
-		dev_err(hsw->dev, "error failed to create message TX task\n");
+		dev_err(hsw->dev, "error: failed to create message TX task\n");
 		goto list_err;
 	}
 	init_kthread_work(&hsw->kwork, ipc_tx_msgs);
@@ -1974,18 +1725,11 @@
 		goto list_err;
 	}
 
-	/* load DSP FW */
-	ret = request_firmware(&fw, pdata->fw_filename, dev);
-	if (ret < 0) {
-		dev_err(dev, "request firmware %s failed %d\n",
-			pdata->fw_filename, ret);
-		goto fw_err;
-	}
-
 	/* keep the DSP in reset state for base FW loading */
 	sst_dsp_reset(hsw->dsp);
 
-	hsw_sst_fw = sst_fw_new(hsw->dsp, fw, hsw);
+	hsw_sst_fw = sst_fw_new(hsw->dsp, pdata->fw, hsw);
+
 	if (hsw_sst_fw == NULL) {
 		ret = -ENODEV;
 		dev_err(dev, "error: failed to load firmware\n");
@@ -1998,7 +1742,7 @@
 		msecs_to_jiffies(IPC_BOOT_MSECS));
 	if (ret == 0) {
 		ret = -EIO;
-		dev_err(hsw->dev, "ipc: error DSP boot timeout\n");
+		dev_err(hsw->dev, "error: ADSP boot timeout\n");
 		goto boot_err;
 	}
 
@@ -2010,7 +1754,7 @@
 	/* get the globalmixer */
 	ret = sst_hsw_mixer_get_info(hsw);
 	if (ret < 0) {
-		dev_err(hsw->dev, "failed to get stream info\n");
+		dev_err(hsw->dev, "error: failed to get stream info\n");
 		goto boot_err;
 	}
 
@@ -2026,7 +1770,7 @@
 list_err:
 	return ret;
 }
-EXPORT_SYMBOL(sst_hsw_dsp_init);
+EXPORT_SYMBOL_GPL(sst_hsw_dsp_init);
 
 void sst_hsw_dsp_free(struct device *dev, struct sst_pdata *pdata)
 {
@@ -2038,4 +1782,4 @@
 	kfree(hsw->scratch);
 	kfree(hsw->msg);
 }
-EXPORT_SYMBOL(sst_hsw_dsp_free);
+EXPORT_SYMBOL_GPL(sst_hsw_dsp_free);
Index: b/sound/soc/intel/sst-haswell-ipc.h
===================================================================
--- a/sound/soc/intel/sst-haswell-ipc.h	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-haswell-ipc.h	2016-06-02 12:28:43.397170197 +0800
@@ -14,18 +14,33 @@
  *
  */
 
-#ifndef __SST_ADSP_IPC_H
-#define __SST_ADSP_IPC_H
+#ifndef __SST_HASWELL_IPC_H
+#define __SST_HASWELL_IPC_H
 
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
 
-#define SST_HSW_NO_CHANNELS	2
-#define SST_HSW_MAX_DX_REGIONS	14
+#define SST_HSW_NO_CHANNELS		2
+#define SST_HSW_MAX_DX_REGIONS		14
 
-#define SST_HSW_FW_LOG_CONFIG_DWORDS 12
-#define SST_HSW_GLOBAL_LOG 15
+#define SST_HSW_FW_LOG_CONFIG_DWORDS	12
+#define SST_HSW_GLOBAL_LOG		15
+
+/**
+ * Upfront defined maximum message size that is
+ * expected by the in/out communication pipes in FW.
+ */
+#define SST_HSW_IPC_MAX_PAYLOAD_SIZE	400
+#define SST_HSW_MAX_INFO_SIZE		64
+#define SST_HSW_BUILD_HASH_LENGTH	40
+
+struct sst_hsw;
+struct sst_hsw_stream;
+struct sst_hsw_log_stream;
+struct sst_pdata;
+struct sst_module;
+extern struct sst_ops haswell_ops;
 
 /* Stream Allocate Path ID */
 enum sst_hsw_stream_path_id {
@@ -70,11 +85,6 @@
 	SST_HSW_DEVICE_CLOCK_SLAVE   = 0,
 	SST_HSW_DEVICE_CLOCK_MASTER  = 1,
 };
-/* Audio Curve Type */
-enum sst_hsw_ipc_volume_curve_type {
-	SST_HSW_AUDIO_CURVE_TYPE_NONE = 0,
-	SST_HSW_AUDIO_CURVE_TYPE_FADE = 1,
-};
 
 /* DX Power State */
 enum sst_hsw_dx_state {
@@ -107,8 +117,8 @@
 
 /* Sample ordering */
 enum sst_hsw_interleaving {
-	SST_HSW_INTERLEAVING_PER_CHANNEL = 0, /* [s1_ch1...s1_chN,...,sM_ch1...sM_chN] */
-	SST_HSW_INTERLEAVING_PER_SAMPLE  = 1, /* [s1_ch1...sM_ch1,...,s1_chN...sM_chN] */
+	SST_HSW_INTERLEAVING_PER_CHANNEL = 0,
+	SST_HSW_INTERLEAVING_PER_SAMPLE  = 1,
 };
 
 /* Channel indices */
@@ -125,396 +135,271 @@
 
 /* List of supported channel maps. */
 enum sst_hsw_channel_config {
-	SST_HSW_CHANNEL_CONFIG_MONO      = 0, /**< One channel only. */
-	SST_HSW_CHANNEL_CONFIG_STEREO    = 1, /**< L & R. */
-	SST_HSW_CHANNEL_CONFIG_2_POINT_1 = 2, /**< L, R & LFE; PCM only. */
-	SST_HSW_CHANNEL_CONFIG_3_POINT_0 = 3, /**< L, C & R; MP3 & AAC only. */
-	SST_HSW_CHANNEL_CONFIG_3_POINT_1 = 4, /**< L, C, R & LFE; PCM only. */
-	SST_HSW_CHANNEL_CONFIG_QUATRO    = 5, /**< L, R, Ls & Rs; PCM only. */
-	SST_HSW_CHANNEL_CONFIG_4_POINT_0 = 6, /**< L, C, R & Cs; MP3 & AAC only. */
-	SST_HSW_CHANNEL_CONFIG_5_POINT_0 = 7, /**< L, C, R, Ls & Rs. */
-	SST_HSW_CHANNEL_CONFIG_5_POINT_1 = 8, /**< L, C, R, Ls, Rs & LFE. */
-	SST_HSW_CHANNEL_CONFIG_DUAL_MONO = 9, /**< One channel replicated in two. */
-	SST_HSW_CHANNEL_CONFIG_INVALID
-};
-
-/* List of supported ADSP sample rates */
-enum sample_frequency {
-	SST_HSW_FS_8000HZ   = 8000,
-	SST_HSW_FS_11025HZ  = 11025,
-	SST_HSW_FS_12000HZ  = 12000, /** Mp3, AAC, SRC only. */
-	SST_HSW_FS_16000HZ  = 16000,
-	SST_HSW_FS_22050HZ  = 22050,
-	SST_HSW_FS_24000HZ  = 24000, /** Mp3, AAC, SRC only. */
-	SST_HSW_FS_32000HZ  = 32000,
-	SST_HSW_FS_44100HZ  = 44100,
-	SST_HSW_FS_48000HZ  = 48000, /**< Default. */
-	SST_HSW_FS_64000HZ  = 64000, /** AAC, SRC only. */
-	SST_HSW_FS_88200HZ  = 88200, /** AAC, SRC only. */
-	SST_HSW_FS_96000HZ  = 96000, /** AAC, SRC only. */
-	SST_HSW_FS_128000HZ = 128000, /** SRC only. */
-	SST_HSW_FS_176400HZ = 176400, /** SRC only. */
-	SST_HSW_FS_192000HZ = 192000, /** SRC only. */
-	SST_HSW_FS_INVALID
+	SST_HSW_CHANNEL_CONFIG_MONO      = 0, /* mono only. */
+	SST_HSW_CHANNEL_CONFIG_STEREO    = 1, /* L & R. */
+	SST_HSW_CHANNEL_CONFIG_2_POINT_1 = 2, /* L, R & LFE; PCM only. */
+	SST_HSW_CHANNEL_CONFIG_3_POINT_0 = 3, /* L, C & R; MP3 & AAC only. */
+	SST_HSW_CHANNEL_CONFIG_3_POINT_1 = 4, /* L, C, R & LFE; PCM only. */
+	SST_HSW_CHANNEL_CONFIG_QUATRO    = 5, /* L, R, Ls & Rs; PCM only. */
+	SST_HSW_CHANNEL_CONFIG_4_POINT_0 = 6, /* L, C, R & Cs; MP3 & AAC only. */
+	SST_HSW_CHANNEL_CONFIG_5_POINT_0 = 7, /* L, C, R, Ls & Rs. */
+	SST_HSW_CHANNEL_CONFIG_5_POINT_1 = 8, /* L, C, R, Ls, Rs & LFE. */
+	SST_HSW_CHANNEL_CONFIG_DUAL_MONO = 9, /* One channel replicated in two. */
+	SST_HSW_CHANNEL_CONFIG_INVALID,
 };
 
-/** List of supported bit depths. */
-enum bitdepth {
+/* List of supported bit depths. */
+enum sst_hsw_bitdepth {
 	SST_HSW_DEPTH_8BIT  = 8,
 	SST_HSW_DEPTH_16BIT = 16,
-	SST_HSW_DEPTH_24BIT = 24, /**< Default. */
+	SST_HSW_DEPTH_24BIT = 24, /* Default. */
 	SST_HSW_DEPTH_32BIT = 32,
 	SST_HSW_DEPTH_INVALID = 33,
 };
 
-struct sst_hsw;
-struct sst_hsw_stream;
-struct sst_hsw_log_stream;
-struct sst_pdata;
-struct sst_module;
-extern struct sst_ops haswell_ops;
-
-/**
- * Upfront defined maximum message size that is
- * expected by the in/out communication pipes in FW.
- */
-#define SST_HSW_IPC_MAX_PAYLOAD_SIZE	400
-#define SST_HSW_MAX_INFO_SIZE		64
-#define SST_HSW_BUILD_HASH_LENGTH	40
-
-struct sst_hsw_module_info {
-    uint8_t name[SST_HSW_MAX_INFO_SIZE];
-    uint8_t version[SST_HSW_MAX_INFO_SIZE];
-} __attribute__((packed));
-
-
-struct sst_hsw_transfer_info {
-    uint32_t destination;       //!< destination address
-    uint32_t reverse:1;         //!< if 1 data flows from destination
-    uint32_t size:31;           //!< transfer size in bytes. Negative value means reverse direction
-    uint16_t first_page_offset; //!< offset to data in the first page.
-    uint8_t  packed_pages[1];   //!< compressed array of page numbers. Each page occupies 24b.
-} __attribute__((packed));
-
-#if 0
-/**
-* Calculates variable size of TransferInfo payload.
-* pages_count is ceil((size+offset)/PAGE_SIZE)
-* size of packed_pages is ceil(pages_count * 2.5), as each page number occupies 20 bits (2.5 bytes)
-*/
-inline size_t PayloadSize(const TransferInfo* payload) {
-    uint16_t result=static_cast<uint16_t>((payload->size + payload->first_page_offset + 4095) >> 12); //pages_count
-    result = (result * 5 + 1) >> 1; //sizeof(packed_pages)
-    result += sizeof(*payload) - sizeof(payload->packed_pages); //add size of header
-    return result;
-}
-#endif
-
-struct sst_hsw_transfer_list {
-    uint32_t transfers_count;
-    struct sst_hsw_transfer_info transfers[1];
-} __attribute__((packed));
-
-#if 0
-/**
-* Calculates variable size of TransferList payload.
-* @return size Computed size in bytes or 0 if payload is corrupted)
-*/
-inline size_t PayloadSize(const TransferList* payload) {
-    size_t size = sizeof(*payload) - sizeof(payload->transfers);
-
-    for(uint32_t idx=0; idx<payload->transfers_count; ++idx)
-    {
-        const TransferInfo *current = reinterpret_cast<const TransferInfo*>(reinterpret_cast<const uint8_t*>(payload)+size);
-        if ((size += PayloadSize(current)) > IPC_MAX_PAYLOAD_SIZE)
-        {
-            return 0;
-        }
-    }
-    return size;
-}
-#endif
-
-/**
- * TODO: add pointer & data struct for sensory net & gramm memory regions.
- */
-struct sst_hsw_transfer_parameter
-{
-    uint32_t parameter_id;
-    uint32_t data_size;
-    union {
-        uint8_t data[1];
-        struct sst_hsw_transfer_list transfer_list; // SGL chain of physical 32bit addresses
-    };
-} __attribute__((packed));
-
-
-#if 0
-/**
-* Calculates variable size of Parameter payload.
-*/
-inline size_t PayloadSize(const Parameter* payload) {
-    return sizeof(*payload) + payload->data_size - 1;
-}
-
-#endif
-
-#define SST_HSW_IPC_MAX_PARAMETER_SIZE	\
-	(IPC_MAX_PAYLOAD_SIZE - sizeof(struct sst_hsw_transfer_parameter) - 1)
-
 enum sst_hsw_module_id {
 	SST_HSW_MODULE_BASE_FW = 0x0,
 	SST_HSW_MODULE_MP3     = 0x1,
 	SST_HSW_MODULE_AAC_5_1 = 0x2,
 	SST_HSW_MODULE_AAC_2_0 = 0x3,
 	SST_HSW_MODULE_SRC     = 0x4,
-	//MIN_MODULE_ID_AVAILABLE_THROUGH_API= 0x4,	// minimal module ID (including) that status can be set by FwModuleManager API
 	SST_HSW_MODULE_WAVES   = 0x5,
 	SST_HSW_MODULE_DOLBY   = 0x6,
 	SST_HSW_MODULE_BOOST   = 0x7,
 	SST_HSW_MODULE_LPAL    = 0x8,
 	SST_HSW_MODULE_DTS     = 0x9,
-	//MAX_MODULE_ID_AVAILABLE_THROUGH_API= 0x9,	// maximal module ID (including) that status can be set by FwModuleManager API
 	SST_HSW_MODULE_PCM_CAPTURE = 0xA,
 	SST_HSW_MODULE_PCM_SYSTEM = 0xB,
 	SST_HSW_MODULE_PCM_REFERENCE = 0xC,
 	SST_HSW_MODULE_PCM = 0xD,
 	SST_HSW_MODULE_BLUETOOTH_RENDER_MODULE = 0xE,
 	SST_HSW_MODULE_BLUETOOTH_CAPTURE_MODULE = 0xF,
-	MAX_MODULE_ID
+	SST_HSW_MAX_MODULE_ID,
 };
 
+enum sst_hsw_performance_action {
+	SST_HSW_PERF_START = 0,
+	SST_HSW_PERF_STOP = 1,
+};
+
+/* SST firmware module info */
+struct sst_hsw_module_info {
+	u8 name[SST_HSW_MAX_INFO_SIZE];
+	u8 version[SST_HSW_MAX_INFO_SIZE];
+} __attribute__((packed));
+
+/* Module entry point */
 struct sst_hsw_module_entry {
 	enum sst_hsw_module_id module_id;
-	uint32_t entry_point;
+	u32 entry_point;
 } __attribute__((packed));
 
+/* Module map - alignement matches DSP */
 struct sst_hsw_module_map {
-	uint8_t module_entries_count;
-        // list of all loaded modules necesary for stream
+	u8 module_entries_count;
 	struct sst_hsw_module_entry module_entries[1];
 } __attribute__((packed));
 
-#if 0
-    /**
-    * Calculates variable size of ModuleMap payload.
-    */
-    inline size_t PayloadSize(const ModuleMap* payload) {
-        return sizeof(*payload) + (payload->module_entries_count - 1)*sizeof(ModuleEntry);
-    }
-#endif
-
 struct sst_hsw_memory_info {
-	uint32_t offset;
-	uint32_t size;
+	u32 offset;
+	u32 size;
 } __attribute__((packed));
 
-    /*
-     * GetFxState Message Class
-     */
 struct sst_hsw_fx_enable {
 	struct sst_hsw_module_map module_map;
 	struct sst_hsw_memory_info persistent_mem;
 } __attribute__((packed));
 
-    /*
-     * GetFxParam Message Class
-     */
 struct sst_hsw_get_fx_param {
-	uint32_t parameter_id;
-	uint32_t param_size;
-} __attribute__((packed));
-
-enum sst_hsw_performance_action {
-	SST_HSW_PERF_START = 0,
-	SST_HSW_PERF_STOP = 1,
+	u32 parameter_id;
+	u32 param_size;
 } __attribute__((packed));
 
 struct sst_hsw_perf_action {
-	uint32_t action;
+	u32 action;
 } __attribute__((packed));
 
 struct sst_hsw_perf_data {
-	uint64_t timestamp;
-	uint64_t cycles;
-	uint64_t datatime;
+	u64 timestamp;
+	u64 cycles;
+	u64 datatime;
 } __attribute__((packed));
 
 /* FW version */
 struct sst_hsw_ipc_fw_version {
-	uint8_t build;
-	uint8_t minor;
-	uint8_t major;
-	uint8_t type;
-	uint8_t fw_build_hash[SST_HSW_BUILD_HASH_LENGTH];
-	uint32_t fw_log_providers_hash;
+	u8 build;
+	u8 minor;
+	u8 major;
+	u8 type;
+	u8 fw_build_hash[SST_HSW_BUILD_HASH_LENGTH];
+	u32 fw_log_providers_hash;
 } __attribute__((packed));
 
 /* Stream ring info */
 struct sst_hsw_ipc_stream_ring {
-	uint32_t ring_pt_address;
-	uint32_t num_pages;
-	uint32_t ring_size;
-	uint32_t ring_offset;
-	uint32_t ring_first_pfn;
+	u32 ring_pt_address;
+	u32 num_pages;
+	u32 ring_size;
+	u32 ring_offset;
+	u32 ring_first_pfn;
 } __attribute__((packed));
 
 /* Debug Dump Log Enable Request */
 struct sst_hsw_ipc_debug_log_enable_req {
 	struct sst_hsw_ipc_stream_ring ringinfo;
-	uint32_t config[SST_HSW_FW_LOG_CONFIG_DWORDS];
+	u32 config[SST_HSW_FW_LOG_CONFIG_DWORDS];
 } __attribute__((packed));
 
 /* Debug Dump Log Reply */
 struct sst_hsw_ipc_debug_log_reply {
-	uint32_t log_buffer_begining;
-	uint32_t log_buffer_size;
+	u32 log_buffer_begining;
+	u32 log_buffer_size;
 } __attribute__((packed));
 
 /* Stream glitch position */
 struct sst_hsw_ipc_stream_glitch_position {
-	uint32_t glitch_type;
-	uint32_t present_pos;
-	uint32_t write_pos;
+	u32 glitch_type;
+	u32 present_pos;
+	u32 write_pos;
 } __attribute__((packed));
 
 /* Stream get position */
 struct sst_hsw_ipc_stream_get_position {
-	uint32_t position;
-	uint32_t fw_cycle_count;
+	u32 position;
+	u32 fw_cycle_count;
 } __attribute__((packed));
 
 /* Stream set position */
 struct sst_hsw_ipc_stream_set_position {
-	uint32_t position;
-	uint32_t end_of_buffer;
+	u32 position;
+	u32 end_of_buffer;
 } __attribute__((packed));
 
 /* Stream Free Request */
 struct sst_hsw_ipc_stream_free_req {
-	uint8_t stream_id;
-	uint8_t reserved[3];
+	u8 stream_id;
+	u8 reserved[3];
 } __attribute__((packed));
 
 /* Set Volume Request */
 struct sst_hsw_ipc_volume_req {
-	uint32_t channel;
-	uint32_t target_volume;
-	uint64_t curve_duration;
-	uint32_t curve_type;
+	u32 channel;
+	u32 target_volume;
+	u64 curve_duration;
+	u32 curve_type;
 } __attribute__((packed));
 
 /* Device Configuration Request */
 struct sst_hsw_ipc_device_config_req {
-	uint32_t ssp_interface;
-	uint32_t clock_frequency;
-	uint32_t mode;
-	uint16_t clock_divider;
-	uint16_t reserved;
+	u32 ssp_interface;
+	u32 clock_frequency;
+	u32 mode;
+	u16 clock_divider;
+	u16 reserved;
 } __attribute__((packed));
 
 /* Audio Data formats */
 struct sst_hsw_audio_data_format_ipc {
-	uint32_t frequency;
-	uint32_t bitdepth;
-	uint32_t map;
-	uint32_t config;
-	uint32_t style;
-	uint8_t ch_num;
-	uint8_t valid_bit;
-	uint8_t reserved[2];
+	u32 frequency;
+	u32 bitdepth;
+	u32 map;
+	u32 config;
+	u32 style;
+	u8 ch_num;
+	u8 valid_bit;
+	u8 reserved[2];
 } __attribute__((packed));
 
 /* Stream Allocate Request */
 struct sst_hsw_ipc_stream_alloc_req {
-	uint8_t path_id;
-	uint8_t stream_type;
-	uint8_t format_id;
-	uint8_t reserved;
+	u8 path_id;
+	u8 stream_type;
+	u8 format_id;
+	u8 reserved;
 	struct sst_hsw_audio_data_format_ipc format;
 	struct sst_hsw_ipc_stream_ring ringinfo;
 	struct sst_hsw_module_map map;
 	struct sst_hsw_memory_info persistent_mem;
 	struct sst_hsw_memory_info scratch_mem;
-	uint32_t number_of_notifications;
+	u32 number_of_notifications;
 } __attribute__((packed));
 
 /* Stream Allocate Reply */
 struct sst_hsw_ipc_stream_alloc_reply {
-	uint32_t stream_hw_id;
-	uint32_t mixer_hw_id; // returns rate ????
-	uint32_t read_position_register_address;
-	uint32_t presentation_position_register_address;
-	uint32_t peak_meter_register_address[SST_HSW_NO_CHANNELS];
-	uint32_t volume_register_address[SST_HSW_NO_CHANNELS];
+	u32 stream_hw_id;
+	u32 mixer_hw_id; // returns rate ????
+	u32 read_position_register_address;
+	u32 presentation_position_register_address;
+	u32 peak_meter_register_address[SST_HSW_NO_CHANNELS];
+	u32 volume_register_address[SST_HSW_NO_CHANNELS];
 } __attribute__((packed));
 
 /* Get Mixer Stream Info */
 struct sst_hsw_ipc_stream_info_reply {
-	uint32_t mixer_hw_id;
-	uint32_t peak_meter_register_address[SST_HSW_NO_CHANNELS];
-	uint32_t volume_register_address[SST_HSW_NO_CHANNELS];
+	u32 mixer_hw_id;
+	u32 peak_meter_register_address[SST_HSW_NO_CHANNELS];
+	u32 volume_register_address[SST_HSW_NO_CHANNELS];
 } __attribute__((packed));
 
 /* DX State Request */
 struct sst_hsw_ipc_dx_req {
-	uint8_t state;
-	uint8_t reserved[3];
+	u8 state;
+	u8 reserved[3];
 } __attribute__((packed));
 
 /* DX State Reply Memory Info Item */
 struct sst_hsw_ipc_dx_memory_item {
-	uint32_t offset;
-	uint32_t size;
-	uint32_t source;
+	u32 offset;
+	u32 size;
+	u32 source;
 } __attribute__((packed));
 
 /* DX State Reply */
 struct sst_hsw_ipc_dx_reply {
-	uint32_t entries_no;
+	u32 entries_no;
 	struct sst_hsw_ipc_dx_memory_item mem_info[SST_HSW_MAX_DX_REGIONS];
 } __attribute__((packed));
 
 struct sst_hsw_ipc_fw_version;
 
 /* SST Init & Free */
-struct sst_hsw *sst_hsw_new(struct device *dev, const uint8_t *fw, size_t fw_length,
-	uint32_t fw_offset);
+struct sst_hsw *sst_hsw_new(struct device *dev, const u8 *fw, size_t fw_length,
+	u32 fw_offset);
 void sst_hsw_free(struct sst_hsw *hsw);
 int sst_hsw_fw_get_version(struct sst_hsw *hsw,
 	struct sst_hsw_ipc_fw_version *version);
-uint32_t create_channel_map(enum sst_hsw_channel_config config);
+u32 create_channel_map(enum sst_hsw_channel_config config);
 
 /* Stream Mixer Controls - */
 int sst_hsw_stream_mute(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t stage_id, uint32_t channel);
+	u32 stage_id, u32 channel);
 int sst_hsw_stream_unmute(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t stage_id, uint32_t channel);
+	u32 stage_id, u32 channel);
 
-int sst_hsw_stream_set_volume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t stage_id, uint32_t channel, uint32_t volume);
-int sst_hsw_stream_get_volume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t stage_id, uint32_t channel, uint32_t *volume);
+int sst_hsw_stream_set_volume(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 volume);
+int sst_hsw_stream_get_volume(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 stage_id, u32 channel, u32 *volume);
 
 int sst_hsw_stream_set_volume_curve(struct sst_hsw *hsw,
-	struct sst_hsw_stream *stream, uint64_t curve_duration,
+	struct sst_hsw_stream *stream, u64 curve_duration,
 	enum sst_hsw_volume_curve curve);
 
 /* Global Mixer Controls - */
-int sst_hsw_mixer_mute(struct sst_hsw *hsw, uint32_t stage_id, uint32_t channel);
-int sst_hsw_mixer_unmute(struct sst_hsw *hsw, uint32_t stage_id, uint32_t channel);
+int sst_hsw_mixer_mute(struct sst_hsw *hsw, u32 stage_id, u32 channel);
+int sst_hsw_mixer_unmute(struct sst_hsw *hsw, u32 stage_id, u32 channel);
 
-int sst_hsw_mixer_set_volume(struct sst_hsw *hsw, uint32_t stage_id, uint32_t channel,
-	uint32_t volume);
-int sst_hsw_mixer_get_volume(struct sst_hsw *hsw, uint32_t stage_id, uint32_t channel,
-	uint32_t *volume);
+int sst_hsw_mixer_set_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
+	u32 volume);
+int sst_hsw_mixer_get_volume(struct sst_hsw *hsw, u32 stage_id, u32 channel,
+	u32 *volume);
 
 int sst_hsw_mixer_set_volume_curve(struct sst_hsw *hsw,
-	uint64_t curve_duration, enum sst_hsw_volume_curve curve);
+	u64 curve_duration, enum sst_hsw_volume_curve curve);
 
 /* Stream API */
 struct sst_hsw_stream *sst_hsw_stream_new(struct sst_hsw *hsw, int id,
-	uint32_t (*get_write_position)(struct sst_hsw_stream *stream, void *data),
+	u32 (*get_write_position)(struct sst_hsw_stream *stream, void *data),
 	void *data);
 
 int sst_hsw_stream_free(struct sst_hsw *hsw, struct sst_hsw_stream *stream);
@@ -526,21 +411,22 @@
 	enum sst_hsw_stream_format format_id);
 
 int sst_hsw_stream_buffer(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t ring_pt_address, uint32_t num_pages,
-	uint32_t ring_size, uint32_t ring_offset, uint32_t ring_first_pfn);
+	u32 ring_pt_address, u32 num_pages,
+	u32 ring_size, u32 ring_offset, u32 ring_first_pfn);
 
 int sst_hsw_stream_commit(struct sst_hsw *hsw, struct sst_hsw_stream *stream);
 
 int sst_hsw_stream_set_valid(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t bits);
+	u32 bits);
 int sst_hsw_stream_set_rate(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum sample_frequency rate);
+	int rate);
 int sst_hsw_stream_set_bits(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	enum bitdepth bits);
-int sst_hsw_stream_set_channels(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint8_t channels);
-int sst_hsw_stream_set_map_config(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t map, enum sst_hsw_channel_config config);
+	enum sst_hsw_bitdepth bits);
+int sst_hsw_stream_set_channels(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, int channels);
+int sst_hsw_stream_set_map_config(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 map,
+	enum sst_hsw_channel_config config);
 int sst_hsw_stream_set_style(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
 	enum sst_hsw_interleaving style);
 int sst_hsw_stream_set_module_info(struct sst_hsw *hsw,
@@ -550,31 +436,47 @@
 	struct sst_hsw_stream *stream, u32 offset, u32 size);
 int sst_hsw_stream_set_smemory_info(struct sst_hsw *hsw,
 	struct sst_hsw_stream *stream, u32 offset, u32 size);
+int sst_hsw_stream_get_hw_id(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream);
+int sst_hsw_stream_get_mixer_id(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream);
+u32 sst_hsw_stream_get_read_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream);
+u32 sst_hsw_stream_get_pointer_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream);
+u32 sst_hsw_stream_get_peak_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel);
+u32 sst_hsw_stream_get_vol_reg(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 channel);
+int sst_hsw_mixer_get_info(struct sst_hsw *hsw);
 
 /* Stream ALSA trigger operations */
-int sst_hsw_stream_pause(struct sst_hsw *hsw, struct sst_hsw_stream *stream, int wait);
-int sst_hsw_stream_resume(struct sst_hsw *hsw, struct sst_hsw_stream *stream, int wait);
+int sst_hsw_stream_pause(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	int wait);
+int sst_hsw_stream_resume(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
+	int wait);
 int sst_hsw_stream_reset(struct sst_hsw *hsw, struct sst_hsw_stream *stream);
 
 /* Stream pointer positions */
-int sst_hsw_stream_get_read_pos(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t *position);
-int sst_hsw_stream_get_write_pos(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t *position);
-int sst_hsw_stream_set_write_position(struct sst_hsw *hsw, struct sst_hsw_stream *stream,
-	uint32_t stage_id, uint32_t position);
-int sst_hsw_get_dsp_position(struct sst_hsw *hsw, struct sst_hsw_stream *stream);
+int sst_hsw_stream_get_read_pos(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 *position);
+int sst_hsw_stream_get_write_pos(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 *position);
+int sst_hsw_stream_set_write_position(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream, u32 stage_id, u32 position);
+int sst_hsw_get_dsp_position(struct sst_hsw *hsw,
+	struct sst_hsw_stream *stream);
 
 /* HW port config */
 int sst_hsw_device_set_config(struct sst_hsw *hsw,
 	enum sst_hsw_device_id dev, enum sst_hsw_device_mclk mclk,
-	enum sst_hsw_device_mode mode, uint32_t clock_divider);
+	enum sst_hsw_device_mode mode, u32 clock_divider);
 
 /* DX Config */
 int sst_hsw_dx_set_state(struct sst_hsw *hsw,
 	enum sst_hsw_dx_state state, struct sst_hsw_ipc_dx_reply *dx);
-int sst_hsw_dx_get_state(struct sst_hsw *hsw, uint32_t item,
-	uint32_t *offset, uint32_t *size, uint32_t *source);
+int sst_hsw_dx_get_state(struct sst_hsw *hsw, u32 item,
+	u32 *offset, u32 *size, u32 *source);
 
 /* init */
 int sst_hsw_dsp_init(struct device *dev, struct sst_pdata *pdata);
@@ -583,7 +485,4 @@
 void sst_hsw_set_scratch_module(struct sst_hsw *hsw,
 	struct sst_module *scratch);
 
-/* create debugFS entries for loging */
-int sst_hsw_dbg_enable(struct sst_hsw *hsw, struct dentry *debugfs_card_root);
-
 #endif
Index: b/sound/soc/intel/sst-haswell-pcm.c
===================================================================
--- a/sound/soc/intel/sst-haswell-pcm.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/intel/sst-haswell-pcm.c	2016-06-02 12:28:43.397170197 +0800
@@ -33,16 +33,10 @@
 #include "sst-dsp-priv.h"
 #include "sst-dsp.h"
 
-/*
- * Dont build in the compressed support as it's not required for base FW.
- * We also have to fix an issue on module removal with compressed.
- */
-#define HSW_COMPR	0
-
 #define HSW_PCM_COUNT		6
 #define HSW_VOLUME_MAX		0x7FFFFFFF	/* 0dB */
 
-/* TODO: to be replaced with windows table */
+/* simple volume table */
 static const u32 volume_map[] = {
 	HSW_VOLUME_MAX >> 30,
 	HSW_VOLUME_MAX >> 29,
@@ -135,6 +129,7 @@
 		if (volume_map[i] >= value)
 			return i;
 	}
+
 	return i - 1;
 }
 
@@ -153,8 +148,10 @@
 	mutex_lock(&pcm_data->mutex);
 
 	if (!pcm_data->stream) {
-		pcm_data->volume[0] = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
-		pcm_data->volume[1] = hsw_mixer_to_ipc(ucontrol->value.integer.value[1]);
+		pcm_data->volume[0] =
+			hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);
+		pcm_data->volume[1] =
+			hsw_mixer_to_ipc(ucontrol->value.integer.value[1]);
 		mutex_unlock(&pcm_data->mutex);
 		return 0;
 	}
@@ -189,8 +186,10 @@
 	mutex_lock(&pcm_data->mutex);
 
 	if (!pcm_data->stream) {
-		ucontrol->value.integer.value[0] = hsw_ipc_to_mixer(pcm_data->volume[0]);
-		ucontrol->value.integer.value[1] = hsw_ipc_to_mixer(pcm_data->volume[1]);
+		ucontrol->value.integer.value[0] =
+			hsw_ipc_to_mixer(pcm_data->volume[0]);
+		ucontrol->value.integer.value[1] =
+			hsw_ipc_to_mixer(pcm_data->volume[1]);
 		mutex_unlock(&pcm_data->mutex);
 		return 0;
 	}
@@ -324,15 +323,13 @@
 	u8 channels;
 	int ret;
 
-	dev_dbg(rtd->dev, "PCM: hw_params, pcm_data %p\n", pcm_data);
-
 	/* stream direction */
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		path_id = SST_HSW_STREAM_PATH_SSP0_OUT;
 	else
 		path_id = SST_HSW_STREAM_PATH_SSP0_IN;
 
-	/* stream type depends on DAI ID */
+	/* DSP stream type depends on DAI ID */
 	switch (rtd->cpu_dai->id) {
 	case 0:
 		stream_type = SST_HSW_STREAM_TYPE_SYSTEM;
@@ -354,109 +351,67 @@
 		module_id = SST_HSW_MODULE_PCM_CAPTURE;
 		break;
 	default:
-		dev_err(rtd->dev, "invalid DAI ID %d\n", rtd->cpu_dai->id);
+		dev_err(rtd->dev, "error: invalid DAI ID %d\n",
+			rtd->cpu_dai->id);
 		return -EINVAL;
 	};
 
 	ret = sst_hsw_stream_format(hsw, pcm_data->stream,
-		path_id, stream_type,
-		SST_HSW_STREAM_FORMAT_PCM_FORMAT);
+		path_id, stream_type, SST_HSW_STREAM_FORMAT_PCM_FORMAT);
 	if (ret < 0) {
-		dev_err(rtd->dev, "failed to set stream format %d\n", ret);
+		dev_err(rtd->dev, "error: failed to set format %d\n", ret);
 		return ret;
 	}
 
-	switch (params_rate(params)) {
-	case 8000:
-		rate = SST_HSW_FS_8000HZ;
-		break;
-	case 11025:
-		rate = SST_HSW_FS_11025HZ;
-		break;
-	case 12000:
-		rate = SST_HSW_FS_12000HZ;
-		break;
-	case 16000:
-		rate = SST_HSW_FS_16000HZ;
-		break;
-	case 22050:
-		rate = SST_HSW_FS_22050HZ;
-		break;
-	case 24000:
-		rate = SST_HSW_FS_24000HZ;
-		break;
-	case 32000:
-		rate = SST_HSW_FS_32000HZ;
-		break;
-	case 44100:
-		rate = SST_HSW_FS_44100HZ;
-		break;
-	case 48000:
-		rate = SST_HSW_FS_48000HZ;
-		break;
-	case 64000:
-		rate = SST_HSW_FS_64000HZ;
-		break;
-	case 88200:
-		rate = SST_HSW_FS_88200HZ;
-		break;
-	case 96000:
-		rate = SST_HSW_FS_96000HZ;
-		break;
-	case 128000:
-		rate = SST_HSW_FS_128000HZ;
-		break;
-	case 176400:
-		rate = SST_HSW_FS_176400HZ;
-		break;
-	case 192000:
-		rate = SST_HSW_FS_192000HZ;
-		break;
-	default:
-		dev_err(rtd->dev, "invalid rate %d\n", params_rate(params));
-		return -EINVAL;
-	}
-
+	rate = params_rate(params);
 	ret = sst_hsw_stream_set_rate(hsw, pcm_data->stream, rate);
 	if (ret < 0) {
-		dev_err(rtd->dev, "could not set rate %d\n", params_rate(params));
+		dev_err(rtd->dev, "error: could not set rate %d\n", rate);
 		return ret;
 	}
 
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
 		bits = SST_HSW_DEPTH_16BIT;
+		sst_hsw_stream_set_valid(hsw, pcm_data->stream, 16);
 		break;
 	case SNDRV_PCM_FORMAT_S24_LE:
 		bits = SST_HSW_DEPTH_24BIT;
-		break;
-	case SNDRV_PCM_FORMAT_S8:
-		bits = SST_HSW_DEPTH_8BIT;
-		break;
-	case SNDRV_PCM_FORMAT_S32_LE:
-		bits = SST_HSW_DEPTH_32BIT;
+		sst_hsw_stream_set_valid(hsw, pcm_data->stream, 32);
 		break;
 	default:
-		dev_err(rtd->dev, "invalid format %d\n", params_format(params));
+		dev_err(rtd->dev, "error: invalid format %d\n",
+			params_format(params));
 		return -EINVAL;
 	}
 
 	ret = sst_hsw_stream_set_bits(hsw, pcm_data->stream, bits);
 	if (ret < 0) {
-		dev_err(rtd->dev, "could not set formats %d\n", params_rate(params));
+		dev_err(rtd->dev, "error: could not set bits %d\n", bits);
 		return ret;
 	}
 
-	channels = (u8)(params_channels(params) & 0xF);
+	/* we only support stereo atm */
+	channels = params_channels(params);
+	if (channels != 2) {
+		dev_err(rtd->dev, "error: invalid channels %d\n", channels);
+		return -EINVAL;
+	}
+
+	map = create_channel_map(SST_HSW_CHANNEL_CONFIG_STEREO);
+	sst_hsw_stream_set_map_config(hsw, pcm_data->stream,
+			map, SST_HSW_CHANNEL_CONFIG_STEREO);
+
 	ret = sst_hsw_stream_set_channels(hsw, pcm_data->stream, channels);
 	if (ret < 0) {
-		dev_err(rtd->dev, "could not set channels %d\n", params_rate(params));
+		dev_err(rtd->dev, "error: could not set channels %d\n",
+			channels);
 		return ret;
 	}
 
 	ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 	if (ret < 0) {
-		dev_err(rtd->dev, "could not allocate %d bytes for PCM %d\n",
+		dev_err(rtd->dev, "error: could not allocate %d bytes for PCM %d\n",
 			params_buffer_bytes(params), ret);
 		return ret;
 	}
@@ -466,12 +421,8 @@
 	if (ret < 0)
 		return ret;
 
-	// TODO leave these hard coded atm
-	map = create_channel_map(SST_HSW_CHANNEL_CONFIG_STEREO);
-	sst_hsw_stream_set_map_config(hsw, pcm_data->stream,
-			map, SST_HSW_CHANNEL_CONFIG_STEREO);
-	sst_hsw_stream_set_style(hsw, pcm_data->stream, SST_HSW_INTERLEAVING_PER_CHANNEL);
-	sst_hsw_stream_set_valid(hsw, pcm_data->stream, 16);
+	sst_hsw_stream_set_style(hsw, pcm_data->stream,
+		SST_HSW_INTERLEAVING_PER_CHANNEL);
 
 	if (runtime->dma_bytes % PAGE_SIZE)
 		pages = (runtime->dma_bytes / PAGE_SIZE) + 1;
@@ -483,7 +434,7 @@
 		pages, runtime->dma_bytes, 0,
 		(u32)(virt_to_phys(runtime->dma_area) >> PAGE_SHIFT));
 	if (ret < 0) {
-		dev_err(rtd->dev, "PCM: failed to set DMA buffer %d\n", ret);
+		dev_err(rtd->dev, "error: failed to set DMA buffer %d\n", ret);
 		return ret;
 	}
 
@@ -491,11 +442,11 @@
 
 	module_data = sst_module_get_from_id(dsp, module_id);
 	if (module_data == NULL) {
-		dev_err(rtd->dev, "PCM: failed to get module config\n");
+		dev_err(rtd->dev, "error: failed to get module config\n");
 		return -EINVAL;
 	}
 
-	/* TODO: validate module parameters for allocate stream */
+	/* we use hardcoded memory offsets atm, will be updated for new FW */
 	if (stream_type == SST_HSW_STREAM_TYPE_CAPTURE) {
 		sst_hsw_stream_set_module_info(hsw, pcm_data->stream,
 			SST_HSW_MODULE_PCM_CAPTURE, module_data->entry);
@@ -520,24 +471,20 @@
 
 	ret = sst_hsw_stream_commit(hsw, pcm_data->stream);
 	if (ret < 0) {
-		dev_err(rtd->dev, "PCM: failed stream commit %d\n", ret);
+		dev_err(rtd->dev, "error: failed to commit stream %d\n", ret);
 		return ret;
 	}
 
 	ret = sst_hsw_stream_pause(hsw, pcm_data->stream, 1);
 	if (ret < 0)
-		dev_err(rtd->dev, "PCM: failed to pause %d after commit\n", ret);
+		dev_err(rtd->dev, "error: failed to pause %d\n", ret);
 
 	return 0;
 }
 
 static int hsw_pcm_hw_free(struct snd_pcm_substream *substream)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-
-	dev_dbg(rtd->dev, "PCM: hw_free\n");
 	snd_pcm_lib_free_pages(substream);
-
 	return 0;
 }
 
@@ -549,8 +496,6 @@
 	struct hsw_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
 	struct sst_hsw *hsw = pdata->hsw;
 
-	dev_dbg(rtd->dev, "PCM: trigger %d\n", cmd);
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -610,12 +555,11 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct hsw_priv_data *pdata =
 		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data = snd_soc_pcm_get_drvdata(rtd);
+	struct hsw_pcm_data *pcm_data;
 	struct sst_hsw *hsw = pdata->hsw;
 
-	dev_dbg(rtd->dev, "PCM: open\n");
-
 	pcm_data = &pdata->pcm[rtd->cpu_dai->id];
+
 	mutex_lock(&pcm_data->mutex);
 
 	snd_soc_pcm_set_drvdata(rtd, pcm_data);
@@ -626,12 +570,12 @@
 	pcm_data->stream = sst_hsw_stream_new(hsw, rtd->cpu_dai->id,
 		hsw_notify_pointer, pcm_data);
 	if (pcm_data->stream == NULL) {
-		dev_err(rtd->dev, "failed to create stream\n");
+		dev_err(rtd->dev, "error: failed to create stream\n");
 		mutex_unlock(&pcm_data->mutex);
 		return -EINVAL;
 	}
 
-	/* Set previous save volume */
+	/* Set previous saved volume */
 	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
 			0, pcm_data->volume[0]);
 	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
@@ -650,18 +594,16 @@
 	struct sst_hsw *hsw = pdata->hsw;
 	int ret;
 
-	dev_dbg(rtd->dev, "PCM: close\n");
-
 	mutex_lock(&pcm_data->mutex);
 	ret = sst_hsw_stream_reset(hsw, pcm_data->stream);
 	if (ret < 0) {
-		dev_dbg(rtd->dev, "Reset stream fail!!!\n");
+		dev_dbg(rtd->dev, "error: reset stream failed %d\n", ret);
 		goto out;
 	}
 
 	ret = sst_hsw_stream_free(hsw, pcm_data->stream);
 	if (ret < 0) {
-		dev_dbg(rtd->dev, "Free stream fail!!!\n");
+		dev_dbg(rtd->dev, "error: free stream failed %d\n", ret);
 		goto out;
 	}
 	pcm_data->stream = NULL;
@@ -671,15 +613,6 @@
 	return ret;
 }
 
-static int hsw_pcm_mmap(struct snd_pcm_substream *substream,
-	struct vm_area_struct *vma)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-
-	dev_dbg(rtd->dev, "PCM: mmap\n");
-	return snd_pcm_lib_default_mmap(substream, vma);
-}
-
 static struct snd_pcm_ops hsw_pcm_ops = {
 	.open		= hsw_pcm_open,
 	.close		= hsw_pcm_close,
@@ -688,7 +621,7 @@
 	.hw_free	= hsw_pcm_hw_free,
 	.trigger	= hsw_pcm_trigger,
 	.pointer	= hsw_pcm_pointer,
-	.mmap		= hsw_pcm_mmap,
+	.mmap		= snd_pcm_lib_default_mmap,
 };
 
 static void hsw_pcm_free(struct snd_pcm *pcm)
@@ -738,11 +671,8 @@
 		},
 	},
 	{
-		/* PCM and compressed */
+		/* PCM */
 		.name  = "Offload0 Pin",
-#if HSW_COMPR
-		.compress_dai = 1,
-#endif
 		.playback = {
 			.stream_name = "Offload0 Playback",
 			.channels_min = 2,
@@ -752,11 +682,8 @@
 		},
 	},
 	{
-		/* PCM and compressed */
+		/* PCM */
 		.name  = "Offload1 Pin",
-#if HSW_COMPR
-		.compress_dai = 1,
-#endif
 		.playback = {
 			.stream_name = "Offload1 Playback",
 			.channels_min = 2,
@@ -872,360 +799,10 @@
 	return 0;
 }
 
-#if HSW_COMPR
-
-static u32 hsw_compr_notify_pointer(struct sst_hsw_stream *stream, void *data)
-{
-	struct hsw_pcm_data *pcm_data = data;
-	struct snd_compr_stream *cstream = pcm_data->cstream;
-
-	if (cstream)
-		snd_compr_fragment_elapsed(cstream);
-
-	return 0;
-}
-
-static int hsw_compr_open(struct snd_compr_stream *cstream)
-{
-	struct snd_compr_runtime *runtime = cstream->runtime;
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct hsw_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data;
-	struct sst_hsw *hsw = pdata->hsw;
-
-	dev_dbg(rtd->dev, "compr: open\n");
-
-	pcm_data = &pdata->pcm[rtd->cpu_dai->id];
-
-	mutex_lock(&pcm_data->mutex);
-	pcm_data->cstream = cstream;
-	pcm_data->wpos = 0;
-
-	pcm_data->stream = sst_hsw_stream_new(hsw, rtd->cpu_dai->id,
-		 hsw_compr_notify_pointer, pcm_data);
-	if (pcm_data->stream == NULL) {
-		dev_err(rtd->dev, "failed to create stream\n");
-		mutex_unlock(&pcm_data->mutex);
-		return -EINVAL;
-	}
-
-	runtime->private_data = pcm_data;
-
-	mutex_unlock(&pcm_data->mutex);
-	return 0;
-}
-
-static int hsw_compr_free(struct snd_compr_stream *cstream)
-{
-	struct snd_compr_runtime *runtime = cstream->runtime;
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct hsw_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data = runtime->private_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret;
-
-	dev_dbg(rtd->dev, "compr: close\n");
-
-	mutex_lock(&pcm_data->mutex);
-
-	ret = sst_hsw_stream_reset(hsw, pcm_data->stream);
-	if (ret < 0) {
-		dev_dbg(rtd->dev, "Reset stream fail!!!\n");
-		goto out;
-	}
-
-	ret = sst_hsw_stream_free(hsw, pcm_data->stream);
-	if (ret < 0) {
-		dev_dbg(rtd->dev, "Free stream fail!!!\n");
-		goto out;
-	}
-	pcm_data->stream = NULL;
-
-out:
-	mutex_unlock(&pcm_data->mutex);
-	return ret;
-}
-
-static int hsw_compr_set_params(struct snd_compr_stream *cstream,
-	struct snd_compr_params *params)
-{
-	struct snd_compr_runtime *runtime = cstream->runtime;
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct hsw_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data = runtime->private_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	enum sst_hsw_stream_path_id path_id;
-	enum sst_hsw_stream_format format;
-	enum sample_frequency rate;
-	u32 map;
-	int ret, pages, depth = SST_HSW_DEPTH_INVALID, bits = 0;
-
-	dev_dbg(rtd->dev, "compr: hw_params, pcm_data %p\n", pcm_data);
-
-	/* stream direction -- hard coded atm */
-	path_id = SST_HSW_STREAM_PATH_SSP0_OUT;
-
-	/* compressed rate */
-	switch (params->codec.sample_rate) {
-	case SNDRV_PCM_RATE_44100:
-		rate = SST_HSW_FS_44100HZ;
-		break;
-	case SNDRV_PCM_RATE_48000:
-		rate = SST_HSW_FS_48000HZ;
-		break;
-	default:
-		dev_err(rtd->dev, "invalid rate %d\n",
-			params->codec.sample_rate);
-		return -EINVAL;
-	}
-
-	/* stream format - hard code rate atm */
-	switch (params->codec.id) {
-	case SND_AUDIOCODEC_MP3:
-		format = SST_HSW_STREAM_FORMAT_MP3_FORMAT;
-		break;
-	case SND_AUDIOCODEC_AAC:
-		format = SST_HSW_STREAM_FORMAT_AAC_FORMAT;
-		break;
-	case SND_AUDIOCODEC_PCM:
-		format = SST_HSW_STREAM_FORMAT_PCM_FORMAT;
-		depth = SST_HSW_DEPTH_16BIT;
-		bits = 16;
-		break;
-	default:
-		dev_err(rtd->dev, "invalid compressed format %d\n",
-			params->codec.id);
-		return -EINVAL;
-	}
-	ret = sst_hsw_stream_format(hsw, pcm_data->stream,
-		path_id, SST_HSW_STREAM_TYPE_RENDER, format);
-	if (ret < 0) {
-		dev_err(rtd->dev, "failed to set stream format %d\n", ret);
-		return ret;
-	}
-
-	/* set rate */
-	ret = sst_hsw_stream_set_rate(hsw, pcm_data->stream, rate);
-	if (ret < 0) {
-		dev_err(rtd->dev, "could not set rate %d\n", rate);
-		return ret;
-	}
-
-	/* set to stereo - TODO hardcoded */
-	ret = sst_hsw_stream_set_channels(hsw, pcm_data->stream, 2);
-	if (ret < 0) {
-		dev_err(rtd->dev, "could not set channels %d\n", 2);
-		return ret;
-	}
-
-	ret = create_adsp_page_table(pdata, rtd, runtime->buffer,
-		runtime->buffer_size, rtd->cpu_dai->id, SNDRV_PCM_STREAM_PLAYBACK);
-	if (ret < 0)
-		return ret;
-
-	ret = sst_hsw_stream_set_bits(hsw, pcm_data->stream, bits);
-	if (ret < 0) {
-		dev_err(rtd->dev, "could not set bits %d\n", bits);
-		return ret;
-	}
-
-	// TODO leave these hard coded atm
-	map = create_channel_map(SST_HSW_CHANNEL_CONFIG_STEREO);
-	sst_hsw_stream_set_map_config(hsw, pcm_data->stream,
-			map, SST_HSW_CHANNEL_CONFIG_STEREO);
-
-	sst_hsw_stream_set_style(hsw, pcm_data->stream, SST_HSW_INTERLEAVING_PER_CHANNEL);
-	sst_hsw_stream_set_valid(hsw, pcm_data->stream, depth);
-
-	if (runtime->buffer_size % PAGE_SIZE)
-		pages = (runtime->buffer_size / PAGE_SIZE) + 1;
-	else
-		pages = runtime->buffer_size / PAGE_SIZE;
-
-	ret = sst_hsw_stream_buffer(hsw, pcm_data->stream,
-		virt_to_phys(pdata->pcm_pg[rtd->cpu_dai->id][SNDRV_PCM_STREAM_PLAYBACK]),
-		pages, runtime->buffer_size, 0,
-		(u32)(virt_to_phys(runtime->buffer) >> PAGE_SHIFT));
-	if (ret < 0) {
-		dev_err(rtd->dev, "compr: failed to set DMA buffer %d\n", ret);
-		return ret;
-	}
-
-	ret = sst_hsw_stream_commit(hsw, pcm_data->stream);
-	if (ret < 0) {
-		dev_err(rtd->dev, "compr: failed stream commit %d\n", ret);
-		return ret;
-	}
-
-	ret = sst_hsw_stream_pause(hsw, pcm_data->stream, 1);
-	if (ret < 0)
-		dev_err(rtd->dev, "compr: failed to pause %d after commit\n", ret);
-
-	/* Set previous save volume */
-	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-			0, pcm_data->volume[0]);
-	sst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,
-			1, pcm_data->volume[1]);
-
-	return 0;
-}
-
-static int hsw_compr_trigger(struct snd_compr_stream *cstream, int cmd)
-{
-	struct snd_compr_runtime *runtime = cstream->runtime;
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct hsw_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data = runtime->private_data;
-	struct sst_hsw *hsw = pdata->hsw;
-
-	dev_dbg(rtd->dev, "compr: trigger %d\n", cmd);
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		sst_hsw_stream_resume(hsw, pcm_data->stream, 0);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		sst_hsw_stream_pause(hsw, pcm_data->stream, 0);
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static int hsw_compr_pointer(struct snd_compr_stream *cstream,
-					struct snd_compr_tstamp *tstamp)
-{
-	struct snd_compr_runtime *runtime = cstream->runtime;
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct hsw_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data = runtime->private_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	u32 bytes;
-
-	bytes =	sst_hsw_get_dsp_position(hsw, pcm_data->stream);
-	tstamp->pcm_io_frames = bytes * 4; // TODO: hardcoded
-	tstamp->copied_total += bytes;
-	tstamp->byte_offset = tstamp->copied_total %
-				 (u32)cstream->runtime->buffer_size;
-
-	dev_info(rtd->dev, "DSP pointer byte offset 0x%x dsp at frame 0x%zu\n",
-		tstamp->byte_offset, tstamp->pcm_io_frames);
-
-	return 0;
-}
-
-static int hsw_compr_ack(struct snd_compr_stream *cstream, size_t bytes)
-{
-	struct snd_compr_runtime *runtime = cstream->runtime;
-	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
-	struct hsw_priv_data *pdata =
-		snd_soc_platform_get_drvdata(rtd->platform);
-	struct hsw_pcm_data *pcm_data = runtime->private_data;
-	struct sst_hsw *hsw = pdata->hsw;
-	int ret;
-	u32 pos;
-
-	pcm_data->wpos += bytes;
-	pos = pcm_data->wpos % (u32)cstream->runtime->buffer_size;
-
-	ret = sst_hsw_stream_set_write_position(hsw, pcm_data->stream, 0, pos);
-	if (ret < 0)
-		dev_err(rtd->dev, "compr: failed to set write position to %d\n", ret);
-
-	return ret;
-}
-
-static int hsw_compr_get_caps(struct snd_compr_stream *cstream,
-					struct snd_compr_caps *caps)
-{
-	caps->num_codecs = 3;
-	caps->min_fragment_size = PAGE_SIZE;
-	caps->max_fragment_size = PAGE_SIZE * 1024;
-	caps->min_fragments = 2;
-	caps->max_fragments = 1024;
-	caps->codecs[0] = SND_AUDIOCODEC_MP3;
-	caps->codecs[1] = SND_AUDIOCODEC_AAC;
-	caps->codecs[2] = SND_AUDIOCODEC_PCM;
-
-	return 0;
-}
-
-static int hsw_compr_get_codec_caps(struct snd_compr_stream *cstream,
-					struct snd_compr_codec_caps *codec)
-{
-	switch (codec->codec) {
-	case SND_AUDIOCODEC_MP3:
-		codec->num_descriptors = 3;
-		codec->descriptor[0].max_ch = 2;
-		codec->descriptor[0].sample_rates = SNDRV_PCM_RATE_8000_48000;
-		codec->descriptor[0].bit_rate[0] = 320; /* 320kbps */
-		codec->descriptor[0].bit_rate[1] = 192;
-		codec->descriptor[0].num_bitrates = 2;
-		codec->descriptor[0].profiles = 0;
-		codec->descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO;
-		codec->descriptor[0].formats = 0;
-		break;
-	case SND_AUDIOCODEC_AAC:
-		codec->num_descriptors = 3;
-		codec->descriptor[1].max_ch = 2;
-		codec->descriptor[1].sample_rates = SNDRV_PCM_RATE_8000_48000;
-		codec->descriptor[1].bit_rate[0] = 320; /* 320kbps */
-		codec->descriptor[1].bit_rate[1] = 192;
-		codec->descriptor[1].num_bitrates = 2;
-		codec->descriptor[1].profiles = 0;
-		codec->descriptor[1].modes = 0;
-		codec->descriptor[1].formats =
-			(SND_AUDIOSTREAMFORMAT_MP4ADTS |
-				SND_AUDIOSTREAMFORMAT_RAW);
-		break;
-	case SND_AUDIOCODEC_PCM:
-		codec->num_descriptors = 3;
-		codec->descriptor[2].max_ch = 2;
-		codec->descriptor[2].sample_rates = SNDRV_PCM_RATE_8000_48000;
-		codec->descriptor[2].bit_rate[0] = 320; /* 320kbps */
-		codec->descriptor[2].bit_rate[1] = 192;
-		codec->descriptor[2].num_bitrates = 0;
-		codec->descriptor[2].profiles = 0;
-		codec->descriptor[2].modes = 0;
-		codec->descriptor[2].formats = 0;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static struct snd_compr_ops hsw_compr_ops = {
-	.open = hsw_compr_open,
-	.free = hsw_compr_free,
-	.set_params = hsw_compr_set_params,
-	.trigger = hsw_compr_trigger,
-	.pointer = hsw_compr_pointer,
-	.get_caps = hsw_compr_get_caps,
-	.get_codec_caps = hsw_compr_get_codec_caps,
-	.ack = hsw_compr_ack,
-};
-#endif
-
 static struct snd_soc_platform_driver hsw_soc_platform = {
 	.probe		= hsw_pcm_probe,
 	.remove		= hsw_pcm_remove,
 	.ops		= &hsw_pcm_ops,
-#if HSW_COMPR
-	.compr_ops	= &hsw_compr_ops,
-#endif
 	.pcm_new	= hsw_pcm_new,
 	.pcm_free	= hsw_pcm_free,
 	.controls	= hsw_volume_controls,
Index: b/sound/soc/soc-core.c
===================================================================
--- a/sound/soc/soc-core.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/soc-core.c	2016-06-02 12:28:43.397170197 +0800
@@ -2571,10 +2571,10 @@
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
-	uinfo->value.enumerated.items = e->max;
+	uinfo->value.enumerated.items = e->items;
 
-	if (uinfo->value.enumerated.item > e->max - 1)
-		uinfo->value.enumerated.item = e->max - 1;
+	if (uinfo->value.enumerated.item >= e->items)
+		uinfo->value.enumerated.item = e->items - 1;
 	strlcpy(uinfo->value.enumerated.name,
 		e->texts[uinfo->value.enumerated.item],
 		sizeof(uinfo->value.enumerated.name));
@@ -2626,12 +2626,12 @@
 	unsigned int val;
 	unsigned int mask;
 
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] >= e->items)
 		return -EINVAL;
 	val = ucontrol->value.enumerated.item[0] << e->shift_l;
 	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] >= e->items)
 			return -EINVAL;
 		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
 		mask |= e->mask << e->shift_r;
@@ -2662,14 +2662,14 @@
 
 	reg_val = snd_soc_read(codec, e->reg);
 	val = (reg_val >> e->shift_l) & e->mask;
-	for (mux = 0; mux < e->max; mux++) {
+	for (mux = 0; mux < e->items; mux++) {
 		if (val == e->values[mux])
 			break;
 	}
 	ucontrol->value.enumerated.item[0] = mux;
 	if (e->shift_l != e->shift_r) {
 		val = (reg_val >> e->shift_r) & e->mask;
-		for (mux = 0; mux < e->max; mux++) {
+		for (mux = 0; mux < e->items; mux++) {
 			if (val == e->values[mux])
 				break;
 		}
@@ -2700,12 +2700,12 @@
 	unsigned int val;
 	unsigned int mask;
 
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] >= e->items)
 		return -EINVAL;
 	val = e->values[ucontrol->value.enumerated.item[0]] << e->shift_l;
 	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] >= e->items)
 			return -EINVAL;
 		val |= e->values[ucontrol->value.enumerated.item[1]] << e->shift_r;
 		mask |= e->mask << e->shift_r;
@@ -2716,6 +2716,48 @@
 EXPORT_SYMBOL_GPL(snd_soc_put_value_enum_double);
 
 /**
+ * snd_soc_read_signed - Read a codec register and interprete as signed value
+ * @codec: codec
+ * @reg: Register to read
+ * @mask: Mask to use after shifting the register value
+ * @shift: Right shift of register value
+ * @sign_bit: Bit that describes if a number is negative or not.
+ *
+ * This functions reads a codec register. The register value is shifted right
+ * by 'shift' bits and masked with the given 'mask'. Afterwards it translates
+ * the given registervalue into a signed integer if sign_bit is non-zero.
+ *
+ * Returns the register value as signed int.
+ */
+static int snd_soc_read_signed(struct snd_soc_codec *codec, unsigned int reg,
+		unsigned int mask, unsigned int shift, unsigned int sign_bit)
+{
+	int ret;
+	unsigned int val;
+
+	val = (snd_soc_read(codec, reg) >> shift) & mask;
+
+	if (!sign_bit)
+		return val;
+
+	/* non-negative number */
+	if (!(val & BIT(sign_bit)))
+		return val;
+
+	ret = val;
+
+	/*
+	 * The register most probably does not contain a full-sized int.
+	 * Instead we have an arbitrary number of bits in a signed
+	 * representation which has to be translated into a full-sized int.
+	 * This is done by filling up all bits above the sign-bit.
+	 */
+	ret |= ~((int)(BIT(sign_bit) - 1));
+
+	return ret;
+}
+
+/**
  * snd_soc_info_volsw - single mixer info callback
  * @kcontrol: mixer control
  * @uinfo: control element information
@@ -2743,7 +2785,7 @@
 
 	uinfo->count = snd_soc_volsw_is_stereo(mc) ? 2 : 1;
 	uinfo->value.integer.min = 0;
-	uinfo->value.integer.max = platform_max;
+	uinfo->value.integer.max = platform_max - mc->min;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
@@ -2769,11 +2811,16 @@
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 	int max = mc->max;
+	int min = mc->min;
+	int sign_bit = mc->sign_bit;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 
-	ucontrol->value.integer.value[0] =
-		(snd_soc_read(codec, reg) >> shift) & mask;
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	ucontrol->value.integer.value[0] = snd_soc_read_signed(codec, reg, mask,
+			shift, sign_bit) - min;
 	if (invert)
 		ucontrol->value.integer.value[0] =
 			max - ucontrol->value.integer.value[0];
@@ -2781,10 +2828,12 @@
 	if (snd_soc_volsw_is_stereo(mc)) {
 		if (reg == reg2)
 			ucontrol->value.integer.value[1] =
-				(snd_soc_read(codec, reg) >> rshift) & mask;
+				snd_soc_read_signed(codec, reg, mask, rshift,
+						sign_bit) - min;
 		else
 			ucontrol->value.integer.value[1] =
-				(snd_soc_read(codec, reg2) >> shift) & mask;
+				snd_soc_read_signed(codec, reg2, mask, shift,
+						sign_bit) - min;
 		if (invert)
 			ucontrol->value.integer.value[1] =
 				max - ucontrol->value.integer.value[1];
@@ -2815,6 +2864,8 @@
 	unsigned int shift = mc->shift;
 	unsigned int rshift = mc->rshift;
 	int max = mc->max;
+	int min = mc->min;
+	unsigned int sign_bit = mc->sign_bit;
 	unsigned int mask = (1 << fls(max)) - 1;
 	unsigned int invert = mc->invert;
 	int err;
@@ -2822,13 +2873,16 @@
 	unsigned int val2 = 0;
 	unsigned int val, val_mask;
 
-	val = (ucontrol->value.integer.value[0] & mask);
+	if (sign_bit)
+		mask = BIT(sign_bit + 1) - 1;
+
+	val = ((ucontrol->value.integer.value[0] + min) & mask);
 	if (invert)
 		val = max - val;
 	val_mask = mask << shift;
 	val = val << shift;
 	if (snd_soc_volsw_is_stereo(mc)) {
-		val2 = (ucontrol->value.integer.value[1] & mask);
+		val2 = ((ucontrol->value.integer.value[1] + min) & mask);
 		if (invert)
 			val2 = max - val2;
 		if (reg == reg2) {
@@ -3609,6 +3663,30 @@
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 
 /**
+ * snd_soc_of_xlate_tdm_slot - generate tx/rx slot mask.
+ * @slots: Number of slots in use.
+ * @tx_mask: bitmask representing active TX slots.
+ * @rx_mask: bitmask representing active RX slots.
+ *
+ * Generates the TDM tx and rx slot default masks for DAI.
+ */
+static int snd_soc_of_xlate_tdm_slot_mask(unsigned int slots,
+					  unsigned int *tx_mask,
+					  unsigned int *rx_mask)
+{
+	if (*tx_mask || *rx_mask)
+		return 0;
+
+	if (!slots)
+		return -EINVAL;
+
+	*tx_mask = (1 << slots) - 1;
+	*rx_mask = (1 << slots) - 1;
+
+	return 0;
+}
+
+/**
  * snd_soc_dai_set_tdm_slot - configure DAI TDM.
  * @dai: DAI
  * @tx_mask: bitmask representing active TX slots.
@@ -3622,11 +3700,17 @@
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
 {
+	if (dai->driver && dai->driver->ops->of_xlate_tdm_slot_mask)
+		dai->driver->ops->of_xlate_tdm_slot_mask(slots,
+						&tx_mask, &rx_mask);
+	else
+		snd_soc_of_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);
+
 	if (dai->driver && dai->driver->ops->set_tdm_slot)
 		return dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,
 				slots, slot_width);
 	else
-		return -EINVAL;
+		return -ENOTSUPP;
 }
 EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
 
@@ -4417,6 +4501,122 @@
 }
 EXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name);
 
+static const struct snd_soc_dapm_widget simple_widgets[] = {
+	SND_SOC_DAPM_MIC("Microphone", NULL),
+	SND_SOC_DAPM_LINE("Line", NULL),
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+};
+
+int snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,
+					  const char *propname)
+{
+	struct device_node *np = card->dev->of_node;
+	struct snd_soc_dapm_widget *widgets;
+	const char *template, *wname;
+	int i, j, num_widgets, ret;
+
+	num_widgets = of_property_count_strings(np, propname);
+	if (num_widgets < 0) {
+		dev_err(card->dev,
+			"ASoC: Property '%s' does not exist\n",	propname);
+		return -EINVAL;
+	}
+	if (num_widgets & 1) {
+		dev_err(card->dev,
+			"ASoC: Property '%s' length is not even\n", propname);
+		return -EINVAL;
+	}
+
+	num_widgets /= 2;
+	if (!num_widgets) {
+		dev_err(card->dev, "ASoC: Property '%s's length is zero\n",
+			propname);
+		return -EINVAL;
+	}
+
+	widgets = devm_kcalloc(card->dev, num_widgets, sizeof(*widgets),
+			       GFP_KERNEL);
+	if (!widgets) {
+		dev_err(card->dev,
+			"ASoC: Could not allocate memory for widgets\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < num_widgets; i++) {
+		ret = of_property_read_string_index(np, propname,
+			2 * i, &template);
+		if (ret) {
+			dev_err(card->dev,
+				"ASoC: Property '%s' index %d read error:%d\n",
+				propname, 2 * i, ret);
+			return -EINVAL;
+		}
+
+		for (j = 0; j < ARRAY_SIZE(simple_widgets); j++) {
+			if (!strncmp(template, simple_widgets[j].name,
+				     strlen(simple_widgets[j].name))) {
+				widgets[i] = simple_widgets[j];
+				break;
+			}
+		}
+
+		if (j >= ARRAY_SIZE(simple_widgets)) {
+			dev_err(card->dev,
+				"ASoC: DAPM widget '%s' is not supported\n",
+				template);
+			return -EINVAL;
+		}
+
+		ret = of_property_read_string_index(np, propname,
+						    (2 * i) + 1,
+						    &wname);
+		if (ret) {
+			dev_err(card->dev,
+				"ASoC: Property '%s' index %d read error:%d\n",
+				propname, (2 * i) + 1, ret);
+			return -EINVAL;
+		}
+
+		widgets[i].name = wname;
+	}
+
+	card->dapm_widgets = widgets;
+	card->num_dapm_widgets = num_widgets;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);
+
+int snd_soc_of_parse_tdm_slot(struct device_node *np,
+			      unsigned int *slots,
+			      unsigned int *slot_width)
+{
+	u32 val;
+	int ret;
+
+	if (of_property_read_bool(np, "dai-tdm-slot-num")) {
+		ret = of_property_read_u32(np, "dai-tdm-slot-num", &val);
+		if (ret)
+			return ret;
+
+		if (slots)
+			*slots = val;
+	}
+
+	if (of_property_read_bool(np, "dai-tdm-slot-width")) {
+		ret = of_property_read_u32(np, "dai-tdm-slot-width", &val);
+		if (ret)
+			return ret;
+
+		if (slot_width)
+			*slot_width = val;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_of_parse_tdm_slot);
+
 int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 				   const char *propname)
 {
Index: b/sound/soc/soc-dapm.c
===================================================================
--- a/sound/soc/soc-dapm.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/soc-dapm.c	2016-06-02 12:28:43.397170197 +0800
@@ -385,7 +385,8 @@
 	return -1;
 }
 
-static int soc_widget_write(struct snd_soc_dapm_widget *w, int reg, int val)
+static int soc_widget_write(struct snd_soc_dapm_widget *w, int reg,
+	unsigned int val)
 {
 	if (w->codec)
 		return snd_soc_write(w->codec, reg, val);
@@ -505,7 +506,7 @@
 	case snd_soc_dapm_switch:
 	case snd_soc_dapm_mixer:
 	case snd_soc_dapm_mixer_named_ctl: {
-		int val;
+		unsigned int val;
 		struct soc_mixer_control *mc = (struct soc_mixer_control *)
 			w->kcontrol_news[i].private_value;
 		int reg = mc->reg;
@@ -529,12 +530,12 @@
 	case snd_soc_dapm_mux: {
 		struct soc_enum *e = (struct soc_enum *)
 			w->kcontrol_news[i].private_value;
-		int val, item;
+		unsigned int val, item;
 
 		soc_widget_read(w, e->reg, &val);
 		item = (val >> e->shift_l) & e->mask;
 
-		if (item < e->max && !strcmp(p->name, e->texts[item]))
+		if (item < e->items && !strcmp(p->name, e->texts[item]))
 			p->connect = 1;
 		else
 			p->connect = 0;
@@ -558,16 +559,16 @@
 	case snd_soc_dapm_value_mux: {
 		struct soc_enum *e = (struct soc_enum *)
 			w->kcontrol_news[i].private_value;
-		int val, item;
+		unsigned int val, item;
 
 		soc_widget_read(w, e->reg, &val);
 		val = (val >> e->shift_l) & e->mask;
-		for (item = 0; item < e->max; item++) {
+		for (item = 0; item < e->items; item++) {
 			if (val == e->values[item])
 				break;
 		}
 
-		if (item < e->max && !strcmp(p->name, e->texts[item]))
+		if (item < e->items && !strcmp(p->name, e->texts[item]))
 			p->connect = 1;
 		else
 			p->connect = 0;
@@ -615,7 +616,7 @@
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	int i;
 
-	for (i = 0; i < e->max; i++) {
+	for (i = 0; i < e->items; i++) {
 		if (!(strcmp(control_name, e->texts[i]))) {
 			list_add(&path->list, &dapm->card->paths);
 			list_add(&path->list_sink, &dest->sources);
@@ -2343,18 +2344,18 @@
 }
 
 /**
- * snd_soc_dapm_sync - scan and power dapm paths
+ * snd_soc_dapm_sync_unlocked - scan and power dapm paths
  * @dapm: DAPM context
  *
  * Walks all dapm audio paths and powers widgets according to their
  * stream or path usage.
  *
+ * Requires external locking.
+ *
  * Returns 0 for success.
  */
-int snd_soc_dapm_sync(struct snd_soc_dapm_context *dapm)
+int snd_soc_dapm_sync_unlocked(struct snd_soc_dapm_context *dapm)
 {
-	int ret;
-
 	/*
 	 * Suppress early reports (eg, jacks syncing their state) to avoid
 	 * silly DAPM runs during card startup.
@@ -2362,8 +2363,25 @@
 	if (!dapm->card || !dapm->card->instantiated)
 		return 0;
 
+	return dapm_power_widgets(dapm->card, SND_SOC_DAPM_STREAM_NOP);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_sync_unlocked);
+
+/**
+ * snd_soc_dapm_sync - scan and power dapm paths
+ * @dapm: DAPM context
+ *
+ * Walks all dapm audio paths and powers widgets according to their
+ * stream or path usage.
+ *
+ * Returns 0 for success.
+ */
+int snd_soc_dapm_sync(struct snd_soc_dapm_context *dapm)
+{
+	int ret;
+
 	mutex_lock_nested(&dapm->card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
-	ret = dapm_power_widgets(dapm->card, SND_SOC_DAPM_STREAM_NOP);
+	ret = snd_soc_dapm_sync_unlocked(dapm);
 	mutex_unlock(&dapm->card->dapm_mutex);
 	return ret;
 }
@@ -2966,13 +2984,13 @@
 	struct snd_soc_dapm_update update;
 	int ret = 0;
 
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] >= e->items)
 		return -EINVAL;
 	mux = ucontrol->value.enumerated.item[0];
 	val = mux << e->shift_l;
 	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] >= e->items)
 			return -EINVAL;
 		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
 		mask |= e->mask << e->shift_r;
@@ -3035,7 +3053,7 @@
 	int change;
 	int ret = 0;
 
-	if (ucontrol->value.enumerated.item[0] >= e->max)
+	if (ucontrol->value.enumerated.item[0] >= e->items)
 		return -EINVAL;
 
 	mutex_lock_nested(&card->dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
@@ -3076,14 +3094,14 @@
 
 	reg_val = snd_soc_read(codec, e->reg);
 	val = (reg_val >> e->shift_l) & e->mask;
-	for (mux = 0; mux < e->max; mux++) {
+	for (mux = 0; mux < e->items; mux++) {
 		if (val == e->values[mux])
 			break;
 	}
 	ucontrol->value.enumerated.item[0] = mux;
 	if (e->shift_l != e->shift_r) {
 		val = (reg_val >> e->shift_r) & e->mask;
-		for (mux = 0; mux < e->max; mux++) {
+		for (mux = 0; mux < e->items; mux++) {
 			if (val == e->values[mux])
 				break;
 		}
@@ -3118,13 +3136,13 @@
 	struct snd_soc_dapm_update update;
 	int ret = 0;
 
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] >= e->items)
 		return -EINVAL;
 	mux = ucontrol->value.enumerated.item[0];
 	val = e->values[ucontrol->value.enumerated.item[0]] << e->shift_l;
 	mask = e->mask << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] >= e->items)
 			return -EINVAL;
 		val |= e->values[ucontrol->value.enumerated.item[1]] << e->shift_r;
 		mask |= e->mask << e->shift_r;
Index: b/sound/soc/soc-jack.c
===================================================================
--- a/sound/soc/soc-jack.c	2016-06-02 12:28:43.401170186 +0800
+++ b/sound/soc/soc-jack.c	2016-06-02 12:28:43.397170197 +0800
@@ -250,7 +250,7 @@
 		report = 0;
 
 	if (gpio->jack_status_check)
-		report = gpio->jack_status_check();
+		report = gpio->jack_status_check(gpio->data);
 
 	snd_soc_jack_report(jack, report, gpio->report);
 }
@@ -342,7 +342,8 @@
 		gpio_export(gpios[i].gpio, false);
 
 		/* Update initial jack status */
-		snd_soc_jack_gpio_detect(&gpios[i]);
+		schedule_delayed_work(&gpios[i].work,
+				      msecs_to_jiffies(gpios[i].debounce_time));
 	}
 
 	return 0;
