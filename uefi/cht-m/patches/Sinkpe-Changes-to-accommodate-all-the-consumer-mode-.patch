From e0d07aa6471a5a222d8e237b5ec2730c70bb5f24 Mon Sep 17 00:00:00 2001
From: "R, Kannappan" <r.kannappan@intel.com>
Date: Mon, 17 Aug 2015 16:03:14 +0530
Subject: [PATCH] Sinkpe: Changes to accommodate all the consumer mode states

Existing code doesn't handle the reset and the error recovery path.
In order to handle this, sink's own task worker is created which
will wait for the port partner's response and move the state machine
accordingly. If sink did not receive the response within the expected
time, it should reset the link and its internal state. If the port
partner is not pd capable, it will goto error recovery state and shall
not respond to port partner's further requests.

Change-Id: I046fdac87c8057044f18599843306eda331b5ad8
Tracked-On: https://jira01.devtools.intel.com/browse/GMINL-16898
Signed-off-by: R, Kannappan <r.kannappan@intel.com>
---
 drivers/usb/typec/pd/policy_engine.c |    2 +-
 drivers/usb/typec/pd/protocol.c      |    2 +-
 drivers/usb/typec/pd/sink_port_pe.c  | 1176 ++++++++++++++++------------------
 drivers/usb/typec/pd/sink_port_pe.h  |   55 +-
 4 files changed, 574 insertions(+), 661 deletions(-)

diff --git a/drivers/usb/typec/pd/policy_engine.c b/drivers/usb/typec/pd/policy_engine.c
index 46f2372ce3e3..b28b2e01f9f3 100644
--- a/drivers/usb/typec/pd/policy_engine.c
+++ b/drivers/usb/typec/pd/policy_engine.c
@@ -465,7 +465,7 @@ static int pe_send_packet(struct policy_engine *pe, void *data, int len,
 {
 	int ret = 0;
 
-	if (!pe_get_pd_state(pe)) {
+	if (!pe_get_pd_state(pe) && evt != PE_EVT_SEND_HARD_RESET) {
 		pr_debug("PE:%s: Not sending pkt, evt=%d\n", __func__, evt);
 		ret = -EINVAL;
 		goto snd_pkt_err;
diff --git a/drivers/usb/typec/pd/protocol.c b/drivers/usb/typec/pd/protocol.c
index db01147d1f8c..a335e7ac9981 100644
--- a/drivers/usb/typec/pd/protocol.c
+++ b/drivers/usb/typec/pd/protocol.c
@@ -254,7 +254,7 @@ static int prot_fwd_ctrlmsg_to_pe(struct pd_prot *pd, struct prot_msg *msg)
 		event = PE_EVT_RCVD_WAIT;
 		break;
 	case PD_CTRL_MSG_SOFT_RESET:
-		/*This should be already handled, dont not forward to pe*/
+		event = PE_EVT_RCVD_SOFT_RESET;
 		break;
 	default:
 		dev_warn(pd->phy->dev, "%s:Unknown msg received, msg_type=%d\n",
diff --git a/drivers/usb/typec/pd/sink_port_pe.c b/drivers/usb/typec/pd/sink_port_pe.c
index b79b035f95e0..5bb4b3beb94c 100644
--- a/drivers/usb/typec/pd/sink_port_pe.c
+++ b/drivers/usb/typec/pd/sink_port_pe.c
@@ -27,9 +27,18 @@
 #include <linux/notifier.h>
 #include <linux/kfifo.h>
 #include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/timer.h>
 #include "policy_engine.h"
 #include "sink_port_pe.h"
 
+static int snkpe_start(struct sink_port_pe *sink);
+static int snkpe_handle_select_capability_state(struct sink_port_pe *sink,
+							struct pd_packet *pkt);
+static int snkpe_handle_give_snk_cap_state(struct sink_port_pe *sink);
+static void sink_port_policy_exit(struct policy *p);
+
 static inline void snkpe_update_state(struct sink_port_pe *sink,
 					enum pe_states cur_state)
 {
@@ -37,7 +46,6 @@ static inline void snkpe_update_state(struct sink_port_pe *sink,
 		return;
 
 	mutex_lock(&sink->snkpe_state_lock);
-	sink->prev_state = sink->cur_state;
 	sink->cur_state = cur_state;
 	mutex_unlock(&sink->snkpe_state_lock);
 }
@@ -51,67 +59,6 @@ static void snkpe_reset_params(struct sink_port_pe *sink)
 	sink->pp_is_ext_pwrd = 0;
 }
 
-static int snkpe_timeout_transition_check(struct sink_port_pe *sink)
-{
-	int ret = 0;
-	enum snkpe_timeout tout = sink->timeout;
-
-	pr_debug("SNKPE: %s tout %d\n", __func__, tout);
-
-	/* ((SinkWaitCapTimer timeout | SinkActivityTimer timeout |
-	 * PSTransitionTimer timeout | NoResponseTimer timeout)
-	 * & (HardResetCounter <= nHardResetCount)) | Hard Reset request
-	 * from Device Policy Manager.
-	 * (OR) SENDER_RESPONSE_TIMER timeout.
-	 */
-	if (((tout == SINK_WAIT_CAP_TIMER || tout == SINK_ACTIVITY_TIMER ||
-		tout == PS_TRANSITION_TIMER || tout == NO_RESPONSE_TIMER) &&
-		(sink->hard_reset_count <= HARD_RESET_COUNT_N)) ||
-		tout == SENDER_RESPONSE_TIMER) {
-
-		/* Move to PE_SNK_Hard_Reset state */
-		snkpe_update_state(sink, PE_SNK_HARD_RESET);
-
-		/* FIXME: Not generating hard reset signal now, since vbus is
-		 * getting diconnect and after that PD charger is not responding
-		 * with source capabilty message.
-		 */
-		sink->hard_reset_count++;
-		/* expect Hard Reset to complete */
-	} else if (tout == NO_RESPONSE_TIMER &&
-		sink->hard_reset_count > HARD_RESET_COUNT_N) {
-
-		/* FIXME : handle ErrorRecovery state */
-		snkpe_update_state(sink, ERROR_RECOVERY);
-	}
-
-	return ret;
-}
-
-static int snkpe_rxmsg_from_fifo(struct sink_port_pe *sink,
-					struct pd_packet *pkt)
-{
-	int len = 0;
-	int ret = 0;
-
-	wait_for_completion(&sink->pktwt_complete);
-	len = kfifo_len(&sink->pkt_fifo);
-	if (len <= 0) {
-		pr_err("SNKPE: Error in getting fifo len %d\n", len);
-		ret = -ENODATA;
-		goto error;
-	}
-	ret = kfifo_out(&sink->pkt_fifo, (unsigned char *)pkt, len);
-	if (ret != len) {
-		pr_warn("SNKPE: pkt size < %d", len);
-		ret = -ENODATA;
-	}
-
-error:
-	reinit_completion(&sink->pktwt_complete);
-	return ret;
-}
-
 static int snkpe_get_req_cap(struct sink_port_pe *sink,
 					struct pd_packet *pkt,
 					struct power_cap *pcap,
@@ -171,17 +118,17 @@ static int snkpe_create_reqmsg(struct sink_port_pe *sink,
 {
 	struct pd_fixed_var_rdo *rdo = (struct pd_fixed_var_rdo *)data;
 	struct req_cap *rcap = &sink->rcap;
-	struct power_cap mpcap;
+	struct power_cap dpm_suggested_cap;
 	int ret;
 
-	ret = policy_get_max_snkpwr_cap(&sink->p, &mpcap);
+	ret = policy_get_snkpwr_cap(&sink->p, &dpm_suggested_cap);
 	if (ret) {
 		pr_err("SNKPE: Error in getting max sink pwr cap %d\n",
 				ret);
 		goto error;
 	}
 
-	ret = snkpe_get_req_cap(sink, pkt, &mpcap, rcap);
+	ret = snkpe_get_req_cap(sink, pkt, &dpm_suggested_cap, rcap);
 	if (ret < 0) {
 		pr_err("SNKPE: Unable to get the Sink Port PE cap\n");
 		goto error;
@@ -198,52 +145,18 @@ error:
 	return ret;
 }
 
-static int snkpe_get_msg(struct sink_port_pe *sink, struct pd_packet *pkt,
-				int msg, u32 *data)
-{
-	int ret = 0;
-
-	switch (msg) {
-	case PE_EVT_SEND_REQUEST:
-		ret = snkpe_create_reqmsg(sink, pkt, data);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-
-static void snkpe_txmsg_to_fifo(struct sink_port_pe *sink,
-					struct pd_packet *pkt)
-{
-	int len = 0;
-
-	len = PD_MSG_LEN(&pkt->header) + PD_MSG_HEADER_SIZE;
-	kfifo_in(&sink->pkt_fifo, (const unsigned char *)pkt, len);
-	complete(&sink->pktwt_complete);
-}
-
-static int snkpe_handle_gotomin_msg(struct sink_port_pe *sink)
-{
-	return snkpe_handle_transition_sink_state(sink);
-}
-
 static int snkpe_send_pr_swap_accept(struct sink_port_pe *sink)
 {
 	snkpe_update_state(sink, PE_PRS_SNK_SRC_ACCEPT_PR_SWAP);
-	sink->pevt = PE_EVT_SEND_ACCEPT;
 	return policy_send_packet(&sink->p, NULL, 0,
-					PD_CTRL_MSG_ACCEPT, sink->pevt);
+					PD_CTRL_MSG_ACCEPT, PE_EVT_SEND_ACCEPT);
 }
 
 static int snkpe_send_pr_swap_reject(struct sink_port_pe *sink)
 {
 	snkpe_update_state(sink, PE_PRS_SNK_SRC_REJECT_PR_SWAP);
-	sink->pevt = PE_EVT_SEND_REJECT;
 	return policy_send_packet(&sink->p, NULL, 0,
-					PD_CTRL_MSG_REJECT, sink->pevt);
+				PD_CTRL_MSG_REJECT, PE_EVT_SEND_REJECT);
 }
 
 static int snkpe_handle_pr_swap(struct sink_port_pe *sink)
@@ -298,124 +211,9 @@ static void snkpe_reinitialize_completion(struct sink_port_pe *sink)
 {
 	reinit_completion(&sink->wct_complete);
 	reinit_completion(&sink->srt_complete);
-	reinit_completion(&sink->nrt_complete);
 	reinit_completion(&sink->pstt_complete);
 	reinit_completion(&sink->sat_complete);
-	reinit_completion(&sink->srqt_complete);
 	reinit_completion(&sink->pssoff_complete);
-	reinit_completion(&sink->pktwt_complete);
-}
-
-static int snkpe_start(struct sink_port_pe *sink)
-{
-	enum cable_state sink_cable_state;
-	int ret = 0;
-
-	pr_debug("SNKPE: %s\n", __func__);
-	if (sink->cur_state == PE_SNK_TRANSITION_TO_DEFAULT) {
-		complete(&sink->nrt_complete);
-		return 0;
-	}
-
-	/*---------- Start of Sink Port PE --------------*/
-	snkpe_reset_params(sink);
-	/* get the sink_cable_state, in case of boot with cable */
-	sink_cable_state = policy_get_cable_state(&sink->p,
-					CABLE_TYPE_CONSUMER);
-	if (sink_cable_state < 0) {
-		pr_err("SNKPE: Error in getting vbus state!\n");
-		return ret;
-	}
-	if (sink_cable_state == CABLE_ATTACHED)
-		sink->is_sink_cable_connected = true;
-	else
-		sink->is_sink_cable_connected = false;
-
-	if (sink->is_sink_cable_connected) {
-		if (sink->cur_state != PE_SNK_STARTUP)
-			return 0;
-	} else {
-		mutex_lock(&sink->snkpe_state_lock);
-		sink->cur_state = PE_SNK_STARTUP;
-		mutex_unlock(&sink->snkpe_state_lock);
-		return snkpe_do_prot_reset(sink);
-	}
-
-	/* move the state from PE_SNK_STARTUP to PE_SNK_DISCOVERY */
-	snkpe_update_state(sink, PE_SNK_DISCOVERY);
-
-	/* wait for vbus: get notification from device policy manager
-	 * to continue the next state.
-	 */
-	if (sink->is_sink_cable_connected)
-		snkpe_vbus_attached(sink);
-
-	return ret;
-}
-
-static inline int sink_port_policy_start(struct policy *p)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-
-	pr_debug("SNKPE: %s\n", __func__);
-	mutex_lock(&sink->snkpe_state_lock);
-	p->status = POLICY_STATUS_RUNNING;
-	p->state = POLICY_STATE_ONLINE;
-	sink->cur_state = PE_SNK_STARTUP;
-	mutex_unlock(&sink->snkpe_state_lock);
-	return snkpe_start(sink);
-}
-
-static int sink_port_policy_stop(struct policy *p)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-
-	pr_debug("SNKPE: %s\n", __func__);
-	/* reset HardResetCounter to zero upon vbus disconnect.
-	 */
-	mutex_lock(&sink->snkpe_state_lock);
-	sink->hard_reset_count = 0;
-	p->status = POLICY_STATUS_UNKNOWN;
-	p->state = POLICY_STATE_OFFLINE;
-	sink->is_sink_cable_connected = false;
-	mutex_unlock(&sink->snkpe_state_lock);
-	policy_set_pd_state(p, false);
-
-	cancel_work_sync(&sink->timer_work);
-	snkpe_reinitialize_completion(sink);
-	/* FIXME: handle the stop state */
-	snkpe_do_prot_reset(sink);
-	mutex_lock(&sink->snkpe_state_lock);
-	sink->cur_state = PE_SNK_STARTUP;
-	mutex_unlock(&sink->snkpe_state_lock);
-
-	return 0;
-}
-
-static int sink_port_policy_rcv_cmd(struct policy *p, enum pe_event evt)
-{
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-	int ret = 0;
-
-	switch (evt) {
-	case PE_EVT_RCVD_HARD_RESET:
-		ret = snkpe_do_prot_reset(sink);
-		sink_port_policy_stop(p);
-		snkpe_update_state(sink, PE_SNK_STARTUP);
-		sink_port_policy_start(p);
-		break;
-	case PE_EVT_RCVD_HARD_RESET_COMPLETE:
-		return snkpe_handle_transition_to_default(sink);
-	default:
-		pr_err("SNKPE: %s evt - %d\n", __func__, evt);
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
 }
 
 /* This function will set the role to POWER_ROLE_SWAP, disable charging
@@ -446,58 +244,75 @@ static int snkpe_handle_pss_transition_to_off(struct sink_port_pe *sink)
 trans_to_off_err:
 	/* Move to PE_SNK_Hard_Reset state */
 	snkpe_update_state(sink, PE_SNK_HARD_RESET);
+	schedule_work(&sink->timer_work);
 	return ret;
 }
 
-static int snkpe_received_msg_good_crc(struct sink_port_pe *sink)
+static void snkpe_handle_send_swap(struct sink_port_pe *sink)
 {
-	int ret = 0;
+	int ret;
+
+	ret = wait_for_completion_timeout(&sink->srt_complete,
+				msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER));
 
-	if (snkpe_is_cur_state(sink, PE_SNK_SELECT_CAPABILITY) ||
-		snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_SEND_PR_SWAP)) {
+	if (ret == 0) {
+		pr_warn("SNKPE: %s sender response expired\n", __func__);
+		snkpe_update_state(sink, PE_SNK_HARD_RESET);
 		schedule_work(&sink->timer_work);
-		pr_debug("SNKPE: Received ack for PD_DATA_MSG_REQUEST\n");
-	} else if (snkpe_is_cur_state(sink, PE_SNK_GIVE_SINK_CAP) &&
-		snkpe_is_prev_evt(sink, PE_EVT_SEND_SNK_CAP)) {
-		pr_debug("SNKPE: Received ack for PD_DATA_MSG_SINK_CAP\n");
-		return snkpe_handle_snk_ready_state(sink, sink->pevt);
-	} else if (snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_REJECT_PR_SWAP)) {
-		snkpe_update_state(sink, PE_SNK_READY);
-	} else if (snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_ACCEPT_PR_SWAP)) {
-		ret = snkpe_handle_pss_transition_to_off(sink);
-	} else if (snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_SOURCE_ON) &&
-		snkpe_is_prev_evt(sink, PE_EVT_SEND_PS_RDY)) {
-		pr_debug("SNKPE: PR_SWAP Authentication Success!\n");
-		policy_switch_policy(&sink->p, POLICY_TYPE_SOURCE);
-	} else {
-		pr_warn("SNKPE: Received Good CRC at state %d pevt %d\n",
-					 sink->cur_state, sink->pevt);
-		ret = -EINVAL;
+		goto send_swap_out;
+	}
+	/* Either accepr or reject received */
+	switch (sink->cur_state) {
+	case PE_PRS_SNK_SRC_SEND_PR_SWAP:
+		if (sink->last_pkt == PE_EVT_RCVD_ACCEPT) {
+			pr_debug("SNKPE:%s: PR_Swap accepted\n", __func__);
+			/* PR_SWAP accepted, transition to sink off*/
+			snkpe_handle_pss_transition_to_off(sink);
+		} else {
+			pr_debug("SNKPE:%s: PR_Swap not accepted\n", __func__);
+			/* PR_SWAP not accepted, go to ready state*/
+			snkpe_update_state(sink, PE_SNK_READY);
+		}
+		break;
+	case PE_EVT_SEND_DR_SWAP:
+		/* TODO: handle for data role swap */
+		break;
+	default:
+		pr_warn("SNKPE:%s: unexpected state=%d\n", __func__,
+						sink->cur_state);
 	}
 
-	return ret;
+send_swap_out:
+	reinit_completion(&sink->srt_complete);
 }
 
-static int snkpe_received_msg_ps_rdy(struct sink_port_pe *sink)
+static void snkpe_received_msg_good_crc(struct sink_port_pe *sink)
 {
-	int ret = 0;
 
-	if ((snkpe_is_prev_state(sink, PE_SNK_SELECT_CAPABILITY) ||
-		snkpe_is_prev_state(sink, PE_SNK_READY)) &&
-		snkpe_is_cur_state(sink, PE_SNK_TRANSITION_SINK)) {
-		complete(&sink->pstt_complete);
-	} else if (snkpe_is_prev_state(sink, PE_SNK_SELECT_CAPABILITY) &&
-		snkpe_is_cur_state(sink, PE_SNK_READY)) {
-		complete(&sink->srqt_complete);
-	} else if (snkpe_is_cur_state(sink,
-			PE_PRS_SNK_SRC_TRANSITION_TO_OFF)) {
-		complete(&sink->pssoff_complete);
-	} else {
-		pr_err("SNKPE: Error in State Machine!\n");
-		ret = -EINVAL;
+	switch (sink->cur_state) {
+	case PE_SNK_SOFT_RESET:
+		if (sink->last_pkt == PE_EVT_RCVD_ACCEPT) {
+			snkpe_update_state(sink, PE_SNK_STARTUP);
+			schedule_work(&sink->timer_work);
+		}
+		break;
+	case PE_SNK_GIVE_SINK_CAP:
+		snkpe_update_state(sink, PE_SNK_READY);
+		break;
+	case PE_SNK_SELECT_CAPABILITY:
+		schedule_work(&sink->timer_work);
+		break;
+	case PE_PRS_SNK_SRC_ACCEPT_PR_SWAP:
+		snkpe_handle_pss_transition_to_off(sink);
+		break;
+	case PE_PRS_SNK_SRC_SOURCE_ON:
+		pr_debug("SNKPE:%s: Calling swith policy\n", __func__);
+		policy_switch_policy(&sink->p, POLICY_TYPE_SOURCE);
+		break;
+	default:
+		pr_warn("SNKPE: Recved GOODCRC in %d state\n", sink->cur_state);
+		break;
 	}
-
-	return ret;
 }
 
 static int sink_port_policy_rcv_request(struct policy *p, enum pe_event evt)
@@ -507,17 +322,17 @@ static int sink_port_policy_rcv_request(struct policy *p, enum pe_event evt)
 
 	switch (evt) {
 	case PE_EVT_SEND_PR_SWAP:
-		if (sink->pp_is_ext_pwrd || (!sink->pp_is_dual_prole)) {
+		if (sink->pp_is_ext_pwrd || (!sink->pp_is_dual_prole)
+			|| (sink->cur_state != PE_SNK_READY)) {
 			pr_info("SNKPE:%s: Not processing PR_SWAP Req\n",
 					__func__);
 			break;
 		}
 		snkpe_update_state(sink, PE_PRS_SNK_SRC_SEND_PR_SWAP);
-		sink->pevt = evt;
 		policy_send_packet(&sink->p, NULL, 0,
-				PD_CTRL_MSG_PR_SWAP, sink->pevt);
+				PD_CTRL_MSG_PR_SWAP, evt);
 		/* work schedule for rcv good crc for PR_SWAP and
-		 * recevice Accept */
+		 * receive Accept/reject */
 		schedule_work(&sink->timer_work);
 		break;
 	case PE_EVT_SEND_DR_SWAP:
@@ -528,95 +343,50 @@ static int sink_port_policy_rcv_request(struct policy *p, enum pe_event evt)
 	return 0;
 }
 
-static int sink_port_policy_rcv_pkt(struct policy *p, struct pd_packet *pkt,
-				enum pe_event evt)
+static void sink_handle_src_cap(struct sink_port_pe *sink,
+					struct pd_packet *pkt)
 {
-	struct sink_port_pe *sink = container_of(p,
-					struct sink_port_pe, p);
-	int ret = 0;
+	snkpe_update_state(sink, PE_SNK_EVALUATE_CAPABILITY);
 
-	pr_debug("SNKPE:%s:evt = %d\n", __func__, evt);
-	/* good crc is the ack for the actual command/message */
-	if (evt != PE_EVT_RCVD_GOODCRC)
-		sink->pevt = evt;
+	sink->hard_reset_count = 0;
+	if (timer_pending(&sink->no_response_timer))
+		del_timer_sync(&sink->no_response_timer);
+	sink->no_response_timer_expired = false;
 
-	switch (evt) {
-	case PE_EVT_RCVD_SRC_CAP:
-		/* FIXME: We can check here only the cur state */
-		snkpe_txmsg_to_fifo(sink, pkt);
-		if (sink->prev_state == PE_SNK_DISCOVERY &&
-			sink->cur_state == PE_SNK_WAIT_FOR_CAPABILITIES)
-			complete(&sink->wct_complete);
-		else if (sink->cur_state == PE_SNK_TRANSITION_TO_DEFAULT)
-			complete(&sink->nrt_complete);
-		else if (sink->cur_state != ERROR_RECOVERY)
-			/* Handle source cap data at all states */
-			 return snkpe_handle_evaluate_capability(sink);
-		break;
-	case PE_EVT_RCVD_GET_SINK_CAP:
-		if (sink->cur_state != ERROR_RECOVERY) {
-			return snkpe_handle_give_snk_cap_state(sink);
-		} else {
-			pr_err("SNKPE: Error in State Machine!\n");
-			ret = -EINVAL;
-		}
-		break;
+	policy_set_pd_state(&sink->p, true);
+
+	snkpe_handle_select_capability_state(sink, pkt);
 
+}
+
+static void sink_handle_accept_reject_wait(struct sink_port_pe *sink,
+					enum pe_event evt)
+{
+	switch (evt) {
 	case PE_EVT_RCVD_ACCEPT:
+		snkpe_update_state(sink, PE_SNK_TRANSITION_SINK);
+		break;
 	case PE_EVT_RCVD_REJECT:
 	case PE_EVT_RCVD_WAIT:
-		/* Move to PE_SNK_Ready state as per state machine */
-		if (((sink->prev_state == PE_SNK_EVALUATE_CAPABILITY ||
-			sink->prev_state == PE_SNK_READY) &&
-			sink->cur_state == PE_SNK_SELECT_CAPABILITY) ||
-			snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_SEND_PR_SWAP)) {
-			complete(&sink->srt_complete);
-		} else {
-			pr_err("SNKPE: Error in State Machine!\n");
-			ret = -EINVAL;
-		}
-		break;
-	case PE_EVT_RCVD_PS_RDY:
-		ret = snkpe_received_msg_ps_rdy(sink);
-		break;
-	case PE_EVT_RCVD_PING:
-		if (sink->cur_state == PE_SNK_READY) {
-			/* FIXME: stay in the current state...
-			 */
-		}
-		break;
-	case PE_EVT_RCVD_GOTOMIN:
-		if (sink->cur_state == PE_SNK_READY) {
-			return snkpe_handle_gotomin_msg(sink);
-		} else {
-			pr_err("SNKPE: Error in State Machine!\n");
-			ret = -EINVAL;
-		}
-		break;
-	case PE_EVT_RCVD_GOODCRC:
-		ret = snkpe_received_msg_good_crc(sink);
-		break;
-	case PE_EVT_RCVD_PR_SWAP:
-		if (sink->cur_state != ERROR_RECOVERY) {
-			return snkpe_handle_pr_swap(sink);
-		} else {
-			pr_err("SNKPE: SM is in Error Recovery Mode!\n");
-			ret = -EINVAL;
-		}
+		snkpe_update_state(sink, PE_SNK_READY);
 		break;
 	default:
-		break;
+		pr_warn("SNKPE: recvd (%d) in select cap\n", evt);
+		goto end;
 	}
-
-	return ret;
+	schedule_work(&sink->timer_work);
+end:
+	return;
 }
 
+
 static int snkpe_setup_charging(struct sink_port_pe *sink)
 {
 	int ret = 0;
 
+	pr_debug("SNKPE:%s In\n", __func__);
 	/* Update the charger input current limit */
-	ret = policy_update_charger_ilim(&sink->p, sink->ilim);
+	ret = policy_update_charger_ilim(&sink->p, sink->rcap.ma);
 	if (ret < 0) {
 		pr_err("SNKPE: Error in updating charger ilim (%d)\n",
 				ret);
@@ -632,98 +402,23 @@ static int snkpe_setup_charging(struct sink_port_pe *sink)
 	return ret;
 }
 
-static int snkpe_handle_transition_to_default(struct sink_port_pe *sink)
+/* This function will read the port partner capabilities and
+ * save it for further use.
+ */
+static void snkpe_read_src_caps(struct sink_port_pe *sink,
+					struct pd_packet *pkt)
 {
-	int ret = 0;
-	unsigned long timeout;
-
-	snkpe_update_state(sink, PE_SNK_TRANSITION_TO_DEFAULT);
-
-	/* FIXME: Request Device Policy Manager to request power sink transition
-	 * to default Reset local HW, handled automatically based on cable event
-	 */
+	struct pd_fixed_supply_pdo *pdo =
+			(struct pd_fixed_supply_pdo *) &pkt->data_obj[0];
 
-	/* Actions on exit: Initialize and run NoResponseTimer Inform Protocol
-	 * Layer Hard Reset complete.
-	 */
-	timeout = msecs_to_jiffies(TYPEC_NO_RESPONSE_TIMER);
-	/* unblock this once PS_RDY msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&sink->nrt_complete,
-						timeout);
-	if (ret == 0) {
-		sink->timeout = NO_RESPONSE_TIMER;
-		ret = snkpe_timeout_transition_check(sink);
-		goto end;
+	if (pdo->fixed_supply != SUPPLY_TYPE_FIXED) {
+		pr_debug("SNKPE:%s: source is not fixed supply\n",
+					__func__);
+		return;
 	}
-
-	sink->cur_state = PE_SNK_STARTUP;
-	if (sink->pevt != PE_EVT_RCVD_SRC_CAP)
-		ret = snkpe_start(sink);
-	else
-		ret = snkpe_handle_evaluate_capability(sink);
-
-end:
-	reinit_completion(&sink->nrt_complete);
-	return ret;
-}
-
-
-static int snkpe_handle_transition_sink_state(struct sink_port_pe *sink)
-{
-	int ret = 0;
-	unsigned long timeout;
-
-	snkpe_update_state(sink, PE_SNK_TRANSITION_SINK);
-
-	/* FIXME: Request Device Policy Manager transitions sink power
-	 * supply to new power (if required): handled in next state (READY) */
-
-	/* Put the charger into HiZ mode */
-	ret = policy_set_charger_mode(&sink->p, CHRGR_SET_HZ);
-	if (ret < 0)
-		pr_err("SNKPE: Error in putting into HiZ mode (%d)\n", ret);
-
-	if (sink->pevt != PE_EVT_RCVD_GOTOMIN)
-		sink->ilim = sink->rcap.ma;
-	else
-		sink->ilim = 0;
-
-	/* Initialize and run PSTransitionTimer */
-	timeout = msecs_to_jiffies(TYPEC_PS_TRANSITION_TIMER);
-	/* unblock this once PS_RDY msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&sink->pstt_complete,
-						timeout);
-	if (ret == 0) {
-		sink->timeout = PS_TRANSITION_TIMER;
-		ret = snkpe_timeout_transition_check(sink);
-		goto error;
-	}
-	ret = snkpe_handle_snk_ready_state(sink, sink->pevt);
-
-error:
-	reinit_completion(&sink->pstt_complete);
-	return ret;
-}
-
-/* This function will read the port partner capabilities and
- * save it for further use.
- */
-static void snkpe_read_src_caps(struct sink_port_pe *sink,
-					struct pd_packet *pkt)
-{
-	struct pd_fixed_supply_pdo *pdo =
-			(struct pd_fixed_supply_pdo *) &pkt->data_obj[0];
-
-	if (pdo->fixed_supply != SUPPLY_TYPE_FIXED) {
-		pr_debug("SNKPE:%s: source is not fixed supply\n",
-					__func__);
-		return;
-	}
-	sink->pp_is_dual_prole = pdo->dual_role_pwr;
-	sink->pp_is_dual_drole = pdo->data_role_swap;
-	sink->pp_is_ext_pwrd = pdo->ext_powered;
+	sink->pp_is_dual_prole = pdo->dual_role_pwr;
+	sink->pp_is_dual_drole = pdo->data_role_swap;
+	sink->pp_is_ext_pwrd = pdo->ext_powered;
 
 	pr_debug("SNKPE:%s:dual_prole=%d, dual_drole=%d, ext_pwrd=%d",
 			__func__, sink->pp_is_dual_prole,
@@ -734,28 +429,25 @@ static int snkpe_handle_select_capability_state(struct sink_port_pe *sink,
 							struct pd_packet *pkt)
 {
 	int ret = 0;
-	enum pe_event evt;
 	u32 data = 0;
 
 	/* move the next state PE_SNK_Select_Capability */
 	snkpe_update_state(sink, PE_SNK_SELECT_CAPABILITY);
 
 	snkpe_read_src_caps(sink, pkt);
-
-	evt = PE_EVT_SEND_REQUEST;
 	/* make request message and send to PE -> protocol */
-	ret = snkpe_get_msg(sink, pkt, evt, &data);
+	ret = snkpe_create_reqmsg(sink, pkt, &data);
 	if (ret < 0) {
 		pr_err("SNKPE: Error in getting message!\n");
 		goto error;
 	}
 
-	ret = policy_send_packet(&sink->p, &data, 4, PD_DATA_MSG_REQUEST, evt);
+	ret = policy_send_packet(&sink->p, &data, 4, PD_DATA_MSG_REQUEST,
+							PE_EVT_SEND_REQUEST);
 	if (ret < 0) {
 		pr_err("SNKPE: Error in sending packet!\n");
 		goto error;
 	}
-	sink->pevt = evt;
 	pr_debug("SNKPE: PD_DATA_MSG_REQUEST Sent\n");
 
 	/* Keeping backup to use later if required for wait event and
@@ -766,42 +458,10 @@ error:
 	return ret;
 }
 
-static int snkpe_handle_after_request_sent(struct sink_port_pe *sink)
-{
-	unsigned long timeout;
-	int ret;
-
-	/* Initialize and run SenderResponseTimer */
-	timeout = msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER);
-	/* unblock this once Accept msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&sink->srt_complete, timeout);
-	if (ret == 0) {
-		sink->timeout = SENDER_RESPONSE_TIMER;
-		ret = snkpe_timeout_transition_check(sink);
-		goto error;
-	}
-
-	if (sink->pevt == PE_EVT_RCVD_ACCEPT) {
-		if (snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_SEND_PR_SWAP))
-			ret = snkpe_handle_pss_transition_to_off(sink);
-		else
-			ret = snkpe_handle_transition_sink_state(sink);
-	} else if (sink->pevt == PE_EVT_RCVD_REJECT ||
-		sink->pevt == PE_EVT_RCVD_WAIT)
-		ret = snkpe_handle_snk_ready_state(sink, sink->pevt);
-	else
-		pr_err("SNKPE: Unknown event: %d\n", sink->pevt);
-error:
-	reinit_completion(&sink->srt_complete);
-	return ret;
-}
-
 static int snkpe_handle_give_snk_cap_state(struct sink_port_pe *sink)
 {
 	int ret = 0;
 	int i;
-	enum pe_event evt;
 	struct power_caps pcaps;
 	struct pd_sink_fixed_pdo pdo[MAX_NUM_DATA_OBJ] = { {0} };
 
@@ -819,239 +479,522 @@ static int snkpe_handle_give_snk_cap_state(struct sink_port_pe *sink)
 		pdo[i].volt = (VOLT_TO_DATA_OBJ(pcaps.pcap[i].mv) >>
 					SNK_FSPDO_VOLT_SHIFT);
 		/* FIXME: get it from dpm once the dpm provides the caps */
-		pdo[i].data_role_swap = 0;
-		pdo[i].usb_comm = 0;
+		pdo[i].data_role_swap = 1;
+		pdo[i].usb_comm = 1;
 		pdo[i].ext_powered = 0;
 		pdo[i].higher_cap = 0;
-		pdo[i].dual_role_pwr = 0;
+		pdo[i].dual_role_pwr = 1;
 		pdo[i].supply_type = 0;
 	}
 
-	evt = PE_EVT_SEND_SNK_CAP;
 	ret = policy_send_packet(&sink->p, pdo, pcaps.n_cap * 4,
-					PD_DATA_MSG_SINK_CAP, evt);
+					PD_DATA_MSG_SINK_CAP,
+					PE_EVT_SEND_SNK_CAP);
 	if (ret < 0) {
 		pr_err("SNKPE: Error in sending packet!\n");
 		goto error;
 	}
-	sink->pevt = evt;
 	pr_debug("SNKPE: PD_DATA_MSG_SINK_CAP sent\n");
 
 error:
 	return ret;
 }
 
-static int snkpe_handle_psrdy_after_wait_state(struct sink_port_pe *sink)
+/* After accepting the pr_swap and disabling the charging
+ * (in PE_PRS_SNK_SRC_TRANSITION_TO_OFF state), this function
+ * will wait for ps_rdy from source with timeout. On timeout,
+ * pe will move to hard reset state. If ps_rdy received on-time
+ * then move to source mode.
+ */
+static void snkpe_handle_pss_transition_off(struct sink_port_pe *sink)
 {
 	int ret;
+	unsigned long timeout;
 
-	/* Put the charger into HiZ mode */
-	ret = policy_set_charger_mode(&sink->p, CHRGR_SET_HZ);
-	if (ret < 0) {
-		pr_err("SNKPE: Error in putting into HiZ mode (%d)\n", ret);
-		return ret;
-	}
-	sink->ilim = sink->rcap.ma;
+	/* initialize and run the PSSourceOffTimer */
+	timeout = msecs_to_jiffies(TYPEC_PS_SRC_OFF_TIMER);
+	/* unblock this once PS_RDY msg received by checking the
+	 * cur_state */
+	ret = wait_for_completion_timeout(&sink->pssoff_complete,
+						timeout);
+	if (!ret)
+		goto trans_off_err;
 
-	ret = snkpe_setup_charging(sink);
-	if (ret < 0)
-		pr_err("SNKPE: Error in setup charging (%d)\n", ret);
+	pr_info("SNKPE: Received PS_RDY\n");
+	/* Pull-up CC (enable Rp) and Vbus 5V enable */
+	ret = policy_set_power_role(&sink->p, POWER_ROLE_SOURCE);
+	if (ret)
+		goto trans_off_err;
 
-	return ret;
+	/* SourceActivityTimer (40 - 50mSec) is not used to monitor source
+	 * activity. Assuming the source activity can be done within the time
+	 */
+	snkpe_update_state(sink, PE_PRS_SNK_SRC_SOURCE_ON);
+	policy_send_packet(&sink->p, NULL, 0,
+			PD_CTRL_MSG_PS_RDY, PE_EVT_SEND_PS_RDY);
+
+	return;
+
+trans_off_err:
+	pr_err("SNKPE: Error in pss_transition_off %d\n", ret);
+	/* Move to PE_SNK_Hard_Reset state */
+	snkpe_update_state(sink, PE_SNK_HARD_RESET);
+	schedule_work(&sink->timer_work);
+	return;
 }
 
-static int snkpe_handle_snk_ready_state(struct sink_port_pe *sink,
-						enum pe_event evt)
+static void snkpe_handle_startup(struct sink_port_pe *sink)
 {
-	int ret = 0;
-	unsigned long timeout;
-
-	snkpe_update_state(sink, PE_SNK_READY);
+	int ret;
+	unsigned long timeout =
+		msecs_to_jiffies(TYPEC_SINK_WAIT_CAP_TIMER);
 
-	/* TODO: if Update remote capabilities request from received from
-	 * Device Policy Manager move to PE_SNK_Get_Source_Cap state and
-	 * send Send Get_Source_Cap message, then move to PE_SNK_Ready state.
-	 */
+	if (sink->cur_state == PE_SNK_STARTUP ||
+		sink->cur_state == PE_SNK_DISCOVERY) {
+		snkpe_update_state(sink, PE_SNK_WAIT_FOR_CAPABILITIES);
 
-	switch (evt) {
-	case PE_EVT_RCVD_PS_RDY:
-		ret = snkpe_setup_charging(sink);
-		if (ret < 0)
-			pr_warn("SNKPE: Error in setup charging (%d)\n", ret);
-		break;
-	case PE_EVT_RCVD_REJECT:
-	case PE_EVT_SEND_SNK_CAP:
-	case PE_EVT_SEND_GET_SRC_CAP:
-		/* Do nothing and continue in the same state */
-		break;
-	case PE_EVT_RCVD_WAIT:
-		/* Initialize and run SinkRequestTimer (on receiving
-		 * Wait) for PS_RDY */
-		timeout = msecs_to_jiffies(TYPEC_SINK_REQUEST_TIMER);
-		ret = wait_for_completion_timeout(&sink->srqt_complete,
-							timeout);
+		/* Initialize and run SinkWaitCapTimer */
+		/* unblock this once source cap rcv by checking the cur_state */
+		ret = wait_for_completion_timeout(&sink->wct_complete, timeout);
 		if (ret == 0) {
-			/* New power required | SinkRequestTimer timeout */
-			sink->cur_state = PE_SNK_EVALUATE_CAPABILITY;
-			ret = snkpe_handle_select_capability_state(
-					sink, &sink->prev_pkt);
-			goto end;
+			snkpe_update_state(sink, PE_SNK_HARD_RESET);
+			schedule_work(&sink->timer_work);
 		}
-		reinit_completion(&sink->srqt_complete);
+	}
 
-		/* Received PS_RDY event after a WAIT event */
-		ret = snkpe_handle_psrdy_after_wait_state(sink);
-		break;
-	default:
-		pr_err("SNKPE: Unknown state to handle ready evt = %d\n", evt);
-		ret = -EINVAL;
+	reinit_completion(&sink->wct_complete);
+}
+
+static void snkpe_handle_sink_hard_reset(struct sink_port_pe *sink)
+{
+	pr_warn("SNKPE: transitioning to hard reset\n");
+	/* send hard reset */
+	sink->hard_reset_complete = false;
+	policy_send_packet(&sink->p, NULL, 0, PD_CMD_HARD_RESET,
+			PE_EVT_SEND_HARD_RESET);
+
+	/* increment counter */
+	sink->hard_reset_count++;
+	/* wait for hardrst complete */
+	wait_event(sink->wq, sink->hard_reset_complete);
+
+	if ((sink->last_pkt == PE_EVT_RCVD_HARD_RESET) ||
+		(sink->last_pkt == PE_EVT_RCVD_SOFT_RESET)) {
+		/* this will move the state to SNK_STARTUP */
+		sink->hard_reset_count = 0;
+		return;
 	}
-	return 0;
 
-end:
-	reinit_completion(&sink->srqt_complete);
-	return ret;
+	if (!timer_pending(&sink->no_response_timer))
+		mod_timer(&sink->no_response_timer,
+				msecs_to_jiffies(TYPEC_NO_RESPONSE_TIMER));
+
+	snkpe_update_state(sink, PE_SNK_STARTUP);
+	schedule_work(&sink->timer_work);
 }
 
-static int snkpe_handle_evaluate_capability(struct sink_port_pe *sink)
+static void sink_handle_select_cap(struct sink_port_pe *sink)
 {
-	int ret = 0;
-	struct pd_packet pkt = { {0} };
+	int ret;
 
-	snkpe_update_state(sink, PE_SNK_EVALUATE_CAPABILITY);
+	sink->resend_cap = false;
+	ret = wait_for_completion_timeout(&sink->srt_complete,
+				msecs_to_jiffies(TYPEC_SENDER_RESPONSE_TIMER));
 
-	/* FIXME: Stop NoResponseTimer and reset HardResetCounter to
-	 * zero. Ask Device Policy Manager to evaluate option based on
-	 * supplied capabilities (from supplied capabilities, reserve or
-	 * Capability (Mismatch.).
-	 */
-	sink->hard_reset_count = 0;
-	policy_set_pd_state(&sink->p, true);
+	if (ret == 0) {
+		pr_warn("SNKPE: %s sender response expired\n", __func__);
+		snkpe_update_state(sink, PE_SNK_HARD_RESET);
+		schedule_work(&sink->timer_work);
+	}
+	reinit_completion(&sink->srt_complete);
+}
 
-	/* Receive the pd_packet for the source cap message */
-	ret = snkpe_rxmsg_from_fifo(sink, &pkt);
-	if (ret < 0) {
-		pr_err("SNKPE: Error in reading data from fio\n");
-		goto error;
+static void sink_handle_ready(struct sink_port_pe *sink)
+{
+	pr_debug("SNKPE: %s: last_pkt = %d cur_state %d\n", __func__,
+			sink->last_pkt, sink->cur_state);
+	if (sink->last_pkt == PE_EVT_RCVD_WAIT) {
+		pr_info("SNKPE:%s: wait\n", __func__);
+		schedule_work(&sink->request_timer);
+		goto ready_end;
 	}
-	return snkpe_handle_select_capability_state(sink, &pkt);
+	if (sink->cur_state == PE_SNK_TRANSITION_SINK)
+		snkpe_setup_charging(sink);
 
-error:
-	return ret;
+ready_end:
+	snkpe_update_state(sink, PE_SNK_READY);
 }
 
-static int snkpe_handle_assert_rp_src_on(struct sink_port_pe *sink)
+static void sink_handle_transition_sink(struct sink_port_pe *sink)
 {
 	int ret;
 
-	snkpe_update_state(sink, PE_PRS_SNK_SRC_SOURCE_ON);
+	pr_debug("SNKPE:%s: in\n", __func__);
+	policy_set_charger_mode(&sink->p, CHRGR_SET_HZ);
+	ret = wait_for_completion_timeout(&sink->pstt_complete,
+				msecs_to_jiffies(TYPEC_PS_TRANSITION_TIMER));
 
-	/* Pull-up CC (enable Rp) and Vbus 5V enable */
-	ret = policy_set_power_role(&sink->p, POWER_ROLE_SOURCE);
-	if (ret < 0) {
-		pr_err("SNKPE: Error in enabling source %d\n", ret);
-		return ret;
+	if (ret == 0) {
+		pr_warn("SNKPE: %s PSTransition expired\n", __func__);
+		policy_set_charger_mode(&sink->p, CHRGR_ENABLE);
+		snkpe_update_state(sink, PE_SNK_HARD_RESET);
+		schedule_work(&sink->timer_work);
+		goto trans_sink_end;
 	}
-	/* SourceActivityTimer (40 - 50mSec) is not used to monitor source
-	 * activity. Assuming the source activity can be done within the time
-	 */
-	sink->pevt = PE_EVT_SEND_PS_RDY;
-	return policy_send_packet(&sink->p, NULL, 0,
-					PD_CTRL_MSG_PS_RDY, sink->pevt);
+
+	/* PS_RDY received, handle it*/
+	sink_handle_ready(sink);
+
+trans_sink_end:
+	reinit_completion(&sink->pstt_complete);
 }
 
-/* After accepting the pr_swap and disabling the charging
- * (in PE_PRS_SNK_SRC_TRANSITION_TO_OFF state), this function
- * will wait for ps_rdy from source with timeout. On timeout,
- * pe will move to hard reset state. If ps_rdy received on-time
- * then move to source mode.
- */
-static void snkpe_handle_pss_transition_off(struct sink_port_pe *sink)
+/* wait for request timer expired to restart the request */
+static void sink_request_timer_work(struct work_struct *work)
 {
-	int ret;
-	unsigned long timeout;
+	struct sink_port_pe *sink = container_of(work,
+					struct sink_port_pe,
+					request_timer);
 
-	/* initialize and run the PSSourceOffTimer */
-	timeout = msecs_to_jiffies(TYPEC_PS_SRC_OFF_TIMER);
-	/* unblock this once PS_RDY msg received by checking the
-	 * cur_state */
-	ret = wait_for_completion_timeout(&sink->pssoff_complete,
-						timeout);
-	if (!ret)
-		goto trans_off_err;
+	if (timer_pending(&sink->snk_request_timer))
+		del_timer_sync(&sink->snk_request_timer);
 
-	pr_info("SNKPE: Received PS_RDY\n");
-	ret = snkpe_handle_assert_rp_src_on(sink);
-	if (!ret)
-		return;
+	mod_timer(&sink->snk_request_timer,
+				msecs_to_jiffies(TYPEC_SINK_REQUEST_TIMER));
 
-trans_off_err:
-	/* Move to PE_SNK_Hard_Reset state */
-	snkpe_update_state(sink, PE_SNK_HARD_RESET);
-	return;
+	sink->request_timer_expired = false;
+
+	wait_event(sink->wq_req, sink->request_timer_expired);
+
+	if ((sink->last_pkt != PE_EVT_RCVD_HARD_RESET) ||
+		(sink->last_pkt != PE_EVT_RCVD_SOFT_RESET)) {
+		snkpe_update_state(sink, PE_SNK_SELECT_CAPABILITY);
+		sink->resend_cap = true;
+		schedule_work(&sink->timer_work);
+	} else
+		sink->request_timer_expired = false;
+}
+
+static void sink_request_timer(unsigned long data)
+{
+	struct sink_port_pe *sink = (struct sink_port_pe *) data;
+
+	sink->request_timer_expired = true;
+	wake_up(&sink->wq_req);
 }
 
-static void snkpe_timer_worker(struct work_struct *work)
+static void sinkpe_no_response_timer(unsigned long data)
+{
+	struct sink_port_pe *sink_pe = (struct sink_port_pe *) data;
+
+	sink_pe->no_response_timer_expired  = true;
+
+	schedule_work(&sink_pe->timer_work);
+}
+
+static void sinkpe_handle_error_recovery(struct sink_port_pe *sink)
+{
+	snkpe_update_state(sink, ERROR_RECOVERY);
+	policy_send_packet(&sink->p, NULL, 0, PD_CMD_PROTOCOL_RESET,
+				PE_EVT_SEND_PROTOCOL_RESET);
+	sink->no_response_timer_expired = false;
+	pr_err("SNKPE: No Response timer expired, going to error recovery\n");
+}
+
+/* This is the main task worker for sink pe */
+static void snkpe_task_worker(struct work_struct *work)
 {
 	struct sink_port_pe *sink = container_of(work,
 					struct sink_port_pe,
 					timer_work);
 
-	if ((snkpe_is_cur_state(sink, PE_SNK_SELECT_CAPABILITY) &&
-		snkpe_is_prev_evt(sink, PE_EVT_SEND_REQUEST)) ||
-		(snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_SEND_PR_SWAP) &&
-		snkpe_is_prev_evt(sink, PE_EVT_SEND_PR_SWAP)))
-		snkpe_handle_after_request_sent(sink);
-	else if (snkpe_is_cur_state(sink, PE_PRS_SNK_SRC_TRANSITION_TO_OFF))
+	if (sink->hard_reset_count > HARD_RESET_COUNT_N &&
+		sink->no_response_timer_expired) {
+		return sinkpe_handle_error_recovery(sink);
+	}
+
+	pr_err("SNKPE: %s: state = %d\n", __func__, sink->cur_state);
+	switch (sink->cur_state) {
+	case PE_SNK_STARTUP:
+	case PE_SNK_DISCOVERY:
+		sink->last_pkt = 0;
+		if (sink->is_sink_cable_connected)
+			snkpe_handle_startup(sink);
+		break;
+	case PE_SNK_HARD_RESET:
+		if (sink->hard_reset_count <= HARD_RESET_COUNT_N)
+			snkpe_handle_sink_hard_reset(sink);
+		else if (sink->hard_reset_count > HARD_RESET_COUNT_N &&
+			sink->no_response_timer_expired)
+			return sinkpe_handle_error_recovery(sink);
+		break;
+	case PE_SNK_SELECT_CAPABILITY:
+		if (sink->resend_cap)
+			snkpe_handle_select_capability_state(sink,
+							&sink->prev_pkt);
+		sink_handle_select_cap(sink);
+		break;
+	case PE_SNK_TRANSITION_SINK:
+		sink_handle_transition_sink(sink);
+		break;
+	case PE_PRS_SNK_SRC_TRANSITION_TO_OFF:
 		snkpe_handle_pss_transition_off(sink);
+		break;
+	case PE_PRS_SNK_SRC_SEND_PR_SWAP:
+		snkpe_handle_send_swap(sink);
+		break;
+	default:
+		pr_warn("SNKPE: got state %d\n", sink->cur_state);
+		break;
+	}
+}
+
+static void sinkpe_reset_timers(struct sink_port_pe *sink)
+{
+	del_timer_sync(&sink->no_response_timer);
+	del_timer_sync(&sink->snk_request_timer);
+}
+
+static void sink_do_reset(struct sink_port_pe *pe)
+{
+	/* complete the pending timers */
+	if (!completion_done(&pe->wct_complete))
+		complete(&pe->wct_complete);
+	if (!completion_done(&pe->srt_complete))
+		complete(&pe->srt_complete);
+	if (!completion_done(&pe->pstt_complete))
+		complete(&pe->pstt_complete);
+	if (!completion_done(&pe->pssoff_complete))
+		complete(&pe->pssoff_complete); /* PS Source Off timer */
+
+	if (pe->cur_state == PE_SNK_HARD_RESET) {
+		pe->hard_reset_complete = true;
+		wake_up(&pe->wq);
+	}
+
+	if (timer_pending(&pe->snk_request_timer)) {
+		del_timer_sync(&pe->snk_request_timer);
+		pe->request_timer_expired = true;
+		wake_up(&pe->wq_req);
+	}
+
+	if (timer_pending(&pe->no_response_timer))
+		del_timer_sync(&pe->no_response_timer);
+
+	snkpe_update_state(pe, PE_SNK_STARTUP);
+	schedule_work(&pe->timer_work);
 }
 
-static int snkpe_vbus_attached(struct sink_port_pe *sink)
+static void sink_handle_src_hard_reset(struct sink_port_pe *pe)
 {
+
+	sink_do_reset(pe);
+	/* restart the no response timer */
+	mod_timer(&pe->no_response_timer,
+				msecs_to_jiffies(TYPEC_NO_RESPONSE_TIMER));
+	pe->hard_reset_count = 0;
+}
+
+static int sink_port_policy_rcv_cmd(struct policy *p, enum pe_event evt)
+{
+	struct sink_port_pe *sink = container_of(p,
+					struct sink_port_pe, p);
 	int ret = 0;
-	unsigned long timeout =
-		msecs_to_jiffies(TYPEC_SINK_WAIT_CAP_TIMER);
 
-	if (sink->prev_state == PE_SNK_STARTUP &&
-		sink->cur_state == PE_SNK_DISCOVERY) {
-		snkpe_update_state(sink, PE_SNK_WAIT_FOR_CAPABILITIES);
+	switch (evt) {
+	case PE_EVT_RCVD_HARD_RESET:
+		ret = snkpe_do_prot_reset(sink);
+		sink->last_pkt = evt;
+		sink_handle_src_hard_reset(sink);
+		break;
+	case PE_EVT_RCVD_HARD_RESET_COMPLETE:
+		pr_err("SNKPE: RCVD PE_EVT_RCVD_HARD_RESET_COMPLETE\n");
+		sink->hard_reset_complete = true;
+		wake_up(&sink->wq);
+		break;
+	case PE_EVT_RCVD_SOFT_RESET:
+		ret = snkpe_do_prot_reset(sink);
+		sink->last_pkt = evt;
+		sink_do_reset(sink);
+		policy_send_packet(&sink->p, NULL, 0,
+				PD_CTRL_MSG_ACCEPT, PE_EVT_SEND_ACCEPT);
+		snkpe_update_state(sink, PE_SNK_SOFT_RESET);
+		break;
+	default:
+		pr_err("SNKPE: %s evt - %d\n", __func__, evt);
+		ret = -EINVAL;
+		break;
+	}
 
-		/* Initialize and run SinkWaitCapTimer */
-		/* unblock this once source cap rcv by checking the cur_state */
-		ret = wait_for_completion_timeout(&sink->wct_complete, timeout);
-		if (ret == 0) {
-			sink->timeout = SINK_WAIT_CAP_TIMER;
-			ret = snkpe_timeout_transition_check(sink);
-			goto error;
+	return ret;
+}
+
+static int sink_port_policy_rcv_pkt(struct policy *p, struct pd_packet *pkt,
+				enum pe_event evt)
+{
+	struct sink_port_pe *sink = container_of(p,
+					struct sink_port_pe, p);
+
+	pr_debug("SNKPE:%s: received evt=%d\n", __func__, evt);
+	if (evt != PE_EVT_RCVD_GOODCRC)
+		sink->last_pkt = evt;
+
+	switch (evt) {
+	case PE_EVT_RCVD_SRC_CAP:
+		complete(&sink->wct_complete);
+		/* Process ScrcCap if sink pe is waiting for caps */
+		if (sink->cur_state == PE_SNK_WAIT_FOR_CAPABILITIES)
+			sink_handle_src_cap(sink, pkt);
+		break;
+	case PE_EVT_RCVD_GET_SINK_CAP:
+		if (sink->cur_state == PE_SNK_READY)
+			return snkpe_handle_give_snk_cap_state(sink);
+		break;
+	case PE_EVT_RCVD_ACCEPT:
+	case PE_EVT_RCVD_REJECT:
+	case PE_EVT_RCVD_WAIT:
+		if (sink->cur_state == PE_SNK_SELECT_CAPABILITY) {
+			complete(&sink->srt_complete);
+			sink_handle_accept_reject_wait(sink, evt);
+
+		} else if (sink->cur_state == PE_SNK_SEND_SOFT_RESET) {
+			/* Move to start-up */
+			snkpe_update_state(sink, PE_SNK_STARTUP);
+
+		} else if (sink->cur_state == PE_PRS_SNK_SRC_SEND_PR_SWAP) {
+			/* unblock the waiting thread */
+			complete(&sink->srt_complete);
 		}
-		ret = snkpe_handle_evaluate_capability(sink);
+		break;
+	case PE_EVT_RCVD_PS_RDY:
+		/* Unblock the task worker thread waiting for PS_RDY*/
+		if (sink->cur_state == PE_SNK_TRANSITION_SINK)
+			complete(&sink->pstt_complete);
+		else if (sink->cur_state == PE_PRS_SNK_SRC_TRANSITION_TO_OFF)
+			complete(&sink->pssoff_complete);
+		else
+			pr_warn("SNKPE: Got PSRdy in wrong state=%d\n",
+					sink->cur_state);
+		break;
+	case PE_EVT_RCVD_PING:
+		break;
+	case PE_EVT_RCVD_GOTOMIN:
+		snkpe_update_state(sink, PE_SNK_TRANSITION_SINK);
+		schedule_work(&sink->timer_work);
+		break;
+	case PE_EVT_RCVD_GOODCRC:
+		snkpe_received_msg_good_crc(sink);
+		break;
+	case PE_EVT_RCVD_PR_SWAP:
+		/* If not SNK_READY dont send accept or reject*/
+		if (sink->cur_state == PE_SNK_READY)
+			snkpe_handle_pr_swap(sink);
+		else
+			pr_debug("SNKPE:%s: PR_Swap rcvd in worng state=%d\n",
+					__func__, sink->cur_state);
+		break;
+	default:
+		pr_warn("SNKPE: Not intersted in (%d) event\n", evt);
+		return -EINVAL;
 	}
 
-error:
-	reinit_completion(&sink->wct_complete);
-	return ret;
+	return 0;
+}
+
+static int snkpe_start(struct sink_port_pe *sink)
+{
+	enum cable_state sink_cable_state;
+
+	pr_debug("SNKPE: %s\n", __func__);
+
+	/*---------- Start of Sink Port PE --------------*/
+	/* get the sink_cable_state, in case of boot with cable */
+	snkpe_reset_params(sink);
+	sink_cable_state = policy_get_cable_state(&sink->p,
+					CABLE_TYPE_CONSUMER);
+	if (sink_cable_state < 0) {
+		pr_err("SNKPE: Error in getting vbus state!\n");
+		return sink_cable_state;
+	}
+	if (sink_cable_state == CABLE_ATTACHED)
+		sink->is_sink_cable_connected = true;
+	else
+		sink->is_sink_cable_connected = false;
+
+	if (!sink->is_sink_cable_connected) {
+		mutex_lock(&sink->snkpe_state_lock);
+		sink->cur_state = PE_SNK_STARTUP;
+		mutex_unlock(&sink->snkpe_state_lock);
+		return snkpe_do_prot_reset(sink);
+	}
+
+	/* move the state from PE_SNK_STARTUP to PE_SNK_DISCOVERY */
+	snkpe_update_state(sink, PE_SNK_DISCOVERY);
+
+	schedule_work(&sink->timer_work);
+
+	return 0;
+}
+
+static inline int sink_port_policy_start(struct policy *p)
+{
+	struct sink_port_pe *sink = container_of(p,
+					struct sink_port_pe, p);
+
+	pr_debug("SNKPE: %s\n", __func__);
+	mutex_lock(&sink->snkpe_state_lock);
+	p->status = POLICY_STATUS_RUNNING;
+	p->state = POLICY_STATE_ONLINE;
+	sink->cur_state = PE_SNK_STARTUP;
+	mutex_unlock(&sink->snkpe_state_lock);
+	return snkpe_start(sink);
+}
+
+static int sink_port_policy_stop(struct policy *p)
+{
+	struct sink_port_pe *sink = container_of(p,
+					struct sink_port_pe, p);
+
+	pr_debug("SNKPE: %s\n", __func__);
+	/* reset HardResetCounter to zero upon vbus disconnect.
+	 */
+	mutex_lock(&sink->snkpe_state_lock);
+	sink->hard_reset_count = 0;
+	p->status = POLICY_STATUS_UNKNOWN;
+	p->state = POLICY_STATE_OFFLINE;
+	sink->is_sink_cable_connected = false;
+	mutex_unlock(&sink->snkpe_state_lock);
+	policy_set_pd_state(p, false);
+
+	/* clear any pending completions */
+	sink_do_reset(sink);
+	sinkpe_reset_timers(sink);
+	cancel_work_sync(&sink->timer_work);
+	cancel_work_sync(&sink->request_timer);
+	sink->resend_cap = 0;
+	sink->last_pkt = 0;
+	snkpe_reinitialize_completion(sink);
+	snkpe_update_state(sink, PE_SNK_STARTUP);
+	mutex_lock(&sink->snkpe_state_lock);
+	sink->cur_state = PE_SNK_STARTUP;
+	mutex_unlock(&sink->snkpe_state_lock);
+
+	return 0;
 }
 
 struct policy *sink_port_policy_init(struct policy_engine *pe)
 {
 	struct sink_port_pe *snkpe;
 	struct policy *p;
-	int ret;
 
 	snkpe = kzalloc(sizeof(*snkpe), GFP_KERNEL);
 	if (!snkpe)
 		return ERR_PTR(-ENOMEM);
 
-	INIT_WORK(&snkpe->timer_work, snkpe_timer_worker);
-
-	/* Allocate memory for PD packet FIFO */
-	if (kfifo_alloc(&snkpe->pkt_fifo,
-				sizeof(struct pd_packet),
-				GFP_KERNEL)) {
-		pr_err("SNKPE: kfifo alloc failed for policy\n");
-		ret = -ENOMEM;
-		goto error;
-	}
+	INIT_WORK(&snkpe->timer_work, snkpe_task_worker);
+	INIT_WORK(&snkpe->request_timer, sink_request_timer_work);
+	init_waitqueue_head(&snkpe->wq);
+	init_waitqueue_head(&snkpe->wq_req);
 
 	p = &snkpe->p;
 	p->type = POLICY_TYPE_SINK;
@@ -1064,22 +1007,20 @@ struct policy *sink_port_policy_init(struct policy_engine *pe)
 	p->start = sink_port_policy_start;
 	p->stop = sink_port_policy_stop;
 	p->exit = sink_port_policy_exit;
+	setup_timer(&snkpe->no_response_timer, sinkpe_no_response_timer,
+					(unsigned long) snkpe);
+	setup_timer(&snkpe->snk_request_timer, sink_request_timer,
+					(unsigned long) snkpe);
 
 	init_completion(&snkpe->wct_complete);
 	init_completion(&snkpe->srt_complete);
-	init_completion(&snkpe->nrt_complete);
 	init_completion(&snkpe->pstt_complete);
 	init_completion(&snkpe->sat_complete);
-	init_completion(&snkpe->srqt_complete);
 	init_completion(&snkpe->pssoff_complete);
-	init_completion(&snkpe->pktwt_complete);
 	mutex_init(&snkpe->snkpe_state_lock);
 
 	return p;
 
-error:
-	kfree(snkpe);
-	return ERR_PTR(ret);
 }
 EXPORT_SYMBOL_GPL(sink_port_policy_init);
 
@@ -1089,7 +1030,6 @@ static void sink_port_policy_exit(struct policy *p)
 
 	if (p) {
 		snkpe = container_of(p, struct sink_port_pe, p);
-		kfifo_free(&snkpe->pkt_fifo);
 		kfree(snkpe);
 	}
 }
diff --git a/drivers/usb/typec/pd/sink_port_pe.h b/drivers/usb/typec/pd/sink_port_pe.h
index e24f96a31197..2e1beac87293 100644
--- a/drivers/usb/typec/pd/sink_port_pe.h
+++ b/drivers/usb/typec/pd/sink_port_pe.h
@@ -80,9 +80,9 @@ enum snkpe_timeout {
 
 struct req_cap {
 	u8 obj_pos;
-	bool cap_mismatch;
 	u32 ma;
 	u32 mv;
+	bool cap_mismatch;
 };
 
 struct sink_port_pe {
@@ -90,23 +90,26 @@ struct sink_port_pe {
 	struct pd_packet prev_pkt;
 	struct completion wct_complete; /* wait cap timer */
 	struct completion srt_complete; /* sender response timer */
-	struct completion nrt_complete; /* no response timer */
 	struct completion pstt_complete; /* PS Transition timer */
 	struct completion sat_complete; /* Sink Activity timer */
-	struct completion srqt_complete; /* Sink Request timer */
 	struct completion pssoff_complete; /* PS Source Off timer */
-	struct completion pktwt_complete; /* fifo write complete */
-	struct kfifo pkt_fifo;
+	struct mutex snkpe_state_lock;
+	struct timer_list no_response_timer;
+	struct timer_list snk_request_timer;
+	struct work_struct timer_work; /* sink pe worker thread */
+	struct work_struct request_timer; /* snk request timer on ready state */
 	struct req_cap rcap;
-	int ilim;
-	enum pe_event pevt;
+	wait_queue_head_t wq;
+	wait_queue_head_t wq_req;
+	enum pe_event last_pkt;
 	enum pe_states cur_state;
-	enum pe_states prev_state;
-	struct mutex snkpe_state_lock;
 	enum snkpe_timeout timeout;
-	struct work_struct timer_work;
-	bool is_sink_cable_connected;
 	u8 hard_reset_count;
+	unsigned resend_cap:1;
+	unsigned hard_reset_complete:1;
+	unsigned is_sink_cable_connected:1;
+	unsigned request_timer_expired:1;
+	unsigned no_response_timer_expired:1;
 
 	/* Port partner caps */
 	unsigned pp_is_dual_prole:1;
@@ -114,34 +117,4 @@ struct sink_port_pe {
 	unsigned pp_is_ext_pwrd:1;
 };
 
-static int snkpe_start(struct sink_port_pe *sink);
-static int snkpe_handle_snk_ready_state(struct sink_port_pe *sink,
-						enum pe_event evt);
-static int snkpe_handle_select_capability_state(struct sink_port_pe *sink,
-							struct pd_packet *pkt);
-static int snkpe_handle_transition_sink_state(struct sink_port_pe *sink);
-static int snkpe_handle_give_snk_cap_state(struct sink_port_pe *sink);
-static int snkpe_handle_evaluate_capability(struct sink_port_pe *sink);
-static int snkpe_handle_transition_to_default(struct sink_port_pe *sink);
-static int snkpe_vbus_attached(struct sink_port_pe *sink);
-static void sink_port_policy_exit(struct policy *p);
-
-static inline bool snkpe_is_cur_state(struct sink_port_pe *sink,
-					enum pe_states state)
-{
-	return sink->cur_state == state;
-}
-
-static inline bool snkpe_is_prev_state(struct sink_port_pe *sink,
-					enum pe_states state)
-{
-	return sink->prev_state == state;
-}
-
-static inline bool snkpe_is_prev_evt(struct sink_port_pe *sink,
-					enum pe_event evt)
-{
-	return sink->pevt == evt;
-}
-
 #endif /* __SINK_PORT_PE__H__ */
-- 
1.9.1

