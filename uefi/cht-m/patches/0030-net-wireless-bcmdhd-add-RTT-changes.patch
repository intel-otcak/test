From c953d3be5adba478eb0947ebe6a01ee8b0ec78ea Mon Sep 17 00:00:00 2001
From: Ecco park <eccopark@broadcom.com>
Date: Mon, 21 Jul 2014 18:17:45 -0700
Subject: [PATCH 30/77] net: wireless: bcmdhd:  add RTT changes

Change-Id: I40986ab24710efa04ab9d224e7dfb41f7446ec8a
Signed-off-by: Ecco park <eccopark@broadcom.com>
---
 drivers/net/wireless/bcmdhd/Makefile           |   3 +-
 drivers/net/wireless/bcmdhd/dhd.h              |   3 +
 drivers/net/wireless/bcmdhd/dhd_common.c       |   8 +
 drivers/net/wireless/bcmdhd/dhd_dbg.h          |   4 +-
 drivers/net/wireless/bcmdhd/dhd_linux.c        |  74 ++-
 drivers/net/wireless/bcmdhd/dhd_rtt.c          | 677 +++++++++++++++++++++++++
 drivers/net/wireless/bcmdhd/dhd_rtt.h          | 241 +++++++++
 drivers/net/wireless/bcmdhd/include/dhdioctl.h |   1 +
 drivers/net/wireless/bcmdhd/wl_cfgvendor.c     | 260 +++++++++-
 drivers/net/wireless/bcmdhd/wl_cfgvendor.h     |  55 +-
 10 files changed, 1296 insertions(+), 30 deletions(-)
 create mode 100644 drivers/net/wireless/bcmdhd/dhd_rtt.c
 create mode 100644 drivers/net/wireless/bcmdhd/dhd_rtt.h

diff --git a/drivers/net/wireless/bcmdhd/Makefile b/drivers/net/wireless/bcmdhd/Makefile
index 70e418f28a99..e04d076c13cd 100644
--- a/drivers/net/wireless/bcmdhd/Makefile
+++ b/drivers/net/wireless/bcmdhd/Makefile
@@ -53,6 +53,7 @@ DHDCFLAGS += -DMIRACAST_AMPDU_SIZE=8
 
 #Gscan
 DHDCFLAGS += -DGSCAN_SUPPORT
+DHDCFLAGS += -DRTT_SUPPORT
 DHDCFLAGS += -DWL_VENDOR_EXT_SUPPORT
 
 # Early suspend
@@ -185,7 +186,7 @@ DHDOFILES := dhd_pno.o dhd_common.o dhd_ip.o dhd_custom_gpio.o \
 	dhd_linux.o dhd_linux_sched.o dhd_cfg80211.o dhd_linux_wq.o aiutils.o bcmevent.o \
 	bcmutils.o bcmwifi_channels.o hndpmu.o linux_osl.o sbutils.o siutils.o \
 	wl_android.o wl_cfg80211.o wl_cfgp2p.o wl_cfg_btcoex.o wldev_common.o wl_linux_mon.o  \
-	dhd_linux_platdev.o dhd_pno.o dhd_linux_wq.o wl_cfg_btcoex.o \
+	dhd_linux_platdev.o dhd_pno.o dhd_rtt.o dhd_linux_wq.o wl_cfg_btcoex.o \
 	hnd_pktq.o hnd_pktpool.o wl_cfgvendor.o
 
 ifneq ($(CONFIG_BCMDHD_SDIO),)
diff --git a/drivers/net/wireless/bcmdhd/dhd.h b/drivers/net/wireless/bcmdhd/dhd.h
index 64789ce9c751..65a5d5992505 100644
--- a/drivers/net/wireless/bcmdhd/dhd.h
+++ b/drivers/net/wireless/bcmdhd/dhd.h
@@ -337,6 +337,9 @@ typedef struct dhd_pub {
 #ifdef PNO_SUPPORT
 	void *pno_state;
 #endif
+#ifdef RTT_SUPPORT
+	void *rtt_state;
+#endif
 #ifdef ROAM_AP_ENV_DETECTION
 	bool	roam_env_detection;
 #endif
diff --git a/drivers/net/wireless/bcmdhd/dhd_common.c b/drivers/net/wireless/bcmdhd/dhd_common.c
index e034980cc8ba..b52a0b139776 100644
--- a/drivers/net/wireless/bcmdhd/dhd_common.c
+++ b/drivers/net/wireless/bcmdhd/dhd_common.c
@@ -55,6 +55,9 @@
 #ifdef PNO_SUPPORT
 #include <dhd_pno.h>
 #endif
+#ifdef RTT_SUPPORT
+#include <dhd_rtt.h>
+#endif
 
 #define htod32(i) (i)
 #define htod16(i) (i)
@@ -1736,6 +1739,11 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 		dhd_pno_event_handler(dhd_pub, event, (void *)event_data);
 		break;
 #endif
+#if defined(RTT_SUPPORT)
+	case WLC_E_PROXD:
+		dhd_rtt_event_handler(dhd_pub, event, (void *)event_data);
+		break;
+#endif /* RTT_SUPPORT */
 		/* These are what external supplicant/authenticator wants */
 	case WLC_E_ASSOC_IND:
 	case WLC_E_AUTH_IND:
diff --git a/drivers/net/wireless/bcmdhd/dhd_dbg.h b/drivers/net/wireless/bcmdhd/dhd_dbg.h
index b9f1c6f529e3..6ab5f607ffb8 100644
--- a/drivers/net/wireless/bcmdhd/dhd_dbg.h
+++ b/drivers/net/wireless/bcmdhd/dhd_dbg.h
@@ -48,6 +48,7 @@
 #define DHD_ARPOE(args)		do {if (dhd_msg_level & DHD_ARPOE_VAL) printf args;} while (0)
 #define DHD_REORDER(args)	do {if (dhd_msg_level & DHD_REORDER_VAL) printf args;} while (0)
 #define DHD_PNO(args)		do {if (dhd_msg_level & DHD_PNO_VAL) printf args;} while (0)
+#define DHD_RTT(args)		do {if (dhd_msg_level & DHD_RTT_VAL) printf args;} while (0)
 
 #define DHD_TRACE_HW4	DHD_TRACE
 
@@ -68,6 +69,7 @@
 #define DHD_REORDER_ON()	(dhd_msg_level & DHD_REORDER_VAL)
 #define DHD_NOCHECKDIED_ON()	(dhd_msg_level & DHD_NOCHECKDIED_VAL)
 #define DHD_PNO_ON()		(dhd_msg_level & DHD_PNO_VAL)
+#define DHD_RTT_ON()		(dhd_msg_level & DHD_RTT_VAL)
 
 #else /* defined(BCMDBG) || defined(DHD_DEBUG) */
 
@@ -107,7 +109,7 @@
 #define DHD_REORDER_ON()	0
 #define DHD_NOCHECKDIED_ON()	0
 #define DHD_PNO_ON()		0
-
+#define DHD_RTT_ON()		0
 #endif 
 
 #define DHD_LOG(args)
diff --git a/drivers/net/wireless/bcmdhd/dhd_linux.c b/drivers/net/wireless/bcmdhd/dhd_linux.c
index 972bf7d21a6b..6491ff71d343 100644
--- a/drivers/net/wireless/bcmdhd/dhd_linux.c
+++ b/drivers/net/wireless/bcmdhd/dhd_linux.c
@@ -92,6 +92,9 @@
 #ifdef PNO_SUPPORT
 #include <dhd_pno.h>
 #endif
+#ifdef RTT_SUPPORT
+#include <dhd_rtt.h>
+#endif
 
 #ifdef CONFIG_COMPAT
 #include <linux/compat.h>
@@ -5554,6 +5557,9 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #ifdef WLTDLS
 	setbit(eventmask, WLC_E_TDLS_PEER_EVENT);
 #endif /* WLTDLS */
+#ifdef RTT_SUPPORT
+	setbit(eventmask, WLC_E_PROXD);
+#endif /* RTT_SUPPORT */
 #ifdef WL_CFG80211
 	setbit(eventmask, WLC_E_ESCAN_RESULT);
 	if (dhd->op_mode & DHD_FLAG_P2P_MODE) {
@@ -5732,6 +5738,12 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 		dhd_pno_init(dhd);
 	}
 #endif
+#ifdef RTT_SUPPORT
+	if (!dhd->rtt_state) {
+		dhd_rtt_init(dhd);
+	}
+#endif
+
 #ifdef WL11U
 	dhd_interworking_enable(dhd);
 #endif /* WL11U */
@@ -6370,6 +6382,10 @@ void dhd_detach(dhd_pub_t *dhdp)
 	if (dhdp->pno_state)
 		dhd_pno_deinit(dhdp);
 #endif
+#ifdef RTT_SUPPORT
+	if (dhdp->rtt_state)
+		dhd_rtt_deinit(dhdp);
+#endif
 #if defined(CONFIG_PM_SLEEP)
 	if (dhd_pm_notifier_registered) {
 		unregister_pm_notifier(&dhd_pm_notifier);
@@ -6989,16 +7005,22 @@ dhd_net_bus_devreset(struct net_device *dev, uint8 flag)
 			DHD_TRACE(("%s: wl down failed\n", __FUNCTION__));
 		}
 #ifdef PROP_TXSTATUS
-		if (dhd->pub.wlfc_enabled)
+		if (dhd->pub.wlfc_enabled) {
 			dhd_wlfc_deinit(&dhd->pub);
+		}
 #endif /* PROP_TXSTATUS */
 #ifdef PNO_SUPPORT
-	if (dhd->pub.pno_state)
-		dhd_pno_deinit(&dhd->pub);
-#endif
+		if (dhd->pub.pno_state) {
+			dhd_pno_deinit(&dhd->pub);
+		}
+#endif /* PNO_SUPPORT */
+#ifdef RTT_SUPPORT
+		if (dhd->pub.rtt_state) {
+			dhd_rtt_deinit(&dhd->pub);
+		}
+#endif /* RTT_SUPPORT */
 	}
-
-#if defined (BCMSDIO)
+#ifdef BCMSDIO
 	if (!flag) {
 		dhd_update_fw_nv_path(dhd);
 		/* update firmware and nvram path to sdio bus */
@@ -7515,6 +7537,46 @@ int dhd_dev_retrieve_batch_scan(struct net_device *dev)
 }
 
 #endif /* GSCAN_SUPPORT */
+#ifdef RTT_SUPPORT
+/* Linux wrapper to call common dhd_pno_set_cfg_gscan */
+int
+dhd_dev_rtt_set_cfg(struct net_device *dev, void *buf)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return (dhd_rtt_set_cfg(&dhd->pub, buf));
+}
+int
+dhd_dev_rtt_cancel_cfg(struct net_device *dev, struct ether_addr *mac_list, int mac_cnt)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return (dhd_rtt_stop(&dhd->pub, mac_list, mac_cnt));
+}
+
+int
+dhd_dev_rtt_register_noti_callback(struct net_device *dev, void *ctx, dhd_rtt_compl_noti_fn noti_fn)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return (dhd_rtt_register_noti_callback(&dhd->pub, ctx, noti_fn));
+}
+int
+dhd_dev_rtt_unregister_noti_callback(struct net_device *dev, dhd_rtt_compl_noti_fn noti_fn)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return (dhd_rtt_unregister_noti_callback(&dhd->pub, noti_fn));
+}
+
+int
+dhd_dev_rtt_capability(struct net_device *dev, rtt_capabilities_t *capa)
+{
+	dhd_info_t *dhd = *(dhd_info_t **)netdev_priv(dev);
+
+	return (dhd_rtt_capability(&dhd->pub, capa));
+}
+#endif /* RTT_SUPPORT */
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27))
 static void dhd_hang_process(void *dhd_info, void *event_info, u8 event)
diff --git a/drivers/net/wireless/bcmdhd/dhd_rtt.c b/drivers/net/wireless/bcmdhd/dhd_rtt.c
new file mode 100644
index 000000000000..30e87f3cf0e8
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/dhd_rtt.c
@@ -0,0 +1,677 @@
+/*
+ * Header file of Broadcom Dongle Host Driver (DHD)
+ * Copyright (C) 1999-2014, Broadcom Corporation
+ *
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ *
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ *
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * $Id: dhd_rtt.c 423669 2014-07-01 13:01:55Z $
+ */
+#include <typedefs.h>
+#include <osl.h>
+
+#include <epivers.h>
+#include <bcmutils.h>
+
+#include <bcmendian.h>
+#include <linuxver.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/sort.h>
+#include <dngl_stats.h>
+#include <wlioctl.h>
+
+#include <proto/bcmevent.h>
+#include <dhd.h>
+#include <dhd_rtt.h>
+#include <dhd_dbg.h>
+#define GET_RTTSTATE(dhd) ((rtt_status_info_t *)dhd->rtt_state)
+static DEFINE_SPINLOCK(noti_list_lock);
+#define NULL_CHECK(p, s, err)  \
+			do { \
+				if (!(p)) { \
+					printf("NULL POINTER (%s) : %s\n", __FUNCTION__, (s)); \
+					err = BCME_ERROR; \
+					return err; \
+				} \
+			} while (0)
+
+#define RTT_TWO_SIDED(capability) \
+			do { \
+				if((capability & RTT_CAP_ONE_WAY) == (uint8) (RTT_CAP_ONE_WAY)) \
+					return FALSE; \
+				else \
+					return TRUE; \
+			} while (0)
+#define TIMESPEC_TO_US(ts)  (((uint64)(ts).tv_sec * USEC_PER_SEC) + \
+							(ts).tv_nsec / NSEC_PER_USEC)
+struct rtt_noti_callback {
+	struct list_head list;
+	void *ctx;
+	dhd_rtt_compl_noti_fn noti_fn;
+};
+
+typedef struct rtt_status_info {
+	dhd_pub_t *dhd;
+	int8 status;   /* current status for the current entry */
+	int8 cur_idx; /* current entry to do RTT */
+	int32 capability; /* rtt capability */
+	struct mutex rtt_mutex;
+	rtt_config_params_t rtt_config;
+	struct work_struct work;
+	struct list_head noti_fn_list;
+	struct list_head rtt_results_cache; /* store results for RTT */
+} rtt_status_info_t;
+static int dhd_rtt_start(dhd_pub_t *dhd);
+chanspec_t
+dhd_rtt_convert_to_chspec(wifi_channel_info_t channel)
+{
+	int bw;
+	switch (channel.width) {
+	case WIFI_CHAN_WIDTH_20:
+		bw = WL_CHANSPEC_BW_20;
+		break;
+	case WIFI_CHAN_WIDTH_40:
+		bw = WL_CHANSPEC_BW_40;
+		break;
+	case WIFI_CHAN_WIDTH_80:
+		bw = WL_CHANSPEC_BW_80;
+		break;
+	case WIFI_CHAN_WIDTH_160:
+		bw = WL_CHANSPEC_BW_160;
+		break;
+	default:
+		DHD_ERROR(("doesn't support this bandwith : %d", channel.width));
+		bw = -1;
+		break;
+	}
+	return wf_channel2chspec(wf_mhz2channel(channel.center_freq, 0), bw);
+}
+int
+dhd_rtt_set_cfg(dhd_pub_t *dhd, rtt_config_params_t *params)
+{
+	int err = BCME_OK;
+	int idx;
+	rtt_status_info_t *rtt_status;
+	NULL_CHECK(params, "params is NULL", err);
+
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	if (rtt_status->capability == RTT_CAP_NONE) {
+		DHD_ERROR(("doesn't support RTT \n"));
+		return BCME_ERROR;
+	}
+	if (rtt_status->status == RTT_STARTED) {
+		DHD_ERROR(("rtt is already started\n"));
+		return BCME_BUSY;
+	}
+	DHD_RTT(("%s enter\n", __FUNCTION__));
+	bcopy(params, &rtt_status->rtt_config, sizeof(rtt_config_params_t));
+	rtt_status->status = RTT_STARTED;
+	/* start to measure RTT from 1th device */
+	/* find next target to trigger RTT */
+	for (idx = rtt_status->cur_idx; idx < rtt_status->rtt_config.rtt_target_cnt; idx++) {
+		/* skip the disabled device */
+		if (rtt_status->rtt_config.target_info[idx].disable)
+			continue;
+		else {
+			/*set the idx to cur_idx */
+			rtt_status->cur_idx = idx;
+			break;
+		}
+	}
+	if (idx < rtt_status->rtt_config.rtt_target_cnt) {
+		DHD_RTT(("rtt_status->cur_idx : %d\n", rtt_status->cur_idx));
+		schedule_work(&rtt_status->work);
+	}
+	return err;
+}
+int
+dhd_rtt_stop(dhd_pub_t *dhd, struct ether_addr *mac_list, int mac_cnt)
+{
+	int err = BCME_OK;
+	int i = 0, j = 0;
+	rtt_status_info_t *rtt_status;
+
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	if (rtt_status->status == RTT_STOPPED) {
+		DHD_ERROR(("rtt is not started\n"));
+		return BCME_OK;
+	}
+	DHD_RTT(("%s enter\n", __FUNCTION__));
+	mutex_lock(&rtt_status->rtt_mutex);
+	for (i = 0; i < mac_cnt; i++) {
+		for ( j = 0; j < rtt_status->rtt_config.rtt_target_cnt; j++) {
+				if (!bcmp(&mac_list[i],&rtt_status->rtt_config.target_info[j].addr,
+					ETHER_ADDR_LEN)) {
+					rtt_status->rtt_config.target_info[j].disable = TRUE;
+				}
+		}
+	}
+	mutex_unlock(&rtt_status->rtt_mutex);
+	return err;
+}
+
+static int
+dhd_rtt_start(dhd_pub_t *dhd) {
+	int err = BCME_OK;
+	int mpc = 0;
+	int nss, mcs, bw;
+	uint32 rspec = 0;
+	int8 eabuf[ETHER_ADDR_STR_LEN];
+	int8 chanbuf[CHANSPEC_STR_LEN];
+	bool set_mpc = FALSE;
+	wl_proxd_iovar_t proxd_iovar;
+	wl_proxd_params_iovar_t proxd_params;
+	wl_proxd_params_iovar_t proxd_tune;
+	wl_proxd_params_tof_method_t *tof_params = &proxd_params.u.tof_params;
+	rtt_status_info_t *rtt_status;
+	rtt_target_info_t *rtt_target;
+	NULL_CHECK(dhd, "dhd is NULL", err);
+
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	/* turn off mpc in case of non-associted */
+	if (!dhd_is_associated(dhd, NULL, NULL)) {
+		err = dhd_iovar(dhd, 0, "mpc", (char *)&mpc, sizeof(mpc), 1);
+		if (err < 0) {
+				DHD_ERROR(("%s : failed to set proxd_tune\n", __FUNCTION__));
+				goto exit;
+		}
+		set_mpc = TRUE;
+	}
+
+	if (rtt_status->cur_idx >= rtt_status->rtt_config.rtt_target_cnt) {
+		err = BCME_RANGE;
+		goto exit;
+	}
+	DHD_RTT(("%s enter\n", __FUNCTION__));
+	bzero(&proxd_tune, sizeof(proxd_tune));
+	bzero(&proxd_params, sizeof(proxd_params));
+	mutex_lock(&rtt_status->rtt_mutex);
+	/* Get a target information */
+	rtt_target = &rtt_status->rtt_config.target_info[rtt_status->cur_idx];
+	mutex_unlock(&rtt_status->rtt_mutex);
+	/* set role */
+	proxd_iovar.method = PROXD_TOF_METHOD;
+	proxd_iovar.mode = WL_PROXD_MODE_INITIATOR;
+
+	/* make sure that proxd is stop */
+	//dhd_iovar(dhd, 0, "proxd_stop", (char *)NULL, 0, 1);
+
+	err = dhd_iovar(dhd, 0, "proxd", (char *)&proxd_iovar, sizeof(proxd_iovar), 1);
+	if (err < 0 && err != BCME_BUSY) {
+		DHD_ERROR(("%s : failed to set proxd %d\n", __FUNCTION__, err));
+		goto exit;
+	}
+	/* mac address */
+	bcopy(&rtt_target->addr, &tof_params->tgt_mac, ETHER_ADDR_LEN);
+	/* frame count */
+
+	if (rtt_target->ftm_cnt)
+		tof_params->ftm_cnt = htol16(rtt_target->ftm_cnt);
+	else
+		tof_params->ftm_cnt = htol16(DEFAULT_FTM_CNT);
+
+	/* retry count */
+	if (rtt_target->retry_cnt)
+		tof_params->retry_cnt = htol16(rtt_target->retry_cnt);
+	else
+		tof_params->retry_cnt = htol16(DEFAULT_RETRY_CNT);
+
+	/* chanspec */
+	tof_params->chanspec = htol16(rtt_target->chanspec);
+	/* set parameter */
+	DHD_RTT(("Target addr(Idx %d) %s, Channel : %s for RTT (ftm_cnt %d, rety_cnt : %d)\n",
+			rtt_status->cur_idx,
+			bcm_ether_ntoa((const struct ether_addr *)&rtt_target->addr, eabuf),
+			wf_chspec_ntoa(rtt_target->chanspec, chanbuf), rtt_target->ftm_cnt,
+			rtt_target->retry_cnt));
+
+	if (rtt_target->type == RTT_ONE_WAY) {
+		proxd_tune.u.tof_tune.flags = htol32(WL_PROXD_FLAG_ONEWAY);
+		/* report RTT results for initiator */
+		proxd_tune.u.tof_tune.flags |= htol32(WL_PROXD_FLAG_INITIATOR_RPTRTT);
+		proxd_tune.u.tof_tune.vhtack = 0;
+		tof_params->tx_rate = htol16(WL_RATE_6M);
+		tof_params->vht_rate = htol16((WL_RATE_6M >> 16));
+	} else { /* RTT TWO WAY */
+		/* initiator will send the rtt result to the target  */
+		proxd_tune.u.tof_tune.flags = htol32(WL_PROXD_FLAG_INITIATOR_REPORT);
+		tof_params->timeout = 10; /* 10ms for timeout */
+		rspec = WL_RSPEC_ENCODE_VHT;	/* 11ac VHT */
+		/* TODO : need to find a way to set nss and mcs */
+		nss = 1; /* default Nss = 1 */
+		mcs = 0; /* default MCS 0 */
+		rspec |= (nss << WL_RSPEC_VHT_NSS_SHIFT) | mcs;
+		bw = 0;
+		switch (CHSPEC_BW(rtt_target->chanspec)) {
+		case WL_CHANSPEC_BW_20:
+			bw = WL_RSPEC_BW_20MHZ;
+			break;
+		case WL_CHANSPEC_BW_40:
+			bw = WL_RSPEC_BW_40MHZ;
+			break;
+		case WL_CHANSPEC_BW_80:
+			bw = WL_RSPEC_BW_80MHZ;
+			break;
+		case WL_CHANSPEC_BW_160:
+			bw = WL_RSPEC_BW_160MHZ;
+			break;
+		}
+		rspec |= bw;
+		tof_params->tx_rate = htol16(rspec);
+		tof_params->vht_rate = htol16(rspec >> 16);
+	}
+
+	/* Set Method to TOF */
+	proxd_tune.method = PROXD_TOF_METHOD;
+	err = dhd_iovar(dhd, 0, "proxd_tune", (char *)&proxd_tune, sizeof(proxd_tune), 1);
+	if (err < 0) {
+		DHD_ERROR(("%s : failed to set proxd_tune %d\n", __FUNCTION__, err));
+		goto exit;
+	}
+
+	/* Set Method to TOF */
+	proxd_params.method = PROXD_TOF_METHOD;
+	err = dhd_iovar(dhd, 0, "proxd_params", (char *)&proxd_params, sizeof(proxd_params), 1);
+	if (err < 0) {
+		DHD_ERROR(("%s : failed to set proxd_params %d\n", __FUNCTION__, err));
+		goto exit;
+	}
+	err = dhd_iovar(dhd, 0, "proxd_find", (char *)NULL, 0, 1);
+	if (err < 0) {
+		DHD_ERROR(("%s : failed to set proxd_find %d\n", __FUNCTION__, err));
+		goto exit;
+	}
+exit:
+	if (err < 0) {
+		rtt_status->status = RTT_STOPPED;
+		if (set_mpc) {
+			/* enable mpc again in case of error */
+			  mpc = 1;
+			  err = dhd_iovar(dhd, 0, "mpc", (char *)&mpc, sizeof(mpc), 1);
+		}
+	}
+	return err;
+}
+int
+dhd_rtt_register_noti_callback(dhd_pub_t *dhd, void *ctx, dhd_rtt_compl_noti_fn noti_fn)
+{
+	int err = BCME_OK;
+	struct rtt_noti_callback *cb = NULL, *iter;
+	rtt_status_info_t *rtt_status;
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	NULL_CHECK(noti_fn, "noti_fn is NULL", err);
+
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	spin_lock_bh(&noti_list_lock);
+	list_for_each_entry(iter, &rtt_status->noti_fn_list, list)
+		if (iter->noti_fn == noti_fn) {
+			goto exit;
+		}
+	cb = kmalloc(sizeof(struct rtt_noti_callback), GFP_ATOMIC);
+	if (!cb) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	cb->noti_fn = noti_fn;
+	cb->ctx = ctx;
+	list_add(&cb->list, &rtt_status->noti_fn_list);
+exit:
+	spin_unlock_bh(&noti_list_lock);
+	return err;
+}
+
+int
+dhd_rtt_unregister_noti_callback(dhd_pub_t *dhd, dhd_rtt_compl_noti_fn noti_fn)
+{
+	int err = BCME_OK;
+	struct rtt_noti_callback *cb = NULL, *iter;
+	rtt_status_info_t *rtt_status;
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	NULL_CHECK(noti_fn, "noti_fn is NULL", err);
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	spin_lock_bh(&noti_list_lock);
+	list_for_each_entry(iter, &rtt_status->noti_fn_list, list)
+		if (iter->noti_fn == noti_fn) {
+			cb = iter;
+			list_del(&cb->list);
+			break;
+		}
+	spin_unlock_bh(&noti_list_lock);
+	if (cb) {
+		kfree(cb);
+	}
+	return err;
+}
+static int
+dhd_rtt_convert_to_host(rtt_result_t *rtt_results, const wl_proxd_event_data_t* evp)
+{
+	int err = BCME_OK;
+	int i;
+	char eabuf[ETHER_ADDR_STR_LEN];
+	char diststr[40];
+	struct timespec ts;
+	NULL_CHECK(rtt_results, "rtt_results is NULL", err);
+	NULL_CHECK(evp, "evp is NULL", err);
+	DHD_RTT(("%s enter\n", __FUNCTION__));
+	rtt_results->distance = ntoh32(evp->distance);
+	rtt_results->sdrtt = ntoh32(evp->sdrtt);
+	rtt_results->ftm_cnt = ntoh16(evp->ftm_cnt);
+	rtt_results->avg_rssi = ntoh16(evp->avg_rssi);
+	rtt_results->validfrmcnt = ntoh16(evp->validfrmcnt);
+	rtt_results->meanrtt = ntoh32(evp->meanrtt);
+	rtt_results->modertt = ntoh32(evp->modertt);
+	rtt_results->medianrtt = ntoh32(evp->medianrtt);
+	rtt_results->err_code = evp->err_code;
+	rtt_results->tx_rate.preamble = (evp->OFDM_frame_type == TOF_FRAME_RATE_VHT)? 3 : 0;
+	rtt_results->tx_rate.nss = 0; /* 1 x 1 */
+	rtt_results->tx_rate.bw = (evp->bandwidth == TOF_BW_80MHZ)? 2 : (evp->bandwidth == TOF_BW_40MHZ)? 1 : 0;
+	rtt_results->TOF_type = evp->TOF_type;
+	if (evp->TOF_type == TOF_TYPE_ONE_WAY) {
+		/* convert to 100kbps unit */
+		rtt_results->tx_rate.bitrate = WL_RATE_6M * 5;
+		rtt_results->tx_rate.rateMcsIdx = WL_RATE_6M;
+	} else {
+		/* TODO : check tx rate for two way */
+		rtt_results->tx_rate.bitrate = WL_RATE_6M * 5;
+		rtt_results->tx_rate.rateMcsIdx = 0; /* MCS 0 */
+	}
+	memset(diststr, 0, sizeof(diststr));
+	if (rtt_results->distance == 0xffffffff || rtt_results->distance == 0)
+		sprintf(diststr, "distance=-1m\n");
+	else
+		sprintf(diststr, "distance=%d.%d m\n", rtt_results->distance>>4, ((rtt_results->distance&0xf)*125)>>1);
+
+
+	if (ntoh32(evp->mode) == WL_PROXD_MODE_INITIATOR) {
+		DHD_RTT(("Target:(%s) %s;\n", bcm_ether_ntoa((&evp->peer_mac), eabuf), diststr));
+		DHD_RTT(("RTT : mean %d mode %d median %d\n", rtt_results->meanrtt,
+			rtt_results->modertt, rtt_results->medianrtt));
+	}
+	else {
+		DHD_RTT(("Initiator:(%s) %s; ", bcm_ether_ntoa((&evp->peer_mac), eabuf), diststr));
+	}
+	if (rtt_results->sdrtt > 0)
+		DHD_RTT(("sigma:%d.%d\n", rtt_results->sdrtt/10, rtt_results->sdrtt % 10));
+	else
+		DHD_RTT(("sigma:0\n"));
+
+	DHD_RTT(("rssi:%d validfrmcnt %d\n", rtt_results->avg_rssi, rtt_results->validfrmcnt));
+
+	switch (evp->err_code) {
+	case TOF_REASON_OK:
+		rtt_results->err_code = RTT_REASON_SUCCESS;
+		break;
+	case TOF_REASON_TIMEOUT:
+		rtt_results->err_code = RTT_REASON_TIMEOUT;
+		break;
+	case TOF_REASON_NOACK:
+		rtt_results->err_code = RTT_REASON_NO_RSP;
+		break;
+	case TOF_REASON_ABORT:
+		rtt_results->err_code = RTT_REASON_ABORT;
+		break;
+	default:
+		rtt_results->err_code = RTT_REASON_FAILURE;
+		break;
+	}
+	rtt_results->peer_mac = evp->peer_mac;
+	/* get the time elapsed from boot time */
+	get_monotonic_boottime(&ts);
+	rtt_results->ts = (uint64) TIMESPEC_TO_US(ts);
+
+	for (i = 0; i < rtt_results->ftm_cnt; i++) {
+		rtt_results->ftm_buff[i].value = ltoh32(evp->ftm_buff[i].value);
+		rtt_results->ftm_buff[i].rssi = ltoh32(evp->ftm_buff[i].rssi);
+	}
+	return err;
+}
+int
+dhd_rtt_event_handler(dhd_pub_t *dhd, wl_event_msg_t *event, void *event_data)
+{
+	int err = BCME_OK;
+	int len = 0;
+	int idx;
+	uint status, event_type, flags, reason, ftm_cnt;
+	rtt_status_info_t *rtt_status;
+	wl_proxd_event_data_t* evp;
+	struct rtt_noti_callback *iter;
+	rtt_result_t *rtt_result, *entry, *next;
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	event_type = ntoh32_ua((void *)&event->event_type);
+	flags = ntoh16_ua((void *)&event->flags);
+	status = ntoh32_ua((void *)&event->status);
+	reason = ntoh32_ua((void *)&event->reason);
+
+	if (event_type != WLC_E_PROXD) {
+		goto exit;
+	}
+	evp = (wl_proxd_event_data_t*)event_data;
+	DHD_RTT(("%s enter : mode: %s, reason :%d \n", __FUNCTION__,
+			(ntoh16(evp->mode) == WL_PROXD_MODE_INITIATOR)?
+			"initiator":"target", reason));
+	switch (reason) {
+	case WLC_E_PROXD_STOP:
+		DHD_RTT(("WLC_E_PROXD_STOP\n"));
+		break;
+	case WLC_E_PROXD_ERROR:
+	case WLC_E_PROXD_COMPLETED:
+		if (reason == WLC_E_PROXD_ERROR) {
+			DHD_RTT(("WLC_E_PROXD_ERROR\n"));
+		} else {
+			DHD_RTT(("WLC_E_PROXD_COMPLETED\n"));
+		}
+		mutex_lock(&rtt_status->rtt_mutex);
+		ftm_cnt = ltoh16(evp->ftm_cnt);
+
+		if (ftm_cnt > 0)
+			len = OFFSETOF(rtt_result_t, ftm_buff);
+		else
+			len = sizeof(rtt_result_t);
+		/* check whether the results is already reported or not*/
+		list_for_each_entry(entry, &rtt_status->rtt_results_cache, list) {
+			if (!memcmp(&entry->peer_mac, &evp->peer_mac, ETHER_ADDR_LEN))	{
+				mutex_unlock(&rtt_status->rtt_mutex);
+				goto exit;
+			}
+		}
+
+		rtt_result = kzalloc(len + sizeof(ftm_sample_t) * ftm_cnt, GFP_KERNEL);
+		if (!rtt_result) {
+			mutex_unlock(&rtt_status->rtt_mutex);
+			err = -ENOMEM;
+			goto exit;
+		}
+		/* point to target_info in status struct and increase pointer */
+		rtt_result->target_info = &rtt_status->rtt_config.target_info[rtt_status->cur_idx];
+		/* find next target to trigger RTT */
+		for (idx = (rtt_status->cur_idx + 1); idx < rtt_status->rtt_config.rtt_target_cnt; idx++) {
+			/* skip the disabled device */
+			if (rtt_status->rtt_config.target_info[idx].disable)
+				continue;
+			else {
+				/*set the idx to cur_idx */
+				rtt_status->cur_idx = idx;
+				break;
+			}
+		}
+		/* convert the event results to host format */
+		dhd_rtt_convert_to_host(rtt_result, evp);
+		list_add_tail(&rtt_result->list, &rtt_status->rtt_results_cache);
+		if (idx < rtt_status->rtt_config.rtt_target_cnt) {
+			/* restart to measure RTT from next device */
+			schedule_work(&rtt_status->work);
+		} else {
+			DHD_RTT(("RTT_STOPPED\n"));
+			rtt_status->status = RTT_STOPPED;
+			/* to turn on mpc mode */
+			schedule_work(&rtt_status->work);
+			/* notify the completed information to others */
+			list_for_each_entry(iter, &rtt_status->noti_fn_list, list) {
+				iter->noti_fn(iter->ctx, &rtt_status->rtt_results_cache);
+			}
+			/* remove the rtt results in cache */
+			list_for_each_entry_safe(rtt_result, next,
+				&rtt_status->rtt_results_cache, list) {
+				list_del(&rtt_result->list);
+				kfree(rtt_result);
+			}
+			/* reinit the HEAD */
+			INIT_LIST_HEAD(&rtt_status->rtt_results_cache);
+			/* clear information for rtt_config */
+			bzero(&rtt_status->rtt_config, sizeof(rtt_config_params_t));
+			rtt_status->cur_idx = 0;
+		}
+		mutex_unlock(&rtt_status->rtt_mutex);
+
+		break;
+	case WLC_E_PROXD_GONE:
+		DHD_RTT(("WLC_E_PROXD_GONE\n"));
+		break;
+	case WLC_E_PROXD_START:
+		/* event for targets / accesspoints  */
+		DHD_RTT(("WLC_E_PROXD_START\n"));
+		break;
+	case WLC_E_PROXD_COLLECT_START:
+		DHD_RTT(("WLC_E_PROXD_COLLECT_START\n"));
+		break;
+	case WLC_E_PROXD_COLLECT_STOP:
+		DHD_RTT(("WLC_E_PROXD_COLLECT_STOP\n"));
+		break;
+	case WLC_E_PROXD_COLLECT_COMPLETED:
+		DHD_RTT(("WLC_E_PROXD_COLLECT_COMPLETED\n"));
+		break;
+	case WLC_E_PROXD_COLLECT_ERROR:
+		DHD_RTT(("WLC_E_PROXD_COLLECT_ERROR; "));
+		break;
+	default:
+		DHD_ERROR(("WLC_E_PROXD: supported EVENT reason code:%d\n", reason));
+		break;
+	}
+
+exit:
+	return err;
+}
+static void
+dhd_rtt_work(struct work_struct *work)
+{
+	rtt_status_info_t *rtt_status;
+	dhd_pub_t *dhd;
+	rtt_status = container_of(work, rtt_status_info_t, work);
+	if (rtt_status == NULL) {
+		DHD_ERROR(("%s : rtt_status is NULL\n", __FUNCTION__));
+		return;
+	}
+	dhd = rtt_status->dhd;
+	if (dhd == NULL) {
+		DHD_ERROR(("%s : dhd is NULL\n", __FUNCTION__));
+		return;
+	}
+	dhd_rtt_start(dhd);
+}
+
+int
+dhd_rtt_capability(dhd_pub_t *dhd, rtt_capabilities_t *capa)
+{
+	rtt_status_info_t *rtt_status;
+	int err = BCME_OK;
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	NULL_CHECK(capa, "capa is NULL", err);
+	bzero(capa, sizeof(rtt_capabilities_t));
+
+	if (rtt_status->capability & RTT_CAP_ONE_WAY)
+		capa->rtt_one_sided_supported = 1;
+	if (rtt_status->capability & RTT_CAP_11V_WAY)
+		capa->rtt_11v_supported = 1;
+	if (rtt_status->capability & RTT_CAP_11MC_WAY)
+		capa->rtt_ftm_supported = 1;
+	if (rtt_status->capability & RTT_CAP_VS_WAY)
+		capa->rtt_vs_supported = 1;
+
+	return err;
+}
+int
+dhd_rtt_init(dhd_pub_t *dhd)
+{
+	int err = BCME_OK;
+	rtt_status_info_t *rtt_status;
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	if (dhd->rtt_state)
+		goto exit;
+	dhd->rtt_state = MALLOC(dhd->osh, sizeof(rtt_status_info_t));
+	if (dhd->rtt_state == NULL) {
+		DHD_ERROR(("failed to create rtt_state\n"));
+		goto exit;
+	}
+	bzero(dhd->rtt_state, sizeof(rtt_status_info_t));
+	rtt_status = GET_RTTSTATE(dhd);
+	rtt_status->dhd = dhd;
+	err = dhd_iovar(dhd, 0, "proxd_params", NULL, 0, 1);
+	if (err != BCME_UNSUPPORTED) {
+		/* TODO :  need to find a way to check rtt capability */
+		rtt_status->capability |= RTT_CAP_ONE_WAY;
+		rtt_status->capability |= RTT_CAP_VS_WAY;
+	}
+	mutex_init(&rtt_status->rtt_mutex);
+	INIT_LIST_HEAD(&rtt_status->noti_fn_list);
+	INIT_LIST_HEAD(&rtt_status->rtt_results_cache);
+	INIT_WORK(&rtt_status->work, dhd_rtt_work);
+exit:
+	return err;
+}
+
+int dhd_rtt_deinit(dhd_pub_t *dhd)
+{
+	int err = BCME_OK;
+	rtt_status_info_t *rtt_status;
+	rtt_result_t *rtt_result, *next;
+	struct rtt_noti_callback *iter, *iter2;
+	NULL_CHECK(dhd, "dhd is NULL", err);
+	rtt_status = GET_RTTSTATE(dhd);
+	NULL_CHECK(rtt_status, "rtt_status is NULL", err);
+	rtt_status->status = RTT_STOPPED;
+	/* clear evt callback list */
+	if (!list_empty(&rtt_status->noti_fn_list)) {
+		list_for_each_entry_safe(iter, iter2, &rtt_status->noti_fn_list, list) {
+			list_del(&iter->list);
+			kfree(iter);
+		}
+	}
+	/* remove the rtt results */
+	if (!list_empty(&rtt_status->rtt_results_cache)) {
+		list_for_each_entry_safe(rtt_result, next, &rtt_status->rtt_results_cache, list) {
+			list_del(&rtt_result->list);
+			kfree(rtt_result);
+		}
+	}
+	MFREE(dhd->osh, dhd->rtt_state, sizeof(rtt_status_info_t));
+	dhd->rtt_state = NULL;
+	return err;
+}
diff --git a/drivers/net/wireless/bcmdhd/dhd_rtt.h b/drivers/net/wireless/bcmdhd/dhd_rtt.h
new file mode 100644
index 000000000000..cf04533c1b50
--- /dev/null
+++ b/drivers/net/wireless/bcmdhd/dhd_rtt.h
@@ -0,0 +1,241 @@
+/*
+ * Header file of Broadcom Dongle Host Driver (DHD)
+ * Copyright (C) 1999-2014, Broadcom Corporation
+ *
+ *      Unless you and Broadcom execute a separate written software license
+ * agreement governing use of this software, this software is licensed to you
+ * under the terms of the GNU General Public License version 2 (the "GPL"),
+ * available at http://www.broadcom.com/licenses/GPLv2.php, with the
+ * following added to such license:
+ *
+ *      As a special exception, the copyright holders of this software give you
+ * permission to link this software with independent modules, and to copy and
+ * distribute the resulting executable under terms of your choice, provided that
+ * you also meet, for each linked independent module, the terms and conditions of
+ * the license of that module.  An independent module is a module which is not
+ * derived from this software.  The special exception does not apply to any
+ * modifications of the software.
+ *
+ *      Notwithstanding the above, under no circumstances may you combine this
+ * software in any way with any other Broadcom software provided under a license
+ * other than the GPL, without Broadcom's express prior written consent.
+ *
+ * $Id: dhd_rtt.h 423669 2014-07-01 13:01:56Z $
+ */
+#ifndef __DHD_RTT_H__
+#define __DHD_RTT_H__
+
+#define RTT_MAX_TARGET_CNT 10
+#define DEFAULT_FTM_CNT 6
+#define DEFAULT_RETRY_CNT 6
+
+
+/* DSSS, CCK and 802.11n rates in [500kbps] units */
+#define WL_MAXRATE	108	/* in 500kbps units */
+#define WL_RATE_1M	2	/* in 500kbps units */
+#define WL_RATE_2M	4	/* in 500kbps units */
+#define WL_RATE_5M5	11	/* in 500kbps units */
+#define WL_RATE_11M	22	/* in 500kbps units */
+#define WL_RATE_6M	12	/* in 500kbps units */
+#define WL_RATE_9M	18	/* in 500kbps units */
+#define WL_RATE_12M	24	/* in 500kbps units */
+#define WL_RATE_18M	36	/* in 500kbps units */
+#define WL_RATE_24M	48	/* in 500kbps units */
+#define WL_RATE_36M	72	/* in 500kbps units */
+#define WL_RATE_48M	96	/* in 500kbps units */
+#define WL_RATE_54M	108	/* in 500kbps units */
+
+
+enum rtt_role {
+	RTT_INITIATOR = 0,
+	RTT_TARGET = 1
+};
+enum rtt_status {
+	RTT_STOPPED = 0,
+	RTT_STARTED = 1
+};
+typedef int64_t wifi_timestamp; /* In microseconds (us) */
+typedef int64_t wifi_timespan;
+typedef int wifi_rssi;
+
+typedef enum {
+	RTT_INVALID,
+	RTT_ONE_WAY,
+	RTT_TWO_WAY,
+	RTT_AUTO
+} rtt_type_t;
+
+typedef enum {
+	RTT_PEER_STA,
+	RTT_PEER_AP,
+	RTT_PEER_P2P,
+	RTT_PEER_NAN,
+	RTT_PEER_INVALID
+} rtt_peer_type_t;
+
+typedef enum rtt_reason {
+	RTT_REASON_SUCCESS,
+	RTT_REASON_FAILURE,
+	RTT_REASON_NO_RSP,
+	RTT_REASON_REJECTED,
+	RTT_REASON_NOT_SCHEDULED_YET,
+	RTT_REASON_TIMEOUT,
+	RTT_REASON_AP_ON_DIFF_CH,
+	RTT_REASON_AP_NO_CAP,
+	RTT_REASON_ABORT
+} rtt_reason_t;
+
+typedef enum wifi_channel_width {
+	WIFI_CHAN_WIDTH_20	  = 0,
+	WIFI_CHAN_WIDTH_40	  = 1,
+	WIFI_CHAN_WIDTH_80	  = 2,
+	WIFI_CHAN_WIDTH_160   = 3,
+	WIFI_CHAN_WIDTH_80P80 = 4,
+	WIFI_CHAN_WIDTH_5	  = 5,
+	WIFI_CHAN_WIDTH_10	  = 6,
+	WIFI_CHAN_WIDTH_INVALID = -1
+} wifi_channel_width_t;
+
+typedef enum rtt_capability {
+	RTT_CAP_NONE = 0,
+	RTT_CAP_ONE_WAY	 = (1 << (0)),
+	RTT_CAP_11V_WAY  = (1 << (1)),  /* IEEE802.11v */
+	RTT_CAP_11MC_WAY  = (1 << (2)), /* IEEE802.11mc */
+	RTT_CAP_VS_WAY = (1 << (3)) /* BRCM vendor specific */
+} rtt_capability_t ;
+
+typedef int wifi_channel;
+
+typedef struct wifi_channel_info {
+	wifi_channel_width_t width;
+	wifi_channel center_freq; /* primary 20 MHz channel */
+	wifi_channel center_freq0; /* center freq (MHz) first segment */
+	wifi_channel center_freq1; /* center freq (MHz) second segment valid for 80 + 80 */
+} wifi_channel_info_t;
+
+typedef struct wifi_rate {
+	uint32 preamble :3; /* 0: OFDM, 1: CCK, 2 : HT, 3: VHT, 4..7 reserved */
+	uint32 nss		:2; /* 0 : 1x1, 1: 2x2, 3: 3x3, 4: 4x4 */
+	uint32 bw		:3; /* 0: 20Mhz, 1: 40Mhz, 2: 80Mhz, 3: 160Mhz */
+	/* OFDM/CCK rate code would be as per IEEE std in the unit of 0.5 mb
+	* HT/VHT it would be mcs index
+	*/
+	uint32 rateMcsIdx :8;
+	uint32 reserved :16; /* reserved */
+	uint32 bitrate; 	/* unit of 100 Kbps */
+} wifi_rate_t;
+
+typedef struct rtt_target_info {
+	struct ether_addr addr;
+	rtt_type_t type; /* rtt_type */
+	rtt_peer_type_t peer; /* peer type */
+	wifi_channel_info_t channel; /* channel information */
+	chanspec_t chanspec; /* chanspec for channel */
+	int8	continuous; /* 0 = single shot or 1 = continous raging */
+	bool	disable; /* disable for RTT measurement */
+	uint32	interval; /* interval of RTT measurement (unit ms) when continuous = true */
+	uint32	measure_cnt; /* total number of RTT measurement when continuous */
+	uint32	ftm_cnt; /* num of packets in each RTT measurement */
+	uint32	retry_cnt; /* num of retries if sampling fails */
+} rtt_target_info_t;
+
+typedef struct rtt_result {
+	struct list_head list;
+	uint16 ver;			/* version */
+	rtt_target_info_t *target_info; /* target info */
+	uint16 mode;			/* mode: target/initiator */
+	uint16 method;			/* method: rssi/TOF/AOA */
+	uint8  err_code;		/* error classification */
+	uint8  TOF_type;		/* one way or two way TOF */
+	wifi_rate_t tx_rate;           /* tx rate */
+	struct ether_addr peer_mac;	/* (e.g for tgt:initiator's */
+	int32 distance;		/* dst to tgt, units (meter * 16) */
+	uint32 meanrtt;			/* mean delta */
+	uint32 modertt;			/* Mode delta */
+	uint32 medianrtt;		/* median RTT */
+	uint32 sdrtt;			/* Standard deviation of RTT */
+	int16  avg_rssi;		/* avg rssi across the ftm frames */
+	int16  validfrmcnt;		/* Firmware's valid frame counts */
+	wifi_timestamp ts; /* the time elapsed from boot time when driver get this result */
+	uint16 ftm_cnt;			/*  num of rtd measurments/length in the ftm buffer  */
+	ftm_sample_t ftm_buff[1];	/* 1 ... ftm_cnt  */
+} rtt_result_t;
+
+typedef struct rtt_report {
+	struct ether_addr addr;
+	uint num_measurement; /* measurement number in case of continous raging */
+	rtt_reason_t status; /* raging status */
+	rtt_type_t type; /* rtt type */
+	rtt_peer_type_t peer; /* peer type */
+	wifi_channel_info_t channel; /* channel information */
+	wifi_rssi  rssi; /* avg rssi accroos the ftm frames */
+	wifi_rssi  rssi_spread; /* rssi spread in 0.5 db steps e.g. 5 implies 2.5 spread */
+	wifi_rate_t tx_rate;           /* tx rate */
+	wifi_timespan rtt;	/*  round trip time in nanoseconds */
+	wifi_timespan rtt_sd;	/* rtt standard deviation in nanoseconds */
+	wifi_timespan rtt_spread; /* difference between max and min rtt times recorded */
+	int32 distance; /* distance in cm (optional) */
+	int32 distance_sd; /* standard deviation in cm (optional) */
+	int32 distance_spread;/* difference between max and min distance recorded (optional) */
+	wifi_timestamp ts; /* time of the measurement (in microseconds since boot) */
+} rtt_report_t;
+
+/* RTT Capabilities */
+typedef struct rtt_capabilities{
+	uint8 rtt_one_sided_supported;  /* if 1-sided rtt data collection is supported */
+	uint8 rtt_11v_supported;        /* if 11v rtt data collection is supported */
+	uint8 rtt_ftm_supported;        /* if ftm rtt data collection is supported */
+	uint8 rtt_vs_supported; 		 /* if vendor specific data collection is supported */
+} rtt_capabilities_t;
+
+typedef struct rtt_config_params {
+	int8 rtt_target_cnt;
+	rtt_target_info_t target_info[RTT_MAX_TARGET_CNT];
+} rtt_config_params_t;
+
+typedef void (*dhd_rtt_compl_noti_fn)(void *ctx, void *rtt_data);
+/* Linux wrapper to call common dhd_rtt_set_cfg */
+int
+dhd_dev_rtt_set_cfg(struct net_device *dev, void *buf);
+
+int
+dhd_dev_rtt_cancel_cfg(struct net_device *dev, struct ether_addr *mac_list, int mac_cnt);
+
+int
+dhd_dev_rtt_register_noti_callback(struct net_device *dev, void *ctx, dhd_rtt_compl_noti_fn noti_fn);
+
+int
+dhd_dev_rtt_unregister_noti_callback(struct net_device *dev, dhd_rtt_compl_noti_fn noti_fn);
+
+int
+dhd_dev_rtt_capability(struct net_device *dev, rtt_capabilities_t *capa);
+
+/* export to upper layer */
+chanspec_t
+dhd_rtt_convert_to_chspec(wifi_channel_info_t channel);
+
+int
+dhd_rtt_set_cfg(dhd_pub_t *dhd, rtt_config_params_t *params);
+
+int
+dhd_rtt_stop(dhd_pub_t *dhd, struct ether_addr *mac_list, int mac_cnt);
+
+
+int
+dhd_rtt_register_noti_callback(dhd_pub_t *dhd, void *ctx, dhd_rtt_compl_noti_fn noti_fn);
+
+int
+dhd_rtt_unregister_noti_callback(dhd_pub_t *dhd, dhd_rtt_compl_noti_fn noti_fn);
+
+int
+dhd_rtt_event_handler(dhd_pub_t *dhd, wl_event_msg_t *event, void *event_data);
+
+int
+dhd_rtt_capability(dhd_pub_t *dhd, rtt_capabilities_t *capa);
+
+int
+dhd_rtt_init(dhd_pub_t *dhd);
+
+int
+dhd_rtt_deinit(dhd_pub_t *dhd);
+#endif
diff --git a/drivers/net/wireless/bcmdhd/include/dhdioctl.h b/drivers/net/wireless/bcmdhd/include/dhdioctl.h
index 3fa5f154f33a..63cddc85572a 100644
--- a/drivers/net/wireless/bcmdhd/include/dhdioctl.h
+++ b/drivers/net/wireless/bcmdhd/include/dhdioctl.h
@@ -93,6 +93,7 @@ enum {
 #define DHD_NOCHECKDIED_VAL		0x20000 /* UTF WAR */
 #define DHD_WL_VAL2		0x40000
 #define DHD_PNO_VAL		0x80000
+#define DHD_RTT_VAL		0x100000
 
 #ifdef SDTEST
 /* For pktgen iovar */
diff --git a/drivers/net/wireless/bcmdhd/wl_cfgvendor.c b/drivers/net/wireless/bcmdhd/wl_cfgvendor.c
index 61673580724a..68b2dcb931a3 100644
--- a/drivers/net/wireless/bcmdhd/wl_cfgvendor.c
+++ b/drivers/net/wireless/bcmdhd/wl_cfgvendor.c
@@ -42,7 +42,7 @@
 #include <linux/if_arp.h>
 #include <asm/uaccess.h>
 
-#if defined(BCMDONGLEHOST)
+
 #include <dngl_stats.h>
 #include <dhd.h>
 #include <dhdioctl.h>
@@ -51,8 +51,9 @@
 #ifdef PNO_SUPPORT
 #include <dhd_pno.h>
 #endif /* PNO_SUPPORT */
-#endif /* defined(BCMDONGLEHOST) */
-
+#ifdef RTT_SUPPORT
+#include <dhd_rtt.h>
+#endif /* RTT_SUPPORT */
 #include <proto/ethernet.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
@@ -719,6 +720,221 @@ exit:
 	return err;
 }
 #endif /* GSCAN_SUPPORT */
+
+#ifdef RTT_SUPPORT
+void wl_cfgvendor_rtt_evt(void *ctx, void *rtt_data)
+{
+	struct wireless_dev *wdev = (struct wireless_dev *)ctx;
+	struct wiphy *wiphy;
+	struct sk_buff *skb;
+	uint32 tot_len = NLMSG_DEFAULT_SIZE, entry_len = 0;
+	gfp_t kflags;
+	rtt_report_t *rtt_report = NULL;
+	rtt_result_t *rtt_result = NULL;
+	struct list_head *rtt_list;
+	wiphy = wdev->wiphy;
+
+	WL_DBG(("In\n"));
+	/* Push the data to the skb */
+	if (!rtt_data) {
+		WL_ERR(("rtt_data is NULL\n"));
+		goto exit;
+	}
+	rtt_list = (struct list_head *)rtt_data;
+	kflags = in_atomic() ? GFP_ATOMIC : GFP_KERNEL;
+	/* Alloc the SKB for vendor_event */
+	skb = cfg80211_vendor_event_alloc(wiphy, tot_len, GOOGLE_RTT_COMPLETE_EVENT, kflags);
+	if (!skb) {
+		WL_ERR(("skb alloc failed"));
+		goto exit;
+	}
+	/* fill in the rtt results on each entry */
+	list_for_each_entry(rtt_result, rtt_list, list) {
+		entry_len = 0;
+		if (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) {
+			entry_len = sizeof(rtt_report_t);
+			rtt_report = kzalloc(entry_len, kflags);
+			if (!rtt_report) {
+				WL_ERR(("rtt_report alloc failed"));
+				goto exit;
+			}
+			rtt_report->addr = rtt_result->peer_mac;
+			rtt_report->num_measurement = 1; /* ONE SHOT */
+			rtt_report->status = rtt_result->err_code;
+			rtt_report->type = (rtt_result->TOF_type == TOF_TYPE_ONE_WAY) ? RTT_ONE_WAY: RTT_TWO_WAY;
+			rtt_report->peer = rtt_result->target_info->peer;
+			rtt_report->channel = rtt_result->target_info->channel;
+			rtt_report->rssi = rtt_result->avg_rssi;
+			/* tx_rate */
+			rtt_report->tx_rate = rtt_result->tx_rate;
+			/* RTT */
+			rtt_report->rtt = rtt_result->meanrtt;
+			rtt_report->rtt_sd = rtt_result->sdrtt;
+			/* convert to centi meter */
+			if (rtt_result->distance != 0xffffffff)
+				rtt_report->distance = (rtt_result->distance >> 2) * 25;
+			else /* invalid distance */
+				rtt_report->distance = -1;
+
+			rtt_report->ts = rtt_result->ts;
+			nla_append(skb, entry_len, rtt_report);
+			kfree(rtt_report);
+		}
+	}
+	cfg80211_vendor_event(skb, kflags);
+exit:
+	return;
+}
+
+static int wl_cfgvendor_rtt_set_config(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len) {
+	int err = 0, rem, rem1, rem2, type;
+	rtt_config_params_t rtt_param;
+	rtt_target_info_t* rtt_target = NULL;
+	const struct nlattr *iter, *iter1, *iter2;
+	int8 eabuf[ETHER_ADDR_STR_LEN];
+	int8 chanbuf[CHANSPEC_STR_LEN];
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+
+	WL_DBG(("In\n"));
+	err = dhd_dev_rtt_register_noti_callback(wdev->netdev, wdev, wl_cfgvendor_rtt_evt);
+	if (err < 0) {
+		WL_ERR(("failed to register rtt_noti_callback\n"));
+		goto exit;
+	}
+	memset(&rtt_param, 0, sizeof(rtt_param));
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case RTT_ATTRIBUTE_TARGET_CNT:
+			rtt_param.rtt_target_cnt = nla_get_u8(iter);
+			if (rtt_param.rtt_target_cnt > RTT_MAX_TARGET_CNT) {
+				WL_ERR(("exceed max target count : %d\n",
+					rtt_param.rtt_target_cnt));
+				err = BCME_RANGE;
+			}
+			break;
+		case RTT_ATTRIBUTE_TARGET_INFO:
+			rtt_target = rtt_param.target_info;
+			nla_for_each_nested(iter1, iter, rem1) {
+				nla_for_each_nested(iter2, iter1, rem2) {
+					type = nla_type(iter2);
+					switch (type) {
+					case RTT_ATTRIBUTE_TARGET_MAC:
+						memcpy(&rtt_target->addr, nla_data(iter2), ETHER_ADDR_LEN);
+						break;
+					case RTT_ATTRIBUTE_TARGET_TYPE:
+						rtt_target->type = nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_PEER:
+						rtt_target->peer= nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_CHAN:
+						memcpy(&rtt_target->channel, nla_data(iter2),
+							sizeof(rtt_target->channel));
+						break;
+					case RTT_ATTRIBUTE_TARGET_MODE:
+						rtt_target->continuous = nla_get_u8(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_INTERVAL:
+						rtt_target->interval = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_MEASUREMENT:
+						rtt_target->measure_cnt = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_PKT:
+						rtt_target->ftm_cnt = nla_get_u32(iter2);
+						break;
+					case RTT_ATTRIBUTE_TARGET_NUM_RETRY:
+						rtt_target->retry_cnt = nla_get_u32(iter2);
+					}
+				}
+				/* convert to chanspec value */
+				rtt_target->chanspec = dhd_rtt_convert_to_chspec(rtt_target->channel);
+				if (rtt_target->chanspec == 0) {
+					WL_ERR(("Channel is not valid \n"));
+					goto exit;
+				}
+				WL_INFORM(("Target addr %s, Channel : %s for RTT \n",
+					bcm_ether_ntoa((const struct ether_addr *)&rtt_target->addr, eabuf),
+					wf_chspec_ntoa(rtt_target->chanspec, chanbuf)));
+				rtt_target++;
+			}
+			break;
+		}
+	}
+	WL_DBG(("leave :target_cnt : %d\n", rtt_param.rtt_target_cnt));
+	if (dhd_dev_rtt_set_cfg(bcmcfg_to_prmry_ndev(cfg), &rtt_param) < 0) {
+		WL_ERR(("Could not set RTT configuration\n"));
+		err = -EINVAL;
+	}
+exit:
+	return err;
+}
+
+static int wl_cfgvendor_rtt_cancel_config(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	int err = 0, rem, type, target_cnt = 0;
+	const struct nlattr *iter;
+	struct ether_addr *mac_list = NULL, *mac_addr = NULL;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case RTT_ATTRIBUTE_TARGET_CNT:
+			target_cnt = nla_get_u8(iter);
+			mac_list = (struct ether_addr *)kzalloc(target_cnt * ETHER_ADDR_LEN , GFP_KERNEL);
+			if (mac_list == NULL) {
+				WL_ERR(("failed to allocate mem for mac list\n"));
+				goto exit;
+			}
+			mac_addr = &mac_list[0];
+			break;
+		case RTT_ATTRIBUTE_TARGET_MAC:
+			if (mac_addr)
+				memcpy(mac_addr++, nla_data(iter), ETHER_ADDR_LEN);
+			else {
+				WL_ERR(("mac_list is NULL\n"));
+				goto exit;
+			}
+			break;
+		}
+		if (dhd_dev_rtt_cancel_cfg(bcmcfg_to_prmry_ndev(cfg), mac_list, target_cnt) < 0) {
+			WL_ERR(("Could not cancel RTT configuration\n"));
+			err = -EINVAL;
+			goto exit;
+		}
+	}
+exit:
+	if (mac_list)
+		kfree(mac_list);
+	return err;
+}
+static int wl_cfgvendor_rtt_get_capability(struct wiphy *wiphy, struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	int err = 0;
+	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	rtt_capabilities_t capability;
+
+	err = dhd_dev_rtt_capability(bcmcfg_to_prmry_ndev(cfg), &capability);
+	if (unlikely(err)) {
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+		goto exit;
+	}
+	err =  wl_cfgvendor_send_cmd_reply(wiphy, bcmcfg_to_prmry_ndev(cfg),
+	        &capability, sizeof(capability));
+
+	if (unlikely(err)) {
+		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+	}
+exit:
+	return err;
+}
+
+#endif /* RTT_SUPPORT */
 static int wl_cfgvendor_priv_string_handler(struct wiphy *wiphy,
 	struct wireless_dev *wdev, const void  *data, int len)
 {
@@ -743,6 +959,8 @@ static int wl_cfgvendor_priv_string_handler(struct wiphy *wiphy,
 		cfg->ioctl_buf, data_len+1);
 	if (unlikely(err))
 		WL_ERR(("Vendor Command reply failed ret:%d \n", err));
+	else
+		WL_INFORM(("Vendor Command reply sent successfully!\n"));
 
 	return err;
 }
@@ -830,6 +1048,32 @@ static const struct wiphy_vendor_command wl_vendor_cmds [] = {
 		.doit = wl_cfgvendor_gscan_get_channel_list
 	},
 #endif /* GSCAN_SUPPORT */
+#ifdef RTT_SUPPORT
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_SET_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_set_config
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_CANCEL_CONFIG
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_cancel_config
+	},
+	{
+		{
+			.vendor_id = OUI_GOOGLE,
+			.subcmd = RTT_SUBCMD_GETCAPABILITY
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = wl_cfgvendor_rtt_get_capability
+	},
+#endif /* RTT_SUPPORT */
 	{
 		{
 			.vendor_id = OUI_GOOGLE,
@@ -856,7 +1100,11 @@ static const struct  nl80211_vendor_cmd_info wl_vendor_events [] = {
 		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT },
 		{ OUI_GOOGLE, GOOGLE_GSCAN_BATCH_SCAN_EVENT },
 		{ OUI_GOOGLE, GOOGLE_SCAN_FULL_RESULTS_EVENT },
-		{ OUI_GOOGLE, GOOGLE_SCAN_RTT_EVENT },
+#endif /* GSCAN_SUPPORT */
+#ifdef RTT_SUPPORT
+		{ OUI_GOOGLE, GOOGLE_RTT_COMPLETE_EVENT },
+#endif /* RTT_SUPPORT */
+#ifdef GSCAN_SUPPORT
 		{ OUI_GOOGLE, GOOGLE_SCAN_COMPLETE_EVENT },
 		{ OUI_GOOGLE, GOOGLE_GSCAN_GEOFENCE_LOST_EVENT }
 #endif /* GSCAN_SUPPORT */
@@ -865,7 +1113,7 @@ static const struct  nl80211_vendor_cmd_info wl_vendor_events [] = {
 int wl_cfgvendor_attach(struct wiphy *wiphy)
 {
 
-	WL_ERR(("Vendor: Register BRCM cfg80211 vendor cmd(0x%x) interface \n",
+	WL_INFORM(("Vendor: Register BRCM cfg80211 vendor cmd(0x%x) interface \n",
 		NL80211_CMD_VENDOR));
 
 	wiphy->vendor_commands	= wl_vendor_cmds;
@@ -878,7 +1126,7 @@ int wl_cfgvendor_attach(struct wiphy *wiphy)
 
 int wl_cfgvendor_detach(struct wiphy *wiphy)
 {
-	WL_ERR(("Vendor: Unregister BRCM cfg80211 vendor interface \n"));
+	WL_INFORM(("Vendor: Unregister BRCM cfg80211 vendor interface \n"));
 
 	wiphy->vendor_commands  = NULL;
 	wiphy->vendor_events    = NULL;
diff --git a/drivers/net/wireless/bcmdhd/wl_cfgvendor.h b/drivers/net/wireless/bcmdhd/wl_cfgvendor.h
index 6087acf4a205..0087d1282f2b 100644
--- a/drivers/net/wireless/bcmdhd/wl_cfgvendor.h
+++ b/drivers/net/wireless/bcmdhd/wl_cfgvendor.h
@@ -56,25 +56,30 @@
 									VENDOR_DATA_OVERHEAD)
 typedef enum {
 	/* don't use 0 as a valid subcommand */
-    VENDOR_NL80211_SUBCMD_UNSPECIFIED,
+	VENDOR_NL80211_SUBCMD_UNSPECIFIED,
 
-    /* define all vendor startup commands between 0x0 and 0x0FFF */
-    VENDOR_NL80211_SUBCMD_RANGE_START = 0x0001,
-    VENDOR_NL80211_SUBCMD_RANGE_END   = 0x0FFF,
+	/* define all vendor startup commands between 0x0 and 0x0FFF */
+	VENDOR_NL80211_SUBCMD_RANGE_START = 0x0001,
+	VENDOR_NL80211_SUBCMD_RANGE_END   = 0x0FFF,
 
-    /* define all GScan related commands between 0x1000 and 0x10FF */
-    ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 0x1000,
-    ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END   = 0x10FF,
+	/* define all GScan related commands between 0x1000 and 0x10FF */
+	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 0x1000,
+	ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END   = 0x10FF,
 
-    /* define all NearbyDiscovery related commands between 0x1100 and 0x11FF */
-    ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 0x1100,
-    ANDROID_NL80211_SUBCMD_NBD_RANGE_END   = 0x11FF,
+	/* define all NearbyDiscovery related commands between 0x1100 and 0x11FF */
+	ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 0x1100,
+	ANDROID_NL80211_SUBCMD_NBD_RANGE_END   = 0x11FF,
 
-    /* define all RTT related commands between 0x1100 and 0x11FF */
-    ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 0x1100,
-    ANDROID_NL80211_SUBCMD_RTT_RANGE_END   = 0x11FF,
+	/* define all RTT related commands between 0x1100 and 0x11FF */
+	ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 0x1100,
+	ANDROID_NL80211_SUBCMD_RTT_RANGE_END   = 0x11FF,
 
-    /* This is reserved for future usage */
+	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START = 0x1200,
+	ANDROID_NL80211_SUBCMD_LSTATS_RANGE_END   = 0x12FF,
+
+	ANDROID_NL80211_SUBCMD_TDLS_RANGE_START = 0x1300,
+	ANDROID_NL80211_SUBCMD_TDLS_RANGE_END	= 0x13FF,
+	/* This is reserved for future usage */
 
 } ANDROID_VENDOR_SUB_COMMAND;
 
@@ -93,8 +98,11 @@ enum wl_vendor_subcmd {
 	GSCAN_SUBCMD_GET_CHANNEL_LIST,
 	ANDR_WIFI_SUBCMD_GET_FEATURE_SET,
 	ANDR_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,
+	RTT_SUBCMD_SET_CONFIG = ANDROID_NL80211_SUBCMD_RTT_RANGE_START,
+	RTT_SUBCMD_CANCEL_CONFIG,
+	RTT_SUBCMD_GETCAPABILITY,
     /* Add more sub commands here */
-    GSCAN_SUBCMD_MAX
+    VENDOR_SUBCMD_MAX
 };
 
 enum gscan_attributes {
@@ -151,6 +159,7 @@ enum gscan_attributes {
     GSCAN_ATTRIBUTE_SIGNIFICANT_CHANGE_FLUSH,
     GSCAN_ATTRIBUTE_MAX
 };
+
 enum gscan_bucket_attributes {
 	GSCAN_ATTRIBUTE_CH_BUCKET_1,
 	GSCAN_ATTRIBUTE_CH_BUCKET_2,
@@ -171,6 +180,20 @@ enum gscan_ch_attributes {
 	GSCAN_ATTRIBUTE_CH_ID_7
 };
 
+enum rtt_attributes {
+	RTT_ATTRIBUTE_TARGET_CNT,
+	RTT_ATTRIBUTE_TARGET_INFO,
+	RTT_ATTRIBUTE_TARGET_MAC,
+	RTT_ATTRIBUTE_TARGET_TYPE,
+	RTT_ATTRIBUTE_TARGET_PEER,
+	RTT_ATTRIBUTE_TARGET_CHAN,
+	RTT_ATTRIBUTE_TARGET_MODE,
+	RTT_ATTRIBUTE_TARGET_INTERVAL,
+	RTT_ATTRIBUTE_TARGET_NUM_MEASUREMENT,
+	RTT_ATTRIBUTE_TARGET_NUM_PKT,
+	RTT_ATTRIBUTE_TARGET_NUM_RETRY
+};
+
 typedef enum wl_vendor_event {
 	BRCM_VENDOR_EVENT_UNSPEC,
 	BRCM_VENDOR_EVENT_PRIV_STR,
@@ -178,7 +201,7 @@ typedef enum wl_vendor_event {
 	GOOGLE_GSCAN_GEOFENCE_FOUND_EVENT,
 	GOOGLE_GSCAN_BATCH_SCAN_EVENT,
 	GOOGLE_SCAN_FULL_RESULTS_EVENT,
-	GOOGLE_SCAN_RTT_EVENT,
+	GOOGLE_RTT_COMPLETE_EVENT,
 	GOOGLE_SCAN_COMPLETE_EVENT,
 	GOOGLE_GSCAN_GEOFENCE_LOST_EVENT
 } wl_vendor_event_t;
-- 
2.0.3

