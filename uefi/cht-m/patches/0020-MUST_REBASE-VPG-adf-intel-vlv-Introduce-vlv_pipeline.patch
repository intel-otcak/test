From ae90e2a06a070f02bdfb1961720dab5605a096d3 Mon Sep 17 00:00:00 2001
Message-Id: <ae90e2a06a070f02bdfb1961720dab5605a096d3.1423172493.git.feitong.yi@intel.com>
In-Reply-To: <18bb7324f916bffbc75e07ea0ffd3e6e68e7b6d8.1423172493.git.feitong.yi@intel.com>
References: <18bb7324f916bffbc75e07ea0ffd3e6e68e7b6d8.1423172493.git.feitong.yi@intel.com>
From: rtshiva <sivakumar.thulasimani@intel.com>
Date: Tue, 20 Jan 2015 18:34:21 +0530
Subject: [PATCH 20/29] MUST_REBASE [VPG]: adf/intel/vlv: Introduce
 vlv_pipeline

vlv_pipeline is a superset of vlv_pipe, vlv_port, vlv_pll, vlv_pm  and planes.
This patch adds changes required to plug in this new design across the
existing code and adds new files for pipeline as well.

MUST_REBASE: Since Google ADF framework is not in upstream and also
we cannot have two display drivers, other one being i915, we need to
work on i915 and ADF convergence path before it can be upstreamed.

For: GMINL-5213
Change-Id: I550c9c9f3380cd24561ea1a2d6995c590ee93207
Signed-off-by: Sivakumar Thulasimani <sivakumar.thulasimani@intel.com>
Signed-off-by: Deepak M <m.deepak@intel.com>
---
 drivers/video/adf/intel/core/common/dsi/Makefile   |    2 -
 .../video/adf/intel/core/common/dsi/dsi_config.c   |   15 +-
 .../video/adf/intel/core/common/dsi/dsi_pipe_ops.c |  616 ++++----------------
 .../video/adf/intel/core/common/dsi/gen_dsi_pipe.c |  462 ++++++++-------
 .../adf/intel/core/common/dsi/intel_dsi_cmd.h      |   74 +--
 drivers/video/adf/intel/core/intel_dc_config.c     |    1 +
 drivers/video/adf/intel/core/vlv/Makefile          |    4 +-
 drivers/video/adf/intel/core/vlv/vlv_dc_config.c   |  211 ++++---
 drivers/video/adf/intel/core/vlv/vlv_mode_set.c    |  324 ----------
 drivers/video/adf/intel/core/vlv/vlv_pipeline.c    |  495 ++++++++++++++++
 drivers/video/adf/intel/core/vlv/vlv_pri_plane.c   |  149 +++--
 drivers/video/adf/intel/core/vlv/vlv_sp_plane.c    |  182 +++---
 .../adf/intel/include/core/common/dsi/dsi_pipe.h   |    4 +-
 .../video/adf/intel/include/core/intel_dc_config.h |   40 +-
 .../adf/intel/include/core/intel_platform_config.h |   83 +++
 .../adf/intel/include/core/vlv/vlv_dc_config.h     |  133 +++--
 .../video/adf/intel/include/core/vlv/vlv_dpst.h    |    9 +-
 .../adf/intel/include/core/vlv/vlv_pri_plane.h     |   26 +-
 .../adf/intel/include/core/vlv/vlv_sp_plane.h      |   20 +-
 drivers/video/adf/intel/include/intel_adf.h        |    1 -
 drivers/video/adf/intel/intel_adf_interface.c      |    4 -
 21 files changed, 1438 insertions(+), 1417 deletions(-)
 delete mode 100644 drivers/video/adf/intel/core/vlv/vlv_mode_set.c
 create mode 100644 drivers/video/adf/intel/core/vlv/vlv_pipeline.c
 create mode 100644 drivers/video/adf/intel/include/core/intel_platform_config.h

diff --git a/drivers/video/adf/intel/core/common/dsi/Makefile b/drivers/video/adf/intel/core/common/dsi/Makefile
index 282e3fa..f625b27 100644
--- a/drivers/video/adf/intel/core/common/dsi/Makefile
+++ b/drivers/video/adf/intel/core/common/dsi/Makefile
@@ -7,8 +7,6 @@ CFLAGS_adf.o := -I$(src)
 ifdef CONFIG_ADF_INTEL_VLV
 	obj-y := gen_dsi_pipe.o
 	obj-y += dsi_pipe_ops.o
-	obj-y += intel_dsi_cmd.o
-	obj-y += intel_dsi_pll.o
 else
 	obj-y := dsi_pipe.o
 	obj-y += dsi_dbi.o
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_config.c b/drivers/video/adf/intel/core/common/dsi/dsi_config.c
index c82d567..6907336 100644
--- a/drivers/video/adf/intel/core/common/dsi/dsi_config.c
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_config.c
@@ -1,4 +1,4 @@
-/**************************************************************************
+/*
  * Copyright (c) 2007, Intel Corporation.
  * All Rights Reserved.
  * Copyright (c) 2008, Tungsten Graphics, Inc. Cedar Park, TX., USA.
@@ -13,10 +13,11 @@
  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  * more details.
  *
- **************************************************************************/
+ */
 
-#include "core/common/dsi/dsi_config.h"
-#include "core/common/dsi/dsi_panel.h"
+#include <core/common/dsi/dsi_config.h>
+#include <core/common/dsi/dsi_panel.h>
+#include <core/intel_dc_config.h>
 
 #ifndef CONFIG_ADF_INTEL_VLV
 static void dsi_regs_init(struct dsi_config *config, int idx)
@@ -184,8 +185,7 @@ int dsi_config_init(struct dsi_config *config,
 	struct panel_info pi;
 	struct drm_mode_modeinfo mode;
 
-	pr_err("ADF: %s\n", __func__);
-
+	pr_info("ADF: %s\n", __func__);
 	if (!config || !panel) {
 		pr_err("%s: invalid parameter\n", __func__);
 		err = -EINVAL;
@@ -225,7 +225,7 @@ int dsi_config_init(struct dsi_config *config,
 	config->bpp = pi.bpp;
 	config->dual_link = pi.dual_link;
 
-#ifdef CONFIG_INTEL_ADF_VLV
+#ifndef CONFIG_ADF_INTEL_VLV
 	config->channel_num = 0;
 	config->enable_gamma_csc = 0;
 	config->video_mode = DSI_VIDEO_BURST_MODE;
@@ -235,6 +235,7 @@ int dsi_config_init(struct dsi_config *config,
 	/*init regs*/
 	dsi_regs_init(config, idx);
 #endif
+
 	/*init context lock*/
 	mutex_init(&config->ctx_lock);
 
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c b/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
index d758831..6a6c66a 100644
--- a/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
@@ -28,8 +28,15 @@
 #include <intel_adf_device.h>
 #include <core/common/dsi/dsi_pipe.h>
 #include <core/common/dsi/dsi_config.h>
-#include <core/vlv/vlv_dc_regs.h>
+/*
+ * FIXME:leaving for now till we can move all calls through
+ * pipeline interface
+ */
 #include <core/vlv/vlv_dc_config.h>
+/*
+ * FIXME:leaving for now till we can move all calls through
+ * pipeline interface
+ */
 #include <core/vlv/vlv_dc_gpio.h>
 #include <core/common/intel_gen_backlight.h>
 #include <linux/mfd/intel_soc_pmic.h>
@@ -41,10 +48,9 @@
 #define PMIC_BKL_EN		0x4B
 #define PMIC_PWM_LEVEL		0x4E
 
-static void band_gap_reset(struct dsi_pipe *dsi_pipe)
+void band_gap_reset(struct dsi_pipe *dsi_pipe)
 {
-	pr_err("ADF: %s\n", __func__);
-
+	/* FIXME: move to pipeline */
 	vlv_flisdsi_write(0x08, 0x0001);
 	vlv_flisdsi_write(0x0F, 0x0005);
 	vlv_flisdsi_write(0x0F, 0x0025);
@@ -53,77 +59,8 @@ static void band_gap_reset(struct dsi_pipe *dsi_pipe)
 	vlv_flisdsi_write(0x08, 0x0000);
 }
 
-static inline bool is_vid_mode(struct dsi_config *config)
-{
-	return config->ctx.operation_mode == DSI_DPI;
-}
-
-static inline bool is_cmd_mode(struct dsi_config *config)
-{
-	return config->ctx.operation_mode == DSI_DBI;
-}
-
-static void intel_adf_dsi_device_ready(struct dsi_pipe *dsi_pipe)
-{
-	int pipe = dsi_pipe->config.pipe;
-	u32 val;
-
-	pr_err("ADF: %s\n", __func__);
-
-	val = REG_READ(MIPI_PORT_CTRL(pipe));
-	REG_WRITE(MIPI_PORT_CTRL(pipe), val | LP_OUTPUT_HOLD);
-	usleep_range(1000, 1500);
-	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_EXIT);
-	usleep_range(2000, 2500);
-	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY);
-	usleep_range(2000, 2500);
-	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x00);
-	usleep_range(2000, 2500);
-	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY);
-	usleep_range(2000, 2500);
-}
-
-static void intel_adf_dsi_enable(struct dsi_pipe *dsi_pipe)
-{
-	struct dsi_config *config = &dsi_pipe->config;
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	int pipe = config->pipe;
-	struct dsi_panel *panel = dsi_pipe->panel;
-	u32 temp;
-
-	pr_err("ADF: %s\n", __func__);
-
-	if (is_cmd_mode(config))
-		REG_WRITE(MIPI_MAX_RETURN_PKT_SIZE(pipe), 8 * 4);
-	else {
-		msleep(20); /* XXX */
-		adf_dpi_send_cmd(dsi_pipe, TURN_ON, DPI_LP_MODE_EN);
-		msleep(100);
-
-		if (panel->ops->power_on)
-			panel->ops->power_on(dsi_pipe);
-
-		/* assert ip_tg_enable signal */
-		temp = REG_READ(MIPI_PORT_CTRL(pipe)) &
-				~LANE_CONFIGURATION_MASK;
-		temp = temp | intel_dsi->port_bits;
-		REG_WRITE(MIPI_PORT_CTRL(pipe), temp | DPI_ENABLE);
-		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
-	}
-
-	if (intel_dsi->backlight_on_delay >= 20)
-		msleep(intel_dsi->backlight_on_delay);
-	else
-		usleep_range(intel_dsi->backlight_on_delay * 1000,
-				(intel_dsi->backlight_on_delay * 1000) + 500);
-
-	intel_enable_backlight(&dsi_pipe->base);
-}
-
 int intel_adf_dsi_soc_power_on(struct dsi_pipe *dsi_pipe)
 {
-	pr_err("ADF: %s\n", __func__);
-
 	/*  cabc disable */
 	vlv_gpio_write(IOSF_PORT_GPIO_NC,
 			PANEL1_VDDEN_GPIONC_9_PCONF0, 0x2000CC00);
@@ -141,154 +78,12 @@ int intel_adf_dsi_soc_power_on(struct dsi_pipe *dsi_pipe)
 
 int intel_adf_dsi_pmic_power_on(struct dsi_pipe *dsi_pipe)
 {
-	pr_err("ADF: %s\n", __func__);
 	intel_soc_pmic_writeb(PMIC_PANEL_EN, 0x01);
 	return 0;
 }
 
-int intel_adf_dsi_pre_enable(struct dsi_pipe *dsi_pipe)
-{
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	struct dsi_config *config = &dsi_pipe->config;
-	struct dsi_panel *panel = dsi_pipe->panel;
-	int pipe = config->pipe;
-	u32 tmp;
-
-	pr_err("ADF: %s\n", __func__);
-
-	/* Panel Enable */
-	if (panel->ops->panel_power_on)
-		panel->ops->panel_power_on(dsi_pipe);
-
-	msleep(intel_dsi->panel_on_delay);
-
-	/* Disable DPOunit clock gating, can stall pipe
-	* and we need DPLL REFA always enabled */
-	tmp = REG_READ(DPLL(pipe));
-	tmp |= DPLL_REFA_CLK_ENABLE_VLV;
-	REG_WRITE(DPLL(pipe), tmp);
-
-	tmp = REG_READ(DSPCLK_GATE_D);
-	tmp |= DPOUNIT_CLOCK_GATE_DISABLE;
-	REG_WRITE(DSPCLK_GATE_D, tmp);
-
-	if (panel->ops->reset)
-		panel->ops->reset(dsi_pipe);
-
-	/* put device in ready state */
-	intel_adf_dsi_device_ready(dsi_pipe);
-
-	msleep(intel_dsi->panel_on_delay);
-
-	if (panel->ops->drv_ic_init)
-		panel->ops->drv_ic_init(dsi_pipe);
-
-	/* Enable port in pre-enable phase itself because as per hw team
-	 * recommendation, port should be enabled befor plane & pipe */
-	intel_adf_dsi_enable(dsi_pipe);
-
-	return 0;
-}
-
-void intel_adf_dsi_pre_disable(struct dsi_pipe *dsi_pipe)
-{
-	struct dsi_config *config = &dsi_pipe->config;
-
-	pr_err("ADF: %s\n", __func__);
-
-	if (is_vid_mode(config)) {
-		/* Send Shutdown command to the panel in LP mode */
-		adf_dpi_send_cmd(dsi_pipe, SHUTDOWN, DPI_LP_MODE_EN);
-		usleep_range(10000, 10500);
-		pr_err("ADF: %s: Sent DPI_SHUTDOWN\n", __func__);
-	}
-}
-
-int intel_adf_dsi_disable(struct dsi_pipe *dsi_pipe)
-{
-	struct dsi_config *config = &dsi_pipe->config;
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	struct dsi_panel *panel = dsi_pipe->panel;
-	int pipe = dsi_pipe->config.pipe;
-	u32 temp;
-
-	pr_err("ADF: %s\n", __func__);
-
-	intel_disable_backlight(&dsi_pipe->base);
-
-	if (intel_dsi->backlight_off_delay >= 20)
-		msleep(intel_dsi->backlight_off_delay);
-	else
-		usleep_range(intel_dsi->backlight_off_delay * 1000,
-				(intel_dsi->backlight_off_delay * 1000) + 500);
-
-	if (is_vid_mode(config)) {
-		/* de-assert ip_tg_enable signal */
-		temp = REG_READ(MIPI_PORT_CTRL(pipe));
-		REG_WRITE(MIPI_PORT_CTRL(pipe), temp & ~DPI_ENABLE);
-		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
-
-		usleep_range(2000, 2500);
-	}
-
-	/* Panel commands can be sent when clock is in LP11 */
-	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x0);
-
-	temp = REG_READ(MIPI_CTRL(pipe));
-	temp &= ~ESCAPE_CLOCK_DIVIDER_MASK;
-	REG_WRITE(MIPI_CTRL(pipe), temp |
-			intel_dsi->escape_clk_div <<
-			ESCAPE_CLOCK_DIVIDER_SHIFT);
-
-	REG_WRITE(MIPI_EOT_DISABLE(pipe), CLOCKSTOP);
-
-	temp = REG_READ(MIPI_DSI_FUNC_PRG(pipe));
-	temp &= ~VID_MODE_FORMAT_MASK;
-	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), temp);
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x1);
-
-	/* if disable packets are sent before sending shutdown packet then in
-	 * some next enable sequence send turn on packet error is observed */
-	if (panel->ops->power_off)
-		panel->ops->power_off(dsi_pipe);
-
-	return 0;
-}
-
-static void intel_adf_dsi_clear_device_ready(struct dsi_pipe *dsi_pipe)
-{
-	int pipe = dsi_pipe->config.pipe;
-	u32 val;
-
-	pr_err("ADF: %s\n", __func__);
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_ENTER);
-	usleep_range(2000, 2500);
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_EXIT);
-	usleep_range(2000, 2500);
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_ENTER);
-	usleep_range(2000, 2500);
-
-	val = REG_READ(MIPI_PORT_CTRL(pipe));
-	REG_WRITE(MIPI_PORT_CTRL(pipe), val & ~LP_OUTPUT_HOLD);
-	usleep_range(1000, 1500);
-
-	if (wait_for(((REG_READ(MIPI_PORT_CTRL(pipe)) & AFE_LATCHOUT)
-					== 0x00000), 30))
-		DRM_ERROR("DSI LP not going Low\n");
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x00);
-	usleep_range(2000, 2500);
-
-	adf_vlv_disable_dsi_pll(&dsi_pipe->config);
-}
-
 int intel_adf_dsi_soc_power_off(struct dsi_pipe *dsi_pipe)
 {
-	pr_err("ADF: %s\n", __func__);
 	vlv_gpio_write(IOSF_PORT_GPIO_NC,
 			PANEL1_BKLTCTL_GPIONC_11_PCONF0, 0x2000CC00);
 	vlv_gpio_write(IOSF_PORT_GPIO_NC,
@@ -299,361 +94,154 @@ int intel_adf_dsi_soc_power_off(struct dsi_pipe *dsi_pipe)
 
 int intel_adf_dsi_pmic_power_off(struct dsi_pipe *dsi_pipe)
 {
-	pr_err("ADF: %s\n", __func__);
 	intel_soc_pmic_writeb(PMIC_PANEL_EN, 0x00);
 	return 0;
 }
 
-int intel_adf_dsi_post_disable(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_pmic_backlight_on(struct dsi_pipe *dsi_pipe)
 {
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	struct dsi_panel *panel = dsi_pipe->panel;
-	u32 val;
-
-	pr_debug("ADF: %s\n", __func__);
-
-	intel_adf_dsi_disable(dsi_pipe);
+	intel_soc_pmic_writeb(PMIC_BKL_EN, 0xFF);
+	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x01);
 
-	intel_adf_dsi_clear_device_ready(dsi_pipe);
+	panel_generic_enable_bklt(dsi_pipe);
+	return 0;
+}
 
-	val = REG_READ(DSPCLK_GATE_D);
-	val &= ~DPOUNIT_CLOCK_GATE_DISABLE;
-	REG_WRITE(DSPCLK_GATE_D, val);
+int intel_adf_dsi_soc_backlight_on(struct dsi_pipe *dsi_pipe)
+{
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000005);
+	udelay(500);
 
-	if (panel->ops->disable_panel_power)
-		panel->ops->disable_panel_power(dsi_pipe);
+	return 0;
+}
 
-	/* Disable Panel */
-	if (panel->ops->panel_power_off)
-		panel->ops->panel_power_off(dsi_pipe);
+int intel_adf_dsi_pmic_backlight_off(struct dsi_pipe *dsi_pipe)
+{
+	panel_generic_disable_bklt(dsi_pipe);
 
-	msleep(intel_dsi->panel_off_delay);
-	msleep(intel_dsi->panel_pwr_cycle_delay);
+	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x00);
+	intel_soc_pmic_writeb(PMIC_BKL_EN, 0x7F);
 
 	return 0;
 }
 
-int intel_adf_dsi_modeset(struct dsi_pipe *dsi_pipe,
-			  struct drm_mode_modeinfo *mode)
+int intel_adf_dsi_soc_backlight_off(struct dsi_pipe *dsi_pipe)
 {
-	pr_err("ADF: %s\n", __func__);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000004);
+	udelay(500);
 	return 0;
 }
 
-int intel_adf_dsi_set_events(struct dsi_pipe *dsi_pipe, u8 event, bool enabled)
+void adf_dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable)
 {
-	return 0;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_hs_mode_enable(pipeline, enable);
 }
 
-void intel_adf_dsi_get_events(struct dsi_pipe *dsi_pipe, u32 *events)
+/* XXX: questionable write helpers */
+int adf_dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
+		const u8 *data, int len)
 {
-	return;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_dcs_write(pipeline, channel, data, len);
 }
 
-void intel_adf_dsi_handle_events(struct dsi_pipe *dsi_pipe, u32 events)
+int adf_dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
+		const u8 *data, int len)
 {
-	return;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_write(pipeline, channel, data, len);
 }
 
-void intel_adf_dsi_pre_post(struct dsi_pipe *dsi_pipe)
+/* XXX: questionable read helpers */
+int adf_dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
+		u8 *buf, int buflen)
 {
-	return;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_dcs_read(pipeline, channel, dcs_cmd,
+		buf, buflen);
 }
 
-/* return txclkesc cycles in terms of divider and duration in us */
-static u16 txclkesc(u32 divider, unsigned int us)
+int adf_dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
+		u8 *reqdata, int reqlen, u8 *buf, int buflen)
 {
-	switch (divider) {
-	case ESCAPE_CLOCK_DIVIDER_1:
-	default:
-		return 20 * us;
-	case ESCAPE_CLOCK_DIVIDER_2:
-		return 10 * us;
-	case ESCAPE_CLOCK_DIVIDER_4:
-		return 5 * us;
-	}
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_read(pipeline, channel, reqdata,
+		reqlen, buf, buflen);
 }
 
-/* return pixels in terms of txbyteclkhs */
-static u16 txbyteclkhs(u16 pixels, int bpp, int lane_count,
-		       u16 burst_mode_ratio)
+static inline int adf_dsi_vc_generic_read_0(struct dsi_pipe *dsi_pipe,
+		int channel, u8 *buf, int buflen)
 {
-	return DIV_ROUND_UP(DIV_ROUND_UP(pixels * bpp * burst_mode_ratio,
-					 8 * 100), lane_count);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_read(pipeline, channel, NULL, 0,
+		buf, buflen);
 }
 
-static void set_dsi_timings(struct dsi_pipe *dsi_pipe,
-			    const struct drm_mode_modeinfo *mode)
+static inline int adf_dsi_vc_generic_read_1(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param, u8 *buf,
+					int buflen)
 {
-	struct dsi_config *config = &dsi_pipe->config;
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	int pipe = config->pipe;
-	unsigned int bpp = config->bpp;
-	unsigned int lane_count = intel_dsi->lane_count;
-	u16 hactive, hfp, hsync, hbp, vfp, vsync, vbp;
-
-	hactive = mode->hdisplay;
-	hfp = mode->hsync_start - mode->hdisplay;
-	hsync = mode->hsync_end - mode->hsync_start;
-	hbp = mode->htotal - mode->hsync_end;
-
-	vfp = mode->vsync_start - mode->vdisplay;
-	vsync = mode->vsync_end - mode->vsync_start;
-	vbp = mode->vtotal - mode->vsync_end;
-
-	/* horizontal values are in terms of high speed byte clock */
-	hactive = txbyteclkhs(hactive, bpp, lane_count,
-			      intel_dsi->burst_mode_ratio);
-	hfp = txbyteclkhs(hfp, bpp, lane_count, intel_dsi->burst_mode_ratio);
-	hsync = txbyteclkhs(hsync, bpp, lane_count,
-			    intel_dsi->burst_mode_ratio);
-	hbp = txbyteclkhs(hbp, bpp, lane_count, intel_dsi->burst_mode_ratio);
-
-	REG_WRITE(MIPI_HACTIVE_AREA_COUNT(pipe), hactive);
-	REG_WRITE(MIPI_HFP_COUNT(pipe), hfp);
-
-	/* meaningful for video mode non-burst sync pulse mode only, can be zero
-	 * for non-burst sync events and burst modes */
-	REG_WRITE(MIPI_HSYNC_PADDING_COUNT(pipe), hsync);
-	REG_WRITE(MIPI_HBP_COUNT(pipe), hbp);
-
-	/* vertical values are in terms of lines */
-	REG_WRITE(MIPI_VFP_COUNT(pipe), vfp);
-	REG_WRITE(MIPI_VSYNC_PADDING_COUNT(pipe), vsync);
-	REG_WRITE(MIPI_VBP_COUNT(pipe), vbp);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_read(pipeline, channel, &param, 1,
+		buf, buflen);
 }
 
-int intel_adf_dsi_prepare(struct dsi_pipe *dsi_pipe,
-			  struct drm_mode_modeinfo *mode)
+static inline int adf_dsi_vc_generic_read_2(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param1, u8 param2,
+					u8 *buf, int buflen)
 {
-	struct dsi_config *config = &dsi_pipe->config;
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	int pipe = config->pipe;
-	unsigned int bpp = config->bpp;
-	u32 val, tmp;
-
-	pr_err("ADF: %s: pipe %d\n", __func__, pipe);
-
-	/* escape clock divider, 20MHz, shared for A and C. device ready must be
-	 * off when doing this! txclkesc? */
-	tmp = REG_READ(MIPI_CTRL(0));
-	tmp &= ~ESCAPE_CLOCK_DIVIDER_MASK;
-	REG_WRITE(MIPI_CTRL(0), tmp | ESCAPE_CLOCK_DIVIDER_1);
-
-	/* read request priority is per pipe */
-	tmp = REG_READ(MIPI_CTRL(pipe));
-	tmp &= ~READ_REQUEST_PRIORITY_MASK;
-	REG_WRITE(MIPI_CTRL(pipe), tmp | READ_REQUEST_PRIORITY_HIGH);
-
-	/* XXX: why here, why like this? handling in irq handler?! */
-	REG_WRITE(MIPI_INTR_STAT(pipe), 0xffffffff);
-	REG_WRITE(MIPI_INTR_EN(pipe), 0xffffffff);
-
-	REG_WRITE(MIPI_DPHY_PARAM(pipe), intel_dsi->dphy_reg);
-
-	REG_WRITE(MIPI_DPI_RESOLUTION(pipe),
-		   mode->vdisplay << VERTICAL_ADDRESS_SHIFT |
-		   mode->hdisplay << HORIZONTAL_ADDRESS_SHIFT);
-
-	set_dsi_timings(dsi_pipe, mode);
-
-	val = intel_dsi->lane_count << DATA_LANES_PRG_REG_SHIFT;
-	if (is_cmd_mode(config)) {
-		val |= intel_dsi->channel << CMD_MODE_CHANNEL_NUMBER_SHIFT;
-		val |= CMD_MODE_DATA_WIDTH_8_BIT; /* XXX */
-	} else {
-		val |= intel_dsi->channel << VID_MODE_CHANNEL_NUMBER_SHIFT;
-
-		/* XXX: cross-check bpp vs. pixel format? */
-		val |= intel_dsi->pixel_format;
-	}
-	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), val);
-
-	/* timeouts for recovery. one frame IIUC. if counter expires, EOT and
-	 * stop state. */
-
-	/*
-	 * In burst mode, value greater than one DPI line Time in byte clock
-	 * (txbyteclkhs) To timeout this timer 1+ of the above said value is
-	 * recommended.
-	 *
-	 * In non-burst mode, Value greater than one DPI frame time in byte
-	 * clock(txbyteclkhs) To timeout this timer 1+ of the above said value
-	 * is recommended.
-	 *
-	 * In DBI only mode, value greater than one DBI frame time in byte
-	 * clock(txbyteclkhs) To timeout this timer 1+ of the above said value
-	 * is recommended.
-	 */
-
-	if (is_vid_mode(config) &&
-	    intel_dsi->video_mode_format == VIDEO_MODE_BURST) {
-		REG_WRITE(MIPI_HS_TX_TIMEOUT(pipe),
-			   txbyteclkhs(mode->htotal, bpp,
-				       intel_dsi->lane_count,
-				       intel_dsi->burst_mode_ratio) + 1);
-	} else {
-		REG_WRITE(MIPI_HS_TX_TIMEOUT(pipe),
-			   txbyteclkhs(mode->vtotal *
-				       mode->htotal,
-				       bpp, intel_dsi->lane_count,
-				       intel_dsi->burst_mode_ratio) + 1);
-	}
-	REG_WRITE(MIPI_LP_RX_TIMEOUT(pipe), intel_dsi->lp_rx_timeout);
-	REG_WRITE(MIPI_TURN_AROUND_TIMEOUT(pipe), intel_dsi->turn_arnd_val);
-	REG_WRITE(MIPI_DEVICE_RESET_TIMER(pipe), intel_dsi->rst_timer_val);
-
-	/* dphy stuff */
-
-	/* in terms of low power clock */
-	REG_WRITE(MIPI_INIT_COUNT(pipe), txclkesc(intel_dsi->escape_clk_div,
-						  100));
-
-	val = 0;
-	if (intel_dsi->eotp_pkt == 0)
-		val |= EOT_DISABLE;
-
-	if (intel_dsi->clock_stop)
-		val |= CLOCKSTOP;
-
-	/* recovery disables */
-	REG_WRITE(MIPI_EOT_DISABLE(pipe), val);
-
-	/* in terms of low power clock */
-	REG_WRITE(MIPI_INIT_COUNT(pipe), intel_dsi->init_count);
-
-	/* in terms of txbyteclkhs. actual high to low switch +
-	 * MIPI_STOP_STATE_STALL * MIPI_LP_BYTECLK.
-	 *
-	 * XXX: write MIPI_STOP_STATE_STALL?
-	 */
-	REG_WRITE(MIPI_HIGH_LOW_SWITCH_COUNT(pipe),
-						intel_dsi->hs_to_lp_count);
-
-	/* XXX: low power clock equivalence in terms of byte clock. the number
-	 * of byte clocks occupied in one low power clock. based on txbyteclkhs
-	 * and txclkesc. txclkesc time / txbyteclk time * (105 +
-	 * MIPI_STOP_STATE_STALL) / 105.???
-	 */
-	REG_WRITE(MIPI_LP_BYTECLK(pipe), intel_dsi->lp_byte_clk);
-
-	/* the bw essential for transmitting 16 long packets containing 252
-	 * bytes meant for dcs write memory command is programmed in this
-	 * register in terms of byte clocks. based on dsi transfer rate and the
-	 * number of lanes configured the time taken to transmit 16 long packets
-	 * in a dsi stream varies. */
-	REG_WRITE(MIPI_DBI_BW_CTRL(pipe), intel_dsi->bw_timer);
-
-	REG_WRITE(MIPI_CLK_LANE_SWITCH_TIME_CNT(pipe),
-		   intel_dsi->clk_lp_to_hs_count << LP_HS_SSW_CNT_SHIFT |
-		   intel_dsi->clk_hs_to_lp_count << HS_LP_PWR_SW_CNT_SHIFT);
-
-	if (is_vid_mode(config))
-		/* Some panels might have resolution which is not a multiple of
-		 * 64 like 1366 x 768. Enable RANDOM resolution support for such
-		 * panels by default */
-		REG_WRITE(MIPI_VIDEO_MODE_FORMAT(pipe),
-				intel_dsi->video_frmt_cfg_bits |
-				intel_dsi->video_mode_format |
-				IP_TG_CONFIG |
-				RANDOM_DPI_DISPLAY_RESOLUTION);
-
-	return 0;
+	u8 req[2] = { param1, param2 };
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_read(pipeline, channel, req, 2,
+		buf, buflen);
 }
 
-int intel_adf_dsi_pre_pll_enable(struct dsi_pipe *dsi_pipe)
+int adf_dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs)
 {
-	struct dsi_config *config = &dsi_pipe->config;
-	struct dsi_panel *panel = dsi_pipe->panel;
-	struct drm_mode_modeinfo mode;
-	int pipe = config->pipe;
-	u32 tmp;
-
-	pr_err("ADF: %s\n", __func__);
-
-	/*
-	 * FIXME:
-	 * get the mode; works for DSI as only one mode
-	 */
-	panel->ops->get_config_mode(&dsi_pipe->config, &mode);
-	intel_adf_dsi_prepare(dsi_pipe, &mode);
-
-	/* program rcomp for compliance, reduce from 50 ohms to 45 ohms
-	 * needed everytime after power gate */
-	vlv_flisdsi_write(0x04, 0x0004);
-
-	/* bandgap reset is needed after everytime we do power gate */
-	band_gap_reset(dsi_pipe);
-
-	/* Disable DPOunit clock gating, can stall pipe */
-	tmp = REG_READ(DPLL(pipe));
-	tmp |= DPLL_RESERVED_BIT;
-	REG_WRITE(DPLL(pipe), tmp);
-
-	tmp = REG_READ(DSPCLK_GATE_D);
-	tmp |= VSUNIT_CLOCK_GATE_DISABLE;
-	REG_WRITE(DSPCLK_GATE_D, tmp);
-
-	adf_vlv_enable_dsi_pll(&dsi_pipe->config);
-
-	intel_adf_dsi_pre_enable(dsi_pipe);
-
-	return 0;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_dpi_send_cmd(pipeline, cmd, hs);
 }
 
-int intel_adf_dsi_pmic_backlight_on(struct dsi_pipe *dsi_pipe)
+inline int adf_dsi_vc_dcs_write_0(struct dsi_pipe *dsi_pipe,
+				int channel, u8 dcs_cmd)
 {
-	intel_soc_pmic_writeb(PMIC_BKL_EN, 0xFF);
-	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x01);
-
-	panel_generic_enable_bklt(dsi_pipe);
-	return 0;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_dcs_write(pipeline, channel, &dcs_cmd, 1);
 }
 
-int intel_adf_dsi_soc_backlight_on(struct dsi_pipe *dsi_pipe)
+inline int adf_dsi_vc_dcs_write_1(struct dsi_pipe *dsi_pipe,
+				int channel, u8 dcs_cmd, u8 param)
 {
-	vlv_gpio_write(IOSF_PORT_GPIO_NC,
-			PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00);
-	vlv_gpio_write(IOSF_PORT_GPIO_NC,
-			PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000005);
-	udelay(500);
-
-	return 0;
+	u8 buf[2] = { dcs_cmd, param };
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_dcs_write(pipeline, channel, buf, 2);
 }
 
-int intel_adf_dsi_pmic_backlight_off(struct dsi_pipe *dsi_pipe)
+inline int adf_dsi_vc_generic_write_0(struct dsi_pipe *dsi_pipe,
+				int channel)
 {
-	panel_generic_disable_bklt(dsi_pipe);
-
-	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x00);
-	intel_soc_pmic_writeb(PMIC_BKL_EN, 0x7F);
-
-	return 0;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_write(pipeline, channel, NULL, 0);
 }
 
-int intel_adf_dsi_soc_backlight_off(struct dsi_pipe *dsi_pipe)
+inline int adf_dsi_vc_generic_write_1(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param)
 {
-	vlv_gpio_write(IOSF_PORT_GPIO_NC,
-			PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00);
-	vlv_gpio_write(IOSF_PORT_GPIO_NC,
-			PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000004);
-	udelay(500);
-	return 0;
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_write(pipeline, channel, &param, 1);
 }
 
-bool intel_adf_dsi_get_hw_state(struct dsi_pipe *dsi_pipe)
+inline int adf_dsi_vc_generic_write_2(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param1, u8 param2)
 {
-	struct dsi_config *config = &dsi_pipe->config;
-	int pipe = config->pipe;
-	u32 port = REG_READ(MIPI_PORT_CTRL(pipe));
-	u32 func = REG_READ(MIPI_DSI_FUNC_PRG(pipe));
-
-	if ((port & DPI_ENABLE) || (func & CMD_MODE_DATA_WIDTH_MASK)) {
-		if (REG_READ(MIPI_DEVICE_READY(pipe)) & DEVICE_READY)
-			return true;
-		else
-			return false;
-	}
-
-	return false;
+	u8 buf[2] = { param1, param2 };
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	return vlv_cmd_vc_generic_write(pipeline, channel, buf, 2);
 }
diff --git a/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c b/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
index 06b530d..0835f3b 100644
--- a/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
+++ b/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
@@ -16,36 +16,19 @@
 
 #include <drm/drm_mode.h>
 #include <drm/i915_drm.h>
-
+#include <drm/i915_adf.h>
+#include <intel_adf_device.h>
 #include <core/intel_dc_config.h>
-#include <core/vlv/vlv_dc_regs.h>
-#include <core/vlv/vlv_dc_hw.h>
-#include <core/vlv/vlv_dc_config.h>
 #include <core/common/dsi/dsi_pipe.h>
 #include <core/common/dsi/dsi_config.h>
 #include <core/common/intel_gen_backlight.h>
+/* FIXME: remove this once gpio calls are abstracted */
 #include <core/vlv/vlv_dc_config.h>
-#include <core/vlv/vlv_dpst.h>
-#include <intel_adf_device.h>
 #include "dsi_vbt.h"
 #include "intel_dsi.h"
+#include "intel_dsi_cmd.h"
 
-static void dsi_pipe_suspend(struct intel_dc_component *component)
-{
-	struct intel_pipe *pipe = to_intel_pipe(component);
-	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
-
-	/*power gate the power rail directly*/
-	dsi_pipe->ops.power_off(dsi_pipe);
-}
-
-static void dsi_pipe_resume(struct intel_dc_component *component)
-{
-	struct intel_pipe *pipe = to_intel_pipe(component);
-	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
-
-	dsi_pipe->ops.power_on(dsi_pipe);
-}
+#define TURN_ON (1 << 1)
 
 #ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
 static int dsi_set_brightness(struct intel_pipe *pipe, int level)
@@ -122,6 +105,22 @@ static void dsi_get_modelist(struct intel_pipe *pipe,
 	mutex_unlock(&config->ctx_lock);
 }
 
+static void dsi_get_current_mode(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+	bool lock;
+
+	if (!mode)
+		return;
+
+	lock = mutex_trylock(&config->ctx_lock);
+	dsi_pipe->panel->ops->get_config_mode(&dsi_pipe->config,
+				mode);
+	if (lock)
+		mutex_unlock(&config->ctx_lock);
+}
 static void dsi_get_preferred_mode(struct intel_pipe *pipe,
 		struct drm_mode_modeinfo **mode)
 {
@@ -135,8 +134,8 @@ static void dsi_get_preferred_mode(struct intel_pipe *pipe,
 	if (lock)
 		mutex_unlock(&config->ctx_lock);
 
-	pr_err("ADF: %s: Preferred Mode = %dx%d @%d\n", __func__,
-	       (*mode)->hdisplay, (*mode)->vdisplay, (*mode)->vrefresh);
+	pr_debug("ADF: %s: Preferred Mode = %dx%d @%d\n", __func__,
+		(*mode)->hdisplay, (*mode)->vdisplay, (*mode)->vrefresh);
 }
 
 static bool dsi_is_screen_connected(struct intel_pipe *pipe)
@@ -144,6 +143,180 @@ static bool dsi_is_screen_connected(struct intel_pipe *pipe)
 	return true;
 }
 
+static int dsi_display_on(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int err = 0;
+	bool need_free_mem = false;
+
+	/*
+	 * program rcomp for compliance, reduce from 50 ohms to 45 ohms
+	 * needed everytime after power gate
+	 */
+	vlv_flisdsi_write(0x04, 0x0004);
+
+	/* bandgap reset is needed after everytime we do power gate */
+	band_gap_reset(dsi_pipe);
+
+	/* Panel Enable */
+	if (panel->ops->panel_power_on)
+		panel->ops->panel_power_on(dsi_pipe);
+
+	msleep(intel_dsi->panel_on_delay);
+
+	if (panel->ops->reset)
+		panel->ops->reset(dsi_pipe);
+
+	/* get the configured mode */
+	if (mode == NULL) {
+		need_free_mem = true;
+		mode = kzalloc(sizeof(struct drm_mode_modeinfo), GFP_KERNEL);
+		if (mode == NULL) {
+			pr_err("%s: mem alloc for mode failed\n", __func__);
+			err = -ENOMEM;
+			goto out;
+		}
+		dsi_pipe->panel->ops->get_config_mode(&dsi_pipe->config, mode);
+	}
+
+	/* FIXME: compare if mode passed is same as current mode */
+
+	/*
+	 * DSI is a special beast that requires 3 calls to pipeline
+	 * 1) setup pll : dsi_prepare_on
+	 * 2) setup port: dsi_pre_display_on
+	 * 3) enable port, pipe, plane etc : display_on
+	 * this is because of the panel calls needed to be performed
+	 * between these operations and hence we return to common code
+	 * to make these calls.
+	 */
+
+	/* FIXME: plan to remove config as very few params inside it are used */
+	pipeline->params.dsi.dsi_config = &dsi_pipe->config;
+
+	err = vlv_dsi_prepare_on(pipeline, mode);
+	if (err != 0) {
+		pr_err("%s:dsi prepare pipeline on failed !!!\n", __func__);
+		/* recovery ? */
+		goto out;
+	}
+
+	if (panel->ops->drv_ic_init)
+		panel->ops->drv_ic_init(dsi_pipe);
+
+	err = vlv_dsi_pre_pipeline_on(pipeline, mode);
+	if (err != 0) {
+		pr_err("%s: dsi pre pipeline on failed !!!\n", __func__);
+		/* recovery ? */
+		goto out;
+	}
+
+	if (vlv_is_vid_mode(pipeline)) {
+		msleep(20); /* XXX */
+		adf_dpi_send_cmd(dsi_pipe, TURN_ON, DPI_LP_MODE_EN);
+		msleep(100);
+
+		if (panel->ops->power_on)
+			panel->ops->power_on(dsi_pipe);
+	}
+
+	err = vlv_pipeline_on(pipeline, mode);
+	if (err != 0) {
+		pr_err("%s: dsi pipeline on failed !!!\n", __func__);
+		/* recovery ? */
+		goto out;
+	}
+
+	if (intel_dsi->backlight_on_delay >= 20)
+		msleep(intel_dsi->backlight_on_delay);
+	else
+		usleep_range(intel_dsi->backlight_on_delay * 1000,
+				(intel_dsi->backlight_on_delay * 1000) + 500);
+
+	intel_enable_backlight(&dsi_pipe->base);
+
+	/* enable vsyncs */
+	pipe->ops->set_event(pipe, INTEL_PIPE_EVENT_VSYNC, true);
+
+	dsi_pipe->dpms_state = DRM_MODE_DPMS_ON;
+
+out:
+	if (need_free_mem)
+		kfree(mode);
+
+	return err;
+}
+
+static int dsi_display_off(struct intel_pipe *pipe)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	int err = 0;
+
+	/* check harwdare state before disabling */
+	if (!vlv_can_be_disabled(pipeline)) {
+		pr_err("%s: DSI device already disabled\n", __func__);
+		goto out;
+	}
+
+	intel_disable_backlight(&dsi_pipe->base);
+
+	if (intel_dsi->backlight_off_delay >= 20)
+		msleep(intel_dsi->backlight_off_delay);
+	else
+		usleep_range(intel_dsi->backlight_off_delay * 1000,
+				(intel_dsi->backlight_off_delay * 1000) + 500);
+
+
+	if (vlv_is_vid_mode(pipeline)) {
+		/* Send Shutdown command to the panel in LP mode */
+		adf_dpi_send_cmd(dsi_pipe, SHUTDOWN, DPI_LP_MODE_EN);
+		usleep_range(10000, 10500);
+		pr_err("ADF: %s: Sent DPI_SHUTDOWN\n", __func__);
+	}
+
+	/* disable vsyncs */
+	pipe->ops->set_event(pipe, INTEL_PIPE_EVENT_VSYNC, false);
+
+	err = vlv_pipeline_off(pipeline);
+
+	if (err != 0) {
+		pr_err("%s: DSI pipeline off failed\n", __func__);
+		/* FIXME: error recovery ??? */
+		goto out;
+	}
+
+	/*
+	 * if disable packets are sent before sending shutdown packet then in
+	 * some next enable sequence send turn on packet error is observed
+	 */
+	if (panel->ops->power_off)
+		panel->ops->power_off(dsi_pipe);
+
+	vlv_post_pipeline_off(pipeline);
+
+	if (panel->ops->disable_panel_power)
+		panel->ops->disable_panel_power(dsi_pipe);
+
+	/* Disable Panel */
+	if (panel->ops->panel_power_off)
+		panel->ops->panel_power_off(dsi_pipe);
+
+	msleep(intel_dsi->panel_off_delay);
+	msleep(intel_dsi->panel_pwr_cycle_delay);
+
+	dsi_pipe->dpms_state = DRM_MODE_DPMS_OFF;
+
+out:
+	return err;
+}
+
 static int dsi_dpms(struct intel_pipe *pipe, u8 state)
 {
 	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
@@ -171,10 +344,10 @@ static int dsi_dpms(struct intel_pipe *pipe, u8 state)
 	switch (state) {
 	case DRM_MODE_DPMS_ON:
 		intel_adf_display_rpm_get();
-		err = vlv_display_on(pipe);
+		err = dsi_display_on(pipe, NULL);
 		break;
 	case DRM_MODE_DPMS_OFF:
-		err = vlv_display_off(pipe);
+		err = dsi_display_off(pipe);
 		intel_adf_display_rpm_put();
 		break;
 	case DRM_MODE_DPMS_STANDBY:
@@ -211,8 +384,8 @@ static int dsi_modeset(struct intel_pipe *pipe,
 	}
 
 	mutex_lock(&config->ctx_lock);
-	vlv_display_off(pipe);
-	vlv_display_on(pipe);
+	dsi_display_off(pipe);
+	dsi_display_on(pipe, mode);
 	mutex_unlock(&config->ctx_lock);
 
 	return err;
@@ -224,7 +397,7 @@ static int dsi_get_screen_size(struct intel_pipe *pipe,
 	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
 	struct dsi_panel *panel = dsi_pipe->panel;
 	struct panel_info pi;
-	int err;
+	int err = 0;
 
 	if (!panel || !panel->ops || !panel->ops->get_panel_info) {
 		pr_err("%s: failed to get panel info\n", __func__);
@@ -237,61 +410,25 @@ static int dsi_get_screen_size(struct intel_pipe *pipe,
 	*width_mm = pi.width_mm;
 	*height_mm = pi.height_mm;
 
-	return 0;
 out_err:
 	return err;
 }
 
-static unsigned int usecs_to_scanlines(struct drm_display_mode *hwmode,
-				       unsigned int usecs)
-{
-	/* paranoia */
-	if (!hwmode->crtc_htotal)
-		return 1;
-
-	return DIV_ROUND_UP(usecs * hwmode->clock,
-			    1000 * hwmode->crtc_htotal);
-}
-
-static void intel_pipe_vblank_evade(struct intel_pipe *intel_pipe)
-{
-	u32 val;
-	struct dsi_pipe *dsi_pipe = to_dsi_pipe(intel_pipe);
-	struct drm_display_mode *hwmode = &dsi_pipe->config.vbt_mode;
-	int pipe = intel_pipe->base.idx;
-	/* FIXME needs to be calibrated sensibly */
-	u32 min = hwmode->crtc_vdisplay - usecs_to_scanlines(hwmode, 50);
-	u32 max = hwmode->crtc_vdisplay - 1;
-	long timeout = msecs_to_jiffies(3);
-
-	local_irq_disable();
-	val = REG_READ(PIPEDSL(pipe));
-	local_irq_enable();
-
-	while (val >= min && val <= max && timeout > 0) {
-
-		vlv_wait_for_vblank(pipe);
-		local_irq_disable();
-		val = REG_READ(PIPEDSL(pipe));
-		local_irq_enable();
-		intel_pipe->status.wait_vblank = false;
-	}
-
-	if (val >= min && val <= max)
-		pr_warn("ADF: Page flipping close to vblank start (DSL=%u, VBL=%u)\n",
-			 val, hwmode->crtc_vdisplay);
-}
 
 static void dsi_on_post(struct intel_pipe *pipe)
 {
 	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	int num_planes = 0;
+
+	num_planes = vlv_num_planes_enabled(pipeline);
 
 	/* Enable maxfifo if required */
-	if (!pipe->status.maxfifo_enabled &&
-				(vlv_num_planes_enabled(pipe) == 1)) {
-		REG_WRITE(FW_BLC_SELF_VLV, FW_CSPWRDWNEN);
+	if (!pipe->status.maxfifo_enabled && (num_planes == 1)) {
+		vlv_update_maxfifo_status(pipeline, true);
 		pipe->status.maxfifo_enabled = true;
 	}
+
 	if (dsi_pipe->ops.on_post)
 		dsi_pipe->ops.on_post(dsi_pipe);
 }
@@ -299,6 +436,8 @@ static void dsi_on_post(struct intel_pipe *pipe)
 static void dsi_pre_validate(struct intel_pipe *pipe,
 		struct intel_adf_post_custom_data *custom)
 {
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
 	struct intel_adf_config *custom_config;
 	u8 i = 0, planes_enabled = 0;
 
@@ -312,7 +451,8 @@ static void dsi_pre_validate(struct intel_pipe *pipe,
 
 	/* If we are moving to multiple plane then disable maxfifo */
 	if (planes_enabled > 1 && pipe->status.maxfifo_enabled) {
-		REG_WRITE(FW_BLC_SELF_VLV, ~FW_CSPWRDWNEN);
+		vlv_update_maxfifo_status(pipeline, false);
+		/* FIXME: move these variables out of intel_pipe */
 		pipe->status.maxfifo_enabled = false;
 		pipe->status.wait_vblank = true;
 		pipe->status.vsync_counter =
@@ -323,15 +463,17 @@ static void dsi_pre_validate(struct intel_pipe *pipe,
 static void dsi_pre_post(struct intel_pipe *pipe)
 {
 	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+	struct drm_mode_modeinfo mode;
 
 	if (pipe->status.wait_vblank && pipe->status.vsync_counter ==
 			pipe->ops->get_vsync_counter(pipe, 0)) {
-		vlv_wait_for_vblank(pipe->base.idx);
+		vlv_wait_for_vblank(pipeline);
 		pipe->status.wait_vblank = false;
 	}
-	if (dsi_pipe->ops.pre_post)
-		dsi_pipe->ops.pre_post(dsi_pipe);
-	intel_pipe_vblank_evade(pipe);
+
+	pipe->ops->get_current_mode(pipe, &mode);
+	vlv_evade_vblank(pipeline, &mode, &pipe->status.wait_vblank);
 }
 
 static u32 dsi_get_supported_events(struct intel_pipe *pipe)
@@ -342,55 +484,9 @@ static u32 dsi_get_supported_events(struct intel_pipe *pipe)
 int dsi_set_event(struct intel_pipe *pipe, u16 event, bool enabled)
 {
 	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->pipeline;
 
-	u32 pipestat, value = 0;
-	u8 idx = pipe->base.idx;
-	value = REG_READ(PIPESTAT(idx));
-
-	if (enabled)
-		pipestat = 0;
-	else {
-		if (event == INTEL_PIPE_EVENT_VSYNC) {
-			pr_debug("ADF: %s: Not allowing VSYNC OFF\n", __func__);
-			return 0;
-		} else
-			pipestat = 0xFFFFFFFF;
-	}
-
-	switch (event) {
-	case INTEL_PIPE_EVENT_SPRITE2_FLIP:
-		enabled ? (pipestat |= SPRITE2_FLIP_DONE_EN) :
-			(pipestat &= ~SPRITE2_FLIP_DONE_EN);
-		break;
-	case INTEL_PIPE_EVENT_SPRITE1_FLIP:
-		enabled ? (pipestat |= SPRITE1_FLIP_DONE_EN) :
-			(pipestat &= ~SPRITE1_FLIP_DONE_EN);
-		break;
-	case INTEL_PIPE_EVENT_PRIMARY_FLIP:
-		enabled ? (pipestat |= PLANE_FLIP_DONE_EN) :
-			(pipestat &= ~PLANE_FLIP_DONE_EN);
-		break;
-	case INTEL_PIPE_EVENT_VSYNC:
-		enabled ? (pipestat |= VSYNC_EN) : (pipestat &= ~VSYNC_EN);
-		break;
-	case INTEL_PIPE_EVENT_DPST:
-		enabled ? (pipestat |= DPST_EVENT_EN) :
-			(pipestat &= ~DPST_EVENT_EN);
-		break;
-	}
-
-	if (enabled)
-		/* Enable interrupts */
-		REG_WRITE(PIPESTAT(idx), value | pipestat);
-	else
-		/* Disable interrupts */
-		REG_WRITE(PIPESTAT(idx), value & pipestat);
-
-	/* In case specififc interrupts for DSI like TE */
-	if (dsi_pipe->ops.set_event)
-		return dsi_pipe->ops.set_event(dsi_pipe, event, enabled);
-
-	return 0;
+	return vlv_set_event(pipeline, event, enabled);
 }
 
 /**
@@ -404,74 +500,9 @@ static u32 vsync_counter;
 static void dsi_get_events(struct intel_pipe *pipe, u32 *events)
 {
 	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
-	u8 idx = pipe->base.idx;
-
-	u32 pipestat = 0, value = 0;
-	pipestat = REG_READ(PIPESTAT(idx));
-
-	*events = 0;
-
-	pr_debug("%s: PIPESTAT = 0x%x\n", __func__, pipestat);
-
-	/* FIFO under run */
-	if (pipestat & FIFO_UNDERRUN_STAT) {
-		*events |= INTEL_PIPE_EVENT_UNDERRUN;
-		value |= FIFO_UNDERRUN_STAT;
-	}
-
-	/* Sprite B Flip done interrupt */
-	if (pipestat & SPRITE2_FLIP_DONE_STAT) {
-		*events |= INTEL_PIPE_EVENT_SPRITE2_FLIP;
-		value |= SPRITE2_FLIP_DONE_STAT;
-		/* program the pre-calculated ddl value */
-		if (pipe->regs.sp2_ddl) {
-			REG_WRITE_BITS(VLV_DDL(idx), pipe->regs.sp2_ddl,
-					pipe->regs.sp2_ddl_mask);
-			pipe->regs.sp2_ddl = 0;
-		}
-	}
-
-	/* Sprite A Flip done interrupt */
-	if (pipestat & SPRITE1_FLIP_DONE_STAT) {
-		*events |= INTEL_PIPE_EVENT_SPRITE1_FLIP;
-		value |= SPRITE2_FLIP_DONE_STAT;
-		/* program the pre-calculated ddl value */
-		if (pipe->regs.sp1_ddl) {
-			REG_WRITE_BITS(VLV_DDL(idx), pipe->regs.sp1_ddl,
-					pipe->regs.sp1_ddl_mask);
-			pipe->regs.sp1_ddl = 0;
-		}
-	}
-
-	/* Plane A Flip done interrupt */
-	if (pipestat & PLANE_FLIP_DONE_STAT) {
-		*events |= INTEL_PIPE_EVENT_PRIMARY_FLIP;
-		value |= PLANE_FLIP_DONE_STAT;
-		/* program the pre-calculated ddl value */
-		if (pipe->regs.pri_ddl) {
-			REG_WRITE_BITS(VLV_DDL(idx), pipe->regs.pri_ddl,
-					pipe->regs.pri_ddl_mask);
-			pipe->regs.pri_ddl = 0;
-		}
-	}
-
-	/* Vsync interrupt */
-	if (pipestat & VSYNC_STAT) {
-		*events |= INTEL_PIPE_EVENT_VSYNC;
-		value |= VSYNC_STAT;
-	}
-
-	/* DPST event */
-	if (pipestat & DPST_EVENT_STAT) {
-		*events |= INTEL_PIPE_EVENT_DPST;
-		value |= DPST_EVENT_STAT;
-	}
+	struct intel_pipeline *pipeline = dsi_pipe->pipeline;
 
-	/* Clear the 1st level interrupt. */
-	REG_WRITE(PIPESTAT(idx), pipestat | value);
-
-	if (dsi_pipe->ops.get_events)
-		dsi_pipe->ops.get_events(dsi_pipe, events);
+	vlv_get_event(pipeline, events);
 
 	/**
 	 * FIXME: should use hardware vsync counter.
@@ -487,11 +518,10 @@ u32 dsi_get_vsync_counter(struct intel_pipe *pipe, u32 interval)
 	u32 count;
 	u32 max_count_mask = VSYNC_COUNT_MAX_MASK;
 
-	count = vsync_counter;
+	count = pipe->vsync_counter;
 	count |= (~max_count_mask);
 	count += interval;
 	count &= max_count_mask;
-
 	pr_debug("%s: count = %#x\n", __func__, count);
 
 	return count;
@@ -506,16 +536,31 @@ static void dsi_handle_events(struct intel_pipe *pipe, u32 events)
 		dsi_pipe->ops.handle_events(dsi_pipe, events);
 }
 
+static long dsi_pipe_dpst_context(struct intel_pipe *pipe, unsigned long arg)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->pipeline;
+	long val = vlv_dpst_context(pipeline, arg);
+
+	return val;
+}
+
+static long dsi_pipe_dpst_irq_handler(struct intel_pipe *pipe)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct intel_pipeline *pipeline = dsi_pipe->base.pipeline;
+
+	return vlv_dpst_irq_handler(pipeline);
+
+}
+
 static struct intel_pipe_ops dsi_base_ops = {
-	.base = {
-		.suspend = dsi_pipe_suspend,
-		.resume = dsi_pipe_resume,
-	},
 	.hw_init = dsi_pipe_hw_init,
 	.hw_deinit = dsi_pipe_hw_deinit,
 	.get_preferred_mode = dsi_get_preferred_mode,
 	.is_screen_connected = dsi_is_screen_connected,
 	.get_modelist = dsi_get_modelist,
+	.get_current_mode = dsi_get_current_mode,
 	.dpms = dsi_dpms,
 	.modeset = dsi_modeset,
 	.get_screen_size = dsi_get_screen_size,
@@ -527,6 +572,8 @@ static struct intel_pipe_ops dsi_base_ops = {
 	.get_events = dsi_get_events,
 	.get_vsync_counter = dsi_get_vsync_counter,
 	.handle_events = dsi_handle_events,
+	.dpst_context = dsi_pipe_dpst_context,
+	.dpst_irq_handler = dsi_pipe_dpst_irq_handler,
 #ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
 	.set_brightness = dsi_set_brightness,
 #endif
@@ -539,7 +586,8 @@ void dsi_pipe_destroy(struct dsi_pipe *pipe)
 }
 
 int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
-	struct intel_plane *primary_plane, u8 idx)
+	struct intel_plane *primary_plane, u8 idx,
+	struct intel_pipeline *pipeline)
 {
 	struct dsi_panel *panel;
 	struct dsi_vbt *vbt;
@@ -551,12 +599,12 @@ int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 		return -EINVAL;
 
 	memset(pipe, 0, sizeof(struct dsi_pipe));
+	pipe->base.pipeline = pipeline;
 
 	/*get panel*/
 	panel = get_dsi_panel_by_id(MIPI_DSI_GENERIC_PANEL_ID);
 	if (!panel)
 		return -ENODEV;
-
 	/*
 	 * For GEN DSI implementation of generic driver, we need this call
 	 * before any other panel ops
@@ -587,8 +635,7 @@ int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 		 */
 		if (vbt->config->pwm_blc) {
 			/* using SOC PWM */
-			panel->ops->panel_power_on =
-					intel_adf_dsi_soc_power_on;
+			panel->ops->panel_power_on = intel_adf_dsi_soc_power_on;
 			panel->ops->panel_power_off =
 					intel_adf_dsi_soc_power_off;
 			panel->ops->enable_backlight =
@@ -613,18 +660,7 @@ int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 	if (err)
 		goto err;
 
-	/*init dsi interface ops*/
-	pipe->ops.power_on = intel_adf_dsi_pre_pll_enable;
-	pipe->ops.pre_power_off = intel_adf_dsi_pre_disable;
-	pipe->ops.power_off = intel_adf_dsi_post_disable;
-	pipe->ops.mode_set = intel_adf_dsi_modeset;
-	pipe->ops.pre_post = intel_adf_dsi_pre_post;
-	pipe->ops.set_event = intel_adf_dsi_set_events;
-	pipe->ops.get_events = intel_adf_dsi_get_events;
-	pipe->ops.handle_events = intel_adf_dsi_handle_events;
-	pipe->ops.get_hw_state = intel_adf_dsi_get_hw_state;
 	pipe->dpms_state = DRM_MODE_DPMS_OFF;
-
 	pipe->panel = panel;
 
 	err = intel_pipe_init(&pipe->base, dev, idx, true, INTEL_PIPE_DSI,
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
index 7aa0ca9..a07b3ed 100644
--- a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
@@ -36,79 +36,33 @@
 #define DPI_LP_MODE_EN	false
 #define DPI_HS_MODE_EN	true
 
+void band_gap_reset(struct dsi_pipe *dsi_pipe);
 void adf_dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable);
 
 int adf_dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
-		     const u8 *data, int len);
+		const u8 *data, int len);
 
 int adf_dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
-			 const u8 *data, int len);
+			const u8 *data, int len);
 
 int adf_dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
-		    u8 *buf, int buflen);
+		u8 *buf, int buflen);
 
 int adf_dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
 			u8 *reqdata, int reqlen, u8 *buf, int buflen);
 
 int adf_dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs);
-void adf_wait_for_dsi_fifo_empty(struct dsi_pipe *dsi_pipe);
 
-/* XXX: questionable write helpers */
-static inline int adf_dsi_vc_dcs_write_0(struct dsi_pipe *dsi_pipe,
-				     int channel, u8 dcs_cmd)
-{
-	return adf_dsi_vc_dcs_write(dsi_pipe, channel, &dcs_cmd, 1);
-}
-
-static inline int adf_dsi_vc_dcs_write_1(struct dsi_pipe *dsi_pipe,
-				     int channel, u8 dcs_cmd, u8 param)
-{
-	u8 buf[2] = { dcs_cmd, param };
-	return adf_dsi_vc_dcs_write(dsi_pipe, channel, buf, 2);
-}
-
-static inline int adf_dsi_vc_generic_write_0(struct dsi_pipe *dsi_pipe,
-					 int channel)
-{
-	return adf_dsi_vc_generic_write(dsi_pipe, channel, NULL, 0);
-}
-
-static inline int adf_dsi_vc_generic_write_1(struct dsi_pipe *dsi_pipe,
-					 int channel, u8 param)
-{
-	return adf_dsi_vc_generic_write(dsi_pipe, channel, &param, 1);
-}
-
-static inline int adf_dsi_vc_generic_write_2(struct dsi_pipe *dsi_pipe,
-					 int channel, u8 param1, u8 param2)
-{
-	u8 buf[2] = { param1, param2 };
-	return adf_dsi_vc_generic_write(dsi_pipe, channel, buf, 2);
-}
-
-/* XXX: questionable read helpers */
-static inline int adf_dsi_vc_generic_read_0(struct dsi_pipe *dsi_pipe,
-					int channel, u8 *buf, int buflen)
-{
-	return adf_dsi_vc_generic_read(dsi_pipe, channel, NULL, 0, buf, buflen);
-}
-
-static inline int adf_dsi_vc_generic_read_1(struct dsi_pipe *dsi_pipe,
-					int channel, u8 param, u8 *buf,
-					int buflen)
-{
-	return adf_dsi_vc_generic_read(dsi_pipe, channel, &param,
-				       1, buf, buflen);
-}
-
-static inline int adf_dsi_vc_generic_read_2(struct dsi_pipe *dsi_pipe,
-					int channel, u8 param1, u8 param2,
-					u8 *buf, int buflen)
-{
-	u8 req[2] = { param1, param2 };
-
-	return adf_dsi_vc_generic_read(dsi_pipe, channel, req, 2, buf, buflen);
-}
 
+inline int adf_dsi_vc_dcs_write_0(struct dsi_pipe *dsi_pipe,
+					int channel, u8 dcs_cmd);
+inline int adf_dsi_vc_dcs_write_1(struct dsi_pipe *dsi_pipe,
+					int channel, u8 dcs_cmd, u8 param);
+inline int adf_dsi_vc_generic_write_0(struct dsi_pipe *dsi_pipe,
+					int channel);
+inline int adf_dsi_vc_generic_write_1(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param);
+inline int adf_dsi_vc_generic_write_2(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param1, u8 param2);
 
 #endif /* _INTEL_DSI_DSI_H */
diff --git a/drivers/video/adf/intel/core/intel_dc_config.c b/drivers/video/adf/intel/core/intel_dc_config.c
index 4a558e5..a2064ea 100644
--- a/drivers/video/adf/intel/core/intel_dc_config.c
+++ b/drivers/video/adf/intel/core/intel_dc_config.c
@@ -14,6 +14,7 @@
 #include <linux/pci.h>
 
 #include "core/intel_dc_config.h"
+#include "core/intel_platform_config.h"
 
 static const struct intel_dc_config_entry g_dc_configs[] = {
 	{
diff --git a/drivers/video/adf/intel/core/vlv/Makefile b/drivers/video/adf/intel/core/vlv/Makefile
index 1e83ce7..243d3ca 100644
--- a/drivers/video/adf/intel/core/vlv/Makefile
+++ b/drivers/video/adf/intel/core/vlv/Makefile
@@ -5,10 +5,10 @@ ccflags-y := -Idrivers/staging/ -Iinclude/adf -Iinclude/uapi/adf -Idrivers/video
 obj-y := vlv_dc_config.o \
 	vlv_pri_plane.o \
 	vlv_sp_plane.o \
-	vlv_mode_set.o \
 	vlv_pipe.o \
 	vlv_pll.o \
 	vlv_dsi_pll.o \
 	vlv_pm.o \
 	vlv_dsi_port.o \
-	vlv_dsi_port_cmd.o
+	vlv_dsi_port_cmd.o \
+	vlv_pipeline.o
diff --git a/drivers/video/adf/intel/core/vlv/vlv_dc_config.c b/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
index f0fe2c3..5f2b2bb 100644
--- a/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
+++ b/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
@@ -36,24 +36,6 @@ static const struct intel_dc_attachment vlv_allowed_attachments[] = {
 	}
 };
 
-void vlv_update_plane_status(struct intel_pipe *pipe, int plane, bool enabled)
-{
-	pipe->status.plane_status[pipe->base.idx][plane] = enabled;
-}
-
-int vlv_num_planes_enabled(struct intel_pipe *pipe)
-{
-	int cnt = 0;
-	int i, j;
-
-	for (i = 0; i < MAX_PIPES; i++)
-		for (j = 0; j < VLV_MAX_PLANES; j++)
-			if (pipe->status.plane_status[i][j])
-				cnt++;
-
-	return cnt;
-}
-
 void vlv_dc_config_destroy(struct intel_dc_config *config)
 {
 	struct vlv_dc_config *vlv_config = to_vlv_dc_config(config);
@@ -62,25 +44,25 @@ void vlv_dc_config_destroy(struct intel_dc_config *config)
 	struct dsi_pipe *dsi_pipe;
 	int pipe;
 
-	if (!config)
+	if (!config || !vlv_config)
 		return;
 
-	for (pipe = 0; pipe < MAX_PIPES; pipe++) {
-		if (vlv_config->vdisp[pipe].type == INTEL_PIPE_DSI) {
-			dsi_pipe = &vlv_config->vdisp[pipe].pipe.dsi;
+	for (pipe = 0; pipe < vlv_config->max_pipes; pipe++) {
+		if (vlv_config->pipeline[pipe].type == INTEL_PIPE_DSI) {
+			dsi_pipe = &vlv_config->pipeline[pipe].gen.dsi;
 			dsi_pipe_destroy(dsi_pipe);
-		} else if (vlv_config->vdisp[pipe].type == INTEL_PIPE_HDMI) {
+		} else if (vlv_config->pipeline[pipe].type == INTEL_PIPE_HDMI) {
 			/* FIXME:
 			 * HDMI Pipe deinit
 			 */
 		} else
 			pr_err("ADF: %s: Unknown pipe type\n", __func__);
 
-		pplane = &vlv_config->vdisp[pipe].pplane;
+		pplane = &vlv_config->pipeline[pipe].pplane;
 		vlv_pri_plane_destroy(pplane);
-		splane = &vlv_config->vdisp[pipe].splane[0];
+		splane = &vlv_config->pipeline[pipe].splane[0];
 		vlv_sp_plane_destroy(splane);
-		splane = &vlv_config->vdisp[pipe].splane[1];
+		splane = &vlv_config->pipeline[pipe].splane[1];
 		vlv_sp_plane_destroy(splane);
 	}
 
@@ -92,48 +74,114 @@ void vlv_dc_config_destroy(struct intel_dc_config *config)
 	return;
 }
 
-static int vlv_initialize_disp(struct vlv_dc_config *vlv_config, int pipe,
-		enum intel_pipe_type type)
+static int vlv_display_encoder_init(struct vlv_dc_config *vlv_config, int pipe)
+{
+	struct dsi_pipe *dsi_pipe = NULL;
+	struct intel_pipeline *intel_pipeline;
+	struct vlv_pipeline *disp = &vlv_config->pipeline[pipe];
+	int err;
+
+	/* Initialize interface PIPE */
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_pipe = &disp->gen.dsi;
+		intel_pipeline = &disp->base;
+		err = dsi_pipe_init(dsi_pipe, vlv_config->base.dev,
+				&disp->pplane.base, pipe, intel_pipeline);
+		if (err) {
+			dev_err(vlv_config->base.dev,
+				"%s: failed to init pipe(%d)\n", __func__, err);
+			return err;
+		}
+
+		intel_dc_config_add_pipe(&vlv_config->base,
+					&dsi_pipe->base, pipe);
+
+		/* FIXME: uncomment when dpst is enabled with redesign*/
+		/* vlv_dpst_init(&config->base);*/
+
+		disp->dpst = &vlv_config->dpst;
+	} else {
+		pr_err("ADF: %s: unsupported pipe type = %d\n",
+				__func__, disp->type);
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int vlv_initialize_port(struct vlv_dc_config *vlv_config,
+			int pipe, int type)
+{
+	struct vlv_dsi_port *dsi_port = NULL;
+	struct vlv_pipeline *disp = NULL;
+
+	disp = &vlv_config->pipeline[pipe];
+	switch (type) {
+	case INTEL_PIPE_DSI:
+		dsi_port = &disp->port.dsi_port;
+		vlv_dsi_port_init(dsi_port, PORT_A, pipe);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int vlv_initialize_disp(struct vlv_dc_config *vlv_config,
+			int pipe, int type)
 {
 	struct vlv_pri_plane *pplane;
 	struct vlv_sp_plane *splane;
-	struct dsi_pipe *dsi_pipe;
-	struct intel_plane *intel_plane;
-	struct intel_pipe *intel_pipe;
-	int err = 0;
+	struct vlv_pipeline *disp = NULL;
+	struct vlv_pipe *vlv_pipe = NULL;
+	struct vlv_pm *vlv_pm = NULL;
+	struct vlv_pll *pll = NULL;
+	int err;
 
-	if (pipe > MAX_PIPES) {
+	if (!vlv_config) {
+		dev_err(vlv_config->base.dev, "%s:invalid config", __func__);
+		return -EINVAL;
+	}
+
+	if (pipe >= vlv_config->max_pipes) {
 		dev_err(vlv_config->base.dev, "%s:invalid pipe", __func__);
 		return -EINVAL;
 	}
 
+	disp = &vlv_config->pipeline[pipe];
+
+	disp->type = type;
+
 	/* Initialize the plane */
-	pplane = &vlv_config->vdisp[pipe].pplane;
-	err = vlv_pri_plane_init(pplane, vlv_config->base.dev, PRIMARY_PLANE);
+	pplane = &disp->pplane;
+	err = vlv_pri_plane_init(pplane, &disp->base,
+			vlv_config->base.dev, PRIMARY_PLANE);
 	if (err) {
 		dev_err(vlv_config->base.dev,
 			"%s: failed to init pri plane, %d\n", __func__, err);
 		return err;
 	}
 	intel_dc_config_add_plane(&vlv_config->base, &pplane->base,
-				  VLV_ID(pipe, VLV_PLANE));
+				VLV_ID(pipe, VLV_PLANE));
 
 	/* Initialize first sprite */
-	splane = &vlv_config->vdisp[pipe].splane[0];
-	err = vlv_sp_plane_init(splane, vlv_config->base.dev,
-				pipe ? SPRITE_C : SPRITE_A);
+	splane = &disp->splane[0];
+	err = vlv_sp_plane_init(splane, &disp->base,
+			vlv_config->base.dev, pipe ? SPRITE_C : SPRITE_A);
 	if (err) {
 		dev_err(vlv_config->base.dev,
-			"%s: failed to init sprite plane, %d\n", __func__, err);
+			"%s: failed to init sprite plane, %d\n",
+			__func__, err);
 		return err;
 	}
 	intel_dc_config_add_plane(&vlv_config->base, &splane->base,
-				  VLV_ID(pipe, VLV_SPRITE1));
+				VLV_ID(pipe, VLV_SPRITE1));
 
 	/* Initialize second sprite */
-	splane = &vlv_config->vdisp[pipe].splane[1];
-	err = vlv_sp_plane_init(splane, vlv_config->base.dev,
-				pipe ? SPRITE_D : SPRITE_B);
+	splane = &disp->splane[1];
+	err = vlv_sp_plane_init(splane, &disp->base,
+			vlv_config->base.dev, pipe ? SPRITE_D : SPRITE_B);
 	if (err) {
 		dev_err(vlv_config->base.dev,
 				"%s: failed to init sprite plane, %d\n",
@@ -141,47 +189,27 @@ static int vlv_initialize_disp(struct vlv_dc_config *vlv_config, int pipe,
 		return err;
 	}
 	intel_dc_config_add_plane(&vlv_config->base, &splane->base,
-				  VLV_ID(pipe, VLV_SPRITE2));
+				VLV_ID(pipe, VLV_SPRITE2));
+	vlv_pm = &disp->pm;
 
-	/* Initialize interface PIPE */
-	if (type == INTEL_PIPE_DSI) {
-		dsi_pipe = &vlv_config->vdisp[pipe].pipe.dsi;
-		err = dsi_pipe_init(dsi_pipe, vlv_config->base.dev,
-				   &pplane->base, pipe);
-		if (err) {
-			dev_err(vlv_config->base.dev,
-				"%s: failed to init pipe(%d)\n", __func__, err);
-			return err;
-		}
-		intel_dc_config_add_pipe(&vlv_config->base,
-					 &dsi_pipe->base, pipe);
-		vlv_config->vdisp[pipe].type = type;
-		intel_pipe = &vlv_config->vdisp[pipe].pipe.dsi.base;
-	} else {
-		pr_err("ADF: %s: unsupported pipe type = %d\n", __func__, type);
-		err = -EINVAL;
-		return err;
+	if (vlv_pm_init(vlv_pm, (enum pipe) pipe) == false) {
+		dev_err(vlv_config->base.dev,
+			"%s: failed to init pm for pipe %d\n",
+			__func__, pipe);
 	}
 
-	/*
-	 * In this platform the plane and pipe are fixed and cannot be
-	 * moved across to a different pipe, hence set the attachment by
-	 * default over here
-	 */
-	/* Attach Primary plane to Pipe */
-	intel_plane = &vlv_config->vdisp[pipe].pplane.base;
-	if (intel_plane->ops->attach)
-		intel_plane->ops->attach(intel_plane, intel_pipe);
+	vlv_pipe = &disp->pipe;
+	err = vlv_pipe_init(vlv_pipe, (enum pipe) pipe);
+
+	/* FIXME: update from attachment */
+	pll = &disp->pll;
+	err = vlv_pll_init(pll, type, (enum pipe) pipe, PORT_A);
 
-	/* Attach Sprite1 to the pipe */
-	intel_plane = &vlv_config->vdisp[pipe].splane[0].base;
-	if (intel_plane->ops->attach)
-		intel_plane->ops->attach(intel_plane, intel_pipe);
+	/* Initialize port */
+	vlv_initialize_port(vlv_config, pipe, type);
 
-	/* Attach Sprite2 to the pipe */
-	intel_plane = &vlv_config->vdisp[pipe].splane[1].base;
-	if (intel_plane->ops->attach)
-		intel_plane->ops->attach(intel_plane, intel_pipe);
+	/* Initialize encoder */
+	vlv_display_encoder_init(vlv_config, pipe);
 
 	return err;
 }
@@ -200,15 +228,18 @@ struct intel_dc_config *vlv_get_dc_config(struct pci_dev *pdev, u32 id)
 		dev_err(&pdev->dev, "failed to alloc memory\n");
 		return ERR_PTR(-ENOMEM);
 	}
+	config->max_pipes = CHV_N_PIPES;
+	config->max_planes = NUM_PLANES;
 	/* Init config */
 	err = intel_dc_config_init(&config->base, &pdev->dev, 0,
-				   NUM_PLANES, VLV_N_PIPES,
-				   &vlv_allowed_attachments[0],
-				   ARRAY_SIZE(vlv_allowed_attachments));
+				config->max_planes, config->max_pipes,
+				&vlv_allowed_attachments[0],
+				ARRAY_SIZE(vlv_allowed_attachments));
 	if (err) {
 		dev_err(&pdev->dev, "failed to inintialize dc config\n");
 		goto err;
 	}
+
 	/* create and add memory */
 	/*
 	 * TODO: add gem config or get the gem struct here and register as a
@@ -225,8 +256,22 @@ struct intel_dc_config *vlv_get_dc_config(struct pci_dev *pdev, u32 id)
 
 	vlv_initialize_disp(config, PIPE_A, INTEL_PIPE_DSI);
 
+
 	return &config->base;
 err:
 	vlv_dc_config_destroy(&config->base);
 	return ERR_PTR(err);
 }
+
+
+
+/* FIXME: TEMP till dpst is enabled */
+u32 vlv_dpst_context(struct intel_pipeline *pipeline, unsigned long args)
+{
+	return 0;
+}
+
+u32 vlv_dpst_irq_handler(struct intel_pipeline *pipeline)
+{
+	return 0;
+}
diff --git a/drivers/video/adf/intel/core/vlv/vlv_mode_set.c b/drivers/video/adf/intel/core/vlv/vlv_mode_set.c
deleted file mode 100644
index 25fee28..0000000
--- a/drivers/video/adf/intel/core/vlv/vlv_mode_set.c
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
- * Copyright (C) 2014, Intel Corporation.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- *
- * Authors:
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/delay.h>
-
-#include <core/vlv/vlv_dc_config.h>
-#include <core/common/dsi/dsi_pipe.h>
-#include <core/intel_dc_config.h>
-#include <intel_adf.h>
-#include <core/vlv/vlv_dc_regs.h>
-#include <core/common/dsi/dsi_pipe.h>
-#include <drm/drmP.h>
-#include <drm/i915_drm.h>
-
-void vlv_vblank_on(int pipe)
-{
-	u32 val = REG_READ(PIPESTAT(pipe));
-	if (val & PIPE_VBLANK_INTERRUPT_ENABLE) {
-		pr_info("ADF: %s: vblank already on for pipe = %d\n",
-			__func__, pipe);
-	} else {
-		REG_WRITE(PIPESTAT(pipe),
-			 (val | PIPE_VBLANK_INTERRUPT_ENABLE));
-		REG_POSTING_READ(PIPESTAT(pipe));
-	}
-}
-
-void vlv_vblank_off(int pipe)
-{
-	u32 val = REG_READ(PIPESTAT(pipe));
-	if (val & PIPE_VBLANK_INTERRUPT_ENABLE) {
-		REG_WRITE(PIPESTAT(pipe),
-				val & ~PIPE_VBLANK_INTERRUPT_ENABLE);
-		REG_POSTING_READ(PIPESTAT(pipe));
-	} else
-		pr_info("ADF: %s: vblank already off for pipe = %d\n",
-			__func__, pipe);
-}
-
-void vlv_wait_for_vblank(int pipe)
-{
-	u32 frame, frame_reg = PIPE_FRMCOUNT_GM45(pipe);
-
-	frame = REG_READ(frame_reg);
-
-	if (wait_for(REG_POSTING_READ(frame_reg) != frame, 50))
-		pr_info("ADF: %s: vblank wait timed out\n", __func__);
-}
-
-void vlv_wait_for_pipe_off(int pipe)
-{
-	int reg = PIPECONF(pipe);
-
-	/* Wait for the Pipe State to go off */
-	if (wait_for((REG_READ(reg) & I965_PIPECONF_ACTIVE) == 0, 100))
-		pr_err("ADF: %s: pipe_off wait timed out\n", __func__);
-}
-
-void vlv_program_wm(void)
-{
-	REG_WRITE(DSPFW1,
-		   (DSPFW_SR_VAL << DSPFW_SR_SHIFT) |
-		   (DSPFW_CURSORB_VAL << DSPFW_CURSORB_SHIFT) |
-		   (DSPFW_PLANEB_VAL << DSPFW_PLANEB_SHIFT) |
-		   DSPFW_PLANEA_VAL);
-	REG_WRITE(DSPFW2,
-		   (DSPFW2_RESERVED) |
-		   (DSPFW_CURSORA_VAL << DSPFW_CURSORA_SHIFT) |
-		   DSPFW_PLANEC_VAL);
-	REG_WRITE(DSPFW3,
-		   (REG_READ(DSPFW3) & ~DSPFW_CURSOR_SR_MASK) |
-		   (DSPFW3_VLV));
-	REG_WRITE(DSPFW4, (DSPFW4_SPRITEB_VAL << DSPFW4_SPRITEB_SHIFT) |
-			(DSPFW4_CURSORA_VAL << DSPFW4_CURSORA_SHIFT) |
-			DSPFW4_SPRITEA_VAL);
-	REG_WRITE(DSPFW5, (DSPFW5_DISPLAYB_VAL << DSPFW5_DISPLAYB_SHIFT) |
-			(DSPFW5_DISPLAYA_VAL << DSPFW5_DISPLAYA_SHIFT) |
-			(DSPFW5_CURSORB_VAL << DSPFW5_CURSORB_SHIFT) |
-			DSPFW5_CURSORSR_VAL);
-	REG_WRITE(DSPFW6, DSPFW6_DISPLAYSR_VAL);
-	REG_WRITE(DSPFW7, (DSPFW7_SPRITED1_VAL << DSPFW7_SPRITED1_SHIFT) |
-			(DSPFW7_SPRITED_VAL << DSPFW7_SPRITED_SHIFT) |
-			(DSPFW7_SPRITEC1_VAL << DSPFW7_SPRITEC1_SHIFT) |
-			DSPFW7_SPRITEC_VAL);
-	REG_WRITE(DSPARB, VLV_DEFAULT_DSPARB);
-}
-
-int vlv_display_on(struct intel_pipe *pipe)
-{
-	struct dsi_pipe *dsi_pipe = NULL;
-	struct drm_mode_modeinfo mode;
-	int reg, i;
-	u32 val = 0;
-	u8 index;
-	bool is_dsi = pipe->type == INTEL_PIPE_DSI ? true : false;
-
-	if (!pipe)
-		return -EINVAL;
-
-	index = pipe->base.idx;
-
-	if (is_dsi) {
-		dsi_pipe = to_dsi_pipe(pipe);
-
-		/* encoder enable */
-		dsi_pipe->ops.power_on(dsi_pipe);
-
-		/* get the configured mode */
-		dsi_pipe->panel->ops->get_config_mode(&dsi_pipe->config, &mode);
-		dsi_pipe->dpms_state = DRM_MODE_DPMS_ON;
-	}
-
-	pipe_mode_set(pipe, &mode);
-
-	/* FIXME: Enable PF here if needed */
-
-	/* Load default gamma LUT */
-	reg = PALETTE(0);
-	for (i = 0; i < 256; i++) {
-		REG_WRITE(reg + 4 * i,
-			(dsi_pipe->config.lut_r[i] << 16) |
-			(dsi_pipe->config.lut_g[i] << 8) |
-			(dsi_pipe->config.lut_b[i]));
-	}
-
-	/* Enable pipe */
-	reg = PIPECONF(index);
-	val = REG_READ(reg);
-	if (val & PIPECONF_ENABLE)
-		pr_err("ADF: %s: Pipe already on !!\n", __func__);
-	else {
-		REG_WRITE(reg, val | PIPECONF_ENABLE);
-		REG_POSTING_READ(reg);
-	}
-
-	/* program Gamma enable */
-	val = REG_READ(DSPCNTR(index)) | DISPPLANE_GAMMA_ENABLE;
-
-	/* disable rotation for now */
-	val &= ~(1 << 15);
-	REG_WRITE(DSPCNTR(index), val);
-	REG_POSTING_READ(DSPCNTR(index));
-
-	vlv_vblank_on(index);
-
-	/* enable vsyncs */
-	pipe->ops->set_event(pipe, INTEL_PIPE_EVENT_VSYNC, true);
-
-	/* Program the watermarks */
-	vlv_program_wm();
-	/* Trickle feed is disabled by default */
-	REG_WRITE(MI_ARB_VLV, 0x00);
-	/* program the pfi credits, first disable and then program */
-	if (REG_READ(GCI_CONTROL) != 0x78004000) {
-		REG_WRITE(GCI_CONTROL, 0x00004000);
-		REG_WRITE(GCI_CONTROL, 0x78004000);
-	}
-
-	return 0;
-}
-
-int vlv_display_off(struct intel_pipe *pipe)
-{
-	int i, reg;
-	u32 val = 0;
-	u8 index;
-	struct dsi_pipe *dsi = NULL;
-	int is_dsi = pipe->type == INTEL_PIPE_DSI ? true : false;
-
-	pr_debug("ADF: %s\n", __func__);
-
-	if (!pipe)
-		return -EINVAL;
-
-	if (is_dsi) {
-		dsi = to_dsi_pipe(pipe);
-
-		/* check harwdare state before disabling */
-		if (!dsi->ops.get_hw_state(dsi)) {
-			pr_err("%s: DSI device already disabled\n", __func__);
-			return 0;
-		}
-	}
-
-	index = pipe->base.idx;
-
-	/* disable vsyncs */
-	pipe->ops->set_event(pipe, INTEL_PIPE_EVENT_VSYNC, false);
-
-	 /* encoder specifific disabling if needed */
-	if (is_dsi)
-		/* DSI Shutdown command */
-		dsi->ops.pre_power_off(dsi);
-
-	/* Also check for pending flip and the vblank off  */
-
-	/* Disable Sprite planes */
-	for (i = 0; i < VLV_NUM_SPRITES; i++) {
-		REG_WRITE(SPCNTR(index, i), REG_READ(SPCNTR(index, i)) &
-				~SP_ENABLE);
-
-		/* Activate double buffered register update */
-		I915_MODIFY_DISPBASE(SPSURF(index, i), 0);
-		REG_POSTING_READ(SPSURF(index, i));
-	}
-
-	vlv_vblank_off(index);
-
-	/* Disable primary plane */
-	reg = DSPCNTR(index);
-	val = REG_READ(reg);
-	if (val & DISPLAY_PLANE_ENABLE) {
-		REG_WRITE(reg, val & ~DISPLAY_PLANE_ENABLE);
-		REG_WRITE(DSPSURF(index), REG_READ(DSPSURF(index)));
-	} else
-		pr_info("ADF:%s: primary plane already disabled on pipe = %d\n",
-			__func__, index);
-
-	/* Disable pipe */
-	reg = PIPECONF(index);
-	val = REG_READ(reg);
-	if ((val & PIPECONF_ENABLE) == 0)
-		pr_info("ADF: %s: pipe already off\n", __func__);
-	else {
-		REG_WRITE(reg, val & ~PIPECONF_ENABLE);
-		vlv_wait_for_pipe_off(index);
-		REG_WRITE(PFIT_CONTROL, 0);
-	}
-
-	/* TODO
-	* Interface specific encoder post disable should be done here */
-
-	/* encoder off interface specific */
-	if (is_dsi) {
-		dsi->ops.power_off(dsi);
-		dsi->dpms_state = DRM_MODE_DPMS_OFF;
-	}
-	/*
-	 * Disable PLL
-	 * Needed for interfaces other than DSI
-	 */
-
-	/*TODO*/
-	/* Power gate DPIO RX Lanes */
-
-	return 0;
-}
-
-int pipe_mode_set(struct intel_pipe *pipe, struct drm_mode_modeinfo *mode)
-{
-	int vblank_start;
-	int vblank_end;
-	int hblank_start;
-	int hblank_end;
-	uint32_t pipeconf = 0;
-	u8 index = pipe->base.idx;
-
-	vblank_start = min(mode->vsync_start, mode->vdisplay);
-	vblank_end = max(mode->vsync_end, mode->vtotal);
-	hblank_start = min(mode->hsync_start, mode->hdisplay);
-	hblank_end = max(mode->hsync_end, mode->htotal);
-
-	REG_WRITE(HTOTAL(index),
-		(mode->hdisplay - 1) |
-		((mode->htotal - 1) << 16));
-
-	REG_WRITE(HBLANK(index),
-		(hblank_start - 1) |
-		((hblank_end - 1) << 16));
-
-	REG_WRITE(HSYNC(index),
-		(mode->hsync_start - 1) |
-		((mode->hsync_end - 1) << 16));
-
-	REG_WRITE(VTOTAL(index),
-		(mode->vdisplay - 1) |
-		((mode->vtotal - 1) << 16));
-
-	REG_WRITE(VBLANK(index),
-		(vblank_start - 1) |
-		((vblank_end - 1) << 16));
-
-	REG_WRITE(VSYNC(index),
-		(mode->vsync_start - 1) |
-		((mode->vsync_end - 1) << 16));
-
-	/* pipesrc controls the size that is scaled from, which should
-	* always be the user's requested size.
-	*/
-	REG_WRITE(PIPESRC(index),
-		((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));
-
-	/* pipesrc and dspsize control the size that is scaled from,
-	* which should always be the user's requested size.
-	*/
-
-	REG_WRITE(DSPSIZE(index),
-		((mode->vdisplay - 1) << 16) |
-		(mode->hdisplay - 1));
-	REG_WRITE(DSPPOS(index), 0);
-
-	pipeconf |= PIPECONF_PROGRESSIVE;
-	REG_WRITE(PIPECONF(index), pipeconf);
-	REG_POSTING_READ(PIPECONF(index));
-
-	/* TODO primary plane fb update */
-
-	return 0;
-}
diff --git a/drivers/video/adf/intel/core/vlv/vlv_pipeline.c b/drivers/video/adf/intel/core/vlv/vlv_pipeline.c
new file mode 100644
index 0000000..0cbbd77
--- /dev/null
+++ b/drivers/video/adf/intel/core/vlv/vlv_pipeline.c
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+
+#include <core/vlv/vlv_dc_config.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/intel_dc_config.h>
+#include <intel_adf.h>
+#include <core/vlv/vlv_dc_regs.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/vlv/vlv_pm.h>
+#include <drm/drmP.h>
+#include <drm/i915_drm.h>
+
+bool vlv_wait_for_vblank(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pipe *pipe = &disp->pipe;
+
+	return vlv_pipe_wait_for_vblank(pipe);
+}
+
+void vlv_evade_vblank(struct intel_pipeline *pipeline,
+	struct drm_mode_modeinfo *mode, bool *wait_for_vblank)
+{
+
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pipe *pipe = &disp->pipe;
+
+	vlv_pipe_evade_vblank(pipe, mode, wait_for_vblank);
+}
+
+u32 vlv_num_planes_enabled(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	u32 count = 0, i;
+
+	if (vlv_pri_is_enabled(&disp->pplane))
+		count++;
+
+	/* 2 sprite planes for both vlv/chv */
+	for (i = 0; i < VLV_NUM_SPRITES; i++) {
+		if (vlv_sp_plane_is_enabled(&disp->splane[i]))
+			count++;
+	}
+
+	return count;
+}
+
+bool vlv_update_maxfifo_status(struct intel_pipeline *pipeline, bool enable)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pm *pm = &disp->pm;
+
+	return vlv_pm_update_maxfifo_status(pm, enable);
+
+}
+
+void vlv_program_pm(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pm *pm = &disp->pm;
+	int num_planes;
+
+	num_planes = vlv_num_planes_enabled(pipeline);
+	vlv_pm_program_values(pm, num_planes);
+}
+
+u32 vlv_dsi_prepare_on(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pll *pll = &disp->pll;
+	struct vlv_pipe *pipe = &disp->pipe;
+	struct vlv_dsi_port *dsi_port = &disp->port.dsi_port;
+	struct dsi_config *config = pipeline->params.dsi.dsi_config;
+	u32 err = 0;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		/*
+		 * MIPI being special has extra call to pipeline
+		 * enable sequence for pll enable is here, later
+		 * call will ensure rest of components powered up
+		 */
+
+		/* pll enable */
+		/* need port, mode for pll enable */
+		pll->config = pipeline->params.dsi.dsi_config;
+
+		vlv_dsi_pll_enable(pll, mode);
+
+		err = vlv_pipe_wait_for_pll_lock(pipe);
+		if (err)
+			goto out;
+
+		vlv_dsi_port_set_device_ready(dsi_port);
+
+		vlv_dsi_port_prepare(dsi_port, mode, config);
+
+		/* need to make panel calls so return to common code */
+	}
+
+out:
+	return err;
+}
+
+u32 vlv_port_enable(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = &disp->port.dsi_port;
+	struct dsi_config *config = pipeline->params.dsi.dsi_config;
+	struct dsi_context *intel_dsi = &config->ctx;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		/* DSI PORT */
+		vlv_dsi_port_enable(dsi_port, intel_dsi->port_bits);
+		/* enable will be done in next call for dsi */
+	}
+	return 0;
+}
+
+/*
+ * DSI is a special beast that requires 3 calls to pipeline
+ *	1) setup pll : dsi_prepare_on
+ *	2) setup port: dsi_pre_pipeline_on
+ *	3) enable port, pipe, plane etc : pipeline_on
+ * this is because of the panel calls needed to be performed
+ * between these operations and hence we return to common code
+ * to make these calls.
+ */
+u32 vlv_pipeline_on(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pri_plane *pplane = &disp->pplane;
+	struct vlv_pipe *pipe = &disp->pipe;
+	struct vlv_plane_params plane_params;
+	u32 err = 0;
+
+	/* pll enable */
+	/* need port, mode for pll enable */
+
+	/* pf enable */
+
+	/* port enable */
+	vlv_port_enable(pipeline, mode);
+	/* wait for dpio phystatus ready */
+
+	vlv_pipe_program_timings(pipe, mode);
+
+	/* pipe enable */
+	vlv_pipe_enable(pipe, mode);
+
+	/* FIXME: create func to update plane registers */
+	vlv_pri_update_params(pplane, &plane_params);
+
+	vlv_pipe_vblank_on(pipe);
+	if (err != true)
+		pr_err("ADF: %s: enable vblank failed\n", __func__);
+	else
+		/*
+		 * Reset the last success value (bool true) to zero else
+		 * this will give caller an illusion of failure
+		 */
+		 err = 0;
+
+	/*
+	 * FIXME: enable dpst call once dpst is fixed
+	 * vlv_dpst_pipeline_on(disp->dpst, mode);
+	 */
+
+	/* Program the watermarks */
+	vlv_program_pm(pipeline);
+
+	return err;
+}
+
+u32 vlv_dsi_pre_pipeline_on(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *port = &disp->port.dsi_port;
+	u32 err = 0;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		err = vlv_dsi_port_pre_enable(port, mode,
+			pipeline->params.dsi.dsi_config);
+	}
+
+	return err;
+}
+
+u32 vlv_dsi_post_pipeline_off(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pll *pll = &disp->pll;
+	struct vlv_dsi_port *dsi_port = &disp->port.dsi_port;
+	u32 err = 0;
+	err = vlv_dsi_port_wait_for_fifo_empty(dsi_port);
+
+	err = vlv_dsi_port_clear_device_ready(dsi_port);
+
+	err = vlv_dsi_pll_disable(pll);
+
+	return err;
+}
+
+/* generic function to be called for any operations after disable is done */
+u32 vlv_post_pipeline_off(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	u32 err = 0;
+
+	switch (disp->type) {
+	case INTEL_PIPE_DSI:
+		err = vlv_dsi_post_pipeline_off(pipeline);
+		break;
+	case INTEL_PIPE_EDP:
+	case INTEL_PIPE_DP:
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+u32 vlv_port_disable(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	u32 err = 0;
+
+	switch (disp->type) {
+	case INTEL_PIPE_DSI:
+		dsi_port = &disp->port.dsi_port;
+		err = vlv_dsi_port_disable(dsi_port,
+			pipeline->params.dsi.dsi_config);
+		/*
+		 * pll is disabled in the next call to
+		 * vlv_post_pipeline_off
+		 */
+		break;
+	case INTEL_PIPE_EDP:
+	case INTEL_PIPE_DP:
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+u32 vlv_pipeline_off(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pri_plane *pplane = NULL;
+	struct vlv_sp_plane *splane = NULL;
+	struct vlv_pipe *pipe = NULL;
+	struct vlv_pll *pll = NULL;
+	u32 err = 0, i = 0;
+
+	/* Disable DPST */
+	/* FIXME: vlv_dpst_pipeline_off(); */
+
+	/* Also check for pending flip and the vblank off  */
+
+	pplane = &disp->pplane;
+	pipe = &disp->pipe;
+
+	for (i = 0; i < 2; i++) {
+		splane = &disp->splane[i];
+		splane->base.ops->disable(&splane->base);
+	}
+
+	pplane->base.ops->disable(&pplane->base);
+
+	vlv_pipe_vblank_off(pipe);
+
+	/* pipe */
+	err = vlv_pipe_disable(pipe);
+	if (err != 0)
+		goto out;
+
+	/* port disable */
+	err = vlv_port_disable(pipeline);
+	if (err != 0)
+		goto out;
+
+	if (disp->type == INTEL_PIPE_DSI)
+		goto out;
+
+	/* pll */
+	err = vlv_pll_disable(pll);
+	if (err != 0)
+		goto out;
+
+	/* TODO: watermark */
+out:
+	return err;
+}
+
+bool vlv_is_vid_mode(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	bool ret = false;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		ret = vlv_dsi_port_is_vid_mode(dsi_port);
+	}
+
+	return ret;
+}
+
+bool vlv_can_be_disabled(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	bool ret = false;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		ret = vlv_dsi_port_can_be_disabled(dsi_port);
+	}
+
+	return ret;
+}
+
+bool vlv_is_screen_connected(struct intel_pipeline *pipeline)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	bool ret = false;
+
+	switch (disp->type) {
+	case INTEL_PIPE_DSI:
+		/* FIXME: call dsi port */
+		ret = true;
+		break;
+	case INTEL_PIPE_DP:
+	case INTEL_PIPE_EDP:
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+/* DSI specific calls  */
+void vlv_cmd_hs_mode_enable(struct intel_pipeline *pipeline, bool enable)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		vlv_dsi_port_cmd_hs_mode_enable(dsi_port, enable);
+	}
+}
+
+int vlv_cmd_vc_dcs_write(struct intel_pipeline *pipeline, int channel,
+		const u8 *data, int len)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	int err = 0;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		err = vlv_dsi_port_cmd_vc_dcs_write(dsi_port,
+			channel, data, len);
+	}
+
+	return err;
+}
+
+int vlv_cmd_vc_generic_write(struct intel_pipeline *pipeline, int channel,
+			const u8 *data, int len)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	int err = 0;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		err = vlv_dsi_port_cmd_vc_generic_write(dsi_port,
+			channel, data, len);
+	}
+
+	return err;
+}
+
+int vlv_cmd_vc_dcs_read(struct intel_pipeline *pipeline, int channel,
+		u8 dcs_cmd, u8 *buf, int buflen)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	int err = 0;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		err = vlv_dsi_port_cmd_vc_dcs_read(dsi_port, channel,
+			dcs_cmd, buf, buflen);
+	}
+
+	return err;
+}
+
+int vlv_cmd_vc_generic_read(struct intel_pipeline *pipeline, int channel,
+		u8 *reqdata, int reqlen, u8 *buf, int buflen)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	int err = 0;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		err = vlv_dsi_port_cmd_vc_generic_read(dsi_port, channel,
+			reqdata, reqlen, buf, buflen);
+	}
+
+	return err;
+}
+
+int vlv_cmd_dpi_send_cmd(struct intel_pipeline *pipeline, u32 cmd, bool hs)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_dsi_port *dsi_port = NULL;
+	int err = 0;
+
+	if (disp->type == INTEL_PIPE_DSI) {
+		dsi_port = &disp->port.dsi_port;
+		err = vlv_dsi_port_cmd_dpi_send_cmd(dsi_port, cmd, hs);
+	}
+
+	return err;
+}
+
+u32 vlv_get_event(struct intel_pipeline *pipeline, u32 *event)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pipe *pipe = &disp->pipe;
+	struct vlv_pm *pm = &disp->pm;
+	u32 ret = 0;
+
+	ret = vlv_pipe_get_event(pipe, event);
+
+	if (ret == 0)
+		ret = vlv_pm_flush_values(pm, *event);
+
+	return ret;
+}
+
+u32 vlv_set_event(struct intel_pipeline *pipeline, u32 event, bool enabled)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pipe *pipe = &disp->pipe;
+
+	return vlv_pipe_set_event(pipe, event, enabled);
+}
+
+bool vlv_is_plane_enabled(struct intel_pipeline *pipeline,
+		struct intel_plane *plane)
+{
+	struct vlv_pipeline *disp = to_vlv_pipeline(pipeline);
+	struct vlv_pri_plane *pri_plane = &disp->pplane;
+	struct vlv_sp_plane *sp1_plane = &disp->splane[0];
+	struct vlv_sp_plane *sp2_plane = &disp->splane[1];
+	bool ret = false;
+
+	if (&pri_plane->base == plane)
+		ret = vlv_pri_is_enabled(pri_plane);
+	else if (&sp1_plane->base == plane)
+		ret = vlv_sp_plane_is_enabled(sp1_plane);
+	else if (&sp2_plane->base == plane)
+		ret = vlv_sp_plane_is_enabled(sp2_plane);
+
+	return ret;
+}
diff --git a/drivers/video/adf/intel/core/vlv/vlv_pri_plane.c b/drivers/video/adf/intel/core/vlv/vlv_pri_plane.c
index 24e5031..0a750c4 100644
--- a/drivers/video/adf/intel/core/vlv/vlv_pri_plane.c
+++ b/drivers/video/adf/intel/core/vlv/vlv_pri_plane.c
@@ -207,14 +207,21 @@ unsigned long vlv_compute_page_offset(int *x, int *y,
 	}
 }
 
+static inline struct vlv_pipeline *to_vlv_pipeline_pri_plane(
+	struct vlv_pri_plane *plane)
+{
+	return container_of(plane, struct vlv_pipeline, pplane);
+}
+
 static int vlv_pri_calculate(struct intel_plane *plane,
 		struct intel_buffer *buf,
 		struct intel_plane_config *config)
 {
 	struct vlv_pri_plane *pri_plane = to_vlv_pri_plane(plane);
+	struct vlv_pipeline *disp = to_vlv_pipeline_pri_plane(pri_plane);
+	struct vlv_pm *pm = &disp->pm;
 	struct pri_plane_regs_value *regs = &pri_plane->ctx.regs;
 	struct intel_pipe *intel_pipe = config->pipe;
-	struct dsi_pipe *dsi_pipe = to_dsi_pipe(intel_pipe);
 	struct drm_mode_modeinfo mode;
 	unsigned long dspaddr_offset;
 	int plane_ddl, prec_multi, plane_prec_multi;
@@ -248,33 +255,46 @@ static int vlv_pri_calculate(struct intel_plane *plane,
 		}
 	}
 	mask = DDL_PLANEA_MASK;
+
 	if (bpp != prev_bpp || !(REG_READ(VLV_DDL(pipe)) & mask)) {
-		dsi_pipe->panel->ops->get_config_mode(&dsi_pipe->config,
-				&mode);
-		vlv_calculate_ddl(mode.clock, bpp, &prec_multi,
-				&plane_ddl);
-		plane_prec_multi = (prec_multi ==
+		/*FIXME: get mode from interface itself */
+		intel_pipe->ops->get_current_mode(intel_pipe, &mode);
+		if (mode.clock && bpp) {
+			vlv_calculate_ddl(mode.clock, bpp, &prec_multi,
+					&plane_ddl);
+			plane_prec_multi = (prec_multi ==
 					DRAIN_LATENCY_PRECISION_32) ?
-					DDL_PLANE_PRECISION_32 :
-					DDL_PLANE_PRECISION_64;
-		plane_ddl = plane_prec_multi | (plane_ddl);
-		intel_pipe->regs.pri_ddl = plane_ddl;
-		intel_pipe->regs.pri_ddl_mask = mask;
+				DDL_PLANE_PRECISION_32 :
+				DDL_PLANE_PRECISION_64;
+			plane_ddl = plane_prec_multi | (plane_ddl);
+
+			/* save the ddl in pm object to flush later */
+			vlv_pm_save_values(pm, true, false, false, plane_ddl);
+			/*
+			 * FIXME: Now currently drain latency is set to zero.
+			 * this is should be fixed in future.
+			 */
+		} else {
+			pr_err("ADF: %s: Skipping DDL(clock=%u bpp=%u)\n",
+					__func__, mode.clock, bpp);
+		}
 		REG_WRITE_BITS(VLV_DDL(pipe), 0x00, mask);
 	}
+
 	if (buf->tiling_mode != I915_TILING_NONE)
 		regs->dspcntr |= DISPPLANE_TILED;
 	else
 		regs->dspcntr &= ~DISPPLANE_TILED;
+
 	/* when in maxfifo display control register cannot be modified */
 	if (intel_pipe->status.maxfifo_enabled && regs->dspcntr != dspcntr) {
 		REG_WRITE(FW_BLC_SELF_VLV, ~FW_CSPWRDWNEN);
 		intel_pipe->status.maxfifo_enabled = false;
 		intel_pipe->status.wait_vblank = true;
 		intel_pipe->status.vsync_counter =
-				intel_pipe->ops->get_vsync_counter(intel_pipe,
-								   0);
+			intel_pipe->ops->get_vsync_counter(intel_pipe, 0);
 	}
+
 	regs->stride = buf->stride;
 	regs->linearoff = src_y * regs->stride + src_x * bpp;
 	dspaddr_offset = vlv_compute_page_offset(&src_x, &src_y,
@@ -317,39 +337,74 @@ static void vlv_pri_flip(struct intel_plane *plane,
 {
 	struct vlv_pri_plane *pri_plane = to_vlv_pri_plane(plane);
 	struct pri_plane_regs_value *regs = &pri_plane->ctx.regs;
-	u32 pidx = pri_plane->ctx.plane;
 
-	REG_WRITE(DSPCNTR(pidx), regs->dspcntr);
-	REG_WRITE(DSPSTRIDE(pidx), regs->stride);
-	REG_WRITE(DSPTILEOFF(pidx), regs->tileoff);
-	REG_WRITE(DSPLINOFF(pidx), regs->linearoff);
-	I915_MODIFY_DISPBASE(DSPSURF(pidx), regs->surfaddr);
-	REG_POSTING_READ(DSPSURF(pidx));
-	vlv_update_plane_status(config->pipe, VLV_PLANE, true);
+	REG_WRITE(pri_plane->stride_offset, regs->stride);
+	REG_WRITE(pri_plane->tiled_offset, regs->tileoff);
+	REG_WRITE(pri_plane->linear_offset, regs->linearoff);
+
+	REG_WRITE(pri_plane->offset, regs->dspcntr);
+	I915_MODIFY_DISPBASE(pri_plane->surf_offset, regs->surfaddr);
+	REG_POSTING_READ(pri_plane->surf_offset);
+	pri_plane->enabled = true;
 
 	return;
 }
 
-static inline void vlv_adf_flush_disp_plane(u8 plane)
+static inline void vlv_adf_flush_disp_plane(struct vlv_pri_plane *plane)
+{
+	REG_WRITE(plane->surf_offset, REG_READ(plane->surf_offset));
+}
+
+bool vlv_pri_is_enabled(struct vlv_pri_plane *plane)
 {
-	REG_WRITE(DSPSURF(plane), REG_READ(DSPSURF(plane)));
+	return plane->enabled;
 }
 
-static int vlv_pri_enable(struct intel_plane *plane)
+/*
+ * called during modeset, where we just configure params without
+ * enabling plane
+ */
+int vlv_pri_update_params(struct vlv_pri_plane *plane,
+		struct vlv_plane_params *params)
 {
-	u32 reg, value;
+	u32 value;
 
-	reg = DSPCNTR(plane->base.idx);
-	value = REG_READ(reg);
+	value = REG_READ(plane->offset);
+
+	/*
+	 * FIXME: need to update rotation value based on need
+	 * disable rotation for now
+	 */
+	value &= ~(1 << 15);
+
+	value |= DISPPLANE_GAMMA_ENABLE;
+
+	REG_WRITE(plane->offset, value);
+
+	return 0;
+}
+
+static int vlv_pri_enable(struct intel_plane *intel_plane)
+{
+	struct vlv_pri_plane *plane = to_vlv_pri_plane(intel_plane);
+	u32 value;
+
+	value = REG_READ(plane->offset);
 	if (value & DISPLAY_PLANE_ENABLE) {
-		dev_dbg(plane->base.dev, "%splane already enabled\n",
+		dev_dbg(plane->base.base.dev, "%splane already enabled\n",
 				__func__);
 		return 0;
 	}
 
-	REG_WRITE(reg, value | DISPLAY_PLANE_ENABLE);
-	vlv_update_plane_status(plane->pipe, VLV_PLANE, true);
-	vlv_adf_flush_disp_plane(plane->base.idx);
+	/*
+	 * FIXME: need to update rotation value based on need
+	 * disable rotation for now
+	 */
+	value &= ~(1 << 15);
+
+	plane->enabled = true;
+	REG_WRITE(plane->offset, value | DISPLAY_PLANE_ENABLE);
+	vlv_adf_flush_disp_plane(plane);
 
 	/*
 	 * TODO:No need to wait in case of mipi.
@@ -361,26 +416,28 @@ static int vlv_pri_enable(struct intel_plane *plane)
 	return 0;
 }
 
-static int vlv_pri_disable(struct intel_plane *plane)
+static int vlv_pri_disable(struct intel_plane *intel_plane)
 {
-	u32 reg, value;
+	struct vlv_pri_plane *plane = to_vlv_pri_plane(intel_plane);
+	u32 value;
 	u32 mask = DDL_PLANEA_MASK;
 
-	reg = DSPCNTR(plane->base.idx);
-	value = REG_READ(reg);
+	value = REG_READ(plane->offset);
 	if ((value & DISPLAY_PLANE_ENABLE) == 0) {
-		dev_dbg(plane->base.dev, "%splane already disabled\n",
+		dev_dbg(plane->base.base.dev, "%splane already disabled\n",
 				__func__);
 		return 0;
 	}
 
-	REG_WRITE(reg, value & ~DISPLAY_PLANE_ENABLE);
-	vlv_update_plane_status(plane->pipe, VLV_PLANE, false);
-	vlv_adf_flush_disp_plane(plane->base.idx);
-	REG_WRITE_BITS(VLV_DDL(plane->base.idx), 0x00, mask);
+	plane->enabled = false;
+	REG_WRITE(plane->offset, value & ~DISPLAY_PLANE_ENABLE);
+	vlv_adf_flush_disp_plane(plane);
+	REG_WRITE_BITS(VLV_DDL(plane->base.base.idx), 0x00, mask);
 	return 0;
 }
 
+
+
 static const struct intel_plane_capabilities vlv_pri_caps = {
 	.supported_formats = pri_supported_formats,
 	.n_supported_formats = ARRAY_SIZE(pri_supported_formats),
@@ -400,7 +457,7 @@ static const struct intel_plane_capabilities vlv_pri_caps = {
 	.n_supported_reservedbit = 0,
 };
 
-static const struct intel_plane_ops vlv_pri_ops = {
+static struct intel_plane_ops vlv_pri_ops = {
 	.base = {
 		.suspend = vlv_pri_suspend,
 		.resume = vlv_pri_resume,
@@ -416,7 +473,8 @@ static const struct intel_plane_ops vlv_pri_ops = {
 	.disable = vlv_pri_disable,
 };
 
-int vlv_pri_plane_init(struct vlv_pri_plane *pplane, struct device *dev, u8 idx)
+int vlv_pri_plane_init(struct vlv_pri_plane *pplane,
+		struct intel_pipeline *pipeline, struct device *dev, u8 idx)
 {
 	int err;
 
@@ -429,6 +487,13 @@ int vlv_pri_plane_init(struct vlv_pri_plane *pplane, struct device *dev, u8 idx)
 		pr_err("%s: plane context initialization failed\n", __func__);
 		return err;
 	}
+
+	pplane->offset = DSPCNTR(idx);
+	pplane->surf_offset = DSPSURF(idx);
+	pplane->stride_offset = DSPSTRIDE(idx);
+	pplane->tiled_offset = DSPTILEOFF(idx);
+	pplane->linear_offset = DSPLINOFF(idx);
+
 	return intel_adf_plane_init(&pplane->base, dev, idx, &vlv_pri_caps,
 			&vlv_pri_ops, "primary_plane");
 }
diff --git a/drivers/video/adf/intel/core/vlv/vlv_sp_plane.c b/drivers/video/adf/intel/core/vlv/vlv_sp_plane.c
index 556757f..1eed46c 100644
--- a/drivers/video/adf/intel/core/vlv/vlv_sp_plane.c
+++ b/drivers/video/adf/intel/core/vlv/vlv_sp_plane.c
@@ -14,6 +14,7 @@
 
 #include <drm/i915_drm.h>
 #include <video/intel_adf.h>
+#include <drm/drm_rect.h>
 
 #include "intel_adf_device.h"
 #include "core/common/intel_dc_regs.h"
@@ -50,7 +51,6 @@ static const struct format_info format_mappings[] = {
 	},
 
 	{
-
 		.drm_format = DRM_FORMAT_VYUY,
 		.hw_config = SP_FORMAT_YUV422 | SP_YUV_ORDER_VYUY,
 		.bpp = 2,
@@ -179,61 +179,6 @@ static void vlv_sp_resume(struct intel_dc_component *component)
 {
 	return;
 }
-
-/**
- * rect_clip_scaled - perform a scaled clip operation
- * @src: source window rectangle
- * @dst: destination window rectangle
- * @clip: clip rectangle
- * @hscale: horizontal scaling factor
- * @vscale: vertical scaling factor
- *
- * Clip rectangle @dst by rectangle @clip. Clip rectangle @src by the
- * same amounts multiplied by @hscale and @vscale.
- *
- * RETURNS:
- * %true if rectangle @dst is still visible after being clipped,
- * %false otherwise
-*/
-
-static bool rect_clip_scaled(struct rectangle *src, struct rectangle *dst,
-			const struct rectangle *clip)
-{
-	int diff;
-	int width, height;
-
-	diff = clip->x1 - dst->x1;
-	if (diff > 0) {
-		int64_t tmp = src->x1 + (int64_t) diff;
-		src->x1 = clamp_t(int64_t, tmp, INT_MIN, INT_MAX);
-	}
-	diff = clip->y1 - dst->y1;
-	if (diff > 0) {
-		int64_t tmp = src->y1 + (int64_t) diff;
-		src->y1 = clamp_t(int64_t, tmp, INT_MIN, INT_MAX);
-	}
-	diff = dst->x2 - clip->x2;
-	if (diff > 0) {
-		int64_t tmp = src->x2 - (int64_t) diff;
-		src->x2 = clamp_t(int64_t, tmp, INT_MIN, INT_MAX);
-	}
-	diff = dst->y2 - clip->y2;
-	if (diff > 0) {
-		int64_t tmp = src->y2 - (int64_t) diff;
-		src->y2 = clamp_t(int64_t, tmp, INT_MIN, INT_MAX);
-	}
-
-	dst->x1 = max(dst->x1, clip->x1);
-	dst->y1 = max(dst->y1, clip->y1);
-	dst->x2 = min(dst->x2, clip->x2);
-	dst->y2 = min(dst->y2, clip->y2);
-
-	width = dst->x2 - dst->x1;
-	height = dst->y2 - dst->y1;
-
-	return width > 0 && height > 0;
-}
-
 static bool format_is_yuv(uint32_t format)
 {
 	switch (format) {
@@ -247,14 +192,37 @@ static bool format_is_yuv(uint32_t format)
 	}
 }
 
+static inline struct vlv_pipeline *to_vlv_pipeline_sp1_plane(
+	struct vlv_sp_plane *plane)
+{
+	return container_of(plane, struct vlv_pipeline, splane[0]);
+}
+
+static void vlv_sp_pane_save_ddl(struct vlv_sp_plane *splane, u32 ddl)
+{
+	int plane = splane->ctx.plane;
+	struct vlv_pipeline *disp = NULL;
+	struct vlv_pm *pm;
+	struct vlv_sp_plane *tmp_plane = splane;
+
+	/* FIXME: verify this works for both planes */
+	if (plane == 1)
+		tmp_plane -= 1;
+
+	disp = to_vlv_pipeline_sp1_plane(tmp_plane);
+
+	pm = &disp->pm;
+	vlv_pm_save_values(pm, true, (plane ? false : true),
+		(plane ? true : false), ddl);
+}
+
 static int vlv_sp_calculate(struct intel_plane *planeptr,
-			    struct intel_buffer *buf,
-			    struct intel_plane_config *config)
+			struct intel_buffer *buf,
+			struct intel_plane_config *config)
 {
 	struct vlv_sp_plane *splane = to_vlv_sp_plane(planeptr);
 	struct sp_plane_regs_value *regs = &splane->ctx.regs;
 	struct intel_pipe *intel_pipe = config->pipe;
-	struct dsi_pipe *dsi_pipe = to_dsi_pipe(intel_pipe);
 	struct drm_mode_modeinfo mode;
 	unsigned long sprsurf_offset, linear_offset;
 	int sprite_ddl, prec_multi, sp_prec_multi;
@@ -329,8 +297,7 @@ static int vlv_sp_calculate(struct intel_plane *planeptr,
 		shift = DDL_SPRITEB_SHIFT;
 	}
 	if (bpp != prev_bpp || !(REG_READ(VLV_DDL(pipe)) & mask)) {
-		dsi_pipe->panel->ops->get_config_mode(&dsi_pipe->config,
-				&mode);
+		intel_pipe->ops->get_current_mode(intel_pipe, &mode);
 		vlv_calculate_ddl(mode.clock, bpp, &prec_multi,
 				&sprite_ddl);
 		sp_prec_multi = (prec_multi ==
@@ -338,14 +305,9 @@ static int vlv_sp_calculate(struct intel_plane *planeptr,
 					DDL_PLANE_PRECISION_32 :
 					DDL_PLANE_PRECISION_64;
 		sprite_ddl = (sp_prec_multi | sprite_ddl) << shift;
-		if (plane == 0) {
-			intel_pipe->regs.sp1_ddl = sprite_ddl;
-			intel_pipe->regs.sp1_ddl_mask = mask;
-		} else {
-			intel_pipe->regs.sp2_ddl = sprite_ddl;
-			intel_pipe->regs.sp2_ddl_mask = mask;
-		}
+		vlv_sp_pane_save_ddl(splane, sprite_ddl);
 		REG_WRITE_BITS(VLV_DDL(pipe), 0x00, mask);
+
 	}
 
 	sprctl |= SP_ENABLE;
@@ -388,8 +350,7 @@ static int vlv_sp_calculate(struct intel_plane *planeptr,
 		intel_pipe->status.maxfifo_enabled = false;
 		intel_pipe->status.wait_vblank = true;
 		intel_pipe->status.vsync_counter =
-				intel_pipe->ops->get_vsync_counter(intel_pipe,
-								   0);
+			intel_pipe->ops->get_vsync_counter(intel_pipe, 0);
 	}
 
 	return 0;
@@ -403,17 +364,22 @@ static int vlv_sp_attach(struct intel_plane *plane, struct intel_pipe *pipe)
 	return 0;
 }
 
-static int vlv_sp_validate(struct intel_plane *plane, struct intel_buffer *buf,
-		struct intel_plane_config *config)
+static int vlv_sp_validate(struct intel_plane *planeptr,
+		struct intel_buffer *buf, struct intel_plane_config *config)
 {
-	struct dsi_pipe *dsi_pipe;
-	struct drm_mode_modeinfo *mode;
+	struct intel_pipe *intel_pipe = config->pipe;
+	struct drm_mode_modeinfo mode;
 	u32 format_config, bpp;
 	bool visible = false;
-	struct rectangle clip;
 	u32 width, height;
-
-	struct rectangle src = {
+	int max_downscale = 1;
+	bool can_scale = false;
+	int hscale, vscale;
+	int max_scale;
+	int min_scale;
+	struct drm_rect clip;
+
+	struct drm_rect src = {
 		/* sample coordinates in 16.16 fixed point */
 		.x1 = config->src_x,
 		.x2 = config->src_x + config->src_w,
@@ -421,7 +387,7 @@ static int vlv_sp_validate(struct intel_plane *plane, struct intel_buffer *buf,
 		.y2 = config->src_y + config->src_h,
 	};
 
-	struct rectangle dst = {
+	struct drm_rect dst = {
 		/* integer pixels */
 		.x1 = config->dst_x,
 		.x2 = config->dst_x + config->dst_w,
@@ -446,18 +412,12 @@ static int vlv_sp_validate(struct intel_plane *plane, struct intel_buffer *buf,
 		return -ERANGE;
 	}
 
-	if (config->pipe->type == INTEL_PIPE_DSI) {
-		dsi_pipe = to_dsi_pipe(config->pipe);
-		mode = &dsi_pipe->config.perferred_mode;
-	} else {
-		/* handle HDMI pipe later */
-		return -EINVAL;
-	}
+	intel_pipe->ops->get_current_mode(intel_pipe, &mode);
 
 	clip.x1 = 0;
 	clip.y1 = 0;
-	clip.x2 = mode->hdisplay;
-	clip.y2 = mode->vdisplay;
+	clip.x2 = mode.hdisplay;
+	clip.y2 = mode.vdisplay;
 
 	if (get_format_config(buf->format, &format_config, &bpp,
 				config->alpha)) {
@@ -498,8 +458,16 @@ static int vlv_sp_validate(struct intel_plane *plane, struct intel_buffer *buf,
 		pr_err("ADF: unsupported tiling mode %s\n", __func__);
 		return -EINVAL;
 	}
+	max_scale = max_downscale << 16;
+	min_scale = can_scale ? 1 : (1 << 16);
+
+	hscale = drm_rect_calc_hscale_relaxed(&src, &dst, min_scale, max_scale);
+	BUG_ON(hscale < 0);
 
-	visible = rect_clip_scaled(&src, &dst, &clip);
+	vscale = drm_rect_calc_vscale_relaxed(&src, &dst, min_scale, max_scale);
+	BUG_ON(vscale < 0);
+
+	visible = drm_rect_clip_scaled(&src, &dst, &clip, hscale, vscale);
 
 	config->dst_x = dst.x1;
 	config->dst_y = dst.y1;
@@ -532,7 +500,7 @@ static int vlv_sp_validate(struct intel_plane *plane, struct intel_buffer *buf,
 		return -EINVAL;
 	}
 
-	return vlv_sp_calculate(plane, buf, config);
+	return vlv_sp_calculate(planeptr, buf, config);
 }
 
 static void vlv_sp_flip(struct intel_plane *planeptr, struct intel_buffer *buf,
@@ -550,10 +518,10 @@ static void vlv_sp_flip(struct intel_plane *planeptr, struct intel_buffer *buf,
 	REG_WRITE(SPLINOFF(pipe, plane), regs->linearoff);
 	REG_WRITE(SPSIZE(pipe, plane), regs->size);
 	REG_WRITE(SPCNTR(pipe, plane), regs->dspcntr);
+
 	I915_MODIFY_DISPBASE(SPSURF(pipe, plane), regs->surfaddr);
 	REG_POSTING_READ(SPSURF(pipe, plane));
-	vlv_update_plane_status(config->pipe,
-			plane ? VLV_SPRITE2 : VLV_SPRITE1, true);
+	splane->enabled = true;
 	/* Check for reserved register bit 2 */
 	val = REG_READ(SPSURF(pipe, plane));
 	if (config->flags & INTEL_ADF_PLANE_HW_PRIVATE_1) {
@@ -569,10 +537,15 @@ static void vlv_sp_flip(struct intel_plane *planeptr, struct intel_buffer *buf,
 	return;
 }
 
+bool vlv_sp_plane_is_enabled(struct vlv_sp_plane *splane)
+{
+	return splane->enabled;
+}
+
 static int vlv_sp_enable(struct intel_plane *planeptr)
 {
-	u32 reg, value;
 	struct vlv_sp_plane *splane = to_vlv_sp_plane(planeptr);
+	u32 reg, value;
 	int plane = splane->ctx.plane;
 	int pipe = splane->ctx.pipe;
 
@@ -580,13 +553,12 @@ static int vlv_sp_enable(struct intel_plane *planeptr)
 	value = REG_READ(reg);
 	if (value & DISPLAY_PLANE_ENABLE) {
 		return 0;
-		dev_dbg(planeptr->base.dev, "%splane already enabled\n",
+		dev_dbg(splane->base.base.dev, "%splane already enabled\n",
 				__func__);
 	}
 
+	splane->enabled = true;
 	REG_WRITE(reg, value | DISPLAY_PLANE_ENABLE);
-	vlv_update_plane_status(planeptr->pipe,
-			plane ? VLV_SPRITE2 : VLV_SPRITE1, true);
 	vlv_adf_flush_sp_plane(pipe, plane);
 	/*
 	 * TODO:No need to wait in case of mipi.
@@ -596,24 +568,23 @@ static int vlv_sp_enable(struct intel_plane *planeptr)
 	return 0;
 }
 
+
 static int vlv_sp_disable(struct intel_plane *planeptr)
 {
-	u32 reg, value, mask;
 	struct vlv_sp_plane *splane = to_vlv_sp_plane(planeptr);
+	u32 value, mask;
 	int plane = splane->ctx.plane;
 	int pipe = splane->ctx.pipe;
 
-	reg = SPCNTR(pipe, plane);
-	value = REG_READ(reg);
+	value = REG_READ(splane->offset);
 	if ((value & DISPLAY_PLANE_ENABLE) == 0) {
-		dev_dbg(planeptr->base.dev, "%splane already disabled\n",
+		dev_dbg(splane->base.base.dev, "%splane already disabled\n",
 				__func__);
 		return 0;
 	}
 
-	REG_WRITE(reg, value & ~DISPLAY_PLANE_ENABLE);
-	vlv_update_plane_status(planeptr->pipe,
-			plane ? VLV_SPRITE2 : VLV_SPRITE1, false);
+	splane->enabled = false;
+	REG_WRITE(splane->offset, value & ~DISPLAY_PLANE_ENABLE);
 	vlv_adf_flush_sp_plane(pipe, plane);
 	/* While disabling plane reset the plane DDL value */
 	if (plane == 0)
@@ -705,15 +676,20 @@ static const struct intel_plane_capabilities vlv_sp_caps = {
 	.n_supported_reservedbit = ARRAY_SIZE(sprite_supported_reservedbit),
 };
 
-int vlv_sp_plane_init(struct vlv_sp_plane *splane, struct device *dev, u8 idx)
+int vlv_sp_plane_init(struct vlv_sp_plane *splane,
+		struct intel_pipeline *pipeline, struct device *dev, u8 idx)
 {
 	int err;
+	pr_debug("ADF: %s\n", __func__);
 
 	if (!splane) {
 		dev_err(dev, "data provided is NULL\n");
 		return -EINVAL;
 	}
 	err = context_init(&splane->ctx, idx);
+
+	splane->offset = SPCNTR(splane->ctx.pipe, splane->ctx.plane);
+
 	if (err) {
 		dev_err(dev, "failed to init sprite context\n");
 		return err;
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
index 66a6a33..d88152a 100644
--- a/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
@@ -59,6 +59,7 @@ struct dsi_pipe {
 	struct intel_pipe base;
 	struct dsi_pipe_ops ops;
 	struct dsi_config config;
+	struct intel_pipeline *pipeline;
 #ifndef CONFIG_ADF_INTEL_VLV
 	struct dsi_pkg_sender sender;
 #endif
@@ -73,7 +74,8 @@ static inline struct dsi_pipe *to_dsi_pipe(struct intel_pipe *pipe)
 
 #ifdef CONFIG_ADF_INTEL_VLV
 extern int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
-	struct intel_plane *primary_plane, u8 idx);
+	struct intel_plane *primary_plane, u8 idx,
+	struct intel_pipeline *pipeline);
 #else
 extern int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 	struct intel_plane *primary_plane, u8 idx, u32 gtt_phy_addr);
diff --git a/drivers/video/adf/intel/include/core/intel_dc_config.h b/drivers/video/adf/intel/include/core/intel_dc_config.h
index e4737a5..ef80098 100644
--- a/drivers/video/adf/intel/include/core/intel_dc_config.h
+++ b/drivers/video/adf/intel/include/core/intel_dc_config.h
@@ -19,6 +19,7 @@
 #include <linux/module.h>
 #include <video/intel_adf.h>
 #include <drm/i915_adf.h>
+#include <core/common/dsi/dsi_config.h>
 
 #if defined(CONFIG_ADF)
 #include <video/adf.h>
@@ -32,6 +33,7 @@ struct intel_plane;
 struct intel_pipe;
 struct intel_dc_memory;
 struct intel_dc_power_ops;
+struct intel_pipeline;
 
 enum gen_id {
 	gen_invalid = 0,
@@ -44,6 +46,11 @@ enum gen_id {
 	gen_cherryview = 8,
 	gen_skylake,
 };
+enum pipe {
+	PIPE_A = 0,
+	PIPE_B,
+	PIPE_C,
+};
 
 #define IS_CHERRYVIEW() (intel_adf_get_platform_id() == gen_cherryview)
 #define IS_VALLEYVIEW() (intel_adf_get_platform_id() == gen_valleyview)
@@ -229,6 +236,7 @@ struct intel_plane {
 	struct intel_pipe *pipe;
 	const struct intel_plane_capabilities *caps;
 	const struct intel_plane_ops *ops;
+	struct intel_pipeline *pipeline;
 };
 
 enum intel_pipe_type {
@@ -286,6 +294,8 @@ struct intel_pipe_ops {
 		u16 *width_mm, u16 *height_mm);
 	bool (*is_screen_connected)(struct intel_pipe *pipe);
 
+	void (*get_current_mode)(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo *mode);
 	u32 (*get_supported_events)(struct intel_pipe *pipe);
 	int (*set_event)(struct intel_pipe *pipe, u16 event, bool enabled);
 	void (*get_events)(struct intel_pipe *pipe, u32 *active_events);
@@ -335,14 +345,14 @@ struct intel_pipe {
 	const struct intel_plane *primary_plane;
 	const struct intel_pipe_ops *ops;
 	bool dpst_enabled;
-
+	struct intel_pipeline *pipeline;
+	u32 vsync_counter;
 	/*
 	 * Store the computed reg values in this to apply in
 	 * one shot later in flip calls
 	 */
-	 struct pri_plane_regs regs;
-
-	 struct intel_global_status status;
+	struct pri_plane_regs regs;
+	struct intel_global_status status;
 };
 
 struct intel_dc_attachment {
@@ -350,6 +360,19 @@ struct intel_dc_attachment {
 	u8 pipe_id;
 };
 
+struct intel_pipeline {
+	union {
+		/* pass display specific params to pipeline code */
+		/* that might be needed across multiple calls */
+		struct {
+			struct dsi_config *dsi_config;
+		} dsi;
+		struct {
+			int temp;/*stub*/
+		} dp;
+	} params;
+};
+
 struct intel_dc_config {
 	struct device *dev;
 
@@ -371,7 +394,7 @@ struct intel_dc_config {
 };
 
 struct intel_dc_config_entry {
-	const u32 id;
+	const enum gen_id id;
 	struct intel_dc_config * (*get_dc_config)(struct pci_dev *pdev,
 		u32 id);
 	void (*destroy_dc_config)(struct intel_dc_config *config);
@@ -428,18 +451,21 @@ extern void intel_dc_config_add_plane(struct intel_dc_config *config,
 	struct intel_plane *plane, u8 idx);
 extern void intel_dc_config_add_pipe(struct intel_dc_config *config,
 	struct intel_pipe *pipe, u8 idx);
+
 static inline void intel_dc_config_add_memory(struct intel_dc_config *config,
 	struct intel_dc_memory *memory)
 {
 	if (config)
 		config->memory = memory;
 }
+
 static inline void intel_dc_config_add_power(struct intel_dc_config *config,
 	struct intel_dc_power *power)
 {
 	if (config)
 		config->power = power;
 }
+
 extern int intel_dc_config_init(struct intel_dc_config *config,
 	struct device *dev, const u32 id, size_t n_planes, size_t n_pipes,
 	const struct intel_dc_attachment *allowed_attachments,
@@ -450,8 +476,4 @@ extern struct intel_dc_config *intel_adf_get_dc_config(
 	struct pci_dev *pdev, const u32 id);
 extern void intel_adf_destroy_config(struct intel_dc_config *config);
 
-/* Supported configs */
-extern struct intel_dc_config *vlv_get_dc_config(struct pci_dev *pdev, u32 id);
-extern void vlv_dc_config_destroy(struct intel_dc_config *config);
-
 #endif /* INTEL_DC_CONFIG_H_ */
diff --git a/drivers/video/adf/intel/include/core/intel_platform_config.h b/drivers/video/adf/intel/include/core/intel_platform_config.h
new file mode 100644
index 0000000..ffeefdc
--- /dev/null
+++ b/drivers/video/adf/intel/include/core/intel_platform_config.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef INTEL_PLATFORM_CONFIG_H_
+#define INTEL_PLATFORM_CONFIG_H_
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <video/intel_adf.h>
+#include <core/intel_dc_config.h>
+
+#if defined(CONFIG_ADF)
+#include <video/adf.h>
+#endif
+
+bool vlv_wait_for_vblank(struct intel_pipeline *pipeline);
+void vlv_evade_vblank(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode, bool *wait_for_vblank);
+u32 vlv_dsi_prepare_on(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode);
+u32 vlv_dsi_pre_pipeline_on(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode);
+u32 vlv_pipeline_on(struct intel_pipeline *pipeline,
+		struct drm_mode_modeinfo *mode);
+u32 vlv_pipeline_off(struct intel_pipeline *pipeline);
+u32 vlv_post_pipeline_off(struct intel_pipeline *pipeline);
+bool vlv_is_screen_connected(struct intel_pipeline *pipeline);
+u32 vlv_dpst_context(struct intel_pipeline *pipeline, unsigned long args);
+u32 vlv_dpst_irq_handler(struct intel_pipeline *pipeline);
+u32 vlv_num_planes_enabled(struct intel_pipeline *pipeline);
+bool vlv_can_be_disabled(struct intel_pipeline *pipeline);
+bool vlv_update_maxfifo_status(struct intel_pipeline *pipeline, bool enable);
+u32 vlv_set_event(struct intel_pipeline *pipeline, u32 event, bool enabled);
+u32 vlv_get_event(struct intel_pipeline *pipeline, u32 *event);
+int vlv_enable_plane(struct intel_pipeline *pipeline,
+		struct intel_plane *plane);
+int vlv_disable_plane(struct intel_pipeline *pipeline,
+		struct intel_plane *plane);
+bool vlv_is_plane_enabled(struct intel_pipeline *pipeline,
+		struct intel_plane *plane);
+void vlv_flip(struct intel_pipeline *pipeline,
+		struct intel_plane *plane,
+		struct intel_buffer *buf,
+		struct intel_plane_config *config);
+int vlv_validate(struct intel_pipeline *pipeline,
+		struct intel_plane *plane,
+		struct intel_buffer *buf,
+		struct intel_plane_config *config);
+int vlv_validate_custom_format(struct intel_pipeline *pipeline,
+		struct intel_plane *plane, u32 format, u32 w, u32 h);
+bool vlv_is_vid_mode(struct intel_pipeline *pipeline);
+void vlv_cmd_hs_mode_enable(struct intel_pipeline *pipeline, bool enable);
+int vlv_cmd_vc_dcs_write(struct intel_pipeline *pipeline, int channel,
+		const u8 *data, int len);
+int vlv_cmd_vc_generic_write(struct intel_pipeline *pipeline, int channel,
+		const u8 *data, int len);
+int vlv_cmd_vc_dcs_read(struct intel_pipeline *pipeline, int channel,
+		u8 dcs_cmd, u8 *buf, int buflen);
+int vlv_cmd_vc_generic_read(struct intel_pipeline *pipeline, int channel,
+		u8 *reqdata, int reqlen, u8 *buf, int buflen);
+int vlv_cmd_dpi_send_cmd(struct intel_pipeline *pipeline, u32 cmd, bool hs);
+
+/*
+ * Supported configs can be declared here for use inside
+ * intel_adf_get_dc_config
+ */
+
+
+extern struct intel_dc_config *vlv_get_dc_config(struct pci_dev *pdev, u32 id);
+extern void vlv_dc_config_destroy(struct intel_dc_config *config);
+
+#endif /* INTEL_PLATFORM_CONFIG_H_ */
diff --git a/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h b/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h
index db8bb6d..9a8b5134 100644
--- a/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h
+++ b/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h
@@ -25,18 +25,19 @@
 #include <core/vlv/vlv_sp_plane.h>
 #include <core/vlv/vlv_dpst.h>
 #include <core/vlv/vlv_dsi_port.h>
+#include <core/vlv/vlv_pll.h>
+#include <core/vlv/vlv_pipe.h>
+#include <core/vlv/vlv_pm.h>
 
 #define VLV_N_PLANES	6
 #define VLV_N_PIPES	2
+
+#define CHV_N_PLANES	9
+#define CHV_N_PIPES	3
+
 #define VLV_NUM_SPRITES 2
 #define VLV_SP_12BIT_MASK 0xFFF
 
-enum pipe {
-	PIPE_A = 0,
-	PIPE_B,
-	MAX_PIPES,
-};
-
 enum planes {
 	PRIMARY_PLANE = 0,
 	SPRITE_A = 1,
@@ -44,6 +45,9 @@ enum planes {
 	SECONDARY_PLANE = 3,
 	SPRITE_C = 4,
 	SPRITE_D = 5,
+	TERTARY_PLANE = 6,
+	SPRITE_E = 7,
+	SPRITE_F = 8,
 	NUM_PLANES,
 };
 
@@ -62,7 +66,7 @@ static inline void vlv_gpio_write(u32 port, u32 reg, u32 val)
 static inline void vlv_flisdsi_write(u32 reg, u32 val)
 {
 	intel_adf_dpio_sideband_rw(INTEL_SIDEBAND_REG_WRITE, IOSF_PORT_FLISDSI,
-			      reg, &val);
+				reg, &val);
 }
 
 static inline void vlv_gpio_nc_write(u32 reg, u32 val)
@@ -89,33 +93,45 @@ static inline u32 vlv_cck_read(u32 reg)
 {
 	u32 val;
 	intel_adf_pci_sideband_rw(INTEL_SIDEBAND_REG_READ, IOSF_PORT_CCK,
-			       reg, &val);
+					reg, &val);
 	return val;
 }
 
 static inline void vlv_cck_write(u32 reg, u32 val)
 {
 	intel_adf_pci_sideband_rw(INTEL_SIDEBAND_REG_WRITE, IOSF_PORT_CCK,
-			       reg, &val);
+					reg, &val);
 }
+struct vlv_pipeline {
+	struct intel_pipeline base;
+	struct vlv_dpst *dpst;
+	struct vlv_pll pll;
+	struct vlv_pm pm;
+	struct vlv_pipe pipe;
+	struct vlv_pri_plane pplane;
+	struct vlv_sp_plane splane[2];
+	enum intel_pipe_type type;
+	union {
+		struct dsi_pipe dsi;
+		/* later we will have hdmi pipe */
+	} gen;
+	union {
+		struct vlv_dsi_port dsi_port;
+		/* later we will have hdmi port */
+	} port;
+
+};
 
 struct vlv_dc_config {
 	struct intel_dc_config base;
+	u32 max_pipes;
+	u32 max_planes;
 	struct vlv_dpst dpst;
-#ifdef CONFIG_DEBUG_FS
-	struct dentry	*debugfs_root;
-#endif
-	struct vlv_disp {
-		struct vlv_pri_plane pplane;
-		struct vlv_sp_plane splane[2];
-		enum intel_pipe_type type;
-		union {
-			struct dsi_pipe dsi;
-
-			/* later we will have hdmi pipe */
-		} pipe;
-
-	} vdisp[2];
+	/*
+	 * FIXME: For other platforms the number of pipes may
+	 * vary, which has to be handeled in future
+	 */
+	struct vlv_pipeline pipeline[CHV_N_PIPES];
 };
 
 static inline struct vlv_dc_config *to_vlv_dc_config(
@@ -124,20 +140,69 @@ static inline struct vlv_dc_config *to_vlv_dc_config(
 	return container_of(config, struct vlv_dc_config, base);
 }
 
-bool vlv_intf_screen_connected(struct intel_pipe *pipe);
-u32 vlv_intf_vsync_counter(struct intel_pipe *pipe, u32 interval);
-extern int pipe_mode_set(struct intel_pipe *pipe,
-			 struct drm_mode_modeinfo *mode);
-extern int vlv_display_on(struct intel_pipe *pipe);
-extern int vlv_display_off(struct intel_pipe *pipe);
-int vlv_num_planes_enabled(struct intel_pipe *pipe);
-void vlv_update_plane_status(struct intel_pipe *pipe, int plane, bool enabled);
+static inline struct vlv_pipeline *to_vlv_pipeline(
+	struct intel_pipeline *intel_pipeline)
+{
+	return container_of(intel_pipeline, struct vlv_pipeline, base);
+}
+
+bool vlv_intf_screen_connected(struct intel_pipeline *pipeline);
+u32 vlv_intf_vsync_counter(struct intel_pipeline *pipeline, u32 interval);
+
+/* vlv_modeset */
+extern bool vlv_wait_for_vblank(struct intel_pipeline *pipeline);
+extern void vlv_evade_vblank(struct intel_pipeline *pipeline,
+			struct drm_mode_modeinfo *mode, bool *wait_for_vblank);
+extern u32 vlv_dsi_prepare_on(struct intel_pipeline *pipeline,
+			struct drm_mode_modeinfo *mode);
+extern u32 vlv_dsi_pre_pipeline_on(struct intel_pipeline *pipeline,
+			struct drm_mode_modeinfo *mode);
+extern u32 vlv_pipeline_on(struct intel_pipeline *pipeline,
+			struct drm_mode_modeinfo *mode);
+extern u32 vlv_pipeline_off(struct intel_pipeline *pipeline);
+extern u32 vlv_post_pipeline_off(struct intel_pipeline *pipeline);
+extern bool vlv_is_screen_connected(struct intel_pipeline *pipeline);
+extern u32 vlv_num_planes_enabled(struct intel_pipeline *pipeline);
+extern bool vlv_is_vid_mode(struct intel_pipeline *pipeline);
+extern bool vlv_can_be_disabled(struct intel_pipeline *pipeline);
+extern bool vlv_update_maxfifo_status(struct intel_pipeline *pipeline,
+		bool enable);
+extern u32 vlv_get_event(struct intel_pipeline *pipeline, u32 *event);
+extern u32 vlv_set_event(struct intel_pipeline *pipeline, u32 event,
+		bool enabled);
+extern int vlv_cmd_dpi_send_cmd(struct intel_pipeline *pipeline, u32 cmd,
+		bool hs);
+extern int vlv_cmd_vc_generic_read(struct intel_pipeline *pipeline,
+		int channel, u8 *reqdata, int reqlen, u8 *buf, int buflen);
+extern int vlv_cmd_vc_dcs_read(struct intel_pipeline *pipeline, int channel,
+		u8 dcs_cmd, u8 *buf, int buflen);
+extern int vlv_cmd_vc_generic_write(struct intel_pipeline *pipeline,
+		int channel, const u8 *data, int len);
+extern int vlv_cmd_vc_dcs_write(struct intel_pipeline *pipeline, int channel,
+		const u8 *data, int len);
+extern void vlv_cmd_hs_mode_enable(struct intel_pipeline *pipeline,
+		bool enable);
+
+extern bool vlv_is_plane_enabled(struct intel_pipeline *pipeline,
+		struct intel_plane *plane);
+
+/* vlv_dpst */
+extern u32 vlv_dpst_context(struct intel_pipeline *pipeline,
+		unsigned long args);
+extern u32 vlv_dpst_irq_handler(struct intel_pipeline *pipeline);
+/* vlv_debugfs */
+extern int vlv_debugfs_init(struct vlv_dc_config *vlv_config);
+extern void vlv_debugfs_teardown(struct vlv_dc_config *vlv_config);
 
 /* port export functions */
 bool vlv_dsi_port_init(struct vlv_dsi_port *port, enum port, enum pipe);
 bool vlv_dsi_port_destroy(struct vlv_dsi_port *port);
 
-/* vlv_debugfs */
-extern int vlv_debugfs_init(struct vlv_dc_config *vlv_config);
-extern void vlv_debugfs_teardown(struct vlv_dc_config *vlv_config);
+/* reg access */
+extern u32 REG_READ(u32 reg);
+extern u32 REG_POSTING_READ(u32 reg);
+extern void REG_WRITE(u32 reg, u32 val);
+extern void REG_WRITE_BITS(u32 reg, u32 val, u32 mask);
+
+
 #endif
diff --git a/drivers/video/adf/intel/include/core/vlv/vlv_dpst.h b/drivers/video/adf/intel/include/core/vlv/vlv_dpst.h
index e2931ec..5527a3d 100644
--- a/drivers/video/adf/intel/include/core/vlv/vlv_dpst.h
+++ b/drivers/video/adf/intel/include/core/vlv/vlv_dpst.h
@@ -84,12 +84,17 @@ struct vlv_dpst {
 
 	struct mutex ioctl_lock;
 	struct vlv_dpst_registers reg;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry	*debugfs_root;
+#endif
+
 };
 
-extern void vlv_wait_for_vblank(int pipe);
+extern bool vlv_wait_for_vblank(struct intel_pipeline *pipeline);
 void vlv_dpst_init(struct intel_dc_config *config);
 void vlv_dpst_teardown(void);
-void vlv_dpst_irq_handler(struct intel_pipe *pipe);
+
+u32 vlv_dpst_irq_handler(struct intel_pipeline *pipeline);
 void vlv_dpst_display_on(void);
 void vlv_dpst_display_off(void);
 void vlv_dpst_set_brightness(struct intel_pipe *pipe, u32 brightness_val);
diff --git a/drivers/video/adf/intel/include/core/vlv/vlv_pri_plane.h b/drivers/video/adf/intel/include/core/vlv/vlv_pri_plane.h
index 43aa380..aeb404b 100644
--- a/drivers/video/adf/intel/include/core/vlv/vlv_pri_plane.h
+++ b/drivers/video/adf/intel/include/core/vlv/vlv_pri_plane.h
@@ -15,7 +15,7 @@
 #ifndef VLV_PRI_PLANE_H
 #define VLV_PRI_PLANE_H
 
-#include "core/intel_dc_config.h"
+#include <core/intel_dc_config.h>
 #include "vlv_dc_hw.h"
 
 enum {
@@ -35,8 +35,26 @@ struct vlv_pri_plane_context {
 	u32 plane;
 };
 
+struct vlv_pri_plane;
+
+struct vlv_plane_params {
+	/* data to be forwarded to plane object */
+	u8 dithering; /*stub */
+};
+
+bool vlv_pri_is_enabled(struct vlv_pri_plane *plane);
+int vlv_pri_update_params(struct vlv_pri_plane *plane,
+		struct vlv_plane_params *params);
+
 struct vlv_pri_plane {
 	struct intel_plane base;
+	u32 offset;
+	u32 surf_offset;
+	u32 stride_offset;
+	u32 tiled_offset;
+	u32 linear_offset;
+	bool enabled;
+
 	struct vlv_pri_plane_context ctx;
 };
 
@@ -45,9 +63,9 @@ static inline struct vlv_pri_plane *to_vlv_pri_plane(struct intel_plane *plane)
 	return container_of(plane, struct vlv_pri_plane, base);
 }
 
-int vlv_pri_plane_init(struct vlv_pri_plane *pplane,
-		struct device *dev, u8 idx);
-void vlv_pri_plane_destroy(struct vlv_pri_plane *plane);
+extern int vlv_pri_plane_init(struct vlv_pri_plane *pplane,
+		struct intel_pipeline *pipeline, struct device *dev, u8 idx);
+extern void vlv_pri_plane_destroy(struct vlv_pri_plane *plane);
 extern unsigned long vlv_compute_page_offset(int *x, int *y,
 					unsigned int tiling_mode,
 					unsigned int cpp,
diff --git a/drivers/video/adf/intel/include/core/vlv/vlv_sp_plane.h b/drivers/video/adf/intel/include/core/vlv/vlv_sp_plane.h
index 31a6a49..cb7c0fd 100644
--- a/drivers/video/adf/intel/include/core/vlv/vlv_sp_plane.h
+++ b/drivers/video/adf/intel/include/core/vlv/vlv_sp_plane.h
@@ -35,28 +35,24 @@ struct vlv_sp_plane_context {
 	u32 pipe;
 };
 
+struct vlv_sp_plane;
+
+bool vlv_sp_plane_is_enabled(struct vlv_sp_plane *splane);
+
 struct vlv_sp_plane {
 	struct intel_plane base;
+	u32 offset;
+	bool enabled;
 	struct vlv_sp_plane_context ctx;
 };
 
-/**
- * struct rectangle - two dimensional rectangle
- * @x1: horizontal starting coordinate (inclusive)
- * @x2: horizontal ending coordinate (exclusive)
- * @y1: vertical starting coordinate (inclusive)
- * @y2: vertical ending coordinate (exclusive)
-*/
-struct rectangle {
-	int x1, y1, x2, y2;
-};
-
 static inline struct vlv_sp_plane *to_vlv_sp_plane(struct intel_plane *plane)
 {
 	return container_of(plane, struct vlv_sp_plane, base);
 }
 
-int vlv_sp_plane_init(struct vlv_sp_plane *splane, struct device *dev, u8 idx);
+int vlv_sp_plane_init(struct vlv_sp_plane *splane,
+		struct intel_pipeline *pipeline, struct device *dev, u8 idx);
 void vlv_sp_plane_destroy(struct vlv_sp_plane *splane);
 
 #endif
diff --git a/drivers/video/adf/intel/include/intel_adf.h b/drivers/video/adf/intel/include/intel_adf.h
index de142e7..99118ad 100644
--- a/drivers/video/adf/intel/include/intel_adf.h
+++ b/drivers/video/adf/intel/include/intel_adf.h
@@ -51,5 +51,4 @@ extern void intel_adf_context_destroy(struct intel_adf_context *ctx);
 extern int intel_adf_context_on_event(void);
 extern int intel_adf_map_dma_to_flip(unsigned long args);
 extern int intel_adf_unmap_dma_to_flip(unsigned long args);
-extern int vlv_dpst_context(unsigned long args);
 #endif /* INTEL_ADF_H_ */
diff --git a/drivers/video/adf/intel/intel_adf_interface.c b/drivers/video/adf/intel/intel_adf_interface.c
index 4c00ded..fdcd478 100644
--- a/drivers/video/adf/intel/intel_adf_interface.c
+++ b/drivers/video/adf/intel/intel_adf_interface.c
@@ -16,10 +16,6 @@
 #include <video/adf_client.h>
 #include "intel_adf.h"
 
-#ifdef CONFIG_ADF_INTEL_VLV
-#include <core/vlv/vlv_dpst.h>
-#endif
-
 /* Custom IOCTL */
 static long intel_interface_obj_ioctl(struct adf_obj *obj,
 	unsigned int cmd, unsigned long arg)
-- 
1.7.9.5

