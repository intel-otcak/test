From 1ad984ccacdabaaa46f548093c73c97035d04d3e Mon Sep 17 00:00:00 2001
From: Mikael Persson <mikael.persson@intel.com>
Date: Wed, 24 Feb 2016 18:03:42 +0100
Subject: [PATCH 1/2] camera: Remove CTP (CSS2300) support.

CTP is no longer supported.

Change-Id: Ic3be94aa52a215f2f03823fbce0f219d6cd63492
Original-Tracked-On: https://jira01.devtools.intel.com/browse/OAM-20599
Signed-off-by: Mikael Persson <mikael.persson@intel.com>
Reviewed-on: https://icggerrit.ir.intel.com/103835
Build: Dessert M BXT RVP (SC)
Build: Dessert M CHT FFD (SC)
Validation-Android: Wei Tao <wei.tao@intel.com>
Reviewed-by: Jose R Sapiens <jose.r.sapiens@intel.com>
Reviewed-by: Jukka O Kaartinen <jukka.o.kaartinen@intel.com>
Reviewed-by: Lassi I Vaatamoinen <lassi.i.vaatamoinen@intel.com>
Approver: Yunliang Ding <yunliang.ding@intel.com>
Integrator: WeiX Meng <weix.meng@intel.com>
Reviewed-by: WeiX Meng <weix.meng@intel.com>
Tracked-On: https://jira01.devtools.intel.com/browse/OAM-24395
Signed-off-by: Tao Wei <wei.tao@intel.com>
Signed-off-by: Yang Fan F <fan.f.yang@intel.com>
Reviewed-on: https://android.intel.com:443/483546
---
 .../camera/drivers/media/pci/atomisp2/Makefile     |    3 -
 .../atomisp2/atomisp_driver_css15/atomisp-regs.h   |  188 -
 .../atomisp2/atomisp_driver_css15/atomisp_acc.c    |  536 --
 .../atomisp2/atomisp_driver_css15/atomisp_acc.h    |  122 -
 .../atomisp2/atomisp_driver_css15/atomisp_cmd.c    | 4485 ----------
 .../atomisp2/atomisp_driver_css15/atomisp_cmd.h    |  333 -
 .../atomisp2/atomisp_driver_css15/atomisp_common.h |   82 -
 .../atomisp2/atomisp_driver_css15/atomisp_compat.h |  556 --
 .../atomisp_driver_css15/atomisp_compat_css15.c    | 1576 ----
 .../atomisp_driver_css15/atomisp_compat_css15.h    |  138 -
 .../atomisp_driver_css15/atomisp_compat_css20.c    | 3559 --------
 .../atomisp_driver_css15/atomisp_compat_css20.h    |  237 -
 .../atomisp_driver_css15/atomisp_compat_ioctl32.c  | 1116 ---
 .../atomisp_driver_css15/atomisp_compat_ioctl32.h  |  342 -
 .../atomisp2/atomisp_driver_css15/atomisp_csi2.c   |  310 -
 .../atomisp2/atomisp_driver_css15/atomisp_csi2.h   |   58 -
 .../atomisp2/atomisp_driver_css15/atomisp_file.c   |  296 -
 .../atomisp2/atomisp_driver_css15/atomisp_file.h   |   47 -
 .../atomisp2/atomisp_driver_css15/atomisp_fops.c   |  966 ---
 .../atomisp2/atomisp_driver_css15/atomisp_fops.h   |   60 -
 .../pci/atomisp2/atomisp_driver_css15/atomisp_fw.h |   81 -
 .../atomisp2/atomisp_driver_css15/atomisp_helper.h |   33 -
 .../atomisp_driver_css15/atomisp_internal.h        |  325 -
 .../atomisp2/atomisp_driver_css15/atomisp_ioctl.c  | 2481 ------
 .../atomisp2/atomisp_driver_css15/atomisp_ioctl.h  |   68 -
 .../atomisp2/atomisp_driver_css15/atomisp_subdev.c | 1138 ---
 .../atomisp2/atomisp_driver_css15/atomisp_subdev.h |  356 -
 .../atomisp2/atomisp_driver_css15/atomisp_tables.h |  366 -
 .../atomisp2/atomisp_driver_css15/atomisp_tpg.c    |  253 -
 .../atomisp2/atomisp_driver_css15/atomisp_tpg.h    |   42 -
 .../atomisp_driver_css15/atomisp_trace_event.h     |   93 -
 .../atomisp2/atomisp_driver_css15/atomisp_v4l2.c   | 1492 ----
 .../atomisp2/atomisp_driver_css15/atomisp_v4l2.h   |   35 -
 .../pci/atomisp2/atomisp_driver_css15/hmm/hmm.c    |  506 --
 .../pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo.c | 1247 ---
 .../atomisp2/atomisp_driver_css15/hmm/hmm_bo_dev.c |  336 -
 .../atomisp_driver_css15/hmm/hmm_dynamic_pool.c    |  239 -
 .../atomisp_driver_css15/hmm/hmm_reserved_pool.c   |  239 -
 .../pci/atomisp2/atomisp_driver_css15/hmm/hmm_vm.c |  218 -
 .../atomisp_driver_css15/hrt/device_access.c       |  140 -
 .../hrt/hive_isp_css_custom_host_hrt.h             |  107 -
 .../atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.c |  193 -
 .../atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.h |   92 -
 .../atomisp_driver_css15/hrt/memory_access.c       |  383 -
 .../atomisp_driver_css15/include/hmm/hmm.h         |   98 -
 .../atomisp_driver_css15/include/hmm/hmm_bo.h      |  314 -
 .../atomisp_driver_css15/include/hmm/hmm_bo_dev.h  |  136 -
 .../atomisp_driver_css15/include/hmm/hmm_common.h  |   76 -
 .../atomisp_driver_css15/include/hmm/hmm_pool.h    |  122 -
 .../atomisp_driver_css15/include/hmm/hmm_vm.h      |   68 -
 .../atomisp_driver_css15/include/mmu/isp_mmu.h     |  180 -
 .../atomisp_driver_css15/include/mmu/sh_mmu.h      |   76 -
 .../atomisp_driver_css15/include/mmu/sh_mmu_mfld.h |   28 -
 .../include/mmu/sh_mmu_mrfld.h                     |   28 -
 .../atomisp2/atomisp_driver_css15/mmu/isp_mmu.c    |  620 --
 .../atomisp_driver_css15/mmu/sh_mmu_mfld.c         |   89 -
 .../atomisp_driver_css15/mmu/sh_mmu_mrfld.c        |  100 -
 .../css2300/hive_isp_css_include/addr_support.h    |   28 -
 .../css2300/hive_isp_css_include/assert_support.h  |   60 -
 .../atomisp2/css2300/hive_isp_css_include/debug.h  |   47 -
 .../device_access/device_access.h                  |  178 -
 .../atomisp2/css2300/hive_isp_css_include/dma.h    |   47 -
 .../atomisp2/css2300/hive_isp_css_include/event.h  |   46 -
 .../css2300/hive_isp_css_include/fifo_monitor.h    |   46 -
 .../css2300/hive_isp_css_include/gdc_device.h      |   48 -
 .../css2300/hive_isp_css_include/gp_device.h       |   46 -
 .../atomisp2/css2300/hive_isp_css_include/gpio.h   |   46 -
 .../atomisp2/css2300/hive_isp_css_include/hmem.h   |   46 -
 .../hive_isp_css_include/host/debug_public.h       |   99 -
 .../css2300/hive_isp_css_include/host/dma_public.h |   57 -
 .../hive_isp_css_include/host/event_public.h       |   78 -
 .../host/fifo_monitor_public.h                     |  109 -
 .../css2300/hive_isp_css_include/host/gdc_public.h |   48 -
 .../hive_isp_css_include/host/gp_device_public.h   |   57 -
 .../hive_isp_css_include/host/gpio_public.h        |   44 -
 .../host/ia_css_i_rmgr_public.h                    |   21 -
 .../host/ia_css_i_rmgr_vbuf_public.h               |   30 -
 .../host/input_formatter_public.h                  |   93 -
 .../host/input_system_public.h                     |  241 -
 .../css2300/hive_isp_css_include/host/irq_public.h |  177 -
 .../css2300/hive_isp_css_include/host/isp_public.h |  180 -
 .../css2300/hive_isp_css_include/host/mmu_public.h |   75 -
 .../hive_isp_css_include/host/queue_public.h       |  100 -
 .../css2300/hive_isp_css_include/host/sp_public.h  |  225 -
 .../hive_isp_css_include/host/sw_event_public.h    |   44 -
 .../css2300/hive_isp_css_include/host/tag_public.h |   40 -
 .../hive_isp_css_include/host/timed_ctrl_public.h  |   60 -
 .../hive_isp_css_include/host/vamem_public.h       |   19 -
 .../css2300/hive_isp_css_include/ia_css_i_rmgr.h   |   72 -
 .../css2300/hive_isp_css_include/input_formatter.h |   46 -
 .../css2300/hive_isp_css_include/input_system.h    |   46 -
 .../atomisp2/css2300/hive_isp_css_include/irq.h    |   46 -
 .../atomisp2/css2300/hive_isp_css_include/isp.h    |   46 -
 .../css2300/hive_isp_css_include/math_support.h    |  383 -
 .../memory_access/memory_access.h                  |  274 -
 .../css2300/hive_isp_css_include/mmu_device.h      |   48 -
 .../hive_isp_css_include/platform_support.h        |   57 -
 .../css2300/hive_isp_css_include/print_support.h   |   41 -
 .../program_load/program_load.h                    |   23 -
 .../atomisp2/css2300/hive_isp_css_include/queue.h  |   45 -
 .../css2300/hive_isp_css_include/resource.h        |   47 -
 .../atomisp2/css2300/hive_isp_css_include/socket.h |   47 -
 .../pci/atomisp2/css2300/hive_isp_css_include/sp.h |   46 -
 .../css2300/hive_isp_css_include/stdbool/stdbool.h |   46 -
 .../css2300/hive_isp_css_include/stdint/stdint.h   |   79 -
 .../css2300/hive_isp_css_include/storage_class.h   |   27 -
 .../css2300/hive_isp_css_include/stream_buffer.h   |   47 -
 .../css2300/hive_isp_css_include/sw_event.h        |   56 -
 .../css2300/hive_isp_css_include/system_types.h    |   19 -
 .../atomisp2/css2300/hive_isp_css_include/tag.h    |   45 -
 .../css2300/hive_isp_css_include/timed_ctrl.h      |   46 -
 .../atomisp2/css2300/hive_isp_css_include/vamem.h  |   46 -
 .../css2300/hive_isp_css_include/vector_func.h     |   31 -
 .../css2300/hive_isp_css_include/vector_ops.h      |   31 -
 .../host/ia_css_i_rmgr_shared.c                    |   33 -
 .../host/ia_css_i_rmgr_vbuf_shared.c               |  288 -
 .../host/ia_css_i_rmgr_vbuf_shared.h               |   43 -
 .../css2300/hive_isp_css_shared/host/queue.c       |  677 --
 .../css2300/hive_isp_css_shared/host/queue_local.h |   19 -
 .../hive_isp_css_shared/host/queue_private.h       |   17 -
 .../css2300/hive_isp_css_shared/host/sw_event.c    |   82 -
 .../hive_isp_css_shared/host/sw_event_local.h      |   29 -
 .../hive_isp_css_shared/host/sw_event_private.h    |   27 -
 .../css2300/hive_isp_css_shared/host/tag.c         |   66 -
 .../css2300/hive_isp_css_shared/host/tag_local.h   |   21 -
 .../css2300/hive_isp_css_shared/host/tag_private.h |   17 -
 .../css2300/hive_isp_css_shared/queue_global.h     |   18 -
 .../css2300/hive_isp_css_shared/socket_global.h    |   52 -
 .../hive_isp_css_shared/stream_buffer_global.h     |   25 -
 .../css2300/hive_isp_css_shared/sw_event_global.h  |   39 -
 .../css2300/hive_isp_css_shared/tag_global.h       |   40 -
 .../css2300/hive_isp_css_system/debug_global.h     |   69 -
 .../css2300/hive_isp_css_system/dma_global.h       |  233 -
 .../css2300/hive_isp_css_system/event_global.h     |   19 -
 .../hive_isp_css_system/fifo_monitor_global.h      |   23 -
 .../css2300/hive_isp_css_system/gdc_global.h       |   73 -
 .../css2300/hive_isp_css_system/gp_device_global.h |   76 -
 .../css2300/hive_isp_css_system/gpio_global.h      |   44 -
 .../css2300/hive_isp_css_system/host/debug.c       |   76 -
 .../css2300/hive_isp_css_system/host/debug_local.h |   20 -
 .../hive_isp_css_system/host/debug_private.h       |  101 -
 .../css2300/hive_isp_css_system/host/dma.c         |  287 -
 .../css2300/hive_isp_css_system/host/dma_local.h   |  170 -
 .../css2300/hive_isp_css_system/host/dma_private.h |   43 -
 .../css2300/hive_isp_css_system/host/event.c       |   19 -
 .../css2300/hive_isp_css_system/host/event_local.h |   56 -
 .../hive_isp_css_system/host/event_private.h       |   82 -
 .../hive_isp_css_system/host/fifo_monitor.c        |  477 --
 .../hive_isp_css_system/host/fifo_monitor_local.h  |   87 -
 .../host/fifo_monitor_private.h                    |   78 -
 .../css2300/hive_isp_css_system/host/gdc.c         |  116 -
 .../css2300/hive_isp_css_system/host/gdc_local.h   |   19 -
 .../css2300/hive_isp_css_system/host/gdc_private.h |   19 -
 .../css2300/hive_isp_css_system/host/gp_device.c   |  113 -
 .../hive_isp_css_system/host/gp_device_local.h     |  108 -
 .../hive_isp_css_system/host/gp_device_private.h   |   45 -
 .../css2300/hive_isp_css_system/host/gpio_local.h  |   19 -
 .../hive_isp_css_system/host/gpio_private.h        |   43 -
 .../host/hive_isp_css_hrt_modified.h               |   95 -
 .../hive_isp_css_system/host/input_formatter.c     |  127 -
 .../host/input_formatter_local.h                   |   77 -
 .../host/input_formatter_private.h                 |   45 -
 .../hive_isp_css_system/host/input_system.c        |  198 -
 .../hive_isp_css_system/host/input_system_local.h  |  296 -
 .../host/input_system_private.h                    |  121 -
 .../css2300/hive_isp_css_system/host/irq.c         |  327 -
 .../css2300/hive_isp_css_system/host/irq_local.h   |   82 -
 .../css2300/hive_isp_css_system/host/irq_private.h |   43 -
 .../css2300/hive_isp_css_system/host/isp.c         |   75 -
 .../css2300/hive_isp_css_system/host/isp_local.h   |   50 -
 .../css2300/hive_isp_css_system/host/isp_private.h |  145 -
 .../css2300/hive_isp_css_system/host/mmu.c         |   42 -
 .../css2300/hive_isp_css_system/host/mmu_local.h   |   22 -
 .../css2300/hive_isp_css_system/host/mmu_private.h |   43 -
 .../atomisp2/css2300/hive_isp_css_system/host/sp.c |   71 -
 .../css2300/hive_isp_css_system/host/sp_local.h    |  104 -
 .../css2300/hive_isp_css_system/host/sp_private.h  |  192 -
 .../hive_isp_css_system/host/system_local.h        |  128 -
 .../css2300/hive_isp_css_system/host/timed_ctrl.c  |   76 -
 .../hive_isp_css_system/host/timed_ctrl_local.h    |   19 -
 .../hive_isp_css_system/host/timed_ctrl_private.h  |   34 -
 .../css2300/hive_isp_css_system/host/vamem_local.h |   19 -
 .../hive_isp_css_system/input_formatter_global.h   |   70 -
 .../hive_isp_css_system/input_system_global.h      |   88 -
 .../css2300/hive_isp_css_system/irq_global.h       |   37 -
 .../css2300/hive_isp_css_system/isp_global.h       |   69 -
 .../css2300/hive_isp_css_system/mmu_global.h       |   21 -
 .../css2300/hive_isp_css_system/resource_global.h  |   34 -
 .../css2300/hive_isp_css_system/sp_global.h        |   71 -
 .../css2300/hive_isp_css_system/system_global.h    |  206 -
 .../hive_isp_css_system/timed_ctrl_global.h        |   50 -
 .../css2300/hive_isp_css_system/vamem_global.h     |   33 -
 .../drivers/media/pci/atomisp2/css2300/hrt/bits.h  |  113 -
 .../media/pci/atomisp2/css2300/hrt/cell_params.h   |   51 -
 .../atomisp2/css2300/hrt/css_receiver_ahb_defs.h   |  179 -
 .../drivers/media/pci/atomisp2/css2300/hrt/defs.h  |   45 -
 .../media/pci/atomisp2/css2300/hrt/dma_v1_defs.h   |  180 -
 .../drivers/media/pci/atomisp2/css2300/hrt/embed.h |   38 -
 .../media/pci/atomisp2/css2300/hrt/gdc_defs.h      |  111 -
 .../media/pci/atomisp2/css2300/hrt/gp_regs_defs.h  |   31 -
 .../pci/atomisp2/css2300/hrt/gpio_block_defs.h     |   51 -
 .../pci/atomisp2/css2300/hrt/hive_isp_css_defs.h   |  200 -
 .../css2300/hrt/hive_isp_css_host_ids_hrt.h        |   67 -
 .../pci/atomisp2/css2300/hrt/hive_isp_css_if_hrt.h |   43 -
 .../css2300/hrt/hive_isp_css_irq_types_hrt.h       |   78 -
 .../hive_isp_css_streaming_monitors_types_hrt.h    |   72 -
 .../hrt/hive_isp_css_streaming_to_mipi_types_hrt.h |   37 -
 .../media/pci/atomisp2/css2300/hrt/hive_types.h    |  137 -
 .../media/pci/atomisp2/css2300/hrt/if_defs.h       |   31 -
 .../pci/atomisp2/css2300/hrt/input_switch_defs.h   |   39 -
 .../pci/atomisp2/css2300/hrt/irq_controller_defs.h |   37 -
 .../atomisp2/css2300/hrt/isp2300_medfield_params.h |  179 -
 .../media/pci/atomisp2/css2300/hrt/master_port.h   |  111 -
 .../media/pci/atomisp2/css2300/hrt/mmu_defs.h      |   32 -
 .../atomisp2/css2300/hrt/scalar_processor_params.h |   29 -
 .../media/pci/atomisp2/css2300/hrt/sp_hrt.h        |   31 -
 .../media/pci/atomisp2/css2300/hrt/str2mem_defs.h  |   48 -
 .../atomisp2/css2300/hrt/streaming_to_mipi_defs.h  |   37 -
 .../atomisp2/css2300/hrt/timed_controller_defs.h   |   31 -
 .../media/pci/atomisp2/css2300/hrt/version.h       |   29 -
 .../drivers/media/pci/atomisp2/css2300/sh_css.c    | 8669 --------------------
 .../drivers/media/pci/atomisp2/css2300/sh_css.h    | 2569 ------
 .../media/pci/atomisp2/css2300/sh_css_accelerate.c |  271 -
 .../media/pci/atomisp2/css2300/sh_css_accelerate.h |  107 -
 .../media/pci/atomisp2/css2300/sh_css_binary.c     |  872 --
 .../media/pci/atomisp2/css2300/sh_css_binary.h     |  182 -
 .../media/pci/atomisp2/css2300/sh_css_debug.c      | 2069 -----
 .../media/pci/atomisp2/css2300/sh_css_debug.h      |  293 -
 .../pci/atomisp2/css2300/sh_css_debug_internal.h   |  101 -
 .../media/pci/atomisp2/css2300/sh_css_defs.h       |  392 -
 .../media/pci/atomisp2/css2300/sh_css_firmware.c   |  154 -
 .../media/pci/atomisp2/css2300/sh_css_firmware.h   |   59 -
 .../media/pci/atomisp2/css2300/sh_css_hrt.c        |  576 --
 .../media/pci/atomisp2/css2300/sh_css_hrt.h        |   68 -
 .../media/pci/atomisp2/css2300/sh_css_internal.h   | 1079 ---
 .../media/pci/atomisp2/css2300/sh_css_metrics.c    |  180 -
 .../media/pci/atomisp2/css2300/sh_css_metrics.h    |   83 -
 .../pci/atomisp2/css2300/sh_css_param_shading.c    |  581 --
 .../pci/atomisp2/css2300/sh_css_param_shading.h    |   60 -
 .../media/pci/atomisp2/css2300/sh_css_params.c     | 6548 ---------------
 .../media/pci/atomisp2/css2300/sh_css_params.h     |  405 -
 .../pci/atomisp2/css2300/sh_css_params_internal.h  |   36 -
 .../media/pci/atomisp2/css2300/sh_css_pipeline.c   |  120 -
 .../media/pci/atomisp2/css2300/sh_css_pipeline.h   |   57 -
 .../media/pci/atomisp2/css2300/sh_css_refcount.c   |  318 -
 .../media/pci/atomisp2/css2300/sh_css_refcount.h   |   55 -
 .../drivers/media/pci/atomisp2/css2300/sh_css_rx.c |  441 -
 .../drivers/media/pci/atomisp2/css2300/sh_css_rx.h |   40 -
 .../drivers/media/pci/atomisp2/css2300/sh_css_sp.c | 1354 ---
 .../drivers/media/pci/atomisp2/css2300/sh_css_sp.h |  238 -
 .../media/pci/atomisp2/css2300/sh_css_sp_start.c   |   98 -
 .../media/pci/atomisp2/css2300/sh_css_sp_start.h   |   56 -
 .../media/pci/atomisp2/css2300/sh_css_types.h      | 1035 ---
 .../drivers/media/pci/atomisp2/css2300/sh_css_v2.h |  124 -
 .../media/pci/atomisp2/css2300/spmem_dump.c        | 1851 -----
 .../media/pci/atomisp2/css2300_build/Makefile      |   19 -
 .../pci/atomisp2/css2300_build/atomisp_driver      |    1 -
 .../drivers/media/pci/atomisp2/css2300_build/css   |    1 -
 258 files changed, 71930 deletions(-)
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp-regs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_common.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fw.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_helper.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_internal.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tables.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_trace_event.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo_dev.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_dynamic_pool.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_reserved_pool.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_vm.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/device_access.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_custom_host_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/memory_access.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo_dev.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_common.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_pool.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_vm.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/isp_mmu.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mfld.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mrfld.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/isp_mmu.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mfld.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mrfld.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/addr_support.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/assert_support.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/debug.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/device_access/device_access.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/dma.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/event.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/fifo_monitor.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gdc_device.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gp_device.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gpio.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/hmem.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/debug_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/dma_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/event_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/fifo_monitor_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gdc_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gp_device_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gpio_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_formatter_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_system_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/irq_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/isp_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/mmu_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/queue_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sp_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sw_event_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/tag_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/timed_ctrl_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/vamem_public.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/ia_css_i_rmgr.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_formatter.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_system.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/irq.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/isp.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/math_support.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/memory_access/memory_access.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/mmu_device.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/platform_support.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/print_support.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/program_load/program_load.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/queue.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/resource.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/socket.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sp.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdbool/stdbool.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdint/stdint.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/storage_class.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stream_buffer.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sw_event.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/system_types.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/tag.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/timed_ctrl.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vamem.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_func.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_ops.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/queue_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/socket_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/stream_buffer_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/sw_event_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/tag_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/debug_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/dma_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/event_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/fifo_monitor_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gdc_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gp_device_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gpio_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/hive_isp_css_hrt_modified.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/system_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_private.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/vamem_local.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_formatter_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_system_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/irq_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/isp_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/mmu_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/resource_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/sp_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/system_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/timed_ctrl_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/vamem_global.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/bits.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/cell_params.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/css_receiver_ahb_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/dma_v1_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/embed.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gdc_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gp_regs_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gpio_block_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_host_ids_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_if_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_irq_types_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_monitors_types_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_types.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/if_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/input_switch_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/irq_controller_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/isp2300_medfield_params.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/master_port.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/mmu_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/scalar_processor_params.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/sp_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/str2mem_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/streaming_to_mipi_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/timed_controller_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/version.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug_internal.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_defs.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_internal.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params_internal.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_types.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_v2.h
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/spmem_dump.c
 delete mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/Makefile
 delete mode 120000 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/atomisp_driver
 delete mode 120000 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/css

diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile
index f723651..49ad692 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/Makefile
@@ -15,9 +15,6 @@ ifdef CONFIG_GMIN_INTEL_MID
 obj-$(CONFIG_VIDEO_ATOMISP) += css2400b0_v21_build/
 obj-$(CONFIG_VIDEO_ATOMISP) += css2401a0_v21_build/
 else
-ifeq ($(CONFIG_64BIT), )
-	obj-$(CONFIG_VIDEO_ATOMISP) += css2300_build/
-endif
 obj-$(CONFIG_VIDEO_ATOMISP) += css2400b0_v21_build/
 obj-$(CONFIG_VIDEO_ATOMISP) += css2401a0_legacy_v21_build/
 obj-$(CONFIG_VIDEO_ATOMISP) += css2401a0_v21_build/
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp-regs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp-regs.h
deleted file mode 100644
index c9d29e2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp-regs.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef ATOMISP_REGS_H
-#define ATOMISP_REGS_H
-
-/* common register definitions */
-#define PUNIT_PORT		0x04
-
-#define PCICMDSTS		0x01
-#define INTR			0x0f
-#define MSI_CAPID		0x24
-#define MSI_ADDRESS		0x25
-#define MSI_DATA		0x26
-#define INTR_CTL		0x27
-
-#define PCI_MSI_CAPID		0x90
-#define PCI_MSI_ADDR		0x94
-#define PCI_MSI_DATA		0x98
-#define PCI_INTERRUPT_CTRL	0x9C
-#define PCI_I_CONTROL		0xfc
-
-/* MFLD specific register definitions */
-#define MFLD_IUNITPHY_PORT	0x09
-
-#define MFLD_CSI_RCOMP		0x00
-#define MFLD_CSI_AFE		0x02
-#define MFLD_CSI_CONTROL	0x03
-#define MFLD_CG_DIS		0x36
-#define MFLD_OR1		0x72
-
-#define MFLD_PCI_PMCS		0xd4
-#define MFLD_PCI_CG_DIS		0xd8
-
-/*
- * Enables the combining of adjacent 32-byte read requests to the same
- * cache line. When cleared, each 32-byte read request is sent as a
- * separate request on the IB interface.
- */
-#define MFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING	BIT(16)
-
-/*
- * Enables the combining of adjacent 32-byte write requests to the same
- * cache line. When cleared, each 32-byte write request is sent as a
- * separate request on the IB interface.
- */
-#define MFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING	BIT(17)
-
-/* Ensure the correct bits are set for the clock gating disable regster */
-#define MFLD_PCI_CG_DIS_DISABLED_ISPCLK		BIT(0)
-#define MFLD_PCI_CG_DIS_DISABLED_PERF_MON	BIT(2)
-#define MFLD_PCI_CG_DIS_DISABLED_NOA_MON	BIT(3)
-
-/* The MIPI1 and MIPI4 interface and lanes configuration */
-#define MFLD_CSI_CONTROL_DIS_MIPI1_IF	BIT(8)
-#define MFLD_CSI_CONTROL_DIS_MIPI4_IF	BIT(9)
-#define MFLD_CSI_CONTROL_EN_MIPI1_LANE	BIT(10)
-#define MFLD_CSI_CONTROL_EN_MIPI4_LANE	(BIT(11) | BIT(12) | BIT(13) | BIT(14))
-
-#define MFLD_MAX_ZOOM_FACTOR	64
-
-/* MRFLD specific register definitions */
-#define MRFLD_CSI_AFE		0x39
-#define MRFLD_CSI_CONTROL	0x3a
-#define MRFLD_CSI_RCOMP		0x3d
-
-#define MRFLD_PCI_PMCS		0x84
-#define MRFLD_PCI_CSI_ACCESS_CTRL_VIOL	0xd4
-#define MRFLD_PCI_CSI_AFE_HS_CONTROL	0xdc
-#define MRFLD_PCI_CSI_AFE_RCOMP_CONTROL	0xe0
-#define MRFLD_PCI_CSI_CONTROL		0xe8
-#define MRFLD_PCI_CSI_AFE_TRIM_CONTROL	0xe4
-#define MRFLD_PCI_CSI_DEADLINE_CONTROL	0xec
-#define MRFLD_PCI_CSI_RCOMP_CONTROL	0xf4
-
-/* Select Arasan (legacy)/Intel input system */
-#define MRFLD_PCI_CSI_CONTROL_PARPATHEN	BIT(24)
-
-/*
- * Enables the combining of adjacent 32-byte read requests to the same
- * cache line. When cleared, each 32-byte read request is sent as a
- * separate request on the IB interface.
- */
-#define MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING	0x1
-
-/*
- * Register: MRFLD_PCI_CSI_RCOMP_CONTROL
- * If cleared, the high speed clock going to the digital logic is gated when
- * RCOMP update is happening. The clock is gated for a minimum of 100 nsec.
- * If this bit is set, then the high speed clock is not gated during the
- * update cycle.
- */
-#define MRFLD_PCI_CSI_HS_OVR_CLK_GATE_ON_UPDATE		0x800000
-
-/*
- * Enables the combining of adjacent 32-byte write requests to the same
- * cache line. When cleared, each 32-byte write request is sent as a
- * separate request on the IB interface.
- */
-#define MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING	0x2
-
-#define MRFLD_PCI_CSI1_HSRXCLKTRIM		0x2
-#define MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT	16
-#define MRFLD_PCI_CSI2_HSRXCLKTRIM		0x3
-#define MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT	24
-#define MRFLD_PCI_CSI3_HSRXCLKTRIM		0x2
-#define MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT	28
-#define MRFLD_PCI_CSI_HSRXCLKTRIM_MASK		0xf
-
-/*
- * This register is IUINT MMIO register, it is used to select the CSI
- * receiver backend.
- * 1: SH CSI backend
- * 0: Arasan CSI backend
- */
-#define MRFLD_CSI_RECEIVER_SELECTION_REG       0x8081c
-
-#define MRFLD_INTR_CLEAR_REG		       0x50c
-#define MRFLD_INTR_STATUS_REG		       0x508
-#define MRFLD_INTR_ENABLE_REG		       0x510
-
-#define MRFLD_MAX_ZOOM_FACTOR	1024
-
-/* MRFLD ISP POWER related */
-#define MRFLD_ISPSSPM0         0x39
-#define MRFLD_ISPSSPM0_ISPSSC_OFFSET   0
-#define MRFLD_ISPSSPM0_ISPSSS_OFFSET   24
-#define MRFLD_ISPSSPM0_ISPSSC_MASK     0x3
-#define MRFLD_ISPSSPM0_IUNIT_POWER_ON  0
-#define MRFLD_ISPSSPM0_IUNIT_POWER_OFF 0x3
-
-/* MRFLD CSI lane configuration related */
-#define MRFLD_PORT_CONFIG_NUM  8
-#define MRFLD_PORT_NUM         3
-#define MRFLD_PORT1_ENABLE_SHIFT       0
-#define MRFLD_PORT2_ENABLE_SHIFT       1
-#define MRFLD_PORT3_ENABLE_SHIFT       2
-#define MRFLD_PORT1_LANES_SHIFT        3
-#define MRFLD_PORT2_LANES_SHIFT        7
-#define MRFLD_PORT3_LANES_SHIFT        8
-#define MRFLD_PORT_CONFIG_MASK 0x000f03ff
-#define MRFLD_PORT_CONFIGCODE_SHIFT    16
-#define MRFLD_ALL_CSI_PORTS_OFF_MASK   0x7
-
-#define CHV_PORT3_LANES_SHIFT		9
-#define CHV_PORT_CONFIG_MASK		0x1f07ff
-
-#define ISPSSPM1				0x3a
-#define ISP_FREQ_STAT_MASK			(0x1f << ISP_FREQ_STAT_OFFSET)
-#define ISP_REQ_FREQ_MASK			0x1f
-#define ISP_FREQ_VALID_MASK			(0x1 << ISP_FREQ_VALID_OFFSET)
-#define ISP_FREQ_STAT_OFFSET			0x18
-#define ISP_REQ_GUAR_FREQ_OFFSET		0x8
-#define ISP_REQ_FREQ_OFFSET			0x0
-#define ISP_FREQ_VALID_OFFSET			0x7
-#define ISP_FREQ_RULE_ANY			0x0
-
-#define ISP_FREQ_457MHZ				0x1C9
-#define ISP_FREQ_400MHZ				0x190
-#define ISP_FREQ_320MHZ				0x140
-#define ISP_FREQ_266MHZ				0x10a
-#define ISP_FREQ_200MHZ				0xc8
-#define HPLL_FREQ				0x640
-
-#if defined(ISP2401)
-#define ISP_FREQ_MAX	ISP_FREQ_320MHZ
-#else
-#define ISP_FREQ_MAX	ISP_FREQ_400MHZ
-#endif
-#endif /* ATOMISP_REGS_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.c
deleted file mode 100644
index 5872ac5..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
- * Support for Clovertrail PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-/*
- * This file implements loadable acceleration firmware API,
- * including ioctls to map and unmap acceleration parameters and buffers.
- */
-
-#include <linux/init.h>
-
-#include "atomisp_acc.h"
-#include "atomisp_internal.h"
-#include "atomisp_compat.h"
-#include "atomisp_cmd.h"
-
-#include "hrt/hive_isp_css_mm_hrt.h"
-#include "memory_access/memory_access.h"
-#ifdef CSS20
-#include "ia_css.h"
-#ifndef CSS21
-#include "ia_css_accelerate.h"
-#endif /* !CSS21 */
-#else /* CSS20 */
-#include "sh_css.h"
-#include "sh_css_accelerate.h"
-#endif /* CSS20 */
-
-static const struct {
-	unsigned int flag;
-	enum atomisp_css_pipe_id pipe_id;
-} acc_flag_to_pipe[] = {
-	{ ATOMISP_ACC_FW_LOAD_FL_PREVIEW, CSS_PIPE_ID_PREVIEW },
-	{ ATOMISP_ACC_FW_LOAD_FL_COPY, CSS_PIPE_ID_COPY },
-	{ ATOMISP_ACC_FW_LOAD_FL_VIDEO, CSS_PIPE_ID_VIDEO },
-	{ ATOMISP_ACC_FW_LOAD_FL_CAPTURE, CSS_PIPE_ID_CAPTURE }
-};
-
-/*
- * Allocate struct atomisp_acc_fw along with space for firmware.
- * The returned struct atomisp_acc_fw is cleared (firmware region is not).
- */
-static struct atomisp_acc_fw *acc_alloc_fw(unsigned int fw_size)
-{
-	struct atomisp_acc_fw *acc_fw;
-
-	acc_fw = kzalloc(sizeof(*acc_fw), GFP_KERNEL);
-	if (!acc_fw)
-		return NULL;
-
-	acc_fw->fw = vmalloc(fw_size);
-	if (!acc_fw->fw) {
-		kfree(acc_fw);
-		return NULL;
-	}
-
-	return acc_fw;
-}
-
-static void acc_free_fw(struct atomisp_acc_fw *acc_fw)
-{
-	vfree(acc_fw->fw);
-	kfree(acc_fw);
-}
-
-static struct atomisp_acc_fw *
-acc_get_fw(struct atomisp_device *isp, unsigned int handle)
-{
-	struct atomisp_acc_fw *acc_fw;
-
-	list_for_each_entry(acc_fw, &isp->acc.fw, list)
-		if (acc_fw->handle == handle)
-			return acc_fw;
-
-	return NULL;
-}
-
-static struct atomisp_map *acc_get_map(struct atomisp_device *isp,
-				       unsigned long css_ptr, size_t length)
-{
-	struct atomisp_map *atomisp_map;
-
-	list_for_each_entry(atomisp_map, &isp->acc.memory_maps, list) {
-		if (atomisp_map->ptr == css_ptr &&
-		    atomisp_map->length == length)
-			return atomisp_map;
-	}
-	return NULL;
-}
-
-static int acc_stop_acceleration(struct atomisp_device *isp)
-{
-	int ret;
-
-	ret = atomisp_css_stop_acc_pipe(isp->asd);
-	atomisp_css_destroy_acc_pipe(isp->asd);
-
-	return ret;
-}
-
-void atomisp_acc_init(struct atomisp_device *isp)
-{
-	INIT_LIST_HEAD(&isp->acc.fw);
-	INIT_LIST_HEAD(&isp->acc.memory_maps);
-	ida_init(&isp->acc.ida);
-}
-
-void atomisp_acc_cleanup(struct atomisp_device *isp)
-{
-	ida_destroy(&isp->acc.ida);
-}
-
-void atomisp_acc_release(struct atomisp_device *isp)
-{
-	struct atomisp_acc_fw *acc_fw, *ta;
-	struct atomisp_map *atomisp_map, *tm;
-
-	/* Stop acceleration if already running */
-	if (isp->acc.pipeline)
-		acc_stop_acceleration(isp);
-
-	/* Unload all loaded acceleration binaries */
-	list_for_each_entry_safe(acc_fw, ta, &isp->acc.fw, list) {
-		list_del(&acc_fw->list);
-		ida_remove(&isp->acc.ida, acc_fw->handle);
-		acc_free_fw(acc_fw);
-	}
-
-	/* Free all mapped memory blocks */
-	list_for_each_entry_safe(atomisp_map, tm, &isp->acc.memory_maps, list) {
-		list_del(&atomisp_map->list);
-		mmgr_free(atomisp_map->ptr);
-		kfree(atomisp_map);
-	}
-}
-
-int atomisp_acc_load_to_pipe(struct atomisp_device *isp,
-			     struct atomisp_acc_fw_load_to_pipe *user_fw)
-{
-	static const unsigned int pipeline_flags =
-		ATOMISP_ACC_FW_LOAD_FL_PREVIEW | ATOMISP_ACC_FW_LOAD_FL_COPY |
-		ATOMISP_ACC_FW_LOAD_FL_VIDEO |
-		ATOMISP_ACC_FW_LOAD_FL_CAPTURE | ATOMISP_ACC_FW_LOAD_FL_ACC;
-
-	struct atomisp_acc_fw *acc_fw;
-	int handle;
-
-	if (!user_fw->data || user_fw->size == 0)
-		return -EINVAL;
-
-	/* Binary has to be enabled at least for one pipeline */
-	if (!(user_fw->flags & pipeline_flags))
-		return -EINVAL;
-
-	/* We do not support other flags yet */
-	if (user_fw->flags & ~pipeline_flags)
-		return -EINVAL;
-
-	if (user_fw->type < ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT ||
-	    user_fw->type > ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)
-		return -EINVAL;
-
-	if (isp->acc.pipeline || isp->acc.extension_mode)
-		return -EBUSY;
-
-	acc_fw = acc_alloc_fw(user_fw->size);
-	if (!acc_fw)
-		return -ENOMEM;
-
-	if (copy_from_user(acc_fw->fw, user_fw->data, user_fw->size)) {
-		acc_free_fw(acc_fw);
-		return -EFAULT;
-	}
-
-	if (!ida_pre_get(&isp->acc.ida, GFP_KERNEL) ||
-	    ida_get_new_above(&isp->acc.ida, 1, &handle)) {
-		acc_free_fw(acc_fw);
-		return -ENOSPC;
-	}
-
-	user_fw->fw_handle = handle;
-	acc_fw->handle = handle;
-	acc_fw->flags = user_fw->flags;
-	acc_fw->type = user_fw->type;
-
-#ifdef CSS20
-	/*
-	 * correct isp firmware type in order ISP firmware can be appended
-	 * to correct pipe properly
-	 */
-	if (acc_fw->fw->type == ia_css_isp_firmware) {
-		switch (acc_fw->type) {
-		case ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT:
-			acc_fw->fw->info.isp.type = IA_CSS_ACC_OUTPUT;
-			break;
-
-		case ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER:
-			acc_fw->fw->info.isp.type = IA_CSS_ACC_VIEWFINDER;
-			break;
-
-		case ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE:
-			acc_fw->fw->info.isp.type = IA_CSS_ACC_STANDALONE;
-			break;
-		}
-	}
-#endif /* CSS20 */
-
-	list_add_tail(&acc_fw->list, &isp->acc.fw);
-	return 0;
-}
-
-int atomisp_acc_load(struct atomisp_device *isp,
-		     struct atomisp_acc_fw_load *user_fw)
-{
-	struct atomisp_acc_fw_load_to_pipe ltp = {0};
-	int r;
-
-	ltp.flags = ATOMISP_ACC_FW_LOAD_FL_ACC;
-	ltp.type = ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE;
-	ltp.size = user_fw->size;
-	ltp.data = user_fw->data;
-	r = atomisp_acc_load_to_pipe(isp, &ltp);
-	user_fw->fw_handle = ltp.fw_handle;
-	return r;
-}
-
-int atomisp_acc_unload(struct atomisp_device *isp, unsigned int *handle)
-{
-	struct atomisp_acc_fw *acc_fw;
-
-	if (isp->acc.pipeline || isp->acc.extension_mode)
-		return -EBUSY;
-
-	acc_fw = acc_get_fw(isp, *handle);
-	if (!acc_fw)
-		return -EINVAL;
-
-	list_del(&acc_fw->list);
-	ida_remove(&isp->acc.ida, acc_fw->handle);
-	acc_free_fw(acc_fw);
-
-	return 0;
-}
-
-int atomisp_acc_start(struct atomisp_sub_device *asd, unsigned int *handle)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_acc_fw *acc_fw;
-	int ret;
-	unsigned int nbin;
-
-	if (isp->acc.pipeline || isp->acc.extension_mode)
-		return -EBUSY;
-
-	/* Invalidate caches. FIXME: should flush only necessary buffers */
-	wbinvd();
-
-	ret = atomisp_css_create_acc_pipe(asd);
-	if (ret)
-		return ret;
-
-	nbin = 0;
-	list_for_each_entry(acc_fw, &isp->acc.fw, list) {
-		if (*handle != 0 && *handle != acc_fw->handle)
-			continue;
-
-		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_STANDALONE)
-			continue;
-
-		/* Add the binary into the pipeline */
-		ret = atomisp_css_load_acc_binary(asd, acc_fw->fw, nbin);
-		if (ret < 0) {
-			dev_err(isp->dev, "acc_load_binary failed\n");
-			goto err_stage;
-		}
-
-		ret = atomisp_css_set_acc_parameters(acc_fw);
-		if (ret < 0) {
-			dev_err(isp->dev, "acc_set_parameters failed\n");
-			goto err_stage;
-		}
-		nbin++;
-	}
-	if (nbin < 1) {
-		/* Refuse creating pipelines with no binaries */
-		dev_err(isp->dev, "%s: no acc binary available\n", __func__);
-		ret = -EINVAL;
-		goto err_stage;
-	}
-
-	ret = atomisp_css_start_acc_pipe(asd);
-	if (ret) {
-		dev_err(isp->dev, "%s: atomisp_acc_start_acc_pipe failed\n",
-			__func__);
-		goto err_stage;
-	}
-
-	return 0;
-
-err_stage:
-	atomisp_css_destroy_acc_pipe(asd);
-	return ret;
-}
-
-int atomisp_acc_wait(struct atomisp_sub_device *asd, unsigned int *handle)
-{
-	struct atomisp_device *isp = asd->isp;
-	int ret;
-
-	if (!isp->acc.pipeline)
-		return -ENOENT;
-
-	if (*handle && !acc_get_fw(isp, *handle))
-		return -EINVAL;
-
-	ret = atomisp_css_wait_acc_finish(asd);
-	if (acc_stop_acceleration(isp) == -EIO) {
-		atomisp_reset(isp);
-		return -EINVAL;
-	}
-
-	return ret;
-}
-
-int atomisp_acc_map(struct atomisp_device *isp, struct atomisp_acc_map *map)
-{
-	struct atomisp_map *atomisp_map;
-	ia_css_ptr cssptr;
-	int pgnr;
-
-	if (map->flags || !map->user_ptr || map->css_ptr)
-		return -EINVAL;
-
-	if (isp->acc.pipeline)
-		return -EBUSY;
-
-	/* Buffer to map must be page-aligned */
-	if ((unsigned long)map->user_ptr & ~PAGE_MASK) {
-		dev_err(isp->dev,
-			"%s: mapped buffer address %p is not page aligned\n",
-			__func__, map->user_ptr);
-		return -EINVAL;
-	}
-
-	pgnr = DIV_ROUND_UP(map->length, PAGE_SIZE);
-	cssptr = hrt_isp_css_mm_alloc_user_ptr(
-			map->length, map->user_ptr,
-			pgnr, HRT_USR_PTR, false);
-	if (!cssptr)
-		return -ENOMEM;
-
-	atomisp_map = kmalloc(sizeof(*atomisp_map), GFP_KERNEL);
-	if (!atomisp_map) {
-		mmgr_free(cssptr);
-		return -ENOMEM;
-	}
-	atomisp_map->ptr = cssptr;
-	atomisp_map->length = map->length;
-	list_add(&atomisp_map->list, &isp->acc.memory_maps);
-
-	dev_dbg(isp->dev, "%s: userptr %p, css_address 0x%x, size %d\n",
-		__func__, map->user_ptr, cssptr, map->length);
-	map->css_ptr = cssptr;
-	return 0;
-}
-
-int atomisp_acc_unmap(struct atomisp_device *isp, struct atomisp_acc_map *map)
-{
-	struct atomisp_map *atomisp_map;
-
-	if (map->flags)
-		return -EINVAL;
-
-	if (isp->acc.pipeline)
-		return -EBUSY;
-
-	atomisp_map = acc_get_map(isp, map->css_ptr, map->length);
-	if (!atomisp_map)
-		return -EINVAL;
-
-	list_del(&atomisp_map->list);
-	mmgr_free(atomisp_map->ptr);
-	kfree(atomisp_map);
-	return 0;
-}
-
-int atomisp_acc_s_mapped_arg(struct atomisp_device *isp,
-			     struct atomisp_acc_s_mapped_arg *arg)
-{
-	struct atomisp_acc_fw *acc_fw;
-
-	if (arg->memory >= ATOMISP_ACC_NR_MEMORY)
-		return -EINVAL;
-
-	if (isp->acc.pipeline)
-		return -EBUSY;
-
-	acc_fw = acc_get_fw(isp, arg->fw_handle);
-	if (!acc_fw)
-		return -EINVAL;
-
-	if (arg->css_ptr != 0 || arg->length != 0) {
-		/* Unless the parameter is cleared, check that it exists */
-		if (!acc_get_map(isp, arg->css_ptr, arg->length))
-			return -EINVAL;
-	}
-
-	acc_fw->args[arg->memory].length = arg->length;
-	acc_fw->args[arg->memory].css_ptr = arg->css_ptr;
-
-	dev_dbg(isp->dev, "%s: mem %d, address %p, size %ld\n",
-		__func__, arg->memory, (void *)arg->css_ptr,
-		(unsigned long)arg->length);
-	return 0;
-}
-
-/*
- * Appends the loaded acceleration binary extensions to the
- * current ISP mode. Must be called just before sh_css_start().
- */
-int atomisp_acc_load_extensions(struct atomisp_sub_device *asd)
-{
-	struct atomisp_acc_fw *acc_fw;
-	bool ext_loaded = false;
-	int ret = 0, i = -1;
-	struct atomisp_device *isp = asd->isp;
-
-	if (isp->acc.pipeline || isp->acc.extension_mode)
-		return -EBUSY;
-
-	/* Invalidate caches. FIXME: should flush only necessary buffers */
-	wbinvd();
-
-	list_for_each_entry(acc_fw, &isp->acc.fw, list) {
-		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
-		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
-			continue;
-
-		for (i = 0; i < ARRAY_SIZE(acc_flag_to_pipe); i++) {
-			if (acc_fw->flags & acc_flag_to_pipe[i].flag) {
-				ret = atomisp_css_load_acc_extension(asd,
-					acc_fw->fw,
-					acc_flag_to_pipe[i].pipe_id,
-					acc_fw->type);
-				if (ret) {
-					i--;
-					goto error;
-				}
-
-				ext_loaded = true;
-			}
-		}
-
-		ret = atomisp_css_set_acc_parameters(acc_fw);
-		if (ret < 0)
-			goto error;
-	}
-
-	if (!ext_loaded)
-		return ret;
-
-	ret = atomisp_css_update_stream(asd);
-	if (ret) {
-		dev_err(isp->dev, "%s: update stream failed.\n", __func__);
-		goto error;
-	}
-
-	isp->acc.extension_mode = true;
-	return 0;
-
-error:
-	for (; i >= 0; i--) {
-		if (acc_fw->flags & acc_flag_to_pipe[i].flag) {
-			atomisp_css_unload_acc_extension(asd, acc_fw->fw,
-					acc_flag_to_pipe[i].pipe_id);
-		}
-	}
-
-	list_for_each_entry_continue_reverse(acc_fw, &isp->acc.fw, list) {
-		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
-		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
-			continue;
-
-		for (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {
-			if (acc_fw->flags & acc_flag_to_pipe[i].flag) {
-				atomisp_css_unload_acc_extension(asd,
-					acc_fw->fw,
-					acc_flag_to_pipe[i].pipe_id);
-			}
-		}
-	}
-	return ret;
-}
-
-void atomisp_acc_unload_extensions(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_acc_fw *acc_fw;
-	int i;
-
-	if (!isp->acc.extension_mode)
-		return;
-
-	list_for_each_entry_reverse(acc_fw, &isp->acc.fw, list) {
-		if (acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_OUTPUT &&
-		    acc_fw->type != ATOMISP_ACC_FW_LOAD_TYPE_VIEWFINDER)
-			continue;
-
-		for (i = ARRAY_SIZE(acc_flag_to_pipe) - 1; i >= 0; i--) {
-			if (acc_fw->flags & acc_flag_to_pipe[i].flag) {
-				atomisp_css_unload_acc_extension(asd,
-					acc_fw->fw,
-					acc_flag_to_pipe[i].pipe_id);
-			}
-		}
-	}
-
-	isp->acc.extension_mode = false;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.h
deleted file mode 100644
index 7daf070..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_acc.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Support for Clovertrail PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __ATOMISP_ACC_H__
-#define __ATOMISP_ACC_H__
-
-#include <linux/atomisp.h>
-#include "atomisp_internal.h"
-
-#ifdef CSS20
-#include "ia_css_types.h"
-#else /* CSS20 */
-#include "sh_css_types.h"
-#endif /* CSS20 */
-
-/*
- * Interface functions for AtomISP driver acceleration API implementation.
- */
-
-struct atomisp_device;
-
-/*
- * Initialize acceleration interface.
- * Must be called once when the driver is loaded.
- */
-void atomisp_acc_init(struct atomisp_device *isp);
-
-void atomisp_acc_cleanup(struct atomisp_device *isp);
-
-/*
- * Free up any allocated resources.
- * Must be called each time when the device is closed.
- * Note that there isn't corresponding open() call;
- * this function may be called sequentially multiple times.
- * Must be called to free up resources before driver is unloaded.
- */
-void atomisp_acc_release(struct atomisp_device *isp);
-
-/* Load acceleration binary. DEPRECATED. */
-int atomisp_acc_load(struct atomisp_device *isp,
-		     struct atomisp_acc_fw_load *fw);
-
-/* Load acceleration binary with specified properties */
-int atomisp_acc_load_to_pipe(struct atomisp_device *isp,
-			     struct atomisp_acc_fw_load_to_pipe *fw);
-
-/* Unload specified acceleration binary */
-int atomisp_acc_unload(struct atomisp_device *isp,
-		       unsigned int *handle);
-
-/*
- * Map a memory region into ISP memory space.
- */
-int atomisp_acc_map(struct atomisp_device *isp,
-		    struct atomisp_acc_map *map);
-
-/*
- * Unmap a mapped memory region.
- */
-int atomisp_acc_unmap(struct atomisp_device *isp,
-		      struct atomisp_acc_map *map);
-
-/*
- * Set acceleration binary argument to a previously mapped memory region.
- */
-int atomisp_acc_s_mapped_arg(struct atomisp_device *isp,
-			     struct atomisp_acc_s_mapped_arg *arg);
-
-
-/*
- * Start acceleration.
- * Return immediately, acceleration is left running in background.
- * Specify either acceleration binary or pipeline which to start.
- */
-int atomisp_acc_start(struct atomisp_sub_device *asd,
-		      unsigned int *handle);
-
-/*
- * Wait until acceleration finishes.
- * This MUST be called after each acceleration has been started.
- * Specify either acceleration binary or pipeline handle.
- */
-int atomisp_acc_wait(struct atomisp_sub_device *asd,
-		     unsigned int *handle);
-
-/*
- * Used by ISR to notify ACC pipeline finished.
- * This is internally used and does not export as IOCTL.
- */
-void atomisp_acc_done(struct atomisp_device *isp);
-
-/*
- * Appends the loaded acceleration binary extensions to the
- * current ISP mode. Must be called just before atomisp_css_start().
- */
-int atomisp_acc_load_extensions(struct atomisp_sub_device *asd);
-
-/*
- * Must be called after streaming is stopped:
- * unloads any loaded acceleration extensions.
- */
-void atomisp_acc_unload_extensions(struct atomisp_sub_device *asd);
-
-#endif /* __ATOMISP_ACC_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.c
deleted file mode 100644
index 0130f64..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.c
+++ /dev/null
@@ -1,4485 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#include <linux/firmware.h>
-#include <linux/intel_mid_pm.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/kfifo.h>
-#include <linux/pm_runtime.h>
-#include <linux/timer.h>
-
-#include <asm/intel-mid.h>
-
-#include <media/v4l2-event.h>
-#include <media/videobuf-vmalloc.h>
-
-#include "atomisp_cmd.h"
-#include "atomisp_common.h"
-#include "atomisp_fops.h"
-#include "atomisp_internal.h"
-#include "atomisp_ioctl.h"
-#include "atomisp-regs.h"
-#include "atomisp_tables.h"
-#include "atomisp_acc.h"
-#include "atomisp_compat.h"
-#include "atomisp_subdev.h"
-
-#include "hrt/hive_isp_css_mm_hrt.h"
-
-#include "sh_css_hrt.h"
-#include "sh_css_defs.h"
-#include "system_global.h"
-#include "sh_css_internal.h"
-#include "sh_css_sp.h"
-#include "gp_device.h"
-#include "device_access.h"
-#include "irq.h"
-
-#ifdef CSS20
-#ifndef CSS21
-#include "ia_css_accelerate.h"
-#endif /* !CSS21 */
-#include "ia_css_types.h"
-#else /* CSS20 */
-#include "sh_css_accelerate.h"
-#include "sh_css.h"
-#include "sh_css_types.h"
-#endif /* CSS20 */
-
-#include "hrt/bits.h"
-
-/* We should never need to run the flash for more than 2 frames.
- * At 15fps this means 133ms. We set the timeout a bit longer.
- * Each flash driver is supposed to set its own timeout, but
- * just in case someone else changed the timeout, we set it
- * here to make sure we don't damage the flash hardware. */
-#define FLASH_TIMEOUT 800 /* ms */
-
-union host {
-	struct {
-		void *kernel_ptr;
-		void __user *user_ptr;
-		int size;
-	} scalar;
-	struct {
-		void *hmm_ptr;
-	} ptr;
-};
-
-/*
- * atomisp_kernel_malloc: chooses whether kmalloc() or vmalloc() is preferable.
- *
- * It is also a wrap functions to pass into css framework.
- */
-void *atomisp_kernel_malloc(size_t bytes)
-{
-	/* vmalloc() is preferable if allocating more than 1 page */
-	if (bytes > PAGE_SIZE)
-		return vmalloc(bytes);
-
-	return kmalloc(bytes, GFP_KERNEL);
-}
-
-/*
- * atomisp_kernel_zalloc: chooses whether set 0 to the allocated memory.
- *
- * It is also a wrap functions to pass into css framework.
- */
-void *atomisp_kernel_zalloc(size_t bytes, bool zero_mem)
-{
-	void *ptr = atomisp_kernel_malloc(bytes);
-
-	if (ptr && zero_mem)
-		memset(ptr, 0, bytes);
-
-	return ptr;
-}
-
-/*
- * Free buffer allocated with atomisp_kernel_malloc()/atomisp_kernel_zalloc
- * helper
- */
-void atomisp_kernel_free(void *ptr)
-{
-	/* Verify if buffer was allocated by vmalloc() or kmalloc() */
-	if (is_vmalloc_addr(ptr))
-		vfree(ptr);
-	else
-		kfree(ptr);
-}
-
-/*
- * get sensor:dis71430/ov2720 related info from v4l2_subdev->priv data field.
- * subdev->priv is set in mrst.c
- */
-struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd)
-{
-	return (struct camera_mipi_info *)v4l2_get_subdev_hostdata(sd);
-}
-
-/*
- * get struct atomisp_video_pipe from v4l2 video_device
- */
-struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev)
-{
-	return (struct atomisp_video_pipe *)
-	    container_of(dev, struct atomisp_video_pipe, vdev);
-}
-
-/* This is just a draft rules, should be tuned when sensor is ready*/
-static struct atomisp_freq_scaling_rule dfs_rules_isp2400[] = {
-	/*
-	 * TODO: SDV maybe have to use 457MHz on TNG B0,
-	 * add 457MHz option later together with SDV.
-	 */
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_400MHZ,
-		.run_mode = ATOMISP_RUN_MODE_VIDEO,
-	},
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_400MHZ,
-		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
-	},
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_400MHZ,
-		.run_mode = ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE,
-	},
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_400MHZ,
-		.run_mode = ATOMISP_RUN_MODE_PREVIEW,
-	},
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_457MHZ,
-		.run_mode = ATOMISP_RUN_MODE_SDV,
-	},
-};
-
-static struct atomisp_freq_scaling_rule dfs_rules_isp2401[] = {
-	/*
-	 * TODO: SDV maybe have to use 457MHz on TNG B0,
-	 * add 457MHz option later together with SDV.
-	 */
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_320MHZ,
-		.run_mode = ATOMISP_RUN_MODE_VIDEO,
-	},
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_320MHZ,
-		.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE,
-	},
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_320MHZ,
-		.run_mode = ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE,
-	},
-	{
-		.width = ISP_FREQ_RULE_ANY,
-		.height = ISP_FREQ_RULE_ANY,
-		.fps = ISP_FREQ_RULE_ANY,
-		.isp_freq = ISP_FREQ_320MHZ,
-		.run_mode = ATOMISP_RUN_MODE_PREVIEW,
-	},
-};
-
-static unsigned short atomisp_get_sensor_fps(struct atomisp_sub_device *asd)
-{
-	struct v4l2_subdev_frame_interval frame_interval;
-	struct atomisp_device *isp = asd->isp;
-	unsigned short fps;
-
-	if (v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-		video, g_frame_interval, &frame_interval)) {
-		fps = 0;
-	} else {
-		if (frame_interval.interval.numerator)
-			fps = frame_interval.interval.denominator /
-			    frame_interval.interval.numerator;
-		else
-			fps = 0;
-	}
-	return fps;
-}
-/*
- * DFS progress is shown as follows:
- * 1. Target frequency is calculated according to FPS/Resolution/ISP running
- *    mode.
- * 2. Ratio is calculated using formula: 2 * HPLL / target frequency - 1
- *    with proper rounding.
- * 3. Set ratio to ISPFREQ40, 1 to FREQVALID and ISPFREQGUAR40
- *    to 200MHz in ISPSSPM1.
- * 4. Wait for FREQVALID to be cleared by P-Unit.
- * 5. Wait for field ISPFREQSTAT40 in ISPSSPM1 turn to ratio set in 3.
- */
-static int write_target_freq_to_hw(struct atomisp_device *isp,
-				   unsigned int new_freq)
-{
-	unsigned int ratio, timeout;
-	u32 isp_sspm1 = 0;
-
-	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
-	if (isp_sspm1 & ISP_FREQ_VALID_MASK) {
-		dev_dbg(isp->dev, "clearing ISPSSPM1 valid bit.\n");
-		intel_mid_msgbus_write32(PUNIT_PORT, ISPSSPM1,
-				    isp_sspm1 & ~(1 << ISP_FREQ_VALID_OFFSET));
-	}
-
-	ratio =  (2 * HPLL_FREQ + new_freq / 2) / new_freq - 1;
-	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
-	isp_sspm1 &= ~(0x1F << ISP_REQ_FREQ_OFFSET);
-	intel_mid_msgbus_write32(PUNIT_PORT, ISPSSPM1,
-				   isp_sspm1
-				   | ratio << ISP_REQ_FREQ_OFFSET
-				   | 1 << ISP_FREQ_VALID_OFFSET
-				   | 0xF << ISP_REQ_GUAR_FREQ_OFFSET);
-
-	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
-	timeout = 10;
-	while ((isp_sspm1 & ISP_FREQ_VALID_MASK) && timeout) {
-		isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
-		dev_dbg(isp->dev, "waiting for ISPSSPM1 valid bit to be 0.\n");
-		udelay(100);
-		timeout--;
-	}
-	if (timeout == 0) {
-		dev_err(isp->dev, "DFS failed due to HW error.\n");
-		return -EINVAL;
-	}
-
-	isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
-	timeout = 10;
-	while (((isp_sspm1 >> ISP_FREQ_STAT_OFFSET) != ratio) && timeout) {
-		isp_sspm1 = intel_mid_msgbus_read32(PUNIT_PORT, ISPSSPM1);
-		dev_dbg(isp->dev, "waiting for ISPSSPM1 status bit to be 0x%x.\n",
-			new_freq);
-		udelay(100);
-		timeout--;
-	}
-	if (timeout == 0) {
-		dev_err(isp->dev, "DFS target freq is rejected by HW.\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-int atomisp_freq_scaling(struct atomisp_device *isp, enum atomisp_dfs_mode mode)
-{
-	/* FIXME! Only use subdev[0] status yet */
-	struct atomisp_sub_device *asd = &isp->asd[0];
-	unsigned int new_freq;
-	struct atomisp_freq_scaling_rule curr_rules;
-	struct atomisp_freq_scaling_rule *dfs_rules;
-	unsigned int rule_number;
-	int i, ret;
-	unsigned short fps = 0;
-
-	if (isp->sw_contex.power_state != ATOM_ISP_POWER_UP) {
-		dev_err(isp->dev, "DFS cannot proceed due to no power.\n");
-		return -EINVAL;
-	}
-
-	if (mode == ATOMISP_DFS_MODE_LOW) {
-		new_freq = ISP_FREQ_200MHZ;
-		goto done;
-	}
-
-	if (mode == ATOMISP_DFS_MODE_MAX) {
-		new_freq = ISP_FREQ_MAX;
-		goto done;
-	}
-
-	fps = atomisp_get_sensor_fps(asd);
-	if (fps == 0)
-		return -EINVAL;
-
-	curr_rules.width = asd->fmt[asd->capture_pad].fmt.width;
-	curr_rules.height = asd->fmt[asd->capture_pad].fmt.height;
-	curr_rules.fps = fps;
-	curr_rules.run_mode = asd->run_mode->val;
-	/*
-	 * For continuous mode, we need to make the capture setting applied
-	 * since preview mode, because there is no chance to do this when
-	 * starting image capture.
-	 */
-	if (asd->continuous_mode->val) {
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-			curr_rules.run_mode = ATOMISP_RUN_MODE_SDV;
-		else
-			curr_rules.run_mode = ATOMISP_RUN_MODE_STILL_CAPTURE;
-	}
-
-	if (IS_ISP2401(isp)) {
-		dfs_rules = dfs_rules_isp2401;
-		rule_number = ARRAY_SIZE(dfs_rules_isp2401);
-	} else {
-		dfs_rules = dfs_rules_isp2400;
-		rule_number = ARRAY_SIZE(dfs_rules_isp2400);
-	}
-
-	/* search for the target frequency by looping freq rules*/
-	for (i = 0; i < rule_number; i++) {
-		if (curr_rules.width != dfs_rules[i].width
-			&& dfs_rules[i].width != ISP_FREQ_RULE_ANY)
-			continue;
-		if (curr_rules.height != dfs_rules[i].height
-			&& dfs_rules[i].height != ISP_FREQ_RULE_ANY)
-			continue;
-		if (curr_rules.fps != dfs_rules[i].fps
-			&& dfs_rules[i].fps != ISP_FREQ_RULE_ANY)
-			continue;
-		if (curr_rules.run_mode != dfs_rules[i].run_mode
-			&& dfs_rules[i].run_mode != ISP_FREQ_RULE_ANY)
-			continue;
-		break;
-	}
-	if (i == rule_number)
-		new_freq = ISP_FREQ_320MHZ;
-	else
-		new_freq = dfs_rules[i].isp_freq;
-
-done:
-	dev_dbg(isp->dev, "DFS target frequency=%d.\n", new_freq);
-
-	if (new_freq == isp->sw_contex.running_freq) {
-		dev_dbg(isp->dev, "ignoring DFS target freq.\n");
-		return 0;
-	}
-	ret = write_target_freq_to_hw(isp, new_freq);
-	if (!ret)
-		isp->sw_contex.running_freq = new_freq;
-	return ret;
-}
-
-/*
- * reset and restore ISP
- */
-int atomisp_reset(struct atomisp_device *isp)
-{
-	/* Reset ISP by power-cycling it */
-	int ret = 0;
-
-	dev_dbg(isp->dev, "%s\n", __func__);
-	atomisp_css_suspend();
-	ret = pm_runtime_put_sync(isp->dev);
-	if (ret < 0) {
-		dev_err(isp->dev, "can not disable ISP power\n");
-	} else {
-		ret = pm_runtime_get_sync(isp->dev);
-		if (ret < 0)
-			dev_err(isp->dev, "can not enable ISP power\n");
-	}
-	ret = atomisp_css_resume(isp);
-	if (ret)
-		isp->isp_fatal_error = true;
-
-	return ret;
-}
-
-/*
- * interrupt enable/disable functions
- */
-static void enable_isp_irq(enum hrt_isp_css_irq irq, bool enable)
-{
-	if (enable) {
-		irq_enable_channel(IRQ0_ID, irq);
-		/*sh_css_hrt_irq_enable(irq, true, false);*/
-		switch (irq) { /*We only have sp interrupt right now*/
-		case hrt_isp_css_irq_sp:
-			/*sh_css_hrt_irq_enable_sp(true);*/
-			cnd_sp_irq_enable(SP0_ID, true);
-			break;
-		default:
-			break;
-		}
-
-	} else {
-		/*sh_css_hrt_irq_disable(irq);*/
-		irq_disable_channel(IRQ0_ID, irq);
-		switch (irq) {
-		case hrt_isp_css_irq_sp:
-			/*sh_css_hrt_irq_enable_sp(false);*/
-			cnd_sp_irq_enable(SP0_ID, false);
-			break;
-		default:
-			break;
-		}
-	}
-}
-
-/*
- * interrupt clean function
- */
-static void clear_isp_irq(enum hrt_isp_css_irq irq)
-{
-	irq_clear_all(IRQ0_ID);
-}
-
-void atomisp_msi_irq_init(struct atomisp_device *isp, struct pci_dev *dev)
-{
-	u32 msg32;
-	u16 msg16;
-
-	pci_read_config_dword(dev, PCI_MSI_CAPID, &msg32);
-	msg32 |= 1 << MSI_ENABLE_BIT;
-	pci_write_config_dword(dev, PCI_MSI_CAPID, msg32);
-
-	msg32 = (1 << INTR_IER) | (1 << INTR_IIR);
-	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, msg32);
-
-	pci_read_config_word(dev, PCI_COMMAND, &msg16);
-	msg16 |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
-		  PCI_COMMAND_INTX_DISABLE);
-	pci_write_config_word(dev, PCI_COMMAND, msg16);
-}
-
-void atomisp_msi_irq_uninit(struct atomisp_device *isp, struct pci_dev *dev)
-{
-	u32 msg32;
-	u16 msg16;
-
-	pci_read_config_dword(dev, PCI_MSI_CAPID, &msg32);
-	msg32 &=  ~(1 << MSI_ENABLE_BIT);
-	pci_write_config_dword(dev, PCI_MSI_CAPID, msg32);
-
-	msg32 = 0x0;
-	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, msg32);
-
-	pci_read_config_word(dev, PCI_COMMAND, &msg16);
-	msg16 &= ~(PCI_COMMAND_MASTER);
-	pci_write_config_word(dev, PCI_COMMAND, msg16);
-}
-
-static void atomisp_sof_event(struct atomisp_sub_device *asd)
-{
-	struct v4l2_event event = {0};
-
-	event.type = V4L2_EVENT_FRAME_SYNC;
-	event.u.frame_sync.frame_sequence = atomic_read(&asd->sof_count);
-
-	v4l2_event_queue(asd->subdev.devnode, &event);
-}
-
-static void atomisp_3a_stats_ready_event(struct atomisp_sub_device *asd)
-{
-	struct v4l2_event event = {0};
-
-	event.type = V4L2_EVENT_ATOMISP_3A_STATS_READY;
-	event.u.frame_sync.frame_sequence = atomic_read(&asd->sequence);
-
-	v4l2_event_queue(asd->subdev.devnode, &event);
-}
-
-static void print_csi_rx_errors(struct atomisp_device *isp)
-{
-	u32 infos = 0;
-
-	atomisp_css_rx_get_irq_info(&infos);
-
-	dev_err(isp->dev, "CSI Receiver errors:\n");
-	if (infos & CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
-		dev_err(isp->dev, "  buffer overrun");
-	if (infos & CSS_RX_IRQ_INFO_ERR_SOT)
-		dev_err(isp->dev, "  start-of-transmission error");
-	if (infos & CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
-		dev_err(isp->dev, "  start-of-transmission sync error");
-	if (infos & CSS_RX_IRQ_INFO_ERR_CONTROL)
-		dev_err(isp->dev, "  control error");
-	if (infos & CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
-		dev_err(isp->dev, "  2 or more ECC errors");
-	if (infos & CSS_RX_IRQ_INFO_ERR_CRC)
-		dev_err(isp->dev, "  CRC mismatch");
-	if (infos & CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
-		dev_err(isp->dev, "  unknown error");
-	if (infos & CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
-		dev_err(isp->dev, "  frame sync error");
-	if (infos & CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
-		dev_err(isp->dev, "  frame data error");
-	if (infos & CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
-		dev_err(isp->dev, "  data timeout");
-	if (infos & CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
-		dev_err(isp->dev, "  unknown escape command entry");
-	if (infos & CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
-		dev_err(isp->dev, "  line sync error");
-}
-
-/* Clear irq reg */
-static void clear_irq_reg(struct atomisp_device *isp)
-{
-	u32 msg_ret;
-	pci_read_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, &msg_ret);
-	msg_ret |= 1 << INTR_IIR;
-	pci_write_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, msg_ret);
-}
-
-
-/* interrupt handling function*/
-irqreturn_t atomisp_isr(int irq, void *dev)
-{
-	struct atomisp_device *isp = (struct atomisp_device *)dev;
-	struct atomisp_sub_device *asd;
-	unsigned int irq_infos = 0;
-	unsigned long flags;
-	unsigned int i;
-	int err;
-
-	spin_lock_irqsave(&isp->lock, flags);
-	if (isp->sw_contex.power_state != ATOM_ISP_POWER_UP) {
-		spin_unlock_irqrestore(&isp->lock, flags);
-		return IRQ_HANDLED;
-	}
-	err = atomisp_css_irq_translate(isp, &irq_infos);
-	if (err) {
-		spin_unlock_irqrestore(&isp->lock, flags);
-		return IRQ_NONE;
-	}
-
-	dev_dbg(isp->dev, "irq:0x%x\n", irq_infos);
-
-	clear_irq_reg(isp);
-
-	if (!atomisp_streaming_count(isp) && !isp->acc.pipeline)
-		goto out_nowake;
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		asd = &isp->asd[i];
-		if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
-			continue;
-		/*
-		 * Current SOF only support one stream, so the SOF only valid
-		 * either solely one stream is running
-		 */
-		if (irq_infos & CSS_IRQ_INFO_CSS_RECEIVER_SOF) {
-			atomic_inc(&asd->sof_count);
-			atomisp_sof_event(asd);
-
-			/* If sequence_temp and sequence are the same
-			 * there where no frames lost so we can increase
-			 * sequence_temp.
-			 * If not then processing of frame is still in progress
-			 * and driver needs to keep old sequence_temp value.
-			 * NOTE: There is assumption here that ISP will not
-			 * start processing next frame from sensor before old
-			 * one is completely done. */
-			if (atomic_read(&asd->sequence) == atomic_read(
-						&asd->sequence_temp))
-				atomic_set(&asd->sequence_temp,
-						atomic_read(&asd->sof_count));
-
-			/* signal streamon after delayed init is done */
-			if (asd->delayed_init ==
-					ATOMISP_DELAYED_INIT_WORK_DONE) {
-				asd->delayed_init = ATOMISP_DELAYED_INIT_DONE;
-				complete(&asd->init_done);
-			}
-		}
-		if (irq_infos & CSS_IRQ_INFO_EVENTS_READY)
-			atomic_set(&asd->sequence,
-					atomic_read(&asd->sequence_temp));
-	}
-
-	if (irq_infos & CSS_IRQ_INFO_CSS_RECEIVER_SOF)
-		irq_infos &= ~CSS_IRQ_INFO_CSS_RECEIVER_SOF;
-
-#if defined(ISP2400) || defined(ISP2400B0) || defined(ISP2401)
-	if ((irq_infos & CSS_IRQ_INFO_INPUT_SYSTEM_ERROR) ||
-		(irq_infos & CSS_IRQ_INFO_IF_ERROR)) {
-#else
-	if (irq_infos & CSS_IRQ_INFO_CSS_RECEIVER_ERROR) {
-#endif
-		/* handle mipi receiver error */
-		u32 rx_infos;
-
-		print_csi_rx_errors(isp);
-		atomisp_css_rx_get_irq_info(&rx_infos);
-		atomisp_css_rx_clear_irq_info(rx_infos);
-	}
-#if defined(CSS15) && defined(ISP2300)
-	if (irq_infos & CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW) {
-		atomic_inc(&isp->fast_reset);
-		queue_work(isp->wdt_work_queue, &isp->wdt_work);
-		goto out_nowake;
-	}
-#endif
-#ifndef CSS20
-	if (irq_infos & CSS_IRQ_INFO_INVALID_FIRST_FRAME) {
-		isp->sw_contex.invalid_frame = 1;
-		isp->sw_contex.invalid_vf_frame = 1;
-		isp->sw_contex.invalid_s3a = 1;
-		isp->sw_contex.invalid_dis = 1;
-	}
-#endif /* CSS20 */
-
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	return IRQ_WAKE_THREAD;
-
-out_nowake:
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Background:
- * The IUNITPHY register CSI_CONTROL bit definition was changed since PNW C0.
- * For PNW A0 and B0, CSI4_TERM_EN_COUNT is bit 23:20 (4 bits).
- * Starting from PWN C0, including all CLV and CLV+ steppings,
- * CSI4_TERM_EN_COUNT is bit 30:24 (7 bits).
- *
- * ------------------------------------------
- * Silicon	Stepping	PCI revision
- * Penwell	A0		0x00
- * Penwell	B0		0x04
- * Penwell	C0		0x06
- * Penwell	D0		0x06
- * Penwell	D1		0x06
- * Penwell	D2		0x06
- * Cloverview	A0		0x06
- * Cloverview	B0		0x05
- * Cloverview	C0		0x04
- * Cloverview+	A0		0x08
- * Cloverview+	B0		0x0C
- *
- */
-
-#define TERM_EN_COUNT_1LANE_OFFSET		16	/* bit 22:16 */
-#define TERM_EN_COUNT_1LANE_MASK		0x7f0000
-#define TERM_EN_COUNT_4LANE_OFFSET		24	/* bit 30:24 */
-#define TERM_EN_COUNT_4LANE_MASK		0x7f000000
-#define TERM_EN_COUNT_4LANE_PWN_B0_OFFSET	20	/* bit 23:20 */
-#define TERM_EN_COUNT_4LANE_PWN_B0_MASK		0xf00000
-
-void atomisp_set_term_en_count(struct atomisp_device *isp)
-{
-	uint32_t val;
-	int pwn_b0 = 0;
-
-	/* For MRFLD, there is no Tescape-clock cycles control. */
-	if (IS_ISP24XX(isp))
-		return;
-
-	if (IS_MFLD && isp->pdev->device == 0x0148 &&
-		isp->pdev->revision < 0x6)
-		pwn_b0 = 1;
-
-	val = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL);
-
-	/* set TERM_EN_COUNT_1LANE to 0xf */
-	val &= ~TERM_EN_COUNT_1LANE_MASK;
-	val |= 0xf << TERM_EN_COUNT_1LANE_OFFSET;
-
-	/* set TERM_EN_COUNT_4LANE to 0xf */
-	val &= pwn_b0 ? ~TERM_EN_COUNT_4LANE_PWN_B0_MASK :
-				~TERM_EN_COUNT_4LANE_MASK;
-	val |= 0xf << (pwn_b0 ? TERM_EN_COUNT_4LANE_PWN_B0_OFFSET :
-				TERM_EN_COUNT_4LANE_OFFSET);
-
-	intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL, val);
-}
-
-void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *asd)
-{
-	memset(asd->s3a_bufs_in_css, 0, sizeof(asd->s3a_bufs_in_css));
-	asd->dis_bufs_in_css = 0;
-	asd->video_out_capture.buffers_in_css = 0;
-	asd->video_out_vf.buffers_in_css = 0;
-	asd->video_out_preview.buffers_in_css = 0;
-	asd->video_out_video_capture.buffers_in_css = 0;
-}
-
-bool atomisp_buffers_queued(struct atomisp_sub_device *asd)
-{
-	return asd->video_out_capture.buffers_in_css ||
-		asd->video_out_vf.buffers_in_css ||
-		asd->video_out_preview.buffers_in_css ||
-		asd->video_out_video_capture.buffers_in_css ?
-		    true : false;
-}
-
-/* 0x100000 is the start of dmem inside SP */
-#define SP_DMEM_BASE	0x100000
-
-void dump_sp_dmem(struct atomisp_device *isp, unsigned int addr,
-		  unsigned int size)
-{
-	unsigned int data = 0;
-	unsigned int size32 = DIV_ROUND_UP(size, sizeof(u32));
-
-	dev_dbg(isp->dev, "atomisp_io_base:%p\n", atomisp_io_base);
-	dev_dbg(isp->dev, "%s, addr:0x%x, size: %d, size32: %d\n", __func__,
-			addr, size, size32);
-	if (size32 * 4 + addr > 0x4000) {
-		dev_err(isp->dev, "illegal size (%d) or addr (0x%x)\n",
-				size32, addr);
-		return;
-	}
-	addr += SP_DMEM_BASE;
-	do {
-		data = _hrt_master_port_uload_32(addr);
-
-		dev_dbg(isp->dev, "%s, \t [0x%x]:0x%x\n", __func__, addr, data);
-		addr += sizeof(unsigned int);
-		size32 -= 1;
-	} while (size32 > 0);
-}
-
-static struct videobuf_buffer *atomisp_css_frame_to_vbuf(
-	struct atomisp_video_pipe *pipe, struct atomisp_css_frame *frame)
-{
-	struct videobuf_vmalloc_memory *vm_mem;
-	struct atomisp_css_frame *handle;
-	int i;
-
-	for (i = 0; pipe->capq.bufs[i]; i++) {
-		vm_mem = pipe->capq.bufs[i]->priv;
-		handle = vm_mem->vaddr;
-		if (handle && handle->data == frame->data)
-			return pipe->capq.bufs[i];
-	}
-
-	return NULL;
-}
-
-static void get_buf_timestamp(struct timeval *tv)
-{
-	struct timespec ts;
-	ktime_get_ts(&ts);
-	tv->tv_sec = ts.tv_sec;
-	tv->tv_usec = ts.tv_nsec / NSEC_PER_USEC;
-}
-
-static void atomisp_flush_video_pipe(struct atomisp_sub_device *asd,
-				     struct atomisp_video_pipe *pipe)
-{
-	unsigned long irqflags;
-	int i;
-
-	if (!pipe->users)
-		return;
-
-	for (i = 0; pipe->capq.bufs[i]; i++) {
-		spin_lock_irqsave(&pipe->irq_lock, irqflags);
-		if (pipe->capq.bufs[i]->state == VIDEOBUF_ACTIVE ||
-		    pipe->capq.bufs[i]->state == VIDEOBUF_QUEUED) {
-			get_buf_timestamp(&pipe->capq.bufs[i]->ts);
-			pipe->capq.bufs[i]->field_count =
-				atomic_read(&asd->sequence) << 1;
-			dev_dbg(asd->isp->dev, "release buffers on device %s\n",
-				pipe->vdev.name);
-			if (pipe->capq.bufs[i]->state == VIDEOBUF_QUEUED)
-				list_del_init(&pipe->capq.bufs[i]->queue);
-			pipe->capq.bufs[i]->state = VIDEOBUF_ERROR;
-			wake_up(&pipe->capq.bufs[i]->done);
-		}
-		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
-	}
-}
-
-/* Returns queued buffers back to video-core */
-void atomisp_flush_bufs_and_wakeup(struct atomisp_sub_device *asd)
-{
-	atomisp_flush_video_pipe(asd, &asd->video_out_capture);
-	atomisp_flush_video_pipe(asd, &asd->video_out_vf);
-	atomisp_flush_video_pipe(asd, &asd->video_out_preview);
-	atomisp_flush_video_pipe(asd, &asd->video_out_video_capture);
-}
-
-
-/* find atomisp_video_pipe with css pipe id, buffer type and atomisp run_mode */
-static struct atomisp_video_pipe *__atomisp_get_pipe(
-		struct atomisp_sub_device *asd,
-		enum atomisp_input_stream_id stream_id,
-		enum atomisp_css_pipe_id css_pipe_id,
-		enum atomisp_css_buffer_type buf_type)
-{
-	if (css_pipe_id == CSS_PIPE_ID_COPY) {
-		switch (stream_id) {
-		case ATOMISP_INPUT_STREAM_PREVIEW:
-			return &asd->video_out_preview;
-		case ATOMISP_INPUT_STREAM_POSTVIEW:
-			return &asd->video_out_vf;
-		case ATOMISP_INPUT_STREAM_VIDEO:
-			return &asd->video_out_video_capture;
-		case ATOMISP_INPUT_STREAM_CAPTURE:
-		default:
-			return &asd->video_out_capture;
-		}
-	}
-	/* video is same in online as in continuouscapture mode */
-	if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {
-		/*
-		 * Disable vf_pp and run CSS in still capture mode. In this
-		 * mode, CSS does not cause extra latency with buffering, but
-		 * scaling is not available.
-		 */
-		return &asd->video_out_capture;
-	} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
-		/*
-		 * Disable vf_pp and run CSS in video mode. This allows using
-		 * ISP scaling but it has one frame delay due to CSS internal
-		 * buffering.
-		 */
-		return &asd->video_out_video_capture;
-	} else if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-		if (css_pipe_id == CSS_PIPE_ID_VIDEO) {
-			if (buf_type == CSS_BUFFER_TYPE_OUTPUT_FRAME)
-				return &asd->video_out_video_capture;
-			return &asd->video_out_preview;
-		} else {
-			if (buf_type == CSS_BUFFER_TYPE_OUTPUT_FRAME)
-				return &asd->video_out_capture;
-			return &asd->video_out_vf;
-		}
-	} else if (buf_type == CSS_BUFFER_TYPE_OUTPUT_FRAME) {
-		if (css_pipe_id == CSS_PIPE_ID_PREVIEW)
-			return &asd->video_out_preview;
-		return &asd->video_out_capture;
-	/* statistic buffers are needed only in css capture & preview pipes */
-	} else if (buf_type == CSS_BUFFER_TYPE_3A_STATISTICS ||
-		   buf_type == CSS_BUFFER_TYPE_DIS_STATISTICS) {
-		if (css_pipe_id == CSS_PIPE_ID_PREVIEW)
-			return &asd->video_out_preview;
-		return &asd->video_out_capture;
-	}
-	return &asd->video_out_vf;
-}
-
-void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
-		      enum atomisp_css_buffer_type buf_type,
-		      enum atomisp_css_pipe_id css_pipe_id,
-		      bool q_buffers, enum atomisp_input_stream_id stream_id)
-{
-	struct videobuf_buffer *vb = NULL;
-	struct atomisp_video_pipe *pipe = NULL;
-	struct atomisp_css_buffer buffer;
-	bool requeue = false;
-	int err;
-	unsigned long irqflags;
-	struct atomisp_css_frame *frame = NULL;
-	struct atomisp_device *isp = asd->isp;
-
-	if (buf_type != CSS_BUFFER_TYPE_3A_STATISTICS &&
-	    buf_type != CSS_BUFFER_TYPE_DIS_STATISTICS &&
-	    buf_type != CSS_BUFFER_TYPE_OUTPUT_FRAME &&
-	    buf_type != CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME &&
-	    buf_type != CSS_BUFFER_TYPE_VF_OUTPUT_FRAME) {
-		dev_err(isp->dev, "%s, unsupported buffer type: %d\n",
-			__func__, buf_type);
-		return;
-	}
-
-	memset(&buffer, 0, sizeof(struct atomisp_css_buffer));
-	buffer.css_buffer.type = buf_type;
-	err = atomisp_css_dequeue_buffer(asd, stream_id, css_pipe_id,
-			buf_type, &buffer);
-	if (err) {
-		dev_err(isp->dev,
-			"atomisp_css_dequeue_buffer failed: 0x%x\n", err);
-		return;
-	}
-
-	/* need to know the atomisp pipe for frame buffers */
-	pipe = __atomisp_get_pipe(asd, stream_id, css_pipe_id, buf_type);
-	if (pipe == NULL) {
-		dev_err(isp->dev, "error getting atomisp pipe\n");
-		return;
-	}
-
-	switch (buf_type) {
-	case CSS_BUFFER_TYPE_3A_STATISTICS:
-		/* ignore error in case of 3a statistics for now */
-		if (isp->sw_contex.invalid_s3a) {
-			requeue = true;
-			isp->sw_contex.invalid_s3a = 0;
-			break;
-		}
-		/* update the 3A data to ISP context */
-		if (!error)
-			atomisp_css_get_3a_statistics(asd, &buffer);
-
-		asd->s3a_bufs_in_css[css_pipe_id]--;
-
-		atomisp_3a_stats_ready_event(asd);
-		break;
-	case CSS_BUFFER_TYPE_DIS_STATISTICS:
-		/* ignore error in case of dis statistics for now */
-		if (isp->sw_contex.invalid_dis) {
-			requeue = true;
-			isp->sw_contex.invalid_dis = 0;
-			break;
-		}
-		if (!error)
-			atomisp_css_get_dis_statistics(asd, &buffer);
-
-		asd->dis_bufs_in_css--;
-		break;
-	case CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
-		if (isp->sw_contex.invalid_vf_frame) {
-			error = true;
-			isp->sw_contex.invalid_vf_frame = 0;
-			dev_dbg(isp->dev, "%s css has marked this vf frame as invalid\n",
-				__func__);
-		}
-
-		pipe->buffers_in_css--;
-		frame = buffer.css_buffer.data.frame;
-		if (!frame) {
-			WARN_ON(1);
-			break;
-		}
-#ifdef CSS20
-		if (!frame->valid)
-			error = true;
-#endif
-
-		if (asd->params.flash_state ==
-		    ATOMISP_FLASH_ONGOING) {
-			if (frame->flash_state
-			    == CSS_FRAME_FLASH_STATE_PARTIAL)
-				dev_dbg(isp->dev, "%s thumb partially flashed\n",
-					__func__);
-			else if (frame->flash_state
-				 == CSS_FRAME_FLASH_STATE_FULL)
-				dev_dbg(isp->dev, "%s thumb completely flashed\n",
-					__func__);
-			else
-				dev_dbg(isp->dev, "%s thumb no flash in this frame\n",
-					__func__);
-		}
-		vb = atomisp_css_frame_to_vbuf(pipe, frame);
-		WARN_ON(!vb);
-		break;
-	case CSS_BUFFER_TYPE_OUTPUT_FRAME:
-		if (isp->sw_contex.invalid_frame) {
-			error = true;
-			isp->sw_contex.invalid_frame = 0;
-			dev_dbg(isp->dev, "%s css has marked this frame as invalid\n",
-				__func__);
-		}
-		pipe->buffers_in_css--;
-		frame = buffer.css_buffer.data.frame;
-		if (!frame) {
-			WARN_ON(1);
-			break;
-		}
-
-#ifdef CSS20
-		if (!frame->valid)
-			error = true;
-#endif
-		vb = atomisp_css_frame_to_vbuf(pipe, frame);
-		if (!vb) {
-			WARN_ON(1);
-			break;
-		}
-
-		if (asd->params.flash_state ==
-		    ATOMISP_FLASH_ONGOING) {
-			if (frame->flash_state
-			    == CSS_FRAME_FLASH_STATE_PARTIAL) {
-				asd->frame_status[vb->i] =
-					ATOMISP_FRAME_STATUS_FLASH_PARTIAL;
-				dev_dbg(isp->dev, "%s partially flashed\n",
-					 __func__);
-			} else if (frame->flash_state
-				   == CSS_FRAME_FLASH_STATE_FULL) {
-				asd->frame_status[vb->i] =
-					ATOMISP_FRAME_STATUS_FLASH_EXPOSED;
-				asd->params.num_flash_frames--;
-				dev_dbg(isp->dev, "%s completely flashed\n",
-						 __func__);
-				} else {
-					asd->frame_status[vb->i] =
-						ATOMISP_FRAME_STATUS_OK;
-					dev_dbg(isp->dev, "%s no flash in this frame\n",
-						 __func__);
-				}
-
-			/* Check if flashing sequence is done */
-			if (asd->frame_status[vb->i] ==
-				ATOMISP_FRAME_STATUS_FLASH_EXPOSED)
-				asd->params.flash_state =
-					ATOMISP_FLASH_DONE;
-		} else {
-			asd->frame_status[vb->i] =
-				ATOMISP_FRAME_STATUS_OK;
-		}
-
-		asd->params.last_frame_status =
-			asd->frame_status[vb->i];
-
-		if (asd->continuous_mode->val) {
-			unsigned int exp_id = frame->exp_id;
-
-			if (css_pipe_id == CSS_PIPE_ID_PREVIEW ||
-			    css_pipe_id == CSS_PIPE_ID_VIDEO) {
-				asd->latest_preview_exp_id = exp_id;
-			} else if (css_pipe_id ==
-					CSS_PIPE_ID_CAPTURE) {
-				if (asd->run_mode->val ==
-				    ATOMISP_RUN_MODE_VIDEO)
-					dev_dbg(isp->dev, "SDV capture raw buffer id: %u\n",
-						exp_id);
-				else
-					dev_dbg(isp->dev, "ZSL capture raw buffer id: %u\n",
-						exp_id);
-			}
-		}
-		break;
-	default:
-		break;
-	}
-	if (vb) {
-		get_buf_timestamp(&vb->ts);
-		vb->field_count = atomic_read(&asd->sequence) << 1;
-		/*mark videobuffer done for dequeue*/
-		spin_lock_irqsave(&pipe->irq_lock, irqflags);
-		vb->state = !error ? VIDEOBUF_DONE : VIDEOBUF_ERROR;
-		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
-
-		/*
-		 * Frame capture done, wake up any process block on
-		 * current active buffer
-		 * possibly hold by videobuf_dqbuf()
-		 */
-		wake_up(&vb->done);
-	}
-
-	/*
-	 * Requeue should only be done for 3a and dis buffers.
-	 * Queue/dequeue order will change if driver recycles image buffers.
-	 */
-	if (requeue) {
-		err = atomisp_css_queue_buffer(asd,
-					stream_id, css_pipe_id,
-					buf_type, &buffer);
-		if (err)
-			dev_err(isp->dev, "%s, q to css fails: %d\n",
-					__func__, err);
-		return;
-	}
-	if (!error && q_buffers)
-		atomisp_qbuffers_to_css(asd);
-}
-
-void atomisp_delayed_init_work(struct work_struct *work)
-{
-	struct atomisp_sub_device *asd = container_of(work,
-			struct atomisp_sub_device,
-			delayed_init_work);
-	atomisp_css_allocate_continuous_frames(false, asd);
-	atomisp_css_update_continuous_frames(asd);
-	asd->delayed_init = ATOMISP_DELAYED_INIT_WORK_DONE;
-}
-
-static void __atomisp_css_recover(struct atomisp_device *isp)
-{
-	enum atomisp_css_pipe_id css_pipe_id;
-	bool stream_restart[MAX_STREAM_NUM] = {0};
-	int i, ret;
-
-	if (!isp->sw_contex.file_input) {
-		atomisp_css_irq_enable(isp,
-				CSS_IRQ_INFO_CSS_RECEIVER_SOF, false);
-#if defined(CSS15) && defined(ISP2300)
-		atomisp_css_irq_enable(isp,
-				CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW, false);
-#endif
-	}
-
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		struct atomisp_sub_device *asd = &isp->asd[i];
-
-		if (asd->streaming !=
-				ATOMISP_DEVICE_STREAMING_ENABLED)
-			continue;
-		if (asd->delayed_init == ATOMISP_DELAYED_INIT_QUEUED)
-			cancel_work_sync(&asd->delayed_init_work);
-
-		complete(&asd->init_done);
-		asd->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
-
-		stream_restart[asd->index] = true;
-
-		asd->streaming = ATOMISP_DEVICE_STREAMING_STOPPING;
-
-		css_pipe_id = atomisp_get_css_pipe_id(asd);
-		atomisp_css_stop(asd, css_pipe_id, true);
-
-		atomisp_acc_unload_extensions(asd);
-
-		/* stream off sensor */
-		ret = v4l2_subdev_call(
-				isp->inputs[asd->input_curr].
-				camera, video, s_stream, 0);
-		if (ret)
-			dev_warn(isp->dev,
-					"can't stop streaming on sensor!\n");
-
-		atomisp_clear_css_buffer_counters(asd);
-		asd->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
-	}
-
-	/* clear irq */
-	enable_isp_irq(hrt_isp_css_irq_sp, false);
-	clear_isp_irq(hrt_isp_css_irq_sp);
-
-	/* reset ISP and restore its state */
-	isp->isp_timeout = true;
-	atomisp_reset(isp);
-	isp->isp_timeout = false;
-
-	/* The following frame after an ISP timeout
-	 * may be corrupted, so mark it so. */
-	isp->sw_contex.invalid_frame = 1;
-	isp->sw_contex.invalid_vf_frame = 1;
-	isp->sw_contex.invalid_s3a = 1;
-	isp->sw_contex.invalid_dis = 1;
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		struct atomisp_sub_device *asd = &isp->asd[i];
-
-		if (!stream_restart[i])
-			continue;
-
-		if (atomisp_acc_load_extensions(asd) < 0)
-			dev_err(isp->dev,
-					"acc extension failed to reload\n");
-
-		if (isp->inputs[asd->input_curr].type != FILE_INPUT)
-			atomisp_css_input_set_mode(asd,
-					CSS_INPUT_MODE_SENSOR);
-
-		css_pipe_id = atomisp_get_css_pipe_id(asd);
-		atomisp_css_start(asd, css_pipe_id, true);
-
-		asd->streaming = ATOMISP_DEVICE_STREAMING_ENABLED;
-	}
-
-	if (!isp->sw_contex.file_input) {
-		atomisp_css_irq_enable(isp,
-				CSS_IRQ_INFO_CSS_RECEIVER_SOF, true);
-#if defined(CSS15) && defined(ISP2300)
-		atomisp_css_irq_enable(isp,
-				CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW, true);
-#endif
-
-		atomisp_set_term_en_count(isp);
-
-		if (IS_ISP24XX(isp) &&
-		    atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO) < 0)
-			dev_dbg(isp->dev, "dfs failed!\n");
-	} else {
-		if (IS_ISP24XX(isp) &&
-		    atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX) < 0)
-			dev_dbg(isp->dev, "dfs failed!\n");
-	}
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		struct atomisp_sub_device *asd = &isp->asd[i];
-
-		if (!stream_restart[i])
-			continue;
-
-		ret = v4l2_subdev_call(
-				isp->inputs[asd->input_curr].camera, video,
-				s_stream, 1);
-		if (ret)
-			dev_warn(isp->dev,
-					"can't start streaming on sensor!\n");
-
-		if (asd->continuous_mode->val &&
-		    asd->delayed_init == ATOMISP_DELAYED_INIT_NOT_QUEUED) {
-			INIT_COMPLETION(asd->init_done);
-			asd->delayed_init = ATOMISP_DELAYED_INIT_QUEUED;
-			queue_work(asd->delayed_init_workq,
-					&asd->delayed_init_work);
-		}
-		/*
-		 * dequeueing buffers is not needed. CSS will recycle
-		 * buffers that it has.
-		 */
-		atomisp_flush_bufs_and_wakeup(asd);
-	}
-
-}
-
-void atomisp_wdt_work(struct work_struct *work)
-{
-	struct atomisp_device *isp = container_of(work, struct atomisp_device,
-						  wdt_work);
-	int i;
-
-	mutex_lock(&isp->mutex);
-	if (!atomisp_streaming_count(isp)) {
-		mutex_unlock(&isp->mutex);
-		return;
-	}
-
-	if (atomic_read(&isp->fast_reset)) {
-		atomisp_set_stop_timeout(0);
-		goto process_timeout;
-	}
-
-	dev_err(isp->dev, "timeout %d of %d\n",
-		atomic_read(&isp->wdt_count) + 1,
-		ATOMISP_ISP_MAX_TIMEOUT_COUNT);
-
-	if (atomic_inc_return(&isp->wdt_count) <
-			ATOMISP_ISP_MAX_TIMEOUT_COUNT) {
-		atomisp_css_debug_set_dtrace_level(CSS_DTRACE_VERBOSITY_TIMEOUT);
-		atomisp_css_debug_dump_sp_sw_debug_info();
-		atomisp_css_debug_dump_debug_info(__func__);
-		atomisp_css_debug_set_dtrace_level(CSS_DTRACE_VERBOSITY_LEVEL);
-		for (i = 0; i < isp->num_of_streams; i++) {
-			struct atomisp_sub_device *asd = &isp->asd[i];
-
-			if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
-				continue;
-			dev_err(isp->dev, "%s, vdev %s buffers in css: %d\n",
-				__func__,
-				asd->video_out_capture.vdev.name,
-				asd->video_out_capture.
-				buffers_in_css);
-			dev_err(isp->dev,
-				"%s, vdev %s buffers in css: %d\n",
-				__func__,
-				asd->video_out_vf.vdev.name,
-				asd->video_out_vf.
-				buffers_in_css);
-			dev_err(isp->dev,
-				"%s, vdev %s buffers in css: %d\n",
-				__func__,
-				asd->video_out_preview.vdev.name,
-				asd->video_out_preview.
-				buffers_in_css);
-			dev_err(isp->dev,
-				"%s, vdev %s buffers in css: %d\n",
-				__func__,
-				asd->video_out_video_capture.vdev.name,
-				asd->video_out_video_capture.
-				buffers_in_css);
-			dev_err(isp->dev,
-				"%s, s3a buffers in css preview pipe:%d\n",
-				__func__,
-				asd->
-				s3a_bufs_in_css[CSS_PIPE_ID_PREVIEW]);
-			dev_err(isp->dev,
-				"%s, s3a buffers in css capture pipe:%d\n",
-				__func__, asd->
-				s3a_bufs_in_css[CSS_PIPE_ID_CAPTURE]);
-			dev_err(isp->dev,
-				"%s, s3a buffers in css video pipe:%d\n",
-				__func__, asd->
-				s3a_bufs_in_css[CSS_PIPE_ID_VIDEO]);
-			dev_err(isp->dev,
-				"%s, dis buffers in css: %d\n",
-				__func__, asd->dis_bufs_in_css);
-		}
-
-		/*sh_css_dump_sp_state();*/
-		/*sh_css_dump_isp_state();*/
-	} else {
-		for (i = 0; i < isp->num_of_streams; i++) {
-			struct atomisp_sub_device *asd = &isp->asd[i];
-			if (asd->streaming ==
-			    ATOMISP_DEVICE_STREAMING_ENABLED) {
-				atomisp_clear_css_buffer_counters(asd);
-				atomisp_flush_bufs_and_wakeup(asd);
-				complete(&asd->init_done);
-			}
-		}
-
-		atomic_set(&isp->wdt_count, 0);
-		isp->isp_fatal_error = true;
-
-		mutex_unlock(&isp->mutex);
-		return;
-	}
-process_timeout:
-	__atomisp_css_recover(isp);
-	atomic_set(&isp->fast_reset, 0);
-	atomisp_set_stop_timeout(ATOMISP_CSS_STOP_TIMEOUT_US);
-	dev_err(isp->dev, "timeout recovery handling done\n");
-
-	mutex_unlock(&isp->mutex);
-}
-
-void atomisp_css_flush(struct atomisp_device *isp)
-{
-	if (!atomisp_streaming_count(isp))
-		return;
-
-	/* Disable wdt */
-	del_timer_sync(&isp->wdt);
-	cancel_work_sync(&isp->wdt_work);
-
-	/* Start recover */
-	__atomisp_css_recover(isp);
-
-	/* Restore wdt */
-	if (isp->sw_contex.file_input)
-		isp->wdt_duration = ATOMISP_ISP_FILE_TIMEOUT_DURATION;
-	else
-		isp->wdt_duration = ATOMISP_ISP_TIMEOUT_DURATION;
-
-	mod_timer(&isp->wdt, jiffies + isp->wdt_duration);
-
-	dev_dbg(isp->dev, "atomisp css flush done\n");
-}
-
-void atomisp_wdt(unsigned long isp_addr)
-{
-	struct atomisp_device *isp = (struct atomisp_device *)isp_addr;
-
-	queue_work(isp->wdt_work_queue, &isp->wdt_work);
-}
-
-void atomisp_setup_flash(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct v4l2_control ctrl;
-
-	if (asd->params.flash_state != ATOMISP_FLASH_REQUESTED &&
-	    asd->params.flash_state != ATOMISP_FLASH_DONE)
-		return;
-
-	if (asd->params.num_flash_frames) {
-		/* make sure the timeout is set before setting flash mode */
-		ctrl.id = V4L2_CID_FLASH_TIMEOUT;
-		ctrl.value = FLASH_TIMEOUT;
-
-		if (v4l2_subdev_call(isp->flash, core, s_ctrl, &ctrl)) {
-			dev_err(isp->dev, "flash timeout configure failed\n");
-			return;
-		}
-
-		atomisp_css_request_flash(asd);
-		asd->params.flash_state = ATOMISP_FLASH_ONGOING;
-	} else {
-		asd->params.flash_state = ATOMISP_FLASH_IDLE;
-	}
-}
-
-irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
-{
-	struct atomisp_device *isp = isp_ptr;
-	unsigned long flags;
-	bool frame_done_found[MAX_STREAM_NUM] = {0};
-	bool css_pipe_done[MAX_STREAM_NUM] = {0};
-	bool reset_wdt_timer = false;
-	unsigned int i;
-	struct atomisp_sub_device *asd = &isp->asd[0];
-
-	dev_dbg(isp->dev, ">%s\n", __func__);
-	mutex_lock(&isp->mutex);
-
-	spin_lock_irqsave(&isp->lock, flags);
-
-	if (!atomisp_streaming_count(isp) && !isp->acc.pipeline) {
-		spin_unlock_irqrestore(&isp->lock, flags);
-		goto out;
-	}
-	spin_unlock_irqrestore(&isp->lock, flags);
-	/*
-	 * The standard CSS2.0 API tells the following calling sequence of
-	 * dequeue ready buffers:
-	 * while (ia_css_dequeue_event(...)) {
-	 *	switch (event.type) {
-	 *	...
-	 *	ia_css_pipe_dequeue_buffer()
-	 *	}
-	 * }
-	 * That is, dequeue event and buffer are one after another.
-	 *
-	 * But the following implementation is to first deuque all the event
-	 * to a FIFO, then process the event in the FIFO.
-	 * This will not have issue in single stream mode, but it do have some
-	 * issue in multiple stream case. The issue is that
-	 * ia_css_pipe_dequeue_buffer() will not return the corrent buffer in
-	 * a specific pipe.
-	 *
-	 * This is due to ia_css_pipe_dequeue_buffer() does not take the
-	 * ia_css_pipe parameter.
-	 *
-	 * So:
-	 * For CSS2.0: we change the way to not dequeue all the event at one
-	 * time, instead, dequue one and process one, then another
-	 *
-	 * For CSS1.5: still keep previous implementation.
-	 */
-	if (atomisp_css_isr_thread(isp, frame_done_found, css_pipe_done,
-				   &reset_wdt_timer))
-		goto out;
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		asd = &isp->asd[i];
-		if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
-			continue;
-		if (frame_done_found[asd->index] &&
-		    asd->params.css_update_params_needed) {
-			atomisp_css_update_isp_params(asd);
-			asd->params.css_update_params_needed = false;
-			frame_done_found[asd->index] = false;
-		}
-		atomisp_setup_flash(asd);
-
-		/* If there are no buffers queued then
-		 * delete wdt timer. */
-		if (!atomisp_buffers_queued(asd)) {
-			del_timer(&isp->wdt);
-		} else if (reset_wdt_timer) {
-			/* SOF irq should not reset wdt timer. */
-			mod_timer(&isp->wdt, jiffies +
-				  isp->wdt_duration);
-			atomic_set(&isp->wdt_count, 0);
-		}
-	}
-out:
-	mutex_unlock(&isp->mutex);
-	for (i = 0; i < isp->num_of_streams; i++) {
-		asd = &isp->asd[i];
-		if (asd->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
-		    && css_pipe_done[asd->index]
-		    && isp->sw_contex.file_input)
-			v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-					 video, s_stream, 1);
-		/* FIXME! FIX ACC implementation */
-		if (isp->acc.pipeline && css_pipe_done[asd->index])
-			atomisp_css_acc_done(asd);
-	}
-	dev_dbg(isp->dev, "<%s\n", __func__);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * utils for buffer allocation/free
- */
-
-int atomisp_get_frame_pgnr(struct atomisp_device *isp,
-			   const struct atomisp_css_frame *frame, u32 *p_pgnr)
-{
-	if (!frame) {
-		dev_err(isp->dev, "%s: NULL frame pointer ERROR.\n", __func__);
-		return -EINVAL;
-	}
-
-	*p_pgnr = DIV_ROUND_UP(frame->data_bytes, PAGE_SIZE);
-	return 0;
-}
-
-/*
- * Get internal fmt according to V4L2 fmt
- */
-static enum atomisp_css_frame_format
-v4l2_fmt_to_sh_fmt(u32 fmt)
-{
-	switch (fmt) {
-	case V4L2_PIX_FMT_YUV420:
-		return CSS_FRAME_FORMAT_YUV420;
-	case V4L2_PIX_FMT_YVU420:
-		return CSS_FRAME_FORMAT_YV12;
-	case V4L2_PIX_FMT_YUV422P:
-		return CSS_FRAME_FORMAT_YUV422;
-	case V4L2_PIX_FMT_YUV444:
-		return CSS_FRAME_FORMAT_YUV444;
-	case V4L2_PIX_FMT_NV12:
-		return CSS_FRAME_FORMAT_NV12;
-	case V4L2_PIX_FMT_NV21:
-		return CSS_FRAME_FORMAT_NV21;
-	case V4L2_PIX_FMT_NV16:
-		return CSS_FRAME_FORMAT_NV16;
-	case V4L2_PIX_FMT_NV61:
-		return CSS_FRAME_FORMAT_NV61;
-	case V4L2_PIX_FMT_UYVY:
-		return CSS_FRAME_FORMAT_UYVY;
-	case V4L2_PIX_FMT_YUYV:
-		return CSS_FRAME_FORMAT_YUYV;
-	case V4L2_PIX_FMT_RGB24:
-		return CSS_FRAME_FORMAT_PLANAR_RGB888;
-	case V4L2_PIX_FMT_RGB32:
-		return CSS_FRAME_FORMAT_RGBA888;
-	case V4L2_PIX_FMT_RGB565:
-		return CSS_FRAME_FORMAT_RGB565;
-	case V4L2_PIX_FMT_SBGGR16:
-	case V4L2_PIX_FMT_SBGGR10:
-	case V4L2_PIX_FMT_SGBRG10:
-	case V4L2_PIX_FMT_SGRBG10:
-	case V4L2_PIX_FMT_SRGGB10:
-	case V4L2_PIX_FMT_SBGGR12:
-	case V4L2_PIX_FMT_SGBRG12:
-	case V4L2_PIX_FMT_SGRBG12:
-	case V4L2_PIX_FMT_SRGGB12:
-	case V4L2_PIX_FMT_SBGGR8:
-	case V4L2_PIX_FMT_SGBRG8:
-	case V4L2_PIX_FMT_SGRBG8:
-	case V4L2_PIX_FMT_SRGGB8:
-		return CSS_FRAME_FORMAT_RAW;
-	default:
-		return -EINVAL;
-	}
-}
-/*
- * raw format match between SH format and V4L2 format
- */
-static int raw_output_format_match_input(u32 input, u32 output)
-{
-	if ((input == CSS_FORMAT_RAW_12) &&
-	    ((output == V4L2_PIX_FMT_SRGGB12) ||
-	     (output == V4L2_PIX_FMT_SGRBG12) ||
-	     (output == V4L2_PIX_FMT_SBGGR12) ||
-	     (output == V4L2_PIX_FMT_SGBRG12)))
-		return 0;
-
-	if ((input == CSS_FORMAT_RAW_10) &&
-	    ((output == V4L2_PIX_FMT_SRGGB10) ||
-	     (output == V4L2_PIX_FMT_SGRBG10) ||
-	     (output == V4L2_PIX_FMT_SBGGR10) ||
-	     (output == V4L2_PIX_FMT_SGBRG10)))
-		return 0;
-
-	if ((input == CSS_FORMAT_RAW_8) &&
-	    ((output == V4L2_PIX_FMT_SRGGB8) ||
-	     (output == V4L2_PIX_FMT_SGRBG8) ||
-	     (output == V4L2_PIX_FMT_SBGGR8) ||
-	     (output == V4L2_PIX_FMT_SGBRG8)))
-		return 0;
-
-	if ((input == CSS_FORMAT_RAW_16) && (output == V4L2_PIX_FMT_SBGGR16))
-		return 0;
-
-	return -EINVAL;
-}
-
-static u32 get_pixel_depth(u32 pixelformat)
-{
-	switch (pixelformat) {
-	case V4L2_PIX_FMT_YUV420:
-	case V4L2_PIX_FMT_NV12:
-	case V4L2_PIX_FMT_NV21:
-	case V4L2_PIX_FMT_YVU420:
-		return 12;
-	case V4L2_PIX_FMT_YUV422P:
-	case V4L2_PIX_FMT_YUYV:
-	case V4L2_PIX_FMT_UYVY:
-	case V4L2_PIX_FMT_NV16:
-	case V4L2_PIX_FMT_NV61:
-	case V4L2_PIX_FMT_RGB565:
-	case V4L2_PIX_FMT_SBGGR16:
-	case V4L2_PIX_FMT_SBGGR12:
-	case V4L2_PIX_FMT_SGBRG12:
-	case V4L2_PIX_FMT_SGRBG12:
-	case V4L2_PIX_FMT_SRGGB12:
-	case V4L2_PIX_FMT_SBGGR10:
-	case V4L2_PIX_FMT_SGBRG10:
-	case V4L2_PIX_FMT_SGRBG10:
-	case V4L2_PIX_FMT_SRGGB10:
-		return 16;
-	case V4L2_PIX_FMT_RGB24:
-	case V4L2_PIX_FMT_YUV444:
-		return 24;
-	case V4L2_PIX_FMT_RGB32:
-		return 32;
-	case V4L2_PIX_FMT_SBGGR8:
-	case V4L2_PIX_FMT_SGBRG8:
-	case V4L2_PIX_FMT_SGRBG8:
-	case V4L2_PIX_FMT_SRGGB8:
-		return 8;
-	default:
-		return 8 * 2;	/* raw type now */
-	}
-}
-
-bool atomisp_is_mbuscode_raw(uint32_t code)
-{
-	return code >= 0x3000 && code < 0x4000;
-}
-
-/*
- * ISP features control function
- */
-
-/*
- * Set ISP capture mode based on current settings
- */
-static void atomisp_update_capture_mode(struct atomisp_sub_device *asd)
-{
-	if (asd->params.gdc_cac_en)
-		atomisp_css_capture_set_mode(asd, CSS_CAPTURE_MODE_ADVANCED);
-	else if (asd->params.low_light)
-		atomisp_css_capture_set_mode(asd, CSS_CAPTURE_MODE_LOW_LIGHT);
-	else if (asd->video_out_capture.sh_fmt == CSS_FRAME_FORMAT_RAW)
-		atomisp_css_capture_set_mode(asd, CSS_CAPTURE_MODE_RAW);
-	else
-		atomisp_css_capture_set_mode(asd, CSS_CAPTURE_MODE_PRIMARY);
-}
-
-/*
- * Function to enable/disable lens geometry distortion correction (GDC) and
- * chromatic aberration correction (CAC)
- */
-int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag,
-		    __s32 *value)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	if (flag == 0) {
-		*value = asd->params.gdc_cac_en;
-		return 0;
-	}
-
-	asd->params.gdc_cac_en = !!*value;
-	if (asd->params.gdc_cac_en) {
-		atomisp_css_set_morph_table(asd,
-				isp->inputs[asd->input_curr].morph_table);
-	} else {
-		atomisp_css_set_morph_table(asd, NULL);
-	}
-	asd->params.css_update_params_needed = true;
-	atomisp_update_capture_mode(asd);
-	return 0;
-}
-
-/*
- * Function to enable/disable low light mode including ANR
- */
-int atomisp_low_light(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value)
-{
-	if (flag == 0) {
-		*value = asd->params.low_light;
-		return 0;
-	}
-
-	asd->params.low_light = (*value != 0);
-	atomisp_update_capture_mode(asd);
-	return 0;
-}
-
-/*
- * Function to enable/disable extra noise reduction (XNR) in low light
- * condition
- */
-int atomisp_xnr(struct atomisp_sub_device *asd, int flag,
-		int *xnr_enable)
-{
-	if (flag == 0) {
-		*xnr_enable = asd->params.xnr_en;
-		return 0;
-	}
-
-	atomisp_css_capture_enable_xnr(asd, !!*xnr_enable);
-
-	return 0;
-}
-
-/*
- * Function to configure bayer noise reduction
- */
-int atomisp_nr(struct atomisp_sub_device *asd, int flag,
-	       struct atomisp_nr_config *arg)
-{
-	if (flag == 0) {
-		/* Get nr config from current setup */
-		if (atomisp_css_get_nr_config(asd, arg))
-			return -EINVAL;
-	} else {
-		/* Set nr config to isp parameters */
-		memcpy(&asd->params.nr_config, arg,
-			sizeof(struct atomisp_css_nr_config));
-		atomisp_css_set_nr_config(asd, &asd->params.nr_config);
-		asd->params.css_update_params_needed = true;
-	}
-	return 0;
-}
-
-/*
- * Function to configure temporal noise reduction (TNR)
- */
-int atomisp_tnr(struct atomisp_sub_device *asd, int flag,
-		struct atomisp_tnr_config *config)
-{
-	/* Get tnr config from current setup */
-	if (flag == 0) {
-		/* Get tnr config from current setup */
-		if (atomisp_css_get_tnr_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set tnr config to isp parameters */
-		memcpy(&asd->params.tnr_config, config,
-			sizeof(struct atomisp_css_tnr_config));
-		atomisp_css_set_tnr_config(asd, &asd->params.tnr_config);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-/*
- * Function to configure black level compensation
- */
-int atomisp_black_level(struct atomisp_sub_device *asd, int flag,
-			struct atomisp_ob_config *config)
-{
-	if (flag == 0) {
-		/* Get ob config from current setup */
-		if (atomisp_css_get_ob_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set ob config to isp parameters */
-		memcpy(&asd->params.ob_config, config,
-			sizeof(struct atomisp_css_ob_config));
-		atomisp_css_set_ob_config(asd, &asd->params.ob_config);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-/*
- * Function to configure edge enhancement
- */
-int atomisp_ee(struct atomisp_sub_device *asd, int flag,
-	       struct atomisp_ee_config *config)
-{
-	if (flag == 0) {
-		/* Get ee config from current setup */
-		if (atomisp_css_get_ee_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set ee config to isp parameters */
-		memcpy(&asd->params.ee_config, config,
-		       sizeof(asd->params.ee_config));
-		atomisp_css_set_ee_config(asd, &asd->params.ee_config);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-/*
- * Function to update Gamma table for gamma, brightness and contrast config
- */
-int atomisp_gamma(struct atomisp_sub_device *asd, int flag,
-		  struct atomisp_gamma_table *config)
-{
-	if (flag == 0) {
-		/* Get gamma table from current setup */
-		if (atomisp_css_get_gamma_table(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set gamma table to isp parameters */
-		memcpy(&asd->params.gamma_table, config,
-		       sizeof(asd->params.gamma_table));
-		atomisp_css_set_gamma_table(asd, &asd->params.gamma_table);
-	}
-
-	return 0;
-}
-
-/*
- * Function to update Ctc table for Chroma Enhancement
- */
-int atomisp_ctc(struct atomisp_sub_device *asd, int flag,
-		struct atomisp_ctc_table *config)
-{
-	if (flag == 0) {
-		/* Get ctc table from current setup */
-		if (atomisp_css_get_ctc_table(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set ctc table to isp parameters */
-		memcpy(&asd->params.ctc_table, config,
-			sizeof(asd->params.ctc_table));
-		atomisp_css_set_ctc_table(asd, &asd->params.ctc_table);
-	}
-
-	return 0;
-}
-
-/*
- * Function to update gamma correction parameters
- */
-int atomisp_gamma_correction(struct atomisp_sub_device *asd, int flag,
-	struct atomisp_gc_config *config)
-{
-	if (flag == 0) {
-		/* Get gamma correction params from current setup */
-		if (atomisp_css_get_gc_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set gamma correction params to isp parameters */
-		memcpy(&asd->params.gc_config, config,
-			sizeof(asd->params.gc_config));
-		atomisp_css_set_gc_config(asd, &asd->params.gc_config);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-void atomisp_free_internal_buffers(struct atomisp_sub_device *asd)
-{
-	struct atomisp_css_morph_table *tab;
-	struct atomisp_device *isp = asd->isp;
-
-	tab = isp->inputs[asd->input_curr].morph_table;
-	if (tab) {
-		atomisp_css_morph_table_free(tab);
-		isp->inputs[asd->input_curr].morph_table = NULL;
-	}
-	if (asd->raw_output_frame) {
-		atomisp_css_frame_free(asd->raw_output_frame);
-		asd->raw_output_frame = NULL;
-	}
-}
-
-void atomisp_free_3a_dis_buffers(struct atomisp_sub_device *asd)
-{
-	atomisp_css_free_3a_dis_buffers(asd);
-}
-
-static void atomisp_update_grid_info(struct atomisp_sub_device *asd,
-				enum atomisp_css_pipe_id pipe_id, int source_pad)
-{
-	struct atomisp_device *isp = asd->isp;
-	int err;
-
-	if (atomisp_css_get_grid_info(asd, pipe_id, source_pad))
-		return;
-
-	/* We must free all buffers because they no longer match
-	   the grid size. */
-	atomisp_free_3a_dis_buffers(asd);
-
-	err = atomisp_alloc_css_stat_bufs(asd);
-	if (err) {
-		dev_err(isp->dev, "stat_buf allocate error\n");
-		goto err_3a;
-	}
-
-	if (atomisp_alloc_3a_output_buf(asd))
-		goto err_3a;
-
-	if (atomisp_alloc_dis_coef_buf(asd))
-		goto err_dis;
-
-	return;
-
-	/* Failure for 3A buffers does not influence DIS buffers */
-err_3a:
-	if (asd->params.s3a_output_bytes != 0) {
-		/* For SOC sensor happens s3a_output_bytes == 0,
-		*  using if condition to exclude false error log */
-		dev_err(isp->dev, "Failed allocate memory for 3A statistics\n");
-	}
-	atomisp_free_3a_dis_buffers(asd);
-	return;
-
-err_dis:
-	dev_err(isp->dev, "Failed allocate memory for DIS statistics\n");
-	atomisp_free_3a_dis_buffers(asd);
-}
-
-static void atomisp_curr_user_grid_info(struct atomisp_sub_device *asd,
-				    struct atomisp_grid_info *info)
-{
-#ifndef CSS20
-	info->isp_in_width          = asd->params.curr_grid_info.isp_in_width;
-	info->isp_in_height         =
-		asd->params.curr_grid_info.isp_in_height;
-	info->s3a_width             =
-		asd->params.curr_grid_info.s3a_grid.width;
-	info->s3a_height            =
-		asd->params.curr_grid_info.s3a_grid.height;
-	info->s3a_bqs_per_grid_cell =
-		asd->params.curr_grid_info.s3a_grid.bqs_per_grid_cell;
-
-	info->dis_width          = asd->params.curr_grid_info.dvs_grid.width;
-	info->dis_aligned_width  =
-		asd->params.curr_grid_info.dvs_grid.aligned_width;
-	info->dis_height         = asd->params.curr_grid_info.dvs_grid.height;
-	info->dis_aligned_height =
-		asd->params.curr_grid_info.dvs_grid.aligned_height;
-	info->dis_bqs_per_grid_cell =
-		asd->params.curr_grid_info.dvs_grid.bqs_per_grid_cell;
-	info->dis_hor_coef_num      =
-		asd->params.curr_grid_info.dvs_hor_coef_num;
-	info->dis_ver_coef_num      =
-		asd->params.curr_grid_info.dvs_ver_coef_num;
-#else /* CSS20 */
-	memcpy(info, &asd->params.curr_grid_info.s3a_grid,
-			sizeof(struct atomisp_css_3a_grid_info));
-#endif /* CSS20 */
-}
-
-int atomisp_compare_grid(struct atomisp_sub_device *asd,
-				struct atomisp_grid_info *atomgrid)
-{
-	struct atomisp_grid_info tmp = {0};
-
-	atomisp_curr_user_grid_info(asd, &tmp);
-	return memcmp(atomgrid, &tmp, sizeof(tmp));
-}
-
-/*
- * Function to update Gdc table for gdc
- */
-int atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,
-			  struct atomisp_morph_table *config)
-{
-	int ret;
-	int i;
-	struct atomisp_device *isp = asd->isp;
-
-	if (flag == 0) {
-		/* Get gdc table from current setup */
-		struct atomisp_css_morph_table tab = {0};
-		atomisp_css_get_morph_table(asd, &tab);
-
-		config->width = tab.width;
-		config->height = tab.height;
-
-		for (i = 0; i < CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			ret = copy_to_user(config->coordinates_x[i],
-				tab.coordinates_x[i], tab.height *
-				tab.width * sizeof(*tab.coordinates_x[i]));
-			if (ret) {
-				dev_err(isp->dev,
-					"Failed to copy to User for x\n");
-				return -EFAULT;
-			}
-			ret = copy_to_user(config->coordinates_y[i],
-				tab.coordinates_y[i], tab.height *
-				tab.width * sizeof(*tab.coordinates_y[i]));
-			if (ret) {
-				dev_err(isp->dev,
-					"Failed to copy to User for y\n");
-				return -EFAULT;
-			}
-		}
-	} else {
-		struct atomisp_css_morph_table *tab =
-			isp->inputs[asd->input_curr].morph_table;
-
-		/* free first if we have one */
-		if (tab) {
-			atomisp_css_morph_table_free(tab);
-			isp->inputs[asd->input_curr].morph_table = NULL;
-		}
-
-		/* allocate new one */
-		tab = atomisp_css_morph_table_allocate(config->width,
-						  config->height);
-
-		if (!tab) {
-			dev_err(isp->dev, "out of memory\n");
-			return -EINVAL;
-		}
-
-		for (i = 0; i < CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			ret = copy_from_user(tab->coordinates_x[i],
-				config->coordinates_x[i],
-				config->height * config->width *
-				sizeof(*config->coordinates_x[i]));
-			if (ret) {
-				dev_err(isp->dev,
-				"Failed to copy from User for x, ret %d\n",
-				ret);
-				atomisp_css_morph_table_free(tab);
-				return -EFAULT;
-			}
-			ret = copy_from_user(tab->coordinates_y[i],
-				config->coordinates_y[i],
-				config->height * config->width *
-				sizeof(*config->coordinates_y[i]));
-			if (ret) {
-				dev_err(isp->dev,
-				"Failed to copy from User for y, ret is %d\n",
-				ret);
-				atomisp_css_morph_table_free(tab);
-				return -EFAULT;
-			}
-		}
-		isp->inputs[asd->input_curr].morph_table = tab;
-		if (asd->params.gdc_cac_en)
-			atomisp_css_set_morph_table(asd, tab);
-	}
-
-	return 0;
-}
-
-int atomisp_macc_table(struct atomisp_sub_device *asd, int flag,
-		       struct atomisp_macc_config *config)
-{
-	struct atomisp_css_macc_table *macc_table;
-
-	switch (config->color_effect) {
-	case V4L2_COLORFX_NONE:
-		macc_table = &asd->params.macc_table;
-		break;
-	case V4L2_COLORFX_SKY_BLUE:
-		macc_table = &blue_macc_table;
-		break;
-	case V4L2_COLORFX_GRASS_GREEN:
-		macc_table = &green_macc_table;
-		break;
-	case V4L2_COLORFX_SKIN_WHITEN_LOW:
-		macc_table = &skin_low_macc_table;
-		break;
-	case V4L2_COLORFX_SKIN_WHITEN:
-		macc_table = &skin_medium_macc_table;
-		break;
-	case V4L2_COLORFX_SKIN_WHITEN_HIGH:
-		macc_table = &skin_high_macc_table;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (flag == 0) {
-		/* Get macc table from current setup */
-		memcpy(&config->table, macc_table,
-		       sizeof(struct atomisp_css_macc_table));
-	} else {
-		memcpy(macc_table, &config->table,
-		       sizeof(struct atomisp_css_macc_table));
-		if (config->color_effect == asd->params.color_effect)
-			atomisp_css_set_macc_table(asd, macc_table);
-	}
-
-	return 0;
-}
-
-int atomisp_set_dis_vector(struct atomisp_sub_device *asd,
-			   struct atomisp_dis_vector *vector)
-{
-	atomisp_css_video_set_dis_vector(asd, vector);
-
-	asd->params.dis_proj_data_valid = false;
-	asd->params.css_update_params_needed = true;
-	return 0;
-}
-
-/*
- * Function to set/get image stablization statistics
- */
-int atomisp_get_dis_stat(struct atomisp_sub_device *asd,
-			 struct atomisp_dis_statistics *stats)
-{
-	return atomisp_css_get_dis_stat(asd, stats);
-}
-
-int atomisp_set_dis_coefs(struct atomisp_sub_device *asd,
-			  struct atomisp_dis_coefficients *coefs)
-{
-	return atomisp_css_set_dis_coefs(asd, coefs);
-}
-
-/*
- * Function to set/get 3A stat from isp
- */
-int atomisp_3a_stat(struct atomisp_sub_device *asd, int flag,
-		    struct atomisp_3a_statistics *config)
-{
-	unsigned long ret;
-	struct atomisp_device *isp = asd->isp;
-
-	if (flag != 0)
-		return -EINVAL;
-
-	/* sanity check to avoid writing into unallocated memory. */
-	if (asd->params.s3a_output_bytes == 0)
-		return -EINVAL;
-
-	if (atomisp_compare_grid(asd, &config->grid_info) != 0) {
-		/* If the grid info in the argument differs from the current
-		   grid info, we tell the caller to reset the grid size and
-		   try again. */
-		return -EAGAIN;
-	}
-
-	/* This is done in the atomisp_s3a_buf_done() */
-	if (!asd->params.s3a_buf_data_valid) {
-		dev_err(isp->dev, "3a statistics is not valid.\n");
-		return -EAGAIN;
-	}
-
-#ifdef CSS20
-	ret = copy_to_user(config->data, asd->params.s3a_user_stat->data,
-			   asd->params.s3a_output_bytes);
-#else /* CSS20 */
-	ret = copy_to_user(config->data, asd->params.s3a_output_buf,
-			   asd->params.s3a_output_bytes);
-#endif /* CSS20 */
-	if (ret) {
-		dev_err(isp->dev, "copy to user failed: copied %lu bytes\n",
-				ret);
-		return -EFAULT;
-	}
-	return 0;
-}
-
-static int __atomisp_set_general_isp_parameters(
-					struct atomisp_sub_device *asd,
-					struct atomisp_parameters *arg)
-{
-
-	/* TODO: add cnr_config when it's ready */
-	if (arg->wb_config) {
-		if (copy_from_user(&asd->params.wb_config, arg->wb_config,
-				   sizeof(struct atomisp_css_wb_config)))
-			return -EFAULT;
-		atomisp_css_set_wb_config(asd, &asd->params.wb_config);
-	}
-
-	if (arg->ob_config) {
-		if (copy_from_user(&asd->params.ob_config, arg->ob_config,
-				   sizeof(struct atomisp_css_ob_config)))
-			return -EFAULT;
-		atomisp_css_set_ob_config(asd, &asd->params.ob_config);
-	}
-
-	if (arg->dp_config) {
-		if (copy_from_user(&asd->params.dp_config, arg->dp_config,
-				   sizeof(struct atomisp_css_dp_config)))
-			return -EFAULT;
-		atomisp_css_set_dp_config(asd, &asd->params.dp_config);
-	}
-
-	if (arg->de_config) {
-		if (copy_from_user(&asd->params.de_config, arg->de_config,
-				   sizeof(struct atomisp_css_de_config)))
-			return -EFAULT;
-		atomisp_css_set_de_config(asd, &asd->params.de_config);
-	}
-
-	if (arg->ce_config) {
-		if (copy_from_user(&asd->params.ce_config, arg->ce_config,
-				   sizeof(struct atomisp_css_ce_config)))
-			return -EFAULT;
-		atomisp_css_set_ce_config(asd, &asd->params.ce_config);
-	}
-
-	if (arg->nr_config) {
-		if (copy_from_user(&asd->params.nr_config, arg->nr_config,
-				   sizeof(struct atomisp_css_nr_config)))
-			return -EFAULT;
-		atomisp_css_set_nr_config(asd, &asd->params.nr_config);
-	}
-
-	if (arg->ee_config) {
-		if (copy_from_user(&asd->params.ee_config, arg->ee_config,
-				   sizeof(struct atomisp_css_ee_config)))
-			return -EFAULT;
-		atomisp_css_set_ee_config(asd, &asd->params.ee_config);
-	}
-
-	if (arg->tnr_config) {
-		if (copy_from_user(&asd->params.tnr_config, arg->tnr_config,
-				   sizeof(struct atomisp_css_tnr_config)))
-			return -EFAULT;
-		atomisp_css_set_tnr_config(asd, &asd->params.tnr_config);
-	}
-
-	if (arg->cc_config) {
-		if (copy_from_user(&asd->params.cc_config, arg->cc_config,
-				   sizeof(struct atomisp_css_cc_config)))
-			return -EFAULT;
-		atomisp_css_set_cc_config(asd, &asd->params.cc_config);
-	}
-
-	if (arg->ctc_table) {
-		if (copy_from_user(&asd->params.ctc_table,
-				   arg->ctc_table,
-				   sizeof(asd->params.ctc_table)))
-			return -EFAULT;
-		atomisp_css_set_ctc_table(asd, &asd->params.ctc_table);
-	}
-
-	if (arg->gc_config) {
-		if (copy_from_user(&asd->params.gc_config, arg->gc_config,
-				   sizeof(asd->params.gc_config)))
-			return -EFAULT;
-		atomisp_css_set_gc_config(asd, &asd->params.gc_config);
-	}
-
-	if (arg->a3a_config) {
-		if (copy_from_user(&asd->params.s3a_config, arg->a3a_config,
-				   sizeof(asd->params.s3a_config)))
-			return -EFAULT;
-		atomisp_css_set_3a_config(asd, &asd->params.s3a_config);
-	}
-
-	if (arg->macc_config) {
-		if (copy_from_user(&asd->params.macc_table,
-			&arg->macc_config->table,
-			sizeof(struct atomisp_css_macc_table)))
-			return -EFAULT;
-		asd->params.color_effect = arg->macc_config->color_effect;
-		atomisp_css_set_macc_table(asd, &asd->params.macc_table);
-	}
-
-	if (arg->gamma_table) {
-		if (copy_from_user(&asd->params.gamma_table, arg->gamma_table,
-			sizeof(asd->params.gamma_table)))
-			return -EFAULT;
-		atomisp_css_set_gamma_table(asd, &asd->params.gamma_table);
-	}
-
-#ifdef CSS20
-	if (arg->ctc_config) {
-		if (copy_from_user(&asd->params.ctc_config, arg->ctc_config,
-					sizeof(struct atomisp_css_ctc_config)))
-			return -EFAULT;
-		atomisp_css_set_ctc_config(asd, &asd->params.ctc_config);
-	}
-
-	if (arg->cnr_config) {
-		if (copy_from_user(&asd->params.cnr_config, arg->cnr_config,
-				   sizeof(struct atomisp_css_cnr_config)))
-			return -EFAULT;
-		atomisp_css_set_cnr_config(asd, &asd->params.cnr_config);
-	}
-
-	if (arg->ecd_config) {
-		if (copy_from_user(&asd->params.ecd_config, arg->ecd_config,
-				   sizeof(struct atomisp_css_ecd_config)))
-			return -EFAULT;
-		atomisp_css_set_ecd_config(asd, &asd->params.ecd_config);
-	}
-
-	if (arg->ynr_config) {
-		if (copy_from_user(&asd->params.ynr_config, arg->ynr_config,
-				   sizeof(struct atomisp_css_ynr_config)))
-			return -EFAULT;
-		atomisp_css_set_ynr_config(asd, &asd->params.ynr_config);
-	}
-
-	if (arg->fc_config) {
-		if (copy_from_user(&asd->params.fc_config, arg->fc_config,
-				   sizeof(struct atomisp_css_fc_config)))
-			return -EFAULT;
-		atomisp_css_set_fc_config(asd, &asd->params.fc_config);
-	}
-
-	if (arg->macc_config) {
-		if (copy_from_user(&asd->params.macc_config, arg->macc_config,
-				   sizeof(struct atomisp_css_macc_config)))
-			return -EFAULT;
-		atomisp_css_set_macc_config(asd, &asd->params.macc_config);
-	}
-
-	if (arg->aa_config) {
-		if (copy_from_user(&asd->params.aa_config, arg->aa_config,
-				   sizeof(struct atomisp_css_aa_config)))
-			return -EFAULT;
-		atomisp_css_set_aa_config(asd, &asd->params.aa_config);
-	}
-
-	if (arg->anr_config) {
-		if (copy_from_user(&asd->params.anr_config, arg->anr_config,
-				   sizeof(struct atomisp_css_anr_config)))
-			return -EFAULT;
-		atomisp_css_set_anr_config(asd, &asd->params.anr_config);
-	}
-
-	if (arg->xnr_config) {
-		if (copy_from_user(&asd->params.xnr_config, arg->xnr_config,
-				   sizeof(struct atomisp_css_xnr_config)))
-			return -EFAULT;
-		atomisp_css_set_xnr_config(asd, &asd->params.xnr_config);
-	}
-
-	if (arg->yuv2rgb_cc_config) {
-		if (copy_from_user(&asd->params.yuv2rgb_cc_config,
-				   arg->yuv2rgb_cc_config,
-				   sizeof(struct atomisp_css_cc_config)))
-			return -EFAULT;
-		atomisp_css_set_yuv2rgb_cc_config(asd,
-					&asd->params.yuv2rgb_cc_config);
-	}
-
-	if (arg->rgb2yuv_cc_config) {
-		if (copy_from_user(&asd->params.rgb2yuv_cc_config,
-				   arg->rgb2yuv_cc_config,
-				   sizeof(struct atomisp_css_cc_config)))
-			return -EFAULT;
-		atomisp_css_set_rgb2yuv_cc_config(asd,
-					&asd->params.rgb2yuv_cc_config);
-	}
-
-	if (arg->macc_table) {
-		if (copy_from_user(&asd->params.macc_table, arg->macc_table,
-				   sizeof(struct atomisp_css_macc_table)))
-			return -EFAULT;
-		atomisp_css_set_macc_table(asd, &asd->params.macc_table);
-	}
-
-	if (arg->xnr_table) {
-		if (copy_from_user(&asd->params.xnr_table, arg->xnr_table,
-				   sizeof(struct atomisp_css_xnr_table)))
-			return -EFAULT;
-		atomisp_css_set_xnr_table(asd, &asd->params.xnr_table);
-	}
-
-	if (arg->r_gamma_table) {
-		if (copy_from_user(&asd->params.r_gamma_table,
-				   arg->r_gamma_table,
-				   sizeof(struct atomisp_css_rgb_gamma_table)))
-			return -EFAULT;
-		atomisp_css_set_r_gamma_table(asd, &asd->params.
-					      r_gamma_table);
-	}
-
-	if (arg->g_gamma_table) {
-		if (copy_from_user(&asd->params.g_gamma_table,
-				   arg->g_gamma_table,
-				   sizeof(struct atomisp_css_rgb_gamma_table)))
-			return -EFAULT;
-		atomisp_css_set_g_gamma_table(asd, &asd->params.
-					      g_gamma_table);
-	}
-
-	if (arg->b_gamma_table) {
-		if (copy_from_user(&asd->params.b_gamma_table,
-				   arg->b_gamma_table,
-				   sizeof(struct atomisp_css_rgb_gamma_table)))
-			return -EFAULT;
-		atomisp_css_set_b_gamma_table(asd, &asd->params.
-					      b_gamma_table);
-	}
-
-	if (arg->anr_thres) {
-		if (copy_from_user(&asd->params.anr_thres, arg->anr_thres,
-				   sizeof(struct atomisp_css_anr_thres)))
-			return -EFAULT;
-		atomisp_css_set_anr_thres(asd, &asd->params.anr_thres);
-	}
-#endif /* CSS20 */
-	return 0;
-}
-
-static int __atomisp_set_lsc_table(struct atomisp_sub_device *asd,
-			struct atomisp_shading_table *user_st)
-{
-	unsigned int i;
-	unsigned int len_table;
-	struct atomisp_css_shading_table *shading_table;
-	struct atomisp_css_shading_table *old_table;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!user_st)
-		return 0;
-
-	old_table = isp->inputs[asd->input_curr].shading_table;
-
-	/* user config is to disable the shading table. */
-	if (!user_st->enable) {
-		shading_table = NULL;
-		goto set_lsc;
-	}
-
-	/* Setting a new table. Validate first - all tables must be set */
-	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
-		if (!user_st->data[i])
-			return -EINVAL;
-	}
-
-	/* Shading table size per color */
-	if (user_st->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||
-		user_st->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR)
-		return -EINVAL;
-
-	shading_table = atomisp_css_shading_table_alloc(user_st->width,
-							user_st->height);
-	if (!shading_table)
-			return -ENOMEM;
-
-	len_table = user_st->width * user_st->height * ATOMISP_SC_TYPE_SIZE;
-	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
-		if (copy_from_user(shading_table->data[i],
-			user_st->data[i], len_table)) {
-			atomisp_css_shading_table_free(shading_table);
-			return -EFAULT;
-		}
-
-	}
-	shading_table->sensor_width = user_st->sensor_width;
-	shading_table->sensor_height = user_st->sensor_height;
-	shading_table->fraction_bits = user_st->fraction_bits;
-#ifdef CSS20
-	shading_table->enable = user_st->enable;
-
-	/* No need to update shading table if it is the same */
-	if (old_table != NULL &&
-		old_table->sensor_width == shading_table->sensor_width &&
-		old_table->sensor_height == shading_table->sensor_height &&
-		old_table->width == shading_table->width &&
-		old_table->height == shading_table->height &&
-		old_table->fraction_bits == shading_table->fraction_bits &&
-		old_table->enable == shading_table->enable) {
-		bool data_is_same = true;
-
-		for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
-			if (memcmp(shading_table->data[i], old_table->data[i],
-				len_table) != 0) {
-				data_is_same = false;
-				break;
-			}
-		}
-
-		if (data_is_same) {
-			atomisp_css_shading_table_free(shading_table);
-			return 0;
-		}
-	}
-#endif
-
-set_lsc:
-	/* set LSC to CSS */
-	isp->inputs[asd->input_curr].shading_table = shading_table;
-	atomisp_css_set_shading_table(asd, shading_table);
-	asd->params.sc_en = shading_table != NULL;
-
-	if (old_table)
-		atomisp_css_shading_table_free(old_table);
-
-	return 0;
-}
-
-#ifdef CSS20
-#include "ia_css_stream.h"	/* FIXME */
-int atomisp_set_dvs_6axis_config(struct atomisp_sub_device *asd,
-					  struct atomisp_dvs_6axis_config
-					  *user_6axis_config)
-{
-	struct atomisp_css_dvs_6axis_config *dvs_6axis_config;
-	struct atomisp_css_dvs_6axis_config *old_6axis_config;
-	struct ia_css_stream *stream = asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream;
-	struct ia_css_dvs_6axis_config *stream_dvs_config =
-	    stream->isp_params_configs->dvs_6axis_config;
-	int ret = -EFAULT;
-
-	if (!user_6axis_config)
-		return 0;
-
-	if (!stream_dvs_config)
-		return -EAGAIN;
-
-	if (stream_dvs_config->width_y != user_6axis_config->width_y ||
-	    stream_dvs_config->height_y != user_6axis_config->height_y ||
-	    stream_dvs_config->width_uv != user_6axis_config->width_uv ||
-	    stream_dvs_config->height_uv != user_6axis_config->height_uv) {
-		dev_err(asd->isp->dev, "%s: mismatch 6axis config!", __func__);
-		dev_err(asd->isp->dev, "CSS expected:width_y:%d, height_y:%d, width_uv:%d, height_uv:%d.\n",
-			 stream_dvs_config->width_y,
-			 stream_dvs_config->height_y,
-			 stream_dvs_config->width_uv,
-			 stream_dvs_config->height_uv);
-		dev_err(asd->isp->dev, "User space:width_y:%d, height_y:%d, width_uv:%d, height_uv:%d.\n",
-			 user_6axis_config->width_y,
-			 user_6axis_config->height_y,
-			 user_6axis_config->width_uv,
-			 user_6axis_config->height_uv);
-		return -EINVAL;
-	}
-
-	/* check whether need to reallocate for 6 axis config */
-	old_6axis_config = asd->params.dvs_6axis;
-	dvs_6axis_config = old_6axis_config;
-	if (old_6axis_config &&
-	    (old_6axis_config->width_y != user_6axis_config->width_y ||
-	     old_6axis_config->height_y != user_6axis_config->height_y ||
-	     old_6axis_config->width_uv != user_6axis_config->width_uv ||
-	     old_6axis_config->height_uv != user_6axis_config->height_uv)) {
-		ia_css_dvs2_6axis_config_free(asd->params.dvs_6axis);
-		asd->params.dvs_6axis = NULL;
-
-		dvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);
-		if (!dvs_6axis_config)
-			return -ENOMEM;
-	} else if (!dvs_6axis_config) {
-		dvs_6axis_config = ia_css_dvs2_6axis_config_allocate(stream);
-		if (!dvs_6axis_config)
-			return -ENOMEM;
-	}
-
-	dvs_6axis_config->exp_id = user_6axis_config->exp_id;
-
-	if (copy_from_user(dvs_6axis_config->xcoords_y,
-			   user_6axis_config->xcoords_y,
-			   user_6axis_config->width_y *
-			   user_6axis_config->height_y *
-			   sizeof(*user_6axis_config->xcoords_y)))
-		goto error;
-	if (copy_from_user(dvs_6axis_config->ycoords_y,
-			   user_6axis_config->ycoords_y,
-			   user_6axis_config->width_y *
-			   user_6axis_config->height_y *
-			   sizeof(*user_6axis_config->ycoords_y)))
-		goto error;
-	if (copy_from_user(dvs_6axis_config->xcoords_uv,
-			   user_6axis_config->xcoords_uv,
-			   user_6axis_config->width_uv *
-			   user_6axis_config->height_uv *
-			   sizeof(*user_6axis_config->xcoords_uv)))
-		goto error;
-	if (copy_from_user(dvs_6axis_config->ycoords_uv,
-			   user_6axis_config->ycoords_uv,
-			   user_6axis_config->width_uv *
-			   user_6axis_config->height_uv *
-			   sizeof(*user_6axis_config->ycoords_uv)))
-		goto error;
-
-	asd->params.dvs_6axis = dvs_6axis_config;
-	atomisp_css_set_dvs_6axis(asd, asd->params.dvs_6axis);
-	asd->params.css_update_params_needed = true;
-
-	return 0;
-
-error:
-	if (dvs_6axis_config)
-		ia_css_dvs2_6axis_config_free(dvs_6axis_config);
-	return ret;
-}
-#endif
-
-static int __atomisp_set_morph_table(struct atomisp_sub_device *asd,
-				struct atomisp_morph_table *user_morph_table)
-{
-	int ret = -EFAULT;
-	unsigned int i;
-	struct atomisp_css_morph_table *morph_table;
-	struct atomisp_css_morph_table *old_morph_table;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!user_morph_table)
-		return 0;
-
-	old_morph_table = isp->inputs[asd->input_curr].morph_table;
-
-	morph_table = atomisp_css_morph_table_allocate(user_morph_table->width,
-				user_morph_table->height);
-	if (!morph_table)
-		return -ENOMEM;
-
-	for (i = 0; i < CSS_MORPH_TABLE_NUM_PLANES; i++) {
-		if (copy_from_user(morph_table->coordinates_x[i],
-			user_morph_table->coordinates_x[i],
-			user_morph_table->height * user_morph_table->width *
-			sizeof(*user_morph_table->coordinates_x[i])))
-			goto error;
-
-		if (copy_from_user(morph_table->coordinates_y[i],
-			user_morph_table->coordinates_y[i],
-			user_morph_table->height * user_morph_table->width *
-			sizeof(*user_morph_table->coordinates_y[i])))
-			goto error;
-	}
-
-	isp->inputs[asd->input_curr].morph_table = morph_table;
-	if (asd->params.gdc_cac_en)
-		atomisp_css_set_morph_table(asd, morph_table);
-
-	if (old_morph_table)
-		atomisp_css_morph_table_free(old_morph_table);
-
-	return 0;
-
-error:
-	if (morph_table)
-		atomisp_css_morph_table_free(morph_table);
-	return ret;
-}
-
-/*
-* Function to configure ISP parameters
-*/
-int atomisp_set_parameters(struct atomisp_sub_device *asd,
-			struct atomisp_parameters *arg)
-{
-	int ret;
-
-	ret = __atomisp_set_general_isp_parameters(asd, arg);
-	if (ret)
-		return ret;
-
-	ret = __atomisp_set_lsc_table(asd, arg->shading_table);
-	if (ret)
-		return ret;
-
-	ret = __atomisp_set_morph_table(asd, arg->morph_table);
-	if (ret)
-		return ret;
-
-	/* indicate to CSS that we have parametes to be updated */
-	asd->params.css_update_params_needed = true;
-
-#ifdef CSS20
-	if (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream
-		&& (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_state != CSS_STREAM_STARTED
-		|| asd->run_mode->val
-			== ATOMISP_RUN_MODE_STILL_CAPTURE)) {
-		atomisp_css_update_isp_params(asd);
-		asd->params.css_update_params_needed = false;
-	}
-#endif
-	return 0;
-}
-
-/*
- * Function to set/get isp parameters to isp
- */
-int atomisp_param(struct atomisp_sub_device *asd, int flag,
-		  struct atomisp_parm *config)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	/* Read parameter for 3A binary info */
-	if (flag == 0) {
-		if (&config->info == NULL) {
-			dev_err(isp->dev, "ERROR: NULL pointer in grid_info\n");
-			return -EINVAL;
-		}
-		atomisp_curr_user_grid_info(asd, &config->info);
-#ifdef CSS20
-		/* update dvs grid info */
-		memcpy(&config->dvs_grid, &asd->params.curr_grid_info.dvs_grid,
-			sizeof(struct atomisp_css_dvs_grid_info));
-		/* update dvs envelop info */
-		config->dvs_envelop.width =
-		    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipe_configs[IA_CSS_PIPE_ID_VIDEO].
-		    dvs_envelope.width;
-		config->dvs_envelop.height =
-		    asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].pipe_configs[IA_CSS_PIPE_ID_VIDEO].
-		    dvs_envelope.height;
-#endif
-		return 0;
-	}
-
-	memcpy(&asd->params.wb_config, &config->wb_config,
-	       sizeof(struct atomisp_css_wb_config));
-	memcpy(&asd->params.ob_config, &config->ob_config,
-	       sizeof(struct atomisp_css_ob_config));
-	memcpy(&asd->params.dp_config, &config->dp_config,
-	       sizeof(struct atomisp_css_dp_config));
-	memcpy(&asd->params.de_config, &config->de_config,
-	       sizeof(struct atomisp_css_de_config));
-	memcpy(&asd->params.ce_config, &config->ce_config,
-	       sizeof(struct atomisp_css_ce_config));
-	memcpy(&asd->params.nr_config, &config->nr_config,
-	       sizeof(struct atomisp_css_nr_config));
-	memcpy(&asd->params.ee_config, &config->ee_config,
-	       sizeof(struct atomisp_css_ee_config));
-	memcpy(&asd->params.tnr_config, &config->tnr_config,
-	       sizeof(struct atomisp_css_tnr_config));
-
-	if (asd->params.color_effect == V4L2_COLORFX_NEGATIVE) {
-		config->cc_config.matrix[3] = -config->cc_config.matrix[3];
-		config->cc_config.matrix[4] = -config->cc_config.matrix[4];
-		config->cc_config.matrix[5] = -config->cc_config.matrix[5];
-		config->cc_config.matrix[6] = -config->cc_config.matrix[6];
-		config->cc_config.matrix[7] = -config->cc_config.matrix[7];
-		config->cc_config.matrix[8] = -config->cc_config.matrix[8];
-	}
-
-	if (asd->params.color_effect != V4L2_COLORFX_SEPIA &&
-	    asd->params.color_effect != V4L2_COLORFX_BW) {
-		memcpy(&asd->params.cc_config, &config->cc_config,
-		       sizeof(struct atomisp_css_cc_config));
-		atomisp_css_set_cc_config(asd, &asd->params.cc_config);
-	}
-
-	atomisp_css_set_wb_config(asd, &asd->params.wb_config);
-	atomisp_css_set_ob_config(asd, &asd->params.ob_config);
-	atomisp_css_set_de_config(asd, &asd->params.de_config);
-	atomisp_css_set_ce_config(asd, &asd->params.ce_config);
-	atomisp_css_set_dp_config(asd, &asd->params.dp_config);
-	atomisp_css_set_nr_config(asd, &asd->params.nr_config);
-	atomisp_css_set_ee_config(asd, &asd->params.ee_config);
-	atomisp_css_set_tnr_config(asd, &asd->params.tnr_config);
-	asd->params.css_update_params_needed = true;
-
-	return 0;
-}
-
-/*
- * Function to configure color effect of the image
- */
-int atomisp_color_effect(struct atomisp_sub_device *asd, int flag,
-			 __s32 *effect)
-{
-	struct atomisp_css_cc_config *cc_config = NULL;
-	struct atomisp_css_macc_table *macc_table = NULL;
-	struct atomisp_css_ctc_table *ctc_table = NULL;
-	int ret = 0;
-	struct v4l2_control control;
-	struct atomisp_device *isp = asd->isp;
-
-	if (flag == 0) {
-		*effect = asd->params.color_effect;
-		return 0;
-	}
-
-
-	control.id = V4L2_CID_COLORFX;
-	control.value = *effect;
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				core, s_ctrl, &control);
-	/*
-	 * if set color effect to sensor successfully, return
-	 * 0 directly.
-	 */
-	if (!ret) {
-		asd->params.color_effect = (u32)*effect;
-		return 0;
-	}
-
-	if (*effect == asd->params.color_effect)
-		return 0;
-
-#ifndef CSS20
-	/*
-	 * restore the default cc and ctc table config:
-	 * when change from sepia/mono to macc effect, the default
-	 * cc and ctc table should be used.
-	 */
-	cc_config = asd->params.default_cc_config;
-	ctc_table = asd->params.default_ctc_table;
-
-	/*
-	 * set macc table to default when change from macc to
-	 * sepia/mono,
-	 */
-	macc_table = asd->params.default_macc_table;
-#endif /* CSS20 */
-	/*
-	 * isp_subdev->params.macc_en should be set to false.
-	 */
-	asd->params.macc_en = false;
-
-	switch (*effect) {
-	case V4L2_COLORFX_NONE:
-		macc_table = &asd->params.macc_table;
-		asd->params.macc_en = true;
-		break;
-	case V4L2_COLORFX_SEPIA:
-		cc_config = &sepia_cc_config;
-		break;
-	case V4L2_COLORFX_NEGATIVE:
-		cc_config = &nega_cc_config;
-		break;
-	case V4L2_COLORFX_BW:
-		cc_config = &mono_cc_config;
-		break;
-	case V4L2_COLORFX_SKY_BLUE:
-		macc_table = &blue_macc_table;
-		asd->params.macc_en = true;
-		break;
-	case V4L2_COLORFX_GRASS_GREEN:
-		macc_table = &green_macc_table;
-		asd->params.macc_en = true;
-		break;
-	case V4L2_COLORFX_SKIN_WHITEN_LOW:
-		macc_table = &skin_low_macc_table;
-		asd->params.macc_en = true;
-		break;
-	case V4L2_COLORFX_SKIN_WHITEN:
-		macc_table = &skin_medium_macc_table;
-		asd->params.macc_en = true;
-		break;
-	case V4L2_COLORFX_SKIN_WHITEN_HIGH:
-		macc_table = &skin_high_macc_table;
-		asd->params.macc_en = true;
-		break;
-	case V4L2_COLORFX_VIVID:
-		ctc_table = &vivid_ctc_table;
-		break;
-	default:
-		return -EINVAL;
-	}
-	atomisp_update_capture_mode(asd);
-
-	if (cc_config)
-		atomisp_css_set_cc_config(asd, cc_config);
-	if (macc_table)
-		atomisp_css_set_macc_table(asd, macc_table);
-	if (ctc_table)
-		atomisp_css_set_ctc_table(asd, ctc_table);
-	asd->params.color_effect = (u32)*effect;
-	asd->params.css_update_params_needed = true;
-	return 0;
-}
-
-/*
- * Function to configure bad pixel correction
- */
-int atomisp_bad_pixel(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value)
-{
-
-	if (flag == 0) {
-		*value = asd->params.bad_pixel_en;
-		return 0;
-	}
-	asd->params.bad_pixel_en = !!*value;
-
-	return 0;
-}
-
-/*
- * Function to configure bad pixel correction params
- */
-int atomisp_bad_pixel_param(struct atomisp_sub_device *asd, int flag,
-			    struct atomisp_dp_config *config)
-{
-	if (flag == 0) {
-		/* Get bad pixel from current setup */
-		if (atomisp_css_get_dp_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set bad pixel to isp parameters */
-		memcpy(&asd->params.dp_config, config,
-			sizeof(asd->params.dp_config));
-		atomisp_css_set_dp_config(asd, &asd->params.dp_config);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-/*
- * Function to enable/disable video image stablization
- */
-int atomisp_video_stable(struct atomisp_sub_device *asd, int flag,
-			 __s32 *value)
-{
-	if (flag == 0)
-		*value = asd->params.video_dis_en;
-	else
-		asd->params.video_dis_en = !!*value;
-
-	return 0;
-}
-
-/*
- * Function to configure fixed pattern noise
- */
-int atomisp_fixed_pattern(struct atomisp_sub_device *asd, int flag,
-			  __s32 *value)
-{
-
-	if (flag == 0) {
-		*value = asd->params.fpn_en;
-		return 0;
-	}
-
-	if (*value == 0) {
-		asd->params.fpn_en = 0;
-		return 0;
-	}
-
-	/* Add function to get black from from sensor with shutter off */
-	return 0;
-}
-
-static unsigned int
-atomisp_bytesperline_to_padded_width(unsigned int bytesperline,
-				     enum atomisp_css_frame_format format)
-{
-	switch (format) {
-	case CSS_FRAME_FORMAT_UYVY:
-	case CSS_FRAME_FORMAT_YUYV:
-	case CSS_FRAME_FORMAT_RAW:
-	case CSS_FRAME_FORMAT_RGB565:
-		return bytesperline/2;
-	case CSS_FRAME_FORMAT_RGBA888:
-		return bytesperline/4;
-	/* The following cases could be removed, but we leave them
-	   in to document the formats that are included. */
-	case CSS_FRAME_FORMAT_NV11:
-	case CSS_FRAME_FORMAT_NV12:
-	case CSS_FRAME_FORMAT_NV16:
-	case CSS_FRAME_FORMAT_NV21:
-	case CSS_FRAME_FORMAT_NV61:
-	case CSS_FRAME_FORMAT_YV12:
-	case CSS_FRAME_FORMAT_YV16:
-	case CSS_FRAME_FORMAT_YUV420:
-	case CSS_FRAME_FORMAT_YUV420_16:
-	case CSS_FRAME_FORMAT_YUV422:
-	case CSS_FRAME_FORMAT_YUV422_16:
-	case CSS_FRAME_FORMAT_YUV444:
-	case CSS_FRAME_FORMAT_YUV_LINE:
-	case CSS_FRAME_FORMAT_PLANAR_RGB888:
-	case CSS_FRAME_FORMAT_QPLANE6:
-	case CSS_FRAME_FORMAT_BINARY_8:
-	default:
-		return bytesperline;
-	}
-}
-
-static int
-atomisp_v4l2_framebuffer_to_css_frame(const struct v4l2_framebuffer *arg,
-					 struct atomisp_css_frame **result)
-{
-	struct atomisp_css_frame *res;
-	unsigned int padded_width;
-	enum atomisp_css_frame_format sh_format;
-	char *tmp_buf = NULL;
-	int ret = 0;
-
-	sh_format = v4l2_fmt_to_sh_fmt(arg->fmt.pixelformat);
-	padded_width = atomisp_bytesperline_to_padded_width(
-					arg->fmt.bytesperline, sh_format);
-
-	/* Note: the padded width on an atomisp_css_frame is in elements, not in
-	   bytes. The RAW frame we use here should always be a 16bit RAW
-	   frame. This is why we bytesperline/2 is equal to the padded with */
-	if (atomisp_css_frame_allocate(&res, arg->fmt.width, arg->fmt.height,
-				  sh_format, padded_width, 0)) {
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	tmp_buf = vmalloc(arg->fmt.sizeimage);
-	if (!tmp_buf) {
-		ret = -ENOMEM;
-		goto err;
-	}
-	if (copy_from_user(tmp_buf, (void __user __force *)arg->base,
-			   arg->fmt.sizeimage)) {
-		ret = -EFAULT;
-		goto err;
-	}
-
-	if (hmm_store(res->data, tmp_buf, arg->fmt.sizeimage)) {
-		ret = -EINVAL;
-		goto err;
-	}
-
-err:
-	if (ret && res)
-		atomisp_css_frame_free(res);
-	if (tmp_buf)
-		vfree(tmp_buf);
-	if (ret == 0)
-		*result = res;
-	return ret;
-}
-
-/*
- * Function to configure fixed pattern noise table
- */
-int atomisp_fixed_pattern_table(struct atomisp_sub_device *asd,
-				struct v4l2_framebuffer *arg)
-{
-	struct atomisp_css_frame *raw_black_frame = NULL;
-	int ret;
-
-	if (arg == NULL)
-		return -EINVAL;
-
-	ret = atomisp_v4l2_framebuffer_to_css_frame(arg, &raw_black_frame);
-	if (ret)
-		return ret;
-	if (atomisp_css_set_black_frame(asd, raw_black_frame))
-		ret = -ENOMEM;
-
-	atomisp_css_frame_free(raw_black_frame);
-	return ret;
-}
-
-/*
- * Function to configure false color correction
- */
-int atomisp_false_color(struct atomisp_sub_device *asd, int flag,
-			__s32 *value)
-{
-	/* Get nr config from current setup */
-	if (flag == 0) {
-		*value = asd->params.false_color;
-		return 0;
-	}
-
-	/* Set nr config to isp parameters */
-	if (*value) {
-		atomisp_css_set_default_de_config(asd);
-	} else {
-		asd->params.de_config.pixelnoise = 0;
-		atomisp_css_set_de_config(asd, &asd->params.de_config);
-	}
-	asd->params.css_update_params_needed = true;
-	asd->params.false_color = *value;
-	return 0;
-}
-
-/*
- * Function to configure bad pixel correction params
- */
-int atomisp_false_color_param(struct atomisp_sub_device *asd, int flag,
-			      struct atomisp_de_config *config)
-{
-	if (flag == 0) {
-		/* Get false color from current setup */
-		if (atomisp_css_get_de_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set false color to isp parameters */
-		memcpy(&asd->params.de_config, config,
-				sizeof(asd->params.de_config));
-		atomisp_css_set_de_config(asd, &asd->params.de_config);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-/*
- * Function to configure white balance params
- */
-int atomisp_white_balance_param(struct atomisp_sub_device *asd, int flag,
-	struct atomisp_wb_config *config)
-{
-	if (flag == 0) {
-		/* Get white balance from current setup */
-		if (atomisp_css_get_wb_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set white balance to isp parameters */
-		memcpy(&asd->params.wb_config, config,
-				sizeof(asd->params.wb_config));
-		atomisp_css_set_wb_config(asd, &asd->params.wb_config);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-int atomisp_3a_config_param(struct atomisp_sub_device *asd, int flag,
-			    struct atomisp_3a_config *config)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	dev_dbg(isp->dev, ">%s %d\n", __func__, flag);
-
-	if (flag == 0) {
-		/* Get white balance from current setup */
-		if (atomisp_css_get_3a_config(asd, config))
-			return -EINVAL;
-	} else {
-		/* Set white balance to isp parameters */
-		memcpy(&asd->params.s3a_config, config,
-				sizeof(asd->params.s3a_config));
-		atomisp_css_set_3a_config(asd, &asd->params.s3a_config);
-		asd->params.css_update_params_needed = true;
-		/* isp_subdev->params.s3a_buf_data_valid = false; */
-	}
-
-	dev_dbg(isp->dev, "<%s %d\n", __func__, flag);
-	return 0;
-}
-
-/*
- * Function to enable/disable lens shading correction
- */
-int atomisp_shading_correction(struct atomisp_sub_device *asd, int flag,
-				       __s32 *value)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	if (flag == 0) {
-		*value = asd->params.sc_en;
-		return 0;
-	}
-
-	if (*value == 0)
-		atomisp_css_set_shading_table(asd, NULL);
-	else
-		atomisp_css_set_shading_table(asd,
-			isp->inputs[asd->input_curr].shading_table);
-
-	asd->params.sc_en = *value;
-
-	return 0;
-}
-
-/*
- * Function to setup digital zoom
- */
-int atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag,
-			 __s32 *value)
-{
-	u32 zoom;
-	struct atomisp_device *isp = asd->isp;
-
-	unsigned int max_zoom =
-		IS_ISP24XX(isp) ? MRFLD_MAX_ZOOM_FACTOR : MFLD_MAX_ZOOM_FACTOR;
-
-	if (flag == 0) {
-		atomisp_css_get_zoom_factor(asd, &zoom);
-		*value = max_zoom - zoom;
-	} else {
-		if (*value < 0)
-			return -EINVAL;
-
-		zoom = max_zoom - min_t(u32, max_zoom - 1, *value);
-
-		dev_dbg(isp->dev, "%s, zoom: %d\n", __func__, zoom);
-		atomisp_css_set_zoom_factor(asd, zoom);
-		asd->params.css_update_params_needed = true;
-	}
-
-	return 0;
-}
-
-/*
- * Function to get sensor specific info for current resolution,
- * which will be used for auto exposure conversion.
- */
-int atomisp_get_sensor_mode_data(struct atomisp_sub_device *asd,
-				 struct atomisp_sensor_mode_data *config)
-{
-	struct camera_mipi_info *mipi_info;
-	struct atomisp_device *isp = asd->isp;
-
-	mipi_info = atomisp_to_sensor_mipi_info(
-		isp->inputs[asd->input_curr].camera);
-	if (mipi_info == NULL)
-		return -EINVAL;
-
-	memcpy(config, &mipi_info->data, sizeof(*config));
-	return 0;
-}
-
-int atomisp_get_fmt(struct video_device *vdev, struct v4l2_format *f)
-{
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-
-	f->fmt.pix = pipe->pix;
-
-	return 0;
-}
-
-
-/* This function looks up the closest available resolution. */
-int atomisp_try_fmt(struct video_device *vdev, struct v4l2_format *f,
-						bool *res_overflow)
-{
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct v4l2_mbus_framefmt snr_mbus_fmt;
-	const struct atomisp_format_bridge *fmt;
-	int ret;
-
-	if (isp->inputs[asd->input_curr].camera == NULL)
-		return -EINVAL;
-
-	fmt = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
-	if (fmt == NULL) {
-		dev_err(isp->dev, "unsupported pixelformat!\n");
-		fmt = atomisp_output_fmts;
-	}
-
-	snr_mbus_fmt.code = fmt->mbus_code;
-	snr_mbus_fmt.width = f->fmt.pix.width;
-	snr_mbus_fmt.height = f->fmt.pix.height;
-
-	dev_dbg(isp->dev, "try_mbus_fmt: asking for %ux%u\n",
-		snr_mbus_fmt.width, snr_mbus_fmt.height);
-
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-			video, try_mbus_fmt, &snr_mbus_fmt);
-	if (ret)
-		return ret;
-
-	dev_dbg(isp->dev, "try_mbus_fmt: got %ux%u\n",
-		snr_mbus_fmt.width, snr_mbus_fmt.height);
-
-	fmt = atomisp_get_format_bridge_from_mbus(snr_mbus_fmt.code);
-	if (fmt == NULL) {
-		dev_err(isp->dev, "unknown sensor format 0x%8.8x\n",
-			snr_mbus_fmt.code);
-		return -EINVAL;
-	}
-
-	f->fmt.pix.pixelformat = fmt->pixelformat;
-
-	if (snr_mbus_fmt.width < f->fmt.pix.width
-	    && snr_mbus_fmt.height < f->fmt.pix.height) {
-		f->fmt.pix.width = snr_mbus_fmt.width;
-		f->fmt.pix.height = snr_mbus_fmt.height;
-		/* Set the flag when resolution requested is
-		 * beyond the max value supported by sensor
-		 */
-		if (res_overflow != NULL)
-			*res_overflow = true;
-	}
-
-	/* app vs isp */
-	f->fmt.pix.width = rounddown(
-		clamp_t(u32, f->fmt.pix.width, ATOM_ISP_MIN_WIDTH,
-			ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);
-	f->fmt.pix.height = rounddown(
-		clamp_t(u32, f->fmt.pix.height, ATOM_ISP_MIN_HEIGHT,
-			ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);
-
-	return 0;
-}
-
-static int
-atomisp_try_fmt_file(struct atomisp_device *isp, struct v4l2_format *f)
-{
-	u32 width = f->fmt.pix.width;
-	u32 height = f->fmt.pix.height;
-	u32 pixelformat = f->fmt.pix.pixelformat;
-	enum v4l2_field field = f->fmt.pix.field;
-	u32 depth;
-
-	if (!atomisp_get_format_bridge(pixelformat)) {
-		dev_err(isp->dev, "Wrong output pixelformat\n");
-		return -EINVAL;
-	}
-
-	depth = get_pixel_depth(pixelformat);
-
-	if (!field || field == V4L2_FIELD_ANY)
-		field = V4L2_FIELD_NONE;
-	else if (field != V4L2_FIELD_NONE) {
-		dev_err(isp->dev, "Wrong output field\n");
-		return -EINVAL;
-	}
-
-	f->fmt.pix.field = field;
-	f->fmt.pix.width = clamp_t(u32,
-				   rounddown(width, (u32)ATOM_ISP_STEP_WIDTH),
-				   ATOM_ISP_MIN_WIDTH, ATOM_ISP_MAX_WIDTH);
-	f->fmt.pix.height = clamp_t(u32, rounddown(height,
-						   (u32)ATOM_ISP_STEP_HEIGHT),
-				    ATOM_ISP_MIN_HEIGHT, ATOM_ISP_MAX_HEIGHT);
-	f->fmt.pix.bytesperline = (width * depth) >> 3;
-
-	return 0;
-}
-
-static mipi_port_ID_t __get_mipi_port(struct atomisp_device *isp,
-				      enum atomisp_camera_port port)
-{
-	switch (port) {
-	case ATOMISP_CAMERA_PORT_PRIMARY:
-		return MIPI_PORT0_ID;
-	case ATOMISP_CAMERA_PORT_SECONDARY:
-		return MIPI_PORT1_ID;
-	case ATOMISP_CAMERA_PORT_TERTIARY:
-		if (MIPI_PORT1_ID + 1 != N_MIPI_PORT_ID)
-			return MIPI_PORT1_ID + 1;
-		/* go through down for else case */
-	default:
-		dev_err(isp->dev, "unsupported port: %d\n", port);
-		return MIPI_PORT0_ID;
-	}
-}
-
-static inline void atomisp_set_sensor_mipi_to_isp(
-				struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				struct camera_mipi_info *mipi_info)
-{
-	/* Compatibility for sensors which provide no media bus code
-	 * in s_mbus_framefmt() nor support pad formats. */
-	if (mipi_info->input_format != -1) {
-		atomisp_css_input_set_bayer_order(asd, stream_id,
-						mipi_info->raw_bayer_order);
-		atomisp_css_input_set_format(asd, stream_id,
-						mipi_info->input_format);
-	}
-	atomisp_css_input_configure_port(asd, __get_mipi_port(asd->isp,
-							mipi_info->port),
-					mipi_info->num_lanes, 0xffff4);
-}
-
-static int __enable_continuous_mode(struct atomisp_sub_device *asd,
-				    bool enable)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	dev_dbg(isp->dev,
-		"continuous mode %d, raw buffers %d, stop preview %d\n",
-		enable, asd->continuous_raw_buffer_size->val,
-		!asd->continuous_viewfinder->val);
-	atomisp_css_capture_set_mode(asd, CSS_CAPTURE_MODE_PRIMARY);
-	/* in case of ANR, force capture pipe to offline mode */
-	atomisp_css_capture_enable_online(asd,
-			asd->params.low_light ? false : !enable);
-	atomisp_css_preview_enable_online(asd, !enable);
-	atomisp_css_enable_continuous(asd, enable);
-	atomisp_css_enable_cont_capt(enable,
-				!asd->continuous_viewfinder->val);
-
-	if (atomisp_css_continuous_set_num_raw_frames(asd,
-			asd->continuous_raw_buffer_size->val)) {
-		dev_err(isp->dev, "css_continuous_set_num_raw_frames failed\n");
-		return -EINVAL;
-	}
-
-	if (!enable) {
-		atomisp_css_enable_raw_binning(asd, false);
-		atomisp_css_input_set_two_pixels_per_clock(asd, false);
-	}
-
-	if (isp->inputs[asd->input_curr].type != FILE_INPUT)
-		atomisp_css_input_set_mode(asd, CSS_INPUT_MODE_SENSOR);
-
-	return atomisp_update_run_mode(asd);
-}
-
-int configure_pp_input_nop(struct atomisp_sub_device *asd,
-			   unsigned int width, unsigned int height)
-{
-	return 0;
-}
-
-int configure_output_nop(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format sh_fmt)
-{
-	return 0;
-}
-
-int get_frame_info_nop(struct atomisp_sub_device *asd,
-				struct atomisp_css_frame_info *finfo)
-{
-	return 0;
-}
-
-/**
- * Resets CSS parameters that depend on input resolution.
- *
- * Update params like CSS RAW binning, 2ppc mode and pp_input
- * which depend on input size, but are not automatically
- * handled in CSS when the input resolution is changed.
- */
-static int css_input_resolution_changed(struct atomisp_device *isp,
-		struct v4l2_mbus_framefmt *ffmt)
-{
-	struct atomisp_sub_device *asd = &isp->asd[0];
-	int ret = 0;
-
-	dev_dbg(isp->dev, "css_input_resolution_changed to %ux%u\n",
-		ffmt->width, ffmt->height);
-
-	if (asd->continuous_mode->val) {
-		/* Note for all checks: ffmt includes pad_w+pad_h */
-		if (IS_ISP24XX(isp)) {
-			if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
-			    (ffmt->width >= 2048 || ffmt->height >= 1536)) {
-				/*
-				 * For preview pipe, enable only if resolution
-				 * is >= 3M for ISP2400.
-				 */
-				atomisp_css_enable_raw_binning(asd, true);
-				atomisp_css_input_set_two_pixels_per_clock(asd,
-									false);
-			}
-		} else {
-			/* enable raw binning for >= 5M */
-			if (ffmt->width >= 2560 || ffmt->height >= 1920)
-				atomisp_css_enable_raw_binning(asd, true);
-			/* enable 2ppc for CTP if >= 9M */
-			if (ffmt->width >= 3648 || ffmt->height >= 2736)
-				atomisp_css_input_set_two_pixels_per_clock(
-					asd, true);
-		}
-	}
-
-#ifndef CSS20
-	ret = atomisp_css_capture_configure_pp_input(asd, ffmt->width,
-				ffmt->height);
-	if (ret)
-		dev_err(isp->dev, "configure_pp_input %ux%u\n",
-			ffmt->width, ffmt->height);
-#endif
-	return ret;
-
-	/*
-	 * TODO: atomisp_css_preview_configure_pp_input() not
-	 *       reset due to CSS bug tracked as PSI BZ 115124
-	 */
-}
-
-static int atomisp_set_fmt_to_isp(struct video_device *vdev,
-			struct atomisp_css_frame_info *output_info,
-			struct atomisp_css_frame_info *raw_output_info,
-			struct v4l2_pix_format *pix,
-			unsigned int source_pad)
-{
-	struct camera_mipi_info *mipi_info;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	const struct atomisp_format_bridge *format;
-	struct v4l2_rect *isp_sink_crop;
-	enum atomisp_css_pipe_id pipe_id;
-	struct v4l2_subdev_fh fh;
-	int (*configure_output)(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format sh_fmt) =
-							configure_output_nop;
-	int (*get_frame_info)(struct atomisp_sub_device *asd,
-				struct atomisp_css_frame_info *finfo) =
-							get_frame_info_nop;
-	int (*configure_pp_input)(struct atomisp_sub_device *asd,
-				  unsigned int width, unsigned int height) =
-							configure_pp_input_nop;
-	uint16_t stream_index = atomisp_source_pad_to_stream_id(asd, source_pad);
-	int ret;
-
-	v4l2_fh_init(&fh.vfh, vdev);
-
-	isp_sink_crop = atomisp_subdev_get_rect(
-		&asd->subdev, NULL, V4L2_SUBDEV_FORMAT_ACTIVE,
-		ATOMISP_SUBDEV_PAD_SINK, V4L2_SEL_TGT_CROP);
-
-	format = atomisp_get_format_bridge(pix->pixelformat);
-	if (format == NULL) {
-		dev_err(isp->dev, "format %d is not supported\n", pix->pixelformat);
-		return -EINVAL;
-	}
-
-	if (isp->inputs[asd->input_curr].type != TEST_PATTERN &&
-		isp->inputs[asd->input_curr].type != FILE_INPUT) {
-		mipi_info = atomisp_to_sensor_mipi_info(
-			isp->inputs[asd->input_curr].camera);
-		if (!mipi_info) {
-			dev_err(isp->dev, "mipi_info is NULL\n");
-			return -EINVAL;
-		}
-		atomisp_set_sensor_mipi_to_isp(asd, stream_index, mipi_info);
-
-		if (format->sh_fmt == CSS_FRAME_FORMAT_RAW &&
-		     raw_output_format_match_input(
-						   mipi_info->input_format, pix->pixelformat)) {
-			dev_err(isp->dev,
-				"Input format 0x%x is not match with the output format 0x%x\n",
-				mipi_info->input_format,
-				pix->pixelformat);
-			return -EINVAL;
-		}
-	}
-
-	/*
-	 * Configure viewfinder also when vfpp is disabled: the
-	 * CSS still requires viewfinder configuration.
-	 */
-	if (asd->fmt_auto->val ||
-	    asd->vfpp->val != ATOMISP_VFPP_ENABLE) {
-		struct v4l2_rect vf_size = {0};
-		struct v4l2_mbus_framefmt vf_ffmt = {0};
-
-		if (pix->width < 640 || pix->height < 480) {
-			vf_size.width = pix->width;
-			vf_size.height = pix->height;
-		} else {
-			vf_size.width = 640;
-			vf_size.height = 480;
-		}
-
-		/* FIXME: proper format name for this one. See
-		   atomisp_output_fmts[] in atomisp_v4l2.c */
-		vf_ffmt.code = 0x8001;
-
-		atomisp_subdev_set_selection(&asd->subdev, &fh,
-					     V4L2_SUBDEV_FORMAT_ACTIVE,
-					     ATOMISP_SUBDEV_PAD_SOURCE_VF,
-					     V4L2_SEL_TGT_COMPOSE, 0, &vf_size);
-		atomisp_subdev_set_ffmt(&asd->subdev, &fh,
-					V4L2_SUBDEV_FORMAT_ACTIVE,
-					ATOMISP_SUBDEV_PAD_SOURCE_VF, &vf_ffmt);
-#ifdef CSS20
-		asd->video_out_vf.sh_fmt = CSS_FRAME_FORMAT_NV12;
-#else
-		asd->video_out_vf.sh_fmt = CSS_FRAME_FORMAT_YUV420;
-#endif
-		if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
-			atomisp_css_video_configure_viewfinder(asd,
-				vf_size.width, vf_size.height, 0,
-				asd->video_out_vf.sh_fmt);
-		} else if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-			if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW ||
-			    source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VIDEO)
-				atomisp_css_video_configure_viewfinder(asd,
-					vf_size.width, vf_size.height, 0,
-					asd->video_out_vf.sh_fmt);
-			else
-				atomisp_css_capture_configure_viewfinder(asd,
-					vf_size.width, vf_size.height, 0,
-					asd->video_out_vf.sh_fmt);
-		} else if (source_pad != ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW ||
-			 asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {
-			atomisp_css_capture_configure_viewfinder(asd,
-				vf_size.width, vf_size.height, 0,
-				asd->video_out_vf.sh_fmt);
-		}
-	}
-
-	if (asd->continuous_mode->val) {
-		ret = __enable_continuous_mode(asd, true);
-		if (ret) {
-			dev_err(isp->dev, "enable continuous mode failed\n");
-			return -EINVAL;
-		}
-	}
-
-	atomisp_css_input_set_mode(asd, CSS_INPUT_MODE_SENSOR);
-	atomisp_css_disable_vf_pp(asd,
-			asd->vfpp->val != ATOMISP_VFPP_ENABLE);
-
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-	/* ISP2401 new input system need to use copy pipe */
-	if (format->sh_fmt == CSS_FRAME_FORMAT_RAW ||
-			isp->inputs[asd->input_curr].type == SOC_CAMERA) {
-		pipe_id = CSS_PIPE_ID_COPY;
-	} else
-#endif
-	/* video same in continuouscapture and online modes */
-	if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
-		configure_output = atomisp_css_video_configure_output;
-		get_frame_info = atomisp_css_video_get_output_frame_info;
-		pipe_id = CSS_PIPE_ID_VIDEO;
-	} else if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-		if (!asd->continuous_mode->val) {
-			configure_output = atomisp_css_video_configure_output;
-			get_frame_info =
-				atomisp_css_video_get_output_frame_info;
-			pipe_id = CSS_PIPE_ID_VIDEO;
-		} else {
-			if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW ||
-			    source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VIDEO) {
-				configure_output =
-					atomisp_css_video_configure_output;
-				get_frame_info =
-					atomisp_css_video_get_output_frame_info;
-				configure_pp_input =
-					atomisp_css_video_configure_pp_input;
-				pipe_id = CSS_PIPE_ID_VIDEO;
-			} else {
-				configure_output =
-					atomisp_css_capture_configure_output;
-				get_frame_info =
-					atomisp_css_capture_get_output_frame_info;
-				configure_pp_input =
-					atomisp_css_capture_configure_pp_input;
-				pipe_id = CSS_PIPE_ID_CAPTURE;
-
-				atomisp_update_capture_mode(asd);
-				atomisp_css_capture_enable_online(asd, false);
-			}
-		}
-	} else if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW) {
-		configure_output = atomisp_css_preview_configure_output;
-		get_frame_info = atomisp_css_preview_get_output_frame_info;
-		configure_pp_input = atomisp_css_preview_configure_pp_input;
-		pipe_id = CSS_PIPE_ID_PREVIEW;
-	} else {
-		/* CSS doesn't support low light mode on SOC cameras, so disable
-		 * it. FIXME: if this is done elsewhere, it gives corrupted
-		 * colors into thumbnail image.
-		 */
-		if (isp->inputs[asd->input_curr].type == SOC_CAMERA)
-			asd->params.low_light = false;
-
-		if (format->sh_fmt == CSS_FRAME_FORMAT_RAW) {
-			atomisp_css_capture_set_mode(asd, CSS_CAPTURE_MODE_RAW);
-			atomisp_css_enable_dz(asd, false);
-		} else {
-			atomisp_update_capture_mode(asd);
-		}
-
-		if (!asd->continuous_mode->val)
-			/* in case of ANR, force capture pipe to offline mode */
-			atomisp_css_capture_enable_online(asd,
-					asd->params.low_light ?
-					false : asd->params.online_process);
-
-		configure_output = atomisp_css_capture_configure_output;
-		get_frame_info = atomisp_css_capture_get_output_frame_info;
-		configure_pp_input = atomisp_css_capture_configure_pp_input;
-		pipe_id = CSS_PIPE_ID_CAPTURE;
-
-		if (!asd->params.online_process &&
-		    !asd->continuous_mode->val) {
-			ret = atomisp_css_capture_get_output_raw_frame_info(asd,
-							raw_output_info);
-			if (ret)
-				return ret;
-		}
-		if (!asd->continuous_mode->val && asd->run_mode->val
-		    != ATOMISP_RUN_MODE_STILL_CAPTURE) {
-			dev_err(isp->dev,
-				    "Need to set the running mode first\n");
-			asd->run_mode->val = ATOMISP_RUN_MODE_STILL_CAPTURE;
-		}
-	}
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-	/* ISP2401 new input system need to use copy pipe */
-	if (format->sh_fmt == CSS_FRAME_FORMAT_RAW ||
-			isp->inputs[asd->input_curr].type == SOC_CAMERA)
-		ret = atomisp_css_copy_configure_output(asd, stream_index,
-				pix->width, pix->height, format->sh_fmt);
-	else
-		ret = configure_output(asd, pix->width, pix->height,
-				       format->planar ? pix->bytesperline :
-				       pix->bytesperline * 8 / format->depth,
-				       format->sh_fmt);
-#else
-	ret = configure_output(asd, pix->width, pix->height,
-			       format->planar ? pix->bytesperline :
-			       pix->bytesperline * 8 / format->depth,
-			       format->sh_fmt);
-#endif
-	if (ret) {
-		dev_err(isp->dev, "configure_output %ux%u, format %8.8x\n",
-			pix->width, pix->height, format->sh_fmt);
-		return -EINVAL;
-	}
-
-	if (asd->continuous_mode->val &&
-	    (configure_pp_input == atomisp_css_preview_configure_pp_input ||
-	     configure_pp_input == atomisp_css_video_configure_pp_input)) {
-#ifdef CSS20
-		/* for isp 2.2, configure pp input is available for continuous
-		 * mode */
-		ret = configure_pp_input(asd, isp_sink_crop->width,
-					 isp_sink_crop->height);
-		if (ret) {
-			dev_err(isp->dev, "configure_pp_input %ux%u\n",
-				isp_sink_crop->width,
-				isp_sink_crop->height);
-			return -EINVAL;
-		}
-#else
-		/* See PSI BZ 115124. preview_configure_pp_input()
-		 * API does not work correctly in continuous mode and
-		 * and must be disabled by setting it to (0, 0).
-		 */
-		configure_pp_input(asd, 0, 0);
-#endif
-	} else {
-		ret = configure_pp_input(asd, isp_sink_crop->width,
-					 isp_sink_crop->height);
-		if (ret) {
-			dev_err(isp->dev, "configure_pp_input %ux%u\n",
-				isp_sink_crop->width, isp_sink_crop->height);
-			return -EINVAL;
-		}
-	}
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-	/* ISP2401 new input system need to use copy pipe */
-	if (format->sh_fmt == CSS_FRAME_FORMAT_RAW ||
-			isp->inputs[asd->input_curr].type == SOC_CAMERA)
-		ret = atomisp_css_copy_get_output_frame_info(asd, stream_index,
-				output_info);
-	else
-		ret = get_frame_info(asd, output_info);
-#else
-	ret = get_frame_info(asd, output_info);
-#endif
-	if (ret) {
-		dev_err(isp->dev, "get_frame_info %ux%u (padded to %u)\n",
-			pix->width, pix->height, pix->bytesperline);
-		return -EINVAL;
-	}
-
-	atomisp_update_grid_info(asd, pipe_id, source_pad);
-
-	/* Free the raw_dump buffer first */
-	atomisp_css_frame_free(asd->raw_output_frame);
-	asd->raw_output_frame = NULL;
-
-	if (!asd->continuous_mode->val &&
-	    !asd->params.online_process && !isp->sw_contex.file_input &&
-		atomisp_css_frame_allocate_from_info(&asd->raw_output_frame,
-							raw_output_info))
-		return -ENOMEM;
-
-	return 0;
-}
-
-static void atomisp_get_dis_envelop(struct atomisp_sub_device *asd,
-			    unsigned int width, unsigned int height,
-			    unsigned int *dvs_env_w, unsigned int *dvs_env_h)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	/* if subdev type is SOC camera,we do not need to set DVS */
-	if (isp->inputs[asd->input_curr].type == SOC_CAMERA)
-		asd->params.video_dis_en = 0;
-
-	if (asd->params.video_dis_en &&
-	    asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-		/* envelope is 20% of the output resolution */
-		/*
-		 * dvs envelope cannot be round up.
-		 * it would cause ISP timeout and color switch issue
-		 */
-		*dvs_env_w = rounddown(width / 5, ATOM_ISP_STEP_WIDTH);
-		*dvs_env_h = rounddown(height / 5, ATOM_ISP_STEP_HEIGHT);
-	}
-
-	asd->params.dis_proj_data_valid = false;
-	asd->params.css_update_params_needed = true;
-}
-
-static int atomisp_set_fmt_to_snr(struct video_device *vdev,
-		struct v4l2_format *f, unsigned int pixelformat,
-		unsigned int padding_w, unsigned int padding_h,
-		unsigned int dvs_env_w, unsigned int dvs_env_h)
-{
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	const struct atomisp_format_bridge *format;
-	struct v4l2_mbus_framefmt ffmt, req_ffmt;
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_input_stream_info *stream_info =
-		(struct atomisp_input_stream_info *)ffmt.reserved;
-	uint16_t stream_index = ATOMISP_INPUT_STREAM_GENERAL;
-	int source_pad = atomisp_subdev_source_pad(vdev);
-	struct v4l2_subdev_fh fh;
-	int ret;
-
-	v4l2_fh_init(&fh.vfh, vdev);
-
-	stream_index = atomisp_source_pad_to_stream_id(asd, source_pad);
-
-	format = atomisp_get_format_bridge(pixelformat);
-	if (format == NULL)
-		return -EINVAL;
-
-	v4l2_fill_mbus_format(&ffmt, &f->fmt.pix, format->mbus_code);
-	ffmt.height += padding_h + dvs_env_h;
-	ffmt.width += padding_w + dvs_env_w;
-
-	dev_dbg(isp->dev, "s_mbus_fmt: ask %ux%u (padding %ux%u, dvs %ux%u)\n",
-		ffmt.width, ffmt.height, padding_w, padding_h,
-		dvs_env_w, dvs_env_h);
-
-	stream_info->enable = 1;
-	stream_info->stream = stream_index;
-	stream_info->ch_id = 0;
-
-	req_ffmt = ffmt;
-
-	/* Disable dvs if resolution can't be supported by sensor */
-	if (asd->params.video_dis_en) {
-		ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-			video, try_mbus_fmt, &ffmt);
-		if (ret)
-			return ret;
-		if (ffmt.width < req_ffmt.width ||
-				ffmt.height < req_ffmt.height) {
-			req_ffmt.height -= dvs_env_h;
-			req_ffmt.width -= dvs_env_w;
-			ffmt = req_ffmt;
-			dev_warn(isp->dev,
-			  "can not enable video dis due to sensor limitation.");
-			asd->params.video_dis_en = 0;
-		}
-	}
-	dev_dbg(isp->dev, "sensor width: %d, height: %d\n",
-		ffmt.width, ffmt.height);
-
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera, video,
-			       s_mbus_fmt, &ffmt);
-	if (ret)
-		return ret;
-
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-	/* assign virtual channel id return from sensor driver query */
-	asd->stream_env[stream_index].ch_id = stream_info->ch_id;
-#endif
-	dev_dbg(isp->dev, "sensor width: %d, height: %d\n",
-		ffmt.width, ffmt.height);
-
-	if (ffmt.width < ATOM_ISP_STEP_WIDTH ||
-	    ffmt.height < ATOM_ISP_STEP_HEIGHT)
-			return -EINVAL;
-
-	if (asd->params.video_dis_en && (ffmt.width < req_ffmt.width ||
-	    ffmt.height < req_ffmt.height)) {
-		dev_warn(isp->dev,
-			 "can not enable video dis due to sensor limitation.");
-		asd->params.video_dis_en = 0;
-	}
-
-	atomisp_subdev_set_ffmt(&asd->subdev, &fh,
-				V4L2_SUBDEV_FORMAT_ACTIVE,
-				ATOMISP_SUBDEV_PAD_SINK, &ffmt);
-
-	return css_input_resolution_changed(isp, &ffmt);
-}
-
-int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f)
-{
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	const struct atomisp_format_bridge *format_bridge;
-	struct atomisp_css_frame_info output_info, raw_output_info;
-	struct v4l2_format snr_fmt = *f;
-	unsigned int dvs_env_w = 0, dvs_env_h = 0;
-	unsigned int padding_w = pad_w, padding_h = pad_h;
-	bool res_overflow = false, crop_needs_override = false;
-	struct v4l2_mbus_framefmt isp_sink_fmt;
-	struct v4l2_mbus_framefmt isp_source_fmt = {0};
-	struct v4l2_rect isp_sink_crop;
-	uint16_t source_pad = atomisp_subdev_source_pad(vdev);
-	struct v4l2_subdev_fh fh;
-	int ret;
-
-	dev_dbg(isp->dev,
-		"setting resolution %ux%u on pad %u, bytesperline %u\n",
-		f->fmt.pix.width, f->fmt.pix.height, source_pad,
-		f->fmt.pix.bytesperline);
-
-	v4l2_fh_init(&fh.vfh, vdev);
-
-	format_bridge = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
-	if (format_bridge == NULL)
-		return -EINVAL;
-
-	pipe->sh_fmt = format_bridge->sh_fmt;
-	pipe->pix.pixelformat = f->fmt.pix.pixelformat;
-
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-	if (isp->inputs[asd->input_curr].camera_caps->sensor[asd->sensor_curr].
-			stream_num < 2 &&
-			(source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VF ||
-			 (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW
-		&& asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO))) {
-#else
-	if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VF ||
-	    (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW
-		&& asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)) {
-#endif
-		if (asd->fmt_auto->val) {
-			struct v4l2_rect *capture_comp;
-			struct v4l2_rect r = {0};
-
-			r.width = f->fmt.pix.width;
-			r.height = f->fmt.pix.height;
-
-			if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW)
-				capture_comp = atomisp_subdev_get_rect(
-					&asd->subdev, NULL,
-					V4L2_SUBDEV_FORMAT_ACTIVE,
-					ATOMISP_SUBDEV_PAD_SOURCE_VIDEO,
-					V4L2_SEL_TGT_COMPOSE);
-			else
-				capture_comp = atomisp_subdev_get_rect(
-					&asd->subdev, NULL,
-					V4L2_SUBDEV_FORMAT_ACTIVE,
-					ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
-					V4L2_SEL_TGT_COMPOSE);
-
-			if (capture_comp->width < r.width
-			    || capture_comp->height < r.height) {
-				r.width = capture_comp->width;
-				r.height = capture_comp->height;
-			}
-
-			atomisp_subdev_set_selection(
-				&asd->subdev, &fh,
-				V4L2_SUBDEV_FORMAT_ACTIVE, source_pad,
-				V4L2_SEL_TGT_COMPOSE, 0, &r);
-
-			f->fmt.pix.width = r.width;
-			f->fmt.pix.height = r.height;
-		}
-
-		if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW) {
-			atomisp_css_video_configure_viewfinder(asd,
-				f->fmt.pix.width, f->fmt.pix.height,
-				format_bridge->planar ? f->fmt.pix.bytesperline
-				: f->fmt.pix.bytesperline * 8
-				/ format_bridge->depth,	format_bridge->sh_fmt);
-			atomisp_css_video_get_viewfinder_frame_info(asd,
-								&output_info);
-		} else {
-			atomisp_css_capture_configure_viewfinder(asd,
-				f->fmt.pix.width, f->fmt.pix.height,
-				format_bridge->planar ? f->fmt.pix.bytesperline
-				: f->fmt.pix.bytesperline * 8
-				/ format_bridge->depth,	format_bridge->sh_fmt);
-			atomisp_css_capture_get_viewfinder_frame_info(asd,
-								&output_info);
-		}
-
-		goto done;
-	}
-	/*
-	 * Check whether main resolution configured smaller
-	 * than snapshot resolution. If so, force main resolution
-	 * to be the same as snapshot resolution
-	 */
-	if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE) {
-		struct v4l2_rect *r;
-
-		r = atomisp_subdev_get_rect(
-			&asd->subdev, NULL,
-			V4L2_SUBDEV_FORMAT_ACTIVE,
-			ATOMISP_SUBDEV_PAD_SOURCE_VF, V4L2_SEL_TGT_COMPOSE);
-
-		if (r->width && r->height
-		    && (r->width > f->fmt.pix.width
-			|| r->height > f->fmt.pix.height))
-			dev_warn(isp->dev,
-				 "Main Resolution config smaller then Vf Resolution. Force to be equal with Vf Resolution.");
-	}
-
-	/* Pipeline configuration done through subdevs. Bail out now. */
-	if (!asd->fmt_auto->val)
-		goto set_fmt_to_isp;
-
-	/* get sensor resolution and format */
-	ret = atomisp_try_fmt(vdev, &snr_fmt, &res_overflow);
-	if (ret)
-		return ret;
-	f->fmt.pix.width = snr_fmt.fmt.pix.width;
-	f->fmt.pix.height = snr_fmt.fmt.pix.height;
-
-	format_bridge = atomisp_get_format_bridge(snr_fmt.fmt.pix.pixelformat);
-	if (format_bridge == NULL)
-		return -EINVAL;
-
-	atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				V4L2_SUBDEV_FORMAT_ACTIVE,
-				ATOMISP_SUBDEV_PAD_SINK)->code =
-		format_bridge->mbus_code;
-
-	isp_sink_fmt = *atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-					    V4L2_SUBDEV_FORMAT_ACTIVE,
-					    ATOMISP_SUBDEV_PAD_SINK);
-	format_bridge = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
-	if (format_bridge == NULL)
-		return -EINVAL;
-
-	isp_source_fmt.code = format_bridge->mbus_code;
-	atomisp_subdev_set_ffmt(&asd->subdev, &fh,
-				V4L2_SUBDEV_FORMAT_ACTIVE,
-				source_pad, &isp_source_fmt);
-
-	if (!atomisp_subdev_format_conversion(asd, source_pad))
-		padding_w = 0, padding_h = 0;
-
-	if (IS_BYT) {
-		padding_w = 12;
-		padding_h = 12;
-	}
-
-	/* construct resolution supported by isp */
-	if (res_overflow && !asd->continuous_mode->val) {
-		f->fmt.pix.width = rounddown(
-			clamp_t(u32, f->fmt.pix.width - padding_w,
-				ATOM_ISP_MIN_WIDTH,
-				ATOM_ISP_MAX_WIDTH), ATOM_ISP_STEP_WIDTH);
-		f->fmt.pix.height = rounddown(
-			clamp_t(u32, f->fmt.pix.height - padding_h,
-				ATOM_ISP_MIN_HEIGHT,
-				ATOM_ISP_MAX_HEIGHT), ATOM_ISP_STEP_HEIGHT);
-	}
-
-	atomisp_get_dis_envelop(asd, f->fmt.pix.width, f->fmt.pix.height,
-				&dvs_env_w, &dvs_env_h);
-
-	if (asd->continuous_mode->val)
-		asd->capture_pad = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE;
-	else
-		asd->capture_pad = source_pad;
-
-	/*
-	 * set format info to sensor
-	 * In continuous mode, resolution is set only if it is higher than
-	 * existing value. This because preview pipe will be configured after
-	 * capture pipe and usually has lower resolution than capture pipe.
-	 */
-	if (!asd->continuous_mode->val ||
-	    isp_sink_fmt.width < (f->fmt.pix.width + padding_w + dvs_env_w) ||
-	     isp_sink_fmt.height < (f->fmt.pix.height + padding_h +
-				    dvs_env_h)) {
-		ret = atomisp_set_fmt_to_snr(vdev, f, f->fmt.pix.pixelformat,
-					     padding_w, padding_h,
-					     dvs_env_w, dvs_env_h);
-		if (ret)
-			return -EINVAL;
-
-		crop_needs_override = true;
-	}
-
-	isp_sink_crop = *atomisp_subdev_get_rect(&asd->subdev, NULL,
-						 V4L2_SUBDEV_FORMAT_ACTIVE,
-						 ATOMISP_SUBDEV_PAD_SINK,
-						 V4L2_SEL_TGT_CROP);
-
-	/* Try to enable YUV downscaling if ISP input is 10 % (either
-	 * width or height) bigger than the desired result. */
-	if (isp_sink_crop.width * 9 / 10 < f->fmt.pix.width ||
-	    isp_sink_crop.height * 9 / 10 < f->fmt.pix.height ||
-	    (atomisp_subdev_format_conversion(asd, source_pad) &&
-	     ((asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
-	       !asd->continuous_mode->val) ||
-	      asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER))) {
-		/* for continuous mode, preview size might be smaller than
-		 * still capture size. if preview size still needs crop,
-		 * pick the larger one between crop size of preview and
-		 * still capture.
-		 */
-		if (asd->continuous_mode->val
-		    && source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW
-		    && !crop_needs_override) {
-			isp_sink_crop.width =
-				max_t(unsigned int, f->fmt.pix.width,
-				      isp_sink_crop.width);
-			isp_sink_crop.height =
-				max_t(unsigned int, f->fmt.pix.height,
-				      isp_sink_crop.height);
-		} else {
-			isp_sink_crop.width = f->fmt.pix.width;
-			isp_sink_crop.height = f->fmt.pix.height;
-		}
-
-		atomisp_subdev_set_selection(&asd->subdev, &fh,
-					     V4L2_SUBDEV_FORMAT_ACTIVE,
-					     ATOMISP_SUBDEV_PAD_SINK,
-					     V4L2_SEL_TGT_CROP,
-					     V4L2_SEL_FLAG_KEEP_CONFIG,
-					     &isp_sink_crop);
-		atomisp_subdev_set_selection(&asd->subdev, &fh,
-					     V4L2_SUBDEV_FORMAT_ACTIVE,
-					     source_pad, V4L2_SEL_TGT_COMPOSE,
-					     0, &isp_sink_crop);
-	} else {
-		struct v4l2_rect main_compose = {0};
-
-		main_compose.width = isp_sink_crop.width - padding_w;
-		main_compose.height =
-			DIV_ROUND_UP(main_compose.width * f->fmt.pix.height,
-				     f->fmt.pix.width);
-		if (main_compose.height > isp_sink_crop.height - padding_h) {
-			main_compose.height = isp_sink_crop.height - padding_h;
-			main_compose.width =
-				DIV_ROUND_UP(main_compose.height *
-					     f->fmt.pix.width,
-					     f->fmt.pix.height);
-		}
-
-		if (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VIDEO)
-			atomisp_subdev_set_selection(&asd->subdev, &fh,
-					     V4L2_SUBDEV_FORMAT_ACTIVE,
-					     ATOMISP_SUBDEV_PAD_SOURCE_VIDEO,
-					     V4L2_SEL_TGT_COMPOSE, 0,
-					     &main_compose);
-		else
-			atomisp_subdev_set_selection(&asd->subdev, &fh,
-					     V4L2_SUBDEV_FORMAT_ACTIVE,
-					     ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
-					     V4L2_SEL_TGT_COMPOSE, 0,
-					     &main_compose);
-	}
-
-set_fmt_to_isp:
-	ret = atomisp_set_fmt_to_isp(vdev, &output_info, &raw_output_info,
-				     &f->fmt.pix, source_pad);
-	if (ret)
-		return -EINVAL;
-done:
-	pipe->pix.width = f->fmt.pix.width;
-	pipe->pix.height = f->fmt.pix.height;
-	pipe->pix.pixelformat = f->fmt.pix.pixelformat;
-	if (format_bridge->planar) {
-		pipe->pix.bytesperline = output_info.padded_width;
-		pipe->pix.sizeimage = PAGE_ALIGN(f->fmt.pix.height *
-			DIV_ROUND_UP(format_bridge->depth *
-				     output_info.padded_width, 8));
-	} else {
-		pipe->pix.bytesperline =
-			DIV_ROUND_UP(format_bridge->depth *
-				     output_info.padded_width, 8);
-		pipe->pix.sizeimage =
-			PAGE_ALIGN(f->fmt.pix.height * pipe->pix.bytesperline);
-
-	}
-	if (f->fmt.pix.field == V4L2_FIELD_ANY)
-		f->fmt.pix.field = V4L2_FIELD_NONE;
-	pipe->pix.field = f->fmt.pix.field;
-
-	f->fmt.pix = pipe->pix;
-	f->fmt.pix.priv = PAGE_ALIGN(pipe->pix.width *
-				     pipe->pix.height * 2);
-
-	pipe->capq.field = f->fmt.pix.field;
-
-	/*
-	 * If in video 480P case, no GFX throttle
-	 */
-	if (asd->run_mode->val == ATOMISP_SUBDEV_PAD_SOURCE_VIDEO &&
-	    f->fmt.pix.width == 720 && f->fmt.pix.height == 480)
-		isp->need_gfx_throttle = false;
-	else
-		isp->need_gfx_throttle = true;
-
-	return 0;
-}
-
-int atomisp_set_fmt_file(struct video_device *vdev, struct v4l2_format *f)
-{
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct v4l2_mbus_framefmt ffmt = {0};
-	const struct atomisp_format_bridge *format_bridge;
-	struct v4l2_subdev_fh fh;
-	int ret;
-
-	v4l2_fh_init(&fh.vfh, vdev);
-
-	dev_dbg(isp->dev, "setting fmt %ux%u 0x%x for file inject\n",
-		f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.pixelformat);
-	ret = atomisp_try_fmt_file(isp, f);
-	if (ret) {
-		dev_err(isp->dev, "atomisp_try_fmt_file err: %d\n", ret);
-		return ret;
-	}
-
-	format_bridge = atomisp_get_format_bridge(f->fmt.pix.pixelformat);
-	if (format_bridge == NULL) {
-		dev_dbg(isp->dev, "atomisp_get_format_bridge err! fmt:0x%x\n",
-				f->fmt.pix.pixelformat);
-		return -EINVAL;
-	}
-
-	pipe->pix = f->fmt.pix;
-	atomisp_css_input_set_mode(asd, CSS_INPUT_MODE_FIFO);
-	atomisp_css_input_configure_port(asd,
-		__get_mipi_port(isp, ATOMISP_CAMERA_PORT_PRIMARY), 2, 0xffff4);
-
-	ffmt.width = f->fmt.pix.width;
-	ffmt.height = f->fmt.pix.height;
-	ffmt.code = format_bridge->mbus_code;
-
-	atomisp_subdev_set_ffmt(&asd->subdev, &fh, V4L2_SUBDEV_FORMAT_ACTIVE,
-				ATOMISP_SUBDEV_PAD_SINK, &ffmt);
-
-	return 0;
-}
-
-void atomisp_free_all_shading_tables(struct atomisp_device *isp)
-{
-	int i;
-
-	for (i = 0; i < isp->input_cnt; i++) {
-		if (isp->inputs[i].shading_table == NULL)
-			continue;
-		atomisp_css_shading_table_free(isp->inputs[i].shading_table);
-		isp->inputs[i].shading_table = NULL;
-	}
-}
-
-int atomisp_set_shading_table(struct atomisp_sub_device *asd,
-		struct atomisp_shading_table *user_shading_table)
-{
-	struct atomisp_css_shading_table *shading_table;
-	struct atomisp_css_shading_table *free_table;
-	unsigned int len_table;
-	struct atomisp_device *isp = asd->isp;
-	int i;
-	int ret = 0;
-
-	if (!user_shading_table)
-		return -EINVAL;
-
-#ifndef CSS20
-	if (user_shading_table->flags & ATOMISP_SC_FLAG_QUERY) {
-		user_shading_table->enable = asd->params.sc_en;
-		return 0;
-	}
-#endif
-
-	if (!user_shading_table->enable) {
-		atomisp_css_set_shading_table(asd, NULL);
-		asd->params.sc_en = 0;
-		return 0;
-	}
-
-	/* If enabling, all tables must be set */
-	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
-		if (!user_shading_table->data[i])
-			return -EINVAL;
-	}
-
-	/* Shading table size per color */
-	if (user_shading_table->width > SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR ||
-	    user_shading_table->height > SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR)
-		return -EINVAL;
-
-	shading_table = atomisp_css_shading_table_alloc(
-			user_shading_table->width, user_shading_table->height);
-	if (!shading_table)
-		return -ENOMEM;
-
-	len_table = user_shading_table->width * user_shading_table->height *
-		    ATOMISP_SC_TYPE_SIZE;
-	for (i = 0; i < ATOMISP_NUM_SC_COLORS; i++) {
-		ret = copy_from_user(shading_table->data[i],
-				     user_shading_table->data[i], len_table);
-		if (ret) {
-			free_table = shading_table;
-			ret = -EFAULT;
-			goto out;
-		}
-	}
-	shading_table->sensor_width = user_shading_table->sensor_width;
-	shading_table->sensor_height = user_shading_table->sensor_height;
-	shading_table->fraction_bits = user_shading_table->fraction_bits;
-
-	free_table = isp->inputs[asd->input_curr].shading_table;
-	isp->inputs[asd->input_curr].shading_table = shading_table;
-	atomisp_css_set_shading_table(asd, shading_table);
-	asd->params.sc_en = 1;
-
-out:
-	if (free_table != NULL)
-		atomisp_css_shading_table_free(free_table);
-
-	return ret;
-}
-
-/*Turn off ISP dphy */
-int atomisp_ospm_dphy_down(struct atomisp_device *isp)
-{
-	unsigned long flags;
-	u32 pwr_cnt = 0;
-	int timeout = 100;
-	bool idle;
-	u32 reg;
-
-	dev_dbg(isp->dev, "%s\n", __func__);
-
-	/* if ISP timeout, we can force powerdown */
-	if (isp->isp_timeout)
-		goto done;
-
-	if (!atomisp_dev_users(isp))
-		goto done;
-
-	idle = sh_css_hrt_system_is_idle();
-	dev_dbg(isp->dev, "%s system_is_idle:%d\n", __func__, idle);
-	while (!idle && timeout--) {
-		udelay(20);
-		idle = sh_css_hrt_system_is_idle();
-	}
-
-	if (timeout < 0) {
-		dev_err(isp->dev, "Timeout to stop ISP HW\n");
-		/* force power down here */
-		/* return -EINVAL; */
-	}
-
-	spin_lock_irqsave(&isp->lock, flags);
-	isp->sw_contex.power_state = ATOM_ISP_POWER_DOWN;
-	spin_unlock_irqrestore(&isp->lock, flags);
-done:
-	if (IS_ISP24XX(isp)) {
-		/*
-		 * MRFLD IUNIT DPHY is located in an always-power-on island
-		 * MRFLD HW design need all CSI ports are disabled before
-		 * powering down the IUNIT.
-		 */
-		pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &reg);
-		reg |= MRFLD_ALL_CSI_PORTS_OFF_MASK;
-		pci_write_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, reg);
-	} else {
-		/* power down DPHY */
-		pwr_cnt = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT,
-							MFLD_CSI_CONTROL);
-		pwr_cnt |= 0x300;
-		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT,
-						MFLD_CSI_CONTROL, pwr_cnt);
-	}
-
-	return 0;
-}
-
-/*Turn on ISP dphy */
-int atomisp_ospm_dphy_up(struct atomisp_device *isp)
-{
-	u32 pwr_cnt = 0;
-	unsigned long flags;
-	dev_dbg(isp->dev, "%s\n", __func__);
-
-	/* MRFLD IUNIT DPHY is located in an always-power-on island */
-	if (!IS_ISP24XX(isp)) {
-		/* power on DPHY */
-		pwr_cnt = intel_mid_msgbus_read32(MFLD_IUNITPHY_PORT,
-							MFLD_CSI_CONTROL);
-		pwr_cnt &= ~0x300;
-		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT,
-						MFLD_CSI_CONTROL, pwr_cnt);
-	}
-	spin_lock_irqsave(&isp->lock, flags);
-	isp->sw_contex.power_state = ATOM_ISP_POWER_UP;
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	return 0;
-}
-
-
-int atomisp_exif_makernote(struct atomisp_sub_device *asd,
-			   struct atomisp_makernote_info *config)
-{
-	struct v4l2_control ctrl;
-	struct atomisp_device *isp = asd->isp;
-
-	ctrl.id = V4L2_CID_FOCAL_ABSOLUTE;
-	if (v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				 core, g_ctrl, &ctrl))
-		dev_warn(isp->dev, "failed to g_ctrl for focal length\n");
-	else
-		config->focal_length = ctrl.value;
-
-	ctrl.id = V4L2_CID_FNUMBER_ABSOLUTE;
-	if (v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				core, g_ctrl, &ctrl))
-		dev_warn(isp->dev, "failed to g_ctrl for f-number\n");
-	else
-		config->f_number_curr = ctrl.value;
-
-	ctrl.id = V4L2_CID_FNUMBER_RANGE;
-	if (v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				core, g_ctrl, &ctrl))
-		dev_warn(isp->dev, "failed to g_ctrl for f number range\n");
-	else
-		config->f_number_range = ctrl.value;
-
-	return 0;
-}
-
-int atomisp_offline_capture_configure(struct atomisp_sub_device *asd,
-			      struct atomisp_cont_capture_conf *cvf_config)
-{
-	asd->params.offline_parm = *cvf_config;
-
-	if (asd->params.offline_parm.num_captures) {
-		if (asd->streaming == ATOMISP_DEVICE_STREAMING_DISABLED)
-			/* TODO: this can be removed once user-space
-			 *       has been updated to use control API */
-			asd->continuous_raw_buffer_size->val =
-				min_t(int, ATOMISP_CONT_RAW_FRAMES,
-				      asd->params.offline_parm.
-				      num_captures + 3);
-
-		asd->continuous_mode->val = true;
-	} else {
-		asd->continuous_mode->val = false;
-		__enable_continuous_mode(asd, false);
-	}
-
-	return 0;
-}
-
-int atomisp_flash_enable(struct atomisp_sub_device *asd, int num_frames)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	if (num_frames < 0) {
-		dev_dbg(isp->dev, "%s ERROR: num_frames: %d\n", __func__,
-				num_frames);
-		return -EINVAL;
-	}
-	/* a requested flash is still in progress. */
-	if (num_frames && asd->params.flash_state != ATOMISP_FLASH_IDLE) {
-		dev_dbg(isp->dev, "%s flash busy: %d frames left: %d\n",
-				__func__, asd->params.flash_state,
-				asd->params.num_flash_frames);
-		return -EBUSY;
-	}
-
-	asd->params.num_flash_frames = num_frames;
-	asd->params.flash_state = ATOMISP_FLASH_REQUESTED;
-	return 0;
-}
-
-int atomisp_source_pad_to_stream_id(struct atomisp_sub_device *asd,
-					   uint16_t source_pad)
-{
-	int stream_id;
-	struct atomisp_device *isp = asd->isp;
-
-	if (isp->inputs[asd->input_curr].camera_caps->
-			sensor[asd->sensor_curr].stream_num == 1)
-		return ATOMISP_INPUT_STREAM_GENERAL;
-
-	if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
-			source_pad == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE)
-		stream_id = ATOMISP_INPUT_STREAM_VIDEO;
-	else {
-		switch (source_pad) {
-		case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
-			stream_id = ATOMISP_INPUT_STREAM_CAPTURE;
-			break;
-		case ATOMISP_SUBDEV_PAD_SOURCE_VF:
-			stream_id = ATOMISP_INPUT_STREAM_POSTVIEW;
-			break;
-		case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
-			stream_id = ATOMISP_INPUT_STREAM_PREVIEW;
-			break;
-		default:
-			stream_id = ATOMISP_INPUT_STREAM_GENERAL;
-		}
-	}
-
-	return stream_id;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.h
deleted file mode 100644
index e48e0b8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_cmd.h
+++ /dev/null
@@ -1,333 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__ATOMISP_CMD_H__
-#define	__ATOMISP_CMD_H__
-
-#include <linux/atomisp.h>
-#include <linux/interrupt.h>
-#include <linux/videodev2.h>
-
-#include <media/v4l2-subdev.h>
-
-#include "atomisp_internal.h"
-
-#ifdef CSS20
-#include "ia_css_types.h"
-#include "ia_css.h"
-#else /* CSS20 */
-#include "sh_css_types.h"
-#endif /* CSS20 */
-
-struct atomisp_device;
-struct atomisp_css_frame;
-
-#define MSI_ENABLE_BIT		16
-#define INTR_DISABLE_BIT	10
-#define BUS_MASTER_ENABLE	2
-#define MEMORY_SPACE_ENABLE	1
-#define INTR_IER		24
-#define INTR_IIR		16
-
-/*
- * Helper function
- */
-void dump_sp_dmem(struct atomisp_device *isp, unsigned int addr,
-		  unsigned int size);
-struct camera_mipi_info *atomisp_to_sensor_mipi_info(struct v4l2_subdev *sd);
-struct atomisp_video_pipe *atomisp_to_video_pipe(struct video_device *dev);
-int atomisp_reset(struct atomisp_device *isp);
-void atomisp_flush_bufs_and_wakeup(struct atomisp_sub_device *asd);
-void atomisp_clear_css_buffer_counters(struct atomisp_sub_device *asd);
-bool atomisp_buffers_queued(struct atomisp_sub_device *asd);
-
-/* TODO:should be here instead of atomisp_helper.h
-extern void __iomem *atomisp_io_base;
-
-static inline void __iomem *atomisp_get_io_virt_addr(unsigned int address)
-{
-	void __iomem *ret = atomisp_io_base + (address & 0x003FFFFF);
-	return ret;
-}
-*/
-void *atomisp_kernel_malloc(size_t bytes);
-void *atomisp_kernel_zalloc(size_t bytes, bool zero_mem);
-void atomisp_kernel_free(void *ptr);
-
-/*
- * Interrupt functions
- */
-void atomisp_msi_irq_init(struct atomisp_device *isp, struct pci_dev *dev);
-void atomisp_msi_irq_uninit(struct atomisp_device *isp, struct pci_dev *dev);
-void atomisp_wdt_work(struct work_struct *work);
-void atomisp_wdt(unsigned long isp_addr);
-void atomisp_setup_flash(struct atomisp_sub_device *asd);
-irqreturn_t atomisp_isr(int irq, void *dev);
-irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr);
-const struct atomisp_format_bridge *get_atomisp_format_bridge_from_mbus(
-	enum v4l2_mbus_pixelcode mbus_code);
-bool atomisp_is_mbuscode_raw(uint32_t code);
-int atomisp_get_frame_pgnr(struct atomisp_device *isp,
-			   const struct atomisp_css_frame *frame, u32 *p_pgnr);
-void atomisp_delayed_init_work(struct work_struct *work);
-
-/*
- * CSI-2 receiver configuration
- */
-void atomisp_set_term_en_count(struct atomisp_device *isp);
-
-/*
- * Get internal fmt according to V4L2 fmt
- */
-
-bool atomisp_is_viewfinder_support(struct atomisp_device *isp);
-
-/*
- * ISP features control function
- */
-
-/*
- * Function to enable/disable lens geometry distortion correction (GDC) and
- * chromatic aberration correction (CAC)
- */
-int atomisp_gdc_cac(struct atomisp_sub_device *asd, int flag,
-		    __s32 *value);
-
-/*
- * Function to enable/disable low light mode (including ANR)
- */
-int atomisp_low_light(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value);
-
-/*
- * Function to enable/disable extra noise reduction (XNR) in low light
- * condition
- */
-int atomisp_xnr(struct atomisp_sub_device *asd, int flag, int *arg);
-
-/*
- * Function to configure noise reduction
- */
-int atomisp_nr(struct atomisp_sub_device *asd, int flag,
-	       struct atomisp_nr_config *config);
-
-/*
- * Function to configure temporal noise reduction (TNR)
- */
-int atomisp_tnr(struct atomisp_sub_device *asd, int flag,
-		struct atomisp_tnr_config *config);
-
-/*
- * Function to configure black level compensation
- */
-int atomisp_black_level(struct atomisp_sub_device *asd, int flag,
-			struct atomisp_ob_config *config);
-
-/*
- * Function to configure edge enhancement
- */
-int atomisp_ee(struct atomisp_sub_device *asd, int flag,
-	       struct atomisp_ee_config *config);
-
-/*
- * Function to update Gamma table for gamma, brightness and contrast config
- */
-int atomisp_gamma(struct atomisp_sub_device *asd, int flag,
-		  struct atomisp_gamma_table *config);
-/*
- * Function to update Ctc table for Chroma Enhancement
- */
-int atomisp_ctc(struct atomisp_sub_device *asd, int flag,
-		struct atomisp_ctc_table *config);
-
-/*
- * Function to update gamma correction parameters
- */
-int atomisp_gamma_correction(struct atomisp_sub_device *asd, int flag,
-	struct atomisp_gc_config *config);
-
-/*
- * Function to update Gdc table for gdc
- */
-int atomisp_gdc_cac_table(struct atomisp_sub_device *asd, int flag,
-			  struct atomisp_morph_table *config);
-
-/*
- * Function to update table for macc
- */
-int atomisp_macc_table(struct atomisp_sub_device *asd, int flag,
-		       struct atomisp_macc_config *config);
-/*
- * Function to get DIS statistics.
- */
-int atomisp_get_dis_stat(struct atomisp_sub_device *asd,
-			 struct atomisp_dis_statistics *stats);
-
-/*
- * Function to set the DIS coefficients.
- */
-int atomisp_set_dis_coefs(struct atomisp_sub_device *asd,
-			  struct atomisp_dis_coefficients *coefs);
-
-/*
- * Function to set the DIS motion vector.
- */
-int atomisp_set_dis_vector(struct atomisp_sub_device *asd,
-			   struct atomisp_dis_vector *vector);
-
-/*
- * Function to set/get 3A stat from isp
- */
-int atomisp_3a_stat(struct atomisp_sub_device *asd, int flag,
-		    struct atomisp_3a_statistics *config);
-
-int atomisp_set_parameters(struct atomisp_sub_device *asd,
-		struct atomisp_parameters *arg);
-
-/*
- * Function to set/get isp parameters to isp
- */
-int atomisp_param(struct atomisp_sub_device *asd, int flag,
-		  struct atomisp_parm *config);
-
-/*
- * Function to configure color effect of the image
- */
-int atomisp_color_effect(struct atomisp_sub_device *asd, int flag,
-			 __s32 *effect);
-
-/*
- * Function to configure bad pixel correction
- */
-int atomisp_bad_pixel(struct atomisp_sub_device *asd, int flag,
-		      __s32 *value);
-
-/*
- * Function to configure bad pixel correction params
- */
-int atomisp_bad_pixel_param(struct atomisp_sub_device *asd, int flag,
-			    struct atomisp_dp_config *config);
-
-/*
- * Function to enable/disable video image stablization
- */
-int atomisp_video_stable(struct atomisp_sub_device *asd, int flag,
-			 __s32 *value);
-
-/*
- * Function to configure fixed pattern noise
- */
-int atomisp_fixed_pattern(struct atomisp_sub_device *asd, int flag,
-			  __s32 *value);
-
-/*
- * Function to configure fixed pattern noise table
- */
-int atomisp_fixed_pattern_table(struct atomisp_sub_device *asd,
-				struct v4l2_framebuffer *config);
-
-/*
- * Function to configure false color correction
- */
-int atomisp_false_color(struct atomisp_sub_device *asd, int flag,
-			__s32 *value);
-
-/*
- * Function to configure false color correction params
- */
-int atomisp_false_color_param(struct atomisp_sub_device *asd, int flag,
-			      struct atomisp_de_config *config);
-
-/*
- * Function to configure white balance params
- */
-int atomisp_white_balance_param(struct atomisp_sub_device *asd, int flag,
-				struct atomisp_wb_config *config);
-
-int atomisp_3a_config_param(struct atomisp_sub_device *asd, int flag,
-			    struct atomisp_3a_config *config);
-
-/*
- * Function to enable/disable lens shading correction
- */
-int atomisp_shading_correction(struct atomisp_sub_device *asd, int flag,
-				       __s32 *value);
-
-/*
- * Function to setup digital zoom
- */
-int atomisp_digital_zoom(struct atomisp_sub_device *asd, int flag,
-			 __s32 *value);
-
-#ifdef CSS20
-int atomisp_set_dvs_6axis_config(struct atomisp_sub_device *asd,
-					  struct atomisp_dvs_6axis_config
-					  *user_6axis_config);
-#endif
-
-int atomisp_compare_grid(struct atomisp_sub_device *asd,
-				struct atomisp_grid_info *atomgrid);
-
-int atomisp_get_sensor_mode_data(struct atomisp_sub_device *asd,
-				 struct atomisp_sensor_mode_data *config);
-
-int atomisp_get_fmt(struct video_device *vdev, struct v4l2_format *f);
-
-
-/* This function looks up the closest available resolution. */
-int atomisp_try_fmt(struct video_device *vdev, struct v4l2_format *f,
-						bool *res_overflow);
-
-int atomisp_set_fmt(struct video_device *vdev, struct v4l2_format *f);
-int atomisp_set_fmt_file(struct video_device *vdev, struct v4l2_format *f);
-
-void atomisp_free_all_shading_tables(struct atomisp_device *isp);
-int atomisp_set_shading_table(struct atomisp_sub_device *asd,
-			      struct atomisp_shading_table *shading_table);
-
-int atomisp_offline_capture_configure(struct atomisp_sub_device *asd,
-				struct atomisp_cont_capture_conf *cvf_config);
-
-int atomisp_ospm_dphy_down(struct atomisp_device *isp);
-int atomisp_ospm_dphy_up(struct atomisp_device *isp);
-int atomisp_exif_makernote(struct atomisp_sub_device *asd,
-			   struct atomisp_makernote_info *config);
-
-void atomisp_free_internal_buffers(struct atomisp_sub_device *asd);
-void atomisp_free_3a_dis_buffers(struct atomisp_sub_device *asd);
-
-int  atomisp_flash_enable(struct atomisp_sub_device *asd,
-			  int num_frames);
-
-int atomisp_freq_scaling(struct atomisp_device *vdev,
-			 enum atomisp_dfs_mode mode);
-
-void atomisp_buf_done(struct atomisp_sub_device *asd, int error,
-		      enum atomisp_css_buffer_type buf_type,
-		      enum atomisp_css_pipe_id css_pipe_id,
-		      bool q_buffers, enum atomisp_input_stream_id stream_id);
-
-void atomisp_css_flush(struct atomisp_device *isp);
-int atomisp_source_pad_to_stream_id(struct atomisp_sub_device *asd,
-					   uint16_t source_pad);
-#endif /* __ATOMISP_CMD_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_common.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_common.h
deleted file mode 100644
index 9c696f9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_common.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__ATOMISP_COMMON_H__
-#define	__ATOMISP_COMMON_H__
-
-#include <linux/atomisp.h>
-
-#include <linux/v4l2-mediabus.h>
-
-#include <media/videobuf-core.h>
-
-#include "atomisp_compat.h"
-
-#ifdef CSS20
-#include "ia_css.h"
-#else /* CSS20 */
-#include <sh_css.h>
-#endif /* CSS20 */
-
-extern int dbg_level;
-extern int mipicsi_flag;
-extern int pad_w;
-extern int pad_h;
-
-#define CSS_DTRACE_VERBOSITY_LEVEL	7	/* Controls trace verbosity */
-#define CSS_DTRACE_VERBOSITY_TIMEOUT	9	/* Verbosity on ISP timeout */
-#define MFLD_MAX_ZOOM_FACTOR	64
-#define MRFLD_MAX_ZOOM_FACTOR	1024
-
-#define IS_ISP24XX(isp)							\
-	(((isp)->media_dev.hw_revision & ATOMISP_HW_REVISION_MASK)	\
-	 >= (ATOMISP_HW_REVISION_ISP2400 << ATOMISP_HW_REVISION_SHIFT))
-#define IS_ISP2401(isp)							\
-	(((isp)->media_dev.hw_revision & ATOMISP_HW_REVISION_MASK)	\
-	 >= (ATOMISP_HW_REVISION_ISP2401_LEGACY << ATOMISP_HW_REVISION_SHIFT))
-
-struct atomisp_format_bridge {
-	unsigned int pixelformat;
-	unsigned int depth;
-	enum v4l2_mbus_pixelcode mbus_code;
-	enum atomisp_css_frame_format sh_fmt;
-	unsigned char description[32];	/* the same as struct v4l2_fmtdesc */
-	bool planar;
-};
-
-struct atomisp_fmt {
-	u32 pixelformat;
-	u32 depth;
-	u32 bytesperline;
-	u32 framesize;
-	u32 imagesize;
-	u32 width;
-	u32 height;
-	u32 bayer_order;
-};
-
-struct atomisp_buffer {
-	struct videobuf_buffer	vb;
-};
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat.h
deleted file mode 100644
index 04a756c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat.h
+++ /dev/null
@@ -1,556 +0,0 @@
-/*
- * Support for Clovertrail PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __ATOMISP_COMPAT_H__
-#define __ATOMISP_COMPAT_H__
-
-#ifdef CSS20
-#include "atomisp_compat_css20.h"
-#else /* CSS20 */
-#include "atomisp_compat_css15.h"
-#endif /* CSS20 */
-
-#include <linux/atomisp.h>
-#include <media/videobuf-vmalloc.h>
-
-#define CSS_RX_IRQ_INFO_BUFFER_OVERRUN \
-	CSS_ID(CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
-#define CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE \
-	CSS_ID(CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE)
-#define CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE \
-	CSS_ID(CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE)
-#define CSS_RX_IRQ_INFO_ECC_CORRECTED \
-	CSS_ID(CSS_RX_IRQ_INFO_ECC_CORRECTED)
-#define CSS_RX_IRQ_INFO_ERR_SOT \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_SOT)
-#define CSS_RX_IRQ_INFO_ERR_SOT_SYNC \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
-#define CSS_RX_IRQ_INFO_ERR_CONTROL \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_CONTROL)
-#define CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
-#define CSS_RX_IRQ_INFO_ERR_CRC \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_CRC)
-#define CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
-#define CSS_RX_IRQ_INFO_ERR_FRAME_SYNC \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
-#define CSS_RX_IRQ_INFO_ERR_FRAME_DATA \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
-#define CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
-#define CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
-#define CSS_RX_IRQ_INFO_ERR_LINE_SYNC \
-	CSS_ID(CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
-#define CSS_RX_IRQ_INFO_INIT_TIMEOUT \
-	CSS_ID(CSS_RX_IRQ_INFO_INIT_TIMEOUT)
-
-#define CSS_IRQ_INFO_CSS_RECEIVER_SOF	CSS_ID(CSS_IRQ_INFO_CSS_RECEIVER_SOF)
-#define CSS_IRQ_INFO_CSS_RECEIVER_EOF	CSS_ID(CSS_IRQ_INFO_CSS_RECEIVER_EOF)
-#define CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW \
-	CSS_ID(CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW)
-#define CSS_EVENT_OUTPUT_FRAME_DONE	CSS_EVENT(OUTPUT_FRAME_DONE)
-#define CSS_EVENT_VF_OUTPUT_FRAME_DONE	CSS_EVENT(VF_OUTPUT_FRAME_DONE)
-#define CSS_EVENT_3A_STATISTICS_DONE	CSS_EVENT(3A_STATISTICS_DONE)
-#define CSS_EVENT_DIS_STATISTICS_DONE	CSS_EVENT(DIS_STATISTICS_DONE)
-#define CSS_EVENT_PIPELINE_DONE		CSS_EVENT(PIPELINE_DONE)
-
-#define CSS_BUFFER_TYPE_3A_STATISTICS	CSS_ID(CSS_BUFFER_TYPE_3A_STATISTICS)
-#define CSS_BUFFER_TYPE_DIS_STATISTICS	CSS_ID(CSS_BUFFER_TYPE_DIS_STATISTICS)
-#define CSS_BUFFER_TYPE_INPUT_FRAME	CSS_ID(CSS_BUFFER_TYPE_INPUT_FRAME)
-#define CSS_BUFFER_TYPE_OUTPUT_FRAME	CSS_ID(CSS_BUFFER_TYPE_OUTPUT_FRAME)
-#define CSS_BUFFER_TYPE_VF_OUTPUT_FRAME	CSS_ID(CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)
-#define CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME \
-	CSS_ID(CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME)
-
-#define CSS_FORMAT_RAW_8	CSS_FORMAT(RAW_8)
-#define CSS_FORMAT_RAW_10	CSS_FORMAT(RAW_10)
-#define CSS_FORMAT_RAW_12	CSS_FORMAT(RAW_12)
-#define CSS_FORMAT_RAW_16	CSS_FORMAT(RAW_16)
-
-#define CSS_CAPTURE_MODE_RAW		CSS_ID(CSS_CAPTURE_MODE_RAW)
-#define CSS_CAPTURE_MODE_BAYER		CSS_ID(CSS_CAPTURE_MODE_BAYER)
-#define CSS_CAPTURE_MODE_PRIMARY	CSS_ID(CSS_CAPTURE_MODE_PRIMARY)
-#define CSS_CAPTURE_MODE_ADVANCED	CSS_ID(CSS_CAPTURE_MODE_ADVANCED)
-#define CSS_CAPTURE_MODE_LOW_LIGHT	CSS_ID(CSS_CAPTURE_MODE_LOW_LIGHT)
-
-#define CSS_MORPH_TABLE_NUM_PLANES	CSS_ID(CSS_MORPH_TABLE_NUM_PLANES)
-
-#define CSS_FRAME_FORMAT_NV11		CSS_ID(CSS_FRAME_FORMAT_NV11)
-#define CSS_FRAME_FORMAT_NV12		CSS_ID(CSS_FRAME_FORMAT_NV12)
-#define CSS_FRAME_FORMAT_NV16		CSS_ID(CSS_FRAME_FORMAT_NV16)
-#define CSS_FRAME_FORMAT_NV21		CSS_ID(CSS_FRAME_FORMAT_NV21)
-#define CSS_FRAME_FORMAT_NV61		CSS_ID(CSS_FRAME_FORMAT_NV61)
-#define CSS_FRAME_FORMAT_YV12		CSS_ID(CSS_FRAME_FORMAT_YV12)
-#define CSS_FRAME_FORMAT_YV16		CSS_ID(CSS_FRAME_FORMAT_YV16)
-#define CSS_FRAME_FORMAT_YUV420		CSS_ID(CSS_FRAME_FORMAT_YUV420)
-#define CSS_FRAME_FORMAT_YUV420_16	CSS_ID(CSS_FRAME_FORMAT_YUV420_16)
-#define CSS_FRAME_FORMAT_YUV422		CSS_ID(CSS_FRAME_FORMAT_YUV422)
-#define CSS_FRAME_FORMAT_YUV422_16	CSS_ID(CSS_FRAME_FORMAT_YUV422_16)
-#define CSS_FRAME_FORMAT_UYVY		CSS_ID(CSS_FRAME_FORMAT_UYVY)
-#define CSS_FRAME_FORMAT_YUYV		CSS_ID(CSS_FRAME_FORMAT_YUYV)
-#define CSS_FRAME_FORMAT_YUV444		CSS_ID(CSS_FRAME_FORMAT_YUV444)
-#define CSS_FRAME_FORMAT_YUV_LINE	CSS_ID(CSS_FRAME_FORMAT_YUV_LINE)
-#define CSS_FRAME_FORMAT_RAW		CSS_ID(CSS_FRAME_FORMAT_RAW)
-#define CSS_FRAME_FORMAT_RGB565		CSS_ID(CSS_FRAME_FORMAT_RGB565)
-#define CSS_FRAME_FORMAT_PLANAR_RGB888	CSS_ID(CSS_FRAME_FORMAT_PLANAR_RGB888)
-#define CSS_FRAME_FORMAT_RGBA888	CSS_ID(CSS_FRAME_FORMAT_RGBA888)
-#define CSS_FRAME_FORMAT_QPLANE6	CSS_ID(CSS_FRAME_FORMAT_QPLANE6)
-#define CSS_FRAME_FORMAT_BINARY_8	CSS_ID(CSS_FRAME_FORMAT_BINARY_8)
-
-struct atomisp_device;
-struct atomisp_sub_device;
-struct video_device;
-enum atomisp_input_stream_id;
-
-void atomisp_css_debug_dump_sp_sw_debug_info(void);
-void atomisp_css_debug_dump_debug_info(const char *context);
-void atomisp_css_debug_set_dtrace_level(const unsigned int trace_level);
-
-void atomisp_store_uint32(hrt_address addr, uint32_t data);
-void atomisp_load_uint32(hrt_address addr, uint32_t *data);
-
-int atomisp_css_init(struct atomisp_device *isp);
-
-void atomisp_css_uninit(struct atomisp_device *isp);
-
-void atomisp_css_suspend(void);
-
-int atomisp_css_resume(struct atomisp_device *isp);
-
-void atomisp_css_init_struct(struct atomisp_sub_device *asd);
-
-int atomisp_css_irq_translate(struct atomisp_device *isp,
-			      unsigned int *infos);
-
-void atomisp_css_rx_get_irq_info(unsigned int *infos);
-
-void atomisp_css_rx_clear_irq_info(unsigned int infos);
-
-int atomisp_css_irq_enable(struct atomisp_device *isp,
-			   enum atomisp_css_irq_info info, bool enable);
-
-int atomisp_q_video_buffer_to_css(struct atomisp_sub_device *asd,
-			struct videobuf_vmalloc_memory *vm_mem,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_buffer_type css_buf_type,
-			enum atomisp_css_pipe_id css_pipe_id);
-
-int atomisp_q_s3a_buffer_to_css(struct atomisp_sub_device *asd,
-			struct atomisp_s3a_buf *s3a_buf,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_pipe_id css_pipe_id);
-
-int atomisp_q_dis_buffer_to_css(struct atomisp_sub_device *asd,
-			struct atomisp_dis_buf *dis_buf,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_pipe_id css_pipe_id);
-
-void atomisp_css_mmu_invalidate_cache(void);
-
-void atomisp_css_mmu_invalidate_tlb(void);
-
-void atomisp_css_mmu_set_page_table_base_index(unsigned long base_index);
-
-int atomisp_css_start(struct atomisp_sub_device *asd,
-		      enum atomisp_css_pipe_id pipe_id, bool in_reset);
-
-void atomisp_css_update_isp_params(struct atomisp_sub_device *asd);
-
-int atomisp_css_queue_buffer(struct atomisp_sub_device *asd,
-			     enum atomisp_input_stream_id stream_id,
-			     enum atomisp_css_pipe_id pipe_id,
-			     enum atomisp_css_buffer_type buf_type,
-			     struct atomisp_css_buffer *isp_css_buffer);
-
-int atomisp_css_dequeue_buffer(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_pipe_id pipe_id,
-				enum atomisp_css_buffer_type buf_type,
-				struct atomisp_css_buffer *isp_css_buffer);
-
-int atomisp_css_allocate_3a_dis_bufs(struct atomisp_sub_device *asd,
-				struct atomisp_s3a_buf *s3a_buf,
-				struct atomisp_dis_buf *dis_buf);
-
-void atomisp_css_free_3a_buffers(struct atomisp_s3a_buf *s3a_buf);
-
-void atomisp_css_free_dis_buffers(struct atomisp_dis_buf *dis_buf);
-
-void atomisp_css_free_3a_dis_buffers(struct atomisp_sub_device *asd);
-
-int atomisp_css_get_grid_info(struct atomisp_sub_device *asd,
-				enum atomisp_css_pipe_id pipe_id,
-				int source_pad);
-
-int atomisp_alloc_3a_output_buf(struct atomisp_sub_device *asd);
-
-int atomisp_alloc_dis_coef_buf(struct atomisp_sub_device *asd);
-
-int atomisp_css_get_3a_statistics(struct atomisp_sub_device *asd,
-				  struct atomisp_css_buffer *isp_css_buffer);
-
-void atomisp_css_get_dis_statistics(struct atomisp_sub_device *asd,
-				    struct atomisp_css_buffer *isp_css_buffer);
-
-int atomisp_css_dequeue_event(struct atomisp_css_event *current_event);
-
-void atomisp_css_temp_pipe_to_pipe_id(struct atomisp_css_event *current_event);
-
-int atomisp_css_input_set_resolution(struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					struct v4l2_mbus_framefmt *ffmt);
-
-void atomisp_css_input_set_binning_factor(struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					unsigned int bin_factor);
-
-void atomisp_css_input_set_bayer_order(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_bayer_order bayer_order);
-
-void atomisp_css_input_set_format(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_stream_format format);
-
-int atomisp_css_input_set_effective_resolution(
-					struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					unsigned int width,
-					unsigned int height);
-
-void atomisp_css_video_set_dis_envelope(struct atomisp_sub_device *asd,
-					unsigned int dvs_w, unsigned int dvs_h);
-
-void atomisp_css_input_set_two_pixels_per_clock(
-					struct atomisp_sub_device *asd,
-					bool two_ppc);
-
-void atomisp_css_enable_raw_binning(struct atomisp_sub_device *asd,
-					bool enable);
-
-void atomisp_css_enable_dz(struct atomisp_sub_device *asd, bool enable);
-
-void atomisp_css_capture_set_mode(struct atomisp_sub_device *asd,
-				enum atomisp_css_capture_mode mode);
-
-void atomisp_css_input_set_mode(struct atomisp_sub_device *asd,
-				enum atomisp_css_input_mode mode);
-
-void atomisp_css_capture_enable_online(struct atomisp_sub_device *asd,
-							bool enable);
-
-void atomisp_css_preview_enable_online(struct atomisp_sub_device *asd,
-							bool enable);
-
-void atomisp_css_enable_continuous(struct atomisp_sub_device *asd,
-							bool enable);
-
-void atomisp_css_enable_cont_capt(bool enable, bool stop_copy_preview);
-
-int atomisp_css_input_configure_port(struct atomisp_sub_device *asd,
-					mipi_port_ID_t port,
-					unsigned int num_lanes,
-					unsigned int timeout);
-
-int atomisp_css_frame_allocate(struct atomisp_css_frame **frame,
-				unsigned int width, unsigned int height,
-				enum atomisp_css_frame_format format,
-				unsigned int padded_width,
-				unsigned int raw_bit_depth);
-
-int atomisp_css_frame_allocate_from_info(struct atomisp_css_frame **frame,
-				const struct atomisp_css_frame_info *info);
-
-void atomisp_css_frame_free(struct atomisp_css_frame *frame);
-
-int atomisp_css_frame_map(struct atomisp_css_frame **frame,
-				const struct atomisp_css_frame_info *info,
-				const void *data, uint16_t attribute,
-				void *context);
-
-int atomisp_css_set_black_frame(struct atomisp_sub_device *asd,
-			const struct atomisp_css_frame *raw_black_frame);
-
-int atomisp_css_allocate_continuous_frames(bool init_time,
-			struct atomisp_sub_device *asd);
-
-void atomisp_css_update_continuous_frames(struct atomisp_sub_device *asd);
-
-void atomisp_destroy_pipes_stream_force(struct atomisp_sub_device *asd);
-
-int atomisp_css_stop(struct atomisp_sub_device *asd,
-			enum atomisp_css_pipe_id pipe_id, bool in_reset);
-
-int atomisp_css_continuous_set_num_raw_frames(
-					struct atomisp_sub_device *asd,
-					int num_frames);
-
-void atomisp_css_disable_vf_pp(struct atomisp_sub_device *asd,
-			       bool disable);
-
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-int atomisp_css_copy_configure_output(struct atomisp_sub_device *asd,
-				unsigned int stream_index,
-				unsigned int width, unsigned int height,
-				enum atomisp_css_frame_format format);
-#endif
-
-int atomisp_css_preview_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format);
-
-int atomisp_css_capture_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format);
-
-int atomisp_css_video_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format);
-
-int atomisp_get_css_frame_info(struct atomisp_sub_device *asd,
-				uint16_t source_pad,
-				struct atomisp_css_frame_info *frame_info);
-
-int atomisp_css_video_configure_viewfinder(struct atomisp_sub_device *asd,
-					unsigned int width, unsigned int height,
-					unsigned int min_width,
-					enum atomisp_css_frame_format format);
-
-int atomisp_css_capture_configure_viewfinder(
-					struct atomisp_sub_device *asd,
-					unsigned int width, unsigned int height,
-					unsigned int min_width,
-					enum atomisp_css_frame_format format);
-
-int atomisp_css_video_get_viewfinder_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info);
-
-int atomisp_css_capture_get_viewfinder_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info);
-
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-int atomisp_css_copy_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					unsigned int stream_index,
-					struct atomisp_css_frame_info *info);
-#endif
-
-int atomisp_css_capture_get_output_raw_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info);
-
-int atomisp_css_preview_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info);
-
-int atomisp_css_capture_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info);
-
-int atomisp_css_video_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info);
-
-int atomisp_css_preview_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height);
-
-int atomisp_css_capture_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height);
-
-int atomisp_css_video_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height);
-
-int atomisp_css_offline_capture_configure(struct atomisp_sub_device *asd,
-			int num_captures, unsigned int skip, int offset);
-
-int atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd,
-				   bool enable);
-
-void atomisp_css_send_input_frame(struct atomisp_sub_device *asd,
-				  unsigned short *data, unsigned int width,
-				  unsigned int height);
-
-bool atomisp_css_isp_has_started(void);
-
-void atomisp_css_request_flash(struct atomisp_sub_device *asd);
-
-void atomisp_css_set_wb_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_wb_config *wb_config);
-
-void atomisp_css_set_ob_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ob_config *ob_config);
-
-void atomisp_css_set_dp_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_dp_config *dp_config);
-
-void atomisp_css_set_de_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_de_config *de_config);
-
-void atomisp_css_set_default_de_config(struct atomisp_sub_device *asd);
-
-void atomisp_css_set_ce_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ce_config *ce_config);
-
-void atomisp_css_set_nr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_nr_config *nr_config);
-
-void atomisp_css_set_ee_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ee_config *ee_config);
-
-void atomisp_css_set_tnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_tnr_config *tnr_config);
-
-void atomisp_css_set_cc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cc_config *cc_config);
-
-void atomisp_css_set_macc_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_macc_table *macc_table);
-
-void atomisp_css_set_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_gamma_table *gamma_table);
-
-void atomisp_css_set_ctc_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_ctc_table *ctc_table);
-
-void atomisp_css_set_gc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_gc_config *gc_config);
-
-void atomisp_css_set_3a_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_3a_config *s3a_config);
-
-void atomisp_css_video_set_dis_vector(struct atomisp_sub_device *asd,
-				struct atomisp_dis_vector *vector);
-
-int atomisp_css_set_dis_coefs(struct atomisp_sub_device *asd,
-			  struct atomisp_dis_coefficients *coefs);
-
-void atomisp_css_set_zoom_factor(struct atomisp_sub_device *asd,
-					unsigned int zoom);
-
-int atomisp_css_get_wb_config(struct atomisp_sub_device *asd,
-			struct atomisp_wb_config *config);
-
-int atomisp_css_get_ob_config(struct atomisp_sub_device *asd,
-			struct atomisp_ob_config *config);
-
-int atomisp_css_get_dp_config(struct atomisp_sub_device *asd,
-			struct atomisp_dp_config *config);
-
-int atomisp_css_get_de_config(struct atomisp_sub_device *asd,
-			struct atomisp_de_config *config);
-
-int atomisp_css_get_nr_config(struct atomisp_sub_device *asd,
-			struct atomisp_nr_config *config);
-
-int atomisp_css_get_ee_config(struct atomisp_sub_device *asd,
-			struct atomisp_ee_config *config);
-
-int atomisp_css_get_tnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_tnr_config *config);
-
-int atomisp_css_get_ctc_table(struct atomisp_sub_device *asd,
-			struct atomisp_ctc_table *config);
-
-int atomisp_css_get_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_gamma_table *config);
-
-int atomisp_css_get_gc_config(struct atomisp_sub_device *asd,
-			struct atomisp_gc_config *config);
-
-int atomisp_css_get_3a_config(struct atomisp_sub_device *asd,
-			struct atomisp_3a_config *config);
-
-int atomisp_css_get_zoom_factor(struct atomisp_sub_device *asd,
-					unsigned int *zoom);
-
-struct atomisp_css_shading_table *atomisp_css_shading_table_alloc(
-				unsigned int width, unsigned int height);
-
-void atomisp_css_set_shading_table(struct atomisp_sub_device *asd,
-				struct atomisp_css_shading_table *table);
-
-void atomisp_css_shading_table_free(struct atomisp_css_shading_table *table);
-
-struct atomisp_css_morph_table *atomisp_css_morph_table_allocate(
-				unsigned int width, unsigned int height);
-
-void atomisp_css_set_morph_table(struct atomisp_sub_device *asd,
-				struct atomisp_css_morph_table *table);
-
-void atomisp_css_get_morph_table(struct atomisp_sub_device *asd,
-				struct atomisp_css_morph_table *table);
-
-void atomisp_css_morph_table_free(struct atomisp_css_morph_table *table);
-
-void atomisp_css_set_cont_prev_start_time(struct atomisp_device *isp,
-					unsigned int overlap);
-
-int atomisp_css_get_dis_stat(struct atomisp_sub_device *asd,
-			 struct atomisp_dis_statistics *stats);
-
-int atomisp_css_update_stream(struct atomisp_sub_device *asd);
-
-int atomisp_css_create_acc_pipe(struct atomisp_sub_device *asd);
-
-int atomisp_css_start_acc_pipe(struct atomisp_sub_device *asd);
-
-int atomisp_css_stop_acc_pipe(struct atomisp_sub_device *asd);
-
-void atomisp_css_destroy_acc_pipe(struct atomisp_sub_device *asd);
-
-int atomisp_css_load_acc_extension(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					enum atomisp_css_pipe_id pipe_id,
-					unsigned int type);
-
-void atomisp_css_unload_acc_extension(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					enum atomisp_css_pipe_id pipe_id);
-
-int atomisp_css_wait_acc_finish(struct atomisp_sub_device *asd);
-
-void atomisp_css_acc_done(struct atomisp_sub_device *asd);
-
-int atomisp_css_load_acc_binary(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					unsigned int index);
-
-void atomisp_css_unload_acc_binary(struct atomisp_sub_device *asd);
-
-struct atomisp_acc_fw;
-int atomisp_css_set_acc_parameters(struct atomisp_acc_fw *acc_fw);
-
-int atomisp_css_isr_thread(struct atomisp_device *isp,
-			   bool *frame_done_found,
-			   bool *css_pipe_done,
-			   bool *reset_wdt_timer);
-void atomisp_set_stop_timeout(unsigned int timeout);
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.c
deleted file mode 100644
index c6de3c8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.c
+++ /dev/null
@@ -1,1576 +0,0 @@
-/*
- * Support for Clovertrail PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <linux/kfifo.h>
-#include <media/videobuf-vmalloc.h>
-#include <media/v4l2-dev.h>
-
-#include "sh_css_debug.h"
-#include "host/mmu_local.h"
-#include "device_access/device_access.h"
-#include "memory_access/memory_access.h"
-
-#include "atomisp_compat.h"
-#include "atomisp_internal.h"
-#include "atomisp_cmd.h"
-
-#include "sh_css_accelerate.h"
-#include <asm/intel-mid.h>
-
-void atomisp_css_debug_dump_sp_sw_debug_info(void)
-{
-	sh_css_dump_sp_sw_debug_info();
-}
-
-void atomisp_css_debug_dump_debug_info(const char *context)
-{
-	sh_css_dump_debug_info(context);
-}
-
-void atomisp_css_debug_set_dtrace_level(const unsigned int trace_level)
-{
-	sh_css_set_dtrace_level(trace_level);
-}
-
-void atomisp_store_uint32(hrt_address addr, uint32_t data)
-{
-	device_store_uint32(addr, data);
-}
-
-void atomisp_load_uint32(hrt_address addr, uint32_t *data)
-{
-	*data = device_load_uint32(addr);
-}
-
-int atomisp_css_init(struct atomisp_device *isp)
-{
-	device_set_base_address(0);
-
-	/* set css env */
-	isp->css_env.isp_css_env = sh_css_default_env();
-	isp->css_env.isp_css_env.sh_env.alloc = atomisp_kernel_zalloc;
-	isp->css_env.isp_css_env.sh_env.free = atomisp_kernel_free;
-
-	/*
-	 * if the driver gets closed and reopened, the HMM is not reinitialized
-	 * This means we need to put the L1 page table base address back into
-	 * the ISP
-	 */
-	if (isp->mmu_l1_base)
-		/*
-		 * according to sh_css.c sh_css_mmu_set_page_table_base_index
-		 * is deprecated and mmgr_set_base_address should be used
-		 * instead. But just for now (with CSS "alpha") replacing
-		 * all sh_cssh_mmu_set_page_table_base_index() -calls
-		 * with mmgr_set_base_address() is not working.
-		 */
-		sh_css_mmu_set_page_table_base_index(
-				HOST_ADDRESS(isp->mmu_l1_base));
-
-	/* With CSS "alpha" it is mandatory to set base address always */
-	mmgr_set_base_address(HOST_ADDRESS(isp->mmu_l1_base));
-
-	/* Init ISP */
-	if (sh_css_init(&isp->css_env.isp_css_env,
-			isp->firmware->data, isp->firmware->size)) {
-		dev_err(isp->dev, "css init failed --- bad firmware?\n");
-		return -EINVAL;
-	}
-
-	/* CSS has default zoom factor of 61x61, we want no zoom
-	   because the zoom binary for capture is broken (XNR). */
-	if (IS_ISP24XX(isp))
-		sh_css_set_zoom_factor(MRFLD_MAX_ZOOM_FACTOR,
-					MRFLD_MAX_ZOOM_FACTOR);
-	else
-		sh_css_set_zoom_factor(MFLD_MAX_ZOOM_FACTOR,
-					MFLD_MAX_ZOOM_FACTOR);
-
-	dev_dbg(isp->dev, "sh_css_init success\n");
-
-	return 0;
-}
-
-void atomisp_css_uninit(struct atomisp_device *isp)
-{
-	sh_css_uninit();
-
-	/* store L1 base address for next time we init the CSS */
-	isp->mmu_l1_base = (void *)sh_css_mmu_get_page_table_base_index();
-}
-
-void atomisp_css_suspend(void)
-{
-	sh_css_suspend();
-}
-
-int atomisp_css_resume(struct atomisp_device *isp)
-{
-	sh_css_resume();
-
-	return 0;
-}
-
-int atomisp_css_irq_translate(struct atomisp_device *isp,
-			      unsigned int *infos)
-{
-	int err;
-
-	err = sh_css_translate_interrupt(infos);
-	if (err != sh_css_success) {
-		dev_warn(isp->dev,
-			  "%s:failed to translate irq (err = %d,infos = %d)\n",
-			  __func__, err, *infos);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_rx_get_irq_info(unsigned int *infos)
-{
-	sh_css_rx_get_interrupt_info(infos);
-}
-
-void atomisp_css_rx_clear_irq_info(unsigned int infos)
-{
-	sh_css_rx_clear_interrupt_info(infos);
-}
-
-int atomisp_css_irq_enable(struct atomisp_device *isp,
-			    enum atomisp_css_irq_info info, bool enable)
-{
-	if (sh_css_enable_interrupt(info, enable) != sh_css_success) {
-		dev_warn(isp->dev, "%s:Invalid irq info.\n", __func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_init_struct(struct atomisp_sub_device *asd)
-{
-	/* obtain the pointers to the default configurations */
-	sh_css_get_tnr_config((const struct atomisp_css_tnr_config **)
-				&asd->params.default_tnr_config);
-	sh_css_get_nr_config((const struct atomisp_css_nr_config **)
-				&asd->params.default_nr_config);
-	sh_css_get_ee_config((const struct atomisp_css_ee_config **)
-				&asd->params.default_ee_config);
-	sh_css_get_ob_config((const struct atomisp_css_ob_config **)
-				&asd->params.default_ob_config);
-	sh_css_get_dp_config((const struct atomisp_css_dp_config **)
-				&asd->params.default_dp_config);
-	sh_css_get_wb_config((const struct atomisp_css_wb_config **)
-				&asd->params.default_wb_config);
-	sh_css_get_cc_config((const struct atomisp_css_cc_config **)
-				&asd->params.default_cc_config);
-	sh_css_get_de_config((const struct atomisp_css_de_config **)
-				&asd->params.default_de_config);
-	sh_css_get_gc_config((const struct atomisp_css_gc_config **)
-				&asd->params.default_gc_config);
-	sh_css_get_3a_config((const struct atomisp_css_3a_config **)
-				&asd->params.default_3a_config);
-	sh_css_get_macc_table((const struct atomisp_css_macc_table **)
-				&asd->params.default_macc_table);
-	sh_css_get_ctc_table((const struct atomisp_css_ctc_table **)
-				&asd->params.default_ctc_table);
-	sh_css_get_gamma_table((const struct atomisp_css_gamma_table **)
-				&asd->params.default_gamma_table);
-
-	/* we also initialize our configurations with the defaults */
-	asd->params.tnr_config  = *asd->params.default_tnr_config;
-	asd->params.nr_config   = *asd->params.default_nr_config;
-	asd->params.ee_config   = *asd->params.default_ee_config;
-	asd->params.ob_config   = *asd->params.default_ob_config;
-	asd->params.dp_config   = *asd->params.default_dp_config;
-	asd->params.wb_config   = *asd->params.default_wb_config;
-	asd->params.cc_config   = *asd->params.default_cc_config;
-	asd->params.de_config   = *asd->params.default_de_config;
-	asd->params.gc_config   = *asd->params.default_gc_config;
-	asd->params.s3a_config  = *asd->params.default_3a_config;
-	asd->params.macc_table  = *asd->params.default_macc_table;
-	asd->params.ctc_table   = *asd->params.default_ctc_table;
-	asd->params.gamma_table =
-		*asd->params.default_gamma_table;
-}
-
-int atomisp_q_video_buffer_to_css(struct atomisp_sub_device *asd,
-			struct videobuf_vmalloc_memory *vm_mem,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_buffer_type css_buf_type,
-			enum atomisp_css_pipe_id css_pipe_id)
-{
-	enum sh_css_err err;
-
-	err = sh_css_queue_buffer(css_pipe_id, css_buf_type, vm_mem->vaddr);
-	if (err != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_q_s3a_buffer_to_css(struct atomisp_sub_device *asd,
-			struct atomisp_s3a_buf *s3a_buf,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_pipe_id css_pipe_id)
-{
-	if (sh_css_queue_buffer(css_pipe_id, SH_CSS_BUFFER_TYPE_3A_STATISTICS,
-				&s3a_buf->s3a_data)) {
-		dev_dbg(asd->isp->dev, "failed to q s3a stat buffer\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int atomisp_q_dis_buffer_to_css(struct atomisp_sub_device *asd,
-			struct atomisp_dis_buf *dis_buf,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_pipe_id css_pipe_id)
-{
-	if (sh_css_queue_buffer(css_pipe_id,
-				SH_CSS_BUFFER_TYPE_DIS_STATISTICS,
-				&dis_buf->dis_data)) {
-		dev_dbg(asd->isp->dev, "failed to q dis stat buffer\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_mmu_invalidate_cache(void)
-{
-	sh_css_mmu_invalidate_cache();
-}
-
-void atomisp_css_mmu_invalidate_tlb(void)
-{
-	sh_css_enable_sp_invalidate_tlb();
-}
-
-void atomisp_css_mmu_set_page_table_base_index(unsigned long base_index)
-{
-	sh_css_mmu_set_page_table_base_index((hrt_data)base_index);
-}
-
-int atomisp_css_start(struct atomisp_sub_device *asd,
-			enum atomisp_css_pipe_id pipe_id, bool in_reset)
-{
-	enum sh_css_err err;
-
-	err = sh_css_start(pipe_id);
-	if (err != sh_css_success) {
-		dev_err(asd->isp->dev, "sh_css_start error:%d.\n", err);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_update_isp_params(struct atomisp_sub_device *asd)
-{
-	sh_css_update_isp_params();
-}
-
-int atomisp_css_queue_buffer(struct atomisp_sub_device *asd,
-			     enum atomisp_input_stream_id stream_id,
-			     enum atomisp_css_pipe_id pipe_id,
-			     enum atomisp_css_buffer_type buf_type,
-			     struct atomisp_css_buffer *isp_css_buffer)
-{
-	void *buffer;
-
-	switch (buf_type) {
-	case SH_CSS_BUFFER_TYPE_3A_STATISTICS:
-		buffer = isp_css_buffer->s3a_data;
-		break;
-	case SH_CSS_BUFFER_TYPE_DIS_STATISTICS:
-		buffer = isp_css_buffer->dis_data;
-		break;
-	case SH_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
-		buffer = isp_css_buffer->css_buffer.data.frame;
-		break;
-	case SH_CSS_BUFFER_TYPE_OUTPUT_FRAME:
-		buffer = isp_css_buffer->css_buffer.data.frame;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	if (sh_css_queue_buffer(pipe_id, buf_type, buffer) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_dequeue_buffer(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_pipe_id pipe_id,
-				enum atomisp_css_buffer_type buf_type,
-				struct atomisp_css_buffer *isp_css_buffer)
-{
-	enum sh_css_err err;
-	void *buffer;
-
-	err = sh_css_dequeue_buffer(pipe_id, buf_type, (void **)&buffer);
-	if (err != sh_css_success) {
-		dev_err(asd->isp->dev,
-			"sh_css_dequeue_buffer failed: 0x%x\n", err);
-		return -EINVAL;
-	}
-
-	switch (buf_type) {
-	case SH_CSS_BUFFER_TYPE_3A_STATISTICS:
-		isp_css_buffer->s3a_data = buffer;
-		break;
-	case SH_CSS_BUFFER_TYPE_DIS_STATISTICS:
-		isp_css_buffer->dis_data = buffer;
-		break;
-	case SH_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
-		isp_css_buffer->css_buffer.data.frame = buffer;
-		break;
-	case SH_CSS_BUFFER_TYPE_OUTPUT_FRAME:
-		isp_css_buffer->css_buffer.data.frame = buffer;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int atomisp_css_allocate_3a_dis_bufs(struct atomisp_sub_device *asd,
-				struct atomisp_s3a_buf *s3a_buf,
-				struct atomisp_dis_buf *dis_buf)
-{
-	if (sh_css_allocate_stat_buffers_from_info(&s3a_buf->s3a_data,
-			&dis_buf->dis_data, &asd->params.curr_grid_info)
-			!= sh_css_success) {
-		dev_err(asd->isp->dev, "3a and dis buf allocation failed.\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_free_3a_buffers(struct atomisp_s3a_buf *s3a_buf)
-{
-	sh_css_free_stat_buffers(&s3a_buf->s3a_data, NULL);
-}
-
-void atomisp_css_free_dis_buffers(struct atomisp_dis_buf *dis_buf)
-{
-	sh_css_free_stat_buffers(NULL, &dis_buf->dis_data);
-}
-
-void atomisp_css_free_3a_dis_buffers(struct atomisp_sub_device *asd)
-{
-	struct atomisp_s3a_buf *s3a_buf, *_s3a_buf;
-	struct atomisp_dis_buf *dis_buf, *_dis_buf;
-
-	/* 3A statistics use vmalloc, DIS use kmalloc */
-	vfree(asd->params.s3a_output_buf);
-	asd->params.s3a_output_buf = NULL;
-	asd->params.s3a_output_bytes = 0;
-	asd->params.s3a_buf_data_valid = false;
-
-	kfree(asd->params.dis_hor_proj_buf);
-	kfree(asd->params.dis_ver_proj_buf);
-	kfree(asd->params.dis_hor_coef_buf);
-	kfree(asd->params.dis_ver_coef_buf);
-
-	asd->params.dis_hor_proj_buf = NULL;
-	asd->params.dis_ver_proj_buf = NULL;
-	asd->params.dis_hor_coef_buf = NULL;
-	asd->params.dis_ver_coef_buf = NULL;
-	asd->params.dis_hor_proj_bytes = 0;
-	asd->params.dis_ver_proj_bytes = 0;
-	asd->params.dis_hor_coef_bytes = 0;
-	asd->params.dis_ver_coef_bytes = 0;
-	asd->params.dis_proj_data_valid = false;
-
-	list_for_each_entry_safe(s3a_buf, _s3a_buf, &asd->s3a_stats, list) {
-		sh_css_free_stat_buffers(&s3a_buf->s3a_data, NULL);
-		list_del(&s3a_buf->list);
-		kfree(s3a_buf);
-	}
-
-	list_for_each_entry_safe(dis_buf, _dis_buf, &asd->dis_stats, list) {
-		sh_css_free_stat_buffers(NULL, &dis_buf->dis_data);
-		list_del(&dis_buf->list);
-		kfree(dis_buf);
-	}
-}
-
-int atomisp_css_get_grid_info(struct atomisp_sub_device *asd,
-				enum atomisp_css_pipe_id pipe_id,
-				int stream_index)
-{
-	enum sh_css_err err;
-	struct atomisp_css_grid_info old_info = asd->params.curr_grid_info;
-
-	switch (asd->run_mode->val) {
-	case ATOMISP_RUN_MODE_PREVIEW:
-		err = sh_css_preview_get_grid_info(
-					&asd->params.curr_grid_info);
-		if (err != sh_css_success) {
-			dev_err(asd->isp->dev,
-				 "sh_css_preview_get_grid_info failed: %d\n",
-				 err);
-			return -EINVAL;
-		}
-		break;
-	case ATOMISP_RUN_MODE_VIDEO:
-		err = sh_css_video_get_grid_info(
-					&asd->params.curr_grid_info);
-		if (err != sh_css_success) {
-			dev_err(asd->isp->dev,
-				 "sh_css_video_get_grid_info failed: %d\n",
-				 err);
-			return -EINVAL;
-		}
-		break;
-	default:
-		err = sh_css_capture_get_grid_info(
-					&asd->params.curr_grid_info);
-		if (err != sh_css_success) {
-			dev_err(asd->isp->dev,
-				 "sh_css_capture_get_grid_info failed: %d\n",
-				 err);
-			return -EINVAL;
-		}
-	}
-
-	/* If the grid info has not changed and the buffers for 3A and
-	 * DIS statistics buffers are allocated or buffer size would be zero
-	 * then no need to do anything. */
-	if ((!memcmp(&old_info, &asd->params.curr_grid_info, sizeof(old_info))
-	    && asd->params.s3a_output_buf
-	    && asd->params.dis_hor_coef_buf)
-	    || asd->params.curr_grid_info.s3a_grid.width == 0
-	    || asd->params.curr_grid_info.s3a_grid.height == 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_alloc_3a_output_buf(struct atomisp_sub_device *asd)
-{
-	/* 3A statistics. These can be big, so we use vmalloc. */
-	asd->params.s3a_output_bytes =
-		asd->params.curr_grid_info.s3a_grid.width *
-		asd->params.curr_grid_info.s3a_grid.height *
-		sizeof(*asd->params.s3a_output_buf);
-
-	dev_dbg(asd->isp->dev, "asd->params.s3a_output_bytes: %d\n",
-		asd->params.s3a_output_bytes);
-	asd->params.s3a_output_buf = vmalloc(
-					asd->params.s3a_output_bytes);
-
-	if (asd->params.s3a_output_buf == NULL
-	    && asd->params.s3a_output_bytes != 0)
-		return -ENOMEM;
-
-	memset(asd->params.s3a_output_buf, 0, asd->params.s3a_output_bytes);
-	asd->params.s3a_buf_data_valid = false;
-
-	return 0;
-}
-
-int atomisp_alloc_dis_coef_buf(struct atomisp_sub_device *asd)
-{
-	/* DIS coefficients. */
-	asd->params.dis_hor_coef_bytes =
-		asd->params.curr_grid_info.dvs_hor_coef_num *
-		SH_CSS_DIS_NUM_COEF_TYPES *
-		sizeof(*asd->params.dis_hor_coef_buf);
-
-	asd->params.dis_ver_coef_bytes =
-		asd->params.curr_grid_info.dvs_ver_coef_num *
-		SH_CSS_DIS_NUM_COEF_TYPES *
-		sizeof(*asd->params.dis_ver_coef_buf);
-
-	asd->params.dis_hor_coef_buf =
-		kzalloc(asd->params.dis_hor_coef_bytes, GFP_KERNEL);
-	if (asd->params.dis_hor_coef_buf == NULL &&
-			asd->params.dis_hor_coef_bytes != 0)
-		return -ENOMEM;
-
-	asd->params.dis_ver_coef_buf =
-		kzalloc(asd->params.dis_ver_coef_bytes, GFP_KERNEL);
-	if (asd->params.dis_ver_coef_buf == NULL &&
-			asd->params.dis_ver_coef_bytes != 0)
-		return -ENOMEM;
-
-	/* DIS projections. */
-	asd->params.dis_proj_data_valid = false;
-	asd->params.dis_hor_proj_bytes =
-		asd->params.curr_grid_info.dvs_grid.aligned_height *
-		SH_CSS_DIS_NUM_COEF_TYPES *
-		sizeof(*asd->params.dis_hor_proj_buf);
-
-	asd->params.dis_ver_proj_bytes =
-		asd->params.curr_grid_info.dvs_grid.aligned_width *
-		SH_CSS_DIS_NUM_COEF_TYPES *
-		sizeof(*asd->params.dis_ver_proj_buf);
-
-	asd->params.dis_hor_proj_buf = kzalloc(
-					asd->params.dis_hor_proj_bytes,
-					GFP_KERNEL);
-	if (asd->params.dis_hor_proj_buf == NULL &&
-			asd->params.dis_hor_proj_bytes != 0)
-		return -ENOMEM;
-
-	asd->params.dis_ver_proj_buf = kzalloc(
-					asd->params.dis_ver_proj_bytes,
-					GFP_KERNEL);
-	if (asd->params.dis_ver_proj_buf == NULL &&
-			asd->params.dis_ver_proj_bytes != 0)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int atomisp_css_get_3a_statistics(struct atomisp_sub_device *asd,
-				  struct atomisp_css_buffer *isp_css_buffer)
-{
-	enum sh_css_err err;
-
-	if (asd->params.s3a_output_buf && asd->params.s3a_output_bytes) {
-		/* To avoid racing with atomisp_3a_stat() */
-		err = sh_css_get_3a_statistics(
-			asd->params.s3a_output_buf,
-			asd->params.curr_grid_info.s3a_grid.use_dmem,
-			isp_css_buffer->s3a_data);
-		if (err != sh_css_success) {
-			dev_err(asd->isp->dev,
-				"sh_css_get_3a_statistics failed: 0x%x\n", err);
-			return -EINVAL;
-		}
-		asd->params.s3a_buf_data_valid = true;
-	}
-
-	return 0;
-}
-
-void atomisp_css_get_dis_statistics(struct atomisp_sub_device *asd,
-				    struct atomisp_css_buffer *isp_css_buffer)
-{
-	if (asd->params.dis_ver_proj_bytes
-	    && asd->params.dis_ver_proj_buf
-	    && asd->params.dis_hor_proj_buf
-	    && asd->params.dis_hor_proj_bytes) {
-		/* To avoid racing with atomisp_get_dis_stat()*/
-		sh_css_get_dis_projections(asd->params.dis_hor_proj_buf,
-				   asd->params.dis_ver_proj_buf,
-				   isp_css_buffer->dis_data);
-		asd->params.dis_proj_data_valid = true;
-	}
-}
-
-int atomisp_css_dequeue_event(struct atomisp_css_event *current_event)
-{
-	if (sh_css_dequeue_event(&current_event->pipe,
-				&current_event->event.type) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-void atomisp_css_temp_pipe_to_pipe_id(struct atomisp_css_event *current_event)
-{
-}
-
-int atomisp_css_input_set_resolution(struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					struct v4l2_mbus_framefmt *ffmt)
-{
-	if (sh_css_input_set_resolution(ffmt->width, ffmt->height)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-void atomisp_css_input_set_binning_factor(struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					unsigned int bin_factor)
-{
-	sh_css_input_set_binning_factor(bin_factor);
-}
-
-void atomisp_css_input_set_bayer_order(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_bayer_order bayer_order)
-{
-	sh_css_input_set_bayer_order(bayer_order);
-}
-
-void atomisp_css_input_set_format(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_stream_format format)
-{
-	sh_css_input_set_format(format);
-}
-
-int atomisp_css_input_set_effective_resolution(
-					struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					unsigned int width, unsigned int height)
-{
-	if (sh_css_input_set_effective_resolution(width, height)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-void atomisp_css_video_set_dis_envelope(struct atomisp_sub_device *asd,
-					unsigned int dvs_w, unsigned int dvs_h)
-{
-	sh_css_video_set_dis_envelope(dvs_w, dvs_h);
-}
-
-void atomisp_css_input_set_two_pixels_per_clock(
-					struct atomisp_sub_device *asd,
-					bool two_ppc)
-{
-	sh_css_input_set_two_pixels_per_clock(two_ppc);
-}
-
-void atomisp_css_enable_raw_binning(struct atomisp_sub_device *asd,
-					bool enable)
-{
-	sh_css_enable_raw_binning(enable);
-}
-
-void atomisp_css_enable_dz(struct atomisp_sub_device *asd, bool enable)
-{
-}
-
-void atomisp_css_capture_set_mode(struct atomisp_sub_device *asd,
-				enum atomisp_css_capture_mode mode)
-{
-	sh_css_capture_set_mode(mode);
-}
-
-void atomisp_css_input_set_mode(struct atomisp_sub_device *asd,
-				enum atomisp_css_input_mode mode)
-{
-	sh_css_input_set_mode(mode);
-}
-
-void atomisp_css_capture_enable_online(struct atomisp_sub_device *asd,
-							bool enable)
-{
-	sh_css_capture_enable_online(enable);
-}
-
-void atomisp_css_preview_enable_online(struct atomisp_sub_device *asd,
-							bool enable)
-{
-	sh_css_preview_enable_online(enable);
-}
-
-void atomisp_css_enable_continuous(struct atomisp_sub_device *asd,
-							bool enable)
-{
-	sh_css_enable_continuous(enable);
-}
-
-void atomisp_css_enable_cont_capt(bool enable, bool stop_copy_preview)
-{
-	sh_css_enable_cont_capt(enable, stop_copy_preview);
-}
-
-int atomisp_css_input_configure_port(struct atomisp_sub_device *asd,
-					mipi_port_ID_t port,
-					unsigned int num_lanes,
-					unsigned int timeout)
-{
-	if (sh_css_input_configure_port(port, num_lanes, timeout)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_frame_allocate(struct atomisp_css_frame **frame,
-				unsigned int width, unsigned int height,
-				enum atomisp_css_frame_format format,
-				unsigned int padded_width,
-				unsigned int raw_bit_depth)
-{
-	if (sh_css_frame_allocate(frame, width, height, format,
-			padded_width, raw_bit_depth) != sh_css_success)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int atomisp_css_frame_allocate_from_info(struct atomisp_css_frame **frame,
-				const struct atomisp_css_frame_info *info)
-{
-	if (sh_css_frame_allocate_from_info(frame, info) != sh_css_success)
-		return -ENOMEM;
-
-	return 0;
-}
-
-void atomisp_css_frame_free(struct atomisp_css_frame *frame)
-{
-	sh_css_frame_free(frame);
-}
-
-int atomisp_css_frame_map(struct atomisp_css_frame **frame,
-				const struct atomisp_css_frame_info *info,
-				const void *data, uint16_t attribute,
-				void *context)
-{
-	if (sh_css_frame_map(frame, info, data, attribute, context)
-	    != sh_css_success)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int atomisp_css_set_black_frame(struct atomisp_sub_device *asd,
-				const struct atomisp_css_frame *raw_black_frame)
-{
-	if (sh_css_set_black_frame(raw_black_frame) != sh_css_success)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int atomisp_css_allocate_continuous_frames(bool init_time,
-				struct atomisp_sub_device *asd)
-{
-	if (sh_css_allocate_continuous_frames(init_time) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-void atomisp_css_update_continuous_frames(struct atomisp_sub_device *asd)
-{
-	sh_css_update_continuous_frames();
-}
-
-int atomisp_css_stop(struct atomisp_sub_device *asd,
-			enum atomisp_css_pipe_id pipe_id, bool in_reset)
-{
-	enum sh_css_err ret;
-
-	/* No need to dump debug traces when css is stopped. */
-	sh_css_set_dtrace_level(0);
-	switch (pipe_id) {
-	case SH_CSS_PREVIEW_PIPELINE:
-		ret = sh_css_preview_stop();
-		break;
-	case SH_CSS_VIDEO_PIPELINE:
-		ret = sh_css_video_stop();
-		break;
-	case SH_CSS_CAPTURE_PIPELINE:
-		/* fall through */
-	default:
-		ret = sh_css_capture_stop();
-		break;
-	}
-	sh_css_set_dtrace_level(CSS_DTRACE_VERBOSITY_LEVEL);
-
-	if (ret != sh_css_success) {
-		dev_err(asd->isp->dev, "stop css fatal error.\n");
-		return ret == sh_css_err_internal_error ? -EIO : -EINVAL;
-	}
-
-	return 0;
-}
-
-int atomisp_css_continuous_set_num_raw_frames(
-					struct atomisp_sub_device *asd,
-					int num_frames)
-{
-	int max_raw_frames = sh_css_continuous_get_max_raw_frames();
-
-	if (num_frames > max_raw_frames) {
-		dev_warn(asd->isp->dev, "continuous_num_raw_frames %d->%d\n",
-				num_frames, max_raw_frames);
-		num_frames = max_raw_frames;
-	}
-
-	if (sh_css_continuous_set_num_raw_frames(num_frames) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-void atomisp_css_disable_vf_pp(struct atomisp_sub_device *asd,
-			       bool disable)
-{
-	sh_css_disable_vf_pp(disable);
-}
-
-int atomisp_css_preview_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	if (sh_css_preview_configure_output(width, height, min_width, format)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	if (sh_css_capture_configure_output(width, height, min_width, format)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_video_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	if (sh_css_video_configure_output(width, height, min_width, format)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_video_configure_viewfinder(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	if (sh_css_video_configure_viewfinder(width, height, min_width, format)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_configure_viewfinder(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	if (sh_css_capture_configure_viewfinder(width, height, min_width,
-						format) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_video_get_viewfinder_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	if (sh_css_video_get_viewfinder_frame_info(info) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_get_viewfinder_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	if (sh_css_capture_get_viewfinder_frame_info(info)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_get_output_raw_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	if (sh_css_capture_get_output_raw_frame_info(info)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_preview_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	if (sh_css_preview_get_output_frame_info(info) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	if (sh_css_capture_get_output_frame_info(info) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_video_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	if (sh_css_video_get_output_frame_info(info) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_get_css_frame_info(struct atomisp_sub_device *asd,
-				uint16_t source_pad,
-				struct atomisp_css_frame_info *frame_info)
-{
-	enum sh_css_err ret = sh_css_err_internal_error;
-
-	switch (source_pad) {
-	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
-	case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO:
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO
-		    || asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER)
-			ret = sh_css_video_get_output_frame_info(frame_info);
-		else
-			ret = sh_css_capture_get_output_frame_info(frame_info);
-		break;
-	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-			ret = sh_css_video_get_viewfinder_frame_info(
-					frame_info);
-		else if (!atomisp_is_mbuscode_raw(
-				asd->fmt[asd->capture_pad].fmt.code))
-			ret = sh_css_capture_get_viewfinder_frame_info(
-					frame_info);
-		break;
-	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-			ret = sh_css_video_get_viewfinder_frame_info(
-					frame_info);
-		else
-			ret = sh_css_preview_get_output_frame_info(frame_info);
-		break;
-	default:
-		/* Return with error */
-		break;
-	}
-
-	return ret != sh_css_success ? -EINVAL : 0;
-}
-
-int atomisp_css_preview_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height)
-{
-	if (sh_css_preview_configure_pp_input(width, height) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height)
-{
-	if (sh_css_capture_configure_pp_input(width, height) != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_video_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height)
-{
-	/* Not supported on CSS1.5, Dummy function for compiling. */
-	return 0;
-}
-
-int atomisp_css_offline_capture_configure(struct atomisp_sub_device *asd,
-				int num_captures, unsigned int skip, int offset)
-{
-	if (sh_css_offline_capture_configure(num_captures, skip, offset)
-	    != sh_css_success)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd,
-				   bool enable)
-{
-	sh_css_capture_enable_xnr(enable);
-	return 0;
-}
-
-void atomisp_css_send_input_frame(struct atomisp_sub_device *asd,
-				  unsigned short *data, unsigned int width,
-				  unsigned int height)
-{
-	sh_css_send_input_frame(data, width, height);
-}
-
-bool atomisp_css_isp_has_started(void)
-{
-	return sh_css_isp_has_started();
-}
-
-void atomisp_css_request_flash(struct atomisp_sub_device *asd)
-{
-	sh_css_request_flash();
-}
-
-void atomisp_css_set_wb_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_wb_config *wb_config)
-{
-	sh_css_set_wb_config(wb_config);
-}
-
-void atomisp_css_set_ob_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ob_config *ob_config)
-{
-	sh_css_set_ob_config(ob_config);
-}
-
-void atomisp_css_set_dp_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_dp_config *dp_config)
-{
-	sh_css_set_dp_config(dp_config);
-}
-
-void atomisp_css_set_de_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_de_config *de_config)
-{
-	sh_css_set_de_config(de_config);
-}
-
-void atomisp_css_set_default_de_config(struct atomisp_sub_device *asd)
-{
-	sh_css_set_de_config(asd->params.default_de_config);
-}
-
-void atomisp_css_set_ce_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ce_config *ce_config)
-{
-	sh_css_set_ce_config(ce_config);
-}
-
-void atomisp_css_set_nr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_nr_config *nr_config)
-{
-	sh_css_set_nr_config(nr_config);
-}
-
-void atomisp_css_set_ee_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ee_config *ee_config)
-{
-	sh_css_set_ee_config(ee_config);
-}
-
-void atomisp_css_set_tnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_tnr_config *tnr_config)
-{
-	sh_css_set_tnr_config(tnr_config);
-}
-
-void atomisp_css_set_cc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cc_config *cc_config)
-{
-	sh_css_set_cc_config(cc_config);
-}
-
-void atomisp_css_set_macc_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_macc_table *macc_table)
-{
-	sh_css_set_macc_table(macc_table);
-}
-
-void atomisp_css_set_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_gamma_table *gamma_table)
-{
-	sh_css_set_gamma_table(gamma_table);
-}
-
-void atomisp_css_set_ctc_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_ctc_table *ctc_table)
-{
-	sh_css_set_ctc_table(ctc_table);
-}
-
-void atomisp_css_set_gc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_gc_config *gc_config)
-{
-	sh_css_set_gc_config(gc_config);
-}
-
-void atomisp_css_set_3a_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_3a_config *s3a_config)
-{
-	sh_css_set_3a_config(s3a_config);
-}
-
-void atomisp_css_video_set_dis_vector(struct atomisp_sub_device *asd,
-				struct atomisp_dis_vector *vector)
-{
-	sh_css_video_set_dis_vector(vector->x, vector->y);
-}
-
-int atomisp_css_set_dis_coefs(struct atomisp_sub_device *asd,
-			  struct atomisp_dis_coefficients *coefs)
-{
-	if (coefs->horizontal_coefficients == NULL ||
-	    coefs->vertical_coefficients   == NULL ||
-	    asd->params.dis_hor_coef_buf   == NULL ||
-	    asd->params.dis_ver_coef_buf   == NULL)
-		return -EINVAL;
-
-	if (copy_from_user(asd->params.dis_hor_coef_buf,
-	    coefs->horizontal_coefficients, asd->params.dis_hor_coef_bytes))
-		return -EFAULT;
-	if (copy_from_user(asd->params.dis_ver_coef_buf,
-	    coefs->vertical_coefficients, asd->params.dis_ver_coef_bytes))
-		return -EFAULT;
-
-	sh_css_set_dis_coefficients(asd->params.dis_hor_coef_buf,
-				    asd->params.dis_ver_coef_buf);
-	asd->params.dis_proj_data_valid = false;
-
-	return 0;
-}
-
-void atomisp_css_set_zoom_factor(struct atomisp_sub_device *asd,
-					unsigned int zoom)
-{
-	sh_css_set_zoom_factor(zoom, zoom);
-}
-
-int atomisp_css_get_wb_config(struct atomisp_sub_device *asd,
-			struct atomisp_wb_config *config)
-{
-	memcpy(config, &asd->params.wb_config, sizeof(*config));
-	return 0;
-}
-
-int atomisp_css_get_ob_config(struct atomisp_sub_device *asd,
-			struct atomisp_ob_config *config)
-{
-	const struct atomisp_css_ob_config *ob_config;
-	sh_css_get_ob_config(&ob_config);
-	memcpy(config, ob_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_dp_config(struct atomisp_sub_device *asd,
-			struct atomisp_dp_config *config)
-{
-	memcpy(config, &asd->params.dp_config, sizeof(*config));
-	return 0;
-}
-
-int atomisp_css_get_de_config(struct atomisp_sub_device *asd,
-			struct atomisp_de_config *config)
-{
-	memcpy(config, &asd->params.de_config, sizeof(*config));
-	return 0;
-}
-
-int atomisp_css_get_nr_config(struct atomisp_sub_device *asd,
-			struct atomisp_nr_config *config)
-{
-	const struct atomisp_css_nr_config *nr_config;
-	sh_css_get_nr_config(&nr_config);
-	memcpy(config, nr_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_ee_config(struct atomisp_sub_device *asd,
-			struct atomisp_ee_config *config)
-{
-	const struct atomisp_css_ee_config *ee_config;
-	sh_css_get_ee_config(&ee_config);
-	memcpy(config, ee_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_tnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_tnr_config *config)
-{
-	memcpy(config, &asd->params.tnr_config, sizeof(*config));
-	return 0;
-}
-
-int atomisp_css_get_ctc_table(struct atomisp_sub_device *asd,
-			struct atomisp_ctc_table *config)
-{
-	const struct sh_css_ctc_table *tab;
-
-	sh_css_get_ctc_table(&tab);
-	memcpy(config, tab->data, sizeof(tab->data));
-	return 0;
-}
-
-int atomisp_css_get_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_gamma_table *config)
-{
-	const struct sh_css_gamma_table *tab;
-
-	sh_css_get_gamma_table(&tab);
-	memcpy(config, tab->data, sizeof(tab->data));
-
-	return 0;
-}
-
-int atomisp_css_get_gc_config(struct atomisp_sub_device *asd,
-			struct atomisp_gc_config *config)
-{
-	memcpy(config, &asd->params.gc_config, sizeof(*config));
-	return 0;
-}
-
-int atomisp_css_get_3a_config(struct atomisp_sub_device *asd,
-			struct atomisp_3a_config *config)
-{
-	memcpy(config, &asd->params.s3a_config, sizeof(*config));
-	return 0;
-}
-
-int atomisp_css_get_zoom_factor(struct atomisp_sub_device *asd,
-					unsigned int *zoom)
-{
-	sh_css_get_zoom_factor(zoom, zoom);
-	return 0;
-}
-
-/*
- * Function to set/get image stablization statistics
- */
-int atomisp_css_get_dis_stat(struct atomisp_sub_device *asd,
-			 struct atomisp_dis_statistics *stats)
-{
-	struct atomisp_device *isp = asd->isp;
-	unsigned long flags;
-	int error;
-
-	if (stats->vertical_projections   == NULL ||
-	    stats->horizontal_projections == NULL ||
-	    asd->params.dis_hor_proj_buf  == NULL ||
-	    asd->params.dis_ver_proj_buf  == NULL)
-		return -EINVAL;
-
-	/* isp needs to be streaming to get DIS statistics */
-	spin_lock_irqsave(&isp->lock, flags);
-	if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
-		spin_unlock_irqrestore(&isp->lock, flags);
-		return -EINVAL;
-	}
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	if (!asd->params.video_dis_en)
-		return -EINVAL;
-
-	if (atomisp_compare_grid(asd, &stats->grid_info) != 0)
-		/* If the grid info in the argument differs from the current
-		   grid info, we tell the caller to reset the grid size and
-		   try again. */
-		return -EAGAIN;
-
-	if (!asd->params.dis_proj_data_valid)
-		return -EBUSY;
-
-	error = copy_to_user(stats->vertical_projections,
-			     asd->params.dis_ver_proj_buf,
-			     asd->params.dis_ver_proj_bytes);
-
-	error |= copy_to_user(stats->horizontal_projections,
-			     asd->params.dis_hor_proj_buf,
-			     asd->params.dis_hor_proj_bytes);
-
-	if (error)
-		return -EFAULT;
-
-	return 0;
-}
-
-struct atomisp_css_shading_table *atomisp_css_shading_table_alloc(
-				unsigned int width, unsigned int height)
-{
-	return sh_css_shading_table_alloc(width, height);
-}
-
-void atomisp_css_set_shading_table(struct atomisp_sub_device *asd,
-				struct atomisp_css_shading_table *table)
-{
-	sh_css_set_shading_table(table);
-}
-
-void atomisp_css_shading_table_free(struct atomisp_css_shading_table *table)
-{
-	sh_css_shading_table_free(table);
-}
-
-struct atomisp_css_morph_table *atomisp_css_morph_table_allocate(
-				unsigned int width, unsigned int height)
-{
-	return sh_css_morph_table_allocate(width, height);
-}
-
-void atomisp_css_set_morph_table(struct atomisp_sub_device *asd,
-					struct atomisp_css_morph_table *table)
-{
-	sh_css_set_morph_table(table);
-}
-
-void atomisp_css_get_morph_table(struct atomisp_sub_device *asd,
-				struct atomisp_css_morph_table *table)
-{
-	const struct atomisp_css_morph_table *tab;
-	sh_css_get_morph_table(&tab);
-	memcpy(table, tab, sizeof(*table));
-}
-
-void atomisp_css_morph_table_free(struct atomisp_css_morph_table *table)
-{
-	sh_css_morph_table_free(table);
-}
-
-void atomisp_css_set_cont_prev_start_time(struct atomisp_device *isp,
-					unsigned int overlap)
-{
-	sh_css_set_cont_prev_start_time(overlap);
-}
-
-int atomisp_css_update_stream(struct atomisp_sub_device *asd)
-{
-	return 0;
-}
-
-int atomisp_css_wait_acc_finish(struct atomisp_sub_device *asd)
-{
-	if (sh_css_wait_for_completion(SH_CSS_ACC_PIPELINE) != sh_css_success)
-		return -EIO;
-
-	return 0;
-}
-
-void atomisp_css_acc_done(struct atomisp_sub_device *asd)
-{
-}
-
-int atomisp_css_create_acc_pipe(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	isp->acc.pipeline = sh_css_create_pipeline();
-	if (!isp->acc.pipeline)
-		return -EBADE;
-
-	return 0;
-}
-
-int atomisp_css_start_acc_pipe(struct atomisp_sub_device *asd)
-{
-	unsigned int i = 0;
-	struct atomisp_device *isp = asd->isp;
-
-	sh_css_start_pipeline(SH_CSS_ACC_PIPELINE, isp->acc.pipeline);
-	/* wait 2-4ms before failing */
-	while (!sh_css_sp_has_booted()) {
-		if (i > 100) {
-			atomisp_reset(isp);
-			return -EIO;
-		}
-		usleep_range(20, 40);
-		i++;
-	}
-
-	sh_css_init_buffer_queues();
-	return 0;
-}
-
-int atomisp_css_stop_acc_pipe(struct atomisp_sub_device *asd)
-{
-	enum sh_css_err ret;
-	ret = sh_css_acceleration_stop();
-	if (ret != sh_css_success) {
-		dev_err(asd->isp->dev, "cannot stop acceleration pipeline\n");
-		return ret == sh_css_err_internal_error ? -EIO : -EINVAL;
-	}
-	return 0;
-}
-
-void atomisp_css_destroy_acc_pipe(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	if (isp->acc.pipeline) {
-		sh_css_destroy_pipeline(isp->acc.pipeline);
-		isp->acc.pipeline = NULL;
-	}
-}
-
-/* Set the ACC binary arguments */
-int atomisp_css_set_acc_parameters(struct atomisp_acc_fw *acc_fw)
-{
-	struct sh_css_hmm_section sec;
-	unsigned int mem;
-
-	for (mem = 0; mem < ATOMISP_ACC_NR_MEMORY; mem++) {
-		if (acc_fw->args[mem].length == 0)
-			continue;
-
-		sec.ddr_address = acc_fw->args[mem].css_ptr;
-		sec.ddr_size = acc_fw->args[mem].length;
-		if (sh_css_acc_set_firmware_parameters(acc_fw->fw, mem, sec)
-			!= sh_css_success)
-			return -EIO;
-	}
-
-	return 0;
-}
-
-/* Load acc binary extension */
-int atomisp_css_load_acc_extension(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					enum atomisp_css_pipe_id pipe_id,
-					unsigned int type)
-{
-	if (sh_css_load_extension(fw, pipe_id, type) != sh_css_success)
-		return -EBADSLT;
-
-	return 0;
-}
-
-/* Unload acc binary extension */
-void atomisp_css_unload_acc_extension(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					enum atomisp_css_pipe_id pipe_id)
-{
-	sh_css_unload_extension(fw, pipe_id);
-}
-
-int atomisp_css_load_acc_binary(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					unsigned int index)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	if (sh_css_pipeline_add_acc_stage(
-	    isp->acc.pipeline, fw) != sh_css_success)
-		return -EBADSLT;
-
-	return 0;
-}
-
-void atomisp_set_stop_timeout(unsigned int timeout)
-{
-	sh_css_set_stop_timeout(timeout);
-}
-
-int atomisp_css_isr_thread(struct atomisp_device *isp,
-			   bool *frame_done_found,
-			   bool *css_pipe_done,
-			   bool *reset_wdt_timer)
-{
-	struct atomisp_css_event current_event;
-	DEFINE_KFIFO(events, struct atomisp_css_event, ATOMISP_CSS_EVENTS_MAX);
-	/* ISP1.5 has only 1 stream */
-	struct atomisp_sub_device *asd = &isp->asd[0];
-
-	while (!atomisp_css_dequeue_event(&current_event)) {
-		switch (current_event.event.type) {
-		case CSS_EVENT_PIPELINE_DONE:
-			css_pipe_done[asd->index] = true;
-			break;
-		case CSS_EVENT_OUTPUT_FRAME_DONE:
-		case CSS_EVENT_VF_OUTPUT_FRAME_DONE:
-			*reset_wdt_timer = true; /* ISP running */
-			/* fall through */
-		case CSS_EVENT_3A_STATISTICS_DONE:
-		case CSS_EVENT_DIS_STATISTICS_DONE:
-			break;
-		default:
-			dev_err(isp->dev, "unknown event 0x%x pipe:%d\n",
-				current_event.event.type, current_event.pipe);
-			break;
-		}
-		kfifo_in(&events, &current_event, 1);
-	}
-
-	while (kfifo_out(&events, &current_event, 1)) {
-		atomisp_css_temp_pipe_to_pipe_id(&current_event);
-		switch (current_event.event.type) {
-		case CSS_EVENT_OUTPUT_FRAME_DONE:
-			frame_done_found[asd->index] = true;
-			atomisp_buf_done(asd, 0, CSS_BUFFER_TYPE_OUTPUT_FRAME,
-					 current_event.pipe, true,
-					 ATOMISP_INPUT_STREAM_GENERAL);
-			break;
-		case CSS_EVENT_3A_STATISTICS_DONE:
-			atomisp_buf_done(asd, 0,
-					 CSS_BUFFER_TYPE_3A_STATISTICS,
-					 current_event.pipe,
-					 css_pipe_done[asd->index],
-					 ATOMISP_INPUT_STREAM_GENERAL);
-			break;
-		case CSS_EVENT_VF_OUTPUT_FRAME_DONE:
-			atomisp_buf_done(asd, 0,
-					 CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
-					 current_event.pipe, true,
-					 ATOMISP_INPUT_STREAM_GENERAL);
-			break;
-		case CSS_EVENT_DIS_STATISTICS_DONE:
-			atomisp_buf_done(asd, 0,
-					 CSS_BUFFER_TYPE_DIS_STATISTICS,
-					 current_event.pipe,
-					 css_pipe_done[asd->index],
-					 ATOMISP_INPUT_STREAM_GENERAL);
-			break;
-		case CSS_EVENT_PIPELINE_DONE:
-			break;
-		default:
-			dev_err(isp->dev, "unhandled css stored event: 0x%x\n",
-					current_event.event.type);
-			break;
-		}
-	}
-
-	return 0;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.h
deleted file mode 100644
index 65599eb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css15.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Support for Clovertrail PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __ATOMISP_COMPAT_CSS15_H__
-#define __ATOMISP_COMPAT_CSS15_H__
-
-#include <media/v4l2-mediabus.h>
-
-#include "sh_css.h"
-#include "sh_css_sp.h"
-
-#define atomisp_css_pipe_id sh_css_pipe_id
-#define atomisp_css_pipeline	sh_css_pipeline
-#define atomisp_css_buffer_type sh_css_buffer_type
-#define atomisp_css_dis_data sh_css_dis_data
-#define atomisp_css_irq_info sh_css_interrupt_info
-#define atomisp_css_bayer_order sh_css_bayer_order
-#define atomisp_css_stream_format sh_css_input_format
-#define atomisp_css_capture_mode sh_css_capture_mode
-#define atomisp_css_input_mode sh_css_input_mode
-#define atomisp_css_frame sh_css_frame
-#define atomisp_css_frame_format sh_css_frame_format
-#define atomisp_css_frame_info sh_css_frame_info
-#define atomisp_css_dp_config	sh_css_dp_config
-#define atomisp_css_wb_config	sh_css_wb_config
-#define atomisp_css_cc_config	sh_css_cc_config
-#define atomisp_css_nr_config	sh_css_nr_config
-#define atomisp_css_ee_config	sh_css_ee_config
-#define atomisp_css_ob_config	sh_css_ob_config
-#define atomisp_css_de_config	sh_css_de_config
-#define atomisp_css_ce_config	sh_css_ce_config
-#define atomisp_css_gc_config	sh_css_gc_config
-#define atomisp_css_tnr_config	sh_css_tnr_config
-#define atomisp_css_3a_config	sh_css_3a_config
-#define atomisp_css_gamma_table	sh_css_gamma_table
-#define atomisp_css_ctc_table	sh_css_ctc_table
-#define atomisp_css_macc_table	sh_css_macc_table
-#define atomisp_css_grid_info	sh_css_grid_info
-#define atomisp_css_shading_table	sh_css_shading_table
-#define atomisp_css_morph_table	sh_css_morph_table
-#define atomisp_css_fw_info	sh_css_fw_info
-
-#define CSS_PIPE_ID_PREVIEW	SH_CSS_PREVIEW_PIPELINE
-#define CSS_PIPE_ID_COPY	SH_CSS_COPY_PIPELINE
-#define CSS_PIPE_ID_VIDEO	SH_CSS_VIDEO_PIPELINE
-#define CSS_PIPE_ID_CAPTURE	SH_CSS_CAPTURE_PIPELINE
-#define CSS_PIPE_ID_ACC		SH_CSS_ACC_PIPELINE
-#define CSS_PIPE_ID_NUM		SH_CSS_NR_OF_PIPELINES
-
-#define CSS_INPUT_MODE_SENSOR	SH_CSS_INPUT_MODE_SENSOR
-#define CSS_INPUT_MODE_FIFO	SH_CSS_INPUT_MODE_FIFO
-#define CSS_INPUT_MODE_TPG	SH_CSS_INPUT_MODE_TPG
-#define CSS_INPUT_MODE_PRBS	SH_CSS_INPUT_MODE_PRBS
-#define CSS_INPUT_MODE_MEMORY	SH_CSS_INPUT_MODE_MEMORY
-
-#define CSS_IRQ_INFO_EVENTS_READY	SH_CSS_IRQ_INFO_BUFFER_DONE
-#define CSS_IRQ_INFO_INVALID_FIRST_FRAME \
-	SH_CSS_IRQ_INFO_INVALID_FIRST_FRAME
-
-#if defined(HAS_IRQ_MAP_VERSION_2)
-
-#define CSS_IRQ_INFO_INPUT_SYSTEM_ERROR	SH_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR
-#define CSS_IRQ_INFO_IF_ERROR	SH_CSS_IRQ_INFO_IF_ERROR
-
-#elif defined(HAS_IRQ_MAP_VERSION_1) || defined(HAS_IRQ_MAP_VERSION_1_DEMO)
-
-#define CSS_IRQ_INFO_CSS_RECEIVER_ERROR	SH_CSS_IRQ_INFO_CSS_RECEIVER_ERROR
-
-#endif
-
-#define CSS_BUFFER_TYPE_NUM	SH_CSS_BUFFER_TYPE_NR_OF_TYPES
-
-#define CSS_FRAME_FLASH_STATE_NONE	SH_CSS_FRAME_NO_FLASH
-#define CSS_FRAME_FLASH_STATE_PARTIAL	SH_CSS_FRAME_PARTIAL_FLASH
-#define CSS_FRAME_FLASH_STATE_FULL	SH_CSS_FRAME_FULLY_FLASH
-
-#define CSS_BAYER_ORDER_GRBG	sh_css_bayer_order_grbg
-#define CSS_BAYER_ORDER_RGGB	sh_css_bayer_order_rggb
-#define CSS_BAYER_ORDER_BGGR	sh_css_bayer_order_bggr
-#define CSS_BAYER_ORDER_GBRG	sh_css_bayer_order_gbrg
-
-/*
- * Hide SH_ naming difference in otherwise common CSS macros.
- */
-#define CSS_ID(val)	(SH_ ## val)
-#define CSS_EVENT(val)	(SH_CSS_EVENT_ ## val)
-#define CSS_FORMAT(val)	(SH_CSS_INPUT_FORMAT_ ## val)
-
-struct atomisp_css_env {
-	struct sh_css_env isp_css_env;
-};
-
-struct atomisp_s3a_buf {
-	union sh_css_s3a_data s3a_data;
-	struct list_head list;
-};
-
-struct atomisp_dis_buf {
-	struct atomisp_css_dis_data dis_data;
-	struct list_head list;
-};
-
-struct atomisp_css_buffer {
-	struct sh_css_buffer css_buffer;
-	struct atomisp_css_dis_data *dis_data;
-	union sh_css_s3a_data *s3a_data;
-};
-
-struct atomisp_css_event_type {
-	enum sh_css_event_type type;
-};
-
-struct atomisp_css_event {
-	enum atomisp_css_pipe_id pipe;
-	struct atomisp_css_event_type event;
-};
-
-void atomisp_css_mmu_invalidate_tlb(void);
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.c
deleted file mode 100644
index ffd2016..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.c
+++ /dev/null
@@ -1,3559 +0,0 @@
-/*
- * Support for Clovertrail PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <media/videobuf-vmalloc.h>
-#include <media/v4l2-dev.h>
-
-#include "mmu/isp_mmu.h"
-#include "mmu/sh_mmu_mrfld.h"
-#include "hmm/hmm_bo_dev.h"
-#include "hmm/hmm.h"
-
-#include "atomisp_compat.h"
-#include "atomisp_internal.h"
-#include "atomisp_cmd.h"
-#include "atomisp-regs.h"
-#include "atomisp_fops.h"
-#include "atomisp_ioctl.h"
-
-#include "hrt/hive_isp_css_mm_hrt.h"
-
-#include <asm/intel-mid.h>
-
-#ifdef CSS21
-#include "ia_css_debug.h"
-#include "ia_css_isp_param.h"
-#else /* CSS21 */
-#include "ia_css_accelerate.h"
-#include "sh_css_debug.h"
-#endif /* CSS21 */
-
-#include <linux/pm_runtime.h>
-
-/* Assume max number of ACC stages */
-#define MAX_ACC_STAGES	20
-
-/*
- * to serialize MMIO access , this is due to ISP2400 silicon issue Sighting
- * #4684168, if concurrency access happened, system may hard hang.
- */
-static DEFINE_SPINLOCK(mmio_lock);
-
-enum frame_info_type {
-	ATOMISP_CSS_VF_FRAME,
-	ATOMISP_CSS_OUTPUT_FRAME,
-	ATOMISP_CSS_RAW_FRAME,
-};
-
-struct bayer_ds_factor {
-	unsigned int numerator;
-	unsigned int denominator;
-};
-
-#ifdef CSS21
-void atomisp_css_debug_dump_sp_sw_debug_info(void)
-{
-	ia_css_debug_dump_sp_sw_debug_info();
-}
-
-void atomisp_css_debug_dump_debug_info(const char *context)
-{
-	ia_css_debug_dump_debug_info(context);
-}
-
-void atomisp_css_debug_set_dtrace_level(const unsigned int trace_level)
-{
-	ia_css_debug_set_dtrace_level(trace_level);
-}
-#else /* CSS21 */
-void atomisp_css_debug_dump_sp_sw_debug_info(void)
-{
-	sh_css_dump_sp_sw_debug_info();
-}
-
-void atomisp_css_debug_dump_debug_info(const char *context)
-{
-	sh_css_dump_debug_info(context);
-}
-
-void atomisp_css_debug_set_dtrace_level(const unsigned int trace_level)
-{
-	sh_css_set_dtrace_level(trace_level);
-}
-#endif /* CSS21 */
-
-static ia_css_ptr atomisp_css2_mm_alloc(size_t bytes, uint32_t attr)
-{
-	if (attr & IA_CSS_MEM_ATTR_CACHED)
-		return (ia_css_ptr) hrt_isp_css_mm_calloc_cached(bytes);
-	else if (attr & IA_CSS_MEM_ATTR_ZEROED)
-		return (ia_css_ptr) hrt_isp_css_mm_calloc(bytes);
-	else if (attr & IA_CSS_MEM_ATTR_CONTIGUOUS)
-		return (ia_css_ptr) hrt_isp_css_mm_calloc_contiguous(bytes);
-	else
-		return (ia_css_ptr) hrt_isp_css_mm_calloc(bytes);
-}
-
-static void atomisp_css2_mm_free(ia_css_ptr ptr)
-{
-	hrt_isp_css_mm_free(ptr);
-}
-
-static int atomisp_css2_mm_load(ia_css_ptr ptr, void *data, size_t bytes)
-{
-	return hrt_isp_css_mm_load(ptr, data, bytes);
-}
-
-static int atomisp_css2_mm_store(ia_css_ptr ptr, const void *data, size_t bytes)
-{
-	return hrt_isp_css_mm_store(ptr, data, bytes);
-}
-
-static int atomisp_css2_mm_set(ia_css_ptr ptr, int c, size_t bytes)
-{
-	return hrt_isp_css_mm_set(ptr, c, bytes);
-}
-
-static ia_css_ptr atomisp_css2_mm_mmap(const void *ptr, const size_t size,
-		   uint16_t attribute, void *context)
-{
-	struct hrt_userbuffer_attr *userbuffer_attr = context;
-	return hrt_isp_css_mm_alloc_user_ptr(
-			size, (void *)ptr, userbuffer_attr->pgnr,
-			userbuffer_attr->type,
-			attribute & HRT_BUF_FLAG_CACHED);
-}
-
-#ifdef CSS21
-static void *atomisp_css21_hrt_vaddr_to_host_vaddr(ia_css_ptr ptr)
-{
-	return hmm_isp_vaddr_to_host_vaddr(ptr);
-}
-
-static ia_css_ptr atomisp_css21_host_vaddr_to_hrt_vaddr(const void *ptr)
-{
-	return hmm_host_vaddr_to_hrt_vaddr(ptr);
-}
-#endif
-
-void atomisp_css2_hw_store_8(hrt_address addr, uint8_t data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	_hrt_master_port_store_8(addr, data);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-}
-
-static void atomisp_css2_hw_store_16(hrt_address addr, uint16_t data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	_hrt_master_port_store_16(addr, data);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-}
-
-static void atomisp_css2_hw_store_32(hrt_address addr, uint32_t data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	_hrt_master_port_store_32(addr, data);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-}
-
-static uint8_t atomisp_css2_hw_load_8(hrt_address addr)
-{
-	unsigned long flags;
-	uint8_t ret;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	ret = _hrt_master_port_load_8(addr);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-	return ret;
-}
-
-uint16_t atomisp_css2_hw_load_16(hrt_address addr)
-{
-	unsigned long flags;
-	uint16_t ret;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	ret = _hrt_master_port_load_16(addr);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-	return ret;
-}
-uint32_t atomisp_css2_hw_load_32(hrt_address addr)
-{
-	unsigned long flags;
-	uint32_t ret;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	ret = _hrt_master_port_load_32(addr);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-	return ret;
-}
-
-static void atomisp_css2_hw_store(hrt_address addr,
-				  const void *from, uint32_t n)
-{
-	unsigned long flags;
-	unsigned i;
-	unsigned int _to = (unsigned int)addr;
-	const char *_from = (const char *)from;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	for (i = 0; i < n; i++, _to++, _from++)
-		_hrt_master_port_store_8(_to , *_from);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-}
-
-static void atomisp_css2_hw_load(hrt_address addr, void *to, uint32_t n)
-{
-	unsigned long flags;
-	unsigned i;
-	char *_to = (char *)to;
-	unsigned int _from = (unsigned int)addr;
-
-	spin_lock_irqsave(&mmio_lock, flags);
-	raw_spin_lock(&pci_config_lock);
-	for (i = 0; i < n; i++, _to++, _from++)
-		*_to = _hrt_master_port_load_8(_from);
-	raw_spin_unlock(&pci_config_lock);
-	spin_unlock_irqrestore(&mmio_lock, flags);
-}
-
-static int atomisp_css2_dbg_print(const char *fmt, va_list args)
-{
-	if (dbg_level > 5)
-		vprintk(fmt, args);
-	return 0;
-}
-
-static int atomisp_css2_err_print(const char *fmt, va_list args)
-{
-	vprintk(fmt, args);
-	return 0;
-}
-
-void atomisp_store_uint32(hrt_address addr, uint32_t data)
-{
-	atomisp_css2_hw_store_32(addr, data);
-}
-
-void atomisp_load_uint32(hrt_address addr, uint32_t *data)
-{
-	*data = atomisp_css2_hw_load_32(addr);
-}
-static int hmm_get_mmu_base_addr(unsigned int *mmu_base_addr)
-{
-	if (sh_mmu_mrfld.get_pd_base == NULL) {
-		dev_err(atomisp_dev, "get mmu base address failed.\n");
-		return -EINVAL;
-	}
-
-	*mmu_base_addr = sh_mmu_mrfld.get_pd_base(&bo_device.mmu,
-					bo_device.mmu.base_address);
-	return 0;
-}
-
-static void atomisp_isp_parameters_clean_up(
-				struct atomisp_css_isp_config *config)
-{
-	if (config->morph_table)
-		ia_css_morph_table_free(config->morph_table);
-
-	/*
-	 * Set NULL to configs pointer to avoid they are set into isp again when
-	 * some configs are changed and need to be updated later.
-	 */
-	memset(config, 0, sizeof(*config));
-}
-
-static void __dump_pipe_config(struct atomisp_sub_device *asd,
-			       struct atomisp_stream_env *stream_env,
-			       unsigned int pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	if (stream_env->pipes[pipe_id]) {
-		struct ia_css_pipe_config *p_config;
-		struct ia_css_pipe_extra_config *pe_config;
-		p_config = &stream_env->pipe_configs[pipe_id];
-		pe_config = &stream_env->pipe_extra_configs[pipe_id];
-		dev_dbg(isp->dev, "dumping pipe[%d] config:\n", pipe_id);
-		dev_dbg(isp->dev,
-			 "pipe_config.pipe_mode:%d.\n", p_config->mode);
-		dev_dbg(isp->dev,
-			 "pipe_config.output_info w=%d, h=%d.\n",
-			 p_config->output_info.res.width,
-			 p_config->output_info.res.height);
-#ifndef CSS21
-		dev_dbg(isp->dev,
-			 "pipe_config.bin_out w=%d, h=%d.\n",
-			 p_config->bin_out_res.width,
-			 p_config->bin_out_res.height);
-#else
-		dev_dbg(isp->dev,
-			 "pipe_config.vf_pp_in_res w=%d, h=%d.\n",
-			 p_config->vf_pp_in_res.width,
-			 p_config->vf_pp_in_res.height);
-		dev_dbg(isp->dev,
-			 "pipe_config.capt_pp_in_res w=%d, h=%d.\n",
-			 p_config->capt_pp_in_res.width,
-			 p_config->capt_pp_in_res.height);
-#endif /* CSS21 */
-		dev_dbg(isp->dev,
-			 "pipe_config.output.padded w=%d.\n",
-			 p_config->output_info.padded_width);
-		dev_dbg(isp->dev,
-			 "pipe_config.vf_output_info w=%d, h=%d.\n",
-			 p_config->vf_output_info.res.width,
-			 p_config->vf_output_info.res.height);
-		dev_dbg(isp->dev,
-			 "pipe_config.bayer_ds_out_res w=%d, h=%d.\n",
-			 p_config->bayer_ds_out_res.width,
-			 p_config->bayer_ds_out_res.height);
-		dev_dbg(isp->dev,
-			 "pipe_config.envelope w=%d, h=%d.\n",
-			 p_config->dvs_envelope.width,
-			 p_config->dvs_envelope.height);
-		dev_dbg(isp->dev,
-			 "pipe_config.isp_pipe_version:%d.\n",
-			p_config->isp_pipe_version);
-		dev_dbg(isp->dev,
-			 "pipe_config.default_capture_config.capture_mode=%d.\n",
-			 p_config->default_capture_config.mode);
-		dev_dbg(isp->dev,
-#ifndef CSS21
-			 "pipe_config.default_capture_config.enable_capture_pp=%d.\n",
-			 p_config->default_capture_config.enable_capture_pp);
-#else
-			 "pipe_config.enable_dz=%d.\n",
-			 p_config->enable_dz);
-#endif
-		dev_dbg(isp->dev,
-			 "pipe_config.default_capture_config.enable_xnr=%d.\n",
-			 p_config->default_capture_config.enable_xnr);
-		dev_dbg(isp->dev,
-			 "dumping pipe[%d] extra config:\n", pipe_id);
-		dev_dbg(isp->dev,
-			 "pipe_extra_config.enable_raw_binning:%d.\n",
-			 pe_config->enable_raw_binning);
-		dev_dbg(isp->dev,
-			 "pipe_extra_config.enable_yuv_ds:%d.\n",
-			 pe_config->enable_yuv_ds);
-		dev_dbg(isp->dev,
-			 "pipe_extra_config.enable_high_speed:%d.\n",
-			 pe_config->enable_high_speed);
-		dev_dbg(isp->dev,
-			 "pipe_extra_config.enable_dvs_6axis:%d.\n",
-			 pe_config->enable_dvs_6axis);
-		dev_dbg(isp->dev,
-			 "pipe_extra_config.enable_reduced_pipe:%d.\n",
-			 pe_config->enable_reduced_pipe);
-		dev_dbg(isp->dev,
-			 "pipe_(extra_)config.enable_dz:%d.\n",
-#ifdef CSS21
-			 p_config
-#else
-			 pe_config
-#endif
-			 ->enable_dz);
-		dev_dbg(isp->dev,
-			 "pipe_extra_config.disable_vf_pp:%d.\n",
-			 pe_config->disable_vf_pp);
-#ifndef CSS21
-		dev_dbg(isp->dev,
-			 "pipe_extra_config.disable_capture_pp:%d.\n",
-			 pe_config->disable_capture_pp);
-#endif
-	}
-}
-
-static void __dump_stream_config(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct ia_css_stream_config *s_config;
-	int i, j;
-	bool valid_stream;
-
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		valid_stream = false;
-		for (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {
-			if (asd->stream_env[i].pipes[j]) {
-				__dump_pipe_config(asd, &asd->stream_env[i], j);
-				valid_stream = true;
-			}
-		}
-		if (!valid_stream)
-			continue;
-		s_config = &asd->stream_env[i].stream_config;
-		dev_dbg(isp->dev,
-			"dumping stream config[%d]:\n", i);
-		dev_dbg(isp->dev,
-			"stream_config.mode=%d.\n",
-			s_config->mode);
-		dev_dbg(isp->dev,
-			"stream_config.input_res w=%d, h=%d.\n",
-			s_config->input_res.width,
-			s_config->input_res.height);
-		dev_dbg(isp->dev,
-			"stream_config.effective_res w=%d, h=%d.\n",
-			s_config->effective_res.width,
-			s_config->effective_res.height);
-		dev_dbg(isp->dev,
-			"stream_config.format=%d.\n",
-			s_config->format);
-		dev_dbg(isp->dev,
-			"stream_config.bayer_order=%d.\n",
-			s_config->bayer_order);
-		dev_dbg(isp->dev,
-			"stream_config.2ppc=%d.\n",
-			s_config->two_pixels_per_clock);
-		dev_dbg(isp->dev,
-			"stream_config.online=%d.\n",
-			s_config->online);
-		dev_dbg(isp->dev,
-			"stream_config.continuous=%d.\n",
-			s_config->continuous);
-		dev_dbg(isp->dev,
-			"stream_config.channel_id=%d.\n",
-			s_config->channel_id);
-#ifdef CSS21
-		dev_dbg(isp->dev,
-			"stream_config.init_num_cont_raw_buf=%d.\n",
-			s_config->init_num_cont_raw_buf);
-		dev_dbg(isp->dev,
-			"stream_config.target_num_cont_raw_buf=%d.\n",
-			s_config->target_num_cont_raw_buf);
-		dev_dbg(isp->dev,
-			"stream_config.left_padding=%d.\n",
-			s_config->left_padding);
-#endif
-	}
-}
-
-static int __destroy_stream(struct atomisp_sub_device *asd,
-			struct atomisp_stream_env *stream_env, bool force)
-{
-	struct atomisp_device *isp = asd->isp;
-	int i;
-
-	if (!stream_env->stream)
-		return 0;
-
-	if (!force) {
-		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-			if (stream_env->update_pipe[i])
-				break;
-
-		if (i == IA_CSS_PIPE_ID_NUM)
-			return 0;
-	}
-
-	if (stream_env->stream_state == CSS_STREAM_STARTED
-	    && ia_css_stream_stop(stream_env->stream) != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "stop stream failed.\n");
-		return -EINVAL;
-	}
-	stream_env->stream_state = CSS_STREAM_STOPPED;
-
-	if (ia_css_stream_destroy(stream_env->stream) != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "destroy stream failed.\n");
-		return -EINVAL;
-	}
-	stream_env->stream_state = CSS_STREAM_UNINIT;
-	stream_env->stream = NULL;
-
-	return 0;
-}
-
-static int __destroy_streams(struct atomisp_sub_device *asd, bool force)
-{
-	int ret, i;
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		ret = __destroy_stream(asd, &asd->stream_env[i], force);
-		if (ret)
-			return ret;
-	}
-	return 0;
-}
-static int __create_stream(struct atomisp_sub_device *asd,
-			   struct atomisp_stream_env *stream_env)
-{
-	int pipe_index = 0, i;
-	struct ia_css_pipe *multi_pipes[IA_CSS_PIPE_ID_NUM];
-
-	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
-		if (stream_env->pipes[i])
-			multi_pipes[pipe_index++] = stream_env->pipes[i];
-	}
-	if (pipe_index == 0)
-		return 0;
-
-#ifdef CSS21
-	stream_env->stream_config.target_num_cont_raw_buf =
-		asd->continuous_raw_buffer_size->val;
-#endif /* CSS21 */
-	stream_env->stream_config.channel_id = stream_env->ch_id;
-	if (ia_css_stream_create(&stream_env->stream_config,
-	    pipe_index, multi_pipes, &stream_env->stream) != IA_CSS_SUCCESS)
-		return -EINVAL;
-	stream_env->stream_state = CSS_STREAM_CREATED;
-	return 0;
-}
-
-static int __create_streams(struct atomisp_sub_device *asd)
-{
-	int ret, i;
-	__dump_stream_config(asd);
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		ret = __create_stream(asd, &asd->stream_env[i]);
-		if (ret)
-			goto rollback;
-	}
-	return 0;
-rollback:
-	for (i--; i >= 0; i--)
-		__destroy_stream(asd, &asd->stream_env[i], true);
-	return ret;
-}
-
-static int __destroy_stream_pipes(struct atomisp_sub_device *asd,
-				  struct atomisp_stream_env *stream_env,
-				  bool force)
-{
-	struct atomisp_device *isp = asd->isp;
-	int ret, i;
-	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
-		if (!stream_env->pipes[i] ||
-		    !(force || stream_env->update_pipe[i]))
-			continue;
-		if (ia_css_pipe_destroy(stream_env->pipes[i])
-		    != IA_CSS_SUCCESS) {
-			dev_err(isp->dev,
-				"destroy pipe[%d]failed.cannot recover.\n", i);
-			ret = -EINVAL;
-		}
-		stream_env->pipes[i] = NULL;
-		stream_env->update_pipe[i] = false;
-	}
-	return 0;
-}
-
-static int __destroy_pipes(struct atomisp_sub_device *asd, bool force)
-{
-	struct atomisp_device *isp = asd->isp;
-	int i;
-	int ret = 0;
-
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		if (asd->stream_env[i].stream) {
-
-			dev_err(isp->dev,
-				"cannot destroy css pipes for stream[%d].\n",
-				i);
-			continue;
-		}
-
-		ret = __destroy_stream_pipes(asd, &asd->stream_env[i], force);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-void atomisp_destroy_pipes_stream_force(struct atomisp_sub_device *asd)
-{
-	__destroy_streams(asd, true);
-	__destroy_pipes(asd, true);
-}
-
-static void __apply_additional_pipe_config(
-				struct atomisp_sub_device *asd,
-				struct atomisp_stream_env *stream_env,
-				enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	if (pipe_id < 0 || pipe_id >= IA_CSS_PIPE_ID_NUM) {
-		dev_err(isp->dev,
-			 "wrong pipe_id for additional pipe config.\n");
-		return;
-	}
-
-	/* apply default pipe config */
-	stream_env->pipe_configs[pipe_id].isp_pipe_version = 2;
-	/* apply isp 2.2 specific config for baytrail*/
-	switch (pipe_id) {
-	case IA_CSS_PIPE_ID_CAPTURE:
-		/* enable capture pp/dz manually or digital zoom would
-		 * fail*/
-		if (stream_env->pipe_configs[pipe_id].
-			default_capture_config.mode != CSS_CAPTURE_MODE_RAW)
-			stream_env->pipe_configs[pipe_id]
-#ifndef CSS21
-			    .default_capture_config.enable_capture_pp = true;
-#else
-			    .enable_dz = true;
-#endif
-		/*
-		 * FIXME!
-		 * For ISP2401 legacy input system, online still image pipe
-		 * would cause a watchdog timeout.
-		 * With pipe config, dz=0, image capture could be success.
-		 *
-		 * VIED BZ 1369 on tracking this.
-		 */
-		if (asd->isp->media_dev.hw_revision ==
-		    ATOMISP_HW_REVISION_ISP2401_LEGACY << ATOMISP_HW_REVISION_SHIFT) {
-#ifdef CSS21
-			stream_env->pipe_configs[pipe_id].enable_dz = false;
-#endif
-			dev_dbg(isp->dev,
-				"pipe config enable_dz is overrided for ISP2401 legacy.\n");
-		}
-		break;
-	case IA_CSS_PIPE_ID_VIDEO:
-		/* enable reduced pipe to have binary
-		 * video_dz_2_min selected*/
-		stream_env->pipe_extra_configs[pipe_id]
-		    .enable_reduced_pipe = true;
-#ifdef CSS21
-		stream_env->pipe_configs[pipe_id]
-#else
-		stream_env->pipe_extra_configs[pipe_id]
-#endif
-		    .enable_dz = false;
-#ifdef CSS20
-		if (asd->params.video_dis_en) {
-			stream_env->pipe_extra_configs[pipe_id]
-				.enable_dvs_6axis = true;
-			stream_env->pipe_configs[pipe_id]
-				.dvs_frame_delay = 2;
-		}
-#endif
-		break;
-	case IA_CSS_PIPE_ID_PREVIEW:
-	case IA_CSS_PIPE_ID_COPY:
-	case IA_CSS_PIPE_ID_ACC:
-		break;
-	default:
-		break;
-	}
-}
-
-static int __create_pipe(struct atomisp_sub_device *asd,
-			 struct atomisp_stream_env *stream_env,
-			 enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct ia_css_pipe_extra_config extra_config;
-	enum ia_css_err ret;
-	if (!stream_env->pipe_configs[pipe_id].output_info.res.width)
-		return 0;
-
-	ia_css_pipe_extra_config_defaults(&extra_config);
-
-	__apply_additional_pipe_config(asd, stream_env, pipe_id);
-	if (!memcmp(&extra_config,
-		    &stream_env->pipe_extra_configs[pipe_id],
-		    sizeof(extra_config)))
-		ret = ia_css_pipe_create(
-			&stream_env->pipe_configs[pipe_id],
-			&stream_env->pipes[pipe_id]);
-	else
-		ret = ia_css_pipe_create_extra(
-			&stream_env->pipe_configs[pipe_id],
-			&stream_env->pipe_extra_configs[pipe_id],
-			&stream_env->pipes[pipe_id]);
-	if (ret != IA_CSS_SUCCESS)
-		dev_err(isp->dev, "create pipe[%d] error.\n", pipe_id);
-	return ret;
-}
-
-static int __create_pipes(struct atomisp_sub_device *asd)
-{
-	enum ia_css_err ret;
-	int i, j;
-
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		for (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {
-			ret = __create_pipe(asd, &asd->stream_env[i], j);
-			if (ret != IA_CSS_SUCCESS)
-				break;
-		}
-		if (j < IA_CSS_PIPE_ID_NUM)
-			goto pipe_err;
-	}
-	return 0;
-pipe_err:
-	for (; i >= 0; i--) {
-		for (j--; j >= 0; j--) {
-			if (asd->stream_env[i].pipes[j]) {
-				ia_css_pipe_destroy(asd->stream_env[i].pipes[j]);
-				asd->stream_env[i].pipes[j] = NULL;
-			}
-		}
-		j = IA_CSS_PIPE_ID_NUM;
-	}
-	return -EINVAL;
-}
-
-int atomisp_css_update_stream(struct atomisp_sub_device *asd)
-{
-	int ret;
-	struct atomisp_device *isp = asd->isp;
-
-	if (__destroy_streams(asd, true) != IA_CSS_SUCCESS)
-		dev_warn(isp->dev, "destroy stream failed.\n");
-
-	if (__destroy_pipes(asd, true) != IA_CSS_SUCCESS)
-		dev_warn(isp->dev, "destroy pipe failed.\n");
-
-	ret = __create_pipes(asd);
-	if (ret != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "create pipe failed %d.\n", ret);
-		return -EIO;
-	}
-
-	ret = __create_streams(asd);
-	if (ret != IA_CSS_SUCCESS) {
-		dev_warn(isp->dev, "create stream failed %d.\n", ret);
-		__destroy_pipes(asd, true);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-int atomisp_css_init(struct atomisp_device *isp)
-{
-	unsigned int mmu_base_addr;
-	int ret;
-	enum ia_css_err err;
-
-	ret = hmm_get_mmu_base_addr(&mmu_base_addr);
-	if (ret)
-		return ret;
-
-	/* Init ISP */
-	err = ia_css_init(&isp->css_env.isp_css_env, NULL,
-			  (uint32_t)mmu_base_addr, IA_CSS_IRQ_TYPE_PULSE);
-	if (err != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "css init failed --- bad firmware?\n");
-		return -EINVAL;
-	}
-
-	dev_dbg(isp->dev, "sh_css_init success\n");
-
-	return 0;
-}
-
-int atomisp_css_load_firmware(struct atomisp_device *isp)
-{
-	enum ia_css_err err;
-
-	/* set css env */
-	isp->css_env.isp_css_fw.data = (void *)isp->firmware->data;
-	isp->css_env.isp_css_fw.bytes = isp->firmware->size;
-
-	isp->css_env.isp_css_env.cpu_mem_env.alloc = atomisp_kernel_zalloc;
-	isp->css_env.isp_css_env.cpu_mem_env.free = atomisp_kernel_free;
-
-	isp->css_env.isp_css_env.css_mem_env.alloc = atomisp_css2_mm_alloc;
-	isp->css_env.isp_css_env.css_mem_env.free = atomisp_css2_mm_free;
-	isp->css_env.isp_css_env.css_mem_env.load = atomisp_css2_mm_load;
-	isp->css_env.isp_css_env.css_mem_env.store = atomisp_css2_mm_store;
-	isp->css_env.isp_css_env.css_mem_env.set = atomisp_css2_mm_set;
-	isp->css_env.isp_css_env.css_mem_env.mmap = atomisp_css2_mm_mmap;
-#ifdef CSS21
-	isp->css_env.isp_css_env.css_mem_env.hrt_vaddr_to_host_vaddr =
-					atomisp_css21_hrt_vaddr_to_host_vaddr;
-	isp->css_env.isp_css_env.css_mem_env.host_vaddr_to_hrt_vaddr =
-					atomisp_css21_host_vaddr_to_hrt_vaddr;
-#endif
-
-	isp->css_env.isp_css_env.hw_access_env.store_8 =
-							atomisp_css2_hw_store_8;
-	isp->css_env.isp_css_env.hw_access_env.store_16 =
-						atomisp_css2_hw_store_16;
-	isp->css_env.isp_css_env.hw_access_env.store_32 =
-						atomisp_css2_hw_store_32;
-
-	isp->css_env.isp_css_env.hw_access_env.load_8 = atomisp_css2_hw_load_8;
-	isp->css_env.isp_css_env.hw_access_env.load_16 =
-							atomisp_css2_hw_load_16;
-	isp->css_env.isp_css_env.hw_access_env.load_32 =
-							atomisp_css2_hw_load_32;
-
-	isp->css_env.isp_css_env.hw_access_env.load = atomisp_css2_hw_load;
-	isp->css_env.isp_css_env.hw_access_env.store = atomisp_css2_hw_store;
-
-	isp->css_env.isp_css_env.print_env.debug_print = atomisp_css2_dbg_print;
-	isp->css_env.isp_css_env.print_env.error_print = atomisp_css2_err_print;
-
-	/* load isp fw into ISP memory */
-	err = ia_css_load_firmware(&isp->css_env.isp_css_env,
-				   &isp->css_env.isp_css_fw);
-	if (err != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "css load fw failed.\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_unload_firmware(struct atomisp_device *isp)
-{
-	ia_css_unload_firmware();
-}
-
-void atomisp_css_uninit(struct atomisp_device *isp)
-{
-	struct atomisp_sub_device *asd;
-	unsigned int i;
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		asd = &isp->asd[i];
-		atomisp_isp_parameters_clean_up(&asd->params.config);
-		asd->params.css_update_params_needed = false;
-	}
-
-	ia_css_uninit();
-}
-
-void atomisp_css_suspend(void)
-{
-	ia_css_uninit();
-}
-
-int atomisp_css_resume(struct atomisp_device *isp)
-{
-	unsigned int mmu_base_addr;
-	int ret;
-
-	ret = hmm_get_mmu_base_addr(&mmu_base_addr);
-	if (ret) {
-		dev_err(isp->dev, "get base address error.\n");
-		return -EINVAL;
-	}
-
-	ret = ia_css_init(&isp->css_env.isp_css_env, NULL,
-			  mmu_base_addr, IA_CSS_IRQ_TYPE_PULSE);
-	if (ret) {
-		dev_err(isp->dev, "re-init css failed.\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int atomisp_css_irq_translate(struct atomisp_device *isp,
-			      unsigned int *infos)
-{
-	int err;
-
-	err = ia_css_irq_translate(infos);
-	if (err != IA_CSS_SUCCESS) {
-		dev_warn(isp->dev,
-			  "%s:failed to translate irq (err = %d,infos = %d)\n",
-			  __func__, err, *infos);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_rx_get_irq_info(unsigned int *infos)
-{
-#ifndef ISP2401_NEW_INPUT_SYSTEM
-	ia_css_rx_get_irq_info(infos);
-#else
-	*infos = 0;
-#endif
-}
-
-void atomisp_css_rx_clear_irq_info(unsigned int infos)
-{
-#ifndef ISP2401_NEW_INPUT_SYSTEM
-	ia_css_rx_clear_irq_info(infos);
-#endif
-}
-
-int atomisp_css_irq_enable(struct atomisp_device *isp,
-			    enum atomisp_css_irq_info info, bool enable)
-{
-	if (ia_css_irq_enable(info, enable) != IA_CSS_SUCCESS) {
-		dev_warn(isp->dev, "%s:Invalid irq info.\n", __func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_init_struct(struct atomisp_sub_device *asd)
-{
-	int i, j;
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		asd->stream_env[i].stream = NULL;
-		for (j = 0; j < IA_CSS_PIPE_MODE_NUM; j++) {
-			asd->stream_env[i].pipes[j] = NULL;
-			asd->stream_env[i].update_pipe[j] = false;
-			ia_css_pipe_config_defaults(
-				&asd->stream_env[i].pipe_configs[j]);
-			ia_css_pipe_extra_config_defaults(
-				&asd->stream_env[i].pipe_extra_configs[j]);
-		}
-		ia_css_stream_config_defaults(&asd->stream_env[i].stream_config);
-	}
-}
-
-int atomisp_q_video_buffer_to_css(struct atomisp_sub_device *asd,
-			struct videobuf_vmalloc_memory *vm_mem,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_buffer_type css_buf_type,
-			enum atomisp_css_pipe_id css_pipe_id)
-{
-	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];
-	struct ia_css_buffer css_buf = {0};
-	enum ia_css_err err;
-
-	css_buf.type = css_buf_type;
-	css_buf.data.frame = vm_mem->vaddr;
-
-	err = ia_css_pipe_enqueue_buffer(
-				stream_env->pipes[css_pipe_id], &css_buf);
-	if (err != IA_CSS_SUCCESS)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_q_s3a_buffer_to_css(struct atomisp_sub_device *asd,
-			struct atomisp_s3a_buf *s3a_buf,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_pipe_id css_pipe_id)
-{
-	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];
-	struct ia_css_buffer buffer = {0};
-	struct atomisp_device *isp = asd->isp;
-
-	buffer.type = IA_CSS_BUFFER_TYPE_3A_STATISTICS;
-	buffer.data.stats_3a = s3a_buf->s3a_data;
-	if (ia_css_pipe_enqueue_buffer(
-				stream_env->pipes[css_pipe_id],
-				&buffer)) {
-		dev_dbg(isp->dev, "failed to q s3a stat buffer\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int atomisp_q_dis_buffer_to_css(struct atomisp_sub_device *asd,
-			struct atomisp_dis_buf *dis_buf,
-			enum atomisp_input_stream_id stream_id,
-			enum atomisp_css_pipe_id css_pipe_id)
-{
-	struct atomisp_stream_env *stream_env = &asd->stream_env[stream_id];
-	struct ia_css_buffer buffer = {0};
-	struct atomisp_device *isp = asd->isp;
-
-	buffer.type = IA_CSS_BUFFER_TYPE_DIS_STATISTICS;
-	buffer.data.stats_dvs = dis_buf->dis_data;
-	if (ia_css_pipe_enqueue_buffer(
-				stream_env->pipes[css_pipe_id],
-				&buffer)) {
-		dev_dbg(isp->dev, "failed to q dvs stat buffer\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-void atomisp_css_mmu_invalidate_cache(void)
-{
-	ia_css_mmu_invalidate_cache();
-}
-
-void atomisp_css_mmu_invalidate_tlb(void)
-{
-	ia_css_mmu_invalidate_cache();
-}
-
-void atomisp_css_mmu_set_page_table_base_index(unsigned long base_index)
-{
-}
-
-/*
- * Check whether currently running MIPI buffer size fulfill
- * the requirement of the stream to be run
- */
-bool __need_realloc_mipi_buffer(struct atomisp_device *isp)
-{
-	unsigned int i;
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		struct atomisp_sub_device *asd = &isp->asd[i];
-
-		if (asd->streaming !=
-				ATOMISP_DEVICE_STREAMING_ENABLED)
-			continue;
-		if (asd->mipi_frame_size < isp->mipi_frame_size)
-			return true;
-	}
-
-	return false;
-}
-
-int atomisp_css_start(struct atomisp_sub_device *asd,
-			enum atomisp_css_pipe_id pipe_id, bool in_reset)
-{
-	struct atomisp_device *isp = asd->isp;
-	int ret = 0, i = 0;
-	if (in_reset) {
-		if (__destroy_streams(asd, true))
-			dev_warn(isp->dev, "destroy stream failed.\n");
-
-		if (__destroy_pipes(asd, true))
-			dev_warn(isp->dev, "destroy pipe failed.\n");
-
-		if (__create_pipes(asd)) {
-			dev_err(isp->dev, "create pipe error.\n");
-			return -EINVAL;
-		}
-		if (__create_streams(asd)) {
-			dev_err(isp->dev, "create stream error.\n");
-			ret = -EINVAL;
-			goto stream_err;
-		}
-	}
-
-	/*
-	 * SP can only be started one time
-	 * if atomisp_subdev_streaming_count() tell there already has some
-	 * subdev at streamming, then SP should already be started previously,
-	 * so need to skip start sp procedure
-	 */
-	if (atomisp_streaming_count(isp)) {
-		dev_dbg(isp->dev, "skip start sp\n");
-		/*
-		 * FIXME! VIED BZ 1439:
-		 * ISP timeout in start second stream due to incorrect MIPI
-		 * Buffer size.
-		 *
-		 * This is due to MIPI buffers are allocated once and shared
-		 * by all streams. So if the first sensor start running, MIPI
-		 * buffer is allocated with size conrresponding to the sensor
-		 * output frame size; when start second sensor, whose output
-		 * resolution requires more MIPI buffers, the previous
-		 * allocated MIPI buffer could not fulfill the requirement and
-		 * hense get ISP timeout or other unexpected behavor.
-		 *
-		 * Workaround here is to reset ISP which will stop previous
-		 * running stream, re-allocate mipi buffer, and start again.
-		 */
-		if (__need_realloc_mipi_buffer(isp)) {
-			dev_warn(isp->dev, "Need to reallocate mipi buffer.\n");
-			/* destroy stream/pipe for this stream */
-			if (__destroy_streams(asd, true))
-				dev_warn(isp->dev, "destroy stream failed.\n");
-
-			if (__destroy_pipes(asd, true))
-				dev_warn(isp->dev, "destroy pipe failed.\n");
-
-			/*
-			 * reset running stream which will reset mipi buffer
-			 */
-			atomisp_css_flush(isp);
-
-			/* recreate stream/pipe for this stream */
-			if (__create_pipes(asd)) {
-				dev_err(isp->dev, "create pipe error.\n");
-				return -EINVAL;
-			}
-			if (__create_streams(asd)) {
-				dev_err(isp->dev, "create stream error.\n");
-				ret = -EINVAL;
-				goto stream_err;
-			}
-		}
-	} else if (ia_css_start_sp() != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "start sp error.\n");
-		ret = -EINVAL;
-		goto start_err;
-	}
-
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		if (asd->stream_env[i].stream) {
-			if (ia_css_stream_start(asd->stream_env[i]
-						.stream) != IA_CSS_SUCCESS) {
-				dev_err(isp->dev, "stream[%d] start error.\n", i);
-				ret = -EINVAL;
-				goto start_err;
-			} else {
-				asd->stream_env[i].stream_state = CSS_STREAM_STARTED;
-				dev_dbg(isp->dev, "stream[%d] started.\n", i);
-			}
-		}
-	}
-
-	return 0;
-
-start_err:
-	__destroy_streams(asd, true);
-stream_err:
-	__destroy_pipes(asd, true);
-
-	/* css 2.0 API limitation: ia_css_stop_sp() could be only called after
-	 * destroy all pipes
-	 */
-	/*
-	 * SP can not be stop if other streams are in use
-	 */
-	if (atomisp_streaming_count(isp))
-		dev_dbg(isp->dev, "skip stop sp\n");
-	else if (ia_css_isp_has_started() &&
-		 ia_css_stop_sp() != IA_CSS_SUCCESS)
-		dev_err(isp->dev, "stop sp failed.\n");
-
-	return ret;
-}
-
-void atomisp_css_update_isp_params(struct atomisp_sub_device *asd)
-{
-	/*
-	 * FIXME!
-	 * for ISP2401 new input system, this api is under development.
-	 * Calling it would cause kernel panic.
-	 *
-	 * VIED BZ: 1458
-	 *
-	 * Check if it is Cherry Trail and also new input system
-	 */
-	if ((asd->isp->media_dev.hw_revision & ATOMISP_HW_REVISION_MASK) ==
-	    (ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT)) {
-		dev_warn(asd->isp->dev, "%s: ia_css_stream_set_isp_config() not supported!.\n",
-				__func__);
-		return;
-	}
-
-	ia_css_stream_set_isp_config(
-			asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-			&asd->params.config);
-	atomisp_isp_parameters_clean_up(&asd->params.config);
-}
-
-int atomisp_css_queue_buffer(struct atomisp_sub_device *asd,
-			     enum atomisp_input_stream_id stream_id,
-			     enum atomisp_css_pipe_id pipe_id,
-			     enum atomisp_css_buffer_type buf_type,
-			     struct atomisp_css_buffer *isp_css_buffer)
-{
-	if (ia_css_pipe_enqueue_buffer(
-		asd->stream_env[stream_id].pipes[pipe_id],
-					&isp_css_buffer->css_buffer)
-					!= IA_CSS_SUCCESS)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_dequeue_buffer(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_pipe_id pipe_id,
-				enum atomisp_css_buffer_type buf_type,
-				struct atomisp_css_buffer *isp_css_buffer)
-{
-	struct atomisp_device *isp = asd->isp;
-	enum ia_css_err err;
-
-	err = ia_css_pipe_dequeue_buffer(
-		asd->stream_env[stream_id].pipes[pipe_id],
-					&isp_css_buffer->css_buffer);
-	if (err != IA_CSS_SUCCESS) {
-		dev_err(isp->dev,
-			"ia_css_pipe_dequeue_buffer failed: 0x%x\n", err);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int atomisp_css_allocate_3a_dis_bufs(struct atomisp_sub_device *asd,
-				struct atomisp_s3a_buf *s3a_buf,
-				struct atomisp_dis_buf *dis_buf)
-{
-	struct atomisp_device *isp = asd->isp;
-	if (asd->params.curr_grid_info.s3a_grid.enable) {
-		s3a_buf->s3a_data = ia_css_isp_3a_statistics_allocate(
-				&asd->params.curr_grid_info.s3a_grid);
-		if (!s3a_buf->s3a_data) {
-			dev_err(isp->dev, "3a buf allocation failed.\n");
-			return -EINVAL;
-		}
-	}
-
-	if (asd->params.curr_grid_info.dvs_grid.enable) {
-		dis_buf->dis_data = ia_css_isp_dvs2_statistics_allocate(
-				&asd->params.curr_grid_info.dvs_grid);
-		if (!dis_buf->dis_data) {
-			dev_err(isp->dev, "dvs buf allocation failed.\n");
-			ia_css_isp_3a_statistics_free(s3a_buf->s3a_data);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-void atomisp_css_free_3a_buffers(struct atomisp_s3a_buf *s3a_buf)
-{
-	ia_css_isp_3a_statistics_free(s3a_buf->s3a_data);
-}
-
-void atomisp_css_free_dis_buffers(struct atomisp_dis_buf *dis_buf)
-{
-	ia_css_isp_dvs2_statistics_free(dis_buf->dis_data);
-}
-
-void atomisp_css_free_3a_dis_buffers(struct atomisp_sub_device *asd)
-{
-	struct atomisp_s3a_buf *s3a_buf, *_s3a_buf;
-	struct atomisp_dis_buf *dis_buf, *_dis_buf;
-
-	/* 3A statistics use vmalloc, DIS use kmalloc */
-	if (asd->params.curr_grid_info.dvs_grid.enable) {
-		ia_css_dvs2_coefficients_free(asd->params.dvs_coeff);
-		ia_css_dvs2_statistics_free(asd->params.dvs_stat);
-		asd->params.dvs_coeff = NULL;
-		asd->params.dvs_stat = NULL;
-		asd->params.dvs_hor_proj_bytes = 0;
-		asd->params.dvs_ver_proj_bytes = 0;
-		asd->params.dvs_hor_coef_bytes = 0;
-		asd->params.dvs_ver_coef_bytes = 0;
-		asd->params.dis_proj_data_valid = false;
-		list_for_each_entry_safe(dis_buf, _dis_buf,
-						&asd->dis_stats, list) {
-			ia_css_isp_dvs2_statistics_free(dis_buf->dis_data);
-			list_del(&dis_buf->list);
-			kfree(dis_buf);
-		}
-	}
-	if (asd->params.curr_grid_info.s3a_grid.enable) {
-		ia_css_3a_statistics_free(asd->params.s3a_user_stat);
-		asd->params.s3a_user_stat = NULL;
-		asd->params.s3a_buf_data_valid = false;
-		asd->params.s3a_output_bytes = 0;
-		list_for_each_entry_safe(s3a_buf, _s3a_buf,
-						&asd->s3a_stats, list) {
-			ia_css_isp_3a_statistics_free(s3a_buf->s3a_data);
-			list_del(&s3a_buf->list);
-			kfree(s3a_buf);
-		}
-	}
-
-	if (asd->params.dvs_6axis) {
-		ia_css_dvs2_6axis_config_free(asd->params.dvs_6axis);
-		asd->params.dvs_6axis = NULL;
-	}
-}
-
-int atomisp_css_get_grid_info(struct atomisp_sub_device *asd,
-				enum atomisp_css_pipe_id pipe_id,
-				int source_pad)
-{
-	struct ia_css_pipe_info p_info;
-	struct ia_css_grid_info old_info;
-	struct atomisp_device *isp = asd->isp;
-	int stream_index = atomisp_source_pad_to_stream_id(asd, source_pad);
-
-	memset(&p_info, 0, sizeof(struct ia_css_pipe_info));
-	memset(&old_info, 0, sizeof(struct ia_css_grid_info));
-
-	if (ia_css_pipe_get_info(
-		asd->stream_env[stream_index].pipes[pipe_id],
-		&p_info) != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "ia_css_pipe_get_info failed\n");
-		return -EINVAL;
-	}
-
-	memcpy(&old_info, &asd->params.curr_grid_info,
-					sizeof(struct ia_css_grid_info));
-	memcpy(&asd->params.curr_grid_info, &p_info.grid_info,
-					sizeof(struct ia_css_grid_info));
-
-	/* If the grid info has not changed and the buffers for 3A and
-	 * DIS statistics buffers are allocated or buffer size would be zero
-	 * then no need to do anything. */
-	if ((!memcmp(&old_info, &asd->params.curr_grid_info, sizeof(old_info))
-	    && asd->params.s3a_user_stat && asd->params.dvs_stat)
-	    || asd->params.curr_grid_info.s3a_grid.width == 0
-	    || asd->params.curr_grid_info.s3a_grid.height == 0) {
-		dev_dbg(isp->dev,
-			"grid info change escape. memcmp=%d, s3a_user_stat=%d,"
-			"dvs_stat=%d, s3a.width=%d, s3a.height=%d\n",
-			!memcmp(&old_info, &asd->params.curr_grid_info,
-				 sizeof(old_info)),
-			 !!asd->params.s3a_user_stat, !!asd->params.dvs_stat,
-			 asd->params.curr_grid_info.s3a_grid.width,
-			 asd->params.curr_grid_info.s3a_grid.height);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int atomisp_alloc_3a_output_buf(struct atomisp_sub_device *asd)
-{
-	asd->params.s3a_user_stat = ia_css_3a_statistics_allocate(
-				&asd->params.curr_grid_info.s3a_grid);
-	if (!asd->params.s3a_user_stat)
-		return -ENOMEM;
-	/* 3A statistics. These can be big, so we use vmalloc. */
-	asd->params.s3a_output_bytes =
-	    asd->params.curr_grid_info.s3a_grid.width *
-	    asd->params.curr_grid_info.s3a_grid.height *
-	    sizeof(*asd->params.s3a_user_stat->data);
-
-	asd->params.s3a_buf_data_valid = false;
-
-	return 0;
-}
-
-int atomisp_alloc_dis_coef_buf(struct atomisp_sub_device *asd)
-{
-	if (!asd->params.curr_grid_info.dvs_grid.enable) {
-		dev_err(asd->isp->dev, "%s: dvs_grid not enabled.\n", __func__);
-		return 0;
-	}
-
-	/* DIS coefficients. */
-	asd->params.dvs_coeff = ia_css_dvs2_coefficients_allocate(
-				&asd->params.curr_grid_info.dvs_grid);
-	if (!asd->params.dvs_coeff)
-		return -ENOMEM;
-
-	asd->params.dvs_hor_coef_bytes =
-		asd->params.curr_grid_info.dvs_grid.num_hor_coefs *
-		sizeof(*asd->params.dvs_coeff->hor_coefs.odd_real);
-
-	asd->params.dvs_ver_coef_bytes =
-		asd->params.curr_grid_info.dvs_grid.num_ver_coefs *
-		sizeof(*asd->params.dvs_coeff->ver_coefs.odd_real);
-
-	/* DIS projections. */
-	asd->params.dis_proj_data_valid = false;
-	asd->params.dvs_stat = ia_css_dvs2_statistics_allocate(
-				&asd->params.curr_grid_info.dvs_grid);
-	if (!asd->params.dvs_stat)
-		return -ENOMEM;
-
-	asd->params.dvs_hor_proj_bytes =
-		asd->params.curr_grid_info.dvs_grid.aligned_height *
-		asd->params.curr_grid_info.dvs_grid.aligned_width *
-		sizeof(*asd->params.dvs_stat->hor_prod.odd_real);
-
-	asd->params.dvs_ver_proj_bytes =
-		asd->params.curr_grid_info.dvs_grid.aligned_height *
-		asd->params.curr_grid_info.dvs_grid.aligned_width *
-		sizeof(*asd->params.dvs_stat->ver_prod.odd_real);
-
-	return 0;
-}
-
-int atomisp_css_get_3a_statistics(struct atomisp_sub_device *asd,
-				  struct atomisp_css_buffer *isp_css_buffer)
-{
-	if (asd->params.s3a_user_stat && asd->params.s3a_output_bytes) {
-		/* To avoid racing with atomisp_3a_stat() */
-		ia_css_get_3a_statistics(asd->params.s3a_user_stat,
-				 isp_css_buffer->css_buffer.data.stats_3a);
-		asd->params.s3a_buf_data_valid = true;
-	}
-
-	return 0;
-}
-
-void atomisp_css_get_dis_statistics(struct atomisp_sub_device *asd,
-				    struct atomisp_css_buffer *isp_css_buffer)
-{
-	if (asd->params.dvs_stat) {
-		ia_css_get_dvs2_statistics(asd->params.dvs_stat,
-				  isp_css_buffer->css_buffer.data.stats_dvs);
-		asd->params.exp_id = isp_css_buffer->css_buffer.exp_id;
-		asd->params.dis_proj_data_valid = true;
-	}
-}
-
-int atomisp_css_dequeue_event(struct atomisp_css_event *current_event)
-{
-	if (ia_css_dequeue_event(&current_event->event) != IA_CSS_SUCCESS)
-		return -EINVAL;
-
-	return 0;
-}
-
-void atomisp_css_temp_pipe_to_pipe_id(struct atomisp_css_event *current_event)
-{
-	ia_css_temp_pipe_to_pipe_id(current_event->event.pipe,
-						&current_event->pipe);
-}
-
-int atomisp_css_input_set_resolution(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				struct v4l2_mbus_framefmt *ffmt)
-{
-	asd->stream_env[stream_id]
-	    .stream_config.input_res.width = ffmt->width;
-	asd->stream_env[stream_id]
-	    .stream_config.input_res.height = ffmt->height;
-	return 0;
-}
-
-void atomisp_css_input_set_binning_factor(struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					unsigned int bin_factor)
-{
-	asd->stream_env[stream_id]
-	    .stream_config.sensor_binning_factor = bin_factor;
-}
-
-void atomisp_css_input_set_bayer_order(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_bayer_order bayer_order)
-{
-	asd->stream_env[stream_id]
-	    .stream_config.bayer_order = bayer_order;
-}
-
-void atomisp_css_input_set_format(struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					enum atomisp_css_stream_format format)
-{
-	asd->stream_env[stream_id]
-	    .stream_config.format = format;
-}
-
-int atomisp_css_input_set_effective_resolution(
-					struct atomisp_sub_device *asd,
-					enum atomisp_input_stream_id stream_id,
-					unsigned int width, unsigned int height)
-{
-	asd->stream_env[stream_id]
-	    .stream_config.effective_res.width = width;
-	asd->stream_env[stream_id]
-	    .stream_config.effective_res.height = height;
-
-	return 0;
-}
-
-void atomisp_css_video_set_dis_envelope(struct atomisp_sub_device *asd,
-					unsigned int dvs_w, unsigned int dvs_h)
-{
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.width = dvs_w;
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.pipe_configs[IA_CSS_PIPE_ID_VIDEO].dvs_envelope.height = dvs_h;
-}
-
-void atomisp_css_input_set_two_pixels_per_clock(
-					struct atomisp_sub_device *asd,
-					bool two_ppc)
-{
-	int i;
-
-	if (asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.stream_config.two_pixels_per_clock == !!two_ppc)
-		return;
-
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.stream_config.two_pixels_per_clock = !!two_ppc;
-	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.update_pipe[i] = true;
-}
-
-void atomisp_css_enable_raw_binning(struct atomisp_sub_device *asd,
-					bool enable)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	unsigned int pipe;
-
-	if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-		pipe = IA_CSS_PIPE_ID_VIDEO;
-	else
-		pipe = IA_CSS_PIPE_ID_PREVIEW;
-
-	stream_env->pipe_extra_configs[pipe].enable_raw_binning = enable;
-	stream_env->update_pipe[pipe] = true;
-	if (enable) {
-#ifndef CSS21
-		stream_env->pipe_configs[pipe].bin_out_res.width =
-		    stream_env->stream_config.effective_res.width;
-		stream_env->pipe_configs[pipe].bin_out_res.height =
-		    stream_env->stream_config.effective_res.height;
-#endif /* CSS21 */
-		stream_env->pipe_configs[pipe].output_info.padded_width =
-		    stream_env->stream_config.effective_res.width;
-	}
-}
-
-void atomisp_css_enable_dz(struct atomisp_sub_device *asd, bool enable)
-{
-	int i;
-	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-#ifdef CSS21
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-			.pipe_configs[i].enable_dz = enable;
-#else
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-			.pipe_extra_configs[i].enable_dz = enable;
-#endif
-}
-
-void atomisp_css_capture_set_mode(struct atomisp_sub_device *asd,
-				enum atomisp_css_capture_mode mode)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-
-	if (stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
-		.default_capture_config.mode == mode)
-		return;
-
-	stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].
-					default_capture_config.mode = mode;
-	stream_env->update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
-}
-
-void atomisp_css_input_set_mode(struct atomisp_sub_device *asd,
-				enum atomisp_css_input_mode mode)
-{
-	int i;
-	struct atomisp_device *isp = asd->isp;
-	unsigned int size_mem_words, total_size_mem_words = 0;
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++)
-		asd->stream_env[i].stream_config.mode = mode;
-
-	if (isp->inputs[asd->input_curr].type == TEST_PATTERN) {
-		struct ia_css_stream_config *s_config =
-		    &asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream_config;
-		s_config->mode = IA_CSS_INPUT_MODE_TPG;
-		s_config->source.tpg.mode = IA_CSS_TPG_MODE_CHECKERBOARD;
-		s_config->source.tpg.x_mask = (1 << 4) - 1;
-		s_config->source.tpg.x_delta = -2;
-		s_config->source.tpg.y_mask = (1 << 4) - 1;
-		s_config->source.tpg.y_delta = 3;
-		s_config->source.tpg.xy_mask = (1 << 8) - 1;
-		return;
-	}
-
-	if (mode != IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
-		return;
-
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		/*
-		 * TODO: sensor needs to export the embedded_data_size_words
-		 * information to atomisp for each setting.
-		 * Here using a large safe value.
-		 */
-		struct ia_css_stream_config *s_config =
-			&asd->stream_env[i].stream_config;
-		if (s_config->input_res.width == 0)
-			continue;
-		if (ia_css_mipi_frame_calculate_size(s_config->input_res.width,
-					s_config->input_res.height,
-					s_config->format,
-					true,
-					0x13000,
-					&size_mem_words) != IA_CSS_SUCCESS) {
-			if (intel_mid_identify_cpu() ==
-				INTEL_MID_CPU_CHIP_TANGIER)
-				size_mem_words = CSS_MIPI_FRAME_BUFFER_SIZE_2;
-			else
-				size_mem_words = CSS_MIPI_FRAME_BUFFER_SIZE_1;
-			dev_warn(asd->isp->dev,
-				"ia_css_mipi_frame_calculate_size failed,"
-				"applying pre-defined MIPI buffer size %u.\n",
-				size_mem_words);
-		}
-		total_size_mem_words += size_mem_words;
-	}
-
-	if (total_size_mem_words > asd->isp->mipi_frame_size)
-		asd->isp->mipi_frame_size = size_mem_words;
-
-	asd->mipi_frame_size = asd->isp->mipi_frame_size;
-
-	ia_css_mipi_frame_specify(asd->isp->mipi_frame_size, false);
-}
-
-void atomisp_css_capture_enable_online(struct atomisp_sub_device *asd,
-							bool enable)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-
-	if (stream_env->stream_config.online == !!enable)
-		return;
-
-	stream_env->stream_config.online = !!enable;
-	stream_env->update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
-}
-
-void atomisp_css_preview_enable_online(struct atomisp_sub_device *asd,
-							bool enable)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	int i;
-
-	if (stream_env->stream_config.online != !!enable) {
-		stream_env->stream_config.online = !!enable;
-		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-			stream_env->update_pipe[i] = true;
-	}
-}
-
-void atomisp_css_enable_continuous(struct atomisp_sub_device *asd,
-							bool enable)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	int i;
-
-	if (stream_env->stream_config.continuous != !!enable) {
-		stream_env->stream_config.continuous = !!enable;
-#ifdef CSS21
-		stream_env->stream_config.pack_raw_pixels = true;
-#endif
-		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-			stream_env->update_pipe[i] = true;
-	}
-}
-
-void atomisp_css_enable_cont_capt(bool enable, bool stop_copy_preview)
-{
-	sh_css_enable_cont_capt(enable, stop_copy_preview);
-}
-
-int atomisp_css_input_configure_port(struct atomisp_sub_device *asd,
-					mipi_port_ID_t port,
-					unsigned int num_lanes,
-					unsigned int timeout)
-{
-	int i;
-	struct atomisp_stream_env *stream_env;
-	for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-		stream_env = &asd->stream_env[i];
-		stream_env->stream_config.source.port.port = port;
-		stream_env->stream_config.source.port.num_lanes = num_lanes;
-		stream_env->stream_config.source.port.timeout = timeout;
-	}
-
-	return 0;
-}
-
-int atomisp_css_frame_allocate(struct atomisp_css_frame **frame,
-				unsigned int width, unsigned int height,
-				enum atomisp_css_frame_format format,
-				unsigned int padded_width,
-				unsigned int raw_bit_depth)
-{
-	if (ia_css_frame_allocate(frame, width, height, format,
-			padded_width, raw_bit_depth) != IA_CSS_SUCCESS)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int atomisp_css_frame_allocate_from_info(struct atomisp_css_frame **frame,
-				const struct atomisp_css_frame_info *info)
-{
-	if (ia_css_frame_allocate_from_info(frame, info) != IA_CSS_SUCCESS)
-		return -ENOMEM;
-
-	return 0;
-}
-
-void atomisp_css_frame_free(struct atomisp_css_frame *frame)
-{
-	ia_css_frame_free(frame);
-}
-
-int atomisp_css_frame_map(struct atomisp_css_frame **frame,
-				const struct atomisp_css_frame_info *info,
-				const void *data, uint16_t attribute,
-				void *context)
-{
-	if (ia_css_frame_map(frame, info, data, attribute, context)
-	    != IA_CSS_SUCCESS)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int atomisp_css_set_black_frame(struct atomisp_sub_device *asd,
-				const struct atomisp_css_frame *raw_black_frame)
-{
-	if (sh_css_set_black_frame(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		raw_black_frame) != IA_CSS_SUCCESS)
-		return -ENOMEM;
-
-	return 0;
-}
-
-int atomisp_css_allocate_continuous_frames(bool init_time,
-				struct atomisp_sub_device *asd)
-{
-	if (ia_css_alloc_continuous_frame_remain(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream)
-			!= IA_CSS_SUCCESS)
-		return -EINVAL;
-	return 0;
-}
-
-void atomisp_css_update_continuous_frames(struct atomisp_sub_device *asd)
-{
-	ia_css_update_continuous_frames(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream);
-}
-
-int atomisp_css_stop(struct atomisp_sub_device *asd,
-			enum atomisp_css_pipe_id pipe_id, bool in_reset)
-{
-	struct atomisp_device *isp = asd->isp;
-	/* if is called in atomisp_reset(), force destroy stream */
-	if (__destroy_streams(asd, true))
-		dev_err(isp->dev, "destroy stream failed.\n");
-
-	/* if is called in atomisp_reset(), force destroy all pipes */
-	if (__destroy_pipes(asd, true))
-		dev_err(isp->dev, "destroy pipes failed.\n");
-	/*
-	 * SP can not be stop if other streams are in use
-	 */
-	if (atomisp_streaming_count(isp)) {
-		dev_dbg(isp->dev, "skip stop sp\n");
-	} else if (ia_css_isp_has_started() &&
-		   (ia_css_stop_sp() != IA_CSS_SUCCESS)) {
-		dev_err(isp->dev, "stop sp failed. stop css fatal error.\n");
-		return -EINVAL;
-	}
-
-	if (!in_reset) {
-		struct atomisp_stream_env *stream_env;
-		int i, j;
-		for (i = 0; i < ATOMISP_INPUT_STREAM_NUM; i++) {
-			stream_env = &asd->stream_env[i];
-			for (j = 0; j < IA_CSS_PIPE_ID_NUM; j++) {
-				ia_css_pipe_config_defaults(
-					&stream_env->pipe_configs[j]);
-				ia_css_pipe_extra_config_defaults(
-					&stream_env->pipe_extra_configs[j]);
-			}
-			ia_css_stream_config_defaults(
-				&stream_env->stream_config);
-		}
-		atomisp_isp_parameters_clean_up(&asd->params.config);
-		asd->params.css_update_params_needed = false;
-	}
-
-	return 0;
-}
-
-int atomisp_css_continuous_set_num_raw_frames(
-					struct atomisp_sub_device *asd,
-					int num_frames)
-{
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.stream_config.init_num_cont_raw_buf =
-		ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES;
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.stream_config.target_num_cont_raw_buf = num_frames;
-	return 0;
-}
-
-void atomisp_css_disable_vf_pp(struct atomisp_sub_device *asd,
-			       bool disable)
-{
-	int i;
-
-	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.pipe_extra_configs[i].disable_vf_pp = !!disable;
-}
-
-static enum ia_css_pipe_mode __pipe_id_to_pipe_mode(
-					enum ia_css_pipe_id pipe_id)
-{
-	switch (pipe_id) {
-#ifdef CSS21
-	case IA_CSS_PIPE_ID_COPY:
-		return IA_CSS_PIPE_MODE_COPY;
-#endif
-	case IA_CSS_PIPE_ID_PREVIEW:
-		return IA_CSS_PIPE_MODE_PREVIEW;
-	case IA_CSS_PIPE_ID_CAPTURE:
-		return IA_CSS_PIPE_MODE_CAPTURE;
-	case IA_CSS_PIPE_ID_VIDEO:
-		return IA_CSS_PIPE_MODE_VIDEO;
-	case IA_CSS_PIPE_ID_ACC:
-		return IA_CSS_PIPE_MODE_ACC;
-	default:
-		WARN_ON(1);
-		return IA_CSS_PIPE_MODE_PREVIEW;
-	}
-
-}
-
-static void __configure_output(struct atomisp_sub_device *asd,
-			       unsigned int stream_index,
-			       unsigned int width, unsigned int height,
-			       unsigned int min_width,
-			       enum ia_css_frame_format format,
-			       enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[stream_index];
-
-	stream_env->pipe_configs[pipe_id].mode =
-		__pipe_id_to_pipe_mode(pipe_id);
-	stream_env->update_pipe[pipe_id] = true;
-
-	stream_env->pipe_configs[pipe_id].output_info.res.width = width;
-	stream_env->pipe_configs[pipe_id].output_info.res.height = height;
-	stream_env->pipe_configs[pipe_id].output_info.format = format;
-	stream_env->pipe_configs[pipe_id].output_info.padded_width = min_width;
-
-	/* isp binary 2.2 specific setting*/
-	if (width > stream_env->stream_config.effective_res.width ||
-	    height > stream_env->stream_config.effective_res.height) {
-		stream_env->stream_config.effective_res.width = width;
-		stream_env->stream_config.effective_res.height = height;
-	}
-
-	dev_dbg(isp->dev, "configuring pipe[%d] output info w=%d.h=%d.f=%d.\n",
-		pipe_id, width, height, format);
-}
-
-/*
- * CSS2.1 and Old CSS2.0 has different parameters for pp input configuration.
- */
-#ifndef CSS21
-/*
- * For old CSS2.0, preview pipe and capture pipe all use bayer_ds_out_res to
- * configure YUV Downscaling input resolution
- */
-static void __configure_pp_input(struct atomisp_sub_device *asd,
-				 unsigned int width, unsigned int height,
-				 enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	if (width == 0 && height == 0)
-		return;
-
-	if (width * 9 / 10 <
-	    stream_env->pipe_configs[pipe_id].
-	    output_info.res.width ||
-	    height * 9 / 10 <
-	    stream_env->pipe_configs[pipe_id].
-	    output_info.res.height
-	   )
-		return;
-	stream_env->pipe_configs[pipe_id].mode =
-					__pipe_id_to_pipe_mode(pipe_id);
-	stream_env->update_pipe[pipe_id] = true;
-
-	stream_env->pipe_extra_configs[pipe_id].enable_yuv_ds = true;
-	stream_env->pipe_configs[pipe_id].bayer_ds_out_res.width =
-	    stream_env->stream_config.effective_res.width;
-	stream_env->pipe_configs[pipe_id].bayer_ds_out_res.height =
-	    stream_env->stream_config.effective_res.height;
-	dev_dbg(isp->dev, "configuring pipe[%d]capture pp input w=%d.h=%d.\n",
-		pipe_id, width, height);
-}
-#else
-/*
- * For CSS2.1, capture pipe uses capture_pp_in_res to configure yuv
- * downscaling input resolution.
- */
-static void __configure_capture_pp_input(struct atomisp_sub_device *asd,
-				 unsigned int width, unsigned int height,
-				 enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	struct ia_css_stream_config *stream_config = &stream_env->stream_config;
-	struct ia_css_pipe_config *pipe_configs =
-		&stream_env->pipe_configs[pipe_id];
-	struct ia_css_pipe_extra_config *pipe_extra_configs =
-		&stream_env->pipe_extra_configs[pipe_id];
-
-	if (width == 0 && height == 0)
-		return;
-
-	if (width * 9 / 10 < pipe_configs->output_info.res.width ||
-	    height * 9 / 10 < pipe_configs->output_info.res.height)
-		return;
-
-	pipe_configs->mode = __pipe_id_to_pipe_mode(pipe_id);
-	stream_env->update_pipe[pipe_id] = true;
-
-	pipe_extra_configs->enable_yuv_ds = true;
-	pipe_configs->capt_pp_in_res.width = stream_config->effective_res.width;
-	pipe_configs->capt_pp_in_res.height =
-		stream_config->effective_res.height;
-	dev_dbg(isp->dev, "configuring pipe[%d]capture pp input w=%d.h=%d.\n",
-		pipe_id, width, height);
-}
-
-/*
- * For CSS2.1, preview pipe could support bayer decimation, yuv decimation and
- * yuv downscaling, which needs addtional configurations.
- */
-static void __configure_preview_pp_input(struct atomisp_sub_device *asd,
-				 unsigned int width, unsigned int height,
-				 enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	int out_width, out_height;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	struct ia_css_stream_config *stream_config = &stream_env->stream_config;
-	struct ia_css_pipe_config *pipe_configs =
-		&stream_env->pipe_configs[pipe_id];
-	struct ia_css_pipe_extra_config *pipe_extra_configs =
-		&stream_env->pipe_extra_configs[pipe_id];
-	struct ia_css_resolution *vf_pp_in_res =
-		&pipe_configs->vf_pp_in_res;
-	struct ia_css_resolution  *effective_res =
-		&stream_config->effective_res;
-
-	if (width == 0 && height == 0)
-		return;
-
-	if (width * 9 / 10 < pipe_configs->output_info.res.width ||
-	    height * 9 / 10 < pipe_configs->output_info.res.height)
-		return;
-	pipe_configs->mode = __pipe_id_to_pipe_mode(pipe_id);
-	stream_env->update_pipe[pipe_id] = true;
-
-	pipe_extra_configs->enable_yuv_ds = true;
-
-	out_width = pipe_configs->output_info.res.width;
-	out_height = pipe_configs->output_info.res.height;
-
-	vf_pp_in_res->width = effective_res->width;
-	vf_pp_in_res->height = effective_res->height;
-
-	dev_dbg(isp->dev, "configuring pipe[%d]capture pp input w=%d.h=%d.\n",
-		pipe_id, width, height);
-}
-
-/*
- * For CSS2.1, offline video pipe could support bayer decimation, and
- * yuv downscaling, which needs addtional configurations.
- */
-static void __configure_video_pp_input(struct atomisp_sub_device *asd,
-				 unsigned int width, unsigned int height,
-				 enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	int out_width, out_height;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	struct ia_css_stream_config *stream_config = &stream_env->stream_config;
-	struct ia_css_pipe_config *pipe_configs =
-		&stream_env->pipe_configs[pipe_id];
-	struct ia_css_pipe_extra_config *pipe_extra_configs =
-		&stream_env->pipe_extra_configs[pipe_id];
-	struct ia_css_resolution *bayer_ds_out_res =
-		&pipe_configs->bayer_ds_out_res;
-	struct ia_css_resolution  *effective_res =
-		&stream_config->effective_res;
-	const struct bayer_ds_factor bds_factors[] = {
-		{8, 1}, {4, 1}, {2, 1}, {3, 2}, {5, 4} };
-	unsigned int i;
-
-	if (width == 0 && height == 0)
-		return;
-
-	if (width * 9 / 10 < pipe_configs->output_info.res.width ||
-	    height * 9 / 10 < pipe_configs->output_info.res.height)
-		return;
-
-	pipe_configs->mode = __pipe_id_to_pipe_mode(pipe_id);
-	stream_env->update_pipe[pipe_id] = true;
-
-	pipe_extra_configs->enable_yuv_ds = false;
-
-	/*
-	 * If DVS is enabled,  video binary will take care the dvs envelope
-	 * and usually the bayer_ds_out_res should be larger than 120% of
-	 * destination resolution, the extra 20% will be cropped as DVS
-	 * envelope. But,  if the bayer_ds_out_res is less than 120% of the
-	 * destination. The ISP can still work,  but DVS quality is not good.
-	 */
-	/* taking at least 18% as envelope */
-	if (asd->params.video_dis_en) {
-		out_width = pipe_configs->output_info.res.width * 118 / 100;
-		out_height = pipe_configs->output_info.res.height * 118 / 100;
-	} else {
-		out_width = pipe_configs->output_info.res.width;
-		out_height = pipe_configs->output_info.res.height;
-	}
-
-	/*
-	 * calculate bayer decimate factor:
-	 * 1: only 1.25, 1.5, 2, 4 and 8 get supported
-	 * 2: Do not configure bayer_ds_out_res if:
-	 *    online == 1 or continuous == 0 or raw_binning = 0
-	 */
-	if (stream_config->online || !stream_config->continuous ||
-	    !pipe_extra_configs->enable_raw_binning) {
-		bayer_ds_out_res->width = 0;
-		bayer_ds_out_res->height = 0;
-		goto done;
-	}
-
-	bayer_ds_out_res->width = effective_res->width;
-	bayer_ds_out_res->height = effective_res->height;
-
-	for (i = 0; i < sizeof(bds_factors) / sizeof(struct bayer_ds_factor);
-	     i++) {
-		if (effective_res->width >= out_width *
-		    bds_factors[i].numerator / bds_factors[i].denominator &&
-		    effective_res->height >= out_height *
-		    bds_factors[i].numerator / bds_factors[i].denominator) {
-			bayer_ds_out_res->width = effective_res->width *
-			    bds_factors[i].denominator /
-			    bds_factors[i].numerator;
-			bayer_ds_out_res->height = effective_res->height *
-			    bds_factors[i].denominator /
-			    bds_factors[i].numerator;
-			break;
-		}
-	}
-
-done:
-	stream_config->left_padding = 12;
-	dev_dbg(isp->dev, "configuring pipe[%d]video pp input w=%d.h=%d.\n",
-		pipe_id, width, height);
-}
-#endif
-
-static void __configure_vf_output(struct atomisp_sub_device *asd,
-				  unsigned int width, unsigned int height,
-				  unsigned int min_width,
-				  enum atomisp_css_frame_format format,
-				  enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	stream_env->pipe_configs[pipe_id].mode =
-					__pipe_id_to_pipe_mode(pipe_id);
-	stream_env->update_pipe[pipe_id] = true;
-
-	stream_env->pipe_configs[pipe_id].vf_output_info.res.width = width;
-	stream_env->pipe_configs[pipe_id].vf_output_info.res.height = height;
-	stream_env->pipe_configs[pipe_id].vf_output_info.format = format;
-	stream_env->pipe_configs[pipe_id].vf_output_info.padded_width =
-		min_width;
-	dev_dbg(isp->dev,
-		"configuring pipe[%d] vf output info w=%d.h=%d.f=%d.\n",
-		 pipe_id, width, height, format);
-}
-
-static int __get_frame_info(struct atomisp_sub_device *asd,
-				unsigned int stream_index,
-				struct atomisp_css_frame_info *info,
-				enum frame_info_type type,
-				enum ia_css_pipe_id pipe_id)
-{
-	struct atomisp_device *isp = asd->isp;
-	enum ia_css_err ret;
-	struct ia_css_pipe_info p_info;
-
-	/* FIXME! No need to destroy/recreate all streams */
-	if (__destroy_streams(asd, true))
-		dev_warn(isp->dev, "destroy stream failed.\n");
-
-	if (__destroy_pipes(asd, true))
-		dev_warn(isp->dev, "destroy pipe failed.\n");
-
-	if (__create_pipes(asd))
-		return -EINVAL;
-
-	if (__create_streams(asd))
-		goto stream_err;
-
-	ret = ia_css_pipe_get_info(
-		asd->stream_env[stream_index]
-		.pipes[pipe_id], &p_info);
-	if (ret == IA_CSS_SUCCESS) {
-		switch (type) {
-		case ATOMISP_CSS_VF_FRAME:
-			*info = p_info.vf_output_info;
-			dev_dbg(isp->dev, "getting vf frame info.\n");
-			break;
-		case ATOMISP_CSS_OUTPUT_FRAME:
-			*info = p_info.output_info;
-			dev_dbg(isp->dev, "getting main frame info.\n");
-			break;
-		case ATOMISP_CSS_RAW_FRAME:
-			*info = p_info.raw_output_info;
-			dev_dbg(isp->dev, "getting raw frame info.\n");
-		}
-		dev_dbg(isp->dev, "get frame info: w=%d, h=%d.\n",
-			info->res.width, info->res.height);
-		return 0;
-	}
-
-stream_err:
-	__destroy_pipes(asd, true);
-	return -EINVAL;
-}
-
-unsigned int atomisp_get_pipe_index(struct atomisp_sub_device *asd,
-					uint16_t source_pad)
-{
-	struct atomisp_device *isp = asd->isp;
-	if (isp->inputs[asd->input_curr].camera_caps->
-			sensor[asd->sensor_curr].stream_num > 1)
-		return IA_CSS_PIPE_ID_COPY;
-
-	switch (source_pad) {
-	case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO:
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO
-		    || asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER)
-			return IA_CSS_PIPE_ID_VIDEO;
-		else
-			return IA_CSS_PIPE_ID_CAPTURE;
-	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
-		return IA_CSS_PIPE_ID_CAPTURE;
-	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
-		if (!atomisp_is_mbuscode_raw(
-		    asd->fmt[asd->capture_pad].fmt.code))
-			return IA_CSS_PIPE_ID_CAPTURE;
-	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-			return IA_CSS_PIPE_ID_VIDEO;
-		else
-			return IA_CSS_PIPE_ID_PREVIEW;
-	}
-
-	dev_warn(isp->dev,
-		 "invalid source pad:%d, return default preview pipe index.\n",
-		 source_pad);
-	return IA_CSS_PIPE_ID_PREVIEW;
-}
-
-int atomisp_get_css_frame_info(struct atomisp_sub_device *asd,
-				uint16_t source_pad,
-				struct atomisp_css_frame_info *frame_info)
-{
-	struct ia_css_pipe_info info;
-	int pipe_index = atomisp_get_pipe_index(asd, source_pad);
-	int stream_index = atomisp_source_pad_to_stream_id(asd, source_pad);
-
-	ia_css_pipe_get_info(asd->stream_env[stream_index]
-		.pipes[pipe_index], &info);
-	switch (source_pad) {
-	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
-	case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO:
-		*frame_info = info.output_info;
-		break;
-	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
-		if (stream_index == ATOMISP_INPUT_STREAM_POSTVIEW)
-			*frame_info = info.output_info;
-		else
-			*frame_info = info.vf_output_info;
-		break;
-	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-			*frame_info = info.vf_output_info;
-		else
-			*frame_info = info.output_info;
-		break;
-	default:
-		frame_info = NULL;
-		break;
-	}
-	return frame_info ? 0 : -EINVAL;
-}
-
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-int atomisp_css_copy_configure_output(struct atomisp_sub_device *asd,
-				unsigned int stream_index,
-				unsigned int width, unsigned int height,
-				enum atomisp_css_frame_format format)
-{
-	asd->stream_env[stream_index].pipe_configs[IA_CSS_PIPE_ID_COPY].
-					default_capture_config.mode =
-					CSS_CAPTURE_MODE_RAW;
-
-	__configure_output(asd, stream_index, width, height, width, format,
-			   IA_CSS_PIPE_ID_COPY);
-	return 0;
-}
-#endif
-
-int atomisp_css_preview_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,
-			   min_width, format, IA_CSS_PIPE_ID_PREVIEW);
-	return 0;
-}
-
-int atomisp_css_capture_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,
-			   min_width, format, IA_CSS_PIPE_ID_CAPTURE);
-	return 0;
-}
-
-int atomisp_css_video_configure_output(struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	__configure_output(asd, ATOMISP_INPUT_STREAM_GENERAL, width, height,
-			   min_width, format, IA_CSS_PIPE_ID_VIDEO);
-	return 0;
-}
-
-int atomisp_css_video_configure_viewfinder(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	__configure_vf_output(asd, width, height, min_width, format,
-			      IA_CSS_PIPE_ID_VIDEO);
-	return 0;
-}
-
-int atomisp_css_capture_configure_viewfinder(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height,
-				unsigned int min_width,
-				enum atomisp_css_frame_format format)
-{
-	__configure_vf_output(asd, width, height, min_width, format,
-			      IA_CSS_PIPE_ID_CAPTURE);
-	return 0;
-}
-
-int atomisp_css_video_get_viewfinder_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-			ATOMISP_CSS_VF_FRAME, IA_CSS_PIPE_ID_VIDEO);
-}
-
-int atomisp_css_capture_get_viewfinder_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-			ATOMISP_CSS_VF_FRAME, IA_CSS_PIPE_ID_CAPTURE);
-}
-
-int atomisp_css_capture_get_output_raw_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-			ATOMISP_CSS_RAW_FRAME, IA_CSS_PIPE_ID_CAPTURE);
-}
-
-#if defined(CSS21) && defined(ISP2401_NEW_INPUT_SYSTEM)
-int atomisp_css_copy_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					unsigned int stream_index,
-					struct atomisp_css_frame_info *info)
-{
-	return __get_frame_info(asd, stream_index, info,
-			ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_COPY);
-}
-#endif
-
-int atomisp_css_preview_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-			ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_PREVIEW);
-}
-
-int atomisp_css_capture_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-			ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_CAPTURE);
-}
-
-int atomisp_css_video_get_output_frame_info(
-					struct atomisp_sub_device *asd,
-					struct atomisp_css_frame_info *info)
-{
-	return __get_frame_info(asd, ATOMISP_INPUT_STREAM_GENERAL, info,
-			ATOMISP_CSS_OUTPUT_FRAME, IA_CSS_PIPE_ID_VIDEO);
-}
-
-int atomisp_css_preview_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-#ifdef CSS21
-	__configure_preview_pp_input(asd, width, height,
-			IA_CSS_PIPE_ID_PREVIEW);
-
-	if (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].
-					capt_pp_in_res.width)
-		__configure_capture_pp_input(asd,
-				     width, height, IA_CSS_PIPE_ID_CAPTURE);
-#else
-	if (stream_env->pipe_extra_configs[IA_CSS_PIPE_ID_PREVIEW].
-					enable_raw_binning == false)
-		__configure_pp_input(asd, width, height,
-					IA_CSS_PIPE_ID_PREVIEW);
-
-	if (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].
-					bayer_ds_out_res.width)
-		__configure_pp_input(asd,
-				     width, height, IA_CSS_PIPE_ID_CAPTURE);
-#endif
-	return 0;
-}
-
-int atomisp_css_capture_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height)
-{
-#ifdef CSS21
-	__configure_capture_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);
-#else
-	__configure_pp_input(asd, width, height, IA_CSS_PIPE_ID_CAPTURE);
-#endif
-	return 0;
-}
-
-int atomisp_css_video_configure_pp_input(
-				struct atomisp_sub_device *asd,
-				unsigned int width, unsigned int height)
-{
-#ifdef CSS21
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-
-	__configure_video_pp_input(asd, width, height,
-			IA_CSS_PIPE_ID_VIDEO);
-
-	if (width > stream_env->pipe_configs[IA_CSS_PIPE_ID_CAPTURE].
-					capt_pp_in_res.width)
-		__configure_capture_pp_input(asd,
-				     width, height, IA_CSS_PIPE_ID_CAPTURE);
-#endif
-	return 0;
-}
-
-int atomisp_css_offline_capture_configure(struct atomisp_sub_device *asd,
-			int num_captures, unsigned int skip, int offset)
-{
-	enum ia_css_err ret;
-
-	ret = ia_css_stream_capture(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		num_captures, skip, offset);
-	if (ret != IA_CSS_SUCCESS)
-		return -EINVAL;
-
-	return 0;
-}
-
-int atomisp_css_capture_enable_xnr(struct atomisp_sub_device *asd,
-				   bool enable)
-{
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.pipe_configs[IA_CSS_PIPE_ID_CAPTURE]
-		.default_capture_config.enable_xnr = enable;
-	asd->params.capture_config.enable_xnr = enable;
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.update_pipe[IA_CSS_PIPE_ID_CAPTURE] = true;
-
-	return 0;
-}
-
-void atomisp_css_send_input_frame(struct atomisp_sub_device *asd,
-				  unsigned short *data, unsigned int width,
-				  unsigned int height)
-{
-	ia_css_stream_send_input_frame(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		data, width, height);
-}
-
-bool atomisp_css_isp_has_started(void)
-{
-	return ia_css_isp_has_started();
-}
-
-void atomisp_css_request_flash(struct atomisp_sub_device *asd)
-{
-	ia_css_stream_request_flash(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream);
-}
-
-void atomisp_css_set_wb_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_wb_config *wb_config)
-{
-	asd->params.config.wb_config = wb_config;
-}
-
-void atomisp_css_set_ob_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ob_config *ob_config)
-{
-	asd->params.config.ob_config = ob_config;
-}
-
-void atomisp_css_set_dp_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_dp_config *dp_config)
-{
-	asd->params.config.dp_config = dp_config;
-}
-
-void atomisp_css_set_de_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_de_config *de_config)
-{
-	asd->params.config.de_config = de_config;
-}
-
-void atomisp_css_set_default_de_config(struct atomisp_sub_device *asd)
-{
-	asd->params.config.de_config = NULL;
-}
-
-void atomisp_css_set_ce_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ce_config *ce_config)
-{
-	asd->params.config.ce_config = ce_config;
-}
-
-void atomisp_css_set_nr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_nr_config *nr_config)
-{
-	asd->params.config.nr_config = nr_config;
-}
-
-void atomisp_css_set_ee_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ee_config *ee_config)
-{
-	asd->params.config.ee_config = ee_config;
-}
-
-void atomisp_css_set_tnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_tnr_config *tnr_config)
-{
-	asd->params.config.tnr_config = tnr_config;
-}
-
-void atomisp_css_set_cc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cc_config *cc_config)
-{
-	asd->params.config.cc_config = cc_config;
-}
-
-void atomisp_css_set_macc_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_macc_table *macc_table)
-{
-	asd->params.config.macc_table = macc_table;
-}
-
-void atomisp_css_set_macc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_macc_config *macc_config)
-{
-	asd->params.config.macc_config = macc_config;
-}
-
-void atomisp_css_set_ecd_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ecd_config *ecd_config)
-{
-	asd->params.config.ecd_config = ecd_config;
-}
-
-void atomisp_css_set_ynr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ynr_config *ynr_config)
-{
-	asd->params.config.ynr_config = ynr_config;
-}
-
-void atomisp_css_set_fc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_fc_config *fc_config)
-{
-	asd->params.config.fc_config = fc_config;
-}
-
-void atomisp_css_set_ctc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ctc_config *ctc_config)
-{
-	asd->params.config.ctc_config = ctc_config;
-}
-
-void atomisp_css_set_cnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cnr_config *cnr_config)
-{
-	asd->params.config.cnr_config = cnr_config;
-}
-
-void atomisp_css_set_aa_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_aa_config *aa_config)
-{
-	asd->params.config.aa_config = aa_config;
-}
-
-void atomisp_css_set_baa_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_baa_config *baa_config)
-{
-	asd->params.config.baa_config = baa_config;
-}
-
-void atomisp_css_set_anr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_anr_config *anr_config)
-{
-	asd->params.config.anr_config = anr_config;
-}
-
-void atomisp_css_set_xnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_xnr_config *xnr_config)
-{
-	asd->params.config.xnr_config = xnr_config;
-}
-
-void atomisp_css_set_yuv2rgb_cc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cc_config *yuv2rgb_cc_config)
-{
-	asd->params.config.yuv2rgb_cc_config = yuv2rgb_cc_config;
-}
-
-void atomisp_css_set_rgb2yuv_cc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cc_config *rgb2yuv_cc_config)
-{
-	asd->params.config.rgb2yuv_cc_config = rgb2yuv_cc_config;
-}
-
-void atomisp_css_set_xnr_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_xnr_table *xnr_table)
-{
-	asd->params.config.xnr_table = xnr_table;
-}
-
-void atomisp_css_set_r_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_rgb_gamma_table *r_gamma_table)
-{
-	asd->params.config.r_gamma_table = r_gamma_table;
-}
-
-void atomisp_css_set_g_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_rgb_gamma_table *g_gamma_table)
-{
-	asd->params.config.g_gamma_table = g_gamma_table;
-}
-
-void atomisp_css_set_b_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_rgb_gamma_table *b_gamma_table)
-{
-	asd->params.config.b_gamma_table = b_gamma_table;
-}
-
-void atomisp_css_set_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_gamma_table *gamma_table)
-{
-	asd->params.config.gamma_table = gamma_table;
-}
-
-void atomisp_css_set_ctc_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_ctc_table *ctc_table)
-{
-	int i;
-	uint16_t *vamem_ptr = ctc_table->data.vamem_1;
-	int data_size = IA_CSS_VAMEM_1_CTC_TABLE_SIZE;
-	bool valid = false;
-
-	/* workaround: if ctc_table is all 0, do not apply it */
-	if (ctc_table->vamem_type == IA_CSS_VAMEM_TYPE_2) {
-		vamem_ptr = ctc_table->data.vamem_2;
-		data_size = IA_CSS_VAMEM_2_CTC_TABLE_SIZE;
-	}
-
-	for (i = 0; i < data_size; i++) {
-		if (*(vamem_ptr + i)) {
-			valid = true;
-			break;
-		}
-	}
-
-	if (valid)
-		asd->params.config.ctc_table = ctc_table;
-	else
-		dev_warn(asd->isp->dev, "Bypass the invalid ctc_table.\n");
-}
-
-void atomisp_css_set_anr_thres(struct atomisp_sub_device *asd,
-			struct atomisp_css_anr_thres *anr_thres)
-{
-	asd->params.config.anr_thres = anr_thres;
-}
-
-void atomisp_css_set_dvs_6axis(struct atomisp_sub_device *asd,
-			struct atomisp_css_dvs_6axis *dvs_6axis)
-{
-	asd->params.config.dvs_6axis_config = dvs_6axis;
-}
-
-void atomisp_css_set_gc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_gc_config *gc_config)
-{
-	asd->params.config.gc_config = gc_config;
-}
-
-void atomisp_css_set_3a_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_3a_config *s3a_config)
-{
-	asd->params.config.s3a_config = s3a_config;
-}
-
-void atomisp_css_video_set_dis_vector(struct atomisp_sub_device *asd,
-				struct atomisp_dis_vector *vector)
-{
-	if (!asd->params.config.motion_vector)
-		asd->params.config.motion_vector = &asd->params.motion_vector;
-
-	memset(asd->params.config.motion_vector,
-			0, sizeof(struct ia_css_vector));
-	asd->params.motion_vector.x = vector->x;
-	asd->params.motion_vector.y = vector->y;
-}
-
-static int atomisp_compare_dvs_grid(struct atomisp_sub_device *asd,
-				struct atomisp_dvs_grid_info *atomgrid)
-{
-	struct atomisp_css_dvs_grid_info *cur =
-	    &asd->params.curr_grid_info.dvs_grid;
-
-	if (sizeof(*cur) != sizeof(*atomgrid)) {
-		dev_err(asd->isp->dev, "dvs grid mis-match!\n");
-		return -EINVAL;
-	}
-
-	if (!cur->enable) {
-		dev_err(asd->isp->dev, "dvs not enabled!\n");
-		return -EINVAL;
-	}
-
-	return memcmp(atomgrid, cur, sizeof(*cur));
-}
-
-int atomisp_css_set_dis_coefs(struct atomisp_sub_device *asd,
-			  struct atomisp_dis_coefficients *coefs)
-{
-	if (atomisp_compare_dvs_grid(asd, &coefs->grid_info) != 0)
-		/* If the grid info in the argument differs from the current
-		   grid info, we tell the caller to reset the grid size and
-		   try again. */
-		return -EAGAIN;
-
-	if (coefs->hor_coefs.odd_real == NULL ||
-	    coefs->hor_coefs.odd_imag == NULL ||
-	    coefs->hor_coefs.even_real == NULL ||
-	    coefs->hor_coefs.even_imag == NULL ||
-	    coefs->ver_coefs.odd_real == NULL ||
-	    coefs->ver_coefs.odd_imag == NULL ||
-	    coefs->ver_coefs.even_real == NULL ||
-	    coefs->ver_coefs.even_imag == NULL ||
-	    asd->params.dvs_coeff->hor_coefs.odd_real == NULL ||
-	    asd->params.dvs_coeff->hor_coefs.odd_imag == NULL ||
-	    asd->params.dvs_coeff->hor_coefs.even_real == NULL ||
-	    asd->params.dvs_coeff->hor_coefs.even_imag == NULL ||
-	    asd->params.dvs_coeff->ver_coefs.odd_real == NULL ||
-	    asd->params.dvs_coeff->ver_coefs.odd_imag == NULL ||
-	    asd->params.dvs_coeff->ver_coefs.even_real == NULL ||
-	    asd->params.dvs_coeff->ver_coefs.even_imag == NULL)
-		return -EINVAL;
-
-	if (copy_from_user(asd->params.dvs_coeff->hor_coefs.odd_real,
-	    coefs->hor_coefs.odd_real, asd->params.dvs_hor_coef_bytes))
-		return -EFAULT;
-	if (copy_from_user(asd->params.dvs_coeff->hor_coefs.odd_imag,
-	    coefs->hor_coefs.odd_imag, asd->params.dvs_hor_coef_bytes))
-		return -EFAULT;
-	if (copy_from_user(asd->params.dvs_coeff->hor_coefs.even_real,
-	    coefs->hor_coefs.even_real, asd->params.dvs_hor_coef_bytes))
-		return -EFAULT;
-	if (copy_from_user(asd->params.dvs_coeff->hor_coefs.even_imag,
-	    coefs->hor_coefs.even_imag, asd->params.dvs_hor_coef_bytes))
-		return -EFAULT;
-
-	if (copy_from_user(asd->params.dvs_coeff->ver_coefs.odd_real,
-	    coefs->ver_coefs.odd_real, asd->params.dvs_ver_coef_bytes))
-		return -EFAULT;
-	if (copy_from_user(asd->params.dvs_coeff->ver_coefs.odd_imag,
-	    coefs->ver_coefs.odd_imag, asd->params.dvs_ver_coef_bytes))
-		return -EFAULT;
-	if (copy_from_user(asd->params.dvs_coeff->ver_coefs.even_real,
-	    coefs->ver_coefs.even_real, asd->params.dvs_ver_coef_bytes))
-		return -EFAULT;
-	if (copy_from_user(asd->params.dvs_coeff->ver_coefs.even_imag,
-	    coefs->ver_coefs.even_imag, asd->params.dvs_ver_coef_bytes))
-		return -EFAULT;
-
-	asd->params.config.dvs2_coefs = asd->params.dvs_coeff;
-	/* FIXME! */
-/*	asd->params.dis_proj_data_valid = false; */
-	asd->params.css_update_params_needed = true;
-
-	return 0;
-}
-
-void atomisp_css_set_zoom_factor(struct atomisp_sub_device *asd,
-					unsigned int zoom)
-{
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->params.config.dz_config)
-		asd->params.config.dz_config = &asd->params.dz_config;
-
-	if (zoom == asd->params.config.dz_config->dx &&
-		 zoom == asd->params.config.dz_config->dy) {
-		dev_dbg(isp->dev, "same zoom scale. skipped.\n");
-		return;
-	}
-
-	memset(asd->params.config.dz_config, 0,
-		sizeof(struct ia_css_dz_config));
-	asd->params.dz_config.dx = zoom;
-	asd->params.dz_config.dy = zoom;
-}
-
-int atomisp_css_get_wb_config(struct atomisp_sub_device *asd,
-			struct atomisp_wb_config *config)
-{
-	struct atomisp_css_wb_config wb_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&wb_config, 0, sizeof(struct atomisp_css_wb_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.wb_config = &wb_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, &wb_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_ob_config(struct atomisp_sub_device *asd,
-			struct atomisp_ob_config *config)
-{
-	struct atomisp_css_ob_config ob_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&ob_config, 0, sizeof(struct atomisp_css_ob_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.ob_config = &ob_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, &ob_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_dp_config(struct atomisp_sub_device *asd,
-			struct atomisp_dp_config *config)
-{
-	struct atomisp_css_dp_config dp_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&dp_config, 0, sizeof(struct atomisp_css_dp_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.dp_config = &dp_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, &dp_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_de_config(struct atomisp_sub_device *asd,
-			struct atomisp_de_config *config)
-{
-	struct atomisp_css_de_config de_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&de_config, 0, sizeof(struct atomisp_css_de_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.de_config = &de_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, &de_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_nr_config(struct atomisp_sub_device *asd,
-			struct atomisp_nr_config *config)
-{
-	struct atomisp_css_nr_config nr_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&nr_config, 0, sizeof(struct atomisp_css_nr_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-
-	isp_config.nr_config = &nr_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, &nr_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_ee_config(struct atomisp_sub_device *asd,
-			struct atomisp_ee_config *config)
-{
-	struct atomisp_css_ee_config ee_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			 __func__);
-		return -EINVAL;
-	}
-	memset(&ee_config, 0, sizeof(struct atomisp_css_ee_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.ee_config = &ee_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, &ee_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_tnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_tnr_config *config)
-{
-	struct atomisp_css_tnr_config tnr_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&tnr_config, 0, sizeof(struct atomisp_css_tnr_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.tnr_config = &tnr_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, &tnr_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_ctc_table(struct atomisp_sub_device *asd,
-			struct atomisp_ctc_table *config)
-{
-	struct atomisp_css_ctc_table *tab;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-
-	tab = vzalloc(sizeof(struct atomisp_css_ctc_table));
-	if (!tab)
-		return -ENOMEM;
-
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.ctc_table = tab;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, tab, sizeof(*tab));
-	vfree(tab);
-
-	return 0;
-}
-
-int atomisp_css_get_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_gamma_table *config)
-{
-	struct atomisp_css_gamma_table *tab;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-
-	tab = vzalloc(sizeof(struct atomisp_css_gamma_table));
-	if (!tab)
-		return -ENOMEM;
-
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.gamma_table = tab;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	memcpy(config, tab, sizeof(*tab));
-	vfree(tab);
-
-	return 0;
-}
-
-int atomisp_css_get_gc_config(struct atomisp_sub_device *asd,
-			struct atomisp_gc_config *config)
-{
-	struct atomisp_css_gc_config gc_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&gc_config, 0, sizeof(struct atomisp_css_gc_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.gc_config = &gc_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	/* Get gamma correction params from current setup */
-	memcpy(config, &gc_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_3a_config(struct atomisp_sub_device *asd,
-			struct atomisp_3a_config *config)
-{
-	struct atomisp_css_3a_config s3a_config;
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&s3a_config, 0, sizeof(struct atomisp_css_3a_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.s3a_config = &s3a_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	/* Get white balance from current setup */
-	memcpy(config, &s3a_config, sizeof(*config));
-
-	return 0;
-}
-
-int atomisp_css_get_zoom_factor(struct atomisp_sub_device *asd,
-					unsigned int *zoom)
-{
-	struct ia_css_dz_config dz_config;  /**< Digital Zoom */
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev, "%s called after streamoff, skipping.\n",
-			__func__);
-		return -EINVAL;
-	}
-	memset(&dz_config, 0, sizeof(struct ia_css_dz_config));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.dz_config = &dz_config;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-	*zoom = dz_config.dx;
-
-	return 0;
-}
-
-
-/*
- * Function to set/get image stablization statistics
- */
-int atomisp_css_get_dis_stat(struct atomisp_sub_device *asd,
-			 struct atomisp_dis_statistics *stats)
-{
-	struct atomisp_device *isp = asd->isp;
-	unsigned long flags;
-
-	if (asd->params.dvs_stat->hor_prod.odd_real == NULL ||
-	    asd->params.dvs_stat->hor_prod.odd_imag == NULL ||
-	    asd->params.dvs_stat->hor_prod.even_real == NULL ||
-	    asd->params.dvs_stat->hor_prod.even_imag == NULL ||
-	    asd->params.dvs_stat->ver_prod.odd_real == NULL ||
-	    asd->params.dvs_stat->ver_prod.odd_imag == NULL ||
-	    asd->params.dvs_stat->ver_prod.even_real == NULL ||
-	    asd->params.dvs_stat->ver_prod.even_imag == NULL)
-		return -EINVAL;
-
-	/* isp needs to be streaming to get DIS statistics */
-	spin_lock_irqsave(&isp->lock, flags);
-	if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
-		spin_unlock_irqrestore(&isp->lock, flags);
-		return -EINVAL;
-	}
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	if (atomisp_compare_dvs_grid(asd, &stats->dvs2_stat.grid_info) != 0)
-		/* If the grid info in the argument differs from the current
-		   grid info, we tell the caller to reset the grid size and
-		   try again. */
-		return -EAGAIN;
-
-	if (!asd->params.dis_proj_data_valid)
-		return -EBUSY;
-
-	stats->exp_id = asd->params.exp_id;
-	if (copy_to_user(stats->dvs2_stat.ver_prod.odd_real,
-			 asd->params.dvs_stat->ver_prod.odd_real,
-			 asd->params.dvs_ver_proj_bytes))
-		return -EFAULT;
-	if (copy_to_user(stats->dvs2_stat.ver_prod.odd_imag,
-			 asd->params.dvs_stat->ver_prod.odd_imag,
-			 asd->params.dvs_ver_proj_bytes))
-		return -EFAULT;
-	if (copy_to_user(stats->dvs2_stat.ver_prod.even_real,
-			 asd->params.dvs_stat->ver_prod.even_real,
-			 asd->params.dvs_ver_proj_bytes))
-		return -EFAULT;
-	if (copy_to_user(stats->dvs2_stat.ver_prod.even_imag,
-			 asd->params.dvs_stat->ver_prod.even_imag,
-			 asd->params.dvs_ver_proj_bytes))
-		return -EFAULT;
-	if (copy_to_user(stats->dvs2_stat.hor_prod.odd_real,
-			 asd->params.dvs_stat->hor_prod.odd_real,
-			 asd->params.dvs_hor_proj_bytes))
-		return -EFAULT;
-	if (copy_to_user(stats->dvs2_stat.hor_prod.odd_imag,
-			 asd->params.dvs_stat->hor_prod.odd_imag,
-			 asd->params.dvs_hor_proj_bytes))
-		return -EFAULT;
-	if (copy_to_user(stats->dvs2_stat.hor_prod.even_real,
-			 asd->params.dvs_stat->hor_prod.even_real,
-			 asd->params.dvs_hor_proj_bytes))
-		return -EFAULT;
-	if (copy_to_user(stats->dvs2_stat.hor_prod.even_imag,
-			 asd->params.dvs_stat->hor_prod.even_imag,
-			 asd->params.dvs_hor_proj_bytes))
-		return -EFAULT;
-
-	return 0;
-
-}
-
-struct atomisp_css_shading_table *atomisp_css_shading_table_alloc(
-				unsigned int width, unsigned int height)
-{
-	return ia_css_shading_table_alloc(width, height);
-}
-
-void atomisp_css_set_shading_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_shading_table *table)
-{
-	asd->params.config.shading_table = table;
-}
-
-void atomisp_css_shading_table_free(struct atomisp_css_shading_table *table)
-{
-	ia_css_shading_table_free(table);
-}
-
-struct atomisp_css_morph_table *atomisp_css_morph_table_allocate(
-				unsigned int width, unsigned int height)
-{
-	return ia_css_morph_table_allocate(width, height);
-}
-
-void atomisp_css_set_morph_table(struct atomisp_sub_device *asd,
-					struct atomisp_css_morph_table *table)
-{
-	asd->params.config.morph_table = table;
-}
-
-void atomisp_css_get_morph_table(struct atomisp_sub_device *asd,
-				struct atomisp_css_morph_table *table)
-{
-	struct ia_css_isp_config isp_config;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream) {
-		dev_err(isp->dev,
-			"%s called after streamoff, skipping.\n", __func__);
-		return;
-	}
-	memset(table, 0, sizeof(struct atomisp_css_morph_table));
-	memset(&isp_config, 0, sizeof(struct ia_css_isp_config));
-	isp_config.morph_table = table;
-	ia_css_stream_get_isp_config(
-		asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL].stream,
-		&isp_config);
-}
-
-void atomisp_css_morph_table_free(struct atomisp_css_morph_table *table)
-{
-	ia_css_morph_table_free(table);
-}
-
-void atomisp_css_set_cont_prev_start_time(struct atomisp_device *isp,
-					unsigned int overlap)
-{
-	/* CSS 2.0 doesn't support this API. */
-	dev_info(isp->dev, "set cont prev start time is not supported.\n");
-	return;
-}
-
-void atomisp_css_acc_done(struct atomisp_sub_device *asd)
-{
-	complete(&asd->isp->acc.acc_done);
-}
-
-int atomisp_css_wait_acc_finish(struct atomisp_sub_device *asd)
-{
-	int ret = 0;
-	struct atomisp_device *isp = asd->isp;
-
-	/* Unlock the isp mutex taken in IOCTL handler before sleeping! */
-	mutex_unlock(&isp->mutex);
-	if (wait_for_completion_interruptible_timeout(&isp->acc.acc_done,
-					ATOMISP_ISP_TIMEOUT_DURATION) == 0) {
-		unsigned int old_dbglevel = dbg_level;
-
-		dbg_level = 6;
-		dev_err(isp->dev, "<%s: completion timeout\n", __func__);
-		atomisp_css_debug_set_dtrace_level(
-						CSS_DTRACE_VERBOSITY_TIMEOUT);
-		atomisp_css_debug_dump_sp_sw_debug_info();
-		atomisp_css_debug_dump_debug_info(__func__);
-		atomisp_css_debug_set_dtrace_level(CSS_DTRACE_VERBOSITY_LEVEL);
-		dbg_level = old_dbglevel;
-		ret = -EIO;
-	}
-	mutex_lock(&isp->mutex);
-
-	return ret;
-}
-
-/* Set the ACC binary arguments */
-int atomisp_css_set_acc_parameters(struct atomisp_acc_fw *acc_fw)
-{
-#ifndef CSS21
-	struct ia_css_data sec;
-#endif /* !CSS21 */
-	unsigned int mem;
-
-	for (mem = 0; mem < ATOMISP_ACC_NR_MEMORY; mem++) {
-		if (acc_fw->args[mem].length == 0)
-			continue;
-
-#ifndef CSS21
-		sec.address = acc_fw->args[mem].css_ptr;
-		sec.size = acc_fw->args[mem].length;
-		if (sh_css_acc_set_firmware_parameters(acc_fw->fw, mem, sec)
-			!= IA_CSS_SUCCESS)
-			return -EIO;
-#else /* !CSS21 */
-		ia_css_isp_param_set_css_mem_init(&acc_fw->fw->mem_initializers,
-						IA_CSS_PARAM_CLASS_PARAM, mem,
-						acc_fw->args[mem].css_ptr,
-						acc_fw->args[mem].length);
-#endif /* !CSS21 */
-	}
-
-	return 0;
-}
-
-/* Load acc binary extension */
-int atomisp_css_load_acc_extension(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					enum atomisp_css_pipe_id pipe_id,
-					unsigned int type)
-{
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.pipe_configs[pipe_id].acc_extension = fw;
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.update_pipe[pipe_id] = true;
-	return 0;
-}
-
-/* Unload acc binary extension */
-void atomisp_css_unload_acc_extension(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					enum atomisp_css_pipe_id pipe_id)
-{
-	asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-		.pipe_configs[pipe_id].acc_extension = NULL;
-}
-
-int atomisp_css_create_acc_pipe(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct ia_css_pipe_config *pipe_config;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-
-	if (stream_env->acc_stream) {
-		if (stream_env->acc_stream_state == CSS_STREAM_STARTED) {
-			if (ia_css_stream_stop(stream_env->acc_stream)
-				!= IA_CSS_SUCCESS) {
-				dev_err(isp->dev, "stop acc_stream failed.\n");
-				return -EBUSY;
-			}
-		}
-
-		if (ia_css_stream_destroy(stream_env->acc_stream)
-			!= IA_CSS_SUCCESS) {
-			dev_err(isp->dev, "destroy acc_stream failed.\n");
-			return -EBUSY;
-		}
-		stream_env->acc_stream = NULL;
-	}
-
-	pipe_config = &stream_env->pipe_configs[CSS_PIPE_ID_ACC];
-	ia_css_pipe_config_defaults(pipe_config);
-	isp->acc.acc_stages = kzalloc(MAX_ACC_STAGES *
-				sizeof(void *), GFP_KERNEL);
-	if (!isp->acc.acc_stages)
-		return -ENOMEM;
-	pipe_config->acc_stages = isp->acc.acc_stages;
-	pipe_config->mode = IA_CSS_PIPE_MODE_ACC;
-	pipe_config->num_acc_stages = 0;
-
-	/*
-	 * We delay the ACC pipeline creation to atomisp_css_start_acc_pipe,
-	 * because pipe configuration will soon be changed by
-	 * atomisp_css_load_acc_binary()
-	 */
-	return 0;
-}
-
-int atomisp_css_start_acc_pipe(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	struct ia_css_pipe_config *pipe_config =
-			&stream_env->pipe_configs[IA_CSS_PIPE_ID_ACC];
-
-	if (ia_css_pipe_create(pipe_config,
-		&stream_env->pipes[IA_CSS_PIPE_ID_ACC]) != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "%s: ia_css_pipe_create failed\n",
-				__func__);
-		return -EBADE;
-	}
-
-	memset(&stream_env->acc_stream_config, 0,
-		sizeof(struct ia_css_stream_config));
-	if (ia_css_stream_create(&stream_env->acc_stream_config, 1,
-				&stream_env->pipes[IA_CSS_PIPE_ID_ACC],
-				&stream_env->acc_stream) != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "%s: create acc_stream error.\n", __func__);
-		return -EINVAL;
-	}
-	stream_env->acc_stream_state = CSS_STREAM_CREATED;
-
-	init_completion(&isp->acc.acc_done);
-	isp->acc.pipeline = stream_env->pipes[IA_CSS_PIPE_ID_ACC];
-
-	atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX);
-
-	if (ia_css_start_sp() != IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "start sp error.\n");
-		return -EIO;
-	}
-
-	if (ia_css_stream_start(stream_env->acc_stream)
-		!= IA_CSS_SUCCESS) {
-		dev_err(isp->dev, "acc_stream start error.\n");
-		return -EIO;
-	}
-
-	stream_env->acc_stream_state = CSS_STREAM_STARTED;
-	return 0;
-}
-
-int atomisp_css_stop_acc_pipe(struct atomisp_sub_device *asd)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	if (stream_env->acc_stream_state == CSS_STREAM_STARTED) {
-		ia_css_stream_stop(stream_env->acc_stream);
-		stream_env->acc_stream_state = CSS_STREAM_STOPPED;
-	}
-	return 0;
-}
-
-void atomisp_css_destroy_acc_pipe(struct atomisp_sub_device *asd)
-{
-	struct atomisp_stream_env *stream_env =
-		&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL];
-	if (stream_env->acc_stream) {
-		if (ia_css_stream_destroy(stream_env->acc_stream)
-		    != IA_CSS_SUCCESS)
-			dev_warn(asd->isp->dev,
-				"destroy acc_stream failed.\n");
-		stream_env->acc_stream = NULL;
-	}
-
-	if (stream_env->pipes[IA_CSS_PIPE_ID_ACC]) {
-		if (ia_css_pipe_destroy(stream_env->pipes[IA_CSS_PIPE_ID_ACC])
-			!= IA_CSS_SUCCESS)
-			dev_warn(asd->isp->dev,
-				"destroy ACC pipe failed.\n");
-		stream_env->pipes[IA_CSS_PIPE_ID_ACC] = NULL;
-		stream_env->update_pipe[IA_CSS_PIPE_ID_ACC] = false;
-		ia_css_pipe_config_defaults(
-			&stream_env->pipe_configs[IA_CSS_PIPE_ID_ACC]);
-		ia_css_pipe_extra_config_defaults(
-			&stream_env->pipe_extra_configs[IA_CSS_PIPE_ID_ACC]);
-	}
-	asd->isp->acc.pipeline = NULL;
-
-	/* css 2.0 API limitation: ia_css_stop_sp() could be only called after
-	 * destroy all pipes
-	 */
-	if (ia_css_isp_has_started())
-		ia_css_stop_sp();
-
-	kfree(asd->isp->acc.acc_stages);
-	asd->isp->acc.acc_stages = NULL;
-
-	atomisp_freq_scaling(asd->isp, ATOMISP_DFS_MODE_LOW);
-
-	/* Force power cycling when binary finished */
-	atomisp_css_suspend();
-	if (pm_runtime_put_sync(asd->isp->dev) < 0)
-		dev_err(asd->isp->dev, "can not disable ISP power\n");
-	else if (pm_runtime_get_sync(asd->isp->dev) < 0)
-		dev_err(asd->isp->dev, "can not enable ISP power\n");
-	atomisp_css_resume(asd->isp);
-}
-
-int atomisp_css_load_acc_binary(struct atomisp_sub_device *asd,
-					struct atomisp_css_fw_info *fw,
-					unsigned int index)
-{
-	struct ia_css_pipe_config *pipe_config =
-			&asd->stream_env[ATOMISP_INPUT_STREAM_GENERAL]
-			.pipe_configs[IA_CSS_PIPE_ID_ACC];
-
-	if (index >= MAX_ACC_STAGES) {
-		dev_dbg(asd->isp->dev, "%s: index(%d) out of range\n",
-				__func__, index);
-		return -ENOMEM;
-	}
-
-	pipe_config->acc_stages[index] = fw;
-	pipe_config->num_acc_stages = index + 1;
-#ifdef CSS21
-	pipe_config->acc_num_execs = 1;
-#endif
-
-	return 0;
-}
-
-static struct atomisp_sub_device *__get_atomisp_subdev(
-					struct ia_css_pipe *css_pipe,
-					struct atomisp_device *isp,
-					enum atomisp_input_stream_id *stream_id) {
-	int i, j, k;
-	struct atomisp_sub_device *asd;
-	struct atomisp_stream_env *stream_env;
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		asd = &isp->asd[i];
-		if (asd->streaming == ATOMISP_DEVICE_STREAMING_DISABLED &&
-		    !isp->acc.pipeline)
-			continue;
-		for (j = 0; j < ATOMISP_INPUT_STREAM_NUM; j++) {
-			stream_env = &asd->stream_env[j];
-			for (k = 0; k < IA_CSS_PIPE_ID_NUM; k++) {
-				if (stream_env->pipes[k] &&
-					stream_env->pipes[k] == css_pipe) {
-						*stream_id = j;
-						return asd;
-					}
-				}
-		}
-	}
-
-	return NULL;
-}
-
-int atomisp_css_isr_thread(struct atomisp_device *isp,
-			   bool *frame_done_found,
-			   bool *css_pipe_done,
-			   bool *reset_wdt_timer)
-{
-	enum atomisp_input_stream_id stream_id = 0;
-	struct atomisp_css_event current_event;
-	struct atomisp_sub_device *asd = &isp->asd[0];
-
-	while (!atomisp_css_dequeue_event(&current_event)) {
-		atomisp_css_temp_pipe_to_pipe_id(&current_event);
-		asd = __get_atomisp_subdev(current_event.event.pipe,
-						  isp, &stream_id);
-		if (!asd) {
-			/* EOF Event does not have the css_pipe returned */
-			if (current_event.event.type !=
-			    IA_CSS_EVENT_TYPE_PORT_EOF) {
-				dev_err(isp->dev, "%s:no subdev. event:%d",
-					 __func__, current_event.event.type);
-				return -EINVAL;
-			}
-		}
-
-		switch (current_event.event.type) {
-		case CSS_EVENT_OUTPUT_FRAME_DONE:
-			frame_done_found[asd->index] = true;
-			atomisp_buf_done(asd, 0, CSS_BUFFER_TYPE_OUTPUT_FRAME,
-					 current_event.pipe, true, stream_id);
-			*reset_wdt_timer = true; /* ISP running */
-			break;
-		case CSS_EVENT_3A_STATISTICS_DONE:
-			atomisp_buf_done(asd, 0,
-					 CSS_BUFFER_TYPE_3A_STATISTICS,
-					 current_event.pipe,
-					 css_pipe_done[asd->index], stream_id);
-			break;
-		case CSS_EVENT_VF_OUTPUT_FRAME_DONE:
-			atomisp_buf_done(asd, 0,
-					 CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
-					 current_event.pipe, true, stream_id);
-			*reset_wdt_timer = true; /* ISP running */
-			break;
-		case CSS_EVENT_DIS_STATISTICS_DONE:
-			atomisp_buf_done(asd, 0,
-					 CSS_BUFFER_TYPE_DIS_STATISTICS,
-					 current_event.pipe,
-					 css_pipe_done[asd->index], stream_id);
-			break;
-		case CSS_EVENT_PIPELINE_DONE:
-			css_pipe_done[asd->index] = true;
-			break;
-		case CSS_EVENT_PORT_EOF:
-			break;
-		default:
-			dev_err(isp->dev, "unhandled css stored event: 0x%x\n",
-					current_event.event.type);
-			break;
-		}
-	}
-	return 0;
-}
-
-void atomisp_set_stop_timeout(unsigned int timeout)
-{
-	return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.h
deleted file mode 100644
index c0d43ee..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_css20.h
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
- * Support for Clovertrail PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __ATOMISP_COMPAT_CSS20_H__
-#define __ATOMISP_COMPAT_CSS20_H__
-
-#include <media/v4l2-mediabus.h>
-
-#include "ia_css.h"
-#include "ia_css_types.h"
-#include "ia_css_acc_types.h"
-#include "sh_css_legacy.h"
-
-#define ATOMISP_CSS2_PIPE_MAX	2
-#define ATOMISP_CSS2_NUM_OFFLINE_INIT_CONTINUOUS_FRAMES     3
-
-#define atomisp_css_pipe_id ia_css_pipe_id
-#define atomisp_css_pipeline	ia_css_pipe
-#define atomisp_css_buffer_type ia_css_buffer_type
-#define atomisp_css_dis_data ia_css_isp_dvs_statistics
-#define atomisp_css_irq_info  ia_css_irq_info
-#define atomisp_css_isp_config ia_css_isp_config
-#define atomisp_css_bayer_order ia_css_bayer_order
-#define atomisp_css_stream_format ia_css_stream_format
-#define atomisp_css_capture_mode ia_css_capture_mode
-#define atomisp_css_input_mode ia_css_input_mode
-#define atomisp_css_frame ia_css_frame
-#define atomisp_css_frame_format ia_css_frame_format
-#define atomisp_css_frame_info ia_css_frame_info
-#define atomisp_css_dp_config	ia_css_dp_config
-#define atomisp_css_wb_config	ia_css_wb_config
-#define atomisp_css_cc_config	ia_css_cc_config
-#define atomisp_css_nr_config	ia_css_nr_config
-#define atomisp_css_ee_config	ia_css_ee_config
-#define atomisp_css_ob_config	ia_css_ob_config
-#define atomisp_css_de_config	ia_css_de_config
-#define atomisp_css_ce_config	ia_css_ce_config
-#define atomisp_css_gc_config	ia_css_gc_config
-#define atomisp_css_tnr_config	ia_css_tnr_config
-#define atomisp_css_cnr_config	ia_css_cnr_config
-#define atomisp_css_ctc_config	ia_css_ctc_config
-#define atomisp_css_3a_config	ia_css_3a_config
-#define atomisp_css_ecd_config	ia_css_ecd_config
-#define atomisp_css_ynr_config	ia_css_ynr_config
-#define atomisp_css_fc_config	ia_css_fc_config
-#define atomisp_css_aa_config	ia_css_aa_config
-#define atomisp_css_baa_config	ia_css_aa_config
-#define atomisp_css_anr_config	ia_css_anr_config
-#define atomisp_css_xnr_config	ia_css_xnr_config
-#define atomisp_css_macc_config	ia_css_macc_config
-#define atomisp_css_gamma_table	ia_css_gamma_table
-#define atomisp_css_ctc_table	ia_css_ctc_table
-#define atomisp_css_macc_table	ia_css_macc_table
-#define atomisp_css_xnr_table	ia_css_xnr_table
-#define atomisp_css_rgb_gamma_table	ia_css_rgb_gamma_table
-#define atomisp_css_anr_thres	ia_css_anr_thres
-#define atomisp_css_dvs_6axis	ia_css_dvs_6axis_config
-#define atomisp_css_grid_info	ia_css_grid_info
-#define atomisp_css_3a_grid_info	ia_css_3a_grid_info
-#define atomisp_css_dvs_grid_info	ia_css_dvs_grid_info
-#define atomisp_css_shading_table	ia_css_shading_table
-#define atomisp_css_morph_table	ia_css_morph_table
-#define atomisp_css_dvs_6axis_config	ia_css_dvs_6axis_config
-#define atomisp_css_fw_info	ia_css_fw_info
-
-#define CSS_PIPE_ID_PREVIEW	IA_CSS_PIPE_ID_PREVIEW
-#define CSS_PIPE_ID_COPY	IA_CSS_PIPE_ID_COPY
-#define CSS_PIPE_ID_VIDEO	IA_CSS_PIPE_ID_VIDEO
-#define CSS_PIPE_ID_CAPTURE	IA_CSS_PIPE_ID_CAPTURE
-#define CSS_PIPE_ID_ACC		IA_CSS_PIPE_ID_ACC
-#define CSS_PIPE_ID_NUM		IA_CSS_PIPE_ID_NUM
-
-#define CSS_INPUT_MODE_SENSOR	IA_CSS_INPUT_MODE_BUFFERED_SENSOR
-#define CSS_INPUT_MODE_FIFO	IA_CSS_INPUT_MODE_FIFO
-#define CSS_INPUT_MODE_TPG	IA_CSS_INPUT_MODE_TPG
-#define CSS_INPUT_MODE_PRBS	IA_CSS_INPUT_MODE_PRBS
-#define CSS_INPUT_MODE_MEMORY	IA_CSS_INPUT_MODE_MEMORY
-
-#define CSS_IRQ_INFO_CSS_RECEIVER_ERROR	IA_CSS_IRQ_INFO_CSS_RECEIVER_ERROR
-#define CSS_IRQ_INFO_EVENTS_READY	IA_CSS_IRQ_INFO_EVENTS_READY
-#define CSS_IRQ_INFO_INPUT_SYSTEM_ERROR \
-	IA_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR
-#define CSS_IRQ_INFO_IF_ERROR	IA_CSS_IRQ_INFO_IF_ERROR
-
-#define CSS_BUFFER_TYPE_NUM	IA_CSS_BUFFER_TYPE_NUM
-
-#define CSS_FRAME_FLASH_STATE_NONE	IA_CSS_FRAME_FLASH_STATE_NONE
-#define CSS_FRAME_FLASH_STATE_PARTIAL	IA_CSS_FRAME_FLASH_STATE_PARTIAL
-#define CSS_FRAME_FLASH_STATE_FULL	IA_CSS_FRAME_FLASH_STATE_FULL
-
-#define CSS_BAYER_ORDER_GRBG	IA_CSS_BAYER_ORDER_GRBG
-#define CSS_BAYER_ORDER_RGGB	IA_CSS_BAYER_ORDER_RGGB
-#define CSS_BAYER_ORDER_BGGR	IA_CSS_BAYER_ORDER_BGGR
-#define CSS_BAYER_ORDER_GBRG	IA_CSS_BAYER_ORDER_GBRG
-
-/*
- * Hide IA_ naming difference in otherwise common CSS macros.
- */
-#define CSS_ID(val)	(IA_ ## val)
-#define CSS_EVENT(val)	(IA_CSS_EVENT_TYPE_ ## val)
-#define CSS_FORMAT(val)	(IA_CSS_STREAM_FORMAT_ ## val)
-
-#define CSS_EVENT_PORT_EOF	CSS_EVENT(PORT_EOF)
-#define CSS_EVENT_FRAME_TAGGED	CSS_EVENT(FRAME_TAGGED)
-
-#define CSS_MIPI_FRAME_BUFFER_SIZE_1	0x60000
-#define CSS_MIPI_FRAME_BUFFER_SIZE_2	0x80000
-
-struct atomisp_device;
-struct atomisp_sub_device;
-
-/*
- * These are used to indicate the css stream state, corresponding
- * stream handling can be done via judging the different state.
- */
-enum atomisp_css_stream_state {
-	CSS_STREAM_UNINIT,
-	CSS_STREAM_CREATED,
-	CSS_STREAM_STARTED,
-	CSS_STREAM_STOPPED,
-};
-
-struct atomisp_stream_env {
-	struct ia_css_stream *stream;
-	struct ia_css_stream_config stream_config;
-	struct ia_css_pipe *pipes[IA_CSS_PIPE_ID_NUM];
-	struct ia_css_pipe *multi_pipes[IA_CSS_PIPE_ID_NUM];
-	struct ia_css_pipe_config pipe_configs[IA_CSS_PIPE_ID_NUM];
-	struct ia_css_pipe_extra_config pipe_extra_configs[IA_CSS_PIPE_ID_NUM];
-	bool update_pipe[IA_CSS_PIPE_ID_NUM];
-	enum atomisp_css_stream_state stream_state;
-	struct ia_css_stream *acc_stream;
-	enum atomisp_css_stream_state acc_stream_state;
-	struct ia_css_stream_config acc_stream_config;
-	unsigned int ch_id; /* virtual channel ID */
-};
-
-struct atomisp_css_env {
-	struct ia_css_env isp_css_env;
-	struct ia_css_fw isp_css_fw;
-};
-
-struct atomisp_s3a_buf {
-	struct ia_css_isp_3a_statistics *s3a_data;
-	struct list_head list;
-};
-
-struct atomisp_dis_buf {
-	struct atomisp_css_dis_data *dis_data;
-	struct list_head list;
-};
-
-struct atomisp_css_buffer {
-	struct ia_css_buffer css_buffer;
-};
-
-struct atomisp_css_event {
-	enum atomisp_css_pipe_id pipe;
-	struct ia_css_event event;
-};
-
-void atomisp_css_set_macc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_macc_config *macc_config);
-
-void atomisp_css_set_ecd_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ecd_config *ecd_config);
-
-void atomisp_css_set_ynr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ynr_config *ynr_config);
-
-void atomisp_css_set_fc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_fc_config *fc_config);
-
-void atomisp_css_set_aa_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_aa_config *aa_config);
-
-void atomisp_css_set_baa_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_baa_config *baa_config);
-
-void atomisp_css_set_anr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_anr_config *anr_config);
-
-void atomisp_css_set_xnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_xnr_config *xnr_config);
-
-void atomisp_css_set_cnr_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cnr_config *cnr_config);
-
-void atomisp_css_set_ctc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_ctc_config *ctc_config);
-
-void atomisp_css_set_yuv2rgb_cc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cc_config *yuv2rgb_cc_config);
-
-void atomisp_css_set_rgb2yuv_cc_config(struct atomisp_sub_device *asd,
-			struct atomisp_css_cc_config *rgb2yuv_cc_config);
-
-void atomisp_css_set_xnr_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_xnr_table *xnr_table);
-
-void atomisp_css_set_r_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_rgb_gamma_table *r_gamma_table);
-
-void atomisp_css_set_g_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_rgb_gamma_table *g_gamma_table);
-
-void atomisp_css_set_b_gamma_table(struct atomisp_sub_device *asd,
-			struct atomisp_css_rgb_gamma_table *b_gamma_table);
-
-void atomisp_css_set_anr_thres(struct atomisp_sub_device *asd,
-			struct atomisp_css_anr_thres *anr_thres);
-
-int atomisp_css_load_firmware(struct atomisp_device *isp);
-
-void atomisp_css_unload_firmware(struct atomisp_device *isp);
-
-void atomisp_css_set_dvs_6axis(struct atomisp_sub_device *asd,
-			struct atomisp_css_dvs_6axis *dvs_6axis);
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.c
deleted file mode 100644
index 242d155..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.c
+++ /dev/null
@@ -1,1116 +0,0 @@
-/*
- * Support for Intel Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifdef CONFIG_COMPAT
-#include <linux/compat.h>
-
-#include <linux/videodev2.h>
-
-#include "atomisp_internal.h"
-#include "atomisp_compat.h"
-#include "atomisp_compat_ioctl32.h"
-
-static int get_atomisp_histogram32(struct atomisp_histogram *kp,
-					struct atomisp_histogram32 __user *up)
-{
-	compat_uptr_t tmp;
-
-	if (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_histogram32)) ||
-		get_user(kp->num_elements, &up->num_elements) ||
-		get_user(tmp, &up->data))
-			return -EFAULT;
-
-	kp->data = compat_ptr(tmp);
-	return 0;
-}
-
-static int put_atomisp_histogram32(struct atomisp_histogram *kp,
-					struct atomisp_histogram32 __user *up)
-{
-	compat_uptr_t tmp = (compat_uptr_t)((uintptr_t)kp->data);
-
-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_histogram32)) ||
-		put_user(kp->num_elements, &up->num_elements) ||
-		put_user(tmp, &up->data))
-			return -EFAULT;
-
-	return 0;
-}
-
-static inline int get_v4l2_pix_format(struct v4l2_pix_format *kp,
-					struct v4l2_pix_format __user *up)
-{
-	if (copy_from_user(kp, up, sizeof(struct v4l2_pix_format)))
-		return -EFAULT;
-	return 0;
-}
-
-static inline int put_v4l2_pix_format(struct v4l2_pix_format *kp,
-					struct v4l2_pix_format __user *up)
-{
-	if (copy_to_user(up, kp, sizeof(struct v4l2_pix_format)))
-		return -EFAULT;
-	return 0;
-}
-
-static int get_v4l2_framebuffer32(struct v4l2_framebuffer *kp,
-					struct v4l2_framebuffer32 __user *up)
-{
-	compat_uptr_t tmp;
-
-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_framebuffer32)) ||
-		get_user(tmp, &up->base) ||
-		get_user(kp->capability, &up->capability) ||
-		get_user(kp->flags, &up->flags))
-			return -EFAULT;
-
-	kp->base = compat_ptr(tmp);
-	get_v4l2_pix_format(&kp->fmt, &up->fmt);
-	return 0;
-}
-
-#ifdef CSS20
-static int get_atomisp_dis_statistics32(struct atomisp_dis_statistics *kp,
-				struct atomisp_dis_statistics32 __user *up)
-{
-	compat_uptr_t hor_prod_odd_real;
-	compat_uptr_t hor_prod_odd_imag;
-	compat_uptr_t hor_prod_even_real;
-	compat_uptr_t hor_prod_even_imag;
-	compat_uptr_t ver_prod_odd_real;
-	compat_uptr_t ver_prod_odd_imag;
-	compat_uptr_t ver_prod_even_real;
-	compat_uptr_t ver_prod_even_imag;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_dis_statistics32)) ||
-		copy_from_user(kp, up, sizeof(struct atomisp_dvs_grid_info)) ||
-		get_user(hor_prod_odd_real,
-				&up->dvs2_stat.hor_prod.odd_real) ||
-		get_user(hor_prod_odd_imag,
-				&up->dvs2_stat.hor_prod.odd_imag) ||
-		get_user(hor_prod_even_real,
-				&up->dvs2_stat.hor_prod.even_real) ||
-		get_user(hor_prod_even_imag,
-				&up->dvs2_stat.hor_prod.even_imag) ||
-		get_user(ver_prod_odd_real,
-				&up->dvs2_stat.ver_prod.odd_real) ||
-		get_user(ver_prod_odd_imag,
-				&up->dvs2_stat.ver_prod.odd_imag) ||
-		get_user(ver_prod_even_real,
-				&up->dvs2_stat.ver_prod.even_real) ||
-		get_user(ver_prod_even_imag,
-				&up->dvs2_stat.ver_prod.even_imag) ||
-		get_user(kp->exp_id, &up->exp_id))
-			return -EFAULT;
-
-	kp->dvs2_stat.hor_prod.odd_real = compat_ptr(hor_prod_odd_real);
-	kp->dvs2_stat.hor_prod.odd_imag = compat_ptr(hor_prod_odd_imag);
-	kp->dvs2_stat.hor_prod.even_real = compat_ptr(hor_prod_even_real);
-	kp->dvs2_stat.hor_prod.even_imag = compat_ptr(hor_prod_even_imag);
-	kp->dvs2_stat.ver_prod.odd_real = compat_ptr(ver_prod_odd_real);
-	kp->dvs2_stat.ver_prod.odd_imag = compat_ptr(ver_prod_odd_imag);
-	kp->dvs2_stat.ver_prod.even_real = compat_ptr(ver_prod_even_real);
-	kp->dvs2_stat.ver_prod.even_imag = compat_ptr(ver_prod_even_imag);
-	return 0;
-}
-
-static int put_atomisp_dis_statistics32(struct atomisp_dis_statistics *kp,
-				struct atomisp_dis_statistics32 __user *up)
-{
-	compat_uptr_t hor_prod_odd_real =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.odd_real);
-	compat_uptr_t hor_prod_odd_imag =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.odd_imag);
-	compat_uptr_t hor_prod_even_real =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.even_real);
-	compat_uptr_t hor_prod_even_imag =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.hor_prod.even_imag);
-	compat_uptr_t ver_prod_odd_real =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.odd_real);
-	compat_uptr_t ver_prod_odd_imag =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.odd_imag);
-	compat_uptr_t ver_prod_even_real =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.even_real);
-	compat_uptr_t ver_prod_even_imag =
-		(compat_uptr_t)((uintptr_t)kp->dvs2_stat.ver_prod.even_imag);
-
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_dis_statistics32)) ||
-		copy_to_user(up, kp, sizeof(struct atomisp_dvs_grid_info)) ||
-		put_user(hor_prod_odd_real,
-				&up->dvs2_stat.hor_prod.odd_real) ||
-		put_user(hor_prod_odd_imag,
-				&up->dvs2_stat.hor_prod.odd_imag) ||
-		put_user(hor_prod_even_real,
-				&up->dvs2_stat.hor_prod.even_real) ||
-		put_user(hor_prod_even_imag,
-				&up->dvs2_stat.hor_prod.even_imag) ||
-		put_user(ver_prod_odd_real,
-				&up->dvs2_stat.ver_prod.odd_real) ||
-		put_user(ver_prod_odd_imag,
-				&up->dvs2_stat.ver_prod.odd_imag) ||
-		put_user(ver_prod_even_real,
-				&up->dvs2_stat.ver_prod.even_real) ||
-		put_user(ver_prod_even_imag,
-				&up->dvs2_stat.ver_prod.even_imag) ||
-		put_user(kp->exp_id, &up->exp_id))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_dis_coefficients32(struct atomisp_dis_coefficients *kp,
-				struct atomisp_dis_coefficients32 __user *up)
-{
-	compat_uptr_t hor_coefs_odd_real;
-	compat_uptr_t hor_coefs_odd_imag;
-	compat_uptr_t hor_coefs_even_real;
-	compat_uptr_t hor_coefs_even_imag;
-	compat_uptr_t ver_coefs_odd_real;
-	compat_uptr_t ver_coefs_odd_imag;
-	compat_uptr_t ver_coefs_even_real;
-	compat_uptr_t ver_coefs_even_imag;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_dis_coefficients32)) ||
-		copy_from_user(kp, up, sizeof(struct atomisp_dvs_grid_info)) ||
-		get_user(hor_coefs_odd_real, &up->hor_coefs.odd_real) ||
-		get_user(hor_coefs_odd_imag, &up->hor_coefs.odd_imag) ||
-		get_user(hor_coefs_even_real, &up->hor_coefs.even_real) ||
-		get_user(hor_coefs_even_imag, &up->hor_coefs.even_imag) ||
-		get_user(ver_coefs_odd_real, &up->ver_coefs.odd_real) ||
-		get_user(ver_coefs_odd_imag, &up->ver_coefs.odd_imag) ||
-		get_user(ver_coefs_even_real, &up->ver_coefs.even_real) ||
-		get_user(ver_coefs_even_imag, &up->ver_coefs.even_imag))
-			return -EFAULT;
-
-	kp->hor_coefs.odd_real = compat_ptr(hor_coefs_odd_real);
-	kp->hor_coefs.odd_imag = compat_ptr(hor_coefs_odd_imag);
-	kp->hor_coefs.even_real = compat_ptr(hor_coefs_even_real);
-	kp->hor_coefs.even_imag = compat_ptr(hor_coefs_even_imag);
-	kp->ver_coefs.odd_real = compat_ptr(ver_coefs_odd_real);
-	kp->ver_coefs.odd_imag = compat_ptr(ver_coefs_odd_imag);
-	kp->ver_coefs.even_real = compat_ptr(ver_coefs_even_real);
-	kp->ver_coefs.even_imag = compat_ptr(ver_coefs_even_imag);
-	return 0;
-}
-
-#else /* CSS20 */
-static int get_atomisp_dis_statistics32(struct atomisp_dis_statistics *kp,
-				struct atomisp_dis_statistics32 __user *up)
-{
-	compat_uptr_t vertical_projections;
-	compat_uptr_t horizontal_projections;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_dis_statistics32)) ||
-		copy_from_user(kp, up, sizeof(struct atomisp_grid_info)) ||
-		get_user(vertical_projections, &up->vertical_projections) ||
-		get_user(horizontal_projections, &up->horizontal_projections))
-			return -EFAULT;
-
-	kp->vertical_projections = compat_ptr(vertical_projections);
-	kp->horizontal_projections = compat_ptr(horizontal_projections);
-	return 0;
-}
-
-static int put_atomisp_dis_statistics32(struct atomisp_dis_statistics *kp,
-				struct atomisp_dis_statistics32 __user *up)
-{
-	compat_uptr_t vertical_projections =
-		(compat_uptr_t)((uintptr_t)kp->vertical_projections);
-	compat_uptr_t horizontal_projections =
-		(compat_uptr_t)((uintptr_t)kp->horizontal_projections);
-
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_dis_statistics32)) ||
-		copy_to_user(up, kp, sizeof(struct atomisp_dvs_grid_info)) ||
-		put_user(vertical_projections, &up->vertical_projections) ||
-		put_user(horizontal_projections, &up->horizontal_projections))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_dis_coefficients32(struct atomisp_dis_coefficients *kp,
-				struct atomisp_dis_coefficients32 __user *up)
-{
-	compat_uptr_t vertical_coefficients;
-	compat_uptr_t horizontal_coefficients;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_dis_coefficients32)) ||
-		copy_from_user(kp, up, sizeof(struct atomisp_grid_info)) ||
-		get_user(vertical_coefficients, &up->vertical_coefficients) ||
-		get_user(horizontal_coefficients,
-				&up->horizontal_coefficients))
-			return -EFAULT;
-
-	kp->vertical_coefficients = compat_ptr(vertical_coefficients);
-	kp->horizontal_coefficients = compat_ptr(horizontal_coefficients);
-	return 0;
-}
-#endif /* CSS20 */
-
-static int get_atomisp_dvs_6axis_config32(struct atomisp_dvs_6axis_config *kp,
-				struct atomisp_dvs_6axis_config32 __user *up)
-{	compat_uptr_t xcoords_y;
-	compat_uptr_t ycoords_y;
-	compat_uptr_t xcoords_uv;
-	compat_uptr_t ycoords_uv;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_dvs_6axis_config32)) ||
-		get_user(kp->exp_id, &up->exp_id) ||
-		get_user(kp->width_y, &up->width_y) ||
-		get_user(kp->height_y, &up->height_y) ||
-		get_user(kp->width_uv, &up->width_uv) ||
-		get_user(kp->height_uv, &up->height_uv) ||
-		get_user(xcoords_y, &up->xcoords_y) ||
-		get_user(ycoords_y, &up->ycoords_y) ||
-		get_user(xcoords_uv, &up->xcoords_uv) ||
-		get_user(ycoords_uv, &up->ycoords_uv))
-			return -EFAULT;
-
-	kp->xcoords_y = compat_ptr(xcoords_y);
-	kp->ycoords_y = compat_ptr(ycoords_y);
-	kp->xcoords_uv = compat_ptr(xcoords_uv);
-	kp->ycoords_uv = compat_ptr(ycoords_uv);
-	return 0;
-}
-
-static int get_atomisp_3a_statistics32(struct atomisp_3a_statistics *kp,
-				struct atomisp_3a_statistics32 __user *up)
-{
-	compat_uptr_t data;
-#ifdef CSS20
-	compat_uptr_t rgby_data;
-#endif
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_3a_statistics32)) ||
-		copy_from_user(kp, up, sizeof(struct atomisp_grid_info)) ||
-#ifdef CSS20
-		get_user(rgby_data, &up->rgby_data) ||
-#endif
-		get_user(data, &up->data))
-			return -EFAULT;
-
-	kp->data = compat_ptr(data);
-#ifdef CSS20
-	kp->rgby_data = compat_ptr(rgby_data);
-#endif
-	return 0;
-}
-
-static int put_atomisp_3a_statistics32(struct atomisp_3a_statistics *kp,
-				struct atomisp_3a_statistics32 __user *up)
-{
-	compat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);
-#ifdef CSS20
-	compat_uptr_t rgby_data = (compat_uptr_t)((uintptr_t)kp->rgby_data);
-#endif
-
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_3a_statistics32)) ||
-		copy_to_user(up, kp, sizeof(struct atomisp_grid_info)) ||
-#ifdef CSS20
-		put_user(rgby_data, &up->rgby_data) ||
-#endif
-		put_user(data, &up->data))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_morph_table32(struct atomisp_morph_table *kp,
-				struct atomisp_morph_table32 __user *up)
-{
-	unsigned int n = ATOMISP_MORPH_TABLE_NUM_PLANES;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_morph_table32)) ||
-#ifdef CSS20
-		get_user(kp->enabled, &up->enabled) ||
-#endif
-		get_user(kp->width, &up->width) ||
-		get_user(kp->height, &up->height))
-			return -EFAULT;
-
-	while (n-- > 0) {
-		uintptr_t *coord_kp = (uintptr_t *)&kp->coordinates_x[n];
-
-		if (get_user((*coord_kp), &up->coordinates_x[n]))
-			return -EFAULT;
-
-		coord_kp = (uintptr_t *)&kp->coordinates_y[n];
-		if (get_user((*coord_kp), &up->coordinates_y[n]))
-			return -EFAULT;
-	}
-	return 0;
-}
-
-static int put_atomisp_morph_table32(struct atomisp_morph_table *kp,
-				struct atomisp_morph_table32 __user *up)
-{
-	unsigned int n = ATOMISP_MORPH_TABLE_NUM_PLANES;
-
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_morph_table32)) ||
-#ifdef CSS20
-		put_user(kp->enabled, &up->enabled) ||
-#endif
-		put_user(kp->width, &up->width) ||
-		put_user(kp->height, &up->height))
-			return -EFAULT;
-
-	while (n-- > 0) {
-		uintptr_t *coord_kp = (uintptr_t *)&kp->coordinates_x[n];
-
-		if (put_user((*coord_kp), &up->coordinates_x[n]))
-			return -EFAULT;
-
-		coord_kp = (uintptr_t *)&kp->coordinates_y[n];
-		if (put_user((*coord_kp), &up->coordinates_y[n]))
-			return -EFAULT;
-	}
-	return 0;
-}
-
-static int get_atomisp_overlay32(struct atomisp_overlay *kp,
-					struct atomisp_overlay32 __user *up)
-{
-	compat_uptr_t frame;
-	if (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_overlay32)) ||
-		get_user(frame, &up->frame) ||
-		get_user(kp->bg_y, &up->bg_y) ||
-		get_user(kp->bg_u, &up->bg_u) ||
-		get_user(kp->bg_v, &up->bg_v) ||
-		get_user(kp->blend_input_perc_y, &up->blend_input_perc_y) ||
-		get_user(kp->blend_input_perc_u, &up->blend_input_perc_u) ||
-		get_user(kp->blend_input_perc_v, &up->blend_input_perc_v) ||
-		get_user(kp->blend_overlay_perc_y,
-				&up->blend_overlay_perc_y) ||
-		get_user(kp->blend_overlay_perc_u,
-				&up->blend_overlay_perc_u) ||
-		get_user(kp->blend_overlay_perc_v,
-				&up->blend_overlay_perc_v) ||
-		get_user(kp->blend_overlay_perc_u,
-				&up->blend_overlay_perc_u) ||
-		get_user(kp->overlay_start_x, &up->overlay_start_y))
-			return -EFAULT;
-
-	kp->frame = compat_ptr(frame);
-	return 0;
-}
-
-static int put_atomisp_overlay32(struct atomisp_overlay *kp,
-					struct atomisp_overlay32 __user *up)
-{
-	compat_uptr_t frame = (compat_uptr_t)((uintptr_t)kp->frame);
-
-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_overlay32)) ||
-		put_user(frame, &up->frame) ||
-		put_user(kp->bg_y, &up->bg_y) ||
-		put_user(kp->bg_u, &up->bg_u) ||
-		put_user(kp->bg_v, &up->bg_v) ||
-		put_user(kp->blend_input_perc_y, &up->blend_input_perc_y) ||
-		put_user(kp->blend_input_perc_u, &up->blend_input_perc_u) ||
-		put_user(kp->blend_input_perc_v, &up->blend_input_perc_v) ||
-		put_user(kp->blend_overlay_perc_y,
-				&up->blend_overlay_perc_y) ||
-		put_user(kp->blend_overlay_perc_u,
-				&up->blend_overlay_perc_u) ||
-		put_user(kp->blend_overlay_perc_v,
-				&up->blend_overlay_perc_v) ||
-		put_user(kp->blend_overlay_perc_u,
-				&up->blend_overlay_perc_u) ||
-		put_user(kp->overlay_start_x, &up->overlay_start_y))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_calibration_group32(
-				struct atomisp_calibration_group *kp,
-				struct atomisp_calibration_group32 __user *up)
-{
-	compat_uptr_t calb_grp_values;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_calibration_group32)) ||
-		get_user(kp->size, &up->size) ||
-		get_user(kp->type, &up->type) ||
-		get_user(calb_grp_values, &up->calb_grp_values))
-			return -EFAULT;
-
-	kp->calb_grp_values = compat_ptr(calb_grp_values);
-	return 0;
-}
-
-static int put_atomisp_calibration_group32(
-				struct atomisp_calibration_group *kp,
-				struct atomisp_calibration_group32 __user *up)
-{
-	compat_uptr_t calb_grp_values =
-			(compat_uptr_t)((uintptr_t)kp->calb_grp_values);
-
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_calibration_group32)) ||
-		put_user(kp->size, &up->size) ||
-		put_user(kp->type, &up->type) ||
-		put_user(calb_grp_values, &up->calb_grp_values))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_acc_fw_load32(struct atomisp_acc_fw_load *kp,
-				struct atomisp_acc_fw_load32 __user *up)
-{
-	compat_uptr_t data;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_acc_fw_load32)) ||
-		get_user(kp->size, &up->size) ||
-		get_user(kp->fw_handle, &up->fw_handle) ||
-		get_user(data, &up->data))
-			return -EFAULT;
-
-	kp->data = compat_ptr(data);
-	return 0;
-}
-
-static int put_atomisp_acc_fw_load32(struct atomisp_acc_fw_load *kp,
-				struct atomisp_acc_fw_load32 __user *up)
-{
-	compat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);
-
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_acc_fw_load32)) ||
-		put_user(kp->size, &up->size) ||
-		put_user(kp->fw_handle, &up->fw_handle) ||
-		put_user(data, &up->data))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_acc_fw_arg32(struct atomisp_acc_fw_arg *kp,
-					struct atomisp_acc_fw_arg32 __user *up)
-{
-	compat_uptr_t value;
-
-	if (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_acc_fw_arg32)) ||
-		get_user(kp->fw_handle, &up->fw_handle) ||
-		get_user(kp->index, &up->index) ||
-		get_user(value, &up->value) ||
-		get_user(kp->size, &up->size))
-			return -EFAULT;
-
-	kp->value = compat_ptr(value);
-	return 0;
-}
-
-static int put_atomisp_acc_fw_arg32(struct atomisp_acc_fw_arg *kp,
-					struct atomisp_acc_fw_arg32 __user *up)
-{
-	compat_uptr_t value = (compat_uptr_t)((uintptr_t)kp->value);
-
-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_acc_fw_arg32)) ||
-		put_user(kp->fw_handle, &up->fw_handle) ||
-		put_user(kp->index, &up->index) ||
-		put_user(value, &up->value) ||
-		put_user(kp->size, &up->size))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_v4l2_private_int_data32(struct v4l2_private_int_data *kp,
-					struct v4l2_private_int_data32 __user *up)
-{
-	compat_uptr_t data;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct v4l2_private_int_data32)) ||
-		get_user(kp->size, &up->size) ||
-		get_user(data, &up->data) ||
-		get_user(kp->reserved[0], &up->reserved[0]) ||
-		get_user(kp->reserved[1], &up->reserved[1]))
-			return -EFAULT;
-
-	kp->data = compat_ptr(data);
-	return 0;
-}
-
-static int put_v4l2_private_int_data32(struct v4l2_private_int_data *kp,
-				struct v4l2_private_int_data32 __user *up)
-{
-	compat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);
-
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct v4l2_private_int_data32)) ||
-		put_user(kp->size, &up->size) ||
-		put_user(data, &up->data) ||
-		put_user(kp->reserved[0], &up->reserved[0]) ||
-		put_user(kp->reserved[1], &up->reserved[1]))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_shading_table32(struct atomisp_shading_table *kp,
-				struct atomisp_shading_table32 __user *up)
-{
-	unsigned int n = ATOMISP_NUM_SC_COLORS;
-
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_shading_table32)) ||
-#ifndef CSS20
-		get_user(kp->flags, &up->flags) ||
-#endif
-		get_user(kp->enable, &up->enable) ||
-		get_user(kp->sensor_width, &up->sensor_width) ||
-		get_user(kp->sensor_height, &up->sensor_height) ||
-		get_user(kp->width, &up->width) ||
-		get_user(kp->height, &up->height) ||
-		get_user(kp->fraction_bits, &up->fraction_bits))
-			return -EFAULT;
-
-	while (n-- > 0) {
-		uintptr_t *data_p = (uintptr_t *)&kp->data[n];
-
-		if (get_user((*data_p), &up->data[n]))
-			return -EFAULT;
-	}
-	return 0;
-}
-
-static int get_atomisp_acc_map32(struct atomisp_acc_map *kp,
-					struct atomisp_acc_map32 __user *up)
-{
-	compat_uptr_t user_ptr;
-
-	if (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_acc_map32)) ||
-		get_user(kp->flags, &up->flags) ||
-		get_user(kp->length, &up->length) ||
-		get_user(user_ptr, &up->user_ptr) ||
-		get_user(kp->css_ptr, &up->css_ptr) ||
-		get_user(kp->reserved[0], &up->reserved[0]) ||
-		get_user(kp->reserved[1], &up->reserved[1]) ||
-		get_user(kp->reserved[2], &up->reserved[2]) ||
-		get_user(kp->reserved[3], &up->reserved[3]))
-			return -EFAULT;
-
-	kp->user_ptr = compat_ptr(user_ptr);
-	return 0;
-}
-
-static int put_atomisp_acc_map32(struct atomisp_acc_map *kp,
-					struct atomisp_acc_map32 __user *up)
-{
-	compat_uptr_t user_ptr = (compat_uptr_t)((uintptr_t)kp->user_ptr);
-
-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct atomisp_acc_map32)) ||
-		put_user(kp->flags, &up->flags) ||
-		put_user(kp->length, &up->length) ||
-		put_user(user_ptr, &up->user_ptr) ||
-		put_user(kp->css_ptr, &up->css_ptr) ||
-		put_user(kp->reserved[0], &up->reserved[0]) ||
-		put_user(kp->reserved[1], &up->reserved[1]) ||
-		put_user(kp->reserved[2], &up->reserved[2]) ||
-		put_user(kp->reserved[3], &up->reserved[3]))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_acc_s_mapped_arg32(struct atomisp_acc_s_mapped_arg *kp,
-				struct atomisp_acc_s_mapped_arg32 __user *up)
-{
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_acc_s_mapped_arg32)) ||
-		get_user(kp->fw_handle, &up->fw_handle) ||
-		get_user(kp->memory, &up->memory) ||
-		get_user(kp->length, &up->length) ||
-		get_user(kp->css_ptr, &up->css_ptr))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int put_atomisp_acc_s_mapped_arg32(struct atomisp_acc_s_mapped_arg *kp,
-				struct atomisp_acc_s_mapped_arg32 __user *up)
-{
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_acc_s_mapped_arg32)) ||
-		put_user(kp->fw_handle, &up->fw_handle) ||
-		put_user(kp->memory, &up->memory) ||
-		put_user(kp->length, &up->length) ||
-		put_user(kp->css_ptr, &up->css_ptr))
-			return -EFAULT;
-
-	return 0;
-}
-
-static int get_atomisp_parameters32(struct atomisp_parameters *kp,
-					struct atomisp_parameters32 __user *up)
-{
-	unsigned int n = sizeof(struct atomisp_parameters32) /
-				sizeof(compat_uptr_t);
-
-	if (!access_ok(VERIFY_READ, up, sizeof(struct atomisp_parameters32)))
-			return -EFAULT;
-
-	while (n-- > 0) {
-		compat_uptr_t *src = (compat_uptr_t *)up + n;
-		uintptr_t *dst = (uintptr_t *)kp + n;
-
-		if (get_user((*dst), src))
-			return -EFAULT;
-	}
-
-	{
-		union {
-			struct atomisp_shading_table shading_table;
-			struct atomisp_morph_table   morph_table;
-#ifdef CSS20
-			struct atomisp_dis_coefficients dvs2_coefs;
-#endif
-		} karg;
-
-		/* handle shading table */
-		if (up->shading_table != 0) {
-			if (get_atomisp_shading_table32(&karg.shading_table,
-				(struct atomisp_shading_table32 __user *)
-						(uintptr_t)up->shading_table))
-				return -EFAULT;
-
-			kp->shading_table = compat_alloc_user_space(
-					sizeof(struct atomisp_shading_table));
-			if (!kp->shading_table)
-				return -EFAULT;
-
-			if (copy_to_user(kp->shading_table,
-					 &karg.shading_table,
-					 sizeof(struct atomisp_shading_table)))
-				return -EFAULT;
-		}
-
-		/* handle morph table */
-		if (up->morph_table != 0) {
-			if (get_atomisp_morph_table32(&karg.morph_table,
-					(struct atomisp_morph_table32 __user *)
-						(uintptr_t)up->morph_table))
-				return -EFAULT;
-
-			kp->morph_table = compat_alloc_user_space(
-					sizeof(struct atomisp_morph_table));
-			if (!kp->morph_table)
-				return -EFAULT;
-
-			if (copy_to_user(kp->morph_table, &karg.morph_table,
-					   sizeof(struct atomisp_morph_table)))
-				return -EFAULT;
-		}
-
-#ifdef CSS20
-		/* handle dvs2 coefficients */
-		if (up->dvs2_coefs != 0) {
-			if (get_atomisp_dis_coefficients32(&karg.dvs2_coefs,
-				(struct atomisp_dis_coefficients32 __user *)
-						(uintptr_t)up->dvs2_coefs))
-				return -EFAULT;
-
-			kp->dvs2_coefs = compat_alloc_user_space(
-				sizeof(struct atomisp_dis_coefficients));
-			if (!kp->dvs2_coefs)
-				return -EFAULT;
-
-			if (copy_to_user(kp->dvs2_coefs, &karg.dvs2_coefs,
-				sizeof(struct atomisp_dis_coefficients)))
-				return -EFAULT;
-		}
-		/*
-		 * we do not handle dvs1.0 coefficients, because it is replaced
-		 * by dvs2.0, thus not used any more.
-		 */
-#endif
-	}
-	return 0;
-}
-
-static int get_atomisp_acc_fw_load_to_pipe32(
-			struct atomisp_acc_fw_load_to_pipe *kp,
-			struct atomisp_acc_fw_load_to_pipe32 __user *up)
-{
-	compat_uptr_t data;
-	if (!access_ok(VERIFY_READ, up,
-			sizeof(struct atomisp_acc_fw_load_to_pipe32)) ||
-		get_user(kp->flags, &up->flags) ||
-		get_user(kp->fw_handle, &up->fw_handle) ||
-		get_user(kp->size, &up->size) ||
-		get_user(kp->type, &up->type) ||
-		get_user(kp->reserved[0], &up->reserved[0]) ||
-		get_user(kp->reserved[1], &up->reserved[1]) ||
-		get_user(kp->reserved[2], &up->reserved[2]) ||
-		get_user(data, &up->data))
-			return -EFAULT;
-
-	kp->data = compat_ptr(data);
-	return 0;
-}
-
-static int put_atomisp_acc_fw_load_to_pipe32(
-			struct atomisp_acc_fw_load_to_pipe *kp,
-			struct atomisp_acc_fw_load_to_pipe32 __user *up)
-{
-	compat_uptr_t data = (compat_uptr_t)((uintptr_t)kp->data);
-	if (!access_ok(VERIFY_WRITE, up,
-			sizeof(struct atomisp_acc_fw_load_to_pipe32)) ||
-		put_user(kp->flags, &up->flags) ||
-		put_user(kp->fw_handle, &up->fw_handle) ||
-		put_user(kp->size, &up->size) ||
-		put_user(kp->type, &up->type) ||
-		put_user(kp->reserved[0], &up->reserved[0]) ||
-		put_user(kp->reserved[1], &up->reserved[1]) ||
-		put_user(kp->reserved[2], &up->reserved[2]) ||
-		put_user(data, &up->data))
-			return -EFAULT;
-
-	return 0;
-}
-
-static long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	long ret = -ENOIOCTLCMD;
-
-	if (file->f_op->unlocked_ioctl)
-		ret = file->f_op->unlocked_ioctl(file, cmd, arg);
-
-	return ret;
-}
-
-long atomisp_do_compat_ioctl(struct file *file,
-			    unsigned int cmd, unsigned long arg)
-{
-	union {
-		struct atomisp_histogram his;
-		struct atomisp_dis_statistics dis_s;
-		struct atomisp_dis_coefficients dis_c;
-		struct atomisp_dvs_6axis_config dvs_c;
-		struct atomisp_3a_statistics s3a_s;
-		struct atomisp_morph_table mor_t;
-		struct v4l2_framebuffer v4l2_buf;
-		struct atomisp_overlay overlay;
-		struct atomisp_calibration_group cal_grp;
-		struct atomisp_acc_fw_load acc_fw_load;
-		struct atomisp_acc_fw_arg acc_fw_arg;
-		struct v4l2_private_int_data v4l2_pri_data;
-		struct atomisp_shading_table shd_tbl;
-		struct atomisp_acc_map acc_map;
-		struct atomisp_acc_s_mapped_arg acc_map_arg;
-		struct atomisp_parameters param;
-		struct atomisp_acc_fw_load_to_pipe acc_fw_to_pipe;
-	} karg;
-	mm_segment_t old_fs;
-	void __user *up = compat_ptr(arg);
-	long err = -ENOIOCTLCMD;
-
-	/* First, convert the command. */
-	switch (cmd) {
-	case ATOMISP_IOC_G_HISTOGRAM32:
-		cmd = ATOMISP_IOC_G_HISTOGRAM;
-		break;
-	case ATOMISP_IOC_S_HISTOGRAM32:
-		cmd = ATOMISP_IOC_S_HISTOGRAM;
-		break;
-	case ATOMISP_IOC_G_DIS_STAT32:
-		cmd = ATOMISP_IOC_G_DIS_STAT;
-		break;
-	case ATOMISP_IOC_S_DIS_COEFS32:
-		cmd = ATOMISP_IOC_S_DIS_COEFS;
-		break;
-	case ATOMISP_IOC_S_DIS_VECTOR32:
-		cmd = ATOMISP_IOC_S_DIS_VECTOR;
-		break;
-	case ATOMISP_IOC_G_3A_STAT32:
-		cmd = ATOMISP_IOC_G_3A_STAT;
-		break;
-	case ATOMISP_IOC_G_ISP_GDC_TAB32:
-		cmd = ATOMISP_IOC_G_ISP_GDC_TAB;
-		break;
-	case ATOMISP_IOC_S_ISP_GDC_TAB32:
-		cmd = ATOMISP_IOC_S_ISP_GDC_TAB;
-		break;
-	case ATOMISP_IOC_S_ISP_FPN_TABLE32:
-		cmd = ATOMISP_IOC_S_ISP_FPN_TABLE;
-		break;
-	case ATOMISP_IOC_G_ISP_OVERLAY32:
-		cmd = ATOMISP_IOC_G_ISP_OVERLAY;
-		break;
-	case ATOMISP_IOC_S_ISP_OVERLAY32:
-		cmd = ATOMISP_IOC_S_ISP_OVERLAY;
-		break;
-	case ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP32:
-		cmd = ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP;
-		break;
-	case ATOMISP_IOC_ACC_LOAD32:
-		cmd = ATOMISP_IOC_ACC_LOAD;
-		break;
-	case ATOMISP_IOC_ACC_S_ARG32:
-		cmd = ATOMISP_IOC_ACC_S_ARG;
-		break;
-	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA32:
-		cmd = ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA;
-		break;
-	case ATOMISP_IOC_S_ISP_SHD_TAB32:
-		cmd = ATOMISP_IOC_S_ISP_SHD_TAB;
-		break;
-	case ATOMISP_IOC_ACC_DESTAB32:
-		cmd = ATOMISP_IOC_ACC_DESTAB;
-		break;
-	case ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA32:
-		cmd = ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA;
-		break;
-	case ATOMISP_IOC_ACC_MAP32:
-		cmd = ATOMISP_IOC_ACC_MAP;
-		break;
-	case ATOMISP_IOC_ACC_UNMAP32:
-		cmd = ATOMISP_IOC_ACC_UNMAP;
-		break;
-	case ATOMISP_IOC_ACC_S_MAPPED_ARG32:
-		cmd = ATOMISP_IOC_ACC_S_MAPPED_ARG;
-		break;
-	case ATOMISP_IOC_S_PARAMETERS32:
-		cmd = ATOMISP_IOC_S_PARAMETERS;
-		break;
-	case ATOMISP_IOC_ACC_LOAD_TO_PIPE32:
-		cmd = ATOMISP_IOC_ACC_LOAD_TO_PIPE;
-		break;
-	}
-
-	switch (cmd) {
-	case ATOMISP_IOC_G_HISTOGRAM:
-	case ATOMISP_IOC_S_HISTOGRAM:
-		err = get_atomisp_histogram32(&karg.his, up);
-		break;
-	case ATOMISP_IOC_G_DIS_STAT:
-		err = get_atomisp_dis_statistics32(&karg.dis_s, up);
-		break;
-	case ATOMISP_IOC_S_DIS_COEFS:
-		err = get_atomisp_dis_coefficients32(&karg.dis_c, up);
-		break;
-	case ATOMISP_IOC_S_DIS_VECTOR:
-		err = get_atomisp_dvs_6axis_config32(&karg.dvs_c, up);
-		break;
-	case ATOMISP_IOC_G_3A_STAT:
-		err = get_atomisp_3a_statistics32(&karg.s3a_s, up);
-		break;
-	case ATOMISP_IOC_G_ISP_GDC_TAB:
-	case ATOMISP_IOC_S_ISP_GDC_TAB:
-		err = get_atomisp_morph_table32(&karg.mor_t, up);
-		break;
-	case ATOMISP_IOC_S_ISP_FPN_TABLE:
-		err = get_v4l2_framebuffer32(&karg.v4l2_buf, up);
-		break;
-	case ATOMISP_IOC_G_ISP_OVERLAY:
-	case ATOMISP_IOC_S_ISP_OVERLAY:
-		err = get_atomisp_overlay32(&karg.overlay, up);
-		break;
-	case ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP:
-		err = get_atomisp_calibration_group32(&karg.cal_grp, up);
-		break;
-	case ATOMISP_IOC_ACC_LOAD:
-		err = get_atomisp_acc_fw_load32(&karg.acc_fw_load, up);
-		break;
-	case ATOMISP_IOC_ACC_S_ARG:
-	case ATOMISP_IOC_ACC_DESTAB:
-		err = get_atomisp_acc_fw_arg32(&karg.acc_fw_arg, up);
-		break;
-	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
-	case ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA:
-		err = get_v4l2_private_int_data32(&karg.v4l2_pri_data, up);
-		break;
-	case ATOMISP_IOC_S_ISP_SHD_TAB:
-		err = get_atomisp_shading_table32(&karg.shd_tbl, up);
-		break;
-	case ATOMISP_IOC_ACC_MAP:
-	case ATOMISP_IOC_ACC_UNMAP:
-		err = get_atomisp_acc_map32(&karg.acc_map, up);
-		break;
-	case ATOMISP_IOC_ACC_S_MAPPED_ARG:
-		err = get_atomisp_acc_s_mapped_arg32(&karg.acc_map_arg, up);
-		break;
-	case ATOMISP_IOC_S_PARAMETERS:
-		err = get_atomisp_parameters32(&karg.param, up);
-		break;
-	case ATOMISP_IOC_ACC_LOAD_TO_PIPE:
-		err = get_atomisp_acc_fw_load_to_pipe32(&karg.acc_fw_to_pipe,
-							up);
-		break;
-	}
-	if (err)
-		return err;
-
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-	err = native_ioctl(file, cmd, (unsigned long)&karg);
-	set_fs(old_fs);
-	if (err)
-		return err;
-
-	switch (cmd) {
-	case ATOMISP_IOC_G_HISTOGRAM:
-		err = put_atomisp_histogram32(&karg.his, up);
-		break;
-	case ATOMISP_IOC_G_DIS_STAT:
-		err = put_atomisp_dis_statistics32(&karg.dis_s, up);
-		break;
-	case ATOMISP_IOC_G_3A_STAT:
-		err = put_atomisp_3a_statistics32(&karg.s3a_s, up);
-		break;
-	case ATOMISP_IOC_G_ISP_GDC_TAB:
-		err = put_atomisp_morph_table32(&karg.mor_t, up);
-		break;
-	case ATOMISP_IOC_G_ISP_OVERLAY:
-		err = put_atomisp_overlay32(&karg.overlay, up);
-		break;
-	case ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP:
-		err = put_atomisp_calibration_group32(&karg.cal_grp, up);
-		break;
-	case ATOMISP_IOC_ACC_LOAD:
-		err = put_atomisp_acc_fw_load32(&karg.acc_fw_load, up);
-		break;
-	case ATOMISP_IOC_ACC_S_ARG:
-	case ATOMISP_IOC_ACC_DESTAB:
-		err = put_atomisp_acc_fw_arg32(&karg.acc_fw_arg, up);
-		break;
-	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
-	case ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA:
-		err = put_v4l2_private_int_data32(&karg.v4l2_pri_data, up);
-		break;
-	case ATOMISP_IOC_ACC_MAP:
-	case ATOMISP_IOC_ACC_UNMAP:
-		err = put_atomisp_acc_map32(&karg.acc_map, up);
-		break;
-	case ATOMISP_IOC_ACC_S_MAPPED_ARG:
-		err = put_atomisp_acc_s_mapped_arg32(&karg.acc_map_arg, up);
-		break;
-	case ATOMISP_IOC_ACC_LOAD_TO_PIPE:
-		err = put_atomisp_acc_fw_load_to_pipe32(&karg.acc_fw_to_pipe,
-							up);
-		break;
-	}
-
-	return err;
-}
-
-long atomisp_compat_ioctl32(struct file *file,
-			    unsigned int cmd, unsigned long arg)
-{
-
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	long ret = -ENOIOCTLCMD;
-
-	if (!file->f_op->unlocked_ioctl)
-		return ret;
-
-	switch (cmd) {
-	case ATOMISP_IOC_G_XNR:
-	case ATOMISP_IOC_S_XNR:
-	case ATOMISP_IOC_G_NR:
-	case ATOMISP_IOC_S_NR:
-	case ATOMISP_IOC_G_TNR:
-	case ATOMISP_IOC_S_TNR:
-	case ATOMISP_IOC_G_BLACK_LEVEL_COMP:
-	case ATOMISP_IOC_S_BLACK_LEVEL_COMP:
-	case ATOMISP_IOC_G_EE:
-	case ATOMISP_IOC_S_EE:
-	case ATOMISP_IOC_S_DIS_VECTOR:
-	case ATOMISP_IOC_G_ISP_PARM:
-	case ATOMISP_IOC_S_ISP_PARM:
-	case ATOMISP_IOC_G_ISP_GAMMA:
-	case ATOMISP_IOC_S_ISP_GAMMA:
-	case ATOMISP_IOC_ISP_MAKERNOTE:
-	case ATOMISP_IOC_G_ISP_MACC:
-	case ATOMISP_IOC_S_ISP_MACC:
-	case ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION:
-	case ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION:
-	case ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION:
-	case ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION:
-	case ATOMISP_IOC_G_ISP_CTC:
-	case ATOMISP_IOC_S_ISP_CTC:
-	case ATOMISP_IOC_G_ISP_WHITE_BALANCE:
-	case ATOMISP_IOC_S_ISP_WHITE_BALANCE:
-	case ATOMISP_IOC_CAMERA_BRIDGE:
-	case ATOMISP_IOC_G_SENSOR_MODE_DATA:
-	case ATOMISP_IOC_S_EXPOSURE:
-	case ATOMISP_IOC_G_3A_CONFIG:
-	case ATOMISP_IOC_S_3A_CONFIG:
-	case ATOMISP_IOC_ACC_UNLOAD:
-	case ATOMISP_IOC_ACC_START:
-	case ATOMISP_IOC_ACC_WAIT:
-	case ATOMISP_IOC_ACC_ABORT:
-	case ATOMISP_IOC_G_ISP_GAMMA_CORRECTION:
-	case ATOMISP_IOC_S_ISP_GAMMA_CORRECTION:
-	case ATOMISP_IOC_S_CONT_CAPTURE_CONFIG:
-		ret = native_ioctl(file, cmd, arg);
-		break;
-
-	case ATOMISP_IOC_G_HISTOGRAM32:
-	case ATOMISP_IOC_S_HISTOGRAM32:
-	case ATOMISP_IOC_G_DIS_STAT32:
-	case ATOMISP_IOC_S_DIS_COEFS32:
-	case ATOMISP_IOC_S_DIS_VECTOR32:
-	case ATOMISP_IOC_G_3A_STAT32:
-	case ATOMISP_IOC_G_ISP_GDC_TAB32:
-	case ATOMISP_IOC_S_ISP_GDC_TAB32:
-	case ATOMISP_IOC_S_ISP_FPN_TABLE32:
-	case ATOMISP_IOC_G_ISP_OVERLAY32:
-	case ATOMISP_IOC_S_ISP_OVERLAY32:
-	case ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP32:
-	case ATOMISP_IOC_ACC_LOAD32:
-	case ATOMISP_IOC_ACC_S_ARG32:
-	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA32:
-	case ATOMISP_IOC_S_ISP_SHD_TAB32:
-	case ATOMISP_IOC_ACC_DESTAB32:
-	case ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA32:
-	case ATOMISP_IOC_ACC_MAP32:
-	case ATOMISP_IOC_ACC_UNMAP32:
-	case ATOMISP_IOC_ACC_S_MAPPED_ARG32:
-	case ATOMISP_IOC_S_PARAMETERS32:
-	case ATOMISP_IOC_ACC_LOAD_TO_PIPE32:
-		ret = atomisp_do_compat_ioctl(file, cmd, arg);
-		break;
-
-	default:
-		dev_warn(isp->dev,
-			"%s: unknown ioctl '%c', dir=%d, #%d (0x%08x)\n",
-			__func__, _IOC_TYPE(cmd), _IOC_DIR(cmd), _IOC_NR(cmd),
-			cmd);
-		break;
-	}
-	return ret;
-}
-#endif /* CONFIG_COMPAT */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.h
deleted file mode 100644
index 10e02f7..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_compat_ioctl32.h
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Support for Intel Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef __ATOMISP_COMPAT_IOCTL32_H__
-#define __ATOMISP_COMPAT_IOCTL32_H__
-
-#include <linux/compat.h>
-#include <linux/videodev2.h>
-
-#include "atomisp_compat.h"
-
-struct atomisp_histogram32 {
-	unsigned int num_elements;
-	compat_uptr_t data;
-};
-
-struct atomisp_dvs2_stat_types32 {
-	compat_uptr_t odd_real; /**< real part of the odd statistics*/
-	compat_uptr_t odd_imag; /**< imaginary part of the odd statistics*/
-	compat_uptr_t even_real;/**< real part of the even statistics*/
-	compat_uptr_t even_imag;/**< imaginary part of the even statistics*/
-};
-
-struct atomisp_dvs2_coef_types32 {
-	compat_uptr_t odd_real; /**< real part of the odd coefficients*/
-	compat_uptr_t odd_imag; /**< imaginary part of the odd coefficients*/
-	compat_uptr_t even_real;/**< real part of the even coefficients*/
-	compat_uptr_t even_imag;/**< imaginary part of the even coefficients*/
-};
-
-struct atomisp_dvs2_statistics32 {
-	struct atomisp_dvs_grid_info grid_info;
-	struct atomisp_dvs2_stat_types32 hor_prod;
-	struct atomisp_dvs2_stat_types32 ver_prod;
-};
-
-struct atomisp_dis_statistics32 {
-#ifdef CSS20
-	struct atomisp_dvs2_statistics32 dvs2_stat;
-	uint32_t exp_id;
-#else /* CSS20 */
-	struct atomisp_grid_info grid_info;
-	compat_uptr_t vertical_projections;
-	compat_uptr_t horizontal_projections;
-#endif
-};
-
-struct atomisp_dis_coefficients32 {
-#ifdef CSS20
-	struct atomisp_dvs_grid_info grid_info;
-	struct atomisp_dvs2_coef_types32 hor_coefs;
-	struct atomisp_dvs2_coef_types32 ver_coefs;
-#else /* CSS20 */
-	struct atomisp_grid_info grid_info;
-	compat_uptr_t vertical_coefficients;
-	compat_uptr_t horizontal_coefficients;
-#endif /* CSS20 */
-};
-
-struct atomisp_3a_statistics32 {
-	struct atomisp_grid_info  grid_info;
-	compat_uptr_t data;
-#ifdef CSS20
-	compat_uptr_t rgby_data;
-#endif
-};
-
-struct atomisp_morph_table32 {
-#ifdef CSS20
-	unsigned int enabled;
-#endif
-	unsigned int height;
-	unsigned int width;	/* number of valid elements per line */
-	compat_uptr_t coordinates_x[ATOMISP_MORPH_TABLE_NUM_PLANES];
-	compat_uptr_t coordinates_y[ATOMISP_MORPH_TABLE_NUM_PLANES];
-};
-
-struct v4l2_framebuffer32 {
-	__u32			capability;
-	__u32			flags;
-	compat_uptr_t		base;
-	struct v4l2_pix_format	fmt;
-};
-
-struct atomisp_overlay32 {
-	/* the frame containing the overlay data The overlay frame width should
-	 * be the multiples of 2*ISP_VEC_NELEMS. The overlay frame height
-	 * should be the multiples of 2.
-	 */
-	compat_uptr_t frame;
-	/* Y value of overlay background */
-	unsigned char bg_y;
-	/* U value of overlay background */
-	char bg_u;
-	/* V value of overlay background */
-	char bg_v;
-	/* the blending percent of input data for Y subpixels */
-	unsigned char blend_input_perc_y;
-	/* the blending percent of input data for U subpixels */
-	unsigned char blend_input_perc_u;
-	/* the blending percent of input data for V subpixels */
-	unsigned char blend_input_perc_v;
-	/* the blending percent of overlay data for Y subpixels */
-	unsigned char blend_overlay_perc_y;
-	/* the blending percent of overlay data for U subpixels */
-	unsigned char blend_overlay_perc_u;
-	/* the blending percent of overlay data for V subpixels */
-	unsigned char blend_overlay_perc_v;
-	/* the overlay start x pixel position on output frame It should be the
-	   multiples of 2*ISP_VEC_NELEMS. */
-	unsigned int overlay_start_x;
-	/* the overlay start y pixel position on output frame It should be the
-	   multiples of 2. */
-	unsigned int overlay_start_y;
-};
-
-struct atomisp_calibration_group32 {
-	unsigned int size;
-	unsigned int type;
-	compat_uptr_t calb_grp_values;
-};
-
-struct atomisp_acc_fw_load32 {
-	unsigned int size;
-	unsigned int fw_handle;
-	compat_uptr_t data;
-};
-
-struct atomisp_acc_fw_arg32 {
-	unsigned int fw_handle;
-	unsigned int index;
-	compat_uptr_t value;
-	compat_size_t size;
-};
-
-struct v4l2_private_int_data32 {
-	__u32 size;
-	compat_uptr_t data;
-	__u32 reserved[2];
-};
-
-struct atomisp_shading_table32 {
-#ifdef CSS20
-	__u32 enable;
-#else
-	__u8 flags;
-	__u8 enable;
-#endif
-	__u32 sensor_width;
-	__u32 sensor_height;
-	__u32 width;
-	__u32 height;
-	__u32 fraction_bits;
-
-	compat_uptr_t data[ATOMISP_NUM_SC_COLORS];
-};
-
-struct atomisp_acc_map32 {
-	__u32 flags;			/* Flags, see list below */
-	__u32 length;			/* Length of data in bytes */
-	compat_uptr_t user_ptr;		/* Pointer into user space */
-	compat_ulong_t css_ptr;		/* Pointer into CSS address space */
-	__u32 reserved[4];		/* Set to zero */
-};
-
-struct atomisp_acc_s_mapped_arg32 {
-	unsigned int fw_handle;
-	__u32 memory;			/* one of enum atomisp_acc_memory */
-	compat_size_t length;
-	compat_ulong_t css_ptr;
-};
-
-#ifdef CSS20
-struct atomisp_parameters32 {
-	compat_uptr_t wb_config;  /* White Balance config */
-	compat_uptr_t cc_config;  /* Color Correction config */
-	compat_uptr_t tnr_config; /* Temporal Noise Reduction */
-	compat_uptr_t ecd_config; /* Eigen Color Demosaicing */
-	compat_uptr_t ynr_config; /* Y(Luma) Noise Reduction */
-	compat_uptr_t fc_config;  /* Fringe Control */
-	compat_uptr_t cnr_config; /* Chroma Noise Reduction */
-	compat_uptr_t macc_config;  /* MACC */
-	compat_uptr_t ctc_config; /* Chroma Tone Control */
-	compat_uptr_t aa_config;  /* Anti-Aliasing */
-	compat_uptr_t baa_config;  /* Anti-Aliasing */
-	compat_uptr_t ce_config;
-	compat_uptr_t dvs_6axis_config;
-	compat_uptr_t ob_config;  /* Objective Black config */
-	compat_uptr_t dp_config;  /* Dead Pixel config */
-	compat_uptr_t nr_config;  /* Noise Reduction config */
-	compat_uptr_t ee_config;  /* Edge Enhancement config */
-	compat_uptr_t de_config;  /* Demosaic config */
-	compat_uptr_t gc_config;  /* Gamma Correction config */
-	compat_uptr_t anr_config; /* Advanced Noise Reduction */
-	compat_uptr_t a3a_config; /* 3A Statistics config */
-	compat_uptr_t xnr_config; /* eXtra Noise Reduction */
-	compat_uptr_t dz_config;  /* Digital Zoom */
-	compat_uptr_t yuv2rgb_cc_config; /* Color
-							Correction config */
-	compat_uptr_t rgb2yuv_cc_config; /* Color
-							Correction config */
-	compat_uptr_t macc_table;
-	compat_uptr_t gamma_table;
-	compat_uptr_t ctc_table;
-	compat_uptr_t xnr_table;
-	compat_uptr_t r_gamma_table;
-	compat_uptr_t g_gamma_table;
-	compat_uptr_t b_gamma_table;
-	compat_uptr_t motion_vector; /* For 2-axis DVS */
-	compat_uptr_t shading_table;
-	compat_uptr_t morph_table;
-	compat_uptr_t dvs_coefs; /* DVS 1.0 coefficients */
-	compat_uptr_t dvs2_coefs; /* DVS 2.0 coefficients */
-	compat_uptr_t capture_config;
-	compat_uptr_t anr_thres;
-};
-#else /* CSS20 */
-struct atomisp_parameters32 {
-	compat_uptr_t wb_config;
-	compat_uptr_t cc_config;
-	compat_uptr_t ob_config;
-	compat_uptr_t de_config;
-	compat_uptr_t ce_config;
-	compat_uptr_t dp_config;
-	compat_uptr_t nr_config;
-	compat_uptr_t ee_config;
-	compat_uptr_t tnr_config;
-	compat_uptr_t shading_table;
-	compat_uptr_t morph_table;
-	compat_uptr_t macc_config;
-	compat_uptr_t gamma_table;
-	compat_uptr_t ctc_table;
-	compat_uptr_t xnr_config;
-	compat_uptr_t gc_config;
-	compat_uptr_t a3a_config;
-};
-#endif /* CSS20 */
-
-struct atomisp_acc_fw_load_to_pipe32 {
-	__u32 flags;			/* Flags, see below for valid values */
-	unsigned int fw_handle;		/* Handle, filled by kernel. */
-	__u32 size;			/* Firmware binary size */
-	compat_uptr_t data;		/* Pointer to firmware */
-	__u32 type;			/* Binary type */
-	__u32 reserved[3];		/* Set to zero */
-};
-
-struct atomisp_dvs_6axis_config32 {
-	uint32_t exp_id;
-	uint32_t width_y;
-	uint32_t height_y;
-	uint32_t width_uv;
-	uint32_t height_uv;
-	compat_uptr_t xcoords_y;
-	compat_uptr_t ycoords_y;
-	compat_uptr_t xcoords_uv;
-	compat_uptr_t ycoords_uv;
-};
-
-#define ATOMISP_IOC_G_HISTOGRAM32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 6, struct atomisp_histogram32)
-#define ATOMISP_IOC_S_HISTOGRAM32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 7, struct atomisp_histogram32)
-
-#define ATOMISP_IOC_G_DIS_STAT32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 14, struct atomisp_dis_statistics32)
-#define ATOMISP_IOC_S_DIS_COEFS32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 15, struct atomisp_dis_coefficients32)
-
-#define ATOMISP_IOC_S_DIS_VECTOR32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 16, struct atomisp_dvs_6axis_config32)
-
-#define ATOMISP_IOC_G_3A_STAT32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 17, struct atomisp_3a_statistics32)
-
-#define ATOMISP_IOC_G_ISP_GDC_TAB32 \
-	_IOR('v', BASE_VIDIOC_PRIVATE + 22, struct atomisp_morph_table32)
-#define ATOMISP_IOC_S_ISP_GDC_TAB32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 23, struct atomisp_morph_table32)
-
-#define ATOMISP_IOC_S_ISP_FPN_TABLE32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 35, struct v4l2_framebuffer32)
-
-#define ATOMISP_IOC_G_ISP_OVERLAY32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 36, struct atomisp_overlay32)
-#define ATOMISP_IOC_S_ISP_OVERLAY32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 37, struct atomisp_overlay32)
-
-#define ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 41, struct atomisp_calibration_group32)
-
-#define ATOMISP_IOC_ACC_LOAD32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 44, struct atomisp_acc_fw_load32)
-
-#define ATOMISP_IOC_ACC_S_ARG32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 46, struct atomisp_acc_fw_arg32)
-
-#define ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 50, struct v4l2_private_int_data32)
-
-#define ATOMISP_IOC_S_ISP_SHD_TAB32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 51, struct atomisp_shading_table32)
-
-#define ATOMISP_IOC_ACC_DESTAB32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 54, struct atomisp_acc_fw_arg32)
-
-#define ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 57, struct v4l2_private_int_data32)
-
-#define ATOMISP_IOC_ACC_MAP32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 58, struct atomisp_acc_map32)
-
-#define ATOMISP_IOC_ACC_UNMAP32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 59, struct atomisp_acc_map32)
-
-#define ATOMISP_IOC_ACC_S_MAPPED_ARG32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 60, struct atomisp_acc_s_mapped_arg32)
-
-#define ATOMISP_IOC_S_PARAMETERS32 \
-	_IOW('v', BASE_VIDIOC_PRIVATE + 61, struct atomisp_parameters32)
-
-#define ATOMISP_IOC_ACC_LOAD_TO_PIPE32 \
-	_IOWR('v', BASE_VIDIOC_PRIVATE + 63, struct atomisp_acc_fw_load_to_pipe32)
-
-#endif /* __ATOMISP_COMPAT_IOCTL32_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.c
deleted file mode 100644
index 24f7955..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.c
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <media/v4l2-event.h>
-#include <media/v4l2-mediabus.h>
-#include "atomisp_internal.h"
-
-static struct v4l2_mbus_framefmt *__csi2_get_format(
-	struct atomisp_mipi_csi2_device *csi2, struct v4l2_subdev_fh *fh,
-	enum v4l2_subdev_format_whence which, unsigned int pad)
-{
-	if (which == V4L2_SUBDEV_FORMAT_TRY)
-		return v4l2_subdev_get_try_format(fh, pad);
-	else
-		return &csi2->formats[pad];
-}
-
-/*
- * csi2_enum_mbus_code - Handle pixel format enumeration
- * @sd     : pointer to v4l2 subdev structure
- * @fh     : V4L2 subdev file handle
- * @code   : pointer to v4l2_subdev_pad_mbus_code_enum structure
- * return -EINVAL or zero on success
-*/
-static int csi2_enum_mbus_code(struct v4l2_subdev *sd,
-			struct v4l2_subdev_fh *fh,
-			struct v4l2_subdev_mbus_code_enum *code)
-{
-	const struct atomisp_in_fmt_conv *ic = atomisp_in_fmt_conv;
-	unsigned int i = 0;
-
-	while (ic->code) {
-		if (i == code->index) {
-			code->code = ic->code;
-			return 0;
-		}
-		i++, ic++;
-	}
-
-	return -EINVAL;
-}
-
-/*
- * csi2_get_format - Handle get format by pads subdev method
- * @sd : pointer to v4l2 subdev structure
- * @fh : V4L2 subdev file handle
- * @pad: pad num
- * @fmt: pointer to v4l2 format structure
- * return -EINVAL or zero on sucess
-*/
-static int csi2_get_format(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
-{
-	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
-	struct v4l2_mbus_framefmt *format;
-
-	format = __csi2_get_format(csi2, fh, fmt->which, fmt->pad);
-
-	fmt->format = *format;
-
-	return 0;
-}
-
-int atomisp_csi2_set_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			  unsigned int which, uint16_t pad,
-			  struct v4l2_mbus_framefmt *ffmt)
-{
-	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
-	struct v4l2_mbus_framefmt *actual_ffmt =
-		__csi2_get_format(csi2, fh, which, pad);
-
-	if (pad == CSI2_PAD_SINK) {
-		const struct atomisp_in_fmt_conv *ic;
-		struct v4l2_mbus_framefmt tmp_ffmt;
-
-		ic = atomisp_find_in_fmt_conv(ffmt->code);
-		if (ic)
-			actual_ffmt->code = ic->code;
-		else
-			actual_ffmt->code = atomisp_in_fmt_conv[0].code;
-
-		actual_ffmt->width = clamp_t(
-			u32, ffmt->width, ATOM_ISP_MIN_WIDTH,
-			ATOM_ISP_MAX_WIDTH);
-		actual_ffmt->height = clamp_t(
-			u32, ffmt->height, ATOM_ISP_MIN_HEIGHT,
-			ATOM_ISP_MAX_HEIGHT);
-
-		tmp_ffmt = *ffmt = *actual_ffmt;
-
-		return atomisp_csi2_set_ffmt(sd, fh, which, CSI2_PAD_SOURCE,
-					     &tmp_ffmt);
-	}
-
-	/* FIXME: DPCM decompression */
-	*actual_ffmt = *ffmt =
-		*__csi2_get_format(csi2, fh, which, CSI2_PAD_SINK);
-
-	return 0;
-}
-
-/*
- * csi2_set_format - Handle set format by pads subdev method
- * @sd : pointer to v4l2 subdev structure
- * @fh : V4L2 subdev file handle
- * @pad: pad num
- * @fmt: pointer to v4l2 format structure
- * return -EINVAL or zero on success
-*/
-static int csi2_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-		    struct v4l2_subdev_format *fmt)
-{
-	return atomisp_csi2_set_ffmt(sd, fh, fmt->which, fmt->pad,
-				     &fmt->format);
-}
-
-/*
- * csi2_set_stream - Enable/Disable streaming on the CSI2 module
- * @sd: ISP CSI2 V4L2 subdevice
- * @enable: Enable/disable stream (1/0)
- *
- * Return 0 on success or a negative error code otherwise.
-*/
-static int csi2_set_stream(struct v4l2_subdev *sd, int enable)
-{
-	 return 0;
-}
-
-/* subdev core operations */
-static const struct v4l2_subdev_core_ops csi2_core_ops = {
-	.queryctrl = v4l2_subdev_queryctrl,
-	.querymenu = v4l2_subdev_querymenu,
-	.g_ctrl = v4l2_subdev_g_ctrl,
-	.s_ctrl = v4l2_subdev_s_ctrl,
-	.g_ext_ctrls = v4l2_subdev_g_ext_ctrls,
-	.try_ext_ctrls = v4l2_subdev_try_ext_ctrls,
-	.s_ext_ctrls = v4l2_subdev_s_ext_ctrls,
-};
-
-/* subdev video operations */
-static const struct v4l2_subdev_video_ops csi2_video_ops = {
-	.s_stream = csi2_set_stream,
-};
-
-/* subdev pad operations */
-static const struct v4l2_subdev_pad_ops csi2_pad_ops = {
-	.enum_mbus_code = csi2_enum_mbus_code,
-	.get_fmt = csi2_get_format,
-	.set_fmt = csi2_set_format,
-	.link_validate = v4l2_subdev_link_validate_default,
-};
-
-/* subdev operations */
-static const struct v4l2_subdev_ops csi2_ops = {
-	.core = &csi2_core_ops,
-	.video = &csi2_video_ops,
-	.pad = &csi2_pad_ops,
-};
-
-
-/*
- * csi2_link_setup - Setup CSI2 connections.
- * @entity : Pointer to media entity structure
- * @local  : Pointer to local pad array
- * @remote : Pointer to remote pad array
- * @flags  : Link flags
- * return -EINVAL or zero on success
-*/
-static int csi2_link_setup(struct media_entity *entity,
-	    const struct media_pad *local,
-	    const struct media_pad *remote, u32 flags)
-{
-	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
-	struct atomisp_mipi_csi2_device *csi2 = v4l2_get_subdevdata(sd);
-	u32 result = local->index | media_entity_type(remote->entity);
-
-	switch (result) {
-	case CSI2_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:
-		/* not supported yet */
-		return -EINVAL;
-
-	case CSI2_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:
-		if (flags & MEDIA_LNK_FL_ENABLED) {
-			if (csi2->output & ~CSI2_OUTPUT_ISP_SUBDEV)
-				return -EBUSY;
-			csi2->output |= CSI2_OUTPUT_ISP_SUBDEV;
-		} else {
-			csi2->output &= ~CSI2_OUTPUT_ISP_SUBDEV;
-		}
-		break;
-
-	default:
-		/* Link from camera to CSI2 is fixed... */
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/* media operations */
-static const struct media_entity_operations csi2_media_ops = {
-	.link_setup = csi2_link_setup,
-	.link_validate = v4l2_subdev_link_validate,
-};
-
-/*
-* ispcsi2_init_entities - Initialize subdev and media entity.
-* @csi2: Pointer to ispcsi2 structure.
-* return -ENOMEM or zero on success
-*/
-static int mipi_csi2_init_entities(struct atomisp_mipi_csi2_device *csi2,
-					int port)
-{
-	struct v4l2_subdev *sd = &csi2->subdev;
-	struct media_pad *pads = csi2->pads;
-	struct media_entity *me = &sd->entity;
-	int ret;
-
-	v4l2_subdev_init(sd, &csi2_ops);
-	snprintf(sd->name, sizeof(sd->name), "ATOM ISP CSI2-port%d", port);
-
-	v4l2_set_subdevdata(sd, csi2);
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-
-	pads[CSI2_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
-	pads[CSI2_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
-
-	me->ops = &csi2_media_ops;
-	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
-	ret = media_entity_init(me, CSI2_PADS_NUM, pads, 0);
-	if (ret < 0)
-		return ret;
-
-	csi2->formats[CSI2_PAD_SINK].code =
-		csi2->formats[CSI2_PAD_SOURCE].code =
-		atomisp_in_fmt_conv[0].code;
-
-	return 0;
-}
-
-void
-atomisp_mipi_csi2_unregister_entities(struct atomisp_mipi_csi2_device *csi2)
-{
-	media_entity_cleanup(&csi2->subdev.entity);
-	v4l2_device_unregister_subdev(&csi2->subdev);
-}
-
-int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
-			struct v4l2_device *vdev)
-{
-	int ret;
-
-	/* Register the subdev and video nodes. */
-	ret = v4l2_device_register_subdev(vdev, &csi2->subdev);
-	if (ret < 0)
-		goto error;
-
-	return 0;
-
-error:
-	atomisp_mipi_csi2_unregister_entities(csi2);
-	return ret;
-}
-
-/*
- * atomisp_mipi_csi2_cleanup - Routine for module driver cleanup
-*/
-void atomisp_mipi_csi2_cleanup(struct atomisp_device *isp)
-{
-}
-
-
-int atomisp_mipi_csi2_init(struct atomisp_device *isp)
-{
-	struct atomisp_mipi_csi2_device *csi2_port;
-	unsigned int i;
-	int ret;
-
-	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
-		csi2_port = &isp->csi2_port[i];
-		csi2_port->isp = isp;
-		ret = mipi_csi2_init_entities(csi2_port, i);
-		if (ret < 0)
-			goto fail;
-	}
-
-	return 0;
-
-fail:
-	atomisp_mipi_csi2_cleanup(isp);
-	return ret;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.h
deleted file mode 100644
index df7b657..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_csi2.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef __ATOMISP_CSI2_H__
-#define __ATOMISP_CSI2_H__
-
-#include <media/v4l2-subdev.h>
-#include <media/v4l2-ctrls.h>
-
-#define CSI2_PAD_SINK		0
-#define CSI2_PAD_SOURCE		1
-#define CSI2_PADS_NUM		2
-
-#define CSI2_OUTPUT_ISP_SUBDEV	(1 << 0)
-#define CSI2_OUTPUT_MEMORY	(1 << 1)
-
-struct atomisp_device;
-struct v4l2_device;
-
-struct atomisp_mipi_csi2_device {
-	struct v4l2_subdev subdev;
-	struct media_pad pads[CSI2_PADS_NUM];
-	struct v4l2_mbus_framefmt formats[CSI2_PADS_NUM];
-
-	struct v4l2_ctrl_handler ctrls;
-	struct atomisp_device *isp;
-
-	u32 output; /* output direction */
-};
-
-int atomisp_csi2_set_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			  unsigned int which, uint16_t pad,
-			  struct v4l2_mbus_framefmt *ffmt);
-int atomisp_mipi_csi2_init(struct atomisp_device *isp);
-void atomisp_mipi_csi2_cleanup(struct atomisp_device *isp);
-void atomisp_mipi_csi2_unregister_entities(
-					struct atomisp_mipi_csi2_device *csi2);
-int atomisp_mipi_csi2_register_entities(struct atomisp_mipi_csi2_device *csi2,
-			struct v4l2_device *vdev);
-
-#endif /* __ATOMISP_CSI2_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.c
deleted file mode 100644
index 734fc3b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.c
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <media/v4l2-event.h>
-#include <media/v4l2-mediabus.h>
-
-#include <media/videobuf-vmalloc.h>
-#include <linux/delay.h>
-
-#ifdef CSS20
-#include "ia_css.h"
-#else /* CSS20 */
-#include <sh_css.h>
-#endif /* CSS20 */
-
-#include "atomisp_cmd.h"
-#include "atomisp_common.h"
-#include "atomisp_file.h"
-#include "atomisp_internal.h"
-#include "atomisp_ioctl.h"
-
-static void file_work(struct work_struct *work)
-{
-	struct atomisp_file_device *file_dev =
-			container_of(work, struct atomisp_file_device, work);
-	struct atomisp_device *isp = file_dev->isp;
-	/* only support file injection on subdev0 */
-	struct atomisp_sub_device *asd = &isp->asd[0];
-	struct atomisp_video_pipe *out_pipe = &asd->video_in;
-	unsigned short *buf = videobuf_to_vmalloc(out_pipe->outq.bufs[0]);
-	struct v4l2_mbus_framefmt isp_sink_fmt;
-
-	if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
-		return;
-
-	dev_dbg(isp->dev, ">%s: ready to start streaming\n", __func__);
-	isp_sink_fmt = *atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-						V4L2_SUBDEV_FORMAT_ACTIVE,
-						ATOMISP_SUBDEV_PAD_SINK);
-
-	while (!atomisp_css_isp_has_started())
-		usleep_range(1000, 1500);
-
-	atomisp_css_send_input_frame(asd, buf, isp_sink_fmt.width,
-				     isp_sink_fmt.height);
-	dev_dbg(isp->dev, "<%s: streaming done\n", __func__);
-}
-
-static int file_input_s_stream(struct v4l2_subdev *sd, int enable)
-{
-	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
-	struct atomisp_device *isp = file_dev->isp;
-	/* only support file injection on subdev0 */
-	struct atomisp_sub_device *asd = &isp->asd[0];
-
-	dev_dbg(isp->dev, "%s: enable %d\n", __func__, enable);
-	if (enable) {
-		if (asd->streaming != ATOMISP_DEVICE_STREAMING_ENABLED)
-			return 0;
-
-		queue_work(file_dev->work_queue, &file_dev->work);
-		return 0;
-	}
-	cancel_work_sync(&file_dev->work);
-	return 0;
-}
-
-static int file_input_g_parm(struct v4l2_subdev *sd,
-		struct v4l2_streamparm *param)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_s_parm(struct v4l2_subdev *sd,
-		struct v4l2_streamparm *param)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_enum_framesizes(struct v4l2_subdev *sd,
-				  struct v4l2_frmsizeenum *fsize)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_enum_frameintervals(struct v4l2_subdev *sd,
-				      struct v4l2_frmivalenum *fival)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
-				enum v4l2_mbus_pixelcode *code)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_g_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	struct atomisp_file_device *file_dev = v4l2_get_subdevdata(sd);
-	struct atomisp_device *isp = file_dev->isp;
-	/* only support file injection on subdev0 */
-	struct atomisp_sub_device *asd = &isp->asd[0];
-	struct v4l2_mbus_framefmt *isp_sink_fmt;
-
-	isp_sink_fmt = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-					       V4L2_SUBDEV_FORMAT_ACTIVE,
-					       ATOMISP_SUBDEV_PAD_SINK);
-
-	fmt->width = isp_sink_fmt->width;
-	fmt->height = isp_sink_fmt->height;
-	fmt->code = isp_sink_fmt->code;
-
-	return 0;
-}
-
-static int file_input_s_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	file_input_g_mbus_fmt(sd, fmt);
-	return 0;
-}
-
-static int file_input_g_chip_ident(struct v4l2_subdev *sd,
-			       struct v4l2_dbg_chip_ident *chip)
-{
-	if (!chip)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int file_input_log_status(struct v4l2_subdev *sd)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_queryctrl(struct v4l2_subdev *sd,
-		struct v4l2_queryctrl *qc)
-{
-	/*to fake*/
-	return -EINVAL;
-}
-
-static int file_input_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	/*to fake*/
-	return -EINVAL;
-}
-
-static int file_input_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_s_power(struct v4l2_subdev *sd, int on)
-{
-	/* to fake */
-	return 0;
-}
-
-static int file_input_enum_mbus_code(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_fh *fh,
-				 struct v4l2_subdev_mbus_code_enum *code)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_enum_frame_size(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_fh *fh,
-				  struct v4l2_subdev_frame_size_enum *fse)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int file_input_enum_frame_ival(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_fh *fh,
-				  struct v4l2_subdev_frame_interval_enum *fie)
-{
-	/*to fake*/
-	return 0;
-}
-
-static const struct v4l2_subdev_video_ops file_input_video_ops = {
-	.s_stream = file_input_s_stream,
-	.g_parm = file_input_g_parm,
-	.s_parm = file_input_s_parm,
-	.enum_framesizes = file_input_enum_framesizes,
-	.enum_frameintervals = file_input_enum_frameintervals,
-	.enum_mbus_fmt = file_input_enum_mbus_fmt,
-	.try_mbus_fmt = file_input_g_mbus_fmt,
-	.g_mbus_fmt = file_input_g_mbus_fmt,
-	.s_mbus_fmt = file_input_s_mbus_fmt,
-};
-
-static const struct v4l2_subdev_core_ops file_input_core_ops = {
-	.g_chip_ident = file_input_g_chip_ident,
-	.log_status = file_input_log_status,
-	.queryctrl = file_input_queryctrl,
-	.g_ctrl = file_input_g_ctrl,
-	.s_ctrl = file_input_s_ctrl,
-	.s_power = file_input_s_power,
-};
-
-static const struct v4l2_subdev_pad_ops file_input_pad_ops = {
-	.enum_mbus_code = file_input_enum_mbus_code,
-	.enum_frame_size = file_input_enum_frame_size,
-	.enum_frame_interval = file_input_enum_frame_ival,
-};
-
-static const struct v4l2_subdev_ops file_input_ops = {
-	.core = &file_input_core_ops,
-	.video = &file_input_video_ops,
-	.pad = &file_input_pad_ops,
-};
-
-void
-atomisp_file_input_unregister_entities(struct atomisp_file_device *file_dev)
-{
-	media_entity_cleanup(&file_dev->sd.entity);
-	v4l2_device_unregister_subdev(&file_dev->sd);
-}
-
-int atomisp_file_input_register_entities(struct atomisp_file_device *file_dev,
-			struct v4l2_device *vdev)
-{
-	/* Register the subdev and video nodes. */
-	return  v4l2_device_register_subdev(vdev, &file_dev->sd);
-}
-
-void atomisp_file_input_cleanup(struct atomisp_device *isp)
-{
-	struct atomisp_file_device *file_dev = &isp->file_dev;
-
-	if (file_dev->work_queue) {
-		destroy_workqueue(file_dev->work_queue);
-		file_dev->work_queue = NULL;
-	}
-}
-
-int atomisp_file_input_init(struct atomisp_device *isp)
-{
-	struct atomisp_file_device *file_dev = &isp->file_dev;
-	struct v4l2_subdev *sd = &file_dev->sd;
-	struct media_pad *pads = file_dev->pads;
-	struct media_entity *me = &sd->entity;
-
-	file_dev->isp = isp;
-	file_dev->work_queue = alloc_workqueue(isp->v4l2_dev.name, 0, 1);
-	if (file_dev->work_queue == NULL) {
-		dev_err(isp->dev, "Failed to initialize file inject workq\n");
-		return -ENOMEM;
-	}
-
-	INIT_WORK(&file_dev->work, file_work);
-
-	v4l2_subdev_init(sd, &file_input_ops);
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	strcpy(sd->name, "file_input_subdev");
-	v4l2_set_subdevdata(sd, file_dev);
-
-	pads[0].flags = MEDIA_PAD_FL_SINK;
-	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
-
-	return media_entity_init(me, 1, pads, 0);
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.h
deleted file mode 100644
index 1b86abd..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_file.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __ATOMISP_FILE_H__
-#define __ATOMISP_FILE_H__
-
-#include <media/media-entity.h>
-#include <media/v4l2-subdev.h>
-
-struct atomisp_device;
-
-struct atomisp_file_device {
-	struct v4l2_subdev sd;
-	struct atomisp_device *isp;
-	struct media_pad pads[1];
-
-	struct workqueue_struct *work_queue;
-	struct work_struct work;
-};
-
-void atomisp_file_input_cleanup(struct atomisp_device *isp);
-int atomisp_file_input_init(struct atomisp_device *isp);
-void atomisp_file_input_unregister_entities(
-				struct atomisp_file_device *file_dev);
-int atomisp_file_input_register_entities(struct atomisp_file_device *file_dev,
-			struct v4l2_device *vdev);
-#endif /* __ATOMISP_FILE_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.c
deleted file mode 100644
index 0f49697..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.c
+++ /dev/null
@@ -1,966 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <linux/module.h>
-#include <linux/pm_runtime.h>
-
-#include <media/v4l2-ioctl.h>
-#include <media/videobuf-vmalloc.h>
-
-#include "atomisp_cmd.h"
-#include "atomisp_common.h"
-#include "atomisp_fops.h"
-#include "atomisp_internal.h"
-#include "atomisp_ioctl.h"
-#include "atomisp_compat.h"
-#include "atomisp_subdev.h"
-#include "atomisp-regs.h"
-#include "hmm/hmm.h"
-
-#include "hrt/hive_isp_css_mm_hrt.h"
-
-#ifndef CSS21
-#include "host/mmu_local.h"
-#else
-#include "type_support.h"
-#endif
-#include "device_access/device_access.h"
-#include "memory_access/memory_access.h"
-
-#include "atomisp_acc.h"
-#include "atomisp_fw.h"
-
-#define ISP_LEFT_PAD			128	/* equal to 2*NWAY */
-
-/*
- * input image data, and current frame resolution for test
- */
-#define	ISP_PARAM_MMAP_OFFSET	0xfffff000
-
-#define MAGIC_CHECK(is, should)	\
-	do { \
-		if (unlikely((is) != (should))) { \
-			pr_err("magic mismatch: %x (expected %x)\n", \
-				is, should); \
-			BUG(); \
-		} \
-	} while (0)
-
-/*
- * Videobuf ops
- */
-static int atomisp_buf_setup(struct videobuf_queue *vq, unsigned int *count,
-			     unsigned int *size)
-{
-	struct atomisp_video_pipe *pipe = vq->priv_data;
-
-	*size = pipe->pix.sizeimage;
-
-	return 0;
-}
-
-static int atomisp_buf_prepare(struct videobuf_queue *vq,
-			       struct videobuf_buffer *vb,
-			       enum v4l2_field field)
-{
-	struct atomisp_video_pipe *pipe = vq->priv_data;
-
-	vb->size = pipe->pix.sizeimage;
-	vb->width = pipe->pix.width;
-	vb->height = pipe->pix.height;
-	vb->field = field;
-	vb->state = VIDEOBUF_PREPARED;
-
-	return 0;
-}
-
-int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
-			     struct atomisp_video_pipe *pipe,
-			     enum atomisp_input_stream_id stream_id,
-			     enum atomisp_css_buffer_type css_buf_type,
-			     enum atomisp_css_pipe_id css_pipe_id)
-{
-	struct videobuf_vmalloc_memory *vm_mem;
-	unsigned long irqflags;
-	int err;
-
-	while (pipe->buffers_in_css < ATOMISP_CSS_Q_DEPTH) {
-		struct videobuf_buffer *vb;
-
-		spin_lock_irqsave(&pipe->irq_lock, irqflags);
-		if (list_empty(&pipe->activeq)) {
-			spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
-			return -EINVAL;
-		}
-		vb = list_entry(pipe->activeq.next,
-				struct videobuf_buffer, queue);
-		list_del_init(&vb->queue);
-		vb->state = VIDEOBUF_ACTIVE;
-		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
-
-		vm_mem = vb->priv;
-
-		err = atomisp_q_video_buffer_to_css(asd, vm_mem, stream_id,
-						css_buf_type, css_pipe_id);
-		if (err) {
-			spin_lock_irqsave(&pipe->irq_lock, irqflags);
-			list_add_tail(&vb->queue, &pipe->activeq);
-			vb->state = VIDEOBUF_QUEUED;
-			spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
-			dev_err(asd->isp->dev, "%s, css q fails: %d\n",
-					__func__, err);
-			return -EINVAL;
-		}
-		pipe->buffers_in_css++;
-	}
-	return 0;
-}
-
-int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_pipe_id css_pipe_id)
-{
-	struct atomisp_s3a_buf *s3a_buf;
-
-	if (list_empty(&asd->s3a_stats)) {
-		WARN(1, "%s: No s3a buffers available!\n", __func__);
-		return -EINVAL;
-	}
-
-	while (asd->s3a_bufs_in_css[css_pipe_id] < ATOMISP_CSS_Q_DEPTH) {
-		s3a_buf = list_entry(asd->s3a_stats.next,
-				struct atomisp_s3a_buf, list);
-		list_move_tail(&s3a_buf->list, &asd->s3a_stats);
-
-		if (atomisp_q_s3a_buffer_to_css(asd, s3a_buf,
-						stream_id, css_pipe_id))
-			return -EINVAL;
-
-		asd->s3a_bufs_in_css[css_pipe_id]++;
-	}
-
-	return 0;
-}
-
-int atomisp_q_dis_buffers_to_css(struct atomisp_sub_device *asd,
-				enum atomisp_input_stream_id stream_id,
-				enum atomisp_css_pipe_id css_pipe_id)
-{
-	if (list_empty(&asd->dis_stats)) {
-		WARN(1, "%s: No dis buffers available!\n", __func__);
-		return -EINVAL;
-	}
-
-	while (asd->dis_bufs_in_css < ATOMISP_CSS_Q_DEPTH) {
-		struct atomisp_dis_buf *dis_buf =
-			list_entry(asd->dis_stats.next,
-				   struct atomisp_dis_buf, list);
-		list_move_tail(&dis_buf->list, &asd->dis_stats);
-
-		if (atomisp_q_dis_buffer_to_css(asd, dis_buf,
-						stream_id, css_pipe_id))
-			return -EINVAL;
-
-		asd->dis_bufs_in_css++;
-	}
-
-	return 0;
-}
-
-static int atomisp_get_css_buf_type(struct atomisp_sub_device *asd,
-				    enum atomisp_css_pipe_id pipe_id,
-				    uint16_t source_pad)
-{
-	if (pipe_id == CSS_PIPE_ID_COPY ||
-	    source_pad == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE ||
-	    source_pad == ATOMISP_SUBDEV_PAD_SOURCE_VIDEO ||
-	    (source_pad == ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW &&
-	     asd->run_mode->val != ATOMISP_RUN_MODE_VIDEO))
-		return CSS_BUFFER_TYPE_OUTPUT_FRAME;
-	else
-		return CSS_BUFFER_TYPE_VF_OUTPUT_FRAME;
-}
-
-/* queue all available buffers to css */
-int atomisp_qbuffers_to_css(struct atomisp_sub_device *asd)
-{
-	enum atomisp_css_buffer_type buf_type;
-	enum atomisp_css_pipe_id css_capture_pipe_id = CSS_PIPE_ID_NUM;
-	enum atomisp_css_pipe_id css_preview_pipe_id = CSS_PIPE_ID_NUM;
-	enum atomisp_css_pipe_id css_video_pipe_id = CSS_PIPE_ID_NUM;
-	enum atomisp_input_stream_id input_stream_id;
-	struct atomisp_video_pipe *capture_pipe = NULL;
-	struct atomisp_video_pipe *vf_pipe = NULL;
-	struct atomisp_video_pipe *preview_pipe = NULL;
-	struct atomisp_video_pipe *video_pipe = NULL;
-	bool raw_mode = atomisp_is_mbuscode_raw(
-			    asd->fmt[asd->capture_pad].fmt.code);
-
-	if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER) {
-		video_pipe = &asd->video_out_video_capture;
-		css_video_pipe_id = CSS_PIPE_ID_VIDEO;
-	} else if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {
-		preview_pipe = &asd->video_out_capture;
-		css_preview_pipe_id = CSS_PIPE_ID_CAPTURE;
-	} else if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-		if (asd->continuous_mode->val) {
-			capture_pipe = &asd->video_out_capture;
-			vf_pipe = &asd->video_out_vf;
-			css_capture_pipe_id = CSS_PIPE_ID_CAPTURE;
-		}
-		video_pipe = &asd->video_out_video_capture;
-		preview_pipe = &asd->video_out_preview;
-		css_video_pipe_id = CSS_PIPE_ID_VIDEO;
-		css_preview_pipe_id = CSS_PIPE_ID_VIDEO;
-	} else if (asd->continuous_mode->val) {
-		capture_pipe = &asd->video_out_capture;
-		vf_pipe = &asd->video_out_vf;
-		preview_pipe = &asd->video_out_preview;
-
-		css_preview_pipe_id = CSS_PIPE_ID_PREVIEW;
-		css_capture_pipe_id = CSS_PIPE_ID_CAPTURE;
-	} else if (asd->run_mode->val == ATOMISP_RUN_MODE_PREVIEW) {
-		preview_pipe = &asd->video_out_preview;
-		css_preview_pipe_id = CSS_PIPE_ID_PREVIEW;
-	} else {
-		/* ATOMISP_RUN_MODE_STILL_CAPTURE */
-		capture_pipe = &asd->video_out_capture;
-		if (!raw_mode)
-			vf_pipe = &asd->video_out_vf;
-		css_capture_pipe_id = CSS_PIPE_ID_CAPTURE;
-	}
-
-#ifdef ISP2401_NEW_INPUT_SYSTEM
-	if (asd->isp->inputs[asd->input_curr].type == SOC_CAMERA || raw_mode) {
-		css_capture_pipe_id = CSS_PIPE_ID_COPY;
-		css_preview_pipe_id = CSS_PIPE_ID_COPY;
-	}
-#endif
-
-	if (capture_pipe) {
-		buf_type = atomisp_get_css_buf_type(
-			asd, css_capture_pipe_id,
-			atomisp_subdev_source_pad(&capture_pipe->vdev));
-#ifdef CSS20
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
-			asd->stream_env[ATOMISP_INPUT_STREAM_VIDEO].stream)
-			input_stream_id = ATOMISP_INPUT_STREAM_VIDEO;
-		else
-#endif
-			input_stream_id = ATOMISP_INPUT_STREAM_GENERAL;
-		atomisp_q_video_buffers_to_css(asd, capture_pipe,
-					       input_stream_id,
-					       buf_type, css_capture_pipe_id);
-	}
-
-	if (vf_pipe) {
-		buf_type = atomisp_get_css_buf_type(
-			asd, css_capture_pipe_id,
-			atomisp_subdev_source_pad(&vf_pipe->vdev));
-#ifdef CSS20
-		if (asd->stream_env[ATOMISP_INPUT_STREAM_POSTVIEW].stream)
-			input_stream_id = ATOMISP_INPUT_STREAM_POSTVIEW;
-		else
-#endif
-			input_stream_id = ATOMISP_INPUT_STREAM_GENERAL;
-		atomisp_q_video_buffers_to_css(asd, vf_pipe,
-					       input_stream_id,
-					       buf_type, css_capture_pipe_id);
-	}
-
-	if (preview_pipe) {
-		buf_type = atomisp_get_css_buf_type(
-			asd, css_preview_pipe_id,
-			atomisp_subdev_source_pad(&preview_pipe->vdev));
-#ifdef CSS20
-		if (asd->stream_env[ATOMISP_INPUT_STREAM_PREVIEW].stream)
-			input_stream_id = ATOMISP_INPUT_STREAM_PREVIEW;
-		else
-#endif
-			input_stream_id = ATOMISP_INPUT_STREAM_GENERAL;
-		atomisp_q_video_buffers_to_css(asd, preview_pipe,
-					       input_stream_id,
-					       buf_type, css_preview_pipe_id);
-	}
-
-	if (video_pipe) {
-		buf_type = atomisp_get_css_buf_type(
-			asd, css_video_pipe_id,
-			atomisp_subdev_source_pad(&video_pipe->vdev));
-#ifdef CSS20
-		if (asd->stream_env[ATOMISP_INPUT_STREAM_VIDEO].stream)
-			input_stream_id = ATOMISP_INPUT_STREAM_VIDEO;
-		else
-#endif
-			input_stream_id = ATOMISP_INPUT_STREAM_GENERAL;
-		atomisp_q_video_buffers_to_css(asd, video_pipe,
-					       input_stream_id,
-					       buf_type, css_video_pipe_id);
-	}
-
-
-	if (asd->params.curr_grid_info.s3a_grid.enable) {
-		if (css_capture_pipe_id < CSS_PIPE_ID_NUM)
-			atomisp_q_s3a_buffers_to_css(asd,
-					ATOMISP_INPUT_STREAM_GENERAL,
-					css_capture_pipe_id);
-		if (css_preview_pipe_id < CSS_PIPE_ID_NUM)
-			atomisp_q_s3a_buffers_to_css(asd,
-					ATOMISP_INPUT_STREAM_GENERAL,
-					css_preview_pipe_id);
-		if (css_video_pipe_id < CSS_PIPE_ID_NUM)
-			atomisp_q_s3a_buffers_to_css(asd,
-					ATOMISP_INPUT_STREAM_GENERAL,
-					css_video_pipe_id);
-	}
-
-	if (asd->params.curr_grid_info.dvs_grid.enable)
-		atomisp_q_dis_buffers_to_css(asd,
-					ATOMISP_INPUT_STREAM_GENERAL,
-					css_video_pipe_id);
-
-	return 0;
-}
-
-static void atomisp_buf_queue(struct videobuf_queue *vq,
-			      struct videobuf_buffer *vb)
-{
-	struct atomisp_video_pipe *pipe = vq->priv_data;
-
-	list_add_tail(&vb->queue, &pipe->activeq);
-	vb->state = VIDEOBUF_QUEUED;
-}
-
-static void atomisp_buf_release(struct videobuf_queue *vq,
-				struct videobuf_buffer *vb)
-{
-	vb->state = VIDEOBUF_NEEDS_INIT;
-	atomisp_videobuf_free_buf(vb);
-}
-
-static int atomisp_buf_setup_output(struct videobuf_queue *vq,
-				    unsigned int *count, unsigned int *size)
-{
-	struct atomisp_video_pipe *pipe = vq->priv_data;
-
-	*size = pipe->pix.sizeimage;
-
-	return 0;
-}
-
-static int atomisp_buf_prepare_output(struct videobuf_queue *vq,
-				      struct videobuf_buffer *vb,
-				      enum v4l2_field field)
-{
-	struct atomisp_video_pipe *pipe = vq->priv_data;
-
-	vb->size = pipe->pix.sizeimage;
-	vb->width = pipe->pix.width;
-	vb->height = pipe->pix.height;
-	vb->field = field;
-	vb->state = VIDEOBUF_PREPARED;
-
-	return 0;
-}
-
-static void atomisp_buf_queue_output(struct videobuf_queue *vq,
-				     struct videobuf_buffer *vb)
-{
-	struct atomisp_video_pipe *pipe = vq->priv_data;
-
-	list_add_tail(&vb->queue, &pipe->activeq_out);
-	vb->state = VIDEOBUF_QUEUED;
-}
-
-static void atomisp_buf_release_output(struct videobuf_queue *vq,
-				       struct videobuf_buffer *vb)
-{
-	videobuf_vmalloc_free(vb);
-	vb->state = VIDEOBUF_NEEDS_INIT;
-}
-
-static struct videobuf_queue_ops videobuf_qops = {
-	.buf_setup	= atomisp_buf_setup,
-	.buf_prepare	= atomisp_buf_prepare,
-	.buf_queue	= atomisp_buf_queue,
-	.buf_release	= atomisp_buf_release,
-};
-
-static struct videobuf_queue_ops videobuf_qops_output = {
-	.buf_setup	= atomisp_buf_setup_output,
-	.buf_prepare	= atomisp_buf_prepare_output,
-	.buf_queue	= atomisp_buf_queue_output,
-	.buf_release	= atomisp_buf_release_output,
-};
-
-static int atomisp_init_pipe(struct atomisp_video_pipe *pipe)
-{
-	/* init locks */
-	spin_lock_init(&pipe->irq_lock);
-
-	videobuf_queue_vmalloc_init(&pipe->capq, &videobuf_qops, NULL,
-				    &pipe->irq_lock,
-				    V4L2_BUF_TYPE_VIDEO_CAPTURE,
-				    V4L2_FIELD_NONE,
-				    sizeof(struct atomisp_buffer), pipe,
-				    NULL);	/* ext_lock: NULL */
-
-	videobuf_queue_vmalloc_init(&pipe->outq, &videobuf_qops_output, NULL,
-				    &pipe->irq_lock,
-				    V4L2_BUF_TYPE_VIDEO_OUTPUT,
-				    V4L2_FIELD_NONE,
-				    sizeof(struct atomisp_buffer), pipe,
-				    NULL);	/* ext_lock: NULL */
-
-	INIT_LIST_HEAD(&pipe->activeq);
-	INIT_LIST_HEAD(&pipe->activeq_out);
-
-	return 0;
-}
-
-static void atomisp_dev_init_struct(struct atomisp_device *isp)
-{
-	unsigned int i;
-
-	isp->sw_contex.file_input = 0;
-	isp->need_gfx_throttle = true;
-	isp->isp_fatal_error = false;
-	isp->mipi_frame_size = 0;
-
-	for (i = 0; i < isp->input_cnt; i++)
-		isp->inputs[i].asd = NULL;
-	/*
-	 * For Merrifield, frequency is scalable.
-	 * After boot-up, the default frequency is 200MHz.
-	 * For Medfield/Clovertrail, all running at 320MHz
-	 */
-	if (IS_ISP24XX(isp))
-		isp->sw_contex.running_freq = ISP_FREQ_200MHZ;
-	else
-		isp->sw_contex.running_freq = ISP_FREQ_320MHZ;
-}
-
-static void atomisp_subdev_init_struct(struct atomisp_sub_device *asd)
-{
-	v4l2_ctrl_s_ctrl(asd->run_mode, ATOMISP_RUN_MODE_STILL_CAPTURE);
-	asd->params.color_effect = V4L2_COLORFX_NONE;
-	asd->params.bad_pixel_en = 1;
-	asd->params.gdc_cac_en = 0;
-	asd->params.video_dis_en = 0;
-	asd->params.sc_en = 0;
-	asd->params.fpn_en = 0;
-	asd->params.xnr_en = 0;
-	asd->params.false_color = 0;
-	asd->params.online_process = 1;
-	asd->params.yuv_ds_en = 0;
-#ifdef CSS20
-	asd->params.dvs_6axis = NULL;
-#endif
-	asd->params.offline_parm.num_captures = 1;
-	asd->params.offline_parm.skip_frames = 0;
-	asd->params.offline_parm.offset = 0;
-	asd->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
-	/* Add for channel */
-	asd->input_curr = 0;
-
-	asd->mipi_frame_size = 0;
-
-	atomisp_css_init_struct(asd);
-}
-/*
- * file operation functions
- */
-unsigned int atomisp_subdev_users(struct atomisp_sub_device *asd)
-{
-	return asd->video_out_preview.users +
-	       asd->video_out_vf.users +
-	       asd->video_out_capture.users +
-	       asd->video_out_video_capture.users +
-	       asd->video_in.users;
-}
-
-unsigned int atomisp_dev_users(struct atomisp_device *isp)
-{
-	unsigned int i, sum;
-	for (i = 0, sum = 0; i < isp->num_of_streams; i++)
-		sum += atomisp_subdev_users(&isp->asd[i]);
-
-	return sum;
-}
-
-static int atomisp_open(struct file *file)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	int ret;
-
-	dev_dbg(isp->dev, "open device %s\n", vdev->name);
-
-	mutex_lock(&isp->mutex);
-
-	if (!isp->input_cnt) {
-		dev_err(isp->dev, "no camera attached\n");
-		ret = -EINVAL;
-		goto error;
-	}
-
-	if (pipe->users)
-		goto done;
-
-	ret = atomisp_init_pipe(pipe);
-	if (ret)
-		goto error;
-
-
-	if (atomisp_dev_users(isp)) {
-		dev_err(isp->dev, "skip init isp in open\n");
-		goto init_subdev;
-	}
-
-	/* runtime power management, turn on ISP */
-	ret = pm_runtime_get_sync(vdev->v4l2_dev->dev);
-	if (ret < 0) {
-		dev_err(isp->dev, "Failed to power on device\n");
-		goto error;
-	}
-
-	if (dypool_enable) {
-		ret = hmm_pool_register(dypool_pgnr, HMM_POOL_TYPE_DYNAMIC);
-		if (ret)
-			dev_err(isp->dev, "Failed to register dynamic memory pool.\n");
-	}
-
-	/* Init ISP */
-	if (atomisp_css_init(isp)) {
-		ret = -EINVAL;
-		goto error;
-	}
-
-	/* Initialize the CSS debug trace verbosity level. To change
-	 * the verbosity level, change the definition of this macro
-	 * up in the file
-	 */
-	atomisp_css_debug_set_dtrace_level(CSS_DTRACE_VERBOSITY_LEVEL);
-
-	atomisp_dev_init_struct(isp);
-
-	ret = v4l2_subdev_call(isp->flash, core, s_power, 1);
-	if (ret < 0 && ret != -ENODEV && ret != -ENOIOCTLCMD) {
-		dev_err(isp->dev, "Failed to power-on flash\n");
-		goto error;
-	}
-
-init_subdev: /* For CTP CSS1.5, below init depends on css global init */
-	if (atomisp_subdev_users(asd))
-		goto done;
-
-	atomisp_subdev_init_struct(asd);
-
-done:
-	pipe->users++;
-	mutex_unlock(&isp->mutex);
-	return 0;
-
-error:
-	hmm_pool_unregister(HMM_POOL_TYPE_DYNAMIC);
-	pm_runtime_put(vdev->v4l2_dev->dev);
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-static int atomisp_release(struct file *file)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct v4l2_requestbuffers req;
-	struct v4l2_subdev_fh fh;
-	int ret = 0;
-
-	v4l2_fh_init(&fh.vfh, vdev);
-
-	req.count = 0;
-	if (isp == NULL)
-		return -EBADF;
-
-	mutex_lock(&isp->streamoff_mutex);
-	mutex_lock(&isp->mutex);
-
-	dev_dbg(isp->dev, "release device %s\n", vdev->name);
-
-	pipe->users--;
-
-	if (pipe->capq.streaming &&
-	    __atomisp_streamoff(file, NULL, V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
-		dev_err(isp->dev,
-			"atomisp_streamoff failed on release, driver bug");
-		goto done;
-	}
-
-	if (pipe->users)
-		goto done;
-
-	if (__atomisp_reqbufs(file, NULL, &req)) {
-		dev_err(isp->dev,
-			"atomisp_reqbufs failed on release, driver bug");
-		goto done;
-	}
-
-	if (pipe->outq.bufs[0]) {
-		mutex_lock(&pipe->outq.vb_lock);
-		videobuf_queue_cancel(&pipe->outq);
-		mutex_unlock(&pipe->outq.vb_lock);
-	}
-
-	/*
-	 * A little trick here:
-	 * file injection input resolution is recorded in the sink pad,
-	 * therefore can not be cleared when releaseing one device node.
-	 * The sink pad setting can only be cleared when all device nodes
-	 * get released.
-	 */
-	if (!isp->sw_contex.file_input && asd->fmt_auto->val) {
-		struct v4l2_mbus_framefmt isp_sink_fmt = { 0 };
-		atomisp_subdev_set_ffmt(
-			&asd->subdev, &fh,
-			V4L2_SUBDEV_FORMAT_ACTIVE, ATOMISP_SUBDEV_PAD_SINK,
-			&isp_sink_fmt);
-	}
-
-	if (atomisp_subdev_users(asd))
-		goto done;
-
-	/* clear the sink pad for file input */
-	if (isp->sw_contex.file_input && asd->fmt_auto->val) {
-		struct v4l2_mbus_framefmt isp_sink_fmt = { 0 };
-		atomisp_subdev_set_ffmt(&asd->subdev, &fh,
-					V4L2_SUBDEV_FORMAT_ACTIVE,
-					ATOMISP_SUBDEV_PAD_SINK, &isp_sink_fmt);
-	}
-
-	atomisp_free_3a_dis_buffers(asd);
-	atomisp_free_internal_buffers(asd);
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				       core, s_power, 0);
-	if (ret)
-		dev_warn(isp->dev, "Failed to power-off sensor\n");
-
-	/* clear the asd field to show this camera is not used */
-	isp->inputs[asd->input_curr].asd = NULL;
-
-	if (atomisp_dev_users(isp))
-		goto done;
-
-	del_timer_sync(&isp->wdt);
-	atomisp_acc_release(isp);
-	atomisp_free_all_shading_tables(isp);
-#ifdef CSS20
-	atomisp_destroy_pipes_stream_force(asd);
-#endif
-	atomisp_css_uninit(isp);
-#ifndef CSS20
-	hrt_isp_css_mm_clear();
-#else /* CSS20 */
-	hmm_cleanup_mmu_l2();
-#endif /* CSS20 */
-	hmm_pool_unregister(HMM_POOL_TYPE_DYNAMIC);
-
-	ret = v4l2_subdev_call(isp->flash, core, s_power, 0);
-	if (ret < 0 && ret != -ENODEV && ret != -ENOIOCTLCMD)
-		dev_warn(isp->dev, "Failed to power-off flash\n");
-
-	if (pm_runtime_put_sync(vdev->v4l2_dev->dev) < 0)
-		dev_err(isp->dev, "Failed to power off device\n");
-
-done:
-	mutex_unlock(&isp->mutex);
-	mutex_unlock(&isp->streamoff_mutex);
-
-	return 0;
-}
-
-/*
- * Memory help functions for image frame and private parameters
- */
-static int do_isp_mm_remap(struct atomisp_device *isp,
-			   struct vm_area_struct *vma,
-			   ia_css_ptr isp_virt, u32 host_virt, u32 pgnr)
-{
-	u32 pfn;
-
-	while (pgnr) {
-		pfn = hmm_virt_to_phys(isp_virt) >> PAGE_SHIFT;
-		if (remap_pfn_range(vma, host_virt, pfn,
-				    PAGE_SIZE, PAGE_SHARED)) {
-			dev_err(isp->dev, "remap_pfn_range err.\n");
-			return -EAGAIN;
-		}
-
-		isp_virt += PAGE_SIZE;
-		host_virt += PAGE_SIZE;
-		pgnr--;
-	}
-
-	return 0;
-}
-
-static int frame_mmap(struct atomisp_device *isp,
-	const struct atomisp_css_frame *frame, struct vm_area_struct *vma)
-{
-	ia_css_ptr isp_virt;
-	u32 host_virt;
-	u32 pgnr;
-
-	if (!frame) {
-		dev_err(isp->dev, "%s: NULL frame pointer.\n", __func__);
-		return -EINVAL;
-	}
-
-	host_virt = vma->vm_start;
-	isp_virt = frame->data;
-	atomisp_get_frame_pgnr(isp, frame, &pgnr);
-
-	if (do_isp_mm_remap(isp, vma, isp_virt, host_virt, pgnr))
-		return -EAGAIN;
-
-	return 0;
-}
-
-int atomisp_videobuf_mmap_mapper(struct videobuf_queue *q,
-	struct vm_area_struct *vma)
-{
-	u32 offset = vma->vm_pgoff << PAGE_SHIFT;
-	int ret = -EINVAL, i;
-	struct atomisp_device *isp =
-		((struct atomisp_video_pipe *)(q->priv_data))->isp;
-	struct videobuf_vmalloc_memory *vm_mem;
-	struct videobuf_mapping *map;
-
-	MAGIC_CHECK(q->int_ops->magic, MAGIC_QTYPE_OPS);
-	if (!(vma->vm_flags & VM_WRITE) || !(vma->vm_flags & VM_SHARED)) {
-		dev_err(isp->dev, "map appl bug: PROT_WRITE and MAP_SHARED are required\n");
-		return -EINVAL;
-	}
-
-	mutex_lock(&q->vb_lock);
-	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
-		struct videobuf_buffer *buf = q->bufs[i];
-		if (buf == NULL)
-			continue;
-
-		map = kzalloc(sizeof(struct videobuf_mapping), GFP_KERNEL);
-		if (map == NULL) {
-			mutex_unlock(&q->vb_lock);
-			return -ENOMEM;
-		}
-
-		buf->map = map;
-		map->q = q;
-
-		buf->baddr = vma->vm_start;
-
-		if (buf && buf->memory == V4L2_MEMORY_MMAP &&
-		    buf->boff == offset) {
-			vm_mem = buf->priv;
-			ret = frame_mmap(isp, vm_mem->vaddr, vma);
-			vma->vm_flags |= VM_IO|VM_DONTEXPAND|VM_DONTDUMP;
-			break;
-		}
-	}
-	mutex_unlock(&q->vb_lock);
-
-	return ret;
-}
-
-/* The input frame contains left and right padding that need to be removed.
- * There is always ISP_LEFT_PAD padding on the left side.
- * There is also padding on the right (padded_width - width).
- */
-static int remove_pad_from_frame(struct atomisp_device *isp,
-		struct atomisp_css_frame *in_frame, __u32 width, __u32 height)
-{
-	unsigned int i;
-	unsigned short *buffer;
-	int ret = 0;
-	ia_css_ptr load = in_frame->data;
-	ia_css_ptr store = load;
-
-	buffer = kmalloc(width*sizeof(load), GFP_KERNEL);
-	if (!buffer) {
-		dev_err(isp->dev, "out of memory.\n");
-		return -ENOMEM;
-	}
-
-	load += ISP_LEFT_PAD;
-	for (i = 0; i < height; i++) {
-		ret = hrt_isp_css_mm_load(load, buffer, width*sizeof(load));
-		if (ret < 0)
-			goto remove_pad_error;
-
-		ret = hrt_isp_css_mm_store(store, buffer, width*sizeof(store));
-		if (ret < 0)
-			goto remove_pad_error;
-
-		load  += in_frame->info.padded_width;
-		store += width;
-	}
-
-remove_pad_error:
-	kfree(buffer);
-	return ret;
-}
-
-static int atomisp_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct atomisp_css_frame *raw_virt_addr;
-	u32 start = vma->vm_start;
-	u32 end = vma->vm_end;
-	u32 size = end - start;
-	u32 origin_size, new_size;
-	int ret;
-
-	if (!(vma->vm_flags & (VM_WRITE | VM_READ)))
-		return -EACCES;
-
-	if (!(vma->vm_flags & VM_SHARED))
-		return -EINVAL;
-
-	mutex_lock(&isp->mutex);
-	new_size = pipe->pix.width * pipe->pix.height * 2;
-
-	/* mmap for ISP offline raw data */
-	if (atomisp_subdev_source_pad(vdev)
-	    == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE &&
-	    vma->vm_pgoff == (ISP_PARAM_MMAP_OFFSET >> PAGE_SHIFT)) {
-		if (asd->params.online_process != 0) {
-			ret = -EINVAL;
-			goto error;
-		}
-		raw_virt_addr = asd->raw_output_frame;
-		if (raw_virt_addr == NULL) {
-			dev_err(isp->dev, "Failed to request RAW frame\n");
-			ret = -EINVAL;
-			goto error;
-		}
-
-		ret = remove_pad_from_frame(isp, raw_virt_addr,
-				      pipe->pix.width, pipe->pix.height);
-		if (ret < 0) {
-			dev_err(isp->dev, "remove pad failed.\n");
-			goto error;
-		}
-		origin_size = raw_virt_addr->data_bytes;
-		raw_virt_addr->data_bytes = new_size;
-
-		if (size != PAGE_ALIGN(new_size)) {
-			dev_err(isp->dev, "incorrect size for mmap ISP Raw Frame\n");
-			ret = -EINVAL;
-			goto error;
-		}
-
-		if (frame_mmap(isp, raw_virt_addr, vma)) {
-			dev_err(isp->dev, "frame_mmap failed.\n");
-			raw_virt_addr->data_bytes = origin_size;
-			ret = -EAGAIN;
-			goto error;
-		}
-		raw_virt_addr->data_bytes = origin_size;
-		vma->vm_flags |= VM_IO|VM_DONTEXPAND|VM_DONTDUMP;
-		mutex_unlock(&isp->mutex);
-		return 0;
-	}
-
-	/*
-	 * mmap for normal frames
-	 */
-	if (size != pipe->pix.sizeimage) {
-		dev_err(isp->dev, "incorrect size for mmap ISP frames\n");
-		ret = -EINVAL;
-		goto error;
-	}
-	mutex_unlock(&isp->mutex);
-
-	return atomisp_videobuf_mmap_mapper(&pipe->capq, vma);
-
-error:
-	mutex_unlock(&isp->mutex);
-
-	return ret;
-}
-
-static int atomisp_file_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-
-	return videobuf_mmap_mapper(&pipe->outq, vma);
-}
-
-static unsigned int atomisp_poll(struct file *file,
-				 struct poll_table_struct *pt)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-
-	mutex_lock(&isp->mutex);
-	if (pipe->capq.streaming != 1) {
-		mutex_unlock(&isp->mutex);
-		return POLLERR;
-	}
-	mutex_unlock(&isp->mutex);
-
-	return videobuf_poll_stream(file, &pipe->capq, pt);
-}
-
-const struct v4l2_file_operations atomisp_fops = {
-	.owner = THIS_MODULE,
-	.open = atomisp_open,
-	.release = atomisp_release,
-	.mmap = atomisp_mmap,
-	.ioctl = video_ioctl2,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl32 = atomisp_compat_ioctl32,
-#endif
-	.poll = atomisp_poll,
-};
-
-const struct v4l2_file_operations atomisp_file_fops = {
-	.owner = THIS_MODULE,
-	.open = atomisp_open,
-	.release = atomisp_release,
-	.mmap = atomisp_file_mmap,
-	.ioctl = video_ioctl2,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl32 = atomisp_compat_ioctl32,
-#endif
-	.poll = atomisp_poll,
-};
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.h
deleted file mode 100644
index 50edb4b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fops.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__ATOMISP_FOPS_H__
-#define	__ATOMISP_FOPS_H__
-#include "atomisp_subdev.h"
-
-int atomisp_q_video_buffers_to_css(struct atomisp_sub_device *asd,
-			     struct atomisp_video_pipe *pipe,
-			     enum atomisp_input_stream_id stream_id,
-			     enum atomisp_css_buffer_type css_buf_type,
-			     enum atomisp_css_pipe_id css_pipe_id);
-
-int atomisp_q_s3a_buffers_to_css(struct atomisp_sub_device *asd,
-			   enum atomisp_input_stream_id stream_id,
-			   enum atomisp_css_pipe_id css_pipe_id);
-
-int atomisp_q_dis_buffers_to_css(struct atomisp_sub_device *asd,
-			   enum atomisp_input_stream_id stream_id,
-			   enum atomisp_css_pipe_id css_pipe_id);
-
-unsigned int atomisp_dev_users(struct atomisp_device *isp);
-unsigned int atomisp_sub_dev_users(struct atomisp_sub_device *asd);
-
-/*
- * Memory help functions for image frame and private parameters
- */
-
-int atomisp_videobuf_mmap_mapper(struct videobuf_queue *q,
-				     struct vm_area_struct *vma);
-
-int atomisp_qbuf_to_css(struct atomisp_device *isp,
-			struct atomisp_video_pipe *pipe,
-			struct videobuf_buffer *vb);
-
-int atomisp_qbuffers_to_css(struct atomisp_sub_device *asd);
-
-extern const struct v4l2_file_operations atomisp_fops;
-
-#endif /* __ATOMISP_FOPS_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fw.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fw.h
deleted file mode 100644
index 20e4e16..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_fw.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-/* this is the ISP firmware data running on Merrifield VP */
-char isp2400_fw_data_sim[] = {
-0x8e, 0x02, 0x33, 0x01, 0x14, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x01, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x02, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x54, 0x03,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x54,
-0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00,
-0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00,
-0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
-0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d,
-0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x0e, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x0f, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x03, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_helper.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_helper.h
deleted file mode 100644
index e9650cb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_helper.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef _atomisp_helper_h_
-#define _atomisp_helper_h_
-extern void __iomem *atomisp_io_base;
-
-static inline void __iomem *atomisp_get_io_virt_addr(unsigned int address)
-{
-	void __iomem *ret = atomisp_io_base + (address & 0x003FFFFF);
-	return ret;
-}
-#endif
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_internal.h
deleted file mode 100644
index 6100c2c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_internal.h
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef __ATOMISP_INTERNAL_H__
-#define __ATOMISP_INTERNAL_H__
-
-#include <linux/atomisp_platform.h>
-#include <linux/firmware.h>
-#include <linux/kernel.h>
-#include <linux/pm_qos.h>
-#include <linux/idr.h>
-
-#include <asm/intel-mid.h>
-
-#include <media/media-device.h>
-#include <media/v4l2-subdev.h>
-
-#ifdef CSS20
-#include "ia_css_types.h"
-#include "sh_css_legacy.h"
-#else /* CSS20 */
-#include "sh_css_types.h"
-#endif /* CSS20 */
-
-#include "atomisp_csi2.h"
-#include "atomisp_file.h"
-#include "atomisp_subdev.h"
-#include "atomisp_tpg.h"
-#include "atomisp_compat.h"
-
-#include "gp_device.h"
-#include "irq.h"
-
-#define IS_MOFD (INTEL_MID_BOARD(1, PHONE, MOFD) || \
-	INTEL_MID_BOARD(1, TABLET, MOFD))
-#define IS_BYT (INTEL_MID_BOARD(1, PHONE, BYT) || \
-	INTEL_MID_BOARD(1, TABLET, BYT))
-#define IS_MFLD (INTEL_MID_BOARD(1, PHONE, MFLD) || \
-	INTEL_MID_BOARD(1, TABLET, MFLD))
-
-#define MAX_STREAM_NUM	2
-
-#define ATOMISP_PCI_DEVICE_SOC_MASK	0xfff8
-/* MRFLD with 0x1178: ISP freq can burst to 457MHz */
-#define ATOMISP_PCI_DEVICE_SOC_MRFLD	0x1178
-/* MRFLD with 0x1179: max ISP freq limited to 400MHz */
-#define ATOMISP_PCI_DEVICE_SOC_MRFLD_FREQ_LIMITED	0x1179
-#define ATOMISP_PCI_DEVICE_SOC_BYT	0x0f38
-#define ATOMISP_PCI_DEVICE_SOC_ANN	0x1478
-#define ATOMISP_PCI_DEVICE_SOC_CHT	0x22b8
-
-#define ATOMISP_PCI_REV_MRFLD_A0_MAX	0
-#define ATOMISP_PCI_REV_BYT_A0_MAX	4
-
-#define ATOMISP_MAJOR		0
-#define ATOMISP_MINOR		5
-#define ATOMISP_PATCHLEVEL	1
-
-#define DRIVER_VERSION_STR	__stringify(ATOMISP_MAJOR) \
-	"." __stringify(ATOMISP_MINOR) "." __stringify(ATOMISP_PATCHLEVEL)
-#define DRIVER_VERSION		KERNEL_VERSION(ATOMISP_MAJOR, \
-	ATOMISP_MINOR, ATOMISP_PATCHLEVEL)
-
-#define ATOM_ISP_STEP_WIDTH	4
-#define ATOM_ISP_STEP_HEIGHT	4
-
-#define ATOM_ISP_MIN_WIDTH	4
-#define ATOM_ISP_MIN_HEIGHT	4
-#define ATOM_ISP_MAX_WIDTH	4352
-#define ATOM_ISP_MAX_HEIGHT	3264
-
-/* sub-QCIF resolution */
-#define ATOM_RESOLUTION_SUBQCIF_WIDTH	128
-#define ATOM_RESOLUTION_SUBQCIF_HEIGHT	96
-
-#define ATOM_ISP_MAX_WIDTH_TMP	1280
-#define ATOM_ISP_MAX_HEIGHT_TMP	720
-
-#define ATOM_ISP_I2C_BUS_1	4
-#define ATOM_ISP_I2C_BUS_2	5
-
-#define ATOM_ISP_POWER_DOWN	0
-#define ATOM_ISP_POWER_UP	1
-
-#define ATOM_ISP_MAX_INPUTS	4
-
-#define ATOMISP_SC_TYPE_SIZE	2
-
-#define ATOMISP_ISP_TIMEOUT_DURATION		(2 * HZ)
-#define ATOMISP_ISP_FILE_TIMEOUT_DURATION	(60 * HZ)
-#define ATOMISP_ISP_MAX_TIMEOUT_COUNT	2
-#define ATOMISP_CSS_STOP_TIMEOUT_US	200000
-
-#define ATOMISP_CSS_Q_DEPTH	3
-#define ATOMISP_CSS_EVENTS_MAX  16
-#define ATOMISP_CONT_RAW_FRAMES 10
-
-#define ATOMISP_DELAYED_INIT_NOT_QUEUED	0
-#define ATOMISP_DELAYED_INIT_QUEUED	1
-#define ATOMISP_DELAYED_INIT_WORK_DONE	2
-#define ATOMISP_DELAYED_INIT_DONE	3
-
-#define ATOMISP_CALC_CSS_PREV_OVERLAP(lines) \
-	((lines) * 38 / 100 & 0xfffffe)
-
-/*
- * Define how fast CPU should be able to serve ISP interrupts.
- * The bigger the value, the higher risk that the ISP is not
- * triggered sufficiently fast for it to process image during
- * vertical blanking time, increasing risk of dropped frames.
- * 1000 us is a reasonable value considering that the processing
- * time is typically ~2000 us.
- */
-#define ATOMISP_MAX_ISR_LATENCY	1000
-
-/* Declared in hmm.c. */
-extern bool atomisp_hmm_is_2400;
-
-extern raw_spinlock_t pci_config_lock;
-
-struct atomisp_input_subdev {
-	unsigned int type;
-	enum atomisp_camera_port port;
-	struct v4l2_subdev *camera;
-	struct v4l2_subdev *motor;
-	struct atomisp_css_morph_table *morph_table;
-	struct atomisp_css_shading_table *shading_table;
-	struct v4l2_frmsizeenum frame_size;
-
-	/*
-	 * To show this resource is used by
-	 * which stream, in ISP multiple stream mode
-	 */
-	struct atomisp_sub_device *asd;
-
-	const struct atomisp_camera_caps *camera_caps;
-};
-
-struct atomisp_freq_scaling_rule {
-	unsigned int width;
-	unsigned int height;
-	unsigned short fps;
-	unsigned int isp_freq;
-	unsigned int run_mode;
-};
-
-enum atomisp_dfs_mode {
-	ATOMISP_DFS_MODE_AUTO = 0,
-	ATOMISP_DFS_MODE_LOW,
-	ATOMISP_DFS_MODE_MAX,
-};
-
-struct atomisp_regs {
-	/* PCI config space info */
-	u16 pcicmdsts;
-	u32 ispmmadr;
-	u32 msicap;
-	u32 msi_addr;
-	u16 msi_data;
-	u8 intr;
-	u32 interrupt_control;
-	u32 pmcs;
-	u32 cg_dis;
-	u32 i_control;
-
-	/* I-Unit PHY related info */
-	u32 csi_rcomp_config;
-	u32 csi_afe_dly;
-	u32 csi_control;
-
-	/* New for MRFLD */
-	u32 csi_afe_rcomp_config;
-	u32 csi_afe_hs_control;
-	u32 csi_deadline_control;
-	u32 csi_access_viol;
-};
-
-struct atomisp_sw_contex {
-	bool file_input;
-	int  invalid_frame;
-	int  invalid_vf_frame;
-	int  invalid_s3a;
-	int  invalid_dis;
-
-	int power_state;
-	int running_freq;
-};
-
-struct atomisp_acc_fw {
-	struct atomisp_css_fw_info *fw;
-	unsigned int handle;
-	unsigned int flags;
-	unsigned int type;
-	struct {
-		size_t length;
-		unsigned long css_ptr;
-	} args[ATOMISP_ACC_NR_MEMORY];
-	struct list_head list;
-};
-
-struct atomisp_map {
-	ia_css_ptr ptr;
-	size_t length;
-	struct list_head list;
-	/* FIXME: should keep book which maps are currently used
-	 * by binaries and not allow releasing those
-	 * which are in use. Implement by reference counting.
-	 */
-};
-
-#define ATOMISP_DEVICE_STREAMING_DISABLED	0
-#define ATOMISP_DEVICE_STREAMING_ENABLED	1
-#define ATOMISP_DEVICE_STREAMING_STOPPING	2
-
-/*
- * ci device struct
- */
-struct atomisp_device {
-	struct pci_dev *pdev;
-	struct device *dev;
-	struct v4l2_device v4l2_dev;
-	struct media_device media_dev;
-	struct atomisp_platform_data *pdata;
-	void *mmu_l1_base;
-	struct pci_dev *pci_root;
-	const struct firmware *firmware;
-
-	struct pm_qos_request pm_qos;
-	s32 max_isr_latency;
-
-	struct {
-		struct list_head fw;
-		struct list_head memory_maps;
-		struct atomisp_css_pipeline *pipeline;
-		bool extension_mode;
-		struct ida ida;
-		struct completion acc_done;
-		void *acc_stages;
-	} acc;
-
-
-	/*
-	 * ISP modules
-	 * Multiple streams are represents by multiple
-	 * atomisp_sub_device instances
-	 */
-	struct atomisp_sub_device *asd;
-	/*
-	 * this will be assiged dyanamically.
-	 * For CTP(ISP2300), only 1 stream is supported.
-	 * For Merr/BTY(ISP2400), 2 streams are supported.
-	 */
-	unsigned int num_of_streams;
-	/*
-	 * MRFLD has 3 CSI ports, while MFLD has only 2.
-	 */
-	struct atomisp_mipi_csi2_device csi2_port[ATOMISP_CAMERA_NR_PORTS];
-	struct atomisp_tpg_device tpg;
-	struct atomisp_file_device file_dev;
-
-	/* Purpose of mutex is to protect and serialize use of isp data
-	 * structures and css API calls. */
-	struct mutex mutex;
-	/*
-	 * Serialise streamoff: mutex is dropped during streamoff to
-	 * cancel the watchdog queue. MUST be acquired BEFORE
-	 * "mutex".
-	 */
-	struct mutex streamoff_mutex;
-
-	int input_cnt;
-	struct atomisp_input_subdev inputs[ATOM_ISP_MAX_INPUTS];
-	struct v4l2_subdev *flash;
-	struct v4l2_subdev *motor;
-
-	struct atomisp_regs saved_regs;
-	struct atomisp_sw_contex sw_contex;
-	struct atomisp_css_env css_env;
-
-	/* isp timeout status flag */
-	bool isp_timeout;
-	bool isp_fatal_error;
-	struct workqueue_struct *wdt_work_queue;
-	struct work_struct wdt_work;
-	struct timer_list wdt;
-	atomic_t wdt_count;
-	unsigned int wdt_duration;	/* in jiffies */
-	atomic_t fast_reset;
-
-	spinlock_t lock; /* Just for streaming below */
-
-	bool need_gfx_throttle;
-
-	unsigned int mipi_frame_size;
-};
-
-#define v4l2_dev_to_atomisp_device(dev) \
-	container_of(dev, struct atomisp_device, v4l2_dev)
-
-extern struct device *atomisp_dev;
-
-extern void *atomisp_kernel_malloc(size_t bytes);
-
-extern void atomisp_kernel_free(void *ptr);
-
-#endif /* __ATOMISP_INTERNAL_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.c
deleted file mode 100644
index ee3453b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.c
+++ /dev/null
@@ -1,2481 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <linux/delay.h>
-
-#include <asm/intel-mid.h>
-
-#include <media/v4l2-ioctl.h>
-#include <media/videobuf-vmalloc.h>
-
-#include "atomisp_acc.h"
-#include "atomisp_cmd.h"
-#include "atomisp_common.h"
-#include "atomisp_fops.h"
-#include "atomisp_internal.h"
-#include "atomisp_ioctl.h"
-#include "atomisp-regs.h"
-#include "atomisp_compat.h"
-
-#include "sh_css_hrt.h"
-
-#ifndef CSS20
-#include "sh_css.h"
-#endif /* CSS20 */
-
-#include "gp_device.h"
-#include "device_access.h"
-#include "irq.h"
-
-#include "hrt/hive_isp_css_mm_hrt.h"
-
-/* for v4l2_capability */
-static const char *DRIVER = "atomisp";	/* max size 15 */
-static const char *CARD = "ATOM ISP";	/* max size 31 */
-static const char *BUS_INFO = "PCI-3";	/* max size 31 */
-static const u32 VERSION = DRIVER_VERSION;
-
-/*
- * FIXME: ISP should not know beforehand all CIDs supported by sensor.
- * Instead, it needs to propagate to sensor unkonwn CIDs.
- */
-static struct v4l2_queryctrl ci_v4l2_controls[] = {
-	{
-		.id = V4L2_CID_AUTO_WHITE_BALANCE,
-		.type = V4L2_CTRL_TYPE_BOOLEAN,
-		.name = "Automatic White Balance",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_RED_BALANCE,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Red Balance",
-		.minimum = 0x00,
-		.maximum = 0xff,
-		.step = 1,
-		.default_value = 0x00,
-	},
-	{
-		.id = V4L2_CID_BLUE_BALANCE,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Blue Balance",
-		.minimum = 0x00,
-		.maximum = 0xff,
-		.step = 1,
-		.default_value = 0x00,
-	},
-	{
-		.id = V4L2_CID_GAMMA,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Gamma",
-		.minimum = 0x00,
-		.maximum = 0xff,
-		.step = 1,
-		.default_value = 0x00,
-	},
-	{
-		.id = V4L2_CID_HFLIP,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Image h-flip",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_VFLIP,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Image v-flip",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_POWER_LINE_FREQUENCY,
-		.type = V4L2_CTRL_TYPE_MENU,
-		.name = "Light frequency filter",
-		.minimum = 1,
-		.maximum = 2,
-		.step = 1,
-		.default_value = 1,
-	},
-	{
-		.id = V4L2_CID_COLORFX,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Image Color Effect",
-		.minimum = 0,
-		.maximum = 9,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Bad Pixel Correction",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "GDC/CAC",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_ATOMISP_VIDEO_STABLIZATION,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Video Stablization",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_ATOMISP_FIXED_PATTERN_NR,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Fixed Pattern Noise Reduction",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "False Color Correction",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_REQUEST_FLASH,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Request flash frames",
-		.minimum = 0,
-		.maximum = 10,
-		.step = 1,
-		.default_value = 1,
-	},
-	{
-		.id = V4L2_CID_ATOMISP_LOW_LIGHT,
-		.type = V4L2_CTRL_TYPE_BOOLEAN,
-		.name = "Low light mode",
-		.minimum = 0,
-		.maximum = 1,
-		.step = 1,
-		.default_value = 1,
-	},
-	{
-		.id = V4L2_CID_BIN_FACTOR_HORZ,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Horizontal binning factor",
-		.minimum = 0,
-		.maximum = 10,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_BIN_FACTOR_VERT,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "Vertical binning factor",
-		.minimum = 0,
-		.maximum = 10,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_2A_STATUS,
-		.type = V4L2_CTRL_TYPE_BITMASK,
-		.name = "AE and AWB status",
-		.minimum = 0,
-		.maximum = V4L2_2A_STATUS_AE_READY | V4L2_2A_STATUS_AWB_READY,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_EXPOSURE,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "exposure",
-		.minimum = -4,
-		.maximum = 4,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_SCENE_MODE,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "scene mode",
-		.minimum = 0,
-		.maximum = 13,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_ISO_SENSITIVITY,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "iso",
-		.minimum = -4,
-		.maximum = 4,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.name = "white balance",
-		.minimum = 0,
-		.maximum = 9,
-		.step = 1,
-		.default_value = 0,
-	},
-	{
-		.id = V4L2_CID_EXPOSURE_METERING,
-		.type = V4L2_CTRL_TYPE_MENU,
-		.name = "metering",
-		.minimum = 0,
-		.maximum = 2,
-		.step = 1,
-		.default_value = 1,
-	},
-	{
-		.id = V4L2_CID_3A_LOCK,
-		.type = V4L2_CTRL_TYPE_BITMASK,
-		.name = "3a lock",
-		.minimum = 0,
-		.maximum = V4L2_LOCK_EXPOSURE | V4L2_LOCK_WHITE_BALANCE
-			 | V4L2_LOCK_FOCUS,
-		.step = 1,
-		.default_value = 0,
-	},
-};
-static const u32 ctrls_num = ARRAY_SIZE(ci_v4l2_controls);
-
-/*
- * supported V4L2 fmts and resolutions
- */
-const struct atomisp_format_bridge atomisp_output_fmts[] = {
-	{
-		.pixelformat = V4L2_PIX_FMT_YUV420,
-		.depth = 12,
-		.mbus_code = 0x8001,
-		.sh_fmt = CSS_FRAME_FORMAT_YUV420,
-		.description = "YUV420, planar",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YVU420,
-		.depth = 12,
-		.mbus_code = 0x8002,
-		.sh_fmt = CSS_FRAME_FORMAT_YV12,
-		.description = "YVU420, planar",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YUV422P,
-		.depth = 16,
-		.mbus_code = 0x8003,
-		.sh_fmt = CSS_FRAME_FORMAT_YUV422,
-		.description = "YUV422, planar",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YUV444,
-		.depth = 24,
-		.mbus_code = 0x8004,
-		.sh_fmt = CSS_FRAME_FORMAT_YUV444,
-		.description = "YUV444"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_NV12,
-		.depth = 12,
-		.mbus_code = 0x8005,
-		.sh_fmt = CSS_FRAME_FORMAT_NV12,
-		.description = "NV12, Y-plane, CbCr interleaved",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_NV21,
-		.depth = 12,
-		.mbus_code = 0x8006,
-		.sh_fmt = CSS_FRAME_FORMAT_NV21,
-		.description = "NV21, Y-plane, CbCr interleaved",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_NV16,
-		.depth = 16,
-		.mbus_code = 0x8007,
-		.sh_fmt = CSS_FRAME_FORMAT_NV16,
-		.description = "NV16, Y-plane, CbCr interleaved",
-		.planar = true
-	}, {
-		.pixelformat = V4L2_PIX_FMT_YUYV,
-		.depth = 16,
-		.mbus_code = 0x8008,
-		.sh_fmt = CSS_FRAME_FORMAT_YUYV,
-		.description = "YUYV, interleaved"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_UYVY,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_UYVY8_1X16,
-		.sh_fmt = CSS_FRAME_FORMAT_UYVY,
-		.description = "UYVY, interleaved"
-	}, { /* This one is for parallel sensors! DO NOT USE! */
-		.pixelformat = V4L2_PIX_FMT_UYVY,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_UYVY8_2X8,
-		.sh_fmt = CSS_FRAME_FORMAT_UYVY,
-		.description = "UYVY, interleaved"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR16,
-		.depth = 16,
-		.mbus_code = 0x8009,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 16"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR8,
-		.depth = 8,
-		.mbus_code = V4L2_MBUS_FMT_SBGGR8_1X8,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGBRG8,
-		.depth = 8,
-		.mbus_code = V4L2_MBUS_FMT_SGBRG8_1X8,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGRBG8,
-		.depth = 8,
-		.mbus_code = V4L2_MBUS_FMT_SGRBG8_1X8,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SRGGB8,
-		.depth = 8,
-		.mbus_code = V4L2_MBUS_FMT_SRGGB8_1X8,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR10,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SBGGR10_1X10,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGBRG10,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SGBRG10_1X10,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGRBG10,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SGRBG10_1X10,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SRGGB10,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SRGGB10_1X10,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 10"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SBGGR12,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SBGGR12_1X12,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGBRG12,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SGBRG12_1X12,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SGRBG12,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SGRBG12_1X12,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_SRGGB12,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_SRGGB12_1X12,
-		.sh_fmt = CSS_FRAME_FORMAT_RAW,
-		.description = "Bayer 12"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_RGB32,
-		.depth = 32,
-		.mbus_code = 0x800a,
-		.sh_fmt = CSS_FRAME_FORMAT_RGBA888,
-		.description = "32 RGB 8-8-8-8"
-	}, {
-		.pixelformat = V4L2_PIX_FMT_RGB565,
-		.depth = 16,
-		.mbus_code = V4L2_MBUS_FMT_BGR565_2X8_LE,
-		.sh_fmt = CSS_FRAME_FORMAT_RGB565,
-		.description = "16 RGB 5-6-5"
-	},
-};
-
-const struct atomisp_format_bridge *atomisp_get_format_bridge(
-	unsigned int pixelformat)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {
-		if (atomisp_output_fmts[i].pixelformat == pixelformat)
-			return &atomisp_output_fmts[i];
-	}
-
-	return NULL;
-}
-
-const struct atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(
-	enum v4l2_mbus_pixelcode mbus_code)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {
-		if (mbus_code == atomisp_output_fmts[i].mbus_code)
-			return &atomisp_output_fmts[i];
-	}
-
-	return NULL;
-}
-
-/*
- * v4l2 ioctls
- * return ISP capabilities
- *
- * FIXME: capabilities should be different for video0/video2/video3
- */
-static int atomisp_querycap(struct file *file, void *fh,
-			    struct v4l2_capability *cap)
-{
-	int ret = 0;
-
-	memset(cap, 0, sizeof(struct v4l2_capability));
-
-	WARN_ON(sizeof(DRIVER) > sizeof(cap->driver) ||
-		sizeof(CARD) > sizeof(cap->card) ||
-		sizeof(BUS_INFO) > sizeof(cap->bus_info));
-
-	strncpy(cap->driver, DRIVER, sizeof(cap->driver) - 1);
-	strncpy(cap->card, CARD, sizeof(cap->card) - 1);
-	strncpy(cap->bus_info, BUS_INFO, sizeof(cap->card) - 1);
-
-	cap->version = VERSION;
-
-	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
-	    V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
-
-	return ret;
-}
-
-/*
- * return sensor chip identification
- */
-static int atomisp_g_chip_ident(struct file *file, void *fh,
-	struct v4l2_dbg_chip_ident *chip)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-
-	int ret = 0;
-
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-			       core, g_chip_ident, chip);
-
-	if (ret)
-		dev_err(isp->dev, "failed to g_chip_ident for sensor\n");
-	return ret;
-}
-
-/*
- * enum input are used to check primary/secondary camera
- */
-static int atomisp_enum_input(struct file *file, void *fh,
-	struct v4l2_input *input)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int index = input->index;
-
-	if (index >= isp->input_cnt)
-		return -EINVAL;
-
-	if (!isp->inputs[index].camera)
-		return -EINVAL;
-
-	memset(input, 0, sizeof(struct v4l2_input));
-	strncpy(input->name, isp->inputs[index].camera->name,
-		sizeof(input->name) - 1);
-
-	/*
-	 * HACK: append actuator's name to sensor's
-	 * As currently userspace can't talk directly to subdev nodes, this
-	 * ioctl is the only way to enum inputs + possible external actuators
-	 * for 3A tuning purpose.
-	 */
-	if (isp->inputs[index].motor &&
-	    strlen(isp->inputs[index].motor->name) > 0) {
-		const int cur_len = strlen(input->name);
-		const int max_size = sizeof(input->name) - cur_len - 1;
-
-		if (max_size > 0) {
-			input->name[cur_len] = '+';
-			strncpy(&input->name[cur_len + 1],
-				isp->inputs[index].motor->name, max_size - 1);
-		}
-	}
-
-	input->type = V4L2_INPUT_TYPE_CAMERA;
-	input->index = index;
-	input->reserved[0] = isp->inputs[index].type;
-	input->reserved[1] = isp->inputs[index].port;
-
-	return 0;
-}
-
-static unsigned int atomisp_subdev_streaming_count(
-					struct atomisp_sub_device *asd)
-{
-	return asd->video_out_preview.capq.streaming
-		+ asd->video_out_capture.capq.streaming
-		+ asd->video_out_video_capture.capq.streaming
-		+ asd->video_in.capq.streaming;
-}
-
-unsigned int atomisp_streaming_count(struct atomisp_device *isp)
-{
-	unsigned int i, sum;
-
-	for (i = 0, sum = 0; i < isp->num_of_streams; i++)
-		sum += isp->asd[i].streaming ==
-		    ATOMISP_DEVICE_STREAMING_ENABLED;
-
-	return sum;
-}
-
-/*
- * get input are used to get current primary/secondary camera
- */
-static int atomisp_g_input(struct file *file, void *fh, unsigned int *input)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-
-	mutex_lock(&isp->mutex);
-	*input = asd->input_curr;
-	mutex_unlock(&isp->mutex);
-
-	return 0;
-}
-/*
- * set input are used to set current primary/secondary camera
- */
-static int atomisp_s_input(struct file *file, void *fh, unsigned int input)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct v4l2_subdev *camera = NULL;
-	int ret;
-
-	mutex_lock(&isp->mutex);
-	if (input >= ATOM_ISP_MAX_INPUTS || input > isp->input_cnt) {
-		dev_dbg(isp->dev, "input_cnt: %d\n", isp->input_cnt);
-		ret = -EINVAL;
-		goto error;
-	}
-
-	/*
-	 * check whether the request camera:
-	 * 1: already in use
-	 * 2: if in use, whether it is used by other streams
-	 */
-	if (isp->inputs[input].asd != NULL && isp->inputs[input].asd != asd) {
-		dev_err(isp->dev,
-			 "%s, camera is already used by stream: %d\n", __func__,
-			 isp->inputs[input].asd->index);
-		ret = -EBUSY;
-		goto error;
-	}
-
-	camera = isp->inputs[input].camera;
-	if (!camera) {
-		dev_err(isp->dev, "%s, no camera\n", __func__);
-		ret = -EINVAL;
-		goto error;
-	}
-
-	if (atomisp_subdev_streaming_count(asd)) {
-		dev_err(isp->dev,
-			 "ISP is still streaming, stop first\n");
-		ret = -EINVAL;
-		goto error;
-	}
-
-	/* power off the current owned sensor, as it is not used this time */
-	if (isp->inputs[asd->input_curr].asd == asd &&
-	    asd->input_curr != input) {
-		ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				       core, s_power, 0);
-		if (ret)
-			dev_warn(isp->dev,
-				    "Failed to power-off sensor\n");
-		/* clear the asd field to show this camera is not used */
-		isp->inputs[asd->input_curr].asd = NULL;
-	}
-
-	/* powe on the new sensor */
-	ret = v4l2_subdev_call(isp->inputs[input].camera, core, s_power, 1);
-	if (ret) {
-		dev_err(isp->dev, "Failed to power-on sensor\n");
-		goto error;
-	}
-
-	if (!isp->sw_contex.file_input && isp->inputs[input].motor)
-		ret = v4l2_subdev_call(isp->inputs[input].motor, core,
-				       init, 1);
-
-	asd->input_curr = input;
-	/* mark this camera is used by the current stream */
-	isp->inputs[input].asd = asd;
-	mutex_unlock(&isp->mutex);
-
-	return 0;
-
-error:
-	mutex_unlock(&isp->mutex);
-
-	return ret;
-}
-
-static int atomisp_enum_fmt_cap(struct file *file, void *fh,
-	struct v4l2_fmtdesc *f)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct v4l2_subdev_mbus_code_enum code = { 0 };
-	unsigned int i, fi = 0;
-	int rval;
-
-	mutex_lock(&isp->mutex);
-	rval = v4l2_subdev_call(isp->inputs[asd->input_curr].camera, pad,
-				enum_mbus_code, NULL, &code);
-	if (rval == -ENOIOCTLCMD) {
-		dev_warn(isp->dev, "enum_mbus_code pad op not supported. Please fix your sensor driver!\n");
-		rval = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-					video, enum_mbus_fmt, 0, &code.code);
-	}
-	mutex_unlock(&isp->mutex);
-
-	if (rval)
-		return rval;
-
-	for (i = 0; i < ARRAY_SIZE(atomisp_output_fmts); i++) {
-		const struct atomisp_format_bridge *format =
-			&atomisp_output_fmts[i];
-
-		/*
-		 * Is the atomisp-supported format is valid for the
-		 * sensor (configuration)? If not, skip it.
-		 */
-		if (format->sh_fmt == CSS_FRAME_FORMAT_RAW
-		    && format->mbus_code != code.code)
-			continue;
-
-		/* Found a match. Now let's pick f->index'th one. */
-		if (fi < f->index) {
-			fi++;
-			continue;
-		}
-
-		strlcpy(f->description, format->description,
-			sizeof(f->description));
-		f->pixelformat = format->pixelformat;
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static int atomisp_g_fmt_cap(struct file *file, void *fh,
-	struct v4l2_format *f)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-
-	int ret;
-
-	mutex_lock(&isp->mutex);
-	ret = atomisp_get_fmt(vdev, f);
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-static int atomisp_g_fmt_file(struct file *file, void *fh,
-		struct v4l2_format *f)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-
-	mutex_lock(&isp->mutex);
-	f->fmt.pix = pipe->pix;
-	mutex_unlock(&isp->mutex);
-
-	return 0;
-}
-
-/* This function looks up the closest available resolution. */
-static int atomisp_try_fmt_cap(struct file *file, void *fh,
-	struct v4l2_format *f)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int ret;
-
-	mutex_lock(&isp->mutex);
-	ret = atomisp_try_fmt(vdev, f, NULL);
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-static int atomisp_s_fmt_cap(struct file *file, void *fh,
-	struct v4l2_format *f)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int ret;
-
-	mutex_lock(&isp->mutex);
-	if (isp->isp_fatal_error) {
-		ret = -EIO;
-		mutex_unlock(&isp->mutex);
-		return ret;
-	}
-	ret = atomisp_set_fmt(vdev, f);
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-static int atomisp_s_fmt_file(struct file *file, void *fh,
-				struct v4l2_format *f)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int ret;
-
-	mutex_lock(&isp->mutex);
-	ret = atomisp_set_fmt_file(vdev, f);
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-/*
- * is_resolution_supported - Check whether resolution is supported
- * @width: check resolution width
- * @height: check resolution height
- *
- * Return 1 on supported or 0 otherwise.
-*/
-static int is_resolution_supported(u32 width, u32 height)
-{
-	if ((width > ATOM_ISP_MIN_WIDTH) && (width <= ATOM_ISP_MAX_WIDTH) &&
-	    (height > ATOM_ISP_MIN_HEIGHT) && (height <= ATOM_ISP_MAX_HEIGHT)) {
-		if (!(width % ATOM_ISP_STEP_WIDTH) &&
-		    !(height % ATOM_ISP_STEP_HEIGHT))
-			return 1;
-	}
-
-	return 0;
-}
-
-/*
- * This ioctl allows applications to enumerate all frame intervals that the
- * device supports for the given pixel format and frame size.
- *
- * framerate =  1 / frameintervals
- */
-static int atomisp_enum_frameintervals(struct file *file, void *fh,
-	struct v4l2_frmivalenum *arg)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	int ret;
-
-	if (arg->index != 0)
-		return -EINVAL;
-
-	if (!atomisp_get_format_bridge(arg->pixel_format))
-		return -EINVAL;
-
-	if (!is_resolution_supported(arg->width, arg->height))
-		return -EINVAL;
-
-	mutex_lock(&isp->mutex);
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-		video, enum_frameintervals, arg);
-
-	if (ret) {
-		/* set the FPS to default 15*/
-		arg->type = V4L2_FRMIVAL_TYPE_DISCRETE;
-		arg->discrete.numerator = 1;
-		arg->discrete.denominator = 15;
-	}
-	mutex_unlock(&isp->mutex);
-
-	return 0;
-}
-
-/*
- * Free videobuffer buffer priv data
- */
-void atomisp_videobuf_free_buf(struct videobuf_buffer *vb)
-{
-	struct videobuf_vmalloc_memory *vm_mem;
-
-	if (vb == NULL)
-		return;
-
-	vm_mem = vb->priv;
-	if (vm_mem && vm_mem->vaddr) {
-		atomisp_css_frame_free(vm_mem->vaddr);
-		vm_mem->vaddr = NULL;
-	}
-}
-
-/*
- * this function is used to free video buffer queue
- */
-static void atomisp_videobuf_free_queue(struct videobuf_queue *q)
-{
-	int i;
-
-	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
-		atomisp_videobuf_free_buf(q->bufs[i]);
-		kfree(q->bufs[i]);
-		q->bufs[i] = NULL;
-	}
-}
-
-int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd)
-{
-	struct atomisp_s3a_buf *s3a_buf = NULL, *_s3a_buf;
-	struct atomisp_dis_buf *dis_buf = NULL, *_dis_buf;
-	/* 2 css pipes consuming 3a buffers */
-	int count = ATOMISP_CSS_Q_DEPTH * 2;
-	struct atomisp_device *isp = asd->isp;
-
-	if (!list_empty(&asd->s3a_stats) && !list_empty(&asd->dis_stats))
-		return 0;
-
-	dev_dbg(isp->dev, "allocating %d 3a & dis buffers\n", count);
-
-	while (count--) {
-		s3a_buf = kzalloc(sizeof(struct atomisp_s3a_buf), GFP_KERNEL);
-		if (!s3a_buf) {
-			dev_err(isp->dev, "s3a stat buf alloc failed\n");
-			goto error;
-		}
-
-		dis_buf = kzalloc(sizeof(struct atomisp_dis_buf), GFP_KERNEL);
-		if (!dis_buf) {
-			dev_err(isp->dev, "dis stat buf alloc failed\n");
-			kfree(s3a_buf);
-			goto error;
-		}
-
-		if (atomisp_css_allocate_3a_dis_bufs(asd, s3a_buf, dis_buf)) {
-			kfree(s3a_buf);
-			kfree(dis_buf);
-			goto error;
-		}
-
-		list_add_tail(&s3a_buf->list, &asd->s3a_stats);
-		list_add_tail(&dis_buf->list, &asd->dis_stats);
-	}
-
-	return 0;
-
-error:
-	dev_err(isp->dev, "failed to allocate statistics buffers\n");
-
-	list_for_each_entry_safe(dis_buf, _dis_buf, &asd->dis_stats, list) {
-		atomisp_css_free_dis_buffers(dis_buf);
-		list_del(&dis_buf->list);
-		kfree(dis_buf);
-	}
-
-	list_for_each_entry_safe(s3a_buf, _s3a_buf, &asd->s3a_stats, list) {
-		atomisp_css_free_3a_buffers(s3a_buf);
-		list_del(&s3a_buf->list);
-		kfree(s3a_buf);
-	}
-
-	return -ENOMEM;
-}
-
-/*
- * Initiate Memory Mapping or User Pointer I/O
- */
-int __atomisp_reqbufs(struct file *file, void *fh,
-	struct v4l2_requestbuffers *req)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct atomisp_css_frame_info frame_info;
-	struct atomisp_css_frame *frame;
-	struct videobuf_vmalloc_memory *vm_mem;
-	uint16_t source_pad = atomisp_subdev_source_pad(vdev);
-	int ret = 0, i = 0;
-
-	if (req->count == 0) {
-		mutex_lock(&pipe->capq.vb_lock);
-		if (!list_empty(&pipe->capq.stream))
-			videobuf_queue_cancel(&pipe->capq);
-		atomisp_videobuf_free_queue(&pipe->capq);
-		mutex_unlock(&pipe->capq.vb_lock);
-		return 0;
-	}
-
-	ret = videobuf_reqbufs(&pipe->capq, req);
-	if (ret)
-		return ret;
-
-	atomisp_alloc_css_stat_bufs(asd);
-
-	/*
-	 * for user pointer type, buffers are not really allcated here,
-	 * buffers are setup in QBUF operation through v4l2_buffer structure
-	 */
-	if (req->memory == V4L2_MEMORY_USERPTR)
-		return 0;
-
-	ret = atomisp_get_css_frame_info(asd, source_pad, &frame_info);
-	if (ret)
-		return ret;
-
-	/*
-	 * Allocate the real frame here for selected node using our
-	 * memory management function
-	 */
-	for (i = 0; i < req->count; i++) {
-		if (atomisp_css_frame_allocate_from_info(&frame, &frame_info))
-			goto error;
-		vm_mem = pipe->capq.bufs[i]->priv;
-		vm_mem->vaddr = frame;
-	}
-
-	return ret;
-
-error:
-	while (i--) {
-		vm_mem = pipe->capq.bufs[i]->priv;
-		atomisp_css_frame_free(vm_mem->vaddr);
-	}
-
-	if (asd->vf_frame)
-		atomisp_css_frame_free(asd->vf_frame);
-
-	return -ENOMEM;
-}
-
-int atomisp_reqbufs(struct file *file, void *fh,
-	struct v4l2_requestbuffers *req)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int ret;
-
-	mutex_lock(&isp->mutex);
-	ret = __atomisp_reqbufs(file, fh, req);
-	mutex_unlock(&isp->mutex);
-
-	return ret;
-}
-
-static int atomisp_reqbufs_file(struct file *file, void *fh,
-		struct v4l2_requestbuffers *req)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-
-	if (req->count == 0) {
-		mutex_lock(&pipe->outq.vb_lock);
-		atomisp_videobuf_free_queue(&pipe->outq);
-		mutex_unlock(&pipe->outq.vb_lock);
-		return 0;
-	}
-
-	return videobuf_reqbufs(&pipe->outq, req);
-}
-
-/* application query the status of a buffer */
-static int atomisp_querybuf(struct file *file, void *fh,
-	struct v4l2_buffer *buf)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-
-	return videobuf_querybuf(&pipe->capq, buf);
-}
-
-static int atomisp_querybuf_file(struct file *file, void *fh,
-				struct v4l2_buffer *buf)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-
-	return videobuf_querybuf(&pipe->outq, buf);
-}
-
-/*
- * Applications call the VIDIOC_QBUF ioctl to enqueue an empty (capturing) or
- * filled (output) buffer in the drivers incoming queue.
- */
-static int atomisp_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
-{
-	static const int NOFLUSH_FLAGS = V4L2_BUF_FLAG_NO_CACHE_INVALIDATE |
-					 V4L2_BUF_FLAG_NO_CACHE_CLEAN;
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct videobuf_buffer *vb;
-	struct videobuf_vmalloc_memory *vm_mem;
-	struct atomisp_css_frame_info frame_info;
-	struct atomisp_css_frame *handle = NULL;
-	u32 length;
-	u32 pgnr;
-	int ret = 0;
-
-	mutex_lock(&isp->mutex);
-	if (isp->isp_fatal_error) {
-		ret = -EIO;
-		goto error;
-	}
-
-	if (asd->streaming == ATOMISP_DEVICE_STREAMING_STOPPING) {
-		dev_err(isp->dev, "ISP ERROR\n");
-		ret = -EIO;
-		goto error;
-	}
-
-	if (!buf || buf->index >= VIDEO_MAX_FRAME ||
-		!pipe->capq.bufs[buf->index]) {
-		dev_err(isp->dev, "Invalid index for qbuf.\n");
-		ret = -EINVAL;
-		goto error;
-	}
-
-	/*
-	 * For userptr type frame, we convert user space address to physic
-	 * address and reprograme out page table properly
-	 */
-	if (buf->memory == V4L2_MEMORY_USERPTR) {
-		struct hrt_userbuffer_attr attributes;
-		vb = pipe->capq.bufs[buf->index];
-		vm_mem = vb->priv;
-		if (!vm_mem) {
-			ret = -EINVAL;
-			goto error;
-		}
-
-		length = vb->bsize;
-		pgnr = (length + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-
-		if (vb->baddr == buf->m.userptr && vm_mem->vaddr)
-			goto done;
-
-		if (atomisp_get_css_frame_info(asd,
-				atomisp_subdev_source_pad(vdev), &frame_info)) {
-			ret = -EIO;
-			goto error;
-		}
-
-		attributes.pgnr = pgnr;
-#ifdef CONFIG_ION
-		attributes.type = buf->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_ION
-					? HRT_USR_ION : HRT_USR_PTR;
-#else
-		attributes.type = HRT_USR_PTR;
-#endif
-		ret = atomisp_css_frame_map(&handle, &frame_info,
-				       (void *)buf->m.userptr,
-				       0, &attributes);
-		if (ret) {
-			dev_err(isp->dev, "Failed to map user buffer\n");
-			goto error;
-		}
-
-		if (vm_mem->vaddr) {
-			mutex_lock(&pipe->capq.vb_lock);
-			atomisp_css_frame_free(vm_mem->vaddr);
-			vm_mem->vaddr = NULL;
-			vb->state = VIDEOBUF_NEEDS_INIT;
-			mutex_unlock(&pipe->capq.vb_lock);
-		}
-
-		vm_mem->vaddr = handle;
-
-		buf->flags &= ~V4L2_BUF_FLAG_MAPPED;
-		buf->flags |= V4L2_BUF_FLAG_QUEUED;
-		buf->flags &= ~V4L2_BUF_FLAG_DONE;
-
-	} else if (buf->memory == V4L2_MEMORY_MMAP) {
-		buf->flags |= V4L2_BUF_FLAG_MAPPED;
-		buf->flags |= V4L2_BUF_FLAG_QUEUED;
-		buf->flags &= ~V4L2_BUF_FLAG_DONE;
-	}
-
-done:
-	if (!((buf->flags & NOFLUSH_FLAGS) == NOFLUSH_FLAGS))
-		wbinvd();
-
-	ret = videobuf_qbuf(&pipe->capq, buf);
-	if (ret)
-		goto error;
-
-	/* TODO: do this better, not best way to queue to css */
-	if (asd->streaming == ATOMISP_DEVICE_STREAMING_ENABLED) {
-		atomisp_qbuffers_to_css(asd);
-
-		if (!timer_pending(&isp->wdt) && atomisp_buffers_queued(asd))
-			mod_timer(&isp->wdt, jiffies + isp->wdt_duration);
-	}
-	mutex_unlock(&isp->mutex);
-
-	dev_dbg(isp->dev, "qbuf buffer %d (%s)\n", buf->index, vdev->name);
-
-	return ret;
-
-error:
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-static int atomisp_qbuf_file(struct file *file, void *fh,
-					struct v4l2_buffer *buf)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	int ret;
-
-	mutex_lock(&isp->mutex);
-	if (isp->isp_fatal_error) {
-		ret = -EIO;
-		goto error;
-	}
-
-	if (!buf || buf->index >= VIDEO_MAX_FRAME ||
-		!pipe->outq.bufs[buf->index]) {
-		dev_err(isp->dev, "Invalid index for qbuf.\n");
-		ret = -EINVAL;
-		goto error;
-	}
-
-	if (buf->memory != V4L2_MEMORY_MMAP) {
-		dev_err(isp->dev, "Unsupported memory method\n");
-		ret = -EINVAL;
-		goto error;
-	}
-
-	if (buf->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
-		dev_err(isp->dev, "Unsupported buffer type\n");
-		ret = -EINVAL;
-		goto error;
-	}
-	mutex_unlock(&isp->mutex);
-
-	return videobuf_qbuf(&pipe->outq, buf);
-
-error:
-	mutex_unlock(&isp->mutex);
-
-	return ret;
-}
-
-/*
- * Applications call the VIDIOC_DQBUF ioctl to dequeue a filled (capturing) or
- * displayed (output buffer)from the driver's outgoing queue
- */
-static int atomisp_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int ret = 0;
-
-	mutex_lock(&isp->mutex);
-
-	if (isp->isp_fatal_error) {
-		mutex_unlock(&isp->mutex);
-		return -EIO;
-	}
-
-	if (asd->streaming == ATOMISP_DEVICE_STREAMING_STOPPING) {
-		mutex_unlock(&isp->mutex);
-		dev_err(isp->dev, "ISP ERROR\n");
-		return -EIO;
-	}
-
-	mutex_unlock(&isp->mutex);
-
-	ret = videobuf_dqbuf(&pipe->capq, buf, file->f_flags & O_NONBLOCK);
-	if (ret) {
-		dev_dbg(isp->dev, "<%s: %d\n", __func__, ret);
-		return ret;
-	}
-	mutex_lock(&isp->mutex);
-	buf->bytesused = pipe->pix.sizeimage;
-	buf->reserved = asd->frame_status[buf->index];
-	mutex_unlock(&isp->mutex);
-
-	dev_dbg(isp->dev, "dqbuf buffer %d (%s)\n", buf->index, vdev->name);
-
-	return 0;
-}
-
-enum atomisp_css_pipe_id atomisp_get_css_pipe_id(struct atomisp_sub_device *asd)
-{
-	if (asd->continuous_mode->val) {
-		if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-			return CSS_PIPE_ID_VIDEO;
-		else
-			return CSS_PIPE_ID_PREVIEW;
-	}
-
-	/*
-	 * Disable vf_pp and run CSS in video mode. This allows using ISP
-	 * scaling but it has one frame delay due to CSS internal buffering.
-	 */
-	if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_SCALER)
-		return CSS_PIPE_ID_VIDEO;
-
-	/*
-	 * Disable vf_pp and run CSS in still capture mode. In this mode
-	 * CSS does not cause extra latency with buffering, but scaling
-	 * is not available.
-	 */
-	if (asd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT)
-		return CSS_PIPE_ID_CAPTURE;
-
-	switch (asd->run_mode->val) {
-	case ATOMISP_RUN_MODE_PREVIEW:
-		return CSS_PIPE_ID_PREVIEW;
-	case ATOMISP_RUN_MODE_VIDEO:
-		return CSS_PIPE_ID_VIDEO;
-	case ATOMISP_RUN_MODE_STILL_CAPTURE:
-		/* fall through */
-	default:
-		return CSS_PIPE_ID_CAPTURE;
-	}
-}
-
-static unsigned int atomisp_sensor_start_stream(struct atomisp_sub_device *asd)
-{
-	if (asd->vfpp->val != ATOMISP_VFPP_ENABLE)
-		return 1;
-
-	if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO ||
-	    (asd->run_mode->val == ATOMISP_RUN_MODE_STILL_CAPTURE &&
-	     !atomisp_is_mbuscode_raw(
-		     asd->fmt[
-			     asd->capture_pad].fmt.code) &&
-	     !asd->continuous_mode->val))
-		return 2;
-	else
-		return 1;
-}
-
-/*
- * This ioctl start the capture during streaming I/O.
- */
-static int atomisp_streamon(struct file *file, void *fh,
-	enum v4l2_buf_type type)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	enum atomisp_css_pipe_id css_pipe_id;
-	unsigned int sensor_start_stream;
-	int ret = 0;
-	unsigned long irqflags;
-#ifdef PUNIT_CAMERA_BUSY
-	u32 msg_ret;
-#endif
-	if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_dbg(isp->dev, "unsupported v4l2 buf type\n");
-		return -EINVAL;
-	}
-
-	mutex_lock(&isp->mutex);
-	if (isp->isp_fatal_error) {
-		ret = -EIO;
-		goto out;
-	}
-
-	if (asd->streaming == ATOMISP_DEVICE_STREAMING_STOPPING) {
-		ret = -EBUSY;
-		goto out;
-	}
-
-	if (pipe->capq.streaming)
-		goto out;
-
-	/*
-	 * The number of streaming video nodes is based on which
-	 * binary is going to be run.
-	 */
-	sensor_start_stream = atomisp_sensor_start_stream(asd);
-
-	spin_lock_irqsave(&pipe->irq_lock, irqflags);
-	if (list_empty(&(pipe->capq.stream))) {
-		spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
-		dev_dbg(isp->dev, "no buffer in the queue\n");
-		ret = -EINVAL;
-		goto out;
-	}
-	spin_unlock_irqrestore(&pipe->irq_lock, irqflags);
-
-	ret = videobuf_streamon(&pipe->capq);
-	if (ret)
-		goto out;
-
-	if (atomisp_subdev_streaming_count(asd) > sensor_start_stream) {
-		/* trigger still capture */
-		if (asd->continuous_mode->val &&
-		    atomisp_subdev_source_pad(vdev)
-		    == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE) {
-			if (asd->run_mode->val == ATOMISP_RUN_MODE_VIDEO)
-				dev_dbg(isp->dev, "SDV last video raw buffer id: %u\n",
-					asd->latest_preview_exp_id);
-			else
-				dev_dbg(isp->dev, "ZSL last preview raw buffer id: %u\n",
-					asd->latest_preview_exp_id);
-
-			if (asd->delayed_init != ATOMISP_DELAYED_INIT_DONE) {
-				flush_work(&asd->delayed_init_work);
-				mutex_unlock(&isp->mutex);
-				if (wait_for_completion_interruptible(
-						&asd->init_done) != 0)
-					return -ERESTARTSYS;
-				mutex_lock(&isp->mutex);
-			}
-			ret = atomisp_css_offline_capture_configure(asd,
-				asd->params.offline_parm.num_captures,
-				asd->params.offline_parm.skip_frames,
-				asd->params.offline_parm.offset);
-			if (ret) {
-				ret = -EINVAL;
-				goto out;
-			}
-		}
-		atomisp_qbuffers_to_css(asd);
-		goto out;
-	}
-
-	if (asd->streaming == ATOMISP_DEVICE_STREAMING_ENABLED) {
-		atomisp_qbuffers_to_css(asd);
-		goto start_sensor;
-	}
-
-#ifdef PUNIT_CAMERA_BUSY
-	if (!IS_ISP24XX(isp) && isp->need_gfx_throttle) {
-		/*
-		 * As per h/w architect and ECO 697611 we need to throttle the
-		 * GFX performance (freq) while camera is up to prevent peak
-		 * current issues. this is done by setting the camera busy bit.
-		 */
-		msg_ret = intel_mid_msgbus_read32(PUNIT_PORT, MFLD_OR1);
-		msg_ret |= 0x100;
-		intel_mid_msgbus_write32(PUNIT_PORT, MFLD_OR1, msg_ret);
-	}
-#endif
-
-	css_pipe_id = atomisp_get_css_pipe_id(asd);
-
-	ret = atomisp_acc_load_extensions(asd);
-	if (ret < 0) {
-		dev_err(isp->dev, "acc extension failed to load\n");
-		goto out;
-	}
-	ret = atomisp_css_start(asd, css_pipe_id, false);
-	if (ret)
-		goto out;
-
-	if (asd->continuous_mode->val) {
-		struct v4l2_mbus_framefmt *sink;
-
-		sink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				       V4L2_SUBDEV_FORMAT_ACTIVE,
-				       ATOMISP_SUBDEV_PAD_SINK);
-
-		INIT_COMPLETION(asd->init_done);
-		asd->delayed_init = ATOMISP_DELAYED_INIT_QUEUED;
-		queue_work(asd->delayed_init_workq, &asd->delayed_init_work);
-		atomisp_css_set_cont_prev_start_time(isp,
-				ATOMISP_CALC_CSS_PREV_OVERLAP(sink->height));
-	}
-
-	/* Make sure that update_isp_params is called at least once.*/
-	asd->params.css_update_params_needed = true;
-	asd->streaming = ATOMISP_DEVICE_STREAMING_ENABLED;
-	atomic_set(&asd->sof_count, -1);
-	atomic_set(&asd->sequence, -1);
-	atomic_set(&asd->sequence_temp, -1);
-	atomic_set(&isp->wdt_count, 0);
-	atomic_set(&isp->fast_reset, 0);
-	if (isp->sw_contex.file_input)
-		isp->wdt_duration = ATOMISP_ISP_FILE_TIMEOUT_DURATION;
-	else
-		isp->wdt_duration = ATOMISP_ISP_TIMEOUT_DURATION;
-
-	isp->sw_contex.invalid_frame = false;
-	asd->params.dis_proj_data_valid = false;
-	asd->latest_preview_exp_id = 0;
-
-	atomisp_qbuffers_to_css(asd);
-
-	/* Only start sensor when the last streaming instance started */
-	if (atomisp_subdev_streaming_count(asd) < sensor_start_stream)
-		goto out;
-
-start_sensor:
-	if (isp->flash) {
-		asd->params.num_flash_frames = 0;
-		asd->params.flash_state = ATOMISP_FLASH_IDLE;
-		atomisp_setup_flash(asd);
-	}
-
-	if (!isp->sw_contex.file_input) {
-		atomisp_css_irq_enable(isp, CSS_IRQ_INFO_CSS_RECEIVER_SOF,
-					true);
-#if defined(CSS15) && defined(ISP2300)
-		atomisp_css_irq_enable(isp,
-				CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW, true);
-#endif
-		atomisp_set_term_en_count(isp);
-
-		if (IS_ISP24XX(isp) &&
-			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_AUTO) < 0)
-			dev_dbg(isp->dev, "dfs failed!\n");
-	} else {
-		if (IS_ISP24XX(isp) &&
-			atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_MAX) < 0)
-			dev_dbg(isp->dev, "dfs failed!\n");
-	}
-
-	/* stream on the sensor */
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-			       video, s_stream, 1);
-	if (ret) {
-		atomisp_reset(isp);
-		ret = -EINVAL;
-	}
-
-	if (atomisp_buffers_queued(asd))
-		mod_timer(&isp->wdt, jiffies + isp->wdt_duration);
-
-out:
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_video_pipe *pipe = atomisp_to_video_pipe(vdev);
-	struct atomisp_sub_device *asd = pipe->asd;
-	struct atomisp_video_pipe *capture_pipe = NULL;
-	struct atomisp_video_pipe *vf_pipe = NULL;
-	struct atomisp_video_pipe *preview_pipe = NULL;
-	struct atomisp_video_pipe *video_pipe = NULL;
-	struct videobuf_buffer *vb, *_vb;
-	enum atomisp_css_pipe_id css_pipe_id;
-	int ret;
-	unsigned long flags;
-	bool first_streamoff = false;
-#ifdef PUNIT_CAMERA_BUSY
-	u32 msg_ret;
-#endif
-
-	BUG_ON(!mutex_is_locked(&isp->mutex));
-	BUG_ON(!mutex_is_locked(&isp->streamoff_mutex));
-
-	if (type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_dbg(isp->dev, "unsupported v4l2 buf type\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * do only videobuf_streamoff for capture & vf pipes in
-	 * case of continuous capture
-	 */
-	if (asd->continuous_mode->val &&
-	    atomisp_subdev_source_pad(vdev) !=
-		ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW &&
-	    atomisp_subdev_source_pad(vdev) !=
-		ATOMISP_SUBDEV_PAD_SOURCE_VIDEO) {
-
-		/* stop continuous still capture if needed */
-		if (atomisp_subdev_source_pad(vdev)
-		    == ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE &&
-		    asd->params.offline_parm.num_captures == -1)
-			atomisp_css_offline_capture_configure(asd, 0, 0, 0);
-		/*
-		 * Currently there is no way to flush buffers queued to css.
-		 * When doing videobuf_streamoff, active buffers will be
-		 * marked as VIDEOBUF_NEEDS_INIT. HAL will be able to use
-		 * these buffers again, and these buffers might be queued to
-		 * css more than once! Warn here, if HAL has not dequeued all
-		 * buffers back before calling streamoff.
-		 */
-		if (pipe->buffers_in_css != 0)
-			WARN(1, "%s: buffers of vdev %s still in CSS!\n",
-			     __func__, pipe->vdev.name);
-
-		return videobuf_streamoff(&pipe->capq);
-	}
-
-	if (!pipe->capq.streaming)
-		return 0;
-
-	spin_lock_irqsave(&isp->lock, flags);
-	if (asd->streaming == ATOMISP_DEVICE_STREAMING_ENABLED) {
-		asd->streaming = ATOMISP_DEVICE_STREAMING_STOPPING;
-		first_streamoff = true;
-	}
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	if (first_streamoff) {
-		/* if other streams are running, should not disable watch dog */
-		mutex_unlock(&isp->mutex);
-		if (!atomisp_streaming_count(isp)) {
-			del_timer_sync(&isp->wdt);
-			cancel_work_sync(&isp->wdt_work);
-		}
-
-		/*
-		 * must stop sending pixels into GP_FIFO before stop
-		 * the pipeline.
-		 */
-		if (isp->sw_contex.file_input)
-			v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-					video, s_stream, 0);
-
-		mutex_lock(&isp->mutex);
-	}
-
-	spin_lock_irqsave(&isp->lock, flags);
-	if (atomisp_subdev_streaming_count(asd) == 1)
-		asd->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	if (!first_streamoff) {
-		ret = videobuf_streamoff(&pipe->capq);
-		if (ret)
-			return ret;
-		goto stopsensor;
-	}
-
-	atomisp_clear_css_buffer_counters(asd);
-
-	if (!isp->sw_contex.file_input) {
-		atomisp_css_irq_enable(isp, CSS_IRQ_INFO_CSS_RECEIVER_SOF,
-					false);
-#if defined(CSS15) && defined(ISP2300)
-		atomisp_css_irq_enable(isp,
-				CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW, false);
-#endif
-	}
-
-	if (asd->delayed_init == ATOMISP_DELAYED_INIT_QUEUED) {
-		cancel_work_sync(&asd->delayed_init_work);
-		asd->delayed_init = ATOMISP_DELAYED_INIT_NOT_QUEUED;
-	}
-
-	css_pipe_id = atomisp_get_css_pipe_id(asd);
-	ret = atomisp_css_stop(asd, css_pipe_id, false);
-#ifndef CSS20
-	/* Workaround to avoid system wide crash */
-	if (ret == -EIO)
-		isp->isp_timeout = true;
-#endif
-	atomisp_acc_unload_extensions(asd);
-
-	/* cancel work queue*/
-	if (asd->video_out_capture.users) {
-		capture_pipe = &asd->video_out_capture;
-		wake_up_interruptible(&capture_pipe->capq.wait);
-	}
-	if (asd->video_out_vf.users) {
-		vf_pipe = &asd->video_out_vf;
-		wake_up_interruptible(&vf_pipe->capq.wait);
-	}
-	if (asd->video_out_preview.users) {
-		preview_pipe = &asd->video_out_preview;
-		wake_up_interruptible(&preview_pipe->capq.wait);
-	}
-	if (asd->video_out_video_capture.users) {
-		video_pipe = &asd->video_out_video_capture;
-		wake_up_interruptible(&video_pipe->capq.wait);
-	}
-	ret = videobuf_streamoff(&pipe->capq);
-	if (ret)
-		return ret;
-
-	/* cleanup css here */
-	/* no need for this, as ISP will be reset anyway */
-	/*atomisp_flush_bufs_in_css(isp);*/
-
-	spin_lock_irqsave(&pipe->irq_lock, flags);
-	list_for_each_entry_safe(vb, _vb, &pipe->activeq, queue) {
-		vb->state = VIDEOBUF_PREPARED;
-		list_del(&vb->queue);
-	}
-	spin_unlock_irqrestore(&pipe->irq_lock, flags);
-
-stopsensor:
-	if (atomisp_subdev_streaming_count(asd) + 1
-	    != atomisp_sensor_start_stream(asd))
-		return 0;
-
-	if (!isp->sw_contex.file_input)
-		ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				       video, s_stream, 0);
-
-	if (isp->flash) {
-		asd->params.num_flash_frames = 0;
-		asd->params.flash_state = ATOMISP_FLASH_IDLE;
-	}
-
-	/* if other streams are running, isp should not be powered off */
-	if (atomisp_streaming_count(isp)) {
-		atomisp_css_flush(isp);
-		return 0;
-	}
-
-#ifdef PUNIT_CAMERA_BUSY
-	if (!IS_ISP24XX(isp) && isp->need_gfx_throttle) {
-		/* Free camera_busy bit */
-		msg_ret = intel_mid_msgbus_read32(PUNIT_PORT, MFLD_OR1);
-		msg_ret &= ~0x100;
-		intel_mid_msgbus_write32(PUNIT_PORT, MFLD_OR1, msg_ret);
-	}
-#endif
-
-	if (IS_ISP24XX(isp) && atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW))
-		dev_warn(isp->dev, "DFS failed.\n");
-	/*
-	 * ISP work around, need to reset isp
-	 * Is it correct time to reset ISP when first node does streamoff?
-	 */
-	if (isp->sw_contex.power_state == ATOM_ISP_POWER_UP) {
-		if (isp->isp_timeout)
-			dev_err(isp->dev, "%s: Resetting with WA activated",
-				__func__);
-		atomisp_reset(isp);
-		isp->isp_timeout = false;
-	}
-	return ret;
-}
-
-static int atomisp_streamoff(struct file *file, void *fh,
-			     enum v4l2_buf_type type)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int rval;
-
-	mutex_lock(&isp->streamoff_mutex);
-	mutex_lock(&isp->mutex);
-	rval = __atomisp_streamoff(file, fh, type);
-	mutex_unlock(&isp->mutex);
-	mutex_unlock(&isp->streamoff_mutex);
-
-	return rval;
-}
-
-/*
- * To get the current value of a control.
- * applications initialize the id field of a struct v4l2_control and
- * call this ioctl with a pointer to this structure
- */
-static int atomisp_g_ctrl(struct file *file, void *fh,
-	struct v4l2_control *control)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int i, ret = -EINVAL;
-
-	for (i = 0; i < ctrls_num; i++) {
-		if (ci_v4l2_controls[i].id == control->id) {
-			ret = 0;
-			break;
-		}
-	}
-
-	if (ret)
-		return ret;
-
-	mutex_lock(&isp->mutex);
-
-	switch (control->id) {
-	case V4L2_CID_IRIS_ABSOLUTE:
-	case V4L2_CID_EXPOSURE_ABSOLUTE:
-	case V4L2_CID_FNUMBER_ABSOLUTE:
-	case V4L2_CID_HFLIP:
-	case V4L2_CID_VFLIP:
-	case V4L2_CID_2A_STATUS:
-	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
-	case V4L2_CID_EXPOSURE:
-	case V4L2_CID_SCENE_MODE:
-	case V4L2_CID_ISO_SENSITIVITY:
-	case V4L2_CID_EXPOSURE_METERING:
-	case V4L2_CID_CONTRAST:
-	case V4L2_CID_SATURATION:
-	case V4L2_CID_SHARPNESS:
-	case V4L2_CID_3A_LOCK:
-		mutex_unlock(&isp->mutex);
-		return v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				       core, g_ctrl, control);
-	case V4L2_CID_COLORFX:
-		ret = atomisp_color_effect(asd, 0, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:
-		ret = atomisp_bad_pixel(asd, 0, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:
-		ret = atomisp_gdc_cac(asd, 0, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_VIDEO_STABLIZATION:
-		ret = atomisp_video_stable(asd, 0, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_FIXED_PATTERN_NR:
-		ret = atomisp_fixed_pattern(asd, 0, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:
-		ret = atomisp_false_color(asd, 0, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_LOW_LIGHT:
-		ret = atomisp_low_light(asd, 0, &control->value);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-
-/*
- * To change the value of a control.
- * applications initialize the id and value fields of a struct v4l2_control
- * and call this ioctl.
- */
-static int atomisp_s_ctrl(struct file *file, void *fh,
-			  struct v4l2_control *control)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	int i, ret = -EINVAL;
-
-	for (i = 0; i < ctrls_num; i++) {
-		if (ci_v4l2_controls[i].id == control->id) {
-			ret = 0;
-			break;
-		}
-	}
-
-	if (ret)
-		return ret;
-
-	mutex_lock(&isp->mutex);
-	switch (control->id) {
-	case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
-	case V4L2_CID_EXPOSURE:
-	case V4L2_CID_SCENE_MODE:
-	case V4L2_CID_ISO_SENSITIVITY:
-	case V4L2_CID_HFLIP:
-	case V4L2_CID_VFLIP:
-	case V4L2_CID_POWER_LINE_FREQUENCY:
-	case V4L2_CID_EXPOSURE_METERING:
-	case V4L2_CID_CONTRAST:
-	case V4L2_CID_SATURATION:
-	case V4L2_CID_SHARPNESS:
-	case V4L2_CID_3A_LOCK:
-		mutex_unlock(&isp->mutex);
-		return v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-				       core, s_ctrl, control);
-	case V4L2_CID_COLORFX:
-		ret = atomisp_color_effect(asd, 1, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_BAD_PIXEL_DETECTION:
-		ret = atomisp_bad_pixel(asd, 1, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_POSTPROCESS_GDC_CAC:
-		ret = atomisp_gdc_cac(asd, 1, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_VIDEO_STABLIZATION:
-		ret = atomisp_video_stable(asd, 1, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_FIXED_PATTERN_NR:
-		ret = atomisp_fixed_pattern(asd, 1, &control->value);
-		break;
-	case V4L2_CID_ATOMISP_FALSE_COLOR_CORRECTION:
-		ret = atomisp_false_color(asd, 1, &control->value);
-		break;
-	case V4L2_CID_REQUEST_FLASH:
-		ret = atomisp_flash_enable(asd, control->value);
-		break;
-	case V4L2_CID_ATOMISP_LOW_LIGHT:
-		ret = atomisp_low_light(asd, 1, &control->value);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	mutex_unlock(&isp->mutex);
-	return ret;
-}
-/*
- * To query the attributes of a control.
- * applications set the id field of a struct v4l2_queryctrl and call the
- * this ioctl with a pointer to this structure. The driver fills
- * the rest of the structure.
- */
-static int atomisp_queryctl(struct file *file, void *fh,
-			    struct v4l2_queryctrl *qc)
-{
-	int i, ret = -EINVAL;
-
-	if (qc->id & V4L2_CTRL_FLAG_NEXT_CTRL)
-		return ret;
-
-	for (i = 0; i < ctrls_num; i++) {
-		if (ci_v4l2_controls[i].id == qc->id) {
-			memcpy(qc, &ci_v4l2_controls[i],
-			       sizeof(struct v4l2_queryctrl));
-			qc->reserved[0] = 0;
-			ret = 0;
-			break;
-		}
-	}
-	if (ret != 0)
-		qc->flags = V4L2_CTRL_FLAG_DISABLED;
-
-	return ret;
-}
-
-static int atomisp_camera_g_ext_ctrls(struct file *file, void *fh,
-	struct v4l2_ext_controls *c)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct v4l2_control ctrl;
-	int i;
-	int ret = 0;
-
-	for (i = 0; i < c->count; i++) {
-		ctrl.id = c->controls[i].id;
-		ctrl.value = c->controls[i].value;
-		switch (ctrl.id) {
-		case V4L2_CID_EXPOSURE_ABSOLUTE:
-		case V4L2_CID_IRIS_ABSOLUTE:
-		case V4L2_CID_FNUMBER_ABSOLUTE:
-		case V4L2_CID_BIN_FACTOR_HORZ:
-		case V4L2_CID_BIN_FACTOR_VERT:
-		case V4L2_CID_3A_LOCK:
-			/*
-			 * Exposure related control will be handled by sensor
-			 * driver
-			 */
-			ret = v4l2_subdev_call(isp->inputs
-					       [asd->input_curr].camera,
-					       core, g_ctrl, &ctrl);
-			break;
-		case V4L2_CID_FOCUS_ABSOLUTE:
-		case V4L2_CID_FOCUS_RELATIVE:
-		case V4L2_CID_FOCUS_STATUS:
-		case V4L2_CID_FOCUS_AUTO:
-			if (isp->inputs[asd->input_curr].motor)
-				ret = v4l2_subdev_call(
-					isp->inputs[asd->input_curr].motor,
-					core, g_ctrl, &ctrl);
-			else
-				ret = v4l2_subdev_call(
-					isp->inputs[asd->input_curr].camera,
-					core, g_ctrl, &ctrl);
-			break;
-		case V4L2_CID_FLASH_STATUS:
-		case V4L2_CID_FLASH_INTENSITY:
-		case V4L2_CID_FLASH_TORCH_INTENSITY:
-		case V4L2_CID_FLASH_INDICATOR_INTENSITY:
-		case V4L2_CID_FLASH_TIMEOUT:
-		case V4L2_CID_FLASH_STROBE:
-		case V4L2_CID_FLASH_MODE:
-			if (isp->flash)
-				ret = v4l2_subdev_call(
-					isp->flash, core, g_ctrl, &ctrl);
-			break;
-		case V4L2_CID_ZOOM_ABSOLUTE:
-			mutex_lock(&isp->mutex);
-			ret = atomisp_digital_zoom(asd, 0, &ctrl.value);
-			mutex_unlock(&isp->mutex);
-			break;
-		case V4L2_CID_G_SKIP_FRAMES:
-			ret = v4l2_subdev_call(
-				isp->inputs[asd->input_curr].camera,
-				sensor, g_skip_frames, (u32 *)&ctrl.value);
-			break;
-		default:
-			ret = -EINVAL;
-		}
-
-		if (ret) {
-			c->error_idx = i;
-			break;
-		}
-		c->controls[i].value = ctrl.value;
-	}
-	return ret;
-}
-
-/* This ioctl allows the application to get multiple controls by class */
-static int atomisp_g_ext_ctrls(struct file *file, void *fh,
-	struct v4l2_ext_controls *c)
-{
-	struct v4l2_control ctrl;
-	int i, ret = 0;
-
-	/* input_lock is not need for the Camera releated IOCTLs
-	 * The input_lock downgrade the FPS of 3A*/
-	ret = atomisp_camera_g_ext_ctrls(file, fh, c);
-	if (ret != -EINVAL)
-		return ret;
-
-	for (i = 0; i < c->count; i++) {
-		ctrl.id = c->controls[i].id;
-		ctrl.value = c->controls[i].value;
-		ret = atomisp_g_ctrl(file, fh, &ctrl);
-		c->controls[i].value = ctrl.value;
-		if (ret) {
-			c->error_idx = i;
-			break;
-		}
-	}
-	return ret;
-}
-
-static int atomisp_camera_s_ext_ctrls(struct file *file, void *fh,
-	struct v4l2_ext_controls *c)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct v4l2_control ctrl;
-	int i;
-	int ret = 0;
-
-	for (i = 0; i < c->count; i++) {
-		struct v4l2_ctrl *ctr;
-
-		ctrl.id = c->controls[i].id;
-		ctrl.value = c->controls[i].value;
-		switch (ctrl.id) {
-		case V4L2_CID_EXPOSURE_ABSOLUTE:
-		case V4L2_CID_IRIS_ABSOLUTE:
-		case V4L2_CID_FNUMBER_ABSOLUTE:
-		case V4L2_CID_VCM_TIMEING:
-		case V4L2_CID_VCM_SLEW:
-		case V4L2_CID_TEST_PATTERN:
-		case V4L2_CID_3A_LOCK:
-			ret = v4l2_subdev_call(
-				isp->inputs[asd->input_curr].camera,
-				core, s_ctrl, &ctrl);
-			break;
-		case V4L2_CID_FOCUS_ABSOLUTE:
-		case V4L2_CID_FOCUS_RELATIVE:
-		case V4L2_CID_FOCUS_STATUS:
-		case V4L2_CID_FOCUS_AUTO:
-			if (isp->inputs[asd->input_curr].motor)
-				ret = v4l2_subdev_call(
-					isp->inputs[asd->input_curr].motor,
-					core, s_ctrl, &ctrl);
-			else
-				ret = v4l2_subdev_call(
-					isp->inputs[asd->input_curr].camera,
-					core, s_ctrl, &ctrl);
-			break;
-		case V4L2_CID_FLASH_STATUS:
-		case V4L2_CID_FLASH_INTENSITY:
-		case V4L2_CID_FLASH_TORCH_INTENSITY:
-		case V4L2_CID_FLASH_INDICATOR_INTENSITY:
-		case V4L2_CID_FLASH_TIMEOUT:
-		case V4L2_CID_FLASH_STROBE:
-		case V4L2_CID_FLASH_MODE:
-			mutex_lock(&isp->mutex);
-			if (isp->flash) {
-				ret = v4l2_subdev_call(isp->flash,
-					core, s_ctrl, &ctrl);
-				/* When flash mode is changed we need to reset
-				 * flash state */
-				if (ctrl.id == V4L2_CID_FLASH_MODE) {
-					asd->params.flash_state =
-						ATOMISP_FLASH_IDLE;
-					asd->params.num_flash_frames = 0;
-				}
-			}
-			mutex_unlock(&isp->mutex);
-			break;
-		case V4L2_CID_ZOOM_ABSOLUTE:
-			mutex_lock(&isp->mutex);
-			ret = atomisp_digital_zoom(asd, 1, &ctrl.value);
-			mutex_unlock(&isp->mutex);
-			break;
-		default:
-			ctr = v4l2_ctrl_find(&asd->ctrl_handler, ctrl.id);
-			if (ctr)
-				ret = v4l2_ctrl_s_ctrl(ctr, ctrl.value);
-			else
-				ret = -EINVAL;
-		}
-
-		if (ret) {
-			c->error_idx = i;
-			break;
-		}
-		c->controls[i].value = ctrl.value;
-	}
-	return ret;
-}
-
-/* This ioctl allows the application to set multiple controls by class */
-static int atomisp_s_ext_ctrls(struct file *file, void *fh,
-	struct v4l2_ext_controls *c)
-{
-	struct v4l2_control ctrl;
-	int i, ret = 0;
-
-	/* input_lock is not need for the Camera releated IOCTLs
-	 * The input_lock downgrade the FPS of 3A*/
-	ret = atomisp_camera_s_ext_ctrls(file, fh, c);
-	if (ret != -EINVAL)
-		return ret;
-
-	for (i = 0; i < c->count; i++) {
-		ctrl.id = c->controls[i].id;
-		ctrl.value = c->controls[i].value;
-		ret = atomisp_s_ctrl(file, fh, &ctrl);
-		c->controls[i].value = ctrl.value;
-		if (ret) {
-			c->error_idx = i;
-			break;
-		}
-	}
-	return ret;
-}
-
-/*
- * vidioc_g/s_param are used to switch isp running mode
- */
-static int atomisp_g_parm(struct file *file, void *fh,
-	struct v4l2_streamparm *parm)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-
-	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_err(isp->dev, "unsupport v4l2 buf type\n");
-		return -EINVAL;
-	}
-
-	mutex_lock(&isp->mutex);
-	parm->parm.capture.capturemode = asd->run_mode->val;
-	mutex_unlock(&isp->mutex);
-
-	return 0;
-}
-
-static int atomisp_s_parm(struct file *file, void *fh,
-	struct v4l2_streamparm *parm)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	int mode;
-	int rval;
-
-	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-		dev_err(isp->dev, "unsupport v4l2 buf type\n");
-		return -EINVAL;
-	}
-
-	mutex_lock(&isp->mutex);
-
-	switch (parm->parm.capture.capturemode) {
-	case CI_MODE_NONE: {
-		struct v4l2_subdev_frame_interval fi = {0};
-
-		fi.interval = parm->parm.capture.timeperframe;
-
-		rval = v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-					video, s_frame_interval, &fi);
-		if (!rval)
-			parm->parm.capture.timeperframe = fi.interval;
-		goto out;
-	}
-	case CI_MODE_VIDEO:
-		mode = ATOMISP_RUN_MODE_VIDEO;
-		break;
-	case CI_MODE_STILL_CAPTURE:
-		mode = ATOMISP_RUN_MODE_STILL_CAPTURE;
-		break;
-	case CI_MODE_CONTINUOUS:
-		mode = ATOMISP_RUN_MODE_CONTINUOUS_CAPTURE;
-		break;
-	case CI_MODE_PREVIEW:
-		mode = ATOMISP_RUN_MODE_PREVIEW;
-		break;
-	default:
-		rval = -EINVAL;
-		goto out;
-	}
-
-	rval = v4l2_ctrl_s_ctrl(asd->run_mode, mode);
-
-out:
-	mutex_unlock(&isp->mutex);
-
-	return rval == -ENOIOCTLCMD ? 0 : rval;
-}
-
-static int atomisp_s_parm_file(struct file *file, void *fh,
-				struct v4l2_streamparm *parm)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-
-	if (parm->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
-		dev_err(isp->dev, "unsupport v4l2 buf type for output\n");
-		return -EINVAL;
-	}
-
-	mutex_lock(&isp->mutex);
-	isp->sw_contex.file_input = 1;
-	mutex_unlock(&isp->mutex);
-
-	return 0;
-}
-
-static long atomisp_vidioc_default(struct file *file, void *fh,
-	bool valid_prio, unsigned int cmd, void *arg)
-{
-	struct video_device *vdev = video_devdata(file);
-	struct atomisp_device *isp = video_get_drvdata(vdev);
-	struct atomisp_sub_device *asd = atomisp_to_video_pipe(vdev)->asd;
-	int err;
-
-	mutex_lock(&isp->mutex);
-	switch (cmd) {
-	case ATOMISP_IOC_G_XNR:
-		err = atomisp_xnr(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_XNR:
-		err = atomisp_xnr(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_NR:
-		err = atomisp_nr(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_NR:
-		err = atomisp_nr(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_TNR:
-		err = atomisp_tnr(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_TNR:
-		err = atomisp_tnr(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_BLACK_LEVEL_COMP:
-		err = atomisp_black_level(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_BLACK_LEVEL_COMP:
-		err = atomisp_black_level(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_EE:
-		err = atomisp_ee(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_EE:
-		err = atomisp_ee(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_DIS_STAT:
-		err = atomisp_get_dis_stat(asd, arg);
-		break;
-
-	case ATOMISP_IOC_S_DIS_COEFS:
-		err = atomisp_set_dis_coefs(asd, arg);
-		break;
-
-	case ATOMISP_IOC_S_DIS_VECTOR:
-#ifdef CSS20
-		err = atomisp_set_dvs_6axis_config(asd, arg);
-#else
-		err = atomisp_set_dis_vector(asd, arg);
-#endif
-		break;
-
-	case ATOMISP_IOC_G_ISP_PARM:
-		err = atomisp_param(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_PARM:
-		err = atomisp_param(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_3A_STAT:
-		err = atomisp_3a_stat(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_GAMMA:
-		err = atomisp_gamma(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_GAMMA:
-		err = atomisp_gamma(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_GDC_TAB:
-		err = atomisp_gdc_cac_table(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_GDC_TAB:
-		err = atomisp_gdc_cac_table(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_MACC:
-		err = atomisp_macc_table(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_MACC:
-		err = atomisp_macc_table(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_BAD_PIXEL_DETECTION:
-		err = atomisp_bad_pixel_param(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_BAD_PIXEL_DETECTION:
-		err = atomisp_bad_pixel_param(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_FALSE_COLOR_CORRECTION:
-		err = atomisp_false_color_param(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_FALSE_COLOR_CORRECTION:
-		err = atomisp_false_color_param(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_CTC:
-		err = atomisp_ctc(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_CTC:
-		err = atomisp_ctc(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_WHITE_BALANCE:
-		err = atomisp_white_balance_param(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_WHITE_BALANCE:
-		err = atomisp_white_balance_param(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_G_3A_CONFIG:
-		err = atomisp_3a_config_param(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_3A_CONFIG:
-		err = atomisp_3a_config_param(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_FPN_TABLE:
-		err = atomisp_fixed_pattern_table(asd, arg);
-		break;
-
-	case ATOMISP_IOC_ISP_MAKERNOTE:
-		err = atomisp_exif_makernote(asd, arg);
-		break;
-
-	case ATOMISP_IOC_G_SENSOR_MODE_DATA:
-		err = atomisp_get_sensor_mode_data(asd, arg);
-		break;
-
-	case ATOMISP_IOC_G_MOTOR_PRIV_INT_DATA:
-		mutex_unlock(&isp->mutex);
-		if (isp->inputs[asd->input_curr].motor)
-			return v4l2_subdev_call(
-					isp->inputs[asd->input_curr].motor,
-					core, ioctl, cmd, arg);
-		else
-			return v4l2_subdev_call(
-					isp->inputs[asd->input_curr].camera,
-					core, ioctl, cmd, arg);
-
-	case ATOMISP_IOC_S_EXPOSURE:
-	case ATOMISP_IOC_G_SENSOR_CALIBRATION_GROUP:
-	case ATOMISP_IOC_G_SENSOR_PRIV_INT_DATA:
-		mutex_unlock(&isp->mutex);
-		return v4l2_subdev_call(isp->inputs[asd->input_curr].camera,
-					core, ioctl, cmd, arg);
-
-	case ATOMISP_IOC_ACC_LOAD:
-		err = atomisp_acc_load(isp, arg);
-		break;
-
-	case ATOMISP_IOC_ACC_LOAD_TO_PIPE:
-		err = atomisp_acc_load_to_pipe(isp, arg);
-		break;
-
-	case ATOMISP_IOC_ACC_UNLOAD:
-		err = atomisp_acc_unload(isp, arg);
-		break;
-
-	case ATOMISP_IOC_ACC_START:
-		err = atomisp_acc_start(asd, arg);
-		break;
-
-	case ATOMISP_IOC_ACC_WAIT:
-		err = atomisp_acc_wait(asd, arg);
-		break;
-
-	case ATOMISP_IOC_ACC_MAP:
-		err = atomisp_acc_map(isp, arg);
-		break;
-
-	case ATOMISP_IOC_ACC_UNMAP:
-		err = atomisp_acc_unmap(isp, arg);
-		break;
-
-	case ATOMISP_IOC_ACC_S_MAPPED_ARG:
-		err = atomisp_acc_s_mapped_arg(isp, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_SHD_TAB:
-		err = atomisp_set_shading_table(asd, arg);
-		break;
-
-	case ATOMISP_IOC_G_ISP_GAMMA_CORRECTION:
-		err = atomisp_gamma_correction(asd, 0, arg);
-		break;
-
-	case ATOMISP_IOC_S_ISP_GAMMA_CORRECTION:
-		err = atomisp_gamma_correction(asd, 1, arg);
-		break;
-
-	case ATOMISP_IOC_S_PARAMETERS:
-		err = atomisp_set_parameters(asd, arg);
-		break;
-
-	case ATOMISP_IOC_S_CONT_CAPTURE_CONFIG:
-		err = atomisp_offline_capture_configure(asd, arg);
-		break;
-	default:
-		mutex_unlock(&isp->mutex);
-		return -EINVAL;
-	}
-	mutex_unlock(&isp->mutex);
-	return err;
-}
-
-const struct v4l2_ioctl_ops atomisp_ioctl_ops = {
-	.vidioc_querycap = atomisp_querycap,
-	.vidioc_g_chip_ident = atomisp_g_chip_ident,
-	.vidioc_enum_input = atomisp_enum_input,
-	.vidioc_g_input = atomisp_g_input,
-	.vidioc_s_input = atomisp_s_input,
-	.vidioc_queryctrl = atomisp_queryctl,
-	.vidioc_s_ctrl = atomisp_s_ctrl,
-	.vidioc_g_ctrl = atomisp_g_ctrl,
-	.vidioc_s_ext_ctrls = atomisp_s_ext_ctrls,
-	.vidioc_g_ext_ctrls = atomisp_g_ext_ctrls,
-	.vidioc_enum_fmt_vid_cap = atomisp_enum_fmt_cap,
-	.vidioc_try_fmt_vid_cap = atomisp_try_fmt_cap,
-	.vidioc_g_fmt_vid_cap = atomisp_g_fmt_cap,
-	.vidioc_s_fmt_vid_cap = atomisp_s_fmt_cap,
-	.vidioc_reqbufs = atomisp_reqbufs,
-	.vidioc_querybuf = atomisp_querybuf,
-	.vidioc_qbuf = atomisp_qbuf,
-	.vidioc_dqbuf = atomisp_dqbuf,
-	.vidioc_streamon = atomisp_streamon,
-	.vidioc_streamoff = atomisp_streamoff,
-	.vidioc_default = atomisp_vidioc_default,
-	.vidioc_enum_frameintervals = atomisp_enum_frameintervals,
-	.vidioc_s_parm = atomisp_s_parm,
-	.vidioc_g_parm = atomisp_g_parm,
-};
-
-const struct v4l2_ioctl_ops atomisp_file_ioctl_ops = {
-	.vidioc_querycap = atomisp_querycap,
-	.vidioc_g_fmt_vid_out = atomisp_g_fmt_file,
-	.vidioc_s_fmt_vid_out = atomisp_s_fmt_file,
-	.vidioc_s_parm = atomisp_s_parm_file,
-	.vidioc_reqbufs = atomisp_reqbufs_file,
-	.vidioc_querybuf = atomisp_querybuf_file,
-	.vidioc_qbuf = atomisp_qbuf_file,
-};
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.h
deleted file mode 100644
index c7f2898..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_ioctl.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__ATOMISP_IOCTL_H__
-#define	__ATOMISP_IOCTL_H__
-
-#ifdef CSS20
-#include "ia_css.h"
-#else /* CSS20 */
-#include <sh_css.h>
-#endif /* CSS20 */
-
-struct atomisp_device;
-struct atomisp_video_pipe;
-
-extern const struct atomisp_format_bridge atomisp_output_fmts[];
-
-const struct atomisp_format_bridge *atomisp_get_format_bridge(
-	unsigned int pixelformat);
-const struct atomisp_format_bridge *atomisp_get_format_bridge_from_mbus(
-	enum v4l2_mbus_pixelcode mbus_code);
-
-int atomisp_alloc_css_stat_bufs(struct atomisp_sub_device *asd);
-
-int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type);
-int __atomisp_reqbufs(struct file *file, void *fh,
-		struct v4l2_requestbuffers *req);
-
-int atomisp_reqbufs(struct file *file, void *fh,
-			struct v4l2_requestbuffers *req);
-
-enum atomisp_css_pipe_id atomisp_get_css_pipe_id(struct atomisp_sub_device
-						 *asd);
-
-void atomisp_videobuf_free_buf(struct videobuf_buffer *vb);
-
-extern const struct v4l2_file_operations atomisp_file_fops;
-
-extern const struct v4l2_ioctl_ops atomisp_ioctl_ops;
-
-extern const struct v4l2_ioctl_ops atomisp_file_ioctl_ops;
-
-unsigned int atomisp_streaming_count(struct atomisp_device *isp);
-
-/* compat_ioctl for 32bit userland app and 64bit kernel */
-long atomisp_compat_ioctl32(struct file *file,
-			    unsigned int cmd, unsigned long arg);
-#endif /* __ATOMISP_IOCTL_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.c
deleted file mode 100644
index 8f76064..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.c
+++ /dev/null
@@ -1,1138 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#include <linux/module.h>
-#include <linux/uaccess.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <asm/intel-mid.h>
-
-#include <media/v4l2-event.h>
-#include <media/v4l2-mediabus.h>
-#include "atomisp_cmd.h"
-#include "atomisp_common.h"
-#include "atomisp_compat.h"
-#include "atomisp_internal.h"
-
-const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[] = {
-	{ V4L2_MBUS_FMT_SBGGR8_1X8, 8, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_BGGR },
-	{ V4L2_MBUS_FMT_SGBRG8_1X8, 8, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_GBRG },
-	{ V4L2_MBUS_FMT_SGRBG8_1X8, 8, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_GRBG },
-	{ V4L2_MBUS_FMT_SRGGB8_1X8, 8, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_RGGB },
-	{ V4L2_MBUS_FMT_SBGGR10_1X10, 10, 10, CSS_FORMAT_RAW_10, CSS_BAYER_ORDER_BGGR },
-	{ V4L2_MBUS_FMT_SGBRG10_1X10, 10, 10, CSS_FORMAT_RAW_10, CSS_BAYER_ORDER_GBRG },
-	{ V4L2_MBUS_FMT_SGRBG10_1X10, 10, 10, CSS_FORMAT_RAW_10, CSS_BAYER_ORDER_GRBG },
-	{ V4L2_MBUS_FMT_SRGGB10_1X10, 10, 10, CSS_FORMAT_RAW_10, CSS_BAYER_ORDER_RGGB },
-#ifndef CSS20
-	{ V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8, 10, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_BGGR },
-	{ V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8, 10, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_GBRG },
-	{ V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8, 10, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_GRBG },
-	{ V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8, 10, 8, CSS_FORMAT_RAW_8, CSS_BAYER_ORDER_RGGB },
-#endif /* CSS20 */
-	{ V4L2_MBUS_FMT_SBGGR12_1X12, 12, 12, CSS_FORMAT_RAW_12, CSS_BAYER_ORDER_BGGR },
-	{ V4L2_MBUS_FMT_SGBRG12_1X12, 12, 12, CSS_FORMAT_RAW_12, CSS_BAYER_ORDER_GBRG },
-	{ V4L2_MBUS_FMT_SGRBG12_1X12, 12, 12, CSS_FORMAT_RAW_12, CSS_BAYER_ORDER_GRBG },
-	{ V4L2_MBUS_FMT_SRGGB12_1X12, 12, 12, CSS_FORMAT_RAW_12, CSS_BAYER_ORDER_RGGB },
-	{ V4L2_MBUS_FMT_UYVY8_1X16, 8, 8, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },
-	{ V4L2_MBUS_FMT_YUYV8_1X16, 8, 8, ATOMISP_INPUT_FORMAT_YUV422_8, 0 },
-	{}
-};
-
-static const struct {
-	enum v4l2_mbus_pixelcode code;
-	enum v4l2_mbus_pixelcode compressed;
-} compressed_codes[] = {
-	{ V4L2_MBUS_FMT_SBGGR10_1X10, V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8 },
-	{ V4L2_MBUS_FMT_SGBRG10_1X10, V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8 },
-	{ V4L2_MBUS_FMT_SGRBG10_1X10, V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8 },
-	{ V4L2_MBUS_FMT_SRGGB10_1X10, V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8 },
-};
-
-enum v4l2_mbus_pixelcode atomisp_subdev_uncompressed_code(
-	enum v4l2_mbus_pixelcode code)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(compressed_codes); i++)
-		if (code == compressed_codes[i].compressed)
-			return compressed_codes[i].code;
-
-	return code;
-}
-
-bool atomisp_subdev_is_compressed(enum v4l2_mbus_pixelcode code)
-{
-	const struct atomisp_in_fmt_conv *ic = atomisp_in_fmt_conv;
-
-	while (ic->code) {
-		if (code == ic->code)
-			return ic->bpp != ic->depth;
-		ic++;
-	}
-
-	return false;
-}
-
-const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(
-	enum v4l2_mbus_pixelcode code)
-{
-	const struct atomisp_in_fmt_conv *ic = atomisp_in_fmt_conv;
-
-	while (ic->code) {
-		if (code == ic->code)
-			return ic;
-		ic++;
-	}
-
-	return NULL;
-}
-
-bool atomisp_subdev_format_conversion(struct atomisp_sub_device *asd,
-				      unsigned int source_pad)
-{
-	struct v4l2_mbus_framefmt *sink, *src;
-
-	sink = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				       V4L2_SUBDEV_FORMAT_ACTIVE,
-				       ATOMISP_SUBDEV_PAD_SINK);
-	src = atomisp_subdev_get_ffmt(&asd->subdev, NULL,
-				      V4L2_SUBDEV_FORMAT_ACTIVE, source_pad);
-
-	return atomisp_is_mbuscode_raw(sink->code)
-		&& !atomisp_is_mbuscode_raw(src->code);
-}
-
-uint16_t atomisp_subdev_source_pad(struct video_device *vdev)
-{
-	return vdev->entity.links[0].source->index;
-}
-
-/*
- * V4L2 subdev operations
- */
-
-/*
- * isp_subdev_ioctl - CCDC module private ioctl's
- * @sd: ISP V4L2 subdevice
- * @cmd: ioctl command
- * @arg: ioctl argument
- *
- * Return 0 on success or a negative error code otherwise.
- */
-static long isp_subdev_ioctl(struct v4l2_subdev *sd,
-	unsigned int cmd, void *arg)
-{
-	int ret = 0;
-
-	return ret;
-}
-
-/*
- * isp_subdev_set_power - Power on/off the CCDC module
- * @sd: ISP V4L2 subdevice
- * @on: power on/off
- *
- * Return 0 on success or a negative error code otherwise.
- */
-static int isp_subdev_set_power(struct v4l2_subdev *sd, int on)
-{
-	return 0;
-}
-
-static int isp_subdev_subscribe_event(struct v4l2_subdev *sd,
-	struct v4l2_fh *fh, struct v4l2_event_subscription *sub)
-{
-	if (sub->type != V4L2_EVENT_FRAME_SYNC &&
-	    sub->type != V4L2_EVENT_ATOMISP_3A_STATS_READY)
-		return -EINVAL;
-
-	return v4l2_event_subscribe(fh, sub, 16, NULL);
-}
-
-static int isp_subdev_unsubscribe_event(struct v4l2_subdev *sd,
-	struct v4l2_fh *fh, struct v4l2_event_subscription *sub)
-{
-	return v4l2_event_unsubscribe(fh, sub);
-}
-
-/*
- * isp_subdev_enum_mbus_code - Handle pixel format enumeration
- * @sd: pointer to v4l2 subdev structure
- * @fh : V4L2 subdev file handle
- * @code: pointer to v4l2_subdev_pad_mbus_code_enum structure
- * return -EINVAL or zero on success
- */
-static int isp_subdev_enum_mbus_code(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh, struct v4l2_subdev_mbus_code_enum *code)
-{
-	if (code->index >= ARRAY_SIZE(atomisp_in_fmt_conv) - 1)
-		return -EINVAL;
-
-	code->code = atomisp_in_fmt_conv[code->index].code;
-
-	return 0;
-}
-
-static int isp_subdev_validate_rect(struct v4l2_subdev *sd, uint32_t pad,
-				    uint32_t target)
-{
-	switch (pad) {
-	case ATOMISP_SUBDEV_PAD_SINK:
-		switch (target) {
-		case V4L2_SEL_TGT_CROP:
-			return 0;
-		}
-		break;
-	default:
-		switch (target) {
-		case V4L2_SEL_TGT_COMPOSE:
-			return 0;
-		}
-		break;
-	}
-
-	return -EINVAL;
-}
-
-struct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,
-					  struct v4l2_subdev_fh *fh,
-					  uint32_t which, uint32_t pad,
-					  uint32_t target)
-{
-	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
-
-	if (which == V4L2_SUBDEV_FORMAT_TRY) {
-		switch (target) {
-		case V4L2_SEL_TGT_CROP:
-			return v4l2_subdev_get_try_crop(fh, pad);
-		case V4L2_SEL_TGT_COMPOSE:
-			return v4l2_subdev_get_try_compose(fh, pad);
-		}
-	}
-
-	switch (target) {
-	case V4L2_SEL_TGT_CROP:
-		return &isp_sd->fmt[pad].crop;
-	case V4L2_SEL_TGT_COMPOSE:
-		return &isp_sd->fmt[pad].compose;
-	}
-
-	return NULL;
-}
-
-struct v4l2_mbus_framefmt
-*atomisp_subdev_get_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			 uint32_t which, uint32_t pad)
-{
-	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
-
-	if (which == V4L2_SUBDEV_FORMAT_TRY)
-		return v4l2_subdev_get_try_format(fh, pad);
-
-	return &isp_sd->fmt[pad].fmt;
-}
-
-static void isp_get_fmt_rect(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			     uint32_t which, struct v4l2_mbus_framefmt **ffmt,
-			     struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
-			     struct v4l2_rect *comp[ATOMISP_SUBDEV_PADS_NUM])
-{
-	unsigned int i;
-
-	for (i = 0; i < ATOMISP_SUBDEV_PADS_NUM; i++) {
-		ffmt[i] = atomisp_subdev_get_ffmt(sd, fh, which, i);
-		crop[i] = atomisp_subdev_get_rect(sd, fh, which, i,
-						  V4L2_SEL_TGT_CROP);
-		comp[i] = atomisp_subdev_get_rect(sd, fh, which, i,
-						  V4L2_SEL_TGT_COMPOSE);
-	}
-}
-
-static void isp_subdev_propagate(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_fh *fh,
-				 uint32_t which, uint32_t pad, uint32_t target,
-				 uint32_t flags)
-{
-	struct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];
-	struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
-		*comp[ATOMISP_SUBDEV_PADS_NUM];
-
-	if (flags & V4L2_SEL_FLAG_KEEP_CONFIG)
-		return;
-
-	isp_get_fmt_rect(sd, fh, which, ffmt, crop, comp);
-
-	switch (pad) {
-	case ATOMISP_SUBDEV_PAD_SINK: {
-		struct v4l2_rect r = {0};
-
-		/* Only crop target supported on sink pad. */
-		r.width = ffmt[pad]->width;
-		r.height = ffmt[pad]->height;
-
-		atomisp_subdev_set_selection(sd, fh, which, pad, target, flags,
-					     &r);
-		break;
-	}
-	}
-}
-
-static int isp_subdev_get_selection(struct v4l2_subdev *sd,
-				    struct v4l2_subdev_fh *fh,
-				    struct v4l2_subdev_selection *sel)
-{
-	int rval = isp_subdev_validate_rect(sd, sel->pad, sel->target);
-	if (rval)
-		return rval;
-
-	sel->r = *atomisp_subdev_get_rect(sd, fh, sel->which, sel->pad,
-					  sel->target);
-
-	return 0;
-}
-
-static char *atomisp_pad_str[] = { "ATOMISP_SUBDEV_PAD_SINK",
-				   "ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE",
-				   "ATOMISP_SUBDEV_PAD_SOURCE_VF",
-				   "ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW",
-				   "ATOMISP_SUBDEV_PAD_SOURCE_VIDEO"};
-
-int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_fh *fh, uint32_t which,
-				 uint32_t pad, uint32_t target, uint32_t flags,
-				 struct v4l2_rect *r)
-{
-	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
-	struct atomisp_device *isp = isp_sd->isp;
-	struct v4l2_mbus_framefmt *ffmt[ATOMISP_SUBDEV_PADS_NUM];
-	uint16_t vdev_pad = atomisp_subdev_source_pad(fh->vfh.vdev);
-	struct v4l2_rect *crop[ATOMISP_SUBDEV_PADS_NUM],
-		*comp[ATOMISP_SUBDEV_PADS_NUM];
-	enum atomisp_input_stream_id stream_id;
-	unsigned int i;
-	unsigned int padding_w = pad_w;
-	unsigned int padding_h = pad_h;
-
-	stream_id = atomisp_source_pad_to_stream_id(isp_sd, vdev_pad);
-
-	isp_get_fmt_rect(sd, fh, which, ffmt, crop, comp);
-
-	dev_dbg(isp->dev,
-		"sel: pad %s tgt %s l %d t %d w %d h %d which %s f 0x%8.8x\n",
-		atomisp_pad_str[pad], target == V4L2_SEL_TGT_CROP
-		? "V4L2_SEL_TGT_CROP" : "V4L2_SEL_TGT_COMPOSE",
-		r->left, r->top, r->width, r->height,
-		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
-		: "V4L2_SUBDEV_FORMAT_ACTIVE", flags);
-
-	r->width = rounddown(r->width, ATOM_ISP_STEP_WIDTH);
-	r->height = rounddown(r->height, ATOM_ISP_STEP_HEIGHT);
-
-	switch (pad) {
-	case ATOMISP_SUBDEV_PAD_SINK: {
-		/* Only crop target supported on sink pad. */
-		unsigned int dvs_w, dvs_h;
-
-		crop[pad]->width = ffmt[pad]->width;
-		crop[pad]->height = ffmt[pad]->height;
-
-		/* Workaround for BYT 1080p perfectshot since the maxinum resolution of
-		 * front camera ov2722 is 1932x1092 and cannot use pad_w > 12*/
-		if (IS_BYT && crop[pad]->height == 1092) {
-			padding_w = 12;
-			padding_h = 12;
-		}
-
-		if (atomisp_subdev_format_conversion(isp_sd,
-						     isp_sd->capture_pad)
-		    && crop[pad]->width && crop[pad]->height)
-			crop[pad]->width -= padding_w, crop[pad]->height -= padding_h;
-
-		/* if subdev type is SOC camera,we do not need to set DVS */
-		if (isp->inputs[isp_sd->input_curr].type == SOC_CAMERA)
-			isp_sd->params.video_dis_en = 0;
-
-		if (isp_sd->params.video_dis_en &&
-		    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO &&
-		    !isp_sd->continuous_mode->val) {
-			/* This resolution contains 20 % of DVS slack
-			 * (of the desired captured image before
-			 * scaling, or 1 / 6 of what we get from the
-			 * sensor) in both width and height. Remove
-			 * it. */
-			crop[pad]->width = roundup(crop[pad]->width * 5 / 6,
-						   ATOM_ISP_STEP_WIDTH);
-			crop[pad]->height = roundup(crop[pad]->height * 5 / 6,
-						    ATOM_ISP_STEP_HEIGHT);
-		}
-
-		crop[pad]->width = min(crop[pad]->width, r->width);
-		crop[pad]->height = min(crop[pad]->height, r->height);
-
-		if (!(flags & V4L2_SEL_FLAG_KEEP_CONFIG)) {
-			for (i = ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE;
-			     i < ATOMISP_SUBDEV_PADS_NUM; i++) {
-				struct v4l2_rect tmp = *crop[pad];
-
-				atomisp_subdev_set_selection(
-					sd, fh, which, i, V4L2_SEL_TGT_COMPOSE,
-					flags, &tmp);
-			}
-		}
-
-		if (which == V4L2_SUBDEV_FORMAT_TRY)
-			break;
-
-		if (isp_sd->params.video_dis_en &&
-		    isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-			dvs_w = rounddown(crop[pad]->width / 5,
-					  ATOM_ISP_STEP_WIDTH);
-			dvs_h = rounddown(crop[pad]->height / 5,
-					  ATOM_ISP_STEP_HEIGHT);
-#ifdef CSS20
-		} else if (!isp_sd->params.video_dis_en &&
-			   isp_sd->run_mode->val == ATOMISP_RUN_MODE_VIDEO) {
-			/*
-			 * For CSS2.0, digital zoom needs to set dvs envelope to 12
-			 * when dvs is disabled.
-			 */
-			dvs_w = dvs_h = 12;
-#endif
-		} else
-			dvs_w = dvs_h = 0;
-
-		atomisp_css_video_set_dis_envelope(isp_sd, dvs_w, dvs_h);
-		atomisp_css_input_set_effective_resolution(isp_sd, stream_id,
-					crop[pad]->width, crop[pad]->height);
-
-		break;
-	}
-	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
-	case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO: {
-		/* Only compose target is supported on source pads. */
-
-		if (isp_sd->vfpp->val == ATOMISP_VFPP_DISABLE_LOWLAT) {
-			/* Scaling is disabled in this mode */
-			r->width = crop[ATOMISP_SUBDEV_PAD_SINK]->width;
-			r->height = crop[ATOMISP_SUBDEV_PAD_SINK]->height;
-		}
-
-		if (crop[ATOMISP_SUBDEV_PAD_SINK]->width == r->width
-		    && crop[ATOMISP_SUBDEV_PAD_SINK]->height == r->height)
-			isp_sd->params.yuv_ds_en = false;
-		else
-			isp_sd->params.yuv_ds_en = true;
-
-		comp[pad]->width = r->width;
-		comp[pad]->height = r->height;
-
-		break;
-	}
-	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
-	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
-		comp[pad]->width = r->width;
-		comp[pad]->height = r->height;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* Set format dimensions on non-sink pads as well. */
-	if (pad != ATOMISP_SUBDEV_PAD_SINK) {
-		ffmt[pad]->width = comp[pad]->width;
-		ffmt[pad]->height = comp[pad]->height;
-	}
-
-	*r = *atomisp_subdev_get_rect(sd, fh, which, pad, target);
-
-	dev_dbg(isp->dev, "sel actual: l %d t %d w %d h %d\n",
-		r->left, r->top, r->width, r->height);
-
-	return 0;
-}
-
-static int isp_subdev_set_selection(struct v4l2_subdev *sd,
-				    struct v4l2_subdev_fh *fh,
-				    struct v4l2_subdev_selection *sel)
-{
-	int rval = isp_subdev_validate_rect(sd, sel->pad, sel->target);
-	if (rval)
-		return rval;
-
-	return atomisp_subdev_set_selection(sd, fh, sel->which, sel->pad,
-					    sel->target, sel->flags, &sel->r);
-}
-
-static int atomisp_get_sensor_bin_factor(struct atomisp_sub_device *asd)
-{
-	struct v4l2_control ctrl = {0};
-	struct atomisp_device *isp = asd->isp;
-	int hbin, vbin;
-	int ret;
-
-	if (isp->inputs[asd->input_curr].type == FILE_INPUT ||
-		isp->inputs[asd->input_curr].type == TEST_PATTERN)
-		return 0;
-
-	ctrl.id = V4L2_CID_BIN_FACTOR_HORZ;
-	ret = v4l2_subdev_call(isp->inputs[asd->input_curr].camera, core,
-			       g_ctrl, &ctrl);
-	hbin = ctrl.value;
-	ctrl.id = V4L2_CID_BIN_FACTOR_VERT;
-	ret |= v4l2_subdev_call(isp->inputs[asd->input_curr].camera, core,
-				g_ctrl, &ctrl);
-	vbin = ctrl.value;
-
-	/*
-	 * ISP needs to know binning factor from sensor.
-	 * In case horizontal and vertical sensor's binning factors
-	 * are different or sensor does not support binning factor CID,
-	 * ISP will apply default 0 value.
-	 */
-	if (ret || hbin != vbin)
-		hbin = 0;
-
-	return hbin;
-}
-
-void atomisp_subdev_set_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			     uint32_t which, uint32_t pad,
-			     struct v4l2_mbus_framefmt *ffmt)
-{
-	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
-	struct atomisp_device *isp = isp_sd->isp;
-	struct v4l2_mbus_framefmt *__ffmt =
-		atomisp_subdev_get_ffmt(sd, fh, which, pad);
-	uint16_t vdev_pad = atomisp_subdev_source_pad(fh->vfh.vdev);
-	enum atomisp_input_stream_id stream_id;
-
-	dev_dbg(isp->dev, "ffmt: pad %s w %d h %d code 0x%8.8x which %s\n",
-		atomisp_pad_str[pad], ffmt->width, ffmt->height, ffmt->code,
-		which == V4L2_SUBDEV_FORMAT_TRY ? "V4L2_SUBDEV_FORMAT_TRY"
-		: "V4L2_SUBDEV_FORMAT_ACTIVE");
-
-	stream_id = atomisp_source_pad_to_stream_id(isp_sd, vdev_pad);
-
-	switch (pad) {
-	case ATOMISP_SUBDEV_PAD_SINK: {
-		const struct atomisp_in_fmt_conv *fc =
-			atomisp_find_in_fmt_conv(ffmt->code);
-
-		if (!fc) {
-			fc = atomisp_in_fmt_conv;
-			ffmt->code = fc->code;
-			dev_dbg(isp->dev, "using 0x%8.8x instead\n",
-				ffmt->code);
-		}
-
-		*__ffmt = *ffmt;
-
-		isp_subdev_propagate(sd, fh, which, pad,
-				     V4L2_SEL_TGT_CROP, 0);
-
-		if (which == V4L2_SUBDEV_FORMAT_ACTIVE) {
-			atomisp_css_input_set_resolution(isp_sd,
-				stream_id, ffmt);
-			atomisp_css_input_set_binning_factor(isp_sd,
-				stream_id,
-				atomisp_get_sensor_bin_factor(isp_sd));
-			atomisp_css_input_set_bayer_order(isp_sd, stream_id,
-							  fc->bayer_order);
-			atomisp_css_input_set_format(isp_sd, stream_id,
-						fc->in_sh_fmt);
-		}
-
-		break;
-	}
-	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE:
-	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW:
-	case ATOMISP_SUBDEV_PAD_SOURCE_VF:
-	case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO:
-		__ffmt->code = ffmt->code;
-		break;
-	}
-}
-
-/*
- * isp_subdev_get_format - Retrieve the video format on a pad
- * @sd : ISP V4L2 subdevice
- * @fh : V4L2 subdev file handle
- * @pad: Pad number
- * @fmt: Format
- *
- * Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
- * to the format type.
- */
-static int isp_subdev_get_format(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
-{
-	fmt->format = *atomisp_subdev_get_ffmt(sd, fh, fmt->which, fmt->pad);
-
-	return 0;
-}
-
-/*
- * isp_subdev_set_format - Set the video format on a pad
- * @sd : ISP subdev V4L2 subdevice
- * @fh : V4L2 subdev file handle
- * @pad: Pad number
- * @fmt: Format
- *
- * Return 0 on success or -EINVAL if the pad is invalid or doesn't correspond
- * to the format type.
- */
-static int isp_subdev_set_format(struct v4l2_subdev *sd,
-	struct v4l2_subdev_fh *fh, struct v4l2_subdev_format *fmt)
-{
-	atomisp_subdev_set_ffmt(sd, fh, fmt->which, fmt->pad, &fmt->format);
-
-	return 0;
-}
-
-/* V4L2 subdev core operations */
-static const struct v4l2_subdev_core_ops isp_subdev_v4l2_core_ops = {
-	 .ioctl = isp_subdev_ioctl, .s_power = isp_subdev_set_power,
-	 .subscribe_event = isp_subdev_subscribe_event,
-	 .unsubscribe_event = isp_subdev_unsubscribe_event,
-};
-
-/* V4L2 subdev pad operations */
-static const struct v4l2_subdev_pad_ops isp_subdev_v4l2_pad_ops = {
-	 .enum_mbus_code = isp_subdev_enum_mbus_code,
-	 .get_fmt = isp_subdev_get_format, .set_fmt = isp_subdev_set_format,
-	 .get_selection = isp_subdev_get_selection,
-	 .set_selection = isp_subdev_set_selection,
-	 .link_validate = v4l2_subdev_link_validate_default,
-};
-
-/* V4L2 subdev operations */
-static const struct v4l2_subdev_ops isp_subdev_v4l2_ops = {
-	 .core = &isp_subdev_v4l2_core_ops, .pad = &isp_subdev_v4l2_pad_ops,
-};
-
-static void isp_subdev_init_params(struct atomisp_sub_device *asd)
-{
-	/* parameters initialization */
-	INIT_LIST_HEAD(&asd->s3a_stats);
-	INIT_LIST_HEAD(&asd->dis_stats);
-}
-
-/*
-* isp_subdev_link_setup - Setup isp subdev connections
-* @entity: ispsubdev media entity
-* @local: Pad at the local end of the link
-* @remote: Pad at the remote end of the link
-* @flags: Link flags
-*
-* return -EINVAL or zero on success
-*/
-static int isp_subdev_link_setup(struct media_entity *entity,
-	const struct media_pad *local,
-	const struct media_pad *remote, u32 flags)
-{
-	struct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);
-	struct atomisp_sub_device *isp_sd = v4l2_get_subdevdata(sd);
-	struct atomisp_device *isp = isp_sd->isp;
-	unsigned int i;
-
-	switch (local->index | media_entity_type(remote->entity)) {
-	case ATOMISP_SUBDEV_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:
-		/* Read from the sensor CSI2-ports. */
-		if (!(flags & MEDIA_LNK_FL_ENABLED)) {
-			isp_sd->input = ATOMISP_SUBDEV_INPUT_NONE;
-			break;
-		}
-
-		if (isp_sd->input != ATOMISP_SUBDEV_INPUT_NONE)
-			return -EBUSY;
-
-		for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
-			if (remote->entity != &isp->csi2_port[i].subdev.entity)
-				continue;
-
-			isp_sd->input = ATOMISP_SUBDEV_INPUT_CSI2_PORT1 + i;
-			return 0;
-		}
-
-		return -EINVAL;
-
-	case ATOMISP_SUBDEV_PAD_SINK | MEDIA_ENT_T_DEVNODE:
-		/* read from memory */
-		if (flags & MEDIA_LNK_FL_ENABLED) {
-			if (isp_sd->input >= ATOMISP_SUBDEV_INPUT_CSI2_PORT1 &&
-				isp_sd->input < (ATOMISP_SUBDEV_INPUT_CSI2_PORT1
-						+ ATOMISP_CAMERA_NR_PORTS))
-				return -EBUSY;
-			isp_sd->input = ATOMISP_SUBDEV_INPUT_MEMORY;
-		} else {
-			if (isp_sd->input == ATOMISP_SUBDEV_INPUT_MEMORY)
-				isp_sd->input = ATOMISP_SUBDEV_INPUT_NONE;
-		}
-		break;
-
-	case ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW | MEDIA_ENT_T_DEVNODE:
-		/* always write to memory */
-		break;
-
-	case ATOMISP_SUBDEV_PAD_SOURCE_VF | MEDIA_ENT_T_DEVNODE:
-		/* always write to memory */
-		break;
-
-	case ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE | MEDIA_ENT_T_DEVNODE:
-		/* always write to memory */
-		break;
-
-	case ATOMISP_SUBDEV_PAD_SOURCE_VIDEO | MEDIA_ENT_T_DEVNODE:
-		/* always write to memory */
-		break;
-
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/* media operations */
-static const struct media_entity_operations isp_subdev_media_ops = {
-	 .link_setup = isp_subdev_link_setup,
-	 .link_validate = v4l2_subdev_link_validate,
-/*	 .set_power = v4l2_subdev_set_power,	*/
-};
-
-static int __atomisp_update_run_mode(struct atomisp_sub_device *asd)
-{
-	struct atomisp_device *isp = asd->isp;
-	struct v4l2_ctrl *ctrl = asd->run_mode;
-	struct v4l2_ctrl *c;
-	struct v4l2_streamparm p = {0};
-	int modes[] = { CI_MODE_NONE,
-			CI_MODE_VIDEO,
-			CI_MODE_STILL_CAPTURE,
-			CI_MODE_CONTINUOUS,
-			CI_MODE_PREVIEW };
-	s32 mode;
-
-	if (ctrl->val != ATOMISP_RUN_MODE_VIDEO &&
-	    asd->continuous_mode->val)
-		mode = ATOMISP_RUN_MODE_PREVIEW;
-	else
-		mode = ctrl->val;
-
-	c = v4l2_ctrl_find(
-		isp->inputs[asd->input_curr].camera->ctrl_handler,
-		V4L2_CID_RUN_MODE);
-
-	if (c)
-		return v4l2_ctrl_s_ctrl(c, mode);
-
-	/* Fall back to obsolete s_parm */
-	p.parm.capture.capturemode = modes[mode];
-
-	return v4l2_subdev_call(
-		isp->inputs[asd->input_curr].camera, video, s_parm, &p);
-}
-
-int atomisp_update_run_mode(struct atomisp_sub_device *asd)
-{
-	int rval;
-
-	mutex_lock(asd->ctrl_handler.lock);
-	rval = __atomisp_update_run_mode(asd);
-	mutex_unlock(asd->ctrl_handler.lock);
-
-	return rval;
-}
-
-static int s_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct atomisp_sub_device *asd = container_of(
-		ctrl->handler, struct atomisp_sub_device, ctrl_handler);
-
-	switch (ctrl->id) {
-	case V4L2_CID_RUN_MODE:
-		return __atomisp_update_run_mode(asd);
-	}
-
-	return 0;
-}
-
-static const struct v4l2_ctrl_ops ctrl_ops = {
-	.s_ctrl = &s_ctrl,
-};
-
-static const struct v4l2_ctrl_config ctrl_fmt_auto = {
-	.ops = &ctrl_ops,
-	.id = V4L2_CID_FMT_AUTO,
-	.name = "Automatic format guessing",
-	.type = V4L2_CTRL_TYPE_BOOLEAN,
-	.min = 0,
-	.max = 1,
-	.step = 1,
-	.def = 1,
-};
-
-static const char * const ctrl_run_mode_menu[] = {
-	NULL,
-	"Video",
-	"Still capture",
-	"Continuous capture",
-	"Preview",
-};
-
-static const struct v4l2_ctrl_config ctrl_run_mode = {
-	.ops = &ctrl_ops,
-	.id = V4L2_CID_RUN_MODE,
-	.name = "Atomisp run mode",
-	.type = V4L2_CTRL_TYPE_MENU,
-	.min = 1,
-	.def = 1,
-	.max = 4,
-	.qmenu = ctrl_run_mode_menu,
-};
-
-static const char * const ctrl_vfpp_mode_menu[] = {
-	"Enable",			/* vfpp always enabled */
-	"Disable to scaler mode",	/* CSS into video mode and disable */
-	"Disable to low latency mode",	/* CSS into still mode and disable */
-};
-
-static const struct v4l2_ctrl_config ctrl_vfpp = {
-	.id = V4L2_CID_VFPP,
-	.name = "Atomisp vf postprocess",
-	.type = V4L2_CTRL_TYPE_MENU,
-	.min = 0,
-	.def = 0,
-	.max = 2,
-	.qmenu = ctrl_vfpp_mode_menu,
-};
-
-/*
- * Control for ISP continuous mode
- *
- * When enabled, capture processing is possible without
- * stopping the preview pipeline. When disabled, ISP needs
- * to be restarted between preview and capture.
- */
-static const struct v4l2_ctrl_config ctrl_continuous_mode = {
-	.ops = &ctrl_ops,
-	.id = V4L2_CID_ATOMISP_CONTINUOUS_MODE,
-	.type = V4L2_CTRL_TYPE_BOOLEAN,
-	.name = "Continuous mode",
-	.min = 0,
-	.max = 1,
-	.step = 1,
-	.def = 0,
-};
-
-/*
- * Control for continuous mode raw buffer size
- *
- * The size of the RAW ringbuffer sets limit on how much
- * back in time application can go when requesting capture
- * frames to be rendered, and how many frames can be rendered
- * in a burst at full sensor rate.
- *
- * Note: this setting has a big impact on memory consumption of
- * the CSS subsystem.
- */
-static const struct v4l2_ctrl_config ctrl_continuous_raw_buffer_size = {
-	.ops = &ctrl_ops,
-	.id = V4L2_CID_ATOMISP_CONTINUOUS_RAW_BUFFER_SIZE,
-	.type = V4L2_CTRL_TYPE_INTEGER,
-	.name = "Continuous raw ringbuffer size",
-	.min = 1,
-	.max = 100, /* depends on CSS version, runtime checked */
-	.step = 1,
-	.def = 3,
-};
-
-/*
- * Control for enabling continuous viewfinder
- *
- * When enabled, and ISP is in continuous mode (see ctrl_continuous_mode ),
- * preview pipeline continues concurrently with capture
- * processing. When disabled, and continuous mode is used,
- * preview is paused while captures are processed, but
- * full pipeline restart is not needed.
- *
- * By setting this to disabled, capture processing is
- * essentially given priority over preview, and the effective
- * capture output rate may be higher than with continuous
- * viewfinder enabled.
- */
-static const struct v4l2_ctrl_config ctrl_continuous_viewfinder = {
-	.id = V4L2_CID_ATOMISP_CONTINUOUS_VIEWFINDER,
-	.type = V4L2_CTRL_TYPE_BOOLEAN,
-	.name = "Continuous viewfinder",
-	.min = 0,
-	.max = 1,
-	.step = 1,
-	.def = 0,
-};
-
-static void atomisp_init_subdev_pipe(struct atomisp_sub_device *asd,
-		struct atomisp_video_pipe *pipe, enum v4l2_buf_type buf_type)
-{
-	pipe->type = buf_type;
-	pipe->asd = asd;
-	pipe->isp = asd->isp;
-	spin_lock_init(&pipe->irq_lock);
-	INIT_LIST_HEAD(&pipe->activeq);
-	INIT_LIST_HEAD(&pipe->activeq_out);
-}
-
-/*
- * isp_subdev_init_entities - Initialize V4L2 subdev and media entity
- * @asd: ISP CCDC module
- *
- * Return 0 on success and a negative error code on failure.
- */
-static int isp_subdev_init_entities(struct atomisp_sub_device *asd)
-{
-	struct v4l2_subdev *sd = &asd->subdev;
-	struct media_pad *pads = asd->pads;
-	struct media_entity *me = &sd->entity;
-	int ret;
-
-	asd->input = ATOMISP_SUBDEV_INPUT_NONE;
-
-	v4l2_subdev_init(sd, &isp_subdev_v4l2_ops);
-	strlcpy(sd->name, "ATOM ISP SUBDEV", sizeof(sd->name));
-	v4l2_set_subdevdata(sd, asd);
-	sd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;
-
-	pads[ATOMISP_SUBDEV_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
-	pads[ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW].flags = MEDIA_PAD_FL_SOURCE;
-	pads[ATOMISP_SUBDEV_PAD_SOURCE_VF].flags = MEDIA_PAD_FL_SOURCE;
-	pads[ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE].flags = MEDIA_PAD_FL_SOURCE;
-	pads[ATOMISP_SUBDEV_PAD_SOURCE_VIDEO].flags = MEDIA_PAD_FL_SOURCE;
-
-	asd->fmt[ATOMISP_SUBDEV_PAD_SINK].fmt.code =
-		V4L2_MBUS_FMT_SBGGR10_1X10;
-	asd->fmt[ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW].fmt.code =
-		V4L2_MBUS_FMT_SBGGR10_1X10;
-	asd->fmt[ATOMISP_SUBDEV_PAD_SOURCE_VF].fmt.code =
-		V4L2_MBUS_FMT_SBGGR10_1X10;
-	asd->fmt[ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE].fmt.code =
-		V4L2_MBUS_FMT_SBGGR10_1X10;
-	asd->fmt[ATOMISP_SUBDEV_PAD_SOURCE_VIDEO].fmt.code =
-		V4L2_MBUS_FMT_SBGGR10_1X10;
-
-	me->ops = &isp_subdev_media_ops;
-	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
-	ret = media_entity_init(me, ATOMISP_SUBDEV_PADS_NUM, pads, 0);
-	if (ret < 0)
-		return ret;
-
-	atomisp_init_subdev_pipe(asd, &asd->video_in,
-			V4L2_BUF_TYPE_VIDEO_OUTPUT);
-
-	atomisp_init_subdev_pipe(asd, &asd->video_out_preview,
-			V4L2_BUF_TYPE_VIDEO_CAPTURE);
-
-	atomisp_init_subdev_pipe(asd, &asd->video_out_vf,
-			V4L2_BUF_TYPE_VIDEO_CAPTURE);
-
-	atomisp_init_subdev_pipe(asd, &asd->video_out_capture,
-			V4L2_BUF_TYPE_VIDEO_CAPTURE);
-
-	atomisp_init_subdev_pipe(asd, &asd->video_out_video_capture,
-			V4L2_BUF_TYPE_VIDEO_CAPTURE);
-
-	ret = atomisp_video_init(&asd->video_in, "MEMORY");
-	if (ret < 0)
-		return ret;
-
-	ret = atomisp_video_init(&asd->video_out_capture, "CAPTURE");
-	if (ret < 0)
-		return ret;
-
-	ret = atomisp_video_init(&asd->video_out_vf, "VIEWFINDER");
-	if (ret < 0)
-		return ret;
-
-	ret = atomisp_video_init(&asd->video_out_preview, "PREVIEW");
-	if (ret < 0)
-		return ret;
-
-	ret = atomisp_video_init(&asd->video_out_video_capture, "VIDEO");
-	if (ret < 0)
-		return ret;
-
-	/* Connect the isp subdev to the video node. */
-	ret = media_entity_create_link(&asd->video_in.vdev.entity,
-		0, &asd->subdev.entity, ATOMISP_SUBDEV_PAD_SINK, 0);
-	if (ret < 0)
-		return ret;
-
-	ret = media_entity_create_link(&asd->subdev.entity,
-		ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW,
-		&asd->video_out_preview.vdev.entity, 0, 0);
-	if (ret < 0)
-		return ret;
-
-	ret = media_entity_create_link(&asd->subdev.entity,
-		ATOMISP_SUBDEV_PAD_SOURCE_VF,
-		&asd->video_out_vf.vdev.entity, 0, 0);
-	if (ret < 0)
-		return ret;
-
-	ret = media_entity_create_link(&asd->subdev.entity,
-		ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE,
-		&asd->video_out_capture.vdev.entity, 0, 0);
-	if (ret < 0)
-		return ret;
-
-	ret = media_entity_create_link(&asd->subdev.entity,
-		ATOMISP_SUBDEV_PAD_SOURCE_VIDEO,
-		&asd->video_out_video_capture.vdev.entity, 0, 0);
-	if (ret < 0)
-		return ret;
-
-	ret = v4l2_ctrl_handler_init(&asd->ctrl_handler, 1);
-	if (ret)
-		return ret;
-
-	asd->fmt_auto = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-						    &ctrl_fmt_auto, NULL);
-	asd->run_mode = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-						    &ctrl_run_mode, NULL);
-	asd->vfpp = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-						&ctrl_vfpp, NULL);
-	asd->continuous_mode = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-					     &ctrl_continuous_mode, NULL);
-	asd->continuous_viewfinder = v4l2_ctrl_new_custom(&asd->ctrl_handler,
-					     &ctrl_continuous_viewfinder,
-					     NULL);
-	asd->continuous_raw_buffer_size =
-			v4l2_ctrl_new_custom(&asd->ctrl_handler,
-					     &ctrl_continuous_raw_buffer_size,
-					     NULL);
-
-	/* Make controls visible on subdev as well. */
-	asd->subdev.ctrl_handler = &asd->ctrl_handler;
-
-	return asd->ctrl_handler.error;
-}
-
-static void atomisp_subdev_cleanup_entities(struct atomisp_sub_device *asd)
-{
-	v4l2_ctrl_handler_free(&asd->ctrl_handler);
-
-	media_entity_cleanup(&asd->subdev.entity);
-}
-
-void atomisp_subdev_unregister_entities(struct atomisp_sub_device *asd)
-{
-	atomisp_subdev_cleanup_entities(asd);
-	v4l2_device_unregister_subdev(&asd->subdev);
-	atomisp_video_unregister(&asd->video_in);
-	atomisp_video_unregister(&asd->video_out_preview);
-	atomisp_video_unregister(&asd->video_out_vf);
-	atomisp_video_unregister(&asd->video_out_capture);
-	atomisp_video_unregister(&asd->video_out_video_capture);
-}
-
-int atomisp_subdev_register_entities(struct atomisp_sub_device *asd,
-	struct v4l2_device *vdev)
-{
-	int ret;
-
-	/* Register the subdev and video node. */
-	ret = v4l2_device_register_subdev(vdev, &asd->subdev);
-	if (ret < 0)
-		goto error;
-
-	ret = atomisp_video_register(&asd->video_out_capture, vdev);
-	if (ret < 0)
-		goto error;
-
-	ret = atomisp_video_register(&asd->video_out_vf, vdev);
-	if (ret < 0)
-		goto error;
-
-	ret = atomisp_video_register(&asd->video_out_preview, vdev);
-	if (ret < 0)
-		goto error;
-
-	ret = atomisp_video_register(&asd->video_out_video_capture, vdev);
-	if (ret < 0)
-		goto error;
-
-	/*
-	 * file input only supported on subdev0
-	 * so do not create video node for subdevs other then subdev0
-	 */
-	if (asd->index)
-		return 0;
-	ret = atomisp_video_register(&asd->video_in, vdev);
-	if (ret < 0)
-		goto error;
-
-	return 0;
-
-error:
-	atomisp_subdev_unregister_entities(asd);
-	return ret;
-}
-
-
-/*
- * atomisp_subdev_init - ISP Subdevice  initialization.
- * @dev: Device pointer specific to the ATOM ISP.
- *
- * TODO: Get the initialisation values from platform data.
- *
- * Return 0 on success or a negative error code otherwise.
- */
-int atomisp_subdev_init(struct atomisp_device *isp)
-{
-	struct atomisp_sub_device *asd;
-	int i, ret = 0;
-
-	/*
-	 * CSS2.0 running ISP2400 support
-	 * multiple streams
-	 */
-	isp->num_of_streams = isp->media_dev.driver_version >=
-	    ATOMISP_CSS_VERSION_20 ? 2 : 1;
-	isp->asd = devm_kzalloc(isp->dev, sizeof(struct atomisp_sub_device) *
-			       isp->num_of_streams, GFP_KERNEL);
-	if (!isp->asd)
-		return -ENOMEM;
-	for (i = 0; i < isp->num_of_streams; i++) {
-		asd = &isp->asd[i];
-		spin_lock_init(&asd->lock);
-		asd->isp = isp;
-		isp_subdev_init_params(asd);
-		ret = isp_subdev_init_entities(asd);
-		if (ret < 0) {
-			atomisp_subdev_cleanup_entities(asd);
-			break;
-		}
-		asd->index = i;
-	}
-
-	return ret;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.h
deleted file mode 100644
index eff1f88..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_subdev.h
+++ /dev/null
@@ -1,356 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef __ATOMISP_SUBDEV_H__
-#define __ATOMISP_SUBDEV_H__
-
-#include <media/v4l2-ctrls.h>
-#include <media/v4l2-device.h>
-#include <media/v4l2-subdev.h>
-#include <media/videobuf-core.h>
-
-#include "atomisp_common.h"
-#include "atomisp_compat.h"
-#include "atomisp_v4l2.h"
-
-#ifdef CSS20
-#include "ia_css.h"
-#else /* CSS20 */
-#include "sh_css.h"
-#endif /* CSS20 */
-
-enum atomisp_subdev_input_entity {
-	ATOMISP_SUBDEV_INPUT_NONE,
-	ATOMISP_SUBDEV_INPUT_MEMORY,
-	ATOMISP_SUBDEV_INPUT_CSI2,
-	/*
-	 * The following enum for CSI2 port must go together in one row.
-	 * Otherwise it breaks the code logic.
-	 */
-	ATOMISP_SUBDEV_INPUT_CSI2_PORT1,
-	ATOMISP_SUBDEV_INPUT_CSI2_PORT2,
-	ATOMISP_SUBDEV_INPUT_CSI2_PORT3,
-};
-
-#define ATOMISP_SUBDEV_PAD_SINK			0
-/* capture output for still frames */
-#define ATOMISP_SUBDEV_PAD_SOURCE_CAPTURE	1
-/* viewfinder output for downscaled capture output */
-#define ATOMISP_SUBDEV_PAD_SOURCE_VF		2
-/* preview output for display */
-#define ATOMISP_SUBDEV_PAD_SOURCE_PREVIEW	3
-/* main output for video pipeline */
-#define ATOMISP_SUBDEV_PAD_SOURCE_VIDEO	4
-#define ATOMISP_SUBDEV_PADS_NUM			5
-
-struct atomisp_in_fmt_conv {
-	enum v4l2_mbus_pixelcode code;
-	uint8_t bpp; /* bits per pixel */
-	uint8_t depth; /* uncompressed */
-	enum atomisp_css_stream_format in_sh_fmt;
-	enum atomisp_css_bayer_order bayer_order;
-};
-
-struct atomisp_sub_device;
-
-struct atomisp_video_pipe {
-	struct video_device vdev;
-	enum v4l2_buf_type type;
-	struct media_pad pad;
-	struct videobuf_queue capq;
-	struct videobuf_queue outq;
-	struct list_head activeq;
-	struct list_head activeq_out;
-	unsigned int buffers_in_css;
-
-	/* irq_lock is used to protect video buffer state change operations and
-	 * also to make activeq, activeq_out, capq and outq list
-	 * operations atomic. */
-	spinlock_t irq_lock;
-	unsigned int users;
-
-	struct atomisp_device *isp;
-	struct v4l2_pix_format pix;
-	uint32_t sh_fmt;
-
-	struct atomisp_sub_device *asd;
-};
-
-struct atomisp_pad_format {
-	struct v4l2_mbus_framefmt fmt;
-	struct v4l2_rect crop;
-	struct v4l2_rect compose;
-};
-
-/* Internal states for flash process */
-enum atomisp_flash_state {
-	ATOMISP_FLASH_IDLE,
-	ATOMISP_FLASH_REQUESTED,
-	ATOMISP_FLASH_ONGOING,
-	ATOMISP_FLASH_DONE
-};
-
-struct atomisp_css_params {
-	/* FIXME: Determines whether raw capture buffer are being passed to
-	 * user space. Unimplemented for now. */
-	int online_process;
-	int yuv_ds_en;
-	unsigned int color_effect;
-	bool gdc_cac_en;
-	bool macc_en;
-	bool bad_pixel_en;
-	bool video_dis_en;
-	bool sc_en;
-	bool fpn_en;
-	bool xnr_en;
-	bool low_light;
-	int false_color;
-	unsigned int histogram_elenum;
-
-	/* Current grid info */
-	struct atomisp_css_grid_info curr_grid_info;
-
-	int s3a_output_bytes;
-	bool s3a_buf_data_valid;
-
-	bool dis_proj_data_valid;
-
-	/* current configurations */
-	/* Dead Pixel config */
-	struct atomisp_css_dp_config   dp_config;
-	/* White Balance config */
-	struct atomisp_css_wb_config   wb_config;
-	/* Color Correction config */
-	struct atomisp_css_cc_config   cc_config;
-	/* Noise Reduction config */
-	struct atomisp_css_nr_config   nr_config;
-	/* Edge Enhancement config */
-	struct atomisp_css_ee_config   ee_config;
-	/* Objective Black config */
-	struct atomisp_css_ob_config   ob_config;
-	/* Demosaic config */
-	struct atomisp_css_de_config   de_config;
-	struct atomisp_css_ce_config   ce_config;
-	/* Gamma Correction config */
-	struct atomisp_css_gc_config   gc_config;
-	/* Temporal Noise Reduction */
-	struct atomisp_css_tnr_config  tnr_config;
-	/* 3A Statistics config */
-	struct atomisp_css_3a_config   s3a_config;
-	struct atomisp_css_gamma_table gamma_table;
-	struct atomisp_css_ctc_table   ctc_table;
-	struct atomisp_css_macc_table  macc_table;
-
-#ifdef CSS20
-	struct atomisp_css_ctc_config	ctc_config;
-	struct atomisp_css_cnr_config	cnr_config;
-	struct atomisp_css_macc_config	macc_config;
-	/* Eigen Color Demosaicing */
-	struct atomisp_css_ecd_config	ecd_config;
-	/* Y(Luma) Noise Reduction */
-	struct atomisp_css_ynr_config	ynr_config;
-	/* Fringe Control */
-	struct atomisp_css_fc_config	fc_config;
-	/* Anti-Aliasing */
-	struct atomisp_css_aa_config	aa_config;
-	/* Bayer Anti-Aliasing */
-	struct atomisp_css_aa_config	baa_config;
-	/* Advanced Noise Reduction */
-	struct atomisp_css_anr_config	anr_config;
-	/* eXtra Noise Reduction */
-	struct atomisp_css_xnr_config	xnr_config;
-	/* Color Correction config */
-	struct atomisp_css_cc_config	yuv2rgb_cc_config;
-	/* Color Correction config */
-	struct atomisp_css_cc_config	rgb2yuv_cc_config;
-	struct atomisp_css_xnr_table   xnr_table;
-	struct atomisp_css_rgb_gamma_table	r_gamma_table;
-	struct atomisp_css_rgb_gamma_table	g_gamma_table;
-	struct atomisp_css_rgb_gamma_table	b_gamma_table;
-	struct atomisp_css_anr_thres	anr_thres;
-
-	struct ia_css_dz_config   dz_config;  /**< Digital Zoom */
-	struct ia_css_capture_config   capture_config;
-	struct ia_css_dvs_coefficients dvs_coefs;
-	struct ia_css_vector  motion_vector;
-
-	struct atomisp_css_isp_config config;
-
-	/* Intermediate buffers used to communicate data between
-	   CSS and user space. These are needed to perform the
-	   copy_to_user. */
-	struct ia_css_3a_statistics *s3a_user_stat;
-	struct ia_css_dvs2_coefficients *dvs_coeff;
-	struct ia_css_dvs2_statistics *dvs_stat;
-	struct ia_css_dvs_6axis_config *dvs_6axis;
-	uint32_t exp_id;
-	int  dvs_hor_coef_bytes;
-	int  dvs_ver_coef_bytes;
-	int  dvs_ver_proj_bytes;
-	int  dvs_hor_proj_bytes;
-#else /* CSS20 */
-	struct sh_css_3a_output *s3a_output_buf;
-	/* DIS Coefficients */
-	short *dis_hor_coef_buf;
-	int    dis_hor_coef_bytes;
-	short *dis_ver_coef_buf;
-	int    dis_ver_coef_bytes;
-	/* DIS projections */
-	int *dis_ver_proj_buf;
-	int  dis_ver_proj_bytes;
-	int *dis_hor_proj_buf;
-	int  dis_hor_proj_bytes;
-
-	/* default configurations */
-	struct atomisp_css_dp_config   *default_dp_config;
-	struct atomisp_css_wb_config   *default_wb_config;
-	struct atomisp_css_cc_config   *default_cc_config;
-	struct atomisp_css_nr_config   *default_nr_config;
-	struct atomisp_css_ee_config   *default_ee_config;
-	struct atomisp_css_ob_config   *default_ob_config;
-	struct atomisp_css_de_config   *default_de_config;
-	struct atomisp_css_ce_config   *default_ce_config;
-	struct atomisp_css_gc_config   *default_gc_config;
-	struct atomisp_css_tnr_config  *default_tnr_config;
-	struct atomisp_css_3a_config   *default_3a_config;
-	struct atomisp_css_macc_table  *default_macc_table;
-	struct atomisp_css_ctc_table   *default_ctc_table;
-	struct atomisp_css_gamma_table *default_gamma_table;
-#endif /* CSS20 */
-
-	/* Flash */
-	int num_flash_frames;
-	enum atomisp_flash_state flash_state;
-	enum atomisp_frame_status last_frame_status;
-
-	/* continuous capture */
-	struct atomisp_cont_capture_conf offline_parm;
-	/* Flag to check if driver needs to update params to css */
-	bool css_update_params_needed;
-};
-
-struct atomisp_sub_device {
-	struct v4l2_subdev subdev;
-	struct media_pad pads[ATOMISP_SUBDEV_PADS_NUM];
-	struct atomisp_pad_format fmt[ATOMISP_SUBDEV_PADS_NUM];
-	uint16_t capture_pad; /* main capture pad; defines much of isp config */
-
-	enum atomisp_subdev_input_entity input;
-	unsigned int output;
-	struct atomisp_video_pipe video_in;
-	struct atomisp_video_pipe video_out_capture; /* capture output */
-	struct atomisp_video_pipe video_out_vf;      /* viewfinder output */
-	struct atomisp_video_pipe video_out_preview; /* preview output */
-	/* video pipe main output */
-	struct atomisp_video_pipe video_out_video_capture;
-	/* struct isp_subdev_params params; */
-	spinlock_t lock;
-	struct atomisp_device *isp;
-	struct v4l2_ctrl_handler ctrl_handler;
-	struct v4l2_ctrl *fmt_auto;
-	struct v4l2_ctrl *run_mode;
-	struct v4l2_ctrl *vfpp;
-	struct v4l2_ctrl *continuous_mode;
-	struct v4l2_ctrl *continuous_raw_buffer_size;
-	struct v4l2_ctrl *continuous_viewfinder;
-
-	struct atomisp_css_params params;
-
-#ifdef CSS20
-	struct atomisp_stream_env stream_env[ATOMISP_INPUT_STREAM_NUM];
-#endif
-	struct v4l2_pix_format dvs_envelop;
-	unsigned int s3a_bufs_in_css[CSS_PIPE_ID_NUM];
-	unsigned int dis_bufs_in_css;
-
-	struct list_head s3a_stats;
-	struct list_head dis_stats;
-
-	struct atomisp_css_frame *vf_frame; /* TODO: needed? */
-	struct atomisp_css_frame *raw_output_frame;
-	enum atomisp_frame_status frame_status[VIDEO_MAX_FRAME];
-
-	/* This field specifies which MIPI input port is selected. */
-	int input_curr;
-	/* This field specifies which sensor is being selected when there
-	   are multiple sensors connected to the same MIPI port. */
-	int sensor_curr;
-
-	atomic_t sof_count;
-	atomic_t sequence;      /* Sequence value that is assigned to buffer. */
-	atomic_t sequence_temp;
-
-	unsigned int streaming; /* Hold both mutex and lock to change this */
-
-	/* subdev index: will be used to show which subdev is holding the
-	 * resource, like which camera is used by which subdev
-	 */
-	unsigned int index;
-
-	/* delayed memory allocation for css */
-	struct completion init_done;
-	struct workqueue_struct *delayed_init_workq;
-	unsigned int delayed_init;
-	struct work_struct delayed_init_work;
-
-	unsigned int latest_preview_exp_id; /* CSS ZSL/SDV raw buffer id */
-
-	unsigned int mipi_frame_size;
-};
-
-extern const struct atomisp_in_fmt_conv atomisp_in_fmt_conv[];
-
-enum v4l2_mbus_pixelcode atomisp_subdev_uncompressed_code(
-	enum v4l2_mbus_pixelcode code);
-bool atomisp_subdev_is_compressed(enum v4l2_mbus_pixelcode code);
-const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv(
-	enum v4l2_mbus_pixelcode code);
-const struct atomisp_in_fmt_conv *atomisp_find_in_fmt_conv_compressed(
-	enum v4l2_mbus_pixelcode code);
-bool atomisp_subdev_format_conversion(struct atomisp_sub_device *asd,
-				      unsigned int source_pad);
-uint16_t atomisp_subdev_source_pad(struct video_device *vdev);
-
-/* Get pointer to appropriate format */
-struct v4l2_mbus_framefmt
-*atomisp_subdev_get_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			 uint32_t which, uint32_t pad);
-struct v4l2_rect *atomisp_subdev_get_rect(struct v4l2_subdev *sd,
-					  struct v4l2_subdev_fh *fh,
-					  uint32_t which, uint32_t pad,
-					  uint32_t target);
-int atomisp_subdev_set_selection(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_fh *fh, uint32_t which,
-				 uint32_t pad, uint32_t target, uint32_t flags,
-				 struct v4l2_rect *r);
-/* Actually set the format */
-void atomisp_subdev_set_ffmt(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
-			     uint32_t which, uint32_t pad,
-			     struct v4l2_mbus_framefmt *ffmt);
-
-int atomisp_update_run_mode(struct atomisp_sub_device *asd);
-
-void atomisp_subdev_unregister_entities(struct atomisp_sub_device *asd);
-int atomisp_subdev_register_entities(struct atomisp_sub_device *asd,
-	struct v4l2_device *vdev);
-int atomisp_subdev_init(struct atomisp_device *isp);
-void atomisp_subdev_cleanup(struct atomisp_device *isp);
-
-#endif /* __ATOMISP_SUBDEV_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tables.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tables.h
deleted file mode 100644
index d69a9c1..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tables.h
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef	__ATOMISP_TABLES_H__
-#define	__ATOMISP_TABLES_H__
-
-#include "sh_css_params.h"
-
-/*Sepia image effect table*/
-static struct atomisp_css_cc_config sepia_cc_config = {
-	.fraction_bits  = 8,
-	.matrix	 = {141, 18, 68, -40, -5, -19, 35, 4, 16},
-};
-
-/*Negative image effect table*/
-static struct atomisp_css_cc_config nega_cc_config = {
-	.fraction_bits  = 8,
-	.matrix	 = {255, 29, 120, 0, 374, 342, 0, 672, -301},
-};
-
-/*Mono image effect table*/
-static struct atomisp_css_cc_config mono_cc_config = {
-	.fraction_bits  = 8,
-	.matrix	 = {255, 29, 120, 0, 0, 0, 0, 0, 0},
-};
-
-/*Skin whiten image effect table*/
-static struct atomisp_css_macc_table skin_low_macc_table = {
-	.data = {
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	7168, 0, 2048, 8192,
-	5120, -1024, 2048, 8192,
-	8192, 2048, -1024, 5120,
-	8192, 2048, 0, 7168,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192
-	}
-};
-
-static struct atomisp_css_macc_table skin_medium_macc_table = {
-	.data = {
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	5120, 0, 6144, 8192,
-	3072, -1024, 2048, 6144,
-	6144, 2048, -1024, 3072,
-	8192, 6144, 0, 5120,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192
-	}
-};
-
-static struct atomisp_css_macc_table skin_high_macc_table = {
-	.data = {
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	4096, 0, 8192, 8192,
-	0, -2048, 4096, 6144,
-	6144, 4096, -2048, 0,
-	8192, 8192, 0, 4096,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192
-	}
-};
-
-/*Blue enhencement image effect table*/
-static struct atomisp_css_macc_table blue_macc_table = {
-	.data = {
-	9728, -3072, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	9728, 0, -3072, 8192,
-	12800, 1536, -3072, 8192,
-	11264, 0, 0, 11264,
-	9728, -3072, 0, 11264
-	}
-};
-
-/*Green enhencement image effect table*/
-static struct atomisp_css_macc_table green_macc_table = {
-	.data = {
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	10240, 4096, 0, 8192,
-	10240, 4096, 0, 12288,
-	12288, 0, 0, 12288,
-	14336, -2048, 4096, 8192,
-	10240, 0, 4096, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192,
-	8192, 0, 0, 8192
-	}
-};
-
-#if defined(ISP2400) || defined(ISP2400B0) || defined(ISP2401)
-/* this table is from CSS1.5 default_ctc_table(20121003) */
-static struct atomisp_css_ctc_table vivid_ctc_table = {
-#ifdef CSS20
-	.data.vamem_2 = {
-	0,  384,  837,  957, 1011, 1062, 1083, 1080,
-	1078, 1077, 1053, 1039, 1012,  992,  969,  951,
-	929,  906,  886,  866,  845,  823,  809,  790,
-	772,  758,  741,  726,  711,  701,  688,  675,
-	666,  656,  648,  639,  633,  626,  618,  612,
-	603,  594,  582,  572,  557,  545,  529,  516,
-	504,  491,  480,  467,  459,  447,  438,  429,
-	419,  412,  404,  397,  389,  382,  376,  368,
-	363,  357,  351,  345,  340,  336,  330,  326,
-	321,  318,  312,  308,  304,  300,  297,  294,
-	291,  286,  284,  281,  278,  275,  271,  268,
-	261,  257,  251,  245,  240,  235,  232,  225,
-	223,  218,  213,  209,  206,  204,  199,  197,
-	193,  189,  186,  185,  183,  179,  177,  175,
-	172,  170,  169,  167,  164,  164,  162,  160,
-	158,  157,  156,  154,  154,  152,  151,  150,
-	149,  148,  146,  147,  146,  144,  143,  143,
-	142,  141,  140,  141,  139,  138,  138,  138,
-	137,  136,  136,  135,  134,  134,  134,  133,
-	132,  132,  131,  130,  131,  130,  129,  128,
-	129,  127,  127,  127,  127,  125,  125,  125,
-	123,  123,  122,  120,  118,  115,  114,  111,
-	110,  108,  106,  105,  103,  102,  100,   99,
-	97,   97,   96,   95,   94,   93,   93,   91,
-	91,   91,   90,   90,   89,   89,   88,   88,
-	89,   88,   88,   87,   87,   87,   87,   86,
-	87,   87,   86,   87,   86,   86,   84,   84,
-	82,   80,   78,   76,   74,   72,   70,   68,
-	67,   65,   62,   60,   58,   56,   55,   54,
-	53,   51,   49,   49,   47,   45,   45,   45,
-	41,   40,   39,   39,   34,   33,   34,   32,
-	25,   23,   24,   20,   13,    9,   12,    0,
-	0
-	}
-#else /* CSS20 */
-	.data = {
-	0,  384,  837,  957, 1011, 1062, 1083, 1080,
-	1078, 1077, 1053, 1039, 1012,  992,  969,  951,
-	929,  906,  886,  866,  845,  823,  809,  790,
-	772,  758,  741,  726,  711,  701,  688,  675,
-	666,  656,  648,  639,  633,  626,  618,  612,
-	603,  594,  582,  572,  557,  545,  529,  516,
-	504,  491,  480,  467,  459,  447,  438,  429,
-	419,  412,  404,  397,  389,  382,  376,  368,
-	363,  357,  351,  345,  340,  336,  330,  326,
-	321,  318,  312,  308,  304,  300,  297,  294,
-	291,  286,  284,  281,  278,  275,  271,  268,
-	261,  257,  251,  245,  240,  235,  232,  225,
-	223,  218,  213,  209,  206,  204,  199,  197,
-	193,  189,  186,  185,  183,  179,  177,  175,
-	172,  170,  169,  167,  164,  164,  162,  160,
-	158,  157,  156,  154,  154,  152,  151,  150,
-	149,  148,  146,  147,  146,  144,  143,  143,
-	142,  141,  140,  141,  139,  138,  138,  138,
-	137,  136,  136,  135,  134,  134,  134,  133,
-	132,  132,  131,  130,  131,  130,  129,  128,
-	129,  127,  127,  127,  127,  125,  125,  125,
-	123,  123,  122,  120,  118,  115,  114,  111,
-	110,  108,  106,  105,  103,  102,  100,   99,
-	97,   97,   96,   95,   94,   93,   93,   91,
-	91,   91,   90,   90,   89,   89,   88,   88,
-	89,   88,   88,   87,   87,   87,   87,   86,
-	87,   87,   86,   87,   86,   86,   84,   84,
-	82,   80,   78,   76,   74,   72,   70,   68,
-	67,   65,   62,   60,   58,   56,   55,   54,
-	53,   51,   49,   49,   47,   45,   45,   45,
-	41,   40,   39,   39,   34,   33,   34,   32,
-	25,   23,   24,   20,   13,    9,   12,    0,
-	0
-	}
-#endif /* CSS20 */
-};
-#else
-/*Color enhancement image effect table*/
-static struct atomisp_css_ctc_table vivid_ctc_table = {
-	.data = {
-	876, 872, 869, 865, 861, 858, 854, 850,
-	847, 843, 839, 835, 832, 828, 824, 821,
-	817, 813, 810, 806, 802, 799, 795, 791,
-	788, 784, 780, 777, 773, 769, 766, 762,
-	758, 754, 751, 747, 743, 740, 736, 732,
-	729, 725, 721, 718, 714, 710, 707, 703,
-	699, 696, 692, 688, 685, 681, 677, 673,
-	670, 666, 662, 659, 655, 651, 648, 644,
-	640, 637, 633, 629, 626, 622, 618, 615,
-	611, 607, 604, 600, 596, 592, 589, 585,
-	581, 578, 574, 570, 567, 563, 559, 556,
-	552, 548, 545, 541, 539, 537, 536, 534,
-	533, 531, 530, 528, 527, 525, 524, 522,
-	521, 519, 518, 516, 515, 514, 512, 511,
-	509, 508, 506, 505, 503, 502, 500, 499,
-	497, 496, 494, 493, 491, 490, 488, 487,
-	485, 484, 482, 481, 479, 478, 476, 475,
-	473, 472, 470, 469, 467, 466, 464, 463,
-	461, 460, 458, 457, 455, 454, 452, 451,
-	449, 448, 446, 445, 443, 442, 440, 439,
-	437, 436, 434, 433, 431, 430, 428, 427,
-	425, 424, 422, 421, 419, 418, 417, 415,
-	414, 412, 411, 409, 408, 406, 405, 403,
-	402, 400, 399, 397, 396, 394, 393, 392,
-	392, 391, 391, 390, 389, 389, 388, 388,
-	387, 387, 386, 385, 385, 384, 384, 383,
-	383, 382, 381, 381, 380, 380, 379, 379,
-	378, 377, 377, 376, 376, 375, 375, 374,
-	374, 373, 372, 372, 371, 371, 370, 370,
-	369, 368, 368, 367, 367, 366, 366, 365,
-	364, 364, 363, 363, 362, 362, 361, 360,
-	360, 359, 359, 358, 358, 357, 356, 356,
-	355, 355, 354, 354, 353, 352, 352, 351,
-	351, 350, 350, 349, 348, 348, 347, 347,
-	346, 346, 345, 344, 344, 343, 343, 342,
-	342, 341, 340, 340, 339, 339, 338, 338,
-	337, 336, 336, 335, 335, 334, 334, 333,
-	333, 332, 331, 331, 330, 330, 329, 329,
-	328, 327, 327, 326, 326, 325, 325, 324,
-	323, 323, 322, 322, 321, 321, 320, 319,
-	319, 318, 318, 317, 317, 316, 315, 315,
-	314, 314, 313, 313, 312, 311, 311, 310,
-	310, 309, 309, 308, 307, 307, 306, 306,
-	305, 305, 304, 303, 303, 302, 302, 301,
-	301, 300, 299, 299, 298, 298, 297, 297,
-	296, 296, 295, 294, 294, 293, 293, 292,
-	292, 291, 290, 290, 289, 289, 288, 288,
-	287, 286, 286, 285, 285, 284, 284, 283,
-	282, 282, 281, 281, 280, 280, 279, 278,
-	278, 277, 277, 276, 276, 275, 274, 274,
-	273, 273, 272, 272, 271, 270, 270, 269,
-	269, 268, 268, 267, 266, 266, 265, 265,
-	264, 264, 263, 262, 262, 261, 261, 260,
-	260, 259, 259, 258, 257, 257, 256, 256,
-	255, 255, 254, 253, 253, 252, 252, 251,
-	251, 250, 249, 249, 248, 248, 247, 247,
-	246, 245, 245, 244, 244, 243, 243, 242,
-	241, 241, 240, 240, 239, 239, 238, 237,
-	237, 236, 236, 235, 235, 234, 233, 233,
-	232, 232, 231, 231, 230, 229, 229, 228,
-	228, 227, 227, 226, 225, 225, 224, 224,
-	223, 223, 222, 221, 221, 220, 220, 219,
-	219, 218, 218, 217, 216, 216, 215, 215,
-	214, 214, 213, 212, 212, 211, 211, 210,
-	210, 209, 208, 208, 207, 207, 206, 206,
-	205, 204, 204, 203, 203, 202, 202, 201,
-	200, 200, 199, 199, 198, 198, 197, 196,
-	196, 195, 195, 194, 194, 193, 192, 192,
-	191, 191, 190, 190, 189, 188, 188, 187,
-	187, 186, 186, 185, 184, 184, 183, 183,
-	182, 182, 181, 181, 180, 179, 179, 178,
-	178, 177, 177, 176, 175, 175, 174, 174,
-	173, 173, 172, 171, 171, 170, 170, 169,
-	169, 168, 167, 167, 166, 166, 165, 165,
-	164, 163, 163, 163, 162, 162, 161, 161,
-	161, 160, 160, 159, 159, 159, 158, 158,
-	158, 157, 157, 156, 156, 156, 155, 155,
-	155, 154, 154, 153, 153, 153, 152, 152,
-	152, 151, 151, 150, 150, 150, 149, 149,
-	149, 148, 148, 147, 147, 147, 146, 146,
-	145, 145, 145, 144, 144, 144, 143, 143,
-	142, 142, 142, 141, 141, 141, 140, 140,
-	139, 139, 139, 138, 138, 138, 137, 137,
-	136, 136, 136, 135, 135, 134, 134, 134,
-	133, 133, 133, 132, 132, 131, 131, 131,
-	130, 130, 130, 129, 129, 128, 128, 128,
-	127, 127, 127, 126, 126, 125, 125, 125,
-	124, 124, 123, 123, 123, 122, 122, 122,
-	121, 121, 120, 120, 120, 119, 119, 119,
-	118, 118, 117, 117, 117, 116, 116, 116,
-	115, 115, 114, 114, 114, 113, 113, 112,
-	112, 112, 111, 111, 111, 110, 110, 109,
-	109, 109, 108, 108, 108, 107, 107, 106,
-	106, 106, 105, 105, 105, 104, 104, 103,
-	103, 103, 102, 102, 101, 101, 101, 100,
-	100, 100, 99, 99, 98, 98, 98, 97,
-	97, 97, 96, 96, 95, 95, 95, 94,
-	94, 94, 93, 93, 92, 92, 92, 91,
-	91, 91, 90, 90, 89, 89, 89, 88,
-	88, 87, 87, 87, 86, 86, 86, 85,
-	85, 84, 84, 84, 83, 83, 83, 82,
-	82, 81, 81, 81, 80, 80, 80, 79,
-	79, 78, 78, 78, 77, 77, 76, 76,
-	76, 75, 75, 75, 74, 74, 73, 73,
-	73, 72, 72, 72, 71, 71, 70, 70,
-	70, 69, 69, 69, 68, 68, 67, 67,
-	67, 66, 66, 65, 65, 65, 64, 64,
-	64, 63, 63, 61, 61, 61, 61, 61,
-	61, 60, 60, 58, 58, 58, 58, 58,
-	58, 57, 57, 56, 56, 56, 55, 55,
-	54, 54, 54, 53, 53, 53, 51, 51,
-	51, 51, 51, 50, 50, 50, 48, 48,
-	48, 48, 48, 47, 47, 47, 45, 45,
-	45, 45, 45, 44, 44, 42, 42, 42,
-	42, 42, 42, 41, 41, 40, 40, 40,
-	39, 39, 39, 38, 38, 37, 37, 37,
-	35, 35, 35, 35, 35, 34, 34, 34,
-	32, 32, 32, 32, 32, 31, 31, 31,
-	29, 29, 29, 29, 29, 28, 28, 28,
-	26, 26, 25, 25, 25, 25, 25, 25,
-	24, 24, 22, 22, 22, 22, 22, 22,
-	21, 21, 19, 19, 19, 19, 19, 18,
-	18, 18, 16, 16, 16, 16, 16, 15,
-	15, 15, 13, 13, 13, 12, 12, 12,
-	12, 12, 10, 10, 10, 9, 9, 9,
-	9, 9, 8, 8, 6, 6, 6, 6,
-	6, 6, 5, 5, 3, 3, 3, 3,
-	3, 3, 2, 2, 0, 0, 0, 0,
-	}
-};
-#endif
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.c
deleted file mode 100644
index e123ac7..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.c
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include <media/v4l2-event.h>
-#include <media/v4l2-mediabus.h>
-#include "atomisp_internal.h"
-#include "atomisp_tpg.h"
-
-#ifndef CSS20
-#include "sh_css.h"
-#endif /* CSS20 */
-
-static int tpg_s_stream(struct v4l2_subdev *sd, int enable)
-{
-	return 0;
-}
-
-static int tpg_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *param)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_enum_framesizes(struct v4l2_subdev *sd,
-				  struct v4l2_frmsizeenum *fsize)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_enum_frameintervals(struct v4l2_subdev *sd,
-				      struct v4l2_frmivalenum *fival)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,
-				enum v4l2_mbus_pixelcode *code)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_try_mbus_fmt(struct v4l2_subdev *sd,
-			       struct v4l2_mbus_framefmt *fmt)
-{
-	/* only raw8 grbg is supported by TPG */
-	fmt->code = V4L2_MBUS_FMT_SGRBG8_1X8;
-	return 0;
-}
-
-static int tpg_g_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_s_mbus_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_mbus_framefmt *fmt)
-{
-	/* only raw8 grbg is supported by TPG */
-	fmt->code = V4L2_MBUS_FMT_SGRBG8_1X8;
-	return 0;
-}
-
-static int tpg_g_chip_ident(struct v4l2_subdev *sd,
-			       struct v4l2_dbg_chip_ident *chip)
-{
-	if (!chip)
-		return -EINVAL;
-	return 0;
-}
-
-static int tpg_log_status(struct v4l2_subdev *sd)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
-{
-	/*to fake*/
-	return -EINVAL;
-}
-
-static int tpg_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	/*to fake*/
-	return -EINVAL;
-}
-
-static int tpg_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_s_power(struct v4l2_subdev *sd, int on)
-{
-#ifndef CSS20
-	int x_delta = -2;
-	int y_delta = 3;
-	unsigned int x_mask  = (1 << 4) - 1;
-	unsigned int y_mask  = (1 << 4) - 1;
-	unsigned int xy_mask = (1 << 8) - 1;
-
-	sh_css_input_set_bayer_order(sh_css_bayer_order_grbg);
-	sh_css_input_set_format(SH_CSS_INPUT_FORMAT_RAW_10);
-	sh_css_input_configure_port(MIPI_PORT0_ID, 2, 0xffff4);
-	sh_css_tpg_configure(x_mask, x_delta, y_mask, y_delta, xy_mask);
-	sh_css_input_set_mode(SH_CSS_INPUT_MODE_TPG);
-#endif /* CSS20 */
-
-	return 0;
-}
-
-static int tpg_enum_mbus_code(struct v4l2_subdev *sd,
-				 struct v4l2_subdev_fh *fh,
-				 struct v4l2_subdev_mbus_code_enum *code)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_enum_frame_size(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_fh *fh,
-				  struct v4l2_subdev_frame_size_enum *fse)
-{
-	/*to fake*/
-	return 0;
-}
-
-static int tpg_enum_frame_ival(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_fh *fh,
-				  struct v4l2_subdev_frame_interval_enum *fie)
-{
-	/*to fake*/
-	return 0;
-}
-
-static const struct v4l2_subdev_video_ops tpg_video_ops = {
-	.s_stream = tpg_s_stream,
-	.g_parm = tpg_g_parm,
-	.s_parm = tpg_s_parm,
-	.enum_framesizes = tpg_enum_framesizes,
-	.enum_frameintervals = tpg_enum_frameintervals,
-	.enum_mbus_fmt = tpg_enum_mbus_fmt,
-	.try_mbus_fmt = tpg_try_mbus_fmt,
-	.g_mbus_fmt = tpg_g_mbus_fmt,
-	.s_mbus_fmt = tpg_s_mbus_fmt,
-};
-
-static const struct v4l2_subdev_core_ops tpg_core_ops = {
-	.g_chip_ident = tpg_g_chip_ident,
-	.log_status = tpg_log_status,
-	.queryctrl = tpg_queryctrl,
-	.g_ctrl = tpg_g_ctrl,
-	.s_ctrl = tpg_s_ctrl,
-	.s_power = tpg_s_power,
-};
-
-static const struct v4l2_subdev_pad_ops tpg_pad_ops = {
-	.enum_mbus_code = tpg_enum_mbus_code,
-	.enum_frame_size = tpg_enum_frame_size,
-	.enum_frame_interval = tpg_enum_frame_ival,
-};
-
-static const struct v4l2_subdev_ops tpg_ops = {
-	.core = &tpg_core_ops,
-	.video = &tpg_video_ops,
-	.pad = &tpg_pad_ops,
-};
-
-void atomisp_tpg_unregister_entities(struct atomisp_tpg_device *tpg)
-{
-	media_entity_cleanup(&tpg->sd.entity);
-	v4l2_device_unregister_subdev(&tpg->sd);
-}
-
-int atomisp_tpg_register_entities(struct atomisp_tpg_device *tpg,
-			struct v4l2_device *vdev)
-{
-	int ret;
-	/* Register the subdev and video nodes. */
-	ret = v4l2_device_register_subdev(vdev, &tpg->sd);
-	if (ret < 0)
-		goto error;
-
-	return 0;
-
-error:
-	atomisp_tpg_unregister_entities(tpg);
-	return ret;
-}
-
-void atomisp_tpg_cleanup(struct atomisp_device *isp)
-{
-
-}
-
-int atomisp_tpg_init(struct atomisp_device *isp)
-{
-	struct atomisp_tpg_device *tpg = &isp->tpg;
-	struct v4l2_subdev *sd = &tpg->sd;
-	struct media_pad *pads = tpg->pads;
-	struct media_entity *me = &sd->entity;
-	int ret;
-
-	tpg->isp = isp;
-	v4l2_subdev_init(sd, &tpg_ops);
-	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	strcpy(sd->name, "tpg_subdev");
-	v4l2_set_subdevdata(sd, tpg);
-
-	pads[0].flags = MEDIA_PAD_FL_SINK;
-	me->type = MEDIA_ENT_T_V4L2_SUBDEV;
-
-	ret = media_entity_init(me, 1, pads, 0);
-	if (ret < 0)
-		goto fail;
-	return 0;
-fail:
-	atomisp_tpg_cleanup(isp);
-	return ret;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.h
deleted file mode 100644
index 64ab60f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_tpg.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __ATOMISP_TPG_H__
-#define __ATOMISP_TPG_H__
-
-#include <media/media-entity.h>
-#include <media/v4l2-subdev.h>
-
-struct atomisp_tpg_device {
-	struct v4l2_subdev sd;
-	struct atomisp_device *isp;
-	struct media_pad pads[1];
-};
-
-void atomisp_tpg_cleanup(struct atomisp_device *isp);
-int atomisp_tpg_init(struct atomisp_device *isp);
-void atomisp_tpg_unregister_entities(struct atomisp_tpg_device *tpg);
-int atomisp_tpg_register_entities(struct atomisp_tpg_device *tpg,
-			struct v4l2_device *vdev);
-
-#endif /* __ATOMISP_TPG_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_trace_event.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_trace_event.h
deleted file mode 100644
index 60c1845..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_trace_event.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Support Camera Imaging tracer core.
- *
- * Copyright (c) 2013 Intel Corporation. All Rights Reserved.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#undef TRACE_SYSTEM
-#define TRACE_SYSTEM atomisp
-
-#include <linux/tracepoint.h>
-#include <linux/string.h>
-TRACE_EVENT(camera_meminfo,
-
-	TP_PROTO(const char *name, int uptr_size, int counter, int sys_size,
-		int sys_res_size, int cam_sys_use, int cam_dyc_use,
-		int cam_res_use),
-
-	TP_ARGS(name, uptr_size, counter, sys_size, sys_res_size, cam_sys_use,
-		cam_dyc_use, cam_res_use),
-
-	TP_STRUCT__entry(
-		__array(char, name, 24)
-		__field(int, uptr_size)
-		__field(int, counter)
-		__field(int, sys_size)
-		__field(int, sys_res_size)
-		__field(int, cam_res_use)
-		__field(int, cam_dyc_use)
-		__field(int, cam_sys_use)
-	),
-
-	TP_fast_assign(
-		strlcpy(__entry->name, name, 24);
-		__entry->uptr_size = uptr_size;
-		__entry->counter = counter;
-		__entry->sys_size = sys_size;
-		__entry->sys_res_size = sys_res_size;
-		__entry->cam_res_use = cam_res_use;
-		__entry->cam_dyc_use = cam_dyc_use;
-		__entry->cam_sys_use = cam_sys_use;
-	),
-
-	TP_printk(
-		"<%s> User ptr memory:%d pages,\tISP private memory used:%d"
-		" pages:\tsysFP system size:%d,\treserved size:%d"
-		"\tcamFP sysUse:%d,\tdycUse:%d,\tresUse:%d.\n",
-		__entry->name, __entry->uptr_size, __entry->counter,
-		__entry->sys_size, __entry->sys_res_size, __entry->cam_sys_use,
-		__entry->cam_dyc_use, __entry->cam_res_use)
-);
-
-TRACE_EVENT(camera_debug,
-
-	TP_PROTO(const char *name, char *info, const int line),
-
-	TP_ARGS(name, info, line),
-
-	TP_STRUCT__entry(
-		__array(char, name, 24)
-		__array(char, info, 24)
-		__field(int, line)
-	),
-
-	TP_fast_assign(
-		strlcpy(__entry->name, name, 24);
-		strlcpy(__entry->info, info, 24);
-		__entry->line = line;
-	),
-
-	TP_printk("<%s>-<%d> %s\n", __entry->name, __entry->line,
-		__entry->info)
-);
-
-#undef TRACE_INCLUDE_PATH
-#undef TRACE_INCLUDE_FILE
-#define TRACE_INCLUDE_PATH (.)
-#define TRACE_INCLUDE_FILE   atomisp_trace_event
-/* This part must be outside protection */
-#include <trace/define_trace.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c
deleted file mode 100644
index f49cd12..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.c
+++ /dev/null
@@ -1,1492 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
-#include <linux/timer.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-
-#include <asm/intel-mid.h>
-
-#include "atomisp_cmd.h"
-#include "atomisp_common.h"
-#include "atomisp_fops.h"
-#include "atomisp_file.h"
-#include "atomisp_ioctl.h"
-#include "atomisp_internal.h"
-#include "atomisp_acc.h"
-#include "atomisp-regs.h"
-#include "hmm/hmm.h"
-
-#include "hrt/hive_isp_css_mm_hrt.h"
-
-#include "device_access.h"
-#include <linux/intel_mid_pm.h>
-#include <asm/intel-mid.h>
-
-#define ATOMISP_INTERNAL_PM	(IS_BYT || IS_MOFD)
-
-/* set reserved memory pool size in page */
-unsigned int repool_pgnr;
-module_param(repool_pgnr, uint, 0644);
-MODULE_PARM_DESC(repool_pgnr,
-		"Set the reserved memory pool size in page (default:0)");
-
-/* set dynamic memory pool size in page */
-unsigned int dypool_pgnr = UINT_MAX;
-module_param(dypool_pgnr, uint, 0644);
-MODULE_PARM_DESC(dypool_pgnr,
-		"Set the dynamic memory pool size in page (default:0)");
-
-bool dypool_enable;
-module_param(dypool_enable, bool, 0644);
-MODULE_PARM_DESC(dypool_enable,
-		"dynamic memory pool enable/disable (default:disable)");
-
-/* cross componnet debug message flag */
-int dbg_level;
-module_param(dbg_level, int, 0644);
-MODULE_PARM_DESC(dbg_level, "debug message on/off (default:off)");
-
-int mipicsi_flag;
-module_param(mipicsi_flag, int, 0644);
-MODULE_PARM_DESC(mipicsi_flag, "mipi csi compression predictor algorithm");
-
-/*set to 16x16 since this is the amount of lines and pixels the sensor
-exports extra. If these are kept at the 10x8 that they were on, in yuv
-downscaling modes incorrect resolutions where requested to the sensor
-driver with strange outcomes as a result. The proper way tot do this
-would be to have a list of tables the specify the sensor res, mipi rec,
-output res, and isp output res. however since we do not have this yet,
-the chosen solution is the next best thing. */
-int pad_w = 16;
-module_param(pad_w, int, 0644);
-MODULE_PARM_DESC(pad_w, "extra data for ISP processing");
-
-int pad_h = 16;
-module_param(pad_h, int, 0644);
-MODULE_PARM_DESC(pad_h, "extra data for ISP processing");
-
-struct device *atomisp_dev;
-
-void __iomem *atomisp_io_base;
-
-int atomisp_video_init(struct atomisp_video_pipe *video, const char *name)
-{
-	int ret;
-	const char *direction;
-
-	switch (video->type) {
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		direction = "output";
-		video->pad.flags = MEDIA_PAD_FL_SINK;
-		video->vdev.fops = &atomisp_fops;
-		video->vdev.ioctl_ops = &atomisp_ioctl_ops;
-		break;
-	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
-		direction = "input";
-		video->pad.flags = MEDIA_PAD_FL_SOURCE;
-		video->vdev.fops = &atomisp_file_fops;
-		video->vdev.ioctl_ops = &atomisp_file_ioctl_ops;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	ret = media_entity_init(&video->vdev.entity, 1, &video->pad, 0);
-	if (ret < 0)
-		return ret;
-
-	/* Initialize the video device. */
-	snprintf(video->vdev.name, sizeof(video->vdev.name),
-		 "ATOMISP ISP %s %s", name, direction);
-	video->vdev.release = video_device_release_empty;
-	video_set_drvdata(&video->vdev, video->isp);
-
-	return 0;
-}
-
-int atomisp_video_register(struct atomisp_video_pipe *video,
-	struct v4l2_device *vdev)
-{
-	int ret;
-
-	video->vdev.v4l2_dev = vdev;
-
-	ret = video_register_device(&video->vdev, VFL_TYPE_GRABBER, -1);
-	if (ret < 0)
-		dev_err(vdev->dev, "%s: could not register video device (%d)\n",
-			__func__, ret);
-
-	return ret;
-}
-
-void atomisp_video_unregister(struct atomisp_video_pipe *video)
-{
-	if (video_is_registered(&video->vdev)) {
-		media_entity_cleanup(&video->vdev.entity);
-		video_unregister_device(&video->vdev);
-	}
-}
-
-static int atomisp_save_iunit_reg(struct atomisp_device *isp)
-{
-	struct pci_dev *dev = isp->pdev;
-
-	dev_dbg(isp->dev, "%s\n", __func__);
-
-	pci_read_config_word(dev, PCI_COMMAND, &isp->saved_regs.pcicmdsts);
-	/* isp->saved_regs.ispmmadr is set from the atomisp_pci_probe() */
-	pci_read_config_dword(dev, PCI_MSI_CAPID, &isp->saved_regs.msicap);
-	pci_read_config_dword(dev, PCI_MSI_ADDR, &isp->saved_regs.msi_addr);
-	pci_read_config_word(dev, PCI_MSI_DATA,  &isp->saved_regs.msi_data);
-	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &isp->saved_regs.intr);
-	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL,
-			      &isp->saved_regs.interrupt_control);
-
-	if (IS_ISP24XX(isp)) {
-		pci_read_config_dword(dev, MRFLD_PCI_PMCS,
-				      &isp->saved_regs.pmcs);
-		/* Ensure read/write combining is enabled. */
-		pci_read_config_dword(dev, PCI_I_CONTROL,
-				&isp->saved_regs.i_control);
-		isp->saved_regs.i_control |=
-				MRFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
-				MRFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,
-				      &isp->saved_regs.csi_access_viol);
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_RCOMP_CONTROL,
-				      &isp->saved_regs.csi_rcomp_config);
-		/*
-		 * Hardware bugs require setting CSI_HS_OVR_CLK_GATE_ON_UPDATE.
-		 * ANN/CHV: RCOMP updates do not happen when using CSI2+ path
-		 * and sensor sending "continuous clock".
-		 * TNG/ANN/CHV: MIPI packets are lost if the HS entry sequence
-		 * is missed, and IUNIT can hang.
-		 * For both issues, setting this bit is a workaround.
-		 */
-		isp->saved_regs.csi_rcomp_config |=
-			MRFLD_PCI_CSI_HS_OVR_CLK_GATE_ON_UPDATE;
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
-				      &isp->saved_regs.csi_afe_dly);
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_CONTROL,
-				      &isp->saved_regs.csi_control);
-		if (isp->media_dev.hw_revision >=
-		    ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT)
-			isp->saved_regs.csi_control |=
-				MRFLD_PCI_CSI_CONTROL_PARPATHEN;
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
-				      &isp->saved_regs.csi_afe_rcomp_config);
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_HS_CONTROL,
-				      &isp->saved_regs.csi_afe_hs_control);
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_DEADLINE_CONTROL,
-				      &isp->saved_regs.csi_deadline_control);
-	} else {
-		pci_read_config_dword(dev, MFLD_PCI_PMCS,
-				      &isp->saved_regs.pmcs);
-
-		/* Ensure clock gating for ISPCLK, PERF and NOA monitoring. */
-		pci_read_config_dword(dev, MFLD_PCI_CG_DIS,
-				      &isp->saved_regs.cg_dis);
-		isp->saved_regs.cg_dis &= ~(MFLD_PCI_CG_DIS_DISABLED_ISPCLK |
-				MFLD_PCI_CG_DIS_DISABLED_PERF_MON |
-				MFLD_PCI_CG_DIS_DISABLED_NOA_MON);
-
-		/* Ensure read/write combining is enabled. */
-		pci_read_config_dword(dev, PCI_I_CONTROL,
-				&isp->saved_regs.i_control);
-		isp->saved_regs.i_control |=
-				MFLD_PCI_I_CONTROL_ENABLE_READ_COMBINING |
-				MFLD_PCI_I_CONTROL_ENABLE_WRITE_COMBINING;
-
-		isp->saved_regs.csi_rcomp_config = intel_mid_msgbus_read32(
-				MFLD_IUNITPHY_PORT, MFLD_CSI_RCOMP);
-		isp->saved_regs.csi_afe_dly = intel_mid_msgbus_read32(
-				MFLD_IUNITPHY_PORT, MFLD_CSI_AFE);
-
-		/* Ensure mipi1 and mipi4 configurations are enabled */
-		isp->saved_regs.csi_control = intel_mid_msgbus_read32(
-				MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL);
-		isp->saved_regs.csi_control &= ~(MFLD_CSI_CONTROL_DIS_MIPI4_IF |
-				MFLD_CSI_CONTROL_DIS_MIPI1_IF);
-		isp->saved_regs.csi_control |= MFLD_CSI_CONTROL_EN_MIPI4_LANE |
-				MFLD_CSI_CONTROL_EN_MIPI1_LANE;
-	}
-
-	return 0;
-}
-
-static int atomisp_restore_iunit_reg(struct atomisp_device *isp)
-{
-	struct pci_dev *dev = isp->pdev;
-
-	dev_dbg(isp->dev, "%s\n", __func__);
-
-	pci_write_config_word(dev, PCI_COMMAND, isp->saved_regs.pcicmdsts);
-	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0,
-			       isp->saved_regs.ispmmadr);
-	pci_write_config_dword(dev, PCI_MSI_CAPID, isp->saved_regs.msicap);
-	pci_write_config_dword(dev, PCI_MSI_ADDR, isp->saved_regs.msi_addr);
-	pci_write_config_word(dev, PCI_MSI_DATA, isp->saved_regs.msi_data);
-	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, isp->saved_regs.intr);
-	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL,
-			       isp->saved_regs.interrupt_control);
-	pci_write_config_dword(dev, PCI_I_CONTROL,
-					isp->saved_regs.i_control);
-
-	if (IS_ISP24XX(isp)) {
-		pci_write_config_dword(dev, MRFLD_PCI_PMCS,
-						isp->saved_regs.pmcs);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_ACCESS_CTRL_VIOL,
-				      isp->saved_regs.csi_access_viol);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_RCOMP_CONTROL,
-				      isp->saved_regs.csi_rcomp_config);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
-				      isp->saved_regs.csi_afe_dly);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_CONTROL,
-				      isp->saved_regs.csi_control);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_RCOMP_CONTROL,
-				      isp->saved_regs.csi_afe_rcomp_config);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_HS_CONTROL,
-				      isp->saved_regs.csi_afe_hs_control);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_DEADLINE_CONTROL,
-				      isp->saved_regs.csi_deadline_control);
-
-		/*
-		 * for MRFLD, Software/firmware needs to write a 1 to bit0
-		 * of the register at CSI_RECEIVER_SELECTION_REG to enable
-		 * SH CSI backend write 0 will enable Arasan CSI backend,
-		 * which has bugs(like sighting:4567697 and 4567699) and
-		 * will be removed in B0
-		 */
-		atomisp_store_uint32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);
-
-	} else {
-		pci_write_config_dword(dev, MFLD_PCI_PMCS,
-				       isp->saved_regs.pmcs);
-		pci_write_config_dword(dev, MFLD_PCI_CG_DIS,
-						isp->saved_regs.cg_dis);
-		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_RCOMP,
-				    isp->saved_regs.csi_rcomp_config);
-		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_AFE,
-				    isp->saved_regs.csi_afe_dly);
-		intel_mid_msgbus_write32(MFLD_IUNITPHY_PORT, MFLD_CSI_CONTROL,
-				    isp->saved_regs.csi_control);
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int atomisp_mrfld_pre_power_down(struct atomisp_device *isp)
-{
-	struct pci_dev *dev = isp->pdev;
-	u32 irq;
-	unsigned long flags;
-
-	spin_lock_irqsave(&isp->lock, flags);
-	if (isp->sw_contex.power_state == ATOM_ISP_POWER_DOWN) {
-		spin_unlock_irqrestore(&isp->lock, flags);
-		dev_dbg(isp->dev, "<%s %d.\n", __func__, __LINE__);
-		return 0;
-	}
-	/*
-	 * MRFLD HAS requirement: cannot power off i-unit if
-	 * ISP has IRQ not serviced.
-	 * So, here we need to check if there is any pending
-	 * IRQ, if so, waiting for it to be served
-	 */
-	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
-	irq = irq & 1 << INTR_IIR;
-	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, irq);
-
-	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
-	if (!(irq & (1 << INTR_IIR)))
-		goto done;
-
-	atomisp_store_uint32(MRFLD_INTR_CLEAR_REG, 0xFFFFFFFF);
-	atomisp_load_uint32(MRFLD_INTR_STATUS_REG, &irq);
-	if (irq != 0) {
-		dev_err(isp->dev,
-			 "%s: fail to clear isp interrupt status reg=0x%x\n",
-			 __func__, irq);
-		spin_unlock_irqrestore(&isp->lock, flags);
-		return -EAGAIN;
-	} else {
-		pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
-		irq = irq & 1 << INTR_IIR;
-		pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, irq);
-
-		pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
-		if (!(irq & (1 << INTR_IIR))) {
-			atomisp_store_uint32(MRFLD_INTR_ENABLE_REG, 0x0);
-			goto done;
-		}
-		dev_err(isp->dev,
-			 "%s: error in iunit interrupt. status reg=0x%x\n",
-			 __func__, irq);
-		spin_unlock_irqrestore(&isp->lock, flags);
-		return -EAGAIN;
-	}
-done:
-	/*
-	* MRFLD WORKAROUND:
-	* before powering off IUNIT, clear the pending interrupts
-	* and disable the interrupt. driver should avoid writing 0
-	* to IIR. It could block subsequent interrupt messages.
-	* HW sighting:4568410.
-	*/
-	pci_read_config_dword(dev, PCI_INTERRUPT_CTRL, &irq);
-	irq &= ~(1 << INTR_IER);
-	pci_write_config_dword(dev, PCI_INTERRUPT_CTRL, irq);
-
-	atomisp_msi_irq_uninit(isp, dev);
-	atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	return 0;
-}
-
-/* Workaround for pmu_nc_set_power_state not ready in MRFLD */
-static int atomisp_mrfld_power_down(struct atomisp_device *isp)
-{
-	unsigned long timeout;
-	u32 reg_value;
-
-	/* writing 0x3 to ISPSSPM0 bit[1:0] to power off the IUNIT */
-	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
-	reg_value &= ~MRFLD_ISPSSPM0_ISPSSC_MASK;
-	reg_value |= MRFLD_ISPSSPM0_IUNIT_POWER_OFF;
-	intel_mid_msgbus_write32(PUNIT_PORT, MRFLD_ISPSSPM0, reg_value);
-
-	/*
-	 * There should be no iunit access while power-down is
-	 * in progress HW sighting: 4567865
-	 * FIXME: msecs_to_jiffies(50)- experienced value
-	 */
-	timeout = jiffies + msecs_to_jiffies(50);
-	while (1) {
-		reg_value = intel_mid_msgbus_read32(PUNIT_PORT,
-							MRFLD_ISPSSPM0);
-		dev_dbg(isp->dev, "power-off in progress, ISPSSPM0: 0x%x\n",
-				reg_value);
-		/* wait until ISPSSPM0 bit[25:24] shows 0x3 */
-		if ((reg_value >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) ==
-			MRFLD_ISPSSPM0_IUNIT_POWER_OFF)
-			return 0;
-
-		if (time_after(jiffies, timeout)) {
-			dev_err(isp->dev, "power-off iunit timeout.\n");
-			return -EBUSY;
-		}
-		/* FIXME: experienced value for delay */
-		usleep_range(100, 150);
-	};
-}
-
-
-/* Workaround for pmu_nc_set_power_state not ready in MRFLD */
-static int atomisp_mrfld_power_up(struct atomisp_device *isp)
-{
-	unsigned long timeout;
-	u32 reg_value;
-
-	/* writing 0x0 to ISPSSPM0 bit[1:0] to power off the IUNIT */
-	reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
-	reg_value &= ~MRFLD_ISPSSPM0_ISPSSC_MASK;
-	intel_mid_msgbus_write32(PUNIT_PORT, MRFLD_ISPSSPM0, reg_value);
-
-	/* FIXME: experienced value for delay */
-	timeout = jiffies + msecs_to_jiffies(50);
-	while (1) {
-		reg_value = intel_mid_msgbus_read32(PUNIT_PORT, MRFLD_ISPSSPM0);
-		dev_dbg(isp->dev, "power-on in progress, ISPSSPM0: 0x%x\n",
-				reg_value);
-		/* wait until ISPSSPM0 bit[25:24] shows 0x0 */
-		if ((reg_value >> MRFLD_ISPSSPM0_ISPSSS_OFFSET) ==
-			MRFLD_ISPSSPM0_IUNIT_POWER_ON)
-			return 0;
-
-		if (time_after(jiffies, timeout)) {
-			dev_err(isp->dev, "power-on iunit timeout.\n");
-			return -EBUSY;
-		}
-		/* FIXME: experienced value for delay */
-		usleep_range(100, 150);
-	};
-}
-
-static int atomisp_runtime_suspend(struct device *dev)
-{
-	struct atomisp_device *isp = (struct atomisp_device *)
-		dev_get_drvdata(dev);
-	int ret;
-
-	if (IS_ISP24XX(isp)) {
-		ret = atomisp_mrfld_pre_power_down(isp);
-		if (ret)
-			return ret;
-	}
-
-	/*Turn off the ISP d-phy*/
-	ret = atomisp_ospm_dphy_down(isp);
-	if (ret)
-		return ret;
-	pm_qos_update_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);
-	if (ATOMISP_INTERNAL_PM)
-		ret = atomisp_mrfld_power_down(isp);
-
-	return ret;
-}
-
-static int atomisp_runtime_resume(struct device *dev)
-{
-	struct atomisp_device *isp = (struct atomisp_device *)
-		dev_get_drvdata(dev);
-	int ret;
-
-	if (ATOMISP_INTERNAL_PM) {
-		ret = atomisp_mrfld_power_up(isp);
-		if (ret)
-			return ret;
-	}
-
-	pm_qos_update_request(&isp->pm_qos, isp->max_isr_latency);
-	if (isp->sw_contex.power_state == ATOM_ISP_POWER_DOWN) {
-		/*Turn on ISP d-phy */
-		ret = atomisp_ospm_dphy_up(isp);
-		if (ret) {
-			dev_err(isp->dev, "Failed to power up ISP!.\n");
-			return -EINVAL;
-		}
-	}
-
-	/*restore register values for iUnit and iUnitPHY registers*/
-	if (isp->saved_regs.pcicmdsts)
-		atomisp_restore_iunit_reg(isp);
-
-	if (IS_ISP24XX(isp))
-		atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
-
-	return 0;
-}
-
-static int atomisp_suspend(struct device *dev)
-{
-	struct atomisp_device *isp = (struct atomisp_device *)
-		dev_get_drvdata(dev);
-	/* FIXME: only has one isp_subdev at present */
-	struct atomisp_sub_device *asd = &isp->asd[0];
-	unsigned long flags;
-	int ret;
-
-	/*
-	 * FIXME: Suspend is not supported by sensors. Abort if any video
-	 * node was opened.
-	 */
-	if (atomisp_dev_users(isp))
-		return -EBUSY;
-
-	spin_lock_irqsave(&isp->lock, flags);
-	if (asd->streaming != ATOMISP_DEVICE_STREAMING_DISABLED) {
-		spin_unlock_irqrestore(&isp->lock, flags);
-		dev_err(isp->dev, "atomisp cannot suspend at this time.\n");
-		return -EINVAL;
-	}
-	spin_unlock_irqrestore(&isp->lock, flags);
-
-	/* Prepare for MRFLD IUNIT power down */
-	if (IS_ISP24XX(isp)) {
-		ret = atomisp_mrfld_pre_power_down(isp);
-		if (ret)
-			return ret;
-	}
-
-	/*Turn off the ISP d-phy */
-	ret = atomisp_ospm_dphy_down(isp);
-	if (ret) {
-		dev_err(isp->dev, "fail to power off ISP\n");
-		return ret;
-	}
-	pm_qos_update_request(&isp->pm_qos, PM_QOS_DEFAULT_VALUE);
-	if (ATOMISP_INTERNAL_PM)
-		ret = atomisp_mrfld_power_down(isp);
-
-	return ret;
-}
-
-static int atomisp_resume(struct device *dev)
-{
-	struct atomisp_device *isp = (struct atomisp_device *)
-		dev_get_drvdata(dev);
-	int ret;
-
-	if (ATOMISP_INTERNAL_PM) {
-		ret = atomisp_mrfld_power_up(isp);
-		if (ret)
-			return ret;
-	}
-
-	pm_qos_update_request(&isp->pm_qos, isp->max_isr_latency);
-
-	/*Turn on ISP d-phy */
-	ret = atomisp_ospm_dphy_up(isp);
-	if (ret) {
-		dev_err(isp->dev, "Failed to power up ISP!.\n");
-		return -EINVAL;
-	}
-
-	/*restore register values for iUnit and iUnitPHY registers*/
-	if (isp->saved_regs.pcicmdsts)
-		atomisp_restore_iunit_reg(isp);
-
-	if (IS_ISP24XX(isp))
-		atomisp_freq_scaling(isp, ATOMISP_DFS_MODE_LOW);
-
-	return 0;
-}
-#endif
-
-static int atomisp_csi_lane_config(struct atomisp_device *isp)
-{
-	static const struct {
-		u8 code;
-		u8 lanes[MRFLD_PORT_NUM];
-	} portconfigs[] = {
-		/* Tangier/Merrifield available lane configurations */
-		{ 0x00, { 4, 1, 0 } },		/* 00000 */
-		{ 0x01, { 3, 1, 0 } },		/* 00001 */
-		{ 0x02, { 2, 1, 0 } },		/* 00010 */
-		{ 0x03, { 1, 1, 0 } },		/* 00011 */
-		{ 0x04, { 2, 1, 2 } },		/* 00100 */
-		{ 0x08, { 3, 1, 1 } },		/* 01000 */
-		{ 0x09, { 2, 1, 1 } },		/* 01001 */
-		{ 0x0a, { 1, 1, 1 } },		/* 01010 */
-
-		/* Anniedale/Moorefield only configurations */
-		{ 0x10, { 4, 2, 0 } },		/* 10000 */
-		{ 0x11, { 3, 2, 0 } },		/* 10001 */
-		{ 0x12, { 2, 2, 0 } },		/* 10010 */
-		{ 0x13, { 1, 2, 0 } },		/* 10011 */
-		{ 0x14, { 2, 2, 2 } },		/* 10100 */
-		{ 0x18, { 3, 2, 1 } },		/* 11000 */
-		{ 0x19, { 2, 2, 1 } },		/* 11001 */
-		{ 0x1a, { 1, 2, 1 } },		/* 11010 */
-	};
-
-	unsigned int i, j;
-	u8 sensor_lanes[MRFLD_PORT_NUM] = { 0 };
-	u32 csi_control;
-	int nportconfigs;
-	u32 port_config_mask;
-	int port3_lanes_shift;
-
-	if (isp->media_dev.hw_revision <
-		ATOMISP_HW_REVISION_ISP2401_LEGACY <<
-		ATOMISP_HW_REVISION_SHIFT) {
-		/* Merrifield */
-		port_config_mask = MRFLD_PORT_CONFIG_MASK;
-		port3_lanes_shift = MRFLD_PORT3_LANES_SHIFT;
-	} else {
-		/* Moorefield / Cherryview */
-		port_config_mask = CHV_PORT_CONFIG_MASK;
-		port3_lanes_shift = CHV_PORT3_LANES_SHIFT;
-	}
-
-	if (isp->media_dev.hw_revision <
-		ATOMISP_HW_REVISION_ISP2401 <<
-		ATOMISP_HW_REVISION_SHIFT) {
-		/* Merrifield / Moorefield legacy input system */
-		nportconfigs = MRFLD_PORT_CONFIG_NUM;
-	} else {
-		/* Moorefield / Cherryview new input system */
-		nportconfigs = ARRAY_SIZE(portconfigs);
-	}
-
-	for (i = 0; i < isp->input_cnt; i++) {
-		struct camera_mipi_info *mipi_info;
-
-		if (isp->inputs[i].type != RAW_CAMERA &&
-		    isp->inputs[i].type != SOC_CAMERA)
-			continue;
-
-		mipi_info = atomisp_to_sensor_mipi_info(isp->inputs[i].camera);
-		if (!mipi_info)
-			continue;
-
-		switch (mipi_info->port) {
-		case ATOMISP_CAMERA_PORT_PRIMARY:
-			sensor_lanes[0] = mipi_info->num_lanes;
-			break;
-		case ATOMISP_CAMERA_PORT_SECONDARY:
-			sensor_lanes[1] = mipi_info->num_lanes;
-			break;
-		case ATOMISP_CAMERA_PORT_TERTIARY:
-			sensor_lanes[2] = mipi_info->num_lanes;
-			break;
-		default:
-			dev_err(isp->dev,
-				"%s: invalid port: %d for the %dth sensor\n",
-				__func__, mipi_info->port, i);
-			return -EINVAL;
-		}
-	}
-
-	for (i = 0; i < nportconfigs; i++) {
-		for (j = 0; j < MRFLD_PORT_NUM; j++)
-			if (sensor_lanes[j] &&
-			    sensor_lanes[j] != portconfigs[i].lanes[j])
-				break;
-
-		if (j == MRFLD_PORT_NUM)
-			break;			/* Found matching setting */
-	}
-
-	if (i >= nportconfigs) {
-		dev_err(isp->dev,
-			"%s: could not find the CSI port setting for %d-%d-%d\n",
-			__func__,
-			sensor_lanes[0], sensor_lanes[1], sensor_lanes[2]);
-		return -EINVAL;
-	}
-
-	pci_read_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, &csi_control);
-	csi_control &= ~port_config_mask;
-	csi_control |= (portconfigs[i].code << MRFLD_PORT_CONFIGCODE_SHIFT)
-		| (portconfigs[i].lanes[0] ? 0 : (1 << MRFLD_PORT1_ENABLE_SHIFT))
-		| (portconfigs[i].lanes[1] ? 0 : (1 << MRFLD_PORT2_ENABLE_SHIFT))
-		| (portconfigs[i].lanes[2] ? 0 : (1 << MRFLD_PORT3_ENABLE_SHIFT))
-		| (((1 << portconfigs[i].lanes[0]) - 1) << MRFLD_PORT1_LANES_SHIFT)
-		| (((1 << portconfigs[i].lanes[1]) - 1) << MRFLD_PORT2_LANES_SHIFT)
-		| (((1 << portconfigs[i].lanes[2]) - 1) << port3_lanes_shift);
-
-	pci_write_config_dword(isp->pdev, MRFLD_PCI_CSI_CONTROL, csi_control);
-
-	dev_dbg(isp->dev,
-		"%s: the portconfig is %d-%d-%d, CSI_CONTROL is 0x%08X\n",
-		__func__, portconfigs[i].lanes[0], portconfigs[i].lanes[1],
-		portconfigs[i].lanes[2], csi_control);
-
-	return 0;
-}
-
-static int atomisp_subdev_probe(struct atomisp_device *isp)
-{
-	const struct atomisp_platform_data *pdata;
-	struct intel_v4l2_subdev_table *subdevs;
-	int raw_index = -1;
-
-	pdata = atomisp_get_platform_data();
-	if (pdata == NULL) {
-		dev_err(isp->dev, "no platform data available\n");
-		return 0;
-	}
-
-	for (subdevs = pdata->subdevs; subdevs->type; ++subdevs) {
-		struct v4l2_subdev *subdev;
-		struct i2c_board_info *board_info =
-			&subdevs->v4l2_subdev.board_info;
-		struct i2c_adapter *adapter =
-			i2c_get_adapter(subdevs->v4l2_subdev.i2c_adapter_id);
-		struct camera_sensor_platform_data *sensor_pdata;
-
-		if (adapter == NULL) {
-			dev_err(isp->dev,
-				"Failed to find i2c adapter for subdev %s\n",
-				board_info->type);
-			break;
-		}
-
-		subdev = v4l2_i2c_new_subdev_board(&isp->v4l2_dev, adapter,
-				board_info, NULL);
-
-		if (subdev == NULL) {
-			dev_warn(isp->dev, "Subdev %s detection fail\n",
-				 board_info->type);
-			continue;
-		}
-
-		dev_info(isp->dev, "Subdev %s successfully register\n",
-			 board_info->type);
-
-		switch (subdevs->type) {
-		case RAW_CAMERA:
-			raw_index = isp->input_cnt;
-			dev_dbg(isp->dev, "raw_index: %d\n", raw_index);
-		case SOC_CAMERA:
-			dev_dbg(isp->dev, "SOC_INDEX: %d\n", isp->input_cnt);
-			if (isp->input_cnt >= ATOM_ISP_MAX_INPUTS) {
-				dev_warn(isp->dev,
-					 "too many atomisp inputs, ignored\n");
-				break;
-			}
-
-			isp->inputs[isp->input_cnt].type = subdevs->type;
-			isp->inputs[isp->input_cnt].port = subdevs->port;
-			isp->inputs[isp->input_cnt].camera = subdev;
-			isp->inputs[isp->input_cnt].shading_table = NULL;
-			isp->inputs[isp->input_cnt].morph_table = NULL;
-			/*
-			 * initialize the subdev frame size, then next we can
-			 * judge whether frame_size store effective value via
-			 * pixel_format.
-			 */
-			isp->inputs[isp->input_cnt].frame_size.pixel_format = 0;
-			sensor_pdata = (struct camera_sensor_platform_data *)
-					board_info->platform_data;
-			if (sensor_pdata->get_camera_caps)
-				isp->inputs[isp->input_cnt].camera_caps =
-					sensor_pdata->get_camera_caps();
-			else
-				isp->inputs[isp->input_cnt].camera_caps =
-					atomisp_get_default_camera_caps();
-			isp->input_cnt++;
-			break;
-		case CAMERA_MOTOR:
-			isp->motor = subdev;
-			break;
-		case LED_FLASH:
-		case XENON_FLASH:
-			isp->flash = subdev;
-			break;
-		default:
-			dev_dbg(isp->dev, "unknown subdev probed\n");
-			break;
-		}
-
-	}
-
-	/*
-	 * HACK: Currently VCM belongs to primary sensor only, but correct
-	 * approach must be to acquire from platform code which sensor
-	 * owns it.
-	 */
-	if (isp->motor && raw_index >= 0)
-		isp->inputs[raw_index].motor = isp->motor;
-
-	/* Proceed even if no modules detected. For COS mode and no modules. */
-	if (!isp->inputs[0].camera)
-		dev_warn(isp->dev, "no camera attached or fail to detect\n");
-
-	if (IS_ISP24XX(isp))
-		return atomisp_csi_lane_config(isp);
-
-	return 0;
-}
-
-static void atomisp_unregister_entities(struct atomisp_device *isp)
-{
-	unsigned int i;
-
-	for (i = 0; i < isp->num_of_streams; i++)
-		atomisp_subdev_unregister_entities(&isp->asd[i]);
-	atomisp_tpg_unregister_entities(&isp->tpg);
-	atomisp_file_input_unregister_entities(&isp->file_dev);
-	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)
-		atomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);
-
-	v4l2_device_unregister(&isp->v4l2_dev);
-	media_device_unregister(&isp->media_dev);
-}
-
-static int atomisp_register_entities(struct atomisp_device *isp)
-{
-	int ret = 0;
-	unsigned int i;
-
-	isp->media_dev.dev = isp->dev;
-
-	strlcpy(isp->media_dev.model, "Intel Atom ISP",
-		sizeof(isp->media_dev.model));
-
-	ret = media_device_register(&isp->media_dev);
-	if (ret < 0) {
-		dev_err(isp->dev, "%s: Media device registration failed (%d)\n",
-				__func__, ret);
-		return ret;
-	}
-
-	isp->v4l2_dev.mdev = &isp->media_dev;
-	ret = v4l2_device_register(isp->dev, &isp->v4l2_dev);
-	if (ret < 0) {
-		dev_err(isp->dev, "%s: V4L2 device registration failed (%d)\n",
-			__func__, ret);
-		goto v4l2_device_failed;
-	}
-
-	ret = atomisp_subdev_probe(isp);
-	if (ret < 0)
-		goto csi_and_subdev_probe_failed;
-
-	/* Register internal entities */
-	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
-		ret = atomisp_mipi_csi2_register_entities(&isp->csi2_port[i],
-								&isp->v4l2_dev);
-		if (ret == 0)
-			continue;
-
-		/* error case */
-		dev_err(isp->dev, "failed to register the CSI port: %d\n", i);
-		/* deregister all registered CSI ports */
-		while (i--)
-			atomisp_mipi_csi2_unregister_entities(
-							&isp->csi2_port[i]);
-
-		goto csi_and_subdev_probe_failed;
-	}
-
-	ret =
-	atomisp_file_input_register_entities(&isp->file_dev, &isp->v4l2_dev);
-	if (ret < 0) {
-		dev_err(isp->dev, "atomisp_file_input_register_entities\n");
-		goto file_input_register_failed;
-	}
-
-	ret = atomisp_tpg_register_entities(&isp->tpg, &isp->v4l2_dev);
-	if (ret < 0) {
-		dev_err(isp->dev, "atomisp_tpg_register_entities\n");
-		goto tpg_register_failed;
-	}
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		struct atomisp_sub_device *asd = &isp->asd[i];
-
-		ret = atomisp_subdev_register_entities(asd, &isp->v4l2_dev);
-		if (ret < 0) {
-			dev_err(isp->dev,
-				"atomisp_subdev_register_entities fail\n");
-			for (; i > 0; i--)
-				atomisp_subdev_unregister_entities(
-						&isp->asd[i - 1]);
-			goto subdev_register_failed;
-		}
-	}
-
-	for (i = 0; i < isp->num_of_streams; i++) {
-		struct atomisp_sub_device *asd = &isp->asd[i];
-
-		init_completion(&asd->init_done);
-
-		asd->delayed_init_workq =
-			alloc_workqueue(isp->v4l2_dev.name, WQ_CPU_INTENSIVE,
-					1);
-		if (asd->delayed_init_workq == NULL) {
-			dev_err(isp->dev,
-					"Failed to initialize delayed init workq\n");
-			ret = -ENOMEM;
-
-			for (; i > 0; i--)
-				destroy_workqueue(isp->asd[i - 1].
-						delayed_init_workq);
-			goto wq_alloc_failed;
-		}
-		INIT_WORK(&asd->delayed_init_work, atomisp_delayed_init_work);
-	}
-
-	for (i = 0; i < isp->input_cnt; i++) {
-		if (isp->inputs[i].port >= ATOMISP_CAMERA_NR_PORTS) {
-			dev_err(isp->dev, "isp->inputs port %d not supported\n",
-					isp->inputs[i].port);
-			ret = -EINVAL;
-			goto link_failed;
-		}
-
-		ret = media_entity_create_link(
-			&isp->inputs[i].camera->entity, 0,
-			&isp->csi2_port[isp->inputs[i].port].subdev.entity,
-			CSI2_PAD_SINK,
-			MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);
-		if (ret < 0) {
-			dev_err(isp->dev,
-				"link create from sensor to csi-2 receiver failed\n");
-			goto link_failed;
-		}
-	}
-
-	dev_dbg(isp->dev,
-		"FILE_INPUT enable, camera_cnt: %d\n", isp->input_cnt);
-	isp->inputs[isp->input_cnt].type = FILE_INPUT;
-	isp->inputs[isp->input_cnt].port = -1;
-	isp->inputs[isp->input_cnt].shading_table = NULL;
-	isp->inputs[isp->input_cnt].morph_table = NULL;
-	isp->inputs[isp->input_cnt].camera_caps =
-		    atomisp_get_default_camera_caps();
-	isp->inputs[isp->input_cnt++].camera = &isp->file_dev.sd;
-
-	if (isp->input_cnt < ATOM_ISP_MAX_INPUTS) {
-		dev_dbg(isp->dev,
-			"TPG detected, camera_cnt: %d\n", isp->input_cnt);
-		isp->inputs[isp->input_cnt].type = TEST_PATTERN;
-		isp->inputs[isp->input_cnt].port = -1;
-		isp->inputs[isp->input_cnt].shading_table = NULL;
-		isp->inputs[isp->input_cnt].morph_table = NULL;
-		isp->inputs[isp->input_cnt].camera_caps =
-		    atomisp_get_default_camera_caps();
-		isp->inputs[isp->input_cnt++].camera = &isp->tpg.sd;
-	} else {
-		dev_warn(isp->dev, "too many atomisp inputs, TPG ignored.\n");
-	}
-
-	ret = v4l2_device_register_subdev_nodes(&isp->v4l2_dev);
-	if (ret < 0)
-		goto link_failed;
-
-	return ret;
-
-link_failed:
-	for (i = 0; i < isp->num_of_streams; i++)
-		destroy_workqueue(isp->asd[i].
-				delayed_init_workq);
-wq_alloc_failed:
-	for (i = 0; i < isp->num_of_streams; i++)
-		atomisp_subdev_unregister_entities(
-					&isp->asd[i]);
-subdev_register_failed:
-	atomisp_tpg_unregister_entities(&isp->tpg);
-tpg_register_failed:
-	atomisp_file_input_unregister_entities(&isp->file_dev);
-file_input_register_failed:
-	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++)
-		atomisp_mipi_csi2_unregister_entities(&isp->csi2_port[i]);
-csi_and_subdev_probe_failed:
-	v4l2_device_unregister(&isp->v4l2_dev);
-v4l2_device_failed:
-	media_device_unregister(&isp->media_dev);
-	return ret;
-}
-
-static int atomisp_initialize_modules(struct atomisp_device *isp)
-{
-	int ret;
-	unsigned int i, j;
-
-	ret = atomisp_mipi_csi2_init(isp);
-	if (ret < 0) {
-		dev_err(isp->dev, "mipi csi2 initialization failed\n");
-		goto error_mipi_csi2;
-	}
-
-	ret = atomisp_file_input_init(isp);
-	if (ret < 0) {
-		dev_err(isp->dev,
-			"file input device initialization failed\n");
-		goto error_file_input;
-	}
-
-	ret = atomisp_tpg_init(isp);
-	if (ret < 0) {
-		dev_err(isp->dev, "tpg initialization failed\n");
-		goto error_tpg;
-	}
-
-	ret = atomisp_subdev_init(isp);
-	if (ret < 0) {
-		dev_err(isp->dev, "ISP subdev initialization failed\n");
-		goto error_isp_subdev;
-	}
-
-	/* connet submoduels */
-	for (i = 0; i < ATOMISP_CAMERA_NR_PORTS; i++) {
-		for (j = 0; j < isp->num_of_streams; j++) {
-			ret = media_entity_create_link(
-				&isp->csi2_port[i].subdev.entity,
-				CSI2_PAD_SOURCE,
-				&isp->asd[j].subdev.entity,
-				ATOMISP_SUBDEV_PAD_SINK,
-				0);
-			if (ret < 0)
-				goto error_link;
-		}
-	}
-	return 0;
-
-error_link:
-error_isp_subdev:
-error_tpg:
-	atomisp_tpg_cleanup(isp);
-error_file_input:
-	atomisp_file_input_cleanup(isp);
-error_mipi_csi2:
-	atomisp_mipi_csi2_cleanup(isp);
-	return ret;
-}
-
-static const struct firmware *
-load_firmware(struct atomisp_device *isp)
-{
-	const struct firmware *fw;
-	int rc;
-	char *fw_path = NULL;
-
-#if defined(ATOMISP_FWNAME)
-	fw_path = ATOMISP_FWNAME;
-#else
-	if (isp->media_dev.driver_version == ATOMISP_CSS_VERSION_21) {
-		if (isp->media_dev.hw_revision ==
-		    ((ATOMISP_HW_REVISION_ISP2400 << ATOMISP_HW_REVISION_SHIFT)
-		     | ATOMISP_HW_STEPPING_A0))
-			fw_path = "shisp_2400a0_v21.bin";
-
-		if (isp->media_dev.hw_revision ==
-		    ((ATOMISP_HW_REVISION_ISP2401 << ATOMISP_HW_REVISION_SHIFT)
-		     | ATOMISP_HW_STEPPING_A0))
-			fw_path = "shisp_2401a0_v21.bin";
-
-		if (isp->media_dev.hw_revision ==
-		    ((ATOMISP_HW_REVISION_ISP2401_LEGACY << ATOMISP_HW_REVISION_SHIFT)
-		     | ATOMISP_HW_STEPPING_A0))
-			fw_path = "shisp_2401a0_legacy_v21.bin";
-
-		if (isp->media_dev.hw_revision ==
-		    ((ATOMISP_HW_REVISION_ISP2400 << ATOMISP_HW_REVISION_SHIFT)
-		     | ATOMISP_HW_STEPPING_B0))
-			fw_path = "shisp_2400b0_v21.bin";
-	} else if (isp->media_dev.driver_version == ATOMISP_CSS_VERSION_20) {
-		if (isp->media_dev.hw_revision ==
-		    ((ATOMISP_HW_REVISION_ISP2400 << ATOMISP_HW_REVISION_SHIFT)
-		     | ATOMISP_HW_STEPPING_A0))
-			fw_path = "shisp_2400_cssv2.bin";
-
-		if (isp->media_dev.hw_revision ==
-		    ((ATOMISP_HW_REVISION_ISP2400 << ATOMISP_HW_REVISION_SHIFT)
-		     | ATOMISP_HW_STEPPING_B0))
-			fw_path = "shisp_2400b0_cssv2.bin";
-	} else if (isp->media_dev.driver_version == ATOMISP_CSS_VERSION_15) {
-		if (isp->media_dev.hw_revision ==
-		    ((ATOMISP_HW_REVISION_ISP2400 << ATOMISP_HW_REVISION_SHIFT)
-		     | ATOMISP_HW_STEPPING_A0))
-			fw_path = "shisp_2400.bin";
-
-		if ((isp->media_dev.hw_revision >> ATOMISP_HW_REVISION_SHIFT)
-			== ATOMISP_HW_REVISION_ISP2300)
-			fw_path = "shisp_css15.bin";
-	}
-#endif
-
-	if (!fw_path) {
-		dev_err(isp->dev,
-			"Unsupported driver_version 0x%x, hw_revision 0x%x\n",
-			isp->media_dev.driver_version,
-			isp->media_dev.hw_revision);
-		return NULL;
-	}
-
-	rc = request_firmware(&fw, fw_path, isp->dev);
-	if (rc) {
-		dev_err(isp->dev,
-			"atomisp: Error %d while requesting firmware %s\n",
-			rc, fw_path);
-		return NULL;
-	}
-
-	return fw;
-}
-
-/*
- * Check for flags the driver was compiled with against the PCI
- * device. Always returns true on other than ISP 2400.
- */
-static bool is_valid_device(struct pci_dev *dev,
-			    const struct pci_device_id *id)
-{
-	unsigned int a0_max_id;
-
-	switch (id->device & ATOMISP_PCI_DEVICE_SOC_MASK) {
-	case ATOMISP_PCI_DEVICE_SOC_MRFLD:
-	case ATOMISP_PCI_DEVICE_SOC_MRFLD_FREQ_LIMITED:
-		a0_max_id = ATOMISP_PCI_REV_MRFLD_A0_MAX;
-		break;
-	case ATOMISP_PCI_DEVICE_SOC_BYT:
-		a0_max_id = ATOMISP_PCI_REV_BYT_A0_MAX;
-		break;
-	default:
-		return true;
-	}
-
-#ifdef ISP2400
-	return dev->revision <= a0_max_id;
-#else /* ISP2400 */
-	return dev->revision > a0_max_id;
-#endif /* ISP2400 */
-}
-
-#define ATOM_ISP_PCI_BAR	0
-
-static int atomisp_pci_probe(struct pci_dev *dev,
-				       const struct pci_device_id *id)
-{
-	const struct atomisp_platform_data *pdata;
-	struct atomisp_device *isp;
-	unsigned int start;
-	void __iomem *base;
-	void __iomem * const *iomap;
-	int err;
-
-	if (!dev) {
-		dev_err(&dev->dev, "atomisp: error device ptr\n");
-		return -EINVAL;
-	}
-
-	if (!is_valid_device(dev, id))
-		return -ENODEV;
-
-	/* Pointer to struct device. */
-	atomisp_dev = &dev->dev;
-
-	pdata = atomisp_get_platform_data();
-	if (pdata == NULL)
-		dev_warn(&dev->dev, "no platform data available\n");
-
-	err = pcim_enable_device(dev);
-	if (err) {
-		dev_err(&dev->dev, "Failed to enable CI ISP device (%d)\n",
-			err);
-		return err;
-	}
-
-	start = pci_resource_start(dev, ATOM_ISP_PCI_BAR);
-	dev_dbg(&dev->dev, "start: 0x%x\n", start);
-
-	err = pcim_iomap_regions(dev, 1 << ATOM_ISP_PCI_BAR, pci_name(dev));
-	if (err) {
-		dev_err(&dev->dev, "Failed to I/O memory remapping (%d)\n",
-			err);
-		return err;
-	}
-
-	iomap = pcim_iomap_table(dev);
-	if (!iomap)
-		return -ENODEV;
-
-	base = iomap[ATOM_ISP_PCI_BAR];
-	dev_dbg(&dev->dev, "base: %p\n", base);
-	if (!base)
-		return -ENODEV;
-
-	atomisp_io_base = base;
-
-	dev_dbg(&dev->dev, "atomisp_io_base: %p\n", atomisp_io_base);
-
-	isp = devm_kzalloc(&dev->dev, sizeof(struct atomisp_device), GFP_KERNEL);
-	if (!isp) {
-		dev_err(&dev->dev, "Failed to alloc CI ISP structure\n");
-		return -ENOMEM;
-	}
-	isp->pdev = dev;
-	isp->dev = &dev->dev;
-	isp->sw_contex.power_state = ATOM_ISP_POWER_UP;
-	isp->pci_root = pci_get_bus_and_slot(0, 0);
-	if (!isp->pci_root) {
-		dev_err(&dev->dev, "Unable to find PCI host\n");
-		return -ENODEV;
-	}
-	isp->saved_regs.ispmmadr = start;
-
-	mutex_init(&isp->mutex);
-	mutex_init(&isp->streamoff_mutex);
-	spin_lock_init(&isp->lock);
-
-#ifndef CSS20
-	isp->media_dev.driver_version = ATOMISP_CSS_VERSION_15;
-#elif !defined(CSS21)
-	isp->media_dev.driver_version = ATOMISP_CSS_VERSION_20;
-#else
-	isp->media_dev.driver_version = ATOMISP_CSS_VERSION_21;
-#endif
-	switch (id->device & ATOMISP_PCI_DEVICE_SOC_MASK) {
-	case ATOMISP_PCI_DEVICE_SOC_MRFLD:
-	case ATOMISP_PCI_DEVICE_SOC_MRFLD_FREQ_LIMITED:
-	case ATOMISP_PCI_DEVICE_SOC_BYT:
-		isp->media_dev.hw_revision =
-			(ATOMISP_HW_REVISION_ISP2400
-			 << ATOMISP_HW_REVISION_SHIFT) |
-#ifdef ISP2400
-			ATOMISP_HW_STEPPING_A0;
-#else
-			ATOMISP_HW_STEPPING_B0;
-#endif
-		atomisp_hmm_is_2400 = true;
-		break;
-	case ATOMISP_PCI_DEVICE_SOC_ANN:
-	case ATOMISP_PCI_DEVICE_SOC_CHT:
-		isp->media_dev.hw_revision = (
-#ifdef ISP2401_NEW_INPUT_SYSTEM
-			 ATOMISP_HW_REVISION_ISP2401
-#else
-			 ATOMISP_HW_REVISION_ISP2401_LEGACY
-#endif
-			 << ATOMISP_HW_REVISION_SHIFT) |
-			ATOMISP_HW_STEPPING_A0;
-		atomisp_hmm_is_2400 = true;
-		break;
-	default:
-		/* Medfield and Clovertrail. */
-		isp->media_dev.hw_revision =
-			(ATOMISP_HW_REVISION_ISP2300
-			 << ATOMISP_HW_REVISION_SHIFT) |
-			(dev->revision < 0x09 ?
-			 ATOMISP_HW_STEPPING_A0 : ATOMISP_HW_STEPPING_B0);
-	}
-
-	isp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;
-	if (pdata &&
-	    (pdata->spid->platform_family_id == INTEL_CLVTP_PHONE ||
-	     pdata->spid->platform_family_id == INTEL_CLVT_TABLET) &&
-	    isp->pdev->revision < 0x09) {
-		/* Workaround for Cloverview(+) older than stepping B0 */
-		isp->max_isr_latency = CSTATE_EXIT_LATENCY_C1;
-	}
-
-	/* Load isp firmware from user space */
-	isp->firmware = load_firmware(isp);
-	if (!isp->firmware) {
-		err = -ENOENT;
-		goto load_fw_fail;
-	}
-
-	isp->wdt_work_queue = alloc_workqueue(isp->v4l2_dev.name, 0, 1);
-	if (isp->wdt_work_queue == NULL) {
-		dev_err(&dev->dev, "Failed to initialize wdt work queue\n");
-		err = -ENOMEM;
-		goto wdt_work_queue_fail;
-	}
-	INIT_WORK(&isp->wdt_work, atomisp_wdt_work);
-
-	pci_set_master(dev);
-	pci_set_drvdata(dev, isp);
-
-	err = pci_enable_msi(dev);
-	if (err) {
-		dev_err(&dev->dev, "Failed to enable msi (%d)\n", err);
-		goto enable_msi_fail;
-	}
-
-	err = devm_request_threaded_irq(&dev->dev, dev->irq,
-					atomisp_isr, atomisp_isr_thread,
-					IRQF_SHARED, "isp_irq", isp);
-	if (err) {
-		dev_err(&dev->dev, "Failed to request irq (%d)\n", err);
-		goto enable_msi_fail;
-	}
-
-	setup_timer(&isp->wdt, atomisp_wdt, (unsigned long)isp);
-
-	atomisp_msi_irq_init(isp, dev);
-
-	pm_qos_add_request(&isp->pm_qos, PM_QOS_CPU_DMA_LATENCY,
-			   PM_QOS_DEFAULT_VALUE);
-
-	if (IS_ISP24XX(isp)) {
-		/*
-		 * for MRFLD, Software/firmware needs to write a 1 to bit 0 of
-		 * the register at CSI_RECEIVER_SELECTION_REG to enable SH CSI
-		 * backend write 0 will enable Arasan CSI backend, which has
-		 * bugs(like sighting:4567697 and 4567699) and will be removed
-		 * in B0
-		 */
-		atomisp_store_uint32(MRFLD_CSI_RECEIVER_SELECTION_REG, 1);
-	}
-
-	if ((id->device & ATOMISP_PCI_DEVICE_SOC_MASK) ==
-			ATOMISP_PCI_DEVICE_SOC_MRFLD) {
-		u32 csi_afe_trim;
-
-		/*
-		 * Workaround for imbalance data eye issue which is observed
-		 * on TNG B0.
-		 */
-		pci_read_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
-				      &csi_afe_trim);
-		csi_afe_trim &= ~((MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<
-					MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |
-				  (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<
-					MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |
-				  (MRFLD_PCI_CSI_HSRXCLKTRIM_MASK <<
-					MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT));
-		csi_afe_trim |= (MRFLD_PCI_CSI1_HSRXCLKTRIM <<
-					MRFLD_PCI_CSI1_HSRXCLKTRIM_SHIFT) |
-				(MRFLD_PCI_CSI2_HSRXCLKTRIM <<
-					MRFLD_PCI_CSI2_HSRXCLKTRIM_SHIFT) |
-				(MRFLD_PCI_CSI3_HSRXCLKTRIM <<
-					MRFLD_PCI_CSI3_HSRXCLKTRIM_SHIFT);
-		pci_write_config_dword(dev, MRFLD_PCI_CSI_AFE_TRIM_CONTROL,
-				      csi_afe_trim);
-	}
-
-	err = atomisp_initialize_modules(isp);
-	if (err < 0) {
-		dev_err(&dev->dev, "atomisp_initialize_modules (%d)\n", err);
-		goto enable_msi_fail;
-	}
-
-	err = atomisp_register_entities(isp);
-	if (err < 0) {
-		dev_err(&dev->dev, "atomisp_register_entities failed (%d)\n",
-			err);
-		goto enable_msi_fail;
-	}
-	atomisp_acc_init(isp);
-
-	/* save the iunit context only once after all the values are init'ed. */
-	atomisp_save_iunit_reg(isp);
-
-	pm_runtime_put_noidle(&dev->dev);
-	pm_runtime_allow(&dev->dev);
-
-	err = hmm_pool_register(repool_pgnr, HMM_POOL_TYPE_RESERVED);
-	if (err)
-		dev_err(&dev->dev, "Failed to register reserved memory pool.\n");
-
-/*
- * In css1.5, we still do hmm_init and load_firmware when open camera, this
- * is beacuse ISP timeout will happen if put it here.
- */
-#ifdef CSS20
-	/* Init ISP memory management */
-	hrt_isp_css_mm_init();
-
-	/* Load firmware into ISP memory */
-	err = atomisp_css_load_firmware(isp);
-	if (err) {
-		dev_err(&dev->dev, "Failed to init css.\n");
-		goto css_init_fail;
-	}
-#endif /* CSS20 */
-
-	return 0;
-
-#ifdef CSS20
-css_init_fail:
-	hrt_isp_css_mm_clear();
-	hmm_pool_unregister(HMM_POOL_TYPE_RESERVED);
-	atomisp_acc_cleanup(isp);
-#endif /* CSS20 */
-enable_msi_fail:
-	destroy_workqueue(isp->wdt_work_queue);
-wdt_work_queue_fail:
-	release_firmware(isp->firmware);
-load_fw_fail:
-	pci_dev_put(isp->pci_root);
-	return err;
-}
-
-static void atomisp_pci_remove(struct pci_dev *dev)
-{
-	struct atomisp_device *isp = (struct atomisp_device *)
-		pci_get_drvdata(dev);
-
-	atomisp_acc_cleanup(isp);
-#ifdef CSS20
-	atomisp_css_unload_firmware(isp);
-	hrt_isp_css_mm_clear();
-#endif /* CSS20 */
-
-	pm_runtime_forbid(&dev->dev);
-	pm_runtime_get_noresume(&dev->dev);
-	pm_qos_remove_request(&isp->pm_qos);
-
-	atomisp_msi_irq_uninit(isp, dev);
-	pci_dev_put(isp->pci_root);
-
-	atomisp_unregister_entities(isp);
-
-	destroy_workqueue(isp->wdt_work_queue);
-	atomisp_file_input_cleanup(isp);
-
-	release_firmware(isp->firmware);
-
-	hmm_pool_unregister(HMM_POOL_TYPE_RESERVED);
-}
-
-static DEFINE_PCI_DEVICE_TABLE(atomisp_pci_tbl) = {
-#if defined(ISP2300)
-	/* Medfield */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0148)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0149)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014A)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014B)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014C)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014D)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014E)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x014F)},
-	/* Clovertrail */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08D0)},
-#elif defined(ISP2400) || defined(ISP2400B0)
-	/* Merrifield */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1178)},
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1179)},
-	/* Baytrail */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0f38)},
-#elif defined(ISP2401)
-	/* Anniedale (Merrifield+ / Moorefield) */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1478)},
-	/* Cherrytrail */
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x22b8)},
-#endif
-	{0,}
-};
-
-MODULE_DEVICE_TABLE(pci, atomisp_pci_tbl);
-
-#ifdef CONFIG_PM
-static const struct dev_pm_ops atomisp_pm_ops = {
-	.runtime_suspend = atomisp_runtime_suspend,
-	.runtime_resume = atomisp_runtime_resume,
-	.suspend = atomisp_suspend,
-	.resume = atomisp_resume,
-};
-
-#define DEV_PM_OPS (&atomisp_pm_ops)
-#else
-#define DEV_PM_OPS NULL
-#endif
-
-static struct pci_driver atomisp_pci_driver = {
-	.driver = {
-		.pm = DEV_PM_OPS,
-	},
-	.name = "atomisp-" ATOMISP_POSTFIX,
-	.id_table = atomisp_pci_tbl,
-	.probe = atomisp_pci_probe,
-	.remove = atomisp_pci_remove,
-};
-
-static int __init atomisp_init(void)
-{
-	return pci_register_driver(&atomisp_pci_driver);
-}
-
-static void __exit atomisp_exit(void)
-{
-	pci_unregister_driver(&atomisp_pci_driver);
-}
-
-module_init(atomisp_init);
-module_exit(atomisp_exit);
-
-MODULE_AUTHOR("Wen Wang <wen.w.wang@intel.com>");
-MODULE_AUTHOR("Xiaolin Zhang <xiaolin.zhang@intel.com>");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Intel ATOM Platform ISP Driver");
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.h
deleted file mode 100644
index 05eed6e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/atomisp_v4l2.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef __ATOMISP_V4L2_H__
-#define __ATOMISP_V4L2_H__
-
-struct atomisp_video_pipe;
-struct v4l2_device;
-
-int atomisp_video_init(struct atomisp_video_pipe *video, const char *name);
-void atomisp_video_unregister(struct atomisp_video_pipe *video);
-int atomisp_video_register(struct atomisp_video_pipe *video,
-	struct v4l2_device *vdev);
-
-#endif /* __ATOMISP_V4L2_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm.c
deleted file mode 100644
index 53718d89..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm.c
+++ /dev/null
@@ -1,506 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-/*
- * This file contains entry functions for memory management of ISP driver
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/highmem.h>	/* for kmap */
-#include <linux/io.h>		/* for page_to_phys */
-
-#include "hmm/hmm.h"
-#include "hmm/hmm_pool.h"
-#include "hmm/hmm_bo.h"
-#include "hmm/hmm_bo_dev.h"
-
-#include "atomisp_internal.h"
-#include "asm/cacheflush.h"
-#include "mmu/isp_mmu.h"
-#include "mmu/sh_mmu_mrfld.h"
-#include "mmu/sh_mmu_mfld.h"
-
-#ifdef USE_SSSE3
-#include <asm/ssse3.h>
-#endif
-
-struct hmm_bo_device bo_device;
-struct hmm_pool	dynamic_pool;
-struct hmm_pool	reserved_pool;
-static ia_css_ptr dummy_ptr;
-bool atomisp_hmm_is_2400;
-
-int hmm_init(void)
-{
-	int ret;
-
-	if (atomisp_hmm_is_2400)
-		ret = hmm_bo_device_init(&bo_device, &sh_mmu_mrfld,
-					 ISP_VM_START, ISP_VM_SIZE);
-	else
-		ret = hmm_bo_device_init(&bo_device, &sh_mmu_mfld,
-					 ISP_VM_START, ISP_VM_SIZE);
-
-	if (ret)
-		dev_err(atomisp_dev, "hmm_bo_device_init failed.\n");
-
-	/*
-	 * As hmm use NULL to indicate invalid ISP virtual address,
-	 * and ISP_VM_START is defined to 0 too, so we allocate
-	 * one piece of dummy memory, which should return value 0,
-	 * at the beginning, to avoid hmm_alloc return 0 in the
-	 * further allocation.
-	 */
-	dummy_ptr = hmm_alloc(1, HMM_BO_PRIVATE, 0, 0, HMM_UNCACHED);
-	return ret;
-}
-
-void hmm_cleanup(void)
-{
-	/*
-	 * free dummy memory first
-	 */
-	hmm_free(dummy_ptr);
-	dummy_ptr = 0;
-
-	hmm_bo_device_exit(&bo_device);
-}
-
-void hmm_cleanup_mmu_l2(void)
-{
-	hmm_bo_device_cleanup_mmu_l2(&bo_device);
-}
-
-ia_css_ptr hmm_alloc(size_t bytes, enum hmm_bo_type type,
-		int from_highmem, void *userptr, bool cached)
-{
-	unsigned int pgnr;
-	struct hmm_buffer_object *bo;
-	int ret;
-
-	/*Get page number from size*/
-	pgnr = size_to_pgnr_ceil(bytes);
-
-	/*Buffer object structure init*/
-	bo = hmm_bo_create(&bo_device, pgnr);
-	if (!bo) {
-		dev_err(atomisp_dev, "hmm_bo_create failed.\n");
-		goto create_bo_err;
-	}
-
-	/*Allocate virtual address in ISP virtual space*/
-	ret = hmm_bo_alloc_vm(bo);
-	if (ret) {
-		dev_err(atomisp_dev,
-			    "hmm_bo_alloc_vm failed.\n");
-		goto alloc_vm_err;
-	}
-
-	/*Allocate pages for memory*/
-	ret = hmm_bo_alloc_pages(bo, type, from_highmem, userptr, cached);
-	if (ret) {
-		dev_err(atomisp_dev,
-			    "hmm_bo_alloc_pages failed.\n");
-		goto alloc_page_err;
-	}
-
-	/*Combind the virtual address and pages togather*/
-	ret = hmm_bo_bind(bo);
-	if (ret) {
-		dev_err(atomisp_dev, "hmm_bo_bind failed.\n");
-		goto bind_err;
-	}
-	return bo->vm_node->start;
-
-bind_err:
-	hmm_bo_free_pages(bo);
-alloc_page_err:
-	hmm_bo_free_vm(bo);
-alloc_vm_err:
-	hmm_bo_unref(bo);
-create_bo_err:
-	return 0;
-}
-
-void hmm_free(ia_css_ptr virt)
-{
-	struct hmm_buffer_object *bo;
-
-	bo = hmm_bo_device_search_start(&bo_device, (unsigned int)virt);
-
-	if (!bo) {
-		dev_err(atomisp_dev,
-			    "can not find buffer object start with "
-			    "address 0x%x\n", (unsigned int)virt);
-		return;
-	}
-
-	hmm_bo_unbind(bo);
-
-	hmm_bo_free_pages(bo);
-
-	hmm_bo_free_vm(bo);
-
-	hmm_bo_unref(bo);
-}
-
-static inline int hmm_check_bo(struct hmm_buffer_object *bo, unsigned int ptr)
-{
-	if (!bo) {
-		dev_err(atomisp_dev,
-			    "can not find buffer object contains "
-			    "address 0x%x\n", ptr);
-		return -EINVAL;
-	}
-
-	if (!hmm_bo_page_allocated(bo)) {
-		dev_err(atomisp_dev,
-			    "buffer object has no page allocated.\n");
-		return -EINVAL;
-	}
-
-	if (!hmm_bo_vm_allocated(bo)) {
-		dev_err(atomisp_dev,
-			    "buffer object has no virtual address"
-			    " space allocated.\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/*Read function in ISP memory management*/
-static int load_and_flush(ia_css_ptr virt, void *data, unsigned int bytes)
-{
-	unsigned int ptr;
-	struct hmm_buffer_object *bo;
-	unsigned int idx, offset, len;
-	char *src, *des;
-	int ret;
-
-	ptr = (unsigned int)virt;
-
-	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
-	ret = hmm_check_bo(bo, ptr);
-	if (ret)
-		return ret;
-
-	des = (char *)data;
-	while (bytes) {
-		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
-		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
-
-		src = (char *)kmap(bo->page_obj[idx].page);
-		if (!src) {
-			dev_err(atomisp_dev,
-				    "kmap buffer object page failed: "
-				    "pg_idx = %d\n", idx);
-			return -EINVAL;
-		}
-
-		src += offset;
-
-		if ((bytes + offset) >= PAGE_SIZE) {
-			len = PAGE_SIZE - offset;
-			bytes -= len;
-		} else {
-			len = bytes;
-			bytes = 0;
-		}
-
-		ptr += len;	/* update ptr for next loop */
-
-		if (des) {
-
-#ifdef USE_SSSE3
-			_ssse3_memcpy(des, src, len);
-#else
-			memcpy(des, src, len);
-#endif
-			des += len;
-		}
-
-		clflush_cache_range(src, len);
-
-		kunmap(bo->page_obj[idx].page);
-	}
-
-	return 0;
-}
-
-/*Read function in ISP memory management*/
-int hmm_load(ia_css_ptr virt, void *data, unsigned int bytes)
-{
-	if (!data) {
-		dev_err(atomisp_dev,
-			 "hmm_load NULL argument\n");
-		return -EINVAL;
-	}
-	return load_and_flush(virt, data, bytes);
-}
-
-/*Flush hmm data from the data cache*/
-int hmm_flush(ia_css_ptr virt, unsigned int bytes)
-{
-	return load_and_flush(virt, NULL, bytes);
-}
-
-/*Write function in ISP memory management*/
-int hmm_store(ia_css_ptr virt, const void *data, unsigned int bytes)
-{
-	unsigned int ptr;
-	struct hmm_buffer_object *bo;
-	unsigned int idx, offset, len;
-	char *src, *des;
-	int ret;
-
-	ptr = (unsigned int)virt;
-
-	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
-	ret = hmm_check_bo(bo, ptr);
-	if (ret)
-		return ret;
-
-	src = (char *)data;
-	while (bytes) {
-		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
-		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
-
-		if (in_atomic())
-			des = (char *)kmap_atomic(bo->page_obj[idx].page);
-		else
-			des = (char *)kmap(bo->page_obj[idx].page);
-
-		if (!des) {
-			dev_err(atomisp_dev,
-				    "kmap buffer object page failed: "
-				    "pg_idx = %d\n", idx);
-			return -EINVAL;
-		}
-
-		des += offset;
-
-		if ((bytes + offset) >= PAGE_SIZE) {
-			len = PAGE_SIZE - offset;
-			bytes -= len;
-		} else {
-			len = bytes;
-			bytes = 0;
-		}
-
-		ptr += len;
-
-#ifdef USE_SSSE3
-		_ssse3_memcpy(des, src, len);
-#else
-		memcpy(des, src, len);
-#endif
-		src += len;
-
-		clflush_cache_range(des, len);
-
-		if (in_atomic())
-			/*
-			 * Note: kunmap_atomic requires return addr from
-			 * kmap_atomic, not the page. See linux/highmem.h
-			 */
-			kunmap_atomic(des - offset);
-		else
-			kunmap(bo->page_obj[idx].page);
-	}
-
-	return 0;
-}
-
-/*memset function in ISP memory management*/
-int hmm_set(ia_css_ptr virt, int c, unsigned int bytes)
-{
-	unsigned int ptr;
-	struct hmm_buffer_object *bo;
-	unsigned int idx, offset, len;
-	char *des;
-	int ret;
-
-	ptr = virt;
-
-	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
-	ret = hmm_check_bo(bo, ptr);
-	if (ret)
-		return ret;
-
-	while (bytes) {
-		idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
-		offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
-
-		des = (char *)kmap(bo->page_obj[idx].page);
-		if (!des) {
-			dev_err(atomisp_dev,
-				    "kmap buffer object page failed: "
-				    "pg_idx = %d\n", idx);
-			return -EINVAL;
-		}
-		des += offset;
-
-		if ((bytes + offset) >= PAGE_SIZE) {
-			len = PAGE_SIZE - offset;
-			bytes -= len;
-		} else {
-			len = bytes;
-			bytes = 0;
-		}
-
-		ptr += len;
-
-		memset(des, c, len);
-
-		clflush_cache_range(des, len);
-
-		kunmap(bo->page_obj[idx].page);
-	}
-
-	return 0;
-}
-
-/*Virtual address to physical address convert*/
-phys_addr_t hmm_virt_to_phys(ia_css_ptr virt)
-{
-	unsigned int ptr = (unsigned int)virt;
-	unsigned int idx, offset;
-	struct hmm_buffer_object *bo;
-
-	bo = hmm_bo_device_search_in_range(&bo_device, ptr);
-	if (!bo) {
-		dev_err(atomisp_dev,
-			    "can not find buffer object contains "
-			    "address 0x%x\n", ptr);
-		return -1;
-	}
-
-	idx = (ptr - bo->vm_node->start) >> PAGE_SHIFT;
-	offset = (ptr - bo->vm_node->start) - (idx << PAGE_SHIFT);
-
-	return page_to_phys(bo->page_obj[idx].page) + offset;
-}
-
-int hmm_mmap(struct vm_area_struct *vma, ia_css_ptr virt)
-{
-	struct hmm_buffer_object *bo;
-
-	bo = hmm_bo_device_search_start(&bo_device, virt);
-	if (!bo) {
-		dev_err(atomisp_dev,
-			    "can not find buffer object start with "
-			    "address 0x%x\n", virt);
-		return -EINVAL;
-	}
-
-	return hmm_bo_mmap(vma, bo);
-}
-
-/*Map ISP virtual address into IA virtual address*/
-void *hmm_vmap(ia_css_ptr virt)
-{
-	struct hmm_buffer_object *bo;
-
-	bo = hmm_bo_device_search_start(&bo_device, virt);
-	if (!bo) {
-		dev_err(atomisp_dev,
-			    "can not find buffer object start with address 0x%x\n",
-			    virt);
-		return NULL;
-	}
-
-	return hmm_bo_vmap(bo);
-}
-
-void hmm_vunmap(ia_css_ptr virt)
-{
-	struct hmm_buffer_object *bo;
-
-	bo = hmm_bo_device_search_start(&bo_device, virt);
-	if (!bo) {
-		dev_warn(atomisp_dev,
-			"can not find buffer object start with address 0x%x\n",
-			virt);
-		return;
-	}
-
-	return hmm_bo_vunmap(bo);
-}
-
-int hmm_pool_register(unsigned int pool_size,
-			enum hmm_pool_type pool_type)
-{
-	switch (pool_type) {
-	case HMM_POOL_TYPE_RESERVED:
-		reserved_pool.pops = &reserved_pops;
-		return reserved_pool.pops->pool_init(&reserved_pool.pool_info,
-							pool_size);
-	case HMM_POOL_TYPE_DYNAMIC:
-		dynamic_pool.pops = &dynamic_pops;
-		return dynamic_pool.pops->pool_init(&dynamic_pool.pool_info,
-							pool_size);
-	default:
-		dev_err(atomisp_dev, "invalid pool type.\n");
-		return -EINVAL;
-	}
-}
-
-void hmm_pool_unregister(enum hmm_pool_type pool_type)
-{
-	switch (pool_type) {
-	case HMM_POOL_TYPE_RESERVED:
-		if (reserved_pool.pops && reserved_pool.pops->pool_exit)
-			reserved_pool.pops->pool_exit(&reserved_pool.pool_info);
-		break;
-	case HMM_POOL_TYPE_DYNAMIC:
-		if (dynamic_pool.pops && dynamic_pool.pops->pool_exit)
-			dynamic_pool.pops->pool_exit(&dynamic_pool.pool_info);
-		break;
-	default:
-		dev_err(atomisp_dev, "invalid pool type.\n");
-		break;
-	}
-
-	return;
-}
-
-void *hmm_isp_vaddr_to_host_vaddr(ia_css_ptr ptr)
-{
-	return hmm_vmap(ptr);
-	/* vmunmap will be done in hmm_bo_release() */
-}
-
-ia_css_ptr hmm_host_vaddr_to_hrt_vaddr(const void *ptr)
-{
-	struct hmm_buffer_object *bo;
-
-	bo = hmm_bo_device_search_vmap_start(&bo_device, ptr);
-	if (bo)
-		return bo->vm_node->start;
-
-	dev_err(atomisp_dev,
-		"can not find buffer object whose kernel virtual address is %p\n",
-		ptr);
-	return 0;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo.c
deleted file mode 100644
index f270108..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo.c
+++ /dev/null
@@ -1,1247 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-/*
- * This file contains functions for buffer object structure management
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/gfp.h>		/* for GFP_ATOMIC */
-#include <linux/mm.h>
-#include <linux/mm_types.h>
-#include <linux/hugetlb.h>
-#include <linux/highmem.h>
-#include <linux/slab.h>		/* for kmalloc */
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/string.h>
-#include <linux/list.h>
-#include <linux/errno.h>
-#include <asm/cacheflush.h>
-#include <linux/io.h>
-#include <asm/current.h>
-#include <linux/sched.h>
-
-#include "atomisp_internal.h"
-
-#include "hmm/hmm_vm.h"
-#include "hmm/hmm_bo.h"
-#include "hmm/hmm_pool.h"
-#include "hmm/hmm_bo_dev.h"
-#include "hmm/hmm_common.h"
-
-#ifdef CONFIG_ION
-#include <linux/ion.h>
-#include <linux/scatterlist.h>
-#endif
-
-static unsigned int order_to_nr(unsigned int order)
-{
-	return 1U << order;
-}
-
-static unsigned int nr_to_order_bottom(unsigned int nr)
-{
-	return fls(nr) - 1;
-}
-
-static void free_bo_internal(struct hmm_buffer_object *bo)
-{
-	kfree(bo);
-}
-
-/*
- * use these functions to dynamically alloc hmm_buffer_object.
- * hmm_bo_init will called for that allocated buffer object, and
- * the release callback is set to kfree.
- */
-struct hmm_buffer_object *hmm_bo_create(struct hmm_bo_device *bdev, int pgnr)
-{
-	struct hmm_buffer_object *bo;
-	int ret;
-
-	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
-	if (!bo) {
-		dev_err(atomisp_dev, "out of memory for bo\n");
-		return NULL;
-	}
-
-	ret = hmm_bo_init(bdev, bo, pgnr, free_bo_internal);
-	if (ret) {
-		dev_err(atomisp_dev, "hmm_bo_init failed\n");
-		kfree(bo);
-		return NULL;
-	}
-
-	return bo;
-}
-
-/*
- * use this function to initialize pre-allocated hmm_buffer_object.
- * as hmm_buffer_object may be used as an embedded object in an upper
- * level object, a release callback must be provided. if it is
- * embedded in upper level object, set release call back to release
- * function of that object. if no upper level object, set release
- * callback to NULL.
- *
- * bo->kref is inited to 1.
- */
-int hmm_bo_init(struct hmm_bo_device *bdev,
-		struct hmm_buffer_object *bo,
-		unsigned int pgnr, void (*release) (struct hmm_buffer_object *))
-{
-	unsigned long flags;
-
-	if (bdev == NULL) {
-		dev_warn(atomisp_dev, "NULL hmm_bo_device.\n");
-		return -EINVAL;
-	}
-
-	/* hmm_bo_device must be already inited */
-	var_equal_return(hmm_bo_device_inited(bdev), 0, -EINVAL,
-			   "hmm_bo_device not inited yet.\n");
-
-	/* prevent zero size buffer object */
-	if (pgnr == 0) {
-		dev_err(atomisp_dev, "0 size buffer is not allowed.\n");
-		return -EINVAL;
-	}
-
-	memset(bo, 0, sizeof(*bo));
-
-	kref_init(&bo->kref);
-
-	mutex_init(&bo->mutex);
-
-	INIT_LIST_HEAD(&bo->list);
-
-	bo->pgnr = pgnr;
-	bo->bdev = bdev;
-	bo->vmap_addr = NULL;
-	bo->release = release;
-
-	if (!bo->release)
-		dev_warn(atomisp_dev, "no release callback specified.\n");
-
-	/*
-	 * add to active_bo_list
-	 */
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_add_tail(&bo->list, &bdev->active_bo_list);
-	bo->status |= HMM_BO_ACTIVE;
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-
-	return 0;
-}
-
-static void hmm_bo_release(struct hmm_buffer_object *bo)
-{
-	struct hmm_bo_device *bdev;
-	unsigned long flags;
-
-	check_bo_null_return_void(bo);
-
-	bdev = bo->bdev;
-
-	/*
-	 * remove it from buffer device's buffer object list.
-	 */
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_del(&bo->list);
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-
-	/*
-	 * FIX ME:
-	 *
-	 * how to destroy the bo when it is stilled MMAPED?
-	 *
-	 * ideally, this will not happened as hmm_bo_release
-	 * will only be called when kref reaches 0, and in mmap
-	 * operation the hmm_bo_ref will eventually be called.
-	 * so, if this happened, something goes wrong.
-	 */
-	if (bo->status & HMM_BO_MMAPED) {
-		dev_err(atomisp_dev, "destroy bo which is MMAPED, do nothing\n");
-		goto err;
-	}
-
-	if (bo->status & HMM_BO_BINDED) {
-		dev_warn(atomisp_dev,
-			     "the bo is still binded, unbind it first...\n");
-		hmm_bo_unbind(bo);
-	}
-	if (bo->status & HMM_BO_PAGE_ALLOCED) {
-		dev_warn(atomisp_dev,
-			     "the pages is not freed, free pages first\n");
-		hmm_bo_free_pages(bo);
-	}
-	if (bo->status & HMM_BO_VM_ALLOCED) {
-		dev_warn(atomisp_dev,
-			     "the vm is still not freed, free vm first...\n");
-		hmm_bo_free_vm(bo);
-	}
-	if (bo->status & HMM_BO_VMAPED) {
-		dev_warn(atomisp_dev, "the vunmap is not done, do it...\n");
-		hmm_bo_vunmap(bo);
-	}
-
-	if (bo->release)
-		bo->release(bo);
-err:
-	return;
-}
-
-int hmm_bo_activated(struct hmm_buffer_object *bo)
-{
-	check_bo_null_return(bo, 0);
-
-	return bo->status & HMM_BO_ACTIVE;
-}
-
-void hmm_bo_unactivate(struct hmm_buffer_object *bo)
-{
-	struct hmm_bo_device *bdev;
-	unsigned long flags;
-
-	check_bo_null_return_void(bo);
-
-	check_bo_status_no_goto(bo, HMM_BO_ACTIVE, status_err);
-
-	bdev = bo->bdev;
-
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_del(&bo->list);
-	list_add_tail(&bo->list, &bdev->free_bo_list);
-	bo->status &= (~HMM_BO_ACTIVE);
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-
-	return;
-
-status_err:
-	dev_err(atomisp_dev, "buffer object already unactivated.\n");
-	return;
-}
-
-int hmm_bo_alloc_vm(struct hmm_buffer_object *bo)
-{
-	struct hmm_bo_device *bdev;
-
-	check_bo_null_return(bo, -EINVAL);
-
-	mutex_lock(&bo->mutex);
-
-	check_bo_status_no_goto(bo, HMM_BO_VM_ALLOCED, status_err);
-
-	bdev = bo->bdev;
-	bo->vm_node = hmm_vm_alloc_node(&bdev->vaddr_space, bo->pgnr);
-	if (unlikely(!bo->vm_node)) {
-		dev_err(atomisp_dev, "hmm_vm_alloc_node err.\n");
-		goto null_vm;
-	}
-
-	bo->status |= HMM_BO_VM_ALLOCED;
-
-	mutex_unlock(&bo->mutex);
-
-	return 0;
-null_vm:
-	mutex_unlock(&bo->mutex);
-	return -ENOMEM;
-
-status_err:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev, "buffer object already has vm allocated.\n");
-	return -EINVAL;
-}
-
-void hmm_bo_free_vm(struct hmm_buffer_object *bo)
-{
-	struct hmm_bo_device *bdev;
-
-	check_bo_null_return_void(bo);
-
-	mutex_lock(&bo->mutex);
-
-	check_bo_status_yes_goto(bo, HMM_BO_VM_ALLOCED, status_err);
-
-	bdev = bo->bdev;
-
-	bo->status &= (~HMM_BO_VM_ALLOCED);
-	hmm_vm_free_node(bo->vm_node);
-	bo->vm_node = NULL;
-	mutex_unlock(&bo->mutex);
-
-	return;
-
-status_err:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev, "buffer object has no vm allocated.\n");
-}
-
-int hmm_bo_vm_allocated(struct hmm_buffer_object *bo)
-{
-	int ret;
-
-	check_bo_null_return(bo, 0);
-
-	ret = (bo->status & HMM_BO_VM_ALLOCED);
-
-	return ret;
-}
-
-static void free_private_bo_pages(struct hmm_buffer_object *bo,
-				  struct hmm_pool *dypool,
-				  struct hmm_pool *repool, int free_pgnr)
-{
-	int i, ret;
-
-	for (i = 0; i < free_pgnr; i++) {
-		switch (bo->page_obj[i].type) {
-		case HMM_PAGE_TYPE_RESERVED:
-			if (repool->pops
-			    && repool->pops->pool_free_pages)
-				repool->pops->pool_free_pages(repool->pool_info,
-							&bo->page_obj[i]);
-			break;
-		/*
-		 * HMM_PAGE_TYPE_GENERAL indicates that pages are from system
-		 * memory, so when free them, they should be put into dynamic
-		 * pool.
-		 */
-		case HMM_PAGE_TYPE_DYNAMIC:
-		case HMM_PAGE_TYPE_GENERAL:
-			if (dypool->pops
-			    && dypool->pops->pool_inited
-			    && dypool->pops->pool_inited(dypool->pool_info)) {
-				if (dypool->pops->pool_free_pages)
-					dypool->pops->pool_free_pages(
-							      dypool->pool_info,
-							      &bo->page_obj[i]);
-				break;
-			}
-
-			/*
-			 * if dynamic memory pool doesn't exist, need to free
-			 * pages to system directly.
-			 */
-		default:
-			ret = set_pages_wb(bo->page_obj[i].page, 1);
-			if (ret)
-				dev_err(atomisp_dev,
-						"set page to WB err ...\n");
-			__free_pages(bo->page_obj[i].page, 0);
-			break;
-		}
-	}
-
-	return;
-}
-
-/*Allocate pages which will be used only by ISP*/
-static int alloc_private_pages(struct hmm_buffer_object *bo, int from_highmem,
-				bool cached, struct hmm_pool *dypool,
-				struct hmm_pool *repool)
-{
-	int ret;
-	unsigned int pgnr, order, blk_pgnr, alloc_pgnr;
-	struct page *pages;
-	gfp_t gfp = GFP_NOWAIT | __GFP_NOWARN; /* REVISIT: need __GFP_FS too? */
-	int i, j;
-	int failure_number = 0;
-	bool reduce_order = false;
-	bool lack_mem = true;
-
-	if (from_highmem)
-		gfp |= __GFP_HIGHMEM;
-
-	pgnr = bo->pgnr;
-
-	bo->page_obj = atomisp_kernel_malloc(
-				sizeof(struct hmm_page_object) * pgnr);
-	if (unlikely(!bo->page_obj)) {
-		dev_err(atomisp_dev, "out of memory for bo->page_obj\n");
-		return -ENOMEM;
-	}
-
-	i = 0;
-	alloc_pgnr = 0;
-
-	/*
-	 * get physical pages from dynamic pages pool.
-	 */
-	if (dypool->pops && dypool->pops->pool_alloc_pages) {
-		alloc_pgnr = dypool->pops->pool_alloc_pages(dypool->pool_info,
-							bo->page_obj, pgnr,
-							cached);
-		if (alloc_pgnr == pgnr)
-			return 0;
-	}
-
-	pgnr -= alloc_pgnr;
-	i += alloc_pgnr;
-
-	/*
-	 * get physical pages from reserved pages pool for atomisp.
-	 */
-	if (repool->pops && repool->pops->pool_alloc_pages) {
-		alloc_pgnr = repool->pops->pool_alloc_pages(repool->pool_info,
-							&bo->page_obj[i], pgnr,
-							cached);
-		if (alloc_pgnr == pgnr)
-			return 0;
-	}
-
-	pgnr -= alloc_pgnr;
-	i += alloc_pgnr;
-
-	while (pgnr) {
-		order = nr_to_order_bottom(pgnr);
-		/*
-		 * if be short of memory, we will set order to 0
-		 * everytime.
-		 */
-		if (lack_mem)
-			order = HMM_MIN_ORDER;
-		else if (order > HMM_MAX_ORDER)
-			order = HMM_MAX_ORDER;
-retry:
-		/*
-		 * When order > HMM_MIN_ORDER, for performance reasons we don't
-		 * want alloc_pages() to sleep. In case it fails and fallbacks
-		 * to HMM_MIN_ORDER or in case the requested order is originally
-		 * the minimum value, we can allow alloc_pages() to sleep for
-		 * robustness purpose.
-		 *
-		 * REVISIT: why __GFP_FS is necessary?
-		 */
-		if (order == HMM_MIN_ORDER) {
-			gfp &= ~GFP_NOWAIT;
-			gfp |= __GFP_WAIT | __GFP_FS;
-		}
-
-		pages = alloc_pages(gfp, order);
-		if (unlikely(!pages)) {
-			/*
-			 * in low memory case, if allocation page fails,
-			 * we turn to try if order=0 allocation could
-			 * succeed. if order=0 fails too, that means there is
-			 * no memory left.
-			 */
-			if (order == HMM_MIN_ORDER) {
-				dev_err(atomisp_dev,
-					"%s: cannot allocate pages\n",
-					 __func__);
-				goto cleanup;
-			}
-			order = HMM_MIN_ORDER;
-			failure_number++;
-			reduce_order = true;
-			/*
-			 * if fail two times continuously, we think be short
-			 * of memory now.
-			 */
-			if (failure_number == 2) {
-				lack_mem = true;
-				failure_number = 0;
-			}
-			goto retry;
-		} else {
-			blk_pgnr = order_to_nr(order);
-
-			if (!cached) {
-				/*
-				 * set memory to uncacheable -- UC_MINUS
-				 */
-				ret = set_pages_uc(pages, blk_pgnr);
-				if (ret) {
-					dev_err(atomisp_dev,
-						     "set page uncacheable"
-							"failed.\n");
-
-					__free_pages(pages, order);
-
-					goto cleanup;
-				}
-			}
-
-			for (j = 0; j < blk_pgnr; j++) {
-				bo->page_obj[i].page = pages + j;
-				bo->page_obj[i++].type = HMM_PAGE_TYPE_GENERAL;
-			}
-
-			pgnr -= blk_pgnr;
-
-			/*
-			 * if order is not reduced this time, clear
-			 * failure_number.
-			 */
-			if (reduce_order)
-				reduce_order = false;
-			else
-				failure_number = 0;
-		}
-	}
-
-	return 0;
-cleanup:
-	alloc_pgnr = i;
-	free_private_bo_pages(bo, dypool, repool, alloc_pgnr);
-
-	atomisp_kernel_free(bo->page_obj);
-
-	return -ENOMEM;
-}
-
-static void free_private_pages(struct hmm_buffer_object *bo,
-				struct hmm_pool *dypool,
-				struct hmm_pool *repool)
-{
-	free_private_bo_pages(bo, dypool, repool, bo->pgnr);
-
-	atomisp_kernel_free(bo->page_obj);
-}
-
-/*
- * Hacked from kernel function __get_user_pages in mm/memory.c
- *
- * Handle buffers allocated by other kernel space driver and mmaped into user
- * space, function Ignore the VM_PFNMAP and VM_IO flag in VMA structure
- *
- * Get physical pages from user space virtual address and update into page list
- */
-static int __get_pfnmap_pages(struct task_struct *tsk, struct mm_struct *mm,
-			      unsigned long start, int nr_pages,
-			      unsigned int gup_flags, struct page **pages,
-			      struct vm_area_struct **vmas)
-{
-	int i, ret;
-	unsigned long vm_flags;
-
-	if (nr_pages <= 0)
-		return 0;
-
-	VM_BUG_ON(!!pages != !!(gup_flags & FOLL_GET));
-
-	/*
-	 * Require read or write permissions.
-	 * If FOLL_FORCE is set, we only require the "MAY" flags.
-	 */
-	vm_flags  = (gup_flags & FOLL_WRITE) ?
-			(VM_WRITE | VM_MAYWRITE) : (VM_READ | VM_MAYREAD);
-	vm_flags &= (gup_flags & FOLL_FORCE) ?
-			(VM_MAYREAD | VM_MAYWRITE) : (VM_READ | VM_WRITE);
-	i = 0;
-
-	do {
-		struct vm_area_struct *vma;
-
-		vma = find_vma(mm, start);
-		if (!vma) {
-			dev_err(atomisp_dev, "find_vma failed\n");
-			return i ? : -EFAULT;
-		}
-
-		if (is_vm_hugetlb_page(vma)) {
-			/*
-			i = follow_hugetlb_page(mm, vma, pages, vmas,
-					&start, &nr_pages, i, gup_flags);
-			*/
-			continue;
-		}
-
-		do {
-			struct page *page;
-			unsigned long pfn;
-
-			/*
-			 * If we have a pending SIGKILL, don't keep faulting
-			 * pages and potentially allocating memory.
-			 */
-			if (unlikely(fatal_signal_pending(current))) {
-				dev_err(atomisp_dev,
-					"fatal_signal_pending in %s\n",
-					__func__);
-				return i ? i : -ERESTARTSYS;
-			}
-
-			ret = follow_pfn(vma, start, &pfn);
-			if (ret) {
-				dev_err(atomisp_dev, "follow_pfn() failed\n");
-				return i ? : -EFAULT;
-			}
-
-			page = pfn_to_page(pfn);
-			if (IS_ERR(page))
-				return i ? i : PTR_ERR(page);
-			if (pages) {
-				pages[i] = page;
-
-				flush_anon_page(vma, page, start);
-				flush_dcache_page(page);
-			}
-			if (vmas)
-				vmas[i] = vma;
-			i++;
-			start += PAGE_SIZE;
-			nr_pages--;
-		} while (nr_pages && start < vma->vm_end);
-	} while (nr_pages);
-	return i;
-}
-
-static int get_pfnmap_pages(struct task_struct *tsk, struct mm_struct *mm,
-		     unsigned long start, int nr_pages, int write, int force,
-		     struct page **pages, struct vm_area_struct **vmas)
-{
-	int flags = FOLL_TOUCH;
-
-	if (pages)
-		flags |= FOLL_GET;
-	if (write)
-		flags |= FOLL_WRITE;
-	if (force)
-		flags |= FOLL_FORCE;
-
-	return __get_pfnmap_pages(tsk, mm, start, nr_pages, flags, pages, vmas);
-}
-
-#ifdef CONFIG_ION
-static int alloc_ion_pages(struct hmm_buffer_object *bo,
-			     unsigned int shared_fd)
-{
-	struct sg_table *sg_tbl;
-	struct scatterlist *sl;
-	int ret, page_nr = 0;
-
-	bo->page_obj = atomisp_kernel_malloc(
-			sizeof(struct hmm_page_object) * bo->pgnr);
-	if (unlikely(!bo->page_obj)) {
-		dev_err(atomisp_dev, "out of memory for bo->page_obj...\n");
-		return -ENOMEM;
-	}
-
-	bo->ihandle = ion_import_dma_buf(bo->bdev->iclient, shared_fd);
-	if (IS_ERR_OR_NULL(bo->ihandle)) {
-		dev_err(atomisp_dev, "invalid shared fd to ion.\n");
-		ret = PTR_ERR(bo->ihandle);
-		if (!bo->ihandle)
-			ret = -EINVAL;
-		goto error;
-	}
-
-	sg_tbl = ion_sg_table(bo->bdev->iclient, bo->ihandle);
-	if (IS_ERR_OR_NULL(sg_tbl)) {
-		dev_err(atomisp_dev, "ion_sg_table error.\n");
-		ret = PTR_ERR(sg_tbl);
-		if (!sg_tbl)
-			ret = -EINVAL;
-		goto error_unmap;
-	}
-
-	sl = sg_tbl->sgl;
-	do {
-		bo->page_obj[page_nr++].page = sg_page(sl);
-		sl = sg_next(sl);
-	} while (sl && page_nr < bo->pgnr);
-
-	if (page_nr != bo->pgnr) {
-		dev_err(atomisp_dev,
-			 "get_ion_pages err: bo->pgnr = %d, "
-			 "pgnr actually pinned = %d.\n",
-			 bo->pgnr, page_nr);
-		ret = -EINVAL;
-		goto error_unmap;
-	}
-
-	return 0;
-error_unmap:
-	ion_free(bo->bdev->iclient, bo->ihandle);
-error:
-	atomisp_kernel_free(bo->page_obj);
-	return ret;
-}
-#endif
-
-/*
- * Convert user space virtual address into pages list
- */
-static int alloc_user_pages(struct hmm_buffer_object *bo,
-			      void *userptr, bool cached)
-{
-	int page_nr;
-	int i;
-	struct vm_area_struct *vma;
-	struct page **pages;
-
-	pages = atomisp_kernel_malloc(sizeof(struct page *) * bo->pgnr);
-	if (unlikely(!pages)) {
-		dev_err(atomisp_dev, "out of memory for pages...\n");
-		return -ENOMEM;
-	}
-
-	bo->page_obj = atomisp_kernel_malloc(
-				sizeof(struct hmm_page_object) * bo->pgnr);
-	if (unlikely(!bo->page_obj)) {
-		dev_err(atomisp_dev, "out of memory for bo->page_obj...\n");
-		atomisp_kernel_free(pages);
-		return -ENOMEM;
-	}
-
-	mutex_unlock(&bo->mutex);
-	down_read(&current->mm->mmap_sem);
-	vma = find_vma(current->mm, (unsigned long)userptr);
-	up_read(&current->mm->mmap_sem);
-	if (vma == NULL) {
-		dev_err(atomisp_dev, "find_vma failed\n");
-		atomisp_kernel_free(bo->page_obj);
-		atomisp_kernel_free(pages);
-		return -EFAULT;
-	}
-	mutex_lock(&bo->mutex);
-	/*
-	 * Handle frame buffer allocated in other kerenl space driver
-	 * and map to user space
-	 */
-	if (vma->vm_flags & (VM_IO | VM_PFNMAP)) {
-		page_nr = get_pfnmap_pages(current, current->mm,
-					   (unsigned long)userptr,
-					   (int)(bo->pgnr), 1, 0,
-					   pages, NULL);
-		bo->mem_type = HMM_BO_MEM_TYPE_PFN;
-	} else {
-		/*Handle frame buffer allocated in user space*/
-		mutex_unlock(&bo->mutex);
-		down_read(&current->mm->mmap_sem);
-		page_nr = get_user_pages(current, current->mm,
-					 (unsigned long)userptr,
-					 (int)(bo->pgnr), 1, 0, pages,
-					 NULL);
-		up_read(&current->mm->mmap_sem);
-		mutex_lock(&bo->mutex);
-		bo->mem_type = HMM_BO_MEM_TYPE_USER;
-	}
-
-	/* can be written by caller, not forced */
-	if (page_nr != bo->pgnr) {
-		dev_err(atomisp_dev,
-				"get_user_pages err: bo->pgnr = %d, "
-				"pgnr actually pinned = %d.\n",
-				bo->pgnr, page_nr);
-		goto out_of_mem;
-	}
-
-	for (i = 0; i < bo->pgnr; i++) {
-		bo->page_obj[i].page = pages[i];
-		bo->page_obj[i].type = HMM_PAGE_TYPE_GENERAL;
-	}
-
-	atomisp_kernel_free(pages);
-
-	return 0;
-
-out_of_mem:
-	if (bo->mem_type == HMM_BO_MEM_TYPE_USER)
-		for (i = 0; i < page_nr; i++)
-			put_page(pages[i]);
-	atomisp_kernel_free(pages);
-	atomisp_kernel_free(bo->page_obj);
-
-	return -ENOMEM;
-}
-#ifdef CONFIG_ION
-static void free_ion_pages(struct hmm_buffer_object *bo)
-{
-	atomisp_kernel_free(bo->page_obj);
-	ion_free(bo->bdev->iclient, bo->ihandle);
-}
-#endif
-
-static void free_user_pages(struct hmm_buffer_object *bo)
-{
-	int i;
-
-	if (bo->mem_type == HMM_BO_MEM_TYPE_USER)
-		for (i = 0; i < bo->pgnr; i++)
-			put_page(bo->page_obj[i].page);
-
-	atomisp_kernel_free(bo->page_obj);
-}
-
-/*
- * allocate/free physical pages for the bo.
- *
- * type indicate where are the pages from. currently we have 3 types
- * of memory: HMM_BO_PRIVATE, HMM_BO_USER, HMM_BO_SHARE.
- *
- * from_highmem is only valid when type is HMM_BO_PRIVATE, it will
- * try to alloc memory from highmem if from_highmem is set.
- *
- * userptr is only valid when type is HMM_BO_USER, it indicates
- * the start address from user space task.
- *
- * from_highmem and userptr will both be ignored when type is
- * HMM_BO_SHARE.
- */
-int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
-		       enum hmm_bo_type type, int from_highmem,
-		       void *userptr, bool cached)
-{
-	int ret;
-
-	check_bo_null_return(bo, -EINVAL);
-
-	mutex_lock(&bo->mutex);
-
-	check_bo_status_no_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
-
-	/*
-	 * TO DO:
-	 * add HMM_BO_USER type
-	 */
-	if (type == HMM_BO_PRIVATE)
-		ret = alloc_private_pages(bo, from_highmem,
-				cached, &dynamic_pool, &reserved_pool);
-	else if (type == HMM_BO_USER)
-		ret = alloc_user_pages(bo, userptr, cached);
-#ifdef CONFIG_ION
-	else if (type == HMM_BO_ION)
-		/*
-		 * TODO:
-		 * Add cache flag when ION support it
-		 */
-		ret = alloc_ion_pages(bo, userptr);
-#endif
-	else {
-		dev_err(atomisp_dev, "invalid buffer type.\n");
-		ret = -EINVAL;
-	}
-
-	if (ret)
-		goto alloc_err;
-
-	bo->type = type;
-
-	bo->status |= HMM_BO_PAGE_ALLOCED;
-
-	mutex_unlock(&bo->mutex);
-
-	return 0;
-
-alloc_err:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev, "alloc pages err...\n");
-	return ret;
-status_err:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-			"buffer object has already page allocated.\n");
-	return -EINVAL;
-}
-
-/*
- * free physical pages of the bo.
- */
-void hmm_bo_free_pages(struct hmm_buffer_object *bo)
-{
-	check_bo_null_return_void(bo);
-
-	mutex_lock(&bo->mutex);
-
-	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err2);
-
-	/* clear the flag anyway. */
-	bo->status &= (~HMM_BO_PAGE_ALLOCED);
-
-	if (bo->type == HMM_BO_PRIVATE)
-		free_private_pages(bo, &dynamic_pool, &reserved_pool);
-	else if (bo->type == HMM_BO_USER)
-		free_user_pages(bo);
-#ifdef CONFIG_ION
-	else if (bo->type == HMM_BO_ION)
-		free_ion_pages(bo);
-#endif
-	else
-		dev_err(atomisp_dev, "invalid buffer type.\n");
-	mutex_unlock(&bo->mutex);
-
-	return;
-
-status_err2:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-			"buffer object not page allocated yet.\n");
-}
-
-int hmm_bo_page_allocated(struct hmm_buffer_object *bo)
-{
-	int ret;
-
-	check_bo_null_return(bo, 0);
-
-	ret = bo->status & HMM_BO_PAGE_ALLOCED;
-
-	return ret;
-}
-
-/*
- * get physical page info of the bo.
- */
-int hmm_bo_get_page_info(struct hmm_buffer_object *bo,
-			 struct hmm_page_object **page_obj, int *pgnr)
-{
-	check_bo_null_return(bo, -EINVAL);
-
-	mutex_lock(&bo->mutex);
-
-	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
-
-	*page_obj = bo->page_obj;
-	*pgnr = bo->pgnr;
-
-	mutex_unlock(&bo->mutex);
-
-	return 0;
-
-status_err:
-	dev_err(atomisp_dev,
-			"buffer object not page allocated yet.\n");
-	mutex_unlock(&bo->mutex);
-	return -EINVAL;
-}
-
-/*
- * bind the physical pages to a virtual address space.
- */
-int hmm_bo_bind(struct hmm_buffer_object *bo)
-{
-	int ret;
-	unsigned int virt;
-	struct hmm_bo_device *bdev;
-	unsigned int i;
-
-	check_bo_null_return(bo, -EINVAL);
-
-	mutex_lock(&bo->mutex);
-
-	check_bo_status_yes_goto(bo,
-				   HMM_BO_PAGE_ALLOCED | HMM_BO_VM_ALLOCED,
-				   status_err1);
-
-	check_bo_status_no_goto(bo, HMM_BO_BINDED, status_err2);
-
-	bdev = bo->bdev;
-
-	virt = bo->vm_node->start;
-
-	for (i = 0; i < bo->pgnr; i++) {
-		ret =
-		    isp_mmu_map(&bdev->mmu, virt,
-				page_to_phys(bo->page_obj[i].page), 1);
-		if (ret)
-			goto map_err;
-		virt += (1 << PAGE_SHIFT);
-	}
-
-	/*
-	 * flush TBL here.
-	 *
-	 * theoretically, we donot need to flush TLB as we didnot change
-	 * any existed address mappings, but for Silicon Hive's MMU, its
-	 * really a bug here. I guess when fetching PTEs (page table entity)
-	 * to TLB, its MMU will fetch additional INVALID PTEs automatically
-	 * for performance issue. EX, we only set up 1 page address mapping,
-	 * meaning updating 1 PTE, but the MMU fetches 4 PTE at one time,
-	 * so the additional 3 PTEs are invalid.
-	 */
-#ifdef CSS20
-	if (bo->vm_node->start != 0x0)
-#endif /* CSS20 */
-		isp_mmu_flush_tlb_range(&bdev->mmu, bo->vm_node->start,
-						(bo->pgnr << PAGE_SHIFT));
-
-	bo->status |= HMM_BO_BINDED;
-
-	mutex_unlock(&bo->mutex);
-
-	return 0;
-
-map_err:
-	/* unbind the physical pages with related virtual address space */
-	virt = bo->vm_node->start;
-	for (; i > 0; i--) {
-		isp_mmu_unmap(&bdev->mmu, virt, 1);
-		virt += pgnr_to_size(1);
-	}
-
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-			"setup MMU address mapping failed.\n");
-	return ret;
-
-status_err2:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev, "buffer object already binded.\n");
-	return -EINVAL;
-status_err1:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-		     "buffer object vm_node or page not allocated.\n");
-	return -EINVAL;
-}
-
-/*
- * unbind the physical pages with related virtual address space.
- */
-void hmm_bo_unbind(struct hmm_buffer_object *bo)
-{
-	unsigned int virt;
-	struct hmm_bo_device *bdev;
-	unsigned int i;
-
-	check_bo_null_return_void(bo);
-
-	mutex_lock(&bo->mutex);
-
-	check_bo_status_yes_goto(bo,
-				   HMM_BO_PAGE_ALLOCED |
-				   HMM_BO_VM_ALLOCED |
-				   HMM_BO_BINDED, status_err);
-
-	bdev = bo->bdev;
-
-	virt = bo->vm_node->start;
-
-	for (i = 0; i < bo->pgnr; i++) {
-		isp_mmu_unmap(&bdev->mmu, virt, 1);
-		virt += pgnr_to_size(1);
-	}
-
-	/*
-	 * flush TLB as the address mapping has been removed and
-	 * related TLBs should be invalidated.
-	 */
-	isp_mmu_flush_tlb_range(&bdev->mmu, bo->vm_node->start,
-				(bo->pgnr << PAGE_SHIFT));
-
-	bo->status &= (~HMM_BO_BINDED);
-
-	mutex_unlock(&bo->mutex);
-
-	return;
-
-status_err:
-	mutex_unlock(&bo->mutex);
-	dev_err(atomisp_dev,
-		     "buffer vm or page not allocated or not binded yet.\n");
-}
-
-int hmm_bo_binded(struct hmm_buffer_object *bo)
-{
-	int ret;
-
-	check_bo_null_return(bo, 0);
-
-	mutex_lock(&bo->mutex);
-
-	ret = bo->status & HMM_BO_BINDED;
-
-	mutex_unlock(&bo->mutex);
-
-	return ret;
-}
-
-void *hmm_bo_vmap(struct hmm_buffer_object *bo)
-{
-	struct page **pages;
-	int i;
-
-	check_bo_null_return(bo, NULL);
-
-	mutex_lock(&bo->mutex);
-	if (bo->status & HMM_BO_VMAPED) {
-		mutex_unlock(&bo->mutex);
-		return bo->vmap_addr;
-	}
-
-	pages = atomisp_kernel_malloc(sizeof(*pages) * bo->pgnr);
-	if (unlikely(!pages)) {
-		mutex_unlock(&bo->mutex);
-		dev_err(atomisp_dev, "out of memory for pages...\n");
-		return NULL;
-	}
-
-	for (i = 0; i < bo->pgnr; i++)
-		pages[i] = bo->page_obj[i].page;
-
-	bo->vmap_addr = vmap(pages, bo->pgnr, VM_MAP, PAGE_KERNEL_NOCACHE);
-	if (unlikely(!bo->vmap_addr)) {
-		mutex_unlock(&bo->mutex);
-		dev_err(atomisp_dev, "vmap failed...\n");
-		return NULL;
-	}
-	bo->status |= HMM_BO_VMAPED;
-
-	atomisp_kernel_free(pages);
-
-	mutex_unlock(&bo->mutex);
-	return bo->vmap_addr;
-}
-
-void hmm_bo_vunmap(struct hmm_buffer_object *bo)
-{
-	check_bo_null_return_void(bo);
-
-	mutex_lock(&bo->mutex);
-	if (bo->status & HMM_BO_VMAPED) {
-		vunmap(bo->vmap_addr);
-		bo->vmap_addr = NULL;
-		bo->status &= ~HMM_BO_VMAPED;
-	}
-
-	mutex_unlock(&bo->mutex);
-	return;
-}
-
-void hmm_bo_ref(struct hmm_buffer_object *bo)
-{
-	check_bo_null_return_void(bo);
-
-	kref_get(&bo->kref);
-}
-
-static void kref_hmm_bo_release(struct kref *kref)
-{
-	if (!kref)
-		return;
-
-	hmm_bo_release(kref_to_hmm_bo(kref));
-}
-
-void hmm_bo_unref(struct hmm_buffer_object *bo)
-{
-	check_bo_null_return_void(bo);
-
-	kref_put(&bo->kref, kref_hmm_bo_release);
-}
-
-static void hmm_bo_vm_open(struct vm_area_struct *vma)
-{
-	struct hmm_buffer_object *bo =
-	    (struct hmm_buffer_object *)vma->vm_private_data;
-
-	check_bo_null_return_void(bo);
-
-	hmm_bo_ref(bo);
-
-	mutex_lock(&bo->mutex);
-
-	bo->status |= HMM_BO_MMAPED;
-
-	bo->mmap_count++;
-
-	mutex_unlock(&bo->mutex);
-}
-
-static void hmm_bo_vm_close(struct vm_area_struct *vma)
-{
-	struct hmm_buffer_object *bo =
-	    (struct hmm_buffer_object *)vma->vm_private_data;
-
-	check_bo_null_return_void(bo);
-
-	hmm_bo_unref(bo);
-
-	mutex_lock(&bo->mutex);
-
-	bo->mmap_count--;
-
-	if (!bo->mmap_count) {
-		bo->status &= (~HMM_BO_MMAPED);
-		vma->vm_private_data = NULL;
-	}
-
-	mutex_unlock(&bo->mutex);
-}
-
-static const struct vm_operations_struct hmm_bo_vm_ops = {
-	.open = hmm_bo_vm_open,
-	.close = hmm_bo_vm_close,
-};
-
-/*
- * mmap the bo to user space.
- */
-int hmm_bo_mmap(struct vm_area_struct *vma, struct hmm_buffer_object *bo)
-{
-	unsigned int start, end;
-	unsigned int virt;
-	unsigned int pgnr, i;
-	unsigned int pfn;
-
-	check_bo_null_return(bo, -EINVAL);
-
-	check_bo_status_yes_goto(bo, HMM_BO_PAGE_ALLOCED, status_err);
-
-	pgnr = bo->pgnr;
-	start = vma->vm_start;
-	end = vma->vm_end;
-
-	/*
-	 * check vma's virtual address space size and buffer object's size.
-	 * must be the same.
-	 */
-	if ((start + pgnr_to_size(pgnr)) != end) {
-		dev_warn(atomisp_dev,
-			     "vma's address space size not equal"
-			     " to buffer object's size");
-		return -EINVAL;
-	}
-
-	virt = vma->vm_start;
-	for (i = 0; i < pgnr; i++) {
-		pfn = page_to_pfn(bo->page_obj[i].page);
-		if (remap_pfn_range(vma, virt, pfn, PAGE_SIZE, PAGE_SHARED)) {
-			dev_warn(atomisp_dev,
-					"remap_pfn_range failed:"
-					" virt = 0x%x, pfn = 0x%x,"
-					" mapped_pgnr = %d\n", virt, pfn, 1);
-			return -EINVAL;
-		}
-		virt += PAGE_SIZE;
-	}
-
-	vma->vm_private_data = bo;
-
-	vma->vm_ops = &hmm_bo_vm_ops;
-	vma->vm_flags |= VM_IO|VM_DONTEXPAND|VM_DONTDUMP;
-
-	/*
-	 * call hmm_bo_vm_open explictly.
-	 */
-	hmm_bo_vm_open(vma);
-
-	return 0;
-
-status_err:
-	dev_err(atomisp_dev, "buffer page not allocated yet.\n");
-	return -EINVAL;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo_dev.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo_dev.c
deleted file mode 100644
index 79ac4fd..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_bo_dev.c
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/gfp.h>
-#include <linux/mm.h>		/* for GFP_ATOMIC */
-#include <linux/slab.h>		/* for kmalloc */
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/string.h>
-#include <linux/list.h>
-#include <linux/errno.h>
-
-#ifdef CONFIG_ION
-#include <linux/ion.h>
-#endif
-
-#include "atomisp_internal.h"
-#include "hmm/hmm_common.h"
-#include "hmm/hmm_bo_dev.h"
-#include "hmm/hmm_bo.h"
-
-/*
- * hmm_bo_device functions.
- */
-int hmm_bo_device_init(struct hmm_bo_device *bdev,
-		       struct isp_mmu_client *mmu_driver,
-		       unsigned int vaddr_start, unsigned int size)
-{
-	int ret;
-
-	check_bodev_null_return(bdev, -EINVAL);
-
-	ret = isp_mmu_init(&bdev->mmu, mmu_driver);
-	if (ret) {
-		dev_err(atomisp_dev, "isp_mmu_init failed.\n");
-		goto isp_mmu_init_err;
-	}
-
-	ret = hmm_vm_init(&bdev->vaddr_space, vaddr_start, size);
-	if (ret) {
-		dev_err(atomisp_dev, "hmm_vm_init falied. vaddr_start = 0x%x, size = %d\n",
-			vaddr_start, size);
-		goto vm_init_err;
-	}
-
-	INIT_LIST_HEAD(&bdev->free_bo_list);
-	INIT_LIST_HEAD(&bdev->active_bo_list);
-
-	spin_lock_init(&bdev->list_lock);
-#ifdef CONFIG_ION
-	/*
-	 * TODO:
-	 * The ion_dev should be defined by ION driver. But ION driver does
-	 * not implement it yet, will fix it when it is ready.
-	 */
-	if (!ion_dev)
-		goto vm_init_err;
-
-	bdev->iclient = ion_client_create(ion_dev, "atomisp");
-	if (IS_ERR_OR_NULL(bdev->iclient)) {
-		ret = PTR_ERR(bdev->iclient);
-		if (!bdev->iclient)
-			ret = -EINVAL;
-		goto vm_init_err;
-	}
-#endif
-	bdev->flag = HMM_BO_DEVICE_INITED;
-
-	return 0;
-
-vm_init_err:
-	isp_mmu_exit(&bdev->mmu);
-isp_mmu_init_err:
-	return ret;
-}
-
-void hmm_bo_device_exit(struct hmm_bo_device *bdev)
-{
-	check_bodev_null_return_void(bdev);
-
-	/*
-	 * destroy all bos in the bo list, even they are in use.
-	 */
-	if (!list_empty(&bdev->active_bo_list))
-		dev_warn(atomisp_dev,
-			     "there're still activated bo in use. "
-			     "force to free them.\n");
-
-	while (!list_empty(&bdev->active_bo_list))
-		hmm_bo_unref(list_to_hmm_bo(bdev->active_bo_list.next));
-
-	if (!list_empty(&bdev->free_bo_list))
-		dev_warn(atomisp_dev,
-				"there're still bo in free_bo_list. "
-				"force to free them.\n");
-
-	while (!list_empty(&bdev->free_bo_list))
-		hmm_bo_unref(list_to_hmm_bo(bdev->free_bo_list.next));
-
-	isp_mmu_exit(&bdev->mmu);
-	hmm_vm_clean(&bdev->vaddr_space);
-#ifdef CONFIG_ION
-	if (bdev->iclient != NULL)
-		ion_client_destroy(bdev->iclient);
-#endif
-}
-
-void hmm_bo_device_cleanup_mmu_l2(struct hmm_bo_device *bdev)
-{
-	check_bodev_null_return_void(bdev);
-
-	isp_mmu_clean_l2(&bdev->mmu);
-}
-
-int hmm_bo_device_inited(struct hmm_bo_device *bdev)
-{
-	check_bodev_null_return(bdev, -EINVAL);
-
-	return bdev->flag == HMM_BO_DEVICE_INITED;
-}
-
-/*
- * find the buffer object with virtual address vaddr.
- * return NULL if no such buffer object found.
- */
-struct hmm_buffer_object *hmm_bo_device_search_start(struct hmm_bo_device *bdev,
-						     ia_css_ptr vaddr)
-{
-	struct list_head *pos;
-	struct hmm_buffer_object *bo;
-	unsigned long flags;
-
-	check_bodev_null_return(bdev, NULL);
-
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_for_each(pos, &bdev->active_bo_list) {
-		bo = list_to_hmm_bo(pos);
-		/* pass bo which has no vm_node allocated */
-		if (!hmm_bo_vm_allocated(bo))
-			continue;
-		if (bo->vm_node->start == vaddr)
-			goto found;
-	}
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return NULL;
-found:
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return bo;
-}
-
-static int in_range(unsigned int start, unsigned int size, unsigned int addr)
-{
-	return (start <= addr) && (start + size > addr);
-}
-
-struct hmm_buffer_object *hmm_bo_device_search_in_range(struct hmm_bo_device
-							*bdev,
-							unsigned int vaddr)
-{
-	struct list_head *pos;
-	struct hmm_buffer_object *bo;
-	unsigned long flags;
-
-	check_bodev_null_return(bdev, NULL);
-
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_for_each(pos, &bdev->active_bo_list) {
-		bo = list_to_hmm_bo(pos);
-		/* pass bo which has no vm_node allocated */
-		if (!hmm_bo_vm_allocated(bo))
-			continue;
-		if (in_range(bo->vm_node->start, bo->vm_node->size, vaddr))
-			goto found;
-	}
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return NULL;
-found:
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return bo;
-}
-
-struct hmm_buffer_object *
-hmm_bo_device_search_vmap_start(struct hmm_bo_device *bdev, const void *vaddr)
-{
-	struct list_head *pos;
-	struct hmm_buffer_object *bo;
-	unsigned long flags;
-
-	check_bodev_null_return(bdev, NULL);
-
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_for_each(pos, &bdev->active_bo_list) {
-		bo = list_to_hmm_bo(pos);
-		/* pass bo which has no vm_node allocated */
-		if (!hmm_bo_vm_allocated(bo))
-			continue;
-		if (bo->vmap_addr == vaddr)
-			goto found;
-	}
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return NULL;
-found:
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return bo;
-}
-
-/*
- * find a buffer object with pgnr pages from free_bo_list and
- * activate it (remove from free_bo_list and add to
- * active_bo_list)
- *
- * return NULL if no such buffer object found.
- */
-struct hmm_buffer_object *hmm_bo_device_get_bo(struct hmm_bo_device *bdev,
-					       unsigned int pgnr)
-{
-	struct list_head *pos;
-	struct hmm_buffer_object *bo;
-	unsigned long flags;
-
-	check_bodev_null_return(bdev, NULL);
-
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_for_each(pos, &bdev->free_bo_list) {
-		bo = list_to_hmm_bo(pos);
-		if (bo->pgnr == pgnr)
-			goto found;
-	}
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return NULL;
-found:
-	list_del(&bo->list);
-	list_add(&bo->list, &bdev->active_bo_list);
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-
-	return bo;
-}
-
-/*
- * destroy all buffer objects in the free_bo_list.
- */
-void hmm_bo_device_destroy_free_bo_list(struct hmm_bo_device *bdev)
-{
-	struct hmm_buffer_object *bo, *tmp;
-	unsigned long flags;
-	struct list_head new_head;
-
-	check_bodev_null_return_void(bdev);
-
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_replace_init(&bdev->free_bo_list, &new_head);
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-
-	list_for_each_entry_safe(bo, tmp, &new_head, list) {
-		list_del(&bo->list);
-		hmm_bo_unref(bo);
-	}
-}
-
-/*
- * destroy buffer object with start virtual address vaddr.
- */
-void hmm_bo_device_destroy_free_bo_addr(struct hmm_bo_device *bdev,
-					unsigned int vaddr)
-{
-	struct list_head *pos;
-	struct hmm_buffer_object *bo;
-	unsigned long flags;
-
-	check_bodev_null_return_void(bdev);
-
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_for_each(pos, &bdev->free_bo_list) {
-		bo = list_to_hmm_bo(pos);
-		/* pass bo which has no vm_node allocated */
-		if (!hmm_bo_vm_allocated(bo))
-			continue;
-		if (bo->vm_node->start == vaddr)
-			goto found;
-	}
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return;
-found:
-	list_del(&bo->list);
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	hmm_bo_unref(bo);
-}
-
-/*
- * destroy all buffer objects with pgnr pages.
- */
-void hmm_bo_device_destroy_free_bo_size(struct hmm_bo_device *bdev,
-					unsigned int pgnr)
-{
-	struct list_head *pos;
-	struct hmm_buffer_object *bo;
-	unsigned long flags;
-
-	check_bodev_null_return_void(bdev);
-
-retry:
-	spin_lock_irqsave(&bdev->list_lock, flags);
-	list_for_each(pos, &bdev->free_bo_list) {
-		bo = list_to_hmm_bo(pos);
-		if (bo->pgnr == pgnr)
-			goto found;
-	}
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	return;
-found:
-	list_del(&bo->list);
-	spin_unlock_irqrestore(&bdev->list_lock, flags);
-	hmm_bo_unref(bo);
-	goto retry;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_dynamic_pool.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_dynamic_pool.c
deleted file mode 100644
index 8856a95..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_dynamic_pool.c
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-/*
- * This file contains functions for dynamic memory pool management
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-
-#include "asm/cacheflush.h"
-
-#include "atomisp_internal.h"
-
-#include "hmm/hmm_pool.h"
-
-/*
- * dynamic memory pool ops.
- */
-static unsigned int get_pages_from_dynamic_pool(void *pool,
-					struct hmm_page_object *page_obj,
-					unsigned int size, bool cached)
-{
-	struct hmm_page *hmm_page;
-	unsigned long flags;
-	unsigned int i = 0;
-	struct hmm_dynamic_pool_info *dypool_info = pool;
-
-	if (!dypool_info)
-		return 0;
-
-	spin_lock_irqsave(&dypool_info->list_lock, flags);
-	if (dypool_info->initialized) {
-		while (!list_empty(&dypool_info->pages_list)) {
-			hmm_page = list_entry(dypool_info->pages_list.next,
-						struct hmm_page, list);
-
-			list_del(&hmm_page->list);
-			dypool_info->pgnr--;
-			spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-
-			page_obj[i].page = hmm_page->page;
-			page_obj[i++].type = HMM_PAGE_TYPE_DYNAMIC;
-#ifdef USE_KMEM_CACHE
-			kmem_cache_free(dypool_info->pgptr_cache, hmm_page);
-#else
-			atomisp_kernel_free(hmm_page);
-#endif
-
-			if (i == size)
-				return i;
-
-			spin_lock_irqsave(&dypool_info->list_lock, flags);
-		}
-	}
-	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-
-	return i;
-}
-
-static void free_pages_to_dynamic_pool(void *pool,
-					struct hmm_page_object *page_obj)
-{
-	struct hmm_page *hmm_page;
-	unsigned long flags;
-	int ret;
-	struct hmm_dynamic_pool_info *dypool_info = pool;
-
-	if (!dypool_info)
-		return;
-
-	spin_lock_irqsave(&dypool_info->list_lock, flags);
-	if (!dypool_info->initialized) {
-		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-		return;
-	}
-	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-
-	if (page_obj->type == HMM_PAGE_TYPE_RESERVED)
-		return;
-
-	if (dypool_info->pgnr >= dypool_info->pool_size) {
-		/* free page directly back to system */
-		ret = set_pages_wb(page_obj->page, 1);
-		if (ret)
-			dev_err(atomisp_dev, "set page to WB err ...\n");
-		__free_pages(page_obj->page, 0);
-
-		return;
-	}
-#ifdef USE_KMEM_CACHE
-	hmm_page = kmem_cache_zalloc(dypool_info->pgptr_cache,
-						GFP_KERNEL);
-#else
-	hmm_page = atomisp_kernel_malloc(sizeof(struct hmm_page));
-#endif
-	if (!hmm_page) {
-		dev_err(atomisp_dev, "out of memory for hmm_page.\n");
-
-		/* free page directly */
-		ret = set_pages_wb(page_obj->page, 1);
-		if (ret)
-			dev_err(atomisp_dev, "set page to WB err ...\n");
-		__free_pages(page_obj->page, 0);
-
-		return;
-	}
-
-	hmm_page->page = page_obj->page;
-
-	/*
-	 * add to pages_list of pages_pool
-	 */
-	spin_lock_irqsave(&dypool_info->list_lock, flags);
-	list_add_tail(&hmm_page->list, &dypool_info->pages_list);
-	dypool_info->pgnr++;
-	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-}
-
-static int hmm_dynamic_pool_init(void **pool, unsigned int pool_size)
-{
-	struct hmm_dynamic_pool_info *dypool_info;
-
-	if (pool_size == 0)
-		return 0;
-
-	dypool_info = atomisp_kernel_malloc(
-					sizeof(struct hmm_dynamic_pool_info));
-	if (unlikely(!dypool_info)) {
-		dev_err(atomisp_dev, "out of memory for repool_info.\n");
-		return -ENOMEM;
-	}
-
-#ifdef USE_KMEM_CACHE
-	dypool_info->pgptr_cache = kmem_cache_create("pgptr_cache",
-						sizeof(struct hmm_page), 0,
-						SLAB_HWCACHE_ALIGN, NULL);
-	if (!dypool_info->pgptr_cache) {
-		atomisp_kernel_free(dypool_info);
-		return -ENOMEM;
-	}
-#endif
-
-	INIT_LIST_HEAD(&dypool_info->pages_list);
-	spin_lock_init(&dypool_info->list_lock);
-	dypool_info->initialized = true;
-	dypool_info->pool_size = pool_size;
-	dypool_info->pgnr = 0;
-
-	*pool = dypool_info;
-
-	return 0;
-}
-
-static void hmm_dynamic_pool_exit(void **pool)
-{
-	struct hmm_dynamic_pool_info *dypool_info = *pool;
-	struct hmm_page *hmm_page;
-	unsigned long flags;
-	int ret;
-
-	if (!dypool_info)
-		return;
-
-	spin_lock_irqsave(&dypool_info->list_lock, flags);
-	if (!dypool_info->initialized) {
-		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-		return;
-	}
-	dypool_info->initialized = false;
-
-	while (!list_empty(&dypool_info->pages_list)) {
-		hmm_page = list_entry(dypool_info->pages_list.next,
-					struct hmm_page, list);
-
-		list_del(&hmm_page->list);
-		spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-
-		/* can cause thread sleep, so cannot be put into spin_lock */
-		ret = set_pages_wb(hmm_page->page, 1);
-		if (ret)
-			dev_err(atomisp_dev, "set page to WB err...\n");
-		__free_pages(hmm_page->page, 0);
-
-#ifdef USE_KMEM_CACHE
-		kmem_cache_free(dypool_info->pgptr_cache, hmm_page);
-#else
-		atomisp_kernel_free(hmm_page);
-#endif
-		spin_lock_irqsave(&dypool_info->list_lock, flags);
-	}
-
-	spin_unlock_irqrestore(&dypool_info->list_lock, flags);
-
-#ifdef USE_KMEM_CACHE
-	kmem_cache_destroy(dypool_info->pgptr_cache);
-#endif
-
-	atomisp_kernel_free(dypool_info);
-
-	*pool = NULL;
-}
-
-static int hmm_dynamic_pool_inited(void *pool)
-{
-	struct hmm_dynamic_pool_info *dypool_info = pool;
-
-	if (!dypool_info)
-		return 0;
-
-	return dypool_info->initialized;
-}
-
-struct hmm_pool_ops dynamic_pops = {
-	.pool_init		= hmm_dynamic_pool_init,
-	.pool_exit		= hmm_dynamic_pool_exit,
-	.pool_alloc_pages	= get_pages_from_dynamic_pool,
-	.pool_free_pages	= free_pages_to_dynamic_pool,
-	.pool_inited		= hmm_dynamic_pool_inited,
-};
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_reserved_pool.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_reserved_pool.c
deleted file mode 100644
index 5ae69a3..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_reserved_pool.c
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-/*
- * This file contains functions for reserved memory pool management
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-
-#include "asm/cacheflush.h"
-#include "atomisp_internal.h"
-#include "hmm/hmm_pool.h"
-
-/*
- * reserved memory pool ops.
- */
-static unsigned int get_pages_from_reserved_pool(void *pool,
-					struct hmm_page_object *page_obj,
-					unsigned int size, bool cached)
-{
-	unsigned long flags;
-	unsigned int i = 0;
-	unsigned int repool_pgnr;
-	int j;
-	struct hmm_reserved_pool_info *repool_info = pool;
-
-	if (!repool_info)
-		return 0;
-
-	spin_lock_irqsave(&repool_info->list_lock, flags);
-	if (repool_info->initialized) {
-		repool_pgnr = repool_info->index;
-
-		for (j = repool_pgnr-1; j >= 0; j--) {
-			page_obj[i].page = repool_info->pages[j];
-			page_obj[i].type = HMM_PAGE_TYPE_RESERVED;
-			i++;
-			repool_info->index--;
-			if (i == size)
-				break;
-		}
-	}
-	spin_unlock_irqrestore(&repool_info->list_lock, flags);
-	return i;
-}
-
-static void free_pages_to_reserved_pool(void *pool,
-					struct hmm_page_object *page_obj)
-{
-	unsigned long flags;
-	struct hmm_reserved_pool_info *repool_info = pool;
-
-	if (!repool_info)
-		return;
-
-	spin_lock_irqsave(&repool_info->list_lock, flags);
-
-	if (repool_info->initialized &&
-	    repool_info->index < repool_info->pgnr &&
-	    page_obj->type == HMM_PAGE_TYPE_RESERVED) {
-		repool_info->pages[repool_info->index++] = page_obj->page;
-	}
-
-	spin_unlock_irqrestore(&repool_info->list_lock, flags);
-}
-
-static int hmm_reserved_pool_setup(struct hmm_reserved_pool_info **repool_info,
-					unsigned int pool_size)
-{
-	struct hmm_reserved_pool_info *pool_info;
-
-	pool_info = atomisp_kernel_malloc(
-					sizeof(struct hmm_reserved_pool_info));
-	if (unlikely(!pool_info)) {
-		dev_err(atomisp_dev, "out of memory for repool_info.\n");
-		return -ENOMEM;
-	}
-
-	pool_info->pages = atomisp_kernel_malloc(
-					sizeof(struct page *) * pool_size);
-	if (unlikely(!pool_info->pages)) {
-		dev_err(atomisp_dev, "out of memory for repool_info->pages.\n");
-		atomisp_kernel_free(pool_info);
-		return -ENOMEM;
-	}
-
-	pool_info->index = 0;
-	pool_info->pgnr = 0;
-	spin_lock_init(&pool_info->list_lock);
-	pool_info->initialized = true;
-
-	*repool_info = pool_info;
-
-	return 0;
-}
-
-static int hmm_reserved_pool_init(void **pool, unsigned int pool_size)
-{
-	int ret;
-	unsigned int blk_pgnr;
-	unsigned int pgnr = pool_size;
-	unsigned int order = 0;
-	unsigned int i = 0;
-	int fail_number = 0;
-	struct page *pages;
-	int j;
-	struct hmm_reserved_pool_info *repool_info;
-
-	if (pool_size == 0)
-		return 0;
-
-	ret = hmm_reserved_pool_setup(&repool_info, pool_size);
-	if (ret) {
-		dev_err(atomisp_dev, "hmm_reserved_pool_setup failed.\n");
-		return ret;
-	}
-
-	pgnr = pool_size;
-
-	i = 0;
-	order = 0;
-
-	while (pgnr) {
-		pages = alloc_pages(GFP_KERNEL | __GFP_NOWARN, order);
-		if (unlikely(!pages)) {
-			fail_number++;
-			dev_err(atomisp_dev, "%s: alloc_pages failed: %d\n",
-					__func__, fail_number);
-			/* if fail five times, will goto end */
-
-			/* FIXME: whether is the mechanism is ok? */
-			if (fail_number == ALLOC_PAGE_FAIL_NUM)
-				goto end;
-		} else {
-			blk_pgnr = 1U << order;
-
-			ret = set_pages_uc(pages, blk_pgnr);
-			if (ret) {
-				dev_err(atomisp_dev,
-						"set pages uncached failed\n");
-				__free_pages(pages, order);
-				goto end;
-			}
-
-			for (j = 0; j < blk_pgnr; j++)
-				repool_info->pages[i++] = pages + j;
-
-			repool_info->index += blk_pgnr;
-			repool_info->pgnr += blk_pgnr;
-
-			pgnr -= blk_pgnr;
-
-			fail_number = 0;
-		}
-	}
-
-end:
-	repool_info->initialized = true;
-
-	*pool = repool_info;
-
-	dev_info(atomisp_dev,
-			"hmm_reserved_pool init successfully,"
-			"hmm_reserved_pool is with %d pages.\n",
-			repool_info->pgnr);
-	return 0;
-}
-
-static void hmm_reserved_pool_exit(void **pool)
-{
-	unsigned long flags;
-	int i, ret;
-	unsigned int pgnr;
-	struct hmm_reserved_pool_info *repool_info = *pool;
-
-	if (!repool_info)
-		return;
-
-	spin_lock_irqsave(&repool_info->list_lock, flags);
-	if (!repool_info->initialized) {
-		spin_unlock_irqrestore(&repool_info->list_lock, flags);
-		return;
-	}
-	pgnr = repool_info->pgnr;
-	repool_info->index = 0;
-	repool_info->pgnr = 0;
-	repool_info->initialized = false;
-	spin_unlock_irqrestore(&repool_info->list_lock, flags);
-
-	for (i = 0; i < pgnr; i++) {
-		ret = set_pages_wb(repool_info->pages[i], 1);
-		if (ret)
-			dev_err(atomisp_dev, "set page to WB err...\n");
-		__free_pages(repool_info->pages[i], 0);
-	}
-
-	atomisp_kernel_free(repool_info->pages);
-	atomisp_kernel_free(repool_info);
-
-	*pool = NULL;
-}
-
-static int hmm_reserved_pool_inited(void *pool)
-{
-	struct hmm_reserved_pool_info *repool_info = pool;
-
-	if (!repool_info)
-		return 0;
-
-	return repool_info->initialized;
-}
-
-struct hmm_pool_ops reserved_pops = {
-	.pool_init		= hmm_reserved_pool_init,
-	.pool_exit		= hmm_reserved_pool_exit,
-	.pool_alloc_pages	= get_pages_from_reserved_pool,
-	.pool_free_pages	= free_pages_to_reserved_pool,
-	.pool_inited		= hmm_reserved_pool_inited,
-};
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_vm.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_vm.c
deleted file mode 100644
index 0722a68..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hmm/hmm_vm.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-/*
- * This file contains function for ISP virtual address management in ISP driver
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/slab.h>
-#include <asm/page.h>
-
-#include "atomisp_internal.h"
-#include "mmu/isp_mmu.h"
-#include "hmm/hmm_vm.h"
-#include "hmm/hmm_common.h"
-
-static unsigned int vm_node_end(unsigned int start, unsigned int pgnr)
-{
-	return start + pgnr_to_size(pgnr);
-}
-
-static int addr_in_vm_node(unsigned int addr,
-		struct hmm_vm_node *node)
-{
-	return (addr >= node->start) && (addr < (node->start + node->size));
-}
-
-int hmm_vm_init(struct hmm_vm *vm, unsigned int start,
-		unsigned int size)
-{
-	if (!vm)
-		return -1;
-
-	vm->start = start;
-	vm->pgnr = size_to_pgnr_ceil(size);
-	vm->size = pgnr_to_size(vm->pgnr);
-
-	INIT_LIST_HEAD(&vm->vm_node_list);
-	spin_lock_init(&vm->lock);
-	vm->cache = kmem_cache_create("atomisp_vm", sizeof(struct hmm_vm_node),
-				      0, 0, NULL);
-
-	return vm->cache != NULL ? 0 : -ENOMEM;
-}
-
-void hmm_vm_clean(struct hmm_vm *vm)
-{
-	struct hmm_vm_node *node, *tmp;
-	struct list_head new_head;
-
-	if (!vm)
-		return;
-
-	spin_lock(&vm->lock);
-	list_replace_init(&vm->vm_node_list, &new_head);
-	spin_unlock(&vm->lock);
-
-	list_for_each_entry_safe(node, tmp, &new_head, list) {
-		list_del(&node->list);
-		kmem_cache_free(vm->cache, node);
-	}
-
-	kmem_cache_destroy(vm->cache);
-}
-
-static struct hmm_vm_node *alloc_hmm_vm_node(unsigned int pgnr,
-					     struct hmm_vm *vm)
-{
-	struct hmm_vm_node *node;
-
-	node = kmem_cache_alloc(vm->cache, GFP_KERNEL);
-	if (!node) {
-		dev_err(atomisp_dev, "out of memory.\n");
-		return NULL;
-	}
-
-	INIT_LIST_HEAD(&node->list);
-	node->pgnr = pgnr;
-	node->size = pgnr_to_size(pgnr);
-	node->vm = vm;
-
-	return node;
-}
-
-struct hmm_vm_node *hmm_vm_alloc_node(struct hmm_vm *vm, unsigned int pgnr)
-{
-	struct list_head *head;
-	struct hmm_vm_node *node, *cur, *next;
-	unsigned int vm_start, vm_end;
-	unsigned int addr;
-	unsigned int size;
-
-	if (!vm)
-		return NULL;
-
-	vm_start = vm->start;
-	vm_end = vm_node_end(vm->start, vm->pgnr);
-	size = pgnr_to_size(pgnr);
-
-	addr = vm_start;
-	head = &vm->vm_node_list;
-
-	node = alloc_hmm_vm_node(pgnr, vm);
-	if (!node) {
-		dev_err(atomisp_dev, "no memory to allocate hmm vm node.\n");
-		return NULL;
-	}
-
-	spin_lock(&vm->lock);
-	/*
-	 * if list is empty, the loop code will not be executed.
-	 */
-	list_for_each_entry(cur, head, list) {
-		/* Add gap between vm areas as helper to not hide overflow */
-		addr = PAGE_ALIGN(vm_node_end(cur->start, cur->pgnr) + 1);
-
-		if (list_is_last(&cur->list, head)) {
-			if (addr + size > vm_end) {
-				/* vm area does not have space anymore */
-				spin_unlock(&vm->lock);
-				kmem_cache_free(vm->cache, node);
-				dev_err(atomisp_dev,
-					  "no enough virtual address space.\n");
-				return NULL;
-			}
-
-			/* We still have vm space to add new node to tail */
-			break;
-		}
-
-		next = list_entry(cur->list.next, struct hmm_vm_node, list);
-		if ((next->start - addr) > size)
-			break;
-	}
-	node->start = addr;
-	node->vm = vm;
-	list_add(&node->list, &cur->list);
-	spin_unlock(&vm->lock);
-
-	return node;
-}
-
-void hmm_vm_free_node(struct hmm_vm_node *node)
-{
-	struct hmm_vm *vm;
-
-	if (!node)
-		return;
-
-	vm = node->vm;
-
-	spin_lock(&vm->lock);
-	list_del(&node->list);
-	spin_unlock(&vm->lock);
-
-	kmem_cache_free(vm->cache, node);
-}
-
-struct hmm_vm_node *hmm_vm_find_node_start(struct hmm_vm *vm, unsigned int addr)
-{
-	struct hmm_vm_node *node;
-
-	if (!vm)
-		return NULL;
-
-	spin_lock(&vm->lock);
-
-	list_for_each_entry(node, &vm->vm_node_list, list) {
-		if (node->start == addr) {
-			spin_unlock(&vm->lock);
-			return node;
-		}
-	}
-
-	spin_unlock(&vm->lock);
-	return NULL;
-}
-
-struct hmm_vm_node *hmm_vm_find_node_in_range(struct hmm_vm *vm,
-					      unsigned int addr)
-{
-	struct hmm_vm_node *node;
-
-	if (!vm)
-		return NULL;
-
-	spin_lock(&vm->lock);
-
-	list_for_each_entry(node, &vm->vm_node_list, list) {
-		if (addr_in_vm_node(addr, node)) {
-			spin_unlock(&vm->lock);
-			return node;
-		}
-	}
-
-	spin_unlock(&vm->lock);
-	return NULL;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/device_access.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/device_access.c
deleted file mode 100644
index acad4f0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/device_access.c
+++ /dev/null
@@ -1,140 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-#include <hrt/master_port.h>	/* hrt_master_port_load() */
-#ifdef C_RUN
-#include <string.h>				/* memcpy() */
-#endif
-
-/*
- * This is an HRT backend implementation for CSIM
- */
-
-static sys_address		base_address = (sys_address)-1;
-
-void device_set_base_address(
-	const sys_address		base_addr)
-{
-	base_address = base_addr;
-return;
-}
-
-
-sys_address device_get_base_address(void)
-{
-return base_address;
-}
-
-uint8_t device_load_uint8(
-	const hrt_address		addr)
-{
-assert(base_address != (sys_address)-1);
-return hrt_master_port_uload_8(base_address + addr);
-}
-
-uint16_t device_load_uint16(
-	const hrt_address		addr)
-{
-assert(base_address != (sys_address)-1);
-assert((addr & 0x01) == 0);
-return hrt_master_port_uload_16(base_address + addr);
-}
-
-uint32_t device_load_uint32(
-	const hrt_address		addr)
-{
-assert(base_address != (sys_address)-1);
-assert((addr & 0x03) == 0);
-return hrt_master_port_uload_32(base_address + addr);
-}
-
-uint64_t device_load_uint64(
-	const hrt_address		addr)
-{
-assert(base_address != (sys_address)-1);
-assert((addr & 0x07) == 0);
-assert(0);
-return 0;
-}
-
-void device_store_uint8(
-	const hrt_address		addr,
-	const uint8_t			data)
-{
-assert(base_address != (sys_address)-1);
-hrt_master_port_store_8(base_address + addr, data);
-return;
-}
-
-void device_store_uint16(
-	const hrt_address		addr,
-	const uint16_t			data)
-{
-assert(base_address != (sys_address)-1);
-assert((addr & 0x01) == 0);
-hrt_master_port_store_16(base_address + addr, data);
-return;
-}
-
-void device_store_uint32(
-	const hrt_address		addr,
-	const uint32_t			data)
-{
-assert(base_address != (sys_address)-1);
-assert((addr & 0x03) == 0);
-hrt_master_port_store_32(base_address + addr, data);
-return;
-}
-
-void device_store_uint64(
-	const hrt_address		addr,
-	const uint64_t			data)
-{
-assert(base_address != (sys_address)-1);
-assert((addr & 0x07) == 0);
-assert(0);
-(void)data;
-return;
-}
-
-void device_load(
-	const hrt_address		addr,
-	void					*data,
-	const size_t			size)
-{
-assert(base_address != (sys_address)-1);
-#ifndef C_RUN
-	hrt_master_port_load((uint32_t)(base_address + addr), data, size);
-#else
-	memcpy(data, (void *)addr, size);
-#endif
-}
-
-void device_store(
-	const hrt_address		addr,
-	const void				*data,
-	const size_t			size)
-{
-assert(base_address != (sys_address)-1);
-#ifndef C_RUN
-	hrt_master_port_store((uint32_t)(base_address + addr), data, size);
-#else
-	memcpy((void *)addr, data, size);
-#endif
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_custom_host_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_custom_host_hrt.h
deleted file mode 100644
index 46a5d29..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_custom_host_hrt.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef _hive_isp_css_custom_host_hrt_h_
-#define _hive_isp_css_custom_host_hrt_h_
-
-#include <linux/delay.h>
-#include "atomisp_helper.h"
-
-/*
- * _hrt_master_port_store/load/uload -macros using __force attributed
- * cast to intentional dereferencing __iomem attributed (noderef)
- * pointer from atomisp_get_io_virt_addr
- */
-#define _hrt_master_port_store_8(a, d) \
-	(*((s8 __force *)atomisp_get_io_virt_addr(a)) = (d))
-
-#define _hrt_master_port_store_16(a, d) \
-	(*((s16 __force *)atomisp_get_io_virt_addr(a)) = (d))
-
-#define _hrt_master_port_store_32(a, d) \
-	(*((s32 __force *)atomisp_get_io_virt_addr(a)) = (d))
-
-#define _hrt_master_port_load_8(a) \
-	(*(s8 __force *)atomisp_get_io_virt_addr(a))
-
-#define _hrt_master_port_load_16(a) \
-	(*(s16 __force *)atomisp_get_io_virt_addr(a))
-
-#define _hrt_master_port_load_32(a) \
-	(*(s32 __force *)atomisp_get_io_virt_addr(a))
-
-#define _hrt_master_port_uload_8(a) \
-	(*(u8 __force *)atomisp_get_io_virt_addr(a))
-
-#define _hrt_master_port_uload_16(a) \
-	(*(u16 __force *)atomisp_get_io_virt_addr(a))
-
-#define _hrt_master_port_uload_32(a) \
-	(*(u32 __force *)atomisp_get_io_virt_addr(a))
-
-#define _hrt_master_port_store_8_volatile(a, d)  _hrt_master_port_store_8(a, d)
-#define _hrt_master_port_store_16_volatile(a, d) _hrt_master_port_store_16(a, d)
-#define _hrt_master_port_store_32_volatile(a, d) _hrt_master_port_store_32(a, d)
-
-#define _hrt_master_port_load_8_volatile(a)      _hrt_master_port_load_8(a)
-#define _hrt_master_port_load_16_volatile(a)     _hrt_master_port_load_16(a)
-#define _hrt_master_port_load_32_volatile(a)     _hrt_master_port_load_32(a)
-
-#define _hrt_master_port_uload_8_volatile(a)     _hrt_master_port_uload_8(a)
-#define _hrt_master_port_uload_16_volatile(a)    _hrt_master_port_uload_16(a)
-#define _hrt_master_port_uload_32_volatile(a)    _hrt_master_port_uload_32(a)
-
-static inline void hrt_sleep(void)
-{
-	udelay(1);
-}
-
-static inline uint32_t _hrt_mem_store(uint32_t to, const void *from, size_t n)
-{
-	unsigned i;
-	uint32_t _to = to;
-	const char *_from = (const char *)from;
-	for (i = 0; i < n; i++, _to++, _from++)
-		_hrt_master_port_store_8(_to, *_from);
-	return _to;
-}
-
-static inline void *_hrt_mem_load(uint32_t from, void *to, size_t n)
-{
-	unsigned i;
-	char *_to = (char *)to;
-	uint32_t _from = from;
-	for (i = 0; i < n; i++, _to++, _from++)
-		*_to = _hrt_master_port_load_8(_from);
-	return _to;
-}
-
-static inline uint32_t _hrt_mem_set(uint32_t to, int c, size_t n)
-{
-	unsigned i;
-	uint32_t _to = to;
-	for (i = 0; i < n; i++, _to++)
-		_hrt_master_port_store_8(_to, c);
-	return _to;
-}
-
-#endif /* _hive_isp_css_custom_host_hrt_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.c
deleted file mode 100644
index a401c68..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include "atomisp_internal.h"
-
-#include "hive_isp_css_mm_hrt.h"
-#include "hmm/hmm.h"
-
-#define __page_align(size)	(((size) + (PAGE_SIZE-1)) & (~(PAGE_SIZE-1)))
-
-static unsigned init_done;
-void hrt_isp_css_mm_init(void)
-{
-	hmm_init();
-	init_done = 1;
-}
-
-int hrt_isp_css_mm_set(ia_css_ptr virt_addr, int c, size_t bytes)
-{
-	if (virt_addr)
-		return hmm_set(virt_addr, c, bytes);
-
-	return -EINVAL;
-}
-
-int hrt_isp_css_mm_load(ia_css_ptr virt_addr, void *data, size_t bytes)
-{
-	if (virt_addr)
-		return hmm_load(virt_addr, data, bytes);
-	return -EINVAL;
-}
-
-int hrt_isp_css_mm_store(ia_css_ptr virt_addr, const void *data, size_t bytes)
-{
-	if (virt_addr)
-		return hmm_store(virt_addr, data, bytes);
-	return -EINVAL;
-}
-
-void hrt_isp_css_mm_free(ia_css_ptr virt_addr)
-{
-	if (virt_addr)
-		hmm_free(virt_addr);
-}
-
-void hrt_isp_css_mm_clear(void)
-{
-	if (init_done) {
-		hmm_cleanup();
-		init_done = 0;
-	}
-}
-
-static void *my_userptr;
-static unsigned my_num_pages;
-static enum hrt_userptr_type my_usr_type;
-
-void hrt_isp_css_mm_set_user_ptr(void *userptr,
-				 unsigned int num_pages,
-				 enum hrt_userptr_type type)
-{
-	my_userptr = userptr;
-	my_num_pages = num_pages;
-	my_usr_type = type;
-}
-
-static ia_css_ptr __hrt_isp_css_mm_alloc(size_t bytes, void *userptr,
-				    unsigned int num_pages,
-				    enum hrt_userptr_type type,
-				    bool cached)
-{
-	if (!init_done)
-		hrt_isp_css_mm_init();
-#ifdef CONFIG_ION
-	if (type == HRT_USR_ION)
-		return hmm_alloc(bytes, HMM_BO_ION, 0,
-					 userptr, cached);
-
-#endif
-	if (type == HRT_USR_PTR) {
-		if (userptr == NULL)
-			return hmm_alloc(bytes, HMM_BO_PRIVATE, 0,
-						 0, cached);
-		else {
-			if (num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
-				dev_err(atomisp_dev,
-					 "user space memory size is less"
-					 " than the expected size..\n");
-			else if (num_pages > ((__page_align(bytes))
-					      >> PAGE_SHIFT))
-				dev_err(atomisp_dev,
-					 "user space memory size is"
-					 " large than the expected size..\n");
-
-			return hmm_alloc(bytes, HMM_BO_USER, 0,
-						 userptr, cached);
-		}
-	} else {
-		dev_err(atomisp_dev, "user ptr type is incorrect.\n");
-		return 0;
-	}
-}
-
-ia_css_ptr hrt_isp_css_mm_alloc(size_t bytes)
-{
-	return __hrt_isp_css_mm_alloc(bytes, my_userptr,
-				      my_num_pages, my_usr_type, false);
-}
-
-ia_css_ptr hrt_isp_css_mm_alloc_user_ptr(size_t bytes, void *userptr,
-				    unsigned int num_pages,
-				    enum hrt_userptr_type type,
-				    bool cached)
-{
-	return __hrt_isp_css_mm_alloc(bytes, userptr, num_pages,
-				      type, cached);
-}
-
-ia_css_ptr hrt_isp_css_mm_alloc_cached(size_t bytes)
-{
-	if (!init_done)
-		hrt_isp_css_mm_init();
-
-	if (my_userptr == NULL)
-		return hmm_alloc(bytes, HMM_BO_PRIVATE, 0, 0,
-						HMM_CACHED);
-	else {
-		if (my_num_pages < ((__page_align(bytes)) >> PAGE_SHIFT))
-			dev_err(atomisp_dev,
-					"user space memory size is less"
-					" than the expected size..\n");
-		else if (my_num_pages > ((__page_align(bytes)) >> PAGE_SHIFT))
-			dev_err(atomisp_dev,
-					"user space memory size is"
-					" large than the expected size..\n");
-
-		return hmm_alloc(bytes, HMM_BO_USER, 0,
-						my_userptr, HMM_CACHED);
-	}
-}
-
-ia_css_ptr hrt_isp_css_mm_calloc(size_t bytes)
-{
-	ia_css_ptr ptr = hrt_isp_css_mm_alloc(bytes);
-	if (!ptr)
-		hmm_set(ptr, 0, bytes);
-	return ptr;
-}
-
-ia_css_ptr hrt_isp_css_mm_calloc_cached(size_t bytes)
-{
-	ia_css_ptr ptr = hrt_isp_css_mm_alloc_cached(bytes);
-	if (!ptr)
-		hmm_set(ptr, 0, bytes);
-	return ptr;
-}
-
-phys_addr_t hrt_isp_css_virt_to_phys(ia_css_ptr virt_addr)
-{
-	return hmm_virt_to_phys(virt_addr);
-}
-
-ia_css_ptr hrt_isp_css_mm_alloc_contiguous(size_t bytes)
-{
-	BUG_ON(false);
-	return 0;
-}
-ia_css_ptr hrt_isp_css_mm_calloc_contiguous(size_t bytes)
-{
-	BUG_ON(false);
-	return 0;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.h
deleted file mode 100644
index 5363c5a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/hive_isp_css_mm_hrt.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _hive_isp_css_mm_hrt_h_
-#define _hive_isp_css_mm_hrt_h_
-
-#ifndef HRT_KERNEL
-/* size_t is defined already in kernel mode */
-#include <stdlib.h>
-#endif
-#include <hmm/hmm.h>
-#include <hrt/hive_isp_css_custom_host_hrt.h>
-
-#define HRT_BUF_FLAG_CACHED (1 << 0)
-
-enum hrt_userptr_type {
-	HRT_USR_PTR = 0,
-#ifdef CONFIG_ION
-	HRT_USR_ION,
-#endif
-};
-
-struct hrt_userbuffer_attr {
-	enum hrt_userptr_type	type;
-	unsigned int		pgnr;
-};
-
-void hrt_isp_css_mm_init(void);
-void hrt_isp_css_mm_set_user_ptr(void *userptr,
-				unsigned int num_pages, enum hrt_userptr_type);
-
-int hrt_isp_css_mm_set(ia_css_ptr virt_addr, int c, size_t bytes);
-
-/* Allocate memory, returns a virtual address */
-ia_css_ptr hrt_isp_css_mm_alloc(size_t bytes);
-ia_css_ptr hrt_isp_css_mm_alloc_user_ptr(size_t bytes, void *userptr,
-				    unsigned int num_pages,
-				    enum hrt_userptr_type,
-				    bool cached);
-ia_css_ptr hrt_isp_css_mm_alloc_cached(size_t bytes);
-
-/* allocate memory and initialize with zeros,
-   returns a virtual address */
-ia_css_ptr hrt_isp_css_mm_calloc(size_t bytes);
-ia_css_ptr hrt_isp_css_mm_calloc_cached(size_t bytes);
-
-/* Free memory, given a virtual address */
-void hrt_isp_css_mm_free(ia_css_ptr virt_addr);
-
-/* Store data to a virtual address */
-int hrt_isp_css_mm_load(ia_css_ptr virt_addr, void *data, size_t bytes);
-
-/* Load data from a virtual address */
-int hrt_isp_css_mm_store(ia_css_ptr virt_addr, const void *data, size_t bytes);
-
-int hrt_isp_css_mm_load_int(ia_css_ptr virt_addr, int *data);
-int hrt_isp_css_mm_load_short(ia_css_ptr virt_addr, short *data);
-int hrt_isp_css_mm_load_char(ia_css_ptr virt_addr, char *data);
-
-int hrt_isp_css_mm_store_char(ia_css_ptr virt_addr, char data);
-int hrt_isp_css_mm_store_short(ia_css_ptr virt_addr, short data);
-int hrt_isp_css_mm_store_int(ia_css_ptr virt_addr, int data);
-
-/* translate a virtual to a physical address, used to program
-   the display driver on  the FPGA system */
-phys_addr_t hrt_isp_css_virt_to_phys(ia_css_ptr virt_addr);
-
-ia_css_ptr hrt_isp_css_mm_alloc_contiguous(size_t bytes);
-ia_css_ptr hrt_isp_css_mm_calloc_contiguous(size_t bytes);
-
-void hrt_isp_css_mm_clear(void);
-#endif /* _hive_isp_css_mm_hrt_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/memory_access.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/memory_access.c
deleted file mode 100644
index b5088d2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/hrt/memory_access.c
+++ /dev/null
@@ -1,383 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include "memory_access.h"
-
-#include <stddef.h>		/* NULL */
-#include <stdbool.h>
-
-#include "device_access.h"
-
-#include "mmu_device.h"
-
-#include "assert_support.h"
-
-/* Presently system specific */
-#include <hmm/hmm.h>
-/* Presently system specific */
-#include "hive_isp_css_mm_hrt.h"
-
-/*
- * This is an HRT backend implementation for CSIM
- * 31 July 2012, rvanimme: this implementation is also used in Android context
- */
-
-static sys_address	page_table_base_address = (sys_address)-1;
-const ia_css_ptr       mmgr_NULL;
-
-#ifndef SH_CSS_MEMORY_GUARDING
-/* Choose default in case not defined */
-#ifdef HRT_CSIM
-#define SH_CSS_MEMORY_GUARDING (1)
-#else
-#define SH_CSS_MEMORY_GUARDING (0)
-#endif
-#endif
-
-#if SH_CSS_MEMORY_GUARDING
-#define CEIL_DIV(a, b)	((b) ? ((a)+(b)-1)/(b) : 0)
-#define CEIL_MUL(a, b)	(CEIL_DIV(a, b) * (b))
-#define DDR_ALIGN(a)	(CEIL_MUL((a), (HIVE_ISP_DDR_WORD_BYTES)))
-
-#define MEM_GUARD_START		0xABBAABBA
-#define MEM_GUARD_END		0xBEEFBEEF
-#define GUARD_SIZE		sizeof(unsigned long)
-#define GUARD_SIZE_ALIGNED	DDR_ALIGN(GUARD_SIZE)
-
-#define MAX_ALLOC_ENTRIES (256)
-#define INVALID_VBASE ((ia_css_ptr)-1)
-#define INVALID_SIZE ((unsigned long)-1)
-
-struct alloc_info {
-	ia_css_ptr  vbase;
-	unsigned long size;
-};
-
-static struct alloc_info alloc_admin[MAX_ALLOC_ENTRIES];
-
-static struct alloc_info const alloc_info_invalid
-					= { INVALID_VBASE, INVALID_SIZE };
-
-static void alloc_admin_init(void)
-{
-	int i;
-
-	for (i = 0; i < MAX_ALLOC_ENTRIES; i++)
-		alloc_admin[i] = alloc_info_invalid;
-}
-
-static struct alloc_info const *alloc_admin_find(ia_css_ptr vaddr)
-{
-	int i;
-	/**
-	 * Note that we use <= instead of < because we like to accept
-	 * zero-sized operations at the last allocated address
-	 * e.g. mmgr_set(vbase+alloc_size, data, 0)
-	 */
-	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
-		if (alloc_admin[i].vbase != INVALID_VBASE &&
-					vaddr >= alloc_admin[i].vbase &&
-					vaddr <= alloc_admin[i].vbase +
-							alloc_admin[i].size) {
-			return &alloc_admin[i];
-		}
-	}
-	return &alloc_info_invalid;
-}
-
-static bool mem_guard_valid(ia_css_ptr vaddr, unsigned long size)
-{
-	unsigned long mem_guard;
-	struct alloc_info const *info;
-
-	info = alloc_admin_find(vaddr);
-	if (info->vbase == INVALID_VBASE) {
-		assert(false);
-		return false;
-	}
-
-	/* Check if end is in alloc range*/
-	if ((vaddr + size) > (info->vbase + info->size)) {
-		assert(false);
-		return false;
-	}
-
-	hrt_isp_css_mm_load((info->vbase - sizeof(mem_guard)),
-			&mem_guard, sizeof(mem_guard));
-	if (mem_guard != MEM_GUARD_START) {
-		assert(false);
-		return false;
-	}
-
-	hrt_isp_css_mm_load((info->vbase + info->size),
-				&mem_guard, sizeof(mem_guard));
-	if (mem_guard != MEM_GUARD_END) {
-		assert(false);
-		return false;
-	}
-
-	return true;
-
-}
-
-static void alloc_admin_add(ia_css_ptr vbase, unsigned long size)
-{
-	int i;
-	unsigned long mem_guard;
-
-	assert(alloc_admin_find(vbase)->vbase == INVALID_VBASE);
-
-	mem_guard = MEM_GUARD_START;
-	hrt_isp_css_mm_store((vbase - sizeof(mem_guard)),
-				&mem_guard, sizeof(mem_guard));
-
-	mem_guard = MEM_GUARD_END;
-	hrt_isp_css_mm_store((vbase + size),
-				&mem_guard, sizeof(mem_guard));
-
-	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
-		if (alloc_admin[i].vbase == INVALID_VBASE) {
-			alloc_admin[i].vbase = vbase;
-			alloc_admin[i].size = size;
-			return;
-		}
-	}
-	assert(false);
-}
-
-static void alloc_admin_remove(ia_css_ptr vbase)
-{
-	int i;
-	assert(mem_guard_valid(vbase, 0));
-	for (i = 0; i < MAX_ALLOC_ENTRIES; i++) {
-		if (alloc_admin[i].vbase == vbase) {
-			alloc_admin[i] = alloc_info_invalid;
-			return;
-		}
-	}
-	assert(false);
-}
-
-#endif
-
-void mmgr_set_base_address(
-	const sys_address		base_addr)
-{
-	page_table_base_address = base_addr;
-
-#if SH_CSS_MEMORY_GUARDING
-	alloc_admin_init();
-#endif
-/*
- * This is part of "device_access.h", but it may be
- * that "hive_isp_css_mm_hrt.h" requires it
- */
-/* hrt_isp_css_mm_set_ddr_address_offset(offset); */
-/*	mmu_set_page_table_base_index(MMU0_ID, page_table_base_address); */
-return;
-}
-
-sys_address mmgr_get_base_address(void)
-{
-return page_table_base_address;
-}
-
-void mmgr_set_base_index(
-	const hrt_data		base_index)
-{
-/* This system only defines the MMU base address */
-assert(0);
-(void)base_index;
-return;
-}
-
-hrt_data mmgr_get_base_index(void)
-{
-/* This system only defines the MMU base address */
-assert(0);
-return 0;
-}
-
-ia_css_ptr mmgr_malloc(
-	const size_t			size)
-{
-return mmgr_alloc_attr(size, MMGR_ATTRIBUTE_CACHED);
-}
-
-ia_css_ptr mmgr_calloc(
-	const size_t			N,
-	const size_t			size)
-{
-return mmgr_alloc_attr(N * size, MMGR_ATTRIBUTE_CLEARED|MMGR_ATTRIBUTE_CACHED);
-}
-
-ia_css_ptr mmgr_realloc(
-	ia_css_ptr			vaddr,
-	const size_t			size)
-{
-return mmgr_realloc_attr(vaddr, size, MMGR_ATTRIBUTE_DEFAULT);
-}
-
-void mmgr_free(
-	ia_css_ptr			vaddr)
-{
-/* "free()" should accept NULL, "hrt_isp_css_mm_free()" may not */
-	if (vaddr) {
-#if SH_CSS_MEMORY_GUARDING
-		alloc_admin_remove(vaddr);
-		/* Reconstruct the "original" address used with the alloc */
-		vaddr -= GUARD_SIZE_ALIGNED;
-#endif
-		hrt_isp_css_mm_free(vaddr);
-	}
-return;
-}
-
-ia_css_ptr mmgr_alloc_attr(
-	const size_t			size,
-	const uint16_t			attribute)
-{
-	ia_css_ptr	ptr;
-	size_t	extra_space = 0;
-	size_t	aligned_size = size;
-
-assert(page_table_base_address != (sys_address)-1);
-assert((attribute & MMGR_ATTRIBUTE_UNUSED) == 0);
-
-#if SH_CSS_MEMORY_GUARDING
-	/* Add DDR aligned space for a guard at begin and end */
-	/* Begin guard must be DDR aligned, "end" guard not */
-	extra_space = GUARD_SIZE_ALIGNED + GUARD_SIZE;
-	/* SP DMA operates on multiple of 32 bytes, also with writes.
-	 * To prevent that the guard is being overwritten by SP DMA,
-	 * the "end" guard must start DDR aligned.
-	 */
-	aligned_size = DDR_ALIGN(aligned_size);
-#endif
-
-	if (attribute & MMGR_ATTRIBUTE_CLEARED) {
-		if (attribute & MMGR_ATTRIBUTE_CACHED) {
-			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
-				ptr = hrt_isp_css_mm_calloc_contiguous(
-						aligned_size + extra_space);
-			/* } */ else /* { */
-				ptr = hrt_isp_css_mm_calloc_cached(
-						aligned_size + extra_space);
-			/* } */
-		} else { /* !MMGR_ATTRIBUTE_CACHED */
-			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
-				ptr = hrt_isp_css_mm_calloc_contiguous(
-						aligned_size + extra_space);
-			/* } */ else /* { */
-				ptr = hrt_isp_css_mm_calloc(
-						aligned_size + extra_space);
-			/* } */
-		}
-	} else { /* MMGR_ATTRIBUTE_CLEARED */
-		if (attribute & MMGR_ATTRIBUTE_CACHED) {
-			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
-				ptr = hrt_isp_css_mm_alloc_contiguous(
-						aligned_size + extra_space);
-			/* } */ else /* { */
-				ptr = hrt_isp_css_mm_alloc_cached(
-						aligned_size + extra_space);
-			/* } */
-		} else { /* !MMGR_ATTRIBUTE_CACHED */
-			if (attribute & MMGR_ATTRIBUTE_CONTIGUOUS) /* { */
-				ptr = hrt_isp_css_mm_alloc_contiguous(
-						aligned_size + extra_space);
-			/* } */ else /* { */
-				ptr = hrt_isp_css_mm_alloc(
-						aligned_size + extra_space);
-			/* } */
-		}
-	}
-
-#if SH_CSS_MEMORY_GUARDING
-	/* ptr is the user pointer, so we need to skip the "begin" guard */
-	ptr += GUARD_SIZE_ALIGNED;
-	alloc_admin_add(ptr, aligned_size);
-#endif
-
-	return ptr;
-}
-
-ia_css_ptr mmgr_realloc_attr(
-	ia_css_ptr			vaddr,
-	const size_t			size,
-	const uint16_t			attribute)
-{
-assert(page_table_base_address != (sys_address)-1);
-assert((attribute & MMGR_ATTRIBUTE_UNUSED) == 0);
-/* assert(attribute == MMGR_ATTRIBUTE_DEFAULT); */
-/* Apparently we don't have this one */
-assert(0);
-(void)vaddr;
-(void)size;
-(void)attribute;
-return 0;
-}
-
-ia_css_ptr mmgr_mmap(const void *ptr, const size_t size, uint16_t attribute,
-		void *context)
-{
-	struct hrt_userbuffer_attr *userbuffer_attr = context;
-	return hrt_isp_css_mm_alloc_user_ptr(size, (void *)ptr,
-					userbuffer_attr->pgnr,
-					userbuffer_attr->type,
-					attribute & HRT_BUF_FLAG_CACHED);
-}
-
-void mmgr_clear(
-	ia_css_ptr			vaddr,
-	const size_t			size)
-{
-	mmgr_set(vaddr, (uint8_t)0, size);
-}
-
-void mmgr_set(
-	ia_css_ptr			vaddr,
-	const uint8_t			data,
-	const size_t			size)
-{
-#if SH_CSS_MEMORY_GUARDING
-	assert(mem_guard_valid(vaddr, size));
-#endif
-	hrt_isp_css_mm_set(vaddr, (int)data, size);
-return;
-}
-
-void mmgr_load(
-	const ia_css_ptr		vaddr,
-	void				*data,
-	const size_t			size)
-{
-#if SH_CSS_MEMORY_GUARDING
-	assert(mem_guard_valid(vaddr, size));
-#endif
-	hrt_isp_css_mm_load(vaddr, data, size);
-return;
-}
-
-void mmgr_store(
-	const ia_css_ptr		vaddr,
-	const void				*data,
-	const size_t			size)
-{
-#if SH_CSS_MEMORY_GUARDING
-	assert(mem_guard_valid(vaddr, size));
-#endif
-	hrt_isp_css_mm_store(vaddr, data, size);
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm.h
deleted file mode 100644
index b3f532f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__HMM_H__
-#define	__HMM_H__
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-
-#include "hmm/hmm_bo.h"
-#include "hmm/hmm_pool.h"
-#ifdef CSS20
-#include "ia_css_types.h"
-#else /* CSS20 */
-#include "sh_css_types.h"
-#endif /* CSS20 */
-
-#define HMM_CACHED true
-#define HMM_UNCACHED false
-
-int hmm_pool_register(unsigned int pool_size, enum hmm_pool_type pool_type);
-void hmm_pool_unregister(enum hmm_pool_type pool_type);
-
-int hmm_init(void);
-void hmm_cleanup(void);
-void hmm_cleanup_mmu_l2(void);
-
-ia_css_ptr hmm_alloc(size_t bytes, enum hmm_bo_type type,
-		int from_highmem, void *userptr, bool cached);
-void hmm_free(ia_css_ptr ptr);
-int hmm_load(ia_css_ptr virt, void *data, unsigned int bytes);
-int hmm_store(ia_css_ptr virt, const void *data, unsigned int bytes);
-int hmm_set(ia_css_ptr virt, int c, unsigned int bytes);
-int hmm_flush(ia_css_ptr virt, unsigned int bytes);
-
-/*
- * get kernel memory physical address from ISP virtual address.
- */
-phys_addr_t hmm_virt_to_phys(ia_css_ptr virt);
-
-/*
- * map ISP memory starts with virt to kernel virtual address
- * by using vmap. return NULL if failed.
- *
- * virt must be the start address of ISP memory (return by hmm_alloc),
- * do not pass any other address.
- */
-void *hmm_vmap(ia_css_ptr virt);
-void hmm_vunmap(ia_css_ptr virt);
-
-/*
- * Address translation from ISP shared memory address to kernel virtual address
- * if the memory is not vmmaped,  then do it.
- */
-void *hmm_isp_vaddr_to_host_vaddr(ia_css_ptr ptr);
-
-/*
- * Address translation from kernel virtual address to ISP shared memory address
- */
-ia_css_ptr hmm_host_vaddr_to_hrt_vaddr(const void *ptr);
-
-/*
- * map ISP memory starts with virt to specific vma.
- *
- * used for mmap operation.
- *
- * virt must be the start address of ISP memory (return by hmm_alloc),
- * do not pass any other address.
- */
-int hmm_mmap(struct vm_area_struct *vma, ia_css_ptr virt);
-
-extern bool dypool_enable;
-extern unsigned int dypool_pgnr;
-extern struct hmm_bo_device bo_device;
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo.h
deleted file mode 100644
index b556ca7..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo.h
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__HMM_BO_H__
-#define	__HMM_BO_H__
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/mutex.h>
-#include <linux/kref.h>
-#include "hmm_common.h"
-#include "hmm/hmm_vm.h"
-
-#define	check_bo_status_yes_goto(bo, _status, label) \
-	var_not_equal_goto((bo->status & (_status)), (_status), \
-			label, \
-			"HMM buffer status not contain %s.\n", \
-			#_status)
-
-#define	check_bo_status_no_goto(bo, _status, label) \
-	var_equal_goto((bo->status & (_status)), (_status), \
-			label, \
-			"HMM buffer status contains %s.\n", \
-			#_status)
-#define	list_to_hmm_bo(list_ptr)	\
-	list_entry((list_ptr), struct hmm_buffer_object, list)
-
-#define	kref_to_hmm_bo(kref_ptr)	\
-	list_entry((kref_ptr), struct hmm_buffer_object, kref)
-
-#define	check_bo_null_return(bo, exp)	\
-	check_null_return(bo, exp, "NULL hmm buffer object.\n")
-
-#define	check_bo_null_return_void(bo)	\
-	check_null_return_void(bo, "NULL hmm buffer object.\n")
-
-#define	HMM_MAX_ORDER		3
-#define	HMM_MIN_ORDER		0
-
-struct hmm_bo_device;
-
-/*
- * buffer object type.
- *
- *	HMM_BO_PRIVATE:
- *	pages are allocated by driver itself.
- *	HMM_BO_SHARE:
- *	pages are allocated by other component. currently: video driver.
- *	HMM_BO_USER:
- *	pages are allocated in user space process.
- *	HMM_BO_ION:
- *	pages are allocated through ION.
- *
- */
-enum hmm_bo_type {
-	HMM_BO_PRIVATE,
-	HMM_BO_SHARE,
-	HMM_BO_USER,
-#ifdef CONFIG_ION
-	HMM_BO_ION,
-#endif
-};
-
-enum hmm_page_type {
-	HMM_PAGE_TYPE_RESERVED,
-	HMM_PAGE_TYPE_DYNAMIC,
-	HMM_PAGE_TYPE_GENERAL,
-};
-
-#define	HMM_BO_VM_ALLOCED	0x1
-#define	HMM_BO_PAGE_ALLOCED	0x2
-#define	HMM_BO_BINDED		0x4
-#define	HMM_BO_MMAPED		0x8
-#define	HMM_BO_VMAPED		0x10
-#define	HMM_BO_ACTIVE		0x1000
-#define	HMM_BO_MEM_TYPE_USER     0x1
-#define	HMM_BO_MEM_TYPE_PFN      0x2
-
-struct hmm_page_object {
-	struct page		*page;
-	enum hmm_page_type	type;
-};
-
-struct hmm_buffer_object {
-	struct hmm_bo_device	*bdev;
-	struct list_head	list;
-	struct kref		kref;
-
-	/* mutex protecting this BO */
-	struct mutex		mutex;
-	enum hmm_bo_type	type;
-	struct hmm_page_object	*page_obj;	/* physical pages */
-	unsigned int		pgnr;	/* page number */
-	int			from_highmem;
-	int			mmap_count;
-	struct hmm_vm_node	*vm_node;
-#ifdef CONFIG_ION
-	struct ion_handle	*ihandle;
-#endif
-	int			status;
-	int         mem_type;
-	void		*vmap_addr; /* kernel virtual address by vmap */
-	/*
-	 * release callback for releasing buffer object.
-	 *
-	 * usually set to the release function to release the
-	 * upper level buffer object which has hmm_buffer_object
-	 * embedded in. if the hmm_buffer_object is dynamically
-	 * created by hmm_bo_create, release will set to kfree.
-	 *
-	 */
-	void (*release)(struct hmm_buffer_object *bo);
-};
-
-/*
- * use this function to initialize pre-allocated hmm_buffer_object.
- *
- * the hmm_buffer_object use reference count to manage its life cycle.
- *
- * bo->kref is inited to 1.
- *
- * use hmm_bo_ref/hmm_bo_unref increase/decrease the reference count,
- * and hmm_bo_unref will free resource of buffer object (but not the
- * buffer object itself as it can be both pre-allocated or dynamically
- * allocated) when reference reaches 0.
- *
- * see detailed description of hmm_bo_ref/hmm_bo_unref below.
- *
- * as hmm_buffer_object may be used as an embedded object in an upper
- * level object, a release callback must be provided. if it is
- * embedded in upper level object, set release call back to release
- * function of that object. if no upper level object, set release
- * callback to NULL.
- *
- * ex:
- *	struct hmm_buffer_object bo;
- *	hmm_bo_init(bdev, &bo, pgnr, NULL);
- *
- * or
- *	struct my_buffer_object {
- *		struct hmm_buffer_object bo;
- *		...
- *	};
- *
- *	void my_buffer_release(struct hmm_buffer_object *bo)
- *	{
- *		struct my_buffer_object *my_bo =
- *			container_of(bo, struct my_buffer_object, bo);
- *
- *		...	// release resource in my_buffer_object
- *
- *		kfree(my_bo);
- *	}
- *
- *	struct my_buffer_object *my_bo =
- *		kmalloc(sizeof(*my_bo), GFP_KERNEL);
- *
- *	hmm_bo_init(bdev, &my_bo->bo, pgnr, my_buffer_release);
- *	...
- *
- *	hmm_bo_unref(&my_bo->bo);
- */
-int hmm_bo_init(struct hmm_bo_device *bdev,
-		struct hmm_buffer_object *bo,
-		unsigned int pgnr,
-		void (*release)(struct hmm_buffer_object *));
-
-/*
- * use these functions to dynamically alloc hmm_buffer_object.
- *
- * hmm_bo_init will called for that allocated buffer object, and
- * the release callback is set to kfree.
- *
- * ex:
- *	hmm_buffer_object *bo = hmm_bo_create(bdev, pgnr);
- *	...
- *	hmm_bo_unref(bo);
- */
-struct hmm_buffer_object *hmm_bo_create(struct hmm_bo_device *bdev,
-		int pgnr);
-
-/*
- * increse buffer object reference.
- */
-void hmm_bo_ref(struct hmm_buffer_object *bo);
-
-/*
- * decrese buffer object reference. if reference reaches 0,
- * release function of the buffer object will be called.
- *
- * this call is also used to release hmm_buffer_object or its
- * upper level object with it embedded in. you need to call
- * this function when it is no longer used.
- *
- * Note:
- *
- * user dont need to care about internal resource release of
- * the buffer object in the release callback, it will be
- * handled internally.
- *
- * this call will only release internal resource of the buffer
- * object but will not free the buffer object itself, as the
- * buffer object can be both pre-allocated statically or
- * dynamically allocated. so user need to deal with the release
- * of the buffer object itself manually. below example shows
- * the normal case of using the buffer object.
- *
- *	struct hmm_buffer_object *bo = hmm_bo_create(bdev, pgnr);
- *	......
- *	hmm_bo_unref(bo);
- *
- * or:
- *
- *	struct hmm_buffer_object bo;
- *
- *	hmm_bo_init(bdev, &bo, pgnr, NULL);
- *	...
- *	hmm_bo_unref(&bo);
- */
-void hmm_bo_unref(struct hmm_buffer_object *bo);
-
-
-/*
- * put buffer object to unactivated status, meaning put it into
- * bo->bdev->free_bo_list, but not destroy it.
- *
- * this can be used to instead of hmm_bo_destroy if there are
- * lots of petential hmm_bo_init/hmm_bo_destroy operations with
- * the same buffer object size. using this with hmm_bo_device_get_bo
- * can improve performace as lots of memory allocation/free are
- * avoided..
- */
-void hmm_bo_unactivate(struct hmm_buffer_object *bo);
-int hmm_bo_activated(struct hmm_buffer_object *bo);
-
-/*
- * allocate/free virtual address space for the bo.
- */
-int hmm_bo_alloc_vm(struct hmm_buffer_object *bo);
-void hmm_bo_free_vm(struct hmm_buffer_object *bo);
-int hmm_bo_vm_allocated(struct hmm_buffer_object *bo);
-
-/*
- * allocate/free physical pages for the bo. will try to alloc mem
- * from highmem if from_highmem is set, and type indicate that the
- * pages will be allocated by using video driver (for share buffer)
- * or by ISP driver itself.
- */
-int hmm_bo_alloc_pages(struct hmm_buffer_object *bo,
-		enum hmm_bo_type type, int from_highmem,
-		void *userptr, bool cached);
-void hmm_bo_free_pages(struct hmm_buffer_object *bo);
-int hmm_bo_page_allocated(struct hmm_buffer_object *bo);
-
-/*
- * get physical page info of the bo.
- */
-int hmm_bo_get_page_info(struct hmm_buffer_object *bo,
-		struct hmm_page_object **page_obj, int *pgnr);
-
-/*
- * bind/unbind the physical pages to a virtual address space.
- */
-int hmm_bo_bind(struct hmm_buffer_object *bo);
-void hmm_bo_unbind(struct hmm_buffer_object *bo);
-int hmm_bo_binded(struct hmm_buffer_object *bo);
-
-/*
- * vmap buffer object's pages to contiguous kernel virtual address.
- * if the buffer has been vmaped, return the virtual address directly.
- */
-void *hmm_bo_vmap(struct hmm_buffer_object *bo);
-/*
- * vunmap buffer object's kernel virtual address.
- */
-void hmm_bo_vunmap(struct hmm_buffer_object *bo);
-
-/*
- * mmap the bo's physical pages to specific vma.
- *
- * vma's address space size must be the same as bo's size,
- * otherwise it will return -EINVAL.
- *
- * vma->vm_flags will be set to (VM_RESERVED | VM_IO).
- */
-int hmm_bo_mmap(struct vm_area_struct *vma,
-		struct hmm_buffer_object *bo);
-
-extern struct hmm_pool	dynamic_pool;
-extern struct hmm_pool	reserved_pool;
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo_dev.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo_dev.h
deleted file mode 100644
index 4655ea8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_bo_dev.h
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__HMM_BO_DEV_H__
-#define	__HMM_BO_DEV_H__
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/mutex.h>
-#include "mmu/isp_mmu.h"
-#include "hmm/hmm_common.h"
-#include "hmm/hmm_vm.h"
-#ifdef CSS20
-#include "ia_css_types.h"
-#else /* CSS20 */
-#include "sh_css_types.h"
-#endif /* CSS20 */
-
-#define	check_bodev_null_return(bdev, exp)	\
-		check_null_return(bdev, exp, \
-			"NULL hmm_bo_device.\n")
-
-#define	check_bodev_null_return_void(bdev)	\
-		check_null_return_void(bdev, \
-			"NULL hmm_bo_device.\n")
-
-#define	HMM_BO_DEVICE_INITED	0x1
-
-struct hmm_buffer_object;
-
-struct hmm_bo_device {
-	/* isp_mmu provides lock itself */
-	struct isp_mmu		mmu;
-
-	/* hmm_vm provides lock itself */
-	struct hmm_vm		vaddr_space;
-
-	struct list_head	free_bo_list;
-	struct list_head	active_bo_list;
-
-	/* list lock is used to protect both of the buffer object lists */
-	spinlock_t		list_lock;
-#ifdef CONFIG_ION
-	struct ion_client	*iclient;
-#endif
-	int			flag;
-};
-
-int hmm_bo_device_init(struct hmm_bo_device *bdev,
-		       struct isp_mmu_client *mmu_driver,
-		       unsigned int vaddr_start, unsigned int size);
-
-/*
- * clean up all hmm_bo_device related things.
- */
-void hmm_bo_device_exit(struct hmm_bo_device *bdev);
-
-/*
- * only clean up empty MMU L2 tables.
- */
-void hmm_bo_device_cleanup_mmu_l2(struct hmm_bo_device *bdev);
-
-/*
- * whether the bo device is inited or not.
- */
-int hmm_bo_device_inited(struct hmm_bo_device *bdev);
-
-/*
- * find the buffer object with virtual address vaddr.
- * return NULL if no such buffer object found.
- */
-struct hmm_buffer_object *hmm_bo_device_search_start(
-		struct hmm_bo_device *bdev, ia_css_ptr vaddr);
-
-/*
- * find the buffer object with virtual address vaddr.
- * return NULL if no such buffer object found.
- */
-struct hmm_buffer_object *hmm_bo_device_search_in_range(
-		struct hmm_bo_device *bdev, ia_css_ptr vaddr);
-
-/*
- * find the buffer object with kernel virtual address vaddr.
- * return NULL if no such buffer object found.
- */
-struct hmm_buffer_object *hmm_bo_device_search_vmap_start(
-		struct hmm_bo_device *bdev, const void *vaddr);
-
-/*
- * find a buffer object with pgnr pages from free_bo_list and
- * activate it (remove from free_bo_list and add to
- * active_bo_list)
- *
- * return NULL if no such buffer object found.
- */
-struct hmm_buffer_object *hmm_bo_device_get_bo(
-		struct hmm_bo_device *bdev, unsigned int pgnr);
-
-/*
- * destroy all buffer objects in the free_bo_list.
- */
-void hmm_bo_device_destroy_free_bo_list(struct hmm_bo_device *bdev);
-/*
- * destroy buffer object with start virtual address vaddr.
- */
-void hmm_bo_device_destroy_free_bo_addr(struct hmm_bo_device *bdev,
-		ia_css_ptr vaddr);
-/*
- * destroy all buffer objects with pgnr pages.
- */
-void hmm_bo_device_destroy_free_bo_size(struct hmm_bo_device *bdev,
-		unsigned int pgnr);
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_common.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_common.h
deleted file mode 100644
index 61905f1..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_common.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__HMM_BO_COMMON_H__
-#define	__HMM_BO_COMMON_H__
-
-#define	HMM_BO_NAME	"HMM"
-
-/*
- * some common use micros
- */
-#define	var_equal_return(var1, var2, exp, fmt, arg ...)	\
-	do { \
-		if ((var1) == (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			return exp;\
-		} \
-	} while (0)
-
-#define	var_equal_return_void(var1, var2, fmt, arg ...)	\
-	do { \
-		if ((var1) == (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			return;\
-		} \
-	} while (0)
-
-#define	var_equal_goto(var1, var2, label, fmt, arg ...)	\
-	do { \
-		if ((var1) == (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			goto label;\
-		} \
-	} while (0)
-
-#define	var_not_equal_goto(var1, var2, label, fmt, arg ...)	\
-	do { \
-		if ((var1) != (var2)) { \
-			dev_err(atomisp_dev, \
-			fmt, ## arg); \
-			goto label;\
-		} \
-	} while (0)
-
-#define	check_null_return(ptr, exp, fmt, arg ...)	\
-		var_equal_return(ptr, NULL, exp, fmt, ## arg)
-
-#define	check_null_return_void(ptr, fmt, arg ...)	\
-		var_equal_return_void(ptr, NULL, fmt, ## arg)
-
-
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_pool.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_pool.h
deleted file mode 100644
index 57c3cf9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_pool.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef __HMM_POOL_H__
-#define __HMM_POOL_H__
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/mutex.h>
-#include <linux/kref.h>
-#include "hmm_common.h"
-#include "hmm/hmm_vm.h"
-#include "hmm/hmm_bo.h"
-
-#define ALLOC_PAGE_FAIL_NUM		5
-
-enum hmm_pool_type {
-	HMM_POOL_TYPE_RESERVED,
-	HMM_POOL_TYPE_DYNAMIC,
-};
-
-/**
- * struct hmm_pool_ops  -  memory pool callbacks.
- *
- * @pool_init:		   initialize the memory pool.
- * @pool_exit:		   uninitialize the memory pool.
- * @pool_alloc_pages:	   allocate pages from memory pool.
- * @pool_free_pages:	   free pages to memory pool.
- * @pool_inited:	   check whether memory pool is initialized.
- */
-struct hmm_pool_ops {
-	int (*pool_init)(void **pool, unsigned int pool_size);
-	void (*pool_exit)(void **pool);
-	unsigned int (*pool_alloc_pages)(void *pool,
-					struct hmm_page_object *page_obj,
-					unsigned int size, bool cached);
-	void (*pool_free_pages)(void *pool,
-				struct hmm_page_object *page_obj);
-	int (*pool_inited)(void *pool);
-};
-
-struct hmm_pool {
-	struct hmm_pool_ops	*pops;
-
-	void			*pool_info;
-};
-
-/**
- * struct hmm_reserved_pool_info  - represents reserved pool private data.
- * @pages:			    a array that store physical pages.
- *				    The array is as reserved memory pool.
- * @index:			    to indicate the first blank page number
- *				    in reserved memory pool(pages array).
- * @pgnr:			    the valid page amount in reserved memory
- *				    pool.
- * @list_lock:			    list lock is used to protect the operation
- *				    to reserved memory pool.
- * @flag:			    reserved memory pool state flag.
- */
-struct hmm_reserved_pool_info {
-	struct page		**pages;
-
-	unsigned int		index;
-	unsigned int		pgnr;
-	spinlock_t		list_lock;
-	bool			initialized;
-};
-
-/**
- * struct hmm_dynamic_pool_info  -  represents dynamic pool private data.
- * @pages_list:			    a list that store physical pages.
- *				    The pages list is as dynamic memory pool.
- * @list_lock:			    list lock is used to protect the operation
- *				    to dynamic memory pool.
- * @flag:			    dynamic memory pool state flag.
- * @pgptr_cache:		    struct kmem_cache, manages a cache.
- */
-struct hmm_dynamic_pool_info {
-	struct list_head	pages_list;
-
-	/* list lock is used to protect the free pages block lists */
-	spinlock_t		list_lock;
-
-#ifdef USE_KMEM_CACHE
-	struct kmem_cache	*pgptr_cache;
-#endif
-	bool			initialized;
-
-	unsigned int		pool_size;
-	unsigned int		pgnr;
-};
-
-struct hmm_page {
-	struct page		*page;
-	struct list_head	list;
-};
-
-extern struct hmm_pool_ops	reserved_pops;
-extern struct hmm_pool_ops	dynamic_pops;
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_vm.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_vm.h
deleted file mode 100644
index 07d4066..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/hmm/hmm_vm.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__HMM_VM_H__
-#define	__HMM_VM_H__
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/list.h>
-
-struct hmm_vm {
-	unsigned int start;
-	unsigned int pgnr;
-	unsigned int size;
-	struct list_head vm_node_list;
-	spinlock_t lock;
-	struct kmem_cache *cache;
-};
-
-struct hmm_vm_node {
-	struct list_head list;
-	unsigned int start;
-	unsigned int pgnr;
-	unsigned int size;
-	struct hmm_vm *vm;
-};
-#define	ISP_VM_START	0x0
-#define	ISP_VM_SIZE	(0x7FFFFFFF)	/* 2G address space */
-#define	ISP_PTR_NULL	NULL
-
-int hmm_vm_init(struct hmm_vm *vm, unsigned int start,
-		unsigned int size);
-
-void hmm_vm_clean(struct hmm_vm *vm);
-
-struct hmm_vm_node *hmm_vm_alloc_node(struct hmm_vm *vm,
-		unsigned int pgnr);
-
-void hmm_vm_free_node(struct hmm_vm_node *node);
-
-struct hmm_vm_node *hmm_vm_find_node_start(struct hmm_vm *vm,
-		unsigned int addr);
-
-struct hmm_vm_node *hmm_vm_find_node_in_range(struct hmm_vm *vm,
-		unsigned int addr);
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/isp_mmu.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/isp_mmu.h
deleted file mode 100644
index 348e0a5..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/isp_mmu.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-/*
- * ISP MMU driver for classic two-level page tables
- */
-#ifndef	__ISP_MMU_H__
-#define	__ISP_MMU_H__
-
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-
-/*
- * do not change these values, the page size for ISP must be the
- * same as kernel's page size.
- */
-#define	ISP_PAGE_OFFSET		12
-#define	ISP_PAGE_SIZE		(1U << ISP_PAGE_OFFSET)
-#define	ISP_PAGE_MASK		(~(ISP_PAGE_SIZE - 1))
-
-#define	ISP_L1PT_OFFSET		22
-#define	ISP_L1PT_MASK		(~((1U << ISP_L1PT_OFFSET) - 1))
-
-#define	ISP_L2PT_OFFSET		12
-#define	ISP_L2PT_MASK		(~(ISP_L1PT_MASK|(~(ISP_PAGE_MASK))))
-
-#define	ISP_L1PT_PTES		1024
-#define	ISP_L2PT_PTES		1024
-
-#define	ISP_PTR_TO_L1_IDX(x)	((((x) & ISP_L1PT_MASK)) \
-					>> ISP_L1PT_OFFSET)
-
-#define	ISP_PTR_TO_L2_IDX(x)	((((x) & ISP_L2PT_MASK)) \
-					>> ISP_L2PT_OFFSET)
-
-#define	ISP_PAGE_ALIGN(x)	(((x) + (ISP_PAGE_SIZE-1)) \
-					& ISP_PAGE_MASK)
-
-#define	ISP_PT_TO_VIRT(l1_idx, l2_idx, offset) do {\
-		((l1_idx) << ISP_L1PT_OFFSET) | \
-		((l2_idx) << ISP_L2PT_OFFSET) | \
-		(offset)\
-} while (0)
-
-#define	pgnr_to_size(pgnr)	((pgnr) << ISP_PAGE_OFFSET)
-#define	size_to_pgnr_ceil(size)	(((size) + (1 << ISP_PAGE_OFFSET) - 1)\
-						>> ISP_PAGE_OFFSET)
-#define	size_to_pgnr_bottom(size)	((size) >> ISP_PAGE_OFFSET)
-
-struct isp_mmu;
-
-struct isp_mmu_client {
-	/*
-	 * const value
-	 *
-	 * @name:
-	 *      driver name
-	 * @pte_valid_mask:
-	 *      should be 1 bit valid data, meaning the value should
-	 *      be power of 2.
-	 */
-	char *name;
-	unsigned int pte_valid_mask;
-	unsigned int null_pte;
-
-	/*
-	 * set/get page directory base address (physical address).
-	 *
-	 * must be provided.
-	 */
-	int (*set_pd_base) (struct isp_mmu *mmu,
-			phys_addr_t pd_base);
-	unsigned int (*get_pd_base) (struct isp_mmu *mmu, phys_addr_t pd_base);
-	/*
-	 * callback to flush tlb.
-	 *
-	 * tlb_flush_range will at least flush TLBs containing
-	 * address mapping from addr to addr + size.
-	 *
-	 * tlb_flush_all will flush all TLBs.
-	 *
-	 * tlb_flush_all is must be provided. if tlb_flush_range is
-	 * not valid, it will set to tlb_flush_all by default.
-	 */
-	void (*tlb_flush_range) (struct isp_mmu *mmu,
-				 unsigned int addr, unsigned int size);
-	void (*tlb_flush_all) (struct isp_mmu *mmu);
-	unsigned int (*phys_to_pte) (struct isp_mmu *mmu,
-				     phys_addr_t phys);
-	phys_addr_t (*pte_to_phys) (struct isp_mmu *mmu,
-				    unsigned int pte);
-
-};
-
-struct isp_mmu {
-	struct isp_mmu_client *driver;
-	unsigned int l1_pte;
-	unsigned int base_address;
-
-	struct mutex pt_mutex;
-#ifdef USE_KMEM_CACHE
-	struct kmem_cache *tbl_cache;
-#endif
-};
-
-/* flags for PDE and PTE */
-#define	ISP_PTE_VALID_MASK(mmu)	\
-	((mmu)->driver->pte_valid_mask)
-
-#define	ISP_PTE_VALID(mmu, pte)	\
-	((pte) & ISP_PTE_VALID_MASK(mmu))
-
-#define	NULL_PAGE	((phys_addr_t)(-1) & ISP_PAGE_MASK)
-#define	PAGE_VALID(page)	((page) != NULL_PAGE)
-
-/*
- * init mmu with specific mmu driver.
- */
-int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver);
-/*
- * cleanup all mmu related things.
- */
-void isp_mmu_exit(struct isp_mmu *mmu);
-/*
- * just cleanup empty L2 page tables.
- */
-void isp_mmu_clean_l2(struct isp_mmu *mmu);
-
-/*
- * setup/remove address mapping for pgnr continous physical pages
- * and isp_virt.
- *
- * map/unmap is mutex lock protected, and caller does not have
- * to do lock/unlock operation.
- *
- * map/unmap will not flush tlb, and caller needs to deal with
- * this itself.
- */
-int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
-		phys_addr_t phys, unsigned int pgnr);
-
-void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
-		   unsigned int pgnr);
-
-static inline void isp_mmu_flush_tlb_all(struct isp_mmu *mmu)
-{
-	if (mmu->driver && mmu->driver->tlb_flush_all)
-		mmu->driver->tlb_flush_all(mmu);
-}
-
-#define isp_mmu_flush_tlb isp_mmu_flush_tlb_all
-
-static inline void isp_mmu_flush_tlb_range(struct isp_mmu *mmu,
-		unsigned int start, unsigned int size)
-{
-	if (mmu->driver && mmu->driver->tlb_flush_range)
-		mmu->driver->tlb_flush_range(mmu, start, size);
-}
-
-#endif /* ISP_MMU_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu.h
deleted file mode 100644
index 06041e9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef	SH_MMU_H_
-#define	SH_MMU_H_
-
-
-#include <sh_css.h>
-
-#include "mmu/isp_mmu.h"
-
-
-/*
- * include SH header file here
- */
-
-/*
- * set page directory base address (physical address).
- *
- * must be provided.
- */
-static int sh_set_pd_base(struct isp_mmu *mmu,
-		unsigned int phys)
-{
-	sh_css_mmu_set_page_table_base_address((void *)phys);
-	return 0;
-}
-
-/*
- * callback to flush tlb.
- *
- * tlb_flush_range will at least flush TLBs containing
- * address mapping from addr to addr + size.
- *
- * tlb_flush_all will flush all TLBs.
- *
- * tlb_flush_all is must be provided. if tlb_flush_range is
- * not valid, it will set to tlb_flush_all by default.
- */
-static void sh_tlb_flush(struct isp_mmu *mmu)
-{
-	sh_css_mmu_invalidate_cache();
-}
-
-static struct isp_mmu_driver sh_mmu_driver = {
-	.name = "Silicon Hive ISP3000 MMU",
-	.pte_valid_mask = 0x1,
-	.set_pd_base = sh_set_pd_base,
-	.tlb_flush_all = sh_tlb_flush,
-};
-
-#define	ISP_VM_START	0x0
-#define	ISP_VM_SIZE	(1 << 30)	/* 1G address space */
-#define	ISP_PTR_NULL	NULL
-
-#endif /* SH_MMU_H_ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mfld.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mfld.h
deleted file mode 100644
index 359deb2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mfld.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__SH_MMU_MFLD_H__
-#define	__SH_MMU_MFLD_H__
-
-extern struct isp_mmu_client sh_mmu_mfld;
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mrfld.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mrfld.h
deleted file mode 100644
index b9bad9f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/include/mmu/sh_mmu_mrfld.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Support for Merrifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef	__SH_MMU_MRFLD_H__
-#define	__SH_MMU_MRFLD_H__
-
-extern struct isp_mmu_client sh_mmu_mrfld;
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/isp_mmu.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/isp_mmu.c
deleted file mode 100644
index e9f2924..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/isp_mmu.c
+++ /dev/null
@@ -1,620 +0,0 @@
-/*
- * Support for Medifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-/*
- * ISP MMU management wrap code
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/gfp.h>
-#include <linux/mm.h>		/* for GFP_ATOMIC */
-#include <linux/slab.h>		/* for kmalloc */
-#include <linux/list.h>
-#include <linux/io.h>
-#include <asm/cacheflush.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/string.h>
-#include <linux/errno.h>
-
-#include "atomisp_internal.h"
-#include "mmu/isp_mmu.h"
-
-static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
-				unsigned int end_isp_virt);
-
-static unsigned int atomisp_get_pte(phys_addr_t pt, unsigned int idx)
-{
-	unsigned int *pt_virt = phys_to_virt(pt);
-	return *(pt_virt + idx);
-}
-
-static void atomisp_set_pte(phys_addr_t pt,
-			    unsigned int idx, unsigned int pte)
-{
-	unsigned int *pt_virt = phys_to_virt(pt);
-	*(pt_virt + idx) = pte;
-}
-
-static void *isp_pt_phys_to_virt(phys_addr_t phys)
-{
-	return phys_to_virt(phys);
-}
-
-static phys_addr_t isp_pte_to_pgaddr(struct isp_mmu *mmu,
-				     unsigned int pte)
-{
-	return mmu->driver->pte_to_phys(mmu, pte);
-}
-
-static unsigned int isp_pgaddr_to_pte_valid(struct isp_mmu *mmu,
-					    phys_addr_t phys)
-{
-	unsigned int pte = mmu->driver->phys_to_pte(mmu, phys);
-	return (unsigned int) (pte | ISP_PTE_VALID_MASK(mmu));
-}
-
-/*
- * allocate a uncacheable page table.
- * return physical address.
- */
-static phys_addr_t alloc_page_table(struct isp_mmu *mmu)
-{
-	int i;
-	phys_addr_t page;
-	/*page table lock may needed here*/
-#ifdef USE_KMEM_CACHE
-	void *virt = kmem_cache_zalloc(mmu->tbl_cache, GFP_KERNEL);
-#else
-	void *virt = (void *)__get_free_page(GFP_KERNEL);
-#endif
-	if (!virt)
-		return (phys_addr_t)NULL_PAGE;
-
-	/*
-	 * we need a uncacheable page table.
-	 */
-#ifdef	CONFIG_X86
-	set_memory_uc((unsigned long)virt, 1);
-#endif
-
-	page = virt_to_phys(virt);
-
-	for (i = 0; i < 1024; i++) {
-		/* NEED CHECK */
-		atomisp_set_pte(page, i, mmu->driver->null_pte);
-	}
-
-	return page;
-}
-
-static void free_page_table(struct isp_mmu *mmu, phys_addr_t page)
-{
-	void *virt;
-	page &= ISP_PAGE_MASK;
-	/*
-	 * reset the page to write back before free
-	 */
-	virt = phys_to_virt(page);
-
-#ifdef	CONFIG_X86
-	set_memory_wb((unsigned long)virt, 1);
-#endif
-
-#ifdef USE_KMEM_CACHE
-	kmem_cache_free(mmu->tbl_cache, virt);
-#else
-	free_page((unsigned long)virt);
-#endif
-}
-
-static void mmu_remap_error(struct isp_mmu *mmu,
-			    phys_addr_t l1_pt, unsigned int l1_idx,
-			    phys_addr_t l2_pt, unsigned int l2_idx,
-			    unsigned int isp_virt, phys_addr_t old_phys,
-			    phys_addr_t new_phys)
-{
-	dev_err(atomisp_dev, "address remap:\n\n"
-		     "\tL1 PT: virt = %p, phys = 0x%llx, "
-		     "idx = %d\n"
-		     "\tL2 PT: virt = %p, phys = 0x%llx, "
-		     "idx = %d\n"
-		     "\told: isp_virt = 0x%x, phys = 0x%llx\n"
-		     "\tnew: isp_virt = 0x%x, phys = 0x%llx\n",
-		     isp_pt_phys_to_virt(l1_pt),
-		     (u64)l1_pt, l1_idx,
-		     isp_pt_phys_to_virt(l2_pt),
-		     (u64)l2_pt, l2_idx, isp_virt,
-		     (u64)old_phys, isp_virt,
-		     (u64)new_phys);
-}
-
-static void mmu_unmap_l2_pte_error(struct isp_mmu *mmu,
-				   phys_addr_t l1_pt, unsigned int l1_idx,
-				   phys_addr_t l2_pt, unsigned int l2_idx,
-				   unsigned int isp_virt, unsigned int pte)
-{
-	dev_err(atomisp_dev, "unmap unvalid L2 pte:\n\n"
-		     "\tL1 PT: virt = %p, phys = 0x%llx, "
-		     "idx = %d\n"
-		     "\tL2 PT: virt = %p, phys = 0x%llx, "
-		     "idx = %d\n"
-		     "\tisp_virt = 0x%x, pte(page phys) = 0x%x\n",
-		     isp_pt_phys_to_virt(l1_pt),
-		     (u64)l1_pt, l1_idx,
-		     isp_pt_phys_to_virt(l2_pt),
-		     (u64)l2_pt, l2_idx, isp_virt,
-		     pte);
-}
-
-static void mmu_unmap_l1_pte_error(struct isp_mmu *mmu,
-				   phys_addr_t l1_pt, unsigned int l1_idx,
-				   unsigned int isp_virt, unsigned int pte)
-{
-	dev_err(atomisp_dev, "unmap unvalid L1 pte (L2 PT):\n\n"
-		     "\tL1 PT: virt = %p, phys = 0x%llx, "
-		     "idx = %d\n"
-		     "\tisp_virt = 0x%x, l1_pte(L2 PT) = 0x%x\n",
-		     isp_pt_phys_to_virt(l1_pt),
-		     (u64)l1_pt, l1_idx, (unsigned int)isp_virt,
-		     pte);
-}
-
-static void mmu_unmap_l1_pt_error(struct isp_mmu *mmu, unsigned int pte)
-{
-	dev_err(atomisp_dev, "unmap unvalid L1PT:\n\n"
-		     "L1PT = 0x%x\n", (unsigned int)pte);
-}
-
-/*
- * Update L2 page table according to isp virtual address and page physical
- * address
- */
-static int mmu_l2_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
-		      unsigned int l1_idx, phys_addr_t l2_pt,
-		      unsigned int start, unsigned int end, phys_addr_t phys)
-{
-	unsigned int ptr;
-	unsigned int idx;
-	unsigned int pte;
-
-	l2_pt &= ISP_PAGE_MASK;
-
-	start = start & ISP_PAGE_MASK;
-	end = ISP_PAGE_ALIGN(end);
-	phys &= ISP_PAGE_MASK;
-
-	ptr = start;
-	do {
-		idx = ISP_PTR_TO_L2_IDX(ptr);
-
-		pte = atomisp_get_pte(l2_pt, idx);
-
-		if (ISP_PTE_VALID(mmu, pte)) {
-			mmu_remap_error(mmu, l1_pt, l1_idx,
-					  l2_pt, idx, ptr, pte, phys);
-
-			/* free all mapped pages */
-			free_mmu_map(mmu, start, ptr);
-
-			return -EINVAL;
-		}
-
-		pte = isp_pgaddr_to_pte_valid(mmu, phys);
-
-		atomisp_set_pte(l2_pt, idx, pte);
-		ptr += (1U << ISP_L2PT_OFFSET);
-		phys += (1U << ISP_L2PT_OFFSET);
-	} while (ptr < end && idx < ISP_L2PT_PTES - 1);
-
-	return 0;
-}
-
-/*
- * Update L1 page table according to isp virtual address and page physical
- * address
- */
-static int mmu_l1_map(struct isp_mmu *mmu, phys_addr_t l1_pt,
-		      unsigned int start, unsigned int end,
-		      phys_addr_t phys)
-{
-	phys_addr_t l2_pt;
-	unsigned int ptr, l1_aligned;
-	unsigned int idx;
-	unsigned int l2_pte;
-	int ret;
-
-	l1_pt &= ISP_PAGE_MASK;
-
-	start = start & ISP_PAGE_MASK;
-	end = ISP_PAGE_ALIGN(end);
-	phys &= ISP_PAGE_MASK;
-
-	ptr = start;
-	do {
-		idx = ISP_PTR_TO_L1_IDX(ptr);
-
-		l2_pte = atomisp_get_pte(l1_pt, idx);
-
-		if (!ISP_PTE_VALID(mmu, l2_pte)) {
-			l2_pt = alloc_page_table(mmu);
-			if (l2_pt == NULL_PAGE) {
-				dev_err(atomisp_dev,
-					     "alloc page table fail.\n");
-
-				/* free all mapped pages */
-				free_mmu_map(mmu, start, ptr);
-
-				return -ENOMEM;
-			}
-
-			l2_pte = isp_pgaddr_to_pte_valid(mmu, l2_pt);
-
-			atomisp_set_pte(l1_pt, idx, l2_pte);
-		}
-
-		l2_pt = isp_pte_to_pgaddr(mmu, l2_pte);
-
-		l1_aligned = (ptr & ISP_PAGE_MASK) + (1U << ISP_L1PT_OFFSET);
-
-		if (l1_aligned < end) {
-			ret = mmu_l2_map(mmu, l1_pt, idx,
-					   l2_pt, ptr, l1_aligned, phys);
-			phys += (l1_aligned - ptr);
-			ptr = l1_aligned;
-		} else {
-			ret = mmu_l2_map(mmu, l1_pt, idx,
-					   l2_pt, ptr, end, phys);
-			phys += (end - ptr);
-			ptr = end;
-		}
-
-		if (ret) {
-			dev_err(atomisp_dev, "setup mapping in L2PT fail.\n");
-
-			/* free all mapped pages */
-			free_mmu_map(mmu, start, ptr);
-
-			return -EINVAL;
-		}
-	} while (ptr < end && idx < ISP_L1PT_PTES - 1);
-
-	return 0;
-}
-
-/*
- * Update page table according to isp virtual address and page physical
- * address
- */
-static int mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
-		   phys_addr_t phys, unsigned int pgnr)
-{
-	unsigned int start, end;
-	phys_addr_t l1_pt;
-	int ret;
-
-	mutex_lock(&mmu->pt_mutex);
-	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
-		/*
-		 * allocate 1 new page for L1 page table
-		 */
-		l1_pt = alloc_page_table(mmu);
-		if (l1_pt == NULL_PAGE) {
-			dev_err(atomisp_dev, "alloc page table fail.\n");
-			mutex_unlock(&mmu->pt_mutex);
-			return -ENOMEM;
-		}
-
-		/*
-		 * setup L1 page table physical addr to MMU
-		 */
-		ret = mmu->driver->set_pd_base(mmu, l1_pt);
-		if (ret) {
-			dev_err(atomisp_dev,
-				 "set page directory base address fail.\n");
-			mutex_unlock(&mmu->pt_mutex);
-			return ret;
-		}
-		mmu->base_address = l1_pt;
-		mmu->l1_pte = isp_pgaddr_to_pte_valid(mmu, l1_pt);
-	}
-
-	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
-
-	start = (isp_virt) & ISP_PAGE_MASK;
-	end = start + (pgnr << ISP_PAGE_OFFSET);
-	phys &= ISP_PAGE_MASK;
-
-	ret = mmu_l1_map(mmu, l1_pt, start, end, phys);
-
-	if (ret)
-		dev_err(atomisp_dev, "setup mapping in L1PT fail.\n");
-
-	mutex_unlock(&mmu->pt_mutex);
-	return ret;
-}
-
-/*
- * Free L2 page table according to isp virtual address and page physical
- * address
- */
-static void mmu_l2_unmap(struct isp_mmu *mmu, phys_addr_t l1_pt,
-			   unsigned int l1_idx, phys_addr_t l2_pt,
-			   unsigned int start, unsigned int end)
-{
-
-	unsigned int ptr;
-	unsigned int idx;
-	unsigned int pte;
-
-	l2_pt &= ISP_PAGE_MASK;
-
-	start = start & ISP_PAGE_MASK;
-	end = ISP_PAGE_ALIGN(end);
-
-	ptr = start;
-	do {
-		idx = ISP_PTR_TO_L2_IDX(ptr);
-
-		pte = atomisp_get_pte(l2_pt, idx);
-
-		if (!ISP_PTE_VALID(mmu, pte))
-			mmu_unmap_l2_pte_error(mmu, l1_pt, l1_idx,
-						 l2_pt, idx, ptr, pte);
-
-		atomisp_set_pte(l2_pt, idx, mmu->driver->null_pte);
-
-		ptr += (1U << ISP_L2PT_OFFSET);
-	} while (ptr < end && idx < ISP_L2PT_PTES - 1);
-}
-
-/*
- * Free L1 page table according to isp virtual address and page physical
- * address
- */
-static void mmu_l1_unmap(struct isp_mmu *mmu, phys_addr_t l1_pt,
-			   unsigned int start, unsigned int end)
-{
-	phys_addr_t l2_pt;
-	unsigned int ptr, l1_aligned;
-	unsigned int idx;
-	unsigned int l2_pte;
-
-	l1_pt &= ISP_PAGE_MASK;
-
-	start = start & ISP_PAGE_MASK;
-	end = ISP_PAGE_ALIGN(end);
-
-	ptr = start;
-	do {
-		idx = ISP_PTR_TO_L1_IDX(ptr);
-
-		l2_pte = atomisp_get_pte(l1_pt, idx);
-
-		if (!ISP_PTE_VALID(mmu, l2_pte)) {
-			mmu_unmap_l1_pte_error(mmu, l1_pt, idx, ptr, l2_pte);
-			continue;
-		}
-
-		l2_pt = isp_pte_to_pgaddr(mmu, l2_pte);
-
-		l1_aligned = (ptr & ISP_PAGE_MASK) + (1U << ISP_L1PT_OFFSET);
-
-		if (l1_aligned < end) {
-			mmu_l2_unmap(mmu, l1_pt, idx, l2_pt, ptr, l1_aligned);
-			ptr = l1_aligned;
-		} else {
-			mmu_l2_unmap(mmu, l1_pt, idx, l2_pt, ptr, end);
-			ptr = end;
-		}
-		/*
-		 * use the same L2 page next time, so we dont
-		 * need to invalidate and free this PT.
-		 */
-		/*      atomisp_set_pte(l1_pt, idx, NULL_PTE); */
-	} while (ptr < end && idx < ISP_L1PT_PTES - 1);
-}
-
-/*
- * Free page table according to isp virtual address and page physical
- * address
- */
-static void mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
-			unsigned int pgnr)
-{
-	unsigned int start, end;
-	phys_addr_t l1_pt;
-
-	mutex_lock(&mmu->pt_mutex);
-	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
-		mmu_unmap_l1_pt_error(mmu, mmu->l1_pte);
-		mutex_unlock(&mmu->pt_mutex);
-		return;
-	}
-
-	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
-
-	start = (isp_virt) & ISP_PAGE_MASK;
-	end = start + (pgnr << ISP_PAGE_OFFSET);
-
-	mmu_l1_unmap(mmu, l1_pt, start, end);
-	mutex_unlock(&mmu->pt_mutex);
-}
-
-/*
- * Free page tables according to isp start virtual address and end virtual
- * address.
- */
-static void free_mmu_map(struct isp_mmu *mmu, unsigned int start_isp_virt,
-				unsigned int end_isp_virt)
-{
-	unsigned int pgnr;
-	unsigned int start, end;
-
-	start = (start_isp_virt) & ISP_PAGE_MASK;
-	end = (end_isp_virt) & ISP_PAGE_MASK;
-	pgnr = (end - start) >> ISP_PAGE_OFFSET;
-	mmu_unmap(mmu, start, pgnr);
-}
-
-int isp_mmu_map(struct isp_mmu *mmu, unsigned int isp_virt,
-		phys_addr_t phys, unsigned int pgnr)
-{
-	return mmu_map(mmu, isp_virt, phys, pgnr);
-}
-
-void isp_mmu_unmap(struct isp_mmu *mmu, unsigned int isp_virt,
-		   unsigned int pgnr)
-{
-	mmu_unmap(mmu, isp_virt, pgnr);
-}
-
-static void isp_mmu_flush_tlb_range_default(struct isp_mmu *mmu,
-					      unsigned int start,
-					      unsigned int size)
-{
-	isp_mmu_flush_tlb(mmu);
-}
-
-/*MMU init for internal structure*/
-int isp_mmu_init(struct isp_mmu *mmu, struct isp_mmu_client *driver)
-{
-	if (!mmu)		/* error */
-		return -EINVAL;
-	if (!driver)		/* error */
-		return -EINVAL;
-
-	if (!driver->name)
-		dev_warn(atomisp_dev, "NULL name for MMU driver...\n");
-
-	mmu->driver = driver;
-
-	if (!driver->set_pd_base || !driver->tlb_flush_all) {
-		dev_err(atomisp_dev,
-			    "set_pd_base or tlb_flush_all operation "
-			     "not provided.\n");
-		return -EINVAL;
-	}
-
-	if (!driver->tlb_flush_range)
-		driver->tlb_flush_range = isp_mmu_flush_tlb_range_default;
-
-	if (!driver->pte_valid_mask) {
-		dev_err(atomisp_dev, "PTE_MASK is missing from mmu driver\n");
-		return -EINVAL;
-	}
-
-	mmu->l1_pte = driver->null_pte;
-
-	mutex_init(&mmu->pt_mutex);
-
-#ifndef CSS20
-	isp_mmu_flush_tlb(mmu);
-#endif /* CSS20 */
-
-#ifdef USE_KMEM_CACHE
-	mmu->tbl_cache = kmem_cache_create("iopte_cache", ISP_PAGE_SIZE,
-					   ISP_PAGE_SIZE, SLAB_HWCACHE_ALIGN,
-					   NULL);
-	if (!mmu->tbl_cache)
-		return -ENOMEM;
-#endif
-
-	return 0;
-}
-
-/* cleanup empty L2 page tables */
-void isp_mmu_clean_l2(struct isp_mmu *mmu)
-{
-	unsigned int idx, idx2;
-	unsigned int pte;
-	phys_addr_t l1_pt, l2_pt;
-
-	if (!mmu)
-		return;
-
-	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
-		dev_warn(atomisp_dev, "invalid L1PT: pte = 0x%x\n",
-			    (unsigned int)mmu->l1_pte);
-		return;
-	}
-
-	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
-
-	for (idx = 0; idx < ISP_L1PT_PTES; idx++) {
-		bool l2_pt_is_empty = true;
-
-		pte = atomisp_get_pte(l1_pt, idx);
-		if (!ISP_PTE_VALID(mmu, pte))
-			continue;
-
-		l2_pt = isp_pte_to_pgaddr(mmu, pte);
-		for (idx2 = 0; idx2 < ISP_L2PT_PTES; idx2++) {
-			if (atomisp_get_pte(l2_pt, idx2) !=
-			    mmu->driver->null_pte) {
-				l2_pt_is_empty = false;
-				break;
-			}
-		}
-
-		if (l2_pt_is_empty) {
-			free_page_table(mmu, l2_pt);
-			atomisp_set_pte(l1_pt, idx, mmu->driver->null_pte);
-			dev_dbg(atomisp_dev, "free l1_pte index %d\n", idx);
-		}
-	}
-}
-
-/*Free L1 and L2 page table*/
-void isp_mmu_exit(struct isp_mmu *mmu)
-{
-	unsigned int idx;
-	unsigned int pte;
-	phys_addr_t l1_pt, l2_pt;
-
-	if (!mmu)
-		return;
-
-	if (!ISP_PTE_VALID(mmu, mmu->l1_pte)) {
-		dev_warn(atomisp_dev, "invalid L1PT: pte = 0x%x\n",
-			    (unsigned int)mmu->l1_pte);
-		return;
-	}
-
-	l1_pt = isp_pte_to_pgaddr(mmu, mmu->l1_pte);
-
-	for (idx = 0; idx < ISP_L1PT_PTES; idx++) {
-		pte = atomisp_get_pte(l1_pt, idx);
-
-		if (ISP_PTE_VALID(mmu, pte)) {
-			l2_pt = isp_pte_to_pgaddr(mmu, pte);
-
-			free_page_table(mmu, l2_pt);
-		}
-	}
-
-	free_page_table(mmu, l1_pt);
-
-#ifdef USE_KMEM_CACHE
-	kmem_cache_destroy(mmu->tbl_cache);
-#endif
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mfld.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mfld.c
deleted file mode 100644
index dd784f8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mfld.c
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef CSS21
-#include <host/mmu_local.h>
-#else
-#include "type_support.h"
-#endif
-
-#include "mmu/isp_mmu.h"
-#include "memory_access/memory_access.h"
-#include "atomisp_compat.h"
-
-#ifndef CSS20
-#include <sh_css.h>
-#endif /* CSS20 */
-/*
- * include SH header file here
- */
-
-static unsigned int sh_phys_to_pte(struct isp_mmu *mmu,
-				   phys_addr_t phys)
-{
-	return (unsigned int)phys;
-}
-
-static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu,
-				  unsigned int pte)
-{
-	return (phys_addr_t)(pte & ISP_PAGE_MASK);
-}
-/*
- * set page directory base address (physical address).
- *
- * must be provided.
- */
-static int sh_set_pd_base(struct isp_mmu *mmu,
-			  phys_addr_t phys)
-{
-	/*mmgr_set_base_address(HOST_ADDRESS(u32)phys);*/
-	atomisp_css_mmu_set_page_table_base_index(HOST_ADDRESS(u32)phys);
-	return 0;
-}
-
-/*
- * callback to flush tlb.
- *
- * tlb_flush_range will at least flush TLBs containing
- * address mapping from addr to addr + size.
- *
- * tlb_flush_all will flush all TLBs.
- *
- * tlb_flush_all is must be provided. if tlb_flush_range is
- * not valid, it will set to tlb_flush_all by default.
- */
-static void sh_tlb_flush(struct isp_mmu *mmu)
-{
-	atomisp_css_mmu_invalidate_tlb();
-}
-
-struct isp_mmu_client sh_mmu_mfld = {
-	.name = "Silicon Hive ISP3000 MMU",
-	.pte_valid_mask = 0x1,
-	.null_pte = (u32)NULL_PAGE,
-	.set_pd_base = sh_set_pd_base,
-	.tlb_flush_all = sh_tlb_flush,
-	.phys_to_pte = sh_phys_to_pte,
-	.pte_to_phys = sh_pte_to_phys,
-};
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mrfld.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mrfld.c
deleted file mode 100644
index 757e6a6..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/atomisp_driver_css15/mmu/sh_mmu_mrfld.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Support for Merrifield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2012 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-#ifndef CSS20
-#include <sh_css.h>
-#endif /* CSS20 */
-
-#ifndef CSS21
-#include <host/mmu_local.h>
-#else
-#include "type_support.h"
-#endif
-
-#include "mmu/isp_mmu.h"
-#include "memory_access/memory_access.h"
-#include "atomisp_compat.h"
-
-/*
- * include SH header file here
- */
-
-static unsigned int sh_phys_to_pte(struct isp_mmu *mmu,
-				   phys_addr_t phys)
-{
-	return phys >> ISP_PAGE_OFFSET;
-}
-
-static phys_addr_t sh_pte_to_phys(struct isp_mmu *mmu,
-				  unsigned int pte)
-{
-	unsigned int mask = mmu->driver->pte_valid_mask;
-	return (phys_addr_t)((pte & ~mask) << ISP_PAGE_OFFSET);
-}
-
-/*
- * set page directory base address (physical address).
- *
- * must be provided.
- */
-static int sh_set_pd_base(struct isp_mmu *mmu,
-			  phys_addr_t phys)
-{
-	unsigned int pte = sh_phys_to_pte(mmu, phys);
-	/*mmgr_set_base_address(HOST_ADDRESS(pte));*/
-	atomisp_css_mmu_set_page_table_base_index(HOST_ADDRESS(pte));
-	return 0;
-}
-
-static unsigned int sh_get_pd_base(struct isp_mmu *mmu,
-				   phys_addr_t phys)
-{
-	unsigned int pte = sh_phys_to_pte(mmu, phys);
-	return HOST_ADDRESS(pte);
-}
-
-/*
- * callback to flush tlb.
- *
- * tlb_flush_range will at least flush TLBs containing
- * address mapping from addr to addr + size.
- *
- * tlb_flush_all will flush all TLBs.
- *
- * tlb_flush_all is must be provided. if tlb_flush_range is
- * not valid, it will set to tlb_flush_all by default.
- */
-static void sh_tlb_flush(struct isp_mmu *mmu)
-{
-	atomisp_css_mmu_invalidate_cache();
-}
-
-struct isp_mmu_client sh_mmu_mrfld = {
-	.name = "Silicon Hive ISP3000 MMU",
-	.pte_valid_mask = 0x80000000,
-	.null_pte = NULL_PAGE >> ISP_PAGE_OFFSET,
-	.set_pd_base = sh_set_pd_base,
-	.get_pd_base = sh_get_pd_base,
-	.tlb_flush_all = sh_tlb_flush,
-	.phys_to_pte = sh_phys_to_pte,
-	.pte_to_phys = sh_pte_to_phys,
-};
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/addr_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/addr_support.h
deleted file mode 100644
index f3286d0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/addr_support.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __ADDR_SUPPORT_H_INCLUDED__
-#define __ADDR_SUPPORT_H_INCLUDED__
-
-/*
- * Compute the byte address offset of a struct or array member from the base struct base
- *
- * Note:
- *	- The header defining the type "T" must be included
- *	- This macro works on all cells, but not necessarily with the same output
- *	- Works for arrays, structs, arrays of structs, arrays in structs etc.
- */
-#define offsetof(T, x) ((unsigned)&(((T *)0)->x))
-#define OFFSET_OF(T, x) offsetof(T, x)
-
-#endif /* __ADDR_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/assert_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/assert_support.h
deleted file mode 100644
index b796a25..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/assert_support.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __ASSERT_SUPPORT_H_INCLUDED__
-#define __ASSERT_SUPPORT_H_INCLUDED__
-
-#if defined(_MSC_VER)
-#include "assert.h"
-#define OP___assert(cnd) assert(cnd)
-#elif defined(__HIVECC)
-
-/*
- * Enabling assert on cells has too many side effects, it should
- * by default be limited to the unsched CSIM mode, or to only
- * controller type processors. Presently there are not controls
- * in place for that
- */
-/* #define OP___assert(cnd) OP___csim_assert(cnd) */
-#define OP___assert(cnd) ((void)0)
-
-#elif defined(__KERNEL__) /* a.o. Android builds */
-
-#include "sh_css_debug.h"
-#define __symbol2value( x ) #x
-#define __symbol2string( x ) __symbol2value( x )
-#define assert( expression )                                            \
-	do {                                                            \
-		if (!(expression))                                      \
-			sh_css_dtrace(SH_DBG_ERROR, "%s",               \
-				"Assertion failed: " #expression        \
-				  ", file " __FILE__                    \
-				  ", line " __symbol2string( __LINE__ ) \
-				  ".\n" );                              \
-	} while (0)
-
-#define OP___assert(cnd) assert(cnd)
-
-#elif defined(__FIST__)
-
-#include "assert.h"
-#define OP___assert(cnd) assert(cnd)
-
-#elif defined(__GNUC__)
-#include "assert.h"
-#define OP___assert(cnd) assert(cnd)
-#else /* default is for unknown environments */
-#define assert(cnd) ((void)0)
-#endif
-
-#endif /* __ASSERT_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/debug.h
deleted file mode 100644
index 8e661fb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/debug.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DEBUG_H_INCLUDED__
-#define __DEBUG_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the DMA device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- *
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "debug_local.h"
-
-#ifndef __INLINE_DEBUG__
-#define STORAGE_CLASS_DEBUG_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_DEBUG_C 
-#include "debug_public.h"
-#else  /* __INLINE_DEBUG__ */
-#define STORAGE_CLASS_DEBUG_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_DEBUG_C STORAGE_CLASS_INLINE
-#include "debug_private.h"
-#endif /* __INLINE_DEBUG__ */
-
-#endif /* __DEBUG_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/device_access/device_access.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/device_access/device_access.h
deleted file mode 100644
index 73b210d..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/device_access/device_access.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DEVICE_ACCESS_H_INCLUDED__
-#define __DEVICE_ACCESS_H_INCLUDED__
-
-/*!
- * \brief
- * Define the public interface for physical system
- * access functions to SRAM and registers. Access
- * types are limited to those defined in <stdint.h>
- * All accesses are aligned
- *
- * The address representation is private to the system
- * and represented as/stored in "hrt_address".
- *
- * The system global address can differ by an offset;
- * The device base address. This offset must be added
- * by the implementation of the access function
- *
- * "store" is a transfer to the device
- * "load" is a transfer from the device
- */
-
-#include <stdint.h>
-#include <stddef.h>
-
-/*
- * User provided file that defines the system address types:
- *	- hrt_address	a type that can hold the (sub)system address range
- */
-#include "system_types.h"
-/*
- * We cannot assume that the global system address size is the size of
- * a pointer because a (say) 64-bit host can be simulated in a 32-bit
- * environment. Only if the host environment is modelled as on the target
- * we could use a pointer. Even then, prototyping may need to be done
- * before the target environment is available. AS we cannot wait for that
- * we are stuck with integer addresses
- */
-
-/*typedef	char *sys_address;*/
-typedef	hrt_address		sys_address;
-
-/*! Set the (sub)system base address
-
- \param	base_addr[in]		The offset on which the (sub)system is located
-							in the global address map
-
- \return none,
- */
-extern void device_set_base_address(
-	const sys_address		base_addr);
-
-
-/*! Get the (sub)system base address
-
- \return base_address,
- */
-extern sys_address device_get_base_address(void);
-
-/*! Read an 8-bit value from a device register or memory in the device
-
- \param	addr[in]			Local address
-
- \return device[addr]
- */
-extern uint8_t device_load_uint8(
-	const hrt_address		addr);
-
-/*! Read a 16-bit value from a device register or memory in the device
-
- \param	addr[in]			Local address
-
- \return device[addr]
- */
-extern uint16_t device_load_uint16(
-	const hrt_address		addr);
-
-/*! Read a 32-bit value from a device register or memory in the device
-
- \param	addr[in]			Local address
-
- \return device[addr]
- */
-extern uint32_t device_load_uint32(
-	const hrt_address		addr);
-
-/*! Read a 64-bit value from a device register or memory in the device
-
- \param	addr[in]			Local address
-
- \return device[addr]
- */
-extern uint64_t device_load_uint64(
-	const hrt_address		addr);
-
-/*! Write an 8-bit value to a device register or memory in the device
-
- \param	addr[in]			Local address
- \param	data[in]			value
-
- \return none, device[addr] = value
- */
-extern void device_store_uint8(
-	const hrt_address		addr,
-	const uint8_t			data);
-
-/*! Write a 16-bit value to a device register or memory in the device
-
- \param	addr[in]			Local address
- \param	data[in]			value
-
- \return none, device[addr] = value
- */
-extern void device_store_uint16(
-	const hrt_address		addr,
-	const uint16_t			data);
-
-/*! Write a 32-bit value to a device register or memory in the device
-
- \param	addr[in]			Local address
- \param	data[in]			value
-
- \return none, device[addr] = value
- */
-extern void device_store_uint32(
-	const hrt_address		addr,
-	const uint32_t			data);
-
-/*! Write a 64-bit value to a device register or memory in the device
-
- \param	addr[in]			Local address
- \param	data[in]			value
-
- \return none, device[addr] = value
- */
-extern void device_store_uint64(
-	const hrt_address		addr,
-	const uint64_t			data);
-
-/*! Read an array of bytes from device registers or memory in the device
-
- \param	addr[in]			Local address
- \param	data[out]			pointer to the destination array
- \param	size[in]			number of bytes to read
-
- \return none
- */
-extern void device_load(
-	const hrt_address		addr,
-	void					*data,
-	const size_t			size);
-
-/*! Write an array of bytes to device registers or memory in the device
-
- \param	addr[in]			Local address
- \param	data[in]			pointer to the source array
- \param	size[in]			number of bytes to write
-
- \return none
- */
-extern void device_store(
-	const hrt_address		addr,
-	const void				*data,
-	const size_t			size);
-
-#endif /* __DEVICE_ACCESS_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/dma.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/dma.h
deleted file mode 100644
index 24d4e69..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/dma.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DMA_H_INCLUDED__
-#define __DMA_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the DMA device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- *
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "dma_local.h"
-
-#ifndef __INLINE_DMA__
-#define STORAGE_CLASS_DMA_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_DMA_C 
-#include "dma_public.h"
-#else  /* __INLINE_DMA__ */
-#define STORAGE_CLASS_DMA_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_DMA_C STORAGE_CLASS_INLINE
-#include "dma_private.h"
-#endif /* __INLINE_DMA__ */
-
-#endif /* __DMA_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/event.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/event.h
deleted file mode 100644
index e217024..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/event.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __EVENT_H_INCLUDED__
-#define __EVENT_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the IRQ device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "event_local.h"
-
-#ifndef __INLINE_EVENT__
-#define STORAGE_CLASS_EVENT_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_EVENT_C 
-#include "event_public.h"
-#else  /* __INLINE_EVENT__ */
-#define STORAGE_CLASS_EVENT_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_EVENT_C STORAGE_CLASS_INLINE
-#include "event_private.h"
-#endif /* __INLINE_EVENT__ */
-
-#endif /* __EVENT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/fifo_monitor.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/fifo_monitor.h
deleted file mode 100644
index 512cd1d..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/fifo_monitor.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __FIFO_MONITOR_H_INCLUDED__
-#define __FIFO_MONITOR_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the input system device(s). It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "fifo_monitor_local.h"
-
-#ifndef __INLINE_FIFO_MONITOR__
-#define STORAGE_CLASS_FIFO_MONITOR_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_FIFO_MONITOR_C 
-#include "fifo_monitor_public.h"
-#else  /* __INLINE_FIFO_MONITOR__ */
-#define STORAGE_CLASS_FIFO_MONITOR_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_FIFO_MONITOR_C STORAGE_CLASS_INLINE
-#include "fifo_monitor_private.h"
-#endif /* __INLINE_FIFO_MONITOR__ */
-
-#endif /* __FIFO_MONITOR_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gdc_device.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gdc_device.h
deleted file mode 100644
index 7753047..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gdc_device.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GDC_DEVICE_H_INCLUDED__
-#define __GDC_DEVICE_H_INCLUDED__
-
-/* The file gdc.h already exists */
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the GDC device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "gdc_local.h"
-
-#ifndef __INLINE_GDC__
-#define STORAGE_CLASS_GDC_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_GDC_C 
-#include "gdc_public.h"
-#else  /* __INLINE_GDC__ */
-#define STORAGE_CLASS_GDC_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_GDC_C STORAGE_CLASS_INLINE
-#include "gdc_private.h"
-#endif /* __INLINE_GDC__ */
-
-#endif /* __GDC_DEVICE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gp_device.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gp_device.h
deleted file mode 100644
index 9861c2c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gp_device.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GP_DEVICE_H_INCLUDED__
-#define __GP_DEVICE_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the input system device(s). It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "gp_device_local.h"
-
-#ifndef __INLINE_GP_DEVICE__
-#define STORAGE_CLASS_GP_DEVICE_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_GP_DEVICE_C 
-#include "gp_device_public.h"
-#else  /* __INLINE_GP_DEVICE__ */
-#define STORAGE_CLASS_GP_DEVICE_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_GP_DEVICE_C STORAGE_CLASS_INLINE
-#include "gp_device_private.h"
-#endif /* __INLINE_GP_DEVICE__ */
-
-#endif /* __GP_DEVICE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gpio.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gpio.h
deleted file mode 100644
index d18030a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/gpio.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GPIO_H_INCLUDED__
-#define __GPIO_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the input system device(s). It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "gpio_local.h"
-
-#ifndef __INLINE_GPIO__
-#define STORAGE_CLASS_GPIO_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_GPIO_C 
-#include "gpio_public.h"
-#else  /* __INLINE_GPIO__ */
-#define STORAGE_CLASS_GPIO_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_GPIO_C STORAGE_CLASS_INLINE
-#include "gpio_private.h"
-#endif /* __INLINE_GPIO__ */
-
-#endif /* __GPIO_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/hmem.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/hmem.h
deleted file mode 100644
index 0ad8163..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/hmem.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __HMEM_H_INCLUDED__
-#define __HMEM_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the VAMEM device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "hmem_local.h"
-
-#ifndef __INLINE_HMEM__
-#define STORAGE_CLASS_HMEM_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_HMEM_C 
-#include "hmem_public.h"
-#else  /* __INLINE_HMEM__ */
-#define STORAGE_CLASS_HMEM_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_HMEM_C STORAGE_CLASS_INLINE
-#include "hmem_private.h"
-#endif /* __INLINE_HMEM__ */
-
-#endif /* __HMEM_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/debug_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/debug_public.h
deleted file mode 100644
index df59e8e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/debug_public.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DEBUG_PUBLIC_H_INCLUDED__
-#define __DEBUG_PUBLIC_H_INCLUDED__
-
-#include "stdbool.h"
-
-#include "system_types.h"
-
-/*! brief
- *
- * Simple queuing trace buffer for debug data
- * instantiatable in SP DMEM
- *
- * The buffer has a remote and and a local store
- * which contain duplicate data (when in sync).
- * The buffers are automatically synched when the
- * user dequeues, or manualy using the synch function
- *
- * An alternative (storage efficient) implementation
- * could manage the buffers to contain unique data
- *
- * The buffer empty status is computed from local
- * state which does not reflect the presence of data
- * in the remote buffer (unless the alternative
- * implementation is followed)
- */
-
-typedef struct debug_data_s		debug_data_t;
-typedef struct debug_data_ddr_s	debug_data_ddr_t;
-
-extern debug_data_t				*debug_data_ptr;
-extern hrt_address				debug_buffer_address;
-extern hrt_vaddress				debug_buffer_ddr_address;
-
-/*! Check the empty state of the local debug data buffer
- 
- \return isEmpty(buffer)
- */
-STORAGE_CLASS_DEBUG_H bool is_debug_buffer_empty(void);
-
-/*! Dequeue a token from the debug data buffer
- 
- \return isEmpty(buffer)?0:buffer[head]
- */
-STORAGE_CLASS_DEBUG_H hrt_data debug_dequeue(void);
-
-/*! Synchronise the remote buffer to the local buffer
- 
- \return none
- */
-STORAGE_CLASS_DEBUG_H void debug_synch_queue(void);
-
-/*! Synchronise the remote buffer to the local buffer
- 
- \return none
- */
-STORAGE_CLASS_DEBUG_H void debug_synch_queue_isp(void);
-
-
-/*! Synchronise the remote buffer to the local buffer
- 
- \return none
- */
-STORAGE_CLASS_DEBUG_H void debug_synch_queue_ddr(void);
-
-/*! Set the offset/address of the (remote) debug buffer
- 
- \return none
- */
-extern void debug_buffer_init(
-	const hrt_address		addr);
-
-/*! Set the offset/address of the (remote) debug buffer
- 
- \return none
- */
-extern void debug_buffer_ddr_init(
-	const hrt_vaddress		addr);
-
-/*! Set the (remote) operating mode of the debug buffer
- 
- \return none
- */
-extern void debug_buffer_setmode(
-	const debug_buf_mode_t	mode);
-
-#endif /* __DEBUG_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/dma_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/dma_public.h
deleted file mode 100644
index 4bf7ea1..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/dma_public.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DMA_PUBLIC_H_INCLUDED__
-#define __DMA_PUBLIC_H_INCLUDED__
-
-#include "system_types.h"
-
-typedef struct dma_state_s		dma_state_t;
-
-/*! Read the control registers of DMA[ID]
- 
- \param	ID[in]				DMA identifier
- \param	state[out]			input formatter state structure
-
- \return none, state = DMA[ID].state
- */
-extern void dma_get_state(
-	const dma_ID_t		ID,
-	dma_state_t			*state);
-
-/*! Write to a control register of DMA[ID]
-
- \param	ID[in]				DMA identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, DMA[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_DMA_H void dma_reg_store(
-	const dma_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value);
-
-/*! Read from a control register of DMA[ID]
- 
- \param	ID[in]				DMA identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return DMA[ID].ctrl[reg]
- */
-STORAGE_CLASS_DMA_H hrt_data dma_reg_load(
-	const dma_ID_t		ID,
-	const unsigned int	reg);
-
-#endif /* __DMA_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/event_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/event_public.h
deleted file mode 100644
index 9902bf4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/event_public.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __EVENT_PUBLIC_H_INCLUDED__
-#define __EVENT_PUBLIC_H_INCLUDED__
-
-#include <stdbool.h>
-#include "system_types.h"
-
-/*! Blocking read from an event source EVENT[ID]
- 
- \param	ID[in]				EVENT identifier
-
- \return none, dequeue(event_queue[ID])
- */
-STORAGE_CLASS_EVENT_H void event_wait_for(
-	const event_ID_t		ID);
-
-/*! Conditional blocking wait for an event source EVENT[ID]
- 
- \param	ID[in]				EVENT identifier
- \param	cnd[in]				predicate
-
- \return none, if(cnd) dequeue(event_queue[ID])
- */
-STORAGE_CLASS_EVENT_H void cnd_event_wait_for(
-	const event_ID_t		ID,
-	const bool				cnd);
-
-/*! Blocking read from an event source EVENT[ID]
- 
- \param	ID[in]				EVENT identifier
-
- \return dequeue(event_queue[ID])
- */
-STORAGE_CLASS_EVENT_H hrt_data event_receive_token(
-	const event_ID_t		ID);
-
-/*! Blocking write to an event sink EVENT[ID]
- 
- \param	ID[in]				EVENT identifier
- \param	token[in]			token to be written on the event
-
- \return none, enqueue(event_queue[ID])
- */
-STORAGE_CLASS_EVENT_H void event_send_token(
-	const event_ID_t		ID,
-	const hrt_data			token);
-
-/*! Query an event source EVENT[ID]
- 
- \param	ID[in]				EVENT identifier
-
- \return !isempty(event_queue[ID])
- */
-STORAGE_CLASS_EVENT_H bool is_event_pending(
-	const event_ID_t		ID);
-
-/*! Query an event sink EVENT[ID]
- 
- \param	ID[in]				EVENT identifier
-
- \return !isfull(event_queue[ID])
- */
-STORAGE_CLASS_EVENT_H bool can_event_send_token(
-	const event_ID_t		ID);
-
-#endif /* __EVENT_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/fifo_monitor_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/fifo_monitor_public.h
deleted file mode 100644
index 9245cdb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/fifo_monitor_public.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __FIFO_MONITOR_PUBLIC_H_INCLUDED__
-#define __FIFO_MONITOR_PUBLIC_H_INCLUDED__
-
-#include "system_types.h"
-
-typedef struct fifo_channel_state_s		fifo_channel_state_t;
-typedef struct fifo_switch_state_s		fifo_switch_state_t;
-typedef struct fifo_monitor_state_s		fifo_monitor_state_t;
-
-/*! Set a fifo switch multiplex
- 
- \param	ID[in]				FIFO_MONITOR identifier
- \param	switch_id[in]		fifo switch identifier
- \param	sel[in]				fifo switch selector
-
- \return none, fifo_switch[switch_id].sel = sel
- */
-STORAGE_CLASS_FIFO_MONITOR_H void fifo_switch_set(
-	const fifo_monitor_ID_t		ID,
-	const fifo_switch_t			switch_id,
-	const hrt_data				sel);
-
-/*! Get a fifo switch multiplex
- 
- \param	ID[in]				FIFO_MONITOR identifier
- \param	switch_id[in]		fifo switch identifier
-
- \return fifo_switch[switch_id].sel
- */
-STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_switch_get(
-	const fifo_monitor_ID_t		ID,
-	const fifo_switch_t			switch_id);
-
-/*! Read the state of FIFO_MONITOR[ID]
- 
- \param	ID[in]				FIFO_MONITOR identifier
- \param	state[out]			fifo monitor state structure
-
- \return none, state = FIFO_MONITOR[ID].state
- */
-extern void fifo_monitor_get_state(
-	const fifo_monitor_ID_t		ID,
-	fifo_monitor_state_t		*state);
-
-/*! Read the state of a fifo channel
- 
- \param	ID[in]				FIFO_MONITOR identifier
- \param	channel_id[in]		fifo channel identifier
- \param	state[out]			fifo channel state structure
-
- \return none, state = fifo_channel[channel_id].state
- */
-extern void fifo_channel_get_state(
-	const fifo_monitor_ID_t		ID,
-	const fifo_channel_t		channel_id,
-	fifo_channel_state_t		*state);
-
-/*! Read the state of a fifo switch
- 
- \param	ID[in]				FIFO_MONITOR identifier
- \param	switch_id[in]		fifo switch identifier
- \param	state[out]			fifo switch state structure
-
- \return none, state = fifo_switch[switch_id].state
- */
-extern void fifo_switch_get_state(
-	const fifo_monitor_ID_t		ID,
-	const fifo_switch_t			switch_id,
-	fifo_switch_state_t			*state);
-
-/*! Write to a control register of FIFO_MONITOR[ID]
- 
- \param	ID[in]				FIFO_MONITOR identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, FIFO_MONITOR[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_FIFO_MONITOR_H void fifo_monitor_reg_store(
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg,
-	const hrt_data				value);
-
-/*! Read from a control register of FIFO_MONITOR[ID]
- 
- \param	ID[in]				FIFO_MONITOR identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return FIFO_MONITOR[ID].ctrl[reg]
- */
-STORAGE_CLASS_FIFO_MONITOR_H hrt_data fifo_monitor_reg_load(
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg);
-
-#endif /* __FIFO_MONITOR_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gdc_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gdc_public.h
deleted file mode 100644
index 5e3cf90..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gdc_public.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GDC_PUBLIC_H_INCLUDED__
-#define __GDC_PUBLIC_H_INCLUDED__
-
-/*! Write the bicubic interpolation table of GDC[ID]
-
- \param	ID[in]				GDC identifier
- \param data[in]			The data matrix to be written
-
- \pre
-	- data must point to a matrix[4][HRT_GDC_N]
-
- \implementation dependent
-	- The value of "HRT_GDC_N" is device specific
-	- The LUT should not be partially written
-	- The LUT format is a quadri-phase interpolation
-	  table. The layout is device specific
-	- The range of the values data[n][m] is device
-	  specific
-
- \return none, GDC[ID].lut[0...3][0...HRT_GDC_N-1] = data
- */
-STORAGE_CLASS_EXTERN void gdc_lut_store(
-	const gdc_ID_t		ID,
-	const int			data[4][HRT_GDC_N]);
-
-/*! Return the integer representation of 1.0 of GDC[ID]
- 
- \param	ID[in]				GDC identifier
-
- \return unity
- */
-STORAGE_CLASS_EXTERN int gdc_get_unity(
-	const gdc_ID_t		ID);
-
-#endif /* __GDC_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gp_device_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gp_device_public.h
deleted file mode 100644
index c05bbbe..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gp_device_public.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GP_DEVICE_PUBLIC_H_INCLUDED__
-#define __GP_DEVICE_PUBLIC_H_INCLUDED__
-
-#include "system_types.h"
-
-typedef struct gp_device_state_s		gp_device_state_t;
-
-/*! Read the state of GP_DEVICE[ID]
- 
- \param	ID[in]				GP_DEVICE identifier
- \param	state[out]			gp device state structure
-
- \return none, state = GP_DEVICE[ID].state
- */
-extern void gp_device_get_state(
-	const gp_device_ID_t		ID,
-	gp_device_state_t			*state);
-
-/*! Write to a control register of GP_DEVICE[ID]
-
- \param	ID[in]				GP_DEVICE identifier
- \param	reg_addr[in]		register byte address
- \param value[in]			The data to be written
-
- \return none, GP_DEVICE[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_GP_DEVICE_H void gp_device_reg_store(
-	const gp_device_ID_t	ID,
-	const unsigned int		reg_addr,
-	const hrt_data			value);
-
-/*! Read from a control register of GP_DEVICE[ID]
- 
- \param	ID[in]				GP_DEVICE identifier
- \param	reg_addr[in]		register byte address
- \param value[in]			The data to be written
-
- \return GP_DEVICE[ID].ctrl[reg]
- */
-STORAGE_CLASS_GP_DEVICE_H hrt_data gp_device_reg_load(
-	const gp_device_ID_t	ID,
-	const unsigned int		reg_addr);
-
-#endif /* __GP_DEVICE_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gpio_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gpio_public.h
deleted file mode 100644
index 800f07c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/gpio_public.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GPIO_PUBLIC_H_INCLUDED__
-#define __GPIO_PUBLIC_H_INCLUDED__
-
-#include "system_types.h"
-
-/*! Write to a control register of GPIO[ID]
-
- \param	ID[in]				GPIO identifier
- \param	reg_addr[in]		register byte address
- \param value[in]			The data to be written
-
- \return none, GPIO[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_GPIO_H void gpio_reg_store(
-	const gpio_ID_t	ID,
-	const unsigned int		reg_addr,
-	const hrt_data			value);
-
-/*! Read from a control register of GPIO[ID]
- 
- \param	ID[in]				GPIO identifier
- \param	reg_addr[in]		register byte address
- \param value[in]			The data to be written
-
- \return GPIO[ID].ctrl[reg]
- */
-STORAGE_CLASS_GPIO_H hrt_data gpio_reg_load(
-	const gpio_ID_t	ID,
-	const unsigned int		reg_addr);
-
-#endif /* __GPIO_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_public.h
deleted file mode 100644
index 87fd518..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_public.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IA_CSS_I_RMGR_PUBLIC_H_INCLUDED__
-#define __IA_CSS_I_RMGR_PUBLIC_H_INCLUDED__
-
-IA_CSS_I_RMGR_INIT(host)
-
-#include "ia_css_i_rmgr_vbuf_public.h"
-
-#endif /* __IA_CSS_I_RMGR_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h
deleted file mode 100644
index d9f3c76..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/ia_css_i_rmgr_vbuf_public.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IA_CSS_I_HOST_RMGR_VBUF_PUBLIC_H_INCLUDED__
-#define __IA_CSS_I_HOST_RMGR_VBUF_PUBLIC_H_INCLUDED__
-
-#include "ia_css_i_rmgr.h"
-
-/* declare supported types and functions
- *
- */
-IA_CSS_I_RMGR_TYPE(host, vbuf)
-
-IA_CSS_I_REFCOUNT(host, vbuf)
-
-/* include the system shared declarations
- */
-#include "ia_css_i_rmgr_vbuf_shared.h"
-
-#endif /* __IA_CSS_I_HOST_RMGR_VBUF_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_formatter_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_formatter_public.h
deleted file mode 100644
index f1a6ae8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_formatter_public.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_FORMATTER_PUBLIC_H_INCLUDED__
-#define __INPUT_FORMATTER_PUBLIC_H_INCLUDED__
-
-#include <stdbool.h>
-
-#include "system_types.h"
-
-/*! Reset INPUT_FORMATTER[ID]
- 
- \param	ID[in]				INPUT_FORMATTER identifier
-
- \return none, reset(INPUT_FORMATTER[ID])
- */
-extern void input_formatter_rst(
-	const input_formatter_ID_t		ID);
-
-/*! Set the blocking mode of INPUT_FORMATTER[ID]
- 
- \param	ID[in]				INPUT_FORMATTER identifier
- \param	enable[in]			blocking enable flag
-
- \use
-	- In HW, the capture unit will deliver an infinite stream of frames,
-	  the input formatter will synchronise on the first SOF. In simulation
-	  there are only a fixed number of frames, presented only once. By
-	  enabling blocking the inputformatter will wait on the first presented
-	  frame, thus avoiding race in the simulation setup.
-
- \return none, INPUT_FORMATTER[ID].blocking_mode = enable
- */
-extern void input_formatter_set_fifo_blocking_mode(
-	const input_formatter_ID_t		ID,
-	const bool						enable);
-
-/*! Return the data alignment of INPUT_FORMATTER[ID]
- 
- \param	ID[in]				INPUT_FORMATTER identifier
-
- \return alignment(INPUT_FORMATTER[ID].data)
- */
-extern unsigned int input_formatter_get_alignment(
-	const input_formatter_ID_t		ID);
-
-/*! Read the control registers of INPUT_FORMATTER[ID]
- 
- \param	ID[in]				INPUT_FORMATTER identifier
- \param	state[out]			input formatter state structure
-
- \return none, state = INPUT_FORMATTER[ID].state
- */
-extern void input_formatter_get_state(
-	const input_formatter_ID_t		ID,
-	input_formatter_state_t			*state);
-
-/*! Write to a control register of INPUT_FORMATTER[ID]
- 
- \param	ID[in]				INPUT_FORMATTER identifier
- \param	reg_addr[in]		register byte address
- \param value[in]			The data to be written
-
- \return none, INPUT_FORMATTER[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_INPUT_FORMATTER_H void input_formatter_reg_store(
-	const input_formatter_ID_t	ID,
-	const unsigned int			reg_addr,
-	const hrt_data				value);
-
-/*! Read from a control register of INPUT_FORMATTER[ID]
- 
- \param	ID[in]				INPUT_FORMATTER identifier
- \param	reg_addr[in]		register byte address
- \param value[in]			The data to be written
-
- \return INPUT_FORMATTER[ID].ctrl[reg]
- */
-STORAGE_CLASS_INPUT_FORMATTER_H hrt_data input_formatter_reg_load(
-	const input_formatter_ID_t	ID,
-	const unsigned int			reg_addr);
-
-#endif /* __INPUT_FORMATTER_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_system_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_system_public.h
deleted file mode 100644
index 945caa4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/input_system_public.h
+++ /dev/null
@@ -1,241 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_SYSTEM_PUBLIC_H_INCLUDED__
-#define __INPUT_SYSTEM_PUBLIC_H_INCLUDED__
-
-#include "stdbool.h"
-
-typedef struct input_system_state_s		input_system_state_t;
-typedef struct receiver_state_s			receiver_state_t;
-
-/*! Read the state of INPUT_SYSTEM[ID]
-
- \param	ID[in]				INPUT_SYSTEM identifier
- \param	state[out]			input system state structure
-
- \return none, state = INPUT_SYSTEM[ID].state
- */
-extern void input_system_get_state(
-	const input_system_ID_t		ID,
-	input_system_state_t		*state);
-
-/*! Read the state of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	state[out]			receiver state structure
-
- \return none, state = RECEIVER[ID].state
- */
-extern void receiver_get_state(
-	const rx_ID_t				ID,
-	receiver_state_t			*state);
-
-/*! Flag whether a MIPI format is YUV420
-
- \param	mipi_format[in]		MIPI format
-
- \return mipi_format == YUV420
- */
-extern bool is_mipi_format_yuv420(
-	const mipi_format_t			mipi_format);
-
-/*! Set compression parameters for cfg[cfg_ID] of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	cfg_ID[in]			Configuration identifier
- \param	comp[in]			Compression method
- \param	pred[in]			Predictor method
-
- \NOTE: the storage of compression configuration is
-        implementation specific. The config can be
-        carried either on MIPI ports or on MIPI channels
-
- \return none, RECEIVER[ID].cfg[cfg_ID] = {comp, pred}
- */
-extern void receiver_set_compression(
-	const rx_ID_t				ID,
-	const unsigned int			cfg_ID,
-	const mipi_compressor_t		comp,
-	const mipi_predictor_t		pred);
-
-/*! Enable PORT[port_ID] of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	port_ID[in]			mipi PORT identifier
- \param	cnd[in]				irq predicate
-
- \return None, enable(RECEIVER[ID].PORT[port_ID])
- */
-extern void receiver_port_enable(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const bool					cnd);
-
-/*! Flag if PORT[port_ID] of RECEIVER[ID] is enabled
-
- \param	ID[in]				RECEIVER identifier
- \param	port_ID[in]			mipi PORT identifier
-
- \return enable(RECEIVER[ID].PORT[port_ID]) == true
- */
-extern bool is_receiver_port_enabled(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID);
-
-/*! Enable the IRQ channels of PORT[port_ID] of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	port_ID[in]			mipi PORT identifier
- \param	irq_info[in]		irq channels
-
- \return None, enable(RECEIVER[ID].PORT[port_ID].irq_info)
- */
-extern void receiver_irq_enable(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const rx_irq_info_t			irq_info);
-
-/*! Return the IRQ status of PORT[port_ID] of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	port_ID[in]			mipi PORT identifier
-
- \return RECEIVER[ID].PORT[port_ID].irq_info
- */
-extern rx_irq_info_t receiver_get_irq_info(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID);
-
-/*! Clear the IRQ status of PORT[port_ID] of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	port_ID[in]			mipi PORT identifier
- \param	irq_info[in]		irq status
-
- \return None, clear(RECEIVER[ID].PORT[port_ID].irq_info)
- */
-extern void receiver_irq_clear(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const rx_irq_info_t			irq_info);
-
-/*! Write to a control register of INPUT_SYSTEM[ID]
-
- \param	ID[in]				INPUT_SYSTEM identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, INPUT_SYSTEM[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_INPUT_SYSTEM_H void input_system_reg_store(
-	const input_system_ID_t		ID,
-	const unsigned int			reg,
-	const hrt_data				value);
-
-/*! Read from a control register of INPUT_SYSTEM[ID]
-
- \param	ID[in]				INPUT_SYSTEM identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return INPUT_SYSTEM[ID].ctrl[reg]
- */
-STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_reg_load(
-	const input_system_ID_t		ID,
-	const unsigned int			reg);
-
-/*! Write to a control register of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, RECEIVER[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_INPUT_SYSTEM_H void receiver_reg_store(
-	const rx_ID_t				ID,
-	const unsigned int			reg,
-	const hrt_data				value);
-
-/*! Read from a control register of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return RECEIVER[ID].ctrl[reg]
- */
-STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_reg_load(
-	const rx_ID_t				ID,
-	const unsigned int			reg);
-
-/*! Write to a control register of PORT[port_ID] of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	port_ID[in]			mipi PORT identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, RECEIVER[ID].PORT[port_ID].ctrl[reg] = value
- */
-STORAGE_CLASS_INPUT_SYSTEM_H void receiver_port_reg_store(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const unsigned int			reg,
-	const hrt_data				value);
-
-/*! Read from a control register PORT[port_ID] of of RECEIVER[ID]
-
- \param	ID[in]				RECEIVER identifier
- \param	port_ID[in]			mipi PORT identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return RECEIVER[ID].PORT[port_ID].ctrl[reg]
- */
-STORAGE_CLASS_INPUT_SYSTEM_H hrt_data receiver_port_reg_load(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const unsigned int			reg);
-
-/*! Write to a control register of SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
-
- \param	ID[in]				INPUT_SYSTEM identifier
- \param	port_ID[in]			sub system identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg] = value
- */
-STORAGE_CLASS_INPUT_SYSTEM_H void input_system_sub_system_reg_store(
-	const input_system_ID_t		ID,
-	const sub_system_ID_t		sub_ID,
-	const unsigned int			reg,
-	const hrt_data				value);
-
-/*! Read from a control register SUB_SYSTEM[sub_ID] of INPUT_SYSTEM[ID]
-
- \param	ID[in]				INPUT_SYSTEM identifier
- \param	port_ID[in]			sub system identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return INPUT_SYSTEM[ID].SUB_SYSTEM[sub_ID].ctrl[reg]
- */
-STORAGE_CLASS_INPUT_SYSTEM_H hrt_data input_system_sub_system_reg_load(
-	const input_system_ID_t		ID,
-	const sub_system_ID_t		sub_ID,
-	const unsigned int			reg);
-
-#endif /* __INPUT_SYSTEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/irq_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/irq_public.h
deleted file mode 100644
index 8f9eac7..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/irq_public.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IRQ_PUBLIC_H_INCLUDED__
-#define __IRQ_PUBLIC_H_INCLUDED__
-
-#include "system_types.h"
-#include "stdbool.h"
-
-/*! Read the control registers of IRQ[ID]
-
- \param	ID[in]				IRQ identifier
- \param	state[out]			irq controller state structure
-
- \return none, state = IRQ[ID].state
- */
-extern void irq_controller_get_state(
-	const irq_ID_t				ID,
-	irq_controller_state_t		*state);
-
-/*! Write to a control register of IRQ[ID]
-
- \param	ID[in]				IRQ identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, IRQ[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_IRQ_H void irq_reg_store(
-	const irq_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value);
-
-/*! Read from a control register of IRQ[ID]
-
- \param	ID[in]				IRQ identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return IRQ[ID].ctrl[reg]
- */
-STORAGE_CLASS_IRQ_H hrt_data irq_reg_load(
-	const irq_ID_t		ID,
-	const unsigned int	reg);
-
-/*! Enable an IRQ channel of IRQ[ID] with a mode
-
- \param	ID[in]				IRQ (device) identifier
- \param	irq[in]				IRQ (channel) identifier
-
- \return none, enable(IRQ[ID].channel[irq_ID])
- */
-extern void irq_enable_channel(
-	const irq_ID_t				ID,
-	const unsigned int			irq_ID);
-
-/*! Enable pulse interrupts for IRQ[ID] with a mode
-
- \param	ID[in]				IRQ (device) identifier
- \param	enable				enable/disable pulse interrupts
-
- \return none
- */
-extern void irq_enable_pulse(
-	const irq_ID_t	ID,
-	bool 			pulse);
-
-/*! Disable an IRQ channel of IRQ[ID]
-
- \param	ID[in]				IRQ (device) identifier
- \param	irq[in]				IRQ (channel) identifier
-
- \return none, disable(IRQ[ID].channel[irq_ID])
- */
-extern void irq_disable_channel(
-	const irq_ID_t				ID,
-	const unsigned int			irq);
-
-/*! Clear the state of all IRQ channels of IRQ[ID]
-
- \param	ID[in]				IRQ (device) identifier
-
- \return none, clear(IRQ[ID].channel[])
- */
-extern void irq_clear_all(
-	const irq_ID_t				ID);
-
-/*! Return the ID of a signalling IRQ channel of IRQ[ID]
-
- \param	ID[in]				IRQ (device) identifier
- \param irq_id[out]			active IRQ (channel) identifier
-
- \Note: This function operates as strtok(), based on the return
-  state the user is informed if there are additional signalling
-  channels
-
- \return state(IRQ[ID])
- */
-extern enum hrt_isp_css_irq_status irq_get_channel_id(
-	const irq_ID_t				ID,
-	unsigned int				*irq_id);
-
-/*! Raise an interrupt on channel irq_id of device IRQ[ID]
-
- \param	ID[in]				IRQ (device) identifier
- \param	irq_id[in]			IRQ (channel) identifier
-
- \return none, signal(IRQ[ID].channel[irq_id])
- */
-extern void irq_raise(
-	const irq_ID_t				ID,
-	const irq_sw_channel_id_t	irq_id);
-
-/*! Enable an IRQ channel of the virtual super IRQ
-
- \param	irq[in]				IRQ (channel) identifier
- \param	en[in]				boolean channel enable
-
- \return none, VIRQ.channel[irq_ID].enable = en
- */
-extern void virq_enable_channel(
-	const virq_id_t				irq_ID,
-	const bool					en);
-
-/*! Clear the state of all IRQ channels of the virtual super IRQ
-
- \return none, clear(VIRQ.channel[])
- */
-extern void virq_clear_all(void);
-
-/*! Clear the IRQ info state of the virtual super IRQ
-
- \param irq_info[in/out]	The IRQ (channel) state
-
- \return none
- */
-extern void virq_clear_info(
-	virq_info_t					*irq_info);
-
-/*! Return the ID of a signalling IRQ channel of the virtual super IRQ
-
- \param irq_id[out]			active IRQ (channel) identifier
-
- \Note: This function operates as strtok(), based on the return
-  state the user is informed if there are additional signalling
-  channels
-
- \return state(IRQ[...])
- */
-extern enum hrt_isp_css_irq_status virq_get_channel_id(
-	virq_id_t					*irq_id);
-
-/*! Return the IDs of all signaling IRQ channels of the virtual super IRQ
-
- \param irq_info[out]		all active IRQ (channel) identifiers
-
- \Note: Unlike "irq_get_channel_id()" this function returns all
-  channel signaling info. The new info is OR'd with the current
-  info state. N.B. this is the same as repeatedly calling the function
-  "irq_get_channel_id()" in a (non-blocked) handler routine
-
- \return (error(state(IRQ[...]))
- */
-extern enum hrt_isp_css_irq_status virq_get_channel_signals(
-	virq_info_t					*irq_info);
-
-#endif /* __IRQ_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/isp_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/isp_public.h
deleted file mode 100644
index b62af48..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/isp_public.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __ISP_PUBLIC_H_INCLUDED__
-#define __ISP_PUBLIC_H_INCLUDED__
-
-#include <stddef.h>			/* size_t */
-#include <stdbool.h>		/* bool */
-#include <stdint.h>			/* uint32_t */
-
-#include "system_types.h"
-
-/*! Enable or disable the program complete irq signal of ISP[ID]
-
- \param	ID[in]				SP identifier
- \param	cnd[in]				predicate
-
- \return none, if(cnd) enable(ISP[ID].irq) else disable(ISP[ID].irq)
- */
-extern void cnd_isp_irq_enable(
-	const isp_ID_t		ID,
-	const bool			cnd);
-
-/*! Read the state of cell ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	state[out]			isp state structure
- \param	stall[out]			isp stall conditions
-
- \return none, state = ISP[ID].state, stall = ISP[ID].stall
- */
-extern void isp_get_state(
-	const isp_ID_t		ID,
-	isp_state_t			*state,
-	isp_stall_t			*stall);
-
-
-/*! Write to the status and control register of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, ISP[ID].sc[reg] = value
- */
-STORAGE_CLASS_ISP_H void isp_ctrl_store(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value);
-
-/*! Read from the status and control register of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return ISP[ID].sc[reg]
- */
-STORAGE_CLASS_ISP_H hrt_data isp_ctrl_load(
-	const isp_ID_t		ID,
-	const unsigned int	reg);
-
-/*! Get the status of a bitfield in the control register of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	reg[in]				register index
- \param bit[in]				The bit index to be checked
-
- \return  (ISP[ID].sc[reg] & (1<<bit)) != 0
- */
-STORAGE_CLASS_ISP_H bool isp_ctrl_getbit(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit);
-
-/*! Set a bitfield in the control register of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	reg[in]				register index
- \param bit[in]				The bit index to be set
-
- \return none, ISP[ID].sc[reg] |= (1<<bit)
- */
-STORAGE_CLASS_ISP_H void isp_ctrl_setbit(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit);
-
-/*! Clear a bitfield in the control register of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	reg[in]				register index
- \param bit[in]				The bit index to be set
-
- \return none, ISP[ID].sc[reg] &= ~(1<<bit)
- */
-STORAGE_CLASS_ISP_H void isp_ctrl_clearbit(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit);
-
-/*! Write to the DMEM of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be written
- \param size[in]			The size(in bytes) of the data to be written
-
- \return none, ISP[ID].dmem[addr...addr+size-1] = data
- */
-STORAGE_CLASS_ISP_H void isp_dmem_store(
-	const isp_ID_t		ID,
-	unsigned int		addr,
-	const void			*data,
-	const size_t		size);
-
-/*! Read from the DMEM of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be read
- \param size[in]			The size(in bytes) of the data to be read
-
- \return none, data = ISP[ID].dmem[addr...addr+size-1]
- */
-STORAGE_CLASS_ISP_H void isp_dmem_load(
-	const isp_ID_t		ID,
-	const unsigned int	addr,
-	void				*data,
-	const size_t		size);
-
-/*! Write a 32-bit datum to the DMEM of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be written
- \param size[in]			The size(in bytes) of the data to be written
-
- \return none, ISP[ID].dmem[addr] = data
- */
-STORAGE_CLASS_ISP_H void isp_dmem_store_uint32(
-	const isp_ID_t		ID,
-	unsigned int		addr,
-	const uint32_t		data);
-
-/*! Load a 32-bit datum from the DMEM of ISP[ID]
-
- \param	ID[in]				ISP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be read
- \param size[in]			The size(in bytes) of the data to be read
-
- \return none, data = ISP[ID].dmem[addr]
- */
-STORAGE_CLASS_ISP_H uint32_t isp_dmem_load_uint32(
-	const isp_ID_t		ID,
-	const unsigned int	addr);
-
-/*! Concatenate the LSW and MSW into a double precision word
-
- \param	x0[in]				Integer containing the LSW
- \param	x1[in]				Integer containing the MSW
-
- \return x0 | (x1 << bits_per_vector_element)
- */
-STORAGE_CLASS_ISP_H uint32_t isp_2w_cat_1w(
-	const uint16_t		x0,
-	const uint16_t		x1);
-
-#endif /* __ISP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/mmu_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/mmu_public.h
deleted file mode 100644
index de39db6..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/mmu_public.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __MMU_PUBLIC_H_INCLUDED__
-#define __MMU_PUBLIC_H_INCLUDED__
-
-#include "system_types.h"
-
-/*! Set the page table base index of MMU[ID]
-
- \param	ID[in]				MMU identifier
- \param	base_index[in]		page table base index
-
- \return none, MMU[ID].page_table_base_index = base_index
- */
-STORAGE_CLASS_EXTERN void mmu_set_page_table_base_index(
-	const mmu_ID_t		ID,
-	const hrt_data		base_index);
-
-/*! Get the page table base index of MMU[ID]
-
- \param	ID[in]				MMU identifier
- \param	base_index[in]		page table base index
-
- \return MMU[ID].page_table_base_index
- */
-STORAGE_CLASS_EXTERN hrt_data mmu_get_page_table_base_index(
-	const mmu_ID_t		ID);
-
-/*! Invalidate the page table cache of MMU[ID]
-
- \param	ID[in]				MMU identifier
-
- \return none
- */
-STORAGE_CLASS_EXTERN void mmu_invalidate_cache(
-	const mmu_ID_t		ID);
-
-
-/*! Write to a control register of MMU[ID]
-
- \param	ID[in]				MMU identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, MMU[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_MMU_H void mmu_reg_store(
-	const mmu_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value);
-
-/*! Read from a control register of MMU[ID]
-
- \param	ID[in]				MMU identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return MMU[ID].ctrl[reg]
- */
-STORAGE_CLASS_MMU_H hrt_data mmu_reg_load(
-	const mmu_ID_t		ID,
-	const unsigned int	reg);
-
-#endif /* __MMU_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/queue_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/queue_public.h
deleted file mode 100644
index 6a0369b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/queue_public.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __QUEUE_PUBLIC_H_INCLUDED__
-#define __QUEUE_PUBLIC_H_INCLUDED__
-
-#include <stdbool.h>	/* bool */
-#include <stdint.h>		/* uint32_t */
-
-#include "sh_css_internal.h"	/* enum sh_css_frame_id */
-
-
-/*! The Host initialize the "host2sp" queues.
- */
-extern void init_host2sp_queues(void);
-
-/*! The Host initialize the "sp2host" queues.
- */
-extern void init_sp2host_queues(void);
-
-/************************************************************
- *
- * Buffer queues (the host -> the SP).
- *
- ************************************************************/
-/*! The Host puts the buffer at the tail of the queue
-
- \param	pipe_num[in]			the pipe number
- \param stage_num[in]			the stage number
- \param	ERROR frame_id[in]			the frame type
- \param	ERROR frame_data[in]			the frame that will be enqueued
-
- \return !isFull(host2sp_queue[pipe_num][stage_num][frame_id])
- */
-extern bool host2sp_enqueue_buffer(
-	unsigned int pipe_num,
-	unsigned int stage_num,
-	enum sh_css_buffer_queue_id index,
-	uint32_t buffer_ptr);
-
-/************************************************************
- *
- * Buffer queues (the SP -> the host).
- *
- ************************************************************/
-/*! The Host gets the buffer at the head of the queue
-
- \param	pipe_num[in]			the pipe number
- \param stage_num[in]			the stage number
- \param	ERROR frame_id[in]			the frame type
- \param	ERROR frame_data[out]			the frame that will be dequeued
-
- \return !isEmpty(sp2host_queue[frame_id])
- */
-extern bool sp2host_dequeue_buffer(
-	unsigned int pipe_num,
-	unsigned int stage_num,
-	enum sh_css_buffer_queue_id index,
-	uint32_t *buffer_ptr);
-
-/************************************************************
- *
- * Event queues (the host -> the SP).
- *
- ************************************************************/
-/*! The Host puts the SP event at the tail of the queue.
-
- \param	event[in]			the SP event that will be queued
-
- \return !isFull(host2sp_queue)
- */
-extern bool host2sp_enqueue_sp_event(
-		uint32_t event);
-
-/************************************************************
- *
- * Event queues (the SP -> the host).
- *
- ************************************************************/
-/*! The Host gets the IRQ event from the IRQ queue
-
- \param	event[out]			the IRQ event that will be dequeued
-
- \return !isEmpty(sp2host_queue)
- */
-extern bool sp2host_dequeue_irq_event(
-	uint32_t *event);
-
-#endif /* __QUEUE_PUBLIC_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sp_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sp_public.h
deleted file mode 100644
index 84a6386..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sp_public.h
+++ /dev/null
@@ -1,225 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SP_PUBLIC_H_INCLUDED__
-#define __SP_PUBLIC_H_INCLUDED__
-
-#include <stddef.h>			/* size_t */
-#include <stdbool.h>		/* bool */
-#include <stdint.h>			/* uint32_t */
-
-#include "system_types.h"
-
-typedef struct sp_state_s		sp_state_t;
-typedef struct sp_stall_s		sp_stall_t;
-
-/*! Enable or disable the program complete irq signal of SP[ID]
- 
- \param	ID[in]				SP identifier
- \param	cnd[in]				predicate
-
- \return none, if(cnd) enable(SP[ID].irq) else disable(SP[ID].irq)
- */
-extern void cnd_sp_irq_enable(
-	const sp_ID_t		ID,
-	const bool			cnd);
-
-/*! Read the state of cell SP[ID]
- 
- \param	ID[in]				SP identifier
- \param	state[out]			sp state structure
- \param	stall[out]			isp stall conditions
-
- \return none, state = SP[ID].state, stall = SP[ID].stall
- */
-extern void sp_get_state(
-	const sp_ID_t		ID,
-	sp_state_t			*state,
-	sp_stall_t			*stall);
-
-/*! Write to the status and control register of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return none, SP[ID].sc[reg] = value
- */
-STORAGE_CLASS_SP_H void sp_ctrl_store(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value);
-
-/*! Read from the status and control register of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	reg[in]				register index
- \param value[in]			The data to be written
-
- \return SP[ID].sc[reg]
- */
-STORAGE_CLASS_SP_H hrt_data sp_ctrl_load(
-	const sp_ID_t		ID,
-	const unsigned int	reg);
-
-/*! Get the status of a bitfield in the control register of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	reg[in]				register index
- \param bit[in]				The bit index to be checked
-
- \return  (SP[ID].sc[reg] & (1<<bit)) != 0
- */
-STORAGE_CLASS_SP_H bool sp_ctrl_getbit(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit);
-
-/*! Set a bitfield in the control register of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	reg[in]				register index
- \param bit[in]				The bit index to be set
-
- \return none, SP[ID].sc[reg] |= (1<<bit)
- */
-STORAGE_CLASS_SP_H void sp_ctrl_setbit(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit);
-
-/*! Clear a bitfield in the control register of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	reg[in]				register index
- \param bit[in]				The bit index to be set
-
- \return none, SP[ID].sc[reg] &= ~(1<<bit)
- */
-STORAGE_CLASS_SP_H void sp_ctrl_clearbit(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit);
-
-/*! Write to the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be written
- \param size[in]			The size(in bytes) of the data to be written
-
- \return none, SP[ID].dmem[addr...addr+size-1] = data
- */
-STORAGE_CLASS_SP_H void sp_dmem_store(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const void			*data,
-	const size_t		size);
-
-/*! Read from the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be read
- \param size[in]			The size(in bytes) of the data to be read
-
- \return none, data = SP[ID].dmem[addr...addr+size-1]
- */
-STORAGE_CLASS_SP_H void sp_dmem_load(
-	const sp_ID_t		ID,
-	const unsigned int	addr,
-	void				*data,
-	const size_t		size);
-
-/*! Write a 8-bit datum to the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be written
- \param size[in]			The size(in bytes) of the data to be written
-
- \return none, SP[ID].dmem[addr...addr+size-1] = data
- */
-STORAGE_CLASS_SP_H void sp_dmem_store_uint8(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const uint8_t		data);
-
-/*! Write a 16-bit datum to the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be written
- \param size[in]			The size(in bytes) of the data to be written
-
- \return none, SP[ID].dmem[addr...addr+size-1] = data
- */
-STORAGE_CLASS_SP_H void sp_dmem_store_uint16(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const uint16_t		data);
-
-/*! Write a 32-bit datum to the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be written
- \param size[in]			The size(in bytes) of the data to be written
-
- \return none, SP[ID].dmem[addr...addr+size-1] = data
- */
-STORAGE_CLASS_SP_H void sp_dmem_store_uint32(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const uint32_t		data);
-
-/*! Load a 8-bit datum from the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be read
- \param size[in]			The size(in bytes) of the data to be read
-
- \return none, data = SP[ID].dmem[addr...addr+size-1]
- */
-STORAGE_CLASS_SP_H uint8_t sp_dmem_load_uint8(
-	const sp_ID_t		ID,
-	const unsigned int	addr);
-
-/*! Load a 16-bit datum from the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be read
- \param size[in]			The size(in bytes) of the data to be read
-
- \return none, data = SP[ID].dmem[addr...addr+size-1]
- */
-STORAGE_CLASS_SP_H uint16_t sp_dmem_load_uint16(
-	const sp_ID_t		ID,
-	const unsigned int	addr);
-
-/*! Load a 32-bit datum from the DMEM of SP[ID]
-
- \param	ID[in]				SP identifier
- \param	addr[in]			the address in DMEM
- \param data[in]			The data to be read
- \param size[in]			The size(in bytes) of the data to be read
-
- \return none, data = SP[ID].dmem[addr...addr+size-1]
- */
-STORAGE_CLASS_SP_H uint32_t sp_dmem_load_uint32(
-	const sp_ID_t		ID,
-	const unsigned int	addr);
-
-#endif /* __SP_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sw_event_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sw_event_public.h
deleted file mode 100644
index f598ccc..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/sw_event_public.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-/****************************************************************
- *
- * Time   : 2012-09-06, 11:16.
- * Author : zhengjie.lu@intel.com
- * Comment:
- * - Initial version.
- *
- ****************************************************************/
-
-#ifndef __SW_EVENT_PUBLIC_H_INCLUDED__
-#define __SW_EVENT_PUBLIC_H_INCLUDED__
-
-#include <stdbool.h>
-#include "system_types.h"
-
-/**
- * @brief Encode the information into the software-event.
- * Encode a certain amount of information into a signel software-event.
- *
- * @param[in]	in	The inputs of the encoder.
- * @param[in]	nr	The number of inputs.
- * @param[out]	out	The output of the encoder.
- *
- * @return true if it is successfull.
- */
-STORAGE_CLASS_SW_EVENT_H bool encode_sw_event(
-	uint32_t	*in,
-	uint32_t	nr,
-	uint32_t	*out);
-#endif /* __SW_EVENT_PUBLIC_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/tag_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/tag_public.h
deleted file mode 100644
index 01ddfe7..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/tag_public.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TAG_PUBLIC_H_INCLUDED__
-#define __TAG_PUBLIC_H_INCLUDED__
-
-/**
- * @brief	Creates the tag description from the given parameters.
- * @param[in]	num_captures
- * @param[in]	skip
- * @param[in]	offset
- * @param[out]	tag_descr
- */
-void
-sh_css_create_tag_descr(int num_captures,
-			unsigned int skip,
-			int offset,
-			unsigned int exp_id,
-			struct sh_css_tag_descr *tag_descr);
-
-/**
- * @brief	Encodes the members of tag description into a 32-bit value.
- * @param[in]	tag		Pointer to the tag description
- * @return	(unsigned int)	Encoded 32-bit tag-info
- */
-unsigned int
-sh_css_encode_tag_descr(struct sh_css_tag_descr *tag);
-
-#endif /* __TAG_PUBLIC_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/timed_ctrl_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/timed_ctrl_public.h
deleted file mode 100644
index 97869e8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/timed_ctrl_public.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TIMED_CTRL_PUBLIC_H_INCLUDED__
-#define __TIMED_CTRL_PUBLIC_H_INCLUDED__
-
-#include "system_types.h"
-
-/*! Write to a control register of TIMED_CTRL[ID]
-
- \param	ID[in]				TIMED_CTRL identifier
- \param	reg_addr[in]		register byte address
- \param value[in]			The data to be written
-
- \return none, TIMED_CTRL[ID].ctrl[reg] = value
- */
-STORAGE_CLASS_TIMED_CTRL_H void timed_ctrl_reg_store(
-	const timed_ctrl_ID_t	ID,
-	const unsigned int		reg_addr,
-	const hrt_data			value);
-
-extern void timed_ctrl_snd_commnd(
-	const timed_ctrl_ID_t				ID,
-	hrt_data				mask,
-	hrt_data				condition,
-	hrt_data				counter,
-	hrt_address				addr,
-	hrt_data				value);
-
-extern void timed_ctrl_snd_sp_commnd(
-	const timed_ctrl_ID_t				ID,
-	hrt_data				mask,
-	hrt_data				condition,
-	hrt_data				counter,
-	const sp_ID_t			SP_ID,
-	hrt_address				offset,
-	hrt_data				value);
-
-extern void timed_ctrl_snd_gpio_commnd(
-	const timed_ctrl_ID_t				ID,
-	hrt_data				mask,
-	hrt_data				condition,
-	hrt_data				counter,
-	const gpio_ID_t			GPIO_ID,
-	hrt_address				offset,
-	hrt_data				value);
-
-
-
-#endif /* __TIMED_CTRL_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/vamem_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/vamem_public.h
deleted file mode 100644
index 4cfed14..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/host/vamem_public.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __VAMEM_PUBLIC_H_INCLUDED__
-#define __VAMEM_PUBLIC_H_INCLUDED__
-
-
-
-#endif /* __VAMEM_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/ia_css_i_rmgr.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/ia_css_i_rmgr.h
deleted file mode 100644
index 7ff694e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/ia_css_i_rmgr.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IA_CSS_I_RMGR_GLOBAL_H_INCLUDED__
-#define __IA_CSS_I_RMGR_GLOBAL_H_INCLUDED__
-
-#include "storage_class.h"
-
-#ifndef __INLINE_RMGR__
-#define STORAGE_CLASS_RMGR_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_RMGR_C
-#else  /* __INLINE_RMGR__ */
-#define STORAGE_CLASS_RMGR_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_RMGR_C STORAGE_CLASS_INLINE
-#endif /* __INLINE_RMGR__ */
-
-/* definition of init uninit function that needs to be implemented
- * per system?
- */
-#define IA_CSS_I_RMGR_INIT(proc) \
-void ia_css_i_ ## proc ## _rmgr_init(void); \
-\
-void ia_css_i_ ## proc ## _rmgr_uninit(void);
-
-/*
- * macro to define the interface for resource type
- */
-#define IA_CSS_I_RMGR_TYPE(proc, type) \
-\
-struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool; \
-\
-struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle; \
-\
-STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_init_ ## type( \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool); \
-\
-STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_uninit_ ## type( \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool); \
-\
-STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_acq_ ## type( \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool, \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle); \
-\
-STORAGE_CLASS_RMGR_H void ia_css_i_ ## proc ## _rmgr_rel_ ## type( \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _pool *pool, \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle); \
-
-/*
- * macro to define the interface for refcounting
- */
-#define IA_CSS_I_REFCOUNT(proc, type) \
-void ia_css_i_ ## proc ## _refcount_retain_ ## type( \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle); \
-\
-void ia_css_i_ ## proc ## _refcount_release_ ## type( \
-	struct ia_css_i_ ## proc ## _rmgr_ ## type ## _handle **handle);
-
-
-#include "ia_css_i_rmgr_public.h"
-
-
-#endif /* __IA_CSS_I_RMGR_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_formatter.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_formatter.h
deleted file mode 100644
index c66922b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_formatter.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_FORMATTER_H_INCLUDED__
-#define __INPUT_FORMATTER_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the input system device(s). It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "input_formatter_local.h"
-
-#ifndef __INLINE_INPUT_FORMATTER__
-#define STORAGE_CLASS_INPUT_FORMATTER_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_INPUT_FORMATTER_C 
-#include "input_formatter_public.h"
-#else  /* __INLINE_INPUT_FORMATTER__ */
-#define STORAGE_CLASS_INPUT_FORMATTER_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_INPUT_FORMATTER_C STORAGE_CLASS_INLINE
-#include "input_formatter_private.h"
-#endif /* __INLINE_INPUT_FORMATTER__ */
-
-#endif /* __INPUT_FORMATTER_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_system.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_system.h
deleted file mode 100644
index cfb417d..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/input_system.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_SYSTEM_H_INCLUDED__
-#define __INPUT_SYSTEM_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the input system device(s). It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "input_system_local.h"
-
-#ifndef __INLINE_INPUT_SYSTEM__
-#define STORAGE_CLASS_INPUT_SYSTEM_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_INPUT_SYSTEM_C 
-#include "input_system_public.h"
-#else  /* __INLINE_INPUT_SYSTEM__ */
-#define STORAGE_CLASS_INPUT_SYSTEM_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_INPUT_SYSTEM_C STORAGE_CLASS_INLINE
-#include "input_system_private.h"
-#endif /* __INLINE_INPUT_SYSTEM__ */
-
-#endif /* __INPUT_SYSTEM_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/irq.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/irq.h
deleted file mode 100644
index 5a11620..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/irq.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IRQ_H_INCLUDED__
-#define __IRQ_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the IRQ device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "irq_local.h"
-
-#ifndef __INLINE_IRQ__
-#define STORAGE_CLASS_IRQ_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_IRQ_C 
-#include "irq_public.h"
-#else  /* __INLINE_IRQ__ */
-#define STORAGE_CLASS_IRQ_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_IRQ_C STORAGE_CLASS_INLINE
-#include "irq_private.h"
-#endif /* __INLINE_IRQ__ */
-
-#endif /* __IRQ_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/isp.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/isp.h
deleted file mode 100644
index 5679ca1..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/isp.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __ISP_H_INCLUDED__
-#define __ISP_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the ISP cell. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "isp_local.h"
-
-#ifndef __INLINE_ISP__
-#define STORAGE_CLASS_ISP_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_ISP_C 
-#include "isp_public.h"
-#else  /* __INLINE_iSP__ */
-#define STORAGE_CLASS_ISP_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_ISP_C STORAGE_CLASS_INLINE
-#include "isp_private.h"
-#endif /* __INLINE_ISP__ */
-
-#endif /* __ISP_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/math_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/math_support.h
deleted file mode 100644
index 47c0ce3..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/math_support.h
+++ /dev/null
@@ -1,383 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __MATH_SUPPORT_H_INCLUDED__
-#define __MATH_SUPPORT_H_INCLUDED__
-
-/* ceil((real)a / b) */
-#define ceil_div(a,b) (((a)+(b)-1)/(b))
-
-#if defined(_MSC_VER)
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-#define max(a, b) ((a) > (b) ? (a) : (b))
-#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
-#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
-
-#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
-#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
-#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
-#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
-#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
-#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
-#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
-
-#ifndef SH_CSS_CEIL_INLINE
-#define MAX(a, b)	 	_MAX(a,b)
-#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
-#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
-#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
-#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
-
-#else /* SH_CSS_CEIL_INLINE */
-
-#define MAX(a, b)	 	_max(a,b)
-#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
-#define CEIL_DIV(a, b)   	_ceil_div(a, b)
-#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
-#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
-
-static __inline unsigned _max(unsigned a, unsigned b)
-{
-	return _MAX(a,b);
-}
-
-static __inline unsigned _min(unsigned a, unsigned b)
-{
-	return _MIN(a,b);
-}
-
-static __inline unsigned _ceil_div(unsigned a, unsigned b)
-{
-	return _CEIL_DIV(a,b);
-}
-
-static inline unsigned _ceil_mul(unsigned a, unsigned b)
-{
-	return _CEIL_MUL(a,b);
-}
-
-static __inline unsigned _ceil_shift(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT(a,b);
-}
-
-static __inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT_MUL(a,b);
-}
-
-static __inline unsigned _ceil_mul2(unsigned a, unsigned b)
-{
-	return _CEIL_MUL2(a,b);
-}
-
-#endif /* SH_CSS_CEIL_INLINE */
-
-#elif defined(__HIVECC)
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-#define max(a, b) ((a) > (b) ? (a) : (b))
-#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
-/* the HIVE operator clip() is an assymetric bound() */
-#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
-
-#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
-#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
-#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
-#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
-#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
-#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
-#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
-
-#ifndef SH_CSS_CEIL_INLINE
-#define MAX(a, b)	 	_MAX(a,b)
-#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
-#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
-#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
-#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
-
-#else /* SH_CSS_CEIL_INLINE */
-
-#define MAX(a, b)	 	_max(a,b)
-#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
-#define CEIL_DIV(a, b)   	_ceil_div(a, b)
-#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
-#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
-
-static inline unsigned _max(unsigned a, unsigned b)
-{
-	return _MAX(a,b);
-}
-
-static inline unsigned _min(unsigned a, unsigned b)
-{
-	return _MIN(a,b);
-}
-
-static inline unsigned _ceil_div(unsigned a, unsigned b)
-{
-	return _CEIL_DIV(a,b);
-}
-
-static inline unsigned _ceil_mul(unsigned a, unsigned b)
-{
-	return _CEIL_MUL(a,b);
-}
-
-static inline unsigned _ceil_shift(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT(a,b);
-}
-
-static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT_MUL(a,b);
-}
-
-static inline unsigned _ceil_mul2(unsigned a, unsigned b)
-{
-	return _CEIL_MUL2(a,b);
-}
-
-#endif /* SH_CSS_CEIL_INLINE */
-
-#elif defined(__KERNEL__)
-
-#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
-#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
-#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
-#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
-#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
-#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
-#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
-
-#ifndef SH_CSS_CEIL_INLINE
-#define MAX(a, b)	 	_MAX(a,b)
-#define MIN(a, b)		_MIN(a,b)
-#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
-#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
-#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
-#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
-
-#else /* SH_CSS_CEIL_INLINE */
-
-#define MAX(a, b)	 	_max(a,b)
-#define MIN(a, b)		_min(a,b)
-#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
-#define CEIL_DIV(a, b)   	_ceil_div(a, b)
-#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
-#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
-
-static inline unsigned _max(unsigned a, unsigned b)
-{
-	return _MAX(a,b);
-}
-
-static inline unsigned _min(unsigned a, unsigned b)
-{
-	return _MIN(a,b);
-}
-
-static inline unsigned _ceil_div(unsigned a, unsigned b)
-{
-	return _CEIL_DIV(a,b);
-}
-
-static inline unsigned _ceil_mul(unsigned a, unsigned b)
-{
-	return _CEIL_MUL(a,b);
-}
-
-static inline unsigned _ceil_shift(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT(a,b);
-}
-
-static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT_MUL(a,b);
-}
-
-static inline unsigned _ceil_mul2(unsigned a, unsigned b)
-{
-	return _CEIL_MUL2(a,b);
-}
-
-#endif /* SH_CSS_CEIL_INLINE */
-
-#elif defined(__FIST__)
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-#define max(a, b) ((a) > (b) ? (a) : (b))
-#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
-#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
-
-#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
-#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
-#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
-#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
-#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
-#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
-#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
-
-#ifndef SH_CSS_CEIL_INLINE
-#define MAX(a, b)	 	_MAX(a,b)
-#define MIN(a, b)		_MIN(a,b)
-#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
-#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
-#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
-#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
-
-#else /* SH_CSS_CEIL_INLINE */
-
-#define MAX(a, b)	 	_max(a,b)
-#define MIN(a, b)		_min(a,b)
-#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
-#define CEIL_DIV(a, b)   	_ceil_div(a, b)
-#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
-#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
-
-static inline unsigned _max(unsigned a, unsigned b)
-{
-	return _MAX(a,b);
-}
-
-static inline unsigned _min(unsigned a, unsigned b)
-{
-	return _MIN(a,b);
-}
-
-static inline unsigned _ceil_div(unsigned a, unsigned b)
-{
-	return _CEIL_DIV(a,b);
-}
-
-static inline unsigned _ceil_mul(unsigned a, unsigned b)
-{
-	return _CEIL_MUL(a,b);
-}
-
-static inline unsigned _ceil_shift(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT(a,b);
-}
-
-static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT_MUL(a,b);
-}
-
-static inline unsigned _ceil_mul2(unsigned a, unsigned b)
-{
-	return _CEIL_MUL2(a,b);
-}
-
-#endif /* SH_CSS_CEIL_INLINE */
-
-#elif defined(__GNUC__)
-
-#define min(a, b) ((a) < (b) ? (a) : (b))
-#define max(a, b) ((a) > (b) ? (a) : (b))
-/*
-#define min(a, b) ({ \
-	__typeof__ (a) _a = (a); \
-	__typeof__ (b) _b = (b); \
-	_a < _b ? _a : _b; }) 
-
-#define max(a, b) ({ \
-	__typeof__ (a) _a = (a); \
-	__typeof__ (b) _b = (b); \
-	_a > _b ? _a : _b; }) 
- */
-#define clamp(a, min_val, max_val) min(max(a, min_val), max_val)
-#define bound(min_val, x, max_val) min(max(x, min_val), max_val)
-
-#define _MAX(a, b)        ((a) > (b) ? (a) : (b))
-#define _MIN(a, b)        ((a) < (b) ? (a) : (b))
-#define _CEIL_MUL(a, b)   (CEIL_DIV(a, b) * (b))
-#define _CEIL_DIV(a, b)   ((b) ? ((a)+(b)-1)/(b) : 0)
-#define _CEIL_SHIFT(a, b) (((a)+(1<<(b))-1)>>(b))
-#define _CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
-#define _CEIL_MUL2(a, b)  (((a)+(b)-1) & ~((b)-1))
-
-#ifndef SH_CSS_CEIL_INLINE
-#define MAX(a, b)	 	_MAX(a,b)
-#define CEIL_MUL(a, b)		_CEIL_MUL(a, b) 
-#define CEIL_DIV(a, b)   	_CEIL_DIV(a, b)
-#define CEIL_SHIFT(a, b) 	_CEIL_SHIFT(a, b)
-#define CEIL_SHIFT_MUL(a, b)  	_CEIL_SHIFT_MUL(a, b)
-#define CEIL_MUL2(a, b)  	_CEIL_MUL2(a, b)
-
-#else /* SH_CSS_CEIL_INLINE */
-
-#define MAX(a, b)	 	_max(a,b)
-#define CEIL_MUL(a, b)		_ceil_mul(a, b) 
-#define CEIL_DIV(a, b)   	_ceil_div(a, b)
-#define CEIL_SHIFT(a, b) 	_ceil_shift(a, b)
-
-#define CEIL_SHIFT_MUL(a, b)  	_ceil_shift_mul(a, b)
-#define CEIL_MUL2(a, b)  	_ceil_mul2(a, b)
-
-static inline unsigned _max(unsigned a, unsigned b)
-{
-	return _MAX(a,b);
-}
-
-static inline unsigned _min(unsigned a, unsigned b)
-{
-	return _MIN(a,b);
-}
-
-static inline unsigned _ceil_div(unsigned a, unsigned b)
-{
-	return _CEIL_DIV(a,b);
-}
-
-static inline unsigned _ceil_mul(unsigned a, unsigned b)
-{
-	return _CEIL_MUL(a,b);
-}
-
-static inline unsigned _ceil_shift(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT(a,b);
-}
-
-static inline unsigned _ceil_shift_mul(unsigned a, unsigned b)
-{
-	return _CEIL_SHIFT_MUL(a,b);
-}
-
-static inline unsigned _ceil_mul2(unsigned a, unsigned b)
-{
-	return _CEIL_MUL2(a,b);
-}
-
-#endif /* SH_CSS_CEIL_INLINE */
-
-#else /* default is for an unknown environment */
-
-/* already defined */
-
-#endif
-
-#endif /* __MATH_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/memory_access/memory_access.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/memory_access/memory_access.h
deleted file mode 100644
index f4d6a21..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/memory_access/memory_access.h
+++ /dev/null
@@ -1,274 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __MEMORY_ACCESS_H_INCLUDED__
-#define __MEMORY_ACCESS_H_INCLUDED__
-
-/*!
- * \brief
- * Define the public interface for virtual memory
- * access functions. Access types are limited to
- * those defined in <stdint.h>
- *
- * The address representation is private to the system
- * and represented as "hrt_vaddress" rather than a
- * pointer, as the memory allocation cannot be accessed
- * by dereferencing but reaquires load and store access
- * functions
- *
- * The page table selection or virtual memory context;
- * The page table base index; Is implicit. This page
- * table base index must be set by the implementation
- * of the access function
- *
- * "store" is a transfer to the system
- * "load" is a transfer from the system
- *
- * Allocation properties can be specified by setting
- * attributes (see below) in case of multiple physical
- * memories the memory ID is encoded on the attribute
- *
- * Allocations in the same physical memory, but in a
- * different (set of) page tables can be shared through
- * a page table information mapping function
- */
-
-#include <stdint.h>
-#include <stddef.h>
-
-/*
- * User provided file that defines the (sub)system address types:
- *	- hrt_vaddress	a type that can hold the (sub)system virtual address range
- */
-#include "system_types.h"
-
-/*
- * The MMU base address is a physical address, thus the same type is used
- * as for the device base address
- */
-#include "device_access.h"
-
-/*!
- * \brief
- * Bit masks for specialised allocation functions
- * the default is "uncached", "not contiguous",
- * "not page aligned" and "not cleared"
- *
- * Forcing alignment (usually) returns a pointer
- * at an alignment boundary that is offset from
- * the allocated pointer. Without storing this
- * pointer/offset, we cannot free it. The memory
- * manager is responsible for the bookkeeping, e.g.
- * the allocation function creates a sentinel
- * within the allocation referencable from the
- * returned pointer/address.
- */
-#define MMGR_ATTRIBUTE_MASK			0x000f
-#define MMGR_ATTRIBUTE_CACHED		0x0001
-#define MMGR_ATTRIBUTE_CONTIGUOUS	0x0002
-#define MMGR_ATTRIBUTE_PAGEALIGN	0x0004
-#define MMGR_ATTRIBUTE_CLEARED		0x0008
-#define MMGR_ATTRIBUTE_UNUSED		0xfff0
-
-/* #define MMGR_ATTRIBUTE_DEFAULT	(MMGR_ATTRIBUTE_CACHED) */
-#define MMGR_ATTRIBUTE_DEFAULT	0
-
-extern const hrt_vaddress	mmgr_NULL;
-
-/*! Set the (sub)system virtual memory page table base address
-
- \param	base_addr[in]		The address where page table 0 is located
-
- \Note: The base_addr is an absolute system address, thus it is not
-        relative to the DDR base address
-
- \return none,
- */
-extern void mmgr_set_base_address(
-	const sys_address		base_addr);
-
-/*! Get the (sub)system virtual memory page table base address
-
- \return base_address,
- */
-extern sys_address mmgr_get_base_address(void);
-
-
-/*! Set the (sub)system virtual memory page table base index
-
- \param	base_addr[in]		The index  where page table 0 is located
-
- \Note: The base_index is the MSB section of an absolute system address,
-        the in-page address bits are discared. The base address is not
-		relative to the DDR base address
-
- \return none,
- */
-extern void mmgr_set_base_index(
-	const hrt_data			base_index);
-
-/*! Get the (sub)system virtual memory page table base index
-
- \return base_address,
- */
-extern hrt_data mmgr_get_base_index(void);
-
-/*! Return the address of an allocation in memory
-
- \param	size[in]			Size in bytes of the allocation
-
- \return vaddress
- */
-extern hrt_vaddress mmgr_malloc(
-	const size_t			size);
-
-/*! Return the address of a zero initialised allocation in memory
-
- \param	size[in]			Size in bytes of the allocation
-
- \return vaddress
- */
-extern hrt_vaddress mmgr_calloc(
-	const size_t			N,
-	const size_t			size);
-
-/*! Return the address of a reallocated allocation in memory
-
- \param	vaddr[in]			Address of an allocation
- \param	size[in]			Size in bytes of the allocation
-
- \Note
-	All limitations and particularities of the C stdlib
-	realloc function apply
-
- \return vaddress
- */
-extern hrt_vaddress mmgr_realloc(
-	hrt_vaddress			vaddr,
-	const size_t			size);
-
-/*! Free the memory allocation identified by the address
-
- \param	vaddr[in]			Address of the allocation
-
- \return vaddress
- */
-extern void mmgr_free(
-	hrt_vaddress			vaddr);
-
-/*! Return the address of an allocation in memory
-
- \param	size[in]			Size in bytes of the allocation
- \param	attribute[in]		Bit vector specifying the properties
-							of the allocation including zero
-							initialisation
-
- \return vaddress
- */
-extern hrt_vaddress mmgr_alloc_attr(
-	const size_t			size,
-	const uint16_t			attribute);
-
-/*! Return the address of a reallocated allocation in memory
-
- \param	vaddr[in]			Address of an allocation
- \param	size[in]			Size in bytes of the allocation
- \param	attribute[in]		Bit vector specifying the properties
-							of the allocation
-
- \Note
-	All limitations and particularities of the C stdlib
-	realloc function apply
-
- \return vaddress
- */
-extern hrt_vaddress mmgr_realloc_attr(
-	hrt_vaddress			vaddr,
-	const size_t			size,
-	const uint16_t			attribute);
-
-/*! Return the address of a mapped existing allocation in memory
-
- \param	ptr[in]				Pointer to an allocation in a different
-							virtual memory page table, but the same
-							physical memory
- \param size[in]			Size of the memory of the pointer
- \param	attribute[in]			Bit vector specifying the properties
-					of the allocation
- \param context				Pointer of a context provided by
-					client/driver for additonal parameters
-					needed by the implementation
-
- \Note
-	This interface is tentative, limited to the desired function
-	the actual interface may require furhter parameters
-
- \return vaddress
- */
-extern hrt_vaddress mmgr_mmap(
-	const void *ptr,
-	const size_t size,
-	uint16_t attribute,
-	void *context);
-
-/*! Zero initialise an allocation in memory
-
- \param	vaddr[in]			Address of an allocation
- \param	size[in]			Size in bytes of the area to be cleared
-
- \return none
- */
-extern void mmgr_clear(
-	hrt_vaddress			vaddr,
-	const size_t			size);
-
-/*! Set an allocation in memory to a value
-
- \param	vaddr[in]			Address of an allocation
- \param	data[in]			Value to set
- \param	size[in]			Size in bytes of the area to be set
-
- \return none
- */
-extern void mmgr_set(
-	hrt_vaddress			vaddr,
-	const uint8_t			data,
-	const size_t			size);
-
-/*! Read an array of bytes from a virtual memory address
-
- \param	vaddr[in]			Address of an allocation
- \param	data[out]			pointer to the destination array
- \param	size[in]			number of bytes to read
-
- \return none
- */
-extern void mmgr_load(
-	const hrt_vaddress		vaddr,
-	void					*data,
-	const size_t			size);
-
-/*! Write an array of bytes to device registers or memory in the device
-
- \param	vaddr[in]			Address of an allocation
- \param	data[in]			pointer to the source array
- \param	size[in]			number of bytes to write
-
- \return none
- */
-extern void mmgr_store(
-	const hrt_vaddress		vaddr,
-	const void				*data,
-	const size_t			size);
-
-#endif /* __MEMORY_ACCESS_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/mmu_device.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/mmu_device.h
deleted file mode 100644
index d45bb0e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/mmu_device.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __MMU_DEVICE_H_INCLUDED__
-#define __MMU_DEVICE_H_INCLUDED__
-
-/* The file mmu.h already exists */
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the MMU device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "mmu_local.h"
-
-#ifndef __INLINE_MMU__
-#define STORAGE_CLASS_MMU_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_MMU_C 
-#include "mmu_public.h"
-#else  /* __INLINE_MMU__ */
-#define STORAGE_CLASS_MMU_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_MMU_C STORAGE_CLASS_INLINE
-#include "mmu_private.h"
-#endif /* __INLINE_MMU__ */
-
-#endif /* __MMU_DEVICE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/platform_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/platform_support.h
deleted file mode 100644
index ec05a36..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/platform_support.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __PLATFORM_SUPPORT_H_INCLUDED__
-#define __PLATFORM_SUPPORT_H_INCLUDED__
-
-#if defined(_MSC_VER)
-/*
- * Put here everything _MSC_VER specific not covered in
- * "assert_support.h", "math_support.h", etc
- */
-
-#elif defined(__HIVECC)
-/*
- * Put here everything __HIVECC specific not covered in
- * "assert_support.h", "math_support.h", etc
- */
-#include "hrt/host.h"
-
-#elif defined(__KERNEL__)
-/*
- * Put here everything __KERNEL__ specific not covered in
- * "assert_support.h", "math_support.h", etc
- */
-#elif defined(__FIST__)
-/*
- * Put here everything __FIST__ specific not covered in
- * "assert_support.h", "math_support.h", etc
- */
-
-#elif defined(__GNUC__)
-/*
- * Put here everything __GNUC__ specific not covered in
- * "assert_support.h", "math_support.h", etc
- */
-#include "hrt/host.h"
-
-
-#else /* default is for unknwn environments */
-/*
- * Put here everything specific not covered in
- * "assert_support.h", "math_support.h", etc
- */
-
-#endif
-
-#endif /* __PLATFORM_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/print_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/print_support.h
deleted file mode 100644
index 77386c9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/print_support.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __PRINT_SUPPORT_H_INCLUDED__
-#define __PRINT_SUPPORT_H_INCLUDED__
-
-#if defined(_MSC_VER)
-
-#include <stdio.h>
-
-#elif defined(__HIVECC)
-/*
- * Use OP___dump()
- */
-
-#elif defined(__KERNEL__)
-/* printk() */
-
-#elif defined(__FIST__)
-
-#elif defined(__GNUC__)
-
-#include <stdio.h>
-
-#else /* default is for unknown environments */
-
-/* ? */
-
-#endif
-
-#endif /* __PRINT_SUPPORT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/program_load/program_load.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/program_load/program_load.h
deleted file mode 100644
index 17c112f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/program_load/program_load.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __PROGRAM_LOAD_H_INCLUDED__
-#define __PROGRAM_LOAD_H_INCLUDED__
-
-#include <stdbool.h>
-
-extern bool program_load(
-	const cell_id_t			ID,
-	const firmware_h		firmware);
-
-#endif /* __PROGRAM_LOAD_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/queue.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/queue.h
deleted file mode 100644
index 48d050b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/queue.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __QUEUE_H_INCLUDED__
-#define __QUEUE_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and is system agnostic
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  cell specific interfaces
- *	- private: cell specific inline implementations
- *	- global:  inter cell constants and identifiers
- *	- local:   cell specific constants and identifiers
- *
- */
-
-#include "storage_class.h"
-
-#include "queue_local.h"
-
-#ifndef __INLINE_QUEUE__
-#define STORAGE_CLASS_QUEUE_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_QUEUE_C 
-#include "queue_public.h"
-#else  /* __INLINE_QUEUE__ */
-#define STORAGE_CLASS_QUEUE_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_QUEUE_C STORAGE_CLASS_INLINE
-#include "queue_private.h"
-#endif /* __INLINE_QUEUE__ */
-
-#endif /* __QUEUE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/resource.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/resource.h
deleted file mode 100644
index 3dc37e0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/resource.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __RESOURCE_H_INCLUDED__
-#define __RESOURCE_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses a RESOURCE manager. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- *
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "resource_local.h"
-
-#ifndef __INLINE_RESOURCE__
-#define STORAGE_CLASS_RESOURCE_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_RESOURCE_C 
-#include "resource_public.h"
-#else  /* __INLINE_RESOURCE__ */
-#define STORAGE_CLASS_RESOURCE_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_RESOURCE_C STORAGE_CLASS_INLINE
-#include "resource_private.h"
-#endif /* __INLINE_RESOURCE__ */
-
-#endif /* __RESOURCE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/socket.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/socket.h
deleted file mode 100644
index ea8a5a8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/socket.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SOCKET_H_INCLUDED__
-#define __SOCKET_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the DMA device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- *
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "socket_local.h"
-
-#ifndef __INLINE_SOCKET__
-#define STORAGE_CLASS_SOCKET_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_SOCKET_C 
-#include "socket_public.h"
-#else  /* __INLINE_SOCKET__ */
-#define STORAGE_CLASS_SOCKET_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_SOCKET_C STORAGE_CLASS_INLINE
-#include "socket_private.h"
-#endif /* __INLINE_SOCKET__ */
-
-#endif /* __SOCKET_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sp.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sp.h
deleted file mode 100644
index d6bd873..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sp.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SP_H_INCLUDED__
-#define __SP_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the SP cell. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "sp_local.h"
-
-#ifndef __INLINE_SP__
-#define STORAGE_CLASS_SP_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_SP_C 
-#include "sp_public.h"
-#else  /* __INLINE_SP__ */
-#define STORAGE_CLASS_SP_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_SP_C STORAGE_CLASS_INLINE
-#include "sp_private.h"
-#endif /* __INLINE_SP__ */
-
-#endif /* __SP_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdbool/stdbool.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdbool/stdbool.h
deleted file mode 100644
index be54b50..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdbool/stdbool.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __STDBOOL_H_INCLUDED__
-#define __STDBOOL_H_INCLUDED__
-
-#ifndef __cplusplus
-
-#if defined(_MSC_VER)
-typedef unsigned int bool;
-
-#define true	1
-#define false	0
-
-#elif defined(__GNUC__)
-#ifndef __KERNEL__
-/* Linux kernel driver defines stdbool types in types.h */
-typedef unsigned int	bool;
-
-#define true	1
-#define false	0
-
-/*
- *Alternatively
- * 
-typedef enum {
-	false = 0,
-	true
-} bool;
- */
-#endif
-#endif
-
-#endif /* __cplusplus */
-
-#endif /* __STDBOOL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdint/stdint.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdint/stdint.h
deleted file mode 100644
index e535531..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stdint/stdint.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __STDINT_H_INCLUDED__
-#define __STDINT_H_INCLUDED__
-
-#if defined(_MSC_VER)
-typedef unsigned char		uint8_t;
-typedef signed char			int8_t;
-
-typedef unsigned short		uint16_t;
-typedef signed short		int16_t;
-
-typedef unsigned int		uint32_t;
-typedef signed int			int32_t;
-
-typedef unsigned long long	uint64_t;
-typedef signed long long	int64_t;
-
-#define _UINT8_MAX			0xff
-#define _UINT16_MAX			0xffff
-#define _UINT32_MAX			0xffffffffUL
-#define _UINT64_MAX			0xffffffffffffffffULL
-
-#define _INT8_MAX			0x7f
-#define _INT16_MAX			0x7fff
-#define _INT32_MAX			0x7fffffffL
-#define _INT64_MAX			0x7fffffffffffffffLL
-
-#define _INT8_MIN			0x80
-#define _INT16_MIN			0x8000
-#define _INT32_MIN			0x80000000L
-#define _INT64_MIN			0x8000000000000000LL
-
-#elif defined(__GNUC__) || defined(__HIVECC)
-
-#ifndef __KERNEL__
-/* Linux kernel driver defines stdint types in types.h */
-typedef unsigned char		uint8_t;
-typedef signed char			int8_t;
-
-typedef unsigned short		uint16_t;
-typedef signed short		int16_t;
-
-typedef unsigned int		uint32_t;
-typedef signed int			int32_t;
-
-typedef unsigned long long	uint64_t;
-typedef signed long long	int64_t;
-#endif /* __KERNEL__ */
-
-#define UINT8_MAX			0xff
-#define UINT16_MAX			0xffff
-#define UINT32_MAX			0xffffffffUL
-#define UINT64_MAX			0xffffffffffffffffULL
-
-#define INT8_MAX			0x7f
-#define INT16_MAX			0x7fff
-#define INT32_MAX			0x7fffffffL
-#define INT64_MAX			0x7fffffffffffffffLL
-
-#define INT8_MIN			0x80
-#define INT16_MIN			0x8000
-#define INT32_MIN			0x80000000L
-#define INT64_MIN			0x8000000000000000LL
-
-#endif
-
-#endif /* __STDINT_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/storage_class.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/storage_class.h
deleted file mode 100644
index 2468e9f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/storage_class.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __STORAGE_CLASS_H_INCLUDED__
-#define __STORAGE_CLASS_H_INCLUDED__
-
-#define STORAGE_CLASS_EXTERN extern
-
-#if defined(_MSC_VER)
-#define STORAGE_CLASS_INLINE static __inline
-#elif defined(__HIVECC)
-#define STORAGE_CLASS_INLINE static inline
-#else
-#define STORAGE_CLASS_INLINE static inline
-#endif
-
-#endif /* __STORAGE_CLASS_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stream_buffer.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stream_buffer.h
deleted file mode 100644
index 4dfe03c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/stream_buffer.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __STREAM_BUFFER_H_INCLUDED__
-#define __STREAM_BUFFER_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the DMA device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- *
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "stream_buffer_local.h"
-
-#ifndef __INLINE_STREAM_BUFFER__
-#define STORAGE_CLASS_STREAM_BUFFER_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_STREAM_BUFFER_C 
-#include "stream_buffer_public.h"
-#else  /* __INLINE_STREAM_BUFFER__ */
-#define STORAGE_CLASS_STREAM_BUFFER_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_STREAM_BUFFER_C STORAGE_CLASS_INLINE
-#include "stream_buffer_private.h"
-#endif /* __INLINE_STREAM_BUFFER__ */
-
-#endif /* __STREAM_BUFFER_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sw_event.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sw_event.h
deleted file mode 100644
index ef0357f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/sw_event.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-/****************************************************************
- *
- * Time   : 2012-09-06, 11:16.
- * Author : zhengjie.lu@intel.com
- * Comment:
- * - Initial version.
- *
- ****************************************************************/
-
-#ifndef __SW_EVENT_H_INCLUDED__
-#define __SW_EVENT_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the IRQ device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "sw_event_local.h"
-
-#ifndef __INLINE_SW_EVENT__
-#define STORAGE_CLASS_SW_EVENT_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_SW_EVENT_C 
-#include "sw_event_public.h"
-#else  /* __INLINE_SW_EVENT__ */
-#define STORAGE_CLASS_SW_EVENT_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_SW_EVENT_C STORAGE_CLASS_INLINE
-#include "sw_event_private.h"
-#endif /* __INLINE_SW_EVENT__ */
-
-#endif /* __SW_EVENT_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/system_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/system_types.h
deleted file mode 100644
index 78fbfcc..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/system_types.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SYSTEM_TYPES_H_INCLUDED__
-#define __SYSTEM_TYPES_H_INCLUDED__
-
-#include "system_local.h"
-
-#endif /* __SYSTEM_TYPES_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/tag.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/tag.h
deleted file mode 100644
index 3646f0f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/tag.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TAG_H_INCLUDED__
-#define __TAG_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and is system agnostic
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  cell specific interfaces
- *	- private: cell specific inline implementations
- *	- global:  inter cell constants and identifiers
- *	- local:   cell specific constants and identifiers
- *
- */
-
-#include "storage_class.h"
-
-#include "tag_local.h"
-
-#ifndef __INLINE_TAG__
-#define STORAGE_CLASS_TAG_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_TAG_C 
-#include "tag_public.h"
-#else  /* __INLINE_TAG__ */
-#define STORAGE_CLASS_TAG_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_TAG_C STORAGE_CLASS_INLINE
-#include "tag_private.h"
-#endif /* __INLINE_TAG__ */
-
-#endif /* __TAG_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/timed_ctrl.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/timed_ctrl.h
deleted file mode 100644
index 49619bb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/timed_ctrl.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TIMED_CTRL_H_INCLUDED__
-#define __TIMED_CTRL_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the input system device(s). It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "timed_ctrl_local.h"
-
-#ifndef __INLINE_TIMED_CTRL__
-#define STORAGE_CLASS_TIMED_CTRL_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_TIMED_CTRL_C 
-#include "timed_ctrl_public.h"
-#else  /* __INLINE_TIMED_CTRL__ */
-#define STORAGE_CLASS_TIMED_CTRL_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_TIMED_CTRL_C STORAGE_CLASS_INLINE
-#include "timed_ctrl_private.h"
-#endif /* __INLINE_TIMED_CTRL__ */
-
-#endif /* __TIMED_CTRL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vamem.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vamem.h
deleted file mode 100644
index ccda51c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vamem.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __VAMEM_H_INCLUDED__
-#define __VAMEM_H_INCLUDED__
-
-/*
- * This file is included on every cell {SP,ISP,host} and on every system
- * that uses the VAMEM device. It defines the API to DLI bridge
- *
- * System and cell specific interfaces and inline code are included
- * conditionally through Makefile path settings.
- *
- *  - .        system and cell agnostic interfaces, constants and identifiers
- *	- public:  system agnostic, cell specific interfaces
- *	- private: system dependent, cell specific interfaces & inline implementations
- *	- global:  system specific constants and identifiers
- *	- local:   system and cell specific constants and identifiers
- */
-
-#include "storage_class.h"
-
-#include "system_local.h"
-#include "vamem_local.h"
-
-#ifndef __INLINE_VAMEM__
-#define STORAGE_CLASS_VAMEM_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_VAMEM_C 
-#include "vamem_public.h"
-#else  /* __INLINE_VAMEM__ */
-#define STORAGE_CLASS_VAMEM_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_VAMEM_C STORAGE_CLASS_INLINE
-#include "vamem_private.h"
-#endif /* __INLINE_VAMEM__ */
-
-#endif /* __VAMEM_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_func.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_func.h
deleted file mode 100644
index f2f6fcf..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_func.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __VECTOR_FUNC_H_INCLUDED__
-#define __VECTOR_FUNC_H_INCLUDED__
-
-#include "storage_class.h"
-
-#include "vector_func_local.h"
-
-#ifndef __INLINE_VECTOR_FUNC__
-#define STORAGE_CLASS_VECTOR_FUNC_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_VECTOR_FUNC_C 
-#include "vector_func_public.h"
-#else  /* __INLINE_VECTOR_FUNC__ */
-#define STORAGE_CLASS_VECTOR_FUNC_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_VECTOR_FUNC_C STORAGE_CLASS_INLINE
-#include "vector_func_private.h"
-#endif /* __INLINE_VECTOR_FUNC__ */
-
-#endif /* __VECTOR_FUNC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_ops.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_ops.h
deleted file mode 100644
index adea9ac..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_include/vector_ops.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __VECTOR_OPS_H_INCLUDED__
-#define __VECTOR_OPS_H_INCLUDED__
-
-#include "storage_class.h"
-
-#include "vector_ops_local.h"
-
-#ifndef __INLINE_VECTOR_OPS__
-#define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_VECTOR_OPS_C 
-#include "vector_ops_public.h"
-#else  /* __INLINE_VECTOR_OPS__ */
-#define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_INLINE
-#define STORAGE_CLASS_VECTOR_OPS_C STORAGE_CLASS_INLINE
-#include "vector_ops_private.h"
-#endif /* __INLINE_VECTOR_OPS__ */
-
-#endif /* __VECTOR_OPS_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c
deleted file mode 100644
index 70c00c7..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_shared.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "ia_css_i_rmgr.h"
-
-#include <stdbool.h>
-#include <assert_support.h>
-
-
-void ia_css_i_host_rmgr_init(void)
-{
-	ia_css_i_host_rmgr_init_vbuf(vbuf_ref);
-	ia_css_i_host_rmgr_init_vbuf(vbuf_write);
-	ia_css_i_host_rmgr_init_vbuf(hmm_buffer_pool);
-}
-
-void ia_css_i_host_rmgr_uninit(void)
-{
-	ia_css_i_host_rmgr_uninit_vbuf(hmm_buffer_pool);
-	ia_css_i_host_rmgr_uninit_vbuf(vbuf_write);
-	ia_css_i_host_rmgr_uninit_vbuf(vbuf_ref);
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c
deleted file mode 100644
index 0e01039..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.c
+++ /dev/null
@@ -1,288 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "ia_css_i_rmgr.h"
-
-#include <stdbool.h>
-#include <assert_support.h>
-
-#include "memory_access.h"
-
-#include "sh_css_debug.h"
-
-#define NUM_HANDLES 1000
-struct ia_css_i_host_rmgr_vbuf_handle handle_table[NUM_HANDLES];
-
-struct ia_css_i_host_rmgr_vbuf_pool refpool = {
-	.copy_on_write = false,
-	.recycle = false,
-};
-struct ia_css_i_host_rmgr_vbuf_pool writepool = {
-	.copy_on_write = true,
-	.recycle = false,
-	.size = 0,
-};
-struct ia_css_i_host_rmgr_vbuf_pool hmmbufferpool = {
-	.copy_on_write = true,
-	.recycle = true,
-	.size = 20,
-};
-
-struct ia_css_i_host_rmgr_vbuf_pool *vbuf_ref = &refpool;
-struct ia_css_i_host_rmgr_vbuf_pool *vbuf_write = &writepool;
-struct ia_css_i_host_rmgr_vbuf_pool *hmm_buffer_pool = &hmmbufferpool;
-
-
-
-static void ia_css_i_host_refcount_init_vbuf(void)
-{
-	/* initialize the refcount table */
-	memset(&handle_table, 0, sizeof(handle_table));
-}
-
-void ia_css_i_host_refcount_retain_vbuf(
-		struct ia_css_i_host_rmgr_vbuf_handle **handle)
-{
-	int i;
-	struct ia_css_i_host_rmgr_vbuf_handle *h;
-	assert(handle != NULL);
-	if(handle == NULL)
-		return;
-	assert(*handle != NULL);
-	if(*handle == NULL)
-		return;
-	/* new vbuf to count on */
-	if ((*handle)->count == 0) {
-		h = *handle;
-		*handle = NULL;
-		for (i = 0; i < NUM_HANDLES; i++) {
-			if (handle_table[i].count == 0) {
-				*handle = &handle_table[i];
-				break;
-			}
-		}
-		assert(*handle != NULL);
-		/* Klockwork pacifier */
-		if(*handle == NULL)
-			return;
-		(*handle)->vptr = h->vptr;
-		(*handle)->size = h->size;
-	}
-	(*handle)->count++;
-}
-
-
-void ia_css_i_host_refcount_release_vbuf(
-		struct ia_css_i_host_rmgr_vbuf_handle **handle)
-{
-	assert(handle != NULL);
-	if(handle == NULL)
-		return;
-	assert(*handle != NULL);
-	if(*handle == NULL)
-		return;
-	assert((*handle)->count != 0);
-	/* decrease reference count */
-	(*handle)->count--;
-	/* remove from admin */
-	if ((*handle)->count == 0) {
-		(*handle)->vptr = 0x0;
-		(*handle)->size = 0;
-		*handle = NULL;
-	}
-}
-
-void ia_css_i_host_rmgr_init_vbuf(struct ia_css_i_host_rmgr_vbuf_pool *pool)
-{
-	size_t bytes_needed;
-	ia_css_i_host_refcount_init_vbuf();
-	assert(pool != NULL);
-	if (pool == NULL)
-		return;
-	/* initialize the recycle pool if used */
-	if (pool->recycle && pool->size) {
-		/* allocate memory for storing the handles */
-		bytes_needed =
-			sizeof(struct ia_css_i_host_rmgr_vbuf_handle *) *
-			pool->size;
-		pool->handles = sh_css_malloc(bytes_needed);
-		assert(pool->handles != NULL);
-		if (pool->handles == NULL) {
-			pool->size = 0;
-			return;
-		}
-		memset(pool->handles, 0, bytes_needed);
-	}
-	else {
-		/* just in case, set the size to 0 */
-		pool->size = 0;
-		pool->handles = NULL;
-	}
-}
-
-void ia_css_i_host_rmgr_uninit_vbuf(struct ia_css_i_host_rmgr_vbuf_pool *pool)
-{
-	uint32_t i;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"ia_css_i_host_rmgr_uninit_vbuf()\n");
-	assert(pool != NULL);
-	if(pool == NULL)
-		return;
-	if (pool->handles != NULL) {
-		/* free the hmm buffers */
-		for (i = 0; i < pool->size; i++) {
-			if (pool->handles[i] != NULL) {
-				sh_css_dtrace(SH_DBG_TRACE,
-					"   freeing/releasing %x (count=%d)\n",
-					pool->handles[i]->vptr,
-					pool->handles[i]->count);
-				/* free memory */
-				mmgr_free(pool->handles[i]->vptr);
-				/* remove from refcount admin*/
-				ia_css_i_host_refcount_release_vbuf(
-						&pool->handles[i]);
-			}
-		}
-		/* now free the pool handles list */
-		sh_css_free(pool->handles);
-		pool->handles = NULL;
-	}
-}
-
-static
-void ia_css_i_host_rmgr_push_handle(
-	struct ia_css_i_host_rmgr_vbuf_pool *pool,
-	struct ia_css_i_host_rmgr_vbuf_handle **handle)
-{
-	uint32_t i;
-	bool succes = false;
-	assert(pool != NULL);
-	if(pool == NULL)
-		return;
-	assert(pool->recycle);
-	assert(pool->handles != NULL);
-	if(pool->handles == NULL)
-		return;
-	assert(handle != NULL);
-	if(handle == NULL)
-		return;
-	for (i = 0; i < pool->size; i++) {
-		if (pool->handles[i] == NULL) {
-			ia_css_i_host_refcount_retain_vbuf(handle);
-			pool->handles[i] = *handle;
-			succes = true;
-			break;
-		}
-	}
-	assert(succes);
-}
-
-static
-void ia_css_i_host_rmgr_pop_handle(
-	struct ia_css_i_host_rmgr_vbuf_pool *pool,
-	struct ia_css_i_host_rmgr_vbuf_handle **handle)
-{
-	uint32_t i;
-	bool succes = false;
-	assert(pool != NULL);
-	if(pool == NULL)
-		return;
-	assert(pool->recycle);
-	assert(pool->handles != NULL);
-	if(pool->handles == NULL)
-		return;
-	assert(handle != NULL);
-	if(handle == NULL)
-		return;
-	for (i = 0; i < pool->size; i++) {
-		if (pool->handles[i] != NULL && pool->handles[i]->size == (*handle)->size) {
-			*handle = pool->handles[i];
-			pool->handles[i] = NULL;
-			/* dont release, we are returning it...
-			   ia_css_i_host_refcount_release_vbuf(handle); */
-			succes = true;
-			break;
-		}
-	}
-}
-
-void ia_css_i_host_rmgr_acq_vbuf(
-	struct ia_css_i_host_rmgr_vbuf_pool *pool,
-	struct ia_css_i_host_rmgr_vbuf_handle **handle)
-{
-	struct ia_css_i_host_rmgr_vbuf_handle h;
-	assert(pool != NULL);
-	if(pool == NULL)
-		return;
-	assert(handle != NULL);
-	if(handle == NULL)
-		return;
-	if (pool->copy_on_write) {
-		/* only one reference, reuse (no new retain) */
-		if ((*handle)->count == 1)
-			return;
-		/* more than one reference, release current buffer */
-		if ((*handle)->count > 1) {
-			/* store current values */
-			h.vptr = 0x0;
-			h.size = (*handle)->size;
-			/* release ref to current buffer */
-			ia_css_i_host_refcount_release_vbuf(handle);
-			*handle = &h;
-		}
-		/* get new buffer for needed size */
-		if ((*handle)->vptr == 0x0) {
-			if (pool->recycle) {
-				/* try and pop from pool */
-				ia_css_i_host_rmgr_pop_handle(pool, handle);
-				if ((*handle)->vptr != 0x0) {
-					/* we popped a buffer */
-					return;
-				}
-			}
-			/* we need to allocate */
-			(*handle)->vptr = mmgr_alloc_attr((*handle)->size, 0);
-		}
-	}
-	/* Note that handle will change to an internally maintained one */
-	ia_css_i_host_refcount_retain_vbuf(handle);
-}
-
-void ia_css_i_host_rmgr_rel_vbuf(
-	struct ia_css_i_host_rmgr_vbuf_pool *pool,
-	struct ia_css_i_host_rmgr_vbuf_handle **handle)
-{
-	assert(pool != NULL);
-	if(pool == NULL)
-		return;
-	assert(handle != NULL);
-	if(handle == NULL)
-		return;
-	assert(*handle != NULL);
-	if(*handle == NULL)
-		return;
-	/* release the handle */
-	if ((*handle)->count == 1) {
-		if (!pool->recycle) {
-			/* non recycling pool, free mem */
-			mmgr_free((*handle)->vptr);
-		}
-		else {
-			/* recycle to pool */
-			ia_css_i_host_rmgr_push_handle(pool, handle);
-		}
-	}
-	ia_css_i_host_refcount_release_vbuf(handle);
-	*handle = NULL;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h
deleted file mode 100644
index 912b467..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/ia_css_i_rmgr_vbuf_shared.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IA_CSS_I_RMGR_VBUF_HOST_SHARED_H_INCLUDED__
-#define __IA_CSS_I_RMGR_VBUF_HOST_SHARED_H_INCLUDED__
-
-#include "ia_css_i_rmgr_vbuf_public.h"
-
-#include <stdint.h>
-
-#include "sh_css_internal.h"
-
-/* complete the types for the sp implementation of the dma resource pool */
-
-struct ia_css_i_host_rmgr_vbuf_handle {
-	hrt_vaddress vptr;
-	uint8_t count;
-	uint32_t size;
-};
-
-struct ia_css_i_host_rmgr_vbuf_pool {
-	uint8_t copy_on_write;
-	uint8_t recycle;
-	uint32_t size;
-	uint32_t index;
-	struct ia_css_i_host_rmgr_vbuf_handle **handles;
-};
-
-extern struct ia_css_i_host_rmgr_vbuf_pool *vbuf_ref;
-extern struct ia_css_i_host_rmgr_vbuf_pool *vbuf_write;
-extern struct ia_css_i_host_rmgr_vbuf_pool *hmm_buffer_pool;
-
-#endif /* __IA_CSS_I_RMGR_VBUF_HOST_SHARED_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue.c
deleted file mode 100644
index 03ac341..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue.c
+++ /dev/null
@@ -1,677 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include "queue.h"
-
-#include "sp.h"
-
-#include <stdbool.h>	/* bool				*/
-
-/* MW: The queue should be application agnostic */
-#include "sh_css_internal.h"
-/* sh_css_frame_id,  struct sh_css_circular_buf		*/
-
-/* MW: The queue should not depend on principal interface types */
-#include "sh_css_types.h"		/* sh_css_fw_info		*/
-
-#include "assert_support.h"
-
-#ifndef offsetof
-#define offsetof(T, x) ((unsigned)&(((T *)0)->x))
-#endif
-
-/*
- * MW: The interface to get events is in "event.h"
- * presently that is wired to the HOST2SP (HW) FIFO
- * In the case that events are signaled by interrupt
- * and retrieved from SP, then the access mechanism
- * to that queue must be here as it is addressed by
- * SP_ID. The functions interpreting and acting on
- * the event are not part of the SP device interface
- */
-
-/*
- * Local declarations.
- *
- * NOTE: Linux checkpatch cannot handle the storage class
- * macro "STORAGE_CLASS_INLINE" that is used to hide
- * compiler specific "inline" specifiers. To maintain
- * portability do not force inline.
- */
-
-/************************************************************
- *
- * Generic queues.
- *
- ************************************************************/
-/*! The Host initialize the target "host2sp" queue.
-
- @param	offset[in]	The target queue's offset that is
-			relative to the base address of the struct
-			"host_sp_communication"
- */
-/*STORAGE_CLASS_INLINE void init_sp_queue(*/
-static void init_sp_queue(
-	struct sh_css_circular_buf *offset);
-
-/*! Push an element to the queue.
-
- @param	offset[in]	The target queue's offset that is
-			relative to the base address of the struct
-			"host_sp_communication".
- @param elem[in]	the element to be enqueued.
- */
-/*STORAGE_CLASS_INLINE bool push_sp_queue(*/
-static void push_sp_queue(
-	struct sh_css_circular_buf *offset,
-	unsigned int elem);
-
-/*! Pop an element from the queue.
-
- @param	offset[in]	The target queue's offset that is
-			relative to the base address of the struct
-			"host_sp_communication".
- @param elem[in]	the element to be dequeued.
- */
-/*STORAGE_CLASS_INLINE bool pop_sp_queue(*/
-static void pop_sp_queue(
-	struct sh_css_circular_buf *offset,
-	unsigned int *elem);
-
-
-/*! Check whether the "host2sp" queue is full or not.
-
- @param	offset[in]	The target queue's offset that is
-			relative to the base address of the struct
-			"host_sp_communication".
-
- \return true if the queue is full
- */
-/*STORAGE_CLASS_INLINE bool is_sp_queue_full(*/
-static bool is_sp_queue_full(
-	struct sh_css_circular_buf *offset);
-
-/*! Check whether the "host2sp" queue is empty or not.
-
- \param	offset[in]	The target queue's offset that is
-			relative to the base address of the struct
-			"host_sp_queuemunication".
-
- \return true if the queue is empty
- */
-/*STORAGE_CLASS_INLINE bool is_sp_queue_empty(*/
-static bool is_sp_queue_empty(
-	struct sh_css_circular_buf *offset);
-
-/*
- * The compiler complains that "warning: dump_sp_queue defined
- * but not used", which treats warnings as errors. So dump_sp_queue
- * is disabled. Enable it as soon as it is used.
- */
-#if 0
-/*! The Host prints the contents within the target "host2sp" queue.
-
- \param	offset[in]	The target queue's offset that is
-			relative to the base address of the struct
-			"host_sp_queuemunication"
- */
-/*STORAGE_CLASS_INLINE void dump_sp_queue(*/
-static void dump_sp_queue(
-	struct sh_css_circular_buf *offset);
-#endif
-/* end of local declarations */
-
-#ifndef __INLINE_QUEUE__
-#include "queue_private.h"
-#endif /* __INLINE_QUEUE__ */
-
-/************************************************************
- *
- * Application-specific queues.
- *
- ************************************************************/
-void init_host2sp_queues(void)
-{
-	unsigned int i, j;
-	struct sh_css_circular_buf *offset_to_queue;
-
-	for (i = 0; i < SH_CSS_MAX_SP_THREADS; i++) {
-		for (j = 0; j < SH_CSS_NUM_BUFFER_QUEUES; j++) {
-			offset_to_queue = (struct sh_css_circular_buf *)
-				offsetof(struct host_sp_queues,
-					host2sp_buffer_queues[i][j]);
-			init_sp_queue(offset_to_queue);
-		}
-	}
-	offset_to_queue = (struct sh_css_circular_buf *)
-		offsetof(struct host_sp_queues,
-			host2sp_event_queue);
-	init_sp_queue(offset_to_queue);
-}
-
-void init_sp2host_queues(void)
-{
-	unsigned int j;
-//	struct host_sp_queues *my_queues = NULL;
-	struct sh_css_circular_buf *offset_to_queue;
-
-	for (j = 0; j < SH_CSS_NUM_BUFFER_QUEUES; j++) {
-		offset_to_queue = (struct sh_css_circular_buf *)
-			offsetof(struct host_sp_queues,
-				sp2host_buffer_queues[j]);
-		init_sp_queue(offset_to_queue);
-		//init_sp_queue(&my_queues->sp2host_buffer_queues[j]);
-	}
-	offset_to_queue = (struct sh_css_circular_buf *)
-		offsetof(struct host_sp_queues,
-			sp2host_event_queue);
-	init_sp_queue(offset_to_queue);
-//	init_sp_queue(&my_queues->sp2host_event_queue);
-}
-
-/************************************************************
- *
- * Buffer queues (direction: the host -> the SP).
- *
- ************************************************************/
-bool host2sp_enqueue_buffer(
-	unsigned int pipe_num,
-	unsigned int stage_num,
-	enum sh_css_buffer_queue_id index,
-	uint32_t buffer_ptr)
-{
-	bool is_full;
-//	struct host_sp_queues *my_queues = NULL;
-	struct sh_css_circular_buf *offset_to_queue;
-
-	(void)stage_num;
-
-assert(pipe_num < SH_CSS_MAX_SP_THREADS);
-assert((index < SH_CSS_NUM_BUFFER_QUEUES));
-assert((index >= 0));
-
-	/* Klockwork pacifier */
-	if (pipe_num >= SH_CSS_MAX_SP_THREADS)
-		return false;
-
-	/* Klockwork pacifier */
-	if ((index >= SH_CSS_NUM_BUFFER_QUEUES) || (index < 0))
-		return false;
-
-	/* This is just the first step of introducing the queue API */
-	/* The implementation is still the old non-queue implementation */
-	/* till the new queue implementation is there */
-	offset_to_queue = (struct sh_css_circular_buf *)
-		offsetof(struct host_sp_queues,
-			host2sp_buffer_queues[pipe_num][index]);
-
-	/* check whether both queues are full or not */
-	is_full = is_sp_queue_full(offset_to_queue);
-
-	if (!is_full) {
-		/* push elements into the queues */
-		push_sp_queue(offset_to_queue, (uint32_t)buffer_ptr);
-	}
-
-
-	return !is_full;
-}
-
-/************************************************************
- *
- * Event queues (the host -> the SP).
- *
- ************************************************************/
-bool host2sp_enqueue_sp_event(
-		uint32_t event)
-{
-	bool is_full;
-	//struct host_sp_queues *my_queues = NULL;
-	struct sh_css_circular_buf *offset_to_queue;
-	offset_to_queue = (struct sh_css_circular_buf *)
-		offsetof(struct host_sp_queues,
-			host2sp_event_queue);
-
-	/* check whether the queue is full or not */
-	is_full = is_sp_queue_full(offset_to_queue);
-
-	if (!is_full) {
-		/* push elements into the queues */
-		push_sp_queue(offset_to_queue, event);
-	}
-
-	return !is_full;
-}
-
-/************************************************************
- *
- * Buffer queues (the SP -> the host).
- *
- ************************************************************/
-bool sp2host_dequeue_buffer(
-	unsigned int pipe_num,
-	unsigned int stage_num,
-	enum sh_css_buffer_queue_id index,
-	uint32_t *buffer_ptr)
-{
-	uint32_t elem;
-	bool is_empty;
-	//struct host_sp_queues *my_queues = NULL;
-	struct sh_css_circular_buf *offset_to_queue;
-	(void)stage_num;
-
-assert(pipe_num < SH_CSS_MAX_SP_THREADS);
-assert((index < SH_CSS_NUM_BUFFER_QUEUES));
-assert((index >= 0));
-
-	/* Klockwork pacifier */
-	if (pipe_num >= SH_CSS_MAX_SP_THREADS)
-		return false;
-
-	/* Klockwork pacifier */
-	if ((index >= SH_CSS_NUM_BUFFER_QUEUES) || (index < 0))
-		return false;
-
-	offset_to_queue = (struct sh_css_circular_buf *)
-		offsetof(struct host_sp_queues, sp2host_buffer_queues[index]);
-
-
-	/* This is just the first step of introducing the queue API */
-	/* The implementation is still the old non-queue implementation */
-	/* till the new queue implementation is there */
-
-	/* check whether the queue is empty or not */
-	is_empty = is_sp_queue_empty(offset_to_queue);
-
-	/* pop when both queue is not empty */
-	if (!is_empty) {
-		/* pop element from the queue */
-		pop_sp_queue(offset_to_queue, &elem);
-
-		/* set the frame data */
-		*buffer_ptr = elem;
-	}
-
-	return !is_empty;
-}
-
-/************************************************************
- *
- * Event queues (the SP -> the host).
- *
- ************************************************************/
-bool sp2host_dequeue_irq_event(
-	uint32_t *event)
-{
-	unsigned int elem;
-	bool is_empty;
-	//struct host_sp_queues *my_queues = NULL;
-	struct sh_css_circular_buf *offset_to_queue;
-	offset_to_queue = (struct sh_css_circular_buf *)
-		offsetof(struct host_sp_queues,
-			sp2host_event_queue);
-
-	/* check whether the queue is empty or not */
-	is_empty = is_sp_queue_empty(offset_to_queue);
-
-	/* pop when both queue is not empty */
-	if (!is_empty) {
-		/* pop element from the queue */
-		pop_sp_queue(offset_to_queue, &elem);
-
-		/* fill in the IRQ event */
-		*event = elem;
-	}
-
-	return !is_empty;
-}
-
-static void store_sp_queue(
-	struct sh_css_circular_buf *offset,
-	unsigned int *size,
-	unsigned int *step,
-	unsigned int *start,
-	unsigned int *end)
-{
-#ifndef C_RUN
-	unsigned int HIVE_ADDR_host_sp_queue;
-	const struct sh_css_fw_info *fw;
-#endif
-	unsigned int entry_to_cb_size  = (unsigned)&offset->size;
-	unsigned int entry_to_cb_step  = (unsigned)&offset->step;
-	unsigned int entry_to_cb_start = (unsigned)&offset->start;
-	unsigned int entry_to_cb_end   = (unsigned)&offset->end;
-
-#ifndef C_RUN
-	/* get the variable address from the firmware */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-	/* update the contents at the entries */
-	if (size)
-		store_sp_array_uint8(host_sp_queue,
-			entry_to_cb_size / sizeof(offset->size),
-			*size);
-
-	if (step)
-		store_sp_array_uint8(host_sp_queue,
-			entry_to_cb_step / sizeof(offset->step),
-			*step);
-
-	if (start)
-		store_sp_array_uint8(host_sp_queue,
-			entry_to_cb_start / sizeof(offset->start),
-			*start);
-
-	if (end)
-		store_sp_array_uint8(host_sp_queue,
-			entry_to_cb_end / sizeof(offset->end),
-			*end);
-}
-
-static void load_sp_queue(
-	struct sh_css_circular_buf *offset,
-	unsigned int *size,
-	unsigned int *step,
-	unsigned int *start,
-	unsigned int *end)
-{
-#ifndef C_RUN
-	unsigned int HIVE_ADDR_host_sp_queue;
-	const struct sh_css_fw_info *fw;
-#endif
-	unsigned int entry_to_cb_size  = (unsigned)&offset->size;
-	unsigned int entry_to_cb_step  = (unsigned)&offset->step;
-	unsigned int entry_to_cb_start = (unsigned)&offset->start;
-	unsigned int entry_to_cb_end   = (unsigned)&offset->end;
-
-#ifndef C_RUN
-	/* get the variable address from the firmware */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-	/* update the contents at the entries */
-	if (size)  *size  = load_sp_array_uint8(host_sp_queue,
-			entry_to_cb_size / sizeof(offset->size));
-
-	if (step)  *step  = load_sp_array_uint8(host_sp_queue,
-			entry_to_cb_step / sizeof(offset->step));
-
-	if (start) *start = load_sp_array_uint8(host_sp_queue,
-			entry_to_cb_start / sizeof(offset->start));
-
-	if (end)   *end   = load_sp_array_uint8(host_sp_queue,
-			entry_to_cb_end / sizeof(offset->end));
-}
-
-/************************************************************
- *
- * Generic queues.
- *
- ************************************************************/
-/*STORAGE_CLASS_INLINE void init_sp_queue(*/
-static void init_sp_queue(
-	struct sh_css_circular_buf *offset)
-{
-	unsigned int size  = SH_CSS_CIRCULAR_BUF_NUM_ELEMS;
-	unsigned int step  = sizeof(offset->elems[0]);
-	unsigned int start = 0;
-	unsigned int end   = 0;
-	store_sp_queue (offset, &size, &step, &start, &end);
-}
-
-/*STORAGE_CLASS_INLINE void push_sp_queue(*/
-static void push_sp_queue(
-	struct sh_css_circular_buf *offset,
-	unsigned int elem)
-{
-#ifndef C_RUN
-	unsigned int HIVE_ADDR_host_sp_queue;
-	const struct sh_css_fw_info *fw;
-#endif
-
-	unsigned int cb_size;
-	unsigned int cb_start;
-	unsigned int cb_end;
-	unsigned int entry_to_cb_elem;
-	uint32_t cb_elem;
-
-#ifndef C_RUN
-	/* get the variable address from the firmware */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-	/* set a local copy of the circular buffer */
-	load_sp_queue (offset, &cb_size, NULL, &cb_start, &cb_end);
-
-	entry_to_cb_elem = (unsigned)&offset->elems[cb_end];
-
-	/* enqueue the element */
-	cb_elem = (uint32_t)elem;
-	store_sp_array_uint(host_sp_queue,
-			entry_to_cb_elem / sizeof(uint32_t),
-			cb_elem);
-
-	/* update the "end" index */
-	cb_end = (cb_end + 1) % cb_size;
-	store_sp_queue (offset, NULL, NULL, NULL, &cb_end);
-}
-
-/*STORAGE_CLASS_INLINE void pop_sp_queue(*/
-static void pop_sp_queue(
-	struct sh_css_circular_buf *offset,
-	unsigned int *elem)
-{
-#ifndef C_RUN
-	unsigned int HIVE_ADDR_host_sp_queue;
-	const struct sh_css_fw_info *fw;
-#endif
-
-	unsigned int cb_size;
-	unsigned int cb_start;
-	unsigned int cb_end;
-
-	unsigned int entry_to_cb_elem;
-	uint32_t cb_elem;
-
-#ifndef C_RUN
-	/* get the variable address from the firmware */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-	load_sp_queue(offset, &cb_size, NULL, &cb_start, &cb_end);
-
-	/* read from the non-empty queue */
-	entry_to_cb_elem = (unsigned)&offset->elems[cb_start];
-
-	/* dequeue the buffer */
-	cb_elem = load_sp_array_uint(host_sp_queue,
-			entry_to_cb_elem / sizeof(uint32_t));
-	*elem = (unsigned int)cb_elem;
-
-	/* update the "start" index */
-	cb_start = (cb_start + 1) % cb_size;
-	store_sp_queue(offset, NULL, NULL, &cb_start, NULL);
-}
-
-#if 1
-/*STORAGE_CLASS_INLINE bool is_sp_queue_full(*/
-static bool is_sp_queue_full(
-	struct sh_css_circular_buf *offset)
-{
-#ifndef C_RUN
-	unsigned int HIVE_ADDR_host_sp_queue;
-	const struct sh_css_fw_info *fw;
-#endif
-
-	unsigned int cb_size;
-	unsigned int cb_start;
-	unsigned int cb_end;
-
-	bool is_full;
-
-#ifndef C_RUN
-	/* get the variable address from the firmware */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-	load_sp_queue (offset, &cb_size, NULL, &cb_start, &cb_end);
-
-	/* check whether the queue is full or not */
-	is_full = (cb_size == 0) ? true : ((cb_end + 1) % cb_size == cb_start);
-
-	return is_full;
-}
-
-#else
-
-/*STORAGE_CLASS_INLINE bool is_sp_queue_full(*/
-static bool is_sp_queue_full(
-        unsigned int base)
-{
-#ifndef C_RUN
-        unsigned int HIVE_ADDR_host_sp_queue;
-        const struct sh_css_fw_info *fw;
-#endif
-
-        unsigned int offset;
-
-        unsigned int entry_to_cb_fsm;
-
-        uint32_t cb_fsm;
-
-        bool is_full;
-
-#ifndef C_RUN
-        /* get the variable address from the firmware */
-        fw = &sh_css_sp_fw;
-        HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-        /* get the offsets (in words) */
-        offset = offsetof(struct sh_css_circular_buf, fsm)
-                / sizeof(int);
-
-        /* get the entries (in words) */
-        entry_to_cb_fsm = base + offset;
-
-        /* get a local copy of the circular buffer */
-        cb_fsm   = load_sp_array_uint(host_sp_queue, entry_to_cb_fsm);
-
-        /* check whether the queue is full or not */
-        is_full  = (SP_QUEUE_FSM_GET_CURR_STATE(cb_fsm) == SP_QUEUE_STATE_FULL);
-
-        return is_full;
-}
-#endif
-
-/*STORAGE_CLASS_INLINE bool is_sp_queue_empty(*/
-static bool is_sp_queue_empty(
-	struct sh_css_circular_buf *offset)
-{
-#ifndef C_RUN
-	unsigned int HIVE_ADDR_host_sp_queue;
-	const struct sh_css_fw_info *fw;
-#endif
-
-	unsigned int cb_size;
-	unsigned int cb_start;
-	unsigned int cb_end;
-
-	bool is_empty;
-
-#ifndef C_RUN
-	/* get the variable address from the firmware */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-	load_sp_queue (offset, &cb_size, NULL, &cb_start, &cb_end);
-
-	/* check whether the queue is full or not */
-	is_empty = (cb_size == 0) ? true: (cb_start == cb_end);
-
-	return is_empty;
-}
-
-/*
- * The compiler complains that "warning: dump_sp_queue defined
- * but not used", which treats warnings as errors. So dump_sp_queue
- * is disabled. Enable it as soon as it is used.
- */
-#if 0
-/*STORAGE_CLASS_INLINE void dump_sp_queue(*/
-static void dump_sp_queue(
-	struct sh_ccs_circular_buf *offset)
-{
-#ifndef C_RUN
-	unsigned int HIVE_ADDR_host_sp_queue;
-	const struct sh_css_fw_info *fw;
-#endif
-
-	unsigned int offset_4;
-
-	unsigned int entry_to_cb_elems[SH_CSS_CIRCULAR_BUF_NUM_ELEMS];
-
-	unsigned int cb_size;
-	unsigned int cb_step;
-	unsigned int cb_start;
-	unsigned int cb_end;
-	uint32_t cb_elems[SH_CSS_CIRCULAR_BUF_NUM_ELEMS];
-
-	unsigned int i;
-
-#ifndef C_RUN
-	/* get the variable address from the firmware */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queue = fw->info.sp.host_sp_queue;
-#endif
-
-	/* get the offsets (in words) */
-	offset_4 = offsetof(struct sh_css_circular_buf, elems)
-		/ sizeof(int);
-
-	/* get the entries (in words) */
-	for (i = 0; i < SH_CSS_CIRCULAR_BUF_NUM_ELEMS; i++) {
-		entry_to_cb_elems[i] = base + offset_4;
-		entry_to_cb_elems[i] +=	i;
-	}
-
-	/* update the contents at the entries */
-	load_sp_queue (offset, &cb_size, &cb_step, &cb_start, &cb_end);
-
-	for (i = 0 ; i < SH_CSS_CIRCULAR_BUF_NUM_ELEMS; i++) {
-		cb_elems[i] = load_sp_array_uint(host_sp_queue,
-						entry_to_cb_elems[i]);
-	}
-
-#ifdef C_RUN
-	printf("base     = %d\n", base);
-	printf("cb_size  = %d\n", cb_size);
-	printf("cb_step  = %d (bytes)\n", cb_step);
-	printf("cb_start = %d\n", cb_start);
-	printf("cb_end   = %d\n", cb_end);
-	for (i = 0 ; i < SH_CSS_CIRCULAR_BUF_NUM_ELEMS; i++)
-		printf("cb_elems[%d] = %d\n", i, cb_elems[i]);
-
-	printf("\n");
-#endif
-}
-#endif
-/* end of local definitions */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_local.h
deleted file mode 100644
index 94d89f0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_local.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __QUEUE_LOCAL_H_INCLUDED__
-#define __QUEUE_LOCAL_H_INCLUDED__
-
-#include "queue_global.h"
-
-#endif /* __QUEUE_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_private.h
deleted file mode 100644
index 1469278..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/queue_private.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __QUEUE_PRIVATE_H_INCLUDED__
-#define __QUEUE_PRIVATE_H_INCLUDED__
-
-#endif /* __QUEUE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event.c
deleted file mode 100644
index 2fd062b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-/****************************************************************
- *
- * Time: 2012-09-12, 14:23.
- * Author: zhengjie.lu@intel.com
- * Comment:
- * - Extend the bit number per information. In the previous
- *   version, the bit number per information can be 32, 16,
- *   or 8. In this version, it is determined by the formula
- *   "32-bit / number of information".
- *
- * Time   : 2012-09-06, 11:16.
- * Author : zhengjie.lu@intel.com
- * Comment:
- * - Initial version.
- *
- ****************************************************************/
-
-#include "sw_event.h"
-
-#include <stdbool.h>		/* bool */
-#include <stddef.h>		/* NULL */
-
-#include "assert_support.h"	/* OP___assert() */
-
-/****************************************
- *
- * Local declarations.
- *
- ****************************************/
-/* end of local declarations */
-
-#ifndef __INLINE_SW_EVENT__
-#include "sw_event_private.h"
-#endif /* __INLINE_SW_EVENT__ */
-
-/**
- * @brief Encode the information into the software-event.
- * Refer to "sw_event_public.h" for details.
- */
-STORAGE_CLASS_SW_EVENT_C bool
-encode_sw_event(
-	uint32_t	*in,
-	uint32_t	nr,
-	uint32_t	*out)
-{
-	bool ret;
-	uint32_t nr_of_bits;
-	uint32_t i;
-
-OP___assert (nr > 0 && nr <= MAX_NR_OF_PAYLOADS_PER_SW_EVENT);
-
-	/* initialize the output */
-	*out = 0;
-	
-	/* get the number of bits per information */
-	nr_of_bits = sizeof(uint32_t) * 8 / nr;
-
-	/* compress the all inputs into a signle output */
-	for (i = 0; i < nr; i++) {
-		*out <<= nr_of_bits;
-		*out |= in[i];
-	}
-
-	/* get the return value */
-	ret = (nr > 0 && nr <= MAX_NR_OF_PAYLOADS_PER_SW_EVENT);
-
-	return ret;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_local.h
deleted file mode 100644
index dc19e62..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_local.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-/****************************************************************
- *
- * Time   : 2012-09-06, 11:16.
- * Author : zhengjie.lu@intel.com
- * Comment:
- * - Initial version.
- *
- ****************************************************************/
-
-#ifndef __SW_EVENT_LOCAL_H_INCLUDED__
-#define __SW_EVENT_LOCAL_H_INCLUDED__
-
-#include "sw_event_global.h"
-
-#endif /* __SW_EVENT_LOCAL_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_private.h
deleted file mode 100644
index 0b87516..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/sw_event_private.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-/****************************************************************
- *
- * Time   : 2012-09-06, 11:16.
- * Author : zhengjie.lu@intel.com
- * Comment:
- * - Initial version.
- *
- ****************************************************************/
-
-#ifndef __SW_EVENT_PRIVATE_H_INCLUDED__
-#define __SW_EVENT_PRIVATE_H_INCLUDED__
-
-#endif /* __SW_EVENT_PRIVATE_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag.c
deleted file mode 100644
index c0e1246..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "tag.h"
-
-#ifndef __INLINE_QUEUE__
-#include "queue_private.h"
-#endif /* __INLINE_QUEUE__ */
-
-/**
- * @brief	Creates the tag description from the given parameters.
- * @param[in]	num_captures
- * @param[in]	skip
- * @param[in]	offset
- * @param[out]	tag_descr
- */
-void
-sh_css_create_tag_descr(int num_captures,
-			unsigned int skip,
-			int offset,
-			unsigned int exp_id,
-			struct sh_css_tag_descr *tag_descr)
-{
-	tag_descr->num_captures = num_captures;
-	tag_descr->skip		= skip;
-	tag_descr->offset	= offset;
-	tag_descr->exp_id	= exp_id;
-	tag_descr->num_captures_sign = (num_captures < 0) ? 1 : 0;
-	tag_descr->offset_sign = (offset < 0) ? 1 : 0;
-}
-
-/**
- * @brief	Encodes the members of tag description into a 32-bit value.
- * @param[in]	tag		Pointer to the tag description
- * @return	(unsigned int)	Encoded 32-bit tag-info
- */
-unsigned int
-sh_css_encode_tag_descr(struct sh_css_tag_descr *tag)
-{
-	int num_captures = (tag->num_captures < 0) ? (-tag->num_captures) : (tag->num_captures);
-	unsigned int skip = tag->skip;
-	int offset = (tag->offset < 0) ? (-tag->offset) : (tag->offset);
-	unsigned int exp_id = tag->exp_id;
-	unsigned int num_captures_sign = tag->num_captures_sign;
-	unsigned int offset_sign = tag->offset_sign;
-
-	unsigned int encoded_tag = (num_captures_sign & 0x00000001)
-				|  (offset_sign  & 0x00000001) << 1
-				|  (num_captures & 0x000000FF) << 4
-				|  (exp_id       & 0x0000000F) << 12
-				|  (skip         & 0x000000FF) << 16
-				|  (offset       & 0x000000FF) << 24;
-
-	return encoded_tag;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_local.h
deleted file mode 100644
index ce810cd..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_local.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TAG_LOCAL_H_INCLUDED__
-#define __TAG_LOCAL_H_INCLUDED__
-
-#include "tag_global.h"
-
-#define SH_CSS_MINIMUM_TAG_ID (-1)
-
-#endif /* __TAG_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_private.h
deleted file mode 100644
index 3c1810a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/host/tag_private.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TAG_PRIVATE_H_INCLUDED__
-#define __TAG_PRIVATE_H_INCLUDED__
-
-#endif /* __TAG_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/queue_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/queue_global.h
deleted file mode 100644
index 9350545..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/queue_global.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __QUEUE_GLOBAL_H_INCLUDED__
-#define __QUEUE_GLOBAL_H_INCLUDED__
-
-#endif /* __QUEUE_GLOBAL_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/socket_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/socket_global.h
deleted file mode 100644
index 7439b20..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/socket_global.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SOCKET_GLOBAL_H_INCLUDED__
-#define __SOCKET_GLOBAL_H_INCLUDED__
-
-#include "stream_buffer.h"
-
-/* define the socket port direction */
-typedef enum {
-	SOCKET_PORT_DIRECTION_NULL,
-	SOCKET_PORT_DIRECTION_IN,
-	SOCKET_PORT_DIRECTION_OUT
-} socket_port_direction_t;
-
-/* pointer to the port's callout function */
-typedef void (*socket_port_callout_fp)(void);
-typedef struct socket_port_s socket_port_t;
-typedef struct socket_s socket_t;
-
-/* data structure of the socket port */
-struct socket_port_s {
-	unsigned				channel;	/* the port entity */
-	socket_port_direction_t direction;	/* the port direction */
-	socket_port_callout_fp	callout;	/* the port callout function */
-
-	socket_t				*socket;	/* point to the socket */
-
-	struct {
-		unsigned data;
-	} buf;								/* the buffer at the port */
-};
-
-/* data structure of the socket */
-struct socket_s {
-	socket_port_t	*in;	/* the in-direction port */
-	socket_port_t	*out;	/* the out-direction port */
-	stream_buffer_t	buf;	/* the buffer between in-ports and out-ports */
-};
-
-#endif /* __SOCKET_PUBLIC_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/stream_buffer_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/stream_buffer_global.h
deleted file mode 100644
index 15986b8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/stream_buffer_global.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __STREAM_BUFFER_GLOBAL_H_INCLUDED__
-#define __STREAM_BUFFER_GLOBAL_H_INCLUDED__
-
-typedef struct stream_buffer_s stream_buffer_t;
-struct stream_buffer_s {
-	unsigned	base;
-	unsigned	limit;
-	unsigned	top;
-};
-
-#endif /* __STREAM_BUFFER_PUBLIC_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/sw_event_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/sw_event_global.h
deleted file mode 100644
index 14fab5b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/sw_event_global.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-/****************************************************************
- *
- * Time   : 2012-09-12, 19:22.
- * Author : zhengjie.lu@intel.com
- * Comment:
- * - Define the software event IDs.
- *
- * Time   : 2012-09-06, 11:16.
- * Author : zhengjie.lu@intel.com
- * Comment:
- * - Initial version.
- *
- ****************************************************************/
-
-#ifndef __SW_EVENT_GLOBAL_H_INCLUDED__
-#define __SW_EVENT_GLOBAL_H_INCLUDED__
-
-#define MAX_NR_OF_PAYLOADS_PER_SW_EVENT 4
-
-#define SP_SW_EVENT_ID_0	0	/* for the error		*/
-#define SP_SW_EVENT_ID_1	1	/* for the host2sp_buffer_queue */
-#define SP_SW_EVENT_ID_2	2	/* for the sp2host_buffer_queue */
-#define SP_SW_EVENT_ID_3	3	/* for the sp2host_event_queue  */
-
-#endif /* __SW_EVENT_GLOBAL_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/tag_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/tag_global.h
deleted file mode 100644
index bebd43b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_shared/tag_global.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TAG_GLOBAL_H_INCLUDED__
-#define __TAG_GLOBAL_H_INCLUDED__
-
-/* Data structure containing the tagging information which is used in
- * continuous mode to specify which frames should be captured.
- * num_captures		The number of RAW frames to be processed to
- *                      YUV. Setting this to -1 will make continuous
- *                      capture run until it is stopped.
- * skip			Skip N frames in between captures. This can be
- *                      used to select a slower capture frame rate than
- *                      the sensor output frame rate.
- * offset		Start the RAW-to-YUV processing at RAW buffer
- *                      with this offset. This allows the user to
- *                      process RAW frames that were captured in the
- *                      past or future.
- * exp_id		Exposure id of the RAW frame to tag.
- */
-struct sh_css_tag_descr {
-	int num_captures;
-	unsigned int num_captures_sign;
-	unsigned int skip;
-	int offset;
-	unsigned int offset_sign;
-	unsigned int exp_id;
-};
-
-#endif /* __TAG_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/debug_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/debug_global.h
deleted file mode 100644
index c161cfa..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/debug_global.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DEBUG_GLOBAL_H_INCLUDED__
-#define __DEBUG_GLOBAL_H_INCLUDED__
-
-#include "stdint.h"
-
-#define DEBUG_BUF_SIZE	1024
-#define DEBUG_BUF_MASK	(DEBUG_BUF_SIZE - 1)
-
-#define DEBUG_DATA_ENABLE_ADDR		0x00
-#define DEBUG_DATA_BUF_MODE_ADDR	0x04
-#define DEBUG_DATA_HEAD_ADDR		0x08
-#define DEBUG_DATA_TAIL_ADDR		0x0C
-#define DEBUG_DATA_BUF_ADDR			0x10
-
-#define DEBUG_DATA_ENABLE_DDR_ADDR		0x00
-#define DEBUG_DATA_BUF_MODE_DDR_ADDR	HIVE_ISP_DDR_WORD_BYTES
-#define DEBUG_DATA_HEAD_DDR_ADDR		(2 * HIVE_ISP_DDR_WORD_BYTES)
-#define DEBUG_DATA_TAIL_DDR_ADDR		(3 * HIVE_ISP_DDR_WORD_BYTES)
-#define DEBUG_DATA_BUF_DDR_ADDR			(4 * HIVE_ISP_DDR_WORD_BYTES)
-
-#define DEBUG_BUFFER_ISP_DMEM_ADDR       0x0
-
-/*
- * The linear buffer mode will accept data until the first
- * overflow and then stop accepting new data
- * The circular buffer mode will accept if there is place
- * and discard the data if the buffer is full
- */
-typedef enum {
-	DEBUG_BUFFER_MODE_LINEAR = 0,
-	DEBUG_BUFFER_MODE_CIRCULAR,
-	N_DEBUG_BUFFER_MODE
-} debug_buf_mode_t;
-
-struct debug_data_s {
-	uint32_t			enable;
-	uint32_t			bufmode;
-	uint32_t			head;
-	uint32_t			tail;
-	uint32_t			buf[DEBUG_BUF_SIZE];
-};
-
-struct debug_data_ddr_s {
-	uint32_t			enable;
-	int8_t				padding1[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
-	uint32_t			bufmode;
-	int8_t				padding2[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
-	uint32_t			head;
-	int8_t				padding3[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
-	uint32_t			tail;
-	int8_t				padding4[HIVE_ISP_DDR_WORD_BYTES-sizeof(uint32_t)];
-	uint32_t			buf[DEBUG_BUF_SIZE];
-};
-
-#endif /* __DEBUG_GLOBAL_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/dma_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/dma_global.h
deleted file mode 100644
index 9741c46..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/dma_global.h
+++ /dev/null
@@ -1,233 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DMA_GLOBAL_H_INCLUDED__
-#define __DMA_GLOBAL_H_INCLUDED__
-
-#define IS_DMA_VERSION_1
-
-#define HIVE_ISP_NUM_DMA_CONNS			3
-#define HIVE_ISP_NUM_DMA_CHANNELS_LOG2	3
-#define HIVE_ISP_NUM_DMA_CHANNELS		8
-#define N_DMA_CHANNEL_ID	HIVE_ISP_NUM_DMA_CHANNELS
-
-#include "dma_v1_defs.h"
-
-/*
- * Command token bit mappings
- *
- * transfer / config
- *    crun  param id[4] channel id[8] cmd id[4]
- *	| b16 | b15 .. b12 | b11 ... b4 | b3 ... b0 |
- */
-
-typedef unsigned int dma_channel;
-
-typedef enum {
-  dma_isp_to_bus_connection = HIVE_DMA_ISP_BUS_CONN,
-  dma_isp_to_ddr_connection = HIVE_DMA_ISP_DDR_CONN,
-  dma_bus_to_ddr_connection = HIVE_DMA_BUS_DDR_CONN,
-} dma_connection;
-
-typedef enum {
-  dma_zero_extension = _DMA_ZERO_EXTEND,
-  dma_sign_extension = _DMA_SIGN_EXTEND
-} dma_extension;
-
-
-#define DMA_PACK_CHANNEL(ch)             ((ch)   << _DMA_CHANNEL_IDX)
-#define DMA_PACK_PARAM(par)              ((par)  << _DMA_PARAM_IDX)
-#define DMA_PACK_EXTENSION(ext)          ((ext)  << _DMA_EXTENSION_IDX)
-#define DMA_PACK_ELEM_ORDER(ord)         ((ord)  << _DMA_ELEM_ORDER_IDX)
-#define DMA_PACK_LEFT_CROPPING(crop)     ((crop) << _DMA_LEFT_CROPPING_IDX)
-
-#define DMA_PACK_CMD_CHANNEL(cmd, ch)    ((cmd) | DMA_PACK_CHANNEL(ch))
-#define DMA_PACK_SETUP(conn, ext, order) ((conn) | DMA_PACK_EXTENSION(ext) | DMA_PACK_ELEM_ORDER(order))
-#define DMA_PACK_CROP_ELEMS(elems, crop) ((elems) | DMA_PACK_LEFT_CROPPING(crop))
-
-#define hive_dma_snd(dma_id, token) OP_std_snd(dma_id, (unsigned int)(token))
-
-#ifdef __HIVECC
-#define hive_dma_move_data(dma_id, read, channel, a_addr, b_addr, a_is_var, b_is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_READ_COMMAND:_DMA_WRITE_COMMAND, channel)); \
-  hive_dma_snd(dma_id, a_addr); \
-  hive_dma_snd(dma_id, b_addr); \
-}
-#else
-#define hive_dma_move_data(dma_id, read, channel, a_addr, b_addr, a_is_var, b_is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(read?_DMA_READ_COMMAND:_DMA_WRITE_COMMAND, channel) | (1 << _DMA_CRUN_IDX)); \
-  hive_dma_snd(dma_id, a_addr); \
-  hive_dma_snd(dma_id, b_addr); \
-  hive_dma_snd(dma_id, a_is_var); \
-  hive_dma_snd(dma_id, b_is_var); \
-}
-#endif
-
-#define hive_dma_move_b2a_data(dma_id, channel, a_addr, b_addr, a_is_var, b_is_var) \
-{ \
-  hive_dma_move_data (dma_id, true, channel, a_addr, b_addr, a_is_var, b_is_var); \
-}
-
-#define hive_dma_move_a2b_data(dma_id, channel, a_addr, b_addr, a_is_var, b_is_var) \
-{ \
-  hive_dma_move_data (dma_id, false, channel, a_addr, b_addr, a_is_var, b_is_var); \
-}
-
-#ifdef __HIVECC
-#define hive_dma_set_data(dma_id, channel, address, value, is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_INIT_COMMAND, channel)); \
-  hive_dma_snd(dma_id, address); \
-  hive_dma_snd(dma_id, value); \
-}
-#else
-#define hive_dma_set_data(dma_id, channel, address, value, is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_INIT_COMMAND, channel) | (1 << _DMA_CRUN_IDX)); \
-  hive_dma_snd(dma_id, address); \
-  hive_dma_snd(dma_id, value); \
-  hive_dma_snd(dma_id, is_var); \
-}
-#endif
-
-#define hive_dma_clear_data(dma_id, channel, address, is_var) hive_dma_set_data(dma_id, channel, address, 0, is_var)
-
-#ifdef __HIVECC
-#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value, to_is_var, from_is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel)); \
-  hive_dma_snd(dma_id, from_addr_value); \
-  hive_dma_snd(dma_id, to_addr); \
-}
-#else
-#define hive_dma_execute(dma_id, channel, cmd, to_addr, from_addr_value, to_is_var, from_is_var) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(cmd, channel) | (1 << _DMA_CRUN_IDX)); \
-  hive_dma_snd(dma_id, from_addr_value); \
-  hive_dma_snd(dma_id, to_addr); \
-  hive_dma_snd(dma_id, to_is_var); \
-  if ((cmd & DMA_CLEAR_CMDBIT) == 0) { \
-	hive_dma_snd(dma_id, from_is_var); \
-  } \
-}
-#endif
-
-#ifdef __HIVECC
-#define hive_dma_configure(dma_id, channel, connection, extension, height, \
-	stride_A, elems_A, cropping_A, width_A, \
-	stride_B, elems_B, cropping_B, width_B) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_CONFIG_CHANNEL_COMMAND, channel)); \
-  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension, _DMA_KEEP_ELEM_ORDER)); \
-  hive_dma_snd(dma_id, stride_A); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, cropping_A)); \
-  hive_dma_snd(dma_id, width_A); \
-  hive_dma_snd(dma_id, stride_B); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, cropping_B)); \
-  hive_dma_snd(dma_id, width_B); \
-  hive_dma_snd(dma_id, height); \
-}
-
-#define hive_dma_configure_fast(dma_id, channel, connection, extension, elems_A, elems_B) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_CONFIG_CHANNEL_COMMAND, channel)); \
-  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension, _DMA_KEEP_ELEM_ORDER)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, 0)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, 0)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, 1); \
-}
-#else
-#define hive_dma_configure(dma_id, channel, connection, extension, height, \
-	stride_A, elems_A, cropping_A, width_A, \
-	stride_B, elems_B, cropping_B, width_B) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_CONFIG_CHANNEL_COMMAND, channel) | (1 << _DMA_CRUN_IDX)); \
-  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension, _DMA_KEEP_ELEM_ORDER)); \
-  hive_dma_snd(dma_id, stride_A); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, cropping_A)); \
-  hive_dma_snd(dma_id, width_A); \
-  hive_dma_snd(dma_id, stride_B); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, cropping_B)); \
-  hive_dma_snd(dma_id, width_B); \
-  hive_dma_snd(dma_id, height); \
-}
-
-#define hive_dma_configure_fast(dma_id, channel, connection, extension, elems_A, elems_B) \
-{ \
-  hive_dma_snd(dma_id, DMA_PACK_CMD_CHANNEL(_DMA_CONFIG_CHANNEL_COMMAND, channel) | (1 << _DMA_CRUN_IDX)); \
-  hive_dma_snd(dma_id, DMA_PACK_SETUP(connection, extension, _DMA_KEEP_ELEM_ORDER)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_A, 0)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, DMA_PACK_CROP_ELEMS(elems_B, 0)); \
-  hive_dma_snd(dma_id, 0); \
-  hive_dma_snd(dma_id, 1); \
-}
-#endif
-
-#define hive_dma_set_parameter(dma_id, channel, param, value) \
-{ \
-  hive_dma_snd(dma_id, _DMA_SET_CHANNEL_PARAM_COMMAND | DMA_PACK_CHANNEL(channel) | DMA_PACK_PARAM(param)); \
-  hive_dma_snd(dma_id, value); \
-}
-
-#define	DMA_RW_CMDBIT		0x01
-#define	DMA_CFG_CMDBIT		0x02
-#define	DMA_CLEAR_CMDBIT	0x08
-#define	DMA_PARAM_CMDBIT	0x01
-
-#define	DMA_CFG_CMD			(DMA_CFG_CMDBIT)
-#define	DMA_CFGPARAM_CMD	(DMA_CFG_CMDBIT | DMA_PARAM_CMDBIT)
-
-#define DMA_CMD_NEEDS_ACK(cmd) (1)
-#define DMA_CMD_IS_TRANSFER(cmd) ((cmd & DMA_CFG_CMDBIT) == 0)
-#define DMA_CMD_IS_WR(cmd) ((cmd & DMA_RW_CMDBIT) != 0)
-#define DMA_CMD_IS_RD(cmd) ((cmd & DMA_RW_CMDBIT) == 0)
-#define DMA_CMD_IS_CLR(cmd) ((cmd & DMA_CLEAR_CMDBIT) != 0)
-#define DMA_CMD_IS_CFG(cmd) ((cmd & DMA_CFG_CMDBIT) != 0)
-#define DMA_CMD_IS_PARAMCFG(cmd) ((cmd & DMA_CFGPARAM_CMD) == DMA_CFGPARAM_CMD)
-
-/* As a matter of convention */
-#define DMA_TRANSFER_READ		DMA_TRANSFER_B2A
-#define DMA_TRANSFER_WRITE		DMA_TRANSFER_A2B
-/* store/load from the PoV of the system(memory) */
-#define DMA_TRANSFER_STORE		DMA_TRANSFER_B2A
-#define DMA_TRANSFER_LOAD		DMA_TRANSFER_A2B
-#define DMA_TRANSFER_CLEAR		DMA_TRANSFER_CLEAR_A
-
-typedef enum {
-	DMA_TRANSFER_CLEAR_A = DMA_CLEAR_CMDBIT,
-	DMA_TRANSFER_CLEAR_B = DMA_CLEAR_CMDBIT | DMA_RW_CMDBIT,
-	DMA_TRANSFER_A2B = DMA_RW_CMDBIT,
-	DMA_TRANSFER_B2A = 0,
-} dma_transfer_type_t;
-
-typedef enum {
-	DMA_CONFIG_SETUP = _DMA_PACKING_SETUP_PARAM,
-	DMA_CONFIG_HEIGHT = _DMA_HEIGHT_PARAM,
-	DMA_CONFIG_STRIDE_A_ = _DMA_STRIDE_A_PARAM,
-	DMA_CONFIG_CROP_ELEM_A = _DMA_ELEM_CROPPING_A_PARAM,
-	DMA_CONFIG_WIDTH_A = _DMA_WIDTH_A_PARAM,
-	DMA_CONFIG_STRIDE_B_ = _DMA_STRIDE_B_PARAM,
-	DMA_CONFIG_CROP_ELEM_B = _DMA_ELEM_CROPPING_B_PARAM,
-	DMA_CONFIG_WIDTH_B = _DMA_WIDTH_B_PARAM,
-} dma_config_type_t;
-
-#endif /* __DMA_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/event_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/event_global.h
deleted file mode 100644
index 813cdef..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/event_global.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __EVENT_GLOBAL_H_INCLUDED__
-#define __EVENT_GLOBAL_H_INCLUDED__
-
-/*#error "event_global.h: No global event information permitted"*/
-
-#endif /* __EVENT_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/fifo_monitor_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/fifo_monitor_global.h
deleted file mode 100644
index ac410c1..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/fifo_monitor_global.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __FIFO_MONITOR_GLOBAL_H_INCLUDED__
-#define __FIFO_MONITOR_GLOBAL_H_INCLUDED__
-
-#define IS_FIFO_MONITOR_VERSION_1
-
-#define HIVE_ISP_CSS_STREAM_SWITCH_NONE      0
-#define HIVE_ISP_CSS_STREAM_SWITCH_SP        1
-#define HIVE_ISP_CSS_STREAM_SWITCH_ISP       2
-
-#endif /* __FIFO_MONITOR_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gdc_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gdc_global.h
deleted file mode 100644
index 4932bf4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gdc_global.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GDC_GLOBAL_H_INCLUDED__
-#define __GDC_GLOBAL_H_INCLUDED__
-
-#define IS_GDC_VERSION_1
-
-#include <gdc_defs.h>
-
-/*
- * Storage addresses for packed data transfer
- */
-#define GDC_PARAM_ICX_LEFT_ROUNDED_IDX            0
-#define GDC_PARAM_OXDIM_FLOORED_IDX               1
-#define GDC_PARAM_OXDIM_LAST_IDX                  2
-#define GDC_PARAM_WOIX_LAST_IDX                   3
-#define GDC_PARAM_IY_TOPLEFT_IDX                  4
-#define GDC_PARAM_CHUNK_CNT_IDX                   5
-/* Derived from bpp */
-/*#define GDC_PARAM_ELEMENTS_PER_XMEM_ADDR_IDX    6 */
-#define GDC_PARAM_BPP_IDX						  6
-#define GDC_PARAM_BLOCK_HEIGHT_IDX                7
-/* The DMA stride == the GDC buffer stride */
-/*#define GDC_PARAM_DMA_CHANNEL_STRIDE_A_IDX        8 */
-#define GDC_PARAM_WOIX_IDX						  8
-#define GDC_PARAM_DMA_CHANNEL_STRIDE_B_IDX        9
-#define GDC_PARAM_DMA_CHANNEL_WIDTH_A_IDX        10
-#define GDC_PARAM_DMA_CHANNEL_WIDTH_B_IDX        11
-#define GDC_PARAM_VECTORS_PER_LINE_IN_IDX        12
-#define GDC_PARAM_VECTORS_PER_LINE_OUT_IDX       13
-#define GDC_PARAM_VMEM_IN_DIMY_IDX               14
-#define GDC_PARAM_COMMAND_IDX                    15
-#define N_GDC_PARAM                              16
-
-/* Because of the packed parameter thransfer max(params) == max(fragments) */
-#define	N_GDC_FRAGMENTS		N_GDC_PARAM
-
-typedef enum {
-	gdc_8_bpp  = 8,
-	gdc_10_bpp = 10,
-	gdc_12_bpp = 12,
-	gdc_14_bpp = 14
-} gdc_bits_per_pixel_t;
-
-typedef struct {
-	unsigned int      origin_x;
-	unsigned int      origin_y;
-	unsigned int      in_addr_offset;
-	unsigned int      in_block_width;
-	unsigned int      in_block_height;
-	unsigned int      p0_x;
-	unsigned int      p0_y;
-	unsigned int      p1_x;
-	unsigned int      p1_y;
-	unsigned int      p2_x;
-	unsigned int      p2_y;
-	unsigned int      p3_x;
-	unsigned int      p3_y;
-	unsigned int      padding[3];
-} gdc_warp_param_mem_t;
-
-#endif /* __GDC_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gp_device_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gp_device_global.h
deleted file mode 100644
index 118992e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gp_device_global.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GP_DEVICE_GLOBAL_H_INCLUDED__
-#define __GP_DEVICE_GLOBAL_H_INCLUDED__
-
-#define IS_GP_DEVICE_VERSION_1
-
-/* The SP configures FIFO switches in these registers */
-#define _REG_GP_SWITCH_IF_ADDR				0x00
-#define _REG_GP_SWITCH_DMA_ADDR				0x04
-#define _REG_GP_SWITCH_GDC_ADDR				0x08
-
-/* The SP sends SW interrupt info to this register */
-#define _REG_GP_IRQ_REQUEST_ADDR			0x98
-
-#define _REG_GP_SYNGEN_ENABLE_ADDR			0x0C
-#define _REG_GP_SYNGEN_NR_PIX_ADDR			0x10
-#define _REG_GP_SYNGEN_NR_LINES_ADDR		0x14
-#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR	0x18
-#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR	0x1C
-#define _REG_GP_ISEL_SOF_ADDR				0x20
-#define _REG_GP_ISEL_EOF_ADDR				0x24
-#define _REG_GP_ISEL_SOL_ADDR				0x28
-#define _REG_GP_ISEL_EOL_ADDR				0x2C
-#define _REG_GP_ISEL_LFSR_ENABLE_ADDR		0x30
-#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR		0x34
-#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR	0x38
-#define _REG_GP_ISEL_TPG_ENABLE_ADDR		0x3C
-#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR		0x40
-#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR		0x44
-#define _REG_GP_ISEL_VER_CNT_MASK_ADDR		0x48
-#define _REG_GP_ISEL_XY_CNT_MASK_ADDR		0x4C
-#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR		0x50
-#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR		0x54
-#define _REG_GP_ISEL_CH_ID_ADDR				0x58
-#define _REG_GP_ISEL_FMT_TYPE_ADDR			0x5C
-#define _REG_GP_ISEL_DATA_SEL_ADDR			0x60
-#define _REG_GP_ISEL_SBAND_SEL_ADDR			0x64
-#define _REG_GP_ISEL_SYNC_SEL_ADDR			0x68
-#define _REG_GP_INP_SWI_LUT_REG_0_ADDR		0x6C
-#define _REG_GP_INP_SWI_LUT_REG_1_ADDR		0x70
-#define _REG_GP_INP_SWI_LUT_REG_2_ADDR		0x74
-#define _REG_GP_INP_SWI_LUT_REG_3_ADDR		0x78
-#define _REG_GP_INP_SWI_LUT_REG_4_ADDR		0x7C
-#define _REG_GP_INP_SWI_LUT_REG_5_ADDR		0x80
-#define _REG_GP_INP_SWI_LUT_REG_6_ADDR		0x84
-#define _REG_GP_INP_SWI_LUT_REG_7_ADDR		0x88
-#define _REG_GP_INP_SWI_FSYNC_LUT_REG_ADDR	0x8C
-#define _REG_GP_SDRAM_WAKEUP_ADDR			0x90
-#define _REG_GP_IDLE_ADDR					0x94
-
-#define _REG_GP_MIPI_USED_DWORD_ADDR		0xA0
-
-#define _REG_GP_IFMT_input_switch_lut_reg0			_REG_GP_INP_SWI_LUT_REG_0_ADDR
-#define _REG_GP_IFMT_input_switch_lut_reg1			_REG_GP_INP_SWI_LUT_REG_1_ADDR
-#define _REG_GP_IFMT_input_switch_lut_reg2			_REG_GP_INP_SWI_LUT_REG_2_ADDR
-#define _REG_GP_IFMT_input_switch_lut_reg3			_REG_GP_INP_SWI_LUT_REG_3_ADDR
-#define _REG_GP_IFMT_input_switch_lut_reg4			_REG_GP_INP_SWI_LUT_REG_4_ADDR
-#define _REG_GP_IFMT_input_switch_lut_reg5			_REG_GP_INP_SWI_LUT_REG_5_ADDR
-#define _REG_GP_IFMT_input_switch_lut_reg6			_REG_GP_INP_SWI_LUT_REG_6_ADDR
-#define _REG_GP_IFMT_input_switch_lut_reg7			_REG_GP_INP_SWI_LUT_REG_7_ADDR
-#define _REG_GP_IFMT_input_switch_fsync_lut			_REG_GP_INP_SWI_FSYNC_LUT_REG_ADDR
-#define _REG_GP_IFMT_input_switch_ch_id_fmt_type	0xffffffff
-
-#endif /* __GP_DEVICE_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gpio_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gpio_global.h
deleted file mode 100644
index ec04e30..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/gpio_global.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GPIO_GLOBAL_H_INCLUDED__
-#define __GPIO_GLOBAL_H_INCLUDED__
-
-#define IS_GPIO_VERSION_1
-
-#include <gpio_block_defs.h>
-
-/* pqiao: following part only defines in hive_isp_css_defs.h in fpga system.
-	port it here
-*/
-
-/* GPIO pin defines */
-/*#define HIVE_GPIO_CAMERA_BOARD_RESET_PIN_NR                   0
-#define HIVE_GPIO_LCD_CLOCK_SELECT_PIN_NR                     7
-#define HIVE_GPIO_HDMI_CLOCK_SELECT_PIN_NR                    8
-#define HIVE_GPIO_LCD_VERT_FLIP_PIN_NR                        8
-#define HIVE_GPIO_LCD_HOR_FLIP_PIN_NR                         9
-#define HIVE_GPIO_AS3683_GPIO_P0_PIN_NR                       1
-#define HIVE_GPIO_AS3683_DATA_P1_PIN_NR                       2
-#define HIVE_GPIO_AS3683_CLK_P2_PIN_NR                        3
-#define HIVE_GPIO_AS3683_T1_F0_PIN_NR                         4
-#define HIVE_GPIO_AS3683_SFL_F1_PIN_NR                        5
-#define HIVE_GPIO_AS3683_STROBE_F2_PIN_NR                     6
-#define HIVE_GPIO_MAX1577_EN1_PIN_NR                          1
-#define HIVE_GPIO_MAX1577_EN2_PIN_NR                          2
-#define HIVE_GPIO_MAX8685A_EN_PIN_NR                          3
-#define HIVE_GPIO_MAX8685A_TRIG_PIN_NR                        4*/
-
-#define HIVE_GPIO_STROBE_TRIGGER_PIN						2
-
-#endif /* __GPIO_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug.c
deleted file mode 100644
index fbd9dc9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "debug.h"
-
-#ifndef __INLINE_DEBUG__
-#include "debug_private.h"
-#endif /* __INLINE_DEBUG__ */
-
-#include "memory_access.h"
-
-#include "sp.h"
-
-#include "assert_support.h"
-
-/* The address of the remote copy */
-hrt_address	debug_buffer_address = (hrt_address)-1;
-hrt_vaddress	debug_buffer_ddr_address = (hrt_vaddress)-1;
-/* The local copy */
-debug_data_t		debug_data;
-debug_data_t		*debug_data_ptr = &debug_data;
-
-void debug_buffer_init(
-	const hrt_address		addr)
-{
-	debug_buffer_address = addr;
-
-	debug_data.head = 0;
-	debug_data.tail = 0;
-return;
-}
-
-void debug_buffer_ddr_init(
-	const hrt_vaddress		addr)
-{
-	debug_buf_mode_t mode = DEBUG_BUFFER_MODE_LINEAR;
-	uint32_t enable = 1;
-	uint32_t head = 0;
-	uint32_t tail = 0;
-	/* set the ddr queue */
-	debug_buffer_ddr_address = addr;
-	mmgr_store(addr + DEBUG_DATA_BUF_MODE_DDR_ADDR,
-				&mode, sizeof(debug_buf_mode_t));
-	mmgr_store(addr + DEBUG_DATA_HEAD_DDR_ADDR,
-				&head, sizeof(uint32_t));
-	mmgr_store(addr + DEBUG_DATA_TAIL_DDR_ADDR,
-				&tail, sizeof(uint32_t));
-	mmgr_store(addr + DEBUG_DATA_ENABLE_DDR_ADDR,
-				&enable, sizeof(uint32_t));
-
-	/* set the local copy */
-	debug_data.head = 0;
-	debug_data.tail = 0;
-return;
-}
-
-void debug_buffer_setmode(
-	const debug_buf_mode_t	mode)
-{
-assert(debug_buffer_address != ((hrt_address)-1));
-
-	sp_dmem_store_uint32(SP0_ID,
-		debug_buffer_address + DEBUG_DATA_BUF_MODE_ADDR, mode);
-return;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_local.h
deleted file mode 100644
index 19a27ae..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_local.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DEBUG_LOCAL_H_INCLUDED__
-#define __DEBUG_LOCAL_H_INCLUDED__
-
-#include "debug_global.h"
-
-#endif /* __DEBUG_LOCAL_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_private.h
deleted file mode 100644
index 18d3101..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/debug_private.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DEBUG_PRIVATE_H_INCLUDED__
-#define __DEBUG_PRIVATE_H_INCLUDED__
-
-#include "debug_public.h"
-
-#include "sp.h"
-
-#define __INLINE_ISP__
-#include "isp.h"
-
-#include "memory_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_DEBUG_C bool is_debug_buffer_empty(void)
-{
-return (debug_data_ptr->head == debug_data_ptr->tail);
-}
-
-STORAGE_CLASS_DEBUG_C hrt_data debug_dequeue(void)
-{
-	hrt_data	value = 0;
-
-assert(debug_buffer_address != ((hrt_address)-1));
-
-	debug_synch_queue();
-
-	if (!is_debug_buffer_empty()) {
-		value = debug_data_ptr->buf[debug_data_ptr->head];
-		debug_data_ptr->head = (debug_data_ptr->head + 1) & DEBUG_BUF_MASK;
-		sp_dmem_store_uint32(SP0_ID, debug_buffer_address + DEBUG_DATA_HEAD_ADDR, debug_data_ptr->head);
-	}
-
-return value;
-}
-
-STORAGE_CLASS_DEBUG_C void debug_synch_queue(void)
-{
-	uint32_t	remote_tail	= sp_dmem_load_uint32(SP0_ID, debug_buffer_address + DEBUG_DATA_TAIL_ADDR);
-/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
-	if (remote_tail > debug_data_ptr->tail) {
-		size_t	delta = remote_tail - debug_data_ptr->tail;
-		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
-	} else if (remote_tail < debug_data_ptr->tail) {
-		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
-		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
-		sp_dmem_load(SP0_ID, debug_buffer_address + DEBUG_DATA_BUF_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
-	} /* else we are up to date */
-	debug_data_ptr->tail = remote_tail;
-return;
-}
-
-STORAGE_CLASS_DEBUG_C void debug_synch_queue_isp(void)
-{
-	uint32_t	remote_tail	= isp_dmem_load_uint32(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_TAIL_ADDR);
-/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
-	if (remote_tail > debug_data_ptr->tail) {
-		size_t	delta = remote_tail - debug_data_ptr->tail;
-		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
-	} else if (remote_tail < debug_data_ptr->tail) {
-		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
-		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
-		isp_dmem_load(ISP0_ID, DEBUG_BUFFER_ISP_DMEM_ADDR + DEBUG_DATA_BUF_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
-	} /* else we are up to date */
-	debug_data_ptr->tail = remote_tail;
-return;
-}
-
-STORAGE_CLASS_DEBUG_C void debug_synch_queue_ddr(void)
-{
-	uint32_t	remote_tail;
-
-	mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_TAIL_DDR_ADDR, &remote_tail, sizeof(uint32_t));
-/* We could move the remote head after the upload, but we would have to limit the upload w.r.t. the local head. This is easier */
-	if (remote_tail > debug_data_ptr->tail) {
-		size_t	delta = remote_tail - debug_data_ptr->tail;
-		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
-	} else if (remote_tail < debug_data_ptr->tail) {
-		size_t	delta = DEBUG_BUF_SIZE - debug_data_ptr->tail;
-		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR + debug_data_ptr->tail*sizeof(uint32_t), (void *)&(debug_data_ptr->buf[debug_data_ptr->tail]), delta*sizeof(uint32_t));
-		mmgr_load(debug_buffer_ddr_address + DEBUG_DATA_BUF_DDR_ADDR, (void *)&(debug_data_ptr->buf[0]), remote_tail*sizeof(uint32_t));
-	} /* else we are up to date */
-	debug_data_ptr->tail = remote_tail;
-return;
-}
-
-#endif /* __DEBUG_PRIVATE_H_INCLUDED__ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma.c
deleted file mode 100644
index a409616..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma.c
+++ /dev/null
@@ -1,287 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include <stddef.h>		/* NULL */
-
-#include "dma.h"
-
-#include "assert_support.h"
-
-#ifndef __INLINE_DMA__
-#include "dma_private.h"
-#endif /* __INLINE_DMA__ */
-
-void dma_get_state(
-	const dma_ID_t		ID,
-	dma_state_t			*state)
-{
-	int			i;
-	hrt_data	tmp;
-
-assert(ID < N_DMA_ID);
-assert(state != NULL);
-	if (state == NULL)
-		return;
-
-	tmp = dma_reg_load(ID, DMA_COMMAND_FSM_REG_IDX);
-	state->fsm_command_idle = tmp & 0x1;
-	state->fsm_command_run = tmp & 0x2;
-	state->fsm_command_stalling = tmp & 0x4;
-	state->fsm_command_error    = tmp & 0x8;
-	state->last_command_channel = (tmp>>8 & 0xFF);
-	state->last_command_param =  (tmp>>16 & 0x0F);
-	tmp = (tmp>>4) & 0x0F;
-/* state->last_command = (dma_commands_t)tmp; */
-/* if the enumerator is made non-linear */
-	if (tmp == 0)
-		state->last_command = DMA_COMMAND_READ;
-	if (tmp == 1)
-		state->last_command = DMA_COMMAND_WRITE;
-	if (tmp == 2)
-		state->last_command = DMA_COMMAND_SET_CHANNEL;
-	if (tmp == 3)
-		state->last_command = DMA_COMMAND_SET_PARAM;
-	if (tmp == 4)
-		state->last_command = DMA_COMMAND_READ_SPECIFIC;
-	if (tmp == 5)
-		state->last_command = DMA_COMMAND_WRITE_SPECIFIC;
-	if (tmp == 8)
-		state->last_command = DMA_COMMAND_INIT;
-	if (tmp == 12)
-		state->last_command = DMA_COMMAND_INIT_SPECIFIC;
-	if (tmp == 15)
-		state->last_command = DMA_COMMAND_RST;
-
-/* No sub-fields, idx = 0 */
-	state->current_command = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_CMD_IDX));
-	state->current_addr_a = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_ADDR_A_IDX));
-	state->current_addr_b = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(0, _DMA_FSM_GROUP_ADDR_B_IDX));
-
-	tmp =  dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_STATE_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_idle = tmp & 0x1;
-	state->fsm_ctrl_run = tmp & 0x2;
-	state->fsm_ctrl_stalling = tmp & 0x4;
-	state->fsm_ctrl_error = tmp & 0x8;
-	tmp = tmp >> 4;
-/* state->fsm_ctrl_state = (dma_ctrl_states_t)tmp; */
-	if (tmp == 0)
-		state->fsm_ctrl_state = DMA_CTRL_STATE_IDLE;
-	if (tmp == 1)
-		state->fsm_ctrl_state = DMA_CTRL_STATE_REQ_RCV;
-	if (tmp == 2)
-		state->fsm_ctrl_state = DMA_CTRL_STATE_RCV;
-	if (tmp == 3)
-		state->fsm_ctrl_state = DMA_CTRL_STATE_RCV_REQ;
-	if (tmp == 4)
-		state->fsm_ctrl_state = DMA_CTRL_STATE_INIT;
-	state->fsm_ctrl_source_dev = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_source_addr = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_source_stride = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_source_width = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_source_height = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_source_dev = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_dest_dev = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_dest_addr = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_dest_stride = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_source_width = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_dest_height = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_dest_width = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_source_elems = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_dest_elems = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-	state->fsm_ctrl_pack_extension = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX,
-		_DMA_FSM_GROUP_FSM_CTRL_IDX));
-
-	tmp = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_PACK_STATE_IDX,
-		_DMA_FSM_GROUP_FSM_PACK_IDX));
-	state->pack_idle     = tmp & 0x1;
-	state->pack_run      = tmp & 0x2;
-	state->pack_stalling = tmp & 0x4;
-	state->pack_error    = tmp & 0x8;
-	state->pack_cnt_height = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX,
-		_DMA_FSM_GROUP_FSM_PACK_IDX));
-	state->pack_src_cnt_width = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX,
-		_DMA_FSM_GROUP_FSM_PACK_IDX));
-	state->pack_dest_cnt_width = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX,
-		_DMA_FSM_GROUP_FSM_PACK_IDX));
-
-	tmp = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_REQ_STATE_IDX,
-		_DMA_FSM_GROUP_FSM_REQ_IDX));
-/* state->read_state = (dma_rw_states_t)tmp; */
-	if (tmp == 0)
-		state->read_state = DMA_RW_STATE_IDLE;
-	if (tmp == 1)
-		state->read_state = DMA_RW_STATE_REQ;
-	if (tmp == 2)
-		state->read_state = DMA_RW_STATE_NEXT_LINE;
-	if (tmp == 3)
-		state->read_state = DMA_RW_STATE_UNLOCK_CHANNEL;
-	state->read_cnt_height = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX,
-		_DMA_FSM_GROUP_FSM_REQ_IDX));
-	state->read_cnt_width = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX,
-		_DMA_FSM_GROUP_FSM_REQ_IDX));
-
-	tmp = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_WR_STATE_IDX,
-		_DMA_FSM_GROUP_FSM_WR_IDX));
-/* state->write_state = (dma_rw_states_t)tmp; */
-	if (tmp == 0)
-		state->write_state = DMA_RW_STATE_IDLE;
-	if (tmp == 1)
-		state->write_state = DMA_RW_STATE_REQ;
-	if (tmp == 2)
-		state->write_state = DMA_RW_STATE_NEXT_LINE;
-	if (tmp == 3)
-		state->write_state = DMA_RW_STATE_UNLOCK_CHANNEL;
-	state->write_height = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX,
-		_DMA_FSM_GROUP_FSM_WR_IDX));
-	state->write_width = dma_reg_load(ID,
-		DMA_CG_INFO_REG_IDX(
-		_DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX,
-		_DMA_FSM_GROUP_FSM_WR_IDX));
-
-	for (i = 0; i < HIVE_ISP_NUM_DMA_CONNS; i++) {
-		dma_port_state_t *port = &(state->port_states[i]);
-
-		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(0, i));
-		port->req_cs   = ((tmp & 0x1) != 0);
-		port->req_we_n = ((tmp & 0x2) != 0);
-		port->req_run  = ((tmp & 0x4) != 0);
-		port->req_ack  = ((tmp & 0x8) != 0);
-
-		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(1, i));
-		port->send_cs   = ((tmp & 0x1) != 0);
-		port->send_we_n = ((tmp & 0x2) != 0);
-		port->send_run  = ((tmp & 0x4) != 0);
-		port->send_ack  = ((tmp & 0x8) != 0);
-
-		tmp = dma_reg_load(ID, DMA_DEV_INFO_REG_IDX(2, i));
-		if (tmp & 0x1)
-			port->fifo_state = DMA_FIFO_STATE_WILL_BE_FULL;
-		if (tmp & 0x2)
-			port->fifo_state = DMA_FIFO_STATE_FULL;
-		if (tmp & 0x4)
-			port->fifo_state = DMA_FIFO_STATE_EMPTY;
-		port->fifo_counter = tmp >> 3;
-	}
-
-	for (i = 0; i < HIVE_DMA_NUM_CHANNELS; i++) {
-		dma_channel_state_t *ch = &(state->channel_states[i]);
-
-		ch->connection = DMA_GET_CONNECTION(dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_PACKING_SETUP_PARAM)));
-		ch->sign_extend = DMA_GET_EXTENSION(dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_PACKING_SETUP_PARAM)));
-		ch->reverse_elem_order = DMA_GET_ELEMENT_ORDER(dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_PACKING_SETUP_PARAM)));
-		ch->height = dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_HEIGHT_PARAM));
-		ch->stride_a = dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_STRIDE_A_PARAM));
-		ch->elems_a = DMA_GET_ELEMENTS(dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_ELEM_CROPPING_A_PARAM)));
-		ch->cropping_a = DMA_GET_CROPPING(dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_ELEM_CROPPING_A_PARAM)));
-		ch->width_a = dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_WIDTH_A_PARAM));
-		ch->stride_b = dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_STRIDE_B_PARAM));
-		ch->elems_b = DMA_GET_ELEMENTS(dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_ELEM_CROPPING_B_PARAM)));
-		ch->cropping_b = DMA_GET_CROPPING(dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_ELEM_CROPPING_B_PARAM)));
-		ch->width_b = dma_reg_load(ID,
-			DMA_CHANNEL_PARAM_REG_IDX(i,
-			_DMA_WIDTH_B_PARAM));
-	}
-
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_local.h
deleted file mode 100644
index cd74e57..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_local.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DMA_LOCAL_H_INCLUDED__
-#define __DMA_LOCAL_H_INCLUDED__
-
-#include <stdbool.h>
-
-#include "dma_global.h"
-
-#include <hrt/defs.h>				/* HRTCAT() */
-#include <hrt/bits.h>				/* _hrt_get_bits() */
-#include <hive_isp_css_defs.h>		/* HIVE_DMA_NUM_CHANNELS */
-#include <dma_v1_defs.h>
-
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_IDX	_DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_REV_IDX
-
-/*
- * Macro's to compute the DMA parameter register indices
- */
-#define DMA_SEL_COMP(comp)     (((comp)  & _hrt_ones(_DMA_ADDR_SEL_COMP_BITS))            << _DMA_ADDR_SEL_COMP_IDX)
-#define DMA_SEL_CH(ch)         (((ch)    & _hrt_ones(_DMA_ADDR_SEL_CH_REG_BITS))          << _DMA_ADDR_SEL_CH_REG_IDX)
-#define DMA_SEL_PARAM(param)   (((param) & _hrt_ones(_DMA_ADDR_SEL_PARAM_BITS))           << _DMA_ADDR_SEL_PARAM_IDX)
-#define DMA_SEL_CG_INFO(info)  (((info)  & _hrt_ones(_DMA_ADDR_SEL_GROUP_COMP_INFO_BITS)) << _DMA_ADDR_SEL_GROUP_COMP_INFO_IDX)
-#define DMA_SEL_CG_COMP(comp)  (((comp)  & _hrt_ones(_DMA_ADDR_SEL_GROUP_COMP_BITS))      << _DMA_ADDR_SEL_GROUP_COMP_IDX)
-/* #define DMA_SEL_CG_ID(gr)      (((gr)    & _hrt_ones(_DMA_ADDR_SEL_GROUP_BITS))           << _DMA_ADDR_SEL_GROUP_IDX) */
-#define DMA_SEL_DEV_INFO(info) (((info)  & _hrt_ones(_DMA_ADDR_SEL_DEV_INTERF_INFO_BITS)) << _DMA_ADDR_SEL_DEV_INTERF_INFO_IDX)
-#define DMA_SEL_DEV_ID(dev)    (((dev)   & _hrt_ones(_DMA_ADDR_SEL_DEV_INTERF_IDX_BITS))  << _DMA_ADDR_SEL_DEV_INTERF_IDX_IDX)
-
-#define DMA_COMMAND_FSM_REG_IDX							(DMA_SEL_COMP(_DMA_SEL_FSM_CMD) >> 2)
-#define DMA_CHANNEL_PARAM_REG_IDX(ch, param)			((DMA_SEL_COMP(_DMA_SEL_CH_REG) | DMA_SEL_CH(ch) | DMA_SEL_PARAM(param)) >> 2)
-/* #define DMA_CG_INFO_REG_IDX(info_id, comp_id, gr_id)	((DMA_SEL_COMP(_DMA_SEL_CONN_GROUP) | DMA_SEL_CG_INFO(info_id) | DMA_SEL_CG_COMP(comp_id) | DMA_SEL_CG_ID(gr_id)) >> 2) */
-#define DMA_CG_INFO_REG_IDX(info_id, comp_id)			((DMA_SEL_COMP(_DMA_SEL_CONN_GROUP) | DMA_SEL_CG_INFO(info_id) | DMA_SEL_CG_COMP(comp_id) | 0) >> 2)
-#define DMA_DEV_INFO_REG_IDX(info_id, dev_id)			((DMA_SEL_COMP(_DMA_SEL_DEV_INTERF) | DMA_SEL_DEV_INFO(info_id) | DMA_SEL_DEV_ID(dev_id)) >> 2)
-#define DMA_RST_REG_IDX									(DMA_SEL_COMP(_DMA_SEL_RESET) >> 2)
-
-#define DMA_GET_CONNECTION(val)    _hrt_get_bits(val, _DMA_CONNECTION_IDX,    _DMA_CONNECTION_BITS)
-#define DMA_GET_EXTENSION(val)     _hrt_get_bits(val, _DMA_EXTENSION_IDX,     _DMA_EXTENSION_BITS)
-#define DMA_GET_ELEMENT_ORDER(val) _hrt_get_bits(val, _DMA_ELEM_ORDER_IDX,    _DMA_ELEM_ORDER_BITS)
-#define DMA_GET_ELEMENTS(val)      _hrt_get_bits(val, _DMA_ELEMENTS_IDX,      _DMA_ELEMENTS_BITS)
-#define DMA_GET_CROPPING(val)      _hrt_get_bits(val, _DMA_LEFT_CROPPING_IDX, _DMA_LEFT_CROPPING_BITS)
-
-typedef enum {
-	DMA_CTRL_STATE_IDLE,
-	DMA_CTRL_STATE_REQ_RCV,
-	DMA_CTRL_STATE_RCV,
-	DMA_CTRL_STATE_RCV_REQ,
-	DMA_CTRL_STATE_INIT,
-	N_DMA_CTRL_STATES
-} dma_ctrl_states_t;
-
-typedef enum {
-	DMA_COMMAND_READ,
-	DMA_COMMAND_WRITE,
-	DMA_COMMAND_SET_CHANNEL,
-	DMA_COMMAND_SET_PARAM,
-	DMA_COMMAND_READ_SPECIFIC,
-	DMA_COMMAND_WRITE_SPECIFIC,
-	DMA_COMMAND_INIT,
-	DMA_COMMAND_INIT_SPECIFIC,
-	DMA_COMMAND_RST,
-	N_DMA_COMMANDS
-} dma_commands_t;
-
-typedef enum {
-	DMA_RW_STATE_IDLE,
-	DMA_RW_STATE_REQ,
-	DMA_RW_STATE_NEXT_LINE,
-	DMA_RW_STATE_UNLOCK_CHANNEL,
-	N_DMA_RW_STATES
-} dma_rw_states_t;
-
-typedef enum {
-	DMA_FIFO_STATE_WILL_BE_FULL,
-	DMA_FIFO_STATE_FULL,
-	DMA_FIFO_STATE_EMPTY,
-	N_DMA_FIFO_STATES
-} dma_fifo_states_t;
-
-/* typedef struct dma_state_s			dma_state_t; */
-typedef struct dma_channel_state_s	dma_channel_state_t;
-typedef struct dma_port_state_s		dma_port_state_t;
-
-struct dma_port_state_s {
-	bool                       req_cs;
-	bool                       req_we_n;
-	bool                       req_run;
-	bool                       req_ack;
-	bool                       send_cs;
-	bool                       send_we_n;
-	bool                       send_run;
-	bool                       send_ack;
-	dma_fifo_states_t          fifo_state;
-	int                        fifo_counter;
-};
-
-struct dma_channel_state_s {
-	int                        connection;
-	bool                       sign_extend;
-	bool                       reverse_elem_order;
-	int                        height;
-	int                        stride_a;
-	int                        elems_a;
-	int                        cropping_a;
-	int                        width_a;
-	int                        stride_b;
-	int                        elems_b;
-	int                        cropping_b;
-	int                        width_b;
-};
-
-struct dma_state_s {
-	bool                       fsm_command_idle;
-	bool                       fsm_command_run;
-	bool                       fsm_command_stalling;
-	bool                       fsm_command_error;
-	dma_commands_t             last_command;
-	int                        last_command_channel;
-	int                        last_command_param;
-	dma_commands_t             current_command;
-	int                        current_addr_a;
-	int                        current_addr_b;
-	bool                       fsm_ctrl_idle;
-	bool                       fsm_ctrl_run;
-	bool                       fsm_ctrl_stalling;
-	bool                       fsm_ctrl_error;
-	dma_ctrl_states_t          fsm_ctrl_state;
-	int                        fsm_ctrl_source_dev;
-	int                        fsm_ctrl_source_addr;
-	int                        fsm_ctrl_source_stride;
-	int                        fsm_ctrl_source_width;
-	int                        fsm_ctrl_source_height;
-	int                        fsm_ctrl_pack_source_dev;
-	int                        fsm_ctrl_pack_dest_dev;
-	int                        fsm_ctrl_dest_addr;
-	int                        fsm_ctrl_dest_stride;
-	int                        fsm_ctrl_pack_source_width;
-	int                        fsm_ctrl_pack_dest_height;
-	int                        fsm_ctrl_pack_dest_width;
-	int                        fsm_ctrl_pack_source_elems;
-	int                        fsm_ctrl_pack_dest_elems;
-	int                        fsm_ctrl_pack_extension;
-	int						   pack_idle;
-	int	                       pack_run;
-	int                    	   pack_stalling;
-	int		                   pack_error;
-	int                        pack_cnt_height;
-	int                        pack_src_cnt_width;
-	int                        pack_dest_cnt_width;
-	dma_rw_states_t            read_state;
-	int                        read_cnt_height;
-	int                        read_cnt_width;
-	dma_rw_states_t            write_state;
-	int                        write_height;
-	int                        write_width;
-	dma_port_state_t           port_states[HIVE_ISP_NUM_DMA_CONNS];
-	dma_channel_state_t        channel_states[HIVE_DMA_NUM_CHANNELS];
-};
-
-#endif /* __DMA_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_private.h
deleted file mode 100644
index 4424ffe..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/dma_private.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __DMA_PRIVATE_H_INCLUDED__
-#define __DMA_PRIVATE_H_INCLUDED__
-
-#include "dma_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_DMA_C void dma_reg_store(
-	const dma_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value)
-{
-assert(ID < N_DMA_ID);
-assert(DMA_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(DMA_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_DMA_C hrt_data dma_reg_load(
-	const dma_ID_t		ID,
-	const unsigned int	reg)
-{
-assert(ID < N_DMA_ID);
-assert(DMA_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(DMA_BASE[ID] + reg*sizeof(hrt_data));
-}
-
-#endif /* __DMA_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event.c
deleted file mode 100644
index 0ea8f7f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event.c
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include "event.h"
-
-#ifndef __INLINE_EVENT__
-#include "event_private.h"
-#endif /* __INLINE_EVENT__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_local.h
deleted file mode 100644
index 0940ab2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_local.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __EVENT_LOCAL_H_INCLUDED__
-#define __EVENT_LOCAL_H_INCLUDED__
-
-/*
- * All events come from connections mapped on the system
- * bus but do not use a global IRQ
- */
-#include "event_global.h"
-
-typedef enum {
-	SP0_EVENT_ID,
-	ISP0_EVENT_ID,
-	STR2MIPI_EVENT_ID,
-	N_EVENT_ID
-} event_ID_t;
-
-#define	EVENT_QUERY_BIT		0
-
-/* Events are read from FIFO */
-static const hrt_address event_source_addr[N_EVENT_ID] = {
-	0x10200200UL,
-	0x10200204UL,
-	0xffffffffUL};
-
-/* Read from FIFO are blocking, query data availability */
-static const hrt_address event_source_query_addr[N_EVENT_ID] = {
-	0x10200210UL,
-	0x10200214UL,
-	0xffffffffUL};
-
-/* Events are written to FIFO */
-static const hrt_address event_sink_addr[N_EVENT_ID] = {
-	0x10200208UL,
-	0x1020020CUL,
-	0x10200304UL};
-
-/* Writes to FIFO are blocking, query data space */
-static const hrt_address event_sink_query_addr[N_EVENT_ID] = {
-	0x10200218UL,
-	0x1020021CUL,
-	0x1020030CUL};
-
-#endif /* __EVENT_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_private.h
deleted file mode 100644
index d4f92a2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/event_private.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __EVENT_PRIVATE_H_INCLUDED__
-#define __EVENT_PRIVATE_H_INCLUDED__
-
-#include "event_public.h"
-
-#include "device_access.h"
-
-#include <bits.h>
-
-#include "assert_support.h"
-
-STORAGE_CLASS_EVENT_C void event_wait_for(
-	const event_ID_t		ID)
-{
-assert(ID < N_EVENT_ID);
-assert(event_source_addr[ID] != ((hrt_address)-1));
-	(void)device_load_uint32(event_source_addr[ID]);
-return;
-}
-
-STORAGE_CLASS_EVENT_C void cnd_event_wait_for(
-	const event_ID_t		ID,
-	const bool				cnd)
-{
-	if (cnd) {
-		event_wait_for(ID);
-	}
-return;
-}
-
-STORAGE_CLASS_EVENT_C hrt_data event_receive_token(
-	const event_ID_t		ID)
-{
-assert(ID < N_EVENT_ID);
-assert(event_source_addr[ID] != ((hrt_address)-1));
-return device_load_uint32(event_source_addr[ID]);
-}
-
-STORAGE_CLASS_EVENT_C void event_send_token(
-	const event_ID_t		ID,
-	const hrt_data			token)
-{
-assert(ID < N_EVENT_ID);
-assert(event_sink_addr[ID] != ((hrt_address)-1));
-	device_store_uint32(event_sink_addr[ID], token);
-return;
-}
-
-STORAGE_CLASS_EVENT_C bool is_event_pending(
-	const event_ID_t		ID)
-{
-	hrt_data	value;
-assert(ID < N_EVENT_ID);
-assert(event_source_query_addr[ID] != ((hrt_address)-1));
-	value = device_load_uint32(event_source_query_addr[ID]);
-return !_hrt_get_bit(value, EVENT_QUERY_BIT);
-}
-
-STORAGE_CLASS_EVENT_C bool can_event_send_token(
-	const event_ID_t		ID)
-{
-	hrt_data	value;
-assert(ID < N_EVENT_ID);
-assert(event_sink_query_addr[ID] != ((hrt_address)-1));
-	value = device_load_uint32(event_sink_query_addr[ID]);
-return !_hrt_get_bit(value, EVENT_QUERY_BIT);
-}
-
-#endif /* __EVENT_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor.c
deleted file mode 100644
index 9aa01a5..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor.c
+++ /dev/null
@@ -1,477 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include "fifo_monitor.h"
-
-#include <stdbool.h>
-
-#include "device_access.h"
-
-#include <hrt/bits.h>
-
-#define __INLINE_GP_DEVICE__
-#include "gp_device.h"
-
-#include "assert_support.h"
-
-#ifndef __INLINE_FIFO_MONITOR__
-#define STORAGE_CLASS_FIFO_MONITOR_DATA static const
-
-STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
-
-#include "fifo_monitor_private.h"
-#else
-#define STORAGE_CLASS_FIFO_MONITOR_DATA const
-
-STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
-#endif /* __INLINE_FIFO_MONITOR__ */
-
-STORAGE_CLASS_FIFO_MONITOR_DATA unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH] = {
-	_REG_GP_SWITCH_IF_ADDR,
-	_REG_GP_SWITCH_DMA_ADDR,
-	_REG_GP_SWITCH_GDC_ADDR};
-
-static bool fifo_monitor_status_valid(
-/* STORAGE_CLASS_INLINE bool fifo_monitor_status_valid ( */
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg,
-	const unsigned int			port_id);
-
-static bool fifo_monitor_status_accept(
-/* STORAGE_CLASS_INLINE bool fifo_monitor_status_accept( */
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg,
-	const unsigned int			port_id);
-
-
-void fifo_channel_get_state(
-	const fifo_monitor_ID_t		ID,
-	const fifo_channel_t		channel_id,
-	fifo_channel_state_t		*state)
-{
-assert(state != NULL);
-assert(channel_id < N_FIFO_CHANNEL);
-	if (state == NULL)
-		return;
-
-	switch (channel_id) {
-	case FIFO_CHANNEL_ISP0_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_SP);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_SP);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_ISP);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_ISP);
-		break;
-	case FIFO_CHANNEL_SP0_TO_ISP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_ISP);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_ISP);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_SP);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_SP);
-		break;
-	case FIFO_CHANNEL_ISP0_TO_IF0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_PIF_A); /* even */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_PIF_A); /* odd */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_PIF_A);
-		break;
-	case FIFO_CHANNEL_IF0_TO_ISP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_PIF_A); /* even */
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_PIF_A); /* odd */
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_PIF_A);
-		break;
-	case FIFO_CHANNEL_ISP0_TO_IF1:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_PIF_B);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_PIF_B);
-		state->fifo_valid  = false; /* no monitor connected */
-		state->sink_accept = false; /* no monitor connected */
-		break;
-	case FIFO_CHANNEL_IF1_TO_ISP0:
-		state->src_valid   = false; /* no monitor connected */
-		state->fifo_accept = false; /* no monitor connected */
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_PIF_B);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_PIF_B);
-		break;
-	case FIFO_CHANNEL_ISP0_TO_DMA0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_DMA);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_DMA);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_DMA);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_DMA);
-		break;
-	case FIFO_CHANNEL_DMA0_TO_ISP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_DMA);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_DMA);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_DMA);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_DMA);
-		break;
-	case FIFO_CHANNEL_ISP0_TO_GDC0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_GDC);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_GDC);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_GDC);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_GDC);
-		break;
-	case FIFO_CHANNEL_GDC0_TO_ISP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_GDC);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_GDC);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_GDC);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_GDC);
-		break;
-	case FIFO_CHANNEL_ISP0_TO_HOST0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_GPD);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_SND_GPD);
-		{
-		hrt_data	value = device_load_uint32(0x10200214UL);
-		state->fifo_valid  = !_hrt_get_bit(value, 0);
-		state->sink_accept = false; /* no monitor connected */
-		}
-		break;
-	case FIFO_CHANNEL_HOST0_TO_ISP0:
-		{
-		hrt_data	value = device_load_uint32(0x1020021CUL);
-		state->fifo_valid  = false; /* no monitor connected */
-		state->sink_accept = !_hrt_get_bit(value, 0);
-		}
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_GPD);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			ISP_STR_MON_PORT_RCV_GPD);
-		break;
-	case FIFO_CHANNEL_SP0_TO_IF0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_PIF_A);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_PIF_A);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_PIF_A);
-		break;
-	case FIFO_CHANNEL_IF0_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_PIF_A);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_PIF_A);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_PIF_A);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_PIF_A);
-		break;
-	case FIFO_CHANNEL_SP0_TO_IF1:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_PIF_B);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_PIF_B);
-		state->fifo_valid  = false; /* no monitor connected */
-		state->sink_accept = false; /* no monitor connected */
-		break;
-	case FIFO_CHANNEL_IF1_TO_SP0:
-		state->src_valid   = false; /* no monitor connected */
-		state->fifo_accept = false; /* no monitor connected */
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_PIF_B);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_PIF_B);
-		break;
-	case FIFO_CHANNEL_SP0_TO_IF2:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_SIF);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_SIF);
-		state->fifo_valid  = false; /* no monitor connected */
-		state->sink_accept = false; /* no monitor connected */
-		break;
-	case FIFO_CHANNEL_IF2_TO_SP0:
-		state->src_valid   = false; /* no monitor connected */
-		state->fifo_accept = false; /* no monitor connected */
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_SIF);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_ISP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_SIF);
-		break;
-	case FIFO_CHANNEL_SP0_TO_DMA0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_DMA);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_DMA);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_DMA);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_DMA);
-		break;
-	case FIFO_CHANNEL_DMA0_TO_SP0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_DMA);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_DMA);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_DMA);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_DMA);
-		break;
-	case FIFO_CHANNEL_SP0_TO_GDC0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_GDC);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_GDC);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_GDC);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_GDC);
-		break;
-	case FIFO_CHANNEL_GDC0_TO_SP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_GDC);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_GDC);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_GDC);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_GDC);
-		break;
-	case FIFO_CHANNEL_SP0_TO_HOST0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_GPD);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_GPD);
-		{
-		hrt_data	value = device_load_uint32(0x10200210UL);
-		state->fifo_valid  = !_hrt_get_bit(value, 0);
-		state->sink_accept = false; /* no monitor connected */
-		}
-		break;
-	case FIFO_CHANNEL_HOST0_TO_SP0:
-		{
-		hrt_data	value = device_load_uint32(0x10200218UL);
-		state->fifo_valid  = false; /* no monitor connected */
-		state->sink_accept = !_hrt_get_bit(value, 0);
-		}
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_GPD);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_GPD);
-		break;
-	case FIFO_CHANNEL_SP0_TO_STREAM2MEM0:
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_MC);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_SND_MC);
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_MC);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_RCV_MC);
-		break;
-	case FIFO_CHANNEL_STREAM2MEM0_TO_SP0:
-		state->fifo_valid  = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_MC);
-		state->sink_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_MOD_STREAM_STAT_IDX,
-			MOD_STR_MON_PORT_SND_MC);
-		state->src_valid   = fifo_monitor_status_valid(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_MC);
-		state->fifo_accept = fifo_monitor_status_accept(ID,
-			HIVE_GP_REGS_SP_STREAM_STAT_IDX,
-			SP_STR_MON_PORT_RCV_MC);
-		break;
-	default:
-assert(0);
-		break;
-	}
-
-return;
-}
-
-void fifo_switch_get_state(
-	const fifo_monitor_ID_t		ID,
-	const fifo_switch_t			switch_id,
-	fifo_switch_state_t			*state)
-{
-	hrt_data	data = (hrt_data)-1;
-
-assert(state != NULL);
-assert(switch_id < N_FIFO_SWITCH);
-assert(ID == FIFO_MONITOR0_ID);
-	if (state == NULL)
-		return;
-
-(void)ID;
-
-	data = gp_device_reg_load(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id]);
-
-	state->is_none = (data == HIVE_ISP_CSS_STREAM_SWITCH_NONE);
-	state->is_sp = (data == HIVE_ISP_CSS_STREAM_SWITCH_SP);
-	state->is_isp = (data == HIVE_ISP_CSS_STREAM_SWITCH_ISP);
-
-return;
-}
-
-void fifo_monitor_get_state(
-	const fifo_monitor_ID_t		ID,
-	fifo_monitor_state_t		*state)
-{
-	fifo_channel_t	ch_id;
-	fifo_switch_t	sw_id;
-
-assert(state != NULL);
-assert(ID < N_FIFO_MONITOR_ID);
-
-	for (ch_id = 0; ch_id < N_FIFO_CHANNEL; ch_id++) /* { */
-		fifo_channel_get_state(ID, ch_id,
-			&(state->fifo_channels[ch_id]));
-	/* } */
-
-	for (sw_id = 0; sw_id < N_FIFO_SWITCH; sw_id++) /* { */
-		fifo_switch_get_state(ID, sw_id,
-			&(state->fifo_switches[sw_id]));
-	/* } */
-return;
-}
-
-static bool fifo_monitor_status_valid(
-/* STORAGE_CLASS_INLINE bool fifo_monitor_status_valid ( */
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg,
-	const unsigned int			port_id)
-{
-hrt_data	data = fifo_monitor_reg_load(ID, reg);
-return (data >> (((port_id * 2) + _hive_str_mon_valid_offset))) & 0x1;
-}
-
-static bool fifo_monitor_status_accept(
-/* STORAGE_CLASS_INLINE bool fifo_monitor_status_accept( */
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg,
-	const unsigned int			port_id)
-{
-hrt_data	data = fifo_monitor_reg_load(ID, reg);
-return (data >> (((port_id * 2) + _hive_str_mon_accept_offset))) & 0x1;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_local.h
deleted file mode 100644
index 9f438a9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_local.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __FIFO_MONITOR_LOCAL_H_INCLUDED__
-#define __FIFO_MONITOR_LOCAL_H_INCLUDED__
-
-#include <stdbool.h>
-
-#include "fifo_monitor_global.h"
-
-#include <hive_isp_css_streaming_monitors_types_hrt.h>
-
-#define HIVE_GP_REGS_SP_STREAM_STAT_IDX		HIVE_GP_REGS_SP_STREAM_STAT
-#define HIVE_GP_REGS_ISP_STREAM_STAT_IDX	HIVE_GP_REGS_ISP_STREAM_STAT
-#define HIVE_GP_REGS_MOD_STREAM_STAT_IDX	HIVE_GP_REGS_MOD_STREAM_STAT
-
-#define	FIFO_CHANNEL_SP_VALID_MASK	0x55555555
-#define	FIFO_CHANNEL_ISP_VALID_MASK	0x00555555
-#define	FIFO_CHANNEL_MOD_VALID_MASK	0x00055555
-
-typedef enum {
-	FIFO_SWITCH_IF,
-	FIFO_SWITCH_DMA,
-	FIFO_SWITCH_GDC,
-	N_FIFO_SWITCH
-} fifo_switch_t;
-
-typedef enum {
-	FIFO_CHANNEL_ISP0_TO_SP0,
-	FIFO_CHANNEL_SP0_TO_ISP0,
-	FIFO_CHANNEL_ISP0_TO_IF0,
-	FIFO_CHANNEL_IF0_TO_ISP0,
-	FIFO_CHANNEL_ISP0_TO_IF1,
-	FIFO_CHANNEL_IF1_TO_ISP0,
-	FIFO_CHANNEL_ISP0_TO_DMA0,
-	FIFO_CHANNEL_DMA0_TO_ISP0,
-	FIFO_CHANNEL_ISP0_TO_GDC0,
-	FIFO_CHANNEL_GDC0_TO_ISP0,
-	FIFO_CHANNEL_ISP0_TO_HOST0,
-	FIFO_CHANNEL_HOST0_TO_ISP0,
-	FIFO_CHANNEL_SP0_TO_IF0,
-	FIFO_CHANNEL_IF0_TO_SP0,
-	FIFO_CHANNEL_SP0_TO_IF1,
-	FIFO_CHANNEL_IF1_TO_SP0,
-	FIFO_CHANNEL_SP0_TO_IF2,
-	FIFO_CHANNEL_IF2_TO_SP0,
-	FIFO_CHANNEL_SP0_TO_DMA0,
-	FIFO_CHANNEL_DMA0_TO_SP0,
-	FIFO_CHANNEL_SP0_TO_GDC0,
-	FIFO_CHANNEL_GDC0_TO_SP0,
-	FIFO_CHANNEL_SP0_TO_HOST0,
-	FIFO_CHANNEL_HOST0_TO_SP0,
-	FIFO_CHANNEL_SP0_TO_STREAM2MEM0,
-	FIFO_CHANNEL_STREAM2MEM0_TO_SP0,
-	N_FIFO_CHANNEL
-} fifo_channel_t;
-
-struct fifo_channel_state_s {
-	bool	src_valid;
-	bool	fifo_accept;
-	bool	fifo_valid;
-	bool	sink_accept;
-};
-
-/* The switch is tri-state */
-struct fifo_switch_state_s {
-	bool	is_none;
-	bool	is_isp;
-	bool	is_sp;
-};
-
-struct fifo_monitor_state_s {
-	struct fifo_channel_state_s	fifo_channels[N_FIFO_CHANNEL];
-	struct fifo_switch_state_s	fifo_switches[N_FIFO_SWITCH];
-};
-
-#endif /* __FIFO_MONITOR_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_private.h
deleted file mode 100644
index d454d4b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/fifo_monitor_private.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __FIFO_MONITOR_PRIVATE_H_INCLUDED__
-#define __FIFO_MONITOR_PRIVATE_H_INCLUDED__
-
-#include "fifo_monitor_public.h"
-
-#define __INLINE_GP_DEVICE__
-#include "gp_device.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-#ifdef __INLINE_FIFO_MONITOR__
-extern const unsigned int FIFO_SWITCH_ADDR[N_FIFO_SWITCH];
-#endif
-
-STORAGE_CLASS_FIFO_MONITOR_C void fifo_switch_set(
-	const fifo_monitor_ID_t		ID,
-	const fifo_switch_t			switch_id,
-	const hrt_data				sel)
-{
-assert(ID == FIFO_MONITOR0_ID);
-assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
-assert(switch_id < N_FIFO_SWITCH);
-
-	gp_device_reg_store(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id], sel);
-
-return;
-}
-
-STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_switch_get(
-	const fifo_monitor_ID_t		ID,
-	const fifo_switch_t			switch_id)
-{
-assert(ID == FIFO_MONITOR0_ID);
-assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
-assert(switch_id < N_FIFO_SWITCH);
-
-return gp_device_reg_load(GP_DEVICE0_ID, FIFO_SWITCH_ADDR[switch_id]);
-}
-
-
-STORAGE_CLASS_FIFO_MONITOR_C void fifo_monitor_reg_store(
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg,
-	const hrt_data				value)
-{
-assert(ID < N_FIFO_MONITOR_ID);
-assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(FIFO_MONITOR_BASE[ID] +
-		reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_FIFO_MONITOR_C hrt_data fifo_monitor_reg_load(
-	const fifo_monitor_ID_t		ID,
-	const unsigned int			reg)
-{
-assert(ID < N_FIFO_MONITOR_ID);
-assert(FIFO_MONITOR_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(FIFO_MONITOR_BASE[ID] +
-		reg*sizeof(hrt_data));
-}
-
-#endif /* __FIFO_MONITOR_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc.c
deleted file mode 100644
index 13c137e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-/* The name "gdc.h is already taken" */
-#include "gdc_device.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-/*
- * Local function declarations
- *
- * NOTE: Linux checkpatch cannot handle the storage class
- * macro "STORAGE_CLASS_INLINE" that is used to hide
- * compiler specific "inline" specifiers. To maintain
- * portability do not force inline.
- */
-/*STORAGE_CLASS_INLINE void gdc_reg_store(*/
-static void gdc_reg_store(
-	const gdc_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value);
-
-/*
- * The compiler complains that "warning: 'gdc_reg_load' defined but not used",
- * which treats warnings as errors. So 'gdc_reg_load' is disabled. Enable it
- * as soon as it is used.
- */
-#if 0
-/*STORAGE_CLASS_INLINE hrt_data gdc_reg_load(*/
-static hrt_data gdc_reg_load(
-	const gdc_ID_t		ID,
-	const unsigned int	reg);
-#endif
-
-#ifndef __INLINE_GDC__
-#include "gdc_private.h"
-#endif /* __INLINE_GDC__ */
-
-/*
- * Exported function implementations
- */
-void gdc_lut_store(
-	const gdc_ID_t		ID,
-	const int			data[4][HRT_GDC_N])
-{
-	unsigned int i, lut_offset = HRT_GDC_LUT_IDX;
-
-assert(ID < N_GDC_ID);
-assert(HRT_GDC_BCI_COEF_BITS <= (4*sizeof(hrt_data)));
-
-	for (i = 0; i < HRT_GDC_N; i++) {
-		hrt_data	entry_0 = data[0][i] & HRT_GDC_BCI_COEF_MASK;
-		hrt_data	entry_1 = data[1][i] & HRT_GDC_BCI_COEF_MASK;
-		hrt_data	entry_2 = data[2][i] & HRT_GDC_BCI_COEF_MASK;
-		hrt_data	entry_3 = data[3][i] & HRT_GDC_BCI_COEF_MASK;
-
-		hrt_data	word_0 = entry_0 |
-			(entry_1 << HRT_GDC_BCI_COEF_BITS);
-		hrt_data	word_1 = entry_2 |
-			(entry_3 << HRT_GDC_BCI_COEF_BITS);
-
-		gdc_reg_store(ID, lut_offset++, word_0);
-		gdc_reg_store(ID, lut_offset++, word_1);
-	}
-return;
-}
-
-int gdc_get_unity(
-	const gdc_ID_t		ID)
-{
-assert(ID < N_GDC_ID);
-	(void)ID;
-return (int)HRT_GDC_COORD_ONE;
-}
-
-
-/*
- * Local function implementations
- */
-/*STORAGE_CLASS_INLINE void gdc_reg_store( */
-static void gdc_reg_store(
-	const gdc_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value)
-{
-	device_store_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-/*
- * The compiler complains that "warning: 'gdc_reg_load' defined but not used",
- * which treats warnings as errors. So 'gdc_reg_load' is disabled. Enable it
- * as soon as it is used.
- */
-#if 0
-/*STORAGE_CLASS_INLINE hrt_data gdc_reg_load(*/
-static hrt_data gdc_reg_load(
-	const gdc_ID_t		ID,
-	const unsigned int	reg)
-{
-return device_load_uint32(GDC_BASE[ID] + reg*sizeof(hrt_data));
-}
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_local.h
deleted file mode 100644
index d5e8da0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_local.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GDC_LOCAL_H_INCLUDED__
-#define __GDC_LOCAL_H_INCLUDED__
-
-#include "gdc_global.h"
-
-#endif /* __GDC_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_private.h
deleted file mode 100644
index 2d2e4aa..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gdc_private.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GDC_PRIVATE_H_INCLUDED__
-#define __GDC_PRIVATE_H_INCLUDED__
-
-#include "gdc_public.h"
-
-#endif /* __GDC_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device.c
deleted file mode 100644
index 6d452d3..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device.c
+++ /dev/null
@@ -1,113 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "gp_device.h"
-
-#ifndef __INLINE_GP_DEVICE__
-#include "gp_device_private.h"
-#endif /* __INLINE_GP_DEVICE__ */
-
-void gp_device_get_state(
-	const gp_device_ID_t		ID,
-	gp_device_state_t			*state)
-{
-assert(ID < N_GP_DEVICE_ID);
-assert(state != NULL);
-	if (state == NULL)
-		return;
-
-	state->switch_if = gp_device_reg_load(ID,
-		_REG_GP_SWITCH_IF_ADDR);
-	state->switch_dma = gp_device_reg_load(ID,
-		_REG_GP_SWITCH_DMA_ADDR);
-	state->switch_gdc = gp_device_reg_load(ID,
-		_REG_GP_SWITCH_GDC_ADDR);
-	state->syngen_enable = gp_device_reg_load(ID,
-		_REG_GP_SYNGEN_ENABLE_ADDR);
-	state->syngen_nr_pix = gp_device_reg_load(ID,
-		_REG_GP_SYNGEN_NR_PIX_ADDR);
-	state->syngen_nr_lines = gp_device_reg_load(ID,
-		_REG_GP_SYNGEN_NR_LINES_ADDR);
-	state->syngen_hblank_cycles = gp_device_reg_load(ID,
-		_REG_GP_SYNGEN_HBLANK_CYCLES_ADDR);
-	state->syngen_vblank_cycles = gp_device_reg_load(ID,
-		_REG_GP_SYNGEN_VBLANK_CYCLES_ADDR);
-	state->isel_sof = gp_device_reg_load(ID,
-		_REG_GP_ISEL_SOF_ADDR);
-	state->isel_eof = gp_device_reg_load(ID,
-		_REG_GP_ISEL_EOF_ADDR);
-	state->isel_sol = gp_device_reg_load(ID,
-		_REG_GP_ISEL_SOL_ADDR);
-	state->isel_eol = gp_device_reg_load(ID,
-		_REG_GP_ISEL_EOL_ADDR);
-	state->isel_lfsr_enable = gp_device_reg_load(ID,
-		_REG_GP_ISEL_LFSR_ENABLE_ADDR);
-	state->isel_lfsr_enable_b = gp_device_reg_load(ID,
-		_REG_GP_ISEL_LFSR_ENABLE_B_ADDR);
-	state->isel_lfsr_reset_value = gp_device_reg_load(ID,
-		_REG_GP_ISEL_LFSR_RESET_VALUE_ADDR);
-	state->isel_tpg_enable = gp_device_reg_load(ID,
-		_REG_GP_ISEL_TPG_ENABLE_ADDR);
-	state->isel_tpg_enable_b = gp_device_reg_load(ID,
-		_REG_GP_ISEL_TPG_ENABLE_B_ADDR);
-	state->isel_hor_cnt_mask = gp_device_reg_load(ID,
-		_REG_GP_ISEL_HOR_CNT_MASK_ADDR);
-	state->isel_ver_cnt_mask = gp_device_reg_load(ID,
-		_REG_GP_ISEL_VER_CNT_MASK_ADDR);
-	state->isel_xy_cnt_mask = gp_device_reg_load(ID,
-		_REG_GP_ISEL_XY_CNT_MASK_ADDR);
-	state->isel_hor_cnt_delta = gp_device_reg_load(ID,
-		_REG_GP_ISEL_HOR_CNT_DELTA_ADDR);
-	state->isel_ver_cnt_delta = gp_device_reg_load(ID,
-		_REG_GP_ISEL_VER_CNT_DELTA_ADDR);
-	state->isel_ch_id = gp_device_reg_load(ID,
-		_REG_GP_ISEL_CH_ID_ADDR);
-	state->isel_fmt_type = gp_device_reg_load(ID,
-		_REG_GP_ISEL_FMT_TYPE_ADDR);
-	state->isel_data_sel = gp_device_reg_load(ID,
-		_REG_GP_ISEL_DATA_SEL_ADDR);
-	state->isel_sband_sel = gp_device_reg_load(ID,
-		_REG_GP_ISEL_SBAND_SEL_ADDR);
-	state->isel_sync_sel = gp_device_reg_load(ID,
-		_REG_GP_ISEL_SYNC_SEL_ADDR);
-	state->inp_swi_lut_reg_0 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_0_ADDR);
-	state->inp_swi_lut_reg_1 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_1_ADDR);
-	state->inp_swi_lut_reg_2 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_2_ADDR);
-	state->inp_swi_lut_reg_3 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_3_ADDR);
-	state->inp_swi_lut_reg_4 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_4_ADDR);
-	state->inp_swi_lut_reg_5 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_5_ADDR);
-	state->inp_swi_lut_reg_6 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_6_ADDR);
-	state->inp_swi_lut_reg_7 = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_LUT_REG_7_ADDR);
-	state->inp_swi_fsync_lut_reg = gp_device_reg_load(ID,
-		_REG_GP_INP_SWI_FSYNC_LUT_REG_ADDR);
-	state->sdram_wakeup = gp_device_reg_load(ID,
-		_REG_GP_SDRAM_WAKEUP_ADDR);
-	state->idle = gp_device_reg_load(ID,
-		_REG_GP_IDLE_ADDR);
-	state->irq_request = gp_device_reg_load(ID,
-		_REG_GP_IRQ_REQUEST_ADDR);
-	state->mipi_dword_full = gp_device_reg_load(ID,
-		_REG_GP_MIPI_DWORD_FULL_ADDR);
-	state->mipi_used_dword = gp_device_reg_load(ID,
-		_REG_GP_MIPI_USED_DWORD_ADDR);
-return;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_local.h
deleted file mode 100644
index 130e9d2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_local.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GP_DEVICE_LOCAL_H_INCLUDED__
-#define __GP_DEVICE_LOCAL_H_INCLUDED__
-
-#include "gp_device_global.h"
-/*
-#define _REG_GP_SWITCH_IF_ADDR				0x00
-#define _REG_GP_SWITCH_DMA_ADDR				0x04
-#define _REG_GP_SWITCH_GDC_ADDR				0x08
-*/
-/*
-#define _REG_GP_SYNGEN_ENABLE_ADDR			0x0C
-#define _REG_GP_SYNGEN_NR_PIX_ADDR			0x10
-#define _REG_GP_SYNGEN_NR_LINES_ADDR		0x14
-#define _REG_GP_SYNGEN_HBLANK_CYCLES_ADDR	0x18
-#define _REG_GP_SYNGEN_VBLANK_CYCLES_ADDR	0x1C
-#define _REG_GP_ISEL_SOF_ADDR				0x20
-#define _REG_GP_ISEL_EOF_ADDR				0x24
-#define _REG_GP_ISEL_SOL_ADDR				0x28
-#define _REG_GP_ISEL_EOL_ADDR				0x2C
-#define _REG_GP_ISEL_LFSR_ENABLE_ADDR		0x30
-#define _REG_GP_ISEL_LFSR_ENABLE_B_ADDR		0x34
-#define _REG_GP_ISEL_LFSR_RESET_VALUE_ADDR	0x38
-#define _REG_GP_ISEL_TPG_ENABLE_ADDR		0x3C
-#define _REG_GP_ISEL_TPG_ENABLE_B_ADDR		0x40
-#define _REG_GP_ISEL_HOR_CNT_MASK_ADDR		0x44
-#define _REG_GP_ISEL_VER_CNT_MASK_ADDR		0x48
-#define _REG_GP_ISEL_XY_CNT_MASK_ADDR		0x4C
-#define _REG_GP_ISEL_HOR_CNT_DELTA_ADDR		0x50
-#define _REG_GP_ISEL_VER_CNT_DELTA_ADDR		0x54
-#define _REG_GP_ISEL_CH_ID_ADDR				0x58
-#define _REG_GP_ISEL_FMT_TYPE_ADDR			0x5C
-#define _REG_GP_ISEL_DATA_SEL_ADDR			0x60
-#define _REG_GP_ISEL_SBAND_SEL_ADDR			0x64
-#define _REG_GP_ISEL_SYNC_SEL_ADDR			0x68
-#define _REG_GP_INP_SWI_LUT_REG_0_ADDR		0x6C
-#define _REG_GP_INP_SWI_LUT_REG_1_ADDR		0x70
-#define _REG_GP_INP_SWI_LUT_REG_2_ADDR		0x74
-#define _REG_GP_INP_SWI_LUT_REG_3_ADDR		0x78
-#define _REG_GP_INP_SWI_LUT_REG_4_ADDR		0x7C
-#define _REG_GP_INP_SWI_LUT_REG_5_ADDR		0x80
-#define _REG_GP_INP_SWI_LUT_REG_6_ADDR		0x84
-#define _REG_GP_INP_SWI_LUT_REG_7_ADDR		0x88
-#define _REG_GP_INP_SWI_FSYNC_LUT_REG_ADDR	0x8C
-#define _REG_GP_SDRAM_WAKEUP_ADDR			0x90
-#define _REG_GP_IDLE_ADDR					0x94
-*/
-/* #define _REG_GP_IRQ_REQUEST_ADDR			0x98 */
-#define _REG_GP_MIPI_DWORD_FULL_ADDR		0x9C
-/* #define _REG_GP_MIPI_USED_DWORD_ADDR		0xA0 */
-
-struct gp_device_state_s {
-	int switch_if;
-	int switch_dma;
-	int switch_gdc;
-	int syngen_enable;
-	int syngen_nr_pix;
-	int syngen_nr_lines;
-	int syngen_hblank_cycles;
-	int syngen_vblank_cycles;
-	int isel_sof;
-	int isel_eof;
-	int isel_sol;
-	int isel_eol;
-	int isel_lfsr_enable;
-	int isel_lfsr_enable_b;
-	int isel_lfsr_reset_value;
-	int isel_tpg_enable;
-	int isel_tpg_enable_b;
-	int isel_hor_cnt_mask;
-	int isel_ver_cnt_mask;
-	int isel_xy_cnt_mask;
-	int isel_hor_cnt_delta;
-	int isel_ver_cnt_delta;
-	int isel_ch_id;
-	int isel_fmt_type;
-	int isel_data_sel;
-	int isel_sband_sel;
-	int isel_sync_sel;
-	int inp_swi_lut_reg_0;
-	int inp_swi_lut_reg_1;
-	int inp_swi_lut_reg_2;
-	int inp_swi_lut_reg_3;
-	int inp_swi_lut_reg_4;
-	int inp_swi_lut_reg_5;
-	int inp_swi_lut_reg_6;
-	int inp_swi_lut_reg_7;
-	int inp_swi_fsync_lut_reg;
-	int sdram_wakeup;
-	int idle;
-	int irq_request;
-	int mipi_dword_full;
-	int mipi_used_dword;
-};
-
-#endif /* __GP_DEVICE_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_private.h
deleted file mode 100644
index f34f690..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gp_device_private.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GP_DEVICE_PRIVATE_H_INCLUDED__
-#define __GP_DEVICE_PRIVATE_H_INCLUDED__
-
-#include "gp_device_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_GP_DEVICE_C void gp_device_reg_store(
-	const gp_device_ID_t	ID,
-	const unsigned int		reg_addr,
-	const hrt_data			value)
-{
-assert(ID < N_GP_DEVICE_ID);
-assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
-assert((reg_addr % sizeof(hrt_data)) == 0);
-	device_store_uint32(GP_DEVICE_BASE[ID] + reg_addr, value);
-return;
-}
-
-STORAGE_CLASS_GP_DEVICE_C hrt_data gp_device_reg_load(
-	const gp_device_ID_t	ID,
-	const unsigned int		reg_addr)
-{
-assert(ID < N_GP_DEVICE_ID);
-assert(GP_DEVICE_BASE[ID] != (hrt_address)-1);
-assert((reg_addr % sizeof(hrt_data)) == 0);
-return device_load_uint32(GP_DEVICE_BASE[ID] + reg_addr);
-}
-
-#endif /* __GP_DEVICE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_local.h
deleted file mode 100644
index 3832301..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_local.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GPIO_LOCAL_H_INCLUDED__
-#define __GPIO_LOCAL_H_INCLUDED__
-
-#include "gpio_global.h"
-
-#endif /* __GPIO_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_private.h
deleted file mode 100644
index 1eefad8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/gpio_private.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __GPIO_PRIVATE_H_INCLUDED__
-#define __GPIO_PRIVATE_H_INCLUDED__
-
-#include "gpio_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_GPIO_C void gpio_reg_store(
-	const gpio_ID_t	ID,
-	const unsigned int		reg,
-	const hrt_data			value)
-{
-OP___assert(ID < N_GPIO_ID);
-OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(GPIO_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_GPIO_C hrt_data gpio_reg_load(
-	const gpio_ID_t	ID,
-	const unsigned int		reg)
-{
-OP___assert(ID < N_GPIO_ID);
-OP___assert(GPIO_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(GPIO_BASE[ID] + reg*sizeof(hrt_data));
-}
-
-#endif /* __GPIO_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/hive_isp_css_hrt_modified.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/hive_isp_css_hrt_modified.h
deleted file mode 100644
index d40f7db..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/hive_isp_css_hrt_modified.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef _hive_isp_css_hrt_h
-#define _hive_isp_css_hrt_h
-
-#include "hive_isp_css_host_ids_hrt.h"
-
-#ifdef HRT_ISP_CSS_CUSTOM_HOST
-#ifndef HRT_USE_VIR_ADDRS
-#define HRT_USE_VIR_ADDRS
-#endif
-/*#include "hive_isp_css_custom_host_hrt.h"*/
-#endif
-
-#include <timed_controller.h>
-#include <gpio_block.h>
-#include <gp_regs.h>
-#ifdef _HIVE_ISP_CSS_FPGA_SYSTEM
-#include <i2c_api.h> // specific for css_dev, not used in ghanius
-#include <dis_sensor.h>
-#include <display_driver.h>
-#include <display.h>
-#include <display_driver.h>
-#include <shi_sensor_api.h>
-#ifdef _HIVE_ISP_CSS_PI_SYSTEM
-#include <isp2300_medfield_demo_pi_params.h>
-#else
-#include <isp2300_medfield_demo_params.h>
-#endif
-#include <isp2300_support.h>
-#include "isp_css_dev_flash_hrt.h"
-#include "isp_css_dev_display_hrt.h"
-#include "isp_css_dev_i2c_hrt.h"
-#ifdef _HIVE_ISP_CSS_FPGA_MIPI_SYSTEM
-#include "isp_css_mipi_tb.h"
-#include <css_receiver_ahb_hrt.h>
-#elif defined _HIVE_ISP_CSS_PI_SYSTEM
-#include "hive_isp_css_pi_system.h"
-#else
-#include "isp_css_dev_tb.h"
-#endif
-#else
-#include <css_receiver_ahb_hrt.h>
-#ifdef _HIVE_ISP_CSS_2310_SYSTEM
-#include <isp2310_medfield_params.h>
-#include <isp2310_support.h>
-#else
-#include <isp2300_medfield_params.h>
-#include <isp2300_support.h>
-#endif
-/* insert idle signal clearing and setting around hrt_main */
-#if !defined(HRT_HW) || defined(HRT_ISP_CSS_INSERT_IDLE_SIGNAL)
-#define hrt_main _hrt_isp_css_main
-#endif
-#ifdef _HIVE_ISP_CSS_2310_SYSTEM
-#include "hive_isp_css_system_2310.h"
-#else
-#include "hive_isp_css_system.h"
-#endif
-#endif
-#include <sp_hrt.h>
-#include <stream2memory.h>
-#include <sig_monitor_hrt.h>
-#include <test_pat_gen.h>
-
-#include "hive_isp_css_defs.h"
-#include "hive_isp_css_stream_switch_hrt.h"
-#include "hive_isp_css_input_selector_hrt.h"
-#include "hive_isp_css_input_switch_hrt.h"
-#include "hive_isp_css_sync_gen_hrt.h"
-#include "hive_isp_css_prbs_hrt.h"
-#include "hive_isp_css_tpg_hrt.h"
-#include "hive_isp_css_sdram_wakeup_hrt.h"
-#include "hive_isp_css_idle_signal_hrt.h"
-#include "hive_isp_css_sp_hrt.h"
-#include "hive_isp_css_isp_hrt.h"
-#include "hive_isp_css_ddr_hrt.h"
-#include "hive_isp_css_streaming_to_mipi_hrt.h"
-#include "hive_isp_css_testbench_hrt.h"
-#include "hive_isp_css_streaming_monitors_hrt.h"
-#include "hive_isp_css_dma_set_hrt.h"
-#include "hive_isp_css_gp_regs_hrt.h"
-
-#endif /* _hive_isp_css_hrt_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter.c
deleted file mode 100644
index e9a998c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include <stddef.h>		/* NULL */
-
-#include "input_formatter.h"
-
-#include "assert_support.h"
-
-#ifndef __INLINE_INPUT_FORMATTER__
-#include "input_formatter_private.h"
-#endif /* __INLINE_INPUT_FORMATTER__ */
-
-void input_formatter_rst(
-	const input_formatter_ID_t		ID)
-{
-assert(ID < N_INPUT_FORMATTER_ID);
-	input_formatter_reg_store(ID,
-		HIVE_IF_RESET_ADDRESS, 1);
-return;
-}
-
-unsigned int input_formatter_get_alignment(
-	const input_formatter_ID_t		ID)
-{
-assert(ID < N_INPUT_FORMATTER_ID);
-
-return input_formatter_alignment[ID];
-}
-
-void input_formatter_set_fifo_blocking_mode(
-	const input_formatter_ID_t		ID,
-	const bool						enable)
-{
-assert(ID < N_INPUT_FORMATTER_ID);
-	input_formatter_reg_store(ID,
-		 HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS, enable);
-return;
-}
-
-void input_formatter_get_state(
-	const input_formatter_ID_t		ID,
-	input_formatter_state_t			*state)
-{
-assert(ID < N_INPUT_FORMATTER_ID);
-assert(state != NULL);
-	if (state == NULL)
-		return;
-
-	state->reset = input_formatter_reg_load(ID,
-		HIVE_IF_RESET_ADDRESS);
-	state->start_line = input_formatter_reg_load(ID,
-		HIVE_IF_START_LINE_ADDRESS);
-	state->start_column = input_formatter_reg_load(ID,
-		HIVE_IF_START_COLUMN_ADDRESS);
-	state->cropped_height = input_formatter_reg_load(ID,
-		HIVE_IF_CROPPED_HEIGHT_ADDRESS);
-	state->cropped_width = input_formatter_reg_load(ID,
-		HIVE_IF_CROPPED_WIDTH_ADDRESS);
-	state->ver_decimation = input_formatter_reg_load(ID,
-		HIVE_IF_VERTICAL_DECIMATION_ADDRESS);
-	state->hor_decimation = input_formatter_reg_load(ID,
-		HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS);
-	state->deinterleaving = input_formatter_reg_load(ID,
-		HIVE_IF_H_DEINTERLEAVING_ADDRESS);
-	state->left_padding = input_formatter_reg_load(ID,
-		HIVE_IF_LEFTPADDING_WIDTH_ADDRESS);
-	state->eol_offset = input_formatter_reg_load(ID,
-		HIVE_IF_END_OF_LINE_OFFSET_ADDRESS);
-	state->vmem_start_address = input_formatter_reg_load(ID,
-		HIVE_IF_VMEM_START_ADDRESS_ADDRESS);
-	state->vmem_end_address = input_formatter_reg_load(ID,
-		HIVE_IF_VMEM_END_ADDRESS_ADDRESS);
-	state->vmem_increment = input_formatter_reg_load(ID,
-		HIVE_IF_VMEM_INCREMENT_ADDRESS);
-	state->is_yuv420 = input_formatter_reg_load(ID,
-		HIVE_IF_YUV_420_FORMAT_ADDRESS);
-	state->vsync_active_low = input_formatter_reg_load(ID,
-		HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS);
-	state->hsync_active_low = input_formatter_reg_load(ID,
-		HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS);
-	state->allow_fifo_overflow = input_formatter_reg_load(ID,
-		HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS);
-	state->fsm_sync_status = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_SYNC_STATUS);
-	state->fsm_sync_counter = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_SYNC_COUNTER);
-	state->fsm_crop_status = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_CROP_STATUS);
-	state->fsm_crop_line_counter = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_CROP_LINE_COUNTER);
-	state->fsm_crop_pixel_counter = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_CROP_PIXEL_COUNTER);
-	state->fsm_deinterleaving_index = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_DEINTERLEAVING_IDX);
-	state->fsm_dec_h_counter = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_DECIMATION_H_COUNTER);
-	state->fsm_dec_v_counter = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_DECIMATION_V_COUNTER);
-	state->fsm_dec_block_v_counter = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER);
-	state->fsm_padding_status = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_PADDING_STATUS);
-	state->fsm_padding_elem_counter = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_PADDING_ELEMENT_COUNTER);
-	state->fsm_vector_support_error = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_VECTOR_SUPPORT_ERROR);
-	state->fsm_vector_buffer_full = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL);
-	state->vector_support = input_formatter_reg_load(ID,
-		HIVE_IF_FSM_VECTOR_SUPPORT);
-	state->sensor_data_lost = input_formatter_reg_load(ID,
-		HIVE_IF_FIFO_SENSOR_STATUS);
-
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_local.h
deleted file mode 100644
index e2fb50a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_local.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_FORMATTER_LOCAL_H_INCLUDED__
-#define __INPUT_FORMATTER_LOCAL_H_INCLUDED__
-
-#include "input_formatter_global.h"
-
-#include "isp.h"		/* ISP_VEC_ALIGN */
-
-typedef struct input_formatter_state_s		input_formatter_state_t;
-
-#define HIVE_IF_FSM_SYNC_STATUS                 0x100
-#define HIVE_IF_FSM_SYNC_COUNTER                0x104
-#define HIVE_IF_FSM_CROP_STATUS                 0x108
-#define HIVE_IF_FSM_CROP_LINE_COUNTER           0x10C
-#define HIVE_IF_FSM_CROP_PIXEL_COUNTER          0x110
-#define HIVE_IF_FSM_DEINTERLEAVING_IDX          0x114
-#define HIVE_IF_FSM_DECIMATION_H_COUNTER        0x118
-#define HIVE_IF_FSM_DECIMATION_V_COUNTER        0x11C
-#define HIVE_IF_FSM_DECIMATION_BLOCK_V_COUNTER  0x120
-#define HIVE_IF_FSM_PADDING_STATUS              0x124
-#define HIVE_IF_FSM_PADDING_ELEMENT_COUNTER     0x128
-#define HIVE_IF_FSM_VECTOR_SUPPORT_ERROR        0x12C
-#define HIVE_IF_FSM_VECTOR_SUPPORT_BUFF_FULL    0x130
-#define HIVE_IF_FSM_VECTOR_SUPPORT              0x134
-#define HIVE_IF_FIFO_SENSOR_STATUS              0x138
-
-struct input_formatter_state_s {
-	int	reset;
-	int	start_line;
-	int	start_column;
-	int	cropped_height;
-	int	cropped_width;
-	int	ver_decimation;
-	int	hor_decimation;
-	int	deinterleaving;
-	int	left_padding;
-	int	eol_offset;
-	int	vmem_start_address;
-	int	vmem_end_address;
-	int	vmem_increment;
-	int	is_yuv420;
-	int	vsync_active_low;
-	int	hsync_active_low;
-	int	allow_fifo_overflow;
-	int	fsm_sync_status;
-	int	fsm_sync_counter;
-	int	fsm_crop_status;
-	int	fsm_crop_line_counter;
-	int	fsm_crop_pixel_counter;
-	int	fsm_deinterleaving_index;
-	int	fsm_dec_h_counter;
-	int	fsm_dec_v_counter;
-	int	fsm_dec_block_v_counter;
-	int	fsm_padding_status;
-	int	fsm_padding_elem_counter;
-	int	fsm_vector_support_error;
-	int	fsm_vector_buffer_full;
-	int	vector_support;
-	int	sensor_data_lost;
-};
-
-static const unsigned int input_formatter_alignment[N_INPUT_FORMATTER_ID] = {
-	ISP_VEC_ALIGN, ISP_VEC_ALIGN};
-
-#endif /* __INPUT_FORMATTER_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_private.h
deleted file mode 100644
index 7703ea4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_formatter_private.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_FORMATTER_PRIVATE_H_INCLUDED__
-#define __INPUT_FORMATTER_PRIVATE_H_INCLUDED__
-
-#include "input_formatter_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_INPUT_FORMATTER_C void input_formatter_reg_store(
-	const input_formatter_ID_t	ID,
-	const unsigned int			reg_addr,
-	const hrt_data				value)
-{
-assert(ID < N_INPUT_FORMATTER_ID);
-assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
-assert((reg_addr % sizeof(hrt_data)) == 0);
-	device_store_uint32(INPUT_FORMATTER_BASE[ID] + reg_addr, value);
-return;
-}
-
-STORAGE_CLASS_INPUT_FORMATTER_C hrt_data input_formatter_reg_load(
-	const input_formatter_ID_t	ID,
-	const unsigned int			reg_addr)
-{
-assert(ID < N_INPUT_FORMATTER_ID);
-assert(INPUT_FORMATTER_BASE[ID] != (hrt_address)-1);
-assert((reg_addr % sizeof(hrt_data)) == 0);
-return device_load_uint32(INPUT_FORMATTER_BASE[ID] + reg_addr);
-}
-
-#endif /* __INPUT_FORMATTER_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system.c
deleted file mode 100644
index 2588abe..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system.c
+++ /dev/null
@@ -1,198 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include "stddef.h"		/* NULL */
-#include "stdint.h"
-
-#include "input_system.h"
-
-#include "assert_support.h"
-
-#ifndef __INLINE_INPUT_SYSTEM__
-#include "input_system_private.h"
-#endif /* __INLINE_INPUT_SYSTEM__ */
-
-static uint8_t	mipi_compressed_bits[N_MIPI_COMPRESSOR_METHODS] = {
-	0, 6, 7, 8, 6, 7, 8};
-
-static uint8_t	mipi_uncompressed_bits[N_MIPI_COMPRESSOR_METHODS] = {
-	0, 10, 10, 10, 12, 12, 12};
-
-/* STORAGE_CLASS_INLINE void mipi_port_get_state( */
-static void mipi_port_get_state(
-	const rx_ID_t					ID,
-	const mipi_port_ID_t			port_ID,
-	mipi_port_state_t				*state);
-
-void input_system_get_state(
-	const input_system_ID_t			ID,
-	input_system_state_t			*state)
-{
-assert(ID < N_INPUT_SYSTEM_ID);
-assert(state != NULL);
-
-	state->ch_id_fmt_type = input_system_sub_system_reg_load(ID,
-		UNIT0_ID,
-		_REG_GP_CH_ID_FMT_TYPE_IDX);
-
-return;
-}
-
-void receiver_get_state(
-	const rx_ID_t				ID,
-	receiver_state_t			*state)
-{
-	mipi_port_ID_t	port_id;
-
-assert(ID < N_RX_ID);
-assert(state != NULL);
-
-	for (port_id = (mipi_port_ID_t)0; port_id < N_MIPI_PORT_ID; port_id++) {
-		mipi_port_get_state(ID, port_id,
-			&(state->mipi_port_state[port_id]));
-	}
-
-return;
-}
-
-bool is_mipi_format_yuv420(
-	const mipi_format_t			mipi_format)
-{
-	bool	is_yuv420 = (
-		(mipi_format == MIPI_FORMAT_YUV420_8) ||
-		(mipi_format == MIPI_FORMAT_YUV420_10));
-/* MIPI_FORMAT_YUV420_8_LEGACY is not YUV420 */
-
-return is_yuv420;
-}
-
-void receiver_set_compression(
-	const rx_ID_t				ID,
-	const unsigned int			cfg_ID,
-	const mipi_compressor_t		comp,
-	const mipi_predictor_t		pred)
-{
-	const mipi_port_ID_t	port_ID = (mipi_port_ID_t)cfg_ID;
-	uint8_t		comp_bits, uncomp_bits;
-	hrt_data	reg;
-
-assert(ID < N_RX_ID);
-assert(cfg_ID < N_MIPI_COMPRESSOR_CONTEXT);
-assert(port_ID < N_MIPI_PORT_ID);
-assert(comp < N_MIPI_COMPRESSOR_METHODS);
-assert(pred < N_MIPI_PREDICTOR_TYPES);
-
-	comp_bits = mipi_compressed_bits[comp];
-	uncomp_bits = mipi_uncompressed_bits[comp];
-
-assert(comp_bits != 0);
-assert(uncomp_bits != 0);
-
-	reg = (((hrt_data)uncomp_bits) << 8) | comp_bits;
-	receiver_port_reg_store(ID,
-		port_ID, _HRT_CSS_RECEIVER_COMP_FORMAT_REG_IDX, reg);
-	reg = (hrt_data)pred;
-	receiver_port_reg_store(ID,
-		port_ID, _HRT_CSS_RECEIVER_COMP_PREDICT_REG_IDX, reg);
-
-return;
-}
-
-void receiver_port_enable(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const bool					cnd)
-{
-	receiver_port_reg_store(ID, port_ID,
-		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, (hrt_data)cnd);
-return;
-}
-
-bool is_receiver_port_enabled(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID)
-{
-return (receiver_port_reg_load(ID, port_ID,
-	_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX) != 0);
-}
-
-void receiver_irq_enable(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const rx_irq_info_t			irq_info)
-{
-	receiver_port_reg_store(ID,
-		port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, irq_info);
-return;
-}
-
-rx_irq_info_t receiver_get_irq_info(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID)
-{
-return receiver_port_reg_load(ID,
-	port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
-}
-
-void receiver_irq_clear(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const rx_irq_info_t			irq_info)
-{
-	receiver_port_reg_store(ID,
-		port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX, irq_info);
-return;
-}
-
-/* STORAGE_CLASS_INLINE void mipi_port_get_state( */
-static void mipi_port_get_state(
-	const rx_ID_t					ID,
-	const mipi_port_ID_t			port_ID,
-	mipi_port_state_t				*state)
-{
-assert(ID < N_RX_ID);
-assert(port_ID < N_MIPI_PORT_ID);
-assert(state != NULL);
-
-	state->device_ready = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX);
-	state->irq_status = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
-	state->irq_enable = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
-	state->func_prog = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX);
-	state->init_count = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX);
-	state->comp_format = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_COMP_FORMAT_REG_IDX);
-	state->comp_predict = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_COMP_PREDICT_REG_IDX);
-	state->fs_to_ls_delay = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX);
-	state->ls_to_data_delay = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX);
-	state->data_to_le_delay = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX);
-	state->le_to_fe_delay = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX);
-	state->fe_to_fs_delay = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX);
-	state->le_to_fs_delay = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX);
-	state->is_two_ppc = receiver_port_reg_load(ID,
-		port_ID, _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX);
-
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_local.h
deleted file mode 100644
index aa980d8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_local.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_SYSTEM_LOCAL_H_INCLUDED__
-#define __INPUT_SYSTEM_LOCAL_H_INCLUDED__
-
-#include <stdbool.h>
-
-#include <input_system_global.h>
-
-typedef struct mipi_port_state_s	mipi_port_state_t;
-
-#define _REG_GP_CH_ID_FMT_TYPE_IDX		44
-
-/*
- * For each MIPI port
- */
-#define _HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX			\
-	_HRT_CSS_RECEIVER_AHB_DEVICE_READY_REG_IDX
-/*
-#define _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX			\
-	_HRT_CSS_RECEIVER_AHB_IRQ_STATUS_REG_IDX
- */
-#define _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX			\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ENABLE_REG_IDX
-#define _HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX				\
-	_HRT_CSS_RECEIVER_AHB_CSI2_FUNC_PROG_REG_IDX
-#define _HRT_CSS_RECEIVER_INIT_COUNT_REG_IDX			\
-	_HRT_CSS_RECEIVER_AHB_INIT_COUNT_REG_IDX
-#define _HRT_CSS_RECEIVER_COMP_FORMAT_REG_IDX			\
-	_HRT_CSS_RECEIVER_AHB_COMP_FORMAT_REG_IDX
-#define _HRT_CSS_RECEIVER_COMP_PREDICT_REG_IDX			\
-	_HRT_CSS_RECEIVER_AHB_COMP_PREDICT_REG_IDX
-#define _HRT_CSS_RECEIVER_FS_TO_LS_DELAY_REG_IDX		\
-	_HRT_CSS_RECEIVER_AHB_FS_TO_LS_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_LS_TO_DATA_DELAY_REG_IDX		\
-	_HRT_CSS_RECEIVER_AHB_LS_TO_DATA_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_DATA_TO_LE_DELAY_REG_IDX		\
-	_HRT_CSS_RECEIVER_AHB_DATA_TO_LE_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_LE_TO_FE_DELAY_REG_IDX		\
-	_HRT_CSS_RECEIVER_AHB_LE_TO_FE_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_FE_TO_FS_DELAY_REG_IDX		\
-	_HRT_CSS_RECEIVER_AHB_FE_TO_FS_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_LE_TO_LS_DELAY_REG_IDX		\
-	_HRT_CSS_RECEIVER_AHB_LE_TO_LS_DELAY_REG_IDX
-#define _HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX			\
-	_HRT_CSS_RECEIVER_AHB_TWO_PIXEL_EN_REG_IDX
-
-
-/*
-#define _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT				\
-	_HRT_CSS_RECEIVER_AHB_IRQ_OVERRUN_BIT
- */
-#define _HRT_CSS_RECEIVER_IRQ_RESERVED_BIT				\
-	_HRT_CSS_RECEIVER_AHB_IRQ_RESERVED_BIT
-#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT		\
-	_HRT_CSS_RECEIVER_AHB_IRQ_SLEEP_MODE_ENTRY_BIT
-#define _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT		\
-	_HRT_CSS_RECEIVER_AHB_IRQ_SLEEP_MODE_EXIT_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT			\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_SOT_HS_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT		\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_SOT_SYNC_HS_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT			\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_CONTROL_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT		\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_DOUBLE_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT		\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_CORRECTED_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT	\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_NO_CORRECTION_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT				\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_CRC_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT				\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_ID_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT		\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_FRAME_SYNC_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT		\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_FRAME_DATA_BIT
-#define _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT			\
-	_HRT_CSS_RECEIVER_AHB_IRQ_DATA_TIMEOUT_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT			\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_ESCAPE_BIT
-#define _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT			\
-	_HRT_CSS_RECEIVER_AHB_IRQ_ERR_LINE_SYNC_BIT
-
-#define _HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX				\
-	_HRT_CSS_RECEIVER_AHB_CSI2_FUNC_PROG_REG_IDX
-#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_IDX				\
-	_HRT_CSS_RECEIVER_AHB_CSI2_DATA_TIMEOUT_IDX
-#define	_HRT_CSS_RECEIVER_DATA_TIMEOUT_BITS				\
-	_HRT_CSS_RECEIVER_AHB_CSI2_DATA_TIMEOUT_BITS
-
-
-typedef enum {
-	MONO_4L_1L_0L = 0,
-	MONO_3L_1L_0L = 0,
-	MONO_2L_1L_0L = 0,
-	MONO_1L_1L_0L = 0,
-	N_RX_MODE
-} rx_mode_t;
-
-typedef enum {
-	MIPI_PREDICTOR_NONE = 0,
-	MIPI_PREDICTOR_TYPE1,
-	MIPI_PREDICTOR_TYPE2,
-	N_MIPI_PREDICTOR_TYPES
-} mipi_predictor_t;
-
-typedef enum {
-	MIPI_COMPRESSOR_NONE = 0,
-	MIPI_COMPRESSOR_10_6_10,
-	MIPI_COMPRESSOR_10_7_10,
-	MIPI_COMPRESSOR_10_8_10,
-	MIPI_COMPRESSOR_12_6_12,
-	MIPI_COMPRESSOR_12_7_12,
-	MIPI_COMPRESSOR_12_8_12,
-	N_MIPI_COMPRESSOR_METHODS
-} mipi_compressor_t;
-
-typedef enum {
-	MIPI_FORMAT_RGB888 = 0,
-	MIPI_FORMAT_RGB555,
-	MIPI_FORMAT_RGB444,
-	MIPI_FORMAT_RGB565,
-	MIPI_FORMAT_RGB666,
-	MIPI_FORMAT_RAW8,		/* 5 */
-	MIPI_FORMAT_RAW10,
-	MIPI_FORMAT_RAW6,
-	MIPI_FORMAT_RAW7,
-	MIPI_FORMAT_RAW12,
-	MIPI_FORMAT_RAW14,		/* 10 */
-	MIPI_FORMAT_YUV420_8,
-	MIPI_FORMAT_YUV420_10,
-	MIPI_FORMAT_YUV422_8,
-	MIPI_FORMAT_YUV422_10,
-	MIPI_FORMAT_CUSTOM0,	/* 15 */
-	MIPI_FORMAT_YUV420_8_LEGACY,
-	MIPI_FORMAT_EMBEDDED,
-	MIPI_FORMAT_CUSTOM1,
-	MIPI_FORMAT_CUSTOM2,
-	MIPI_FORMAT_CUSTOM3,	/* 20 */
-	MIPI_FORMAT_CUSTOM4,
-	MIPI_FORMAT_CUSTOM5,
-	MIPI_FORMAT_CUSTOM6,
-	MIPI_FORMAT_CUSTOM7,
-	MIPI_FORMAT_YUV420_8_SHIFT,	/* 25 */
-	MIPI_FORMAT_YUV420_10_SHIFT,
-	N_MIPI_FORMAT,
-} mipi_format_t;
-
-#define MIPI_FORMAT_RAW16		MIPI_FORMAT_EMBEDDED
-#define MIPI_FORMAT_JPEG		MIPI_FORMAT_CUSTOM0
-#define MIPI_FORMAT_BINARY_8	MIPI_FORMAT_CUSTOM0
-#define N_MIPI_FORMAT_CUSTOM	8
-
-/* The number of stores for compressed format types */
-#define	N_MIPI_COMPRESSOR_CONTEXT	(N_MIPI_PORT_ID)
-
-/*
- * Internal encoding
- *
-typedef enum {
-	MIPI_FORMAT_RAW16 = 17,
-	MIPI_FORMAT_EMBEDDED,
-
-	MIPI_FORMAT_YUV420_8 = 24,
-	MIPI_FORMAT_YUV420_10,
-	MIPI_FORMAT_YUV420_8_LEGACY,
-
-	MIPI_FORMAT_YUV420_8_SHIFT = 28,
-	MIPI_FORMAT_YUV420_10_SHIFT,
-	MIPI_FORMAT_YUV422_8,
-	MIPI_FORMAT_YUV422_10,
-	MIPI_FORMAT_RGB555,
-	MIPI_FORMAT_RGB444,
-	MIPI_FORMAT_RGB565,
-	MIPI_FORMAT_RGB666,
-	MIPI_FORMAT_RGB888,
-
-	MIPI_FORMAT_RAW8 = 40,
-	MIPI_FORMAT_RAW10,
-	MIPI_FORMAT_RAW6,
-	MIPI_FORMAT_RAW7,
-	MIPI_FORMAT_RAW12,
-	MIPI_FORMAT_RAW14,
-
-	MIPI_FORMAT_CUSTOM0 = 48,
-	MIPI_FORMAT_CUSTOM1,
-	MIPI_FORMAT_CUSTOM2,
-	MIPI_FORMAT_CUSTOM3,
-	MIPI_FORMAT_CUSTOM4,
-	MIPI_FORMAT_CUSTOM5,
-	MIPI_FORMAT_CUSTOM6,
-	MIPI_FORMAT_CUSTOM7,
-	N_MIPI_FORMAT = 28,
-} mipi_format_t;
- */
-
-typedef enum {
-	RX_IRQ_INFO_BUFFER_OVERRUN   =
-		1UL << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT,
-/*	RX_IRQ_INFO_RESERVED         =
-		1UL << _HRT_CSS_RECEIVER_IRQ_RESERVED_BIT, */
-	RX_IRQ_INFO_ENTER_SLEEP_MODE =
-		1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT,
-	RX_IRQ_INFO_EXIT_SLEEP_MODE  =
-		1UL << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT,
-	RX_IRQ_INFO_ECC_CORRECTED    =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT,
-	RX_IRQ_INFO_ERR_SOT          =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT,
-	RX_IRQ_INFO_ERR_SOT_SYNC     =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT,
-	RX_IRQ_INFO_ERR_CONTROL      =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT,
-	RX_IRQ_INFO_ERR_ECC_DOUBLE   =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT,
-/*	RX_IRQ_INFO_NO_ERR           =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT, */
-	RX_IRQ_INFO_ERR_CRC          =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT,
-	RX_IRQ_INFO_ERR_UNKNOWN_ID   =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT,
-	RX_IRQ_INFO_ERR_FRAME_SYNC   =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT,
-	RX_IRQ_INFO_ERR_FRAME_DATA   =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT,
-	RX_IRQ_INFO_ERR_DATA_TIMEOUT =
-		1UL << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT,
-	RX_IRQ_INFO_ERR_UNKNOWN_ESC  =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT,
-	RX_IRQ_INFO_ERR_LINE_SYNC    =
-		1UL << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT,
-}  rx_irq_info_t;
-
-
-typedef struct rx_cfg_s		rx_cfg_t;
-
-struct rx_cfg_s {
-	mipi_port_ID_t		port;
-	unsigned int		num_lanes;
-	unsigned int		timeout;
-	unsigned int		comp_bpp;
-	unsigned int		uncomp_bpp;
-	mipi_predictor_t	comp;
-	bool                is_two_ppc;
-};
-
-static const hrt_address MIPI_PORT_OFFSET[N_MIPI_PORT_ID] = {
-	0x00000100UL,
-	0x00000200UL};
-
-static const mipi_lane_cfg_t MIPI_PORT_MAXLANES[N_MIPI_PORT_ID] = {
-	MIPI_4LANE_CFG,
-	MIPI_1LANE_CFG};
-
-static const hrt_address SUB_SYSTEM_OFFSET[N_SUB_SYSTEM_ID] = {
-	0x00000000UL};
-
-struct input_system_state_s {
-	int	ch_id_fmt_type;
-};
-
-struct mipi_port_state_s {
-	int	device_ready;
-	int	irq_status;
-	int	irq_enable;
-	int	func_prog;
-	int	init_count;
-	int	comp_format;
-	int	comp_predict;
-	int	fs_to_ls_delay;
-	int	ls_to_data_delay;
-	int	data_to_le_delay;
-	int	le_to_fe_delay;
-	int	fe_to_fs_delay;
-	int	le_to_fs_delay;
-	int	is_two_ppc;
-};
-
-struct receiver_state_s {
-	struct mipi_port_state_s	mipi_port_state[N_MIPI_PORT_ID];
-};
-
-#endif /* __INPUT_SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_private.h
deleted file mode 100644
index 204f28f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/input_system_private.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_SYSTEM_PRIVATE_H_INCLUDED__
-#define __INPUT_SYSTEM_PRIVATE_H_INCLUDED__
-
-#include "input_system_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_INPUT_SYSTEM_C void input_system_reg_store(
-	const input_system_ID_t		ID,
-	const unsigned int			reg,
-	const hrt_data				value)
-{
-assert(ID < N_INPUT_SYSTEM_ID);
-assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(INPUT_SYSTEM_BASE[ID] +
-		reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_reg_load(
-	const input_system_ID_t		ID,
-	const unsigned int			reg)
-{
-assert(ID < N_INPUT_SYSTEM_ID);
-assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(INPUT_SYSTEM_BASE[ID] +
-		reg*sizeof(hrt_data));
-}
-
-STORAGE_CLASS_INPUT_SYSTEM_C void receiver_reg_store(
-	const rx_ID_t				ID,
-	const unsigned int			reg,
-	const hrt_data				value)
-{
-assert(ID < N_RX_ID);
-assert(RX_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(RX_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_reg_load(
-	const rx_ID_t				ID,
-	const unsigned int			reg)
-{
-assert(ID < N_RX_ID);
-assert(RX_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(RX_BASE[ID] + reg*sizeof(hrt_data));
-}
-
-STORAGE_CLASS_INPUT_SYSTEM_C void receiver_port_reg_store(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const unsigned int			reg,
-	const hrt_data				value)
-{
-assert(ID < N_RX_ID);
-assert(port_ID < N_MIPI_PORT_ID);
-assert(RX_BASE[ID] != (hrt_address)-1);
-assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
-	device_store_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] +
-		reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_INPUT_SYSTEM_C hrt_data receiver_port_reg_load(
-	const rx_ID_t				ID,
-	const mipi_port_ID_t		port_ID,
-	const unsigned int			reg)
-{
-assert(ID < N_RX_ID);
-assert(port_ID < N_MIPI_PORT_ID);
-assert(RX_BASE[ID] != (hrt_address)-1);
-assert(MIPI_PORT_OFFSET[port_ID] != (hrt_address)-1);
-return device_load_uint32(RX_BASE[ID] + MIPI_PORT_OFFSET[port_ID] +
-		reg*sizeof(hrt_data));
-}
-
-STORAGE_CLASS_INPUT_SYSTEM_C void input_system_sub_system_reg_store(
-	const input_system_ID_t		ID,
-	const sub_system_ID_t		sub_ID,
-	const unsigned int			reg,
-	const hrt_data				value)
-{
-assert(ID < N_INPUT_SYSTEM_ID);
-assert(sub_ID < N_SUB_SYSTEM_ID);
-assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
-assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
-	device_store_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] +
-		reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_INPUT_SYSTEM_C hrt_data input_system_sub_system_reg_load(
-	const input_system_ID_t		ID,
-	const sub_system_ID_t		sub_ID,
-	const unsigned int			reg)
-{
-assert(ID < N_INPUT_SYSTEM_ID);
-assert(sub_ID < N_SUB_SYSTEM_ID);
-assert(INPUT_SYSTEM_BASE[ID] != (hrt_address)-1);
-assert(SUB_SYSTEM_OFFSET[sub_ID] != (hrt_address)-1);
-return device_load_uint32(INPUT_SYSTEM_BASE[ID] + SUB_SYSTEM_OFFSET[sub_ID] +
-		reg*sizeof(hrt_data));
-}
-
-#endif /* __INPUT_SYSTEM_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq.c
deleted file mode 100644
index 0520222..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq.c
+++ /dev/null
@@ -1,327 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "irq.h"
-
-#ifndef __INLINE_GP_DEVICE__
-#define __INLINE_GP_DEVICE__
-#endif
-#include "gp_device.h"
-
-/* MW: This is an HRT backend function from "thread" */
-#include "platform_support.h"	/* hrt_sleep() */
-
-STORAGE_CLASS_INLINE void irq_wait_for_write_complete(
-	const irq_ID_t		ID);
-
-STORAGE_CLASS_INLINE bool any_irq_channel_enabled(
-	const irq_ID_t				ID);
-
-STORAGE_CLASS_INLINE irq_ID_t virq_get_irq_id(
-	const virq_id_t		irq_ID,
-	unsigned int		*channel_ID);
-
-#ifndef __INLINE_IRQ__
-#include "irq_private.h"
-#endif /* __INLINE_IRQ__ */
-
-void irq_clear_all(
-	const irq_ID_t				ID)
-{
-	hrt_data	mask = 0xFFFFFFFF;
-
-assert(ID < N_IRQ_ID);
-
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, mask);
-return;
-}
-
-/*
- * Do we want the user to be able to set the signalling method ?
- */
-void irq_enable_channel(
-	const irq_ID_t				ID,
-    const unsigned int			irq_id)
-{
-	unsigned int mask = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
-	unsigned int enable = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
-	unsigned int edge_in = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
-	unsigned int me = 1U << irq_id;
-
-assert(irq_id < hrt_isp_css_irq_num_irqs);
-
-	mask |= me;
-	enable |= me;
-	edge_in |= me;	/* rising edge */
-
-/* to avoid mishaps configuration must follow the following order */
-
-/* mask this interrupt */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask & ~me);
-/* rising edge at input */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX, edge_in);
-/* enable interrupt to output */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
-/* clear current irq only */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
-/* unmask interrupt from input */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
-
-	irq_wait_for_write_complete(ID);
-
-return;
-}
-
-void irq_enable_pulse(
-	const irq_ID_t	ID,
-	bool 			pulse)
-{
-	unsigned int edge_out = 0x0;
-	if (pulse) {
-		edge_out = 0xffffffff;
-	}
-	/* output is given as edge, not pulse */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX, edge_out);
-return;
-}
-
-void irq_disable_channel(
-	const irq_ID_t				ID,
-	const unsigned int			irq_id)
-{
-	unsigned int mask = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
-	unsigned int enable = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
-	unsigned int me = 1U << irq_id;
-
-assert(irq_id < hrt_isp_css_irq_num_irqs);
-
-	mask &= ~me;
-	enable &= ~me;
-
-/* enable interrupt to output */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX, enable);
-/* unmask interrupt from input */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_MASK_REG_IDX, mask);
-/* clear current irq only */
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, me);
-
-	irq_wait_for_write_complete(ID);
-
-return;
-}
-
-enum hrt_isp_css_irq_status irq_get_channel_id(
-	const irq_ID_t				ID,
-	unsigned int				*irq_id)
-{
-	unsigned int irq_status = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
-	enum hrt_isp_css_irq idx = hrt_isp_css_irq_num_irqs;
-	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_success;
-
-assert(irq_id != NULL);
-
-/* find the first irq bit */
-	for (idx = 0; idx < hrt_isp_css_irq_num_irqs; idx++) {
-		if (irq_status & (1U << idx))
-			break;
-	}
-	if (idx == hrt_isp_css_irq_num_irqs)
-		return hrt_isp_css_irq_status_error;
-
-/* now check whether there are more bits set */
-	if (irq_status != (1U << idx))
-		status = hrt_isp_css_irq_status_more_irqs;
-
-	irq_reg_store(ID,
-		_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, 1U << idx);
-
-	irq_wait_for_write_complete(ID);
-
-	if (irq_id)
-		*irq_id = (unsigned int)idx;
-
-return status;
-}
-
-void irq_raise(
-	const irq_ID_t				ID,
-	const irq_sw_channel_id_t	irq_id)
-{
-assert(ID == IRQ0_ID);
-assert(IRQ_BASE[ID] != (hrt_address)-1);
-assert(irq_id < N_IRQ_SW_CHANNEL_ID);
-	(void)ID;
-
-/* The SW IRQ pins are remapped to offset zero */
-	gp_device_reg_store(GP_DEVICE0_ID,
-		_REG_GP_IRQ_REQUEST_ADDR,
-		(1U<<(irq_id - hrt_isp_css_irq_sw_0)));
-#ifdef HRT_CSIM
-	hrt_sleep();
-#endif
-	gp_device_reg_store(GP_DEVICE0_ID,
-		_REG_GP_IRQ_REQUEST_ADDR, 0);
-return;
-}
-
-void irq_controller_get_state(
-	const irq_ID_t				ID,
-	irq_controller_state_t		*state)
-{
-assert(ID < N_IRQ_ID);
-assert(state != NULL);
-	if (state == NULL)
-		return;
-
-	state->irq_edge = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_EDGE_REG_IDX);
-	state->irq_mask = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_MASK_REG_IDX);
-	state->irq_status = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
-	state->irq_enable = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
-	state->irq_level_not_pulse = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX);
-return;
-}
-
-void virq_enable_channel(
-	const virq_id_t				irq_ID,
-	const bool					en)
-{
-	unsigned int	channel_ID;
-	irq_ID_t		ID = virq_get_irq_id(irq_ID, &channel_ID);
-	
-assert(ID < N_IRQ_ID);
-
-	if (en) {
-/* */
-		irq_enable_channel(ID, channel_ID);
-	} else {
-/* */
-		irq_disable_channel(ID, channel_ID);
-	}
-return;
-}
-
-
-void virq_clear_all(void)
-{
-	irq_clear_all(IRQ0_ID);
-return;
-}
-
-enum hrt_isp_css_irq_status virq_get_channel_signals(
-	virq_info_t					*irq_info)
-{
-	enum hrt_isp_css_irq_status irq_status = hrt_isp_css_irq_status_error;
-
-assert(irq_info != NULL);
-
-
-	if (any_irq_channel_enabled(IRQ0_ID)) {
-		hrt_data	irq_data = irq_reg_load(IRQ0_ID,
-			_HRT_IRQ_CONTROLLER_STATUS_REG_IDX);
-
-		if (irq_data != 0) {
-/* The error condition is an IRQ pulse received with no IRQ status written */
-			irq_status = hrt_isp_css_irq_status_success;
-		}
-		if (irq_info != NULL)
-			irq_info->irq_status_reg[IRQ0_ID] |= irq_data;
-
-		irq_reg_store(IRQ0_ID,
-			_HRT_IRQ_CONTROLLER_CLEAR_REG_IDX, irq_data);
-
-		irq_wait_for_write_complete(IRQ0_ID);
-	}
-
-return irq_status;
-}
-
-void virq_clear_info(
-	virq_info_t					*irq_info)
-{
-	irq_info->irq_status_reg[IRQ0_ID] = 0;
-return;
-}
-
-enum hrt_isp_css_irq_status virq_get_channel_id(
-	virq_id_t					*irq_id)
-{
-	unsigned int	_irq_id;
-	enum hrt_isp_css_irq_status	irq_status = irq_get_channel_id(IRQ0_ID, &_irq_id);
-	if (irq_id != NULL) {
-		*irq_id = (virq_id_t)_irq_id;
-	}
-return irq_status;
-}
-
-STORAGE_CLASS_INLINE void irq_wait_for_write_complete(
-	const irq_ID_t		ID)
-{
-assert(ID < N_IRQ_ID);
-assert(IRQ_BASE[ID] != (hrt_address)-1);
-	(void)device_load_uint32(IRQ_BASE[ID] +
-		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX*sizeof(hrt_data));
-#ifdef HRT_CSIM
-	hrt_sleep();
-#endif
-return;
-}
-
-STORAGE_CLASS_INLINE bool any_irq_channel_enabled(
-	const irq_ID_t				ID)
-{
-	hrt_data	en_reg;
-
-assert(ID < N_IRQ_ID);
-
-	en_reg = irq_reg_load(ID,
-		_HRT_IRQ_CONTROLLER_ENABLE_REG_IDX);
-
-return (en_reg != 0);
-}
-
-STORAGE_CLASS_INLINE irq_ID_t virq_get_irq_id(
-	const virq_id_t		irq_ID,
-	unsigned int		*channel_ID)
-{
-	irq_ID_t ID = IRQ0_ID;
-
-assert(channel_ID != NULL);
-	if (channel_ID == NULL) {
-		return N_IRQ_ID;
-	}
-
-	*channel_ID = (unsigned int)irq_ID;
-
-return ID;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_local.h
deleted file mode 100644
index 95e4459..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_local.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IRQ_LOCAL_H_INCLUDED__
-#define __IRQ_LOCAL_H_INCLUDED__
-
-#include "irq_global.h"
-
-#include <hive_isp_css_irq_types_hrt.h>
-#include <irq_controller_defs.h>
-
-typedef struct virq_info_s					virq_info_t;
-typedef struct irq_controller_state_s		irq_controller_state_t;
-
-typedef enum {
-	virq_gpio_pin_0     = hrt_isp_css_irq_gpio_0,
-	virq_gpio_pin_1     = hrt_isp_css_irq_gpio_1,
-	virq_gpio_pin_2     = hrt_isp_css_irq_gpio_2,
-	virq_gpio_pin_3     = hrt_isp_css_irq_gpio_3,
-	virq_gpio_pin_4     = hrt_isp_css_irq_gpio_4,
-	virq_gpio_pin_5     = hrt_isp_css_irq_gpio_5,
-	virq_gpio_pin_6     = hrt_isp_css_irq_gpio_6,
-	virq_gpio_pin_7     = hrt_isp_css_irq_gpio_7,
-	virq_gpio_pin_8     = hrt_isp_css_irq_gpio_8,
-	virq_gpio_pin_9     = hrt_isp_css_irq_gpio_9,
-	virq_sp             = hrt_isp_css_irq_sp,
-	virq_isp            = hrt_isp_css_irq_isp,
-	virq_isys           = hrt_isp_css_irq_mipi,
-	virq_ifmt0_id       = hrt_isp_css_irq_ift_prim,
-	virq_ifmt1_id       = hrt_isp_css_irq_ift_prim_b,
-	virq_ifmt2_id       = hrt_isp_css_irq_ift_sec,
-	virq_ifmt3_id       = hrt_isp_css_irq_ift_mem_cpy,
-	virq_isys_fifo_full = hrt_isp_css_irq_mipi_fifo_full,
-	virq_isys_sof       = hrt_isp_css_irq_mipi_sof,
-	virq_isys_eof       = hrt_isp_css_irq_mipi_eof,
-	virq_isys_sol       = hrt_isp_css_irq_mipi_sol,
-	virq_isys_eol       = hrt_isp_css_irq_mipi_eol,
-	virq_isel_sof       = hrt_isp_css_irq_syncgen_sof,
-	virq_isel_eof       = hrt_isp_css_irq_syncgen_eof,
-	virq_isel_sol       = hrt_isp_css_irq_syncgen_sol,
-	virq_isel_eol       = hrt_isp_css_irq_syncgen_eol,
-	virq_gen_short_0    = hrt_isp_css_irq_css_gen_short_0,
-	virq_gen_short_1    = hrt_isp_css_irq_css_gen_short_1,
-	virq_ifmt_sideband_changed = hrt_isp_css_irq_sideband_changed,
-	virq_sw_pin_0       = hrt_isp_css_irq_sw_0,
-	virq_sw_pin_1       = hrt_isp_css_irq_sw_1,
-	virq_sw_pin_2       = hrt_isp_css_irq_sw_2,
-	N_virq_id           = hrt_isp_css_irq_num_irqs
-} virq_id_t;
-
-struct virq_info_s {
-/*
- * If we want to auto-size to the minimum required
- * else guess what is the maximum over all systems
- *
-	hrt_data		irq_status_reg[N_IRQ_ID];
- */
-	hrt_data		irq_status_reg[4];
-};
-
-/*
- * This data structure is private to the host
- */
-struct irq_controller_state_s {
-	unsigned int	irq_edge;
-	unsigned int	irq_mask;
-	unsigned int	irq_status;
-	unsigned int	irq_enable;
-	unsigned int	irq_level_not_pulse;
-};
-
-#endif /* __IRQ_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_private.h
deleted file mode 100644
index c7bc770f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/irq_private.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IRQ_PRIVATE_H_INCLUDED__
-#define __IRQ_PRIVATE_H_INCLUDED__
-
-#include "irq_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_IRQ_C void irq_reg_store(
-	const irq_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value)
-{
-assert(ID < N_IRQ_ID);
-assert(IRQ_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(IRQ_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_IRQ_C hrt_data irq_reg_load(
-	const irq_ID_t		ID,
-	const unsigned int	reg)
-{
-assert(ID < N_IRQ_ID);
-assert(IRQ_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(IRQ_BASE[ID] + reg*sizeof(hrt_data));
-}
-
-#endif /* __IRQ_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp.c
deleted file mode 100644
index dfeed9d..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "isp.h"
-
-#ifndef __INLINE_ISP__
-#include "isp_private.h"
-#endif /* __INLINE_ISP__ */
-
-void cnd_isp_irq_enable(
-	const isp_ID_t		ID,
-	const bool			cnd)
-{
-	if (cnd) {
-		isp_ctrl_setbit(ID, ISP_IRQ_READY_REG, ISP_IRQ_READY_BIT);
-/* Enabling the IRQ immediately triggers an interrupt, clear it */
-		isp_ctrl_setbit(ID, ISP_IRQ_CLEAR_REG, ISP_IRQ_CLEAR_BIT);
-	} else /* { */
-		isp_ctrl_clearbit(ID, ISP_IRQ_READY_REG,
-			ISP_IRQ_READY_BIT);
-	/* } */
-return;
-}
-
-void isp_get_state(
-	const isp_ID_t		ID,
-    isp_state_t			*state,
-	isp_stall_t			*stall)
-{
-	hrt_data sc = isp_ctrl_load(ID, ISP_SC_REG);
-	state->pc = isp_ctrl_load(ID, ISP_PC_REG);
-	state->status_register = sc;
-	state->is_broken = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_BROKEN_BIT);
-	state->is_idle = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_IDLE_BIT);
-	state->is_sleeping = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_SLEEPING_BIT);
-	state->is_stalling = isp_ctrl_getbit(ID, ISP_SC_REG, ISP_STALLING_BIT);
-	stall->stat_ctrl =
-		!isp_ctrl_getbit(ID, ISP_CTRL_SINK_REG, ISP_CTRL_SINK_BIT);
-/*
-	stall->pmem =
-		!isp_ctrl_getbit(ID, ISP_PMEM_SINK_REG, ISP_PMEM_SINK_BIT);
- */
-	stall->dmem =
-		!isp_ctrl_getbit(ID, ISP_DMEM_SINK_REG, ISP_DMEM_SINK_BIT);
-	stall->vmem =
-		!isp_ctrl_getbit(ID, ISP_VMEM_SINK_REG, ISP_VMEM_SINK_BIT);
-	stall->fifo0 =
-		!isp_ctrl_getbit(ID, ISP_FIFO0_SINK_REG, ISP_FIFO0_SINK_BIT);
-	stall->fifo1 =
-		!isp_ctrl_getbit(ID, ISP_FIFO1_SINK_REG, ISP_FIFO1_SINK_BIT);
-	stall->fifo2 =
-		!isp_ctrl_getbit(ID, ISP_FIFO2_SINK_REG, ISP_FIFO2_SINK_BIT);
-	stall->fifo3 =
-		!isp_ctrl_getbit(ID, ISP_FIFO3_SINK_REG, ISP_FIFO3_SINK_BIT);
-	stall->fifo4 =
-		!isp_ctrl_getbit(ID, ISP_FIFO4_SINK_REG, ISP_FIFO4_SINK_BIT);
-	stall->fifo5 =
-		!isp_ctrl_getbit(ID, ISP_FIFO5_SINK_REG, ISP_FIFO5_SINK_BIT);
-	stall->vamem1 =
-		!isp_ctrl_getbit(ID, ISP_VAMEM1_SINK_REG, ISP_VAMEM1_SINK_BIT);
-	stall->vamem2 =
-		!isp_ctrl_getbit(ID, ISP_VAMEM2_SINK_REG, ISP_VAMEM2_SINK_BIT);
-
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_local.h
deleted file mode 100644
index 9894f2a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_local.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __ISP_LOCAL_H_INCLUDED__
-#define __ISP_LOCAL_H_INCLUDED__
-
-#include <stdbool.h>
-
-#include "isp_global.h"
-
-#define HIVE_ISP_VMEM_MASK	((1U<<ISP_VMEM_ELEMBITS)-1)
-
-typedef struct isp_state_s		isp_state_t;
-typedef struct isp_stall_s		isp_stall_t;
-
-struct isp_state_s {
-	int		pc;
-	int		status_register;
-	bool	is_broken;
-	bool	is_idle;
-	bool	is_sleeping;
-	bool	is_stalling;
-};
-
-struct isp_stall_s {
-	bool	fifo0;
-	bool	fifo1;
-	bool	fifo2;
-	bool	fifo3;
-	bool	fifo4;
-	bool	fifo5;
-	bool	stat_ctrl;
-	bool	dmem;
-	bool	vmem;
-	bool	vamem1;
-	bool	vamem2;
-	bool	pmem;
-};
-
-#endif /* __ISP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_private.h
deleted file mode 100644
index 7a409913..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/isp_private.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __ISP_PRIVATE_H_INCLUDED__
-#define __ISP_PRIVATE_H_INCLUDED__
-
-#include "isp_public.h"
-
-#ifdef C_RUN
-#include <string.h>		/* memcpy() */
-#endif
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_ISP_C void isp_ctrl_store(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value)
-{
-assert(ID < N_ISP_ID);
-assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(ISP_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_ISP_C hrt_data isp_ctrl_load(
-	const isp_ID_t		ID,
-	const unsigned int	reg)
-{
-assert(ID < N_ISP_ID);
-assert(ISP_CTRL_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(ISP_CTRL_BASE[ID] + reg*sizeof(hrt_data));
-}
-
-STORAGE_CLASS_ISP_C bool isp_ctrl_getbit(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit)
-{
-	hrt_data val = isp_ctrl_load(ID, reg);
-return (val & (1UL << bit)) != 0;
-}
-
-STORAGE_CLASS_ISP_C void isp_ctrl_setbit(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit)
-{
-	hrt_data	data = isp_ctrl_load(ID, reg);
-	isp_ctrl_store(ID, reg, (data | (1UL << bit)));
-return;
-}
-
-STORAGE_CLASS_ISP_C void isp_ctrl_clearbit(
-	const isp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit)
-{
-	hrt_data	data = isp_ctrl_load(ID, reg);
-	isp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
-return;
-}
-
-STORAGE_CLASS_ISP_C void isp_dmem_store(
-	const isp_ID_t		ID,
-	unsigned int		addr,
-	const void			*data,
-	const size_t		size)
-{
-assert(ID < N_ISP_ID);
-assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_store(ISP_DMEM_BASE[ID] + addr, data, size);
-#else
-	memcpy((void *)addr, data, size);
-#endif
-return;
-}
-
-STORAGE_CLASS_ISP_C void isp_dmem_load(
-	const isp_ID_t		ID,
-	const unsigned int	addr,
-	void				*data,
-	const size_t		size)
-{
-assert(ID < N_ISP_ID);
-assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_load(ISP_DMEM_BASE[ID] + addr, data, size);
-#else
-	memcpy(data, (void *)addr, size);
-#endif
-return;
-}
-
-STORAGE_CLASS_ISP_C void isp_dmem_store_uint32(
-	const isp_ID_t		ID,
-	unsigned int		addr,
-	const uint32_t		data)
-{
-assert(ID < N_ISP_ID);
-assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_store_uint32(ISP_DMEM_BASE[ISP0_ID] + addr, data);
-#else
-	*(uint32_t *)addr = data;
-#endif
-return;
-}
-
-STORAGE_CLASS_ISP_C uint32_t isp_dmem_load_uint32(
-	const isp_ID_t		ID,
-	const unsigned int	addr)
-{
-assert(ID < N_ISP_ID);
-assert(ISP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	return device_load_uint32(ISP_DMEM_BASE[ISP0_ID] + addr);
-#else
-	return *(uint32_t *)addr;
-#endif
-}
-
-STORAGE_CLASS_ISP_C uint32_t isp_2w_cat_1w(
-	const uint16_t		x0,
-	const uint16_t		x1)
-{
-	uint32_t out = ((uint32_t)(x1 & HIVE_ISP_VMEM_MASK) << ISP_VMEM_ELEMBITS)
-		| (x0 & HIVE_ISP_VMEM_MASK);
-return out;
-}
-
-#endif /* __ISP_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu.c
deleted file mode 100644
index f7b6025..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-
-/* The name "mmu.h is already taken" */
-#include "mmu_device.h"
-
-#ifndef __INLINE_MMU__
-#include "mmu_private.h"
-#endif /* __INLINE_MMU__ */
-
-void mmu_set_page_table_base_index(
-	const mmu_ID_t		ID,
-	const hrt_data		base_index)
-{
-	mmu_reg_store(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX, base_index);
-return;
-}
-
-hrt_data mmu_get_page_table_base_index(
-	const mmu_ID_t		ID)
-{
-return mmu_reg_load(ID, _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX);
-}
-
-void mmu_invalidate_cache(
-	const mmu_ID_t		ID)
-{
-	mmu_reg_store(ID, _HRT_MMU_INVALIDATE_TLB_REG_IDX, 1);
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_local.h
deleted file mode 100644
index ce7036c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_local.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __MMU_LOCAL_H_INCLUDED__
-#define __MMU_LOCAL_H_INCLUDED__
-
-#include "mmu_global.h"
-
-
-#define HOST_ADDRESS(x) (unsigned long)(x)
-
-#endif /* __MMU_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_private.h
deleted file mode 100644
index 06d7761..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/mmu_private.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __MMU_PRIVATE_H_INCLUDED__
-#define __MMU_PRIVATE_H_INCLUDED__
-
-#include "mmu_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_MMU_C void mmu_reg_store(
-	const mmu_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value)
-{
-assert(ID < N_MMU_ID);
-assert(MMU_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(MMU_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_MMU_C hrt_data mmu_reg_load(
-	const mmu_ID_t		ID,
-	const unsigned int	reg)
-{
-assert(ID < N_MMU_ID);
-assert(MMU_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(MMU_BASE[ID] + reg*sizeof(hrt_data));
-}
-
-#endif /* __MMU_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp.c
deleted file mode 100644
index c5ad421..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-
-#include "sp.h"
-
-#ifndef __INLINE_SP__
-#include "sp_private.h"
-#endif /* __INLINE_SP__ */
-
-void cnd_sp_irq_enable(
-	const sp_ID_t		ID,
-	const bool			cnd)
-{
-	if (cnd) {
-		sp_ctrl_setbit(ID, SP_IRQ_READY_REG, SP_IRQ_READY_BIT);
-/* Enabling the IRQ immediately triggers an interrupt, clear it */
-		sp_ctrl_setbit(ID, SP_IRQ_CLEAR_REG, SP_IRQ_CLEAR_BIT);
-	} else /* { */
-		sp_ctrl_clearbit(ID, SP_IRQ_READY_REG, SP_IRQ_READY_BIT);
-	/* } */
-return;
-}
-
-void sp_get_state(
-	const sp_ID_t			ID,
-	sp_state_t				*state,
-	sp_stall_t				*stall)
-{
-	hrt_data sc = sp_ctrl_load(ID, SP_SC_REG);
-	state->pc = sp_ctrl_load(ID, SP_PC_REG);
-	state->status_register = sc;
-	state->is_broken   = (sc & (1U << SP_BROKEN_BIT)) != 0;
-	state->is_idle     = (sc & (1U << SP_IDLE_BIT)) != 0;
-	state->is_sleeping = (sc & (1U << SP_SLEEPING_BIT)) != 0;
-	state->is_stalling = (sc & (1U << SP_STALLING_BIT)) != 0;
-	stall->fifo0 =
-		!sp_ctrl_getbit(ID, SP_FIFO0_SINK_REG, SP_FIFO0_SINK_BIT);
-	stall->fifo1 =
-		!sp_ctrl_getbit(ID, SP_FIFO1_SINK_REG, SP_FIFO1_SINK_BIT);
-	stall->fifo2 =
-		!sp_ctrl_getbit(ID, SP_FIFO2_SINK_REG, SP_FIFO2_SINK_BIT);
-	stall->fifo3 =
-		!sp_ctrl_getbit(ID, SP_FIFO3_SINK_REG, SP_FIFO3_SINK_BIT);
-	stall->fifo4 =
-		!sp_ctrl_getbit(ID, SP_FIFO4_SINK_REG, SP_FIFO4_SINK_BIT);
-	stall->fifo5 =
-		!sp_ctrl_getbit(ID, SP_FIFO5_SINK_REG, SP_FIFO5_SINK_BIT);
-	stall->fifo6 =
-		!sp_ctrl_getbit(ID, SP_FIFO6_SINK_REG, SP_FIFO6_SINK_BIT);
-	stall->fifo7 =
-		!sp_ctrl_getbit(ID, SP_FIFO7_SINK_REG, SP_FIFO7_SINK_BIT);
-	stall->dmem =
-		!sp_ctrl_getbit(ID, SP_DMEM_SINK_REG, SP_DMEM_SINK_BIT);
-	stall->control_master =
-		!sp_ctrl_getbit(ID, SP_CTRL_MT_SINK_REG, SP_CTRL_MT_SINK_BIT);
-	stall->icache_master =
-		!sp_ctrl_getbit(ID, SP_ICACHE_MT_SINK_REG,
-			SP_ICACHE_MT_SINK_BIT);
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_local.h
deleted file mode 100644
index 008cd92..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_local.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SP_LOCAL_H_INCLUDED__
-#define __SP_LOCAL_H_INCLUDED__
-
-#include <stdbool.h>
-
-#include "sp_global.h"
-
-struct sp_state_s {
-	int		pc;
-	int		status_register;
-	bool	is_broken;
-	bool	is_idle;
-	bool	is_sleeping;
-	bool	is_stalling;
-};
-
-struct sp_stall_s {
-	bool	fifo0;
-	bool	fifo1;
-	bool	fifo2;
-	bool	fifo3;
-	bool	fifo4;
-	bool	fifo5;
-	bool	fifo6;
-	bool	fifo7;
-	bool	dmem;
-	bool	control_master;
-	bool	icache_master;
-};
-
-#if !defined(HRT_RTL) && !defined(HRT_HW) && \
-	!defined(HRT_FPGA) && !defined(HRT_PD)
-#include "hive_isp_css_sp_hrt.h"
-#define sp_address_of(var)	_sp_var_addr(var)
-#else
-#define sp_address_of(var)	(HIVE_ADDR_ ## var)
-#endif
-
-/*
- * deprecated
- */
-#define store_sp_int(var, value) \
-	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(var), \
-		(uint32_t)(value))
-
-#define store_sp_ptr(var, value) \
-	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(var), \
-		(uint32_t)(value))
-
-#define load_sp_uint(var) \
-	sp_dmem_load_uint32(SP0_ID, (unsigned)sp_address_of(var))
-
-#define load_sp_array_uint8(array_name, index) \
-	sp_dmem_load_uint8(SP0_ID, (unsigned)sp_address_of(array_name) + \
-		(index)*sizeof(uint8_t))
-
-#define load_sp_array_uint16(array_name, index) \
-	sp_dmem_load_uint16(SP0_ID, (unsigned)sp_address_of(array_name) + \
-		(index)*sizeof(uint16_t))
-
-#define load_sp_array_uint(array_name, index) \
-	sp_dmem_load_uint32(SP0_ID, (unsigned)sp_address_of(array_name) + \
-		(index)*sizeof(uint32_t))
-
-#define store_sp_var(var, data, bytes) \
-	sp_dmem_store(SP0_ID, (unsigned)sp_address_of(var), data, bytes)
-
-#define store_sp_array_uint8(array_name, index, value) \
-	sp_dmem_store_uint8(SP0_ID, (unsigned)sp_address_of(array_name) + \
-		(index)*sizeof(uint8_t), value)
-
-#define store_sp_array_uint16(array_name, index, value) \
-	sp_dmem_store_uint16(SP0_ID, (unsigned)sp_address_of(array_name) + \
-		(index)*sizeof(uint16_t), value)
-
-#define store_sp_array_uint(array_name, index, value) \
-	sp_dmem_store_uint32(SP0_ID, (unsigned)sp_address_of(array_name) + \
-		(index)*sizeof(uint32_t), value)
-
-#define store_sp_var_with_offset(var, offset, data, bytes) \
-	sp_dmem_store(SP0_ID, (unsigned)sp_address_of(var) + \
-		offset, data, bytes)
-
-#define load_sp_var(var, data, bytes) \
-	sp_dmem_load(SP0_ID, (unsigned)sp_address_of(var), data, bytes)
-
-#define load_sp_var_with_offset(var, offset, data, bytes) \
-	sp_dmem_load(SP0_ID, (unsigned)sp_address_of(var) + offset, \
-		data, bytes)
-
-#endif /* __SP_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_private.h
deleted file mode 100644
index ddad036..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/sp_private.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SP_PRIVATE_H_INCLUDED__
-#define __SP_PRIVATE_H_INCLUDED__
-
-#include "sp_public.h"
-
-#include "device_access.h"
-#ifdef C_RUN
-#include <string.h>	/* memcpy() */
-#endif
-
-#include "assert_support.h"
-
-STORAGE_CLASS_SP_C void sp_ctrl_store(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const hrt_data		value)
-{
-assert(ID < N_SP_ID);
-assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(SP_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-STORAGE_CLASS_SP_C hrt_data sp_ctrl_load(
-	const sp_ID_t		ID,
-	const unsigned int	reg)
-{
-assert(ID < N_SP_ID);
-assert(SP_CTRL_BASE[ID] != (hrt_address)-1);
-return device_load_uint32(SP_CTRL_BASE[ID] + reg*sizeof(hrt_data));
-}
-
-STORAGE_CLASS_SP_C bool sp_ctrl_getbit(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit)
-{
-	hrt_data val = sp_ctrl_load(ID, reg);
-return (val & (1UL << bit)) != 0;
-}
-
-STORAGE_CLASS_SP_C void sp_ctrl_setbit(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit)
-{
-	hrt_data	data = sp_ctrl_load(ID, reg);
-	sp_ctrl_store(ID, reg, (data | (1UL << bit)));
-return;
-}
-
-STORAGE_CLASS_SP_C void sp_ctrl_clearbit(
-	const sp_ID_t		ID,
-	const unsigned int	reg,
-	const unsigned int	bit)
-{
-	hrt_data	data = sp_ctrl_load(ID, reg);
-	sp_ctrl_store(ID, reg, (data & ~(1UL << bit)));
-return;
-}
-
-STORAGE_CLASS_SP_C void sp_dmem_store(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const void			*data,
-	const size_t		size)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_store(SP_DMEM_BASE[ID] + addr, data, size);
-#else
-	memcpy((void *)addr, data, size);
-#endif
-return;
-}
-
-STORAGE_CLASS_SP_C void sp_dmem_load(
-	const sp_ID_t		ID,
-	const unsigned int	addr,
-	void				*data,
-	const size_t		size)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_load(SP_DMEM_BASE[ID] + addr, data, size);
-#else
-	memcpy(data, (void *)addr, size);
-#endif
-return;
-}
-
-STORAGE_CLASS_SP_C void sp_dmem_store_uint8(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const uint8_t		data)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_store_uint8(SP_DMEM_BASE[SP0_ID] + addr, data);
-#else
-	*(uint8_t *)addr = data;
-#endif
-return;
-}
-
-STORAGE_CLASS_SP_C void sp_dmem_store_uint16(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const uint16_t		data)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_store_uint16(SP_DMEM_BASE[SP0_ID] + addr, data);
-#else
-	*(uint16_t *)addr = data;
-#endif
-return;
-}
-
-STORAGE_CLASS_SP_C void sp_dmem_store_uint32(
-	const sp_ID_t		ID,
-	unsigned int		addr,
-	const uint32_t		data)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	device_store_uint32(SP_DMEM_BASE[SP0_ID] + addr, data);
-#else
-	*(uint32_t *)addr = data;
-#endif
-return;
-}
-
-STORAGE_CLASS_SP_C uint8_t sp_dmem_load_uint8(
-	const sp_ID_t		ID,
-	const unsigned int	addr)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	return device_load_uint8(SP_DMEM_BASE[SP0_ID] + addr);
-#else
-	return *(uint8_t *)addr;
-#endif
-}
-
-STORAGE_CLASS_SP_C uint16_t sp_dmem_load_uint16(
-	const sp_ID_t		ID,
-	const unsigned int	addr)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	return device_load_uint16(SP_DMEM_BASE[SP0_ID] + addr);
-#else
-	return *(uint16_t *)addr;
-#endif
-}
-
-STORAGE_CLASS_SP_C uint32_t sp_dmem_load_uint32(
-	const sp_ID_t		ID,
-	const unsigned int	addr)
-{
-assert(ID < N_SP_ID);
-assert(SP_DMEM_BASE[ID] != (hrt_address)-1);
-#ifndef C_RUN
-	return device_load_uint32(SP_DMEM_BASE[SP0_ID] + addr);
-#else
-	return *(uint32_t *)addr;
-#endif
-}
-
-
-#endif /* __SP_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/system_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/system_local.h
deleted file mode 100644
index 15bcae3..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/system_local.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SYSTEM_LOCAL_H_INCLUDED__
-#define __SYSTEM_LOCAL_H_INCLUDED__
-
-#ifdef HRT_ISP_CSS_CUSTOM_HOST
-#ifndef HRT_USE_VIR_ADDRS
-#define HRT_USE_VIR_ADDRS
-#endif
-#ifdef __KERNEL__
-#include <hive_isp_css_custom_host_hrt.h>
-#endif
-#endif
-
-#include "system_global.h"
-
-/* Surprise, this is a local property */
-#define HRT_ADDRESS_WIDTH	32
-
-#define GHANIUS 0
-
-#if !defined(__KERNEL__) && !GHANIUS
-#include <hrt/hive_types.h>
-#else  /* __KERNEL__ */
-/*
- * leaks through to the ISP code generation
- *
-#include <stdint.h>
-
-typedef uint32_t			hrt_address;
-typedef uint32_t			hrt_vaddress;
-typedef uint32_t			hrt_data;
-*/
-#define hrt_address			unsigned
-#define hrt_vaddress		unsigned
-#define hrt_data			unsigned
-#endif /* __KERNEL__ */
-
-/*
- * Cell specific address maps
- */
-/* This is NOT a base address */
-#define GP_FIFO_BASE   ((hrt_address)0x10200304)
-
-/* DDR */
-static const hrt_address DDR_BASE[N_DDR_ID] = {
-	0x00000000UL};
-
-/* ISP */
-static const hrt_address ISP_CTRL_BASE[N_ISP_ID] = {
-	0x10020000UL};
-
-static const hrt_address ISP_DMEM_BASE[N_ISP_ID] = {
-	0xffffffffUL};
-
-static const hrt_address ISP_BAMEM_BASE[N_BAMEM_ID] = {
-	0xffffffffUL};
-
-static const hrt_address ISP_VAMEM_BASE[N_VAMEM_ID] = {
-	0xffffffffUL,
-	0xffffffffUL};
-
-/* SP */
-static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
-	0x10104000UL};
-
-static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
-	0x10100000UL};
-
-/* MMU */
-static const hrt_address MMU_BASE[N_MMU_ID] = {
-	0x10250000UL};
-
-/* DMA */
-static const hrt_address DMA_BASE[N_DMA_ID] = {
-	0x10240000UL};
-
-/* IRQ */
-static const hrt_address IRQ_BASE[N_IRQ_ID] = {
-	0x10200500UL};
-
-/* GDC */
-static const hrt_address GDC_BASE[N_GDC_ID] = {
-	0x10180000UL};
-
-/* FIFO_MONITOR (subset of GP_DEVICE) */
-static const hrt_address FIFO_MONITOR_BASE[N_FIFO_MONITOR_ID] = {
-	0x10200000UL};
-
-/* GP_DEVICE */
-static const hrt_address GP_DEVICE_BASE[N_GP_DEVICE_ID] = {
-	0x10200000UL};
-
-/* GPIO */
-static const hrt_address GPIO_BASE[N_GPIO_ID] = {
-	0x10200400UL};
-
-/* TIMED_CTRL */
-static const hrt_address TIMED_CTRL_BASE[N_TIMED_CTRL_ID] = {
-	0x10200100UL};
-
-/* INPUT_FORMATTER */
-static const hrt_address INPUT_FORMATTER_BASE[N_INPUT_FORMATTER_ID] = {
-	0x10210000UL,
-	0x10270000UL};
-/*	0x10220000UL, */ /* sec */
-/*	0x10230000UL, */ /* memcpy() */
-
-/* INPUT_SYSTEM (subset of GP_DEVICE) */
-static const hrt_address INPUT_SYSTEM_BASE[N_INPUT_SYSTEM_ID] = {
-	0x10200000UL};
-
-/* RX */
-static const hrt_address RX_BASE[N_RX_ID] = {
-	0x10260000UL};
-
-#endif /* __SYSTEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl.c
deleted file mode 100644
index aaa60f9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#include "timed_ctrl.h"
-
-#ifndef __INLINE_TIMED_CTRL__
-#include "timed_ctrl_private.h"
-#endif /* __INLINE_TIMED_CTRL__ */
-
-#include "assert_support.h"
-
-void timed_ctrl_snd_commnd(
-	const timed_ctrl_ID_t				ID,
-	hrt_data				mask,
-	hrt_data				condition,
-	hrt_data				counter,
-	hrt_address				addr,
-	hrt_data				value)
-{
-OP___assert(ID == TIMED_CTRL0_ID);
-OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
-
-	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, mask);
-	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, condition);
-	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, counter);
-	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, addr);
-	timed_ctrl_reg_store(ID, _HRT_TIMED_CONTROLLER_CMD_REG_IDX, value);
-return;
-}
-
-/* pqiao TODO: make sure the following commands get
-	correct BASE address both for csim and android */
-
-void timed_ctrl_snd_sp_commnd(
-	const timed_ctrl_ID_t				ID,
-	hrt_data				mask,
-	hrt_data				condition,
-	hrt_data				counter,
-	const sp_ID_t			SP_ID,
-	hrt_address				offset,
-	hrt_data				value)
-{
-OP___assert(SP_ID < N_SP_ID);
-OP___assert(SP_DMEM_BASE[SP_ID] != (hrt_address)-1);
-
-	timed_ctrl_snd_commnd(ID, mask, condition, counter,
-				SP_DMEM_BASE[SP_ID]+offset, value);
-return;
-}
-
-void timed_ctrl_snd_gpio_commnd(
-	const timed_ctrl_ID_t				ID,
-	hrt_data				mask,
-	hrt_data				condition,
-	hrt_data				counter,
-	const gpio_ID_t			GPIO_ID,
-	hrt_address				offset,
-	hrt_data				value)
-{
-OP___assert(GPIO_ID < N_GPIO_ID);
-OP___assert(GPIO_BASE[GPIO_ID] != (hrt_address)-1);
-
-	timed_ctrl_snd_commnd(ID, mask, condition, counter,
-				GPIO_BASE[GPIO_ID]+offset, value);
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_local.h
deleted file mode 100644
index 2a87b532..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_local.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TIMED_CTRL_LOCAL_H_INCLUDED__
-#define __TIMED_CTRL_LOCAL_H_INCLUDED__
-
-#include "timed_ctrl_global.h"
-
-#endif /* __TIMED_CTRL_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_private.h
deleted file mode 100644
index 95cf28a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/timed_ctrl_private.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TIMED_CTRL_PRIVATE_H_INCLUDED__
-#define __TIMED_CTRL_PRIVATE_H_INCLUDED__
-
-#include "timed_ctrl_public.h"
-
-#include "device_access.h"
-
-#include "assert_support.h"
-
-STORAGE_CLASS_TIMED_CTRL_C void timed_ctrl_reg_store(
-	const timed_ctrl_ID_t	ID,
-	const unsigned int		reg,
-	const hrt_data			value)
-{
-OP___assert(ID < N_TIMED_CTRL_ID);
-OP___assert(TIMED_CTRL_BASE[ID] != (hrt_address)-1);
-	device_store_uint32(TIMED_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
-return;
-}
-
-#endif /* __GP_DEVICE_PRIVATE_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/vamem_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/vamem_local.h
deleted file mode 100644
index 6f93b6e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/host/vamem_local.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __VAMEM_LOCAL_H_INCLUDED__
-#define __VAMEM_LOCAL_H_INCLUDED__
-
-#include "vamem_global.h"
-
-#endif /* __VAMEM_LOCAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_formatter_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_formatter_global.h
deleted file mode 100644
index 0e4d714..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_formatter_global.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_FORMATTER_GLOBAL_H_INCLUDED__
-#define __INPUT_FORMATTER_GLOBAL_H_INCLUDED__
-
-#define IS_INPUT_FORMATTER_VERSION1
-
-#include "stdint.h"
-
-#include "if_defs.h"
-
-typedef struct input_formatter_cfg_s	input_formatter_cfg_t;
-
-/* Hardware registers */
-#define HIVE_IF_RESET_ADDRESS                   0x000
-#define HIVE_IF_START_LINE_ADDRESS              0x004
-#define HIVE_IF_START_COLUMN_ADDRESS            0x008
-#define HIVE_IF_CROPPED_HEIGHT_ADDRESS          0x00C
-#define HIVE_IF_CROPPED_WIDTH_ADDRESS           0x010
-#define HIVE_IF_VERTICAL_DECIMATION_ADDRESS     0x014
-#define HIVE_IF_HORIZONTAL_DECIMATION_ADDRESS   0x018
-#define HIVE_IF_H_DEINTERLEAVING_ADDRESS        0x01C
-#define HIVE_IF_LEFTPADDING_WIDTH_ADDRESS       0x020
-#define HIVE_IF_END_OF_LINE_OFFSET_ADDRESS      0x024
-#define HIVE_IF_VMEM_START_ADDRESS_ADDRESS      0x028
-#define HIVE_IF_VMEM_END_ADDRESS_ADDRESS        0x02C
-#define HIVE_IF_VMEM_INCREMENT_ADDRESS          0x030
-#define HIVE_IF_YUV_420_FORMAT_ADDRESS          0x034
-#define HIVE_IF_VSYNCK_ACTIVE_LOW_ADDRESS       0x038
-#define HIVE_IF_HSYNCK_ACTIVE_LOW_ADDRESS       0x03C
-#define HIVE_IF_ALLOW_FIFO_OVERFLOW_ADDRESS     0x040
-#define HIVE_IF_BLOCK_FIFO_NO_REQ_ADDRESS       0x044
-#define HIVE_IF_V_DEINTERLEAVING_ADDRESS        0x048
-/* Registers only for simulation */
-#define HIVE_IF_CRUN_MODE_ADDRESS               0x04C
-#define HIVE_IF_DUMP_OUTPUT_ADDRESS             0x050
-
-/* Follow the DMA syntax, "cmd" last */
-#define IF_PACK(val, cmd)             ((val & 0x0fff) | (cmd /*& 0xf000*/))
-
-/*
- * This data structure is shared between host and SP
- */
-struct input_formatter_cfg_s {
-	uint32_t	start_line;
-	uint32_t	start_column;
-	uint32_t	left_padding;
-	uint32_t	cropped_height;
-	uint32_t	cropped_width;
-	uint32_t	deinterleaving;
-	uint32_t	buf_vecs;
-	uint32_t	buf_start_index;
-	uint32_t	buf_increment;
-	uint32_t	buf_eol_offset;
-	uint32_t	is_yuv420_format;
-	uint32_t	block_no_reqs;
-};
-
-#endif /* __INPUT_FORMATTER_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_system_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_system_global.h
deleted file mode 100644
index 2f6bb06b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/input_system_global.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
-#define __INPUT_SYSTEM_GLOBAL_H_INCLUDED__
-
-#define IS_INPUT_SYSTEM_VERSION_1
-
-#include <stdint.h>
-#include <css_receiver_ahb_defs.h>
-
-#define _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX \
-	_HRT_CSS_RECEIVER_AHB_IRQ_STATUS_REG_IDX
-#define _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT \
-	_HRT_CSS_RECEIVER_AHB_IRQ_OVERRUN_BIT
-
-typedef enum {
-	MIPI_0LANE_CFG = 0,
-	MIPI_1LANE_CFG = 1,
-	MIPI_4LANE_CFG = 4
-} mipi_lane_cfg_t;
-
-typedef enum {
-	INPUT_SYSTEM_SOURCE_SENSOR = 0,
-	INPUT_SYSTEM_SOURCE_FIFO,
-	INPUT_SYSTEM_SOURCE_TPG,
-	INPUT_SYSTEM_SOURCE_PRBS,
-	INPUT_SYSTEM_SOURCE_MEMORY,
-	N_INPUT_SYSTEM_SOURCE,
-} input_system_source_t;
-
-typedef enum {
-	INPUT_SYSTEM_SINK_MEMORY = 0,
-	INPUT_SYSTEM_SINK_ISP,
-	INPUT_SYSTEM_SINK_SP,
-	N_INPUT_SYSTEM_SINK,
-} input_system_sink_t;
-
-typedef struct input_system_cfg_s	input_system_cfg_t;
-typedef struct sync_generator_cfg_s	sync_generator_cfg_t;
-typedef struct tpg_cfg_s			tpg_cfg_t;
-typedef struct prbs_cfg_s			prbs_cfg_t;
-
-/* MW: uint16_t should be sufficient */
-struct input_system_cfg_s {
-	uint32_t	no_side_band;
-	uint32_t	fmt_type;
-	uint32_t	ch_id;
-	uint32_t	input_mode;
-};
-
-struct sync_generator_cfg_s {
-	uint32_t	width;
-	uint32_t	height;
-	uint32_t	hblank_cycles;
-	uint32_t	vblank_cycles;
-};
-
-/* MW: tpg & prbs are exclusive */
-struct tpg_cfg_s {
-	uint32_t	x_mask;
-	uint32_t	y_mask;
-	uint32_t	x_delta;
-	uint32_t	y_delta;
-	uint32_t	xy_mask;
-};
-
-struct prbs_cfg_s {
-	uint32_t	seed;
-};
-
-/*
-static const hrt_address MIPI_PORT_OFFSET[N_MIPI_PORT_ID] = {
-	0x00000100UL,
-	0x00000200UL};
-*/
-
-#endif /* __INPUT_SYSTEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/irq_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/irq_global.h
deleted file mode 100644
index 81e178b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/irq_global.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __IRQ_GLOBAL_H_INCLUDED__
-#define __IRQ_GLOBAL_H_INCLUDED__
-
-#define IS_IRQ_VERSION_1
-#define IS_IRQ_MAP_VERSION_1
-
-/* We cannot include the file defining the "CSS_RECEIVER" property without side effects */
-#ifndef HAS_NO_RX
-#define CSS_RECEIVER testbench_isp_css_receiver
-#endif
-#include "hive_isp_css_irq_types_hrt.h"	/* enum	hrt_isp_css_irq */
-
-/* The IRQ is not mapped uniformly on its related interfaces */
-#define	IRQ_SW_CHANNEL_OFFSET	hrt_isp_css_irq_sw_0
-
-typedef enum {
-	IRQ_SW_CHANNEL0_ID = hrt_isp_css_irq_sw_0 - IRQ_SW_CHANNEL_OFFSET,
-	IRQ_SW_CHANNEL1_ID = hrt_isp_css_irq_sw_1 - IRQ_SW_CHANNEL_OFFSET,
-/* deprecated; Do not use this channel */
-	IRQ_SW_CHANNEL2_ID = hrt_isp_css_irq_sw_2 - IRQ_SW_CHANNEL_OFFSET,
-	N_IRQ_SW_CHANNEL_ID
-} irq_sw_channel_id_t;
-
-#endif /* __IRQ_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/isp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/isp_global.h
deleted file mode 100644
index 52b2cef..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/isp_global.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __ISP_GLOBAL_H_INCLUDED__
-#define __ISP_GLOBAL_H_INCLUDED__
-
-#include <stdint.h>
-
-#define IS_ISP_2300_MEDFIELD
-
-#include "isp2300_medfield_params.h"
-
-#define ISP_PMEM_WIDTH_LOG2		9
-#define ISP_PMEM_SIZE			ISP_PMEM_DEPTH
-
-#define ISP_NWAY_LOG2			6
-#define ISP_VEC_NELEMS_LOG2		ISP_NWAY_LOG2
-
-/* The number of data bytes in a vector disregarding the reduced precision */
-#define ISP_VEC_BYTES			(ISP_VEC_NELEMS*sizeof(uint16_t))
-
-/* ISP Registers */
-#define ISP_PC_REG				0x05
-#define ISP_SC_REG				0x00
-#define ISP_IRQ_READY_REG		0x00
-#define ISP_IRQ_CLEAR_REG		0x00
-#define ISP_BROKEN_BIT			0x04
-#define ISP_IDLE_BIT			0x05
-#define ISP_STALLING_BIT		0x07
-#define ISP_IRQ_CLEAR_BIT		0x08
-#define ISP_IRQ_READY_BIT		0x0A
-#define ISP_SLEEPING_BIT		0x0B
-
-#define ISP_CTRL_SINK_REG		0x06
-#define ISP_DMEM_SINK_REG		0x06
-#define ISP_VMEM_SINK_REG		0x06
-#define ISP_FIFO0_SINK_REG		0x06
-#define ISP_FIFO1_SINK_REG		0x06
-#define ISP_FIFO2_SINK_REG		0x06
-#define ISP_FIFO3_SINK_REG		0x06
-#define ISP_FIFO4_SINK_REG		0x06
-#define ISP_FIFO5_SINK_REG		0x06
-#define ISP_VAMEM1_SINK_REG		0x06
-#define ISP_VAMEM2_SINK_REG		0x06
-
-/* ISP Register bits */
-#define ISP_CTRL_SINK_BIT		0x00
-#define ISP_DMEM_SINK_BIT		0x01
-#define ISP_VMEM_SINK_BIT		0x02
-#define ISP_FIFO0_SINK_BIT		0x03
-#define ISP_FIFO1_SINK_BIT		0x04
-#define ISP_FIFO2_SINK_BIT		0x05
-#define ISP_FIFO3_SINK_BIT		0x06
-#define ISP_FIFO4_SINK_BIT		0x07
-#define ISP_FIFO5_SINK_BIT		0x08
-#define ISP_VAMEM1_SINK_BIT		0x09
-#define ISP_VAMEM2_SINK_BIT		0x0A
-
-#endif /* __ISP_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/mmu_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/mmu_global.h
deleted file mode 100644
index 71852bb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/mmu_global.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __MMU_GLOBAL_H_INCLUDED__
-#define __MMU_GLOBAL_H_INCLUDED__
-
-#define IS_MMU_VERSION_1
-
-#include <mmu_defs.h>
-
-#endif /* __MMU_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/resource_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/resource_global.h
deleted file mode 100644
index eba77a3..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/resource_global.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __RESOURCE_GLOBAL_H_INCLUDED__
-#define __RESOURCE_GLOBAL_H_INCLUDED__
-
-#define IS_RESOURCE_VERSION_1
-
-typedef enum {
-	DMA_CHANNEL_RESOURCE_TYPE,
-	IRQ_CHANNEL_RESOURCE_TYPE,
-	MEM_SECTION_RESOURCE_TYPE,
-	N_RESOURCE_TYPE
-} resource_type_ID_t;
-
-typedef enum {
-	PERMANENT_RESOURCE_RESERVATION,
-	PERSISTENT_RESOURCE_RESERVATION,
-	DEDICTATED_RESOURCE_RESERVATION,
-	SHARED_RESOURCE_RESERVATION,
-	N_RESOURCE_RESERVATION
-} resource_reservation_t;
-
-#endif /* __RESOURCE_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/sp_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/sp_global.h
deleted file mode 100644
index 55240a8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/sp_global.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SP_GLOBAL_H_INCLUDED__
-#define __SP_GLOBAL_H_INCLUDED__
-
-#define IS_SP_2300
-
-#include <scalar_processor_params.h>
-
-#define SP_PMEM_WIDTH_LOG2		SP_PMEM_LOG_WIDTH_BITS
-#define SP_PMEM_SIZE			SP_PMEM_DEPTH
-
-#define SP_DMEM_SIZE			0x4000
-
-/* SP Registers */
-#define SP_PC_REG				0x09
-#define SP_SC_REG				0x00
-#define SP_START_ADDR_REG		0x01
-#define SP_ICACHE_ADDR_REG		0x05
-#define SP_IRQ_READY_REG		0x00
-#define SP_IRQ_CLEAR_REG		0x00
-#define SP_ICACHE_INV_REG		0x00
-#define SP_CTRL_SINK_REG		0x0A
-
-/* SP Register bits */
-#define SP_START_BIT			0x01
-#define SP_RUN_BIT				0x03
-#define SP_BROKEN_BIT			0x04
-#define SP_IDLE_BIT				0x05
-#define SP_STALLING_BIT			0x07
-#define SP_IRQ_CLEAR_BIT		0x08
-#define SP_IRQ_READY_BIT		0x0A
-#define SP_SLEEPING_BIT			0x0B
-#define SP_ICACHE_INV_BIT		0x0C
-
-#define SP_FIFO0_SINK_BIT		0x00
-#define SP_FIFO1_SINK_BIT		0x01
-#define SP_FIFO2_SINK_BIT		0x02
-#define SP_FIFO3_SINK_BIT		0x03
-#define SP_FIFO4_SINK_BIT		0x04
-#define SP_FIFO5_SINK_BIT		0x05
-#define SP_FIFO6_SINK_BIT		0x06
-#define SP_FIFO7_SINK_BIT		0x07
-#define SP_DMEM_SINK_BIT		0x08
-#define SP_CTRL_MT_SINK_BIT		0x09
-#define SP_ICACHE_MT_SINK_BIT	0x0A
-
-#define SP_FIFO0_SINK_REG		0x0A
-#define SP_FIFO1_SINK_REG		0x0A
-#define SP_FIFO2_SINK_REG		0x0A
-#define SP_FIFO3_SINK_REG		0x0A
-#define SP_FIFO4_SINK_REG		0x0A
-#define SP_FIFO5_SINK_REG		0x0A
-#define SP_FIFO6_SINK_REG		0x0A
-#define SP_FIFO7_SINK_REG		0x0A
-#define SP_DMEM_SINK_REG		0x0A
-#define SP_CTRL_MT_SINK_REG		0x0A
-#define SP_ICACHE_MT_SINK_REG	0x0A
-
-#endif /* __SP_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/system_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/system_global.h
deleted file mode 100644
index c2ec596..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/system_global.h
+++ /dev/null
@@ -1,206 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __SYSTEM_GLOBAL_H_INCLUDED__
-#define __SYSTEM_GLOBAL_H_INCLUDED__
-
-#include <hive_isp_css_defs.h>	/* HIVE_ISP_DDR_WORD_BITS, ... */
-#define HIVE_ISP_DDR_WORD_BYTES  (HIVE_ISP_DDR_WORD_BITS/8)
-
-/*
- * The longest allowed (uninteruptible) bus transfer, does not
- * take stalling into account
- */
-#define HIVE_ISP_MAX_BURST_LENGTH	128
-
-/*
- * Create a list of HAS and IS properties that defines the system
- * these definitions should be used for platform specific code
- * control rather than the cell/device specific defines which
- * differ per cell/scope
- *
- * Those properties should be moved to the system API (like the
- * register maps in sh_css_hw.h)
- *
- * The configuration assumes the following
- * - The system is hetereogeneous; Multiple cells and devices classes
- * - The cell and device instances are homogeneous, each device type
- *   belongs to the same class
- * - Device instances supporting a subset of the class capabilities are
- *   allowed
- *
- * We could manage different device classes through the enumerated
- * lists (C) or the use of classes (C++), but that is presently not
- * supported
- */
-
-#include <stdint.h>
-
-#define IS_ISP_2300_SYSTEM
-#define IS_ISP_2300_MEDFIELD_SYSTEM
-
-#define HAS_ISP_2300_MEDFIELD
-#define HAS_SP_2300
-#define HAS_MMU_VERSION_1
-#define HAS_DMA_VERSION_1
-#define HAS_GDC_VERSION_1
-#define HAS_VAMEM_VERSION_1
-#define HAS_BAMEM_VERSION_1
-#define HAS_NO_HMEM
-#define HAS_IRQ_VERSION_1
-#define HAS_IRQ_MAP_VERSION_1
-#define HAS_INPUT_SYSTEM_VERSION_1
-#define HAS_INPUT_FORMATTER_VERSION_1
-#define HAS_FIFO_MONITORS_VERSION_1
-#define HAS_GP_DEVICE_VERSION_1
-#define HAS_GPIO_VERSION_1
-#define HAS_TIMED_CTRL_VERSION_1
-#define HAS_RX_VERSION_1
-
-/*
- * Semi global. "HRT" is accessible from SP, but the HRT types do not fully apply
- */
-#define HRT_VADDRESS_WIDTH	32
-//#define HRT_ADDRESS_WIDTH	32		/* Surprise, this is a local property*/
-#define HRT_DATA_WIDTH		32
-
-#define SIZEOF_HRT_REG		(HRT_DATA_WIDTH>>3)
-#define HIVE_ISP_CTRL_DATA_BYTES (HIVE_ISP_CTRL_DATA_WIDTH/8)
-
-/* The main bus connecting all devices */
-#define HRT_BUS_WIDTH		HIVE_ISP_CTRL_DATA_WIDTH
-#define HRT_BUS_BYTES		HIVE_ISP_CTRL_DATA_BYTES
-
-typedef uint32_t			hrt_bus_align_t;
-
-/*
- * Enumerate the devices, device access through the API is by ID, through the DLI by address
- * The enumerator terminators are used to size the wiring arrays and as an exception value.
- */
-typedef enum {
-	DDR0_ID = 0,
-	N_DDR_ID
-} ddr_ID_t;
-
-typedef enum {
-	ISP0_ID = 0,
-	N_ISP_ID
-} isp_ID_t;
-
-typedef enum {
-	SP0_ID = 0,
-	N_SP_ID
-} sp_ID_t;
-
-typedef enum {
-	MMU0_ID = 0,
-	N_MMU_ID
-} mmu_ID_t;
-
-typedef enum {
-	DMA0_ID = 0,
-	N_DMA_ID
-} dma_ID_t;
-
-typedef enum {
-	GDC0_ID = 0,
-	N_GDC_ID
-} gdc_ID_t;
-
-typedef enum {
-	VAMEM0_ID = 0,
-	VAMEM1_ID,
-	N_VAMEM_ID
-} vamem_ID_t;
-
-typedef enum {
-	BAMEM0_ID = 0,
-	N_BAMEM_ID
-} bamem_ID_t;
-
-typedef enum {
-	N_HMEM_ID
-} hmem_ID_t;
-
-typedef enum {
-	IRQ0_ID = 0,
-	N_IRQ_ID
-} irq_ID_t;
-
-typedef enum {
-	FIFO_MONITOR0_ID = 0,
-	N_FIFO_MONITOR_ID
-} fifo_monitor_ID_t;
-
-typedef enum {
-	GP_DEVICE0_ID = 0,
-	N_GP_DEVICE_ID
-} gp_device_ID_t;
-
-typedef enum {
-	GPIO0_ID = 0,
-	N_GPIO_ID
-} gpio_ID_t;
-
-typedef enum {
-	TIMED_CTRL0_ID = 0,
-	N_TIMED_CTRL_ID
-} timed_ctrl_ID_t;
-
-typedef enum {
-	INPUT_FORMATTER0_ID = 0,
-	INPUT_FORMATTER1_ID,
-	N_INPUT_FORMATTER_ID
-} input_formatter_ID_t;
-
-typedef enum {
-	INPUT_SYSTEM0_ID = 0,
-	N_INPUT_SYSTEM_ID
-} input_system_ID_t;
-
-typedef enum {
-	RX0_ID = 0,
-	N_RX_ID
-} rx_ID_t;
-
-typedef enum {
-	MIPI_PORT0_ID = 0,
-	MIPI_PORT1_ID,
-	N_MIPI_PORT_ID
-} mipi_port_ID_t;
-
-#define	N_RX_CHANNEL_ID		4
-
-/* Generic port enumeration with an internal port type ID */
-typedef enum {
-	CSI_PORT0_ID = 0,
-	CSI_PORT1_ID,
-	TPG_PORT0_ID,
-	PRBS_PORT0_ID,
-	FIFO_PORT0_ID,
-	MEMORY_PORT0_ID,
-	N_INPUT_PORT_ID
-} input_port_ID_t;
-
-/* 2300 input system has no sub-systems */
-typedef enum {
-	UNIT0_ID = 0,
-	N_SUB_SYSTEM_ID
-} sub_system_ID_t;
-
-typedef enum {
-	IRQ_EVENT_TYPE0 = 0,
-	N_IRQ_EVENT_TYPE
-} irq_event_type;
-
-#endif /* __SYSTEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/timed_ctrl_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/timed_ctrl_global.h
deleted file mode 100644
index 127e0c0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/timed_ctrl_global.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __TIMED_CTRL_GLOBAL_H_INCLUDED__
-#define __TIMED_CTRL_GLOBAL_H_INCLUDED__
-
-#define IS_TIMED_CTRL_VERSION_1
-
-#include <timed_controller_defs.h>
-
-/* order of the input bits for the timed controller */
-#define HIVE_TIMED_CTRL_GPIO_PIN_0_BIT_ID                       0
-#define HIVE_TIMED_CTRL_GPIO_PIN_1_BIT_ID                       1
-#define HIVE_TIMED_CTRL_GPIO_PIN_2_BIT_ID                       2
-#define HIVE_TIMED_CTRL_GPIO_PIN_3_BIT_ID                       3
-#define HIVE_TIMED_CTRL_GPIO_PIN_4_BIT_ID                       4
-#define HIVE_TIMED_CTRL_GPIO_PIN_5_BIT_ID                       5
-#define HIVE_TIMED_CTRL_GPIO_PIN_6_BIT_ID                       6
-#define HIVE_TIMED_CTRL_GPIO_PIN_7_BIT_ID                       7
-#define HIVE_TIMED_CTRL_GPIO_PIN_8_BIT_ID                       8
-#define HIVE_TIMED_CTRL_GPIO_PIN_9_BIT_ID                       9
-#define HIVE_TIMED_CTRL_SP_BIT_ID                              10
-#define HIVE_TIMED_CTRL_ISP_BIT_ID                             11
-#define HIVE_TIMED_CTRL_MIPI_RCV_IRQ_BIT_ID                    12
-#define HIVE_TIMED_CTRL_IFMT_BIT_ID                            13
-#define HIVE_TIMED_CTRL_IFMT_B_BIT_ID                          14
-#define HIVE_TIMED_CTRL_IFMT_SEC_BIT_ID                        15
-#define HIVE_TIMED_CTRL_MEM_CPY_BIT_ID                         16
-#define HIVE_TIMED_CTRL_MIPI_FIFO_FULL_BIT_ID                  17
-#define HIVE_TIMED_CTRL_MIPI_SOF_BIT_ID                        18
-#define HIVE_TIMED_CTRL_MIPI_EOF_BIT_ID                        19
-#define HIVE_TIMED_CTRL_MIPI_SOL_BIT_ID                        20
-#define HIVE_TIMED_CTRL_MIPI_EOL_BIT_ID                        21
-#define HIVE_TIMED_CTRL_SYNC_GEN_SOF_BIT_ID                    22
-#define HIVE_TIMED_CTRL_SYNC_GEN_EOF_BIT_ID                    23
-#define HIVE_TIMED_CTRL_SYNC_GEN_SOL_BIT_ID                    24
-#define HIVE_TIMED_CTRL_SYNC_GEN_EOL_BIT_ID                    25
-
-
-#endif /* __TIMED_CTRL_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/vamem_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/vamem_global.h
deleted file mode 100644
index 2dd5345..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hive_isp_css_system/vamem_global.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef __VAMEM_GLOBAL_H_INCLUDED__
-#define __VAMEM_GLOBAL_H_INCLUDED__
-
-#include <stdint.h>
-
-#define IS_VAMEM_VERSION_1
-
-/* (log) stepsize of linear interpolation */
-#define VAMEM_INTERP_STEP_LOG2	0
-#define VAMEM_INTERP_STEP		(1<<VAMEM_INTERP_STEP_LOG2)
-/* (physical) size of the tables */
-#define VAMEM_TABLE_UNIT_SIZE	ISP_VAMEM_DEPTH
-/* (logical) size of the tables */
-#define VAMEM_TABLE_UNIT_STEP	VAMEM_TABLE_UNIT_SIZE
-/* Number of tables */
-#define VAMEM_TABLE_UNIT_COUNT	(ISP_VAMEM_DEPTH/VAMEM_TABLE_UNIT_STEP)
-
-typedef uint16_t				vamem_data_t;
-
-#endif /* __VAMEM_GLOBAL_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/bits.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/bits.h
deleted file mode 100644
index af592d7..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/bits.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _HRT_BITS_H
-#define _HRT_BITS_H
-
-#include "defs.h"
-
-#define _hrt_ones(n) HRTCAT(_hrt_ones_, n)
-#define _hrt_ones_0x0  0x00000000U
-#define _hrt_ones_0x1  0x00000001U
-#define _hrt_ones_0x2  0x00000003U
-#define _hrt_ones_0x3  0x00000007U
-#define _hrt_ones_0x4  0x0000000FU
-#define _hrt_ones_0x5  0x0000001FU
-#define _hrt_ones_0x6  0x0000003FU
-#define _hrt_ones_0x7  0x0000007FU
-#define _hrt_ones_0x8  0x000000FFU
-#define _hrt_ones_0x9  0x000001FFU
-#define _hrt_ones_0xA  0x000003FFU
-#define _hrt_ones_0xB  0x000007FFU
-#define _hrt_ones_0xC  0x00000FFFU
-#define _hrt_ones_0xD  0x00001FFFU
-#define _hrt_ones_0xE  0x00003FFFU
-#define _hrt_ones_0xF  0x00007FFFU
-#define _hrt_ones_0x10 0x0000FFFFU
-#define _hrt_ones_0x11 0x0001FFFFU
-#define _hrt_ones_0x12 0x0003FFFFU
-#define _hrt_ones_0x13 0x0007FFFFU
-#define _hrt_ones_0x14 0x000FFFFFU
-#define _hrt_ones_0x15 0x001FFFFFU
-#define _hrt_ones_0x16 0x003FFFFFU
-#define _hrt_ones_0x17 0x007FFFFFU
-#define _hrt_ones_0x18 0x00FFFFFFU
-#define _hrt_ones_0x19 0x01FFFFFFU
-#define _hrt_ones_0x1A 0x03FFFFFFU
-#define _hrt_ones_0x1B 0x07FFFFFFU
-#define _hrt_ones_0x1C 0x0FFFFFFFU
-#define _hrt_ones_0x1D 0x1FFFFFFFU
-#define _hrt_ones_0x1E 0x3FFFFFFFU
-#define _hrt_ones_0x1F 0x7FFFFFFFU
-#define _hrt_ones_0x20 0xFFFFFFFFU
-
-#define _hrt_ones_0  _hrt_ones_0x0
-#define _hrt_ones_1  _hrt_ones_0x1
-#define _hrt_ones_2  _hrt_ones_0x2
-#define _hrt_ones_3  _hrt_ones_0x3
-#define _hrt_ones_4  _hrt_ones_0x4
-#define _hrt_ones_5  _hrt_ones_0x5
-#define _hrt_ones_6  _hrt_ones_0x6
-#define _hrt_ones_7  _hrt_ones_0x7
-#define _hrt_ones_8  _hrt_ones_0x8
-#define _hrt_ones_9  _hrt_ones_0x9
-#define _hrt_ones_10 _hrt_ones_0xA
-#define _hrt_ones_11 _hrt_ones_0xB
-#define _hrt_ones_12 _hrt_ones_0xC
-#define _hrt_ones_13 _hrt_ones_0xD
-#define _hrt_ones_14 _hrt_ones_0xE
-#define _hrt_ones_15 _hrt_ones_0xF
-#define _hrt_ones_16 _hrt_ones_0x10
-#define _hrt_ones_17 _hrt_ones_0x11
-#define _hrt_ones_18 _hrt_ones_0x12
-#define _hrt_ones_19 _hrt_ones_0x13
-#define _hrt_ones_20 _hrt_ones_0x14
-#define _hrt_ones_21 _hrt_ones_0x15
-#define _hrt_ones_22 _hrt_ones_0x16
-#define _hrt_ones_23 _hrt_ones_0x17
-#define _hrt_ones_24 _hrt_ones_0x18
-#define _hrt_ones_25 _hrt_ones_0x19
-#define _hrt_ones_26 _hrt_ones_0x1A
-#define _hrt_ones_27 _hrt_ones_0x1B
-#define _hrt_ones_28 _hrt_ones_0x1C
-#define _hrt_ones_29 _hrt_ones_0x1D
-#define _hrt_ones_30 _hrt_ones_0x1E
-#define _hrt_ones_31 _hrt_ones_0x1F
-#define _hrt_ones_32 _hrt_ones_0x20
-
-#define _hrt_mask(b, n) \
-  (_hrt_ones(n) << (b))
-#define _hrt_get_bits(w, b, n) \
-  (((w) >> (b)) & _hrt_ones(n))
-#define _hrt_set_bits(w, b, n, v) \
-  (((w) & ~_hrt_mask(b, n)) | (((v) & _hrt_ones(n)) << (b)))
-#define _hrt_get_bit(w, b) \
-  (((w) >> (b)) & 1)
-#define _hrt_set_bit(w, b, v) \
-  (((w) & (~(1 << (b)))) | (((v)&1) << (b)))
-#define _hrt_set_lower_half(w, v) \
-  _hrt_set_bits(w, 0, 16, v)
-#define _hrt_set_upper_half(w, v) \
-  _hrt_set_bits(w, 16, 16, v)
-
-#endif /* _HRT_BITS_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/cell_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/cell_params.h
deleted file mode 100644
index 55ec7f9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/cell_params.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _cell_params_h
-#define _cell_params_h
-
-#define SP_PMEM_LOG_WIDTH_BITS           6  /*Width of PC, 64 bits, 8 bytes*/
-#define SP_ICACHE_TAG_BITS               4  /*size of tag*/
-#define SP_ICACHE_SET_BITS               8  /* 256 sets*/
-#define SP_ICACHE_BLOCKS_PER_SET_BITS    1  /* 2 way associative*/
-#define SP_ICACHE_BLOCK_ADDRESS_BITS     11 /* 2048 lines capacity*/
-
-#define SP_ICACHE_ADDRESS_BITS \
-	                    (SP_ICACHE_TAG_BITS+SP_ICACHE_BLOCK_ADDRESS_BITS)
-
-#define SP_PMEM_DEPTH        (1<<SP_ICACHE_ADDRESS_BITS)
-
-#define SP_FIFO_0_DEPTH      0
-#define SP_FIFO_1_DEPTH      0
-#define SP_FIFO_2_DEPTH      0
-#define SP_FIFO_3_DEPTH      0
-#define SP_FIFO_4_DEPTH      0
-#define SP_FIFO_5_DEPTH      0
-#define SP_FIFO_6_DEPTH      0
-#define SP_FIFO_7_DEPTH      0
-
-
-#define SP_SLV_BUS_MAXBURSTSIZE        1
-
-#endif /* _cell_params_h */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/css_receiver_ahb_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/css_receiver_ahb_defs.h
deleted file mode 100644
index 1a70275..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/css_receiver_ahb_defs.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _css_receiver_ahb_defs_h_
-#define _css_receiver_ahb_defs_h_
-
-#define CSS_RECEIVER_DATA_WIDTH                8
-#define CSS_RECEIVER_RX_TRIG                   4
-#define CSS_RECEIVER_RF_WORD                  32
-#define CSS_RECEIVER_IMG_PROC_RF_ADDR         10
-#define CSS_RECEIVER_CSI_RF_ADDR               4
-#define CSS_RECEIVER_DATA_OUT                 12
-#define CSS_RECEIVER_CHN_NO                    2
-#define CSS_RECEIVER_DWORD_CNT                11
-#define CSS_RECEIVER_FORMAT_TYP                5
-#define CSS_RECEIVER_HRESPONSE                 2
-#define CSS_RECEIVER_STATE_WIDTH               3
-#define CSS_RECEIVER_FIFO_DAT                 32
-#define CSS_RECEIVER_CNT_VAL                   2
-#define CSS_RECEIVER_PRED10_VAL               10
-#define CSS_RECEIVER_PRED12_VAL               12
-#define CSS_RECEIVER_CNT_WIDTH                 8
-#define CSS_RECEIVER_WORD_CNT                 16
-#define CSS_RECEIVER_PIXEL_LEN                 6
-#define CSS_RECEIVER_PIXEL_CNT                 5
-#define CSS_RECEIVER_COMP_8_BIT                8
-#define CSS_RECEIVER_COMP_7_BIT                7
-#define CSS_RECEIVER_COMP_6_BIT                6
-#define CSS_RECEIVER_GEN_SHORT_DATA_WIDTH     16
-#define CSS_RECEIVER_GEN_SHORT_CH_ID_WIDTH     2
-#define CSS_RECEIVER_GEN_SHORT_FMT_TYPE_WIDTH  3
-#define CSS_RECEIVER_GEN_SHORT_STR_REAL_WIDTH (CSS_RECEIVER_GEN_SHORT_DATA_WIDTH + CSS_RECEIVER_GEN_SHORT_CH_ID_WIDTH + CSS_RECEIVER_GEN_SHORT_FMT_TYPE_WIDTH)
-#define CSS_RECEIVER_GEN_SHORT_STR_WIDTH      32 /* use 32 to be compatibel with streaming monitor !, MSB's of interface are tied to '0' */ 
-
-/* division of gen_short data, ch_id and fmt_type over streaming data interface */
-#define CSS_RECEIVER_GEN_SHORT_STR_DATA_BIT_LSB     0
-#define CSS_RECEIVER_GEN_SHORT_STR_FMT_TYPE_BIT_LSB (CSS_RECEIVER_GEN_SHORT_STR_DATA_BIT_LSB     + CSS_RECEIVER_GEN_SHORT_DATA_WIDTH)
-#define CSS_RECEIVER_GEN_SHORT_STR_CH_ID_BIT_LSB    (CSS_RECEIVER_GEN_SHORT_STR_FMT_TYPE_BIT_LSB + CSS_RECEIVER_GEN_SHORT_FMT_TYPE_WIDTH)
-#define CSS_RECEIVER_GEN_SHORT_STR_DATA_BIT_MSB     (CSS_RECEIVER_GEN_SHORT_STR_FMT_TYPE_BIT_LSB - 1)
-#define CSS_RECEIVER_GEN_SHORT_STR_FMT_TYPE_BIT_MSB (CSS_RECEIVER_GEN_SHORT_STR_CH_ID_BIT_LSB    - 1)
-#define CSS_RECEIVER_GEN_SHORT_STR_CH_ID_BIT_MSB    (CSS_RECEIVER_GEN_SHORT_STR_REAL_WIDTH       - 1)
-
-#define _HRT_CSS_RECEIVER_AHB_REG_ALIGN 4
-
-#define hrt_css_receiver_ahb_4_lane_port_offset 0x100
-#define hrt_css_receiver_ahb_1_lane_port_offset 0x200
-
-#define _HRT_CSS_RECEIVER_AHB_DEVICE_READY_REG_IDX      0
-#define _HRT_CSS_RECEIVER_AHB_IRQ_STATUS_REG_IDX        1
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ENABLE_REG_IDX        2
-#define _HRT_CSS_RECEIVER_AHB_CSI2_FUNC_PROG_REG_IDX    3
-#define _HRT_CSS_RECEIVER_AHB_INIT_COUNT_REG_IDX        4
-#define _HRT_CSS_RECEIVER_AHB_COMP_FORMAT_REG_IDX       5
-#define _HRT_CSS_RECEIVER_AHB_COMP_PREDICT_REG_IDX      6
-#define _HRT_CSS_RECEIVER_AHB_FS_TO_LS_DELAY_REG_IDX    7
-#define _HRT_CSS_RECEIVER_AHB_LS_TO_DATA_DELAY_REG_IDX  8
-#define _HRT_CSS_RECEIVER_AHB_DATA_TO_LE_DELAY_REG_IDX  9
-#define _HRT_CSS_RECEIVER_AHB_LE_TO_FE_DELAY_REG_IDX   10
-#define _HRT_CSS_RECEIVER_AHB_FE_TO_FS_DELAY_REG_IDX   11
-#define _HRT_CSS_RECEIVER_AHB_LE_TO_LS_DELAY_REG_IDX   12
-#define _HRT_CSS_RECEIVER_AHB_TWO_PIXEL_EN_REG_IDX     13
-
-/* Interrupt bits for IRQ_STATUS and IRQ_ENABLE registers */
-#define _HRT_CSS_RECEIVER_AHB_IRQ_OVERRUN_BIT                0
-#define _HRT_CSS_RECEIVER_AHB_IRQ_RESERVED_BIT               1
-#define _HRT_CSS_RECEIVER_AHB_IRQ_SLEEP_MODE_ENTRY_BIT       2
-#define _HRT_CSS_RECEIVER_AHB_IRQ_SLEEP_MODE_EXIT_BIT        3
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_SOT_HS_BIT             4
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_SOT_SYNC_HS_BIT        5
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_CONTROL_BIT            6
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_DOUBLE_BIT         7
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_CORRECTED_BIT      8
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_NO_CORRECTION_BIT  9
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_CRC_BIT               10
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ID_BIT                11
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_FRAME_SYNC_BIT        12
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_FRAME_DATA_BIT        13
-#define _HRT_CSS_RECEIVER_AHB_IRQ_DATA_TIMEOUT_BIT          14
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ESCAPE_BIT            15
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_LINE_SYNC_BIT         16
-
-#define _HRT_CSS_RECEIVER_AHB_IRQ_OVERRUN_CAUSE_                  "Fifo Overrun"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_RESERVED_CAUSE_                 "Reserved"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_SLEEP_MODE_ENTRY_CAUSE_         "Sleep mode entry"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_SLEEP_MODE_EXIT_CAUSE_          "Sleep mode exit"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_SOT_HS_CAUSE_               "Error high speed SOT"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_SOT_SYNC_HS_CAUSE_          "Error high speed sync SOT"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_CONTROL_CAUSE_              "Error control"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_DOUBLE_CAUSE_           "Error correction double bit"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_CORRECTED_CAUSE_        "Error correction single bit"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ECC_NO_CORRECTION_CAUSE_    "No error"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_CRC_CAUSE_                  "Error cyclic redundancy check"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ID_CAUSE_                   "Error id"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_FRAME_SYNC_CAUSE_           "Error frame sync"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_FRAME_DATA_CAUSE_           "Error frame data"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_DATA_TIMEOUT_CAUSE_             "Data time-out"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_ESCAPE_CAUSE_               "Error escape"
-#define _HRT_CSS_RECEIVER_AHB_IRQ_ERR_LINE_SYNC_CAUSE_            "Error line sync"
-                                  
-/* Bits for CSI2_FUNC_PROG register */
-#define _HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_IDX  0
-#define _HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_BITS 3
-#define _HRT_CSS_RECEIVER_AHB_CSI2_DATA_TIMEOUT_IDX    (_HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_IDX + _HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_BITS)
-#define _HRT_CSS_RECEIVER_AHB_CSI2_DATA_TIMEOUT_BITS   29
-
-/* Bits for INIT_COUNT register */
-#define _HRT_CSS_RECEIVER_AHB_INIT_TIMER_IDX  0
-#define _HRT_CSS_RECEIVER_AHB_INIT_TIMER_BITS 16
-
-/* Bits for COMP_FORMAT register, this selects the compression data format */
-#define _HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_IDX  0
-#define _HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_BITS 8
-#define _HRT_CSS_RECEIVER_AHB_COMP_NUM_BITS_IDX  (_HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_IDX + _HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_BITS)
-#define _HRT_CSS_RECEIVER_AHB_COMP_NUM_BITS_BITS 8
-
-/* Bits for COMP_PREDICT register, this selects the predictor algorithm */
-#define _HRT_CSS_RECEIVER_AHB_PREDICT_NO_COMP 0
-#define _HRT_CSS_RECEIVER_AHB_PREDICT_1       1
-#define _HRT_CSS_RECEIVER_AHB_PREDICT_2       2
-
-/* Number of bits used for the delay registers */
-#define _HRT_CSS_RECEIVER_AHB_DELAY_BITS 8
-
-/* These hsync and vsync values are for HSS simulation only */
-#define _HRT_CSS_RECEIVER_AHB_HSYNC_VAL (1<<16)
-#define _HRT_CSS_RECEIVER_AHB_VSYNC_VAL (1<<17)
-
-/* Definition of format_types */
-/* !! Changes here should be copied to systems/isp/isp_css/bin/conv_transmitter_cmd.tcl !! */
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RGB888           0 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RGB555           1 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RGB444           2 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RGB565           3 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RGB666           4 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RAW8             5 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RAW10            6 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RAW6             7 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RAW7             8 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RAW12            9 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_RAW14           10 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_YUV420_8        11 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_YUV420_10       12 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_YUV422_8        13 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_YUV422_10       14 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_1       15 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_YUV420_8L       16 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_Emb             17 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_2       18 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_3       19 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_4       20 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_5       21 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_6       22 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_7       23 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_USR_DEF_8       24 
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_YUV420_8_CSPS   25
-#define _HRT_CSS_RECEIVER_AHB_FMT_TYPE_YUV420_10_CSPS  26
-
-
-#endif /* _css_receiver_ahb_defs_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/defs.h
deleted file mode 100644
index f95c33e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/defs.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _HRT_DEFS_H_
-#define _HRT_DEFS_H_
-
-#ifndef HRTCAT
-#define _HRTCAT(m, n)     m##n
-#define HRTCAT(m, n)      _HRTCAT(m, n)
-#endif
-
-#ifndef HRTSTR
-#define _HRTSTR(x)   #x
-#define HRTSTR(x)    _HRTSTR(x)
-#endif
-
-#ifndef HRTMIN
-#define HRTMIN(a, b) (((a) < (b)) ? (a) : (b))
-#endif
-
-#ifndef HRTMAX
-#define HRTMAX(a, b) (((a) > (b)) ? (a) : (b))
-#endif
-
-#endif /* _HRT_DEFS_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/dma_v1_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/dma_v1_defs.h
deleted file mode 100644
index a770391..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/dma_v1_defs.h
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _dma_v1_defs_h
-#define _dma_v1_defs_h
-
-#define _DMA_V1_NUM_CHANNELS_ID               MaxNumChannels
-#define _DMA_V1_CONNECTIONS_ID                Connections
-#define _DMA_V1_DEV_ELEM_WIDTHS_ID            DevElemWidths
-#define _DMA_V1_DEV_FIFO_DEPTH_ID             DevFifoDepth
-#define _DMA_V1_DEV_FIFO_RD_LAT_ID            DevFifoRdLat
-#define _DMA_V1_DEV_FIFO_LAT_BYPASS_ID        DevFifoRdLatBypass
-#define _DMA_V1_DEV_2_CIO_ID                  DevConnectedToCIO
-#define _DMA_V1_DEV_HAS_CRUN_ID               CRunMasters
-#define _DMA_V1_CONN_GROUPS_ID                ConnectionGroups
-#define _DMA_V1_CONN_GROUP_FIFO_DEPTH_ID      ConnectionGroupFifoDepth
-#define _DMA_V1_CONN_GROUP_FIFO_RD_LAT_ID     ConnectionGroupFifoRdLat
-#define _DMA_V1_CONN_GROUP_FIFO_LAT_BYPASS_ID ConnectionGroupFifoRdLatBypass
-
-#define _DMA_V1_REG_ALIGN                4
-#define _DMA_V1_REG_ADDR_BITS            2
-
-/* Command word */
-#define _DMA_CMD_IDX         0
-#define _DMA_CMD_BITS        4
-#define _DMA_CHANNEL_IDX     (_DMA_CMD_IDX + _DMA_CMD_BITS)
-#define _DMA_CHANNEL_BITS    8
-#define _DMA_PARAM_IDX       (_DMA_CHANNEL_IDX + _DMA_CHANNEL_BITS)
-#define _DMA_PARAM_BITS      4
-#define _DMA_CRUN_IDX        (_DMA_PARAM_IDX + _DMA_PARAM_BITS)
-#define _DMA_CRUN_BITS       1
-
-/* Packing setup word */
-#define _DMA_CONNECTION_IDX  0
-#define _DMA_CONNECTION_BITS 8
-#define _DMA_EXTENSION_IDX   (_DMA_CONNECTION_IDX + _DMA_CONNECTION_BITS)
-#define _DMA_EXTENSION_BITS  4
-#define _DMA_ELEM_ORDER_IDX  (_DMA_EXTENSION_IDX + _DMA_EXTENSION_BITS)
-#define _DMA_ELEM_ORDER_BITS 4
-
-/* Elements packing word */
-#define _DMA_ELEMENTS_IDX        0
-#define _DMA_ELEMENTS_BITS      12
-#define _DMA_LEFT_CROPPING_IDX  (_DMA_ELEMENTS_IDX + _DMA_ELEMENTS_BITS)
-#define _DMA_LEFT_CROPPING_BITS 12
-
-#define _DMA_WIDTH_IDX   0
-#define _DMA_WIDTH_BITS 16
-
-#define _DMA_HEIGHT_IDX   0
-#define _DMA_HEIGHT_BITS 16
-
-#define _DMA_STRIDE_IDX   0
-#define _DMA_STRIDE_BITS 32
-
-/* Command IDs */
-#define _DMA_READ_COMMAND              0
-#define _DMA_WRITE_COMMAND             1
-#define _DMA_CONFIG_CHANNEL_COMMAND    2
-#define _DMA_SET_CHANNEL_PARAM_COMMAND 3
-#define _DMA_INIT_COMMAND              8
-#define _DMA_RESET_COMMAND            15
-
-/* Channel Parameter IDs */
-#define _DMA_PACKING_SETUP_PARAM   0
-#define _DMA_STRIDE_A_PARAM        1
-#define _DMA_ELEM_CROPPING_A_PARAM 2
-#define _DMA_WIDTH_A_PARAM         3
-#define _DMA_STRIDE_B_PARAM        4
-#define _DMA_ELEM_CROPPING_B_PARAM 5
-#define _DMA_WIDTH_B_PARAM         6
-#define _DMA_HEIGHT_PARAM          7
-
-/* Parameter Constants */
-#define _DMA_ZERO_EXTEND     0
-#define _DMA_SIGN_EXTEND     1
-#define _DMA_REVERSE_ELEMS   1
-#define _DMA_KEEP_ELEM_ORDER 0
-
-  /* SLAVE address map */
-#define _DMA_SEL_FSM_CMD                           0
-#define _DMA_SEL_CH_REG                            1
-#define _DMA_SEL_CONN_GROUP                        2
-#define _DMA_SEL_DEV_INTERF                        3
-#define _DMA_SEL_RESET                             15
-
-#define _DMA_RESET_TOKEN                  0xDEADCAFE
-
-#define _DMA_SEL_CONN_CMD                          0
-#define _DMA_SEL_CONN_ADDRESS_A                    1
-#define _DMA_SEL_CONN_ADDRESS_B                    2
-#define _DMA_SEL_FSM_CONN_CTRL                     3
-#define _DMA_SEL_FSM_PACK                          4
-#define _DMA_SEL_FSM_REQ                           5
-#define _DMA_SEL_FSM_WR                            6
-  
-#define _DMA_ADDR_SEL_COMP_IDX                    12
-#define _DMA_ADDR_SEL_COMP_BITS                    4
-#define _DMA_ADDR_SEL_CH_REG_IDX                   2
-#define _DMA_ADDR_SEL_CH_REG_BITS                  6
-#define _DMA_ADDR_SEL_PARAM_IDX                    8
-#define _DMA_ADDR_SEL_PARAM_BITS                   4
-
-#define _DMA_ADDR_SEL_GROUP_IDX                    2
-#define _DMA_ADDR_SEL_GROUP_BITS                   3
-#define _DMA_ADDR_SEL_GROUP_COMP_IDX               5
-#define _DMA_ADDR_SEL_GROUP_COMP_BITS              3
-#define _DMA_ADDR_SEL_GROUP_COMP_INFO_IDX          8
-#define _DMA_ADDR_SEL_GROUP_COMP_INFO_BITS         4
-
-#define _DMA_ADDR_SEL_DEV_INTERF_IDX_IDX           2
-#define _DMA_ADDR_SEL_DEV_INTERF_IDX_BITS          6
-#define _DMA_ADDR_SEL_DEV_INTERF_INFO_IDX          8
-#define _DMA_ADDR_SEL_DEV_INTERF_INFO_BITS         4
-
-#define _DMA_FSM_GROUP_CMD_IDX                     0
-#define _DMA_FSM_GROUP_ADDR_A_IDX                  1
-#define _DMA_FSM_GROUP_ADDR_B_IDX                  2
-#define _DMA_FSM_GROUP_FSM_CTRL_IDX                3
-#define _DMA_FSM_GROUP_FSM_PACK_IDX                4
-#define _DMA_FSM_GROUP_FSM_REQ_IDX                 5
-#define _DMA_FSM_GROUP_FSM_WR_IDX                  6
-  
-#define _DMA_FSM_GROUP_FSM_CTRL_STATE_IDX          0
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_DEV_IDX        1
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_ADDR_IDX       2
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_STRIDE_IDX     3
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_XB_IDX         4
-#define _DMA_FSM_GROUP_FSM_CTRL_REQ_YB_IDX         5
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_DEV_IDX   6
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_DEV_IDX    7
-#define _DMA_FSM_GROUP_FSM_CTRL_WR_ADDR_IDX        8
-#define _DMA_FSM_GROUP_FSM_CTRL_WR_STRIDE_IDX      9
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_REQ_XB_IDX   10
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_YB_IDX    11
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_WR_XB_IDX    12
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_REQ_IDX 13
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_ELEM_WR_IDX  14
-#define _DMA_FSM_GROUP_FSM_CTRL_PACK_S_Z_REV_IDX  15
-
-#define _DMA_FSM_GROUP_FSM_PACK_STATE_IDX          0
-#define _DMA_FSM_GROUP_FSM_PACK_CNT_YB_IDX         1
-#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_REQ_IDX     2
-#define _DMA_FSM_GROUP_FSM_PACK_CNT_XB_WR_IDX      3
-
-#define _DMA_FSM_GROUP_FSM_REQ_STATE_IDX           0
-#define _DMA_FSM_GROUP_FSM_REQ_CNT_YB_IDX          1
-#define _DMA_FSM_GROUP_FSM_REQ_CNT_XB_IDX          2
-
-#define _DMA_FSM_GROUP_FSM_WR_STATE_IDX            0
-#define _DMA_FSM_GROUP_FSM_WR_CNT_YB_IDX           1
-#define _DMA_FSM_GROUP_FSM_WR_CNT_XB_IDX           2
-
-#define _DMA_DEV_INTERF_REQ_SIDE_STATUS_IDX        0
-#define _DMA_DEV_INTERF_SEND_SIDE_STATUS_IDX       1
-#define _DMA_DEV_INTERF_FIFO_STATUS_IDX            2
-#define _DMA_DEV_INTERF_MAX_BURST_IDX              3
-#define _DMA_DEV_INTERF_CHK_ADDR_ALIGN             4
-
-#endif /* _dma_v1_defs_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/embed.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/embed.h
deleted file mode 100644
index a63d2bb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/embed.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _HRT_EMBED_H_
-#define _HRT_EMBED_H_
-
-#define _hrt_cell_dummy_use_blob(prog) \
-	HRTCAT(_hrt_dummy_use_blob_, prog)()
-#define _hrt_program_transfer_func(prog) \
-	HRTCAT(_hrt_transfer_embedded_, prog)
-#define _hrt_program_blob(prog) \
-	(HRTCAT(_hrt_blob_, prog).data)
-#define hrt_embedded_program_size(prog) \
-	HRTCAT(_hrt_size_of_, prog)
-#define hrt_embedded_program_text_size(prog) \
-	HRTCAT(_hrt_text_size_of_, prog)
-
-#endif /* _HRT_EMBED_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gdc_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gdc_defs.h
deleted file mode 100644
index 10b3d9a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gdc_defs.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _gdc_defs_h_
-#define _gdc_defs_h_
-
-#define HRT_GDC_N_BITS               6
-#define HRT_GDC_N                     64
-
-/* GDC lookup tables entries are 10 bits values, but they're
-   stored 2 by 2 as 32 bit values, yielding 16 bits per entry.
-   A GDC lookup table contains 64 * 4 elements */
-#define HRT_GDC_LUT_BYTES             ((HRT_GDC_N * 4) * 2)
-
-#define HRT_GDC_BLI_COEF_BITS              5
-#define HRT_GDC_BLI_COEF_SHIFT             (HRT_GDC_BLI_COEF_BITS - 1)
-#define HRT_GDC_BLI_COEF_ONE               (1 << HRT_GDC_BLI_COEF_SHIFT)
-
-#define HRT_GDC_BCI_COEF_BITS             10
-#define HRT_GDC_BCI_COEF_MASK              ((1 << HRT_GDC_BCI_COEF_BITS) - 1)
-#define HRT_GDC_BCI_COEF_SHIFT             (HRT_GDC_BCI_COEF_BITS - 2)
-#define HRT_GDC_BCI_COEF_ONE               (1 << HRT_GDC_BCI_COEF_SHIFT)
-
-#define HRT_GDC_COORD_FRAC_BITS        4
-#define HRT_GDC_COORD_ONE              (1 << HRT_GDC_COORD_FRAC_BITS)
-
-#define HRT_GDC_MAX_GDC_IPY_16NWAY    (15*HRT_GDC_COORD_ONE - 1)
-#define HRT_GDC_MAX_GDC_IPY_32NWAY    (26*HRT_GDC_COORD_ONE - 1)
-#define HRT_GDC_MAX_GDC_IPY_64NWAY    (49*HRT_GDC_COORD_ONE - 1)
-
-#define _HRT_GDC_REG_ALIGN         4
-
-#define HRT_GDC_NND_CMD               4
-#define HRT_GDC_BLI_CMD               5
-#define HRT_GDC_BCI_CMD               6
-#define HRT_GDC_GD_CAC_CMD            7
-#define HRT_GDC_CONFIG_CMD            8
-
-/* This is how commands are packed into one fifo token */
-#define HRT_GDC_CMD_DATA_POS         16 
-#define HRT_GDC_CMD_DATA_BITS        16 
-#define HRT_GDC_CMD_BITS              4 
-#define HRT_GDC_REG_ID_BITS           8 
-#define HRT_GDC_CRUN_BIT              (HRT_GDC_CMD_BITS + HRT_GDC_REG_ID_BITS)
-
-#define HRT_GDC_MODE_IDX              0  
-#define HRT_GDC_BPP_IDX               1  
-#define HRT_GDC_END_IDX               2  
-#define HRT_GDC_WOIX_IDX              3  
-#define HRT_GDC_WOIY_IDX              4  
-#define HRT_GDC_STX_IDX               5  
-#define HRT_GDC_STY_IDX               6  
-#define HRT_GDC_OXDIM_IDX             7  
-#define HRT_GDC_OYDIM_IDX             8  
-#define HRT_GDC_SRC_ADDR_IDX          9  
-#define HRT_GDC_SRC_END_ADDR_IDX     10 
-#define HRT_GDC_SRC_WRAP_ADDR_IDX    11 
-#define HRT_GDC_SRC_STRIDE_IDX       12 
-#define HRT_GDC_DST_ADDR_IDX         13 
-#define HRT_GDC_DST_STRIDE_IDX       14 
-#define HRT_GDC_DX_IDX               15 
-#define HRT_GDC_DY_IDX               16 
-#define HRT_GDC_P0X_IDX              17 
-#define HRT_GDC_P1X_IDX              18 
-#define HRT_GDC_P2X_IDX              19 
-#define HRT_GDC_P3X_IDX              20 
-#define HRT_GDC_P0Y_IDX              21 
-#define HRT_GDC_P1Y_IDX              22 
-#define HRT_GDC_P2Y_IDX              23 
-#define HRT_GDC_P3Y_IDX              24 
-#define HRT_GDC_SOFT_RST_IDX         25 
-
-#ifndef __HIVECC
-#define HRT_GDC_ELEM_WIDTH_IDX       26 /* Only for csim */
-#define HRT_GDC_ELEMS_PER_WORD_IDX   27 /* Only for csim */
-#define HRT_GDC_BYTES_PER_WORD_IDX   28 /* Only for csim */
-#define HRT_GDC_CRUN_IDX             29 /* Only for csim */
-#endif
-
-#define HRT_GDC_LUT_IDX              32 
-
-#define HRT_GDC_MAX_DX		     1023
-#define HRT_GDC_MAX_DY		     1023
-#define HRT_GDC_MAX_PX		     (128*16)
-#define HRT_GDC_MAX_PY		     (64*16)
-#define HRT_GDC_MAX_WOIX	     2048
-#define HRT_GDC_MAX_WOIY	     16
-#define HRT_GDC_MAX_OXDIM	     4096
-#define HRT_GDC_MAX_OYDIM	     64
-
-#endif /* _gdc_defs_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gp_regs_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gp_regs_defs.h
deleted file mode 100644
index a8c06a1..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gp_regs_defs.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _gp_regs_defs_h
-#define _gp_regs_defs_h
-
-#define _HRT_GP_REGS_IS_FWD_REG_IDX 0
-
-#define _HRT_GP_REGS_REG_ALIGN 4
-
-#endif /* _gp_regs_defs_h */   
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gpio_block_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gpio_block_defs.h
deleted file mode 100644
index c81eeb5..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/gpio_block_defs.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _gpio_block_defs_h_
-#define _gpio_block_defs_h_
-
-#define _HRT_GPIO_BLOCK_REG_ALIGN 4
-
-/* R/W registers */
-#define _gpio_block_reg_do_e			         0
-#define _gpio_block_reg_do_select		       1
-#define _gpio_block_reg_do_0			         2
-#define _gpio_block_reg_do_1			         3
-#define _gpio_block_reg_do_pwm_cnt_0	     4
-#define _gpio_block_reg_do_pwm_cnt_1	     5
-#define _gpio_block_reg_do_pwm_cnt_2	     6
-#define _gpio_block_reg_do_pwm_cnt_3	     7
-#define _gpio_block_reg_do_pwm_main_cnt    8
-#define _gpio_block_reg_do_pwm_enable      9
-#define _gpio_block_reg_di_debounce_sel	  10
-#define _gpio_block_reg_di_debounce_cnt_0	11
-#define _gpio_block_reg_di_debounce_cnt_1	12
-#define _gpio_block_reg_di_debounce_cnt_2	13
-#define _gpio_block_reg_di_debounce_cnt_3	14
-#define _gpio_block_reg_di_active_level	  15
-
-
-/* read-only registers */
-#define _gpio_block_reg_di			          16
-
-#endif /* _gpio_block_defs_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_defs.h
deleted file mode 100644
index e50efa2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_defs.h
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _hive_isp_css_defs_h
-#define _hive_isp_css_defs_h
-
-#define HIVE_ISP_CTRL_DATA_WIDTH     32
-#define HIVE_ISP_CTRL_ADDRESS_WIDTH  32
-#define HIVE_ISP_CTRL_MAX_BURST_SIZE  1
-#define HIVE_ISP_NUM_GPIO_PINS       10
-
-/* This list of vector num_elems/elem_bits pairs is valid both
-   in C as initializer and in the DMA parameter list */
-#define HIVE_ISP_DDR_DMA_SPECS \
-    { {32,  8}, {16, 16}, {18, 14}, {25, 10}, {21, 12} }
-#define HIVE_ISP_DDR_WORD_BITS      256
-#define HIVE_ISP_DDR_WORD_BYTES     (HIVE_ISP_DDR_WORD_BITS/8)
-#define HIVE_ISP_DDR_BYTES          (256 * 1024 * 1024)
-#define HIVE_ISP_DDR_BYTES_RTL      ( 16 * 1024 * 1024)
-
-#define HIVE_ISP_PAGE_SHIFT         12
-#define HIVE_ISP_PAGE_SIZE          (1<<HIVE_ISP_PAGE_SHIFT)
-
-/* If HIVE_ISP_DDR_BASE_OFFSET is set to a non-zero value,
- * the wide bus just before the DDRAM gets an extra dummy port where
- * address range 0 .. HIVE_ISP_DDR_BASE_OFFSET-1 maps onto.
- * This effectively creates an offset for the DDRAM from system perspective.
- */
-#define HIVE_ISP_DDR_BASE_OFFSET 0 /* 0x200000 */
-
-#define HIVE_DMA_ISP_BUS_CONN 0
-#define HIVE_DMA_ISP_DDR_CONN 1
-#define HIVE_DMA_BUS_DDR_CONN 2
-#define HIVE_DMA_ISP_MASTER master_port0
-#define HIVE_DMA_BUS_MASTER master_port1
-#define HIVE_DMA_DDR_MASTER master_port2
-#define HIVE_DMA_NUM_CHANNELS       8
-
-#define HIVE_IF_PIXEL_WIDTH 12
-
-#define HIVE_MMU_TLB_SETS           16
-#define HIVE_MMU_TLB_SET_BLOCKS     8
-#define HIVE_MMU_TLB_BLOCK_ELEMENTS 8
-#define HIVE_MMU_PAGE_TABLE_LEVELS  2
-#define HIVE_MMU_PAGE_BYTES         HIVE_ISP_PAGE_SIZE
-
-#define HIVE_ISP_CH_ID_BITS    2
-#define HIVE_ISP_FMT_TYPE_BITS 5
-#define HIVE_ISP_ISEL_SEL_BITS 2
-
-/* gp_register register id's   */
-#define HIVE_GP_REGS_SWITCH_IF_IDX                              0
-#define HIVE_GP_REGS_SWITCH_DMA_IDX                             1
-#define HIVE_GP_REGS_SWITCH_GDC_IDX                             2
-
-#define HIVE_GP_REGS_SYNCGEN_ENABLE_IDX                         3
-#define HIVE_GP_REGS_SYNCGEN_NR_PIX_IDX                         4
-#define HIVE_GP_REGS_SYNCGEN_NR_LINES_IDX                       5
-#define HIVE_GP_REGS_SYNCGEN_HBLANK_CYCLES_IDX                  6
-#define HIVE_GP_REGS_SYNCGEN_VBLANK_CYCLES_IDX                  7
-
-#define HIVE_GP_REGS_ISEL_SOF_IDX                               8
-#define HIVE_GP_REGS_ISEL_EOF_IDX                               9
-#define HIVE_GP_REGS_ISEL_SOL_IDX                              10
-#define HIVE_GP_REGS_ISEL_EOL_IDX                              11
-
-#define HIVE_GP_REGS_PRBS_ENABLE                               12
-#define HIVE_GP_REGS_PRBS_ENABLE_PORT_B                        13
-#define HIVE_GP_REGS_PRBS_LFSR_RESET_VALUE                     14
-
-#define HIVE_GP_REGS_TPG_ENABLE                                15
-#define HIVE_GP_REGS_TPG_ENABLE_PORT_B                         16
-#define HIVE_GP_REGS_TPG_HOR_CNT_MASK_IDX                      17
-#define HIVE_GP_REGS_TPG_VER_CNT_MASK_IDX                      18
-#define HIVE_GP_REGS_TPG_XY_CNT_MASK_IDX                       19
-#define HIVE_GP_REGS_TPG_HOR_CNT_DELTA_IDX                     20
-#define HIVE_GP_REGS_TPG_VER_CNT_DELTA_IDX                     21
-
-#define HIVE_GP_REGS_ISEL_CH_ID_IDX                            22
-#define HIVE_GP_REGS_ISEL_FMT_TYPE_IDX                         23
-#define HIVE_GP_REGS_ISEL_DATA_SEL_IDX                         24
-#define HIVE_GP_REGS_ISEL_SBAND_SEL_IDX                        25
-#define HIVE_GP_REGS_ISEL_SYNC_SEL_IDX                         26
-
-/* HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_? have to be sequential ! */
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_0                    27
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_1                    28
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_2                    29
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_3                    30
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_4                    31
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_5                    32
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_6                    33
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_7                    34
-
-#define HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_BASE \
-	HIVE_GP_REGS_INPUT_SWITCH_LUT_REG_0
-#define HIVE_GP_REGS_INPUT_SWITCH_FSYNC_LUT_REG                35
-
-#define HIVE_GP_REGS_SDRAM_WAKEUP_IDX                          36
-#define HIVE_GP_REGS_IDLE_IDX                                  37
-#define HIVE_GP_REGS_IRQ_IDX                                   38
-
-#define HIVE_GP_REGS_MIPI_FIFO_FULL                            39
-#define HIVE_GP_REGS_MIPI_USED_DWORD                           40
-
-#define HIVE_GP_REGS_SP_STREAM_STAT                            41
-#define HIVE_GP_REGS_MOD_STREAM_STAT                           42
-#define HIVE_GP_REGS_ISP_STREAM_STAT                           43
-
-#define HIVE_GP_REGS_CH_ID_FMT_TYPE_IDX                        44
-
-/* order of the input bits for the irq controller */
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_0_BIT_ID             0
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_1_BIT_ID             1
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_2_BIT_ID             2
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_3_BIT_ID             3
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_4_BIT_ID             4
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_5_BIT_ID             5
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_6_BIT_ID             6
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_7_BIT_ID             7
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_8_BIT_ID             8
-#define HIVE_TESTBENCH_IRQ_SOURCE_GPIO_PIN_9_BIT_ID             9
-#define HIVE_TESTBENCH_IRQ_SOURCE_SP_BIT_ID                    10
-#define HIVE_TESTBENCH_IRQ_SOURCE_ISP_BIT_ID                   11
-#define HIVE_TESTBENCH_IRQ_SOURCE_MIPI_BIT_ID                  12
-#define HIVE_TESTBENCH_IRQ_SOURCE_PRIM_IF_BIT_ID               13
-#define HIVE_TESTBENCH_IRQ_SOURCE_PRIM_B_IF_BIT_ID             14
-#define HIVE_TESTBENCH_IRQ_SOURCE_SEC_IF_BIT_ID                15
-#define HIVE_TESTBENCH_IRQ_SOURCE_MEM_COPY_BIT_ID              16
-#define HIVE_TESTBENCH_IRQ_SOURCE_MIPI_FIFO_FULL_BIT_ID        17
-#define HIVE_TESTBENCH_IRQ_SOURCE_MIPI_SOF_BIT_ID              18
-#define HIVE_TESTBENCH_IRQ_SOURCE_MIPI_EOF_BIT_ID              19
-#define HIVE_TESTBENCH_IRQ_SOURCE_MIPI_SOL_BIT_ID              20
-#define HIVE_TESTBENCH_IRQ_SOURCE_MIPI_EOL_BIT_ID              21
-#define HIVE_TESTBENCH_IRQ_SOURCE_SYNC_GEN_SOF_BIT_ID          22
-#define HIVE_TESTBENCH_IRQ_SOURCE_SYNC_GEN_EOF_BIT_ID          23
-#define HIVE_TESTBENCH_IRQ_SOURCE_SYNC_GEN_SOL_BIT_ID          24
-#define HIVE_TESTBENCH_IRQ_SOURCE_SYNC_GEN_EOL_BIT_ID          25
-#define HIVE_TESTBENCH_IRQ_SOURCE_CSS_GEN_SHORT_VALID_BIT_ID   26
-#define HIVE_TESTBENCH_IRQ_SOURCE_CSS_GEN_SHORT_ACCEPT_BIT_ID  27
-#define HIVE_TESTBENCH_IRQ_SOURCE_SIDEBAND_CHANGED_BIT_ID      28
-
-#define HIVE_TESTBENCH_IRQ_SOURCE_SW_PIN_0_BIT_ID              29
-#define HIVE_TESTBENCH_IRQ_SOURCE_SW_PIN_1_BIT_ID              30
-#define HIVE_TESTBENCH_IRQ_SOURCE_SW_PIN_2_BIT_ID              31
-
-#define HIVE_ISP_NUM_USED_IRQ_INPUTS \
-	(HIVE_TESTBENCH_IRQ_SOURCE_SW_PIN_0_BIT_ID - \
-	 HIVE_TESTBENCH_IRQ_SOURCE_SP_BIT_ID)
-
-#define HIVE_GP_REGS_IRQ_REG_WIDTH \
-	(HIVE_ISP_CTRL_DATA_WIDTH - \
-	 HIVE_TESTBENCH_IRQ_SOURCE_SW_PIN_0_BIT_ID)
-
-/* testbench signals:       */
-
-/* GP adapter register ids  */
-#define HIVE_TESTBENCH_GPIO_DATA_OUT_REG_IDX                    0
-#define HIVE_TESTBENCH_GPIO_DIR_OUT_REG_IDX                     1
-#define HIVE_TESTBENCH_IRQ_REG_IDX                              2
-#define HIVE_TESTBENCH_SDRAM_WAKEUP_REG_IDX                     3
-#define HIVE_TESTBENCH_IDLE_REG_IDX                             4
-#define HIVE_TESTBENCH_GPIO_DATA_IN_REG_IDX                     5
-
-/* Signal monitor input bit ids */
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_O_BIT_ID         0
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_1_BIT_ID         1
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_2_BIT_ID         2
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_3_BIT_ID         3
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_4_BIT_ID         4
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_5_BIT_ID         5
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_6_BIT_ID         6
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_7_BIT_ID         7
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_8_BIT_ID         8
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_GPIO_PIN_9_BIT_ID         9
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_IRQ_PIN_BIT_ID           10
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_SDRAM_WAKEUP_PIN_BIT_ID  11
-#define HIVE_TESTBENCH_SIG_MON_SOURCE_IDLE_PIN_BIT_ID          12
-
-#endif /* _hive_isp_css_defs_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_host_ids_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_host_ids_hrt.h
deleted file mode 100644
index 581aa0f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_host_ids_hrt.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _hive_isp_css_host_ids_hrt_h_
-#define _hive_isp_css_host_ids_hrt_h_
-
-/* ISP_CSS identifiers */
-#define ISP           testbench_isp_isp
-#define SP            testbench_isp_scp
-#define IF_PRIM       testbench_isp_ift_prim
-#define IF_PRIM_B     testbench_isp_ift_prim_b
-#define IF_SEC        testbench_isp_ift_sec
-#define STR_TO_MEM    testbench_isp_mem_cpy
-#define CSS_RECEIVER  testbench_isp_css_receiver
-#define TC            testbench_isp_gpd_tc
-#define DMA           testbench_isp_isp_dma
-#define GDC           testbench_isp_gdc
-#define IRQ_CTRL      testbench_isp_gpd_irq_ctrl
-#define GPIO          testbench_isp_gpd_c_gpio
-#define GP_REGS       testbench_isp_gpd_gp_reg
-#define MMU           testbench_isp_c_mmu
-#define ISEL_FA       testbench_isp_gpd_fa_isel
-/* next is actually not FIFO but FIFO adapter, or slave to streaming adapter */
-#define ISP_SP_FIFO   testbench_isp_gpd_fa_sp_isp
-#define GP_FIFO       testbench_isp_gpd_sf_2isel_in
-#define FIFO_GPF_ISEL testbench_isp_gpd_sf_2isel_in
-#define FIFO_GPF_SP   testbench_isp_gpd_sf_gpf2sp_in
-#define FIFO_GPF_ISP  testbench_isp_gpd_sf_gpf2isp_in
-#define FIFO_SP_GPF   testbench_isp_gpd_sf_sp2gpf_in
-#define FIFO_ISP_GPF  testbench_isp_gpd_sf_isp2gpf_in
-#define OCP_MASTER    testbench_isp_cio2ocp_wide_data_out_mt
-#define IF_SEC_MASTER testbench_isp_ift_sec_mt_out
-#define SP_IN_FIFO    testbench_isp_gpd_sf_gpf2sp_in
-#define SP_OUT_FIFO   testbench_isp_gpd_sf_sp2gpf_out
-#define ISP_IN_FIFO   testbench_isp_gpd_sf_gpf2isp_in
-#define ISP_OUT_FIFO  testbench_isp_gpd_sf_isp2gpf_out
-#define GEN_SHORT_PACK_PORT testbench_isp_ModStrMon_out10
-
-/* Testbench identifiers */
-#define DDR           testbench_ddram
-#define XMEM          DDR
-#define GPIO_ADAPTER  testbench_gp_adapter
-#define SIG_MONITOR   testbench_sig_mon
-#define DDR_SLAVE     testbench_ddram_ip0
-#define HOST_MASTER   host_op0
-
-#endif /* _hive_isp_css_host_ids_hrt_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_if_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_if_hrt.h
deleted file mode 100644
index a7d3ace..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_if_hrt.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _HIVE_ISP_CSS_IF_HRT_H_
-#define _HIVE_ISP_CSS_IF_HRT_H_
-
-#ifdef _HIVE_ISP_CSS_FPGA_SYSTEM
-#define dev_sys_isp_clus_ift_prim_vector_alignment   ISP_VEC_ALIGN
-#define dev_sys_isp_clus_ift_prim_b_vector_alignment ISP_VEC_ALIGN
-#define dev_sys_isp_clus_ift_sec_vector_alignment \
-	(dev_sys_isp_clus_ift_sec_mt_out_data_width / 8)
-#define dev_sys_isp_clus_mem_cpy_vector_alignment \
-	(dev_sys_isp_clus_mem_cpy_mt_out_data_width / 8)
-#else
-#define testbench_isp_ift_prim_vector_alignment   ISP_VEC_ALIGN
-#define testbench_isp_ift_prim_b_vector_alignment ISP_VEC_ALIGN
-#define testbench_isp_ift_sec_vector_alignment \
-	(testbench_isp_ift_sec_mt_out_data_width / 8)
-#define testbench_isp_mem_cpy_vector_alignment \
-	(testbench_isp_mem_cpy_mt_out_data_width / 8)
-#endif
-
-#endif /* _HIVE_ISP_CSS_IF_HRT_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_irq_types_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_irq_types_hrt.h
deleted file mode 100644
index f273e4f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_irq_types_hrt.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_
-#define _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_
-
-/* these are the indices of each interrupt in the
- * interrupt controller's registers. these can be used
- * as the irq_id argument to the hrt functions irq_controller.h.
- */
-enum hrt_isp_css_irq {
-  hrt_isp_css_irq_gpio_0,
-  hrt_isp_css_irq_gpio_1,
-  hrt_isp_css_irq_gpio_2,
-  hrt_isp_css_irq_gpio_3,
-  hrt_isp_css_irq_gpio_4,
-  hrt_isp_css_irq_gpio_5,
-  hrt_isp_css_irq_gpio_6,
-  hrt_isp_css_irq_gpio_7,
-  hrt_isp_css_irq_gpio_8,
-  hrt_isp_css_irq_gpio_9,
-  hrt_isp_css_irq_sp,
-  hrt_isp_css_irq_isp,
-  hrt_isp_css_irq_mipi,
-  hrt_isp_css_irq_ift_prim,
-  hrt_isp_css_irq_ift_prim_b,
-  hrt_isp_css_irq_ift_sec,
-  hrt_isp_css_irq_ift_mem_cpy,
-  hrt_isp_css_irq_mipi_fifo_full,
-  hrt_isp_css_irq_mipi_sof,
-  hrt_isp_css_irq_mipi_eof,
-  hrt_isp_css_irq_mipi_sol,
-  hrt_isp_css_irq_mipi_eol,
-  hrt_isp_css_irq_syncgen_sof,
-  hrt_isp_css_irq_syncgen_eof,
-  hrt_isp_css_irq_syncgen_sol,
-  hrt_isp_css_irq_syncgen_eol,
-#ifdef CSS_RECEIVER
-  hrt_isp_css_irq_css_gen_short_0,
-  hrt_isp_css_irq_css_gen_short_1,
-  hrt_isp_css_irq_sideband_changed,
-#endif
-  /* The ASIC system has only 3 SW interrupts, so the FPGA system is limited
-   * by this to 3 as well. */
-  hrt_isp_css_irq_sw_0,
-  hrt_isp_css_irq_sw_1,
-  hrt_isp_css_irq_sw_2,
-  /* this must (obviously) be the last on in the enum */
-  hrt_isp_css_irq_num_irqs
-};
-
-enum hrt_isp_css_irq_status {
-  hrt_isp_css_irq_status_error,
-  hrt_isp_css_irq_status_more_irqs,
-  hrt_isp_css_irq_status_success
-};
-
-#endif /* _HIVE_ISP_CSS_IRQ_TYPES_HRT_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_monitors_types_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_monitors_types_hrt.h
deleted file mode 100644
index 1d21beb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_monitors_types_hrt.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _hive_isp_css_streaming_monitors_types_hrt_h
-#define _hive_isp_css_streaming_monitors_types_hrt_h
-
-#define _hive_str_mon_valid_offset   0
-#define _hive_str_mon_accept_offset  1
-
-#define SP_STR_MON_PORT_SND_PIF_A         0
-#define SP_STR_MON_PORT_RCV_PIF_A         1
-#define SP_STR_MON_PORT_SND_SIF           2
-#define SP_STR_MON_PORT_RCV_SIF           3
-#define SP_STR_MON_PORT_SND_MC            4
-#define SP_STR_MON_PORT_RCV_MC            5
-#define SP_STR_MON_PORT_SND_DMA           6
-#define SP_STR_MON_PORT_RCV_DMA           7
-#define SP_STR_MON_PORT_SND_GDC           8
-#define SP_STR_MON_PORT_RCV_GDC           9
-#define SP_STR_MON_PORT_SND_ISP          10
-#define SP_STR_MON_PORT_RCV_ISP          11
-#define SP_STR_MON_PORT_SND_GPD          12
-#define SP_STR_MON_PORT_RCV_GPD          13
-#define SP_STR_MON_PORT_SND_PIF_B        14
-#define SP_STR_MON_PORT_RCV_PIF_B        15
-
-#define MOD_STR_MON_PORT_SND_PIF_A        0
-#define MOD_STR_MON_PORT_RCV_PIF_A        1
-#define MOD_STR_MON_PORT_SND_SIF          2
-#define MOD_STR_MON_PORT_RCV_SIF          3
-#define MOD_STR_MON_PORT_SND_MC           4
-#define MOD_STR_MON_PORT_RCV_MC           5
-#define MOD_STR_MON_PORT_SND_DMA          6
-#define MOD_STR_MON_PORT_RCV_DMA          7
-#define MOD_STR_MON_PORT_SND_GDC          8
-#define MOD_STR_MON_PORT_RCV_GDC          9
-#define MOD_STR_MON_PORT_SND_CSS_REC     10
-
-#define ISP_STR_MON_PORT_SND_PIF_A        0
-#define ISP_STR_MON_PORT_RCV_PIF_A        1
-#define ISP_STR_MON_PORT_SND_PIF_B        2
-#define ISP_STR_MON_PORT_RCV_PIF_B        3
-#define ISP_STR_MON_PORT_SND_DMA          4
-#define ISP_STR_MON_PORT_RCV_DMA          5
-#define ISP_STR_MON_PORT_SND_GDC          6
-#define ISP_STR_MON_PORT_RCV_GDC          7
-#define ISP_STR_MON_PORT_SND_GPD          8
-#define ISP_STR_MON_PORT_RCV_GPD          9
-#define ISP_STR_MON_PORT_SND_SP          10
-#define ISP_STR_MON_PORT_RCV_SP          11
-
-#endif /* _hive_isp_css_streaming_monitors_types_hrt_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
deleted file mode 100644
index 47750f0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_isp_css_streaming_to_mipi_types_hrt.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _hive_isp_css_streaming_to_mipi_types_hrt_h_
-#define _hive_isp_css_streaming_to_mipi_types_hrt_h_
-
-#include <streaming_to_mipi_defs.h>
-
-#define _HIVE_ISP_CH_ID_MASK    ((1U << HIVE_ISP_CH_ID_BITS)-1)
-#define _HIVE_ISP_FMT_TYPE_MASK ((1U << HIVE_ISP_FMT_TYPE_BITS)-1)
-
-#define _HIVE_STR_TO_MIPI_FMT_TYPE_LSB \
-	(HIVE_STR_TO_MIPI_CH_ID_LSB + HIVE_ISP_CH_ID_BITS)
-#define _HIVE_STR_TO_MIPI_DATA_B_LSB \
-	(HIVE_STR_TO_MIPI_DATA_A_LSB + HIVE_IF_PIXEL_WIDTH)
-
-#endif /* _hive_isp_css_streaming_to_mipi_types_hrt_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_types.h
deleted file mode 100644
index 15d644e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/hive_types.h
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _HRT_HIVE_TYPES_H 
-#define _HRT_HIVE_TYPES_H 
-
-#include "version.h"
-#include "defs.h"
-
-#ifndef HRTCAT3
-#define _HRTCAT3(m,n,o)     m##n##o
-#define HRTCAT3(m,n,o)      _HRTCAT3(m,n,o)
-#endif
-
-#ifndef HRTCAT4
-#define _HRTCAT4(m,n,o,p)     m##n##o##p
-#define HRTCAT4(m,n,o,p)      _HRTCAT4(m,n,o,p)
-#endif
-
-#ifndef HRTMIN
-#define HRTMIN(a,b) (((a)<(b))?(a):(b))
-#endif
-                                 
-#ifndef HRTMAX
-#define HRTMAX(a,b) (((a)>(b))?(a):(b))
-#endif
-
-/* boolean data type */
-typedef unsigned int hive_bool;
-#define hive_false 0
-#define hive_true  1
-
-typedef char                 hive_int8;
-typedef short                hive_int16;
-typedef int                  hive_int32;
-typedef long long            hive_int64;
-
-typedef unsigned char        hive_uint8;
-typedef unsigned short       hive_uint16;
-typedef unsigned int         hive_uint32;
-typedef unsigned long long   hive_uint64;
-
-/* by default assume 32 bit master port (both data and address) */
-#ifndef HRT_DATA_WIDTH
-#define HRT_DATA_WIDTH 32
-#endif
-#ifndef HRT_ADDRESS_WIDTH
-#define HRT_ADDRESS_WIDTH 32
-#endif
-
-#define HRT_DATA_BYTES    (HRT_DATA_WIDTH/8)
-#define HRT_ADDRESS_BYTES (HRT_ADDRESS_WIDTH/8)
-
-#if HRT_DATA_WIDTH == 64
-typedef hive_uint64 hrt_data;
-#elif HRT_DATA_WIDTH == 32
-typedef hive_uint32 hrt_data;
-#else
-#error data width not supported
-#endif
-
-#if HRT_ADDRESS_WIDTH == 64
-typedef hive_uint64 hrt_address; 
-#elif HRT_ADDRESS_WIDTH == 32
-typedef hive_uint32 hrt_address;
-#else
-#error adddres width not supported
-#endif
-
-/* The SP side representation of an HMM virtual address */
-typedef hive_uint32 hrt_vaddress;
-
-/* use 64 bit addresses in simulation, where possible */
-typedef hive_uint64  hive_sim_address;
-
-/* below is for csim, not for hrt, rename and move this elsewhere */
-
-typedef unsigned int hive_uint;
-typedef hive_uint32  hive_address;
-typedef hive_address hive_slave_address;
-typedef hive_address hive_mem_address;
-
-/* MMIO devices */
-typedef hive_uint    hive_mmio_id;
-typedef hive_mmio_id hive_slave_id;
-typedef hive_mmio_id hive_port_id;
-typedef hive_mmio_id hive_master_id; 
-typedef hive_mmio_id hive_mem_id;
-typedef hive_mmio_id hive_dev_id;
-typedef hive_mmio_id hive_fifo_id;
-
-typedef hive_uint      hive_hier_id;
-typedef hive_hier_id   hive_device_id;
-typedef hive_device_id hive_proc_id;
-typedef hive_device_id hive_cell_id;
-typedef hive_device_id hive_host_id;
-typedef hive_device_id hive_bus_id;
-typedef hive_device_id hive_bridge_id;
-typedef hive_device_id hive_fifo_adapter_id;
-typedef hive_device_id hive_custom_device_id;
-
-typedef hive_uint hive_slot_id;
-typedef hive_uint hive_fu_id;
-typedef hive_uint hive_reg_file_id;
-typedef hive_uint hive_reg_id;
-
-/* Streaming devices */
-typedef hive_uint hive_outport_id;
-typedef hive_uint hive_inport_id;
-
-typedef hive_uint hive_msink_id;
-
-/* HRT specific */
-typedef char* hive_program;
-typedef char* hive_function;
-
-#endif /* _HRT_HIVE_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/if_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/if_defs.h
deleted file mode 100644
index 7fee792..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/if_defs.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _IF_DEFS_H
-#define _IF_DEFS_H
-
-#define HIVE_IF_FRAME_REQUEST        0xA000
-#define HIVE_IF_LINES_REQUEST        0xB000
-#define HIVE_IF_VECTORS_REQUEST      0xC000
-
-#endif /* _IF_DEFS_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/input_switch_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/input_switch_defs.h
deleted file mode 100644
index f4100db..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/input_switch_defs.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _input_switch_defs_h
-#define _input_switch_defs_h
-
-#define _HIVE_INPUT_SWITCH_GET_LUT_REG_ID(ch_id, fmt_type) (((ch_id)*2) + ((fmt_type)>=16))
-#define _HIVE_INPUT_SWITCH_GET_LUT_REG_LSB(fmt_type)        (((fmt_type)%16) * 2)
-
-#define HIVE_INPUT_SWITCH_SELECT_NO_OUTPUT   0
-#define HIVE_INPUT_SWITCH_SELECT_IF_PRIM     1
-#define HIVE_INPUT_SWITCH_SELECT_IF_SEC      2
-#define HIVE_INPUT_SWITCH_SELECT_STR_TO_MEM  3
-#define HIVE_INPUT_SWITCH_VSELECT_NO_OUTPUT  0
-#define HIVE_INPUT_SWITCH_VSELECT_IF_PRIM    1
-#define HIVE_INPUT_SWITCH_VSELECT_IF_SEC     2
-#define HIVE_INPUT_SWITCH_VSELECT_STR_TO_MEM 4
-
-#endif /* _input_switch_defs_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/irq_controller_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/irq_controller_defs.h
deleted file mode 100644
index c89e4c2..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/irq_controller_defs.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _irq_controller_defs_h
-#define _irq_controller_defs_h
-
-#define _HRT_IRQ_CONTROLLER_EDGE_REG_IDX           0
-#define _HRT_IRQ_CONTROLLER_MASK_REG_IDX           1
-#define _HRT_IRQ_CONTROLLER_STATUS_REG_IDX         2
-#define _HRT_IRQ_CONTROLLER_CLEAR_REG_IDX          3
-#define _HRT_IRQ_CONTROLLER_ENABLE_REG_IDX         4
-#define _HRT_IRQ_CONTROLLER_EDGE_NOT_PULSE_REG_IDX 5
-#define _HRT_IRQ_CONTROLLER_STR_OUT_ENABLE_REG_IDX 6
-
-#define _HRT_IRQ_CONTROLLER_REG_ALIGN 4
-
-#endif /* _irq_controller_defs_h */   
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/isp2300_medfield_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/isp2300_medfield_params.h
deleted file mode 100644
index 32a0153..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/isp2300_medfield_params.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-/* Version */
-#define ISP_VERSION SDK_VERSION
-
-/* Cell name  */
-
-#define ISP_CELL_TYPE         isp2300_medfield
-#define ISP_VMEM              simd_vmem
-#define _HRT_ISP_VMEM         isp2300_medfield_simd_vmem
-
-/* instruction pipeline depth */
-#define ISP_BRANCHDELAY       3
-
-/* bus */
-#define ISP_BUS_PROT          CIO
-#define ISP_BUS_WIDTH         32
-#define ISP_BUS_ADDR_WIDTH    32
-#define ISP_BUS_BURST_SIZE    1
-
-/* data-path */
-#define ISP_SCALAR_WIDTH      32
-#define ISP_SLICE_NELEMS      4
-#define ISP_VEC_NELEMS        64
-#define ISP_VEC_ELEMBITS      14
-#define ISP_VEC_ELEM8BITS     16
-#define ISP_ALPHA_BLEND_SHIFT 13
-
-
-/* memories */
-#define ISP_DMEM_DEPTH            4096
-#define ISP_VMEM_DEPTH            2048
-#define ISP_VMEM_ELEMBITS         14
-#define ISP_VMEM_ELEM_PRECISION   14
-#define ISP_PMEM_DEPTH            2048
-#define ISP_PMEM_WIDTH            448
-#define ISP_VAMEM_ADDRESS_BITS    13
-#define ISP_VAMEM_ELEMBITS        12
-#define ISP_VAMEM_DEPTH           4096
-#define ISP_VAMEM_ALIGNMENT       2
-#define ISP_VA_ADDRESS_WIDTH      896
-#define ISP_VEC_VALSU_LATENCY     ISP_VEC_NELEMS
-
-/* program counter */
-#define ISP_PC_WIDTH          12
-
-/* RSN pipelining */
-#define ISP_RSN_PIPE          0
-
-/* shrink instruction set */
-#define ISP_SHRINK_IS         0
-
-/* Template experiments */
-#define ISP_HAS_VARU_SIMD_IS1 0     
-#define ISP_HAS_SIMD_IS5      1     
-#define ISP_HAS_SIMD6_FLGU    0
-#define ISP_HAS_VALSU         1     
-#define ISP_SRU_GUARDING      1
-#define ISP_VRF_RAM     	    1
-#define ISP_SRF_RAM     	    1
-#define ISP_REDUCE_VARUS      0
-#define ISP_COMBINE_MAC_SHIFT 0    
-#define ISP_COMBINE_MAC_VARU  1    
-#define ISP_COMBINE_SHIFT_VARU 0    
-#define ISP_SLICE_LATENCY     1    
-#define ISP_RFSPLIT_EXP       0
-#define ISP_SPILL_MEM_EXP     0
-#define ISP_VHSU_NO_WIDE      0
-#define ISP_NO_SLICE          0
-#define ISP_BLOCK_SLICE       0
-#define ISP_IF                1
-#define ISP_IF_B              1
-#define ISP_DMA               0     
-#define ISP_OF                0     
-#define ISP_SYS_OF            1   
-#define ISP_GDC               1   
-#define ISP_GPIO              1    
-#define ISP_SP                1  
-#define ISP_HAS_IRQ           1
-
-/* derived values */
-#define ISP_VEC_WIDTH         896
-#define ISP_SLICE_WIDTH       56
-#define ISP_VMEM_ALIGN        128
-#define ISP_VMEM_WIDTH        896
-#define ISP_SIMDLSU           1
-#define ISP_LSU_IMM_BITS      12
-#define ISP_CRUN_VEC_ALIGN    
-
-/* convenient shortcuts for software*/
-#define ISP_NWAY              ISP_VEC_NELEMS 
-#define NBITS                       ISP_VEC_ELEMBITS
-
-#define _isp_ceil_div(a,b)          (((a)+(b)-1)/(b))
-
-#ifdef C_RUN
-#define ISP_VEC_ALIGN         (_isp_ceil_div(ISP_VEC_WIDTH, 64)*8)
-#else
-#define ISP_VEC_ALIGN         ISP_VMEM_ALIGN
-#endif
-
-/* HRT specific vector support */
-#define isp2300_medfield_vector_alignment      ISP_VEC_ALIGN
-#define isp2300_medfield_vector_elem_bits      ISP_VMEM_ELEMBITS
-#define isp2300_medfield_vector_elem_precision ISP_VMEM_ELEM_PRECISION
-#define isp2300_medfield_vector_num_elems      ISP_VEC_NELEMS
-
-/* register file sizes */
-#define ISP_RF0_SIZE        64
-#define ISP_RF1_SIZE        8
-#define ISP_RF2_SIZE        64
-#define ISP_RF3_SIZE        32
-#define ISP_RF4_SIZE        32
-#define ISP_RF5_SIZE        32
-#define ISP_RF6_SIZE        16
-#define ISP_VRF0_SIZE       16
-#define ISP_VRF1_SIZE       16
-#define ISP_VRF2_SIZE       16
-#define ISP_VRF3_SIZE       16
-#define ISP_VRF4_SIZE       16
-#define ISP_VRF5_SIZE       16
-#define ISP_VRF6_SIZE       16
-#define ISP_VRF7_SIZE       16
-#define ISP_VRF8_SIZE       16
-#define ISP_SRF0_SIZE       64
-#define ISP_SRF1_SIZE       64
-#define ISP_FRF0_SIZE       16
-#define ISP_FRF1_SIZE       16
-/* register file read latency */
-#define ISP_VRF0_READ_LAT       0
-#define ISP_VRF1_READ_LAT       0
-#define ISP_VRF2_READ_LAT       0
-#define ISP_VRF3_READ_LAT       0
-#define ISP_VRF4_READ_LAT       0
-#define ISP_VRF5_READ_LAT       0
-#define ISP_VRF6_READ_LAT       0
-#define ISP_VRF7_READ_LAT       0
-#define ISP_VRF8_READ_LAT       0
-#define ISP_SRF0_READ_LAT       0
-#define ISP_SRF1_READ_LAT       0
-/* immediate sizes */
-#define ISP_IS1_IMM_BITS        13
-#define ISP_IS2_IMM_BITS        10
-#define ISP_IS3_IMM_BITS        7
-#define ISP_IS4_IMM_BITS        7
-#define ISP_IS5_IMM_BITS        13
-#define ISP_IS6_IMM_BITS        7
-#define ISP_IS7_IMM_BITS        7
-#define ISP_IS8_IMM_BITS        7
-#define ISP_IS9_IMM_BITS        7
-/* fifo depths */
-#define ISP_IF_FIFO_DEPTH         0
-#define ISP_IF_B_FIFO_DEPTH       0
-#define ISP_DMA_FIFO_DEPTH        0
-#define ISP_OF_FIFO_DEPTH         0
-#define ISP_GDC_FIFO_DEPTH        0
-#define ISP_GPIO_FIFO_DEPTH       0
-#define ISP_SP_FIFO_DEPTH         0
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/master_port.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/master_port.h
deleted file mode 100644
index 3ae4bfb..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/master_port.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _HRT_MASTER_PORT_H 
-#define _HRT_MASTER_PORT_H 
-
-
-/* Congratulations, you have reached the end of the HRT.
- * Here we split between the hardware implementation (memcpy / assignments)
- * and the software backends (_hrt_master_port_load / _hrt_master_port_store)
- */
-
-#define hrt_master_port_store_char(addr,data)  hrt_master_port_store_8(addr,data)
-#define hrt_master_port_store_short(addr,data) hrt_master_port_store_16(addr,data)
-#define hrt_master_port_store_int(addr,data)   hrt_master_port_store_32(addr,data)
-#define hrt_master_port_store_long(addr,data)  hrt_master_port_store_32(addr,data)
-#define hrt_master_port_store_uchar(addr,data)  hrt_master_port_store_8(addr,data)
-#define hrt_master_port_store_ushort(addr,data) hrt_master_port_store_16(addr,data)
-#define hrt_master_port_store_uint(addr,data)   hrt_master_port_store_32(addr,data)
-#define hrt_master_port_store_ulong(addr,data)  hrt_master_port_store_32(addr,data)
-
-#define hrt_master_port_load_char(addr)   hrt_master_port_load_8(addr)
-#define hrt_master_port_load_short(addr)  hrt_master_port_load_16(addr)
-#define hrt_master_port_load_int(addr)    hrt_master_port_load_32(addr)
-#define hrt_master_port_load_long(addr)   hrt_master_port_load_32(addr)
-#define hrt_master_port_load_uchar(addr)  hrt_master_port_load_8(addr)
-#define hrt_master_port_load_ushort(addr) hrt_master_port_load_16(addr)
-#define hrt_master_port_load_uint(addr)   hrt_master_port_load_32(addr)
-#define hrt_master_port_load_ulong(addr)  hrt_master_port_load_32(addr)
-
-#define hrt_master_port_store_8(addr,data)  _hrt_master_port_store_8(addr, data)
-#define hrt_master_port_store_16(addr,data) _hrt_master_port_store_16(addr, data)
-#define hrt_master_port_store_32(addr,data) _hrt_master_port_store_32(addr, data)
-#define hrt_master_port_load_8(addr)        _hrt_master_port_load_8(addr)
-#define hrt_master_port_load_16(addr)       _hrt_master_port_load_16(addr)
-#define hrt_master_port_load_32(addr)       _hrt_master_port_load_32(addr)
-#define hrt_master_port_uload_8(addr)       _hrt_master_port_uload_8(addr)
-#define hrt_master_port_uload_16(addr)      _hrt_master_port_uload_16(addr)
-#define hrt_master_port_uload_32(addr)      _hrt_master_port_uload_32(addr)
-
-
-
-#define hrt_master_port_store(addr, data, bytes) \
-	_hrt_master_port_unaligned_store((addr), \
-					(const void *)(data), bytes)
-#define hrt_master_port_load(addr, data, bytes) \
-	_hrt_master_port_unaligned_load((addr), \
-					(void *)(data), bytes)
-#define hrt_master_port_set(addr, data, bytes) \
-	_hrt_master_port_unaligned_set((addr), \
-					(int)(data), bytes)
-
-/* reduce number of functions */
-#define _hrt_master_port_unaligned_store(address, data, size) \
-	_hrt_mem_store(address, data, size)
-#define _hrt_master_port_unaligned_load(address, data, size) \
-	_hrt_mem_load(address, data, size)
-#define _hrt_master_port_unaligned_set(address, data, size) \
-	_hrt_mem_set(address, data, size)
-
-
-#if defined(__HIVECC)
-#include "master_port_hivecc.h"
-#elif defined(HRT_USE_VIR_ADDRS)
-/* do nothing, hrt backend is already included */
-#elif defined(HRT_HW)
-#include "master_port_hw.h"
-#else
-#include "master_port_sim.h"
-#endif
-
-
-
-/* To use a combination of variables in crun and bus addresses in other runs, use these: */
-#ifdef C_RUN
-#define hrt_master_port_scalar_store(type, var, data, addr)             (var) = (data)
-#define hrt_master_port_scalar_load(type, var, addr)                    (var)
-#define hrt_master_port_indexed_store(type, array, i, data, addr)       ((array)[i]) = (data)
-#define hrt_master_port_indexed_load(type, array, i, addr)              ((array)[i])
-#else
-#define hrt_master_port_scalar_store(type, var, data, addr) \
-        HRTCAT(hrt_master_port_store_,type)(addr, data)
-#define hrt_master_port_scalar_load(type, var, addr) \
-        HRTCAT(hrt_master_port_load_,type)(addr)
-#define hrt_master_port_indexed_store(type, array, i, data, addr) \
-        HRTCAT(hrt_master_port_store_,type)((addr) + ((i)*sizeof(type)), data)
-#define hrt_master_port_indexed_load(type, array, i, addr) \
-        HRTCAT(hrt_master_port_load_,type)((addr) + ((i)*sizeof(type)))
-#endif /* C_RUN */
-
-#endif /* _HRT_MASTER_PORT_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/mmu_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/mmu_defs.h
deleted file mode 100644
index 6aa8ed5..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/mmu_defs.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _mmu_defs_h
-#define _mmu_defs_h
-
-#define _HRT_MMU_INVALIDATE_TLB_REG_IDX          0
-#define _HRT_MMU_PAGE_TABLE_BASE_ADDRESS_REG_IDX 1
-
-#define _HRT_MMU_REG_ALIGN 4
-
-#endif /* _mmu_defs_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/scalar_processor_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/scalar_processor_params.h
deleted file mode 100644
index 2eb5166..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/scalar_processor_params.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _scalar_processor_params_h
-#define _scalar_processor_params_h
-
-#include "cell_params.h"
-
-#endif /* _scalar_processor_params_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/sp_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/sp_hrt.h
deleted file mode 100644
index a3ad0bc..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/sp_hrt.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _sp_hrt_h_
-#define _sp_hrt_h_
-
-#define hrt_sp_dmem(cell) HRT_PROC_TYPE_PROP(cell, _dmem)
-
-#define hrt_sp_dmem_master_port_address(cell) hrt_mem_master_port_address(cell, hrt_sp_dmem(cell))
-
-#endif /* _sp_hrt_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/str2mem_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/str2mem_defs.h
deleted file mode 100644
index 754cf32..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/str2mem_defs.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _ST2MEM_DEFS_H
-#define _ST2MEM_DEFS_H
-
-#define _STR2MEM_CRUN_BIT               0x100000
-#define _STR2MEM_CMD_BITS               0x0F0000
-#define _STR2MEM_COUNT_BITS             0x00FFFF
-
-#define _STR2MEM_BLOCKS_CMD             0xA0000
-#define _STR2MEM_PACKETS_CMD            0xB0000
-#define _STR2MEM_BYTES_CMD              0xC0000
-#define _STR2MEM_BYTES_FROM_PACKET_CMD  0xD0000
-
-#define _STR2MEM_SOFT_RESET_REG_ID                   0
-#define _STR2MEM_INPUT_ENDIANNESS_REG_ID             1
-#define _STR2MEM_OUTPUT_ENDIANNESS_REG_ID            2
-#define _STR2MEM_BIT_SWAPPING_REG_ID                 3
-#define _STR2MEM_BLOCK_SYNC_LEVEL_REG_ID             4
-#define _STR2MEM_PACKET_SYNC_LEVEL_REG_ID            5
-#define _STR2MEM_READ_POST_WRITE_SYNC_ENABLE_REG_ID  6
-#define _STR2MEM_DUAL_BYTE_INPUTS_ENABLED_REG_ID     7
-#define _STR2MEM_EN_STAT_UPDATE_ID                   8
-
-#define _STR2MEM_REG_ALIGN      4
-
-#endif /* _ST2MEM_DEFS_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/streaming_to_mipi_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/streaming_to_mipi_defs.h
deleted file mode 100644
index 2826ce8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/streaming_to_mipi_defs.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _streaming_to_mipi_defs_h
-#define _streaming_to_mipi_defs_h
-
-#define HIVE_STR_TO_MIPI_VALID_A_BIT 0
-#define HIVE_STR_TO_MIPI_VALID_B_BIT 1
-#define HIVE_STR_TO_MIPI_SOL_BIT     2
-#define HIVE_STR_TO_MIPI_EOL_BIT     3
-#define HIVE_STR_TO_MIPI_SOF_BIT     4
-#define HIVE_STR_TO_MIPI_EOF_BIT     5
-#define HIVE_STR_TO_MIPI_CH_ID_LSB   6
-
-#define HIVE_STR_TO_MIPI_DATA_A_LSB  (HIVE_STR_TO_MIPI_VALID_B_BIT + 1)
-
-#endif /* _streaming_to_mipi_defs_h */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/timed_controller_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/timed_controller_defs.h
deleted file mode 100644
index b2b796d..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/timed_controller_defs.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _timed_controller_defs_h
-#define _timed_controller_defs_h
-
-#define _HRT_TIMED_CONTROLLER_CMD_REG_IDX 0
-
-#define _HRT_TIMED_CONTROLLER_REG_ALIGN 4
-
-#endif /* _timed_controller_defs_h */   
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/version.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/version.h
deleted file mode 100644
index 5e7dc29..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/hrt/version.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef HRT_VERSION_H
-#define HRT_VERSION_H
-#define HRT_VERSION_MAJOR 1
-#define HRT_VERSION_MINOR 4
-#define HRT_VERSION 1_4
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.c
deleted file mode 100644
index 250416e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.c
+++ /dev/null
@@ -1,8669 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-/*! \file */
-
-#include "sh_css.h"
-#include "sh_css_v2.h"
-#include "sh_css_hrt.h"		/* only for file 2 MIPI */
-#include "sh_css_binary.h"
-#include "sh_css_internal.h"
-#include "sh_css_sp.h"
-#include "sh_css_sp_start.h"
-#include "sh_css_rx.h"
-#include "sh_css_defs.h"
-#include "sh_css_firmware.h"
-#include "sh_css_accelerate.h"
-#include "sh_css_params.h"
-#include "sh_css_params_internal.h"
-#include "sh_css_param_shading.h"
-#include "sh_css_pipeline.h"
-#include "sh_css_refcount.h"
-#include "ia_css_i_rmgr.h"
-#include "sh_css_debug.h"
-#include "sh_css_debug_internal.h"
-
-#include "memory_access.h"
-#include "tag.h"
-#include "assert_support.h"
-#include "queue.h"			/* host2sp_enqueue_frame_data() */
-#include "sw_event.h"			/* encode_sw_event */
-#include "input_formatter.h"/* input_formatter_cfg_t,
-	input_formatter_get_alignment(), ... */
-#include "input_system.h"
-#include "mmu_device.h"		/* mmu_set_page_table_base_index(), ... */
-#include "gdc_device.h"		/* HRT_GDC_N */
-#include "irq.h"			/* virq */
-#include "sp.h"				/* cnd_sp_irq_enable() */
-#include "isp.h"			/* cnd_isp_irq_enable, ISP_VEC_NELEMS */
-#define __INLINE_GPIO__
-#include "gpio.h"
-#include "timed_ctrl.h"
-#include "platform_support.h" /* hrt_sleep() */
-
-#define WITH_PC_MONITORING  0
-
-#if WITH_PC_MONITORING
-#define MULTIPLE_SAMPLES 1
-#define NOF_SAMPLES      60
-#include "linux/kthread.h"
-#include "linux/sched.h"
-#include "linux/delay.h"
-#include "sh_css_metrics.h"
-
-
-
-
-static int thread_alive;
-#endif
-
-#define DVS_REF_TESTING 0
-#if DVS_REF_TESTING
-#include <stdio.h>
-#endif
-
-/* Name of the sp program: should not be built-in */
-#define SP_PROG_NAME "sp"
-
-/* for JPEG, we don't know the length of the image upfront,
- * but since we support sensor upto 16MP, we take this as
- * upper limit.
- */
-#define JPEG_BYTES (16 * 1024 * 1024)
-
-#define IS_ODD(a)              ((a) & 0x1)
-
-#define IMPLIES(a, b)           (!(a) || (b))   /* A => B */
-
-#define STATS_ENABLED(stage) (stage && stage->binary && stage->binary->info && \
-	(stage->binary->info->enable.s3a || stage->binary->info->enable.dis))
-
-#define DEFAULT_IF_CONFIG \
-{ \
-	0,          /* start_line */\
-	0,          /* start_column */\
-	0,          /* left_padding */\
-	0,          /* cropped_height */\
-	0,          /* cropped_width */\
-	0,          /* deinterleaving */\
-	0,          /*.buf_vecs */\
-	0,          /* buf_start_index */\
-	0,          /* buf_increment */\
-	0,          /* buf_eol_offset */\
-	false,      /* is_yuv420_format */\
-	false       /* block_no_reqs */\
-}
-
-enum sh_css_state {
-	sh_css_state_idle,
-	sh_css_state_executing_isp,
-	sh_css_state_executing_sp_bin_copy,
-};
-
-#define DEFAULT_PLANES { {0, 0, 0, 0} }
-
-#define DEFAULT_FRAME \
-{ \
-	DEFAULT_FRAME_INFO, \
-	0, \
-	0, \
-	-1, \
-	SH_CSS_FRAME_NO_FLASH, \
-	0, \
-	false, \
-	{ 0 } \
-}
-
-#define DEFAULT_PIPELINE_SETTINGS \
-{ \
-	0, \
-	NULL, \
-	false, \
-	NULL, \
-	0, \
-	DEFAULT_FRAME, \
-	DEFAULT_FRAME, \
-	DEFAULT_FRAME \
-}
-
-#define DEFAULT_PIPE \
-	true,                      /* online */ \
-	NULL,                      /* shading_table */ \
-	DEFAULT_PIPELINE_SETTINGS, /* pipeline */ \
-	DEFAULT_FRAME_INFO,        /* output_info */\
-	DEFAULT_FRAME_INFO,        /* vf_output_info */ \
-	DEFAULT_FRAME_INFO,        /* yuv_ds_input_info */\
-	0,                         /* ch_id */ \
-	N_SH_CSS_INPUT_FORMAT,     /* input_format */ \
-	SH_CSS_INPUT_MODE_SENSOR,  /* input_mode */ \
-	false,                     /* two_ppc */ \
-	N_sh_css_bayer_order,      /* bayer_order */ \
-	false,                     /* disable_vf_pp */\
-	false,                     /* disable_capture_pp */ \
-	false,                     /* input_needs_raw_binning */ \
-	DEFAULT_MIPI_CONFIG,       /* mipi_config */ \
-	NULL,                      /* output_stage */\
-	NULL,                      /* vf_stage */ \
-	0,                         /* input_width */ \
-	0,                         /* input_height */ \
-	DEFAULT_FRAME_INFO,        /* input_effective_info */ \
-	SH_CSS_CAPTURE_MODE_PRIMARY,/* capture_mode */ \
-	false,                     /* xnr */ \
-	{ 0, 0 },                  /* dvs_envelope */ \
-	false,                     /* invalid_first_frame */ \
-	false,                     /* enable_yuv_ds */ \
-	false,                     /* enable_high_speed */ \
-	false,                     /* enable_dvs_6axis */ \
-	true,                      /* enable_viewfinder */ \
-	true,                      /* enable_dz */ \
-	false,                     /* enable_reduced_pipe */ \
-	1,                         /* isp_pipe_version */ \
-	{ }                        /* settings */
-
-struct sh_css_preview_settings {
-	struct sh_css_binary copy_binary;
-	struct sh_css_binary preview_binary;
-	struct sh_css_binary vf_pp_binary;
-	struct sh_css_frame *continuous_frames[NUM_CONTINUOUS_FRAMES];
-};
-
-#define DEFAULT_PREVIEW_SETTINGS \
-{ \
-	DEFAULT_BINARY_SETTINGS,  /* copy_binary */\
-	DEFAULT_BINARY_SETTINGS,  /* preview_binary */\
-	DEFAULT_BINARY_SETTINGS,  /* vf_pp_binary */\
-	{ NULL },                 /* continuous_frames */\
-}
-
-#define DEFAULT_PREVIEW_PIPE \
-{ \
-	SH_CSS_PREVIEW_PIPELINE, \
-	DEFAULT_PIPE \
-}
-
-struct sh_css_capture_settings {
-	struct sh_css_binary copy_binary;
-	struct sh_css_binary primary_binary;
-	struct sh_css_binary pre_isp_binary;
-	struct sh_css_binary gdc_binary;
-	struct sh_css_binary post_isp_binary;
-	struct sh_css_binary anr_binary;
-	struct sh_css_binary capture_pp_binary;
-	struct sh_css_binary vf_pp_binary;
-	struct sh_css_frame *capture_pp_frame;
-	struct sh_css_frame *output_frame;
-	/*struct sh_css_frame *continuous_frames[NUM_CONTINUOUS_FRAMES];*/
-};
-
-#define DEFAULT_CAPTURE_SETTINGS \
-{ \
-	DEFAULT_BINARY_SETTINGS,     /* copy_binary */\
-	DEFAULT_BINARY_SETTINGS,     /* primary_binary */\
-	DEFAULT_BINARY_SETTINGS,     /* pre_isp_binary */\
-	DEFAULT_BINARY_SETTINGS,     /* gdc_binary */\
-	DEFAULT_BINARY_SETTINGS,     /* post_isp_binary */\
-	DEFAULT_BINARY_SETTINGS,     /* anr_binary */\
-	DEFAULT_BINARY_SETTINGS,     /* capture_pp_binary */\
-	DEFAULT_BINARY_SETTINGS,     /* vf_pp_binary */\
-	NULL,                        /* capture_pp_frame */\
-	NULL,                        /* output_frame */\
-	/*{ NULL },   */              /* continuous_frames */\
-}
-
-#define DEFAULT_CAPTURE_PIPE \
-{ \
-	SH_CSS_CAPTURE_PIPELINE, \
-	DEFAULT_PIPE \
-}
-
-struct sh_css_video_settings {
-	struct sh_css_binary copy_binary;
-	struct sh_css_binary video_binary;
-	struct sh_css_binary vf_pp_binary;
-	struct sh_css_frame *ref_frames[NUM_VIDEO_REF_FRAMES];
-	struct sh_css_frame *tnr_frames[NUM_VIDEO_TNR_FRAMES];
-	struct sh_css_frame *vf_pp_in_frame;
-};
-
-#define DEFAULT_VIDEO_SETTINGS \
-{ \
-	DEFAULT_BINARY_SETTINGS,/* copy_binary */ \
-	DEFAULT_BINARY_SETTINGS,/* video_binary */ \
-	DEFAULT_BINARY_SETTINGS,/* vf_pp_binary */ \
-	{ NULL },                /* ref_frames */ \
-	{ NULL },                /* tnr_frames */ \
-	NULL,                    /* vf_pp_in_frame */ \
-}
-
-#define DEFAULT_VIDEO_PIPE \
-{ \
-	SH_CSS_VIDEO_PIPELINE, \
-	DEFAULT_PIPE \
-}
-
-#define DEFAULT_ACC_PIPE \
-{ \
-	SH_CSS_ACC_PIPELINE, \
-	DEFAULT_PIPE \
-}
-
-struct sh_css_pipe {
-	enum sh_css_pipe_id          mode;
-	bool                         online;
-	struct sh_css_shading_table *shading_table;
-	struct sh_css_pipeline       pipeline;
-	struct sh_css_frame_info     output_info;
-	struct sh_css_frame_info     vf_output_info;
-	struct sh_css_frame_info     yuv_ds_input_info;
-	unsigned int                 ch_id;
-	enum sh_css_input_format     input_format;
-	enum sh_css_input_mode       input_mode;
-	bool                         two_ppc;
-	enum sh_css_bayer_order      bayer_order;
-	bool                         disable_vf_pp;
-	bool                         disable_capture_pp;
-	bool                         input_needs_raw_binning;
-	rx_cfg_t                     mipi_config;
-	struct sh_css_fw_info	    *output_stage; /* extra output stage */
-	struct sh_css_fw_info	    *vf_stage;     /* extra vf stage */
-	unsigned int                   input_width;
-	unsigned int                   input_height;
-	struct sh_css_frame_info       input_effective_info;
-	enum sh_css_capture_mode     capture_mode;
-	bool                         xnr;
-	struct sh_css_envelope       dvs_envelope;
-	bool                         invalid_first_frame;
-	bool                         enable_yuv_ds;
-	bool                         enable_high_speed;
-	bool                         enable_dvs_6axis;
-	bool                         enable_viewfinder;
-	bool                         enable_dz;
-	bool                         enable_reduced_pipe;
-	unsigned int                 isp_pipe_version;
-	union {
-		struct sh_css_preview_settings preview;
-		struct sh_css_video_settings   video;
-		struct sh_css_capture_settings capture;
-	} pipe;
-};
-
-struct sh_css {
-	struct sh_css_pipe             preview_pipe;
-	struct sh_css_pipe             capture_pipe;
-	struct sh_css_pipe             video_pipe;
-	struct sh_css_pipe             acc_pipe;
-	unsigned int                   left_padding;
-	struct sh_css_pipe            *curr_pipe;
-	bool                           reconfigure_css_rx;
-	void *(*malloc) (size_t bytes, bool zero_mem);
-	void (*free) (void *ptr);
-	void (*flush) (struct sh_css_acc_fw *fw);
-	enum sh_css_state              curr_state;
-	unsigned int                   sensor_binning;
-	input_formatter_cfg_t          curr_if_a_config;
-	input_formatter_cfg_t          curr_if_b_config;
-	unsigned int                   curr_fmt_type;
-	unsigned int                   curr_ch_id;
-	enum sh_css_input_mode         curr_input_mode;
-	bool                           check_system_idle;
-	bool                           continuous;
-	bool                           cont_capt;
-	bool						   stop_copy_preview;
-	unsigned int                   num_cont_raw_frames;
-	struct sh_css_event_irq_mask   sp_irq_mask[NR_OF_PIPELINES];
-	bool                           start_sp_copy;
-	hrt_vaddress                   sp_bin_addr;
-	hrt_data		       page_table_base_index;
-};
-
-#define DEFAULT_CSS \
-{ \
-	DEFAULT_PREVIEW_PIPE,     /* preview_pipe */ \
-	DEFAULT_CAPTURE_PIPE,     /* capture_pipe */ \
-	DEFAULT_VIDEO_PIPE,       /* video_pipe */ \
-	DEFAULT_ACC_PIPE,         /* acc_pipe */ \
-	0,                        /* left_padding */ \
-	NULL,                     /* curr_pipe */ \
-	true,                     /* reconfigure_css_rx */ \
-	NULL,                     /* malloc */ \
-	NULL,                     /* free */ \
-	NULL,                     /* flush */ \
-	sh_css_state_idle,        /* curr_state */ \
-	0,                        /* sensor_binning */ \
-	DEFAULT_IF_CONFIG,        /* curr_if_a_config */ \
-	DEFAULT_IF_CONFIG,        /* curr_if_b_config */ \
-	-1,                       /* curr_fmt_type */ \
-	0,                        /* curr_ch_id */ \
-	SH_CSS_INPUT_MODE_SENSOR, /* curr_input_mode */ \
-	true,                     /* check_system_idle */ \
-	false,                    /* continuous */ \
-	false,                    /* cont_capt */ \
-	false,                    /* stop_copy_preview */ \
-	NUM_CONTINUOUS_FRAMES,    /* num_cont_raw_frames */ \
-	{{SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_VF_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE, SH_CSS_EVENT_IRQ_MASK_NONE}, \
-	{SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_VF_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE, SH_CSS_EVENT_IRQ_MASK_NONE}, \
-	{SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_VF_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE, SH_CSS_EVENT_IRQ_MASK_NONE}, \
-	{SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_VF_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE, SH_CSS_EVENT_IRQ_MASK_NONE}, \
-	{SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_VF_OUTPUT_FRAME_DONE | SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE, SH_CSS_EVENT_IRQ_MASK_NONE}},    /* sp_irq_mask */ \
-	false,                    /* start_sp_copy */ \
-	0,                        /* sp_bin_addr */ \
-	0,                        /* page_table_base_index */ \
-}
-
-#if defined(HAS_RX_VERSION_2)
-
-#define DEFAULT_MIPI_CONFIG \
-{ \
-	MONO_4L_1L_0L, \
-	MIPI_PORT0_ID, \
-	0xffff4, \
-	0, \
-	0x28282828, \
-	0x04040404, \
-	MIPI_PREDICTOR_NONE, \
-	false \
-}
-
-#elif defined(HAS_RX_VERSION_1) || defined(HAS_NO_RX)
-
-#define DEFAULT_MIPI_CONFIG \
-{ \
-	MIPI_PORT1_ID, \
-	1, \
-	0xffff4, \
-	0, \
-	0, \
-	MIPI_PREDICTOR_NONE, \
-	false \
-}
-
-#else
-#error "sh_css.c: RX version must be one of {RX_VERSION_1, RX_VERSION_2, NO_RX}"
-#endif
-
-int (*sh_css_printf) (const char *fmt, ...) = NULL;
-
-unsigned int sh_css_stop_timeout_us;
-
-static struct sh_css my_css;
-/* static variables, temporarily used in load_<mode>_binaries.
-   Declaring these inside the functions increases the size of the
-   stack frames beyond the acceptable 128 bytes. */
-static struct sh_css_binary_descr preview_descr,
-				  vf_pp_descr,
-				  copy_descr,
-				  prim_descr,
-				  pre_gdc_descr,
-				  gdc_descr,
-				  post_gdc_descr,
-				  pre_anr_descr,
-				  anr_descr,
-				  post_anr_descr,
-				  video_descr,
-				  capture_pp_descr;
-
-/* pqiao NOTICE: this is for css internal buffer recycling when stopping pipeline,
-   this array is temporary and will be replaced by resource manager*/
-#define MAX_HMM_BUFFER_NUM (SH_CSS_NUM_BUFFER_QUEUES * (SH_CSS_CIRCULAR_BUF_NUM_ELEMS + 2))
-static struct ia_css_i_host_rmgr_vbuf_handle *hmm_buffer_record_h[MAX_HMM_BUFFER_NUM];
-
-/* Should be consistent with SH_CSS_MAX_SP_THREADS */
-/* See also pipe_threads in sp.hive.c, which should be consistent with this */
-#define COPY_PIPELINE		(0)
-#define PREVIEW_PIPELINE	(1)
-#define CAPTURE_PIPELINE	(2)
-#define ACCELERATION_PIPELINE	(3)
-#define VIDEO_PIPELINE		(PREVIEW_PIPELINE)
-
-/* From enum sh_css_pipe_id to struct sh_css_pipeline * */
-static unsigned int sh_css_pipe_id_2_internal_thread_id[SH_CSS_NR_OF_PIPELINES]
-	 = { PREVIEW_PIPELINE,
-	     COPY_PIPELINE,
-	     VIDEO_PIPELINE,
-	     CAPTURE_PIPELINE,
-	     ACCELERATION_PIPELINE };
-
-#define GPIO_FLASH_PIN_MASK (1 << HIVE_GPIO_STROBE_TRIGGER_PIN)
-
-static enum sh_css_buffer_queue_id
-	sh_css_buf_type_2_internal_queue_id[SH_CSS_BUFFER_TYPE_NR_OF_TYPES] = {
-		sh_css_s3a_buffer_queue,
-		sh_css_dis_buffer_queue,
-		sh_css_input_buffer_queue,
-		sh_css_output_buffer_queue,
-		sh_css_vf_output_buffer_queue,
-		sh_css_output_buffer_queue,
-		sh_css_input_buffer_queue,
-		sh_css_output_buffer_queue,
-		sh_css_param_buffer_queue };
-
-/**
- * Local prototypes
- */
-static bool
-need_capture_pp(const struct sh_css_pipe *pipe);
-
-static enum sh_css_err
-sh_css_pipe_load_binaries(struct sh_css_pipe *pipe);
-
-static enum sh_css_err
-sh_css_pipe_get_output_frame_info(struct sh_css_pipe *pipe,
-				  struct sh_css_frame_info *info);
-
-static enum sh_css_err
-capture_start(struct sh_css_pipe *pipe);
-
-static enum sh_css_err
-video_start(struct sh_css_pipe *pipe);
-
-static enum sh_css_err
-construct_capture_pipe(struct sh_css_pipe *pipe);
-
-static enum sh_css_err
-init_frame_planes(struct sh_css_frame *frame);
-
-static enum sh_css_err
-sh_css_pipeline_stop(enum sh_css_pipe_id pipe);
-
-static uint32_t
-translate_sp_event(uint32_t sp_event);
-
-void
-sh_css_set_stop_timeout(unsigned int timeout)
-{
-	sh_css_stop_timeout_us = timeout;
-}
-
-static void
-sh_css_pipe_free_shading_table(struct sh_css_pipe *pipe)
-{
-	if (pipe->shading_table)
-		sh_css_shading_table_free(pipe->shading_table);
-	pipe->shading_table = NULL;
-}
-
-static enum sh_css_err
-check_frame_info(const struct sh_css_frame_info *info)
-{
-	if (info->width == 0 || info->height == 0)
-		return sh_css_err_illegal_resolution;
-	return sh_css_success;
-}
-
-static enum sh_css_err
-check_vf_info(const struct sh_css_frame_info *info)
-{
-	enum sh_css_err err;
-	err = check_frame_info(info);
-	if (err != sh_css_success)
-		return err;
-	if (info->width > sh_css_max_vf_width()*2)
-		return sh_css_err_viewfinder_resolution_too_wide;
-	return sh_css_success;
-}
-
-static enum sh_css_err
-check_vf_out_info(const struct sh_css_frame_info *out_info,
-		  const struct sh_css_frame_info *vf_info)
-{
-	enum sh_css_err err;
-	err = check_frame_info(out_info);
-	if (err != sh_css_success)
-		return err;
-	err = check_vf_info(vf_info);
-	if (err != sh_css_success)
-		return err;
-	if (vf_info->width > out_info->width ||
-	    vf_info->height > out_info->height)
-		return sh_css_err_viewfinder_resolution_exceeds_output;
-	return sh_css_success;
-}
-
-static enum sh_css_err
-check_res(unsigned int width, unsigned int height)
-{
-	if (width  == 0   ||
-	    height == 0   ||
-	    IS_ODD(width) ||
-	    IS_ODD(height)) {
-		return sh_css_err_illegal_resolution;
-	}
-	return sh_css_success;
-}
-
-static enum sh_css_err
-check_null_res(unsigned int width, unsigned int height)
-{
-	if (IS_ODD(width) || IS_ODD(height))
-		return sh_css_err_illegal_resolution;
-
-	return sh_css_success;
-}
-
-static bool
-input_format_is_raw(enum sh_css_input_format format)
-{
-	return format == SH_CSS_INPUT_FORMAT_RAW_6 ||
-	    format == SH_CSS_INPUT_FORMAT_RAW_7 ||
-	    format == SH_CSS_INPUT_FORMAT_RAW_8 ||
-	    format == SH_CSS_INPUT_FORMAT_RAW_10 ||
-	    format == SH_CSS_INPUT_FORMAT_RAW_12;
-	/* raw_14 and raw_16 are not supported as input formats to the ISP.
-	 * They can only be copied to a frame in memory using the
-	 * copy binary.
-	 */
-}
-
-static bool
-input_format_is_yuv(enum sh_css_input_format format)
-{
-	return format == SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY ||
-	    format == SH_CSS_INPUT_FORMAT_YUV420_8 ||
-	    format == SH_CSS_INPUT_FORMAT_YUV420_10 ||
-	    format == SH_CSS_INPUT_FORMAT_YUV422_8 ||
-	    format == SH_CSS_INPUT_FORMAT_YUV422_10;
-}
-
-bool
-input_format_is_yuv_8(enum sh_css_input_format format)
-{
-	return format == SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY ||
-	    format == SH_CSS_INPUT_FORMAT_YUV420_8 ||
-	    format == SH_CSS_INPUT_FORMAT_YUV422_8;
-}
-
-static enum sh_css_err
-check_input(struct sh_css_pipe *pipe, bool must_be_raw)
-{
-	if (pipe->input_effective_info.width == 0 ||
-	    pipe->input_effective_info.height == 0) {
-		return sh_css_err_effective_input_resolution_not_set;
-	}
-	if (must_be_raw &&
-	    !input_format_is_raw(pipe->input_format)) {
-		return sh_css_err_unsupported_input_format;
-	}
-	return sh_css_success;
-}
-
-/* Input network configuration functions */
-static void
-get_copy_out_frame_format(struct sh_css_pipe *pipe,
-	enum sh_css_frame_format *format)
-{
-	switch (pipe->input_format) {
-	case SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY:
-	case SH_CSS_INPUT_FORMAT_YUV420_8:
-		*format = SH_CSS_FRAME_FORMAT_YUV420;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV420_10:
-		*format = SH_CSS_FRAME_FORMAT_YUV420_16;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV422_8:
-		*format = SH_CSS_FRAME_FORMAT_YUV422;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV422_10:
-		*format = SH_CSS_FRAME_FORMAT_YUV422_16;
-		break;
-	case SH_CSS_INPUT_FORMAT_RGB_444:
-	case SH_CSS_INPUT_FORMAT_RGB_555:
-	case SH_CSS_INPUT_FORMAT_RGB_565:
-		if (*format != SH_CSS_FRAME_FORMAT_RGBA888)
-			*format = SH_CSS_FRAME_FORMAT_RGB565;
-		break;
-	case SH_CSS_INPUT_FORMAT_RGB_666:
-	case SH_CSS_INPUT_FORMAT_RGB_888:
-		*format = SH_CSS_FRAME_FORMAT_RGBA888;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_6:
-	case SH_CSS_INPUT_FORMAT_RAW_7:
-	case SH_CSS_INPUT_FORMAT_RAW_8:
-	case SH_CSS_INPUT_FORMAT_RAW_10:
-	case SH_CSS_INPUT_FORMAT_RAW_12:
-	case SH_CSS_INPUT_FORMAT_RAW_14:
-	case SH_CSS_INPUT_FORMAT_RAW_16:
-		*format = SH_CSS_FRAME_FORMAT_RAW;
-		break;
-	case SH_CSS_INPUT_FORMAT_BINARY_8:
-		*format = SH_CSS_FRAME_FORMAT_BINARY_8;
-		break;
-	case N_SH_CSS_INPUT_FORMAT:
-/* Fall through */
-	default:
-		*format = N_SH_CSS_FRAME_FORMAT;
-		break;
-	}
-}
-
-/* next function takes care of getting the settings from kernel
- * commited to hmm / isp
- * TODO: see if needs to be made public
- */
-static enum sh_css_err
-sh_css_commit_isp_config(void *me, bool queue)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_pipeline *pipeline = me;
-	struct sh_css_pipeline_stage *stage;
-
-	if (pipeline) {
-		/* walk through pipeline and commit settings */
-		/* TODO: check if this is needed (s3a is handled through this */
-		for (stage = pipeline->stages; stage; stage = stage->next) {
-			if (stage && stage->binary) {
-				err = sh_css_params_write_to_ddr(stage->binary);
-				if (err != sh_css_success)
-					return err;
-			}
-		}
-	}
-	/* now propagate the set to sp */
-	//sh_css_param_update_isp_params(queue);
-	(void)me;
-	(void)queue;
-	return err;
-}
-
-static unsigned int
-sh_css_pipe_input_format_bits_per_pixel(const struct sh_css_pipe *pipe)
-{
-	return sh_css_input_format_bits_per_pixel(pipe->input_format,
-						  pipe->two_ppc);
-}
-
-/* MW: Table look-up ??? */
-unsigned int
-sh_css_input_format_bits_per_pixel(enum sh_css_input_format format,
-	bool two_ppc)
-{
-	switch (format) {
-	case SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY:
-	case SH_CSS_INPUT_FORMAT_YUV420_8:
-	case SH_CSS_INPUT_FORMAT_YUV422_8:
-	case SH_CSS_INPUT_FORMAT_RGB_888:
-	case SH_CSS_INPUT_FORMAT_RAW_8:
-	case SH_CSS_INPUT_FORMAT_BINARY_8:
-		return 8;
-	case SH_CSS_INPUT_FORMAT_YUV420_10:
-	case SH_CSS_INPUT_FORMAT_YUV422_10:
-	case SH_CSS_INPUT_FORMAT_RAW_10:
-		return 10;
-	case SH_CSS_INPUT_FORMAT_RGB_444:
-		return 4;
-	case SH_CSS_INPUT_FORMAT_RGB_555:
-		return 5;
-	case SH_CSS_INPUT_FORMAT_RGB_565:
-		return 65;
-	case SH_CSS_INPUT_FORMAT_RGB_666:
-	case SH_CSS_INPUT_FORMAT_RAW_6:
-		return 6;
-	case SH_CSS_INPUT_FORMAT_RAW_7:
-		return 7;
-	case SH_CSS_INPUT_FORMAT_RAW_12:
-		return 12;
-	case SH_CSS_INPUT_FORMAT_RAW_14:
-		if (two_ppc)
-			return 14;
-		else
-			return 12;
-	case SH_CSS_INPUT_FORMAT_RAW_16:
-		if (two_ppc)
-			return 16;
-		else
-			return 12;
-	case N_SH_CSS_INPUT_FORMAT:
-/* Fall through */
-	default:
-		return 0;
-	}
-return 0;
-}
-
-/* compute the log2 of the downscale factor needed to get closest
- * to the requested viewfinder resolution on the upper side. The output cannot
- * be smaller than the requested viewfinder resolution.
- */
-enum sh_css_err
-sh_css_vf_downscale_log2(const struct sh_css_frame_info *out_info,
-			 const struct sh_css_frame_info *vf_info,
-			 unsigned int *downscale_log2)
-{
-	unsigned int ds_log2 = 0;
-	unsigned int out_width = out_info ? out_info->width : 0;
-
-	if (out_width == 0)
-		return 0;
-
-	/* downscale until width smaller than the viewfinder width. We don't
-	 * test for the height since the vmem buffers only put restrictions on
-	 * the width of a line, not on the number of lines in a frame.
-	 */
-	while (out_width >= vf_info->width) {
-		ds_log2++;
-		out_width /= 2;
-	}
-	/* now width is smaller, so we go up one step */
-	if ((ds_log2 > 0) && (out_width < sh_css_max_vf_width()))
-		ds_log2--;
-	/* TODO: use actual max input resolution of vf_pp binary */
-	if ((out_info->width >> ds_log2) >= 2*sh_css_max_vf_width())
-		return sh_css_err_viewfinder_resolution_too_wide;
-	
-	/* currently the actual supported maximum input width for vf_pp is 
-	   2*1280=2560 pixel, when the resolution is larger than this, we let
-	   previous stage do extra downscaling and vf_pp do upscaling to get the
-	   desired vf output resolution. In this case, the image quality is a bit
-	   worse, but the customer requests a 1080p postview for 6M capture. The
-	   image quality of postview is not that important, so we go for this 
-	   easiest solution */
-	while ((out_info->width >> ds_log2) > (2*SH_CSS_MAX_VF_WIDTH)) {
-		ds_log2++;
-	}
-
-	*downscale_log2 = ds_log2;
-	return sh_css_success;
-}
-
-/* ISP expects GRBG bayer order, we skip one line and/or one row
- * to correct in case the input bayer order is different.
- */
-static unsigned int
-lines_needed_for_bayer_order(struct sh_css_pipe *pipe)
-{
-	if (pipe->bayer_order == sh_css_bayer_order_bggr ||
-	    pipe->bayer_order == sh_css_bayer_order_gbrg) {
-		return 1;
-	}
-	return 0;
-}
-
-static unsigned int
-columns_needed_for_bayer_order(struct sh_css_pipe *pipe)
-{
-	if (pipe->bayer_order == sh_css_bayer_order_rggb ||
-	    pipe->bayer_order == sh_css_bayer_order_gbrg) {
-		return 1;
-	}
-	return 0;
-}
-
-static enum sh_css_err
-input_start_column(struct sh_css_pipe *pipe,
-		   unsigned int bin_in,
-		   unsigned int *start_column)
-{
-	unsigned int in = pipe->input_width,
-	    for_bayer = columns_needed_for_bayer_order(pipe), start;
-
-	if (bin_in + 2 * for_bayer > in)
-		return sh_css_err_not_enough_input_columns;
-
-	/* On the hardware, we want to use the middle of the input, so we
-	 * divide the start column by 2. */
-	start = (in - bin_in) / 2;
-	/* in case the number of extra columns is 2 or odd, we round the start
-	 * column down */
-	start &= ~0x1;
-
-	/* now we add the one column (if needed) to correct for the bayer
-	 * order).
-	 */
-	start += for_bayer;
-	*start_column = start;
-	return sh_css_success;
-}
-
-static enum sh_css_err
-input_start_line(struct sh_css_pipe *pipe,
-		 unsigned int bin_in,
-		 unsigned int *start_line)
-{
-	unsigned int in = pipe->input_height,
-	    for_bayer = lines_needed_for_bayer_order(pipe), start;
-
-	if (bin_in + 2 * for_bayer > in)
-		return sh_css_err_not_enough_input_lines;
-
-	/* On the hardware, we want to use the middle of the input, so we
-	 * divide the start line by 2. On the simulator, we cannot handle extra
-	 * lines at the end of the frame.
-	 */
-	start = (in - bin_in) / 2;
-	/* in case the number of extra lines is 2 or odd, we round the start
-	 * line down.
-	 */
-	start &= ~0x1;
-
-	/* now we add the one line (if needed) to correct for the bayer order*/
-	start += for_bayer;
-	*start_line = start;
-	return sh_css_success;
-}
-
-static enum sh_css_err
-program_input_formatter(struct sh_css_pipe *pipe,
-			struct sh_css_binary *binary,
-			unsigned int left_padding)
-{
-	unsigned int start_line, start_column = 0,
-		     cropped_height = binary->in_frame_info.height,
-		     cropped_width  = binary->in_frame_info.width,
-		     num_vectors,
-		     buffer_height = 2,
-		     buffer_width = binary->info->max_input_width,
-		     two_ppc = pipe->two_ppc,
-		     vmem_increment = 0,
-		     deinterleaving = 0,
-		     deinterleaving_b = 0,
-		     width_a = 0,
-		     width_b = 0,
-		     bits_per_pixel,
-		     vectors_per_buffer,
-		     vectors_per_line = 0,
-		     buffers_per_line = 0,
-		     buf_offset_a = 0,
-		     buf_offset_b = 0,
-		     line_width = 0,
-		     width_b_factor = 1,
-		     start_column_b;
-	input_formatter_cfg_t	if_a_config, if_b_config;
-	enum sh_css_input_format input_format = binary->input_format;
-	enum sh_css_err err = sh_css_success;
-
-        bool input_is_raw = input_format_is_raw(input_format);
-
-	if (pipe->input_needs_raw_binning &&
-	    binary->info->enable.raw_binning) {
-		cropped_width *= 2;
-		cropped_width -= binary->info->left_cropping;
-		cropped_height *= 2;
-		cropped_height -= binary->info->left_cropping;
-	}
-
-	/* TODO: check to see if input is RAW and if current mode interprets
-	 * RAW data in any particular bayer order. copy binary with output
-	 * format other than raw should not result in dropping lines and/or
-	 * columns.
-	 */
-	err = input_start_line(pipe, cropped_height, &start_line);
-	if (err != sh_css_success)
-		return err;
-	err = input_start_column(pipe, cropped_width, &start_column);
-		if (err != sh_css_success)
-			return err;
-
-	if (!left_padding)
-		left_padding = binary->left_padding;
-	if (left_padding) {
-		num_vectors = CEIL_DIV(cropped_width + left_padding,
-				       ISP_VEC_NELEMS);
-	} else {
-		num_vectors = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);
-		num_vectors *= buffer_height;
-		/* todo: in case of left padding,
-		   num_vectors is vectors per line,
-		   otherwise vectors per line * buffer_height. */
-	}
-
-	start_column_b = start_column;
-
-	bits_per_pixel = input_formatter_get_alignment(INPUT_FORMATTER0_ID)
-		*8 / ISP_VEC_NELEMS;
-	switch (input_format) {
-	case SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY:
-		if (two_ppc) {
-			vmem_increment = 1;
-			deinterleaving = 1;
-			deinterleaving_b = 1;
-			/* half lines */
-			width_a = cropped_width * deinterleaving / 2;
-			width_b_factor = 2;
-			/* full lines */
-			width_b = width_a * width_b_factor;
-			buffer_width *= deinterleaving * 2;
-			/* Patch from bayer to yuv */
-			num_vectors *= deinterleaving;
-			buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
-			vectors_per_line = num_vectors / buffer_height;
-			/* Even lines are half size */
-			line_width = vectors_per_line *
-				input_formatter_get_alignment(
-				INPUT_FORMATTER0_ID) / 2;
-			start_column /= 2;
-		} else {
-			vmem_increment = 1;
-			deinterleaving = 3;
-			width_a = cropped_width * deinterleaving / 2;
-			buffer_width = buffer_width * deinterleaving / 2;
-			/* Patch from bayer to yuv */
-			num_vectors = num_vectors / 2 * deinterleaving;
-			start_column = start_column * deinterleaving / 2;
-		}
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV420_8:
-	case SH_CSS_INPUT_FORMAT_YUV420_10:
-		if (two_ppc) {
-			vmem_increment = 1;
-			deinterleaving = 1;
-			width_a = width_b = cropped_width * deinterleaving / 2;
-			buffer_width *= deinterleaving * 2;
-			num_vectors *= deinterleaving;
-			buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
-			vectors_per_line = num_vectors / buffer_height;
-			/* Even lines are half size */
-			line_width = vectors_per_line *
-				input_formatter_get_alignment(
-				INPUT_FORMATTER0_ID) / 2;
-			start_column *= deinterleaving;
-			start_column /= 2;
-			start_column_b = start_column;
-		} else {
-			vmem_increment = 1;
-			deinterleaving = 1;
-			width_a = cropped_width * deinterleaving;
-			buffer_width  *= deinterleaving * 2;
-			num_vectors  *= deinterleaving;
-			start_column *= deinterleaving;
-		}
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV422_8:
-	case SH_CSS_INPUT_FORMAT_YUV422_10:
-		if (two_ppc) {
-			vmem_increment = 1;
-			deinterleaving = 1;
-			width_a = width_b = cropped_width * deinterleaving;
-			buffer_width *= deinterleaving * 2;
-			num_vectors  *= deinterleaving;
-			start_column *= deinterleaving;
-			buf_offset_b   = buffer_width / 2 / ISP_VEC_NELEMS;
-			start_column_b = start_column;
-		} else {
-			vmem_increment = 1;
-			deinterleaving = 2;
-			width_a = cropped_width * deinterleaving;
-			buffer_width *= deinterleaving;
-			num_vectors  *= deinterleaving;
-			start_column *= deinterleaving;
-		}
-		break;
-	case SH_CSS_INPUT_FORMAT_RGB_444:
-	case SH_CSS_INPUT_FORMAT_RGB_555:
-	case SH_CSS_INPUT_FORMAT_RGB_565:
-	case SH_CSS_INPUT_FORMAT_RGB_666:
-	case SH_CSS_INPUT_FORMAT_RGB_888:
-		num_vectors *= 2;
-		if (two_ppc) {
-			deinterleaving = 2;	/* BR in if_a, G in if_b */
-			deinterleaving_b = 1;	/* BR in if_a, G in if_b */
-			buffers_per_line = 4;
-			start_column_b = start_column;
-			start_column *= deinterleaving;
-			start_column_b *= deinterleaving_b;
-		} else {
-			deinterleaving = 3;	/* BGR */
-			buffers_per_line = 3;
-			start_column *= deinterleaving;
-		}
-		vmem_increment = 1;
-		width_a = cropped_width * deinterleaving;
-		width_b = cropped_width * deinterleaving_b;
-		buffer_width *= buffers_per_line;
-		/* Patch from bayer to rgb */
-		num_vectors = num_vectors / 2 * deinterleaving;
-		buf_offset_b = buffer_width / 2 / ISP_VEC_NELEMS;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_6:
-	case SH_CSS_INPUT_FORMAT_RAW_7:
-	case SH_CSS_INPUT_FORMAT_RAW_8:
-	case SH_CSS_INPUT_FORMAT_RAW_10:
-	case SH_CSS_INPUT_FORMAT_RAW_12:
-		if (two_ppc) {
-			vmem_increment = 2;
-			deinterleaving = 1;
-			width_a = width_b = cropped_width / 2;
-			//start_column /= 2;
-			//start_column_b = start_column;
-			buf_offset_b = 1;
-		} else {
-			vmem_increment = 1;
-			deinterleaving = 2;
-			if (my_css.continuous &&
-			    binary->info->mode == SH_CSS_BINARY_MODE_COPY) {
-				/* No deinterleaving for sp copy */
-				deinterleaving = 1;
-			}
-			width_a = cropped_width;
-			/* Must be multiple of deinterleaving */
-			num_vectors = CEIL_MUL(num_vectors, deinterleaving);
-		}
-		buffer_height *= 2;
-		if (my_css.continuous)
-			buffer_height *= 2;
-		vectors_per_line = CEIL_DIV(cropped_width, ISP_VEC_NELEMS);
-		vectors_per_line = CEIL_MUL(vectors_per_line, deinterleaving);
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_14:
-	case SH_CSS_INPUT_FORMAT_RAW_16:
-		if (two_ppc) {
-			num_vectors *= 2;
-			vmem_increment = 1;
-			deinterleaving = 2;
-			width_a = width_b = cropped_width;
-			/* B buffer is one line further */
-			buf_offset_b = buffer_width / ISP_VEC_NELEMS;
-			bits_per_pixel *= 2;
-		} else {
-			vmem_increment = 1;
-			deinterleaving = 2;
-			width_a = cropped_width;
-			start_column /= deinterleaving;
-		}
-		buffer_height *= 2;
-		break;
-	case SH_CSS_INPUT_FORMAT_BINARY_8:
-/* Fall through */
-	case N_SH_CSS_INPUT_FORMAT:
-		break;
-	}
-	if (width_a == 0)
-		return sh_css_err_unsupported_input_mode;
-
-	if (two_ppc)
-		left_padding /= 2;
-
-	/* Default values */
-	if (left_padding)
-		vectors_per_line = num_vectors;
-	if (!vectors_per_line) {
-		vectors_per_line = CEIL_MUL(num_vectors / buffer_height,
-					    deinterleaving);
-		line_width = 0;
-	}
-	if (!line_width)
-		line_width = vectors_per_line *
-		input_formatter_get_alignment(INPUT_FORMATTER0_ID);
-#if 0
-	/* Klocwork pacifier: VA_UNUSED.GEN */
-	/* buffers_per_line is never used, this is SUSPICIOUS */
-	/* NEEDS FURTHER INVESTIGATION */
-	if (!buffers_per_line)
-		buffers_per_line = deinterleaving;
-#endif
-	line_width = CEIL_MUL(line_width,
-		input_formatter_get_alignment(INPUT_FORMATTER0_ID)
-		* vmem_increment);
-
-	vectors_per_buffer = buffer_height * buffer_width / ISP_VEC_NELEMS;
-#if 0
-	if (sh_css_continuous_is_enabled())
-		vectors_per_buffer *= 2;
-#endif
-
-	if (pipe->input_mode == SH_CSS_INPUT_MODE_TPG &&
-	    binary->info->mode == SH_CSS_BINARY_MODE_VIDEO) {
-		/* workaround for TPG in video mode*/
-		start_line = 0;
-		start_column = 0;
-		cropped_height -= start_line;
-		width_a -= start_column;
-	}
-
-        /* When two_ppc is enabled, IF_A and IF_B gets seperate
-         * bayer components. Therefore, it is not possible to
-         * correct the bayer order to GRBG in horizontal direction
-         * by shifting start_column.
-         * Instead, IF_A and IF_B output (VMEM) addresses should be
-         * swapped for this purpose (@Gokturk).
-         */
-	if (two_ppc && input_is_raw) {
-		if (start_column%2 == 1) {
-			/* Still correct for center of image. Just subtract 
-			 * the part (which used to be correcting bayer order,
-			 * now we do it by swapping the buffers) */
-			start_column   = start_column - 1;
-			
-			/* Buffer start address swap from (0, buf_offset_b) ->
-			 * (buf_offset_b, 0) */
-			buf_offset_a = buf_offset_b;
-			buf_offset_b = 0;
-			/* Since each IF gets every two pixel in twoppc case, 
-		 	* we need to halve the start_column per IF. */
-			start_column /= 2;
-			start_column_b = start_column;
-			start_column += 1;
-		} else {
-			start_column /= 2;
-			start_column_b = start_column;
-		}
-
-		
-	}
-	
-	if_a_config.start_line = start_line;
-	if_a_config.start_column = start_column;
-	if_a_config.left_padding = left_padding / deinterleaving;
-	if_a_config.cropped_height = cropped_height;
-	if_a_config.cropped_width = width_a;
-	if_a_config.deinterleaving = deinterleaving;
-	if_a_config.buf_vecs = vectors_per_buffer;
-	if_a_config.buf_start_index = buf_offset_a;
-	if_a_config.buf_increment = vmem_increment;
-	if_a_config.buf_eol_offset =
-	    buffer_width * bits_per_pixel / 8 - line_width;
-	if_a_config.is_yuv420_format =
-		(input_format == SH_CSS_INPUT_FORMAT_YUV420_8)
-		|| (input_format == SH_CSS_INPUT_FORMAT_YUV420_10);
-	if_a_config.block_no_reqs =
-		pipe->input_mode != SH_CSS_INPUT_MODE_SENSOR;
-
-	if (two_ppc) {
-		if (deinterleaving_b) {
-			deinterleaving = deinterleaving_b;
-			width_b = cropped_width * deinterleaving;
-			buffer_width *= deinterleaving;
-			/* Patch from bayer to rgb */
-			num_vectors = num_vectors / 2 *
-					deinterleaving * width_b_factor;
-			vectors_per_line = num_vectors / buffer_height;
-			line_width = vectors_per_line *
-				input_formatter_get_alignment(
-				INPUT_FORMATTER0_ID);
-		}
-		if_b_config.start_line = start_line;
-		if_b_config.start_column = start_column_b;
-		if_b_config.left_padding = left_padding / deinterleaving;
-		if_b_config.cropped_height = cropped_height;
-		if_b_config.cropped_width = width_b;
-		if_b_config.deinterleaving = deinterleaving;
-		if_b_config.buf_vecs = vectors_per_buffer;
-		if_b_config.buf_start_index = buf_offset_b;
-		if_b_config.buf_increment = vmem_increment;
-		if_b_config.buf_eol_offset =
-		    buffer_width * bits_per_pixel/8 - line_width;
-		if_b_config.is_yuv420_format =
-		    input_format == SH_CSS_INPUT_FORMAT_YUV420_8
-		    || input_format == SH_CSS_INPUT_FORMAT_YUV420_10;
-		if_b_config.block_no_reqs =
-			pipe->input_mode != SH_CSS_INPUT_MODE_SENSOR;
-		if (memcmp(&if_a_config, &my_css.curr_if_a_config,
-			   sizeof(input_formatter_cfg_t)) ||
-		    memcmp(&if_b_config, &my_css.curr_if_b_config,
-			   sizeof(input_formatter_cfg_t))) {
-			my_css.curr_if_a_config = if_a_config;
-			my_css.curr_if_b_config = if_b_config;
-			sh_css_sp_set_if_configs(&if_a_config, &if_b_config);
-		}
-	} else {
-		if (memcmp(&if_a_config, &my_css.curr_if_a_config,
-			   sizeof(input_formatter_cfg_t))) {
-			my_css.curr_if_a_config = if_a_config;
-			sh_css_sp_set_if_configs(&if_a_config, NULL);
-		}
-	}
-	return sh_css_success;
-}
-
-static enum sh_css_err
-sh_css_config_input_network(struct sh_css_pipe *pipe,
-			    struct sh_css_binary *binary)
-{
-	unsigned int fmt_type;
-	enum sh_css_err err = sh_css_success;
-
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->pipeline.stages)
-		binary = pipe->pipeline.stages->binary;
-
-	err = sh_css_input_format_type(pipe->input_format,
-				       pipe->mipi_config.comp,
-				       &fmt_type);
-	if (err != sh_css_success)
-		return err;
-	if (fmt_type != my_css.curr_fmt_type ||
-	    pipe->ch_id != my_css.curr_ch_id ||
-	    pipe->input_mode != my_css.curr_input_mode) {
-		my_css.curr_fmt_type = fmt_type;
-		my_css.curr_ch_id = pipe->ch_id;
-		my_css.curr_input_mode = pipe->input_mode;
-		sh_css_sp_program_input_circuit(fmt_type,
-						pipe->ch_id,
-						pipe->input_mode);
-	}
-
-	if (binary && (binary->online || my_css.continuous)) {
-		if (my_css.continuous)
-			my_css.start_sp_copy = true;
-		err = program_input_formatter(pipe, binary, my_css.left_padding);
-		if (err != sh_css_success)
-			return err;
-	}
-
-	if (pipe->input_mode == SH_CSS_INPUT_MODE_TPG ||
-	    pipe->input_mode == SH_CSS_INPUT_MODE_PRBS) {
-		unsigned int hblank_cycles = 100,
-			     vblank_lines = 6,
-			     width,
-			     height,
-			     vblank_cycles;
-		width  = pipe->input_width;
-		height = pipe->input_height;
-		vblank_cycles = vblank_lines * (width + hblank_cycles);
-		sh_css_sp_configure_sync_gen(width, height, hblank_cycles,
-					     vblank_cycles);
-	}
-	return sh_css_success;
-}
-
-#if WITH_PC_MONITORING
-static struct task_struct *my_kthread;    /* Handle for the monitoring thread */
-static int sh_binary_running;         /* Enable sampling in the thread */
-
-static void print_pc_histo(char *core_name, struct sh_css_pc_histogram *hist)
-{
-	unsigned i;
-	unsigned cnt_run = 0;
-	unsigned cnt_stall = 0;
-	sh_css_print("%s histogram length = %d\n", core_name, hist->length);
-	sh_css_print("%s PC\trun\tstall\n", core_name);
-
-	for (i = 0; i < hist->length; i++) {
-		if ((hist->run[i] == 0) && (hist->run[i] == hist->stall[i]))
-			continue;
-		sh_css_print("%s %d\t%d\t%d\n",
-				core_name, i, hist->run[i], hist->stall[i]);
-		cnt_run += hist->run[i];
-		cnt_stall += hist->stall[i];
-	}
-
-	sh_css_print(" Statistics for %s, cnt_run = %d, cnt_stall = %d, "
-	       "hist->length = %d\n",
-			core_name, cnt_run, cnt_stall, hist->length);
-}
-
-static void print_pc_histogram(void)
-{
-	struct sh_css_binary_metrics *metrics;
-
-	for (metrics = sh_css_metrics.binary_metrics;
-	     metrics;
-	     metrics = metrics->next) {
-		if (metrics->mode == SH_CSS_BINARY_MODE_PREVIEW ||
-		    metrics->mode == SH_CSS_BINARY_MODE_VF_PP) {
-			sh_css_print("pc_histogram for binary %d is SKIPPED\n",
-				metrics->id);
-			continue;
-		}
-
-		sh_css_print(" pc_histogram for binary %d\n", metrics->id);
-		print_pc_histo("  ISP", &metrics->isp_histogram);
-		print_pc_histo("  SP",   &metrics->sp_histogram);
-		sh_css_print("print_pc_histogram() done for binay->id = %d, "
-			     "done.\n", metrics->id);
-	}
-
-	sh_css_print("PC_MONITORING:print_pc_histogram() -- DONE\n");
-}
-
-static int pc_monitoring(void *data)
-{
-	int i = 0;
-
-	while (true) {
-		if (sh_binary_running) {
-			sh_css_metrics_sample_pcs();
-#if MULTIPLE_SAMPLES
-			for (i = 0; i < NOF_SAMPLES; i++)
-				sh_css_metrics_sample_pcs();
-#endif
-		}
-		usleep_range(10, 50);
-	}
-	return 0;
-}
-
-static void spying_thread_create(void)
-{
-	my_kthread = kthread_run(pc_monitoring, NULL, "sh_pc_monitor");
-	sh_css_metrics_enable_pc_histogram(1);
-}
-
-static void input_frame_info(struct sh_css_frame_info frame_info)
-{
-	sh_css_print("SH_CSS:input_frame_info() -- frame->info.width = %d, "
-	       "frame->info.height = %d, format = %d\n",
-			frame_info.width, frame_info.height, frame_info.format);
-}
-#endif /* WITH_PC_MONITORING */
-
-static void
-start_binary(struct sh_css_pipe *pipe,
-	     struct sh_css_binary *binary)
-{
-	if (my_css.reconfigure_css_rx)
-		sh_css_rx_disable();
-
-	sh_css_metrics_start_binary(&binary->metrics);
-
-#if WITH_PC_MONITORING
-	sh_css_print("PC_MONITORING: %s() -- binary id = %d , "
-		     "enable_dvs_envelope = %d\n",
-		     __func__, binary->info->id,
-		     binary->info->enable.dvs_envelope);
-	input_frame_info(binary->in_frame_info);
-
-	if (binary->info->mode == SH_CSS_BINARY_MODE_VIDEO)
-		sh_binary_running = true;
-#endif
-
-	my_css.curr_state = sh_css_state_executing_isp;
-
-	sh_css_sp_start_isp();
-
-	if (my_css.reconfigure_css_rx) {
-		pipe->mipi_config.is_two_ppc = pipe->two_ppc;
-		sh_css_rx_configure(&pipe->mipi_config);
-		my_css.reconfigure_css_rx = false;
-	}
-}
-
-void
-sh_css_frame_zero(struct sh_css_frame *frame)
-{
-	mmgr_clear(frame->data, frame->data_bytes);
-}
-
-/* start the copy function on the SP */
-static enum sh_css_err
-start_copy_on_sp(struct sh_css_pipe *pipe,
-		 struct sh_css_binary *binary,
-		 struct sh_css_frame *out_frame)
-{
-	if (my_css.reconfigure_css_rx)
-		sh_css_rx_disable();
-
-	if (pipe->input_format == SH_CSS_INPUT_FORMAT_BINARY_8)
-		sh_css_sp_start_binary_copy(out_frame, pipe->two_ppc);
-	else
-		sh_css_sp_start_raw_copy(binary, out_frame, pipe->two_ppc,
-					 pipe->input_needs_raw_binning,
-					SH_CSS_PIPE_CONFIG_OVRD_THRD_2);
-
-	sh_css_sp_start_isp();
-
-	if (my_css.reconfigure_css_rx) {
-		/* do we need to wait for the IF do be ready? */
-		pipe->mipi_config.is_two_ppc = pipe->two_ppc;
-		sh_css_rx_configure(&pipe->mipi_config);
-		my_css.reconfigure_css_rx = false;
-	}
-
-	return sh_css_success;
-}
-
-/* Pipeline:
- * To organize the several different binaries for each type of mode,
- * we use a pipeline. A pipeline contains a number of stages, each with
- * their own binary and frame pointers.
- * When stages are added to a pipeline, output frames that are not passed
- * from outside are automatically allocated.
- * When input frames are not passed from outside, each stage will use the
- * output frame of the previous stage as input (the full resolution output,
- * not the viewfinder output).
- * Pipelines must be cleaned and re-created when settings of the binaries
- * change.
- */
-static void
-sh_css_pipeline_stage_destroy(struct sh_css_pipeline_stage *me)
-{
-	if (me->out_frame_allocated)
-		sh_css_frame_free(me->args.out_frame);
-	if (me->vf_frame_allocated)
-		sh_css_frame_free(me->args.out_vf_frame);
-	sh_css_free(me);
-}
-
-static void
-sh_css_binary_args_reset(struct sh_css_binary_args *args)
-{
-	args->in_frame      = NULL;
-	args->out_frame     = NULL;
-	args->in_ref_frame  = NULL;
-	args->out_ref_frame = NULL;
-	args->in_tnr_frame  = NULL;
-	args->out_tnr_frame = NULL;
-	args->extra_frame   = NULL;
-	args->out_vf_frame  = NULL;
-	args->copy_vf       = false;
-	args->copy_output   = true;
-	args->vf_downscale_log2 = 0;
-}
-
-static enum sh_css_err
-sh_css_pipeline_stage_create(struct sh_css_pipeline_stage **me,
-			     struct sh_css_binary *binary,
-			     const struct sh_css_fw_info *firmware,
-			     int    mode,
-			     struct sh_css_frame *cc_frame,
-			     struct sh_css_frame *in_frame,
-			     struct sh_css_frame *out_frame,
-			     struct sh_css_frame *vf_frame)
-{
-	struct sh_css_pipeline_stage *stage = sh_css_malloc(sizeof(*stage));
-	if (!stage)
-		return sh_css_err_cannot_allocate_memory;
-	stage->binary = firmware ? NULL : binary;
-	stage->binary_info = firmware ?
-			     (struct sh_css_binary_info *)
-				&firmware->info.isp
-			     : (struct sh_css_binary_info *)binary->info;
-	stage->firmware = firmware;
-	stage->mode = mode;
-	stage->out_frame_allocated = false;
-	stage->vf_frame_allocated = false;
-	stage->irq_buf_flags = 0x0;
-	stage->next = NULL;
-	sh_css_binary_args_reset(&stage->args);
-
-	if (!in_frame && !firmware && !binary->online)
-		return sh_css_err_internal_error;
-
-	if (!out_frame && binary && binary->out_frame_info.width) {
-		enum sh_css_err ret =
-		    sh_css_frame_allocate_from_info(&out_frame,
-						    &binary->out_frame_info);
-		if (ret != sh_css_success) {
-			sh_css_free(stage);
-			return ret;
-		}
-		stage->out_frame_allocated = true;
-	}
-	/* VF frame is not needed in case of need_pp
-	   However, the capture binary needs a vf frame to write to.
-	*/
-	if (!vf_frame) {
-		if ((binary && binary->vf_frame_info.width) ||
-		    (firmware &&
-		     firmware->info.isp.enable.vf_veceven)
-		    ) {
-			enum sh_css_err ret =
-			    sh_css_frame_allocate_from_info(&vf_frame,
-						    &binary->vf_frame_info);
-			if (ret != sh_css_success) {
-				if (stage->out_frame_allocated)
-					sh_css_frame_free(out_frame);
-				sh_css_free(stage);
-				return ret;
-			}
-			stage->vf_frame_allocated = true;
-		}
-	} else if (vf_frame && binary && binary->vf_frame_info.width)
-		stage->vf_frame_allocated = true;
-
-	stage->args.cc_frame = cc_frame;
-	stage->args.in_frame = in_frame;
-	stage->args.out_frame = out_frame;
-	stage->args.out_vf_frame = vf_frame;
-	*me = stage;
-	return sh_css_success;
-}
-
-static void
-sh_css_pipeline_init(struct sh_css_pipeline *me, enum sh_css_pipe_id pipe_id)
-{
-	struct sh_css_frame init_frame = {
-		.dynamic_data_index = SH_CSS_INVALID_FRAME_ID };
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipeline_init() enter:\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return;
-
-	me->pipe_id = pipe_id;
-	me->stages = NULL;
-	me->reload = true;
-	me->current_stage = NULL;
-	me->in_frame = init_frame;
-	me->out_frame = init_frame;
-	me->vf_frame = init_frame;
-}
-
-/** @brief Add a stage to pipeline.
- *
- * @param	me	Pointer to the pipeline to be added to.
- * @param[in]	binary		ISP binary of new stage.
- * @param[in]	firmware	ISP firmware of new stage.
- * @param[in]	mode		ISP mode of new stage.
- * @param[in]	cc_frame		The cc frame to the stage.
- * @param[in]	in_frame		The input frame to the stage.
- * @param[in]	out_frame		The output frame of the stage.
- * @param[in]	vf_frame		The viewfinder frame of the stage.
- * @param[in]	stage			The successor of the stage.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Add a new stage to a non-NULL pipeline.
- * The stage consists of an ISP binary or firmware and input and output arguments.
-*/
-static enum sh_css_err
-sh_css_pipeline_add_stage(struct sh_css_pipeline *me,
-			  struct sh_css_binary *binary,
-			  const struct sh_css_fw_info *firmware,
-			  unsigned int mode,
-			  struct sh_css_frame *cc_frame,
-			  struct sh_css_frame *in_frame,
-			  struct sh_css_frame *out_frame,
-			  struct sh_css_frame *vf_frame,
-			  struct sh_css_pipeline_stage **stage)
-{
-	struct sh_css_pipeline_stage *last, *new_stage = NULL;
-	enum sh_css_err err;
-
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipeline_add_stage() enter:\n");
-
-	/* other arguments can be NULL */
-	assert(me != NULL);
-	if (me == NULL)
-		return sh_css_err_internal_error;
-
-	last = me->stages;
-
-	if (!binary && !firmware)
-		return sh_css_err_internal_error;
-
-	while (last && last->next)
-		last = last->next;
-
-	/* if in_frame is not set, we use the out_frame from the previous
-	 * stage, if no previous stage, it's an error.
-	 */
-	if (!in_frame && !firmware && !binary->online) {
-		if (last)
-			in_frame = last->args.out_frame;
-		if (!in_frame)
-			return sh_css_err_internal_error;
-	}
-	err = sh_css_pipeline_stage_create(&new_stage, binary, firmware,
-					   mode, cc_frame,
-					   in_frame, out_frame, vf_frame);
-	if (err != sh_css_success)
-		return err;
-	if (last)
-		last->next = new_stage;
-	else
-		me->stages = new_stage;
-	if (stage)
-		*stage = new_stage;
-	return sh_css_success;
-}
-
-static enum sh_css_err
-sh_css_pipeline_get_stage(struct sh_css_pipeline *me,
-			  int mode,
-			  struct sh_css_pipeline_stage **stage)
-{
-	struct sh_css_pipeline_stage *s;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipeline_get_stage() enter:\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return sh_css_err_internal_error;
-
-	assert(stage != NULL);
-	if (stage == NULL)
-		return sh_css_err_internal_error;
-
-	for (s = me->stages; s; s = s->next) {
-		if (s->mode == mode) {
-			*stage = s;
-			return sh_css_success;
-		}
-	}
-	return sh_css_err_internal_error;
-}
-
-static enum sh_css_err
-sh_css_pipeline_get_output_stage(struct sh_css_pipeline *me,
-				 int mode,
-				 struct sh_css_pipeline_stage **stage)
-{
-	struct sh_css_pipeline_stage *s;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipeline_get_output_stage() enter:\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return sh_css_err_internal_error;
-
-	assert(stage != NULL);
-	if (stage == NULL)
-		return sh_css_err_internal_error;
-
-	*stage = NULL;
-	/* First find acceleration firmware at end of pipe */
-	for (s = me->stages; s; s = s->next) {
-		if (s->firmware && s->mode == mode &&
-		    s->firmware->info.isp.enable.output)
-			*stage = s;
-	}
-	if (*stage)
-		return sh_css_success;
-	/* If no firmware, find binary in pipe */
-	return sh_css_pipeline_get_stage(me, mode, stage);
-}
-
-static void
-sh_css_pipeline_restart(struct sh_css_pipeline *me)
-{
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipeline_restart() enter:\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return;
-
-	me->current_stage = NULL;
-}
-
-static void
-sh_css_pipeline_clean(struct sh_css_pipeline *me)
-{
-	struct sh_css_pipeline_stage *s;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipeline_clean() enter:\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return;
-
-	s = me->stages;
-
-	while (s) {
-		struct sh_css_pipeline_stage *next = s->next;
-		sh_css_pipeline_stage_destroy(s);
-		s = next;
-	}
-	sh_css_pipeline_init(me, me->pipe_id);
-}
-
-static void
-sh_css_pipe_start(struct sh_css_pipe *pipe)
-{
-	struct sh_css_pipeline_stage *stage;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipe_start() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	stage = pipe->pipeline.stages;
-
-	if (stage == NULL)
-		return;
-
-	pipe->pipeline.current_stage = stage;
-
-	start_binary(pipe, stage->binary);
-}
-
-static void start_pipe(
-	struct sh_css_pipe *me,
-	enum sh_css_pipe_config_override copy_ovrd)
-{
-	bool low_light;
-	bool is_preview;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"start_pipe() enter:\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return;
-
-	low_light = me->mode == SH_CSS_CAPTURE_PIPELINE &&
-			 (me->capture_mode == SH_CSS_CAPTURE_MODE_LOW_LIGHT ||
-			  me->capture_mode == SH_CSS_CAPTURE_MODE_BAYER);
-	is_preview = me->mode == SH_CSS_PREVIEW_PIPELINE;
-
-	sh_css_sp_init_pipeline(&me->pipeline,
-				me->mode,
-				is_preview,
-				low_light,
-				me->xnr,
-				me->two_ppc,
-				my_css.continuous,
-				false,
-				me->input_needs_raw_binning,
-			copy_ovrd);
-
-	/* prepare update of params to ddr */
-	sh_css_commit_isp_config(&me->pipeline, false);
-
-	sh_css_pipe_start(me);
-}
-
-static void
-sh_css_set_irq_buffer(struct sh_css_pipeline_stage *stage,
-			enum sh_css_frame_id frame_id,
-			struct sh_css_frame *frame)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_set_irq_buffer() enter:\n");
-	if (stage && frame)
-		stage->irq_buf_flags |= 1<<frame_id;
-}
-
-void sh_css_frame_info_set_width(
-	struct sh_css_frame_info *info,
-	unsigned int width, unsigned int min_padded_width)
-{
-	unsigned int align = width < min_padded_width ? min_padded_width : width;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_info_set_width() enter: "
-		"width=%d, format=%d, align=%d\n", width, info->format, align);
-
-	assert(info != NULL);
-	if (info == NULL)
-		return;
-
-	info->width = width;
-	/* frames with a U and V plane of 8 bits per pixel need to have
-	   all planes aligned, this means double the alignment for the
-	   Y plane if the horizontal decimation is 2. */
-	if (info->format == SH_CSS_FRAME_FORMAT_YUV420 ||
-	    info->format == SH_CSS_FRAME_FORMAT_YV12)
-		info->padded_width = CEIL_MUL(align, 2*HIVE_ISP_DDR_WORD_BYTES);
-	else if (info->format == SH_CSS_FRAME_FORMAT_YUV_LINE)
-		info->padded_width = CEIL_MUL(align, 2*ISP_VEC_NELEMS);
-	else if (info->format == SH_CSS_FRAME_FORMAT_RAW)
-		info->padded_width = CEIL_MUL(align, 2*ISP_VEC_NELEMS);
-	else
-		info->padded_width = CEIL_MUL(align, HIVE_ISP_DDR_WORD_BYTES);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_info_set_width() leave: "
-		"padded_width=%d\n",
-		info->padded_width);
-}
-
-static void sh_css_frame_info_set_format(
-	struct sh_css_frame_info *info,
-	enum sh_css_frame_format format)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_frame_info_set_format() enter:\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return;
-
-	/* yuv_line has 2*NWAY alignment */
-	info->format = format;
-	/* HACK: this resets the padded width incorrectly.
-	   Lex needs to fix this in the vf_veceven module. */
-	info->padded_width =  CEIL_MUL(info->padded_width, 2*ISP_VEC_NELEMS);
-}
-
-void sh_css_frame_info_init(
-	struct sh_css_frame_info *info, unsigned int width, unsigned int height,
-	unsigned int min_padded_width, enum sh_css_frame_format format)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		      "sh_css_frame_info_init() enter: width=%d, min_padded_width=%d, height=%d, format=%d\n",
-		      width, min_padded_width, height, format);
-
-	assert(info != NULL);
-	if (info == NULL)
-		return;
-
-	info->height = height;
-	info->format = format;
-	sh_css_frame_info_set_width(info, width, min_padded_width);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_info_init() leave: return_void\n");
-}
-
-static void invalidate_video_binaries(
-	struct sh_css_pipe *pipe)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"invalidate_video_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	pipe->pipeline.reload   = true;
-	pipe->pipe.video.copy_binary.info = NULL;
-	pipe->pipe.video.video_binary.info = NULL;
-	pipe->pipe.video.vf_pp_binary.info = NULL;
-	if (pipe->shading_table) {
-		sh_css_shading_table_free(pipe->shading_table);
-		pipe->shading_table = NULL;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"invalidate_video_binaries() leave:\n");
-}
-
-void sh_css_set_shading_table(
-	const struct sh_css_shading_table *table)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_shading_table() enter: "
-		"table=%p\n",table);
-#if 0
-	if (table != my_css.shading_table)
-		reset_mode_shading_tables();
-
-	my_css.shading_table = table;
-#endif
-	if (sh_css_params_set_shading_table(table)) {
-		sh_css_pipe_free_shading_table(&my_css.preview_pipe);
-		sh_css_pipe_free_shading_table(&my_css.video_pipe);
-		sh_css_pipe_free_shading_table(&my_css.capture_pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_shading_table() leave: return_void\n");
-}
-
-/* CSS receiver programming */
-enum sh_css_err sh_css_pipe_configure_input_port(
-	struct sh_css_pipe	*pipe,
-	const mipi_port_ID_t	port,
-	const unsigned int		num_lanes,
-	const unsigned int		timeout)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() enter: "
-		"port=%d, "
-		"num_lanes=%d, "
-		"timeout=%d\n",
-		port, num_lanes,
-		timeout);
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(port < N_MIPI_PORT_ID);
-	if (port >= N_MIPI_PORT_ID)
-		return sh_css_err_internal_error;
-
-	if (num_lanes > MIPI_PORT_MAXLANES[port]) {
-		return sh_css_err_conflicting_mipi_settings;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() leave: return_err=%d", sh_css_err_conflicting_mipi_settings);
-	}
-	if (num_lanes > MIPI_4LANE_CFG) {
-		return sh_css_err_conflicting_mipi_settings;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() leave: return_err=%d", sh_css_err_conflicting_mipi_settings);
-	}
-
-	pipe->mipi_config.port = port;
-#if defined(HAS_RX_VERSION_1)
-	pipe->mipi_config.num_lanes = num_lanes;
-#endif
-	pipe->mipi_config.timeout = timeout;
-	my_css.reconfigure_css_rx = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() leave: return_err=%d", sh_css_success);
-return sh_css_success;
-}
-
-enum sh_css_err sh_css_pipe_set_compression(
-	struct sh_css_pipe    *pipe,
-	const mipi_predictor_t	comp,
-	const unsigned int compressed_bits_per_pixel,
-	const unsigned int uncompressed_bits_per_pixel)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() enter: "
-		"comp=%d, "
-		"compressed_bits_per_pixel=%d, "
-		"uncompressed_bits_per_pixel=%d\n",
-		comp, compressed_bits_per_pixel,
-		uncompressed_bits_per_pixel);
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(comp < N_MIPI_PREDICTOR_TYPES);
-	if (comp >= N_MIPI_PREDICTOR_TYPES)
-		return sh_css_err_internal_error;
-
-	if (comp == MIPI_PREDICTOR_NONE) {
-		if (compressed_bits_per_pixel || uncompressed_bits_per_pixel) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() leave: return_err=%d", sh_css_err_conflicting_mipi_settings);
-			return sh_css_err_conflicting_mipi_settings;
-		}
-	} else {
-		if (compressed_bits_per_pixel < 6 ||
-		    compressed_bits_per_pixel > 8) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() leave: return_err=%d", sh_css_err_conflicting_mipi_settings);
-			return sh_css_err_conflicting_mipi_settings;
-		}
-		if (uncompressed_bits_per_pixel != 10 &&
-		    uncompressed_bits_per_pixel != 12) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() leave: return_err=%d", sh_css_err_conflicting_mipi_settings);
-			return sh_css_err_conflicting_mipi_settings;
-		}
-	}
-	pipe->mipi_config.comp = comp;
-#if defined(HAS_RX_VERSION_1)
-	pipe->mipi_config.comp_bpp = compressed_bits_per_pixel;
-	pipe->mipi_config.uncomp_bpp = uncompressed_bits_per_pixel;
-#endif
-	my_css.reconfigure_css_rx = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_compression() leave: return_err=%d", sh_css_success);
-
-return sh_css_success;
-}
-
-void sh_css_tpg_configure(
-	unsigned int x_mask,
-	int x_delta,
-	unsigned int y_mask,
-	int y_delta,
-	unsigned int xy_mask)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_tpg_configure() enter: "
-		"x_mask=%d, y_mask=%d, xy_mask=%d, "
-		"x_delta=%d, y_delta=%d\n",
-		x_mask, y_mask, xy_mask,
-		x_delta, y_delta);
-	sh_css_sp_configure_tpg(x_mask, y_mask, x_delta, y_delta, xy_mask);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_tpg_configure() leave: return_void\n");
-}
-
-void sh_css_prbs_set_seed(
-	int seed)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_prbs_set_seed() enter: "
-		"seed=%d\n",seed);
-	sh_css_sp_configure_prbs(seed);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_prbs_set_seed() leave: return_void\n");
-}
-
-/* currently, the capture pp binary requires an internal frame. This will
-   be removed in the future. */
-static enum sh_css_err alloc_capture_pp_frame(
-	struct sh_css_pipe *pipe,
-	const struct sh_css_binary *binary)
-{
-	struct sh_css_frame_info cpp_info;
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "alloc_capture_pp_frame() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return sh_css_err_internal_error;
-
-	cpp_info = binary->internal_frame_info;
-	cpp_info.format = SH_CSS_FRAME_FORMAT_YUV420;
-	if (pipe->pipe.capture.capture_pp_frame)
-		sh_css_frame_free(pipe->pipe.capture.capture_pp_frame);
-	err = sh_css_frame_allocate_from_info(
-			&pipe->pipe.capture.capture_pp_frame, &cpp_info);
-	return err;
-}
-
-static void invalidate_preview_binaries(
-	struct sh_css_pipe *pipe)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "invalidate_preview_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	pipe->pipeline.reload     = true;
-	pipe->pipe.preview.preview_binary.info = NULL;
-	pipe->pipe.preview.vf_pp_binary.info   = NULL;
-	pipe->pipe.preview.copy_binary.info    = NULL;
-	if (pipe->shading_table) {
-		sh_css_shading_table_free(pipe->shading_table);
-		pipe->shading_table = NULL;
-	}
-}
-
-static void invalidate_capture_binaries(
-	struct sh_css_pipe *pipe)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "invalidate_capture_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	pipe->pipeline.reload        = true;
-	pipe->pipe.capture.copy_binary.info       = NULL;
-	pipe->pipe.capture.primary_binary.info    = NULL;
-	pipe->pipe.capture.pre_isp_binary.info    = NULL;
-	pipe->pipe.capture.gdc_binary.info        = NULL;
-	pipe->pipe.capture.post_isp_binary.info   = NULL;
-	pipe->pipe.capture.anr_binary.info        = NULL;
-	pipe->pipe.capture.capture_pp_binary.info = NULL;
-	pipe->pipe.capture.vf_pp_binary.info      = NULL;
-	if (pipe->shading_table) {
-		sh_css_shading_table_free(pipe->shading_table);
-		pipe->shading_table = NULL;
-	}
-}
-
-static void sh_css_pipe_invalidate_binaries(
-	struct sh_css_pipe *pipe)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_invalidate_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	switch (pipe->mode) {
-	case SH_CSS_VIDEO_PIPELINE:
-		invalidate_video_binaries(pipe);
-		break;
-	case SH_CSS_CAPTURE_PIPELINE:
-		invalidate_capture_binaries(pipe);
-		break;
-	case SH_CSS_PREVIEW_PIPELINE:
-		invalidate_preview_binaries(pipe);
-		break;
-	default:
-		break;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_invalidate_binaries() leave:\n");
-}
-
-static void
-enable_interrupts(void)
-{
-/* Select whether the top IRQ delivers a level signal or not. In CSS 2.0 this choice is on the interface */
-	bool enable_pulse = false;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "enable_interrupts() enter:\n");
-/* Enable IRQ on the SP which signals that SP goes to idle (aka ready state) */
-	cnd_sp_irq_enable(SP0_ID, true);
-/* Set the IRQ device 0 to either level or pulse */
-	irq_enable_pulse(IRQ0_ID, enable_pulse);
-	virq_enable_channel(virq_sp, true);
-	/* Triggered by SP to signal Host that there are new statistics */
-	virq_enable_channel((virq_id_t)(IRQ_SW_CHANNEL1_ID + IRQ_SW_CHANNEL_OFFSET), true);
-	/* Triggered by SP to signal Host that there is data in one of the
-	 * SP->Host queues.*/
-#if !defined(HAS_IRQ_MAP_VERSION_2)
-/* IRQ_SW_CHANNEL2_ID does not exist on 240x systems */
-	virq_enable_channel((virq_id_t)(IRQ_SW_CHANNEL2_ID + IRQ_SW_CHANNEL_OFFSET), true);
-	virq_clear_all();
-#endif
-
-	sh_css_rx_enable_all_interrupts();
-
-#if defined(HRT_CSIM)
-/*
- * Enable IRQ on the SP which signals that SP goes to idle
- * to get statistics for each binary
- */
-	cnd_isp_irq_enable(ISP0_ID, true);
-	virq_enable_channel(virq_isp, true);
-#endif
-}
-
-static const struct sh_css_env default_env = {
-  .sh_env	  = { NULL, NULL, NULL },
-  .print_env	  = { NULL, NULL }
-};
-
-struct sh_css_env
-sh_css_default_env(void)
-{
-	struct sh_css_env env = default_env;
-	return env;
-}
-
-enum sh_css_err sh_css_init(
-	const struct sh_css_env *env,
-	const char			*fw_data,
-	const unsigned int	fw_size)
-{
-	enum sh_css_err err;
-	void *(*malloc_func) (size_t size, bool zero_mem) = env->sh_env.alloc;
-	void (*free_func) (void *ptr) = env->sh_env.free;
-	void (*flush_func) (struct sh_css_acc_fw *fw) = env->sh_env.flush;
-
-	static struct sh_css default_css = DEFAULT_CSS;
-	static struct sh_css_preview_settings preview = DEFAULT_PREVIEW_SETTINGS;
-	static struct sh_css_capture_settings capture = DEFAULT_CAPTURE_SETTINGS;
-	static struct sh_css_video_settings   video   = DEFAULT_VIDEO_SETTINGS;
-
-	hrt_data select = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_select)
-						& (~GPIO_FLASH_PIN_MASK);
-	hrt_data enable = gpio_reg_load(GPIO0_ID, _gpio_block_reg_do_e)
-							| GPIO_FLASH_PIN_MASK;
-
-	default_css.preview_pipe.pipe.preview = preview;
-	default_css.capture_pipe.pipe.capture = capture;
-	default_css.video_pipe.pipe.video     = video;
-
-	if (malloc_func == NULL || free_func == NULL)
-		return sh_css_err_invalid_arguments;
-
-	memcpy(&my_css, &default_css, sizeof(my_css));
-
-	my_css.malloc = malloc_func;
-	my_css.free = free_func;
-	my_css.flush = flush_func;
-	/* Only after next line we can do dtrace */
-	sh_css_printf = env->print_env.debug_print;
-
-	sh_css_set_dtrace_level(SH_DBG_INFO);
-	sh_css_set_stop_timeout(CSS_TIMEOUT_US);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_init() enter: env=%p, fw_data=%p, fw_size=%d\n",
-		env, fw_data, fw_size);
-
-	ia_css_i_host_rmgr_init();
-
-	/* In case this has been programmed already, update internal
-	   data structure ... DEPRECATED */
-	my_css.page_table_base_index =
-		sh_css_mmu_get_page_table_base_index();
-
-	enable_interrupts();
-
-	/* configure GPIO to output mode */
-	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_select, select);
-	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_e, enable);
-	gpio_reg_store(GPIO0_ID, _gpio_block_reg_do_0, 0);
-
-	err = sh_css_refcount_init();
-	if (err != sh_css_success)
-		return err;
-	err = sh_css_params_init();
-	if (err != sh_css_success)
-		return err;
-	err = sh_css_sp_init();
-	if (err != sh_css_success)
-		return err;
-	err = sh_css_load_firmware(fw_data, fw_size);
-	if (err != sh_css_success)
-		return err;
-	sh_css_init_binary_infos();
-	my_css.sp_bin_addr = sh_css_sp_load_program(&sh_css_sp_fw,
-						    SP_PROG_NAME,
-						    my_css.sp_bin_addr);
-	if (!my_css.sp_bin_addr) {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",sh_css_err_cannot_allocate_memory);
-		return sh_css_err_cannot_allocate_memory;
-	}
-	sh_css_pipeline_init(&my_css.preview_pipe.pipeline,
-			     SH_CSS_PREVIEW_PIPELINE);
-	sh_css_pipeline_init(&my_css.video_pipe.pipeline,
-			     SH_CSS_VIDEO_PIPELINE);
-	sh_css_pipeline_init(&my_css.capture_pipe.pipeline,
-			     SH_CSS_CAPTURE_PIPELINE);
-
-#if defined(HRT_CSIM)
-	/**
-	 * In compiled simulator context include debug support by default.
-	 * In all other cases (e.g. Android phone), the user (e.g. driver)
-	 * must explicitly enable debug support by calling this function.
-	 */
-	if (!sh_css_debug_mode_init()) {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",sh_css_err_internal_error);
-		return sh_css_err_internal_error;
-	}
-#endif
-
-#if WITH_PC_MONITORING
-	if (!thread_alive) {
-		thread_alive++;
-		sh_css_print("PC_MONITORING: %s() -- create thread DISABLED\n",
-			     __func__);
-		spying_thread_create();
-	}
-	sh_css_printf = printk;
-#endif
-	if (!sh_css_hrt_system_is_idle()) {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",sh_css_err_system_not_idle);
-		return sh_css_err_system_not_idle;
-	}
-	/* can be called here, queuing works, but:
-	   - when sp is started later, it will wipe queued items
-	   so for now we leave it for later and make sure
-	   updates are not called to frequently.
-	sh_css_init_buffer_queues();
-	*/
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init() leave: return_err=%d\n",err);
-
-	return err;
-}
-
-/* Suspend does not need to do anything for now, this may change
-   in the future though. */
-void
-sh_css_suspend(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_suspend() enter & leave\n");
-}
-
-void
-sh_css_resume(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_resume() enter: void\n");
-	/* trigger reconfiguration of necessary hardware */
-	my_css.reconfigure_css_rx = true;
-	my_css.curr_if_a_config.cropped_width  = 0;
-	my_css.curr_if_a_config.cropped_height = 0;
-	my_css.curr_if_b_config.cropped_width  = 0;
-	my_css.curr_if_b_config.cropped_height = 0;
-	my_css.curr_fmt_type = -1;
-
-	sh_css_sp_set_sp_running(false);
-	/* reload the SP binary. ISP binaries are automatically
-	   reloaded by the ISP upon execution. */
-	mmu_set_page_table_base_index(MMU0_ID,
-			my_css.page_table_base_index);
-	sh_css_params_reconfigure_gdc_lut();
-
-	sh_css_sp_activate_program(&sh_css_sp_fw, my_css.sp_bin_addr,
-				   SP_PROG_NAME);
-
-	enable_interrupts();
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_resume() leave: return=void\n");
-}
-
-void *
-sh_css_malloc(size_t size)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_malloc() enter: size=%d\n", size);
-	if (size > 0 && my_css.malloc) {
-		void *p = my_css.malloc(size, false);
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_malloc() leave: "
-			"return=%p\n", p);
-		return p;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_malloc() leave: return=NULL\n");
-	return NULL;
-}
-
-void
-sh_css_free(void *ptr)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_free() enter: ptr=%p\n", ptr);
-	if (ptr && my_css.free)
-		my_css.free(ptr);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_free() leave: return=void\n");
-}
-
-/* For Acceleration API: Flush FW (shared buffer pointer) arguments */
-void
-sh_css_flush(struct sh_css_acc_fw *fw)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_flush() enter: fw=%p\n", fw);
-	if ((fw != NULL) && (my_css.flush != NULL))
-		my_css.flush(fw);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_flush() leave: return=void\n");
-}
-
-void
-sh_css_uninit(void)
-{
-	int i;
-	struct sh_css_pipe *preview_pipe = &my_css.preview_pipe;
-	struct sh_css_pipe *video_pipe   = &my_css.video_pipe;
-	struct sh_css_pipe *capture_pipe = &my_css.capture_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_uninit() enter: void\n");
-#if WITH_PC_MONITORING
-	sh_css_print("PC_MONITORING: %s() -- started\n", __func__);
-	print_pc_histogram();
-#endif
-
-	/* cleanup generic data */
-	sh_css_params_uninit();
-	sh_css_pipeline_stream_clear_pipelines();
-	sh_css_refcount_uninit();
-
-	ia_css_i_host_rmgr_uninit();
-
-	sh_css_binary_uninit();
-	sh_css_sp_uninit();
-	sh_css_unload_firmware();
-	if (my_css.sp_bin_addr) {
-		mmgr_free(my_css.sp_bin_addr);
-		my_css.sp_bin_addr = mmgr_NULL;
-	}
-
-	/* cleanup preview data */
-	sh_css_pipe_invalidate_binaries(preview_pipe);
-	sh_css_pipeline_clean(&preview_pipe->pipeline);
-	for (i = 0; i < NUM_CONTINUOUS_FRAMES; i++) {
-		if (preview_pipe->pipe.preview.continuous_frames[i]) {
-			sh_css_frame_free(
-				preview_pipe->pipe.preview.continuous_frames[i]);
-			preview_pipe->pipe.preview.continuous_frames[i] = NULL;
-		}
-	}
-
-	/* cleanup video data */
-	sh_css_pipe_invalidate_binaries(video_pipe);
-	sh_css_pipeline_clean(&video_pipe->pipeline);
-	for (i = 0; i < NUM_TNR_FRAMES; i++) {
-		if (video_pipe->pipe.video.tnr_frames[i])
-			sh_css_frame_free(video_pipe->pipe.video.tnr_frames[i]);
-		video_pipe->pipe.video.tnr_frames[i] = NULL;
-	}
-	for (i = 0; i < NUM_REF_FRAMES; i++) {
-		if (video_pipe->pipe.video.ref_frames[i])
-			sh_css_frame_free(video_pipe->pipe.video.ref_frames[i]);
-		video_pipe->pipe.video.ref_frames[i] = NULL;
-	}
-
-	/* cleanup capture data */
-	sh_css_pipe_invalidate_binaries(capture_pipe);
-	sh_css_pipeline_clean(&capture_pipe->pipeline);
-	if (capture_pipe->pipe.capture.capture_pp_frame) {
-		sh_css_frame_free(capture_pipe->pipe.capture.capture_pp_frame);
-		capture_pipe->pipe.capture.capture_pp_frame = NULL;
-	}
-#if 0
-	for (i = 0; i < NUM_CONTINUOUS_FRAMES; i++) {
-		if (capture_pipe->pipe.capture.continuous_frames[i]) {
-			sh_css_frame_free(
-				capture_pipe->pipe.capture.continuous_frames[i]);
-			capture_pipe->pipe.capture.continuous_frames[i] = NULL;
-		}
-	}
-#endif
-
-
-	sh_css_sp_set_sp_running(false);
-	sh_css_sp_reset_global_vars();
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_uninit() leave: return=void\n");
-}
-
-static bool sh_css_frame_ready(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_frame_ready() enter:\n");
-	if (my_css.curr_state == sh_css_state_executing_sp_bin_copy) {
-		my_css.capture_pipe.pipe.capture.output_frame->planes.binary.size =
-			sh_css_sp_get_binary_copy_size();
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_frame_ready() leave: return=true\n");
-		return true;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_frame_ready() leave: return=false\n");
-	return false;
-}
-
-static unsigned int translate_sw_interrupt(unsigned value)
-{
-	enum sh_css_pipe_id pipe_id = value >> 24;
-	unsigned stage_num;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sw_interrupt() enter:\n");
-	value &= ~(0xff<<24);
-	stage_num = value >> 16;
-	value &= ~(0xff<<16);
-	(void)pipe_id;
-	(void)stage_num;
-	return value;
-}
-
-static unsigned int translate_sw_interrupt1(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sw_interrupt1() enter:\n");
-	return translate_sw_interrupt(sh_css_get_sw_interrupt_value(1));
-}
-
-#if 0
-static unsigned int translate_sw_interrupt2(void)
-{
-	/* By smart coding the flag/bits in value (on the SP side),
-	 * no translation is required. The returned value can be
-	 * binary ORed with existing interrupt info
-	 * (it is compatible with enum sh_css_interrupt_info)
-	 */
-/* MW: No smart coding required, we should just keep interrupt info
-   and local context info separated */
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sw_interrupt2() enter:\n");
-	return translate_sw_interrupt(sh_css_get_sw_interrupt_value(2));
-}
-#endif
-
-/* Deprecated, this is an HRT backend function (memory_access.h) */
-void
-sh_css_mmu_set_page_table_base_index(hrt_data base_index)
-{
-	mmu_ID_t mmu_id;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_mmu_set_page_table_base_index() enter: base_index=0x%08x\n",base_index);
-	my_css.page_table_base_index = base_index;
-	for (mmu_id = (mmu_ID_t)0; mmu_id < (int)N_MMU_ID; mmu_id++) {
-		mmu_set_page_table_base_index(mmu_id, base_index);
-		mmu_invalidate_cache(mmu_id);
-	}
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_mmu_set_page_table_base_index() leave: return_void\n");
-}
-
-/* Deprecated, this is an HRT backend function (memory_access.h) */
-hrt_data
-sh_css_mmu_get_page_table_base_index(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_mmu_get_page_table_base_index() enter & leave\n");
-	return mmu_get_page_table_base_index(MMU0_ID);
-}
-
-void
-sh_css_mmu_invalidate_cache(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_mmu_invalidate_cache() enter & leave\n");
-	sh_css_sp_invalidate_mmu();
-}
-
-
-#if defined(HAS_IRQ_MAP_VERSION_1) || defined(HAS_IRQ_MAP_VERSION_1_DEMO)
-enum sh_css_err sh_css_translate_interrupt(
-	unsigned int *irq_infos)
-{
-	virq_id_t	irq;
-	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;
-	unsigned int infos = 0;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_translate_interrupt() enter: irq_infos=%d\n", *irq_infos);
-
-	while (status == hrt_isp_css_irq_status_more_irqs) {
-		status = virq_get_channel_id(&irq);
-		if (status == hrt_isp_css_irq_status_error)
-			return sh_css_err_interrupt_error;
-
-#if WITH_PC_MONITORING
-		sh_css_print("PC_MONITORING: %s() irq = %d, "
-			     "sh_binary_running set to 0\n", __func__, irq);
-		sh_binary_running = 0 ;
-#endif
-
-		switch (irq) {
-		case virq_sp:
-			if (sh_css_frame_ready()) {
-				infos |= SH_CSS_IRQ_INFO_BUFFER_DONE;
-				if (my_css.curr_pipe &&
-				    my_css.curr_pipe->invalid_first_frame) {
-					infos |=
-					  SH_CSS_IRQ_INFO_INVALID_FIRST_FRAME;
-					my_css.curr_pipe->invalid_first_frame = false;
-				}
-			}
-			break;
-		case virq_isp:
-#ifdef HRT_CSIM
-			/* Enable IRQ which signals that ISP goes to idle
-			 * to get statistics for each binary */
-			infos |= SH_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY;
-#endif
-			break;
-		case virq_isys:
-			/* css rx interrupt, read error bits from css rx */
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_ERROR;
-			break;
-		case virq_isys_fifo_full:
-			infos |=
-			    SH_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW;
-			break;
-		case virq_isys_sof:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_SOF;
-			break;
-		case virq_isys_eof:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_EOF;
-			break;
-/* Temporarily removed, until we have a seperate flag for FRAME_READY irq */
-#if 0
-/* hmm, an interrupt mask, why would we have that ? */
-		case virq_isys_sol:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_SOL;
-			break;
-#endif
-		case virq_isys_eol:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_EOL;
-			break;
-/*
- * MW: The 2300 demo system does not have a receiver, and it
- * does not have the following three IRQ channels defined
- */
-#if defined(HAS_IRQ_MAP_VERSION_1)
-		case virq_ifmt_sideband_changed:
-			infos |=
-			    SH_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED;
-			break;
-		case virq_gen_short_0:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0;
-			break;
-		case virq_gen_short_1:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1;
-			break;
-#endif
-		case virq_ifmt0_id:
-			infos |= SH_CSS_IRQ_INFO_IF_PRIM_ERROR;
-			break;
-		case virq_ifmt1_id:
-			infos |= SH_CSS_IRQ_INFO_IF_PRIM_B_ERROR;
-			break;
-		case virq_ifmt2_id:
-			infos |= SH_CSS_IRQ_INFO_IF_SEC_ERROR;
-			break;
-		case virq_ifmt3_id:
-			infos |= SH_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR;
-			break;
-		case virq_sw_pin_0:
-			infos |= SH_CSS_IRQ_INFO_SW_0;
-			break;
-		case virq_sw_pin_1:
-			infos |= translate_sw_interrupt1();
-
-			if (my_css.curr_state == sh_css_state_executing_sp_bin_copy) {
-				my_css.capture_pipe.pipe.capture.output_frame->planes.binary.size =
-					sh_css_sp_get_binary_copy_size();
-			}
-			if (my_css.curr_pipe &&
-					my_css.curr_pipe->invalid_first_frame) {
-				infos |=
-					 SH_CSS_IRQ_INFO_INVALID_FIRST_FRAME;
-				my_css.curr_pipe->invalid_first_frame = false;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (irq_infos)
-		*irq_infos = infos;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_translate_interrupt() "
-		"leave: irq_infos=0x%08x\n", infos);
-
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_enable_interrupt(
-	enum sh_css_interrupt_info info,
-	bool enable)
-{
-	virq_id_t	irq = N_virq_id;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_enable_interrupt() enter: info=%d, enable=%d\n",info,enable);
-
-	switch (info) {
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_ERROR:
-		irq = virq_isys;
-		break;
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW:
-		irq = virq_isys_fifo_full;
-		break;
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_SOF:
-		irq = virq_isys_sof;
-		break;
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_EOF:
-		irq = virq_isys_eof;
-		break;
-/* Temporarily removed, until we have a seperate flag for FRAME_READY irq */
-#if 0
-/* hmm, an interrupt mask, why would we have that ? */
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_SOL:
-		irq = virq_isys_sol;
-		break;
-#endif
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_EOL:
-		irq = virq_isys_eol;
-		break;
-#if defined(HAS_IRQ_MAP_VERSION_1)
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED:
-		irq = virq_ifmt_sideband_changed;
-		break;
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0:
-		irq = virq_gen_short_0;
-		break;
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1:
-		irq = virq_gen_short_1;
-		break;
-#endif
-	case SH_CSS_IRQ_INFO_IF_PRIM_ERROR:
-		irq = virq_ifmt0_id;
-		break;
-	case SH_CSS_IRQ_INFO_IF_PRIM_B_ERROR:
-		irq = virq_ifmt1_id;
-		break;
-	case SH_CSS_IRQ_INFO_IF_SEC_ERROR:
-		irq = virq_ifmt2_id;
-		break;
-	case SH_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR:
-		irq = virq_ifmt3_id;
-		break;
-	case SH_CSS_IRQ_INFO_SW_0:
-		irq = virq_sw_pin_0;
-		break;
-	case SH_CSS_IRQ_INFO_SW_1:
-		irq = virq_sw_pin_1;
-		break;
-	case SH_CSS_IRQ_INFO_SW_2:
-		irq = virq_sw_pin_2;
-		break;
-	default:
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_enable_interrupt() leave: return_err=%d\n",sh_css_err_invalid_arguments);
-		return sh_css_err_invalid_arguments;
-	}
-
-	virq_enable_channel(irq, enable);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_enable_interrupt() leave: return_err=%d\n",sh_css_success);
-	return sh_css_success;
-}
-
-#elif defined(HAS_IRQ_MAP_VERSION_2)
-
-enum sh_css_err sh_css_translate_interrupt(
-	unsigned int *irq_infos)
-{
-	virq_id_t	irq;
-	enum hrt_isp_css_irq_status status = hrt_isp_css_irq_status_more_irqs;
-	unsigned int infos = 0;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_translate_interrupt() enter: irq_infos=%d\n",irq_infos);
-
-	while (status == hrt_isp_css_irq_status_more_irqs) {
-		status = virq_get_channel_id(&irq);
-		if (status == hrt_isp_css_irq_status_error)
-			return sh_css_err_interrupt_error;
-
-#if WITH_PC_MONITORING
-		sh_css_print("PC_MONITORING: %s() irq = %d, "
-			     "sh_binary_running set to 0\n", __func__, irq);
-		sh_binary_running = 0 ;
-#endif
-
-		switch (irq) {
-		case virq_sp:
-			if (sh_css_frame_ready()) {
-				infos |= SH_CSS_IRQ_INFO_BUFFER_DONE;
-				if (my_css.curr_pipe &&
-				    my_css.curr_pipe->invalid_first_frame) {
-					infos |=
-					  SH_CSS_IRQ_INFO_INVALID_FIRST_FRAME;
-					my_css.curr_pipe->invalid_first_frame = false;
-				}
-			}
-			break;
-		case virq_isp:
-#ifdef HRT_CSIM
-			/* Enable IRQ which signals that ISP goes to idle
-			 * to get statistics for each binary */
-			infos |= SH_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY;
-#endif
-			break;
-		case virq_isys_sof:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_SOF;
-			break;
-		case virq_isys_eof:
-			infos |= SH_CSS_IRQ_INFO_CSS_RECEIVER_EOF;
-			break;
-		case virq_isys_csi:
-			infos |= SH_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR;
-			break;
-		case virq_ifmt0_id:
-			infos |= SH_CSS_IRQ_INFO_IF_ERROR;
-			break;
-		case virq_dma:
-			infos |= SH_CSS_IRQ_INFO_DMA_ERROR;
-			break;
-		case virq_sw_pin_0:
-			infos |= SH_CSS_IRQ_INFO_SW_0;
-			break;
-		case virq_sw_pin_1:
-			infos |= translate_sw_interrupt1();
-
-			if (my_css.curr_state == sh_css_state_executing_sp_bin_copy) {
-				my_css.capture_pipe.pipe.capture.output_frame->planes.binary.size =
-					sh_css_sp_get_binary_copy_size();
-			}
-			if (my_css.curr_pipe &&
-					my_css.curr_pipe->invalid_first_frame) {
-				infos |=
-					 SH_CSS_IRQ_INFO_INVALID_FIRST_FRAME;
-				my_css.curr_pipe->invalid_first_frame = false;
-			}
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (irq_infos)
-		*irq_infos = infos;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_translate_interrupt() "
-		"leave: irq_infos=0x%08x\n", infos);
-
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_enable_interrupt(
-	enum sh_css_interrupt_info info,
-	bool enable)
-{
-	virq_id_t	irq = N_virq_id;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_enable_interrupt() enter: info=%d, enable=%d\n",info,enable);
-
-	switch (info) {
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_SOF:
-		irq = virq_isys_sof;
-		break;
-	case SH_CSS_IRQ_INFO_CSS_RECEIVER_EOF:
-		irq = virq_isys_eof;
-		break;
-	case SH_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR:
-		irq = virq_isys_csi;
-		break;
-	case SH_CSS_IRQ_INFO_IF_ERROR:
-		irq = virq_ifmt0_id;
-		break;
-	case SH_CSS_IRQ_INFO_DMA_ERROR:
-		irq = virq_dma;
-		break;
-	case SH_CSS_IRQ_INFO_SW_0:
-		irq = virq_sw_pin_0;
-		break;
-	case SH_CSS_IRQ_INFO_SW_1:
-		irq = virq_sw_pin_1;
-		break;
-	default:
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_enable_interrupt() leave: return_err=%d\n",sh_css_err_invalid_arguments);
-		return sh_css_err_invalid_arguments;
-	}
-
-	virq_enable_channel(irq, enable);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_enable_interrupt() leave: return_err=%d\n",sh_css_success);
-	return sh_css_success;
-}
-
-#else
-#error "sh_css.c: IRQ MAP must be one of \
-	{IRQ_MAP_VERSION_1, IRQ_MAP_VERSION_1_DEMO, IRQ_MAP_VERSION_2}"
-#endif
-
-unsigned int sh_css_get_sw_interrupt_value(
-	unsigned int irq)
-{
-unsigned int	irq_value;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_sw_interrupt_value() enter: irq=%d\n",irq);
-	irq_value = sh_css_sp_get_sw_interrupt_value(irq);
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_sw_interrupt_value() leave: irq_value=%d\n",irq_value);
-return irq_value;
-}
-
-enum sh_css_err sh_css_wait_for_completion(
-	enum sh_css_pipe_id pipe_id)
-{
-	uint32_t sp_event;
-	uint32_t event;
-	enum sh_css_pipe_id pipe_id_event;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_wait_for_completion() enter: pipe_id=%d\n",pipe_id);
-
-	do {
-		bool rc;
-
-		rc = sp2host_dequeue_irq_event(&sp_event);
-
-		if (rc)
-			sh_css_sp_snd_event(SP_SW_EVENT_ID_3, 0, 0, 0);
-
-		if (rc) {
-			event = translate_sp_event(sp_event);
-			pipe_id_event = event >> 16;
-			event &= 0xFFFF;
-			if ((pipe_id_event ==  pipe_id) &&
-					(event == SH_CSS_EVENT_PIPELINE_DONE)) {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_wait_for_completion() leave: return_err=%d\n",sh_css_success);
-				return sh_css_success;
-			}
-		}
-		hrt_sleep();
-	} while (true);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_wait_for_completion() leave: return_err=%d\n",sh_css_err_internal_error);
-
-	return sh_css_err_internal_error;
-}
-
-void
-sh_css_uv_offset_is_zero(bool *uv_offset_is_zero)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_uv_offset_is_zero() enter:\n");
-	if (uv_offset_is_zero != NULL) {
-		*uv_offset_is_zero = SH_CSS_UV_OFFSET_IS_0;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_uv_offset_is_zero() leave: uv_offset_is_zero=%d\n",
-		*uv_offset_is_zero);
-	}
-}
-
-enum sh_css_err sh_css_pipe_set_input_resolution(struct sh_css_pipe *pipe,
-				 unsigned int width,
-				 unsigned int height)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_resolution() enter: width=%d, height=%d\n",width, height);
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	err = check_res(width, height);
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_resolution() leave: return_err=%d\n",err);
-		return err;
-	}
-	if (pipe->input_width != width || pipe->input_height != height)
-		sh_css_invalidate_morph_table();
-
-	pipe->input_width  = width;
-	pipe->input_height = height;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_resolution() leave: return_err=%d\n",sh_css_success);
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_pipe_set_effective_input_resolution(
-	struct sh_css_pipe *pipe,
-	unsigned int width,
-	unsigned int height)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_effective_input_resolution() enter: width=%d, height=%d\n",width, height);
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	err = check_res(width, height);
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_effective_input_resolution() leave: return_err=%d\n",err);
-		return err;
-	}
-	if (pipe->input_effective_info.width != width ||
-		pipe->input_effective_info.padded_width != width ||
-		pipe->input_effective_info.height != height) {
-		pipe->input_effective_info.width = width;
-		pipe->input_effective_info.padded_width = width;
-		pipe->input_effective_info.height = height;
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_effective_input_resolution() leave: return_err=%d\n",sh_css_success);
-
-	return sh_css_success;
-}
-
-void sh_css_pipe_set_input_format(
-	struct sh_css_pipe *me,
-	enum sh_css_input_format format)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_format() enter: format=%d\n",format);
-
-	assert(me != NULL);
-	if (me == NULL)
-		return;
-
-	me->input_format = format;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_format() leave: return_void\n");
-}
-
-enum sh_css_input_format sh_css_pipe_get_input_format(
-	struct sh_css_pipe *me)
-{
-	enum sh_css_input_format	format;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_get_input_format() enter: void\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return -1;
-
-	format = me->input_format;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_get_two_pixels_per_clock() leave: format=%d\n",format);
-return format;
-}
-
-void sh_css_input_set_binning_factor(
-	unsigned int binning_factor)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_binning_factor() enter: binning_factor=%d\n",binning_factor);
-	my_css.sensor_binning = binning_factor;
-	if (sh_css_params_set_binning_factor(binning_factor)) {
-		sh_css_pipe_free_shading_table(&my_css.preview_pipe);
-		sh_css_pipe_free_shading_table(&my_css.video_pipe);
-		sh_css_pipe_free_shading_table(&my_css.capture_pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_binning_factor() leave: return_void\n");
-}
-
-void sh_css_pipe_set_two_pixels_per_clock(
-	struct sh_css_pipe *me,
-	bool two_ppc)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_two_pixels_per_clock() enter: is_two_ppc=%d\n",two_ppc);
-
-	assert(me != NULL);
-	if (me == NULL)
-		return;
-
-	if (me->two_ppc != two_ppc) {
-		me->two_ppc = two_ppc;
-		my_css.reconfigure_css_rx = true;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_two_pixels_per_clock() leave: return_void\n");
-}
-
-bool
-sh_css_pipe_get_two_pixels_per_clock(struct sh_css_pipe *me)
-{
-bool	is_two_ppc;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_get_two_pixels_per_clock() enter: void\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return false;
-
-	is_two_ppc = me->two_ppc;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_get_two_pixels_per_clock() leave: is_two_ppc=%d\n",is_two_ppc);
-return is_two_ppc;
-}
-
-void
-sh_css_pipe_set_input_bayer_order(struct sh_css_pipe *pipe,
-				  enum sh_css_bayer_order bayer_order)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_bayer_order() enter: bayer_order=%d\n",bayer_order);
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	pipe->bayer_order = bayer_order;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_bayer_order() leave: return_void\n");
-}
-
-void sh_css_pipe_get_extra_pixels_count(
-	struct sh_css_pipe *pipe,
-	int *extra_rows,
-	int *extra_cols)
-{
-	int rows = SH_CSS_MAX_LEFT_CROPPING,
-	    cols = SH_CSS_MAX_LEFT_CROPPING;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_extra_pixels_count() enter: void\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(extra_rows != NULL);
-	if (extra_rows == NULL)
-		return;
-	assert(extra_cols != NULL);
-	if (extra_cols == NULL)
-		return;
-
-	if (lines_needed_for_bayer_order(pipe))
-		rows += 2;
-
-	if (columns_needed_for_bayer_order(pipe))
-		cols  += 2;
-
-	*extra_rows = rows;
-	*extra_cols = cols;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_extra_pixels_count() leave: extra_rows=%d, extra_cols=%d\n",
-		*extra_rows,*extra_cols);
-
-	return;
-}
-
-void sh_css_pipe_set_input_channel(
-	struct sh_css_pipe *pipe,
-	unsigned int channel_id)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_channel() enter: channel_id=%d\n",channel_id);
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	pipe->ch_id = channel_id;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_input_channel() leave: return_void\n");
-}
-
-void sh_css_pipe_set_input_mode(
-	struct sh_css_pipe *pipe,
-	enum sh_css_input_mode mode)
-{
-	enum sh_css_input_mode prev;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_mode() enter: mode=%d\n",mode);
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-
-	prev = pipe->input_mode;
-
-	if (prev != mode && pipe->mode == SH_CSS_VIDEO_PIPELINE) {
-		if (mode == SH_CSS_INPUT_MODE_MEMORY
-		    || prev == SH_CSS_INPUT_MODE_MEMORY) {
-			/* if we switch from online to offline, we need to
-			   reload the binary */
-			sh_css_pipe_invalidate_binaries(pipe);
-		}
-	}
-	pipe->input_mode = mode;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_mode() leave: return_void\n");
-}
-
-void sh_css_input_set_left_padding(
-	unsigned int padding)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_left_padding() enter: padding=%d\n",padding);
-
-	my_css.left_padding = 2*ISP_VEC_NELEMS-padding;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_left_padding() leave: return_void\n");
-}
-
-static void init_copy_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"init_copy_descr() enter:\n");
-
-	/* out_info can be NULL */
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-
-	*in_info = *out_info;
-
-	copy_descr.mode          = SH_CSS_BINARY_MODE_COPY;
-	copy_descr.online        = true;
-	copy_descr.stream_format = pipe->input_format;
-	copy_descr.binning       = false;
-	copy_descr.two_ppc       = pipe->two_ppc;
-	copy_descr.in_info       = in_info;
-	copy_descr.out_info      = out_info;
-	copy_descr.vf_info       = NULL;
-}
-
-static void init_offline_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_binary_descr *descr,
-	int mode,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info,
-	struct sh_css_frame_info *vf_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"init_offline_descr() enter:\n");
-
-	/* in_info, out_info, vf_info can be NULL */
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(descr != NULL);
-	if (descr == NULL)
-		return;
-
-	descr->mode          = mode;
-	descr->online        = false;
-	descr->stream_format = pipe->input_format;
-	descr->binning       = false;
-	descr->two_ppc       = false;
-	descr->in_info       = in_info;
-	descr->out_info      = out_info;
-	descr->vf_info       = vf_info;
-}
-
-static void
-init_vf_pp_descr(struct sh_css_pipe *pipe,
-		 struct sh_css_frame_info *in_info,
-		 struct sh_css_frame_info *out_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"init_vf_pp_descr() enter:\n");
-
-	/* out_info can be NULL ??? */
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-
-	in_info->raw_bit_depth = 0;
-	init_offline_descr(pipe,
-			   &vf_pp_descr, SH_CSS_BINARY_MODE_VF_PP,
-			   in_info, out_info, NULL);
-}
-
-static void init_preview_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info)
-{
-	int mode = SH_CSS_BINARY_MODE_PREVIEW;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"init_preview_descr() enter:\n");
-
-	/* out_info can be NULL ??? */
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-
-	*in_info = pipe->input_effective_info;
-	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
-	if (input_format_is_yuv(pipe->input_format))
-		mode = SH_CSS_BINARY_MODE_COPY;
-	else
-		in_info->format = SH_CSS_FRAME_FORMAT_RAW;
-
-	init_offline_descr(pipe,
-			   &preview_descr, mode,
-			   in_info, out_info, NULL);
-	if (pipe->online) {
-		preview_descr.online	    = pipe->online;
-		preview_descr.two_ppc       = pipe->two_ppc;
-	}
-	preview_descr.stream_format = pipe->input_format;
-	preview_descr.binning	    = pipe->input_needs_raw_binning;
-}
-
-/* configure and load the copy binary, the next binary is used to
-   determine whether the copy binary needs to do left padding. */
-static enum sh_css_err load_copy_binary(
-	struct sh_css_pipe *pipe,
-	struct sh_css_binary *copy_binary,
-	struct sh_css_binary *next_binary)
-{
-	struct sh_css_frame_info copy_out_info, copy_in_info;
-	unsigned int left_padding;
-	enum sh_css_err err;
-	int mode = SH_CSS_BINARY_MODE_COPY;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"load_copy_binary() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(copy_binary != NULL);
-	if (copy_binary == NULL)
-		return sh_css_err_internal_error;
-
-
-	if (next_binary != NULL) {
-		copy_out_info = next_binary->in_frame_info;
-		left_padding = next_binary->left_padding;
-	} else {
-		copy_out_info = pipe->output_info;
-		left_padding = 0;
-	}
-
-	init_copy_descr(pipe, &copy_in_info, &copy_out_info);
-	copy_descr.mode = mode;
-	err = sh_css_binary_find(&copy_descr, copy_binary, false);
-	if (err != sh_css_success)
-		return err;
-	copy_binary->left_padding = left_padding;
-	return sh_css_success;
-}
-#if 0
-static enum sh_css_err
-primary_alloc_continuous_frames(
-	struct sh_css_pipe *pipe,
-	unsigned int stride);
-#endif
-
-
-static enum sh_css_err load_preview_binaries(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_frame_info prev_in_info,
-				 prev_out_info;
-	enum sh_css_err err = sh_css_success;
-	bool online;
-	bool continuous = my_css.continuous;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"load_preview_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	online = pipe->online;
-
-	if (pipe->pipe.preview.preview_binary.info &&
-	    pipe->pipe.preview.vf_pp_binary.info)
-		return sh_css_success;
-
-	err = check_input(pipe, false);
-	if (err != sh_css_success)
-		return err;
-	err = check_frame_info(&pipe->output_info);
-	if (err != sh_css_success)
-		return err;
-
-	/* Preview */
-	if (pipe->yuv_ds_input_info.width)
-		prev_out_info = pipe->yuv_ds_input_info;
-	else
-		prev_out_info = pipe->output_info;
-	sh_css_frame_info_set_format(&prev_out_info,
-				     SH_CSS_FRAME_FORMAT_YUV_LINE);
-	init_preview_descr(pipe, &prev_in_info, &prev_out_info);
-	err = sh_css_binary_find(&preview_descr,
-				 &pipe->pipe.preview.preview_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-
-	/* Viewfinder post-processing */
-	init_vf_pp_descr(pipe,
-			&pipe->pipe.preview.preview_binary.out_frame_info,
-			&pipe->output_info);
-	err = sh_css_binary_find(&vf_pp_descr,
-				 &pipe->pipe.preview.vf_pp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-
-	/* Copy */
-	if (!online && !continuous) {
-		err = load_copy_binary(pipe,
-				       &pipe->pipe.preview.copy_binary,
-				       &pipe->pipe.preview.preview_binary);
-		if (err != sh_css_success)
-			return err;
-	}
-
-	err = sh_css_allocate_continuous_frames(true);
-	if (err != sh_css_success)
-		return err;
-#if 0
-	if (my_css.continuous) {
-		err = primary_alloc_continuous_frames(capture_pipe,
-		    pipe->pipe.preview.continuous_frames[0]->info.padded_width);
-		if (err != sh_css_success)
-			return err;
-	}
-#endif
-
-#if SH_CSS_PREVENT_UNINIT_READS /* Klocwork pacifier: CWARN.CONSTCOND.IF */
-	sh_css_frame_zero(pipe->pipe.preview.continuous_frames[0]);
-#endif
-
-	if (pipe->shading_table) {
-		sh_css_shading_table_free(pipe->shading_table);
-		pipe->shading_table = NULL;
-	}
-	return sh_css_success;
-}
-
-static const struct sh_css_fw_info *last_output_firmware(
-	const struct sh_css_fw_info *fw)
-{
-	const struct sh_css_fw_info *last_fw = NULL;
-/* fw can be NULL */
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"last_output_firmware() enter:\n");
-
-	for (; fw; fw = fw->next) {
-		const struct sh_css_fw_info *info = fw;
-		if (info->info.isp.enable.output)
-			last_fw = fw;
-	}
-	return last_fw;
-}
-
-static enum sh_css_err add_firmwares(
-	struct sh_css_pipeline *me,
-	struct sh_css_binary *binary,
-	const struct sh_css_fw_info *fw,
-	const struct sh_css_fw_info *last_fw,
-	unsigned int binary_mode,
-	struct sh_css_frame *in_frame,
-	struct sh_css_frame *out_frame,
-	struct sh_css_frame *vf_frame,
-	struct sh_css_pipeline_stage **my_stage,
-	struct sh_css_pipeline_stage **vf_stage)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_pipeline_stage *extra_stage = NULL;
-
-/* all args can be NULL ??? */
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"add_firmwares() enter:\n");
-
-	for (; fw; fw = fw->next) {
-		struct sh_css_frame *out = NULL;
-		struct sh_css_frame *in = NULL;
-		struct sh_css_frame *vf = NULL;
-		if ((fw == last_fw) && (fw->info.isp.enable.out_frame  != 0)) {
-			out = out_frame;
-		}
-		if (fw->info.isp.enable.in_frame != 0) {
-			in = in_frame;
-		}
-		if (fw->info.isp.enable.out_frame != 0) {
-			vf = vf_frame;
-		}
-
-		err = sh_css_pipeline_add_stage(me, binary, fw,
-				binary_mode, NULL,
-				in, out,
-				vf, &extra_stage);
-		if (err != sh_css_success)
-			return err;
-		if (fw->info.isp.enable.output != 0)
-			in_frame = extra_stage->args.out_frame;
-		if (my_stage && !*my_stage && extra_stage)
-			*my_stage = extra_stage;
-		if (vf_stage && !*vf_stage && extra_stage &&
-		    fw->info.isp.enable.vf_veceven)
-			*vf_stage = extra_stage;
-	}
-	return err;
-}
-
-static enum sh_css_err add_vf_pp_stage(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame *out_frame,
-	struct sh_css_binary *vf_pp_binary,
-	struct sh_css_pipeline_stage *post_stage,
-	struct sh_css_pipeline_stage **vf_pp_stage)
-{
-	struct sh_css_pipeline *me;
-	const struct sh_css_fw_info *last_fw;
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_frame *in_frame;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"add_vf_pp_stage() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(vf_pp_binary != NULL);
-	if (vf_pp_binary == NULL)
-		return sh_css_err_internal_error;
-
-	assert(post_stage != NULL);
-	if (post_stage == NULL)
-		return sh_css_err_internal_error;
-
-	assert(vf_pp_stage != NULL);
-	if (vf_pp_stage == NULL)
-		return sh_css_err_internal_error;
-
-	me = &pipe->pipeline;
-	in_frame = post_stage->args.out_vf_frame;
-	*vf_pp_stage = NULL;
-
-	if (in_frame == NULL)
-		in_frame = post_stage->args.out_frame;
-
-	last_fw = last_output_firmware(pipe->vf_stage);
-	if (!pipe->disable_vf_pp) {
-		err = sh_css_pipeline_add_stage(me, vf_pp_binary, NULL,
-				vf_pp_binary->info->mode, NULL,
-				in_frame,
-				last_fw ? NULL : out_frame,
-				NULL, vf_pp_stage);
-		if (err != sh_css_success)
-			return err;
-		in_frame = (*vf_pp_stage)->args.out_frame;
-	}
-	err = add_firmwares(me, vf_pp_binary, pipe->vf_stage, last_fw,
-			    SH_CSS_BINARY_MODE_VF_PP,
-			    in_frame, out_frame, NULL,
-			    vf_pp_stage, NULL);
-	return err;
-}
-
-static enum sh_css_err add_capture_pp_stage(
-	struct sh_css_pipe *pipe,
-	struct sh_css_pipeline *me,
-	struct sh_css_frame *out_frame,
-	struct sh_css_binary *capture_pp_binary,
-	struct sh_css_pipeline_stage *capture_stage,
-	struct sh_css_pipeline_stage **pre_vf_pp_stage)
-{
-	const struct sh_css_fw_info *last_fw;
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_frame *in_frame = NULL;
-	struct sh_css_frame *vf_frame = NULL;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"add_capture_pp_stage() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(me != NULL);
-	if (me == NULL)
-		return sh_css_err_internal_error;
-
-	assert(capture_pp_binary != NULL);
-	if (capture_pp_binary == NULL)
-		return sh_css_err_internal_error;
-
-	assert(capture_stage != NULL);
-	if (capture_stage == NULL)
-		return sh_css_err_internal_error;
-
-	in_frame = capture_stage->args.out_frame;
-
-	assert(pre_vf_pp_stage != NULL);
-	if (pre_vf_pp_stage == NULL)
-		return sh_css_err_internal_error;
-
-	*pre_vf_pp_stage = NULL;
-
-	if (in_frame == NULL)
-		in_frame = capture_stage->args.out_frame;
-
-	last_fw = last_output_firmware(pipe->output_stage);
-	if (!pipe->disable_capture_pp &&
-	    need_capture_pp(pipe)) {
-		err = sh_css_frame_allocate_from_info(&vf_frame,
-					    &capture_pp_binary->vf_frame_info);
-		if (err != sh_css_success)
-			return err;
-		err = sh_css_pipeline_add_stage(me, capture_pp_binary, NULL,
-				capture_pp_binary->info->mode, NULL,
-				NULL,
-				last_fw ? NULL : out_frame,
-				vf_frame, pre_vf_pp_stage);
-		if (err != sh_css_success)
-			return err;
-		in_frame = (*pre_vf_pp_stage)->args.out_frame;
-	}
-	err = add_firmwares(me, capture_pp_binary, pipe->output_stage, last_fw,
-			    SH_CSS_BINARY_MODE_CAPTURE_PP,
-			    in_frame, out_frame, vf_frame,
-			    NULL, pre_vf_pp_stage);
-	/* If a firmware produce vf_pp output, we set that as vf_pp input */
-	if (*pre_vf_pp_stage) {
-		(*pre_vf_pp_stage)->args.extra_frame =
-		  pipe->pipe.capture.capture_pp_frame;
-		(*pre_vf_pp_stage)->args.vf_downscale_log2 =
-		  capture_pp_binary->vf_downscale_log2;
-	} else {
-		*pre_vf_pp_stage = capture_stage;
-	}
-	return err;
-}
-
-static void
-number_stages(
-	struct sh_css_pipe *pipe)
-{
-	unsigned i = 0;
-	struct sh_css_pipeline_stage *stage;
-	for (stage = pipe->pipeline.stages; stage; stage = stage->next) {
-		stage->stage_num = i;
-		i++;
-	}
-	pipe->pipeline.num_stages = i;
-}
-
-void
-sh_css_init_buffer_queues(void)
-{
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_host_sp_queues_initialized;
-	unsigned int i;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init_buffer_queues() enter:\n");
-
-	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++)
-		hmm_buffer_record_h[i] = NULL;
-
-
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_queues_initialized =
-		fw->info.sp.host_sp_queues_initialized;
-
-	/* initialize the "sp2host" queues */
-	init_sp2host_queues();
-
-	/* initialize the "host2sp" queues */
-	init_host2sp_queues();
-
-	/* set "host_sp_queues_initialized" to "true" */
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(host_sp_queues_initialized),
-		(uint32_t)(1));
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_init_buffer_queues() leave:\n");
-}
-
-static enum sh_css_err preview_start(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_pipeline *me = &pipe->pipeline;
-	struct sh_css_pipeline_stage *preview_stage;
-	struct sh_css_pipeline_stage *vf_pp_stage;
-	struct sh_css_frame *in_frame = NULL, *cc_frame = NULL;
-	struct sh_css_binary *copy_binary, *preview_binary, *vf_pp_binary;
-	enum sh_css_err err = sh_css_success;
-
-	/**
-	 * rvanimme: raw_out_frame support is broken and forced to NULL
-	 * TODO: add a way to tell the pipeline construction that a
-	 * raw_out_frame is used.
-	 */
-	struct sh_css_frame *raw_out_frame = NULL;
-	struct sh_css_frame *out_frame = &me->out_frame;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"preview_start() enter: void\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	sh_css_pipeline_clean(me);
-
-	my_css.curr_pipe = pipe;
-
-	sh_css_preview_get_output_frame_info(&out_frame->info);
-	out_frame->contiguous = false;
-	out_frame->flash_state = SH_CSS_FRAME_NO_FLASH;
-	out_frame->dynamic_data_index = sh_css_frame_out;
-	err = init_frame_planes(out_frame);
-	if (err != sh_css_success)
-		return err;
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err != sh_css_success)
-		return err;
-
-	copy_binary    = &pipe->pipe.preview.copy_binary;
-	preview_binary = &pipe->pipe.preview.preview_binary;
-	vf_pp_binary   = &pipe->pipe.preview.vf_pp_binary;
-
-	sh_css_metrics_start_frame();
-
-	if (me->reload) {
-		struct sh_css_pipeline_stage *post_stage;
-		if (pipe->pipe.preview.copy_binary.info) {
-			err = sh_css_pipeline_add_stage(me, copy_binary, NULL,
-					copy_binary->info->mode,
-					NULL, NULL, raw_out_frame, NULL,
-					&post_stage);
-			if (err != sh_css_success)
-				return err;
-			in_frame = me->stages->args.out_frame;
-		} else {
-			in_frame = pipe->pipe.preview.continuous_frames[0];
-		}
-		err = sh_css_pipeline_add_stage(me, preview_binary, NULL,
-						preview_binary->info->mode,
-						cc_frame, in_frame, NULL, NULL,
-						&post_stage);
-		if (err != sh_css_success)
-			return err;
-		/* If we use copy iso preview, the input must be yuv iso raw */
-		post_stage->args.copy_vf =
-			preview_binary->info->mode == SH_CSS_BINARY_MODE_COPY;
-		post_stage->args.copy_output = !post_stage->args.copy_vf;
-		if (post_stage->args.copy_vf) {
-			/* in case of copy, use the vf frame as output frame */
-			post_stage->args.out_vf_frame =
-				post_stage->args.out_frame;
-		}
-
-		err = add_vf_pp_stage(pipe, out_frame, vf_pp_binary,
-				      post_stage, &vf_pp_stage);
-		if (err != sh_css_success)
-			return err;
-		number_stages(pipe);
-	} else {
-		sh_css_pipeline_restart(me);
-	}
-
-	sh_css_pipeline_stream_clear_pipelines();
-	sh_css_pipeline_stream_add_pipeline(&pipe->pipeline);
-
-	err = sh_css_pipeline_get_output_stage(me, SH_CSS_BINARY_MODE_VF_PP,
-					       &vf_pp_stage);
-
-	if (err != sh_css_success)
-		return err;
-	err = sh_css_pipeline_get_stage(me, preview_binary->info->mode,
-					&preview_stage);
-	if (err != sh_css_success)
-		return err;
-
-	vf_pp_stage->args.out_frame = out_frame;
-
-	if (my_css.continuous) {
-		in_frame = pipe->pipe.preview.continuous_frames[0];
-		cc_frame = pipe->pipe.preview.continuous_frames[1];
-		preview_stage->args.cc_frame = cc_frame;
-		preview_stage->args.in_frame = in_frame;
-	}
-	/* update the arguments with the latest info */
-
-	sh_css_set_irq_buffer(preview_stage, sh_css_frame_in,  raw_out_frame);
-	sh_css_set_irq_buffer(vf_pp_stage,   sh_css_frame_out, out_frame);
-
-#if 1
-	/* Construct and load the capture pipe */
-	if (my_css.continuous) {
-		bool low_light;
-#if 1
-		struct sh_css_pipe *capture_pipe = &my_css.capture_pipe;
-		err = construct_capture_pipe(capture_pipe);
-		if (err != sh_css_success)
-			return err;
-
-		low_light = (capture_pipe->capture_mode ==
-				SH_CSS_CAPTURE_MODE_LOW_LIGHT) ||
-				(capture_pipe->capture_mode ==
-				SH_CSS_CAPTURE_MODE_BAYER);
-
-		sh_css_sp_init_pipeline(&capture_pipe->pipeline, SH_CSS_CAPTURE_PIPELINE,
-			false, low_light, capture_pipe->xnr,
-			capture_pipe->two_ppc, false,
-			false, capture_pipe->input_needs_raw_binning,
-			SH_CSS_PIPE_CONFIG_OVRD_THRD_1_2);
-
-
-		sh_css_pipeline_stream_add_pipeline(&capture_pipe->pipeline);
-#endif
-	}
-#endif
-
-	err = sh_css_config_input_network(pipe, copy_binary);
-	if (err != sh_css_success)
-		return err;
-
-	start_pipe(pipe, SH_CSS_PIPE_CONFIG_OVRD_THRD_1_2);
-	me->reload = false;
-
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_pipe_stop(
-	struct sh_css_pipe *me)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_stop() enter: me=%p\n",
-		me);
-
-	assert(me != NULL);
-	if (me == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipeline_stop(me->mode);
-
-	/* more settings should be reset here, maybe use the DEFAULT_PIPE */
-	//pipe->input_needs_raw_binning = false;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_stop() leave: return_err=%d\n",err);
-	return err;
-}
-
-enum sh_css_err sh_css_queue_buffer(
-	enum sh_css_pipe_id pipe_id,
-	enum sh_css_buffer_type buf_type,
-	void *buffer)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_pipe *pipe;
-	unsigned int thread_id, i;
-	enum sh_css_buffer_queue_id queue_id;
-	struct sh_css_pipeline *pipeline;
-	struct sh_css_pipeline_stage *stage;
-	struct ia_css_i_host_rmgr_vbuf_handle p_vbuf;
-	struct ia_css_i_host_rmgr_vbuf_handle *h_vbuf;
-	struct sh_css_hmm_buffer ddr_buffer;
-	bool rc = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_queue_buffer() enter: pipe_id=%d, buf_type=%d, buffer=%p\n",
-		pipe_id, buf_type, buffer);
-
-	switch (pipe_id) {
-	case SH_CSS_PREVIEW_PIPELINE:
-		pipe = &my_css.preview_pipe;
-		break;
-	case SH_CSS_VIDEO_PIPELINE:
-		pipe = &my_css.video_pipe;
-		break;
-	case SH_CSS_CAPTURE_PIPELINE:
-		pipe = &my_css.capture_pipe;
-		break;
-	case SH_CSS_ACC_PIPELINE:
-		pipe = &my_css.acc_pipe;
-		break;
-	case SH_CSS_COPY_PIPELINE:
-		pipe = NULL;
-		break;
-	default:
-		return sh_css_err_internal_error;
-	}
-	/* For convenience we allow NULL pointer arguments*/
-	if (buffer == NULL)
-		return sh_css_success;
-
-	assert(pipe_id < SH_CSS_NR_OF_PIPELINES);
-	assert(buf_type < SH_CSS_BUFFER_TYPE_NR_OF_TYPES);
-
-	/**
-	 * the sh_css_frame_done function needs to have acces to the
-	 * latest (completed) output frame to store the sp_binary_copy_size
-	 * TODO: this size is global but should be per output frame
-	 */
-	if (my_css.curr_state == sh_css_state_executing_sp_bin_copy &&
-			buf_type == SH_CSS_BUFFER_TYPE_OUTPUT_FRAME)
-		my_css.capture_pipe.pipe.capture.output_frame = buffer;
-
-	sh_css_query_sp_thread_id(pipe_id, &thread_id);
-	sh_css_query_internal_queue_id(buf_type, &queue_id);
-	if (pipe)
-		pipeline = &pipe->pipeline;
-	else
-		pipeline = NULL;
-
-	assert(pipeline != NULL ||
-	       pipe_id == SH_CSS_COPY_PIPELINE ||
-	       pipe_id == SH_CSS_ACC_PIPELINE);
-
-
-
-	ddr_buffer.kernel_ptr = (hrt_vaddress)HOST_ADDRESS(buffer);
-	if (buf_type == SH_CSS_BUFFER_TYPE_3A_STATISTICS) {
-		ddr_buffer.payload.s3a = *(union sh_css_s3a_data *)buffer;
-	} else if (buf_type == SH_CSS_BUFFER_TYPE_DIS_STATISTICS) {
-		ddr_buffer.payload.dis = *(struct sh_css_dis_data *)buffer;
-	} else if ((buf_type == SH_CSS_BUFFER_TYPE_INPUT_FRAME)
-		|| (buf_type == SH_CSS_BUFFER_TYPE_OUTPUT_FRAME)
-		|| (buf_type == SH_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)) {
-		ddr_buffer.payload.frame.frame_data =
-					((struct sh_css_frame *)buffer)->data;
-		ddr_buffer.payload.frame.flashed = 0;
-	}
-/* start of test for using rmgr for acq/rel memory */
-	p_vbuf.vptr = 0;
-	p_vbuf.count = 0;
-	p_vbuf.size = sizeof(struct sh_css_hmm_buffer);
-	h_vbuf = &p_vbuf;
-	// TODO: change next to correct pool for optimization
-	ia_css_i_host_rmgr_acq_vbuf(hmm_buffer_pool, &h_vbuf);
-
-	assert(h_vbuf != NULL);
-	if (h_vbuf == NULL)
-		return sh_css_err_internal_error;
-
-	assert(h_vbuf->vptr != 0x0);
-	if (h_vbuf->vptr == 0x0)
-		return sh_css_err_internal_error;
-
-	mmgr_store(h_vbuf->vptr,
-				(void *)(&ddr_buffer),
-				sizeof(struct sh_css_hmm_buffer));
-	if ((buf_type == SH_CSS_BUFFER_TYPE_3A_STATISTICS)
-		|| (buf_type == SH_CSS_BUFFER_TYPE_DIS_STATISTICS)) {
-		/* update isp params to ddr */
-		//sh_css_commit_isp_config(pipeline, false);
-		assert(pipeline != NULL);
-		/* Klockwork pacifier */
-		if (pipeline == NULL)
-			return sh_css_err_internal_error;
-		for (stage = pipeline->stages; stage; stage = stage->next) {
-			/* Update params before the enqueue of
-				empty 3a and dis */
-			/* The SP will read the params
-				after it got empty 3a and dis */
-			if (STATS_ENABLED(stage)) {
-				rc = host2sp_enqueue_buffer(thread_id, 0,
-						queue_id,
-						(uint32_t)h_vbuf->vptr);
-			}
-		}
-	} else if ((buf_type == SH_CSS_BUFFER_TYPE_INPUT_FRAME)
-		|| (buf_type == SH_CSS_BUFFER_TYPE_OUTPUT_FRAME)
-		|| (buf_type == SH_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME)) {
-			rc = host2sp_enqueue_buffer(thread_id,
-				0,
-				queue_id,
-				(uint32_t)h_vbuf->vptr);
-	}
-
-	err = (rc == true) ?
-		sh_css_success : sh_css_err_buffer_queue_is_full;
-
-	if (err == sh_css_success) {
-		for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
-			if (hmm_buffer_record_h[i] == NULL) {
-				hmm_buffer_record_h[i] = h_vbuf;
-				break;
-			}
-		}
-	} else {
-		ia_css_i_host_rmgr_rel_vbuf(hmm_buffer_pool, &h_vbuf);
-	}
-
-		/*
-		 * Tell the SP which queues are not empty,
-		 * by sending the software event.
-		 */
-	if (err == sh_css_success)
-		sh_css_sp_snd_event(SP_SW_EVENT_ID_1,
-				thread_id,
-				queue_id,
-				0);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_queue_buffer() leave: return_err=%d\n",err);
-	return err;
-}
-
-/*
- * TODO: Free up the hmm memory space.
-	 */
-enum sh_css_err
-sh_css_dequeue_buffer(enum sh_css_pipe_id   pipe,
-			enum sh_css_buffer_type buf_type,
-			void **buffer)
-{
-	enum sh_css_err err;
-	enum sh_css_buffer_queue_id queue_id;
-	hrt_vaddress ddr_buffer_addr;
-	struct sh_css_hmm_buffer ddr_buffer;
-	bool rc;
-	unsigned int i, found_record;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_dequeue_buffer() enter: pipe=%d, buf_type=%d\n",
-		pipe, buf_type);
-
-	assert(buffer != NULL);
-	if (buffer == NULL)
-		return sh_css_err_internal_error;
-
-	ddr_buffer.kernel_ptr = 0;
-
-	sh_css_query_internal_queue_id(buf_type, &queue_id);
-
-	rc = sp2host_dequeue_buffer(0,
-				0,
-				queue_id,
-				&ddr_buffer_addr);
-	if (rc) {
-		mmgr_load(ddr_buffer_addr,
-				&ddr_buffer,
-				sizeof(struct sh_css_hmm_buffer));
-		found_record = 0;
-		for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
-			if (hmm_buffer_record_h[i] != NULL && hmm_buffer_record_h[i]->vptr == ddr_buffer_addr) {
-				ia_css_i_host_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
-				hmm_buffer_record_h[i] = NULL;
-				found_record = 1;
-				break;
-			}
-		}
-		assert(found_record == 1);
-		assert(ddr_buffer.kernel_ptr != 0);
-
-		/* Klockwork pacifier */
-		if (ddr_buffer.kernel_ptr == 0)
-			return sh_css_err_internal_error;
-
-		switch (buf_type) {
-		case SH_CSS_BUFFER_TYPE_OUTPUT_FRAME:
-			*buffer =
-				(struct sh_css_frame *)HOST_ADDRESS(ddr_buffer.kernel_ptr);
-			if (ddr_buffer.payload.frame.exp_id)
-				((struct sh_css_frame *)(*buffer))->exp_id
-					= ddr_buffer.payload.frame.exp_id;
-			if (ddr_buffer.payload.frame.flashed == 0)
-				((struct sh_css_frame *)(*buffer))->flash_state
-					 = SH_CSS_FRAME_NO_FLASH;
-			if (ddr_buffer.payload.frame.flashed == 1)
-				((struct sh_css_frame *)(*buffer))->flash_state
-					= SH_CSS_FRAME_PARTIAL_FLASH;
-			if (ddr_buffer.payload.frame.flashed == 2)
-				((struct sh_css_frame *)(*buffer))->flash_state
-					= SH_CSS_FRAME_FULLY_FLASH;
-			break;
-		case SH_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME:
-			*buffer =
-				(struct sh_css_frame *)HOST_ADDRESS(ddr_buffer.kernel_ptr);
-			if (ddr_buffer.payload.frame.exp_id)
-				((struct sh_css_frame *)(*buffer))->exp_id
-					= ddr_buffer.payload.frame.exp_id;
-			if (ddr_buffer.payload.frame.flashed == 0)
-				((struct sh_css_frame *)(*buffer))->flash_state
-					 = SH_CSS_FRAME_NO_FLASH;
-			if (ddr_buffer.payload.frame.flashed == 1)
-				((struct sh_css_frame *)(*buffer))->flash_state
-					= SH_CSS_FRAME_PARTIAL_FLASH;
-			if (ddr_buffer.payload.frame.flashed == 2)
-				((struct sh_css_frame *)(*buffer))->flash_state
-					= SH_CSS_FRAME_FULLY_FLASH;
-			break;
-		case SH_CSS_BUFFER_TYPE_3A_STATISTICS:
-			*buffer =
-				(union sh_css_s3a_data *)HOST_ADDRESS(ddr_buffer.kernel_ptr);
-			break;
-		case SH_CSS_BUFFER_TYPE_DIS_STATISTICS:
-			*buffer =
-				(struct sh_css_dis_data *)HOST_ADDRESS(ddr_buffer.kernel_ptr);
-			break;
-		default:
-			rc = false;
-			break;
-		}
-	}
-
-	err = rc ? sh_css_success : sh_css_err_buffer_queue_is_empty;
-
-	/*
-	 * Tell the SP which queues are not full,
-	 * by sending the software event.
-	 */
-	if (err == sh_css_success)
-		sh_css_sp_snd_event(SP_SW_EVENT_ID_2,
-				0,
-				queue_id,
-				0);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_dequeue_buffer() leave: buffer=%p\n",
-		buffer ? *buffer : (void *)-1);
-
-	return err;
-}
-
-static uint32_t translate_sp_event(
-	uint32_t	sp_event)
-{
-	unsigned int bit_width = 0, i;
-	enum sh_css_sp_event_type sp_event_id;
-	uint32_t event;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "translate_sp_event() enter:\n");
-
-	i = SH_CSS_SP_EVENT_NR_OF_TYPES - 1;
-	bit_width = 0;
-	while (i != 0) {
-		bit_width++;
-		i = i >> 1;
-	}
-	sp_event_id = sp_event & ((1ull << bit_width) - 1);
-	switch (sp_event_id) {
-	case SH_CSS_SP_EVENT_OUTPUT_FRAME_DONE:
-		event = (sp_event & 0xFFFF0000) |
-					SH_CSS_EVENT_OUTPUT_FRAME_DONE;
-		break;
-	case SH_CSS_SP_EVENT_VF_OUTPUT_FRAME_DONE:
-		event = (sp_event & 0xFFFF0000) |
-					SH_CSS_EVENT_VF_OUTPUT_FRAME_DONE;
-		break;
-	case SH_CSS_SP_EVENT_3A_STATISTICS_DONE:
-		event = (sp_event & 0xFFFF0000) |
-					SH_CSS_EVENT_3A_STATISTICS_DONE;
-		break;
-	case SH_CSS_SP_EVENT_DIS_STATISTICS_DONE:
-		event = (sp_event & 0xFFFF0000) |
-					SH_CSS_EVENT_DIS_STATISTICS_DONE;
-		break;
-	case SH_CSS_SP_EVENT_PIPELINE_DONE:
-		event = (sp_event & 0xFFFF0000) |
-					SH_CSS_EVENT_PIPELINE_DONE;
-		break;
-	default:
-		event = (sp_event & 0xFFFF0000) |
-					SH_CSS_EVENT_NULL;
-		break;
-	}
-
-	return event;
-}
-
-static void decode_sp_event(
-	uint32_t event,
-	enum sh_css_pipe_id *pipe_id,
-	enum sh_css_event_type *event_id)
-{
-	unsigned int bit_width = 0, i;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "decode_sp_event() enter:\n");
-
-	assert(pipe_id != NULL);
-	if (pipe_id == NULL)
-		return;
-
-	assert(event_id != NULL);
-	if (event_id == NULL)
-		return;
-
-	i = SH_CSS_NR_OF_PIPELINES - 1;
-	while (i != 0) {
-		bit_width++;
-		i = i >> 1;
-	}
-	*pipe_id = (event >> 16) & ((1ull << bit_width) - 1);
-
-	i = SH_CSS_NR_OF_EVENTS - 1;
-	bit_width = 0;
-	while (i != 0) {
-		bit_width++;
-		i = i >> 1;
-	}
-	*event_id = event & ((1ull << bit_width) - 1);
-}
-
-
-enum sh_css_err
-sh_css_dequeue_event(enum sh_css_pipe_id *pipe_id,
-			enum sh_css_event_type *event_id)
-{
-	bool is_event_available;
-	uint32_t sp_event;
-	uint32_t host_event;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_dequeue_event() enter:\n");
-
-	assert(pipe_id != NULL);
-	if (pipe_id == NULL)
-		return sh_css_err_internal_error;
-
-	assert(event_id != NULL);
-	if (event_id == NULL)
-		return sh_css_err_internal_error;
-
-	/* dequeue the IRQ event */
-	is_event_available =
-		sp2host_dequeue_irq_event(&sp_event);
-
-	/* check whether the IRQ event is available or not */
-	if (!is_event_available) {
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_dequeue_event() out: EVENT_QUEUE_EMPTY\n");
-		return sh_css_err_event_queue_is_empty;
-	} else {
-		/*
-		 * Tell the SP which queues are not full,
-		 * by sending the software event.
-		 */
-		sh_css_sp_snd_event(SP_SW_EVENT_ID_3,
-				0,
-				0,
-				0);
-	}
-
-	host_event = translate_sp_event(sp_event);
-
-	decode_sp_event(host_event, pipe_id, event_id);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_dequeue_event() leave: pipe_id=%d, event_id=%d\n",
-				*pipe_id, *event_id);
-
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_start(
-	enum sh_css_pipe_id pipe_id)
-{
-	enum sh_css_err err;
-	unsigned long timeout = CSS_TIMEOUT_US;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_start() enter: pipe_id=%d\n", pipe_id);
-#ifdef __KERNEL__
-	printk("sh_css_start() enter: pipe_id=%d\n", pipe_id);
-#endif
-
-	switch (pipe_id) {
-	case SH_CSS_PREVIEW_PIPELINE:
-		err = preview_start(&my_css.preview_pipe);
-		break;
-	case SH_CSS_VIDEO_PIPELINE:
-		err = video_start(&my_css.video_pipe);
-		break;
-	case SH_CSS_CAPTURE_PIPELINE:
-		err = capture_start(&my_css.capture_pipe);
-		break;
-	default:
-		err = sh_css_err_invalid_arguments;
-	}
-
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_start() leave: return_err=%d\n", err);
-		return err;
-	}
-
-	/* waiting for the SP is completely started */
-	while (!sh_css_sp_has_booted() && timeout) {
-		timeout--;
-		hrt_sleep();
-	}
-	if (timeout == 0) {
-		sh_css_dump_debug_info("sh_css_start point1");
-		sh_css_dump_sp_sw_debug_info();
-#ifdef __KERNEL__
-		printk(KERN_ERR "%s poll timeout point 1!!!\n", __func__);
-#endif
-	}
-
-	sh_css_init_host_sp_control_vars();
-
-	sh_css_event_init_irq_mask();
-
-	sh_css_init_buffer_queues();
-
-	/* Force ISP parameter calculation after a mode change */
-	sh_css_invalidate_params();
-	/* now only preview pipe supports raw binning. if more pipes support it later, we need to change this */
-	sh_css_params_set_raw_binning(my_css.preview_pipe.input_needs_raw_binning);
-
-	sh_css_param_update_isp_params(true);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_start() leave: return_err=%d\n", err);
-	return err;
-}
-
-
-static enum sh_css_err sh_css_pipeline_stop(
-	enum sh_css_pipe_id pipe)
-{
-	unsigned int i;
-	unsigned long timeout = sh_css_stop_timeout_us;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipeline_stop()\n");
-	(void)pipe;
-	/* For now, stop whole SP */
-	sh_css_write_host2sp_command(host2sp_cmd_terminate);
-
-	/*
-	 * Workaround against ISPFW bug. ISPFW sometimes misses the command
-	 * from IA. This WA can be removed if the ISPFW is corrected to
-	 * avoid race condition.
-	 *
-	 * WA: When the command is cleared immediately it is quite probable
-	 * that the FW just forgets the command without any real action.
-	 * To overcome this case resend the command if the previous one is
-	 * handled faster than expected.
-	 * There is a small probability that the cmd_terminate is handled twice.
-	 * This doesn't cause any side effects on FW side.
-	 */
-	if (sh_css_read_host2sp_command() == host2sp_cmd_ready)
-		sh_css_write_host2sp_command(host2sp_cmd_terminate);
-
-	sh_css_sp_set_sp_running(false);
-	sh_css_sp_uninit_pipeline(pipe);
-#ifdef __KERNEL__
-	printk("STOP_FUNC: reach point 1\n");
-#endif
-	while (!sh_css_sp_has_terminated() && timeout) {
-		timeout--;
-		hrt_sleep();
-	}
-	if (timeout == 0) {
-#ifdef __KERNEL__
-		printk(KERN_ERR "%s poll timeout point 1!!!\n", __func__);
-#endif
-	}
-#ifdef __KERNEL__
-	printk("STOP_FUNC: reach point 2\n");
-#endif
-	while (timeout && !isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT)) {
-		timeout--;
-		hrt_sleep();
-	}
-	if (timeout == 0) {
-#ifdef __KERNEL__
-		printk(KERN_ERR "%s poll timeout point 2!!!\n", __func__);
-#endif
-	}
-#ifdef __KERNEL__
-	printk("STOP_FUNC: reach point 3\n");
-#endif
-
-	for (i = 0; i < MAX_HMM_BUFFER_NUM; i++) {
-		if (hmm_buffer_record_h[i] != NULL) {
-			ia_css_i_host_rmgr_rel_vbuf(hmm_buffer_pool, &hmm_buffer_record_h[i]);
-		}
-	}
-
-	/* clear pending param sets from refcount */
-	sh_css_param_clear_param_sets();
-	sh_css_sp_reset_global_vars();
-
-	my_css.curr_state = sh_css_state_idle;
-
-	my_css.curr_pipe = NULL;
-	my_css.start_sp_copy = false;
-
-	if (timeout == 0)
-		return sh_css_err_internal_error;
-
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_preview_configure_pp_input(
-	unsigned int width, unsigned int height)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_pipe *pipe = &my_css.preview_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_configure_pp_input() enter: width=%d, height=%d\n", width, height);
-	err = check_null_res(width, height);
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_preview_configure_pp_input() leave: return_err=%d\n",
-		err);
-		return err;
-	}
-	if (pipe->yuv_ds_input_info.width != width ||
-	    pipe->yuv_ds_input_info.height != height) {
-		sh_css_frame_info_init(&pipe->yuv_ds_input_info,
-				       width, height, 0,
-				       SH_CSS_FRAME_FORMAT_YUV_LINE);
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_preview_configure_pp_input() leave: return_err=%d\n",
-		sh_css_success);
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_preview_get_input_resolution(
-	unsigned int *width,
-	unsigned int *height)
-{
-	enum sh_css_err err;
-	struct sh_css_pipe *pipe = &my_css.preview_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_get_input_resolution() enter: void\n");
-
-	assert(width != NULL);
-	if (width == NULL)
-		return sh_css_err_internal_error;
-
-	assert(height != NULL);
-	if (height == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success) {
-		const struct sh_css_binary *binary;
-		if (pipe->pipe.preview.copy_binary.info)
-			binary = &pipe->pipe.preview.copy_binary;
-		else
-			binary = &pipe->pipe.preview.preview_binary;
-		*width  = binary->in_frame_info.width +
-			  columns_needed_for_bayer_order(pipe);
-		*height = binary->in_frame_info.height +
-			  lines_needed_for_bayer_order(pipe);
-
-	/* TODO: Remove this when the decimated resolution is available */
-	/* Only for continuous preview mode where we need 2xOut resolution */
-		if (pipe->input_needs_raw_binning &&
-		    pipe->pipe.preview.preview_binary.info->enable.raw_binning) {
-			*width *= 2;
-			*width -= binary->info->left_cropping;
-			*height *= 2;
-			*height -= binary->info->left_cropping;
-		}
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_get_input_resolution() leave:"
-		" width=%d, height=%d\n", *width, *height);
-	return err;
-}
-
-void
-sh_css_video_enable_yuv_ds(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_enable_yuv_ds() enter: enable=%d\n", enable);
-	my_css.video_pipe.enable_yuv_ds = enable;
-}
-
-void
-sh_css_video_enable_high_speed(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_enable_high_speed() enter: enable=%d\n", enable);
-	my_css.video_pipe.enable_high_speed = enable;
-}
-
-void
-sh_css_video_enable_dvs_6axis(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_enable_dvs_6axis() enter: enable=%d\n", enable);
-	my_css.video_pipe.enable_dvs_6axis = enable;
-}
-
-void
-sh_css_video_enable_reduced_pipe(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_enable_reduced_pipe() enter: enable=%d\n", enable);
-	my_css.video_pipe.enable_reduced_pipe = enable;
-}
-
-void
-sh_css_video_enable_viewfinder(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_enable_viewfinder() enter: enable=%d\n", enable);
-	my_css.video_pipe.enable_viewfinder = enable;
-}
-
-void
-sh_css_enable_continuous(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_enable_continuous() enter: enable=%d\n", enable);
-	my_css.continuous = enable;
-}
-
-void
-sh_css_enable_cont_capt(bool enable, bool stop_copy_preview)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_enable_cont_capt() enter: enable=%d\n", enable);
-	my_css.cont_capt = enable;
-	my_css.stop_copy_preview = stop_copy_preview;
-}
-
-void
-sh_css_pipe_enable_raw_binning(struct sh_css_pipe *pipe,
-				 bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_enable_raw_binning() enter: pipe=%p, enable=%d\n",
-		pipe, enable);
-	pipe->input_needs_raw_binning = enable;
-}
-
-bool
-sh_css_continuous_is_enabled(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_continuous_is_enabled() enter: void\n");
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_continuous_is_enabled() leave: enable=%d\n",
-		my_css.continuous);
-	return my_css.continuous;
-}
-
-int
-sh_css_continuous_get_max_raw_frames(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_continuous_get_max_raw_frames() enter: void\n");
-	return NUM_CONTINUOUS_FRAMES;
-}
-
-enum sh_css_err
-sh_css_continuous_set_num_raw_frames(int num_frames)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_continuous_set_num_raw_frames() enter: num_frames=%d\n",num_frames);
-	if (num_frames > NUM_CONTINUOUS_FRAMES || num_frames < 1)
-		return sh_css_err_invalid_arguments;
-	/* ok, value allowed */
-	my_css.num_cont_raw_frames = num_frames;
-	// TODO: check what to regarding initialization
-	return sh_css_success;
-}
-
-int
-sh_css_continuous_get_num_raw_frames(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_continuous_get_num_raw_frames() enter: void\n");
-	return my_css.num_cont_raw_frames;
-}
-
-bool
-sh_css_continuous_start_sp_copy(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_continuous_start_sp_copy() enter: void\n");
-	return my_css.start_sp_copy;
-}
-
-void
-sh_css_pipe_disable_vf_pp(struct sh_css_pipe *pipe,
-			  bool disable)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_pipe_disable_vf_pp() enter: disable=%d\n",disable);
-	pipe->disable_vf_pp = disable;
-}
-
-void
-sh_css_disable_capture_pp(bool disable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_disable_capture_pp() enter: disable=%d\n",disable);
-	my_css.capture_pipe.disable_capture_pp = disable;
-}
-
-enum sh_css_err sh_css_pipe_configure_output(
-	struct sh_css_pipe *pipe, unsigned int width, unsigned int height,
-	unsigned int min_padded_width, enum sh_css_frame_format format)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipe_configure_output() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	err = check_res(width, height);
-	if (err != sh_css_success)
-		return err;
-	if (pipe->output_info.width != width ||
-	    pipe->output_info.height != height ||
-	    pipe->output_info.padded_width != min_padded_width ||
-	    pipe->output_info.format != format) {
-		sh_css_frame_info_init(&pipe->output_info, width, height,
-				       min_padded_width, format);
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-	return sh_css_success;
-}
-
-static enum sh_css_err sh_css_pipe_get_grid_info(
-	struct sh_css_pipe *pipe,
-	struct sh_css_grid_info *info)
-{
-	enum sh_css_err err;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipe_get_grid_info() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success) {
-		struct sh_css_binary *s3a_binary = NULL;
-#if 0
-		/* TODO: this requires the pipeline to be created and filled
-		 * in the pipe_load_binaries function. We should do this since
-		 * it simplifies a lot of things.
-		 */
-		struct sh_css_pipeline_stage *stage;
-		printf("stages: %p\n", pipe->pipeline.stages);
-		for (stage = pipe->pipeline.stages; stage; stage = stage->next) {
-			if (STATS_ENABLED(stage)) {
-				s3a_binary = stage->binary;
-				printf("found stats stage: %d\n", s3a_binary->info->mode);
-				break;
-			}
-			printf("no stats stage: %d\n", stage->binary->info->mode);
-		}
-#else
-	switch (pipe->mode) {
-	case SH_CSS_PREVIEW_PIPELINE:
-		s3a_binary = &pipe->pipe.preview.preview_binary;
-		break;
-	case SH_CSS_VIDEO_PIPELINE:
-		s3a_binary = &pipe->pipe.video.video_binary;
-		break;
-	case SH_CSS_CAPTURE_PIPELINE:
-		if (pipe->capture_mode == SH_CSS_CAPTURE_MODE_PRIMARY)
-			s3a_binary = &pipe->pipe.capture.primary_binary;
-		else if (pipe->capture_mode == SH_CSS_CAPTURE_MODE_ADVANCED ||
-			 pipe->capture_mode == SH_CSS_CAPTURE_MODE_LOW_LIGHT ||
-			 pipe->capture_mode == SH_CSS_CAPTURE_MODE_BAYER)
-			s3a_binary = &pipe->pipe.capture.pre_isp_binary;
-		break;
-	default:
-		break;
-	}
-#endif
-		if (s3a_binary)
-			err = sh_css_binary_grid_info(s3a_binary, info);
-		else
-			err = sh_css_err_mode_does_not_have_grid;
-	}
-	return err;
-}
-
-static void init_video_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *vf_info)
-{
-	int mode = SH_CSS_BINARY_MODE_VIDEO;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_video_descr() enter:\n");
-
-	/* vf_info can be NULL */
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-
-	if (input_format_is_yuv(pipe->input_format))
-		mode = SH_CSS_BINARY_MODE_COPY;
-	*in_info = pipe->input_effective_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_RAW;
-	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
-	init_offline_descr(pipe,
-			   &video_descr,
-			   mode,
-			   in_info,
-			   &pipe->output_info,
-			   vf_info);
-	if (pipe->online) {
-		video_descr.online = pipe->online;
-		video_descr.two_ppc = pipe->two_ppc;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_video_descr() leave:\n");
-}
-
-
-/*
- * @GC: TEMPORARY CODE TO TEST DVS AGAINST THE REFERENCE
- * PLEASE DO NOT REMOVE IT!
- */
-#if DVS_REF_TESTING
-static enum sh_css_err alloc_frame_from_file(
-	struct sh_css_pipe *pipe,
-	int width,
-	int height)
-{
-	FILE *fp;
-	int len = 0, err;
-	int bytes_per_pixel;
-	const char *file = "../File_input/dvs_input2.yuv";
-	char *y_buf, *u_buf, *v_buf;
-	char *uv_buf;
-	int offset = 0;
-	int h, w;
-	hrt_vaddress out_base_addr = pipe->pipe.video.ref_frames[0]->data;
-	hrt_vaddress out_y_addr  = out_base_addr
-		+ pipe->pipe.video.ref_frames[0]->planes.yuv.y.offset;
-	hrt_vaddress out_uv_addr = out_base_addr
-		+ pipe->pipe.video.ref_frames[0]->planes.yuv.u.offset;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "alloc_frame_from_file() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	bytes_per_pixel = sizeof(char);
-
-	if (!file) {printf("Error: Input file for dvs is not specified\n"); return 1;}
-	fp = fopen(file, "rb");
-	if (!fp) {printf("Error: Input file for dvs is not found\n"); return 1;}
-
-	err = fseek(fp, 0, SEEK_END);
-	if (err) {
-		fclose(fp);
-	  	printf("Error: Fseek error\n");
-	  	return 1;
-	}
-	len = ftell(fp);
-
-	err = fseek(fp, 0, SEEK_SET);
-	if (err) {
-		fclose(fp);
-		printf("Error: Fseek error2\n");
-		return 1;
-	}
-
-	len = 2 * len / 3;
-	if (len != width * height * bytes_per_pixel) {
-		fclose(fp);
-		printf("Error: File size mismatches with the internal resolution\n");
-		return 1;
-	}
-
-	y_buf = (char *) malloc(len);
-	u_buf = (char *) malloc(len/4);
-	v_buf = (char *) malloc(len/4);
-	uv_buf= (char *) malloc(len/2);
-
-	fread(y_buf, 1, len, fp);
-	fread(u_buf, 1, len/4, fp);
-	fread(v_buf, 1, len/4, fp);
-
-	for (h=0; h<height/2; h++) {
-		for (w=0; w<width/2; w++) {
-			*(uv_buf + offset + w) = *(u_buf++);
-			*(uv_buf + offset + w + width/2) = *(v_buf++);
-			//printf("width: %d\n", width);
-			//printf("offset_u: %d\n", offset+w);
-			//printf("offset_v: %d\n", offset+w+width/2);
-		}
-		offset += width;
-	}
-
-	mmgr_store(out_y_addr, y_buf, len);
-	mmgr_store(out_uv_addr, uv_buf, len/2);
-
-	out_base_addr = pipe->pipe.video.ref_frames[1]->data;
-	out_y_addr  = out_base_addr + pipe->pipe.video.ref_frames[1]->planes.yuv.y.offset;
-	out_uv_addr = out_base_addr + pipe->pipe.video.ref_frames[1]->planes.yuv.u.offset;
-	mmgr_store(out_y_addr, y_buf, len);
-	mmgr_store(out_uv_addr, uv_buf, len/2);
-
-	fclose(fp);
-
-	return sh_css_success;
-}
-
-/* MW: Why do we not pass the pointer to the struct ? */
-static enum sh_css_err fill_ref_frame_for_dvs(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info ref_info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "fill_ref_frame_for_dvs() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	/* Allocate tmp_frame which is used to store YUV420 input.
-	 * Read YUV420 input from the file to tmp_frame.
-	 * Convert from YUV420 to NV12 format */
-	err = alloc_frame_from_file(pipe, ref_info.width, ref_info.height);
-
-	return err;
-}
-#endif
-
-#define SH_CSS_TNR_BIT_DEPTH 8
-#define SH_CSS_REF_BIT_DEPTH 8
-
-static enum sh_css_err load_video_binaries(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_frame_info video_in_info, ref_info, tnr_info,
-				 *video_vf_info;
-	bool online;
-	enum sh_css_err err = sh_css_success;
-	int i;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_video_binaries() enter: "
-		"pipe=%p\n", pipe);
-	/* we only test the video_binary because offline video doesn't need a
-	 * vf_pp binary and online does not (always use) the copy_binary.
-	 * All are always reset at the same time anyway.
-	 */
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->pipe.video.video_binary.info) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"load_video_binaries() leave: "
-			"return=sh_css_success (binary already loaded)\n");
-		return sh_css_success;
-	}
-
-	online = pipe->online;
-	err = check_input(pipe, !online);
-	if (err != sh_css_success)
-		return err;
-	/* cannot have online video and input_mode memory */
-	if (online && pipe->input_mode == SH_CSS_INPUT_MODE_MEMORY)
-		return sh_css_err_unsupported_configuration;
-	if (my_css.video_pipe.enable_viewfinder) {
-		err = check_vf_out_info(&pipe->output_info,
-					&pipe->vf_output_info);
-		if (err != sh_css_success)
-			return err;
-	} else {
-		err = check_frame_info(&pipe->output_info);
-		if (err != sh_css_success)
-			return err;
-	}
-
-	/* Video */
-	if (my_css.video_pipe.enable_viewfinder)
-		video_vf_info = &pipe->vf_output_info;
-	else
-		video_vf_info = NULL;
-	init_video_descr(pipe, &video_in_info, video_vf_info);
-	if (pipe->enable_yuv_ds)
-		video_descr.enable_yuv_ds = true;
-	if (pipe->enable_high_speed)
-		video_descr.enable_high_speed = true;
-	if (pipe->enable_dvs_6axis)
-		video_descr.enable_dvs_6axis = true;
-	if (pipe->enable_reduced_pipe)
-		video_descr.enable_reduced_pipe = true;
-	video_descr.isp_pipe_version = pipe->isp_pipe_version;
-	err = sh_css_binary_find(&video_descr,
-				 &pipe->pipe.video.video_binary,
-				 true);
-	if (err != sh_css_success)
-		return err;
-
-	/* Copy */
-	if (!online) {
-		/* TODO: what exactly needs doing, prepend the copy binary to
-		 *	 video base this only on !online?
-		 */
-		err = load_copy_binary(pipe,
-				       &pipe->pipe.video.copy_binary,
-				       &pipe->pipe.video.video_binary);
-		if (err != sh_css_success)
-			return err;
-	}
-
-	/* This is where we set the flag for invalid first frame */
-	pipe->invalid_first_frame = true;
-
-	/* Viewfinder post-processing */
-	if (my_css.video_pipe.enable_viewfinder) {
-		init_vf_pp_descr(pipe,
-			&pipe->pipe.video.video_binary.vf_frame_info,
-			&pipe->vf_output_info);
-		err = sh_css_binary_find(&vf_pp_descr,
-				&pipe->pipe.video.vf_pp_binary,
-				false);
-		if (err != sh_css_success)
-			return err;
-	}
-
-	if (input_format_is_yuv(pipe->input_format))
-		/* @GC: In case of YUV Zoom, we use reference frame
-		 * to buffer the copy output! Since the sensor input
-		 * is being copied, we need a buffer as big as
-		 * input resolution */
-		ref_info = pipe->pipe.video.video_binary.in_frame_info;
-	else
-		ref_info = pipe->pipe.video.video_binary.internal_frame_info;
-
-	ref_info.format = SH_CSS_FRAME_FORMAT_YUV420;
-	ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
-
-	for (i = 0; i < NUM_REF_FRAMES; i++) {
-		if (pipe->pipe.video.ref_frames[i])
-			sh_css_frame_free(pipe->pipe.video.ref_frames[i]);
-		err = sh_css_frame_allocate_from_info(
-				&pipe->pipe.video.ref_frames[i],
-				&ref_info);
-		if (err != sh_css_success)
-			return err;
-	}
-
-#if SH_CSS_PREVENT_UNINIT_READS /* Klocwork pacifier: CWARN.CONSTCOND.IF */
-	sh_css_frame_zero(pipe->pipe.video.ref_frames[0]);
-	sh_css_frame_zero(pipe->pipe.video.ref_frames[1]);
-#endif
-
-#if DVS_REF_TESTING
-	/* @GC: TEMPORARY CODE TO TEST DVS AGAINST THE REFERENCE
-	 * To test dvs-6axis:
-	 * 1. Enable this function call
-	 * 2. Set "reqs.ref_out_requests" to "0" in lineloop.hive.c
-	 */
-	err = fill_ref_frame_for_dvs(pipe, ref_info);
-	if (err != sh_css_success)
-		return err;
-#endif
-
-	/* YUV copy does not need tnr frames */
-	if (input_format_is_yuv(pipe->input_format)) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_video_binaries() "
-			"leave: return=sh_css_success (L%d)\n", __LINE__);
-		return sh_css_success;
-	}
-
-	tnr_info = pipe->pipe.video.video_binary.internal_frame_info;
-	tnr_info.format = SH_CSS_FRAME_FORMAT_YUV_LINE;
-	tnr_info.raw_bit_depth = SH_CSS_TNR_BIT_DEPTH;
-
-	for (i = 0; i < NUM_TNR_FRAMES; i++) {
-		if (pipe->pipe.video.tnr_frames[i])
-			sh_css_frame_free(pipe->pipe.video.tnr_frames[i]);
-		err = sh_css_frame_allocate_from_info(
-				&pipe->pipe.video.tnr_frames[i],
-				&tnr_info);
-		if (err != sh_css_success)
-			return err;
-	}
-
-#if SH_CSS_PREVENT_UNINIT_READS /* Klocwork pacifier: CWARN.CONSTCOND.IF */
-	sh_css_frame_zero(pipe->pipe.video.tnr_frames[0]);
-	sh_css_frame_zero(pipe->pipe.video.tnr_frames[1]);
-#endif
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_video_binaries() "
-		"leave: return=sh_css_success (L%d)\n", __LINE__);
-	return sh_css_success;
-}
-
-static enum sh_css_err video_start(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_pipeline *me = &pipe->pipeline;
-	struct sh_css_pipeline_stage *copy_stage  = NULL;
-	struct sh_css_pipeline_stage *video_stage = NULL;
-	struct sh_css_pipeline_stage *vf_pp_stage = NULL;
-	struct sh_css_pipeline_stage *in_stage    = NULL;
-	struct sh_css_binary *copy_binary, *video_binary, *vf_pp_binary;
-	enum sh_css_err err = sh_css_success;
-
-	struct sh_css_frame out_frame_struct = { .data = 0 };
-	struct sh_css_frame vf_frame_struct = { .data = 0 };
-
-	/**
-	 * rvanimme: in_frame support is broken and forced to NULL
-	 * TODO: add a way to tell the pipeline construction that an in_frame
-	 * is used.
-	 */
-	struct sh_css_frame *in_frame = NULL;
-	struct sh_css_frame *out_frame = &out_frame_struct;
-	struct sh_css_frame *vf_frame = &vf_frame_struct;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "video_start() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	my_css.curr_pipe = pipe;
-
-	sh_css_video_get_output_frame_info(&out_frame->info);
-	out_frame->contiguous = false;
-	out_frame->flash_state = SH_CSS_FRAME_NO_FLASH;
-	out_frame->dynamic_data_index = sh_css_frame_out;
-	err = init_frame_planes(out_frame);
-	if (err != sh_css_success)
-		return err;
-
-	if (!my_css.video_pipe.enable_viewfinder || in_frame) {
-		/* These situations don't support viewfinder output */
-		vf_frame = NULL;
-	} else {
-		sh_css_video_get_viewfinder_frame_info(&vf_frame->info);
-		vf_frame->contiguous = false;
-		vf_frame->flash_state = SH_CSS_FRAME_NO_FLASH;
-		vf_frame->dynamic_data_index = sh_css_frame_out_vf;
-		err = init_frame_planes(vf_frame);
-		if (err != sh_css_success)
-			return err;
-	}
-
-	copy_stage = NULL;
-	in_stage = NULL;
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err != sh_css_success)
-		return err;
-
-	copy_binary  = &pipe->pipe.video.copy_binary;
-	video_binary = &pipe->pipe.video.video_binary;
-	vf_pp_binary = &pipe->pipe.video.vf_pp_binary;
-
-	sh_css_metrics_start_frame();
-
-	sh_css_pipeline_clean(me);
-	if (pipe->pipe.video.copy_binary.info) {
-		err = sh_css_pipeline_add_stage(me, copy_binary,
-			/* TODO: check next params */
-			/* const struct sh_css_acc_fw *firmware, */
-			NULL,
-			/* unsigned int mode, */
-			copy_binary->info->mode, /* unsigned int mode,*/
-			/* struct sh_css_frame *cc_frame, */
-			NULL,
-			/* struct sh_css_frame *in_frame, */
-			NULL,
-			/* struct sh_css_frame *out_frame, */
-			NULL,
-			/* struct sh_css_frame *vf_frame, */
-			NULL,
-			/* struct sh_css_pipeline_stage **stage) */
-			&copy_stage);
-		if (err != sh_css_success)
-			return err;
-		in_frame = me->stages->args.out_frame;
-		in_stage = copy_stage;
-	}
-	err = sh_css_pipeline_add_stage(me, video_binary, NULL,
-					video_binary->info->mode, NULL,
-					in_frame, out_frame, NULL,
-					&video_stage);
-	if (err != sh_css_success)
-		return err;
-	/* If we use copy iso video, the input must be yuv iso raw */
-	video_stage->args.copy_vf =
-		video_binary->info->mode == SH_CSS_BINARY_MODE_COPY;
-	video_stage->args.copy_output = video_stage->args.copy_vf;
-	if (!in_frame && my_css.video_pipe.enable_viewfinder) {
-		err = add_vf_pp_stage(pipe, vf_frame, vf_pp_binary,
-				      video_stage, &vf_pp_stage);
-		if (err != sh_css_success)
-			return err;
-	}
-	number_stages(pipe);
-
-	err = sh_css_config_input_network(pipe, copy_binary);
-	if (err != sh_css_success)
-		return err;
-
-	sh_css_pipeline_stream_clear_pipelines();
-	sh_css_pipeline_stream_add_pipeline(&pipe->pipeline);
-
-	video_stage->args.in_ref_frame = pipe->pipe.video.ref_frames[0];
-	video_stage->args.out_ref_frame = pipe->pipe.video.ref_frames[1];
-	video_stage->args.in_tnr_frame = pipe->pipe.video.tnr_frames[0];
-	video_stage->args.out_tnr_frame = pipe->pipe.video.tnr_frames[1];
-
-	/* update the arguments with the latest info */
-	video_stage->args.out_frame = out_frame;
-
-	if (vf_pp_stage)
-		vf_pp_stage->args.out_frame = vf_frame;
-
-	start_pipe(pipe, SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD);
-
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_video_get_output_raw_frame_info(
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err;
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_output_raw_frame_info() enter:\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->online) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_viewfinder_frame_info() leave: "
-		"return_err=%d\n",
-			sh_css_err_mode_does_not_have_raw_output);
-		return sh_css_err_mode_does_not_have_raw_output;
-	}
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success) {
-		*info = pipe->pipe.video.copy_binary.out_frame_info;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_output_raw_frame_info() leave: "
-		"info.width=%d, info.height=%d, info.padded_width=%d, "
-		"info.format=%d, info.raw_bit_depth=%d, "
-		"info.raw_bayer_order=%d\n",
-		info->width,info->height,
-		info->padded_width,info->format,
-		info->raw_bit_depth,info->raw_bayer_order);
-	} else {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_viewfinder_frame_info() leave: "
-		"return_err=%d\n",
-			err);
-	}
-		/* info->height += -4; */
-		/* info->width += 12; */
-	return err;
-}
-
-enum sh_css_err sh_css_video_get_viewfinder_frame_info(
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err;
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_viewfinder_frame_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_viewfinder_frame_info() leave: "
-		"return_err=%d\n",
-			err);
-		return err;
-	}
-	/* offline video does not generate viewfinder output */
-	if (!pipe->online) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_viewfinder_frame_info() leave: "
-		"return_err=%d\n",
-			sh_css_err_mode_does_not_have_viewfinder);
-		return sh_css_err_mode_does_not_have_viewfinder;
-	} else {
-		*info = pipe->vf_output_info;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_viewfinder_frame_info() leave: "
-		"info.width=%d, info.height=%d, info.padded_width=%d, "
-		"info.format=%d, info.raw_bit_depth=%d, "
-		"info.raw_bayer_order=%d\n",
-		info->width,info->height,
-		info->padded_width,info->format,
-		info->raw_bit_depth,info->raw_bayer_order);
-
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_video_get_input_resolution(
-	unsigned int *width,
-	unsigned int *height)
-{
-	enum sh_css_err err;
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_input_resolution() enter: void\n");
-
-	assert(width != NULL);
-	if (width == NULL)
-		return sh_css_err_internal_error;
-
-	assert(height != NULL);
-	if (height == NULL)
-		return sh_css_err_internal_error;
-
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success) {
-		const struct sh_css_binary *binary;
-		if (pipe->pipe.video.copy_binary.info)
-			binary = &pipe->pipe.video.copy_binary;
-		else
-			binary = &pipe->pipe.video.video_binary;
-		*width  = binary->in_frame_info.width +
-			  columns_needed_for_bayer_order(pipe);
-		*height = binary->in_frame_info.height +
-			  lines_needed_for_bayer_order(pipe);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_input_resolution() leave: "
-		"width=%d, height=%d\n", *width, *height);
-	return err;
-}
-
-enum sh_css_err sh_css_video_configure_viewfinder(
-	unsigned int width, unsigned int height, unsigned int min_padded_width,
-	enum sh_css_frame_format format)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_configure_viewfinder() enter: "
-		"width=%d, height=%d, min_padded_width=%d, format=%d\n",
-		width, height, min_padded_width, format);
-
-	err = check_res(width, height);
-	if (err != sh_css_success) {
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_video_configure_viewfinder() leave: "
-			"return_err=%d\n", err);
-		return err;
-	}
-	if (pipe->vf_output_info.width != width ||
-	    pipe->vf_output_info.height != height ||
-	    pipe->vf_output_info.padded_width != min_padded_width ||
-	    pipe->vf_output_info.format != format) {
-		sh_css_frame_info_init(&pipe->vf_output_info,
-				       width, height, min_padded_width, format);
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_configure_viewfinder() leave: return_err=%d\n",
-		sh_css_success);
-	return sh_css_success;
-}
-
-/* Specify the envelope to be used for DIS. */
-void sh_css_video_set_dis_envelope(
-	unsigned int width,
-	unsigned int height)
-{
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_set_dis_envelope() enter: width=%d, height=%d\n", width, height);
-	if (width != pipe->dvs_envelope.width ||
-	    height != pipe->dvs_envelope.height) {
-		pipe->dvs_envelope.width = width;
-		pipe->dvs_envelope.height = height;
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_video_set_dis_envelope() leave: return=void\n");
-}
-
-void sh_css_video_get_dis_envelope(
-	unsigned int *width,
-	unsigned int *height)
-{
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_video_get_dis_envelope() enter: void\n");
-
-	assert(width != NULL);
-	if (width == NULL)
-		return;
-
-	assert(height != NULL);
-	if (height == NULL)
-		return;
-
-	*width = pipe->dvs_envelope.width;
-	*height = pipe->dvs_envelope.height;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_dis_envelope() leave: width=%d, height=%d\n", *width, *height);
-}
-
-#if 0
-/* rvanimme: Not supported for now, use global sh_css_set_zoom_factor */
-void sh_css_pipe_set_zoom_factor(
-	struct sh_css_pipe *me,
-	unsigned int dx,
- 	unsigned int dy)
-{
-	bool is_zoomed  = dx < HRT_GDC_N || dy < HRT_GDC_N;
-	bool was_zoomed = me->curr_dx < HRT_GDC_N ||
-			  me->curr_dy < HRT_GDC_N;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_zoom_factor() enter: pipe_id=%d, dx=%d, dy=%d\n",
-		me->mode, dx, dy);
-
-	if (is_zoomed != was_zoomed) {
-		/* for with/without zoom, we use different binaries */
-		me->zoom_changed   = true;
-	}
-	me->curr_dx = dx;
-	me->curr_dy = dy;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_set_zoom_factor() leave: return=void\n");
-}
-
-void sh_css_pipe_get_zoom_factor(
-	struct sh_css_pipe *me,
-	unsigned int *dx,
-	unsigned int *dy)
-{
-assert(dx != NULL);
-assert(dy != NULL);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_get_zoom_factor() enter: pipe_id=%d\n", me->mode);
-	*dx = me->curr_dx;
-	*dy = me->curr_dy;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipe_get_zoom_factor() leave: dx=%d, dy=%d\n", *dx, *dy);
-
-}
-#endif
-
-static enum sh_css_err load_copy_binaries(
-	struct sh_css_pipe *pipe)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_copy_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->pipe.capture.copy_binary.info)
-		return sh_css_success;
-
-	err = check_frame_info(&pipe->output_info);
-	if (err != sh_css_success)
-		return err;
-
-	get_copy_out_frame_format(pipe,
-				  &pipe->output_info.format);
-	return load_copy_binary(pipe,
-				&pipe->pipe.capture.copy_binary,
-				NULL);
-}
-
-static bool need_capture_pp(
-	const struct sh_css_pipe *pipe)
-{
-	struct sh_css_zoom zoom;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "need_capture_pp() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return false;
-
-	/* determine whether we need to use the capture_pp binary.
-	 * This is needed for:
-	 *   1. XNR or
-	 *   2. Digital Zoom or
-	 *   3. YUV downscaling
-	 *   4. in continuous capture mode
-	 */
-	if (pipe->yuv_ds_input_info.width &&
-	    ((pipe->yuv_ds_input_info.width != pipe->output_info.width) ||
-	     (pipe->yuv_ds_input_info.height != pipe->output_info.height)))
-		return true;
-	if (pipe->xnr)
-		return true;
-
-	sh_css_get_zoom(&zoom);
-	if (zoom.dx < HRT_GDC_N ||
-	    zoom.dy < HRT_GDC_N)
-		return true;
-
-	if (my_css.cont_capt)
-		return true;
-
-	return false;
-}
-
-static void init_capture_pp_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *vf_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_capture_pp_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(vf_info != NULL);
-	if (vf_info == NULL)
-		return;
-
-	/* the in_info is only used for resolution to enable
-	   bayer down scaling. */
-	if (pipe->yuv_ds_input_info.width)
-		*in_info = pipe->yuv_ds_input_info;
-	else
-		*in_info = pipe->output_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_YUV420;
-	in_info->raw_bit_depth = 0;
-	sh_css_frame_info_set_width(in_info, in_info->width, 0);
-	init_offline_descr(pipe,
-			   &capture_pp_descr,
-			   SH_CSS_BINARY_MODE_CAPTURE_PP,
-			   in_info,
-			   &pipe->output_info,
-			   vf_info);
-}
-
-static void init_primary_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info,
-	struct sh_css_frame_info *vf_info)
-{
-	int mode = SH_CSS_BINARY_MODE_PRIMARY;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_primary_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(out_info != NULL);
-	if (out_info == NULL)
-		return;
-	assert(vf_info != NULL);
-	if (vf_info == NULL)
-		return;
-
-	if (input_format_is_yuv(pipe->input_format))
-		mode = SH_CSS_BINARY_MODE_COPY;
-
-	*in_info = pipe->input_effective_info;
-
-	in_info->format = SH_CSS_FRAME_FORMAT_RAW;
-
-	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
-	init_offline_descr(pipe,
-			   &prim_descr,
-			   mode,
-			   in_info,
-			   out_info,
-			   vf_info);
-	if (pipe->online && pipe->input_mode != SH_CSS_INPUT_MODE_MEMORY) {
-		prim_descr.online        = true;
-		prim_descr.two_ppc       = pipe->two_ppc;
-		prim_descr.stream_format = pipe->input_format;
-	}
-}
-
-static void init_pre_gdc_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_pre_gdc_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(out_info != NULL);
-	if (out_info == NULL)
-		return;
-
-	*in_info = *out_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_RAW;
-	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
-	init_offline_descr(pipe,
-			   &pre_gdc_descr, SH_CSS_BINARY_MODE_PRE_ISP,
-			   in_info, out_info, NULL);
-}
-
-static void
-init_gdc_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_gdc_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(out_info != NULL);
-	if (out_info == NULL)
-		return;
-
-	*in_info = *out_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_QPLANE6;
-	init_offline_descr(pipe,
-			   &gdc_descr, SH_CSS_BINARY_MODE_GDC,
-			   in_info, out_info, NULL);
-}
-
-static void init_post_gdc_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info,
-	struct sh_css_frame_info *vf_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_post_gdc_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(out_info != NULL);
-	if (out_info == NULL)
-		return;
-	assert(vf_info != NULL);
-	if (vf_info == NULL)
-		return;
-
-	*in_info = *out_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_YUV420_16;
-	init_offline_descr(pipe,
-			   &post_gdc_descr, SH_CSS_BINARY_MODE_POST_ISP,
-			   in_info, out_info, vf_info);
-}
-
-static void init_pre_anr_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_pre_anr_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(out_info != NULL);
-	if (out_info == NULL)
-		return;
-
-	*in_info = *out_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_RAW;
-	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
-	init_offline_descr(pipe,
-			   &pre_anr_descr, SH_CSS_BINARY_MODE_PRE_ISP,
-			   in_info, out_info, NULL);
-	if (pipe->online) {
-		pre_anr_descr.online        = true;
-		pre_anr_descr.two_ppc       = pipe->two_ppc;
-		pre_anr_descr.stream_format = pipe->input_format;
-	}
-}
-
-static void init_anr_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_anr_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(out_info != NULL);
-	if (out_info == NULL)
-		return;
-
-	*in_info = *out_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_RAW;
-	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
-	init_offline_descr(pipe,
-			   &anr_descr, SH_CSS_BINARY_MODE_ANR,
-			   in_info, out_info, NULL);
-}
-
-static void init_post_anr_descr(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *in_info,
-	struct sh_css_frame_info *out_info,
-	struct sh_css_frame_info *vf_info)
-{
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "init_post_anr_descr() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return;
-	assert(in_info != NULL);
-	if (in_info == NULL)
-		return;
-	assert(out_info != NULL);
-	if (out_info == NULL)
-		return;
-	assert(vf_info != NULL);
-	if (vf_info == NULL)
-		return;
-
-	*in_info = *out_info;
-	in_info->format = SH_CSS_FRAME_FORMAT_RAW;
-	in_info->raw_bit_depth = sh_css_pipe_input_format_bits_per_pixel(pipe);
-	init_offline_descr(pipe,
-			   &post_anr_descr, SH_CSS_BINARY_MODE_POST_ISP,
-			   in_info, out_info, vf_info);
-}
-#if 0
-static enum sh_css_err
-primary_alloc_continuous_frames(
-	struct sh_css_pipe *pipe,
-	unsigned int stride)
-{
-	struct sh_css_capture_settings *mycs = &pipe->pipe.capture;
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_frame_info ref_info;
-	unsigned int i;
-
-	ref_info = mycs->primary_binary.internal_frame_info;
-	ref_info.format = SH_CSS_FRAME_FORMAT_RAW;
-	ref_info.padded_width = stride;
-
-	for (i = 0; i < NUM_CONTINUOUS_FRAMES; i++) {
-		/* free previous frame */
-		if (mycs->continuous_frames[i])
-			sh_css_frame_free(mycs->continuous_frames[i]);
-		/* check if new frame needed */
-		if (i < my_css.num_cont_raw_frames) {
-			/* allocate new frame */
-			err = sh_css_frame_allocate_from_info(
-				&mycs->continuous_frames[i], &ref_info);
-			if (err != sh_css_success)
-				return err;
-		}
-	}
-
-	if (SH_CSS_PREVENT_UNINIT_READS)
-		sh_css_frame_zero(mycs->continuous_frames[0]);
-	return sh_css_success;
-}
-#endif
-
-static enum sh_css_err load_primary_binaries(
-	struct sh_css_pipe *pipe)
-{
-	bool online;
-	bool continuous = my_css.continuous;
-	bool need_pp = false;
-	struct sh_css_frame_info prim_in_info,
-				 prim_out_info, vf_info,
-				 *vf_pp_in_info;
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_capture_settings *mycs;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_primary_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	online = pipe->online;
-	mycs = &pipe->pipe.capture;
-
-	if (mycs->primary_binary.info)
-		return sh_css_success;
-
-	err = check_vf_out_info(&pipe->output_info, &pipe->vf_output_info);
-	if (err != sh_css_success)
-		return err;
-	need_pp = need_capture_pp(pipe);
-
-	/* we use the vf output info to get the primary/capture_pp binary
-	   configured for vf_veceven. It will select the closest downscaling
-	   factor. */
-	vf_info = pipe->vf_output_info;
-	sh_css_frame_info_set_format(&vf_info, SH_CSS_FRAME_FORMAT_YUV_LINE);
-
-	/* we build up the pipeline starting at the end */
-	/* Capture post-processing */
-	if (need_pp) {
-		init_capture_pp_descr(pipe, &prim_out_info, &vf_info);
-		err = sh_css_binary_find(&capture_pp_descr,
-					&mycs->capture_pp_binary,
-					false);
-		if (err != sh_css_success)
-			return err;
-	} else {
-		prim_out_info = pipe->output_info;
-	}
-
-	/* Primary */
-	init_primary_descr(pipe, &prim_in_info, &prim_out_info, &vf_info);
-	err = sh_css_binary_find(&prim_descr, &mycs->primary_binary, false);
-	if (err != sh_css_success)
-		return err;
-
-	/* Viewfinder post-processing */
-	if (need_pp) {
-		vf_pp_in_info =
-		    &mycs->capture_pp_binary.vf_frame_info;
-	} else {
-		vf_pp_in_info =
-		    &mycs->primary_binary.vf_frame_info;
-	}
-
-	init_vf_pp_descr(pipe, vf_pp_in_info, &pipe->vf_output_info);
-	err = sh_css_binary_find(&vf_pp_descr,
-				 &mycs->vf_pp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-
-	/* ISP Copy */
-	if (!online && !continuous) {
-		err = load_copy_binary(pipe,
-				       &mycs->copy_binary,
-				       &mycs->primary_binary);
-		if (err != sh_css_success)
-			return err;
-	}
-
-#if 0
-	/* SP copy */
-	if (continuous) {
-		err = primary_alloc_continuous_frames(pipe);
-		if (err != sh_css_success)
-			return err;
-	}
-#endif
-
-
-	if (need_pp)
-		return alloc_capture_pp_frame(pipe, &mycs->capture_pp_binary);
-	else
-		return sh_css_success;
-}
-
-static enum sh_css_err load_advanced_binaries(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_frame_info pre_in_info, gdc_in_info,
-				 post_in_info, post_out_info,
-				 vf_info, *vf_pp_in_info;
-	bool need_pp;
-	enum sh_css_err err = sh_css_success;
-
-	bool continuous = my_css.continuous;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_advanced_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->pipe.capture.pre_isp_binary.info)
-		return sh_css_success;
-
-	vf_info = pipe->vf_output_info;
-	err = check_vf_out_info(&pipe->output_info,
-				&vf_info);
-	if (err != sh_css_success)
-		return err;
-	need_pp = need_capture_pp(pipe);
-
-	sh_css_frame_info_set_format(&vf_info,
-				     SH_CSS_FRAME_FORMAT_YUV_LINE);
-
-	/* we build up the pipeline starting at the end */
-	/* Capture post-processing */
-	if (need_pp) {
-		init_capture_pp_descr(pipe, &post_out_info, &vf_info);
-		err = sh_css_binary_find(&capture_pp_descr,
-				&pipe->pipe.capture.capture_pp_binary,
-				false);
-		if (err != sh_css_success)
-			return err;
-	} else {
-		post_out_info = pipe->output_info;
-	}
-
-	/* Post-gdc */
-	init_post_gdc_descr(pipe, &post_in_info, &post_out_info, &vf_info);
-	err = sh_css_binary_find(&post_gdc_descr,
-				 &pipe->pipe.capture.post_isp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-
-	/* Gdc */
-	init_gdc_descr(pipe, &gdc_in_info,
-		       &pipe->pipe.capture.post_isp_binary.in_frame_info);
-	err = sh_css_binary_find(&gdc_descr,
-				 &pipe->pipe.capture.gdc_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-	pipe->pipe.capture.gdc_binary.left_padding =
-		pipe->pipe.capture.post_isp_binary.left_padding;
-
-	/* Pre-gdc */
-	init_pre_gdc_descr(pipe, &pre_in_info,
-			   &pipe->pipe.capture.gdc_binary.in_frame_info);
-	err = sh_css_binary_find(&pre_gdc_descr,
-				 &pipe->pipe.capture.pre_isp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-	pipe->pipe.capture.pre_isp_binary.left_padding =
-		pipe->pipe.capture.gdc_binary.left_padding;
-
-	/* Viewfinder post-processing */
-	if (need_pp) {
-		vf_pp_in_info =
-		    &pipe->pipe.capture.capture_pp_binary.vf_frame_info;
-	} else {
-		vf_pp_in_info =
-		    &pipe->pipe.capture.post_isp_binary.vf_frame_info;
-	}
-
-	init_vf_pp_descr(pipe, vf_pp_in_info, &pipe->vf_output_info);
-	err = sh_css_binary_find(&vf_pp_descr,
-				 &pipe->pipe.capture.vf_pp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-
-	/* If continuous, SP is responsible for the copy */
-	if (!continuous) {
-		/* Copy */
-		err = load_copy_binary(pipe,
-				       &pipe->pipe.capture.copy_binary,
-				       &pipe->pipe.capture.pre_isp_binary);
-		if (err != sh_css_success)
-			return err;
-	}
-
-	if (need_pp)
-		return alloc_capture_pp_frame(pipe,
-				&pipe->pipe.capture.capture_pp_binary);
-	else
-		return sh_css_success;
-}
-
-static enum sh_css_err load_pre_isp_binaries(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_frame_info pre_isp_in_info;
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_pre_isp_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->pipe.capture.pre_isp_binary.info)
-		return sh_css_success;
-
-	err = check_frame_info(&pipe->output_info);
-	if (err != sh_css_success)
-		return err;
-
-	init_pre_anr_descr(pipe, &pre_isp_in_info,
-			   &pipe->output_info);
-
-	err = sh_css_binary_find(&pre_anr_descr,
-				 &pipe->pipe.capture.pre_isp_binary,
-				 false);
-
-	return err;
-}
-
-static enum sh_css_err load_low_light_binaries(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_frame_info pre_in_info, anr_in_info,
-				 post_in_info, post_out_info,
-				 vf_info, *vf_pp_in_info;
-	bool need_pp;
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_low_light_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->pipe.capture.pre_isp_binary.info)
-		return sh_css_success;
-
-	vf_info = pipe->vf_output_info;
-	err = check_vf_out_info(&pipe->output_info,
-				&vf_info);
-	if (err != sh_css_success)
-		return err;
-	need_pp = need_capture_pp(pipe);
-
-	sh_css_frame_info_set_format(&vf_info,
-				     SH_CSS_FRAME_FORMAT_YUV_LINE);
-
-	/* we build up the pipeline starting at the end */
-	/* Capture post-processing */
-	if (need_pp) {
-		init_capture_pp_descr(pipe, &post_out_info, &vf_info);
-		err = sh_css_binary_find(&capture_pp_descr,
-				&pipe->pipe.capture.capture_pp_binary,
-				false);
-		if (err != sh_css_success)
-			return err;
-	} else {
-		post_out_info = pipe->output_info;
-	}
-
-	/* Post-anr */
-	init_post_anr_descr(pipe, &post_in_info, &post_out_info, &vf_info);
-	err = sh_css_binary_find(&post_anr_descr,
-				 &pipe->pipe.capture.post_isp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-
-	/* Anr */
-	init_anr_descr(pipe, &anr_in_info,
-		       &pipe->pipe.capture.post_isp_binary.in_frame_info);
-	err = sh_css_binary_find(&anr_descr,
-				 &pipe->pipe.capture.anr_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-	pipe->pipe.capture.anr_binary.left_padding =
-		pipe->pipe.capture.post_isp_binary.left_padding;
-
-	/* Pre-anr */
-	init_pre_anr_descr(pipe, &pre_in_info,
-			   &pipe->pipe.capture.anr_binary.in_frame_info);
-	err = sh_css_binary_find(&pre_anr_descr,
-				 &pipe->pipe.capture.pre_isp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-	pipe->pipe.capture.pre_isp_binary.left_padding =
-		pipe->pipe.capture.anr_binary.left_padding;
-
-	/* Viewfinder post-processing */
-	if (need_pp) {
-		vf_pp_in_info =
-		    &pipe->pipe.capture.capture_pp_binary.vf_frame_info;
-	} else {
-		vf_pp_in_info =
-		    &pipe->pipe.capture.post_isp_binary.vf_frame_info;
-	}
-
-	init_vf_pp_descr(pipe, vf_pp_in_info, &pipe->vf_output_info);
-	err = sh_css_binary_find(&vf_pp_descr,
-				 &pipe->pipe.capture.vf_pp_binary,
-				 false);
-	if (err != sh_css_success)
-		return err;
-
-	/* Copy */
-	err = load_copy_binary(pipe,
-			       &pipe->pipe.capture.copy_binary,
-			       &pipe->pipe.capture.pre_isp_binary);
-	if (err != sh_css_success)
-		return err;
-
-	if (need_pp)
-		return alloc_capture_pp_frame(pipe,
-				&pipe->pipe.capture.capture_pp_binary);
-	else
-		return sh_css_success;
-}
-
-static bool copy_on_sp(
-	struct sh_css_pipe *pipe)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "copy_on_sp() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->mode != SH_CSS_CAPTURE_PIPELINE)
-		return false;
-	if (pipe->capture_mode != SH_CSS_CAPTURE_MODE_RAW)
-		return false;
-	return my_css.continuous ||
-		pipe->input_format == SH_CSS_INPUT_FORMAT_BINARY_8;
-}
-
-static enum sh_css_err load_capture_binaries(
-	struct sh_css_pipe *pipe)
-{
-	enum sh_css_err err = sh_css_success;
-	bool must_be_raw;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "load_capture_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	/* in primary, advanced,low light or bayer,
-						the input format must be raw */
-	must_be_raw =
-		pipe->capture_mode == SH_CSS_CAPTURE_MODE_ADVANCED ||
-		pipe->capture_mode == SH_CSS_CAPTURE_MODE_BAYER ||
-		pipe->capture_mode == SH_CSS_CAPTURE_MODE_LOW_LIGHT;
-	err = check_input(pipe, must_be_raw);
-	if (err != sh_css_success)
-		return err;
-	if (copy_on_sp(pipe)) {
-		/* this is handled by the SP, no ISP binaries needed. */
-		if (pipe->input_format == SH_CSS_INPUT_FORMAT_BINARY_8) {
-			sh_css_frame_info_init(
-				&pipe->output_info,
-				JPEG_BYTES, 1, 0, SH_CSS_FRAME_FORMAT_BINARY_8);
-			return sh_css_success;
-		}
-	}
-
-	switch (pipe->capture_mode) {
-	case SH_CSS_CAPTURE_MODE_RAW:
-		return load_copy_binaries(pipe);
-	case SH_CSS_CAPTURE_MODE_BAYER:
-		return load_pre_isp_binaries(pipe);
-	case SH_CSS_CAPTURE_MODE_PRIMARY:
-		return load_primary_binaries(pipe);
-	case SH_CSS_CAPTURE_MODE_ADVANCED:
-		return load_advanced_binaries(pipe);
-	case SH_CSS_CAPTURE_MODE_LOW_LIGHT:
-		return load_low_light_binaries(pipe);
-	}
-	return sh_css_success;
-}
-
-static enum sh_css_err sh_css_pipe_load_binaries(
-	struct sh_css_pipe *pipe)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_load_binaries() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	switch (pipe->mode) {
-	case SH_CSS_PREVIEW_PIPELINE:
-		err = load_preview_binaries(pipe);
-		break;
-	case SH_CSS_VIDEO_PIPELINE:
-		err = load_video_binaries(pipe);
-		break;
-	case SH_CSS_CAPTURE_PIPELINE:
-		err = load_capture_binaries(pipe);
-		break;
-	default:
-		err = sh_css_err_internal_error;
-		break;
-	}
-	return err;
-}
-
-static enum sh_css_err construct_capture_pipe(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_pipeline *me = &pipe->pipeline;
-	enum sh_css_err err = sh_css_success;
-	enum sh_css_capture_mode mode = pipe->capture_mode;
-
-	struct sh_css_pipeline_stage *vf_pp_stage, *post_stage = NULL;
-
-	struct sh_css_frame *cc_frame = NULL;
-	struct sh_css_binary *copy_binary,
-			     *primary_binary,
-			     *vf_pp_binary,
-			     *pre_isp_binary,
-			     *gdc_binary,
-			     *post_isp_binary,
-			     *anr_binary,
-			     *capture_pp_binary;
-	bool need_pp = false;
-	bool enable_vfpp = false;
-	bool raw = mode == SH_CSS_CAPTURE_MODE_RAW;
-	bool raw_copy = raw && copy_on_sp(pipe);
-
-	/**
-	 * rvanimme: in_frame support is broken and forced to NULL
-	 * TODO: add a way to tell the pipeline construction that an in_frame
-	 * is used.
-	 */
-	struct sh_css_frame *in_frame = &me->in_frame;
-	struct sh_css_frame *out_frame = &me->out_frame;
-	struct sh_css_frame *vf_frame = &me->vf_frame;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "construct_capture_pipe() enter:\n");
-	sh_css_pipeline_clean(me);
-
-	/* Construct in_frame info (only in case we have dynamic input) */
-	if (pipe->input_mode == SH_CSS_INPUT_MODE_MEMORY) {
-		in_frame->info.format = SH_CSS_FRAME_FORMAT_RAW;
-		in_frame->info.width = pipe->input_width;
-		in_frame->info.height = pipe->input_height;
-		in_frame->info.raw_bit_depth =
-			sh_css_pipe_input_format_bits_per_pixel(pipe);
-		sh_css_frame_info_set_width(&in_frame->info, pipe->input_width,
-					    in_frame->info.padded_width);
-
-		in_frame->contiguous = false;
-		in_frame->flash_state = SH_CSS_FRAME_NO_FLASH;
-		in_frame->dynamic_data_index = sh_css_frame_in;
-		err = init_frame_planes(in_frame);
-		if (err != sh_css_success)
-			return err;
-	} else {
-		in_frame = NULL;
-	}
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err != sh_css_success)
-		return err;
-
-	/* Construct out_frame info */
-	sh_css_capture_get_output_frame_info(&out_frame->info);
-	out_frame->contiguous = false;
-	out_frame->flash_state = SH_CSS_FRAME_NO_FLASH;
-	out_frame->dynamic_data_index = sh_css_frame_out;
-	err = init_frame_planes(out_frame);
-	if (err != sh_css_success)
-		return err;
-
-	need_pp = need_capture_pp(pipe) || pipe->output_stage;
-
-	enable_vfpp = (mode != SH_CSS_CAPTURE_MODE_RAW &&
-			mode != SH_CSS_CAPTURE_MODE_BAYER );
-
-	/* Construct vf_frame info (only in case we have VF) */
-	if (enable_vfpp) {
-		sh_css_capture_get_viewfinder_frame_info(&vf_frame->info);
-		vf_frame->contiguous = false;
-		vf_frame->flash_state = SH_CSS_FRAME_NO_FLASH;
-		vf_frame->dynamic_data_index = sh_css_frame_out_vf;
-		err = init_frame_planes(vf_frame);
-		if (err != sh_css_success)
-			return err;
-	} else {
-		vf_frame = NULL;
-	}
-
-	copy_binary       = &pipe->pipe.capture.copy_binary;
-	primary_binary    = &pipe->pipe.capture.primary_binary;
-	vf_pp_binary      = &pipe->pipe.capture.vf_pp_binary;
-	pre_isp_binary    = &pipe->pipe.capture.pre_isp_binary;
-	gdc_binary        = &pipe->pipe.capture.gdc_binary;
-	post_isp_binary   = &pipe->pipe.capture.post_isp_binary;
-	anr_binary        = &pipe->pipe.capture.anr_binary;
-	capture_pp_binary = &pipe->pipe.capture.capture_pp_binary;
-
-	if (pipe->pipe.capture.copy_binary.info && !raw_copy) {
-		err = sh_css_pipeline_add_stage(me, copy_binary, NULL,
-				copy_binary->info->mode, NULL, NULL,
-				raw ? out_frame : in_frame,
-				NULL, &post_stage);
-		if (err != sh_css_success)
-			return err;
-	} else if (my_css.continuous) {
-		in_frame = my_css.preview_pipe.pipe.preview.continuous_frames[0];
-	}
-
-	if (mode == SH_CSS_CAPTURE_MODE_PRIMARY) {
-		err = sh_css_pipeline_add_stage(me, primary_binary,
-				NULL, primary_binary->info->mode,
-				cc_frame, in_frame,
-				need_pp ? NULL : out_frame,
-				NULL, &post_stage);
-		if (err != sh_css_success)
-			return err;
-		/* If we use copy iso primary,
-		   the input must be yuv iso raw */
-		post_stage->args.copy_vf =
-			primary_binary->info->mode == SH_CSS_BINARY_MODE_COPY;
-		post_stage->args.copy_output = post_stage->args.copy_vf;
-	} else if (mode == SH_CSS_CAPTURE_MODE_ADVANCED) {
-		err = sh_css_pipeline_add_stage(me, pre_isp_binary,
-				NULL, pre_isp_binary->info->mode,
-				cc_frame, in_frame, NULL, NULL, NULL);
-		if (err != sh_css_success)
-			return err;
-		err = sh_css_pipeline_add_stage(me, gdc_binary,
-				NULL, gdc_binary->info->mode,
-				NULL, NULL, NULL, NULL, NULL);
-		if (err != sh_css_success)
-			return err;
-		err = sh_css_pipeline_add_stage(me, post_isp_binary,
-				NULL, post_isp_binary->info->mode,
-				NULL, NULL,
-				need_pp ? NULL : out_frame,
-				NULL, &post_stage);
-		if (err != sh_css_success)
-			return err;
-	} else if (mode == SH_CSS_CAPTURE_MODE_LOW_LIGHT) {
-		err = sh_css_pipeline_add_stage(me, pre_isp_binary,
-				NULL, pre_isp_binary->info->mode,
-				cc_frame, in_frame, NULL, NULL, NULL);
-		if (err != sh_css_success)
-			return err;
-		err = sh_css_pipeline_add_stage(me, anr_binary,
-				NULL, anr_binary->info->mode,
-				NULL, NULL, NULL, NULL, NULL);
-		if (err != sh_css_success)
-			return err;
-		err = sh_css_pipeline_add_stage(me, post_isp_binary,
-				NULL, post_isp_binary->info->mode,
-				NULL, NULL,
-				need_pp ? NULL : out_frame,
-				NULL, &post_stage);
-		if (err != sh_css_success)
-			return err;
-	} else if (mode == SH_CSS_CAPTURE_MODE_BAYER) {
-		err = sh_css_pipeline_add_stage(me, pre_isp_binary,
-				NULL, pre_isp_binary->info->mode,
-				cc_frame, in_frame, out_frame,
-				NULL, NULL);
-		if (err != sh_css_success)
-			return err;
-	}
-	if (need_pp) {
-		err = add_capture_pp_stage(pipe, me, out_frame,
-					   capture_pp_binary,
-					   post_stage, &post_stage);
-		if (err != sh_css_success)
-			return err;
-	}
-	if (enable_vfpp) {
-		err = add_vf_pp_stage(pipe, vf_frame, vf_pp_binary,
-				      post_stage, &vf_pp_stage);
-		if (err != sh_css_success)
-			return err;
-	}
-	number_stages(pipe);
-
-	return sh_css_success;
-
-}
-
-static enum sh_css_err capture_start(
-	struct sh_css_pipe *pipe)
-{
-	struct sh_css_pipeline *me = &pipe->pipeline;
-
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "capture_start() enter:\n");
-	sh_css_pipeline_stream_clear_pipelines();
-	sh_css_pipeline_stream_add_pipeline(me);
-
-	err = construct_capture_pipe(pipe);
-	if (err != sh_css_success)
-		return err;
-
-	my_css.curr_pipe = pipe;
-
-	if (pipe->input_mode != SH_CSS_INPUT_MODE_MEMORY) {
-	err = sh_css_config_input_network(pipe, &pipe->pipe.capture.copy_binary);
-	if (err != sh_css_success)
-		return err;
-	}
-
-	if (pipe->capture_mode == SH_CSS_CAPTURE_MODE_RAW ||
-	    pipe->capture_mode == SH_CSS_CAPTURE_MODE_BAYER) {
-		if (copy_on_sp(pipe)) {
-			my_css.curr_state = sh_css_state_executing_sp_bin_copy;
-
-			return start_copy_on_sp(pipe,
-				&pipe->pipe.capture.copy_binary,
-				&me->out_frame);
-		}
-	}
-
-	start_pipe(pipe, SH_CSS_PIPE_CONFIG_OVRD_THRD_2);
-
-	return sh_css_success;
-
-}
-
-static enum sh_css_err sh_css_pipe_get_output_frame_info(
-	struct sh_css_pipe *pipe,
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_get_output_frame_info() enter:\n");
-
-	assert(pipe != NULL);
-	if (pipe == NULL)
-		return sh_css_err_internal_error;
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success)
-		*info = pipe->output_info;
-	if (copy_on_sp(pipe) &&
-	    pipe->input_format == SH_CSS_INPUT_FORMAT_BINARY_8) {
-		sh_css_frame_info_init(info, JPEG_BYTES, 1, 0,
-				SH_CSS_FRAME_FORMAT_BINARY_8);
-	} else if (info->format == SH_CSS_FRAME_FORMAT_RAW) {
-		info->raw_bit_depth =
-			sh_css_pipe_input_format_bits_per_pixel(pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_get_output_frame_info() leave:\n");
-	return err;
-}
-
-enum sh_css_err sh_css_capture_get_viewfinder_frame_info(
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err;
-	struct sh_css_pipe *pipe = &my_css.capture_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_viewfinder_frame_info()\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->capture_mode == SH_CSS_CAPTURE_MODE_RAW ||
-	    pipe->capture_mode == SH_CSS_CAPTURE_MODE_BAYER)
-		return sh_css_err_mode_does_not_have_viewfinder;
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success)
-		*info = pipe->vf_output_info;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_viewfinder_frame_info() leave: "
-		"info.width=%d, info.height=%d, info.padded_width=%d, "
-		"info.format=%d, info.raw_bit_depth=%d, "
-		"info.raw_bayer_order=%d\n",
-		info->width,info->height,
-		info->padded_width,info->format,
-		info->raw_bit_depth,info->raw_bayer_order);
-	return err;
-}
-
-enum sh_css_err sh_css_capture_get_output_raw_frame_info(
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err;
-	struct sh_css_pipe *pipe = &my_css.capture_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_output_raw_frame_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	if (pipe->online || copy_on_sp(pipe)) {
-		return sh_css_err_mode_does_not_have_raw_output;
-	}
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success)
-		*info = pipe->pipe.capture.copy_binary.out_frame_info;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_output_raw_frame_info() leave: "
-		"info.width=%d, info.height=%d, info.padded_width=%d, "
-		"info.format=%d, info.raw_bit_depth=%d, "
-		"info.raw_bayer_order=%d\n",
-		info->width,info->height,
-		info->padded_width,info->format,
-		info->raw_bit_depth,info->raw_bayer_order);
-	return err;
-}
-
-enum sh_css_err sh_css_capture_get_input_resolution(
-	unsigned int *width,
-	unsigned int *height)
-{
-	enum sh_css_err err;
-	struct sh_css_pipe *pipe = &my_css.capture_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_input_resolution() enter: void\n");
-
-	assert(width != NULL);
-	if (width == NULL)
-		return sh_css_err_internal_error;
-
-	assert(height != NULL);
-	if (height == NULL)
-		return sh_css_err_internal_error;
-
-	if (copy_on_sp(pipe) &&
-	    pipe->input_format == SH_CSS_INPUT_FORMAT_BINARY_8) {
-		*width = JPEG_BYTES;
-		*height = 1;
-		return sh_css_success;
-	}
-
-	err = sh_css_pipe_load_binaries(pipe);
-	if (err == sh_css_success) {
-		const struct sh_css_binary *binary;
-		if (pipe->pipe.capture.copy_binary.info)
-			binary = &pipe->pipe.capture.copy_binary;
-		else if (pipe->pipe.capture.primary_binary.info)
-			binary = &pipe->pipe.capture.primary_binary;
-		else
-			binary = &pipe->pipe.capture.pre_isp_binary;
-		*width  = binary->in_frame_info.width +
-			  columns_needed_for_bayer_order(pipe);
-		*height = binary->in_frame_info.height +
-			  lines_needed_for_bayer_order(pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_capture_get_input_resolution() "
-		"leave: width=%d, height=%d\n",*width,*height);
-	return err;
-}
-
-void
-sh_css_capture_set_mode(enum sh_css_capture_mode mode)
-{
-	struct sh_css_pipe *pipe = &my_css.capture_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_capture_set_mode() enter: mode=%d\n",mode);
-	if (mode != pipe->capture_mode) {
-		pipe->capture_mode = mode;
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_set_mode() leave: return_void\n");
-}
-
-void
-sh_css_capture_enable_xnr(bool enable)
-{
-	struct sh_css_pipe *pipe = &my_css.capture_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_capture_enable_xnr() enter: enable=%d\n",enable);
-	if (pipe->mode == SH_CSS_CAPTURE_PIPELINE && pipe->xnr != enable) {
-		sh_css_pipe_invalidate_binaries(pipe);
-		pipe->xnr = enable;
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_enable_xnr() leave: return_void\n");
-}
-
-enum sh_css_err sh_css_capture_configure_viewfinder(
-	unsigned int width, unsigned int height, unsigned int min_padded_width,
-	enum sh_css_frame_format format)
-{
-	struct sh_css_pipe *pipe = &my_css.capture_pipe;
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_capture_configure_viewfinder() "
-		"enter: width=%d, height=%d, min_padded_width=%d, format=%d\n",
-		width, height, min_padded_width, format);
-	err = check_res(width, height);
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_configure_viewfinder() leave: return_err=%d\n",
-		err);
-		return err;
-	}
-	if (pipe->vf_output_info.width != width ||
-	    pipe->vf_output_info.height != height ||
-	    pipe->vf_output_info.padded_width != min_padded_width ||
-	    pipe->vf_output_info.format != format) {
-		sh_css_frame_info_init(&pipe->vf_output_info,
-				       width, height, min_padded_width, format);
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_configure_viewfinder() leave: return_err=%d\n",
-		sh_css_success);
-	return sh_css_success;
-}
-
-enum sh_css_err sh_css_capture_configure_pp_input(
-	unsigned int width, unsigned int height)
-{
-	struct sh_css_pipe *pipe = &my_css.capture_pipe;
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_configure_pp_input() enter: "
-		"width=%d, height=%d\n",width, height);
-	err = check_null_res(width, height);
-	if (err != sh_css_success) {
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_capture_configure_pp_input() leave: "
-			"return_err=%d\n",
-			err);
-		return err;
-	}
-	if (pipe->yuv_ds_input_info.width != width ||
-	    pipe->yuv_ds_input_info.height != height) {
-		sh_css_frame_info_init(&pipe->yuv_ds_input_info,
-				       width, height, 0,
-				       SH_CSS_FRAME_FORMAT_YUV420);
-		sh_css_pipe_invalidate_binaries(pipe);
-	}
-	return sh_css_success;
-}
-
-void
-sh_css_pipe_enable_online(
-	struct sh_css_pipe *me,
-	bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipe_enable_online() enter & leave:\n");
-	me->online = enable;
-}
-
-void sh_css_send_input_frame(
-	unsigned short *data,
-	unsigned int width,
-	unsigned int height)
-{
-	sh_css_hrt_send_input_frame(data, width, height,
-				    my_css.curr_pipe->ch_id,
-				    my_css.curr_pipe->input_format,
-				    my_css.curr_pipe->two_ppc);
-}
-
-
-void sh_css_streaming_to_mipi_start_frame(
-	unsigned int channel_id,
-	enum sh_css_input_format input_format,
-	bool two_pixels_per_clock)
-{
-	sh_css_hrt_streaming_to_mipi_start_frame(channel_id,
-						input_format,
-						two_pixels_per_clock);
-}
-
-
-void
-sh_css_streaming_to_mipi_send_line(
-	unsigned int channel_id,
-	unsigned short *data,
-	unsigned int width,
-	unsigned short *data2,
-	unsigned int width2)
-{
-	sh_css_hrt_streaming_to_mipi_send_line(channel_id,
-						data, width,
-						data2, width2);
-}
-
-
-void sh_css_streaming_to_mipi_end_frame(
-	unsigned int channel_id)
-{
-	sh_css_hrt_streaming_to_mipi_end_frame(channel_id);
-}
-
-
-static enum sh_css_err allocate_frame_data(
-	struct sh_css_frame *frame)
-{
-	frame->data = mmgr_alloc_attr(frame->data_bytes,
-		frame->contiguous ?
-			MMGR_ATTRIBUTE_CONTIGUOUS : MMGR_ATTRIBUTE_DEFAULT);
-
-	if (frame->data == mmgr_NULL)
-		return sh_css_err_cannot_allocate_memory;
-	return sh_css_success;
-}
-
-static void init_plane(
-	struct sh_css_frame_plane *plane,
-	unsigned int width,
-	unsigned int stride,
-	unsigned int height,
-	unsigned int offset)
-{
-	plane->height = height;
-	plane->width = width;
-	plane->stride = stride;
-	plane->offset = offset;
-}
-
-static void init_single_plane(
-	struct sh_css_frame *frame,
-	struct sh_css_frame_plane *plane,
-	unsigned int height,
-	unsigned int subpixels_per_line,
-	unsigned int bytes_per_pixel)
-{
-	unsigned int stride;
-
-	stride = subpixels_per_line * bytes_per_pixel;
-	frame->data_bytes = stride * height;
-	init_plane(plane, subpixels_per_line, stride, height, 0);
-	return;
-	}
-
-static void init_nv_planes(
-	struct sh_css_frame *frame,
-	unsigned int horizontal_decimation,
-	unsigned int vertical_decimation)
-{
-	unsigned int y_width = frame->info.padded_width,
-		     y_height = frame->info.height,
-		     uv_width = 2 * (y_width / horizontal_decimation),
-		     uv_height = y_height / vertical_decimation,
-		     y_bytes, uv_bytes;
-
-	y_bytes   = y_width * y_height;
-	uv_bytes  = uv_width * uv_height;
-
-	frame->data_bytes = y_bytes + uv_bytes;
-	init_plane(&frame->planes.nv.y, y_width, y_width, y_height, 0);
-	init_plane(&frame->planes.nv.uv, uv_width,
-			uv_width, uv_height, y_bytes);
-	return;
-}
-
-static void init_yuv_planes(
-	struct sh_css_frame *frame,
-	unsigned int horizontal_decimation,
-	unsigned int vertical_decimation,
-	bool swap_uv,
-	unsigned int bytes_per_element)
-{
-	unsigned int y_width = frame->info.padded_width,
-		     y_height = frame->info.height,
-		     uv_width = y_width / horizontal_decimation,
-		     uv_height = y_height / vertical_decimation,
-		     y_stride, y_bytes, uv_bytes, uv_stride;
-
-	y_stride  = y_width * bytes_per_element;
-	uv_stride = uv_width * bytes_per_element;
-	y_bytes   = y_stride * y_height;
-	uv_bytes  = uv_stride * uv_height;
-
-	frame->data_bytes = y_bytes + 2 * uv_bytes;
-	init_plane(&frame->planes.yuv.y, y_width, y_stride, y_height, 0);
-		if (swap_uv) {
-			init_plane(&frame->planes.yuv.v, uv_width, uv_stride,
-				   uv_height, y_bytes);
-			init_plane(&frame->planes.yuv.u, uv_width, uv_stride,
-				   uv_height, y_bytes + uv_bytes);
-		} else {
-			init_plane(&frame->planes.yuv.u, uv_width, uv_stride,
-				   uv_height, y_bytes);
-			init_plane(&frame->planes.yuv.v, uv_width, uv_stride,
-				   uv_height, y_bytes + uv_bytes);
-		}
-	return;
-	}
-
-static void init_rgb_planes(
-	struct sh_css_frame *frame,
-	unsigned int bytes_per_element)
-{
-	unsigned int width = frame->info.width,
-		     height = frame->info.height, stride, bytes;
-
-	stride = width * bytes_per_element;
-	bytes  = stride * height;
-	frame->data_bytes = 3 * bytes;
-	init_plane(&frame->planes.planar_rgb.r,
-			width, stride, height, 0);
-	init_plane(&frame->planes.planar_rgb.g,
-			width, stride, height, 1 * bytes);
-	init_plane(&frame->planes.planar_rgb.b,
-			width, stride, height, 2 * bytes);
-	return;
-	}
-
-static void init_qplane6_planes(
-	struct sh_css_frame *frame)
-{
-	unsigned int width = frame->info.padded_width / 2,
-		     height = frame->info.height / 2,
-		     bytes, stride;
-
-	stride = width * 2;
-	bytes  = stride * height;
-
-	frame->data_bytes = 6 * bytes;
-	init_plane(&frame->planes.plane6.r,
-			width, stride, height, 0 * bytes);
-	init_plane(&frame->planes.plane6.r_at_b,
-			width, stride, height, 1 * bytes);
-	init_plane(&frame->planes.plane6.gr,
-			width, stride, height, 2 * bytes);
-	init_plane(&frame->planes.plane6.gb,
-			width, stride, height, 3 * bytes);
-	init_plane(&frame->planes.plane6.b,
-			width, stride, height, 4 * bytes);
-	init_plane(&frame->planes.plane6.b_at_r,
-			width, stride, height, 5 * bytes);
-	return;
-}
-
-static enum sh_css_err init_frame_planes(
-	struct sh_css_frame *frame)
-{
-	assert(frame != NULL);
-	if (frame == NULL)
-		return sh_css_err_internal_error;
-
-	switch (frame->info.format) {
-	case SH_CSS_FRAME_FORMAT_RAW:
-		init_single_plane(frame, &frame->planes.raw,
-				frame->info.height,
-				frame->info.padded_width,
-				// always use 2-bytes per pixel
-				2);
-		break;
-	case SH_CSS_FRAME_FORMAT_RGB565:
-		init_single_plane(frame, &frame->planes.rgb,
-				    frame->info.height,
-				    frame->info.padded_width, 2);
-		break;
-	case SH_CSS_FRAME_FORMAT_RGBA888:
-		init_single_plane(frame, &frame->planes.rgb,
-				    frame->info.height,
-				    frame->info.padded_width * 4, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_PLANAR_RGB888:
-		init_rgb_planes(frame, 1);
-		break;
-		/* yuyv and uyvu have the same frame layout, only the data
-		 * positioning differs.
-		 */
-	case SH_CSS_FRAME_FORMAT_YUYV:
-	case SH_CSS_FRAME_FORMAT_UYVY:
-		init_single_plane(frame, &frame->planes.yuyv,
-				    frame->info.height,
-				    frame->info.padded_width * 2, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV_LINE:
-		/* Needs 3 extra lines to allow vf_pp prefetching */
-		init_single_plane(frame, &frame->planes.yuyv,
-				    frame->info.height * 3/2 + 3,
-				    frame->info.padded_width, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_NV11:
-		init_nv_planes(frame, 4, 1);
-		break;
-		/* nv12 and nv21 have the same frame layout, only the data
-		 * positioning differs.
-		 */
-	case SH_CSS_FRAME_FORMAT_NV12:
-	case SH_CSS_FRAME_FORMAT_NV21:
-		init_nv_planes(frame, 2, 2);
-		break;
-		/* nv16 and nv61 have the same frame layout, only the data
-		 * positioning differs.
-		 */
-	case SH_CSS_FRAME_FORMAT_NV16:
-	case SH_CSS_FRAME_FORMAT_NV61:
-		init_nv_planes(frame, 2, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV420:
-		init_yuv_planes(frame, 2, 2, false, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV422:
-		init_yuv_planes(frame, 2, 1, false, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV444:
-		init_yuv_planes(frame, 1, 1, false, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV420_16:
-		init_yuv_planes(frame, 2, 2, false, 2);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV422_16:
-		init_yuv_planes(frame, 2, 1, false, 2);
-		break;
-	case SH_CSS_FRAME_FORMAT_YV12:
-		init_yuv_planes(frame, 2, 2, true, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_YV16:
-		init_yuv_planes(frame, 2, 1, true, 1);
-		break;
-	case SH_CSS_FRAME_FORMAT_QPLANE6:
-		init_qplane6_planes(frame);
-		break;
-	case SH_CSS_FRAME_FORMAT_BINARY_8:
-		init_single_plane(frame, &frame->planes.binary.data,
-				    frame->info.height,
-				    frame->info.padded_width, 1);
-		frame->planes.binary.size = 0;
-		break;
-	default:
-		return sh_css_err_invalid_frame_format;
-	}
-	return sh_css_success;
-}
-
-
-static enum sh_css_err allocate_frame_and_data(
-	struct sh_css_frame **frame,
-	unsigned int width,
-	unsigned int height,
-	enum sh_css_frame_format format,
-	unsigned int padded_width,
-	unsigned int raw_bit_depth,
-	bool contiguous)
-{
-	enum sh_css_err err;
-	struct sh_css_frame *me = sh_css_malloc(sizeof(*me));
-
-	if (me == NULL)
-		return sh_css_err_cannot_allocate_memory;
-
-	me->info.width = width;
-	me->info.height = height;
-	me->info.format = format;
-	me->info.padded_width = padded_width;
-	me->info.raw_bit_depth = raw_bit_depth;
-	me->contiguous = contiguous;
-	me->dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
-
-	err = init_frame_planes(me);
-
-	if (err == sh_css_success)
-		err = allocate_frame_data(me);
-
-	if (err != sh_css_success) {
-		sh_css_free(me);
-		return err;
-	}
-
-		*frame = me;
-
-	return err;
-}
-
-enum sh_css_err sh_css_frame_allocate(
-	struct sh_css_frame **frame,
-	unsigned int width,
-	unsigned int height,
-	enum sh_css_frame_format format,
-	unsigned int padded_width,
-	unsigned int raw_bit_depth)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate() enter: width=%d, height=%d, "
-		"padded_width=%d, format=%d\n",
-		width, height, padded_width, format);
-
-
-	err = allocate_frame_and_data(frame, width, height, format,
-			      padded_width, raw_bit_depth, false);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate() leave: return=%d, frame=%p\n",
-		err, frame ? *frame : (void *)-1);
-
-	return err;
-}
-
-enum sh_css_err sh_css_frame_allocate_from_info(
-	struct sh_css_frame **frame,
-	const struct sh_css_frame_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate_from_info() enter: "
-		"frame=%p, info=%p\n", frame, info);
-
-	assert(frame != NULL);
-	if (frame == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_frame_allocate(frame,
-				     info->width,
-				     info->height,
-				     info->format,
-				     info->padded_width,
-				     info->raw_bit_depth);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate_from_info() leave: "
-		"return=%d, *frame=%p\n", err, *frame);
-return err;
-}
-
-enum sh_css_err sh_css_frame_allocate_contiguous(
-	struct sh_css_frame **frame,
-	unsigned int width,
-	unsigned int height,
-	enum sh_css_frame_format format,
-	unsigned int padded_width,
-	unsigned int raw_bit_depth)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate_contiguous() "
-		"enter: width=%d, height=%d, format=%d\n",
-		width, height, format);
-
-	err = allocate_frame_and_data(frame, width, height, format,
-					padded_width, raw_bit_depth, true);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate_contiguous() leave: frame=%p\n",
-		frame ? *frame : (void *)-1);
-
-	return err;
-}
-
-enum sh_css_err sh_css_frame_allocate_contiguous_from_info(
-	struct sh_css_frame **frame,
-	const struct sh_css_frame_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate_contiguous_from_info() enter:\n");
-
-	assert(frame != NULL);
-	if (frame == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_frame_allocate_contiguous(frame,
-						info->width,
-						info->height,
-						info->format,
-						info->padded_width,
-						info->raw_bit_depth);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_allocate_contiguous_from_info() leave:\n");
-return err;
-}
-
-enum sh_css_err
-sh_css_frame_map(struct sh_css_frame **frame,
-                 const struct sh_css_frame_info *info,
-                 const void *data,
-                 uint16_t attribute,
-                 void *context)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_frame *me = sh_css_malloc(sizeof(*me));
-
-	if (me == NULL)
-		return sh_css_err_cannot_allocate_memory;
-
-	me->info.width = info->width;
-	me->info.height = info->height;
-	me->info.format = info->format;
-	me->info.padded_width = info->padded_width;
-	me->info.raw_bit_depth = info->raw_bit_depth;
-	me->contiguous = false; /* doublecheck */
-	me->dynamic_data_index = SH_CSS_INVALID_FRAME_ID;
-
-	err = init_frame_planes(me);
-
-	if (err == sh_css_success) {
-		/* use mmgr_mmap to map */
-		me->data = mmgr_mmap(
-				     data,
-				     me->data_bytes,
-				     attribute,
-				     context);
-		if (me->data == mmgr_NULL)
-			err = sh_css_err_invalid_arguments;
-	};
-
-	if (err != sh_css_success) {
-		sh_css_free(me);
-		return err;
-	}
-
-	*frame = me;
-
-	return err;
-}
-
-void
-sh_css_frame_free(struct sh_css_frame *frame)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_free() enter: frame=%p\n", frame);
-
-	if (frame != NULL) {
-		mmgr_free(frame->data);
-		sh_css_free(frame);
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_frame_free() leave: return_void\n");
-}
-
-bool sh_css_frame_info_equal_resolution(
-	const struct sh_css_frame_info *info_a,
-	const struct sh_css_frame_info *info_b)
-{
-	if (!info_a || !info_b)
-		return false;
-	return (info_a->width == info_b->width) &&
-	    (info_a->height == info_b->height);
-}
-
-bool sh_css_frame_equal_types(
-	const struct sh_css_frame *frame_a,
-	const struct sh_css_frame *frame_b)
-{
-	bool is_equal = false;
-	const struct sh_css_frame_info *info_a = &frame_a->info,
-	    *info_b = &frame_b->info;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_frame_equal_types() enter:\n");
-
-	if (!info_a || !info_b)
-		return false;
-	if (info_a->format != info_b->format)
-		return false;
-	if (info_a->padded_width != info_b->padded_width)
-		return false;
-	is_equal = sh_css_frame_info_equal_resolution(info_a, info_b);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_frame_equal_types() leave:\n");
-return is_equal;
-}
-
-static void
-append_firmware(struct sh_css_fw_info **l, struct sh_css_fw_info *firmware)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "append_firmware() enter:\n");
-	while (*l)
-		l = &(*l)->next;
-	*l = firmware;
-	firmware->next = NULL;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "append_firmware() leave:\n");
-}
-
-static void
-remove_firmware(struct sh_css_fw_info **l, struct sh_css_fw_info *firmware)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "remove_firmware() enter:\n");
-	while (*l && *l != firmware)
-		l = &(*l)->next;
-	if (!*l)
-		return;
-	*l = firmware->next;
-	firmware->next = NULL;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "remove_firmware() leave:\n");
-}
-
-/* Load firmware for acceleration */
-enum sh_css_err
-sh_css_load_acceleration(struct sh_css_acc_fw *firmware)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_load_acceleration() enter:\n");
-	err = sh_css_acc_load(firmware);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_load_acceleration() leave:\n");
-return err;
-}
-
-/* Unload firmware for acceleration */
-void
-sh_css_unload_acceleration(struct sh_css_acc_fw *firmware)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_unload_acceleration() enter:\n");
-	sh_css_acc_unload(firmware);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_unload_acceleration() leave:\n");
-}
-
-/* Load firmware for extension */
-enum sh_css_err
-sh_css_pipe_load_extension(struct sh_css_pipe *pipe,
-			   struct sh_css_fw_info *firmware)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_load_extension() enter:\n");
-	if (firmware->info.isp.type == SH_CSS_ACC_OUTPUT)
-		append_firmware(&pipe->output_stage, firmware);
-	else if (firmware->info.isp.type == SH_CSS_ACC_VIEWFINDER)
-		append_firmware(&pipe->vf_stage, firmware);
-	err = sh_css_acc_load_extension(firmware);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_load_extension() leave:\n");
-return err;
-}
-
-/* Unload firmware for extension */
-void
-sh_css_pipe_unload_extension(struct sh_css_pipe *pipe,
-			     struct sh_css_fw_info *firmware)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() enter:\n");
-	if (firmware->info.isp.type == SH_CSS_ACC_OUTPUT)
-		remove_firmware(&pipe->output_stage, firmware);
-	else if (firmware->info.isp.type == SH_CSS_ACC_VIEWFINDER)
-		remove_firmware(&pipe->vf_stage, firmware);
-	sh_css_acc_unload_extension(firmware);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() leave:\n");
-}
-
-/* Set acceleration parameter to value <val> */
-enum sh_css_err
-sh_css_set_acceleration_parameter(struct sh_css_acc_fw *firmware,
-				  hrt_vaddress val, size_t size)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_hmm_section par = { val, size };
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_acceleration_parameter() enter:\n");
-	err = sh_css_acc_set_parameter(firmware, par);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_acceleration_parameter() leave:\n");
-return err;
-}
-
-/* Set acceleration parameters to value <val> */
-enum sh_css_err
-sh_css_set_firmware_dmem_parameters(struct sh_css_fw_info *firmware,
-				    enum sh_css_isp_memories mem,
-				  hrt_vaddress val, size_t size)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_hmm_section par = { val, size };
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_firmware_dmem_parameters() enter:\n");
-	err = sh_css_acc_set_firmware_parameters(firmware, mem, par);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_firmware_dmem_parameters() leave:\n");
-return err;
-}
-
-/* Start acceleration of firmware with sp-args as SP arguments. */
-enum sh_css_err
-sh_css_start_acceleration(struct sh_css_acc_fw *firmware)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_start_acceleration() enter:\n");
-	my_css.curr_pipe = NULL;
-	err = sh_css_acc_start(firmware);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_start_acceleration() leave:\n");
-return err;
-}
-
-/* To be called when acceleration has terminated.
-*/
-void
-sh_css_acceleration_done(struct sh_css_acc_fw *firmware)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_acceleration_done() enter: firmware=%p\n", firmware);
-	sh_css_acc_wait();
-	sh_css_acc_done(firmware);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_acceleration_done() leave: return_void\n");
-}
-
-/* Abort acceleration within <deadline> microseconds
-*/
-void
-sh_css_abort_acceleration(struct sh_css_acc_fw *firmware, unsigned deadline)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_abort_acceleration() enter:\n");
-	/* TODO: implement time-out */
-	(void)deadline;
-	sh_css_acc_abort(firmware);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_abort_acceleration() leave:\n");
-}
-
-bool
-sh_css_pipe_uses_params(struct sh_css_pipeline *me)
-{
-	struct sh_css_pipeline_stage *stage;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipe_uses_params() enter: me=%p\n", me);
-
-	assert(me != NULL);
-	if (me == NULL)
-		return false;
-
-	for (stage = me->stages; stage; stage = stage->next)
-		if (stage->binary_info->enable.params) {
-			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-				"sh_css_pipe_uses_params() leave: "
-				"return_bool=true\n");
-			return true;
-		}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_pipe_uses_params() leave: return_bool=false\n");
-	return false;
-}
-
-/* Create a pipeline stage for firmware <isp_fw>
- * with input and output arguments.
-*/
-static enum sh_css_err sh_css_create_stage(
-	struct sh_css_pipeline_stage **stage,
-	const char *isp_fw,
-	struct sh_css_frame *in,
-	struct sh_css_frame *out,
-	struct sh_css_frame *vf)
-{
-	struct sh_css_binary *binary;
-	struct sh_css_blob_descr *blob;
-	struct sh_css_binary_info *info;
-	unsigned size;
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_create_stage() enter:\n");
-
-	assert(stage != NULL);
-	if (stage == NULL)
-		return sh_css_err_internal_error;
-
-	*stage = sh_css_malloc(sizeof(**stage));
-	if (*stage == NULL) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_create_stage() leave: return_err=%d\n",
-			sh_css_err_cannot_allocate_memory);
-		return sh_css_err_cannot_allocate_memory;
-	}
-
-	binary = sh_css_malloc(sizeof(*binary));
-	if (binary == NULL) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_create_stage() leave: return_err=%d\n",
-			sh_css_err_cannot_allocate_memory);
-		return sh_css_err_cannot_allocate_memory;
-	}
-
-	blob = sh_css_malloc(sizeof(*blob));
-	if (blob == NULL) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_create_stage() leave: return_err=%d\n",
-			sh_css_err_cannot_allocate_memory);
-		return sh_css_err_cannot_allocate_memory;
-	}
-
-	memset(&(*stage)->args, 0, sizeof((*stage)->args));
-	(*stage)->args.in_frame = in;
-	(*stage)->args.out_frame = out;
-	(*stage)->args.out_vf_frame = vf;
-
-	err = sh_css_load_blob_info(isp_fw, blob);
-	if (err != sh_css_success) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_create_stage() leave: return_err=%d\n",
-			err);
-		return err;
-	}
-	err = sh_css_fill_binary_info(&blob->header.info.isp, false, false,
-			    SH_CSS_INPUT_FORMAT_RAW_10,
-			    in  ? &in->info  : NULL,
-			    out ? &out->info : NULL,
-			    vf  ? &vf->info  : NULL,
-			    binary, false);
-	if (err != sh_css_success) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_create_stage() leave: return_err=%d\n",
-			err);
-		return err;
-	}
-	blob->header.info.isp.xmem_addr = 0;
-	size = blob->header.blob.size;
-	if (size) {
-		blob->header.info.isp.xmem_addr =
-			sh_css_load_blob(blob->blob, size);
-		if (!blob->header.info.isp.xmem_addr) {
-			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-				"sh_css_create_stage() leave: return_err=%d\n",
-				sh_css_err_cannot_allocate_memory);
-			return sh_css_err_cannot_allocate_memory;
-		}
-	}
-
-	info = (struct sh_css_binary_info *)binary->info;
-	info->blob = blob;
-	(*stage)->binary = binary;
-	(*stage)->binary_info = &blob->header.info.isp;
-	(*stage)->firmware = NULL;
-	(*stage)->mode = binary->info->mode;
-	(*stage)->out_frame_allocated = false;
-	(*stage)->vf_frame_allocated = false;
-	(*stage)->next = NULL;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_create_stage() leave: return_err=%d\n", err);
-
-	return err;
-}
-
-/* Append a new stage to *pipeline. When *pipeline is NULL, it will be created.
- * The stage consists of an ISP binary <isp_fw> and input and output arguments.
-*/
-enum sh_css_err sh_css_append_stage(
-	void **me,
-	const char *isp_fw,
-	struct sh_css_frame *in,
-	struct sh_css_frame *out,
-	struct sh_css_frame *vf)
-{
-	struct sh_css_pipeline **pipeline = (struct sh_css_pipeline **)me;
-	struct sh_css_pipeline_stage *stage;
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_append_stage() enter: "
-		"me=%p, isp_f%s, in=%p, out=%p, vf=%p\n",
-		me, isp_fw, in, out, vf);
-
-	if (!*pipeline) {
-		*pipeline = (struct sh_css_pipeline *)sh_css_create_pipeline();
-		if (*pipeline == NULL) {
-
-			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-				"sh_css_append_stage() leave: return_err=%d\n",
-				sh_css_err_cannot_allocate_memory);
-			return sh_css_err_cannot_allocate_memory;
-		}
-	}
-
-	err = sh_css_create_stage(&stage, isp_fw, in, out, vf);
-	if (err != sh_css_success) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_append_stage() leave: return_err=%d\n", err);
-
-		return err;
-	}
-
-	stage->stage_num = (*pipeline)->num_stages++;
-	if ((*pipeline)->current_stage)
-		(*pipeline)->current_stage->next = stage;
-	else
-		(*pipeline)->stages = stage;
-
-	(*pipeline)->current_stage = stage;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_append_stage() leave: return_err=%d\n", err);
-
-	return err;
-}
-
-/* #error return of function is not consistent with implementation */
-void *sh_css_create_pipeline(void)
-{
-	struct sh_css_pipeline *pipeline = sh_css_malloc(sizeof(struct sh_css_pipeline));
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_create_pipeline() enter:\n");
-
-	if (pipeline != NULL) {
-		pipeline->num_stages = 0;
-		pipeline->stages = NULL;
-		pipeline->current_stage = NULL;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_create_pipeline() leave: pipeline=%p\n", pipeline);
-return (void *)pipeline;
-}
-
-enum sh_css_err sh_css_pipeline_add_acc_stage(
-	void		*pipeline,
-	const void	*acc_fw)
-{
-	struct sh_css_fw_info *fw = (struct sh_css_fw_info *)acc_fw;
-	enum sh_css_err	err = sh_css_acc_load_extension(fw);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipeline_add_acc_stage() enter: pipeline=%p,"
-		" acc_fw=%p\n", pipeline, acc_fw);
-
-	if (err == sh_css_success) {
-		err = sh_css_pipeline_add_stage(
-			pipeline, NULL, fw,
-			SH_CSS_BINARY_MODE_VF_PP, NULL,
-			NULL, NULL,
-			NULL,NULL);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_pipeline_add_acc_stage() leave: return_err=%d\n",err);
-return err;
-}
-
-void sh_css_destroy_pipeline(
-	void		*pipeline)
-{
-	struct sh_css_pipeline *pipeline_loc = pipeline;
-	struct sh_css_pipeline_stage *stage, *next = NULL;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_destroy_pipeline() enter: pipeline=%p\n", pipeline);
-
-	for (stage = pipeline_loc->stages; (stage != NULL); stage = next) {
-		struct sh_css_fw_info *fw = (struct sh_css_fw_info *)stage->firmware;
-
-		next = stage->next;
-
-		sh_css_acc_unload_extension(fw);
-		sh_css_pipeline_stage_destroy(stage);
-	}
-	sh_css_free(pipeline_loc);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_destroy_pipeline() leave: return_void\n");
-return;
-}
-
-/* Run a pipeline and wait till it completes. */
-void
-sh_css_start_pipeline(enum sh_css_pipe_id pipe_id, void *me)
-{
-	struct sh_css_pipeline *pipeline = me;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_start_pipeline() enter: pipe_id=%d, me=%p\n",
-		pipe_id, me);
-	pipeline->pipe_id = pipe_id;
-	sh_css_sp_init_pipeline(pipeline, pipe_id,
-				false, true, false, false, false, true, false,
-				SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD);
-	if (sh_css_pipe_uses_params(pipeline)) {
-		sh_css_pipeline_stream_clear_pipelines();
-		sh_css_pipeline_stream_add_pipeline(pipeline);
-	}
-	sh_css_sp_start_isp();
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_start_pipeline() leave: return_void\n");
-}
-
-/* Run a pipeline and free all memory allocated to it. */
-void
-sh_css_close_pipeline(void *me)
-{
-	struct sh_css_pipeline *pipeline = me;
-	struct sh_css_pipeline_stage *stage;
-	struct sh_css_pipeline_stage *next;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_close_pipeline() enter: "
-		"pipeline=%p\n", pipeline);
-
-	for (stage = pipeline->stages; stage; stage = next) {
-		struct sh_css_blob_descr *blob;
-		next = stage->next;
-		blob = (struct sh_css_blob_descr *)stage->binary->info->blob;
-		if (blob->header.info.isp.xmem_addr)
-			mmgr_free(blob->header.info.isp.xmem_addr);
-		sh_css_free(blob);
-		sh_css_free(stage->binary);
-		sh_css_pipeline_stage_destroy(stage);
-	}
-	sh_css_free(pipeline);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_close_pipeline() leave: return_void\n");
-}
-
-/* Run an isp binary <isp_fw> with input, output and vf frames
-*/
-enum sh_css_err sh_css_run_isp_firmware(
-	const char *isp_fw,
-	struct sh_css_frame *in,
-	struct sh_css_frame *out,
-	struct sh_css_frame *vf)
-{
-	void *pipeline = NULL;
-	enum sh_css_err err;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_run_isp_firmware() enter: isp_fw=%p,"
-		" in=%p, out=%p, vf=%p\n", isp_fw,in, out, vf);
-
-	err = sh_css_append_stage(&pipeline, isp_fw, in, out, vf);
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_run_isp_firmware() leave: return_err=%d\n",err);
-		return err;
-	}
-	sh_css_start_pipeline(SH_CSS_ACC_PIPELINE, pipeline);
-	/* TODO: the following line must be changed if
-		someone want to use this function */
-	err = sh_css_wait_for_completion(SH_CSS_ACC_PIPELINE);
-	if (err != sh_css_success) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_run_isp_firmware() leave: return_err=%d\n",err);
-		return err;
-	}
-	sh_css_close_pipeline(pipeline);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_run_isp_firmware() leave: return_err=%d\n",err);
-	return err;
-}
-
-/**
- * @brief Query the SP thread ID.
- * Refer to "sh_css_internal.h" for details.
- */
-bool
-sh_css_query_sp_thread_id(enum sh_css_pipe_id key,
-		unsigned int *val)
-{
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_query_sp_thread_id() enter: key=%d\n", key);
-
-	assert(key < SH_CSS_NR_OF_PIPELINES);
-	if (key >= SH_CSS_NR_OF_PIPELINES)
-		return false;
-	assert(val != NULL);
-	if (val == NULL)
-		return false;
-
-	*val = sh_css_pipe_id_2_internal_thread_id[key];
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_query_sp_thread_id() leave: return_val=%d\n", *val);
-	return true;
-}
-
-/**
- * @brief Query the internal frame ID.
- * Refer to "sh_css_internal.h" for details.
- */
-bool sh_css_query_internal_queue_id(
-	enum sh_css_buffer_type key,
-	enum sh_css_buffer_queue_id *val)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_query_internal_queue_id() enter: key=%d\n", key);
-
-	assert(key < SH_CSS_BUFFER_TYPE_NR_OF_TYPES);
-	if (key >= SH_CSS_BUFFER_TYPE_NR_OF_TYPES)
-		return false;
-
-	assert(val != NULL);
-	if (val == NULL)
-		return false;
-
-	*val = sh_css_buf_type_2_internal_queue_id[key];
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_query_internal_queue_id() leave: return_val=%d\n",
-		*val);
-	return true;
-}
-
-/**
- * @brief Tag a specific frame in continuous capture.
- * Refer to "sh_css_internal.h" for details.
- */
-enum sh_css_err sh_css_offline_capture_tag_frame(
-	unsigned int exp_id)
-{
-	struct sh_css_tag_descr tag_descr;
-	unsigned int encoded_tag_descr;
-
-	bool enqueue_successful = false;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_offline_capture_tag_frame() enter: exp_id=%d\n",
-		exp_id);
-
-	if (exp_id == 0) {
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_offline_capture_tag_frame() "
-			"leave: return_err=%d\n",
-			sh_css_err_invalid_tag_description);
-		return sh_css_err_invalid_tag_description;
-	}
-
-	/* Create the tag descriptor from the parameters */
-	sh_css_create_tag_descr(0, 0, 0, exp_id, &tag_descr);
-
-
-	/* Encode the tag descriptor into a 32-bit value */
-	encoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);
-
-
-	/* Enqueue the encoded tag to the host2sp queue.
-	 * Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
-	 * on both host and the SP side.
-	 * It is mainly because it is enough to have only one tag_cmd queue */
-	enqueue_successful = host2sp_enqueue_buffer(0, 0,
-				sh_css_tag_cmd_queue,
-				(uint32_t)encoded_tag_descr);
-
-
-	/* Give an error if the tag command cannot be issued
-	 * (because the cmd queue is full) */
-	if (!enqueue_successful) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_offline_capture_tag_frame() leave: return_err=%d\n",
-		sh_css_err_tag_queue_is_full);
-		return sh_css_err_tag_queue_is_full;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_offline_capture_tag_frame() leave: return_err=%d\n",
-		sh_css_success);
-	return sh_css_success;
-}
-
-/**
- * @brief Configure the continuous capture.
- * Refer to "sh_css_internal.h" for details.
- */
-enum sh_css_err sh_css_offline_capture_configure(
-	int num_captures,
-	unsigned int skip,
-	int offset)
-{
-	struct sh_css_tag_descr tag_descr;
-	unsigned int encoded_tag_descr;
-
-	bool enqueue_successful = false;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_offline_capture_configure() enter: num_captures=%d,"
-		" skip=%d, offset=%d\n", num_captures, skip,offset);
-
-	/* Check if the tag descriptor is valid */
-	if (num_captures < SH_CSS_MINIMUM_TAG_ID) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_offline_capture_configure() leave: return_err=%d\n",
-		sh_css_err_invalid_tag_description);
-		return sh_css_err_invalid_tag_description;
-	}
-
-	/* Create the tag descriptor from the parameters */
-	sh_css_create_tag_descr(num_captures, skip, offset, 0, &tag_descr);
-
-
-	/* Encode the tag descriptor into a 32-bit value */
-	encoded_tag_descr = sh_css_encode_tag_descr(&tag_descr);
-
-
-	/* Enqueue the encoded tag to the host2sp queue.
-	 * Note: The pipe and stage IDs for tag_cmd queue are hard-coded to 0
-	 * on both host and the SP side.
-	 * It is mainly because it is enough to have only one tag_cmd queue */
-	enqueue_successful = host2sp_enqueue_buffer(0, 0,
-				sh_css_tag_cmd_queue,
-				(uint32_t)encoded_tag_descr);
-
-
-	/* Give an error if the tag command cannot be issued
-	 * (because the cmd queue is full) */
-	if (!enqueue_successful) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_offline_capture_configure() leave: return_err=%d\n",
-		sh_css_err_tag_queue_is_full);
-		return sh_css_err_tag_queue_is_full;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_offline_capture_configure() leave: return_err=%d\n",
-		sh_css_success);
-	return sh_css_success;
-}
-
-/* MW: This function does not invalidate the TLB, it sends an indicate to do so, better change the name */
-void sh_css_enable_sp_invalidate_tlb(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_invalidate_tlb;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_enable_sp_invalidate_tlb() enter: void\n");
-	HIVE_ADDR_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
-
-	(void)HIVE_ADDR_sp_invalidate_tlb; /* Suppres warnings in CRUN */
-
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_invalidate_tlb),
-		1);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_enable_sp_invalidate_tlb() leave: return_void\n");
-}
-
-void sh_css_request_flash(void)
-{
-	const struct sh_css_fw_info *fw= &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_request_flash;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_request_flash() enter: void\n");
-	HIVE_ADDR_sp_request_flash = fw->info.sp.request_flash;
-
-	(void)HIVE_ADDR_sp_request_flash;
-
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_request_flash),
-		1);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_request_flash() leave: return_void\n");
-}
-
-/* CSS 1.5 wrapper */
-enum sh_css_err
-sh_css_preview_stop(void)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_preview_stop() enter: void\n");
-	err = sh_css_pipe_stop(&my_css.preview_pipe);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_stop() leave: return_err=%d\n",err);
-return err;
-}
-
-enum sh_css_err
-sh_css_video_stop(void)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_video_stop() enter: void\n");
-	err = sh_css_pipe_stop(&my_css.video_pipe);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_stop() leave: return_err=%d\n",err);
-return err;
-}
-
-enum sh_css_err
-sh_css_capture_stop(void)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_capture_stop() enter: void\n");
-	err = sh_css_pipe_stop(&my_css.capture_pipe);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_stop() leave: return_err=%d\n",err);
-return err;
-}
-
-enum sh_css_err
-sh_css_acceleration_stop(void)
-{
-	enum sh_css_err err = sh_css_success;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_acceleration_stop() enter: void\n");
-	err = sh_css_pipeline_stop(SH_CSS_ACC_PIPELINE);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_acceleration_stop() leave: return_err=%d\n",err);
-return err;
-}
-
-void
-sh_css_capture_enable_online(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_enable_online() enter: enable=%d\n", enable);
-	sh_css_pipe_enable_online(&my_css.capture_pipe, enable);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_enable_online() leave: return_void\n");
-}
-
-void
-sh_css_video_set_enable_dz(bool enable_dz)
-{
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_set_enable_dz() enter: enable_dz=%d\n",enable_dz);
-	pipe->enable_dz = enable_dz;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_set_enable_dz() leave: return_void\n");
-}
-
-void
-sh_css_video_get_enable_dz(bool *enable_dz)
-{
-	struct sh_css_pipe *pipe = &my_css.video_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_enable_dz() enter: void\n");
-
-	if (enable_dz != NULL) {
-		*enable_dz = pipe->enable_dz;
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_video_get_enable_dz() leave: enable_dz=%d\n",
-			*enable_dz);
-	} else {
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_video_get_enable_dz() leave: "
-			"enable_dz=UNDEFINED (pipe has no DZ)\n");
-	}
-}
-
-enum sh_css_err sh_css_preview_configure_output(
-	unsigned int width, unsigned int height, unsigned int min_padded_width,
-	enum sh_css_frame_format format)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_configure_output() enter: "
-		"width=%d, height=%d, min_padded_width=%d, format=%d\n",
-		width, height, min_padded_width, format);
-
-	err = sh_css_pipe_configure_output(&my_css.preview_pipe, width,
-					   height, min_padded_width, format);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_configure_output() leave: return_err=%d\n",err);
-return err;
-}
-
-enum sh_css_err sh_css_capture_configure_output(
-	unsigned int width, unsigned int height, unsigned int min_padded_width,
-	enum sh_css_frame_format format)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_configure_output() enter: "
-		"width=%d, height=%d, min_padded_width=%d,  format=%d\n",
-		width, height, min_padded_width, format);
-
-	err = sh_css_pipe_configure_output(&my_css.capture_pipe, width,
-					   height, min_padded_width, format);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_configure_output() leave: return_err=%d\n",err);
-return err;
-}
-
-enum sh_css_err sh_css_video_configure_output(
-	unsigned int width, unsigned int height, unsigned int min_padded_width,
-	enum sh_css_frame_format format)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_configure_output() enter: "
-		"width=%d, height=%d, min_padded_width=%d, format=%d\n",
-		width, height, min_padded_width, format);
-
-	err = sh_css_pipe_configure_output(&my_css.video_pipe, width,
-					   height, min_padded_width, format);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_configure_output() leave: return_err=%d\n", err);
-return err;
-}
-
-enum sh_css_err sh_css_capture_get_output_frame_info(
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_output_frame_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_get_output_frame_info(&my_css.capture_pipe,
-						 info);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_output_frame_info() leave: "
-		"return_err=%d, "
-		"info.width=%d, info.height=%d, "
-		"info.padded_width=%d, info.format=%d, "
-		"info.raw_bit_depth=%d, info.raw_bayer_order=%d\n",
-		err,
-		info->width,info->height,
-		info->padded_width,info->format,
-		info->raw_bit_depth,info->raw_bayer_order);
-
-return err;
-}
-
-enum sh_css_err sh_css_preview_get_output_frame_info(
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_get_output_frame_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_get_output_frame_info(&my_css.preview_pipe,
-						 info);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_get_output_frame_info() leave: "
-		"return_err=%d, "
-		"info.width=%d, info.height=%d, "
-		"info.padded_width=%d, info.format=%d, "
-		"info.raw_bit_depth=%d, info.raw_bayer_order=%d\n",
-		err,
-		info->width,info->height,
-		info->padded_width,info->format,
-		info->raw_bit_depth,info->raw_bayer_order);
-
-return err;
-}
-
-enum sh_css_err sh_css_video_get_output_frame_info(
-	struct sh_css_frame_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_output_frame_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_get_output_frame_info(&my_css.video_pipe,
-						 info);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_output_frame_info() leave: "
-		"return_err=%d, "
-		"info.width=%d, info.height=%d, "
-		"info.padded_width=%d, info.format=%d, "
-		"info.raw_bit_depth=%d, info.raw_bayer_order=%d\n",
-		err,
-		info->width,info->height,
-		info->padded_width,info->format,
-		info->raw_bit_depth,info->raw_bayer_order);
-
-return err;
-}
-
-enum sh_css_err sh_css_preview_get_grid_info(
-	struct sh_css_grid_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_get_grid_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_get_grid_info(&my_css.preview_pipe,
-					 info);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_get_grid_info() leave: &info=%p\n", info);
-
-return err;
-}
-
-enum sh_css_err sh_css_video_get_grid_info(
-	struct sh_css_grid_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_grid_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_get_grid_info(&my_css.video_pipe,
-					 info);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_get_grid_info() leave: &info=%p\n", info);
-
-return err;
-}
-
-enum sh_css_err sh_css_capture_get_grid_info(
-	struct sh_css_grid_info *info)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_grid_info() enter: void\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return sh_css_err_internal_error;
-
-	err = sh_css_pipe_get_grid_info(&my_css.capture_pipe,
-					 info);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_capture_get_grid_info() leave: &info=%p\n", info);
-
-
-return err;
-}
-
-void
-sh_css_preview_enable_online(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_enable_online() enter: enable=%d\n", enable);
-
-	sh_css_pipe_enable_online(&my_css.preview_pipe, enable);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_preview_enable_online() leave: return_void\n");
-
-}
-
-void
-sh_css_video_enable_online(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_enable_online() enter: enable=%d\n", enable);
-
-	sh_css_pipe_enable_online(&my_css.video_pipe, enable);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_enable_online() leave: return_void\n");
-}
-
-void
-sh_css_input_set_channel(unsigned int channel_id)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_channel() enter: channel_id%d\n", channel_id);
-
-	sh_css_pipe_set_input_channel(&my_css.preview_pipe, channel_id);
-	sh_css_pipe_set_input_channel(&my_css.capture_pipe, channel_id);
-	sh_css_pipe_set_input_channel(&my_css.video_pipe, channel_id);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_channel() leave: return_void\n");
-}
-
-void
-sh_css_input_set_format(enum sh_css_input_format format)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_format() enter: format%d\n", format);
-
-	sh_css_debug_pipe_graph_dump_input_set_format(format);
-	sh_css_pipe_set_input_format(&my_css.preview_pipe, format);
-	sh_css_pipe_set_input_format(&my_css.video_pipe, format);
-	sh_css_pipe_set_input_format(&my_css.capture_pipe, format);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_format() leave: return_void\n");
-
-}
-
-void
-sh_css_input_get_format(enum sh_css_input_format *format)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_input_get_format() enter: void\n");
-
-	assert(format != NULL);
-	if (format == NULL)
-		return;
-
-	/* arbitrarily pick preview, they are all the same */
-	*format = sh_css_pipe_get_input_format(&my_css.preview_pipe);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_get_format() leave: format=%d\n", *format);
-}
-
-void
-sh_css_input_set_mode(enum sh_css_input_mode mode)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_mode() enter: mode=%d\n",
-		mode);
-
-	sh_css_pipe_set_input_mode(&my_css.preview_pipe, mode);
-	sh_css_pipe_set_input_mode(&my_css.video_pipe, mode);
-	sh_css_pipe_set_input_mode(&my_css.capture_pipe, mode);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_mode() leave: return_void\n");
-
-}
-
-void
-sh_css_input_set_two_pixels_per_clock(bool two_ppc)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_two_pixels_per_clock() enter: two_ppc=%d\n",
-		two_ppc);
-
-	sh_css_pipe_set_two_pixels_per_clock(&my_css.preview_pipe, two_ppc);
-	sh_css_pipe_set_two_pixels_per_clock(&my_css.video_pipe, two_ppc);
-	sh_css_pipe_set_two_pixels_per_clock(&my_css.capture_pipe, two_ppc);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_two_pixels_per_clock() leave: return_void\n");
-}
-
-void
-sh_css_input_get_two_pixels_per_clock(bool *two_ppc)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_get_two_pixels_per_clock() enter: void\n");
-
-	assert(two_ppc != NULL);
-	if (two_ppc == NULL)
-		return;
-
-	*two_ppc = sh_css_pipe_get_two_pixels_per_clock(&my_css.preview_pipe);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_get_two_pixels_per_clock() leave: two_ppc=%d\n",
-		*two_ppc);
-}
-
-void
-sh_css_input_set_bayer_order(enum sh_css_bayer_order bayer_order)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_bayer_order() enter: "
-		"bayer_order=%d\n", bayer_order);
-
-	sh_css_pipe_set_input_bayer_order(&my_css.preview_pipe, bayer_order);
-	sh_css_pipe_set_input_bayer_order(&my_css.video_pipe, bayer_order);
-	sh_css_pipe_set_input_bayer_order(&my_css.capture_pipe, bayer_order);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_bayer_order() leave: return_void\n");
-}
-
-void
-sh_css_get_extra_pixels_count(int *extra_rows, int *extra_cols)
-{
-	/* arbitrarily pick preview */
-	struct sh_css_pipe *pipe = &my_css.preview_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_extra_pixels_count() enter: void\n");
-
-	assert(extra_rows != NULL);
-	if (extra_rows == NULL)
-		return;
-
-	assert(extra_cols != NULL);
-	if (extra_cols == NULL)
-		return;
-
-	sh_css_pipe_get_extra_pixels_count(pipe, extra_rows, extra_cols);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_extra_pixels_count() leave: "
-		"extra_rows=%d, extra_cols=%d\n", *extra_rows, *extra_cols);
-}
-
-void
-sh_css_disable_vf_pp(bool disable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_disable_vf_pp() enter: disable=%d\n", disable);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_disable_vf_pp()\n");
-	sh_css_pipe_disable_vf_pp(&my_css.preview_pipe, disable);
-	sh_css_pipe_disable_vf_pp(&my_css.video_pipe, disable);
-	sh_css_pipe_disable_vf_pp(&my_css.capture_pipe, disable);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_disable_vf_pp() leave: return_void\n");
-}
-
-void
-sh_css_enable_raw_binning(bool enable)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_enable_raw_binning() enter: enable=%d\n", enable);
-	sh_css_pipe_enable_raw_binning(&my_css.preview_pipe, enable);
-	sh_css_pipe_enable_raw_binning(&my_css.video_pipe, enable);
-	sh_css_pipe_enable_raw_binning(&my_css.capture_pipe, enable);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_enable_raw_binning() leave: return_void\n");
-
-}
-
-enum sh_css_err
-sh_css_input_configure_port(const mipi_port_ID_t port,
-			    const unsigned int	 num_lanes,
-			    const unsigned int	 timeout)
-{
-	enum sh_css_err err;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_configure_port() enter: "
-		"port=%d, ""num_lanes=%d, timeout=%d\n",
-		port, num_lanes, timeout);
-
-	/* if one fails, all fail, so just check the last result */
-	sh_css_pipe_configure_input_port(&my_css.preview_pipe, port,
-					 num_lanes, timeout);
-	sh_css_pipe_configure_input_port(&my_css.capture_pipe, port,
-					 num_lanes, timeout);
-	err = sh_css_pipe_configure_input_port(&my_css.video_pipe, port,
-					 num_lanes, timeout);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_configure_port() leave: return_err=%d\n",err);
-	return err;
-}
-
-enum sh_css_err
-sh_css_input_set_compression(const mipi_predictor_t comp,
-			     const unsigned int     compressed_bits_per_pixel,
-			     const unsigned int     uncompressed_bits_per_pixel)
-{
-	enum sh_css_err err;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_compression() enter: "
-		"comp=%d, ""comp_bpp=%d, uncomp_bpp=%d\n",
-		comp, compressed_bits_per_pixel, uncompressed_bits_per_pixel);
-
-	/* if one fails, all fail, so just check the last result */
-	sh_css_pipe_set_compression(&my_css.preview_pipe, comp,
-				    compressed_bits_per_pixel,
-				    uncompressed_bits_per_pixel);
-	sh_css_pipe_set_compression(&my_css.video_pipe, comp,
-				    compressed_bits_per_pixel,
-				    uncompressed_bits_per_pixel);
-	err = sh_css_pipe_set_compression(&my_css.capture_pipe, comp,
-				    compressed_bits_per_pixel,
-				    uncompressed_bits_per_pixel);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_compression() leave: return_err=%d\n",err);
-
-	return err;
-
-}
-
-enum sh_css_err sh_css_load_extension(
-	struct sh_css_fw_info	*fw,
-	enum sh_css_pipe_id		pipe_id,
-	enum sh_css_acc_type	acc_type)
-{
-	enum sh_css_err err;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_load_extension() enter: "
-		"fw=%p, pipe_id=%d, acc_type=%d\n",fw, pipe_id, acc_type);
-
-	assert(fw != NULL);
-	if (fw == NULL)
-		return sh_css_err_internal_error;
-
-	assert(pipe_id < SH_CSS_NR_OF_PIPELINES);
-	if (pipe_id >= SH_CSS_NR_OF_PIPELINES)
-		return sh_css_err_internal_error;
-
-	assert((acc_type == SH_CSS_ACC_OUTPUT) ||
-			(acc_type == SH_CSS_ACC_VIEWFINDER));
-
-/* MW: Legacy from CSS 1.0, where the acc_type was encoded on FW creation; set */
-	fw->info.isp.type = acc_type;
-
-	switch (pipe_id) {
-		case  SH_CSS_PREVIEW_PIPELINE:
-			err = sh_css_pipe_load_extension(&my_css.preview_pipe, fw);
-		break;
-		case  SH_CSS_COPY_PIPELINE:
-			err = sh_css_err_not_implemented;
-		break;
-		case  SH_CSS_VIDEO_PIPELINE:
-			err = sh_css_pipe_load_extension(&my_css.video_pipe, fw);
-		break;
-		case  SH_CSS_CAPTURE_PIPELINE:
-			err = sh_css_pipe_load_extension(&my_css.capture_pipe, fw);
-		break;
-		default:
-			err = sh_css_err_not_implemented;
-		break;
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_load_extension() leave: return_err=%d\n",err);
-return err;
-}
-
-enum sh_css_err sh_css_unload_extension(
-	struct sh_css_fw_info	*fw,
-	enum sh_css_pipe_id		pipe_id)
-{
-	enum sh_css_err err = sh_css_success;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_unload_extension() enter: fw=%p, pipe_id=%d\n", fw, pipe_id);
-
-	assert(fw != NULL);
-	if (fw == NULL)
-		return sh_css_err_internal_error;
-
-	assert(pipe_id < SH_CSS_NR_OF_PIPELINES);
-	if (pipe_id >= SH_CSS_NR_OF_PIPELINES)
-		return sh_css_err_internal_error;
-
-	switch (pipe_id) {
-		case  SH_CSS_PREVIEW_PIPELINE:
-			sh_css_pipe_unload_extension(&my_css.preview_pipe, fw);
-		break;
-		case  SH_CSS_COPY_PIPELINE:
-			err = sh_css_err_not_implemented;
-		break;
-		case  SH_CSS_VIDEO_PIPELINE:
-			sh_css_pipe_unload_extension(&my_css.video_pipe, fw);
-		break;
-		case  SH_CSS_CAPTURE_PIPELINE:
-			sh_css_pipe_unload_extension(&my_css.capture_pipe, fw);
-		break;
-		default:
-			err = sh_css_err_not_implemented;
-		break;
-	}
-
-/* MW: Legacy from CSS 1.0, where the acc_type was encoded on FW creation; rst */
-	fw->info.isp.type = SH_CSS_ACC_NONE;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_unload_extension() leave: return_err=%d\n",err);
-return err;
-}
-
-enum sh_css_err
-sh_css_input_set_effective_resolution(unsigned int width, unsigned int height)
-{
-	enum sh_css_err err;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_effective_resolution() "
-		"enter: width=%d, height=%d\n",width, height);
-	sh_css_debug_pipe_graph_dump_input_set_effective_resolution(width, height);
-	sh_css_pipe_set_effective_input_resolution(&my_css.preview_pipe, width, height);
-	sh_css_pipe_set_effective_input_resolution(&my_css.video_pipe, width, height);
-	err = sh_css_pipe_set_effective_input_resolution(&my_css.capture_pipe, width, height);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_effective_resolution() "
-		"leave: return_err=%d\n",err);
-	return err;
-}
-
-enum sh_css_err
-sh_css_input_set_resolution(unsigned int width, unsigned int height)
-{
-	enum sh_css_err err;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_resolution() enter: width=%d, height=%d\n",
-		width, height);
-	sh_css_debug_pipe_graph_dump_input_set_resolution(width, height);
-	sh_css_pipe_set_input_resolution(&my_css.preview_pipe, width, height);
-	sh_css_pipe_set_input_resolution(&my_css.video_pipe, width, height);
-	err = sh_css_pipe_set_input_resolution(&my_css.capture_pipe, width, height);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_input_set_resolution() leave: return_err=%d\n",err);
-	return err;
-}
-
-void
-sh_css_video_set_isp_pipe_version(unsigned int version)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_set_isp_pipe_version() enter: version=%d\n",
-		version);
-	my_css.video_pipe.isp_pipe_version = version;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_set_isp_pipe_version() leave: return=void\n");
-}
-
-enum sh_css_err
-sh_css_event_set_irq_mask(
-	enum sh_css_pipe_id pipe_id,
-	unsigned int or_mask,
-	unsigned int and_mask)
-{
-	my_css.sp_irq_mask[pipe_id].or_mask = or_mask;
-	my_css.sp_irq_mask[pipe_id].and_mask = and_mask;
-
-	return sh_css_success;
-}
-
-enum sh_css_err
-sh_css_event_get_irq_mask(
-	enum sh_css_pipe_id pipe_id,
-	unsigned int *or_mask,
-	unsigned int *and_mask)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-	unsigned int offset;
-	struct sh_css_event_irq_mask event_irq_mask;
-
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_event_get_irq_mask()\n");
-
-	assert(SH_CSS_NR_OF_PIPELINES == NR_OF_PIPELINES);
-	assert(pipe_id < SH_CSS_NR_OF_PIPELINES);
-	if (pipe_id >= SH_CSS_NR_OF_PIPELINES)
-		return sh_css_err_internal_error;
-
-	offset = offsetof(struct host_sp_communication,
-					host2sp_event_irq_mask[pipe_id]);
-	assert(offset % HRT_BUS_BYTES == 0);
-	sp_dmem_load(SP0_ID,
-		(unsigned int)sp_address_of(host_sp_com) + offset,
-		&event_irq_mask, sizeof(event_irq_mask));
-
-	if (or_mask)
-		*or_mask = event_irq_mask.or_mask;
-
-	if (and_mask)
-		*and_mask = event_irq_mask.and_mask;
-
-	return sh_css_success;
-}
-
-void
-sh_css_event_init_irq_mask(void)
-{
-	int i;
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-	unsigned int offset;
-
-
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-
-	/*assert(sizeof(event_irq_mask_init) % HRT_BUS_BYTES == 0);*/
-	for (i = 0; i < SH_CSS_NR_OF_PIPELINES; i++) {
-		offset = offsetof(struct host_sp_communication,
-						host2sp_event_irq_mask[i]);
-		assert(offset % HRT_BUS_BYTES == 0);
-		sp_dmem_store(SP0_ID,
-			(unsigned int)sp_address_of(host_sp_com) + offset,
-			&my_css.sp_irq_mask[i], sizeof(struct sh_css_event_irq_mask));
-	}
-
-}
-
-void
-sh_css_init_host_sp_control_vars(void)
-{
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_sp_isp_started;
-
-	unsigned int HIVE_ADDR_host_sp_queues_initialized;
-	unsigned int HIVE_ADDR_sp_sleep_mode;
-	unsigned int HIVE_ADDR_sp_invalidate_tlb;
-	unsigned int HIVE_ADDR_sp_request_flash;
-	unsigned int HIVE_ADDR_sp_stop_copy_preview;
-	unsigned int HIVE_ADDR_sp_copy_pack;
-	unsigned int HIVE_ADDR_host_sp_com;
-	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
-				/ sizeof(int);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_init_host_sp_control_vars() enter:\n");
-
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_sp_isp_started = fw->info.sp.isp_started;
-
-	HIVE_ADDR_host_sp_queues_initialized =
-		fw->info.sp.host_sp_queues_initialized;
-	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
-	HIVE_ADDR_sp_invalidate_tlb = fw->info.sp.invalidate_tlb;
-	HIVE_ADDR_sp_request_flash = fw->info.sp.request_flash;
-	HIVE_ADDR_sp_stop_copy_preview = fw->info.sp.stop_copy_preview;
-	HIVE_ADDR_sp_copy_pack = fw->info.sp.copy_pack;
-	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-
-	(void)HIVE_ADDR_sp_isp_started; /* Suppres warnings in CRUN */
-
-	(void)HIVE_ADDR_sp_sleep_mode;
-	(void)HIVE_ADDR_sp_invalidate_tlb;
-	(void)HIVE_ADDR_sp_request_flash;
-	(void)HIVE_ADDR_sp_stop_copy_preview;
-	(void)HIVE_ADDR_sp_copy_pack;
-	(void)HIVE_ADDR_host_sp_com;
-
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_isp_started),
-		(uint32_t)(0));
-
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(host_sp_queues_initialized),
-		(uint32_t)(0));
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_sleep_mode),
-		(uint32_t)(0));
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_invalidate_tlb),
-		(uint32_t)(0));
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_request_flash),
-		(uint32_t)(0));
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_stop_copy_preview),
-		my_css.stop_copy_preview?(uint32_t)(1):(uint32_t)(0));
-	store_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);
-
-	sh_css_event_init_irq_mask();
-	if (my_css.continuous) {
-		int i;
-		struct sh_css_pipe *pipe = &my_css.preview_pipe;
-		sh_css_update_host2sp_cont_num_raw_frames
-			(NUM_OFFLINE_INIT_CONTINUOUS_FRAMES, true);
-		sh_css_update_host2sp_cont_num_raw_frames
-			(my_css.num_cont_raw_frames, false);
-		if (pipe->mode == SH_CSS_PREVIEW_PIPELINE)
-			for (i = 0; i < NUM_OFFLINE_INIT_CONTINUOUS_FRAMES; i++) {
-				sh_css_update_host2sp_offline_frame(i,
-					pipe->pipe.preview.continuous_frames[i]);
-			}
-#if 0
-		else if (pipe->mode == SH_CSS_CAPTURE_PIPELINE)
-			for (i = 0; i < NUM_CONTINUOUS_FRAMES; i++) {
-				sh_css_update_host2sp_offline_frame(i,
-					pipe->pipe.capture.continuous_frames[i]);
-			}
-#endif
-	}
-	if (my_css.continuous && (my_css.curr_state != sh_css_state_executing_sp_bin_copy)) {
-		sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_copy_pack),
-		(uint32_t)(1));
-	} else {
-		sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_copy_pack),
-		(uint32_t)(0));
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_init_host_sp_control_vars() leave: return_void\n");
-}
-
-enum sh_css_err
-sh_css_allocate_continuous_frames(
-	bool init_time)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_frame_info ref_info;
-	struct sh_css_pipe *pipe = &my_css.preview_pipe;
-	bool input_needs_raw_binning = pipe->input_needs_raw_binning;
-	unsigned int i, idx;
-	unsigned int left_cropping, top_cropping;
-	unsigned int num_frames;
-	left_cropping = pipe->pipe.preview.preview_binary.info->left_cropping;
-	top_cropping = pipe->pipe.preview.preview_binary.info->top_cropping;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_allocate_continuous_frames() enter: init_time=%d\n", init_time);
-
-	if (my_css.continuous) {
-		if (init_time)
-			num_frames = NUM_OFFLINE_INIT_CONTINUOUS_FRAMES;
-		else
-			num_frames = my_css.num_cont_raw_frames;
-	} else {
-		num_frames = NUM_ONLINE_INIT_CONTINUOUS_FRAMES;
-	}
-
-	ref_info = pipe->pipe.preview.preview_binary.in_frame_info;
-	if (input_needs_raw_binning &&
-	    pipe->pipe.preview.preview_binary.info->enable.raw_binning) {
-		/* TODO: Remove this when the decimated
-		 * resolution is available */
-		/* Only for continuous preview mode
-		 * where we need 2xOut resolution */
-		ref_info.padded_width *= 2;
-		ref_info.width -= left_cropping;
-		ref_info.width *= 2;
-		/* In case of left-cropping, add 2 vectors */
-		ref_info.width += left_cropping ? 2*ISP_VEC_NELEMS : 0;
-		/* Must be even amount of vectors */
-		ref_info.width  = CEIL_MUL(ref_info.width,2*ISP_VEC_NELEMS);
-		ref_info.height -= top_cropping;
-		ref_info.height *= 2;
-		ref_info.height += top_cropping;
-	} else if (my_css.continuous) {
-		ref_info.width -= left_cropping;
-		/* In case of left-cropping, add 2 vectors */
-		ref_info.width += left_cropping ? 2*ISP_VEC_NELEMS : 0;
-		/* Must be even amount of vectors */
-		ref_info.width  = CEIL_MUL(ref_info.width,2*ISP_VEC_NELEMS);
-	}
-
-	ref_info.format = SH_CSS_FRAME_FORMAT_RAW;
-
-	if (init_time)
-		idx = 0;
-	else
-		idx = NUM_OFFLINE_INIT_CONTINUOUS_FRAMES;
-	for (i = idx; i < NUM_CONTINUOUS_FRAMES; i++) {
-		/* free previous frame */
-		if (pipe->pipe.preview.continuous_frames[i]) {
-			sh_css_frame_free(pipe->pipe.preview.continuous_frames[i]);
-			pipe->pipe.preview.continuous_frames[i] = NULL;
-		}
-		/* check if new frame needed */
-		if (i < num_frames) {
-			/* allocate new frame */
-			err = sh_css_frame_allocate_from_info(
-				&pipe->pipe.preview.continuous_frames[i],
-				&ref_info);
-			if (err != sh_css_success)
-				return err;
-		}
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_allocate_continuous_frames() leave: return success\n");
-	return sh_css_success;
-}
-
-void
-sh_css_update_continuous_frames(void)
-{
-	struct sh_css_pipe *pipe = &my_css.preview_pipe;
-	unsigned int i;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_update_continuous_frames() enter:\n");
-
-	for (i = NUM_OFFLINE_INIT_CONTINUOUS_FRAMES; i < my_css.num_cont_raw_frames; i++) {
-		sh_css_update_host2sp_offline_frame(i,
-				pipe->pipe.preview.continuous_frames[i]);
-	}
-	sh_css_update_host2sp_cont_num_raw_frames
-			(my_css.num_cont_raw_frames, true);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_update_continuous_frames() leave: return_void\n");
-}
-
-void
-sh_css_set_cont_prev_start_time(unsigned int overlap)
-{
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_sp_copy_preview_overlap;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_cont_prev_start_time() enter:\n");
-
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_sp_copy_preview_overlap = fw->info.sp.copy_preview_overlap;
-
-	(void)HIVE_ADDR_sp_copy_preview_overlap;
-
-	overlap = overlap/4; /* we request 4 lines each time in copy pipe */
-
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_copy_preview_overlap),
-		(uint32_t)(overlap));
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.h
deleted file mode 100644
index e140cb4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css.h
+++ /dev/null
@@ -1,2569 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-/*! \file */
-
-/*! \mainpage Introduction
-This document describes the API that controls the software that is part of the
- HiveGo CSS 3016 series Camera System Solution. We will refer to this API as
- the CSS API.
-Silicon Hive also provides a 3A library which comes with its own APIs; these
- will be described in a separate document.
-This camera subsystem consists of 2 parts, the hardware subsystem and the
- software stack that implements the ISP functionality on top of this hardware.
- In this chapter we introduce both briefly. For more detailed information about
- the hardware or ISP features we refer to the ISP Datasheet.
-
-\section css_hw_sec CSS Hardware
-The following is a block diagram of the CSS hardware.
-\image latex doc_hiveblockdia.png "HiveGo CSS 3016 Block Diagram" width=16cm
-This diagram shows the following hardware blocks.
-
-\subsection css_hw_isp_sec ISP2300 Vector Processor
-This is a fully programmable 10 issue slot VLIW processor. Of these 10 issue
- slots, 9 are vector issue slots which contain 64-way vector (SIMD) operations.
- This processor is where all the ISP processing is implemented. Each ISP mode
- is implemented as one or more executables which run on this processor. This
- processor has local memory which is used as a line buffer. This memory can be
- access by the input formatters, DMA, GDC and Scalar Processor (SP).
-\subsection css_hw_sp_sec Scalar Processor
-The Scalar Processor (SP) is a control processor with a very small silicon
- footprint. It is used to program the subsystem. Next to full access to the
- local configuration bus this processor also has direct connections to several
- other blocks in the subsystem such as input formatters, DMA and GDC engine.
- Typically, this processor is used as a micro controller to hide hardware
- details from the host CPU code. It can also be used to offload control
- oriented tasks from the ISP.
-\subsection css_hw_mipi_sec MIPI CSI2 Receiver
-This is a hardwired MIPI CSI2 receiver. It is capable of receiving MIPI CSI2
- data streams via its 1lane or 4lane CSI2 ports. CSI2 decompression has been
- implemented here. The output of this receiver gets sent to one or more input
- formatters.
-\subsection css_hw_if_sec Input Formatters
-There are 3 input formatters in the subsystem. These input formatters convert a
- stream of incoming pixels into lines of pixel data in the ISP (vector) memory.
- These input formatters can be programmed via their control slave ports. This
- can be done either from the Scalar Processor or from the host CPU.
-\subsection css_hw_dma_sec DMA
-The DMA in the CSS subsystem is used to transfer large amounts of data such as
- input and output image data or large parameter sets. This DMA can be configured
- by the ISP or SP and has support for sign and zero extension while transferring
- data.
-\subsection css_hw_mmu_sec MMU
-The CSS subsystem contains an MMU to access external memory. This allows us to
- share page tables with the host CPU OS. The MMU is programmed by the host OS
- after memory has been allocated. It has 2 registers: one to set the L1 page
- table base address and one to invalidate the TLB inside the MMU.
- DEPRECATED: MMU programming is an HRT abckend function outside the scope of CSS
-\subsection css_hw_gdc_sec GDC / Scaling Accelerator
-Commonly referred to as "GDC block" this hardwired accelerator can perform
- the following functionality:
--# Scaling (upscaling, downscaling, digital zoom).
--# Geometric Distortion and Chromatic Abberation Correction.
-This block is configured via its 32 bit slave port as well as the FIFO based
- connection with the ISP and SP.
-\section css_sw_sec CSS Software
-On top of the fully programmable CSS subsystem, we created an ISP software
- stack.
-\subsection css_sw_isp_sec System integration
-The CSS software is split into FW running on the ISP sub-system and a stub
-on a (remote)host. The CSS API is the interface of the stub to the driver
-the CSS DLI connects it to the FW. Since the stub can be integrated on different
-systems. the connectivity to the ISP sub-system is not known. The integrator is
-responsible for providing the connectivity functions, known as HRT backend
-there are four HRT backend functions
--# Device access, the CSS assumes an interface as defined in "device_access.h"
--# Memory access, the CSS assumes an interface as defined in "memory_access.h"
--# Program load and start control. Undefined
--# Threads. Undefined
-\subsection css_sw_isp_sec ISP Modes
-This software ISP provides the following features:
--# Preview mode: a low-power movie mode used for preview. This produces one
- output stream of up to 720p resolution. This output stream is typically
- displayed on the LCD to represent the viewfinder.
--# Still capture modes: we provide 3 still capture modes. Each mode outputs
- 2 data streams, one for the viewfinder (sometimes referred to as post-view)
- and one for the full resolution captures.
-  -# Raw/YUV capture. In this mode, we capture the sensor output data directly
-  to external memory, without any processing. This can be applied to RAW bayer
-  data, YUV data and RGB data. In this mode we do provide some format
-  conversions such as YUYV to YUV420 where data is only rearranged, not
-  processed.
-  -# Primary capture. This is the main still image capture mode. This mode
-  contains image enhancement features especially selected for still capture.
-  -# Advanced capture. This more advanced still capture mode contains the same
-  features as the primary capture mode plus more advanced features such as
-  Geometric Distortion and Chromatic Aberration Correction (GDCAC), support
-  for Digital Image Stabilization (DIS) and Multi-Axis Color Correction (MACC).
--# Video capture mode: this mode is an enhanced version of the preview mode.
- It produces 2 output streams (viewfinder and full resolution output) and
- supports a capture resolution of up to 1080p. In addition to the features
- contained in the preview mode, it supports Temporal Noise Reduction (TNR)
- , Digital Video Stabilization (DVS) and other video specific ISP optimizations.
-All modes support Digital Zoom, implemented on the GDC accelerator block and a
- range of ISP parameters to fine tune functionality such as edge enhancement,
- noise reduction, black level compensation and more.
-\subsection css_sw_ctrl_sec Control Flow
-Under normal circumstances, the ISP processes streaming input data (coming from
- a MIPI CSI2 compatible image sensor) and writes the output to a frame buffer in
- DDR. The following steps are taken to start this process:
--# The atomisp driver configures the CSS API regarding mode of operation, output
- resolution, data formats and parameters.
--# The atomisp driver starts the CSS API and then waits for interrupts. This is
- done for each frame.
--# The CSS API configures the CSS hardware and firmware by writing into
- registers and the SP data memory respectively.
--# The CSS API starts the SP by writing the start and run bits into its
- status & control register.
--# The SP firmware configures the rest of the CSS hardware and uses the DMA
- to download the ISP executable. Then it configures the ISP firmware by writing
- into the ISP data memory and starts the ISP processor.
--# While the ISP executes the firmware, the SP is used as a DMA proxy. The main
- reason for this is to save on the number of program instructions needed by the
- ISP firmware. The ISP has a local program memory of only 2048 instructions
- which means we can only execute a limited amount of code from this program
- memory. Configuring the DMA takes quite a number of instructions; by executing
- these from the SP we save program memory on the ISP.
--# While executing, the ISP continuously requests input data from the input
- formatter, processes this and requests the DMA to write the output data to
- external memory.
--# When the ISP is done processing the frame, it sends a stop token to the SP
- firmware. The SP then exits from its main function which brings the SP into
- the idle state. When this state transition occurs, the SP generates an
- interrupt which is handled on the host CPU.
--# The interrupt handler on the host CPU asks the CSS API what to do next. For
- certain modes, we need to execute multiple ISP executables in a row. When this
- is the case, the CSS API will tell the interrupt handler to start the next
- stage. This next stage is executed in the same way as the first one, just with
- a different ISP executable.
--# When the CSS API tells the interrupt handler that the frame is done (after
- all stages have been executed), the atomisp driver can send the output frame
- back to the application.
-\subsection css_sw_data_sec Data Flow
-The data flow depends on the mode of operation. In general though, we can say
- that the sensor output stream is stripped from all CSI markers and only the
- pixel data is sent to the input formatter(s). The input formatter converts the
- incoming stream into vectors (ISP SIMD words) and writes these vectors into the
- ISP vector memory.
-The ISP receives a signal (token) from the input formatter and reads the new
- input data from its local vector memory into registers. The content of these
- registers is subsequently modified by instructions in the ISP data path. At
- the end of the processing cycle, the processed pixels are written to a second
- buffer in the same local vector memory. The DMA is then instructed to send this
- output data into external memory (into a buffer allocated on the host CPU).
-In certain cases, this output data is then loaded from external memory by the
- application where it is displayed, encoded, processed or written to file.
-In other cases, this data is further processed by other ISP executables. ISP
- executables that read input data from memory rather than from the CSI receiver
- are referred to as offline executables (or offline binaries).
-\subsection css_sw_preview_sec Preview Mode
-When running the ISP in preview mode, we execute 2 stages for each frame.
--# Preview stage: this does all line based image processing and writes the
- output frame to external memory. The input is acquired from the input
- formatter(s).
--# Vf_pp stage: this stage performs downscaling, digital zoom and format
- conversions. Since these are block based operations, implemented
- on the GDC block, we cannot combine it with the online line based image
- processing.
-\section css_video_sec Video Mode
-The video mode also consists of 2 stages:
--# Video stage. Similar to the preview stage in the preview mode, this stage
- performs line based image processing (including bayer downscaling when
- enabled). During this stage, the previous frame is read as a reference frame
- for temporal noise reduction. The input data is acquired from the input
- formatter(s) and the output frame is written to external memory. Since the
- reference frame must be created before digital zoom, this stage writes out
- 2 frames, one is the output frame (possibly zoomed) and the other is the
- reference frame for the next run.
--# Vf_pp stage: this performs the same tasks as the vf_pp stage in the preview
- mode.
-\section css_stillcap_sec Still Capture Mode
-Here we distinguish 3 types.
-\subsection css_stillcap_raw_sec RAW Capture
-This mode captures RAW data from the sensor output to external memory. The only
- processing done here is re-ordering of pixels (for example to convert from
- yuv420 input data to nv12 output data). We only execute one stage in this mode
- which performs all processing necessary. Input is read from the input
- formatter(s) and output is written to external memory. This mode also produces
- a viewfinder output frame.
-\subsection css_stillcap_primary_sec Primary Capture
-In primary capture mode, we execute 2 or 3 stages, depending on which
- functionality is enabled:
--# Primary stage: this runs all line based image processing on input from either
- memory or the input formatter(s). This can be determined at runtime and is used
- to provide RAW+JPEG functionality where we capture both the RAW bayer
- frame and a processed YUV frame which is subsequently encoded to JPEG.
--# Capture_pp stage: this stage performs post-processing on the capture frame.
- This includes XNR, digital zoom and YUV downscaling. This stage is only
- executed when one or more of these features are enabled.
--# Vf_pp stage: this performs the same tasks as the vf_pp in preview and video
- mode.
-\subsection css_stillcap_advanced_sec Advanced Capture
-The advanced capture mode adds GDCAC capabilities. This is a block based
- algorithm which means we need additional stages.
--# Copy stage: this captures the RAW input data from the input formatter(s) into
- external memory.
--# Pre-GDC stage: this implements all line based image processing that needs to
- be done before the GDCAC stage.
--# GDC stage: this stage executes the GDCAC functionality on the
- GDC accelerator. It reads input data from external memory and writes output
- data back to external memory.
--# Post-GDC stage: this contains all line-based image processing that needs to
- be done after the GDCAC stage.
--# Capture_pp stage: this stage performs post-processing on the capture frame.
- This includes XNR, digital zoom and YUV downscaling. This stage is only
- executed when one or more of these features are enabled.
--# Vf_pp stage: this performs the same tasks as the vf_pp in preview and video
- mode.
- */
-
-/*! \page css_intro API Introduction
-\section css_intro_overview_sec Overview
-The CSS API contains functions to control all software running on the CSS
- hardware. This software implements all features commonly found in a digital
- camera: preview, still capture and video capture.
-This document is organized as follows:
-- Common Data Types and Functions
-- Preview
-- Still Capture
-- Video Capture
-- ISP Parameters
-- Example Applications
-- API Reference
-
-\section css_intro_versioning_sec Versioning
-The API version is also embedded in the API header file. It is advised that
- applications check against this version such that version changes are
- automatically detected. Especially since the API is still in beta phase,
- differences between versions can be significant. It is also advised to check
- the version of this document against the actual API version in the header file,
- both should match.
-\section css_intro_conventions_sec Notational Conventions
-This document contains numerous code snippets and examples, all of these are
- printed like this:
-\code
-enum sh_css_err sh_css_preview_start(struct sh_css_frame *output_frame);
-\endcode
-When showing declarations that are part of the API, the declared symbol (type or
- function) will be printed in bold (as shown here for the function
- ::sh_css_preview_start).
-\section css_intro_reference_sec API Reference
-Each section will explain the use of several types and/or functions, the
- reference documentation for these is included at the end of each section. For
- each function, the prototype is shown, followed by the explanation of the
- function and a list of arguments and the return value. When the argument list
- or the return value is empty, it will be omitted.
-\section css_intro_integration_sec Software Integration
-The CSS API and its implementation do not depend on any particular environment
- or Operating System (OS). It does not use any features from external libraries
- such as libc, this means it can run in any OS and in kernel or user space mode.
- It is expected however that this API will normally be part of a kernel level
- driver.
-*/
-
-#ifndef _SH_CSS_H_
-#define _SH_CSS_H_
-
-#include <stdint.h>
-#include <system_types.h>	/* hrt_vaddress, HAS_IRQ_MAP_VERSION_# */
-
-#include "sh_css_types.h"
-
-#if defined(__HOST__)
-/*
- * For some reason the ISP code depends on the interface to the driver
- */
-#include "input_system.h"	/* mipi_compressor_t */
-#endif
-
-struct sh_css_pipe;
-
-/** Input modes, these enumerate all supported input modes.
- *  Note that not all ISP modes support all input modes.
- */
-/* deprecated */
-enum sh_css_input_mode {
-	SH_CSS_INPUT_MODE_SENSOR, /**< data from sensor */
-	SH_CSS_INPUT_MODE_FIFO,   /**< data from input-fifo */
-	SH_CSS_INPUT_MODE_TPG,    /**< data from test-pattern generator */
-	SH_CSS_INPUT_MODE_PRBS,   /**< data from pseudo-random bit stream */
-	SH_CSS_INPUT_MODE_MEMORY  /**< data from a frame in memory */
-};
-
-/** The ISP streaming input interface supports the following formats.
- *  These match the corresponding MIPI formats.
- */
-enum sh_css_input_format {
-	SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY,    /**< 8 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_YUV420_8,  /**< 8 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_YUV420_10, /**< 10 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_YUV422_8,  /**< UYVY..UVYV, 8 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_YUV422_10, /**< UYVY..UVYV, 10 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_RGB_444,  /**< BGR..BGR, 4 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_RGB_555,  /**< BGR..BGR, 5 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_RGB_565,  /**< BGR..BGR, 5 bits B and $, 6 bits G */
-	SH_CSS_INPUT_FORMAT_RGB_666,  /**< BGR..BGR, 6 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_RGB_888,  /**< BGR..BGR, 8 bits per subpixel */
-	SH_CSS_INPUT_FORMAT_RAW_6,    /**< RAW data, 6 bits per pixel */
-	SH_CSS_INPUT_FORMAT_RAW_7,    /**< RAW data, 7 bits per pixel */
-	SH_CSS_INPUT_FORMAT_RAW_8,    /**< RAW data, 8 bits per pixel */
-	SH_CSS_INPUT_FORMAT_RAW_10,   /**< RAW data, 10 bits per pixel */
-	SH_CSS_INPUT_FORMAT_RAW_12,   /**< RAW data, 12 bits per pixel */
-	SH_CSS_INPUT_FORMAT_RAW_14,   /**< RAW data, 14 bits per pixel */
-	SH_CSS_INPUT_FORMAT_RAW_16,   /**< RAW data, 16 bits per pixel */
-	SH_CSS_INPUT_FORMAT_BINARY_8, /**< Binary byte stream. */
-	N_SH_CSS_INPUT_FORMAT
-};
-
-/** For RAW input, the bayer order needs to be specified separately. There
- *  are 4 possible orders. The name is constructed by taking the first two
- *  colors on the first line and the first two colors from the second line.
- */
-enum sh_css_bayer_order {
-	sh_css_bayer_order_grbg, /**< GRGRGRGRGR .. BGBGBGBGBG */
-	sh_css_bayer_order_rggb, /**< RGRGRGRGRG .. GBGBGBGBGB */
-	sh_css_bayer_order_bggr, /**< BGBGBGBGBG .. GRGRGRGRGR */
-	sh_css_bayer_order_gbrg, /**< GBGBGBGBGB .. RGRGRGRGRG */
-	N_sh_css_bayer_order
-};
-
-/** The still capture mode, this can be RAW (simply copy sensor input to DDR),
- *  Primary ISP, the Advanced ISP (GDC) or the low-light ISP (ANR).
- */
-enum sh_css_capture_mode {
-	SH_CSS_CAPTURE_MODE_RAW,      /**< no processing, copy data only */
-	SH_CSS_CAPTURE_MODE_BAYER,    /**< pre ISP (bayer capture) */
-	SH_CSS_CAPTURE_MODE_PRIMARY,  /**< primary ISP */
-	SH_CSS_CAPTURE_MODE_ADVANCED, /**< advanced ISP (GDC) */
-	SH_CSS_CAPTURE_MODE_LOW_LIGHT /**< low light ISP (ANR) */
-};
-
-/** Interrupt request type.
- *  When the CSS hardware generates an interrupt, a function in this API
- *  needs to be called to retrieve information about the interrupt.
- *  This interrupt type is part of this information and indicates what
- *  type of information the interrupt signals.
- *
- *  Note that one interrupt can carry multiple interrupt types. For
- *  example: the online video ISP will generate only 2 interrupts, one to
- *  signal that the statistics (3a and DIS) are ready and one to signal
- *  that all output frames are done (output and viewfinder).
- *
- * DEPRECATED, this interface is not portable it should only define user
- * (SW) interrupts
- */
-#if defined(HAS_IRQ_MAP_VERSION_2)
-
-enum sh_css_interrupt_info {
-	/**< the current frame is done and a new one can be started */
-	SH_CSS_IRQ_INFO_STATISTICS_READY = 1 << 0,
-	/**< 3A + DIS statistics are ready. */
-
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_SOF = 1 << 9,
-	/**< the css receiver received the start of frame */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_EOF = 1 << 10,
-
-	/**< the css receiver received the end of frame */
-	/* the input system in in error */
-	SH_CSS_IRQ_INFO_INPUT_SYSTEM_ERROR = 1 << 3,
-	/* the input formatter in in error */
-	SH_CSS_IRQ_INFO_IF_ERROR = 1 << 4,
-	/* the dma in in error */
-	SH_CSS_IRQ_INFO_DMA_ERROR = 1 << 5,
-
-	SH_CSS_IRQ_INFO_BUFFER_DONE	 = 1 << 7,
-	/**< Either VF or VFOUT is done */
-	SH_CSS_IRQ_INFO_PIPELINE_DONE	 = 1 << 8,
-	/**< A pipeline is done */
-
-	SH_CSS_IRQ_INFO_SW_0 = 1 << 17,
-	/**< software interrupt 0 */
-	SH_CSS_IRQ_INFO_SW_1 = 1 << 18,
-	/**< software interrupt 1 */
-
-	SH_CSS_IRQ_INFO_INVALID_FIRST_FRAME = 1 << 20,
-	/**< Inform the ISR that there is an invalid first frame */
-	SH_CSS_IRQ_INFO_OUTPUT_FRAME_DONE	= 1 << 21,
-	/**< Output frame done */
-	SH_CSS_IRQ_INFO_VF_OUTPUT_FRAME_DONE	= 1 << 22,
-	/**< Viewfinder output frame done */
-	SH_CSS_IRQ_INFO_RAW_OUTPUT_FRAME_DONE	= 1 << 23,
-	/**< RAW output frame done */
-	SH_CSS_IRQ_INFO_3A_STATISTICS_DONE	= 1 << 24,
-	/**< 3A statistics are ready */
-	SH_CSS_IRQ_INFO_DIS_STATISTICS_DONE	= 1 << 25,
-	/**< DIS statistics are ready */
-	SH_CSS_IRQ_INFO_INPUT_FRAME_DONE	= 1 << 26,
-	/**< Input frame will no longer be accessed */
-	SH_CSS_IRQ_INFO_CUSTOM_INPUT_DONE	= 1 << 27,
-	/**< Custom input buffer will no longer be accessed */
-	SH_CSS_IRQ_INFO_CUSTOM_OUTPUT_DONE	= 1 << 28,
-	/**< Custom output buffer is available */
-	SH_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY = 1 << 29,
-	/**< ISP binary statistics are ready */
-};
-
-#elif defined(HAS_IRQ_MAP_VERSION_1) || defined(HAS_IRQ_MAP_VERSION_1_DEMO)
-
-enum sh_css_interrupt_info {
-	/**< the current frame is done and a new one can be started */
-	SH_CSS_IRQ_INFO_STATISTICS_READY = 1 << 0,
-	/**< 3A + DIS statistics are ready. */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_ERROR = 1 << 1,
-	/**< the css receiver has encountered an error */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_FIFO_OVERFLOW = 1 << 2,
-	/**< the FIFO in the csi receiver has overflown */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_SOF = 1 << 3,
-	/**< the css receiver received the start of frame */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_EOF = 1 << 4,
-	/**< the css receiver received the end of frame */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_SOL = 1 << 6,
-	/**< the css receiver received the start of line */
-	SH_CSS_IRQ_INFO_BUFFER_DONE	 = 1 << 7,
-	/**< Either VF or VFOUT is done */
-	SH_CSS_IRQ_INFO_PIPELINE_DONE	 = 1 << 8,
-	/**< A pipeline is done */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_EOL = 1 << 9,
-	/**< the css receiver received the end of line */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_SIDEBAND_CHANGED = 1 << 10,
-	/**< the css receiver received a change in side band signals */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_0 = 1 << 11,
-	/**< generic short packets (0) */
-	SH_CSS_IRQ_INFO_CSS_RECEIVER_GEN_SHORT_1 = 1 << 12,
-	/**< generic short packets (1) */
-	SH_CSS_IRQ_INFO_IF_PRIM_ERROR = 1 << 13,
-	/**< the primary input formatter (A) has encountered an error */
-	SH_CSS_IRQ_INFO_IF_PRIM_B_ERROR = 1 << 14,
-	/**< the primary input formatter (B) has encountered an error */
-	SH_CSS_IRQ_INFO_IF_SEC_ERROR = 1 << 15,
-	/**< the secondary input formatter has encountered an error */
-	SH_CSS_IRQ_INFO_STREAM_TO_MEM_ERROR = 1 << 16,
-	/**< the stream-to-memory device has encountered an error */
-	SH_CSS_IRQ_INFO_SW_0 = 1 << 17,
-	/**< software interrupt 0 */
-	SH_CSS_IRQ_INFO_SW_1 = 1 << 18,
-	/**< software interrupt 1 */
-	SH_CSS_IRQ_INFO_SW_2 = 1 << 19,
-	/**< software interrupt 2 */
-	SH_CSS_IRQ_INFO_INVALID_FIRST_FRAME = 1 << 20,
-	/**< Inform the ISR that there is an invalid first frame */
-	SH_CSS_IRQ_INFO_OUTPUT_FRAME_DONE	= 1 << 21,
-	/**< Output frame done */
-	SH_CSS_IRQ_INFO_VF_OUTPUT_FRAME_DONE	= 1 << 22,
-	/**< Viewfinder output frame done */
-	SH_CSS_IRQ_INFO_RAW_OUTPUT_FRAME_DONE	= 1 << 23,
-	/**< RAW output frame done */
-	SH_CSS_IRQ_INFO_3A_STATISTICS_DONE	= 1 << 24,
-	/**< 3A statistics are ready */
-	SH_CSS_IRQ_INFO_DIS_STATISTICS_DONE	= 1 << 25,
-	/**< DIS statistics are ready */
-	SH_CSS_IRQ_INFO_INPUT_FRAME_DONE	= 1 << 26,
-	/**< Input frame will no longer be accessed */
-	SH_CSS_IRQ_INFO_CUSTOM_INPUT_DONE	= 1 << 27,
-	/**< Custom input buffer will no longer be accessed */
-	SH_CSS_IRQ_INFO_CUSTOM_OUTPUT_DONE	= 1 << 28,
-	/**< Custom output buffer is available */
-	SH_CSS_IRQ_INFO_ISP_BINARY_STATISTICS_READY = 1 << 29,
-	/**< ISP binary statistics are ready */
-};
-
-#else
-#error "sh_css.h: IRQ MAP must be one of \
-	{IRQ_MAP_VERSION_1, IRQ_MAP_VERSION_1_DEMO, IRQ_MAP_VERSION_2}"
-#endif
-
-/** CSS receiver error types. Whenever the CSS receiver has encountered
- *  an error, this enumeration is used to indicate which errors have occurred.
- *
- *  Note that multiple error flags can be enabled at once and that this is in
- *  fact common (whenever an error occurs, it usually results in multiple
- *  errors).
- *
- * DEPRECATED: This interface is not portable, different systems have
- * different receiver types, or possibly none in case of tests systems.
- */
-enum sh_css_rx_irq_info {
-	SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN   = 1U << 0, /**< buffer overrun */
-	SH_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE = 1U << 1, /**< entering sleep mode */
-	SH_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE  = 1U << 2, /**< exited sleep mode */
-	SH_CSS_RX_IRQ_INFO_ECC_CORRECTED    = 1U << 3, /**< ECC corrected */
-	SH_CSS_RX_IRQ_INFO_ERR_SOT          = 1U << 4,
-						/**< Start of transmission */
-	SH_CSS_RX_IRQ_INFO_ERR_SOT_SYNC     = 1U << 5, /**< SOT sync (??) */
-	SH_CSS_RX_IRQ_INFO_ERR_CONTROL      = 1U << 6, /**< Control (??) */
-	SH_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE   = 1U << 7, /**< Double ECC */
-	SH_CSS_RX_IRQ_INFO_ERR_CRC          = 1U << 8, /**< CRC error */
-	SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID   = 1U << 9, /**< Unknown ID */
-	SH_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC   = 1U << 10,/**< Frame sync error */
-	SH_CSS_RX_IRQ_INFO_ERR_FRAME_DATA   = 1U << 11,/**< Frame data error */
-	SH_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT = 1U << 12,/**< Timeout occurred */
-	SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC  = 1U << 13,/**< Unknown escape seq. */
-	SH_CSS_RX_IRQ_INFO_ERR_LINE_SYNC    = 1U << 14,/**< Line Sync error */
-#if defined(HAS_RX_VERSION_2)
-	SH_CSS_RX_IRQ_INFO_INIT_TIMEOUT     = 1U << 15,
-#endif
-};
-
-/** Errors, these values are used as the return value for most
- *  functions in this API.
- */
-enum sh_css_err {
-	sh_css_success,
-	sh_css_err_internal_error,
-	sh_css_err_conflicting_mipi_settings,
-	sh_css_err_unsupported_configuration,
-	sh_css_err_mode_does_not_have_viewfinder,
-	sh_css_err_input_resolution_not_set,
-	sh_css_err_unsupported_input_mode,
-	sh_css_err_cannot_allocate_memory,
-	sh_css_err_invalid_arguments,
-	sh_css_err_too_may_colors,
-	sh_css_err_unsupported_frame_format,
-	sh_css_err_frames_mismatch,
-	sh_css_err_not_implemented,
-	sh_css_err_invalid_frame_format,
-	sh_css_err_unsupported_resolution,
-	sh_css_err_scaling_factor_out_of_range,
-	sh_css_err_cannot_obtain_shading_table,
-	sh_css_err_interrupt_error,
-	sh_css_err_unexpected_interrupt,
-	sh_css_err_interrupts_not_enabled,
-	sh_css_err_system_not_idle,
-	sh_css_err_unsupported_input_format,
-	sh_css_err_not_enough_input_lines,
-	sh_css_err_not_enough_input_columns,
-	sh_css_err_illegal_resolution,
-	sh_css_err_effective_input_resolution_not_set,
-	sh_css_err_viewfinder_resolution_too_wide,
-	sh_css_err_viewfinder_resolution_exceeds_output,
-	sh_css_err_mode_does_not_have_grid,
-	sh_css_err_mode_does_not_have_raw_output,
-	sh_css_err_unknown_event,
-	sh_css_err_event_queue_is_empty,
-	sh_css_err_buffer_queue_is_full,
-	sh_css_err_buffer_queue_is_empty,
-	sh_css_err_invalid_tag_description,
-	sh_css_err_tag_queue_is_full,
-	sh_css_err_isp_binary_header_mismatch
-};
-
-/** Generic resolution structure.
- */
-struct sh_css_resolution {
-	unsigned int width;  /**< Width */
-	unsigned int height; /**< Height */
-};
-
-/** Frame plane structure. This describes one plane in an image
- *  frame buffer.
- */
-struct sh_css_frame_plane {
-	unsigned int height; /**< height of a plane in lines */
-	unsigned int width;  /**< width of a line, in DMA elements, note that
-				  for RGB565 the three subpixels are stored in
-				  ne element. For all other formats this is
-				   the number of subpixels per line. */
-	unsigned int stride; /**< stride of a line in bytes */
-	unsigned int offset; /**< offset in bytes to start of frame data.
-				  offset is wrt data field in sh_css_frame */
-};
-
-/** Binary "plane". This is used to story binary streams such as jpeg
- *  images. This is not actually a real plane.
- */
-struct sh_css_frame_binary_plane {
-	unsigned int		  size; /**< number of bytes in the stream */
-	struct sh_css_frame_plane data; /**< plane */
-};
-
-/** Container for planar YUV frames. This contains 3 planes.
- */
-struct sh_css_frame_yuv_planes {
-	struct sh_css_frame_plane y; /**< Y plane */
-	struct sh_css_frame_plane u; /**< U plane */
-	struct sh_css_frame_plane v; /**< V plane */
-};
-
-/** Container for semi-planar YUV frames.
-  */
-struct sh_css_frame_nv_planes {
-	struct sh_css_frame_plane y;  /**< Y plane */
-	struct sh_css_frame_plane uv; /**< UV plane */
-};
-
-/** Container for planar RGB frames. Each color has its own plane.
- */
-struct sh_css_frame_rgb_planes {
-	struct sh_css_frame_plane r; /**< Red plane */
-	struct sh_css_frame_plane g; /**< Green plane */
-	struct sh_css_frame_plane b; /**< Blue plane */
-};
-
-/** Container for 6-plane frames. These frames are used internally
- *  in the advanced ISP only.
- */
-struct sh_css_frame_plane6_planes {
-	struct sh_css_frame_plane r;	  /**< Red plane */
-	struct sh_css_frame_plane r_at_b; /**< Red at blue plane */
-	struct sh_css_frame_plane gr;	  /**< Red-green plane */
-	struct sh_css_frame_plane gb;	  /**< Blue-green plane */
-	struct sh_css_frame_plane b;	  /**< Blue plane */
-	struct sh_css_frame_plane b_at_r; /**< Blue at red plane */
-};
-
-/** Frame info struct. This describes the contents of an image frame buffer.
-  */
-struct sh_css_frame_info {
-	unsigned int width;  /**< width of valid data in pixels */
-	unsigned int height; /**< Height of valid data in lines */
-	unsigned int padded_width; /**< stride of line in memory (in pixels) */
-	enum sh_css_frame_format format; /**< format of the frame data */
-	unsigned int raw_bit_depth; /**< number of valid bits per pixel,
-					 only valid for RAW bayer frames */
-	enum sh_css_bayer_order raw_bayer_order; /**< bayer order, only valid
-						      for RAW bayer frames */
-};
-
-enum sh_css_frame_flash_state {
-	SH_CSS_FRAME_NO_FLASH = 0,
-	SH_CSS_FRAME_PARTIAL_FLASH,
-	SH_CSS_FRAME_FULLY_FLASH
-};
-
-/** Frame structure. This structure describes an image buffer or frame.
- *  This is the main structure used for all input and output images.
- */
-struct sh_css_frame {
-	struct sh_css_frame_info info; /**< info struct describing the frame */
-	hrt_vaddress data;	       /**< pointer to start of image data */
-	unsigned int data_bytes;       /**< size of image data in bytes */
-	/* LA: move this to sh_css_buffer */
-	/*
-	 * -1 if data address is static during life time of pipeline
-	 * >=0 if data address can change per pipeline/frame iteration
-	 *     index to dynamic data: sh_css_frame_in, sh_css_frame_out
-	 *                            sh_css_frame_out_vf
-	 */
-	int dynamic_data_index;
-	enum sh_css_frame_flash_state flash_state;
-	unsigned int exp_id; /**< exposure id, only valid for continuous
-				capture cases */
-	bool contiguous; /**< memory is allocated physically contiguously */
-	union {
-		unsigned int	_initialisation_dummy;
-		struct sh_css_frame_plane raw;
-		struct sh_css_frame_plane rgb;
-		struct sh_css_frame_rgb_planes planar_rgb;
-		struct sh_css_frame_plane yuyv;
-		struct sh_css_frame_yuv_planes yuv;
-		struct sh_css_frame_nv_planes nv;
-		struct sh_css_frame_plane6_planes plane6;
-		struct sh_css_frame_binary_plane binary;
-	} planes; /**< frame planes, select the right one based on
-		       info.format */
-};
-
-/** CSS firmware package structure.
- */
-struct sh_css_fw {
-	void	    *data;  /**< pointer to the firmware data */
-	unsigned int bytes; /**< length in bytes of firmware data */
-};
-
-union sh_css_s3a_data {
-	struct {
-		hrt_vaddress s3a_tbl;
-	} dmem;
-	struct {
-		hrt_vaddress s3a_tbl_hi;
-		hrt_vaddress s3a_tbl_lo;
-	} vmem;
-};
-
-struct sh_css_dis_data {
-	hrt_vaddress sdis_hor_proj;
-	hrt_vaddress sdis_ver_proj;
-};
-
-/** Enumeration of buffer types. Buffers can be queued and de-queued
- *  to hand them over between IA and ISP.
- */
-enum sh_css_buffer_type {
-	SH_CSS_BUFFER_TYPE_3A_STATISTICS,
-	SH_CSS_BUFFER_TYPE_DIS_STATISTICS,
-	SH_CSS_BUFFER_TYPE_INPUT_FRAME,
-	SH_CSS_BUFFER_TYPE_OUTPUT_FRAME,
-	SH_CSS_BUFFER_TYPE_VF_OUTPUT_FRAME,
-	SH_CSS_BUFFER_TYPE_RAW_OUTPUT_FRAME,
-	SH_CSS_BUFFER_TYPE_CUSTOM_INPUT,
-	SH_CSS_BUFFER_TYPE_CUSTOM_OUTPUT,
-	SH_CSS_BUFFER_TYPE_PARAMETER_SET,
-	SH_CSS_BUFFER_TYPE_NR_OF_TYPES,		/* must be last */
-};
-
-
-
-/** Environment with function pointers for local IA memory allocation.
- *  This provides the CSS code with environment specific functionality
- *  for memory allocation of small local buffers such as local data structures.
- *  This is never expected to allocate more than one page of memory (4K bytes).
- */
-struct sh_css_sh_env {
-	void *(*alloc)(size_t bytes, bool zero_mem);
-	/**< Allocation function with boolean argument to indicate whether
-	     the allocated memory should be zeroed out or not. */
-	void (*free)(void *ptr); /**< Corresponding free function. */
-	void (*flush) (struct sh_css_acc_fw *fw);
-	/**< Flush function to flush the cache for given accelerator. */
-};
-
-
-/** Environment with function pointers to print error and debug messages.
- */
-struct sh_css_print_env {
-	int (*debug_print)(const char *fmt, ...); /**< Print a debug message. */
-	int (*error_print)(const char *fmt, ...); /**< Print an error message.*/
-};
-
-/** Environment structure. This includes function pointers to access several
- *  features provided by the environment in which the CSS API is used.
- *  This is used to run the camera IP in multiple platforms such as Linux,
- *  Windows and several simulation environments.
- */
-struct sh_css_env {
-	struct sh_css_sh_env	     sh_env; /**< local malloc and free. */
-	struct sh_css_print_env      print_env; /**< Message printing env. */
-};
-
-/** Buffer structure. This is a container structure that enables content
- *  independent buffer queues and access functions.
- */
-#if 1
-struct sh_css_buffer {
-	enum sh_css_buffer_type type; /**< Buffer type. */
-	union {
-		struct sh_css_frame	     *frame;    /**< Frame buffer. */
-	} data; /**< Buffer data pointer. */
-};
-#else
-struct sh_css_buffer {
-	enum sh_css_buffer_type type; /**< Buffer type. */
-	union {
-		struct sh_css_3a_statistics  *stats_3a; /**< 3A statistics. */
-		struct sh_css_dis_statistics *stats_dis;/**< DIS statistics. */
-		struct sh_css_frame	     *frame;    /**< Frame buffer. */
-		struct sh_css_acc_param      *custom_data; /**< Custom buffer. */
-	} data; /**< Buffer data pointer. */
-};
-
-#endif
-
-/** The event type, distinguishes the kind of events that
- * can are generated by the CSS system.
- */
-enum sh_css_event_type {
-  SH_CSS_EVENT_NULL,
-  SH_CSS_EVENT_OUTPUT_FRAME_DONE,
-  SH_CSS_EVENT_VF_OUTPUT_FRAME_DONE,
-  SH_CSS_EVENT_3A_STATISTICS_DONE,
-  SH_CSS_EVENT_DIS_STATISTICS_DONE,
-  SH_CSS_EVENT_PIPELINE_DONE,
-  SH_CSS_NR_OF_EVENTS,
-};
-
-/**
- * Type used with sh_css_event_set_irq_mask()
- */
-enum sh_css_event_irq_mask_type {
-	SH_CSS_EVENT_IRQ_MASK_NONE			= 0,
-	SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE		= 1 << 0,
-	SH_CSS_EVENT_IRQ_MASK_VF_OUTPUT_FRAME_DONE	= 1 << 1,
-	SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE	= 1 << 2,
-	SH_CSS_EVENT_IRQ_MASK_DIS_STATISTICS_DONE	= 1 << 3,
-	SH_CSS_EVENT_IRQ_MASK_PIPELINE_DONE		= 1 << 4,
-	SH_CSS_EVENT_IRQ_MASK_UNUSED			= 1 << 15,
-	SH_CSS_EVENT_IRQ_MASK_ALL			= 0xFFFF
-};
-
-
-/** The pipe id type, distinguishes the kind of pipes that
- *  can be run in parallel.
- */
-enum sh_css_pipe_id {
-  SH_CSS_PREVIEW_PIPELINE,
-  SH_CSS_COPY_PIPELINE,
-  SH_CSS_VIDEO_PIPELINE,
-  SH_CSS_CAPTURE_PIPELINE,
-  SH_CSS_ACC_PIPELINE,
-  SH_CSS_NR_OF_PIPELINES,	/* must be last */
-};
-
-
-/** Interrupt info structure. This structure contains information about an
- *  interrupt. This needs to be used after an interrupt is received on the IA
- *  to perform the correct action.
- */
-struct sh_css_irq_info {
-	enum sh_css_interrupt_info type; /**< Interrupt type. */
-	unsigned int sw_irq_0_val; /**< In case of SW interrupt 0, value. */
-	unsigned int sw_irq_1_val; /**< In case of SW interrupt 1, value. */
-	unsigned int sw_irq_2_val; /**< In case of SW interrupt 2, value. */
-	enum sh_css_pipe_id pipe;
-	/**< The image pipe that generated the interrupt. */
-};
-
-/* ===== GENERIC ===== */
-
-void sh_css_set_stop_timeout(unsigned int timeout);
-
-/** @brief Return the default environment.
- *
- * @return		the default environment.
- *
- * This function return a default environemnt in which
- * isp_buffer_env and css_hw_env are fully defined,
- * sh_env and print_env are undefined.
-*/
-struct sh_css_env sh_css_default_env(void);
-
-/** @brief Initialize the CSS API.
- * @param[in]	env		Environment, provides functions to access the
- *				environment in which the CSS code runs. This is
- *				used for host side memory access and message
- *				printing.
- * @param[in]	fw_data		Firmware package containing the firmware for all
- *				predefined ISP binaries.
- * @param[in]	fw_size		Size of the irmware package in bytes.
- * @return			Returns SH_CSS_ERR_INTERNAL_ERROR in case of any
- *				errors and SH_CSS_SUCCESS otherwise.
- *
- * This function initializes the API which includes allocating and initializing
- * internal data structures. This also interprets the firmware package. All
- * contents of this firmware package are copied into local data structures, so
- * this pointer could be freed after this function completes.
- */
-enum sh_css_err sh_css_init(
-	const struct sh_css_env *env,
-	const char			*fw_data,
-	const unsigned int	fw_size);
-
-#if defined(__HOST__)
-
-/** @brief Un-initialize the CSS API.
- *
- * This function deallocates all memory that has been allocated by the CSS
- * API. After this function is called, no other CSS functions should be called
- * with the exception of sh_css_init which will re-initialize the CSS code.
- *
- * @return None
- */
-void
-sh_css_uninit(void);
-
-/** @brief Suspend CSS API for power down.
- *
- * This function prepares the CSS API for a power down of the CSS hardware.
- * This will make sure the hardware is idle. After this function is called,
- * always call ia_css_resume before calling any other CSS functions.
- * This assumes that all buffers allocated in DDR will remain alive during
- * power down. If this is not the case, use ia_css_unit() followed by
- * ia_css_init() at power up.
- */
-void
-sh_css_suspend(void);
-
-/** @brief Resume CSS API from power down
- *
- * After a power cycle, this function will bring the CSS API back into
- * a state where it can be started. This will re-initialize the hardware.
- * Call this function only after ia_css_suspend() has been called.
- */
-void
-sh_css_resume(void);
-
-/** @brief Obtain interrupt information.
- *
- * @param[out] info	Pointer to the interrupt info. The interrupt
- *			information wil be written to this info.
- * @return		If an error is encountered during the interrupt info
- *			and no interrupt could be translated successfully, this
- *			will return SH_CSS_INTERNAL_ERROR. Otherwise
- *			SH_CSS_SUCCESS.
- *
- * This function is expected to be executed after an interrupt has been sent
- * to the IA from the CSS. This function returns information about the interrupt
- * which is needed by the IA code to properly handle the interrupt. This
- * information includes the image pipe, buffer type etc.
- */
-enum sh_css_err
-sh_css_translate_interrupt(unsigned int *info);
-
-/** @brief Get CSI receiver error info.
- *
- * @param[out] irq_bits	Pointer to the interrupt bits. The interrupt
- *			bits will be written this info.
- *			This will be the error bits that are enabled in the CSI
- *			receiver error register.
- * This function should be used whenever a CSI receiver error interrupt is
- * generated. It provides the detailed information (bits) on the exact error
- * that occurred.
- */
-void
-sh_css_rx_get_interrupt_info(unsigned int *irq_bits);
-
-/** @brief Clear CSI receiver error info.
- *
- * @param[in] irq_bits	The bits that should be cleared from the CSI receiver
- *			interrupt bits register.
- *
- * This function should be called after ia_css_rx_get_irq_info has been called
- * and the error bits have been interpreted. It is advised to use the return
- * value of that function as the argument to this function to make sure no new
- * error bits get overwritten.
- */
-void
-sh_css_rx_clear_interrupt_info(unsigned int irq_bits);
-
-/** @brief Enable or disable specific interrupts.
- *
- * @param[in] type	The interrupt type that will be enabled/disabled.
- * @param[in] enable	enable or disable.
- * @return		Returns SH_CSS_INTERNAL_ERROR if this interrupt
- *			type cannot be enabled/disabled which is true for
- *			CSS internal interrupts. Otherwise returns
- *			SH_CSS_SUCCESS.
- */
-enum sh_css_err
-sh_css_enable_interrupt(enum sh_css_interrupt_info type, bool enable);
-
-/** @brief Return the value of a SW interrupt.
- *
- * @param[in] irq	The software interrupt id.
- * @return		The value for the software interrupt.
- */
-unsigned int
-sh_css_get_sw_interrupt_value(unsigned int irq);
-
-
-/** @brief Set the address of the L1 page table for the CSS MMU.
- *
- * @param[in] base_index	The base address of the L1 page table.
- *
- * This address will be used by the CSS MMU to retrieve page mapping
- * information to translate virtual addresses to physical addresses.
- *
- * DEPRECATED
- */
-void
-sh_css_mmu_set_page_table_base_index(hrt_data base_index);
-
-/** @brief Get the current L1 page table base address.
- *
- * @return	The currently set L1 page table base address.
- *
- * DEPRECATED
- */
-hrt_data
-sh_css_mmu_get_page_table_base_index(void);
-
-/** @brief Invalidate the MMU internal cache.
- *
- * This function triggers an invalidation of the translate-look-aside
- * buffer (TLB) that's inside the CSS MMU. This function should be called
- * every time the page tables used by the MMU change.
- *
- * DEPRECATED, use the MMU access function
- */
-void
-sh_css_mmu_invalidate_cache(void);
-
-#if 1
-/** @brief Starts the CSS system.
- *
- * Starts the CSS system. The provided buffers are only used to construct
- * the static part of the pipeline with the stages. The dynamic data in
- * the buffers are not used and need to be queued with a seperate call
- * to sh_css_queue_buffer. The type of the buffers is still CSS V1.0 style
- */
-enum sh_css_err
-sh_css_start(enum sh_css_pipe_id   pipe);
-#endif
-
-void
-sh_css_update_isp_params(void);
-
-void
-sh_css_queue_free_stat_bufs2sp(enum sh_css_pipe_id pipe);
-
-/* CSS 1.5: to be implemented */
-/** @brief Queue a buffer for an image pipe.
- *
- * @param[in] pipe	The pipe that will own the buffer.
- * @param[in] buffer	Pointer to the buffer.
- * @return		IA_CSS_INTERNAL_ERROR in case of unexpected errors,
- *			IA_CSS_SUCCESS otherwise.
- *
- * This function adds a buffer (which has a certain buffer type) to the queue
- * for this type. This queue is owned by the image pipe. After this function
- * completes successfully, the buffer is now owned by the image pipe and should
- * no longer be accessed by any other code until it gets dequeued. The image
- * pipe will dequeue buffers from this queue, use them and return them to the
- * host code via an interrupt. Buffers will be consumed in the same order they
- * get queued, but may be returned to the host out of order.
- */
-#if 1
-/* NOTE: The type of the buffers is still CSS V1.0 style. The buffer type is
- * provided as a seperate parameter
- */
-enum sh_css_err
-sh_css_queue_buffer(enum sh_css_pipe_id   pipe,
-			enum sh_css_buffer_type buf_type,
-			void *buffer);
-#else
-enum sh_css_err
-sh_css_queue_buffer(enum sh_css_pipe_id   pipe,
-		    struct sh_css_buffer *buffer);
-#endif
-
-/* CSS 1.5: to be implemented */
-/** @brief Dequeue a buffer from an image pipe.
- *
- * @param[in]	pipe	The pipeline that the buffer queue belongs to.
- * @param	type	The type of buffer that should be dequeued.
- * @param[out]	buffer	Pointer to the buffer that was dequeued.
- * @return		IA_CSS_ERR_NO_BUFFER if the queue is empty or
- *			IA_CSS_SUCCESS otherwise.
- *
- * This function dequeues a buffer from a buffer queue. The queue is indicated
- * by the buffer type argument. This function can be called after an interrupt
- * has been generated that signalled that a new buffer was available and can
- * be used in a polling-like situation where the NO_BUFFER return value is used
- * to determine whether a buffer was available or not.
- */
-#if 1
-/* NOTE: The type of the buffers is still CSS V1.0 style. The buffer type is
- * provided as a seperate parameter
- */
-enum sh_css_err
-sh_css_dequeue_buffer(enum sh_css_pipe_id   pipe,
-			enum sh_css_buffer_type buf_type,
-			void **buffer);
-#else
-enum sh_css_err
-sh_css_dequeue_buffer(enum sh_css_pipe_id	pipe,
-		      enum sh_css_buffer_type	type,
-		      struct sh_css_buffer    **buffer);
-#endif
-
-/* CSS 1.5: to be implemented */
-/** @brief Dequeue an event from the CSS system. An event consists of pipe_id
- * and event_id.
- *
- * @param[out]	pipe_id	Pointer to the pipe_id of the event that was dequeued.
- *			Must be non-Null.
- * @param[out]	event_id Pointer to the event_id of the event that was dequeued.
- *			Must be non-Null.
- * @return		sh_css_err_event_queue_is_empty if no events are
- *			available or
- *			sh_css_success otherwise.
- *
- * This function dequeues an event from an event queue. The queue is inbetween
- * the Host (i.e. the Atom processosr) and the CSS system. This function can be
- * called after an interrupt has been generated that signalled that a new event
- * was available and can be used in a polling-like situation where the NO_EVENT
- * return value is used to determine whether an event was available or not.
- */
-enum sh_css_err
-sh_css_dequeue_event(enum sh_css_pipe_id *pipe_id,
-			enum sh_css_event_type *event_id);
-
-/** @brief Controls when the Event generator raises an IRQ to the Host.
- *
- * @param[in]	pipe_id	Id of the pipe e.g. SH_CSS_PREVIEW_PIPELINE.
- * @param[in]	or_mask	Binary or of enum sh_css_event_irq_mask_type. Each event
-			that is part of this mask will directly raise an IRQ to
-			the Host when the event occurs in the CSS.
- * @param[in]	and_mask Binary or of enum sh_css_event_irq_mask_type. An event
-			IRQ for the Host is only raised after all events have
-			occurred at least once for all the active pipes. Events
-			are remembered and don't need to occure at the same
-			moment in time. There is no control over the order of
-			these events. Once an IRQ has been raised all
-			remembered events are reset.
- * @return		sh_css_success.
- *
- Controls when the Event generator in the CSS raises an IRQ to the Host.
- The main purpose of this function is to reduce the amount of interrupts
- between the CSS and the Host. This will help saving power as it wakes up the
- Host less often. In case both or_mask and and_mask are
- SH_CSS_EVENT_IRQ_MASK_NONE for all pipes, no event IRQ's will be raised.
- Note that events are still queued and the Host can poll for them. The
- or_mask and and_mask may be be active at the same time\n
- \n
- Default values, for all pipe id's, after sh_css_init:\n
- or_mask = SH_CSS_EVENT_IRQ_MASK_ALL\n
- and_mask = SH_CSS_EVENT_IRQ_MASK_NONE\n
- \n
- Precondition:\n
- sh_css_init_buffer_queues() must be executed first\n
- \n
- Examples\n
- \code
- sh_css_event_set_irq_mask(SH_CSS_PREVIEW_PIPELINE,
- SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE |
- SH_CSS_EVENT_IRQ_MASK_DIS_STATISTICS_DONE ,
- SH_CSS_EVENT_IRQ_MASK_NONE);
- \endcode
- The event generator will only raise an interrupt to the Host when there are
- 3A or DIS statistics available from the preview pipe. It will not generate
- an interrupt for any other event of the preview pipe e.g when there is an
- output frame available.
-
- \code
- sh_css_event_set_irq_mask(SH_CSS_PREVIEW_PIPELINE,
-	SH_CSS_EVENT_IRQ_MASK_NONE,
-	SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE |
-	SH_CSS_EVENT_IRQ_MASK_3A_STATISTICS_DONE );
-
- sh_css_event_set_irq_mask(SH_CSS_CAPTURE_PIPELINE,
-	SH_CSS_EVENT_IRQ_MASK_NONE,
-	SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE );
- \endcode
- The event generator will only raise an interrupt to the Host when there is
- both a frame done and 3A event available from the preview pipe AND when there
- is a frame done available from the capture pipe. Note that these events
- may occur at different moments in time. Also the order of the events is not
- relevant.
-
- \code
- sh_css_event_set_irq_mask(SH_CSS_PREVIEW_PIPELINE,
-	SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE,
-	SH_CSS_EVENT_IRQ_MASK_ALL );
-
- sh_css_event_set_irq_mask(SH_CSS_COPY_PIPELINE,
-	SH_CSS_EVENT_IRQ_MASK_NONE,
-	SH_CSS_EVENT_IRQ_MASK_NONE );
-
- sh_css_event_set_irq_mask(SH_CSS_CAPTURE_PIPELINE,
-	SH_CSS_EVENT_IRQ_MASK_OUTPUT_FRAME_DONE,
-	SH_CSS_EVENT_IRQ_MASK_ALL );
- \endcode
- The event generator will only raise an interrupt to the Host when there is an
- output frame from the preview pipe OR an output frame from the capture pipe.
- All other events (3A, VF output, pipeline done) will not raise an interrupt
- to the Host. These events are not lost but always stored in the event queue.
- */
-enum sh_css_err
-sh_css_event_set_irq_mask(
-	enum sh_css_pipe_id pipe_id,
-	unsigned int or_mask,
-	unsigned int and_mask);
-
-/** @brief Reads the current event IRQ mask from the CSS.
- *
- * @param[in]	pipe_id	Id of the pipe e.g. SH_CSS_PREVIEW_PIPELINE.
- * @param[out]	or_mask	Current or_mask. The bits in this mask are a binary or
-		of enum sh_css_event_irq_mask_type. Pointer may be NULL.
- * @param[out]	and_mask Current and_mask.The bits in this mask are a binary or
-		of enum sh_css_event_irq_mask_type. Pointer may be NULL.
- * @return	sh_css_success.
- *
- Reads the current event IRQ mask from the CSS. Reading returns the actual
- values as used by the SP and not any mirrored values stored at the Host.\n
-\n
-Precondition:\n
-sh_css_init_buffer_queues() must be executed first\n
-
-*/
-enum sh_css_err
-sh_css_event_get_irq_mask(
-	enum sh_css_pipe_id pipe_id,
-	unsigned int *or_mask,
-	unsigned int *and_mask);
-
-void
-sh_css_event_init_irq_mask(void);
-
-
-/** @brief Return whether UV range starts at 0.
- *
- * @param[out]	uv_offset_is_zero	Pointer to the result value.
-
- *  Return true if UV values range from 0 to 255 and false if UV values
- *  range from -127 to 128.
- */
-void
-sh_css_uv_offset_is_zero(bool *uv_offset_is_zero);
-
-/** @brief Wait for completion of an ISP mode.
- *
- * When interrupts are disabled, use this function to wait for a particular
- * ISP mode to complete.
- */
-enum sh_css_err
-sh_css_wait_for_completion(enum sh_css_pipe_id pipe_id);
-
-/** @brief Set the current input resolution.
- *
- * @param[in]	width	Input resolution width in pixels.
- * @param[in]	height	Input resolution height in pixels.
- *
- * Set the current input resolution. This needs to be called every time the
- * sensor resolution changes.
- */
-enum sh_css_err
-sh_css_input_set_resolution(unsigned int width, unsigned int height);
-
-/** @brief Set the effective input resolution.
- *
- * @param[in]	width	Effective input resolution width in pixels.
- * @param[in]	height	Effective input resolution height in pixels.
- *
- * Set the part of the input resolution that will be the input to the ISP.
- * The difference between the input resolution and effective input resolution
- * will be cropped off. When the effective input resolution is exceeds the
- * output resolution, the ISP will downscale the input to the output resolution
- * in the domain.
- * Note that the effective input resolution cannot be smaller than the output
- * resolution.
- */
-enum sh_css_err
-sh_css_input_set_effective_resolution(unsigned int width, unsigned int height);
-
-/** @brief Set the input format.
- *
- * @param[in]	format	The new input format.
- *
- * Specify the format of the input data. This format is used for all input
- * sources except memory (mipi receiver, prbs, tpg, fifo).
- */
-void
-sh_css_input_set_format(enum sh_css_input_format format);
-
-/** @brief Get the input format.
- *
- * @param[out]	format	Pointer to hold the current input format.
- *
- * Return the last set format of the input data.
- */
-void
-sh_css_input_get_format(enum sh_css_input_format *format);
-
-/** @brief Set the binning factor.
- *
- * @param[in]	binning_factor	The binning factor.
- *
- * Set the current binning factor of the sensor.
- */
-void
-sh_css_input_set_binning_factor(unsigned int binning_factor);
-
-/** @brief Translate format and compression to format type.
- *
- * @param[in]	input_format	The input format.
- * @param[in]	compression	The compression scheme.
- * @param[out]	fmt_type	Pointer to the resulting format type.
- * @return			Error code.
- *
- * Translate an input format and mipi compression pair to the fmt_type.
- * This is normally done by the sensor, but when using the input fifo, this
- * format type must be sumitted correctly by the application.
- */
-enum sh_css_err sh_css_input_format_type(
-	enum sh_css_input_format input_format,
-	mipi_predictor_t	compression,
-	unsigned int		*fmt_type);
-
-/** @brief Enable/disable two pixels per clock.
- *.
- * @param[in]	two_pixels_per_clock	Enable/disable value.
- *
- * Specify that the input will be sent as 2 pixels per clock.
- * The default is one pixel per clock.
- */
-void
-sh_css_input_set_two_pixels_per_clock(bool two_pixels_per_clock);
-
-/** @brief Get the two pixels per clock value.
- *
- * @param[out]	two_pixels_per_clock	Two pixels per clock value.
- *
- * Return the last set "2 pixels per clock" setting
- */
-void
-sh_css_input_get_two_pixels_per_clock(bool *two_pixels_per_clock);
-
-/** @brief Set the bayer order of the input.
- *
- * @param[in]	bayer_order	The bayer order of the input data.
- *
- * Specify the bayer order of the input. The default is grbg.
-*/
-void
-sh_css_input_set_bayer_order(enum sh_css_bayer_order bayer_order);
-
-/** @brief Get the extra pixels for the sensor driver.
- *
- * @param[out]	extra_rows	The horizontal extra pixels.
- * @param[out]	extra_columns	The vertical extra pixels.
- *
- * Get the number of extra rows and columns needed to program the
- * sensor driver with the correct resolution.
- * This is dependent upon the bayer order which is assumed to have
- * been already set using the API ::sh_css_input_set_bayer_order
- */
-void
-sh_css_get_extra_pixels_count(int *extra_rows, int *extra_columns);
-
-/** @brief Set the input channel id.
- *
- * @param[in]	channel_id	The input channel id.
- *
- * Specify the channel on which the input will come into the CSS receiver. Each
- sensor can submit its output data on
- * several channels. The channel used by the sensor must correspond to the
- channel set here, otherwise the input data
- * will be discarded by the CSS.
- */
-void
-sh_css_input_set_channel(unsigned int channel_id);
-
-/** @brief Set the input mode.
- *
- * @param[in]	mode	The input mode.
- *
- * Set the input mode to be used.
- *
- * @return None
- */
-void
-sh_css_input_set_mode(enum sh_css_input_mode mode);
-
-/** @brief Set the left padding.
- *
- * @param[in]	padding	The amount of left padding (pixels).
- *
- * Set the left padding to 2*NWAY-padding.
- *
- * @return None
- */
-void
-sh_css_input_set_left_padding(unsigned int padding);
-
-/** @brief Configure the CSI-2 receiver.
- *
- * @param[in]	port		port ID.
- * @param[in]	num_lanes	Number of lanes.
- * @param[in]	timeout		Timeout value.
- *
- * Configure the MIPI receiver:
- *  The num_lanes argument is only valid for the 4lane port. It specifies
- *  how many of these 4 lanes are in use. Valid values are 1, 2, 3 or 4.
- *  The timeout argument specifies the timeout after which a timeout interrupt
- *  is generated.
- *  The timeout is specified in terms of <TO BE CLARIFIED>.
- *
- * This interface is deprecated, it is not portable -> move to input system API
- */
-enum sh_css_err sh_css_input_configure_port(
-	const mipi_port_ID_t	port,
-	const unsigned int		num_lanes,
-	const unsigned int		timeout);
-
-/** @brief Configure the CSI-2 compression scheme.
- *
- * @param[in]	comp				The predictor type.
- * @param[in]	compressed_bits_per_pixel	Number of compressed bits.
- * @param[in]	uncompressed_bits_per_pixel	Number of uncompressed bits.
- *
- * Specify the number of bits per compressed and uncompressed pixel and
- * the compression predictor mode.
- *
- * This interface is deprecated, it is not portable -> move to input system API
- *
- * @return Error code: indicates success or error.
- */
-enum sh_css_err sh_css_input_set_compression(
-	const mipi_predictor_t	comp,
-	const unsigned int		compressed_bits_per_pixel,
-	const unsigned int		uncompressed_bits_per_pixel);
-
-/** @brief Configure the test pattern generator.
- *
- * @param[in]	x_mask				See code-snippet.
- * @param[in]	x_delta				See code-snippet.
- * @param[in]	y_mask				See code-snippet.
- * @param[in]	y_delta				See code-snippet.
- * @param[in]	xy_mask				See code-snippet.
- *
- * Configure the Test Pattern Generator, the way these values are used to
- * generate the pattern can be seen in the HRT extension for the test pattern
- * generator:
- * devices/test_pat_gen/hrt/include/test_pat_gen.h: hrt_calc_tpg_data().
- *
- * This interface is deprecated, it is not portable -> move to input system API
- *
-@code
-unsigned int test_pattern_value(unsigned int x, unsigned int y)
-{
- unsigned int x_val, y_val;
- if (x_delta > 0) (x_val = (x << x_delta) & x_mask;
- else (x_val = (x >> -x_delta) & x_mask;
- if (y_delta > 0) (y_val = (y << y_delta) & y_mask;
- else (y_val = (y >> -y_delta) & x_mask;
- return (x_val + y_val) & xy_mask;
-}
-@endcode
- */
-void
-sh_css_tpg_configure(unsigned int x_mask, int x_delta,
-		     unsigned int y_mask, int y_delta, unsigned int xy_mask);
-
-/** @brief Set the PRBS seed.
- *
- * @param[in]	seed	The random generator seed.
- *
- * Seed the for the Pseudo Random Bit Sequence.
- *
- * This interface is deprecated, it is not portable -> move to input system API
- */
-void
-sh_css_prbs_set_seed(int seed);
-
-void
-sh_css_set_shading_table(const struct sh_css_shading_table *table);
-
-/* ===== FRAMES ===== */
-
-/** @brief Fill a frame with zeros
- *
- * @param	frame		The frame.
- *
- * Fill a frame with pixel values of zero
- */
-extern void sh_css_frame_zero(struct sh_css_frame *frame);
-
-/** @brief Allocate a CSS frame structure
- *
- * @param	frame		The allocated frame.
- * @param	width		The width (in pixels) of the frame.
- * @param	height		The height (in lines) of the frame.
- * @param	format		The frame format.
- * @param	stride		The padded stride, in pixels.
- * @param	raw_bit_depth	The raw bit depth, in bits.
- * @return			The error code.
- *
- * Allocate a CSS frame structure. The memory for the frame data will be
- * allocated in the CSS address space.
- */
-enum sh_css_err
-sh_css_frame_allocate(struct sh_css_frame **frame,
-		      unsigned int width,
-		      unsigned int height,
-		      enum sh_css_frame_format format,
-		      unsigned int stride,
-		      unsigned int raw_bit_depth);
-
-/** @brief Allocate a CSS frame structure using a frame info structure.
- *
- * @param	frame	The allocated frame.
- * @param[in]	info	The frame info structure.
- * @return		The error code.
- *
- * Allocate a frame using the resolution and format from a frame info struct.
- * This is a convenience function, implemented on top of
- * ia_css_frame_allocate().
- */
-enum sh_css_err
-sh_css_frame_allocate_from_info(struct sh_css_frame **frame,
-				const struct sh_css_frame_info *info);
-
-/** @brief Free a CSS frame structure.
- *
- * @param[in]	frame	Pointer to the frame.
- *
- * Free a CSS frame structure. This will free both the frame structure
- * and the pixel data pointer contained within the frame structure.
- */
-void
-sh_css_frame_free(struct sh_css_frame *frame);
-
-/* ===== FPGA display frames ====== */
-
-/** @brief Allocate a contiguous CSS frame structure
- *
- * @param	frame		The allocated frame.
- * @param	width		The width (in pixels) of the frame.
- * @param	height		The height (in lines) of the frame.
- * @param	format		The frame format.
- * @param	stride		The padded stride, in pixels.
- * @param	raw_bit_depth	The raw bit depth, in bits.
- * @return			The error code.
- *
- * Contiguous frame allocation, only for FPGA display driver which needs
- * physically contiguous memory.
- */
-enum sh_css_err
-sh_css_frame_allocate_contiguous(struct sh_css_frame **frame,
-				 unsigned int width,
-				 unsigned int height,
-				 enum sh_css_frame_format format,
-				 unsigned int stride,
-				 unsigned int raw_bit_depth);
-
-/** @brief Allocate a contiguous CSS frame from a frame info structure.
- *
- * @param	frame	The allocated frame.
- * @param[in]	info	The frame info structure.
- * @return		The error code.
- *
- * Allocate a frame using the resolution and format from a frame info struct.
- * This is a convenience function, implemented on top of
- * ia_css_frame_allocate_contiguous().
- * Only for FPGA display driver which needs physically contiguous memory.
- */
-enum sh_css_err
-sh_css_frame_allocate_contiguous_from_info(struct sh_css_frame **frame,
-					  const struct sh_css_frame_info *info);
-
-/** @brief Map an existing frame data pointer to a CSS frame.
- *
- * @param[in]	info		The frame info.
- * @param[in]	data		Pointer to the allocated frame data.
- * @param[in]	attribute	Attributes to be passed to mmgr_mmap.
- * @param[in]	context		Pointer to the a context to be passed to mmgr_mmap.
- * @return			The allocated frame structure.
- *
- * This function maps a pre-allocated pointer into a CSS frame. This can be
- * used when an upper software layer is responsible for allocating the frame
- * data and it wants to share that frame pointer with the CSS code.
- * This function will fill the CSS frame structure just like
- * ia_css_frame_allocate() does, but instead of allocating the memory, it will
- * map the pre-allocated memory into the CSS address space.
- */
-enum sh_css_err
-sh_css_frame_map(struct sh_css_frame **frame,
-                 const struct sh_css_frame_info *info,
-                 const void *data,
-                 uint16_t attribute,
-                 void *context);
-
-/** @brief Unmap a CSS frame structure.
- *
- * @param[in]	frame	Pointer to the CSS frame.
- *
- * This function unmaps the frame data pointer within a CSS frame and
- * then frees the CSS frame structure. Use this for frame pointers created
- * using ia_css_frame_map().
- */
-void
-sh_css_frame_unmap(struct sh_css_frame *frame);
-
-#if 0
-/* ===== PREVIEW ===== */
-
-/** @brief Start preview mode.
- *
- * @param[in]	raw_out_frame	The optional raw input frame.
- * @param[out]	out_frame	The preview output frame.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Start the ISP in preview mode, this will run the preview ISP on one frame.
- * After this has completed, it needs to be started again for the next frame.
- */
- enum sh_css_err
-sh_css_preview_start(struct sh_css_frame *raw_out_frame,
-		     struct sh_css_frame *out_frame,
-			 union sh_css_s3a_data *s3a_data,
-			 struct sh_css_dis_data *sdis_data);
-#endif
-
-/** @brief Stop the preview pipe
- *
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * This function stops the preview pipe that's running. Note that any
- * dependent pipes will also be stopped automatically since otherwise
- * they would starve because they no longer receive input data.
- */
-enum sh_css_err
-sh_css_preview_stop(void);
-
-/** @brief Enable online mode for preview.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable online binaries if available. Default is enabled.
- */
-void
-sh_css_preview_enable_online(bool enable);
-
-
-/** @brief Enable/disable online mode for video.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable online mode. Default is enabled.
- */
-void
-sh_css_video_enable_online(bool enable);
-
-/** @brief Enable yuv ds mode for video.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable yuv ds mode. Default is disabled.
- */
-void
-sh_css_video_enable_yuv_ds(bool enable);
-
-/** @brief Enable high speed mode for video.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable high speed mode. Default is disabled.
- */
-void
-sh_css_video_enable_high_speed(bool enable);
-
-/** @brief Enable 6-axis DVS mode for video.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable 6-axis DVS mode. Default is disabled.
- */
-void
-sh_css_video_enable_dvs_6axis(bool enable);
-
-/** @brief Enable reduced pipe for video.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable reduced pipe (version 2). Default is disabled.
- */
-void
-sh_css_video_enable_reduced_pipe(bool enable);
-
-/** @brief Enable/disable viewfinder for video.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable viewfinder. Default is enabled.
- */
-void
-sh_css_video_enable_viewfinder(bool enable);
-
-/** @brief Enable continuous mode.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable continuous binaries if available. Default is disabled.
- */
-void
-sh_css_enable_continuous(bool enable);
-
-/** @brief Enable cont_capt mode (continuous preview+capture running together).
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable continuous binaries if available. Default is disabled.
- */
-void
-sh_css_enable_cont_capt(bool enable, bool stop_copy_preview);
-
-/** @brief Return whether continuous mode is enabled.
- *
- * @return	Enabling value.
- *
- * Return whether continuous binaries are enabled.
- */
-bool
-sh_css_continuous_is_enabled(void);
-
-/** @brief Return max nr of continuous RAW frames.
- *
- * @return	Max nr of continuous RAW frames.
- *
- * Return the maximum nr of continuous RAW frames the system can support.
- */
-int
-sh_css_continuous_get_max_raw_frames(void);
-
-/** @brief Set nr of continuous RAW frames to use.
- *
- * @param 	num_frames	Number of frames.
- * @return	SH_CSS_SUCCESS or error code upon error.
- *
- * Set the number of continuous frames to use during continuous modes.
- */
-enum sh_css_err
-sh_css_continuous_set_num_raw_frames(int num_frames);
-
-/** @brief Get nr of continuous RAW frames to use.
- *
- * @return 	Number of frames to use.
- *
- * Get the currently set number of continuous frames
- * to use during continuous modes.
- */
-int
-sh_css_continuous_get_num_raw_frames(void);
-
-/** @brief Enable raw binning mode.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable raw binning if available. Default is disabled.
- */
-void
-sh_css_enable_raw_binning(bool enable);
-
-/** @brief Disable vf_pp.
- *
- * @param	disable	Disabling value.
- *
- * Disable vf_pp: used to replace by dynamic binary for testing purposes.
- *		  OR
- *		  to disable vf_pp. E.g. in case vf_pp processing does not
- *		  fit in the vblank interval and capture frame will be used
- *		  as vf frame (with some optional external post processing)
- */
-void
-sh_css_disable_vf_pp(bool disable);
-
-/** @brief Disable capture_pp.
- *
- * @param	disable	Disabling value.
- *
- * Disable capture_pp: used to replace by dynamic binary for testing purposes.
- */
-void
-sh_css_disable_capture_pp(bool disable);
-
-/** @brief Specify the preview output resolution.
- *
- * @param	width	The output width.
- * @param	height	The output height.
- * @param	format	The output format.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Specify the output resolution to be used by the preview ISP.
- */
-enum sh_css_err
-sh_css_preview_configure_output(unsigned int width,
-				unsigned int height,
-				unsigned int min_padded_width,
-				enum sh_css_frame_format format);
-
-/** @brief Get the preview output information
- *
- * @param[out]	info	Pointer to the output information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Get the information about the output frames, this contains the resolution
- * and the stride. To allocate frames, use the information returned here.
- */
-enum sh_css_err
-sh_css_preview_get_output_frame_info(struct sh_css_frame_info *info);
-
-/** @brief Get the preview grid information
- *
- * @param[out]	info	Pointer to the grid information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Get the information about the preview grid.
- */
-enum sh_css_err
-sh_css_preview_get_grid_info(struct sh_css_grid_info *info);
-
-/** @brief Get the preview input resolution.
- *
- * @param[out]	width	Pointer to the input width.
- * @param[out]	height	Pointer to the input height.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Get the resolution for the preview input frames.
- */
-enum sh_css_err
-sh_css_preview_get_input_resolution(unsigned int *width,
-				    unsigned int *height);
-
-/** @brief Specify the vf_pp input resolution.
- *
- * @param	width	The output width.
- * @param	height	The output height.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Set the input resolution for viewfinder post processing.
- * When this is not set, the input resolution is equal to the input
- * resolution of the preview pipeline. When this is set, the YUV scaler
- * in the viewfinder post processing step will be activated.
- */
-enum sh_css_err
-sh_css_preview_configure_pp_input(unsigned int width, unsigned int height);
-
-#if 0
-/* ===== CAPTURE ===== */
-
-/** @brief Start capture mode.
- *
- * @param[in]	raw_out_frame	The optional raw input frame.
- * @param[out]	out_frame	The capture output frame.
- * @param[out]	vf_frame	The capture viewfinder frame.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Start the ISP in capture mode, this will run a capture ISP on one frame.
- * After this has completed, it needs to be started again for the next frame.
- */
-enum sh_css_err
-sh_css_capture_start(struct sh_css_frame *raw_out_frame,
-		     struct sh_css_frame *out_frame,
-		     struct sh_css_frame *vf_frame,
-			 union sh_css_s3a_data *s3a_data,
-			 struct sh_css_dis_data *sdis_data);
-#endif
-
-/** @brief Stop the capture pipe
- *
- * @return		IA_CSS_SUCCESS or error code upon error.
- *
- * This function stops the capture pipe that's running. Note that any
- * dependent pipes will also be stopped automatically since otherwise
- * they would starve because they no longer receive input data.
- */
-enum sh_css_err
-sh_css_capture_stop(void);
-
-/** @brief Configure the continuous capture
- *
- * @param	num_captures	The number of RAW frames to be processed to
- *                              YUV. Setting this to -1 will make continuous
- *                              capture run until it is stopped.
- *                              This number will also be used to allocate RAW
- *                              buffers. To allow the viewfinder to also
- *                              keep operating, 2 extra buffers will always be
- *                              allocated.
- *                              If the offset is negative and the skip setting
- *                              is greater than 0, additional buffers may be
- *                              needed.
- * @param	skip		Skip N frames in between captures. This can be
- *                              used to select a slower capture frame rate than
- *                              the sensor output frame rate.
- * @param	offset		Start the RAW-to-YUV processing at RAW buffer
- *                              with this offset. This allows the user to
- *                              process RAW frames that were captured in the
- *                              past or future.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- *  For example, to capture the current frame plus the 2 previous
- *  frames and 2 subsequent frames, you would call
- *  sh_css_offline_capture_configure(5, 0, -2).
- */
-enum sh_css_err
-sh_css_offline_capture_configure(int num_captures,
-				 unsigned int skip,
-				 int offset);
-
-/** @brief Specify which raw frame to tag based on exp_id found in frame info
- *
- * @param	exp_id	The exposure id of the raw frame to tag.
- *
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * This function allows the user to tag a raw frame based on the exposure id
- * found in the viewfinder frames' frame info.
- */
-enum sh_css_err
-sh_css_offline_capture_tag_frame(unsigned int exp_id);
-
-/** @brief Specify the mode used for capturing.
- *
- * @param	mode	The capture mode.
- *
- * Specify the mode used for capturing.
- */
-void
-sh_css_capture_set_mode(enum sh_css_capture_mode mode);
-
-/** @brief Enable or disable XNR.
- *
- * @param	enable	Enabling value.
- *
- * Enable the eXtra Noise Reduction as a post processing step. This will be
- * run on both the captured output and the viewfinder output.
- */
-void
-sh_css_capture_enable_xnr(bool enable);
-
-/** @brief Specify the capture output resolution.
- *
- * @param	width	The output width.
- * @param	height	The output height.
- * @param	format	The output format.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Specify the output resolution for captured images.
- */
-enum sh_css_err
-sh_css_capture_configure_output(unsigned int width,
-				unsigned int height,
-				unsigned int min_padded_width,
-				enum sh_css_frame_format format);
-
-/** @brief Specify the capture viewfinder resolution.
- *
- * @param	width	The viewfinder width.
- * @param	height	The viewfinder height.
- * @param	format	The viewfinder format.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Specify the viewfinder resolution. Note that this resolution currently
- * has to be a division of the captured output by a power of 2. The API will
- * automatically select the resolution that's closest to the one requested
- * here.
- */
-enum sh_css_err
-sh_css_capture_configure_viewfinder(unsigned int width,
-				    unsigned int height,
-				    unsigned int min_padded_width,
-				    enum sh_css_frame_format format);
-
-/** @brief Specify the capture post processing input resolution.
- *
- * @param	width	The width.
- * @param	height	The height.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * For non-raw still captures, downscaling in the YUV domain can be done
- * during post processing. This function specifies the input resolution
- * for the YUV downscaling step. If this resolution is not set, the YUV
- * downscaling will not be done. The output resolution of the YUV
- * downscaling is taken from the configure_output function above.
- */
-enum sh_css_err
-sh_css_capture_configure_pp_input(unsigned int width,
-				  unsigned int height);
-
-/** @brief Enable online mode for capture.
- *
- * @param	enable	Enabling value.
- *
- * Enable or disable online binaries if available. Default is enabled.
- */
-void
-sh_css_capture_enable_online(bool enable);
-
-/** @brief Get the capture output information
- *
- * @param[out]	info	Pointer to the output information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Retrieve the format and resolution of the output frames. Note that this
- * can differ from the requested resolution.
- */
-enum sh_css_err
-sh_css_capture_get_output_frame_info(struct sh_css_frame_info *info);
-
-/** @brief Get the capture viewfinder information
- *
- * @param[out]	info	Pointer to the viewfinder information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Retrieve the format and resolution of the viewfinder frames. Note that this
- * can differ from the requested resolution.
- */
-enum sh_css_err
-sh_css_capture_get_viewfinder_frame_info(struct sh_css_frame_info *info);
-
-/** @brief Get the capture raw output information
- *
- * @param[out]	info	Pointer to the raw information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Retrieve the format and resolution of the RAW frame. This is only available
- * when the capture is set to offline or continuous using:
- * sh_css_capture_enable_online(false) or
- * sh_css_enable_continuous(true).
- */
-enum sh_css_err
-sh_css_capture_get_output_raw_frame_info(struct sh_css_frame_info *info);
-
-/** @brief Get the capture grid information
- *
- * @param[out]	info	Pointer to the grid information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Get the information about the capture grid.
- */
-enum sh_css_err
-sh_css_capture_get_grid_info(struct sh_css_grid_info *info);
-
-/** @brief Get the capture input resolution.
- *
- * @param[out]	width	Pointer to the input width.
- * @param[out]	height	Pointer to the input height.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Get the resolution for the capture input frames.
- */
-enum sh_css_err
-sh_css_capture_get_input_resolution(unsigned int *width,
-				    unsigned int *height);
-
-#if 0
-/* ===== VIDEO ===== */
-
-/** @brief Start video mode.
- *
- * @param[in]	in_frame	The optional raw input frame.
- * @param[in]	out_frame	The video output frame.
- * @param[in]	vf_frame	The video viewfinder frame.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Start the ISP in video mode, this will run a video ISP on one frame.
- * After this has completed, it needs to be started again for the next frame.
- * The input frame, this argument is only used if the input_mode is set to
- * sh_css_input_mode_memory.
- */
-enum sh_css_err
-sh_css_video_start(struct sh_css_frame *in_frame,
-		   struct sh_css_frame *out_frame,
-		   struct sh_css_frame *vf_frame,
-		   union sh_css_s3a_data *s3a_data,
-		   struct sh_css_dis_data *sdis_data);
-#endif
-/** @brief Stop the video pipe
- *
- * @return		IA_CSS_SUCCESS or error code upon error.
- *
- * This function stops the video pipe that's running. Note that any
- * dependent pipes will also be stopped automatically since otherwise
- * they would starve because they no longer receive input data.
- */
-enum sh_css_err
-sh_css_video_stop(void);
-
-/** @brief Specify the video output resolution.
- *
- * @param	width	The output width.
- * @param	height	The output height.
- * @param	format	The output format.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Specify the output resolution for video images.
- */
-enum sh_css_err
-sh_css_video_configure_output(unsigned int width,
-			      unsigned int height,
-			      unsigned int min_padded_width,
-			      enum sh_css_frame_format format);
-
-/** @brief Specify the video viewfinder resolution.
- *
- * @param	width	The viewfinder width.
- * @param	height	The viewfinder height.
- * @param	format	The viewfinder format.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Specify the viewfinder resolution. Note that this resolution currently
- * has to be a division of the video output by a power of 2. The API will
- * automatically select the resolution that's closest to the one requested
- * here.
- */
-enum sh_css_err
-sh_css_video_configure_viewfinder(unsigned int width,
-				  unsigned int height,
-				  unsigned int min_padded_width,
-				  enum sh_css_frame_format format);
-
-/** @brief Set the envelope for DVS.
- *
- * @param	width	Envelope width.
- * @param	height	Envelope height.
- *
- * Specify the envelope to be used for DVS.
- */
-void
-sh_css_video_set_dis_envelope(unsigned int width, unsigned int height);
-
-/** @brief Retrieve the envelope for DVS.
- *
- * @param[out]	width	Envelope width.
- * @param[out]	height	Envelope height.
- *
- * Retrieve the envelope to be used for DVS.
- */
-void
-sh_css_video_get_dis_envelope(unsigned int *width, unsigned int *height);
-
-/** @brief Set the flag for using DZ.
- *
- * @param[in]	enable_dz	Enable digital zoom.
- *
- * Set the flag for using digital zoom for video. By default this is enabled.
- */
-void
-sh_css_video_set_enable_dz(bool enable_dz);
-
-/** @brief Retrieve the flag for using DZ.
- *
- * @param[out]	enable_dz	Digital zoom enabled.
- *
- * Retrieve the flag for using digital zoom for video. By default it is enabled.
- */
-void
-sh_css_video_get_enable_dz(bool *enable_dz);
-
-/** @brief Get the video output information
- *
- * @param[out]	info	Pointer to the output information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Retrieve the format and resolution of the output frames. Note that this
- * can differ from the requested resolution.
- */
-enum sh_css_err
-sh_css_video_get_output_frame_info(struct sh_css_frame_info *info);
-
-/** @brief Get the video raw output information
- *
- * @param[out]	info	Pointer to the output information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Retrieve the format and resolution of the raw output frame. Note that this
- * can differ from the requested resolution.
- */
-enum sh_css_err
-sh_css_video_get_output_raw_frame_info(struct sh_css_frame_info *info);
-
-/** @brief Get the video viewfinder information
- *
- * @param[out]	info	Pointer to the viewfinder information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Retrieve the format and resolution of the viewfinder frames. Note that this
- * can differ from the requested resolution.
- */
-enum sh_css_err
-sh_css_video_get_viewfinder_frame_info(struct sh_css_frame_info *info);
-
-/** @brief Get the video grid information
- *
- * @param[out]	info	Pointer to the grid information.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Get the information about the video grid.
- */
-enum sh_css_err
-sh_css_video_get_grid_info(struct sh_css_grid_info *info);
-
-/** @brief Get the video input resolution.
- *
- * @param[out]	width	Pointer to the input width.
- * @param[out]	height	Pointer to the input height.
- * @return		SH_CSS_SUCCESS or error code upon error.
- *
- * Get the resolution for the video input frames.
- */
-enum sh_css_err
-sh_css_video_get_input_resolution(unsigned int *width,
-				  unsigned int *height);
-
-/** @brief Send streaming data into the css input FIFO
- *
- * @param	data	Pointer to the pixels to be send.
- * @param	width	Width of the input frame.
- * @param	height	Height of the input frame.
- *
- * Send streaming data into the css input FIFO. This is for testing purposes
- * only. This uses the channel ID and input format as set by the user with
- * the regular functions for this.
- * This function blocks until the entire frame has been written into the
- * input FIFO.
- */
-void
-sh_css_send_input_frame(unsigned short *data,
-			unsigned int width,
-			unsigned int height);
-
-/*
- * For higher flexibility the sh_css_send_input_frame is replaced by
- * three seperate functions:
- * 1) sh_css_streaming_to_mipi_start_frame
- * 2) sh_css_streaming_to_mipi_send_line
- * 3) sh_css_streaming_to_mipi_end_frame
- * In this way it is possible to stream multiple frames on different
- * channel ID's on a line basis. It will be possible to simulate
- * line-interleaved Stereo 3D muxed on 1 mipi port.
- * These 3 functions are for testing purpose only and can be used in
- * conjunction with sh_css_send_input_frame
- */
-
-/** @brief Start an input frame on the CSS input FIFO.
- *
- * @param[in]	channel_id		The channel id.
- * @param[in]	input_format		The input format.
- * @param[in]	two_pixels_per_clock	Use 2 pixels per clock.
- *
- * Starts the streaming to mipi frame by sending SoF for channel channel_id.
- * It will use the input_format and two_pixels_per_clock as provided by
- * the user.
- * For the "correct" use-case, input_format and two_pixels_per_clock must match
- * with the values as set by the user with the regular functions.
- * To simulate an error, the user can provide "incorrect" values for
- * input_format and/or two_pixels_per_clock.
- */
-void
-sh_css_streaming_to_mipi_start_frame(unsigned int channel_id,
-				enum sh_css_input_format input_format,
-				bool two_pixels_per_clock);
-
-
-/** @brief Send a line of input data into the CSS input FIFO.
- *
- * @param[in]	channel_id		The channel id.
- * @param[in]	data	Array of the first line of image data.
- * @param	width	The width (in pixels) of the first line.
- * @param[in]	data2	Array of the second line of image data.
- * @param	width2	The width (in pixels) of the second line.
- *
- * Sends 1 frame line. Start with SoL followed by width bytes of data, followed
- * by width2 bytes of data2 and followed by and EoL
- * It will use the input_format and two_pixels_per_clock settings as provided
- * with the sh_css_streaming_to_mipi_start_frame function call.
- *
- * This function blocks until the entire line has been written into the
- * input FIFO.
- */
-void
-sh_css_streaming_to_mipi_send_line(unsigned int channel_id,
-						unsigned short *data,
-						unsigned int width,
-						unsigned short *data2,
-						unsigned int width2);
-
-
-/** @brief End an input frame on the CSS input FIFO.
- *
- * @param[in]	channel_id	The channel id.
- *
- * Send the end-of-frame signal into the CSS input FIFO.
- */
-void
-sh_css_streaming_to_mipi_end_frame(unsigned int channel_id);
-
-/** @brief Test whether the ISP has started.
- *
- * @return	The ISP has started.
- *
- * Temporary function to poll whether the ISP has been started. Once it has,
- * the sensor can also be started. */
-bool
-sh_css_isp_has_started(void);
-
-/** @brief Test whether the SP has initialized.
- *
- * @return	The SP has initialized.
- *
- * Temporary function to poll whether the SP has been initilized. Once it has,
- * we can enqueue buffers. */
-bool
-sh_css_sp_has_booted(void);
-
-/** @brief Test whether the SP has terminated.
- *
- * @return	The SP has terminated.
- *
- * Temporary function to poll whether the SP has been terminated. Once it has,
- * we can switch mode. */
-bool
-sh_css_sp_has_terminated(void);
-
-/** @brief Load firmware for acceleration.
- *
- * @param	firmware	Firmware to be loaded.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Load firmware for acceleration.
- */
-enum sh_css_err
-sh_css_load_acceleration(struct sh_css_acc_fw *firmware);
-
-/** @brief Unload firmware for acceleration.
- *
- * @param	firmware	Firmware to be unloaded.
- *
- * Unload firmware for acceleration.
- */
-void
-sh_css_unload_acceleration(struct sh_css_acc_fw *firmware);
-
-/** @brief Load firmware for extension.
- *
- * @param	firmware	Firmware to be loaded.
- * @param	pipe_id		Pipeline type to be loaded on.
- * @param	acc_type	Output to be conneted to.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Load firmware for extension to a designated pipeline
- */
-extern enum sh_css_err sh_css_load_extension(
-	struct sh_css_fw_info	*fw,
-	enum sh_css_pipe_id		pipe_id,
-	enum sh_css_acc_type	acc_type);
-
-
-/** @brief Unload firmware for extension.
- *
- * @param	firmware	Firmware to be unloaded.
- * @param	pipe_id		Pipeline type to be unloaded from.
- *
- * Unload firmware for extension from a designated pipeline.
- */
-extern enum sh_css_err sh_css_unload_extension(
-	struct sh_css_fw_info *fw,
-	enum sh_css_pipe_id		pipe_id);
-
-/** @brief Set parameter for acceleration.
- *
- * @param	firmware	Firmware of acceleration.
- * @param	val		Parameter value.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Set acceleration parameter to value <val>.
- * The parameter value is an isp pointer, i.e. allocated in DDR and mapped
- * to the CSS virtual address space.
- */
-enum sh_css_err
-sh_css_set_acceleration_parameter(struct sh_css_acc_fw *firmware,
-				  hrt_vaddress val, size_t size);
-
-/** @brief Set isp dmem parameters for acceleration.
- *
- * @param	firmware	Firmware of acceleration.
- * @param	val		Parameter value.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Set acceleration parameter to value <val>.
- * The parameter value is an isp pointer, i.e. allocated in DDR and mapped
- * to the CSS virtual address space.
- */
-enum sh_css_err
-sh_css_set_firmware_dmem_parameters(struct sh_css_fw_info *firmware,
-				    enum sh_css_isp_memories mem,
-				    hrt_vaddress val, size_t size);
-
-/** @brief Start acceleration.
- *
- * @param	firmware	Firmware of acceleration.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Start acceleration of firmware.
- * Load the firmware if not yet loaded.
- */
-enum sh_css_err
-sh_css_start_acceleration(struct sh_css_acc_fw *firmware);
-
-/** @brief Signal termination of acceleration.
- *
- * @param	firmware	Firmware of acceleration.
- *
- * To be called when acceleration has terminated.
- */
-void
-sh_css_acceleration_done(struct sh_css_acc_fw *firmware);
-
-/** @brief Abort current acceleration.
- *
- * @param	firmware	Firmware of acceleration.
- * @param	deadline	Deadline in microseconds.
- *
- * Abort acceleration within <deadline> microseconds
- */
-void
-sh_css_abort_acceleration(struct sh_css_acc_fw *firmware, unsigned deadline);
-
-/** @brief Stop the acceleration pipe
- *
- * @return	       IA_CSS_SUCCESS or error code upon error.
- *
- * This function stops the acceleration pipe that's running. Note that any
- * dependent pipes will also be stopped automatically since otherwise
- * they would starve because they no longer receive input data.
- */
-enum sh_css_err
-sh_css_acceleration_stop(void);
-
-/** @brief Append a stage to pipeline.
- *
- * @param	pipeline	Pointer to the pipeline to be extended.
- * @param[in]	isp_fw		ISP firmware of new stage.
- * @param[in]	in		The input frame to the stage.
- * @param[in]	out		The output frame of the stage.
- * @param[in]	vf		The viewfinder frame of the stage.
- * @return			IA_CSS_SUCCESS or error code upon error.
- *
- * Append a new stage to *pipeline. When *pipeline is NULL, it will be created.
- * The stage consists of an ISP binary <isp_fw> and input and output arguments.
-*/
-enum sh_css_err
-sh_css_append_stage(void **pipeline,
-		    const char *isp_fw,
-		    struct sh_css_frame *in,
-		    struct sh_css_frame *out,
-		    struct sh_css_frame *vf);
-
-/** @brief Create an empty pipeline.
- */
-extern void *sh_css_create_pipeline(void);
-
-/** @brief Add an accelerator stage to a pipeline.
- *
- * @param	pipeline	The pipeline to be appended to.
- * @param	acc_fw		The fw descriptor of the new stage
- */
-extern enum sh_css_err sh_css_pipeline_add_acc_stage(
-	void		*pipeline,
-	const void	*acc_fw);
-
-/** @brief Destroy a pipeline.
- *
- * @param	pipeline	The pipeline to be destroyed.
- *
- * Recursively destroys the pipeline stages as well
- */
-extern void sh_css_destroy_pipeline(
-	void		*pipeline);
-
-/** @brief Start a pipeline.
- *
- * @param	pipe_id		The pipe id where to run the pipeline. (Huh ?)
- * @param	pipeline	The pipeline to be executed.
- *
- * Start a pipeline, does not wait until the pipeline completes.
- */
-void
-sh_css_start_pipeline(enum sh_css_pipe_id pipe_id, void *pipeline);
-
-/** @brief Close a pipeline.
- *
- * @param	pipeline	The pipeline to be closed.
- *
- * Close a pipeline and free all memory allocated to it.
- */
-void
-sh_css_close_pipeline(void *pipeline);
-
-/** @brief Run a single stage pipeline.
- *
- * @param[in]	isp_fw	ISP firmware of new pipeline.
- * @param[in]	in	The input frame to the pipeline.
- * @param[in]	out	The output frame of the pipeline.
- * @param[in]	vf	The viewfinder frame of the pipeline.
- * @return		IA_CSS_SUCCESS or error code upon error.
- *
- * Run an isp binary <isp_fw> with input, output and vf frames.
- * This creates a temporary single stage pipeline.
- */
-enum sh_css_err
-sh_css_run_isp_firmware(const char *isp_fw,
-			struct sh_css_frame *in,
-			struct sh_css_frame *out,
-			struct sh_css_frame *vf);
-
-/** @brief Initialize the buffer queues in SP dmem
- *
- * This function needs to be called after sh_css_start() and before
- * sh_css_queue_buffers()
- */
-
-void
-sh_css_init_buffer_queues(void);
-
-/** @brief send a invalidate mmu tlb command to SP
- *
- * As we allocate buffers in hmm space at runtime, we need to force updating
- * the TLB inside mmu by invalidating it atleast after each allocation. This
- * function will be called in the hmm library of driver.
- */
-
-void
-sh_css_enable_sp_invalidate_tlb(void);
-
-/** @brief send a request flash command to SP
- *
- * Driver needs to call this function to send a flash request command
- * to SP, SP will be responsible for switching on/off the flash at proper
- * time. Due to the SP multi-threading environment, this request may have
- * one-frame delay, the driver needs to check the flashed flag in frame info
- * to determine which frame is being flashed.
- */
-void
-sh_css_request_flash(void);
-
-/** @brief Set the isp pipe version for video.
- *
- * @param	version	Version of isp pipe (1 or 2).
- *
- * Set the version of isp pipe for video. Default is 1.
- */
-void
-sh_css_video_set_isp_pipe_version(unsigned int version);
-
-/** @brief initialize host-sp control variables.
- *
- */
-void
-sh_css_init_host_sp_control_vars(void);
-
-/** @brief allocate continuous raw frames for continuous capture
- *
- *  because this allocation takes a long time (around 120ms per frame),
- *  we separate the allocation part and update part to let driver call
- *  this function without locking. This function is the allocation part
- *  and next one is update part
- */
-enum sh_css_err
-sh_css_allocate_continuous_frames(
-	bool init_time);
-
-/** @brief allocate continuous raw frames for continuous capture
- *
- *  because this allocation takes a long time (around 120ms per frame),
- *  we separate the allocation part and update part to let driver call
- *  this function without locking. This function is the update part
- */
-void
-sh_css_update_continuous_frames(void);
-
-void
-sh_css_set_cont_prev_start_time(unsigned int overlap);
-
-/* For convenience, so users only need to include sh_css.h
- * To be removed: the remaining sh_css_params functions should move to here.
- */
-#include "sh_css_params.h"
-
-#endif /* __HOST__ */
-
-#endif /* _SH_CSS_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.c
deleted file mode 100644
index a63b8e0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.c
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "sh_css_accelerate.h"
-
-#include "sh_css_hrt.h"		/* sh_css_hrt_sp_wait() */
-#include "sh_css_sp_start.h"
-#include "sh_css_sp.h"
-#include "sh_css_internal.h"
-
-#include "memory_access.h"
-#include "mmu_device.h"
-
-#define __INLINE_SP__
-#include "sp.h"
-
-#if !defined(C_RUN) && !defined(HRT_UNSCHED)
-static const unsigned char *
-upload_isp_code(const struct sh_css_fw_info *firmware)
-{
-	const unsigned char *binary = firmware->isp_code;
-	if (!binary) {
-		unsigned size = firmware->blob.size;
-		const unsigned char *blob;
-		const unsigned char *binary_name;
-		binary_name =
-			(const unsigned char *)(SH_CSS_EXT_ISP_PROG_NAME(
-						firmware));
-		blob = binary_name +
-			strlen((const char *)binary_name) +
-			1;
-		binary = (const unsigned char *)HOST_ADDRESS(
-			sh_css_load_blob(blob, size));
-		((struct sh_css_fw_info *)firmware)->isp_code = binary;
-		((struct sh_css_fw_info *)firmware)->info.isp.xmem_addr =
-			(hrt_vaddress)HOST_ADDRESS(binary);
-	}
-
-	if (!binary)
-		return NULL;
-	return binary;
-}
-
-static const unsigned char *
-sh_css_acc_upload_isp_code(const struct sh_css_acc_fw *firmware)
-{
-	struct sh_css_acc_fw_hdr *header
-		= (struct sh_css_acc_fw_hdr *)&firmware->header;
-	const unsigned char *binary = firmware->header.isp_code;
-
-	if (!binary) {
-		const unsigned char *blob = SH_CSS_ACC_ISP_CODE(firmware);
-		unsigned size		  = SH_CSS_ACC_ISP_SIZE(firmware);
-		binary = (const unsigned char *)HOST_ADDRESS(
-			sh_css_load_blob(blob, size));
-		header->isp_code = binary;
-	}
-
-	if (!binary)
-		return NULL;
-	sp_dmem_store(SP0_ID, HOST_ADDRESS(header->sp.isp_code),
-			     &binary, sizeof(binary));
-	return binary;
-}
-#endif
-
-static void
-upload_var(void *sp_address, void *val, size_t size)
-{
-	if (!sp_address)
-		return;
-	sp_dmem_store(SP0_ID, HOST_ADDRESS(sp_address), val, size);
-}
-
-static void
-upload_int(unsigned *sp_address, unsigned *val)
-{
-	upload_var(sp_address, val, sizeof(unsigned));
-}
-
-/* Load the firmware into xmem */
-enum sh_css_err
-sh_css_acc_load(const struct sh_css_acc_fw *firmware)
-{
-	struct sh_css_acc_fw_hdr *header
-		= (struct sh_css_acc_fw_hdr *)&firmware->header;
-
-	header->loaded = true;
-	return sh_css_success;
-}
-
-void
-sh_css_acc_unload(const struct sh_css_acc_fw *firmware)
-{
-	struct sh_css_acc_fw_hdr *header
-		= (struct sh_css_acc_fw_hdr *)&firmware->header;
-	struct sh_css_acc_sp *sp = &header->sp;
-	if (sp->code)
-		mmgr_free(HOST_ADDRESS(sp->code));
-	if (header->isp_code)
-		mmgr_free(HOST_ADDRESS(header->isp_code));
-	sp->code  = NULL;
-	header->isp_code = NULL;
-	header->loaded   = false;
-}
-
-/* Load the firmware into xmem */
-enum sh_css_err
-sh_css_acc_load_extension(const struct sh_css_fw_info *firmware)
-{
-#if !defined(C_RUN) && !defined(HRT_UNSCHED)
-	const unsigned char *isp_program
-			= upload_isp_code(firmware);
-	if (isp_program == NULL)
-		return sh_css_err_cannot_allocate_memory;
-#endif
-
-	((struct sh_css_fw_info *)firmware)->loaded = true;
-	return sh_css_success;
-}
-
-void
-sh_css_acc_unload_extension(const struct sh_css_fw_info *firmware)
-{
-	if (firmware->isp_code)
-		mmgr_free(HOST_ADDRESS(firmware->isp_code));
-	((struct sh_css_fw_info *)firmware)->isp_code = NULL;
-	((struct sh_css_fw_info *)firmware)->loaded = false;
-}
-
-/* Set acceleration parameter to value <val> */
-enum sh_css_err
-sh_css_acc_set_parameter(struct sh_css_acc_fw *firmware,
-			 struct sh_css_hmm_section parameters)
-{
-	firmware->header.parameters = parameters;
-	return sh_css_success;
-}
-
-/* Set firmware parameters to value <parameters> */
-enum sh_css_err
-sh_css_acc_set_firmware_parameters(struct sh_css_fw_info *firmware,
-			 enum sh_css_isp_memories mem,
-			 struct sh_css_hmm_section parameters)
-{
-	firmware->memory_interface[mem].parameters = parameters;
-	return sh_css_success;
-}
-
-static void
-sh_css_acc_init(struct sh_css_acc_fw *firmware)
-{
-	struct sh_css_acc_sp *sp = &firmware->header.sp;
-	unsigned sp_address = (unsigned)HOST_ADDRESS(
-			sp->fw.info.sp.ddr_parameter_address);
-	unsigned sp_size = (unsigned)HOST_ADDRESS(
-			sp->fw.info.sp.ddr_parameter_size);
-	unsigned value = firmware->header.parameters.ddr_address;
-	unsigned size  = firmware->header.parameters.ddr_size;
-/* MW: "sp_address" is an offset address, 0 is a legal value*/
-	if (sp_address != 0) {
-		sp_dmem_store(SP0_ID, sp_address, &value, sizeof(value));
-		sp_dmem_store(SP0_ID, sp_size, &size, sizeof(size));
-	}
-}
-
-/* Start the sp, which will start the isp.
-*/
-enum sh_css_err
-sh_css_acc_start(struct sh_css_acc_fw *firmware)
-{
-	struct sh_css_acc_fw_hdr *header
-		= (struct sh_css_acc_fw_hdr *)&firmware->header;
-	struct sh_css_acc_sp *sp = &header->sp;
-	bool is_extension = header->type != SH_CSS_ACC_STANDALONE;
-	const struct sh_css_fw_info *sp_fw = &sp->fw;
-	const unsigned char *sp_program;
-#if !defined(C_RUN) && !defined(HRT_UNSCHED)
-	const unsigned char *isp_program;
-#endif
-
-	*(const void **)&sp_fw->blob.text = SH_CSS_ACC_SP_CODE(firmware);
-	*(const void **)&sp_fw->blob.data = SH_CSS_ACC_SP_DATA(firmware);
-
-	if (!header->loaded)
-		return sh_css_err_invalid_arguments;
-	if (is_extension)
-		return sh_css_err_invalid_arguments;
-
-	/* NOTE: sp accelerators have their (shared buffer pointer)
-	 * arguments flushed in "atomisp_acc_start()"
-	 */
-	if (is_extension)
-		sh_css_flush(firmware);
-
-	sp_program = (const unsigned char *)HOST_ADDRESS(
-		sh_css_sp_load_program(sp_fw,
-		SH_CSS_ACC_SP_PROG_NAME(firmware),
-		(hrt_vaddress)HOST_ADDRESS(sp->code)));
-	if (sp_program == NULL)
-		return sh_css_err_cannot_allocate_memory;
-	sp->code = sp_program;
-#if !defined(C_RUN) && !defined(HRT_UNSCHED)
-	isp_program = sh_css_acc_upload_isp_code(firmware);
-	if (isp_program == NULL)
-		return sh_css_err_cannot_allocate_memory;
-#endif
-
-#ifdef C_RUN
-	sp->init(firmware);
-#endif
-	sh_css_acc_init(firmware);
-
-	/* Start the firmware on the sp, which will start the isp */
-#ifdef C_RUN
-	/* No need to run the dmem_init in crun */
-	sh_css_sp_do_invalidate_mmu();
-	csim_processor_set_crun_func(SP, sp->entry);
-	hrt_ctl_run(SP, 1);
-	hrt_ctl_start(SP);
-	hrt_sleep();
-/* MW: sp->entry is a pointer, yet the entry points are relative addresses and thus 32-bit */
-#elif defined(HRT_CSIM)
-	sh_css_sp_do_invalidate_mmu();
-	_hrt_cell_start(SP, HOST_ADDRESS(sp->entry));
-#else
-	sh_css_sp_start((unsigned int)HOST_ADDRESS(sp->entry));
-#endif
-	return sh_css_success;
-}
-
-/* To be called when acceleration has terminated.
-*/
-void
-sh_css_acc_done(struct sh_css_acc_fw *firmware)
-{
-	(void)firmware;
-}
-
-void
-sh_css_acc_wait(void)
-{
-	sh_css_hrt_sp_wait();
-}
-
-/* Flag abortion of acceleration */
-void sh_css_acc_abort(struct sh_css_acc_fw *firmware)
-{
-	unsigned int t = true;
-	upload_int(firmware->header.sp.css_abort, &t);
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.h
deleted file mode 100644
index 7ee35fa..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_accelerate.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_ACCELERATE_H_
-#define _SH_CSS_ACCELERATE_H_
-
-#include "sh_css_types.h"
-
-/* Load the firmware into xmem */
-enum sh_css_err
-sh_css_acc_load(const struct sh_css_acc_fw *firmware);
-
-/* Unload the firmware*/
-void
-sh_css_acc_unload(const struct sh_css_acc_fw *firmware);
-
-/* Load the firmware into xmem */
-enum sh_css_err
-sh_css_acc_load_extension(const struct sh_css_fw_info *firmware);
-
-/* Unload the firmware*/
-void
-sh_css_acc_unload_extension(const struct sh_css_fw_info *firmware);
-
-/* Unload the firmware*/
-void
-sh_css_acc_unload_extension(const struct sh_css_fw_info *firmware);
-
-/* Set acceleration parameter to value <val> for isp dmem */
-enum sh_css_err
-sh_css_acc_set_parameter(struct sh_css_acc_fw *firmware,
-			 struct sh_css_hmm_section parameters);
-
-/* Set acceleration parameters to value <parameters> for memory <mem> */
-enum sh_css_err
-sh_css_acc_set_firmware_parameters(struct sh_css_fw_info *firmware,
-			 enum sh_css_isp_memories mem,
-			 struct sh_css_hmm_section parameters);
-
-/* Get type for argument <num> */
-enum sh_css_acc_arg_type
-sh_css_argument_type(struct sh_css_acc_fw *firmware, unsigned int num);
-
-/* Set host private data for argument <num> */
-enum sh_css_err
-sh_css_argument_set_host(struct sh_css_acc_fw *firmware,
-			 unsigned num, void *host);
-
-/* Get host private data for argument <num> */
-void *
-sh_css_argument_get_host(struct sh_css_acc_fw *firmware, unsigned num);
-
-/* Get size for argument <num> */
-size_t
-sh_css_argument_get_size(struct sh_css_acc_fw *firmware, unsigned num);
-
-/* Get the number of accelerator arguments */
-unsigned
-sh_css_num_accelerator_args(struct sh_css_acc_fw *firmware);
-
-/* Destabilize argument <num>, i.e. flush it from the cache */
-void
-sh_css_acc_stabilize(struct sh_css_acc_fw *firmware, unsigned num, bool stable);
-
-/* Check stability of argument <num> */
-bool
-sh_css_acc_is_stable(struct sh_css_acc_fw *firmware, unsigned num);
-
-/* Start the sp, which will start the isp.
-   Load the firmware if not yet loaded.
-*/
-enum sh_css_err
-sh_css_acc_start(struct sh_css_acc_fw *firmware);
-
-/* To be called when acceleration has terminated.
-*/
-void
-sh_css_acc_done(struct sh_css_acc_fw *firmware);
-
-/* Wait for the firmware to terminate */
-void
-sh_css_acc_wait(void);
-
-/* Flag abortion of acceleration */
-void sh_css_acc_abort(struct sh_css_acc_fw *firmware);
-
-#endif /* _SH_CSS_ACCELERATE_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.c
deleted file mode 100644
index 1da2b7e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.c
+++ /dev/null
@@ -1,872 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include <gdc_device.h>	/* HR_GDC_N */
-
-#include "sh_css_binary.h"
-
-#include "sh_css_debug.h"
-
-#include "sh_css.h"
-#include "sh_css_internal.h"
-#include "sh_css_sp.h"
-#include "sh_css_firmware.h"
-#include "sh_css_defs.h"
-
-#include "memory_access.h"
-
-#include "assert_support.h"
-
-static struct sh_css_binary_info *all_binaries; /* ISP binaries only (no SP) */
-static struct sh_css_binary_info *binary_infos[SH_CSS_BINARY_NUM_MODES] = {NULL, };
-
-enum sh_css_err
-sh_css_binary_grid_info(struct sh_css_binary *binary,
-			struct sh_css_grid_info *info)
-{
-	struct sh_css_3a_grid_info *s3a_info;
-	struct sh_css_dvs_grid_info *dvs_info;
-
-	assert(binary != NULL);
-	assert(info != NULL);
-	if ((binary == NULL) || (info == NULL)) {
-		return sh_css_err_internal_error;
-	}
-	s3a_info = &info->s3a_grid;
-	dvs_info = &info->dvs_grid;
-
-	info->isp_in_width = binary->internal_frame_info.width;
-	info->isp_in_height = binary->internal_frame_info.height;
-
-	/* for DIS, we use a division instead of a ceil_div. If this is smaller
-	 * than the 3a grid size, it indicates that the outer values are not
-	 * valid for DIS.
-	 */
-	dvs_info->enable            = binary->info->enable.dis;
-	dvs_info->width             = binary->dis_ver_proj_num_3a;
-	dvs_info->height            = binary->dis_hor_proj_num_3a;
-	dvs_info->aligned_width     = binary->dis_ver_proj_num_isp;
-	dvs_info->aligned_height    = binary->dis_hor_proj_num_isp;
-	dvs_info->bqs_per_grid_cell = 1 << binary->dis_deci_factor_log2;
-	info->dvs_hor_coef_num      = binary->dis_hor_coef_num_3a;
-	info->dvs_ver_coef_num      = binary->dis_ver_coef_num_3a;
-
-	/* 3A statistics grid */
-	s3a_info->enable            = binary->info->enable.s3a;
-	s3a_info->width             = binary->s3atbl_width;
-	s3a_info->height            = binary->s3atbl_height;
-	s3a_info->aligned_width     = binary->s3atbl_isp_width;
-	s3a_info->aligned_height    = binary->s3atbl_isp_height;
-	s3a_info->bqs_per_grid_cell = (1 << binary->deci_factor_log2);
-	s3a_info->use_dmem          = binary->info->s3atbl_use_dmem;
-
-	return sh_css_success;
-}
-
-static void
-init_pc_histogram(struct sh_css_pc_histogram *histo)
-{
-	assert(histo != NULL);
-	if (histo == NULL) {
-		sh_css_dtrace(SH_DBG_ERROR,
-		"init_pc_histogram(): error: histo is NULL\n");
-		return;
-	}
-
-	histo->length = 0;
-	histo->run = NULL;
-	histo->stall = NULL;
-}
-
-static void
-init_metrics(struct sh_css_binary_metrics *metrics,
-	     const struct sh_css_binary_info *info)
-{
-	assert(metrics != NULL);
-	assert(info != NULL);
-	if ((metrics == NULL) || (info == NULL)) {
-		sh_css_dtrace(SH_DBG_ERROR,
-		"init_metrics(): error: metrics or info is NULL\n");
-		return;
-	}
-
-	metrics->mode = info->mode;
-	metrics->id   = info->id;
-	metrics->next = NULL;
-	init_pc_histogram(&metrics->isp_histogram);
-	init_pc_histogram(&metrics->sp_histogram);
-}
-
-static bool
-supports_output_format(const struct sh_css_binary_info *info,
-		       enum sh_css_frame_format format)
-{
-	int i;
-
-	assert(info != NULL);
-	if (info == NULL)
-		return false;
-
-	for (i = 0; i < info->num_output_formats; i++) {
-		if (info->output_formats[i] == format)
-			return true;
-	}
-	return false;
-}
-
-static enum sh_css_err
-init_binary_info(struct sh_css_binary_info *info, unsigned int i,
-		 bool *binary_found)
-{
-	const unsigned char *blob = sh_css_blob_info[i].blob;
-	unsigned size = sh_css_blob_info[i].header.blob.size;
-
-	assert(info != NULL);
-	assert(binary_found != NULL);
-	if ((info == NULL) || (binary_found == NULL))
-		return sh_css_err_internal_error;
-
-	*info = sh_css_blob_info[i].header.info.isp;
-	*binary_found = blob != NULL;
-	info->blob_index = i;
-	/* we don't have this binary, skip it */
-	if (!size)
-		return sh_css_success;
-
-	info->xmem_addr = sh_css_load_blob(blob, size);
-	if (!info->xmem_addr)
-		return sh_css_err_cannot_allocate_memory;
-	return sh_css_success;
-}
-
-/* When binaries are put at the beginning, they will only
- * be selected if no other primary matches.
- */
-enum sh_css_err
-sh_css_init_binary_infos(void)
-{
-	unsigned int i;
-	unsigned int num_of_isp_binaries = sh_css_num_binaries - 1;
-
-	all_binaries = sh_css_malloc(num_of_isp_binaries *
-						sizeof(*all_binaries));
-	if (all_binaries == NULL)
-		return sh_css_err_cannot_allocate_memory;
-
-	for (i = 0; i < num_of_isp_binaries; i++) {
-		enum sh_css_err ret;
-		struct sh_css_binary_info *binary = &all_binaries[i];
-		bool binary_found;
-
-		if (binary != NULL) {
-			ret = init_binary_info(binary, i, &binary_found);
-			if (ret != sh_css_success)
-				return ret;
-			if (!binary_found)
-				continue;
-			/* Prepend new binary information */
-			binary->next = binary_infos[binary->mode];
-			binary_infos[binary->mode] = binary;
-			binary->blob = &sh_css_blob_info[i];
-		}
-	}
-	return sh_css_success;
-}
-
-enum sh_css_err
-sh_css_binary_uninit(void)
-{
-	unsigned int i;
-	struct sh_css_binary_info *b;
-
-	for (i = 0; i < SH_CSS_BINARY_NUM_MODES; i++) {
-		for (b = binary_infos[i]; b; b = b->next) {
-			if (b->xmem_addr)
-				mmgr_free(b->xmem_addr);
-			b->xmem_addr = mmgr_NULL;
-		}
-		binary_infos[i] = NULL;
-	}
-	sh_css_free(all_binaries);
-	return sh_css_success;
-}
-
-static int
-sh_css_grid_deci_factor_log2(int width, int height)
-{
-	int fact, fact1;
-	fact = 5;
-	while (ISP_BQ_GRID_WIDTH(width, fact - 1) <= SH_CSS_MAX_BQ_GRID_WIDTH &&
-	       ISP_BQ_GRID_HEIGHT(height, fact - 1) <= SH_CSS_MAX_BQ_GRID_HEIGHT
-	       && fact > 3)
-		fact--;
-
-	/* fact1 satisfies the specification of grid size. fact and fact1 is
-	   not the same for some resolution (fact=4 and fact1=5 for 5mp). */
-	if (width >= 2560)
-		fact1 = 5;
-	else if (width >= 1280)
-		fact1 = 4;
-	else
-		fact1 = 3;
-	return max(fact, fact1);
-}
-
-enum sh_css_err
-sh_css_fill_binary_info(const struct sh_css_binary_info *info,
-		 bool online,
-		 bool two_ppc,
-		 enum sh_css_input_format stream_format,
-		 const struct sh_css_frame_info *in_info, /* can be NULL */
-		 const struct sh_css_frame_info *out_info, /* can be NULL */
-		 const struct sh_css_frame_info *vf_info, /* can be NULL */
-		 struct sh_css_binary *binary,
-		 bool continuous)
-{
-	unsigned int dvs_env_width = 0,
-		     dvs_env_height = 0,
-		     vf_log_ds = 0,
-		     s3a_log_deci = 0,
-		     bits_per_pixel = 0,
-		     ds_input_width = 0,
-		     ds_input_height = 0,
-		     isp_input_width,
-		     isp_input_height,
-		     isp_internal_width,
-		     isp_internal_height,
-		     isp_output_width = 0,
-		     isp_output_height = 0,
-		     s3a_isp_width;
-	unsigned char enable_ds;
-	bool enable_yuv_ds;
-	bool enable_hus = false;
-	bool enable_vus = false;
-	bool is_out_format_rgba888 = false;
-	unsigned int tmp_width, tmp_height;
-	bool input_is_yuv_8 = input_format_is_yuv_8(stream_format);
-
-	assert(info != NULL);
-	assert(binary != NULL);
-	if ((info == NULL) || (binary == NULL))
-		return sh_css_err_internal_error;
-	enable_ds = info->enable.ds;
-	enable_yuv_ds = enable_ds & 2;
-
-	if (in_info != NULL) {
-		bits_per_pixel = in_info->raw_bit_depth;
-		if (out_info != NULL) {
-			enable_hus = in_info->width < out_info->width;
-			enable_vus = in_info->height < out_info->height;
-		}
-	}
-	if (out_info != NULL) {
-		isp_output_width  = out_info->padded_width;
-		isp_output_height = out_info->height;
-		is_out_format_rgba888 =
-			out_info->format == SH_CSS_FRAME_FORMAT_RGBA888;
-	}
-	(void)is_out_format_rgba888; /* Klocwork pacifier: VA_UNUSED.GEN */
-	if (info->enable.dvs_envelope) {
-		sh_css_video_get_dis_envelope(&dvs_env_width, &dvs_env_height);
-		dvs_env_width  = MAX(dvs_env_width, SH_CSS_MIN_DVS_ENVELOPE);
-		dvs_env_height = MAX(dvs_env_height, SH_CSS_MIN_DVS_ENVELOPE);
-	}
-	binary->dvs_envelope.width  = dvs_env_width;
-	binary->dvs_envelope.height = dvs_env_height;
-	if (vf_info != NULL) {
-		enum sh_css_err err;
-		err = sh_css_vf_downscale_log2(out_info, vf_info, &vf_log_ds);
-		if (err != sh_css_success)
-			return err;
-		vf_log_ds = min(vf_log_ds, info->max_vf_log_downscale);
-	}
-	if (online) {
-		bits_per_pixel = sh_css_input_format_bits_per_pixel(
-			stream_format, two_ppc);
-	}
-	if (in_info != NULL) {
-		ds_input_width  = in_info->padded_width + info->left_cropping;
-		ds_input_height = in_info->height + info->top_cropping;
-	}
-	if (enable_hus) /* { */
-		ds_input_width  += dvs_env_width;
-	/* } */
-	if (enable_vus) /* { */
-		ds_input_height += dvs_env_height;
-	/* } */
-	tmp_width  = (enable_yuv_ds && (ds_input_width > isp_output_width)) ?
-			ds_input_width  : isp_output_width;
-	tmp_height = (enable_yuv_ds && (ds_input_height > isp_output_height)) ?
-			ds_input_height : isp_output_height;
-
-	/* We first calculate the resolutions used by the ISP. After that,
-	 * we use those resolutions to compute sizes for tables etc. */
-	isp_internal_width = __ISP_INTERNAL_WIDTH(tmp_width,
-		dvs_env_width,
-		info->left_cropping, info->mode,
-		info->c_subsampling,
-		info->output_num_chunks, info->pipelining,
-		is_out_format_rgba888);
-	isp_internal_height = __ISP_INTERNAL_HEIGHT(tmp_height,
-		info->top_cropping,
-		dvs_env_height);
-	isp_input_width = _ISP_INPUT_WIDTH(isp_internal_width,
-		ds_input_width,
-		enable_ds || enable_hus);
-	isp_input_height = _ISP_INPUT_HEIGHT(isp_internal_height,
-		ds_input_height,
-		enable_ds || enable_vus);
-	s3a_isp_width = _ISP_S3A_ELEMS_ISP_WIDTH(isp_input_width,
-		isp_internal_width, enable_hus || enable_yuv_ds,
-		info->left_cropping);
-	if (info->fixed_s3a_deci_log)
-		s3a_log_deci = info->fixed_s3a_deci_log;
-	else
-		s3a_log_deci = sh_css_grid_deci_factor_log2(s3a_isp_width,
-							    isp_input_height);
-
-	/* In the yuv-copy binary, we have an internal buffer where the copy
-	 * writes its output. Then the padded width should be bus-aligned */
-	if (info->mode == SH_CSS_BINARY_MODE_COPY && input_is_yuv_8) {
-		isp_input_width = CEIL_MUL(isp_input_width,
-				2*HIVE_ISP_DDR_WORD_BYTES);
-	}
-
-	binary->vf_downscale_log2 = vf_log_ds;
-	binary->deci_factor_log2  = s3a_log_deci;
-	binary->input_buf_vectors =
-			SH_CSS_NUM_INPUT_BUF_LINES * _ISP_VECS(isp_input_width);
-	binary->online            = online;
-	binary->input_format      = stream_format;
-	/* input info */
-	if (in_info != NULL) {
-		binary->in_frame_info.format = in_info->format;
-		binary->in_frame_info.width = in_info->width +
-			info->left_cropping + dvs_env_width;
-	}
-	binary->in_frame_info.padded_width  = isp_input_width;
-	binary->in_frame_info.height        = isp_input_height;
-	binary->in_frame_info.raw_bit_depth = bits_per_pixel;
-	/* internal frame info */
-	if (out_info != NULL) /* { */
-		binary->internal_frame_info.format          = out_info->format;
-	/* } */
-	binary->internal_frame_info.width           = isp_internal_width;
-	binary->internal_frame_info.padded_width    = isp_internal_width;
-	binary->internal_frame_info.height          = isp_internal_height;
-	binary->internal_frame_info.raw_bit_depth   = bits_per_pixel;
-	/* output info */
-	if (out_info != NULL) {
-		binary->out_frame_info.format        = out_info->format;
-		binary->out_frame_info.width         = out_info->width;
-	}
-	binary->out_frame_info.padded_width  = isp_output_width;
-	binary->out_frame_info.height        = isp_output_height;
-	binary->out_frame_info.raw_bit_depth = bits_per_pixel;
-
-	/* viewfinder output info */
-	binary->vf_frame_info.format = SH_CSS_FRAME_FORMAT_YUV_LINE;
-	if ((vf_info != NULL) && (in_info != NULL)) {
-		unsigned int vf_out_vecs, vf_out_width, vf_out_height;
-		vf_out_vecs = __ISP_VF_OUTPUT_WIDTH_VECS(isp_output_width,
-			vf_log_ds);
-		vf_out_width = _ISP_VF_OUTPUT_WIDTH(vf_out_vecs);
-		vf_out_height = _ISP_VF_OUTPUT_HEIGHT(isp_output_height,
-			vf_log_ds);
-		/* If we are in continuous preview mode, then out port is
-		 * active instead of vfout port
-		 */
-		if (info->enable.raw_binning && continuous) {
-			binary->out_frame_info.width =
-				(in_info->width >> vf_log_ds);
-			binary->out_frame_info.padded_width = vf_out_width;
-			binary->out_frame_info.height       = vf_out_height;
-		} else {
-		/* we also store the raw downscaled width. This is used for
-		 * digital zoom in preview to zoom only on the width that
-		 * we actually want to keep, not on the aligned width. */
-			if (out_info == NULL)
-				return sh_css_err_internal_error;
-			binary->vf_frame_info.width =
-				(out_info->width >> vf_log_ds);
-			binary->vf_frame_info.padded_width = vf_out_width;
-			binary->vf_frame_info.height       = vf_out_height;
-		}
-	} else {
-		binary->vf_frame_info.width        = 0;
-		binary->vf_frame_info.padded_width = 0;
-		binary->vf_frame_info.height       = 0;
-	}
-
-	if (info->enable.ca_gdc) {
-		binary->morph_tbl_width =
-			_ISP_MORPH_TABLE_WIDTH(isp_internal_width);
-		binary->morph_tbl_aligned_width  =
-			_ISP_MORPH_TABLE_ALIGNED_WIDTH(isp_internal_width);
-		binary->morph_tbl_height =
-			_ISP_MORPH_TABLE_HEIGHT(isp_internal_height);
-	} else {
-		binary->morph_tbl_width  = 0;
-		binary->morph_tbl_aligned_width  = 0;
-		binary->morph_tbl_height = 0;
-	}
-	if (info->enable.sc)
-		binary->sctbl_width_per_color =
-			SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR;
-	else
-		binary->sctbl_width_per_color = 0;
-
-	if (info->enable.s3a) {
-		binary->s3atbl_width  =
-			_ISP_S3ATBL_WIDTH(binary->in_frame_info.width,
-				s3a_log_deci);
-		binary->s3atbl_height =
-			_ISP_S3ATBL_HEIGHT(binary->in_frame_info.height,
-				s3a_log_deci);
-		binary->s3atbl_isp_width =
-			_ISP_S3ATBL_ISP_WIDTH(
-				_ISP_S3A_ELEMS_ISP_WIDTH(isp_input_width,
-					isp_internal_width,
-					enable_hus || enable_yuv_ds,
-					info->left_cropping),
-					s3a_log_deci);
-		binary->s3atbl_isp_height =
-			_ISP_S3ATBL_ISP_HEIGHT(
-				_ISP_S3A_ELEMS_ISP_HEIGHT(isp_input_height,
-				isp_internal_height,
-				enable_vus || enable_yuv_ds),
-				s3a_log_deci);
-	} else {
-		binary->s3atbl_width  = 0;
-		binary->s3atbl_height = 0;
-		binary->s3atbl_isp_width  = 0;
-		binary->s3atbl_isp_height = 0;
-	}
-
-	if (info->enable.sc) {
-		binary->sctbl_width_per_color  =
-			_ISP_SCTBL_WIDTH_PER_COLOR(isp_input_width,
-				s3a_log_deci);
-		binary->sctbl_aligned_width_per_color =
-			SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR;
-		binary->sctbl_height =
-			_ISP_SCTBL_HEIGHT(isp_input_height, s3a_log_deci);
-	} else {
-		binary->sctbl_width_per_color         = 0;
-		binary->sctbl_aligned_width_per_color = 0;
-		binary->sctbl_height                  = 0;
-	}
-	if (info->enable.dis) {
-		binary->dis_deci_factor_log2 = SH_CSS_DIS_DECI_FACTOR_LOG2;
-		binary->dis_hor_coef_num_3a  =
-			_ISP_SDIS_HOR_COEF_NUM_3A(binary->in_frame_info.width,
-						  SH_CSS_DIS_DECI_FACTOR_LOG2);
-		binary->dis_ver_coef_num_3a  =
-			_ISP_SDIS_VER_COEF_NUM_3A(binary->in_frame_info.height,
-						  SH_CSS_DIS_DECI_FACTOR_LOG2);
-		binary->dis_hor_coef_num_isp =
-			_ISP_SDIS_HOR_COEF_NUM_ISP(
-				_ISP_SDIS_ELEMS_ISP(isp_input_width,
-				isp_internal_width,
-				enable_hus || enable_yuv_ds));
-		binary->dis_ver_coef_num_isp =
-			_ISP_SDIS_VER_COEF_NUM_ISP(
-				_ISP_SDIS_ELEMS_ISP(isp_input_height,
-				isp_internal_height,
-				enable_vus || enable_yuv_ds));
-		binary->dis_hor_proj_num_3a  =
-			_ISP_SDIS_HOR_PROJ_NUM_3A(binary->in_frame_info.height,
-						  SH_CSS_DIS_DECI_FACTOR_LOG2);
-		binary->dis_ver_proj_num_3a  =
-			_ISP_SDIS_VER_PROJ_NUM_3A(binary->in_frame_info.width,
-						  SH_CSS_DIS_DECI_FACTOR_LOG2);
-		binary->dis_hor_proj_num_isp =
-			__ISP_SDIS_HOR_PROJ_NUM_ISP(
-				_ISP_SDIS_ELEMS_ISP(isp_input_height,
-				isp_internal_height,
-				enable_vus || enable_yuv_ds),
-						SH_CSS_DIS_DECI_FACTOR_LOG2);
-		binary->dis_ver_proj_num_isp =
-			__ISP_SDIS_VER_PROJ_NUM_ISP(
-				_ISP_SDIS_ELEMS_ISP(isp_input_width,
-				isp_internal_width,
-				enable_hus || enable_yuv_ds),
-						SH_CSS_DIS_DECI_FACTOR_LOG2);
-	} else {
-		binary->dis_deci_factor_log2 = 0;
-		binary->dis_hor_coef_num_3a  = 0;
-		binary->dis_ver_coef_num_3a  = 0;
-		binary->dis_hor_coef_num_isp = 0;
-		binary->dis_ver_coef_num_isp = 0;
-		binary->dis_hor_proj_num_3a  = 0;
-		binary->dis_ver_proj_num_3a  = 0;
-		binary->dis_hor_proj_num_isp = 0;
-		binary->dis_ver_proj_num_isp = 0;
-	}
-	if (info->left_cropping)
-		binary->left_padding = 2 * ISP_VEC_NELEMS - info->left_cropping;
-	else
-		binary->left_padding = 0;
-
-	binary->info = info;
-
-	return sh_css_success;
-}
-
-enum sh_css_err
-sh_css_binary_find(struct sh_css_binary_descr *descr,
-		   struct sh_css_binary *binary,
-		   bool is_video_usecase /* TODO: Remove this */)
-{
-	int mode;
-	bool online;
-	bool two_ppc;
-	enum sh_css_input_format stream_format;
-	bool input_is_yuv_8;
-	const struct sh_css_frame_info *req_in_info,
-				       *req_out_info,
-				       *req_vf_info;
-
-	struct sh_css_frame_info *cc_in_info
-				= sh_css_malloc(sizeof(*req_in_info));
-	struct sh_css_frame_info *cc_out_info
-				= sh_css_malloc(sizeof(*req_out_info));
-	struct sh_css_frame_info *cc_vf_info
-				= sh_css_malloc(sizeof(*req_vf_info));
-
-	struct sh_css_binary_info *candidate;
-	unsigned int dvs_envelope_width = 0,
-		     dvs_envelope_height = 0;
-	bool need_ds = false,
-	     need_dz = false,
-	     need_dvs = false,
-	     need_outputdeci = false;
-	bool enable_yuv_ds;
-	bool enable_high_speed;
-	bool enable_dvs_6axis;
-	bool enable_reduced_pipe;
-	enum sh_css_err err = sh_css_err_internal_error;
-	bool continuous = sh_css_continuous_is_enabled();
-	unsigned int isp_pipe_version;
-
-	assert(descr != NULL);
-	if (descr == NULL)
-		return sh_css_err_internal_error;
-	assert(binary != NULL);
-	if (binary == NULL)
-		return sh_css_err_internal_error;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() enter: "
-		"descr=%p, (mode=%d), "
-		"binary=%p, "
-		"is_video_usecase=%d\n",
-		descr, descr->mode,
-		binary, (int)is_video_usecase);
-
-	mode = descr->mode;
-	online = descr->online;
-	two_ppc = descr->two_ppc;
-	stream_format = descr->stream_format;
-	input_is_yuv_8 = input_format_is_yuv_8(stream_format);
-	req_in_info = descr->in_info;
-	req_out_info = descr->out_info;
-	req_vf_info = descr->vf_info;
-
-	enable_yuv_ds = descr->enable_yuv_ds;
-	enable_high_speed = descr->enable_high_speed;
-	enable_dvs_6axis  = descr->enable_dvs_6axis;
-	enable_reduced_pipe = descr->enable_reduced_pipe;
-	isp_pipe_version = descr->isp_pipe_version;
-
-	if (cc_in_info == NULL || cc_out_info == NULL || cc_vf_info == NULL) {
-		sh_css_free(cc_in_info);
-		sh_css_free(cc_out_info);
-		sh_css_free(cc_vf_info);
-		return err;
-	}
-
-	if (mode == SH_CSS_BINARY_MODE_VIDEO) {
-		unsigned int dx, dy;
-		sh_css_get_zoom_factor(&dx, &dy);
-		sh_css_video_get_dis_envelope(&dvs_envelope_width,
-					      &dvs_envelope_height);
-		sh_css_video_get_enable_dz(&need_dz);
-		/* Video is the only mode that has a nodz variant. */
-		if (!need_dz)
-			need_dz = ((dx != HRT_GDC_N) || (dy != HRT_GDC_N));
-		need_dvs = dvs_envelope_width || dvs_envelope_height;
-	}
-
-	need_ds = req_in_info->width > req_out_info->width ||
-		  req_in_info->height > req_out_info->height;
-
-	/* In continuous mode, ds is not possible. Instead we are
-	 * allowed to have output decimation (vf_veceven) */
-	if (need_ds && continuous) {
-		need_ds = false;
-		need_outputdeci = true;
-	}
-
-	for (candidate = binary_infos[mode]; candidate;
-	     candidate = candidate->next) {
-		/* @GC: Input format is the differentiating factor in binary
-		 * selection for the copy binaries although we dont know which
-		 * binaries support which input format. We hack it as the
-		 * sequence of two copy binaries in FW is known to us.
-		 * TODO: Extend all binary defs with supported input format
-		 * field (see CR 1955) */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() candidate = %p, mode = %d ID = %d\n",candidate, candidate->mode, candidate->id);
-
-		if (mode == SH_CSS_BINARY_MODE_COPY && candidate->enable.ds &&
-		    (!input_is_yuv_8 || !is_video_usecase)/*TODO: change this*/) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%d == %d) && %d && (!%d || !%d)\n", __LINE__,
-			mode, SH_CSS_BINARY_MODE_COPY, candidate->enable.ds,
-			input_is_yuv_8, is_video_usecase);
-			continue;
-		}
-/*
- * MW: Only a limited set of jointly configured binaries can be used in a continuous preview/video mode
- * unless it is the copy mode and copy runs on SP
- */
-		if (!candidate->enable.continuous && continuous && (mode != SH_CSS_BINARY_MODE_COPY)) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d && (%d != %d)\n", __LINE__, candidate->enable.continuous, continuous, mode, SH_CSS_BINARY_MODE_COPY);
-			continue;
-		}
-
-		if (mode == SH_CSS_BINARY_MODE_VIDEO &&
-		    candidate->isp_pipe_version != isp_pipe_version) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%d == %d) && (%d != %d)\n", __LINE__,
-			mode, SH_CSS_BINARY_MODE_VIDEO, candidate->isp_pipe_version, isp_pipe_version);
-			continue;
-		}
-		if (!candidate->enable.reduced_pipe && enable_reduced_pipe) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.reduced_pipe, enable_reduced_pipe);
-			continue;
-		}
-		if (!candidate->enable.dvs_6axis && enable_dvs_6axis) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.dvs_6axis, enable_dvs_6axis);
-			continue;
-		}
-		if (candidate->enable.high_speed && !enable_high_speed) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: %d && !%d\n", __LINE__, candidate->enable.high_speed, enable_high_speed);
-			continue;
-		}
-		if (!(candidate->enable.ds & 2) && enable_yuv_ds) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, ((candidate->enable.ds & 2) != 0), enable_yuv_ds);
-			continue;
-		}
-		if ((candidate->enable.ds & 2) && !enable_yuv_ds) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: %d && !%d\n", __LINE__, ((candidate->enable.ds & 2) != 0), enable_yuv_ds);
-			continue;
-		}
-
-		if (mode == SH_CSS_BINARY_MODE_VIDEO &&
-		    candidate->enable.ds && need_ds)
-			need_dz = false;
-
-		if (mode != SH_CSS_BINARY_MODE_PREVIEW &&
-		    mode != SH_CSS_BINARY_MODE_COPY &&
-		    candidate->enable.vf_veceven && (req_vf_info == NULL)) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%d != %d) && (%d != %d) && %d && (%p == NULL)\n", __LINE__,
-			mode, SH_CSS_BINARY_MODE_PREVIEW, mode, SH_CSS_BINARY_MODE_COPY,
-			candidate->enable.vf_veceven, req_vf_info);
-			continue;
-		}
-		if ((req_vf_info != NULL) && !(candidate->enable.vf_veceven ||
-				     candidate->variable_vf_veceven)) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%p != NULL) && !(%d || %d)\n", __LINE__, req_vf_info, candidate->enable.vf_veceven, candidate->variable_vf_veceven);
-			continue;
-		}
-		if (!candidate->enable.dvs_envelope && need_dvs) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.dvs_envelope, (int)need_dvs);
-			continue;
-		}
-		if (dvs_envelope_width > candidate->max_dvs_envelope_width) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%d > %d)\n", __LINE__, dvs_envelope_width, candidate->max_dvs_envelope_width);
-			continue;
-		}
-		if (dvs_envelope_height > candidate->max_dvs_envelope_height) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%d > %d)\n", __LINE__, dvs_envelope_height, candidate->max_dvs_envelope_height);
-			continue;
-		}
-		if (!candidate->enable.ds && need_ds) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.ds, (int)need_ds);
-			continue;
-		}
-		if (!candidate->enable.uds && need_dz) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d\n", __LINE__, candidate->enable.uds, (int)need_dz);
-			continue;
-		}
-		if (online && candidate->input == SH_CSS_BINARY_INPUT_MEMORY) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: %d && (%d == %d)\n", __LINE__, online, candidate->input, SH_CSS_BINARY_INPUT_MEMORY);
-			continue;
-		}
-		if (!online && candidate->input == SH_CSS_BINARY_INPUT_SENSOR) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && (%d == %d)\n", __LINE__, online, candidate->input, SH_CSS_BINARY_INPUT_SENSOR);
-			continue;
-		}
-		if (req_out_info->padded_width < candidate->min_output_width ||
-		    req_out_info->padded_width > candidate->max_output_width) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%d > %d) || (%d < %d)\n", __LINE__,
-			req_out_info->padded_width, candidate->min_output_width,
-			req_out_info->padded_width, candidate->max_output_width);
-			continue;
-		}
-
-		if (req_in_info->padded_width > candidate->max_input_width) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: (%d > %d)\n", __LINE__, req_in_info->padded_width, candidate->max_input_width);
-			continue;
-		}
-		if (!supports_output_format(candidate, req_out_info->format)) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d\n", __LINE__, supports_output_format(candidate, req_out_info->format));
-			continue;
-		}
-
-/*
- * Select either a binary with conditional decimation or one with fixed decimation
- */
-		if (descr->binning && !(candidate->enable.raw_binning || candidate->enable.fixed_bayer_ds)) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: %d && !(%d || %d)\n", __LINE__, descr->binning, candidate->enable.raw_binning, candidate->enable.fixed_bayer_ds);
-			continue;
-		}
-/*
- * "candidate->enable.fixed_bayer_ds" is also used to get the correct buffer size reservation in the still capture and capture_pp binaries
- */
-		if (!descr->binning && candidate->enable.fixed_bayer_ds && ((mode == SH_CSS_BINARY_MODE_PREVIEW) || (mode == SH_CSS_BINARY_MODE_VIDEO))) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && %d && ((%d == %d) || (%d == %d))\n", __LINE__,
-		descr->binning, candidate->enable.fixed_bayer_ds, mode, SH_CSS_BINARY_MODE_PREVIEW, mode, SH_CSS_BINARY_MODE_VIDEO);
-			continue;
-		}
-
-		if (descr->binning) {
-			if (!candidate->enable.fixed_bayer_ds && (req_in_info->width > 3264)) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: !%d && (%d > %d)\n", __LINE__, candidate->enable.fixed_bayer_ds,req_in_info->width, 3264);
-				continue;
-			}
-			if (candidate->enable.fixed_bayer_ds  && (req_in_info->width <= 3264)) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() [%d] continue: %d && (%d <= %d)\n", __LINE__, candidate->enable.fixed_bayer_ds,req_in_info->width, 3264);
-				continue;
-		}
-		}
-
-/*
- * If we are in continuous preview mode, it is possible to have
- * an output decimation. If output decimation is needed, the
- * decimation factor is calculated output->vf. So, we switch
- * the ports to share the same calculation module
- *
- * There are 2 flavours, an optimised binary for very large resolutions
- * that always decimates, or a binary that conditionally decimates
- */
-		if ((candidate->enable.raw_binning || candidate->enable.fixed_bayer_ds)
-				&& continuous && need_outputdeci) {
-			*cc_in_info = *req_in_info;
-			*cc_out_info = *req_out_info;
-			*cc_vf_info = *req_out_info;
-
-			if (descr->binning) {
-			/* Take into account that we have (currently implicit)
-			 * a decimation on preview-ISP which halves the
-			 * resolution. Therefore, here we specify this. */
-				cc_out_info->width        = req_in_info->width/2;
-				cc_out_info->padded_width = req_in_info->padded_width/2;
-				cc_out_info->height       = req_in_info->height/2;
-
-				cc_in_info->width        = req_in_info->width/2;
-				cc_in_info->padded_width = req_in_info->padded_width/2;
-				cc_in_info->height       = req_in_info->height/2;
-			} else {
-				cc_out_info->width        = req_in_info->width;
-				cc_out_info->padded_width = req_in_info->padded_width;
-				cc_out_info->height       = req_in_info->height;
-			}
-		} else {
-			*cc_in_info  = *req_in_info;
-			*cc_out_info = *req_out_info;
-			if (req_vf_info != NULL) {
-				*cc_vf_info  = *req_vf_info;
-			} else {
-				sh_css_free(cc_vf_info);
-				cc_vf_info  = NULL;
-			}
-		}
-
-		/* reconfigure any variable properties of the binary */
-		err = sh_css_fill_binary_info(candidate, online, two_ppc,
-				       stream_format, cc_in_info,
-				       cc_out_info, cc_vf_info,
-				       binary, continuous);
-		if (err)
-			break;
-		init_metrics(&binary->metrics, binary->info);
-		break;
-	}
-
-	assert(candidate != NULL);
-	if(candidate == NULL)
-		return sh_css_err_internal_error;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() selected = %p, mode = %d ID = %d\n",candidate, candidate->mode, candidate->id);
-
-	sh_css_free(cc_in_info);
-	sh_css_free(cc_out_info);
-	sh_css_free(cc_vf_info);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_binary_find() leave: return_err=%d\n", err);
-
-	return err;
-}
-
-unsigned
-sh_css_max_vf_width(void)
-{
-  return binary_infos[SH_CSS_BINARY_MODE_VF_PP]->max_output_width;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.h
deleted file mode 100644
index b21cb1f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_binary.h
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_BINARY_H_
-#define _SH_CSS_BINARY_H_
-
-/* The binary mode is used in pre-processor expressions so we cannot
- * use an enum here. */
-#define SH_CSS_BINARY_MODE_COPY       0
-#define SH_CSS_BINARY_MODE_PREVIEW    1
-#define SH_CSS_BINARY_MODE_PRIMARY    2
-#define SH_CSS_BINARY_MODE_VIDEO      3
-#define SH_CSS_BINARY_MODE_PRE_ISP    4
-#define SH_CSS_BINARY_MODE_GDC        5
-#define SH_CSS_BINARY_MODE_POST_ISP   6
-#define SH_CSS_BINARY_MODE_ANR        7
-#define SH_CSS_BINARY_MODE_CAPTURE_PP 8
-#define SH_CSS_BINARY_MODE_VF_PP      9
-#define SH_CSS_BINARY_NUM_MODES       10
-
-/* Indicate where binaries can read input from */
-#define SH_CSS_BINARY_INPUT_SENSOR   0
-#define SH_CSS_BINARY_INPUT_MEMORY   1
-#define SH_CSS_BINARY_INPUT_VARIABLE 2
-
-#include "sh_css.h"
-#include "sh_css_metrics.h"
-
-struct sh_css_binary_descr {
-	int mode;
-	bool online;
-	bool continuous;
-	bool binning;
-	bool two_ppc;
-	bool enable_yuv_ds;
-	bool enable_high_speed;
-	bool enable_dvs_6axis;
-	bool enable_reduced_pipe;
-	enum sh_css_input_format stream_format;
-	struct sh_css_frame_info *in_info;
-	struct sh_css_frame_info *out_info;
-	struct sh_css_frame_info *vf_info;
-	unsigned int isp_pipe_version;
-};
-
-struct sh_css_binary {
-	const struct sh_css_binary_info *info;
-	enum sh_css_input_format input_format;
-	struct sh_css_frame_info in_frame_info;
-	struct sh_css_frame_info internal_frame_info;
-	struct sh_css_frame_info out_frame_info;
-	struct sh_css_frame_info vf_frame_info;
-	int                      input_buf_vectors;
-	int                      deci_factor_log2;
-	int                      dis_deci_factor_log2;
-	int                      vf_downscale_log2;
-	int                      s3atbl_width;
-	int                      s3atbl_height;
-	int                      s3atbl_isp_width;
-	int                      s3atbl_isp_height;
-	unsigned int             morph_tbl_width;
-	unsigned int             morph_tbl_aligned_width;
-	unsigned int             morph_tbl_height;
-	int                      sctbl_width_per_color;
-	int                      sctbl_aligned_width_per_color;
-	int                      sctbl_height;
-	int                      dis_hor_coef_num_3a;
-	int                      dis_ver_coef_num_3a;
-	int                      dis_hor_coef_num_isp;
-	int                      dis_ver_coef_num_isp;
-	int                      dis_hor_proj_num_3a;
-	int                      dis_ver_proj_num_3a;
-	int                      dis_hor_proj_num_isp;
-	int                      dis_ver_proj_num_isp;
-	struct sh_css_dvs_envelope dvs_envelope;
-	bool                     online;
-	unsigned int             uds_xc;
-	unsigned int             uds_yc;
-	unsigned int             left_padding;
-	struct sh_css_binary_metrics metrics;
-};
-
-#define DEFAULT_FRAME_INFO \
-{ \
-	0,                          /* width */\
-	0,                          /* height */\
-	0,                          /* padded_width */\
-	N_SH_CSS_FRAME_FORMAT,		/* format */\
-	0,                          /* raw_bit_depth */\
-	N_sh_css_bayer_order		/* raw_bayer_order */\
-}
-
-#define DEFAULT_BINARY_SETTINGS \
-{ \
-	NULL, \
-	N_SH_CSS_INPUT_FORMAT, \
-	DEFAULT_FRAME_INFO, \
-	DEFAULT_FRAME_INFO, \
-	DEFAULT_FRAME_INFO, \
-	DEFAULT_FRAME_INFO, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	0, \
-	{ 0,0 },		/* dvs_envelope_info */			\
-	false,			/* online */				\
-	0, 			/* uds_xc */				\
-	0, 			/* uds_yc */				\
-	0, 			/* left_padding */			\
-	DEFAULT_BINARY_METRICS	/* metrics */				\
-}
-
-enum sh_css_err
-sh_css_init_binary_infos(void);
-
-enum sh_css_err
-sh_css_binary_uninit(void);
-
-enum sh_css_err
-sh_css_fill_binary_info(const struct sh_css_binary_info *info,
-		 bool online,
-		 bool two_ppc,
-		 enum sh_css_input_format stream_format,
-		 const struct sh_css_frame_info *in_info,
-		 const struct sh_css_frame_info *out_info,
-		 const struct sh_css_frame_info *vf_info,
-		 struct sh_css_binary *binary,
-		 bool continuous);
-
-enum sh_css_err
-sh_css_binary_find(struct sh_css_binary_descr *descr,
-		   struct sh_css_binary *binary,
-		   bool is_video_usecase /* TODO: Remove this */);
-
-enum sh_css_err
-sh_css_binary_grid_info(struct sh_css_binary *binary,
-			struct sh_css_grid_info *info);
-
-unsigned
-sh_css_max_vf_width(void);
-
-void sh_css_binary_init(struct sh_css_binary *binary);
-
-#endif /* _SH_CSS_BINARY_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c
deleted file mode 100644
index 13c06b8..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.c
+++ /dev/null
@@ -1,2069 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-#include "debug.h"
-#include "memory_access.h"
-
-#include "sh_css_debug.h"
-#include "sh_css_debug_internal.h"
-
-#include "assert_support.h"
-#include "print_support.h"
-/*#include <stdio.h>*/	/* snprintf() */
-
-#include "fifo_monitor.h"
-#include "input_formatter.h"
-#include "dma.h"
-#include "irq.h"
-#include "gp_device.h"
-#include "sp.h"
-#include "isp.h"
-#include "mmu_device.h"
-
-#include "sh_css.h"
-#include "sh_css_internal.h"
-#include "sh_css_rx.h"
-#include "sh_css_sp.h"	/* sh_css_sp_get_debug_state() */
-
-/* Global variable to store the dtrace verbosity level */
-unsigned int sh_css_trace_level;
-
-void sh_css_set_dtrace_level(
-	const unsigned int	trace_level)
-{
-	sh_css_trace_level = trace_level;
-return;
-}
-
-static void print_sp_state(
-	const sp_state_t	*state,
-	const char			*cell)
-{
-	sh_css_dtrace(2, "%s state:\n", cell);
-	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "PC", state->pc);
-	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "Status register",
-			state->status_register);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is broken", state->is_broken);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is idle", state->is_idle);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is sleeping", state->is_sleeping);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is stalling", state->is_stalling);
-return;
-}
-
-static void print_isp_state(
-	const isp_state_t	*state,
-	const char			*cell)
-{
-	sh_css_dtrace(2, "%s state:\n", cell);
-	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "PC", state->pc);
-	sh_css_dtrace(2, "\t%-32s: 0x%X\n", "Status register",
-			state->status_register);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is broken", state->is_broken);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is idle", state->is_idle);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is sleeping", state->is_sleeping);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "Is stalling", state->is_stalling);
-return;
-}
-
-void sh_css_dump_isp_state(void)
-{
-	isp_state_t		state;
-	isp_stall_t		stall;
-
-	isp_get_state(ISP0_ID, &state, &stall);
-
-	print_isp_state(&state, "ISP");
-
-	if (state.is_stalling) {
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[0] if_prim_a_FIFO stalled",
-				stall.fifo0);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[1] if_prim_b_FIFO stalled",
-				stall.fifo1);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[2] dma_FIFO stalled",
-				stall.fifo2);
-#if defined(HAS_ISP_2400_MAMOIADA) || defined(HAS_ISP_2400A0_MAMOIADA)
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[3] gdc0_FIFO stalled",
-				stall.fifo3);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[4] gdc1_FIFO stalled",
-				stall.fifo4);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[5] gpio_FIFO stalled",
-				stall.fifo5);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[6] sp_FIFO stalled",
-				stall.fifo6);
-#elif defined(HAS_ISP_2300_MEDFIELD) || defined(HAS_ISP_2300_MEDFIELD_DEMO)
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[3] gdc_FIFO stalled",
-				stall.fifo3);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[4] gpio_FIFO stalled",
-				stall.fifo4);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "[5] sp_FIFO stalled",
-				stall.fifo5);
-#else
-#error "sh_css_debug: ISP cell must be \
-	one of {2300_MEDFIELD, 2300_MEDFIELD_DEMO, 2400_MAMOIADA}"
-#endif
-		sh_css_dtrace(2, "\t%-32s: %d\n", "status & control stalled",
-				stall.stat_ctrl);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "dmem stalled",
-				stall.dmem);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "vmem stalled",
-				stall.vmem);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "vamem1 stalled",
-				stall.vamem1);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "vamem2 stalled",
-				stall.vamem2);
-#if defined(HAS_ISP_2400_MAMOIADA) || defined(HAS_ISP_2400A0_MAMOIADA)
-		sh_css_dtrace(2, "\t%-32s: %d\n", "vamem3 stalled",
-				stall.vamem3);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "hmem stalled",
-				stall.hmem);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "pmem stalled",
-				stall.pmem);
-#endif
-	}
-return;
-}
-
-void sh_css_dump_sp_state(void)
-{
-	sp_state_t		state;
-	sp_stall_t		stall;
-	sp_get_state(SP0_ID, &state, &stall);
-	print_sp_state(&state, "SP");
-	if (state.is_stalling) {
-#if defined(HAS_SP_2400) || defined(HAS_SP_2400A0)
-		sh_css_dtrace(2, "\t%-32s: %d\n", "isys_FIFO stalled",
-				stall.fifo0);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "if_sec_FIFO stalled",
-				stall.fifo1);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "str_to_mem_FIFO stalled",
-				stall.fifo2);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "dma_FIFO stalled",
-				stall.fifo3);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_a_FIFO stalled",
-				stall.fifo4);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "isp_FIFO stalled",
-				stall.fifo5);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "gp_FIFO stalled",
-				stall.fifo6);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_b_FIFO stalled",
-				stall.fifo7);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "gdc0_FIFO stalled",
-				stall.fifo8);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "gdc1_FIFO stalled",
-				stall.fifo9);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "irq FIFO stalled",
-				stall.fifoa);
-#elif defined(HAS_SP_2300) || defined(HAS_SP_2300_DEMO)
-		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_a_FIFO stalled",
-				stall.fifo0);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "if_sec_FIFO stalled",
-				stall.fifo1);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "str_to_mem_FIFO stalled",
-				stall.fifo2);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "dma_FIFO stalled",
-				stall.fifo3);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "gdc_FIFO stalled",
-				stall.fifo4);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "isp_FIFO stalled",
-				stall.fifo5);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "gp_FIFO stalled",
-				stall.fifo6);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "if_prim_b_FIFO stalled",
-				stall.fifo7);
-#else
-#error "sh_css_debug: SP cell must be \
-	one of {SP_2300, SP_2300_DEMO, SP2400}"
-#endif
-		sh_css_dtrace(2, "\t%-32s: %d\n", "dmem stalled",
-				stall.dmem);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "control master stalled",
-				stall.control_master);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "i-cache master stalled",
-				stall.icache_master);
-	}
-return;
-}
-
-static void print_if_state(
-	input_formatter_state_t		*state)
-{
-	unsigned int val;
-
-#if defined(HAS_INPUT_FORMATTER_VERSION_1)
-	const char *st_reset  = (state->reset ? "Active" : "Not active");
-#endif
-	const char *st_vsalow = (state->vsync_active_low ? "low" : "high");
-	const char *st_hsalow = (state->hsync_active_low ? "low" : "high");
-
-	const char *fsm_sync_status_str    = "unknown";
-	const char *fsm_crop_status_str    = "unknown";
-	const char *fsm_padding_status_str = "unknown";
-
-	int         st_stline = state->start_line;
-	int         st_stcol  = state->start_column;
-	int         st_crpht  = state->cropped_height;
-	int         st_crpwd  = state->cropped_width;
-	int         st_verdcm = state->ver_decimation;
-	int         st_hordcm = state->hor_decimation;
-	int         st_deintr = state->deinterleaving;
-	int         st_leftpd = state->left_padding;
-	int         st_eoloff = state->eol_offset;
-	int         st_vmstad = state->vmem_start_address;
-	int         st_vmenad = state->vmem_end_address;
-	int         st_vmincr = state->vmem_increment;
-	int         st_yuv420 = state->is_yuv420;
-
-	sh_css_dtrace(2, "InputFormatter State:\n");
-
-	sh_css_dtrace(2, "\tConfiguration:\n");
-
-#if defined(HAS_INPUT_FORMATTER_VERSION_1)
-	sh_css_dtrace(2, "\t\t%-32s: %s\n"       ,
-			"Software reset"         , st_reset);
-#endif
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Start line"             , st_stline);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Start column"           , st_stcol);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Cropped height"         , st_crpht);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Cropped width"          , st_crpwd);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Ver decimation"         , st_verdcm);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Hor decimation"         , st_hordcm);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Deinterleaving"         , st_deintr);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"Left padding"           , st_leftpd);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"EOL offset (bytes)"     , st_eoloff);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%06X\n"   ,
-			"VMEM start address"     , st_vmstad);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%06X\n"   ,
-			"VMEM end address"       , st_vmenad);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%06X\n"   ,
-			"VMEM increment"         , st_vmincr);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n"       ,
-			"YUV 420 format"         , st_yuv420);
-	sh_css_dtrace(2, "\t\t%-32s: Active %s\n",
-			"Vsync"                  , st_vsalow);
-	sh_css_dtrace(2, "\t\t%-32s: Active %s\n",
-			"Hsync"                  , st_hsalow);
-
-	sh_css_dtrace(2, "\tFSM Status:\n");
-
-	val = state->fsm_sync_status;
-
-	if (val > 7)
-		fsm_sync_status_str = "ERROR";
-	else {
-		switch (val) {
-	case 0:
-		fsm_sync_status_str = "idle";
-		break;
-	case 1:
-		fsm_sync_status_str = "request frame";
-		break;
-	case 2:
-		fsm_sync_status_str = "request lines";
-		break;
-	case 3:
-		fsm_sync_status_str = "request vectors";
-		break;
-	case 4:
-		fsm_sync_status_str = "send acknowledge";
-		break;
-	default:
-		fsm_sync_status_str = "unknown";
-		break;
-	}
-	}
-
-	sh_css_dtrace(2, "\t\t%-32s: (0x%X: %s)\n",
-		     "FSM Synchronization Status", val, fsm_sync_status_str);
-
-	sh_css_dtrace(2, "\t\t%-32s: %d\n",
-		     "FSM Synchronization Counter", state->fsm_sync_counter);
-
-	val = state->fsm_crop_status;
-
-	if (val > 7)
-		fsm_crop_status_str = "ERROR";
-	else {
-		switch (val) {
-	case 0:
-		fsm_crop_status_str = "idle";
-		break;
-	case 1:
-		fsm_crop_status_str = "wait line";
-		break;
-	case 2:
-		fsm_crop_status_str = "crop line";
-		break;
-	case 3:
-		fsm_crop_status_str = "crop pixel";
-		break;
-	case 4:
-		fsm_crop_status_str = "pass pixel";
-		break;
-	case 5:
-		fsm_crop_status_str = "pass line";
-		break;
-	case 6:
-		fsm_crop_status_str = "lost line";
-		break;
-	default:
-		fsm_crop_status_str = "unknown";
-		break;
-	}
-	}
-	sh_css_dtrace(2, "\t\t%-32s: (0x%X: %s)\n",
-		     "FSM Crop Status", val, fsm_crop_status_str);
-
-	sh_css_dtrace(2, "\t\t%-32s: %d\n",
-		     "FSM Crop Line Counter",
-		     state->fsm_crop_line_counter);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n",
-		     "FSM Crop Pixel Counter",
-		     state->fsm_crop_pixel_counter);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n",
-		     "FSM Deinterleaving idx buffer",
-		     state->fsm_deinterleaving_index);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n",
-		     "FSM H decimation counter",
-		     state->fsm_dec_h_counter);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n",
-		     "FSM V decimation counter",
-		     state->fsm_dec_v_counter);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n",
-		     "FSM block V decimation counter",
-		     state->fsm_dec_block_v_counter);
-
-	val = state->fsm_padding_status;
-
-	if (val > 7)
-		fsm_padding_status_str = "ERROR";
-	else {
-		switch (val) {
-	case 0:
-		fsm_padding_status_str = "idle";
-		break;
-	case 1:
-		fsm_padding_status_str = "left pad";
-		break;
-	case 2:
-		fsm_padding_status_str = "write";
-		break;
-	case 3:
-		fsm_padding_status_str = "right pad";
-		break;
-	case 4:
-		fsm_padding_status_str = "send end of line";
-		break;
-	default:
-		fsm_padding_status_str = "unknown";
-		break;
-	}
-	}
-
-	sh_css_dtrace(2, "\t\t%-32s: (0x%X: %s)\n", "FSM Padding Status",
-		     val, fsm_padding_status_str);
-
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Padding element idx counter",
-		     state->fsm_padding_elem_counter);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support error",
-		     state->fsm_vector_support_error);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support buf full",
-		     state->fsm_vector_buffer_full);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Vector support",
-		     state->vector_support);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "Fifo sensor data lost",
-		     state->sensor_data_lost);
-return;
-}
-
-void sh_css_dump_if_state(void)
-{
-	input_formatter_state_t		state;
-	input_formatter_get_state(INPUT_FORMATTER0_ID, &state);
-	print_if_state(&state);
-	sh_css_dump_pif_isp_fifo_state();
-return;
-}
-
-void sh_css_dump_dma_state(void)
-{
-	dma_state_t		state;
-	int i, ch_id;
-
-	const char *fsm_cmd_st_lbl = "FSM Command flag state";
-	const char *fsm_ctl_st_lbl = "FSM Control flag state";
-	const char *fsm_ctl_state  = NULL;
-	const char *fsm_ctl_flag   = NULL;
-	const char *fsm_pack_st    = NULL;
-	const char *fsm_read_st    = NULL;
-	const char *fsm_write_st   = NULL;
-	char last_cmd_str[64];
-
-	dma_get_state(DMA0_ID, &state);
-	/* Print header for DMA dump status */
-	sh_css_dtrace(2, "DMA dump status:\n");
-
-	/* Print FSM command flag state */
-	if (state.fsm_command_idle)
-		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "IDLE");
-	if (state.fsm_command_run)
-		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "RUN");
-	if (state.fsm_command_stalling)
-		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "STALL");
-	if (state.fsm_command_error)
-		sh_css_dtrace(2, "\t%-32s: %s\n", fsm_cmd_st_lbl, "ERROR");
-
-	/* Print last command along with the channel */
-	ch_id = state.last_command_channel;
-
-	switch (state.last_command) {
-	case DMA_COMMAND_READ:
-		snprintf(last_cmd_str, 64,
-		  "Read 2D Block [Channel: %d]", ch_id);
-		break;
-	case DMA_COMMAND_WRITE:
-		snprintf(last_cmd_str, 64,
-		  "Write 2D Block [Channel: %d]", ch_id);
-		break;
-	case DMA_COMMAND_SET_CHANNEL:
-		snprintf(last_cmd_str, 64,
-		  "Set Channel [Channel: %d]", ch_id);
-		break;
-	case DMA_COMMAND_SET_PARAM:
-		snprintf(last_cmd_str, 64,
-		  "Set Param: %d [Channel: %d]",
-		  state.last_command_param, ch_id);
-		break;
-	case DMA_COMMAND_READ_SPECIFIC:
-		snprintf(last_cmd_str, 64,
-		  "Read Specific 2D Block [Channel: %d]", ch_id);
-		break;
-	case DMA_COMMAND_WRITE_SPECIFIC:
-		snprintf(last_cmd_str, 64,
-		  "Write Specific 2D Block [Channel: %d]", ch_id);
-		break;
-	case DMA_COMMAND_INIT:
-		snprintf(last_cmd_str, 64,
-		  "Init 2D Block on Device A [Channel: %d]", ch_id);
-		break;
-	case DMA_COMMAND_INIT_SPECIFIC:
-		snprintf(last_cmd_str, 64,
-		  "Init Specific 2D Block [Channel: %d]", ch_id);
-		break;
-	case DMA_COMMAND_RST:
-		snprintf(last_cmd_str, 64,
-		  "DMA SW Reset");
-		break;
-	case N_DMA_COMMANDS:
-		snprintf(last_cmd_str, 64,
-		  "UNKNOWN");
-		break;
-	}
-	sh_css_dtrace(2, "\t%-32s: (0x%X : %s)\n", "last command received",
-		     state.last_command, last_cmd_str);
-
-	/* Print DMA registers */
-	sh_css_dtrace(2, "\t%-32s\n", "DMA registers, connection group 0");
-	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Command",
-			state.current_command);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Address A",
-			state.current_addr_a);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Cmd Fifo Address B",
-			state.current_addr_b);
-
-	if (state.fsm_ctrl_idle)
-		fsm_ctl_flag = "IDLE";
-	else if (state.fsm_ctrl_run)
-		fsm_ctl_flag = "RUN";
-	else if (state.fsm_ctrl_stalling)
-		fsm_ctl_flag = "STAL";
-	else if (state.fsm_ctrl_error)
-		fsm_ctl_flag = "ERROR";
-	else
-		fsm_ctl_flag = "UNKNOWN";
-
-	switch (state.fsm_ctrl_state) {
-	case DMA_CTRL_STATE_IDLE:
-		fsm_ctl_state = "Idle state";
-		break;
-	case DMA_CTRL_STATE_REQ_RCV:
-		fsm_ctl_state = "Req Rcv state";
-		break;
-	case DMA_CTRL_STATE_RCV:
-		fsm_ctl_state = "Rcv state";
-		break;
-	case DMA_CTRL_STATE_RCV_REQ:
-		fsm_ctl_state = "Rcv Req state";
-		break;
-	case DMA_CTRL_STATE_INIT:
-		fsm_ctl_state = "Init state";
-		break;
-	case N_DMA_CTRL_STATES:
-		fsm_ctl_state = "Unknown";
-		break;
-	}
-
-	sh_css_dtrace(2, "\t\t%-32s: %s -> %s\n", fsm_ctl_st_lbl,
-		     fsm_ctl_flag, fsm_ctl_state);
-
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source dev",
-			state.fsm_ctrl_source_dev);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl source addr",
-			state.fsm_ctrl_source_addr);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl source stride",
-			state.fsm_ctrl_source_stride);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source width",
-			state.fsm_ctrl_source_width);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl source height",
-			state.fsm_ctrl_source_height);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source dev",
-			state.fsm_ctrl_pack_source_dev);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest dev",
-			state.fsm_ctrl_pack_dest_dev);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl dest addr",
-			state.fsm_ctrl_dest_addr);
-	sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "FSM Ctrl dest stride",
-			state.fsm_ctrl_dest_stride);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source width",
-			state.fsm_ctrl_pack_source_width);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest height",
-			state.fsm_ctrl_pack_dest_height);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest width",
-			state.fsm_ctrl_pack_dest_width);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack source elems",
-			state.fsm_ctrl_pack_source_elems);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack dest elems",
-			state.fsm_ctrl_pack_dest_elems);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Ctrl pack extension",
-			state.fsm_ctrl_pack_extension);
-
-	if (state.pack_idle)
-		fsm_pack_st = "IDLE";
-	if (state.pack_run)
-		fsm_pack_st = "RUN";
-	if (state.pack_stalling)
-		fsm_pack_st = "STALL";
-	if (state.pack_error)
-		fsm_pack_st = "ERROR";
-
-	sh_css_dtrace(2, "\t\t%-32s: %s\n", "FSM Pack flag state", fsm_pack_st);
-
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack cnt height",
-			state.pack_cnt_height);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack src cnt width",
-			state.pack_src_cnt_width);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Pack dest cnt width",
-			state.pack_dest_cnt_width);
-
-	if (state.read_state == DMA_RW_STATE_IDLE)
-		fsm_read_st = "Idle state";
-	if (state.read_state == DMA_RW_STATE_REQ)
-		fsm_read_st = "Req state";
-	if (state.read_state == DMA_RW_STATE_NEXT_LINE)
-		fsm_read_st = "Next line";
-	if (state.read_state == DMA_RW_STATE_UNLOCK_CHANNEL)
-		fsm_read_st = "Unlock channel";
-
-	sh_css_dtrace(2, "\t\t%-32s: %s\n", "FSM Read state", fsm_read_st);
-
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Read cnt height",
-			state.read_cnt_height);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Read cnt width",
-			state.read_cnt_width);
-
-	if (state.write_state == DMA_RW_STATE_IDLE)
-		fsm_write_st = "Idle state";
-	if (state.write_state == DMA_RW_STATE_REQ)
-		fsm_write_st = "Req state";
-	if (state.write_state == DMA_RW_STATE_NEXT_LINE)
-		fsm_write_st = "Next line";
-	if (state.write_state == DMA_RW_STATE_UNLOCK_CHANNEL)
-		fsm_write_st = "Unlock channel";
-
-	sh_css_dtrace(2, "\t\t%-32s: %s\n", "FSM Write state", fsm_write_st);
-
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Write height",
-			state.write_height);
-	sh_css_dtrace(2, "\t\t%-32s: %d\n", "FSM Write width",
-			state.write_width);
-
-	for (i = 0; i < HIVE_ISP_NUM_DMA_CONNS; i++) {
-		dma_port_state_t	*port = &(state.port_states[i]);
-		sh_css_dtrace(2, "\tDMA device interface %d\n", i);
-		sh_css_dtrace(2, "\t\tDMA internal side state\n");
-		sh_css_dtrace(2, "\t\t\tCS:%d - We_n:%d - Run:%d - Ack:%d\n",
-				port->req_cs,
-				port->req_we_n,
-				port->req_run,
-				port->req_ack);
-		sh_css_dtrace(2, "\t\tMaster Output side state\n");
-		sh_css_dtrace(2, "\t\t\tCS:%d - We_n:%d - Run:%d - Ack:%d\n",
-				port->send_cs,
-				port->send_we_n,
-				port->send_run,
-				port->send_ack);
-		sh_css_dtrace(2, "\t\tFifo state\n");
-		if (port->fifo_state == DMA_FIFO_STATE_WILL_BE_FULL)
-			sh_css_dtrace(2, "\t\t\tFiFo will be full\n");
-		else if (port->fifo_state == DMA_FIFO_STATE_FULL)
-			sh_css_dtrace(2, "\t\t\tFifo Full\n");
-		else if (port->fifo_state == DMA_FIFO_STATE_EMPTY)
-			sh_css_dtrace(2, "\t\t\tFifo Empty\n");
-		else
-			sh_css_dtrace(2, "\t\t\tFifo state unknown\n");
-
-		sh_css_dtrace(2, "\t\tFifo counter %d\n\n",
-				port->fifo_counter);
-	}
-
-	for (i = 0; i < HIVE_DMA_NUM_CHANNELS; i++) {
-		dma_channel_state_t	*ch = &(state.channel_states[i]);
-		sh_css_dtrace(2, "\t%-32s: %d\n", "DMA channel register",
-				i);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Connection",
-				ch->connection);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Sign extend",
-				ch->sign_extend);
-#if defined(IS_DMA_VERSION_1)
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Reverse elems",
-				ch->reverse_elem_order);
-#endif
-		sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Stride Dev A",
-				ch->stride_a);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Elems Dev A",
-				ch->elems_a);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Cropping Dev A",
-				ch->cropping_a);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Width Dev A",
-				ch->width_a);
-		sh_css_dtrace(2, "\t\t%-32s: 0x%X\n", "Stride Dev B",
-				ch->stride_b);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Elems Dev B",
-				ch->elems_b);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Cropping Dev B",
-				ch->cropping_b);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Width Dev B",
-				ch->width_b);
-		sh_css_dtrace(2, "\t\t%-32s: %d\n", "Height",
-				ch->height);
-	}
-	sh_css_dtrace(2, "\n");
-return;
-}
-
-static void print_fifo_channel_state(
-	const fifo_channel_state_t	*state,
-	const char					*descr)
-{
-	sh_css_dtrace(2, "FIFO channel: %s\n", descr);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "source valid", state->src_valid);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "fifo accept" , state->fifo_accept);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "fifo valid"  , state->fifo_valid);
-	sh_css_dtrace(2, "\t%-32s: %d\n", "sink accept" , state->sink_accept);
-return;
-}
-
-void sh_css_dump_pif_isp_fifo_state(void)
-{
-	fifo_channel_state_t pif_to_isp, isp_to_pif;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_IF0_TO_ISP0, &pif_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_ISP0_TO_IF0, &isp_to_pif);
-	print_fifo_channel_state(&pif_to_isp, "Primary IF A to ISP");
-	print_fifo_channel_state(&isp_to_pif, "ISP to Primary IF A)");
-return;
-}
-
-void sh_css_dump_dma_sp_fifo_state(void)
-{
-	fifo_channel_state_t dma_to_sp, sp_to_dma;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_DMA0_TO_SP0, &dma_to_sp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_SP0_TO_DMA0, &sp_to_dma);
-	print_fifo_channel_state(&dma_to_sp, "DMA to SP");
-	print_fifo_channel_state(&sp_to_dma, "SP to DMA");
-return;
-}
-
-void sh_css_dump_dma_isp_fifo_state(void)
-{
-	fifo_channel_state_t dma_to_isp, isp_to_dma;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_DMA0_TO_ISP0, &dma_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_ISP0_TO_DMA0, &isp_to_dma);
-	print_fifo_channel_state(&dma_to_isp, "DMA to ISP");
-	print_fifo_channel_state(&isp_to_dma, "ISP to DMA");
-return;
-}
-
-void sh_css_dump_isp_sp_fifo_state(void)
-{
-	fifo_channel_state_t sp_to_isp, isp_to_sp;
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_SP0_TO_ISP0, &sp_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_ISP0_TO_SP0, &isp_to_sp);
-	print_fifo_channel_state(&sp_to_isp, "SP to ISP");
-	print_fifo_channel_state(&isp_to_sp, "ISP to SP");
-return;
-}
-
-void sh_css_dump_isp_gdc_fifo_state(void)
-{
-	fifo_channel_state_t gdc_to_isp, isp_to_gdc;
-
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_GDC0_TO_ISP0, &gdc_to_isp);
-	fifo_channel_get_state(FIFO_MONITOR0_ID,
-		FIFO_CHANNEL_ISP0_TO_GDC0, &isp_to_gdc);
-	print_fifo_channel_state(&gdc_to_isp, "GDC to ISP");
-	print_fifo_channel_state(&isp_to_gdc, "ISP to GDC");
-return;
-}
-
-void sh_css_dump_all_fifo_state(void)
-{
-	int	i;
-	fifo_monitor_state_t	state;
-	fifo_monitor_get_state(FIFO_MONITOR0_ID, &state);
-
-	for (i = 0; i < N_FIFO_CHANNEL; i++)
-		print_fifo_channel_state(&(state.fifo_channels[i]),
-			"squepfstqkt");
-return;
-}
-
-static void sh_css_binary_info_print(
-	const struct sh_css_binary_info *info)
-{
-	sh_css_dtrace(2, "id = %d\n", info->id);
-	sh_css_dtrace(2, "mode = %d\n", info->mode);
-	sh_css_dtrace(2, "max_input_width = %d\n", info->max_input_width);
-	sh_css_dtrace(2, "min_output_width = %d\n", info->min_output_width);
-	sh_css_dtrace(2, "max_output_width = %d\n", info->max_output_width);
-	sh_css_dtrace(2, "top_cropping = %d\n", info->top_cropping);
-	sh_css_dtrace(2, "left_cropping = %d\n", info->left_cropping);
-	sh_css_dtrace(2, "xmem_addr = %d\n", info->xmem_addr);
-	sh_css_dtrace(2, "enable_vf_veceven = %d\n", info->enable.vf_veceven);
-	sh_css_dtrace(2, "enable_dis = %d\n", info->enable.dis);
-	sh_css_dtrace(2, "enable_uds = %d\n", info->enable.uds);
-	sh_css_dtrace(2, "enable ds = %d\n", info->enable.ds);
-	sh_css_dtrace(2, "s3atbl_use_dmem = %d\n", info->s3atbl_use_dmem);
-return;
-}
-
-void sh_css_binary_print(
-	const struct sh_css_binary *bi)
-{
-	sh_css_binary_info_print(bi->info);
-	sh_css_dtrace(2, "input:  %dx%d, format = %d, padded width = %d\n",
-		     bi->in_frame_info.width, bi->in_frame_info.height,
-		     bi->in_frame_info.format, bi->in_frame_info.padded_width);
-	sh_css_dtrace(2, "internal :%dx%d, format = %d, padded width = %d\n",
-		     bi->internal_frame_info.width,
-		     bi->internal_frame_info.height,
-		     bi->internal_frame_info.format,
-		     bi->internal_frame_info.padded_width);
-	sh_css_dtrace(2, "out:    %dx%d, format = %d, padded width = %d\n",
-		     bi->out_frame_info.width, bi->out_frame_info.height,
-		     bi->out_frame_info.format,
-		     bi->out_frame_info.padded_width);
-	sh_css_dtrace(2, "vf out: %dx%d, format = %d, padded width = %d\n",
-		     bi->vf_frame_info.width, bi->vf_frame_info.height,
-		     bi->vf_frame_info.format, bi->vf_frame_info.padded_width);
-	sh_css_dtrace(2, "online = %d\n", bi->online);
-	sh_css_dtrace(2, "input_buf_vectors = %d\n", bi->input_buf_vectors);
-	sh_css_dtrace(2, "deci_factor_log2 = %d\n", bi->deci_factor_log2);
-	sh_css_dtrace(2, "vf_downscale_log2 = %d\n", bi->vf_downscale_log2);
-	sh_css_dtrace(2, "dis_deci_factor_log2 = %d\n",
-			bi->dis_deci_factor_log2);
-	sh_css_dtrace(2, "dis hor coef num = %d\n", bi->dis_hor_coef_num_isp);
-	sh_css_dtrace(2, "dis ver coef num = %d\n", bi->dis_ver_coef_num_isp);
-	sh_css_dtrace(2, "dis hor proj num = %d\n", bi->dis_ver_proj_num_isp);
-	sh_css_dtrace(2, "sctbl_width_per_color = %d\n",
-			bi->sctbl_width_per_color);
-	sh_css_dtrace(2, "s3atbl_width = %d\n", bi->s3atbl_width);
-	sh_css_dtrace(2, "s3atbl_height = %d\n", bi->s3atbl_height);
-return;
-}
-
-void sh_css_frame_print(
-	const struct sh_css_frame	*frame,
-	const char					*descr)
-{
-	char *data = (char *)HOST_ADDRESS(frame->data);
-	sh_css_dtrace(2, "frame %s (%p):\n", descr, frame);
-	sh_css_dtrace(2, "  resolution    = %dx%d\n",
-		     frame->info.width, frame->info.height);
-	sh_css_dtrace(2, "  padded width  = %d\n", frame->info.padded_width);
-	sh_css_dtrace(2, "  format        = %d\n", frame->info.format);
-	sh_css_dtrace(2, "  is contiguous = %s\n",
-		     frame->contiguous ? "yes" : "no");
-	switch (frame->info.format) {
-	case SH_CSS_FRAME_FORMAT_NV12:
-	case SH_CSS_FRAME_FORMAT_NV16:
-	case SH_CSS_FRAME_FORMAT_NV21:
-	case SH_CSS_FRAME_FORMAT_NV61:
-		sh_css_dtrace(2, "  Y = %p\n",
-				data + frame->planes.nv.y.offset);
-		sh_css_dtrace(2, "  UV = %p\n",
-				data + frame->planes.nv.uv.offset);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUYV:
-	case SH_CSS_FRAME_FORMAT_UYVY:
-	case SH_CSS_FRAME_FORMAT_YUV_LINE:
-		sh_css_dtrace(2, "  YUYV = %p\n",
-				data + frame->planes.yuyv.offset);
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV420:
-	case SH_CSS_FRAME_FORMAT_YUV422:
-	case SH_CSS_FRAME_FORMAT_YUV444:
-	case SH_CSS_FRAME_FORMAT_YV12:
-	case SH_CSS_FRAME_FORMAT_YV16:
-	case SH_CSS_FRAME_FORMAT_YUV420_16:
-	case SH_CSS_FRAME_FORMAT_YUV422_16:
-		sh_css_dtrace(2, "  Y = %p\n",
-				data + frame->planes.yuv.y.offset);
-		sh_css_dtrace(2, "  U = %p\n",
-				data + frame->planes.yuv.u.offset);
-		sh_css_dtrace(2, "  V = %p\n",
-				data + frame->planes.yuv.v.offset);
-		break;
-	case SH_CSS_FRAME_FORMAT_RAW:
-		sh_css_dtrace(2, "  RAW = %p\n",
-				data + frame->planes.raw.offset);
-		break;
-	case SH_CSS_FRAME_FORMAT_RGBA888:
-	case SH_CSS_FRAME_FORMAT_RGB565:
-		sh_css_dtrace(2, "  RGB = %p\n",
-				data + frame->planes.rgb.offset);
-		break;
-	case SH_CSS_FRAME_FORMAT_QPLANE6:
-		sh_css_dtrace(2, "  R    = %p\n",
-				data + frame->planes.plane6.r.offset);
-		sh_css_dtrace(2, "  RatB = %p\n",
-				data + frame->planes.plane6.r_at_b.offset);
-		sh_css_dtrace(2, "  Gr   = %p\n",
-				data + frame->planes.plane6.gr.offset);
-		sh_css_dtrace(2, "  Gb   = %p\n",
-				data + frame->planes.plane6.gb.offset);
-		sh_css_dtrace(2, "  B    = %p\n",
-				data + frame->planes.plane6.b.offset);
-		sh_css_dtrace(2, "  BatR = %p\n",
-				data + frame->planes.plane6.b_at_r.offset);
-		break;
-	case SH_CSS_FRAME_FORMAT_BINARY_8:
-		sh_css_dtrace(2, "  Binary data = %p\n",
-				data + frame->planes.binary.data.offset);
-		break;
-	default:
-		sh_css_dtrace(2, "  unknown frame type\n");
-		break;
-	}
-return;
-}
-
-#ifdef __KERNEL__
-#define DTRACE_SP_STATE(format, args...)                                       \
-	printk(KERN_ERR "sh_css_sp_debug: " format,##args)
-#else
-#define DTRACE_SP_STATE(format, args...)                                       \
-	sh_css_dtrace(SH_DBG_DEBUG, "sh_css_sp_debug: " format,##args)
-#endif
-
-#if SP_DEBUG !=SP_DEBUG_NONE
-
-void sh_css_print_sp_debug_state(
-	const struct sh_css_sp_debug_state	*state)
-{
-
-#endif
-
-#if SP_DEBUG == SP_DEBUG_STALL
-	DTRACE_SP_STATE("current SP software counter: %d\n",
-				state->debug[0]);
-#endif
-
-#if SP_DEBUG == SP_DEBUG_DUMP
-
-	DTRACE_SP_STATE("current SP software counter: %d\n",
-				state->debug[0]);
-	DTRACE_SP_STATE("empty output buffer queue head: 0x%x\n",
-				state->debug[1]);
-	DTRACE_SP_STATE("empty output buffer queue tail: 0x%x\n",
-				state->debug[2]);
-	DTRACE_SP_STATE("empty s3a buffer queue head: 0x%x\n",
-				state->debug[3]);
-	DTRACE_SP_STATE("empty s3a buffer queue tail: 0x%x\n",
-				state->debug[4]);
-	DTRACE_SP_STATE("full output buffer queue head: 0x%x\n",
-				state->debug[5]);
-	DTRACE_SP_STATE("full output buffer queue tail: 0x%x\n",
-				state->debug[6]);
-	DTRACE_SP_STATE("full s3a buffer queue head: 0x%x\n",
-				state->debug[7]);
-	DTRACE_SP_STATE("full s3a buffer queue tail: 0x%x\n",
-				state->debug[8]);
-	DTRACE_SP_STATE("event queue head: 0x%x\n",
-				state->debug[9]);
-	DTRACE_SP_STATE("event queue tail: 0x%x\n",
-				state->debug[10]);
-	DTRACE_SP_STATE("num of stages of current pipeline: 0x%x\n",
-				state->debug[11]);
-	DTRACE_SP_STATE("DDR address of stage 1: 0x%x\n",
-				state->debug[12]);
-	DTRACE_SP_STATE("DDR address of stage 2: 0x%x\n",
-				state->debug[13]);
-	DTRACE_SP_STATE("current stage out_vf buffer idx: 0x%x\n",
-				state->debug[14]);
-	DTRACE_SP_STATE("current stage output buffer idx: 0x%x\n",
-				state->debug[15]);
-	DTRACE_SP_STATE("current stage s3a buffer idx: 0x%x\n",
-				state->debug[16]);
-	DTRACE_SP_STATE("first char of current stage name: 0x%x\n",
-				state->debug[17]);
-	DTRACE_SP_STATE("current SP thread id: 0x%x\n",
-				state->debug[18]);
-	DTRACE_SP_STATE("empty output buffer address 1: 0x%x\n",
-				state->debug[19]);
-	DTRACE_SP_STATE("empty output buffer address 2: 0x%x\n",
-				state->debug[20]);
-	DTRACE_SP_STATE("empty out_vf buffer address 1: 0x%x\n",
-				state->debug[21]);
-	DTRACE_SP_STATE("empty out_vf buffer address 2: 0x%x\n",
-				state->debug[22]);
-	DTRACE_SP_STATE("empty s3a_hi buffer address 1: 0x%x\n",
-				state->debug[23]);
-	DTRACE_SP_STATE("empty s3a_hi buffer address 2: 0x%x\n",
-				state->debug[24]);
-	DTRACE_SP_STATE("empty s3a_lo buffer address 1: 0x%x\n",
-				state->debug[25]);
-	DTRACE_SP_STATE("empty s3a_lo buffer address 2: 0x%x\n",
-				state->debug[26]);
-	DTRACE_SP_STATE("empty dis_hor buffer address 1: 0x%x\n",
-				state->debug[27]);
-	DTRACE_SP_STATE("empty dis_hor buffer address 2: 0x%x\n",
-				state->debug[28]);
-	DTRACE_SP_STATE("empty dis_ver buffer address 1: 0x%x\n",
-				state->debug[29]);
-	DTRACE_SP_STATE("empty dis_ver buffer address 2: 0x%x\n",
-				state->debug[30]);
-	DTRACE_SP_STATE("empty param buffer address: 0x%x\n",
-				state->debug[31]);
-	DTRACE_SP_STATE("first incorrect frame address: 0x%x\n",
-				state->debug[32]);
-	DTRACE_SP_STATE("first incorrect frame container address: 0x%x\n",
-				state->debug[33]);
-	DTRACE_SP_STATE("first incorrect frame container payload: 0x%x\n",
-				state->debug[34]);
-	DTRACE_SP_STATE("first incorrect s3a_hi address: 0x%x\n",
-				state->debug[35]);
-	DTRACE_SP_STATE("first incorrect s3a_hi container address: 0x%x\n",
-				state->debug[36]);
-	DTRACE_SP_STATE("first incorrect s3a_hi container payload: 0x%x\n",
-				state->debug[37]);
-	DTRACE_SP_STATE("first incorrect s3a_lo address: 0x%x\n",
-				state->debug[38]);
-	DTRACE_SP_STATE("first incorrect s3a_lo container address: 0x%x\n",
-				state->debug[39]);
-	DTRACE_SP_STATE("first incorrect s3a_lo container payload: 0x%x\n",
-				state->debug[40]);
-	DTRACE_SP_STATE("number of calling flash start function: 0x%x\n",
-				state->debug[41]);
-	DTRACE_SP_STATE("number of calling flash close function: 0x%x\n",
-				state->debug[42]);
-	DTRACE_SP_STATE("number of flashed frame: 0x%x\n",
-				state->debug[43]);
-	DTRACE_SP_STATE("flash in use flag: 0x%x\n",
-				state->debug[44]);
-	DTRACE_SP_STATE("number of update frame flashed flag: 0x%x\n",
-				state->debug[46]);
-	DTRACE_SP_STATE("number of active threads: 0x%x\n",
-				state->debug[45]);
-
-
-#elif SP_DEBUG == SP_DEBUG_COPY
-
-	/* Remember last_index because we only want to print new entries */
-	static int last_index = 0;
-	int sp_index = state->index;
-	int n;
-
-	if (sp_index < last_index) {
-		/* SP has been reset */
-		last_index = 0;
-	}
-
-	if (last_index == 0) {
-		DTRACE_SP_STATE(
-		  "copy-trace init: sp_dbg_if_start_line=%d, sp_dbg_if_start_column=%d, "
-		  "sp_dbg_if_cropped_height=%d, sp_debg_if_cropped_width=%d\n",
-		  state->if_start_line,
-		  state->if_start_column,
-		  state->if_cropped_height,
-		  state->if_cropped_width
-		  );
-	}
-
-	if ((last_index + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index) {
-		/* last index can be multiple rounds behind */
-		/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
-		last_index = sp_index - SH_CSS_SP_DBG_TRACE_DEPTH;
-	}
-
-	for (n = last_index; n < sp_index; n++) {
-		int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
-		if (state->trace[i].frame != 0) {
-			DTRACE_SP_STATE(
-			  "copy-trace: frame=%d, line=%d, "
-			  "pixel_distance=%d, mipi_used_dword=%d, sp_index=%d\n",
-			  state->trace[i].frame,
-			  state->trace[i].line,
-			  state->trace[i].pixel_distance,
-			  state->trace[i].mipi_used_dword,
-			  state->trace[i].sp_index
-			  );
-		}
-	}
-
-	last_index = sp_index;
-
-#elif SP_DEBUG == SP_DEBUG_TRACE
-
-#if 1
-
-	static char const *id2filename[8] = {
-		"param_buffer.sp.c | tagger.sp.c | pipe_data.sp.c",
-		"isp_init.sp.c",
-		"sp_raw_copy.hive.c",
-		"dma_configure.sp.c",
-		"sp.hive.c",
-		"event_proxy_sp.hive.c",
-		"circular_buffer.sp.c",
-		"frame_buffer.sp.c"
-		};
-
-#if 0
-	static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {
-				"copy", "preview/video", "capture",
-				"acceleration", "control", "TBD" };
-#else
-	static char const *trace_name[SH_CSS_SP_DBG_NR_OF_TRACES] = {
-				"default"};
-#endif
-
-	/* Remember host_index_last because we only want to print new entries */
-	static int host_index_last[SH_CSS_SP_DBG_NR_OF_TRACES] = {0};
-	int t, n;
-
-	for (t = 0; t < SH_CSS_SP_DBG_NR_OF_TRACES; t++) {
-		int sp_index_last = state->index_last[t];
-
-		if (sp_index_last < host_index_last[t]) {
-			/* SP has been reset */
-			host_index_last[t] = 0;
-		}
-
-		if ((host_index_last[t] + SH_CSS_SP_DBG_TRACE_DEPTH) < sp_index_last) {
-			/* last index can be multiple rounds behind */
-			/* while trace size is only SH_CSS_SP_DBG_TRACE_DEPTH */
-			DTRACE_SP_STATE(
-			  "Warning: trace %s has gap of %d traces\n",
-			  trace_name[t],
-			  (sp_index_last - (host_index_last[t] + SH_CSS_SP_DBG_TRACE_DEPTH)));
-
-			host_index_last[t] = sp_index_last - SH_CSS_SP_DBG_TRACE_DEPTH;
-		}
-
-		for (n = host_index_last[t]; n < sp_index_last; n++) {
-			int i = n % SH_CSS_SP_DBG_TRACE_DEPTH;
-			int l = state->trace[t][i].location &
-				((1<<SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS)-1);
-			int fid = state->trace[t][i].location >>
-				SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS;
-			int ts = state->trace[t][i].time_stamp;
-
-			if (ts) {
-				DTRACE_SP_STATE(
-				  "%05d trace=%s, file=%s:%d, data=0x%08x\n",
-				  ts,
-				  trace_name[t],
-				  id2filename[fid], l,
-				  state->trace[t][i].data);
-			}
-		}
-		host_index_last[t] = sp_index_last;
-	}
-
-
-#endif
-#endif
-
-#if SP_DEBUG !=SP_DEBUG_NONE
-
-	return;
-}
-#endif
-
-void sh_css_dump_rx_state(void)
-{
-	unsigned int infos = 0, bits;
-	bits = sh_css_rx_get_interrupt_reg();
-	sh_css_rx_get_interrupt_info(&infos);
-
-	sh_css_dtrace(2, "CSI Receiver errors: (irq reg = 0x%X)\n", bits);
-
-	if (infos & SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
-		sh_css_dtrace(2, "\tbuffer overrun\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_SOT)
-		sh_css_dtrace(2, "\tstart-of-transmission error\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
-		sh_css_dtrace(2, "\tstart-of-transmission sync error\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_CONTROL)
-		sh_css_dtrace(2, "\tcontrol error\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
-		sh_css_dtrace(2, "\t2 or more ECC errors\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_CRC)
-		sh_css_dtrace(2, "\tCRC mismatch\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
-		sh_css_dtrace(2, "\tunknown error\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
-		sh_css_dtrace(2, "\tframe sync error\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
-		sh_css_dtrace(2, "\tframe data error\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
-		sh_css_dtrace(2, "\tdata timeout\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
-		sh_css_dtrace(2, "\tunknown escape command entry\n");
-	if (infos & SH_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
-		sh_css_dtrace(2, "\tline sync error\n");
-return;
-}
-
-void
-sh_css_dump_sp_sw_debug_info(void)
-{
-#if SP_DEBUG !=SP_DEBUG_NONE
-	struct sh_css_sp_debug_state state;
-
-	sh_css_sp_get_debug_state(&state);
-	sh_css_print_sp_debug_state(&state);
-#endif
-return;
-}
-
-void sh_css_dump_debug_info(
-	const char	*context)
-{
-	if (context == NULL)
-		context = "No Context provided";
-
-	sh_css_dtrace(2, "CSS Debug Info dump [Context = %s]\n", context);
-	sh_css_dump_rx_state();
-	sh_css_dump_if_state();
-	sh_css_dump_isp_state();
-	sh_css_dump_isp_sp_fifo_state();
-	sh_css_dump_isp_gdc_fifo_state();
-	sh_css_dump_sp_state();
-	sh_css_dump_dma_isp_fifo_state();
-	sh_css_dump_dma_sp_fifo_state();
-	sh_css_dump_dma_state();
-return;
-}
-
-/* this function is for debug use, it can make SP go to sleep
-  state after each frame, then user can dump the stable SP dmem.
-  this function can be called after sh_css_start()
-  and before sh_css_init_buffer_queues() */
-void sh_css_enable_sp_sleep_mode(enum sh_css_sp_sleep_mode mode)
-{
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_sp_sleep_mode;
-
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_sp_sleep_mode = fw->info.sp.sleep_mode;
-
-	(void)HIVE_ADDR_sp_sleep_mode; /* Suppres warnings in CRUN */
-
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_sleep_mode),
-		(uint32_t)mode);
-}
-
-void sh_css_wake_up_sp(void)
-{
-	/*hrt_ctl_start(SP);*/
-	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_START_BIT);
-}
-
-void sh_css_dump_isp_params(unsigned int enable)
-{
-	const struct sh_css_isp_params *isp_params = sh_css_get_isp_params();
-
-	sh_css_dtrace(SH_DBG_DEBUG, "ISP PARAMETERS:\n");
-	if ((enable & SH_CSS_DEBUG_DUMP_FPN)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Fixed Pattern Noise Reduction:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"fpn_shift", isp_params->fpn_shift);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"fpn_enabled", isp_params->fpn_enabled);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_OB)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Optical Black:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"ob_blacklevel_gr", isp_params->ob_blacklevel_gr);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"ob_blacklevel_r", isp_params->ob_blacklevel_r);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"ob_blacklevel_b", isp_params->ob_blacklevel_b);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"ob_blacklevel_gb", isp_params->ob_blacklevel_gb);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"obarea_start_bq", isp_params->obarea_start_bq);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"obarea_length_bq", isp_params->obarea_length_bq);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"obarea_length_bq_inverse",
-			isp_params->obarea_length_bq_inverse);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_SC)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Shading Correction:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"sc_gain_shift", isp_params->sc_gain_shift);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_WB)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "White Balance:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"wb_gain_shift", isp_params->wb_gain_shift);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"wb_gain_gr", isp_params->wb_gain_gr);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"wb_gain_r", isp_params->wb_gain_r);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"wb_gain_b", isp_params->wb_gain_b);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"wb_gain_gb", isp_params->wb_gain_gb);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_DP)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Defect Pixel Correction:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"dp_threshold_single_w_2adj_on",
-			isp_params->dp_threshold_single_when_2adjacent_on);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"dp_threshold_2adj_w_2adj_on",
-			isp_params->dp_threshold_2adjacent_when_2adjacent_on);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"dp_threshold_single_w_2adj_off",
-			isp_params->dp_threshold_single_when_2adjacent_off);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"dp_threshold_2adj_w_2adj_off",
-			isp_params->dp_threshold_2adjacent_when_2adjacent_off);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-			"dp_gain", isp_params->dp_gain);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_BNR)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Bayer Noise Reduction:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"bnr_gain_all", isp_params->bnr_gain_all);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"bnr_gain_dir", isp_params->bnr_gain_dir);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"bnr_threshold_low",
-				isp_params->bnr_threshold_low);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"bnr_threshold_width_log2",
-				isp_params->bnr_threshold_width_log2);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"bnr_threshold_width",
-				isp_params->bnr_threshold_width);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"bnr_clip", isp_params->bnr_clip);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_S3A)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "S3A Support:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ae_y_coef_r", isp_params->ae_y_coef_r);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ae_y_coef_g", isp_params->ae_y_coef_g);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ae_y_coef_b", isp_params->ae_y_coef_b);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"awb_lg_high_raw", isp_params->awb_lg_high_raw);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"awb_lg_low", isp_params->awb_lg_low);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"awb_lg_high", isp_params->awb_lg_high);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir1[0]", isp_params->af_fir1[0]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir1[1]", isp_params->af_fir1[1]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir1[2]", isp_params->af_fir1[2]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir1[3]", isp_params->af_fir1[3]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir1[4]", isp_params->af_fir1[4]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir1[5]", isp_params->af_fir1[5]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir1[6]", isp_params->af_fir1[6]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir2[0]", isp_params->af_fir2[0]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir2[1]", isp_params->af_fir2[1]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir2[2]", isp_params->af_fir2[2]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir2[3]", isp_params->af_fir2[3]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir2[4]", isp_params->af_fir2[4]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir2[5]", isp_params->af_fir2[5]);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"af_fir2[6]", isp_params->af_fir2[6]);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_DE)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Demosaic:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"de_pixelnoise", isp_params->de_pixelnoise);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"de_c1_coring_threshold",
-				isp_params->de_c1_coring_threshold);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"de_c2_coring_threshold",
-				isp_params->de_c2_coring_threshold);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_YNR)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG,
-			"Y Noise Reduction and Edge Enhancement:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynr_threshold", isp_params->ynr_threshold);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynr_gain_all", isp_params->ynr_gain_all);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynr_gain_dir", isp_params->ynr_gain_dir);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynryee_dirthreshold_s",
-				isp_params->ynryee_dirthreshold_s);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynryee_dirthreshold_g",
-				isp_params->ynryee_dirthreshold_g);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynryee_dirthreshold_width_log2",
-				isp_params->ynryee_dirthreshold_width_log2);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynryee_dirthreshold_width",
-				isp_params->ynryee_dirthreshold_width);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_detailgain",
-				isp_params->yee_detailgain);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_coring_s",
-				isp_params->yee_coring_s);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_coring_g",
-				isp_params->yee_coring_g);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_scale_plus_s",
-				isp_params->yee_scale_plus_s);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_scale_plus_g",
-				isp_params->yee_scale_plus_g);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_scale_minus_s",
-				isp_params->yee_scale_minus_s);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_scale_minus_g",
-				isp_params->yee_scale_minus_g);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_clip_plus_s",
-				isp_params->yee_clip_plus_s);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_clip_plus_g",
-				isp_params->yee_clip_plus_g);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_clip_minus_s",
-				isp_params->yee_clip_minus_s);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yee_clip_minus_g",
-				isp_params->yee_clip_minus_g);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ynryee_Yclip",
-				isp_params->ynryee_Yclip);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_CSC)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Color Space Conversion:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"csc_coef_shift",
-				isp_params->csc_coef_shift);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_00",
-				isp_params->yc1c2_to_ycbcr_00);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_01",
-				isp_params->yc1c2_to_ycbcr_01);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_02",
-				isp_params->yc1c2_to_ycbcr_02);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_10",
-				isp_params->yc1c2_to_ycbcr_10);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_11",
-				isp_params->yc1c2_to_ycbcr_11);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_12",
-				isp_params->yc1c2_to_ycbcr_12);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_20",
-				isp_params->yc1c2_to_ycbcr_20);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_21",
-				isp_params->yc1c2_to_ycbcr_21);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"yc1c2_to_ycbcr_22",
-				isp_params->yc1c2_to_ycbcr_22);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_GC)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Gamma Correction:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"gamma_gain_k1", isp_params->gamma_gain_k1);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"gamma_gain_k2", isp_params->gamma_gain_k2);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_TNR)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Temporal Noise Reduction:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"tnr_coef", isp_params->tnr_coef);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"tnr_threshold_Y", isp_params->tnr_threshold_Y);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"tnr_threshold_C", isp_params->tnr_threshold_C);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_ANR)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Advance Noise Reduction:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"anr_threshold", isp_params->anr_threshold);
-	}
-	if ((enable & SH_CSS_DEBUG_DUMP_CE)
-			|| (enable & SH_CSS_DEBUG_DUMP_ALL)) {
-		sh_css_dtrace(SH_DBG_DEBUG, "Chroma Enhancement:\n");
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ce_uv_level_min", isp_params->ce_uv_level_min);
-		sh_css_dtrace(SH_DBG_DEBUG, "\t%-32s = %d\n",
-				"ce_uv_level_max", isp_params->ce_uv_level_max);
-	}
-}
-
-
-
-/*
-
-void sh_css_init_ddr_debug_queue(void)
-{
-	hrt_vaddress ddr_debug_queue_addr =
-			mmgr_malloc(sizeof(debug_data_ddr_t));
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_debug_buffer_ddr_address;
-
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_debug_buffer_ddr_address =
-			fw->info.sp.debug_buffer_ddr_address;
-
-	(void)HIVE_ADDR_debug_buffer_ddr_address;
-
-	debug_buffer_ddr_init(ddr_debug_queue_addr);
-
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(debug_buffer_ddr_address),
-		(uint32_t)(ddr_debug_queue_addr));
-}
-
-void sh_css_load_ddr_debug_queue(void)
-{
-	debug_synch_queue_ddr();
-}
-
-void sh_css_dump_ddr_debug_queue(void)
-{
-	int i;
-	sh_css_load_ddr_debug_queue();
-#ifdef __KERNEL__
-	for (i = 0; i < DEBUG_BUF_SIZE; i++)
-		printk(KERN_DEBUG, "ddr_debug_queue[%d] = 0x%x\n",
-				i, debug_data_ptr->buf[i]);
-#else
-	for (i = 0; i < DEBUG_BUF_SIZE; i++)
-		printf("ddr_debug_queue[%d] = 0x%x\n",
-				i, debug_data_ptr->buf[i]);
-#endif
-}
-*/
-
-/**
- * @brief Initialize the debug mode.
- * Refer to "sh_css_debug.h" for more details.
- */
-bool
-sh_css_debug_mode_init(void)
-{
-	bool rc;
-	rc = sh_css_sp_init_dma_sw_reg(0);
-	return	rc;
-}
-
-/**
- * @brief Disable the DMA channel.
- * Refer to "sh_css_debug.h" for more details.
- */
-bool
-sh_css_debug_mode_disable_dma_channel(int dma_id,
-		int channel_id,
-		int request_type)
-{
-	bool rc;
-
-	rc = sh_css_sp_set_dma_sw_reg(dma_id,
-			channel_id,
-			request_type,
-			false);
-
-	return rc;
-}
-
-/**
- * @brief Enable the DMA channel.
- * Refer to "sh_css_debug.h" for more details.
- */
-bool
-sh_css_debug_mode_enable_dma_channel(int dma_id,
-		int channel_id,
-		int request_type)
-{
-	bool rc;
-
-	rc = sh_css_sp_set_dma_sw_reg(dma_id,
-			channel_id,
-			request_type,
-			true);
-
-	return rc;
-}
-
-static struct pipe_graph_class {
-	bool do_init;
-	int height;
-	int width;
-	int eff_height;
-	int eff_width;
-	enum sh_css_input_format input_format;
-
-} pg_inst = {true, 0, 0, 0, 0, N_SH_CSS_INPUT_FORMAT};
-
-static const char *format2str[] = {
-	[SH_CSS_FRAME_FORMAT_NV11]	= "NV11",
-	[SH_CSS_FRAME_FORMAT_NV12]	= "NV12",
-	[SH_CSS_FRAME_FORMAT_NV16]	= "NV16",
-	[SH_CSS_FRAME_FORMAT_NV21]	= "NV21",
-	[SH_CSS_FRAME_FORMAT_NV61]	= "NV61",
-	[SH_CSS_FRAME_FORMAT_YV12]	= "YV12",
-	[SH_CSS_FRAME_FORMAT_YV16]	= "YV16",
-	[SH_CSS_FRAME_FORMAT_YUV420]	= "YUV420",
-	[SH_CSS_FRAME_FORMAT_YUV420_16]	= "YUV420_16",
-	[SH_CSS_FRAME_FORMAT_YUV422]	= "YUV422",
-	[SH_CSS_FRAME_FORMAT_YUV422_16]	= "YUV422_16",
-	[SH_CSS_FRAME_FORMAT_UYVY]	= "UYVY",
-	[SH_CSS_FRAME_FORMAT_YUYV]	= "YUYV",
-	[SH_CSS_FRAME_FORMAT_YUV444]	= "YUV444",
-	[SH_CSS_FRAME_FORMAT_YUV_LINE]	= "YUV_LINE",
-	[SH_CSS_FRAME_FORMAT_RAW]	= "RAW",
-	[SH_CSS_FRAME_FORMAT_RGB565]	= "RGB565",
-	[SH_CSS_FRAME_FORMAT_PLANAR_RGB888] = "PLANAR_RGB888",
-	[SH_CSS_FRAME_FORMAT_RGBA888]	= "RGBA888",
-	[SH_CSS_FRAME_FORMAT_QPLANE6]	= "QPLANE6",
-	[SH_CSS_FRAME_FORMAT_BINARY_8]	= "BINARY_8",
-	[N_SH_CSS_FRAME_FORMAT]		= "INVALID"
-};
-
-static const char* input_format2str[] = {
-  [SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY] = "yuv420-8-legacy",
-  [SH_CSS_INPUT_FORMAT_YUV420_8]        = "yuv420-8",
-  [SH_CSS_INPUT_FORMAT_YUV420_10]       = "yuv420-10",
-  [SH_CSS_INPUT_FORMAT_YUV422_8]        = "yuv422-8",
-  [SH_CSS_INPUT_FORMAT_YUV422_10]       = "yuv422-10",
-  [SH_CSS_INPUT_FORMAT_RGB_444]         = "rgb444",
-  [SH_CSS_INPUT_FORMAT_RGB_555]         = "rgb555",
-  [SH_CSS_INPUT_FORMAT_RGB_565]         = "rgb565",
-  [SH_CSS_INPUT_FORMAT_RGB_666]         = "rgb666",
-  [SH_CSS_INPUT_FORMAT_RGB_888]         = "rgb888",
-  [SH_CSS_INPUT_FORMAT_RAW_6]           = "raw6",
-  [SH_CSS_INPUT_FORMAT_RAW_7]           = "raw7",
-  [SH_CSS_INPUT_FORMAT_RAW_8]           = "raw8",
-  [SH_CSS_INPUT_FORMAT_RAW_10]          = "raw10",
-  [SH_CSS_INPUT_FORMAT_RAW_12]          = "raw12",
-  [SH_CSS_INPUT_FORMAT_RAW_14]          = "raw14",
-  [SH_CSS_INPUT_FORMAT_RAW_16]          = "raw16",
-  [SH_CSS_INPUT_FORMAT_BINARY_8]        = "binary8",
-  [N_SH_CSS_INPUT_FORMAT]               = "invalid"
-};
-
-
-static const char *qi2str[] = {
-	[sh_css_frame_in]	= "in",
-	[sh_css_frame_out]	= "out",
-	[sh_css_frame_out_vf]	= "out_vf",
-	[sh_css_frame_s3a]	= "s3a",
-	[sh_css_frame_dis]	= "dis"
-};
-
-static const char *pi2str[] = {
-	[SH_CSS_PREVIEW_PIPELINE]	= "preview",
-	[SH_CSS_COPY_PIPELINE]		= "copy",
-	[SH_CSS_VIDEO_PIPELINE]		= "video",
-	[SH_CSS_CAPTURE_PIPELINE]	= "capture",
-	[SH_CSS_ACC_PIPELINE]		= "accelerator"
-};
-
-static char dot_id_input_bin[20];
-
-#define DPG_START "sh_css_pipe_graph_dump_start "
-#define DPG_END   " sh_css_pipe_graph_dump_end"
-
-#ifdef HRT_CSIM
-/* For CSIM we print double because HSS log can mess up this output */
-/* As post processing, we remove incomplete lines and make lines uniq */
-#define DTRACE_DOT(format, args...)                                         \
-	do {                                                                \
-		sh_css_dtrace(SH_DBG_INFO, "%s" format "%s\n",            \
-						DPG_START,##args, DPG_END); \
-		sh_css_dtrace(SH_DBG_INFO, "%s" format "%s\n",            \
-						DPG_START,##args, DPG_END); \
-  } while (0)
-#else
-#define DTRACE_DOT(format, args...)                                         \
-	sh_css_dtrace(SH_DBG_INFO, "%s" format "%s\n",            \
-					DPG_START,##args, DPG_END)
-#endif
-
-
-static void
-sh_css_debug_pipe_graph_dump_frame(
-	struct sh_css_frame *frame,
-	enum sh_css_pipe_id id,
-	char const *blob_name,
-	char const *frame_name,
-	bool in_frame,
-	bool join_input_buf)
-{
-	char bufinfo[100];
-
-	if (frame->dynamic_data_index == -1) {
-		sprintf(bufinfo, "Internal");
-	} else {
-		sprintf(bufinfo, "Queue: %s %s",
-			pi2str[id],
-			qi2str[frame->dynamic_data_index]);
-	}
-	DTRACE_DOT(
-		"node [shape = box, "
-		"fixedsize=true, width=2, height=0.7]; \"0x%08lx\" "
-		"[label = \"%s\\n%d(%d) x %d\\n%s\"];",
-		join_input_buf ? 0x11111111 : HOST_ADDRESS(frame),
-		format2str[frame->info.format],
-		frame->info.width,
-		frame->info.padded_width,
-		frame->info.height,
-		bufinfo);
-
-	if (in_frame){
-		DTRACE_DOT(
-			"\"0x%08lx\"->\"%s(pipe%d)\" "
-			"[label = %s_frame];",
-			join_input_buf ? 0x11111111 : HOST_ADDRESS(frame),
-			blob_name, id, frame_name);
-	} else {
-		DTRACE_DOT(
-			"\"%s(pipe%d)\"->\"0x%08lx\" "
-			"[label = %s_frame];",
-			blob_name, id,
-			HOST_ADDRESS(frame),
-			frame_name);
-	}
-}
-
-void
-sh_css_debug_pipe_graph_dump_prologue(void)
-{
-
-	DTRACE_DOT("digraph sh_css_pipe_graph {" );
-	DTRACE_DOT("rankdir=LR;" );
-
-	DTRACE_DOT("fontsize=9;");
-	DTRACE_DOT("label = \"\\nEnable options: rp=reduced pipe, vfve=vf_veceven, "
-		"dvse=dvs_envelope, dvs6=dvs_6axis, bo=block_out, "
-		"fbds=fixed_bayer_ds, bf6=bayer_fir_6db, "
-		"rawb=raw_binning, cont=continuous, disc=dis_crop\\n"
-		"dp2a=dp_2adjacent, outp=output, outt=out_table, "
-		"reff=ref_frame, par=params, gam=gamma, "
-		"cagdc=ca_gdc, ispa=isp_addresses, inf=in_frame, "
-		"outf=out_frame, hs=high_speed, inpc=input_chunking\"");
-}
-
-void
-sh_css_debug_pipe_graph_dump_epilogue(void)
-{
-
-	DTRACE_DOT(
-		"node [shape = doublecircle, "
-		"fixedsize=true, width=2]; \"input_system\" "
-		"[label = \"Input system\"];");
-
-	DTRACE_DOT(
-		"\"input_system\"->\"%s\" "
-		"[label = \"%s\\n%d x %d\"];",
-		dot_id_input_bin, input_format2str[pg_inst.input_format],
-		pg_inst.eff_width, pg_inst.eff_height);
-
-#if 0
-	if (pipe->input_mode == SH_CSS_INPUT_MODE_SENSOR) {
-#endif
-		DTRACE_DOT(
-			"node [shape = doublecircle, "
-			"fixedsize=true, width=2]; \"sensor\" "
-			"[label = \"Sensor\"];");
-
-		DTRACE_DOT(
-			"\"sensor\"->\"input_system\" "
-			"[label = \"%s\\n%d x %d\"];",
-			input_format2str[pg_inst.input_format],
-			pg_inst.width, pg_inst.height);
-#if 0
-	} else if (pipe->input_mode == SH_CSS_INPUT_MODE_FIFO) {
-
-		DTRACE_DOT(
-			"node [shape = doublecircle, "
-			"fixedsize=true, width=2]; \"fifo\" "
-			"[label = \"FIFO\"];");
-
-		DTRACE_DOT(
-			"\"fifo\"->\"input_system\" "
-			"[label = \"Format W x H\"];");
-
-	} else {
-
-		DTRACE_DOT(
-			"node [shape = doublecircle, "
-			"fixedsize=true, width=2]; \"input\" "
-			"[label = \"TPG/PRBS/MEMORY\"];");
-
-		DTRACE_DOT(
-			"\"input\"->\"input_system\" "
-			"[label = \"Format W x H\"];");
-
-	}
-#endif
-
-	DTRACE_DOT("}");
-
-	pg_inst.do_init = true;
-	pg_inst.width = 0;
-	pg_inst.height = 0;
-	pg_inst.eff_width = 0;
-	pg_inst.eff_height = 0;
-	pg_inst.input_format = N_SH_CSS_INPUT_FORMAT;
-
-}
-
-void
-sh_css_debug_pipe_graph_dump_stage(
-	struct sh_css_pipeline_stage *stage,
-	enum sh_css_pipe_id id)
-{
-
-	char const *blob_name = "<unknow name>";
-	char const *bin_type = "<unknow type>";
-
-	if (pg_inst.do_init) {
-		sh_css_debug_pipe_graph_dump_prologue();
-		pg_inst.do_init = false;
-	}
-
-	if (stage->binary) {
-		bin_type= "binary";
-		if (stage->binary_info->blob)
-			blob_name = stage->binary_info->blob->name;
-	} else if (stage->firmware){
-		bin_type= "firmware";
-		blob_name =
-			(char const *)SH_CSS_EXT_ISP_PROG_NAME(stage->firmware);
-	}
-
-	{
-		char enable_info1[100];
-		char enable_info2[100];
-		char enable_info3[100];
-		char enable_info[200];
-		struct sh_css_binary_info* bi = stage->binary_info;
-
-		/* Split it in 2 function-calls to keep the amount of
-		 * parameters per call "reasonable"
-		 */
-		snprintf( enable_info1, 100, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
-			bi->enable.reduced_pipe ?	"rp," : "",
-			bi->enable.vf_veceven ?		"vfve," : "",
-			bi->enable.dis ?		"dis," : "",
-			bi->enable.dvs_envelope ?	"dvse," : "",
-			bi->enable.uds ?		"uds," : "",
-			bi->enable.dvs_6axis ?		"dvs6," : "",
-			bi->enable.block_output ?	"bo," : "",
-			bi->enable.ds ?			"ds," : "",
-			bi->enable.fixed_bayer_ds ?	"fbds," : "",
-			bi->enable.bayer_fir_6db ?	"bf6," : "",
-			bi->enable.raw_binning ?	"rawb," : "",
-			bi->enable.continuous ?		"cont," : "",
-			bi->enable.s3a ?		"s3a," : "",
-			bi->enable.fpnr ?		"fpnr," : "",
-			bi->enable.sc ?			"sc," : "",
-			bi->enable.dis_crop ?		"disc," : "",
-			bi->enable.dp_2adjacent ?	"dp2a," : ""
-			);
-
-		snprintf( enable_info2, 100, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
-			bi->enable.macc ?		"macc," : "",
-			bi->enable.ss ?			"ss," : "",
-			bi->enable.output ?		"outp," : "",
-			bi->enable.ref_frame ?		"reff," : "",
-			bi->enable.tnr ?		"tnr," : "",
-			bi->enable.xnr ?		"xnr," : "",
-			bi->enable.raw ?		"raw," : "",
-			bi->enable.params ?		"par," : "",
-			bi->enable.gamma ?		"gam," : "",
-			bi->enable.ctc ?		"ctc," : "",
-			bi->enable.ca_gdc ?		"cagdc," : "",
-			bi->enable.isp_addresses ?	"ispa," : "",
-			bi->enable.in_frame ?		"inf," : "",
-			bi->enable.out_frame ?		"outf," : "",
-			bi->enable.high_speed ?		"hs," : "",
-			bi->enable.input_chunking ?	"inpc," : ""
-			);
-
-		/* And merge them into one string */
-		snprintf(enable_info, 200, "%s%s",
-						enable_info1, enable_info2);
-		{
-			int l, p;
-			char *ei=enable_info;
-
-			l=strlen(ei);
-
-			/* Replace last space with ',' if present */
-			if (enable_info[l-1] == ',')
-				enable_info[--l] = '\0';
-
-#define ENABLE_LINE1_MAX_LENGHT1 (24)
-#define ENABLE_LINE2_MAX_LENGHT2 (22)
-
-			if (l<=ENABLE_LINE1_MAX_LENGHT1) {
-				/* It fits on one line, copy string and init */
-				/* other helper strings with empty string */
-				strcpy(enable_info, ei);
-			} else {
-				/* Too big for one line, find last space */
-				p=ENABLE_LINE1_MAX_LENGHT1;
-				while (ei[p] != ',' && p > 0)
-					p--;
-				/* Last space found, copy till that space */
-				if (p >= sizeof(enable_info1))
-					return;
-				strncpy(enable_info1, ei, p);
-				enable_info1[p] = '\0';
-
-				ei += p+1;
-				l = strlen(ei);
-
-				if (l<=ENABLE_LINE2_MAX_LENGHT2) {
-					/* The 2nd line fits */
-					/* we cannot use ei as argument because
-					 * it is not guarenteed dword aligned
-					 */
-					strcpy(enable_info2, ei);
-					snprintf(enable_info, 200, "%s\\n%s",
-						enable_info1, enable_info2);
-
-				} else {
-					/* 2nd line is still too long */
-					p=ENABLE_LINE2_MAX_LENGHT2;
-					while (ei[p] != ',' && p > 0)
-						p--;
-					if (p >= sizeof(enable_info2))
-						return;
-					strncpy(enable_info2, ei, p);
-					enable_info2[p] = '\0';
-					ei += p+1;
-					strcpy(enable_info3, ei);
-					snprintf(enable_info, 200,
-						"%s\\n%s\\n%s",
-						enable_info1, enable_info2,
-						enable_info3);
-				}
-			}
-		}
-
-		DTRACE_DOT("node [shape = circle, fixedsize=true, width=2, "
-			"label=\"%s\\n%s\\n\\n%s\"]; \"%s(pipe%d)\"",
-			bin_type, blob_name, enable_info, blob_name, id);
-
-	}
-
-	if (stage->stage_num == 0) {
-		sprintf(dot_id_input_bin, "%s(pipe%d)", blob_name, id);
-	}
-
-	/* CC is a bit of special case, it used to be the alternating IN */
-	/* when continuous capture was still used in a double buffer scheme. */
-	/* Now consider it just as another IN */
-	if (stage->args.cc_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.cc_frame, id, blob_name,
-			"in", true, stage->stage_num == 0);
-	} else if (stage->args.in_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.in_frame, id, blob_name,
-			"in", true, stage->stage_num == 0);
-	}
-
-	if (stage->args.in_ref_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.in_ref_frame, id, blob_name,
-			"in_ref", true, false);
-	}
-
-	if (stage->args.in_tnr_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.in_tnr_frame, id, blob_name,
-			"in_tnr", true, false);
-	}
-
-	if (stage->args.out_ref_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.out_ref_frame, id, blob_name,
-			"out_ref", false, false);
-	}
-
-	if (stage->args.out_tnr_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.out_tnr_frame, id, blob_name,
-			"out_tnr", false, false);
-	}
-
-	if (stage->args.out_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.out_frame, id, blob_name,
-			"out", false, false);
-	}
-
-	if (stage->args.out_vf_frame) {
-		sh_css_debug_pipe_graph_dump_frame(
-			stage->args.out_vf_frame, id, blob_name,
-			"out_vf", false, false);
-	}
-}
-
-void
-sh_css_debug_pipe_graph_dump_sp_raw_copy(
-	struct sh_css_frame *cc_frame)
-{
-	DTRACE_DOT("node [shape = circle, fixedsize=true, width=2, "
-		"label=\"%s\\n%s\"]; \"%s(pipe%d)\"",
-		"sp-binary", "sp_raw_copy", "sp_raw_copy", 1);
-
-
-	DTRACE_DOT(
-		"node [shape = box, "
-		"fixedsize=true, width=2, height=0.7]; \"0x11111111\" "
-		"[label = \"%s\\n%d(%d) x %d\\nRingbuffer\"];",
-		format2str[cc_frame->info.format],
-		cc_frame->info.width,
-		cc_frame->info.padded_width,
-		cc_frame->info.height);
-
-
-	DTRACE_DOT(
-		"\"%s(pipe%d)\"->\"0x11111111\" "
-		"[label = cc_frame];",
-		"sp_raw_copy", 1);
-
-	sprintf(dot_id_input_bin, "%s(pipe%d)", "sp_raw_copy", 1);
-
-}
-
-void
-sh_css_debug_pipe_graph_dump_input_set_resolution
-(unsigned int width, unsigned int height)
-{
-	pg_inst.width = width;
-	pg_inst.height = height;
-}
-
-void
-sh_css_debug_pipe_graph_dump_input_set_effective_resolution
-(unsigned int effective_width, unsigned int effective_height)
-{
-	pg_inst.eff_width = effective_width;
-	pg_inst.eff_height = effective_height;
-}
-
-void
-sh_css_debug_pipe_graph_dump_input_set_format
-(enum sh_css_input_format input_format)
-{
-	pg_inst.input_format = input_format;
-}
-
-#if defined(HRT_SCHED) || defined(SH_CSS_DEBUG_SPMEM_DUMP_SUPPORT)
-#include "spmem_dump.c"
-#endif
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.h
deleted file mode 100644
index d944850..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug.h
+++ /dev/null
@@ -1,293 +0,0 @@
-#ifndef _SH_CSS_DEBUG_H_
-#define _SH_CSS_DEBUG_H_
-
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-/*! \file */
-
-#include <stdbool.h>
-
-#include "sh_css.h"
-#include "sh_css_internal.h"
-/* available levels */
-/*! Level for tracing errors */
-#define SH_DBG_ERROR   1
-/*! Level for tracing warnings */
-#define SH_DBG_WARNING 3
-/*! Level for tracing debug messages */
-#define SH_DBG_DEBUG   5
-/*! Level for tracing trace messages a.o. sh_css public function calls */
-#define SH_DBG_TRACE   6
-/*! Level for tracing trace messages a.o. sh_css private function calls */
-#define SH_DBG_TRACE_PRIVATE   7
-/*! Level for tracing parameter messages e.g. in and out params of functions */
-#define SH_DBG_PARAM   8
-/*! Level for tracing info messages */
-#define SH_DBG_INFO    9
-/* Global variable which controls the verbosity levels of the debug tracing */
-extern unsigned int sh_css_trace_level;
-
-/* The following macro definition allows us to direct the debug trace messages
- * to the Linux kernel trace buffer using the ftrace mechanism. The ftrace
- * mechanism is preferred over the usual prink based messages because it is
- * not bound to a console and its efficiency is many holds higher than the
- * printk mechanism. When we are not in the Linux kernel, we depend upon the
- * CSS print function to dump these traces. We need the __KERNEL__ macro
- * because the same code is compiled also in the Silicon Hive simulation
- * environnment
- */
-#ifdef __KERNEL__
-#include <linux/kernel.h>
-
-#define sh_css_dtrace(level, format, args...)          \
-	do {                                           \
-		if (sh_css_trace_level >= level)   {    \
-			pr_debug("sh_css: " format, ##args);	\
-			trace_printk(format, ## args); \
-		}	\
-	} while (0)
-#if 0
-#define sh_css_dtrace(level, format, args...)          \
-	do {                                           \
-		if (level == SH_DBG_ERROR)             \
-			printk(KERN_ERR "sh_css FATAL ERROR: " format,##args); \
-		if (sh_css_trace_level >= level)       \
-			trace_printk(format, ## args); \
-	} while (0)
-#endif
-#else
-#include "sh_css_internal.h"
-
-/*! \brief Function for tracing to the provided printf function in the environment.
- * \param[in]	level		Level of the message.
- * \param[in]	format		printf like format string
- * \param[in]	args		arguments for the format string
- */
-#define sh_css_dtrace(level, format, args...)          \
-	do {                                           \
-		if (sh_css_trace_level >= level)       \
-			sh_css_print(format, ## args); \
-	} while (0)
-#endif
-/*! \brief Enum defining the different isp parameters to dump.
- *  Values can be combined to dump a combination of sets.
- */
-enum sh_css_debug_enable_param_dump {
-	SH_CSS_DEBUG_DUMP_FPN = 1 << 0, /**< FPN table */
-	SH_CSS_DEBUG_DUMP_OB = 1 << 1,  /**< OB table */
-	SH_CSS_DEBUG_DUMP_SC = 1 << 2,  /**< Shading table */
-	SH_CSS_DEBUG_DUMP_WB = 1 << 3,  /**< White balance */
-	SH_CSS_DEBUG_DUMP_DP = 1 << 4,  /**< Defect Pixel */
-	SH_CSS_DEBUG_DUMP_BNR = 1 << 5,  /**< Bayer Noise Reductions */
-	SH_CSS_DEBUG_DUMP_S3A = 1 << 6,  /**< 3A Statistics */
-	SH_CSS_DEBUG_DUMP_DE = 1 << 7,  /**< De Mosaicing */
-	SH_CSS_DEBUG_DUMP_YNR = 1 << 8,  /**< Luma Noise Reduction */
-	SH_CSS_DEBUG_DUMP_CSC = 1 << 9,  /**< Color Space Conversion */
-	SH_CSS_DEBUG_DUMP_GC = 1 << 10,  /**< Gamma Correction */
-	SH_CSS_DEBUG_DUMP_TNR = 1 << 11,  /**< Temporal Noise Reduction */
-	SH_CSS_DEBUG_DUMP_ANR = 1 << 12,  /**< Advanced Noise Reduction */
-	SH_CSS_DEBUG_DUMP_CE = 1 << 13,  /**< Chroma Enhancement */
-	SH_CSS_DEBUG_DUMP_ALL = 1 << 14  /**< Dump all device parameters */
-};
-
-
-/*! \brief Function to set the global dtrace verbosity level.
- * \param[in]	trace_level		Maximum level of the messages to be traced.
- * \return	None
- */
-void sh_css_set_dtrace_level(
-	const unsigned int	trace_level);
-
-/*! \brief Dump input formatter state.
- * Dumps the input formatter state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_if_state(void);
-
-/*! \brief Dump isp hardware state.
- * Dumps the isp hardware state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_isp_state(void);
-
-/*! \brief Dump sp hardware state.
- * Dumps the sp hardware state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_sp_state(void);
-
-/*! \brief Dump dma controller state.
- * Dumps the dma controller state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_dma_state(void);
-
-/*! \brief Dump internal sp software state.
- * Dumps the sp software state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_sp_sw_debug_info(void);
-
-/*! \brief Dump all related hardware state to the trace output
- * \param[in]  context	String to identify context in output.
- * \return	None
- */
-extern void sh_css_dump_debug_info(
-	const char	*context);
-
-void
-sh_css_sp_debug_dump_mipi_fifo_high_water(void);
-
-/*! \brief Dump isp gdc fifo state to the trace output
- * Dumps the isp gdc fifo state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_isp_gdc_fifo_state(void);
-
-/*! \brief Dump dma isp fifo state
- * Dumps the dma isp fifo state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_dma_isp_fifo_state(void);
-
-/*! \brief Dump dma sp fifo state
- * Dumps the dma sp fifo state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_dma_sp_fifo_state(void);
-
-/*! \brief Dump pif isp fifo state
- * Dumps the primary input formatter state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_pif_isp_fifo_state(void);
-
-/*! \brief Dump isp sp fifo state
- * Dumps the isp sp fifo state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_isp_sp_fifo_state(void);
-
-/*! \brief Dump all fifo state info to the output
- * Dumps all fifo state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_all_fifo_state(void);
-
-/*! \brief Dump the rx state to the output
- * Dumps the rx state to tracing output.
- * \return	None
- */
-extern void sh_css_dump_rx_state(void);
-
-
-/*! \brief Dump the frame info to the trace output
- * Dumps the frame info to tracing output.
- * \param[in]	frame		pointer to struct sh_css_frame
- * \param[in]	descr		description output along with the frame info
- * \return	None
- */
-extern void sh_css_frame_print(
-	const struct sh_css_frame	*frame,
-	const char	*descr);
-
-/*! \brief Function to enable sp sleep mode.
- * Function that enables sp sleep mode
- * \param[in]	mode		indicates when to put sp to sleep
- * \return	None
- */
-extern void
-sh_css_enable_sp_sleep_mode(enum sh_css_sp_sleep_mode mode);
-
-/*! \brief Function to wake up sp when in sleep mode.
- * After sp has been put to sleep, use this function to let it continue
- * to run again.
- * \return	None
- */
-extern void
-sh_css_wake_up_sp(void);
-
-/*! \brief Function to dump isp parameters.
- * Dump isp parameters to tracing output
- * \param[in]	enable		flag indicating which parameters to dump.
- * \return	None
- */
-extern void
-sh_css_dump_isp_params(unsigned int enable);
-
-/*
-extern void sh_css_init_ddr_debug_queue(void);
-extern void sh_css_load_ddr_debug_queue(void);
-extern void sh_css_dump_ddr_debug_queue(void); */
-
-/**
- * @brief Initialize the debug mode.
- *
- * WARNING:
- * This API should be called ONLY once in the debug mode.
- *
- * @return
- *	- true, if it is successful.
- *	- false, otherwise.
- */
-extern bool sh_css_debug_mode_init(void);
-
-/**
- * @brief Disable the DMA channel.
- *
- * @param[in]	dma_ID		The ID of the target DMA.
- * @param[in]	channel_id	The ID of the target DMA channel.
- * @param[in]	request_type	The type of the DMA request.
- *				For example:
- *				- "0" indicates the writing request.
- *				- "1" indicates the reading request.
- *
- * This is part of the DMA API -> dma.h
- *
- * @return
- *	- true, if it is successful.
- *	- false, otherwise.
- */
-extern bool sh_css_debug_mode_disable_dma_channel(
-	int dma_ID,
-		int channel_id,
-		int request_type);
-/**
- * @brief Enable the DMA channel.
- *
- * @param[in]	dma_id		The ID of the target DMA.
- * @param[in]	channel_id	The ID of the target DMA channel.
- * @param[in]	request_type	The type of the DMA request.
- *				For example:
- *				- "0" indicates the writing request.
- *				- "1" indicates the reading request.
- *
- *	- true, if it is successful.
- *	- false, otherwise.
- */
-extern bool sh_css_debug_mode_enable_dma_channel(
-	int dma_ID,
-		int channel_id,
-		int request_type);
-
-#endif /* _SH_CSS_DEBUG_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug_internal.h
deleted file mode 100644
index 72adfd0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_debug_internal.h
+++ /dev/null
@@ -1,101 +0,0 @@
-#ifndef _SH_CSS_DEBUG_INTERNAL_H_
-#define _SH_CSS_DEBUG_INTERNAL_H_
-
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-/*! \file */
-
-#include "sh_css.h"
-#include "sh_css_internal.h"
-
-/**
- * @brief Internal debug support for constructing a pipe graph.
- *
- * @return	None
- */
-extern void sh_css_debug_pipe_graph_dump_prologue(void);
-
-/**
- * @brief Internal debug support for constructing a pipe graph.
- *
- * @return	None
- */
-extern void sh_css_debug_pipe_graph_dump_epilogue(void);
-
-/**
- * @brief Internal debug support for constructing a pipe graph.
- * @param[in]	stage		Pipeline stage.
- * @param[in]	id		Pipe id.
- *
- * @return	None
- */
-extern void sh_css_debug_pipe_graph_dump_stage(
-		struct sh_css_pipeline_stage *stage,
-		enum sh_css_pipe_id id);
-
-/**
- * @brief Internal debug support for constructing a pipe graph.
- * @param[in]	cc_frame	Output frame of SP raw copy.
- *
- * @return	None
- */
-extern void sh_css_debug_pipe_graph_dump_sp_raw_copy(
-		struct sh_css_frame *cc_frame);
-
-
-/**
- * @brief Internal debug support for constructing a pipe graph.
- * @param[in]	width		Width as produced by sensor.
- * @param[in]	height		Height as produced by sensor
- *
- * @return	None
- */
-extern void
-sh_css_debug_pipe_graph_dump_input_set_resolution
-(unsigned int width, unsigned int height);
-
-/**
- * @brief Internal debug support for constructing a pipe graph.
- * @param[in]	width		Width as input to ISP.
- * @param[in]	height		Height as input to ISP
- *
- * @return	None
- *
- * @return	None
- */
-extern void
-sh_css_debug_pipe_graph_dump_input_set_effective_resolution
-(unsigned int effective_width, unsigned int effective_height);
-
-/**
- * @brief Internal debug support for constructing a pipe graph.
- * @param[in]	format		format as produced by sensor
- *
- * @return	None
- */
-extern void
-sh_css_debug_pipe_graph_dump_input_set_format
-(enum sh_css_input_format input_format);
-
-
-#endif /* _SH_CSS_DEBUG_INTERNAL_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_defs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_defs.h
deleted file mode 100644
index daeefd6..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_defs.h
+++ /dev/null
@@ -1,392 +0,0 @@
-#ifndef _SH_CSS_DEFS_H_
-#define _SH_CSS_DEFS_H_
-
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "isp.h"
-/*#include "vamem.h"*/ /* Cannot include for VAMEM properties this file is visible on ISP -> pipeline generator */
-
-/* System dependent versions
-   sh_css_types.h exports a system independent version. MW: Yeah, really...
-*/
-#if defined(HAS_VAMEM_VERSION_2)
-#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2      8
-#define SH_CSS_ISP_CTC_TABLE_SIZEM1         (1U<<SH_CSS_ISP_CTC_TABLE_SIZE_LOG2)
-#define SH_CSS_ISP_CTC_TABLE_SIZE           (SH_CSS_ISP_CTC_TABLE_SIZEM1 + 1)
-#define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2    8
-#define SH_CSS_ISP_GAMMA_TABLE_SIZEM1       (1U<<SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2)
-#define SH_CSS_ISP_GAMMA_TABLE_SIZE         (SH_CSS_ISP_GAMMA_TABLE_SIZEM1 + 1)
-#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2      6
-#define SH_CSS_ISP_XNR_TABLE_SIZE           (1U<<SH_CSS_ISP_XNR_TABLE_SIZE_LOG2)
-#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2 8
-#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZEM1 \
-				(1U<<SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2)
-#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE \
-				(SH_CSS_ISP_RGB_GAMMA_TABLE_SIZEM1 + 1)
-/*#define SH_CSS_ISP_XNR_TABLE_SIZE           (SH_CSS_ISP_XNR_TABLE_SIZEM1 + 1)*/
-#elif defined(HAS_VAMEM_VERSION_1)
-#define SH_CSS_ISP_CTC_TABLE_SIZE_LOG2      SH_CSS_CTC_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_CTC_TABLE_SIZE           SH_CSS_CTC_TABLE_SIZE
-#define SH_CSS_ISP_GAMMA_TABLE_SIZE_LOG2    SH_CSS_GAMMA_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_GAMMA_TABLE_SIZE         SH_CSS_GAMMA_TABLE_SIZE
-#define SH_CSS_ISP_XNR_TABLE_SIZE_LOG2      SH_CSS_XNR_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_XNR_TABLE_SIZE           SH_CSS_XNR_TABLE_SIZE
-#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2 SH_CSS_RGB_GAMMA_TABLE_SIZE_LOG2
-#define SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE      SH_CSS_RGB_GAMMA_TABLE_SIZE
-#else
-#error "sh_css_defs: Unknown VAMEM version"
-#endif
-
-#include"math_support.h"	/* max(), min, MAX(), MIN(), etc etc */
-
-/* Digital Image Stabilization */
-#define SH_CSS_DIS_DECI_FACTOR_LOG2       6
-
-/* UV offset: 1:uv=-128...127, 0:uv=0...255 */
-#define SH_CSS_UV_OFFSET_IS_0             0
-
-/* Bits of bayer is adjusted as 13 in ISP */
-#define SH_CSS_BAYER_BITS                 13
-/* Max value of bayer data (unsigned 13bit in ISP) */
-#define SH_CSS_BAYER_MAXVAL               ((1U << SH_CSS_BAYER_BITS) - 1)
-
-/* Bits of yuv in ISP */
-#define SH_CSS_ISP_YUV_BITS               8
-
-#define SH_CSS_DP_GAIN_SHIFT              5
-#define SH_CSS_BNR_GAIN_SHIFT             13
-#define SH_CSS_YNR_GAIN_SHIFT             13
-#define SH_CSS_AE_YCOEF_SHIFT             13
-#define SH_CSS_AF_FIR_SHIFT               13
-#define SH_CSS_YEE_DETAIL_GAIN_SHIFT      8  /* [u5.8] */
-#define SH_CSS_YEE_SCALE_SHIFT            8
-#define SH_CSS_TNR_COEF_SHIFT                    13
-#define SH_CSS_MACC_COEF_SHIFT            11 /* [s2.11] */
-
-/*--------------- sRGB Gamma -----------------
-CCM        : YCgCo[0,8191] -> RGB[0,4095]
-sRGB Gamma : RGB  [0,4095] -> RGB[0,8191]
-CSC        : RGB  [0,8191] -> YUV[0,8191]
-
-CCM:
-Y[0,8191],CgCo[-4096,4095],coef[-8192,8191] -> RGB[0,4095]
-
-sRGB Gamma:
-RGB[0,4095] -(interpolation step16)-> RGB[0,255] -(LUT 12bit)-> RGB[0,4095] -> RGB[0,8191]
-
-CSC:
-RGB[0,8191],coef[-8192,8191] -> RGB[0,8191]
---------------------------------------------*/
-/* Bits of input/output of sRGB Gamma */
-#define SH_CSS_RGB_GAMMA_INPUT_BITS       12 /* [0,4095] */
-#define SH_CSS_RGB_GAMMA_OUTPUT_BITS      13 /* [0,8191] */
-
-/* Bits of fractional part of interpolation in vamem, [0,4095]->[0,255] */
-#define SH_CSS_RGB_GAMMA_FRAC_BITS        \
-	(SH_CSS_RGB_GAMMA_INPUT_BITS - SH_CSS_ISP_RGB_GAMMA_TABLE_SIZE_LOG2)
-#define SH_CSS_RGB_GAMMA_ONE              (1 << SH_CSS_RGB_GAMMA_FRAC_BITS)
-
-/* Bits of input of CCM,  = 13, Y[0,8191],CgCo[-4096,4095] */
-#define SH_CSS_YUV2RGB_CCM_INPUT_BITS     SH_CSS_BAYER_BITS
-
-/* Bits of output of CCM,  = 12, RGB[0,4095] */
-#define SH_CSS_YUV2RGB_CCM_OUTPUT_BITS    SH_CSS_RGB_GAMMA_INPUT_BITS
-
-/* Bits of fractional part of coefficient of CCM, =12, [-1,1]=[-4096,4096] */
-#define SH_CSS_YUV2RGB_CCM_COEF_SHIFT     12
-
-/* Bits of shift in calculation of CCM, =12, [-1,1]=[-4096,4096] */
-#define SH_CSS_YUV2RGB_CCM_CALC_SHIFT     (SH_CSS_YUV2RGB_CCM_COEF_SHIFT \
-	+ (SH_CSS_YUV2RGB_CCM_INPUT_BITS - SH_CSS_YUV2RGB_CCM_OUTPUT_BITS))
-
-/* Maximum value of output of CCM */
-#define SH_CSS_YUV2RGB_CCM_MAX_OUTPUT     \
-	((1 << SH_CSS_YUV2RGB_CCM_OUTPUT_BITS) - 1)
-
-/* Bits of fractional part of coefficient of CSC */
-#define SH_CSS_RGB2YUV_CSC_COEF_SHIFT     13
-
-#define SH_CSS_NUM_INPUT_BUF_LINES        4
-
-/* Left cropping only applicable for sufficiently large nway */
-#if ISP_VEC_NELEMS == 16
-#define SH_CSS_MAX_LEFT_CROPPING          0
-#else
-#define SH_CSS_MAX_LEFT_CROPPING          12
-#endif
-
-#define	SH_CSS_SP_MAX_WIDTH               1280
-
-/* This is the maximum grid we can handle in the ISP binaries.
- * The host code makes sure no bigger grid is ever selected. */
-#define SH_CSS_MAX_BQ_GRID_WIDTH          80
-#define SH_CSS_MAX_BQ_GRID_HEIGHT         60
-
-/* The minimum dvs envelope is 8x8 to make sure the invalid rows/columns
-   that result from filter initialization are skipped. */
-#define SH_CSS_MIN_DVS_ENVELOPE           12
-
-/* The FPGA system (vec_nelems == 16) only supports upto 5MP */
-#if ISP_VEC_NELEMS == 16
-#define SH_CSS_MAX_SENSOR_WIDTH           2560
-#define SH_CSS_MAX_SENSOR_HEIGHT          1920
-#else
-#define SH_CSS_MAX_SENSOR_WIDTH           4608
-#define SH_CSS_MAX_SENSOR_HEIGHT          3450
-#endif
-
-/* Limited to reduce vmem pressure */
-#if ISP_VMEM_DEPTH >= 3072
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  SH_CSS_MAX_SENSOR_WIDTH
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT SH_CSS_MAX_SENSOR_HEIGHT
-#else
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH  3264
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT 2448
-#endif
-/* When using bayer decimation */
-/*
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  4224
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC 3168
-*/
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC  SH_CSS_MAX_SENSOR_WIDTH
-#define SH_CSS_MAX_CONTINUOUS_SENSOR_HEIGHT_DEC SH_CSS_MAX_SENSOR_HEIGHT
-
-#define SH_CSS_MIN_SENSOR_WIDTH           2
-#define SH_CSS_MIN_SENSOR_HEIGHT          2
-
-#define SH_CSS_MAX_VF_WIDTH               1280
-#define SH_CSS_MAX_VF_HEIGHT              960
-/*
-#define SH_CSS_MAX_VF_WIDTH_DEC               1920
-#define SH_CSS_MAX_VF_HEIGHT_DEC              1080
-*/
-#define SH_CSS_MAX_VF_WIDTH_DEC               SH_CSS_MAX_VF_WIDTH
-#define SH_CSS_MAX_VF_HEIGHT_DEC              SH_CSS_MAX_VF_HEIGHT
-
-/* We use 16 bits per coordinate component, including integer
-   and fractional bits */
-#define SH_CSS_MORPH_TABLE_GRID               ISP_VEC_NELEMS
-#define SH_CSS_MORPH_TABLE_ELEM_BYTES         2
-#define SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD \
-	(HIVE_ISP_DDR_WORD_BYTES/SH_CSS_MORPH_TABLE_ELEM_BYTES)
-
-#define SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR   (SH_CSS_MAX_BQ_GRID_WIDTH + 1)
-#define SH_CSS_MAX_SCTBL_HEIGHT_PER_COLOR   (SH_CSS_MAX_BQ_GRID_HEIGHT + 1)
-#define SH_CSS_MAX_SCTBL_ALIGNED_WIDTH_PER_COLOR \
-	CEIL_MUL(SH_CSS_MAX_SCTBL_WIDTH_PER_COLOR, ISP_VEC_NELEMS)
-
-/* Each line of this table is aligned to the maximum line width. */
-#define SH_CSS_MAX_S3ATBL_WIDTH              SH_CSS_MAX_BQ_GRID_WIDTH
-
-/* Rules: these implement logic shared between the host code and ISP firmware.
-   The ISP firmware needs these rules to be applied at pre-processor time,
-   that's why these are macros, not functions. */
-#define _ISP_BQS(num)  ((num)/2)
-#define _ISP_VECS(width) CEIL_DIV(width, ISP_VEC_NELEMS)
-
-#define ISP_BQ_GRID_WIDTH(elements_per_line, deci_factor_log2) \
-	CEIL_SHIFT(elements_per_line/2,  deci_factor_log2)
-#define ISP_BQ_GRID_HEIGHT(lines_per_frame, deci_factor_log2) \
-	CEIL_SHIFT(lines_per_frame/2,  deci_factor_log2)
-#define ISP_C_VECTORS_PER_LINE(elements_per_line) \
-	_ISP_VECS(elements_per_line/2)
-
-/* The morphing table is similar to the shading table in the sense that we
-   have 1 more value than we have cells in the grid. */
-#define _ISP_MORPH_TABLE_WIDTH(int_width) \
-	(CEIL_DIV(int_width, SH_CSS_MORPH_TABLE_GRID) + 1)
-#define _ISP_MORPH_TABLE_HEIGHT(int_height) \
-	(CEIL_DIV(int_height, SH_CSS_MORPH_TABLE_GRID) + 1)
-#define _ISP_MORPH_TABLE_ALIGNED_WIDTH(width) \
-	CEIL_MUL(_ISP_MORPH_TABLE_WIDTH(width), \
-		 SH_CSS_MORPH_TABLE_ELEMS_PER_DDR_WORD)
-
-#define _ISP_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
-	(ISP_BQ_GRID_WIDTH(input_width, deci_factor_log2) + 1)
-#define _ISP_SCTBL_HEIGHT(input_height, deci_factor_log2) \
-	(ISP_BQ_GRID_HEIGHT(input_height, deci_factor_log2) + 1)
-#define _ISP_SCTBL_ALIGNED_WIDTH_PER_COLOR(input_width, deci_factor_log2) \
-	CEIL_MUL(_ISP_SCTBL_WIDTH_PER_COLOR(input_width, deci_factor_log2), \
-		 ISP_VEC_NELEMS)
-
-/* ********************************************************
- * Statistics for Digital Image Stabilization
- * ********************************************************/
-/* Some binaries put the vertical coefficients in DMEM instead
-   of VMEM to save VMEM. */
-#define _SDIS_VER_COEF_TBL_USE_DMEM(mode, enable_sdis) \
-	(mode == SH_CSS_BINARY_MODE_VIDEO && enable_sdis)
-
-/* For YUV upscaling, the internal size is used for DIS statistics */
-#define _ISP_SDIS_ELEMS_ISP(input, internal, enable_us) \
-	((enable_us) ? (internal) : (input))
-
-/* SDIS Projections:
- * Horizontal projections are calculated for each line.
- * Vertical projections are calculated for each column.
- * Grid cells that do not fall completely within the image are not
- * valid. The host needs to use the bigger one for the stride but
- * should only return the valid ones to the 3A. */
-#define __ISP_SDIS_HOR_PROJ_NUM_ISP(in_height, deci_factor_log2) \
-	CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)
-#define __ISP_SDIS_VER_PROJ_NUM_ISP(in_width, deci_factor_log2) \
-	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
-
-#define _ISP_SDIS_HOR_PROJ_NUM_3A(in_height, deci_factor_log2) \
-	(_ISP_BQS(in_height) >> deci_factor_log2)
-#define _ISP_SDIS_VER_PROJ_NUM_3A(in_width, deci_factor_log2) \
-	(_ISP_BQS(in_width) >> deci_factor_log2)
-
-/* SDIS Coefficients: */
-/* The ISP uses vectors to store the coefficients, so we round
-   the number of coefficients up to vectors. */
-#define __ISP_SDIS_HOR_COEF_NUM_VECS(in_width)  _ISP_VECS(_ISP_BQS(in_width))
-#define __ISP_SDIS_VER_COEF_NUM_VECS(in_height) _ISP_VECS(_ISP_BQS(in_height))
-
-/* The number of coefficients produced by the ISP */
-#define _ISP_SDIS_HOR_COEF_NUM_ISP(in_width) \
-	(__ISP_SDIS_HOR_COEF_NUM_VECS(in_width) * ISP_VEC_NELEMS)
-#define _ISP_SDIS_VER_COEF_NUM_ISP(in_height) \
-	(__ISP_SDIS_VER_COEF_NUM_VECS(in_height) * ISP_VEC_NELEMS)
-
-/* The number of coefficients used by the 3A library. This excludes
-   coefficients from grid cells that do not fall completely within the image. */
-#define _ISP_SDIS_HOR_COEF_NUM_3A(in_width, deci_factor_log2) \
-	((_ISP_BQS(in_width) >> deci_factor_log2) << deci_factor_log2)
-#define _ISP_SDIS_VER_COEF_NUM_3A(in_height, deci_factor_log2) \
-	((_ISP_BQS(in_height) >> deci_factor_log2) << deci_factor_log2)
-
-/* *****************************************************************
- * Statistics for 3A (Auto Focus, Auto White Balance, Auto Exposure)
- * *****************************************************************/
-/* if left cropping is used, 3A statistics are also cropped by 2 vectors. */
-#define _ISP_S3ATBL_WIDTH(in_width, deci_factor_log2) \
-	(_ISP_BQS(in_width) >> deci_factor_log2)
-#define _ISP_S3ATBL_HEIGHT(in_height, deci_factor_log2) \
-	(_ISP_BQS(in_height) >> deci_factor_log2)
-
-#define _ISP_S3A_ELEMS_ISP_WIDTH(in_width, int_width, enable_hus, left_crop) \
-	(((enable_hus) ? (int_width) : (in_width)) \
-	 - ((left_crop) ? 2 * ISP_VEC_NELEMS : 0))
-#define _ISP_S3A_ELEMS_ISP_HEIGHT(in_height, int_height, enable_vus) \
-	((enable_vus) ? (int_height) : (in_height))
-
-#define _ISP_S3ATBL_ISP_WIDTH(in_width, deci_factor_log2) \
-	CEIL_SHIFT(_ISP_BQS(in_width), deci_factor_log2)
-#define _ISP_S3ATBL_ISP_HEIGHT(in_height, deci_factor_log2) \
-	CEIL_SHIFT(_ISP_BQS(in_height), deci_factor_log2)
-#define ISP_S3ATBL_VECTORS \
-	_ISP_VECS(SH_CSS_MAX_S3ATBL_WIDTH * \
-		  (sizeof(struct sh_css_3a_output)/sizeof(int)))
-#define ISP_S3ATBL_HI_LO_STRIDE \
-	(ISP_S3ATBL_VECTORS * ISP_VEC_NELEMS)
-#define ISP_S3ATBL_HI_LO_STRIDE_BYTES \
-	(sizeof(unsigned short) * ISP_S3ATBL_HI_LO_STRIDE)
-
-/* Viewfinder support */
-#define __ISP_MAX_VF_OUTPUT_WIDTH(width, left_crop) \
-	(width - 2*ISP_VEC_NELEMS + ((left_crop) ? 2 * ISP_VEC_NELEMS : 0))
-
-/* Number of vectors per vf line is determined by the chroma width,
- * the luma width is derived from that. That's why we have the +1. */
-#define __ISP_VF_OUTPUT_WIDTH_VECS(out_width, vf_log_downscale) \
-	(_ISP_VECS((out_width) >> ((vf_log_downscale)+1)) * 2)
-
-#define _ISP_VF_OUTPUT_WIDTH(vf_out_vecs) ((vf_out_vecs) * ISP_VEC_NELEMS)
-#define _ISP_VF_OUTPUT_HEIGHT(out_height, vf_log_ds) \
-	((out_height) >> (vf_log_ds))
-
-#define _ISP_LOG_VECTOR_STEP(mode) \
-	((mode) == SH_CSS_BINARY_MODE_CAPTURE_PP ? 2 : 1)
-
-/* Rules for computing the internal width. This is extremely complicated
- * and definitely needs to be commented and explained. */
-#define _ISP_LEFT_CROP_EXTRA(left_crop) ((left_crop) > 0 ? 2*ISP_VEC_NELEMS : 0)
-
-#define __ISP_MIN_INTERNAL_WIDTH(num_chunks, pipelining, mode) \
-	((num_chunks) * (pipelining) * (1<<_ISP_LOG_VECTOR_STEP(mode)) * \
-	 ISP_VEC_NELEMS)
-#define __ISP_PADDED_OUTPUT_WIDTH(out_width, dvs_env_width, left_crop) \
-	((out_width) + MAX(dvs_env_width, _ISP_LEFT_CROP_EXTRA(left_crop)))
-
-#define __ISP_CHUNK_STRIDE_ISP(mode) \
-	((1<<_ISP_LOG_VECTOR_STEP(mode)) * ISP_VEC_NELEMS)
-
-#define __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
-	((c_subsampling) * (num_chunks) * HIVE_ISP_DDR_WORD_BYTES)
-#if 0
-#define __ISP_RGBA_WIDTH(rgba, num_chunks) \
-	((rgba) ? (num_chunks)*4*2*ISP_VEC_NELEMS : 0)
-#else
-#define __ISP_RGBA_WIDTH(rgba, num_chunks) \
-	(0)
-#endif
-#define __ISP_INTERNAL_WIDTH(out_width, \
-			     dvs_env_width, \
-			     left_crop, \
-			     mode, \
-			     c_subsampling, \
-			     num_chunks, \
-			     pipelining, \
-			     rgba) \
-	CEIL_MUL2(CEIL_MUL2(MAX(MAX(__ISP_PADDED_OUTPUT_WIDTH(out_width, \
-							    dvs_env_width, \
-							    left_crop), \
-				  __ISP_MIN_INTERNAL_WIDTH(num_chunks, \
-							   pipelining, \
-							   mode) \
-				 ), \
-			      __ISP_RGBA_WIDTH(rgba, num_chunks) \
-			     ), \
-			  __ISP_CHUNK_STRIDE_ISP(mode) \
-			 ), \
-		 __ISP_CHUNK_STRIDE_DDR(c_subsampling, num_chunks) \
-		)
-
-#define __ISP_INTERNAL_HEIGHT(out_height, dvs_env_height, top_crop) \
-	((out_height) + (dvs_env_height) + top_crop)
-
-/* @GC: Input can be up to sensor resolution when either bayer downscaling
- *	or raw binning is enabled.
- *	Also, during continuous mode, we need to align to 4*NWAY since input
- *	should support binning */
-#define _ISP_MAX_INPUT_WIDTH(max_internal_width, enable_ds, enable_fixed_bayer_ds, enable_raw_bin, \
-				enable_continuous) \
-	((enable_ds) ? \
-	   SH_CSS_MAX_SENSOR_WIDTH :\
-	 (enable_fixed_bayer_ds) ? \
-	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC,4*ISP_VEC_NELEMS) : \
-	 (enable_raw_bin) ? \
-	   CEIL_MUL(SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH,4*ISP_VEC_NELEMS) : \
-	 (enable_continuous) ? \
-	   SH_CSS_MAX_CONTINUOUS_SENSOR_WIDTH_DEC \
-	   : max_internal_width)
-
-#define _ISP_INPUT_WIDTH(internal_width, ds_input_width, enable_ds) \
-	((enable_ds) ? (ds_input_width) : (internal_width))
-
-#define _ISP_INPUT_HEIGHT(internal_height, ds_input_height, enable_ds) \
-	((enable_ds) ? (ds_input_height) : (internal_height))
-
-#endif /* _SH_CSS_DEFS_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.c
deleted file mode 100644
index d7b5d5b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.c
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "sh_css_firmware.h"
-
-#include "sh_css_defs.h"
-#include "sh_css_internal.h"
-#include "sh_css_sp_start.h"
-
-#include "memory_access.h"
-
-#include "isp.h"				/* PMEM_WIDTH_LOG2 */
-
-struct sh_css_fw_info	  sh_css_sp_fw;
-struct sh_css_blob_descr *sh_css_blob_info; /* Only ISP blob info (no SP) */
-unsigned		  sh_css_num_binaries; /* This includes 1 SP binary */
-
-/*
- * Split the loaded firmware into blobs
- */
-
-/* Setup sp binary */
-static void
-setup_sp(struct sh_css_fw_info *fw, const char *fw_data)
-{
-	const char  *blob_data = fw_data + fw->blob.offset;
-
-	sh_css_sp_fw = *fw;
-	sh_css_sp_fw.blob.text = blob_data + fw->blob.text_source;
-	sh_css_sp_fw.blob.data = blob_data + fw->blob.data_source;
-}
-
-enum sh_css_err
-sh_css_load_firmware(const char *fw_data,
-		     unsigned int fw_size)
-{
-	unsigned i;
-	struct sh_css_fw_info *binaries;
-	struct sh_css_fw_bi_file_h *file_header;
-
-	file_header = (struct sh_css_fw_bi_file_h *)fw_data;
-	binaries = (struct sh_css_fw_info *)(&file_header[1]);
-
-	/* some sanity checks */
-	if (!fw_data || fw_size < sizeof(struct sh_css_fw_bi_file_h))
-		return sh_css_err_internal_error;
-
-	if (file_header->h_size != sizeof(struct sh_css_fw_bi_file_h))
-		return sh_css_err_internal_error;
-
-	sh_css_num_binaries = file_header->binary_nr;
-	/* Only allocate memory for ISP blob info */
-	sh_css_blob_info = sh_css_malloc((sh_css_num_binaries - 1) *
-						sizeof(*sh_css_blob_info));
-	if (sh_css_blob_info == NULL)
-		return sh_css_err_cannot_allocate_memory;
-
-	for (i = 0; i < sh_css_num_binaries; i++) {
-		struct sh_css_fw_info *bi = &binaries[i];
-		const char *name;
-
-		name = (const char *)fw_data + bi->blob.prog_name_offset;
-
-		/* sanity check */
-		if (bi->blob.size != bi->blob.text_size + bi->blob.icache_size + bi->blob.data_size)
-			return sh_css_err_internal_error;
-
-		if (bi->blob.offset + bi->blob.size > fw_size)
-			return sh_css_err_internal_error;
-
-		if ((bi->blob.offset % (1UL<<(ISP_PMEM_WIDTH_LOG2-3))) != 0)
-			return sh_css_err_internal_error;
-
-		if (bi->type == sh_css_sp_firmware) {
-			/* The first binary (i==0) is always the SP firmware */
-			setup_sp(bi, fw_data);
-		} else {
-			/* All subsequent binaries (i>=1) are ISP firmware */
-			const unsigned char *blob =
-				(const unsigned char *)fw_data +
-				bi->blob.offset;
-			sh_css_blob_info[i-1].blob = blob;
-			sh_css_blob_info[i-1].header = *bi;
-			sh_css_blob_info[i-1].name = name;
-		}
-	}
-	return sh_css_success;
-}
-
-void sh_css_unload_firmware(void)
-{
-	if (sh_css_blob_info) {
-		sh_css_free(sh_css_blob_info);
-		sh_css_blob_info = NULL;
-	}
-}
-
-hrt_vaddress
-sh_css_load_blob(const unsigned char *blob, unsigned size)
-{
-	hrt_vaddress target_addr = mmgr_malloc(size);
-	/* this will allocate memory aligned to a DDR word boundary which
-	   is required for the CSS DMA to read the instructions. */
-	mmgr_store(target_addr, blob, size);
-#if SH_CSS_PREVENT_UNINIT_READS
-	{
-		unsigned padded_size = CEIL_MUL(size, HIVE_ISP_DDR_WORD_BYTES);
-		mmgr_clear(target_addr + size, padded_size - size);
-	}
-#endif
-	return target_addr;
-}
-
-enum sh_css_err
-sh_css_load_blob_info(const char *fw, struct sh_css_blob_descr *bd)
-{
-	const char *name;
-	const unsigned char *blob;
-	struct sh_css_fw_info *bi = (struct sh_css_fw_info *)fw;
-
-	name = fw + sizeof(*bi);
-	blob = (const unsigned char *)name + strlen(name)+1;
-
-	/* sanity check */
-	if (bi->header_size != sizeof(*bi))
-		return sh_css_err_isp_binary_header_mismatch;
-	if (bi->blob.size != bi->blob.text_size + bi->blob.icache_size + bi->blob.data_size)
-		return sh_css_err_isp_binary_header_mismatch;
-
-	bd->blob = blob;
-	bd->header = *bi;
-	bd->name = name;
-	return sh_css_success;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.h
deleted file mode 100644
index 9204f5f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_firmware.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_FIRMWARE_H_
-#define _SH_CSS_FIRMWARE_H_
-
-#include "system_types.h"
-
-#include "sh_css_types.h"
-
-/* This is for the firmware loaded from user space */
-struct  sh_css_fw_bi_file_h {
-	int version;			/* Date in the form YYYYMMDD */
-	int binary_nr;			/* Number of binaries */
-	unsigned int h_size;		/* sizeof(struct sh_css_fw_bi_file_h) */
-};
-
-struct sh_css_blob_descr {
-	const unsigned char  *blob;
-	struct sh_css_fw_info header;
-	const char	     *name;
-};
-
-extern struct sh_css_fw_info     sh_css_sp_fw;
-extern struct sh_css_blob_descr *sh_css_blob_info;
-extern unsigned			 sh_css_num_binaries;
-
-enum sh_css_err
-sh_css_load_firmware(const char *fw_data,
-		     unsigned int fw_size);
-
-void sh_css_unload_firmware(void);
-
-hrt_vaddress sh_css_load_blob(const unsigned char *blob, unsigned size);
-
-enum sh_css_err
-sh_css_load_blob_info(const char *fw, struct sh_css_blob_descr *bd);
-
-#endif /* _SH_CSS_FIRMWARE_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.c
deleted file mode 100644
index daac4c4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.c
+++ /dev/null
@@ -1,576 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "platform_support.h"
-
-#include "sh_css_hrt.h"
-
-#include "device_access.h"
-
-#define __INLINE_SP__
-#include "sp.h"
-#define __INLINE_ISP__
-#include "isp.h"
-#define __INLINE_IRQ__
-#include "irq.h"
-#define __INLINE_FIFO_MONITOR__
-#include "fifo_monitor.h"
-
-#include "input_system.h"	/* MIPI_PREDICTOR_NONE,... */
-
-/* System independent */
-#include "sh_css_internal.h"
-#include "sh_css_sp_start.h"	/* sh_css_sp_start_function() */
-
-#define HBLANK_CYCLES (187)
-#define MARKER_CYCLES (6)
-
-#include <hive_isp_css_streaming_to_mipi_types_hrt.h>
-
-/* The data type is used to send special cases:
- * yuv420: odd lines (1, 3 etc) are twice as wide as even
- *         lines (0, 2, 4 etc).
- * rgb: for two pixels per clock, the R and B values are sent
- *      to output_0 while only G is sent to output_1. This means
- *      that output_1 only gets half the number of values of output_0.
- *      WARNING: This type should also be used for Legacy YUV420.
- * regular: used for all other data types (RAW, YUV422, etc)
- */
-enum sh_css_mipi_data_type {
-	sh_css_mipi_data_type_regular,
-	sh_css_mipi_data_type_yuv420,
-	sh_css_mipi_data_type_yuv420_legacy,
-	sh_css_mipi_data_type_rgb,
-};
-
-static hrt_address gp_fifo_base_address     = GP_FIFO_BASE;
-static unsigned int curr_ch_id, curr_fmt_type;
-
-struct streaming_to_mipi_instance {
-	unsigned int				ch_id;
-	enum sh_css_input_format	input_format;
-	bool						two_ppc;
-	bool						streaming;
-	unsigned int				hblank_cycles;
-	unsigned int				marker_cycles;
-	unsigned int				fmt_type;
-	enum sh_css_mipi_data_type	type;
-};
-
-/*
- * Maintain a basic streaming to Mipi administration with ch_id as index
- * ch_id maps on the "Mipi virtual channel ID" and can have value 0..3
- */
-#define NR_OF_S2M_CHANNELS	(4)
-static struct streaming_to_mipi_instance s2m_inst_admin[NR_OF_S2M_CHANNELS];
-
-void sh_css_hrt_sp_start_isp(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_start_isp_entry =
-					fw->info.sp.sp_entry;
-	(void)HIVE_ADDR_sp_start_isp_entry;
-	sh_css_sp_start_function(sp_start_isp);
-return;
-}
-
-bool sh_css_hrt_system_is_idle(void)
-{
-	hrt_data	status;
-	bool not_idle = false;
-
-	not_idle |= !isp_ctrl_getbit(ISP0_ID, ISP_SC_REG, ISP_IDLE_BIT);
-
-	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
-		HIVE_GP_REGS_SP_STREAM_STAT_IDX);
-	not_idle |= ((status & FIFO_CHANNEL_SP_VALID_MASK) != 0);
-
-#if defined(HAS_FIFO_MONITORS_VERSION_2)
-	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
-		HIVE_GP_REGS_SP_STREAM_STAT_B_IDX);
-	not_idle |= ((status & FIFO_CHANNEL_SP_VALID_B_MASK) != 0);
-#endif
-
-	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
-		HIVE_GP_REGS_ISP_STREAM_STAT_IDX);
-	not_idle |= ((status & FIFO_CHANNEL_ISP_VALID_MASK) != 0);
-
-	status = fifo_monitor_reg_load(FIFO_MONITOR0_ID,
-		HIVE_GP_REGS_MOD_STREAM_STAT_IDX);
-	not_idle |= ((status & FIFO_CHANNEL_MOD_VALID_MASK) != 0);
-
-return !not_idle;
-}
-
-enum sh_css_err sh_css_hrt_sp_wait(void)
-{
-#if defined(HAS_IRQ_MAP_VERSION_2)
-	irq_sw_channel_id_t	irq_id = IRQ_SW_CHANNEL0_ID;
-#else
-	irq_sw_channel_id_t	irq_id = IRQ_SW_CHANNEL2_ID;
-#endif
-	/*
-	 * Wait till SP is idle or till there is a SW2 interrupt
-	 * The SW2 interrupt will be used when frameloop runs on SP
-	 * and signals an event with similar meaning as SP idle
-	 * (e.g. frame_done)
-	 */
-	while (!sp_ctrl_getbit(SP0_ID, SP_SC_REG, SP_IDLE_BIT) &&
-		((irq_reg_load(IRQ0_ID,
-			_HRT_IRQ_CONTROLLER_STATUS_REG_IDX) &
-			(1U<<(irq_id + IRQ_SW_CHANNEL_OFFSET))) == 0)) {
-		hrt_sleep();
-	}
-
-return sh_css_success;
-}
-
-/* Streaming to MIPI */
-static unsigned _sh_css_wrap_marker(
-/* STORAGE_CLASS_INLINE unsigned _sh_css_wrap_marker( */
-	unsigned marker)
-{
-return marker |
-	(curr_ch_id << HIVE_STR_TO_MIPI_CH_ID_LSB) |
-	(curr_fmt_type << _HIVE_STR_TO_MIPI_FMT_TYPE_LSB);
-}
-
-static void sh_css_streaming_to_mipi_send_data_a(
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_data_a( */
-	unsigned int data)
-{
-	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
-			     (data << HIVE_STR_TO_MIPI_DATA_A_LSB);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_data_b(
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_data_b( */
-	unsigned int data)
-{
-	unsigned int token = (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
-			     (data << _HIVE_STR_TO_MIPI_DATA_B_LSB);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_data(
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_data( */
-	unsigned int a,
-	unsigned int b)
-{
-	unsigned int token = ((1 << HIVE_STR_TO_MIPI_VALID_A_BIT) |
-			      (1 << HIVE_STR_TO_MIPI_VALID_B_BIT) |
-			      (a << HIVE_STR_TO_MIPI_DATA_A_LSB) |
-			      (b << _HIVE_STR_TO_MIPI_DATA_B_LSB));
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_sol(void)
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_sol(void) */
-{
-	hrt_data	token = _sh_css_wrap_marker(
-		1 << HIVE_STR_TO_MIPI_SOL_BIT);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_eol(void)
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_eol(void) */
-{
-	hrt_data	token = _sh_css_wrap_marker(
-		1 << HIVE_STR_TO_MIPI_EOL_BIT);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_sof(void)
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_sof(void) */
-{
-	hrt_data	token = _sh_css_wrap_marker(
-		1 << HIVE_STR_TO_MIPI_SOF_BIT);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_eof(void)
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_eof(void) */
-{
-	hrt_data	token = _sh_css_wrap_marker(
-		1 << HIVE_STR_TO_MIPI_EOF_BIT);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-#ifdef __ON__
-static void sh_css_streaming_to_mipi_send_ch_id(
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_ch_id( */
-	unsigned int ch_id)
-{
-	hrt_data	token;
-	curr_ch_id = ch_id & _HIVE_ISP_CH_ID_MASK;
-	/* we send an zero marker, this will wrap the ch_id and
-	 * fmt_type automatically.
-	 */
-	token = _sh_css_wrap_marker(0);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_fmt_type(
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_fmt_type( */
-	unsigned int fmt_type)
-{
-	hrt_data	token;
-	curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
-	/* we send an zero marker, this will wrap the ch_id and
-	 * fmt_type automatically.
-	 */
-	token = _sh_css_wrap_marker(0);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-#endif /*  __ON__ */
-
-static void sh_css_streaming_to_mipi_send_ch_id_and_fmt_type(
-/* STORAGE_CLASS_INLINE
-void sh_css_streaming_to_mipi_send_ch_id_and_fmt_type( */
-	unsigned int ch_id,
-	unsigned int fmt_type)
-{
-	hrt_data	token;
-	curr_ch_id = ch_id & _HIVE_ISP_CH_ID_MASK;
-	curr_fmt_type = fmt_type & _HIVE_ISP_FMT_TYPE_MASK;
-	/* we send an zero marker, this will wrap the ch_id and
-	 * fmt_type automatically.
-	 */
-	token = _sh_css_wrap_marker(0);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_streaming_to_mipi_send_empty_token(void)
-/* STORAGE_CLASS_INLINE void sh_css_streaming_to_mipi_send_empty_token(void) */
-{
-	hrt_data	token = _sh_css_wrap_marker(0);
-	device_store_uint32(gp_fifo_base_address, token);
-return;
-}
-
-static void sh_css_hrt_s2m_start_frame(
-/* STORAGE_CLASS_INLINE void sh_css_hrt_s2m_start_frame( */
-	unsigned int ch_id,
-	unsigned int fmt_type)
-{
-	sh_css_streaming_to_mipi_send_ch_id_and_fmt_type(ch_id, fmt_type);
-	sh_css_streaming_to_mipi_send_sof();
-return;
-}
-
-static void sh_css_hrt_s2m_end_frame(
-	unsigned int marker_cycles)
-{
-	unsigned int i;
-	for (i = 0; i < marker_cycles; i++)
-		sh_css_streaming_to_mipi_send_empty_token();
-	sh_css_streaming_to_mipi_send_eof();
-return;
-}
-
-static void sh_css_hrt_s2m_send_line2(
-	unsigned short *data,
-	unsigned int width,
-	unsigned short *data2,
-	unsigned int width2,
-	unsigned int hblank_cycles,
-	unsigned int marker_cycles,
-	unsigned int two_ppc,
-	enum sh_css_mipi_data_type type)
-{
-	unsigned int i, is_rgb = 0, is_legacy = 0;
-
-	if (type == sh_css_mipi_data_type_rgb)
-		is_rgb = 1;
-
-	if (type == sh_css_mipi_data_type_yuv420_legacy)
-		is_legacy = 1;
-
-	for (i = 0; i < hblank_cycles; i++)
-		sh_css_streaming_to_mipi_send_empty_token();
-	sh_css_streaming_to_mipi_send_sol();
-	for (i = 0; i < marker_cycles; i++)
-		sh_css_streaming_to_mipi_send_empty_token();
-	for (i = 0; i < width; i++, data++) {
-		/* for RGB in two_ppc, we only actually send 2 pixels per
-		 * clock in the even pixels (0, 2 etc). In the other cycles,
-		 * we only send 1 pixel, to data[0].
-		 */
-		unsigned int send_two_pixels = two_ppc;
-		if ((is_rgb || is_legacy) && (i % 3 == 2))
-			send_two_pixels = 0;
-		if (send_two_pixels) {
-			if (i + 1 == width) {
-				/* for jpg (binary) copy, this can occur
-				 * if the file contains an odd number of bytes.
-				 */
-				sh_css_streaming_to_mipi_send_data(
-							data[0], 0);
-			} else {
-				sh_css_streaming_to_mipi_send_data(
-							data[0], data[1]);
-			}
-			/* Additional increment because we send 2 pixels */
-			data++;
-			i++;
-		} else if (two_ppc && is_legacy) {
-			sh_css_streaming_to_mipi_send_data_b(data[0]);
-		} else {
-			sh_css_streaming_to_mipi_send_data_a(data[0]);
-		}
-	}
-
-	for (i = 0; i < width2; i++, data2++) {
-		/* for RGB in two_ppc, we only actually send 2 pixels per
-		 * clock in the even pixels (0, 2 etc). In the other cycles,
-		 * we only send 1 pixel, to data2[0].
-		 */
-		unsigned int send_two_pixels = two_ppc;
-		if ((is_rgb || is_legacy) && (i % 3 == 2))
-			send_two_pixels = 0;
-		if (send_two_pixels) {
-			if (i + 1 == width2) {
-				/* for jpg (binary) copy, this can occur
-				 * if the file contains an odd number of bytes.
-				 */
-				sh_css_streaming_to_mipi_send_data(
-							data2[0], 0);
-			} else {
-				sh_css_streaming_to_mipi_send_data(
-							data2[0], data2[1]);
-			}
-			/* Additional increment because we send 2 pixels */
-			data2++;
-			i++;
-		} else if (two_ppc && is_legacy) {
-			sh_css_streaming_to_mipi_send_data_b(data2[0]);
-		} else {
-			sh_css_streaming_to_mipi_send_data_a(data2[0]);
-		}
-	}
-	for (i = 0; i < hblank_cycles; i++)
-		sh_css_streaming_to_mipi_send_empty_token();
-	sh_css_streaming_to_mipi_send_eol();
-return;
-}
-
-static void
-sh_css_hrt_s2m_send_line(unsigned short *data,
-				unsigned int width,
-				unsigned int hblank_cycles,
-				unsigned int marker_cycles,
-				unsigned int two_ppc,
-				enum sh_css_mipi_data_type type)
-{
-	sh_css_hrt_s2m_send_line2(data, width, NULL, 0,
-					hblank_cycles,
-					marker_cycles,
-					two_ppc,
-					type);
-return;
-}
-
-/* Send a frame of data into the input network via the GP FIFO.
- *  Parameters:
- *   - data: array of 16 bit values that contains all data for the frame.
- *   - width: width of a line in number of subpixels, for yuv420 it is the
- *            number of Y components per line.
- *   - height: height of the frame in number of lines.
- *   - ch_id: channel ID.
- *   - fmt_type: format type.
- *   - hblank_cycles: length of horizontal blanking in cycles.
- *   - marker_cycles: number of empty cycles after start-of-line and before
- *                    end-of-frame.
- *   - two_ppc: boolean, describes whether to send one or two pixels per clock
- *              cycle. In this mode, we sent pixels N and N+1 in the same cycle,
- *              to IF_PRIM_A and IF_PRIM_B respectively. The caller must make
- *              sure the input data has been formatted correctly for this.
- *              For example, for RGB formats this means that unused values
- *              must be inserted.
- *   - yuv420: boolean, describes whether (non-legacy) yuv420 data is used. In
- *             this mode, the odd lines (1,3,5 etc) are half as long as the
- *             even lines (2,4,6 etc).
- *             Note that the first line is odd (1) and the second line is even
- *             (2).
- *
- * This function does not do any reordering of pixels, the caller must make
- * sure the data is in the righ format. Please refer to the CSS receiver
- * documentation for details on the data formats.
- */
-static void sh_css_hrt_s2m_send_frame(
-	unsigned short *data,
-	unsigned int width,
-	unsigned int height,
-	unsigned int ch_id,
-	unsigned int fmt_type,
-	unsigned int hblank_cycles,
-	unsigned int marker_cycles,
-	unsigned int two_ppc,
-	enum sh_css_mipi_data_type type)
-{
-	unsigned int i;
-
-	sh_css_hrt_s2m_start_frame(ch_id, fmt_type);
-	for (i = 0; i < height; i++) {
-		if ((type == sh_css_mipi_data_type_yuv420) &&
-		    (i & 1) == 1) {
-			sh_css_hrt_s2m_send_line(data, 2 * width,
-							   hblank_cycles,
-							   marker_cycles,
-							   two_ppc, type);
-			data += 2 * width;
-		} else {
-			sh_css_hrt_s2m_send_line(data, width,
-							   hblank_cycles,
-							   marker_cycles,
-							   two_ppc, type);
-			data += width;
-		}
-	}
-	sh_css_hrt_s2m_end_frame(marker_cycles);
-return;
-}
-
-static enum sh_css_mipi_data_type sh_css_hrt_s2m_determine_type(
-	enum sh_css_input_format input_format)
-{
-	enum sh_css_mipi_data_type type;
-
-	type = sh_css_mipi_data_type_regular;
-	if (input_format == SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY) {
-		type =
-			sh_css_mipi_data_type_yuv420_legacy;
-	} else if (input_format == SH_CSS_INPUT_FORMAT_YUV420_8 ||
-		   input_format == SH_CSS_INPUT_FORMAT_YUV420_10) {
-		type =
-			sh_css_mipi_data_type_yuv420;
-	} else if (input_format >= SH_CSS_INPUT_FORMAT_RGB_444 &&
-		   input_format <= SH_CSS_INPUT_FORMAT_RGB_888) {
-		type =
-			sh_css_mipi_data_type_rgb;
-	}
-return type;
-}
-
-static struct streaming_to_mipi_instance *sh_css_hrt_s2m_get_inst(
-	unsigned int ch_id)
-{
-return &s2m_inst_admin[ch_id];
-}
-
-void sh_css_hrt_send_input_frame(
-	unsigned short *data,
-	unsigned int width,
-	unsigned int height,
-	unsigned int ch_id,
-	enum sh_css_input_format input_format,
-	bool two_ppc)
-{
-	unsigned int fmt_type, hblank_cycles, marker_cycles;
-	enum sh_css_mipi_data_type type;
-
-	hblank_cycles = HBLANK_CYCLES;
-	marker_cycles = MARKER_CYCLES;
-	sh_css_input_format_type(input_format,
-				 MIPI_PREDICTOR_NONE,
-				 &fmt_type);
-
-	type = sh_css_hrt_s2m_determine_type(input_format);
-
-	sh_css_hrt_s2m_send_frame(data, width, height,
-			ch_id, fmt_type, hblank_cycles, marker_cycles,
-			two_ppc, type);
-return;
-}
-
-void sh_css_hrt_streaming_to_mipi_start_frame(
-	unsigned int ch_id,
-	enum sh_css_input_format input_format,
-	bool two_ppc)
-{
-	struct streaming_to_mipi_instance *s2mi;
-	s2mi = sh_css_hrt_s2m_get_inst(ch_id);
-
-	s2mi->ch_id = ch_id;
-	sh_css_input_format_type(input_format, MIPI_PREDICTOR_NONE,
-				&s2mi->fmt_type);
-	s2mi->two_ppc = two_ppc;
-	s2mi->type = sh_css_hrt_s2m_determine_type(input_format);
-	s2mi->hblank_cycles = HBLANK_CYCLES;
-	s2mi->marker_cycles = MARKER_CYCLES;
-	s2mi->streaming = true;
-
-	sh_css_hrt_s2m_start_frame(ch_id, s2mi->fmt_type);
-return;
-}
-
-void sh_css_hrt_streaming_to_mipi_send_line(
-	unsigned int ch_id,
-	unsigned short *data,
-	unsigned int width,
-	unsigned short *data2,
-	unsigned int width2)
-{
-	struct streaming_to_mipi_instance *s2mi;
-	s2mi = sh_css_hrt_s2m_get_inst(ch_id);
-
-	/* Set global variables that indicate channel_id and format_type */
-	curr_ch_id = (s2mi->ch_id) & _HIVE_ISP_CH_ID_MASK;
-	curr_fmt_type = (s2mi->fmt_type) & _HIVE_ISP_FMT_TYPE_MASK;
-
-	sh_css_hrt_s2m_send_line2(data, width, data2, width2,
-					s2mi->hblank_cycles,
-					s2mi->marker_cycles,
-					s2mi->two_ppc,
-					s2mi->type);
-return;
-}
-
-void sh_css_hrt_streaming_to_mipi_end_frame(
-	unsigned int	ch_id)
-{
-	struct streaming_to_mipi_instance *s2mi;
-	s2mi = sh_css_hrt_s2m_get_inst(ch_id);
-
-	/* Set global variables that indicate channel_id and format_type */
-	curr_ch_id = (s2mi->ch_id) & _HIVE_ISP_CH_ID_MASK;
-	curr_fmt_type = (s2mi->fmt_type) & _HIVE_ISP_FMT_TYPE_MASK;
-
-	/* Call existing HRT function */
-	sh_css_hrt_s2m_end_frame(s2mi->marker_cycles);
-
-	s2mi->streaming = false;
-return;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.h
deleted file mode 100644
index 92d1bfa..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_hrt.h
+++ /dev/null
@@ -1,68 +0,0 @@
-#ifndef _SH_CSS_HRT_H_
-#define _SH_CSS_HRT_H_
-
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include <stdbool.h>
-
-#include <sp.h>
-#include <isp.h>
-
-#include "sh_css.h"	/* enum sh_css_input_format */
-
-/* SP access */
-void sh_css_hrt_sp_start_si(void);
-
-void sh_css_hrt_sp_start_copy_frame(void);
-
-void sh_css_hrt_sp_start_isp(void);
-
-enum sh_css_err sh_css_hrt_sp_wait(void);
-
-bool sh_css_hrt_system_is_idle(void);
-
-void sh_css_hrt_send_input_frame(
-	unsigned short	*data,
-	unsigned int	width,
-	unsigned int	height,
-	unsigned int	ch_id,
-	enum sh_css_input_format	input_format,
-	bool			two_ppc);
-
-void sh_css_hrt_streaming_to_mipi_start_frame(
-	unsigned int	ch_id,
-	enum sh_css_input_format	input_format,
-	bool			two_ppc);
-
-void sh_css_hrt_streaming_to_mipi_send_line(
-	unsigned int	ch_id,
-	unsigned short	*data,
-	unsigned int	width,
-	unsigned short	*data2,
-	unsigned int	width2);
-
-void sh_css_hrt_streaming_to_mipi_end_frame(
-	unsigned int	ch_id);
-
-#endif /* _SH_CSS_HRT_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_internal.h
deleted file mode 100644
index 2236b48..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_internal.h
+++ /dev/null
@@ -1,1079 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_INTERNAL_H_
-#define _SH_CSS_INTERNAL_H_
-
-#include <stdint.h>
-#include "input_formatter.h"
-#include "input_system.h"
-
-#include "sh_css_types.h"
-#include "sh_css_binary.h"
-#include "sh_css_firmware.h"
-/* #include "sh_css_debug.h"*/
-
-#include "dma.h"	/* N_DMA_CHANNEL_ID */
-
-#define sh_css_print(fmt, s...) \
-	do { \
-		if (sh_css_printf) { \
-			sh_css_printf(fmt, ## s); \
-	   } \
-	} while (0)
-
-#define SH_CSS_MAX_BINARY_NAME	32
-
-/* this is an internal timeout value for CSS
-   it should apply to all busy-wait inside CSS system */
-#define CSS_TIMEOUT_US 200000
-
-#define SP_DEBUG_NONE	(0)
-#define SP_DEBUG_DUMP	(1)
-#define SP_DEBUG_COPY	(2)
-#define SP_DEBUG_TRACE	(3)
-#define SP_DEBUG_STALL	(4)
-
-#define SP_DEBUG SP_DEBUG_NONE
-
-#define SH_CSS_MAX_SP_THREADS	4 /* raw_copy, preview, capture, acceleration */
-
-#define NUM_REF_FRAMES		2
-
-/* Determines MAX_CB_ELEMS_FOR_TAGGER in tagger.sp.c */
-/*
-#if defined(HAS_SP_2400A0)
-#define NUM_CONTINUOUS_FRAMES	5
-#else
-#define NUM_CONTINUOUS_FRAMES	10
-#endif
-*/
-
-/* The maximum depth of the frame buffer queue */
-#define NUM_CONTINUOUS_FRAMES	15
-
-#define NUM_OFFLINE_INIT_CONTINUOUS_FRAMES	3
-#define NUM_ONLINE_INIT_CONTINUOUS_FRAMES	2
-
-#define NUM_TNR_FRAMES		2
-
-#define NUM_VIDEO_REF_FRAMES	2
-#define NUM_VIDEO_TNR_FRAMES	2
-#define NR_OF_PIPELINES		5 /* Must match with SH_CSS_NR_OF_PIPELINES */
-
-#define SH_CSS_MAX_STAGES 6 /* copy, preisp, anr, postisp, capture_pp, vf_pp */
-
-/* ISP parameter versions
- * If ISP_PIPE_VERSION is defined as 2 in isp_defs_for_hive.h,
- * SH_CSS_ISP_PARAMS_VERSION should be 2.
- * If ISP_PIPE_VERSION is defined as 1,
- * SH_CSS_ISP_PARAMS_VERSION can be either 1 or 2.
- * ISP_PIPE_VRSION is always defined as 1 for ISP2300,
- * so SH_CSS_ISP_PARAMS_VERSION can be defined as 1 for ISP2300
- * to avoid sched error by increase of the number of paramaters.
-*/
-#if defined(IS_ISP_2400_SYSTEM)
-#define SH_CSS_ISP_PARAMS_VERSION	2
-#else
-#define SH_CSS_ISP_PARAMS_VERSION	1
-#endif
-
-/*
- * JB: keep next enum in sync with thread id's
- * and pipe id's
- */
-enum sh_css_pipe_config_override {
-	SH_CSS_PIPE_CONFIG_OVRD_NONE     = 0,
-	SH_CSS_PIPE_CONFIG_OVRD_THRD_0   = 1,
-	SH_CSS_PIPE_CONFIG_OVRD_THRD_1   = 2,
-	SH_CSS_PIPE_CONFIG_OVRD_THRD_2   = 4,
-	SH_CSS_PIPE_CONFIG_OVRD_THRD_1_2 = 6,
-	SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD  = 0xffff
-};
-
-enum host2sp_commands {
-	host2sp_cmd_error = 0,
-	/*
-	 * The host2sp_cmd_ready command is the only command written by the SP
-	 * It acknowledges that is previous command has been received.
-	 * (this does not mean that the command has been executed)
-	 * It also indicates that a new command can be send (it is a queue
-	 * with depth 1).
-	 */
-	host2sp_cmd_ready = 1,
-	/* Command written by the Host */
-	host2sp_cmd_dummy,		/* No action, can be used as watchdog */
-	host2sp_cmd_terminate,		/* SP should terminate itself */
-	N_host2sp_cmd
-};
-
-/** Enumeration used to indicate the events that are produced by
- *  the SP and consumed by the Host.
- */
-enum sh_css_sp_event_type {
-	SH_CSS_SP_EVENT_NULL,
-	SH_CSS_SP_EVENT_OUTPUT_FRAME_DONE,
-	SH_CSS_SP_EVENT_VF_OUTPUT_FRAME_DONE,
-	SH_CSS_SP_EVENT_3A_STATISTICS_DONE,
-	SH_CSS_SP_EVENT_DIS_STATISTICS_DONE,
-	SH_CSS_SP_EVENT_PIPELINE_DONE,
-	SH_CSS_SP_EVENT_NR_OF_TYPES,		/* must be last */
-};
-
-/* Data structures shared with ISP */
-struct sh_css_isp_params {
-	/* FPNR (Fixed Pattern Noise Reduction) */
-	int fpn_shift;
-	int fpn_enabled;
-
-	/* OB (Optical Black) */
-	int ob_blacklevel_gr;
-	int ob_blacklevel_r;
-	int ob_blacklevel_b;
-	int ob_blacklevel_gb;
-	int obarea_start_bq;
-	int obarea_length_bq;
-	int obarea_length_bq_inverse;
-
-	/* SC (Shading Corrction) */
-	int sc_gain_shift;
-
-	/* WB (White Balance) */
-	int wb_gain_shift;
-	int wb_gain_gr;
-	int wb_gain_r;
-	int wb_gain_b;
-	int wb_gain_gb;
-
-	/* DP (Defect Pixel Correction) */
-	int dp_threshold_single_when_2adjacent_on;
-	int dp_threshold_2adjacent_when_2adjacent_on;
-	int dp_threshold_single_when_2adjacent_off;
-	int dp_threshold_2adjacent_when_2adjacent_off;
-	int dp_gain;
-
-	/* BNR (Bayer Noise Reduction) */
-	int bnr_gain_all;
-	int bnr_gain_dir;
-	int bnr_threshold_low;
-	int bnr_threshold_width_log2;
-	int bnr_threshold_width;
-	int bnr_clip;
-
-	/* S3A (3A Support): coefficients to calculate Y */
-	int ae_y_coef_r;
-	int ae_y_coef_g;
-	int ae_y_coef_b;
-
-	/* S3A (3A Support): AWB level gate */
-	int awb_lg_high_raw;
-	int awb_lg_low;
-	int awb_lg_high;
-
-	/* S3A (3A Support): af fir coefficients */
-	int af_fir1[7];
-	int af_fir2[7];
-
-	/* DE (Demosaic) */
-	int de_pixelnoise;
-	int de_c1_coring_threshold;
-	int de_c2_coring_threshold;
-
-	/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
-	int ynr_threshold;
-	int ynr_gain_all;
-	int ynr_gain_dir;
-	int ynryee_dirthreshold_s;
-	int ynryee_dirthreshold_g;
-	int ynryee_dirthreshold_width_log2;
-	int ynryee_dirthreshold_width;
-	int yee_detailgain;
-	int yee_coring_s;
-	int yee_coring_g;
-	int yee_scale_plus_s;
-	int yee_scale_plus_g;
-	int yee_scale_minus_s;
-	int yee_scale_minus_g;
-	int yee_clip_plus_s;
-	int yee_clip_plus_g;
-	int yee_clip_minus_s;
-	int yee_clip_minus_g;
-	int ynryee_Yclip;
-
-	/* CSC (Color Space Conversion) */
-	/* YC1C2->YCbCr */
-	int csc_coef_shift;
-	int yc1c2_to_ycbcr_00;
-	int yc1c2_to_ycbcr_01;
-	int yc1c2_to_ycbcr_02;
-	int yc1c2_to_ycbcr_10;
-	int yc1c2_to_ycbcr_11;
-	int yc1c2_to_ycbcr_12;
-	int yc1c2_to_ycbcr_20;
-	int yc1c2_to_ycbcr_21;
-	int yc1c2_to_ycbcr_22;
-
-	/* GC (Gamma Correction) */
-	int gamma_gain_k1;
-	int gamma_gain_k2;
-
-	/* TNR (Temporal Noise Reduction) */
-	int tnr_coef;
-	int tnr_threshold_Y;
-	int tnr_threshold_C;
-
-	/* ANR (Advance Noise Reduction) */
-	int anr_threshold;
-
-	/* CE (Chroma Enhancement) */
-	int ce_uv_level_min;
-	int ce_uv_level_max;
-
-	struct sh_css_crop_pos sp_out_crop_pos[SH_CSS_MAX_STAGES];
-	struct sh_css_uds_info uds[SH_CSS_MAX_STAGES];
-
-/* parameters for ISP pipe version 2 */
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	/* DE (Demosaic) */
-	int ecd_zip_strength;
-	int ecd_fc_strength;
-	int ecd_fc_debias;
-
-	/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
-	int yee_edge_sense_gain_0;
-	int yee_edge_sense_gain_1;
-	int yee_corner_sense_gain_0;
-	int yee_corner_sense_gain_1;
-
-	/* Fringe Control */
-	int fc_gain_exp;
-	int fc_gain_pos_0;
-	int fc_gain_pos_1;
-	int fc_gain_neg_0;
-	int fc_gain_neg_1;
-	int fc_crop_pos_0;
-	int fc_crop_pos_1;
-	int fc_crop_neg_0;
-	int fc_crop_neg_1;
-
-	/* CNR */
-	int cnr_coring_u;
-	int cnr_coring_v;
-	int cnr_sense_gain_vy;
-	int cnr_sense_gain_vu;
-	int cnr_sense_gain_vv;
-	int cnr_sense_gain_hy;
-	int cnr_sense_gain_hu;
-	int cnr_sense_gain_hv;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	/* MACC */
-	int exp;
-
-/* parameters for ISP pipe version 2 */
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	/* CTC */
-	int ctc_y0;
-	int ctc_y1;
-	int ctc_y2;
-	int ctc_y3;
-	int ctc_y4;
-	int ctc_y5;
-	int ctc_ce_gain_exp;
-	int ctc_x1;
-	int ctc_x2;
-	int ctc_x3;
-	int ctc_x4;
-	int ctc_dydx0;
-	int ctc_dydx0_shift;
-	int ctc_dydx1;
-	int ctc_dydx1_shift;
-	int ctc_dydx2;
-	int ctc_dydx2_shift;
-	int ctc_dydx3;
-	int ctc_dydx3_shift;
-	int ctc_dydx4;
-	int ctc_dydx4_shift;
-
-	/* Anti-Aliasing */
-        int aa_scale;
-
-	/* CCM before sRGB Gamma: YCgCo->RGB */
-	int ycgco_to_rgb_00;
-	int ycgco_to_rgb_01;
-	int ycgco_to_rgb_02;
-	int ycgco_to_rgb_10;
-	int ycgco_to_rgb_11;
-	int ycgco_to_rgb_12;
-	int ycgco_to_rgb_20;
-	int ycgco_to_rgb_21;
-	int ycgco_to_rgb_22;
-
-	/* CSC after sRGB Gamma: RGB->YUV */
-	int rgb_to_yuv_00;
-	int rgb_to_yuv_01;
-	int rgb_to_yuv_02;
-	int rgb_to_yuv_10;
-	int rgb_to_yuv_11;
-	int rgb_to_yuv_12;
-	int rgb_to_yuv_20;
-	int rgb_to_yuv_21;
-	int rgb_to_yuv_22;
-#else
-	int aa_scale;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	/* XNR threshold */
-	int xnr_threshold;
-};
-
-/* xmem address map allocation */
-struct sh_css_ddr_address_map {
-	hrt_vaddress isp_param;
-	hrt_vaddress ctc_tbl;
-	hrt_vaddress xnr_tbl;
-	hrt_vaddress gamma_tbl;
-	hrt_vaddress macc_tbl;
-	hrt_vaddress fpn_tbl;
-	hrt_vaddress sc_tbl;
-	hrt_vaddress sdis_hor_coef;
-	hrt_vaddress sdis_ver_coef;
-	hrt_vaddress tetra_r_x;
-	hrt_vaddress tetra_r_y;
-	hrt_vaddress tetra_gr_x;
-	hrt_vaddress tetra_gr_y;
-	hrt_vaddress tetra_gb_x;
-	hrt_vaddress tetra_gb_y;
-	hrt_vaddress tetra_b_x;
-	hrt_vaddress tetra_b_y;
-	hrt_vaddress tetra_ratb_x;
-	hrt_vaddress tetra_ratb_y;
-	hrt_vaddress tetra_batr_x;
-	hrt_vaddress tetra_batr_y;
-	hrt_vaddress dvs_6axis_params_y;
-	hrt_vaddress r_gamma_tbl;
-	hrt_vaddress g_gamma_tbl;
-	hrt_vaddress b_gamma_tbl;
-};
-
-/* xmem address map allocation */
-struct sh_css_ddr_address_map_size {
-	size_t isp_param;
-	size_t ctc_tbl;
-	size_t gamma_tbl;
-	size_t xnr_tbl;
-	size_t macc_tbl;
-	size_t fpn_tbl;
-	size_t sc_tbl;
-	size_t sdis_hor_coef;
-	size_t sdis_ver_coef;
-	size_t tetra_r_x;
-	size_t tetra_r_y;
-	size_t tetra_gr_x;
-	size_t tetra_gr_y;
-	size_t tetra_gb_x;
-	size_t tetra_gb_y;
-	size_t tetra_b_x;
-	size_t tetra_b_y;
-	size_t tetra_ratb_x;
-	size_t tetra_ratb_y;
-	size_t tetra_batr_x;
-	size_t tetra_batr_y;
-	size_t dvs_6axis_params_y;
-	size_t r_gamma_tbl;
-	size_t g_gamma_tbl;
-	size_t b_gamma_tbl;
-};
-
-struct sh_css_ddr_address_map_compound {
-	struct sh_css_ddr_address_map		map;
-	struct sh_css_ddr_address_map_size	size;
-};
-
-struct sh_css_envelope {
-	unsigned int width;
-	unsigned int height;
-};
-
-/* this struct contains all arguments that can be passed to
-   a binary. It depends on the binary which ones are used. */
-struct sh_css_binary_args {
-	struct sh_css_frame *cc_frame;       /* continuous capture frame */
-	struct sh_css_frame *in_frame;	     /* input frame */
-	struct sh_css_frame *in_ref_frame;   /* reference input frame */
-	struct sh_css_frame *in_tnr_frame;   /* tnr input frame */
-	struct sh_css_frame *out_frame;      /* output frame */
-	struct sh_css_frame *out_ref_frame;  /* reference output frame */
-	struct sh_css_frame *out_tnr_frame;  /* tnr output frame */
-	struct sh_css_frame *extra_frame;    /* intermediate frame */
-	struct sh_css_frame *out_vf_frame;   /* viewfinder output frame */
-	bool                 copy_vf;
-	bool                 copy_output;
-	unsigned             vf_downscale_log2;
-};
-
-/* Pipeline stage to be executed on SP/ISP */
-struct sh_css_pipeline_stage {
-	unsigned int		     stage_num;
-	struct sh_css_binary        *binary;      /* built-in binary */
-	struct sh_css_binary_info   *binary_info;
-	const struct sh_css_fw_info *firmware; /* acceleration binary */
-	struct sh_css_binary_args    args;
-	int                          mode;
-	bool                         out_frame_allocated;
-	bool                         vf_frame_allocated;
-	/* Indicate which buffers require an IRQ */
-	unsigned int		     irq_buf_flags;
-	struct sh_css_pipeline_stage *next;
-};
-
-/* Pipeline of n stages to be executed on SP/ISP per stage */
-struct sh_css_pipeline {
-	enum sh_css_pipe_id pipe_id;
-	struct sh_css_pipeline_stage *stages;
-	bool reload;
-	struct sh_css_pipeline_stage *current_stage;
-	unsigned num_stages;
-	struct sh_css_frame in_frame;
-	struct sh_css_frame out_frame;
-	struct sh_css_frame vf_frame;
-};
-
-
-#if (SP_DEBUG == SP_DEBUG_DUMP) || (SP_DEBUG == SP_DEBUG_STALL)
-
-#define SH_CSS_NUM_SP_DEBUG 48
-
-struct sh_css_sp_debug_state {
-	unsigned int error;
-	unsigned int debug[SH_CSS_NUM_SP_DEBUG];
-};
-
-#elif SP_DEBUG == SP_DEBUG_COPY
-
-#define SH_CSS_SP_DBG_TRACE_DEPTH	(40)
-
-struct sh_css_sp_debug_trace {
-	uint16_t frame;
-	uint16_t line;
-	uint16_t pixel_distance;
-	uint16_t mipi_used_dword;
-	uint16_t sp_index;
-};
-
-struct sh_css_sp_debug_state {
-	uint16_t if_start_line;
-	uint16_t if_start_column;
-	uint16_t if_cropped_height;
-	uint16_t if_cropped_width;
-	unsigned int index;
-	struct sh_css_sp_debug_trace
-		trace[SH_CSS_SP_DBG_TRACE_DEPTH];
-};
-
-#elif SP_DEBUG == SP_DEBUG_TRACE
-
-#define SH_CSS_SP_DBG_NR_OF_TRACES	(1)
-#define SH_CSS_SP_DBG_TRACE_DEPTH	(40)
-
-#define SH_CSS_SP_DBG_TRACE_FILE_ID_BIT_POS (13)
-
-/* trace id 0..3 are used by the SP threads */
-#define SH_CSS_SP_DBG_TRACE_ID_CONTROL (3) /* Re-use accl thread */
-#define SH_CSS_SP_DBG_TRACE_ID_TBD  (5)
-
-struct sh_css_sp_debug_trace {
-	uint16_t time_stamp;
-	uint16_t location;	/* bit 15..13 = file_id, 12..0 = line */
-	uint32_t data;
-};
-
-struct sh_css_sp_debug_state {
-	struct sh_css_sp_debug_trace
-		trace[SH_CSS_SP_DBG_NR_OF_TRACES][SH_CSS_SP_DBG_TRACE_DEPTH];
-	uint16_t index_last[SH_CSS_SP_DBG_NR_OF_TRACES];
-	uint8_t index[SH_CSS_SP_DBG_NR_OF_TRACES];
-};
-
-#endif
-
-
-struct sh_css_sp_debug_command {
-	/*
-	 * The DMA software-mask,
-	 *	Bit 31...24: unused.
-	 *	Bit 23...16: unused.
-	 *	Bit 15...08: reading-request enabling bits for DMA channel 7..0
-	 *	Bit 07...00: writing-reqeust enabling bits for DMA channel 7..0
-	 *
-	 * For example, "0...0 0...0 11111011 11111101" indicates that the
-	 * writing request through DMA Channel 1 and the reading request
-	 * through DMA channel 2 are both disabled. The others are enabled.
-	 */
-	uint32_t dma_sw_reg;
-};
-
-/* SP configuration information */
-struct sh_css_sp_config {
-	uint8_t			is_offline;  /* Run offline, with continuous copy */
-	uint8_t			input_needs_raw_binning;
-	uint8_t			no_isp_sync; /* Signal host immediately after start */
-	struct {
-		uint8_t					a_changed;
-		uint8_t					b_changed;
-		uint8_t					isp_2ppc;
-		uint32_t				stream_format;
-		input_formatter_cfg_t	config_a;
-		input_formatter_cfg_t	config_b;
-	} input_formatter;
-	sync_generator_cfg_t	sync_gen;
-	tpg_cfg_t				tpg;
-	prbs_cfg_t				prbs;
-	input_system_cfg_t		input_circuit;
-	uint8_t					input_circuit_cfg_changed;
-};
-
-enum sh_css_stage_type {
-  SH_CSS_SP_STAGE_TYPE  = 0,
-  SH_CSS_ISP_STAGE_TYPE = 1
-};
-#define SH_CSS_NUM_STAGE_TYPES 2
-
-enum sh_css_sp_stage_func {
-  SH_CSS_SP_RAW_COPY = 0,
-  SH_CSS_SP_BIN_COPY = 1
-};
-#define SH_CSS_NUM_STAGE_FUNCS 2
-
-#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS 	(1 << 0)
-#define SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS_MASK \
-	((SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << SH_CSS_MAX_SP_THREADS)-1)
-
-/* Information for a pipeline */
-struct sh_css_sp_pipeline {
-	uint32_t	pipe_id;	/* the pipe ID */
-	uint32_t	thread_id;	/* the sp thread ID */
-	uint32_t	pipe_config;	/* the pipe config */
-	uint32_t	num_stages;
-	uint32_t	running;
-	hrt_vaddress	sp_stage_addr[SH_CSS_MAX_STAGES];
-	struct sh_css_sp_stage *stage; /* Current stage for this pipeline */
-	union {
-		struct {
-			unsigned int	bytes_available;
-		} bin;
-		struct {
-			unsigned int	height;
-			unsigned int	width;
-			unsigned int	padded_width;
-			unsigned int	max_input_width;
-			unsigned int	raw_bit_depth;
-		} raw;
-	} copy;
-};
-
-/*
- * These structs are derived from structs defined in sh_css_types.h
- * (just take out the "_sp" from the struct name to get the "original")
- * All the fields that are not needed by the SP are removed.
- */
-struct sh_css_sp_frame_plane {
-	unsigned int offset;	/* offset in bytes to start of frame data */
-				/* offset is wrt data in sh_css_sp_sp_frame */
-};
-
-struct sh_css_sp_frame_binary_plane {
-	unsigned int size;
-	struct sh_css_sp_frame_plane data;
-};
-
-struct sh_css_sp_frame_yuv_planes {
-	struct sh_css_sp_frame_plane y;
-	struct sh_css_sp_frame_plane u;
-	struct sh_css_sp_frame_plane v;
-};
-
-struct sh_css_sp_frame_nv_planes {
-	struct sh_css_sp_frame_plane y;
-	struct sh_css_sp_frame_plane uv;
-};
-
-struct sh_css_sp_frame_rgb_planes {
-	struct sh_css_sp_frame_plane r;
-	struct sh_css_sp_frame_plane g;
-	struct sh_css_sp_frame_plane b;
-};
-
-struct sh_css_sp_frame_plane6_planes {
-	struct sh_css_sp_frame_plane r;
-	struct sh_css_sp_frame_plane r_at_b;
-	struct sh_css_sp_frame_plane gr;
-	struct sh_css_sp_frame_plane gb;
-	struct sh_css_sp_frame_plane b;
-	struct sh_css_sp_frame_plane b_at_r;
-};
-
-enum sh_css_frame_id {
-	sh_css_frame_in,		/* Dynamic */
-	sh_css_frame_out,		/* Dynamic */
-	sh_css_frame_out_vf,		/* Dynamic */
-	sh_css_frame_s3a,		/* Dynamic */
-	sh_css_frame_dis,		/* Dynamic */
-	sh_css_frame_ref_in,
-	sh_css_frame_ref_out,
-	sh_css_frame_tnr_in,
-	sh_css_frame_tnr_out,
-	sh_css_frame_extra,
-	sh_css_frame_raw_out,
-	sh_css_frame_cust_in,
-	sh_css_frame_cust_out,
-};
-/*
- * The first frames (with comment Dynamic) can be dynamic or static
- * The other frames (ref_in and below) can only be static
- * Static means that the data addres will not change during the life time
- * of the associated pipe. Dynamic means that the data address can
- * change with every (frame) iteration of the associated pipe
- *
- * s3a and dis are now also dynamic but (stil) handled seperately
- */
-#define SH_CSS_NUM_FRAME_IDS (13)
-#define SH_CSS_NUM_DYNAMIC_BUFFER_IDS (5)
-#define SH_CSS_NUM_DYNAMIC_FRAME_IDS (3)
-#define SH_CSS_INVALID_FRAME_ID (-1)
-
-
-/** Frame info struct. This describes the contents of an image frame buffer.
-  */
-struct sh_css_sp_frame_info {
-	uint16_t width;  /**< width of valid data in pixels */
-	uint16_t height; /**< Height of valid data in lines */
-	uint16_t padded_width; /**< stride of line in memory (in pixels) */
-	unsigned char format; /**< format of the frame data */
-	unsigned char raw_bit_depth; /**< number of valid bits per pixel,
-					 only valid for RAW bayer frames */
-	unsigned char raw_bayer_order; /**< bayer order, only valid
-						      for RAW bayer frames */
-	unsigned char padding;
-};
-
-
-struct sh_css_sp_frame {
-	struct sh_css_sp_frame_info info;
-	union {
-		struct sh_css_sp_frame_plane raw;
-		struct sh_css_sp_frame_plane rgb;
-		struct sh_css_sp_frame_rgb_planes planar_rgb;
-		struct sh_css_sp_frame_plane yuyv;
-		struct sh_css_sp_frame_yuv_planes yuv;
-		struct sh_css_sp_frame_nv_planes nv;
-		struct sh_css_sp_frame_plane6_planes plane6;
-		struct sh_css_sp_frame_binary_plane binary;
-	} planes;
-};
-
-struct sh_css_sp_frames {
-	struct sh_css_sp_frame	in;
-	struct sh_css_sp_frame	out;
-	struct sh_css_sp_frame	out_vf;
-	struct sh_css_sp_frame	ref_in;
-	/* ref_out_frame is same as ref_in_frame */
-	struct sh_css_sp_frame	tnr_in;
-	/* trn_out_frame is same as tnr_in_frame */
-	struct sh_css_sp_frame	extra;
-	struct sh_css_sp_frame_info internal_frame_info;
-	hrt_vaddress static_frame_data[SH_CSS_NUM_FRAME_IDS];
-};
-
-/* Information for a single pipeline stage for an ISP */
-struct sh_css_isp_stage {
-	/*
-	 * For compatability and portabilty, only types
-	 * from "stdint.h" are allowed
-	 *
-	 * Use of "enum" and "bool" is prohibited
-	 * Multiple boolean flags can be stored in an
-	 * integer
-	 */
-	struct sh_css_blob_info		blob_info;
-	struct sh_css_binary_info	binary_info;
-	char				binary_name[SH_CSS_MAX_BINARY_NAME];
-	struct sh_css_hmm_isp_interface mem_interface
-						[SH_CSS_NUM_ISP_MEMORIES];
-};
-
-/* Information for a single pipeline stage */
-struct sh_css_sp_stage {
-	/*
-	 * For compatability and portabilty, only types
-	 * from "stdint.h" are allowed
-	 *
-	 * Use of "enum" and "bool" is prohibited
-	 * Multiple boolean flags can be stored in an
-	 * integer
-	 */
-	uint8_t			num; /* Stage number */
-	uint8_t			isp_online;
-	uint8_t			isp_copy_vf;
-	uint8_t			isp_copy_output;
-	uint8_t			sp_enable_xnr;
-	uint8_t			isp_deci_log_factor;
-	uint8_t			isp_vf_downscale_bits;
-	uint8_t			anr;
-	uint8_t			deinterleaved;
-/*
- * NOTE: Programming the input circuit can only be done at the
- * start of a session. It is illegal to program it during execution
- * The input circuit defines the connectivity
- */
-	uint8_t			program_input_circuit;
-/* enum sh_css_sp_stage_func	func; */
-	uint8_t			func;
-	/* The type of the pipe-stage */
-	/* enum sh_css_stage_type	stage_type; */
-	uint8_t			stage_type;
-	uint8_t			num_stripes;
-	struct {
-		uint8_t		vf_veceven;
-		uint8_t		s3a;
-		uint8_t		sdis;
-	} enable;
-	/* Add padding to come to a word boundary */
-	/* unsigned char			padding[0]; */
-
-	struct sh_css_crop_pos		sp_out_crop_pos;
-	/* Indicate which buffers require an IRQ */
-	uint32_t					irq_buf_flags;
-	struct sh_css_sp_frames		frames;
-	struct sh_css_dvs_envelope	dvs_envelope;
-	struct sh_css_uds_info		uds;
-	hrt_vaddress			isp_stage_addr;
-	hrt_vaddress			xmem_bin_addr;
-	hrt_vaddress			xmem_map_addr;
-};
-
-/*
- * Time: 2012-07-19, 17:40.
- * Author: zhengjie.lu@intel.com
- * Note: Add a new data memeber "debug" in "sh_css_sp_group". This
- * data member is used to pass the debugging command from the
- * Host to the SP.
- *
- * Time: Before 2012-07-19.
- * Author: unknown
- * Note:
- * Group all host initialized SP variables into this struct.
- * This is initialized every stage through dma.
- * The stage part itself is transfered through sh_css_sp_stage.
-*/
-struct sh_css_sp_group {
-	struct sh_css_sp_config		config;
-	struct sh_css_sp_pipeline	pipe[SH_CSS_MAX_SP_THREADS];
-
-	struct sh_css_sp_debug_command	debug;
-};
-
-/* Data in SP dmem that is set from the host every stage. */
-struct sh_css_sp_per_frame_data {
-	/* ddr address of sp_group and sp_stage */
-	hrt_vaddress			sp_group_addr;
-};
-
-#define SH_CSS_NUM_SDW_IRQS 3
-
-/* Output data from SP to css */
-struct sh_css_sp_output {
-	unsigned int			bin_copy_bytes_copied;
-#if SP_DEBUG != SP_DEBUG_NONE
-	struct sh_css_sp_debug_state	debug;
-#endif
-	unsigned int		sw_interrupt_value[SH_CSS_NUM_SDW_IRQS];
-};
-
-/**
- * @brief Data structure for the circular buffer.
- * The circular buffer is empty if "start == end". The
- * circular buffer is full if "(end + 1) % size == start".
- */
-#define  SH_CSS_CIRCULAR_BUF_NUM_ELEMS	6
-struct sh_css_circular_buf {
-	/*
-	 * WARNING: Do NOT change the memeber orders below,
-	 * unless you are the expert of either the CSS API
-	 * or the SP code.
-	 */
-
-	uint8_t size;  /* maximum number of elements */
-	uint8_t step;  /* number of bytes per element */
-	uint8_t start; /* index of the oldest element */
-	uint8_t end;   /* index at which to write the new element */
-
-	uint32_t elems[SH_CSS_CIRCULAR_BUF_NUM_ELEMS]; /* array of elements */
-};
-
-struct sh_css_hmm_buffer {
-	hrt_vaddress kernel_ptr;
-	union {
-		union sh_css_s3a_data s3a;
-		struct sh_css_dis_data dis;
-//		hrt_vaddress frame_data;
-		struct {
-			hrt_vaddress	frame_data;
-			unsigned int	flashed;
-			unsigned int	exp_id;
-		} frame;
-		hrt_vaddress ddr_ptrs;
-	} payload;
-};
-
-enum sh_css_buffer_queue_id {
-	sh_css_invalid_buffer_queue = -1,
-	sh_css_input_buffer_queue,
-	sh_css_output_buffer_queue,
-	sh_css_vf_output_buffer_queue,
-	sh_css_s3a_buffer_queue,
-	sh_css_dis_buffer_queue,
-	sh_css_param_buffer_queue,
-	sh_css_tag_cmd_queue
-};
-
-struct sh_css_event_irq_mask {
-	uint16_t or_mask;
-	uint16_t and_mask;
-};
-
-#define SH_CSS_NUM_BUFFER_QUEUES 7
-
-struct host_sp_communication {
-	/*
-	 * Don't use enum host2sp_commands, because the sizeof an enum is
-	 * compiler dependant and thus non-portable
-	 */
-	unsigned int host2sp_command;
-
-	/*
-	 * The frame buffers that are reused by the
-	 * copy pipe in the offline preview mode.
-	 *
-	 * host2sp_offline_frames[0]: the input frame of the preview pipe.
-	 * host2sp_offline_frames[1]: the output frame of the copy pipe.
-	 *
-	 * TODO:
-	 *   Remove it when the Host and the SP is decoupled.
-	 */
-	hrt_vaddress host2sp_offline_frames[NUM_CONTINUOUS_FRAMES];
-	unsigned int host2sp_cont_avail_num_raw_frames;
-	unsigned int host2sp_cont_extra_num_raw_frames;
-	unsigned int host2sp_cont_target_num_raw_frames;
-	struct sh_css_event_irq_mask host2sp_event_irq_mask[NR_OF_PIPELINES];
-
-};
-
-struct host_sp_queues {
-	/*
-	 * Queues for the dynamic frame information,
-	 * i.e. the "in_frame" buffer, the "out_frame"
-	 * buffer and the "vf_out_frame" buffer.
-	 */
-	struct sh_css_circular_buf host2sp_buffer_queues
-		[SH_CSS_MAX_SP_THREADS][SH_CSS_NUM_BUFFER_QUEUES];
-	struct sh_css_circular_buf sp2host_buffer_queues
-		[SH_CSS_NUM_BUFFER_QUEUES];
-
-	/*
-	 * The queue for the events.
-	 */
-	struct sh_css_circular_buf host2sp_event_queue;
-	struct sh_css_circular_buf sp2host_event_queue;
-};
-
-extern int (*sh_css_printf) (const char *fmt, ...);
-
-hrt_vaddress
-sh_css_params_ddr_address_map(void);
-
-void
-sh_css_update_isp_params_to_ddr(hrt_vaddress ddr_ptr);
-
-enum sh_css_err
-sh_css_params_write_to_ddr(const struct sh_css_binary *binary_info);
-
-void
-sh_css_params_set_current_binary(const struct sh_css_binary *binary);
-
-/* swap 3a double buffers. This should be called when handling an
-   interrupt that indicates that statistics are ready.
-   This also swaps the DIS buffers. */
-#if 0
-void
-sh_css_params_swap_3a_buffers(void);
-
-enum sh_css_err
-sh_css_params_get_free_stat_bufs(const struct sh_css_binary *binary,
-					union sh_css_s3a_data *s3a_data,
-					struct sh_css_dis_data *sdis_data);
-
-enum sh_css_err
-sh_css_params_get_free_stat_bufs2(union sh_css_s3a_data *s3a_data,
-					struct sh_css_dis_data *sdis_data);
-#endif
-
-enum sh_css_err
-sh_css_params_init(void);
-
-void
-sh_css_params_uninit(void);
-
-void
-sh_css_params_reconfigure_gdc_lut(void);
-
-void *
-sh_css_malloc(size_t size);
-
-void
-sh_css_free(void *ptr);
-
-/* For Acceleration API: Flush FW (shared buffer pointer) arguments */
-extern void
-sh_css_flush(struct sh_css_acc_fw *fw);
-
-/* Check two frames for equality (format, resolution, bits per element) */
-bool
-sh_css_frame_equal_types(const struct sh_css_frame *frame_a,
-			 const struct sh_css_frame *frame_b);
-
-bool
-sh_css_frame_info_equal_resolution(const struct sh_css_frame_info *info_a,
-				   const struct sh_css_frame_info *info_b);
-
-unsigned int
-sh_css_input_format_bits_per_pixel(enum sh_css_input_format format,
-				   bool two_ppc);
-
-enum sh_css_err
-sh_css_vf_downscale_log2(const struct sh_css_frame_info *out_info,
-			 const struct sh_css_frame_info *vf_info,
-			 unsigned int *downscale_log2);
-
-void
-sh_css_capture_enable_bayer_downscaling(bool enable);
-
-void
-sh_css_binary_print(const struct sh_css_binary *binary);
-
-#if SP_DEBUG !=SP_DEBUG_NONE
-
-void
-sh_css_print_sp_debug_state(const struct sh_css_sp_debug_state *state);
-
-#endif
-
-void
-sh_css_frame_info_set_width(struct sh_css_frame_info *info,
-			    unsigned int width, unsigned int min_padded_width);
-
-/* Return whether the sp copy process should be started */
-bool
-sh_css_continuous_start_sp_copy(void);
-
-bool
-sh_css_pipe_uses_params(struct sh_css_pipeline *me);
-
-/* The following functions are used for testing purposes only */
-const struct sh_css_fpn_table *
-sh_css_get_fpn_table(void);
-
-struct sh_css_shading_table *
-sh_css_get_shading_table(void);
-
-const struct sh_css_isp_params *
-sh_css_get_isp_params(void);
-
-void
-sh_css_invalidate_morph_table(void);
-
-const struct sh_css_binary *
-sh_css_get_3a_binary(void);
-
-void
-sh_css_get_isp_dis_coefficients(short *horizontal_coefficients,
-				short *vertical_coefficients);
-
-void
-sh_css_get_isp_dis_projections(int *horizontal_projections,
-			       int *vertical_projections);
-
-hrt_vaddress
-sh_css_store_sp_group_to_ddr(void);
-
-hrt_vaddress
-sh_css_store_sp_stage_to_ddr(unsigned pipe, unsigned stage);
-
-hrt_vaddress
-sh_css_store_isp_stage_to_ddr(unsigned pipe, unsigned stage);
-
-void
-sh_css_frame_info_init(struct sh_css_frame_info *info,
-		       unsigned int width,
-		       unsigned int height,
-		       unsigned int min_padded_width,
-		       enum sh_css_frame_format format);
-
-bool
-sh_css_enqueue_frame(unsigned int pipe_num,
-		     enum sh_css_frame_id frame_id,
-		     struct sh_css_frame *frame);
-
-/**
- * @brief Query the SP thread ID.
- *
- * @param[in]	key	The query key.
- * @param[out]	val	The query value.
- *
- * @return
- *	true, if the query succeeds;
- *	false, if the query fails.
- */
-bool
-sh_css_query_sp_thread_id(enum sh_css_pipe_id key,
-		unsigned int *val);
-
-/**
- * @brief Query the internal frame ID.
- *
- * @param[in]	key	The query key.
- * @param[out]	val	The query value.
- *
- * @return
- *	true, if the query succeeds;
- *	false, if the query fails.
- */
-bool
-sh_css_query_internal_queue_id(enum sh_css_buffer_type key,
-		enum sh_css_buffer_queue_id *val);
-
-
-bool
-input_format_is_yuv_8(enum sh_css_input_format format);
-
-#endif /* _SH_CSS_INTERNAL_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.c
deleted file mode 100644
index 66505e0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.c
+++ /dev/null
@@ -1,180 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#include "sh_css_metrics.h"
-
-#include "sp.h"
-#include "isp.h"
-
-#include "sh_css_internal.h"
-
-#define MULTIPLE_PCS 0
-#define SUSPEND      0
-#define NOF_PCS      1
-#define RESUME_MASK  0x8
-#define STOP_MASK    0x0
-
-static bool pc_histogram_enabled;
-static struct sh_css_pc_histogram *isp_histogram;
-static struct sh_css_pc_histogram *sp_histogram;
-
-struct sh_css_metrics sh_css_metrics;
-
-void
-sh_css_metrics_start_frame(void)
-{
-	sh_css_metrics.frame_metrics.num_frames++;
-}
-
-static void
-clear_histogram(struct sh_css_pc_histogram *histogram)
-{
-	unsigned i;
-	for (i = 0; i < histogram->length; i++) {
-		histogram->run[i] = 0;
-		histogram->stall[i] = 0;
-		histogram->msink[i] = 0xFFFF;
-	}
-}
-
-void
-sh_css_metrics_enable_pc_histogram(bool enable)
-{
-	pc_histogram_enabled = enable;
-}
-
-static void
-make_histogram(struct sh_css_pc_histogram *histogram, unsigned length)
-{
-	if (histogram->length)
-		return;
-	if (histogram->run)
-		return;
-	histogram->run = sh_css_malloc(length * sizeof(*histogram->run));
-	if (!histogram->run)
-		return;
-	histogram->stall = sh_css_malloc(length * sizeof(*histogram->stall));
-	if (!histogram->stall)
-		return;
-	histogram->msink = sh_css_malloc(length * sizeof(*histogram->msink));
-	if (!histogram->msink)
-		return;
-
-	histogram->length = length;
-	clear_histogram(histogram);
-}
-
-static void
-insert_binary_metrics(struct sh_css_binary_metrics **l,
-			struct sh_css_binary_metrics *metrics)
-{
-	for (; *l; l = &(*l)->next)
-		if (*l == metrics)
-			return;
-
-	*l = metrics;
-	metrics->next = NULL;
-}
-
-void
-sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics)
-{
-	if (!pc_histogram_enabled)
-		return;
-
-	isp_histogram = &metrics->isp_histogram;
-	sp_histogram = &metrics->sp_histogram;
-	make_histogram(isp_histogram, ISP_PMEM_DEPTH);
-	make_histogram(sp_histogram, SP_PMEM_DEPTH);
-	insert_binary_metrics(&sh_css_metrics.binary_metrics, metrics);
-}
-
-void
-sh_css_metrics_sample_pcs(void)
-{
-	bool stall;
-	unsigned int pc;
-	unsigned int msink;
-
-#if SUSPEND
-	unsigned int sc = 0;
-	unsigned int stopped_sc = 0;
-	unsigned int resume_sc = 0;
-#endif
-
-
-#if MULTIPLE_PCS
-	int i;
-	unsigned int pc_tab[NOF_PCS] ;
-
-	for (i = 0; i < NOF_PCS; i++)
-		pc_tab[i] = 0;
-#endif
-
-	if (!pc_histogram_enabled)
-		return;
-
-	if (isp_histogram) {
-#if SUSPEND
-		/* STOP the ISP */
-		isp_ctrl_store(ISP0_ID, ISP_SC_REG, STOP_MASK);
-#endif
-		msink = isp_ctrl_load(ISP0_ID, ISP_CTRL_SINK_REG);
-#if MULTIPLE_PCS
-		for (i = 0; i < NOF_PCS; i++)
-			pc_tab[i] = isp_ctrl_load(ISP0_ID, ISP_PC_REG);
-#else
-		pc = isp_ctrl_load(ISP0_ID, ISP_PC_REG);
-#endif
-
-#if SUSPEND
-		/* RESUME the ISP */
-		isp_ctrl_store(ISP0_ID, ISP_SC_REG, RESUME_MASK);
-#endif
-		isp_histogram->msink[pc] &= msink;
-		stall = (msink != 0x7FF);
-
-		if (stall)
-			isp_histogram->stall[pc]++;
-		else
-			isp_histogram->run[pc]++;
-
-#if MULTIPLE_PCS
-		printk(KERN_INFO "msink = 0%X\n", msink);
-		for (i = 0; i < NOF_PCS; i++)
-			printk(KERN_INFO "PC = %d  ", pc_tab[i]);
-		printk(KERN_INFO "\n");
-#endif
-	}
-
-	if (sp_histogram && 0) {
-		msink = sp_ctrl_load(SP0_ID, SP_CTRL_SINK_REG);
-		pc = sp_ctrl_load(SP0_ID, SP_PC_REG);
-		sp_histogram->msink[pc] &= msink;
-		stall = (msink != 0x7FF);
-		if (stall)
-			sp_histogram->stall[pc]++;
-		else
-			sp_histogram->run[pc]++;
-	}
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.h
deleted file mode 100644
index 0d37e9a..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_metrics.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Support for Medfield PNW Camera Imaging ISP subsystem.
- *
- * Copyright (c) 2010 Intel Corporation. All Rights Reserved.
- *
- * Copyright (c) 2010 Silicon Hive www.siliconhive.com.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- *
- */
-
-#ifndef _SH_CSS_METRICS_H_
-#define _SH_CSS_METRICS_H_
-
-struct sh_css_pc_histogram {
-	unsigned length;
-	unsigned *run;
-	unsigned *stall;
-	unsigned *msink;
-};
-
-#if !defined(__USE_DESIGNATED_INITIALISERS__)
-#define DEFAULT_PC_HISTOGRAM \
-{ \
-	0, \
-	NULL, \
-	NULL, \
-	NULL \
-}
-#endif
-
-struct sh_css_binary_metrics {
-	unsigned mode;
-	unsigned id;
-	struct sh_css_pc_histogram isp_histogram;
-	struct sh_css_pc_histogram sp_histogram;
-	struct sh_css_binary_metrics *next;
-};
-
-#if !defined(__USE_DESIGNATED_INITIALISERS__)
-#define DEFAULT_BINARY_METRICS \
-{ \
-	0, \
-	0, \
-	DEFAULT_PC_HISTOGRAM, \
-	DEFAULT_PC_HISTOGRAM, \
-	NULL \
-}
-#endif
-
-struct sh_css_frame_metrics {
-	unsigned num_frames;
-};
-
-struct sh_css_metrics {
-	struct sh_css_binary_metrics *binary_metrics;
-	struct sh_css_frame_metrics   frame_metrics;
-};
-
-extern struct sh_css_metrics sh_css_metrics;
-
-/* includes sh_css_binary.h, which depends on sh_css_metrics.h */
-#include "sh_css_types.h"
-
-/* Sample ISP and SP pc and add to histogram */
-void sh_css_metrics_enable_pc_histogram(bool enable);
-void sh_css_metrics_start_frame(void);
-void sh_css_metrics_start_binary(struct sh_css_binary_metrics *metrics);
-void sh_css_metrics_sample_pcs(void);
-
-#endif /* _SH_CSS_METRICS_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.c
deleted file mode 100644
index 6cf3f58..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.c
+++ /dev/null
@@ -1,581 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "sh_css_param_shading.h"
-#include "sh_css.h"
-#include "sh_css_defs.h"
-#include "sh_css_debug.h"
-#include "sh_css_pipeline.h"
-#include "sh_css_hrt.h"
-#include "memory_access.h"
-#include "platform_support.h"
-#include "assert_support.h"
-
-#if 0
-/* Acces function for isp shading table, access per color per line */
-/* unsigned short data[SH_CSS_SC_NUM_COLORS][sht->height][sht->stride] */
-#define sh_table_entry(sht, color, line, xpos)             \
-	(sht->data + color * sht->stride * sht->height +  \
-	line * sht->stride + xpos)
-#else
-/* Acces function for isp shading table, access per line per color. Layout: */
-/* unsigned short data[sht->height][SH_CSS_SC_NUM_COLORS][sht->stride] */
-#define sh_table_entry(sht, color, line, xpos)             \
-	(sht->data + line * sht->stride * SH_CSS_SC_NUM_COLORS +  \
-	color * sht->stride + xpos)
-#endif
-
-#define DEFAULT_UNITY_VALUE	1
-#define DEFAULT_FRAC_BITS	0
-
-/** Lens color shading table. This describes the color shading artefacts
- *  introduced by lens imperfections.
- */
-struct sh_css_shading_table_isp {
-	unsigned int sensor_width;  /**< Native sensor width in pixels */
-	unsigned int sensor_height; /**< Native sensor height in lines */
-	unsigned int width;  /**< Number of data points per line per color */
-	unsigned int stride; /* padded width */
-	unsigned int height; /**< Number of lines of data points per color */
-	unsigned int fraction_bits; /**< Bits of fractional part in the data
-					    points */
-	unsigned short *data; /* isp shading table data. See sh_table_entry() */
-};
-
-static const struct sh_css_shading_table *sc_table;
-static bool sc_table_changed;
-
-/* Bilinear interpolation on shading tables:
- * For each target point T, we calculate the 4 surrounding source points:
- * ul (upper left), ur (upper right), ll (lower left) and lr (lower right).
- * We then calculate the distances from the T to the source points: x0, x1,
- * y0 and y1.
- * We then calculate the value of T:
- *   dx0*dy0*Slr + dx0*dy1*Sur + dx1*dy0*Sll + dx1*dy1*Sul.
- * We choose a grid size of 1x1 which means:
- *   dx1 = 1-dx0
- *   dy1 = 1-dy0
- *
- *   Sul dx0         dx1      Sur
- *    .<----->|<------------->.
- *    ^
- * dy0|
- *    v        T
- *    -        .
- *    ^
- *    |
- * dy1|
- *    v
- *    .                        .
- *   Sll                      Slr
- *
- * Padding:
- * The area that the ISP operates on can include padding both on the left
- * and the right. We need to padd the shading table such that the shading
- * values end up on the correct pixel values. This means we must padd the
- * shading table to match the ISP padding.
- * We can have 5 cases:
- * 1. All 4 points fall in the left padding.
- * 2. The left 2 points fall in the left padding.
- * 3. All 4 points fall in the cropped (target) region.
- * 4. The right 2 points fall in the right padding.
- * 5. All 4 points fall in the right padding.
- * Cases 1 and 5 are easy to handle: we simply use the
- * value 1 in the shading table.
- * Cases 2 and 4 require interpolation that takes into
- * account how far into the padding area the pixels
- * fall. We extrapolate the shading table into the
- * padded area and then interpolate.
- */
-static void
-crop_and_interpolate(unsigned int cropped_width,
-		     unsigned int cropped_height,
-		     unsigned int left_padding,
-		     unsigned int right_padding,
-		     const struct sh_css_shading_table *in_table,
-		     struct sh_css_shading_table_isp *out_table)
-{
-	unsigned int c, l, x,
-		     sensor_width  = in_table->sensor_width,
-		     sensor_height = in_table->sensor_height,
-		     table_width   = in_table->width,
-		     table_height  = in_table->height,
-		     table_cell_h,
-		     out_cell_size,
-		     in_cell_size,
-		     out_start_row,
-		     padded_width;
-	int out_start_col, /* can be negative to indicate padded space */
-	    table_cell_w;
-
-	padded_width = cropped_width + left_padding + right_padding;
-	out_cell_size = CEIL_DIV(padded_width, out_table->width - 1);
-	in_cell_size  = CEIL_DIV(sensor_width, table_width - 1);
-
-	out_start_col = (sensor_width - cropped_width)/2 - left_padding;
-	out_start_row = (sensor_height - cropped_height)/2;
-	table_cell_w = (int)((table_width-1) * in_cell_size);
-	table_cell_h = (table_height-1) * in_cell_size;
-
-	for (l = 0; l < out_table->height; l++) {
-		unsigned int ty, src_y0, src_y1, sy0, sy1, dy0, dy1, divy;
-
-		/* calculate target point and make sure it falls within
-		   the table */
-		ty = out_start_row + l * out_cell_size;
-		ty = min(ty, sensor_height-1);
-		ty = min(ty, table_cell_h);
-
-		/* calculate closest source points in shading table and
-		   make sure they fall within the table */
-		src_y0 = ty / in_cell_size;
-		if (in_cell_size < out_cell_size)
-			src_y1 = (ty + out_cell_size) / in_cell_size;
-		else
-			src_y1 = src_y0 + 1;
-		src_y0 = min(src_y0, table_height-1);
-		src_y1 = min(src_y1, table_height-1);
-		/* calculate closest source points for distance computation */
-		sy0 = min(src_y0 * in_cell_size, sensor_height-1);
-		sy1 = min(src_y1 * in_cell_size, sensor_height-1);
-		/* calculate distance between source and target pixels */
-		dy0 = ty - sy0;
-		dy1 = sy1 - ty;
-		divy = sy1 - sy0;
-		if (divy == 0) {
-			dy0 = 1;
-			divy = 1;
-		}
-
-		for (x = 0; x < out_table->width; x++) {
-			int tx, src_x0, src_x1;
-			unsigned int sx0, sx1, dx0, dx1, divx;
-			unsigned short s_ul, s_ur, s_ll, s_lr;
-
-			/* calculate target point */
-			tx = out_start_col + x * out_cell_size;
-			/* calculate closest source points. */
-			src_x0 = tx / (int)in_cell_size;
-			if (in_cell_size < out_cell_size) {
-				src_x1 = (tx + out_cell_size) /
-					 (int)in_cell_size;
-			} else {
-				src_x1 = src_x0 + 1;
-			}
-			/* if src points fall in padding, select closest ones.*/
-			src_x0 = clamp(src_x0, 0, (int)table_width-1);
-			src_x1 = clamp(src_x1, 0, (int)table_width-1);
-			tx = min(clamp(tx, 0, (int)sensor_width-1),
-				 (int)table_cell_w);
-			/* calculate closest source points for distance
-			   computation */
-			sx0 = min(src_x0 * in_cell_size, sensor_width-1);
-			sx1 = min(src_x1 * in_cell_size, sensor_width-1);
-			/* calculate distances between source and target
-			   pixels */
-			dx0 = tx - sx0;
-			dx1 = sx1 - tx;
-			divx = sx1 - sx0;
-			/* if we're at the edge, we just use the closest
-			   point still in the grid. We make up for the divider
-			   in this case by setting the distance to
-			   out_cell_size, since it's actually 0. */
-			if (divx == 0) {
-				dx0 = 1;
-				divx = 1;
-			}
-
-			for (c = 0; c < SH_CSS_SC_NUM_COLORS; c++) {
-				/* get source pixel values */
-				s_ul = in_table->data[c]
-						[(table_width*src_y0)+src_x0];
-				s_ur = in_table->data[c]
-						[(table_width*src_y0)+src_x1];
-				s_ll = in_table->data[c]
-						[(table_width*src_y1)+src_x0];
-				s_lr = in_table->data[c]
-					[(table_width*src_y1)+src_x1];
-
-				*sh_table_entry(out_table, c, l, x) =
-						(dx0*dy0*s_lr +
-						dx0*dy1*s_ur +
-						dx1*dy0*s_ll +
-						dx1*dy1*s_ul) / (divx*divy);
-			}
-		}
-	}
-}
-
-static void
-generate_id_shading_table(struct sh_css_shading_table_isp **target_table,
-			  const struct sh_css_binary *binary)
-{
-	unsigned int c, l, x, table_width, table_height, table_stride;
-	struct sh_css_shading_table_isp *result;
-
-	table_width  = binary->sctbl_width_per_color;
-	table_stride = binary->sctbl_aligned_width_per_color;
-	table_height = binary->sctbl_height;
-
-	result = sh_css_malloc(sizeof(*result));
-	if (result == NULL) {
-		*target_table = NULL;
-		return;
-	}
-	result->width	  = table_width;
-	result->stride	  = table_stride;
-	result->height	  = table_height;
-	result->sensor_width  = 0;
-	result->sensor_height = 0;
-	result->fraction_bits = DEFAULT_FRAC_BITS;
-
-	result->data =
-	    sh_css_malloc(SH_CSS_SC_NUM_COLORS * table_stride * table_height *
-		    				sizeof(*result->data));
-	if (result->data == NULL) {
-		sh_css_free(result);
-		*target_table = NULL;
-		return;
-	}
-
-	/* initialize table with ones and padding with zeros*/
-	for (c = 0; c < SH_CSS_SC_NUM_COLORS; c++) {
-		for (l = 0; l < table_height; l++) {
-			for (x = 0; x < table_width; x++)
-				*sh_table_entry(result, c, l, x) = DEFAULT_UNITY_VALUE;
-			for (; x < table_stride; x++)
-				*sh_table_entry(result, c, l, x) = 0;
-		}
-	}
-
-	*target_table = result;
-}
-
-static void
-sh_css_param_shading_table_prepare(const struct sh_css_shading_table *in_table,
-			unsigned int sensor_binning,
-			bool raw_binning,
-			struct sh_css_shading_table_isp **target_table,
-			const struct sh_css_binary *binary)
-{
-	unsigned int input_width,
-		     input_height,
-		     table_width,
-		     table_stride,
-		     table_height,
-		     left_padding,
-		     right_padding;
-
-	struct sh_css_shading_table_isp *result;
-
-	if (!in_table) {
-		generate_id_shading_table(target_table, binary);
-		return;
-	}
-
-	/* We use the ISP input resolution for the shading table because
-	   shading correction is performed in the bayer domain (before bayer
-	   down scaling). */
-	input_height  = binary->in_frame_info.height;
-	input_width   = binary->in_frame_info.width;
-	left_padding  = binary->left_padding;
-	right_padding = binary->in_frame_info.padded_width -
-			(input_width + left_padding);
-
-	if ((binary->info->mode == SH_CSS_BINARY_MODE_PREVIEW)
-			&& raw_binning
-			&& binary->info->enable.raw_binning) {
-		input_width = input_width * 2 - binary->info->left_cropping;
-		input_height = input_height * 2 - binary->info->top_cropping;
-	}
-
-	/* We take into account the binning done by the sensor. We do this
-	   by cropping the non-binned part of the shading table and then
-	   increasing the size of a grid cell with this same binning factor. */
-	input_width  <<= sensor_binning;
-	input_height <<= sensor_binning;
-	/* We also scale the padding by the same binning factor. This will
-	   make it much easier later on to calculate the padding of the
-	   shading table. */
-	left_padding  <<= sensor_binning;
-	right_padding <<= sensor_binning;
-
-	/* during simulation, the used resolution can exceed the sensor
-	   resolution, so we clip it. */
-	input_width  = min(input_width,  in_table->sensor_width);
-	input_height = min(input_height, in_table->sensor_height);
-
-	table_width  = binary->sctbl_width_per_color;
-	table_stride = binary->sctbl_aligned_width_per_color;
-	table_height = binary->sctbl_height;
-
-	result = sh_css_malloc(sizeof(*result));
-	if (result == NULL) {
-		*target_table = NULL;
-		return;
-	}
-	result->width	  = table_width;
-	result->stride	  = table_stride;
-	result->height	  = table_height;
-	result->sensor_width  = in_table->sensor_width;
-	result->sensor_height = in_table->sensor_height;
-	result->fraction_bits = in_table->fraction_bits;
-
-	result->data =
-	    sh_css_malloc(SH_CSS_SC_NUM_COLORS * table_stride * table_height *
-		    				sizeof(*result->data));
-	if (result->data == NULL) {
-		sh_css_free(result);
-		*target_table = NULL;
-		return;
-	}
-
-	crop_and_interpolate(input_width, input_height,
-			     left_padding, right_padding,
-			     in_table,
-			     result);
-
-	*target_table = result;
-
-}
-
-void
-sh_css_param_shading_table_init(void)
-{
-	sc_table = NULL;
-	sc_table_changed = true;
-}
-
-void
-sh_css_param_shading_table_changed_set(bool changed)
-{
-	sc_table_changed = changed;
-}
-
-bool
-sh_css_param_shading_table_changed_get(void)
-{
-	return sc_table_changed;
-}
-
-unsigned int
-sh_css_param_shading_table_fraction_bits_get(void)
-{
-	if (sc_table == NULL) {
-		/* There is no shading table yet, use default unity value */
-		return DEFAULT_FRAC_BITS;
-	}
-
-	return sc_table->fraction_bits;
-}
-
-bool
-sh_css_param_shading_table_store(
-	hrt_vaddress isp_sc_tbl,
-	unsigned int sensor_binning,
-	bool raw_binning,
-	const struct sh_css_binary *binary)
-{
-	struct sh_css_shading_table_isp *tmp_sc_table_isp;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_param_shading_table_store() enter:\n");
-
-	/* shading table is full resolution, reduce */
-	sh_css_param_shading_table_prepare(sc_table, sensor_binning,
-					raw_binning, &tmp_sc_table_isp, binary);
-	if (tmp_sc_table_isp == NULL)
-		return false;
-
-	mmgr_store(isp_sc_tbl, sh_table_entry(tmp_sc_table_isp, 0, 0, 0),
-		SH_CSS_SC_NUM_COLORS * tmp_sc_table_isp->height *
-		tmp_sc_table_isp->stride * sizeof(short));
-
-	sh_css_free(tmp_sc_table_isp->data);
-	sh_css_free(tmp_sc_table_isp);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_param_shading_table_store() leave:\n");
-
-	return true;
-}
-
-struct sh_css_shading_table *
-sh_css_param_shading_table_get(
-	unsigned int sensor_binning,
-	bool raw_binning)
-{
-	struct sh_css_shading_table *sc_table_css = NULL;
-	struct sh_css_shading_table_isp *tmp_sc_table_isp = NULL;
-	struct sh_css_binary *binary = NULL;
-	unsigned num_pipes, p, l;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_param_shading_table_get() enter:\n");
-
-	sh_css_pipeline_stream_get_num_pipelines(&num_pipes);
-	for (p = 0; p < num_pipes; p++) {
-		struct sh_css_pipeline *pipeline;
-		struct sh_css_pipeline_stage *stage;
-		unsigned int thread_id;
-		sh_css_pipeline_stream_get_pipeline(p, &pipeline);
-
-		assert(pipeline != NULL);
-		if (pipeline == NULL)
-			return NULL;
-
-		sh_css_query_sp_thread_id(pipeline->pipe_id, &thread_id);
-
-		for (stage = pipeline->stages; stage; stage = stage->next) {
-			if (stage && stage->binary) {
-				if (stage->binary->info->enable.sc) {
-					binary = stage->binary;
-					break;
-				}
-			}
-		}
-		if (binary)
-			break;
-	}
-	if (binary) {
-		sh_css_param_shading_table_prepare(
-			(const struct sh_css_shading_table *)sc_table,
-			sensor_binning,
-			raw_binning,
-			&tmp_sc_table_isp,
-			binary);
-
-		sc_table_css = sh_css_shading_table_alloc(
-			binary->sctbl_width_per_color, binary->sctbl_height);
-		if ((sc_table_css == NULL) || (tmp_sc_table_isp == NULL))
-			return NULL;
-
-		sc_table_css->sensor_width = tmp_sc_table_isp->sensor_width;
-		sc_table_css->sensor_height = tmp_sc_table_isp->sensor_height;
-		sc_table_css->width = tmp_sc_table_isp->width;
-		sc_table_css->height = tmp_sc_table_isp->height;
-		sc_table_css->fraction_bits = tmp_sc_table_isp->fraction_bits;
-
-		/* Copy + reformat shading table data from ISP to CSS data structure */
-		for (l = 0; l < sc_table_css->height; l++) {
-			unsigned int c;
-			for (c = 0; c < SH_CSS_SC_NUM_COLORS; c++) {
-				memcpy(&sc_table_css->data[c][l*sc_table_css->width],
-				     sh_table_entry(tmp_sc_table_isp, c, l, 0),
-				     sc_table_css->width * sizeof(short));
-			}
-		}
-
-		/* Free the isp shading table in HMM */
-		sh_css_free(tmp_sc_table_isp->data);
-		sh_css_free(tmp_sc_table_isp);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_param_shading_table_get() leave:return=%p\n",
-		sc_table_css);
-
-	return sc_table_css;
-}
-
-bool
-sh_css_param_shading_table_set(
-	const struct sh_css_shading_table *table)
-{
-/* input can be NULL ?? */
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_shading_table_set() enter:\n");
-
-	if (table != sc_table) {
-		sc_table = table;
-		sc_table_changed = true;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_shading_table_set() leave:\n");
-
-	return sc_table_changed;
-}
-
-struct sh_css_shading_table *
-sh_css_shading_table_alloc(
-	unsigned int width,
-	unsigned int height)
-{
-	unsigned int i;
-	struct sh_css_shading_table *me = sh_css_malloc(sizeof(*me));
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_shading_table_alloc() enter:\n");
-
-	if (me == NULL) {
-/* Checkpatch patch */
-		return me;
-	}
-	me->width		 = width;
-	me->height		= height;
-	me->sensor_width  = 0;
-	me->sensor_height = 0;
-	me->fraction_bits = 0;
-	for (i = 0; i < SH_CSS_SC_NUM_COLORS; i++) {
-		me->data[i] =
-		    sh_css_malloc(width * height * sizeof(*me->data[0]));
-		if (me->data[i] == NULL) {
-			unsigned int j;
-			for (j = 0; j < i; j++)
-				sh_css_free(me->data[j]);
-			sh_css_free(me);
-			return NULL;
-		}
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_shading_table_alloc() leave:\n");
-
-	return me;
-}
-
-void
-sh_css_shading_table_free(struct sh_css_shading_table *table)
-{
-	unsigned int i;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_shading_table_free() enter:\n");
-
-	if (table == NULL) {
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_shading_table_free() leave: table == NULL\n");
-		return;
-	}
-
-	for (i = 0; i < SH_CSS_SC_NUM_COLORS; i++) {
-		if (table->data[i])
-			sh_css_free(table->data[i]);
-	}
-	sh_css_free(table);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_shading_table_free() leave:\n");
-}
-
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.h
deleted file mode 100644
index d7057d6..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_param_shading.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_PARAMS_SHADING_H_
-#define _SH_CSS_PARAMS_SHADING_H_
-
-#include "sh_css.h"
-#include "sh_css_internal.h"
-#include "sh_css_binary.h"
-
-void
-sh_css_param_shading_table_init(void);
-
-void
-sh_css_param_shading_table_changed_set(bool changed);
-
-bool
-sh_css_param_shading_table_changed_get(void);
-
-unsigned int
-sh_css_param_shading_table_fraction_bits_get(void);
-
-bool
-sh_css_param_shading_table_store(
-	hrt_vaddress isp_sc_tbl,
-	unsigned int sensor_binning,
-	bool raw_binning,
-	const struct sh_css_binary *binary);
-
-struct sh_css_shading_table *
-sh_css_param_shading_table_get(
-	unsigned int sensor_binning,
-	bool raw_binning);
-
-bool
-sh_css_param_shading_table_set(
-	const struct sh_css_shading_table *table);
-
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.c
deleted file mode 100644
index c607868..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.c
+++ /dev/null
@@ -1,6548 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "gdc_device.h"		/* gdc_lut_store(), ... */
-#include "isp.h"			/* ISP_VEC_ELEMBITS */
-#include "vamem.h"
-#include "queue.h"			/* host2sp_enqueue_frame_data() */
-#include "sw_event.h"		/* encode_sw_event */
-
-#include "assert_support.h"
-
-#include "sh_css.h"
-#include "sh_css_params.h"
-#include "sh_css_params_internal.h"
-#include "sh_css_param_shading.h"
-#include "sh_css_refcount.h"
-#include "sh_css_pipeline.h"
-#include "sh_css_internal.h"
-#include "sh_css_defs.h"
-#include "sh_css_sp.h"
-#include "sh_css_sp_start.h"	/* SH_CSS_PREVENT_UNINIT_READS */
-#include "sh_css_debug.h"
-#include "memory_access.h"
-
-#include "platform_support.h"
-
-#define NOT_USED(a)                ((a) = (a))
-
-#define sISP_REG_BIT		      ISP_VEC_ELEMBITS
-#define uISP_REG_BIT		      ((unsigned)(sISP_REG_BIT-1))
-#define sSHIFT				    (16-sISP_REG_BIT)
-#define uSHIFT				    ((unsigned)(16-uISP_REG_BIT))
-#define sFRACTION_BITS_FITTING(a) (a-sSHIFT)
-#define uFRACTION_BITS_FITTING(a) ((unsigned)(a-uSHIFT))
-#define sISP_VAL_MIN		      (-(1<<uISP_REG_BIT))
-#define sISP_VAL_MAX		      ((1<<uISP_REG_BIT)-1)
-#define uISP_VAL_MIN		      ((unsigned)0)
-#define uISP_VAL_MAX		      ((unsigned)((1<<uISP_REG_BIT)-1))
-
-/* Convenience macro to force a value to a lower even value.
- *  We do not want to (re)use the kernel macro round_down here
- *  because the same code base is used internally by Silicon Hive
- *  simulation environment, where the kernel macro is not available
- */
-#define EVEN_FLOOR(x)	(x & ~1)
-
-/* a:fraction bits for 16bit precision, b:fraction bits for ISP precision */
-#define sDIGIT_FITTING(v, a, b) \
-	min(max((((v)>>sSHIFT) >> (sFRACTION_BITS_FITTING(a)-(b))), \
-	  sISP_VAL_MIN), sISP_VAL_MAX)
-#define uDIGIT_FITTING(v, a, b) \
-	min((unsigned)max((unsigned)(((v)>>uSHIFT) \
-	>> (uFRACTION_BITS_FITTING(a)-(b))), \
-	  uISP_VAL_MIN), uISP_VAL_MAX)
-
-#define FPNTBL_BYTES(binary) \
-	(sizeof(char) * (binary)->in_frame_info.height * \
-	 (binary)->in_frame_info.padded_width)
-#define SCTBL_BYTES(binary) \
-	(sizeof(unsigned short) * (binary)->sctbl_height * \
-	 (binary)->sctbl_aligned_width_per_color * SH_CSS_SC_NUM_COLORS)
-#if 0
-#define S3ATBL_BYTES(binary) \
-	(sizeof(struct sh_css_3a_output) * (binary)->s3atbl_isp_width * \
-	 (binary)->s3atbl_isp_height)
-#endif
-/* TODO: check if the stride is always the same max value or whether
- * it varies per resolution. */
-#if 0
-#define S3ATBL_HI_LO_BYTES(binary) \
-	(ISP_S3ATBL_HI_LO_STRIDE_BYTES * (binary)->s3atbl_isp_height)
-#endif
-/* SDIS */
-#define SDIS_VER_COEF_TBL__IN_DMEM(b) \
-	_SDIS_VER_COEF_TBL_USE_DMEM(b->info->mode, b->info->enable.dis)
-
-#define SH_CSS_DIS_VER_NUM_COEF_TYPES(b) \
-	(SDIS_VER_COEF_TBL__IN_DMEM(b) ? \
-		SH_CSS_DIS_COEF_TYPES_ON_DMEM : \
-		SH_CSS_DIS_NUM_COEF_TYPES)
-
-#define SDIS_HOR_COEF_TBL_BYTES(b) \
-	(sizeof(short) * SH_CSS_DIS_NUM_COEF_TYPES * (b)->dis_hor_coef_num_isp)
-#define SDIS_VER_COEF_TBL_BYTES(b) \
-	(sizeof(short) * SH_CSS_DIS_VER_NUM_COEF_TYPES(b) * \
-		(b)->dis_ver_coef_num_isp)
-#if 0
-#define SDIS_HOR_PROJ_TBL_BYTES(b) \
-	(sizeof(int)   * SH_CSS_DIS_NUM_COEF_TYPES * (b)->dis_hor_proj_num_isp)
-#define SDIS_VER_PROJ_TBL_BYTES(b) \
-	(sizeof(int)   * SH_CSS_DIS_NUM_COEF_TYPES * (b)->dis_ver_proj_num_isp)
-#endif
-#define MORPH_PLANE_BYTES(binary) \
-	(SH_CSS_MORPH_TABLE_ELEM_BYTES * (binary)->morph_tbl_aligned_width * \
-	 (binary)->morph_tbl_height)
-
-/* @GC TODO: Move these defines to the appropriate place later. */
-#define DVS_BLOCKDIM_X (64)
-#define DVS_BLOCKDIM_Y (64)
-#define DVS_COORD_FRAC_BITS (10)
-#define DVS_INPUT_BYTES_PER_PIXEL (1)
-#define XMEM_ALIGN_LOG2 (5)
-
-#define DVS_6AXIS_COORDS_ELEMS CEIL_MUL(sizeof(gdc_warp_param_mem_t) \
-					, HIVE_ISP_DDR_WORD_BYTES)
-
-#define DVS_6AXIS_BYTES(binary) \
-	(DVS_6AXIS_COORDS_ELEMS \
-	 * (binary)->out_frame_info.width / DVS_BLOCKDIM_X \
-	 * (binary)->out_frame_info.height) / (DVS_BLOCKDIM_Y)
-
-
-static struct sh_css_isp_params isp_parameters;
-static struct sh_css_fpn_table fpn_table;
-static struct sh_css_zoom zoom_config;
-static struct sh_css_vector motion_config;
-static const struct sh_css_morph_table   *morph_table;
-static const struct sh_css_macc_table    *macc_table;
-static const struct sh_css_gamma_table   *gamma_table;
-static const struct sh_css_ctc_table     *ctc_table;
-static const struct sh_css_xnr_table     *xnr_table;
-static const struct sh_css_3a_config     *s3a_config;
-static const struct sh_css_wb_config     *wb_config;
-static const struct sh_css_cc_config     *cc_config;
-static const struct sh_css_tnr_config    *tnr_config;
-static const struct sh_css_ob_config     *ob_config;
-static const struct sh_css_dp_config     *dp_config;
-static const struct sh_css_nr_config     *nr_config;
-static const struct sh_css_ee_config     *ee_config;
-static const struct sh_css_de_config     *de_config;
-static const struct sh_css_gc_config     *gc_config;
-static const struct sh_css_anr_config    *anr_config;
-static const struct sh_css_ce_config     *ce_config;
-static const struct sh_css_dvs_6axis_config     *dvs_6axis_config;
-static const struct sh_css_ecd_config    *ecd_config;
-static const struct sh_css_ynr_config    *ynr_config;
-static const struct sh_css_fc_config     *fc_config;
-static const struct sh_css_cnr_config    *cnr_config;
-static const struct sh_css_macc_config   *macc_config;
-static const struct sh_css_ctc_config    *ctc_config;
-static const struct sh_css_aa_config     *aa_config;
-static const struct sh_css_xnr_config    *xnr_config;
-static const struct sh_css_rgb_gamma_table     *r_gamma_table;
-static const struct sh_css_rgb_gamma_table     *g_gamma_table;
-static const struct sh_css_rgb_gamma_table     *b_gamma_table;
-static const struct sh_css_yuv2rgb_cc_config   *yuv2rgb_cc_config;
-static const struct sh_css_rgb2yuv_cc_config   *rgb2yuv_cc_config;
-static bool isp_params_changed,
-	    fpn_table_changed,
-	    zoom_config_changed,
-	    motion_config_changed,
-	    dis_coef_table_changed,
-	    morph_table_changed,
-	    macc_table_changed,
-	    gamma_table_changed,
-	    ctc_table_changed,
-	    xnr_table_changed,
-	    s3a_config_changed,
-	    wb_config_changed,
-	    cc_config_changed,
-	    tnr_config_changed,
-	    ob_config_changed,
-	    dp_config_changed,
-	    nr_config_changed,
-	    ee_config_changed,
-	    de_config_changed,
-	    gc_config_changed,
-	    anr_config_changed,
-	    ce_config_changed,
-	    dvs_6axis_config_changed,
-	    ecd_config_changed,
-	    ynr_config_changed,
-	    fc_config_changed,
-	    cnr_config_changed,
-	    macc_config_changed,
-	    ctc_config_changed,
-	    aa_config_changed,
-	    r_gamma_table_changed,
-	    g_gamma_table_changed,
-	    b_gamma_table_changed,
-	    yuv2rgb_cc_config_changed,
-	    rgb2yuv_cc_config_changed,
-		xnr_config_changed;
-
-
-static unsigned int sensor_binning;
-static bool raw_binning;
-
-/* local buffers, used to re-order the 3a statistics in vmem-format */
-static unsigned short s3a_tbl_hi_buf[ISP_S3ATBL_HI_LO_STRIDE *
-				     SH_CSS_MAX_BQ_GRID_HEIGHT],
-		      s3a_tbl_lo_buf[ISP_S3ATBL_HI_LO_STRIDE *
-				     SH_CSS_MAX_BQ_GRID_HEIGHT];
-static struct sh_css_macc_table converted_macc_table;
-static const short *dis_hor_coef_tbl,
-		   *dis_ver_coef_tbl;
-static const struct sh_css_binary *current_3a_binary;
-/*
- * for csim and fpga, we need to keep a copy of all data in DDR.
- * On the chip this is not necessary through.
- * TODO: remove this for the chip
- *
- * "memory_manager.h" defines mmgr_mmap()
- */
-static struct sh_css_ddr_address_map ddr_ptrs;
-static struct sh_css_ddr_address_map_size ddr_ptrs_size;
-
-static struct sh_css_ddr_address_map
-			pipe_ddr_ptrs[SH_CSS_NR_OF_PIPELINES];
-static struct sh_css_ddr_address_map_size
-			pipe_ddr_ptrs_size[SH_CSS_NR_OF_PIPELINES];
-
-/* We keep a second copy of the ptr struct for the SP to access.
-   Again, this would not be necessary on the chip. */
-static hrt_vaddress sp_ddr_ptrs;
-
-/* sp group address on DDR */
-static hrt_vaddress xmem_sp_group_ptrs;
-
-static hrt_vaddress xmem_sp_stage_ptrs[SH_CSS_NR_OF_PIPELINES]
-						[SH_CSS_MAX_STAGES];
-static hrt_vaddress xmem_isp_stage_ptrs[SH_CSS_NR_OF_PIPELINES]
-						[SH_CSS_MAX_STAGES];
-
-
-
-/* @GC: X and Y coords will later be pointer with no default value.
- * This is just for initial testing with hardcoded tetragon coords */
-#if defined(DVS_6AXIS_COORDS_1080P_UNITY)
-static const struct sh_css_dvs_6axis_config default_dvs_6axis_config = {
-	.xcoords = {
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688},
-{  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504,  983040, 1048576, 1114112, 1179648, 1245184, 1310720, 1376256, 1441792, 1507328, 1572864, 1638400, 1703936, 1769472, 1835008, 1900544, 1966080, 2031616, 2097152, 2162688}
-},
-	.ycoords = {
-{  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592,  110592},
-{  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128,  176128},
-{  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664,  241664},
-{  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200,  307200},
-{  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736,  372736},
-{  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272,  438272},
-{  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808,  503808},
-{  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344,  569344},
-{  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880,  634880},
-{  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416,  700416},
-{  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952,  765952},
-{  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488,  831488},
-{  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024,  897024},
-{  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560,  962560},
-{ 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096, 1028096},
-{ 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632, 1093632},
-{ 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168, 1159168},
-{ 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704, 1224704}
-}
-};
-#elif defined(DVS_6AXIS_COORDS_SMALL_UNITY)
-static const struct sh_css_dvs_6axis_config default_dvs_6axis_config = {
-	.xcoords = {
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504},
-{  131072,  196608,  262144,  327680,  393216,  458752,  524288,  589824,  655360,  720896,  786432,  851968,  917504}
-},
-	.ycoords = {
-{   98304,   98304,   98304,   98304,   98304,   98304,   98304,   98304,   98304,   98304,   98304,   98304,   98304},
-{  163840,  163840,  163840,  163840,  163840,  163840,  163840,  163840,  163840,  163840,  163840,  163840,  163840},
-{  229376,  229376,  229376,  229376,  229376,  229376,  229376,  229376,  229376,  229376,  229376,  229376,  229376},
-{  294912,  294912,  294912,  294912,  294912,  294912,  294912,  294912,  294912,  294912,  294912,  294912,  294912},
-{  360448,  360448,  360448,  360448,  360448,  360448,  360448,  360448,  360448,  360448,  360448,  360448,  360448},
-{  425984,  425984,  425984,  425984,  425984,  425984,  425984,  425984,  425984,  425984,  425984,  425984,  425984},
-{  491520,  491520,  491520,  491520,  491520,  491520,  491520,  491520,  491520,  491520,  491520,  491520,  491520},
-{  557056,  557056,  557056,  557056,  557056,  557056,  557056,  557056,  557056,  557056,  557056,  557056,  557056},
-{  622592,  622592,  622592,  622592,  622592,  622592,  622592,  622592,  622592,  622592,  622592,  622592,  622592},
-{  688128,  688128,  688128,  688128,  688128,  688128,  688128,  688128,  688128,  688128,  688128,  688128,  688128}
-}
-};
-#elif defined(DVS_6AXIS_COORDS_SMALL_WARPED)
-static const struct sh_css_dvs_6axis_config default_dvs_6axis_config = {
-	.xcoords = {
-{  223864,  254656,  285447,  316239,  347031,  377823,  408615,  439407,  470199,  500990,  531782,  562574,  593366},
-{  212656,  243448,  274240,  305032,  335824,  366616,  397408,  428199,  458991,  489783,  520575,  551367,  582159},
-{  201449,  232241,  263033,  293825,  324617,  355408,  386200,  416992,  447784,  478576,  509368,  540159,  570951},
-{  190242,  221034,  251825,  282617,  313409,  344201,  374993,  405785,  436577,  467368,  498160,  528952,  559744},
-{  179034,  209826,  240618,  271410,  302202,  332994,  363786,  394577,  425369,  456161,  486953,  517745,  548537},
-{  167827,  198619,  229411,  260203,  290995,  321786,  352578,  383370,  414162,  444954,  475746,  506538,  537329},
-{  156620,  187412,  218204,  248995,  279787,  310579,  341371,  372163,  402955,  433747,  464538,  495330,  526122},
-{  145413,  176204,  206996,  237788,  268580,  299372,  330164,  360956,  391747,  422539,  453331,  484123,  514915},
-{  134205,  164997,  195789,  226581,  257373,  288165,  318956,  349748,  380540,  411332,  442124,  472916,  503707},
-{  122998,  153790,  184582,  215374,  246165,  276957,  307749,  338541,  369333,  400125,  430916,  461708,  492500}
-},
-	.ycoords = {
-{  343012,  354219,  365427,  376634,  387841,  399048,  410256,  421463,  432670,  443878,  455085,  466292,  477500},
-{  373804,  385011,  396218,  407426,  418633,  429840,  441048,  452255,  463462,  474670,  485877,  497084,  508291},
-{  404596,  415803,  427010,  438218,  449425,  460632,  471839,  483047,  494254,  505461,  516669,  527876,  539083},
-{  435387,  446595,  457802,  469009,  480217,  491424,  502631,  513839,  525046,  536253,  547461,  558668,  569875},
-{  466179,  477387,  488594,  499801,  511009,  522216,  533423,  544631,  555838,  567045,  578252,  589460,  600667},
-{  496971,  508179,  519386,  530593,  541800,  553008,  564215,  575422,  586630,  597837,  609044,  620252,  631459},
-{  527763,  538970,  550178,  561385,  572592,  583800,  595007,  606214,  617422,  628629,  639836,  651043,  662251},
-{  558555,  569762,  580970,  592177,  603384,  614591,  625799,  637006,  648213,  659421,  670628,  681835,  693043},
-{  589347,  600554,  611761,  622969,  634176,  645383,  656591,  667798,  679005,  690213,  701420,  712627,  723834},
-{  620139,  631346,  642553,  653761,  664968,  676175,  687382,  698590,  709797,  721004,  732212,  743419,  754626}
-}
-};
-#else
-#error No default DVS coordinate table specified.
-#endif
-
-
-
-
-#if defined(HAS_VAMEM_VERSION_2)
-
-static const struct sh_css_gamma_table default_gamma_table = {
-{ 0,   4,   8,  12,  17,  21,  27,  32,
- 38,  44,  49,  55,  61,  66,  71,  76,
- 80,  84,  88,  92,  95,  98, 102, 105,
-108, 110, 113, 116, 118, 121, 123, 126,
-128, 130, 132, 135, 137, 139, 141, 143,
-145, 146, 148, 150, 152, 153, 155, 156,
-158, 160, 161, 162, 164, 165, 166, 168,
-169, 170, 171, 172, 174, 175, 176, 177,
-178, 179, 180, 181, 182, 183, 184, 184,
-185, 186, 187, 188, 189, 189, 190, 191,
-192, 192, 193, 194, 195, 195, 196, 197,
-197, 198, 198, 199, 200, 200, 201, 201,
-202, 203, 203, 204, 204, 205, 205, 206,
-206, 207, 207, 208, 208, 209, 209, 210,
-210, 210, 211, 211, 212, 212, 213, 213,
-214, 214, 214, 215, 215, 216, 216, 216,
-217, 217, 218, 218, 218, 219, 219, 220,
-220, 220, 221, 221, 222, 222, 222, 223,
-223, 223, 224, 224, 225, 225, 225, 226,
-226, 226, 227, 227, 227, 228, 228, 228,
-229, 229, 229, 230, 230, 230, 231, 231,
-231, 232, 232, 232, 233, 233, 233, 234,
-234, 234, 234, 235, 235, 235, 236, 236,
-236, 237, 237, 237, 237, 238, 238, 238,
-239, 239, 239, 239, 240, 240, 240, 241,
-241, 241, 241, 242, 242, 242, 242, 243,
-243, 243, 243, 244, 244, 244, 245, 245,
-245, 245, 246, 246, 246, 246, 247, 247,
-247, 247, 248, 248, 248, 248, 249, 249,
-249, 249, 250, 250, 250, 250, 251, 251,
-251, 251, 252, 252, 252, 252, 253, 253,
-253, 253, 254, 254, 254, 254, 255, 255,
-255 }
-};
-
-static const struct sh_css_ctc_table default_ctc_table = {
- { 0,  384,  837,  957, 1011, 1062, 1083, 1080,
-1078, 1077, 1053, 1039, 1012,  992,  969,  951,
- 929,  906,  886,  866,  845,  823,  809,  790,
- 772,  758,  741,  726,  711,  701,  688,  675,
- 666,  656,  648,  639,  633,  626,  618,  612,
- 603,  594,  582,  572,  557,  545,  529,  516,
- 504,  491,  480,  467,  459,  447,  438,  429,
- 419,  412,  404,  397,  389,  382,  376,  368,
- 363,  357,  351,  345,  340,  336,  330,  326,
- 321,  318,  312,  308,  304,  300,  297,  294,
- 291,  286,  284,  281,  278,  275,  271,  268,
- 261,  257,  251,  245,  240,  235,  232,  225,
- 223,  218,  213,  209,  206,  204,  199,  197,
- 193,  189,  186,  185,  183,  179,  177,  175,
- 172,  170,  169,  167,  164,  164,  162,  160,
- 158,  157,  156,  154,  154,  152,  151,  150,
- 149,  148,  146,  147,  146,  144,  143,  143,
- 142,  141,  140,  141,  139,  138,  138,  138,
- 137,  136,  136,  135,  134,  134,  134,  133,
- 132,  132,  131,  130,  131,  130,  129,  128,
- 129,  127,  127,  127,  127,  125,  125,  125,
- 123,  123,  122,  120,  118,  115,  114,  111,
- 110,  108,  106,  105,  103,  102,  100,   99,
-  97,   97,   96,   95,   94,   93,   93,   91,
-  91,   91,   90,   90,   89,   89,   88,   88,
-  89,   88,   88,   87,   87,   87,   87,   86,
-  87,   87,   86,   87,   86,   86,   84,   84,
-  82,   80,   78,   76,   74,   72,   70,   68,
-  67,   65,   62,   60,   58,   56,   55,   54,
-  53,   51,   49,   49,   47,   45,   45,   45,
-  41,   40,   39,   39,   34,   33,   34,   32,
-  25,   23,   24,   20,   13,    9,   12,    0,
-   0 }
-};
-
-static const struct sh_css_rgb_gamma_table default_r_gamma_table = {
-{  0,   72,  144,  216,  288,  360,  426,  486,
- 541,  592,  641,  687,  730,  772,  812,  850,
- 887,  923,  958,  991, 1024, 1055, 1086, 1117,
-1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
-1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
-1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
-1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
-1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
-2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
-2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
-2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
-2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
-2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
-2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
-2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
-2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
-2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
-2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
-3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
-3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
-3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
-3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
-3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
-3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
-3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
-3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
-3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
-3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
-3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
-3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
-3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
-4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
-4095 }
-};
-
-static const struct sh_css_rgb_gamma_table default_g_gamma_table = {
-{  0,   72,  144,  216,  288,  360,  426,  486,
- 541,  592,  641,  687,  730,  772,  812,  850,
- 887,  923,  958,  991, 1024, 1055, 1086, 1117,
-1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
-1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
-1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
-1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
-1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
-2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
-2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
-2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
-2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
-2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
-2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
-2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
-2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
-2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
-2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
-3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
-3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
-3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
-3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
-3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
-3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
-3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
-3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
-3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
-3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
-3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
-3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
-3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
-4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
-4095 }
-};
-
-static const struct sh_css_rgb_gamma_table default_b_gamma_table = {
-{  0,   72,  144,  216,  288,  360,  426,  486,
- 541,  592,  641,  687,  730,  772,  812,  850,
- 887,  923,  958,  991, 1024, 1055, 1086, 1117,
-1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
-1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
-1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
-1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
-1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
-2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
-2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
-2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
-2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
-2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
-2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
-2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
-2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
-2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
-2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
-3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
-3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
-3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
-3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
-3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
-3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
-3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
-3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
-3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
-3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
-3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
-3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
-3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
-4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
-4095 }
-};
-
-static const struct sh_css_xnr_table default_xnr_table = {
-  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
-  { 8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
-    546>>1, 512>>1,
-
-  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
-  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
-    256>>1,
-
-  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
-  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
-    170>>1,
-
-  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
-  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1 }
-  };
-
-const struct sh_css_gamma_table *default_gamma_table_ptr = &default_gamma_table;
-const struct sh_css_ctc_table *default_ctc_table_ptr = &default_ctc_table;
-const struct sh_css_xnr_table *default_xnr_table_ptr = &default_xnr_table;
-
-#elif defined(HAS_VAMEM_VERSION_1)
-
-/* Default Parameters */
-static const struct sh_css_gamma_table default_gamma_table = {
-		{ 0, 1, 2, 3, 4, 5, 6, 7,
-		8, 9, 10, 11, 12, 13, 14, 16,
-		17, 18, 19, 20, 21, 23, 24, 25,
-		27, 28, 29, 31, 32, 33, 35, 36,
-		38, 39, 41, 42, 44, 45, 47, 48,
-		49, 51, 52, 54, 55, 57, 58, 60,
-		61, 62, 64, 65, 66, 68, 69, 70,
-		71, 72, 74, 75, 76, 77, 78, 79,
-		80, 81, 82, 83, 84, 85, 86, 87,
-		88, 89, 90, 91, 92, 93, 93, 94,
-		95, 96, 97, 98, 98, 99, 100, 101,
-		102, 102, 103, 104, 105, 105, 106, 107,
-		108, 108, 109, 110, 110, 111, 112, 112,
-		113, 114, 114, 115, 116, 116, 117, 118,
-		118, 119, 120, 120, 121, 121, 122, 123,
-		123, 124, 125, 125, 126, 126, 127, 127,	/* 128 */
-		128, 129, 129, 130, 130, 131, 131, 132,
-		132, 133, 134, 134, 135, 135, 136, 136,
-		137, 137, 138, 138, 139, 139, 140, 140,
-		141, 141, 142, 142, 143, 143, 144, 144,
-		145, 145, 145, 146, 146, 147, 147, 148,
-		148, 149, 149, 150, 150, 150, 151, 151,
-		152, 152, 152, 153, 153, 154, 154, 155,
-		155, 155, 156, 156, 156, 157, 157, 158,
-		158, 158, 159, 159, 160, 160, 160, 161,
-		161, 161, 162, 162, 162, 163, 163, 163,
-		164, 164, 164, 165, 165, 165, 166, 166,
-		166, 167, 167, 167, 168, 168, 168, 169,
-		169, 169, 170, 170, 170, 170, 171, 171,
-		171, 172, 172, 172, 172, 173, 173, 173,
-		174, 174, 174, 174, 175, 175, 175, 176,
-		176, 176, 176, 177, 177, 177, 177, 178,	/* 256 */
-		178, 178, 178, 179, 179, 179, 179, 180,
-		180, 180, 180, 181, 181, 181, 181, 182,
-		182, 182, 182, 182, 183, 183, 183, 183,
-		184, 184, 184, 184, 184, 185, 185, 185,
-		185, 186, 186, 186, 186, 186, 187, 187,
-		187, 187, 187, 188, 188, 188, 188, 188,
-		189, 189, 189, 189, 189, 190, 190, 190,
-		190, 190, 191, 191, 191, 191, 191, 192,
-		192, 192, 192, 192, 192, 193, 193, 193,
-		193, 193, 194, 194, 194, 194, 194, 194,
-		195, 195, 195, 195, 195, 195, 196, 196,
-		196, 196, 196, 196, 197, 197, 197, 197,
-		197, 197, 198, 198, 198, 198, 198, 198,
-		198, 199, 199, 199, 199, 199, 199, 200,
-		200, 200, 200, 200, 200, 200, 201, 201,
-		201, 201, 201, 201, 201, 202, 202, 202,	/* 384 */
-		202, 202, 202, 202, 203, 203, 203, 203,
-		203, 203, 203, 204, 204, 204, 204, 204,
-		204, 204, 204, 205, 205, 205, 205, 205,
-		205, 205, 205, 206, 206, 206, 206, 206,
-		206, 206, 206, 207, 207, 207, 207, 207,
-		207, 207, 207, 208, 208, 208, 208, 208,
-		208, 208, 208, 209, 209, 209, 209, 209,
-		209, 209, 209, 209, 210, 210, 210, 210,
-		210, 210, 210, 210, 210, 211, 211, 211,
-		211, 211, 211, 211, 211, 211, 212, 212,
-		212, 212, 212, 212, 212, 212, 212, 213,
-		213, 213, 213, 213, 213, 213, 213, 213,
-		214, 214, 214, 214, 214, 214, 214, 214,
-		214, 214, 215, 215, 215, 215, 215, 215,
-		215, 215, 215, 216, 216, 216, 216, 216,
-		216, 216, 216, 216, 216, 217, 217, 217,	/* 512 */
-		217, 217, 217, 217, 217, 217, 217, 218,
-		218, 218, 218, 218, 218, 218, 218, 218,
-		218, 219, 219, 219, 219, 219, 219, 219,
-		219, 219, 219, 220, 220, 220, 220, 220,
-		220, 220, 220, 220, 220, 221, 221, 221,
-		221, 221, 221, 221, 221, 221, 221, 221,
-		222, 222, 222, 222, 222, 222, 222, 222,
-		222, 222, 223, 223, 223, 223, 223, 223,
-		223, 223, 223, 223, 223, 224, 224, 224,
-		224, 224, 224, 224, 224, 224, 224, 224,
-		225, 225, 225, 225, 225, 225, 225, 225,
-		225, 225, 225, 226, 226, 226, 226, 226,
-		226, 226, 226, 226, 226, 226, 226, 227,
-		227, 227, 227, 227, 227, 227, 227, 227,
-		227, 227, 228, 228, 228, 228, 228, 228,
-		228, 228, 228, 228, 228, 228, 229, 229,
-		229, 229, 229, 229, 229, 229, 229, 229,
-		229, 229, 230, 230, 230, 230, 230, 230,
-		230, 230, 230, 230, 230, 230, 231, 231,
-		231, 231, 231, 231, 231, 231, 231, 231,
-		231, 231, 231, 232, 232, 232, 232, 232,
-		232, 232, 232, 232, 232, 232, 232, 233,
-		233, 233, 233, 233, 233, 233, 233, 233,
-		233, 233, 233, 233, 234, 234, 234, 234,
-		234, 234, 234, 234, 234, 234, 234, 234,
-		234, 235, 235, 235, 235, 235, 235, 235,
-		235, 235, 235, 235, 235, 235, 236, 236,
-		236, 236, 236, 236, 236, 236, 236, 236,
-		236, 236, 236, 236, 237, 237, 237, 237,
-		237, 237, 237, 237, 237, 237, 237, 237,
-		237, 237, 238, 238, 238, 238, 238, 238,
-		238, 238, 238, 238, 238, 238, 238, 238,
-		239, 239, 239, 239, 239, 239, 239, 239,
-		239, 239, 239, 239, 239, 239, 240, 240,
-		240, 240, 240, 240, 240, 240, 240, 240,
-		240, 240, 240, 240, 241, 241, 241, 241,
-		241, 241, 241, 241, 241, 241, 241, 241,
-		241, 241, 241, 242, 242, 242, 242, 242,
-		242, 242, 242, 242, 242, 242, 242, 242,
-		242, 242, 243, 243, 243, 243, 243, 243,
-		243, 243, 243, 243, 243, 243, 243, 243,
-		243, 244, 244, 244, 244, 244, 244, 244,
-		244, 244, 244, 244, 244, 244, 244, 244,
-		245, 245, 245, 245, 245, 245, 245, 245,
-		245, 245, 245, 245, 245, 245, 245, 246,
-		246, 246, 246, 246, 246, 246, 246, 246,
-		246, 246, 246, 246, 246, 246, 246, 247,
-		247, 247, 247, 247, 247, 247, 247, 247,
-		247, 247, 247, 247, 247, 247, 247, 248,
-		248, 248, 248, 248, 248, 248, 248, 248,
-		248, 248, 248, 248, 248, 248, 248, 249,
-		249, 249, 249, 249, 249, 249, 249, 249,
-		249, 249, 249, 249, 249, 249, 249, 250,
-		250, 250, 250, 250, 250, 250, 250, 250,
-		250, 250, 250, 250, 250, 250, 250, 251,
-		251, 251, 251, 251, 251, 251, 251, 251,
-		251, 251, 251, 251, 251, 251, 251, 252,
-		252, 252, 252, 252, 252, 252, 252, 252,
-		252, 252, 252, 252, 252, 252, 252, 253,
-		253, 253, 253, 253, 253, 253, 253, 253,
-		253, 253, 253, 253, 253, 253, 253, 253,
-		254, 254, 254, 254, 254, 254, 254, 254,
-		254, 254, 254, 254, 254, 254, 254, 254,
-		255, 255, 255, 255, 255, 255, 255, 255 }
-};
-
-static const struct sh_css_ctc_table default_ctc_table = {
-		{ 0, 0, 256, 384, 384, 497, 765, 806,
-		837, 851, 888, 901, 957, 981, 993, 1001,
-		1011, 1029, 1028, 1039, 1062, 1059, 1073, 1080,
-		1083, 1085, 1085, 1098, 1080, 1084, 1085, 1093,
-		1078, 1073, 1070, 1069, 1077, 1066, 1072, 1063,
-		1053, 1044, 1046, 1053, 1039, 1028, 1025, 1024,
-		1012, 1013, 1016, 996, 992, 990, 990, 980,
-		969, 968, 961, 955, 951, 949, 933, 930,
-		929, 925, 921, 916, 906, 901, 895, 893,
-		886, 877, 872, 869, 866, 861, 857, 849,
-		845, 838, 836, 832, 823, 821, 815, 813,
-		809, 805, 796, 793, 790, 785, 784, 778,
-		772, 768, 766, 763, 758, 752, 749, 745,
-		741, 740, 736, 730, 726, 724, 723, 718,
-		711, 709, 706, 704, 701, 698, 691, 689,
-		688, 683, 683, 678, 675, 673, 671, 669,
-		666, 663, 661, 660, 656, 656, 653, 650,
-		648, 647, 646, 643, 639, 638, 637, 635,
-		633, 632, 629, 627, 626, 625, 622, 621,
-		618, 618, 614, 614, 612, 609, 606, 606,
-		603, 600, 600, 597, 594, 591, 590, 586,
-		582, 581, 578, 575, 572, 569, 563, 560,
-		557, 554, 551, 548, 545, 539, 536, 533,
-		529, 527, 524, 519, 516, 513, 510, 507,
-		504, 501, 498, 493, 491, 488, 485, 484,
-		480, 476, 474, 471, 467, 466, 464, 460,
-		459, 455, 453, 449, 447, 446, 443, 441,
-		438, 435, 432, 432, 429, 427, 426, 422,
-		419, 418, 416, 414, 412, 410, 408, 406,
-		404, 402, 401, 398, 397, 395, 393, 390,
-		389, 388, 387, 384, 382, 380, 378, 377,
-		376, 375, 372, 370, 368, 368, 366, 364,
-		363, 361, 360, 358, 357, 355, 354, 352,
-		351, 350, 349, 346, 345, 344, 344, 342,
-		340, 339, 337, 337, 336, 335, 333, 331,
-		330, 329, 328, 326, 326, 324, 324, 322,
-		321, 320, 318, 318, 318, 317, 315, 313,
-		312, 311, 311, 310, 308, 307, 306, 306,
-		304, 304, 302, 301, 300, 300, 299, 297,
-		297, 296, 296, 294, 294, 292, 291, 291,
-		291, 290, 288, 287, 286, 286, 287, 285,
-		284, 283, 282, 282, 281, 281, 279, 278,
-		278, 278, 276, 276, 275, 274, 274, 273,
-		271, 270, 269, 268, 268, 267, 265, 262,
-		261, 260, 260, 259, 257, 254, 252, 252,
-		251, 251, 249, 246, 245, 244, 243, 242,
-		240, 239, 239, 237, 235, 235, 233, 231,
-		232, 230, 229, 226, 225, 224, 225, 224,
-		223, 220, 219, 219, 218, 217, 217, 214,
-		213, 213, 212, 211, 209, 209, 209, 208,
-		206, 205, 204, 203, 204, 203, 201, 200,
-		199, 197, 198, 198, 197, 195, 194, 194,
-		193, 192, 192, 191, 189, 190, 189, 188,
-		186, 187, 186, 185, 185, 184, 183, 181,
-		183, 182, 181, 180, 179, 178, 178, 178,
-		177, 176, 175, 176, 175, 174, 174, 173,
-		172, 173, 172, 171, 170, 170, 169, 169,
-		169, 168, 167, 166, 167, 167, 166, 165,
-		164, 164, 164, 163, 164, 163, 162, 163,
-		162, 161, 160, 161, 160, 160, 160, 159,
-		158, 157, 158, 158, 157, 157, 156, 156,
-		156, 156, 155, 155, 154, 154, 154, 154,
-		154, 153, 152, 153, 152, 152, 151, 152,
-		151, 152, 151, 150, 150, 149, 149, 150,
-		149, 149, 148, 148, 148, 149, 148, 147,
-		146, 146, 147, 146, 147, 146, 145, 146,
-		146, 145, 144, 145, 144, 145, 144, 144,
-		143, 143, 143, 144, 143, 142, 142, 142,
-		142, 142, 142, 141, 141, 141, 141, 140,
-		140, 141, 140, 140, 141, 140, 139, 139,
-		139, 140, 139, 139, 138, 138, 137, 139,
-		138, 138, 138, 137, 138, 137, 137, 137,
-		137, 136, 137, 136, 136, 136, 136, 135,
-		136, 135, 135, 135, 135, 136, 135, 135,
-		134, 134, 133, 135, 134, 134, 134, 133,
-		134, 133, 134, 133, 133, 132, 133, 133,
-		132, 133, 132, 132, 132, 132, 131, 131,
-		131, 132, 131, 131, 130, 131, 130, 132,
-		131, 130, 130, 129, 130, 129, 130, 129,
-		129, 129, 130, 129, 128, 128, 128, 128,
-		129, 128, 128, 127, 127, 128, 128, 127,
-		127, 126, 126, 127, 127, 126, 126, 126,
-		127, 126, 126, 126, 125, 125, 126, 125,
-		125, 124, 124, 124, 125, 125, 124, 124,
-		123, 124, 124, 123, 123, 122, 122, 122,
-		122, 122, 121, 120, 120, 119, 118, 118,
-		118, 117, 117, 116, 115, 115, 115, 114,
-		114, 113, 113, 112, 111, 111, 111, 110,
-		110, 109, 109, 108, 108, 108, 107, 107,
-		106, 106, 105, 105, 105, 104, 104, 103,
-		103, 102, 102, 102, 102, 101, 101, 100,
-		100, 99, 99, 99, 99, 99, 99, 98,
-		97, 98, 97, 97, 97, 96, 96, 95,
-		96, 95, 96, 95, 95, 94, 94, 95,
-		94, 94, 94, 93, 93, 92, 93, 93,
-		93, 93, 92, 92, 91, 92, 92, 92,
-		91, 91, 90, 90, 91, 91, 91, 90,
-		90, 90, 90, 91, 90, 90, 90, 89,
-		89, 89, 90, 89, 89, 89, 89, 89,
-		88, 89, 89, 88, 88, 88, 88, 87,
-		89, 88, 88, 88, 88, 88, 87, 88,
-		88, 88, 87, 87, 87, 87, 87, 88,
-		87, 87, 87, 87, 87, 87, 88, 87,
-		87, 87, 87, 86, 86, 87, 87, 87,
-		87, 86, 86, 86, 87, 87, 86, 87,
-		86, 86, 86, 87, 87, 86, 86, 86,
-		86, 86, 87, 87, 86, 85, 85, 85,
-		84, 85, 85, 84, 84, 83, 83, 82,
-		82, 82, 81, 81, 80, 79, 79, 79,
-		78, 77, 77, 76, 76, 76, 75, 74,
-		74, 74, 73, 73, 72, 71, 71, 71,
-		70, 70, 69, 69, 68, 68, 67, 67,
-		67, 66, 66, 65, 65, 64, 64, 63,
-		62, 62, 62, 61, 60, 60, 59, 59,
-		58, 58, 57, 57, 56, 56, 56, 55,
-		55, 54, 55, 55, 54, 53, 53, 52,
-		53, 53, 52, 51, 51, 50, 51, 50,
-		49, 49, 50, 49, 49, 48, 48, 47,
-		47, 48, 46, 45, 45, 45, 46, 45,
-		45, 44, 45, 45, 45, 43, 42, 42,
-		41, 43, 41, 40, 40, 39, 40, 41,
-		39, 39, 39, 39, 39, 38, 35, 35,
-		34, 37, 36, 34, 33, 33, 33, 35,
-		34, 32, 32, 31, 32, 30, 29, 26,
-		25, 25, 27, 26, 23, 23, 23, 25,
-		24, 24, 22, 21, 20, 19, 16, 14,
-		13, 13, 13, 10, 9, 7, 7, 7,
-		12, 12, 12, 7, 0, 0, 0, 0 }
-};
-
-static const struct sh_css_rgb_gamma_table default_r_gamma_table = {
-{  0,   72,  144,  216,  288,  360,  426,  486,
- 541,  592,  641,  687,  730,  772,  812,  850,
- 887,  923,  958,  991, 1024, 1055, 1086, 1117,
-1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
-1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
-1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
-1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
-1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
-2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
-2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
-2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
-2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
-2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
-2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
-2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
-2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
-2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
-2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
-3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
-3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
-3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
-3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
-3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
-3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
-3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
-3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
-3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
-3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
-3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
-3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
-3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
-4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088 }
-};
-
-static const struct sh_css_rgb_gamma_table default_g_gamma_table = {
-{  0,   72,  144,  216,  288,  360,  426,  486,
- 541,  592,  641,  687,  730,  772,  812,  850,
- 887,  923,  958,  991, 1024, 1055, 1086, 1117,
-1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
-1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
-1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
-1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
-1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
-2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
-2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
-2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
-2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
-2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
-2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
-2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
-2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
-2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
-2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
-3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
-3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
-3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
-3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
-3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
-3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
-3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
-3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
-3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
-3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
-3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
-3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
-3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
-4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088 }
-};
-
-static const struct sh_css_rgb_gamma_table default_b_gamma_table = {
-{  0,   72,  144,  216,  288,  360,  426,  486,
- 541,  592,  641,  687,  730,  772,  812,  850,
- 887,  923,  958,  991, 1024, 1055, 1086, 1117,
-1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
-1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
-1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
-1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
-1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
-2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
-2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
-2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
-2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
-2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
-2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
-2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
-2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
-2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
-2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
-3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
-3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
-3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
-3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
-3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
-3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
-3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
-3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
-3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
-3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
-3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
-3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
-3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
-4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088 }
-};
-
-static const struct sh_css_xnr_table default_xnr_table = {
-  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
-  { 8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
-    546>>1, 512>>1,
-
-  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
-  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
-    256>>1,
-
-  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
-  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
-    170>>1,
-
-  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
-  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1 }
-};
-
-#else
-#error "sh_css_params.c: VAMEM version must \
-	be one of {VAMEM_VERSION_1, VAMEM_VERSION_2}"
-#endif
-
-/* multiple axis color correction table,
- * 64values = 2x2matrix for 16area, [s2.11].
- */
-static const struct sh_css_macc_table default_macc_table = {
-		{ 8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192,
-		8192, 0, 0, 8192, 8192, 0, 0, 8192 }
-};
-
-/* Digital Zoom lookup table. See documentation for more details about the
- * contents of this table.
- */
-#if defined(HAS_GDC_VERSION_2)
-static const int zoom_table[4][HRT_GDC_N] = {
-		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
-		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
-		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
-		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
-		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
-		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4},
-		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
-		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
-		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
-		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
-		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
-		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
-		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
-		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
-		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
-		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
-		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
-		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
-		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
-		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
-		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
-		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
-		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
-		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
-		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
-		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
-		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
-		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
-		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
-		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
-		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
-		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
-		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
-		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
-		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
-		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
-		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
-		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
-		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
-		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
-		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
-		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
-		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
-		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
-		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
-		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
-		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
-		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
-		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
-		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
-		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
-		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
-		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
-		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
-		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
-		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
-		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
-		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
-		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
-		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
-		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
-		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
-		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
-		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
-		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
-		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
-		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
-		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
-		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
-		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
-		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
-		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
-		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
-		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
-		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
-		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
-		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
-		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
-		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
-		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
-		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
-		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
-		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
-		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
-		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
-		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
-		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
-		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
-		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
-		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
-		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
-		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
-		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
-		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
-		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
-		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
-		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
-		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
-		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
-		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
-		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
-		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
-		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
-		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
-		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
-		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
-		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
-		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
-		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
-		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
-		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
-		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
-		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
-		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
-		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
-		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
-		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
-		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
-		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
-		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
-		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
-		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
-		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
-		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
-		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
-		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
-		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
-		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4},
-		{256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
-		 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
-		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
-		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
-		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
-		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
-		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
-		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
-		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
-		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
-		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
-		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
-		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
-		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
-		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
-		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
-		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
-		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
-		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
-		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
-		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
-		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
-		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
-		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
-		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
-		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
-		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
-		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
-		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
-		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
-		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
-		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
-		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
-		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
-		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
-		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
-		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
-		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
-		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
-		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
-		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
-		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
-		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
-		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
-		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
-		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
-		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
-		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
-		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
-		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
-		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
-		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
-		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
-		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
-		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
-		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
-		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
-		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
-		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
-		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
-		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
-		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
-		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
-		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
-		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
-		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
-		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
-		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
-		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
-		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
-		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
-		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
-		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
-		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
-		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
-		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
-		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
-		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
-		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
-		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
-		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
-		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
-		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
-		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
-		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
-		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
-		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
-		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
-		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
-		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
-		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
-		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
-		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
-		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
-		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
-		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
-		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
-		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
-		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
-		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
-		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
-		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
-		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
-		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
-		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
-		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
-		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
-		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
-		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
-		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
-		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
-		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
-		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
-		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
-		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
-		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
-		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
-		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
-		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
-		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
-		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
-		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
-		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
-		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
-		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4},
-		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
-		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
-		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
-		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4}
-};
-#elif defined(HAS_GDC_VERSION_1)
-static const int zoom_table[4][HRT_GDC_N] = {
-	{0, 0, 0, 0, 0, 0, -1, -1,
-	 -1, -2, -2, -3, -3, -4, -4, -5,
-	 -6, -6, -7, -7, -8, -9, -9, -10,
-	 -11, -11, -12, -13, -13, -14, -14, -15,
-	 -16, -16, -16, -17, -17, -18, -18, -18,
-	 -18, -18, -18, -18, -18, -18, -18, -18,
-	 -18, -17, -17, -16, -15, -15, -14, -13,
-	 -12, -11, -9, -8, -7, -5, -3, -1},
-	{0, 2, 4, 7, 9, 12, 16, 19,
-	 23, 27, 31, 35, 39, 43, 48, 53,
-	 58, 62, 67, 73, 78, 83, 88, 94,
-	 99, 105, 110, 116, 121, 127, 132, 138,
-	 144, 149, 154, 160, 165, 170, 176, 181,
-	 186, 191, 195, 200, 205, 209, 213, 218,
-	 222, 225, 229, 232, 236, 239, 241, 244,
-	 246, 248, 250, 252, 253, 254, 255, 255},
-	{256, 255, 255, 254, 253, 252, 250, 248,
-	 246, 244, 241, 239, 236, 232, 229, 225,
-	 222, 218, 213, 209, 205, 200, 195, 191,
-	 186, 181, 176, 170, 165, 160, 154, 149,
-	 144, 138, 132, 127, 121, 116, 110, 105,
-	 99, 94, 88, 83, 78, 73, 67, 62,
-	 58, 53, 48, 43, 39, 35, 31, 27,
-	 23, 19, 16, 12, 9, 7, 4, 2},
-	{0, -1, -3, -5, -6, -8, -9, -10,
-	 -12, -13, -14, -15, -16, -15, -17, -17,
-	 -18, -18, -17, -19, -19, -18, -18, -19,
-	 -18, -19, -18, -17, -17, -17, -16, -16,
-	 -16, -15, -14, -14, -13, -12, -12, -12,
-	 -11, -11, -9, -9, -9, -8, -6, -6,
-	 -6, -5, -4, -3, -4, -3, -2, -2,
-	 -1, 0, -1, 0, 1, 0, 0, 0}
-};
-#else
-#error "sh_css_params.c: GDC version must be \
-	one of {GDC_VERSION_1, GDC_VERSION_2}"
-#endif
-
-static const struct sh_css_3a_config default_3a_config = {
-	25559,
-	32768,
-	7209,
-	65535,
-	0,
-	65535,
-	{-3344, -6104, -19143, 19143, 6104, 3344, 0},
-	{1027, 0, -9219, 16384, -9219, 1027, 0}
-};
-
-static const struct sh_css_3a_config disabled_3a_config = {
-	25559,
-	32768,
-	7209,
-	65535,
-	0,
-	65535,
-	{-6689, -12207, -32768, 32767, 12207, 6689, 0},
-	{2053, 0, -18437, 32767, -18437, 2053, 0}
-};
-
-static const struct sh_css_wb_config default_wb_config = {
-	1,
-	32768,
-	32768,
-	32768,
-	32768
-};
-
-static const struct sh_css_wb_config disabled_wb_config = {
-	1,
-	32768,
-	32768,
-	32768,
-	32768
-};
-
-static const struct sh_css_cc_config default_cc_config = {
-	8,
-	{255, 29, 120, 0, -374, -342, 0, -672, 301},
-};
-
-static const struct sh_css_cc_config disabled_cc_config = {
-	8,
-	{256, 44, 47, 0, -169, -171, 0, -214, 148},
-};
-
-static const struct sh_css_tnr_config default_tnr_config = {
-	32768,
-	32,
-	32,
-};
-
-static const struct sh_css_tnr_config disabled_tnr_config = {
-	0,
-	0,
-	0,
-};
-
-static const struct sh_css_ob_config default_ob_config = {
-	sh_css_ob_mode_none,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0
-};
-
-static const struct sh_css_ob_config disabled_ob_config = {
-	sh_css_ob_mode_none,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0
-};
-
-static const struct sh_css_dp_config default_dp_config = {
-	8192,
-	2048
-};
-
-static const struct sh_css_dp_config disabled_dp_config = {
-	65535,
-	65535
-};
-
-static const struct sh_css_nr_config default_nr_config = {
-	16384,
-	8192,
-	1280,
-	0,
-	0
-};
-
-static const struct sh_css_nr_config disabled_nr_config = {
-	0,
-	0,
-	0,
-	0,
-	0
-};
-
-static const struct sh_css_ee_config default_ee_config = {
-	8192,
-	128,
-	2048
-};
-
-static const struct sh_css_ee_config disabled_ee_config = {
-	0,
-	0,
-	0
-};
-
-static const struct sh_css_de_config default_de_config = {
-	0,
-	0,
-	0
-};
-
-static const struct sh_css_de_config disabled_de_config = {
-	65535,
-	0,
-	0
-};
-
-static const struct sh_css_gc_config default_gc_config = {
-	0,
-	0
-};
-
-static const struct sh_css_gc_config disabled_gc_config = {
-	0,
-	0
-};
-
-static const struct sh_css_anr_config default_anr_config = {
-	10,
-};
-
-static const struct sh_css_ce_config default_ce_config = {
-	0,
-	255
-};
-
-static const struct sh_css_zoom default_zoom_config = {
-	HRT_GDC_N,
-	HRT_GDC_N
-};
-
-static const struct sh_css_vector default_motion_config = {
-	0,
-	0
-};
-
-static const struct sh_css_ecd_config default_ecd_config = {
-	(1 << (ISP_VEC_ELEMBITS - 1)) * 2 / 3,	/* 2/3 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1.0 */
-	0,					/* 0.0 */
-};
-
-static const struct sh_css_ecd_config disabled_ecd_config = {
-	0,	/* 0.0 */
-	0,	/* 0.0 */
-	0,	/* 0.0 */
-};
-
-static const struct sh_css_ynr_config default_ynr_config = {
-	0,
-	0,
-	0,
-	0,
-};
-
-static const struct sh_css_ynr_config disabled_ynr_config = {
-	0,
-	0,
-	0,
-	0,
-};
-
-static const struct sh_css_fc_config default_fc_config = {
-	1,
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
-	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
-	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
-};
-
-static const struct sh_css_fc_config disabled_fc_config = {
-	1,
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
-	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
-	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
-	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
-};
-
-static const struct sh_css_cnr_config default_cnr_config = {
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0
-};
-
-static const struct sh_css_cnr_config disabled_cnr_config = {
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0,
-	0
-};
-
-static const struct sh_css_macc_config default_macc_config = {
-	0,
-};
-
-static const struct sh_css_macc_config disabled_macc_config = {
-	0,
-};
-
-static const struct sh_css_ctc_config default_ctc_config = {
-	((1 << SH_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << SH_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << SH_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << SH_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << SH_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	((1 << SH_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
-	1,
-	SH_CSS_BAYER_MAXVAL / 5,	/* To be implemented */
-	SH_CSS_BAYER_MAXVAL * 2 / 5,	/* To be implemented */
-	SH_CSS_BAYER_MAXVAL * 3 / 5,	/* To be implemented */
-	SH_CSS_BAYER_MAXVAL * 4 / 5,	/* To be implemented */
-};
-
-#if SH_CSS_ISP_PARAMS_VERSION == 1
-static const struct sh_css_aa_config default_aa_config = {
-	8140,
-};
-#elif SH_CSS_ISP_PARAMS_VERSION == 2
-static const struct sh_css_aa_config default_aa_config = {
-	8191,
-};
-#else
-#error "sh_css_params.c: PARAMS_VERSION must be one of {1,2}"
-#endif
-
-static const struct sh_css_xnr_config default_xnr_config = {
-	25
-};
-
-static const struct sh_css_yuv2rgb_cc_config
-default_yuv2rgb_cc_config = {
-	/* Bits of fractional part = SH_CSS_YUV2RGB_CCM_COEF_SHIFT = 12 */
-	{4096, -4096, 4096, 4096, 4096, 0, 4096, -4096, -4096}
-};
-
-static const struct sh_css_yuv2rgb_cc_config
-disabled_yuv2rgb_cc_config = {
-	/* Bits of fractional part = SH_CSS_YUV2RGB_CCM_COEF_SHIFT = 12 */
-	{4096, -4096, 4096, 4096, 4096, 0, 4096, -4096, -4096}
-};
-
-static const struct sh_css_rgb2yuv_cc_config
-default_rgb2yuv_cc_config = {
-	/* Bits of fractional part = SH_CSS_RGB2YUV_CSC_COEF_SHIFT = 13 */
-	{2449, 4809, 934, -1382, -2714, 4096, 4096, -3430, -666}
-};
-
-static const struct sh_css_rgb2yuv_cc_config
-disabled_rgb2yuv_cc_config = {
-	/* Bits of fractional part = SH_CSS_RGB2YUV_CSC_COEF_SHIFT = 13s */
-	{2449, 4809, 934, -1382, -2714, 4096, 4096, -3430, -666}
-};
-
-
-static void
-sh_css_dequeue_param_buffers(void);
-
-static enum sh_css_err
-ref_sh_css_ddr_address_map(
-		struct sh_css_ddr_address_map *map,
-		struct sh_css_ddr_address_map *out);
-
-static enum sh_css_err
-write_sh_css_address_map_to_ddr(
-		struct sh_css_ddr_address_map *map,
-		hrt_vaddress *out);
-
-static enum sh_css_err
-free_sh_css_ddr_address_map(hrt_vaddress ptr);
-
-static enum sh_css_err
-sh_css_params_write_to_ddr_internal(
-		const struct sh_css_binary *binary,
-		struct sh_css_ddr_address_map *ddr_map,
-		struct sh_css_ddr_address_map_size *ddr_map_size);
-
-int sh_css_get_gdc_coord_one(void)
-{
-#if defined(HAS_GDC_VERSION_2)
-/*
- * MW: We don't want to store the coordinates
- * full range in memory: Truncate
- */
-	return gdc_get_unity(GDC0_ID)/HRT_GDC_COORD_SCALE;
-#elif defined(HAS_GDC_VERSION_1)
-	return gdc_get_unity(GDC0_ID);
-#else
-#error "sh_css_params.c: GDC version must be \
-	one of {GDC_VERSION_1, GDC_VERSION_2}"
-#endif
-}
-
-void
-sh_css_set_dis_coefficients(
-	const short *horizontal_coefficients,
-	const short *vertical_coefficients)
-{
-/* input can be NULL */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_dis_coefficients() enter: hcoef=%p, vcoef=%p",
-		horizontal_coefficients,vertical_coefficients);
-	dis_hor_coef_tbl = horizontal_coefficients;
-	dis_ver_coef_tbl = vertical_coefficients;
-	dis_coef_table_changed = true;
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_dis_coefficients() leave: void\n");
-}
-
-#ifdef __KERNEL__
-/* This is the optimized code that uses the aligned_width and aligned_height
- * for the projections. This should be enabled in the same patch set that
- * adds the correct handling of these strides to the DIS IA code.
- */
-void
-sh_css_get_dis_projections(
-	int *horizontal_projections,
-	int *vertical_projections,
-	struct sh_css_dis_data *dis_data)
-{
-	unsigned int hor_num_isp, ver_num_isp,
-		hor_bytes, ver_bytes;
-	hrt_vaddress hor_ptr_isp, ver_ptr_isp;
-
-	assert(dis_data != NULL);
-	if(dis_data == NULL)
-		return;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dis_projections() enter: "
-		"hcoef=%p, vcoef=%p, haddr=%x, vaddr=%x\n",
-		horizontal_projections,vertical_projections,
-		dis_data->sdis_hor_proj,dis_data->sdis_ver_proj);
-
-	assert(horizontal_projections != NULL);
-	if(horizontal_projections == NULL)
-		return;
-
-	assert(vertical_projections != NULL);
-	if(vertical_projections == NULL)
-		return;
-
-	assert(dis_data->sdis_hor_proj != mmgr_NULL);
-	assert(dis_data->sdis_hor_proj != mmgr_NULL);
-
-	hor_ptr_isp = dis_data->sdis_hor_proj;
-	ver_ptr_isp = dis_data->sdis_ver_proj;
-
-	if (current_3a_binary == NULL) {
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_get_dis_projections() leave: void\n");
-		return;
-	}
-
-	hor_num_isp = current_3a_binary->dis_hor_proj_num_isp;
-	ver_num_isp = current_3a_binary->dis_ver_proj_num_isp;
-
-	hor_bytes = hor_num_isp * sizeof(*horizontal_projections) *
-		SH_CSS_DIS_NUM_COEF_TYPES;
-	ver_bytes = ver_num_isp * sizeof(*vertical_projections) *
-		SH_CSS_DIS_NUM_COEF_TYPES;
-
-	mmgr_load(hor_ptr_isp,
-		horizontal_projections, hor_bytes);
-	mmgr_load(ver_ptr_isp,
-		vertical_projections, ver_bytes);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dis_projections() leave: void\n");
-}
-#else
-void
-sh_css_get_dis_projections(
-	int *horizontal_projections,
-	int *vertical_projections,
-	struct sh_css_dis_data *dis_data)
-{
-	unsigned int hor_num_isp, ver_num_isp,
-		     hor_num_3a, ver_num_3a, i;
-	int *hor_ptr_3a  = horizontal_projections,
-		*ver_ptr_3a  = vertical_projections;
-	hrt_vaddress hor_ptr_isp, ver_ptr_isp;
-
-	assert(dis_data != NULL);
-	if(dis_data == NULL)
-		return;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dis_projections() enter: "
-		"hcoef=%p, vcoef=%p, "
-		"haddr=%x, vaddr=%x\n",
-		horizontal_projections,vertical_projections,
-		dis_data->sdis_hor_proj,dis_data->sdis_ver_proj);
-
-	hor_ptr_isp = dis_data->sdis_hor_proj;
-	ver_ptr_isp = dis_data->sdis_ver_proj;
-
-	assert(horizontal_projections != NULL);
-	if(horizontal_projections == NULL)
-		return;
-
-	assert(vertical_projections != NULL);
-	if(vertical_projections == NULL)
-		return;
-
-	assert(dis_data->sdis_hor_proj != mmgr_NULL);
-	assert(dis_data->sdis_hor_proj != mmgr_NULL);
-
-	if (current_3a_binary == NULL) {
-		sh_css_dtrace(SH_DBG_TRACE,
-			"sh_css_get_dis_projections() leave: return_void\n");
-		return;
-	}
-
-	hor_num_isp = current_3a_binary->dis_hor_proj_num_isp;
-	ver_num_isp = current_3a_binary->dis_ver_proj_num_isp;
-	hor_num_3a  = current_3a_binary->dis_hor_proj_num_3a;
-	ver_num_3a  = current_3a_binary->dis_ver_proj_num_3a;
-
-	for (i = 0; i < SH_CSS_DIS_NUM_COEF_TYPES; i++) {
-		mmgr_load(hor_ptr_isp,
-			hor_ptr_3a, hor_num_3a * sizeof(int));
-		hor_ptr_isp += hor_num_isp * sizeof(int);
-		hor_ptr_3a  += hor_num_3a;
-
-		mmgr_load(ver_ptr_isp,
-			ver_ptr_3a, ver_num_3a * sizeof(int));
-		ver_ptr_isp += ver_num_isp * sizeof(int);
-		ver_ptr_3a  += ver_num_3a;
-	}
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_dis_projections() leave: return_void\n");
-}
-#endif
-
-static void get_3a_stats_from_dmem(
-	struct sh_css_3a_output *output, hrt_vaddress ddr_ptr)
-{
-	int ddr_width  = current_3a_binary->s3atbl_isp_width,
-		out_width  = current_3a_binary->s3atbl_width,
-		out_height = current_3a_binary->s3atbl_height, i;
-	struct sh_css_3a_output *out_ptr = output;
-
-	assert(output != NULL);
-	if(output == NULL)
-		return;
-
-	assert(ddr_ptr != mmgr_NULL);
-
-	for (i = 0; i < out_height; i++) {
-		mmgr_load(ddr_ptr,
-			out_ptr, out_width * sizeof(struct sh_css_3a_output));
-		ddr_ptr += ddr_width * sizeof(struct sh_css_3a_output);
-		out_ptr += out_width;
-	}
-}
-
-static inline int merge_hi14bit_lo14bit(
-	unsigned short hi, unsigned short lo)
-{
-	int val = (int) ((((unsigned int) hi << 14) & 0xfffc000) |
-		((unsigned int) lo & 0x3fff));
-	return val;
-}
-
-static void
-get_3a_stats_from_vmem(
-	struct sh_css_3a_output *output,
-	hrt_vaddress ddr_ptr_hi,
-	hrt_vaddress ddr_ptr_lo)
-{
-	int out_width  = current_3a_binary->s3atbl_width,
-		out_height = current_3a_binary->s3atbl_height;
-	unsigned short *hi, *lo;
-	int chunk, rest, kmax, y, x, k, elm_start, elm, ofs, bytes;
-
-	assert(output != NULL);
-	if(output == NULL)
-		return;
-
-	assert(ddr_ptr_hi != mmgr_NULL);
-	assert(ddr_ptr_lo != mmgr_NULL);
-
-	hi = s3a_tbl_hi_buf;
-	lo = s3a_tbl_lo_buf;
-
-	chunk = (ISP_VEC_NELEMS >> current_3a_binary->deci_factor_log2);
-	chunk = max(chunk, 1);
-	bytes = ISP_S3ATBL_HI_LO_STRIDE_BYTES * out_height;
-
-	mmgr_load(ddr_ptr_hi, hi, bytes);
-	mmgr_load(ddr_ptr_lo, lo, bytes);
-
-	for (y = 0; y < out_height; y++) {
-		elm_start = y * ISP_S3ATBL_HI_LO_STRIDE;
-		rest = out_width;
-		x = 0;
-		while (x < out_width) {
-			kmax = (rest > chunk) ? chunk : rest;
-			ofs = y * out_width + x;
-			elm = elm_start + x * sizeof(*output) / sizeof(int);
-			for (k = 0; k < kmax; k++, elm++) {
-				output[ofs + k].ae_y =
-				    merge_hi14bit_lo14bit
-				    (hi[elm], lo[elm]);
-				output[ofs + k].awb_cnt =
-				    merge_hi14bit_lo14bit
-				    (hi[elm + chunk], lo[elm + chunk]);
-				output[ofs + k].awb_gr =
-				    merge_hi14bit_lo14bit
-				    (hi[elm + chunk * 2],
-				     lo[elm + chunk * 2]);
-				output[ofs + k].awb_r =
-				    merge_hi14bit_lo14bit
-				    (hi[elm + chunk * 3],
-				     lo[elm + chunk * 3]);
-				output[ofs + k].awb_b =
-				    merge_hi14bit_lo14bit
-				    (hi[elm + chunk * 4],
-				     lo[elm + chunk * 4]);
-				output[ofs + k].awb_gb =
-				    merge_hi14bit_lo14bit
-				    (hi[elm + chunk * 5],
-				     lo[elm + chunk * 5]);
-				output[ofs + k].af_hpf1 =
-				    merge_hi14bit_lo14bit
-				    (hi[elm + chunk * 6],
-				     lo[elm + chunk * 6]);
-				output[ofs + k].af_hpf2 =
-				    merge_hi14bit_lo14bit
-				    (hi[elm + chunk * 7],
-				     lo[elm + chunk * 7]);
-			}
-			x += chunk;
-			rest -= chunk;
-		}
-	}
-}
-
-static void
-sh_css_process_3a(void)
-{
-	unsigned int i, raw_bit_depth = 10;
-
-	/* coefficients to calculate Y */
-	isp_parameters.ae_y_coef_r =
-	    uDIGIT_FITTING(s3a_config->ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
-	isp_parameters.ae_y_coef_g =
-	    uDIGIT_FITTING(s3a_config->ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
-	isp_parameters.ae_y_coef_b =
-	    uDIGIT_FITTING(s3a_config->ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);
-
-	/* AWB level gate */
-	if (current_3a_binary)
-		raw_bit_depth
-	    = current_3a_binary->in_frame_info.raw_bit_depth;
-	isp_parameters.awb_lg_high_raw =
-		uDIGIT_FITTING(s3a_config->awb_lg_high_raw, 16, raw_bit_depth);
-	isp_parameters.awb_lg_low =
-		uDIGIT_FITTING(s3a_config->awb_lg_low, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.awb_lg_high =
-		uDIGIT_FITTING(s3a_config->awb_lg_high, 16, SH_CSS_BAYER_BITS);
-
-	/* af fir coefficients */
-	for (i = 0; i < 7; ++i) {
-		isp_parameters.af_fir1[i] =
-		  sDIGIT_FITTING(s3a_config->af_fir1_coef[i], 15,
-				 SH_CSS_AF_FIR_SHIFT);
-		isp_parameters.af_fir2[i] =
-		  sDIGIT_FITTING(s3a_config->af_fir2_coef[i], 15,
-				 SH_CSS_AF_FIR_SHIFT);
-	}
-	isp_params_changed = true;
-	s3a_config_changed = false;
-}
-
-hrt_vaddress
-sh_css_params_ddr_address_map(void)
-{
-	return sp_ddr_ptrs;
-}
-
-/*
- * @GC:
- */
-static void
-convert_coords_to_ispparams(
-	hrt_vaddress ddr_addr,
-	const struct sh_css_dvs_6axis_config *config,
-	unsigned int i_width,
-	unsigned int o_width,
-	unsigned int o_height,
-	unsigned int uv_flag)
-{
-	unsigned int i, j;
-	gdc_warp_param_mem_t s;
-	unsigned int x00, x01, x10, x11,
-		     y00, y01, y10, y11;
-
-	unsigned int xmin, ymin;
-	unsigned int topleft_x, topleft_y,
-		     topleft_x_frac, topleft_y_frac;
-
-	unsigned int blockdim_y = DVS_BLOCKDIM_Y >> uv_flag;
-	unsigned int blockdim_x = DVS_BLOCKDIM_X;
-
-	/* number of blocks per height and width */
-	unsigned int num_blocks_y = o_height / blockdim_y;
-	unsigned int num_blocks_x = o_width / blockdim_x;
-
-	unsigned int in_stride = i_width * DVS_INPUT_BYTES_PER_PIXEL << uv_flag;
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	assert(ddr_addr != mmgr_NULL);
-
-	ddr_addr += (2* DVS_6AXIS_COORDS_ELEMS * uv_flag); /* format is Y0 Y1 UV, so UV starts at 3rd position */
-
-	assert (o_height % blockdim_y == 0);
-	assert (o_width % blockdim_x == 0);
-
-	for (j = 0; j < num_blocks_y; j++) {
-		for (i = 0; i < num_blocks_x; i++) {
-			x00 = config->xcoords[j][i<<uv_flag] >> uv_flag;
-			x01 = config->xcoords[j][(i+1)<<uv_flag] >> uv_flag;
-			x10 = config->xcoords[j+1][i<<uv_flag] >> uv_flag;
-			x11 = config->xcoords[j+1][(i+1)<<uv_flag] >> uv_flag;
-
-			y00 = config->ycoords[j][i<<uv_flag] >> uv_flag;
-			y01 = config->ycoords[j][(i+1)<<uv_flag] >> uv_flag;
-			y10 = config->ycoords[j+1][i<<uv_flag] >> uv_flag;
-			y11 = config->ycoords[j+1][(i+1)<<uv_flag] >> uv_flag;
-
-			/* TODO: Assert that right column's X is greater */
-			xmin = MIN(x00, x10);
-			/* TODO: Assert that bottom row's Y is greater */
-			ymin = MIN(y00, y01);
-
-#if 0
-			/* TODO: Round width to the multiple of bus width */
-			xmax = MAX(x01, x11);
-			ymax = MAX(y10, y11);
-			in_block_width  = xmax - xmin;
-			in_block_height = ymax - ymin;
-#else
-			/*
-			 * For initial testing, we are using constant input
-			 * block size
-			 * */
-			s.in_block_width  = 128;
-			s.in_block_height = 96 >> uv_flag;
-#endif
-
-			topleft_y = ymin >> DVS_COORD_FRAC_BITS;
-			topleft_x = ((xmin >> DVS_COORD_FRAC_BITS)
-					>> XMEM_ALIGN_LOG2)
-					<< (XMEM_ALIGN_LOG2);
-
-			s.in_addr_offset = topleft_y * in_stride + topleft_x;
-
-			topleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);
-			topleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);
-
-			s.p0_x = x00 - topleft_x_frac;
-			s.p1_x = x01 - topleft_x_frac;
-			s.p2_x = x10 - topleft_x_frac;
-			s.p3_x = x11 - topleft_x_frac;
-
-			s.p0_y = y00 - topleft_y_frac;
-			s.p1_y = y01 - topleft_y_frac;
-			s.p2_y = y10 - topleft_y_frac;
-			s.p3_y = y11 - topleft_y_frac;
-#if 0
-			printf("j: %d\ti:%d\n", j, i);
-			printf("offset: %d\n", s.in_addr_offset);
-			printf("relative_x[0]: %d\n", s.relative_x[0]);
-			printf("relative_x[1]: %d\n", s.relative_x[1]);
-			printf("relative_x[2]: %d\n", s.relative_x[2]);
-			printf("relative_x[3]: %d\n", s.relative_x[3]);
-			printf("relative_y[0]: %d\n", s.relative_y[0]);
-			printf("relative_y[1]: %d\n", s.relative_y[1]);
-			printf("relative_y[2]: %d\n", s.relative_y[2]);
-			printf("relative_y[3]: %d\n", s.relative_y[3]);
-			printf("relative_x_nofrac[0]: %d\n", s.relative_x[0]>>DVS_COORD_FRAC_BITS);
-			printf("relative_x_nofrac[1]: %d\n", s.relative_x[1]>>DVS_COORD_FRAC_BITS);
-			printf("relative_x_nofrac[2]: %d\n", s.relative_x[2]>>DVS_COORD_FRAC_BITS);
-			printf("relative_x_nofrac[3]: %d\n", s.relative_x[3]>>DVS_COORD_FRAC_BITS);
-			printf("relative_y_nofrac[0]: %d\n", s.relative_y[0]>>DVS_COORD_FRAC_BITS);
-			printf("relative_y_nofrac[1]: %d\n", s.relative_y[1]>>DVS_COORD_FRAC_BITS);
-			printf("relative_y_nofrac[2]: %d\n", s.relative_y[2]>>DVS_COORD_FRAC_BITS);
-			printf("relative_y_nofrac[3]: %d\n", s.relative_y[3]>>DVS_COORD_FRAC_BITS);
-			printf("\n");
-#endif
-
-			/* HMM STORE the struct "s" */
-			mmgr_store(ddr_addr,
-				   (void *)(&s),
-				   sizeof(gdc_warp_param_mem_t));
-
-			// storage format:
-			// Y0 Y1 UV0 Y2 Y3 UV1
-			if (uv_flag) {
-				ddr_addr += DVS_6AXIS_COORDS_ELEMS * 3;
-		}
-			else {
-        ddr_addr += DVS_6AXIS_COORDS_ELEMS * (1 + (i&1)); // increment with 2 incase x is odd, this to skip the uv position.
-	}
-
-}
-	}
-}
-
-static void
-store_dvs_6axis_config(
-	const struct sh_css_binary *binary,
-	hrt_vaddress ddr_addr_y)
-{
-	unsigned int i_width;
-	unsigned int o_width;
-	unsigned int o_height;
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return;
-
-	i_width  = binary->in_frame_info.width;
-	o_width  = binary->out_frame_info.width;
-	o_height = binary->out_frame_info.height;
-
-	assert(ddr_addr_y != mmgr_NULL);
-
-	if (!dvs_6axis_config) {
-/* Checkpatch patch */
-		return;
-	}
-	/* Y plane */
-	convert_coords_to_ispparams(ddr_addr_y, dvs_6axis_config
-					, i_width, o_width, o_height, 0);
-	/* UV plane (packed inside the y plane) */
-	convert_coords_to_ispparams(ddr_addr_y, dvs_6axis_config
-					, i_width/2, o_width/2, o_height/2, 1);
-
-	isp_params_changed = true;
-}
-/* ****************************************************
- * Each coefficient is stored as 7bits to fit 2 of them into one
- * ISP vector element, so we will store 4 coefficents on every
- * memory word (32bits)
- *
- * 0: Coefficient 0 used bits
- * 1: Coefficient 1 used bits
- * 2: Coefficient 2 used bits
- * 3: Coefficient 3 used bit3
- * x: not used
- *
- * xx33333332222222 | xx11111110000000
- *
- * ***************************************************
- */
-static void
-store_fpntbl(hrt_vaddress ptr)
-{
-	unsigned int i, j;
-	short *data_ptr = fpn_table.data;
-
-	assert(ptr != mmgr_NULL);
-
-	for (i = 0; i < fpn_table.height; i++) {
-		for (j = 0;
-		     j < fpn_table.width;
-		     j += 4, ptr += 4, data_ptr += 4) {
-			int data = data_ptr[0] << 0 |
-				   data_ptr[1] << 7 |
-				   data_ptr[2] << 16 |
-				   data_ptr[3] << 23;
-			mmgr_store(ptr, (void *)(&data), sizeof(data));
-		}
-	}
-}
-
-static void
-convert_raw_to_fpn(void)
-{
-	short maxval = 0;
-	unsigned int i;
-
-	/* Find the maximum value in the table */
-	for (i = 0; i < fpn_table.height * fpn_table.width; i++) {
-		short val = fpn_table.data[i];
-		/* Make sure FPN value can be represented in 13-bit unsigned
-		 * number (ISP precision - 1), but note that actual input range
-		 * depends on precision of input frame data.
-		 */
-		if (val < 0) {
-/* Checkpatch patch */
-			val = 0;
-		} else if (val >= (1 << 13)) {
-/* Checkpatch patch */
-/* MW: BUG, is "13" a system or application property */
-			val = (1 << 13) - 1;
-		}
-		maxval = max(maxval, val);
-	}
-	/* Find the lowest shift value to remap the values in the range
-	 * 0..maxval to 0..2^shiftval*63.
-	 */
-	fpn_table.shift = 0;
-	while (maxval > 63) {
-/* MW: BUG, is "63" a system or application property */
-		maxval /= 2;
-		fpn_table.shift++;
-	}
-	/* Adjust the values in the table for the shift value */
-	for (i = 0; i < fpn_table.height * fpn_table.width; i++)
-		((unsigned short *) fpn_table.data)[i] >>= fpn_table.shift;
-}
-
-enum sh_css_err
-sh_css_set_black_frame(
-	const struct sh_css_frame *raw_black_frame)
-{
-	/* this function desperately needs to be moved to the ISP or SP such
-	 * that it can use the DMA.
-	 */
-	unsigned int height,
-		     width,
-		     y, x, k, data = 0;
-	hrt_vaddress ptr;
-
-	assert(raw_black_frame != NULL);
-	if (raw_black_frame == NULL)
-		return sh_css_err_internal_error;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_black_frame() enter: black_frame=%p\n",
-		raw_black_frame);
-
-	height = raw_black_frame->info.height;
-	width = raw_black_frame->info.padded_width;
-	ptr = raw_black_frame->data + raw_black_frame->planes.raw.offset;
-
-	if (fpn_table.data &&
-	    (fpn_table.width != width || fpn_table.height != height)) {
-		sh_css_free(fpn_table.data);
-		fpn_table.data = NULL;
-	}
-	if (fpn_table.data == NULL) {
-		fpn_table.data = sh_css_malloc(height * width * sizeof(short));
-		if (!fpn_table.data) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_black_frame() leave: return_err=%d\n",
-			sh_css_err_cannot_allocate_memory);
-			return sh_css_err_cannot_allocate_memory;
-		}
-		fpn_table.width = width;
-		fpn_table.height = height;
-		fpn_table.shift = 0;
-	}
-
-	/* store raw to fpntbl */
-	for (y = 0; y < height; y++) {
-		for (x = 0; x < width; x += (ISP_VEC_NELEMS * 2)) {
-			int ofs = y * width + x;
-			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
-				mmgr_load(ptr, (void *)(&data), sizeof(int));
-				fpn_table.data[ofs + 2 * k] =
-				    (short) (data & 0xFFFF);
-				fpn_table.data[ofs + 2 * k + 2] =
-				    (short) ((data >> 16) & 0xFFFF);
-	ptr += sizeof(int);	/* byte system address */
-			}
-			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
-				mmgr_load(ptr, (void *)(&data), sizeof(int));
-				fpn_table.data[ofs + 2 * k + 1] =
-				    (short) (data & 0xFFFF);
-				fpn_table.data[ofs + 2 * k + 3] =
-				    (short) ((data >> 16) & 0xFFFF);
-	ptr += sizeof(int);	/* byte system address */
-			}
-		}
-	}
-
-	/* raw -> fpn */
-	convert_raw_to_fpn();
-
-	/* overwrite isp parameter */
-	isp_parameters.fpn_shift = fpn_table.shift;
-	isp_parameters.fpn_enabled = 1;
-	fpn_table_changed = true;
-	isp_params_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_black_frame() leave: return_err=%d\n",
-		sh_css_success);
-
-	return sh_css_success;
-}
-
-bool
-sh_css_params_set_binning_factor(unsigned int binning_fact)
-{
-/* assert(binning_fact > 0); true ?? */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_set_binning_factor() enter:\n");
-
-	if (sensor_binning != binning_fact) {
-		sensor_binning = binning_fact;
-		sh_css_param_shading_table_changed_set(true);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_set_binning_factor() leave:\n");
-
-	return sh_css_param_shading_table_changed_get();
-}
-
-void
-sh_css_params_set_raw_binning(bool needs_raw_binning)
-{
-	raw_binning = needs_raw_binning;
-}
-
-static void
-sh_css_process_wb(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_wb() enter:\n");
-
-	isp_parameters.wb_gain_shift =
-	    uISP_REG_BIT - wb_config->integer_bits;
-	isp_parameters.wb_gain_gr =
-	    uDIGIT_FITTING(wb_config->gr, 16 - wb_config->integer_bits,
-			   isp_parameters.wb_gain_shift);
-	isp_parameters.wb_gain_r =
-	    uDIGIT_FITTING(wb_config->r, 16 - wb_config->integer_bits,
-			   isp_parameters.wb_gain_shift);
-	isp_parameters.wb_gain_b =
-	    uDIGIT_FITTING(wb_config->b, 16 - wb_config->integer_bits,
-			   isp_parameters.wb_gain_shift);
-	isp_parameters.wb_gain_gb =
-	    uDIGIT_FITTING(wb_config->gb, 16 - wb_config->integer_bits,
-			   isp_parameters.wb_gain_shift);
-	isp_params_changed = true;
-	wb_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_wb() leave:\n");
-}
-
-static void
-sh_css_process_cc(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cc() enter:\n");
-
-	isp_parameters.csc_coef_shift    = (int) cc_config->fraction_bits;
-	isp_parameters.yc1c2_to_ycbcr_00 = (int) cc_config->matrix[0];
-	isp_parameters.yc1c2_to_ycbcr_01 = (int) cc_config->matrix[1];
-	isp_parameters.yc1c2_to_ycbcr_02 = (int) cc_config->matrix[2];
-	isp_parameters.yc1c2_to_ycbcr_10 = (int) cc_config->matrix[3];
-	isp_parameters.yc1c2_to_ycbcr_11 = (int) cc_config->matrix[4];
-	isp_parameters.yc1c2_to_ycbcr_12 = (int) cc_config->matrix[5];
-	isp_parameters.yc1c2_to_ycbcr_20 = (int) cc_config->matrix[6];
-	isp_parameters.yc1c2_to_ycbcr_21 = (int) cc_config->matrix[7];
-	isp_parameters.yc1c2_to_ycbcr_22 = (int) cc_config->matrix[8];
-	isp_params_changed = true;
-	cc_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cc() leave:\n");
-}
-
-static void
-sh_css_process_tnr(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_tnr() enter:\n");
-
-	isp_parameters.tnr_coef =
-	    uDIGIT_FITTING(tnr_config->gain, 16, SH_CSS_TNR_COEF_SHIFT);
-	isp_parameters.tnr_threshold_Y =
-	    uDIGIT_FITTING(tnr_config->threshold_y, 16, SH_CSS_ISP_YUV_BITS);
-	isp_parameters.tnr_threshold_C =
-	    uDIGIT_FITTING(tnr_config->threshold_uv, 16, SH_CSS_ISP_YUV_BITS);
-	isp_params_changed = true;
-	tnr_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_tnr() leqave:\n");
-}
-
-static void
-sh_css_process_ob(void)
-{
-	unsigned int raw_bit_depth = 16;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ob() enter:\n");
-
-	switch (ob_config->mode) {
-	case sh_css_ob_mode_fixed:
-		if (current_3a_binary)
-			raw_bit_depth
-			  = current_3a_binary->in_frame_info.raw_bit_depth;
-		isp_parameters.ob_blacklevel_gr
-			= ob_config->level_gr >> (16 - raw_bit_depth);
-		isp_parameters.ob_blacklevel_r
-			= ob_config->level_r  >> (16 - raw_bit_depth);
-		isp_parameters.ob_blacklevel_b
-			= ob_config->level_b  >> (16 - raw_bit_depth);
-		isp_parameters.ob_blacklevel_gb
-			= ob_config->level_gb >> (16 - raw_bit_depth);
-		isp_parameters.obarea_start_bq = 0;
-		isp_parameters.obarea_length_bq = 0;
-		isp_parameters.obarea_length_bq_inverse = 0;
-		break;
-	case sh_css_ob_mode_raster:
-		isp_parameters.ob_blacklevel_gr = 0;
-		isp_parameters.ob_blacklevel_r = 0;
-		isp_parameters.ob_blacklevel_b = 0;
-		isp_parameters.ob_blacklevel_gb = 0;
-		isp_parameters.obarea_start_bq =
-		    ob_config->start_position;
-		isp_parameters.obarea_length_bq =
-		    ((ob_config->end_position - ob_config->start_position) + 1);
-		isp_parameters.obarea_length_bq_inverse =
-		    (1 << 12) / isp_parameters.obarea_length_bq;
-		break;
-	default:
-		isp_parameters.ob_blacklevel_gr = 0;
-		isp_parameters.ob_blacklevel_r = 0;
-		isp_parameters.ob_blacklevel_b = 0;
-		isp_parameters.ob_blacklevel_gb = 0;
-		isp_parameters.obarea_start_bq = 0;
-		isp_parameters.obarea_length_bq = 0;
-		isp_parameters.obarea_length_bq_inverse = 0;
-		break;
-	}
-	isp_params_changed = true;
-	ob_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ob() leave:\n");
-}
-
-static void
-sh_css_process_dp(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_dp() enter:\n");
-
-	isp_parameters.dp_threshold_single_when_2adjacent_on =
-	    SH_CSS_BAYER_MAXVAL;
-	isp_parameters.dp_threshold_2adjacent_when_2adjacent_on =
-	    uDIGIT_FITTING(dp_config->threshold, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.dp_threshold_single_when_2adjacent_off =
-	    uDIGIT_FITTING(dp_config->threshold, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.dp_threshold_2adjacent_when_2adjacent_off =
-	    SH_CSS_BAYER_MAXVAL;
-	isp_parameters.dp_gain =
-	    uDIGIT_FITTING(dp_config->gain, 8, SH_CSS_DP_GAIN_SHIFT);
-	isp_params_changed = true;
-	dp_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_dp() leave:\n");
-}
-
-static void
-sh_css_process_nr_ee(void)
-{
-	int asiWk1, asiWk2, asiWk3;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_nr_ee() enter:\n");
-
-	/* BNR (Bayer Noise Reduction) */
-	isp_parameters.bnr_threshold_low =
-	    uDIGIT_FITTING(nr_config->direction, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.bnr_threshold_width_log2 = uFRACTION_BITS_FITTING(8);
-	isp_parameters.bnr_threshold_width =
-	    1 << isp_parameters.bnr_threshold_width_log2;
-	isp_parameters.bnr_gain_all =
-	    uDIGIT_FITTING(nr_config->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
-	isp_parameters.bnr_gain_dir =
-	    uDIGIT_FITTING(nr_config->bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
-	isp_parameters.bnr_clip = uDIGIT_FITTING(
-					(unsigned)16384, 16, SH_CSS_BAYER_BITS);
-
-	/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
-	asiWk1 = (int) ee_config->gain;
-	asiWk2 = asiWk1 / 8;
-	asiWk3 = asiWk1 / 4;
-	isp_parameters.ynr_threshold =
-		uDIGIT_FITTING((unsigned)8192, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.ynr_gain_all =
-	    uDIGIT_FITTING(nr_config->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
-	isp_parameters.ynr_gain_dir =
-	    uDIGIT_FITTING(nr_config->ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
-	isp_parameters.ynryee_dirthreshold_s =
-	    min((uDIGIT_FITTING(nr_config->direction, 16, SH_CSS_BAYER_BITS)
-				    << 1),
-		SH_CSS_BAYER_MAXVAL);
-	isp_parameters.ynryee_dirthreshold_g =
-	    min((uDIGIT_FITTING(nr_config->direction, 16, SH_CSS_BAYER_BITS)
-				    << 4),
-		SH_CSS_BAYER_MAXVAL);
-	isp_parameters.ynryee_dirthreshold_width_log2 =
-	    uFRACTION_BITS_FITTING(8);
-	isp_parameters.ynryee_dirthreshold_width =
-	    1 << isp_parameters.ynryee_dirthreshold_width_log2;
-	isp_parameters.yee_detailgain =
-	    uDIGIT_FITTING(ee_config->detail_gain, 11,
-			   SH_CSS_YEE_DETAIL_GAIN_SHIFT);
-	isp_parameters.yee_coring_s =
-	    (uDIGIT_FITTING((unsigned)56, 16, SH_CSS_BAYER_BITS) *
-	     ee_config->threshold) >> 8;
-	isp_parameters.yee_coring_g =
-	    (uDIGIT_FITTING((unsigned)224, 16, SH_CSS_BAYER_BITS) *
-	     ee_config->threshold) >> 8;
-	/* 8; // *1.125 ->[s4.8] */
-	isp_parameters.yee_scale_plus_s =
-	    (asiWk1 + asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
-	/* 8; // ( * -.25)->[s4.8] */
-	isp_parameters.yee_scale_plus_g =
-	    (0 - asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
-	/* 8; // *0.875 ->[s4.8] */
-	isp_parameters.yee_scale_minus_s =
-	    (asiWk1 - asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
-	/* 8; // ( *.25 ) ->[s4.8] */
-	isp_parameters.yee_scale_minus_g =
-	    (asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
-	isp_parameters.yee_clip_plus_s =
-	    uDIGIT_FITTING((unsigned)32760, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.yee_clip_plus_g = 0;
-	isp_parameters.yee_clip_minus_s =
-	    uDIGIT_FITTING((unsigned)504, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.yee_clip_minus_g =
-	    uDIGIT_FITTING((unsigned)32256, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.ynryee_Yclip = SH_CSS_BAYER_MAXVAL;
-	isp_params_changed = true;
-	nr_config_changed = false;
-	ee_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_nr_ee() leave:\n");
-}
-
-static void
-sh_css_process_de(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_de() enter:\n");
-
-	isp_parameters.de_pixelnoise =
-	    uDIGIT_FITTING(de_config->pixelnoise, 16, SH_CSS_BAYER_BITS);
-	isp_parameters.de_c1_coring_threshold =
-	    uDIGIT_FITTING(de_config->c1_coring_threshold, 16,
-			   SH_CSS_BAYER_BITS);
-	isp_parameters.de_c2_coring_threshold =
-	    uDIGIT_FITTING(de_config->c2_coring_threshold, 16,
-			   SH_CSS_BAYER_BITS);
-	isp_params_changed = true;
-	de_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_de() leave:\n");
-}
-
-static void
-sh_css_process_gc(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_gc() enter:\n");
-
-	isp_parameters.gamma_gain_k1 =
-	    uDIGIT_FITTING((int)gc_config->gain_k1, 16,
-		SH_CSS_GAMMA_GAIN_K_SHIFT);
-	isp_parameters.gamma_gain_k2 =
-	    uDIGIT_FITTING((int)gc_config->gain_k2, 16,
-		SH_CSS_GAMMA_GAIN_K_SHIFT);
-	isp_params_changed = true;
-	gc_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_gc() leave:\n");
-}
-
-static void
-sh_css_process_anr(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_anr() enter:\n");
-
-	isp_parameters.anr_threshold = anr_config->threshold;
-	isp_params_changed = true;
-	anr_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_anr() leave:\n");
-}
-
-static void
-sh_css_process_ce(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ce() enter:\n");
-
-	isp_parameters.ce_uv_level_min = ce_config->uv_level_min;
-	isp_parameters.ce_uv_level_max = ce_config->uv_level_max;
-	isp_params_changed = true;
-	ce_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ce() leave:\n");
-}
-
-static void sh_css_process_zoom_and_motion(
-	enum sh_css_pipe_id pipe_id,
-	const struct sh_css_pipeline_stage *first_stage)
-{
-/* first_stage can be  NULL */
-	const struct sh_css_pipeline_stage *stage;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_process_zoom_and_motion() enter:\n");
-
-	/* Go through all stages to udate uds and cropping */
-	for (stage = first_stage; stage; stage = stage->next) {
-
-		struct sh_css_binary *binary;
-		struct sh_css_binary tmp_binary;
-
-		const struct sh_css_binary_info *info = NULL;
-
-		binary = stage->binary;
-		if (binary) {
-			info = binary->info;
-		} else {
-			const struct sh_css_binary_args *args = &stage->args;
-			info = &stage->firmware->info.isp;
-			sh_css_fill_binary_info(info, false, false,
-				SH_CSS_INPUT_FORMAT_RAW_10,
-				args->in_frame  ? &args->in_frame->info  : NULL,
-				args->out_frame ? &args->out_frame->info : NULL,
-				args->out_vf_frame ? &args->out_vf_frame->info
-									: NULL,
-				&tmp_binary,
-				false);
-			binary = &tmp_binary;
-			binary->info = info;
-		}
-
-		assert(stage->stage_num < SH_CSS_MAX_STAGES);
-		sh_css_update_uds_and_crop_info(
-			info,
-			&binary->in_frame_info,
-			&binary->out_frame_info,
-			&binary->dvs_envelope,
-			pipe_id == SH_CSS_PREVIEW_PIPELINE,
-			&zoom_config,
-			&motion_config,
-			&isp_parameters.uds[stage->stage_num],
-			&isp_parameters.sp_out_crop_pos[stage->stage_num]);
-	}
-	isp_params_changed = true;
-	zoom_config_changed = false;
-	motion_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_process_zoom_and_motion() leave:\n");
-}
-
-static void
-sh_css_process_ecd(void)
-{
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	isp_parameters.ecd_zip_strength = ecd_config->ecd_zip_strength;
-	isp_parameters.ecd_fc_strength  = ecd_config->ecd_fc_strength;
-	isp_parameters.ecd_fc_debias    = ecd_config->ecd_fc_debias;
-	isp_params_changed = true;
-	ecd_config_changed = false;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-}
-
-static void
-sh_css_process_ynr(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ynr() enter:\n");
-
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	isp_parameters.yee_edge_sense_gain_0   = ynr_config->edge_sense_gain_0;
-	isp_parameters.yee_edge_sense_gain_1   = ynr_config->edge_sense_gain_1;
-	isp_parameters.yee_corner_sense_gain_0 = ynr_config->corner_sense_gain_0;
-	isp_parameters.yee_corner_sense_gain_1 = ynr_config->corner_sense_gain_1;
-	isp_params_changed = true;
-	ynr_config_changed = false;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ynr() leave:\n");
-}
-
-static void
-sh_css_process_fc(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_fc() enter:\n");
-
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	isp_parameters.fc_gain_exp   = fc_config->gain_exp;
-
-	isp_parameters.fc_gain_pos_0 = fc_config->gain_pos_0;
-	isp_parameters.fc_gain_pos_1 = fc_config->gain_pos_1;
-	isp_parameters.fc_gain_neg_0 = fc_config->gain_neg_0;
-	isp_parameters.fc_gain_neg_1 = fc_config->gain_neg_1;
-
-	isp_parameters.fc_crop_pos_0 = fc_config->crop_pos_0;
-	isp_parameters.fc_crop_pos_1 = fc_config->crop_pos_1;
-	isp_parameters.fc_crop_neg_0 = fc_config->crop_neg_0;
-	isp_parameters.fc_crop_neg_1 = fc_config->crop_neg_1;
-	isp_params_changed = true;
-	fc_config_changed = false;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_fc() leave:\n");
-}
-
-static void
-sh_css_process_cnr(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cnr() enter:\n");
-
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	isp_parameters.cnr_coring_u = cnr_config->coring_u;
-	isp_parameters.cnr_coring_v = cnr_config->coring_v;
-	isp_parameters.cnr_sense_gain_vy = cnr_config->sense_gain_vy;
-	isp_parameters.cnr_sense_gain_vu = cnr_config->sense_gain_vu;
-	isp_parameters.cnr_sense_gain_vv = cnr_config->sense_gain_vv;
-	isp_parameters.cnr_sense_gain_hy = cnr_config->sense_gain_hy;
-	isp_parameters.cnr_sense_gain_hu = cnr_config->sense_gain_hu;
-	isp_parameters.cnr_sense_gain_hv = cnr_config->sense_gain_hv;
-	isp_params_changed = true;
-	cnr_config_changed = false;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cnr() leave:\n");
-}
-
-static void
-sh_css_process_macc(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_macc() enter:\n");
-
-	isp_parameters.exp = macc_config->exp;
-	isp_params_changed = true;
-	macc_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_macc() leave:\n");
-}
-
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-static void ctc_gradient(
-	int *dydx, int *shift,
-	int y1, int y0, int x1, int x0)
-{
-	int frc_bits = max(SH_CSS_CTC_COEF_SHIFT, 16);
-	int dy = y1 - y0;
-	int dx = x1 - x0;
-	int dydx_int = dy / dx;
-	int dydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;
-	int sft;
-
-	/* max_dydx = the maxinum gradient = the maximum y (gain) */
-	int max_dydx = (1 << SH_CSS_CTC_COEF_SHIFT) - 1;
-
-	assert(y0 >= 0 && y0 <= max_dydx);
-	assert(y1 >= 0 && y1 <= max_dydx);
-	assert(x0 < x1);
-	assert(dydx != NULL);
-	if (dydx == NULL)
-		return;
-
-	assert(shift != NULL);
-	if (shift == NULL)
-		return;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
-
-	/* search "sft" which meets this condition:
-		   (1 << (SH_CSS_CTC_COEF_SHIFT - 1))
-		<= (((float)dy / (float)dx) * (1 << sft))
-		<= ((1 << SH_CSS_CTC_COEF_SHIFT) - 1) */
-	for (sft = 0; sft <= SH_CSS_CTC_COEF_SHIFT; sft++) {
-		int tmp_dydx = (dydx_int << sft)
-			     + (dydx_frc >> (frc_bits - sft));
-		if (tmp_dydx <= max_dydx) {
-			*dydx = tmp_dydx;
-			*shift = sft;
-		}
-		if (tmp_dydx >= max_dydx)
-			break;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
-}
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-static void
-sh_css_process_ctc(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ctc() enter:\n");
-
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	isp_parameters.ctc_y0 = ctc_config->y0;
-	isp_parameters.ctc_y1 = ctc_config->y1;
-	isp_parameters.ctc_y2 = ctc_config->y2;
-	isp_parameters.ctc_y3 = ctc_config->y3;
-	isp_parameters.ctc_y4 = ctc_config->y4;
-	isp_parameters.ctc_y5 = ctc_config->y5;
-
-	isp_parameters.ctc_ce_gain_exp = ctc_config->ce_gain_exp;
-
-	isp_parameters.ctc_x1 = ctc_config->x1;
-	isp_parameters.ctc_x2 = ctc_config->x2;
-	isp_parameters.ctc_x3 = ctc_config->x3;
-	isp_parameters.ctc_x4 = ctc_config->x4;
-
-	ctc_gradient(&isp_parameters.ctc_dydx0,
-		     &isp_parameters.ctc_dydx0_shift,
-		     ctc_config->y1, ctc_config->y0,
-		     ctc_config->x1, 0);
-
-	ctc_gradient(&isp_parameters.ctc_dydx1,
-		     &isp_parameters.ctc_dydx1_shift,
-		     ctc_config->y2, ctc_config->y1,
-		     ctc_config->x2, ctc_config->x1);
-
-	ctc_gradient(&isp_parameters.ctc_dydx2,
-		     &isp_parameters.ctc_dydx2_shift,
-		     ctc_config->y3, ctc_config->y2,
-		     ctc_config->x3, ctc_config->x2);
-
-	ctc_gradient(&isp_parameters.ctc_dydx3,
-		     &isp_parameters.ctc_dydx3_shift,
-		     ctc_config->y4, ctc_config->y3,
-		     ctc_config->x4, ctc_config->x3);
-
-	ctc_gradient(&isp_parameters.ctc_dydx4,
-		     &isp_parameters.ctc_dydx4_shift,
-		     ctc_config->y5, ctc_config->y4,
-		     SH_CSS_BAYER_MAXVAL, ctc_config->x4);
-	isp_params_changed = true;
-	ctc_config_changed = false;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ctc() leave:\n");
-}
-
-static void
-sh_css_process_xnr(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_xnr() enter:\n");
-	isp_parameters.xnr_threshold = xnr_config->threshold;
-	isp_params_changed = true;
-	xnr_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_xnr() leave:\n");
-}
-
-
-static void
-sh_css_process_aa(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_aa() enter:\n");
-/* ISP 1.0 has a decimation filter for large input images */
-	isp_parameters.aa_scale = aa_config->scale;
-	isp_params_changed = true;
-	aa_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_aa() leave:\n");
-}
-
-static void
-sh_css_process_yuv2rgb_cc(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_process_yuv2rgb_cc() enter:\n");
-
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	isp_parameters.ycgco_to_rgb_00 = (int) yuv2rgb_cc_config->matrix[0];
-	isp_parameters.ycgco_to_rgb_01 = (int) yuv2rgb_cc_config->matrix[1];
-	isp_parameters.ycgco_to_rgb_02 = (int) yuv2rgb_cc_config->matrix[2];
-	isp_parameters.ycgco_to_rgb_10 = (int) yuv2rgb_cc_config->matrix[3];
-	isp_parameters.ycgco_to_rgb_11 = (int) yuv2rgb_cc_config->matrix[4];
-	isp_parameters.ycgco_to_rgb_12 = (int) yuv2rgb_cc_config->matrix[5];
-	isp_parameters.ycgco_to_rgb_20 = (int) yuv2rgb_cc_config->matrix[6];
-	isp_parameters.ycgco_to_rgb_21 = (int) yuv2rgb_cc_config->matrix[7];
-	isp_parameters.ycgco_to_rgb_22 = (int) yuv2rgb_cc_config->matrix[8];
-	isp_params_changed = true;
-	yuv2rgb_cc_config_changed = false;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_process_yuv2rgb_cc() leave:\n");
-}
-
-static void
-sh_css_process_rgb2yuv_cc(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_process_rgb2yuv_cc() enter:\n");
-
-#if SH_CSS_ISP_PARAMS_VERSION == 2
-	isp_parameters.rgb_to_yuv_00 = (int) rgb2yuv_cc_config->matrix[0];
-	isp_parameters.rgb_to_yuv_01 = (int) rgb2yuv_cc_config->matrix[1];
-	isp_parameters.rgb_to_yuv_02 = (int) rgb2yuv_cc_config->matrix[2];
-	isp_parameters.rgb_to_yuv_10 = (int) rgb2yuv_cc_config->matrix[3];
-	isp_parameters.rgb_to_yuv_11 = (int) rgb2yuv_cc_config->matrix[4];
-	isp_parameters.rgb_to_yuv_12 = (int) rgb2yuv_cc_config->matrix[5];
-	isp_parameters.rgb_to_yuv_20 = (int) rgb2yuv_cc_config->matrix[6];
-	isp_parameters.rgb_to_yuv_21 = (int) rgb2yuv_cc_config->matrix[7];
-	isp_parameters.rgb_to_yuv_22 = (int) rgb2yuv_cc_config->matrix[8];
-	isp_params_changed = true;
-	rgb2yuv_cc_config_changed = false;
-#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_process_rgb2yuv_cc() leave:\n");
-}
-
-void
-sh_css_set_gamma_table(const struct sh_css_gamma_table *table)
-{
-/* table can be NULL */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_gamma_table() enter: table=%p\n",table);
-
-	gamma_table = table;
-	gamma_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_gamma_table() leave: return_void\n");
-}
-
-void
-sh_css_get_gamma_table(const struct sh_css_gamma_table **table)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_gamma_table() enter: table=%p\n",table);
-
-	assert(table != NULL);
-	if (table == NULL)
-		return;
-
-	*table = gamma_table;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_gamma_table() leave: *table=%p\n",*table);
-}
-
-void
-sh_css_set_ctc_table(const struct sh_css_ctc_table *table)
-{
-/* table can be NULL */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ctc_table() enter: table=%p\n",table);
-
-	ctc_table = table;
-	ctc_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ctc_table() leave: return_void\n");
-}
-
-void
-sh_css_get_ctc_table(const struct sh_css_ctc_table **table)
-{
-	assert(table != NULL);
-	if(table == NULL)
-		return;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_table() enter: "
-		"table=%p\n",table);
-
-	*table = ctc_table;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_table() leave: "
-		"*table=%p\n",*table);
-}
-
-void
-sh_css_set_xnr_table(const struct sh_css_xnr_table *table)
-{
-/* table can be NULL */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_xnr_table() enter: table=%p\n",table);
-
-	xnr_table = table;
-	xnr_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_xnr_table() leave: return_void\n");
-}
-
-void
-sh_css_get_xnr_table(const struct sh_css_xnr_table **table)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_table() enter: "
-		"table=%p\n",table);
-
-	assert(table != NULL);
-	if (table == NULL)
-		return;
-
-	*table = xnr_table;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_table() leave: "
-		"*table=%p\n",*table);
-}
-
-void
-sh_css_set_macc_table(const struct sh_css_macc_table *table)
-{
-/* table can be NULL */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_macc_table() enter: table=%p\n",table);
-
-	macc_table = table;
-	macc_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_macc_table() leave: return_void\n");
-}
-
-void
-sh_css_get_macc_table(const struct sh_css_macc_table **table)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_macc_table() enter: table=%p\n",table);
-
-	assert(table != NULL);
-	if (table == NULL)
-		return;
-
-	*table = macc_table;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_macc_table() leave: *table=%p\n",*table);
-}
-
-void sh_css_morph_table_free(
-	struct sh_css_morph_table *me)
-{
-	unsigned int i;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_morph_table_free() enter:\n");
-
-	if (me == NULL) {
-/* Checkpatch patch */
-		return;
-	}
-
-	for (i = 0; i < SH_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-		if (me->coordinates_x[i])
-			sh_css_free(me->coordinates_x[i]);
-		if (me->coordinates_y[i])
-			sh_css_free(me->coordinates_y[i]);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_morph_table_free() leave:\n");
-
-	sh_css_free(me);
-}
-
-struct sh_css_morph_table *sh_css_morph_table_allocate(
-	unsigned int width,
-	unsigned int height)
-{
-	unsigned int i;
-	struct sh_css_morph_table *me = sh_css_malloc(sizeof(*me));
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_morph_table_allocate() enter:\n");
-
-	if (me == NULL) {
-/* Checkpatch patch */
-		return me;
-	}
-
-	for (i = 0; i < SH_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-		me->coordinates_x[i] = NULL;
-		me->coordinates_y[i] = NULL;
-	}
-
-	for (i = 0; i < SH_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-		me->coordinates_x[i] =
-		    sh_css_malloc(height * width *
-				  sizeof(*me->coordinates_x[i]));
-		me->coordinates_y[i] =
-		    sh_css_malloc(height * width *
-				  sizeof(*me->coordinates_y[i]));
-
-		if ((me->coordinates_x[i] == NULL) ||
-			(me->coordinates_y[i] == NULL)) {
-/*
- * MW: Potential memory leak, need to free all previous pointers
- *
-			sh_css_free(me->coordinates_x[i]);
-			sh_css_free(me->coordinates_y[i]);
- */
-			sh_css_morph_table_free(me);
-			me = NULL;
-			return me;
-		}
-	}
-	me->width = width;
-	me->height = height;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_morph_table_allocate() leave:\n");
-
-	return me;
-}
-
-/* This function adds phase shift (1/2 pixel) to the color components. 
- * This is required as we are also doing upscale&interpolation in the GDC. */
-static enum sh_css_err sh_css_params_morph_table_shift_phase(
-	const struct sh_css_morph_table *in_table,
-	const struct sh_css_binary *binary,
-	struct sh_css_morph_table **out_table)
-{
-	// TODO: Remove the hardcoded value. Currently, there is
-	// no defined GDC MACRO to use for all the systems.
-	short shift_val = (1<<4) / 2;
-	short phase_shift_x[SH_CSS_MORPH_TABLE_NUM_PLANES]
-				= { 0, shift_val, 0, shift_val, shift_val, 0 },
-	      phase_shift_y[SH_CSS_MORPH_TABLE_NUM_PLANES]
-				= { shift_val, shift_val, 0, 0, 0, shift_val };
-	unsigned int i, j, k,
-		     width,
-		     height;
-	struct sh_css_morph_table *tab;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_morph_table_shift_phase() enter:\n");
-
-	assert(in_table != NULL);
-	if (in_table == NULL)
-		return sh_css_err_internal_error;
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return sh_css_err_internal_error;
-
-	width = binary->morph_tbl_width,
-	height = binary->morph_tbl_height;
-
-	tab = sh_css_morph_table_allocate(width, height);
-	if (tab == NULL)
-		return sh_css_err_cannot_allocate_memory;
-
-	for (i = 0; i < SH_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-		for (j = 0; j < height; j++) {
-			unsigned short *in_x_ptr, *in_y_ptr,
-				       *out_x_ptr, *out_y_ptr;
-			in_x_ptr = &in_table->coordinates_x[i][j * width];
-			in_y_ptr = &in_table->coordinates_y[i][j * width];
-			out_x_ptr = &tab->coordinates_x[i][j * width];
-			out_y_ptr = &tab->coordinates_y[i][j * width];
-			for (k = 0; k < width; k++, in_x_ptr++, in_y_ptr++,
-						out_x_ptr++, out_y_ptr++) {
-				*out_x_ptr = *in_x_ptr + phase_shift_x[i];
-				*out_y_ptr = *in_y_ptr + phase_shift_y[i];
-			}
-		}
-	}
-	*out_table = tab;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_morph_table_shift_phase() leave:\n");
-
-	return sh_css_success;
-}
-static enum sh_css_err sh_css_params_default_morph_table(
-	struct sh_css_morph_table **table,
-	const struct sh_css_binary *binary)
-{
-/* MW 2400 advanced requires different scaling */
-	unsigned int i, j, k,
-		     step = (ISP_VEC_NELEMS / 16) * 128,
-		     width,
-		     height;
-	struct sh_css_morph_table *tab;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_default_morph_table() enter:\n");
-
-	assert(table != NULL);
-	if (table == NULL)
-		return sh_css_err_internal_error;
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return sh_css_err_internal_error;
-
-	width = binary->morph_tbl_width,
-	height = binary->morph_tbl_height;
-
-	tab = sh_css_morph_table_allocate(width, height);
-	if (tab == NULL) {
-
-		return sh_css_err_cannot_allocate_memory;
-	}
-
-	for (i = 0; i < SH_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-		short val_y = 0;
-		for (j = 0; j < height; j++) {
-			short val_x = 0;
-			unsigned short *x_ptr, *y_ptr;
-
-			x_ptr = &tab->coordinates_x[i][j * width];
-			y_ptr = &tab->coordinates_y[i][j * width];
-			for (k = 0; k < width;
-			     k++, x_ptr++, y_ptr++, val_x += step) {
-				*x_ptr = val_x;
-				*y_ptr = val_y;
-
-				// TODO: We might need to ensure that
-				// the last grid in x&y direction is within
-				// input space.
-				//if (k==width-1)
-				//	*x_ptr -= 4 * (1<<4);
-				//if (j==height-1)
-				//	*y_ptr -= 4 * (1<<4);
-			}
-			val_y += step;
-		}
-	}
-	*table = tab;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_params_default_morph_table() leave:\n");
-
-	return sh_css_success;
-}
-
-void
-sh_css_invalidate_morph_table(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_invalidate_morph_table() enter:\n");
-
-	morph_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_invalidate_morph_table() leave:\n");
-}
-
-void
-sh_css_set_morph_table(const struct sh_css_morph_table *table)
-{
-/* table can be NULL */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_morph_table() enter: "
-		"table=%p\n",table);
-
-	morph_table = table;
-	morph_table_changed = true;
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_morph_table() leave: "
-		"return_void\n");
-}
-
-void
-sh_css_get_morph_table(const struct sh_css_morph_table **table)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_morph_table() enter: "
-		"table=%p\n",table);
-
-	assert(table != NULL);
-	if (table == NULL)
-		return;
-
-	*table = morph_table;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_morph_table() leave: "
-		"*table=%p\n",*table);
-
-}
-
-enum sh_css_err sh_css_get_3a_statistics(
-	struct sh_css_3a_output *output,
-	bool use_dmem,
-	union sh_css_s3a_data *s3a_data)
-{
-	/* rvanimme: s3a_data is referenced in this function, so cannot be null */
-	/* But there are test cases that calls this function with NULL */
-	/* This is considered a BUG (see CR 2344). For now comment out assert */
-	/* assert(s3a_data != NULL); */
-	if(s3a_data == NULL)
-		return sh_css_err_internal_error;
-	assert(output != NULL);
-	if(output == NULL)
-		return sh_css_err_internal_error;
-
-	if (current_3a_binary == NULL) {
-		return sh_css_err_internal_error;
-	}
-
-	if (s3a_data == NULL) {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_3a_statistics() enter: "
-		"s3a_data=%p\n",
-		s3a_data);
-	} else {
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_3a_statistics() enter: "
-		"use_dmem=%d, s3a_data.d=%x, "
-		"s3a_data.v.hi=%x, s3a_data.v.lo=%x\n",
-		use_dmem, s3a_data->dmem.s3a_tbl,
-		s3a_data->vmem.s3a_tbl_hi,s3a_data->vmem.s3a_tbl_lo);
-	}
-
-	if (use_dmem) {
-		get_3a_stats_from_dmem(output, s3a_data->dmem.s3a_tbl);
-	} else {
-		get_3a_stats_from_vmem(output, s3a_data->vmem.s3a_tbl_hi,
-						s3a_data->vmem.s3a_tbl_lo);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_3a_statistics() leave: return=%d\n",sh_css_success);
-
-	return sh_css_success;
-}
-
-void sh_css_set_3a_config(
-	const struct sh_css_3a_config *config)
-{
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_3a_config() enter: "
-		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, "
-		"config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, "
-		"config.awb_lg_low=%d, config.awb_lg_high=%d\n",
-		config->ae_y_coef_r, config->ae_y_coef_g,
-		config->ae_y_coef_b, config->awb_lg_high_raw,
-		config->awb_lg_low, config->awb_lg_high);
-
-
-	s3a_config = config;
-	s3a_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_3a_config() leave: return_void\n");
-}
-
-void sh_css_get_3a_config(
-	const struct sh_css_3a_config **config)
-{
- 	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_3a_config() enter: "
-				"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = s3a_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_3a_config() leave: "
-		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, "
-		"config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, "
-		"config.awb_lg_low=%d,  config.awb_lg_high=%d\n",
-		(*config)->ae_y_coef_r, (*config)->ae_y_coef_g,
-		(*config)->ae_y_coef_b, (*config)->awb_lg_high_raw,
-		(*config)->awb_lg_low, (*config)->awb_lg_high);
-}
-
-void sh_css_set_wb_config(
-	const struct sh_css_wb_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_wb_config() enter: "
-		"config.integer_bits=%d, config.gr=%d, config.r=%d, "
-		"config.b=%d, config.gb=%d\n",
-		config->integer_bits,
-		config->gr, config->r,
-		config->b, config->gb);
-		wb_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_wb_config() enter: "
-		"config=%p\n",config);
-		wb_config = &disabled_wb_config;
-	}
-	wb_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_wb_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_wb_config(
-	const struct sh_css_wb_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_wb_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = wb_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_wb_config() leave: "
-		"config.integer_bits=%d, "
-		"config.gr=%d, config.r=%d, "
-		"config.b=%d,  config.gb=%d\n",
-		(*config)->integer_bits,
-		(*config)->gr, (*config)->r,
-		(*config)->b, (*config)->gb);
-}
-
-void sh_css_set_cc_config(
-	const struct sh_css_cc_config *config)
-{
-/* config can be NULL */
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cc_config()\n");
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cc_config() enter: "
-		"config.fraction_bits=%d, config.m[0]=%d, "
-		"config.m[1]=%d, config.m[2]=%d, "
-		"config.m[3]=%d, config.m[4]=%d, "
-		"config.m[5]=%d, config.m[6]=%d, "
-		"config.m[7]=%d, config.m[8]=%d\n",
-		config->fraction_bits, config->matrix[0],
-		config->matrix[1], config->matrix[2],
-		config->matrix[3], config->matrix[4],
-		config->matrix[5], config->matrix[6],
-		config->matrix[7], config->matrix[8]);
-		cc_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cc_config() enter: "
-		"config=%p\n",config);
-		cc_config = &disabled_cc_config;
-	}
-
-	cc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_cc_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_cc_config(
-	const struct sh_css_cc_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cc_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = cc_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cc_config() leave: "
-		"config.fraction_bits=%d, config.m[0]=%d, "
-		"config.m[1]=%d, config.m[2]=%d, "
-		"config.m[3]=%d, config.m[4]=%d, "
-		"config.m[5]=%d, config.m[6]=%d, "
-		"config.m[7]=%d, config.m[8]=%d\n",
-		(*config)->fraction_bits, (*config)->matrix[0],
-		(*config)->matrix[1], (*config)->matrix[2],
-		(*config)->matrix[3], (*config)->matrix[4],
-		(*config)->matrix[5], (*config)->matrix[6],
-		(*config)->matrix[7], (*config)->matrix[8]);
-}
-
-void sh_css_set_tnr_config(
-	const struct sh_css_tnr_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_tnr_config() enter: "
-		"config.gain=%d, config.threshold_y=%d, "
-		"config.threshold_uv=%d\n",
-		config->gain,
-		config->threshold_y, config->threshold_uv);
-		tnr_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_tnr_config() enter: config=%p\n",config);
-		tnr_config = &disabled_tnr_config;
-	}
-
-	tnr_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_tnr_config() leave: return_void\n");
-}
-
-void sh_css_get_tnr_config(
-	const struct sh_css_tnr_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_tnr_config() enter: config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = tnr_config;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_tnr_config() leave: config.gain=%d, "
-		"config.threshold_y=%d, config.threshold_uv=%d\n",
-		(*config)->gain,
-		(*config)->threshold_y,(*config)->threshold_uv);
-}
-
-void sh_css_set_ob_config(
-	const struct sh_css_ob_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ob_config() enter: "
-		"config.mode=%d, config.level_gr=%d, config.level_r=%d, "
-		"config.level_b=%d,  config.level_gb=%d, "
-		"config.start_position=%d, config.end_position=%d\n",
-		config->mode,
-		config->level_gr, config->level_r,
-		config->level_b, config->level_gb,
-		config->start_position, config->end_position);
-
-		ob_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ob_config() enter: config=%p\n",config);
-		ob_config = &disabled_ob_config;
-	}
-	ob_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ob_config() leave: return_void\n");
-}
-
-void sh_css_get_ob_config(
-	const struct sh_css_ob_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_ob_config() enter: config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = ob_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ob_config() leave: "
-		"config.mode=%d, config.level_gr=%d, config.level_r=%d, "
-		"config.level_b=%d, config.level_gb=%d, "
-		"config.start_position=%d, config.end_position=%d\n",
-		(*config)->mode,
-		(*config)->level_gr, (*config)->level_r,
-		(*config)->level_b, (*config)->level_gb,
-		(*config)->start_position,(*config)->end_position);
-}
-
-void sh_css_set_dp_config(const struct sh_css_dp_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dp_config() enter: "
-		"config.threshold=%d, config.gain=%d\n",
-		config->threshold, config->gain);
-		dp_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_dp_config() enter: config=%p\n",config);
-		dp_config = &disabled_dp_config;
-	}
-	dp_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ob_config() leave: return_void\n");
-}
-
-void sh_css_get_dp_config(
-	const struct sh_css_dp_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_dp_config() enter: config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = dp_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dp_config() enter: "
-		"config.threshold=%d, config.gain=%d\n",
-		(*config)->threshold, (*config)->gain);
-}
-
-void sh_css_set_nr_config(
-	const struct sh_css_nr_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_nr_config() enter: "
-		"config.direction=%d, "
-		"config.bnr_gain=%d, config.ynr_gain=%d, "
-		"config.threshold_cb=%d, config.threshold_cr=%d\n",
-		config->direction,
-		config->bnr_gain, config->ynr_gain,
-		config->threshold_cb, config->threshold_cr);
-		nr_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_nr_config() enter: "
-		"config=%p\n",config);
-		nr_config = &disabled_nr_config;
-	}
-	nr_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_nr_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_nr_config(
-	const struct sh_css_nr_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_nr_config() enter: config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = nr_config;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_nr_config() leave: config.direction=%d, "
-		"config.bnr_gain=%d, config.ynr_gain=%d, "
-		"config.threshold_cb=%d, config.threshold_cr=%d\n",
-		(*config)->direction,
-		(*config)->bnr_gain, (*config)->ynr_gain,
-		(*config)->threshold_cb, (*config)->threshold_cr);
-}
-
-void sh_css_set_ee_config(
-	const struct sh_css_ee_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ee_config() enter: "
-		"config.threshold=%d, "
-		"config.gain=%d, config.detail_gain=%d\n",
-		config->threshold,
-		config->gain, config->detail_gain);
-		ee_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ee_config() enter: "
-		"config=%p\n",config);
-		ee_config = &disabled_ee_config;
-	}
-	ee_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ee_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_ee_config(
-	const struct sh_css_ee_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_ee_config() enter: config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = ee_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ee_config() enter: "
-		"config.threshold=%d, config.gain=%d, config.detail_gain=%d\n",
-		(*config)->threshold,
-		(*config)->gain, (*config)->detail_gain);
-}
-
-void sh_css_set_de_config(
-	const struct sh_css_de_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_de_config() enter: "
-		"config.pixelnoise=%d, "
-		"config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
-		config->pixelnoise,
-		config->c1_coring_threshold, config->c2_coring_threshold);
-		de_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_de_config() enter: "
-		"config=%p\n",config);
-		de_config = &disabled_de_config;
-	}
-	de_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_de_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_de_config(
-	const struct sh_css_de_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_de_config() enter: config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = de_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_de_config() leave: "
-		"config.pixelnoise=%d, config.c1_coring_threshold=%d, "
-		"config.c2_coring_threshold=%d\n",
-		(*config)->pixelnoise,
-		(*config)->c1_coring_threshold, (*config)->c2_coring_threshold);
-}
-
-void sh_css_set_gc_config(const struct sh_css_gc_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gc_config() enter: "
-		"config.gain_k1=%d, config.gain_k2=%d\n",
-		config->gain_k1, config->gain_k2);
-		gc_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gc_config() enter: "
-		"config=%p\n",config);
-		gc_config = &disabled_gc_config;
-	}
-	gc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_gc_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_gc_config(
-	const struct sh_css_gc_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gc_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = gc_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gc_config() leave: "
-		"config.gain_k1=%d, config.gain_k2=%d\n",
-		(*config)->gain_k1, (*config)->gain_k2);
-}
-
-void sh_css_set_anr_config(
-	const struct sh_css_anr_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_config() enter: "
-		"config.threshold=%d\n",
-		config->threshold);
-		anr_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_config() enter: "
-		"config=%p\n",config);
-		anr_config = &default_anr_config;
-	}
-	anr_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_anr_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_anr_config(
-	const struct sh_css_anr_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = anr_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_config() leave: "
-		"config.threshold=%d\n",
-		(*config)->threshold);
-}
-
-void sh_css_set_ce_config(
-	const struct sh_css_ce_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ce_config() enter: "
-		"config.uv_level_min=%d, config.uv_level_max=%d\n",
-		config->uv_level_min, config->uv_level_max);
-		ce_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ce_config() enter: "
-		"config=%p\n",config);
-		ce_config = &default_ce_config;
-	}
-	ce_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ce_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_ce_config(
-	const struct sh_css_ce_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ce_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = ce_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ce_config() leave: "
-		"config.uv_level_min=%d, config.uv_level_max=%d\n",
-		(*config)->uv_level_min, (*config)->uv_level_max);
-}
-
-
-void sh_css_set_dvs_6axis_config(
-	const struct sh_css_dvs_6axis_config *dvs_config)
-{
-/* config can be NULL */
-
-	if (dvs_config != NULL) {
-/* Structure to big to print its contents under a single line requirement */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs_config() enter: "
-		"dvs_config=%p\n",dvs_config);
-		dvs_6axis_config = dvs_config;
-		dvs_6axis_config_changed = true;
-	} else {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs_config() enter: "
-		"dvs_config=%p\n",dvs_config);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_dvs_6axis_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_dvs_6axis_config(
-	const struct sh_css_dvs_6axis_config **dvs_config)
-{
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dvs_6axis_config() enter: "
-		"dvs_config=%p\n",dvs_config);
-
-	assert(dvs_config != NULL);
-	if (dvs_config == NULL)
-		return;
-
-	*dvs_config = dvs_6axis_config;
-
-/* Structure to big to print its contents under a single line requirement */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_dvs_6axis_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_set_ecd_config(
-	const struct sh_css_ecd_config *config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config()\n");
-	if (config != NULL) {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ynr_config() enter: "
-		"config.ecd_zip_strength=%d, "
-		"config.ecd_fc_strength=%d, config.ecd_fc_debias=%d\n",
-		config->ecd_zip_strength,
-		config->ecd_fc_strength, config->ecd_fc_debias);
-		ecd_config = config;
-	} else {
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config() enter: "
-		"config=%p\n",config);
-		ecd_config = &default_ecd_config;
-	}
-	ecd_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config() leave: "
-		"return_void\n");
-return;
-}
-
-void sh_css_get_ecd_config(
-	const struct sh_css_ecd_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ecd_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = ecd_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config() enter: "
-		"config.ecd_zip_strength=%d, "
-		"config.ecd_fc_strength=%d, config.ecd_fc_debias=%d\n",
-		(*config)->ecd_zip_strength,
-		(*config)->ecd_fc_strength, (*config)->ecd_fc_debias);
-return;
-}
-
-void sh_css_set_ynr_config(
-	const struct sh_css_ynr_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ynr_config() enter: "
-		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, "
-		"config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
-		config->edge_sense_gain_0, config->edge_sense_gain_1,
-		config->corner_sense_gain_0, config->corner_sense_gain_1);
-		ynr_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ynr_config() enter: "
-		"config=%p\n",config);
-		ynr_config = &default_ynr_config;
-	}
-	ynr_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ynr_config() leave: "
-		"return_void\n");
-return;
-}
-
-void sh_css_get_ynr_config(
-	const struct sh_css_ynr_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ynr_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = ynr_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ynr_config() leave: "
-		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, "
-		"config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
-		(*config)->edge_sense_gain_0, (*config)->edge_sense_gain_1,
-		(*config)->corner_sense_gain_0, (*config)->corner_sense_gain_1);
-return;
-}
-
-void sh_css_set_fc_config(
-	const struct sh_css_fc_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_fc_config() enter: "
-		"config.gain_exp=%d, "
-		"config.gain_pos_0=%d, config.gain_pos_1=%d, "
-		"config.gain_neg_0=%d, config.gain_neg_1=%d, "
-		"config.crop_pos_0=%d, config.crop_pos_1=%d, "
-		"config.crop_neg_0=%d, config.crop_neg_1=%d\n",
-		config->gain_exp,
-		config->gain_pos_0, config->gain_pos_1,
-		config->gain_neg_0, config->gain_neg_1,
-		config->crop_pos_0, config->crop_pos_1,
-		config->crop_neg_0, config->crop_neg_1);
-		fc_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_fc_config() enter: "
-		"config=%p\n",config);
-		fc_config = &default_fc_config;
-	}
-	fc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_fc_config() leave: "
-		"return_void\n");
-return;
-}
-
-void sh_css_get_fc_config(
-	const struct sh_css_fc_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_fc_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = fc_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_fc_config() leave: "
-		"config.gain_exp=%d, "
-		"config.gain_pos_0=%d, config.gain_pos_1=%d, "
-		"config.gain_neg_0=%d, config.gain_neg_1=%d, "
-		"config.crop_pos_0=%d, config.crop_pos_1=%d, "
-		"config.crop_neg_0=%d, config.crop_neg_1=%d\n",
-		(*config)->gain_exp,
-		(*config)->gain_pos_0, (*config)->gain_pos_1,
-		(*config)->gain_neg_0, (*config)->gain_neg_1,
-		(*config)->crop_pos_0, (*config)->crop_pos_1,
-		(*config)->crop_neg_0, (*config)->crop_neg_1);
-return;
-}
-
-void sh_css_set_cnr_config(
-	const struct sh_css_cnr_config *config)
-{
-/* config can be NULL */
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cnr_config()\n");
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cnr_config() enter: "
-		"config.coring_u=%d, config.coring_v=%d, "
-		"config.sense_gain_vy=%d, config.sense_gain_hy=%d, "
-		"config.sense_gain_vu=%d, config.sense_gain_hu=%d, "
-		"config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
-		config->coring_u, config->coring_v,
-		config->sense_gain_vy, config->sense_gain_hy,
-		config->sense_gain_vu, config->sense_gain_hu,
-		config->sense_gain_vv, config->sense_gain_hv);
-		cnr_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cnr_config() enter: "
-		"config=%p\n",config);
-		cnr_config = &default_cnr_config;
-	}
-	cnr_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_cnr_config() leave: "
-		"return_void\n");
-return;
-}
-
-void sh_css_get_cnr_config(
-	const struct sh_css_cnr_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cnr_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = cnr_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cnr_config() leave: "
-		"config.coring_u=%d, config.coring_v=%d, "
-		"config.sense_gain_vy=%d, config.sense_gain_hy=%d, "
-		"config.sense_gain_vu=%d, config.sense_gain_hu=%d, "
-		"config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
-		(*config)->coring_u, (*config)->coring_v,
-		(*config)->sense_gain_vy, (*config)->sense_gain_hy,
-		(*config)->sense_gain_vu, (*config)->sense_gain_hu,
-		(*config)->sense_gain_vv, (*config)->sense_gain_hv);
-return;
-}
-
-void sh_css_set_macc_config(
-	const struct sh_css_macc_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_config() enter: "
-		"config.exp=%d\n",
-		config->exp);
-		macc_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_config() enter: "
-		"config=%p\n",config);
-		macc_config = &disabled_macc_config;
-	}
-	macc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_macc_config() leave: "
-		"return_void\n");
-return;
-}
-
-void sh_css_get_macc_config(
-	const struct sh_css_macc_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = macc_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_config() leave: "
-		"config.exp=%d\n",
-		(*config)->exp);
-return;
-}
-
-void sh_css_set_ctc_config(
-	const struct sh_css_ctc_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_config() enter: "
-		"config.ce_gain_exp=%d, config.y0=%d, "
-		"config.x1=%d, config.y1=%d, "
-		"config.x2=%d, config.y2=%d, "
-		"config.x3=%d, config.y3=%d, "
-		"config.x4=%d, config.y4=%d\n",
-		config->ce_gain_exp, config->y0,
-		config->x1, config->y1,
-		config->x2, config->y2,
-		config->x3, config->y3,
-		config->x4, config->y4);
-		ctc_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_config() enter: "
-		"config=%p\n",config);
-		ctc_config = &default_ctc_config;
-	}
-	ctc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_ctc_config() leave: "
-		"return_void\n");
-return;
-}
-
-void sh_css_get_ctc_config(
-	const struct sh_css_ctc_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = ctc_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_config() leave: "
-		"config.ce_gain_exp=%d, config.y0=%d, "
-		"config.x1=%d, config.y1=%d, "
-		"config.x2=%d, config.y2=%d, "
-		"config.x3=%d, config.y3=%d, "
-		"config.x4=%d, config.y4=%d\n",
-		(*config)->ce_gain_exp, (*config)->y0,
-		(*config)->x1, (*config)->y1,
-		(*config)->x2, (*config)->y2,
-		(*config)->x3, (*config)->y3,
-		(*config)->x4, (*config)->y4);
-return;
-}
-
-void
-sh_css_set_xnr_config(const struct sh_css_xnr_config *config)
-{
-	if (xnr_config != NULL) {
-		sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_xnr_config() enter: "
-		"config.threshold=%d\n",
-		config->threshold);
-		xnr_config = config;
-	} else {
-		sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_xnr_config() enter: "
-		"default_config.threshold=%d\n",
-		default_xnr_config.threshold);
-		xnr_config = &default_xnr_config;
-	}
-
-	xnr_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_xnr_config() leave: "
-		"return_void\n");
-}
-
-void
-sh_css_get_xnr_config(const struct sh_css_xnr_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = xnr_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_config() leave: "
-		"config.threshold=%d\n",
-		(*config)->threshold);
-}
-
-
-void sh_css_set_aa_config(
-	const struct sh_css_aa_config *config)
-{
-/* config can be NULL */
-
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_aa_config() enter: "
-		"config.scale=%d\n",
-		config->scale);
-		aa_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_aa_config() enter: "
-		"config=%p\n",config);
-		aa_config = &default_aa_config;
-	}
-	aa_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_aa_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_aa_config(
-	const struct sh_css_aa_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_aa_config() enter: "
-		"config=%p\n",config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = aa_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_aa_config() leave: "
-		"config.scale=%d\n",
-		(*config)->scale);
-}
-
-void sh_css_set_r_gamma_table(
-	const struct sh_css_rgb_gamma_table *table)
-{
-/* table can be NULL */
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_r_gamma_table() enter: "
-		"table=%p\n",table);
-
-	r_gamma_table = table;
-	r_gamma_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_r_gamma_table() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_r_gamma_table(
-	const struct sh_css_rgb_gamma_table **table)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_r_gamma_table() enter:\n");
-
-	assert(table != NULL);
-	if (table == NULL)
-		return;
-
-	*table = r_gamma_table;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_r_gamma_table() leave: "
-		"*table=%p\n",*table);
-}
-
-void sh_css_set_g_gamma_table(
-	const struct sh_css_rgb_gamma_table *table)
-{
-/* table can be NULL */
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_g_gamma_table() enter: "
-		"table=%p\n",table);
-
-	g_gamma_table = table;
-	g_gamma_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_g_gamma_table() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_g_gamma_table(
-	const struct sh_css_rgb_gamma_table **table)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() enter:\n");
-
-	assert(table != NULL);
-	if (table == NULL)
-		return;
-
-	*table = g_gamma_table;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() leave: "
-		"*table=%p\n",*table);
-}
-
-void sh_css_set_b_gamma_table(
-	const struct sh_css_rgb_gamma_table *table)
-{
-/* table can be NULL */
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_b_gamma_table() enter: "
-		"table=%p\n",table);
-
-	b_gamma_table = table;
-	b_gamma_table_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_b_gamma_table() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_b_gamma_table(
-	const struct sh_css_rgb_gamma_table **table)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_b_gamma_table() enter:\n");
-
-	assert(table != NULL);
-	if (table == NULL)
-		return;
-
-	*table = b_gamma_table;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() leave: "
-		"*table=%p\n",*table);
-}
-
-void sh_css_set_yuv2rgb_cc_config(
-	const struct sh_css_yuv2rgb_cc_config *config)
-{
-	if (config != NULL) {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_yuv2rgb_cc_config() enter: "
-		"config.m[0]=%d, "
-		"config.m[1]=%d, config.m[2]=%d, "
-		"config.m[3]=%d, config.m[4]=%d, "
-		"config.m[5]=%d, config.m[6]=%d, "
-		"config.m[7]=%d, config.m[8]=%d\n",
-		config->matrix[0],
-		config->matrix[1], config->matrix[2],
-		config->matrix[3], config->matrix[4],
-		config->matrix[5], config->matrix[6],
-		config->matrix[7], config->matrix[8]);
-		yuv2rgb_cc_config = config;
-	} else {
-/* Checkpatch patch */
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_yuv2rgb_cc_config() enter: "
-		"config=%p\n",config);
-		yuv2rgb_cc_config = &disabled_yuv2rgb_cc_config;
-	}
-	yuv2rgb_cc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_yuv2rgb_cc_config() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_yuv2rgb_cc_config(
-	const struct sh_css_yuv2rgb_cc_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_yuv2rgb_cc_config() enter:\n");
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = yuv2rgb_cc_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_yuv2rgb_cc_config() leave: "
-		"config.m[0]=%d, "
-		"config.m[1]=%d, config.m[2]=%d, "
-		"config.m[3]=%d, config.m[4]=%d, "
-		"config.m[5]=%d, config.m[6]=%d, "
-		"config.m[7]=%d, config.m[8]=%d\n",
-		(*config)->matrix[0],
-		(*config)->matrix[1], (*config)->matrix[2],
-		(*config)->matrix[3], (*config)->matrix[4],
-		(*config)->matrix[5], (*config)->matrix[6],
-		(*config)->matrix[7], (*config)->matrix[8]);
-}
-
-void sh_css_set_rgb2yuv_cc_config(
-	const struct sh_css_rgb2yuv_cc_config *config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_rgb2yuv_cc_config()\n");
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_rgb2yuv_cc_config() enter: "
-		"config.m[0]=%d, "
-		"config.m[1]=%d, config.m[2]=%d, "
-		"config.m[3]=%d, config.m[4]=%d, "
-		"config.m[5]=%d, config.m[6]=%d, "
-		"config.m[7]=%d, config.m[8]=%d\n",
-		config->matrix[0],
-		config->matrix[1], config->matrix[2],
-		config->matrix[3], config->matrix[4],
-		config->matrix[5], config->matrix[6],
-		config->matrix[7], config->matrix[8]);
-
-	rgb2yuv_cc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_rgb2yuv_cc_config() leave: return_void\n");
-}
-
-void sh_css_get_rgb2yuv_cc_config(
-	const struct sh_css_rgb2yuv_cc_config **config)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_rgb2yuv_cc_config() enter:\n");
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	*config = rgb2yuv_cc_config;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_rgb2yuv_cc_config() leave: "
-		"config.m[0]=%d, "
-		"config.m[1]=%d, config.m[2]=%d, "
-		"config.m[3]=%d, config.m[4]=%d, "
-		"config.m[5]=%d, config.m[6]=%d, "
-		"config.m[7]=%d, config.m[8]=%d\n",
-		(*config)->matrix[0],
-		(*config)->matrix[1], (*config)->matrix[2],
-		(*config)->matrix[3], (*config)->matrix[4],
-		(*config)->matrix[5], (*config)->matrix[6],
-		(*config)->matrix[7], (*config)->matrix[8]);
-}
-
-/* TODO: make a direct implementation and remove the partial ones */
-/* TODO: use pipe id, currently only one set available */
-void sh_css_set_isp_config(
-	enum sh_css_pipe_id pipe,
-	const struct sh_css_isp_config *config)
-{
-	NOT_USED(pipe);
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_isp_config() enter: pipe=%d, config=%p\n",
-		pipe, config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	sh_css_set_wb_config(&config->wb_config);
-	sh_css_set_cc_config(&config->cc_config);
-	sh_css_set_tnr_config(&config->tnr_config);
-	sh_css_set_ob_config(&config->ob_config);
-	sh_css_set_dp_config(&config->dp_config);
-	sh_css_set_nr_config(&config->nr_config);
-	sh_css_set_ee_config(&config->ee_config);
-	sh_css_set_de_config(&config->de_config);
-	sh_css_set_gc_config(&config->gc_config);
-	sh_css_set_ecd_config(&config->ecd_config);
-	sh_css_set_ynr_config(&config->ynr_config);
-	sh_css_set_fc_config(&config->fc_config);
-	sh_css_set_cnr_config(&config->cnr_config);
-	sh_css_set_macc_config(&config->macc_config);
-	sh_css_set_ctc_config(&config->ctc_config);
-	sh_css_set_aa_config(&config->aa_config);
-	sh_css_set_yuv2rgb_cc_config(&config->yuv2rgb_cc_config);
-	sh_css_set_rgb2yuv_cc_config(&config->rgb2yuv_cc_config);
-	sh_css_set_anr_config(&config->anr_config);
-	sh_css_set_3a_config(&config->s3a_config);
-	sh_css_set_xnr_config(&config->xnr_config);
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_isp_config() leave: return_void\n");
-return;
-}
-
-/* TODO: make a direct implementation and remove the partial ones */
-/* TODO: use pipe id, currently only one set available */
-void sh_css_get_isp_config(
-	enum sh_css_pipe_id pipe,
-	const struct sh_css_isp_config **config)
-{
-	const struct sh_css_wb_config  *wb_config;
-	const struct sh_css_cc_config  *cc_config;
-	const struct sh_css_tnr_config *tnr_config;
-	const struct sh_css_ob_config  *ob_config;
-	const struct sh_css_dp_config  *dp_config;
-	const struct sh_css_nr_config  *nr_config;
-	const struct sh_css_ee_config  *ee_config;
-	const struct sh_css_de_config  *de_config;
-	const struct sh_css_gc_config  *gc_config;
-	const struct sh_css_anr_config *anr_config;
-	const struct sh_css_3a_config  *s3a_config;
-	const struct sh_css_ecd_config *ecd_config;
-	const struct sh_css_ynr_config *ynr_config;
-	const struct sh_css_fc_config  *fc_config;
-	const struct sh_css_cnr_config *cnr_config;
-	const struct sh_css_macc_config *macc_config;
-	const struct sh_css_ctc_config *ctc_config;
-	const struct sh_css_aa_config  *aa_config;
-	const struct sh_css_yuv2rgb_cc_config  *yuv2rgb_cc_config;
-	const struct sh_css_rgb2yuv_cc_config  *rgb2yuv_cc_config;
-	const struct sh_css_xnr_config *xnr_config;
-	NOT_USED(pipe);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_isp_config() enter: "
-		"pipe=%d, config=%p\n",pipe, config);
-
-	assert(config != NULL);
-	if (config == NULL)
-		return;
-
-	assert(*config != NULL);
-	if (*config == NULL)
-		return;
-
-	sh_css_get_wb_config(&wb_config);
-	((struct sh_css_isp_config *)*config)->wb_config = *wb_config;
-	sh_css_get_cc_config(&cc_config);
-	((struct sh_css_isp_config *)*config)->cc_config = *cc_config;
-	sh_css_get_tnr_config(&tnr_config);
-	((struct sh_css_isp_config *)*config)->tnr_config = *tnr_config;
-	sh_css_get_ob_config(&ob_config);
-	((struct sh_css_isp_config *)*config)->ob_config = *ob_config;
-	sh_css_get_dp_config(&dp_config);
-	((struct sh_css_isp_config *)*config)->dp_config = *dp_config;
-	sh_css_get_nr_config(&nr_config);
-	((struct sh_css_isp_config *)*config)->nr_config = *nr_config;
-	sh_css_get_ee_config(&ee_config);
-	((struct sh_css_isp_config *)*config)->ee_config = *ee_config;
-	sh_css_get_de_config(&de_config);
-	((struct sh_css_isp_config *)*config)->de_config = *de_config;
-	sh_css_get_gc_config(&gc_config);
-	((struct sh_css_isp_config *)*config)->gc_config = *gc_config;
-	sh_css_get_anr_config(&anr_config);
-	((struct sh_css_isp_config *)*config)->anr_config = *anr_config;
-	sh_css_get_3a_config(&s3a_config);
-	((struct sh_css_isp_config *)*config)->s3a_config = *s3a_config;
-	sh_css_get_ecd_config(&ecd_config);
-	((struct sh_css_isp_config *)*config)->ecd_config = *ecd_config;
-	sh_css_get_ynr_config(&ynr_config);
-	((struct sh_css_isp_config *)*config)->ynr_config = *ynr_config;
-	sh_css_get_fc_config(&fc_config);
-	((struct sh_css_isp_config *)*config)->fc_config = *fc_config;
-	sh_css_get_cnr_config(&cnr_config);
-	((struct sh_css_isp_config *)*config)->cnr_config = *cnr_config;
-	sh_css_get_macc_config(&macc_config);
-	((struct sh_css_isp_config *)*config)->macc_config = *macc_config;
-	sh_css_get_ctc_config(&ctc_config);
-	((struct sh_css_isp_config *)*config)->ctc_config = *ctc_config;
-	sh_css_get_aa_config(&aa_config);
-	((struct sh_css_isp_config *)*config)->aa_config = *aa_config;
-	sh_css_get_yuv2rgb_cc_config(&yuv2rgb_cc_config);
-	((struct sh_css_isp_config *)*config)->yuv2rgb_cc_config
-		= *yuv2rgb_cc_config;
-	sh_css_get_rgb2yuv_cc_config(&rgb2yuv_cc_config);
-	((struct sh_css_isp_config *)*config)->rgb2yuv_cc_config
-		= *rgb2yuv_cc_config;
-
-	sh_css_get_xnr_config(&xnr_config);
-	((struct sh_css_isp_config *)*config)->xnr_config = *xnr_config;
-
-/* The struct pointers have no information, the functions themselves will print their parameters */
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_isp_config() leave: "
-		"return_void\n");
-return;
-}
-
-void sh_css_set_zoom_factor(
-	unsigned int dx,
-	unsigned int dy)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_zoom_factor() enter: dx=%d, dy=%d\n", dx, dy);
-
-	assert(dx <= HRT_GDC_N);
-	assert(dy <= HRT_GDC_N);
-
-	zoom_config = (struct sh_css_zoom){dx, dy};
-	zoom_config_changed = true;
-	isp_params_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_set_zoom_factor() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_zoom_factor(
-	unsigned int *dx,
-	unsigned int *dy)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_zoom_factor() enter:\n");
-
-	assert(dx != NULL);
-	if (dx == NULL)
-		return;
-	assert(dy != NULL);
-	if (dy == NULL)
-		return;
-
-	*dx = zoom_config.dx;
-	*dy = zoom_config.dy;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_zoom_factor() leave: dx=%d, dy=%d\n", *dx, *dy);
-}
-
-void sh_css_get_zoom(
-	struct sh_css_zoom *zoom)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_zoom() enter:\n");
-
-	assert(zoom != NULL);
-	if (zoom == NULL)
-		return;
-
-	*zoom = zoom_config;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_zoom() leave: dx=%d, dy=%d\n",
-		zoom->dx, zoom->dy);
-}
-
-void sh_css_video_set_dis_vector(
-	int x,
-	int y)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_set_dis_vector() enter: x=%d, y=%d\n",
-		x, y);
-
-	motion_config.x = x;
-	motion_config.y = y;
-
-	motion_config_changed = true;
-	isp_params_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_video_set_dis_vector() leave: "
-		"return_void\n");
-}
-
-void sh_css_get_dis_motion(
-	struct sh_css_vector *motion)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dis_motion() enter\n");
-
-	assert(motion != NULL);
-	if (motion == NULL)
-		return;
-
-	*motion = motion_config;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_get_dis_motion() leave: x=%d, y=%d\n",
-		motion->x, motion->y);
-}
-
-/*
- * coding style says the return of "mmgr_NULL" is the error signal
- *
- * Deprecated: Implement mmgr_realloc()
- */
-static bool realloc_isp_css_mm_buf(
-/* STORAGE_CLASS_INLINE bool realloc_isp_css_mm_buf( */
-	hrt_vaddress *curr_buf, size_t *curr_size,
-	size_t needed_size, bool force, enum sh_css_err *err,
-	uint16_t	mmgr_attribute)
-{
-	int32_t id;
-	*err = sh_css_success;
-	/* Possible optimization: add a function sh_css_isp_css_mm_realloc()
-	 * and implement on top of hmm. */
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() enter:\n");
-
-	if (!force && *curr_size >= needed_size) {
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
-		return false;
-	}
-	/* don't reallocate if single ref to buffer and same size */
-	if (*curr_size == needed_size && sh_css_refcount_is_single(*curr_buf)) {
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
-		return false;
-	}
-
-	id = PARAM_BUFFER;//sh_css_refcount_get_id(*curr_buf);
-	sh_css_refcount_release(id, *curr_buf);
-	*curr_buf = sh_css_refcount_alloc(id, needed_size, mmgr_attribute);
-
-	if (!*curr_buf) {
-		*err = sh_css_err_cannot_allocate_memory;
-		*curr_size = 0;
-	} else {
-		*curr_size = needed_size;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
-	return true;
-}
-
-static bool reallocate_buffer(
-/* STORAGE_CLASS_INLINE bool reallocate_buffer( */
-	hrt_vaddress *curr_buf,
-	size_t *curr_size,
-	size_t needed_size,
-	bool force,
-	enum sh_css_err *err)
-{
-	bool ret;
-	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_buffer() enter:\n");
-
-	ret = realloc_isp_css_mm_buf(curr_buf,
-		curr_size, needed_size, force, err, mmgr_attribute);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_buffer() leave:\n");
-	return ret;
-}
-
-#if 0
-static bool reallocate_cached_buffer(
-/* STORAGE_CLASS_INLINE bool reallocate_cached_buffer( */
-	hrt_vaddress *curr_buf,
-	size_t *curr_size,
-	size_t needed_size,
-	enum sh_css_err *err)
-{
-	bool ret;
-	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT |
-		MMGR_ATTRIBUTE_CACHED;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_cached_buffer() enter:\n");
-
-	ret = realloc_isp_css_mm_buf(curr_buf,
-		curr_size, needed_size, false, err, mmgr_attribute);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_cached_buffer() leave:\n");
-
-	return ret;
-}
-#endif
-
-/* allocate 3A and DIS buffers */
-enum sh_css_err sh_css_allocate_stat_buffers_from_info(
-	union sh_css_s3a_data *s3a_ptr,
-	struct sh_css_dis_data *dvs_ptr,
-	const struct sh_css_grid_info *grid)
-{
-	enum sh_css_err err = sh_css_success;
-	size_t s3a_table_size, dvs_hor_proj_size, dvs_ver_proj_size;
-	const struct sh_css_3a_grid_info *s3a_grid;
-	const struct sh_css_dvs_grid_info *dvs_grid;
-
-	assert(grid != NULL);
-	if (grid == NULL)
-		return sh_css_err_internal_error;
-
-	assert(s3a_ptr != NULL);
-	if (s3a_ptr == NULL)
-		return sh_css_err_internal_error;
-
-	assert(dvs_ptr != NULL);
-	if (dvs_ptr == NULL)
-		return sh_css_err_internal_error;
-
-	s3a_grid = &grid->s3a_grid;
-	dvs_grid = &grid->dvs_grid;
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_allocate_stat_buffers_from_info() "
-		"enter: s3a_ptr=%p, dvs_ptr=%p, "
-		"grid.isp_in_width=%d grid.isp_in_height=%d, "
-		"grid.dvs_hor_coef_num=%d grid.dvs_ver_coef_num=%d\n",
-		s3a_ptr, dvs_ptr,
-		grid->isp_in_width, grid->isp_in_height,
-		grid->dvs_hor_coef_num, grid->dvs_ver_coef_num);
-
-	if (s3a_grid->enable && s3a_grid->use_dmem) {
-		s3a_table_size =
-			sizeof(struct sh_css_3a_output)
-			  * s3a_grid->aligned_width
-			  * s3a_grid->aligned_height;
-			s3a_ptr->dmem.s3a_tbl = mmgr_malloc(s3a_table_size);
-			if (!s3a_ptr->dmem.s3a_tbl) {
-				err = sh_css_err_cannot_allocate_memory;
-				return err;
-			}
-	}
-	if (s3a_grid->enable && !s3a_grid->use_dmem) {
-		s3a_table_size =
-			ISP_S3ATBL_HI_LO_STRIDE_BYTES * s3a_grid->aligned_height;
-		s3a_ptr->vmem.s3a_tbl_hi = mmgr_malloc(s3a_table_size);
-		if (!s3a_ptr->vmem.s3a_tbl_hi) {
-			err = sh_css_err_cannot_allocate_memory;
-			return err;
-		}
-		s3a_ptr->vmem.s3a_tbl_lo = mmgr_malloc(s3a_table_size);
-		if (!s3a_ptr->vmem.s3a_tbl_lo) {
-			err = sh_css_err_cannot_allocate_memory;
-			return err;
-		}
-	}
-	if (dvs_grid->enable) {
-		dvs_hor_proj_size =
-			sizeof(int) * SH_CSS_DIS_NUM_COEF_TYPES
-			* dvs_grid->aligned_height;
-		dvs_ver_proj_size =
-			sizeof(int) * SH_CSS_DIS_NUM_COEF_TYPES
-			* dvs_grid->aligned_width;
-		dvs_ptr->sdis_hor_proj = mmgr_malloc(dvs_hor_proj_size);
-		if (!dvs_ptr->sdis_hor_proj) {
-			err = sh_css_err_cannot_allocate_memory;
-			return err;
-		}
-		dvs_ptr->sdis_ver_proj = mmgr_malloc(dvs_ver_proj_size);
-		if (!dvs_ptr->sdis_hor_proj) {
-/* MW: Memory leak */
-			err = sh_css_err_cannot_allocate_memory;
-			return err;
-		}
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_allocate_stat_buffers_from_info() leave: "
-		"return_err=%d\n",err);
-
-	return err;
-}
-
-void sh_css_free_stat_buffers(
-	union sh_css_s3a_data *s3a_ptr,
-	struct sh_css_dis_data *dvs_ptr)
-{
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_free_stat_buffers() "
-		"enter: s3a_ptr=%p, dvs_ptr=%p\n", s3a_ptr, dvs_ptr);
-
-	if (s3a_ptr) {
-		if (s3a_ptr->vmem.s3a_tbl_hi) {
-			mmgr_free(s3a_ptr->vmem.s3a_tbl_hi);
-		}
-		if (s3a_ptr->vmem.s3a_tbl_lo) {
-			mmgr_free(s3a_ptr->vmem.s3a_tbl_lo);
-		}
-	}
-	if (dvs_ptr) {
-		if (dvs_ptr->sdis_hor_proj) {
-			mmgr_free(dvs_ptr->sdis_hor_proj);
-		}
-		if (dvs_ptr->sdis_ver_proj) {
-			mmgr_free(dvs_ptr->sdis_ver_proj);
-		}
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_free_stat_buffers() leave: "
-		"return_void\n");
-}
-
-enum sh_css_err sh_css_params_init(void)
-{
-	bool succ = true;
-	unsigned i, p;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_init() enter: void\n");
-
-	for (i = 0; i < SH_CSS_NR_OF_PIPELINES; i++) {
-		memset(&pipe_ddr_ptrs[i], 0,
-			sizeof(pipe_ddr_ptrs[i]));
-		memset(&pipe_ddr_ptrs_size[i], 0,
-			sizeof(pipe_ddr_ptrs_size[i]));
-	}
-
-	memset(&ddr_ptrs, 0, sizeof(ddr_ptrs));
-	memset(&ddr_ptrs_size, 0, sizeof(ddr_ptrs_size));
-
-	ddr_ptrs_size.isp_param = sizeof(struct sh_css_isp_params);
-	ddr_ptrs.isp_param = sh_css_refcount_alloc(PARAM_BUFFER,
-				sizeof(struct sh_css_isp_params),
-				MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.isp_param != mmgr_NULL);
-
-	ddr_ptrs_size.ctc_tbl = sizeof(struct sh_css_ctc_table);
-	ddr_ptrs.ctc_tbl =  sh_css_refcount_alloc(PARAM_BUFFER,
-				sizeof(struct sh_css_ctc_table),
-				MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.ctc_tbl != mmgr_NULL);
-
-	ddr_ptrs_size.gamma_tbl = sizeof(struct sh_css_gamma_table);
-	ddr_ptrs.gamma_tbl =  sh_css_refcount_alloc(PARAM_BUFFER,
-				sizeof(struct sh_css_gamma_table),
-				MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.gamma_tbl != mmgr_NULL);
-
-	ddr_ptrs_size.xnr_tbl = sizeof(struct sh_css_xnr_table);
-	ddr_ptrs.xnr_tbl =  sh_css_refcount_alloc(PARAM_BUFFER,
-				sizeof(struct sh_css_xnr_table),
-				MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.xnr_tbl != mmgr_NULL);
-
-	ddr_ptrs_size.macc_tbl = sizeof(struct sh_css_macc_table);
-	ddr_ptrs.macc_tbl = sh_css_refcount_alloc(PARAM_BUFFER,
-				sizeof(struct sh_css_macc_table),
-				MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.macc_tbl != mmgr_NULL);
-
-	ddr_ptrs_size.r_gamma_tbl = sizeof(struct sh_css_rgb_gamma_table);
-	ddr_ptrs.r_gamma_tbl = sh_css_refcount_alloc(PARAM_BUFFER,
-			sizeof(struct sh_css_rgb_gamma_table),
-			MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.r_gamma_tbl != mmgr_NULL);
-
-	ddr_ptrs_size.g_gamma_tbl = sizeof(struct sh_css_rgb_gamma_table);
-	ddr_ptrs.g_gamma_tbl = sh_css_refcount_alloc(PARAM_BUFFER,
-			sizeof(struct sh_css_rgb_gamma_table),
-			MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.g_gamma_tbl != mmgr_NULL);
-
-	ddr_ptrs_size.b_gamma_tbl = sizeof(struct sh_css_rgb_gamma_table);
-	ddr_ptrs.b_gamma_tbl = sh_css_refcount_alloc(PARAM_BUFFER,
-			sizeof(struct sh_css_rgb_gamma_table),
-			MMGR_ATTRIBUTE_DEFAULT);
-	succ &= (ddr_ptrs.b_gamma_tbl != mmgr_NULL);
-
-	sp_ddr_ptrs = sh_css_refcount_alloc(-1,
-			CEIL_MUL(sizeof(ddr_ptrs), HIVE_ISP_DDR_WORD_BYTES),
-			MMGR_ATTRIBUTE_CLEARED);
-	xmem_sp_group_ptrs = sh_css_refcount_alloc(-1,
-					sizeof(struct sh_css_sp_group),
-					MMGR_ATTRIBUTE_CLEARED);
-
-	for (p = 0; p < SH_CSS_NR_OF_PIPELINES; p++) {
-		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
-			xmem_sp_stage_ptrs[p][i] =
-					sh_css_refcount_alloc(-1,
-					    sizeof(struct sh_css_sp_stage),
-					    MMGR_ATTRIBUTE_CLEARED);
-/* MW: memory leak, if you don't want a nice object_free(), then assert */
-			if (xmem_sp_stage_ptrs[p][i] == mmgr_NULL)
-				return sh_css_err_cannot_allocate_memory;
-			xmem_isp_stage_ptrs[p][i] =
-					sh_css_refcount_alloc(-1,
-						sizeof(struct sh_css_isp_stage),
-						MMGR_ATTRIBUTE_CLEARED);
-/* MW: memory leak, if you don't want a nice object_free(), then assert */
-			if (xmem_isp_stage_ptrs[p][i] == mmgr_NULL)
-				return sh_css_err_cannot_allocate_memory;
-		}
-	}
-
-	if (!succ || (sp_ddr_ptrs == mmgr_NULL) ||
-		(xmem_sp_group_ptrs == mmgr_NULL)) {
-		sh_css_uninit();
-		return sh_css_err_cannot_allocate_memory;
-	}
-	sh_css_set_dvs_6axis_config(&default_dvs_6axis_config);
-	sh_css_set_3a_config(&default_3a_config);
-	sh_css_set_wb_config(&default_wb_config);
-	sh_css_set_cc_config(&default_cc_config);
-	sh_css_set_tnr_config(&default_tnr_config);
-	sh_css_set_ob_config(&default_ob_config);
-	sh_css_set_dp_config(&default_dp_config);
-	sh_css_set_nr_config(&default_nr_config);
-	sh_css_set_ee_config(&default_ee_config);
-	sh_css_set_de_config(&default_de_config);
-	sh_css_set_gc_config(&default_gc_config);
-	sh_css_set_anr_config(&default_anr_config);
-	sh_css_set_ce_config(&default_ce_config);
-	sh_css_set_macc_table(&default_macc_table);
-	sh_css_set_gamma_table(&default_gamma_table);
-	sh_css_set_ctc_table(&default_ctc_table);
-	sh_css_set_xnr_table(&default_xnr_table);
-	sh_css_set_ecd_config(&default_ecd_config);
-	sh_css_set_ynr_config(&default_ynr_config);
-	sh_css_set_fc_config(&default_fc_config);
-	sh_css_set_cnr_config(&default_cnr_config);
-	sh_css_set_macc_config(&default_macc_config);
-	sh_css_set_ctc_config(&default_ctc_config);
-	sh_css_set_aa_config(&default_aa_config);
-	sh_css_set_xnr_config(&default_xnr_config);
-	sh_css_set_r_gamma_table(&default_r_gamma_table);
-	sh_css_set_g_gamma_table(&default_g_gamma_table);
-	sh_css_set_b_gamma_table(&default_b_gamma_table);
-	sh_css_set_yuv2rgb_cc_config(&default_yuv2rgb_cc_config);
-	sh_css_set_rgb2yuv_cc_config(&default_rgb2yuv_cc_config);
-	gdc_lut_store(GDC0_ID, zoom_table);
-	{
-		unsigned i;
-		for (i = 0; i < N_GDC_ID; i++)
-			gdc_lut_store(i, zoom_table);
-	}
-	fpn_table_changed = true;
-	isp_parameters.fpn_enabled = 0;
-	morph_table = NULL;
-	morph_table_changed = true;
-
-	sh_css_param_shading_table_init();
-
-	zoom_config = default_zoom_config;
-	zoom_config_changed = true;
-	motion_config = default_motion_config;
-	motion_config_changed = true;
-
-	/* now commit to ddr */
-	sh_css_param_update_isp_params(false);
-
-	/* create per pipe reference to general ddr_ptrs */
-	for (i = 0; i < SH_CSS_NR_OF_PIPELINES; i++) {
-		ref_sh_css_ddr_address_map(&ddr_ptrs, &pipe_ddr_ptrs[i]);
-		pipe_ddr_ptrs_size[i] = ddr_ptrs_size;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sh_css_params_init() leave: "
-		"return_err=%d\n",sh_css_success);
-
-	return sh_css_success;
-}
-
-void sh_css_params_reconfigure_gdc_lut(void)
-{
-	unsigned i;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_reconfigure_gdc_lut() enter: void\n");
-
-	for (i = 0; i < N_GDC_ID; i++)
-		gdc_lut_store(GDC0_ID, zoom_table);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_reconfigure_gdc_lut() leave: return_void\n");
-}
-
-static void free_map_callback(
-	hrt_vaddress ptr)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map_callback() enter:\n");
-
-	free_sh_css_ddr_address_map(ptr);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map_callback() leave:\n");
-}
-
-static void free_buffer_callback(
-	hrt_vaddress ptr)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_buffer_callback() enter:\n");
-
-	mmgr_free(ptr);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_buffer_callback() leave:\n");
-}
-
-void
-sh_css_param_clear_param_sets(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() enter:\n");
-
-	/* hmm_free all param_sets (and buffers) and the free-buffer cache */
-	sh_css_refcount_clear(PARAM_SET_POOL, &free_map_callback);
-	sh_css_refcount_clear(FREE_BUF_CACHE, NULL);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() leave:\n");
-}
-
-/*
- * MW: we can define mmgr_free() to return a NULL
- * then you can write ptr = mmgr_free(ptr);
- */
-#define safe_free(id, x)      \
-	do {                  \
-		sh_css_refcount_release(id, x);     \
-		(x) = mmgr_NULL;  \
-	} while (0)
-
-static void free_map(struct sh_css_ddr_address_map *map)
-{
-	unsigned int i;
-
-	hrt_vaddress *addrs = (hrt_vaddress *)map;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map() enter:\n");
-
-	/* free buffers */
-	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
-						sizeof(size_t)); i++) {
-		if (addrs[i] == mmgr_NULL)
-			continue;
-		safe_free(PARAM_BUFFER, addrs[i]);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map() leave:\n");
-}
-
-void
-sh_css_params_uninit(void)
-{
-	unsigned p, i;
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_uninit() enter:\n");
-
-	/* free existing ddr_ptr maps */
-	for (i = 0; i < SH_CSS_NR_OF_PIPELINES; i++)
-		free_map(&pipe_ddr_ptrs[i]);
-	free_map(&ddr_ptrs);
-
-	safe_free(-1, sp_ddr_ptrs);
-	safe_free(-1, xmem_sp_group_ptrs);
-
-	for (p = 0; p < SH_CSS_NR_OF_PIPELINES; p++)
-		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
-			safe_free(-1, xmem_sp_stage_ptrs[p][i]);
-			safe_free(-1, xmem_isp_stage_ptrs[p][i]);
-		}
-
-	if (fpn_table.data)
-		sh_css_free(fpn_table.data);
-
-	/* go through the pools to clear references */
-	sh_css_refcount_clear(PARAM_SET_POOL, &free_map_callback);
-	sh_css_refcount_clear(PARAM_BUFFER, &free_buffer_callback);
-	sh_css_refcount_clear(-1, &free_buffer_callback);
-	sh_css_refcount_clear(FREE_BUF_CACHE, NULL);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_uninit() leave: return_void\n");
-}
-
-static void write_morph_plane(
-	unsigned short *data,
-	unsigned int width,
-	unsigned int height,
-	hrt_vaddress dest,
-	unsigned int aligned_width)
-{
-	unsigned int i, padding, w;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_morph_plane() enter:\n");
-
-	/* currently we don't have morph table interpolation yet,
-	 * so we allow a wider table to be used. This will be removed
-	 * in the future. */
-	if (width > aligned_width) {
-		padding = 0;
-		w = aligned_width;
-	} else {
-		padding = aligned_width - width;
-		w = width;
-	}
-
-	for (i = 0; i < height; i++) {
-		mmgr_store(dest, data, w * sizeof(short));
-		dest += w * sizeof(short);
-		mmgr_clear(dest, padding * sizeof(short));
-		dest += padding * sizeof(short);
-		data += width;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_morph_plane() leave:\n");
-}
-
-/* Store the DIS coefficients from the 3A library to DDR where the ISP
-   will read them from. The ISP works on a grid that can be larger than
-   that of the 3a library. If that is the case, we padd the difference
-   with zeroes. */
-static void store_dis_coefficients(
-	const struct sh_css_binary *binary,
-	hrt_vaddress ddr_addr_hor,
-	hrt_vaddress ddr_addr_ver)
-{
-	unsigned int hor_num_isp,
-		     ver_num_isp,
-		     hor_num_3a,
-		     ver_num_3a,
-		     hor_padding,
-		     ver_padding,
-		     i;
-	const short *hor_ptr_3a = dis_hor_coef_tbl,
-		*ver_ptr_3a = dis_ver_coef_tbl;
-	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
-		ver_ptr_isp = ddr_addr_ver;
-
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dis_coefficients() enter:\n");
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return;
-	assert(ddr_addr_hor != mmgr_NULL);
-	assert(ddr_addr_ver != mmgr_NULL);
-
-	hor_num_isp = binary->dis_hor_coef_num_isp;
-	ver_num_isp = binary->dis_ver_coef_num_isp;
-	hor_num_3a  = binary->dis_hor_coef_num_3a;
-	ver_num_3a  = binary->dis_ver_coef_num_3a;
-	hor_padding = hor_num_isp - hor_num_3a;
-	ver_padding = ver_num_isp - ver_num_3a;
-
-	for (i = 0; i < SH_CSS_DIS_NUM_COEF_TYPES; i++) {
-		if (dis_hor_coef_tbl != NULL) {
-			mmgr_store(hor_ptr_isp,
-				hor_ptr_3a, hor_num_3a * sizeof(*hor_ptr_3a));
-			hor_ptr_3a  += hor_num_3a;
-		} else {
-			mmgr_clear(hor_ptr_isp,
-				hor_num_3a * sizeof(*hor_ptr_3a));
-		}
-		hor_ptr_isp += hor_num_3a * sizeof(short);
-		mmgr_clear(hor_ptr_isp, hor_padding * sizeof(short));
-		hor_ptr_isp += hor_padding * sizeof(short);
-	}
-	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(binary); i++) {
-		if (dis_ver_coef_tbl != NULL) {
-			mmgr_store(ver_ptr_isp,
-				ver_ptr_3a, ver_num_3a * sizeof(*ver_ptr_3a));
-			ver_ptr_3a  += ver_num_3a;
-		} else {
-			mmgr_clear(ver_ptr_isp,
-				ver_num_3a * sizeof(*ver_ptr_3a));
-		}
-		ver_ptr_isp += ver_num_3a * sizeof(short);
-		mmgr_clear(ver_ptr_isp, ver_padding * sizeof(short));
-		ver_ptr_isp += ver_padding * sizeof(short);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dis_coefficients() leave:\n");
-}
-
-void sh_css_update_isp_params_to_ddr(
-	hrt_vaddress ddr_ptr)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() enter:\n");
-
-#if SH_CSS_PREVENT_UNINIT_READS
-	{
-		/* ispparm struct is read with DMA which reads
-		 * multiples of the DDR word with (32 bytes):
-		 * So we pad with zeroes to prevent warnings in csim.
-		 */
-		unsigned int aligned_width, padding_bytes;
-		hrt_vaddress pad_ptr;
-
-		aligned_width = CEIL_MUL(
-				  sizeof(struct sh_css_isp_params),
-				  HIVE_ISP_DDR_WORD_BYTES);
-		padding_bytes = aligned_width -
-				sizeof(struct sh_css_isp_params);
-		pad_ptr = ddr_ptr +
-				sizeof(struct sh_css_isp_params);
-		mmgr_clear(pad_ptr, padding_bytes);
-	}
-#endif
-	mmgr_store(ddr_ptr,
-	     &isp_parameters,
-	     sizeof(struct sh_css_isp_params));
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() leave:\n");
-}
-
-static void sh_css_dequeue_param_buffers(void)
-{
-	hrt_vaddress cpy;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_dequeue_param_buffers() enter\n");
-
-	/* clean-up old copy */
-	while (sp2host_dequeue_buffer(0, 0,
-				sh_css_param_buffer_queue,
-				&cpy)) {
-		/*
-		 * Tell the SP which queues are not full,
-		 * by sending the software event.
-		 */
-		sh_css_sp_snd_event(SP_SW_EVENT_ID_2,
-				0,
-				sh_css_param_buffer_queue,
-				0);
-
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-			"sh_css_dequeue_param_buffers: "
-			"dequeued param set %x from %d\n",
-			cpy, 0);
-		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-				"sh_css_dequeue_param_buffers: "
-				"release ref on param set %x\n",
-				cpy);
-		free_sh_css_ddr_address_map(cpy);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_dequeue_param_buffers() leave\n");
-}
-/**
- * Function is called from:
- * - s3a when changes to 3a parameters have been applied
- * - after the pipes are created
- * - as a last step in the commit function
- */
-
-void sh_css_update_isp_params(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_update_isp_params() enter: void\n");
-
-	sh_css_param_update_isp_params(true);
-
-	sh_css_dtrace(SH_DBG_TRACE, "sh_css_update_isp_params() leave: return_void\n");
-}
-void
-
-sh_css_param_update_isp_params(bool commit)
-{
-	enum sh_css_err err = sh_css_success;
-	hrt_vaddress cpy;
-	unsigned i, num_pipes;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() enter:\n");
-
-	if (s3a_config && s3a_config_changed)
-		sh_css_process_3a();
-	if (wb_config && wb_config_changed)
-		sh_css_process_wb();
-	if (cc_config && cc_config_changed)
-		sh_css_process_cc();
-	if (tnr_config && tnr_config_changed)
-		sh_css_process_tnr();
-	if (ob_config && ob_config_changed)
-		sh_css_process_ob();
-	if (dp_config && dp_config_changed)
-		sh_css_process_dp();
-	if (nr_config && ee_config && (nr_config_changed || ee_config_changed))
-		sh_css_process_nr_ee();
-	if (de_config && de_config_changed)
-		sh_css_process_de();
-	if (gc_config && gc_config_changed)
-		sh_css_process_gc();
-	if (anr_config && anr_config_changed)
-		sh_css_process_anr();
-	if (ce_config && ce_config_changed)
-		sh_css_process_ce();
-	if (ecd_config && ecd_config_changed)
-		sh_css_process_ecd();
-	if (ynr_config && ynr_config_changed)
-		sh_css_process_ynr();
-	if (fc_config && fc_config_changed)
-		sh_css_process_fc();
-	if (cnr_config && cnr_config_changed)
-		sh_css_process_cnr();
-	if (macc_config && macc_config_changed)
-		sh_css_process_macc();
-	if (ctc_config && ctc_config_changed)
-		sh_css_process_ctc();
-	if (xnr_config && xnr_config_changed)
-		sh_css_process_xnr();
-	if (aa_config && aa_config_changed)
-		sh_css_process_aa();
-	if (yuv2rgb_cc_config && yuv2rgb_cc_config_changed)
-		sh_css_process_yuv2rgb_cc();
-	if (rgb2yuv_cc_config && rgb2yuv_cc_config_changed)
-		sh_css_process_rgb2yuv_cc();
-
-	/* now make the map available to the sp */
-	if (!commit) {
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() leave:\n");
-		return;
-	}
-	/* enqueue a copies of the mem_map to
-	   the designated pipelines */
-	sh_css_pipeline_stream_get_num_pipelines(&num_pipes);
-	for (i = 0; i < num_pipes; i++) {
-		struct sh_css_ddr_address_map *cur_map;
-		struct sh_css_ddr_address_map_size *cur_map_size;
-		struct sh_css_ddr_address_map tmp_map;
-		struct sh_css_pipeline *pipeline;
-		struct sh_css_pipeline_stage *stage;
-		unsigned int thread_id;
-
-		sh_css_pipeline_stream_get_pipeline(i, &pipeline);
-		sh_css_query_sp_thread_id(pipeline->pipe_id,
-					  &thread_id);
-
-		cur_map = &pipe_ddr_ptrs[pipeline->pipe_id];
-		cur_map_size = &pipe_ddr_ptrs_size[pipeline->pipe_id];
-
-		/* TODO: Normally, zoom and motion parameters shouldn't
-		 * be part of "isp_params" as it is resolution/pipe dependant
-		 * Therefore, move the zoom config elsewhere (e.g. shading
-		 * table can be taken as an example! @GC
-		 * */
-		if (isp_params_changed || zoom_config_changed ||
-				motion_config_changed) {
-			/* we have to do this per pipeline because */
-			/* the processing is a.o. resolution dependent */
-			sh_css_process_zoom_and_motion(pipeline->pipe_id,
-							pipeline->stages);
-		}
-		/* update the other buffers to the pipe specific copies */
-		for (stage = pipeline->stages; stage;
-			stage = stage->next) {
-			if (stage && stage->binary) {
-				err =
-				  sh_css_params_write_to_ddr_internal(
-							stage->binary,
-							cur_map,
-							cur_map_size);
-				if (err != sh_css_success)
-					break;
-			}
-		}
-
-		/* update isp_params to pipe specific copies */
-		if (isp_params_changed) {
-			reallocate_buffer(&cur_map->isp_param,
-				  &cur_map_size->isp_param,
-				  cur_map_size->isp_param,
-				  true,
-				  &err);
-			sh_css_update_isp_params_to_ddr(cur_map->isp_param);
-		}
-
-		/* last make referenced copy */
-		err = ref_sh_css_ddr_address_map(
-					cur_map,
-					&tmp_map);
-		/* now write the copy to ddr */
-		write_sh_css_address_map_to_ddr(&tmp_map, &cpy);
-
-		/* [PITBULL] disable for now */
-		/* pqiao: you can disable it forever */
-		//sh_css_enable_sp_invalidate_tlb();
-		/* enqueue the set to sp */
-		if (err == sh_css_success) {
-			bool rc;
-			sh_css_dtrace(SH_DBG_TRACE,
-				"sh_css_param_update_isp_params: "
-				"queue param set %x to %d\n",
-				cpy, thread_id);
-
-			rc = host2sp_enqueue_buffer(thread_id, 0,
-				sh_css_param_buffer_queue,
-				cpy);
-			if (!rc) {
-				free_sh_css_ddr_address_map(cpy);
-			}
-			else {
-#if 0
-				uint32_t tmp[2];
-				uint32_t sw_event;
-
-				/* encode the thread ID and the queue ID into the event*/
-				tmp[0] = thread_id;
-				tmp[1] = sh_css_param_buffer_queue;
-				encode_sw_event(tmp, 2, &sw_event);
-
-				/* queue the software event (busy-waiting) */
-				while (!host2sp_enqueue_sp_event(sw_event))
-					hrt_sleep();
-#else
-				/*
-				 * Tell the SP which queues are not empty,
-				 * by sending the software event.
-				 */
-				sh_css_sp_snd_event(SP_SW_EVENT_ID_1,
-						thread_id,
-						sh_css_param_buffer_queue,
-						0);
-#endif
-
-			}
-		}
-		/* clean-up old copy */
-		sh_css_dequeue_param_buffers();
-	} /* end for each 'active' pipeline */
-	/* clear the changed flags after all params
-	   for all pipelines have been updated */
-	/* only clear the table flag here, other flag is cleared in _process_XXX() function */
-	isp_params_changed = false;
-	fpn_table_changed = false;
-
-	sh_css_param_shading_table_changed_set(false);
-
-	ctc_table_changed = false;
-	xnr_table_changed = false;
-	gamma_table_changed = false;
-	macc_table_changed = false;
-	dis_coef_table_changed = false;
-	morph_table_changed = false;
-	r_gamma_table_changed = false;
-	g_gamma_table_changed = false;
-	b_gamma_table_changed = false;
-	dvs_6axis_config_changed = false;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() leave:\n");
-}
-
-static enum sh_css_err sh_css_params_write_to_ddr_internal(
-	const struct sh_css_binary *binary,
-	struct sh_css_ddr_address_map *ddr_map,
-	struct sh_css_ddr_address_map_size *ddr_map_size)
-{
-	enum sh_css_err err;
-	bool buff_realloced;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() enter:\n");
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return sh_css_err_internal_error;
-	assert(ddr_map != NULL);
-	if (ddr_map == NULL)
-		return sh_css_err_internal_error;
-	assert(ddr_map_size != NULL);
-	if (ddr_map_size == NULL)
-		return sh_css_err_internal_error;
-
-
-	if (binary->info->enable.fpnr) {
-		buff_realloced = reallocate_buffer(&ddr_map->fpn_tbl,
-			&ddr_map_size->fpn_tbl,
-			(size_t)(FPNTBL_BYTES(binary)),
-			fpn_table_changed,
-			&err);
-		if (err != sh_css_success)
-			return err;
-		if (fpn_table_changed || buff_realloced) {
-			if (isp_parameters.fpn_enabled) {
-				store_fpntbl(ddr_map->fpn_tbl);
-			}
-#if SH_CSS_PREVENT_UNINIT_READS
-			else {
-				hrt_vaddress ptr =
-					(hrt_vaddress)ddr_map->fpn_tbl;
-				/* prevent warnings when reading fpn table
-				 * in csim.*/
-				/* Actual values are not used when fpn is
-				 * disabled. */
-				/* MW: fpn_tbl_size*sizeof(whatever)? */
-				mmgr_clear(ptr, ddr_map_size->fpn_tbl);
-			}
-#endif
-		}
-	}
-	if (binary->info->enable.sc) {
-		bool sc_table_changed = sh_css_param_shading_table_changed_get();
-		buff_realloced = reallocate_buffer(&ddr_map->sc_tbl,
-			&ddr_map_size->sc_tbl,
-			(size_t)(SCTBL_BYTES(binary)),
-			sc_table_changed,
-			&err);
-		if (err != sh_css_success)
-			return err;
-		if (sc_table_changed || buff_realloced) {
-			isp_params_changed =
-				sh_css_param_shading_table_store(
-					ddr_map->sc_tbl,
-				sensor_binning,
-				raw_binning,
-				binary);
-			isp_parameters.sc_gain_shift =
-				sh_css_param_shading_table_fraction_bits_get();
-			isp_params_changed = true;
-		}
-	}
-
-	if (ctc_table && ctc_table_changed) {
-		reallocate_buffer(&ddr_map->ctc_tbl,
-				  &ddr_map_size->ctc_tbl,
-				  ddr_map_size->ctc_tbl,
-				  true,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		mmgr_store(ddr_map->ctc_tbl,
-				     ctc_table->data,
-				     sizeof(ctc_table->data));
-	}
-	if (gamma_table && gamma_table_changed) {
-		reallocate_buffer(&ddr_map->gamma_tbl,
-				  &ddr_map_size->gamma_tbl,
-				  ddr_map_size->gamma_tbl,
-				  true,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		mmgr_store(ddr_map->gamma_tbl,
-				     gamma_table->data,
-				     sizeof(gamma_table->data));
-	}
-	if (xnr_table && xnr_table_changed) {
-		reallocate_buffer(&ddr_map->xnr_tbl,
-				  &ddr_map_size->xnr_tbl,
-				  ddr_map_size->xnr_tbl,
-				  true,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		mmgr_store(ddr_map->xnr_tbl,
-				     xnr_table->data,
-				     sizeof(xnr_table->data));
-	}
-	if (macc_table && macc_table_changed) {
-		unsigned int i, j, idx;
-		unsigned int idx_map[] = {
-			0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8};
-
-		for (i = 0; i < SH_CSS_MACC_NUM_AXES; i++) {
-			idx = 4*idx_map[i];
-			j   = 4*i;
-
-			converted_macc_table.data[idx] =
-			    sDIGIT_FITTING(macc_table->data[j], 13,
-			    SH_CSS_MACC_COEF_SHIFT-isp_parameters.exp);
-			converted_macc_table.data[idx+1] =
-			    sDIGIT_FITTING(macc_table->data[j+1], 13,
-			    SH_CSS_MACC_COEF_SHIFT-isp_parameters.exp);
-			converted_macc_table.data[idx+2] =
-			    sDIGIT_FITTING(macc_table->data[j+2], 13,
-			    SH_CSS_MACC_COEF_SHIFT-isp_parameters.exp);
-			converted_macc_table.data[idx+3] =
-			    sDIGIT_FITTING(macc_table->data[j+3], 13,
-			    SH_CSS_MACC_COEF_SHIFT-isp_parameters.exp);
-		}
-		reallocate_buffer(&ddr_map->macc_tbl,
-				  &ddr_map_size->macc_tbl,
-				  ddr_map_size->macc_tbl,
-				  true,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		mmgr_store(ddr_map->macc_tbl,
-				     converted_macc_table.data,
-				     sizeof(converted_macc_table.data));
-	}
-	if (binary->info->enable.dvs_6axis) {
-		buff_realloced = reallocate_buffer(
-				&ddr_map->dvs_6axis_params_y,
-				&ddr_map_size->dvs_6axis_params_y,
-				(size_t)((DVS_6AXIS_BYTES(binary) * 3) / 2), // times 1.5 because UV is packed into the Y plane
-				dvs_6axis_config_changed,
-				&err);
-		if (err != sh_css_success)
-			return err;
-		if (dvs_6axis_config_changed || buff_realloced) {
-			store_dvs_6axis_config(binary,
-				ddr_map->dvs_6axis_params_y);
-		}
-	}
-
-	if (binary->info->enable.dis) {
-		buff_realloced = reallocate_buffer(&ddr_map->sdis_hor_coef,
-				  &ddr_map_size->sdis_hor_coef,
-				  (size_t)(SDIS_HOR_COEF_TBL_BYTES(binary)),
-				  dis_coef_table_changed,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		buff_realloced |= reallocate_buffer(&ddr_map->sdis_ver_coef,
-				  &ddr_map_size->sdis_ver_coef,
-				  (size_t)(SDIS_VER_COEF_TBL_BYTES(binary)),
-				  dis_coef_table_changed,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		if (dis_coef_table_changed || buff_realloced) {
-			store_dis_coefficients(binary,
-				ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
-		}
-	}
-
-	if (binary->info->enable.ca_gdc) {
-		unsigned int i;
-		hrt_vaddress *virt_addr_tetra_x[
-			SH_CSS_MORPH_TABLE_NUM_PLANES] = {
-			&ddr_map->tetra_r_x,
-			&ddr_map->tetra_gr_x,
-			&ddr_map->tetra_gb_x,
-			&ddr_map->tetra_b_x,
-			&ddr_map->tetra_ratb_x,
-			&ddr_map->tetra_batr_x
-		};
-		size_t *virt_size_tetra_x[
-			SH_CSS_MORPH_TABLE_NUM_PLANES] = {
-			&ddr_map_size->tetra_r_x,
-			&ddr_map_size->tetra_gr_x,
-			&ddr_map_size->tetra_gb_x,
-			&ddr_map_size->tetra_b_x,
-			&ddr_map_size->tetra_ratb_x,
-			&ddr_map_size->tetra_batr_x
-		};
-		hrt_vaddress *virt_addr_tetra_y[
-			SH_CSS_MORPH_TABLE_NUM_PLANES] = {
-			&ddr_map->tetra_r_y,
-			&ddr_map->tetra_gr_y,
-			&ddr_map->tetra_gb_y,
-			&ddr_map->tetra_b_y,
-			&ddr_map->tetra_ratb_y,
-			&ddr_map->tetra_batr_y
-		};
-		size_t *virt_size_tetra_y[
-			SH_CSS_MORPH_TABLE_NUM_PLANES] = {
-			&ddr_map_size->tetra_r_y,
-			&ddr_map_size->tetra_gr_y,
-			&ddr_map_size->tetra_gb_y,
-			&ddr_map_size->tetra_b_y,
-			&ddr_map_size->tetra_ratb_y,
-			&ddr_map_size->tetra_batr_y
-		};
-		buff_realloced = false;
-		for (i = 0; i < SH_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-			buff_realloced |=
-					reallocate_buffer(virt_addr_tetra_x[i],
-						virt_size_tetra_x[i],
-						(size_t)
-						  (MORPH_PLANE_BYTES(binary)),
-						morph_table_changed,
-						&err);
-			if (err != sh_css_success)
-				return err;
-			buff_realloced |=
-					reallocate_buffer(virt_addr_tetra_y[i],
-						virt_size_tetra_y[i],
-						(size_t)
-						  (MORPH_PLANE_BYTES(binary)),
-						morph_table_changed,
-						&err);
-			if (err != sh_css_success)
-				return err;
-		}
-		if (morph_table_changed || buff_realloced) {
-			const struct sh_css_morph_table *table = morph_table;
-			struct sh_css_morph_table *default_table = NULL;
-			struct sh_css_morph_table *modified_table = NULL;
-			/* 
-			 * @GC: We expect to receive a morph table with the
-			 * size that the binary expects
-			 */
-			if (table != NULL) {
-				assert(table->width == binary->morph_tbl_width &&
-					table->height == binary->morph_tbl_height);
-			} else {
-				sh_css_params_default_morph_table(
-						&default_table,
-						binary);
-				table = default_table;
-			}
-			sh_css_params_morph_table_shift_phase(table,
-							binary,
-							&modified_table);
-			table = modified_table;
-
-			for (i = 0; i < SH_CSS_MORPH_TABLE_NUM_PLANES; i++) {
-				write_morph_plane(table->coordinates_x[i],
-					table->width,
-					table->height,
-					*virt_addr_tetra_x[i],
-					binary->morph_tbl_aligned_width);
-				write_morph_plane(table->coordinates_y[i],
-					table->width,
-					table->height,
-					*virt_addr_tetra_y[i],
-					binary->morph_tbl_aligned_width);
-			}
-			if (default_table != NULL)
-				sh_css_morph_table_free(default_table);
-			if (modified_table != NULL)
-				sh_css_morph_table_free(modified_table);
-		}
-	}
-	if (r_gamma_table && r_gamma_table_changed) {
-		reallocate_buffer(&ddr_map->r_gamma_tbl,
-				  &ddr_map_size->r_gamma_tbl,
-				  ddr_map_size->r_gamma_tbl,
-				  true,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		mmgr_store(ddr_map->r_gamma_tbl,
-				     r_gamma_table->data,
-				     sizeof(r_gamma_table->data));
-	}
-	if (g_gamma_table && g_gamma_table_changed) {
-		reallocate_buffer(&ddr_map->g_gamma_tbl,
-				  &ddr_map_size->g_gamma_tbl,
-				  ddr_map_size->g_gamma_tbl,
-				  true,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		mmgr_store(ddr_map->g_gamma_tbl,
-				     g_gamma_table->data,
-				     sizeof(g_gamma_table->data));
-	}
-	if (b_gamma_table && b_gamma_table_changed) {
-		reallocate_buffer(&ddr_map->b_gamma_tbl,
-				  &ddr_map_size->b_gamma_tbl,
-				  ddr_map_size->b_gamma_tbl,
-				  true,
-				  &err);
-		if (err != sh_css_success)
-			return err;
-		mmgr_store(ddr_map->b_gamma_tbl,
-				     b_gamma_table->data,
-				     sizeof(b_gamma_table->data));
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() leave:\n");
-
-return sh_css_success;
-}
-
-/**
- * Currently this function is called from:
- *  - sh_css_commit_isp_config
- *    (loops through the stages in a pipe to reconfigure settings)
- */
-enum sh_css_err sh_css_params_write_to_ddr(
-	const struct sh_css_binary *binary)
-{
-	unsigned i;
-	unsigned num_pipes;
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_pipeline *pipeline;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() enter:\n");
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return sh_css_err_internal_error;
-
-	sh_css_pipeline_stream_get_num_pipelines(&num_pipes);
-	for (i = 0; i < num_pipes; i++) {
-		sh_css_pipeline_stream_get_pipeline(i, &pipeline);
-		err = sh_css_params_write_to_ddr_internal(
-					binary,
-					&pipe_ddr_ptrs[pipeline->pipe_id],
-					&pipe_ddr_ptrs_size[pipeline->pipe_id]);
-		if (err != sh_css_success)
-			break;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() leave:\n");
-
-return err;
-}
-
-void
-sh_css_params_set_current_binary(const struct sh_css_binary *binary)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_set_current_binary() enter:\n");
-
-	assert(binary != NULL);
-	if (binary == NULL)
-		return;
-
-	if (binary->info->enable.s3a)
-		current_3a_binary = binary;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_set_current_binary() leave:\n");
-return;
-}
-
-const struct sh_css_fpn_table *sh_css_get_fpn_table(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_get_fpn_table() enter & leave:\n");
-	return &fpn_table;
-}
-
-const struct sh_css_isp_params *sh_css_get_isp_params(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_get_isp_params() enter & leave:\n");
-	return &isp_parameters;
-}
-
-const struct sh_css_binary *sh_css_get_3a_binary(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_get_3a_binary() enter & leave:\n");
-	return current_3a_binary;
-}
-
-void sh_css_get_isp_dis_coefficients(
-	short *horizontal_coefficients,
-	short *vertical_coefficients)
-{
-	unsigned int hor_num_isp, ver_num_isp, i;
-	short *hor_ptr     = horizontal_coefficients,
-		*ver_ptr     = vertical_coefficients;
-	hrt_vaddress hor_ptr_isp;
-	hrt_vaddress ver_ptr_isp;
-
-	struct sh_css_pipeline *pipeline;
-	unsigned num_pipe;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_get_isp_dis_coefficients() enter\n");
-
-	/* TODO: change implementation so it can handle
-		 situation where there are more active
-		 pipes */
-	sh_css_pipeline_stream_get_num_pipelines(&num_pipe);
-	sh_css_pipeline_stream_get_pipeline(0, &pipeline);
-
-	hor_ptr_isp = pipe_ddr_ptrs[pipeline->pipe_id].sdis_hor_coef;
-	ver_ptr_isp = pipe_ddr_ptrs[pipeline->pipe_id].sdis_ver_coef;
-
-/* currently only one pipe supported, update interface if
-   multiple are needed */
-	assert(num_pipe == 1);
-
-	assert(horizontal_coefficients != NULL);
-	if (horizontal_coefficients == NULL)
-		return;
-
-	assert(vertical_coefficients != NULL);
-	if (vertical_coefficients == NULL)
-		return;
-
-	if (current_3a_binary == NULL)
-		return;
-
-	hor_num_isp = current_3a_binary->dis_hor_coef_num_isp;
-	ver_num_isp = current_3a_binary->dis_ver_coef_num_isp;
-
-	for (i = 0; i < SH_CSS_DIS_NUM_COEF_TYPES; i++) {
-		mmgr_load(hor_ptr_isp,
-			hor_ptr, hor_num_isp * sizeof(short));
-		hor_ptr_isp += hor_num_isp * sizeof(short);
-		hor_ptr     += hor_num_isp;
-	}
-	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(current_3a_binary); i++) {
-		mmgr_load(ver_ptr_isp,
-			ver_ptr, ver_num_isp * sizeof(short));
-		ver_ptr_isp += ver_num_isp * sizeof(short);
-		ver_ptr     += ver_num_isp;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_get_isp_dis_coefficients() leave\n");
-	return;
-}
-
-struct sh_css_shading_table *
-sh_css_get_shading_table(void)
-{
-	struct sh_css_shading_table *shading_table;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_get_shading_table() enter:\n");
-
-	shading_table = sh_css_param_shading_table_get(sensor_binning, raw_binning);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_get_shading_table() leave: shading_table=%p\n",
-		shading_table);
-
-	return shading_table;
-}
-
-bool
-sh_css_params_set_shading_table(
-	const struct sh_css_shading_table *table)
-{
-	return sh_css_param_shading_table_set(table);
-}
-
-/* pqiao: this function seems to be not used anywhere,
-	comment it out temporarily */
-#if 0
-void sh_css_get_isp_dis_projections(
-	int *horizontal_projections,
-	int *vertical_projections)
-{
-	unsigned int hor_num_isp, ver_num_isp, i;
-	int *hor_ptr     = horizontal_projections,
-	    *ver_ptr     = vertical_projections;
-	hrt_vaddress hor_ptr_isp = dis_hor_projections[curr_valid_buffer],
-		ver_ptr_isp = dis_ver_projections[curr_valid_buffer];
-
-assert(horizontal_projections != NULL);
-assert(vertical_projections != NULL);
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_get_isp_dis_projections() enter\n");
-
-	if (current_3a_binary == NULL)
-		return;
-
-	hor_num_isp = current_3a_binary->dis_hor_proj_num_isp;
-	ver_num_isp = current_3a_binary->dis_ver_proj_num_isp;
-
-	for (i = 0; i < SH_CSS_DIS_NUM_COEF_TYPES; i++) {
-		mmgr_load(hor_ptr_isp,
-			hor_ptr, hor_num_isp * sizeof(int));
-		hor_ptr_isp += hor_num_isp * sizeof(int);
-		hor_ptr     += hor_num_isp;
-
-		mmgr_load(ver_ptr_isp,
-			ver_ptr, ver_num_isp * sizeof(int));
-		ver_ptr_isp += ver_num_isp * sizeof(int);
-		ver_ptr     += ver_num_isp;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_get_isp_dis_projections() leave\n");
-return;
-}
-#endif
-
-hrt_vaddress sh_css_store_sp_group_to_ddr(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_sp_group_to_ddr() enter & leave:\n");
-	mmgr_store(xmem_sp_group_ptrs,
-			     &sh_css_sp_group,
-			     sizeof(struct sh_css_sp_group));
-	return xmem_sp_group_ptrs;
-}
-
-hrt_vaddress sh_css_store_sp_stage_to_ddr(
-	unsigned pipe,
-	unsigned stage)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_sp_stage_to_ddr() enter & leave:\n");
-	mmgr_store(xmem_sp_stage_ptrs[pipe][stage],
-			     &sh_css_sp_stage,
-			     sizeof(struct sh_css_sp_stage));
-	return xmem_sp_stage_ptrs[pipe][stage];
-}
-
-hrt_vaddress sh_css_store_isp_stage_to_ddr(
-	unsigned pipe,
-	unsigned stage)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_isp_stage_to_ddr() enter & leave:\n");
-	mmgr_store(xmem_isp_stage_ptrs[pipe][stage],
-			     &sh_css_isp_stage,
-			     sizeof(struct sh_css_isp_stage));
-	return xmem_isp_stage_ptrs[pipe][stage];
-}
-
-static enum sh_css_err ref_sh_css_ddr_address_map(
-	struct sh_css_ddr_address_map *map,
-	struct sh_css_ddr_address_map *out)
-{
-	enum sh_css_err err = sh_css_success;
-	unsigned int i;
-
-	hrt_vaddress *in_addrs = (hrt_vaddress *)map;
-	hrt_vaddress *to_addrs = (hrt_vaddress *)out;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() enter:\n");
-
-	if (map == NULL)
-		return sh_css_err_internal_error;
-
-	if (out == NULL)
-		return sh_css_err_internal_error;
-
-	/* copy map using size info */
-	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
-						sizeof(size_t)); i++) {
-		to_addrs[i] = mmgr_NULL;
-		if (in_addrs[i] == mmgr_NULL)
-			continue;
-
-		to_addrs[i] = sh_css_refcount_retain(PARAM_BUFFER, in_addrs[i]);
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() leave:\n");
-
-	return err;
-}
-
-static enum sh_css_err write_sh_css_address_map_to_ddr(
-	struct sh_css_ddr_address_map *me,
-	hrt_vaddress *out)
-{
-	enum sh_css_err err = sh_css_success;
-	bool succ;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() enter:\n");
-
-	assert(me != NULL);
-	if (me == NULL)
-		return sh_css_err_internal_error;
-
-	assert(out != NULL);
-	if (out == NULL)
-		return sh_css_err_internal_error;
-
-	*out = sh_css_refcount_alloc(PARAM_SET_POOL,
-		sizeof(struct sh_css_ddr_address_map), MMGR_ATTRIBUTE_DEFAULT);
-	succ = (*out != mmgr_NULL);
-	if (succ)
-		mmgr_store(*out,
-			me, sizeof(struct sh_css_ddr_address_map));
-	else
-		err = sh_css_err_cannot_allocate_memory;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() leave:\n");
-
-	return err;
-}
-
-static enum sh_css_err free_sh_css_ddr_address_map(
-	hrt_vaddress ptr)
-{
-	enum sh_css_err err = sh_css_success;
-	struct sh_css_ddr_address_map map;
-	unsigned int i;
-	hrt_vaddress *addrs = (hrt_vaddress *)&map;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() enter:\n");
-
-	mmgr_load(ptr, &map, sizeof(struct sh_css_ddr_address_map));
-	/* copy map using size info */
-	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
-						sizeof(size_t)); i++) {
-		if (addrs[i] == mmgr_NULL)
-			continue;
-		sh_css_refcount_release(PARAM_BUFFER, addrs[i]);
-	}
-	sh_css_refcount_release(PARAM_SET_POOL, ptr);
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() leave:\n");
-
-	return err;
-}
-
-/* Mark all parameters as changed to force recomputing the derived ISP parameters */
-void sh_css_invalidate_params(void)
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_invalidate_params() enter:\n");
-
-	isp_params_changed = true;
-	fpn_table_changed = true;
-	dis_coef_table_changed = true;
-	morph_table_changed = true;
-
-	sh_css_param_shading_table_changed_set(true);
-
-	macc_table_changed = true;
-	gamma_table_changed = true;
-	ctc_table_changed = true;
-	xnr_table_changed = true;
-	s3a_config_changed = true;
-	wb_config_changed = true;
-	cc_config_changed = true;
-	tnr_config_changed = true;
-	ob_config_changed = true;
-	dp_config_changed = true;
-	nr_config_changed = true;
-	ee_config_changed = true;
-	de_config_changed = true;
-	gc_config_changed = true;
-	anr_config_changed = true;
-	ce_config_changed = true;
-	zoom_config_changed = true;
-	motion_config_changed = true;
-	dvs_6axis_config_changed = true;
-	fpn_table_changed = true;
-	dis_coef_table_changed = true;
-	morph_table_changed = true;
-	ecd_config_changed = true;
-	ynr_config_changed = true;
-	fc_config_changed = true;
-	cnr_config_changed = true;
-	macc_config_changed = true;
-	ctc_config_changed = true;
-	xnr_config_changed = true;
-	aa_config_changed = true;
-	r_gamma_table_changed = true;
-	g_gamma_table_changed = true;
-	b_gamma_table_changed = true;
-	yuv2rgb_cc_config_changed = true;
-	rgb2yuv_cc_config_changed = true;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_invalidate_params() leave:\n");
-}
-
-void sh_css_update_uds_and_crop_info(
-	const struct sh_css_binary_info *info,
-	const struct sh_css_frame_info *in_frame_info,
-	const struct sh_css_frame_info *out_frame_info,
-	const struct sh_css_dvs_envelope *dvs_env,
-	bool preview_mode,
-	const struct sh_css_zoom *zoom,
-	const struct sh_css_vector *motion_vector,
-	struct sh_css_uds_info *uds,		/* out */
-	struct sh_css_crop_pos *sp_out_crop_pos)/* out */
-{
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_update_uds_and_crop_info() enter:\n");
-
-	assert(info != NULL);
-	if (info == NULL)
-		return;
-
-	assert(in_frame_info != NULL);
-	if (in_frame_info == NULL)
-		return;
-
-	assert(out_frame_info != NULL);
-	if (out_frame_info == NULL)
-		return;
-
-	assert(dvs_env != NULL);
-	if (dvs_env == NULL)
-		return;
-
-	assert(zoom != NULL);
-	if (zoom == NULL)
-		return;
-
-	assert(motion_vector != NULL);
-	if (motion_vector == NULL)
-		return;
-
-	assert(uds != NULL);
-	if (uds == NULL)
-		return;
-
-	assert(sp_out_crop_pos != NULL);
-	if (sp_out_crop_pos == NULL)
-		return;
-
-	if (info->mode == SH_CSS_BINARY_MODE_VF_PP && !preview_mode) {
-		/* in non-preview modes, VF_PP does not do
-		   the zooming, capture_pp or video do. */
-		uds->curr_dx = HRT_GDC_N;
-		uds->curr_dy = HRT_GDC_N;
-	} else {
-		uds->curr_dx   = zoom->dx;
-		uds->curr_dy   = zoom->dy;
-	}
-
-	if (info->enable.dvs_envelope) {
-		unsigned int crop_x = 0,
-			     crop_y = 0,
-			     uds_xc = 0,
-			     uds_yc = 0,
-			     env_width, env_height;
-		int half_env_x, half_env_y;
-		int motion_x = motion_vector->x;
-		int motion_y = motion_vector->y;
-		bool upscale_x = in_frame_info->width < out_frame_info->width;
-		bool upscale_y = in_frame_info->height < out_frame_info->height;
-
-		if (info->enable.uds && !info->enable.ds) {
-			/**
-			 * we calculate with the envelope that we can actually
-			 * use, the min dvs envelope is for the filter
-			 * initialization.
-			 */
-			env_width  = dvs_env->width -
-					SH_CSS_MIN_DVS_ENVELOPE;
-			env_height = dvs_env->height -
-					SH_CSS_MIN_DVS_ENVELOPE;
-			half_env_x = env_width / 2;
-			half_env_y = env_height / 2;
-			/**
-			 * for digital zoom, we use the dvs envelope and make
-			 * sure that we don't include the 8 leftmost pixels or
-			 * 8 topmost rows.
-			 */
-			if (upscale_x) {
-				uds_xc = (in_frame_info->width
-					+ env_width
-					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
-			} else {
-				uds_xc = (out_frame_info->width
-							+ env_width) / 2
-					+ SH_CSS_MIN_DVS_ENVELOPE;
-			}
-			if (upscale_y) {
-				uds_yc = (in_frame_info->height
-					+ env_height
-					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
-			} else {
-				uds_yc = (out_frame_info->height
-							+ env_height) / 2
-					+ SH_CSS_MIN_DVS_ENVELOPE;
-			}
-			/* clip the motion vector to +/- half the envelope */
-			motion_x = clamp(motion_x, -half_env_x, half_env_x);
-			motion_y = clamp(motion_y, -half_env_y, half_env_y);
-			uds_xc += motion_x;
-			uds_yc += motion_y;
-			/* uds can be pipelined, remove top lines */
-			crop_y = 2;
-		} else if (info->enable.ds) {
-			env_width  = dvs_env->width;
-			env_height = dvs_env->height;
-			half_env_x = env_width / 2;
-			half_env_y = env_height / 2;
-			/* clip the motion vector to +/- half the envelope */
-			motion_x = clamp(motion_x, -half_env_x, half_env_x);
-			motion_y = clamp(motion_y, -half_env_y, half_env_y);
-			/* for video with downscaling, the envelope is included
-			    in the input resolution. */
-			uds_xc = in_frame_info->width/2 + motion_x;
-			uds_yc = in_frame_info->height/2 + motion_y;
-			crop_x = info->left_cropping;
-			/* ds == 2 (yuv_ds) can be pipelined, remove top
-			   lines */
-			if (info->enable.ds & 1)
-				crop_y = info->top_cropping;
-			else
-				crop_y = 2;
-		} else {
-			/* video nodz: here we can only crop. We make sure we
-			   crop at least the first 8x8 pixels away. */
-			env_width  = dvs_env->width -
-					SH_CSS_MIN_DVS_ENVELOPE;
-			env_height = dvs_env->height -
-					SH_CSS_MIN_DVS_ENVELOPE;
-			half_env_x = env_width / 2;
-			half_env_y = env_height / 2;
-			motion_x = clamp(motion_x, -half_env_x, half_env_x);
-			motion_y = clamp(motion_y, -half_env_y, half_env_y);
-			crop_x = SH_CSS_MIN_DVS_ENVELOPE
-						+ half_env_x + motion_x;
-			crop_y = SH_CSS_MIN_DVS_ENVELOPE
-						+ half_env_y + motion_y;
-		}
-
-		/* Must enforce that the crop position is even */
-		crop_x = EVEN_FLOOR(crop_x);
-		crop_y = EVEN_FLOOR(crop_y);
-		uds_xc = EVEN_FLOOR(uds_xc);
-		uds_yc = EVEN_FLOOR(uds_yc);
-
-		uds->xc = uds_xc;
-		uds->yc = uds_yc;
-		sp_out_crop_pos->x = crop_x;
-		sp_out_crop_pos->y = crop_y;
-	}
-	else {
-		/* for down scaling, we always use the center of the image */
-		uds->xc = in_frame_info->width / 2;
-		uds->yc = in_frame_info->height / 2;
-		sp_out_crop_pos->x = info->left_cropping;
-		sp_out_crop_pos->y = info->top_cropping;
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_uds_and_crop_info() leave:\n");
-return;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.h
deleted file mode 100644
index 02c877f..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params.h
+++ /dev/null
@@ -1,405 +0,0 @@
-#ifndef _SH_CSS_PARAMS_H_
-#define _SH_CSS_PARAMS_H_
-
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-/*! \file */
-
-#include "sh_css_types.h"	/* struct sh_css_ecd_config,... */
-#include "sh_css.h"
-
-/* TODO: remove most of the individual parameter functions.
- * These will be combined in sh_css_set_isp_config.
- * The remaining function should get an extra pipe-id argument.
- */
-
-int sh_css_get_gdc_coord_one(void);
-
-/* DIS */
-/* get the pointers to the dis coefficient tables.
- * These tables will then be written by the caller and the
- * values will be sent to the ISP upon the next start of frame.
- */
-void sh_css_set_dis_coefficients(
-	const short *horizontal_coefs,
-	const short *vertical_coefs);
-
-void sh_css_get_dis_projections(
-	int *horizontal_projections,
-	int *vertical_projections,
-	struct sh_css_dis_data *dis_data);
-
-/* 3A */
-enum sh_css_err sh_css_get_3a_statistics(
-	struct sh_css_3a_output *output,
-	bool use_dmem,
-	union sh_css_s3a_data *s3a_data);
-
-void sh_css_set_3a_config(
-	const struct sh_css_3a_config *config);
-
-void sh_css_get_3a_config(
-	const struct sh_css_3a_config **config);
-
-/** @brief Configure an image pipe with filter coefficients.
- *
- * @param[in]	pipe	The pipe to be configured.
- * @param[in]	config	The set of filter coefficients.
- * @return		IA_CSS_SUCCESS or error code upon error.
- *
- * This function configures the filter coefficients for an image
- * pipe. For image pipes that do not execute any ISP filters, this
- * function will have no effect.
- * It is safe to call this function while the image pipe is running,
- * in fact this is the expected behavior most of the time. Proper
- * resource locking and double buffering is in place to allow for this.
- */
-void
-sh_css_set_isp_config(enum sh_css_pipe_id pipe,
-		      const struct sh_css_isp_config *config);
-
-void
-sh_css_get_isp_config(enum sh_css_pipe_id pipe,
-		      const struct sh_css_isp_config **config);
-
-/** @brief Set the digital zoom factor.
- *
- * @param[in]	dx	The horizontal zoom factor.
- * @param[in]	dy	The vertical zoom factor.
- *
- * Digital zoom: this feature can be configured with a zoom factor
- * which determines the amount of zoom and a zoom center which determines
- * the point to zoom in at.
- * This feature is currently available only for video, but will become
- * available for preview and capture as well.
- * Set the digital zoom factor, this is a logarithmic scale. The actual zoom
- * factor will be 64/x.
- * Setting dx or dy to 0 disables digital zoom for that direction.
- */
-void
-sh_css_set_zoom_factor(unsigned int dx, unsigned int dy);
-
-/** @brief Get the digital zoom factor.
- *
- * @param[out]	dx	Pointer to the horizontal zoom factor.
- * @param[out]	dy	Pointer to the vertical zoom factor.
- *
- * Get the current zoom factor. This will return the same values as were set
- * during the last video_set_zoom_factor() call.
- */
-void
-sh_css_get_zoom_factor(unsigned int *dx, unsigned int *dy);
-
-void
-sh_css_get_zoom(struct sh_css_zoom *zoom);
-
-/** @brief Set the motion vector for DVS.
- *
- * @param	x	Horizontal motion vector.
- * @param	y	Vertical motion vector.
- *
- * Set the motion vector for Digital Video Stabilization (DVS).
- * These positions are normally calculated using the DVS statistics.
- */
-void
-sh_css_video_set_dis_vector(int x, int y);
-
-void
-sh_css_get_dis_motion(struct sh_css_vector *motion);
-
-/** @brief Set the color shading table.
- *
- * @param[in]	table	The shading table itself.
- *
- * Set the shading table for the current sensor module. This table will be
- * used for shading correction in each mode that supports this feature.
- */
-
-/* FPN */
-enum sh_css_err
-sh_css_set_black_frame(const struct sh_css_frame *raw_black_frame);
-
-void
-sh_css_set_morph_table(const struct sh_css_morph_table *table);
-
-void
-sh_css_get_morph_table(const struct sh_css_morph_table **table);
-
-struct sh_css_morph_table *
-sh_css_morph_table_allocate(unsigned int width, unsigned int height);
-
-void
-sh_css_morph_table_free(struct sh_css_morph_table *me);
-
-/* White Balance */
-void
-sh_css_set_wb_config(const struct sh_css_wb_config *wb_config);
-
-void
-sh_css_get_wb_config(const struct sh_css_wb_config **wb_config);
-
-/* Color Correction */
-void
-sh_css_set_cc_config(const struct sh_css_cc_config *cc_config);
-
-void
-sh_css_get_cc_config(const struct sh_css_cc_config **cc_config);
-
-/* TNR */
-void
-sh_css_set_tnr_config(const struct sh_css_tnr_config *tnr_config);
-
-void
-sh_css_get_tnr_config(const struct sh_css_tnr_config **tnr_config);
-
-/* ANR */
-void
-sh_css_set_anr_config(const struct sh_css_anr_config *anr_config);
-
-void
-sh_css_get_anr_config(const struct sh_css_anr_config **anr_config);
-
-/* Objective Black */
-void
-sh_css_set_ob_config(const struct sh_css_ob_config *ob_config);
-
-void
-sh_css_get_ob_config(const struct sh_css_ob_config **ob_config);
-
-/* Dead Pixel */
-void
-sh_css_set_dp_config(const struct sh_css_dp_config *dp_config);
-
-void
-sh_css_get_dp_config(const struct sh_css_dp_config **dp_config);
-
-/* Noise Reduction */
-void
-sh_css_set_nr_config(const struct sh_css_nr_config *nr_config);
-
-void
-sh_css_get_nr_config(const struct sh_css_nr_config **nr_config);
-
-/* Edge Enhancement */
-void
-sh_css_set_ee_config(const struct sh_css_ee_config *ee_config);
-
-void
-sh_css_get_ee_config(const struct sh_css_ee_config **ee_config);
-
-/* Demosaic */
-void
-sh_css_set_de_config(const struct sh_css_de_config *de_config);
-
-void
-sh_css_get_de_config(const struct sh_css_de_config **de_config);
-
-/* Color Enhancement */
-void
-sh_css_set_ce_config(const struct sh_css_ce_config *ce_config);
-
-void
-sh_css_get_ce_config(const struct sh_css_ce_config **ce_config);
-
-/* Eigen Color Demosaicing */
-void
-sh_css_set_ecd_config(const struct sh_css_ecd_config *ecd_config);
-
-void
-sh_css_get_ecd_config(const struct sh_css_ecd_config **ecd_config);
-
-/* Y(Luma) Noise Reduction */
-void
-sh_css_set_ynr_config(const struct sh_css_ynr_config *ynr_config);
-
-void
-sh_css_get_ynr_config(const struct sh_css_ynr_config **ynr_config);
-
-/* Fringe Control */
-void
-sh_css_set_fc_config(const struct sh_css_fc_config *fc_config);
-
-void
-sh_css_get_fc_config(const struct sh_css_fc_config **fc_config);
-
-/* Chroma Noise Reduction */
-void
-sh_css_set_cnr_config(const struct sh_css_cnr_config *cnr_config);
-
-void
-sh_css_get_cnr_config(const struct sh_css_cnr_config **cnr_config);
-
-/* MACC */
-void
-sh_css_set_macc_config(const struct sh_css_macc_config *macc_config);
-
-void
-sh_css_get_macc_config(const struct sh_css_macc_config **macc_config);
-
-/* Chroma Tone Control */
-void
-sh_css_set_ctc_config(const struct sh_css_ctc_config *ctc_config);
-
-void
-sh_css_get_ctc_config(const struct sh_css_ctc_config **ctc_config);
-
-/* Anti-Aliasing */
-void
-sh_css_set_aa_config(const struct sh_css_aa_config *aa_config);
-
-void
-sh_css_get_aa_config(const struct sh_css_aa_config **aa_config);
-
-/* Gamma Correction */
-void
-sh_css_set_gc_config(const struct sh_css_gc_config *gc_config);
-
-void
-sh_css_get_gc_config(const struct sh_css_gc_config **gc_config);
-
-void
-sh_css_set_gamma_table(const struct sh_css_gamma_table *table);
-
-void
-sh_css_get_gamma_table(const struct sh_css_gamma_table **table);
-
-void
-sh_css_set_ctc_table(const struct sh_css_ctc_table *table);
-
-void
-sh_css_get_ctc_table(const struct sh_css_ctc_table **table);
-
-void
-sh_css_set_xnr_table(const struct sh_css_xnr_table *table);
-
-void
-sh_css_get_xnr_table(const struct sh_css_xnr_table **table);
-
-void
-sh_css_set_xnr_config(const struct sh_css_xnr_config *xnr_config);
-
-void
-sh_css_get_xnr_config(const struct sh_css_xnr_config **xnr_config);
-
-/* Multi-Access Color Correction */
-void
-sh_css_set_macc_table(const struct sh_css_macc_table *table);
-
-void
-sh_css_get_macc_table(const struct sh_css_macc_table **table);
-
-/* 6-axis DVS */
-void
-sh_css_set_dvs_6axis_config(const struct sh_css_dvs_6axis_config *dvs_config);
-
-void
-sh_css_get_dvs_6axis_config(const struct sh_css_dvs_6axis_config **dvs_config);
-
-/* sRGB Gamma Correction */
-void
-sh_css_set_r_gamma_table(const struct sh_css_rgb_gamma_table *table);
-
-void
-sh_css_get_r_gamma_table(const struct sh_css_rgb_gamma_table **table);
-
-void
-sh_css_set_g_gamma_table(const struct sh_css_rgb_gamma_table *table);
-
-void
-sh_css_get_g_gamma_table(const struct sh_css_rgb_gamma_table **table);
-
-void
-sh_css_set_b_gamma_table(const struct sh_css_rgb_gamma_table *table);
-
-void
-sh_css_get_b_gamma_table(const struct sh_css_rgb_gamma_table **table);
-
-void
-sh_css_set_yuv2rgb_cc_config(const struct sh_css_yuv2rgb_cc_config *config);
-
-void
-sh_css_get_yuv2rgb_cc_config(const struct sh_css_yuv2rgb_cc_config **config);
-
-void
-sh_css_set_rgb2yuv_cc_config(const struct sh_css_rgb2yuv_cc_config *config);
-
-void
-sh_css_get_rgb2yuv_cc_config(const struct sh_css_rgb2yuv_cc_config **config);
-
-/* Shading Correction */
-bool
-sh_css_params_set_binning_factor(unsigned int sensor_binning);
-
-void
-sh_css_params_set_raw_binning(bool needs_raw_binning);
-
-bool
-sh_css_params_set_shading_table(
-	const struct sh_css_shading_table *table);
-
-void sh_css_shading_table_free(
-	struct sh_css_shading_table *table);
-
-struct sh_css_shading_table *
-sh_css_shading_table_alloc(unsigned int width,
-			   unsigned int height);
-
-struct sh_css_s3a_dis_buffer_info {
-	bool enable_s3a;
-	bool enable_dis;
-	bool s3atbl_use_dmem;
-	int  s3atbl_width;
-	int  s3atbl_height;
-	int  s3atbl_isp_width;
-	int  s3atbl_isp_height;
-	int  dis_hor_proj_num_isp;
-	int  dis_ver_proj_num_isp;
-	int  dis_hor_proj_num_3a;
-	int  dis_ver_proj_num_3a;
-	int  deci_factor_log2;
-};
-
-enum sh_css_err sh_css_allocate_stat_buffers_from_info(
-	union sh_css_s3a_data *s3a_ptr,
-	struct sh_css_dis_data *dvs_ptr,
-	const struct sh_css_grid_info *info);
-
-void
-sh_css_free_stat_buffers(union sh_css_s3a_data *s3a_ptr,
-	struct sh_css_dis_data *dis_ptr);
-
-void
-sh_css_update_uds_and_crop_info(
-		const struct sh_css_binary_info *info,
-		const struct sh_css_frame_info *in_frame_info,
-		const struct sh_css_frame_info *out_frame_info,
-		const struct sh_css_dvs_envelope *dvs_env,
-		bool preview_mode,
-		const struct sh_css_zoom *zoom,
-		const struct sh_css_vector *motion_vector,
-		struct sh_css_uds_info *uds,		/* out */
-		struct sh_css_crop_pos *sp_out_crop_pos	/* out */
-		);
-
-#endif /* _SH_CSS_PARAMS_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params_internal.h
deleted file mode 100644
index 933477e..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_params_internal.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_PARAMS_INTERNAL_H_
-#define _SH_CSS_PARAMS_INTERNAL_H_
-
-void
-sh_css_param_update_isp_params(bool commit);
-
-void
-sh_css_invalidate_params(void);
-
-void
-sh_css_param_clear_param_sets(void);
-
-#endif /* _SH_CSS_PARAMS_INTERNAL_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.c
deleted file mode 100644
index 6e30ef4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.c
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "sh_css_pipeline.h"
-#include "sh_css.h"
-#include "sh_css_defs.h"
-
-#include "sh_css_hrt.h"
-
-#include "platform_support.h"
-
-#include "assert_support.h"
-
-static struct sh_css_stream my_stream;
-
-void
-sh_css_pipeline_stream_add_pipeline(struct sh_css_pipeline *pipeline)
-{
-	struct sh_css_stream_pipeline *me =
-		sh_css_malloc(sizeof(struct sh_css_stream_pipeline));
-	struct sh_css_stream_pipeline *curr;
-
-	assert(me != NULL);
-	if (me == NULL)
-		return;
-
-	me->pipeline = pipeline;
-	me->next = NULL;
-
-	if (!my_stream.pipelines)
-		my_stream.pipelines = me;
-	else {
-		for (curr = my_stream.pipelines; curr; curr = curr->next) {
-			if (!curr->next) {
-				curr->next = me;
-				break;
-			}
-		}
-	}
-	my_stream.num_pipelines += 1;
-}
-
-void
-sh_css_pipeline_stream_clear_pipelines(void)
-{
-	struct sh_css_stream_pipeline *curr;
-	struct sh_css_stream_pipeline *tofree;
-	for (curr = my_stream.pipelines; curr;) {
-		if (curr) {
-			tofree = curr;
-			curr = curr->next;
-			sh_css_free(tofree);
-		}
-	}
-	my_stream.pipelines = NULL;
-	my_stream.num_pipelines = 0;
-}
-
-void
-sh_css_pipeline_stream_get_num_pipelines(unsigned *num_pipelines)
-{
-	if (num_pipelines)
-		*num_pipelines = my_stream.num_pipelines;
-}
-
-void
-sh_css_pipeline_stream_get_pipeline(
-	unsigned pipe_num,
-	struct sh_css_pipeline **pipeline)
-{
-	struct sh_css_stream_pipeline *curr;
-	unsigned i;
-
-	if (!pipeline)
-		return;
-
-	curr = my_stream.pipelines;
-	for (i = 0; i < pipe_num; i++) {
-		curr = curr->next;
-		if (!curr) {
-			/* no pipeline found */
-			*pipeline = NULL;
-			return;
-		}
-	}
-	*pipeline = curr->pipeline;
-}
-
-void
-sh_css_pipeline_stream_test(void)
-{
-	unsigned num, i;
-	sh_css_pipeline_stream_get_num_pipelines(&num);
-	if (num) {
-		for (i = 0; i < num; i++) {
-			struct sh_css_pipeline *pipeline;
-			sh_css_pipeline_stream_get_pipeline(i, &pipeline);
-		}
-	}
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.h
deleted file mode 100644
index 2284418..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_pipeline.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_PIPELINE_H_
-#define _SH_CSS_PIPELINE_H_
-
-#include "sh_css.h"
-#include "sh_css_binary.h"
-#include "sh_css_internal.h"
-
-struct sh_css_stream_pipeline {
-	struct sh_css_pipeline *pipeline;
-	struct sh_css_stream_pipeline *next;
-};
-
-struct sh_css_stream {
-	struct sh_css_stream_pipeline *pipelines;
-	unsigned num_pipelines;
-};
-
-void
-sh_css_pipeline_stream_add_pipeline(struct sh_css_pipeline *pipeline);
-
-void
-sh_css_pipeline_stream_clear_pipelines(void);
-
-void
-sh_css_pipeline_stream_get_num_pipelines(unsigned *num_pipelines);
-
-void
-sh_css_pipeline_stream_get_pipeline(
-			unsigned pipe_num,
-			struct sh_css_pipeline **pipeline);
-
-void
-sh_css_pipeline_stream_test(void);
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.c
deleted file mode 100644
index 112474c..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.c
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "sh_css_refcount.h"
-#include "memory_access/memory_access.h"
-#include "sh_css_defs.h"
-
-#include "platform_support.h"
-
-#include "assert_support.h"
-
-#include "sh_css_debug.h"
-
-/* TODO: enable for other memory aswell
-	 now only for hrt_vaddress */
-struct sh_css_refcount_entry {
-	uint32_t count;
-	hrt_vaddress data;
-	size_t size;
-	int32_t id;
-};
-
-struct sh_css_refcount_list {
-	uint32_t size;
-	struct sh_css_refcount_entry *items;
-};
-
-static struct sh_css_refcount_list myrefcount;
-
-int sh_css_refcount_used(void)
-{
-	uint32_t i;
-	int used = 0;
-	for (i = 0; i < myrefcount.size; i++) {
-		if (myrefcount.items[i].data != mmgr_NULL)
-			++used;
-	}
-	return used;
-}
-
-static struct sh_css_refcount_entry *find_entry(hrt_vaddress ptr)
-{
-	uint32_t i;
-
-assert(ptr != 0);
-assert(myrefcount.items != NULL);
-	if (myrefcount.items == NULL)
-		return NULL;
-
-	for (i = 0; i < myrefcount.size; i++) {
-		if (myrefcount.items[i].data == ptr) {
-			/* found entry */
-			return &myrefcount.items[i];
-		}
-	}
-	return NULL;
-}
-
-static struct sh_css_refcount_entry *find_free_entry(hrt_vaddress ptr)
-{
-	uint32_t i;
-
-assert(ptr != 0);
-assert(myrefcount.items != NULL);
-	if (myrefcount.items == NULL)
-		return NULL;
-
-	for (i = 0; i < myrefcount.size; i++) {
-		if (myrefcount.items[i].data == 0)
-			return &myrefcount.items[i];
-	}
-	return NULL;
-}
-
-
-enum sh_css_err sh_css_refcount_init(void)
-{
-	enum sh_css_err err = sh_css_success;
-	int size = 2000;
-
-assert(myrefcount.items == NULL);
-
-	myrefcount.items =
-		sh_css_malloc(sizeof(struct sh_css_refcount_entry)*size);
-	if (!myrefcount.items)
-		err = sh_css_err_cannot_allocate_memory;
-	if (err == sh_css_success) {
-		memset(myrefcount.items, 0,
-			   sizeof(struct sh_css_refcount_entry)*size);
-		myrefcount.size = size;
-	}
-	return err;
-}
-
-void sh_css_refcount_uninit(void)
-{
-	struct sh_css_refcount_entry *entry;
-	uint32_t i;
-	for (i = 0; i < myrefcount.size; i++) {
-		entry = &myrefcount.items[i];
-		if (entry->data != mmgr_NULL) {
-/*			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-				"sh_css_refcount_uninit: freeing (%x)\n",
-				entry->data);*/
-			mmgr_free(entry->data);
-			entry->data = mmgr_NULL;
-			entry->size = 0;
-			entry->count = 0;
-			entry->id = 0;
-		}
-	}
-	sh_css_free(myrefcount.items);
-	myrefcount.items = NULL;
-	myrefcount.size = 0;
-}
-
-hrt_vaddress sh_css_refcount_alloc(
-	int32_t id, const size_t size, const uint16_t attribute)
-{
-	hrt_vaddress ptr;
-	struct sh_css_refcount_entry *entry = NULL;
-	uint32_t i;
-
-	assert(size > 0);
-	assert(id != FREE_BUF_CACHE);
-
-	for (i = 0; i < myrefcount.size; i++) {
-		entry = &myrefcount.items[i];
-		if ((entry->id == FREE_BUF_CACHE) && (entry->size == size)) {
-			entry->id = id;
-			assert(entry->count == 0);
-			entry->count = 1;
-			assert(entry->data != mmgr_NULL);
-			if (attribute & MMGR_ATTRIBUTE_CLEARED)
-				mmgr_clear(entry->data, size);
-			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-				"sh_css_refcount_alloc(%x) 0x%x "
-				"reused from cache, refcnt %d\n",
-				id, entry->data, entry->count);
-
-			return entry->data;
-		}
-	}
-
-	ptr = mmgr_alloc_attr(size, attribute);
-	assert(ptr != mmgr_NULL);
-
-	/* This address should not exist in the administration yet */
-	assert(!find_entry(ptr));
-	entry = find_free_entry(ptr);
-
-	assert(entry != NULL);
-	if (entry == NULL)
-		return mmgr_NULL;
-	assert(entry->data == mmgr_NULL);
-	
-
-	entry->id = id;
-	entry->data = ptr;
-	entry->size = size;
-	entry->count = 1;
-
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_refcount_alloc(%x) 0x%x "
-		"new alloc refcnt %d\n",
-		id, ptr, entry->count);
-
-
-	return ptr;
-}
-
-hrt_vaddress sh_css_refcount_retain(int32_t id, hrt_vaddress ptr)
-{
-	struct sh_css_refcount_entry *entry;
-
-	assert(id != FREE_BUF_CACHE);
-
-	assert(ptr != mmgr_NULL);
-	entry = find_entry(ptr);
-
-	assert(entry != NULL);
-	if (entry == NULL)
-		return mmgr_NULL;
-	assert(entry->id == id);
-	assert(entry->data == ptr);
-
-	entry->count += 1;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_refcount_retain(%x) 0x%x new refcnt %d\n",
-		id, ptr, entry->count );
-	return ptr;
-}
-
-bool sh_css_refcount_release(int32_t id, hrt_vaddress ptr)
-{
-	struct sh_css_refcount_entry *entry;
-
-	assert(id != FREE_BUF_CACHE);
-
-	if (ptr == mmgr_NULL)
-		return false;
-
-	entry = find_entry(ptr);
-
-	if (entry) {
-		assert(entry->id == id);
-		if (entry->count > 0) {
-			entry->count -= 1;
-			if (entry->count == 0) {
-/*				sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-					"sh_css_refcount_release: freeing\n");*/
-				entry->id = FREE_BUF_CACHE;
-				sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-					"sh_css_refcount_release(%x) 0x%x "
-					"new refcnt 0, returned to cache\n",
-					id, ptr);
-			} else {
-				sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-					"sh_css_refcount_release(%x) 0x%x "
-					"new refcnt %d\n",
-					id, ptr, entry->count );
-			}
-			return true;
-		}
-	}
-
-/* SHOULD NOT HAPPEN: ptr not managed by refcount, or not valid anymore */
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_refcount_release(%x) 0x%x ERROR not managed\n", id, ptr);
-	assert(false);
-
-	return false;
-}
-
-bool sh_css_refcount_is_single(hrt_vaddress ptr)
-{
-	struct sh_css_refcount_entry *entry;
-
-	if (ptr == mmgr_NULL)
-		return false;
-
-	entry = find_entry(ptr);
-
-	if (entry)
-		return (entry->count == 1);
-
-	return true;
-}
-
-int32_t sh_css_refcount_get_id(hrt_vaddress ptr)
-{
-	struct sh_css_refcount_entry *entry;
-	assert(ptr != mmgr_NULL);
-	entry = find_entry(ptr);
-	assert(entry != NULL);
-	if (entry == NULL)
-		return mmgr_NULL;
-	return entry->id;
-}
-
-void sh_css_refcount_clear(int32_t id, void (*clear_func)(hrt_vaddress ptr))
-{
-	struct sh_css_refcount_entry *entry;
-	uint32_t i;
-	uint32_t count = 0;
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_refcount_clear(%x)\n", id);
-	for (i = 0; i < myrefcount.size; i++) {
-		entry = &myrefcount.items[i];
-		if ((entry->data != mmgr_NULL) && (entry->id == id)) {
-			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-				"sh_css_refcount_clear: %x: 0x%x refcnt %d\n",
-				id, entry->data, entry->count);
-			if (clear_func) {
-				/* clear using provided function */
-				/* This function will update the entry */
-				/* administration (we should not do that)  */
-				clear_func(entry->data);
-				assert(entry->count == 0);
-			}
-			else {
-				sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-						"sh_css_refcount_clear: "
-						"using default mmgr_free\n");
-				mmgr_free(entry->data);
-
-				assert(entry->count == 0);
-				entry->data = mmgr_NULL;
-				entry->size = 0;
-				entry->count = 0;
-				entry->id = 0;
-			}
-			count++;
-		}
-	}
-	sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
-		"sh_css_refcount_clear(%x): cleared %d\n", id, count);
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.h
deleted file mode 100644
index 4103c75..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_refcount.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_REFCOUNT_H_
-#define _SH_CSS_REFCOUNT_H_
-
-#include "sh_css.h"
-#include "sh_css_binary.h"
-#include "sh_css_internal.h"
-
-#define PARAM_SET_POOL  ((int32_t)0xCAFE0001)
-#define PARAM_BUFFER    ((int32_t)0xCAFE0002)
-#define FREE_BUF_CACHE  ((int32_t)0xCAFE0003)
-
-enum sh_css_err sh_css_refcount_init(void);
-
-void sh_css_refcount_uninit(void);
-
-hrt_vaddress sh_css_refcount_alloc(
-	int32_t id, const size_t size, const uint16_t attribute);
-
-hrt_vaddress sh_css_refcount_retain(int32_t id, hrt_vaddress ptr);
-
-bool sh_css_refcount_release(int32_t id, hrt_vaddress ptr);
-
-bool sh_css_refcount_is_single(hrt_vaddress ptr);
-
-int32_t sh_css_refcount_get_id(hrt_vaddress ptr);
-
-void sh_css_refcount_clear(
-	int32_t id, void (*clear_func)(hrt_vaddress ptr));
-
-int sh_css_refcount_used(void);
-
-#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.c
deleted file mode 100644
index c536d60..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.c
+++ /dev/null
@@ -1,441 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#define __INLINE_INPUT_SYSTEM__
-#include "input_system.h"
-
-#include "sh_css.h"
-#include "sh_css_rx.h"
-#include "sh_css_internal.h"
-
-void
-sh_css_rx_enable_all_interrupts(void)
-{
-	hrt_data	bits = receiver_port_reg_load(RX0_ID,
-		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
-
-	bits |= (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT) |
-#if defined(HAS_RX_VERSION_2)
-		(1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT) |
-#endif
-		(1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT) |
-/*		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_NO_CORRECTION_BIT) | */
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT) |
-		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT);
-/*		(1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT); */
-
-	receiver_port_reg_store(RX0_ID,
-		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
-return;
-}
-
-unsigned int sh_css_rx_get_interrupt_reg(void)
-{
-return receiver_port_reg_load(RX0_ID,
-	MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
-}
-
-void
-sh_css_rx_get_interrupt_info(unsigned int *irq_infos)
-{
-	unsigned long	infos = 0;
-
-	hrt_data	bits = receiver_port_reg_load(RX0_ID,
-		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_STATUS_REG_IDX);
-
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN;
-#if defined(HAS_RX_VERSION_2)
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_INIT_TIMEOUT;
-#endif
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ECC_CORRECTED;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_SOT;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_SOT_SYNC;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_CONTROL;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_CRC;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_FRAME_DATA;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC;
-	if (bits & (1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT))
-		infos |= SH_CSS_RX_IRQ_INFO_ERR_LINE_SYNC;
-
-	*irq_infos = infos;
-}
-
-void
-sh_css_rx_clear_interrupt_info(unsigned int irq_infos)
-{
-	hrt_data	bits = receiver_port_reg_load(RX0_ID,
-		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX);
-
-/* MW: Why do we remap the receiver bitmap */
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_OVERRUN_BIT;
-#if defined(HAS_RX_VERSION_2)
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_INIT_TIMEOUT)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_INIT_TIMEOUT_BIT;
-#endif
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ENTER_SLEEP_MODE)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_ENTRY_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_EXIT_SLEEP_MODE)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_SLEEP_MODE_EXIT_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ECC_CORRECTED)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_CORRECTED_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_SOT)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_HS_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_SOT_SYNC)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_SOT_SYNC_HS_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_CONTROL)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CONTROL_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_ECC_DOUBLE)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ECC_DOUBLE_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_CRC)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_CRC_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ID)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ID_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_FRAME_SYNC)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_SYNC_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_FRAME_DATA)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_FRAME_DATA_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_DATA_TIMEOUT)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_DATA_TIMEOUT_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_UNKNOWN_ESC)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_ESCAPE_BIT;
-	if (irq_infos & SH_CSS_RX_IRQ_INFO_ERR_LINE_SYNC)
-		bits |= 1U << _HRT_CSS_RECEIVER_IRQ_ERR_LINE_SYNC_BIT;
-
-	receiver_port_reg_store(RX0_ID,
-		MIPI_PORT1_ID, _HRT_CSS_RECEIVER_IRQ_ENABLE_REG_IDX, bits);
-return;
-}
-
-enum sh_css_err sh_css_input_format_type(
-	enum sh_css_input_format input_format,
-	mipi_predictor_t compression,
-	unsigned int *fmt_type)
-{
-/*
- * Custom (user defined) modes. Used for compressed
- * MIPI transfers
- *
- * Checkpatch thinks the indent before "if" is suspect
- * I think the only suspect part is the missing "else"
- * because of the return.
- */
-	if (compression != MIPI_PREDICTOR_NONE) {
-		switch (input_format) {
-		case SH_CSS_INPUT_FORMAT_RAW_6:
-			*fmt_type = 6;
-			break;
-		case SH_CSS_INPUT_FORMAT_RAW_7:
-			*fmt_type = 7;
-			break;
-		case SH_CSS_INPUT_FORMAT_RAW_8:
-			*fmt_type = 8;
-			break;
-		case SH_CSS_INPUT_FORMAT_RAW_10:
-			*fmt_type = 10;
-			break;
-		case SH_CSS_INPUT_FORMAT_RAW_12:
-			*fmt_type = 12;
-			break;
-		case SH_CSS_INPUT_FORMAT_RAW_14:
-			*fmt_type = 14;
-			break;
-		case SH_CSS_INPUT_FORMAT_RAW_16:
-			*fmt_type = 16;
-			break;
-		default:
-			return sh_css_err_internal_error;
-		}
-		return sh_css_success;
-	}
-/*
- * This mapping comes from the Arasan CSS function spec
- * (CSS_func_spec1.08_ahb_sep29_08.pdf).
- *
- * MW: For some reason the mapping is not 1-to-1
- */
-	switch (input_format) {
-	case SH_CSS_INPUT_FORMAT_RGB_888:
-		*fmt_type = MIPI_FORMAT_RGB888;
-		break;
-	case SH_CSS_INPUT_FORMAT_RGB_555:
-		*fmt_type = MIPI_FORMAT_RGB555;
-		break;
-	case SH_CSS_INPUT_FORMAT_RGB_444:
-		*fmt_type = MIPI_FORMAT_RGB444;
-		break;
-	case SH_CSS_INPUT_FORMAT_RGB_565:
-		*fmt_type = MIPI_FORMAT_RGB565;
-		break;
-	case SH_CSS_INPUT_FORMAT_RGB_666:
-		*fmt_type = MIPI_FORMAT_RGB666;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_8:
-		*fmt_type = MIPI_FORMAT_RAW8;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_10:
-		*fmt_type = MIPI_FORMAT_RAW10;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_6:
-		*fmt_type = MIPI_FORMAT_RAW6;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_7:
-		*fmt_type = MIPI_FORMAT_RAW7;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_12:
-		*fmt_type = MIPI_FORMAT_RAW12;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_14:
-		*fmt_type = MIPI_FORMAT_RAW14;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV420_8:
-		*fmt_type = MIPI_FORMAT_YUV420_8;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV420_10:
-		*fmt_type = MIPI_FORMAT_YUV420_10;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV422_8:
-		*fmt_type = MIPI_FORMAT_YUV422_8;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV422_10:
-		*fmt_type = MIPI_FORMAT_YUV422_10;
-		break;
-	case SH_CSS_INPUT_FORMAT_BINARY_8:
-		*fmt_type = MIPI_FORMAT_BINARY_8;
-		break;
-	case SH_CSS_INPUT_FORMAT_YUV420_8_LEGACY:
-		*fmt_type = MIPI_FORMAT_YUV420_8_LEGACY;
-		break;
-	case SH_CSS_INPUT_FORMAT_RAW_16:
-		/* This is not specified by Arasan, so we use
-		 * 17 for now.
-		 */
-		*fmt_type = MIPI_FORMAT_RAW16;
-		break;
-#if defined(HAS_RX_VERSION_2)
-	default:
-		if (input_format > (enum sh_css_input_format)N_MIPI_FORMAT)
-			return sh_css_err_internal_error;
-		*fmt_type = input_format;
-		break;
-#else
-	default:
-		return sh_css_err_internal_error;
-#endif
-	}
-return sh_css_success;
-}
-
-#if defined(HAS_RX_VERSION_1)
-
-/* This is a device function, shouldn't be here */
-static void sh_css_rx_set_bits(
-	const mipi_port_ID_t	port,
-	const unsigned int		reg,
-	const unsigned int		lsb,
-	const unsigned int		bits,
-	const unsigned int		val)
-{
-	hrt_data	data = receiver_port_reg_load(RX0_ID, port, reg);
-/* prevent writing out of range */
-	hrt_data	tmp = val & ((1U << bits) - 1);
-/* shift into place */
-	data |= (tmp << lsb);
-	receiver_port_reg_store(RX0_ID, port, reg, data);
-return;
-}
-
-static void sh_css_rx_set_num_lanes(
-	const mipi_port_ID_t	port,
-	const unsigned int		lanes)
-{
-	sh_css_rx_set_bits(port,
-		_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
-		_HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_IDX,
-		_HRT_CSS_RECEIVER_AHB_CSI2_NUM_DATA_LANES_BITS,
-		lanes);
-return;
-}
-
-static void sh_css_rx_set_timeout(
-	const mipi_port_ID_t	port,
-	const unsigned int		timeout)
-{
-	sh_css_rx_set_bits(port,
-		_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
-		_HRT_CSS_RECEIVER_DATA_TIMEOUT_IDX,
-		_HRT_CSS_RECEIVER_DATA_TIMEOUT_BITS,
-		timeout);
-return;
-}
-
-static void sh_css_rx_set_compression(
-	const mipi_port_ID_t				port,
-	const mipi_predictor_t				comp)
-{
-	unsigned int reg = _HRT_CSS_RECEIVER_COMP_PREDICT_REG_IDX;
-
-assert(comp < N_MIPI_PREDICTOR_TYPES);
-
-	receiver_port_reg_store(RX0_ID, port, reg, comp);
-return;
-}
-
-static void sh_css_rx_set_uncomp_size(
-	const mipi_port_ID_t	port,
-	const unsigned int		size)
-{
-	sh_css_rx_set_bits(port,
-		_HRT_CSS_RECEIVER_AHB_COMP_FORMAT_REG_IDX,
-		_HRT_CSS_RECEIVER_AHB_COMP_NUM_BITS_IDX,
-		_HRT_CSS_RECEIVER_AHB_COMP_NUM_BITS_BITS,
-		size);
-return;
-}
-
-static void sh_css_rx_set_comp_size(
-	const mipi_port_ID_t	port,
-	const unsigned int		size)
-{
-	sh_css_rx_set_bits(port,
-		_HRT_CSS_RECEIVER_AHB_COMP_FORMAT_REG_IDX,
-		_HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_IDX,
-		_HRT_CSS_RECEIVER_AHB_COMP_RAW_BITS_BITS,
-		size);
-return;
-}
-#endif /* defined(HAS_RX_VERSION_1) */
-
-void sh_css_rx_configure(
-	const rx_cfg_t		*config)
-{
-	mipi_port_ID_t	port = config->port;
-
-/* turn off all ports just in case */
-	sh_css_rx_disable();
-
-#if defined(HAS_RX_VERSION_2)
-	if (MIPI_PORT_LANES[config->mode][port] != MIPI_0LANE_CFG) {
-		receiver_port_reg_store(RX0_ID, port,
-			_HRT_CSS_RECEIVER_FUNC_PROG_REG_IDX,
-			config->timeout);
-		receiver_port_reg_store(RX0_ID, port,
-			_HRT_CSS_RECEIVER_2400_INIT_COUNT_REG_IDX,
-			config->initcount);
-		receiver_port_reg_store(RX0_ID, port,
-			_HRT_CSS_RECEIVER_2400_SYNC_COUNT_REG_IDX,
-			config->synccount);
-		receiver_port_reg_store(RX0_ID, port,
-			_HRT_CSS_RECEIVER_2400_RX_COUNT_REG_IDX,
-			config->rxcount);
-/*
- * MW: A bit of a hack, straight wiring of the capture units,
- * assuming they are linearly enumerated
- */
-		input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
-			GPREGS_UNIT0_ID, HIVE_ISYS_GPREG_MULTICAST_A_IDX +
-			(unsigned int)port, INPUT_SYSTEM_CSI_BACKEND);
-		input_system_sub_system_reg_store(INPUT_SYSTEM0_ID,
-			GPREGS_UNIT0_ID, HIVE_ISYS_GPREG_MUX_IDX,
-			(input_system_multiplex_t)port);
-	}
-/*
- * signal input
- *
-	receiver_reg_store(RX0_ID,
-		_HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX, config->mode);
- */
-	receiver_reg_store(RX0_ID,
-		_HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX, config->is_two_ppc);
-
-/* enable the selected port(s) */
-	for (port = (mipi_port_ID_t)0; port < N_MIPI_PORT_ID; port++) {
-		if (MIPI_PORT_LANES[config->mode][port] != MIPI_0LANE_CFG)
-			receiver_port_reg_store(RX0_ID, port,
-				_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, true);
-	}
-
-#elif defined(HAS_RX_VERSION_1)
-
-/* All settings are per port */
-	sh_css_rx_set_timeout(port, config->timeout);
-/* configure the selected port */
-	sh_css_rx_set_num_lanes(port, config->num_lanes);
-	sh_css_rx_set_compression(port, config->comp);
-	sh_css_rx_set_uncomp_size(port, config->uncomp_bpp);
-	sh_css_rx_set_comp_size(port, config->comp_bpp);
-
-	receiver_port_reg_store(RX0_ID, port,
-		_HRT_CSS_RECEIVER_TWO_PIXEL_EN_REG_IDX, config->is_two_ppc);
-
-/* enable the selected port */
-	receiver_port_reg_store(RX0_ID, port,
-		_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, true);
-#else
-#error "sh_css_rx.c: RX version must be one of {RX_VERSION_1, RX_VERSION_2}"
-#endif
-
-return;
-}
-
-void sh_css_rx_disable(void)
-{
-	mipi_port_ID_t	port;
-	for (port = (mipi_port_ID_t)0; port < N_MIPI_PORT_ID; port++) {
-		receiver_port_reg_store(RX0_ID, port,
-			_HRT_CSS_RECEIVER_DEVICE_READY_REG_IDX, false);
-	}
-return;
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.h
deleted file mode 100644
index c49ff8b..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_rx.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_RX_H_
-#define _SH_CSS_RX_H_
-
-#include "input_system.h"
-
-/* CSS Receiver */
-
-void sh_css_rx_configure(
-	const rx_cfg_t	*config);
-
-void sh_css_rx_disable(void);
-
-void sh_css_rx_enable_all_interrupts(void);
-
-unsigned int sh_css_rx_get_interrupt_reg(void);
-
-#endif /* _SH_CSS_RX_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.c
deleted file mode 100644
index 9e61461..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.c
+++ /dev/null
@@ -1,1354 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "sh_css_sp.h"
-
-#include "input_formatter.h"
-
-#include "dma.h"	/* N_DMA_CHANNEL_ID */
-
-#include "sh_css.h"
-#include "sh_css_binary.h"
-#include "sh_css_sp_start.h"
-#include "sh_css_hrt.h"
-#include "sh_css_defs.h"
-#include "sh_css_internal.h"
-#include "sh_css_debug.h"
-#include "sh_css_debug_internal.h"
-
-#include "gdc_device.h"				/* HRT_GDC_N */
-
-/*#include "sp.h"*/	/* host2sp_enqueue_frame_data() */
-
-#include "memory_access.h"
-
-#include "assert_support.h"
-#include "platform_support.h"	/* hrt_sleep() */
-
-#include "queue.h"	/* host_sp_enqueue_XXX */
-#include "sw_event.h"	/* encode_sw_event */
-
-#ifndef offsetof
-#define offsetof(T, x) ((unsigned)&(((T *)0)->x))
-#endif
-
-struct sh_css_sp_group		sh_css_sp_group;
-struct sh_css_sp_stage		sh_css_sp_stage;
-struct sh_css_isp_stage		sh_css_isp_stage;
-struct sh_css_sp_output		sh_css_sp_output;
-static struct sh_css_sp_per_frame_data per_frame_data;
-
-static hrt_vaddress init_dmem_ddr;
-
-/* true if SP supports frame loop and host2sp_commands */
-/* For the moment there is only code that sets this bool to true */
-/* TODO: add code that sets this bool to false */
-static bool sp_running;
-
-
-static enum sh_css_err
-set_output_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num);
-
-/* This data is stored every frame */
-void
-store_sp_group_data(void)
-{
-	per_frame_data.sp_group_addr = sh_css_store_sp_group_to_ddr();
-}
-
-static void
-copy_isp_stage_to_sp_stage(void)
-{
-	sh_css_sp_stage.num_stripes = sh_css_isp_stage.binary_info.num_stripes;
-	sh_css_sp_stage.enable.vf_veceven =
-		sh_css_isp_stage.binary_info.enable.vf_veceven;
-	sh_css_sp_stage.enable.sdis = sh_css_isp_stage.binary_info.enable.dis;
-	sh_css_sp_stage.enable.s3a = sh_css_isp_stage.binary_info.enable.s3a;
-}
-
-void
-store_sp_stage_data(enum sh_css_pipe_id id, unsigned stage)
-{
-	enum sh_css_pipe_id pipe_id = id;
-	unsigned int thread_id;
-	sh_css_query_sp_thread_id(pipe_id, &thread_id);
-	copy_isp_stage_to_sp_stage();
-	sh_css_sp_stage.isp_stage_addr =
-		sh_css_store_isp_stage_to_ddr(pipe_id, stage);
-	sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] =
-		sh_css_store_sp_stage_to_ddr(pipe_id, stage);
-
-	/* Clear for next frame */
-	sh_css_sp_stage.program_input_circuit = false;
-}
-
-static void
-store_sp_per_frame_data(const struct sh_css_fw_info *fw)
-{
-	unsigned int HIVE_ADDR_sp_per_frame_data = 0;
-	switch (fw->type) {
-	case sh_css_sp_firmware:
-		HIVE_ADDR_sp_per_frame_data = fw->info.sp.per_frame_data;
-		break;
-	case sh_css_acc_firmware:
-		HIVE_ADDR_sp_per_frame_data = fw->info.acc.per_frame_data;
-		break;
-	case sh_css_isp_firmware:
-		return;
-	}
-
-	sp_dmem_store(SP0_ID,
-		(unsigned int)sp_address_of(sp_per_frame_data),
-		&per_frame_data,
-			sizeof(per_frame_data));
-}
-
-static void
-sh_css_store_sp_per_frame_data(enum sh_css_pipe_id pipe_id,
-			       const struct sh_css_fw_info *sp_fw)
-{
-	if (!sp_fw)
-		sp_fw = &sh_css_sp_fw;
-
-	store_sp_stage_data(pipe_id, 0);
-	store_sp_group_data();
-	store_sp_per_frame_data(sp_fw);
-}
-
-/* Initialize the entire contents of the DMEM at once -- does not need to
- * do this from the host
- */
-void
-sh_css_sp_store_init_dmem(const struct sh_css_fw_info *fw)
-{
-	struct sh_css_sp_init_dmem_cfg init_dmem_cfg;
-
-	mmgr_store(init_dmem_ddr, fw->blob.data, fw->blob.data_size);
-
-	/* Configure the data structure to initialize dmem */
-	init_dmem_cfg.done	     = false;
-	init_dmem_cfg.ddr_data_addr  = init_dmem_ddr;
-	init_dmem_cfg.dmem_data_addr = (hrt_vaddress)fw->blob.data_target;
-	init_dmem_cfg.data_size      = fw->blob.data_size;
-	init_dmem_cfg.dmem_bss_addr  = (hrt_vaddress)fw->blob.bss_target;
-	init_dmem_cfg.bss_size       = fw->blob.bss_size;
-
-	sp_dmem_store(SP0_ID, (unsigned)fw->info.sp.init_dmem_data,
-				&init_dmem_cfg,
-				sizeof(init_dmem_cfg));
-
-}
-
-enum sh_css_err
-sh_css_sp_init(void)
-{
-	init_dmem_ddr = mmgr_malloc(SP_DMEM_SIZE);
-	if (init_dmem_ddr == mmgr_NULL)
-		return sh_css_err_cannot_allocate_memory;
-
-	return sh_css_success;
-}
-
-void
-sh_css_sp_uninit(void)
-{
-	mmgr_free(init_dmem_ddr);
-	init_dmem_ddr = mmgr_NULL;
-}
-
-#if SP_DEBUG !=SP_DEBUG_NONE
-
-void
-sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
-	unsigned i;
-	unsigned o = offsetof(struct sh_css_sp_output, debug)/sizeof(int);
-	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
-	for (i = 0; i < sizeof(*state)/sizeof(int); i++)
-		((unsigned *)state)[i] = load_sp_array_uint(sp_output, i+o);
-}
-
-#endif
-
-void
-sh_css_sp_start_binary_copy(struct sh_css_frame *out_frame,
-			    unsigned two_ppc)
-{
-	enum sh_css_pipe_id pipe_id;
-	unsigned int thread_id;
-	struct sh_css_sp_pipeline *pipe;
-	unsigned stage_num = 0;
-
-assert(out_frame != NULL);
-    if (out_frame == NULL) {
-		sh_css_dtrace(SH_DBG_ERROR,
-		"sh_css_sp_start_binary_copy() leave: error output_frame is NULL\n");
-		return;
-	}
-	pipe_id = SH_CSS_CAPTURE_PIPELINE;
-	sh_css_query_sp_thread_id(pipe_id, &thread_id);
-	pipe = &sh_css_sp_group.pipe[thread_id];
-
-	pipe->copy.bin.bytes_available = out_frame->data_bytes;
-	pipe->num_stages = 1;
-	pipe->pipe_id = pipe_id;
-	/* TODO: next indicates from which queues parameters need to be
-		 sampled, needs checking/improvement */
-	pipe->pipe_config = SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;
-
-	sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
-
-	sh_css_sp_stage.num = stage_num;
-	sh_css_sp_stage.irq_buf_flags = 1 << sh_css_frame_out;
-	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
-	sh_css_sp_stage.func =
-		(unsigned int)SH_CSS_SP_BIN_COPY;
-
-	set_output_frame_buffer(out_frame,
-						(unsigned)pipe_id, stage_num);
-
-	/* sp_bin_copy_init on the SP does not deal with dynamica/static yet */
-	/* For now always update the dynamic data from out frames. */
-	sh_css_store_sp_per_frame_data(pipe_id, &sh_css_sp_fw);
-}
-
-void
-sh_css_sp_start_raw_copy(struct sh_css_binary *binary,
-			 struct sh_css_frame *out_frame,
-			 unsigned two_ppc,
-			 bool input_needs_raw_binning,
-			 enum sh_css_pipe_config_override pipe_conf_override)
-{
-	enum sh_css_pipe_id pipe_id;
-	unsigned int thread_id;
-	unsigned stage_num = 0;
-	struct sh_css_sp_pipeline *pipe;
-
-assert(out_frame != NULL);
-	if (out_frame == NULL) {
-		sh_css_dtrace(SH_DBG_ERROR,
-		"sh_css_sp_start_raw_copy() leave: error output_frame is NULL\n");
-		return;
-	}
-
-	{
-		/**
-		 * Clear sh_css_sp_stage for easy debugging.
-		 * program_input_circuit must be saved as it is set outside
-		 * this function.
-		 */
-		unsigned int program_input_circuit;
-		program_input_circuit = sh_css_sp_stage.program_input_circuit;
-		memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
-		sh_css_sp_stage.program_input_circuit = program_input_circuit;
-	}
-
-	pipe_id = SH_CSS_COPY_PIPELINE;
-	sh_css_query_sp_thread_id(pipe_id, &thread_id);
-	pipe = &sh_css_sp_group.pipe[thread_id];
-
-	pipe->copy.raw.height	    = out_frame->info.height;
-	pipe->copy.raw.width	    = out_frame->info.width;
-	pipe->copy.raw.padded_width  = out_frame->info.padded_width;
-	pipe->copy.raw.raw_bit_depth = out_frame->info.raw_bit_depth;
-	pipe->copy.raw.max_input_width = binary->info->max_input_width;
-	pipe->num_stages = 1;
-	pipe->pipe_id = pipe_id;
-	/* TODO: next indicates from which queues parameters need to be
-		 sampled, needs checking/improvement */
-	if (pipe_conf_override == SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD)
-		pipe->pipe_config =
-			(SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id);
-	else
-		pipe->pipe_config = pipe_conf_override;
-
-	sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
-	sh_css_sp_group.config.input_needs_raw_binning =
-						input_needs_raw_binning;
-
-	sh_css_sp_stage.num = stage_num;
-	sh_css_sp_stage.irq_buf_flags = 1 << sh_css_frame_out;
-	sh_css_sp_stage.xmem_bin_addr = binary->info->xmem_addr;
-	sh_css_sp_stage.stage_type = SH_CSS_SP_STAGE_TYPE;
-	sh_css_sp_stage.func =
-		(unsigned int)SH_CSS_SP_RAW_COPY;
-
-	set_output_frame_buffer(out_frame,
-						(unsigned)pipe_id, stage_num);
-
-	/* sp_raw_copy_init on the SP does not deal with dynamica/static yet */
-	/* For now always update the dynamic data from out frames. */
-	sh_css_store_sp_per_frame_data(pipe_id, &sh_css_sp_fw);
-}
-
-unsigned int
-sh_css_sp_get_binary_copy_size(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
-	unsigned int o = offsetof(struct sh_css_sp_output,
-				bin_copy_bytes_copied) / sizeof(int);
-	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
-	return load_sp_array_uint(sp_output, o);
-}
-
-unsigned int
-sh_css_sp_get_sw_interrupt_value(unsigned int irq)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_output = fw->info.sp.output;
-	unsigned int o = offsetof(struct sh_css_sp_output, sw_interrupt_value)
-				/ sizeof(int);
-	(void)HIVE_ADDR_sp_output; /* To get rid of warning in CRUN */
-	return load_sp_array_uint(sp_output, o+irq);
-}
-
-static void
-sh_css_frame_info_to_sp(struct sh_css_sp_frame_info *sp,
-			const struct sh_css_frame_info *host)
-{
-  sp->width	      = host->width;
-  sp->height	      = host->height;
-  sp->padded_width    = host->padded_width;
-  sp->format	      = host->format;
-  sp->raw_bit_depth   = host->raw_bit_depth;
-  sp->raw_bayer_order = host->raw_bayer_order;
-}
-
-static void
-sh_css_copy_frame_to_spframe(struct sh_css_sp_frame *sp_frame_out,
-				const struct sh_css_frame *frame_in,
-				unsigned pipe_num, unsigned stage_num,
-				enum sh_css_frame_id id)
-{
-	/* TODO: remove pipe and stage from interface */
-	(void)pipe_num;
-	(void)stage_num;
-
-	if (frame_in->dynamic_data_index >= 0) {
-		assert((id == sh_css_frame_in) ||
-				(id == sh_css_frame_out) ||
-				(id == sh_css_frame_out_vf));
-		/*
-		 * value >=0 indicates that function init_frame_pointers()
-		 * should use the dynamic data address
-		 */
-		assert(frame_in->dynamic_data_index <
-					SH_CSS_NUM_DYNAMIC_FRAME_IDS);
-		/*
-		 * static_frame_data is overloaded, small values (<3) are
-		 * the dynamic index, large values are the static address
-		 */
-		sh_css_sp_stage.frames.static_frame_data[id] =
-						frame_in->dynamic_data_index;
-	} else {
-		sh_css_sp_stage.frames.static_frame_data[id] = frame_in->data;
-	}
-
-	if (!sp_frame_out)
-		return;
-
-	sh_css_frame_info_to_sp(&sp_frame_out->info, &frame_in->info);
-
-	switch (frame_in->info.format) {
-	case SH_CSS_FRAME_FORMAT_RAW:
-		sp_frame_out->planes.raw.offset = frame_in->planes.raw.offset;
-		break;
-	case SH_CSS_FRAME_FORMAT_RGB565:
-	case SH_CSS_FRAME_FORMAT_RGBA888:
-		sp_frame_out->planes.rgb.offset = frame_in->planes.rgb.offset;
-		break;
-	case SH_CSS_FRAME_FORMAT_PLANAR_RGB888:
-		sp_frame_out->planes.planar_rgb.r.offset =
-			frame_in->planes.planar_rgb.r.offset;
-		sp_frame_out->planes.planar_rgb.g.offset =
-			frame_in->planes.planar_rgb.g.offset;
-		sp_frame_out->planes.planar_rgb.b.offset =
-			frame_in->planes.planar_rgb.b.offset;
-		break;
-	case SH_CSS_FRAME_FORMAT_YUYV:
-	case SH_CSS_FRAME_FORMAT_UYVY:
-	case SH_CSS_FRAME_FORMAT_YUV_LINE:
-		sp_frame_out->planes.yuyv.offset = frame_in->planes.yuyv.offset;
-		break;
-	case SH_CSS_FRAME_FORMAT_NV11:
-	case SH_CSS_FRAME_FORMAT_NV12:
-	case SH_CSS_FRAME_FORMAT_NV21:
-	case SH_CSS_FRAME_FORMAT_NV16:
-	case SH_CSS_FRAME_FORMAT_NV61:
-		sp_frame_out->planes.nv.y.offset =
-			frame_in->planes.nv.y.offset;
-		sp_frame_out->planes.nv.uv.offset =
-			frame_in->planes.nv.uv.offset;
-		break;
-	case SH_CSS_FRAME_FORMAT_YUV420:
-	case SH_CSS_FRAME_FORMAT_YUV422:
-	case SH_CSS_FRAME_FORMAT_YUV444:
-	case SH_CSS_FRAME_FORMAT_YUV420_16:
-	case SH_CSS_FRAME_FORMAT_YUV422_16:
-	case SH_CSS_FRAME_FORMAT_YV12:
-	case SH_CSS_FRAME_FORMAT_YV16:
-		sp_frame_out->planes.yuv.y.offset =
-			frame_in->planes.yuv.y.offset;
-		sp_frame_out->planes.yuv.u.offset =
-			frame_in->planes.yuv.u.offset;
-		sp_frame_out->planes.yuv.v.offset =
-			frame_in->planes.yuv.v.offset;
-		break;
-	case SH_CSS_FRAME_FORMAT_QPLANE6:
-		sp_frame_out->planes.plane6.r.offset =
-			frame_in->planes.plane6.r.offset;
-		sp_frame_out->planes.plane6.r_at_b.offset =
-			frame_in->planes.plane6.r_at_b.offset;
-		sp_frame_out->planes.plane6.gr.offset =
-			frame_in->planes.plane6.gr.offset;
-		sp_frame_out->planes.plane6.gb.offset =
-			frame_in->planes.plane6.gb.offset;
-		sp_frame_out->planes.plane6.b.offset =
-			frame_in->planes.plane6.b.offset;
-		sp_frame_out->planes.plane6.b_at_r.offset =
-			frame_in->planes.plane6.b_at_r.offset;
-		break;
-	case SH_CSS_FRAME_FORMAT_BINARY_8:
-		sp_frame_out->planes.binary.data.offset =
-			frame_in->planes.binary.data.offset;
-		break;
-	default:
-		/* This should not happen, but in case it does,
-		 * nullify the planes
-		 */
-		memset(&sp_frame_out->planes, 0, sizeof(sp_frame_out->planes));
-		break;
-	}
-
-}
-
-static enum sh_css_err
-set_input_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	switch (frame->info.format) {
-	case SH_CSS_FRAME_FORMAT_QPLANE6:
-	case SH_CSS_FRAME_FORMAT_YUV420_16:
-	case SH_CSS_FRAME_FORMAT_RAW:
-	case SH_CSS_FRAME_FORMAT_YUV420:
-	case SH_CSS_FRAME_FORMAT_YUV_LINE:
-	case SH_CSS_FRAME_FORMAT_NV12:
-		break;
-	default:
-		return sh_css_err_unsupported_frame_format;
-	}
-	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.in, frame,
-					pipe_num, stage_num,
-					sh_css_frame_in);
-
-	return sh_css_success;
-}
-
-static enum sh_css_err
-set_output_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	switch (frame->info.format) {
-	case SH_CSS_FRAME_FORMAT_YUV420:
-	case SH_CSS_FRAME_FORMAT_YUV422:
-	case SH_CSS_FRAME_FORMAT_YUV444:
-	case SH_CSS_FRAME_FORMAT_YV12:
-	case SH_CSS_FRAME_FORMAT_YV16:
-	case SH_CSS_FRAME_FORMAT_YUV420_16:
-	case SH_CSS_FRAME_FORMAT_YUV422_16:
-	case SH_CSS_FRAME_FORMAT_NV11:
-	case SH_CSS_FRAME_FORMAT_NV12:
-	case SH_CSS_FRAME_FORMAT_NV16:
-	case SH_CSS_FRAME_FORMAT_NV21:
-	case SH_CSS_FRAME_FORMAT_NV61:
-	case SH_CSS_FRAME_FORMAT_YUYV:
-	case SH_CSS_FRAME_FORMAT_UYVY:
-	case SH_CSS_FRAME_FORMAT_YUV_LINE:
-	case SH_CSS_FRAME_FORMAT_RGB565:
-	case SH_CSS_FRAME_FORMAT_RGBA888:
-	case SH_CSS_FRAME_FORMAT_PLANAR_RGB888:
-	case SH_CSS_FRAME_FORMAT_RAW:
-	case SH_CSS_FRAME_FORMAT_QPLANE6:
-	case SH_CSS_FRAME_FORMAT_BINARY_8:
-		break;
-	default:
-		return sh_css_err_unsupported_frame_format;
-	}
-	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out, frame,
-					pipe_num, stage_num,
-					sh_css_frame_out);
-	return sh_css_success;
-}
-
-static enum sh_css_err
-set_ref_in_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	if (frame->info.format != SH_CSS_FRAME_FORMAT_YUV420)
-		return sh_css_err_unsupported_frame_format;
-	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.ref_in, frame,
-					pipe_num, stage_num,
-					sh_css_frame_ref_in);
-	return sh_css_success;
-}
-
-static enum sh_css_err
-set_ref_out_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	if (frame->info.format != SH_CSS_FRAME_FORMAT_YUV420)
-		return sh_css_err_unsupported_frame_format;
-	sh_css_copy_frame_to_spframe(NULL, frame,
-					pipe_num, stage_num,
-					sh_css_frame_ref_out);
-	return sh_css_success;
-}
-
-static enum sh_css_err
-set_tnr_in_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	if (frame->info.format != SH_CSS_FRAME_FORMAT_YUV_LINE)
-		return sh_css_err_unsupported_frame_format;
-	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.tnr_in, frame,
-					pipe_num, stage_num,
-					sh_css_frame_tnr_in);
-	return sh_css_success;
-}
-
-static enum sh_css_err
-set_tnr_out_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	if (frame->info.format != SH_CSS_FRAME_FORMAT_YUV_LINE)
-		return sh_css_err_unsupported_frame_format;
-	sh_css_copy_frame_to_spframe(NULL, frame,
-					pipe_num, stage_num,
-					sh_css_frame_tnr_out);
-	return sh_css_success;
-}
-
-static enum sh_css_err
-set_capture_pp_frame_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	if (frame->info.format != SH_CSS_FRAME_FORMAT_YUV420)
-		return sh_css_err_unsupported_frame_format;
-	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.extra, frame,
-					pipe_num, stage_num,
-					sh_css_frame_extra);
-	return sh_css_success;
-}
-
-static enum sh_css_err
-set_view_finder_buffer(const struct sh_css_frame *frame,
-			unsigned pipe_num, unsigned stage_num)
-{
-	if (frame == NULL)
-		return sh_css_err_invalid_arguments;
-
-	if (frame->info.format != SH_CSS_FRAME_FORMAT_YUV_LINE)
-		return sh_css_err_unsupported_frame_format;
-	sh_css_copy_frame_to_spframe(&sh_css_sp_stage.frames.out_vf, frame,
-					pipe_num, stage_num,
-					sh_css_frame_out_vf);
-	return sh_css_success;
-}
-
-void sh_css_sp_set_if_configs(
-	const input_formatter_cfg_t		*config_a,
-	const input_formatter_cfg_t		*config_b)
-{
-	input_formatter_ID_t	id;
-#if defined(IS_ISP_2300_SYSTEM)
-	bool	block[N_INPUT_FORMATTER_ID] = {false, false};
-#elif defined(IS_ISP_2400_SYSTEM)
-	bool	block[N_INPUT_FORMATTER_ID] = {false, false, false};
-#else
-#error "sh_css_sp_set_if_configs: ISP_SYSTEM must be one of \
-	{IS_ISP_2300_SYSTEM, IS_ISP_2400_SYSTEM}"
-#endif
-
-	block[INPUT_FORMATTER0_ID] = config_a->block_no_reqs;
-	if (config_b != NULL)
-		block[INPUT_FORMATTER1_ID] = config_b->block_no_reqs;
-
-	for (id = (input_formatter_ID_t)0; id < N_INPUT_FORMATTER_ID; id++) {
-		input_formatter_rst(id);
-		input_formatter_set_fifo_blocking_mode(id, block[id]);
-	}
-
-	sh_css_sp_group.config.input_formatter.config_a = *config_a;
-	sh_css_sp_group.config.input_formatter.a_changed = true;
-
-	if (config_b != NULL) {
-		sh_css_sp_group.config.input_formatter.config_b = *config_b;
-		sh_css_sp_group.config.input_formatter.b_changed = true;
-	}
-
-return;
-}
-
-void
-sh_css_sp_program_input_circuit(int fmt_type,
-				int ch_id,
-				enum sh_css_input_mode input_mode)
-{
-	sh_css_sp_group.config.input_circuit.no_side_band = false;
-	sh_css_sp_group.config.input_circuit.fmt_type     = fmt_type;
-	sh_css_sp_group.config.input_circuit.ch_id	      = ch_id;
-	sh_css_sp_group.config.input_circuit.input_mode   = input_mode;
-/*
- * The SP group is only loaded at SP boot time and is read once
- * change flags as "input_circuit_cfg_changed" must be reset on the SP
- */
-	sh_css_sp_group.config.input_circuit_cfg_changed = true;
-	sh_css_sp_stage.program_input_circuit = true;
-}
-
-void
-sh_css_sp_configure_sync_gen(int width, int height,
-			     int hblank_cycles,
-			     int vblank_cycles)
-{
-	sh_css_sp_group.config.sync_gen.width	       = width;
-	sh_css_sp_group.config.sync_gen.height	       = height;
-	sh_css_sp_group.config.sync_gen.hblank_cycles = hblank_cycles;
-	sh_css_sp_group.config.sync_gen.vblank_cycles = vblank_cycles;
-}
-
-void
-sh_css_sp_configure_tpg(int x_mask,
-			int y_mask,
-			int x_delta,
-			int y_delta,
-			int xy_mask)
-{
-	sh_css_sp_group.config.tpg.x_mask  = x_mask;
-	sh_css_sp_group.config.tpg.y_mask  = y_mask;
-	sh_css_sp_group.config.tpg.x_delta = x_delta;
-	sh_css_sp_group.config.tpg.y_delta = y_delta;
-	sh_css_sp_group.config.tpg.xy_mask = xy_mask;
-}
-
-void
-sh_css_sp_configure_prbs(int seed)
-{
-	sh_css_sp_group.config.prbs.seed = seed;
-}
-
-enum sh_css_err
-sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args,
-				unsigned pipe_num, unsigned stage_num)
-{
-	enum sh_css_err err = sh_css_success;
-	if (args->in_frame)
-		err = set_input_frame_buffer(args->in_frame,
-						pipe_num, stage_num);
-	if (err == sh_css_success && args->in_ref_frame)
-		err = set_ref_in_frame_buffer(args->in_ref_frame,
-						pipe_num, stage_num);
-	if (err == sh_css_success && args->in_tnr_frame)
-		err = set_tnr_in_frame_buffer(args->in_tnr_frame,
-						pipe_num, stage_num);
-	if (err == sh_css_success && args->out_vf_frame)
-		err = set_view_finder_buffer(args->out_vf_frame,
-						pipe_num, stage_num);
-	if (err == sh_css_success && args->extra_frame)
-		err = set_capture_pp_frame_buffer(args->extra_frame,
-						pipe_num, stage_num);
-	if (err == sh_css_success && args->out_ref_frame)
-		err = set_ref_out_frame_buffer(args->out_ref_frame,
-						pipe_num, stage_num);
-	if (err == sh_css_success && args->out_tnr_frame)
-		err = set_tnr_out_frame_buffer(args->out_tnr_frame,
-						pipe_num, stage_num);
-	if (err == sh_css_success && args->out_frame)
-		err = set_output_frame_buffer(args->out_frame,
-						pipe_num, stage_num);
-	return err;
-}
-
-void
-sh_css_sp_init_group(bool two_ppc, enum sh_css_input_format input_format,
-		     bool no_isp_sync)
-{
-	sh_css_sp_group.config.input_formatter.stream_format = input_format;
-	sh_css_sp_group.config.input_formatter.isp_2ppc = two_ppc;
-
-	sh_css_sp_group.config.no_isp_sync = no_isp_sync;
-	/* decide whether the frame is processed online or offline */
-	sh_css_sp_group.config.is_offline  = sh_css_continuous_start_sp_copy();
-}
-
-void
-sh_css_stage_write_binary_info(struct sh_css_binary_info *info)
-{
-	sh_css_isp_stage.binary_info = *info;
-}
-
-static enum sh_css_err
-sh_css_sp_init_stage(struct sh_css_binary *binary,
-		    const char *binary_name,
-		    const struct sh_css_blob_info *blob_info,
-		    const struct sh_css_binary_args *args,
-		    enum sh_css_pipe_id id,
-		    unsigned stage,
-		    bool preview_mode,
-		    bool low_light,
-		    bool xnr,
-		    unsigned irq_buf_flags,
-		    const struct sh_css_hmm_isp_interface *isp_mem_if)
-{
-	const struct sh_css_binary_info *info;
-	enum sh_css_err err = sh_css_success;
-	int i;
-
-	enum sh_css_pipe_id pipe_id = id;
-	unsigned int thread_id;
-	bool continuous = sh_css_continuous_is_enabled();
-	{
-		/**
-		 * Clear sh_css_sp_stage for easy debugging.
-		 * program_input_circuit must be saved as it is set outside
-		 * this function.
-		 */
-		unsigned int program_input_circuit;
-		program_input_circuit = sh_css_sp_stage.program_input_circuit;
-		memset(&sh_css_sp_stage, 0, sizeof(sh_css_sp_stage));
-		sh_css_sp_stage.program_input_circuit = program_input_circuit;
-	}
-
-	sh_css_query_sp_thread_id(pipe_id, &thread_id);
-	sh_css_sp_group.pipe[thread_id].num_stages++;
-
-	if (binary == NULL)
-		return sh_css_err_internal_error;
-	info = binary->info;
-
-	if (info == NULL) {
-		sh_css_sp_group.pipe[thread_id].sp_stage_addr[stage] = mmgr_NULL;
-		return sh_css_success;
-	}
-
-	sh_css_sp_stage.deinterleaved = stage == 0 &&
-					sh_css_continuous_is_enabled();
-
-	/*
-	 * TODO: Make the Host dynamically determine
-	 * the stage type.
-	 */
-	sh_css_sp_stage.stage_type = SH_CSS_ISP_STAGE_TYPE;
-	sh_css_sp_stage.num		= stage;
-	sh_css_sp_stage.isp_online	= binary && binary->online;
-	sh_css_sp_stage.isp_copy_vf     = args->copy_vf;
-	sh_css_sp_stage.isp_copy_output = args->copy_output;
-	/* These flags wil be set from the css top level */
-	sh_css_sp_stage.irq_buf_flags   = irq_buf_flags;
-
-	/* Copy the frame infos first, to be overwritten by the frames,
-	   if these are present.
-	*/
-	sh_css_frame_info_to_sp(&sh_css_sp_stage.frames.in.info,
-				&binary->in_frame_info);
-	sh_css_frame_info_to_sp(&sh_css_sp_stage.frames.out.info,
-				&binary->out_frame_info);
-	sh_css_frame_info_to_sp(&sh_css_sp_stage.frames.internal_frame_info,
-				&binary->internal_frame_info);
-	sh_css_sp_stage.dvs_envelope.width    = binary->dvs_envelope.width;
-	sh_css_sp_stage.dvs_envelope.height   = binary->dvs_envelope.height;
-	sh_css_sp_stage.isp_deci_log_factor   = binary->deci_factor_log2;
-	sh_css_sp_stage.isp_vf_downscale_bits = binary->vf_downscale_log2;
-
-	sh_css_sp_stage.sp_enable_xnr = xnr;
-/*	sh_css_sp_stage.uds.extra_vectors   = info->uds.extra_vectors; */ /* task 3340 */
-	sh_css_sp_stage.xmem_bin_addr = info->xmem_addr;
-	sh_css_sp_stage.xmem_map_addr = sh_css_params_ddr_address_map();
-	sh_css_sp_stage.anr	      = low_light;
-	sh_css_isp_stage.blob_info = *blob_info;
-	sh_css_stage_write_binary_info((struct sh_css_binary_info *)info);
-	memcpy(sh_css_isp_stage.binary_name, binary_name,
-		strlen(binary_name)+1);
-	memcpy(&sh_css_isp_stage.mem_interface, isp_mem_if,
-		sizeof(sh_css_isp_stage.mem_interface));
-
-#if 0
-	{
-		struct sh_css_vector motion;
-		struct sh_css_zoom zoom;
-
-		sh_css_get_zoom(&zoom);
-		sh_css_get_dis_motion(&motion);
-
-		sh_css_update_uds_and_crop_info(binary->info,
-					&binary->in_frame_info,
-					&binary->out_frame_info,
-					&binary->dvs_envelope,
-					preview_mode,
-					&zoom,
-					&motion,
-					&sh_css_sp_stage.uds,
-					&sh_css_sp_stage.sp_out_crop_pos);
-	}
-#else
-	/**
-	 * Even when a stage does not need uds and does not params,
-	 * sp_uds_init() seems to be called (needs further investigation)
-	 * This function can not deal with dx, dy = {0, 0}
-	 */
-	(void)preview_mode;
-#if 0
-	sh_css_sp_stage.uds =
-		(struct sh_css_uds_info){HRT_GDC_N, HRT_GDC_N, 0, 0};
-#endif
-
-#endif
-
-	sh_css_params_set_current_binary(binary);
-
-	/* Clean static frame info before we update it */
-	/*
-	 * TODO: Initialize the static frame data with
-	 * "sh_css_frame_null".
-	 */
-	for (i = 0; i < SH_CSS_NUM_FRAME_IDS; i++)
-		/* Here, we do not initialize it to zero for now */
-		/* to be able to recognize non-updated elements  */
-		sh_css_sp_stage.frames.static_frame_data[i] = -1;
-
-	err = sh_css_sp_write_frame_pointers(args, pipe_id, stage);
-	if (err != sh_css_success)
-		return err;
-
-	if (continuous &&  binary->info->enable.raw_binning) {
-		/* TODO: Remove this after preview output decimation is fixed
-		 * by configuring out&vf info fiels properly */
-		sh_css_sp_stage.frames.out.info.padded_width
-			<<= binary->vf_downscale_log2;
-		sh_css_sp_stage.frames.out.info.width
-			<<= binary->vf_downscale_log2;
-		sh_css_sp_stage.frames.out.info.height
-			<<= binary->vf_downscale_log2;
-	}
-
-	store_sp_stage_data(pipe_id, stage);
-
-	return sh_css_success;
-}
-
-static enum sh_css_err
-sp_init_stage(struct sh_css_pipeline_stage *stage,
-		    enum sh_css_pipe_id id,
-		    unsigned stage_num,
-		    bool preview_mode,
-	      bool low_light,
-	      bool xnr)
-{
-	struct sh_css_binary *binary = stage->binary;
-	const struct sh_css_fw_info *firmware = stage->firmware;
-	const struct sh_css_binary_args *args = &stage->args;
-	const unsigned char *binary_name;
-	const struct sh_css_binary_info *info = NULL;
-	struct sh_css_binary tmp_binary;
-	const struct sh_css_blob_info *blob_info;
-	struct sh_css_hmm_isp_interface isp_mem_if[SH_CSS_NUM_ISP_MEMORIES];
-	const struct sh_css_hmm_isp_interface *mem_if = isp_mem_if;
-	enum sh_css_pipe_id pipe_id = id;
-
-	memset(isp_mem_if, 0, sizeof(isp_mem_if));
-
-	if (binary) {
-		info = binary->info;
-		binary_name =
-			(const unsigned char *)(info->blob->name);
-		blob_info = &info->blob->header.blob;
-	} else {
-		info = &firmware->info.isp;
-		sh_css_fill_binary_info(info, false, false,
-			    SH_CSS_INPUT_FORMAT_RAW_10,
-			    args->in_frame  ? &args->in_frame->info  : NULL,
-			    args->out_frame ? &args->out_frame->info : NULL,
-			    args->out_vf_frame ? &args->out_vf_frame->info
-						: NULL,
-			    &tmp_binary,
-			    false);
-		binary = &tmp_binary;
-		binary->info = info;
-		binary_name = SH_CSS_EXT_ISP_PROG_NAME(firmware);
-		blob_info = &firmware->blob;
-		mem_if = firmware->memory_interface;
-	}
-
-	sh_css_dtrace(SH_DBG_TRACE,
-		"sp_init_stage(): load binary: %s\n", binary_name);
-#ifdef __KERNEL__
-	printk(KERN_ERR "load binary: %s\n", binary_name);
-#endif
-
-	sh_css_sp_init_stage(binary,
-			     (const char *)binary_name,
-			     blob_info,
-			     args,
-			     pipe_id,
-			     stage_num,
-			     preview_mode,
-			     low_light,
-			     xnr,
-				stage->irq_buf_flags,
-				mem_if);
-	return sh_css_success;
-}
-
-void
-sh_css_sp_init_pipeline(struct sh_css_pipeline *me,
-			enum sh_css_pipe_id id,
-			bool preview_mode,
-			bool low_light,
-			bool xnr,
-			bool two_ppc,
-			bool continuous,
-			bool offline,
-			bool input_needs_raw_binning,
-			enum sh_css_pipe_config_override copy_ovrd)
-{
-	/* Get first stage */
-	struct sh_css_pipeline_stage *stage;
-	struct sh_css_binary	     *first_binary = me->stages->binary;
-	struct sh_css_binary_args    *first_args   = &me->stages->args;
-	unsigned num;
-
-	enum sh_css_pipe_id pipe_id = id;
-	unsigned int thread_id;
-
-	sh_css_query_sp_thread_id(pipe_id, &thread_id);
-	memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));
-
-	/* Count stages */
-	for (stage = me->stages, num = 0; stage; stage = stage->next, num++) {
-		stage->stage_num = num;
-		sh_css_debug_pipe_graph_dump_stage(stage, id);
-	}
-	me->num_stages = num;
-
-	if (first_binary != NULL) {
-	/* Init pipeline data */
-		sh_css_sp_init_group(two_ppc, first_binary->input_format, offline);
-	/* for Capture, do we need to add more modes like */
-		if (continuous &&
-			(first_binary->info->mode == SH_CSS_BINARY_MODE_PREVIEW ||
-			 first_binary->info->mode == SH_CSS_BINARY_MODE_PRIMARY)) {
-#if 0
-			sh_css_queue_buffer(SH_CSS_COPY_PIPELINE,
-				SH_CSS_BUFFER_TYPE_OUTPUT_FRAME,
-				(void *)first_args->cc_frame);
-#endif
-			sh_css_sp_start_raw_copy(first_binary, first_args->cc_frame,
-				two_ppc, input_needs_raw_binning,
-				copy_ovrd);
-
-			sh_css_debug_pipe_graph_dump_sp_raw_copy(first_args->cc_frame);
-		}
-	} /* if (first_binary != NULL) */
-
-	/* Init stage data */
-	sh_css_init_host2sp_frame_data();
-
-	sh_css_sp_group.pipe[thread_id].num_stages = 0;
-	sh_css_sp_group.pipe[thread_id].pipe_id = pipe_id;
-	/* TODO: next indicates from which queues parameters need to be
-		 sampled, needs checking/improvement */
-	if (sh_css_pipe_uses_params(me)) {
-		sh_css_sp_group.pipe[thread_id].pipe_config =
-			SH_CSS_PIPE_CONFIG_SAMPLE_PARAMS << thread_id;
-	}
-
-	/* For continuous use-cases, SP copy is responsible for sampling the
-	 * parameters */
-	if (sh_css_continuous_is_enabled())
-		sh_css_sp_group.pipe[thread_id].pipe_config = 0;
-
-	for (stage = me->stages, num = 0; stage; stage = stage->next, num++)
-		sp_init_stage(stage, pipe_id, num, preview_mode, low_light, xnr);
-
-	store_sp_group_data();
-
-}
-
-void
-sh_css_sp_uninit_pipeline(enum sh_css_pipe_id pipe_id)
-{
-	unsigned int thread_id;
-	sh_css_query_sp_thread_id(pipe_id, &thread_id);
-	/*memset(&sh_css_sp_group.pipe[thread_id], 0, sizeof(struct sh_css_sp_pipeline));*/
-	sh_css_sp_group.pipe[thread_id].num_stages = 0;
-}
-#if 0
-static void
-init_host2sp_command(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
-				/ sizeof(int);
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-	store_sp_array_uint(host_sp_com, o, host2sp_cmd_ready);
-}
-#endif
-
-void
-sh_css_write_host2sp_command(enum host2sp_commands host2sp_command)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
-				/ sizeof(int);
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-
-	/* Previous command must be handled by SP (by design) */
-assert(load_sp_array_uint(host_sp_com, o) == host2sp_cmd_ready);
-
-	store_sp_array_uint(host_sp_com, o, host2sp_command);
-}
-
-enum host2sp_commands
-sh_css_read_host2sp_command(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-	unsigned int o = offsetof(struct host_sp_communication, host2sp_command)
-				/ sizeof(int);
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-	return load_sp_array_uint(host_sp_com, o);
-}
-
-
-/*
- * Frame data is no longer part of the sp_stage structure but part of a
- * seperate structure. The aim is to make the sp_data struct static
- * (it defines a pipeline) and that the dynamic (per frame) data is stored
- * separetly.
- *
- * This function must be called first every where were you start constructing
- * a new pipeline by defining one or more stages with use of variable
- * sh_css_sp_stage. Even the special cases like accelerator and copy_frame
- * These have a pipeline of just 1 stage.
- */
-void
-sh_css_init_host2sp_frame_data(void)
-{
-	/* Clean table */
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-	/*
-	 * rvanimme: don't clean it to save static frame info line ref_in
-	 * ref_out, tnr_in and tnr_out. Once this static data is in a
-	 * seperate data struct, this may be enable (but still, there is
-	 * no need for it)
-	 */
-#if 0
-	unsigned i;
-	for (i = 0; i < SH_CSS_MAX_PIPELINES*SH_CSS_NUM_FRAME_IDS; i++)
-		store_sp_array_uint(host_sp_com, i+o, 0);
-#endif
-}
-
-
-/**
- * @brief Update the offline frame information in host_sp_communication.
- * Refer to "sh_css_sp.h" for more details.
- */
-void
-sh_css_update_host2sp_offline_frame(
-				unsigned frame_num,
-				struct sh_css_frame *frame)
-{
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_host_sp_com;
-	unsigned int o;
-
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-
-assert(frame_num < NUM_CONTINUOUS_FRAMES);
-
-	/* Write new frame data into SP DMEM */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-	o = offsetof(struct host_sp_communication, host2sp_offline_frames)
-		/ sizeof(int);
-	o += frame_num;
-
-	store_sp_array_uint(host_sp_com, o,
-				frame ? frame->data : 0);
-}
-
-void
-sh_css_update_host2sp_cont_num_raw_frames(unsigned num_frames, bool set_avail)
-{
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_host_sp_com;
-	unsigned int extra_num_frames, avail_num_frames;
-	unsigned int o, o_extra;
-
-	(void)HIVE_ADDR_host_sp_com; /* Suppres warnings in CRUN */
-
-	/* Write new frame data into SP DMEM */
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_host_sp_com = fw->info.sp.host_sp_com;
-	if (set_avail) {
-
-		o = offsetof(struct host_sp_communication, host2sp_cont_avail_num_raw_frames)
-			/ sizeof(int);
-		avail_num_frames = load_sp_array_uint(host_sp_com, o);
-		extra_num_frames = num_frames - avail_num_frames;
-		o_extra = offsetof(struct host_sp_communication, host2sp_cont_extra_num_raw_frames)
-			/ sizeof(int);
-		store_sp_array_uint(host_sp_com, o_extra,
-				extra_num_frames);
-	} else
-		o = offsetof(struct host_sp_communication, host2sp_cont_target_num_raw_frames)
-			/ sizeof(int);
-
-	store_sp_array_uint(host_sp_com, o,
-				num_frames);
-
-}
-
-void
-sh_css_sp_set_sp_running(bool flag)
-{
-	sp_running = flag;
-}
-
-void
-sh_css_sp_start_isp(void)
-{
-	const struct sh_css_fw_info *fw;
-	unsigned int HIVE_ADDR_sp_sw_state;
-	
-	fw = &sh_css_sp_fw;
-	HIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;
-	
-
-	if (sp_running)
-		return;
-
-	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
-	
-
-	sh_css_debug_pipe_graph_dump_epilogue();
-#if !defined(C_RUN) && !defined(HRT_UNSCHED)
-	sh_css_sp_store_init_dmem(&sh_css_sp_fw);
-#endif
-
-	store_sp_per_frame_data(fw);
-	
-	sp_dmem_store_uint32(SP0_ID,
-		(unsigned int)sp_address_of(sp_sw_state),
-		(uint32_t)(SP_READY_TO_START));
-
-
-	//init_host2sp_command();
-	/* Note 1: The sp_start_isp function contains a wait till
-	 * the input network is configured by the SP.
-	 * Note 2: Not all SP binaries supports host2sp_commands.
-	 * In case a binary does support it, the host2sp_command
-	 * will have status cmd_ready after return of the function
-	 * sh_css_hrt_sp_start_isp. There is no race-condition here
-	 * because only after the process_frame command has been
-	 * received, the SP starts configuring the input network.
-	 */
-	sh_css_mmu_invalidate_cache();
-	sh_css_hrt_sp_start_isp();
-
-	sp_running = true;
-}
-
-bool
-sh_css_isp_has_started(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_isp_started = fw->info.sp.isp_started;
-	(void)HIVE_ADDR_sp_isp_started; /* Suppres warnings in CRUN */
-
-	return load_sp_uint(sp_isp_started);
-}
-
-bool
-sh_css_sp_has_booted(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;
-	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
-
-	return (load_sp_uint(sp_sw_state) == SP_BOOTED);
-}
-
-bool
-sh_css_sp_has_terminated(void)
-{
-	const struct sh_css_fw_info *fw = &sh_css_sp_fw;
-	unsigned int HIVE_ADDR_sp_sw_state = fw->info.sp.sw_state;
-	(void)HIVE_ADDR_sp_sw_state; /* Suppres warnings in CRUN */
-	return (load_sp_uint(sp_sw_state) == SP_TERMINATED);
-}
-
-/**
- * @brief Initialize the DMA software-mask in the debug mode.
- * Refer to "sh_css_sp.h" for more details.
- */
-bool
-sh_css_sp_init_dma_sw_reg(int dma_id)
-{
-	int i;
-
-	/* enable all the DMA channels */
-	for (i = 0; i < N_DMA_CHANNEL_ID; i++) {
-		/* enable the writing request */
-		sh_css_sp_set_dma_sw_reg(dma_id,
-				i,
-				0,
-				true);
-		/* enable the reading request */
-		sh_css_sp_set_dma_sw_reg(dma_id,
-				i,
-				1,
-				true);
-	}
-
-	return true;
-}
-
-/**
- * @brief Set the DMA software-mask in the debug mode.
- * Refer to "sh_css_sp.h" for more details.
- */
-bool
-sh_css_sp_set_dma_sw_reg(int dma_id,
-		int channel_id,
-		int request_type,
-		bool enable)
-{
-	uint32_t sw_reg;
-	uint32_t bit_val;
-	uint32_t bit_offset;
-	uint32_t bit_mask;
-
-	(void)dma_id;
-
-assert(channel_id >= 0 && channel_id < N_DMA_CHANNEL_ID);
-assert(request_type >= 0);
-
-	/* get the software-mask */
-	sw_reg =
-		sh_css_sp_group.debug.dma_sw_reg;
-
-	/* get the offest of the target bit */
-	bit_offset = (8 * request_type) + channel_id;
-
-	/* clear the value of the target bit */
-	bit_mask = ~(1 << bit_offset);
-	sw_reg &= bit_mask;
-
-	/* set the value of the bit for the DMA channel */
-	bit_val = enable ? 1 : 0;
-	bit_val <<= bit_offset;
-	sw_reg |= bit_val;
-
-	/* update the software status of DMA channels */
-	sh_css_sp_group.debug.dma_sw_reg = sw_reg;
-
-	return true;
-}
-
-/**
- * @brief The Host sends the event to the SP.
- * Refer to "sh_css_sp.h" for details.
- */
-void
-sh_css_sp_snd_event(int evt_id, int evt_payload_0, int evt_payload_1, int evt_payload_2)
-{
-	uint32_t tmp[4];
-	uint32_t sw_event;
-	unsigned long timeout = CSS_TIMEOUT_US;
-
-	/*
-	 * Encode the queue type, the thread ID and
-	 * the queue ID into the event.
-	 */
-	tmp[0] = (uint32_t)evt_id;
-	tmp[1] = (uint32_t)evt_payload_0;
-	tmp[2] = (uint32_t)evt_payload_1;
-	tmp[3] = (uint32_t)evt_payload_2;
-	encode_sw_event(tmp, 4, &sw_event);
-
-	/* queue the software event (busy-waiting) */
-	while (!host2sp_enqueue_sp_event(sw_event) && timeout) {
-		timeout--;
-		hrt_sleep();
-	}
-	if (timeout == 0) {
-		sh_css_dump_debug_info("sh_css_sp_snd_event point1");
-		sh_css_dump_sp_sw_debug_info();
-#ifdef __KERNEL__
-		printk(KERN_ERR "%s poll timeout point 1!!!\n", __func__);
-#endif
-	}
-}
-
-void
-sh_css_sp_reset_global_vars(void)
-{
-	memset(&sh_css_sp_group, 0, sizeof(struct sh_css_sp_group));
-	memset(&sh_css_sp_stage, 0, sizeof(struct sh_css_sp_stage));
-	memset(&sh_css_isp_stage, 0, sizeof(struct sh_css_isp_stage));
-	memset(&sh_css_sp_output, 0, sizeof(struct sh_css_sp_output));
-	memset(&per_frame_data, 0, sizeof(struct sh_css_sp_per_frame_data));
-}
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.h
deleted file mode 100644
index aaf70ae..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp.h
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_SP_H_
-#define _SH_CSS_SP_H_
-
-#include "input_formatter.h"
-
-#include "sh_css_binary.h"
-#include "sh_css_internal.h"
-#include "sh_css_types.h"
-
-/* Function to initialize the data and bss section descr of the binary */
-void
-sh_css_sp_store_init_dmem(const struct sh_css_fw_info *fw);
-
-void
-store_sp_stage_data(enum sh_css_pipe_id id, unsigned stage);
-
-void
-sh_css_stage_write_binary_info(struct sh_css_binary_info *info);
-
-void
-sh_css_sp_init_group(bool two_ppc, enum sh_css_input_format input_format,
-		     bool no_isp_sync);
-
-void
-store_sp_group_data(void);
-
-enum sh_css_err
-sh_css_sp_init(void);
-
-void
-sh_css_sp_uninit(void);
-
-/* Start binary (jpeg) copy on the SP */
-void
-sh_css_sp_start_binary_copy(struct sh_css_frame *out_frame,
-			    unsigned two_ppc);
-
-/* Start raw copy on the SP */
-void
-sh_css_sp_start_raw_copy(struct sh_css_binary *binary,
-			 struct sh_css_frame *out_frame,
-			 unsigned two_ppc,
-			 bool input_needs_raw_binning,
-			 enum sh_css_pipe_config_override pco);
-
-unsigned int
-sh_css_sp_get_binary_copy_size(void);
-
-/* Return the value of a SW interrupt */
-unsigned int
-sh_css_sp_get_sw_interrupt_value(unsigned int irq);
-
-void
-sh_css_sp_init_pipeline(struct sh_css_pipeline *me,
-			enum sh_css_pipe_id id,
-			bool preview_mode,
-			bool low_light,
-			bool xnr,
-			bool two_ppc,
-			bool continuous,
-			bool offline,
-			bool input_needs_raw_binning,
-			enum sh_css_pipe_config_override copy_ovrd);
-
-void
-sh_css_sp_uninit_pipeline(enum sh_css_pipe_id pipe_id);
-
-void
-sh_css_write_host2sp_command(enum host2sp_commands host2sp_command);
-
-enum host2sp_commands
-sh_css_read_host2sp_command(void);
-
-void
-sh_css_init_host2sp_frame_data(void);
-
-#if 0
-/* Temporarily prototypes till we have the proper header files and final
- * function names
- */
-extern bool
-host2sp_enqueue_frame_data(
-			unsigned int pipe_num,
-			enum sh_css_frame_id frame_id,
-			void *frame_data);	/* IN */
-
-extern bool sp2host_dequeue_irq_event(void *irq_event);
-#endif
-
-/**
- * @brief Update the offline frame information in host_sp_communication.
- *
- * @param[in] frame_num The offline frame number.
- * @param[in] frame The pointer to the offline frame.
- */
-void
-sh_css_update_host2sp_offline_frame(
-				unsigned frame_num,
-				struct sh_css_frame *frame);
-
-/**
- * @brief Update the nr of offline frames to use in host_sp_communication.
- *
- * @param[in] num_frames The number of raw frames to use.
- */
-void
-sh_css_update_host2sp_cont_num_raw_frames(unsigned num_frames, bool set_avail);
-
-void
-sh_css_sp_start_isp(void);
-
-void
-sh_css_sp_set_sp_running(bool flag);
-
-#if SP_DEBUG !=SP_DEBUG_NONE
-
-void
-sh_css_sp_get_debug_state(struct sh_css_sp_debug_state *state);
-
-#endif
-
-extern void sh_css_sp_set_if_configs(
-	const input_formatter_cfg_t		*config_a,
-	const input_formatter_cfg_t		*config_b);
-
-void
-sh_css_sp_program_input_circuit(int fmt_type,
-				int ch_id,
-				enum sh_css_input_mode input_mode);
-
-void
-sh_css_sp_configure_sync_gen(int width,
-			     int height,
-			     int hblank_cycles,
-			     int vblank_cycles);
-
-void
-sh_css_sp_configure_tpg(int x_mask,
-			int y_mask,
-			int x_delta,
-			int y_delta,
-			int xy_mask);
-
-void
-sh_css_sp_configure_prbs(int seed);
-
-void
-sh_css_sp_reset_global_vars(void);
-
-enum sh_css_err
-sh_css_sp_write_frame_pointers(const struct sh_css_binary_args *args,
-				unsigned pipe_num, unsigned stage_num);
-
-/**
- * @brief Initialize the DMA software-mask in the debug mode.
- * This API should be ONLY called in the debugging mode.
- * And it should be always called before the first call of
- * "sh_css_set_dma_sw_reg(...)".
- *
- * @param[in]	dma_id		The ID of the target DMA.
- *
- * @return
- *	- true, if it is successful.
- *	- false, otherwise.
- */
-extern bool sh_css_sp_init_dma_sw_reg(int dma_id);
-
-/**
- * @brief Set the DMA software-mask in the debug mode.
- * This API should be ONLYL called in the debugging mode. Must
- * call "sh_css_set_dma_sw_reg(...)" before this
- * API is called for the first time.
- *
- * @param[in]	dma_id		The ID of the target DMA.
- * @param[in]	channel_id	The ID of the target DMA channel.
- * @param[in]	request_type	The type of the DMA request.
- *				For example:
- *				- "0" indicates the writing request.
- *				- "1" indicates the reading request.
- *
- * @param[in]	enable		If it is "true", the target DMA
- *				channel is enabled in the software.
- *				Otherwise, the target DMA channel
- *				is disabled in the software.
- *
- * @return
- *	- true, if it is successful.
- *	- false, otherwise.
- */
-extern bool sh_css_sp_set_dma_sw_reg(int dma_id,
-		int channel_id,
-		int request_type,
-		bool enable);
-
-/**
- * @brief The Host sends the event to the SP.
- * The caller of this API will be blocked until the event
- * is sent.
- *
- * @param[in]	evt_id		The event ID.
- * @param[in]	evt_payload_0	The event payload.
- * @param[in]	evt_payload_1	The event payload.
- * @param[in]	evt_payload_2	The event payload.
- */
-extern void sh_css_sp_snd_event(int evt_id,
-		int evt_payload_0,
-		int evt_payload_1,
-		int evt_payload_2);
-
-extern struct sh_css_sp_group sh_css_sp_group;
-extern struct sh_css_sp_stage sh_css_sp_stage;
-extern struct sh_css_isp_stage sh_css_isp_stage;
-
-#endif /* _SH_CSS_SP_H_ */
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.c
deleted file mode 100644
index 3a83a04..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.c
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#include "sh_css_sp_start.h"
-#include "sh_css_sp.h"
-#include "sh_css_firmware.h"
-
-#define __INLINE_SP__
-#include "sp.h"
-
-#include "mmu_device.h"
-
-#include "memory_access.h"
-
-#include "assert_support.h"
-
-static bool invalidate_mmu;
-
-void
-sh_css_sp_invalidate_mmu(void)
-{
-	invalidate_mmu = true;
-}
-
-void sh_css_sp_start(
-	unsigned int start_address)
-{
-assert(sizeof(unsigned int) <= sizeof(hrt_data));
-
-	if (invalidate_mmu) {
-		mmu_invalidate_cache(MMU0_ID);
-		invalidate_mmu = false;
-	}
-	/* set the start address */
-	sp_ctrl_store(SP0_ID, SP_START_ADDR_REG, (hrt_data)start_address);
-	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_RUN_BIT);
-	sp_ctrl_setbit(SP0_ID, SP_SC_REG, SP_START_BIT);
-return;
-}
-
-
-hrt_vaddress sh_css_sp_load_program(
-	const struct sh_css_fw_info *fw,
-	const char *sp_prog,
-	hrt_vaddress code_addr)
-{
-	if (code_addr == mmgr_NULL) {
-		/* store code (text section) to DDR */
-		code_addr = mmgr_malloc(fw->blob.text_size);
-		if (code_addr == mmgr_NULL)
-			return code_addr;
-		mmgr_store(code_addr, fw->blob.text, fw->blob.text_size);
-	}
-
-	/* Set the correct start address for the SP program */
-	sh_css_sp_activate_program(fw, code_addr, sp_prog);
-
-return code_addr;
-}
-
-void sh_css_sp_activate_program(
-	const struct sh_css_fw_info *fw,
-	hrt_vaddress code_addr,
-	const char *sp_prog)
-{
-	(void)sp_prog; /* not used on hardware, only for simulation */
-
-assert(sizeof(hrt_vaddress) <= sizeof(hrt_data));
-	/* now we program the base address into the icache and
-	 * invalidate the cache.
-	 */
-	sp_ctrl_store(SP0_ID, SP_ICACHE_ADDR_REG, (hrt_data)code_addr);
-	sp_ctrl_setbit(SP0_ID, SP_ICACHE_INV_REG, SP_ICACHE_INV_BIT);
-
-	/* Set descr in the SP to initialize the SP DMEM */
-	sh_css_sp_store_init_dmem(fw);
-return;
-}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.h
deleted file mode 100644
index b821afa..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_sp_start.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_SP_START_H_
-#define _SH_CSS_SP_START_H_
-
-#include <stdint.h>
-
-#define __INLINE_SP__
-#include "sp.h"
-
-#include "mmu_device.h"
-
-#include "sh_css_firmware.h"
-
-#define sh_css_sp_start_function(func) \
-	sh_css_sp_start(HIVE_ADDR_ ## func ## _entry)
-
-#define SH_CSS_PREVENT_UNINIT_READS 0
-
-void
-sh_css_sp_start(unsigned int start_address);
-
-hrt_vaddress
-sh_css_sp_load_program(const struct sh_css_fw_info *fw, const char *sp_prog,
-		       hrt_vaddress code_addr);
-
-void
-sh_css_sp_activate_program(const struct sh_css_fw_info *fw,
-			   hrt_vaddress code_addr,
-			   const char *sp_prog);
-
-void
-sh_css_sp_invalidate_mmu(void);
-
-#endif /* _SH_CSS_SP_START_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_types.h
deleted file mode 100644
index d75c0c0..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_types.h
+++ /dev/null
@@ -1,1035 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_TYPES_H_
-#define _SH_CSS_TYPES_H_
-
-/*! \file */
-
-/** @file ia_css_types.h
- * This file contains types used for the ia_css parameters.
- * These types are in a separate file because they are expected
- * to be used in software layers that do not access the CSS API
- * directly but still need to forward parameters for it.
- */
-
-/* This code is also used by Silicon Hive in a simulation environment
- * Therefore, the following macro is used to differentiate when this
- * code is being included from within the Linux kernel source
- */
-#include <stdbool.h>
-#include <system_types.h>	/* hrt_vaddress, HAS_IRQ_MAP_VERSION_# */
-
-/*#include "vamem.h"*/ /* Canot include for VAMEM properties this file is visible on ISP -> pipeline generator */
-/*#include "isp.h"*/	/* surrogate to get VAMEM "HAS" properties, causes other circular include issues */
-
-#ifdef __KERNEL__
-#include <linux/kernel.h>
-#include <linux/string.h>       /* memcpy() */
-#else
-#include <stdarg.h>             /* printf() */
-#include <stdlib.h>             /* size_t */
-#include <string.h>             /* memcpy() */
-#include "math_support.h"		/* min(), max() */
-#endif
-
-#define SH_CSS_MAJOR    0
-#define SH_CSS_MINOR    2
-#define SH_CSS_REVISION 5
-
-/** Number of axes in the MACC table. */
-#define SH_CSS_MACC_NUM_AXES           16
-/** Number of coefficients per MACC axes. */
-#define SH_CSS_MACC_NUM_COEFS          4
-/** The number of planes in the morphing table. */
-#define SH_CSS_MORPH_TABLE_NUM_PLANES  6
-/** Number of color planes in the shading table. */
-#define SH_CSS_SC_NUM_COLORS           4
-/** Number of DIS coefficient types (TBD) */
-#define SH_CSS_DIS_NUM_COEF_TYPES      6
-#define SH_CSS_DIS_COEF_TYPES_ON_DMEM  2
-
-/** Fractional bits for CTC gain */
-#define SH_CSS_CTC_COEF_SHIFT          13
-/** Fractional bits for GAMMA gain */
-#define SH_CSS_GAMMA_GAIN_K_SHIFT      13
-
-/*
- * MW: Note that there is a duplicate copy in "sh_css_defs.h"
- * This version is supposedly platform independent. Unfortunately
- * the support file IspConfig depends 
- */
-#if defined(HAS_VAMEM_VERSION_2)
-#define SH_CSS_CTC_TABLE_SIZE_LOG2      8
-#define SH_CSS_CTC_TABLE_SIZEM1         (1U<<SH_CSS_CTC_TABLE_SIZE_LOG2)
-#define SH_CSS_CTC_TABLE_SIZE           (SH_CSS_CTC_TABLE_SIZEM1 + 1)
-#define SH_CSS_GAMMA_TABLE_SIZE_LOG2    8
-#define SH_CSS_GAMMA_TABLE_SIZEM1	(1U<<SH_CSS_GAMMA_TABLE_SIZE_LOG2)
-#define SH_CSS_GAMMA_TABLE_SIZE         (SH_CSS_GAMMA_TABLE_SIZEM1 + 1)
-#define SH_CSS_XNR_TABLE_SIZE_LOG2      6
-#define SH_CSS_XNR_TABLE_SIZE	        (1U<<SH_CSS_XNR_TABLE_SIZE_LOG2)
-/*#define SH_CSS_XNR_TABLE_SIZE	        (SH_CSS_XNR_TABLE_SIZEM1 + 1)*/
-#define SH_CSS_RGB_GAMMA_TABLE_SIZE_LOG2    8
-#define SH_CSS_RGB_GAMMA_TABLE_SIZEM1	(1U<<SH_CSS_RGB_GAMMA_TABLE_SIZE_LOG2)
-#define SH_CSS_RGB_GAMMA_TABLE_SIZE     (SH_CSS_RGB_GAMMA_TABLE_SIZEM1 + 1)
-#elif defined(HAS_VAMEM_VERSION_1)
-/** Number of elements in the CTC table. */
-#define SH_CSS_CTC_TABLE_SIZE_LOG2      10
-#define SH_CSS_CTC_TABLE_SIZE           (1U<<SH_CSS_CTC_TABLE_SIZE_LOG2)
-/** Number of elements in the gamma table. */
-#define SH_CSS_GAMMA_TABLE_SIZE_LOG2    10
-#define SH_CSS_GAMMA_TABLE_SIZE         (1U<<SH_CSS_GAMMA_TABLE_SIZE_LOG2)
-/** Number of elements in the xnr table. */
-#define SH_CSS_XNR_TABLE_SIZE_LOG2      6
-#define SH_CSS_XNR_TABLE_SIZE           (1U<<SH_CSS_XNR_TABLE_SIZE_LOG2)
-/** Number of elements in the sRGB gamma table. */
-#define SH_CSS_RGB_GAMMA_TABLE_SIZE_LOG2 8
-#define SH_CSS_RGB_GAMMA_TABLE_SIZE      (1U<<SH_CSS_RGB_GAMMA_TABLE_SIZE_LOG2)
-#else
-#error "sh_css_types: Unknown VAMEM version"
-#endif
-
-/* Fixed point types.
- * NOTE: the 16 bit fixed point types actually occupy 32 bits
- * to save on extension operations in the ISP code.
- */
-/** Unsigned fixed point value, 0 integer bits, 16 fractional bits */
-#define u0_16 unsigned int
-/** Unsigned fixed point value, 2 integer bits, 14 fractional bits */
-#define u2_14 unsigned int
-/** Unsigned fixed point value, 5 integer bits, 11 fractional bits */
-#define u5_11 unsigned int
-/** Unsigned fixed point value, 8 integer bits, 8 fractional bits */
-#define u8_8  unsigned int
-/** Signed fixed point value, 0 integer bits, 15 fractional bits */
-#define s0_15 signed int
-
-typedef uint32_t ia_css_ptr;
-/** Frame formats, some of these come from fourcc.org, others are
-   better explained by video4linux2. The NV11 seems to be described only
-   on MSDN pages, but even those seem to be gone now.
-   Frames can come in many forms, the main categories are RAW, RGB and YUV
-   (or YCbCr). The YUV frames come in 4 flavors, determined by how the U and V
-   values are subsampled:
-   1. YUV420: hor = 2, ver = 2
-   2. YUV411: hor = 4, ver = 1
-   3. YUV422: hor = 2, ver = 1
-   4. YUV444: hor = 1, ver = 1
- */
-enum sh_css_frame_format {
-	SH_CSS_FRAME_FORMAT_NV11,       /**< 12 bit YUV 411, Y, UV plane */
-	SH_CSS_FRAME_FORMAT_NV12,       /**< 12 bit YUV 420, Y, UV plane */
-	SH_CSS_FRAME_FORMAT_NV16,       /**< 16 bit YUV 422, Y, UV plane */
-	SH_CSS_FRAME_FORMAT_NV21,       /**< 12 bit YUV 420, Y, VU plane */
-	SH_CSS_FRAME_FORMAT_NV61,       /**< 16 bit YUV 422, Y, VU plane */
-	SH_CSS_FRAME_FORMAT_YV12,       /**< 12 bit YUV 420, Y, V, U plane */
-	SH_CSS_FRAME_FORMAT_YV16,       /**< 16 bit YUV 422, Y, V, U plane */
-	SH_CSS_FRAME_FORMAT_YUV420,     /**< 12 bit YUV 420, Y, U, V plane */
-	SH_CSS_FRAME_FORMAT_YUV420_16,  /**< yuv420, 16 bits per subpixel */
-	SH_CSS_FRAME_FORMAT_YUV422,     /**< 16 bit YUV 422, Y, U, V plane */
-	SH_CSS_FRAME_FORMAT_YUV422_16,  /**< yuv422, 16 bits per subpixel */
-	SH_CSS_FRAME_FORMAT_UYVY,       /**< 16 bit YUV 422, UYVY interleaved */
-	SH_CSS_FRAME_FORMAT_YUYV,       /**< 16 bit YUV 422, YUYV interleaved */
-	SH_CSS_FRAME_FORMAT_YUV444,     /**< 24 bit YUV 444, Y, U, V plane */
-	SH_CSS_FRAME_FORMAT_YUV_LINE,   /**< Internal format, 2 y lines followed
-					     by a uvinterleaved line */
-	SH_CSS_FRAME_FORMAT_RAW,	/**< RAW, 1 plane */
-	SH_CSS_FRAME_FORMAT_RGB565,     /**< 16 bit RGB, 1 plane. Each 3 sub
-					     pixels are packed into one 16 bit
-					     value, 5 bits for R, 6 bits for G
-					     and 5 bits for B. */
-	SH_CSS_FRAME_FORMAT_PLANAR_RGB888, /**< 24 bit RGB, 3 planes */
-	SH_CSS_FRAME_FORMAT_RGBA888,	/**< 32 bit RGBA, 1 plane, A=Alpha
-					     (alpha is unused) */
-	SH_CSS_FRAME_FORMAT_QPLANE6, /**< Internal, for advanced ISP */
-	SH_CSS_FRAME_FORMAT_BINARY_8,	/**< byte stream, used for jpeg. For
-					     frames of this type, we set the
-					     height to 1 and the width to the
-					     number of allocated bytes. */
-	N_SH_CSS_FRAME_FORMAT
-};
-/* The maximum number of different frame formats any binary can support */
-#define SH_CSS_MAX_NUM_FRAME_FORMATS 19
-
-/** Vector with signed values. This is used to indicate motion for
- * Digital Image Stabilization.
- */
-struct sh_css_vector {
-	int x; /**< horizontal motion (in pixels) */
-	int y; /**< vertical motion (in pixels) */
-};
-
-struct sh_css_uds_info {
-	uint16_t curr_dx;
-	uint16_t curr_dy;
-	uint16_t xc;
-	uint16_t yc;
-};
-
-struct sh_css_zoom {
-	uint16_t dx;
-	uint16_t dy;
-};
-
-struct sh_css_crop_pos {
-	uint16_t x;
-	uint16_t y;
-};
-
-struct sh_css_dvs_envelope {
-	uint16_t width;
-	uint16_t height;
-};
-
-/** 3A statistics grid */
-struct sh_css_3a_grid_info {
-	unsigned int enable;            /**< 3A statistics enabled */
-	unsigned int use_dmem;          /**< DMEM or VMEM determines layout */
-	unsigned int width;		/**< Width of 3A grid */
-	unsigned int height;	        /**< Height of 3A grid */
-	unsigned int aligned_width;     /**< Horizontal stride (for alloc) */
-	unsigned int aligned_height;    /**< Vertical stride (for alloc) */
-	unsigned int bqs_per_grid_cell; /**< Grid cell size */
-};
-
-/** DVS statistics grid */
-struct sh_css_dvs_grid_info {
-	unsigned int enable;        /**< DVS statistics enabled */
-	unsigned int width;	    /**< Width of DVS grid, this is equal to the
-					 the number of vertical statistics. */
-	unsigned int aligned_width; /**< Stride of each grid line */
-	unsigned int height;	    /**< Height of DVS grid, this is equal
-					 to the number of horizontal statistics.
-				     */
-	unsigned int aligned_height;/**< Stride of each grid column */
-	unsigned int bqs_per_grid_cell; /**< Grid cell size */
-};
-
-/** structure that describes the 3A and DIS grids */
-struct sh_css_grid_info {
-	/** \name ISP input size
-	  * that is visible for user
-	  * @{
-	  */
-	unsigned int isp_in_width;
-	unsigned int isp_in_height;
-	/** @}*/
-
-	struct sh_css_3a_grid_info  s3a_grid; /**< 3A grid info */
-	struct sh_css_dvs_grid_info dvs_grid; /**< DVS grid info */
-
-	unsigned int dvs_hor_coef_num;	/**< Number of horizontal coefficients. */
-	unsigned int dvs_ver_coef_num;	/**< Number of vertical coefficients. */
-};
-
-/** Optical black mode.
- */
-enum sh_css_ob_mode {
-	sh_css_ob_mode_none,
-	sh_css_ob_mode_fixed,
-	sh_css_ob_mode_raster
-};
-
-/** The 4 colors that a shading table consists of.
- *  For each color we store a grid of values.
- */
-enum sh_css_sc_color {
-	SH_CSS_SC_COLOR_GR, /**< Green on a green-red line */
-	SH_CSS_SC_COLOR_R,  /**< Red */
-	SH_CSS_SC_COLOR_B,  /**< Blue */
-	SH_CSS_SC_COLOR_GB  /**< Green on a green-blue line */
-};
-
-/** White Balance configuration (Gain Adjust).
- *  All values are uinteger_bits.16-integer_bits fixed point values.
- */
-struct sh_css_wb_config {
-	unsigned int integer_bits; /**< */
-	unsigned int gr;	/* unsigned <integer_bits>.<16-integer_bits> */
-	unsigned int r;		/* unsigned <integer_bits>.<16-integer_bits> */
-	unsigned int b;		/* unsigned <integer_bits>.<16-integer_bits> */
-	unsigned int gb;	/* unsigned <integer_bits>.<16-integer_bits> */
-};
-
-/** Color Space Conversion settings.
- *  The data is s13-fraction_bits.fraction_bits fixed point.
- */
-struct sh_css_cc_config {
-	unsigned int fraction_bits;
-	int matrix[3 * 3]; /**< RGB2YUV conversion matrix, signed
-				   <13-fraction_bits>.<fraction_bits> */
-};
-
-/** Morping table, used for geometric distortion and chromatic abberration
- *  correction (GDCAC, also called GDC).
- *  This table describes the imperfections introduced by the lens, the
- *  advanced ISP can correct for these imperfections using this table.
- */
-struct sh_css_morph_table {
-	unsigned int height; /**< Table height */
-	unsigned int width;  /**< Table width */
-	unsigned short *coordinates_x[SH_CSS_MORPH_TABLE_NUM_PLANES];
-	/**< X coordinates that describe the sensor imperfection */
-	unsigned short *coordinates_y[SH_CSS_MORPH_TABLE_NUM_PLANES];
-	/**< Y coordinates that describe the sensor imperfection */
-};
-
-/** Fixed pattern noise table. This contains the fixed patterns noise values
- *  obtained from a black frame capture.
- */
-struct sh_css_fpn_table {
-	short *data;		/**< Tbale content */
-	unsigned int width;	/**< Table height */
-	unsigned int height;	/**< Table width */
-	unsigned int shift;	/**< */
-};
-
-/** Lens color shading table. This describes the color shading artefacts
- *  introduced by lens imperfections.
- */
-struct sh_css_shading_table {
-	unsigned int sensor_width;  /**< Native sensor width in pixels */
-	unsigned int sensor_height; /**< Native sensor height in lines */
-	unsigned int width;  /**< Number of data points per line per color */
-	unsigned int height; /**< Number of lines of data points per color */
-	unsigned int fraction_bits; /**< Bits of fractional part in the data
-					    points */
-	unsigned short *data[SH_CSS_SC_NUM_COLORS];
-	/**< Table data, one array for each color. Use ia_css_sc_color to
-	     index this array */
-};
-
-/** Gamma table, used for gamma correction.
- */
-struct sh_css_gamma_table {
-	unsigned short data[SH_CSS_GAMMA_TABLE_SIZE];
-};
-
-/** CTC table (need to explain CTC)
- */
-struct sh_css_ctc_table {
-	unsigned short data[SH_CSS_CTC_TABLE_SIZE];
-};
-
-/** sRGB Gamma table, used for sRGB gamma correction.
- */
-struct sh_css_rgb_gamma_table {
-	unsigned short data[SH_CSS_RGB_GAMMA_TABLE_SIZE];
-};
-
-/** XNR table
- */
-struct sh_css_xnr_table {
-	unsigned short data[SH_CSS_XNR_TABLE_SIZE];
-};
-
-/** Multi-Axes Color Correction (MACC) table. */
-struct sh_css_macc_table {
-	short data[SH_CSS_MACC_NUM_COEFS * SH_CSS_MACC_NUM_AXES];
-};
-
-/** Temporal noise reduction (TNR) configuration.
- */
-struct sh_css_tnr_config {
-	u0_16 gain;		/**< Gain (strength) of NR */
-	u0_16 threshold_y;	/**< Motion sensitivity for Y */
-	u0_16 threshold_uv;	/**< Motion sensitivity for U/V */
-};
-
-/** Optical black level configuration.
- */
-struct sh_css_ob_config {
-	enum sh_css_ob_mode mode; /**< Mode (Fixed / Raster) */
-	u0_16 level_gr;    /**< Black level for GR pixels */
-	u0_16 level_r;     /**< Black level for R pixels */
-	u0_16 level_b;     /**< Black level for B pixels */
-	u0_16 level_gb;    /**< Black level for GB pixels */
-	unsigned short start_position; /**< Start position of OB area (used for
-				      raster mode only). Valid range is [0..63]. */
-	unsigned short end_position;  /**< End position of OB area (used for
-				      raster mode only).
-				      Valid range is [start_pos..64]. */
-};
-
-/** Defect pixel correction configuration.
- */
-struct sh_css_dp_config {
-	u0_16 threshold; /**< The threshold of defect Pixel Correction,
-			      representing the permissible difference of
-			      intensity between one pixel and its
-			      surrounding pixels. Smaller values result
-			      in more frequent pixel corrections. */
-	u8_8 gain;	 /**< The sensitivity of mis-correction. ISP will
-			      miss a lot of defects if the value is set
-			      too large. */
-};
-
-/** Configuration used by Bayer Noise Reduction (BNR) and
- *  YCC noise reduction (YNR).
- */
-struct sh_css_nr_config {
-	u0_16 bnr_gain;	    /**< Strength of noise reduction (BNR) */
-	u0_16 ynr_gain;	    /**< Strength of noise reduction (YNR */
-	u0_16 direction;    /**< Sensitivity of Edge (BNR) */
-	u0_16 threshold_cb; /**< Coring threshold for Cb (YNR) */
-	u0_16 threshold_cr; /**< Coring threshold for Cr (YNR) */
-};
-
-/** Edge Enhancement (sharpen) configuration.
- */
-struct sh_css_ee_config {
-	u5_11 gain;	   /**< The strength of sharpness. */
-	u8_8 threshold;    /**< The threshold that divides noises from
-				       edge. */
-	u5_11 detail_gain; /**< The strength of sharpness in pell-mell
-				       area. */
-};
-
-/** Demosaic (bayer-to-rgb) configuration.
- */
-struct sh_css_de_config {
-	u0_16 pixelnoise;	   /**< Pixel noise used in moire elimination */
-	u0_16 c1_coring_threshold; /**< Coring threshold for C1 */
-	u0_16 c2_coring_threshold; /**< Coring threshold for C2 */
-};
-
-/** Gamma Correction configuration.
-  */
-struct sh_css_gc_config {
-	unsigned short gain_k1; /**< */
-	unsigned short gain_k2; /**< */
-};
-
-
-
-/* 
- * NOTE: 
- * Temporary code until the proper mechanism for
- * host to receive tetragon coordinates is implemented.
- * Important:
- *   Enable only one of the following defines.
-*/
-#define DVS_6AXIS_COORDS_1080P_UNITY
-//#define DVS_6AXIS_COORDS_SMALL_UNITY
-//#define DVS_6AXIS_COORDS_SMALL_WARPED
-
-/* @GC: Comment on this & Remove the hard-coded values */
-#if defined(DVS_6AXIS_COORDS_1080P_UNITY)
-struct sh_css_dvs_6axis_config {
-	unsigned int xcoords[18][31];
-	unsigned int ycoords[18][31];
-};
-#elif defined(DVS_6AXIS_COORDS_SMALL_UNITY) ||\
-	defined(DVS_6AXIS_COORDS_SMALL_WARPED)
-struct sh_css_dvs_6axis_config {
-	unsigned int xcoords[10][13];
-	unsigned int ycoords[10][13];
-};
-#else
-#error No default DVS coordinate table specified.
-#endif
-
-
-/** Advanced Noise Reduction configuration.
- *  This is also known as Low-Light.
- */
-struct sh_css_anr_config {
-	int threshold; /**< Threshold */
-};
-
-/** Eigen Color Demosaicing configuration.
- */
-struct sh_css_ecd_config {
-	unsigned short ecd_zip_strength;
-	unsigned short ecd_fc_strength;
-	unsigned short ecd_fc_debias;
-};
-
-/** Y(Luma) Noise Reduction configuration.
- */
-struct sh_css_ynr_config {
-	unsigned short edge_sense_gain_0;
-	unsigned short edge_sense_gain_1;
-	unsigned short corner_sense_gain_0;
-	unsigned short corner_sense_gain_1;
-};
-
-/** Fringe Control configuration.
- */
-struct sh_css_fc_config {
-	unsigned char gain_exp;
-	unsigned short gain_pos_0;
-	unsigned short gain_pos_1;
-	unsigned short gain_neg_0;
-	unsigned short gain_neg_1;
-	unsigned short crop_pos_0;
-	unsigned short crop_pos_1;
-	unsigned short crop_neg_0;
-	unsigned short crop_neg_1;
-};
-
-/** Chroma Noise Reduction configuration.
- */
-struct sh_css_cnr_config {
-	unsigned char coring_u;
-	unsigned char coring_v;
-	unsigned char sense_gain_vy;
-	unsigned char sense_gain_vu;
-	unsigned char sense_gain_vv;
-	unsigned char sense_gain_hy;
-	unsigned char sense_gain_hu;
-	unsigned char sense_gain_hv;
-};
-
-/** MACC
- */
-struct sh_css_macc_config {
-	unsigned char exp; /**< */
-};
-
-/** Chroma Tone Control configuration.
- */
-struct sh_css_ctc_config {
-	unsigned short y0;
-	unsigned short y1;
-	unsigned short y2;
-	unsigned short y3;
-	unsigned short y4;
-	unsigned short y5;
-	unsigned short ce_gain_exp;
-	unsigned short x1;
-	unsigned short x2;
-	unsigned short x3;
-	unsigned short x4;
-};
-
-/** Anti-Aliasing configuration.
- */
-struct sh_css_aa_config {
-	unsigned short scale;
-};
-
-/** Chroma Enhancement configuration.
- */
-struct sh_css_ce_config {
-	u0_16 uv_level_min; /**< */
-	u0_16 uv_level_max; /**< */
-};
-
-/** Color Correction Matrix (YCgCo to RGB) settings.
- *  The data is
- *  s(13-SH_CSS_YUV2RGB_CCM_COEF_SHIFT).SH_CSS_YUV2RGB_CCM_COEF_SHIFT
- *  fixed point.
- */
-struct sh_css_yuv2rgb_cc_config {
-	int matrix[3 * 3]; /**< YUV2RGB conversion matrix, signed
-	<13-SH_CSS_YUV2RGB_CCM_COEF_SHIFT>.<SH_CSS_YUV2RGB_CCM_COEF_SHIFT> */
-};
-
-/** Color Space Conversion (RGB to YUV) settings.
- *  The data is
- *  s(13-SH_CSS_RGB2YUV_CSC_COEF_SHIFT).SH_CSS_RGB2YUV_CSC_COEF_SHIFT
- *  fixed point.
- */
-struct sh_css_rgb2yuv_cc_config {
-	int matrix[3 * 3]; /**< RGB2YUV conversion matrix, signed
-	<13-SH_CSS_RGB2YUV_CSC_COEF_SHIFT>.<SH_CSS_RGB2YUV_CSC_COEF_SHIFT> */
-};
-
-/** 3A configuration. This configures the 3A statistics collection
- *  module.
- */
-struct sh_css_3a_config {
-	u0_16 ae_y_coef_r;	/**< Weight of R for Y */
-	u0_16 ae_y_coef_g;	/**< Weight of G for Y */
-	u0_16 ae_y_coef_b;	/**< Weight of B for Y */
-	u0_16 awb_lg_high_raw;	/**< AWB level gate high for raw */
-	u0_16 awb_lg_low;	/**< AWB level gate low */
-	u0_16 awb_lg_high;	/**< AWB level gate high */
-	s0_15 af_fir1_coef[7];	/**< AF FIR coefficients of fir1 */
-	s0_15 af_fir2_coef[7];	/**< AF FIR coefficients of fir2 */
-};
-
-/** eXtra Noise Reduction configuration.
- */
-struct sh_css_xnr_config {
-	unsigned int threshold;  /**< Threshold */
-};
-
-/** ISP filter configuration. This is a collection of configurations
- *  for each of the ISP filters (modules).
- *  We do not allow individual configurations to be set, only the
- *  complete grouping can be set. This is required to make sure all
- *  settings are always applied to the same frame.
- */
-struct sh_css_isp_config {
-	struct sh_css_wb_config  wb_config;  /**< White Balance config */
-	struct sh_css_cc_config  cc_config;  /**< Color Correction config */
-	struct sh_css_tnr_config tnr_config; /**< Temporal Noise Reduction */
-	struct sh_css_ecd_config ecd_config; /**< Eigen Color Demosaicing */
-	struct sh_css_ynr_config ynr_config; /**< Y(Luma) Noise Reduction */
-	struct sh_css_fc_config  fc_config;  /**< Fringe Control */
-	struct sh_css_cnr_config cnr_config; /**< Chroma Noise Reduction */
-	struct sh_css_macc_config  macc_config;  /**< MACC */
-	struct sh_css_ctc_config ctc_config; /**< Chroma Tone Control */
-	struct sh_css_aa_config  aa_config;  /**< Anti-Aliasing */
-	struct sh_css_ob_config  ob_config;  /**< Objective Black config */
-	struct sh_css_dp_config  dp_config;  /**< Dead Pixel config */
-	struct sh_css_nr_config  nr_config;  /**< Noise Reduction config */
-	struct sh_css_ee_config  ee_config;  /**< Edge Enhancement config */
-	struct sh_css_de_config  de_config;  /**< Demosaic config */
-	struct sh_css_gc_config  gc_config;  /**< Gamma Correction config */
-	struct sh_css_anr_config anr_config; /**< Advanced Noise Reduction */
-	struct sh_css_yuv2rgb_cc_config yuv2rgb_cc_config; /**< Color
-							Correction config */
-	struct sh_css_rgb2yuv_cc_config rgb2yuv_cc_config; /**< Color
-							Correction config */
-	struct sh_css_3a_config  s3a_config; /**< 3A Statistics config */
-	struct sh_css_xnr_config xnr_config; /**< eXtra Noise Reduction */
-};
-
-/* Guard this declaration, because this struct is also defined by
- * Sh3a_Types.h now
- */
-#ifndef __SH_CSS_3A_OUTPUT__
-#define __SH_CSS_3A_OUTPUT__
-
-/* Workaround: hivecc complains about "tag "sh_css_3a_output" already declared"
-   without this extra decl. */
-struct sh_css_3a_output;
-
-/** 3A statistics point. This structure describes the data stored
- *  in each 3A grid point.
- */
-struct sh_css_3a_output {
-	int ae_y;    /**< */
-	int awb_cnt; /**< */
-	int awb_gr;  /**< */
-	int awb_r;   /**< */
-	int awb_b;   /**< */
-	int awb_gb;  /**< */
-	int af_hpf1; /**< */
-	int af_hpf2; /**< */
-};
-
-#endif /* End of guard __SH_CSS_3A_OUTPUT__ */
-
-/* Types for the acceleration API.
- * These should be moved to sh_css_internal.h once the old acceleration
- * argument handling has been completed.
- * After that, interpretation of these structures is no longer needed
- * in the kernel and HAL.
-*/
-
-/** Blob descriptor.
- * This structure describes an SP or ISP blob.
- * It describes the test, data and bss sections as well as position in a
- * firmware file.
- * For convenience, it contains dynamic data after loading.
- */
-struct sh_css_blob_info {
-	/**< Static blob data */
-	unsigned int offset;		/**< Blob offset in fw file */
-	unsigned int size;		/**< Size of blob */
-	unsigned int prog_name_offset;  /**< offset wrt hdr in bytes */
-	unsigned int text_source;	/**< Position of text in blob */
-	unsigned int text_size;		/**< Size of text section */
-	unsigned int icache_source;	/**< Position of icache in blob */
-	unsigned int icache_size;		/**< Size of icache section */
-	unsigned int data_source;	/**< Position of data in blob */
-	unsigned int data_target;	/**< Start of data in SP dmem */
-	unsigned int data_size;		/**< Size of text section */
-	unsigned int bss_target;	/**< Start position of bss in SP dmem */
-	unsigned int bss_size;		/**< Size of bss section */
-	/**< Dynamic data filled by loader */
-	const void  *text;		/**< Text section within fw */
-	const void  *data;		/**< Sp data section */
-};
-
-/** Type of acceleration.
- */
-enum sh_css_acc_type {
-	SH_CSS_ACC_NONE,	/**< Normal binary */
-	SH_CSS_ACC_OUTPUT,	/**< Accelerator stage on output frame */
-	SH_CSS_ACC_VIEWFINDER,	/**< Accelerator stage on viewfinder frame */
-	SH_CSS_ACC_STANDALONE,	/**< Stand-alone acceleration */
-};
-
-/** Firmware types.
- */
-enum sh_css_fw_type {
-	sh_css_sp_firmware,	/**< Firmware for the SP */
-	sh_css_isp_firmware,	/**< Firmware for the ISP */
-	sh_css_acc_firmware	/**< Firmware for accelrations */
-};
-
-/** Isp memory section descriptor */
-struct sh_css_isp_memory_section {
-	unsigned int address;  /* In ISP mem */
-	size_t       size;     /* In ISP mem */
-};
-
-struct sh_css_isp_memory_interface {
-	struct sh_css_isp_memory_section parameters;
-};
-
-#if defined(IS_ISP_2300_SYSTEM)
-enum sh_css_isp_memories {
-	SH_CSS_ISP_PMEM0 = 0,
-	SH_CSS_ISP_DMEM0,
-	SH_CSS_ISP_VMEM0,
-	SH_CSS_ISP_VAMEM0,
-	SH_CSS_ISP_VAMEM1,
-	N_SH_CSS_ISP_MEMORIES
-};
-
-#define SH_CSS_NUM_ISP_MEMORIES 5
-
-#elif defined(IS_ISP_2400_SYSTEM)
-enum sh_css_isp_memories {
-	SH_CSS_ISP_PMEM0 = 0,
-	SH_CSS_ISP_DMEM0,
-	SH_CSS_ISP_VMEM0,
-	SH_CSS_ISP_VAMEM0,
-	SH_CSS_ISP_VAMEM1,
-	SH_CSS_ISP_VAMEM2,
-	SH_CSS_ISP_HMEM0,
-	N_SH_CSS_ISP_MEMORIES
-};
-
-#define SH_CSS_NUM_ISP_MEMORIES 7
-
-#else
-#error "sh_css_types.h:  SYSTEM must be one of {ISP_2300_SYSTEM, ISP_2400_SYSTEM}"
-#endif
-
-/** Structure describing an ISP binary.
- * It describes the capabilities of a binary, like the maximum resolution,
- * support features, dma channels, uds features, etc.
- */
-struct sh_css_binary_info {
-	unsigned int		id; /* SH_CSS_BINARY_ID_* */
-	unsigned int		mode;
-	enum sh_css_acc_type	 type;
-	const struct sh_css_blob_descr *blob;
-	int			 num_output_formats;
-	enum sh_css_frame_format output_formats[SH_CSS_MAX_NUM_FRAME_FORMATS];
-	uint32_t		min_input_width;
-	uint32_t		min_input_height;
-	uint32_t		max_input_width;
-	uint32_t		max_input_height;
-	uint32_t		min_output_width;
-	uint32_t		min_output_height;
-	uint32_t		max_output_width;
-	uint32_t		max_output_height;
-	uint32_t		max_internal_width;
-	uint32_t		max_internal_height;
-	unsigned int		max_dvs_envelope_width;
-	unsigned int		max_dvs_envelope_height;
-	unsigned int		variable_resolution;
-	unsigned int		variable_output_format;
-	unsigned int		variable_vf_veceven;
-	unsigned int		max_vf_log_downscale;
-	unsigned int		top_cropping;
-	unsigned int		left_cropping;
-	unsigned int		s3atbl_use_dmem;
-	int                      input;
-	unsigned int		xmem_addr; /* hrt_vaddress */
-	unsigned int		c_subsampling;
-	unsigned int		output_num_chunks;
-	unsigned int		input_num_chunks;
-	unsigned int		num_stripes;
-	unsigned int		pipelining;
-	unsigned int		fixed_s3a_deci_log;
-	unsigned int		isp_addresses; /* Address in ISP dmem */
-	unsigned int		main_entry;    /* Address of entry fct */
-	unsigned int		in_frame;  /* Address in ISP dmem */
-	unsigned int		out_frame; /* Address in ISP dmem */
-	unsigned int		in_data;  /* Address in ISP dmem */
-	unsigned int		out_data; /* Address in ISP dmem */
-	unsigned int		block_width;
-	unsigned int		block_height;
-	unsigned int		output_block_height;
-	unsigned int		dvs_in_block_width;
-	unsigned int		dvs_in_block_height;
-	struct sh_css_isp_memory_interface
-				 memory_interface[SH_CSS_NUM_ISP_MEMORIES];
-	unsigned int		sh_dma_cmd_ptr;     /* In ISP dmem */
-	unsigned int		isp_pipe_version;
-	struct {
-		unsigned char	 ctc;   /* enum sh_css_isp_memories */
-		unsigned char	 gamma; /* enum sh_css_isp_memories */
-		unsigned char	 xnr;   /* enum sh_css_isp_memories */
-		unsigned char	 r_gamma; /* enum sh_css_isp_memories */
-		unsigned char	 g_gamma; /* enum sh_css_isp_memories */
-		unsigned char	 b_gamma; /* enum sh_css_isp_memories */
-	} memories;
-/* MW: Packing (related) bools in an integer ?? */
-	struct {
-		unsigned char     reduced_pipe;
-		unsigned char     vf_veceven;
-		unsigned char     dis;
-		unsigned char     dvs_envelope;
-		unsigned char     uds;
-		unsigned char     dvs_6axis;
-		unsigned char     block_output;
-		unsigned char     ds;
-		unsigned char     fixed_bayer_ds;
-		unsigned char     bayer_fir_6db;
-		unsigned char     raw_binning;
-		unsigned char     continuous;
-		unsigned char     s3a;
-		unsigned char     fpnr;
-		unsigned char     sc;
-		unsigned char     dis_crop;
-		unsigned char     dp_2adjacent;
-		unsigned char     macc;
-		unsigned char     ss;
-		unsigned char     output;
-		unsigned char     ref_frame;
-		unsigned char     tnr;
-		unsigned char     xnr;
-		unsigned char     raw;
-		unsigned char     params;
-		unsigned char     gamma;
-		unsigned char     ctc;
-		unsigned char     ca_gdc;
-		unsigned char     isp_addresses;
-		unsigned char     in_frame;
-		unsigned char     out_frame;
-		unsigned char     high_speed;
-		unsigned char     input_chunking;
-		/* unsigned char	  padding[2]; */
-	} enable;
-	struct {
-/* DMA channel ID: [0,...,HIVE_ISP_NUM_DMA_CHANNELS> */
-		uint8_t		crop_channel;
-		uint8_t		fpntbl_channel;
-		uint8_t		multi_channel;
-		uint8_t		raw_out_channel;
-		uint8_t		sctbl_channel;
-		uint8_t		ref_y_channel;
-		uint8_t		ref_c_channel;
-		uint8_t		tnr_channel;
-		uint8_t		tnr_out_channel;
-		uint8_t		dvs_in_channel;
-		uint8_t		dvs_coords_channel;
-		uint8_t		output_channel;
-		uint8_t		c_channel;
-		uint8_t		vfout_channel;
-		uint8_t		claimed_by_isp;
-		/* uint8_t	padding[0]; */
-		struct {
-			uint8_t	 channel;  /* Dma channel used */
-			uint8_t	 height;   /* Buffer height */
-			uint16_t stride;   /* Buffer stride */
-		} raw;
-	} dma;
-	struct {
-		unsigned short	 bpp;
-		unsigned short	 use_bci;
-		unsigned short	 woix;
-		unsigned short	 woiy;
-		unsigned short   extra_out_vecs;
-		unsigned short	 vectors_per_line_in;
-		unsigned short	 vectors_per_line_out;
-		unsigned short	 vectors_c_per_line_in;
-		unsigned short	 vectors_c_per_line_out;
-		unsigned short	 vmem_gdc_in_block_height_y;
-		unsigned short	 vmem_gdc_in_block_height_c;
-		/* unsigned short	 padding; */
-	} uds;
-	unsigned		   blob_index;
-	struct sh_css_binary_info *next;
-};
-
-/** Structure describing the SP binary.
- * It contains several address, either in ddr, sp_dmem or
- * the entry function in pmem.
- */
-struct sh_css_sp_info {
-	unsigned int	init_dmem_data; /**< data sect config, stored to dmem */
-	unsigned int	per_frame_data; /**< Per frame data, stored to dmem */
-	unsigned int	group;		/**< Per pipeline data, loaded by dma */
-	unsigned int	output;		/**< SP output data, loaded by dmem */
-	unsigned int	host_sp_queue;	/**< Host <-> SP queues */
-	unsigned int	host_sp_com;/**< Host <-> SP commands */
-	unsigned int	isp_started;	/**< Polled from sensor thread, csim only */
-	unsigned int	sw_state;	/**< Polled from css */
-	unsigned int	host_sp_queues_initialized; /**< Polled from the SP */
-	unsigned int	sleep_mode;  /**< different mode to halt SP */
-	unsigned int	invalidate_tlb;		/**< inform SP to invalidate mmu TLB */
-	unsigned int	request_flash;	/**< inform SP to switch on flash for next frame */
-	unsigned int	stop_copy_preview;	/**< suspend copy and preview pipe when capture */
-	unsigned int	copy_preview_overlap; /**< indicate when to start preview pipe in continuous mode */
-	unsigned int	copy_pack;	/**< use packed memory layout for raw data */
-	unsigned int	debug_buffer_ddr_address;	/**< inform SP the address
-	of DDR debug queue */
-	unsigned int	ddr_parameter_address; /**< acc param ddrptr, sp dmem */
-	unsigned int	ddr_parameter_size;    /**< acc param size, sp dmem */
-	/* Entry functions */
-	unsigned int	sp_entry;	/**< The SP entry function */
-};
-
-/** Accelerator firmware information.
- */
-struct sh_css_acc_info {
-	unsigned int	per_frame_data; /**< Dummy for now */
-};
-
-/** Firmware information.
- */
-union sh_css_fw_union {
-	struct sh_css_binary_info	isp; /**< ISP info */
-	struct sh_css_sp_info		sp;  /**< SP info */
-	struct sh_css_acc_info		acc; /**< Accelerator info */
-};
-
-/** Hmm section descriptor */
-struct sh_css_hmm_section {
-	hrt_vaddress			ddr_address;
-	size_t				ddr_size; /* Disabled if 0 */
-};
-
-/** Hmm section descriptor */
-struct sh_css_hmm_isp_interface {
-	struct sh_css_hmm_section	parameters;
-};
-
-/** Firmware information.
- */
-struct sh_css_fw_info {
-	size_t			header_size; /**< size of fw header */
-	enum sh_css_fw_type	type; /**< FW type */
-	union sh_css_fw_union	info; /**< Binary info */
-	struct sh_css_blob_info blob; /**< Blob info */
-	/* Dynamic part */
-	struct sh_css_fw_info  *next;
-	unsigned		loaded;    /**< Firmware has been loaded */
-	const unsigned char    *isp_code;  /**< ISP pointer to code */
-	/**< Firmware handle between user space and kernel */
-	unsigned int		handle;
-	/**< Sections to copy from/to ISP */
-	struct sh_css_hmm_isp_interface
-				memory_interface[SH_CSS_NUM_ISP_MEMORIES];
-};
-
-struct sh_css_acc_fw;
-
-/** Structure describing the SP binary of a stand-alone accelerator.
- */
- struct sh_css_acc_sp {
-	void (*init) (struct sh_css_acc_fw *); /**< init for crun */
-	unsigned      sp_prog_name_offset; /**< program name offset wrt hdr
-						in bytes */
-	unsigned      sp_blob_offset;	   /**< blob offset wrt hdr in bytes */
-	void	     *entry;		   /**< Address of sp entry point */
-	unsigned int *css_abort;	   /**< SP dmem abort flag */
-	void	     *isp_code;		   /**< SP dmem address holding xmem
-						address of isp code */
-	struct sh_css_fw_info fw;	   /**< SP fw descriptor */
-	const unsigned char *code;	   /**< ISP pointer of allocated
-						SP code */
-};
-
-/** Acceleration firmware descriptor.
-  * This descriptor descibes either SP code (stand-alone), or
-  * ISP code (a separate pipeline stage).
-  */
-struct sh_css_acc_fw_hdr {
-	enum sh_css_acc_type type;	/**< Type of accelerator */
-	unsigned	isp_prog_name_offset; /**< program name offset wrt
-						   header in bytes */
-	unsigned	isp_blob_offset;      /**< blob offset wrt header
-						   in bytes */
-	unsigned int	isp_size;	      /**< Size of isp blob */
-	const unsigned
-	      char     *isp_code;	      /**< ISP pointer to code */
-	struct sh_css_acc_sp  sp;  /**< Standalone sp code */
-	unsigned	     loaded;    /**< Firmware has been loaded */
-	/**< Firmware handle between user space and kernel */
-	unsigned int	handle;
-	struct sh_css_hmm_section parameters; /**< Current SP parameters */
-};
-
-/** Firmware structure.
-  * This contains the header and actual blobs.
-  * For standalone, it contains SP and ISP blob.
-  * For a pipeline stage accelerator, it contains ISP code only.
-  * Since its members are variable size, their offsets are described in the
-  * header and computed using the access macros below.
-  */
-struct sh_css_acc_fw {
-	struct sh_css_acc_fw_hdr header; /**< firmware header */
-	/*
-	char   isp_progname[];	  **< ISP program name
-	char   sp_progname[];	  **< SP program name, stand-alone only
-	unsigned char sp_code[];  **< SP blob, stand-alone only
-	unsigned char isp_code[]; **< ISP blob
-	*/
-};
-
-/* Access macros for firmware */
-#define SH_CSS_ACC_OFFSET(t, f, n) ((t)((unsigned char *)(f)+(f->header.n)))
-#define SH_CSS_ACC_SP_PROG_NAME(f) SH_CSS_ACC_OFFSET(const char *, f, \
-						 sp.sp_prog_name_offset)
-#define SH_CSS_ACC_ISP_PROG_NAME(f) SH_CSS_ACC_OFFSET(const char *, f, \
-						 isp_prog_name_offset)
-#define SH_CSS_ACC_SP_CODE(f)      SH_CSS_ACC_OFFSET(unsigned char *, f, \
-						 sp.sp_blob_offset)
-#define SH_CSS_ACC_SP_DATA(f)      (SH_CSS_ACC_SP_CODE(f) + \
-					(f)->header.sp.fw.blob.data_source)
-#define SH_CSS_ACC_ISP_CODE(f)     SH_CSS_ACC_OFFSET(unsigned char*, f,\
-						 isp_blob_offset)
-#define SH_CSS_ACC_ISP_SIZE(f)     ((f)->header.isp_size)
-
-/* Binary name follows header immediately */
-#define SH_CSS_EXT_ISP_PROG_NAME(f) ((const unsigned char *)(f)+sizeof(*f))
-
-/** Structure to encapsulate required arguments for
- * initialization of SP DMEM using the SP itself
- * This is exported for accelerators implementing their own SP code.
- */
-struct sh_css_sp_init_dmem_cfg {
-	unsigned      done;	      /**< Init has been done */
-	/* Next three should be hrt_vaddress */
-	unsigned      ddr_data_addr;  /**< data segment address in ddr  */
-	unsigned      dmem_data_addr; /**< data segment address in dmem */
-	unsigned      dmem_bss_addr;  /**< bss segment address in dmem  */
-	unsigned int  data_size;      /**< data segment size            */
-	unsigned int  bss_size;       /**< bss segment size             */
-};
-
-enum sh_css_sp_sleep_mode {
-	SP_DISABLE_SLEEP_MODE = 0,
-	SP_SLEEP_AFTER_FRAME = 1 << 0,
-	SP_SLEEP_AFTER_IRQ = 1 << 1
-};
-
-enum sh_css_sp_sw_state {
-	SP_READY_TO_START = 0,
-	SP_BOOTED,
-	SP_TERMINATED
-};
-
-#endif /* _SH_CSS_TYPES_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_v2.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_v2.h
deleted file mode 100644
index d4e4cac..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/sh_css_v2.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
-* Support for Medfield PNW Camera Imaging ISP subsystem.
-*
-* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
-*
-* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
-*
-* This program is free software; you can redistribute it and/or
-* modify it under the terms of the GNU General Public License version
-* 2 as published by the Free Software Foundation.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-* 02110-1301, USA.
-*
-*/
-
-#ifndef _SH_CSS_V2_H_
-#define _SH_CSS_V2_H_
-
-#include "sh_css.h"
-
-struct sh_css_pipe;
-
-/* CSS 2.0 starts here */
-enum sh_css_err
-sh_css_pipe_stop(struct sh_css_pipe *me);
-
-void
-sh_css_pipe_enable_online(struct sh_css_pipe *me,
-			  bool enable);
-
-enum sh_css_err
-sh_css_pipe_configure_output(struct sh_css_pipe *me,
-			     unsigned int width,
-			     unsigned int height,
-			     unsigned int min_padded_width,
-			     enum sh_css_frame_format format);
-
-void
-sh_css_pipe_get_zoom_factor(struct sh_css_pipe *me,
-			    unsigned int *dx,
-			    unsigned int *dy);
-
-void
-sh_css_pipe_set_zoom_factor(struct sh_css_pipe *me,
-			    unsigned int dx,
-			    unsigned int dy);
-
-void
-sh_css_pipe_set_input_channel(struct sh_css_pipe *me,
-			      unsigned int channel_id);
-
-void
-sh_css_pipe_set_input_format(struct sh_css_pipe *me,
-			     enum sh_css_input_format format);
-
-enum sh_css_input_format
-sh_css_pipe_get_input_format(struct sh_css_pipe *me);
-
-void
-sh_css_pipe_set_input_mode(struct sh_css_pipe *me, enum sh_css_input_mode mode);
-
-void
-sh_css_pipe_set_two_pixels_per_clock(struct sh_css_pipe *me,
-				     bool two_ppc);
-
-bool
-sh_css_pipe_get_two_pixels_per_clock(struct sh_css_pipe *me);
-
-void
-sh_css_pipe_set_input_bayer_order(struct sh_css_pipe *pipe,
-				  enum sh_css_bayer_order bayer_order);
-
-void
-sh_css_pipe_get_extra_pixels_count(struct sh_css_pipe *pipe,
-				   int *extra_rows,
-				   int *extra_cols);
-
-void
-sh_css_pipe_disable_vf_pp(struct sh_css_pipe *pipe,
-			  bool disable);
-
-void
-sh_css_pipe_enable_raw_binning(struct sh_css_pipe *pipe,
-				 bool enable);
-
-enum sh_css_err
-sh_css_pipe_configure_input_port(struct sh_css_pipe  *pipe,
-				 const mipi_port_ID_t port,
-				 const unsigned int   num_lanes,
-				 const unsigned int   timeout);
-
-enum sh_css_err
-sh_css_pipe_set_compression(struct sh_css_pipe    *pipe,
-			    const mipi_predictor_t comp,
-			    const unsigned int     compressed_bits_per_pixel,
-			    const unsigned int     uncompressed_bits_per_pixel);
-
-enum sh_css_err
-sh_css_pipe_load_extension(struct sh_css_pipe *pipe,
-			   struct sh_css_fw_info *firmware);
-
-void
-sh_css_pipe_unload_extension(struct sh_css_pipe *pipe,
-			     struct sh_css_fw_info *firmware);
-
-enum sh_css_err
-sh_css_pipe_set_input_resolution(struct sh_css_pipe *pipe,
-				 unsigned int width,
-				 unsigned int height);
-
-enum sh_css_err
-sh_css_pipe_set_effective_input_resolution(struct sh_css_pipe *pipe,
-					   unsigned int width,
-					   unsigned int height);
-
-#endif /* _SH_CSS_V2_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/spmem_dump.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/spmem_dump.c
deleted file mode 100644
index d2be1e4..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300/spmem_dump.c
+++ /dev/null
@@ -1,1851 +0,0 @@
-/**
- * Copyright (c) 2010 - 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
-**/
-
-#ifndef _sp_map_h_
-#define _sp_map_h_
-
-
-#ifndef _hrt_dummy_use_blob_sp
-#define _hrt_dummy_use_blob_sp()
-#endif
-
-#define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_vectors_per_input_line
-#define HIVE_MEM_isp_vectors_per_input_line scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_vectors_per_input_line 0x2994
-#define HIVE_SIZE_isp_vectors_per_input_line 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_vectors_per_input_line scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_vectors_per_input_line 0x2994
-#define HIVE_SIZE_sp_isp_vectors_per_input_line 4
-
-/* function sp_tagger_propagate_frame: 3287 */
-
-/* function longjmp: 3589 */
-
-/* function sp_dma_proxy_read: 29D3 */
-
-/* function sp_dma_proxy_is_idle: 2B30 */
-
-/* function stop_event_proxy: 2B3E */
-
-/* function setjmp: 3590 */
-
-/* function decode_sw_event: 2D3 */
-
-/* function initialize_sp_stage: 25C3 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_stage
-#define HIVE_MEM_isp_stage scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_stage 0x382C
-#define HIVE_SIZE_isp_stage 516
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_stage scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_stage 0x382C
-#define HIVE_SIZE_sp_isp_stage 516
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_vbuf_raw
-#define HIVE_MEM_vbuf_raw scalar_processor_demo_dmem
-#define HIVE_ADDR_vbuf_raw 0x8C
-#define HIVE_SIZE_vbuf_raw 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_vbuf_raw scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_vbuf_raw 0x8C
-#define HIVE_SIZE_sp_vbuf_raw 4
-
-/* function release_in_param: 3155 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_dma_proxy_status
-#define HIVE_MEM_dma_proxy_status scalar_processor_demo_dmem
-#define HIVE_ADDR_dma_proxy_status 0x154
-#define HIVE_SIZE_dma_proxy_status 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_dma_proxy_status scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_proxy_status 0x154
-#define HIVE_SIZE_sp_dma_proxy_status 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_do_mmu_invalidation
-#define HIVE_MEM_do_mmu_invalidation scalar_processor_demo_dmem
-#define HIVE_ADDR_do_mmu_invalidation 0x2C48
-#define HIVE_SIZE_do_mmu_invalidation 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_do_mmu_invalidation scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_do_mmu_invalidation 0x2C48
-#define HIVE_SIZE_sp_do_mmu_invalidation 4
-
-/* function sp_start_isp: 1EDA */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_binary_group
-#define HIVE_MEM_sp_binary_group scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_binary_group 0x272C
-#define HIVE_SIZE_sp_binary_group 68
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_binary_group scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_binary_group 0x272C
-#define HIVE_SIZE_sp_sp_binary_group 68
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_sw_state
-#define HIVE_MEM_sp_sw_state scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sw_state 0x2998
-#define HIVE_SIZE_sp_sw_state 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_sw_state scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_sw_state 0x2998
-#define HIVE_SIZE_sp_sp_sw_state 4
-
-/* function sp_circular_buf_pop: 2F31 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_raw_frame_out_port
-#define HIVE_MEM_raw_frame_out_port scalar_processor_demo_dmem
-#define HIVE_ADDR_raw_frame_out_port 0x36A0
-#define HIVE_SIZE_raw_frame_out_port 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_raw_frame_out_port scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_raw_frame_out_port 0x36A0
-#define HIVE_SIZE_sp_raw_frame_out_port 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_stop_copy_preview
-#define HIVE_MEM_sp_stop_copy_preview scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_stop_copy_preview 0x2C20
-#define HIVE_SIZE_sp_stop_copy_preview 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_stop_copy_preview 0x2C20
-#define HIVE_SIZE_sp_sp_stop_copy_preview 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_vbuf_handles
-#define HIVE_MEM_vbuf_handles scalar_processor_demo_dmem
-#define HIVE_ADDR_vbuf_handles 0x2220
-#define HIVE_SIZE_vbuf_handles 980
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_vbuf_handles scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_vbuf_handles 0x2220
-#define HIVE_SIZE_sp_vbuf_handles 980
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_elems_params_capture_pipe
-#define HIVE_MEM_cb_elems_params_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_elems_params_capture_pipe 0x36B4
-#define HIVE_SIZE_cb_elems_params_capture_pipe 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_elems_params_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_elems_params_capture_pipe 0x36B4
-#define HIVE_SIZE_sp_cb_elems_params_capture_pipe 16
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_dma_proxy_thread
-#define HIVE_MEM_sp_dma_proxy_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_proxy_thread 0x2C5C
-#define HIVE_SIZE_sp_dma_proxy_thread 68
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_dma_proxy_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_dma_proxy_thread 0x2C5C
-#define HIVE_SIZE_sp_sp_dma_proxy_thread 68
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_params_tagger
-#define HIVE_MEM_cb_params_tagger scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_params_tagger 0x365C
-#define HIVE_SIZE_cb_params_tagger 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_params_tagger scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_params_tagger 0x365C
-#define HIVE_SIZE_sp_cb_params_tagger 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_thread_ready_queue
-#define HIVE_MEM_sp_thread_ready_queue scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_thread_ready_queue 0x1DC
-#define HIVE_SIZE_sp_thread_ready_queue 8
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_thread_ready_queue scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_thread_ready_queue 0x1DC
-#define HIVE_SIZE_sp_sp_thread_ready_queue 8
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_event_is_pending_mask
-#define HIVE_MEM_event_is_pending_mask scalar_processor_demo_dmem
-#define HIVE_ADDR_event_is_pending_mask 0x38
-#define HIVE_SIZE_event_is_pending_mask 32
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_event_is_pending_mask scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_event_is_pending_mask 0x38
-#define HIVE_SIZE_sp_event_is_pending_mask 32
-
-/* function __sp_dma_proxy_write_ack_callout_critical: 39D1 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_host_sp_com
-#define HIVE_MEM_host_sp_com scalar_processor_demo_dmem
-#define HIVE_ADDR_host_sp_com 0x299C
-#define HIVE_SIZE_host_sp_com 96
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_host_sp_com scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_host_sp_com 0x299C
-#define HIVE_SIZE_sp_host_sp_com 96
-
-/* function exec_image_pipe: 20A4 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_init_dmem_data
-#define HIVE_MEM_sp_init_dmem_data scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_init_dmem_data 0x29FC
-#define HIVE_SIZE_sp_init_dmem_data 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_init_dmem_data 0x29FC
-#define HIVE_SIZE_sp_sp_init_dmem_data 24
-
-/* function stop_threads: 207B */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_flash_in_use
-#define HIVE_MEM_sp_flash_in_use scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_flash_in_use 0xDB8
-#define HIVE_SIZE_sp_flash_in_use 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_flash_in_use scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_flash_in_use 0xDB8
-#define HIVE_SIZE_sp_sp_flash_in_use 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_flashed_frame_cnt
-#define HIVE_MEM_flashed_frame_cnt scalar_processor_demo_dmem
-#define HIVE_ADDR_flashed_frame_cnt 0xDC0
-#define HIVE_SIZE_flashed_frame_cnt 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_flashed_frame_cnt scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_flashed_frame_cnt 0xDC0
-#define HIVE_SIZE_sp_flashed_frame_cnt 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_stack_sizes
-#define HIVE_MEM_stack_sizes scalar_processor_demo_dmem
-#define HIVE_ADDR_stack_sizes 0x20C
-#define HIVE_SIZE_stack_sizes 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_stack_sizes scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_stack_sizes 0x20C
-#define HIVE_SIZE_sp_stack_sizes 24
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_ph
-#define HIVE_MEM_ph scalar_processor_demo_dmem
-#define HIVE_ADDR_ph 0x219C
-#define HIVE_SIZE_ph 32
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_ph scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_ph 0x219C
-#define HIVE_SIZE_sp_ph 32
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_per_frame_data
-#define HIVE_MEM_sp_per_frame_data scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_per_frame_data 0x2A14
-#define HIVE_SIZE_sp_per_frame_data 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_per_frame_data scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_per_frame_data 0x2A14
-#define HIVE_SIZE_sp_sp_per_frame_data 4
-
-/* function dma_proxy_channel_acquire: 3B14 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_copy_pipe_thread
-#define HIVE_MEM_sp_copy_pipe_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_copy_pipe_thread 0x2CA0
-#define HIVE_SIZE_sp_copy_pipe_thread 68
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_copy_pipe_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_copy_pipe_thread 0x2CA0
-#define HIVE_SIZE_sp_sp_copy_pipe_thread 68
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_xmem_bin_addr
-#define HIVE_MEM_xmem_bin_addr scalar_processor_demo_dmem
-#define HIVE_ADDR_xmem_bin_addr 0x2A18
-#define HIVE_SIZE_xmem_bin_addr 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_xmem_bin_addr scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_xmem_bin_addr 0x2A18
-#define HIVE_SIZE_sp_xmem_bin_addr 4
-
-/* function memcpy: 3604 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_pipe_threads
-#define HIVE_MEM_pipe_threads scalar_processor_demo_dmem
-#define HIVE_ADDR_pipe_threads 0x1E4
-#define HIVE_SIZE_pipe_threads 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_pipe_threads scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_pipe_threads 0x1E4
-#define HIVE_SIZE_sp_pipe_threads 16
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_GP_DEVICE_BASE
-#define HIVE_MEM_GP_DEVICE_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_GP_DEVICE_BASE 0x1C
-#define HIVE_SIZE_GP_DEVICE_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_GP_DEVICE_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_GP_DEVICE_BASE 0x1C
-#define HIVE_SIZE_sp_GP_DEVICE_BASE 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_ia_css_i_exp_id
-#define HIVE_MEM_ia_css_i_exp_id scalar_processor_demo_dmem
-#define HIVE_ADDR_ia_css_i_exp_id 0x2B8
-#define HIVE_SIZE_ia_css_i_exp_id 1
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_ia_css_i_exp_id scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_ia_css_i_exp_id 0x2B8
-#define HIVE_SIZE_sp_ia_css_i_exp_id 1
-
-/* function __divu: 3596 */
-
-/* function sp_dma_proxy_write_ack_callout: 27C8 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_cont_capt_stop
-#define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_cont_capt_stop 0x36C4
-#define HIVE_SIZE_sem_for_cont_capt_stop 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x36C4
-#define HIVE_SIZE_sp_sem_for_cont_capt_stop 24
-
-/* function sp_dma_proxy_func: 3673 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_isp_started
-#define HIVE_MEM_sp_isp_started scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_started 0x2A1C
-#define HIVE_SIZE_sp_isp_started 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_isp_started scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_isp_started 0x2A1C
-#define HIVE_SIZE_sp_sp_isp_started 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_isp_pipe_thread
-#define HIVE_MEM_sp_isp_pipe_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_pipe_thread 0x2CE4
-#define HIVE_SIZE_sp_isp_pipe_thread 204
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x2CE4
-#define HIVE_SIZE_sp_sp_isp_pipe_thread 204
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_obarea_start_bq
-#define HIVE_MEM_sp_obarea_start_bq scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_obarea_start_bq 0x2A20
-#define HIVE_SIZE_sp_obarea_start_bq 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_obarea_start_bq scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_obarea_start_bq 0x2A20
-#define HIVE_SIZE_sp_sp_obarea_start_bq 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_IRQ_BASE
-#define HIVE_MEM_IRQ_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_IRQ_BASE 0x18
-#define HIVE_SIZE_IRQ_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_IRQ_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_IRQ_BASE 0x18
-#define HIVE_SIZE_sp_IRQ_BASE 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_TIMED_CTRL_BASE
-#define HIVE_MEM_TIMED_CTRL_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_TIMED_CTRL_BASE 0x24
-#define HIVE_SIZE_TIMED_CTRL_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_TIMED_CTRL_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x24
-#define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_is_isp_requested
-#define HIVE_MEM_is_isp_requested scalar_processor_demo_dmem
-#define HIVE_ADDR_is_isp_requested 0xD94
-#define HIVE_SIZE_is_isp_requested 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_is_isp_requested scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_is_isp_requested 0xD94
-#define HIVE_SIZE_sp_is_isp_requested 4
-
-/* function ia_css_i_sp_rmgr_init: 12B */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_current_sp_thread
-#define HIVE_MEM_current_sp_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_current_sp_thread 0x1D8
-#define HIVE_SIZE_current_sp_thread 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_current_sp_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_current_sp_thread 0x1D8
-#define HIVE_SIZE_sp_current_sp_thread 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_h_pipe_private_ddr_ptrs
-#define HIVE_MEM_h_pipe_private_ddr_ptrs scalar_processor_demo_dmem
-#define HIVE_ADDR_h_pipe_private_ddr_ptrs 0x2DF4
-#define HIVE_SIZE_h_pipe_private_ddr_ptrs 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_h_pipe_private_ddr_ptrs scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_h_pipe_private_ddr_ptrs 0x2DF4
-#define HIVE_SIZE_sp_h_pipe_private_ddr_ptrs 16
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_capture_thread_id
-#define HIVE_MEM_sp_capture_thread_id scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_capture_thread_id 0x35C
-#define HIVE_SIZE_sp_capture_thread_id 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_capture_thread_id scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_capture_thread_id 0x35C
-#define HIVE_SIZE_sp_sp_capture_thread_id 4
-
-/* function sp_turn_off_flash: 2C11 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_internal_event
-#define HIVE_MEM_sp_internal_event scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_internal_event 0x3684
-#define HIVE_SIZE_sp_internal_event 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_internal_event scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_internal_event 0x3684
-#define HIVE_SIZE_sp_sp_internal_event 4
-
-/* function _sp_dma_proxy_init_isp_vector: 296A */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_last_index
-#define HIVE_MEM_last_index scalar_processor_demo_dmem
-#define HIVE_ADDR_last_index 0x25F4
-#define HIVE_SIZE_last_index 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_last_index scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_last_index 0x25F4
-#define HIVE_SIZE_sp_last_index 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_sh_dma_cmd_buffer
-#define HIVE_MEM_isp_sh_dma_cmd_buffer scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_sh_dma_cmd_buffer 0x2C4C
-#define HIVE_SIZE_isp_sh_dma_cmd_buffer 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_sh_dma_cmd_buffer scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_sh_dma_cmd_buffer 0x2C4C
-#define HIVE_SIZE_sp_isp_sh_dma_cmd_buffer 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_cont_capt_start
-#define HIVE_MEM_sem_for_cont_capt_start scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_cont_capt_start 0x36DC
-#define HIVE_SIZE_sem_for_cont_capt_start 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x36DC
-#define HIVE_SIZE_sp_sem_for_cont_capt_start 24
-
-/* function host2sp_event_queue_is_empty: 3639 */
-
-/* function ia_css_i_sp_rmgr_get_num_vbuf: 2A5 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_preview_thread_id
-#define HIVE_MEM_sp_preview_thread_id scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_preview_thread_id 0x358
-#define HIVE_SIZE_sp_preview_thread_id 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_preview_thread_id scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_preview_thread_id 0x358
-#define HIVE_SIZE_sp_sp_preview_thread_id 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_reading_cb_frames_capture_pipe
-#define HIVE_MEM_sem_for_reading_cb_frames_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frames_capture_pipe 0x36F4
-#define HIVE_SIZE_sem_for_reading_cb_frames_capture_pipe 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_reading_cb_frames_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frames_capture_pipe 0x36F4
-#define HIVE_SIZE_sp_sem_for_reading_cb_frames_capture_pipe 24
-
-/* function sp_event_proxy_func: 2B45 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_fibers
-#define HIVE_MEM_fibers scalar_processor_demo_dmem
-#define HIVE_ADDR_fibers 0x224
-#define HIVE_SIZE_fibers 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_fibers scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_fibers 0x224
-#define HIVE_SIZE_sp_fibers 24
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_params_preview_pipe
-#define HIVE_MEM_cb_params_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_params_preview_pipe 0x370C
-#define HIVE_SIZE_cb_params_preview_pipe 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_params_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_params_preview_pipe 0x370C
-#define HIVE_SIZE_sp_cb_params_preview_pipe 20
-
-/* function sp_semaphore_init: 3CE5 */
-
-/* function initialize_sp_group: 25A6 */
-
-/* function start_binary: D29 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_invalidate_tlb
-#define HIVE_MEM_sp_invalidate_tlb scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_invalidate_tlb 0x2C50
-#define HIVE_SIZE_sp_invalidate_tlb 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_invalidate_tlb scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_invalidate_tlb 0x2C50
-#define HIVE_SIZE_sp_sp_invalidate_tlb 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_ISP_DMEM_BASE
-#define HIVE_MEM_ISP_DMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_ISP_DMEM_BASE 0xC
-#define HIVE_SIZE_ISP_DMEM_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_ISP_DMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_ISP_DMEM_BASE 0xC
-#define HIVE_SIZE_sp_ISP_DMEM_BASE 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_SP_DMEM_BASE
-#define HIVE_MEM_SP_DMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_SP_DMEM_BASE 0x4
-#define HIVE_SIZE_SP_DMEM_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_SP_DMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
-#define HIVE_SIZE_sp_SP_DMEM_BASE 4
-
-/* function bin_spec_init_ifs: 37C */
-
-/* function dma_proxy_channel_release: 3B03 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_event_can_send_token_mask
-#define HIVE_MEM_event_can_send_token_mask scalar_processor_demo_dmem
-#define HIVE_ADDR_event_can_send_token_mask 0x58
-#define HIVE_SIZE_event_can_send_token_mask 32
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_event_can_send_token_mask scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_event_can_send_token_mask 0x58
-#define HIVE_SIZE_sp_event_can_send_token_mask 32
-
-/* function sp_dma_proxy_wait_for_ack: 3A01 */
-
-/* function sp_thread_yield: 3BCE */
-
-/* function sp_circular_buf_peek: 2D89 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_thread
-#define HIVE_MEM_isp_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_thread 0x3A30
-#define HIVE_SIZE_isp_thread 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_thread 0x3A30
-#define HIVE_SIZE_sp_isp_thread 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_obarea_length_bq
-#define HIVE_MEM_sp_obarea_length_bq scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_obarea_length_bq 0x2A24
-#define HIVE_SIZE_sp_obarea_length_bq 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_obarea_length_bq scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_obarea_length_bq 0x2A24
-#define HIVE_SIZE_sp_sp_obarea_length_bq 4
-
-/* function sp_uds_init: 5B1 */
-
-/* function sp_circular_buf_create: 2F60 */
-
-/* function host2sp_dequeue_buffer: 10C */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_buf_swap
-#define HIVE_MEM_buf_swap scalar_processor_demo_dmem
-#define HIVE_ADDR_buf_swap 0x2EC
-#define HIVE_SIZE_buf_swap 96
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_buf_swap scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_buf_swap 0x2EC
-#define HIVE_SIZE_sp_buf_swap 96
-
-/* function is_dynamic_buffer: 3101 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_curr_nr_of_copied_frames
-#define HIVE_MEM_curr_nr_of_copied_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_curr_nr_of_copied_frames 0x2C24
-#define HIVE_SIZE_curr_nr_of_copied_frames 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_curr_nr_of_copied_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_curr_nr_of_copied_frames 0x2C24
-#define HIVE_SIZE_sp_curr_nr_of_copied_frames 4
-
-/* function sp2host_enqueue_buffer: F2 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_dma_crop_block_width_b
-#define HIVE_MEM_sp_dma_crop_block_width_b scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_crop_block_width_b 0x26B8
-#define HIVE_SIZE_sp_dma_crop_block_width_b 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_dma_crop_block_width_b scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_dma_crop_block_width_b 0x26B8
-#define HIVE_SIZE_sp_sp_dma_crop_block_width_b 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_elems_params_preview_pipe
-#define HIVE_MEM_cb_elems_params_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_elems_params_preview_pipe 0x3720
-#define HIVE_SIZE_cb_elems_params_preview_pipe 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_elems_params_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_elems_params_preview_pipe 0x3720
-#define HIVE_SIZE_sp_cb_elems_params_preview_pipe 16
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_output
-#define HIVE_MEM_sp_output scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_output 0x2A28
-#define HIVE_SIZE_sp_output 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_output scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_output 0x2A28
-#define HIVE_SIZE_sp_sp_output 16
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_ISP_CTRL_BASE
-#define HIVE_MEM_ISP_CTRL_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_ISP_CTRL_BASE 0x8
-#define HIVE_SIZE_ISP_CTRL_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_ISP_CTRL_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_ISP_CTRL_BASE 0x8
-#define HIVE_SIZE_sp_ISP_CTRL_BASE 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_INPUT_FORMATTER_BASE
-#define HIVE_MEM_INPUT_FORMATTER_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_INPUT_FORMATTER_BASE 0x2C
-#define HIVE_SIZE_INPUT_FORMATTER_BASE 8
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_INPUT_FORMATTER_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x2C
-#define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 8
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_raw_frame_pool
-#define HIVE_MEM_raw_frame_pool scalar_processor_demo_dmem
-#define HIVE_ADDR_raw_frame_pool 0x25F8
-#define HIVE_SIZE_raw_frame_pool 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_raw_frame_pool scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_raw_frame_pool 0x25F8
-#define HIVE_SIZE_sp_raw_frame_pool 16
-
-/* function sp_raw_copy_func: 261A */
-
-/* function __sp_dma_proxy_configure_channel_text: 2A2E */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_sp2host_event_queue
-#define HIVE_MEM_sem_for_sp2host_event_queue scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_sp2host_event_queue 0x3688
-#define HIVE_SIZE_sem_for_sp2host_event_queue 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_sp2host_event_queue scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_event_queue 0x3688
-#define HIVE_SIZE_sp_sem_for_sp2host_event_queue 24
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_copy_pack
-#define HIVE_MEM_sp_copy_pack scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_copy_pack 0x2C28
-#define HIVE_SIZE_sp_copy_pack 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_copy_pack scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_copy_pack 0x2C28
-#define HIVE_SIZE_sp_sp_copy_pack 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_tagger
-#define HIVE_MEM_tagger scalar_processor_demo_dmem
-#define HIVE_ADDR_tagger 0x2C2C
-#define HIVE_SIZE_tagger 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_tagger scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_tagger 0x2C2C
-#define HIVE_SIZE_sp_tagger 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_refpool
-#define HIVE_MEM_refpool scalar_processor_demo_dmem
-#define HIVE_ADDR_refpool 0x2608
-#define HIVE_SIZE_refpool 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_refpool scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_refpool 0x2608
-#define HIVE_SIZE_sp_refpool 16
-
-/* function host2sp_dequeue_sp_event: D2 */
-
-/* function sp_start_isp_entry: 1ED4 */
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifdef HIVE_ADDR_sp_start_isp_entry
-#endif
-#define HIVE_ADDR_sp_start_isp_entry 0x1ED4
-#endif
-#define HIVE_ADDR_sp_sp_start_isp_entry 0x1ED4
-
-/* function add_sp_command: 3AED */
-
-/* function sp2host_enqueue_irq_event: BB */
-
-/* function create_sp_fibers: 2B9D */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_pipe_private_s3a_bufs
-#define HIVE_MEM_pipe_private_s3a_bufs scalar_processor_demo_dmem
-#define HIVE_ADDR_pipe_private_s3a_bufs 0x2E04
-#define HIVE_SIZE_pipe_private_s3a_bufs 32
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_pipe_private_s3a_bufs scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_pipe_private_s3a_bufs 0x2E04
-#define HIVE_SIZE_sp_pipe_private_s3a_bufs 32
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_dma_crop_block_width_a
-#define HIVE_MEM_sp_dma_crop_block_width_a scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_crop_block_width_a 0x26BC
-#define HIVE_SIZE_sp_dma_crop_block_width_a 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_dma_crop_block_width_a scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_dma_crop_block_width_a 0x26BC
-#define HIVE_SIZE_sp_sp_dma_crop_block_width_a 4
-
-/* function sp_bin_copy_func: 2F9 */
-
-/* function ia_css_i_sp_rmgr_acq_gen: 16D */
-
-/* function sp_turn_on_flash: 2C24 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sems_for_sp2host_buf_queues
-#define HIVE_MEM_sems_for_sp2host_buf_queues scalar_processor_demo_dmem
-#define HIVE_ADDR_sems_for_sp2host_buf_queues 0x2E24
-#define HIVE_SIZE_sems_for_sp2host_buf_queues 168
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sems_for_sp2host_buf_queues scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sems_for_sp2host_buf_queues 0x2E24
-#define HIVE_SIZE_sp_sems_for_sp2host_buf_queues 168
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_vectors_per_line
-#define HIVE_MEM_isp_vectors_per_line scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_vectors_per_line 0x2A38
-#define HIVE_SIZE_isp_vectors_per_line 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_vectors_per_line scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_vectors_per_line 0x2A38
-#define HIVE_SIZE_sp_isp_vectors_per_line 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_h_latest_parameter_set
-#define HIVE_MEM_h_latest_parameter_set scalar_processor_demo_dmem
-#define HIVE_ADDR_h_latest_parameter_set 0x363C
-#define HIVE_SIZE_h_latest_parameter_set 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_h_latest_parameter_set scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_h_latest_parameter_set 0x363C
-#define HIVE_SIZE_sp_h_latest_parameter_set 16
-
-/* function __sp_dma_proxy_func_text: 26B2 */
-
-/* function sp_dma_proxy_configure_channel: 3A2A */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_do_irq_raise
-#define HIVE_MEM_do_irq_raise scalar_processor_demo_dmem
-#define HIVE_ADDR_do_irq_raise 0x888
-#define HIVE_SIZE_do_irq_raise 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_do_irq_raise scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_do_irq_raise 0x888
-#define HIVE_SIZE_sp_do_irq_raise 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_group
-#define HIVE_MEM_sp_group scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_group 0x2A3C
-#define HIVE_SIZE_sp_group 444
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_group scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_group 0x2A3C
-#define HIVE_SIZE_sp_sp_group 444
-
-/* function sp2host_buffer_queue_get_size: E7 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_event_proxy_thread
-#define HIVE_MEM_sp_event_proxy_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_event_proxy_thread 0x2DB0
-#define HIVE_SIZE_sp_event_proxy_thread 68
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_event_proxy_thread 0x2DB0
-#define HIVE_SIZE_sp_sp_event_proxy_thread 68
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_dma_pool
-#define HIVE_MEM_dma_pool scalar_processor_demo_dmem
-#define HIVE_ADDR_dma_pool 0x80
-#define HIVE_SIZE_dma_pool 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_dma_pool scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_pool 0x80
-#define HIVE_SIZE_sp_dma_pool 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_uv_internal_width_vecs
-#define HIVE_MEM_isp_uv_internal_width_vecs scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_uv_internal_width_vecs 0x2BF8
-#define HIVE_SIZE_isp_uv_internal_width_vecs 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_uv_internal_width_vecs scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_uv_internal_width_vecs 0x2BF8
-#define HIVE_SIZE_sp_isp_uv_internal_width_vecs 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_pipe_private_exp_id
-#define HIVE_MEM_pipe_private_exp_id scalar_processor_demo_dmem
-#define HIVE_ADDR_pipe_private_exp_id 0x2ECC
-#define HIVE_SIZE_pipe_private_exp_id 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_pipe_private_exp_id scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_pipe_private_exp_id 0x2ECC
-#define HIVE_SIZE_sp_pipe_private_exp_id 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_MMU_BASE
-#define HIVE_MEM_MMU_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_MMU_BASE 0x34
-#define HIVE_SIZE_MMU_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_MMU_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_MMU_BASE 0x34
-#define HIVE_SIZE_sp_MMU_BASE 4
-
-/* function sp_dma_proxy_configure_init_dmem_channel: 29E9 */
-
-/* function sp2host_event_queue_get_size: B3 */
-
-/* function sp_dma_proxy_read_byte_addr: 3A16 */
-
-/* function sp_thread_fork: 2CA4 */
-
-/* function sp_semaphore_wait: 3C60 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_reading_cb_frames_preview_pipe
-#define HIVE_MEM_sem_for_reading_cb_frames_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frames_preview_pipe 0x3730
-#define HIVE_SIZE_sem_for_reading_cb_frames_preview_pipe 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_reading_cb_frames_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frames_preview_pipe 0x3730
-#define HIVE_SIZE_sp_sem_for_reading_cb_frames_preview_pipe 24
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_request_flash
-#define HIVE_MEM_sp_request_flash scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_request_flash 0x2C58
-#define HIVE_SIZE_sp_request_flash 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_request_flash scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_request_flash 0x2C58
-#define HIVE_SIZE_sp_sp_request_flash 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_raw_frame_socket
-#define HIVE_MEM_raw_frame_socket scalar_processor_demo_dmem
-#define HIVE_ADDR_raw_frame_socket 0x3748
-#define HIVE_SIZE_raw_frame_socket 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_raw_frame_socket scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_raw_frame_socket 0x3748
-#define HIVE_SIZE_sp_raw_frame_socket 20
-
-/* function cnd_input_system_cfg: 2478 */
-
-/* function sp_generate_events: 34D3 */
-
-/* function sp_uds_configure: 409 */
-
-/* function sp_dma_proxy_execute: 29C2 */
-
-/* function __modu: 35D5 */
-
-/* function sp_circular_buf_push_marked: 2DDD */
-
-/* function isp_vamem_store: 0 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_sdis_horiproj_num
-#define HIVE_MEM_isp_sdis_horiproj_num scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_sdis_horiproj_num 0x2BFC
-#define HIVE_SIZE_isp_sdis_horiproj_num 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_sdis_horiproj_num scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_sdis_horiproj_num 0x2BFC
-#define HIVE_SIZE_sp_isp_sdis_horiproj_num 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_GDC_BASE
-#define HIVE_MEM_GDC_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_GDC_BASE 0x28
-#define HIVE_SIZE_GDC_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_GDC_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_GDC_BASE 0x28
-#define HIVE_SIZE_sp_GDC_BASE 4
-
-/* function ia_css_i_sp_rmgr_uninit: 126 */
-
-/* function sp_thread_init: 2CC4 */
-
-/* function irq_raise_set_token: 92 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_GPIO_BASE
-#define HIVE_MEM_GPIO_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_GPIO_BASE 0x20
-#define HIVE_SIZE_GPIO_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_GPIO_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_GPIO_BASE 0x20
-#define HIVE_SIZE_sp_GPIO_BASE 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_h_tmp_ddr_buffer_addr
-#define HIVE_MEM_h_tmp_ddr_buffer_addr scalar_processor_demo_dmem
-#define HIVE_ADDR_h_tmp_ddr_buffer_addr 0x364C
-#define HIVE_SIZE_h_tmp_ddr_buffer_addr 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_h_tmp_ddr_buffer_addr scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_h_tmp_ddr_buffer_addr 0x364C
-#define HIVE_SIZE_sp_h_tmp_ddr_buffer_addr 16
-
-/* function _dma_proxy_dma_read_write: 3A7C */
-
-/* function sp_dma_proxy_configure_init_vmem_channel: 2A0C */
-
-/* function sp_acquire_dynamic_buf: 307A */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_ph
-#define HIVE_MEM_isp_ph scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_ph 0x21E0
-#define HIVE_SIZE_isp_ph 32
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_ph scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_ph 0x21E0
-#define HIVE_SIZE_sp_isp_ph 32
-
-/* function sp_tagger_destroy: 343A */
-
-/* function init_isp_internal_buffers: E63 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_target_nr_of_captured_frames
-#define HIVE_MEM_target_nr_of_captured_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_target_nr_of_captured_frames 0x880
-#define HIVE_SIZE_target_nr_of_captured_frames 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_target_nr_of_captured_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_target_nr_of_captured_frames 0x880
-#define HIVE_SIZE_sp_target_nr_of_captured_frames 4
-
-/* function sp_dma_proxy_write: 29AB */
-
-/* function ia_css_i_sp_refcount_init_vbuf: 19E */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_reading_cb_params_preview_pipe
-#define HIVE_MEM_sem_for_reading_cb_params_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_reading_cb_params_preview_pipe 0x375C
-#define HIVE_SIZE_sem_for_reading_cb_params_preview_pipe 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_reading_cb_params_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_params_preview_pipe 0x375C
-#define HIVE_SIZE_sp_sem_for_reading_cb_params_preview_pipe 24
-
-/* function sp_dma_proxy_vmem_read: 2980 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_reading_cb_params_capture_pipe
-#define HIVE_MEM_sem_for_reading_cb_params_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_reading_cb_params_capture_pipe 0x3774
-#define HIVE_SIZE_sem_for_reading_cb_params_capture_pipe 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_reading_cb_params_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_params_capture_pipe 0x3774
-#define HIVE_SIZE_sp_sem_for_reading_cb_params_capture_pipe 24
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_params_capture_pipe
-#define HIVE_MEM_cb_params_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_params_capture_pipe 0x378C
-#define HIVE_SIZE_cb_params_capture_pipe 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_params_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_params_capture_pipe 0x378C
-#define HIVE_SIZE_sp_cb_params_capture_pipe 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_sdis_vertproj_num
-#define HIVE_MEM_isp_sdis_vertproj_num scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_sdis_vertproj_num 0x2C00
-#define HIVE_SIZE_isp_sdis_vertproj_num 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_sdis_vertproj_num scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_sdis_vertproj_num 0x2C00
-#define HIVE_SIZE_sp_isp_sdis_vertproj_num 4
-
-/* function wait_for_in_param: 3114 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_frames_capture_pipe
-#define HIVE_MEM_cb_frames_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_frames_capture_pipe 0x37A0
-#define HIVE_SIZE_cb_frames_capture_pipe 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_frames_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_frames_capture_pipe 0x37A0
-#define HIVE_SIZE_sp_cb_frames_capture_pipe 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_host_sp_queue
-#define HIVE_MEM_host_sp_queue scalar_processor_demo_dmem
-#define HIVE_ADDR_host_sp_queue 0x2ED0
-#define HIVE_SIZE_host_sp_queue 1036
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_host_sp_queue scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_host_sp_queue 0x2ED0
-#define HIVE_SIZE_sp_host_sp_queue 1036
-
-/* function sp_thread_main: 2CD4 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_pool
-#define HIVE_MEM_isp_pool scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_pool 0x84
-#define HIVE_SIZE_isp_pool 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_pool scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_pool 0x84
-#define HIVE_SIZE_sp_isp_pool 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_is_done_flag
-#define HIVE_MEM_isp_is_done_flag scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_is_done_flag 0x88C
-#define HIVE_SIZE_isp_is_done_flag 1
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_is_done_flag scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_is_done_flag 0x88C
-#define HIVE_SIZE_sp_isp_is_done_flag 1
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_event_any_pending_mask
-#define HIVE_MEM_event_any_pending_mask scalar_processor_demo_dmem
-#define HIVE_ADDR_event_any_pending_mask 0x2B4
-#define HIVE_SIZE_event_any_pending_mask 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_event_any_pending_mask scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_event_any_pending_mask 0x2B4
-#define HIVE_SIZE_sp_event_any_pending_mask 4
-
-/* function ia_css_i_sp_refcount_release_vbuf: 1FA */
-
-/* function init_isp_data_segment: EF0 */
-
-/* function sh_css_decode_tag_descr: 2AB */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_dma_configs
-#define HIVE_MEM_dma_configs scalar_processor_demo_dmem
-#define HIVE_ADDR_dma_configs 0x2618
-#define HIVE_SIZE_dma_configs 160
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_dma_configs scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_configs 0x2618
-#define HIVE_SIZE_sp_dma_configs 160
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_dma_crop_cropping_a
-#define HIVE_MEM_sp_dma_crop_cropping_a scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_crop_cropping_a 0x26C0
-#define HIVE_SIZE_sp_dma_crop_cropping_a 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_dma_crop_cropping_a scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_dma_crop_cropping_a 0x26C0
-#define HIVE_SIZE_sp_sp_dma_crop_cropping_a 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_isp_idle
-#define HIVE_MEM_sem_for_isp_idle scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_isp_idle 0x37B4
-#define HIVE_SIZE_sem_for_isp_idle 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_isp_idle 0x37B4
-#define HIVE_SIZE_sp_sem_for_isp_idle 24
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_channels
-#define HIVE_MEM_channels scalar_processor_demo_dmem
-#define HIVE_ADDR_channels 0x21BC
-#define HIVE_SIZE_channels 36
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_channels scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_channels 0x21BC
-#define HIVE_SIZE_sp_channels 36
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_vf_downscale_bits
-#define HIVE_MEM_sp_vf_downscale_bits scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_vf_downscale_bits 0x2C04
-#define HIVE_SIZE_sp_vf_downscale_bits 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_vf_downscale_bits scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_vf_downscale_bits 0x2C04
-#define HIVE_SIZE_sp_sp_vf_downscale_bits 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_sdis_vertcoef_vectors
-#define HIVE_MEM_isp_sdis_vertcoef_vectors scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_sdis_vertcoef_vectors 0x2C08
-#define HIVE_SIZE_isp_sdis_vertcoef_vectors 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_sdis_vertcoef_vectors scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_sdis_vertcoef_vectors 0x2C08
-#define HIVE_SIZE_sp_isp_sdis_vertcoef_vectors 4
-
-/* function dma_configure: 5EE */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_ISP_VAMEM_BASE
-#define HIVE_MEM_ISP_VAMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_ISP_VAMEM_BASE 0x10
-#define HIVE_SIZE_ISP_VAMEM_BASE 8
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_ISP_VAMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_ISP_VAMEM_BASE 0x10
-#define HIVE_SIZE_sp_ISP_VAMEM_BASE 8
-
-/* function handle_parameter_sets: 317E */
-
-/* function sp_tagger_create: 344E */
-
-/* function sp_dma_proxy_deregister_channel_from_port: 293D */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_pipe_private_dis_bufs
-#define HIVE_MEM_pipe_private_dis_bufs scalar_processor_demo_dmem
-#define HIVE_ADDR_pipe_private_dis_bufs 0x32DC
-#define HIVE_SIZE_pipe_private_dis_bufs 32
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_pipe_private_dis_bufs scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_pipe_private_dis_bufs 0x32DC
-#define HIVE_SIZE_sp_pipe_private_dis_bufs 32
-
-/* function sp_semaphore_signal: 3C2B */
-
-/* function sp_dma_proxy_write_byte_addr: 2996 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_SP_PMEM_BASE
-#define HIVE_MEM_SP_PMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_SP_PMEM_BASE 0x0
-#define HIVE_SIZE_SP_PMEM_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_SP_PMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
-#define HIVE_SIZE_sp_SP_PMEM_BASE 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_isp_input_stream_format
-#define HIVE_MEM_sp_isp_input_stream_format scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_input_stream_format 0x2C0C
-#define HIVE_SIZE_sp_isp_input_stream_format 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x2C0C
-#define HIVE_SIZE_sp_sp_isp_input_stream_format 4
-
-/* function sp_circular_buf_push_unmarked: 2D2F */
-
-/* function __mod: 35C0 */
-
-/* function __sp_event_proxy_func_critical: 3B25 */
-
-/* function sp_circular_buf_mark: 2E7D */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_target_nr_of_copied_frames
-#define HIVE_MEM_target_nr_of_copied_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_target_nr_of_copied_frames 0x2C40
-#define HIVE_SIZE_target_nr_of_copied_frames 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_target_nr_of_copied_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_target_nr_of_copied_frames 0x2C40
-#define HIVE_SIZE_sp_target_nr_of_copied_frames 4
-
-/* function irq_raise: A1 */
-
-/* function sp_circular_buf_unmark: 2E5C */
-
-/* function ia_css_i_sp_rmgr_vbuf_dequeue: 1C2 */
-
-/* function _dma_proxy_dma_execute: 2AC5 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_frames_tagger
-#define HIVE_MEM_cb_frames_tagger scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_frames_tagger 0x3670
-#define HIVE_SIZE_cb_frames_tagger 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_frames_tagger scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_frames_tagger 0x3670
-#define HIVE_SIZE_sp_cb_frames_tagger 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_elems_frames_preview_pipe
-#define HIVE_MEM_cb_elems_frames_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_elems_frames_preview_pipe 0x37CC
-#define HIVE_SIZE_cb_elems_frames_preview_pipe 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_elems_frames_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_elems_frames_preview_pipe 0x37CC
-#define HIVE_SIZE_sp_cb_elems_frames_preview_pipe 16
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_frames_preview_pipe
-#define HIVE_MEM_cb_frames_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_frames_preview_pipe 0x37DC
-#define HIVE_SIZE_cb_frames_preview_pipe 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_frames_preview_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_frames_preview_pipe 0x37DC
-#define HIVE_SIZE_sp_cb_frames_preview_pipe 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_current_sp_fiber
-#define HIVE_MEM_current_sp_fiber scalar_processor_demo_dmem
-#define HIVE_ADDR_current_sp_fiber 0xDAC
-#define HIVE_SIZE_current_sp_fiber 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_current_sp_fiber scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_current_sp_fiber 0xDAC
-#define HIVE_SIZE_sp_current_sp_fiber 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_dma_vfout_cropping_a
-#define HIVE_MEM_sp_dma_vfout_cropping_a scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_dma_vfout_cropping_a 0x26C4
-#define HIVE_SIZE_sp_dma_vfout_cropping_a 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_dma_vfout_cropping_a scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_dma_vfout_cropping_a 0x26C4
-#define HIVE_SIZE_sp_sp_dma_vfout_cropping_a 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cb_elems_frames_capture_pipe
-#define HIVE_MEM_cb_elems_frames_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_cb_elems_frames_capture_pipe 0x37F0
-#define HIVE_SIZE_cb_elems_frames_capture_pipe 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cb_elems_frames_capture_pipe scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_cb_elems_frames_capture_pipe 0x37F0
-#define HIVE_SIZE_sp_cb_elems_frames_capture_pipe 16
-
-/* function sp_dma_proxy_init: 2784 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_copy_preview_overlap
-#define HIVE_MEM_sp_copy_preview_overlap scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_copy_preview_overlap 0x2C44
-#define HIVE_SIZE_sp_copy_preview_overlap 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_copy_preview_overlap scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_copy_preview_overlap 0x2C44
-#define HIVE_SIZE_sp_sp_copy_preview_overlap 4
-
-/* function sp_release_dynamic_buf: 2F77 */
-
-/* function ia_css_i_sp_rmgr_vbuf_enqueue: 1E7 */
-
-/* function end_binary: CA5 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_stacks
-#define HIVE_MEM_stacks scalar_processor_demo_dmem
-#define HIVE_ADDR_stacks 0x1F4
-#define HIVE_SIZE_stacks 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_stacks scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_stacks 0x1F4
-#define HIVE_SIZE_sp_stacks 24
-
-/* function dma_proxy_dma_execute_split: 2AF2 */
-
-/* function ia_css_i_sp_rmgr_rel_gen: 15A */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_raw_frame_in_port
-#define HIVE_MEM_raw_frame_in_port scalar_processor_demo_dmem
-#define HIVE_ADDR_raw_frame_in_port 0x3800
-#define HIVE_SIZE_raw_frame_in_port 20
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_raw_frame_in_port scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_raw_frame_in_port 0x3800
-#define HIVE_SIZE_sp_raw_frame_in_port 20
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_irq_sw_interrupt_token
-#define HIVE_MEM_irq_sw_interrupt_token scalar_processor_demo_dmem
-#define HIVE_ADDR_irq_sw_interrupt_token 0x2198
-#define HIVE_SIZE_irq_sw_interrupt_token 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x2198
-#define HIVE_SIZE_sp_irq_sw_interrupt_token 4
-
-/* function sp_thread_kill: 2C88 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_pipe_private_buffer_bufs
-#define HIVE_MEM_pipe_private_buffer_bufs scalar_processor_demo_dmem
-#define HIVE_ADDR_pipe_private_buffer_bufs 0x32FC
-#define HIVE_SIZE_pipe_private_buffer_bufs 112
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_pipe_private_buffer_bufs scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_pipe_private_buffer_bufs 0x32FC
-#define HIVE_SIZE_sp_pipe_private_buffer_bufs 112
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_isp_addresses
-#define HIVE_MEM_sp_isp_addresses scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_addresses 0x20DC
-#define HIVE_SIZE_sp_isp_addresses 188
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_isp_addresses scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_isp_addresses 0x20DC
-#define HIVE_SIZE_sp_sp_isp_addresses 188
-
-/* function sp_fiber_main: 2C0A */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isps
-#define HIVE_MEM_isps scalar_processor_demo_dmem
-#define HIVE_ADDR_isps 0x2200
-#define HIVE_SIZE_isps 32
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isps scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isps 0x2200
-#define HIVE_SIZE_sp_isps 32
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_host_sp_queues_initialized
-#define HIVE_MEM_host_sp_queues_initialized scalar_processor_demo_dmem
-#define HIVE_ADDR_host_sp_queues_initialized 0x2C10
-#define HIVE_SIZE_host_sp_queues_initialized 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_host_sp_queues_initialized 0x2C10
-#define HIVE_SIZE_sp_host_sp_queues_initialized 4
-
-/* function __sp_dma_proxy_wait_for_ack_text: 2952 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_vbuf_spref
-#define HIVE_MEM_vbuf_spref scalar_processor_demo_dmem
-#define HIVE_ADDR_vbuf_spref 0x88
-#define HIVE_SIZE_vbuf_spref 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_vbuf_spref scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_vbuf_spref 0x88
-#define HIVE_SIZE_sp_vbuf_spref 4
-
-/* function sp_circular_buf_extract: 2E9D */
-
-/* function output_compute_dma_info: 1819 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_sdis_horicoef_vectors
-#define HIVE_MEM_isp_sdis_horicoef_vectors scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_sdis_horicoef_vectors 0x2C14
-#define HIVE_SIZE_isp_sdis_horicoef_vectors 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_sdis_horicoef_vectors scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_sdis_horicoef_vectors 0x2C14
-#define HIVE_SIZE_sp_isp_sdis_horicoef_vectors 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sem_for_reading_if
-#define HIVE_MEM_sem_for_reading_if scalar_processor_demo_dmem
-#define HIVE_ADDR_sem_for_reading_if 0x3814
-#define HIVE_SIZE_sem_for_reading_if 24
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sem_for_reading_if scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sem_for_reading_if 0x3814
-#define HIVE_SIZE_sp_sem_for_reading_if 24
-
-/* function sp_circular_buf_pop_marked: 2DA8 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_pipe_private_frames
-#define HIVE_MEM_pipe_private_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_pipe_private_frames 0x336C
-#define HIVE_SIZE_pipe_private_frames 48
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_pipe_private_frames scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_pipe_private_frames 0x336C
-#define HIVE_SIZE_sp_pipe_private_frames 48
-
-/* function sp_generate_interrupts: 3477 */
-
-/* function ia_css_i_sp_rmgr_update_num_vbuf: 29E */
-
-/* function init_isp_vars: 1C0C */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sems_for_host2sp_buf_queues
-#define HIVE_MEM_sems_for_host2sp_buf_queues scalar_processor_demo_dmem
-#define HIVE_ADDR_sems_for_host2sp_buf_queues 0x339C
-#define HIVE_SIZE_sems_for_host2sp_buf_queues 672
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sems_for_host2sp_buf_queues scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sems_for_host2sp_buf_queues 0x339C
-#define HIVE_SIZE_sp_sems_for_host2sp_buf_queues 672
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_data
-#define HIVE_MEM_sp_data scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_data 0x2770
-#define HIVE_SIZE_sp_data 548
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_data scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_data 0x2770
-#define HIVE_SIZE_sp_sp_data 548
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_ISP_BAMEM_BASE
-#define HIVE_MEM_ISP_BAMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_ISP_BAMEM_BASE 0x2B0
-#define HIVE_SIZE_ISP_BAMEM_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_ISP_BAMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x2B0
-#define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
-
-/* function sp_circular_buf_is_marked: 2E3D */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_mem_map
-#define HIVE_MEM_mem_map scalar_processor_demo_dmem
-#define HIVE_ADDR_mem_map 0x26C8
-#define HIVE_SIZE_mem_map 100
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_mem_map scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_mem_map 0x26C8
-#define HIVE_SIZE_sp_mem_map 100
-
-/* function sp_init_dmem: 254E */
-
-/* function ia_css_i_sp_refcount_retain_vbuf: 212 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_thread_is_active
-#define HIVE_MEM_thread_is_active scalar_processor_demo_dmem
-#define HIVE_ADDR_thread_is_active 0x23C
-#define HIVE_SIZE_thread_is_active 16
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_thread_is_active scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_thread_is_active 0x23C
-#define HIVE_SIZE_sp_thread_is_active 16
-
-/* function init_isp_code_segment: D4D */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_ISP_PMEM_BASE
-#define HIVE_MEM_ISP_PMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_ISP_PMEM_BASE 0x2AC
-#define HIVE_SIZE_ISP_PMEM_BASE 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_ISP_PMEM_BASE scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_ISP_PMEM_BASE 0x2AC
-#define HIVE_SIZE_sp_ISP_PMEM_BASE 4
-
-/* function run_sp_threads: 2CE9 */
-
-/* function configure_dma_channel: 25FD */
-
-/* function sp_dma_proxy_register_channel_to_port: 2948 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_flash_in_service
-#define HIVE_MEM_sp_flash_in_service scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_flash_in_service 0xDBC
-#define HIVE_SIZE_sp_flash_in_service 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_flash_in_service scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_flash_in_service 0xDBC
-#define HIVE_SIZE_sp_sp_flash_in_service 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_vf_output_width_vecs
-#define HIVE_MEM_isp_vf_output_width_vecs scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_vf_output_width_vecs 0x2C18
-#define HIVE_SIZE_isp_vf_output_width_vecs 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_vf_output_width_vecs scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_vf_output_width_vecs 0x2C18
-#define HIVE_SIZE_sp_isp_vf_output_width_vecs 4
-
-/* function sp_circular_buf_pop_unmarked: 2CFF */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_sp_sleep_mode
-#define HIVE_MEM_sp_sleep_mode scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sleep_mode 0x2C1C
-#define HIVE_SIZE_sp_sleep_mode 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_sp_sleep_mode scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_sp_sleep_mode 0x2C1C
-#define HIVE_SIZE_sp_sp_sleep_mode 4
-
-/* function mmu_invalidate_cache: AB */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_isp_stop_req
-#define HIVE_MEM_isp_stop_req scalar_processor_demo_dmem
-#define HIVE_ADDR_isp_stop_req 0x2C54
-#define HIVE_SIZE_isp_stop_req 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_isp_stop_req scalar_processor_demo_dmem
-#define HIVE_ADDR_sp_isp_stop_req 0x2C54
-#define HIVE_SIZE_sp_isp_stop_req 4
-
-#define HIVE_ICACHE_sp_critical_SEGMENT_START 0
-#define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
-
-#endif /* _sp_map_h_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/Makefile b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/Makefile
deleted file mode 100644
index 919d880..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/Makefile
+++ /dev/null
@@ -1,19 +0,0 @@
-#
-#  Copyright (c) 2010 - 2015, Intel Corporation.
-#
-#  This program is free software; you can redistribute it and/or modify it
-#  under the terms and conditions of the GNU General Public License,
-#  version 2, as published by the Free Software Foundation.
-#
-#  This program is distributed in the hope it will be useful, but WITHOUT
-#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-#  more details.
-#
-
-ccflags-y += -DATOMISP_POSTFIX=\"css2300\" -DISP2300 -DCSS15
-CSS15 := m
-ISP2300 := y
-postfix := css2300
-
-include $(srctree)/$(src)/../Makefile.common
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/atomisp_driver b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/atomisp_driver
deleted file mode 120000
index 215bfba..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/atomisp_driver
+++ /dev/null
@@ -1 +0,0 @@
-../atomisp_driver_css15
\ No newline at end of file
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/css b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/css
deleted file mode 120000
index 01628d9..0000000
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2300_build/css
+++ /dev/null
@@ -1 +0,0 @@
-../css2300
\ No newline at end of file
-- 
1.9.1

