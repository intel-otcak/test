From 493bb2e186e0a777b134ee713dfd7ab3ebff0c9c Mon Sep 17 00:00:00 2001
From: Daniel Drubin <idaniel.drubin@intel.com>
Date: Wed, 20 Jan 2016 19:06:45 +0200
Subject: [PATCH 1/6] Reorganized ISH code

Change-Id: Id9950bf165953162388fbcb549a49412f29015c1
Signed-off-by: Daniel Drubin <daniel.drubin@intel.com>
Tracked-On: https://jira01.devtools.intel.com/browse/OAM-16663
Reviewed-on: https://android.intel.com:443/460513
---
 arch/x86/configs/x86_64_defconfig        |   15 +-
 drivers/misc/Kconfig                     |    2 +-
 drivers/misc/Makefile                    |    2 +-
 drivers/misc/heci/Kconfig                |   26 -
 drivers/misc/heci/Makefile               |   23 -
 drivers/misc/heci/bus.c                  |  691 -----------------
 drivers/misc/heci/bus.h                  |  125 ---
 drivers/misc/heci/client.c               | 1243 ------------------------------
 drivers/misc/heci/client.h               |  192 -----
 drivers/misc/heci/debugfs.c              |  136 ----
 drivers/misc/heci/hbm.c                  |  927 ----------------------
 drivers/misc/heci/hbm.h                  |  369 ---------
 drivers/misc/heci/heci-api.c             |  692 -----------------
 drivers/misc/heci/heci-api.h             |  115 ---
 drivers/misc/heci/heci-hid-client.c      |  823 --------------------
 drivers/misc/heci/heci-hid.c             |  249 ------
 drivers/misc/heci/heci-hid.h             |  133 ----
 drivers/misc/heci/heci_dev.h             |  351 ---------
 drivers/misc/heci/hid-ids.h              |  891 ---------------------
 drivers/misc/heci/hid-strings-def.h      |  519 -------------
 drivers/misc/heci/hw-ish-regs.h          |  186 -----
 drivers/misc/heci/hw-ish.c               |  981 -----------------------
 drivers/misc/heci/hw-ish.h               |   62 --
 drivers/misc/heci/init.c                 |  254 ------
 drivers/misc/heci/pci-ish.c              | 1154 ---------------------------
 drivers/misc/heci/platform-config.h      |  125 ---
 drivers/misc/heci/senscol-core.c         | 1161 ----------------------------
 drivers/misc/heci/utils.h                |   65 --
 drivers/misc/intel-ish/Kconfig           |   26 +
 drivers/misc/intel-ish/Makefile          |   26 +
 drivers/misc/intel-ish/bus.c             |  691 +++++++++++++++++
 drivers/misc/intel-ish/bus.h             |  125 +++
 drivers/misc/intel-ish/client.c          | 1243 ++++++++++++++++++++++++++++++
 drivers/misc/intel-ish/client.h          |  192 +++++
 drivers/misc/intel-ish/debugfs.c         |  136 ++++
 drivers/misc/intel-ish/hbm.c             |  927 ++++++++++++++++++++++
 drivers/misc/intel-ish/hbm.h             |  369 +++++++++
 drivers/misc/intel-ish/heci-api.c        |  692 +++++++++++++++++
 drivers/misc/intel-ish/heci-api.h        |  115 +++
 drivers/misc/intel-ish/heci-hid-client.c |  823 ++++++++++++++++++++
 drivers/misc/intel-ish/heci-hid.c        |  249 ++++++
 drivers/misc/intel-ish/heci-hid.h        |  133 ++++
 drivers/misc/intel-ish/heci_dev.h        |  351 +++++++++
 drivers/misc/intel-ish/hid-sens-ids.h    |  586 ++++++++++++++
 drivers/misc/intel-ish/hid-strings-def.h |  519 +++++++++++++
 drivers/misc/intel-ish/hw-ish-regs.h     |  186 +++++
 drivers/misc/intel-ish/hw-ish.c          |  981 +++++++++++++++++++++++
 drivers/misc/intel-ish/hw-ish.h          |   62 ++
 drivers/misc/intel-ish/init.c            |  254 ++++++
 drivers/misc/intel-ish/ish-hid-dd.c      |  984 +++++++++++++++++++++++
 drivers/misc/intel-ish/pci-ish.c         | 1154 +++++++++++++++++++++++++++
 drivers/misc/intel-ish/platform-config.h |  125 +++
 drivers/misc/intel-ish/senscol-core.c    | 1161 ++++++++++++++++++++++++++++
 drivers/misc/intel-ish/utils.h           |   65 ++
 54 files changed, 12181 insertions(+), 11506 deletions(-)
 delete mode 100644 drivers/misc/heci/Kconfig
 delete mode 100644 drivers/misc/heci/Makefile
 delete mode 100644 drivers/misc/heci/bus.c
 delete mode 100644 drivers/misc/heci/bus.h
 delete mode 100644 drivers/misc/heci/client.c
 delete mode 100644 drivers/misc/heci/client.h
 delete mode 100644 drivers/misc/heci/debugfs.c
 delete mode 100644 drivers/misc/heci/hbm.c
 delete mode 100644 drivers/misc/heci/hbm.h
 delete mode 100644 drivers/misc/heci/heci-api.c
 delete mode 100644 drivers/misc/heci/heci-api.h
 delete mode 100644 drivers/misc/heci/heci-hid-client.c
 delete mode 100644 drivers/misc/heci/heci-hid.c
 delete mode 100644 drivers/misc/heci/heci-hid.h
 delete mode 100644 drivers/misc/heci/heci_dev.h
 delete mode 100644 drivers/misc/heci/hid-ids.h
 delete mode 100644 drivers/misc/heci/hid-strings-def.h
 delete mode 100644 drivers/misc/heci/hw-ish-regs.h
 delete mode 100644 drivers/misc/heci/hw-ish.c
 delete mode 100644 drivers/misc/heci/hw-ish.h
 delete mode 100644 drivers/misc/heci/init.c
 delete mode 100644 drivers/misc/heci/pci-ish.c
 delete mode 100644 drivers/misc/heci/platform-config.h
 delete mode 100644 drivers/misc/heci/senscol-core.c
 delete mode 100644 drivers/misc/heci/utils.h
 create mode 100644 drivers/misc/intel-ish/Kconfig
 create mode 100644 drivers/misc/intel-ish/Makefile
 create mode 100644 drivers/misc/intel-ish/bus.c
 create mode 100644 drivers/misc/intel-ish/bus.h
 create mode 100644 drivers/misc/intel-ish/client.c
 create mode 100644 drivers/misc/intel-ish/client.h
 create mode 100644 drivers/misc/intel-ish/debugfs.c
 create mode 100644 drivers/misc/intel-ish/hbm.c
 create mode 100644 drivers/misc/intel-ish/hbm.h
 create mode 100644 drivers/misc/intel-ish/heci-api.c
 create mode 100644 drivers/misc/intel-ish/heci-api.h
 create mode 100644 drivers/misc/intel-ish/heci-hid-client.c
 create mode 100644 drivers/misc/intel-ish/heci-hid.c
 create mode 100644 drivers/misc/intel-ish/heci-hid.h
 create mode 100644 drivers/misc/intel-ish/heci_dev.h
 create mode 100644 drivers/misc/intel-ish/hid-sens-ids.h
 create mode 100644 drivers/misc/intel-ish/hid-strings-def.h
 create mode 100644 drivers/misc/intel-ish/hw-ish-regs.h
 create mode 100644 drivers/misc/intel-ish/hw-ish.c
 create mode 100644 drivers/misc/intel-ish/hw-ish.h
 create mode 100644 drivers/misc/intel-ish/init.c
 create mode 100644 drivers/misc/intel-ish/ish-hid-dd.c
 create mode 100644 drivers/misc/intel-ish/pci-ish.c
 create mode 100644 drivers/misc/intel-ish/platform-config.h
 create mode 100644 drivers/misc/intel-ish/senscol-core.c
 create mode 100644 drivers/misc/intel-ish/utils.h

diff --git a/arch/x86/configs/x86_64_defconfig b/arch/x86/configs/x86_64_defconfig
index 5392717..ccf948a 100644
--- a/arch/x86/configs/x86_64_defconfig
+++ b/arch/x86/configs/x86_64_defconfig
@@ -1218,9 +1218,9 @@ CONFIG_EEPROM_93CX6=m
 CONFIG_INTEL_MEI=y
 CONFIG_INTEL_MEI_ME=y
 CONFIG_INTEL_MEI_TXE=y
-CONFIG_INTEL_ISS=y
-CONFIG_ISS_PATH_SENSCOL=y
-# CONFIG_ISS_PATH_IIO is not set
+CONFIG_INTEL_ISH=m
+CONFIG_ISH_PATH_SENSCOL=m
+# CONFIG_ISH_PATH_IIO is not set
 # CONFIG_VMWARE_VMCI is not set
 
 #
@@ -2903,7 +2903,7 @@ CONFIG_HID_MULTITOUCH=y
 # CONFIG_HID_XINMO is not set
 # CONFIG_HID_ZEROPLUS is not set
 # CONFIG_HID_ZYDACRON is not set
-CONFIG_HID_SENSOR_HUB=m
+# CONFIG_HID_SENSOR_HUB is not set
 
 #
 # USB HID support
@@ -3638,7 +3638,6 @@ CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
 #
 # CONFIG_BMA180 is not set
 # CONFIG_BMC150_ACCEL is not set
-CONFIG_HID_SENSOR_ACCEL_3D=m
 CONFIG_IIO_ST_ACCEL_3AXIS=y
 CONFIG_IIO_ST_ACCEL_I2C_3AXIS=y
 CONFIG_IIO_ST_ACCEL_SPI_3AXIS=y
@@ -3669,8 +3668,6 @@ CONFIG_IIO_ST_ACCEL_SPI_3AXIS=y
 #
 # Hid Sensor IIO Common
 #
-CONFIG_HID_SENSOR_IIO_COMMON=m
-CONFIG_HID_SENSOR_IIO_TRIGGER=m
 CONFIG_IIO_ST_SENSORS_I2C=y
 CONFIG_IIO_ST_SENSORS_SPI=y
 CONFIG_IIO_ST_SENSORS_CORE=y
@@ -3717,7 +3714,6 @@ CONFIG_IIO_ST_SENSORS_CORE=y
 # CONFIG_ADIS16260 is not set
 # CONFIG_ADXRS450 is not set
 # CONFIG_BMG160 is not set
-CONFIG_HID_SENSOR_GYRO_3D=m
 CONFIG_IIO_ST_GYRO_3AXIS=y
 CONFIG_IIO_ST_GYRO_I2C_3AXIS=y
 CONFIG_IIO_ST_GYRO_SPI_3AXIS=y
@@ -3746,7 +3742,6 @@ CONFIG_ACPI_ALS=y
 # CONFIG_CM3232 is not set
 # CONFIG_CM36651 is not set
 # CONFIG_GP2AP020A00F is not set
-CONFIG_HID_SENSOR_ALS=m
 # CONFIG_TCS3472 is not set
 # CONFIG_SENSORS_TSL2563 is not set
 # CONFIG_TSL4531 is not set
@@ -3760,7 +3755,6 @@ CONFIG_HID_SENSOR_ALS=m
 # CONFIG_AK8975 is not set
 # CONFIG_AK09911 is not set
 # CONFIG_MAG3110 is not set
-CONFIG_HID_SENSOR_MAGNETOMETER_3D=m
 CONFIG_IIO_ST_MAGN_3AXIS=y
 CONFIG_IIO_ST_MAGN_I2C_3AXIS=y
 CONFIG_IIO_ST_MAGN_SPI_3AXIS=y
@@ -3769,7 +3763,6 @@ CONFIG_IIO_ST_MAGN_SPI_3AXIS=y
 #
 # Inclinometer sensors
 #
-CONFIG_HID_SENSOR_INCLINOMETER_3D=m
 
 #
 # Triggers - standalone
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 7d9b215..afe3627 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -567,7 +567,7 @@ source "drivers/misc/lis3lv02d/Kconfig"
 source "drivers/misc/carma/Kconfig"
 source "drivers/misc/altera-stapl/Kconfig"
 source "drivers/misc/mei/Kconfig"
-source "drivers/misc/heci/Kconfig"
+source "drivers/misc/intel-ish/Kconfig"
 source "drivers/misc/vmw_vmci/Kconfig"
 source "drivers/misc/mic/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 151727b..3098385 100755
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -50,7 +50,7 @@ obj-y				+= carma/
 obj-$(CONFIG_USB_SWITCH_FSA9480) += fsa9480.o
 obj-$(CONFIG_ALTERA_STAPL)	+=altera-stapl/
 obj-$(CONFIG_INTEL_MEI)		+= mei/
-obj-$(CONFIG_INTEL_ISS)         += heci/
+obj-$(CONFIG_INTEL_ISH)         += intel-ish/
 obj-$(CONFIG_VMWARE_VMCI)	+= vmw_vmci/
 obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
diff --git a/drivers/misc/heci/Kconfig b/drivers/misc/heci/Kconfig
deleted file mode 100644
index 524ceb2..0000000
--- a/drivers/misc/heci/Kconfig
+++ /dev/null
@@ -1,26 +0,0 @@
-config INTEL_ISS
-	tristate "Intel Integrated Sensors Solution"
-	depends on X86 && PCI
-	help
-	  ISS enabled sensors hub functionality on SoC/chipset level.
-	  Placeholder for description line 2.
-	  Placeholder for description line 3.
-	  Placeholder for description line 4.
-
-config ISS_PATH_SENSCOL
-	tristate "ISS path through sensor-collection"
-	depends on INTEL_ISS
-	help
-	  Enables sensor-collection path for hid-sensor-hub.
-	  Placeholder for description line 2.
-	  Placeholder for description line 3.
-	  Placeholder for description line 4.
-
-config ISS_PATH_IIO
-	tristate "ISS path through IIO"
-	depends on INTEL_ISS
-	help
-	  Enables IIO path for hid-sensor-hub.
-	  Placeholder for description line 2.
-	  Placeholder for description line 3.
-	  Placeholder for description line 4.
diff --git a/drivers/misc/heci/Makefile b/drivers/misc/heci/Makefile
deleted file mode 100644
index af05bdf..0000000
--- a/drivers/misc/heci/Makefile
+++ /dev/null
@@ -1,23 +0,0 @@
-#
-# Makefile - Intel HECI and ISS implementation
-# Copyright (c) 2010-2015, Intel Corporation.
-#
-obj-m += heci.o
-heci-objs := init.o
-heci-objs += hbm.o
-heci-objs += client.o
-heci-objs += heci-api.o
-heci-objs += bus.o
-heci-$(CONFIG_DEBUG_FS) += debugfs.o
-
-obj-m += heci-ish.o
-heci-ish-objs := hw-ish.o
-heci-ish-objs += pci-ish.o
-
-obj-m += hid-heci-ish.o
-hid-heci-ish-objs := heci-hid.o
-hid-heci-ish-objs += heci-hid-client.o
-
-obj-m += sens-col-core.o
-sens-col-core-objs := senscol-core.o
-
diff --git a/drivers/misc/heci/bus.c b/drivers/misc/heci/bus.c
deleted file mode 100644
index 7c32a95..0000000
--- a/drivers/misc/heci/bus.c
+++ /dev/null
@@ -1,691 +0,0 @@
-/*
- * HECI bus driver
- *
- * Copyright (c) 2012-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include "bus.h"
-#include "heci_dev.h"
-#include "client.h"
-#include <asm/page.h>
-#include "hbm.h"
-#include "utils.h"
-
-#define to_heci_cl_driver(d) container_of(d, struct heci_cl_driver, driver)
-#define to_heci_cl_device(d) container_of(d, struct heci_cl_device, dev)
-
-/**
- * heci_me_cl_by_uuid - locate index of me client
- *
- * @dev: heci device
- * returns me client index or -ENOENT if not found
- */
-int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *uuid)
-{
-	int i, res = -ENOENT;
-	unsigned long	flags;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	for (i = 0; i < dev->me_clients_num; ++i) {
-		if (uuid_le_cmp(*uuid, dev->me_clients[i].props.protocol_name)
-				== 0) {
-			res = i;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	return res;
-}
-EXPORT_SYMBOL(heci_me_cl_by_uuid);
-
-
-/**
- * heci_me_cl_by_id return index to me_clients for client_id
- *
- * @dev: the device structure
- * @client_id: me client id
- *
- * returns index on success, -ENOENT on failure.
- */
-
-int heci_me_cl_by_id(struct heci_device *dev, u8 client_id)
-{
-	int i;
-	unsigned long	flags;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	for (i = 0; i < dev->me_clients_num; i++)
-		if (dev->me_clients[i].client_id == client_id)
-			break;
-	if (WARN_ON(dev->me_clients[i].client_id != client_id)) {
-		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-		return -ENOENT;
-	}
-
-	if (i == dev->me_clients_num) {
-		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-		return -ENOENT;
-	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	return i;
-}
-
-static int heci_cl_device_match(struct device *dev, struct device_driver *drv)
-{
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ returns 1\n", __func__);
-
-	/*
-	 * DD -- return true and let driver's probe() routine decide.
-	 * If this solution lives up, we can rearrange it
-	 * by simply removing match() routine at all
-	 */
-	return	1;
-}
-
-static int heci_cl_device_probe(struct device *dev)
-{
-	struct heci_cl_device *device = to_heci_cl_device(dev);
-	struct heci_cl_driver *driver;
-	struct heci_cl_device_id id;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	if (!device)
-		return 0;
-
-	/* in many cases here will be NULL */
-	driver = to_heci_cl_driver(dev->driver);
-	if (!driver || !driver->probe)
-		return -ENODEV;
-
-	dev_dbg(dev, "Device probe\n");
-
-	strncpy(id.name, dev_name(dev), HECI_CL_NAME_SIZE-1);
-	id.name[HECI_CL_NAME_SIZE-1] = '\0';
-
-	return driver->probe(device, &id);
-}
-
-static int heci_cl_device_remove(struct device *dev)
-{
-	struct heci_cl_device *device = to_heci_cl_device(dev);
-	struct heci_cl_driver *driver;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	if (!device || !dev->driver)
-		return 0;
-
-	if (device->event_cb) {
-		device->event_cb = NULL;
-		cancel_work_sync(&device->event_work);
-	}
-
-	driver = to_heci_cl_driver(dev->driver);
-	if (!driver->remove) {
-		dev->driver = NULL;
-
-		return 0;
-	}
-
-	return driver->remove(device);
-}
-
-static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
-	char *buf)
-{
-	int len;
-
-	len = snprintf(buf, PAGE_SIZE, "heci:%s\n", dev_name(dev));
-	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
-}
-
-static struct device_attribute heci_cl_dev_attrs[] = {
-	__ATTR_RO(modalias),
-	__ATTR_NULL,
-};
-
-static int heci_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
-{
-	if (add_uevent_var(env, "MODALIAS=heci:%s", dev_name(dev)))
-		return -ENOMEM;
-
-	return 0;
-}
-
-static struct bus_type heci_cl_bus_type = {
-	.name		= "heci",
-	.dev_attrs	= heci_cl_dev_attrs,
-	.match		= heci_cl_device_match,
-	.probe		= heci_cl_device_probe,
-	.remove		= heci_cl_device_remove,
-	.uevent		= heci_cl_uevent,
-};
-
-static void heci_cl_dev_release(struct device *dev)
-{
-	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
-	kfree(to_heci_cl_device(dev));
-	ISH_DBG_PRINT(KERN_ALERT "%s():---\n", __func__);
-}
-
-static struct device_type heci_cl_device_type = {
-	.release	= heci_cl_dev_release,
-};
-
-/*
- * Allocate HECI bus client device, attach it to uuid and register with HECI bus
- */
-struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
-	uuid_le uuid, char *name, struct heci_cl_dev_ops *ops)
-{
-	struct heci_cl_device *device;
-	int status;
-	unsigned long flags;
-
-	device = kzalloc(sizeof(struct heci_cl_device), GFP_ATOMIC);
-	if (!device)
-		return NULL;
-
-	device->ops = ops;
-
-	device->dev.parent = &dev->pdev->dev;
-	device->dev.bus = &heci_cl_bus_type;
-	device->dev.type = &heci_cl_device_type;
-	device->heci_dev = dev;
-
-	/* no need for spin lock here, the caller locked me_clients_lock */
-	device->fw_client =
-		&dev->me_clients[dev->me_client_presentation_num - 1];
-
-	dev_set_name(&device->dev, "%s", name);
-
-	spin_lock_irqsave(&dev->device_list_lock, flags);
-	list_add_tail(&device->device_link, &dev->device_list);
-	spin_unlock_irqrestore(&dev->device_list_lock, flags);
-
-	status = device_register(&device->dev);
-	if (status) {
-		spin_lock_irqsave(&dev->device_list_lock, flags);
-		list_del(&device->device_link);
-		spin_unlock_irqrestore(&dev->device_list_lock, flags);
-		dev_err(&dev->pdev->dev, "Failed to register HECI device\n");
-		kfree(device);
-		return NULL;
-	}
-
-	dev_dbg(&device->dev, "client %s registered\n", name);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): Registered HECI device\n", __func__);
-
-	return device;
-}
-EXPORT_SYMBOL_GPL(heci_bus_add_device);
-
-
-/*
- * This is a counterpart of heci_bus_add_device.
- * Device is unregistered and its structure is also freed
- */
-void heci_bus_remove_device(struct heci_cl_device *device)
-{
-	device_unregister(&device->dev);
-	/*kfree(device);*/
-}
-EXPORT_SYMBOL_GPL(heci_bus_remove_device);
-
-
-/*
- * Part of reset flow
- */
-void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
-{
-	struct heci_cl_device	*cl_device, *next_device;
-	struct heci_cl	*cl, *next;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&heci_dev->cl_list_lock, flags);
-	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
-/*		list_del(&cl->link);*/
-		cl->state = HECI_CL_DISCONNECTED;
-
-		/*
-		 * Wake any pending process. The waiter would check dev->state
-		 * and determine that it's not enabled already,
-		 * and will return error to its caller
-		 */
-		if (waitqueue_active(&cl->rx_wait))
-			wake_up_interruptible(&cl->rx_wait);
-		if (waitqueue_active(&cl->wait_ctrl_res))
-			wake_up(&cl->wait_ctrl_res);
-
-		/* Disband any pending read/write requests and free RB */
-		heci_cl_flush_queues(cl);
-
-		/* Remove read_rb for user-mode API clients */
-		if (cl->read_rb) {
-			struct heci_cl_rb *rb = NULL;
-
-			rb = heci_cl_find_read_rb(cl);
-			/* Remove entry from read list */
-			if (rb)
-				list_del(&rb->list);
-
-			rb = cl->read_rb;
-			cl->read_rb = NULL;
-
-			if (rb) {
-				heci_io_rb_free(rb);
-				rb = NULL;
-			}
-		}
-
-		/* Remove all free and in_process rings, both Rx and Tx */
-		heci_cl_free_rx_ring(cl);
-		heci_cl_free_tx_ring(cl);
-
-		/* Free client and HECI bus client device structures */
-		/* don't free host client because it is part of the OS fd
-		   structure */
-	}
-	spin_unlock_irqrestore(&heci_dev->cl_list_lock, flags);
-
-	/* remove bus clients */
-	spin_lock_irqsave(&heci_dev->device_list_lock, flags);
-	list_for_each_entry_safe(cl_device, next_device,
-		&heci_dev->device_list, device_link) {
-			list_del(&cl_device->device_link);
-			spin_unlock_irqrestore(&heci_dev->device_list_lock,
-				flags);
-			heci_bus_remove_device(cl_device);
-			spin_lock_irqsave(&heci_dev->device_list_lock, flags);
-		}
-	spin_unlock_irqrestore(&heci_dev->device_list_lock, flags);
-
-	/* Free all client structures */
-	spin_lock_irqsave(&heci_dev->me_clients_lock, flags);
-	kfree(heci_dev->me_clients);
-	heci_dev->me_clients = NULL;
-	heci_dev->me_clients_num = 0;
-	heci_dev->me_client_presentation_num  = 0;
-	heci_dev->me_client_index = 0;
-	bitmap_zero(heci_dev->me_clients_map, HECI_CLIENTS_MAX);
-/*
-	bitmap_zero(heci_dev->host_clients_map, HECI_CLIENTS_MAX);
-	bitmap_set(heci_dev->host_clients_map, 0, 3);
-*/
-	spin_unlock_irqrestore(&heci_dev->me_clients_lock, flags);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-}
-EXPORT_SYMBOL_GPL(heci_bus_remove_all_clients);
-
-
-int __heci_cl_driver_register(struct heci_cl_driver *driver,
-	struct module *owner)
-{
-	int err;
-
-	driver->driver.name = driver->name;
-	driver->driver.owner = owner;
-	driver->driver.bus = &heci_cl_bus_type;
-
-	err = driver_register(&driver->driver);
-	if (err)
-		return err;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): heci: driver [%s] registered\n",
-		__func__, driver->driver.name);
-	pr_debug("heci: driver [%s] registered\n", driver->driver.name);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(__heci_cl_driver_register);
-
-void heci_cl_driver_unregister(struct heci_cl_driver *driver)
-{
-	driver_unregister(&driver->driver);
-
-	pr_debug("heci: driver [%s] unregistered\n", driver->driver.name);
-}
-EXPORT_SYMBOL_GPL(heci_cl_driver_unregister);
-
-
-static void heci_bus_event_work(struct work_struct *work)
-{
-	struct heci_cl_device *device;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	device = container_of(work, struct heci_cl_device, event_work);
-
-	if (device->event_cb)
-		device->event_cb(device, device->events, device->event_context);
-
-	/*device->events = 0;*/
-}
-
-int heci_register_event_cb(struct heci_cl_device *device,
-	void (*event_cb)(struct heci_cl_device *, u32, void *), void *context)
-{
-	if (device->event_cb)
-		return -EALREADY;
-
-	/*device->events = 0;*/
-	device->event_cb = event_cb;
-	device->event_context = context;
-	INIT_WORK(&device->event_work, heci_bus_event_work);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(heci_register_event_cb);
-
-void *heci_cl_get_drvdata(const struct heci_cl_device *device)
-{
-	return dev_get_drvdata(&device->dev);
-}
-EXPORT_SYMBOL_GPL(heci_cl_get_drvdata);
-
-void heci_cl_set_drvdata(struct heci_cl_device *device, void *data)
-{
-	dev_set_drvdata(&device->dev, data);
-}
-EXPORT_SYMBOL_GPL(heci_cl_set_drvdata);
-
-/* What's this? */
-int heci_cl_enable_device(struct heci_cl_device *device)
-{
-	if (!device->ops || !device->ops->enable)
-		return 0;
-
-	return device->ops->enable(device);
-}
-EXPORT_SYMBOL_GPL(heci_cl_enable_device);
-
-int heci_cl_disable_device(struct heci_cl_device *device)
-{
-	if (!device->ops || !device->ops->disable)
-		return 0;
-
-	return device->ops->disable(device);
-}
-EXPORT_SYMBOL_GPL(heci_cl_disable_device);
-/************************/
-
-void heci_cl_bus_rx_event(struct heci_cl_device *device)
-{
-	static int	rx_count;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ [%d]\n", __func__, rx_count++);
-	if (!device || !device->event_cb)
-		return;
-
-	set_bit(HECI_CL_EVENT_RX, &device->events);
-
-	if (device->event_cb)
-		schedule_work(&device->event_work);
-}
-
-int __init heci_cl_bus_init(void)
-{
-	int	rv;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): Registering HECI bus\n", __func__);
-	rv = bus_register(&heci_cl_bus_type);
-	if (!rv)
-		heci_cl_alloc_dma_buf();
-	return	rv;
-}
-
-void __exit heci_cl_bus_exit(void)
-{
-ISH_DBG_PRINT(KERN_ALERT "%s(): Unregistering HECI bus\n", __func__);
-	bus_unregister(&heci_cl_bus_type);
-}
-
-
-ssize_t cl_prop_read(struct device *dev, struct device_attribute *dev_attr,
-	char *buf)
-{
-	ssize_t	rv = -EINVAL;
-	struct heci_cl_device	*cl_device = to_heci_cl_device(dev);
-	unsigned long	flags;
-
-	if (!strcmp(dev_attr->attr.name, "max_msg_length")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)cl_device->fw_client->props.max_msg_length);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "protocol_version")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)cl_device->fw_client->props.protocol_version);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "max_number_of_connections")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-(unsigned)cl_device->fw_client->props.max_number_of_connections);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "fixed_address")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)cl_device->fw_client->props.fixed_address);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "single_recv_buf")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)cl_device->fw_client->props.single_recv_buf);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "dma_hdr_len")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)cl_device->fw_client->props.dma_hdr_len);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "num_active_connections")) {
-		struct heci_cl	*cl, *next;
-		unsigned	count = 0;
-
-		spin_lock_irqsave(&cl_device->heci_dev->cl_list_lock, flags);
-		list_for_each_entry_safe(cl, next,
-				&cl_device->heci_dev->cl_list, link) {
-			if (cl->state == HECI_CL_CONNECTED &&
-					cl->device == cl_device)
-				++count;
-		}
-		spin_unlock_irqrestore(&cl_device->heci_dev->cl_list_lock,
-			flags);
-
-		scnprintf(buf, PAGE_SIZE, "%u\n", count);
-		rv = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name,  "client_id")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)cl_device->fw_client->client_id);
-		rv = strlen(buf);
-	}
-
-	return	rv;
-}
-
-ssize_t	cl_prop_write(struct device *dev, struct device_attribute *dev_attr,
-	const char *buf, size_t count)
-{
-	return	-EINVAL;
-}
-
-static struct device_attribute	max_msg_length = {
-	.attr = {
-		.name = "max_msg_length",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-static struct device_attribute	protocol_version = {
-	.attr = {
-		.name = "protocol_version",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-static struct device_attribute	max_number_of_connections = {
-	.attr = {
-		.name = "max_number_of_connections",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-static struct device_attribute	fixed_address = {
-	.attr = {
-		.name = "fixed_address",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-static struct device_attribute	single_recv_buf = {
-	.attr = {
-		.name = "single_recv_buf",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-static struct device_attribute	dma_hdr_len = {
-	.attr = {
-		.name = "dma_hdr_len",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-static struct device_attribute	num_active_connections = {
-	.attr = {
-		.name = "num_active_connections",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-static struct device_attribute	client_id = {
-	.attr = {
-		.name = "client_id",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = cl_prop_read,
-	.store = cl_prop_write
-};
-
-/*
- * Enum-completion callback for HECI bus - heci_device has reported its clients
- */
-int	heci_bus_new_client(struct heci_device *dev)
-{
-	int	i;
-	char	*dev_name;
-	struct heci_cl_device	*cl_device;
-	uuid_le	device_uuid;
-
-	/*
-	 * For all reported clients, create an unconnected client and add its
-	 * device to HECI bus.
-	 * If appropriate driver has loaded, this will trigger its probe().
-	 * Otherwise, probe() will be called when driver is loaded
-	 */
-	/* no need for spinlock here - the caller locked me_clients_lock */
-
-	i = dev->me_client_presentation_num - 1;
-	device_uuid = dev->me_clients[i].props.protocol_name;
-	dev_name = kasprintf(GFP_ATOMIC,
-		"{%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
-		device_uuid.b[3], device_uuid.b[2], device_uuid.b[1],
-		device_uuid.b[0], device_uuid.b[5], device_uuid.b[4],
-		device_uuid.b[7], device_uuid.b[6], device_uuid.b[8],
-		device_uuid.b[9], device_uuid.b[10], device_uuid.b[11],
-		device_uuid.b[12], device_uuid.b[13], device_uuid.b[14],
-		device_uuid.b[15]);
-	if (!dev_name)
-		return	-ENOMEM;
-
-	cl_device = heci_bus_add_device(dev, device_uuid, dev_name, NULL);
-	if (!cl_device) {
-		kfree(dev_name);
-		return	-ENOENT;
-	}
-
-	/* Export several properties per client device */
-	device_create_file(&cl_device->dev, &max_msg_length);
-	device_create_file(&cl_device->dev, &protocol_version);
-	device_create_file(&cl_device->dev, &max_number_of_connections);
-	device_create_file(&cl_device->dev, &fixed_address);
-	device_create_file(&cl_device->dev, &single_recv_buf);
-	device_create_file(&cl_device->dev, &dma_hdr_len);
-	device_create_file(&cl_device->dev, &num_active_connections);
-	device_create_file(&cl_device->dev, &client_id);
-	kfree(dev_name);
-
-	return	0;
-}
-
-
-static int	does_driver_bind_uuid(struct device *dev, void *id)
-{
-	uuid_le	*uuid = id;
-	struct heci_cl_device	*device;
-
-	if (!dev->driver)
-		return	0;
-
-	device = to_heci_cl_device(dev);
-	if (!uuid_le_cmp(device->fw_client->props.protocol_name, *uuid))
-		return	1;
-
-	return	0;
-}
-
-
-int	heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid)
-{
-	int	rv;
-
-	rv = bus_for_each_dev(&heci_cl_bus_type, NULL, uuid,
-		does_driver_bind_uuid);
-	return	!rv;
-}
-
-
-/* Binds connected heci_cl to HECI bus device */
-int	heci_cl_device_bind(struct heci_cl *cl)
-{
-	int	rv;
-	struct heci_cl_device	*cl_device, *next;
-	unsigned long flags;
-	if (!cl->me_client_id || cl->state != HECI_CL_CONNECTED)
-		return	-EFAULT;
-
-	rv = -ENOENT;
-	spin_lock_irqsave(&cl->dev->device_list_lock, flags);
-	list_for_each_entry_safe(cl_device, next, &cl->dev->device_list,
-			device_link) {
-		if (cl_device->fw_client->client_id == cl->me_client_id) {
-			cl->device = cl_device;
-			rv = 0;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&cl->dev->device_list_lock, flags);
-	return	rv;
-}
-
diff --git a/drivers/misc/heci/bus.h b/drivers/misc/heci/bus.h
deleted file mode 100644
index 2a39ec7..0000000
--- a/drivers/misc/heci/bus.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * HECI bus definitions
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-#ifndef _LINUX_HECI_CL_BUS_H
-#define _LINUX_HECI_CL_BUS_H
-
-#include <linux/device.h>
-#include <linux/uuid.h>
-
-/*typedef void (*heci_cl_event_cb_t)(struct heci_cl_device *device, u32 events,
-	void *context);*/
-
-struct heci_cl;
-struct heci_cl_device;
-struct heci_device;
-
-#define	HECI_CL_NAME_SIZE	32
-
-struct heci_cl_device_id {
-	char name[MEI_CL_NAME_SIZE];
-	kernel_ulong_t driver_info;
-};
-
-/**
- * struct heci_cl_dev_ops - HECI CL device ops
- * This structure allows ME host clients to implement technology
- * specific operations.
- *
- * @enable: Enable an HECI CL device. Some devices require specific
- *	HECI commands to initialize completely.
- * @disable: Disable an HECI CL device.
- * @send: Tx hook for the device. This allows ME host clients to trap
- *	the device driver buffers before actually physically
- *	pushing it to the ME.
- * @recv: Rx hook for the device. This allows ME host clients to trap the
- *	ME buffers before forwarding them to the device driver.
- */
-struct heci_cl_dev_ops {
-	int (*enable)(struct heci_cl_device *device);
-	int (*disable)(struct heci_cl_device *device);
-	int (*send)(struct heci_cl_device *device, u8 *buf, size_t length);
-	int (*recv)(struct heci_cl_device *device, u8 *buf, size_t length);
-};
-
-struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
-	uuid_le uuid, char *name, struct heci_cl_dev_ops *ops);
-void heci_bus_remove_device(struct heci_cl_device *device);
-
-/**
- * struct heci_cl_device - HECI device handle
- * An heci_cl_device pointer is returned from heci_add_device()
- * and links HECI bus clients to their actual ME host client pointer.
- * Drivers for HECI devices will get an heci_cl_device pointer
- * when being probed and shall use it for doing ME bus I/O.
- *
- * @dev: linux driver model device pointer
- * @uuid: me client uuid
- * @cl: heci client
- * @ops: ME transport ops
- * @event_cb: Drivers register this callback to get asynchronous ME
- *	events (e.g. Rx buffer pending) notifications.
- * @events: Events bitmask sent to the driver.
- * @priv_data: client private data
- */
-struct heci_cl_device {
-	struct device dev;
-	/*struct heci_cl *cl;*/
-	struct heci_device	*heci_dev;
-	struct heci_me_client	*fw_client;	/* For easy reference */
-	struct list_head	device_link;
-	const struct heci_cl_dev_ops *ops;
-	struct work_struct event_work;
-	void (*event_cb)(struct heci_cl_device *device, u32 events,
-		void *context);
-	void *event_context;
-	unsigned long events;
-	void *priv_data;
-};
-
-struct heci_cl_driver {
-	struct device_driver driver;
-	const char *name;
-	const struct heci_cl_device_id *id_table;
-	int (*probe)(struct heci_cl_device *dev,
-		const struct heci_cl_device_id *id);
-	int (*remove)(struct heci_cl_device *dev);
-};
-
-int __heci_cl_driver_register(struct heci_cl_driver *driver,
-	struct module *owner);
-#define heci_cl_driver_register(driver)             \
-	__heci_cl_driver_register(driver, THIS_MODULE)
-
-void heci_cl_driver_unregister(struct heci_cl_driver *driver);
-int heci_register_event_cb(struct heci_cl_device *device,
-	void (*read_cb)(struct heci_cl_device *, u32, void *), void *context);
-
-#define HECI_CL_EVENT_RX 0
-#define HECI_CL_EVENT_TX 1
-
-void *heci_cl_get_drvdata(const struct heci_cl_device *device);
-void heci_cl_set_drvdata(struct heci_cl_device *device, void *data);
-
-int heci_cl_enable_device(struct heci_cl_device *device);
-int heci_cl_disable_device(struct heci_cl_device *device);
-
-void heci_cl_bus_rx_event(struct heci_cl_device *device);
-int heci_cl_bus_init(void);
-void heci_cl_bus_exit(void);
-int	heci_bus_new_client(struct heci_device *dev);
-void	heci_remove_all_clients(struct heci_device *dev);
-int	heci_cl_device_bind(struct heci_cl *cl);
-
-#endif /* _LINUX_HECI_CL_BUS_H */
diff --git a/drivers/misc/heci/client.c b/drivers/misc/heci/client.c
deleted file mode 100644
index b9acd6e..0000000
--- a/drivers/misc/heci/client.c
+++ /dev/null
@@ -1,1243 +0,0 @@
-/*
- * HECI client logic (for both HECI bus driver and user-mode API)
- *
- * Copyright (c) 2003-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/export.h>
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/delay.h>
-#include <linux/pm_runtime.h>
-#include "heci_dev.h"
-#include "hbm.h"
-#include "client.h"
-#include "utils.h"
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-/* #define dev_dbg dev_err */
-
-int	host_dma_enabled;
-void	*host_dma_buf;
-unsigned	host_dma_buf_size = (1024*1024);
-uint64_t	host_dma_buf_phys;
-int	dma_ready = 1;
-
-
-void	heci_cl_alloc_dma_buf(void)
-{
-	int	order;
-	unsigned	temp;
-
-	/*
-	 * Try to allocate 256 contiguous pages (1 M)
-	 * for DMA and enabled host DMA
-	 */
-	for (order = 0, temp = host_dma_buf_size / PAGE_SIZE + 1; temp;
-			temp >>= 1)
-		++order;
-	host_dma_buf = (void *)__get_free_pages(GFP_KERNEL, order);
-	if (host_dma_buf) {
-		host_dma_buf_phys = __pa(host_dma_buf);
-		host_dma_enabled = 1;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): host_dma_enabled=%d host_dma_buf=%p host_dma_buf_phys=%llX host_dma_buf_size=%u order=%d\n",
-		__func__, host_dma_enabled, host_dma_buf, host_dma_buf_phys,
-		host_dma_buf_size, order);
-}
-
-
-/**
- * heci_read_list_flush - removes list entry belonging to cl.
- *
- * @list:  An instance of our list structure
- * @cl: host client
- */
-void heci_read_list_flush(struct heci_cl *cl)
-{
-	struct heci_cl_rb *rb;
-	struct heci_cl_rb *next;
-
-	unsigned long	flags;
-	spin_lock_irqsave(&cl->dev->read_list_spinlock, flags);
-	list_for_each_entry_safe(rb, next, &cl->dev->read_list.list, list) {
-		if (rb->cl && heci_cl_cmp_id(cl, rb->cl)) {
-			list_del(&rb->list);
-			heci_io_rb_free(rb);
-		}
-	}
-	spin_unlock_irqrestore(&cl->dev->read_list_spinlock, flags);
-}
-
-/**
- * heci_io_rb_free - free heci_rb_private related memory
- *
- * @rb: heci callback struct
- */
-void heci_io_rb_free(struct heci_cl_rb *rb)
-{
-	if (rb == NULL)
-		return;
-
-	kfree(rb->buffer.data);
-	kfree(rb);
-}
-EXPORT_SYMBOL(heci_io_rb_free);
-
-/**
- * heci_io_rb_init - allocate and initialize io callback
- *
- * @cl - heci client
- * @file: pointer to file structure
- *
- * returns heci_cl_rb pointer or NULL;
- */
-struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl)
-{
-	struct heci_cl_rb *rb;
-
-	rb = kzalloc(sizeof(struct heci_cl_rb), GFP_KERNEL);
-	if (!rb)
-		return NULL;
-
-	heci_io_list_init(rb);
-
-	rb->cl = cl;
-	rb->buf_idx = 0;
-	return rb;
-}
-
-
-/**
- * heci_io_rb_alloc_buf - allocate respose buffer
- *
- * @rb -  io callback structure
- * @size: size of the buffer
- *
- * returns 0 on success
- *         -EINVAL if rb is NULL
- *         -ENOMEM if allocation failed
- */
-int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length)
-{
-	if (!rb)
-		return -EINVAL;
-
-	if (length == 0)
-		return 0;
-
-	rb->buffer.data = kmalloc(length, GFP_KERNEL);
-	if (!rb->buffer.data)
-		return -ENOMEM;
-	rb->buffer.size = length;
-	return 0;
-}
-
-
-/*
- * heci_io_rb_recycle - re-append rb to its client's free list
- * and send flow control if needed
- */
-int heci_io_rb_recycle(struct heci_cl_rb *rb)
-{
-	struct heci_cl *cl;
-	int	rets = 0;
-	unsigned long	flags;
-
-	if (!rb || !rb->cl)
-		return	-EFAULT;
-
-	cl = rb->cl;
-
-	spin_lock_irqsave(&cl->free_list_spinlock, flags);
-	list_add_tail(&rb->list, &cl->free_rb_list.list);
-	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-
-	/*
-	 * If we returned the first buffer to empty 'free' list,
-	 * send flow control
-	 */
-	if (!cl->out_flow_ctrl_creds)
-		rets = heci_cl_read_start(cl);
-
-	return	rets;
-}
-EXPORT_SYMBOL(heci_io_rb_recycle);
-
-
-/**
- * heci_cl_flush_queues - flushes queue lists belonging to cl.
- *
- * @dev: the device structure
- * @cl: host client
- */
-int heci_cl_flush_queues(struct heci_cl *cl)
-{
-	if (WARN_ON(!cl || !cl->dev))
-		return -EINVAL;
-
-	dev_dbg(&cl->dev->pdev->dev, "remove list entry belonging to cl\n");
-	heci_read_list_flush(cl);
-
-	return 0;
-}
-EXPORT_SYMBOL(heci_cl_flush_queues);
-
-
-/**
- * heci_cl_init - initializes intialize cl.
- *
- * @cl: host client to be initialized
- * @dev: heci device
- */
-void heci_cl_init(struct heci_cl *cl, struct heci_device *dev)
-{
-	memset(cl, 0, sizeof(struct heci_cl));
-	init_waitqueue_head(&cl->wait);
-	init_waitqueue_head(&cl->rx_wait);
-	init_waitqueue_head(&cl->wait_ctrl_res);
-	spin_lock_init(&cl->free_list_spinlock);
-	spin_lock_init(&cl->in_process_spinlock);
-	spin_lock_init(&cl->tx_list_spinlock);
-	spin_lock_init(&cl->tx_free_list_spinlock);
-	spin_lock_init(&cl->fc_spinlock);
-	INIT_LIST_HEAD(&cl->link);
-	cl->dev = dev;
-
-	INIT_LIST_HEAD(&cl->free_rb_list.list);
-	INIT_LIST_HEAD(&cl->tx_list.list);
-	INIT_LIST_HEAD(&cl->tx_free_list.list);
-	INIT_LIST_HEAD(&cl->in_process_list.list);
-
-	cl->rx_ring_size = CL_DEF_RX_RING_SIZE;
-	cl->tx_ring_size = CL_DEF_TX_RING_SIZE;
-}
-
-int	heci_cl_free_rx_ring(struct heci_cl *cl)
-{
-	struct heci_cl_rb *rb;
-	unsigned long	flags;
-
-	/* relese allocated mem- pass over free_rb_list */
-	spin_lock_irqsave(&cl->free_list_spinlock, flags);
-	while (!list_empty(&cl->free_rb_list.list)) {
-		rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb,
-			list);
-		list_del(&rb->list);
-		kfree(rb->buffer.data);
-		kfree(rb);
-	}
-	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-	/* relese allocated mem- pass over in_process_list */
-	spin_lock_irqsave(&cl->in_process_spinlock, flags);
-	while (!list_empty(&cl->in_process_list.list)) {
-		rb = list_entry(cl->in_process_list.list.next,
-			struct heci_cl_rb, list);
-		list_del(&rb->list);
-		kfree(rb->buffer.data);
-		kfree(rb);
-	}
-	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
-	return	0;
-}
-
-int	heci_cl_free_tx_ring(struct heci_cl *cl)
-{
-	struct heci_cl_tx_ring  *tx_buf;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
-	/* relese allocated mem- pass over tx_free_list */
-	while (!list_empty(&cl->tx_free_list.list)) {
-		tx_buf = list_entry(cl->tx_free_list.list.next,
-			struct heci_cl_tx_ring, list);
-		list_del(&tx_buf->list);
-		kfree(tx_buf->send_buf.data);
-		kfree(tx_buf);
-	}
-	spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
-
-	spin_lock_irqsave(&cl->tx_list_spinlock, flags);
-	/* relese allocated mem- pass over tx_list */
-	while (!list_empty(&cl->tx_list.list)) {
-		tx_buf = list_entry(cl->tx_list.list.next,
-			struct heci_cl_tx_ring, list);
-		list_del(&tx_buf->list);
-		kfree(tx_buf->send_buf.data);
-		kfree(tx_buf);
-	}
-	spin_unlock_irqrestore(&cl->tx_list_spinlock, flags);
-
-	return	0;
-}
-
-int	heci_cl_alloc_rx_ring(struct heci_cl *cl)
-{
-	size_t	len = cl->device->fw_client->props.max_msg_length;
-	int	j;
-	struct heci_cl_rb *rb;
-	int	ret = 0;
-	struct heci_device *dev = cl->dev;
-	unsigned long	flags;
-
-	for (j = 0; j < cl->rx_ring_size; ++j) {
-		rb = heci_io_rb_init(cl);
-		if (!rb) {
-			ret = -ENOMEM;
-			goto out;
-		}
-		ret = heci_io_rb_alloc_buf(rb, len);
-		if (ret)
-			goto out;
-		spin_lock_irqsave(&cl->free_list_spinlock, flags);
-		list_add_tail(&rb->list, &cl->free_rb_list.list);
-		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
-		__func__);
-	return	0;
-
-out:
-	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n",
-		__func__);
-	heci_cl_free_rx_ring(cl);
-	return	ret;
-}
-
-
-int	heci_cl_alloc_tx_ring(struct heci_cl *cl)
-{
-	size_t	len = cl->device->fw_client->props.max_msg_length;
-	int	j;
-	struct heci_device *dev = cl->dev;
-	unsigned long	flags;
-
-	/*cl->send_fc_flag = 0;*/
-	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
-		__func__);
-
-	/* Allocate pool to free Tx bufs */
-	for (j = 0; j < cl->tx_ring_size; ++j) {
-		struct heci_cl_tx_ring	*tx_buf;
-
-		tx_buf = kmalloc(sizeof(struct heci_cl_tx_ring), GFP_KERNEL);
-		if (!tx_buf) {
-			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n",
-				__func__);
-			goto	out;
-		}
-		memset(tx_buf, 0, sizeof(struct heci_cl_tx_ring));
-		tx_buf->send_buf.data = kmalloc(len, GFP_KERNEL);
-		if (!tx_buf->send_buf.data) {
-			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n",
-				__func__);
-			kfree(tx_buf);
-			goto	out;
-		}
-		spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
-		list_add_tail(&tx_buf->list, &cl->tx_free_list.list);
-		spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
-	}
-	ISH_DBG_PRINT(KERN_ALERT "%s() allocated Tx  pool successfully\n",
-		__func__);
-
-	return	0;
-
-out:
-	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n",
-		__func__);
-	heci_cl_free_rx_ring(cl);
-	return	-ENOMEM;
-}
-
-
-/**
- * heci_cl_allocate - allocates cl  structure and sets it up.
- *
- * @dev: heci device
- * returns  The allocated file or NULL on failure
- */
-struct heci_cl *heci_cl_allocate(struct heci_device *dev)
-{
-	struct heci_cl *cl;
-
-	cl = kmalloc(sizeof(struct heci_cl), GFP_ATOMIC);
-	if (!cl)
-		return NULL;
-
-	heci_cl_init(cl, dev);
-	return cl;
-}
-EXPORT_SYMBOL(heci_cl_allocate);
-
-
-void	heci_cl_free(struct heci_cl *cl)
-{
-	if (!cl)
-		return;
-
-	heci_cl_free_rx_ring(cl);
-	heci_cl_free_tx_ring(cl);
-	kfree(cl);
-}
-EXPORT_SYMBOL(heci_cl_free);
-
-
-/**
- * heci_cl_find_read_rb - find this cl's callback in the read list
- *
- * @dev: device structure
- * returns rb on success, NULL on error
- */
-struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl)
-{
-	struct heci_device *dev = cl->dev;
-	struct heci_cl_rb *rb = NULL;
-	struct heci_cl_rb *next = NULL;
-	unsigned long     dev_flags;
-
-	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
-	list_for_each_entry_safe(rb, next, &dev->read_list.list, list)
-		if (heci_cl_cmp_id(cl, rb->cl)) {
-			spin_unlock_irqrestore(&dev->read_list_spinlock,
-				dev_flags);
-			return rb;
-		}
-	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
-	return NULL;
-}
-EXPORT_SYMBOL(heci_cl_find_read_rb);
-
-/** heci_cl_link: allocte host id in the host map
- *
- * @cl - host client
- * @id - fixed host id or -1 for genereting one
- * returns 0 on success
- *	-EINVAL on incorrect values
- *	-ENONET if client not found
- */
-int heci_cl_link(struct heci_cl *cl, int id)
-{
-	struct heci_device *dev;
-	unsigned long	flags, flags_cl;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -EINVAL;
-
-	dev = cl->dev;
-
-	spin_lock_irqsave(&dev->device_lock, flags);
-
-	if (dev->open_handle_count >= HECI_MAX_OPEN_HANDLE_COUNT) {
-		spin_unlock_irqrestore(&dev->device_lock, flags);
-		return	-EMFILE;
-	}
-
-	/* If Id is not asigned get one*/
-	if (id == HECI_HOST_CLIENT_ID_ANY)
-		id = find_first_zero_bit(dev->host_clients_map,
-			HECI_CLIENTS_MAX);
-
-	if (id >= HECI_CLIENTS_MAX) {
-		spin_unlock_irqrestore(&dev->device_lock, flags);
-		dev_err(&dev->pdev->dev, "id exceded %d", HECI_CLIENTS_MAX);
-		return -ENOENT;
-	}
-
-	dev->open_handle_count++;
-	cl->host_client_id = id;
-	spin_lock_irqsave(&dev->cl_list_lock, flags_cl);
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
-		spin_unlock_irqrestore(&dev->device_lock, flags);
-		return -ENODEV;
-	}
-	list_add_tail(&cl->link, &dev->cl_list);
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
-	set_bit(id, dev->host_clients_map);
-	cl->state = HECI_CL_INITIALIZING;
-	spin_unlock_irqrestore(&dev->device_lock, flags);
-
-	dev_dbg(&dev->pdev->dev, "link cl host id = %d\n", cl->host_client_id);
-
-	return 0;
-}
-EXPORT_SYMBOL(heci_cl_link);
-
-/**
- * heci_cl_unlink - remove me_cl from the list
- *
- * @dev: the device structure
- */
-int heci_cl_unlink(struct heci_cl *cl)
-{
-	struct heci_device *dev;
-	struct heci_cl *pos, *next;
-	unsigned long	flags;
-
-	/* don't shout on error exit path */
-	if (!cl || !cl->dev)
-		return 0;
-
-	dev = cl->dev;
-
-	spin_lock_irqsave(&dev->device_lock, flags);
-	if (dev->open_handle_count > 0) {
-		clear_bit(cl->host_client_id, dev->host_clients_map);
-		dev->open_handle_count--;
-	}
-	spin_unlock_irqrestore(&dev->device_lock, flags);
-
-	/*
-	 * This checks that 'cl' is actually linked into device's structure,
-	 * before attempting 'list_del'
-	 */
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
-		if (cl->host_client_id == pos->host_client_id) {
-			list_del_init(&pos->link);
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(heci_cl_unlink);
-
-
-/**
- * heci_cl_disconnect - disconnect host clinet form the me one
- *
- * @cl: host client
- *
- * Locking: called under "dev->device_lock" lock
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_cl_disconnect(struct heci_cl *cl)
-{
-	struct heci_device *dev;
-	int rets, err;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	if (cl->state != HECI_CL_DISCONNECTING)
-		return 0;
-
-	rets = pm_runtime_get_sync(&dev->pdev->dev);
-	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
-	if (IS_ERR_VALUE(rets)) {
-		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
-		return rets;
-	}
-
-	if (heci_hbm_cl_disconnect_req(dev, cl)) {
-		rets = -ENODEV;
-		dev_err(&dev->pdev->dev, "failed to disconnect.\n");
-		goto free;
-	}
-
-	err = wait_event_timeout(cl->wait_ctrl_res,
-			(dev->dev_state != HECI_DEV_ENABLED ||
-			HECI_CL_DISCONNECTED == cl->state),
-			heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT));
-
-	/*
-	 * If FW reset arrived, this will happen. Don't check cl->,
-	 * as 'cl' may be freed already
-	 */
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto	free;
-	}
-
-	if (HECI_CL_DISCONNECTED == cl->state) {
-		rets = 0;
-		dev_dbg(&dev->pdev->dev, "successfully disconnected from FW client.\n");
-	} else {
-		rets = -ENODEV;
-		if (HECI_CL_DISCONNECTED != cl->state)
-			dev_dbg(&dev->pdev->dev, "wrong status client disconnect.\n");
-
-		if (err)
-			dev_dbg(&dev->pdev->dev,
-				"wait failed disconnect err=%08x\n", err);
-
-		dev_dbg(&dev->pdev->dev, "failed to disconnect from FW client.\n");
-	}
-
-free:
-	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
-
-	return rets;
-}
-EXPORT_SYMBOL(heci_cl_disconnect);
-
-
-/**
- * heci_cl_is_other_connecting - checks if other
- *    client with the same me client id is connecting
- *
- * @cl: private data of the file object
- *
- * returns ture if other client is connected, 0 - otherwise.
- */
-bool heci_cl_is_other_connecting(struct heci_cl *cl)
-{
-	struct heci_device *dev;
-	struct heci_cl *pos;
-	struct heci_cl *next;
-	unsigned long	flags;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return false;
-
-	dev = cl->dev;
-
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
-		if ((pos->state == HECI_CL_CONNECTING) && (pos != cl) &&
-				cl->me_client_id == pos->me_client_id) {
-			spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-			return true;
-		}
-
-	}
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-
-	return false;
-}
-
-/**
- * heci_cl_connect - connect host clinet to the me one
- *
- * @cl: host client
- *
- * Locking: called under "dev->device_lock" lock
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_cl_connect(struct heci_cl *cl)
-{
-	struct heci_device *dev;
-	long timeout = heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT);
-	int rets;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	if (heci_cl_is_other_connecting(cl))
-		return	-EBUSY;
-
-	dev = cl->dev;
-
-	rets = pm_runtime_get_sync(&dev->pdev->dev);
-	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
-	if (IS_ERR_VALUE(rets)) {
-		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
-		return rets;
-	}
-
-	if (heci_hbm_cl_connect_req(dev, cl)) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-	rets = wait_event_timeout(cl->wait_ctrl_res,
-				(dev->dev_state == HECI_DEV_ENABLED &&
-				 (cl->state == HECI_CL_CONNECTED ||
-				  cl->state == HECI_CL_DISCONNECTED)),
-				 timeout * HZ);
-
-	/*
-	 * If FW reset arrived, this will happen. Don't check cl->,
-	 * as 'cl' may be freed already
-	 */
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -EFAULT;
-		goto	out;
-	}
-
-	if (cl->state != HECI_CL_CONNECTED) {
-		rets = -EFAULT;
-		goto out;
-	}
-
-	rets = cl->status;
-	if (rets)
-		goto	out;
-
-	rets = heci_cl_device_bind(cl);
-	if (rets) {
-		heci_cl_disconnect(cl);
-		goto    out;
-	}
-
-	rets = heci_cl_alloc_rx_ring(cl);
-	if (rets) {
-		/* if failed allocation, disconnect */
-		heci_cl_disconnect(cl);
-		goto	out;
-	}
-
-	rets = heci_cl_alloc_tx_ring(cl);
-	if (rets) {
-		/* if failed allocation, disconnect */
-		heci_cl_free_rx_ring(cl);
-		heci_cl_disconnect(cl);
-		goto	out;
-	}
-
-	/* Upon successful connection and allocation, emit flow-control */
-	rets = heci_cl_read_start(cl);
-out:
-	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
-
-	return rets;
-}
-EXPORT_SYMBOL(heci_cl_connect);
-
-/**
- * heci_cl_read_start - the start read client message function.
- *
- * @cl: host client
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_cl_read_start(struct heci_cl *cl)
-{
-	struct heci_device *dev;
-	struct heci_cl_rb *rb;
-	int rets;
-	int i;
-	unsigned long	flags;
-	unsigned long	dev_flags;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	if (cl->state != HECI_CL_CONNECTED)
-		return -ENODEV;
-
-	if (dev->dev_state != HECI_DEV_ENABLED)
-		return -ENODEV;
-
-/*
-	if (cl->read_rb) {
-		dev_dbg(&dev->pdev->dev, "read is pending.\n");
-		return -EBUSY;
-	}
-*/
-	i = heci_me_cl_by_id(dev, cl->me_client_id);
-	if (i < 0) {
-		dev_err(&dev->pdev->dev, "no such me client %d\n",
-			cl->me_client_id);
-		return  -ENODEV;
-	}
-
-	rets = pm_runtime_get_sync(&dev->pdev->dev);
-	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
-	if (IS_ERR_VALUE(rets)) {
-		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
-		return rets;
-	}
-
-	/* The current rb is the head of the free rb list */
-	spin_lock_irqsave(&cl->free_list_spinlock, flags);
-	if (list_empty(&cl->free_rb_list.list)) {
-		dev_warn(&dev->pdev->dev, "[heci-ish] rb pool is empty\n");
-		rets = -ENOMEM;
-		rb = NULL;
-		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-		goto out;
-	}
-	rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb, list);
-	list_del_init(&rb->list);
-	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-	/***************/
-	rb->cl = cl;
-	rb->buf_idx = 0;
-	/***************/
-
-	heci_io_list_init(rb);
-	rets = 0;
-
-	/*cl->read_rb = rb;*/
-
-	/*
-	 * This must be BEFORE sending flow control -
-	 * response in ISR may come too fast...
-	 */
-	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
-	list_add_tail(&rb->list, &dev->read_list.list);
-	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
-	if (heci_hbm_cl_flow_control_req(dev, cl)) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-out:
-	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
-	pm_runtime_mark_last_busy(&dev->pdev->dev);
-	pm_runtime_put_autosuspend(&dev->pdev->dev);
-
-	/* heci_hbm_cl_flow_control_req failed, return rb to free list */
-	if (rets && rb) {
-		spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
-		list_del(&rb->list);
-		spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
-
-		spin_lock_irqsave(&cl->free_list_spinlock, flags);
-		list_add_tail(&rb->list, &cl->free_rb_list.list);
-		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
-	}
-
-	return rets;
-}
-EXPORT_SYMBOL(heci_cl_read_start);
-
-
-int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
-{
-	struct heci_device *dev;
-	int id;
-	struct heci_cl_tx_ring  *cl_msg;
-	int	have_msg_to_send = 0;
-	unsigned long	me_flags, tx_flags, tx_free_flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	if (cl->state != HECI_CL_CONNECTED) {
-		++cl->err_send_msg;
-		return -EPIPE;
-	}
-
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		++cl->err_send_msg;
-		return -ENODEV;
-	}
-
-	/* Check if we have an ME client device */
-	id = heci_me_cl_by_id(dev, cl->me_client_id);
-	if (id < 0) {
-		++cl->err_send_msg;
-		return -ENOENT;
-	}
-
-	spin_lock_irqsave(&dev->me_clients_lock, me_flags);
-	if (length > dev->me_clients[id].props.max_msg_length) {
-		/* If the client supports DMA, try to use it */
-		if (host_dma_enabled && dev->me_clients[id].props.dma_hdr_len &
-				HECI_CLIENT_DMA_ENABLED) {
-			struct heci_msg_hdr	hdr;
-			struct hbm_client_dma_request	heci_dma_request_msg;
-			unsigned len = sizeof(struct hbm_client_dma_request);
-			int	preview_len =
-				dev->me_clients[id].props.dma_hdr_len & 0x7F;
-			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
-			/* DMA max msg size is 1M */
-			if (length > host_dma_buf_size) {
-				++cl->err_send_msg;
-				return	-EMSGSIZE;
-			}
-
-			/*
-			 * Client for some reason specified
-			 * props.dma_hdr_len > 12, mistake?
-			 */
-			if (preview_len > 12) {
-				++cl->err_send_msg;
-				return	-EINVAL;
-			}
-
-			/*If previous DMA transfer is in progress, go to sleep*/
-			wait_event_timeout(dev->wait_dma_ready, dma_ready,
-				10 * HZ);
-			dma_ready = 0;
-			/*
-			 * First 'preview_len' bytes of buffer are preview
-			 * bytes, omitted from DMA message
-			 */
-			memcpy(host_dma_buf, buf + preview_len,
-				length - preview_len);
-			heci_hbm_hdr(&hdr, len);
-			heci_dma_request_msg.hbm_cmd = CLIENT_DMA_REQ_CMD;
-			heci_dma_request_msg.me_addr = cl->me_client_id;
-			heci_dma_request_msg.host_addr = cl->host_client_id;
-			heci_dma_request_msg.reserved = 0;
-			heci_dma_request_msg.msg_addr = host_dma_buf_phys;
-			heci_dma_request_msg.msg_len = length - preview_len;
-			heci_dma_request_msg.reserved2 = 0;
-			memcpy(heci_dma_request_msg.msg_preview, buf,
-				preview_len);
-			heci_write_message(dev, &hdr,
-				(uint8_t *)&heci_dma_request_msg);
-			return 0;
-		} else {
-			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
-			++cl->err_send_msg;
-			return -EINVAL;		/* -EMSGSIZE? */
-		}
-	} else {
-		spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
-	}
-
-	/* No free bufs */
-	spin_lock_irqsave(&cl->tx_free_list_spinlock, tx_free_flags);
-	if (list_empty(&cl->tx_free_list.list)) {
-		spin_unlock_irqrestore(&cl->tx_free_list_spinlock,
-			tx_free_flags);
-		++cl->err_send_msg;
-		return	-ENOMEM;
-	}
-
-	cl_msg = list_first_entry(&cl->tx_free_list.list,
-		struct heci_cl_tx_ring, list);
-	if (!cl_msg->send_buf.data)
-		return	-EIO;		/* Should not happen,
-					as free list is pre-allocated */
-	++cl->send_msg_cnt;
-	/*
-	 * This is safe, as 'length' is already checked for not exceeding max.
-	 * HECI message size per client
-	 */
-	list_del_init(&cl_msg->list);
-	spin_unlock_irqrestore(&cl->tx_free_list_spinlock, tx_free_flags);
-	memcpy(cl_msg->send_buf.data, buf, length);
-	cl_msg->send_buf.size = length;
-	spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
-	have_msg_to_send = !list_empty(&cl->tx_list.list);
-	list_add_tail(&cl_msg->list, &cl->tx_list.list);
-	spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
-
-	if (!have_msg_to_send && cl->heci_flow_ctrl_creds > 0)
-		heci_cl_send_msg(dev, cl);
-
-	return	0;
-}
-EXPORT_SYMBOL(heci_cl_send);
-
-
-/**
- * heci_cl_read_complete - processes completed operation for a client
- *
- * @cl: private data of the file object.
- * @rb: callback block.
- */
-void heci_cl_read_complete(struct heci_cl_rb *rb)
-{
-	unsigned long	flags;
-	int	schedule_work_flag = 0;
-	struct heci_cl	*cl = rb->cl;
-
-	if (waitqueue_active(&cl->rx_wait)) {
-		cl->read_rb = rb;
-		wake_up_interruptible(&cl->rx_wait);
-	} else {
-		spin_lock_irqsave(&cl->in_process_spinlock, flags);
-		/*
-		 * if in-process list is empty, then need to schedule
-		 * the processing thread
-		 */
-		schedule_work_flag = list_empty(&cl->in_process_list.list);
-		list_add_tail(&rb->list, &cl->in_process_list.list);
-		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
-
-		if (schedule_work_flag)
-			heci_cl_bus_rx_event(cl->device);
-	}
-}
-EXPORT_SYMBOL(heci_cl_read_complete);
-
-
-/**
- * heci_cl_all_disconnect - disconnect forcefully all connected clients
- *
- * @dev - heci device
- */
-void heci_cl_all_disconnect(struct heci_device *dev)
-{
-	struct heci_cl *cl, *next;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		cl->state = HECI_CL_DISCONNECTED;
-		cl->heci_flow_ctrl_creds = 0;
-		cl->read_rb = NULL;
-	}
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-}
-
-
-/**
- * heci_cl_all_read_wakeup  - wake up all readings so they can be interrupted
- *
- * @dev  - heci device
- */
-void heci_cl_all_read_wakeup(struct heci_device *dev)
-{
-	struct heci_cl *cl, *next;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (waitqueue_active(&cl->rx_wait)) {
-			dev_dbg(&dev->pdev->dev, "Waking up client!\n");
-			wake_up_interruptible(&cl->rx_wait);
-		}
-	}
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-}
-
-/*##################################*/
-
-static void	ipc_tx_callback(void *prm)
-{
-	struct heci_cl	*cl = prm;
-	struct heci_cl_tx_ring	*cl_msg;
-	size_t	rem;
-	struct heci_device	*dev = (cl ? cl->dev : NULL);
-	struct heci_msg_hdr	heci_hdr;
-	unsigned long	flags, tx_flags, tx_free_flags;
-	unsigned char	*pmsg;
-
-	if (!dev)
-		return;
-
-	/*
-	 * FIXME: there may be other conditions if some critical error has
-	 * ocurred before this callback is called
-	 */
-	spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
-	if (list_empty(&cl->tx_list.list)) {
-		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
-		return;
-	}
-
-	/* Last call check for fc credits */
-	if (cl->heci_flow_ctrl_creds != 1 && !cl->sending) {
-		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
-		return;
-	}
-
-	if (!cl->sending) {
-		--cl->heci_flow_ctrl_creds;
-		cl->sending = 1;
-	}
-
-	cl_msg = list_entry(cl->tx_list.list.next, struct heci_cl_tx_ring,
-		list);
-	rem = cl_msg->send_buf.size - cl->tx_offs;
-
-	heci_hdr.host_addr = cl->host_client_id;
-	heci_hdr.me_addr = cl->me_client_id;
-	heci_hdr.reserved = 0;
-	pmsg = cl_msg->send_buf.data + cl->tx_offs;
-
-	if (rem <= dev->mtu) {
-		heci_hdr.length = rem;
-		heci_hdr.msg_complete = 1;
-		cl->sending = 0;
-		list_del_init(&cl_msg->list);	/* Must be before write */
-		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
-		/* Submit to IPC queue with no callback */
-		heci_write_message(dev, &heci_hdr, pmsg);
-		spin_lock_irqsave(&cl->tx_free_list_spinlock, tx_free_flags);
-		list_add_tail(&cl_msg->list, &cl->tx_free_list.list);
-		spin_unlock_irqrestore(&cl->tx_free_list_spinlock,
-			tx_free_flags);
-	} else {
-		/* FIXME: Send IPC fragment */
-		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
-		cl->tx_offs += dev->mtu;
-		heci_hdr.length = dev->mtu;
-		heci_hdr.msg_complete = 0;
-		dev->ops->write_ex(dev, &heci_hdr, pmsg, ipc_tx_callback, cl);
-	}
-}
-
-
-void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl)
-{
-	cl->tx_offs = 0;
-	ipc_tx_callback(cl);
-}
-EXPORT_SYMBOL(heci_cl_send_msg);
-/*##################################*/
-
-
-/*
- *	Receive and dispatch HECI client messages
- *
- *	(!) ISR context
- */
-void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
-{
-	struct heci_cl *cl;
-	struct heci_cl_rb *rb, *next;
-	struct heci_cl_rb *new_rb;
-	unsigned char *buffer = NULL;
-	struct heci_cl_rb *complete_rb = NULL;
-	unsigned long	dev_flags;
-	unsigned long	flags;
-	int	rb_count;
-
-
-	if (heci_hdr->reserved) {
-		dev_err(&dev->pdev->dev, "corrupted message header.\n");
-		goto	eoi;
-	}
-
-	if (heci_hdr->length > IPC_PAYLOAD_SIZE) {
-		dev_err(&dev->pdev->dev, "HECI message length in hdr is too big for IPC MTU. Broken message\n");
-		goto	eoi;
-	}
-
-	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
-	rb_count = -1;
-	list_for_each_entry_safe(rb, next, &dev->read_list.list, list) {
-		++rb_count;
-		cl = rb->cl;
-		if (!cl || !(cl->host_client_id == heci_hdr->host_addr &&
-				cl->me_client_id == heci_hdr->me_addr) ||
-				!(cl->state == HECI_CL_CONNECTED))
-			continue;
-
-		/*
-		 * FIXME: in both if() closes rb must return to free pool
-		 * and/or disband and/or disconnect client
-		 */
-		if (rb->buffer.size == 0 || rb->buffer.data == NULL) {
-			spin_unlock_irqrestore(&dev->read_list_spinlock,
-				dev_flags);
-			dev_err(&dev->pdev->dev, "response buffer is not allocated.\n");
-			list_del(&rb->list);
-			goto	eoi;
-		}
-
-		if (rb->buffer.size < heci_hdr->length + rb->buf_idx) {
-			spin_unlock_irqrestore(&dev->read_list_spinlock,
-				dev_flags);
-			dev_err(&dev->pdev->dev, "message overflow. size %d len %d idx %ld\n",
-				rb->buffer.size, heci_hdr->length, rb->buf_idx);
-			list_del(&rb->list);
-			goto	eoi;
-		}
-
-		buffer = rb->buffer.data + rb->buf_idx;
-		dev->ops->read(dev, buffer, heci_hdr->length);
-
-		/* Debug HID client */
-		if (cl->host_client_id == 3 && cl->me_client_id == 5)
-			dev->ipc_hid_in_msg = 1;
-
-		rb->buf_idx += heci_hdr->length;
-		if (heci_hdr->msg_complete) {
-			/* Last fragment in message - it's complete */
-			cl->status = 0;
-			list_del(&rb->list);
-			complete_rb = rb;
-
-			/* Debug HID client */
-			if (cl->host_client_id == 3 && cl->me_client_id == 5) {
-				dev->ipc_hid_in_msg = 0;
-				--dev->ipc_hid_out_fc;
-			}
-
-			--cl->out_flow_ctrl_creds;
-			/*
-			 * the whole msg arrived, send a new FC, and add a new
-			 * rb buffer for the next coming msg
-			 */
-			spin_lock_irqsave(&cl->free_list_spinlock, flags);
-
-			if (!list_empty(&cl->free_rb_list.list)) {
-				new_rb = list_entry(cl->free_rb_list.list.next,
-					struct heci_cl_rb, list);
-				list_del_init(&new_rb->list);
-				spin_unlock_irqrestore(&cl->free_list_spinlock,
-					flags);
-				new_rb->cl = cl;
-				new_rb->buf_idx = 0;
-				INIT_LIST_HEAD(&new_rb->list);
-				list_add_tail(&new_rb->list,
-					&dev->read_list.list);
-
-				heci_hbm_cl_flow_control_req(dev, cl);
-			} else {
-				/*cl->send_fc_flag = 1;*/
-				spin_unlock_irqrestore(&cl->free_list_spinlock,
-					flags);
-			}
-		}
-		/* One more fragment in message (even if this was last) */
-		++cl->recv_msg_num_frags;
-
-		/*
-		 * We can safely break here (and in BH too),
-		 * a single input message can go only to a single request!
-		 */
-		break;
-	}
-
-	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
-	/* If it's nobody's message, just read and discard it */
-	if (!buffer) {
-		uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
-
-		dev_err(&dev->pdev->dev, "%s(): Dropped msg - no request\n",
-			__func__);
-		dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
-		goto	eoi;
-	}
-
-	/* Looks like this is interrupt-safe */
-	if (complete_rb) {
-		struct timeval	tv;
-		do_gettimeofday(&tv);
-		cl->rx_sec = tv.tv_sec;
-		cl->rx_usec = tv.tv_usec;
-		++cl->recv_msg_cnt;
-		heci_cl_read_complete(complete_rb);
-	}
-
-eoi:
-	return;
-}
-EXPORT_SYMBOL(recv_heci_cl_msg);
-
diff --git a/drivers/misc/heci/client.h b/drivers/misc/heci/client.h
deleted file mode 100644
index 8614020..0000000
--- a/drivers/misc/heci/client.h
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * HECI client logic
- *
- * Copyright (c) 2003-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef _HECI_CLIENT_H_
-#define _HECI_CLIENT_H_
-
-#include <linux/types.h>
-#include <linux/watchdog.h>
-#include <linux/poll.h>
-#include "heci_dev.h"
-
-/* Client state */
-enum cl_state {
-	HECI_CL_INITIALIZING = 0,
-	HECI_CL_CONNECTING,
-	HECI_CL_CONNECTED,
-	HECI_CL_DISCONNECTING,
-	HECI_CL_DISCONNECTED
-};
-
-#define	CL_DEF_RX_RING_SIZE	2
-#define	CL_DEF_TX_RING_SIZE	2
-#define	CL_MAX_RX_RING_SIZE	32
-#define	CL_MAX_TX_RING_SIZE	32
-
-/* Client Tx  buffer list entry */
-struct heci_cl_tx_ring {
-	struct list_head list;
-	struct heci_msg_data	send_buf;
-};
-
-/* HECI client instance carried as file->pirvate_data*/
-struct heci_cl {
-	struct list_head link;
-	struct heci_device *dev;
-	enum cl_state state;
-	wait_queue_head_t rx_wait;
-	wait_queue_head_t wait;
-	int status;
-	/* ID of client connected */
-	u8 host_client_id;
-	u8 me_client_id;
-	u8 heci_flow_ctrl_creds;
-	u8 out_flow_ctrl_creds;
-	struct heci_cl_rb *read_rb;
-
-	/* Link to HECI bus device */
-	struct heci_cl_device *device;
-
-	/* Rx ring buffer pool */
-	unsigned	rx_ring_size;
-	struct heci_cl_rb	free_rb_list;
-	/*int     send_fc_flag;*/
-	spinlock_t      free_list_spinlock;
-	/* Rx in-process list */
-	struct heci_cl_rb       in_process_list;
-	spinlock_t      in_process_spinlock;
-
-	/* Client Tx buffers list */
-	unsigned	tx_ring_size;
-	struct heci_cl_tx_ring	tx_list, tx_free_list;
-	spinlock_t      tx_list_spinlock;
-	spinlock_t      tx_free_list_spinlock;
-	size_t	tx_offs;	/* Offset in buffer at head of 'tx_list' */
-	/*#############################*/
-	/* if we get a FC, and the list is not empty, we must know whether we
-	 * are at the middle of sending.
-	 * if so - need to increase FC counter, otherwise, need to start sending
-	 * the first msg in list
-	 * (!) This is for counting-FC implementation only. Within single-FC the
-	 * other party may NOT send FC until it receives complete message
-	 */
-	int sending;
-	/*#############################*/
-
-	/* Send FC spinlock */
-	spinlock_t      fc_spinlock;
-
-	/* wait queue for connect and disconnect response from FW */
-	wait_queue_head_t wait_ctrl_res;
-
-	/* Error stats */
-	unsigned	err_send_msg;
-	unsigned	err_send_fc;
-
-	/* Send/recv stats */
-	unsigned	send_msg_cnt;
-	unsigned	recv_msg_cnt;
-	unsigned	recv_msg_num_frags;
-	unsigned	heci_flow_ctrl_cnt;
-	unsigned	out_flow_ctrl_cnt;
-
-	/* Rx msg ... out FC timing */
-	unsigned long	rx_sec, rx_usec;
-	unsigned long	out_fc_sec, out_fc_usec;
-	unsigned long	max_fc_delay_sec, max_fc_delay_usec;
-};
-
-extern int	dma_ready;
-extern int	host_dma_enabled;
-
-int heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid);
-int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *cuuid);
-int heci_me_cl_by_id(struct heci_device *dev, u8 client_id);
-
-/*
- * HECI IO Functions
- */
-struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl);
-void heci_io_rb_free(struct heci_cl_rb *priv_rb);
-int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length);
-int heci_io_rb_recycle(struct heci_cl_rb *rb);
-
-
-/**
- * heci_io_list_init - Sets up a queue list.
- *
- * @list: An instance cl callback structure
- */
-static inline void heci_io_list_init(struct heci_cl_rb *list)
-{
-	INIT_LIST_HEAD(&list->list);
-}
-void heci_read_list_flush(struct heci_cl *cl);
-
-/*
- * HECI Host Client Functions
- */
-
-struct heci_cl *heci_cl_allocate(struct heci_device *dev);
-void heci_cl_init(struct heci_cl *cl, struct heci_device *dev);
-void	heci_cl_free(struct heci_cl *cl);
-
-int	heci_cl_alloc_rx_ring(struct heci_cl *cl);
-int	heci_cl_alloc_tx_ring(struct heci_cl *cl);
-int	heci_cl_free_rx_ring(struct heci_cl *cl);
-int	heci_cl_free_tx_ring(struct heci_cl *cl);
-
-int heci_cl_link(struct heci_cl *cl, int id);
-int heci_cl_unlink(struct heci_cl *cl);
-
-int heci_cl_flush_queues(struct heci_cl *cl);
-struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl);
-
-/**
- * heci_cl_cmp_id - tells if file private data have same id
- *
- * @fe1: private data of 1. file object
- * @fe2: private data of 2. file object
- *
- * returns true  - if ids are the same and not NULL
- */
-static inline bool heci_cl_cmp_id(const struct heci_cl *cl1,
-				const struct heci_cl *cl2)
-{
-	return cl1 && cl2 &&
-		(cl1->host_client_id == cl2->host_client_id) &&
-		(cl1->me_client_id == cl2->me_client_id);
-}
-
-
-int heci_cl_flow_ctrl_creds(struct heci_cl *cl);
-
-/*
- *  HECI input output function prototype
- */
-bool heci_cl_is_other_connecting(struct heci_cl *cl);
-int heci_cl_disconnect(struct heci_cl *cl);
-int heci_cl_connect(struct heci_cl *cl);
-int heci_cl_read_start(struct heci_cl *cl);
-int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length);
-void heci_cl_read_complete(struct heci_cl_rb *rb);
-void heci_cl_all_disconnect(struct heci_device *dev);
-void heci_cl_all_read_wakeup(struct heci_device *dev);
-void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl);
-void heci_cl_alloc_dma_buf(void);
-void recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
-
-#endif /* _HECI_CLIENT_H_ */
-
diff --git a/drivers/misc/heci/debugfs.c b/drivers/misc/heci/debugfs.c
deleted file mode 100644
index 1160d4f..0000000
--- a/drivers/misc/heci/debugfs.c
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * DebugFS for HECI driver
- *
- * Copyright (c) 2012-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-#include <linux/slab.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/debugfs.h>
-#include <linux/pci.h>
-#include "heci_dev.h"
-
-static ssize_t heci_dbgfs_read_meclients(struct file *fp, char __user *ubuf,
-					size_t cnt, loff_t *ppos)
-{
-	struct heci_device *dev = fp->private_data;
-	struct heci_me_client *cl;
-	const size_t bufsz = 1024;
-	char *buf = kzalloc(bufsz, GFP_KERNEL);
-	int i;
-	int pos = 0;
-	int ret;
-	unsigned long	flags;
-	if  (!buf)
-		return -ENOMEM;
-
-	pos += scnprintf(buf + pos, bufsz - pos,
-			"  |id|addr|         UUID                       |con|msg len|\n");
-
-	/*  if the driver is not enabled the list won't b consitent */
-	if (dev->dev_state != HECI_DEV_ENABLED)
-		goto out;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	for (i = 0; i < dev->me_clients_num; i++) {
-		cl = &dev->me_clients[i];
-		/* skip me clients that cannot be connected */
-		if (cl->props.max_number_of_connections == 0)
-			continue;
-
-		pos += scnprintf(buf + pos, bufsz - pos,
-			"%2d|%2d|%4d|%pUl|%3d|%7d|\n",
-			i, cl->client_id,
-			cl->props.fixed_address,
-			&cl->props.protocol_name,
-			cl->props.max_number_of_connections,
-			cl->props.max_msg_length);
-	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-out:
-	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
-	kfree(buf);
-	return ret;
-}
-
-static const struct file_operations heci_dbgfs_fops_meclients = {
-	.open = simple_open,
-	.read = heci_dbgfs_read_meclients,
-	.llseek = generic_file_llseek,
-};
-
-static ssize_t heci_dbgfs_read_devstate(struct file *fp, char __user *ubuf,
-					size_t cnt, loff_t *ppos)
-{
-	struct heci_device *dev = fp->private_data;
-	const size_t bufsz = 1024;
-	char *buf = kzalloc(bufsz, GFP_KERNEL);
-	int pos = 0;
-	int ret;
-
-	if  (!buf)
-		return -ENOMEM;
-
-	pos += scnprintf(buf + pos, bufsz - pos, "%s\n",
-			heci_dev_state_str(dev->dev_state));
-	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
-	kfree(buf);
-	return ret;
-}
-static const struct file_operations heci_dbgfs_fops_devstate = {
-	.open = simple_open,
-	.read = heci_dbgfs_read_devstate,
-	.llseek = generic_file_llseek,
-};
-
-/**
- * heci_dbgfs_deregister - Remove the debugfs files and directories
- * @heci - pointer to heci device private dat
- */
-void heci_dbgfs_deregister(struct heci_device *dev)
-{
-	if (!dev->dbgfs_dir)
-		return;
-	debugfs_remove_recursive(dev->dbgfs_dir);
-	dev->dbgfs_dir = NULL;
-}
-
-/**
- * Add the debugfs files
- *
- */
-int heci_dbgfs_register(struct heci_device *dev, const char *name)
-{
-	struct dentry *dir, *f;
-	dir = debugfs_create_dir(name, NULL);
-	if (!dir)
-		return -ENOMEM;
-
-	f = debugfs_create_file("meclients", S_IRUSR, dir,
-				dev, &heci_dbgfs_fops_meclients);
-	if (!f) {
-		dev_err(&dev->pdev->dev, "meclients: registration failed\n");
-		goto err;
-	}
-	f = debugfs_create_file("devstate", S_IRUSR, dir,
-				dev, &heci_dbgfs_fops_devstate);
-	if (!f) {
-		dev_err(&dev->pdev->dev, "devstate: registration failed\n");
-		goto err;
-	}
-	dev->dbgfs_dir = dir;
-	return 0;
-err:
-	heci_dbgfs_deregister(dev);
-	return -ENODEV;
-}
-
diff --git a/drivers/misc/heci/hbm.c b/drivers/misc/heci/hbm.c
deleted file mode 100644
index 67680aa..0000000
--- a/drivers/misc/heci/hbm.c
+++ /dev/null
@@ -1,927 +0,0 @@
-/*
- * HECI bus layer messages handling
- *
- * Copyright (c) 2003-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- */
-
-#include <linux/export.h>
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include "heci_dev.h"
-#include "hbm.h"
-#include "client.h"
-#include <linux/spinlock.h>
-/*
-#define	DEBUG_FW_BOOT_SEQ	1
-#define	DUMP_CL_PROP	1
-*/
-
-#ifdef DEBUG_FW_BOOT_SEQ
-unsigned char	static_fw_cl_props[6][32] = {
-
-{0x85, 0x01, 0x00, 0x00, 0x3B, 0x79, 0x63, 0xD9, 0xCF, 0x61, 0x8E, 0x4F, 0x8C,
-	0x02, 0xF2, 0xF7, 0xD0, 0x7F, 0x8E, 0x84, 0x01, 0x01, 0x00, 0x00, 0x00,
-	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x02, 0x00, 0x00, 0xB9, 0x78, 0xCC, 0xC1, 0x93, 0xB6, 0x54, 0x4E, 0x91,
-	0x91, 0x51, 0x69, 0xCB, 0x02, 0x7C, 0x25, 0x01, 0x01, 0x00, 0x00, 0x04,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x03, 0x00, 0x00, 0x26, 0x06, 0x05, 0x1F, 0x05, 0xD5, 0x94, 0x4E, 0xB1,
-	0x89, 0x53, 0x5D, 0x7D, 0xE1, 0x9C, 0xF2, 0x01, 0x01, 0x00, 0x00, 0x34,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x04, 0x00, 0x00, 0x54, 0x6C, 0x53, 0x28, 0x99, 0xCF, 0x27, 0x4F, 0xA6,
-	0xF3, 0x49, 0x97, 0x41, 0xBA, 0xAD, 0xFE, 0x01, 0x01, 0x00, 0x00, 0x80,
-	0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00},
-{0x85, 0x05, 0x00, 0x00, 0x58, 0xCD, 0xAE, 0x33, 0x79, 0xB6, 0x54, 0x4E, 0x9B,
-	0xD9, 0xA0, 0x4D, 0x34, 0xF0, 0xC2, 0x26, 0x01, 0x01, 0x00, 0x00, 0x00,
-	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
-{0x85, 0x06, 0x00, 0x00, 0x2E, 0x9A, 0x57, 0xBB, 0x54, 0xCC, 0x50, 0x44, 0xB1,
-	0xD0, 0x5E, 0x75, 0x20, 0xDC, 0xAD, 0x25, 0x01, 0x01, 0x00, 0x00, 0x04,
-	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
-
-};
-
-#define	NUM_STATIC_CLIENTS	6
-
-#endif /* DEBUG_FW_BOOT_SEQ */
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static  void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-/* #define dev_dbg dev_err */
-
-/**
- * heci_hbm_me_cl_allocate - allocates storage for me clients
- *
- * @dev: the device structure
- *
-	 * returns none.
- */
-static void heci_hbm_me_cl_allocate(struct heci_device *dev)
-{
-	struct heci_me_client *clients;
-	int b;
-
-	/* count how many ME clients we have */
-	for_each_set_bit(b, dev->me_clients_map, HECI_CLIENTS_MAX)
-		dev->me_clients_num++;
-
-	if (dev->me_clients_num <= 0)
-		return;
-
-	kfree(dev->me_clients);
-	dev->me_clients = NULL;
-
-	dev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%zd.\n",
-		dev->me_clients_num * sizeof(struct heci_me_client));
-
-	/* allocate storage for ME clients representation */
-	clients = kcalloc(dev->me_clients_num, sizeof(struct heci_me_client),
-		GFP_ATOMIC);
-	if (!clients) {
-		dev_err(&dev->pdev->dev, "memory allocation for ME clients failed.\n");
-		dev->dev_state = HECI_DEV_RESETTING;
-		heci_reset(dev, 1);
-		return;
-	}
-	dev->me_clients = clients;
-	return;
-}
-
-/**
- * heci_hbm_cl_hdr - construct client hbm header
- * @cl: - client
- * @hbm_cmd: host bus message command
- * @buf: buffer for cl header
- * @len: buffer length
- */
-static inline void heci_hbm_cl_hdr(struct heci_cl *cl, u8 hbm_cmd, void *buf,
-	size_t len)
-{
-	struct heci_hbm_cl_cmd *cmd = buf;
-
-	memset(cmd, 0, len);
-
-	cmd->hbm_cmd = hbm_cmd;
-	cmd->host_addr = cl->host_client_id;
-	cmd->me_addr = cl->me_client_id;
-}
-
-/**
- * same_disconn_addr - tells if they have the same address
- *
- * @file: private data of the file object.
- * @disconn: disconnection request.
- *
- * returns true if addres are same
- */
-static inline bool heci_hbm_cl_addr_equal(struct heci_cl *cl, void *buf)
-{
-	struct heci_hbm_cl_cmd *cmd = buf;
-	return cl->host_client_id == cmd->host_addr &&
-		cl->me_client_id == cmd->me_addr;
-}
-
-
-int heci_hbm_start_wait(struct heci_device *dev)
-{
-	int ret;
-	if (dev->hbm_state > HECI_HBM_START)
-		return 0;
-
-	dev_err(&dev->pdev->dev, "Going to wait for heci start hbm_state=%08X\n",
-		dev->hbm_state);
-	ret = wait_event_timeout(dev->wait_hbm_recvd_msg,
-			dev->hbm_state >= HECI_HBM_STARTED,
-			(HECI_INTEROP_TIMEOUT * HZ));
-
-	dev_err(&dev->pdev->dev, "Woke up from waiting for heci start ret=%d hbm_state=%08X\n",
-		ret, dev->hbm_state);
-
-	if (ret <= 0 && (dev->hbm_state <= HECI_HBM_START)) {
-		dev->hbm_state = HECI_HBM_IDLE;
-		dev_err(&dev->pdev->dev, "wating for heci start failed ret=%d hbm_state=%08X\n",
-			ret, dev->hbm_state);
-		return -ETIMEDOUT;
-	}
-	return 0;
-}
-
-/**
- * heci_hbm_start_req - sends start request message.
- *
- * @dev: the device structure
- */
-int heci_hbm_start_req(struct heci_device *dev)
-{
-	struct heci_msg_hdr hdr;
-	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
-	struct hbm_host_version_request *start_req;
-	const size_t len = sizeof(struct hbm_host_version_request);
-
-	heci_hbm_hdr(heci_hdr, len);
-
-	/* host start message */
-	start_req = (struct hbm_host_version_request *)data;
-	memset(start_req, 0, len);
-	start_req->hbm_cmd = HOST_START_REQ_CMD;
-	start_req->host_version.major_version = HBM_MAJOR_VERSION;
-	start_req->host_version.minor_version = HBM_MINOR_VERSION;
-
-	/*
-	 * (!) Response to HBM start may be so quick that this thread would get
-	 * preempted BEFORE managing to set hbm_state = HECI_HBM_START.
-	 * So set it at first, change back to HECI_HBM_IDLE upon failure
-	 */
-	dev->hbm_state = HECI_HBM_START;
-	if (heci_write_message(dev, heci_hdr, data)) {
-		dev_err(&dev->pdev->dev, "version message write failed\n");
-		dev->dev_state = HECI_DEV_RESETTING;
-		dev->hbm_state = HECI_HBM_IDLE;
-		heci_reset(dev, 1);
-		return -ENODEV;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(heci_hbm_start_req);
-
-/*
- * heci_hbm_enum_clients_req - sends enumeration client request message.
- *
- * @dev: the device structure
- *
- * returns none.
- */
-void heci_hbm_enum_clients_req(struct heci_device *dev)
-{
-	struct heci_msg_hdr hdr;
-	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
-	struct hbm_host_enum_request *enum_req;
-	const size_t len = sizeof(struct hbm_host_enum_request);
-	/* enumerate clients */
-	heci_hbm_hdr(heci_hdr, len);
-
-	enum_req = (struct hbm_host_enum_request *)data;
-	memset(enum_req, 0, len);
-	enum_req->hbm_cmd = HOST_ENUM_REQ_CMD;
-
-	if (heci_write_message(dev, heci_hdr, data)) {
-		dev->dev_state = HECI_DEV_RESETTING;
-		dev_err(&dev->pdev->dev, "enumeration request write failed.\n");
-		heci_reset(dev, 1);
-	}
-	dev->hbm_state = HECI_HBM_ENUM_CLIENTS;
-	return;
-}
-
-/**
- * heci_hbm_prop_requsest - request property for a single client
- *
- * @dev: the device structure
- *
- * returns none.
- */
-
-static int heci_hbm_prop_req(struct heci_device *dev)
-{
-
-	struct heci_msg_hdr hdr;
-	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
-	struct hbm_props_request *prop_req;
-	const size_t len = sizeof(struct hbm_props_request);
-	unsigned long next_client_index;
-	u8 client_num;
-
-	client_num = dev->me_client_presentation_num;
-
-	next_client_index = find_next_bit(dev->me_clients_map, HECI_CLIENTS_MAX,
-		dev->me_client_index);
-
-	/* We got all client properties */
-	if (next_client_index == HECI_CLIENTS_MAX) {
-		dev->hbm_state = HECI_HBM_WORKING;
-		dev->dev_state = HECI_DEV_ENABLED;
-
-		for (dev->me_client_presentation_num = 1;
-			dev->me_client_presentation_num < client_num + 1;
-				++dev->me_client_presentation_num)
-			/* Add new client device */
-			heci_bus_new_client(dev);
-		return 0;
-	}
-
-	dev->me_clients[client_num].client_id = next_client_index;
-
-#ifndef DEBUG_FW_BOOT_SEQ
-	heci_hbm_hdr(heci_hdr, len);
-	prop_req = (struct hbm_props_request *)data;
-
-	memset(prop_req, 0, sizeof(struct hbm_props_request));
-
-	prop_req->hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;
-	prop_req->address = next_client_index;
-
-	if (heci_write_message(dev, heci_hdr, data)) {
-		dev->dev_state = HECI_DEV_RESETTING;
-		dev_err(&dev->pdev->dev, "properties request write failed\n");
-		heci_reset(dev, 1);
-		return -EIO;
-	}
-#endif /*DEBUG_FW_BOOT_SEQ*/
-
-	dev->me_client_index = next_client_index;
-
-#ifdef DEBUG_FW_BOOT_SEQ
-	heci_hbm_dispatch(dev,
-		(struct heci_bus_message *)static_fw_cl_props[client_num]);
-#endif /*DEBUG_FW_BOOT_SEQ*/
-
-	return 0;
-}
-
-/**
- * heci_hbm_stop_req_prepare - perpare stop request message
- *
- * @dev - heci device
- * @heci_hdr - heci message header
- * @data - hbm message body buffer
- */
-static void heci_hbm_stop_req_prepare(struct heci_device *dev,
-	struct heci_msg_hdr *heci_hdr, unsigned char *data)
-{
-	struct hbm_host_stop_request *req =
-		(struct hbm_host_stop_request *)data;
-	const size_t len = sizeof(struct hbm_host_stop_request);
-
-	heci_hbm_hdr(heci_hdr, len);
-
-	memset(req, 0, len);
-	req->hbm_cmd = HOST_STOP_REQ_CMD;
-	req->reason = DRIVER_STOP_REQUEST;
-}
-
-/**
- * heci_hbm_cl_flow_control_req - sends flow control requst.
- *
- * @dev: the device structure
- * @cl: client info
- *
- * This function returns -EIO on write failure
- */
-int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
-{
-	struct heci_msg_hdr hdr;
-	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
-	const size_t len = sizeof(struct hbm_flow_control);
-	int	rv;
-	unsigned	num_frags;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&cl->fc_spinlock, flags);
-	heci_hbm_hdr(heci_hdr, len);
-	heci_hbm_cl_hdr(cl, HECI_FLOW_CONTROL_CMD, data, len);
-
-	dev_dbg(&dev->pdev->dev, "sending flow control host client = %d, ME client = %d\n",
-		cl->host_client_id, cl->me_client_id);
-
-	/* Sync possible race when RB recycle and packet receive paths
-	   both try to send an out FC */
-	if (cl->out_flow_ctrl_creds) {
-		spin_unlock_irqrestore(&cl->fc_spinlock, flags);
-		return	0;
-	}
-
-	num_frags = cl->recv_msg_num_frags;
-	cl->recv_msg_num_frags = 0;
-
-	rv = heci_write_message(dev, heci_hdr, data);
-	if (!rv) {
-		struct timeval	tv;
-
-		++cl->out_flow_ctrl_creds;
-		++cl->out_flow_ctrl_cnt;
-		do_gettimeofday(&tv);
-		cl->out_fc_sec = tv.tv_sec;
-		cl->out_fc_usec = tv.tv_usec;
-		if (cl->rx_sec && cl->rx_usec) {
-			unsigned long	s, us;
-
-			s = cl->out_fc_sec - cl->rx_sec;
-			us = cl->out_fc_usec - cl->rx_usec;
-			if (cl->rx_usec > cl->out_fc_usec) {
-				us += 1000000UL;
-				--s;
-			}
-			if (s > cl->max_fc_delay_sec ||
-					s == cl->max_fc_delay_sec &&
-					us > cl->max_fc_delay_usec) {
-				cl->max_fc_delay_sec = s;
-				cl->max_fc_delay_usec = us;
-			}
-		}
-	} else {
-		++cl->err_send_fc;
-	}
-
-	spin_unlock_irqrestore(&cl->fc_spinlock, flags);
-	return	rv;
-}
-EXPORT_SYMBOL(heci_hbm_cl_flow_control_req);
-
-/*
- * heci_hbm_cl_disconnect_req - sends disconnect message to fw.
- *
- * @dev: the device structure
- * @cl: a client to disconnect from
- *
- * This function returns -EIO on write failure
- */
-int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl)
-{
-	struct heci_msg_hdr hdr;
-	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
-	const size_t len = sizeof(struct hbm_client_connect_request);
-
-	heci_hbm_hdr(heci_hdr, len);
-	heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_REQ_CMD, data, len);
-
-	return heci_write_message(dev, heci_hdr, data);
-}
-
-/*
- * heci_hbm_cl_disconnect_res - disconnect response from ME
- *
- * @dev: the device structure
- * @rs: disconnect response bus message
- */
-static void heci_hbm_cl_disconnect_res(struct heci_device *dev,
-	struct hbm_client_connect_response *rs)
-{
-	struct heci_cl *cl = NULL, *next = NULL;
-	unsigned long	flags;
-
-	dev_dbg(&dev->pdev->dev,
-			"disconnect_response:\n"
-			"ME Client = %d\n"
-			"Host Client = %d\n"
-			"Status = %d\n",
-			rs->me_addr,
-			rs->host_addr,
-			rs->status);
-
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (!rs->status && heci_hbm_cl_addr_equal(cl, rs)) {
-			cl->state = HECI_CL_DISCONNECTED;
-			break;
-		}
-	}
-	if (cl)
-		wake_up(&cl->wait_ctrl_res);
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-}
-
-/**
- * heci_hbm_cl_connect_req - send connection request to specific me client
- *
- * @dev: the device structure
- * @cl: a client to connect to
- *
- * returns -EIO on write failure
- */
-int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl)
-{
-	struct heci_msg_hdr hdr;
-	unsigned char data[128];
-	struct heci_msg_hdr *heci_hdr = &hdr;
-	const size_t len = sizeof(struct hbm_client_connect_request);
-
-	heci_hbm_hdr(heci_hdr, len);
-	heci_hbm_cl_hdr(cl, CLIENT_CONNECT_REQ_CMD, data, len);
-
-	return heci_write_message(dev, heci_hdr,  data);
-}
-EXPORT_SYMBOL(heci_hbm_cl_connect_req);
-
-/**
- * heci_hbm_cl_connect_res - connect resposne from the ME
- *
- * @dev: the device structure
- * @rs: connect response bus message
- */
-static void heci_hbm_cl_connect_res(struct heci_device *dev,
-	struct hbm_client_connect_response *rs)
-{
-	struct heci_cl *cl = NULL, *next = NULL;
-	unsigned long	flags;
-
-	dev_dbg(&dev->pdev->dev,
-			"connect_response:\n"
-			"ME Client = %d\n"
-			"Host Client = %d\n"
-			"Status = %d\n",
-			rs->me_addr,
-			rs->host_addr,
-			rs->status);
-
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (heci_hbm_cl_addr_equal(cl, rs)) {
-			if (!rs->status) {
-				cl->state = HECI_CL_CONNECTED;
-				cl->status = 0;
-			} else {
-				cl->state = HECI_CL_DISCONNECTED;
-				cl->status = -ENODEV;
-			}
-			break;
-		}
-	}
-	if (cl)
-		wake_up(&cl->wait_ctrl_res);
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-}
-
-
-/**
- * heci_client_disconnect_request - disconnect request initiated by me
- *  host sends disoconnect response
- *
- * @dev: the device structure.
- * @disconnect_req: disconnect request bus message from the me
- */
-static void heci_hbm_fw_disconnect_req(struct heci_device *dev,
-	struct hbm_client_connect_request *disconnect_req)
-{
-	struct heci_cl *cl, *next;
-	const size_t len = sizeof(struct hbm_client_connect_response);
-	unsigned long	flags;
-	struct heci_msg_hdr hdr;
-	unsigned char data[4];	/* All HBM messages are 4 bytes */
-
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-		if (heci_hbm_cl_addr_equal(cl, disconnect_req)) {
-			cl->state = HECI_CL_DISCONNECTED;
-
-			/* prepare disconnect response */
-			heci_hbm_hdr(&hdr, len);
-			heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_RES_CMD, data,
-				len);
-			heci_write_message(dev, &hdr, data);
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-}
-
-
-/**
- * heci_hbm_dispatch - bottom half read routine after ISR to
- * handle the read bus message cmd processing.
- *
- * @dev: the device structure
- * @hdr: header of bus message
- */
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
-{
-	struct heci_bus_message *heci_msg;
-	struct heci_me_client *me_client;
-	struct hbm_host_version_response *version_res;
-	struct hbm_client_connect_response *connect_res;
-	struct hbm_client_connect_response *disconnect_res;
-	struct hbm_client_connect_request *disconnect_req;
-	struct hbm_props_response *props_res;
-	struct hbm_host_enum_response *enum_res;
-	struct heci_msg_hdr heci_hdr;
-	unsigned char data[4];	/* All HBM messages are 4 bytes */
-
-	heci_msg = hdr;
-	dev_dbg(&dev->pdev->dev, "bus cmd = %lu\n", heci_msg->hbm_cmd);
-
-	switch (heci_msg->hbm_cmd) {
-	case HOST_START_RES_CMD:
-		version_res = (struct hbm_host_version_response *)heci_msg;
-		if (!version_res->host_version_supported) {
-			dev->version = version_res->me_max_version;
-			dev_dbg(&dev->pdev->dev, "version mismatch.\n");
-
-			dev->hbm_state = HECI_HBM_STOPPED;
-			heci_hbm_stop_req_prepare(dev, &heci_hdr, data);
-			heci_write_message(dev, &heci_hdr, data);
-			return;
-		}
-
-		dev->version.major_version = HBM_MAJOR_VERSION;
-		dev->version.minor_version = HBM_MINOR_VERSION;
-		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
-		    dev->hbm_state == HECI_HBM_START) {
-			dev->hbm_state = HECI_HBM_STARTED;
-			heci_hbm_enum_clients_req(dev);
-		} else {
-			dev_err(&dev->pdev->dev, "reset: wrong host start response\n");
-			/* BUG: why do we arrive here? */
-			heci_reset(dev, 1);
-			return;
-		}
-
-		wake_up(&dev->wait_hbm_recvd_msg);
-		dev_dbg(&dev->pdev->dev, "host start response message received.\n");
-		break;
-
-	case CLIENT_CONNECT_RES_CMD:
-		connect_res = (struct hbm_client_connect_response *)heci_msg;
-		heci_hbm_cl_connect_res(dev, connect_res);
-		dev_dbg(&dev->pdev->dev, "client connect response message received.\n");
-		break;
-
-	case CLIENT_DISCONNECT_RES_CMD:
-		disconnect_res = (struct hbm_client_connect_response *)heci_msg;
-		heci_hbm_cl_disconnect_res(dev, disconnect_res);
-		dev_dbg(&dev->pdev->dev, "client disconnect response message received.\n");
-		break;
-
-	case HOST_CLIENT_PROPERTIES_RES_CMD:
-		props_res = (struct hbm_props_response *)heci_msg;
-		me_client = &dev->me_clients[dev->me_client_presentation_num];
-
-#ifdef DUMP_CL_PROP
-		/* DEBUG -- dump complete response */
-		do {
-			int	i;
-
-			dev->print_log(dev,
-				"%s(): HOST_CLIENT_PROPERTIES_RES_CMD, client# = %d props: ",
-				__func__, dev->me_client_presentation_num);
-			for (i = 0; i < sizeof(struct hbm_props_response); ++i)
-				dev->print_log(dev, "%02X ",
-					*(((unsigned char *)props_res) + i));
-			dev->print_log(dev, "\n");
-		} while (0);
-#endif /*DUMP_CL_PROP*/
-
-		if (props_res->status || !dev->me_clients) {
-			dev_err(&dev->pdev->dev, "reset: properties response hbm wrong status.\n");
-			heci_reset(dev, 1);
-			return;
-		}
-
-		if (me_client->client_id != props_res->address) {
-			dev_err(&dev->pdev->dev,
-"reset: host properties response address mismatch [%02X %02X]\n",
-				me_client->client_id, props_res->address);
-			heci_reset(dev, 1);
-			return;
-		}
-
-		if (dev->dev_state != HECI_DEV_INIT_CLIENTS ||
-		    dev->hbm_state != HECI_HBM_CLIENT_PROPERTIES) {
-			dev_err(&dev->pdev->dev,
-				"reset: unexpected properties response\n");
-			heci_reset(dev, 1);
-			return;
-		}
-
-		me_client->props = props_res->client_properties;
-		dev->me_client_index++;
-		dev->me_client_presentation_num++;
-
-#if 0
-		/* Add new client device */
-		heci_bus_new_client(dev);
-#endif
-
-		/* request property for the next client */
-		heci_hbm_prop_req(dev);
-
-		break;
-
-	case HOST_ENUM_RES_CMD:
-		enum_res = (struct hbm_host_enum_response *) heci_msg;
-		memcpy(dev->me_clients_map, enum_res->valid_addresses, 32);
-		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
-		    dev->hbm_state == HECI_HBM_ENUM_CLIENTS) {
-				dev->me_client_presentation_num = 0;
-				dev->me_client_index = 0;
-
-				heci_hbm_me_cl_allocate(dev);
-				dev->hbm_state = HECI_HBM_CLIENT_PROPERTIES;
-
-				/* first property request */
-				heci_hbm_prop_req(dev);
-		} else {
-			dev_err(&dev->pdev->dev, "reset: unexpected enumeration response hbm.\n");
-			heci_reset(dev, 1);
-			return;
-		}
-		break;
-
-	case HOST_STOP_RES_CMD:
-		if (dev->hbm_state != HECI_HBM_STOPPED)
-			dev_err(&dev->pdev->dev, "unexpected stop response.\n");
-
-		dev->dev_state = HECI_DEV_DISABLED;
-		dev_info(&dev->pdev->dev, "reset: FW stop response.\n");
-		heci_reset(dev, 1);
-		break;
-
-	case CLIENT_DISCONNECT_REQ_CMD:
-		/* search for client */
-		disconnect_req = (struct hbm_client_connect_request *)heci_msg;
-		heci_hbm_fw_disconnect_req(dev, disconnect_req);
-		break;
-
-	case ME_STOP_REQ_CMD:
-		dev->hbm_state = HECI_HBM_STOPPED;
-		break;
-
-	case CLIENT_DMA_RES_CMD:
-		/*
-		 * TODO: wake up anybody who could be
-		 * waiting for DMA completion
-		 */
-		dma_ready = 1;
-		if (waitqueue_active(&dev->wait_dma_ready))
-			wake_up(&dev->wait_dma_ready);
-		break;
-
-	default:
-		/*BUG();*/
-		dev_err(&dev->pdev->dev, "unknown HBM: %u\n",
-			(unsigned)heci_msg->hbm_cmd);
-		break;
-
-	}
-}
-EXPORT_SYMBOL(heci_hbm_dispatch);
-
-
-/*
- *	Receive and process HECI bus messages
- *
- *	(!) ISR context
- */
-void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
-{
-	uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
-	struct heci_bus_message	*heci_msg =
-		(struct heci_bus_message *)rd_msg_buf;
-	unsigned long	flags;
-
-	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
-
-	/* Flow control - handle in place */
-	if (heci_msg->hbm_cmd == HECI_FLOW_CONTROL_CMD) {
-		struct hbm_flow_control *flow_control =
-			(struct hbm_flow_control *)heci_msg;
-		struct heci_cl *cl = NULL;
-		struct heci_cl *next = NULL;
-		unsigned long	flags, tx_flags;
-
-		ISH_DBG_PRINT(KERN_ALERT
-			"%s(): HECI_FLOW_CONTROL_CMD, checking to whom (host_addr=%d me_addr=%d\n",
-			__func__, flow_control->host_addr,
-			flow_control->me_addr);
-		spin_lock_irqsave(&dev->cl_list_lock, flags);
-		list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
-			if (cl->host_client_id == flow_control->host_addr &&
-					cl->me_client_id ==
-					flow_control->me_addr) {
-				/*##########################################*/
-				/*
-				 * FIXME: It's valid only for counting
-				 * flow-control implementation to receive a
-				 * FC in the middle of sending
-				 */
-				if (cl->heci_flow_ctrl_creds)
-					dev_err(&dev->pdev->dev,
-						"recv extra FC from FW client %u (host client %u) (FC count was %u)\n",
-						(unsigned)cl->me_client_id,
-						(unsigned)cl->host_client_id,
-					(unsigned)cl->heci_flow_ctrl_creds);
-				else {
-					if (cl->host_client_id == 3 &&
-							cl->me_client_id == 5) {
-						++dev->ipc_hid_in_fc;
-						++dev->ipc_hid_in_fc_cnt;
-					}
-					++cl->heci_flow_ctrl_creds;
-					++cl->heci_flow_ctrl_cnt;
-					spin_lock_irqsave(&cl->tx_list_spinlock,
-						tx_flags);
-				if (!list_empty(&cl->tx_list.list)) {
-					/*
-					 * start sending the first msg
-					 *	= the callback function
-					 */
-					spin_unlock_irqrestore(
-							&cl->tx_list_spinlock,
-							tx_flags);
-					heci_cl_send_msg(dev, cl);
-				} else {
-						spin_unlock_irqrestore(
-							&cl->tx_list_spinlock,
-							tx_flags);
-					}
-				}
-				break;
-				/*##########################################*/
-			}
-		}
-		spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-		goto	eoi;
-	}
-
-	/*
-	 * Some messages that are safe for ISR processing and important
-	 * to be done "quickly" and in-order, go here
-	 */
-	if (heci_msg->hbm_cmd == CLIENT_CONNECT_RES_CMD ||
-			heci_msg->hbm_cmd == CLIENT_DISCONNECT_RES_CMD ||
-			heci_msg->hbm_cmd == CLIENT_DISCONNECT_REQ_CMD) {
-		heci_hbm_dispatch(dev, heci_msg);
-		goto	eoi;
-	}
-
-	/* TODO: revise, may be some don't need BH as well */
-	/*
-	 * All other HBMs go here.
-	 * We schedule HBMs for processing serially,
-	 * possibly there will be multiplpe HBMs scheduled at the same time.
-	 * System wq itself is a serializing means
-	 */
-	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
-	if ((dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %
-			(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE) ==
-			dev->rd_msg_fifo_head) {
-		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-		dev_err(&dev->pdev->dev, "BH buffer overflow, dropping HBM %u\n",
-			(unsigned)heci_msg->hbm_cmd);
-		goto	eoi;
-	}
-	memcpy(dev->rd_msg_fifo + dev->rd_msg_fifo_tail, heci_msg,
-		heci_hdr->length);
-	dev->rd_msg_fifo_tail = (dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %
-		(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
-	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-	schedule_work(&dev->bh_hbm_work);
-eoi:
-	return;
-}
-EXPORT_SYMBOL(recv_hbm);
-
-/*
- *      Receive and process HECI fixed client messages
- *
- *      (!) ISR context
- */
-void recv_fixed_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
-{
-	uint8_t rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
-
-	dev->print_log(dev,
-		"%s() got fixed client msg from client #%d\n",
-		__func__, heci_hdr->me_addr);
-	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
-	if (heci_hdr->me_addr == HECI_SYSTEM_STATE_CLIENT_ADDR) {
-		struct ish_system_states_header *msg_hdr =
-			(struct ish_system_states_header *)rd_msg_buf;
-		if (msg_hdr->cmd == SYSTEM_STATE_SUBSCRIBE)
-			send_resume(dev);       /* if FW request arrived here,
-						the system is not suspended */
-		else
-			dev_err(&dev->pdev->dev,
-				"unknown fixed client msg [%02X]\n",
-				msg_hdr->cmd);
-	}
-}
-EXPORT_SYMBOL(recv_fixed_cl_msg);
-
-static inline void fix_cl_hdr(struct heci_msg_hdr *hdr, size_t length,
-	u8 cl_addr)
-{
-	hdr->host_addr = 0;
-	hdr->me_addr = cl_addr;
-	hdr->length = length;
-	hdr->msg_complete = 1;
-	hdr->reserved = 0;
-}
-
-/* Suspend and resume notification*/
-
-/*Global var for suspend & resume*/
-u32 current_state = 0;
-u32 supported_states = 0 | SUSPEND_STATE_BIT;
-
-void send_suspend(struct heci_device *dev)
-{
-	struct heci_msg_hdr     heci_hdr;
-	struct ish_system_states_status state_status_msg;
-	const size_t len = sizeof(struct ish_system_states_status);
-
-	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
-
-	memset(&state_status_msg, 0, len);
-	state_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;
-	state_status_msg.supported_states = supported_states;
-	current_state |= SUSPEND_STATE_BIT;
-	dev->print_log(dev, "%s() sends SUSPEND notification\n", __func__);
-	state_status_msg.states_status = current_state;
-
-	heci_write_message(dev, &heci_hdr, &state_status_msg);
-}
-EXPORT_SYMBOL(send_suspend);
-
-void send_resume(struct heci_device *dev)
-{
-	struct heci_msg_hdr     heci_hdr;
-	struct ish_system_states_status state_status_msg;
-	const size_t len = sizeof(struct ish_system_states_status);
-
-	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
-
-	memset(&state_status_msg, 0, len);
-	state_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;
-	state_status_msg.supported_states = supported_states;
-	current_state &= ~SUSPEND_STATE_BIT;
-	dev->print_log(dev, "%s() sends RESUME notification\n", __func__);
-	state_status_msg.states_status = current_state;
-
-	heci_write_message(dev, &heci_hdr, &state_status_msg);
-}
-EXPORT_SYMBOL(send_resume);
-
-void query_subscribers(struct heci_device *dev)
-{
-	struct heci_msg_hdr     heci_hdr;
-	struct ish_system_states_query_subscribers query_subscribers_msg;
-	const size_t len = sizeof(struct ish_system_states_query_subscribers);
-
-	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
-
-	memset(&query_subscribers_msg, 0, len);
-	query_subscribers_msg.hdr.cmd = SYSTEM_STATE_QUERY_SUBSCRIBERS;
-
-	heci_write_message(dev, &heci_hdr, &query_subscribers_msg);
-}
-
diff --git a/drivers/misc/heci/hbm.h b/drivers/misc/heci/hbm.h
deleted file mode 100644
index 94eb0ab..0000000
--- a/drivers/misc/heci/hbm.h
+++ /dev/null
@@ -1,369 +0,0 @@
-/*
- * HECI bus layer messages handling
- *
- * Copyright (c) 2003-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef _HECI_HBM_H_
-#define _HECI_HBM_H_
-
-#include <linux/uuid.h>
-
-struct heci_device;
-struct heci_msg_hdr;
-struct heci_cl;
-
-/*
- * Timeouts in Seconds
- */
-#define HECI_INTEROP_TIMEOUT         7  /* Timeout on ready message */
-#define HECI_CONNECT_TIMEOUT         3  /* HPS: at least 2 seconds */
-
-#define HECI_CL_CONNECT_TIMEOUT     15  /* HPS: Client Connect Timeout */
-#define HECI_CLIENTS_INIT_TIMEOUT   15  /* HPS: Clients Enumeration Timeout */
-
-#if 0
-#define HECI_IAMTHIF_STALL_TIMER    12  /* HPS */
-#define HECI_IAMTHIF_READ_TIMER     10  /* HPS */
-#endif
-
-
-/*
- * HECI Version
- */
-#define HBM_MINOR_VERSION                   0
-#define HBM_MAJOR_VERSION                   1
-#define HBM_TIMEOUT                         1	/* 1 second */
-
-/* Host bus message command opcode */
-#define HECI_HBM_CMD_OP_MSK                  0x7f
-/* Host bus message command RESPONSE */
-#define HECI_HBM_CMD_RES_MSK                 0x80
-
-/*
- * HECI Bus Message Command IDs
- */
-#define HOST_START_REQ_CMD                  0x01
-#define HOST_START_RES_CMD                  0x81
-
-#define HOST_STOP_REQ_CMD                   0x02
-#define HOST_STOP_RES_CMD                   0x82
-
-#define ME_STOP_REQ_CMD                     0x03
-
-#define HOST_ENUM_REQ_CMD                   0x04
-#define HOST_ENUM_RES_CMD                   0x84
-
-#define HOST_CLIENT_PROPERTIES_REQ_CMD      0x05
-#define HOST_CLIENT_PROPERTIES_RES_CMD      0x85
-
-#define CLIENT_CONNECT_REQ_CMD              0x06
-#define CLIENT_CONNECT_RES_CMD              0x86
-
-#define CLIENT_DISCONNECT_REQ_CMD           0x07
-#define CLIENT_DISCONNECT_RES_CMD           0x87
-
-#define HECI_FLOW_CONTROL_CMD                0x08
-
-#define CLIENT_DMA_REQ_CMD		0x10
-#define CLIENT_DMA_RES_CMD		0x90
-
-/*
- * HECI Stop Reason
- * used by hbm_host_stop_request.reason
- */
-enum heci_stop_reason_types {
-	DRIVER_STOP_REQUEST = 0x00,
-	DEVICE_D1_ENTRY = 0x01,
-	DEVICE_D2_ENTRY = 0x02,
-	DEVICE_D3_ENTRY = 0x03,
-	SYSTEM_S1_ENTRY = 0x04,
-	SYSTEM_S2_ENTRY = 0x05,
-	SYSTEM_S3_ENTRY = 0x06,
-	SYSTEM_S4_ENTRY = 0x07,
-	SYSTEM_S5_ENTRY = 0x08
-};
-
-/*
- * Client Connect Status
- * used by hbm_client_connect_response.status
- */
-enum client_connect_status_types {
-	CCS_SUCCESS = 0x00,
-	CCS_NOT_FOUND = 0x01,
-	CCS_ALREADY_STARTED = 0x02,
-	CCS_OUT_OF_RESOURCES = 0x03,
-	CCS_MESSAGE_SMALL = 0x04
-};
-
-/*
- * Client Disconnect Status
- */
-enum client_disconnect_status_types {
-	CDS_SUCCESS = 0x00
-};
-
-/*
- *  HECI BUS Interface Section
- */
-struct heci_msg_hdr {
-	u32 me_addr:8;
-	u32 host_addr:8;
-	u32 length:9;
-	u32 reserved:6;
-	u32 msg_complete:1;
-} __packed;
-
-
-struct heci_bus_message {
-	u8 hbm_cmd;
-	u8 data[0];
-} __packed;
-
-/**
- * struct hbm_cl_cmd - client specific host bus command
- *	CONNECT, DISCONNECT, and FlOW CONTROL
- *
- * @hbm_cmd - bus message command header
- * @me_addr - address of the client in ME
- * @host_addr - address of the client in the driver
- * @data
- */
-struct heci_hbm_cl_cmd {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 data;
-};
-
-struct hbm_version {
-	u8 minor_version;
-	u8 major_version;
-} __packed;
-
-struct hbm_host_version_request {
-	u8 hbm_cmd;
-	u8 reserved;
-	struct hbm_version host_version;
-} __packed;
-
-struct hbm_host_version_response {
-	u8 hbm_cmd;
-	u8 host_version_supported;
-	struct hbm_version me_max_version;
-} __packed;
-
-struct hbm_host_stop_request {
-	u8 hbm_cmd;
-	u8 reason;
-	u8 reserved[2];
-} __packed;
-
-struct hbm_host_stop_response {
-	u8 hbm_cmd;
-	u8 reserved[3];
-} __packed;
-
-struct hbm_me_stop_request {
-	u8 hbm_cmd;
-	u8 reason;
-	u8 reserved[2];
-} __packed;
-
-struct hbm_host_enum_request {
-	u8 hbm_cmd;
-	u8 reserved[3];
-} __packed;
-
-struct hbm_host_enum_response {
-	u8 hbm_cmd;
-	u8 reserved[3];
-	u8 valid_addresses[32];
-} __packed;
-
-struct heci_client_properties {
-	uuid_le protocol_name;
-	u8 protocol_version;
-	u8 max_number_of_connections;
-	u8 fixed_address;
-	u8 single_recv_buf;
-	u32 max_msg_length;
-	u8 dma_hdr_len;
-#define	HECI_CLIENT_DMA_ENABLED	0x80
-	u8 reserved4;
-	u8 reserved5;
-	u8 reserved6;
-} __packed;
-
-struct hbm_props_request {
-	u8 hbm_cmd;
-	u8 address;
-	u8 reserved[2];
-} __packed;
-
-
-struct hbm_props_response {
-	u8 hbm_cmd;
-	u8 address;
-	u8 status;
-	u8 reserved[1];
-	struct heci_client_properties client_properties;
-} __packed;
-
-/**
- * struct hbm_client_connect_request - connect/disconnect request
- *
- * @hbm_cmd - bus message command header
- * @me_addr - address of the client in ME
- * @host_addr - address of the client in the driver
- * @reserved
- */
-struct hbm_client_connect_request {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 reserved;
-} __packed;
-
-/**
- * struct hbm_client_connect_response - connect/disconnect response
- *
- * @hbm_cmd - bus message command header
- * @me_addr - address of the client in ME
- * @host_addr - address of the client in the driver
- * @status - status of the request
- */
-struct hbm_client_connect_response {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 status;
-} __packed;
-
-
-#define HECI_FC_MESSAGE_RESERVED_LENGTH           5
-
-struct hbm_flow_control {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 reserved[HECI_FC_MESSAGE_RESERVED_LENGTH];
-} __packed;
-
-struct hbm_client_dma_request {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 reserved;
-	u64 msg_addr;
-	u32 msg_len;
-	u16 reserved2;
-	u16 msg_preview_len;
-	u8 msg_preview[12];
-} __packed;
-
-struct hbm_client_dma_response {
-	u8 hbm_cmd;
-	u8 me_addr;
-	u8 host_addr;
-	u8 status;
-	u64 msg_addr;
-	u32 msg_len;
-} __packed;
-
-/**
- * enum heci_hbm_state - host bus message protocol state
- *
- * @HECI_HBM_IDLE : protocol not started
- * @HECI_HBM_START : start request message was sent
- * @HECI_HBM_ENUM_CLIENTS : enumeration request was sent
- * @HECI_HBM_CLIENT_PROPERTIES : acquiring clients properties
- */
-enum heci_hbm_state {
-	HECI_HBM_IDLE = 0,
-	HECI_HBM_START,
-	HECI_HBM_STARTED,
-	HECI_HBM_ENUM_CLIENTS,
-	HECI_HBM_CLIENT_PROPERTIES,
-	HECI_HBM_WORKING,
-	HECI_HBM_STOPPED,
-};
-
-#if 0
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_msg_hdr *hdr);
-#else
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
-#endif
-
-static inline void heci_hbm_hdr(struct heci_msg_hdr *hdr, size_t length)
-{
-	hdr->host_addr = 0;
-	hdr->me_addr = 0;
-	hdr->length = length;
-	hdr->msg_complete = 1;
-	hdr->reserved = 0;
-}
-
-int heci_hbm_start_req(struct heci_device *dev);
-int heci_hbm_start_wait(struct heci_device *dev);
-int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl);
-int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl);
-int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl);
-void heci_hbm_enum_clients_req(struct heci_device *dev);
-void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
-
-/* System state */
-#define HECI_SYSTEM_STATE_CLIENT_ADDR 13
-
-#define SYSTEM_STATE_SUBSCRIBE                  0x1
-#define SYSTEM_STATE_STATUS                     0x2
-#define SYSTEM_STATE_QUERY_SUBSCRIBERS          0x3
-#define SYSTEM_STATE_STATE_CHANGE_REQ		0x4
-
-#define SUSPEND_STATE_BIT       (1<<1) /*indicates suspend and resume states*/
-
-#define ANDROID_EVENT_MASK	0xff000000
-
-struct ish_system_states_header {
-	u32 cmd;
-	u32 cmd_status;  /*responses will have this set*/
-} __packed;
-
-struct ish_system_states_subscribe {
-	struct ish_system_states_header hdr;
-	u32 states;
-} __packed;
-
-struct ish_system_states_status {
-	struct ish_system_states_header hdr;
-	u32 supported_states;
-	u32 states_status;
-} __packed;
-
-struct ish_system_states_query_subscribers {
-	struct ish_system_states_header hdr;
-} __packed;
-
-struct ish_system_states_state_change_req {
-	struct ish_system_states_header hdr;
-	u32 requested_states;
-	u32 states_status;
-} __packed;
-
-void send_suspend(struct heci_device *dev);
-void send_resume(struct heci_device *dev);
-void query_subscribers(struct heci_device *dev);
-
-void recv_fixed_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
-void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
-#endif /* _HECI_HBM_H_ */
-
diff --git a/drivers/misc/heci/heci-api.c b/drivers/misc/heci/heci-api.c
deleted file mode 100644
index a056202..0000000
--- a/drivers/misc/heci/heci-api.c
+++ /dev/null
@@ -1,692 +0,0 @@
-/*
- * User-mode HECI API
- *
- * Copyright (c) 2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/aio.h>
-#include <linux/pci.h>
-#include <linux/poll.h>
-#include <linux/init.h>
-#include <linux/ioctl.h>
-#include <linux/cdev.h>
-#include <linux/sched.h>
-#include <linux/uuid.h>
-#include <linux/compat.h>
-#include <linux/jiffies.h>
-#include <linux/interrupt.h>
-#include <linux/miscdevice.h>
-#include "heci-api.h"
-#include "heci_dev.h"
-#include "client.h"
-#include "platform-config.h"
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static  void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-/*#define dev_dbg dev_err*/
-
-/**
- * heci_open - the open function
- *
- * @inode: pointer to inode structure
- * @file: pointer to file structure
- e
- * returns 0 on success, <0 on error
- */
-static int heci_open(struct inode *inode, struct file *file)
-{
-	struct miscdevice *misc = file->private_data;
-	struct pci_dev *pdev;
-	struct heci_cl *cl;
-	struct heci_device *dev;
-	int err;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	/* Non-blocking semantics are not supported */
-	if (file->f_flags & O_NONBLOCK)
-		return	-EINVAL;
-
-	err = -ENODEV;
-	if (!misc->parent)
-		goto out;
-
-	pdev = container_of(misc->parent, struct pci_dev, dev);
-
-	dev = pci_get_drvdata(pdev);
-	if (!dev)
-		goto out;
-
-	err = -ENOMEM;
-	cl = heci_cl_allocate(dev);
-	if (!cl)
-		goto out_free;
-
-	/*
-	 * We may have a case of issued open() with
-	 * dev->dev_state == HECI_DEV_DISABLED, as part of re-enabling path
-	 */
-	err = -ENODEV;
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		dev_dbg(&dev->pdev->dev, "dev_state != HECI_ENABLED  dev_state = %s\n",
-		    heci_dev_state_str(dev->dev_state));
-		goto out_free;
-	}
-
-	err = heci_cl_link(cl, HECI_HOST_CLIENT_ID_ANY);
-	if (err)
-		goto out_free;
-
-	file->private_data = cl;
-
-	return nonseekable_open(inode, file);
-
-out_free:
-	kfree(cl);
-out:
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return err;
-}
-
-/**
- * heci_release - the release function
- *
- * @inode: pointer to inode structure
- * @file: pointer to file structure
- *
- * returns 0 on success, <0 on error
- */
-static int heci_release(struct inode *inode, struct file *file)
-{
-	struct heci_cl *cl = file->private_data;
-	struct heci_device *dev;
-	int rets = 0;
-	unsigned int flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	/*
-	 * May happen if device sent FW reset or was intentionally
-	 * halted by host SW. The client is then invalid
-	 */
-	if (dev->dev_state != HECI_DEV_ENABLED)
-		return	0;
-
-	if (cl->state == HECI_CL_CONNECTED) {
-		cl->state = HECI_CL_DISCONNECTING;
-		dev_dbg(&dev->pdev->dev, "disconnecting client host client = %d, ME client = %d\n",
-			cl->host_client_id, cl->me_client_id);
-		rets = heci_cl_disconnect(cl);
-	}
-
-	dev_dbg(&dev->pdev->dev, "remove client host client = %d, ME client = %d\n",
-	    cl->host_client_id,
-	    cl->me_client_id);
-
-	heci_cl_unlink(cl);
-	heci_cl_flush_queues(cl);
-	file->private_data = NULL;
-
-	/* disband and free all Tx and Rx client-level rings */
-	spin_lock_irqsave(&dev->cl_list_lock, flags);
-	heci_cl_free(cl);
-	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return rets;
-}
-
-
-/**
- * heci_read - the read function.
- *
- * @file: pointer to file structure
- * @ubuf: pointer to user buffer
- * @length: buffer length
- * @offset: data offset in buffer
- *
- * returns >=0 data length on success , <0 on error
- */
-static ssize_t heci_read(struct file *file, char __user *ubuf,
-			size_t length, loff_t *offset)
-{
-	struct heci_cl *cl = file->private_data;
-	struct heci_cl_rb *rb = NULL;
-	struct heci_device *dev;
-	int rets;
-	unsigned long flags;
-
-	/* Non-blocking semantics are not supported */
-	if (file->f_flags & O_NONBLOCK)
-		return	-EINVAL;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-/*
- * EXPLAINME: handle reading message by fragments smaller than
- * actual message size. Why needed? Reportedly, doesn't work: why?
- */
-#if 0
-	if (cl->read_rb && cl->read_rb->buf_idx > *offset) {
-		rb = cl->read_rb;
-		goto copy_buffer;
-	} else if (cl->read_rb && cl->read_rb->buf_idx > 0 &&
-		   cl->read_rb->buf_idx <= *offset) {
-		rb = cl->read_rb;
-		rets = 0;
-		goto free;
-	} else if ((!cl->read_rb || !cl->read_rb->buf_idx) && *offset > 0) {
-		/*Offset needs to be cleaned for contiguous reads*/
-		*offset = 0;
-		rets = 0;
-		goto out;
-	}
-#endif
-
-	spin_lock_irqsave(&cl->in_process_spinlock, flags);
-	if (!list_empty(&cl->in_process_list.list)) {
-		rb = list_entry(cl->in_process_list.list.next,
-			struct heci_cl_rb, list);
-		list_del_init(&rb->list);
-		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
-		goto copy_buffer;
-	}
-	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
-
-	if (waitqueue_active(&cl->rx_wait)) {
-		rets = -EBUSY;
-		goto out;
-	}
-
-	if (wait_event_interruptible(cl->rx_wait,
-			(dev->dev_state == HECI_DEV_ENABLED &&
-			(cl->read_rb || HECI_CL_INITIALIZING == cl->state ||
-			HECI_CL_DISCONNECTED == cl->state ||
-			HECI_CL_DISCONNECTING == cl->state)))) {
-		dev_err(&dev->pdev->dev, "%s(): woke up not in success; sig. pending = %d signal = %08lX\n",
-			__func__, signal_pending(current),
-			current->pending.signal.sig[0]);
-		return	-ERESTARTSYS;
-	}
-
-	/*
-	 * If FW reset arrived, this will happen. Don't check cl->,
-	 * as 'cl' may be freed already
-	 */
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto	out;
-	}
-
-	if (HECI_CL_INITIALIZING == cl->state ||
-	    HECI_CL_DISCONNECTED == cl->state ||
-	    HECI_CL_DISCONNECTING == cl->state) {
-		rets = -EBUSY;
-		goto out;
-	}
-
-	rb = cl->read_rb;
-	if (!rb) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-	/* now copy the data to user space */
-copy_buffer:
-	dev_dbg(&dev->pdev->dev, "buf.size = %d buf.idx= %ld\n",
-	    rb->buffer.size, rb->buf_idx);
-	if (length == 0 || ubuf == NULL || *offset > rb->buf_idx) {
-		rets = -EMSGSIZE;
-		goto free;
-	}
-
-	/* length is being truncated to PAGE_SIZE,
-	 * however buf_idx may point beyond that */
-	length = min_t(size_t, length, rb->buf_idx - *offset);
-
-	if (copy_to_user(ubuf, rb->buffer.data + *offset, length)) {
-		rets = -EFAULT;
-		goto free;
-	}
-
-	rets = length;
-	*offset += length;
-	if ((unsigned long)*offset < rb->buf_idx)
-		goto out;
-
-free:
-	heci_io_rb_recycle(rb);
-
-	cl->read_rb = NULL;
-	*offset = 0;
-out:
-	dev_dbg(&dev->pdev->dev, "end heci read rets= %d\n", rets);
-	return rets;
-}
-
-
-/**
- * heci_write - the write function.
- *
- * @file: pointer to file structure
- * @ubuf: pointer to user buffer
- * @length: buffer length
- * @offset: data offset in buffer
- *
- * returns >=0 data length on success , <0 on error
- */
-static ssize_t heci_write(struct file *file, const char __user *ubuf,
-	size_t length, loff_t *offset)
-{
-	struct heci_cl *cl = file->private_data;
-
-	/*
-	 * TODO: we may further optimize write path by obtaining and directly
-	 * copy_from_user'ing to tx_ring's buffer
-	 */
-	void *write_buf = NULL;
-	struct heci_device *dev;
-	int rets;
-
-	/* Non-blocking semantics are not supported */
-	if (file->f_flags & O_NONBLOCK)
-		return	-EINVAL;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-	if (cl->state != HECI_CL_CONNECTED) {
-		dev_err(&dev->pdev->dev, "host client = %d,  is not connected to ME client = %d",
-			cl->host_client_id, cl->me_client_id);
-		rets = -ENODEV;
-		goto out;
-	}
-
-	if (length <= 0) {
-		rets = -EMSGSIZE;
-		goto out;
-	}
-
-	/* FIXME: check for DMA size for clients that accept DMA transfers */
-	if (length > cl->device->fw_client->props.max_msg_length) {
-		/* If the client supports DMA, try to use it */
-		if (!(host_dma_enabled &&
-				cl->device->fw_client->props.dma_hdr_len &
-				HECI_CLIENT_DMA_ENABLED)) {
-			rets = -EMSGSIZE;
-			goto out;
-		}
-	}
-
-	write_buf = kmalloc(length, GFP_KERNEL);
-	if (!write_buf) {
-		dev_err(&dev->pdev->dev, "write buffer allocation failed\n");
-		rets = -ENOMEM;
-		goto	out;
-	}
-
-	rets = copy_from_user(write_buf, ubuf, length);
-	if (rets)
-		goto out;
-	rets = heci_cl_send(cl, write_buf, length);
-	if (!rets)
-		rets = length;
-	else
-		rets = -EIO;
-out:
-	kfree(write_buf);
-	return rets;
-}
-
-/**
- * heci_ioctl_connect_client - the connect to fw client IOCTL function
- *
- * @dev: the device structure
- * @data: IOCTL connect data, input and output parameters
- * @file: private data of the file object
- *
- * Locking: called under "dev->device_lock" lock
- *
- * returns 0 on success, <0 on failure.
- */
-static int heci_ioctl_connect_client(struct file *file,
-	struct heci_connect_client_data *data)
-{
-	struct heci_device *dev;
-	struct heci_client *client;
-	struct heci_cl *cl;
-	int i;
-	int rets;
-	unsigned long flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	cl = file->private_data;
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	dev = cl->dev;
-
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto end;
-	}
-
-	if (cl->state != HECI_CL_INITIALIZING &&
-	    cl->state != HECI_CL_DISCONNECTED) {
-		rets = -EBUSY;
-		goto end;
-	}
-
-	/* find ME client we're trying to connect to */
-	i = heci_me_cl_by_uuid(dev, &data->in_client_uuid);
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	if (i < 0 || dev->me_clients[i].props.fixed_address) {
-		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
-				&data->in_client_uuid);
-		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-		rets = -ENODEV;
-		goto end;
-	}
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	/* Check if there's driver attached to this UUID */
-	if (!heci_can_client_connect(dev, &data->in_client_uuid))
-		return	-EBUSY;
-
-	cl->me_client_id = dev->me_clients[i].client_id;
-	cl->state = HECI_CL_CONNECTING;
-
-	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
-			cl->me_client_id);
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
-			dev->me_clients[i].props.protocol_version);
-	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
-			dev->me_clients[i].props.max_msg_length);
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	/* prepare the output buffer */
-	client = &data->out_client_properties;
-	spin_lock_irqsave(&dev->me_clients_lock, flags);
-	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
-	client->protocol_version = dev->me_clients[i].props.protocol_version;
-	dev_dbg(&dev->pdev->dev, "Can connect?\n");
-	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
-	rets = heci_cl_connect(cl);
-
-end:
-	ISH_DBG_PRINT(KERN_ALERT "%s(): --- (%d)\n", __func__, rets);
-	return	rets;
-}
-
-
-/**
- * heci_ioctl - the IOCTL function
- *
- * @file: pointer to file structure
- * @cmd: ioctl command
- * @data: pointer to heci message structure
- *
- * returns 0 on success , <0 on error
- */
-static long heci_ioctl(struct file *file, unsigned int cmd, unsigned long data)
-{
-	struct heci_device *dev;
-	struct heci_cl *cl = file->private_data;
-	struct heci_connect_client_data *connect_data = NULL;
-	int rets;
-	unsigned	ring_size;
-	char fw_stat_buf[20];
-
-	if (!cl)
-		return -EINVAL;
-
-	dev = cl->dev;
-	dev_dbg(&dev->pdev->dev, "IOCTL cmd = 0x%x", cmd);
-
-	/* Test API for triggering PCI reset */
-	if (cmd == 0x12341234) {
-		return	heci_hw_reset(dev);
-	}
-
-	/* Test API for triggering host-initiated IPC reset to ISS */
-	if (cmd == 0x12345678) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): ISS FW reset is requested\n",
-			__func__);
-		/* Re-init */
-		dev->dev_state = HECI_DEV_INITIALIZING;
-		heci_reset(dev, 1);
-
-		if (heci_hbm_start_wait(dev)) {
-			dev_err(&dev->pdev->dev, "HBM haven't started");
-			goto err;
-		}
-
-		if (!heci_host_is_ready(dev)) {
-			dev_err(&dev->pdev->dev, "host is not ready.\n");
-			goto err;
-		}
-
-		if (!heci_hw_is_ready(dev)) {
-			dev_err(&dev->pdev->dev, "ME is not ready.\n");
-			goto err;
-		}
-
-		return	0;
-err:
-		dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
-		dev->dev_state = HECI_DEV_DISABLED;
-		return -ENODEV;
-	}
-
-	/* Test API for triggering host disabling */
-	if (cmd == 0xAA55AA55) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): ISS host stop is requested\n",
-			__func__);
-		/* Handle ISS reset against upper layers */
-
-		/* Remove all client devices */
-		heci_bus_remove_all_clients(dev);
-		dev->dev_state = HECI_DEV_DISABLED;
-		return	0;
-	}
-
-	if (cmd == IOCTL_HECI_SET_RX_FIFO_SIZE) {
-		ring_size = data;
-		if (ring_size > CL_MAX_RX_RING_SIZE)
-			return	-EINVAL;
-		if (cl->state != HECI_CL_INITIALIZING)
-			return	-EBUSY;
-		cl->rx_ring_size = ring_size;
-		return	0;
-	}
-
-	if (cmd == IOCTL_HECI_SET_TX_FIFO_SIZE) {
-		ring_size = data;
-		if (ring_size > CL_MAX_TX_RING_SIZE)
-			return	-EINVAL;
-		if (cl->state != HECI_CL_INITIALIZING)
-			return	-EBUSY;
-		cl->tx_ring_size = ring_size;
-		return	0;
-	}
-
-	if (cmd == IOCTL_GET_FW_STATUS) {
-		scnprintf(fw_stat_buf, sizeof(fw_stat_buf),
-			"%08X\n", dev->ops->get_fw_status(dev));
-		copy_to_user((char __user *)data, fw_stat_buf,
-			strlen(fw_stat_buf));
-		return strlen(fw_stat_buf);
-	}
-
-	if (cmd != IOCTL_HECI_CONNECT_CLIENT)
-		return -EINVAL;
-
-	if (WARN_ON(!cl || !cl->dev))
-		return -ENODEV;
-
-	if (dev->dev_state != HECI_DEV_ENABLED) {
-		rets = -ENODEV;
-		goto out;
-	}
-
-	dev_dbg(&dev->pdev->dev, ": IOCTL_HECI_CONNECT_CLIENT.\n");
-
-	connect_data = kzalloc(sizeof(struct heci_connect_client_data),
-							GFP_KERNEL);
-	if (!connect_data) {
-		rets = -ENOMEM;
-		goto out;
-	}
-	dev_dbg(&dev->pdev->dev, "copy connect data from user\n");
-	if (copy_from_user(connect_data, (char __user *)data,
-			sizeof(struct heci_connect_client_data))) {
-		dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
-		rets = -EFAULT;
-		goto out;
-	}
-
-	rets = heci_ioctl_connect_client(file, connect_data);
-
-	/* if all is ok, copying the data back to user. */
-	if (rets)
-		goto out;
-
-	dev_dbg(&dev->pdev->dev, "copy connect data to user\n");
-	if (copy_to_user((char __user *)data, connect_data,
-				sizeof(struct heci_connect_client_data))) {
-		dev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");
-		rets = -EFAULT;
-		goto out;
-	}
-
-out:
-	kfree(connect_data);
-	return rets;
-}
-
-/**
- * heci_compat_ioctl - the compat IOCTL function
- *
- * @file: pointer to file structure
- * @cmd: ioctl command
- * @data: pointer to heci message structure
- *
- * returns 0 on success , <0 on error
- */
-#ifdef CONFIG_COMPAT
-static long heci_compat_ioctl(struct file *file,
-			unsigned int cmd, unsigned long data)
-{
-	return heci_ioctl(file, cmd, (unsigned long)compat_ptr(data));
-}
-#endif /*CONFIG_COMPAT*/
-
-
-/*
- * file operations structure will be used for heci char device.
- */
-static const struct file_operations heci_fops = {
-	.owner = THIS_MODULE,
-	.read = heci_read,
-	.unlocked_ioctl = heci_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = heci_compat_ioctl,
-#endif /*CONFIG_COMPAT*/
-	.open = heci_open,
-	.release = heci_release,
-	.write = heci_write,
-	.llseek = no_llseek
-};
-
-/*
- * Misc Device Struct
- */
-static struct miscdevice  heci_misc_device = {
-		.name = "ish",		/*"heci" changed to "ish", stuff it #2*/
-		.fops = &heci_fops,
-		.minor = MISC_DYNAMIC_MINOR,
-};
-
-int heci_register(struct heci_device *dev)
-{
-	int ret;
-	heci_misc_device.parent = &dev->pdev->dev;
-	ret = misc_register(&heci_misc_device);
-	if (ret)
-		return ret;
-
-	if (heci_dbgfs_register(dev, heci_misc_device.name))
-		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(heci_register);
-
-void heci_deregister(struct heci_device *dev)
-{
-	if (heci_misc_device.parent == NULL)
-		return;
-
-	heci_dbgfs_deregister(dev);
-	misc_deregister(&heci_misc_device);
-	heci_misc_device.parent = NULL;
-}
-EXPORT_SYMBOL_GPL(heci_deregister);
-
-static int __init heci_init(void)
-{
-	return heci_cl_bus_init();
-}
-
-static void __exit heci_exit(void)
-{
-	heci_cl_bus_exit();
-}
-
-module_init(heci_init);
-module_exit(heci_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("Intel(R) Management Engine Interface");
-MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/misc/heci/heci-api.h b/drivers/misc/heci/heci-api.h
deleted file mode 100644
index 7af16a5..0000000
--- a/drivers/misc/heci/heci-api.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/******************************************************************************
- * Intel HECI Interface Header
- *
- * This file is provided under a dual BSD/GPLv2 license.  When using or
- * redistributing this file, you may do so under either license.
- *
- * GPL LICENSE SUMMARY
- *
- * Copyright(c) 2003 - 2015 Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of version 2 of the GNU General Public License as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program;
- *
- * The full GNU General Public License is included in this distribution
- * in the file called LICENSE.GPL.
- *
- * Contact Information:
- *	Intel Corporation.
- *	linux-heci@linux.intel.com
- *	http://www.intel.com
- *
- * BSD LICENSE
- *
- * Copyright(c) 2003 - 2015 Intel Corporation. All rights reserved.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *  * Neither the name Intel Corporation nor the names of its
- *    contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *****************************************************************************/
-
-#ifndef _LINUX_HECI_H
-#define _LINUX_HECI_H
-
-#include <linux/uuid.h>
-
-/*
- * This IOCTL is used to associate the current file descriptor with a
- * FW Client (given by UUID). This opens a communication channel
- * between a host client and a FW client. From this point every read and write
- * will communicate with the associated FW client.
- * Only in close() (file_operation release()) the communication between
- * the clients is disconnected
- *
- * The IOCTL argument is a struct with a union that contains
- * the input parameter and the output parameter for this IOCTL.
- *
- * The input parameter is UUID of the FW Client.
- * The output parameter is the properties of the FW client
- * (FW protocol version and max message size).
- *
- */
-#define IOCTL_HECI_CONNECT_CLIENT	_IOWR('H', 0x01,	\
-				struct heci_connect_client_data)
-
-/* Configuration: set number of Rx/Tx buffers. Must be used before conneciton */
-#define IOCTL_HECI_SET_RX_FIFO_SIZE	_IOWR('H', 0x02, long)
-#define IOCTL_HECI_SET_TX_FIFO_SIZE	_IOWR('H', 0x03, long)
-
-/* Get FW status */
-#define IOCTL_GET_FW_STATUS             _IO('H', 0x04)
-
-/*
- * Intel HECI client information struct
- */
-struct heci_client {
-	__u32 max_msg_length;
-	__u8 protocol_version;
-	__u8 reserved[3];
-};
-
-/*
- * IOCTL Connect Client Data structure
- */
-struct heci_connect_client_data {
-	union {
-		uuid_le in_client_uuid;
-		struct heci_client out_client_properties;
-	};
-};
-
-#endif /* _LINUX_HECI_H  */
-
diff --git a/drivers/misc/heci/heci-hid-client.c b/drivers/misc/heci/heci-hid-client.c
deleted file mode 100644
index 85622c5..0000000
--- a/drivers/misc/heci/heci-hid-client.c
+++ /dev/null
@@ -1,823 +0,0 @@
-/*
- * HECI client driver for HID (ISS)
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/hid.h>
-#include <linux/slab.h>
-#include <linux/timer.h>
-#include <linux/kthread.h>
-#include <linux/uuid.h>
-#include "heci_dev.h"
-#include "client.h"
-#include "heci-hid.h"
-
-/* Rx ring buffer pool size */
-#define RX_RING_SIZE	32
-#define TX_RING_SIZE	16
-
-/* Global vars, may eventually end up in a structure */
-struct heci_cl	*hid_heci_cl = NULL;			/* ISS HECI client */
-
-/* Set when ISS HECI client is successfully probed */
-int	hid_heci_client_found;
-int	may_send;		/* Global flag that determines if sender thread
-				can safely send something or it should
-				wait more */
-int	enum_devices_done;	/* Enum devices response complete flag */
-int	hid_descr_done;		/* Get HID descriptor complete flag */
-int	report_descr_done;	/* Get report descriptor complete flag */
-int	get_report_done;	/* Get Feature/Input report complete flag */
-
-struct device_info	*hid_devices;
-unsigned	cur_hid_dev;
-unsigned	hid_dev_count;
-unsigned	max_hid_devices = /*1*/ MAX_HID_DEVICES;
-unsigned	num_hid_devices;
-unsigned char	*hid_descr[MAX_HID_DEVICES];
-int	hid_descr_size[MAX_HID_DEVICES];
-unsigned char	*report_descr[MAX_HID_DEVICES];
-int	report_descr_size[MAX_HID_DEVICES];
-struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
-
-static wait_queue_head_t	init_wait;
-wait_queue_head_t	heci_hid_wait;
-static unsigned	bad_recv_cnt;
-static int	multi_packet_cnt;
-
-/*flush notification*/
-void (*flush_cb)(void);
-static int	init_done;
-
-
-static void	report_bad_packet(void *recv_buf, size_t cur_pos, size_t payload_len)
-{
-	struct hostif_msg	*recv_msg = recv_buf;
-
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: BAD packet %02X\n",
-		recv_msg->hdr.command);
-	dev_err(&hid_heci_cl->device->dev, "total_bad=%u cur_pos=%u\n",
-		bad_recv_cnt, cur_pos);
-	dev_err(&hid_heci_cl->device->dev, "[%02X %02X %02X %02X]\n",
-		((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1],
-		((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: payload_len=%u\n",
-		payload_len);
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: multi_packet_cnt=%u\n",
-		multi_packet_cnt);
-	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: is_response=%02X\n",
-		recv_msg->hdr.command & ~CMD_MASK);
-}
-
-
-/* HECI client driver structures and API for bus interface */
-static void	process_recv(void *recv_buf, size_t data_len)
-{
-	struct hostif_msg	*recv_msg;
-	unsigned char	*payload;
-	/*size_t	size;*/
-	struct device_info	*dev_info;
-	int	i, j;
-	size_t	payload_len, total_len, cur_pos;
-	int	report_type;
-
-	struct report_list *reports_list;
-	char *reports;
-	size_t report_len;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++ len=%u\n", __func__,
-		(unsigned)data_len);
-
-	if (data_len < sizeof(struct hostif_msg_hdr)) {
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: error, received %u which is ",
-			(unsigned)data_len);
-		dev_err(&hid_heci_cl->device->dev,
-			" less than data header %u\n",
-			(unsigned)sizeof(struct hostif_msg_hdr));
-		++bad_recv_cnt;
-		heci_hw_reset(hid_heci_cl->dev);
-		return;
-	}
-
-	payload = recv_buf + sizeof(struct hostif_msg_hdr);
-	total_len = data_len;
-	cur_pos = 0;
-
-	may_send = 0;
-
-	do {
-		recv_msg = (struct hostif_msg *)(recv_buf + cur_pos);
-		payload_len = recv_msg->hdr.size;
-
-		/* Sanity checks */
-		if (cur_pos + payload_len + sizeof(struct hostif_msg) >
-				total_len) {
-			++bad_recv_cnt;
-			report_bad_packet(recv_msg, cur_pos, payload_len);
-			heci_hw_reset(hid_heci_cl->dev);
-			break;
-		}
-
-
-		switch (recv_msg->hdr.command & CMD_MASK) {
-		default:
-			++bad_recv_cnt;
-			report_bad_packet(recv_msg, cur_pos, payload_len);
-			heci_hw_reset(hid_heci_cl->dev);
-			break;
-
-		case HOSTIF_DM_ENUM_DEVICES:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): HOSTIF_DM_ENUM_DEVICES [cur_pos=%u] [%02X %02X %02X %02X]\n",
-				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
-			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
-					init_done)) {
-				++bad_recv_cnt;
-				report_bad_packet(recv_msg, cur_pos,
-					payload_len);
-				heci_hw_reset(hid_heci_cl->dev);
-				break;
-			}
-			hid_dev_count = (unsigned)*payload;
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): hid_dev_count=%d\n",
-				__func__, hid_dev_count);
-			hid_devices = kmalloc(hid_dev_count *
-				sizeof(struct device_info), GFP_KERNEL);
-			if (hid_devices)
-				memset(hid_devices, 0, hid_dev_count *
-					sizeof(struct device_info));
-
-			for (i = 0; i < hid_dev_count; ++i) {
-				if (1 + sizeof(struct device_info) * i >=
-						payload_len) {
-					dev_err(&hid_heci_cl->device->dev,
-						"[hid-ish]: [ENUM_DEVICES]:");
-					dev_err(&hid_heci_cl->device->dev,
-						" content size %lu ", 1 +
-						sizeof(struct device_info) *
-						i);
-					dev_err(&hid_heci_cl->device->dev,
-						"is bigger than ");
-					dev_err(&hid_heci_cl->device->dev,
-						"payload_len %u\n",
-						(unsigned)payload_len);
-				}
-
-				if (1 + sizeof(struct device_info) * i >=
-						data_len)
-					break;
-
-				dev_info = (struct device_info *)(payload + 1 +
-					sizeof(struct device_info) * i);
-				ISH_DBG_PRINT(KERN_ALERT
-					"[hid-ish]: %s(): [%d] -- dev_id=%08X dev_class=%02X pid=%04X vid=%04X\n",
-					__func__, i, dev_info->dev_id,
-					dev_info->dev_class, dev_info->pid,
-					dev_info->vid);
-				if (hid_devices)
-					memcpy(hid_devices + i, dev_info,
-						sizeof(struct device_info));
-			}
-
-			enum_devices_done = 1;
-			if (waitqueue_active(&init_wait))
-				wake_up(&init_wait);
-
-			break;
-
-		case HOSTIF_GET_HID_DESCRIPTOR:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_GET_HID_DESCRIPTOR [cur_pos=%u] [%02X %02X %02X %02X]\n",
-				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): dump HID descriptor\n",
-				__func__);
-			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
-					init_done)) {
-				++bad_recv_cnt;
-				report_bad_packet(recv_msg, cur_pos,
-					payload_len);
-				heci_hw_reset(hid_heci_cl->dev);
-				break;
-			}
-			for (i = 0; i < payload_len; ++i)
-				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
-			ISH_DBG_PRINT(KERN_ALERT "\n");
-			hid_descr[cur_hid_dev] = kmalloc(payload_len,
-				GFP_KERNEL);
-			if (hid_descr[cur_hid_dev])
-				memcpy(hid_descr[cur_hid_dev], payload,
-					payload_len);
-			hid_descr_size[cur_hid_dev] = payload_len;
-
-			hid_descr_done = 1;
-			if (waitqueue_active(&init_wait))
-				wake_up(&init_wait);
-
-			break;
-
-		case HOSTIF_GET_REPORT_DESCRIPTOR:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_GET_REPORT_DESCRIPTOR [cur_pos=%u] [%02X %02X %02X %02X]\n",
-				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): Length of report descriptor is %u\n",
-				__func__, (unsigned)payload_len);
-			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
-					init_done)) {
-				++bad_recv_cnt;
-				report_bad_packet(recv_msg, cur_pos,
-					payload_len);
-				heci_hw_reset(hid_heci_cl->dev);
-				break;
-			}
-			report_descr[cur_hid_dev] = kmalloc(payload_len,
-				GFP_KERNEL);
-			if (report_descr[cur_hid_dev])
-				memcpy(report_descr[cur_hid_dev], payload,
-					payload_len);
-			report_descr_size[cur_hid_dev] = payload_len;
-
-			report_descr_done = 1;
-			if (waitqueue_active(&init_wait))
-				wake_up(&init_wait);
-
-			break;
-
-		case HOSTIF_GET_FEATURE_REPORT:
-			report_type = HID_FEATURE_REPORT;
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_GET_FEATURE_REPORT\n",
-				__func__);
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): dump Get Feature Result\n",
-				__func__);
-			flush_cb(); /*each "GET_FEATURE_REPORT" ends a batch*/
-			goto	do_get_report;
-
-		case HOSTIF_GET_INPUT_REPORT:
-			report_type = HID_INPUT_REPORT;
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_GET_INPUT_REPORT\n",
-				__func__);
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): dump Get Input Result\n",
-				__func__);
-do_get_report:
-			for (i = 0; i < payload_len; ++i)
-				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
-			ISH_DBG_PRINT(KERN_ALERT "\n");
-
-
-			/* Get index of device that matches this id */
-			for (i = 0; i < num_hid_devices; ++i)
-				if (recv_msg->hdr.device_id ==
-						hid_devices[i].dev_id)
-					if (hid_sensor_hubs[i] != NULL) {
-						hid_input_report(
-							hid_sensor_hubs[i],
-							report_type, payload,
-							payload_len, 0);
-						break;
-					}
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): received input report, upstreaming\n",
-				__func__);
-			get_report_done = 1;
-			if (waitqueue_active(&heci_hid_wait))
-				wake_up(&heci_hid_wait);
-			break;
-
-		case HOSTIF_SET_FEATURE_REPORT:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): HOSTIF_SET_FEATURE_REPORT returned status=%02X\n",
-				__func__, recv_msg->hdr.status);
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): received feature report, upstreaming\n",
-				__func__);
-			get_report_done = 1;
-			if (waitqueue_active(&heci_hid_wait))
-				wake_up(&heci_hid_wait);
-			break;
-
-		case HOSTIF_PUBLISH_INPUT_REPORT:
-			report_type = HID_INPUT_REPORT;
-			do {
-				ISH_DBG_PRINT(KERN_ALERT
-					"[hid-ish]: %s(): received ASYNC DATA REPORT [payload_len=%u]. Dump data:\n",
-					__func__, (unsigned)payload_len);
-				for (i = 0; i < payload_len; ++i)
-					ISH_DBG_PRINT(KERN_ALERT "%02X\n",
-						payload[i]);
-			} while (0);
-
-			for (i = 0; i < num_hid_devices; ++i)
-				if (recv_msg->hdr.device_id ==
-						hid_devices[i].dev_id)
-					if (hid_sensor_hubs[i] != NULL)
-						hid_input_report(
-							hid_sensor_hubs[i],
-							report_type, payload,
-							payload_len, 0);
-			break;
-
-		case HOSTIF_PUBLISH_INPUT_REPORT_LIST:
-			ISH_DBG_PRINT(KERN_ALERT
-				"[hid-ish]: %s(): received HOSTIF_PUBLISH_INPUT_REPORT_LIST\n",
-				__func__);
-
-			report_type = HID_INPUT_REPORT;
-			reports_list = (struct report_list *)payload;
-			reports = (char *)reports_list->reports;
-
-			for (j = 0; j < reports_list->num_of_reports; j++) {
-				recv_msg = (struct hostif_msg *)(reports +
-					sizeof(uint16_t));
-				report_len = *(uint16_t *)reports;
-				payload = reports + sizeof(uint16_t) +
-					sizeof(struct hostif_msg_hdr);
-				payload_len = report_len -
-					sizeof(struct hostif_msg_hdr);
-
-				ISH_DBG_PRINT(KERN_ALERT
-					"[hid-ish]: %s(): report #%d, report_len: %d, payload_len: %d, device_id: %d, payload Data\n",
-					__func__, j, (int)report_len,
-					(int)payload_len,
-					(int)recv_msg->hdr.device_id);
-				for (i = 0; i < payload_len; ++i)
-					ISH_DBG_PRINT(KERN_ALERT "%02X ",
-						payload[i]);
-				ISH_DBG_PRINT(KERN_ALERT "\n");
-
-				for (i = 0; i < num_hid_devices; ++i)
-					if (recv_msg->hdr.device_id ==
-							hid_devices[i].dev_id &&
-							hid_sensor_hubs[i] !=
-							NULL) {
-						hid_input_report(
-							hid_sensor_hubs[i],
-							report_type,
-							payload, payload_len,
-							0);
-					}
-
-				reports += sizeof(uint16_t) + report_len;
-			}
-			break;
-
-		}
-
-		if (!cur_pos && cur_pos + payload_len +
-				sizeof(struct hostif_msg) < total_len)
-			++multi_packet_cnt;
-
-		cur_pos += payload_len + sizeof(struct hostif_msg);
-		payload += payload_len + sizeof(struct hostif_msg);
-
-	} while (cur_pos < total_len);
-	may_send = 1;
-}
-
-
-void ish_cl_event_cb(struct heci_cl_device *device, u32 events, void *context)
-{
-	size_t r_length;
-	struct heci_cl_rb *rb_in_proc;
-	unsigned long	flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s() +++\n", __func__);
-
-	if (!hid_heci_cl)
-		return;
-
-	spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
-	while (!list_empty(&hid_heci_cl->in_process_list.list)) {
-		rb_in_proc = list_entry(hid_heci_cl->in_process_list.list.next,
-			struct heci_cl_rb, list);
-		list_del_init(&rb_in_proc->list);
-		spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock,
-			flags);
-
-		if (!rb_in_proc->buffer.data) {
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): !rb_in_proc-->buffer.data, something's wrong\n",
-				__func__);
-			return;
-		}
-		r_length = rb_in_proc->buf_idx;
-		ISH_DBG_PRINT(KERN_ALERT
-			"%s(): OK received buffer of %u length\n", __func__,
-			(unsigned)r_length);
-
-		/* decide what to do with received data */
-		process_recv(rb_in_proc->buffer.data, r_length);
-
-		heci_io_rb_recycle(rb_in_proc);
-		spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
-	}
-	spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock, flags);
-}
-
-void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len,
-	int report_id)
-{
-	int	rv;
-	struct hostif_msg *msg = (struct hostif_msg *)buf;
-	int	i;
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): writing SET FEATURE REPORT\n", __func__);
-	memset(msg, 0, sizeof(struct hostif_msg));
-	msg->hdr.command = HOSTIF_SET_FEATURE_REPORT;
-	for (i = 0; i < num_hid_devices; ++i)
-		if (hid == hid_sensor_hubs[i]) {
-			msg->hdr.device_id = hid_devices[i].dev_id;
-			break;
-		}
-	if (i == num_hid_devices)
-		return;
-
-	rv = heci_cl_send(hid_heci_cl, buf, len);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
-}
-
-
-void hid_heci_get_report(struct hid_device *hid, int report_id, int report_type)
-{
-	int	rv;
-	static unsigned char	buf[10];
-	unsigned	len;
-	struct hostif_msg_to_sensor *msg = (struct hostif_msg_to_sensor *)buf;
-	int	i;
-
-	len = sizeof(struct hostif_msg_to_sensor);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): writing GET REPORT of type: %d\n", __func__,
-		report_type);
-	memset(msg, 0, sizeof(struct hostif_msg_to_sensor));
-	msg->hdr.command = (report_type == HID_FEATURE_REPORT) ?
-		HOSTIF_GET_FEATURE_REPORT : HOSTIF_GET_INPUT_REPORT;
-	for (i = 0; i < num_hid_devices; ++i)
-		if (hid == hid_sensor_hubs[i]) {
-			msg->hdr.device_id = hid_devices[i].dev_id;
-			/*
-			 * FIXME - temporary when single collection exists,
-			 * then has to be part of hid_device custom fields
-			 */
-			break;
-		}
-	if (i == num_hid_devices)
-		return;
-
-	msg->report_id = report_id;
-	rv = heci_cl_send(hid_heci_cl, buf, len);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
-}
-
-struct work_struct my_work;
-
-int	hid_heci_cl_probe(struct heci_cl_device *cl_device,
-	const struct heci_cl_device_id *id)
-{
-	int	rv;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	if (!cl_device)
-		return	-ENODEV;
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): dev != NULL && dev->cl != NULL /* OK */\n",
-		__func__);
-	if (uuid_le_cmp(ish_heci_guid,
-			cl_device->fw_client->props.protocol_name) != 0) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): device doesn't match\n",
-			__func__);
-		return	-ENODEV;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): device matches!\n", __func__);
-	hid_heci_cl = heci_cl_allocate(cl_device->heci_dev);
-	if (!hid_heci_cl)
-		return	-ENOMEM;
-
-	rv = heci_cl_link(hid_heci_cl, HECI_HOST_CLIENT_ID_ANY);
-	if (rv)
-		return	-ENOMEM;
-
-	hid_heci_client_found = 1;
-	if (waitqueue_active(&init_wait))
-		wake_up(&init_wait);
-
-	schedule_work(&my_work);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() enqueue init_work function\n",
-		__func__);
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return	0;
-
-	/*
-	 * Linux generic drivers framework doesn't like probe() functions
-	 * to start kernel threads
-	 */
-}
-
-
-int     hid_heci_cl_remove(struct heci_cl_device *dev)
-{
-	int i;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	heci_hid_remove();
-	hid_heci_client_found = 0;
-	hid_heci_cl = NULL;
-
-	for (i = 0; i < num_hid_devices ; ++i) {
-		/* kfree(NULL) is safe */
-		kfree(hid_descr[i]);
-		/* kfree(NULL) is safe */
-		kfree(report_descr[i]);
-	}
-	num_hid_devices = 0;
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return  0;
-}
-
-
-struct heci_cl_driver	hid_heci_cl_driver = {
-	.name = "ish",
-	.probe = hid_heci_cl_probe,
-	.remove = hid_heci_cl_remove,
-};
-
-
-/****************************************************************/
-
-void workqueue_init_function(struct work_struct *work)
-{
-	int	rv;
-	static unsigned char	buf[4096];
-	unsigned	len;
-	struct hostif_msg	*msg = (struct hostif_msg *)buf;
-	int	i;
-	struct heci_device	*dev;
-	int	retry_count;
-
-	init_done = 0;
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() in workqueue func, continue initialization process\n",
-		__func__);
-
-	if (!hid_heci_client_found)
-		wait_event_timeout(init_wait, hid_heci_client_found, 30 * HZ);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() completed waiting for hid_heci_client_found[=%d]\n",
-		__func__, hid_heci_client_found);
-
-	if (!hid_heci_client_found) {
-		printk(KERN_ERR "[hid-ish]: timed out waiting for hid_heci_client_found\n");
-		rv = -ENODEV;
-		goto	ret;
-	}
-
-	dev = hid_heci_cl->dev;
-
-	/* Connect to FW client */
-	hid_heci_cl->rx_ring_size = RX_RING_SIZE;
-	hid_heci_cl->tx_ring_size = TX_RING_SIZE;
-
-	i = heci_me_cl_by_uuid(dev, &ish_heci_guid);
-	hid_heci_cl->me_client_id = dev->me_clients[i].client_id;
-	hid_heci_cl->state = HECI_CL_CONNECTING;
-
-	rv = heci_cl_connect(hid_heci_cl);
-	if (rv)
-		goto	ret;
-
-	/* Register read callback */
-	heci_register_event_cb(hid_heci_cl->device, ish_cl_event_cb, NULL);
-
-#if 0
-	/*
-	 * Wait until we can send without risking flow-control break scenario
-	 * (sending OUR FC ahead of message, so that FW will respond)
-	 * We probably need here only a small delay in order to let our FC
-	 * to be sent over to FW
-	 */
-	schedule_timeout(WAIT_FOR_SEND_SLICE);
-#endif
-
-	/* Send HOSTIF_DM_ENUM_DEVICES */
-	memset(msg, 0, sizeof(struct hostif_msg));
-	msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
-	len = sizeof(struct hostif_msg);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() writing HOSTIF_DM_ENUM_DEVICES len = %u\n",
-		__func__, len);
-	rv = heci_cl_send(hid_heci_cl, buf, len);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() heci_cl_send() returned %d\n",
-		__func__, rv);
-	if (rv)
-		goto	ret;
-
-	rv = 0;
-
-	retry_count = 0;
-	while (!enum_devices_done && retry_count < 10) {
-		wait_event_timeout(init_wait, enum_devices_done, 3 * HZ);
-		++retry_count;
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
-			enum_devices_done, retry_count);
-		if (!enum_devices_done) {
-			/* Send HOSTIF_DM_ENUM_DEVICES */
-			memset(msg, 0, sizeof(struct hostif_msg));
-			msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
-			len = sizeof(struct hostif_msg);
-			rv = heci_cl_send(hid_heci_cl, buf, len);
-		}
-	}
-	dev_err(&hid_heci_cl->device->dev,
-		"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
-		enum_devices_done, retry_count);
-
-	if (!enum_devices_done) {
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: timed out waiting for enum_devices_done\n");
-		rv = -ETIMEDOUT;
-		goto	ret;
-	}
-	if (!hid_devices) {
-		dev_err(&hid_heci_cl->device->dev,
-			"[hid-ish]: failed to allocate HID dev structures\n");
-		rv = -ENOMEM;
-		goto	ret;
-	}
-
-	/* Send GET_HID_DESCRIPTOR for each device */
-
-	/*
-	 * Temporary work-around for multi-descriptor traffic:
-	 * read only the first one
-	 * Will be removed when multi-TLC are supported
-	 */
-
-	num_hid_devices = hid_dev_count;
-	dev_err(&hid_heci_cl->device->dev,
-		"[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n",
-		num_hid_devices);
-
-
-	for (i = 0; i < num_hid_devices /*hid_dev_count*/; ++i) {
-		cur_hid_dev = i;
-
-		/* Get HID descriptor */
-		hid_descr_done = 0;
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): [%d] writing HOSTIF_GET_HID_DESCRIPTOR\n",
-			__func__, i);
-		memset(msg, 0, sizeof(struct hostif_msg));
-		msg->hdr.command = HOSTIF_GET_HID_DESCRIPTOR;
-		msg->hdr.device_id = hid_devices[i].dev_id;
-		len = sizeof(struct hostif_msg);
-		rv = heci_cl_send(hid_heci_cl, buf, len);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_HID_DESCRIPTOR] returned %d\n",
-			__func__, rv);
-		rv = 0;
-#ifdef HOST_VIRTUALBOX
-		timed_wait_for(WAIT_FOR_SEND_SLICE, hid_descr_done);
-#else
-		if (!hid_descr_done)
-			wait_event_timeout(init_wait, hid_descr_done, 30 * HZ);
-#endif
-		if (!hid_descr_done) {
-			printk(KERN_ERR "[hid-ish]: timed out waiting for hid_descr_done\n");
-			continue;
-		}
-
-		if (!hid_descr[i]) {
-			printk(KERN_ERR "[hid-ish]: failed to allocate HID descriptor buffer\n");
-			continue;
-		}
-
-		/* Get report descriptor */
-		report_descr_done = 0;
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): [%d] writing HOSTIF_GET_REPORT_DESCRIPTOR\n",
-			__func__, i);
-		memset(msg, 0, sizeof(struct hostif_msg));
-		msg->hdr.command = HOSTIF_GET_REPORT_DESCRIPTOR;
-		msg->hdr.device_id = hid_devices[i].dev_id;
-		len = sizeof(struct hostif_msg);
-		rv = heci_cl_send(hid_heci_cl, buf, len);
-
-		ISH_DBG_PRINT(KERN_ALERT
-			"[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_REPORT_DESCRIPTOR] returned %d\n",
-			__func__, rv);
-		rv = 0;
-#ifdef HOST_VIRTUALBOX
-		timed_wait_for(WAIT_FOR_SEND_SLICE, report_descr_done);
-#else
-		if (!report_descr_done)
-			wait_event_timeout(init_wait, report_descr_done,
-				30 * HZ);
-#endif
-		if (!report_descr_done) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: timed out wait for report descr\n");
-			continue;
-		}
-
-		if (!report_descr[i]) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: failed to alloc report descr\n");
-			continue;
-		}
-
-		rv = heci_hid_probe(i);
-		if (rv) {
-			dev_err(&hid_heci_cl->device->dev,
-				"[hid-ish]: HID probe for #%u failed: %d\n",
-				i, rv);
-			continue;
-		}
-	} /* for() */
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish] %s() in workqueue func, finished initialization process\n",
-		__func__);
-
-ret:
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish] %s() :in ret label --- returning %d\n", __func__,
-		rv);
-	init_done = 1;
-}
-/****************************************************************/
-
-
-static int __init ish_init(void)
-{
-	int	rv;
-
-	ISH_INFO_PRINT(KERN_ERR "[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
-		__func__);
-	g_ish_print_log(
-		"[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
-		__func__);
-
-	init_waitqueue_head(&init_wait);
-	init_waitqueue_head(&heci_hid_wait);
-	/* Register HECI client device driver - ISS */
-	rv = heci_cl_driver_register(&hid_heci_cl_driver);
-
-	/*
-	 * 7/7/2014: in order to not stick Android boot, from here & below
-	 * needs to run in work queue and here we should return rv
-	 */
-	/****************************************************************/
-	INIT_WORK(&my_work, workqueue_init_function);
-	/***************************************************************/
-	return rv;
-
-}
-
-
-static void __exit ish_exit(void)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++\n", __func__);
-	heci_cl_driver_unregister(&hid_heci_cl_driver);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): unregistered from HECI bus\n", __func__);
-	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():---\n", __func__);
-}
-
-module_init(ish_init);
-module_exit(ish_exit);
-
-MODULE_DESCRIPTION("ISS HECI client driver");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/misc/heci/heci-hid.c b/drivers/misc/heci/heci-hid.c
deleted file mode 100644
index d692cb19..0000000
--- a/drivers/misc/heci/heci-hid.c
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * HECI-HID glue driver.
- *
- * Copyright (c) 2012-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/device.h>
-#include <linux/hid.h>
-#include <linux/module.h>
-#include <linux/timer.h>
-#include <linux/kthread.h>
-#include "heci-hid.h"
-#include "platform-config.h"
-#include "client.h"
-
-/*
- * TODO - figure out if this number is used for anything but assignment.
- * BUS_I2C is not
- */
-#define	BUS_HECI	0x44
-/* TODO: just to bootstrap, numbers will probably change */
-#define	ISH_HID_VENDOR	0x8086
-#define	ISH_HID_PRODUCT	0x22D8
-#define	ISH_HID_VERSION	0x0200
-
-static int heci_hid_parse(struct hid_device *hid)
-{
-	int	rv;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
-
-	rv = hid_parse_report(hid, report_descr[cur_hid_dev],
-		report_descr_size[cur_hid_dev]);
-	if (rv) {
-		ISH_DBG_PRINT(KERN_ALERT
-			"[heci-hid] %s(): parsing report descriptor failed\n",
-			__func__);
-		return	rv;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[heci-hid] %s(): parsing report descriptor succeeded\n",
-		__func__);
-	return 0;
-}
-
-static int heci_hid_start(struct hid_device *hid)
-{
-	return 0;
-}
-
-/* should we free smth? */
-static void heci_hid_stop(struct hid_device *hid)
-{
-	return;
-}
-
-/* probably connect might be here (move from probe) */
-static int heci_hid_open(struct hid_device *hid)
-{
-	return 0;
-}
-
-
-/* naturally if connect in open, disconnect here */
-static void ish_heci_close(struct hid_device *hid)
-{
-	return;
-}
-
-static int heci_hid_power(struct hid_device *hid, int lvl)
-{
-	return 0;
-}
-
-
-
-static void heci_hid_request(struct hid_device *hid, struct hid_report *rep,
-	int reqtype)
-{
-	/* the specific report length, just HID part of it */
-	unsigned len = ((rep->size - 1) >> 3) + 1 + (rep->id > 0);
-	char *buf;
-	/* s32 checkValue = 0; */
-	/* int i = 0; */
-	unsigned header_size =  sizeof(struct hostif_msg);
-
-	len += header_size;
-
-	switch (reqtype) {
-	case HID_REQ_GET_REPORT:
-		hid_heci_get_report(hid, rep->id, rep->type);
-		break;
-	case HID_REQ_SET_REPORT:
-		buf = kzalloc(len, GFP_KERNEL);
-		if (!buf)
-			return;
-		hid_output_report(rep, buf + header_size);
-	/* checkValue = rep->field[3]->value[0]; */
-	/* ISH_DBG_PRINT(KERN_ALERT
-		"[hid-ish]: %s(): after hid_output_report value is %d\n",
-		__func__, checkValue);	 */
-	/* for(;i < len; i++) */
-	/*   ISH_DBG_PRINT("\n%d %d\n", i, (int) buf[i]); */
-		hid_heci_set_feature(hid, buf, len, rep->id);
-		kfree(buf);
-		break;
-	}
-
-	return;
-}
-
-
-static int heci_hid_hidinput_input_event(struct input_dev *dev,
-		unsigned int type, unsigned int code, int value)
-{
-	return 0;
-}
-
-
-static int heci_wait_for_response(struct hid_device *hid)
-{
-	ISH_DBG_PRINT(KERN_ALERT "%s() +++\n", __func__);
-#ifdef HOST_VIRTUALBOX
-	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, get_report_done, (10 * HZ));
-#else
-	if (!get_report_done)
-		wait_event_timeout(heci_hid_wait, get_report_done, 3 * HZ);
-
-#endif
-	if (!get_report_done) {
-		hid_err(hid, "timeout waiting for response from HECI device\n");
-		return -1;
-	}
-
-	get_report_done = 0;
-	return 0;
-}
-
-
-static struct hid_ll_driver heci_hid_ll_driver = {
-	.parse = heci_hid_parse,
-	.start = heci_hid_start,
-	.stop = heci_hid_stop,
-	.open = heci_hid_open,
-	.close = ish_heci_close,
-	.power = heci_hid_power,
-	.request = heci_hid_request,
-	.hidinput_input_event = heci_hid_hidinput_input_event,
-	.wait = heci_wait_for_response
-};
-
-
-struct tmp_heci_data {
-	int hdesc_length;
-	struct task_struct	*read_task;
-};
-
-static int heci_hid_get_raw_report(struct hid_device *hid,
-	unsigned char report_number, __u8 *buf, size_t count,
-	unsigned char report_type)
-{
-	return	0;
-}
-
-static int heci_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
-	size_t count, unsigned char report_type)
-{
-	return	0;
-}
-
-/*
- * probably the best way make it driver probe so it will create device with
- * itself as ll_driver, as usb and i2c do
- */
-int	heci_hid_probe(unsigned cur_hid_dev)
-{
-	int rv;
-	struct hid_device	*hid;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
-
-	hid = hid_allocate_device();
-	if (IS_ERR(hid)) {
-		rv = PTR_ERR(hid);
-		return	-ENOMEM;
-	}
-
-	hid_sensor_hubs[cur_hid_dev] = hid;
-
-	hid->ll_driver = &heci_hid_ll_driver;
-	hid->hid_get_raw_report = heci_hid_get_raw_report;
-	hid->hid_output_raw_report = heci_hid_output_raw_report;
-	hid->bus = BUS_HECI;
-	hid->version = le16_to_cpu(ISH_HID_VERSION);
-	hid->vendor = le16_to_cpu(ISH_HID_VENDOR);
-	hid->product = le16_to_cpu(ISH_HID_PRODUCT);
-
-	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX", "hid-heci",
-		hid->vendor, hid->product);
-
-	rv = hid_add_device(hid);
-	if (rv) {
-		if (rv != -ENODEV)
-			hid_err(hid, "[hid-heci]: can't add HID device: %d\n",
-				rv);
-		kfree(hid);
-		return	rv;
-	}
-
-#if 0
-	/* Initialize all reports */
-	list_for_each_entry(report,
-		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
-		hid_heci_get_report(hid, report->id, HID_FEATURE_REPORT);
-#endif
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
-	return 0;
-}
-
-void	heci_hid_remove(void)
-{
-	int	i;
-
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
-	for (i = 0; i < num_hid_devices; ++i)
-		if (hid_sensor_hubs[i]) {
-			hid_destroy_device(hid_sensor_hubs[i]);
-			hid_sensor_hubs[i] = NULL;
-		}
-	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
-}
-
-void register_flush_cb(void (*flush_cb_func)(void))
-{
-	flush_cb = flush_cb_func;
-}
-EXPORT_SYMBOL_GPL(register_flush_cb);
-
diff --git a/drivers/misc/heci/heci-hid.h b/drivers/misc/heci/heci-hid.h
deleted file mode 100644
index 62c1e5b..0000000
--- a/drivers/misc/heci/heci-hid.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * HECI-HID glue driver's definitions.
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-#ifndef HECI_HID__H
-#define	HECI_HID__H
-
-/*
- * Constraint 1: currently we support only 1 ISS HW controller in a system
- */
-
-static const uuid_le ish_heci_guid = UUID_LE(0x33AECD58, 0xB679, 0x4E54,
-						0x9B, 0xD9, 0xA0, 0x4D, 0x34,
-						0xF0, 0xC2, 0x26);
-
-extern wait_queue_head_t	heci_hid_wait;
-
-/*flush notification*/
-extern void (*flush_cb)(void);
-
-struct hostif_msg_hdr {
-	uint8_t	command;	/* Bit 7: is_response */
-#define	CMD_MASK	0x7F
-#define	IS_RESPONSE	0x80
-	uint8_t	device_id;
-	uint8_t	status;
-	uint8_t	flags;
-	uint16_t	size;
-} __packed;
-
-struct hostif_msg {
-	struct hostif_msg_hdr	hdr;
-} __packed;
-
-struct hostif_msg_to_sensor {
-	struct hostif_msg_hdr	hdr;
-	uint8_t	report_id;
-} __packed;
-
-struct device_info {
-	uint32_t	dev_id;
-	uint8_t		dev_class;
-	uint16_t	pid;
-	uint16_t	vid;
-} __packed;
-
-#if 0
-/* Needed? */
-struct heci_client {
-	uint32_t	max_msg_len;
-	uint8_t		proto_ver;
-} __packed;
-#endif
-
-struct heci_version {
-	uint8_t	major;
-	uint8_t	minor;
-	uint8_t	hotfix;
-	uint16_t	build;
-} __packed;
-
-/*
- * struct for heci aggregated input data
- */
-struct report_list {
-	uint16_t total_size;
-	uint8_t  num_of_reports;
-	uint8_t  flags;
-	struct {
-		uint16_t  size_of_report;
-		uint8_t report[1];
-	} __packed reports[1];
-} __packed;
-
-/* HOSTIF commands */
-#define	HOSTIF_HID_COMMAND_BASE		0
-#define	HOSTIF_GET_HID_DESCRIPTOR	0
-#define	HOSTIF_GET_REPORT_DESCRIPTOR	1
-#define HOSTIF_GET_FEATURE_REPORT	2
-#define	HOSTIF_SET_FEATURE_REPORT	3
-#define	HOSTIF_GET_INPUT_REPORT		4
-#define	HOSTIF_PUBLISH_INPUT_REPORT	5
-/*#define	HOSTIF_GET_OUTPUT_REPORT	6*/
-/*#define	HOSTIF_SET_OUTPUT_REPORT	7*/
-#define	HOSTIF_PUBLISH_INPUT_REPORT_LIST	6
-#define	HOSTIF_DM_COMMAND_BASE		32
-#define	HOSTIF_DM_ENUM_DEVICES		33
-#define	HOSTIF_DM_ADD_DEVICE		34
-
-/* Meaning, too large data source = "over 9000?" :-) */
-#define	MAX_DATA_BUF	9000
-
-#define	MAX_HID_DEVICES	32
-
-#include "utils.h"
-
-extern unsigned char	*report_descr[MAX_HID_DEVICES];
-extern int	report_descr_size[MAX_HID_DEVICES];
-extern struct device_info	*hid_devices;
-extern int	may_send;
-extern int	get_report_done; /* Get Feature/Input report complete flag */
-extern unsigned	cur_hid_dev;
-extern struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
-extern unsigned	num_hid_devices;
-extern struct heci_cl  *hid_heci_cl;	/* HECI client */
-
-void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len,
-	int report_id);
-void hid_heci_get_report(struct hid_device *hid, int report_id,
-	int report_type);
-
-int	heci_hid_probe(unsigned cur_hid_dev);
-void	heci_hid_remove(void);
-
-/*flush notification*/
-void register_flush_cb(void (*flush_cb_func)(void));
-
-/*********** Locally redirect ISH_DBG_PRINT **************/
-void g_ish_print_log(char *format, ...);
-/*********************************************************/
-
-#endif	/* HECI_HID__H */
-
diff --git a/drivers/misc/heci/heci_dev.h b/drivers/misc/heci/heci_dev.h
deleted file mode 100644
index bc857c5..0000000
--- a/drivers/misc/heci/heci_dev.h
+++ /dev/null
@@ -1,351 +0,0 @@
-/*
- * Most HECI provider device and HECI logic declarations
- *
- * Copyright (c) 2003-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef _HECI_DEV_H_
-#define _HECI_DEV_H_
-
-#include "platform-config.h"
-#include <linux/types.h>
-#include <linux/watchdog.h>
-#include <linux/poll.h>
-#include "bus.h"
-#include "hbm.h"
-#include <linux/spinlock.h>
-
-#define	IPC_PAYLOAD_SIZE	128
-#define HECI_RD_MSG_BUF_SIZE	IPC_PAYLOAD_SIZE
-/* Number of messages to be held in ISR->BH FIFO */
-#define	RD_INT_FIFO_SIZE	64
-#define	IPC_FULL_MSG_SIZE	132
-/*
- * Number of IPC messages to be held in Tx FIFO, to be sent by ISR -
- * Tx complete interrupt or RX_COMPLETE handler
- */
-#define	IPC_TX_FIFO_SIZE	512
-
-/*
- * Number of Maximum HECI Clients
- */
-#define HECI_CLIENTS_MAX 256
-
-/*
- * Number of File descriptors/handles
- * that can be opened to the driver.
- *
- * Limit to 255: 256 Total Clients
- * minus internal client for HECI Bus Messags
- */
-#define  HECI_MAX_OPEN_HANDLE_COUNT (HECI_CLIENTS_MAX - 1)
-
-/*
- * Internal Clients Number
- */
-#define HECI_HOST_CLIENT_ID_ANY        (-1)
-#define HECI_HBM_HOST_CLIENT_ID         0 /* not used, just for documentation */
-
-/* HECI device states */
-enum heci_dev_state {
-	HECI_DEV_INITIALIZING = 0,
-	HECI_DEV_INIT_CLIENTS,
-	HECI_DEV_ENABLED,
-	HECI_DEV_RESETTING,
-	HECI_DEV_DISABLED,
-	HECI_DEV_POWER_DOWN,
-	HECI_DEV_POWER_UP
-};
-
-const char *heci_dev_state_str(int state);
-
-/**
- * struct heci_me_client - representation of me (fw) client
- *
- * @props  - client properties
- * @client_id - me client id
- */
-struct heci_me_client {
-	struct heci_client_properties props;
-	u8 client_id;
-};
-
-
-struct heci_cl;
-
-/*
- * Intel HECI message data struct
- */
-struct heci_msg_data {
-	u32 size;
-	int	dma_flag;	/* non-0 if this is DMA msg buf */
-	unsigned char *data;
-};
-
-/**
- * struct heci_cl_rb - request block (was: callback) structure
- *
- * @cl - client who is running this operation
- * @type - request type
- */
-struct heci_cl_rb {
-	struct list_head list;
-	struct heci_cl *cl;
-	struct heci_msg_data buffer;
-	unsigned long buf_idx;
-	unsigned long read_time;
-};
-
-
-struct wr_msg_ctl_info {
-	void	(*ipc_send_compl)(void *);	/* Will be called with
-					'ipc_send_compl_prm' as parameter */
-	void	*ipc_send_compl_prm;
-	size_t length;
-	struct list_head	link;
-	unsigned char	inline_data[IPC_FULL_MSG_SIZE];
-};
-
-/** struct heci_hw_ops
- *
- * @host_is_ready    - query for host readiness
- * @hw_is_ready      - query if hw is ready
- * @hw_reset         - reset hw
- * @hw_start         - start hw after reset
- * @hw_config        - configure hw
- * @write            - write a message to FW
- */
-struct heci_hw_ops {
-	bool (*host_is_ready)(struct heci_device *dev);
-	bool (*hw_is_ready)(struct heci_device *dev);
-	int (*hw_reset)(struct heci_device *dev);
-	int (*ipc_reset)(struct heci_device *dev);
-	int (*hw_start)(struct heci_device *dev);
-	void (*hw_config)(struct heci_device *dev);
-	int (*write)(struct heci_device *dev, struct heci_msg_hdr *hdr,
-		unsigned char *buf);
-	int (*write_ex)(struct heci_device *dev, struct heci_msg_hdr *hdr,
-		void *msg, void(*ipc_send_compl)(void *),
-		void *ipc_send_compl_prm);
-	int (*read)(struct heci_device *dev, unsigned char *buffer,
-		unsigned long buffer_length);
-	u32 (*get_fw_status)(struct heci_device *dev);
-};
-
-#define PRINT_BUFFER_SIZE 204800
-
-/**
- * struct heci_device -  HECI private device struct
- *
- * @hbm_state - state of host bus message protocol
- * @mem_addr - mem mapped base register address
- */
-struct heci_device {
-	struct pci_dev *pdev;	/* pointer to pci device struct */
-	/*
-	 * lists of queues
-	 */
-
-	/* array of pointers to aio lists */
-	struct heci_cl_rb read_list;		/* driver read queue */
-	spinlock_t      read_list_spinlock;
-
-	/*
-	 * list of heci_cl's (formerly: files)
-	 */
-	struct list_head cl_list;
-	spinlock_t      cl_list_lock;
-	long open_handle_count;			/* Why's this?.. */
-
-	/*
-	 * lock for the device
-	 * for everything that doesn't have a dedicated spinlock
-	 */
-	spinlock_t	device_lock;
-
-	bool recvd_hw_ready;
-	/*
-	 * waiting queue for receive message from FW
-	 */
-	wait_queue_head_t wait_hw_ready;
-	wait_queue_head_t wait_hbm_recvd_msg;
-	wait_queue_head_t wait_dma_ready;
-
-	/*
-	 * heci device  states
-	 */
-	enum heci_dev_state dev_state;
-	enum heci_hbm_state hbm_state;
-
-	/* FIFO for input messages for BH processing */
-	unsigned char	rd_msg_fifo[RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE];
-	unsigned	rd_msg_fifo_head, rd_msg_fifo_tail;
-	spinlock_t	rd_msg_spinlock;
-	struct work_struct	bh_hbm_work;
-
-#if 0
-	/*
-	 * FIFO for output IPC messages. Includes also HECI/IPC header
-	 * to be supplied in DRBL (first dword)
-	 */
-	unsigned char	wr_msg_fifo[IPC_TX_FIFO_SIZE * IPC_FULL_MSG_SIZE];
-#endif
-	/*
-	 * Control info for IPC messages HECI/IPC sending FIFO -
-	 * list with inline data buffer
-	 * This structure will be filled with parameters submitted
-	 * by the caller glue layer
-	 * 'buf' may be pointing to the external buffer or to 'inline_data'
-	 * 'offset' will be initialized to 0 by submitting
-	 *
-	 * 'ipc_send_compl' is intended for use by clients that send fragmented
-	 * messages. When a fragment is sent down to IPC msg regs,
-	 * it will be called.
-	 * If it has more fragments to send, it will do it. With last fragment
-	 * it will send appropriate HECI "message-complete" flag.
-	 * It will remove the outstanding message
-	 * (mark outstanding buffer as available).
-	 * If counting flow control is in work and there are more flow control
-	 * credits, it can put the next client message queued in cl.
-	 * structure for IPC processing.
-	 *
-	 * (!) We can work on FIFO list or cyclic FIFO in an array
-	 */
-
-	struct wr_msg_ctl_info wr_processing_list_head, wr_free_list_head;
-	spinlock_t wr_processing_spinlock;	/* For both processing
-						   and free lists */
-	spinlock_t	out_ipc_spinlock;
-/*
-	unsigned	wr_msg_fifo_head, wr_msg_fifo_tail;
-	spinlock_t	wr_msg_spinlock;
-*/
-	struct hbm_version version;
-	struct heci_me_client *me_clients; /* Note: memory has to be allocated*/
-	DECLARE_BITMAP(me_clients_map, HECI_CLIENTS_MAX);
-	DECLARE_BITMAP(host_clients_map, HECI_CLIENTS_MAX);
-	u8 me_clients_num;
-	u8 me_client_presentation_num;
-	u8 me_client_index;
-	spinlock_t      me_clients_lock;
-	/* List of bus devices */
-	struct list_head device_list;
-	spinlock_t      device_list_lock;
-
-	/* buffer to save prints from driver */
-	unsigned char log_buffer[PRINT_BUFFER_SIZE];
-	size_t log_head;
-	size_t log_tail;
-	void (*print_log)(struct heci_device *dev, char *format, ...);
-	spinlock_t      log_spinlock;   /* spinlock to protect prints buffer */
-	unsigned long	max_log_sec, max_log_usec;
-
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-	struct dentry *dbgfs_dir;
-#endif /* CONFIG_DEBUG_FS */
-
-	/* Debug stats */
-	unsigned	ipc_hid_out_fc;
-	int	ipc_hid_in_msg;
-	unsigned	ipc_hid_in_fc;
-	int	ipc_hid_out_msg;
-	unsigned	ipc_hid_out_fc_cnt;
-	unsigned	ipc_hid_in_fc_cnt;
-
-	unsigned	ipc_rx_cnt;
-	unsigned long long	ipc_rx_bytes_cnt;
-	unsigned	ipc_tx_cnt;
-	unsigned long long	ipc_tx_bytes_cnt;
-
-	const struct heci_hw_ops *ops;
-
-	size_t	mtu;
-	char hw[0] __aligned(sizeof(void *));
-};
-
-/*
- * heci init function prototypes
- */
-void heci_device_init(struct heci_device *dev);
-void heci_reset(struct heci_device *dev, int interrupts);
-int heci_start(struct heci_device *dev);
-void heci_stop(struct heci_device *dev);
-void	heci_device_disable(struct heci_device *dev);
-
-static inline unsigned long heci_secs_to_jiffies(unsigned long sec)
-{
-	return sec * HZ;	/*msecs_to_jiffies(sec * MSEC_PER_SEC);*/
-}
-
-/*
- * Register Access Function
- */
-static inline void heci_hw_config(struct heci_device *dev)
-{
-	dev->ops->hw_config(dev);
-}
-
-static inline int heci_ipc_reset(struct heci_device *dev)
-{
-	return dev->ops->ipc_reset(dev);
-}
-
-static inline int heci_hw_reset(struct heci_device *dev)
-{
-	return dev->ops->hw_reset(dev);
-}
-
-static inline int heci_hw_start(struct heci_device *dev)
-{
-	return dev->ops->hw_start(dev);
-}
-
-static inline bool heci_host_is_ready(struct heci_device *dev)
-{
-	return dev->ops->host_is_ready(dev);
-}
-
-static inline bool heci_hw_is_ready(struct heci_device *dev)
-{
-	return dev->ops->hw_is_ready(dev);
-}
-
-static inline int heci_write_message(struct heci_device *dev,
-	struct heci_msg_hdr *hdr, unsigned char *buf)
-{
-	return dev->ops->write_ex(dev, hdr, buf, NULL, NULL);
-}
-
-#if IS_ENABLED(CONFIG_DEBUG_FS)
-int heci_dbgfs_register(struct heci_device *dev, const char *name);
-void heci_dbgfs_deregister(struct heci_device *dev);
-#else
-static inline int heci_dbgfs_register(struct heci_device *dev, const char *name)
-{
-	return 0;
-}
-static inline void heci_dbgfs_deregister(struct heci_device *dev) {}
-#endif /* CONFIG_DEBUG_FS */
-
-
-int heci_register(struct heci_device *dev);
-void heci_deregister(struct heci_device *dev);
-
-void    heci_bus_remove_all_clients(struct heci_device *heci_dev);
-
-#define HECI_HDR_FMT "hdr:host=%02d me=%02d len=%d comp=%1d"
-#define HECI_HDR_PRM(hdr)		\
-	((hdr)->host_addr, (hdr)->me_addr,	\
-	(hdr)->length, (hdr)->msg_complete)
-
-#endif /*_HECI_DEV_H_*/
-
diff --git a/drivers/misc/heci/hid-ids.h b/drivers/misc/heci/hid-ids.h
deleted file mode 100644
index 34ce24d..0000000
--- a/drivers/misc/heci/hid-ids.h
+++ /dev/null
@@ -1,891 +0,0 @@
-/*
- *  USB HID quirks support for Linux
- *
- *  Copyright (c) 1999 Andreas Gal
- *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
- *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
- *  Copyright (c) 2006-2007 Jiri Kosina
- */
-
-/*
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
- */
-
-#ifndef HID_IDS_H_FILE
-#define HID_IDS_H_FILE
-
-#define USB_VENDOR_ID_3M		0x0596
-#define USB_DEVICE_ID_3M1968		0x0500
-#define USB_DEVICE_ID_3M2256		0x0502
-#define USB_DEVICE_ID_3M3266		0x0506
-
-#define USB_VENDOR_ID_A4TECH		0x09da
-#define USB_DEVICE_ID_A4TECH_WCP32PU	0x0006
-#define USB_DEVICE_ID_A4TECH_X5_005D	0x000a
-#define USB_DEVICE_ID_A4TECH_RP_649	0x001a
-
-#define USB_VENDOR_ID_AASHIMA		0x06d6
-#define USB_DEVICE_ID_AASHIMA_GAMEPAD	0x0025
-#define USB_DEVICE_ID_AASHIMA_PREDATOR	0x0026
-
-#define USB_VENDOR_ID_ACECAD		0x0460
-#define USB_DEVICE_ID_ACECAD_FLAIR	0x0004
-#define USB_DEVICE_ID_ACECAD_302	0x0008
-
-#define USB_VENDOR_ID_ACRUX		0x1a34
-
-#define USB_VENDOR_ID_ACTIONSTAR	0x2101
-#define USB_DEVICE_ID_ACTIONSTAR_1011	0x1011
-
-#define USB_VENDOR_ID_ADS_TECH		0x06e1
-#define USB_DEVICE_ID_ADS_TECH_RADIO_SI470X	0xa155
-
-#define USB_VENDOR_ID_AFATECH		0x15a4
-#define USB_DEVICE_ID_AFATECH_AF9016	0x9016
-
-#define USB_VENDOR_ID_AIPTEK		0x08ca
-#define USB_DEVICE_ID_AIPTEK_01		0x0001
-#define USB_DEVICE_ID_AIPTEK_10		0x0010
-#define USB_DEVICE_ID_AIPTEK_20		0x0020
-#define USB_DEVICE_ID_AIPTEK_21		0x0021
-#define USB_DEVICE_ID_AIPTEK_22		0x0022
-#define USB_DEVICE_ID_AIPTEK_23		0x0023
-#define USB_DEVICE_ID_AIPTEK_24		0x0024
-
-#define USB_VENDOR_ID_AIRCABLE		0x16CA
-#define USB_DEVICE_ID_AIRCABLE1		0x1502
-
-#define USB_VENDOR_ID_AIREN		0x1a2c
-#define USB_DEVICE_ID_AIREN_SLIMPLUS	0x0002
-
-#define USB_VENDOR_ID_ALCOR		0x058f
-#define USB_DEVICE_ID_ALCOR_USBRS232	0x9720
-
-#define USB_VENDOR_ID_ALPS		0x0433
-#define USB_DEVICE_ID_IBM_GAMEPAD	0x1101
-
-#define USB_VENDOR_ID_APPLE		0x05ac
-#define USB_DEVICE_ID_APPLE_MIGHTYMOUSE	0x0304
-#define USB_DEVICE_ID_APPLE_MAGICMOUSE	0x030d
-#define USB_DEVICE_ID_APPLE_MAGICTRACKPAD	0x030e
-#define USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI	0x020e
-#define USB_DEVICE_ID_APPLE_FOUNTAIN_ISO	0x020f
-#define USB_DEVICE_ID_APPLE_GEYSER_ANSI	0x0214
-#define USB_DEVICE_ID_APPLE_GEYSER_ISO	0x0215
-#define USB_DEVICE_ID_APPLE_GEYSER_JIS	0x0216
-#define USB_DEVICE_ID_APPLE_GEYSER3_ANSI	0x0217
-#define USB_DEVICE_ID_APPLE_GEYSER3_ISO	0x0218
-#define USB_DEVICE_ID_APPLE_GEYSER3_JIS	0x0219
-#define USB_DEVICE_ID_APPLE_GEYSER4_ANSI	0x021a
-#define USB_DEVICE_ID_APPLE_GEYSER4_ISO	0x021b
-#define USB_DEVICE_ID_APPLE_GEYSER4_JIS	0x021c
-#define USB_DEVICE_ID_APPLE_ALU_MINI_ANSI	0x021d
-#define USB_DEVICE_ID_APPLE_ALU_MINI_ISO	0x021e
-#define USB_DEVICE_ID_APPLE_ALU_MINI_JIS	0x021f
-#define USB_DEVICE_ID_APPLE_ALU_ANSI	0x0220
-#define USB_DEVICE_ID_APPLE_ALU_ISO	0x0221
-#define USB_DEVICE_ID_APPLE_ALU_JIS	0x0222
-#define USB_DEVICE_ID_APPLE_WELLSPRING_ANSI	0x0223
-#define USB_DEVICE_ID_APPLE_WELLSPRING_ISO	0x0224
-#define USB_DEVICE_ID_APPLE_WELLSPRING_JIS	0x0225
-#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI	0x0229
-#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO	0x022a
-#define USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS	0x022b
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI	0x022c
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO	0x022d
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS	0x022e
-#define USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI	0x0230
-#define USB_DEVICE_ID_APPLE_WELLSPRING2_ISO	0x0231
-#define USB_DEVICE_ID_APPLE_WELLSPRING2_JIS	0x0232
-#define USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI	0x0236
-#define USB_DEVICE_ID_APPLE_WELLSPRING3_ISO	0x0237
-#define USB_DEVICE_ID_APPLE_WELLSPRING3_JIS	0x0238
-#define USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI	0x023f
-#define USB_DEVICE_ID_APPLE_WELLSPRING4_ISO	0x0240
-#define USB_DEVICE_ID_APPLE_WELLSPRING4_JIS	0x0241
-#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI	0x0242
-#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO	0x0243
-#define USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS	0x0244
-#define USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI	0x0245
-#define USB_DEVICE_ID_APPLE_WELLSPRING5_ISO	0x0246
-#define USB_DEVICE_ID_APPLE_WELLSPRING5_JIS	0x0247
-#define USB_DEVICE_ID_APPLE_ALU_REVB_ANSI	0x024f
-#define USB_DEVICE_ID_APPLE_ALU_REVB_ISO	0x0250
-#define USB_DEVICE_ID_APPLE_ALU_REVB_JIS	0x0251
-#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI	0x0252
-#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO	0x0253
-#define USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS	0x0254
-#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI	0x0259
-#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO	0x025a
-#define USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS	0x025b
-#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI	0x0249
-#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO	0x024a
-#define USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS	0x024b
-#define USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI	0x024c
-#define USB_DEVICE_ID_APPLE_WELLSPRING6_ISO	0x024d
-#define USB_DEVICE_ID_APPLE_WELLSPRING6_JIS	0x024e
-#define USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI	0x0262
-#define USB_DEVICE_ID_APPLE_WELLSPRING7_ISO	0x0263
-#define USB_DEVICE_ID_APPLE_WELLSPRING7_JIS	0x0264
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI  0x0255
-#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO   0x0256
-#define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY	0x030a
-#define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY	0x030b
-#define USB_DEVICE_ID_APPLE_ATV_IRCONTROL	0x8241
-#define USB_DEVICE_ID_APPLE_IRCONTROL4	0x8242
-
-#define USB_VENDOR_ID_ASUS		0x0486
-#define USB_DEVICE_ID_ASUS_T91MT	0x0185
-#define USB_DEVICE_ID_ASUSTEK_MULTITOUCH_YFO	0x0186
-
-#define USB_VENDOR_ID_ASUSTEK		0x0b05
-#define USB_DEVICE_ID_ASUSTEK_LCM	0x1726
-#define USB_DEVICE_ID_ASUSTEK_LCM2	0x175b
-
-#define USB_VENDOR_ID_ATEN		0x0557
-#define USB_DEVICE_ID_ATEN_UC100KM	0x2004
-#define USB_DEVICE_ID_ATEN_CS124U	0x2202
-#define USB_DEVICE_ID_ATEN_2PORTKVM	0x2204
-#define USB_DEVICE_ID_ATEN_4PORTKVM	0x2205
-#define USB_DEVICE_ID_ATEN_4PORTKVMC	0x2208
-
-#define USB_VENDOR_ID_ATMEL		0x03eb
-#define USB_DEVICE_ID_ATMEL_MULTITOUCH	0x211c
-#define USB_DEVICE_ID_ATMEL_MXT_DIGITIZER	0x2118
-#define USB_VENDOR_ID_ATMEL_V_USB	0x16c0
-#define USB_DEVICE_ID_ATMEL_V_USB	0x05df
-
-#define USB_VENDOR_ID_AUREAL		0x0755
-#define USB_DEVICE_ID_AUREAL_W01RN	0x2626
-
-#define USB_VENDOR_ID_AVERMEDIA		0x07ca
-#define USB_DEVICE_ID_AVER_FM_MR800	0xb800
-
-#define USB_VENDOR_ID_AXENTIA		0x12cf
-#define USB_DEVICE_ID_AXENTIA_FM_RADIO	0x7111
-
-#define USB_VENDOR_ID_BAANTO		0x2453
-#define USB_DEVICE_ID_BAANTO_MT_190W2	0x0100
-
-#define USB_VENDOR_ID_BELKIN		0x050d
-#define USB_DEVICE_ID_FLIP_KVM		0x3201
-
-#define USB_VENDOR_ID_BERKSHIRE		0x0c98
-#define USB_DEVICE_ID_BERKSHIRE_PCWD	0x1140
-
-#define USB_VENDOR_ID_BTC		0x046e
-#define USB_DEVICE_ID_BTC_EMPREX_REMOTE	0x5578
-#define USB_DEVICE_ID_BTC_EMPREX_REMOTE_2	0x5577
-
-#define USB_VENDOR_ID_CANDO		0x2087
-#define USB_DEVICE_ID_CANDO_PIXCIR_MULTI_TOUCH 0x0703
-#define USB_DEVICE_ID_CANDO_MULTI_TOUCH	0x0a01
-#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_10_1 0x0a02
-#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_11_6 0x0b03
-#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_15_6 0x0f01
-
-#define USB_VENDOR_ID_CH		0x068e
-#define USB_DEVICE_ID_CH_PRO_THROTTLE	0x00f1
-#define USB_DEVICE_ID_CH_PRO_PEDALS	0x00f2
-#define USB_DEVICE_ID_CH_FIGHTERSTICK	0x00f3
-#define USB_DEVICE_ID_CH_COMBATSTICK	0x00f4
-#define USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE       0x0051
-#define USB_DEVICE_ID_CH_FLIGHT_SIM_YOKE	0x00ff
-#define USB_DEVICE_ID_CH_3AXIS_5BUTTON_STICK	0x00d3
-#define USB_DEVICE_ID_CH_AXIS_295	0x001c
-
-#define USB_VENDOR_ID_CHERRY		0x046a
-#define USB_DEVICE_ID_CHERRY_CYMOTION	0x0023
-#define USB_DEVICE_ID_CHERRY_CYMOTION_SOLAR	0x0027
-
-#define USB_VENDOR_ID_CHIC		0x05fe
-#define USB_DEVICE_ID_CHIC_GAMEPAD	0x0014
-
-#define USB_VENDOR_ID_CHICONY		0x04f2
-#define USB_DEVICE_ID_CHICONY_TACTICAL_PAD	0x0418
-#define USB_DEVICE_ID_CHICONY_MULTI_TOUCH	0xb19d
-#define USB_DEVICE_ID_CHICONY_WIRELESS	0x0618
-#define USB_DEVICE_ID_CHICONY_WIRELESS2	0x1123
-#define USB_DEVICE_ID_CHICONY_AK1D	0x1125
-
-#define USB_VENDOR_ID_CHUNGHWAT		0x2247
-#define USB_DEVICE_ID_CHUNGHWAT_MULTITOUCH	0x0001
-
-#define USB_VENDOR_ID_CIDC		0x1677
-
-#define USB_VENDOR_ID_CMEDIA		0x0d8c
-#define USB_DEVICE_ID_CM109		0x000e
-
-#define USB_VENDOR_ID_CODEMERCS		0x07c0
-#define USB_DEVICE_ID_CODEMERCS_IOW_FIRST	0x1500
-#define USB_DEVICE_ID_CODEMERCS_IOW_LAST	0x15ff
-
-#define USB_VENDOR_ID_CREATIVELABS	0x041e
-#define USB_DEVICE_ID_PRODIKEYS_PCMIDI	0x2801
-
-#define USB_VENDOR_ID_CVTOUCH		0x1ff7
-#define USB_DEVICE_ID_CVTOUCH_SCREEN	0x0013
-
-#define USB_VENDOR_ID_CYGNAL		0x10c4
-#define USB_DEVICE_ID_CYGNAL_RADIO_SI470X	0x818a
-
-#define USB_VENDOR_ID_CYPRESS		0x04b4
-#define USB_DEVICE_ID_CYPRESS_MOUSE	0x0001
-#define USB_DEVICE_ID_CYPRESS_HIDCOM	0x5500
-#define USB_DEVICE_ID_CYPRESS_ULTRAMOUSE	0x7417
-#define USB_DEVICE_ID_CYPRESS_BARCODE_1	0xde61
-#define USB_DEVICE_ID_CYPRESS_BARCODE_2	0xde64
-#define USB_DEVICE_ID_CYPRESS_BARCODE_3	0xbca1
-#define USB_DEVICE_ID_CYPRESS_BARCODE_4	0xed81
-#define USB_DEVICE_ID_CYPRESS_TRUETOUCH	0xc001
-
-#define USB_VENDOR_ID_DEALEXTREAME	0x10c5
-#define USB_DEVICE_ID_DEALEXTREAME_RADIO_SI4701	0x819a
-
-#define USB_VENDOR_ID_DELORME		0x1163
-#define USB_DEVICE_ID_DELORME_EARTHMATE	0x0100
-#define USB_DEVICE_ID_DELORME_EM_LT20	0x0200
-
-#define USB_VENDOR_ID_DMI		0x0c0b
-#define USB_DEVICE_ID_DMI_ENC		0x5fab
-
-#define USB_VENDOR_ID_DRAGONRISE	0x0079
-
-#define USB_VENDOR_ID_DWAV		0x0eef
-#define USB_DEVICE_ID_EGALAX_TOUCHCONTROLLER	0x0001
-#define USB_DEVICE_ID_DWAV_TOUCHCONTROLLER	0x0002
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480D	0x480d
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480E	0x480e
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7207	0x7207
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_720C	0x720c
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7224	0x7224
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_722A	0x722A
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_725E	0x725e
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7262	0x7262
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_726B	0x726b
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72AA	0x72aa
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72A1	0x72a1
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72FA	0x72fa
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7302	0x7302
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7349	0x7349
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_73F7	0x73f7
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_A001	0xa001
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7224      0x7224
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72D0      0x72d0
-#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72C4      0x72c4
-
-#define USB_VENDOR_ID_ELECOM		0x056e
-#define USB_DEVICE_ID_ELECOM_BM084	0x0061
-
-#define USB_VENDOR_ID_DREAM_CHEEKY	0x1d34
-
-#define USB_VENDOR_ID_ELO		0x04E7
-#define USB_DEVICE_ID_ELO_TS2515	0x0022
-#define USB_DEVICE_ID_ELO_TS2700	0x0020
-
-#define USB_VENDOR_ID_EMS		0x2006
-#define USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II 0x0118
-
-#define USB_VENDOR_ID_FLATFROG		0x25b5
-#define USB_DEVICE_ID_MULTITOUCH_3200	0x0002
-
-#define USB_VENDOR_ID_ESSENTIAL_REALITY	0x0d7f
-#define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100
-
-#define USB_VENDOR_ID_ETT		0x0664
-#define USB_DEVICE_ID_TC5UH		0x0309
-#define USB_DEVICE_ID_TC4UM		0x0306
-
-#define USB_VENDOR_ID_ETURBOTOUCH	0x22b9
-#define USB_DEVICE_ID_ETURBOTOUCH	0x0006
-
-#define USB_VENDOR_ID_EZKEY		0x0518
-#define USB_DEVICE_ID_BTC_8193		0x0002
-
-#define USB_VENDOR_ID_FORMOSA          0x147a
-#define USB_DEVICE_ID_FORMOSA_IR_RECEIVER      0xe03e
-
-#define USB_VENDOR_ID_FREESCALE		0x15A2
-#define USB_DEVICE_ID_FREESCALE_MX28	0x004F
-
-#define USB_VENDOR_ID_FRUCTEL	0x25B6
-#define USB_DEVICE_ID_GAMETEL_MT_MODE	0x0002
-
-#define USB_VENDOR_ID_GAMERON		0x0810
-#define USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR	0x0001
-#define USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR	0x0002
-
-#define USB_VENDOR_ID_GENERAL_TOUCH	0x0dfc
-#define USB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS 0x0003
-#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PWT_TENFINGERS 0x0100
-
-#define USB_VENDOR_ID_GLAB		0x06c2
-#define USB_DEVICE_ID_4_PHIDGETSERVO_30	0x0038
-#define USB_DEVICE_ID_1_PHIDGETSERVO_30	0x0039
-#define USB_DEVICE_ID_0_0_4_IF_KIT	0x0040
-#define USB_DEVICE_ID_0_16_16_IF_KIT	0x0044
-#define USB_DEVICE_ID_8_8_8_IF_KIT	0x0045
-#define USB_DEVICE_ID_0_8_7_IF_KIT	0x0051
-#define USB_DEVICE_ID_0_8_8_IF_KIT	0x0053
-#define USB_DEVICE_ID_PHIDGET_MOTORCONTROL	0x0058
-
-#define USB_VENDOR_ID_GOODTOUCH		0x1aad
-#define USB_DEVICE_ID_GOODTOUCH_000f	0x000f
-
-#define USB_VENDOR_ID_GOTOP		0x08f2
-#define USB_DEVICE_ID_SUPER_Q2		0x007f
-#define USB_DEVICE_ID_GOGOPEN		0x00ce
-#define USB_DEVICE_ID_PENPOWER		0x00f4
-
-#define USB_VENDOR_ID_GREENASIA		0x0e8f
-#define USB_DEVICE_ID_GREENASIA_DUAL_USB_JOYPAD	0x3013
-
-#define USB_VENDOR_ID_GRETAGMACBETH	0x0971
-#define USB_DEVICE_ID_GRETAGMACBETH_HUEY	0x2005
-
-#define USB_VENDOR_ID_GRIFFIN		0x077d
-#define USB_DEVICE_ID_POWERMATE		0x0410
-#define USB_DEVICE_ID_SOUNDKNOB		0x04AA
-#define USB_DEVICE_ID_RADIOSHARK	0x627a
-
-#define USB_VENDOR_ID_GTCO		0x078c
-#define USB_DEVICE_ID_GTCO_90		0x0090
-#define USB_DEVICE_ID_GTCO_100		0x0100
-#define USB_DEVICE_ID_GTCO_101		0x0101
-#define USB_DEVICE_ID_GTCO_103		0x0103
-#define USB_DEVICE_ID_GTCO_104		0x0104
-#define USB_DEVICE_ID_GTCO_105		0x0105
-#define USB_DEVICE_ID_GTCO_106		0x0106
-#define USB_DEVICE_ID_GTCO_107		0x0107
-#define USB_DEVICE_ID_GTCO_108		0x0108
-#define USB_DEVICE_ID_GTCO_200		0x0200
-#define USB_DEVICE_ID_GTCO_201		0x0201
-#define USB_DEVICE_ID_GTCO_202		0x0202
-#define USB_DEVICE_ID_GTCO_203		0x0203
-#define USB_DEVICE_ID_GTCO_204		0x0204
-#define USB_DEVICE_ID_GTCO_205		0x0205
-#define USB_DEVICE_ID_GTCO_206		0x0206
-#define USB_DEVICE_ID_GTCO_207		0x0207
-#define USB_DEVICE_ID_GTCO_300		0x0300
-#define USB_DEVICE_ID_GTCO_301		0x0301
-#define USB_DEVICE_ID_GTCO_302		0x0302
-#define USB_DEVICE_ID_GTCO_303		0x0303
-#define USB_DEVICE_ID_GTCO_304		0x0304
-#define USB_DEVICE_ID_GTCO_305		0x0305
-#define USB_DEVICE_ID_GTCO_306		0x0306
-#define USB_DEVICE_ID_GTCO_307		0x0307
-#define USB_DEVICE_ID_GTCO_308		0x0308
-#define USB_DEVICE_ID_GTCO_309		0x0309
-#define USB_DEVICE_ID_GTCO_400		0x0400
-#define USB_DEVICE_ID_GTCO_401		0x0401
-#define USB_DEVICE_ID_GTCO_402		0x0402
-#define USB_DEVICE_ID_GTCO_403		0x0403
-#define USB_DEVICE_ID_GTCO_404		0x0404
-#define USB_DEVICE_ID_GTCO_405		0x0405
-#define USB_DEVICE_ID_GTCO_500		0x0500
-#define USB_DEVICE_ID_GTCO_501		0x0501
-#define USB_DEVICE_ID_GTCO_502		0x0502
-#define USB_DEVICE_ID_GTCO_503		0x0503
-#define USB_DEVICE_ID_GTCO_504		0x0504
-#define USB_DEVICE_ID_GTCO_1000		0x1000
-#define USB_DEVICE_ID_GTCO_1001		0x1001
-#define USB_DEVICE_ID_GTCO_1002		0x1002
-#define USB_DEVICE_ID_GTCO_1003		0x1003
-#define USB_DEVICE_ID_GTCO_1004		0x1004
-#define USB_DEVICE_ID_GTCO_1005		0x1005
-#define USB_DEVICE_ID_GTCO_1006		0x1006
-#define USB_DEVICE_ID_GTCO_1007		0x1007
-
-#define USB_VENDOR_ID_GYRATION		0x0c16
-#define USB_DEVICE_ID_GYRATION_REMOTE	0x0002
-#define USB_DEVICE_ID_GYRATION_REMOTE_2 0x0003
-#define USB_DEVICE_ID_GYRATION_REMOTE_3 0x0008
-
-#define USB_VENDOR_ID_HANWANG		0x0b57
-#define USB_DEVICE_ID_HANWANG_TABLET_FIRST	0x5000
-#define USB_DEVICE_ID_HANWANG_TABLET_LAST	0x8fff
-
-#define USB_VENDOR_ID_HANVON		0x20b3
-#define USB_DEVICE_ID_HANVON_MULTITOUCH	0x0a18
-
-#define USB_VENDOR_ID_HANVON_ALT	0x22ed
-#define USB_DEVICE_ID_HANVON_ALT_MULTITOUCH	0x1010
-
-#define USB_VENDOR_ID_HAPP		0x078b
-#define USB_DEVICE_ID_UGCI_DRIVING	0x0010
-#define USB_DEVICE_ID_UGCI_FLYING	0x0020
-#define USB_DEVICE_ID_UGCI_FIGHTING	0x0030
-
-#define USB_VENDOR_ID_IDEACOM		0x1cb6
-#define USB_DEVICE_ID_IDEACOM_IDC6650	0x6650
-#define USB_DEVICE_ID_IDEACOM_IDC6651	0x6651
-
-#define USB_VENDOR_ID_ILITEK		0x222a
-#define USB_DEVICE_ID_ILITEK_MULTITOUCH	0x0001
-
-#define USB_VENDOR_ID_ION		0x15e4
-#define USB_DEVICE_ID_ICADE		0x0132
-
-#define USB_VENDOR_ID_HOLTEK		0x1241
-#define USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP	0x5015
-
-#define USB_VENDOR_ID_HOLTEK_ALT		0x04d9
-#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD	0xa055
-
-#define USB_VENDOR_ID_IMATION		0x0718
-#define USB_DEVICE_ID_DISC_STAKKA	0xd000
-
-#define USB_VENDOR_ID_IRTOUCHSYSTEMS	0x6615
-#define USB_DEVICE_ID_IRTOUCH_INFRARED_USB	0x0070
-
-#define USB_VENDOR_ID_JESS		0x0c45
-#define USB_DEVICE_ID_JESS_YUREX	0x1010
-
-#define USB_VENDOR_ID_JESS2		0x0f30
-#define USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD 0x0111
-
-#define USB_VENDOR_ID_KBGEAR		0x084e
-#define USB_DEVICE_ID_KBGEAR_JAMSTUDIO	0x1001
-
-#define USB_VENDOR_ID_KENSINGTON	0x047d
-#define USB_DEVICE_ID_KS_SLIMBLADE	0x2041
-
-#define USB_VENDOR_ID_KWORLD		0x1b80
-#define USB_DEVICE_ID_KWORLD_RADIO_FM700	0xd700
-
-#define USB_VENDOR_ID_KEYTOUCH		0x0926
-#define USB_DEVICE_ID_KEYTOUCH_IEC	0x3333
-
-#define USB_VENDOR_ID_KYE		0x0458
-#define USB_DEVICE_ID_KYE_ERGO_525V	0x0087
-#define USB_DEVICE_ID_KYE_GPEN_560	0x5003
-#define USB_DEVICE_ID_KYE_EASYPEN_I405X	0x5010
-#define USB_DEVICE_ID_KYE_MOUSEPEN_I608X	0x5011
-#define USB_DEVICE_ID_KYE_EASYPEN_M610X	0x5013
-
-#define USB_VENDOR_ID_LABTEC		0x1020
-#define USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD	0x0006
-
-#define USB_VENDOR_ID_LCPOWER		0x1241
-#define USB_DEVICE_ID_LCPOWER_LC1000	0xf767
-
-#define USB_VENDOR_ID_LD		0x0f11
-#define USB_DEVICE_ID_LD_CASSY		0x1000
-#define USB_DEVICE_ID_LD_CASSY2		0x1001
-#define USB_DEVICE_ID_LD_POCKETCASSY	0x1010
-#define USB_DEVICE_ID_LD_POCKETCASSY2	0x1011
-#define USB_DEVICE_ID_LD_MOBILECASSY	0x1020
-#define USB_DEVICE_ID_LD_MOBILECASSY2	0x1021
-#define USB_DEVICE_ID_LD_MICROCASSYVOLTAGE	0x1031
-#define USB_DEVICE_ID_LD_MICROCASSYCURRENT	0x1032
-#define USB_DEVICE_ID_LD_MICROCASSYTIME		0x1033
-#define USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE	0x1035
-#define USB_DEVICE_ID_LD_MICROCASSYPH		0x1038
-#define USB_DEVICE_ID_LD_JWM		0x1080
-#define USB_DEVICE_ID_LD_DMMP		0x1081
-#define USB_DEVICE_ID_LD_UMIP		0x1090
-#define USB_DEVICE_ID_LD_UMIC		0x10A0
-#define USB_DEVICE_ID_LD_UMIB		0x10B0
-#define USB_DEVICE_ID_LD_XRAY		0x1100
-#define USB_DEVICE_ID_LD_XRAY2		0x1101
-#define USB_DEVICE_ID_LD_XRAYCT		0x1110
-#define USB_DEVICE_ID_LD_VIDEOCOM	0x1200
-#define USB_DEVICE_ID_LD_MOTOR		0x1210
-#define USB_DEVICE_ID_LD_COM3LAB	0x2000
-#define USB_DEVICE_ID_LD_TELEPORT	0x2010
-#define USB_DEVICE_ID_LD_NETWORKANALYSER 0x2020
-#define USB_DEVICE_ID_LD_POWERCONTROL	0x2030
-#define USB_DEVICE_ID_LD_MACHINETEST	0x2040
-#define USB_DEVICE_ID_LD_MOSTANALYSER	0x2050
-#define USB_DEVICE_ID_LD_MOSTANALYSER2	0x2051
-#define USB_DEVICE_ID_LD_ABSESP		0x2060
-#define USB_DEVICE_ID_LD_AUTODATABUS	0x2070
-#define USB_DEVICE_ID_LD_MCT		0x2080
-#define USB_DEVICE_ID_LD_HYBRID		0x2090
-#define USB_DEVICE_ID_LD_HEATCONTROL	0x20A0
-
-#define USB_VENDOR_ID_LENOVO		0x17ef
-#define USB_DEVICE_ID_LENOVO_TPKBD	0x6009
-
-#define USB_VENDOR_ID_LG		0x1fd2
-#define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
-
-#define USB_VENDOR_ID_LOGITECH		0x046d
-#define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e
-#define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
-#define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
-#define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f
-#define USB_DEVICE_ID_LOGITECH_HARMONY_PS3 0x0306
-#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD	0xc20a
-#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD	0xc211
-#define USB_DEVICE_ID_LOGITECH_EXTREME_3D	0xc215
-#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2	0xc218
-#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2	0xc219
-#define USB_DEVICE_ID_LOGITECH_WINGMAN_F3D	0xc283
-#define USB_DEVICE_ID_LOGITECH_FORCE3D_PRO	0xc286
-#define USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940	0xc287
-#define USB_DEVICE_ID_LOGITECH_WINGMAN_FFG	0xc293
-#define USB_DEVICE_ID_LOGITECH_WHEEL	0xc294
-#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL	0xc295
-#define USB_DEVICE_ID_LOGITECH_DFP_WHEEL	0xc298
-#define USB_DEVICE_ID_LOGITECH_G25_WHEEL	0xc299
-#define USB_DEVICE_ID_LOGITECH_DFGT_WHEEL	0xc29a
-#define USB_DEVICE_ID_LOGITECH_G27_WHEEL	0xc29b
-#define USB_DEVICE_ID_LOGITECH_WII_WHEEL	0xc29c
-#define USB_DEVICE_ID_LOGITECH_ELITE_KBD	0xc30a
-#define USB_DEVICE_ID_S510_RECEIVER	0xc50c
-#define USB_DEVICE_ID_S510_RECEIVER_2	0xc517
-#define USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500	0xc512
-#define USB_DEVICE_ID_MX3000_RECEIVER	0xc513
-#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER	0xc52b
-#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2	0xc532
-#define USB_DEVICE_ID_SPACETRAVELLER	0xc623
-#define USB_DEVICE_ID_SPACENAVIGATOR	0xc626
-#define USB_DEVICE_ID_DINOVO_DESKTOP	0xc704
-#define USB_DEVICE_ID_DINOVO_EDGE	0xc714
-#define USB_DEVICE_ID_DINOVO_MINI	0xc71f
-#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2	0xca03
-
-#define USB_VENDOR_ID_LUMIO		0x202e
-#define USB_DEVICE_ID_CRYSTALTOUCH	0x0006
-#define USB_DEVICE_ID_CRYSTALTOUCH_DUAL	0x0007
-
-#define USB_VENDOR_ID_MADCATZ		0x0738
-#define USB_DEVICE_ID_MADCATZ_BEATPAD	0x4540
-
-#define USB_VENDOR_ID_MCC		0x09db
-#define USB_DEVICE_ID_MCC_PMD1024LS	0x0076
-#define USB_DEVICE_ID_MCC_PMD1208LS	0x007a
-
-#define USB_VENDOR_ID_MGE		0x0463
-#define USB_DEVICE_ID_MGE_UPS		0xffff
-#define USB_DEVICE_ID_MGE_UPS1		0x0001
-
-#define USB_VENDOR_ID_MICROCHIP		0x04d8
-#define USB_DEVICE_ID_PICKIT1		0x0032
-#define USB_DEVICE_ID_PICKIT2		0x0033
-#define USB_DEVICE_ID_PICOLCD		0xc002
-#define USB_DEVICE_ID_PICOLCD_BOOTLOADER	0xf002
-
-#define USB_VENDOR_ID_MICROSOFT		0x045e
-#define USB_DEVICE_ID_SIDEWINDER_GV	0x003b
-#define USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0 0x009d
-#define USB_DEVICE_ID_MS_NE4K		0x00db
-#define USB_DEVICE_ID_MS_LK6K		0x00f9
-#define USB_DEVICE_ID_MS_PRESENTER_8K_BT	0x0701
-#define USB_DEVICE_ID_MS_PRESENTER_8K_USB	0x0713
-#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K	0x0730
-#define USB_DEVICE_ID_MS_COMFORT_MOUSE_4500	0x076c
-
-#define USB_VENDOR_ID_MOJO		0x8282
-#define USB_DEVICE_ID_RETRO_ADAPTER	0x3201
-
-#define USB_VENDOR_ID_MONTEREY		0x0566
-#define USB_DEVICE_ID_GENIUS_KB29E	0x3004
-
-#define USB_VENDOR_ID_MSI		0x1770
-#define USB_DEVICE_ID_MSI_GX680R_LED_PANEL	0xff00
-
-#define USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR 0x0400
-#define USB_DEVICE_ID_N_S_HARMONY	0xc359
-
-#define USB_VENDOR_ID_NATSU		0x08b7
-#define USB_DEVICE_ID_NATSU_GAMEPAD	0x0001
-
-#define USB_VENDOR_ID_NCR		0x0404
-#define USB_DEVICE_ID_NCR_FIRST		0x0300
-#define USB_DEVICE_ID_NCR_LAST		0x03ff
-
-#define USB_VENDOR_ID_NEC		0x073e
-#define USB_DEVICE_ID_NEC_USB_GAME_PAD	0x0301
-
-#define USB_VENDOR_ID_NEXIO		0x1870
-#define USB_DEVICE_ID_NEXIO_MULTITOUCH_420	0x010d
-
-#define USB_VENDOR_ID_NEXTWINDOW	0x1926
-#define USB_DEVICE_ID_NEXTWINDOW_TOUCHSCREEN	0x0003
-
-#define USB_VENDOR_ID_NINTENDO		0x057e
-#define USB_DEVICE_ID_NINTENDO_WIIMOTE	0x0306
-
-#define USB_VENDOR_ID_NOVATEK		0x0603
-#define USB_DEVICE_ID_NOVATEK_PCT	0x0600
-#define USB_DEVICE_ID_NOVATEK_MOUSE	0x1602
-
-#define USB_VENDOR_ID_NTRIG		0x1b96
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN   0x0001
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1   0x0003
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2   0x0004
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_3   0x0005
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_4   0x0006
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_5   0x0007
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_6   0x0008
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_7   0x0009
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_8   0x000A
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_9   0x000B
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_10   0x000C
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_11   0x000D
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_12   0x000E
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_13   0x000F
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_14   0x0010
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_15   0x0011
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16   0x0012
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17   0x0013
-#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18   0x0014
-
-#define USB_VENDOR_ID_ONTRAK		0x0a07
-#define USB_DEVICE_ID_ONTRAK_ADU100	0x0064
-
-#define USB_VENDOR_ID_ORTEK		0x05a4
-#define USB_DEVICE_ID_ORTEK_PKB1700	0x1700
-#define USB_DEVICE_ID_ORTEK_WKB2000	0x2000
-
-#define USB_VENDOR_ID_PANASONIC		0x04da
-#define USB_DEVICE_ID_PANABOARD_UBT780	0x1044
-#define USB_DEVICE_ID_PANABOARD_UBT880	0x104d
-
-#define USB_VENDOR_ID_PANJIT		0x134c
-
-#define USB_VENDOR_ID_PANTHERLORD	0x0810
-#define USB_DEVICE_ID_PANTHERLORD_TWIN_USB_JOYSTICK	0x0001
-
-#define USB_VENDOR_ID_PENMOUNT		0x14e1
-#define USB_DEVICE_ID_PENMOUNT_PCI	0x3500
-
-#define USB_VENDOR_ID_PETALYNX		0x18b1
-#define USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE	0x0037
-
-#define USB_VENDOR_ID_PHILIPS		0x0471
-#define USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE 0x0617
-
-#define USB_VENDOR_ID_PI_ENGINEERING	0x05f3
-#define USB_DEVICE_ID_PI_ENGINEERING_VEC_USB_FOOTPEDAL	0xff
-
-#define USB_VENDOR_ID_PIXART				0x093a
-#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN	0x8001
-#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1	0x8002
-#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2	0x8003
-
-#define USB_VENDOR_ID_PLAYDOTCOM	0x0b43
-#define USB_DEVICE_ID_PLAYDOTCOM_EMS_USBII	0x0003
-
-#define USB_VENDOR_ID_POWERCOM		0x0d9f
-#define USB_DEVICE_ID_POWERCOM_UPS	0x0002
-
-#define USB_VENDOR_ID_PRODIGE		0x05af
-#define USB_DEVICE_ID_PRODIGE_CORDLESS	0x3062
-
-#define USB_VENDOR_ID_QUANTA		0x0408
-#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH		0x3000
-#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001		0x3001
-#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3008		0x3008
-
-#define USB_VENDOR_ID_REALTEK		0x0bda
-#define USB_DEVICE_ID_REALTEK_READER	0x0152
-
-#define USB_VENDOR_ID_ROCCAT		0x1e7d
-#define USB_DEVICE_ID_ROCCAT_ARVO	0x30d4
-#define USB_DEVICE_ID_ROCCAT_ISKU	0x319c
-#define USB_DEVICE_ID_ROCCAT_KONE	0x2ced
-#define USB_DEVICE_ID_ROCCAT_KONEPLUS	0x2d51
-#define USB_DEVICE_ID_ROCCAT_KONEXTD	0x2e22
-#define USB_DEVICE_ID_ROCCAT_KOVAPLUS	0x2d50
-#define USB_DEVICE_ID_ROCCAT_LUA	0x2c2e
-#define USB_DEVICE_ID_ROCCAT_PYRA_WIRED	0x2c24
-#define USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS	0x2cf6
-#define USB_DEVICE_ID_ROCCAT_SAVU	0x2d5a
-
-#define USB_VENDOR_ID_SAITEK		0x06a3
-#define USB_DEVICE_ID_SAITEK_RUMBLEPAD	0xff17
-#define USB_DEVICE_ID_SAITEK_PS1000	0x0621
-
-#define USB_VENDOR_ID_SAMSUNG		0x0419
-#define USB_DEVICE_ID_SAMSUNG_IR_REMOTE	0x0001
-#define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE	0x0600
-
-#define USB_VENDOR_ID_SENNHEISER	0x1395
-#define USB_DEVICE_ID_SENNHEISER_BTD500USB	0x002c
-
-#define USB_VENDOR_ID_SIGMA_MICRO	0x1c4f
-#define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD	0x0002
-
-#define USB_VENDOR_ID_SIGMATEL		0x066F
-#define USB_DEVICE_ID_SIGMATEL_STMP3780	0x3780
-
-#define USB_VENDOR_ID_SKYCABLE			0x1223
-#define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
-
-#define USB_VENDOR_ID_SONY			0x054c
-#define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE	0x024b
-#define USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE	0x0374
-#define USB_DEVICE_ID_SONY_PS3_BDREMOTE		0x0306
-#define USB_DEVICE_ID_SONY_PS3_CONTROLLER	0x0268
-#define USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER	0x042f
-
-#define USB_VENDOR_ID_SOUNDGRAPH	0x15c2
-#define USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST	0x0034
-#define USB_DEVICE_ID_SOUNDGRAPH_IMON_LAST	0x0046
-
-#define USB_VENDOR_ID_STANTUM		0x1f87
-#define USB_DEVICE_ID_MTP		0x0002
-
-#define USB_VENDOR_ID_STANTUM_STM		0x0483
-#define USB_DEVICE_ID_MTP_STM		0x3261
-
-#define USB_VENDOR_ID_STANTUM_SITRONIX		0x1403
-#define USB_DEVICE_ID_MTP_SITRONIX		0x5001
-
-#define USB_VENDOR_ID_STEELSERIES	0x1038
-#define USB_DEVICE_ID_STEELSERIES_SRWS1	0x1410
-
-#define USB_VENDOR_ID_SUN		0x0430
-#define USB_DEVICE_ID_RARITAN_KVM_DONGLE	0xcdab
-
-#define USB_VENDOR_ID_SUNPLUS		0x04fc
-#define USB_DEVICE_ID_SUNPLUS_WDESKTOP	0x05d8
-
-#define USB_VENDOR_ID_SYMBOL		0x05e0
-#define USB_DEVICE_ID_SYMBOL_SCANNER_1	0x0800
-#define USB_DEVICE_ID_SYMBOL_SCANNER_2	0x1300
-
-#define USB_VENDOR_ID_SYNAPTICS		0x06cb
-#define USB_DEVICE_ID_SYNAPTICS_TP	0x0001
-#define USB_DEVICE_ID_SYNAPTICS_INT_TP	0x0002
-#define USB_DEVICE_ID_SYNAPTICS_CPAD	0x0003
-#define USB_DEVICE_ID_SYNAPTICS_TS	0x0006
-#define USB_DEVICE_ID_SYNAPTICS_STICK	0x0007
-#define USB_DEVICE_ID_SYNAPTICS_WP	0x0008
-#define USB_DEVICE_ID_SYNAPTICS_COMP_TP	0x0009
-#define USB_DEVICE_ID_SYNAPTICS_WTP	0x0010
-#define USB_DEVICE_ID_SYNAPTICS_DPAD	0x0013
-
-#define USB_VENDOR_ID_THINGM		0x27b8
-#define USB_DEVICE_ID_BLINK1		0x01ed
-
-#define USB_VENDOR_ID_THRUSTMASTER	0x044f
-
-#define USB_VENDOR_ID_TIVO		0x150a
-#define USB_DEVICE_ID_TIVO_SLIDE_BT	0x1200
-#define USB_DEVICE_ID_TIVO_SLIDE	0x1201
-
-#define USB_VENDOR_ID_TOPSEED		0x0766
-#define USB_DEVICE_ID_TOPSEED_CYBERLINK	0x0204
-
-#define USB_VENDOR_ID_TOPSEED2		0x1784
-#define USB_DEVICE_ID_TOPSEED2_RF_COMBO	0x0004
-#define USB_DEVICE_ID_TOPSEED2_PERIPAD_701	0x0016
-
-#define USB_VENDOR_ID_TOPMAX		0x0663
-#define USB_DEVICE_ID_TOPMAX_COBRAPAD	0x0103
-
-#define USB_VENDOR_ID_TOUCH_INTL	0x1e5e
-#define USB_DEVICE_ID_TOUCH_INTL_MULTI_TOUCH	0x0313
-
-#define USB_VENDOR_ID_TOUCHPACK		0x1bfd
-#define USB_DEVICE_ID_TOUCHPACK_RTS	0x1688
-
-#define USB_VENDOR_ID_TPV		0x25aa
-#define USB_DEVICE_ID_TPV_OPTICAL_TOUCHSCREEN	0x8883
-
-#define USB_VENDOR_ID_TURBOX		0x062a
-#define USB_DEVICE_ID_TURBOX_KEYBOARD	0x0201
-#define USB_DEVICE_ID_TURBOX_TOUCHSCREEN_MOSART	0x7100
-
-#define USB_VENDOR_ID_TWINHAN		0x6253
-#define USB_DEVICE_ID_TWINHAN_IR_REMOTE	0x0100
-
-#define USB_VENDOR_ID_UCLOGIC		0x5543
-#define USB_DEVICE_ID_UCLOGIC_TABLET_PF1209	0x0042
-#define USB_DEVICE_ID_UCLOGIC_TABLET_KNA5	0x6001
-#define USB_DEVICE_ID_UCLOGIC_TABLET_TWA60	0x0064
-#define USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U	0x0003
-#define USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U	0x0004
-#define USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U	0x0005
-#define USB_DEVICE_ID_UCLOGIC_TABLET_WP1062	0x0064
-#define USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850	0x0522
-#define USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60	0x0781
-
-#define USB_VENDOR_ID_UNITEC	0x227d
-#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0709	0x0709
-#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0A19	0x0a19
-
-#define USB_VENDOR_ID_VELLEMAN		0x10cf
-#define USB_DEVICE_ID_VELLEMAN_K8055_FIRST	0x5500
-#define USB_DEVICE_ID_VELLEMAN_K8055_LAST	0x5503
-#define USB_DEVICE_ID_VELLEMAN_K8061_FIRST	0x8061
-#define USB_DEVICE_ID_VELLEMAN_K8061_LAST	0x8068
-
-#define USB_VENDOR_ID_VERNIER		0x08f7
-#define USB_DEVICE_ID_VERNIER_LABPRO	0x0001
-#define USB_DEVICE_ID_VERNIER_GOTEMP	0x0002
-#define USB_DEVICE_ID_VERNIER_SKIP	0x0003
-#define USB_DEVICE_ID_VERNIER_CYCLOPS	0x0004
-#define USB_DEVICE_ID_VERNIER_LCSPEC	0x0006
-
-#define USB_VENDOR_ID_WACOM		0x056a
-#define USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH	0x81
-#define USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH   0x00BD
-
-#define USB_VENDOR_ID_WALTOP				0x172f
-#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH	0x0032
-#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH	0x0034
-#define USB_DEVICE_ID_WALTOP_Q_PAD			0x0037
-#define USB_DEVICE_ID_WALTOP_PID_0038			0x0038
-#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH	0x0501
-#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH	0x0500
-#define USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET	0x0502
-
-#define USB_VENDOR_ID_WISEGROUP		0x0925
-#define USB_DEVICE_ID_SMARTJOY_PLUS	0x0005
-#define USB_DEVICE_ID_1_PHIDGETSERVO_20	0x8101
-#define USB_DEVICE_ID_4_PHIDGETSERVO_20	0x8104
-#define USB_DEVICE_ID_8_8_4_IF_KIT	0x8201
-#define USB_DEVICE_ID_SUPER_JOY_BOX_3	0x8888
-#define USB_DEVICE_ID_QUAD_USB_JOYPAD	0x8800
-#define USB_DEVICE_ID_DUAL_USB_JOYPAD	0x8866
-
-#define USB_VENDOR_ID_WISEGROUP_LTD	0x6666
-#define USB_VENDOR_ID_WISEGROUP_LTD2	0x6677
-#define USB_DEVICE_ID_SMARTJOY_DUAL_PLUS 0x8802
-#define USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO 0x8801
-#define USB_DEVICE_ID_SUPER_DUAL_BOX_PRO 0x8802
-#define USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO 0x8804
-
-#define USB_VENDOR_ID_X_TENSIONS               0x1ae7
-#define USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE    0x9001
-
-#define USB_VENDOR_ID_XAT	0x2505
-#define USB_DEVICE_ID_XAT_CSR	0x0220
-
-#define USB_VENDOR_ID_XIROKU		0x1477
-#define USB_DEVICE_ID_XIROKU_SPX	0x1006
-#define USB_DEVICE_ID_XIROKU_MPX	0x1007
-#define USB_DEVICE_ID_XIROKU_CSR	0x100e
-#define USB_DEVICE_ID_XIROKU_SPX1	0x1021
-#define USB_DEVICE_ID_XIROKU_CSR1	0x1022
-#define USB_DEVICE_ID_XIROKU_MPX1	0x1023
-#define USB_DEVICE_ID_XIROKU_SPX2	0x1024
-#define USB_DEVICE_ID_XIROKU_CSR2	0x1025
-#define USB_DEVICE_ID_XIROKU_MPX2	0x1026
-
-#define USB_VENDOR_ID_YEALINK		0x6993
-#define USB_DEVICE_ID_YEALINK_P1K_P4K_B2K	0xb001
-
-#define USB_VENDOR_ID_ZEROPLUS		0x0c12
-
-#define USB_VENDOR_ID_ZYDACRON	0x13EC
-#define USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL	0x0006
-
-#define USB_VENDOR_ID_ZYTRONIC		0x14c8
-#define USB_DEVICE_ID_ZYTRONIC_ZXY100	0x0005
-
-#define USB_VENDOR_ID_PRIMAX	0x0461
-#define USB_DEVICE_ID_PRIMAX_KEYBOARD	0x4e05
-
-#endif /*HID_IDS_H_FILE*/
diff --git a/drivers/misc/heci/hid-strings-def.h b/drivers/misc/heci/hid-strings-def.h
deleted file mode 100644
index c058f34..0000000
--- a/drivers/misc/heci/hid-strings-def.h
+++ /dev/null
@@ -1,519 +0,0 @@
-/*
- * HID sensor-related constants and names translations
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef _HID_STRINGS_DEF_H_
-#define _HID_STRINGS_DEF_H_
-
-
-static const struct sensor_map {
-	unsigned code;
-	char *msg;
-} code_msg_arr[] = {
-	{0x01,	"type_collection"},
-	{0x10,	"category_biometric"},
-	{0x11,	"type_biometric_presence"},
-	{0x12,	"type_biometric_proximity"},
-	{0x13,	"type_biometric_touch"},
-	{0x20,	"category_electrical"},
-	{0x21,	"type_electrical_capacitance"},
-	{0x22,	"type_electrical_current"},
-	{0x23,	"type_electrical_power"},
-	{0x24,	"type_electrical_inductance"},
-	{0x25,	"type_electrical_resistance"},
-	{0x26,	"type_electrical_voltage"},
-	{0x27,	"type_electrical_potentiometer"},
-	{0x28,	"type_electrical_frequency"},
-	{0x29,	"type_electrical_period"},
-	{0x30,	"category_environmental"},
-	{0x31,	"type_environmental_atmospheric_pressure"},
-	{0x32,	"type_environmental_humidity"},
-	{0x33,	"type_environmental_temperature"},
-	{0x34,	"type_environmental_wind_direction"},
-	{0x35,	"type_environmental_wind_speed"},
-	{0x40,	"category_light"},
-	{0x41,	"type_light_ambientlight"},
-	{0x42,	"type_light_consumer_infrared"},
-	{0x50,	"category_location"},
-	{0x51,	"type_location_broadcast"},
-	{0x52,	"type_location_dead_reckoning"},
-	{0x53,	"type_location_gps"},
-	{0x54,	"type_location_lookup"},
-	{0x55,	"type_location_other"},
-	{0x56,	"type_location_static"},
-	{0x57,	"type_location_triangulation"},
-	{0x60,	"category_mechanical"},
-	{0x61,	"type_mechanical_boolean_switch"},
-	{0x62,	"type_mechanical_boolean_switch_array"},
-	{0x63,	"type_mechanical_multivalue_switch"},
-	{0x64,	"type_mechanical_force"},
-	{0x65,	"type_mechanical_pressure"},
-	{0x66,	"type_mechanical_strain"},
-	{0x67,	"type_mechanical_scale_weight"},
-	{0x68,	"type_mechanical_vibrator"},
-	{0x69,	"type_mechanical_hall_effect_switch"},
-	{0x70,	"category_motion"},
-	{0x71,	"type_motion_accelerometer_1d"},
-	{0x72,	"type_motion_accelerometer_2d"},
-	{0x73,	"type_motion_accelerometer_3d"},
-	{0x74,	"type_motion_gyrometer_1d"},
-	{0x75,	"type_motion_gyrometer_2d"},
-	{0x76,	"type_motion_gyrometer_3d"},
-	{0x77,	"type_motion_motion_detector"},
-	{0x78,	"type_motion_speedometer"},
-	{0x79,	"type_motion_accelerometer"},
-	{0x7A,	"type_motion_gyrometer"},
-	{0x80,	"category_orientation"},
-	{0x81,	"type_orientation_compass_1d"},
-	{0x82,	"type_orientation_compass_2d"},
-	{0x83,	"type_orientation_compass_3d"},
-	{0x84,	"type_orientation_inclinometer_1d"},
-	{0x85,	"type_orientation_inclinometer_2d"},
-	{0x86,	"type_orientation_inclinometer_3d"},
-	{0x87,	"type_orientation_distance_1d"},
-	{0x88,	"type_orientation_distance_2d"},
-	{0x89,	"type_orientation_distance_3d"},
-	{0x8A,	"type_orientation_device_orientation"},
-	{0x8B,	"type_orientation_compass"},
-	{0x8C,	"type_orientation_inclinometer"},
-	{0x8D,	"type_orientation_distance"},
-	{0x90,	"category_scanner"},
-	{0x91,	"type_scanner_barcode"},
-	{0x92,	"type_scanner_rfid"},
-	{0x93,	"type_scanner_nfc"},
-	{0xA0,	"category_time"},
-	{0xA1,	"type_time_alarm"},
-	{0xA2,	"type_time_rtc"},
-	{0xE0,	"category_other"},
-	{0xE1,	"type_other_custom"},
-	{0xE2,	"type_other_generic"},
-	{0xE3,	"type_other_generic_enumerator"},
-	{0xE4,	"type_other_health_monitor"},
-	{0x0201,	"property_sensor_state"},
-	{0x0800,	"state_unknown_sel"},
-	{0x0801,	"state_ready_sel"},
-	{0x0802,	"state_not_available_sel"},
-	{0x0803,	"state_no_data_sel"},
-	{0x0804,	"state_initializing_sel"},
-	{0x0805,	"state_access_denied_sel"},
-	{0x0806,	"state_error_sel"},
-	{0x0202,	"event"},
-	{0x0810,	"event_unknown_sel"},
-	{0x0811,	"event_state_changed_sel"},
-	{0x0812,	"event_property_changed_sel"},
-	{0x0813,	"event_data_updated_sel"},
-	{0x0814,	"event_poll_response_sel"},
-	{0x0815,	"event_change_sensitivity_sel"},
-	{0x0816,	"event_max_reached_sel"},
-	{0x0817,	"event_min_reached_sel"},
-	{0x0818,	"event_high_threshold_cross_upward_sel"},
-	{0x0819,	"event_high_threshold_cross_downward_sel"},
-	{0x081A,	"event_low_threshold_cross_upward_sel"},
-	{0x081B,	"event_low_threshold_cross_downward_sel"},
-	{0x081C,	"event_zero_threshold_cross_upward_sel"},
-	{0x081D,	"event_zero_threshold_cross_downward_sel"},
-	{0x081E,	"event_period_exceeded_sel"},
-	{0x081F,	"event_frequency_exceeded_sel"},
-	{0x0820,	"event_complex_trigger_sel"},
-	{0x0300,	"property"},
-	{0x0301,	"property_friendly_name"},
-	{0x0302,	"property_persistent_unique_id"},
-	{0x0303,	"property_sensor_status"},
-	{0x0304,	"property_minimum_report_interval"},
-	{0x0305,	"property_sensor_manufacturer"},
-	{0x0306,	"property_sensor_model"},
-	{0x0307,	"property_sensor_serial_number"},
-	{0x0308,	"property_sensor_description"},
-	{0x0309,	"property_sensor_connection_type"},
-	{0x0830,	"property_connection_type_pc_integrated_sel"},
-	{0x0831,	"property_connection_type_pc_attached_sel"},
-	{0x0832,	"property_connection_type_pc_external_sel"},
-	{0x030A,	"property_sensor_device_path"},
-	{0x030B,	"property_hardware_revision"},
-	{0x030C,	"property_firmware_version"},
-	{0x030D,	"property_release_date"},
-	{0x030E,	"property_report_interval"},
-	{0x030F,	"property_change_sensitivity_abs"},
-	{0x0310,	"property_change_sensitivity_range_pct"},
-	{0x0311,	"property_change_sensitivity_rel_pct"},
-	{0x0312,	"property_accuracy"},
-	{0x0313,	"property_resolution"},
-	{0x0314,	"property_range_maximum"},
-	{0x0315,	"property_range_minimum"},
-	{0x0316,	"property_reporting_state"},
-	{0x0840,	"property_reporting_state_no_events_sel"},
-	{0x0841,	"property_reporting_state_all_events_sel"},
-	{0x0842,	"property_reporting_state_threshold_events_sel"},
-	{0x0843,	"property_reporting_state_no_events_wake_sel"},
-	{0x0844,	"property_reporting_state_all_events_wake_sel"},
-	{0x0845,	"property_reporting_state_threshold_events_wake_sel"},
-	{0x0317,	"property_sampling_rate"},
-	{0x0318,	"property_response_curve"},
-	{0x0319,	"property_power_state"},
-	{0x0850,	"property_power_state_undefined_sel"},
-	{0x0851,	"property_power_state_d0_full_power_sel"},
-	{0x0852,	"property_power_state_d1_low_power_sel"},
-	{0x0853,	"property_power_state_d2_standby_with_wake_sel"},
-	{0x0854,	"property_power_state_d3_sleep_with_wake_sel"},
-	{0x0855,	"property_power_state_d4_power_off_sel"},
-	{0x08E0,	"property_orientation_magnetometer_accuracy_low"},
-	{0x08E1,	"property_orientation_magnetometer_accuracy_medium"},
-	{0x08E2,	"property_orientation_magnetometer_accuracy_high"},
-	{0x0400,	"data_location"},
-	{0x0401,	"data_location_desired_accuracy"},
-	{0x0402,	"data_location_altitude_antenna_sealevel"},
-	{0x0403,	"data_location_differential_reference_station_id"},
-	{0x0404,	"data_location_altitide_elipsoid_error"},
-	{0x0405,	"data_location_altitide_elipsoid"},
-	{0x0406,	"data_location_altitude_sealevel_error"},
-	{0x0407,	"data_location_altitude_sealevel"},
-	{0x0408,	"data_location_dgps_data_age"},
-	{0x0409,	"data_location_error_radius"},
-	{0x040A,	"data_location_fix_quality"},
-	{0x0870,	"data_fix_quality_no_fix"},
-	{0x0871,	"data_fix_quality_gps"},
-	{0x0872,	"data_fix_quality_dgps"},
-	{0x040B,	"data_location_fix_type"},
-	{0x0880,	"data_fix_type_no_fix"},
-	{0x0881,	"data_fix_type_gps_sps_mode_fix_valid"},
-	{0x0882,	"data_fix_type_dgps_sps_mode_fix_valid"},
-	{0x0883,	"data_fix_type_gps_pps_mode_fix_valid"},
-	{0x0884,	"data_fix_type_real_time_kinematic"},
-	{0x0885,	"data_fix_type_float_rtk"},
-	{0x0886,	"data_fix_type_estimated_dead_reckoning"},
-	{0x0887,	"data_fix_type_manual_input_mode"},
-	{0x0888,	"data_fix_type_simulator_mode"},
-	{0x040C,	"data_location_geoidal_separation"},
-	{0x040D,	"data_location_gps_operation_mode"},
-	{0x0890,	"data_gps_op_mode_manual"},
-	{0x0891,	"data_gps_op_mode_automatic"},
-	{0x040E,	"data_location_gps_selection_mode"},
-	{0x08A0,	"data_gps_sel_mode_autonomous"},
-	{0x08A1,	"data_gps_sel_mode_dgps"},
-	{0x08A2,	"data_gps_sel_mode_estimated_dead_reckoning"},
-	{0x08A3,	"data_gps_sel_mode_manual_input"},
-	{0x08A4,	"data_gps_sel_mode_simulator"},
-	{0x08A5,	"data_gps_sel_mode_data_not_valid"},
-	{0x040F,	"data_location_gps_status"},
-	{0x08B0,	"data_gps_status_data_valid"},
-	{0x08B1,	"data_gps_status_data_not_valid"},
-	{0x0410,	"data_location_position_dilution_of_precision"},
-	{0x0411,	"data_location_horizontal_dilution_of_precision"},
-	{0x0412,	"data_location_vertical_dilution_of_precision"},
-	{0x0413,	"data_location_latitude"},
-	{0x0414,	"data_location_longitude"},
-	{0x0415,	"data_location_true_heading"},
-	{0x0416,	"data_location_magnetic_heading"},
-	{0x0417,	"data_location_magnetic_variation"},
-	{0x0418,	"data_location_speed"},
-	{0x0419,	"data_location_satellites_in_view"},
-	{0x041A,	"data_location_satellites_in_view_azimuth"},
-	{0x041B,	"data_location_satellites_in_view_elevation"},
-	{0x041C,	"data_location_satellites_in_view_id"},
-	{0x041D,	"data_location_satellites_in_view_prns"},
-	{0x041E,	"data_location_satellites_in_view_stn_ratio"},
-	{0x041F,	"data_location_satellites_used_count"},
-	{0x0420,	"data_location_satellites_used_prns"},
-	{0x0421,	"data_location_nmea_sentence"},
-	{0x0422,	"data_location_address_line_1"},
-	{0x0423,	"data_location_address_line_2"},
-	{0x0424,	"data_location_city"},
-	{0x0425,	"data_location_state_or_province"},
-	{0x0426,	"data_location_country_or_region"},
-	{0x0427,	"data_location_postal_code"},
-	{0x042A,	"property_location"},
-	{0x042B,	"property_location_desired_accuracy"},
-	{0x0860,	"desired_accuracy_default"},
-	{0x0861,	"desired_accuracy_high"},
-	{0x0862,	"desired_accuracy_medium"},
-	{0x0863,	"desired_accuracy_low"},
-	{0x0430,	"data_environmental"},
-	{0x0431,	"data_environmental_atmospheric_pressure"},
-	{0x0432,	"data_environmental_reference_pressure"},
-	{0x0433,	"data_environmental_relative_humidity"},
-	{0x0434,	"data_environmental_temperature"},
-	{0x0435,	"data_environmental_wind_direction"},
-	{0x0436,	"data_environmental_wind_speed"},
-	{0x0440,	"property_environmental"},
-	{0x0441,	"property_environmental_reference_pressure"},
-	{0x0450,	"data_motion"},
-	{0x0451,	"data_motion_state"},
-	{0x0452,	"data_motion_acceleration"},
-	{0x0453,	"data_motion_acceleration_x_axis"},
-	{0x0454,	"data_motion_acceleration_y_axis"},
-	{0x0455,	"data_motion_acceleration_z_axis"},
-	{0x0456,	"data_motion_angular_velocity"},
-	{0x0457,	"data_motion_angular_velocity_x_axis"},
-	{0x0458,	"data_motion_angular_velocity_y_axis"},
-	{0x0459,	"data_motion_angular_velocity_z_axis"},
-	{0x045A,	"data_motion_angular_position"},
-	{0x045B,	"data_motion_angular_position_x_axis"},
-	{0x045C,	"data_motion_angular_position_y_axis"},
-	{0x045D,	"data_motion_angular_position_z_axis"},
-	{0x045E,	"data_motion_speed"},
-	{0x045F,	"data_motion_intensity"},
-	{0x0470,	"data_orientation"},
-	{0x0471,	"data_orientation_magnetic_heading"},
-	{0x0472,	"data_orientation_magnetic_heading_x"},
-	{0x0473,	"data_orientation_magnetic_heading_y"},
-	{0x0474,	"data_orientation_magnetic_heading_z"},
-	{0x0475,	"data_orientation_compensated_magnetic_north"},
-	{0x0476,	"data_orientation_compensated_true_north"},
-	{0x0477,	"data_orientation_magnetic_north"},
-	{0x0478,	"data_orientation_true_north"},
-	{0x0479,	"data_orientation_distance"},
-	{0x047A,	"data_orientation_distance_x"},
-	{0x047B,	"data_orientation_distance_y"},
-	{0x047C,	"data_orientation_distance_z"},
-	{0x047D,	"data_orientation_distance_out_of_range"},
-	{0x047E,	"data_orientation_tilt"},
-	{0x047F,	"data_orientation_tilt_x"},
-	{0x0480,	"data_orientation_tilt_y"},
-	{0x0481,	"data_orientation_tilt_z"},
-	{0x0482,	"data_orientation_rotation_matrix"},
-	{0x0483,	"data_orientation_quaternion"},
-	{0x0484,	"data_orientation_magnetic_flux"},
-	{0x0485,	"data_orientation_magnetic_flux_x_axis"},
-	{0x0486,	"data_orientation_magnetic_flux_y_axis"},
-	{0x0487,	"data_orientation_magnetic_flux_z_axis"},
-	{0x0488,	"data_orientation_magnetometer_accuracy"},
-	{0x0490,	"data_mechanical"},
-	{0x0491,	"data_mechanical_boolean_switch_state"},
-	{0x0492,	"data_mechanical_boolean_switch_array_states"},
-	{0x0493,	"data_mechanical_multivalue_switch_value"},
-	{0x0494,	"data_mechanical_force"},
-	{0x0495,	"data_mechanical_absolute_pressure"},
-	{0x0496,	"data_mechanical_gauge_pressure"},
-	{0x0497,	"data_mechanical_strain"},
-	{0x0498,	"data_mechanical_weight"},
-	{0x04A0,	"property_mechanical"},
-	{0x04A1,	"property_mechanical_vibration_state"},
-	{0x04A2,	"data_mechanical_vibration_speed_forward"},
-	{0x04A3,	"data_mechanical_vibration_speed_backward"},
-	{0x04B0,	"data_biometric"},
-	{0x04B1,	"data_biometric_human_presence"},
-	{0x04B2,	"data_biometric_human_proximity_range"},
-	{0x04B3,	"data_biometric_human_proximity_out_of_range"},
-	{0x04B4,	"data_biometric_human_touch_state"},
-	{0x04D0,	"data_light"},
-	{0x04D1,	"data_light_illuminance"},
-	{0x04D2,	"data_light_color_temperature"},
-	{0x04D3,	"data_light_chromaticity"},
-	{0x04D4,	"data_light_chromaticity_x"},
-	{0x04D5,	"data_light_chromaticity_y"},
-	{0x04D6,	"data_light_consumer_ir_sentence_receive"},
-	{0x04E0,	"property_light"},
-	{0x04E1,	"property_light_consumer_ir_sentence_send"},
-	{0x04F0,	"data_scanner"},
-	{0x04F1,	"data_scanner_rfid_tag"},
-	{0x04F2,	"data_scanner_nfc_sentence_receive"},
-	{0x04F8,	"property_scanner"},
-	{0x04F9,	"property_scanner_nfc_sentence_send"},
-	{0x0500,	"data_electrical"},
-	{0x0501,	"data_electrical_capacitance"},
-	{0x0502,	"data_electrical_current"},
-	{0x0503,	"data_electrical_power"},
-	{0x0504,	"data_electrical_inductance"},
-	{0x0505,	"data_electrical_resistance"},
-	{0x0506,	"data_electrical_voltage"},
-	{0x0507,	"data_electrical_frequency"},
-	{0x0508,	"data_electrical_period"},
-	{0x0509,	"data_electrical_percent_of_range"},
-	{0x0520,	"data_time"},
-	{0x0521,	"data_time_year"},
-	{0x0522,	"data_time_month"},
-	{0x0523,	"data_time_day"},
-	{0x0524,	"data_time_day_of_week"},
-	{0x0525,	"data_time_hour"},
-	{0x0526,	"data_time_minute"},
-	{0x0527,	"data_time_second"},
-	{0x0528,	"data_time_millisecond"},
-	{0x0529,	"data_time_timestamp"},
-	{0x052A,	"data_time_julian_day_of_year"},
-	{0x0530,	"property_time"},
-	{0x0531,	"property_time_time_zone_offset_from_utc"},
-	{0x0532,	"property_time_time_zone_name"},
-	{0x0533,	"property_time_daylight_savings_time_observed"},
-	{0x0534,	"property_time_time_trim_adjustment"},
-	{0x0535,	"property_time_arm_alarm"},
-	{0x0540,	"data_custom"},
-	{0x0541,	"data_custom_usage"},
-	{0x0542,	"data_custom_boolean_array"},
-	{0x0543,	"data_custom_value"},
-	{0x0544,	"data_custom_value_1"},
-	{0x0545,	"data_custom_value_2"},
-	{0x0546,	"data_custom_value_3"},
-	{0x0547,	"data_custom_value_4"},
-	{0x0548,	"data_custom_value_5"},
-	{0x0549,	"data_custom_value_6"},
-	{0x054A,	"data_custom_value_7"},
-	{0x054B,	"data_custom_value_8"},
-	{0x054C,	"data_custom_value_9"},
-	{0x054D,	"data_custom_value_10"},
-	{0x054E,	"data_custom_value_11"},
-	{0x054F,	"data_custom_value_12"},
-	{0x0550,	"data_custom_value_13"},
-	{0x0551,	"data_custom_value_14"},
-	{0x0552,	"data_custom_value_15"},
-	{0x0553,	"data_custom_value_16"},
-	{0x0554,	"data_custom_value_17"},
-	{0x0555,	"data_custom_value_18"},
-	{0x0556,	"data_custom_value_19"},
-	{0x0557,	"data_custom_value_20"},
-	{0x0558,	"data_custom_value_21"},
-	{0x0559,	"data_custom_value_22"},
-	{0x055A,	"data_custom_value_23"},
-	{0x055B,	"data_custom_value_24"},
-	{0x055C,	"data_custom_value_25"},
-	{0x055D,	"data_custom_value_26"},
-	{0x055E,	"data_custom_value_27"},
-	{0x055F,	"data_custom_value_28"},
-	{0x0560,	"data_generic"},
-	{0x0561,	"data_generic_guid_or_propertykey"},
-	{0x0562,	"data_generic_category_guid"},
-	{0x0563,	"data_generic_type_guid"},
-	{0x0564,	"data_generic_event_propertykey"},
-	{0x0565,	"data_generic_property_propertykey"},
-	{0x0566,	"data_generic_datafield_propertykey"},
-	{0x0567,	"data_generic_event"},
-	{0x0568,	"data_generic_property"},
-	{0x0569,	"data_generic_datafield"},
-	{0x056A,	"data_enumerator_table_row_index"},
-	{0x056B,	"data_enumerator_table_row_count"},
-	{0x056C,	"data_generic_guid_or_propertykey_kind"},
-	{0x08D0,	"gorpk_kind_category"},
-	{0x08D1,	"gorpk_kind_type"},
-	{0x08D2,	"gorpk_kind_event"},
-	{0x08D3,	"gorpk_kind_property"},
-	{0x08D4,	"gorpk_kind_datafield"},
-	{0x056D,	"data_generic_guid"},
-	{0x056E,	"data_generic_propertykey"},
-	{0x056F,	"data_generic_top_level_collection_id"},
-	{0x0570,	"data_generic_report_id"},
-	{0x0571,	"data_generic_report_item_position_index"},
-	{0x0572,	"data_generic_firmware_vartype"},
-	{0x0900,	"firmware_vartype_vt_null"},
-	{0x0901,	"firmware_vartype_vt_bool"},
-	{0x0902,	"firmware_vartype_vt_ui1"},
-	{0x0903,	"firmware_vartype_vt_i1"},
-	{0x0904,	"firmware_vartype_vt_ui2"},
-	{0x0905,	"firmware_vartype_vt_i2"},
-	{0x0906,	"firmware_vartype_vt_ui4"},
-	{0x0907,	"firmware_vartype_vt_i4"},
-	{0x0908,	"firmware_vartype_vt_ui8"},
-	{0x0909,	"firmware_vartype_vt_i8"},
-	{0x090A,	"firmware_vartype_vt_r4"},
-	{0x090B,	"firmware_vartype_vt_r8"},
-	{0x090C,	"firmware_vartype_vt_wstr"},
-	{0x090D,	"firmware_vartype_vt_str"},
-	{0x090E,	"firmware_vartype_vt_clsid"},
-	{0x090F,	"firmware_vartype_vt_vector_vt_ui1"},
-	{0x0910,	"firmware_vartype_vt_f16e0"},
-	{0x0911,	"firmware_vartype_vt_f16e1"},
-	{0x0912,	"firmware_vartype_vt_f16e2"},
-	{0x0913,	"firmware_vartype_vt_f16e3"},
-	{0x0914,	"firmware_vartype_vt_f16e4"},
-	{0x0915,	"firmware_vartype_vt_f16e5"},
-	{0x0916,	"firmware_vartype_vt_f16e6"},
-	{0x0917,	"firmware_vartype_vt_f16e7"},
-	{0x0918,	"firmware_vartype_vt_f16e8"},
-	{0x0919,	"firmware_vartype_vt_f16e9"},
-	{0x091A,	"firmware_vartype_vt_f16ea"},
-	{0x091B,	"firmware_vartype_vt_f16eb"},
-	{0x091C,	"firmware_vartype_vt_f16ec"},
-	{0x091D,	"firmware_vartype_vt_f16ed"},
-	{0x091E,	"firmware_vartype_vt_f16ee"},
-	{0x091F,	"firmware_vartype_vt_f16ef"},
-	{0x0920,	"firmware_vartype_vt_f32e0"},
-	{0x0921,	"firmware_vartype_vt_f32e1"},
-	{0x0922,	"firmware_vartype_vt_f32e2"},
-	{0x0923,	"firmware_vartype_vt_f32e3"},
-	{0x0924,	"firmware_vartype_vt_f32e4"},
-	{0x0925,	"firmware_vartype_vt_f32e5"},
-	{0x0926,	"firmware_vartype_vt_f32e6"},
-	{0x0927,	"firmware_vartype_vt_f32e7"},
-	{0x0928,	"firmware_vartype_vt_f32e8"},
-	{0x0929,	"firmware_vartype_vt_f32e9"},
-	{0x092A,	"firmware_vartype_vt_f32ea"},
-	{0x092B,	"firmware_vartype_vt_f32eb"},
-	{0x092C,	"firmware_vartype_vt_f32ec"},
-	{0x092D,	"firmware_vartype_vt_f32ed"},
-	{0x092E,	"firmware_vartype_vt_f32ee"},
-	{0x092F,	"firmware_vartype_vt_f32ef"},
-	{0x0573,	"data_generic_unit_of_measure"},
-	{0x0940,	"generic_unit_not_specified"},
-	{0x0941,	"generic_unit_lux"},
-	{0x0942,	"generic_unit_degrees_kelvin"},
-	{0x0943,	"generic_unit_degrees_celsius"},
-	{0x0944,	"generic_unit_pascal"},
-	{0x0945,	"generic_unit_newton"},
-	{0x0946,	"generic_unit_meters_per_second"},
-	{0x0947,	"generic_unit_kilogram"},
-	{0x0948,	"generic_unit_meter"},
-	{0x0949,	"generic_unit_meters_per_sec_sqrd"},
-	{0x094A,	"generic_unit_farad"},
-	{0x094B,	"generic_unit_ampere"},
-	{0x094C,	"generic_unit_watt"},
-	{0x094D,	"generic_unit_henry"},
-	{0x094E,	"generic_unit_ohm"},
-	{0x094F,	"generic_unit_volt"},
-	{0x0950,	"generic_unit_hertz"},
-	{0x0951,	"generic_unit_bar"},
-	{0x0952,	"generic_unit_degrees_anti_clockwise"},
-	{0x0953,	"generic_unit_degrees_clockwise"},
-	{0x0954,	"generic_unit_degrees"},
-	{0x0955,	"generic_unit_degrees_per_second"},
-	{0x0956,	"generic_unit_degrees_per_sec_sqrd"},
-	{0x0957,	"generic_unit_knot"},
-	{0x0958,	"generic_unit_percent"},
-	{0x0959,	"generic_unit_second"},
-	{0x095A,	"generic_unit_millisecond"},
-	{0x095B,	"generic_unit_g"},
-	{0x095C,	"generic_unit_bytes"},
-	{0x095D,	"generic_unit_milligauss"},
-	{0x095E,	"generic_unit_bits"},
-	{0x0574,	"data_generic_unit_exponent"},
-	{0x0970,	"generic_exponent_0"},
-	{0x0971,	"generic_exponent_1"},
-	{0x0972,	"generic_exponent_2"},
-	{0x0973,	"generic_exponent_3"},
-	{0x0974,	"generic_exponent_4"},
-	{0x0975,	"generic_exponent_5"},
-	{0x0976,	"generic_exponent_6"},
-	{0x0977,	"generic_exponent_7"},
-	{0x0978,	"generic_exponent_8"},
-	{0x0979,	"generic_exponent_9"},
-	{0x097A,	"generic_exponent_a"},
-	{0x097B,	"generic_exponent_b"},
-	{0x097C,	"generic_exponent_c"},
-	{0x097D,	"generic_exponent_d"},
-	{0x097E,	"generic_exponent_e"},
-	{0x097F,	"generic_exponent_f"},
-	{0x0575,	"data_generic_report_size"},
-	{0x0576,	"data_generic_report_count"},
-	{0x0580,	"property_generic"},
-	{0x0581,	"property_enumerator_table_row_index"},
-	{0x0582,	"property_enumerator_table_row_count"},
-	{0,	0}
-};
-
-static const char *modifiers[16] = {"none", "chg_sensitivity_abs", "max", "min",
-	"accuracy", "resolution", "thres_high", "thres_low",
-	"calibration_offset", "calibration_multiplier", "report_interval",
-	"freq_max", "period_max", "chg_sensitivity_percent_range",
-	"chg_sensitivity_percent_rel", "custom"};
-
-
-#endif /* _HID_STRINGS_DEF_H_ */
-
diff --git a/drivers/misc/heci/hw-ish-regs.h b/drivers/misc/heci/hw-ish-regs.h
deleted file mode 100644
index 9d3db55..0000000
--- a/drivers/misc/heci/hw-ish-regs.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * ISH registers definitions
- *
- * Copyright (c) 2012-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef _HECI_ISH_REGS_H_
-#define _HECI_ISH_REGS_H_
-
-
-/* IPC PCI Offsets and sizes */
-#define IPC_REG_BASE             0x0000 /* Ish IPC Base Address */
-/*Peripheral Interrupt Status Register */
-#define IPC_REG_PISR             (IPC_REG_BASE + 0x00)
-/* Peripheral Interrupt Mask Register */
-#define IPC_REG_PIMR             (IPC_REG_BASE + 0x04)
-/* ISH Host Firmware status Register */
-#define IPC_REG_ISH_HOST_FWSTS   (IPC_REG_BASE + 0x34)
-/* Host Communication Register */
-#define IPC_REG_HOST_COMM        (IPC_REG_BASE + 0x38)
-/* Reset register */
-#define IPC_REG_ISH_RST          (IPC_REG_BASE + 0x44)
-
-/*Inbound doorbell register Host to ISH */
-#define IPC_REG_HOST2ISH_DRBL    (IPC_REG_BASE + 0x48)
-/*Outbound doorbell register ISH to Host */
-#define IPC_REG_ISH2HOST_DRBL    (IPC_REG_BASE + 0x54)
-/* ISH to HOST message registers */
-#define IPC_REG_ISH2HOST_MSG     (IPC_REG_BASE + 0x60)
-/* HOST to ISH message registers */
-#define IPC_REG_HOST2ISH_MSG     (IPC_REG_BASE + 0xE0)
-/* REMAP2 to enable DMA (D3 RCR) */
-#define	IPC_REG_ISH_RMP2	 (IPC_REG_BASE + 0x368)
-
-/* register bits - HISR */
-
-/* bit corresponds HOST2ISH interrupt in PISR and PIMR registers */
-#define IPC_INT_HOST2ISH_BIT            (1<<0)
-/* bit corresponds ISH2HOST interrupt in PISR and PIMR registers */
-#define IPC_INT_ISH2HOST_BIT            (1<<3)
-/* bit corresponds ISH2HOST busy clear interrupt in PIMR register */
-#define IPC_INT_ISH2HOST_CLR_MASK_BIT   (1<<11)
-
-/* offset of ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
-#define IPC_INT_ISH2HOST_CLR_OFFS       (0)
-
-/* bit corresponds ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
-#define IPC_INT_ISH2HOST_CLR_BIT        (1<<IPC_INT_ISH2HOST_CLR_OFFS)
-
-/* bit corresponds busy bit in doorbell registers */
-#define IPC_DRBL_BUSY_OFFS              (31)
-#define IPC_DRBL_BUSY_BIT               (1<<IPC_DRBL_BUSY_OFFS)
-
-#define	IPC_HOST_OWNS_MSG_OFFS		(30)
-
-/* A0: bit means that host owns MSGnn registers and is reading them.
-ISS FW may not write to them */
-#define	IPC_HOST_OWNS_MSG_BIT		(1<<IPC_HOST_OWNS_MSG_OFFS)
-
-/*
- * Host status bits (HOSTCOMM)
- */
-/* bit corresponds host ready bit in Host Status Register (HOST_COMM) */
-#define IPC_HOSTCOMM_READY_OFFS		(7)
-#define IPC_HOSTCOMM_READY_BIT		(1<<IPC_HOSTCOMM_READY_OFFS)
-
-#define	IPC_HOSTCOMM_INT_EN_OFFS	(31)
-#define	IPC_HOSTCOMM_INT_EN_BIT		(1<<IPC_HOSTCOMM_INT_EN_OFFS)
-
-/*
- * as of now, both Host and ISS have ILUP at bit 0
- * bit corresponds host ready bit in both status registers
- */
-#define IPC_ILUP_OFFS			(0)
-#define IPC_ILUP_BIT			(1<<IPC_ILUP_OFFS)
-
-/*
- * FW status bits (relevant)
- */ 
-#define	IPC_FWSTS_ILUP		0x1
-#define	IPC_FWSTS_HECI_UP	(1<<1)
-#define	IPC_FWSTS_DMA0		(1<<16)
-#define	IPC_FWSTS_DMA1		(1<<17)
-#define	IPC_FWSTS_DMA2		(1<<18)
-#define	IPC_FWSTS_DMA3		(1<<19)
-
-#define	IPC_ISH_IN_DMA		\
-	(IPC_FWSTS_DMA0 | IPC_FWSTS_DMA1 | IPC_FWSTS_DMA2 | IPC_FWSTS_DMA3)
-
-/* bit corresponds host ready bit in ISS FW Status Register */
-#define IPC_ISH_HECI_READY_OFFS              (1)
-#define IPC_ISH_HECI_READY_BIT               (1<<IPC_ISH_HECI_READY_OFFS)
-
-#define	IPC_RMP2_DMA_ENABLED	0x1	/* Value to enable DMA, per D3 RCR */
-
-#define IPC_MSG_MAX_SIZE	0x80
-
-
-#define IPC_HEADER_LENGTH_MASK          (0x03FF)
-#define IPC_HEADER_PROTOCOL_MASK        (0x0F)
-#define IPC_HEADER_MNG_CMD_MASK         (0x0F)
-
-#define IPC_HEADER_LENGTH_OFFSET         0
-#define IPC_HEADER_PROTOCOL_OFFSET      10
-#define IPC_HEADER_MNG_CMD_OFFSET       16
-
-#define IPC_HEADER_GET_LENGTH(drbl_reg)		\
-	(((drbl_reg) >> IPC_HEADER_LENGTH_OFFSET)&IPC_HEADER_LENGTH_MASK)
-#define IPC_HEADER_GET_PROTOCOL(drbl_reg)	\
-	(((drbl_reg) >> IPC_HEADER_PROTOCOL_OFFSET)&IPC_HEADER_PROTOCOL_MASK)
-#define IPC_HEADER_GET_MNG_CMD(drbl_reg)	\
-	(((drbl_reg) >> IPC_HEADER_MNG_CMD_OFFSET)&IPC_HEADER_MNG_CMD_MASK)
-
-#define IPC_IS_BUSY(drbl_reg)			\
-	(((drbl_reg)&IPC_DRBL_BUSY_BIT) == ((u32)IPC_DRBL_BUSY_BIT))
-
-#define IPC_SET_BUSY(drbl_reg)		((drbl_reg) | (IPC_DRBL_BUSY_BIT))
-
-#define IPC_INT_FROM_ISH_TO_HOST(drbl_reg)	\
-	(((drbl_reg)&IPC_INT_ISH2HOST_BIT) == ((u32)IPC_INT_ISH2HOST_BIT))
-
-#define IPC_BUILD_HEADER(length, protocol, busy)		\
-	(((busy)<<IPC_DRBL_BUSY_OFFS) |				\
-	((protocol) << IPC_HEADER_PROTOCOL_OFFSET) |		\
-	((length)<<IPC_HEADER_LENGTH_OFFSET))
-
-#define IPC_BUILD_MNG_MSG(cmd, length)				\
-	(((1)<<IPC_DRBL_BUSY_OFFS)|				\
-	((IPC_PROTOCOL_MNG)<<IPC_HEADER_PROTOCOL_OFFSET)|	\
-	((cmd)<<IPC_HEADER_MNG_CMD_OFFSET)|((length)<<IPC_HEADER_LENGTH_OFFSET))
-
-
-#define IPC_SET_HOST_READY(host_status)		\
-				((host_status) |= (IPC_HOSTCOMM_READY_BIT))
-
-#define IPC_SET_HOST_ILUP(host_status)		\
-				((host_status) |= (IPC_ILUP_BIT))
-
-#define IPC_CLEAR_HOST_READY(host_status)	\
-				((host_status) ^= (IPC_HOSTCOMM_READY_BIT))
-
-#define IPC_CLEAR_HOST_ILUP(host_status)	\
-				((host_status) ^= (IPC_ILUP_BIT))
-
-/* todo - temp until PIMR HW ready */
-#define IPC_HOST_BUSY_READING_OFFS				(6)
-
-/* bit corresponds host ready bit in Host Status Register (HOST_COMM) */
-#define IPC_HOST_BUSY_READING_BIT	(1<<IPC_HOST_BUSY_READING_OFFS)
-
-#define IPC_SET_HOST_BUSY_READING(host_status)	\
-				((host_status) |= (IPC_HOST_BUSY_READING_BIT))
-
-#define IPC_CLEAR_HOST_BUSY_READING(host_status)\
-				((host_status) ^= (IPC_HOST_BUSY_READING_BIT))
-
-
-#define IPC_IS_ISH_HECI_READY(ish_status)       \
-		(((ish_status)&IPC_ISH_HECI_READY_BIT) == ((u32)IPC_ISH_HECI_READY_BIT))
-
-#define IPC_IS_ISH_ILUP(ish_status)		\
-			(((ish_status)&IPC_ILUP_BIT) == ((u32)IPC_ILUP_BIT))
-
-
-#define IPC_PROTOCOL_HECI               1
-#define IPC_PROTOCOL_MNG                3
-
-#define MNG_RX_CMPL_ENABLE              0
-#define MNG_RX_CMPL_DISABLE             1
-#define MNG_RX_CMPL_INDICATION          2
-#define MNG_RESET_NOTIFY		3
-#define MNG_RESET_NOTIFY_ACK		4
-#define MNG_SYNC_FW_CLOCK		5
-#define MNG_ILLEGAL_CMD			0xFF
-
-#endif /* _HECI_ISH_REGS_H_ */
-
diff --git a/drivers/misc/heci/hw-ish.c b/drivers/misc/heci/hw-ish.c
deleted file mode 100644
index caa7539..0000000
--- a/drivers/misc/heci/hw-ish.c
+++ /dev/null
@@ -1,981 +0,0 @@
-/*
- * H/W layer of HECI provider device (ISS)
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include "client.h"
-#include "hw-ish.h"
-#include "utils.h"
-#include "heci_dev.h"
-#include "hbm.h"
-#include <linux/spinlock.h>
-#include <linux/jiffies.h>
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static void no_dev_dbg(void *v, char *s, ...)
-{
-}
-/*#define dev_dbg dev_err*/
-#define dev_dbg no_dev_dbg
-
-#include <linux/delay.h>
-
-/**
- * ish_reg_read - reads 32bit register
- *
- * @dev: the device structure
- * @offset: offset from which to read the data
- */
-static inline u32 ish_reg_read(const struct heci_device *dev,
-	unsigned long offset)
-{
-	struct ish_hw *hw = to_ish_hw(dev);
-	return readl(hw->mem_addr + offset);
-}
-
-/**
- * ish_reg_write - Writes 32bit register
- *
- * @dev: the device structure
- * @offset: offset from which to write the data
- * @value: the byte to write
- */
-static inline void ish_reg_write(struct heci_device *dev, unsigned long offset,
-	u32 value)
-{
-	struct ish_hw *hw = to_ish_hw(dev);
-	writel(value, hw->mem_addr + offset);
-}
-
-static inline u32 ish_read_fw_sts_reg(struct heci_device *dev)
-{
-	return ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
-}
-
-bool check_generated_interrupt(struct heci_device *dev)
-{
-	bool interrupt_generated = true;
-	u32 pisr_val = 0;
-
-	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
-	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
-
-	return interrupt_generated;
-}
-
-
-u32 ipc_output_payload_read(struct heci_device *dev, unsigned long index)
-{
-	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG +	(index * sizeof(u32)));
-}
-
-/**
- * ish_read - reads a message from heci device.
- *
- * @dev: the device structure
- * @buffer: message buffer will be written
- * @buffer_length: message size will be read
- */
-static int ish_read(struct heci_device *dev, unsigned char *buffer,
-	unsigned long buffer_length)
-{
-	u32	i;
-	u32	*r_buf = (u32 *)buffer;
-	u32	msg_offs;
-
-	dev_dbg(&dev->pdev->dev, "buffer-length = %lu buf[0]0x%08X\n",
-		buffer_length, ipc_output_payload_read(dev, 0));
-
-	msg_offs = IPC_REG_ISH2HOST_MSG + sizeof(struct heci_msg_hdr);
-	for (i = 0; i < buffer_length; i += sizeof(u32))
-		*r_buf++ = ish_reg_read(dev, msg_offs + i);
-
-	return 0;
-}
-
-/**
- * ish_is_input_ready - check if ISS FW is ready for receiving data
- *
- * @dev: the device structure
- */
-static bool ish_is_input_ready(struct heci_device *dev)
-{
-	u32 doorbell_val;
-
-	doorbell_val = ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL);
-	return !IPC_IS_BUSY(doorbell_val);
-}
-
-/**
- * ish_intr_enable - enables heci device interrupts
- *
- * @dev: the device structure
- */
-void ish_intr_enable(struct heci_device *dev)
-{
-/*	u32 host_status = 0; */
-
-	dev_dbg(&dev->pdev->dev, "ish_intr_enable\n");
-	if (dev->pdev->revision == REVISION_ID_CHT_A0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_A0_SI)
-		ish_reg_write(dev, IPC_REG_HOST_COMM, 0x81);
-	else if (dev->pdev->revision == REVISION_ID_CHT_B0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Bx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Kx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Dx_SI) {
-		uint32_t	host_comm_val;
-
-		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
-		host_comm_val |= IPC_HOSTCOMM_INT_EN_BIT | 0x81;
-		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
-	}
-}
-
-/**
- * ish_intr_disable - disables heci device interrupts
- *
- * @dev: the device structure
- */
-void ish_intr_disable(struct heci_device *dev)
-{
-	dev_dbg(&dev->pdev->dev, "ish_intr_disable\n");
-	if (dev->pdev->revision == REVISION_ID_CHT_A0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_A0_SI)
-		/*ish_reg_write(dev, IPC_REG_HOST_COMM, 0xC1)*/;
-	else if (dev->pdev->revision == REVISION_ID_CHT_B0 ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Bx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Kx_SI ||
-			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Dx_SI) {
-		uint32_t	host_comm_val;
-
-		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
-		host_comm_val &= ~IPC_HOSTCOMM_INT_EN_BIT;
-		host_comm_val |= 0xC1;
-		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
-	}
-}
-
-/*
- * BH processing work function (instead of thread handler)
- */
-static void	bh_hbm_work_fn(struct work_struct *work)
-{
-	unsigned long	flags;
-	struct heci_device	*dev;
-	unsigned char	hbm[IPC_PAYLOAD_SIZE];
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): work=%p +++\n", __func__, work);
-	dev = container_of(work, struct heci_device, bh_hbm_work);
-	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
-	if (dev->rd_msg_fifo_head != dev->rd_msg_fifo_tail) {
-		memcpy(hbm, dev->rd_msg_fifo + dev->rd_msg_fifo_head,
-			IPC_PAYLOAD_SIZE);
-		dev->rd_msg_fifo_head =
-			(dev->rd_msg_fifo_head + IPC_PAYLOAD_SIZE) %
-			(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
-		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-		heci_hbm_dispatch(dev, (struct heci_bus_message *)hbm);
-	} else {
-		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-	}
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-}
-/*#####################################################*/
-
-/*
- * Got msg with IPC (and upper protocol) header
- * and add it to the device Tx-to-write list
- * then try to send the first IPC waiting msg (if DRBL is cleared)
- * RETURN VALUE:	negative -	fail (means free links list is empty,
- *					or msg too long)
- *			0 -	succeed
- */
-static int write_ipc_to_queue(struct heci_device *dev,
-	void (*ipc_send_compl)(void *), void *ipc_send_compl_prm,
-	unsigned char *msg, int length)
-{
-	struct wr_msg_ctl_info *ipc_link;
-	unsigned long   flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ length=%u\n", __func__, length);
-	if (length > IPC_FULL_MSG_SIZE)
-		return -EMSGSIZE;
-
-	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
-	if (list_empty(&dev->wr_free_list_head.link)) {
-		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-		return -ENOMEM;
-	}
-	ipc_link = list_entry(dev->wr_free_list_head.link.next,
-		struct wr_msg_ctl_info, link);
-	list_del_init(&ipc_link->link);
-
-	ipc_link->ipc_send_compl = ipc_send_compl;
-	ipc_link->ipc_send_compl_prm = ipc_send_compl_prm;
-	ipc_link->length = length;
-	memcpy(ipc_link->inline_data, msg, length);
-
-	list_add_tail(&ipc_link->link, &dev->wr_processing_list_head.link);
-	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-
-	write_ipc_from_queue(dev);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
-	return 0;
-}
-
-/* check if DRBL is cleared. if it is - write the first IPC msg,
- * then call the callback function (if it isn't NULL)
- */
-int write_ipc_from_queue(struct heci_device *dev)
-{
-	u32	doorbell_val;
-	unsigned long length;
-	unsigned long rem;
-	u32	*r_buf;
-	int i;
-	struct wr_msg_ctl_info	*ipc_link;
-	u32	reg_addr;
-	unsigned long	flags;
-	void	(*ipc_send_compl)(void *);
-	void	*ipc_send_compl_prm;
-	static int	out_ipc_locked;
-	unsigned long	out_ipc_flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-
-	if (dev->dev_state == HECI_DEV_DISABLED)
-		return	-EINVAL;
-
-	spin_lock_irqsave(&dev->out_ipc_spinlock, out_ipc_flags);
-	if (out_ipc_locked) {
-		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
-		return -EBUSY;
-	}
-	out_ipc_locked = 1;
-	if (!ish_is_input_ready(dev)) {
-		ISH_DBG_PRINT(KERN_ALERT "%s(): --- EBUSY\n", __func__);
-		out_ipc_locked = 0;
-		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
-		return -EBUSY;
-	}
-	spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
-
-	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
-	/*
-	 * if empty list - return 0; may happen, as RX_COMPLETE handler doesn't
-	 * check list emptiness
-	 */
-	if (list_empty(&dev->wr_processing_list_head.link)) {
-		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-		ISH_DBG_PRINT(KERN_ALERT "%s(): --- empty\n", __func__);
-		out_ipc_locked = 0;
-		return	0;
-	}
-
-	ipc_link = list_entry(dev->wr_processing_list_head.link.next,
-		struct wr_msg_ctl_info, link);
-	length = ipc_link->length - sizeof(u32);
-	/*first 4 bytes of the data is the doorbell value (IPC header)*/
-	doorbell_val = *(u32 *)ipc_link->inline_data;
-	r_buf = (u32 *)(ipc_link->inline_data + sizeof(u32));
-
-	/* If sending MNG_SYNC_FW_CLOCK, update clock again */
-	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG &&
-		IPC_HEADER_GET_MNG_CMD(doorbell_val) == MNG_SYNC_FW_CLOCK) {
-
-		struct timespec	ts;
-		uint64_t	usec;
-
-		get_monotonic_boottime(&ts);
-		usec = (uint64_t)ts.tv_sec * 1000000 +
-			(uint64_t)ts.tv_nsec / 1000;
-		r_buf[0] = (u32)(usec & 0xFFFFFFFF);
-		r_buf[1] = (u32)(usec >> 32);
-	}
-
-	for (i = 0, reg_addr = IPC_REG_HOST2ISH_MSG; i < length >> 2; i++,
-			reg_addr += 4)
-		ish_reg_write(dev, reg_addr, r_buf[i]);
-
-	rem = length & 0x3;
-	if (rem > 0) {
-		u32 reg = 0;
-		memcpy(&reg, &r_buf[length >> 2], rem);
-		ish_reg_write(dev, reg_addr, reg);
-	}
-
-	/* HID client debug */
-	if (doorbell_val == 0x8000040C &&
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG) == 0x80080000 &&
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+4) == 0x00030508) {
-			++dev->ipc_hid_out_fc;
-			++dev->ipc_hid_out_fc_cnt;
-		}
-	else if ((doorbell_val & 0xFFFFFC00) == 0x80000400 &&
-		(ish_reg_read(dev, IPC_REG_HOST2ISH_MSG) & 0x8000FFFF) ==
-				0x80000305)
-			--dev->ipc_hid_in_fc;
-
-	/* Update IPC counters */
-	++dev->ipc_tx_cnt;
-	dev->ipc_tx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
-
-	ish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, doorbell_val);
-	out_ipc_locked = 0;
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): in msg. registers: %08X ! %08X %08X %08X %08X... hostcomm reg: %08X\n",
-		__func__, ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 4),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 8),
-		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 0xC),
-		ish_reg_read(dev, IPC_REG_HOST_COMM));
-
-	ipc_send_compl = ipc_link->ipc_send_compl;
-	ipc_send_compl_prm = ipc_link->ipc_send_compl_prm;
-	list_del_init(&ipc_link->link);
-	list_add_tail(&ipc_link->link, &dev->wr_free_list_head.link);
-	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-
-	/*
-	 * callback will be called out of spinlock,
-	 * after ipc_link returned to free list
-	 */
-	if (ipc_send_compl)
-		ipc_send_compl(ipc_send_compl_prm);
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): --- written %lu bytes [%08X ! %08X %08X %08X %08X...]\n",
-		__func__, length, *(u32 *)ipc_link->inline_data, r_buf[0],
-		r_buf[1], r_buf[2], r_buf[3]);
-	return 0;
-}
-
-/*#####################################################*/
-
-static int	ish_fw_reset_handler(struct heci_device *dev)
-{
-	uint32_t	reset_id;
-	unsigned long	flags;
-	struct wr_msg_ctl_info *processing, *next;
-	/* Read reset ID */
-	reset_id = ish_reg_read(dev, IPC_REG_ISH2HOST_MSG) & 0xFFFF;
-
-	/* Handle FW-initiated reset */
-	dev->dev_state = HECI_DEV_RESETTING;
-
-	/* Clear HOST2ISH.ILUP (what's it?) */
-	/*ish_clr_host_rdy(dev);*/
-
-	/* Clear IPC output queue */
-	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
-	list_for_each_entry_safe(processing, next,
-			&dev->wr_processing_list_head.link, link) {
-		list_del(&processing->link);
-		list_add_tail(&processing->link, &dev->wr_free_list_head.link);
-	}
-	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
-
-	/* Clear BH processing queue - no further HBMs */
-	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
-	dev->rd_msg_fifo_head = dev->rd_msg_fifo_tail = 0;
-	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
-
-	/* Handle ISS FW reset against upper layers */
-	heci_bus_remove_all_clients(dev);	/* Remove all client devices */
-
-	/* Send RESET_NOTIFY_ACK (with reset_id) */
-/*#####################################*/
-	if (!ish_is_input_ready(dev))
-		timed_wait_for_timeout(WAIT_FOR_SEND_SLICE,
-			ish_is_input_ready(dev), (2 * HZ));
-
-	/* ISS FW is dead (?) */
-	if (!ish_is_input_ready(dev)) {
-		return	-EPIPE;
-	} else {
-		/*
-		 * Set HOST2ISH.ILUP. Apparently we need this BEFORE sending
-		 * RESET_NOTIFY_ACK - FW will be checking for it
-		 */
-		ish_set_host_rdy(dev);
-		ipc_send_mng_msg(dev, MNG_RESET_NOTIFY_ACK, &reset_id,
-			sizeof(uint32_t));
-	}
-/*####################################*/
-
-	/* Wait for ISS FW'es ILUP and HECI_READY */
-	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, ish_hw_is_ready(dev),
-		(2 * HZ));
-	if (!ish_hw_is_ready(dev)) {
-		/* ISS FW is dead */
-		uint32_t	ish_status;
-		ish_status = ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
-		dev_err(&dev->pdev->dev,
-		"[heci-ish]: completed reset, ISS is dead (FWSTS = %08X)\n",
-		ish_status);
-		return -ENODEV;
-	}
-
-	return	0;
-}
-
-struct work_struct	fw_reset_work;
-struct heci_device	*heci_dev;
-
-static void	fw_reset_work_fn(struct work_struct *unused)
-{
-	int	rv;
-	static int reset_cnt;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
-	reset_cnt++;
-
-	rv = ish_fw_reset_handler(heci_dev);
-	if (!rv) {
-		/* ISS is ILUP & HECI-ready. Restart HECI */
-	/* bug fix here: when reset flow occurs, sometimes, the sysfs entries
-		which were removed in ish_fw_reset_handler were still up,
-		but the driver tried to create the same entries and failed.
-		so wait some time here and then the sysfs entries removal will
-		be done */
-		if (reset_cnt != 0) /* not the boot flow */
-			schedule_timeout(HZ / 3);
-		heci_dev->recvd_hw_ready = 1;
-		if (waitqueue_active(&heci_dev->wait_hw_ready))
-			wake_up(&heci_dev->wait_hw_ready);
-
-		heci_dev->dev_state = HECI_DEV_INIT_CLIENTS;
-		heci_dev->hbm_state = HECI_HBM_START;
-		heci_hbm_start_req(heci_dev);
-		ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n",
-			__func__);
-
-	} else
-		printk(KERN_ERR "[heci-ish]: FW reset failed (%d)\n", rv);
-}
-
-
-static void	sync_fw_clock(struct heci_device *dev)
-{
-	static unsigned long	prev_sync;
-	struct timespec	ts;
-	uint64_t	usec;
-
-	if (prev_sync && jiffies - prev_sync < 20 * HZ)
-		return;
-
-	prev_sync = jiffies;
-	get_monotonic_boottime(&ts);
-	usec = (uint64_t)ts.tv_sec * 1000000 + (uint64_t)ts.tv_nsec / 1000;
-	ipc_send_mng_msg(dev, MNG_SYNC_FW_CLOCK, &usec, sizeof(uint64_t));
-}
-
-
-/*
- *	Receive and process IPC management messages
- *
- *	NOTE: Any other mng command than reset_notify and reset_notify_ack
- *	won't wake BH handler
- */
-static void	recv_ipc(struct heci_device *dev, uint32_t doorbell_val)
-{
-	uint32_t	mng_cmd;
-
-	mng_cmd = IPC_HEADER_GET_MNG_CMD(doorbell_val);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): handled IPC mng_cmd=%08X\n", __func__,
-		mng_cmd);
-
-	switch (mng_cmd) {
-	default:
-		break;
-
-	case MNG_RX_CMPL_INDICATION:
-		ISH_DBG_PRINT(KERN_ALERT
-			"%s(): RX_COMPLETE -- IPC_REG_ISH2HOST_MSG[0] = %08X\n",
-			__func__, ish_reg_read(dev, IPC_REG_ISH2HOST_MSG));
-		if (suspend_flag) {
-			suspend_flag = 0;
-			if (waitqueue_active(&suspend_wait))
-				wake_up(&suspend_wait);
-		}
-		write_ipc_from_queue(dev);
-		break;
-
-	case MNG_RESET_NOTIFY:
-		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY\n", __func__);
-		if (!heci_dev) {
-			heci_dev = dev;
-			INIT_WORK(&fw_reset_work, fw_reset_work_fn);
-		}
-		schedule_work(&fw_reset_work);
-		break;
-
-	case MNG_RESET_NOTIFY_ACK:
-		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY_ACK\n",
-			__func__);
-		dev->recvd_hw_ready = 1;
-		if (waitqueue_active(&dev->wait_hw_ready))
-			wake_up(&dev->wait_hw_ready);
-		break;
-	}
-}
-
-
-/**
- * ish_irq_handler - ISR of the HECI device
- *
- * @irq: irq number
- * @dev_id: pointer to the device structure
- *
- * returns irqreturn_t
- */
-irqreturn_t ish_irq_handler(int irq, void *dev_id)
-{
-	struct heci_device *dev = dev_id;
-	uint32_t	doorbell_val;
-	struct heci_msg_hdr	*heci_hdr;
-	bool interrupt_generated;
-	u32 pisr_val;
-	u32	msg_hdr;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): irq=%d +++\n", __func__, irq);
-
-	/* Check that it's interrupt from ISH (may be shared) */
-	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
-	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): interrupt_generated=%d [PIMR=%08X]\n",
-		__func__, (int)interrupt_generated,
-		ish_reg_read(dev, IPC_REG_PIMR));
-	if (!interrupt_generated)
-		return IRQ_NONE;
-
-	doorbell_val = ish_reg_read(dev, IPC_REG_ISH2HOST_DRBL);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): IPC_IS_BUSY=%d\n", __func__,
-		(int)IPC_IS_BUSY(doorbell_val));
-	if (!IPC_IS_BUSY(doorbell_val))
-		return IRQ_HANDLED;
-
-	ISH_DBG_PRINT("%s(): doorbell is busy - YES\n", __func__);
-
-	/* CHECKME: double check this */
-	if (dev->dev_state == HECI_DEV_DISABLED)
-		return	IRQ_HANDLED;
-
-	ish_intr_disable(dev);
-
-	/* Sanity check: IPC dgram length in header */
-	if (IPC_HEADER_GET_LENGTH(doorbell_val) > IPC_PAYLOAD_SIZE) {
-		dev_err(&dev->pdev->dev,
-			"%s(): IPC hdr - bad length: %u; dropped\n",
-			__func__,
-			(unsigned)IPC_HEADER_GET_LENGTH(doorbell_val));
-		goto	eoi;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): protocol=%u\n", __func__,
-		IPC_HEADER_GET_PROTOCOL(doorbell_val));
-
-	/* IPC message */
-	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG) {
-		recv_ipc(dev, doorbell_val);
-		goto	eoi;
-	}
-
-	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) != IPC_PROTOCOL_HECI)
-		goto	eoi;
-
-	/* Read HECI header dword */
-	msg_hdr = ish_read_hdr(dev);
-	if (!msg_hdr)
-		goto	eoi;
-
-	sync_fw_clock(dev);
-
-	heci_hdr = (struct heci_msg_hdr *)&msg_hdr;
-
-	/* Sanity check: HECI frag. length in header */
-	if (heci_hdr->length > dev->mtu) {
-		dev_err(&dev->pdev->dev,
-			"%s(): HECI hdr - bad length: %u; dropped [%08X]\n",
-			__func__,
-			(unsigned)heci_hdr->length, msg_hdr);
-		goto	eoi;
-	}
-
-	/* HECI bus message */
-	if (!heci_hdr->host_addr && !heci_hdr->me_addr) {
-		recv_hbm(dev, heci_hdr);
-		goto	eoi;
-
-	/* HECI fixed-client message */
-	} else if (!heci_hdr->host_addr) {
-		recv_fixed_cl_msg(dev, heci_hdr);
-		goto	eoi;
-	} else {
-		/* HECI client message */
-		recv_heci_cl_msg(dev, heci_hdr);
-		goto	eoi;
-	}
-
-eoi:
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): Doorbell cleared, busy reading cleared\n", __func__);
-	/* Update IPC counters */
-	++dev->ipc_rx_cnt;
-	dev->ipc_rx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
-
-	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
-	/*
-	 * Here and above: we need to actually read this register
-	 * in order to unblock further interrupts on CHT A0
-	 */
-	ish_intr_enable(dev);
-	return	IRQ_HANDLED;
-}
-
-
-static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code,
-	void *msg, size_t size)
-{
-	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
-	uint32_t	drbl_val = IPC_BUILD_MNG_MSG(msg_code, size);
-
-	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
-	memcpy(ipc_msg + sizeof(uint32_t), msg, size);
-	return	write_ipc_to_queue(dev, NULL, NULL, ipc_msg,
-		sizeof(uint32_t) + size);
-}
-
-
-static int	ipc_send_heci_msg(struct heci_device *dev,
-	struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
-	void *ipc_send_compl_prm)
-{
-	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
-	uint32_t	drbl_val;
-
-	drbl_val = IPC_BUILD_HEADER(hdr->length + sizeof(struct heci_msg_hdr),
-		IPC_PROTOCOL_HECI, 1);
-
-	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
-	memcpy(ipc_msg + sizeof(uint32_t), hdr, sizeof(uint32_t));
-	memcpy(ipc_msg + 2 * sizeof(uint32_t), msg, hdr->length);
-	return	write_ipc_to_queue(dev, ipc_send_compl, ipc_send_compl_prm,
-		ipc_msg, 2 * sizeof(uint32_t) + hdr->length);
-}
-
-
-/**
- * ish_hw_is_ready - check if the hw is ready
- *
- * @dev: the device structure
- */
-bool ish_hw_is_ready(struct heci_device *dev)
-{
-	u32 ish_status =  ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
-	return IPC_IS_ISH_ILUP(ish_status) && IPC_IS_ISH_HECI_READY(ish_status);
-}
-
-/**
- * ish_host_is_ready - check if the host is ready
- *
- * @dev: the device structure
- */
-bool ish_host_is_ready(struct heci_device *dev)
-{
-	return true;
-}
-
-void ish_set_host_rdy(struct heci_device *dev)
-{
-	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n",
-		host_status);
-	IPC_SET_HOST_READY(host_status);
-	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
-	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n",
-		host_status);
-}
-
-void ish_clr_host_rdy(struct heci_device *dev)
-{
-	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n",
-		host_status);
-	IPC_CLEAR_HOST_READY(host_status);
-	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
-	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
-	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n",
-		host_status);
-}
-
-
-static int ish_hw_reset(struct heci_device *dev)
-{
-	struct pci_dev *pdev = dev->pdev;
-	struct ish_hw *hw = to_ish_hw(dev);
-	int	rv;
-	u16 csr;
-
-#define	MAX_DMA_DELAY	20
-	unsigned	dma_delay;
-
-	if (!pdev)
-		return	-ENODEV;
-
-	rv = pci_reset_function(pdev);
-	if (!rv)
-		dev->dev_state = HECI_DEV_RESETTING;
-
-	if (!pdev->pm_cap) {
-		dev_err(&pdev->dev, "Can't reset - no PM caps\n");
-		return	-EINVAL;
-	}
-
-	/* Now trigger reset to FW */
-	writel(0, hw->mem_addr + IPC_REG_ISH_RMP2);
-
-	for (dma_delay = 0; dma_delay < MAX_DMA_DELAY &&
-		ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS) & (IPC_ISH_IN_DMA);
-		dma_delay += 5);
-			mdelay(5);
-
-	if (dma_delay >= MAX_DMA_DELAY) {
-		dev_err(&pdev->dev,
-			"Can't reset - stuck with DMA in-progress\n");
-		return	-EBUSY;
-	}
-
-	pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &csr);
-
-	csr &= ~PCI_PM_CTRL_STATE_MASK;
-	csr |= PCI_D3hot;
-	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
-
-	mdelay(pdev->d3_delay);
-
-	csr &= ~PCI_PM_CTRL_STATE_MASK;
-	csr |= PCI_D0;
-	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
-
-	writel(IPC_RMP2_DMA_ENABLED, hw->mem_addr + IPC_REG_ISH_RMP2);
-
-	/* Send 0 IPC message so that ISS FW wakes up if it was already
-	 asleep */
-	writel(IPC_DRBL_BUSY_BIT, hw->mem_addr + IPC_REG_HOST2ISH_DRBL);
-
-	return	0;
-}
-
-
-/**
- * ish_ipc_reset - resets host and fw IPC and upper layers.
- *
- * @dev: the device structure
- */
-static int ish_ipc_reset(struct heci_device *dev)
-{
-	struct ipc_rst_payload_type ipc_mng_msg;
-	int	rv = 0;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
-	dev_dbg(&dev->pdev->dev, "ish_hw_reset\n");
-	/*temporary we'll send reset*/
-
-	ipc_mng_msg.reset_id = 1;
-	ipc_mng_msg.reserved = 0;
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): before ish_intr_enable()\n", __func__);
-	ish_intr_enable(dev);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): after ish_intr_enable()\n", __func__);
-
-/* DEBUG: send self-interrupt and wait 100 (ms) for it to appear in klog */
-/*	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0x80000000);
-	mdelay(100);
-************************/
-
-	/* Clear the incoming doorbell */
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): Doorbell cleared, busy reading cleared\n", __func__);
-	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): cleared doorbell reg.\n", __func__);
-
-	/*
-	 * Fixed: this should be set BEFORE writing RESET_NOTIFY,
-	 * lest response will be received BEFORE this clearing...
-	 */
-	dev->recvd_hw_ready = 0;
-
-	/*send message */
-	rv = ipc_send_mng_msg(dev, MNG_RESET_NOTIFY, &ipc_mng_msg,
-		sizeof(struct ipc_rst_payload_type));
-	if (rv) {
-		dev_err(&dev->pdev->dev, "Failed to send IPC MNG_RESET_NOTIFY\n");
-		return	rv;
-	}
-
-	ISH_DBG_PRINT(KERN_ALERT "%s(): going to wait for hw_ready.\n",
-		__func__);
-	/*wait_event_interruptible(dev->wait_hw_ready, dev->recvd_hw_ready);*/
-	wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready, 2*HZ);
-	if (!dev->recvd_hw_ready) {
-		dev_err(&dev->pdev->dev, "Timed out waiting for HW ready\n");
-		rv = -ENODEV;
-	}
-	ISH_DBG_PRINT(KERN_ALERT "%s(): woke up from hw_ready.\n", __func__);
-
-	dev_dbg(&dev->pdev->dev, "exit initial link wait\n");
-
-	return rv;
-}
-
-/* Dummy. Do we need it? */
-static void ish_hw_config(struct heci_device *dev)
-{
-	ISH_DBG_PRINT(KERN_ALERT "%s()+++ [ish_hw_reset=%p]\n",
-		__func__, ish_hw_reset);
-	dev_dbg(&dev->pdev->dev, "ish_hw_config\n");
-}
-
-static int ish_hw_start(struct heci_device *dev)
-{
-	struct ish_hw *hw = to_ish_hw(dev);
-
-	dev_dbg(&dev->pdev->dev, "ish_hw_start\n");
-	ish_set_host_rdy(dev);
-#ifdef	D3_RCR
-	/* After that we can enable ISH DMA operation */
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): writing DMA_ENABLED\n",
-		__func__);
-	writel(IPC_RMP2_DMA_ENABLED, hw->mem_addr + IPC_REG_ISH_RMP2);
-
-	/* Send 0 IPC message so that ISS FW wakes up if it was already
-	 asleep */
-	writel(IPC_DRBL_BUSY_BIT, hw->mem_addr + IPC_REG_HOST2ISH_DRBL);
-#endif /*D3_RCR*/
-	ish_intr_enable(dev);
-	return 0;
-}
-
-
-static u32 ish_read_hdr(const struct heci_device *dev)
-{
-	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG);
-}
-
-
-/**
- * ish_write - writes a message to heci device.
- *
- * @dev: the device structure
- * @header: header of message
- * @buf: message buffer will be written
- * returns 1 if success, 0 - otherwise.
- */
-
-static int ish_write(struct heci_device *dev, struct heci_msg_hdr *header,
-	unsigned char *buf)
-{
-/*#####################################################################*/
-	unsigned char ipc_msg[IPC_FULL_MSG_SIZE];
-	u32 doorbell_val;
-
-	doorbell_val = IPC_BUILD_HEADER(header->length +
-		sizeof(struct heci_msg_hdr), IPC_PROTOCOL_HECI, 1);
-	memcpy(ipc_msg, (char *)&doorbell_val, sizeof(u32));
-	memcpy(ipc_msg + sizeof(u32), (char *)header,
-		sizeof(struct heci_msg_hdr));
-	memcpy(ipc_msg + sizeof(u32) + sizeof(struct heci_msg_hdr), buf,
-		header->length);
-
-	return write_ipc_to_queue(dev, NULL, NULL, ipc_msg,
-		sizeof(u32) + sizeof(struct heci_msg_hdr) + header->length);
-/*#####################################################################*/
-}
-
-
-static const struct heci_hw_ops ish_hw_ops = {
-	.host_is_ready = ish_host_is_ready,
-	.hw_is_ready = ish_hw_is_ready,
-	.hw_reset = ish_hw_reset,
-	.ipc_reset = ish_ipc_reset,
-	.hw_config = ish_hw_config,
-	.hw_start = ish_hw_start,
-	.read = ish_read,
-	.write = ish_write,
-	.write_ex = ipc_send_heci_msg,
-	.get_fw_status = ish_read_fw_sts_reg
-};
-
-
-struct heci_device *ish_dev_init(struct pci_dev *pdev)
-{
-
-	struct heci_device *dev;
-
-	dev = kzalloc(sizeof(struct heci_device) +  sizeof(struct ish_hw),
-		GFP_KERNEL);
-	if (!dev)
-		return NULL;
-
-	heci_device_init(dev);
-
-	/* Rx INT->BH FIFO pointers */
-	dev->rd_msg_fifo_head = 0;
-	dev->rd_msg_fifo_tail = 0;
-	spin_lock_init(&dev->rd_msg_spinlock);
-	spin_lock_init(&dev->wr_processing_spinlock);
-	spin_lock_init(&dev->out_ipc_spinlock);
-	spin_lock_init(&dev->read_list_spinlock);
-	spin_lock_init(&dev->device_lock);
-	spin_lock_init(&dev->device_list_lock);
-	spin_lock_init(&dev->cl_list_lock);
-	spin_lock_init(&dev->me_clients_lock);
-	INIT_WORK(&dev->bh_hbm_work, bh_hbm_work_fn);
-
-	dev->ops = &ish_hw_ops;
-	dev->pdev = pdev;
-	dev->mtu = IPC_PAYLOAD_SIZE - sizeof(struct heci_msg_hdr);
-	return dev;
-}
-
-
-void	heci_device_disable(struct heci_device *dev)
-{
-	unsigned long	flags;
-	struct wr_msg_ctl_info	*ipc_link;
-	struct heci_cl	*cl;
-
-	dev->dev_state = HECI_DEV_DISABLED;
-	ish_clr_host_rdy(dev);
-	ish_intr_disable(dev);
-
-	/* Free all other allocations */
-	kfree(dev->me_clients);
-}
-
diff --git a/drivers/misc/heci/hw-ish.h b/drivers/misc/heci/hw-ish.h
deleted file mode 100644
index cc56113..0000000
--- a/drivers/misc/heci/hw-ish.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * H/W layer of HECI provider device (ISS)
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef _HECI_HW_ISH_H_
-#define _HECI_HW_ISH_H_
-
-#include <linux/pci.h>
-#include "hw-ish-regs.h"
-#include "heci_dev.h"
-
-extern int	suspend_flag;
-extern wait_queue_head_t	suspend_wait;
-
-struct ipc_rst_payload_type {
-	u16            reset_id;
-	u16            reserved;
-};
-
-struct ish_hw {
-	void __iomem *mem_addr;
-};
-
-#define to_ish_hw(dev) (struct ish_hw *)((dev)->hw)
-
-
-struct heci_device *ish_dev_init(struct pci_dev *pdev);
-
-irqreturn_t ish_irq_handler(int irq, void *dev_id);
-
-void ish_clr_host_rdy(struct heci_device *dev);
-void ish_set_host_rdy(struct heci_device *dev);
-bool ish_hw_is_ready(struct heci_device *dev);
-void ish_intr_enable(struct heci_device *dev);
-void ish_intr_disable(struct heci_device *dev);
-
-int	write_ipc_from_queue(struct heci_device *dev);
-
-static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code,
-	void *msg, size_t size);
-
-static int	ipc_send_heci_msg(struct heci_device *dev,
-	struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
-	void *ipc_send_compl_prm);
-
-static u32	ish_read_hdr(const struct heci_device *dev);
-
-void g_ish_print_log(char *format, ...);
-
-#endif /* _HECI_HW_ISH_H_ */
-
diff --git a/drivers/misc/heci/init.c b/drivers/misc/heci/init.c
deleted file mode 100644
index 39336b9..0000000
--- a/drivers/misc/heci/init.c
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Initialization protocol for HECI driver
- *
- * Copyright (c) 2003-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/export.h>
-#include <linux/pci.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include <linux/delay.h>
-#include "heci_dev.h"
-#include "hbm.h"
-#include "client.h"
-#include "utils.h"
-#include "platform-config.h"
-
-const char *heci_dev_state_str(int state)
-{
-	switch (state) {
-	case HECI_DEV_INITIALIZING:
-		return	"INITIALIZING";
-	case HECI_DEV_INIT_CLIENTS:
-		return	"INIT_CLIENTS";
-	case HECI_DEV_ENABLED:
-		return	"ENABLED";
-	case HECI_DEV_RESETTING:
-		return	"RESETTING";
-	case HECI_DEV_DISABLED:
-		return	"DISABLED";
-	case HECI_DEV_POWER_DOWN:
-		return	"POWER_DOWN";
-	case HECI_DEV_POWER_UP:
-		return	"POWER_UP";
-	default:
-		return "unkown";
-	}
-}
-EXPORT_SYMBOL(heci_dev_state_str);
-
-void heci_device_init(struct heci_device *dev)
-{
-	/* setup our list array */
-	INIT_LIST_HEAD(&dev->cl_list);
-	INIT_LIST_HEAD(&dev->device_list);
-	init_waitqueue_head(&dev->wait_hw_ready);
-	init_waitqueue_head(&dev->wait_hbm_recvd_msg);
-	init_waitqueue_head(&dev->wait_dma_ready);
-	dev->dev_state = HECI_DEV_INITIALIZING;
-
-	/*
-	 * We need to reserve something, because client #0
-	 * is reserved for HECI bus messages
-	 */
-	bitmap_zero(dev->host_clients_map, HECI_CLIENTS_MAX);
-	dev->open_handle_count = 0;
-
-	/*
-	 * Reserving the first three client IDs
-	 * 0: Reserved for HECI Bus Message communications
-	 * 1: Reserved for Watchdog
-	 * 2: Reserved for AMTHI
-	 */
-	bitmap_set(dev->host_clients_map, 0, 3);
-	/*****************************/
-
-	heci_io_list_init(&dev->read_list);
-
-	/* Init IPC processing and free lists */
-	INIT_LIST_HEAD(&dev->wr_processing_list_head.link);
-	INIT_LIST_HEAD(&dev->wr_free_list_head.link);
-	do {
-		int	i;
-
-		for (i = 0; i < IPC_TX_FIFO_SIZE; ++i) {
-			struct wr_msg_ctl_info	*tx_buf;
-
-			tx_buf = kmalloc(sizeof(struct wr_msg_ctl_info),
-				GFP_KERNEL);
-			if (!tx_buf) {
-				/*
-				 * ERROR: decide what to do with it.
-				 * IPC buffers may be limited or not available
-				 * at all - although this shouldn't happen
-				 */
-				dev_err(&dev->pdev->dev, "[heci-ish]: failure in Tx FIFO allocations (%d)\n",
-					i);
-				break;
-			}
-			memset(tx_buf, 0, sizeof(struct wr_msg_ctl_info));
-			list_add_tail(&tx_buf->link,
-				&dev->wr_free_list_head.link);
-		}
-		printk(KERN_ALERT "[heci-ish]: success Tx FIFO allocations\n");
-	} while (0);
-}
-EXPORT_SYMBOL_GPL(heci_device_init);
-
-/**
- * heci_start - initializes host and fw to start work.
- *
- * @dev: the device structure
- *
- * returns 0 on success, <0 on failure.
- */
-int heci_start(struct heci_device *dev)
-{
-	heci_hw_config(dev);
-#ifdef FORCE_FW_INIT_RESET
-	/* wait for FW-initiated reset flow, indefinitely */
-	heci_hw_start(dev);
-	/* 16/6/2014: changed this 2->5 seconds following MCG assertion.
-	 * Once this was 10 seconds, lowered to 2.
-	 * TODO: check out all FW ISS/SEC path how much it should be */
-
-	/*timed_wait_for_timeout(WAIT_FOR_CONNECT_SLICE, dev->recvd_hw_ready,
-		(10*HZ));*/
-	if (!dev->recvd_hw_ready)
-		wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready,
-			10*HZ);
-	/*
-	 * Lock only after FW-reset flow worked or failed.
-	 * otherwise interrupts BH will be locked
-	 */
-	if (dev->recvd_hw_ready)
-		goto	reset_done;
-	dev_err(&dev->pdev->dev, "[heci-ish] %s(): Timed out waiting for FW-initiated reset\n",
-		__func__);
-#if 1
-	goto	err;	/* DEBUGDEBUGDEBUG: raise timeout for FW-initiated reset
-			 * to 10 s and don't sent host-initiated reset flow */
-#endif
-	/* DEBUGDEBUGDEBUG: Below code until 'reset_done:' is defunct */
-#else
-#endif
-	/* acknowledge interrupt and stop interupts */
-	dev_dbg(&dev->pdev->dev, "reset in start the heci device.\n");
-	heci_reset(dev, 1);
-
-reset_done:
-	if (heci_hbm_start_wait(dev)) {
-		dev_err(&dev->pdev->dev, "HBM haven't started");
-		goto err;
-	}
-
-	if (!heci_host_is_ready(dev)) {
-		dev_err(&dev->pdev->dev, "host is not ready.\n");
-		goto err;
-	}
-
-	if (!heci_hw_is_ready(dev)) {
-		dev_err(&dev->pdev->dev, "ME is not ready.\n");
-		goto err;
-	}
-
-	/*if (dev->version.major_version != HBM_MAJOR_VERSION ||
-	    dev->version.minor_version != HBM_MINOR_VERSION) {
-		dev_dbg(&dev->pdev->dev, "HECI start failed.\n");
-		goto err;
-	}*/
-
-	dev_dbg(&dev->pdev->dev, "link layer has been established.\n");
-
-	/*suspend & resume notification - send QUERY_SUBSCRIBERS msg*/
-	query_subscribers(dev);
-
-	return 0;
-err:
-	dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
-	dev->dev_state = HECI_DEV_DISABLED;
-	return -ENODEV;
-}
-EXPORT_SYMBOL_GPL(heci_start);
-
-/**
- * heci_reset - resets host and fw.
- *
- * @dev: the device structure
- * @interrupts_enabled: if interrupt should be enabled after reset.
- */
-void heci_reset(struct heci_device *dev, int interrupts_enabled)
-{
-	bool unexpected;
-	int ret;
-
-	unexpected = (dev->dev_state != HECI_DEV_INITIALIZING &&
-			dev->dev_state != HECI_DEV_DISABLED &&
-			dev->dev_state != HECI_DEV_POWER_DOWN &&
-			dev->dev_state != HECI_DEV_POWER_UP);
-
-	ret = heci_hw_reset(dev);
-	if (ret) {
-		dev_err(&dev->pdev->dev, "hw reset failed disabling the device\n");
-		interrupts_enabled = false;
-		dev->dev_state = HECI_DEV_DISABLED;
-	}
-
-	dev->hbm_state = HECI_HBM_IDLE;
-
-	if (dev->dev_state != HECI_DEV_INITIALIZING) {
-		if (dev->dev_state != HECI_DEV_DISABLED &&
-		    dev->dev_state != HECI_DEV_POWER_DOWN)
-			dev->dev_state = HECI_DEV_RESETTING;
-
-		heci_cl_all_disconnect(dev);
-	}
-
-	if (unexpected)
-		dev_warn(&dev->pdev->dev, "unexpected reset: dev_state = %s\n",
-			 heci_dev_state_str(dev->dev_state));
-
-	if (!interrupts_enabled) {
-		dev_dbg(&dev->pdev->dev, "intr not enabled end of reset\n");
-		return;
-	}
-	dev_dbg(&dev->pdev->dev, "before sending HOST start\n");
-	ret = heci_hw_start(dev);
-	if (ret) {
-		dev_err(&dev->pdev->dev, "hw_start failed disabling the device\n");
-		dev->dev_state = HECI_DEV_DISABLED;
-		return;
-	}
-
-	dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
-	/* link is established * start sending messages.  */
-
-	dev->dev_state = HECI_DEV_INIT_CLIENTS;
-	dev->hbm_state = HECI_HBM_START;
-	heci_hbm_start_req(dev);
-	ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n",
-		__func__);
-	/* wake up all readings so they can be interrupted */
-	heci_cl_all_read_wakeup(dev);
-}
-EXPORT_SYMBOL_GPL(heci_reset);
-
-void heci_stop(struct heci_device *dev)
-{
-	dev_dbg(&dev->pdev->dev, "stopping the device.\n");
-	dev->dev_state = HECI_DEV_POWER_DOWN;
-	heci_reset(dev, 0);
-	flush_scheduled_work();
-}
-EXPORT_SYMBOL_GPL(heci_stop);
-
diff --git a/drivers/misc/heci/pci-ish.c b/drivers/misc/heci/pci-ish.c
deleted file mode 100644
index 4e1bf46..0000000
--- a/drivers/misc/heci/pci-ish.c
+++ /dev/null
@@ -1,1154 +0,0 @@
-/*
- * PCI glue for HECI provider device (ISS) driver
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/aio.h>
-#include <linux/pci.h>
-#include <linux/poll.h>
-#include <linux/init.h>
-#include <linux/ioctl.h>
-#include <linux/cdev.h>
-#include <linux/version.h>
-#include <linux/sched.h>
-#include <linux/uuid.h>
-#include <linux/compat.h>
-#include <linux/jiffies.h>
-#include <linux/interrupt.h>
-#include <linux/workqueue.h>
-#include "client.h"
-#include "heci_dev.h"
-#include "hw-ish.h"
-#include "hbm.h"
-#include "utils.h"
-#include <linux/miscdevice.h>
-
-#ifdef dev_dbg
-#undef dev_dbg
-#endif
-static void no_dev_dbg(void *v, char *s, ...)
-{
-}
-#define dev_dbg no_dev_dbg
-
-/*#define dev_dbg dev_err*/
-
-/*
- *  heci driver strings
- */
-static bool nomsi;
-module_param_named(nomsi, nomsi, bool, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(nomsi, "don't use msi (default = false)");
-
-/* Currently this driver works as long as there is only a single HECI device. */
-static struct pci_dev *heci_pci_device;
-
-static const struct pci_device_id ish_pci_tbl[] = {
-	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x22D8)},
-	{0, }
-};
-
-MODULE_DEVICE_TABLE(pci, ish_pci_tbl);
-
-static DEFINE_MUTEX(heci_mutex);
-struct workqueue_struct *workqueue_for_init;
-
-/*global variables for suspend*/
-int	suspend_flag = 0;
-wait_queue_head_t	suspend_wait;
-
-#ifdef TIMER_POLLING
-/*
- * DD -- ISS timer-polling workaround for H-FPGA
- * (and other platforms that fail to deliver interrupts)
- * NOTE: currently this will break (crash) if driver is unloaded
- */
-
-#include <linux/timer.h>
-
-struct timer_list	ish_poll_timer;
-void	*timer_data;
-struct work_struct	ish_poll_work;
-
-void	ish_poll_work_fn(void *prm)
-{
-}
-
-void	ish_poll_timer_fn(unsigned long unused)
-{
-	irqreturn_t	rv;
-
-	rv = ish_irq_handler(0, timer_data);
-	/*ISH_DBG_PRINT(KERN_ALERT "%s(): ish_irq_handler() returned %08X\n",
-		__func__, rv);*/
-
-	/* Reschedule timer */
-	ish_poll_timer.expires += 2;
-	add_timer(&ish_poll_timer);
-}
-
-#endif	/* TIMER_POLLING */
-
-
-#if ISH_DEBUGGER
-
-struct ish_hw *hw_dbg;
-
-static int ishdbg_open(struct inode *inode, struct file *file)
-{
-	return	0;
-}
-
-static int ishdbg_release(struct inode *inode, struct file *file)
-{
-	return	0;
-}
-
-static char	dbg_resp_buf[2048];
-static int	resp_buf_read;
-
-static ssize_t ishdbg_read(struct file *file, char __user *ubuf, size_t length,
-	loff_t *offset)
-{
-	int rv;
-	int copy_len;
-
-	if (resp_buf_read)
-		return	0;	/* EOF */
-	copy_len = (length > strlen(dbg_resp_buf)) ?
-		strlen(dbg_resp_buf) : length;
-	rv = copy_to_user(ubuf, dbg_resp_buf, copy_len);
-	if (rv)
-		return  -EINVAL;
-	resp_buf_read = 1;
-	return  copy_len;
-}
-
-static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
-	size_t length, loff_t *offset)
-{
-	char    dbg_req_buf[768];
-	char    cmd[768];
-	int     rv;
-	unsigned     addr, count;
-	int	sscanf_match, i, cur_index;
-	uint32_t __iomem *reg_data;
-
-	if (length > sizeof(dbg_req_buf))
-		length = sizeof(dbg_req_buf);
-	rv = copy_from_user(dbg_req_buf, ubuf, length);
-	if (rv)
-		return  -EINVAL;
-	if (sscanf(dbg_req_buf, "%s ", cmd) != 1) {
-		dev_err(&heci_pci_device->dev, "[ish-dbg]) sscanf failed\n");
-		return  -EINVAL;
-	}
-	sscanf_match = sscanf(dbg_req_buf + 2, "%x %u", &addr, &count);
-	if (!strcmp(cmd, "d")) {
-		/* Dump values: d <addr> [count] */
-		if (sscanf_match == 1)
-			count = 1;
-		else if (sscanf_match != 2) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanf_match = %d\n",
-				sscanf_match);
-			return  -EINVAL;
-		}
-		if (addr % 4) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
-			return -EINVAL;
-		}
-		cur_index = 0;
-		for (i = 0; i < count; i++) {
-			reg_data = (uint32_t __iomem *)
-				((char *)hw_dbg->mem_addr + addr + i*4);
-			cur_index += scnprintf(dbg_resp_buf + cur_index,
-				sizeof(dbg_resp_buf) - cur_index, "%08X ",
-				readl(reg_data));
-		}
-		cur_index += scnprintf(dbg_resp_buf + cur_index,
-			sizeof(dbg_resp_buf) - cur_index, "\n");
-		resp_buf_read = 0;
-	} else if (!strcmp(cmd, "e")) {
-		/* Enter values e <addr> <value> */
-		if (sscanf_match != 2) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanfMatch = %d\n",
-				sscanf_match);
-			return  -EINVAL;
-		}
-		if (addr % 4) {
-			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
-			return -EINVAL;
-		}
-		reg_data = (uint32_t __iomem *)((char *)hw_dbg->mem_addr
-			+ addr);
-		writel(count, reg_data);
-		scnprintf(dbg_resp_buf, sizeof(dbg_resp_buf), "OK\n");
-		resp_buf_read = 0;
-	}
-
-	return  length;
-}
-
-static long ishdbg_ioctl(struct file *file, unsigned int cmd,
-	unsigned long data)
-{
-	return	0;
-}
-
-/*
- * file operations structure will be used for heci char device.
- */
-static const struct file_operations ishdbg_fops = {
-	.owner = THIS_MODULE,
-	.read = ishdbg_read,
-	.unlocked_ioctl = ishdbg_ioctl,
-	.open = ishdbg_open,
-	.release = ishdbg_release,
-	.write = ishdbg_write,
-	.llseek = no_llseek
-};
-
-/*
- * Misc Device Struct
- */
-static struct miscdevice  ishdbg_misc_device = {
-		.name = "ishdbg",
-		.fops = &ishdbg_fops,
-		.minor = MISC_DYNAMIC_MINOR,
-};
-
-#endif /* ISH_DEBUGGER */
-
-#if ISH_LOG
-
-void delete_from_log(struct heci_device *dev, size_t min_chars)
-{
-	int i;
-	/* set log_tail to point at the last char to be deleted */
-	dev->log_tail = (dev->log_tail + min_chars - 1) % PRINT_BUFFER_SIZE;
-	for (i = dev->log_tail; dev->log_buffer[i] != '\n';
-			i = (i+1) % PRINT_BUFFER_SIZE)
-		;
-	dev->log_tail = (i+1) % PRINT_BUFFER_SIZE;
-}
-
-static void ish_print_log(struct heci_device *dev, char *format, ...)
-{
-	char tmp_buf[1024];
-	va_list args;
-	int length, i, full_space, free_space;
-	unsigned long	flags;
-	struct timeval tv;
-	struct timeval tv1, tv2, tv_diff;
-
-	do_gettimeofday(&tv1);
-	/* Fix for power-off path */
-	if (!heci_pci_device)
-		return;
-
-	do_gettimeofday(&tv);
-	i = scnprintf(tmp_buf, sizeof(tmp_buf), "[%ld.%06ld] ",
-		tv.tv_sec, tv.tv_usec);
-
-	va_start(args, format);
-	length = vsnprintf(tmp_buf + i, sizeof(tmp_buf)-i, format, args);
-	va_end(args);
-
-	length = length + i;
-	/* if the msg does not end with \n, add it */
-	if (tmp_buf[length-1] != '\n') {
-		tmp_buf[length] = '\n';
-		length++;
-	}
-
-	spin_lock_irqsave(&dev->log_spinlock, flags);
-
-	full_space = dev->log_head - dev->log_tail;
-	if (full_space < 0)
-		full_space = PRINT_BUFFER_SIZE + full_space;
-	free_space = PRINT_BUFFER_SIZE - full_space;
-
-	if (free_space <= length)
-		/*
-		 * not enougth space.
-		 * needed at least 1 empty char to recognize
-		 * whether buffer is full or empty
-		 */
-		delete_from_log(dev, (length - free_space) + 1);
-
-	if (dev->log_head + length <= PRINT_BUFFER_SIZE) {
-		memcpy(dev->log_buffer + dev->log_head, tmp_buf, length);
-	} else {
-		memcpy(dev->log_buffer + dev->log_head, tmp_buf,
-			PRINT_BUFFER_SIZE - dev->log_head);
-		memcpy(dev->log_buffer,
-			tmp_buf + PRINT_BUFFER_SIZE - dev->log_head,
-			length - (PRINT_BUFFER_SIZE - dev->log_head));
-	}
-	dev->log_head = (dev->log_head + length) % PRINT_BUFFER_SIZE;
-
-	spin_unlock_irqrestore(&dev->log_spinlock, flags);
-
-	do_gettimeofday(&tv2);
-	tv_diff.tv_sec = tv2.tv_sec - tv1.tv_sec;
-	tv_diff.tv_usec = tv2.tv_usec - tv1.tv_usec;
-	if (tv1.tv_usec > tv2.tv_usec) {
-		tv_diff.tv_usec += 1000000UL;
-		--tv_diff.tv_sec;
-	}
-	if (tv_diff.tv_sec > dev->max_log_sec ||
-			tv_diff.tv_sec == dev->max_log_sec &&
-			tv_diff.tv_usec > dev->max_log_usec) {
-		dev->max_log_sec = tv_diff.tv_sec;
-		dev->max_log_usec = tv_diff.tv_usec;
-	}
-}
-
-
-void	g_ish_print_log(char *fmt, ...)
-{
-	char tmp_buf[1024];
-	va_list args;
-	struct heci_device	*dev;
-
-	/* Fix for power-off path */
-	if (!heci_pci_device)
-		return;
-
-	dev = pci_get_drvdata(heci_pci_device);
-	va_start(args, fmt);
-	vsnprintf(tmp_buf, sizeof(tmp_buf), fmt, args);
-	va_end(args);
-	ish_print_log(dev, tmp_buf);
-}
-EXPORT_SYMBOL(g_ish_print_log);
-
-
-static ssize_t ish_read_log(struct heci_device *dev, char *buf, size_t size)
-{
-	int i, full_space, ret_val;
-
-	if (dev->log_head == dev->log_tail) /* log is empty */
-		return 0;
-
-	/* read size the minimum between full_space and the buffer size */
-	full_space = dev->log_head - dev->log_tail;
-	if (full_space < 0)
-		full_space = PRINT_BUFFER_SIZE + full_space;
-
-	if (full_space < size)
-		i = (dev->log_tail + full_space) % PRINT_BUFFER_SIZE;
-		/* log has less than 'size' bytes, i = dev->log_head */
-	else
-		i = (dev->log_tail + size) % PRINT_BUFFER_SIZE;
-	/* i is the last character to be readen */
-	i = (i-1) % PRINT_BUFFER_SIZE;
-
-	/* read from tail to last '\n' before i */
-	for (; dev->log_buffer[i] != '\n'; i = (i-1) % PRINT_BUFFER_SIZE)
-		;
-
-	if (dev->log_tail < i) {
-		memcpy(buf, dev->log_buffer + dev->log_tail,
-			i - dev->log_tail + 1);
-		ret_val = i - dev->log_tail + 1;
-	} else {
-		memcpy(buf, dev->log_buffer + dev->log_tail,
-			PRINT_BUFFER_SIZE - dev->log_tail);
-		memcpy(buf + PRINT_BUFFER_SIZE - dev->log_tail,
-			dev->log_buffer, i + 1);
-		ret_val = PRINT_BUFFER_SIZE - dev->log_tail + i + 1;
-	}
-	return ret_val;
-}
-
-static ssize_t ish_read_flush_log(struct heci_device *dev, char *buf,
-	size_t size)
-{
-	int ret;
-
-	ret = ish_read_log(dev, buf, size);
-	delete_from_log(dev, ret);
-	return ret;
-}
-
-/* show & store functions for both read and flush char devices*/
-ssize_t show_read(struct device *dev, struct device_attribute *dev_attr,
-	char *buf)
-{
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	ssize_t retval;
-	unsigned long	flags;
-
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-	spin_lock_irqsave(&heci_dev->log_spinlock, flags);
-	retval = ish_read_log(heci_dev, buf, PAGE_SIZE);
-	spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
-
-	return retval;
-}
-
-ssize_t store_read(struct device *dev, struct device_attribute *dev_attr,
-	const char *buf, size_t count)
-{
-	return count;
-}
-
-static struct device_attribute read_attr = {
-	.attr = {
-		.name = "ish_read_log",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_read,
-	.store = store_read
-};
-
-ssize_t show_flush(struct device *dev, struct device_attribute *dev_attr,
-	char *buf)
-{
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	unsigned long	flags;
-	ssize_t retval;
-
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-	spin_lock_irqsave(&heci_dev->log_spinlock, flags);
-	retval = ish_read_flush_log(heci_dev, buf, PAGE_SIZE);
-	spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
-
-	return retval;
-}
-
-ssize_t store_flush(struct device *dev, struct device_attribute *dev_attr,
-	const char *buf, size_t count)
-{
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	unsigned long   flags;
-
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-
-	if (!strncmp(buf, "empty", 5)) {
-		spin_lock_irqsave(&heci_dev->log_spinlock, flags);
-		heci_dev->log_tail = heci_dev->log_head;
-		spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
-	}
-	return count;
-}
-
-static struct device_attribute flush_attr = {
-	.attr = {
-		.name = "ish_flush_log",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_flush,
-	.store = store_flush
-};
-#else
-
-static void ish_print_log_nolog(struct heci_device *dev, char *format, ...)
-{
-}
-
-void	g_ish_print_log(char *fmt, ...)
-{
-}
-EXPORT_SYMBOL(g_ish_print_log);
-
-#endif /* ISH_LOG */
-
-ssize_t show_heci_dev_props(struct device *dev,
-	struct device_attribute *dev_attr, char *buf)
-{
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	ssize_t	ret = -ENOENT;
-	unsigned	count;
-	unsigned long   flags, flags2, tx_flags, tx_free_flags;
-
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-
-	if (!strcmp(dev_attr->attr.name, "heci_dev_state")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)heci_dev->dev_state);
-		ret = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "hbm_state")) {
-		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)heci_dev->hbm_state);
-		ret = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "fw_status")) {
-		scnprintf(buf, PAGE_SIZE, "%08X\n",
-			heci_dev->ops->get_fw_status(heci_dev));
-		ret = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "ipc_buf")) {
-		struct wr_msg_ctl_info *ipc_link, *ipc_link_next;
-
-		count = 0;
-		spin_lock_irqsave(&heci_dev->wr_processing_spinlock, flags);
-		list_for_each_entry_safe(ipc_link, ipc_link_next,
-			&heci_dev->wr_processing_list_head.link, link)
-			++count;
-		spin_unlock_irqrestore(&heci_dev->wr_processing_spinlock,
-			flags);
-		scnprintf(buf, PAGE_SIZE, "outstanding %u messages\n", count);
-		ret = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "host_clients")) {
-		struct heci_cl *cl, *next;
-		static const char * const cl_states[] = {"initializing",
-			"connecting", "connected", "disconnecting",
-			"disconnected"};
-		struct heci_cl_rb	*rb, *next_rb;
-		struct heci_cl_tx_ring	*tx_rb, *next_tx_rb;
-
-		scnprintf(buf, PAGE_SIZE, "Host clients:\n"
-				"------------\n");
-		spin_lock_irqsave(&heci_dev->device_lock, flags);
-		list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
-			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-				"id: %d\n",
-				cl->host_client_id);
-			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-				"state: %s\n", cl->state < 0 || cl->state >
-					HECI_CL_DISCONNECTED ?
-					"unknown" : cl_states[cl->state]);
-			if (cl->state == HECI_CL_CONNECTED) {
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"FW client id: %d\n", cl->me_client_id);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"RX ring size: %u\n", cl->rx_ring_size);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"TX ring size: %u\n", cl->tx_ring_size);
-
-				count = 0;
-				spin_lock_irqsave(&cl->in_process_spinlock,
-					flags2);
-				list_for_each_entry_safe(rb, next_rb,
-						&cl->in_process_list.list, list)
-					++count;
-				spin_unlock_irqrestore(&cl->in_process_spinlock,
-					flags2);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"RX in work: %u\n", count);
-
-				count = 0;
-				spin_lock_irqsave(&cl->in_process_spinlock,
-					flags2);
-				list_for_each_entry_safe(rb, next_rb,
-						&cl->free_rb_list.list, list)
-					++count;
-				spin_unlock_irqrestore(&cl->in_process_spinlock,
-					flags2);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"RX free: %u\n", count);
-
-				count = 0;
-				spin_lock_irqsave(&cl->tx_list_spinlock,
-					tx_flags);
-				list_for_each_entry_safe(tx_rb, next_tx_rb,
-						&cl->tx_list.list, list)
-					++count;
-				spin_unlock_irqrestore(&cl->tx_list_spinlock,
-					tx_flags);
-
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"TX pending: %u\n", count);
-				count = 0;
-				spin_lock_irqsave(
-					&cl->tx_free_list_spinlock,
-					tx_free_flags);
-				list_for_each_entry_safe(tx_rb, next_tx_rb,
-						&cl->tx_free_list.list, list)
-					++count;
-				spin_unlock_irqrestore(
-					&cl->tx_free_list_spinlock,
-					tx_free_flags);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"TX free: %u\n", count);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"FC: %u\n",
-					(unsigned)cl->heci_flow_ctrl_creds);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					 "out FC: %u\n",
-					(unsigned)cl->out_flow_ctrl_creds);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Err snd msg: %u\n",
-					(unsigned)cl->err_send_msg);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Err snd FC: %u\n",
-					(unsigned)cl->err_send_fc);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Tx count: %u\n",
-					(unsigned)cl->send_msg_cnt);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Rx count: %u\n",
-					(unsigned)cl->recv_msg_cnt);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"FC count: %u\n",
-					(unsigned)cl->heci_flow_ctrl_cnt);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"out FC cnt: %u\n",
-					(unsigned)cl->out_flow_ctrl_cnt);
-				scnprintf(buf + strlen(buf),
-					PAGE_SIZE - strlen(buf),
-					"Max FC delay: %lu.%06lu\n",
-					cl->max_fc_delay_sec,
-					cl->max_fc_delay_usec);
-			}
-		}
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID out FC: %u\n",
-			(unsigned)heci_dev->ipc_hid_out_fc);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID out FC count: %u\n",
-			(unsigned)heci_dev->ipc_hid_out_fc_cnt);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID in msg: %u\n",
-			(unsigned)heci_dev->ipc_hid_in_msg);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID in FC: %u\n",
-			(unsigned)heci_dev->ipc_hid_in_fc);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID in FC count: %u\n",
-			(unsigned)heci_dev->ipc_hid_in_fc_cnt);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC HID out msg: %u\n",
-			(unsigned)heci_dev->ipc_hid_out_msg);
-		spin_unlock_irqrestore(&heci_dev->device_lock, flags);
-		ret = strlen(buf);
-	} else if (!strcmp(dev_attr->attr.name, "stats")) {
-		scnprintf(buf, PAGE_SIZE, "Max. log time: %lu.%06lu\n",
-			heci_dev->max_log_sec, heci_dev->max_log_usec);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC Rx frames: %u; bytes: %llu\n",
-			heci_dev->ipc_rx_cnt, heci_dev->ipc_rx_bytes_cnt);
-		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
-			"IPC Tx frames: %u; bytes: %llu\n",
-			heci_dev->ipc_tx_cnt, heci_dev->ipc_tx_bytes_cnt);
-		ret = strlen(buf);
-	}
-
-	return	ret;
-}
-
-ssize_t store_heci_dev_props(struct device *dev,
-	struct device_attribute *dev_attr, const char *buf, size_t count)
-{
-	return	-EINVAL;
-}
-
-/* Debug interface to force flow-control to HID client */
-static unsigned	num_force_hid_fc;
-
-ssize_t show_force_hid_fc(struct device *dev, struct device_attribute *dev_attr,
-	char *buf)
-{
-	scnprintf(buf, PAGE_SIZE, "%u\n", num_force_hid_fc);
-	return	 strlen(buf);
-}
-
-ssize_t store_force_hid_fc(struct device *dev,
-	struct device_attribute *dev_attr, const char *buf, size_t count)
-{
-	struct pci_dev *pdev;
-	struct heci_device *heci_dev;
-	struct heci_cl *cl, *next;
-	unsigned long	tx_flags;
-
-	pdev = container_of(dev, struct pci_dev, dev);
-	heci_dev = pci_get_drvdata(pdev);
-
-	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
-		if (cl->host_client_id == 3 && cl->me_client_id == 5) {
-			dev_warn(dev, "HID FC %u, forced to 1\n",
-				(unsigned)cl->heci_flow_ctrl_creds);
-			cl->heci_flow_ctrl_creds = 1;
-			++num_force_hid_fc;
-			spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
-			if (!list_empty(&cl->tx_list.list)) {
-				/* start sending the first msg
-				 = the callback function */
-				spin_unlock_irqrestore(&cl->tx_list_spinlock,
-					tx_flags);
-				heci_cl_send_msg(heci_dev, cl);
-			} else {
-				spin_unlock_irqrestore(&cl->tx_list_spinlock,
-					tx_flags);
-			}
-			break;
-		}
-	}
-
-	return	 strlen(buf);
-}
-
-static struct device_attribute heci_dev_state_attr = {
-	.attr = {
-		.name = "heci_dev_state",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
-};
-
-static struct device_attribute hbm_state_attr = {
-	.attr = {
-		.name = "hbm_state",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
-};
-
-static struct device_attribute fw_status_attr = {
-	.attr = {
-		.name = "fw_status",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
-};
-
-static struct device_attribute host_clients_attr = {
-	.attr = {
-		.name = "host_clients",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
-};
-
-static struct device_attribute ipc_buf_attr = {
-	.attr = {
-		.name = "ipc_buf",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
-};
-
-static struct device_attribute stats_attr = {
-	.attr = {
-		.name = "stats",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_heci_dev_props,
-	.store = store_heci_dev_props
-};
-
-static struct device_attribute force_hid_fc_attr = {
-	.attr = {
-		.name = "force_hid_fc",
-		.mode = (S_IWUSR | S_IRUGO)
-	},
-	.show = show_force_hid_fc,
-	.store = store_force_hid_fc
-};
-/**********************************/
-
-struct my_work_t {
-	struct work_struct my_work;
-	struct heci_device *dev;
-};
-
-struct my_work_t *work;
-
-void workqueue_init_function(struct work_struct *work)
-{
-	struct heci_device *dev = ((struct my_work_t *)work)->dev;
-	int err;
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[pci driver] %s() in workqueue func, continue initialization process\n",
-		__func__);
-
-	pci_set_drvdata(dev->pdev, dev);
-/*	dev_dbg(&dev->pdev->dev, "heci: after pci_set_drvdata\n");*/
-
-	device_create_file(&dev->pdev->dev, &heci_dev_state_attr);
-	device_create_file(&dev->pdev->dev, &hbm_state_attr);
-	device_create_file(&dev->pdev->dev, &fw_status_attr);
-	device_create_file(&dev->pdev->dev, &host_clients_attr);
-	device_create_file(&dev->pdev->dev, &ipc_buf_attr);
-	device_create_file(&dev->pdev->dev, &stats_attr);
-	device_create_file(&dev->pdev->dev, &force_hid_fc_attr);
-
-#if ISH_LOG
-
-	device_create_file(&dev->pdev->dev, &read_attr);
-	device_create_file(&dev->pdev->dev, &flush_attr);
-
-	dev->log_head = dev->log_tail = 0;
-	dev->print_log = ish_print_log;
-
-	spin_lock_init(&dev->log_spinlock);
-
-	dev->print_log(dev,
-		"[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
-		__func__);
-	dev->print_log(dev, "[heci-ish] %s() running on %s revision [%02X]\n",
-		__func__,
-		dev->pdev->revision == REVISION_ID_CHT_A0 ||
-		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-		REVISION_ID_CHT_A0_SI ? "CHT Ax" :
-		dev->pdev->revision == REVISION_ID_CHT_B0 ||
-		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-		REVISION_ID_CHT_Bx_SI ? "CHT Bx" :
-		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
-		REVISION_ID_CHT_Kx_SI ? "CHT Kx/Cx" : "Unknown",
-		dev->pdev->revision);
-#else
-	dev->print_log = ish_print_log_nolog;
-#endif /*ISH_LOG*/
-
-	init_waitqueue_head(&suspend_wait);
-
-	mutex_lock(&heci_mutex);
-	if (heci_start(dev)) {
-		dev_err(&dev->pdev->dev, "heci: Init hw failure.\n");
-		err = -ENODEV;
-		goto out_err;
-	}
-/*	dev_dbg(&dev->pdev->dev, "heci: after heci_start\n");*/
-
-	err = heci_register(dev);
-	if (err)
-		goto out_err;
-/*	dev_dbg(&dev->pdev->dev, "heci: after heci_register\n");*/
-
-
-	mutex_unlock(&heci_mutex);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[pci driver] %s() in workqueue func, finished initialization process\n",
-		__func__);
-	kfree((void *)work);
-	return;
-
-out_err:
-	mutex_unlock(&heci_mutex);
-	kfree((void *)work);
-}
-
-/**********************************/
-
-/**
- * ish_probe - Device Initialization Routine
- *
- * @pdev: PCI device structure
- * @ent: entry in ish_pci_tbl
- *
- * returns 0 on success, <0 on failure.
- */
-static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
-{
-	struct heci_device *dev;
-	struct ish_hw *hw;
-	int err;
-	int	rv;
-
-	ISH_INFO_PRINT(
-	KERN_ERR "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
-		__func__);
-	ISH_INFO_PRINT(KERN_ERR
-		"[heci-ish] %s() running on %s revision [%02X]\n", __func__,
-		pdev->revision == REVISION_ID_CHT_A0 ||
-		(pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_A0_SI ? "CHT A0" :
-		pdev->revision == REVISION_ID_CHT_B0 ||
-		(pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Bx_SI ? "CHT B0" :
-		(pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Kx_SI ? "CHT Kx/Cx" :
-		(pdev->revision & REVISION_ID_SI_MASK) ==
-			REVISION_ID_CHT_Dx_SI ? "CHT Dx" : "Unknown",
-		pdev->revision);
-#if defined(SUPPORT_Ax_ONLY)
-	pdev->revision = REVISION_ID_CHT_A0;
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to A0\n",
-		__func__);
-#elif defined(SUPPORT_Bx_ONLY)
-	pdev->revision = REVISION_ID_CHT_B0;
-	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to B0\n",
-		__func__);
-#endif
-	mutex_lock(&heci_mutex);
-	if (heci_pci_device) {
-		err = -EEXIST;
-		goto end;
-	}
-	/* enable pci dev */
-	err = pci_enable_device(pdev);
-	if (err) {
-		dev_err(&pdev->dev, "heci: Failed to enable pci device.\n");
-		goto end;
-	}
-	/* set PCI host mastering  */
-	pci_set_master(pdev);
-	/* pci request regions for heci driver */
-	err = pci_request_regions(pdev, KBUILD_MODNAME);
-	if (err) {
-		dev_err(&pdev->dev, "heci: Failed to get pci regions.\n");
-		goto disable_device;
-	}
-
-	/* allocates and initializes the heci dev structure */
-	dev = ish_dev_init(pdev);
-	if (!dev) {
-		err = -ENOMEM;
-		goto release_regions;
-	}
-	hw = to_ish_hw(dev);
-
-	/* mapping  IO device memory */
-	hw->mem_addr = pci_iomap(pdev, 0, 0);
-	if (!hw->mem_addr) {
-		dev_err(&pdev->dev, "mapping I/O device memory failure.\n");
-		err = -ENOMEM;
-		goto free_device;
-	}
-
-#if ISH_DEBUGGER
-	ishdbg_misc_device.parent = &pdev->dev;
-	rv = misc_register(&ishdbg_misc_device);
-	if (rv)
-		dev_err(&pdev->dev,
-			"error starting ISS debugger (misc_register): %d\n",
-			rv);
-	hw_dbg = hw;
-#endif /*ISH_DEBUGGER*/
-
-	heci_pci_device = pdev;
-
-	/* request and enable interrupt   */
-#ifndef TIMER_POLLING
-	err = request_irq(pdev->irq, ish_irq_handler, IRQF_NO_SUSPEND,
-		KBUILD_MODNAME, dev);
-	if (err) {
-		dev_err(&pdev->dev, "heci: request_irq failure. irq = %d\n",
-			pdev->irq);
-		goto free_device;
-	}
-	dev_alert(&pdev->dev, "[heci-ish]: uses IRQ %d\n", pdev->irq);
-
-	/* Diagnostic output */
-	do {
-		uint32_t	msg_addr;
-		uint32_t	msg_data;
-
-		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_LO,
-			&msg_addr);
-		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_DATA_32,
-			&msg_data);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[heci-ish] %s(): assigned IRQ = %d, [PCI_MSI_ADDRESS_LO] = %08X [PCI_MSI_DATA_32] = %08X\n",
-			__func__, pdev->irq, msg_addr, msg_data);
-	} while (0);
-	/*********************/
-#else
-	/* Init & prepare workqueue */
-	INIT_WORK(&ish_poll_work, ish_poll_work_fn);
-
-	/* Create and schedule ISS polling timer */
-	init_timer(&ish_poll_timer);
-	ish_poll_timer.data = 0;
-	ish_poll_timer.function = ish_poll_timer_fn;
-	ish_poll_timer.expires = jiffies + 2;
-	timer_data = dev;
-	add_timer(&ish_poll_timer);
-
-	/* Init ISS polling timers workqueue */
-#endif
-
-	/* PCI quirk: prevent from being put into D3 state */
-	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
-
-
-	/*
-	 * 7/7/2014: in order to not stick Android boot,
-	 * from here & below needs to run in work queue
-	 * and here we should return success
-	 */
-	/****************************************************************/
-	work = kmalloc(sizeof(struct my_work_t), GFP_KERNEL);
-	if (!work)
-		return -ENOMEM;
-	work->dev = dev;
-	workqueue_for_init = create_workqueue("workqueue_for_init");
-	if (!workqueue_for_init) {
-		kfree(work);
-		return -ENOMEM;
-	}
-	INIT_WORK(&work->my_work, workqueue_init_function);
-	queue_work(workqueue_for_init, &work->my_work);
-
-	ISH_DBG_PRINT("[pci driver] %s() enqueue init_work function\n",
-		__func__);
-
-	mutex_unlock(&heci_mutex);
-	return 0;
-	/****************************************************************/
-
-free_device:
-	pci_iounmap(pdev, hw->mem_addr);
-	kfree(dev);
-release_regions:
-	pci_release_regions(pdev);
-disable_device:
-	pci_disable_device(pdev);
-end:
-	mutex_unlock(&heci_mutex);
-	dev_err(&pdev->dev, "heci: Driver initialization failed.\n");
-	return err;
-}
-
-/**
- * heci_remove - Device Removal Routine
- *
- * @pdev: PCI device structure
- *
- * heci_remove is called by the PCI subsystem to alert the driver
- * that it should release a PCI device.
- */
-static void ish_remove(struct pci_dev *pdev)
-{
-	struct heci_device *dev;
-	struct ish_hw *hw;
-
-	/*
-	 * This happens during power-off/reboot and may be at the same time as
-	 * a lot of bi-directional communication happens
-	 */
-	if (heci_pci_device != pdev) {
-		dev_err(&pdev->dev, "heci: heci_pci_device != pdev\n");
-		return;
-	}
-
-	dev = pci_get_drvdata(pdev);
-	if (!dev) {
-		dev_err(&pdev->dev, "heci: dev =NULL\n");
-		return;
-	}
-
-	hw = to_ish_hw(dev);
-
-	/*
-	 * Set HECI device state to disabled.
-	 * Invalidate all other possible communication in both directions
-	 */
-	heci_device_disable(dev);
-
-	free_irq(pdev->irq, dev);
-	pci_disable_msi(pdev);
-	pci_iounmap(pdev, hw->mem_addr);
-	heci_pci_device = NULL;
-	if (workqueue_for_init) {
-		flush_workqueue(workqueue_for_init);
-		destroy_workqueue(workqueue_for_init);
-		workqueue_for_init = NULL;
-	}
-	pci_set_drvdata(pdev, NULL);
-	heci_deregister(dev);
-	kfree(dev);
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-}
-
-int ish_suspend(struct device *device)
-{
-	struct pci_dev *pdev = to_pci_dev(device);
-	struct heci_device *dev = pci_get_drvdata(pdev);
-
-	enable_irq_wake(pdev->irq);
-
-	/* If previous suspend hasn't been asnwered then ISH is likely dead,
-	don't attempt nested notification */
-	if (suspend_flag)
-		return	0;
-
-	suspend_flag = 1;
-	send_suspend(dev);
-
-	/* 250 ms should be likely enough for live ISH to flush all IPC buf */
-	if (suspend_flag)
-		wait_event_timeout(suspend_wait, !suspend_flag, HZ / 4);
-	return 0;
-}
-
-int ish_resume(struct device *device)
-{
-	struct pci_dev *pdev = to_pci_dev(device);
-	struct heci_device *dev = pci_get_drvdata(pdev);
-
-	disable_irq_wake(pdev->irq);
-	send_resume(dev);
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static const struct dev_pm_ops ish_pm_ops = {
-	.suspend = ish_suspend,
-	.resume = ish_resume,
-};
-
-#define HECI_ISH_PM_OPS	(&ish_pm_ops)
-#else
-#define HECI_ISH_PM_OPS	NULL
-#endif /* CONFIG_PM */
-
-
-/*
- *  PCI driver structure
- */
-static struct pci_driver ish_driver = {
-	.name = KBUILD_MODNAME,
-	.id_table = ish_pci_tbl,
-	.probe = ish_probe,
-	.remove = ish_remove,
-	.shutdown = ish_remove,
-	.driver.pm = HECI_ISH_PM_OPS,
-};
-
-module_pci_driver(ish_driver);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("Intel(R) Integrated Sensor Hub PCI Device Driver");
-MODULE_LICENSE("GPL v2");
-
diff --git a/drivers/misc/heci/platform-config.h b/drivers/misc/heci/platform-config.h
deleted file mode 100644
index 2696bac..0000000
--- a/drivers/misc/heci/platform-config.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * ISS platform-specific definitions
- *
- * Copyright (c) 2012-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#ifndef PLATFORM_CONFIG__H
-#define PLATFORM_CONFIG__H
-
-/* Build ID string */
-#define	BUILD_ID	"0195-fix-recv-hid-hw-reset"
-
-#define	ISH_DEBUG	0
-#if ISH_DEBUG
-#define	ISH_DBG_PRINT	printk
-#else
-#define	ISH_DBG_PRINT	no_printk
-#endif
-
-#define	ISH_INFO	1
-#if ISH_INFO
-#define	ISH_INFO_PRINT	printk
-#else
-#define	ISH_INFO_PRINT	no_printk
-#endif
-
-#define ISH_LOG		0
-
-#if 0
-/*
- * Define if running on VirtualBox -
- * may solve imprecise timer emulation problems
- */
-#define	HOST_VIRTUALBOX	1
-#endif
-
-#if 0
-/* Timer-polling workaround for DUTs with non-functional interrupts reporting */
-#define	TIMER_POLLING	1
-#endif
-
-#define	REVISION_ID_CHT_A0	0x6
-#define	REVISION_ID_CHT_A0_SI	0x0
-#define	REVISION_ID_CHT_Bx_SI	0x10
-#define	REVISION_ID_CHT_Kx_SI	0x20
-#define	REVISION_ID_CHT_Dx_SI	0x30
-#define	REVISION_ID_CHT_B0	0xB0
-
-#define	REVISION_ID_SI_MASK	0x70
-
-/* For buggy (pre-)silicon, select model rather than retrieve it */
-#if 0
-/* If defined, will support A0 only, will not check revision ID */
-#define	SUPPORT_Ax_ONLY	1
-
-#else
-
-#if  0
-/* If defined, will support B0 only, will not check revision ID */
-#define	SUPPORT_B0_ONLY	1
-#endif
-#endif
-
-#if defined(SUPPORT_A0_ONLY) && defined(SUPPORT_B0_ONLY)
-#error Only one of SUPPORT_A0_ONLY and SUPPORT_B0_ONLY may be defined
-#endif
-
-/* D3 RCR */
-#define	D3_RCR	1
-
-/* Define in order to force FW-initated reset */
-#define	FORCE_FW_INIT_RESET	1
-
-/* Include ISH register debugger */
-#define	ISH_DEBUGGER	1
-
-/* Debug mutex locking/unlocking */
-#define	DEBUG_LOCK	0
-
-#if DEBUG_LOCK
-
-static void	do_mutex_lock(void *m)
-{
-	mutex_lock(m);
-}
-
-static void	do_mutex_unlock(void *m)
-{
-	mutex_unlock(m);
-}
-
-#ifdef mutex_lock
-#undef mutex_lock
-#endif
-#ifdef mutex_unlock
-#undef mutex_unlock
-#endif
-
-#define mutex_lock(a) \
-	do {\
-		dev_warn(NULL, "%s:%d[%s] -- mutex_lock(%p)\n",	\
-			__FILE__, __LINE__, __func__, a);	\
-		do_mutex_lock(a);	\
-	} while (0)
-
-#define mutex_unlock(a) \
-	do {\
-		dev_warn(NULL, "%s:%d[%s] -- mutex_unlock(%p)\n",	\
-			__FILE__, __LINE__, __func__, a);	\
-		do_mutex_unlock(a);	\
-	} while (0)
-#endif /* DEBUG_LOCK */
-/*************************************/
-
-#endif /* PLATFORM_CONFIG__H*/
-
diff --git a/drivers/misc/heci/senscol-core.c b/drivers/misc/heci/senscol-core.c
deleted file mode 100644
index 8d20977..0000000
--- a/drivers/misc/heci/senscol-core.c
+++ /dev/null
@@ -1,1161 +0,0 @@
-/*
- * Sensor collection framework core
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-
-#include <linux/module.h>
-#include <linux/senscol/senscol-core.h>
-#include <linux/platform_device.h>
-#include <linux/kobject.h>
-#include <linux/spinlock.h>
-#include <linux/slab.h>
-#include "hid-strings-def.h"
-#include "platform-config.h"
-#include <linux/miscdevice.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
-#include "heci-hid.h"
-
-struct list_head	senscol_impl_list;
-struct list_head	senscol_sensors_list;
-spinlock_t	senscol_lock;
-spinlock_t	senscol_data_lock;
-uint8_t	*senscol_data_buf;
-unsigned	senscol_data_head, senscol_data_tail;
-int	flush_asked = 0;
-struct task_struct *user_task;
-
-static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
-	char *buf);
-
-static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size);
-
-static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
-
-static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
-
-static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
-	char *buf);
-
-static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size);
-
-static struct platform_device	*sc_pdev;
-
-wait_queue_head_t senscol_read_wait;
-
-void senscol_send_ready_event(void)
-{
-	if (waitqueue_active(&senscol_read_wait))
-		wake_up_interruptible(&senscol_read_wait);
-}
-EXPORT_SYMBOL(senscol_send_ready_event);
-
-int senscol_reset_notify(void)
-{
-
-	struct siginfo si;
-	int ret;
-
-	memset(&si, 0, sizeof(struct siginfo));
-	si.si_signo = SIGUSR1;
-	si.si_code = SI_USER;
-
-	if (user_task == NULL)
-		return -EINVAL;
-
-	ret = send_sig_info(SIGUSR1, &si, user_task);
-	return ret;
-}
-EXPORT_SYMBOL(senscol_reset_notify);
-
-const char *senscol_usage_to_name(unsigned usage)
-{
-	int i;
-
-	for (i = 0; code_msg_arr[i].msg && code_msg_arr[i].code != usage; i++)
-		;
-	return	code_msg_arr[i].msg;
-}
-EXPORT_SYMBOL(senscol_usage_to_name);
-
-
-unsigned senscol_name_to_usage(const char *name)
-{
-	int i;
-
-	for (i = 0; code_msg_arr[i].msg &&
-			strcmp(code_msg_arr[i].msg, name) != 0; ++i)
-		;
-	return	code_msg_arr[i].code;
-}
-EXPORT_SYMBOL(senscol_name_to_usage);
-
-
-const char	*senscol_get_modifier(unsigned modif)
-{
-	uint32_t to4bits = modif >> 0xC;
-	return	modifiers[to4bits];
-}
-EXPORT_SYMBOL(senscol_get_modifier);
-
-
-
-#if 0
-/*
- * data kobject attributes and handlers
- */
-
-static struct attribute	sc_data_defattr_event = {
-	.name = "event",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute	*sc_data_defattrs[] = {
-	&sc_data_defattr_event,
-	NULL
-};
-#endif
-
-static void	sc_data_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
-
-static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	scnprintf(buf, PAGE_SIZE, "%s\n", attr->name);
-	return	strlen(buf);
-}
-
-static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__,
-		attr->name, buf, (unsigned)size);
-	return	size;
-}
-
-const struct sysfs_ops	sc_data_sysfs_fops = {
-	.show = sc_data_show,
-	.store = sc_data_store
-};
-
-struct kobj_type	sc_data_kobj_type = {
-	.release = sc_data_release,
-	.sysfs_ops = &sc_data_sysfs_fops
-	/*.default_attrs = sc_data_defattrs*/
-};
-
-struct bin_attribute	sensors_data_binattr = {
-	.attr = {
-		.name = "sensors_data",
-		.mode = S_IRUGO
-	},
-	.size = 0,
-	.read = sensors_data_read,
-	.write = sensors_data_write
-};
-
-struct kobject	sc_data_kobj;
-
-/*****************************************/
-
-
-/*
- * sensor_def kobject type and handlers
- */
-static struct attribute	sc_sensdef_defattr_name = {
-	.name = "name",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_sensdef_defattr_id = {
-	.name = "id",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_sensdef_defattr_usage_id = {
-	.name = "usage_id",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_sensdef_defattr_sample_size = {
-	.name = "sample_size",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_sensdef_defattr_flush = {
-	.name = "flush",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_sensdef_defattr_get_sample = {
-	.name = "get_sample",
-	.mode = (S_IRUGO)
-};
-
-struct attribute	*sc_sensdef_defattrs[] = {
-	&sc_sensdef_defattr_name,
-	&sc_sensdef_defattr_id,
-	&sc_sensdef_defattr_usage_id,
-	&sc_sensdef_defattr_sample_size,
-	&sc_sensdef_defattr_flush,
-	&sc_sensdef_defattr_get_sample,
-	NULL
-};
-
-static void	sc_sensdef_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
-
-static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	ssize_t	rv;
-	struct sensor_def	*sensdef;
-	static char    tmp_buf[0x1000];
-	unsigned long flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	sensdef = container_of(kobj, struct sensor_def, kobj);
-	buf[0] = '\0';
-	if (!strcmp(attr->name, "id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->id);
-	else if (!strcmp(attr->name, "sample_size"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", sensdef->sample_size);
-	else if (!strcmp(attr->name, "usage_id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->usage_id);
-	else if (!strcmp(attr->name, "name"))
-		scnprintf(buf, PAGE_SIZE, "%s\n", sensdef->name);
-	else if (!strcmp(attr->name, "flush"))
-		/*if "sensdef" is activated in batch mode,
-		mark it as asking flush*/
-		if (sensdef->impl->batch_check(sensdef)) {
-			spin_lock_irqsave(&senscol_lock, flags);
-			flush_asked = 1;
-			sensdef->flush_req = 1;
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			sensdef->impl->get_sens_property(sensdef,
-				sensdef->properties, tmp_buf, 0x1000);
-			scnprintf(buf, PAGE_SIZE, "1\n");
-		} else {
-			uint32_t pseudo_event_id =
-				sensdef->id | PSEUSO_EVENT_BIT;
-			uint32_t pseudo_event_content = 0;
-			pseudo_event_content |= FLUSH_CMPL_BIT;
-			push_sample(pseudo_event_id, &pseudo_event_content);
-			scnprintf(buf, PAGE_SIZE, "0\n");
-		}
-	else if (!strcmp(attr->name, "get_sample")) {
-		rv = sensdef->impl->get_sample(sensdef);
-		/* The sample will arrive to hid "raw event" func,
-		and will be pushed to user via "push_sample" method */
-
-		scnprintf(buf, PAGE_SIZE, "%d\n", !rv);
-	}
-	rv = strlen(buf) + 1;
-	return	rv;
-}
-
-static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
-}
-const struct sysfs_ops	sc_sensdef_sysfs_fops = {
-	.show = sc_sensdef_show,
-	.store = sc_sensdef_store
-};
-
-struct kobj_type	sc_sensdef_kobj_type = {
-	.release = sc_sensdef_release,
-	.sysfs_ops = &sc_sensdef_sysfs_fops,
-	.default_attrs = sc_sensdef_defattrs
-};
-/*****************************************/
-
-/*
- * kobject type for empty sub-directories
- */
-static struct attribute	*sc_subdir_defattrs[] = {
-	NULL
-};
-
-static void	sc_subdir_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
-
-static ssize_t	sc_subdir_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
-}
-
-static ssize_t	sc_subdir_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
-}
-
-const struct sysfs_ops	sc_subdir_sysfs_fops = {
-	.show = sc_subdir_show,
-	.store = sc_subdir_store
-};
-
-struct kobj_type	sc_subdir_kobj_type = {
-	.release = sc_subdir_release,
-	.sysfs_ops = &sc_subdir_sysfs_fops,
-	.default_attrs = sc_subdir_defattrs
-};
-/*****************************************/
-
-/*
- * sensors 'data_field's kobject type
- */
-static struct attribute	sc_datafield_defattr_usage_id = {
-	.name = "usage_id",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute	sc_datafield_defattr_exp = {
-	.name = "exponent",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_datafield_defattr_len = {
-	.name = "length",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_datafield_defattr_unit = {
-	.name = "unit",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_datafield_defattr_index = {
-	.name = "index",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute	sc_datafield_defattr_is_numeric = {
-	.name = "is_numeric",
-	.mode = (S_IRUGO)
-};
-
-struct attribute	*sc_datafield_defattrs[] = {
-	&sc_datafield_defattr_usage_id,
-	&sc_datafield_defattr_exp,
-	&sc_datafield_defattr_len,
-	&sc_datafield_defattr_unit,
-	&sc_datafield_defattr_index,
-	&sc_datafield_defattr_is_numeric,
-	NULL
-};
-
-static void	sc_datafield_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
-
-static ssize_t	sc_datafield_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	ssize_t	rv;
-	struct data_field	*dfield;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	dfield = container_of(kobj, struct data_field, kobj);
-	if (!strcmp(attr->name, "usage_id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", (unsigned)dfield->usage_id);
-	else if (!strcmp(attr->name, "exponent"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->exp);
-	else if (!strcmp(attr->name, "length"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->len);
-	else if (!strcmp(attr->name, "unit"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->unit);
-	else if (!strcmp(attr->name, "index"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->index);
-	else if (!strcmp(attr->name, "is_numeric"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->is_numeric);
-
-	rv = strlen(buf) + 1;
-	return	rv;
-}
-
-static ssize_t	sc_datafield_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__,
-		attr->name, buf, (unsigned)size);
-	return	-EINVAL;
-}
-
-const struct sysfs_ops	sc_datafield_sysfs_fops = {
-	.show = sc_datafield_show,
-	.store = sc_datafield_store
-};
-
-struct kobj_type	sc_datafield_kobj_type = {
-	.release = sc_datafield_release,
-	.sysfs_ops = &sc_datafield_sysfs_fops,
-	.default_attrs = sc_datafield_defattrs
-};
-/*****************************************/
-
-
-/*
- * sensors 'properties' kobject type
- */
-/*
-static struct attribute	sc_sensprop_defattr_unit = {
-	.name = "unit",
-	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
-};
-*/
-static struct attribute sc_sensprop_defattr_value = {
-	.name = "value",
-	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
-};
-
-static struct attribute sc_sensprop_defattr_usage_id = {
-	.name = "usage_id",
-	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
-};
-
-struct attribute	*sc_sensprop_defattrs[] = {
-/*	&sc_sensprop_defattr_unit,*/
-	&sc_sensprop_defattr_value,
-	&sc_sensprop_defattr_usage_id,
-	NULL
-};
-
-static void	sc_sensprop_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
-
-static ssize_t	sc_sensprop_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	struct sens_property	*pfield;
-	struct sensor_def	*sensor;
-	int	rv = -EINVAL;
-
-	/*
-	 * We need "property_power_state" (=2), "property_reporting_state" (=2)
-	 * and "property_report_interval" (in ms?)
-	 */
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	pfield = container_of(kobj, struct sens_property, kobj);
-	sensor = pfield->sensor;
-
-	if (!strcmp(attr->name, "value"))
-		rv = sensor->impl->get_sens_property(sensor, pfield, buf,
-			0x1000);
-	else if (!strcmp(attr->name, "usage_id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", pfield->usage_id & 0xFFFF);
-	if (rv)
-		return	rv;
-	return	strlen(buf);
-}
-
-static ssize_t	sc_sensprop_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	struct sens_property	*pfield;
-	struct sensor_def	*sensor;
-	int	rv;
-
-	/*
-	 * TODO: stream down set property request and return size
-	 * upon successful completion or error code
-	 */
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n",
-		__func__, attr->name, buf, (unsigned)size);
-	if (strcmp(attr->name, "value"))
-		return -EINVAL;
-
-	pfield = container_of(kobj, struct sens_property, kobj);
-	sensor = pfield->sensor;
-	rv = sensor->impl->set_sens_property(sensor, pfield, buf);
-
-	if (rv)
-		return	rv;
-	return	size;
-}
-
-const struct sysfs_ops	sc_sensprop_sysfs_fops = {
-	.show = sc_sensprop_show,
-	.store = sc_sensprop_store
-};
-
-struct kobj_type	sc_sensprop_kobj_type = {
-	.release = sc_sensprop_release,
-	.sysfs_ops = &sc_sensprop_sysfs_fops,
-	.default_attrs = sc_sensprop_defattrs
-};
-/*****************************************/
-
-static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
-{
-	size_t	count;
-	unsigned	cur;
-	struct senscol_sample	*sample;
-	unsigned long	flags;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-
-	if (size > PAGE_SIZE)
-		size = PAGE_SIZE;
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): >>> offs=%u size=%u senscol_data_head=%u senscol_data_tail=%u\n",
-		__func__, (unsigned)offs, (unsigned)size,
-		(unsigned)senscol_data_head, (unsigned)senscol_data_tail);
-
-	spin_lock_irqsave(&senscol_data_lock, flags);
-
-	/*
-	 * Count how much we may copy, keeping whole samples.
-	 * Copy samples along the way
-	 */
-	count = 0;
-	cur = senscol_data_head;
-	while (cur != senscol_data_tail) {
-		sample = (struct senscol_sample *)(senscol_data_buf + cur);
-		if (count + sample->size > size)
-			break;
-		memcpy(buf + count, sample, sample->size);
-		count += sample->size;
-		cur += sample->size;
-		if (cur > SENSCOL_DATA_BUF_LAST)
-			cur = 0;
-	}
-	senscol_data_head = cur;
-
-	spin_unlock_irqrestore(&senscol_data_lock, flags);
-
-	if (count) {
-		ISH_DBG_PRINT(KERN_ALERT
-			"[senscol]: <<< %s(): senscol_data_head=%u senscol_data_tail=%u\n",
-			__func__, senscol_data_head, senscol_data_tail);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[senscol]: %s(): returning count=%u\n", __func__,
-			(unsigned)count);
-	}
-
-	return	count;
-}
-
-static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
-}
-
-int	add_senscol_impl(struct senscol_impl *impl)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_add_tail(&impl->link, &senscol_impl_list);
-	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	0;
-}
-EXPORT_SYMBOL(add_senscol_impl);
-
-int	remove_senscol_impl(struct senscol_impl *impl)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_del(&impl->link);
-	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	0;
-}
-EXPORT_SYMBOL(remove_senscol_impl);
-
-/* Only allocates new sensor */
-struct sensor_def *alloc_senscol_sensor(void)
-{
-	struct sensor_def *sens;
-
-	sens = kzalloc(sizeof(struct sensor_def), GFP_KERNEL);
-	return	sens;
-}
-EXPORT_SYMBOL(alloc_senscol_sensor);
-
-/* Init sensor (don't call for initialized sensors */
-void	init_senscol_sensor(struct sensor_def *sensor)
-{
-	if (!sensor)
-		return;
-
-	memset(sensor, 0, sizeof(*sensor));
-	sensor->name = NULL;
-	sensor->friendly_name = NULL;
-	sensor->impl = NULL;
-	sensor->data_fields = NULL;
-	sensor->properties = NULL;
-}
-EXPORT_SYMBOL(init_senscol_sensor);
-
-int remove_senscol_sensor(uint32_t id)
-{
-	unsigned long	flags;
-	struct sensor_def	*sens, *next;
-	int i;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (sens->id == id) {
-			list_del(&sens->link);
-			spin_unlock_irqrestore(&senscol_lock, flags);
-
-			for (i = 0; i < sens->num_properties; ++i)
-				if (sens->properties[i].name) {
-					kobject_put(&sens->properties[i].kobj);
-					kobject_del(&sens->properties[i].kobj);
-				}
-			kfree(sens->properties);
-			kobject_put(&sens->props_kobj);
-			kobject_del(&sens->props_kobj);
-
-			for (i = 0; i < sens->num_data_fields; ++i)
-				if (sens->data_fields[i].name) {
-					kobject_put(&sens->data_fields[i].kobj);
-					kobject_del(&sens->data_fields[i].kobj);
-				}
-			kfree(sens->data_fields);
-			kobject_put(&sens->data_fields_kobj);
-			kobject_del(&sens->data_fields_kobj);
-			kobject_put(&sens->kobj);
-			kobject_del(&sens->kobj);
-
-			kfree(sens);
-
-			return 0;
-		}
-	}
-	spin_unlock_irqrestore(&senscol_lock, flags);
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL(remove_senscol_sensor);
-
-/*
- * Exposed sensor via sysfs, structure may be static
- *
- * The caller is responsible for setting all meaningful fields
- * (may call add_data_field() and add_sens_property() as needed)
- * We'll consider hiding senscol framework-specific fields
- * into opaque structures
- */
-
-int	add_senscol_sensor(struct sensor_def *sensor)
-{
-	unsigned long	flags;
-	char	sensor_name[256];	/* Enough for name "sensor_<NN>_def",
-					 * if convention changes array size
-					 * should be reviewed */
-	int	i;
-	int	rv;
-	int	j;
-
-	if (!sensor->name || !sensor->impl || !sensor->usage_id || !sensor->id)
-		return	-EINVAL;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_add_tail(&sensor->link, &senscol_sensors_list);
-	spin_unlock_irqrestore(&senscol_lock, flags);
-
-	/*
-	 * Create sysfs entries for this sensor
-	 */
-
-	/* Init and add sensor_def kobject */
-	snprintf(sensor_name, sizeof(sensor_name), "sensor_%X_def", sensor->id);
-	rv = kobject_init_and_add(&sensor->kobj, &sc_sensdef_kobj_type,
-		&sc_pdev->dev.kobj, sensor_name);
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): kobject_init_and_add() for 'data' returned %d\n",
-		__func__, rv);
-	if (rv) {
-		rv = -EFAULT;
-err_ret:
-		kobject_put(&sensor->kobj);
-		kobject_del(&sensor->kobj);
-		return	rv;
-	}
-
-/*
- * Special attribute "friendly_name" is retired in favor
- * of generic property "property_friendly_name"
- */
-#if 0
-	/* If freiendly_name is given, add such attribute */
-	memset(&attr, 0, sizeof(struct attribute));
-	attr.name = "friendly_name";
-	attr.mode = S_IRUGO;
-	rv = sysfs_create_file(&sensor->kobj, &attr);
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): sysfs_create_file() for 'friendly_name' returned %d\n",
-		__func__, rv);
-#endif
-
-	/*
-	 * Create kobjects without attributes for
-	 * sensor_<NN>_def/data_fields and sensor_<NN>/properties
-	 */
-	rv = kobject_init_and_add(&sensor->data_fields_kobj,
-		&sc_subdir_kobj_type, &sensor->kobj, "data_fields");
-	if (rv) {
-		rv = -EFAULT;
-err_ret2:
-		kobject_put(&sensor->data_fields_kobj);
-		kobject_del(&sensor->data_fields_kobj);
-		goto	err_ret;
-	}
-
-	rv = kobject_init_and_add(&sensor->props_kobj, &sc_subdir_kobj_type,
-		&sensor->kobj, "properties");
-	if (rv) {
-		rv = -EFAULT;
-err_ret3:
-		kobject_put(&sensor->props_kobj);
-		kobject_del(&sensor->props_kobj);
-		goto	err_ret2;
-	}
-
-	/*
-	 * Create kobjects for data_fields
-	 */
-	for (i = 0; i < sensor->num_data_fields; ++i)
-		if (sensor->data_fields[i].name)
-			for (j = i-1; j >= 0; --j)	/*use index as a temp
-							variable*/
-				if (sensor->data_fields[j].name &&
-					!strcmp(sensor->data_fields[i].name,
-						sensor->data_fields[j].name)) {
-					if (!sensor->data_fields[j].index)
-						sensor->data_fields[j].index++;
-					sensor->data_fields[i].index =
-						sensor->data_fields[j].index
-									+ 1;
-					break;
-				}
-
-	for (i = 0; i < sensor->num_data_fields; ++i) {
-		if (sensor->data_fields[i].name) {
-			if (sensor->data_fields[i].index) {
-				char *p = kasprintf(GFP_KERNEL, "%s#%d",
-					sensor->data_fields[i].name,
-					sensor->data_fields[i].index-1);
-				kfree(sensor->data_fields[i].name);
-				sensor->data_fields[i].name = p;
-			}
-
-			/* Mark index */
-			sensor->data_fields[i].index = i;
-
-			rv = kobject_init_and_add(&sensor->data_fields[i].kobj,
-				&sc_datafield_kobj_type,
-				&sensor->data_fields_kobj,
-				sensor->data_fields[i].name);
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): kobject_init_and_add() for data_field '%s' returned %d\n",
-				__func__, sensor->data_fields[i].name, rv);
-		}
-	}
-	ISH_DBG_PRINT(KERN_ALERT "%s(): sample_size=%u\n",
-		__func__, sensor->sample_size);
-
-	/*
-	 * Create kobjects for properties
-	 */
-	for (i = 0; i < sensor->num_properties; ++i) {
-		if (sensor->properties[i].name) {
-			rv = kobject_init_and_add(&sensor->properties[i].kobj,
-				&sc_sensprop_kobj_type, &sensor->props_kobj,
-				sensor->properties[i].name);
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): kobject_init_and_add() for property '%s' returned %d\n",
-				__func__, sensor->properties[i].name, rv);
-		}
-	}
-
-	/* Sample size should be set by the caller to size of raw data */
-	sensor->sample_size += offsetof(struct senscol_sample, data);
-
-	return	0;
-}
-EXPORT_SYMBOL(add_senscol_sensor);
-
-struct sensor_def	*get_senscol_sensor_by_name(const char *name)
-{
-	struct sensor_def	*sens, *next;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (!strcmp(sens->name, name)) {
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			return	sens;
-		}
-	}
-
-	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	NULL;
-}
-EXPORT_SYMBOL(get_senscol_sensor_by_name);
-
-struct sensor_def	*get_senscol_sensor_by_id(uint32_t id)
-{
-	struct sensor_def	*sens, *next;
-	unsigned long	flags;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (sens->id == id) {
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			return	sens;
-		}
-	}
-
-	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	NULL;
-}
-EXPORT_SYMBOL(get_senscol_sensor_by_id);
-
-/* Add data field to existing sensor */
-int	add_data_field(struct sensor_def *sensor, struct data_field *data)
-{
-	struct data_field	*temp;
-
-	temp = krealloc(sensor->data_fields,
-		(sensor->num_data_fields + 1) * sizeof(struct data_field),
-		GFP_KERNEL);
-	if (!temp)
-		return	-ENOMEM;
-
-	data->sensor = sensor;
-	memcpy(&temp[sensor->num_data_fields++], data,
-		sizeof(struct data_field));
-	sensor->data_fields = temp;
-	return	0;
-}
-EXPORT_SYMBOL(add_data_field);
-
-/* Add property to existing sensor */
-int	add_sens_property(struct sensor_def *sensor, struct sens_property *prop)
-{
-	struct sens_property	*temp;
-
-	temp = krealloc(sensor->properties,
-		(sensor->num_properties + 1) * sizeof(struct sens_property),
-		GFP_KERNEL);
-	if (!temp)
-		return	-ENOMEM;
-
-	prop->sensor = sensor;		/* The needed backlink */
-	memcpy(&temp[sensor->num_properties++], prop,
-		sizeof(struct sens_property));
-	sensor->properties = temp;
-	return	0;
-}
-EXPORT_SYMBOL(add_sens_property);
-
-/*
- * Push data sample in upstream buffer towards user-mode.
- * Sample's size is determined from the structure
- *
- * Samples are queued is a simple FIFO binary buffer with head and tail
- * pointers.
- * Additional fields if wanted to be communicated to user mode can be defined
- *
- * Returns 0 on success, negative error code on error
- */
-int	push_sample(uint32_t id, void *sample)
-{
-	struct sensor_def	*sensor;
-	unsigned long flags;
-	unsigned char	sample_buf[1024];
-	struct senscol_sample	*p_sample = (struct senscol_sample *)sample_buf;
-	struct sensor_def pseudo_event_sensor;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	g_ish_print_log("%s() DATA from sensor #%x\n", __func__, id);
-
-	if (!senscol_data_buf)
-		return	-ENOMEM;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): senscol_data_buf=%p\n",
-		__func__, senscol_data_buf);
-
-	if (id & PSEUSO_EVENT_BIT) {
-		pseudo_event_sensor.sample_size = sizeof(uint32_t) +
-			offsetof(struct senscol_sample, data);
-		sensor = &pseudo_event_sensor;
-	} else
-		sensor = get_senscol_sensor_by_id(id);
-
-	if (!sensor)
-		return	-ENODEV;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): sensor=%p\n",
-		__func__, sensor);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): senscol_data_head=%u senscol_data_tail=%u sample_size=%u\n",
-		__func__, senscol_data_head, senscol_data_tail,
-		sensor->sample_size);
-
-	spin_lock_irqsave(&senscol_data_lock, flags);
-
-	/*
-	 * TBD: when buffer overflows we may choose to drop
-	 * the new data or oldest data.
-	 */
-	/* Here we drop the new data */
-	if (senscol_data_head != senscol_data_tail &&
-			(senscol_data_head - senscol_data_tail) %
-			SENSCOL_DATA_BUF_SIZE <= sensor->sample_size) {
-		spin_unlock_irqrestore(&senscol_data_lock, flags);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[senscol]: %s(): dropping sample, senscol_data_head=%u senscol_data_tail=%u sample size=%u\n",
-			__func__, senscol_data_head, senscol_data_tail,
-			sensor->sample_size);
-		return	-ENOMEM;
-	}
-
-	p_sample->id = id;
-	p_sample->size = sensor->sample_size;
-	memcpy(p_sample->data, sample,
-		sensor->sample_size - offsetof(struct senscol_sample, data));
-
-	memcpy(senscol_data_buf + senscol_data_tail, p_sample, p_sample->size);
-	senscol_data_tail += sensor->sample_size;
-	if (senscol_data_tail > SENSCOL_DATA_BUF_LAST)
-		senscol_data_tail = 0;
-
-	spin_unlock_irqrestore(&senscol_data_lock, flags);
-
-	/* Fire event through "data/event" */
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol] %s(): firing data-ready event senscol_data_head=%u senscol_data_tail=%u id=%08X sample_size=%u\n",
-		__func__, senscol_data_head, senscol_data_tail, p_sample->id,
-		sensor->sample_size);
-
-	if (waitqueue_active(&senscol_read_wait))
-		wake_up_interruptible(&senscol_read_wait);
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():--- 0\n", __func__);
-	return	0;
-}
-EXPORT_SYMBOL(push_sample);
-
-
-static int senscol_open(struct inode *inode, struct file *file)
-{
-	user_task = current;
-	return	0;
-}
-
-static int senscol_release(struct inode *inode, struct file *file)
-{
-	return	0;
-}
-
-static ssize_t senscol_read(struct file *file, char __user *ubuf,
-	size_t length, loff_t *offset)
-{
-	return	length;
-}
-
-static ssize_t senscol_write(struct file *file, const char __user *ubuf,
-	size_t length, loff_t *offset)
-{
-	return	length;
-}
-
-static long senscol_ioctl(struct file *file, unsigned int cmd,
-	unsigned long data)
-{
-	return	0;
-}
-
-static unsigned int senscol_poll(struct file *file, poll_table *wait)
-{
-	unsigned int mask = 0;
-	unsigned long   flags;
-	int	rd_ready = 0;
-
-	poll_wait(file, &senscol_read_wait, wait);
-
-	/* If read buffer is empty, wait again on senscol_read_wait */
-
-	spin_lock_irqsave(&senscol_data_lock, flags);
-	rd_ready = (senscol_data_head != senscol_data_tail);
-	spin_unlock_irqrestore(&senscol_data_lock, flags);
-
-	if (rd_ready)
-		mask |= (POLLIN | POLLRDNORM);
-	/*mask |= DEFAULT_POLLMASK|POLLERR|POLLPRI;*/
-	return	mask;
-}
-
-/* flush callback */
-void senscol_flush_cb(void)
-{
-	struct sensor_def	*sens, *next;
-	unsigned long   flags;
-	uint32_t pseudo_event_id;
-	uint32_t pseudo_event_content = 0;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	if (!flush_asked) {
-		spin_unlock_irqrestore(&senscol_lock, flags);
-		return;
-	}
-
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (sens->flush_req) {
-			sens->flush_req = 0;
-			pseudo_event_id = sens->id | PSEUSO_EVENT_BIT;
-			pseudo_event_content |= FLUSH_CMPL_BIT;
-
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			push_sample(pseudo_event_id, &pseudo_event_content);
-			spin_lock_irqsave(&senscol_lock, flags);
-		}
-	}
-	flush_asked = 0;
-	spin_unlock_irqrestore(&senscol_lock, flags);
-	return;
-}
-
-
-/*
- * file operations structure will be used for heci char device.
- */
-static const struct file_operations senscol_fops = {
-	.owner = THIS_MODULE,
-	.read = senscol_read,
-	.unlocked_ioctl = senscol_ioctl,
-	.open = senscol_open,
-	.release = senscol_release,
-	.write = senscol_write,
-	.poll = senscol_poll,
-	.llseek = no_llseek
-};
-
-/*
- * Misc Device Struct
- */
-static struct miscdevice  senscol_misc_device = {
-		.name = "sensor-collection",
-		.fops = &senscol_fops,
-		.minor = MISC_DYNAMIC_MINOR,
-};
-
-
-static int __init senscol_init(void)
-{
-	int	rv;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-
-	INIT_LIST_HEAD(&senscol_impl_list);
-	INIT_LIST_HEAD(&senscol_sensors_list);
-	spin_lock_init(&senscol_lock);
-	spin_lock_init(&senscol_data_lock);
-	init_waitqueue_head(&senscol_read_wait);
-
-	/* Init data buffer */
-	senscol_data_buf = kmalloc(SENSCOL_DATA_BUF_SIZE, GFP_KERNEL);
-	if (!senscol_data_buf)
-		return	-ENOMEM;
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol] %s(): allocated senscol_data_buf of size %u\n",
-		__func__, SENSCOL_DATA_BUF_SIZE);
-
-	senscol_data_head = 0;
-	senscol_data_tail = 0;
-
-	/* Create sensor_collection platform device and default sysfs entries */
-	sc_pdev = platform_device_register_simple("sensor_collection", -1,
-		NULL, 0);
-	if (IS_ERR(sc_pdev)) {
-		ISH_DBG_PRINT(KERN_ERR
-			"%s(): failed to create platform device sensor_collection\n",
-			__func__);
-		kfree(senscol_data_buf);
-		return	-ENODEV;
-	}
-
-	senscol_misc_device.parent = &sc_pdev->dev;
-	rv = misc_register(&senscol_misc_device);
-	if (rv)
-		return	rv;
-
-	rv = kobject_init_and_add(&sc_data_kobj, &sc_data_kobj_type,
-		&sc_pdev->dev.kobj, "data");
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): kobject_init_and_add() for 'data' returned %d\n",
-		__func__, rv);
-
-	rv = sysfs_create_bin_file(&sc_data_kobj, &sensors_data_binattr);
-	if (rv)
-		ISH_DBG_PRINT(KERN_ERR
-			"%s(): sysfs_create_bin_file() for 'sensors_data' returned %d\n",
-			__func__, rv);
-
-	register_flush_cb(senscol_flush_cb);
-
-	return	0;
-}
-
-static void __exit senscol_exit(void)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	kfree(senscol_data_buf);
-}
-
-
-module_init(senscol_init);
-module_exit(senscol_exit);
-
-MODULE_DESCRIPTION("Sensor Collection framework core");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/misc/heci/utils.h b/drivers/misc/heci/utils.h
deleted file mode 100644
index 04b814e..0000000
--- a/drivers/misc/heci/utils.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Utility macros of ISS
- *
- * Copyright (c) 2014-2015, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- */
-#ifndef UTILS__H
- #define UTILS__H
-
-#define	WAIT_FOR_SEND_SLICE	(HZ / 10)
-#define	WAIT_FOR_CONNECT_SLICE	(HZ / 10)
-
-/*
- * Waits for specified event when a thread that triggers event can't signal
- * Also, waits *at_least* `timeinc` after condition is satisfied
- */
-#define	timed_wait_for(timeinc, condition) \
-	do { \
-		int completed = 0; \
-		do { \
-			unsigned long	j; \
-			int	done = 0; \
-\
-			completed = (condition); \
-			for (j = jiffies, done = 0; !done; ) { \
-				schedule_timeout(timeinc); \
-				if (time_is_before_eq_jiffies(j + timeinc)) \
-					done = 1; \
-			} \
-		} while (!(completed)); \
-	} while (0)
-
-
-/*
- * Waits for specified event when a thread that triggers event
- * can't signal with timeout (use whenever we may hang)
- */
-#define	timed_wait_for_timeout(timeinc, condition, timeout) \
-	do { \
-		int	t = timeout; \
-		do { \
-			unsigned long	j; \
-			int	done = 0; \
-\
-			for (j = jiffies, done = 0; !done; ) { \
-				schedule_timeout(timeinc); \
-				if (time_is_before_eq_jiffies(j + timeinc)) \
-					done = 1; \
-			} \
-			t -= timeinc; \
-			if (t <= 0) \
-				break; \
-		} while (!(condition)); \
-	} while (0)
-
-#endif /* UTILS__H */
-
diff --git a/drivers/misc/intel-ish/Kconfig b/drivers/misc/intel-ish/Kconfig
new file mode 100644
index 0000000..e19c2b7
--- /dev/null
+++ b/drivers/misc/intel-ish/Kconfig
@@ -0,0 +1,26 @@
+config INTEL_ISH
+	tristate "Intel Integrated Sensors Solution"
+	depends on X86 && PCI
+	help
+	  ISS enabled sensors hub functionality on SoC/chipset level.
+	  Placeholder for description line 2.
+	  Placeholder for description line 3.
+	  Placeholder for description line 4.
+
+config ISH_PATH_SENSCOL
+	tristate "ISS path through sensor-collection"
+	depends on INTEL_ISH
+	help
+	  Enables sensor-collection path for ISH
+	  Placeholder for description line 2.
+	  Placeholder for description line 3.
+	  Placeholder for description line 4.
+
+config ISH_PATH_IIO
+	tristate "ISS path through IIO"
+	depends on INTEL_ISH
+	help
+	  Enables IIO path for ISH
+	  Placeholder for description line 2.
+	  Placeholder for description line 3.
+	  Placeholder for description line 4.
diff --git a/drivers/misc/intel-ish/Makefile b/drivers/misc/intel-ish/Makefile
new file mode 100644
index 0000000..79076bd
--- /dev/null
+++ b/drivers/misc/intel-ish/Makefile
@@ -0,0 +1,26 @@
+#
+# Makefile - Intel HECI and ISS implementation
+# Copyright (c) 2010-2015, Intel Corporation.
+#
+obj-$(CONFIG_INTEL_ISH) += heci.o
+heci-objs := init.o
+heci-objs += hbm.o
+heci-objs += client.o
+heci-objs += heci-api.o
+heci-objs += bus.o
+heci-$(CONFIG_DEBUG_FS) += debugfs.o
+
+obj-$(CONFIG_INTEL_ISH) += heci-ish.o
+heci-ish-objs := hw-ish.o
+heci-ish-objs += pci-ish.o
+
+obj-$(CONFIG_INTEL_ISH) += hid-heci-ish.o
+hid-heci-ish-objs := heci-hid.o
+hid-heci-ish-objs += heci-hid-client.o
+
+obj-$(CONFIG_INTEL_ISH) += ish-hid-drv.o
+ish-hid-drv-objs := ish-hid-dd.o
+
+obj-$(CONFIG_INTEL_ISH) += sens-col-core.o
+sens-col-core-objs := senscol-core.o
+
diff --git a/drivers/misc/intel-ish/bus.c b/drivers/misc/intel-ish/bus.c
new file mode 100644
index 0000000..7c32a95
--- /dev/null
+++ b/drivers/misc/intel-ish/bus.c
@@ -0,0 +1,691 @@
+/*
+ * HECI bus driver
+ *
+ * Copyright (c) 2012-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include "bus.h"
+#include "heci_dev.h"
+#include "client.h"
+#include <asm/page.h>
+#include "hbm.h"
+#include "utils.h"
+
+#define to_heci_cl_driver(d) container_of(d, struct heci_cl_driver, driver)
+#define to_heci_cl_device(d) container_of(d, struct heci_cl_device, dev)
+
+/**
+ * heci_me_cl_by_uuid - locate index of me client
+ *
+ * @dev: heci device
+ * returns me client index or -ENOENT if not found
+ */
+int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *uuid)
+{
+	int i, res = -ENOENT;
+	unsigned long	flags;
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
+	for (i = 0; i < dev->me_clients_num; ++i) {
+		if (uuid_le_cmp(*uuid, dev->me_clients[i].props.protocol_name)
+				== 0) {
+			res = i;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	return res;
+}
+EXPORT_SYMBOL(heci_me_cl_by_uuid);
+
+
+/**
+ * heci_me_cl_by_id return index to me_clients for client_id
+ *
+ * @dev: the device structure
+ * @client_id: me client id
+ *
+ * returns index on success, -ENOENT on failure.
+ */
+
+int heci_me_cl_by_id(struct heci_device *dev, u8 client_id)
+{
+	int i;
+	unsigned long	flags;
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
+	for (i = 0; i < dev->me_clients_num; i++)
+		if (dev->me_clients[i].client_id == client_id)
+			break;
+	if (WARN_ON(dev->me_clients[i].client_id != client_id)) {
+		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+		return -ENOENT;
+	}
+
+	if (i == dev->me_clients_num) {
+		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+		return -ENOENT;
+	}
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	return i;
+}
+
+static int heci_cl_device_match(struct device *dev, struct device_driver *drv)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ returns 1\n", __func__);
+
+	/*
+	 * DD -- return true and let driver's probe() routine decide.
+	 * If this solution lives up, we can rearrange it
+	 * by simply removing match() routine at all
+	 */
+	return	1;
+}
+
+static int heci_cl_device_probe(struct device *dev)
+{
+	struct heci_cl_device *device = to_heci_cl_device(dev);
+	struct heci_cl_driver *driver;
+	struct heci_cl_device_id id;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (!device)
+		return 0;
+
+	/* in many cases here will be NULL */
+	driver = to_heci_cl_driver(dev->driver);
+	if (!driver || !driver->probe)
+		return -ENODEV;
+
+	dev_dbg(dev, "Device probe\n");
+
+	strncpy(id.name, dev_name(dev), HECI_CL_NAME_SIZE-1);
+	id.name[HECI_CL_NAME_SIZE-1] = '\0';
+
+	return driver->probe(device, &id);
+}
+
+static int heci_cl_device_remove(struct device *dev)
+{
+	struct heci_cl_device *device = to_heci_cl_device(dev);
+	struct heci_cl_driver *driver;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (!device || !dev->driver)
+		return 0;
+
+	if (device->event_cb) {
+		device->event_cb = NULL;
+		cancel_work_sync(&device->event_work);
+	}
+
+	driver = to_heci_cl_driver(dev->driver);
+	if (!driver->remove) {
+		dev->driver = NULL;
+
+		return 0;
+	}
+
+	return driver->remove(device);
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+	char *buf)
+{
+	int len;
+
+	len = snprintf(buf, PAGE_SIZE, "heci:%s\n", dev_name(dev));
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute heci_cl_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+static int heci_cl_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	if (add_uevent_var(env, "MODALIAS=heci:%s", dev_name(dev)))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static struct bus_type heci_cl_bus_type = {
+	.name		= "heci",
+	.dev_attrs	= heci_cl_dev_attrs,
+	.match		= heci_cl_device_match,
+	.probe		= heci_cl_device_probe,
+	.remove		= heci_cl_device_remove,
+	.uevent		= heci_cl_uevent,
+};
+
+static void heci_cl_dev_release(struct device *dev)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
+	kfree(to_heci_cl_device(dev));
+	ISH_DBG_PRINT(KERN_ALERT "%s():---\n", __func__);
+}
+
+static struct device_type heci_cl_device_type = {
+	.release	= heci_cl_dev_release,
+};
+
+/*
+ * Allocate HECI bus client device, attach it to uuid and register with HECI bus
+ */
+struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
+	uuid_le uuid, char *name, struct heci_cl_dev_ops *ops)
+{
+	struct heci_cl_device *device;
+	int status;
+	unsigned long flags;
+
+	device = kzalloc(sizeof(struct heci_cl_device), GFP_ATOMIC);
+	if (!device)
+		return NULL;
+
+	device->ops = ops;
+
+	device->dev.parent = &dev->pdev->dev;
+	device->dev.bus = &heci_cl_bus_type;
+	device->dev.type = &heci_cl_device_type;
+	device->heci_dev = dev;
+
+	/* no need for spin lock here, the caller locked me_clients_lock */
+	device->fw_client =
+		&dev->me_clients[dev->me_client_presentation_num - 1];
+
+	dev_set_name(&device->dev, "%s", name);
+
+	spin_lock_irqsave(&dev->device_list_lock, flags);
+	list_add_tail(&device->device_link, &dev->device_list);
+	spin_unlock_irqrestore(&dev->device_list_lock, flags);
+
+	status = device_register(&device->dev);
+	if (status) {
+		spin_lock_irqsave(&dev->device_list_lock, flags);
+		list_del(&device->device_link);
+		spin_unlock_irqrestore(&dev->device_list_lock, flags);
+		dev_err(&dev->pdev->dev, "Failed to register HECI device\n");
+		kfree(device);
+		return NULL;
+	}
+
+	dev_dbg(&device->dev, "client %s registered\n", name);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): Registered HECI device\n", __func__);
+
+	return device;
+}
+EXPORT_SYMBOL_GPL(heci_bus_add_device);
+
+
+/*
+ * This is a counterpart of heci_bus_add_device.
+ * Device is unregistered and its structure is also freed
+ */
+void heci_bus_remove_device(struct heci_cl_device *device)
+{
+	device_unregister(&device->dev);
+	/*kfree(device);*/
+}
+EXPORT_SYMBOL_GPL(heci_bus_remove_device);
+
+
+/*
+ * Part of reset flow
+ */
+void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
+{
+	struct heci_cl_device	*cl_device, *next_device;
+	struct heci_cl	*cl, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&heci_dev->cl_list_lock, flags);
+	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
+/*		list_del(&cl->link);*/
+		cl->state = HECI_CL_DISCONNECTED;
+
+		/*
+		 * Wake any pending process. The waiter would check dev->state
+		 * and determine that it's not enabled already,
+		 * and will return error to its caller
+		 */
+		if (waitqueue_active(&cl->rx_wait))
+			wake_up_interruptible(&cl->rx_wait);
+		if (waitqueue_active(&cl->wait_ctrl_res))
+			wake_up(&cl->wait_ctrl_res);
+
+		/* Disband any pending read/write requests and free RB */
+		heci_cl_flush_queues(cl);
+
+		/* Remove read_rb for user-mode API clients */
+		if (cl->read_rb) {
+			struct heci_cl_rb *rb = NULL;
+
+			rb = heci_cl_find_read_rb(cl);
+			/* Remove entry from read list */
+			if (rb)
+				list_del(&rb->list);
+
+			rb = cl->read_rb;
+			cl->read_rb = NULL;
+
+			if (rb) {
+				heci_io_rb_free(rb);
+				rb = NULL;
+			}
+		}
+
+		/* Remove all free and in_process rings, both Rx and Tx */
+		heci_cl_free_rx_ring(cl);
+		heci_cl_free_tx_ring(cl);
+
+		/* Free client and HECI bus client device structures */
+		/* don't free host client because it is part of the OS fd
+		   structure */
+	}
+	spin_unlock_irqrestore(&heci_dev->cl_list_lock, flags);
+
+	/* remove bus clients */
+	spin_lock_irqsave(&heci_dev->device_list_lock, flags);
+	list_for_each_entry_safe(cl_device, next_device,
+		&heci_dev->device_list, device_link) {
+			list_del(&cl_device->device_link);
+			spin_unlock_irqrestore(&heci_dev->device_list_lock,
+				flags);
+			heci_bus_remove_device(cl_device);
+			spin_lock_irqsave(&heci_dev->device_list_lock, flags);
+		}
+	spin_unlock_irqrestore(&heci_dev->device_list_lock, flags);
+
+	/* Free all client structures */
+	spin_lock_irqsave(&heci_dev->me_clients_lock, flags);
+	kfree(heci_dev->me_clients);
+	heci_dev->me_clients = NULL;
+	heci_dev->me_clients_num = 0;
+	heci_dev->me_client_presentation_num  = 0;
+	heci_dev->me_client_index = 0;
+	bitmap_zero(heci_dev->me_clients_map, HECI_CLIENTS_MAX);
+/*
+	bitmap_zero(heci_dev->host_clients_map, HECI_CLIENTS_MAX);
+	bitmap_set(heci_dev->host_clients_map, 0, 3);
+*/
+	spin_unlock_irqrestore(&heci_dev->me_clients_lock, flags);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+}
+EXPORT_SYMBOL_GPL(heci_bus_remove_all_clients);
+
+
+int __heci_cl_driver_register(struct heci_cl_driver *driver,
+	struct module *owner)
+{
+	int err;
+
+	driver->driver.name = driver->name;
+	driver->driver.owner = owner;
+	driver->driver.bus = &heci_cl_bus_type;
+
+	err = driver_register(&driver->driver);
+	if (err)
+		return err;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): heci: driver [%s] registered\n",
+		__func__, driver->driver.name);
+	pr_debug("heci: driver [%s] registered\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(__heci_cl_driver_register);
+
+void heci_cl_driver_unregister(struct heci_cl_driver *driver)
+{
+	driver_unregister(&driver->driver);
+
+	pr_debug("heci: driver [%s] unregistered\n", driver->driver.name);
+}
+EXPORT_SYMBOL_GPL(heci_cl_driver_unregister);
+
+
+static void heci_bus_event_work(struct work_struct *work)
+{
+	struct heci_cl_device *device;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	device = container_of(work, struct heci_cl_device, event_work);
+
+	if (device->event_cb)
+		device->event_cb(device, device->events, device->event_context);
+
+	/*device->events = 0;*/
+}
+
+int heci_register_event_cb(struct heci_cl_device *device,
+	void (*event_cb)(struct heci_cl_device *, u32, void *), void *context)
+{
+	if (device->event_cb)
+		return -EALREADY;
+
+	/*device->events = 0;*/
+	device->event_cb = event_cb;
+	device->event_context = context;
+	INIT_WORK(&device->event_work, heci_bus_event_work);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(heci_register_event_cb);
+
+void *heci_cl_get_drvdata(const struct heci_cl_device *device)
+{
+	return dev_get_drvdata(&device->dev);
+}
+EXPORT_SYMBOL_GPL(heci_cl_get_drvdata);
+
+void heci_cl_set_drvdata(struct heci_cl_device *device, void *data)
+{
+	dev_set_drvdata(&device->dev, data);
+}
+EXPORT_SYMBOL_GPL(heci_cl_set_drvdata);
+
+/* What's this? */
+int heci_cl_enable_device(struct heci_cl_device *device)
+{
+	if (!device->ops || !device->ops->enable)
+		return 0;
+
+	return device->ops->enable(device);
+}
+EXPORT_SYMBOL_GPL(heci_cl_enable_device);
+
+int heci_cl_disable_device(struct heci_cl_device *device)
+{
+	if (!device->ops || !device->ops->disable)
+		return 0;
+
+	return device->ops->disable(device);
+}
+EXPORT_SYMBOL_GPL(heci_cl_disable_device);
+/************************/
+
+void heci_cl_bus_rx_event(struct heci_cl_device *device)
+{
+	static int	rx_count;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ [%d]\n", __func__, rx_count++);
+	if (!device || !device->event_cb)
+		return;
+
+	set_bit(HECI_CL_EVENT_RX, &device->events);
+
+	if (device->event_cb)
+		schedule_work(&device->event_work);
+}
+
+int __init heci_cl_bus_init(void)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): Registering HECI bus\n", __func__);
+	rv = bus_register(&heci_cl_bus_type);
+	if (!rv)
+		heci_cl_alloc_dma_buf();
+	return	rv;
+}
+
+void __exit heci_cl_bus_exit(void)
+{
+ISH_DBG_PRINT(KERN_ALERT "%s(): Unregistering HECI bus\n", __func__);
+	bus_unregister(&heci_cl_bus_type);
+}
+
+
+ssize_t cl_prop_read(struct device *dev, struct device_attribute *dev_attr,
+	char *buf)
+{
+	ssize_t	rv = -EINVAL;
+	struct heci_cl_device	*cl_device = to_heci_cl_device(dev);
+	unsigned long	flags;
+
+	if (!strcmp(dev_attr->attr.name, "max_msg_length")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)cl_device->fw_client->props.max_msg_length);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "protocol_version")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)cl_device->fw_client->props.protocol_version);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "max_number_of_connections")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+(unsigned)cl_device->fw_client->props.max_number_of_connections);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "fixed_address")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)cl_device->fw_client->props.fixed_address);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "single_recv_buf")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)cl_device->fw_client->props.single_recv_buf);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "dma_hdr_len")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)cl_device->fw_client->props.dma_hdr_len);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "num_active_connections")) {
+		struct heci_cl	*cl, *next;
+		unsigned	count = 0;
+
+		spin_lock_irqsave(&cl_device->heci_dev->cl_list_lock, flags);
+		list_for_each_entry_safe(cl, next,
+				&cl_device->heci_dev->cl_list, link) {
+			if (cl->state == HECI_CL_CONNECTED &&
+					cl->device == cl_device)
+				++count;
+		}
+		spin_unlock_irqrestore(&cl_device->heci_dev->cl_list_lock,
+			flags);
+
+		scnprintf(buf, PAGE_SIZE, "%u\n", count);
+		rv = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name,  "client_id")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)cl_device->fw_client->client_id);
+		rv = strlen(buf);
+	}
+
+	return	rv;
+}
+
+ssize_t	cl_prop_write(struct device *dev, struct device_attribute *dev_attr,
+	const char *buf, size_t count)
+{
+	return	-EINVAL;
+}
+
+static struct device_attribute	max_msg_length = {
+	.attr = {
+		.name = "max_msg_length",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	protocol_version = {
+	.attr = {
+		.name = "protocol_version",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	max_number_of_connections = {
+	.attr = {
+		.name = "max_number_of_connections",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	fixed_address = {
+	.attr = {
+		.name = "fixed_address",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	single_recv_buf = {
+	.attr = {
+		.name = "single_recv_buf",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	dma_hdr_len = {
+	.attr = {
+		.name = "dma_hdr_len",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	num_active_connections = {
+	.attr = {
+		.name = "num_active_connections",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+static struct device_attribute	client_id = {
+	.attr = {
+		.name = "client_id",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = cl_prop_read,
+	.store = cl_prop_write
+};
+
+/*
+ * Enum-completion callback for HECI bus - heci_device has reported its clients
+ */
+int	heci_bus_new_client(struct heci_device *dev)
+{
+	int	i;
+	char	*dev_name;
+	struct heci_cl_device	*cl_device;
+	uuid_le	device_uuid;
+
+	/*
+	 * For all reported clients, create an unconnected client and add its
+	 * device to HECI bus.
+	 * If appropriate driver has loaded, this will trigger its probe().
+	 * Otherwise, probe() will be called when driver is loaded
+	 */
+	/* no need for spinlock here - the caller locked me_clients_lock */
+
+	i = dev->me_client_presentation_num - 1;
+	device_uuid = dev->me_clients[i].props.protocol_name;
+	dev_name = kasprintf(GFP_ATOMIC,
+		"{%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
+		device_uuid.b[3], device_uuid.b[2], device_uuid.b[1],
+		device_uuid.b[0], device_uuid.b[5], device_uuid.b[4],
+		device_uuid.b[7], device_uuid.b[6], device_uuid.b[8],
+		device_uuid.b[9], device_uuid.b[10], device_uuid.b[11],
+		device_uuid.b[12], device_uuid.b[13], device_uuid.b[14],
+		device_uuid.b[15]);
+	if (!dev_name)
+		return	-ENOMEM;
+
+	cl_device = heci_bus_add_device(dev, device_uuid, dev_name, NULL);
+	if (!cl_device) {
+		kfree(dev_name);
+		return	-ENOENT;
+	}
+
+	/* Export several properties per client device */
+	device_create_file(&cl_device->dev, &max_msg_length);
+	device_create_file(&cl_device->dev, &protocol_version);
+	device_create_file(&cl_device->dev, &max_number_of_connections);
+	device_create_file(&cl_device->dev, &fixed_address);
+	device_create_file(&cl_device->dev, &single_recv_buf);
+	device_create_file(&cl_device->dev, &dma_hdr_len);
+	device_create_file(&cl_device->dev, &num_active_connections);
+	device_create_file(&cl_device->dev, &client_id);
+	kfree(dev_name);
+
+	return	0;
+}
+
+
+static int	does_driver_bind_uuid(struct device *dev, void *id)
+{
+	uuid_le	*uuid = id;
+	struct heci_cl_device	*device;
+
+	if (!dev->driver)
+		return	0;
+
+	device = to_heci_cl_device(dev);
+	if (!uuid_le_cmp(device->fw_client->props.protocol_name, *uuid))
+		return	1;
+
+	return	0;
+}
+
+
+int	heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid)
+{
+	int	rv;
+
+	rv = bus_for_each_dev(&heci_cl_bus_type, NULL, uuid,
+		does_driver_bind_uuid);
+	return	!rv;
+}
+
+
+/* Binds connected heci_cl to HECI bus device */
+int	heci_cl_device_bind(struct heci_cl *cl)
+{
+	int	rv;
+	struct heci_cl_device	*cl_device, *next;
+	unsigned long flags;
+	if (!cl->me_client_id || cl->state != HECI_CL_CONNECTED)
+		return	-EFAULT;
+
+	rv = -ENOENT;
+	spin_lock_irqsave(&cl->dev->device_list_lock, flags);
+	list_for_each_entry_safe(cl_device, next, &cl->dev->device_list,
+			device_link) {
+		if (cl_device->fw_client->client_id == cl->me_client_id) {
+			cl->device = cl_device;
+			rv = 0;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&cl->dev->device_list_lock, flags);
+	return	rv;
+}
+
diff --git a/drivers/misc/intel-ish/bus.h b/drivers/misc/intel-ish/bus.h
new file mode 100644
index 0000000..2a39ec7
--- /dev/null
+++ b/drivers/misc/intel-ish/bus.h
@@ -0,0 +1,125 @@
+/*
+ * HECI bus definitions
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#ifndef _LINUX_HECI_CL_BUS_H
+#define _LINUX_HECI_CL_BUS_H
+
+#include <linux/device.h>
+#include <linux/uuid.h>
+
+/*typedef void (*heci_cl_event_cb_t)(struct heci_cl_device *device, u32 events,
+	void *context);*/
+
+struct heci_cl;
+struct heci_cl_device;
+struct heci_device;
+
+#define	HECI_CL_NAME_SIZE	32
+
+struct heci_cl_device_id {
+	char name[MEI_CL_NAME_SIZE];
+	kernel_ulong_t driver_info;
+};
+
+/**
+ * struct heci_cl_dev_ops - HECI CL device ops
+ * This structure allows ME host clients to implement technology
+ * specific operations.
+ *
+ * @enable: Enable an HECI CL device. Some devices require specific
+ *	HECI commands to initialize completely.
+ * @disable: Disable an HECI CL device.
+ * @send: Tx hook for the device. This allows ME host clients to trap
+ *	the device driver buffers before actually physically
+ *	pushing it to the ME.
+ * @recv: Rx hook for the device. This allows ME host clients to trap the
+ *	ME buffers before forwarding them to the device driver.
+ */
+struct heci_cl_dev_ops {
+	int (*enable)(struct heci_cl_device *device);
+	int (*disable)(struct heci_cl_device *device);
+	int (*send)(struct heci_cl_device *device, u8 *buf, size_t length);
+	int (*recv)(struct heci_cl_device *device, u8 *buf, size_t length);
+};
+
+struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
+	uuid_le uuid, char *name, struct heci_cl_dev_ops *ops);
+void heci_bus_remove_device(struct heci_cl_device *device);
+
+/**
+ * struct heci_cl_device - HECI device handle
+ * An heci_cl_device pointer is returned from heci_add_device()
+ * and links HECI bus clients to their actual ME host client pointer.
+ * Drivers for HECI devices will get an heci_cl_device pointer
+ * when being probed and shall use it for doing ME bus I/O.
+ *
+ * @dev: linux driver model device pointer
+ * @uuid: me client uuid
+ * @cl: heci client
+ * @ops: ME transport ops
+ * @event_cb: Drivers register this callback to get asynchronous ME
+ *	events (e.g. Rx buffer pending) notifications.
+ * @events: Events bitmask sent to the driver.
+ * @priv_data: client private data
+ */
+struct heci_cl_device {
+	struct device dev;
+	/*struct heci_cl *cl;*/
+	struct heci_device	*heci_dev;
+	struct heci_me_client	*fw_client;	/* For easy reference */
+	struct list_head	device_link;
+	const struct heci_cl_dev_ops *ops;
+	struct work_struct event_work;
+	void (*event_cb)(struct heci_cl_device *device, u32 events,
+		void *context);
+	void *event_context;
+	unsigned long events;
+	void *priv_data;
+};
+
+struct heci_cl_driver {
+	struct device_driver driver;
+	const char *name;
+	const struct heci_cl_device_id *id_table;
+	int (*probe)(struct heci_cl_device *dev,
+		const struct heci_cl_device_id *id);
+	int (*remove)(struct heci_cl_device *dev);
+};
+
+int __heci_cl_driver_register(struct heci_cl_driver *driver,
+	struct module *owner);
+#define heci_cl_driver_register(driver)             \
+	__heci_cl_driver_register(driver, THIS_MODULE)
+
+void heci_cl_driver_unregister(struct heci_cl_driver *driver);
+int heci_register_event_cb(struct heci_cl_device *device,
+	void (*read_cb)(struct heci_cl_device *, u32, void *), void *context);
+
+#define HECI_CL_EVENT_RX 0
+#define HECI_CL_EVENT_TX 1
+
+void *heci_cl_get_drvdata(const struct heci_cl_device *device);
+void heci_cl_set_drvdata(struct heci_cl_device *device, void *data);
+
+int heci_cl_enable_device(struct heci_cl_device *device);
+int heci_cl_disable_device(struct heci_cl_device *device);
+
+void heci_cl_bus_rx_event(struct heci_cl_device *device);
+int heci_cl_bus_init(void);
+void heci_cl_bus_exit(void);
+int	heci_bus_new_client(struct heci_device *dev);
+void	heci_remove_all_clients(struct heci_device *dev);
+int	heci_cl_device_bind(struct heci_cl *cl);
+
+#endif /* _LINUX_HECI_CL_BUS_H */
diff --git a/drivers/misc/intel-ish/client.c b/drivers/misc/intel-ish/client.c
new file mode 100644
index 0000000..b9acd6e
--- /dev/null
+++ b/drivers/misc/intel-ish/client.c
@@ -0,0 +1,1243 @@
+/*
+ * HECI client logic (for both HECI bus driver and user-mode API)
+ *
+ * Copyright (c) 2003-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include "heci_dev.h"
+#include "hbm.h"
+#include "client.h"
+#include "utils.h"
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+/* #define dev_dbg dev_err */
+
+int	host_dma_enabled;
+void	*host_dma_buf;
+unsigned	host_dma_buf_size = (1024*1024);
+uint64_t	host_dma_buf_phys;
+int	dma_ready = 1;
+
+
+void	heci_cl_alloc_dma_buf(void)
+{
+	int	order;
+	unsigned	temp;
+
+	/*
+	 * Try to allocate 256 contiguous pages (1 M)
+	 * for DMA and enabled host DMA
+	 */
+	for (order = 0, temp = host_dma_buf_size / PAGE_SIZE + 1; temp;
+			temp >>= 1)
+		++order;
+	host_dma_buf = (void *)__get_free_pages(GFP_KERNEL, order);
+	if (host_dma_buf) {
+		host_dma_buf_phys = __pa(host_dma_buf);
+		host_dma_enabled = 1;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): host_dma_enabled=%d host_dma_buf=%p host_dma_buf_phys=%llX host_dma_buf_size=%u order=%d\n",
+		__func__, host_dma_enabled, host_dma_buf, host_dma_buf_phys,
+		host_dma_buf_size, order);
+}
+
+
+/**
+ * heci_read_list_flush - removes list entry belonging to cl.
+ *
+ * @list:  An instance of our list structure
+ * @cl: host client
+ */
+void heci_read_list_flush(struct heci_cl *cl)
+{
+	struct heci_cl_rb *rb;
+	struct heci_cl_rb *next;
+
+	unsigned long	flags;
+	spin_lock_irqsave(&cl->dev->read_list_spinlock, flags);
+	list_for_each_entry_safe(rb, next, &cl->dev->read_list.list, list) {
+		if (rb->cl && heci_cl_cmp_id(cl, rb->cl)) {
+			list_del(&rb->list);
+			heci_io_rb_free(rb);
+		}
+	}
+	spin_unlock_irqrestore(&cl->dev->read_list_spinlock, flags);
+}
+
+/**
+ * heci_io_rb_free - free heci_rb_private related memory
+ *
+ * @rb: heci callback struct
+ */
+void heci_io_rb_free(struct heci_cl_rb *rb)
+{
+	if (rb == NULL)
+		return;
+
+	kfree(rb->buffer.data);
+	kfree(rb);
+}
+EXPORT_SYMBOL(heci_io_rb_free);
+
+/**
+ * heci_io_rb_init - allocate and initialize io callback
+ *
+ * @cl - heci client
+ * @file: pointer to file structure
+ *
+ * returns heci_cl_rb pointer or NULL;
+ */
+struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl)
+{
+	struct heci_cl_rb *rb;
+
+	rb = kzalloc(sizeof(struct heci_cl_rb), GFP_KERNEL);
+	if (!rb)
+		return NULL;
+
+	heci_io_list_init(rb);
+
+	rb->cl = cl;
+	rb->buf_idx = 0;
+	return rb;
+}
+
+
+/**
+ * heci_io_rb_alloc_buf - allocate respose buffer
+ *
+ * @rb -  io callback structure
+ * @size: size of the buffer
+ *
+ * returns 0 on success
+ *         -EINVAL if rb is NULL
+ *         -ENOMEM if allocation failed
+ */
+int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length)
+{
+	if (!rb)
+		return -EINVAL;
+
+	if (length == 0)
+		return 0;
+
+	rb->buffer.data = kmalloc(length, GFP_KERNEL);
+	if (!rb->buffer.data)
+		return -ENOMEM;
+	rb->buffer.size = length;
+	return 0;
+}
+
+
+/*
+ * heci_io_rb_recycle - re-append rb to its client's free list
+ * and send flow control if needed
+ */
+int heci_io_rb_recycle(struct heci_cl_rb *rb)
+{
+	struct heci_cl *cl;
+	int	rets = 0;
+	unsigned long	flags;
+
+	if (!rb || !rb->cl)
+		return	-EFAULT;
+
+	cl = rb->cl;
+
+	spin_lock_irqsave(&cl->free_list_spinlock, flags);
+	list_add_tail(&rb->list, &cl->free_rb_list.list);
+	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+
+	/*
+	 * If we returned the first buffer to empty 'free' list,
+	 * send flow control
+	 */
+	if (!cl->out_flow_ctrl_creds)
+		rets = heci_cl_read_start(cl);
+
+	return	rets;
+}
+EXPORT_SYMBOL(heci_io_rb_recycle);
+
+
+/**
+ * heci_cl_flush_queues - flushes queue lists belonging to cl.
+ *
+ * @dev: the device structure
+ * @cl: host client
+ */
+int heci_cl_flush_queues(struct heci_cl *cl)
+{
+	if (WARN_ON(!cl || !cl->dev))
+		return -EINVAL;
+
+	dev_dbg(&cl->dev->pdev->dev, "remove list entry belonging to cl\n");
+	heci_read_list_flush(cl);
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_cl_flush_queues);
+
+
+/**
+ * heci_cl_init - initializes intialize cl.
+ *
+ * @cl: host client to be initialized
+ * @dev: heci device
+ */
+void heci_cl_init(struct heci_cl *cl, struct heci_device *dev)
+{
+	memset(cl, 0, sizeof(struct heci_cl));
+	init_waitqueue_head(&cl->wait);
+	init_waitqueue_head(&cl->rx_wait);
+	init_waitqueue_head(&cl->wait_ctrl_res);
+	spin_lock_init(&cl->free_list_spinlock);
+	spin_lock_init(&cl->in_process_spinlock);
+	spin_lock_init(&cl->tx_list_spinlock);
+	spin_lock_init(&cl->tx_free_list_spinlock);
+	spin_lock_init(&cl->fc_spinlock);
+	INIT_LIST_HEAD(&cl->link);
+	cl->dev = dev;
+
+	INIT_LIST_HEAD(&cl->free_rb_list.list);
+	INIT_LIST_HEAD(&cl->tx_list.list);
+	INIT_LIST_HEAD(&cl->tx_free_list.list);
+	INIT_LIST_HEAD(&cl->in_process_list.list);
+
+	cl->rx_ring_size = CL_DEF_RX_RING_SIZE;
+	cl->tx_ring_size = CL_DEF_TX_RING_SIZE;
+}
+
+int	heci_cl_free_rx_ring(struct heci_cl *cl)
+{
+	struct heci_cl_rb *rb;
+	unsigned long	flags;
+
+	/* relese allocated mem- pass over free_rb_list */
+	spin_lock_irqsave(&cl->free_list_spinlock, flags);
+	while (!list_empty(&cl->free_rb_list.list)) {
+		rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb,
+			list);
+		list_del(&rb->list);
+		kfree(rb->buffer.data);
+		kfree(rb);
+	}
+	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+	/* relese allocated mem- pass over in_process_list */
+	spin_lock_irqsave(&cl->in_process_spinlock, flags);
+	while (!list_empty(&cl->in_process_list.list)) {
+		rb = list_entry(cl->in_process_list.list.next,
+			struct heci_cl_rb, list);
+		list_del(&rb->list);
+		kfree(rb->buffer.data);
+		kfree(rb);
+	}
+	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+	return	0;
+}
+
+int	heci_cl_free_tx_ring(struct heci_cl *cl)
+{
+	struct heci_cl_tx_ring  *tx_buf;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
+	/* relese allocated mem- pass over tx_free_list */
+	while (!list_empty(&cl->tx_free_list.list)) {
+		tx_buf = list_entry(cl->tx_free_list.list.next,
+			struct heci_cl_tx_ring, list);
+		list_del(&tx_buf->list);
+		kfree(tx_buf->send_buf.data);
+		kfree(tx_buf);
+	}
+	spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
+
+	spin_lock_irqsave(&cl->tx_list_spinlock, flags);
+	/* relese allocated mem- pass over tx_list */
+	while (!list_empty(&cl->tx_list.list)) {
+		tx_buf = list_entry(cl->tx_list.list.next,
+			struct heci_cl_tx_ring, list);
+		list_del(&tx_buf->list);
+		kfree(tx_buf->send_buf.data);
+		kfree(tx_buf);
+	}
+	spin_unlock_irqrestore(&cl->tx_list_spinlock, flags);
+
+	return	0;
+}
+
+int	heci_cl_alloc_rx_ring(struct heci_cl *cl)
+{
+	size_t	len = cl->device->fw_client->props.max_msg_length;
+	int	j;
+	struct heci_cl_rb *rb;
+	int	ret = 0;
+	struct heci_device *dev = cl->dev;
+	unsigned long	flags;
+
+	for (j = 0; j < cl->rx_ring_size; ++j) {
+		rb = heci_io_rb_init(cl);
+		if (!rb) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		ret = heci_io_rb_alloc_buf(rb, len);
+		if (ret)
+			goto out;
+		spin_lock_irqsave(&cl->free_list_spinlock, flags);
+		list_add_tail(&rb->list, &cl->free_rb_list.list);
+		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
+		__func__);
+	return	0;
+
+out:
+	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n",
+		__func__);
+	heci_cl_free_rx_ring(cl);
+	return	ret;
+}
+
+
+int	heci_cl_alloc_tx_ring(struct heci_cl *cl)
+{
+	size_t	len = cl->device->fw_client->props.max_msg_length;
+	int	j;
+	struct heci_device *dev = cl->dev;
+	unsigned long	flags;
+
+	/*cl->send_fc_flag = 0;*/
+	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
+		__func__);
+
+	/* Allocate pool to free Tx bufs */
+	for (j = 0; j < cl->tx_ring_size; ++j) {
+		struct heci_cl_tx_ring	*tx_buf;
+
+		tx_buf = kmalloc(sizeof(struct heci_cl_tx_ring), GFP_KERNEL);
+		if (!tx_buf) {
+			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n",
+				__func__);
+			goto	out;
+		}
+		memset(tx_buf, 0, sizeof(struct heci_cl_tx_ring));
+		tx_buf->send_buf.data = kmalloc(len, GFP_KERNEL);
+		if (!tx_buf->send_buf.data) {
+			dev_err(&dev->pdev->dev, "%s(): error allocating Tx buffers\n",
+				__func__);
+			kfree(tx_buf);
+			goto	out;
+		}
+		spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
+		list_add_tail(&tx_buf->list, &cl->tx_free_list.list);
+		spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s() allocated Tx  pool successfully\n",
+		__func__);
+
+	return	0;
+
+out:
+	dev_err(&dev->pdev->dev, "%s() error in allocating rb pool\n",
+		__func__);
+	heci_cl_free_rx_ring(cl);
+	return	-ENOMEM;
+}
+
+
+/**
+ * heci_cl_allocate - allocates cl  structure and sets it up.
+ *
+ * @dev: heci device
+ * returns  The allocated file or NULL on failure
+ */
+struct heci_cl *heci_cl_allocate(struct heci_device *dev)
+{
+	struct heci_cl *cl;
+
+	cl = kmalloc(sizeof(struct heci_cl), GFP_ATOMIC);
+	if (!cl)
+		return NULL;
+
+	heci_cl_init(cl, dev);
+	return cl;
+}
+EXPORT_SYMBOL(heci_cl_allocate);
+
+
+void	heci_cl_free(struct heci_cl *cl)
+{
+	if (!cl)
+		return;
+
+	heci_cl_free_rx_ring(cl);
+	heci_cl_free_tx_ring(cl);
+	kfree(cl);
+}
+EXPORT_SYMBOL(heci_cl_free);
+
+
+/**
+ * heci_cl_find_read_rb - find this cl's callback in the read list
+ *
+ * @dev: device structure
+ * returns rb on success, NULL on error
+ */
+struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl)
+{
+	struct heci_device *dev = cl->dev;
+	struct heci_cl_rb *rb = NULL;
+	struct heci_cl_rb *next = NULL;
+	unsigned long     dev_flags;
+
+	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
+	list_for_each_entry_safe(rb, next, &dev->read_list.list, list)
+		if (heci_cl_cmp_id(cl, rb->cl)) {
+			spin_unlock_irqrestore(&dev->read_list_spinlock,
+				dev_flags);
+			return rb;
+		}
+	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+	return NULL;
+}
+EXPORT_SYMBOL(heci_cl_find_read_rb);
+
+/** heci_cl_link: allocte host id in the host map
+ *
+ * @cl - host client
+ * @id - fixed host id or -1 for genereting one
+ * returns 0 on success
+ *	-EINVAL on incorrect values
+ *	-ENONET if client not found
+ */
+int heci_cl_link(struct heci_cl *cl, int id)
+{
+	struct heci_device *dev;
+	unsigned long	flags, flags_cl;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -EINVAL;
+
+	dev = cl->dev;
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+
+	if (dev->open_handle_count >= HECI_MAX_OPEN_HANDLE_COUNT) {
+		spin_unlock_irqrestore(&dev->device_lock, flags);
+		return	-EMFILE;
+	}
+
+	/* If Id is not asigned get one*/
+	if (id == HECI_HOST_CLIENT_ID_ANY)
+		id = find_first_zero_bit(dev->host_clients_map,
+			HECI_CLIENTS_MAX);
+
+	if (id >= HECI_CLIENTS_MAX) {
+		spin_unlock_irqrestore(&dev->device_lock, flags);
+		dev_err(&dev->pdev->dev, "id exceded %d", HECI_CLIENTS_MAX);
+		return -ENOENT;
+	}
+
+	dev->open_handle_count++;
+	cl->host_client_id = id;
+	spin_lock_irqsave(&dev->cl_list_lock, flags_cl);
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
+		spin_unlock_irqrestore(&dev->device_lock, flags);
+		return -ENODEV;
+	}
+	list_add_tail(&cl->link, &dev->cl_list);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
+	set_bit(id, dev->host_clients_map);
+	cl->state = HECI_CL_INITIALIZING;
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+
+	dev_dbg(&dev->pdev->dev, "link cl host id = %d\n", cl->host_client_id);
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_cl_link);
+
+/**
+ * heci_cl_unlink - remove me_cl from the list
+ *
+ * @dev: the device structure
+ */
+int heci_cl_unlink(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_cl *pos, *next;
+	unsigned long	flags;
+
+	/* don't shout on error exit path */
+	if (!cl || !cl->dev)
+		return 0;
+
+	dev = cl->dev;
+
+	spin_lock_irqsave(&dev->device_lock, flags);
+	if (dev->open_handle_count > 0) {
+		clear_bit(cl->host_client_id, dev->host_clients_map);
+		dev->open_handle_count--;
+	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
+
+	/*
+	 * This checks that 'cl' is actually linked into device's structure,
+	 * before attempting 'list_del'
+	 */
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
+		if (cl->host_client_id == pos->host_client_id) {
+			list_del_init(&pos->link);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_cl_unlink);
+
+
+/**
+ * heci_cl_disconnect - disconnect host clinet form the me one
+ *
+ * @cl: host client
+ *
+ * Locking: called under "dev->device_lock" lock
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_cl_disconnect(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	int rets, err;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (cl->state != HECI_CL_DISCONNECTING)
+		return 0;
+
+	rets = pm_runtime_get_sync(&dev->pdev->dev);
+	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
+	if (IS_ERR_VALUE(rets)) {
+		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
+		return rets;
+	}
+
+	if (heci_hbm_cl_disconnect_req(dev, cl)) {
+		rets = -ENODEV;
+		dev_err(&dev->pdev->dev, "failed to disconnect.\n");
+		goto free;
+	}
+
+	err = wait_event_timeout(cl->wait_ctrl_res,
+			(dev->dev_state != HECI_DEV_ENABLED ||
+			HECI_CL_DISCONNECTED == cl->state),
+			heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT));
+
+	/*
+	 * If FW reset arrived, this will happen. Don't check cl->,
+	 * as 'cl' may be freed already
+	 */
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto	free;
+	}
+
+	if (HECI_CL_DISCONNECTED == cl->state) {
+		rets = 0;
+		dev_dbg(&dev->pdev->dev, "successfully disconnected from FW client.\n");
+	} else {
+		rets = -ENODEV;
+		if (HECI_CL_DISCONNECTED != cl->state)
+			dev_dbg(&dev->pdev->dev, "wrong status client disconnect.\n");
+
+		if (err)
+			dev_dbg(&dev->pdev->dev,
+				"wait failed disconnect err=%08x\n", err);
+
+		dev_dbg(&dev->pdev->dev, "failed to disconnect from FW client.\n");
+	}
+
+free:
+	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
+	pm_runtime_mark_last_busy(&dev->pdev->dev);
+	pm_runtime_put_autosuspend(&dev->pdev->dev);
+
+	return rets;
+}
+EXPORT_SYMBOL(heci_cl_disconnect);
+
+
+/**
+ * heci_cl_is_other_connecting - checks if other
+ *    client with the same me client id is connecting
+ *
+ * @cl: private data of the file object
+ *
+ * returns ture if other client is connected, 0 - otherwise.
+ */
+bool heci_cl_is_other_connecting(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_cl *pos;
+	struct heci_cl *next;
+	unsigned long	flags;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return false;
+
+	dev = cl->dev;
+
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
+		if ((pos->state == HECI_CL_CONNECTING) && (pos != cl) &&
+				cl->me_client_id == pos->me_client_id) {
+			spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+			return true;
+		}
+
+	}
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+
+	return false;
+}
+
+/**
+ * heci_cl_connect - connect host clinet to the me one
+ *
+ * @cl: host client
+ *
+ * Locking: called under "dev->device_lock" lock
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_cl_connect(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	long timeout = heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT);
+	int rets;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	if (heci_cl_is_other_connecting(cl))
+		return	-EBUSY;
+
+	dev = cl->dev;
+
+	rets = pm_runtime_get_sync(&dev->pdev->dev);
+	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
+	if (IS_ERR_VALUE(rets)) {
+		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
+		return rets;
+	}
+
+	if (heci_hbm_cl_connect_req(dev, cl)) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	rets = wait_event_timeout(cl->wait_ctrl_res,
+				(dev->dev_state == HECI_DEV_ENABLED &&
+				 (cl->state == HECI_CL_CONNECTED ||
+				  cl->state == HECI_CL_DISCONNECTED)),
+				 timeout * HZ);
+
+	/*
+	 * If FW reset arrived, this will happen. Don't check cl->,
+	 * as 'cl' may be freed already
+	 */
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -EFAULT;
+		goto	out;
+	}
+
+	if (cl->state != HECI_CL_CONNECTED) {
+		rets = -EFAULT;
+		goto out;
+	}
+
+	rets = cl->status;
+	if (rets)
+		goto	out;
+
+	rets = heci_cl_device_bind(cl);
+	if (rets) {
+		heci_cl_disconnect(cl);
+		goto    out;
+	}
+
+	rets = heci_cl_alloc_rx_ring(cl);
+	if (rets) {
+		/* if failed allocation, disconnect */
+		heci_cl_disconnect(cl);
+		goto	out;
+	}
+
+	rets = heci_cl_alloc_tx_ring(cl);
+	if (rets) {
+		/* if failed allocation, disconnect */
+		heci_cl_free_rx_ring(cl);
+		heci_cl_disconnect(cl);
+		goto	out;
+	}
+
+	/* Upon successful connection and allocation, emit flow-control */
+	rets = heci_cl_read_start(cl);
+out:
+	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
+	pm_runtime_mark_last_busy(&dev->pdev->dev);
+	pm_runtime_put_autosuspend(&dev->pdev->dev);
+
+	return rets;
+}
+EXPORT_SYMBOL(heci_cl_connect);
+
+/**
+ * heci_cl_read_start - the start read client message function.
+ *
+ * @cl: host client
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_cl_read_start(struct heci_cl *cl)
+{
+	struct heci_device *dev;
+	struct heci_cl_rb *rb;
+	int rets;
+	int i;
+	unsigned long	flags;
+	unsigned long	dev_flags;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (cl->state != HECI_CL_CONNECTED)
+		return -ENODEV;
+
+	if (dev->dev_state != HECI_DEV_ENABLED)
+		return -ENODEV;
+
+/*
+	if (cl->read_rb) {
+		dev_dbg(&dev->pdev->dev, "read is pending.\n");
+		return -EBUSY;
+	}
+*/
+	i = heci_me_cl_by_id(dev, cl->me_client_id);
+	if (i < 0) {
+		dev_err(&dev->pdev->dev, "no such me client %d\n",
+			cl->me_client_id);
+		return  -ENODEV;
+	}
+
+	rets = pm_runtime_get_sync(&dev->pdev->dev);
+	dev_dbg(&dev->pdev->dev, "rpm: get sync %d\n", rets);
+	if (IS_ERR_VALUE(rets)) {
+		dev_err(&dev->pdev->dev, "rpm: get sync failed %d\n", rets);
+		return rets;
+	}
+
+	/* The current rb is the head of the free rb list */
+	spin_lock_irqsave(&cl->free_list_spinlock, flags);
+	if (list_empty(&cl->free_rb_list.list)) {
+		dev_warn(&dev->pdev->dev, "[heci-ish] rb pool is empty\n");
+		rets = -ENOMEM;
+		rb = NULL;
+		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+		goto out;
+	}
+	rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb, list);
+	list_del_init(&rb->list);
+	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+	/***************/
+	rb->cl = cl;
+	rb->buf_idx = 0;
+	/***************/
+
+	heci_io_list_init(rb);
+	rets = 0;
+
+	/*cl->read_rb = rb;*/
+
+	/*
+	 * This must be BEFORE sending flow control -
+	 * response in ISR may come too fast...
+	 */
+	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
+	list_add_tail(&rb->list, &dev->read_list.list);
+	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+	if (heci_hbm_cl_flow_control_req(dev, cl)) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+out:
+	dev_dbg(&dev->pdev->dev, "rpm: autosuspend\n");
+	pm_runtime_mark_last_busy(&dev->pdev->dev);
+	pm_runtime_put_autosuspend(&dev->pdev->dev);
+
+	/* heci_hbm_cl_flow_control_req failed, return rb to free list */
+	if (rets && rb) {
+		spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
+		list_del(&rb->list);
+		spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+
+		spin_lock_irqsave(&cl->free_list_spinlock, flags);
+		list_add_tail(&rb->list, &cl->free_rb_list.list);
+		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
+	}
+
+	return rets;
+}
+EXPORT_SYMBOL(heci_cl_read_start);
+
+
+int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
+{
+	struct heci_device *dev;
+	int id;
+	struct heci_cl_tx_ring  *cl_msg;
+	int	have_msg_to_send = 0;
+	unsigned long	me_flags, tx_flags, tx_free_flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (cl->state != HECI_CL_CONNECTED) {
+		++cl->err_send_msg;
+		return -EPIPE;
+	}
+
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		++cl->err_send_msg;
+		return -ENODEV;
+	}
+
+	/* Check if we have an ME client device */
+	id = heci_me_cl_by_id(dev, cl->me_client_id);
+	if (id < 0) {
+		++cl->err_send_msg;
+		return -ENOENT;
+	}
+
+	spin_lock_irqsave(&dev->me_clients_lock, me_flags);
+	if (length > dev->me_clients[id].props.max_msg_length) {
+		/* If the client supports DMA, try to use it */
+		if (host_dma_enabled && dev->me_clients[id].props.dma_hdr_len &
+				HECI_CLIENT_DMA_ENABLED) {
+			struct heci_msg_hdr	hdr;
+			struct hbm_client_dma_request	heci_dma_request_msg;
+			unsigned len = sizeof(struct hbm_client_dma_request);
+			int	preview_len =
+				dev->me_clients[id].props.dma_hdr_len & 0x7F;
+			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
+			/* DMA max msg size is 1M */
+			if (length > host_dma_buf_size) {
+				++cl->err_send_msg;
+				return	-EMSGSIZE;
+			}
+
+			/*
+			 * Client for some reason specified
+			 * props.dma_hdr_len > 12, mistake?
+			 */
+			if (preview_len > 12) {
+				++cl->err_send_msg;
+				return	-EINVAL;
+			}
+
+			/*If previous DMA transfer is in progress, go to sleep*/
+			wait_event_timeout(dev->wait_dma_ready, dma_ready,
+				10 * HZ);
+			dma_ready = 0;
+			/*
+			 * First 'preview_len' bytes of buffer are preview
+			 * bytes, omitted from DMA message
+			 */
+			memcpy(host_dma_buf, buf + preview_len,
+				length - preview_len);
+			heci_hbm_hdr(&hdr, len);
+			heci_dma_request_msg.hbm_cmd = CLIENT_DMA_REQ_CMD;
+			heci_dma_request_msg.me_addr = cl->me_client_id;
+			heci_dma_request_msg.host_addr = cl->host_client_id;
+			heci_dma_request_msg.reserved = 0;
+			heci_dma_request_msg.msg_addr = host_dma_buf_phys;
+			heci_dma_request_msg.msg_len = length - preview_len;
+			heci_dma_request_msg.reserved2 = 0;
+			memcpy(heci_dma_request_msg.msg_preview, buf,
+				preview_len);
+			heci_write_message(dev, &hdr,
+				(uint8_t *)&heci_dma_request_msg);
+			return 0;
+		} else {
+			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
+			++cl->err_send_msg;
+			return -EINVAL;		/* -EMSGSIZE? */
+		}
+	} else {
+		spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
+	}
+
+	/* No free bufs */
+	spin_lock_irqsave(&cl->tx_free_list_spinlock, tx_free_flags);
+	if (list_empty(&cl->tx_free_list.list)) {
+		spin_unlock_irqrestore(&cl->tx_free_list_spinlock,
+			tx_free_flags);
+		++cl->err_send_msg;
+		return	-ENOMEM;
+	}
+
+	cl_msg = list_first_entry(&cl->tx_free_list.list,
+		struct heci_cl_tx_ring, list);
+	if (!cl_msg->send_buf.data)
+		return	-EIO;		/* Should not happen,
+					as free list is pre-allocated */
+	++cl->send_msg_cnt;
+	/*
+	 * This is safe, as 'length' is already checked for not exceeding max.
+	 * HECI message size per client
+	 */
+	list_del_init(&cl_msg->list);
+	spin_unlock_irqrestore(&cl->tx_free_list_spinlock, tx_free_flags);
+	memcpy(cl_msg->send_buf.data, buf, length);
+	cl_msg->send_buf.size = length;
+	spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
+	have_msg_to_send = !list_empty(&cl->tx_list.list);
+	list_add_tail(&cl_msg->list, &cl->tx_list.list);
+	spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
+
+	if (!have_msg_to_send && cl->heci_flow_ctrl_creds > 0)
+		heci_cl_send_msg(dev, cl);
+
+	return	0;
+}
+EXPORT_SYMBOL(heci_cl_send);
+
+
+/**
+ * heci_cl_read_complete - processes completed operation for a client
+ *
+ * @cl: private data of the file object.
+ * @rb: callback block.
+ */
+void heci_cl_read_complete(struct heci_cl_rb *rb)
+{
+	unsigned long	flags;
+	int	schedule_work_flag = 0;
+	struct heci_cl	*cl = rb->cl;
+
+	if (waitqueue_active(&cl->rx_wait)) {
+		cl->read_rb = rb;
+		wake_up_interruptible(&cl->rx_wait);
+	} else {
+		spin_lock_irqsave(&cl->in_process_spinlock, flags);
+		/*
+		 * if in-process list is empty, then need to schedule
+		 * the processing thread
+		 */
+		schedule_work_flag = list_empty(&cl->in_process_list.list);
+		list_add_tail(&rb->list, &cl->in_process_list.list);
+		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+
+		if (schedule_work_flag)
+			heci_cl_bus_rx_event(cl->device);
+	}
+}
+EXPORT_SYMBOL(heci_cl_read_complete);
+
+
+/**
+ * heci_cl_all_disconnect - disconnect forcefully all connected clients
+ *
+ * @dev - heci device
+ */
+void heci_cl_all_disconnect(struct heci_device *dev)
+{
+	struct heci_cl *cl, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		cl->state = HECI_CL_DISCONNECTED;
+		cl->heci_flow_ctrl_creds = 0;
+		cl->read_rb = NULL;
+	}
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+}
+
+
+/**
+ * heci_cl_all_read_wakeup  - wake up all readings so they can be interrupted
+ *
+ * @dev  - heci device
+ */
+void heci_cl_all_read_wakeup(struct heci_device *dev)
+{
+	struct heci_cl *cl, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (waitqueue_active(&cl->rx_wait)) {
+			dev_dbg(&dev->pdev->dev, "Waking up client!\n");
+			wake_up_interruptible(&cl->rx_wait);
+		}
+	}
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+}
+
+/*##################################*/
+
+static void	ipc_tx_callback(void *prm)
+{
+	struct heci_cl	*cl = prm;
+	struct heci_cl_tx_ring	*cl_msg;
+	size_t	rem;
+	struct heci_device	*dev = (cl ? cl->dev : NULL);
+	struct heci_msg_hdr	heci_hdr;
+	unsigned long	flags, tx_flags, tx_free_flags;
+	unsigned char	*pmsg;
+
+	if (!dev)
+		return;
+
+	/*
+	 * FIXME: there may be other conditions if some critical error has
+	 * ocurred before this callback is called
+	 */
+	spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
+	if (list_empty(&cl->tx_list.list)) {
+		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
+		return;
+	}
+
+	/* Last call check for fc credits */
+	if (cl->heci_flow_ctrl_creds != 1 && !cl->sending) {
+		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
+		return;
+	}
+
+	if (!cl->sending) {
+		--cl->heci_flow_ctrl_creds;
+		cl->sending = 1;
+	}
+
+	cl_msg = list_entry(cl->tx_list.list.next, struct heci_cl_tx_ring,
+		list);
+	rem = cl_msg->send_buf.size - cl->tx_offs;
+
+	heci_hdr.host_addr = cl->host_client_id;
+	heci_hdr.me_addr = cl->me_client_id;
+	heci_hdr.reserved = 0;
+	pmsg = cl_msg->send_buf.data + cl->tx_offs;
+
+	if (rem <= dev->mtu) {
+		heci_hdr.length = rem;
+		heci_hdr.msg_complete = 1;
+		cl->sending = 0;
+		list_del_init(&cl_msg->list);	/* Must be before write */
+		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
+		/* Submit to IPC queue with no callback */
+		heci_write_message(dev, &heci_hdr, pmsg);
+		spin_lock_irqsave(&cl->tx_free_list_spinlock, tx_free_flags);
+		list_add_tail(&cl_msg->list, &cl->tx_free_list.list);
+		spin_unlock_irqrestore(&cl->tx_free_list_spinlock,
+			tx_free_flags);
+	} else {
+		/* FIXME: Send IPC fragment */
+		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
+		cl->tx_offs += dev->mtu;
+		heci_hdr.length = dev->mtu;
+		heci_hdr.msg_complete = 0;
+		dev->ops->write_ex(dev, &heci_hdr, pmsg, ipc_tx_callback, cl);
+	}
+}
+
+
+void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl)
+{
+	cl->tx_offs = 0;
+	ipc_tx_callback(cl);
+}
+EXPORT_SYMBOL(heci_cl_send_msg);
+/*##################################*/
+
+
+/*
+ *	Receive and dispatch HECI client messages
+ *
+ *	(!) ISR context
+ */
+void	recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+{
+	struct heci_cl *cl;
+	struct heci_cl_rb *rb, *next;
+	struct heci_cl_rb *new_rb;
+	unsigned char *buffer = NULL;
+	struct heci_cl_rb *complete_rb = NULL;
+	unsigned long	dev_flags;
+	unsigned long	flags;
+	int	rb_count;
+
+
+	if (heci_hdr->reserved) {
+		dev_err(&dev->pdev->dev, "corrupted message header.\n");
+		goto	eoi;
+	}
+
+	if (heci_hdr->length > IPC_PAYLOAD_SIZE) {
+		dev_err(&dev->pdev->dev, "HECI message length in hdr is too big for IPC MTU. Broken message\n");
+		goto	eoi;
+	}
+
+	spin_lock_irqsave(&dev->read_list_spinlock, dev_flags);
+	rb_count = -1;
+	list_for_each_entry_safe(rb, next, &dev->read_list.list, list) {
+		++rb_count;
+		cl = rb->cl;
+		if (!cl || !(cl->host_client_id == heci_hdr->host_addr &&
+				cl->me_client_id == heci_hdr->me_addr) ||
+				!(cl->state == HECI_CL_CONNECTED))
+			continue;
+
+		/*
+		 * FIXME: in both if() closes rb must return to free pool
+		 * and/or disband and/or disconnect client
+		 */
+		if (rb->buffer.size == 0 || rb->buffer.data == NULL) {
+			spin_unlock_irqrestore(&dev->read_list_spinlock,
+				dev_flags);
+			dev_err(&dev->pdev->dev, "response buffer is not allocated.\n");
+			list_del(&rb->list);
+			goto	eoi;
+		}
+
+		if (rb->buffer.size < heci_hdr->length + rb->buf_idx) {
+			spin_unlock_irqrestore(&dev->read_list_spinlock,
+				dev_flags);
+			dev_err(&dev->pdev->dev, "message overflow. size %d len %d idx %ld\n",
+				rb->buffer.size, heci_hdr->length, rb->buf_idx);
+			list_del(&rb->list);
+			goto	eoi;
+		}
+
+		buffer = rb->buffer.data + rb->buf_idx;
+		dev->ops->read(dev, buffer, heci_hdr->length);
+
+		/* Debug HID client */
+		if (cl->host_client_id == 3 && cl->me_client_id == 5)
+			dev->ipc_hid_in_msg = 1;
+
+		rb->buf_idx += heci_hdr->length;
+		if (heci_hdr->msg_complete) {
+			/* Last fragment in message - it's complete */
+			cl->status = 0;
+			list_del(&rb->list);
+			complete_rb = rb;
+
+			/* Debug HID client */
+			if (cl->host_client_id == 3 && cl->me_client_id == 5) {
+				dev->ipc_hid_in_msg = 0;
+				--dev->ipc_hid_out_fc;
+			}
+
+			--cl->out_flow_ctrl_creds;
+			/*
+			 * the whole msg arrived, send a new FC, and add a new
+			 * rb buffer for the next coming msg
+			 */
+			spin_lock_irqsave(&cl->free_list_spinlock, flags);
+
+			if (!list_empty(&cl->free_rb_list.list)) {
+				new_rb = list_entry(cl->free_rb_list.list.next,
+					struct heci_cl_rb, list);
+				list_del_init(&new_rb->list);
+				spin_unlock_irqrestore(&cl->free_list_spinlock,
+					flags);
+				new_rb->cl = cl;
+				new_rb->buf_idx = 0;
+				INIT_LIST_HEAD(&new_rb->list);
+				list_add_tail(&new_rb->list,
+					&dev->read_list.list);
+
+				heci_hbm_cl_flow_control_req(dev, cl);
+			} else {
+				/*cl->send_fc_flag = 1;*/
+				spin_unlock_irqrestore(&cl->free_list_spinlock,
+					flags);
+			}
+		}
+		/* One more fragment in message (even if this was last) */
+		++cl->recv_msg_num_frags;
+
+		/*
+		 * We can safely break here (and in BH too),
+		 * a single input message can go only to a single request!
+		 */
+		break;
+	}
+
+	spin_unlock_irqrestore(&dev->read_list_spinlock, dev_flags);
+	/* If it's nobody's message, just read and discard it */
+	if (!buffer) {
+		uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
+
+		dev_err(&dev->pdev->dev, "%s(): Dropped msg - no request\n",
+			__func__);
+		dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
+		goto	eoi;
+	}
+
+	/* Looks like this is interrupt-safe */
+	if (complete_rb) {
+		struct timeval	tv;
+		do_gettimeofday(&tv);
+		cl->rx_sec = tv.tv_sec;
+		cl->rx_usec = tv.tv_usec;
+		++cl->recv_msg_cnt;
+		heci_cl_read_complete(complete_rb);
+	}
+
+eoi:
+	return;
+}
+EXPORT_SYMBOL(recv_heci_cl_msg);
+
diff --git a/drivers/misc/intel-ish/client.h b/drivers/misc/intel-ish/client.h
new file mode 100644
index 0000000..8614020
--- /dev/null
+++ b/drivers/misc/intel-ish/client.h
@@ -0,0 +1,192 @@
+/*
+ * HECI client logic
+ *
+ * Copyright (c) 2003-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_CLIENT_H_
+#define _HECI_CLIENT_H_
+
+#include <linux/types.h>
+#include <linux/watchdog.h>
+#include <linux/poll.h>
+#include "heci_dev.h"
+
+/* Client state */
+enum cl_state {
+	HECI_CL_INITIALIZING = 0,
+	HECI_CL_CONNECTING,
+	HECI_CL_CONNECTED,
+	HECI_CL_DISCONNECTING,
+	HECI_CL_DISCONNECTED
+};
+
+#define	CL_DEF_RX_RING_SIZE	2
+#define	CL_DEF_TX_RING_SIZE	2
+#define	CL_MAX_RX_RING_SIZE	32
+#define	CL_MAX_TX_RING_SIZE	32
+
+/* Client Tx  buffer list entry */
+struct heci_cl_tx_ring {
+	struct list_head list;
+	struct heci_msg_data	send_buf;
+};
+
+/* HECI client instance carried as file->pirvate_data*/
+struct heci_cl {
+	struct list_head link;
+	struct heci_device *dev;
+	enum cl_state state;
+	wait_queue_head_t rx_wait;
+	wait_queue_head_t wait;
+	int status;
+	/* ID of client connected */
+	u8 host_client_id;
+	u8 me_client_id;
+	u8 heci_flow_ctrl_creds;
+	u8 out_flow_ctrl_creds;
+	struct heci_cl_rb *read_rb;
+
+	/* Link to HECI bus device */
+	struct heci_cl_device *device;
+
+	/* Rx ring buffer pool */
+	unsigned	rx_ring_size;
+	struct heci_cl_rb	free_rb_list;
+	/*int     send_fc_flag;*/
+	spinlock_t      free_list_spinlock;
+	/* Rx in-process list */
+	struct heci_cl_rb       in_process_list;
+	spinlock_t      in_process_spinlock;
+
+	/* Client Tx buffers list */
+	unsigned	tx_ring_size;
+	struct heci_cl_tx_ring	tx_list, tx_free_list;
+	spinlock_t      tx_list_spinlock;
+	spinlock_t      tx_free_list_spinlock;
+	size_t	tx_offs;	/* Offset in buffer at head of 'tx_list' */
+	/*#############################*/
+	/* if we get a FC, and the list is not empty, we must know whether we
+	 * are at the middle of sending.
+	 * if so - need to increase FC counter, otherwise, need to start sending
+	 * the first msg in list
+	 * (!) This is for counting-FC implementation only. Within single-FC the
+	 * other party may NOT send FC until it receives complete message
+	 */
+	int sending;
+	/*#############################*/
+
+	/* Send FC spinlock */
+	spinlock_t      fc_spinlock;
+
+	/* wait queue for connect and disconnect response from FW */
+	wait_queue_head_t wait_ctrl_res;
+
+	/* Error stats */
+	unsigned	err_send_msg;
+	unsigned	err_send_fc;
+
+	/* Send/recv stats */
+	unsigned	send_msg_cnt;
+	unsigned	recv_msg_cnt;
+	unsigned	recv_msg_num_frags;
+	unsigned	heci_flow_ctrl_cnt;
+	unsigned	out_flow_ctrl_cnt;
+
+	/* Rx msg ... out FC timing */
+	unsigned long	rx_sec, rx_usec;
+	unsigned long	out_fc_sec, out_fc_usec;
+	unsigned long	max_fc_delay_sec, max_fc_delay_usec;
+};
+
+extern int	dma_ready;
+extern int	host_dma_enabled;
+
+int heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid);
+int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *cuuid);
+int heci_me_cl_by_id(struct heci_device *dev, u8 client_id);
+
+/*
+ * HECI IO Functions
+ */
+struct heci_cl_rb *heci_io_rb_init(struct heci_cl *cl);
+void heci_io_rb_free(struct heci_cl_rb *priv_rb);
+int heci_io_rb_alloc_buf(struct heci_cl_rb *rb, size_t length);
+int heci_io_rb_recycle(struct heci_cl_rb *rb);
+
+
+/**
+ * heci_io_list_init - Sets up a queue list.
+ *
+ * @list: An instance cl callback structure
+ */
+static inline void heci_io_list_init(struct heci_cl_rb *list)
+{
+	INIT_LIST_HEAD(&list->list);
+}
+void heci_read_list_flush(struct heci_cl *cl);
+
+/*
+ * HECI Host Client Functions
+ */
+
+struct heci_cl *heci_cl_allocate(struct heci_device *dev);
+void heci_cl_init(struct heci_cl *cl, struct heci_device *dev);
+void	heci_cl_free(struct heci_cl *cl);
+
+int	heci_cl_alloc_rx_ring(struct heci_cl *cl);
+int	heci_cl_alloc_tx_ring(struct heci_cl *cl);
+int	heci_cl_free_rx_ring(struct heci_cl *cl);
+int	heci_cl_free_tx_ring(struct heci_cl *cl);
+
+int heci_cl_link(struct heci_cl *cl, int id);
+int heci_cl_unlink(struct heci_cl *cl);
+
+int heci_cl_flush_queues(struct heci_cl *cl);
+struct heci_cl_rb *heci_cl_find_read_rb(struct heci_cl *cl);
+
+/**
+ * heci_cl_cmp_id - tells if file private data have same id
+ *
+ * @fe1: private data of 1. file object
+ * @fe2: private data of 2. file object
+ *
+ * returns true  - if ids are the same and not NULL
+ */
+static inline bool heci_cl_cmp_id(const struct heci_cl *cl1,
+				const struct heci_cl *cl2)
+{
+	return cl1 && cl2 &&
+		(cl1->host_client_id == cl2->host_client_id) &&
+		(cl1->me_client_id == cl2->me_client_id);
+}
+
+
+int heci_cl_flow_ctrl_creds(struct heci_cl *cl);
+
+/*
+ *  HECI input output function prototype
+ */
+bool heci_cl_is_other_connecting(struct heci_cl *cl);
+int heci_cl_disconnect(struct heci_cl *cl);
+int heci_cl_connect(struct heci_cl *cl);
+int heci_cl_read_start(struct heci_cl *cl);
+int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length);
+void heci_cl_read_complete(struct heci_cl_rb *rb);
+void heci_cl_all_disconnect(struct heci_device *dev);
+void heci_cl_all_read_wakeup(struct heci_device *dev);
+void heci_cl_send_msg(struct heci_device *dev, struct heci_cl *cl);
+void heci_cl_alloc_dma_buf(void);
+void recv_heci_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
+
+#endif /* _HECI_CLIENT_H_ */
+
diff --git a/drivers/misc/intel-ish/debugfs.c b/drivers/misc/intel-ish/debugfs.c
new file mode 100644
index 0000000..1160d4f
--- /dev/null
+++ b/drivers/misc/intel-ish/debugfs.c
@@ -0,0 +1,136 @@
+/*
+ * DebugFS for HECI driver
+ *
+ * Copyright (c) 2012-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/debugfs.h>
+#include <linux/pci.h>
+#include "heci_dev.h"
+
+static ssize_t heci_dbgfs_read_meclients(struct file *fp, char __user *ubuf,
+					size_t cnt, loff_t *ppos)
+{
+	struct heci_device *dev = fp->private_data;
+	struct heci_me_client *cl;
+	const size_t bufsz = 1024;
+	char *buf = kzalloc(bufsz, GFP_KERNEL);
+	int i;
+	int pos = 0;
+	int ret;
+	unsigned long	flags;
+	if  (!buf)
+		return -ENOMEM;
+
+	pos += scnprintf(buf + pos, bufsz - pos,
+			"  |id|addr|         UUID                       |con|msg len|\n");
+
+	/*  if the driver is not enabled the list won't b consitent */
+	if (dev->dev_state != HECI_DEV_ENABLED)
+		goto out;
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
+	for (i = 0; i < dev->me_clients_num; i++) {
+		cl = &dev->me_clients[i];
+		/* skip me clients that cannot be connected */
+		if (cl->props.max_number_of_connections == 0)
+			continue;
+
+		pos += scnprintf(buf + pos, bufsz - pos,
+			"%2d|%2d|%4d|%pUl|%3d|%7d|\n",
+			i, cl->client_id,
+			cl->props.fixed_address,
+			&cl->props.protocol_name,
+			cl->props.max_number_of_connections,
+			cl->props.max_msg_length);
+	}
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+out:
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations heci_dbgfs_fops_meclients = {
+	.open = simple_open,
+	.read = heci_dbgfs_read_meclients,
+	.llseek = generic_file_llseek,
+};
+
+static ssize_t heci_dbgfs_read_devstate(struct file *fp, char __user *ubuf,
+					size_t cnt, loff_t *ppos)
+{
+	struct heci_device *dev = fp->private_data;
+	const size_t bufsz = 1024;
+	char *buf = kzalloc(bufsz, GFP_KERNEL);
+	int pos = 0;
+	int ret;
+
+	if  (!buf)
+		return -ENOMEM;
+
+	pos += scnprintf(buf + pos, bufsz - pos, "%s\n",
+			heci_dev_state_str(dev->dev_state));
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
+	kfree(buf);
+	return ret;
+}
+static const struct file_operations heci_dbgfs_fops_devstate = {
+	.open = simple_open,
+	.read = heci_dbgfs_read_devstate,
+	.llseek = generic_file_llseek,
+};
+
+/**
+ * heci_dbgfs_deregister - Remove the debugfs files and directories
+ * @heci - pointer to heci device private dat
+ */
+void heci_dbgfs_deregister(struct heci_device *dev)
+{
+	if (!dev->dbgfs_dir)
+		return;
+	debugfs_remove_recursive(dev->dbgfs_dir);
+	dev->dbgfs_dir = NULL;
+}
+
+/**
+ * Add the debugfs files
+ *
+ */
+int heci_dbgfs_register(struct heci_device *dev, const char *name)
+{
+	struct dentry *dir, *f;
+	dir = debugfs_create_dir(name, NULL);
+	if (!dir)
+		return -ENOMEM;
+
+	f = debugfs_create_file("meclients", S_IRUSR, dir,
+				dev, &heci_dbgfs_fops_meclients);
+	if (!f) {
+		dev_err(&dev->pdev->dev, "meclients: registration failed\n");
+		goto err;
+	}
+	f = debugfs_create_file("devstate", S_IRUSR, dir,
+				dev, &heci_dbgfs_fops_devstate);
+	if (!f) {
+		dev_err(&dev->pdev->dev, "devstate: registration failed\n");
+		goto err;
+	}
+	dev->dbgfs_dir = dir;
+	return 0;
+err:
+	heci_dbgfs_deregister(dev);
+	return -ENODEV;
+}
+
diff --git a/drivers/misc/intel-ish/hbm.c b/drivers/misc/intel-ish/hbm.c
new file mode 100644
index 0000000..67680aa
--- /dev/null
+++ b/drivers/misc/intel-ish/hbm.c
@@ -0,0 +1,927 @@
+/*
+ * HECI bus layer messages handling
+ *
+ * Copyright (c) 2003-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include "heci_dev.h"
+#include "hbm.h"
+#include "client.h"
+#include <linux/spinlock.h>
+/*
+#define	DEBUG_FW_BOOT_SEQ	1
+#define	DUMP_CL_PROP	1
+*/
+
+#ifdef DEBUG_FW_BOOT_SEQ
+unsigned char	static_fw_cl_props[6][32] = {
+
+{0x85, 0x01, 0x00, 0x00, 0x3B, 0x79, 0x63, 0xD9, 0xCF, 0x61, 0x8E, 0x4F, 0x8C,
+	0x02, 0xF2, 0xF7, 0xD0, 0x7F, 0x8E, 0x84, 0x01, 0x01, 0x00, 0x00, 0x00,
+	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+{0x85, 0x02, 0x00, 0x00, 0xB9, 0x78, 0xCC, 0xC1, 0x93, 0xB6, 0x54, 0x4E, 0x91,
+	0x91, 0x51, 0x69, 0xCB, 0x02, 0x7C, 0x25, 0x01, 0x01, 0x00, 0x00, 0x04,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+{0x85, 0x03, 0x00, 0x00, 0x26, 0x06, 0x05, 0x1F, 0x05, 0xD5, 0x94, 0x4E, 0xB1,
+	0x89, 0x53, 0x5D, 0x7D, 0xE1, 0x9C, 0xF2, 0x01, 0x01, 0x00, 0x00, 0x34,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+{0x85, 0x04, 0x00, 0x00, 0x54, 0x6C, 0x53, 0x28, 0x99, 0xCF, 0x27, 0x4F, 0xA6,
+	0xF3, 0x49, 0x97, 0x41, 0xBA, 0xAD, 0xFE, 0x01, 0x01, 0x00, 0x00, 0x80,
+	0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00},
+{0x85, 0x05, 0x00, 0x00, 0x58, 0xCD, 0xAE, 0x33, 0x79, 0xB6, 0x54, 0x4E, 0x9B,
+	0xD9, 0xA0, 0x4D, 0x34, 0xF0, 0xC2, 0x26, 0x01, 0x01, 0x00, 0x00, 0x00,
+	0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+{0x85, 0x06, 0x00, 0x00, 0x2E, 0x9A, 0x57, 0xBB, 0x54, 0xCC, 0x50, 0x44, 0xB1,
+	0xD0, 0x5E, 0x75, 0x20, 0xDC, 0xAD, 0x25, 0x01, 0x01, 0x00, 0x00, 0x04,
+	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+
+};
+
+#define	NUM_STATIC_CLIENTS	6
+
+#endif /* DEBUG_FW_BOOT_SEQ */
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static  void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+/* #define dev_dbg dev_err */
+
+/**
+ * heci_hbm_me_cl_allocate - allocates storage for me clients
+ *
+ * @dev: the device structure
+ *
+	 * returns none.
+ */
+static void heci_hbm_me_cl_allocate(struct heci_device *dev)
+{
+	struct heci_me_client *clients;
+	int b;
+
+	/* count how many ME clients we have */
+	for_each_set_bit(b, dev->me_clients_map, HECI_CLIENTS_MAX)
+		dev->me_clients_num++;
+
+	if (dev->me_clients_num <= 0)
+		return;
+
+	kfree(dev->me_clients);
+	dev->me_clients = NULL;
+
+	dev_dbg(&dev->pdev->dev, "memory allocation for ME clients size=%zd.\n",
+		dev->me_clients_num * sizeof(struct heci_me_client));
+
+	/* allocate storage for ME clients representation */
+	clients = kcalloc(dev->me_clients_num, sizeof(struct heci_me_client),
+		GFP_ATOMIC);
+	if (!clients) {
+		dev_err(&dev->pdev->dev, "memory allocation for ME clients failed.\n");
+		dev->dev_state = HECI_DEV_RESETTING;
+		heci_reset(dev, 1);
+		return;
+	}
+	dev->me_clients = clients;
+	return;
+}
+
+/**
+ * heci_hbm_cl_hdr - construct client hbm header
+ * @cl: - client
+ * @hbm_cmd: host bus message command
+ * @buf: buffer for cl header
+ * @len: buffer length
+ */
+static inline void heci_hbm_cl_hdr(struct heci_cl *cl, u8 hbm_cmd, void *buf,
+	size_t len)
+{
+	struct heci_hbm_cl_cmd *cmd = buf;
+
+	memset(cmd, 0, len);
+
+	cmd->hbm_cmd = hbm_cmd;
+	cmd->host_addr = cl->host_client_id;
+	cmd->me_addr = cl->me_client_id;
+}
+
+/**
+ * same_disconn_addr - tells if they have the same address
+ *
+ * @file: private data of the file object.
+ * @disconn: disconnection request.
+ *
+ * returns true if addres are same
+ */
+static inline bool heci_hbm_cl_addr_equal(struct heci_cl *cl, void *buf)
+{
+	struct heci_hbm_cl_cmd *cmd = buf;
+	return cl->host_client_id == cmd->host_addr &&
+		cl->me_client_id == cmd->me_addr;
+}
+
+
+int heci_hbm_start_wait(struct heci_device *dev)
+{
+	int ret;
+	if (dev->hbm_state > HECI_HBM_START)
+		return 0;
+
+	dev_err(&dev->pdev->dev, "Going to wait for heci start hbm_state=%08X\n",
+		dev->hbm_state);
+	ret = wait_event_timeout(dev->wait_hbm_recvd_msg,
+			dev->hbm_state >= HECI_HBM_STARTED,
+			(HECI_INTEROP_TIMEOUT * HZ));
+
+	dev_err(&dev->pdev->dev, "Woke up from waiting for heci start ret=%d hbm_state=%08X\n",
+		ret, dev->hbm_state);
+
+	if (ret <= 0 && (dev->hbm_state <= HECI_HBM_START)) {
+		dev->hbm_state = HECI_HBM_IDLE;
+		dev_err(&dev->pdev->dev, "wating for heci start failed ret=%d hbm_state=%08X\n",
+			ret, dev->hbm_state);
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
+
+/**
+ * heci_hbm_start_req - sends start request message.
+ *
+ * @dev: the device structure
+ */
+int heci_hbm_start_req(struct heci_device *dev)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct hbm_host_version_request *start_req;
+	const size_t len = sizeof(struct hbm_host_version_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+
+	/* host start message */
+	start_req = (struct hbm_host_version_request *)data;
+	memset(start_req, 0, len);
+	start_req->hbm_cmd = HOST_START_REQ_CMD;
+	start_req->host_version.major_version = HBM_MAJOR_VERSION;
+	start_req->host_version.minor_version = HBM_MINOR_VERSION;
+
+	/*
+	 * (!) Response to HBM start may be so quick that this thread would get
+	 * preempted BEFORE managing to set hbm_state = HECI_HBM_START.
+	 * So set it at first, change back to HECI_HBM_IDLE upon failure
+	 */
+	dev->hbm_state = HECI_HBM_START;
+	if (heci_write_message(dev, heci_hdr, data)) {
+		dev_err(&dev->pdev->dev, "version message write failed\n");
+		dev->dev_state = HECI_DEV_RESETTING;
+		dev->hbm_state = HECI_HBM_IDLE;
+		heci_reset(dev, 1);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(heci_hbm_start_req);
+
+/*
+ * heci_hbm_enum_clients_req - sends enumeration client request message.
+ *
+ * @dev: the device structure
+ *
+ * returns none.
+ */
+void heci_hbm_enum_clients_req(struct heci_device *dev)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct hbm_host_enum_request *enum_req;
+	const size_t len = sizeof(struct hbm_host_enum_request);
+	/* enumerate clients */
+	heci_hbm_hdr(heci_hdr, len);
+
+	enum_req = (struct hbm_host_enum_request *)data;
+	memset(enum_req, 0, len);
+	enum_req->hbm_cmd = HOST_ENUM_REQ_CMD;
+
+	if (heci_write_message(dev, heci_hdr, data)) {
+		dev->dev_state = HECI_DEV_RESETTING;
+		dev_err(&dev->pdev->dev, "enumeration request write failed.\n");
+		heci_reset(dev, 1);
+	}
+	dev->hbm_state = HECI_HBM_ENUM_CLIENTS;
+	return;
+}
+
+/**
+ * heci_hbm_prop_requsest - request property for a single client
+ *
+ * @dev: the device structure
+ *
+ * returns none.
+ */
+
+static int heci_hbm_prop_req(struct heci_device *dev)
+{
+
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	struct hbm_props_request *prop_req;
+	const size_t len = sizeof(struct hbm_props_request);
+	unsigned long next_client_index;
+	u8 client_num;
+
+	client_num = dev->me_client_presentation_num;
+
+	next_client_index = find_next_bit(dev->me_clients_map, HECI_CLIENTS_MAX,
+		dev->me_client_index);
+
+	/* We got all client properties */
+	if (next_client_index == HECI_CLIENTS_MAX) {
+		dev->hbm_state = HECI_HBM_WORKING;
+		dev->dev_state = HECI_DEV_ENABLED;
+
+		for (dev->me_client_presentation_num = 1;
+			dev->me_client_presentation_num < client_num + 1;
+				++dev->me_client_presentation_num)
+			/* Add new client device */
+			heci_bus_new_client(dev);
+		return 0;
+	}
+
+	dev->me_clients[client_num].client_id = next_client_index;
+
+#ifndef DEBUG_FW_BOOT_SEQ
+	heci_hbm_hdr(heci_hdr, len);
+	prop_req = (struct hbm_props_request *)data;
+
+	memset(prop_req, 0, sizeof(struct hbm_props_request));
+
+	prop_req->hbm_cmd = HOST_CLIENT_PROPERTIES_REQ_CMD;
+	prop_req->address = next_client_index;
+
+	if (heci_write_message(dev, heci_hdr, data)) {
+		dev->dev_state = HECI_DEV_RESETTING;
+		dev_err(&dev->pdev->dev, "properties request write failed\n");
+		heci_reset(dev, 1);
+		return -EIO;
+	}
+#endif /*DEBUG_FW_BOOT_SEQ*/
+
+	dev->me_client_index = next_client_index;
+
+#ifdef DEBUG_FW_BOOT_SEQ
+	heci_hbm_dispatch(dev,
+		(struct heci_bus_message *)static_fw_cl_props[client_num]);
+#endif /*DEBUG_FW_BOOT_SEQ*/
+
+	return 0;
+}
+
+/**
+ * heci_hbm_stop_req_prepare - perpare stop request message
+ *
+ * @dev - heci device
+ * @heci_hdr - heci message header
+ * @data - hbm message body buffer
+ */
+static void heci_hbm_stop_req_prepare(struct heci_device *dev,
+	struct heci_msg_hdr *heci_hdr, unsigned char *data)
+{
+	struct hbm_host_stop_request *req =
+		(struct hbm_host_stop_request *)data;
+	const size_t len = sizeof(struct hbm_host_stop_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+
+	memset(req, 0, len);
+	req->hbm_cmd = HOST_STOP_REQ_CMD;
+	req->reason = DRIVER_STOP_REQUEST;
+}
+
+/**
+ * heci_hbm_cl_flow_control_req - sends flow control requst.
+ *
+ * @dev: the device structure
+ * @cl: client info
+ *
+ * This function returns -EIO on write failure
+ */
+int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	const size_t len = sizeof(struct hbm_flow_control);
+	int	rv;
+	unsigned	num_frags;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&cl->fc_spinlock, flags);
+	heci_hbm_hdr(heci_hdr, len);
+	heci_hbm_cl_hdr(cl, HECI_FLOW_CONTROL_CMD, data, len);
+
+	dev_dbg(&dev->pdev->dev, "sending flow control host client = %d, ME client = %d\n",
+		cl->host_client_id, cl->me_client_id);
+
+	/* Sync possible race when RB recycle and packet receive paths
+	   both try to send an out FC */
+	if (cl->out_flow_ctrl_creds) {
+		spin_unlock_irqrestore(&cl->fc_spinlock, flags);
+		return	0;
+	}
+
+	num_frags = cl->recv_msg_num_frags;
+	cl->recv_msg_num_frags = 0;
+
+	rv = heci_write_message(dev, heci_hdr, data);
+	if (!rv) {
+		struct timeval	tv;
+
+		++cl->out_flow_ctrl_creds;
+		++cl->out_flow_ctrl_cnt;
+		do_gettimeofday(&tv);
+		cl->out_fc_sec = tv.tv_sec;
+		cl->out_fc_usec = tv.tv_usec;
+		if (cl->rx_sec && cl->rx_usec) {
+			unsigned long	s, us;
+
+			s = cl->out_fc_sec - cl->rx_sec;
+			us = cl->out_fc_usec - cl->rx_usec;
+			if (cl->rx_usec > cl->out_fc_usec) {
+				us += 1000000UL;
+				--s;
+			}
+			if (s > cl->max_fc_delay_sec ||
+					s == cl->max_fc_delay_sec &&
+					us > cl->max_fc_delay_usec) {
+				cl->max_fc_delay_sec = s;
+				cl->max_fc_delay_usec = us;
+			}
+		}
+	} else {
+		++cl->err_send_fc;
+	}
+
+	spin_unlock_irqrestore(&cl->fc_spinlock, flags);
+	return	rv;
+}
+EXPORT_SYMBOL(heci_hbm_cl_flow_control_req);
+
+/*
+ * heci_hbm_cl_disconnect_req - sends disconnect message to fw.
+ *
+ * @dev: the device structure
+ * @cl: a client to disconnect from
+ *
+ * This function returns -EIO on write failure
+ */
+int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	const size_t len = sizeof(struct hbm_client_connect_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+	heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_REQ_CMD, data, len);
+
+	return heci_write_message(dev, heci_hdr, data);
+}
+
+/*
+ * heci_hbm_cl_disconnect_res - disconnect response from ME
+ *
+ * @dev: the device structure
+ * @rs: disconnect response bus message
+ */
+static void heci_hbm_cl_disconnect_res(struct heci_device *dev,
+	struct hbm_client_connect_response *rs)
+{
+	struct heci_cl *cl = NULL, *next = NULL;
+	unsigned long	flags;
+
+	dev_dbg(&dev->pdev->dev,
+			"disconnect_response:\n"
+			"ME Client = %d\n"
+			"Host Client = %d\n"
+			"Status = %d\n",
+			rs->me_addr,
+			rs->host_addr,
+			rs->status);
+
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (!rs->status && heci_hbm_cl_addr_equal(cl, rs)) {
+			cl->state = HECI_CL_DISCONNECTED;
+			break;
+		}
+	}
+	if (cl)
+		wake_up(&cl->wait_ctrl_res);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+}
+
+/**
+ * heci_hbm_cl_connect_req - send connection request to specific me client
+ *
+ * @dev: the device structure
+ * @cl: a client to connect to
+ *
+ * returns -EIO on write failure
+ */
+int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl)
+{
+	struct heci_msg_hdr hdr;
+	unsigned char data[128];
+	struct heci_msg_hdr *heci_hdr = &hdr;
+	const size_t len = sizeof(struct hbm_client_connect_request);
+
+	heci_hbm_hdr(heci_hdr, len);
+	heci_hbm_cl_hdr(cl, CLIENT_CONNECT_REQ_CMD, data, len);
+
+	return heci_write_message(dev, heci_hdr,  data);
+}
+EXPORT_SYMBOL(heci_hbm_cl_connect_req);
+
+/**
+ * heci_hbm_cl_connect_res - connect resposne from the ME
+ *
+ * @dev: the device structure
+ * @rs: connect response bus message
+ */
+static void heci_hbm_cl_connect_res(struct heci_device *dev,
+	struct hbm_client_connect_response *rs)
+{
+	struct heci_cl *cl = NULL, *next = NULL;
+	unsigned long	flags;
+
+	dev_dbg(&dev->pdev->dev,
+			"connect_response:\n"
+			"ME Client = %d\n"
+			"Host Client = %d\n"
+			"Status = %d\n",
+			rs->me_addr,
+			rs->host_addr,
+			rs->status);
+
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (heci_hbm_cl_addr_equal(cl, rs)) {
+			if (!rs->status) {
+				cl->state = HECI_CL_CONNECTED;
+				cl->status = 0;
+			} else {
+				cl->state = HECI_CL_DISCONNECTED;
+				cl->status = -ENODEV;
+			}
+			break;
+		}
+	}
+	if (cl)
+		wake_up(&cl->wait_ctrl_res);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+}
+
+
+/**
+ * heci_client_disconnect_request - disconnect request initiated by me
+ *  host sends disoconnect response
+ *
+ * @dev: the device structure.
+ * @disconnect_req: disconnect request bus message from the me
+ */
+static void heci_hbm_fw_disconnect_req(struct heci_device *dev,
+	struct hbm_client_connect_request *disconnect_req)
+{
+	struct heci_cl *cl, *next;
+	const size_t len = sizeof(struct hbm_client_connect_response);
+	unsigned long	flags;
+	struct heci_msg_hdr hdr;
+	unsigned char data[4];	/* All HBM messages are 4 bytes */
+
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+		if (heci_hbm_cl_addr_equal(cl, disconnect_req)) {
+			cl->state = HECI_CL_DISCONNECTED;
+
+			/* prepare disconnect response */
+			heci_hbm_hdr(&hdr, len);
+			heci_hbm_cl_hdr(cl, CLIENT_DISCONNECT_RES_CMD, data,
+				len);
+			heci_write_message(dev, &hdr, data);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+}
+
+
+/**
+ * heci_hbm_dispatch - bottom half read routine after ISR to
+ * handle the read bus message cmd processing.
+ *
+ * @dev: the device structure
+ * @hdr: header of bus message
+ */
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
+{
+	struct heci_bus_message *heci_msg;
+	struct heci_me_client *me_client;
+	struct hbm_host_version_response *version_res;
+	struct hbm_client_connect_response *connect_res;
+	struct hbm_client_connect_response *disconnect_res;
+	struct hbm_client_connect_request *disconnect_req;
+	struct hbm_props_response *props_res;
+	struct hbm_host_enum_response *enum_res;
+	struct heci_msg_hdr heci_hdr;
+	unsigned char data[4];	/* All HBM messages are 4 bytes */
+
+	heci_msg = hdr;
+	dev_dbg(&dev->pdev->dev, "bus cmd = %lu\n", heci_msg->hbm_cmd);
+
+	switch (heci_msg->hbm_cmd) {
+	case HOST_START_RES_CMD:
+		version_res = (struct hbm_host_version_response *)heci_msg;
+		if (!version_res->host_version_supported) {
+			dev->version = version_res->me_max_version;
+			dev_dbg(&dev->pdev->dev, "version mismatch.\n");
+
+			dev->hbm_state = HECI_HBM_STOPPED;
+			heci_hbm_stop_req_prepare(dev, &heci_hdr, data);
+			heci_write_message(dev, &heci_hdr, data);
+			return;
+		}
+
+		dev->version.major_version = HBM_MAJOR_VERSION;
+		dev->version.minor_version = HBM_MINOR_VERSION;
+		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
+		    dev->hbm_state == HECI_HBM_START) {
+			dev->hbm_state = HECI_HBM_STARTED;
+			heci_hbm_enum_clients_req(dev);
+		} else {
+			dev_err(&dev->pdev->dev, "reset: wrong host start response\n");
+			/* BUG: why do we arrive here? */
+			heci_reset(dev, 1);
+			return;
+		}
+
+		wake_up(&dev->wait_hbm_recvd_msg);
+		dev_dbg(&dev->pdev->dev, "host start response message received.\n");
+		break;
+
+	case CLIENT_CONNECT_RES_CMD:
+		connect_res = (struct hbm_client_connect_response *)heci_msg;
+		heci_hbm_cl_connect_res(dev, connect_res);
+		dev_dbg(&dev->pdev->dev, "client connect response message received.\n");
+		break;
+
+	case CLIENT_DISCONNECT_RES_CMD:
+		disconnect_res = (struct hbm_client_connect_response *)heci_msg;
+		heci_hbm_cl_disconnect_res(dev, disconnect_res);
+		dev_dbg(&dev->pdev->dev, "client disconnect response message received.\n");
+		break;
+
+	case HOST_CLIENT_PROPERTIES_RES_CMD:
+		props_res = (struct hbm_props_response *)heci_msg;
+		me_client = &dev->me_clients[dev->me_client_presentation_num];
+
+#ifdef DUMP_CL_PROP
+		/* DEBUG -- dump complete response */
+		do {
+			int	i;
+
+			dev->print_log(dev,
+				"%s(): HOST_CLIENT_PROPERTIES_RES_CMD, client# = %d props: ",
+				__func__, dev->me_client_presentation_num);
+			for (i = 0; i < sizeof(struct hbm_props_response); ++i)
+				dev->print_log(dev, "%02X ",
+					*(((unsigned char *)props_res) + i));
+			dev->print_log(dev, "\n");
+		} while (0);
+#endif /*DUMP_CL_PROP*/
+
+		if (props_res->status || !dev->me_clients) {
+			dev_err(&dev->pdev->dev, "reset: properties response hbm wrong status.\n");
+			heci_reset(dev, 1);
+			return;
+		}
+
+		if (me_client->client_id != props_res->address) {
+			dev_err(&dev->pdev->dev,
+"reset: host properties response address mismatch [%02X %02X]\n",
+				me_client->client_id, props_res->address);
+			heci_reset(dev, 1);
+			return;
+		}
+
+		if (dev->dev_state != HECI_DEV_INIT_CLIENTS ||
+		    dev->hbm_state != HECI_HBM_CLIENT_PROPERTIES) {
+			dev_err(&dev->pdev->dev,
+				"reset: unexpected properties response\n");
+			heci_reset(dev, 1);
+			return;
+		}
+
+		me_client->props = props_res->client_properties;
+		dev->me_client_index++;
+		dev->me_client_presentation_num++;
+
+#if 0
+		/* Add new client device */
+		heci_bus_new_client(dev);
+#endif
+
+		/* request property for the next client */
+		heci_hbm_prop_req(dev);
+
+		break;
+
+	case HOST_ENUM_RES_CMD:
+		enum_res = (struct hbm_host_enum_response *) heci_msg;
+		memcpy(dev->me_clients_map, enum_res->valid_addresses, 32);
+		if (dev->dev_state == HECI_DEV_INIT_CLIENTS &&
+		    dev->hbm_state == HECI_HBM_ENUM_CLIENTS) {
+				dev->me_client_presentation_num = 0;
+				dev->me_client_index = 0;
+
+				heci_hbm_me_cl_allocate(dev);
+				dev->hbm_state = HECI_HBM_CLIENT_PROPERTIES;
+
+				/* first property request */
+				heci_hbm_prop_req(dev);
+		} else {
+			dev_err(&dev->pdev->dev, "reset: unexpected enumeration response hbm.\n");
+			heci_reset(dev, 1);
+			return;
+		}
+		break;
+
+	case HOST_STOP_RES_CMD:
+		if (dev->hbm_state != HECI_HBM_STOPPED)
+			dev_err(&dev->pdev->dev, "unexpected stop response.\n");
+
+		dev->dev_state = HECI_DEV_DISABLED;
+		dev_info(&dev->pdev->dev, "reset: FW stop response.\n");
+		heci_reset(dev, 1);
+		break;
+
+	case CLIENT_DISCONNECT_REQ_CMD:
+		/* search for client */
+		disconnect_req = (struct hbm_client_connect_request *)heci_msg;
+		heci_hbm_fw_disconnect_req(dev, disconnect_req);
+		break;
+
+	case ME_STOP_REQ_CMD:
+		dev->hbm_state = HECI_HBM_STOPPED;
+		break;
+
+	case CLIENT_DMA_RES_CMD:
+		/*
+		 * TODO: wake up anybody who could be
+		 * waiting for DMA completion
+		 */
+		dma_ready = 1;
+		if (waitqueue_active(&dev->wait_dma_ready))
+			wake_up(&dev->wait_dma_ready);
+		break;
+
+	default:
+		/*BUG();*/
+		dev_err(&dev->pdev->dev, "unknown HBM: %u\n",
+			(unsigned)heci_msg->hbm_cmd);
+		break;
+
+	}
+}
+EXPORT_SYMBOL(heci_hbm_dispatch);
+
+
+/*
+ *	Receive and process HECI bus messages
+ *
+ *	(!) ISR context
+ */
+void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+{
+	uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
+	struct heci_bus_message	*heci_msg =
+		(struct heci_bus_message *)rd_msg_buf;
+	unsigned long	flags;
+
+	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
+
+	/* Flow control - handle in place */
+	if (heci_msg->hbm_cmd == HECI_FLOW_CONTROL_CMD) {
+		struct hbm_flow_control *flow_control =
+			(struct hbm_flow_control *)heci_msg;
+		struct heci_cl *cl = NULL;
+		struct heci_cl *next = NULL;
+		unsigned long	flags, tx_flags;
+
+		ISH_DBG_PRINT(KERN_ALERT
+			"%s(): HECI_FLOW_CONTROL_CMD, checking to whom (host_addr=%d me_addr=%d\n",
+			__func__, flow_control->host_addr,
+			flow_control->me_addr);
+		spin_lock_irqsave(&dev->cl_list_lock, flags);
+		list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
+			if (cl->host_client_id == flow_control->host_addr &&
+					cl->me_client_id ==
+					flow_control->me_addr) {
+				/*##########################################*/
+				/*
+				 * FIXME: It's valid only for counting
+				 * flow-control implementation to receive a
+				 * FC in the middle of sending
+				 */
+				if (cl->heci_flow_ctrl_creds)
+					dev_err(&dev->pdev->dev,
+						"recv extra FC from FW client %u (host client %u) (FC count was %u)\n",
+						(unsigned)cl->me_client_id,
+						(unsigned)cl->host_client_id,
+					(unsigned)cl->heci_flow_ctrl_creds);
+				else {
+					if (cl->host_client_id == 3 &&
+							cl->me_client_id == 5) {
+						++dev->ipc_hid_in_fc;
+						++dev->ipc_hid_in_fc_cnt;
+					}
+					++cl->heci_flow_ctrl_creds;
+					++cl->heci_flow_ctrl_cnt;
+					spin_lock_irqsave(&cl->tx_list_spinlock,
+						tx_flags);
+				if (!list_empty(&cl->tx_list.list)) {
+					/*
+					 * start sending the first msg
+					 *	= the callback function
+					 */
+					spin_unlock_irqrestore(
+							&cl->tx_list_spinlock,
+							tx_flags);
+					heci_cl_send_msg(dev, cl);
+				} else {
+						spin_unlock_irqrestore(
+							&cl->tx_list_spinlock,
+							tx_flags);
+					}
+				}
+				break;
+				/*##########################################*/
+			}
+		}
+		spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+		goto	eoi;
+	}
+
+	/*
+	 * Some messages that are safe for ISR processing and important
+	 * to be done "quickly" and in-order, go here
+	 */
+	if (heci_msg->hbm_cmd == CLIENT_CONNECT_RES_CMD ||
+			heci_msg->hbm_cmd == CLIENT_DISCONNECT_RES_CMD ||
+			heci_msg->hbm_cmd == CLIENT_DISCONNECT_REQ_CMD) {
+		heci_hbm_dispatch(dev, heci_msg);
+		goto	eoi;
+	}
+
+	/* TODO: revise, may be some don't need BH as well */
+	/*
+	 * All other HBMs go here.
+	 * We schedule HBMs for processing serially,
+	 * possibly there will be multiplpe HBMs scheduled at the same time.
+	 * System wq itself is a serializing means
+	 */
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	if ((dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %
+			(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE) ==
+			dev->rd_msg_fifo_head) {
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+		dev_err(&dev->pdev->dev, "BH buffer overflow, dropping HBM %u\n",
+			(unsigned)heci_msg->hbm_cmd);
+		goto	eoi;
+	}
+	memcpy(dev->rd_msg_fifo + dev->rd_msg_fifo_tail, heci_msg,
+		heci_hdr->length);
+	dev->rd_msg_fifo_tail = (dev->rd_msg_fifo_tail + IPC_PAYLOAD_SIZE) %
+		(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
+	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+	schedule_work(&dev->bh_hbm_work);
+eoi:
+	return;
+}
+EXPORT_SYMBOL(recv_hbm);
+
+/*
+ *      Receive and process HECI fixed client messages
+ *
+ *      (!) ISR context
+ */
+void recv_fixed_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
+{
+	uint8_t rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
+
+	dev->print_log(dev,
+		"%s() got fixed client msg from client #%d\n",
+		__func__, heci_hdr->me_addr);
+	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
+	if (heci_hdr->me_addr == HECI_SYSTEM_STATE_CLIENT_ADDR) {
+		struct ish_system_states_header *msg_hdr =
+			(struct ish_system_states_header *)rd_msg_buf;
+		if (msg_hdr->cmd == SYSTEM_STATE_SUBSCRIBE)
+			send_resume(dev);       /* if FW request arrived here,
+						the system is not suspended */
+		else
+			dev_err(&dev->pdev->dev,
+				"unknown fixed client msg [%02X]\n",
+				msg_hdr->cmd);
+	}
+}
+EXPORT_SYMBOL(recv_fixed_cl_msg);
+
+static inline void fix_cl_hdr(struct heci_msg_hdr *hdr, size_t length,
+	u8 cl_addr)
+{
+	hdr->host_addr = 0;
+	hdr->me_addr = cl_addr;
+	hdr->length = length;
+	hdr->msg_complete = 1;
+	hdr->reserved = 0;
+}
+
+/* Suspend and resume notification*/
+
+/*Global var for suspend & resume*/
+u32 current_state = 0;
+u32 supported_states = 0 | SUSPEND_STATE_BIT;
+
+void send_suspend(struct heci_device *dev)
+{
+	struct heci_msg_hdr     heci_hdr;
+	struct ish_system_states_status state_status_msg;
+	const size_t len = sizeof(struct ish_system_states_status);
+
+	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
+
+	memset(&state_status_msg, 0, len);
+	state_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;
+	state_status_msg.supported_states = supported_states;
+	current_state |= SUSPEND_STATE_BIT;
+	dev->print_log(dev, "%s() sends SUSPEND notification\n", __func__);
+	state_status_msg.states_status = current_state;
+
+	heci_write_message(dev, &heci_hdr, &state_status_msg);
+}
+EXPORT_SYMBOL(send_suspend);
+
+void send_resume(struct heci_device *dev)
+{
+	struct heci_msg_hdr     heci_hdr;
+	struct ish_system_states_status state_status_msg;
+	const size_t len = sizeof(struct ish_system_states_status);
+
+	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
+
+	memset(&state_status_msg, 0, len);
+	state_status_msg.hdr.cmd = SYSTEM_STATE_STATUS;
+	state_status_msg.supported_states = supported_states;
+	current_state &= ~SUSPEND_STATE_BIT;
+	dev->print_log(dev, "%s() sends RESUME notification\n", __func__);
+	state_status_msg.states_status = current_state;
+
+	heci_write_message(dev, &heci_hdr, &state_status_msg);
+}
+EXPORT_SYMBOL(send_resume);
+
+void query_subscribers(struct heci_device *dev)
+{
+	struct heci_msg_hdr     heci_hdr;
+	struct ish_system_states_query_subscribers query_subscribers_msg;
+	const size_t len = sizeof(struct ish_system_states_query_subscribers);
+
+	fix_cl_hdr(&heci_hdr, len, HECI_SYSTEM_STATE_CLIENT_ADDR);
+
+	memset(&query_subscribers_msg, 0, len);
+	query_subscribers_msg.hdr.cmd = SYSTEM_STATE_QUERY_SUBSCRIBERS;
+
+	heci_write_message(dev, &heci_hdr, &query_subscribers_msg);
+}
+
diff --git a/drivers/misc/intel-ish/hbm.h b/drivers/misc/intel-ish/hbm.h
new file mode 100644
index 0000000..94eb0ab
--- /dev/null
+++ b/drivers/misc/intel-ish/hbm.h
@@ -0,0 +1,369 @@
+/*
+ * HECI bus layer messages handling
+ *
+ * Copyright (c) 2003-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_HBM_H_
+#define _HECI_HBM_H_
+
+#include <linux/uuid.h>
+
+struct heci_device;
+struct heci_msg_hdr;
+struct heci_cl;
+
+/*
+ * Timeouts in Seconds
+ */
+#define HECI_INTEROP_TIMEOUT         7  /* Timeout on ready message */
+#define HECI_CONNECT_TIMEOUT         3  /* HPS: at least 2 seconds */
+
+#define HECI_CL_CONNECT_TIMEOUT     15  /* HPS: Client Connect Timeout */
+#define HECI_CLIENTS_INIT_TIMEOUT   15  /* HPS: Clients Enumeration Timeout */
+
+#if 0
+#define HECI_IAMTHIF_STALL_TIMER    12  /* HPS */
+#define HECI_IAMTHIF_READ_TIMER     10  /* HPS */
+#endif
+
+
+/*
+ * HECI Version
+ */
+#define HBM_MINOR_VERSION                   0
+#define HBM_MAJOR_VERSION                   1
+#define HBM_TIMEOUT                         1	/* 1 second */
+
+/* Host bus message command opcode */
+#define HECI_HBM_CMD_OP_MSK                  0x7f
+/* Host bus message command RESPONSE */
+#define HECI_HBM_CMD_RES_MSK                 0x80
+
+/*
+ * HECI Bus Message Command IDs
+ */
+#define HOST_START_REQ_CMD                  0x01
+#define HOST_START_RES_CMD                  0x81
+
+#define HOST_STOP_REQ_CMD                   0x02
+#define HOST_STOP_RES_CMD                   0x82
+
+#define ME_STOP_REQ_CMD                     0x03
+
+#define HOST_ENUM_REQ_CMD                   0x04
+#define HOST_ENUM_RES_CMD                   0x84
+
+#define HOST_CLIENT_PROPERTIES_REQ_CMD      0x05
+#define HOST_CLIENT_PROPERTIES_RES_CMD      0x85
+
+#define CLIENT_CONNECT_REQ_CMD              0x06
+#define CLIENT_CONNECT_RES_CMD              0x86
+
+#define CLIENT_DISCONNECT_REQ_CMD           0x07
+#define CLIENT_DISCONNECT_RES_CMD           0x87
+
+#define HECI_FLOW_CONTROL_CMD                0x08
+
+#define CLIENT_DMA_REQ_CMD		0x10
+#define CLIENT_DMA_RES_CMD		0x90
+
+/*
+ * HECI Stop Reason
+ * used by hbm_host_stop_request.reason
+ */
+enum heci_stop_reason_types {
+	DRIVER_STOP_REQUEST = 0x00,
+	DEVICE_D1_ENTRY = 0x01,
+	DEVICE_D2_ENTRY = 0x02,
+	DEVICE_D3_ENTRY = 0x03,
+	SYSTEM_S1_ENTRY = 0x04,
+	SYSTEM_S2_ENTRY = 0x05,
+	SYSTEM_S3_ENTRY = 0x06,
+	SYSTEM_S4_ENTRY = 0x07,
+	SYSTEM_S5_ENTRY = 0x08
+};
+
+/*
+ * Client Connect Status
+ * used by hbm_client_connect_response.status
+ */
+enum client_connect_status_types {
+	CCS_SUCCESS = 0x00,
+	CCS_NOT_FOUND = 0x01,
+	CCS_ALREADY_STARTED = 0x02,
+	CCS_OUT_OF_RESOURCES = 0x03,
+	CCS_MESSAGE_SMALL = 0x04
+};
+
+/*
+ * Client Disconnect Status
+ */
+enum client_disconnect_status_types {
+	CDS_SUCCESS = 0x00
+};
+
+/*
+ *  HECI BUS Interface Section
+ */
+struct heci_msg_hdr {
+	u32 me_addr:8;
+	u32 host_addr:8;
+	u32 length:9;
+	u32 reserved:6;
+	u32 msg_complete:1;
+} __packed;
+
+
+struct heci_bus_message {
+	u8 hbm_cmd;
+	u8 data[0];
+} __packed;
+
+/**
+ * struct hbm_cl_cmd - client specific host bus command
+ *	CONNECT, DISCONNECT, and FlOW CONTROL
+ *
+ * @hbm_cmd - bus message command header
+ * @me_addr - address of the client in ME
+ * @host_addr - address of the client in the driver
+ * @data
+ */
+struct heci_hbm_cl_cmd {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 data;
+};
+
+struct hbm_version {
+	u8 minor_version;
+	u8 major_version;
+} __packed;
+
+struct hbm_host_version_request {
+	u8 hbm_cmd;
+	u8 reserved;
+	struct hbm_version host_version;
+} __packed;
+
+struct hbm_host_version_response {
+	u8 hbm_cmd;
+	u8 host_version_supported;
+	struct hbm_version me_max_version;
+} __packed;
+
+struct hbm_host_stop_request {
+	u8 hbm_cmd;
+	u8 reason;
+	u8 reserved[2];
+} __packed;
+
+struct hbm_host_stop_response {
+	u8 hbm_cmd;
+	u8 reserved[3];
+} __packed;
+
+struct hbm_me_stop_request {
+	u8 hbm_cmd;
+	u8 reason;
+	u8 reserved[2];
+} __packed;
+
+struct hbm_host_enum_request {
+	u8 hbm_cmd;
+	u8 reserved[3];
+} __packed;
+
+struct hbm_host_enum_response {
+	u8 hbm_cmd;
+	u8 reserved[3];
+	u8 valid_addresses[32];
+} __packed;
+
+struct heci_client_properties {
+	uuid_le protocol_name;
+	u8 protocol_version;
+	u8 max_number_of_connections;
+	u8 fixed_address;
+	u8 single_recv_buf;
+	u32 max_msg_length;
+	u8 dma_hdr_len;
+#define	HECI_CLIENT_DMA_ENABLED	0x80
+	u8 reserved4;
+	u8 reserved5;
+	u8 reserved6;
+} __packed;
+
+struct hbm_props_request {
+	u8 hbm_cmd;
+	u8 address;
+	u8 reserved[2];
+} __packed;
+
+
+struct hbm_props_response {
+	u8 hbm_cmd;
+	u8 address;
+	u8 status;
+	u8 reserved[1];
+	struct heci_client_properties client_properties;
+} __packed;
+
+/**
+ * struct hbm_client_connect_request - connect/disconnect request
+ *
+ * @hbm_cmd - bus message command header
+ * @me_addr - address of the client in ME
+ * @host_addr - address of the client in the driver
+ * @reserved
+ */
+struct hbm_client_connect_request {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 reserved;
+} __packed;
+
+/**
+ * struct hbm_client_connect_response - connect/disconnect response
+ *
+ * @hbm_cmd - bus message command header
+ * @me_addr - address of the client in ME
+ * @host_addr - address of the client in the driver
+ * @status - status of the request
+ */
+struct hbm_client_connect_response {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 status;
+} __packed;
+
+
+#define HECI_FC_MESSAGE_RESERVED_LENGTH           5
+
+struct hbm_flow_control {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 reserved[HECI_FC_MESSAGE_RESERVED_LENGTH];
+} __packed;
+
+struct hbm_client_dma_request {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 reserved;
+	u64 msg_addr;
+	u32 msg_len;
+	u16 reserved2;
+	u16 msg_preview_len;
+	u8 msg_preview[12];
+} __packed;
+
+struct hbm_client_dma_response {
+	u8 hbm_cmd;
+	u8 me_addr;
+	u8 host_addr;
+	u8 status;
+	u64 msg_addr;
+	u32 msg_len;
+} __packed;
+
+/**
+ * enum heci_hbm_state - host bus message protocol state
+ *
+ * @HECI_HBM_IDLE : protocol not started
+ * @HECI_HBM_START : start request message was sent
+ * @HECI_HBM_ENUM_CLIENTS : enumeration request was sent
+ * @HECI_HBM_CLIENT_PROPERTIES : acquiring clients properties
+ */
+enum heci_hbm_state {
+	HECI_HBM_IDLE = 0,
+	HECI_HBM_START,
+	HECI_HBM_STARTED,
+	HECI_HBM_ENUM_CLIENTS,
+	HECI_HBM_CLIENT_PROPERTIES,
+	HECI_HBM_WORKING,
+	HECI_HBM_STOPPED,
+};
+
+#if 0
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_msg_hdr *hdr);
+#else
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
+#endif
+
+static inline void heci_hbm_hdr(struct heci_msg_hdr *hdr, size_t length)
+{
+	hdr->host_addr = 0;
+	hdr->me_addr = 0;
+	hdr->length = length;
+	hdr->msg_complete = 1;
+	hdr->reserved = 0;
+}
+
+int heci_hbm_start_req(struct heci_device *dev);
+int heci_hbm_start_wait(struct heci_device *dev);
+int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl);
+int heci_hbm_cl_disconnect_req(struct heci_device *dev, struct heci_cl *cl);
+int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl);
+void heci_hbm_enum_clients_req(struct heci_device *dev);
+void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
+
+/* System state */
+#define HECI_SYSTEM_STATE_CLIENT_ADDR 13
+
+#define SYSTEM_STATE_SUBSCRIBE                  0x1
+#define SYSTEM_STATE_STATUS                     0x2
+#define SYSTEM_STATE_QUERY_SUBSCRIBERS          0x3
+#define SYSTEM_STATE_STATE_CHANGE_REQ		0x4
+
+#define SUSPEND_STATE_BIT       (1<<1) /*indicates suspend and resume states*/
+
+#define ANDROID_EVENT_MASK	0xff000000
+
+struct ish_system_states_header {
+	u32 cmd;
+	u32 cmd_status;  /*responses will have this set*/
+} __packed;
+
+struct ish_system_states_subscribe {
+	struct ish_system_states_header hdr;
+	u32 states;
+} __packed;
+
+struct ish_system_states_status {
+	struct ish_system_states_header hdr;
+	u32 supported_states;
+	u32 states_status;
+} __packed;
+
+struct ish_system_states_query_subscribers {
+	struct ish_system_states_header hdr;
+} __packed;
+
+struct ish_system_states_state_change_req {
+	struct ish_system_states_header hdr;
+	u32 requested_states;
+	u32 states_status;
+} __packed;
+
+void send_suspend(struct heci_device *dev);
+void send_resume(struct heci_device *dev);
+void query_subscribers(struct heci_device *dev);
+
+void recv_fixed_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
+void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
+#endif /* _HECI_HBM_H_ */
+
diff --git a/drivers/misc/intel-ish/heci-api.c b/drivers/misc/intel-ish/heci-api.c
new file mode 100644
index 0000000..a056202
--- /dev/null
+++ b/drivers/misc/intel-ish/heci-api.c
@@ -0,0 +1,692 @@
+/*
+ * User-mode HECI API
+ *
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/aio.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/uuid.h>
+#include <linux/compat.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include "heci-api.h"
+#include "heci_dev.h"
+#include "client.h"
+#include "platform-config.h"
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static  void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+/*#define dev_dbg dev_err*/
+
+/**
+ * heci_open - the open function
+ *
+ * @inode: pointer to inode structure
+ * @file: pointer to file structure
+ e
+ * returns 0 on success, <0 on error
+ */
+static int heci_open(struct inode *inode, struct file *file)
+{
+	struct miscdevice *misc = file->private_data;
+	struct pci_dev *pdev;
+	struct heci_cl *cl;
+	struct heci_device *dev;
+	int err;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	err = -ENODEV;
+	if (!misc->parent)
+		goto out;
+
+	pdev = container_of(misc->parent, struct pci_dev, dev);
+
+	dev = pci_get_drvdata(pdev);
+	if (!dev)
+		goto out;
+
+	err = -ENOMEM;
+	cl = heci_cl_allocate(dev);
+	if (!cl)
+		goto out_free;
+
+	/*
+	 * We may have a case of issued open() with
+	 * dev->dev_state == HECI_DEV_DISABLED, as part of re-enabling path
+	 */
+	err = -ENODEV;
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		dev_dbg(&dev->pdev->dev, "dev_state != HECI_ENABLED  dev_state = %s\n",
+		    heci_dev_state_str(dev->dev_state));
+		goto out_free;
+	}
+
+	err = heci_cl_link(cl, HECI_HOST_CLIENT_ID_ANY);
+	if (err)
+		goto out_free;
+
+	file->private_data = cl;
+
+	return nonseekable_open(inode, file);
+
+out_free:
+	kfree(cl);
+out:
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	return err;
+}
+
+/**
+ * heci_release - the release function
+ *
+ * @inode: pointer to inode structure
+ * @file: pointer to file structure
+ *
+ * returns 0 on success, <0 on error
+ */
+static int heci_release(struct inode *inode, struct file *file)
+{
+	struct heci_cl *cl = file->private_data;
+	struct heci_device *dev;
+	int rets = 0;
+	unsigned int flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	/*
+	 * May happen if device sent FW reset or was intentionally
+	 * halted by host SW. The client is then invalid
+	 */
+	if (dev->dev_state != HECI_DEV_ENABLED)
+		return	0;
+
+	if (cl->state == HECI_CL_CONNECTED) {
+		cl->state = HECI_CL_DISCONNECTING;
+		dev_dbg(&dev->pdev->dev, "disconnecting client host client = %d, ME client = %d\n",
+			cl->host_client_id, cl->me_client_id);
+		rets = heci_cl_disconnect(cl);
+	}
+
+	dev_dbg(&dev->pdev->dev, "remove client host client = %d, ME client = %d\n",
+	    cl->host_client_id,
+	    cl->me_client_id);
+
+	heci_cl_unlink(cl);
+	heci_cl_flush_queues(cl);
+	file->private_data = NULL;
+
+	/* disband and free all Tx and Rx client-level rings */
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
+	heci_cl_free(cl);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	return rets;
+}
+
+
+/**
+ * heci_read - the read function.
+ *
+ * @file: pointer to file structure
+ * @ubuf: pointer to user buffer
+ * @length: buffer length
+ * @offset: data offset in buffer
+ *
+ * returns >=0 data length on success , <0 on error
+ */
+static ssize_t heci_read(struct file *file, char __user *ubuf,
+			size_t length, loff_t *offset)
+{
+	struct heci_cl *cl = file->private_data;
+	struct heci_cl_rb *rb = NULL;
+	struct heci_device *dev;
+	int rets;
+	unsigned long flags;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+/*
+ * EXPLAINME: handle reading message by fragments smaller than
+ * actual message size. Why needed? Reportedly, doesn't work: why?
+ */
+#if 0
+	if (cl->read_rb && cl->read_rb->buf_idx > *offset) {
+		rb = cl->read_rb;
+		goto copy_buffer;
+	} else if (cl->read_rb && cl->read_rb->buf_idx > 0 &&
+		   cl->read_rb->buf_idx <= *offset) {
+		rb = cl->read_rb;
+		rets = 0;
+		goto free;
+	} else if ((!cl->read_rb || !cl->read_rb->buf_idx) && *offset > 0) {
+		/*Offset needs to be cleaned for contiguous reads*/
+		*offset = 0;
+		rets = 0;
+		goto out;
+	}
+#endif
+
+	spin_lock_irqsave(&cl->in_process_spinlock, flags);
+	if (!list_empty(&cl->in_process_list.list)) {
+		rb = list_entry(cl->in_process_list.list.next,
+			struct heci_cl_rb, list);
+		list_del_init(&rb->list);
+		spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+		goto copy_buffer;
+	}
+	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
+
+	if (waitqueue_active(&cl->rx_wait)) {
+		rets = -EBUSY;
+		goto out;
+	}
+
+	if (wait_event_interruptible(cl->rx_wait,
+			(dev->dev_state == HECI_DEV_ENABLED &&
+			(cl->read_rb || HECI_CL_INITIALIZING == cl->state ||
+			HECI_CL_DISCONNECTED == cl->state ||
+			HECI_CL_DISCONNECTING == cl->state)))) {
+		dev_err(&dev->pdev->dev, "%s(): woke up not in success; sig. pending = %d signal = %08lX\n",
+			__func__, signal_pending(current),
+			current->pending.signal.sig[0]);
+		return	-ERESTARTSYS;
+	}
+
+	/*
+	 * If FW reset arrived, this will happen. Don't check cl->,
+	 * as 'cl' may be freed already
+	 */
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto	out;
+	}
+
+	if (HECI_CL_INITIALIZING == cl->state ||
+	    HECI_CL_DISCONNECTED == cl->state ||
+	    HECI_CL_DISCONNECTING == cl->state) {
+		rets = -EBUSY;
+		goto out;
+	}
+
+	rb = cl->read_rb;
+	if (!rb) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	/* now copy the data to user space */
+copy_buffer:
+	dev_dbg(&dev->pdev->dev, "buf.size = %d buf.idx= %ld\n",
+	    rb->buffer.size, rb->buf_idx);
+	if (length == 0 || ubuf == NULL || *offset > rb->buf_idx) {
+		rets = -EMSGSIZE;
+		goto free;
+	}
+
+	/* length is being truncated to PAGE_SIZE,
+	 * however buf_idx may point beyond that */
+	length = min_t(size_t, length, rb->buf_idx - *offset);
+
+	if (copy_to_user(ubuf, rb->buffer.data + *offset, length)) {
+		rets = -EFAULT;
+		goto free;
+	}
+
+	rets = length;
+	*offset += length;
+	if ((unsigned long)*offset < rb->buf_idx)
+		goto out;
+
+free:
+	heci_io_rb_recycle(rb);
+
+	cl->read_rb = NULL;
+	*offset = 0;
+out:
+	dev_dbg(&dev->pdev->dev, "end heci read rets= %d\n", rets);
+	return rets;
+}
+
+
+/**
+ * heci_write - the write function.
+ *
+ * @file: pointer to file structure
+ * @ubuf: pointer to user buffer
+ * @length: buffer length
+ * @offset: data offset in buffer
+ *
+ * returns >=0 data length on success , <0 on error
+ */
+static ssize_t heci_write(struct file *file, const char __user *ubuf,
+	size_t length, loff_t *offset)
+{
+	struct heci_cl *cl = file->private_data;
+
+	/*
+	 * TODO: we may further optimize write path by obtaining and directly
+	 * copy_from_user'ing to tx_ring's buffer
+	 */
+	void *write_buf = NULL;
+	struct heci_device *dev;
+	int rets;
+
+	/* Non-blocking semantics are not supported */
+	if (file->f_flags & O_NONBLOCK)
+		return	-EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	if (cl->state != HECI_CL_CONNECTED) {
+		dev_err(&dev->pdev->dev, "host client = %d,  is not connected to ME client = %d",
+			cl->host_client_id, cl->me_client_id);
+		rets = -ENODEV;
+		goto out;
+	}
+
+	if (length <= 0) {
+		rets = -EMSGSIZE;
+		goto out;
+	}
+
+	/* FIXME: check for DMA size for clients that accept DMA transfers */
+	if (length > cl->device->fw_client->props.max_msg_length) {
+		/* If the client supports DMA, try to use it */
+		if (!(host_dma_enabled &&
+				cl->device->fw_client->props.dma_hdr_len &
+				HECI_CLIENT_DMA_ENABLED)) {
+			rets = -EMSGSIZE;
+			goto out;
+		}
+	}
+
+	write_buf = kmalloc(length, GFP_KERNEL);
+	if (!write_buf) {
+		dev_err(&dev->pdev->dev, "write buffer allocation failed\n");
+		rets = -ENOMEM;
+		goto	out;
+	}
+
+	rets = copy_from_user(write_buf, ubuf, length);
+	if (rets)
+		goto out;
+	rets = heci_cl_send(cl, write_buf, length);
+	if (!rets)
+		rets = length;
+	else
+		rets = -EIO;
+out:
+	kfree(write_buf);
+	return rets;
+}
+
+/**
+ * heci_ioctl_connect_client - the connect to fw client IOCTL function
+ *
+ * @dev: the device structure
+ * @data: IOCTL connect data, input and output parameters
+ * @file: private data of the file object
+ *
+ * Locking: called under "dev->device_lock" lock
+ *
+ * returns 0 on success, <0 on failure.
+ */
+static int heci_ioctl_connect_client(struct file *file,
+	struct heci_connect_client_data *data)
+{
+	struct heci_device *dev;
+	struct heci_client *client;
+	struct heci_cl *cl;
+	int i;
+	int rets;
+	unsigned long flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	cl = file->private_data;
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	dev = cl->dev;
+
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto end;
+	}
+
+	if (cl->state != HECI_CL_INITIALIZING &&
+	    cl->state != HECI_CL_DISCONNECTED) {
+		rets = -EBUSY;
+		goto end;
+	}
+
+	/* find ME client we're trying to connect to */
+	i = heci_me_cl_by_uuid(dev, &data->in_client_uuid);
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
+	if (i < 0 || dev->me_clients[i].props.fixed_address) {
+		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
+				&data->in_client_uuid);
+		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+		rets = -ENODEV;
+		goto end;
+	}
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	/* Check if there's driver attached to this UUID */
+	if (!heci_can_client_connect(dev, &data->in_client_uuid))
+		return	-EBUSY;
+
+	cl->me_client_id = dev->me_clients[i].client_id;
+	cl->state = HECI_CL_CONNECTING;
+
+	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
+			cl->me_client_id);
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
+	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
+			dev->me_clients[i].props.protocol_version);
+	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
+			dev->me_clients[i].props.max_msg_length);
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	/* prepare the output buffer */
+	client = &data->out_client_properties;
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
+	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
+	client->protocol_version = dev->me_clients[i].props.protocol_version;
+	dev_dbg(&dev->pdev->dev, "Can connect?\n");
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
+	rets = heci_cl_connect(cl);
+
+end:
+	ISH_DBG_PRINT(KERN_ALERT "%s(): --- (%d)\n", __func__, rets);
+	return	rets;
+}
+
+
+/**
+ * heci_ioctl - the IOCTL function
+ *
+ * @file: pointer to file structure
+ * @cmd: ioctl command
+ * @data: pointer to heci message structure
+ *
+ * returns 0 on success , <0 on error
+ */
+static long heci_ioctl(struct file *file, unsigned int cmd, unsigned long data)
+{
+	struct heci_device *dev;
+	struct heci_cl *cl = file->private_data;
+	struct heci_connect_client_data *connect_data = NULL;
+	int rets;
+	unsigned	ring_size;
+	char fw_stat_buf[20];
+
+	if (!cl)
+		return -EINVAL;
+
+	dev = cl->dev;
+	dev_dbg(&dev->pdev->dev, "IOCTL cmd = 0x%x", cmd);
+
+	/* Test API for triggering PCI reset */
+	if (cmd == 0x12341234) {
+		return	heci_hw_reset(dev);
+	}
+
+	/* Test API for triggering host-initiated IPC reset to ISS */
+	if (cmd == 0x12345678) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): ISS FW reset is requested\n",
+			__func__);
+		/* Re-init */
+		dev->dev_state = HECI_DEV_INITIALIZING;
+		heci_reset(dev, 1);
+
+		if (heci_hbm_start_wait(dev)) {
+			dev_err(&dev->pdev->dev, "HBM haven't started");
+			goto err;
+		}
+
+		if (!heci_host_is_ready(dev)) {
+			dev_err(&dev->pdev->dev, "host is not ready.\n");
+			goto err;
+		}
+
+		if (!heci_hw_is_ready(dev)) {
+			dev_err(&dev->pdev->dev, "ME is not ready.\n");
+			goto err;
+		}
+
+		return	0;
+err:
+		dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
+		dev->dev_state = HECI_DEV_DISABLED;
+		return -ENODEV;
+	}
+
+	/* Test API for triggering host disabling */
+	if (cmd == 0xAA55AA55) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): ISS host stop is requested\n",
+			__func__);
+		/* Handle ISS reset against upper layers */
+
+		/* Remove all client devices */
+		heci_bus_remove_all_clients(dev);
+		dev->dev_state = HECI_DEV_DISABLED;
+		return	0;
+	}
+
+	if (cmd == IOCTL_HECI_SET_RX_FIFO_SIZE) {
+		ring_size = data;
+		if (ring_size > CL_MAX_RX_RING_SIZE)
+			return	-EINVAL;
+		if (cl->state != HECI_CL_INITIALIZING)
+			return	-EBUSY;
+		cl->rx_ring_size = ring_size;
+		return	0;
+	}
+
+	if (cmd == IOCTL_HECI_SET_TX_FIFO_SIZE) {
+		ring_size = data;
+		if (ring_size > CL_MAX_TX_RING_SIZE)
+			return	-EINVAL;
+		if (cl->state != HECI_CL_INITIALIZING)
+			return	-EBUSY;
+		cl->tx_ring_size = ring_size;
+		return	0;
+	}
+
+	if (cmd == IOCTL_GET_FW_STATUS) {
+		scnprintf(fw_stat_buf, sizeof(fw_stat_buf),
+			"%08X\n", dev->ops->get_fw_status(dev));
+		copy_to_user((char __user *)data, fw_stat_buf,
+			strlen(fw_stat_buf));
+		return strlen(fw_stat_buf);
+	}
+
+	if (cmd != IOCTL_HECI_CONNECT_CLIENT)
+		return -EINVAL;
+
+	if (WARN_ON(!cl || !cl->dev))
+		return -ENODEV;
+
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		rets = -ENODEV;
+		goto out;
+	}
+
+	dev_dbg(&dev->pdev->dev, ": IOCTL_HECI_CONNECT_CLIENT.\n");
+
+	connect_data = kzalloc(sizeof(struct heci_connect_client_data),
+							GFP_KERNEL);
+	if (!connect_data) {
+		rets = -ENOMEM;
+		goto out;
+	}
+	dev_dbg(&dev->pdev->dev, "copy connect data from user\n");
+	if (copy_from_user(connect_data, (char __user *)data,
+			sizeof(struct heci_connect_client_data))) {
+		dev_dbg(&dev->pdev->dev, "failed to copy data from userland\n");
+		rets = -EFAULT;
+		goto out;
+	}
+
+	rets = heci_ioctl_connect_client(file, connect_data);
+
+	/* if all is ok, copying the data back to user. */
+	if (rets)
+		goto out;
+
+	dev_dbg(&dev->pdev->dev, "copy connect data to user\n");
+	if (copy_to_user((char __user *)data, connect_data,
+				sizeof(struct heci_connect_client_data))) {
+		dev_dbg(&dev->pdev->dev, "failed to copy data to userland\n");
+		rets = -EFAULT;
+		goto out;
+	}
+
+out:
+	kfree(connect_data);
+	return rets;
+}
+
+/**
+ * heci_compat_ioctl - the compat IOCTL function
+ *
+ * @file: pointer to file structure
+ * @cmd: ioctl command
+ * @data: pointer to heci message structure
+ *
+ * returns 0 on success , <0 on error
+ */
+#ifdef CONFIG_COMPAT
+static long heci_compat_ioctl(struct file *file,
+			unsigned int cmd, unsigned long data)
+{
+	return heci_ioctl(file, cmd, (unsigned long)compat_ptr(data));
+}
+#endif /*CONFIG_COMPAT*/
+
+
+/*
+ * file operations structure will be used for heci char device.
+ */
+static const struct file_operations heci_fops = {
+	.owner = THIS_MODULE,
+	.read = heci_read,
+	.unlocked_ioctl = heci_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = heci_compat_ioctl,
+#endif /*CONFIG_COMPAT*/
+	.open = heci_open,
+	.release = heci_release,
+	.write = heci_write,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+static struct miscdevice  heci_misc_device = {
+		.name = "ish",		/*"heci" changed to "ish", stuff it #2*/
+		.fops = &heci_fops,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+int heci_register(struct heci_device *dev)
+{
+	int ret;
+	heci_misc_device.parent = &dev->pdev->dev;
+	ret = misc_register(&heci_misc_device);
+	if (ret)
+		return ret;
+
+	if (heci_dbgfs_register(dev, heci_misc_device.name))
+		dev_err(&dev->pdev->dev, "cannot register debugfs\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(heci_register);
+
+void heci_deregister(struct heci_device *dev)
+{
+	if (heci_misc_device.parent == NULL)
+		return;
+
+	heci_dbgfs_deregister(dev);
+	misc_deregister(&heci_misc_device);
+	heci_misc_device.parent = NULL;
+}
+EXPORT_SYMBOL_GPL(heci_deregister);
+
+static int __init heci_init(void)
+{
+	return heci_cl_bus_init();
+}
+
+static void __exit heci_exit(void)
+{
+	heci_cl_bus_exit();
+}
+
+module_init(heci_init);
+module_exit(heci_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R) Management Engine Interface");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/misc/intel-ish/heci-api.h b/drivers/misc/intel-ish/heci-api.h
new file mode 100644
index 0000000..7af16a5
--- /dev/null
+++ b/drivers/misc/intel-ish/heci-api.h
@@ -0,0 +1,115 @@
+/******************************************************************************
+ * Intel HECI Interface Header
+ *
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2003 - 2015 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program;
+ *
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ *	Intel Corporation.
+ *	linux-heci@linux.intel.com
+ *	http://www.intel.com
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2003 - 2015 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *  * Neither the name Intel Corporation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *****************************************************************************/
+
+#ifndef _LINUX_HECI_H
+#define _LINUX_HECI_H
+
+#include <linux/uuid.h>
+
+/*
+ * This IOCTL is used to associate the current file descriptor with a
+ * FW Client (given by UUID). This opens a communication channel
+ * between a host client and a FW client. From this point every read and write
+ * will communicate with the associated FW client.
+ * Only in close() (file_operation release()) the communication between
+ * the clients is disconnected
+ *
+ * The IOCTL argument is a struct with a union that contains
+ * the input parameter and the output parameter for this IOCTL.
+ *
+ * The input parameter is UUID of the FW Client.
+ * The output parameter is the properties of the FW client
+ * (FW protocol version and max message size).
+ *
+ */
+#define IOCTL_HECI_CONNECT_CLIENT	_IOWR('H', 0x01,	\
+				struct heci_connect_client_data)
+
+/* Configuration: set number of Rx/Tx buffers. Must be used before conneciton */
+#define IOCTL_HECI_SET_RX_FIFO_SIZE	_IOWR('H', 0x02, long)
+#define IOCTL_HECI_SET_TX_FIFO_SIZE	_IOWR('H', 0x03, long)
+
+/* Get FW status */
+#define IOCTL_GET_FW_STATUS             _IO('H', 0x04)
+
+/*
+ * Intel HECI client information struct
+ */
+struct heci_client {
+	__u32 max_msg_length;
+	__u8 protocol_version;
+	__u8 reserved[3];
+};
+
+/*
+ * IOCTL Connect Client Data structure
+ */
+struct heci_connect_client_data {
+	union {
+		uuid_le in_client_uuid;
+		struct heci_client out_client_properties;
+	};
+};
+
+#endif /* _LINUX_HECI_H  */
+
diff --git a/drivers/misc/intel-ish/heci-hid-client.c b/drivers/misc/intel-ish/heci-hid-client.c
new file mode 100644
index 0000000..85622c5
--- /dev/null
+++ b/drivers/misc/intel-ish/heci-hid-client.c
@@ -0,0 +1,823 @@
+/*
+ * HECI client driver for HID (ISS)
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include <linux/uuid.h>
+#include "heci_dev.h"
+#include "client.h"
+#include "heci-hid.h"
+
+/* Rx ring buffer pool size */
+#define RX_RING_SIZE	32
+#define TX_RING_SIZE	16
+
+/* Global vars, may eventually end up in a structure */
+struct heci_cl	*hid_heci_cl = NULL;			/* ISS HECI client */
+
+/* Set when ISS HECI client is successfully probed */
+int	hid_heci_client_found;
+int	may_send;		/* Global flag that determines if sender thread
+				can safely send something or it should
+				wait more */
+int	enum_devices_done;	/* Enum devices response complete flag */
+int	hid_descr_done;		/* Get HID descriptor complete flag */
+int	report_descr_done;	/* Get report descriptor complete flag */
+int	get_report_done;	/* Get Feature/Input report complete flag */
+
+struct device_info	*hid_devices;
+unsigned	cur_hid_dev;
+unsigned	hid_dev_count;
+unsigned	max_hid_devices = /*1*/ MAX_HID_DEVICES;
+unsigned	num_hid_devices;
+unsigned char	*hid_descr[MAX_HID_DEVICES];
+int	hid_descr_size[MAX_HID_DEVICES];
+unsigned char	*report_descr[MAX_HID_DEVICES];
+int	report_descr_size[MAX_HID_DEVICES];
+struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
+
+static wait_queue_head_t	init_wait;
+wait_queue_head_t	heci_hid_wait;
+static unsigned	bad_recv_cnt;
+static int	multi_packet_cnt;
+
+/*flush notification*/
+void (*flush_cb)(void);
+static int	init_done;
+
+
+static void	report_bad_packet(void *recv_buf, size_t cur_pos, size_t payload_len)
+{
+	struct hostif_msg	*recv_msg = recv_buf;
+
+	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: BAD packet %02X\n",
+		recv_msg->hdr.command);
+	dev_err(&hid_heci_cl->device->dev, "total_bad=%u cur_pos=%u\n",
+		bad_recv_cnt, cur_pos);
+	dev_err(&hid_heci_cl->device->dev, "[%02X %02X %02X %02X]\n",
+		((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1],
+		((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
+	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: payload_len=%u\n",
+		payload_len);
+	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: multi_packet_cnt=%u\n",
+		multi_packet_cnt);
+	dev_err(&hid_heci_cl->device->dev, "[hid-ish]: is_response=%02X\n",
+		recv_msg->hdr.command & ~CMD_MASK);
+}
+
+
+/* HECI client driver structures and API for bus interface */
+static void	process_recv(void *recv_buf, size_t data_len)
+{
+	struct hostif_msg	*recv_msg;
+	unsigned char	*payload;
+	/*size_t	size;*/
+	struct device_info	*dev_info;
+	int	i, j;
+	size_t	payload_len, total_len, cur_pos;
+	int	report_type;
+
+	struct report_list *reports_list;
+	char *reports;
+	size_t report_len;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++ len=%u\n", __func__,
+		(unsigned)data_len);
+
+	if (data_len < sizeof(struct hostif_msg_hdr)) {
+		dev_err(&hid_heci_cl->device->dev,
+			"[hid-ish]: error, received %u which is ",
+			(unsigned)data_len);
+		dev_err(&hid_heci_cl->device->dev,
+			" less than data header %u\n",
+			(unsigned)sizeof(struct hostif_msg_hdr));
+		++bad_recv_cnt;
+		heci_hw_reset(hid_heci_cl->dev);
+		return;
+	}
+
+	payload = recv_buf + sizeof(struct hostif_msg_hdr);
+	total_len = data_len;
+	cur_pos = 0;
+
+	may_send = 0;
+
+	do {
+		recv_msg = (struct hostif_msg *)(recv_buf + cur_pos);
+		payload_len = recv_msg->hdr.size;
+
+		/* Sanity checks */
+		if (cur_pos + payload_len + sizeof(struct hostif_msg) >
+				total_len) {
+			++bad_recv_cnt;
+			report_bad_packet(recv_msg, cur_pos, payload_len);
+			heci_hw_reset(hid_heci_cl->dev);
+			break;
+		}
+
+
+		switch (recv_msg->hdr.command & CMD_MASK) {
+		default:
+			++bad_recv_cnt;
+			report_bad_packet(recv_msg, cur_pos, payload_len);
+			heci_hw_reset(hid_heci_cl->dev);
+			break;
+
+		case HOSTIF_DM_ENUM_DEVICES:
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): HOSTIF_DM_ENUM_DEVICES [cur_pos=%u] [%02X %02X %02X %02X]\n",
+				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
+			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
+					init_done)) {
+				++bad_recv_cnt;
+				report_bad_packet(recv_msg, cur_pos,
+					payload_len);
+				heci_hw_reset(hid_heci_cl->dev);
+				break;
+			}
+			hid_dev_count = (unsigned)*payload;
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): hid_dev_count=%d\n",
+				__func__, hid_dev_count);
+			hid_devices = kmalloc(hid_dev_count *
+				sizeof(struct device_info), GFP_KERNEL);
+			if (hid_devices)
+				memset(hid_devices, 0, hid_dev_count *
+					sizeof(struct device_info));
+
+			for (i = 0; i < hid_dev_count; ++i) {
+				if (1 + sizeof(struct device_info) * i >=
+						payload_len) {
+					dev_err(&hid_heci_cl->device->dev,
+						"[hid-ish]: [ENUM_DEVICES]:");
+					dev_err(&hid_heci_cl->device->dev,
+						" content size %lu ", 1 +
+						sizeof(struct device_info) *
+						i);
+					dev_err(&hid_heci_cl->device->dev,
+						"is bigger than ");
+					dev_err(&hid_heci_cl->device->dev,
+						"payload_len %u\n",
+						(unsigned)payload_len);
+				}
+
+				if (1 + sizeof(struct device_info) * i >=
+						data_len)
+					break;
+
+				dev_info = (struct device_info *)(payload + 1 +
+					sizeof(struct device_info) * i);
+				ISH_DBG_PRINT(KERN_ALERT
+					"[hid-ish]: %s(): [%d] -- dev_id=%08X dev_class=%02X pid=%04X vid=%04X\n",
+					__func__, i, dev_info->dev_id,
+					dev_info->dev_class, dev_info->pid,
+					dev_info->vid);
+				if (hid_devices)
+					memcpy(hid_devices + i, dev_info,
+						sizeof(struct device_info));
+			}
+
+			enum_devices_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_HID_DESCRIPTOR:
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): received HOSTIF_GET_HID_DESCRIPTOR [cur_pos=%u] [%02X %02X %02X %02X]\n",
+				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): dump HID descriptor\n",
+				__func__);
+			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
+					init_done)) {
+				++bad_recv_cnt;
+				report_bad_packet(recv_msg, cur_pos,
+					payload_len);
+				heci_hw_reset(hid_heci_cl->dev);
+				break;
+			}
+			for (i = 0; i < payload_len; ++i)
+				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
+			ISH_DBG_PRINT(KERN_ALERT "\n");
+			hid_descr[cur_hid_dev] = kmalloc(payload_len,
+				GFP_KERNEL);
+			if (hid_descr[cur_hid_dev])
+				memcpy(hid_descr[cur_hid_dev], payload,
+					payload_len);
+			hid_descr_size[cur_hid_dev] = payload_len;
+
+			hid_descr_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_REPORT_DESCRIPTOR:
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): received HOSTIF_GET_REPORT_DESCRIPTOR [cur_pos=%u] [%02X %02X %02X %02X]\n",
+				__func__, cur_pos, ((unsigned char*)recv_msg)[0], ((unsigned char*)recv_msg)[1], ((unsigned char*)recv_msg)[2], ((unsigned char*)recv_msg)[3]);
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): Length of report descriptor is %u\n",
+				__func__, (unsigned)payload_len);
+			if ((!(recv_msg->hdr.command & ~CMD_MASK) ||
+					init_done)) {
+				++bad_recv_cnt;
+				report_bad_packet(recv_msg, cur_pos,
+					payload_len);
+				heci_hw_reset(hid_heci_cl->dev);
+				break;
+			}
+			report_descr[cur_hid_dev] = kmalloc(payload_len,
+				GFP_KERNEL);
+			if (report_descr[cur_hid_dev])
+				memcpy(report_descr[cur_hid_dev], payload,
+					payload_len);
+			report_descr_size[cur_hid_dev] = payload_len;
+
+			report_descr_done = 1;
+			if (waitqueue_active(&init_wait))
+				wake_up(&init_wait);
+
+			break;
+
+		case HOSTIF_GET_FEATURE_REPORT:
+			report_type = HID_FEATURE_REPORT;
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): received HOSTIF_GET_FEATURE_REPORT\n",
+				__func__);
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): dump Get Feature Result\n",
+				__func__);
+			flush_cb(); /*each "GET_FEATURE_REPORT" ends a batch*/
+			goto	do_get_report;
+
+		case HOSTIF_GET_INPUT_REPORT:
+			report_type = HID_INPUT_REPORT;
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): received HOSTIF_GET_INPUT_REPORT\n",
+				__func__);
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): dump Get Input Result\n",
+				__func__);
+do_get_report:
+			for (i = 0; i < payload_len; ++i)
+				ISH_DBG_PRINT(KERN_ALERT "%02X ", payload[i]);
+			ISH_DBG_PRINT(KERN_ALERT "\n");
+
+
+			/* Get index of device that matches this id */
+			for (i = 0; i < num_hid_devices; ++i)
+				if (recv_msg->hdr.device_id ==
+						hid_devices[i].dev_id)
+					if (hid_sensor_hubs[i] != NULL) {
+						hid_input_report(
+							hid_sensor_hubs[i],
+							report_type, payload,
+							payload_len, 0);
+						break;
+					}
+			ISH_DBG_PRINT(KERN_ALERT
+				"%s(): received input report, upstreaming\n",
+				__func__);
+			get_report_done = 1;
+			if (waitqueue_active(&heci_hid_wait))
+				wake_up(&heci_hid_wait);
+			break;
+
+		case HOSTIF_SET_FEATURE_REPORT:
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): HOSTIF_SET_FEATURE_REPORT returned status=%02X\n",
+				__func__, recv_msg->hdr.status);
+			ISH_DBG_PRINT(KERN_ALERT
+				"%s(): received feature report, upstreaming\n",
+				__func__);
+			get_report_done = 1;
+			if (waitqueue_active(&heci_hid_wait))
+				wake_up(&heci_hid_wait);
+			break;
+
+		case HOSTIF_PUBLISH_INPUT_REPORT:
+			report_type = HID_INPUT_REPORT;
+			do {
+				ISH_DBG_PRINT(KERN_ALERT
+					"[hid-ish]: %s(): received ASYNC DATA REPORT [payload_len=%u]. Dump data:\n",
+					__func__, (unsigned)payload_len);
+				for (i = 0; i < payload_len; ++i)
+					ISH_DBG_PRINT(KERN_ALERT "%02X\n",
+						payload[i]);
+			} while (0);
+
+			for (i = 0; i < num_hid_devices; ++i)
+				if (recv_msg->hdr.device_id ==
+						hid_devices[i].dev_id)
+					if (hid_sensor_hubs[i] != NULL)
+						hid_input_report(
+							hid_sensor_hubs[i],
+							report_type, payload,
+							payload_len, 0);
+			break;
+
+		case HOSTIF_PUBLISH_INPUT_REPORT_LIST:
+			ISH_DBG_PRINT(KERN_ALERT
+				"[hid-ish]: %s(): received HOSTIF_PUBLISH_INPUT_REPORT_LIST\n",
+				__func__);
+
+			report_type = HID_INPUT_REPORT;
+			reports_list = (struct report_list *)payload;
+			reports = (char *)reports_list->reports;
+
+			for (j = 0; j < reports_list->num_of_reports; j++) {
+				recv_msg = (struct hostif_msg *)(reports +
+					sizeof(uint16_t));
+				report_len = *(uint16_t *)reports;
+				payload = reports + sizeof(uint16_t) +
+					sizeof(struct hostif_msg_hdr);
+				payload_len = report_len -
+					sizeof(struct hostif_msg_hdr);
+
+				ISH_DBG_PRINT(KERN_ALERT
+					"[hid-ish]: %s(): report #%d, report_len: %d, payload_len: %d, device_id: %d, payload Data\n",
+					__func__, j, (int)report_len,
+					(int)payload_len,
+					(int)recv_msg->hdr.device_id);
+				for (i = 0; i < payload_len; ++i)
+					ISH_DBG_PRINT(KERN_ALERT "%02X ",
+						payload[i]);
+				ISH_DBG_PRINT(KERN_ALERT "\n");
+
+				for (i = 0; i < num_hid_devices; ++i)
+					if (recv_msg->hdr.device_id ==
+							hid_devices[i].dev_id &&
+							hid_sensor_hubs[i] !=
+							NULL) {
+						hid_input_report(
+							hid_sensor_hubs[i],
+							report_type,
+							payload, payload_len,
+							0);
+					}
+
+				reports += sizeof(uint16_t) + report_len;
+			}
+			break;
+
+		}
+
+		if (!cur_pos && cur_pos + payload_len +
+				sizeof(struct hostif_msg) < total_len)
+			++multi_packet_cnt;
+
+		cur_pos += payload_len + sizeof(struct hostif_msg);
+		payload += payload_len + sizeof(struct hostif_msg);
+
+	} while (cur_pos < total_len);
+	may_send = 1;
+}
+
+
+void ish_cl_event_cb(struct heci_cl_device *device, u32 events, void *context)
+{
+	size_t r_length;
+	struct heci_cl_rb *rb_in_proc;
+	unsigned long	flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s() +++\n", __func__);
+
+	if (!hid_heci_cl)
+		return;
+
+	spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
+	while (!list_empty(&hid_heci_cl->in_process_list.list)) {
+		rb_in_proc = list_entry(hid_heci_cl->in_process_list.list.next,
+			struct heci_cl_rb, list);
+		list_del_init(&rb_in_proc->list);
+		spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock,
+			flags);
+
+		if (!rb_in_proc->buffer.data) {
+			ISH_DBG_PRINT(KERN_ALERT
+				"%s(): !rb_in_proc-->buffer.data, something's wrong\n",
+				__func__);
+			return;
+		}
+		r_length = rb_in_proc->buf_idx;
+		ISH_DBG_PRINT(KERN_ALERT
+			"%s(): OK received buffer of %u length\n", __func__,
+			(unsigned)r_length);
+
+		/* decide what to do with received data */
+		process_recv(rb_in_proc->buffer.data, r_length);
+
+		heci_io_rb_recycle(rb_in_proc);
+		spin_lock_irqsave(&hid_heci_cl->in_process_spinlock, flags);
+	}
+	spin_unlock_irqrestore(&hid_heci_cl->in_process_spinlock, flags);
+}
+
+void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len,
+	int report_id)
+{
+	int	rv;
+	struct hostif_msg *msg = (struct hostif_msg *)buf;
+	int	i;
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish]: %s(): writing SET FEATURE REPORT\n", __func__);
+	memset(msg, 0, sizeof(struct hostif_msg));
+	msg->hdr.command = HOSTIF_SET_FEATURE_REPORT;
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid == hid_sensor_hubs[i]) {
+			msg->hdr.device_id = hid_devices[i].dev_id;
+			break;
+		}
+	if (i == num_hid_devices)
+		return;
+
+	rv = heci_cl_send(hid_heci_cl, buf, len);
+	ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
+}
+
+
+void hid_heci_get_report(struct hid_device *hid, int report_id, int report_type)
+{
+	int	rv;
+	static unsigned char	buf[10];
+	unsigned	len;
+	struct hostif_msg_to_sensor *msg = (struct hostif_msg_to_sensor *)buf;
+	int	i;
+
+	len = sizeof(struct hostif_msg_to_sensor);
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish]: %s(): writing GET REPORT of type: %d\n", __func__,
+		report_type);
+	memset(msg, 0, sizeof(struct hostif_msg_to_sensor));
+	msg->hdr.command = (report_type == HID_FEATURE_REPORT) ?
+		HOSTIF_GET_FEATURE_REPORT : HOSTIF_GET_INPUT_REPORT;
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid == hid_sensor_hubs[i]) {
+			msg->hdr.device_id = hid_devices[i].dev_id;
+			/*
+			 * FIXME - temporary when single collection exists,
+			 * then has to be part of hid_device custom fields
+			 */
+			break;
+		}
+	if (i == num_hid_devices)
+		return;
+
+	msg->report_id = report_id;
+	rv = heci_cl_send(hid_heci_cl, buf, len);
+	ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
+}
+
+struct work_struct my_work;
+
+int	hid_heci_cl_probe(struct heci_cl_device *cl_device,
+	const struct heci_cl_device_id *id)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	if (!cl_device)
+		return	-ENODEV;
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): dev != NULL && dev->cl != NULL /* OK */\n",
+		__func__);
+	if (uuid_le_cmp(ish_heci_guid,
+			cl_device->fw_client->props.protocol_name) != 0) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): device doesn't match\n",
+			__func__);
+		return	-ENODEV;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): device matches!\n", __func__);
+	hid_heci_cl = heci_cl_allocate(cl_device->heci_dev);
+	if (!hid_heci_cl)
+		return	-ENOMEM;
+
+	rv = heci_cl_link(hid_heci_cl, HECI_HOST_CLIENT_ID_ANY);
+	if (rv)
+		return	-ENOMEM;
+
+	hid_heci_client_found = 1;
+	if (waitqueue_active(&init_wait))
+		wake_up(&init_wait);
+
+	schedule_work(&my_work);
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[ish client driver] %s() enqueue init_work function\n",
+		__func__);
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	return	0;
+
+	/*
+	 * Linux generic drivers framework doesn't like probe() functions
+	 * to start kernel threads
+	 */
+}
+
+
+int     hid_heci_cl_remove(struct heci_cl_device *dev)
+{
+	int i;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	heci_hid_remove();
+	hid_heci_client_found = 0;
+	hid_heci_cl = NULL;
+
+	for (i = 0; i < num_hid_devices ; ++i) {
+		/* kfree(NULL) is safe */
+		kfree(hid_descr[i]);
+		/* kfree(NULL) is safe */
+		kfree(report_descr[i]);
+	}
+	num_hid_devices = 0;
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	return  0;
+}
+
+
+struct heci_cl_driver	hid_heci_cl_driver = {
+	.name = "ish",
+	.probe = hid_heci_cl_probe,
+	.remove = hid_heci_cl_remove,
+};
+
+
+/****************************************************************/
+
+void workqueue_init_function(struct work_struct *work)
+{
+	int	rv;
+	static unsigned char	buf[4096];
+	unsigned	len;
+	struct hostif_msg	*msg = (struct hostif_msg *)buf;
+	int	i;
+	struct heci_device	*dev;
+	int	retry_count;
+
+	init_done = 0;
+	ISH_DBG_PRINT(KERN_ALERT
+		"[ish client driver] %s() in workqueue func, continue initialization process\n",
+		__func__);
+
+	if (!hid_heci_client_found)
+		wait_event_timeout(init_wait, hid_heci_client_found, 30 * HZ);
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[ish client driver] %s() completed waiting for hid_heci_client_found[=%d]\n",
+		__func__, hid_heci_client_found);
+
+	if (!hid_heci_client_found) {
+		printk(KERN_ERR "[hid-ish]: timed out waiting for hid_heci_client_found\n");
+		rv = -ENODEV;
+		goto	ret;
+	}
+
+	dev = hid_heci_cl->dev;
+
+	/* Connect to FW client */
+	hid_heci_cl->rx_ring_size = RX_RING_SIZE;
+	hid_heci_cl->tx_ring_size = TX_RING_SIZE;
+
+	i = heci_me_cl_by_uuid(dev, &ish_heci_guid);
+	hid_heci_cl->me_client_id = dev->me_clients[i].client_id;
+	hid_heci_cl->state = HECI_CL_CONNECTING;
+
+	rv = heci_cl_connect(hid_heci_cl);
+	if (rv)
+		goto	ret;
+
+	/* Register read callback */
+	heci_register_event_cb(hid_heci_cl->device, ish_cl_event_cb, NULL);
+
+#if 0
+	/*
+	 * Wait until we can send without risking flow-control break scenario
+	 * (sending OUR FC ahead of message, so that FW will respond)
+	 * We probably need here only a small delay in order to let our FC
+	 * to be sent over to FW
+	 */
+	schedule_timeout(WAIT_FOR_SEND_SLICE);
+#endif
+
+	/* Send HOSTIF_DM_ENUM_DEVICES */
+	memset(msg, 0, sizeof(struct hostif_msg));
+	msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
+	len = sizeof(struct hostif_msg);
+	ISH_DBG_PRINT(KERN_ALERT
+		"[ish client driver] %s() writing HOSTIF_DM_ENUM_DEVICES len = %u\n",
+		__func__, len);
+	rv = heci_cl_send(hid_heci_cl, buf, len);
+	ISH_DBG_PRINT(KERN_ALERT
+		"[ish client driver] %s() heci_cl_send() returned %d\n",
+		__func__, rv);
+	if (rv)
+		goto	ret;
+
+	rv = 0;
+
+	retry_count = 0;
+	while (!enum_devices_done && retry_count < 10) {
+		wait_event_timeout(init_wait, enum_devices_done, 3 * HZ);
+		++retry_count;
+		dev_err(&hid_heci_cl->device->dev,
+			"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
+			enum_devices_done, retry_count);
+		if (!enum_devices_done) {
+			/* Send HOSTIF_DM_ENUM_DEVICES */
+			memset(msg, 0, sizeof(struct hostif_msg));
+			msg->hdr.command = HOSTIF_DM_ENUM_DEVICES;
+			len = sizeof(struct hostif_msg);
+			rv = heci_cl_send(hid_heci_cl, buf, len);
+		}
+	}
+	dev_err(&hid_heci_cl->device->dev,
+		"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
+		enum_devices_done, retry_count);
+
+	if (!enum_devices_done) {
+		dev_err(&hid_heci_cl->device->dev,
+			"[hid-ish]: timed out waiting for enum_devices_done\n");
+		rv = -ETIMEDOUT;
+		goto	ret;
+	}
+	if (!hid_devices) {
+		dev_err(&hid_heci_cl->device->dev,
+			"[hid-ish]: failed to allocate HID dev structures\n");
+		rv = -ENOMEM;
+		goto	ret;
+	}
+
+	/* Send GET_HID_DESCRIPTOR for each device */
+
+	/*
+	 * Temporary work-around for multi-descriptor traffic:
+	 * read only the first one
+	 * Will be removed when multi-TLC are supported
+	 */
+
+	num_hid_devices = hid_dev_count;
+	dev_err(&hid_heci_cl->device->dev,
+		"[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n",
+		num_hid_devices);
+
+
+	for (i = 0; i < num_hid_devices /*hid_dev_count*/; ++i) {
+		cur_hid_dev = i;
+
+		/* Get HID descriptor */
+		hid_descr_done = 0;
+		ISH_DBG_PRINT(KERN_ALERT
+			"[hid-ish]: %s(): [%d] writing HOSTIF_GET_HID_DESCRIPTOR\n",
+			__func__, i);
+		memset(msg, 0, sizeof(struct hostif_msg));
+		msg->hdr.command = HOSTIF_GET_HID_DESCRIPTOR;
+		msg->hdr.device_id = hid_devices[i].dev_id;
+		len = sizeof(struct hostif_msg);
+		rv = heci_cl_send(hid_heci_cl, buf, len);
+		ISH_DBG_PRINT(KERN_ALERT
+			"[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_HID_DESCRIPTOR] returned %d\n",
+			__func__, rv);
+		rv = 0;
+#ifdef HOST_VIRTUALBOX
+		timed_wait_for(WAIT_FOR_SEND_SLICE, hid_descr_done);
+#else
+		if (!hid_descr_done)
+			wait_event_timeout(init_wait, hid_descr_done, 30 * HZ);
+#endif
+		if (!hid_descr_done) {
+			printk(KERN_ERR "[hid-ish]: timed out waiting for hid_descr_done\n");
+			continue;
+		}
+
+		if (!hid_descr[i]) {
+			printk(KERN_ERR "[hid-ish]: failed to allocate HID descriptor buffer\n");
+			continue;
+		}
+
+		/* Get report descriptor */
+		report_descr_done = 0;
+		ISH_DBG_PRINT(KERN_ALERT
+			"[hid-ish]: %s(): [%d] writing HOSTIF_GET_REPORT_DESCRIPTOR\n",
+			__func__, i);
+		memset(msg, 0, sizeof(struct hostif_msg));
+		msg->hdr.command = HOSTIF_GET_REPORT_DESCRIPTOR;
+		msg->hdr.device_id = hid_devices[i].dev_id;
+		len = sizeof(struct hostif_msg);
+		rv = heci_cl_send(hid_heci_cl, buf, len);
+
+		ISH_DBG_PRINT(KERN_ALERT
+			"[hid-ish]: %s(): heci_cl_send() [HOSTIF_GET_REPORT_DESCRIPTOR] returned %d\n",
+			__func__, rv);
+		rv = 0;
+#ifdef HOST_VIRTUALBOX
+		timed_wait_for(WAIT_FOR_SEND_SLICE, report_descr_done);
+#else
+		if (!report_descr_done)
+			wait_event_timeout(init_wait, report_descr_done,
+				30 * HZ);
+#endif
+		if (!report_descr_done) {
+			dev_err(&hid_heci_cl->device->dev,
+				"[hid-ish]: timed out wait for report descr\n");
+			continue;
+		}
+
+		if (!report_descr[i]) {
+			dev_err(&hid_heci_cl->device->dev,
+				"[hid-ish]: failed to alloc report descr\n");
+			continue;
+		}
+
+		rv = heci_hid_probe(i);
+		if (rv) {
+			dev_err(&hid_heci_cl->device->dev,
+				"[hid-ish]: HID probe for #%u failed: %d\n",
+				i, rv);
+			continue;
+		}
+	} /* for() */
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish] %s() in workqueue func, finished initialization process\n",
+		__func__);
+
+ret:
+	ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish] %s() :in ret label --- returning %d\n", __func__,
+		rv);
+	init_done = 1;
+}
+/****************************************************************/
+
+
+static int __init ish_init(void)
+{
+	int	rv;
+
+	ISH_INFO_PRINT(KERN_ERR "[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
+		__func__);
+	g_ish_print_log(
+		"[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
+		__func__);
+
+	init_waitqueue_head(&init_wait);
+	init_waitqueue_head(&heci_hid_wait);
+	/* Register HECI client device driver - ISS */
+	rv = heci_cl_driver_register(&hid_heci_cl_driver);
+
+	/*
+	 * 7/7/2014: in order to not stick Android boot, from here & below
+	 * needs to run in work queue and here we should return rv
+	 */
+	/****************************************************************/
+	INIT_WORK(&my_work, workqueue_init_function);
+	/***************************************************************/
+	return rv;
+
+}
+
+
+static void __exit ish_exit(void)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():+++\n", __func__);
+	heci_cl_driver_unregister(&hid_heci_cl_driver);
+	ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish]: %s(): unregistered from HECI bus\n", __func__);
+	ISH_DBG_PRINT(KERN_ALERT "[hid-ish]: %s():---\n", __func__);
+}
+
+module_init(ish_init);
+module_exit(ish_exit);
+
+MODULE_DESCRIPTION("ISS HECI client driver");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/intel-ish/heci-hid.c b/drivers/misc/intel-ish/heci-hid.c
new file mode 100644
index 0000000..d692cb19
--- /dev/null
+++ b/drivers/misc/intel-ish/heci-hid.c
@@ -0,0 +1,249 @@
+/*
+ * HECI-HID glue driver.
+ *
+ * Copyright (c) 2012-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/kthread.h>
+#include "heci-hid.h"
+#include "platform-config.h"
+#include "client.h"
+
+/*
+ * TODO - figure out if this number is used for anything but assignment.
+ * BUS_I2C is not
+ */
+#define	BUS_HECI	0x44
+/* TODO: just to bootstrap, numbers will probably change */
+#define	ISH_HID_VENDOR	0x8086
+#define	ISH_HID_PRODUCT	0x22D8
+#define	ISH_HID_VERSION	0x0200
+
+static int heci_hid_parse(struct hid_device *hid)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
+
+	rv = hid_parse_report(hid, report_descr[cur_hid_dev],
+		report_descr_size[cur_hid_dev]);
+	if (rv) {
+		ISH_DBG_PRINT(KERN_ALERT
+			"[heci-hid] %s(): parsing report descriptor failed\n",
+			__func__);
+		return	rv;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[heci-hid] %s(): parsing report descriptor succeeded\n",
+		__func__);
+	return 0;
+}
+
+static int heci_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+/* should we free smth? */
+static void heci_hid_stop(struct hid_device *hid)
+{
+	return;
+}
+
+/* probably connect might be here (move from probe) */
+static int heci_hid_open(struct hid_device *hid)
+{
+	return 0;
+}
+
+
+/* naturally if connect in open, disconnect here */
+static void ish_heci_close(struct hid_device *hid)
+{
+	return;
+}
+
+static int heci_hid_power(struct hid_device *hid, int lvl)
+{
+	return 0;
+}
+
+
+
+static void heci_hid_request(struct hid_device *hid, struct hid_report *rep,
+	int reqtype)
+{
+	/* the specific report length, just HID part of it */
+	unsigned len = ((rep->size - 1) >> 3) + 1 + (rep->id > 0);
+	char *buf;
+	/* s32 checkValue = 0; */
+	/* int i = 0; */
+	unsigned header_size =  sizeof(struct hostif_msg);
+
+	len += header_size;
+
+	switch (reqtype) {
+	case HID_REQ_GET_REPORT:
+		hid_heci_get_report(hid, rep->id, rep->type);
+		break;
+	case HID_REQ_SET_REPORT:
+		buf = kzalloc(len, GFP_KERNEL);
+		if (!buf)
+			return;
+		hid_output_report(rep, buf + header_size);
+	/* checkValue = rep->field[3]->value[0]; */
+	/* ISH_DBG_PRINT(KERN_ALERT
+		"[hid-ish]: %s(): after hid_output_report value is %d\n",
+		__func__, checkValue);	 */
+	/* for(;i < len; i++) */
+	/*   ISH_DBG_PRINT("\n%d %d\n", i, (int) buf[i]); */
+		hid_heci_set_feature(hid, buf, len, rep->id);
+		kfree(buf);
+		break;
+	}
+
+	return;
+}
+
+
+static int heci_hid_hidinput_input_event(struct input_dev *dev,
+		unsigned int type, unsigned int code, int value)
+{
+	return 0;
+}
+
+
+static int heci_wait_for_response(struct hid_device *hid)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s() +++\n", __func__);
+#ifdef HOST_VIRTUALBOX
+	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, get_report_done, (10 * HZ));
+#else
+	if (!get_report_done)
+		wait_event_timeout(heci_hid_wait, get_report_done, 3 * HZ);
+
+#endif
+	if (!get_report_done) {
+		hid_err(hid, "timeout waiting for response from HECI device\n");
+		return -1;
+	}
+
+	get_report_done = 0;
+	return 0;
+}
+
+
+static struct hid_ll_driver heci_hid_ll_driver = {
+	.parse = heci_hid_parse,
+	.start = heci_hid_start,
+	.stop = heci_hid_stop,
+	.open = heci_hid_open,
+	.close = ish_heci_close,
+	.power = heci_hid_power,
+	.request = heci_hid_request,
+	.hidinput_input_event = heci_hid_hidinput_input_event,
+	.wait = heci_wait_for_response
+};
+
+
+struct tmp_heci_data {
+	int hdesc_length;
+	struct task_struct	*read_task;
+};
+
+static int heci_hid_get_raw_report(struct hid_device *hid,
+	unsigned char report_number, __u8 *buf, size_t count,
+	unsigned char report_type)
+{
+	return	0;
+}
+
+static int heci_hid_output_raw_report(struct hid_device *hid, __u8 *buf,
+	size_t count, unsigned char report_type)
+{
+	return	0;
+}
+
+/*
+ * probably the best way make it driver probe so it will create device with
+ * itself as ll_driver, as usb and i2c do
+ */
+int	heci_hid_probe(unsigned cur_hid_dev)
+{
+	int rv;
+	struct hid_device	*hid;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
+
+	hid = hid_allocate_device();
+	if (IS_ERR(hid)) {
+		rv = PTR_ERR(hid);
+		return	-ENOMEM;
+	}
+
+	hid_sensor_hubs[cur_hid_dev] = hid;
+
+	hid->ll_driver = &heci_hid_ll_driver;
+	hid->hid_get_raw_report = heci_hid_get_raw_report;
+	hid->hid_output_raw_report = heci_hid_output_raw_report;
+	hid->bus = BUS_HECI;
+	hid->version = le16_to_cpu(ISH_HID_VERSION);
+	hid->vendor = le16_to_cpu(ISH_HID_VENDOR);
+	hid->product = le16_to_cpu(ISH_HID_PRODUCT);
+
+	snprintf(hid->name, sizeof(hid->name), "%s %04hX:%04hX", "hid-heci",
+		hid->vendor, hid->product);
+
+	rv = hid_add_device(hid);
+	if (rv) {
+		if (rv != -ENODEV)
+			hid_err(hid, "[hid-heci]: can't add HID device: %d\n",
+				rv);
+		kfree(hid);
+		return	rv;
+	}
+
+#if 0
+	/* Initialize all reports */
+	list_for_each_entry(report,
+		&hid->report_enum[HID_FEATURE_REPORT].report_list, list)
+		hid_heci_get_report(hid, report->id, HID_FEATURE_REPORT);
+#endif
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
+	return 0;
+}
+
+void	heci_hid_remove(void)
+{
+	int	i;
+
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():+++\n", __func__);
+	for (i = 0; i < num_hid_devices; ++i)
+		if (hid_sensor_hubs[i]) {
+			hid_destroy_device(hid_sensor_hubs[i]);
+			hid_sensor_hubs[i] = NULL;
+		}
+	ISH_DBG_PRINT(KERN_ALERT "[hid-heci]: %s():---\n", __func__);
+}
+
+void register_flush_cb(void (*flush_cb_func)(void))
+{
+	flush_cb = flush_cb_func;
+}
+EXPORT_SYMBOL_GPL(register_flush_cb);
+
diff --git a/drivers/misc/intel-ish/heci-hid.h b/drivers/misc/intel-ish/heci-hid.h
new file mode 100644
index 0000000..62c1e5b
--- /dev/null
+++ b/drivers/misc/intel-ish/heci-hid.h
@@ -0,0 +1,133 @@
+/*
+ * HECI-HID glue driver's definitions.
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#ifndef HECI_HID__H
+#define	HECI_HID__H
+
+/*
+ * Constraint 1: currently we support only 1 ISS HW controller in a system
+ */
+
+static const uuid_le ish_heci_guid = UUID_LE(0x33AECD58, 0xB679, 0x4E54,
+						0x9B, 0xD9, 0xA0, 0x4D, 0x34,
+						0xF0, 0xC2, 0x26);
+
+extern wait_queue_head_t	heci_hid_wait;
+
+/*flush notification*/
+extern void (*flush_cb)(void);
+
+struct hostif_msg_hdr {
+	uint8_t	command;	/* Bit 7: is_response */
+#define	CMD_MASK	0x7F
+#define	IS_RESPONSE	0x80
+	uint8_t	device_id;
+	uint8_t	status;
+	uint8_t	flags;
+	uint16_t	size;
+} __packed;
+
+struct hostif_msg {
+	struct hostif_msg_hdr	hdr;
+} __packed;
+
+struct hostif_msg_to_sensor {
+	struct hostif_msg_hdr	hdr;
+	uint8_t	report_id;
+} __packed;
+
+struct device_info {
+	uint32_t	dev_id;
+	uint8_t		dev_class;
+	uint16_t	pid;
+	uint16_t	vid;
+} __packed;
+
+#if 0
+/* Needed? */
+struct heci_client {
+	uint32_t	max_msg_len;
+	uint8_t		proto_ver;
+} __packed;
+#endif
+
+struct heci_version {
+	uint8_t	major;
+	uint8_t	minor;
+	uint8_t	hotfix;
+	uint16_t	build;
+} __packed;
+
+/*
+ * struct for heci aggregated input data
+ */
+struct report_list {
+	uint16_t total_size;
+	uint8_t  num_of_reports;
+	uint8_t  flags;
+	struct {
+		uint16_t  size_of_report;
+		uint8_t report[1];
+	} __packed reports[1];
+} __packed;
+
+/* HOSTIF commands */
+#define	HOSTIF_HID_COMMAND_BASE		0
+#define	HOSTIF_GET_HID_DESCRIPTOR	0
+#define	HOSTIF_GET_REPORT_DESCRIPTOR	1
+#define HOSTIF_GET_FEATURE_REPORT	2
+#define	HOSTIF_SET_FEATURE_REPORT	3
+#define	HOSTIF_GET_INPUT_REPORT		4
+#define	HOSTIF_PUBLISH_INPUT_REPORT	5
+/*#define	HOSTIF_GET_OUTPUT_REPORT	6*/
+/*#define	HOSTIF_SET_OUTPUT_REPORT	7*/
+#define	HOSTIF_PUBLISH_INPUT_REPORT_LIST	6
+#define	HOSTIF_DM_COMMAND_BASE		32
+#define	HOSTIF_DM_ENUM_DEVICES		33
+#define	HOSTIF_DM_ADD_DEVICE		34
+
+/* Meaning, too large data source = "over 9000?" :-) */
+#define	MAX_DATA_BUF	9000
+
+#define	MAX_HID_DEVICES	32
+
+#include "utils.h"
+
+extern unsigned char	*report_descr[MAX_HID_DEVICES];
+extern int	report_descr_size[MAX_HID_DEVICES];
+extern struct device_info	*hid_devices;
+extern int	may_send;
+extern int	get_report_done; /* Get Feature/Input report complete flag */
+extern unsigned	cur_hid_dev;
+extern struct hid_device	*hid_sensor_hubs[MAX_HID_DEVICES];
+extern unsigned	num_hid_devices;
+extern struct heci_cl  *hid_heci_cl;	/* HECI client */
+
+void hid_heci_set_feature(struct hid_device *hid, char *buf, unsigned len,
+	int report_id);
+void hid_heci_get_report(struct hid_device *hid, int report_id,
+	int report_type);
+
+int	heci_hid_probe(unsigned cur_hid_dev);
+void	heci_hid_remove(void);
+
+/*flush notification*/
+void register_flush_cb(void (*flush_cb_func)(void));
+
+/*********** Locally redirect ISH_DBG_PRINT **************/
+void g_ish_print_log(char *format, ...);
+/*********************************************************/
+
+#endif	/* HECI_HID__H */
+
diff --git a/drivers/misc/intel-ish/heci_dev.h b/drivers/misc/intel-ish/heci_dev.h
new file mode 100644
index 0000000..bc857c5
--- /dev/null
+++ b/drivers/misc/intel-ish/heci_dev.h
@@ -0,0 +1,351 @@
+/*
+ * Most HECI provider device and HECI logic declarations
+ *
+ * Copyright (c) 2003-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_DEV_H_
+#define _HECI_DEV_H_
+
+#include "platform-config.h"
+#include <linux/types.h>
+#include <linux/watchdog.h>
+#include <linux/poll.h>
+#include "bus.h"
+#include "hbm.h"
+#include <linux/spinlock.h>
+
+#define	IPC_PAYLOAD_SIZE	128
+#define HECI_RD_MSG_BUF_SIZE	IPC_PAYLOAD_SIZE
+/* Number of messages to be held in ISR->BH FIFO */
+#define	RD_INT_FIFO_SIZE	64
+#define	IPC_FULL_MSG_SIZE	132
+/*
+ * Number of IPC messages to be held in Tx FIFO, to be sent by ISR -
+ * Tx complete interrupt or RX_COMPLETE handler
+ */
+#define	IPC_TX_FIFO_SIZE	512
+
+/*
+ * Number of Maximum HECI Clients
+ */
+#define HECI_CLIENTS_MAX 256
+
+/*
+ * Number of File descriptors/handles
+ * that can be opened to the driver.
+ *
+ * Limit to 255: 256 Total Clients
+ * minus internal client for HECI Bus Messags
+ */
+#define  HECI_MAX_OPEN_HANDLE_COUNT (HECI_CLIENTS_MAX - 1)
+
+/*
+ * Internal Clients Number
+ */
+#define HECI_HOST_CLIENT_ID_ANY        (-1)
+#define HECI_HBM_HOST_CLIENT_ID         0 /* not used, just for documentation */
+
+/* HECI device states */
+enum heci_dev_state {
+	HECI_DEV_INITIALIZING = 0,
+	HECI_DEV_INIT_CLIENTS,
+	HECI_DEV_ENABLED,
+	HECI_DEV_RESETTING,
+	HECI_DEV_DISABLED,
+	HECI_DEV_POWER_DOWN,
+	HECI_DEV_POWER_UP
+};
+
+const char *heci_dev_state_str(int state);
+
+/**
+ * struct heci_me_client - representation of me (fw) client
+ *
+ * @props  - client properties
+ * @client_id - me client id
+ */
+struct heci_me_client {
+	struct heci_client_properties props;
+	u8 client_id;
+};
+
+
+struct heci_cl;
+
+/*
+ * Intel HECI message data struct
+ */
+struct heci_msg_data {
+	u32 size;
+	int	dma_flag;	/* non-0 if this is DMA msg buf */
+	unsigned char *data;
+};
+
+/**
+ * struct heci_cl_rb - request block (was: callback) structure
+ *
+ * @cl - client who is running this operation
+ * @type - request type
+ */
+struct heci_cl_rb {
+	struct list_head list;
+	struct heci_cl *cl;
+	struct heci_msg_data buffer;
+	unsigned long buf_idx;
+	unsigned long read_time;
+};
+
+
+struct wr_msg_ctl_info {
+	void	(*ipc_send_compl)(void *);	/* Will be called with
+					'ipc_send_compl_prm' as parameter */
+	void	*ipc_send_compl_prm;
+	size_t length;
+	struct list_head	link;
+	unsigned char	inline_data[IPC_FULL_MSG_SIZE];
+};
+
+/** struct heci_hw_ops
+ *
+ * @host_is_ready    - query for host readiness
+ * @hw_is_ready      - query if hw is ready
+ * @hw_reset         - reset hw
+ * @hw_start         - start hw after reset
+ * @hw_config        - configure hw
+ * @write            - write a message to FW
+ */
+struct heci_hw_ops {
+	bool (*host_is_ready)(struct heci_device *dev);
+	bool (*hw_is_ready)(struct heci_device *dev);
+	int (*hw_reset)(struct heci_device *dev);
+	int (*ipc_reset)(struct heci_device *dev);
+	int (*hw_start)(struct heci_device *dev);
+	void (*hw_config)(struct heci_device *dev);
+	int (*write)(struct heci_device *dev, struct heci_msg_hdr *hdr,
+		unsigned char *buf);
+	int (*write_ex)(struct heci_device *dev, struct heci_msg_hdr *hdr,
+		void *msg, void(*ipc_send_compl)(void *),
+		void *ipc_send_compl_prm);
+	int (*read)(struct heci_device *dev, unsigned char *buffer,
+		unsigned long buffer_length);
+	u32 (*get_fw_status)(struct heci_device *dev);
+};
+
+#define PRINT_BUFFER_SIZE 204800
+
+/**
+ * struct heci_device -  HECI private device struct
+ *
+ * @hbm_state - state of host bus message protocol
+ * @mem_addr - mem mapped base register address
+ */
+struct heci_device {
+	struct pci_dev *pdev;	/* pointer to pci device struct */
+	/*
+	 * lists of queues
+	 */
+
+	/* array of pointers to aio lists */
+	struct heci_cl_rb read_list;		/* driver read queue */
+	spinlock_t      read_list_spinlock;
+
+	/*
+	 * list of heci_cl's (formerly: files)
+	 */
+	struct list_head cl_list;
+	spinlock_t      cl_list_lock;
+	long open_handle_count;			/* Why's this?.. */
+
+	/*
+	 * lock for the device
+	 * for everything that doesn't have a dedicated spinlock
+	 */
+	spinlock_t	device_lock;
+
+	bool recvd_hw_ready;
+	/*
+	 * waiting queue for receive message from FW
+	 */
+	wait_queue_head_t wait_hw_ready;
+	wait_queue_head_t wait_hbm_recvd_msg;
+	wait_queue_head_t wait_dma_ready;
+
+	/*
+	 * heci device  states
+	 */
+	enum heci_dev_state dev_state;
+	enum heci_hbm_state hbm_state;
+
+	/* FIFO for input messages for BH processing */
+	unsigned char	rd_msg_fifo[RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE];
+	unsigned	rd_msg_fifo_head, rd_msg_fifo_tail;
+	spinlock_t	rd_msg_spinlock;
+	struct work_struct	bh_hbm_work;
+
+#if 0
+	/*
+	 * FIFO for output IPC messages. Includes also HECI/IPC header
+	 * to be supplied in DRBL (first dword)
+	 */
+	unsigned char	wr_msg_fifo[IPC_TX_FIFO_SIZE * IPC_FULL_MSG_SIZE];
+#endif
+	/*
+	 * Control info for IPC messages HECI/IPC sending FIFO -
+	 * list with inline data buffer
+	 * This structure will be filled with parameters submitted
+	 * by the caller glue layer
+	 * 'buf' may be pointing to the external buffer or to 'inline_data'
+	 * 'offset' will be initialized to 0 by submitting
+	 *
+	 * 'ipc_send_compl' is intended for use by clients that send fragmented
+	 * messages. When a fragment is sent down to IPC msg regs,
+	 * it will be called.
+	 * If it has more fragments to send, it will do it. With last fragment
+	 * it will send appropriate HECI "message-complete" flag.
+	 * It will remove the outstanding message
+	 * (mark outstanding buffer as available).
+	 * If counting flow control is in work and there are more flow control
+	 * credits, it can put the next client message queued in cl.
+	 * structure for IPC processing.
+	 *
+	 * (!) We can work on FIFO list or cyclic FIFO in an array
+	 */
+
+	struct wr_msg_ctl_info wr_processing_list_head, wr_free_list_head;
+	spinlock_t wr_processing_spinlock;	/* For both processing
+						   and free lists */
+	spinlock_t	out_ipc_spinlock;
+/*
+	unsigned	wr_msg_fifo_head, wr_msg_fifo_tail;
+	spinlock_t	wr_msg_spinlock;
+*/
+	struct hbm_version version;
+	struct heci_me_client *me_clients; /* Note: memory has to be allocated*/
+	DECLARE_BITMAP(me_clients_map, HECI_CLIENTS_MAX);
+	DECLARE_BITMAP(host_clients_map, HECI_CLIENTS_MAX);
+	u8 me_clients_num;
+	u8 me_client_presentation_num;
+	u8 me_client_index;
+	spinlock_t      me_clients_lock;
+	/* List of bus devices */
+	struct list_head device_list;
+	spinlock_t      device_list_lock;
+
+	/* buffer to save prints from driver */
+	unsigned char log_buffer[PRINT_BUFFER_SIZE];
+	size_t log_head;
+	size_t log_tail;
+	void (*print_log)(struct heci_device *dev, char *format, ...);
+	spinlock_t      log_spinlock;   /* spinlock to protect prints buffer */
+	unsigned long	max_log_sec, max_log_usec;
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+	struct dentry *dbgfs_dir;
+#endif /* CONFIG_DEBUG_FS */
+
+	/* Debug stats */
+	unsigned	ipc_hid_out_fc;
+	int	ipc_hid_in_msg;
+	unsigned	ipc_hid_in_fc;
+	int	ipc_hid_out_msg;
+	unsigned	ipc_hid_out_fc_cnt;
+	unsigned	ipc_hid_in_fc_cnt;
+
+	unsigned	ipc_rx_cnt;
+	unsigned long long	ipc_rx_bytes_cnt;
+	unsigned	ipc_tx_cnt;
+	unsigned long long	ipc_tx_bytes_cnt;
+
+	const struct heci_hw_ops *ops;
+
+	size_t	mtu;
+	char hw[0] __aligned(sizeof(void *));
+};
+
+/*
+ * heci init function prototypes
+ */
+void heci_device_init(struct heci_device *dev);
+void heci_reset(struct heci_device *dev, int interrupts);
+int heci_start(struct heci_device *dev);
+void heci_stop(struct heci_device *dev);
+void	heci_device_disable(struct heci_device *dev);
+
+static inline unsigned long heci_secs_to_jiffies(unsigned long sec)
+{
+	return sec * HZ;	/*msecs_to_jiffies(sec * MSEC_PER_SEC);*/
+}
+
+/*
+ * Register Access Function
+ */
+static inline void heci_hw_config(struct heci_device *dev)
+{
+	dev->ops->hw_config(dev);
+}
+
+static inline int heci_ipc_reset(struct heci_device *dev)
+{
+	return dev->ops->ipc_reset(dev);
+}
+
+static inline int heci_hw_reset(struct heci_device *dev)
+{
+	return dev->ops->hw_reset(dev);
+}
+
+static inline int heci_hw_start(struct heci_device *dev)
+{
+	return dev->ops->hw_start(dev);
+}
+
+static inline bool heci_host_is_ready(struct heci_device *dev)
+{
+	return dev->ops->host_is_ready(dev);
+}
+
+static inline bool heci_hw_is_ready(struct heci_device *dev)
+{
+	return dev->ops->hw_is_ready(dev);
+}
+
+static inline int heci_write_message(struct heci_device *dev,
+	struct heci_msg_hdr *hdr, unsigned char *buf)
+{
+	return dev->ops->write_ex(dev, hdr, buf, NULL, NULL);
+}
+
+#if IS_ENABLED(CONFIG_DEBUG_FS)
+int heci_dbgfs_register(struct heci_device *dev, const char *name);
+void heci_dbgfs_deregister(struct heci_device *dev);
+#else
+static inline int heci_dbgfs_register(struct heci_device *dev, const char *name)
+{
+	return 0;
+}
+static inline void heci_dbgfs_deregister(struct heci_device *dev) {}
+#endif /* CONFIG_DEBUG_FS */
+
+
+int heci_register(struct heci_device *dev);
+void heci_deregister(struct heci_device *dev);
+
+void    heci_bus_remove_all_clients(struct heci_device *heci_dev);
+
+#define HECI_HDR_FMT "hdr:host=%02d me=%02d len=%d comp=%1d"
+#define HECI_HDR_PRM(hdr)		\
+	((hdr)->host_addr, (hdr)->me_addr,	\
+	(hdr)->length, (hdr)->msg_complete)
+
+#endif /*_HECI_DEV_H_*/
+
diff --git a/drivers/misc/intel-ish/hid-sens-ids.h b/drivers/misc/intel-ish/hid-sens-ids.h
new file mode 100644
index 0000000..bd866f5
--- /dev/null
+++ b/drivers/misc/intel-ish/hid-sens-ids.h
@@ -0,0 +1,586 @@
+/*
+ * HID Sensors Driver
+ * Copyright (c) 2012, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+#ifndef _HID_SENSORS_IDS_H
+#define _HID_SENSORS_IDS_H
+
+/***************************/
+
+#define HID_MAX_PHY_DEVICES					0xFF
+
+/* Accel 3D (200073) */
+#define HID_USAGE_SENSOR_ACCEL_3D				0x200073
+#define HID_USAGE_SENSOR_DATA_ACCELERATION			0x200452
+#define HID_USAGE_SENSOR_ACCEL_X_AXIS				0x200453
+#define HID_USAGE_SENSOR_ACCEL_Y_AXIS				0x200454
+#define HID_USAGE_SENSOR_ACCEL_Z_AXIS				0x200455
+
+/* ALS (200041) */
+#define HID_USAGE_SENSOR_ALS					0x200041
+#define HID_USAGE_SENSOR_DATA_LIGHT				0x2004d0
+#define HID_USAGE_SENSOR_LIGHT_ILLUM				0x2004d1
+
+/* Gyro 3D: (200076) */
+#define HID_USAGE_SENSOR_GYRO_3D				0x200076
+#define HID_USAGE_SENSOR_DATA_ANGL_VELOCITY			0x200456
+#define HID_USAGE_SENSOR_ANGL_VELOCITY_X_AXIS			0x200457
+#define HID_USAGE_SENSOR_ANGL_VELOCITY_Y_AXIS			0x200458
+#define HID_USAGE_SENSOR_ANGL_VELOCITY_Z_AXIS			0x200459
+
+/* ORIENTATION: Compass 3D: (200083) */
+#define HID_USAGE_SENSOR_COMPASS_3D				0x200083
+#define HID_USAGE_SENSOR_DATA_ORIENTATION			0x200470
+#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING			0x200471
+#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING_X			0x200472
+#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING_Y			0x200473
+#define HID_USAGE_SENSOR_ORIENT_MAGN_HEADING_Z			0x200474
+
+#define HID_USAGE_SENSOR_ORIENT_COMP_MAGN_NORTH			0x200475
+#define HID_USAGE_SENSOR_ORIENT_COMP_TRUE_NORTH			0x200476
+#define HID_USAGE_SENSOR_ORIENT_MAGN_NORTH			0x200477
+#define HID_USAGE_SENSOR_ORIENT_TRUE_NORTH			0x200478
+
+#define HID_USAGE_SENSOR_ORIENT_DISTANCE			0x200479
+#define HID_USAGE_SENSOR_ORIENT_DISTANCE_X			0x20047A
+#define HID_USAGE_SENSOR_ORIENT_DISTANCE_Y			0x20047B
+#define HID_USAGE_SENSOR_ORIENT_DISTANCE_Z			0x20047C
+#define HID_USAGE_SENSOR_ORIENT_DISTANCE_OUT_OF_RANGE		0x20047D
+
+/* ORIENTATION: Inclinometer 3D: (200086) */
+#define HID_USAGE_SENSOR_INCLINOMETER_3D			0x200086
+#define HID_USAGE_SENSOR_ORIENT_TILT				0x20047E
+#define HID_USAGE_SENSOR_ORIENT_TILT_X				0x20047F
+#define HID_USAGE_SENSOR_ORIENT_TILT_Y				0x200480
+#define HID_USAGE_SENSOR_ORIENT_TILT_Z				0x200481
+
+#define HID_USAGE_SENSOR_ORIENT_ROTATION_MATRIX			0x200482
+#define HID_USAGE_SENSOR_ORIENT_QUATERNION			0x200483
+#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX			0x200484
+
+#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX_X_AXIS		0x200485
+#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX_Y_AXIS		0x200486
+#define HID_USAGE_SENSOR_ORIENT_MAGN_FLUX_Z_AXIS		0x200487
+
+/* Time (2000a0) */
+#define HID_USAGE_SENSOR_TIME					0x2000a0
+#define HID_USAGE_SENSOR_TIME_YEAR				0x200521
+#define HID_USAGE_SENSOR_TIME_MONTH				0x200522
+#define HID_USAGE_SENSOR_TIME_DAY				0x200523
+#define HID_USAGE_SENSOR_TIME_HOUR				0x200525
+#define HID_USAGE_SENSOR_TIME_MINUTE				0x200526
+#define HID_USAGE_SENSOR_TIME_SECOND				0x200527
+
+/* Units */
+#define HID_USAGE_SENSOR_UNITS_NOT_SPECIFIED			0x00
+#define HID_USAGE_SENSOR_UNITS_LUX				0x01
+#define HID_USAGE_SENSOR_UNITS_KELVIN				0x01000100
+#define HID_USAGE_SENSOR_UNITS_FAHRENHEIT			0x03000100
+#define HID_USAGE_SENSOR_UNITS_PASCAL				0xF1E1
+#define HID_USAGE_SENSOR_UNITS_NEWTON				0x11E1
+#define HID_USAGE_SENSOR_UNITS_METERS_PER_SECOND		0x11F0
+#define HID_USAGE_SENSOR_UNITS_METERS_PER_SEC_SQRD		0x11E0
+#define HID_USAGE_SENSOR_UNITS_FARAD				0xE14F2000
+#define HID_USAGE_SENSOR_UNITS_AMPERE				0x01001000
+#define HID_USAGE_SENSOR_UNITS_WATT				0x21d1
+#define HID_USAGE_SENSOR_UNITS_HENRY				0x21E1E000
+#define HID_USAGE_SENSOR_UNITS_OHM				0x21D1E000
+#define HID_USAGE_SENSOR_UNITS_VOLT				0x21D1F000
+#define HID_USAGE_SENSOR_UNITS_HERTZ				0x01F0
+#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SEC_SQRD		0x14E0
+#define HID_USAGE_SENSOR_UNITS_RADIANS				0x12
+#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SECOND		0x12F0
+#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SEC_SQRD		0x12E0
+#define HID_USAGE_SENSOR_UNITS_SECOND				0x0110
+#define HID_USAGE_SENSOR_UNITS_GAUSS				0x01E1F000
+#define HID_USAGE_SENSOR_UNITS_GRAM				0x0101
+#define HID_USAGE_SENSOR_UNITS_CENTIMETER			0x11
+#define HID_USAGE_SENSOR_UNITS_G				0x1A
+#define HID_USAGE_SENSOR_UNITS_MILLISECOND			0x19
+#define HID_USAGE_SENSOR_UNITS_PERCENT				0x17
+#define HID_USAGE_SENSOR_UNITS_DEGREES				0x14
+#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SECOND		0x15
+
+/* Common selectors */
+#define HID_USAGE_SENSOR_PROP_REPORT_INTERVAL			0x20030E
+#define HID_USAGE_SENSOR_PROP_SENSITIVITY_ABS			0x20030F
+#define HID_USAGE_SENSOR_PROP_SENSITIVITY_RANGE_PCT		0x200310
+#define HID_USAGE_SENSOR_PROP_SENSITIVITY_REL_PCT		0x200311
+#define HID_USAGE_SENSOR_PROP_ACCURACY				0x200312
+#define HID_USAGE_SENSOR_PROP_RESOLUTION			0x200313
+#define HID_USAGE_SENSOR_PROP_RANGE_MAXIMUM			0x200314
+#define HID_USAGE_SENSOR_PROP_RANGE_MINIMUM			0x200315
+#define HID_USAGE_SENSOR_PROP_REPORT_STATE			0x200316
+#define HID_USAGE_SENSOR_PROY_POWER_STATE			0x200319
+
+/* Per data field properties */
+#define HID_USAGE_SENSOR_DATA_MOD_NONE					0x00
+#define HID_USAGE_SENSOR_DATA_MOD_CHANGE_SENSITIVITY_ABS		0x1000
+
+/* Power state enumerations */
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_UNDEFINED_ENUM       0x200850
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D0_FULL_POWER_ENUM   0x200851
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D1_LOW_POWER_ENUM    0x200852
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM 0x200853
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM 0x200854
+#define HID_USAGE_SENSOR_PROP_POWER_STATE_D4_POWER_OFF_ENUM    0x200855
+
+/* Report State enumerations */
+#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_NO_EVENTS_ENUM   0x200840
+#define HID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM  0x200841
+
+/**************************/
+
+
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_RELATIVE_HUMIDITY 0x200433
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_TEMPERATURE 0x200434
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_DIRECTION 0x200435
+#define HID_USAGE_SENSOR_DATA_ENVIRONMENTAL_WIND_SPEED 0x200436
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL 0x200440
+#define HID_USAGE_SENSOR_PROPERTY_ENVIRONMENTAL_REFERENCE_PRESSURE 0x200441
+
+/* data type motion */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_MOTION 0x200450
+#define HID_USAGE_SENSOR_DATA_MOTION_STATE 0x200451
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION 0x200452
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_X_AXIS 0x200453
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Y_AXIS 0x200454
+#define HID_USAGE_SENSOR_DATA_MOTION_ACCELERATION_Z_AXIS 0x200455
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY 0x200456
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_X_AXIS 0x200457
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Y_AXIS 0x200458
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_VELOCITY_Z_AXIS 0x200459
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION 0x20045A
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_X_AXIS 0x20045B
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Y_AXIS 0x20045C
+#define HID_USAGE_SENSOR_DATA_MOTION_ANGULAR_POSITION_Z_AXIS 0x20045D
+#define HID_USAGE_SENSOR_DATA_MOTION_SPEED 0x20045E
+#define HID_USAGE_SENSOR_DATA_MOTION_INTENSITY 0x20045F
+
+/* data type orientation */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_ORIENTATION 0x200470
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING 0x200471
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_X 0x200472
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Y 0x200473
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_HEADING_Z 0x200474
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_MAGNETIC_NORTH 0x200475
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_COMPENSATED_TRUE_NORTH 0x200476
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_NORTH 0x200477
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TRUE_NORTH 0x200478
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE 0x200479
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_X 0x20047A
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Y 0x20047B
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_Z 0x20047C
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_DISTANCE_OUT_OF_RANGE 0x20047D
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT 0x20047E
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_X 0x20047F
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Y 0x200480
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_TILT_Z 0x200481
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_ROTATION_MATRIX 0x200482
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_QUATERNION 0x200483
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX 0x200484
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_X_AXIS 0x200485
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Y_AXIS 0x200486
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETIC_FLUX_Z_AXIS 0x200487
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY 0x200488
+
+/* data type mechanical */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_MECHANICAL 0x200490
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_STATE 0x200491
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_BOOLEAN_SWITCH_ARRAY_STATES 0x200492
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_MULTIVALUE_SWITCH_VALUE 0x200493
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_FORCE 0x200494
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_ABSOLUTE_PRESSURE 0x200495
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_GAUGE_PRESSURE 0x200496
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_STRAIN 0x200497
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_WEIGHT 0x200498
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL 0x2004A0
+#define HID_USAGE_SENSOR_PROPERTY_MECHANICAL_VIBRATION_STATE 0x2004A1
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_FORWARD 0x2004A2
+#define HID_USAGE_SENSOR_DATA_MECHANICAL_VIBRATION_SPEED_BACKWARD 0x2004A3
+
+/* data type biometric */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC 0x2004B0
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PRESENCE 0x2004B1
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_RANGE 0x2004B2
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_PROXIMITY_OUT_OF_RANGE 0x2004B3
+#define HID_USAGE_SENSOR_DATA_BIOMETRIC_HUMAN_TOUCH_STATE 0x2004B4
+
+/* data type light sensor */
+/* data field usages (input report) */
+/*#define HID_USAGE_SENSOR_DATA_LIGHT 0x2004D0*/
+#define HID_USAGE_SENSOR_DATA_LIGHT_ILLUMINANCE 0x2004D1
+#define HID_USAGE_SENSOR_DATA_LIGHT_COLOR_TEMPERATURE 0x2004D2
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY 0x2004D3
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_X 0x2004D4
+#define HID_USAGE_SENSOR_DATA_LIGHT_CHROMATICITY_Y 0x2004D5
+#define HID_USAGE_SENSOR_DATA_LIGHT_CONSUMER_IR_SENTENCE_RECEIVE 0x2004D6
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_LIGHT 0x2004E0
+#define HID_USAGE_SENSOR_PROPERTY_LIGHT_CONSUMER_IR_SENTENCE_SEND 0x2004E1
+
+/* data type scanner */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_SCANNER 0x2004F0
+#define HID_USAGE_SENSOR_DATA_SCANNER_RFID_TAG 0x2004F1
+#define HID_USAGE_SENSOR_DATA_SCANNER_NFC_SENTENCE_RECEIVE 0x2004F2
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_SCANNER 0x2004F8
+#define HID_USAGE_SENSOR_PROPERTY_SCANNER_NFC_SENTENCE_SEND 0x2004F9
+
+/* data type electrical */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL 0x200500
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CAPACITANCE 0x200501
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_CURRENT 0x200502
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_POWER 0x200503
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_INDUCTANCE 0x200504
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_RESISTANCE 0x200505
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_VOLTAGE 0x200506
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_FREQUENCY 0x200507
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERIOD 0x200508
+#define HID_USAGE_SENSOR_DATA_ELECTRICAL_PERCENT_OF_RANGE 0x200509
+
+/* data type time */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_TIME 0x200520
+#define HID_USAGE_SENSOR_DATA_TIME_YEAR 0x200521
+#define HID_USAGE_SENSOR_DATA_TIME_MONTH 0x200522
+#define HID_USAGE_SENSOR_DATA_TIME_DAY 0x200523
+#define HID_USAGE_SENSOR_DATA_TIME_DAY_OF_WEEK 0x200524
+#define HID_USAGE_SENSOR_DATA_TIME_HOUR 0x200525
+#define HID_USAGE_SENSOR_DATA_TIME_MINUTE 0x200526
+#define HID_USAGE_SENSOR_DATA_TIME_SECOND 0x200527
+#define HID_USAGE_SENSOR_DATA_TIME_MILLISECOND 0x200528
+#define HID_USAGE_SENSOR_DATA_TIME_TIMESTAMP 0x200529
+#define HID_USAGE_SENSOR_DATA_TIME_JULIAN_DAY_OF_YEAR 0x20052A
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY_TIME 0x200530
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_OFFSET_FROM_UTC 0x200531
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_ZONE_NAME 0x200532
+#define HID_USAGE_SENSOR_PROPERTY_TIME_DAYLIGHT_SAVINGS_TIME_OBSERVED 0x200533
+#define HID_USAGE_SENSOR_PROPERTY_TIME_TIME_TRIM_ADJUSTMENT 0x200534
+#define HID_USAGE_SENSOR_PROPERTY_TIME_ARM_ALARM 0x200535
+
+/* data type custom */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_CUSTOM 0x200540
+#define HID_USAGE_SENSOR_DATA_CUSTOM_USAGE 0x200541
+#define HID_USAGE_SENSOR_DATA_CUSTOM_BOOLEAN_ARRAY 0x200542
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE 0x200543
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_1 0x200544
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_2 0x200545
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_3 0x200546
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_4 0x200547
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_5 0x200548
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_6 0x200549
+
+#if 1 /* define vendor-specific (non-spec) custom datafields */
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_7 0x20054A
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_8 0x20054B
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_9 0x20054C
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_10 0x20054D
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_11 0x20054E
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_12 0x20054F
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_13 0x200550
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_14 0x200551
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_15 0x200552
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_16 0x200553
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_17 0x200554
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_18 0x200555
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_19 0x200556
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_20 0x200557
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_21 0x200558
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_22 0x200559
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_23 0x20055A
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_24 0x20055B
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_25 0x20055C
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_26 0x20055D
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_27 0x20055E
+#define HID_USAGE_SENSOR_DATA_CUSTOM_VALUE_28 0x20055F
+#endif
+
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_MONITOR 0x200583
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_SYSTOLIC_BLOOD_PRESSURE 0x200584
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_DYSTOLIC_BLOOD_PRESSURE 0x200585
+#define HID_DRIVER_USAGE_SENSOR_DATA_CUSTOM_HEALTH_HEART_BEAT 0x200586
+
+/* data type generic */
+/* data field usages (input report) */
+#define HID_USAGE_SENSOR_DATA_GENERIC 0x200560
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY 0x200561
+#define HID_USAGE_SENSOR_DATA_GENERIC_CATEGORY_GUID 0x200562
+#define HID_USAGE_SENSOR_DATA_GENERIC_TYPE_GUID 0x200563
+#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT_PROPERTYKEY 0x200564
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY_PROPERTYKEY 0x200565
+#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD_PROPERTYKEY 0x200566
+#define HID_USAGE_SENSOR_DATA_GENERIC_EVENT 0x200567
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTY 0x200568
+#define HID_USAGE_SENSOR_DATA_GENERIC_DATAFIELD 0x200569
+#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_INDEX 0x20056A
+#define HID_USAGE_SENSOR_DATA_ENUMERATOR_TABLE_ROW_COUNT 0x20056B
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID_OR_PROPERTYKEY_KIND 0x20056C
+/* begin GorPK kind selectors */
+#define HID_USAGE_SENSOR_GORPK_KIND_CATEGORY 0x2008D0
+#define HID_USAGE_SENSOR_GORPK_KIND_TYPE 0x2008D1
+#define HID_USAGE_SENSOR_GORPK_KIND_EVENT 0x2008D2
+#define HID_USAGE_SENSOR_GORPK_KIND_PROPERTY 0x2008D3
+#define HID_USAGE_SENSOR_GORPK_KIND_DATAFIELD 0x2008D4
+/* end GorPK kind selectors */
+#define HID_USAGE_SENSOR_DATA_GENERIC_GUID 0x20056D
+#define HID_USAGE_SENSOR_DATA_GENERIC_PROPERTYKEY 0x20056E
+#define HID_USAGE_SENSOR_DATA_GENERIC_TOP_LEVEL_COLLECTION_ID 0x20056F
+#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ID 0x200570
+#define HID_USAGE_SENSOR_DATA_GENERIC_REPORT_ITEM_POSITION_INDEX 0x200571
+#define HID_USAGE_SENSOR_DATA_GENERIC_FIRMWARE_VARTYPE 0x200572
+
+/* Units */
+#define HID_USAGE_SENSOR_UNITS_NOT_SPECIFIED			0x00
+#define HID_USAGE_SENSOR_UNITS_LUX				0x01
+#define HID_USAGE_SENSOR_UNITS_KELVIN				0x01000100
+#define HID_USAGE_SENSOR_UNITS_FAHRENHEIT			0x03000100
+#define HID_USAGE_SENSOR_UNITS_PASCAL				0xF1E1
+#define HID_USAGE_SENSOR_UNITS_NEWTON				0x11E1
+#define HID_USAGE_SENSOR_UNITS_METERS_PER_SECOND		0x11F0
+#define HID_USAGE_SENSOR_UNITS_METERS_PER_SEC_SQRD		0x11E0
+#define HID_USAGE_SENSOR_UNITS_FARAD				0xE14F2000
+#define HID_USAGE_SENSOR_UNITS_AMPERE				0x01001000
+#define HID_USAGE_SENSOR_UNITS_WATT				0x21d1
+#define HID_USAGE_SENSOR_UNITS_HENRY				0x21E1E000
+#define HID_USAGE_SENSOR_UNITS_OHM				0x21D1E000
+#define HID_USAGE_SENSOR_UNITS_VOLT				0x21D1F000
+#define HID_USAGE_SENSOR_UNITS_HERTZ				0x01F0
+#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SEC_SQRD		0x14E0
+#define HID_USAGE_SENSOR_UNITS_RADIANS				0x12
+#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SECOND		0x12F0
+#define HID_USAGE_SENSOR_UNITS_RADIANS_PER_SEC_SQRD		0x12E0
+#define HID_USAGE_SENSOR_UNITS_SECOND				0x0110
+#define HID_USAGE_SENSOR_UNITS_GAUSS				0x01E1F000
+#define HID_USAGE_SENSOR_UNITS_GRAM				0x0101
+#define HID_USAGE_SENSOR_UNITS_CENTIMETER			0x11
+#define HID_USAGE_SENSOR_UNITS_G				0x1A
+#define HID_USAGE_SENSOR_UNITS_MILLISECOND			0x19
+#define HID_USAGE_SENSOR_UNITS_PERCENT				0x17
+#define HID_USAGE_SENSOR_UNITS_DEGREES				0x14
+#define HID_USAGE_SENSOR_UNITS_DEGREES_PER_SECOND		0x15
+
+/* Modifiers (Mask of 0xF000 to data field number )*/
+#define HID_USAGE_SENSOR_MODIFIER_NONE				0x0000
+#define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_ABS		0x1000
+#define HID_USAGE_SENSOR_MODIFIER_MAX				0x2000
+#define HID_USAGE_SENSOR_MODIFIER_MIN				0x3000
+#define HID_USAGE_SENSOR_MODIFIER_ACCURACY			0x4000
+#define HID_USAGE_SENSOR_MODIFIER_RESOLUTION			0x5000
+#define HID_USAGE_SENSOR_MODIFIER_THRES_HIGH			0x6000
+#define HID_USAGE_SENSOR_MODIFIER_THRES_LOW			0x7000
+#define HID_USAGE_SENSOR_MODIFIER_CALIBRATION_OFFSET		0x8000
+#define HID_USAGE_SENSOR_MODIFIER_CALIBRATION_MULTIPLIER	0x9000
+#define HID_USAGE_SENSOR_MODIFIER_REPORT_INTERVAL		0xA000
+#define HID_USAGE_SENSOR_MODIFIER_FREQ_MAX			0xB000
+#define HID_USAGE_SENSOR_MODIFIER_PERIOD_MAX			0xC000
+#define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_PERCENT_RANGE	0xD000
+#define HID_USAGE_SENSOR_MODIFIER_CHG_SENSITIVITY_PERCENT_REL	0xE000
+
+/*state usages*/
+#define HID_USAGE_SENSOR_STATE 0x200201
+/* state selectors */
+#define HID_USAGE_SENSOR_STATE_UNKNOWN_SEL 0x200800
+#define HID_USAGE_SENSOR_STATE_READY_SEL 0x200801
+#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_SEL 0x200802
+#define HID_USAGE_SENSOR_STATE_NO_DATA_SEL 0x200803
+#define HID_USAGE_SENSOR_STATE_INITIALIZING_SEL 0x200804
+#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_SEL 0x200805
+#define HID_USAGE_SENSOR_STATE_ERROR_SEL 0x200806
+
+/* state enums */
+#define HID_USAGE_SENSOR_STATE_UNKNOWN_ENUM                                             0x01
+#define HID_USAGE_SENSOR_STATE_READY_ENUM                                               0x02
+#define HID_USAGE_SENSOR_STATE_NOT_AVAILABLE_ENUM                                       0x03
+#define HID_USAGE_SENSOR_STATE_NO_DATA_ENUM                                             0x04
+#define HID_USAGE_SENSOR_STATE_INITIALIZING_ENUM                                        0x05
+#define HID_USAGE_SENSOR_STATE_ACCESS_DENIED_ENUM                                       0x06
+#define HID_USAGE_SENSOR_STATE_ERROR_ENUM                                               0x07
+
+
+/* event usages */
+#define HID_USAGE_SENSOR_EVENT 0x200202
+/* event selectors */
+#define HID_USAGE_SENSOR_EVENT_UNKNOWN_SEL 0x200810
+#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_SEL 0x200811
+#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_SEL 0x200812
+#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_SEL 0x200813
+#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_SEL 0x200814
+#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_SEL 0x200815
+#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_SEL 0x200816
+#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_SEL 0x200817
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL 0x200818
+#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_SEL        HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL 0x200819
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_SEL       HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL 0x20081A
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_SEL        HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL 0x20081B
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_SEL        HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL 0x20081C
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_SEL       HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL 0x20081D
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_SEL       HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_SEL
+#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_SEL 0x20081E
+#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_SEL 0x20081F
+#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_SEL 0x200820
+
+/* event enums */
+#define HID_USAGE_SENSOR_EVENT_UNKNOWN_ENUM                                             0x01
+#define HID_USAGE_SENSOR_EVENT_STATE_CHANGED_ENUM                                       0x02
+#define HID_USAGE_SENSOR_EVENT_PROPERTY_CHANGED_ENUM                                    0x03
+#define HID_USAGE_SENSOR_EVENT_DATA_UPDATED_ENUM                                        0x04
+#define HID_USAGE_SENSOR_EVENT_POLL_RESPONSE_ENUM                                       0x05
+#define HID_USAGE_SENSOR_EVENT_CHANGE_SENSITIVITY_ENUM                                  0x06
+#define HID_USAGE_SENSOR_EVENT_MAX_REACHED_ENUM                                         0x07
+#define HID_USAGE_SENSOR_EVENT_MIN_REACHED_ENUM                                         0x08
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM 0x200009
+#define HID_USAGE_SENSOR_EVENT_HIGH_THESHOLD_CROSS_ABOVE_ENUM   HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM 0x200A00
+#define HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_BELOW_ENUM  HID_USAGE_SENSOR_EVENT_HIGH_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM                          0x0B
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_ABOVE_ENUM   HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM                        0x0C
+#define HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_BELOW_ENUM   HID_USAGE_SENSOR_EVENT_LOW_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM                         0x0D
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_ABOVE_ENUM  HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_UPWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM                       0x0E
+#define HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_BELOW_ENUM  HID_USAGE_SENSOR_EVENT_ZERO_THRESHOLD_CROSS_DOWNWARD_ENUM
+#define HID_USAGE_SENSOR_EVENT_PERIOD_EXCEEDED_ENUM                                     0x0F
+#define HID_USAGE_SENSOR_EVENT_FREQUENCY_EXCEEDED_ENUM                                  0x10
+#define HID_USAGE_SENSOR_EVENT_COMPLEX_TRIGGER_ENUM                                     0x11
+
+
+/* property usages (get/set feature report) */
+#define HID_USAGE_SENSOR_PROPERTY 0x200300
+#define HID_USAGE_SENSOR_PROPERTY_FRIENDLY_NAME 0x200301
+#define HID_USAGE_SENSOR_PROPERTY_PERSISTENT_UNIQUE_ID 0x200302
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_STATUS 0x200303
+#define HID_USAGE_SENSOR_PROPERTY_MINIMUM_REPORT_INTERVAL 0x200304
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MANUFACTURER 0x200305
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_MODEL 0x200306
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_SERIAL_NUMBER 0x200307
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DESCRIPTION 0x200308
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_CONNECTION_TYPE 0x200309
+/* begin connection type selectors */
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_SEL 0x200830
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_SEL 0x200831
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_SEL 0x200832
+/* end connection type selectors */
+
+/* begin connection type enums */
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_INTEGRATED_ENUM                    0x01
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_ATTACHED_ENUM                      0x02
+#define HID_USAGE_SENSOR_PROPERTY_CONNECTION_TYPE_PC_EXTERNAL_ENUM                      0x03
+/* end connection type enums */
+
+#define HID_USAGE_SENSOR_PROPERTY_SENSOR_DEVICE_PATH 0x20030A
+#define HID_USAGE_SENSOR_PROPERTY_HARDWARE_REVISION 0x20030B
+#define HID_USAGE_SENSOR_PROPERTY_FIRMWARE_VERSION 0x20030C
+#define HID_USAGE_SENSOR_PROPERTY_RELEASE_DATE 0x20030D
+#define HID_USAGE_SENSOR_PROPERTY_REPORT_INTERVAL 0x20030E
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_ABS 0x20030F
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_RANGE_PCT 0x200310
+#define HID_USAGE_SENSOR_PROPERTY_CHANGE_SENSITIVITY_REL_PCT 0x200311
+#define HID_USAGE_SENSOR_PROPERTY_ACCURACY 0x200312
+#define HID_USAGE_SENSOR_PROPERTY_RESOLUTION 0x200313
+#define HID_USAGE_SENSOR_PROPERTY_RANGE_MAXIMUM 0x200314
+#define HID_USAGE_SENSOR_PROPERTY_RANGE_MINIMUM 0x200315
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE 0x200316
+
+/* begin reporting state selectors */
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL 0x200840
+#define HID_USAGE_REPORTING_STATE_ON_NONE_SEL       HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL 0x200841
+#define HID_USAGE_REPORTING_STATE_ON_ALL_SEL        HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL 0x200842
+#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_SEL  HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_SEL
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_SEL 0x200843
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_SEL 0x200844
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_SEL 0x200845
+/* end reporting state selectors */
+
+/* begin reporting state enums */
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM                        0x01
+#define HID_USAGE_REPORTING_STATE_ON_NONE_ENUM      HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM                       0x02
+#define HID_USAGE_REPORTING_STATE_ON_ALL_ENUM       HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM                 0x03
+#define HID_USAGE_REPORTING_STATE_ON_THRESHOLD_ENUM HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_ENUM
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_NO_EVENTS_WAKE_ENUM                   0x04
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_ALL_EVENTS_WAKE_ENUM                  0x05
+#define HID_USAGE_SENSOR_PROPERTY_REPORTING_STATE_THRESHOLD_EVENTS_WAKE_ENUM            0x06
+/* end reporting state enums */
+
+#define HID_USAGE_SENSOR_PROPERTY_SAMPLING_RATE 0x200317
+#define HID_USAGE_SENSOR_PROPERTY_RESPONSE_CURVE 0x200318
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE 0x200319
+/* begin power state selectors */
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_SEL 0x200850
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_SEL 0x200851
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_SEL 0x200852
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_SEL 0x200853
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_SEL 0x200854
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_SEL 0x200855
+/* end power state selectors */
+
+/* begin power state enums */
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_UNDEFINED_ENUM                            0x01
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D0_FULL_POWER_ENUM                        0x02
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D1_LOW_POWER_ENUM                         0x03
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D2_STANDBY_WITH_WAKE_ENUM                 0x04
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D3_SLEEP_WITH_WAKE_ENUM                   0x05
+#define HID_USAGE_SENSOR_PROPERTY_POWER_STATE_D4_POWER_OFF_ENUM                         0x06
+/* end power state enums */
+
+/* begin orientation magnetometer accuracy selectors */
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_LOW 0x02008E0
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_MEDIUM 0x02008E1
+#define HID_USAGE_SENSOR_DATA_ORIENTATION_MAGNETOMETER_ACCURACY_HIGH 0x02008E2
+/* end orientation magnetometer accuracy selectors */
+
+#define HID_USAGE_SENSOR_DATA_GENERIC_UNIT_EXPONENT 0x200574
+/* begin unit exponent selectors */
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_0 0x200970
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_1 0x200971
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_2 0x200972
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_3 0x200973
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_4 0x200974
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_5 0x200975
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_6 0x200976
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_7 0x200977
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_8 0x200978
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_9 0x200979
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_A 0x20097A
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_B 0x20097B
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_C 0x20097C
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_D 0x20097D
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_E 0x20097E
+#define HID_USAGE_SENSOR_GENERIC_EXPONENT_F 0x20097F
+/* end unit exponent selectors */
+
+#endif
diff --git a/drivers/misc/intel-ish/hid-strings-def.h b/drivers/misc/intel-ish/hid-strings-def.h
new file mode 100644
index 0000000..c058f34
--- /dev/null
+++ b/drivers/misc/intel-ish/hid-strings-def.h
@@ -0,0 +1,519 @@
+/*
+ * HID sensor-related constants and names translations
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HID_STRINGS_DEF_H_
+#define _HID_STRINGS_DEF_H_
+
+
+static const struct sensor_map {
+	unsigned code;
+	char *msg;
+} code_msg_arr[] = {
+	{0x01,	"type_collection"},
+	{0x10,	"category_biometric"},
+	{0x11,	"type_biometric_presence"},
+	{0x12,	"type_biometric_proximity"},
+	{0x13,	"type_biometric_touch"},
+	{0x20,	"category_electrical"},
+	{0x21,	"type_electrical_capacitance"},
+	{0x22,	"type_electrical_current"},
+	{0x23,	"type_electrical_power"},
+	{0x24,	"type_electrical_inductance"},
+	{0x25,	"type_electrical_resistance"},
+	{0x26,	"type_electrical_voltage"},
+	{0x27,	"type_electrical_potentiometer"},
+	{0x28,	"type_electrical_frequency"},
+	{0x29,	"type_electrical_period"},
+	{0x30,	"category_environmental"},
+	{0x31,	"type_environmental_atmospheric_pressure"},
+	{0x32,	"type_environmental_humidity"},
+	{0x33,	"type_environmental_temperature"},
+	{0x34,	"type_environmental_wind_direction"},
+	{0x35,	"type_environmental_wind_speed"},
+	{0x40,	"category_light"},
+	{0x41,	"type_light_ambientlight"},
+	{0x42,	"type_light_consumer_infrared"},
+	{0x50,	"category_location"},
+	{0x51,	"type_location_broadcast"},
+	{0x52,	"type_location_dead_reckoning"},
+	{0x53,	"type_location_gps"},
+	{0x54,	"type_location_lookup"},
+	{0x55,	"type_location_other"},
+	{0x56,	"type_location_static"},
+	{0x57,	"type_location_triangulation"},
+	{0x60,	"category_mechanical"},
+	{0x61,	"type_mechanical_boolean_switch"},
+	{0x62,	"type_mechanical_boolean_switch_array"},
+	{0x63,	"type_mechanical_multivalue_switch"},
+	{0x64,	"type_mechanical_force"},
+	{0x65,	"type_mechanical_pressure"},
+	{0x66,	"type_mechanical_strain"},
+	{0x67,	"type_mechanical_scale_weight"},
+	{0x68,	"type_mechanical_vibrator"},
+	{0x69,	"type_mechanical_hall_effect_switch"},
+	{0x70,	"category_motion"},
+	{0x71,	"type_motion_accelerometer_1d"},
+	{0x72,	"type_motion_accelerometer_2d"},
+	{0x73,	"type_motion_accelerometer_3d"},
+	{0x74,	"type_motion_gyrometer_1d"},
+	{0x75,	"type_motion_gyrometer_2d"},
+	{0x76,	"type_motion_gyrometer_3d"},
+	{0x77,	"type_motion_motion_detector"},
+	{0x78,	"type_motion_speedometer"},
+	{0x79,	"type_motion_accelerometer"},
+	{0x7A,	"type_motion_gyrometer"},
+	{0x80,	"category_orientation"},
+	{0x81,	"type_orientation_compass_1d"},
+	{0x82,	"type_orientation_compass_2d"},
+	{0x83,	"type_orientation_compass_3d"},
+	{0x84,	"type_orientation_inclinometer_1d"},
+	{0x85,	"type_orientation_inclinometer_2d"},
+	{0x86,	"type_orientation_inclinometer_3d"},
+	{0x87,	"type_orientation_distance_1d"},
+	{0x88,	"type_orientation_distance_2d"},
+	{0x89,	"type_orientation_distance_3d"},
+	{0x8A,	"type_orientation_device_orientation"},
+	{0x8B,	"type_orientation_compass"},
+	{0x8C,	"type_orientation_inclinometer"},
+	{0x8D,	"type_orientation_distance"},
+	{0x90,	"category_scanner"},
+	{0x91,	"type_scanner_barcode"},
+	{0x92,	"type_scanner_rfid"},
+	{0x93,	"type_scanner_nfc"},
+	{0xA0,	"category_time"},
+	{0xA1,	"type_time_alarm"},
+	{0xA2,	"type_time_rtc"},
+	{0xE0,	"category_other"},
+	{0xE1,	"type_other_custom"},
+	{0xE2,	"type_other_generic"},
+	{0xE3,	"type_other_generic_enumerator"},
+	{0xE4,	"type_other_health_monitor"},
+	{0x0201,	"property_sensor_state"},
+	{0x0800,	"state_unknown_sel"},
+	{0x0801,	"state_ready_sel"},
+	{0x0802,	"state_not_available_sel"},
+	{0x0803,	"state_no_data_sel"},
+	{0x0804,	"state_initializing_sel"},
+	{0x0805,	"state_access_denied_sel"},
+	{0x0806,	"state_error_sel"},
+	{0x0202,	"event"},
+	{0x0810,	"event_unknown_sel"},
+	{0x0811,	"event_state_changed_sel"},
+	{0x0812,	"event_property_changed_sel"},
+	{0x0813,	"event_data_updated_sel"},
+	{0x0814,	"event_poll_response_sel"},
+	{0x0815,	"event_change_sensitivity_sel"},
+	{0x0816,	"event_max_reached_sel"},
+	{0x0817,	"event_min_reached_sel"},
+	{0x0818,	"event_high_threshold_cross_upward_sel"},
+	{0x0819,	"event_high_threshold_cross_downward_sel"},
+	{0x081A,	"event_low_threshold_cross_upward_sel"},
+	{0x081B,	"event_low_threshold_cross_downward_sel"},
+	{0x081C,	"event_zero_threshold_cross_upward_sel"},
+	{0x081D,	"event_zero_threshold_cross_downward_sel"},
+	{0x081E,	"event_period_exceeded_sel"},
+	{0x081F,	"event_frequency_exceeded_sel"},
+	{0x0820,	"event_complex_trigger_sel"},
+	{0x0300,	"property"},
+	{0x0301,	"property_friendly_name"},
+	{0x0302,	"property_persistent_unique_id"},
+	{0x0303,	"property_sensor_status"},
+	{0x0304,	"property_minimum_report_interval"},
+	{0x0305,	"property_sensor_manufacturer"},
+	{0x0306,	"property_sensor_model"},
+	{0x0307,	"property_sensor_serial_number"},
+	{0x0308,	"property_sensor_description"},
+	{0x0309,	"property_sensor_connection_type"},
+	{0x0830,	"property_connection_type_pc_integrated_sel"},
+	{0x0831,	"property_connection_type_pc_attached_sel"},
+	{0x0832,	"property_connection_type_pc_external_sel"},
+	{0x030A,	"property_sensor_device_path"},
+	{0x030B,	"property_hardware_revision"},
+	{0x030C,	"property_firmware_version"},
+	{0x030D,	"property_release_date"},
+	{0x030E,	"property_report_interval"},
+	{0x030F,	"property_change_sensitivity_abs"},
+	{0x0310,	"property_change_sensitivity_range_pct"},
+	{0x0311,	"property_change_sensitivity_rel_pct"},
+	{0x0312,	"property_accuracy"},
+	{0x0313,	"property_resolution"},
+	{0x0314,	"property_range_maximum"},
+	{0x0315,	"property_range_minimum"},
+	{0x0316,	"property_reporting_state"},
+	{0x0840,	"property_reporting_state_no_events_sel"},
+	{0x0841,	"property_reporting_state_all_events_sel"},
+	{0x0842,	"property_reporting_state_threshold_events_sel"},
+	{0x0843,	"property_reporting_state_no_events_wake_sel"},
+	{0x0844,	"property_reporting_state_all_events_wake_sel"},
+	{0x0845,	"property_reporting_state_threshold_events_wake_sel"},
+	{0x0317,	"property_sampling_rate"},
+	{0x0318,	"property_response_curve"},
+	{0x0319,	"property_power_state"},
+	{0x0850,	"property_power_state_undefined_sel"},
+	{0x0851,	"property_power_state_d0_full_power_sel"},
+	{0x0852,	"property_power_state_d1_low_power_sel"},
+	{0x0853,	"property_power_state_d2_standby_with_wake_sel"},
+	{0x0854,	"property_power_state_d3_sleep_with_wake_sel"},
+	{0x0855,	"property_power_state_d4_power_off_sel"},
+	{0x08E0,	"property_orientation_magnetometer_accuracy_low"},
+	{0x08E1,	"property_orientation_magnetometer_accuracy_medium"},
+	{0x08E2,	"property_orientation_magnetometer_accuracy_high"},
+	{0x0400,	"data_location"},
+	{0x0401,	"data_location_desired_accuracy"},
+	{0x0402,	"data_location_altitude_antenna_sealevel"},
+	{0x0403,	"data_location_differential_reference_station_id"},
+	{0x0404,	"data_location_altitide_elipsoid_error"},
+	{0x0405,	"data_location_altitide_elipsoid"},
+	{0x0406,	"data_location_altitude_sealevel_error"},
+	{0x0407,	"data_location_altitude_sealevel"},
+	{0x0408,	"data_location_dgps_data_age"},
+	{0x0409,	"data_location_error_radius"},
+	{0x040A,	"data_location_fix_quality"},
+	{0x0870,	"data_fix_quality_no_fix"},
+	{0x0871,	"data_fix_quality_gps"},
+	{0x0872,	"data_fix_quality_dgps"},
+	{0x040B,	"data_location_fix_type"},
+	{0x0880,	"data_fix_type_no_fix"},
+	{0x0881,	"data_fix_type_gps_sps_mode_fix_valid"},
+	{0x0882,	"data_fix_type_dgps_sps_mode_fix_valid"},
+	{0x0883,	"data_fix_type_gps_pps_mode_fix_valid"},
+	{0x0884,	"data_fix_type_real_time_kinematic"},
+	{0x0885,	"data_fix_type_float_rtk"},
+	{0x0886,	"data_fix_type_estimated_dead_reckoning"},
+	{0x0887,	"data_fix_type_manual_input_mode"},
+	{0x0888,	"data_fix_type_simulator_mode"},
+	{0x040C,	"data_location_geoidal_separation"},
+	{0x040D,	"data_location_gps_operation_mode"},
+	{0x0890,	"data_gps_op_mode_manual"},
+	{0x0891,	"data_gps_op_mode_automatic"},
+	{0x040E,	"data_location_gps_selection_mode"},
+	{0x08A0,	"data_gps_sel_mode_autonomous"},
+	{0x08A1,	"data_gps_sel_mode_dgps"},
+	{0x08A2,	"data_gps_sel_mode_estimated_dead_reckoning"},
+	{0x08A3,	"data_gps_sel_mode_manual_input"},
+	{0x08A4,	"data_gps_sel_mode_simulator"},
+	{0x08A5,	"data_gps_sel_mode_data_not_valid"},
+	{0x040F,	"data_location_gps_status"},
+	{0x08B0,	"data_gps_status_data_valid"},
+	{0x08B1,	"data_gps_status_data_not_valid"},
+	{0x0410,	"data_location_position_dilution_of_precision"},
+	{0x0411,	"data_location_horizontal_dilution_of_precision"},
+	{0x0412,	"data_location_vertical_dilution_of_precision"},
+	{0x0413,	"data_location_latitude"},
+	{0x0414,	"data_location_longitude"},
+	{0x0415,	"data_location_true_heading"},
+	{0x0416,	"data_location_magnetic_heading"},
+	{0x0417,	"data_location_magnetic_variation"},
+	{0x0418,	"data_location_speed"},
+	{0x0419,	"data_location_satellites_in_view"},
+	{0x041A,	"data_location_satellites_in_view_azimuth"},
+	{0x041B,	"data_location_satellites_in_view_elevation"},
+	{0x041C,	"data_location_satellites_in_view_id"},
+	{0x041D,	"data_location_satellites_in_view_prns"},
+	{0x041E,	"data_location_satellites_in_view_stn_ratio"},
+	{0x041F,	"data_location_satellites_used_count"},
+	{0x0420,	"data_location_satellites_used_prns"},
+	{0x0421,	"data_location_nmea_sentence"},
+	{0x0422,	"data_location_address_line_1"},
+	{0x0423,	"data_location_address_line_2"},
+	{0x0424,	"data_location_city"},
+	{0x0425,	"data_location_state_or_province"},
+	{0x0426,	"data_location_country_or_region"},
+	{0x0427,	"data_location_postal_code"},
+	{0x042A,	"property_location"},
+	{0x042B,	"property_location_desired_accuracy"},
+	{0x0860,	"desired_accuracy_default"},
+	{0x0861,	"desired_accuracy_high"},
+	{0x0862,	"desired_accuracy_medium"},
+	{0x0863,	"desired_accuracy_low"},
+	{0x0430,	"data_environmental"},
+	{0x0431,	"data_environmental_atmospheric_pressure"},
+	{0x0432,	"data_environmental_reference_pressure"},
+	{0x0433,	"data_environmental_relative_humidity"},
+	{0x0434,	"data_environmental_temperature"},
+	{0x0435,	"data_environmental_wind_direction"},
+	{0x0436,	"data_environmental_wind_speed"},
+	{0x0440,	"property_environmental"},
+	{0x0441,	"property_environmental_reference_pressure"},
+	{0x0450,	"data_motion"},
+	{0x0451,	"data_motion_state"},
+	{0x0452,	"data_motion_acceleration"},
+	{0x0453,	"data_motion_acceleration_x_axis"},
+	{0x0454,	"data_motion_acceleration_y_axis"},
+	{0x0455,	"data_motion_acceleration_z_axis"},
+	{0x0456,	"data_motion_angular_velocity"},
+	{0x0457,	"data_motion_angular_velocity_x_axis"},
+	{0x0458,	"data_motion_angular_velocity_y_axis"},
+	{0x0459,	"data_motion_angular_velocity_z_axis"},
+	{0x045A,	"data_motion_angular_position"},
+	{0x045B,	"data_motion_angular_position_x_axis"},
+	{0x045C,	"data_motion_angular_position_y_axis"},
+	{0x045D,	"data_motion_angular_position_z_axis"},
+	{0x045E,	"data_motion_speed"},
+	{0x045F,	"data_motion_intensity"},
+	{0x0470,	"data_orientation"},
+	{0x0471,	"data_orientation_magnetic_heading"},
+	{0x0472,	"data_orientation_magnetic_heading_x"},
+	{0x0473,	"data_orientation_magnetic_heading_y"},
+	{0x0474,	"data_orientation_magnetic_heading_z"},
+	{0x0475,	"data_orientation_compensated_magnetic_north"},
+	{0x0476,	"data_orientation_compensated_true_north"},
+	{0x0477,	"data_orientation_magnetic_north"},
+	{0x0478,	"data_orientation_true_north"},
+	{0x0479,	"data_orientation_distance"},
+	{0x047A,	"data_orientation_distance_x"},
+	{0x047B,	"data_orientation_distance_y"},
+	{0x047C,	"data_orientation_distance_z"},
+	{0x047D,	"data_orientation_distance_out_of_range"},
+	{0x047E,	"data_orientation_tilt"},
+	{0x047F,	"data_orientation_tilt_x"},
+	{0x0480,	"data_orientation_tilt_y"},
+	{0x0481,	"data_orientation_tilt_z"},
+	{0x0482,	"data_orientation_rotation_matrix"},
+	{0x0483,	"data_orientation_quaternion"},
+	{0x0484,	"data_orientation_magnetic_flux"},
+	{0x0485,	"data_orientation_magnetic_flux_x_axis"},
+	{0x0486,	"data_orientation_magnetic_flux_y_axis"},
+	{0x0487,	"data_orientation_magnetic_flux_z_axis"},
+	{0x0488,	"data_orientation_magnetometer_accuracy"},
+	{0x0490,	"data_mechanical"},
+	{0x0491,	"data_mechanical_boolean_switch_state"},
+	{0x0492,	"data_mechanical_boolean_switch_array_states"},
+	{0x0493,	"data_mechanical_multivalue_switch_value"},
+	{0x0494,	"data_mechanical_force"},
+	{0x0495,	"data_mechanical_absolute_pressure"},
+	{0x0496,	"data_mechanical_gauge_pressure"},
+	{0x0497,	"data_mechanical_strain"},
+	{0x0498,	"data_mechanical_weight"},
+	{0x04A0,	"property_mechanical"},
+	{0x04A1,	"property_mechanical_vibration_state"},
+	{0x04A2,	"data_mechanical_vibration_speed_forward"},
+	{0x04A3,	"data_mechanical_vibration_speed_backward"},
+	{0x04B0,	"data_biometric"},
+	{0x04B1,	"data_biometric_human_presence"},
+	{0x04B2,	"data_biometric_human_proximity_range"},
+	{0x04B3,	"data_biometric_human_proximity_out_of_range"},
+	{0x04B4,	"data_biometric_human_touch_state"},
+	{0x04D0,	"data_light"},
+	{0x04D1,	"data_light_illuminance"},
+	{0x04D2,	"data_light_color_temperature"},
+	{0x04D3,	"data_light_chromaticity"},
+	{0x04D4,	"data_light_chromaticity_x"},
+	{0x04D5,	"data_light_chromaticity_y"},
+	{0x04D6,	"data_light_consumer_ir_sentence_receive"},
+	{0x04E0,	"property_light"},
+	{0x04E1,	"property_light_consumer_ir_sentence_send"},
+	{0x04F0,	"data_scanner"},
+	{0x04F1,	"data_scanner_rfid_tag"},
+	{0x04F2,	"data_scanner_nfc_sentence_receive"},
+	{0x04F8,	"property_scanner"},
+	{0x04F9,	"property_scanner_nfc_sentence_send"},
+	{0x0500,	"data_electrical"},
+	{0x0501,	"data_electrical_capacitance"},
+	{0x0502,	"data_electrical_current"},
+	{0x0503,	"data_electrical_power"},
+	{0x0504,	"data_electrical_inductance"},
+	{0x0505,	"data_electrical_resistance"},
+	{0x0506,	"data_electrical_voltage"},
+	{0x0507,	"data_electrical_frequency"},
+	{0x0508,	"data_electrical_period"},
+	{0x0509,	"data_electrical_percent_of_range"},
+	{0x0520,	"data_time"},
+	{0x0521,	"data_time_year"},
+	{0x0522,	"data_time_month"},
+	{0x0523,	"data_time_day"},
+	{0x0524,	"data_time_day_of_week"},
+	{0x0525,	"data_time_hour"},
+	{0x0526,	"data_time_minute"},
+	{0x0527,	"data_time_second"},
+	{0x0528,	"data_time_millisecond"},
+	{0x0529,	"data_time_timestamp"},
+	{0x052A,	"data_time_julian_day_of_year"},
+	{0x0530,	"property_time"},
+	{0x0531,	"property_time_time_zone_offset_from_utc"},
+	{0x0532,	"property_time_time_zone_name"},
+	{0x0533,	"property_time_daylight_savings_time_observed"},
+	{0x0534,	"property_time_time_trim_adjustment"},
+	{0x0535,	"property_time_arm_alarm"},
+	{0x0540,	"data_custom"},
+	{0x0541,	"data_custom_usage"},
+	{0x0542,	"data_custom_boolean_array"},
+	{0x0543,	"data_custom_value"},
+	{0x0544,	"data_custom_value_1"},
+	{0x0545,	"data_custom_value_2"},
+	{0x0546,	"data_custom_value_3"},
+	{0x0547,	"data_custom_value_4"},
+	{0x0548,	"data_custom_value_5"},
+	{0x0549,	"data_custom_value_6"},
+	{0x054A,	"data_custom_value_7"},
+	{0x054B,	"data_custom_value_8"},
+	{0x054C,	"data_custom_value_9"},
+	{0x054D,	"data_custom_value_10"},
+	{0x054E,	"data_custom_value_11"},
+	{0x054F,	"data_custom_value_12"},
+	{0x0550,	"data_custom_value_13"},
+	{0x0551,	"data_custom_value_14"},
+	{0x0552,	"data_custom_value_15"},
+	{0x0553,	"data_custom_value_16"},
+	{0x0554,	"data_custom_value_17"},
+	{0x0555,	"data_custom_value_18"},
+	{0x0556,	"data_custom_value_19"},
+	{0x0557,	"data_custom_value_20"},
+	{0x0558,	"data_custom_value_21"},
+	{0x0559,	"data_custom_value_22"},
+	{0x055A,	"data_custom_value_23"},
+	{0x055B,	"data_custom_value_24"},
+	{0x055C,	"data_custom_value_25"},
+	{0x055D,	"data_custom_value_26"},
+	{0x055E,	"data_custom_value_27"},
+	{0x055F,	"data_custom_value_28"},
+	{0x0560,	"data_generic"},
+	{0x0561,	"data_generic_guid_or_propertykey"},
+	{0x0562,	"data_generic_category_guid"},
+	{0x0563,	"data_generic_type_guid"},
+	{0x0564,	"data_generic_event_propertykey"},
+	{0x0565,	"data_generic_property_propertykey"},
+	{0x0566,	"data_generic_datafield_propertykey"},
+	{0x0567,	"data_generic_event"},
+	{0x0568,	"data_generic_property"},
+	{0x0569,	"data_generic_datafield"},
+	{0x056A,	"data_enumerator_table_row_index"},
+	{0x056B,	"data_enumerator_table_row_count"},
+	{0x056C,	"data_generic_guid_or_propertykey_kind"},
+	{0x08D0,	"gorpk_kind_category"},
+	{0x08D1,	"gorpk_kind_type"},
+	{0x08D2,	"gorpk_kind_event"},
+	{0x08D3,	"gorpk_kind_property"},
+	{0x08D4,	"gorpk_kind_datafield"},
+	{0x056D,	"data_generic_guid"},
+	{0x056E,	"data_generic_propertykey"},
+	{0x056F,	"data_generic_top_level_collection_id"},
+	{0x0570,	"data_generic_report_id"},
+	{0x0571,	"data_generic_report_item_position_index"},
+	{0x0572,	"data_generic_firmware_vartype"},
+	{0x0900,	"firmware_vartype_vt_null"},
+	{0x0901,	"firmware_vartype_vt_bool"},
+	{0x0902,	"firmware_vartype_vt_ui1"},
+	{0x0903,	"firmware_vartype_vt_i1"},
+	{0x0904,	"firmware_vartype_vt_ui2"},
+	{0x0905,	"firmware_vartype_vt_i2"},
+	{0x0906,	"firmware_vartype_vt_ui4"},
+	{0x0907,	"firmware_vartype_vt_i4"},
+	{0x0908,	"firmware_vartype_vt_ui8"},
+	{0x0909,	"firmware_vartype_vt_i8"},
+	{0x090A,	"firmware_vartype_vt_r4"},
+	{0x090B,	"firmware_vartype_vt_r8"},
+	{0x090C,	"firmware_vartype_vt_wstr"},
+	{0x090D,	"firmware_vartype_vt_str"},
+	{0x090E,	"firmware_vartype_vt_clsid"},
+	{0x090F,	"firmware_vartype_vt_vector_vt_ui1"},
+	{0x0910,	"firmware_vartype_vt_f16e0"},
+	{0x0911,	"firmware_vartype_vt_f16e1"},
+	{0x0912,	"firmware_vartype_vt_f16e2"},
+	{0x0913,	"firmware_vartype_vt_f16e3"},
+	{0x0914,	"firmware_vartype_vt_f16e4"},
+	{0x0915,	"firmware_vartype_vt_f16e5"},
+	{0x0916,	"firmware_vartype_vt_f16e6"},
+	{0x0917,	"firmware_vartype_vt_f16e7"},
+	{0x0918,	"firmware_vartype_vt_f16e8"},
+	{0x0919,	"firmware_vartype_vt_f16e9"},
+	{0x091A,	"firmware_vartype_vt_f16ea"},
+	{0x091B,	"firmware_vartype_vt_f16eb"},
+	{0x091C,	"firmware_vartype_vt_f16ec"},
+	{0x091D,	"firmware_vartype_vt_f16ed"},
+	{0x091E,	"firmware_vartype_vt_f16ee"},
+	{0x091F,	"firmware_vartype_vt_f16ef"},
+	{0x0920,	"firmware_vartype_vt_f32e0"},
+	{0x0921,	"firmware_vartype_vt_f32e1"},
+	{0x0922,	"firmware_vartype_vt_f32e2"},
+	{0x0923,	"firmware_vartype_vt_f32e3"},
+	{0x0924,	"firmware_vartype_vt_f32e4"},
+	{0x0925,	"firmware_vartype_vt_f32e5"},
+	{0x0926,	"firmware_vartype_vt_f32e6"},
+	{0x0927,	"firmware_vartype_vt_f32e7"},
+	{0x0928,	"firmware_vartype_vt_f32e8"},
+	{0x0929,	"firmware_vartype_vt_f32e9"},
+	{0x092A,	"firmware_vartype_vt_f32ea"},
+	{0x092B,	"firmware_vartype_vt_f32eb"},
+	{0x092C,	"firmware_vartype_vt_f32ec"},
+	{0x092D,	"firmware_vartype_vt_f32ed"},
+	{0x092E,	"firmware_vartype_vt_f32ee"},
+	{0x092F,	"firmware_vartype_vt_f32ef"},
+	{0x0573,	"data_generic_unit_of_measure"},
+	{0x0940,	"generic_unit_not_specified"},
+	{0x0941,	"generic_unit_lux"},
+	{0x0942,	"generic_unit_degrees_kelvin"},
+	{0x0943,	"generic_unit_degrees_celsius"},
+	{0x0944,	"generic_unit_pascal"},
+	{0x0945,	"generic_unit_newton"},
+	{0x0946,	"generic_unit_meters_per_second"},
+	{0x0947,	"generic_unit_kilogram"},
+	{0x0948,	"generic_unit_meter"},
+	{0x0949,	"generic_unit_meters_per_sec_sqrd"},
+	{0x094A,	"generic_unit_farad"},
+	{0x094B,	"generic_unit_ampere"},
+	{0x094C,	"generic_unit_watt"},
+	{0x094D,	"generic_unit_henry"},
+	{0x094E,	"generic_unit_ohm"},
+	{0x094F,	"generic_unit_volt"},
+	{0x0950,	"generic_unit_hertz"},
+	{0x0951,	"generic_unit_bar"},
+	{0x0952,	"generic_unit_degrees_anti_clockwise"},
+	{0x0953,	"generic_unit_degrees_clockwise"},
+	{0x0954,	"generic_unit_degrees"},
+	{0x0955,	"generic_unit_degrees_per_second"},
+	{0x0956,	"generic_unit_degrees_per_sec_sqrd"},
+	{0x0957,	"generic_unit_knot"},
+	{0x0958,	"generic_unit_percent"},
+	{0x0959,	"generic_unit_second"},
+	{0x095A,	"generic_unit_millisecond"},
+	{0x095B,	"generic_unit_g"},
+	{0x095C,	"generic_unit_bytes"},
+	{0x095D,	"generic_unit_milligauss"},
+	{0x095E,	"generic_unit_bits"},
+	{0x0574,	"data_generic_unit_exponent"},
+	{0x0970,	"generic_exponent_0"},
+	{0x0971,	"generic_exponent_1"},
+	{0x0972,	"generic_exponent_2"},
+	{0x0973,	"generic_exponent_3"},
+	{0x0974,	"generic_exponent_4"},
+	{0x0975,	"generic_exponent_5"},
+	{0x0976,	"generic_exponent_6"},
+	{0x0977,	"generic_exponent_7"},
+	{0x0978,	"generic_exponent_8"},
+	{0x0979,	"generic_exponent_9"},
+	{0x097A,	"generic_exponent_a"},
+	{0x097B,	"generic_exponent_b"},
+	{0x097C,	"generic_exponent_c"},
+	{0x097D,	"generic_exponent_d"},
+	{0x097E,	"generic_exponent_e"},
+	{0x097F,	"generic_exponent_f"},
+	{0x0575,	"data_generic_report_size"},
+	{0x0576,	"data_generic_report_count"},
+	{0x0580,	"property_generic"},
+	{0x0581,	"property_enumerator_table_row_index"},
+	{0x0582,	"property_enumerator_table_row_count"},
+	{0,	0}
+};
+
+static const char *modifiers[16] = {"none", "chg_sensitivity_abs", "max", "min",
+	"accuracy", "resolution", "thres_high", "thres_low",
+	"calibration_offset", "calibration_multiplier", "report_interval",
+	"freq_max", "period_max", "chg_sensitivity_percent_range",
+	"chg_sensitivity_percent_rel", "custom"};
+
+
+#endif /* _HID_STRINGS_DEF_H_ */
+
diff --git a/drivers/misc/intel-ish/hw-ish-regs.h b/drivers/misc/intel-ish/hw-ish-regs.h
new file mode 100644
index 0000000..9d3db55
--- /dev/null
+++ b/drivers/misc/intel-ish/hw-ish-regs.h
@@ -0,0 +1,186 @@
+/*
+ * ISH registers definitions
+ *
+ * Copyright (c) 2012-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_ISH_REGS_H_
+#define _HECI_ISH_REGS_H_
+
+
+/* IPC PCI Offsets and sizes */
+#define IPC_REG_BASE             0x0000 /* Ish IPC Base Address */
+/*Peripheral Interrupt Status Register */
+#define IPC_REG_PISR             (IPC_REG_BASE + 0x00)
+/* Peripheral Interrupt Mask Register */
+#define IPC_REG_PIMR             (IPC_REG_BASE + 0x04)
+/* ISH Host Firmware status Register */
+#define IPC_REG_ISH_HOST_FWSTS   (IPC_REG_BASE + 0x34)
+/* Host Communication Register */
+#define IPC_REG_HOST_COMM        (IPC_REG_BASE + 0x38)
+/* Reset register */
+#define IPC_REG_ISH_RST          (IPC_REG_BASE + 0x44)
+
+/*Inbound doorbell register Host to ISH */
+#define IPC_REG_HOST2ISH_DRBL    (IPC_REG_BASE + 0x48)
+/*Outbound doorbell register ISH to Host */
+#define IPC_REG_ISH2HOST_DRBL    (IPC_REG_BASE + 0x54)
+/* ISH to HOST message registers */
+#define IPC_REG_ISH2HOST_MSG     (IPC_REG_BASE + 0x60)
+/* HOST to ISH message registers */
+#define IPC_REG_HOST2ISH_MSG     (IPC_REG_BASE + 0xE0)
+/* REMAP2 to enable DMA (D3 RCR) */
+#define	IPC_REG_ISH_RMP2	 (IPC_REG_BASE + 0x368)
+
+/* register bits - HISR */
+
+/* bit corresponds HOST2ISH interrupt in PISR and PIMR registers */
+#define IPC_INT_HOST2ISH_BIT            (1<<0)
+/* bit corresponds ISH2HOST interrupt in PISR and PIMR registers */
+#define IPC_INT_ISH2HOST_BIT            (1<<3)
+/* bit corresponds ISH2HOST busy clear interrupt in PIMR register */
+#define IPC_INT_ISH2HOST_CLR_MASK_BIT   (1<<11)
+
+/* offset of ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
+#define IPC_INT_ISH2HOST_CLR_OFFS       (0)
+
+/* bit corresponds ISH2HOST busy clear interrupt in IPC_BUSY_CLR register */
+#define IPC_INT_ISH2HOST_CLR_BIT        (1<<IPC_INT_ISH2HOST_CLR_OFFS)
+
+/* bit corresponds busy bit in doorbell registers */
+#define IPC_DRBL_BUSY_OFFS              (31)
+#define IPC_DRBL_BUSY_BIT               (1<<IPC_DRBL_BUSY_OFFS)
+
+#define	IPC_HOST_OWNS_MSG_OFFS		(30)
+
+/* A0: bit means that host owns MSGnn registers and is reading them.
+ISS FW may not write to them */
+#define	IPC_HOST_OWNS_MSG_BIT		(1<<IPC_HOST_OWNS_MSG_OFFS)
+
+/*
+ * Host status bits (HOSTCOMM)
+ */
+/* bit corresponds host ready bit in Host Status Register (HOST_COMM) */
+#define IPC_HOSTCOMM_READY_OFFS		(7)
+#define IPC_HOSTCOMM_READY_BIT		(1<<IPC_HOSTCOMM_READY_OFFS)
+
+#define	IPC_HOSTCOMM_INT_EN_OFFS	(31)
+#define	IPC_HOSTCOMM_INT_EN_BIT		(1<<IPC_HOSTCOMM_INT_EN_OFFS)
+
+/*
+ * as of now, both Host and ISS have ILUP at bit 0
+ * bit corresponds host ready bit in both status registers
+ */
+#define IPC_ILUP_OFFS			(0)
+#define IPC_ILUP_BIT			(1<<IPC_ILUP_OFFS)
+
+/*
+ * FW status bits (relevant)
+ */ 
+#define	IPC_FWSTS_ILUP		0x1
+#define	IPC_FWSTS_HECI_UP	(1<<1)
+#define	IPC_FWSTS_DMA0		(1<<16)
+#define	IPC_FWSTS_DMA1		(1<<17)
+#define	IPC_FWSTS_DMA2		(1<<18)
+#define	IPC_FWSTS_DMA3		(1<<19)
+
+#define	IPC_ISH_IN_DMA		\
+	(IPC_FWSTS_DMA0 | IPC_FWSTS_DMA1 | IPC_FWSTS_DMA2 | IPC_FWSTS_DMA3)
+
+/* bit corresponds host ready bit in ISS FW Status Register */
+#define IPC_ISH_HECI_READY_OFFS              (1)
+#define IPC_ISH_HECI_READY_BIT               (1<<IPC_ISH_HECI_READY_OFFS)
+
+#define	IPC_RMP2_DMA_ENABLED	0x1	/* Value to enable DMA, per D3 RCR */
+
+#define IPC_MSG_MAX_SIZE	0x80
+
+
+#define IPC_HEADER_LENGTH_MASK          (0x03FF)
+#define IPC_HEADER_PROTOCOL_MASK        (0x0F)
+#define IPC_HEADER_MNG_CMD_MASK         (0x0F)
+
+#define IPC_HEADER_LENGTH_OFFSET         0
+#define IPC_HEADER_PROTOCOL_OFFSET      10
+#define IPC_HEADER_MNG_CMD_OFFSET       16
+
+#define IPC_HEADER_GET_LENGTH(drbl_reg)		\
+	(((drbl_reg) >> IPC_HEADER_LENGTH_OFFSET)&IPC_HEADER_LENGTH_MASK)
+#define IPC_HEADER_GET_PROTOCOL(drbl_reg)	\
+	(((drbl_reg) >> IPC_HEADER_PROTOCOL_OFFSET)&IPC_HEADER_PROTOCOL_MASK)
+#define IPC_HEADER_GET_MNG_CMD(drbl_reg)	\
+	(((drbl_reg) >> IPC_HEADER_MNG_CMD_OFFSET)&IPC_HEADER_MNG_CMD_MASK)
+
+#define IPC_IS_BUSY(drbl_reg)			\
+	(((drbl_reg)&IPC_DRBL_BUSY_BIT) == ((u32)IPC_DRBL_BUSY_BIT))
+
+#define IPC_SET_BUSY(drbl_reg)		((drbl_reg) | (IPC_DRBL_BUSY_BIT))
+
+#define IPC_INT_FROM_ISH_TO_HOST(drbl_reg)	\
+	(((drbl_reg)&IPC_INT_ISH2HOST_BIT) == ((u32)IPC_INT_ISH2HOST_BIT))
+
+#define IPC_BUILD_HEADER(length, protocol, busy)		\
+	(((busy)<<IPC_DRBL_BUSY_OFFS) |				\
+	((protocol) << IPC_HEADER_PROTOCOL_OFFSET) |		\
+	((length)<<IPC_HEADER_LENGTH_OFFSET))
+
+#define IPC_BUILD_MNG_MSG(cmd, length)				\
+	(((1)<<IPC_DRBL_BUSY_OFFS)|				\
+	((IPC_PROTOCOL_MNG)<<IPC_HEADER_PROTOCOL_OFFSET)|	\
+	((cmd)<<IPC_HEADER_MNG_CMD_OFFSET)|((length)<<IPC_HEADER_LENGTH_OFFSET))
+
+
+#define IPC_SET_HOST_READY(host_status)		\
+				((host_status) |= (IPC_HOSTCOMM_READY_BIT))
+
+#define IPC_SET_HOST_ILUP(host_status)		\
+				((host_status) |= (IPC_ILUP_BIT))
+
+#define IPC_CLEAR_HOST_READY(host_status)	\
+				((host_status) ^= (IPC_HOSTCOMM_READY_BIT))
+
+#define IPC_CLEAR_HOST_ILUP(host_status)	\
+				((host_status) ^= (IPC_ILUP_BIT))
+
+/* todo - temp until PIMR HW ready */
+#define IPC_HOST_BUSY_READING_OFFS				(6)
+
+/* bit corresponds host ready bit in Host Status Register (HOST_COMM) */
+#define IPC_HOST_BUSY_READING_BIT	(1<<IPC_HOST_BUSY_READING_OFFS)
+
+#define IPC_SET_HOST_BUSY_READING(host_status)	\
+				((host_status) |= (IPC_HOST_BUSY_READING_BIT))
+
+#define IPC_CLEAR_HOST_BUSY_READING(host_status)\
+				((host_status) ^= (IPC_HOST_BUSY_READING_BIT))
+
+
+#define IPC_IS_ISH_HECI_READY(ish_status)       \
+		(((ish_status)&IPC_ISH_HECI_READY_BIT) == ((u32)IPC_ISH_HECI_READY_BIT))
+
+#define IPC_IS_ISH_ILUP(ish_status)		\
+			(((ish_status)&IPC_ILUP_BIT) == ((u32)IPC_ILUP_BIT))
+
+
+#define IPC_PROTOCOL_HECI               1
+#define IPC_PROTOCOL_MNG                3
+
+#define MNG_RX_CMPL_ENABLE              0
+#define MNG_RX_CMPL_DISABLE             1
+#define MNG_RX_CMPL_INDICATION          2
+#define MNG_RESET_NOTIFY		3
+#define MNG_RESET_NOTIFY_ACK		4
+#define MNG_SYNC_FW_CLOCK		5
+#define MNG_ILLEGAL_CMD			0xFF
+
+#endif /* _HECI_ISH_REGS_H_ */
+
diff --git a/drivers/misc/intel-ish/hw-ish.c b/drivers/misc/intel-ish/hw-ish.c
new file mode 100644
index 0000000..caa7539
--- /dev/null
+++ b/drivers/misc/intel-ish/hw-ish.c
@@ -0,0 +1,981 @@
+/*
+ * H/W layer of HECI provider device (ISS)
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include "client.h"
+#include "hw-ish.h"
+#include "utils.h"
+#include "heci_dev.h"
+#include "hbm.h"
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static void no_dev_dbg(void *v, char *s, ...)
+{
+}
+/*#define dev_dbg dev_err*/
+#define dev_dbg no_dev_dbg
+
+#include <linux/delay.h>
+
+/**
+ * ish_reg_read - reads 32bit register
+ *
+ * @dev: the device structure
+ * @offset: offset from which to read the data
+ */
+static inline u32 ish_reg_read(const struct heci_device *dev,
+	unsigned long offset)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+	return readl(hw->mem_addr + offset);
+}
+
+/**
+ * ish_reg_write - Writes 32bit register
+ *
+ * @dev: the device structure
+ * @offset: offset from which to write the data
+ * @value: the byte to write
+ */
+static inline void ish_reg_write(struct heci_device *dev, unsigned long offset,
+	u32 value)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+	writel(value, hw->mem_addr + offset);
+}
+
+static inline u32 ish_read_fw_sts_reg(struct heci_device *dev)
+{
+	return ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
+}
+
+bool check_generated_interrupt(struct heci_device *dev)
+{
+	bool interrupt_generated = true;
+	u32 pisr_val = 0;
+
+	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
+	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
+
+	return interrupt_generated;
+}
+
+
+u32 ipc_output_payload_read(struct heci_device *dev, unsigned long index)
+{
+	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG +	(index * sizeof(u32)));
+}
+
+/**
+ * ish_read - reads a message from heci device.
+ *
+ * @dev: the device structure
+ * @buffer: message buffer will be written
+ * @buffer_length: message size will be read
+ */
+static int ish_read(struct heci_device *dev, unsigned char *buffer,
+	unsigned long buffer_length)
+{
+	u32	i;
+	u32	*r_buf = (u32 *)buffer;
+	u32	msg_offs;
+
+	dev_dbg(&dev->pdev->dev, "buffer-length = %lu buf[0]0x%08X\n",
+		buffer_length, ipc_output_payload_read(dev, 0));
+
+	msg_offs = IPC_REG_ISH2HOST_MSG + sizeof(struct heci_msg_hdr);
+	for (i = 0; i < buffer_length; i += sizeof(u32))
+		*r_buf++ = ish_reg_read(dev, msg_offs + i);
+
+	return 0;
+}
+
+/**
+ * ish_is_input_ready - check if ISS FW is ready for receiving data
+ *
+ * @dev: the device structure
+ */
+static bool ish_is_input_ready(struct heci_device *dev)
+{
+	u32 doorbell_val;
+
+	doorbell_val = ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL);
+	return !IPC_IS_BUSY(doorbell_val);
+}
+
+/**
+ * ish_intr_enable - enables heci device interrupts
+ *
+ * @dev: the device structure
+ */
+void ish_intr_enable(struct heci_device *dev)
+{
+/*	u32 host_status = 0; */
+
+	dev_dbg(&dev->pdev->dev, "ish_intr_enable\n");
+	if (dev->pdev->revision == REVISION_ID_CHT_A0 ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_A0_SI)
+		ish_reg_write(dev, IPC_REG_HOST_COMM, 0x81);
+	else if (dev->pdev->revision == REVISION_ID_CHT_B0 ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Bx_SI ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Kx_SI ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Dx_SI) {
+		uint32_t	host_comm_val;
+
+		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
+		host_comm_val |= IPC_HOSTCOMM_INT_EN_BIT | 0x81;
+		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
+	}
+}
+
+/**
+ * ish_intr_disable - disables heci device interrupts
+ *
+ * @dev: the device structure
+ */
+void ish_intr_disable(struct heci_device *dev)
+{
+	dev_dbg(&dev->pdev->dev, "ish_intr_disable\n");
+	if (dev->pdev->revision == REVISION_ID_CHT_A0 ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_A0_SI)
+		/*ish_reg_write(dev, IPC_REG_HOST_COMM, 0xC1)*/;
+	else if (dev->pdev->revision == REVISION_ID_CHT_B0 ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Bx_SI ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Kx_SI ||
+			(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Dx_SI) {
+		uint32_t	host_comm_val;
+
+		host_comm_val = ish_reg_read(dev, IPC_REG_HOST_COMM);
+		host_comm_val &= ~IPC_HOSTCOMM_INT_EN_BIT;
+		host_comm_val |= 0xC1;
+		ish_reg_write(dev, IPC_REG_HOST_COMM, host_comm_val);
+	}
+}
+
+/*
+ * BH processing work function (instead of thread handler)
+ */
+static void	bh_hbm_work_fn(struct work_struct *work)
+{
+	unsigned long	flags;
+	struct heci_device	*dev;
+	unsigned char	hbm[IPC_PAYLOAD_SIZE];
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): work=%p +++\n", __func__, work);
+	dev = container_of(work, struct heci_device, bh_hbm_work);
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	if (dev->rd_msg_fifo_head != dev->rd_msg_fifo_tail) {
+		memcpy(hbm, dev->rd_msg_fifo + dev->rd_msg_fifo_head,
+			IPC_PAYLOAD_SIZE);
+		dev->rd_msg_fifo_head =
+			(dev->rd_msg_fifo_head + IPC_PAYLOAD_SIZE) %
+			(RD_INT_FIFO_SIZE * IPC_PAYLOAD_SIZE);
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+		heci_hbm_dispatch(dev, (struct heci_bus_message *)hbm);
+	} else {
+		spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+}
+/*#####################################################*/
+
+/*
+ * Got msg with IPC (and upper protocol) header
+ * and add it to the device Tx-to-write list
+ * then try to send the first IPC waiting msg (if DRBL is cleared)
+ * RETURN VALUE:	negative -	fail (means free links list is empty,
+ *					or msg too long)
+ *			0 -	succeed
+ */
+static int write_ipc_to_queue(struct heci_device *dev,
+	void (*ipc_send_compl)(void *), void *ipc_send_compl_prm,
+	unsigned char *msg, int length)
+{
+	struct wr_msg_ctl_info *ipc_link;
+	unsigned long   flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++ length=%u\n", __func__, length);
+	if (length > IPC_FULL_MSG_SIZE)
+		return -EMSGSIZE;
+
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	if (list_empty(&dev->wr_free_list_head.link)) {
+		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+		return -ENOMEM;
+	}
+	ipc_link = list_entry(dev->wr_free_list_head.link.next,
+		struct wr_msg_ctl_info, link);
+	list_del_init(&ipc_link->link);
+
+	ipc_link->ipc_send_compl = ipc_send_compl;
+	ipc_link->ipc_send_compl_prm = ipc_send_compl_prm;
+	ipc_link->length = length;
+	memcpy(ipc_link->inline_data, msg, length);
+
+	list_add_tail(&ipc_link->link, &dev->wr_processing_list_head.link);
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	write_ipc_from_queue(dev);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
+	return 0;
+}
+
+/* check if DRBL is cleared. if it is - write the first IPC msg,
+ * then call the callback function (if it isn't NULL)
+ */
+int write_ipc_from_queue(struct heci_device *dev)
+{
+	u32	doorbell_val;
+	unsigned long length;
+	unsigned long rem;
+	u32	*r_buf;
+	int i;
+	struct wr_msg_ctl_info	*ipc_link;
+	u32	reg_addr;
+	unsigned long	flags;
+	void	(*ipc_send_compl)(void *);
+	void	*ipc_send_compl_prm;
+	static int	out_ipc_locked;
+	unsigned long	out_ipc_flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+
+	if (dev->dev_state == HECI_DEV_DISABLED)
+		return	-EINVAL;
+
+	spin_lock_irqsave(&dev->out_ipc_spinlock, out_ipc_flags);
+	if (out_ipc_locked) {
+		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
+		return -EBUSY;
+	}
+	out_ipc_locked = 1;
+	if (!ish_is_input_ready(dev)) {
+		ISH_DBG_PRINT(KERN_ALERT "%s(): --- EBUSY\n", __func__);
+		out_ipc_locked = 0;
+		spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
+		return -EBUSY;
+	}
+	spin_unlock_irqrestore(&dev->out_ipc_spinlock, out_ipc_flags);
+
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	/*
+	 * if empty list - return 0; may happen, as RX_COMPLETE handler doesn't
+	 * check list emptiness
+	 */
+	if (list_empty(&dev->wr_processing_list_head.link)) {
+		spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+		ISH_DBG_PRINT(KERN_ALERT "%s(): --- empty\n", __func__);
+		out_ipc_locked = 0;
+		return	0;
+	}
+
+	ipc_link = list_entry(dev->wr_processing_list_head.link.next,
+		struct wr_msg_ctl_info, link);
+	length = ipc_link->length - sizeof(u32);
+	/*first 4 bytes of the data is the doorbell value (IPC header)*/
+	doorbell_val = *(u32 *)ipc_link->inline_data;
+	r_buf = (u32 *)(ipc_link->inline_data + sizeof(u32));
+
+	/* If sending MNG_SYNC_FW_CLOCK, update clock again */
+	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG &&
+		IPC_HEADER_GET_MNG_CMD(doorbell_val) == MNG_SYNC_FW_CLOCK) {
+
+		struct timespec	ts;
+		uint64_t	usec;
+
+		get_monotonic_boottime(&ts);
+		usec = (uint64_t)ts.tv_sec * 1000000 +
+			(uint64_t)ts.tv_nsec / 1000;
+		r_buf[0] = (u32)(usec & 0xFFFFFFFF);
+		r_buf[1] = (u32)(usec >> 32);
+	}
+
+	for (i = 0, reg_addr = IPC_REG_HOST2ISH_MSG; i < length >> 2; i++,
+			reg_addr += 4)
+		ish_reg_write(dev, reg_addr, r_buf[i]);
+
+	rem = length & 0x3;
+	if (rem > 0) {
+		u32 reg = 0;
+		memcpy(&reg, &r_buf[length >> 2], rem);
+		ish_reg_write(dev, reg_addr, reg);
+	}
+
+	/* HID client debug */
+	if (doorbell_val == 0x8000040C &&
+		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG) == 0x80080000 &&
+		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG+4) == 0x00030508) {
+			++dev->ipc_hid_out_fc;
+			++dev->ipc_hid_out_fc_cnt;
+		}
+	else if ((doorbell_val & 0xFFFFFC00) == 0x80000400 &&
+		(ish_reg_read(dev, IPC_REG_HOST2ISH_MSG) & 0x8000FFFF) ==
+				0x80000305)
+			--dev->ipc_hid_in_fc;
+
+	/* Update IPC counters */
+	++dev->ipc_tx_cnt;
+	dev->ipc_tx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
+
+	ish_reg_write(dev, IPC_REG_HOST2ISH_DRBL, doorbell_val);
+	out_ipc_locked = 0;
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): in msg. registers: %08X ! %08X %08X %08X %08X... hostcomm reg: %08X\n",
+		__func__, ish_reg_read(dev, IPC_REG_HOST2ISH_DRBL),
+		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG),
+		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 4),
+		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 8),
+		ish_reg_read(dev, IPC_REG_HOST2ISH_MSG + 0xC),
+		ish_reg_read(dev, IPC_REG_HOST_COMM));
+
+	ipc_send_compl = ipc_link->ipc_send_compl;
+	ipc_send_compl_prm = ipc_link->ipc_send_compl_prm;
+	list_del_init(&ipc_link->link);
+	list_add_tail(&ipc_link->link, &dev->wr_free_list_head.link);
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	/*
+	 * callback will be called out of spinlock,
+	 * after ipc_link returned to free list
+	 */
+	if (ipc_send_compl)
+		ipc_send_compl(ipc_send_compl_prm);
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): --- written %lu bytes [%08X ! %08X %08X %08X %08X...]\n",
+		__func__, length, *(u32 *)ipc_link->inline_data, r_buf[0],
+		r_buf[1], r_buf[2], r_buf[3]);
+	return 0;
+}
+
+/*#####################################################*/
+
+static int	ish_fw_reset_handler(struct heci_device *dev)
+{
+	uint32_t	reset_id;
+	unsigned long	flags;
+	struct wr_msg_ctl_info *processing, *next;
+	/* Read reset ID */
+	reset_id = ish_reg_read(dev, IPC_REG_ISH2HOST_MSG) & 0xFFFF;
+
+	/* Handle FW-initiated reset */
+	dev->dev_state = HECI_DEV_RESETTING;
+
+	/* Clear HOST2ISH.ILUP (what's it?) */
+	/*ish_clr_host_rdy(dev);*/
+
+	/* Clear IPC output queue */
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	list_for_each_entry_safe(processing, next,
+			&dev->wr_processing_list_head.link, link) {
+		list_del(&processing->link);
+		list_add_tail(&processing->link, &dev->wr_free_list_head.link);
+	}
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	/* Clear BH processing queue - no further HBMs */
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	dev->rd_msg_fifo_head = dev->rd_msg_fifo_tail = 0;
+	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+
+	/* Handle ISS FW reset against upper layers */
+	heci_bus_remove_all_clients(dev);	/* Remove all client devices */
+
+	/* Send RESET_NOTIFY_ACK (with reset_id) */
+/*#####################################*/
+	if (!ish_is_input_ready(dev))
+		timed_wait_for_timeout(WAIT_FOR_SEND_SLICE,
+			ish_is_input_ready(dev), (2 * HZ));
+
+	/* ISS FW is dead (?) */
+	if (!ish_is_input_ready(dev)) {
+		return	-EPIPE;
+	} else {
+		/*
+		 * Set HOST2ISH.ILUP. Apparently we need this BEFORE sending
+		 * RESET_NOTIFY_ACK - FW will be checking for it
+		 */
+		ish_set_host_rdy(dev);
+		ipc_send_mng_msg(dev, MNG_RESET_NOTIFY_ACK, &reset_id,
+			sizeof(uint32_t));
+	}
+/*####################################*/
+
+	/* Wait for ISS FW'es ILUP and HECI_READY */
+	timed_wait_for_timeout(WAIT_FOR_SEND_SLICE, ish_hw_is_ready(dev),
+		(2 * HZ));
+	if (!ish_hw_is_ready(dev)) {
+		/* ISS FW is dead */
+		uint32_t	ish_status;
+		ish_status = ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
+		dev_err(&dev->pdev->dev,
+		"[heci-ish]: completed reset, ISS is dead (FWSTS = %08X)\n",
+		ish_status);
+		return -ENODEV;
+	}
+
+	return	0;
+}
+
+struct work_struct	fw_reset_work;
+struct heci_device	*heci_dev;
+
+static void	fw_reset_work_fn(struct work_struct *unused)
+{
+	int	rv;
+	static int reset_cnt;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	reset_cnt++;
+
+	rv = ish_fw_reset_handler(heci_dev);
+	if (!rv) {
+		/* ISS is ILUP & HECI-ready. Restart HECI */
+	/* bug fix here: when reset flow occurs, sometimes, the sysfs entries
+		which were removed in ish_fw_reset_handler were still up,
+		but the driver tried to create the same entries and failed.
+		so wait some time here and then the sysfs entries removal will
+		be done */
+		if (reset_cnt != 0) /* not the boot flow */
+			schedule_timeout(HZ / 3);
+		heci_dev->recvd_hw_ready = 1;
+		if (waitqueue_active(&heci_dev->wait_hw_ready))
+			wake_up(&heci_dev->wait_hw_ready);
+
+		heci_dev->dev_state = HECI_DEV_INIT_CLIENTS;
+		heci_dev->hbm_state = HECI_HBM_START;
+		heci_hbm_start_req(heci_dev);
+		ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n",
+			__func__);
+
+	} else
+		printk(KERN_ERR "[heci-ish]: FW reset failed (%d)\n", rv);
+}
+
+
+static void	sync_fw_clock(struct heci_device *dev)
+{
+	static unsigned long	prev_sync;
+	struct timespec	ts;
+	uint64_t	usec;
+
+	if (prev_sync && jiffies - prev_sync < 20 * HZ)
+		return;
+
+	prev_sync = jiffies;
+	get_monotonic_boottime(&ts);
+	usec = (uint64_t)ts.tv_sec * 1000000 + (uint64_t)ts.tv_nsec / 1000;
+	ipc_send_mng_msg(dev, MNG_SYNC_FW_CLOCK, &usec, sizeof(uint64_t));
+}
+
+
+/*
+ *	Receive and process IPC management messages
+ *
+ *	NOTE: Any other mng command than reset_notify and reset_notify_ack
+ *	won't wake BH handler
+ */
+static void	recv_ipc(struct heci_device *dev, uint32_t doorbell_val)
+{
+	uint32_t	mng_cmd;
+
+	mng_cmd = IPC_HEADER_GET_MNG_CMD(doorbell_val);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): handled IPC mng_cmd=%08X\n", __func__,
+		mng_cmd);
+
+	switch (mng_cmd) {
+	default:
+		break;
+
+	case MNG_RX_CMPL_INDICATION:
+		ISH_DBG_PRINT(KERN_ALERT
+			"%s(): RX_COMPLETE -- IPC_REG_ISH2HOST_MSG[0] = %08X\n",
+			__func__, ish_reg_read(dev, IPC_REG_ISH2HOST_MSG));
+		if (suspend_flag) {
+			suspend_flag = 0;
+			if (waitqueue_active(&suspend_wait))
+				wake_up(&suspend_wait);
+		}
+		write_ipc_from_queue(dev);
+		break;
+
+	case MNG_RESET_NOTIFY:
+		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY\n", __func__);
+		if (!heci_dev) {
+			heci_dev = dev;
+			INIT_WORK(&fw_reset_work, fw_reset_work_fn);
+		}
+		schedule_work(&fw_reset_work);
+		break;
+
+	case MNG_RESET_NOTIFY_ACK:
+		ISH_DBG_PRINT(KERN_ALERT "%s(): MNG_RESET_NOTIFY_ACK\n",
+			__func__);
+		dev->recvd_hw_ready = 1;
+		if (waitqueue_active(&dev->wait_hw_ready))
+			wake_up(&dev->wait_hw_ready);
+		break;
+	}
+}
+
+
+/**
+ * ish_irq_handler - ISR of the HECI device
+ *
+ * @irq: irq number
+ * @dev_id: pointer to the device structure
+ *
+ * returns irqreturn_t
+ */
+irqreturn_t ish_irq_handler(int irq, void *dev_id)
+{
+	struct heci_device *dev = dev_id;
+	uint32_t	doorbell_val;
+	struct heci_msg_hdr	*heci_hdr;
+	bool interrupt_generated;
+	u32 pisr_val;
+	u32	msg_hdr;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): irq=%d +++\n", __func__, irq);
+
+	/* Check that it's interrupt from ISH (may be shared) */
+	pisr_val = ish_reg_read(dev, IPC_REG_PISR);
+	interrupt_generated = IPC_INT_FROM_ISH_TO_HOST(pisr_val);
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): interrupt_generated=%d [PIMR=%08X]\n",
+		__func__, (int)interrupt_generated,
+		ish_reg_read(dev, IPC_REG_PIMR));
+	if (!interrupt_generated)
+		return IRQ_NONE;
+
+	doorbell_val = ish_reg_read(dev, IPC_REG_ISH2HOST_DRBL);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): IPC_IS_BUSY=%d\n", __func__,
+		(int)IPC_IS_BUSY(doorbell_val));
+	if (!IPC_IS_BUSY(doorbell_val))
+		return IRQ_HANDLED;
+
+	ISH_DBG_PRINT("%s(): doorbell is busy - YES\n", __func__);
+
+	/* CHECKME: double check this */
+	if (dev->dev_state == HECI_DEV_DISABLED)
+		return	IRQ_HANDLED;
+
+	ish_intr_disable(dev);
+
+	/* Sanity check: IPC dgram length in header */
+	if (IPC_HEADER_GET_LENGTH(doorbell_val) > IPC_PAYLOAD_SIZE) {
+		dev_err(&dev->pdev->dev,
+			"%s(): IPC hdr - bad length: %u; dropped\n",
+			__func__,
+			(unsigned)IPC_HEADER_GET_LENGTH(doorbell_val));
+		goto	eoi;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): protocol=%u\n", __func__,
+		IPC_HEADER_GET_PROTOCOL(doorbell_val));
+
+	/* IPC message */
+	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG) {
+		recv_ipc(dev, doorbell_val);
+		goto	eoi;
+	}
+
+	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) != IPC_PROTOCOL_HECI)
+		goto	eoi;
+
+	/* Read HECI header dword */
+	msg_hdr = ish_read_hdr(dev);
+	if (!msg_hdr)
+		goto	eoi;
+
+	sync_fw_clock(dev);
+
+	heci_hdr = (struct heci_msg_hdr *)&msg_hdr;
+
+	/* Sanity check: HECI frag. length in header */
+	if (heci_hdr->length > dev->mtu) {
+		dev_err(&dev->pdev->dev,
+			"%s(): HECI hdr - bad length: %u; dropped [%08X]\n",
+			__func__,
+			(unsigned)heci_hdr->length, msg_hdr);
+		goto	eoi;
+	}
+
+	/* HECI bus message */
+	if (!heci_hdr->host_addr && !heci_hdr->me_addr) {
+		recv_hbm(dev, heci_hdr);
+		goto	eoi;
+
+	/* HECI fixed-client message */
+	} else if (!heci_hdr->host_addr) {
+		recv_fixed_cl_msg(dev, heci_hdr);
+		goto	eoi;
+	} else {
+		/* HECI client message */
+		recv_heci_cl_msg(dev, heci_hdr);
+		goto	eoi;
+	}
+
+eoi:
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): Doorbell cleared, busy reading cleared\n", __func__);
+	/* Update IPC counters */
+	++dev->ipc_rx_cnt;
+	dev->ipc_rx_bytes_cnt += IPC_HEADER_GET_LENGTH(doorbell_val);
+
+	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
+	/*
+	 * Here and above: we need to actually read this register
+	 * in order to unblock further interrupts on CHT A0
+	 */
+	ish_intr_enable(dev);
+	return	IRQ_HANDLED;
+}
+
+
+static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code,
+	void *msg, size_t size)
+{
+	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
+	uint32_t	drbl_val = IPC_BUILD_MNG_MSG(msg_code, size);
+
+	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
+	memcpy(ipc_msg + sizeof(uint32_t), msg, size);
+	return	write_ipc_to_queue(dev, NULL, NULL, ipc_msg,
+		sizeof(uint32_t) + size);
+}
+
+
+static int	ipc_send_heci_msg(struct heci_device *dev,
+	struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
+	void *ipc_send_compl_prm)
+{
+	unsigned char	ipc_msg[IPC_FULL_MSG_SIZE];
+	uint32_t	drbl_val;
+
+	drbl_val = IPC_BUILD_HEADER(hdr->length + sizeof(struct heci_msg_hdr),
+		IPC_PROTOCOL_HECI, 1);
+
+	memcpy(ipc_msg, &drbl_val, sizeof(uint32_t));
+	memcpy(ipc_msg + sizeof(uint32_t), hdr, sizeof(uint32_t));
+	memcpy(ipc_msg + 2 * sizeof(uint32_t), msg, hdr->length);
+	return	write_ipc_to_queue(dev, ipc_send_compl, ipc_send_compl_prm,
+		ipc_msg, 2 * sizeof(uint32_t) + hdr->length);
+}
+
+
+/**
+ * ish_hw_is_ready - check if the hw is ready
+ *
+ * @dev: the device structure
+ */
+bool ish_hw_is_ready(struct heci_device *dev)
+{
+	u32 ish_status =  ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS);
+	return IPC_IS_ISH_ILUP(ish_status) && IPC_IS_ISH_HECI_READY(ish_status);
+}
+
+/**
+ * ish_host_is_ready - check if the host is ready
+ *
+ * @dev: the device structure
+ */
+bool ish_host_is_ready(struct heci_device *dev)
+{
+	return true;
+}
+
+void ish_set_host_rdy(struct heci_device *dev)
+{
+	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n",
+		host_status);
+	IPC_SET_HOST_READY(host_status);
+	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
+	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n",
+		host_status);
+}
+
+void ish_clr_host_rdy(struct heci_device *dev)
+{
+	u32  host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "before HOST start host_status=%08X\n",
+		host_status);
+	IPC_CLEAR_HOST_READY(host_status);
+	ish_reg_write(dev, IPC_REG_HOST_COMM, host_status);
+	host_status = ish_reg_read(dev, IPC_REG_HOST_COMM);
+	dev_dbg(&dev->pdev->dev, "actually sent HOST start host_status=%08X\n",
+		host_status);
+}
+
+
+static int ish_hw_reset(struct heci_device *dev)
+{
+	struct pci_dev *pdev = dev->pdev;
+	struct ish_hw *hw = to_ish_hw(dev);
+	int	rv;
+	u16 csr;
+
+#define	MAX_DMA_DELAY	20
+	unsigned	dma_delay;
+
+	if (!pdev)
+		return	-ENODEV;
+
+	rv = pci_reset_function(pdev);
+	if (!rv)
+		dev->dev_state = HECI_DEV_RESETTING;
+
+	if (!pdev->pm_cap) {
+		dev_err(&pdev->dev, "Can't reset - no PM caps\n");
+		return	-EINVAL;
+	}
+
+	/* Now trigger reset to FW */
+	writel(0, hw->mem_addr + IPC_REG_ISH_RMP2);
+
+	for (dma_delay = 0; dma_delay < MAX_DMA_DELAY &&
+		ish_reg_read(dev, IPC_REG_ISH_HOST_FWSTS) & (IPC_ISH_IN_DMA);
+		dma_delay += 5);
+			mdelay(5);
+
+	if (dma_delay >= MAX_DMA_DELAY) {
+		dev_err(&pdev->dev,
+			"Can't reset - stuck with DMA in-progress\n");
+		return	-EBUSY;
+	}
+
+	pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &csr);
+
+	csr &= ~PCI_PM_CTRL_STATE_MASK;
+	csr |= PCI_D3hot;
+	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
+
+	mdelay(pdev->d3_delay);
+
+	csr &= ~PCI_PM_CTRL_STATE_MASK;
+	csr |= PCI_D0;
+	pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, csr);
+
+	writel(IPC_RMP2_DMA_ENABLED, hw->mem_addr + IPC_REG_ISH_RMP2);
+
+	/* Send 0 IPC message so that ISS FW wakes up if it was already
+	 asleep */
+	writel(IPC_DRBL_BUSY_BIT, hw->mem_addr + IPC_REG_HOST2ISH_DRBL);
+
+	return	0;
+}
+
+
+/**
+ * ish_ipc_reset - resets host and fw IPC and upper layers.
+ *
+ * @dev: the device structure
+ */
+static int ish_ipc_reset(struct heci_device *dev)
+{
+	struct ipc_rst_payload_type ipc_mng_msg;
+	int	rv = 0;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s():+++\n", __func__);
+	dev_dbg(&dev->pdev->dev, "ish_hw_reset\n");
+	/*temporary we'll send reset*/
+
+	ipc_mng_msg.reset_id = 1;
+	ipc_mng_msg.reserved = 0;
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): before ish_intr_enable()\n", __func__);
+	ish_intr_enable(dev);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): after ish_intr_enable()\n", __func__);
+
+/* DEBUG: send self-interrupt and wait 100 (ms) for it to appear in klog */
+/*	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0x80000000);
+	mdelay(100);
+************************/
+
+	/* Clear the incoming doorbell */
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): Doorbell cleared, busy reading cleared\n", __func__);
+	ish_reg_write(dev, IPC_REG_ISH2HOST_DRBL, 0);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): cleared doorbell reg.\n", __func__);
+
+	/*
+	 * Fixed: this should be set BEFORE writing RESET_NOTIFY,
+	 * lest response will be received BEFORE this clearing...
+	 */
+	dev->recvd_hw_ready = 0;
+
+	/*send message */
+	rv = ipc_send_mng_msg(dev, MNG_RESET_NOTIFY, &ipc_mng_msg,
+		sizeof(struct ipc_rst_payload_type));
+	if (rv) {
+		dev_err(&dev->pdev->dev, "Failed to send IPC MNG_RESET_NOTIFY\n");
+		return	rv;
+	}
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): going to wait for hw_ready.\n",
+		__func__);
+	/*wait_event_interruptible(dev->wait_hw_ready, dev->recvd_hw_ready);*/
+	wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready, 2*HZ);
+	if (!dev->recvd_hw_ready) {
+		dev_err(&dev->pdev->dev, "Timed out waiting for HW ready\n");
+		rv = -ENODEV;
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s(): woke up from hw_ready.\n", __func__);
+
+	dev_dbg(&dev->pdev->dev, "exit initial link wait\n");
+
+	return rv;
+}
+
+/* Dummy. Do we need it? */
+static void ish_hw_config(struct heci_device *dev)
+{
+	ISH_DBG_PRINT(KERN_ALERT "%s()+++ [ish_hw_reset=%p]\n",
+		__func__, ish_hw_reset);
+	dev_dbg(&dev->pdev->dev, "ish_hw_config\n");
+}
+
+static int ish_hw_start(struct heci_device *dev)
+{
+	struct ish_hw *hw = to_ish_hw(dev);
+
+	dev_dbg(&dev->pdev->dev, "ish_hw_start\n");
+	ish_set_host_rdy(dev);
+#ifdef	D3_RCR
+	/* After that we can enable ISH DMA operation */
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s(): writing DMA_ENABLED\n",
+		__func__);
+	writel(IPC_RMP2_DMA_ENABLED, hw->mem_addr + IPC_REG_ISH_RMP2);
+
+	/* Send 0 IPC message so that ISS FW wakes up if it was already
+	 asleep */
+	writel(IPC_DRBL_BUSY_BIT, hw->mem_addr + IPC_REG_HOST2ISH_DRBL);
+#endif /*D3_RCR*/
+	ish_intr_enable(dev);
+	return 0;
+}
+
+
+static u32 ish_read_hdr(const struct heci_device *dev)
+{
+	return ish_reg_read(dev, IPC_REG_ISH2HOST_MSG);
+}
+
+
+/**
+ * ish_write - writes a message to heci device.
+ *
+ * @dev: the device structure
+ * @header: header of message
+ * @buf: message buffer will be written
+ * returns 1 if success, 0 - otherwise.
+ */
+
+static int ish_write(struct heci_device *dev, struct heci_msg_hdr *header,
+	unsigned char *buf)
+{
+/*#####################################################################*/
+	unsigned char ipc_msg[IPC_FULL_MSG_SIZE];
+	u32 doorbell_val;
+
+	doorbell_val = IPC_BUILD_HEADER(header->length +
+		sizeof(struct heci_msg_hdr), IPC_PROTOCOL_HECI, 1);
+	memcpy(ipc_msg, (char *)&doorbell_val, sizeof(u32));
+	memcpy(ipc_msg + sizeof(u32), (char *)header,
+		sizeof(struct heci_msg_hdr));
+	memcpy(ipc_msg + sizeof(u32) + sizeof(struct heci_msg_hdr), buf,
+		header->length);
+
+	return write_ipc_to_queue(dev, NULL, NULL, ipc_msg,
+		sizeof(u32) + sizeof(struct heci_msg_hdr) + header->length);
+/*#####################################################################*/
+}
+
+
+static const struct heci_hw_ops ish_hw_ops = {
+	.host_is_ready = ish_host_is_ready,
+	.hw_is_ready = ish_hw_is_ready,
+	.hw_reset = ish_hw_reset,
+	.ipc_reset = ish_ipc_reset,
+	.hw_config = ish_hw_config,
+	.hw_start = ish_hw_start,
+	.read = ish_read,
+	.write = ish_write,
+	.write_ex = ipc_send_heci_msg,
+	.get_fw_status = ish_read_fw_sts_reg
+};
+
+
+struct heci_device *ish_dev_init(struct pci_dev *pdev)
+{
+
+	struct heci_device *dev;
+
+	dev = kzalloc(sizeof(struct heci_device) +  sizeof(struct ish_hw),
+		GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	heci_device_init(dev);
+
+	/* Rx INT->BH FIFO pointers */
+	dev->rd_msg_fifo_head = 0;
+	dev->rd_msg_fifo_tail = 0;
+	spin_lock_init(&dev->rd_msg_spinlock);
+	spin_lock_init(&dev->wr_processing_spinlock);
+	spin_lock_init(&dev->out_ipc_spinlock);
+	spin_lock_init(&dev->read_list_spinlock);
+	spin_lock_init(&dev->device_lock);
+	spin_lock_init(&dev->device_list_lock);
+	spin_lock_init(&dev->cl_list_lock);
+	spin_lock_init(&dev->me_clients_lock);
+	INIT_WORK(&dev->bh_hbm_work, bh_hbm_work_fn);
+
+	dev->ops = &ish_hw_ops;
+	dev->pdev = pdev;
+	dev->mtu = IPC_PAYLOAD_SIZE - sizeof(struct heci_msg_hdr);
+	return dev;
+}
+
+
+void	heci_device_disable(struct heci_device *dev)
+{
+	unsigned long	flags;
+	struct wr_msg_ctl_info	*ipc_link;
+	struct heci_cl	*cl;
+
+	dev->dev_state = HECI_DEV_DISABLED;
+	ish_clr_host_rdy(dev);
+	ish_intr_disable(dev);
+
+	/* Free all other allocations */
+	kfree(dev->me_clients);
+}
+
diff --git a/drivers/misc/intel-ish/hw-ish.h b/drivers/misc/intel-ish/hw-ish.h
new file mode 100644
index 0000000..cc56113
--- /dev/null
+++ b/drivers/misc/intel-ish/hw-ish.h
@@ -0,0 +1,62 @@
+/*
+ * H/W layer of HECI provider device (ISS)
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _HECI_HW_ISH_H_
+#define _HECI_HW_ISH_H_
+
+#include <linux/pci.h>
+#include "hw-ish-regs.h"
+#include "heci_dev.h"
+
+extern int	suspend_flag;
+extern wait_queue_head_t	suspend_wait;
+
+struct ipc_rst_payload_type {
+	u16            reset_id;
+	u16            reserved;
+};
+
+struct ish_hw {
+	void __iomem *mem_addr;
+};
+
+#define to_ish_hw(dev) (struct ish_hw *)((dev)->hw)
+
+
+struct heci_device *ish_dev_init(struct pci_dev *pdev);
+
+irqreturn_t ish_irq_handler(int irq, void *dev_id);
+
+void ish_clr_host_rdy(struct heci_device *dev);
+void ish_set_host_rdy(struct heci_device *dev);
+bool ish_hw_is_ready(struct heci_device *dev);
+void ish_intr_enable(struct heci_device *dev);
+void ish_intr_disable(struct heci_device *dev);
+
+int	write_ipc_from_queue(struct heci_device *dev);
+
+static int	ipc_send_mng_msg(struct heci_device *dev, uint32_t msg_code,
+	void *msg, size_t size);
+
+static int	ipc_send_heci_msg(struct heci_device *dev,
+	struct heci_msg_hdr *hdr, void *msg, void(*ipc_send_compl)(void *),
+	void *ipc_send_compl_prm);
+
+static u32	ish_read_hdr(const struct heci_device *dev);
+
+void g_ish_print_log(char *format, ...);
+
+#endif /* _HECI_HW_ISH_H_ */
+
diff --git a/drivers/misc/intel-ish/init.c b/drivers/misc/intel-ish/init.c
new file mode 100644
index 0000000..39336b9
--- /dev/null
+++ b/drivers/misc/intel-ish/init.c
@@ -0,0 +1,254 @@
+/*
+ * Initialization protocol for HECI driver
+ *
+ * Copyright (c) 2003-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/export.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include "heci_dev.h"
+#include "hbm.h"
+#include "client.h"
+#include "utils.h"
+#include "platform-config.h"
+
+const char *heci_dev_state_str(int state)
+{
+	switch (state) {
+	case HECI_DEV_INITIALIZING:
+		return	"INITIALIZING";
+	case HECI_DEV_INIT_CLIENTS:
+		return	"INIT_CLIENTS";
+	case HECI_DEV_ENABLED:
+		return	"ENABLED";
+	case HECI_DEV_RESETTING:
+		return	"RESETTING";
+	case HECI_DEV_DISABLED:
+		return	"DISABLED";
+	case HECI_DEV_POWER_DOWN:
+		return	"POWER_DOWN";
+	case HECI_DEV_POWER_UP:
+		return	"POWER_UP";
+	default:
+		return "unkown";
+	}
+}
+EXPORT_SYMBOL(heci_dev_state_str);
+
+void heci_device_init(struct heci_device *dev)
+{
+	/* setup our list array */
+	INIT_LIST_HEAD(&dev->cl_list);
+	INIT_LIST_HEAD(&dev->device_list);
+	init_waitqueue_head(&dev->wait_hw_ready);
+	init_waitqueue_head(&dev->wait_hbm_recvd_msg);
+	init_waitqueue_head(&dev->wait_dma_ready);
+	dev->dev_state = HECI_DEV_INITIALIZING;
+
+	/*
+	 * We need to reserve something, because client #0
+	 * is reserved for HECI bus messages
+	 */
+	bitmap_zero(dev->host_clients_map, HECI_CLIENTS_MAX);
+	dev->open_handle_count = 0;
+
+	/*
+	 * Reserving the first three client IDs
+	 * 0: Reserved for HECI Bus Message communications
+	 * 1: Reserved for Watchdog
+	 * 2: Reserved for AMTHI
+	 */
+	bitmap_set(dev->host_clients_map, 0, 3);
+	/*****************************/
+
+	heci_io_list_init(&dev->read_list);
+
+	/* Init IPC processing and free lists */
+	INIT_LIST_HEAD(&dev->wr_processing_list_head.link);
+	INIT_LIST_HEAD(&dev->wr_free_list_head.link);
+	do {
+		int	i;
+
+		for (i = 0; i < IPC_TX_FIFO_SIZE; ++i) {
+			struct wr_msg_ctl_info	*tx_buf;
+
+			tx_buf = kmalloc(sizeof(struct wr_msg_ctl_info),
+				GFP_KERNEL);
+			if (!tx_buf) {
+				/*
+				 * ERROR: decide what to do with it.
+				 * IPC buffers may be limited or not available
+				 * at all - although this shouldn't happen
+				 */
+				dev_err(&dev->pdev->dev, "[heci-ish]: failure in Tx FIFO allocations (%d)\n",
+					i);
+				break;
+			}
+			memset(tx_buf, 0, sizeof(struct wr_msg_ctl_info));
+			list_add_tail(&tx_buf->link,
+				&dev->wr_free_list_head.link);
+		}
+		printk(KERN_ALERT "[heci-ish]: success Tx FIFO allocations\n");
+	} while (0);
+}
+EXPORT_SYMBOL_GPL(heci_device_init);
+
+/**
+ * heci_start - initializes host and fw to start work.
+ *
+ * @dev: the device structure
+ *
+ * returns 0 on success, <0 on failure.
+ */
+int heci_start(struct heci_device *dev)
+{
+	heci_hw_config(dev);
+#ifdef FORCE_FW_INIT_RESET
+	/* wait for FW-initiated reset flow, indefinitely */
+	heci_hw_start(dev);
+	/* 16/6/2014: changed this 2->5 seconds following MCG assertion.
+	 * Once this was 10 seconds, lowered to 2.
+	 * TODO: check out all FW ISS/SEC path how much it should be */
+
+	/*timed_wait_for_timeout(WAIT_FOR_CONNECT_SLICE, dev->recvd_hw_ready,
+		(10*HZ));*/
+	if (!dev->recvd_hw_ready)
+		wait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready,
+			10*HZ);
+	/*
+	 * Lock only after FW-reset flow worked or failed.
+	 * otherwise interrupts BH will be locked
+	 */
+	if (dev->recvd_hw_ready)
+		goto	reset_done;
+	dev_err(&dev->pdev->dev, "[heci-ish] %s(): Timed out waiting for FW-initiated reset\n",
+		__func__);
+#if 1
+	goto	err;	/* DEBUGDEBUGDEBUG: raise timeout for FW-initiated reset
+			 * to 10 s and don't sent host-initiated reset flow */
+#endif
+	/* DEBUGDEBUGDEBUG: Below code until 'reset_done:' is defunct */
+#else
+#endif
+	/* acknowledge interrupt and stop interupts */
+	dev_dbg(&dev->pdev->dev, "reset in start the heci device.\n");
+	heci_reset(dev, 1);
+
+reset_done:
+	if (heci_hbm_start_wait(dev)) {
+		dev_err(&dev->pdev->dev, "HBM haven't started");
+		goto err;
+	}
+
+	if (!heci_host_is_ready(dev)) {
+		dev_err(&dev->pdev->dev, "host is not ready.\n");
+		goto err;
+	}
+
+	if (!heci_hw_is_ready(dev)) {
+		dev_err(&dev->pdev->dev, "ME is not ready.\n");
+		goto err;
+	}
+
+	/*if (dev->version.major_version != HBM_MAJOR_VERSION ||
+	    dev->version.minor_version != HBM_MINOR_VERSION) {
+		dev_dbg(&dev->pdev->dev, "HECI start failed.\n");
+		goto err;
+	}*/
+
+	dev_dbg(&dev->pdev->dev, "link layer has been established.\n");
+
+	/*suspend & resume notification - send QUERY_SUBSCRIBERS msg*/
+	query_subscribers(dev);
+
+	return 0;
+err:
+	dev_err(&dev->pdev->dev, "link layer initialization failed.\n");
+	dev->dev_state = HECI_DEV_DISABLED;
+	return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(heci_start);
+
+/**
+ * heci_reset - resets host and fw.
+ *
+ * @dev: the device structure
+ * @interrupts_enabled: if interrupt should be enabled after reset.
+ */
+void heci_reset(struct heci_device *dev, int interrupts_enabled)
+{
+	bool unexpected;
+	int ret;
+
+	unexpected = (dev->dev_state != HECI_DEV_INITIALIZING &&
+			dev->dev_state != HECI_DEV_DISABLED &&
+			dev->dev_state != HECI_DEV_POWER_DOWN &&
+			dev->dev_state != HECI_DEV_POWER_UP);
+
+	ret = heci_hw_reset(dev);
+	if (ret) {
+		dev_err(&dev->pdev->dev, "hw reset failed disabling the device\n");
+		interrupts_enabled = false;
+		dev->dev_state = HECI_DEV_DISABLED;
+	}
+
+	dev->hbm_state = HECI_HBM_IDLE;
+
+	if (dev->dev_state != HECI_DEV_INITIALIZING) {
+		if (dev->dev_state != HECI_DEV_DISABLED &&
+		    dev->dev_state != HECI_DEV_POWER_DOWN)
+			dev->dev_state = HECI_DEV_RESETTING;
+
+		heci_cl_all_disconnect(dev);
+	}
+
+	if (unexpected)
+		dev_warn(&dev->pdev->dev, "unexpected reset: dev_state = %s\n",
+			 heci_dev_state_str(dev->dev_state));
+
+	if (!interrupts_enabled) {
+		dev_dbg(&dev->pdev->dev, "intr not enabled end of reset\n");
+		return;
+	}
+	dev_dbg(&dev->pdev->dev, "before sending HOST start\n");
+	ret = heci_hw_start(dev);
+	if (ret) {
+		dev_err(&dev->pdev->dev, "hw_start failed disabling the device\n");
+		dev->dev_state = HECI_DEV_DISABLED;
+		return;
+	}
+
+	dev_dbg(&dev->pdev->dev, "link is established start sending messages.\n");
+	/* link is established * start sending messages.  */
+
+	dev->dev_state = HECI_DEV_INIT_CLIENTS;
+	dev->hbm_state = HECI_HBM_START;
+	heci_hbm_start_req(dev);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): after heci_hbm_start_req()\n",
+		__func__);
+	/* wake up all readings so they can be interrupted */
+	heci_cl_all_read_wakeup(dev);
+}
+EXPORT_SYMBOL_GPL(heci_reset);
+
+void heci_stop(struct heci_device *dev)
+{
+	dev_dbg(&dev->pdev->dev, "stopping the device.\n");
+	dev->dev_state = HECI_DEV_POWER_DOWN;
+	heci_reset(dev, 0);
+	flush_scheduled_work();
+}
+EXPORT_SYMBOL_GPL(heci_stop);
+
diff --git a/drivers/misc/intel-ish/ish-hid-dd.c b/drivers/misc/intel-ish/ish-hid-dd.c
new file mode 100644
index 0000000..a1e816c
--- /dev/null
+++ b/drivers/misc/intel-ish/ish-hid-dd.c
@@ -0,0 +1,984 @@
+/*
+ * HID Sensors Driver
+ * Copyright (c) 2012, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program;
+ *
+ */
+
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include "hid-sens-ids.h"
+#include <linux/senscol/senscol-core.h>
+
+/* TODO: remove everything but what ISH exposes */
+#define USB_VENDOR_ID_INTEL_0		0x8086
+#define USB_VENDOR_ID_INTEL_1		0x8087
+#define USB_DEVICE_ID_INTEL_HID_SENSOR	0x09fa
+#define USB_VENDOR_ID_STM_0             0x0483
+#define USB_DEVICE_ID_STM_HID_SENSOR    0x91d1
+#define USB_DEVICE_ID_STM_HID_SENSOR_1  0x9100
+
+
+
+/**
+ * struct ish_pending - Synchronous read pending information
+ * @status:		Pending status true/false.
+ * @ready:		Completion synchronization data.
+ * @usage_id:		Usage id for physical device, E.g. Gyro usage id.
+ * @attr_usage_id:	Usage Id of a field, E.g. X-AXIS for a gyro.
+ * @raw_size:		Response size for a read request.
+ * @raw_data:		Place holder for received response.
+ */
+struct ish_pending {
+	bool status;
+	struct completion ready;
+	u32 usage_id;
+	u32 attr_usage_id;
+	int raw_size;
+	u8  *raw_data;
+};
+
+struct hid_sens_hub_device {
+	struct hid_device *hdev;
+	u32 vendor_id;
+	u32 product_id;
+};
+
+/**
+ * struct ish_data - Hold a instance data for a HID hub device
+ * @hsdev:		Stored hid instance for current hub device.
+ * @lock:		Spin lock to protect pending request structure.
+ * @pending:		Holds information of pending sync read request.
+ */
+struct ish_data {
+	struct hid_sens_hub_device *hsdev;
+	struct mutex mutex;
+	spinlock_t lock;
+	struct ish_pending pending;
+	int ish_index;	/* Needed to identify sensor in a collection */
+};
+
+#define	MAX_HID_SENSOR_HUBS 32
+static struct hid_device *hid_sens_hubs[MAX_HID_SENSOR_HUBS];
+static int	ish_cur_count;
+static int	ish_max_count;
+
+static struct hid_report *ish_report(int id, struct hid_device *hdev,
+						int dir)
+{
+	struct hid_report *report;
+
+	list_for_each_entry(report, &hdev->report_enum[dir].report_list, list) {
+		if (report->id == id)
+			return report;
+	}
+	hid_warn(hdev, "No report with id 0x%x found\n", id);
+
+	return NULL;
+}
+
+static int ish_get_physical_device_count(
+				struct hid_report_enum *report_enum)
+{
+	struct hid_report *report;
+	struct hid_field *field;
+	int cnt = 0;
+
+	list_for_each_entry(report, &report_enum->report_list, list) {
+		field = report->field[0];
+		if (report->maxfield && field && field->physical)
+			cnt++;
+	}
+
+	return cnt;
+}
+
+static int ish_set_feature(struct hid_sens_hub_device *hsdev, u32 report_id,
+				u32 field_index, s32 value)
+{
+	struct hid_report *report;
+	struct ish_data *data = hid_get_drvdata(hsdev->hdev);
+	int ret = 0;
+
+	mutex_lock(&data->mutex);
+	report = ish_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report || (field_index >= report->maxfield)) {
+		ret = -EINVAL;
+		goto done_proc;
+	}
+	hid_set_field(report->field[field_index], 0, value);
+	hid_hw_request(hsdev->hdev, report, HID_REQ_SET_REPORT);
+	hid_hw_wait(hsdev->hdev);
+
+done_proc:
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int ish_suspend(struct hid_device *hdev, pm_message_t message)
+{
+	return	0;
+}
+
+static int ish_resume(struct hid_device *hdev)
+{
+	return 0;
+}
+
+static int ish_reset_resume(struct hid_device *hdev)
+{
+	return 0;
+}
+#endif /*CONFIG_PM*/
+
+/**************************** SENSCOL block: START ****************************/
+#if 1
+static int	senscol_impl_added;
+static int	is_sens_data_field(unsigned usage);
+static int get_field_index(struct hid_device *hdev, unsigned report_id,
+	unsigned usage, int report_idx);
+
+/* Get sensor's property by name */
+static struct sens_property *get_prop_by_name(struct sensor_def *sensor,
+	char *name)
+{
+	int	i;
+
+	for (i = 0; i < sensor->num_properties; ++i)
+		if (!strcmp(sensor->properties[i].name, name))
+			return	&sensor->properties[i];
+
+	return	NULL;
+}
+
+/* Get sensor's data field by name */
+static struct data_field *get_data_field_by_name(struct sensor_def *sensor,
+	char *name)
+{
+	int	i;
+
+	for (i = 0; i < sensor->num_data_fields; ++i)
+		if (!strcmp(sensor->data_fields[i].name, name))
+			return	&sensor->data_fields[i];
+
+	return	NULL;
+}
+
+static int get_field_index(struct hid_device *hdev, unsigned report_id,
+	unsigned usage, int report_type)
+{
+	int i = 0;
+	struct hid_report *report;
+
+	report = ish_report(report_id, hdev,
+		report_type /*HID_FEATURE_REPORT or HID_INPUT_REPORT*/);
+	if (!report)
+		return -1;
+
+	for (i = 0; i < report->maxfield; ++i)
+		if (report->field[i]->usage->hid == usage)
+			return i;
+
+	return -1;
+}
+
+/*
+ * The reason for this _ex() function is broken semantics and existing
+ * usage of ish_get_feature() that
+ * doesn't allow anything with ->report_count > 1 to be delivered.
+ * If that was fixed, existing callers would immediately buffer-overflow
+ * if such feature was delivered
+ * NOTES:
+ *   - if ret != 0, contents of pvalue and count are undefined.
+ *   - upon success, count is in s32 values (not in bytes)
+ */
+static int ish_get_feature_ex(struct hid_sens_hub_device *hsdev,
+	u32 report_id, u32 field_index, u32 *usage_id, s32 **pvalue,
+	size_t *count, unsigned *is_string)
+{
+	struct hid_report *report;
+	struct ish_data *data =  hid_get_drvdata(hsdev->hdev);
+	int ret = 0;
+
+	mutex_lock(&data->mutex);
+	report = ish_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report || (field_index >=  report->maxfield) ||
+	    report->field[field_index]->report_count < 1) {
+		ret = -EINVAL;
+		goto done_proc;
+	}
+	hid_hw_request(hsdev->hdev, report, HID_REQ_GET_REPORT);
+	hid_hw_wait(hsdev->hdev);
+	*pvalue = report->field[field_index]->value;
+	*count = report->field[field_index]->report_count;
+	*usage_id = report->field[field_index]->usage->hid;
+	*is_string = (report->field[field_index]->report_size == 16) &&
+			(*count > 1);
+done_proc:
+	mutex_unlock(&data->mutex);
+
+	return ret;
+}
+
+/* Get sensor hub device by index */
+static struct ish_data	*get_ish_by_index(unsigned idx)
+{
+	int	i;
+	struct ish_data	*sd;
+
+	for (i = 0; i < ish_cur_count; ++i) {
+		if (!hid_sens_hubs[i])
+			continue;
+		sd = hid_get_drvdata(hid_sens_hubs[i]);
+		if (!sd)
+			continue;
+		if (sd->ish_index == idx)
+			return	sd;
+	}
+
+	return	NULL;
+}
+
+static int     hid_get_sens_property(struct sensor_def *sensor,
+	const struct sens_property *prop, char *value, size_t val_buf_size)
+{
+	unsigned	idx;
+	struct ish_data	*sd;
+	char	buf[1024];		/* Enough for single property (?) */
+	unsigned	report_id;
+	int	field;
+	uint32_t	usage_id;
+	int32_t	*pval;
+	size_t	count;
+	unsigned is_string;
+	int	rv;
+
+	if (!sensor || !prop)
+		return	-EINVAL;	/* input is invalid */
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_ish_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is bad */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+
+	/* Field index */
+	field = get_field_index(sd->hsdev->hdev, report_id, prop->usage_id,
+		HID_FEATURE_REPORT);
+	if (field == -1)
+		return	-EINVAL;	/* Something is still wrong */
+
+	/* Get value */
+	rv = ish_get_feature_ex(sd->hsdev, report_id, field, &usage_id,
+		&pval, &count, &is_string);
+	if (rv)
+		return	rv;
+
+	if  (is_string) {
+		int	i;
+
+		for (i = 0; i < count; ++i)
+			buf[i] = (char)pval[i];
+		buf[i] = '\0';
+	} else {
+		/* Verify output length */
+		sprintf(buf, "%d", *pval);
+	}
+
+	if (strlen(buf) >= val_buf_size)
+		return	-EMSGSIZE;
+	strcpy(value, buf);
+	return	0;
+}
+
+static int     hid_set_sens_property(struct sensor_def *sensor,
+	const struct sens_property *prop, const char *value)
+{
+	unsigned	idx;
+	struct ish_data	*sd;
+	unsigned	report_id;
+	int	field;
+	int32_t	val;
+	int	rv;
+
+	if (!sensor || !prop)
+		return	-EINVAL;	/* input is invalid */
+
+	/* Value */
+	rv = sscanf(value, " %d ", &val);
+	if (rv != 1)
+		return	-EINVAL;	/* Bad value */
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_ish_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is bad */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+
+	/* Field index */
+	field = get_field_index(sd->hsdev->hdev, report_id, prop->usage_id,
+		HID_FEATURE_REPORT);
+	if (field == -1)
+		return	-EINVAL;	/* Something is still wrong */
+
+	/* Get value */
+	rv = ish_set_feature(sd->hsdev, report_id, field, val);
+	return	rv;
+}
+
+static int     hid_get_sample(struct sensor_def *sensor)
+{
+	unsigned	idx;
+	struct ish_data	*sd;
+	unsigned	report_id;
+	struct	hid_report *report;
+	int	ret = 0;
+
+	if (!sensor)
+		return -EINVAL;
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_ish_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is bad */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+
+	mutex_lock(&sd->mutex);
+	report = ish_report(report_id, sd->hsdev->hdev,
+		HID_INPUT_REPORT);
+	if (!report) {
+		ret = -EINVAL;
+		goto done_proc;
+	}
+	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_GET_REPORT);
+
+	/*The sample will arrive to "raw event" func,
+	and will be pushed to user via "push_sample" method*/
+
+done_proc:
+	mutex_unlock(&sd->mutex);
+
+	return	ret;
+}
+
+/* Check sensor is activated and in batch mode                  *
+ * property_power_state =       2       hid_usage 0x200319      *
+ * property_reporting_state =   2/5     hid_usage 0x200316      *
+ * property_report_interval !=  0       hid_usage 0x20030e      *
+ * property_report_interval_resolution != 0 hid_usage 0x20530e  *
+ * return value:        0 - sensor is not activated in batch    *
+ *                      1 - sensor is activated in batch        */
+static int      hid_batch_check(struct sensor_def *sensor)
+{
+	unsigned idx;
+	struct ish_data  *sd;
+	unsigned report_id;
+	struct hid_report *report;
+	int field_idx;
+
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_ish_by_index(idx);
+	if (!sd)
+		return -EINVAL;
+	report_id = sensor->id & 0xFFFF;
+	report = ish_report(report_id, sd->hsdev->hdev,
+		HID_FEATURE_REPORT);
+	if (!report)
+		return -EINVAL;
+
+	/* property_power_state */
+	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x200319,
+		HID_FEATURE_REPORT);
+	if (field_idx < 0)
+		return -EINVAL;
+	if (report->field[field_idx]->value[0] != 2)
+		return 0;
+
+	/* property_reporting_state */
+	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x200316,
+		HID_FEATURE_REPORT);
+	if (field_idx < 0)
+		return -EINVAL;
+	if (report->field[field_idx]->value[0] != 2 &&
+		report->field[field_idx]->value[0] != 5)
+		return 0;
+
+	/* property_report_interval */
+	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x20030e,
+		HID_FEATURE_REPORT);
+	if (field_idx < 0)
+		return -EINVAL;
+	if (report->field[field_idx]->value[0] == 0)
+		return 0;
+
+	/* property_report_interval_resolution */
+	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x20530e,
+		HID_FEATURE_REPORT);
+	if (field_idx < 0)
+		return -EINVAL;
+	if (report->field[field_idx]->value[0] == 0)
+		return 0;
+
+	return 1;
+}
+
+struct senscol_impl	hid_senscol_impl = {
+	.get_sens_property = hid_get_sens_property,
+	.set_sens_property = hid_set_sens_property,
+	.get_sample = hid_get_sample,
+	.batch_check = hid_batch_check
+};
+
+static int	is_sens_data_field(unsigned usage)
+{
+	if (usage >= 0x400 && usage <= 0x49F ||
+			usage >= 0x4B0 && usage <= 0x4DF ||
+			usage >= 0x4F0 && usage <= 0x4F7 ||
+			usage >= 0x500 && usage <= 0x52F ||
+			usage >= 0x540 && usage <= 0x57F ||
+			usage >= 590 && usage <= 0x7FF)
+		return	1;
+	return	0;
+}
+
+static int	fill_data_field(struct hid_field *field, unsigned usage,
+	struct sensor_def *senscol_sensor)
+{
+	struct data_field	data_field;
+	char	*usage_name;
+	int	rv;
+
+	memset(&data_field, 0, sizeof(struct data_field));
+	usage_name = senscol_usage_to_name(usage & 0xFFFF);
+	if (usage_name)
+		data_field.name = kasprintf(GFP_KERNEL, "%s", usage_name);
+	else
+		data_field.name = kasprintf(GFP_KERNEL, "data-%X", usage);
+	if (!data_field.name)
+		return	-ENOMEM;
+
+	data_field.usage_id = usage;
+	data_field.is_numeric = (field->flags & HID_MAIN_ITEM_VARIABLE);
+	if (data_field.is_numeric) {
+		if (field->unit_exponent > 7 ||
+				field->unit_exponent < -8)
+			data_field.exp = 0xFF;
+		else if (field->unit_exponent >= 0)
+			data_field.exp = field->unit_exponent;
+		else
+			data_field.exp = 0x10 - field->unit_exponent;
+		data_field.unit = field->unit;
+	}
+
+	data_field.len = (field->report_size >> 3) * field->report_count;
+	rv = add_data_field(senscol_sensor, &data_field);
+	senscol_sensor->sample_size += (field->report_size >> 3) *
+		field->report_count;
+
+	return	rv;
+}
+
+#endif /*SENSCOL*/
+/***************************** SENSCOL block: END *****************************/
+
+/*
+ * Handle raw report as sent by device
+ */
+static int ish_raw_event(struct hid_device *hdev,
+		struct hid_report *report, u8 *raw_data, int size)
+{
+	int i;
+	u8 *ptr;
+	int sz;
+	struct ish_data *pdata = hid_get_drvdata(hdev);
+	unsigned long flags;
+	struct hid_collection *collection = NULL;
+	void *priv = NULL;
+#if 1
+	uint32_t	sensor_id;
+	static unsigned char	data_buf[1024];
+	unsigned	sample_size;
+#endif /*SENSCOL*/
+
+
+	hid_dbg(hdev, "ish_raw_event report id:0x%x size:%d type:%d\n",
+			 report->id, size, report->type);
+	hid_dbg(hdev, "maxfield:%d\n", report->maxfield);
+	if (report->type != HID_INPUT_REPORT)
+		return 0;
+
+	ptr = raw_data;
+	ptr++; /* Skip report id */
+
+	spin_lock_irqsave(&pdata->lock, flags);
+
+#if 1
+	/* make up senscol id */
+	sensor_id = pdata->ish_index << 16 | report->id & 0xFFFF;
+	sample_size = 0;
+#endif /*SENSCOL*/
+
+	for (i = 0; i < report->maxfield; ++i) {
+		hid_dbg(hdev, "%d collection_index:%x hid:%x sz:%x\n",
+				i, report->field[i]->usage->collection_index,
+				report->field[i]->usage->hid,
+				(report->field[i]->report_size *
+					report->field[i]->report_count)/8);
+		sz = (report->field[i]->report_size *
+					report->field[i]->report_count)/8;
+
+#if 1
+		/* Prepare data for senscol sample */
+		if (is_sens_data_field(report->field[i]->usage->hid & 0xFFFF)) {
+			dev_dbg(&hdev->dev, "%s(): aggregating, sz=%u\n",
+				__func__, sample_size);
+			memcpy(data_buf + sample_size, ptr, sz);
+			sample_size += sz;
+		}
+#endif /*SENSCOL*/
+		/*
+		 * If we want to add indication into raw stream that the last
+		 * sample was synchronous, it's here: check for complete()
+		 * condition above
+		 */
+
+		ptr += sz;
+	}
+
+	spin_unlock_irqrestore(&pdata->lock, flags);
+
+#if 1
+	/* Upstream sample to sensor collection framework */
+	dev_dbg(&hdev->dev, "%s(): calling push_sample, aggregated sample size is %u\n",
+		__func__, sample_size);
+	push_sample(sensor_id, data_buf);
+#endif /*SENSCOL*/
+	return 1;
+}
+
+static __u8 *ish_report_fixup(struct hid_device *hdev, __u8 *rdesc,
+		unsigned int *rsize)
+{
+	int index;
+	struct ish_data *sd =  hid_get_drvdata(hdev);
+	unsigned char report_block[] = {
+				0x0a,  0x16, 0x03, 0x15, 0x00, 0x25, 0x05};
+	unsigned char power_block[] = {
+				0x0a,  0x19, 0x03, 0x15, 0x00, 0x25, 0x05};
+
+	/* Looks for power and report state usage id and force to 1 */
+	for (index = 0; index < *rsize; ++index) {
+		if (((*rsize - index) > sizeof(report_block)) &&
+			!memcmp(&rdesc[index], report_block,
+						sizeof(report_block))) {
+			rdesc[index + 4] = 0x01;
+			index += sizeof(report_block);
+		}
+		if (((*rsize - index) > sizeof(power_block)) &&
+			!memcmp(&rdesc[index], power_block,
+						sizeof(power_block))) {
+			rdesc[index + 4] = 0x01;
+			index += sizeof(power_block);
+		}
+	}
+
+	return rdesc;
+}
+
+static int ish_probe(struct hid_device *hdev,
+				const struct hid_device_id *id)
+{
+	int ret;
+	struct ish_data *sd;
+	int i;
+	char *name;
+	struct hid_report *report, *freport;
+	struct hid_report_enum *inp_report_enum, *feat_report_enum;
+	struct hid_field *field, *feat_field;
+	int dev_cnt;
+	int	rv;
+	struct sensor_def	*senscol_sensor;
+	int	j;
+	const char	*usage_name;
+
+	sd = devm_kzalloc(&hdev->dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd) {
+		hid_err(hdev, "cannot allocate Sensor data\n");
+		return -ENOMEM;
+	}
+	sd->hsdev = devm_kzalloc(&hdev->dev, sizeof(*sd->hsdev), GFP_KERNEL);
+	if (!sd->hsdev) {
+		hid_err(hdev, "cannot allocate hid_sens_hub_device\n");
+		ret = -ENOMEM;
+		goto err_free_hub;
+	}
+	hid_set_drvdata(hdev, sd);
+	/* Keep array of HID sensor hubs for senscol_impl usage */
+	hid_sens_hubs[ish_cur_count] = hdev;
+	/* Need to count sensor hub devices for senscol ids */
+	sd->ish_index = ish_cur_count++;
+#if 1
+	if (ish_cur_count >= ish_max_count)
+		senscol_send_ready_event();
+	if (ish_cur_count > ish_max_count)
+		ish_max_count = ish_cur_count;
+#endif
+	sd->hsdev->hdev = hdev;
+	sd->hsdev->vendor_id = hdev->vendor;
+	sd->hsdev->product_id = hdev->product;
+	spin_lock_init(&sd->lock);
+	mutex_init(&sd->mutex);
+	ret = hid_parse(hdev);
+	if (ret) {
+		hid_err(hdev, "parse failed\n");
+		goto err_free;
+	}
+	INIT_LIST_HEAD(&hdev->inputs);
+
+	ret = hid_hw_start(hdev, 0);
+	if (ret) {
+		hid_err(hdev, "hw start failed\n");
+		goto err_free;
+	}
+	inp_report_enum = &hdev->report_enum[HID_INPUT_REPORT];
+	feat_report_enum = &hdev->report_enum[HID_FEATURE_REPORT];
+
+	dev_cnt = ish_get_physical_device_count(inp_report_enum);
+	if (dev_cnt > HID_MAX_PHY_DEVICES) {
+		hid_err(hdev, "Invalid Physical device count\n");
+		ret = -EINVAL;
+		goto err_stop_hw;
+	}
+
+#if 1
+	/* Register senscol impl */
+	if (!senscol_impl_added) {
+		rv = add_senscol_impl(&hid_senscol_impl);
+		dev_dbg(&hdev->dev, "%s(): add_senscol_impl() returned %d\n",
+			__func__, rv);
+		if (!rv)
+			senscol_impl_added = 1;
+	}
+#endif /*SENSCOL*/
+	/* Translate properties logical->physical if needed here,
+	 * instead of hid-core */
+	list_for_each_entry(freport, &feat_report_enum->report_list, list) {
+		int	j;
+
+		for (j = 0; j < freport->maxfield; ++j) {
+			feat_field = freport->field[j];
+			if (!(feat_field->flags & HID_MAIN_ITEM_VARIABLE))
+				for (i = 0; i < feat_field->maxusage; ++i)
+					feat_field->usage[i].hid =
+						feat_field->logical;
+		}
+	}
+
+	/* Translate  input fields logical->physical if needed here,
+	 * instead of hid-core */
+	list_for_each_entry(report, &inp_report_enum->report_list, list) {
+		int	j;
+
+		for (j = 0; j < report->maxfield; ++j) {
+			field = report->field[j];
+			if (!(field->flags & HID_MAIN_ITEM_VARIABLE))
+				for (i = 0; i < field->maxusage; ++i)
+					field->usage[i].hid = field->logical;
+		}
+	}
+
+	list_for_each_entry(report, &inp_report_enum->report_list, list) {
+		hid_dbg(hdev, "Report id:%x\n", report->id);
+		field = report->field[0];
+
+#if 1
+		/* Create senscol sensor from each report */
+		senscol_sensor = alloc_senscol_sensor();
+		if (!senscol_sensor) {
+			dev_err(&hdev->dev,
+				"%s(): failed to allocate sensor\n", __func__);
+			break;
+		}
+		init_senscol_sensor(senscol_sensor);
+		usage_name = senscol_usage_to_name(field->physical & 0xFFFF);
+		if (usage_name)
+			senscol_sensor->name = kasprintf(GFP_KERNEL,
+				"%s", usage_name);
+		else
+			senscol_sensor->name = kasprintf(GFP_KERNEL,
+				"custom-%X", field->physical);
+		if (!senscol_sensor->name) {
+			dev_err(&hdev->dev,
+				"%s(): failed to allocate name\n",
+				__func__);
+			kfree(senscol_sensor);
+			break;
+		}
+		senscol_sensor->usage_id = field->physical;
+		senscol_sensor->id = sd->ish_index << 16 |
+			report->id & 0xFFFF;
+		senscol_sensor->impl = &hid_senscol_impl;
+		senscol_sensor->sample_size = 0;
+
+		/* Add properties */
+		/* 1. find matching feature report */
+		list_for_each_entry(freport,
+				&feat_report_enum->report_list,
+				list) {
+			feat_field = freport->field[0];
+			if (freport->maxfield && feat_field &&
+					feat_field->physical &&
+					(feat_field->physical ==
+					senscol_sensor->usage_id) &&
+					freport->id == report->id)
+				break;
+		}
+
+		/*2. dump each prop field */
+		for (i = 0; i < freport->maxfield; ++i) {
+			struct sens_property	prop_field;
+
+			dev_dbg(&hdev->dev,
+				"%d collection_index:%x hid:%x sz:%x ",
+				i,
+				freport->field[i]->usage->
+					collection_index,
+				freport->field[i]->usage->hid,
+				freport->field[i]->report_size / 8);
+
+			dev_dbg(&hdev->dev, "report count: %u\n",
+				freport->field[i]->report_count);
+
+			memset(&prop_field, 0,
+				sizeof(struct sens_property));
+			prop_field.usage_id =
+				freport->field[i]->usage->hid;
+			usage_name = senscol_usage_to_name(
+				prop_field.usage_id & 0xFFFF);
+			if (usage_name)
+				prop_field.name = kasprintf(GFP_KERNEL,
+						"%s", usage_name);
+			/* there is  a special case when the property
+			 * is related to specific data field/
+			 * set of fields */
+			else {
+				uint32_t modifier =
+					prop_field.usage_id & 0xF000;
+				uint32_t data_hid =
+					prop_field.usage_id & 0x0FFF;
+				const char *modif_name =
+					senscol_get_modifier(modifier);
+				usage_name = senscol_usage_to_name(
+					data_hid);
+
+				if (!strcmp(modif_name, "custom")) {
+					prop_field.name =
+						kasprintf(GFP_KERNEL,
+						"custom-%X",
+						prop_field.usage_id & 0xFFFF);
+				} else if (!usage_name)
+					prop_field.name =
+						kasprintf(GFP_KERNEL,
+						"unknown-%X",
+						prop_field.usage_id & 0xFFFF);
+				else
+					prop_field.name =
+						kasprintf(GFP_KERNEL,
+						"%s_%s", usage_name,
+						modif_name);
+			}
+			prop_field.is_numeric =
+				(freport->field[i]->flags &
+				HID_MAIN_ITEM_VARIABLE) &&
+				/* not string: not array of unsigned short */
+				!(freport->field[i]->report_count > 1 &&
+				freport->field[i]->report_size == 16);
+
+			rv = add_sens_property(senscol_sensor,
+				&prop_field);
+			dev_dbg(&hdev->dev, "%s(): ", __func__);
+			dev_dbg(&hdev->dev, "adding prop %s %s %d\n",
+				prop_field.name, "returned",  rv);
+		}
+
+		/* Add data fields; Dump fields in this report.
+		`maxfield' is upper-bound NON-INCLUSIVE */
+		for (j = 0; j < report->maxfield; ++j) {
+
+			dev_dbg(&hdev->dev, "%s(): ", __func__);
+			dev_dbg(&hdev->dev,
+				"%s=%d %s=%08X %s=%08X %s=%u %s=%u ",
+				"field", j,
+				"physical",  report->field[j]->physical,
+				"logical", report->field[j]->logical,
+				"maxusage", report->field[j]->maxusage,
+				"report_type",
+				report->field[j]->report_type);
+			dev_dbg(&hdev->dev, "%s=%u %s=%d %s=%d %s=%d ",
+				"report_size",
+				report->field[j]->report_size >> 3,
+				"logic_min",
+				report->field[j]->logical_minimum,
+				"logic_max",
+				report->field[j]->logical_maximum,
+				"phys_min",
+				report->field[j]->physical_minimum);
+			dev_dbg(&hdev->dev, "%s=%d %s=%d %s=%u %s=%d\n",
+				"phys_max",
+				report->field[j]->physical_maximum,
+				"exp",
+				report->field[j]->unit_exponent,
+				"unit",
+				report->field[j]->unit,
+				"report_count",
+				report->field[j]->report_count);
+			dev_dbg(&hdev->dev, "%s(): usages --\n",
+				__func__);
+
+			field = report->field[j];
+			/* Add data field */
+			if (is_sens_data_field(field->usage[0].hid & 0xFFFF)) {
+				rv = fill_data_field(field,
+					field->usage[0].hid,
+					senscol_sensor);
+				if (rv == -ENOMEM)
+					dev_err(&hdev->dev,
+						"%s(): Failed to allocated data field for usage %08X\n",
+						__func__,
+						field->usage[0].hid);
+			}
+		}
+
+		/* Add senscol_sensor */
+		rv = add_senscol_sensor(senscol_sensor);
+		dev_dbg(&hdev->dev,
+			"%s(): add_senscol_sensor() returned %d\n",
+			__func__, rv);
+#endif /*SENSCOL*/
+	}
+	return ret;
+
+err_free_names:
+err_stop_hw:
+	hid_hw_stop(hdev);
+err_free:
+	/*kfree(sd->hsdev);*/
+err_free_hub:
+	/*kfree(sd);*/
+
+	return ret;
+}
+
+static void ish_remove(struct hid_device *hdev)
+{
+	struct ish_data *data = hid_get_drvdata(hdev);
+	unsigned long flags;
+	int i;
+#if 1
+	uint32_t	hid_device_id;
+	struct hid_report *report;
+#endif
+
+	/*use max count since we can't know the remove order of hid devices*/
+	for (i = 0; i < ish_max_count; ++i)
+		if (hid_sens_hubs[i] == hdev) {
+			hid_sens_hubs[i] = NULL;
+			break;
+		}
+
+	hid_dbg(hdev, " hardware removed\n");
+	hid_hw_close(hdev);
+	hid_hw_stop(hdev);
+	spin_lock_irqsave(&data->lock, flags);
+	if (data->pending.status)
+		complete(&data->pending.ready);
+	spin_unlock_irqrestore(&data->lock, flags);
+
+#if 1
+	hid_device_id = data->ish_index;
+	list_for_each_entry(report,
+			&hdev->report_enum[HID_INPUT_REPORT].report_list,
+			list) {
+		remove_senscol_sensor(data->ish_index << 16 |
+			(report->id & 0xFFFF));
+	}
+#endif
+
+	hid_set_drvdata(hdev, NULL);
+	mutex_destroy(&data->mutex);
+	ish_cur_count--;
+#if 1
+	if (ish_cur_count == ish_max_count - 1)
+		senscol_reset_notify();
+#endif
+}
+
+static const struct hid_device_id ish_devices[] = {
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_INTEL_0,
+			USB_DEVICE_ID_INTEL_HID_SENSOR)},
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_INTEL_1,
+			USB_DEVICE_ID_INTEL_HID_SENSOR)},
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_STM_0,
+			USB_DEVICE_ID_STM_HID_SENSOR)},
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_STM_0,
+			USB_DEVICE_ID_STM_HID_SENSOR_1)},
+	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, HID_ANY_ID,
+		     HID_ANY_ID) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, ish_devices);
+
+static struct hid_driver ish_driver = {
+	.name = "ish-hid-dev",
+	.id_table = ish_devices,
+	.probe = ish_probe,
+	.remove = ish_remove,
+	.raw_event = ish_raw_event,
+	.report_fixup = ish_report_fixup,
+#ifdef CONFIG_PM
+	.suspend = ish_suspend,
+	.resume = ish_resume,
+	.reset_resume = ish_reset_resume,
+#endif /*CONFIG_PM*/
+};
+static int __init ish_driver_init(void)
+{
+	return hid_register_driver(&ish_driver);
+}
+late_initcall(ish_driver_init);
+
+static void __exit ish_driver_exit(void)
+{
+	hid_unregister_driver(&ish_driver);
+}
+module_exit(ish_driver_exit);
+
+MODULE_DESCRIPTION("ISH HID driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/misc/intel-ish/pci-ish.c b/drivers/misc/intel-ish/pci-ish.c
new file mode 100644
index 0000000..4e1bf46
--- /dev/null
+++ b/drivers/misc/intel-ish/pci-ish.c
@@ -0,0 +1,1154 @@
+/*
+ * PCI glue for HECI provider device (ISS) driver
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/aio.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <linux/ioctl.h>
+#include <linux/cdev.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/uuid.h>
+#include <linux/compat.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include "client.h"
+#include "heci_dev.h"
+#include "hw-ish.h"
+#include "hbm.h"
+#include "utils.h"
+#include <linux/miscdevice.h>
+
+#ifdef dev_dbg
+#undef dev_dbg
+#endif
+static void no_dev_dbg(void *v, char *s, ...)
+{
+}
+#define dev_dbg no_dev_dbg
+
+/*#define dev_dbg dev_err*/
+
+/*
+ *  heci driver strings
+ */
+static bool nomsi;
+module_param_named(nomsi, nomsi, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(nomsi, "don't use msi (default = false)");
+
+/* Currently this driver works as long as there is only a single HECI device. */
+static struct pci_dev *heci_pci_device;
+
+static const struct pci_device_id ish_pci_tbl[] = {
+	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x22D8)},
+	{0, }
+};
+
+MODULE_DEVICE_TABLE(pci, ish_pci_tbl);
+
+static DEFINE_MUTEX(heci_mutex);
+struct workqueue_struct *workqueue_for_init;
+
+/*global variables for suspend*/
+int	suspend_flag = 0;
+wait_queue_head_t	suspend_wait;
+
+#ifdef TIMER_POLLING
+/*
+ * DD -- ISS timer-polling workaround for H-FPGA
+ * (and other platforms that fail to deliver interrupts)
+ * NOTE: currently this will break (crash) if driver is unloaded
+ */
+
+#include <linux/timer.h>
+
+struct timer_list	ish_poll_timer;
+void	*timer_data;
+struct work_struct	ish_poll_work;
+
+void	ish_poll_work_fn(void *prm)
+{
+}
+
+void	ish_poll_timer_fn(unsigned long unused)
+{
+	irqreturn_t	rv;
+
+	rv = ish_irq_handler(0, timer_data);
+	/*ISH_DBG_PRINT(KERN_ALERT "%s(): ish_irq_handler() returned %08X\n",
+		__func__, rv);*/
+
+	/* Reschedule timer */
+	ish_poll_timer.expires += 2;
+	add_timer(&ish_poll_timer);
+}
+
+#endif	/* TIMER_POLLING */
+
+
+#if ISH_DEBUGGER
+
+struct ish_hw *hw_dbg;
+
+static int ishdbg_open(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static int ishdbg_release(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static char	dbg_resp_buf[2048];
+static int	resp_buf_read;
+
+static ssize_t ishdbg_read(struct file *file, char __user *ubuf, size_t length,
+	loff_t *offset)
+{
+	int rv;
+	int copy_len;
+
+	if (resp_buf_read)
+		return	0;	/* EOF */
+	copy_len = (length > strlen(dbg_resp_buf)) ?
+		strlen(dbg_resp_buf) : length;
+	rv = copy_to_user(ubuf, dbg_resp_buf, copy_len);
+	if (rv)
+		return  -EINVAL;
+	resp_buf_read = 1;
+	return  copy_len;
+}
+
+static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
+	size_t length, loff_t *offset)
+{
+	char    dbg_req_buf[768];
+	char    cmd[768];
+	int     rv;
+	unsigned     addr, count;
+	int	sscanf_match, i, cur_index;
+	uint32_t __iomem *reg_data;
+
+	if (length > sizeof(dbg_req_buf))
+		length = sizeof(dbg_req_buf);
+	rv = copy_from_user(dbg_req_buf, ubuf, length);
+	if (rv)
+		return  -EINVAL;
+	if (sscanf(dbg_req_buf, "%s ", cmd) != 1) {
+		dev_err(&heci_pci_device->dev, "[ish-dbg]) sscanf failed\n");
+		return  -EINVAL;
+	}
+	sscanf_match = sscanf(dbg_req_buf + 2, "%x %u", &addr, &count);
+	if (!strcmp(cmd, "d")) {
+		/* Dump values: d <addr> [count] */
+		if (sscanf_match == 1)
+			count = 1;
+		else if (sscanf_match != 2) {
+			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanf_match = %d\n",
+				sscanf_match);
+			return  -EINVAL;
+		}
+		if (addr % 4) {
+			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
+			return -EINVAL;
+		}
+		cur_index = 0;
+		for (i = 0; i < count; i++) {
+			reg_data = (uint32_t __iomem *)
+				((char *)hw_dbg->mem_addr + addr + i*4);
+			cur_index += scnprintf(dbg_resp_buf + cur_index,
+				sizeof(dbg_resp_buf) - cur_index, "%08X ",
+				readl(reg_data));
+		}
+		cur_index += scnprintf(dbg_resp_buf + cur_index,
+			sizeof(dbg_resp_buf) - cur_index, "\n");
+		resp_buf_read = 0;
+	} else if (!strcmp(cmd, "e")) {
+		/* Enter values e <addr> <value> */
+		if (sscanf_match != 2) {
+			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanfMatch = %d\n",
+				sscanf_match);
+			return  -EINVAL;
+		}
+		if (addr % 4) {
+			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
+			return -EINVAL;
+		}
+		reg_data = (uint32_t __iomem *)((char *)hw_dbg->mem_addr
+			+ addr);
+		writel(count, reg_data);
+		scnprintf(dbg_resp_buf, sizeof(dbg_resp_buf), "OK\n");
+		resp_buf_read = 0;
+	}
+
+	return  length;
+}
+
+static long ishdbg_ioctl(struct file *file, unsigned int cmd,
+	unsigned long data)
+{
+	return	0;
+}
+
+/*
+ * file operations structure will be used for heci char device.
+ */
+static const struct file_operations ishdbg_fops = {
+	.owner = THIS_MODULE,
+	.read = ishdbg_read,
+	.unlocked_ioctl = ishdbg_ioctl,
+	.open = ishdbg_open,
+	.release = ishdbg_release,
+	.write = ishdbg_write,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+static struct miscdevice  ishdbg_misc_device = {
+		.name = "ishdbg",
+		.fops = &ishdbg_fops,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+#endif /* ISH_DEBUGGER */
+
+#if ISH_LOG
+
+void delete_from_log(struct heci_device *dev, size_t min_chars)
+{
+	int i;
+	/* set log_tail to point at the last char to be deleted */
+	dev->log_tail = (dev->log_tail + min_chars - 1) % PRINT_BUFFER_SIZE;
+	for (i = dev->log_tail; dev->log_buffer[i] != '\n';
+			i = (i+1) % PRINT_BUFFER_SIZE)
+		;
+	dev->log_tail = (i+1) % PRINT_BUFFER_SIZE;
+}
+
+static void ish_print_log(struct heci_device *dev, char *format, ...)
+{
+	char tmp_buf[1024];
+	va_list args;
+	int length, i, full_space, free_space;
+	unsigned long	flags;
+	struct timeval tv;
+	struct timeval tv1, tv2, tv_diff;
+
+	do_gettimeofday(&tv1);
+	/* Fix for power-off path */
+	if (!heci_pci_device)
+		return;
+
+	do_gettimeofday(&tv);
+	i = scnprintf(tmp_buf, sizeof(tmp_buf), "[%ld.%06ld] ",
+		tv.tv_sec, tv.tv_usec);
+
+	va_start(args, format);
+	length = vsnprintf(tmp_buf + i, sizeof(tmp_buf)-i, format, args);
+	va_end(args);
+
+	length = length + i;
+	/* if the msg does not end with \n, add it */
+	if (tmp_buf[length-1] != '\n') {
+		tmp_buf[length] = '\n';
+		length++;
+	}
+
+	spin_lock_irqsave(&dev->log_spinlock, flags);
+
+	full_space = dev->log_head - dev->log_tail;
+	if (full_space < 0)
+		full_space = PRINT_BUFFER_SIZE + full_space;
+	free_space = PRINT_BUFFER_SIZE - full_space;
+
+	if (free_space <= length)
+		/*
+		 * not enougth space.
+		 * needed at least 1 empty char to recognize
+		 * whether buffer is full or empty
+		 */
+		delete_from_log(dev, (length - free_space) + 1);
+
+	if (dev->log_head + length <= PRINT_BUFFER_SIZE) {
+		memcpy(dev->log_buffer + dev->log_head, tmp_buf, length);
+	} else {
+		memcpy(dev->log_buffer + dev->log_head, tmp_buf,
+			PRINT_BUFFER_SIZE - dev->log_head);
+		memcpy(dev->log_buffer,
+			tmp_buf + PRINT_BUFFER_SIZE - dev->log_head,
+			length - (PRINT_BUFFER_SIZE - dev->log_head));
+	}
+	dev->log_head = (dev->log_head + length) % PRINT_BUFFER_SIZE;
+
+	spin_unlock_irqrestore(&dev->log_spinlock, flags);
+
+	do_gettimeofday(&tv2);
+	tv_diff.tv_sec = tv2.tv_sec - tv1.tv_sec;
+	tv_diff.tv_usec = tv2.tv_usec - tv1.tv_usec;
+	if (tv1.tv_usec > tv2.tv_usec) {
+		tv_diff.tv_usec += 1000000UL;
+		--tv_diff.tv_sec;
+	}
+	if (tv_diff.tv_sec > dev->max_log_sec ||
+			tv_diff.tv_sec == dev->max_log_sec &&
+			tv_diff.tv_usec > dev->max_log_usec) {
+		dev->max_log_sec = tv_diff.tv_sec;
+		dev->max_log_usec = tv_diff.tv_usec;
+	}
+}
+
+
+void	g_ish_print_log(char *fmt, ...)
+{
+	char tmp_buf[1024];
+	va_list args;
+	struct heci_device	*dev;
+
+	/* Fix for power-off path */
+	if (!heci_pci_device)
+		return;
+
+	dev = pci_get_drvdata(heci_pci_device);
+	va_start(args, fmt);
+	vsnprintf(tmp_buf, sizeof(tmp_buf), fmt, args);
+	va_end(args);
+	ish_print_log(dev, tmp_buf);
+}
+EXPORT_SYMBOL(g_ish_print_log);
+
+
+static ssize_t ish_read_log(struct heci_device *dev, char *buf, size_t size)
+{
+	int i, full_space, ret_val;
+
+	if (dev->log_head == dev->log_tail) /* log is empty */
+		return 0;
+
+	/* read size the minimum between full_space and the buffer size */
+	full_space = dev->log_head - dev->log_tail;
+	if (full_space < 0)
+		full_space = PRINT_BUFFER_SIZE + full_space;
+
+	if (full_space < size)
+		i = (dev->log_tail + full_space) % PRINT_BUFFER_SIZE;
+		/* log has less than 'size' bytes, i = dev->log_head */
+	else
+		i = (dev->log_tail + size) % PRINT_BUFFER_SIZE;
+	/* i is the last character to be readen */
+	i = (i-1) % PRINT_BUFFER_SIZE;
+
+	/* read from tail to last '\n' before i */
+	for (; dev->log_buffer[i] != '\n'; i = (i-1) % PRINT_BUFFER_SIZE)
+		;
+
+	if (dev->log_tail < i) {
+		memcpy(buf, dev->log_buffer + dev->log_tail,
+			i - dev->log_tail + 1);
+		ret_val = i - dev->log_tail + 1;
+	} else {
+		memcpy(buf, dev->log_buffer + dev->log_tail,
+			PRINT_BUFFER_SIZE - dev->log_tail);
+		memcpy(buf + PRINT_BUFFER_SIZE - dev->log_tail,
+			dev->log_buffer, i + 1);
+		ret_val = PRINT_BUFFER_SIZE - dev->log_tail + i + 1;
+	}
+	return ret_val;
+}
+
+static ssize_t ish_read_flush_log(struct heci_device *dev, char *buf,
+	size_t size)
+{
+	int ret;
+
+	ret = ish_read_log(dev, buf, size);
+	delete_from_log(dev, ret);
+	return ret;
+}
+
+/* show & store functions for both read and flush char devices*/
+ssize_t show_read(struct device *dev, struct device_attribute *dev_attr,
+	char *buf)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+	ssize_t retval;
+	unsigned long	flags;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+	spin_lock_irqsave(&heci_dev->log_spinlock, flags);
+	retval = ish_read_log(heci_dev, buf, PAGE_SIZE);
+	spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
+
+	return retval;
+}
+
+ssize_t store_read(struct device *dev, struct device_attribute *dev_attr,
+	const char *buf, size_t count)
+{
+	return count;
+}
+
+static struct device_attribute read_attr = {
+	.attr = {
+		.name = "ish_read_log",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_read,
+	.store = store_read
+};
+
+ssize_t show_flush(struct device *dev, struct device_attribute *dev_attr,
+	char *buf)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+	unsigned long	flags;
+	ssize_t retval;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+	spin_lock_irqsave(&heci_dev->log_spinlock, flags);
+	retval = ish_read_flush_log(heci_dev, buf, PAGE_SIZE);
+	spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
+
+	return retval;
+}
+
+ssize_t store_flush(struct device *dev, struct device_attribute *dev_attr,
+	const char *buf, size_t count)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+	unsigned long   flags;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+
+	if (!strncmp(buf, "empty", 5)) {
+		spin_lock_irqsave(&heci_dev->log_spinlock, flags);
+		heci_dev->log_tail = heci_dev->log_head;
+		spin_unlock_irqrestore(&heci_dev->log_spinlock, flags);
+	}
+	return count;
+}
+
+static struct device_attribute flush_attr = {
+	.attr = {
+		.name = "ish_flush_log",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_flush,
+	.store = store_flush
+};
+#else
+
+static void ish_print_log_nolog(struct heci_device *dev, char *format, ...)
+{
+}
+
+void	g_ish_print_log(char *fmt, ...)
+{
+}
+EXPORT_SYMBOL(g_ish_print_log);
+
+#endif /* ISH_LOG */
+
+ssize_t show_heci_dev_props(struct device *dev,
+	struct device_attribute *dev_attr, char *buf)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+	ssize_t	ret = -ENOENT;
+	unsigned	count;
+	unsigned long   flags, flags2, tx_flags, tx_free_flags;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+
+	if (!strcmp(dev_attr->attr.name, "heci_dev_state")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)heci_dev->dev_state);
+		ret = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "hbm_state")) {
+		scnprintf(buf, PAGE_SIZE, "%u\n",
+			(unsigned)heci_dev->hbm_state);
+		ret = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "fw_status")) {
+		scnprintf(buf, PAGE_SIZE, "%08X\n",
+			heci_dev->ops->get_fw_status(heci_dev));
+		ret = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "ipc_buf")) {
+		struct wr_msg_ctl_info *ipc_link, *ipc_link_next;
+
+		count = 0;
+		spin_lock_irqsave(&heci_dev->wr_processing_spinlock, flags);
+		list_for_each_entry_safe(ipc_link, ipc_link_next,
+			&heci_dev->wr_processing_list_head.link, link)
+			++count;
+		spin_unlock_irqrestore(&heci_dev->wr_processing_spinlock,
+			flags);
+		scnprintf(buf, PAGE_SIZE, "outstanding %u messages\n", count);
+		ret = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "host_clients")) {
+		struct heci_cl *cl, *next;
+		static const char * const cl_states[] = {"initializing",
+			"connecting", "connected", "disconnecting",
+			"disconnected"};
+		struct heci_cl_rb	*rb, *next_rb;
+		struct heci_cl_tx_ring	*tx_rb, *next_tx_rb;
+
+		scnprintf(buf, PAGE_SIZE, "Host clients:\n"
+				"------------\n");
+		spin_lock_irqsave(&heci_dev->device_lock, flags);
+		list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"id: %d\n",
+				cl->host_client_id);
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"state: %s\n", cl->state < 0 || cl->state >
+					HECI_CL_DISCONNECTED ?
+					"unknown" : cl_states[cl->state]);
+			if (cl->state == HECI_CL_CONNECTED) {
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"FW client id: %d\n", cl->me_client_id);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"RX ring size: %u\n", cl->rx_ring_size);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"TX ring size: %u\n", cl->tx_ring_size);
+
+				count = 0;
+				spin_lock_irqsave(&cl->in_process_spinlock,
+					flags2);
+				list_for_each_entry_safe(rb, next_rb,
+						&cl->in_process_list.list, list)
+					++count;
+				spin_unlock_irqrestore(&cl->in_process_spinlock,
+					flags2);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"RX in work: %u\n", count);
+
+				count = 0;
+				spin_lock_irqsave(&cl->in_process_spinlock,
+					flags2);
+				list_for_each_entry_safe(rb, next_rb,
+						&cl->free_rb_list.list, list)
+					++count;
+				spin_unlock_irqrestore(&cl->in_process_spinlock,
+					flags2);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"RX free: %u\n", count);
+
+				count = 0;
+				spin_lock_irqsave(&cl->tx_list_spinlock,
+					tx_flags);
+				list_for_each_entry_safe(tx_rb, next_tx_rb,
+						&cl->tx_list.list, list)
+					++count;
+				spin_unlock_irqrestore(&cl->tx_list_spinlock,
+					tx_flags);
+
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"TX pending: %u\n", count);
+				count = 0;
+				spin_lock_irqsave(
+					&cl->tx_free_list_spinlock,
+					tx_free_flags);
+				list_for_each_entry_safe(tx_rb, next_tx_rb,
+						&cl->tx_free_list.list, list)
+					++count;
+				spin_unlock_irqrestore(
+					&cl->tx_free_list_spinlock,
+					tx_free_flags);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"TX free: %u\n", count);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"FC: %u\n",
+					(unsigned)cl->heci_flow_ctrl_creds);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					 "out FC: %u\n",
+					(unsigned)cl->out_flow_ctrl_creds);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"Err snd msg: %u\n",
+					(unsigned)cl->err_send_msg);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"Err snd FC: %u\n",
+					(unsigned)cl->err_send_fc);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"Tx count: %u\n",
+					(unsigned)cl->send_msg_cnt);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"Rx count: %u\n",
+					(unsigned)cl->recv_msg_cnt);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"FC count: %u\n",
+					(unsigned)cl->heci_flow_ctrl_cnt);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"out FC cnt: %u\n",
+					(unsigned)cl->out_flow_ctrl_cnt);
+				scnprintf(buf + strlen(buf),
+					PAGE_SIZE - strlen(buf),
+					"Max FC delay: %lu.%06lu\n",
+					cl->max_fc_delay_sec,
+					cl->max_fc_delay_usec);
+			}
+		}
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC HID out FC: %u\n",
+			(unsigned)heci_dev->ipc_hid_out_fc);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC HID out FC count: %u\n",
+			(unsigned)heci_dev->ipc_hid_out_fc_cnt);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC HID in msg: %u\n",
+			(unsigned)heci_dev->ipc_hid_in_msg);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC HID in FC: %u\n",
+			(unsigned)heci_dev->ipc_hid_in_fc);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC HID in FC count: %u\n",
+			(unsigned)heci_dev->ipc_hid_in_fc_cnt);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC HID out msg: %u\n",
+			(unsigned)heci_dev->ipc_hid_out_msg);
+		spin_unlock_irqrestore(&heci_dev->device_lock, flags);
+		ret = strlen(buf);
+	} else if (!strcmp(dev_attr->attr.name, "stats")) {
+		scnprintf(buf, PAGE_SIZE, "Max. log time: %lu.%06lu\n",
+			heci_dev->max_log_sec, heci_dev->max_log_usec);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC Rx frames: %u; bytes: %llu\n",
+			heci_dev->ipc_rx_cnt, heci_dev->ipc_rx_bytes_cnt);
+		scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+			"IPC Tx frames: %u; bytes: %llu\n",
+			heci_dev->ipc_tx_cnt, heci_dev->ipc_tx_bytes_cnt);
+		ret = strlen(buf);
+	}
+
+	return	ret;
+}
+
+ssize_t store_heci_dev_props(struct device *dev,
+	struct device_attribute *dev_attr, const char *buf, size_t count)
+{
+	return	-EINVAL;
+}
+
+/* Debug interface to force flow-control to HID client */
+static unsigned	num_force_hid_fc;
+
+ssize_t show_force_hid_fc(struct device *dev, struct device_attribute *dev_attr,
+	char *buf)
+{
+	scnprintf(buf, PAGE_SIZE, "%u\n", num_force_hid_fc);
+	return	 strlen(buf);
+}
+
+ssize_t store_force_hid_fc(struct device *dev,
+	struct device_attribute *dev_attr, const char *buf, size_t count)
+{
+	struct pci_dev *pdev;
+	struct heci_device *heci_dev;
+	struct heci_cl *cl, *next;
+	unsigned long	tx_flags;
+
+	pdev = container_of(dev, struct pci_dev, dev);
+	heci_dev = pci_get_drvdata(pdev);
+
+	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
+		if (cl->host_client_id == 3 && cl->me_client_id == 5) {
+			dev_warn(dev, "HID FC %u, forced to 1\n",
+				(unsigned)cl->heci_flow_ctrl_creds);
+			cl->heci_flow_ctrl_creds = 1;
+			++num_force_hid_fc;
+			spin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);
+			if (!list_empty(&cl->tx_list.list)) {
+				/* start sending the first msg
+				 = the callback function */
+				spin_unlock_irqrestore(&cl->tx_list_spinlock,
+					tx_flags);
+				heci_cl_send_msg(heci_dev, cl);
+			} else {
+				spin_unlock_irqrestore(&cl->tx_list_spinlock,
+					tx_flags);
+			}
+			break;
+		}
+	}
+
+	return	 strlen(buf);
+}
+
+static struct device_attribute heci_dev_state_attr = {
+	.attr = {
+		.name = "heci_dev_state",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+static struct device_attribute hbm_state_attr = {
+	.attr = {
+		.name = "hbm_state",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+static struct device_attribute fw_status_attr = {
+	.attr = {
+		.name = "fw_status",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+static struct device_attribute host_clients_attr = {
+	.attr = {
+		.name = "host_clients",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+static struct device_attribute ipc_buf_attr = {
+	.attr = {
+		.name = "ipc_buf",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+static struct device_attribute stats_attr = {
+	.attr = {
+		.name = "stats",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_heci_dev_props,
+	.store = store_heci_dev_props
+};
+
+static struct device_attribute force_hid_fc_attr = {
+	.attr = {
+		.name = "force_hid_fc",
+		.mode = (S_IWUSR | S_IRUGO)
+	},
+	.show = show_force_hid_fc,
+	.store = store_force_hid_fc
+};
+/**********************************/
+
+struct my_work_t {
+	struct work_struct my_work;
+	struct heci_device *dev;
+};
+
+struct my_work_t *work;
+
+void workqueue_init_function(struct work_struct *work)
+{
+	struct heci_device *dev = ((struct my_work_t *)work)->dev;
+	int err;
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[pci driver] %s() in workqueue func, continue initialization process\n",
+		__func__);
+
+	pci_set_drvdata(dev->pdev, dev);
+/*	dev_dbg(&dev->pdev->dev, "heci: after pci_set_drvdata\n");*/
+
+	device_create_file(&dev->pdev->dev, &heci_dev_state_attr);
+	device_create_file(&dev->pdev->dev, &hbm_state_attr);
+	device_create_file(&dev->pdev->dev, &fw_status_attr);
+	device_create_file(&dev->pdev->dev, &host_clients_attr);
+	device_create_file(&dev->pdev->dev, &ipc_buf_attr);
+	device_create_file(&dev->pdev->dev, &stats_attr);
+	device_create_file(&dev->pdev->dev, &force_hid_fc_attr);
+
+#if ISH_LOG
+
+	device_create_file(&dev->pdev->dev, &read_attr);
+	device_create_file(&dev->pdev->dev, &flush_attr);
+
+	dev->log_head = dev->log_tail = 0;
+	dev->print_log = ish_print_log;
+
+	spin_lock_init(&dev->log_spinlock);
+
+	dev->print_log(dev,
+		"[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
+		__func__);
+	dev->print_log(dev, "[heci-ish] %s() running on %s revision [%02X]\n",
+		__func__,
+		dev->pdev->revision == REVISION_ID_CHT_A0 ||
+		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+		REVISION_ID_CHT_A0_SI ? "CHT Ax" :
+		dev->pdev->revision == REVISION_ID_CHT_B0 ||
+		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+		REVISION_ID_CHT_Bx_SI ? "CHT Bx" :
+		(dev->pdev->revision & REVISION_ID_SI_MASK) ==
+		REVISION_ID_CHT_Kx_SI ? "CHT Kx/Cx" : "Unknown",
+		dev->pdev->revision);
+#else
+	dev->print_log = ish_print_log_nolog;
+#endif /*ISH_LOG*/
+
+	init_waitqueue_head(&suspend_wait);
+
+	mutex_lock(&heci_mutex);
+	if (heci_start(dev)) {
+		dev_err(&dev->pdev->dev, "heci: Init hw failure.\n");
+		err = -ENODEV;
+		goto out_err;
+	}
+/*	dev_dbg(&dev->pdev->dev, "heci: after heci_start\n");*/
+
+	err = heci_register(dev);
+	if (err)
+		goto out_err;
+/*	dev_dbg(&dev->pdev->dev, "heci: after heci_register\n");*/
+
+
+	mutex_unlock(&heci_mutex);
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[pci driver] %s() in workqueue func, finished initialization process\n",
+		__func__);
+	kfree((void *)work);
+	return;
+
+out_err:
+	mutex_unlock(&heci_mutex);
+	kfree((void *)work);
+}
+
+/**********************************/
+
+/**
+ * ish_probe - Device Initialization Routine
+ *
+ * @pdev: PCI device structure
+ * @ent: entry in ish_pci_tbl
+ *
+ * returns 0 on success, <0 on failure.
+ */
+static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct heci_device *dev;
+	struct ish_hw *hw;
+	int err;
+	int	rv;
+
+	ISH_INFO_PRINT(
+	KERN_ERR "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
+		__func__);
+	ISH_INFO_PRINT(KERN_ERR
+		"[heci-ish] %s() running on %s revision [%02X]\n", __func__,
+		pdev->revision == REVISION_ID_CHT_A0 ||
+		(pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_A0_SI ? "CHT A0" :
+		pdev->revision == REVISION_ID_CHT_B0 ||
+		(pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Bx_SI ? "CHT B0" :
+		(pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Kx_SI ? "CHT Kx/Cx" :
+		(pdev->revision & REVISION_ID_SI_MASK) ==
+			REVISION_ID_CHT_Dx_SI ? "CHT Dx" : "Unknown",
+		pdev->revision);
+#if defined(SUPPORT_Ax_ONLY)
+	pdev->revision = REVISION_ID_CHT_A0;
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to A0\n",
+		__func__);
+#elif defined(SUPPORT_Bx_ONLY)
+	pdev->revision = REVISION_ID_CHT_B0;
+	ISH_DBG_PRINT(KERN_ALERT "[heci-ish] %s() revision forced to B0\n",
+		__func__);
+#endif
+	mutex_lock(&heci_mutex);
+	if (heci_pci_device) {
+		err = -EEXIST;
+		goto end;
+	}
+	/* enable pci dev */
+	err = pci_enable_device(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "heci: Failed to enable pci device.\n");
+		goto end;
+	}
+	/* set PCI host mastering  */
+	pci_set_master(pdev);
+	/* pci request regions for heci driver */
+	err = pci_request_regions(pdev, KBUILD_MODNAME);
+	if (err) {
+		dev_err(&pdev->dev, "heci: Failed to get pci regions.\n");
+		goto disable_device;
+	}
+
+	/* allocates and initializes the heci dev structure */
+	dev = ish_dev_init(pdev);
+	if (!dev) {
+		err = -ENOMEM;
+		goto release_regions;
+	}
+	hw = to_ish_hw(dev);
+
+	/* mapping  IO device memory */
+	hw->mem_addr = pci_iomap(pdev, 0, 0);
+	if (!hw->mem_addr) {
+		dev_err(&pdev->dev, "mapping I/O device memory failure.\n");
+		err = -ENOMEM;
+		goto free_device;
+	}
+
+#if ISH_DEBUGGER
+	ishdbg_misc_device.parent = &pdev->dev;
+	rv = misc_register(&ishdbg_misc_device);
+	if (rv)
+		dev_err(&pdev->dev,
+			"error starting ISS debugger (misc_register): %d\n",
+			rv);
+	hw_dbg = hw;
+#endif /*ISH_DEBUGGER*/
+
+	heci_pci_device = pdev;
+
+	/* request and enable interrupt   */
+#ifndef TIMER_POLLING
+	err = request_irq(pdev->irq, ish_irq_handler, IRQF_NO_SUSPEND,
+		KBUILD_MODNAME, dev);
+	if (err) {
+		dev_err(&pdev->dev, "heci: request_irq failure. irq = %d\n",
+			pdev->irq);
+		goto free_device;
+	}
+	dev_alert(&pdev->dev, "[heci-ish]: uses IRQ %d\n", pdev->irq);
+
+	/* Diagnostic output */
+	do {
+		uint32_t	msg_addr;
+		uint32_t	msg_data;
+
+		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_ADDRESS_LO,
+			&msg_addr);
+		pci_read_config_dword(pdev, pdev->msi_cap + PCI_MSI_DATA_32,
+			&msg_data);
+		ISH_DBG_PRINT(KERN_ALERT
+			"[heci-ish] %s(): assigned IRQ = %d, [PCI_MSI_ADDRESS_LO] = %08X [PCI_MSI_DATA_32] = %08X\n",
+			__func__, pdev->irq, msg_addr, msg_data);
+	} while (0);
+	/*********************/
+#else
+	/* Init & prepare workqueue */
+	INIT_WORK(&ish_poll_work, ish_poll_work_fn);
+
+	/* Create and schedule ISS polling timer */
+	init_timer(&ish_poll_timer);
+	ish_poll_timer.data = 0;
+	ish_poll_timer.function = ish_poll_timer_fn;
+	ish_poll_timer.expires = jiffies + 2;
+	timer_data = dev;
+	add_timer(&ish_poll_timer);
+
+	/* Init ISS polling timers workqueue */
+#endif
+
+	/* PCI quirk: prevent from being put into D3 state */
+	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
+
+
+	/*
+	 * 7/7/2014: in order to not stick Android boot,
+	 * from here & below needs to run in work queue
+	 * and here we should return success
+	 */
+	/****************************************************************/
+	work = kmalloc(sizeof(struct my_work_t), GFP_KERNEL);
+	if (!work)
+		return -ENOMEM;
+	work->dev = dev;
+	workqueue_for_init = create_workqueue("workqueue_for_init");
+	if (!workqueue_for_init) {
+		kfree(work);
+		return -ENOMEM;
+	}
+	INIT_WORK(&work->my_work, workqueue_init_function);
+	queue_work(workqueue_for_init, &work->my_work);
+
+	ISH_DBG_PRINT("[pci driver] %s() enqueue init_work function\n",
+		__func__);
+
+	mutex_unlock(&heci_mutex);
+	return 0;
+	/****************************************************************/
+
+free_device:
+	pci_iounmap(pdev, hw->mem_addr);
+	kfree(dev);
+release_regions:
+	pci_release_regions(pdev);
+disable_device:
+	pci_disable_device(pdev);
+end:
+	mutex_unlock(&heci_mutex);
+	dev_err(&pdev->dev, "heci: Driver initialization failed.\n");
+	return err;
+}
+
+/**
+ * heci_remove - Device Removal Routine
+ *
+ * @pdev: PCI device structure
+ *
+ * heci_remove is called by the PCI subsystem to alert the driver
+ * that it should release a PCI device.
+ */
+static void ish_remove(struct pci_dev *pdev)
+{
+	struct heci_device *dev;
+	struct ish_hw *hw;
+
+	/*
+	 * This happens during power-off/reboot and may be at the same time as
+	 * a lot of bi-directional communication happens
+	 */
+	if (heci_pci_device != pdev) {
+		dev_err(&pdev->dev, "heci: heci_pci_device != pdev\n");
+		return;
+	}
+
+	dev = pci_get_drvdata(pdev);
+	if (!dev) {
+		dev_err(&pdev->dev, "heci: dev =NULL\n");
+		return;
+	}
+
+	hw = to_ish_hw(dev);
+
+	/*
+	 * Set HECI device state to disabled.
+	 * Invalidate all other possible communication in both directions
+	 */
+	heci_device_disable(dev);
+
+	free_irq(pdev->irq, dev);
+	pci_disable_msi(pdev);
+	pci_iounmap(pdev, hw->mem_addr);
+	heci_pci_device = NULL;
+	if (workqueue_for_init) {
+		flush_workqueue(workqueue_for_init);
+		destroy_workqueue(workqueue_for_init);
+		workqueue_for_init = NULL;
+	}
+	pci_set_drvdata(pdev, NULL);
+	heci_deregister(dev);
+	kfree(dev);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+int ish_suspend(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct heci_device *dev = pci_get_drvdata(pdev);
+
+	enable_irq_wake(pdev->irq);
+
+	/* If previous suspend hasn't been asnwered then ISH is likely dead,
+	don't attempt nested notification */
+	if (suspend_flag)
+		return	0;
+
+	suspend_flag = 1;
+	send_suspend(dev);
+
+	/* 250 ms should be likely enough for live ISH to flush all IPC buf */
+	if (suspend_flag)
+		wait_event_timeout(suspend_wait, !suspend_flag, HZ / 4);
+	return 0;
+}
+
+int ish_resume(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct heci_device *dev = pci_get_drvdata(pdev);
+
+	disable_irq_wake(pdev->irq);
+	send_resume(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops ish_pm_ops = {
+	.suspend = ish_suspend,
+	.resume = ish_resume,
+};
+
+#define HECI_ISH_PM_OPS	(&ish_pm_ops)
+#else
+#define HECI_ISH_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+
+/*
+ *  PCI driver structure
+ */
+static struct pci_driver ish_driver = {
+	.name = KBUILD_MODNAME,
+	.id_table = ish_pci_tbl,
+	.probe = ish_probe,
+	.remove = ish_remove,
+	.shutdown = ish_remove,
+	.driver.pm = HECI_ISH_PM_OPS,
+};
+
+module_pci_driver(ish_driver);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel(R) Integrated Sensor Hub PCI Device Driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/misc/intel-ish/platform-config.h b/drivers/misc/intel-ish/platform-config.h
new file mode 100644
index 0000000..2696bac
--- /dev/null
+++ b/drivers/misc/intel-ish/platform-config.h
@@ -0,0 +1,125 @@
+/*
+ * ISS platform-specific definitions
+ *
+ * Copyright (c) 2012-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef PLATFORM_CONFIG__H
+#define PLATFORM_CONFIG__H
+
+/* Build ID string */
+#define	BUILD_ID	"0195-fix-recv-hid-hw-reset"
+
+#define	ISH_DEBUG	0
+#if ISH_DEBUG
+#define	ISH_DBG_PRINT	printk
+#else
+#define	ISH_DBG_PRINT	no_printk
+#endif
+
+#define	ISH_INFO	1
+#if ISH_INFO
+#define	ISH_INFO_PRINT	printk
+#else
+#define	ISH_INFO_PRINT	no_printk
+#endif
+
+#define ISH_LOG		0
+
+#if 0
+/*
+ * Define if running on VirtualBox -
+ * may solve imprecise timer emulation problems
+ */
+#define	HOST_VIRTUALBOX	1
+#endif
+
+#if 0
+/* Timer-polling workaround for DUTs with non-functional interrupts reporting */
+#define	TIMER_POLLING	1
+#endif
+
+#define	REVISION_ID_CHT_A0	0x6
+#define	REVISION_ID_CHT_A0_SI	0x0
+#define	REVISION_ID_CHT_Bx_SI	0x10
+#define	REVISION_ID_CHT_Kx_SI	0x20
+#define	REVISION_ID_CHT_Dx_SI	0x30
+#define	REVISION_ID_CHT_B0	0xB0
+
+#define	REVISION_ID_SI_MASK	0x70
+
+/* For buggy (pre-)silicon, select model rather than retrieve it */
+#if 0
+/* If defined, will support A0 only, will not check revision ID */
+#define	SUPPORT_Ax_ONLY	1
+
+#else
+
+#if  0
+/* If defined, will support B0 only, will not check revision ID */
+#define	SUPPORT_B0_ONLY	1
+#endif
+#endif
+
+#if defined(SUPPORT_A0_ONLY) && defined(SUPPORT_B0_ONLY)
+#error Only one of SUPPORT_A0_ONLY and SUPPORT_B0_ONLY may be defined
+#endif
+
+/* D3 RCR */
+#define	D3_RCR	1
+
+/* Define in order to force FW-initated reset */
+#define	FORCE_FW_INIT_RESET	1
+
+/* Include ISH register debugger */
+#define	ISH_DEBUGGER	1
+
+/* Debug mutex locking/unlocking */
+#define	DEBUG_LOCK	0
+
+#if DEBUG_LOCK
+
+static void	do_mutex_lock(void *m)
+{
+	mutex_lock(m);
+}
+
+static void	do_mutex_unlock(void *m)
+{
+	mutex_unlock(m);
+}
+
+#ifdef mutex_lock
+#undef mutex_lock
+#endif
+#ifdef mutex_unlock
+#undef mutex_unlock
+#endif
+
+#define mutex_lock(a) \
+	do {\
+		dev_warn(NULL, "%s:%d[%s] -- mutex_lock(%p)\n",	\
+			__FILE__, __LINE__, __func__, a);	\
+		do_mutex_lock(a);	\
+	} while (0)
+
+#define mutex_unlock(a) \
+	do {\
+		dev_warn(NULL, "%s:%d[%s] -- mutex_unlock(%p)\n",	\
+			__FILE__, __LINE__, __func__, a);	\
+		do_mutex_unlock(a);	\
+	} while (0)
+#endif /* DEBUG_LOCK */
+/*************************************/
+
+#endif /* PLATFORM_CONFIG__H*/
+
diff --git a/drivers/misc/intel-ish/senscol-core.c b/drivers/misc/intel-ish/senscol-core.c
new file mode 100644
index 0000000..8d20977
--- /dev/null
+++ b/drivers/misc/intel-ish/senscol-core.c
@@ -0,0 +1,1161 @@
+/*
+ * Sensor collection framework core
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/senscol/senscol-core.h>
+#include <linux/platform_device.h>
+#include <linux/kobject.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include "hid-strings-def.h"
+#include "platform-config.h"
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include "heci-hid.h"
+
+struct list_head	senscol_impl_list;
+struct list_head	senscol_sensors_list;
+spinlock_t	senscol_lock;
+spinlock_t	senscol_data_lock;
+uint8_t	*senscol_data_buf;
+unsigned	senscol_data_head, senscol_data_tail;
+int	flush_asked = 0;
+struct task_struct *user_task;
+
+static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
+	char *buf);
+
+static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size);
+
+static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
+
+static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
+
+static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
+	char *buf);
+
+static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size);
+
+static struct platform_device	*sc_pdev;
+
+wait_queue_head_t senscol_read_wait;
+
+void senscol_send_ready_event(void)
+{
+	if (waitqueue_active(&senscol_read_wait))
+		wake_up_interruptible(&senscol_read_wait);
+}
+EXPORT_SYMBOL(senscol_send_ready_event);
+
+int senscol_reset_notify(void)
+{
+
+	struct siginfo si;
+	int ret;
+
+	memset(&si, 0, sizeof(struct siginfo));
+	si.si_signo = SIGUSR1;
+	si.si_code = SI_USER;
+
+	if (user_task == NULL)
+		return -EINVAL;
+
+	ret = send_sig_info(SIGUSR1, &si, user_task);
+	return ret;
+}
+EXPORT_SYMBOL(senscol_reset_notify);
+
+const char *senscol_usage_to_name(unsigned usage)
+{
+	int i;
+
+	for (i = 0; code_msg_arr[i].msg && code_msg_arr[i].code != usage; i++)
+		;
+	return	code_msg_arr[i].msg;
+}
+EXPORT_SYMBOL(senscol_usage_to_name);
+
+
+unsigned senscol_name_to_usage(const char *name)
+{
+	int i;
+
+	for (i = 0; code_msg_arr[i].msg &&
+			strcmp(code_msg_arr[i].msg, name) != 0; ++i)
+		;
+	return	code_msg_arr[i].code;
+}
+EXPORT_SYMBOL(senscol_name_to_usage);
+
+
+const char	*senscol_get_modifier(unsigned modif)
+{
+	uint32_t to4bits = modif >> 0xC;
+	return	modifiers[to4bits];
+}
+EXPORT_SYMBOL(senscol_get_modifier);
+
+
+
+#if 0
+/*
+ * data kobject attributes and handlers
+ */
+
+static struct attribute	sc_data_defattr_event = {
+	.name = "event",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	*sc_data_defattrs[] = {
+	&sc_data_defattr_event,
+	NULL
+};
+#endif
+
+static void	sc_data_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
+		__func__, attr->name);
+	scnprintf(buf, PAGE_SIZE, "%s\n", attr->name);
+	return	strlen(buf);
+}
+
+static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT
+		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__,
+		attr->name, buf, (unsigned)size);
+	return	size;
+}
+
+const struct sysfs_ops	sc_data_sysfs_fops = {
+	.show = sc_data_show,
+	.store = sc_data_store
+};
+
+struct kobj_type	sc_data_kobj_type = {
+	.release = sc_data_release,
+	.sysfs_ops = &sc_data_sysfs_fops
+	/*.default_attrs = sc_data_defattrs*/
+};
+
+struct bin_attribute	sensors_data_binattr = {
+	.attr = {
+		.name = "sensors_data",
+		.mode = S_IRUGO
+	},
+	.size = 0,
+	.read = sensors_data_read,
+	.write = sensors_data_write
+};
+
+struct kobject	sc_data_kobj;
+
+/*****************************************/
+
+
+/*
+ * sensor_def kobject type and handlers
+ */
+static struct attribute	sc_sensdef_defattr_name = {
+	.name = "name",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_id = {
+	.name = "id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_sample_size = {
+	.name = "sample_size",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_flush = {
+	.name = "flush",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_get_sample = {
+	.name = "get_sample",
+	.mode = (S_IRUGO)
+};
+
+struct attribute	*sc_sensdef_defattrs[] = {
+	&sc_sensdef_defattr_name,
+	&sc_sensdef_defattr_id,
+	&sc_sensdef_defattr_usage_id,
+	&sc_sensdef_defattr_sample_size,
+	&sc_sensdef_defattr_flush,
+	&sc_sensdef_defattr_get_sample,
+	NULL
+};
+
+static void	sc_sensdef_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	ssize_t	rv;
+	struct sensor_def	*sensdef;
+	static char    tmp_buf[0x1000];
+	unsigned long flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
+		__func__, attr->name);
+	sensdef = container_of(kobj, struct sensor_def, kobj);
+	buf[0] = '\0';
+	if (!strcmp(attr->name, "id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->id);
+	else if (!strcmp(attr->name, "sample_size"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", sensdef->sample_size);
+	else if (!strcmp(attr->name, "usage_id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->usage_id);
+	else if (!strcmp(attr->name, "name"))
+		scnprintf(buf, PAGE_SIZE, "%s\n", sensdef->name);
+	else if (!strcmp(attr->name, "flush"))
+		/*if "sensdef" is activated in batch mode,
+		mark it as asking flush*/
+		if (sensdef->impl->batch_check(sensdef)) {
+			spin_lock_irqsave(&senscol_lock, flags);
+			flush_asked = 1;
+			sensdef->flush_req = 1;
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			sensdef->impl->get_sens_property(sensdef,
+				sensdef->properties, tmp_buf, 0x1000);
+			scnprintf(buf, PAGE_SIZE, "1\n");
+		} else {
+			uint32_t pseudo_event_id =
+				sensdef->id | PSEUSO_EVENT_BIT;
+			uint32_t pseudo_event_content = 0;
+			pseudo_event_content |= FLUSH_CMPL_BIT;
+			push_sample(pseudo_event_id, &pseudo_event_content);
+			scnprintf(buf, PAGE_SIZE, "0\n");
+		}
+	else if (!strcmp(attr->name, "get_sample")) {
+		rv = sensdef->impl->get_sample(sensdef);
+		/* The sample will arrive to hid "raw event" func,
+		and will be pushed to user via "push_sample" method */
+
+		scnprintf(buf, PAGE_SIZE, "%d\n", !rv);
+	}
+	rv = strlen(buf) + 1;
+	return	rv;
+}
+
+static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+const struct sysfs_ops	sc_sensdef_sysfs_fops = {
+	.show = sc_sensdef_show,
+	.store = sc_sensdef_store
+};
+
+struct kobj_type	sc_sensdef_kobj_type = {
+	.release = sc_sensdef_release,
+	.sysfs_ops = &sc_sensdef_sysfs_fops,
+	.default_attrs = sc_sensdef_defattrs
+};
+/*****************************************/
+
+/*
+ * kobject type for empty sub-directories
+ */
+static struct attribute	*sc_subdir_defattrs[] = {
+	NULL
+};
+
+static void	sc_subdir_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_subdir_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+
+static ssize_t	sc_subdir_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+
+const struct sysfs_ops	sc_subdir_sysfs_fops = {
+	.show = sc_subdir_show,
+	.store = sc_subdir_store
+};
+
+struct kobj_type	sc_subdir_kobj_type = {
+	.release = sc_subdir_release,
+	.sysfs_ops = &sc_subdir_sysfs_fops,
+	.default_attrs = sc_subdir_defattrs
+};
+/*****************************************/
+
+/*
+ * sensors 'data_field's kobject type
+ */
+static struct attribute	sc_datafield_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	sc_datafield_defattr_exp = {
+	.name = "exponent",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_len = {
+	.name = "length",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_unit = {
+	.name = "unit",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_index = {
+	.name = "index",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	sc_datafield_defattr_is_numeric = {
+	.name = "is_numeric",
+	.mode = (S_IRUGO)
+};
+
+struct attribute	*sc_datafield_defattrs[] = {
+	&sc_datafield_defattr_usage_id,
+	&sc_datafield_defattr_exp,
+	&sc_datafield_defattr_len,
+	&sc_datafield_defattr_unit,
+	&sc_datafield_defattr_index,
+	&sc_datafield_defattr_is_numeric,
+	NULL
+};
+
+static void	sc_datafield_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_datafield_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	ssize_t	rv;
+	struct data_field	*dfield;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
+		__func__, attr->name);
+	dfield = container_of(kobj, struct data_field, kobj);
+	if (!strcmp(attr->name, "usage_id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", (unsigned)dfield->usage_id);
+	else if (!strcmp(attr->name, "exponent"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->exp);
+	else if (!strcmp(attr->name, "length"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->len);
+	else if (!strcmp(attr->name, "unit"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->unit);
+	else if (!strcmp(attr->name, "index"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->index);
+	else if (!strcmp(attr->name, "is_numeric"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->is_numeric);
+
+	rv = strlen(buf) + 1;
+	return	rv;
+}
+
+static ssize_t	sc_datafield_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT
+		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__,
+		attr->name, buf, (unsigned)size);
+	return	-EINVAL;
+}
+
+const struct sysfs_ops	sc_datafield_sysfs_fops = {
+	.show = sc_datafield_show,
+	.store = sc_datafield_store
+};
+
+struct kobj_type	sc_datafield_kobj_type = {
+	.release = sc_datafield_release,
+	.sysfs_ops = &sc_datafield_sysfs_fops,
+	.default_attrs = sc_datafield_defattrs
+};
+/*****************************************/
+
+
+/*
+ * sensors 'properties' kobject type
+ */
+/*
+static struct attribute	sc_sensprop_defattr_unit = {
+	.name = "unit",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+*/
+static struct attribute sc_sensprop_defattr_value = {
+	.name = "value",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+
+static struct attribute sc_sensprop_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+
+struct attribute	*sc_sensprop_defattrs[] = {
+/*	&sc_sensprop_defattr_unit,*/
+	&sc_sensprop_defattr_value,
+	&sc_sensprop_defattr_usage_id,
+	NULL
+};
+
+static void	sc_sensprop_release(struct kobject *k)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+}
+
+static ssize_t	sc_sensprop_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	struct sens_property	*pfield;
+	struct sensor_def	*sensor;
+	int	rv = -EINVAL;
+
+	/*
+	 * We need "property_power_state" (=2), "property_reporting_state" (=2)
+	 * and "property_report_interval" (in ms?)
+	 */
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
+		__func__, attr->name);
+	pfield = container_of(kobj, struct sens_property, kobj);
+	sensor = pfield->sensor;
+
+	if (!strcmp(attr->name, "value"))
+		rv = sensor->impl->get_sens_property(sensor, pfield, buf,
+			0x1000);
+	else if (!strcmp(attr->name, "usage_id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", pfield->usage_id & 0xFFFF);
+	if (rv)
+		return	rv;
+	return	strlen(buf);
+}
+
+static ssize_t	sc_sensprop_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	struct sens_property	*pfield;
+	struct sensor_def	*sensor;
+	int	rv;
+
+	/*
+	 * TODO: stream down set property request and return size
+	 * upon successful completion or error code
+	 */
+	ISH_DBG_PRINT(KERN_ALERT
+		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n",
+		__func__, attr->name, buf, (unsigned)size);
+	if (strcmp(attr->name, "value"))
+		return -EINVAL;
+
+	pfield = container_of(kobj, struct sens_property, kobj);
+	sensor = pfield->sensor;
+	rv = sensor->impl->set_sens_property(sensor, pfield, buf);
+
+	if (rv)
+		return	rv;
+	return	size;
+}
+
+const struct sysfs_ops	sc_sensprop_sysfs_fops = {
+	.show = sc_sensprop_show,
+	.store = sc_sensprop_store
+};
+
+struct kobj_type	sc_sensprop_kobj_type = {
+	.release = sc_sensprop_release,
+	.sysfs_ops = &sc_sensprop_sysfs_fops,
+	.default_attrs = sc_sensprop_defattrs
+};
+/*****************************************/
+
+static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+{
+	size_t	count;
+	unsigned	cur;
+	struct senscol_sample	*sample;
+	unsigned long	flags;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+
+	if (size > PAGE_SIZE)
+		size = PAGE_SIZE;
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[senscol]: %s(): >>> offs=%u size=%u senscol_data_head=%u senscol_data_tail=%u\n",
+		__func__, (unsigned)offs, (unsigned)size,
+		(unsigned)senscol_data_head, (unsigned)senscol_data_tail);
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+
+	/*
+	 * Count how much we may copy, keeping whole samples.
+	 * Copy samples along the way
+	 */
+	count = 0;
+	cur = senscol_data_head;
+	while (cur != senscol_data_tail) {
+		sample = (struct senscol_sample *)(senscol_data_buf + cur);
+		if (count + sample->size > size)
+			break;
+		memcpy(buf + count, sample, sample->size);
+		count += sample->size;
+		cur += sample->size;
+		if (cur > SENSCOL_DATA_BUF_LAST)
+			cur = 0;
+	}
+	senscol_data_head = cur;
+
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	if (count) {
+		ISH_DBG_PRINT(KERN_ALERT
+			"[senscol]: <<< %s(): senscol_data_head=%u senscol_data_tail=%u\n",
+			__func__, senscol_data_head, senscol_data_tail);
+		ISH_DBG_PRINT(KERN_ALERT
+			"[senscol]: %s(): returning count=%u\n", __func__,
+			(unsigned)count);
+	}
+
+	return	count;
+}
+
+static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return	-EINVAL;
+}
+
+int	add_senscol_impl(struct senscol_impl *impl)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_add_tail(&impl->link, &senscol_impl_list);
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	0;
+}
+EXPORT_SYMBOL(add_senscol_impl);
+
+int	remove_senscol_impl(struct senscol_impl *impl)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_del(&impl->link);
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	0;
+}
+EXPORT_SYMBOL(remove_senscol_impl);
+
+/* Only allocates new sensor */
+struct sensor_def *alloc_senscol_sensor(void)
+{
+	struct sensor_def *sens;
+
+	sens = kzalloc(sizeof(struct sensor_def), GFP_KERNEL);
+	return	sens;
+}
+EXPORT_SYMBOL(alloc_senscol_sensor);
+
+/* Init sensor (don't call for initialized sensors */
+void	init_senscol_sensor(struct sensor_def *sensor)
+{
+	if (!sensor)
+		return;
+
+	memset(sensor, 0, sizeof(*sensor));
+	sensor->name = NULL;
+	sensor->friendly_name = NULL;
+	sensor->impl = NULL;
+	sensor->data_fields = NULL;
+	sensor->properties = NULL;
+}
+EXPORT_SYMBOL(init_senscol_sensor);
+
+int remove_senscol_sensor(uint32_t id)
+{
+	unsigned long	flags;
+	struct sensor_def	*sens, *next;
+	int i;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->id == id) {
+			list_del(&sens->link);
+			spin_unlock_irqrestore(&senscol_lock, flags);
+
+			for (i = 0; i < sens->num_properties; ++i)
+				if (sens->properties[i].name) {
+					kobject_put(&sens->properties[i].kobj);
+					kobject_del(&sens->properties[i].kobj);
+				}
+			kfree(sens->properties);
+			kobject_put(&sens->props_kobj);
+			kobject_del(&sens->props_kobj);
+
+			for (i = 0; i < sens->num_data_fields; ++i)
+				if (sens->data_fields[i].name) {
+					kobject_put(&sens->data_fields[i].kobj);
+					kobject_del(&sens->data_fields[i].kobj);
+				}
+			kfree(sens->data_fields);
+			kobject_put(&sens->data_fields_kobj);
+			kobject_del(&sens->data_fields_kobj);
+			kobject_put(&sens->kobj);
+			kobject_del(&sens->kobj);
+
+			kfree(sens);
+
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&senscol_lock, flags);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(remove_senscol_sensor);
+
+/*
+ * Exposed sensor via sysfs, structure may be static
+ *
+ * The caller is responsible for setting all meaningful fields
+ * (may call add_data_field() and add_sens_property() as needed)
+ * We'll consider hiding senscol framework-specific fields
+ * into opaque structures
+ */
+
+int	add_senscol_sensor(struct sensor_def *sensor)
+{
+	unsigned long	flags;
+	char	sensor_name[256];	/* Enough for name "sensor_<NN>_def",
+					 * if convention changes array size
+					 * should be reviewed */
+	int	i;
+	int	rv;
+	int	j;
+
+	if (!sensor->name || !sensor->impl || !sensor->usage_id || !sensor->id)
+		return	-EINVAL;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_add_tail(&sensor->link, &senscol_sensors_list);
+	spin_unlock_irqrestore(&senscol_lock, flags);
+
+	/*
+	 * Create sysfs entries for this sensor
+	 */
+
+	/* Init and add sensor_def kobject */
+	snprintf(sensor_name, sizeof(sensor_name), "sensor_%X_def", sensor->id);
+	rv = kobject_init_and_add(&sensor->kobj, &sc_sensdef_kobj_type,
+		&sc_pdev->dev.kobj, sensor_name);
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): kobject_init_and_add() for 'data' returned %d\n",
+		__func__, rv);
+	if (rv) {
+		rv = -EFAULT;
+err_ret:
+		kobject_put(&sensor->kobj);
+		kobject_del(&sensor->kobj);
+		return	rv;
+	}
+
+/*
+ * Special attribute "friendly_name" is retired in favor
+ * of generic property "property_friendly_name"
+ */
+#if 0
+	/* If freiendly_name is given, add such attribute */
+	memset(&attr, 0, sizeof(struct attribute));
+	attr.name = "friendly_name";
+	attr.mode = S_IRUGO;
+	rv = sysfs_create_file(&sensor->kobj, &attr);
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): sysfs_create_file() for 'friendly_name' returned %d\n",
+		__func__, rv);
+#endif
+
+	/*
+	 * Create kobjects without attributes for
+	 * sensor_<NN>_def/data_fields and sensor_<NN>/properties
+	 */
+	rv = kobject_init_and_add(&sensor->data_fields_kobj,
+		&sc_subdir_kobj_type, &sensor->kobj, "data_fields");
+	if (rv) {
+		rv = -EFAULT;
+err_ret2:
+		kobject_put(&sensor->data_fields_kobj);
+		kobject_del(&sensor->data_fields_kobj);
+		goto	err_ret;
+	}
+
+	rv = kobject_init_and_add(&sensor->props_kobj, &sc_subdir_kobj_type,
+		&sensor->kobj, "properties");
+	if (rv) {
+		rv = -EFAULT;
+err_ret3:
+		kobject_put(&sensor->props_kobj);
+		kobject_del(&sensor->props_kobj);
+		goto	err_ret2;
+	}
+
+	/*
+	 * Create kobjects for data_fields
+	 */
+	for (i = 0; i < sensor->num_data_fields; ++i)
+		if (sensor->data_fields[i].name)
+			for (j = i-1; j >= 0; --j)	/*use index as a temp
+							variable*/
+				if (sensor->data_fields[j].name &&
+					!strcmp(sensor->data_fields[i].name,
+						sensor->data_fields[j].name)) {
+					if (!sensor->data_fields[j].index)
+						sensor->data_fields[j].index++;
+					sensor->data_fields[i].index =
+						sensor->data_fields[j].index
+									+ 1;
+					break;
+				}
+
+	for (i = 0; i < sensor->num_data_fields; ++i) {
+		if (sensor->data_fields[i].name) {
+			if (sensor->data_fields[i].index) {
+				char *p = kasprintf(GFP_KERNEL, "%s#%d",
+					sensor->data_fields[i].name,
+					sensor->data_fields[i].index-1);
+				kfree(sensor->data_fields[i].name);
+				sensor->data_fields[i].name = p;
+			}
+
+			/* Mark index */
+			sensor->data_fields[i].index = i;
+
+			rv = kobject_init_and_add(&sensor->data_fields[i].kobj,
+				&sc_datafield_kobj_type,
+				&sensor->data_fields_kobj,
+				sensor->data_fields[i].name);
+			ISH_DBG_PRINT(KERN_ALERT
+				"%s(): kobject_init_and_add() for data_field '%s' returned %d\n",
+				__func__, sensor->data_fields[i].name, rv);
+		}
+	}
+	ISH_DBG_PRINT(KERN_ALERT "%s(): sample_size=%u\n",
+		__func__, sensor->sample_size);
+
+	/*
+	 * Create kobjects for properties
+	 */
+	for (i = 0; i < sensor->num_properties; ++i) {
+		if (sensor->properties[i].name) {
+			rv = kobject_init_and_add(&sensor->properties[i].kobj,
+				&sc_sensprop_kobj_type, &sensor->props_kobj,
+				sensor->properties[i].name);
+			ISH_DBG_PRINT(KERN_ALERT
+				"%s(): kobject_init_and_add() for property '%s' returned %d\n",
+				__func__, sensor->properties[i].name, rv);
+		}
+	}
+
+	/* Sample size should be set by the caller to size of raw data */
+	sensor->sample_size += offsetof(struct senscol_sample, data);
+
+	return	0;
+}
+EXPORT_SYMBOL(add_senscol_sensor);
+
+struct sensor_def	*get_senscol_sensor_by_name(const char *name)
+{
+	struct sensor_def	*sens, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (!strcmp(sens->name, name)) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return	sens;
+		}
+	}
+
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	NULL;
+}
+EXPORT_SYMBOL(get_senscol_sensor_by_name);
+
+struct sensor_def	*get_senscol_sensor_by_id(uint32_t id)
+{
+	struct sensor_def	*sens, *next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->id == id) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return	sens;
+		}
+	}
+
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return	NULL;
+}
+EXPORT_SYMBOL(get_senscol_sensor_by_id);
+
+/* Add data field to existing sensor */
+int	add_data_field(struct sensor_def *sensor, struct data_field *data)
+{
+	struct data_field	*temp;
+
+	temp = krealloc(sensor->data_fields,
+		(sensor->num_data_fields + 1) * sizeof(struct data_field),
+		GFP_KERNEL);
+	if (!temp)
+		return	-ENOMEM;
+
+	data->sensor = sensor;
+	memcpy(&temp[sensor->num_data_fields++], data,
+		sizeof(struct data_field));
+	sensor->data_fields = temp;
+	return	0;
+}
+EXPORT_SYMBOL(add_data_field);
+
+/* Add property to existing sensor */
+int	add_sens_property(struct sensor_def *sensor, struct sens_property *prop)
+{
+	struct sens_property	*temp;
+
+	temp = krealloc(sensor->properties,
+		(sensor->num_properties + 1) * sizeof(struct sens_property),
+		GFP_KERNEL);
+	if (!temp)
+		return	-ENOMEM;
+
+	prop->sensor = sensor;		/* The needed backlink */
+	memcpy(&temp[sensor->num_properties++], prop,
+		sizeof(struct sens_property));
+	sensor->properties = temp;
+	return	0;
+}
+EXPORT_SYMBOL(add_sens_property);
+
+/*
+ * Push data sample in upstream buffer towards user-mode.
+ * Sample's size is determined from the structure
+ *
+ * Samples are queued is a simple FIFO binary buffer with head and tail
+ * pointers.
+ * Additional fields if wanted to be communicated to user mode can be defined
+ *
+ * Returns 0 on success, negative error code on error
+ */
+int	push_sample(uint32_t id, void *sample)
+{
+	struct sensor_def	*sensor;
+	unsigned long flags;
+	unsigned char	sample_buf[1024];
+	struct senscol_sample	*p_sample = (struct senscol_sample *)sample_buf;
+	struct sensor_def pseudo_event_sensor;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	g_ish_print_log("%s() DATA from sensor #%x\n", __func__, id);
+
+	if (!senscol_data_buf)
+		return	-ENOMEM;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): senscol_data_buf=%p\n",
+		__func__, senscol_data_buf);
+
+	if (id & PSEUSO_EVENT_BIT) {
+		pseudo_event_sensor.sample_size = sizeof(uint32_t) +
+			offsetof(struct senscol_sample, data);
+		sensor = &pseudo_event_sensor;
+	} else
+		sensor = get_senscol_sensor_by_id(id);
+
+	if (!sensor)
+		return	-ENODEV;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): sensor=%p\n",
+		__func__, sensor);
+	ISH_DBG_PRINT(KERN_ALERT
+		"[senscol]: %s(): senscol_data_head=%u senscol_data_tail=%u sample_size=%u\n",
+		__func__, senscol_data_head, senscol_data_tail,
+		sensor->sample_size);
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+
+	/*
+	 * TBD: when buffer overflows we may choose to drop
+	 * the new data or oldest data.
+	 */
+	/* Here we drop the new data */
+	if (senscol_data_head != senscol_data_tail &&
+			(senscol_data_head - senscol_data_tail) %
+			SENSCOL_DATA_BUF_SIZE <= sensor->sample_size) {
+		spin_unlock_irqrestore(&senscol_data_lock, flags);
+		ISH_DBG_PRINT(KERN_ALERT
+			"[senscol]: %s(): dropping sample, senscol_data_head=%u senscol_data_tail=%u sample size=%u\n",
+			__func__, senscol_data_head, senscol_data_tail,
+			sensor->sample_size);
+		return	-ENOMEM;
+	}
+
+	p_sample->id = id;
+	p_sample->size = sensor->sample_size;
+	memcpy(p_sample->data, sample,
+		sensor->sample_size - offsetof(struct senscol_sample, data));
+
+	memcpy(senscol_data_buf + senscol_data_tail, p_sample, p_sample->size);
+	senscol_data_tail += sensor->sample_size;
+	if (senscol_data_tail > SENSCOL_DATA_BUF_LAST)
+		senscol_data_tail = 0;
+
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	/* Fire event through "data/event" */
+	ISH_DBG_PRINT(KERN_ALERT
+		"[senscol] %s(): firing data-ready event senscol_data_head=%u senscol_data_tail=%u id=%08X sample_size=%u\n",
+		__func__, senscol_data_head, senscol_data_tail, p_sample->id,
+		sensor->sample_size);
+
+	if (waitqueue_active(&senscol_read_wait))
+		wake_up_interruptible(&senscol_read_wait);
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():--- 0\n", __func__);
+	return	0;
+}
+EXPORT_SYMBOL(push_sample);
+
+
+static int senscol_open(struct inode *inode, struct file *file)
+{
+	user_task = current;
+	return	0;
+}
+
+static int senscol_release(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static ssize_t senscol_read(struct file *file, char __user *ubuf,
+	size_t length, loff_t *offset)
+{
+	return	length;
+}
+
+static ssize_t senscol_write(struct file *file, const char __user *ubuf,
+	size_t length, loff_t *offset)
+{
+	return	length;
+}
+
+static long senscol_ioctl(struct file *file, unsigned int cmd,
+	unsigned long data)
+{
+	return	0;
+}
+
+static unsigned int senscol_poll(struct file *file, poll_table *wait)
+{
+	unsigned int mask = 0;
+	unsigned long   flags;
+	int	rd_ready = 0;
+
+	poll_wait(file, &senscol_read_wait, wait);
+
+	/* If read buffer is empty, wait again on senscol_read_wait */
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+	rd_ready = (senscol_data_head != senscol_data_tail);
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	if (rd_ready)
+		mask |= (POLLIN | POLLRDNORM);
+	/*mask |= DEFAULT_POLLMASK|POLLERR|POLLPRI;*/
+	return	mask;
+}
+
+/* flush callback */
+void senscol_flush_cb(void)
+{
+	struct sensor_def	*sens, *next;
+	unsigned long   flags;
+	uint32_t pseudo_event_id;
+	uint32_t pseudo_event_content = 0;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	if (!flush_asked) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return;
+	}
+
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->flush_req) {
+			sens->flush_req = 0;
+			pseudo_event_id = sens->id | PSEUSO_EVENT_BIT;
+			pseudo_event_content |= FLUSH_CMPL_BIT;
+
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			push_sample(pseudo_event_id, &pseudo_event_content);
+			spin_lock_irqsave(&senscol_lock, flags);
+		}
+	}
+	flush_asked = 0;
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return;
+}
+
+
+/*
+ * file operations structure will be used for heci char device.
+ */
+static const struct file_operations senscol_fops = {
+	.owner = THIS_MODULE,
+	.read = senscol_read,
+	.unlocked_ioctl = senscol_ioctl,
+	.open = senscol_open,
+	.release = senscol_release,
+	.write = senscol_write,
+	.poll = senscol_poll,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+static struct miscdevice  senscol_misc_device = {
+		.name = "sensor-collection",
+		.fops = &senscol_fops,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+
+static int __init senscol_init(void)
+{
+	int	rv;
+
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+
+	INIT_LIST_HEAD(&senscol_impl_list);
+	INIT_LIST_HEAD(&senscol_sensors_list);
+	spin_lock_init(&senscol_lock);
+	spin_lock_init(&senscol_data_lock);
+	init_waitqueue_head(&senscol_read_wait);
+
+	/* Init data buffer */
+	senscol_data_buf = kmalloc(SENSCOL_DATA_BUF_SIZE, GFP_KERNEL);
+	if (!senscol_data_buf)
+		return	-ENOMEM;
+	ISH_DBG_PRINT(KERN_ALERT
+		"[senscol] %s(): allocated senscol_data_buf of size %u\n",
+		__func__, SENSCOL_DATA_BUF_SIZE);
+
+	senscol_data_head = 0;
+	senscol_data_tail = 0;
+
+	/* Create sensor_collection platform device and default sysfs entries */
+	sc_pdev = platform_device_register_simple("sensor_collection", -1,
+		NULL, 0);
+	if (IS_ERR(sc_pdev)) {
+		ISH_DBG_PRINT(KERN_ERR
+			"%s(): failed to create platform device sensor_collection\n",
+			__func__);
+		kfree(senscol_data_buf);
+		return	-ENODEV;
+	}
+
+	senscol_misc_device.parent = &sc_pdev->dev;
+	rv = misc_register(&senscol_misc_device);
+	if (rv)
+		return	rv;
+
+	rv = kobject_init_and_add(&sc_data_kobj, &sc_data_kobj_type,
+		&sc_pdev->dev.kobj, "data");
+	ISH_DBG_PRINT(KERN_ALERT
+		"%s(): kobject_init_and_add() for 'data' returned %d\n",
+		__func__, rv);
+
+	rv = sysfs_create_bin_file(&sc_data_kobj, &sensors_data_binattr);
+	if (rv)
+		ISH_DBG_PRINT(KERN_ERR
+			"%s(): sysfs_create_bin_file() for 'sensors_data' returned %d\n",
+			__func__, rv);
+
+	register_flush_cb(senscol_flush_cb);
+
+	return	0;
+}
+
+static void __exit senscol_exit(void)
+{
+	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	kfree(senscol_data_buf);
+}
+
+
+module_init(senscol_init);
+module_exit(senscol_exit);
+
+MODULE_DESCRIPTION("Sensor Collection framework core");
+MODULE_AUTHOR("Intel Corporation");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/intel-ish/utils.h b/drivers/misc/intel-ish/utils.h
new file mode 100644
index 0000000..04b814e
--- /dev/null
+++ b/drivers/misc/intel-ish/utils.h
@@ -0,0 +1,65 @@
+/*
+ * Utility macros of ISS
+ *
+ * Copyright (c) 2014-2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+#ifndef UTILS__H
+ #define UTILS__H
+
+#define	WAIT_FOR_SEND_SLICE	(HZ / 10)
+#define	WAIT_FOR_CONNECT_SLICE	(HZ / 10)
+
+/*
+ * Waits for specified event when a thread that triggers event can't signal
+ * Also, waits *at_least* `timeinc` after condition is satisfied
+ */
+#define	timed_wait_for(timeinc, condition) \
+	do { \
+		int completed = 0; \
+		do { \
+			unsigned long	j; \
+			int	done = 0; \
+\
+			completed = (condition); \
+			for (j = jiffies, done = 0; !done; ) { \
+				schedule_timeout(timeinc); \
+				if (time_is_before_eq_jiffies(j + timeinc)) \
+					done = 1; \
+			} \
+		} while (!(completed)); \
+	} while (0)
+
+
+/*
+ * Waits for specified event when a thread that triggers event
+ * can't signal with timeout (use whenever we may hang)
+ */
+#define	timed_wait_for_timeout(timeinc, condition, timeout) \
+	do { \
+		int	t = timeout; \
+		do { \
+			unsigned long	j; \
+			int	done = 0; \
+\
+			for (j = jiffies, done = 0; !done; ) { \
+				schedule_timeout(timeinc); \
+				if (time_is_before_eq_jiffies(j + timeinc)) \
+					done = 1; \
+			} \
+			t -= timeinc; \
+			if (t <= 0) \
+				break; \
+		} while (!(condition)); \
+	} while (0)
+
+#endif /* UTILS__H */
+
-- 
1.9.1

