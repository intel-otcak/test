From 6562383bacea6a3c78e406e31d68a63a172858ae Mon Sep 17 00:00:00 2001
From: "Sodhi, VunnyX" <vunnyx.sodhi@intel.com>
Date: Tue, 6 Jan 2015 17:06:24 +0530
Subject: [PATCH 14/15] ASoC: Intel: [CHT-CR]: Enable Cherrytrail CR-TI Codec

Issue: GMINL-6292

Added Machine Driver for Cherrytrail CR Platform along
with Texas Instruments TLV320AIC31XX Audio codec.

Change-Id: I6e31a8bf2d714d8284637412e6d7ed79b8b0c525
Signed-off-by: Praveen Diwakar <praveen.diwakar@intel.com>
Signed-off-by: Bhakte, GurudattaX <gurudattax.bhakte@intel.com>
Signed-off-by: Fabien Marotte <fabien.marotte@intel.com>
---
 drivers/acpi/acpi_platform.c           |    1 +
 include/acpi/acpi_bus.h                |    1 +
 sound/soc/codecs/Kconfig               |    3 +
 sound/soc/codecs/Makefile              |    4 +-
 sound/soc/codecs/tlv320aic31xx.c       | 1626 ++++++++++++++++++++++++++++++++
 sound/soc/codecs/tlv320aic31xx.h       |  403 ++++++++
 sound/soc/intel/Kconfig                |    5 +-
 sound/soc/intel/board/Makefile         |    3 +-
 sound/soc/intel/board/cht_cr_aic3100.c | 1066 +++++++++++++++++++++
 sound/soc/intel/sst/sst.c              |   34 +-
 10 files changed, 3136 insertions(+), 10 deletions(-)
 create mode 100644 sound/soc/codecs/tlv320aic31xx.c
 create mode 100644 sound/soc/codecs/tlv320aic31xx.h
 create mode 100644 sound/soc/intel/board/cht_cr_aic3100.c

diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 0d7f799..a399a9f 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -50,6 +50,7 @@ static const struct acpi_device_id acpi_platform_device_ids[] = {
 	{ "LPE0F28", 0 },
 	{ "80860F28", 0 },
 	{ "LPE0F281", 0 },
+	{ "10TI3100", 0 },
 	{ "TIMC0F28", 0 },
 	{ "DMA0F28", 0 },
 	{ "ADMA0F28", 0 },
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index 23549be..af643bf 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -466,6 +466,7 @@ struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
 					   u64 address, bool check_children);
 int acpi_is_root_bridge(acpi_handle);
 struct acpi_pci_root *acpi_pci_find_root(acpi_handle handle);
+#define DEVICE_ACPI_HANDLE(dev) ((acpi_handle)ACPI_HANDLE(dev))
 
 int acpi_enable_wakeup_device_power(struct acpi_device *dev, int state);
 int acpi_disable_wakeup_device_power(struct acpi_device *dev);
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index e8bb018..24fc38c 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -345,6 +345,9 @@ config SND_SOC_RT5651
 config SND_SOC_RT5672
 	tristate
 
+config SND_SOC_TLV320AIC31XX
+	tristate
+
 #Freescale sgtl5000 codec
 config SND_SOC_SGTL5000
 	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 4c69368..218ec53 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -71,6 +71,7 @@ snd-soc-tas5086-objs := tas5086.o
 snd-soc-tlv320aic23-objs := tlv320aic23.o
 snd-soc-tlv320aic26-objs := tlv320aic26.o
 snd-soc-tlv320aic3x-objs := tlv320aic3x.o
+snd-soc-tlv320aic31xx-objs := tlv320aic31xx.o
 snd-soc-tlv320aic32x4-objs := tlv320aic32x4.o
 snd-soc-tlv320dac33-objs := tlv320dac33.o
 snd-soc-twl4030-objs := twl4030.o
@@ -208,7 +209,8 @@ obj-$(CONFIG_SND_SOC_TAS5086)	+= snd-soc-tas5086.o
 obj-$(CONFIG_SND_SOC_TLV320AIC23)	+= snd-soc-tlv320aic23.o
 obj-$(CONFIG_SND_SOC_TLV320AIC26)	+= snd-soc-tlv320aic26.o
 obj-$(CONFIG_SND_SOC_TLV320AIC3X)	+= snd-soc-tlv320aic3x.o
-obj-$(CONFIG_SND_SOC_TLV320AIC32X4)     += snd-soc-tlv320aic32x4.o
+obj-$(CONFIG_SND_SOC_TLV320AIC32X4)	+= snd-soc-tlv320aic32x4.o
+obj-$(CONFIG_SND_SOC_TLV320AIC31XX)	+= snd-soc-tlv320aic31xx.o
 obj-$(CONFIG_SND_SOC_TLV320DAC33)	+= snd-soc-tlv320dac33.o
 obj-$(CONFIG_SND_SOC_TWL4030)	+= snd-soc-twl4030.o
 obj-$(CONFIG_SND_SOC_TWL6040)	+= snd-soc-twl6040.o
diff --git a/sound/soc/codecs/tlv320aic31xx.c b/sound/soc/codecs/tlv320aic31xx.c
new file mode 100644
index 0000000..579cd45
--- /dev/null
+++ b/sound/soc/codecs/tlv320aic31xx.c
@@ -0,0 +1,1626 @@
+/*
+ * linux/sound/soc/codecs/tlv320aic31xx.c
+ *
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ *
+ * Based on sound/soc/codecs/tlv320aic326x.c
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED AS IS AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ * The TLV320AIC31xx series of audio codec is a low-power, highly integrated
+ * high performance codec which provides a stereo DAC, a mono ADC,
+ * and mono/stereo Class-D speaker driver.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+#include <linux/acpi.h>
+#include <asm/div64.h>
+#include <sound/jack.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "tlv320aic31xx.h"
+
+static const struct regmap_range_cfg aic31xx_ranges[] = {
+{
+	.name = "codec-regmap",
+	.range_min = 128,
+	.range_max = 13 * 128,
+	.selector_reg = 0,
+	.selector_mask = 0xff,
+	.selector_shift = 0,
+	.window_start = 0,
+	.window_len = 128,
+},
+};
+
+struct regmap_config aicxxx_i2c_regmap = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+	.ranges = aic31xx_ranges,
+	.num_ranges = ARRAY_SIZE(aic31xx_ranges),
+	.max_register =  13 * 128,
+};
+struct aic31xx_driver_data aic31xx_acpi_data = {
+	.acpi_device = 1,
+};
+struct aic31xx_driver_data aic31xx_i2c_data = {
+	.acpi_device = 0,
+};
+
+/* Custom micbias widget since mic bias has two bits */
+#define SND_SOC_DAPM_MICBIASCUSTOM(wname, wreg, wshift, wevent, wflags) \
+{	.id = snd_soc_dapm_micbias, .name = wname, .reg = wreg,	\
+	.shift = wshift, .event = wevent, \
+	.event_flags = wflags}
+
+static int aic31xx_hw_params(struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *params,
+			struct snd_soc_dai *dai);
+
+static int aic31xx_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			unsigned int fmt);
+
+static int aic31xx_set_bias_level(struct snd_soc_codec *codec,
+		enum snd_soc_bias_level level);
+static int aic31xx_set_sysclk(struct snd_soc_codec *codec,
+		int clk_id, int source, unsigned int freq, int dir);
+
+static const struct aic31xx_rate_divs aic31xx_divs[] = {
+/* 8k rate */
+	{AIC31XX_FREQ_25000000, 8000, 2, 6, 5536, 128, 4, 20, 128, 4, 20, 4},
+
+/* 11.025k rate */
+	{AIC31XX_FREQ_25000000, 11025, 2, 7, 7738, 128, 3, 20, 128, 3, 20, 4},
+
+/* 16k rate */
+	{AIC31XX_FREQ_25000000, 16000, 2, 6, 5536, 128, 4, 10, 128, 4, 10, 4},
+
+/* 22.05k rate */
+	{AIC31XX_FREQ_25000000, 22050, 2, 7, 7738, 128, 3, 10, 128, 3, 10, 4},
+/* 32k rate */
+	{AIC31XX_FREQ_25000000, 32000, 2, 6, 5536, 128, 4, 5, 128, 4, 5, 4},
+
+/* 44.1k rate */
+	{AIC31XX_FREQ_25000000, 44100, 2, 6, 5536, 128, 4, 5, 128, 4, 5, 4},
+
+/* 48k rate */
+	{AIC31XX_FREQ_25000000, 48000, 2, 7, 3728, 128, 3, 5, 128, 3, 5, 4},
+};
+
+/*
+ * Global Variables introduced to reduce Headphone Analog Volume Control
+ * Registers at run-time
+ */
+static const char *const micbias_voltage[] = {"off", "2 V", "2.5 V", "AVDD"};
+
+/* Global Variables for ASI1 Routing*/
+static const char *const asilin_text[] = {
+	"off", "ASI Left In", "ASI Right In", "ASI MonoMix In"
+};
+
+static const char *const asirin_text[] = {
+	"off", "ASI Right In", "ASI Left In", "ASI MonoMix In"
+};
+
+/*ASI left*/
+static SOC_ENUM_SINGLE_DECL(asilin_enum, AIC31XX_DACSETUP, 4, asilin_text);
+
+/*ASI right*/
+static SOC_ENUM_SINGLE_DECL(asirin_enum, AIC31XX_DACSETUP, 2, asirin_text);
+
+static const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -6350, 50, 0);
+static const DECLARE_TLV_DB_SCALE(adc_fgain_tlv, 0, 10, 0);
+static const DECLARE_TLV_DB_SCALE(adc_cgain_tlv, -2000, 50, 0);
+static const DECLARE_TLV_DB_SCALE(mic_pga_tlv, 0, 50, 0);
+static const DECLARE_TLV_DB_SCALE(hp_drv_tlv, 0, 100, 0);
+static const DECLARE_TLV_DB_SCALE(class_D_drv_tlv, 600, 600, 0);
+static const DECLARE_TLV_DB_SCALE(hp_vol_tlv, -7830, 60, 0);
+static const DECLARE_TLV_DB_SCALE(sp_vol_tlv, -7830, 60, 0);
+
+/*
+ * controls that need to be exported to the user space
+ */
+static const struct snd_kcontrol_new aic31xx_snd_controls[] = {
+	/* DAC Volume Control*/
+	 SOC_DOUBLE_R_SX_TLV("DAC Playback Volume", AIC31XX_LDACVOL,
+			AIC31XX_RDACVOL, 0, 0x81, 0xaf, dac_vol_tlv),
+	/* DAC Volume soft stepping control */
+	/* HP driver mute control */
+	SOC_DOUBLE_R("HP driver mute", AIC31XX_HPLGAIN,
+			AIC31XX_HPRGAIN, 2, 1, 0),
+
+
+	/* ADC FINE GAIN */
+	SOC_SINGLE_TLV("ADC FINE GAIN", AIC31XX_ADCFGA, 4, 4, 1,
+			adc_fgain_tlv),
+	/* ADC COARSE GAIN */
+	SOC_DOUBLE_R_SX_TLV("ADC Capture Volume", AIC31XX_ADCVOL,
+			AIC31XX_ADCVOL,	0, 0x28, 0x40,
+			adc_cgain_tlv),
+	/* ADC MIC PGA GAIN */
+	SOC_SINGLE_TLV("Mic PGA Gain", AIC31XX_MICPGA, 0,
+			119, 0, mic_pga_tlv),
+
+	/* HP driver Volume Control */
+	SOC_DOUBLE_R_TLV("HP Driver Gain", AIC31XX_HPLGAIN,
+			AIC31XX_HPRGAIN, 3, 0x09, 0, hp_drv_tlv),
+	/* Left DAC input selection control */
+
+	/* DAC Processing Block Selection */
+	SOC_SINGLE("DAC Processing Block Selection(0 <->25)",
+			AIC31XX_DACPRB, 0, 0x19, 0),
+	/* ADC Processing Block Selection */
+	SOC_SINGLE("ADC Processing Block Selection(0 <->25)",
+			AIC31XX_ADCPRB, 0, 0x12, 0),
+
+	/* Throughput of 7-bit vol ADC for pin control */
+	/* HP Analog Gain Volume Control */
+	SOC_DOUBLE_R_TLV("HP Analog Gain", AIC31XX_LANALOGHPL,
+			AIC31XX_RANALOGHPR, 0, 0x7F, 1, hp_vol_tlv),
+	/* ADC MUTE */
+	SOC_SINGLE("ADC mute", AIC31XX_ADCFGA,
+			 7, 2, 0),
+};
+
+static const struct snd_kcontrol_new aic311x_snd_controls[] = {
+	/* SP Class-D driver output stage gain Control */
+	SOC_DOUBLE_R_TLV("SP Driver Gain", AIC31XX_SPLGAIN,
+			AIC31XX_SPRGAIN, 3, 0x03, 0, class_D_drv_tlv),
+	/* SP Analog Gain Volume Control */
+	SOC_DOUBLE_R_TLV("Analog Channel Gain", AIC31XX_LANALOGSPL,
+			AIC31XX_RANALOGSPR, 0, 0x7F, 1, sp_vol_tlv),
+	/* SP driver mute control */
+	SOC_DOUBLE_R("SP driver mute", AIC31XX_SPLGAIN,
+			AIC31XX_SPRGAIN, 2, 1, 0),
+};
+
+static const struct snd_kcontrol_new aic310x_snd_controls[] = {
+	/* SP Class-D driver output stage gain Control */
+	SOC_SINGLE_TLV("SP Driver Gain", AIC31XX_SPLGAIN,
+			3, 0x03, 0, class_D_drv_tlv),
+	/* SP Analog Gain Volume Control */
+	SOC_SINGLE_TLV("Left Analog Channel Gain", AIC31XX_LANALOGSPL,
+			0, 0x7F, 1, sp_vol_tlv),
+	SOC_SINGLE("SP driver mute", AIC31XX_SPLGAIN,
+			 2, 1, 0),
+};
+
+static const struct snd_kcontrol_new asilin_control =
+			 SOC_DAPM_ENUM("ASIIn Left Route", asilin_enum);
+
+static const struct snd_kcontrol_new asirin_control =
+			 SOC_DAPM_ENUM("ASIIn Right Route", asirin_enum);
+
+/* Local wait_bits function to handle wait events*/
+int aic31xx_wait_bits(struct aic31xx_priv *aic31xx, unsigned int reg,
+			unsigned int mask, unsigned char val, int sleep,
+			int counter)
+{
+	unsigned int value;
+	int timeout = sleep * counter;
+
+	value = snd_soc_read(aic31xx->codec, reg);
+	while (((value & mask) != val) && counter) {
+		usleep_range(sleep, sleep + 100);
+		value = snd_soc_read(aic31xx->codec, reg);
+		counter--;
+	};
+	if (!counter)
+		dev_err(aic31xx->dev,
+			"wait_bits timedout (%d millisecs). lastval 0x%x\n",
+			timeout, value);
+	return counter;
+}
+
+/**
+ *aic31xx_dac_power_up_event: Headset popup reduction and powering up dsps together
+ *			when they are in sync mode
+ * @w: pointer variable to dapm_widget
+ * @kcontrol: pointer to sound control
+ * @event: event element information
+ *
+ * Returns 0 for success.
+ */
+static int aic31xx_dac_power_up_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *kcontrol, int event)
+{
+	int reg_mask = 0;
+	int ret_wbits = 0;
+	struct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(w->codec);
+
+	if (w->shift == 7)
+		reg_mask = AIC31XX_LDACPWRSTATUS_MASK;
+
+	if (w->shift == 6)
+		reg_mask = AIC31XX_RDACPWRSTATUS_MASK;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		ret_wbits = aic31xx_wait_bits(aic31xx,
+						AIC31XX_DACFLAG1,
+						reg_mask, reg_mask,
+						AIC31XX_TIME_DELAY,
+						AIC31XX_DELAY_COUNTER);
+		if (!ret_wbits) {
+			dev_err(w->codec->dev, "DAC_post_pmu timed out\n");
+			return -1;
+		}
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		ret_wbits = aic31xx_wait_bits(aic31xx,
+			AIC31XX_DACFLAG1, reg_mask, 0,
+			AIC31XX_TIME_DELAY, AIC31XX_DELAY_COUNTER);
+		if (!ret_wbits) {
+			dev_err(w->codec->dev, "DAC_post_pmd timed out\n");
+			return -1;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/**
+ * aic31xx_adc_power_up_event: To get DSP run state to perform synchronization
+ * @w: pointer variable to dapm_widget
+ * @kcontrol: pointer to sound control
+ * @event: event element information
+ *
+ * Returns 0 for success.
+ */
+static int aic31xx_adc_power_up_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *kcontrol, int event)
+{
+	int reg_mask = 0;
+	int ret_wbits = 0;
+	struct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(w->codec);
+
+	if (w->shift == 7)
+		reg_mask = AIC31XX_ADCPWRSTATUS_MASK;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		ret_wbits = aic31xx_wait_bits(aic31xx,
+						AIC31XX_ADCFLAG, reg_mask,
+						reg_mask, AIC31XX_TIME_DELAY,
+						AIC31XX_DELAY_COUNTER);
+		if (!ret_wbits) {
+			dev_err(w->codec->dev, "ADC POST_PMU timedout\n");
+			return -1;
+		}
+		break;
+
+	case SND_SOC_DAPM_POST_PMD:
+		ret_wbits = aic31xx_wait_bits(aic31xx,
+						AIC31XX_ADCFLAG, reg_mask, 0,
+						AIC31XX_TIME_DELAY,
+						AIC31XX_DELAY_COUNTER);
+		if (!ret_wbits) {
+			dev_err(w->codec->dev, "ADC POST_PMD timedout\n");
+			return -1;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*Hp_power_up_event without powering on/off headphone driver,
+* instead muting hpl & hpr */
+static int aic31xx_hp_power_up_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);
+	int ret_wbits = 0;
+	/* TODO: Already checked with TI, why same thing is getting
+		 done for powerup and poweron both
+	 */
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+
+		if (!(strcmp(w->name, "HPL Driver"))) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1, AIC31XX_HPL_MASK,
+					AIC31XX_HPL_MASK, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "HPL Power Timedout\n");
+
+		}
+		if (!(strcmp(w->name, "HPR Driver"))) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1, AIC31XX_HPR_MASK,
+					AIC31XX_HPR_MASK, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "HPR Power Timedout\n");
+		}
+	}
+
+	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+
+		if (!(strcmp(w->name, "HPL Driver"))) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1, AIC31XX_HPL_MASK,
+					0x0, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "HPL Power Timedout\n");
+
+		}
+		if (!(strcmp(w->name, "HPR Driver"))) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1, AIC31XX_HPR_MASK,
+					0x0, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "HPR Power Timedout\n");
+		}
+	}
+	return 0;
+}
+
+
+static int aic31xx_sp_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	struct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);
+	int ret_wbits = 0;
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		/* Check for the DAC FLAG register to know if the SPL & SPR are
+		 * really powered up
+		 */
+		if (w->shift == 7) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1,  AIC31XX_SPL_MASK,
+					AIC31XX_SPL_MASK, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "SPL power timedout\n");
+			}
+
+
+		if (w->shift == 6) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1,  AIC31XX_SPR_MASK,
+					AIC31XX_SPR_MASK, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "SPR power timedout\n");
+
+			}
+		}
+
+	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+		/* Check for the DAC FLAG register to know if the SPL & SPR are
+		 * powered down
+		 */
+		if (w->shift == 7) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1,  AIC31XX_SPL_MASK,
+					0x0, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "SPL power timedout\n");
+			}
+		if (w->shift == 6) {
+			ret_wbits = aic31xx_wait_bits(aic31xx,
+					AIC31XX_DACFLAG1,  AIC31XX_SPR_MASK,
+					0x0, AIC31XX_TIME_DELAY,
+					AIC31XX_DELAY_COUNTER);
+			if (!ret_wbits)
+				dev_dbg(codec->dev, "SPR power timedout\n");
+			}
+	}
+	return 0;
+}
+
+/* Left Output Mixer */
+static const struct snd_kcontrol_new
+left_output_mixer_controls[] = {
+	SOC_DAPM_SINGLE("From DAC_L", AIC31XX_DACMIXERROUTE, 6, 1, 0),
+	SOC_DAPM_SINGLE("From MIC1LP", AIC31XX_DACMIXERROUTE, 5, 1, 0),
+	SOC_DAPM_SINGLE("From MIC1RP", AIC31XX_DACMIXERROUTE, 4, 1, 0),
+};
+
+/* Right Output Mixer - Valid only for AIC31xx, 3110, 3100 */
+static const struct
+snd_kcontrol_new right_output_mixer_controls[] = {
+	SOC_DAPM_SINGLE("From DAC_R", AIC31XX_DACMIXERROUTE, 2, 1, 0),
+	SOC_DAPM_SINGLE("From MIC1RP", AIC31XX_DACMIXERROUTE, 1, 1, 0),
+};
+
+static const struct
+snd_kcontrol_new pos_mic_imp_controls[] = {
+	SOC_DAPM_SINGLE("MIC1LP_IMP_CNTL", AIC31XX_MICPGAPI, 6, 0x3, 0),
+	SOC_DAPM_SINGLE("MIC1RP_IMP_CNTL", AIC31XX_MICPGAPI, 4, 0x3, 0),
+	SOC_DAPM_SINGLE("MIC1LM_IMP_CNTL", AIC31XX_MICPGAPI, 2, 0x3, 0),
+};
+
+static const struct
+snd_kcontrol_new neg_mic_imp_controls[] = {
+	SOC_DAPM_SINGLE("CM_IMP_CNTL", AIC31XX_MICPGAMI, 6, 0x3, 0),
+	SOC_DAPM_SINGLE("MIC1LM_IMP_CNTL", AIC31XX_MICPGAMI, 4, 0x3, 0),
+};
+
+static const struct snd_kcontrol_new aic31xx_dapm_hpl_vol_control =
+	SOC_DAPM_SINGLE("Switch", AIC31XX_LANALOGHPL, 7, 1, 0);
+
+static const struct snd_kcontrol_new aic31xx_dapm_hpr_vol_control =
+	SOC_DAPM_SINGLE("Switch", AIC31XX_RANALOGHPR, 7, 1, 0);
+
+static const struct snd_kcontrol_new aic31xx_dapm_spl_vol_control =
+	SOC_DAPM_SINGLE("Switch", AIC31XX_LANALOGSPL, 7, 1, 0);
+
+static const struct snd_kcontrol_new aic31xx_dapm_spr_vol_control =
+	SOC_DAPM_SINGLE("Switch", AIC31XX_RANALOGSPR, 7, 1, 0);
+
+/* TODO: Already check with TI on PLL not getting switched
+	 off and on in event. Is it required or not
+ */
+static int pll_power_on_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		dev_dbg(codec->dev, "pll->on pre_pmu");
+	else if (SND_SOC_DAPM_EVENT_OFF(event))
+		dev_dbg(codec->dev, "pll->off\n");
+
+	/* Sleep for 10 ms minumum */
+	usleep_range(10000, 15000);
+
+	return 0;
+}
+
+static int micbias_power_on_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		snd_soc_update_bits(codec, AIC31XX_MICBIAS, 0x03, (0x02));
+	else if (SND_SOC_DAPM_EVENT_OFF(event))
+		snd_soc_update_bits(codec, AIC31XX_MICBIAS, 0x03, (0x0));
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget aic31xx_dapm_widgets[] = {
+	/*ASI*/
+	SND_SOC_DAPM_AIF_IN("ASIIN", "ASI Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_PGA("ASILIN", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("ASIRIN", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("ASIMonoMixIN", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("ASI IN Port", SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	SND_SOC_DAPM_MUX("ASIIn Left Route",
+				SND_SOC_NOPM, 0, 0, &asilin_control),
+	SND_SOC_DAPM_MUX("ASIIn Right Route",
+				SND_SOC_NOPM, 0, 0, &asirin_control),
+	/* DACs */
+	SND_SOC_DAPM_DAC_E("Left DAC", "Left Playback",
+			AIC31XX_DACSETUP, 7, 0, aic31xx_dac_power_up_event,
+			SND_SOC_DAPM_POST_PMU |	SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_DAC_E("Right DAC", "Right Playback",
+			AIC31XX_DACSETUP, 6, 0, aic31xx_dac_power_up_event,
+			SND_SOC_DAPM_POST_PMU |	SND_SOC_DAPM_POST_PMD),
+
+	/* Output Mixers */
+	SND_SOC_DAPM_MIXER("Left Output Mixer", SND_SOC_NOPM, 0, 0,
+			left_output_mixer_controls,
+			ARRAY_SIZE(left_output_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Output Mixer", SND_SOC_NOPM, 0, 0,
+			right_output_mixer_controls,
+			ARRAY_SIZE(right_output_mixer_controls)),
+
+
+	SND_SOC_DAPM_SWITCH("HP Left Analog Volume", SND_SOC_NOPM, 0, 0,
+				&aic31xx_dapm_hpl_vol_control),
+	SND_SOC_DAPM_SWITCH("HP Right Analog Volume", SND_SOC_NOPM, 0, 0,
+				&aic31xx_dapm_hpr_vol_control),
+
+	/* Output drivers */
+	SND_SOC_DAPM_OUT_DRV_E("HPL Driver", AIC31XX_HPDRIVER, 7, 0,
+			NULL, 0, aic31xx_hp_power_up_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_OUT_DRV_E("HPR Driver", AIC31XX_HPDRIVER, 6, 0,
+			NULL, 0, aic31xx_hp_power_up_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	/* ADC */
+	SND_SOC_DAPM_ADC_E("ADC", "Capture", AIC31XX_ADCSETUP, 7, 0,
+			aic31xx_adc_power_up_event, SND_SOC_DAPM_POST_PMU |
+			SND_SOC_DAPM_POST_PMD),
+
+	/*Input Selection to MIC_PGA*/
+	SND_SOC_DAPM_MIXER("P_Input_Mixer", SND_SOC_NOPM, 0, 0,
+		pos_mic_imp_controls, ARRAY_SIZE(pos_mic_imp_controls)),
+	SND_SOC_DAPM_MIXER("M_Input_Mixer", SND_SOC_NOPM, 0, 0,
+		neg_mic_imp_controls, ARRAY_SIZE(neg_mic_imp_controls)),
+
+	/*Enabling & Disabling MIC Gain Ctl */
+	SND_SOC_DAPM_PGA("MIC_GAIN_CTL", AIC31XX_MICPGA,
+		7, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("PLLCLK", AIC31XX_PLLPR, 7, 0, pll_power_on_event,
+				 SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_SUPPLY("CODEC_CLK_IN", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("NDAC_DIV", AIC31XX_NDAC, 7, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("MDAC_DIV", AIC31XX_MDAC, 7, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("NADC_DIV", AIC31XX_NADC, 7, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("MADC_DIV", AIC31XX_MADC, 7, 0, NULL, 0),
+	/* Outputs */
+	SND_SOC_DAPM_OUTPUT("HPL"),
+	SND_SOC_DAPM_OUTPUT("HPR"),
+
+	/* Inputs */
+	SND_SOC_DAPM_INPUT("MIC1LP"),
+	SND_SOC_DAPM_INPUT("MIC1RP"),
+	SND_SOC_DAPM_INPUT("MIC1LM"),
+	SND_SOC_DAPM_MICBIASCUSTOM("micbias", SND_SOC_NOPM, 0,
+		micbias_power_on_event,
+		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+};
+
+static const struct snd_soc_dapm_widget aic311x_dapm_widgets[] = {
+	/* For AIC31XX and AIC3110 as it is stereo both left and right channel
+	 * class-D can be powered up/down
+	 */
+	SND_SOC_DAPM_OUT_DRV_E("SPL ClassD", AIC31XX_SPKAMP, 7, 0, NULL, 0,
+				aic31xx_sp_event, SND_SOC_DAPM_POST_PMU |
+				SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_OUT_DRV_E("SPR ClassD", AIC31XX_SPKAMP, 6, 0, NULL, 0,
+				aic31xx_sp_event, SND_SOC_DAPM_POST_PMU |
+				SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_SWITCH("SP Left Analog Volume", SND_SOC_NOPM, 0, 0,
+				&aic31xx_dapm_spl_vol_control),
+	SND_SOC_DAPM_SWITCH("SP Right Analog Volume", SND_SOC_NOPM, 0, 0,
+				&aic31xx_dapm_spr_vol_control),
+	SND_SOC_DAPM_OUTPUT("SPL"),
+	SND_SOC_DAPM_OUTPUT("SPR"),
+};
+
+static const struct snd_soc_dapm_widget aic310x_dapm_widgets[] = {
+	SND_SOC_DAPM_OUT_DRV_E("SPK ClassD", AIC31XX_SPKAMP, 7, 0, NULL, 0,
+			aic31xx_sp_event, SND_SOC_DAPM_POST_PMU |
+			SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_SWITCH("Speaker Analog Volume", SND_SOC_NOPM, 0, 0,
+				&aic31xx_dapm_spl_vol_control),
+	SND_SOC_DAPM_OUTPUT("SPK"),
+};
+
+static const struct snd_soc_dapm_route
+aic31xx_audio_map[] = {
+
+	{"CODEC_CLK_IN", NULL, "PLLCLK"},
+	{"NDAC_DIV", NULL, "CODEC_CLK_IN"},
+	{"NADC_DIV", NULL, "CODEC_CLK_IN"},
+	{"MDAC_DIV", NULL, "NDAC_DIV"},
+	{"MADC_DIV", NULL, "NADC_DIV"},
+
+	/* Clocks for ADC */
+	{"ADC", NULL, "MADC_DIV"},
+	/*ASI Routing*/
+	{"ASILIN", NULL, "ASIIN"},
+	{"ASIRIN", NULL, "ASIIN"},
+	{"ASIMonoMixIN", NULL, "ASIIN"},
+	{"ASIIn Left Route", "ASI Left In", "ASILIN"},
+	{"ASIIn Left Route", "ASI Right In", "ASIRIN"},
+	{"ASIIn Left Route", "ASI MonoMix In", "ASIMonoMixIN"},
+	{"ASIIn Right Route", "ASI Left In", "ASILIN"},
+	{"ASIIn Right Route", "ASI Right In", "ASIRIN"},
+	{"ASIIn Right Route", "ASI MonoMix In", "ASIMonoMixIN"},
+	{"ASI IN Port", NULL, "ASIIn Left Route"},
+	{"ASI IN Port", NULL, "ASIIn Right Route"},
+	{"Left DAC", NULL, "ASI IN Port"},
+	{"Right DAC", NULL, "ASI IN Port"},
+
+	/* Mic input */
+	{"P_Input_Mixer", "MIC1LP_IMP_CNTL", "MIC1LP"},
+	{"P_Input_Mixer", "MIC1RP_IMP_CNTL", "MIC1RP"},
+	{"P_Input_Mixer", "MIC1LM_IMP_CNTL", "MIC1LM"},
+
+	{"M_Input_Mixer", "CM_IMP_CNTL", "MIC1LM"},
+	{"M_Input_Mixer", "MIC1LM_IMP_CNTL", "MIC1LM"},
+	{"MIC1LM", NULL, "micbias"},
+
+	{"MIC_GAIN_CTL", NULL, "P_Input_Mixer"},
+	{"MIC_GAIN_CTL", NULL, "M_Input_Mixer"},
+
+	{"ADC", NULL, "MIC_GAIN_CTL"},
+
+	/* Clocks for DAC */
+	{"Left DAC", NULL, "MDAC_DIV" },
+	{"Right DAC", NULL, "MDAC_DIV"},
+
+	/* Left Output */
+	{"Left Output Mixer", "From DAC_L", "Left DAC"},
+	{"Left Output Mixer", "From MIC1LP", "MIC1LP"},
+	{"Left Output Mixer", "From MIC1RP", "MIC1RP"},
+	{"MIC1LP", NULL, "micbias"},
+
+	/* Right Output */
+	{"Right Output Mixer", "From DAC_R", "Right DAC"},
+	{"Right Output Mixer", "From MIC1RP", "MIC1RP"},
+
+	/* HPL path */
+	{"HP Left Analog Volume", "Switch", "Left Output Mixer"},
+	{"HPL Driver", NULL, "HP Left Analog Volume"},
+	{"HPL", NULL, "HPL Driver"},
+
+	/* HPR path */
+	{"HP Right Analog Volume", "Switch", "Right Output Mixer"},
+	{"HPR Driver", NULL, "HP Right Analog Volume"},
+	{"HPR", NULL, "HPR Driver"},
+
+};
+
+
+static const struct snd_soc_dapm_route
+aic311x_audio_map[] = {
+	/* SPK L path */
+	{"SP Left Analog Volume", "Switch", "Left Output Mixer"},
+	{"SPL ClassD", NULL, "SP Left Analog Volume"},
+	{"SPL", NULL, "SPL ClassD"},
+
+	/* SPK R path */
+	{"SP Left Analog Volume", "Switch", "Left Output Mixer"},
+	{"SPR ClassD", NULL, "SP Right Analog Volume"},
+	{"SPR", NULL, "SPR ClassD"},
+};
+
+
+static const struct snd_soc_dapm_route
+aic310x_audio_map[] = {
+	/* SPK L path */
+	{"Speaker Analog Volume", "Switch", "Left Output Mixer"},
+	{"SPK ClassD", NULL, "Speaker Analog Volume"},
+	{"SPK", NULL, "SPK ClassD"},
+
+};
+
+/*
+ * aic31xx_add_controls - add non dapm kcontrols.
+ *
+ * The different controls are in "aic31xx_snd_controls" table. The following
+ * different controls are supported
+ *
+ *	# DAC Playback volume control
+ *	# PCM Playback Volume
+ *	# HP Driver Gain
+ *	# HP DAC Playback Switch
+ *	# PGA Capture Volume
+ *	# Program Registers
+ */
+static int aic31xx_add_controls(struct snd_soc_codec *codec)
+{
+	int err = 0;
+	struct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "%s\n", __func__);
+	if (aic31xx->pdata.codec_type == AIC311X) {
+		err = snd_soc_add_codec_controls(codec, aic311x_snd_controls,
+				ARRAY_SIZE(aic311x_snd_controls));
+		if (err < 0)
+			dev_dbg(codec->dev, "Invalid control\n");
+
+	} else if (aic31xx->pdata.codec_type == AIC310X) {
+		err = snd_soc_add_codec_controls(codec, aic310x_snd_controls,
+				ARRAY_SIZE(aic310x_snd_controls));
+		if (err < 0)
+			dev_dbg(codec->dev, "Invalid Control\n");
+
+	}
+	return 0;
+}
+
+/*
+ * aic31xx_add_widgets
+ *
+ * adds all the ASoC Widgets identified by aic31xx_snd_controls array. This
+ * routine will be invoked * during the Audio Driver Initialization.
+ */
+static int aic31xx_add_widgets(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+	dev_dbg(codec->dev, "###aic31xx_add_widgets\n");
+
+	if (aic31xx->pdata.codec_type == AIC311X) {
+		ret = snd_soc_dapm_new_controls(dapm, aic311x_dapm_widgets,
+					ARRAY_SIZE(aic311x_dapm_widgets));
+		if (!ret)
+			dev_dbg(codec->dev, "#Completed adding dapm widgets size = %ld\n",
+					ARRAY_SIZE(aic311x_dapm_widgets));
+		ret = snd_soc_dapm_add_routes(dapm, aic311x_audio_map,
+					ARRAY_SIZE(aic311x_audio_map));
+		if (!ret)
+			dev_dbg(codec->dev, "#Completed adding DAPM routes = %ld\n",
+					ARRAY_SIZE(aic311x_audio_map));
+	} else if (aic31xx->pdata.codec_type == AIC310X) {
+		ret = snd_soc_dapm_new_controls(dapm, aic310x_dapm_widgets,
+					ARRAY_SIZE(aic310x_dapm_widgets));
+		if (!ret)
+			dev_dbg(codec->dev, "#Completed adding dapm widgets size = %ld\n",
+					ARRAY_SIZE(aic310x_dapm_widgets));
+		ret = snd_soc_dapm_add_routes(dapm, aic310x_audio_map,
+					ARRAY_SIZE(aic310x_audio_map));
+		if (!ret)
+			dev_dbg(codec->dev, "#Completed adding DAPM routes = %ld\n",
+					ARRAY_SIZE(aic310x_audio_map));
+	}
+
+	return 0;
+}
+
+/*
+ * This function is to set the hardware parameters for aic31xx.  The
+ * functions set the sample rate and audio serial data word length.
+ */
+static int aic31xx_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *tmp)
+{
+	struct snd_soc_codec *codec = tmp->codec;
+	u8 data;
+	dev_dbg(codec->dev, "%s\n", __func__);
+
+
+	data = snd_soc_read(codec, AIC31XX_IFACE1);
+	data = data & ~(3 << 4);
+
+	dev_dbg(codec->dev, "##- Data length: %d\n", params_format(params));
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		data |= (AIC31XX_WORD_LEN_20BITS <<
+				AIC31XX_IFACE1_DATALEN_SHIFT);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		data |= (AIC31XX_WORD_LEN_24BITS <<
+				AIC31XX_IFACE1_DATALEN_SHIFT);
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		data |= (AIC31XX_WORD_LEN_32BITS <<
+				AIC31XX_IFACE1_DATALEN_SHIFT);
+		break;
+	}
+
+	/* Write to Page 0 Reg 27 for the Codec Interface control 1
+	 * Register */
+	snd_soc_write(codec, AIC31XX_IFACE1, data);
+
+	return 0;
+}
+
+/*
+ * aic31xx_dac_mute - mute or unmute the left and right DAC
+
+ */
+static int aic31xx_dac_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+
+	if (mute)
+		snd_soc_update_bits(codec, AIC31XX_DACMUTE,
+					AIC31XX_DACMUTE_MASK,
+					AIC31XX_DACMUTE_MASK);
+	else
+		snd_soc_update_bits(codec, AIC31XX_DACMUTE,
+					AIC31XX_DACMUTE_MASK, 0x0);
+
+	return 0;
+}
+
+/*
+ * aic31xx_set_dai_fmt
+ *
+ * This function is to set the DAI format
+ */
+static int aic31xx_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 iface_reg1 = 0;
+	u8 iface_reg3 = 0;
+	u8 dsp_a_val = 0;
+
+	dev_dbg(codec->dev, "%s: Entered\n", __func__);
+	dev_dbg(codec->dev, "###aic31xx_set_dai_fmt %x\n", fmt);
+
+
+	dev_dbg(codec->dev, "##+ aic31xx_set_dai_fmt (%x)\n", fmt);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		iface_reg1 |= AIC31XX_BCLK_MASTER | AIC31XX_WCLK_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		iface_reg1 &= ~(AIC31XX_BCLK_MASTER | AIC31XX_WCLK_MASTER);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		iface_reg1 |= AIC31XX_BCLK_MASTER;
+		iface_reg1 &= ~(AIC31XX_WCLK_MASTER);
+		break;
+	default:
+		dev_alert(codec->dev, "Invalid DAI master/slave interface\n");
+		return -EINVAL;
+	}
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+			dsp_a_val = 0x1;
+	case SND_SOC_DAIFMT_DSP_B:
+		switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+		case SND_SOC_DAIFMT_NB_NF:
+				break;
+		case SND_SOC_DAIFMT_IB_NF:
+				iface_reg3 |= AIC31XX_BCLKINV_MASK;
+				break;
+		default:
+				return -EINVAL;
+		}
+		iface_reg1 |= (AIC31XX_DSP_MODE <<
+				AIC31XX_IFACE1_DATATYPE_SHIFT);
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		iface_reg1 |= (AIC31XX_RIGHT_JUSTIFIED_MODE <<
+				AIC31XX_IFACE1_DATATYPE_SHIFT);
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface_reg1 |= (AIC31XX_LEFT_JUSTIFIED_MODE <<
+				AIC31XX_IFACE1_DATATYPE_SHIFT);
+		break;
+	default:
+		dev_alert(codec->dev, "Invalid DAI interface format\n");
+		return -EINVAL;
+	}
+
+	snd_soc_update_bits(codec, AIC31XX_IFACE1,
+			AIC31XX_IFACE1_DATATYPE_MASK |
+			AIC31XX_IFACE1_MASTER_MASK,
+			iface_reg1);
+	snd_soc_update_bits(codec, AIC31XX_DATA_OFFSET,
+			AIC31XX_DATA_OFFSET_MASK,
+			dsp_a_val);
+	snd_soc_update_bits(codec, AIC31XX_IFACE2,
+			AIC31XX_BCLKINV_MASK,
+			iface_reg3);
+
+	dev_dbg(codec->dev, "##-aic31xx_set_dai_fmt Master\n");
+	dev_dbg(codec->dev, "%s: Exiting\n", __func__);
+
+	return 0;
+}
+
+
+/*
+* aic31xx_set_dai_pll
+*
+* This function is invoked as part of the PLL call-back
+* handler from the ALSA layer.
+*/
+static int aic31xx_set_dai_pll(struct snd_soc_dai *dai,
+		int pll_id, int source, unsigned int freq_in,
+		unsigned int freq_out)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	int i;
+	dev_dbg(codec->dev, "In aic31xx: dai_set_pll\n");
+
+	snd_soc_update_bits(codec, AIC31XX_CLKMUX,
+		AIC31XX_PLL_CLKIN_MASK, source << AIC31XX_PLL_CLKIN_SHIFT);
+
+	/* Use PLL as CODEC_CLKIN and DAC_MOD_CLK as BDIV_CLKIN */
+	snd_soc_update_bits(codec, AIC31XX_CLKMUX,
+		AIC31XX_CODEC_CLKIN_MASK, AIC31XX_CODEC_CLKIN_PLL);
+	snd_soc_update_bits(codec, AIC31XX_IFACE2, AIC31XX_BDIVCLK_MASK,
+				AIC31XX_DACMOD2BCLK);
+
+	for (i = 0; i < ARRAY_SIZE(aic31xx_divs); i++) {
+		if ((aic31xx_divs[i].rate == freq_out)
+			&& (aic31xx_divs[i].mclk == freq_in)) {
+				break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(aic31xx_divs)) {
+		dev_err(codec->dev, "sampling rate not supported\n");
+		return -EINVAL;
+	}
+
+	snd_soc_update_bits(codec, AIC31XX_PLLPR, AIC31XX_PLL_MASK,
+			(aic31xx_divs[i].p_val << 4) | 0x01);
+	snd_soc_write(codec, AIC31XX_PLLJ, aic31xx_divs[i].pll_j);
+
+	snd_soc_write(codec, AIC31XX_PLLDMSB, (aic31xx_divs[i].pll_d >> 8));
+	snd_soc_write(codec, AIC31XX_PLLDLSB,
+		      (aic31xx_divs[i].pll_d & 0xff));
+
+	/* NDAC divider value */
+	snd_soc_update_bits(codec, AIC31XX_NDAC, AIC31XX_PLL_MASK,
+			aic31xx_divs[i].ndac);
+
+	/* MDAC divider value */
+	snd_soc_update_bits(codec, AIC31XX_MDAC, AIC31XX_PLL_MASK,
+			aic31xx_divs[i].mdac);
+
+
+	/* DOSR MSB & LSB values */
+	snd_soc_write(codec, AIC31XX_DOSRMSB, aic31xx_divs[i].dosr >> 8);
+	snd_soc_write(codec, AIC31XX_DOSRLSB,
+		      (aic31xx_divs[i].dosr & 0xff));
+	/* NADC divider value */
+	snd_soc_update_bits(codec, AIC31XX_NADC, AIC31XX_PLL_MASK,
+			aic31xx_divs[i].nadc);
+	/* MADC divider value */
+	snd_soc_update_bits(codec, AIC31XX_MADC, AIC31XX_PLL_MASK,
+			aic31xx_divs[i].madc);
+	/* AOSR value */
+	snd_soc_write(codec, AIC31XX_AOSR, aic31xx_divs[i].aosr);
+	/* BCLK N divider */
+	snd_soc_update_bits(codec, AIC31XX_BCLKN, AIC31XX_PLL_MASK,
+			aic31xx_divs[i].bclk_n);
+
+
+	dev_dbg(codec->dev, "%s: DAI ID %d PLL_ID %d InFreq %d OutFreq %d\n",
+		__func__, pll_id, dai->id, freq_in, freq_out);
+	return 0;
+}
+
+
+/*
+ * aic31xx_set_sysclk - This function is called from machine driver to switch
+ *			clock source based on DAPM Event
+ */
+static int aic31xx_set_sysclk(struct snd_soc_codec *codec,
+		int clk_id, int source, unsigned int freq, int dir)
+{
+	/* Frequency required by jack detection logic when
+	 * on external clock
+	 */
+	int divider = 1;
+	if (clk_id == AIC31XX_MCLK) {
+		snd_soc_update_bits(codec, AIC31XX_TIMERCLOCK,
+			 AIC31XX_CLKSEL_MASK, AIC31XX_CLKSEL_MASK);
+
+		divider = freq / AIC31XX_REQ_TIMER_FREQ;
+		/* Added +1 to divider if divider is not exact.
+		 * This will make sure divider is always == ||
+		 * > required divider. So frequency will
+		 * round off to lower than ~1MHz
+		 */
+		if (freq % AIC31XX_REQ_TIMER_FREQ)
+			divider++;
+
+		snd_soc_update_bits(codec, AIC31XX_TIMERCLOCK,
+			 AIC31XX_DIVIDER_MASK, divider);
+
+		dev_dbg(codec->dev, "%s: input freq = %d divider = %d",
+		__func__, freq, divider);
+
+	} else if (clk_id == AIC31XX_INTERNALCLOCK) {
+		snd_soc_update_bits(codec, AIC31XX_TIMERCLOCK,
+			AIC31XX_CLKSEL_MASK, 0x0);
+	} else {
+		dev_err(codec->dev, "Wrong clock src\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ * aic31xx_set_bias_level - This function is to get triggered when dapm
+ * events occurs.
+ */
+static int aic31xx_set_bias_level(struct snd_soc_codec *codec,
+				enum snd_soc_bias_level level)
+{
+	dev_dbg(codec->dev, "## aic31xx_set_bias_level %d\n", level);
+	if (level == codec->dapm.bias_level) {
+		dev_dbg(codec->dev, "##set_bias_level: level returning...\r\n");
+		return 0;
+	}
+	switch (level) {
+	/* full On */
+	case SND_SOC_BIAS_ON:
+		/* All power is driven by DAPM system*/
+		dev_dbg(codec->dev, "###aic31xx_set_bias_level BIAS_ON\n");
+			snd_soc_update_bits(codec, AIC31XX_BCLKN,
+					AIC31XX_PLL_MASK, AIC31XX_PLL_MASK);
+		break;
+
+	/* partial On */
+	case SND_SOC_BIAS_PREPARE:
+		dev_dbg(codec->dev, "###aic31xx_set_bias_level BIAS_PREPARE\n");
+		if (codec->dapm.bias_level == ((SND_SOC_BIAS_ON))) {
+			snd_soc_update_bits(codec, AIC31XX_BCLKN,
+					AIC31XX_PLL_MASK, AIC31XX_PLL_MASK);
+		}
+		break;
+
+	/* Off, with power */
+	case SND_SOC_BIAS_STANDBY:
+		dev_dbg(codec->dev, "###aic31xx_set_bias_level STANDBY\n");
+		break;
+
+	/* Off, without power */
+	case SND_SOC_BIAS_OFF:
+		dev_dbg(codec->dev, "###aic31xx_set_bias_level OFF\n");
+		break;
+
+	}
+	codec->dapm.bias_level = level;
+	dev_dbg(codec->dev, "## aic31xx_set_bias_level %d\n", level);
+
+	return 0;
+}
+
+
+static int aic31xx_suspend(struct snd_soc_codec *codec)
+{
+	dev_dbg(codec->dev, "%s: Entered\n", __func__);
+
+	aic31xx_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	dev_dbg(codec->dev, "%s: Exiting\n", __func__);
+	return 0;
+}
+
+static int aic31xx_resume(struct snd_soc_codec *codec)
+{
+	dev_dbg(codec->dev, "%s: Entered\n", __func__);
+
+	aic31xx_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	dev_dbg(codec->dev, "%s: Exiting\n", __func__);
+
+	return 0;
+}
+
+void aic31xx_btn_press_intr_enable(struct snd_soc_codec *codec,
+		int enable)
+{
+	dev_dbg(codec->dev, "%s: %s\n", __func__,
+				enable ? "enable" : "disable");
+	if (enable)
+		snd_soc_update_bits(codec, AIC31XX_INT1CTRL,
+				AIC31XX_BUTTONPRESSDET_MASK,
+				AIC31XX_BUTTONPRESSDET_MASK);
+	else
+		snd_soc_update_bits(codec, AIC31XX_INT1CTRL,
+				AIC31XX_BUTTONPRESSDET_MASK,
+				0x0);
+}
+EXPORT_SYMBOL_GPL(aic31xx_btn_press_intr_enable);
+
+/**
+* aic31xx_hs_jack_report: Report jack notification to upper layer
+* @codec: pointer variable to codec having information related to codec
+* @jack: Pointer variable to snd_soc_jack having information of codec
+* and pin number$
+* @report: Provides informaton of whether it is headphone or microphone
+*
+*/
+static void aic31xx_hs_jack_report(struct snd_soc_codec *codec,
+			struct snd_soc_jack *jack, int report)
+{
+	struct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);
+	int status, state = 0, switch_state = 0;
+	u8 val;
+
+	mutex_lock(&aic31xx->mutex);
+
+	val = snd_soc_read(codec, AIC31XX_INTRDACFLAG);
+	status = snd_soc_update_bits(codec, AIC31XX_HSDETECT,
+				AIC31XX_HSPLUGDET_MASK, 0);
+	/* Sleep for 10 ms minumum */
+	usleep_range(10000, 15000);
+
+	snd_soc_update_bits(codec, AIC31XX_MICBIAS,
+				0x03, (0x03));
+	/* Sleep for 10 ms minumum */
+	usleep_range(10000, 15000);
+	snd_soc_update_bits(codec, AIC31XX_HSDETECT, AIC31XX_HSPLUGDET_MASK,
+				AIC31XX_HSPLUGDET_MASK);
+	msleep(64);
+	status = snd_soc_read(codec, AIC31XX_HSDETECT);
+
+	switch (status & AIC31XX_HS_MASK) {
+	case  AIC31XX_HS_MASK:
+		state |= SND_JACK_HEADSET;
+		break;
+	case AIC31XX_HP_MASK:
+		state |= SND_JACK_HEADPHONE;
+		break;
+	default:
+		break;
+	}
+	mutex_unlock(&aic31xx->mutex);
+	snd_soc_jack_report(jack, state, report);
+	if ((state & SND_JACK_HEADSET) == SND_JACK_HEADSET)
+		switch_state |= (1<<0);
+	else if (state & SND_JACK_HEADPHONE)
+		switch_state |= (1<<1);
+	dev_dbg(codec->dev, "Headset status =%x, state = %x, switch_state = %x\n",
+		status, state, switch_state);
+
+}
+EXPORT_SYMBOL_GPL(aic31xx_hs_jack_report);
+
+void aic31xx_enable_mic_bias(struct snd_soc_codec *codec, int enable)
+{
+	if (enable)
+		snd_soc_update_bits(codec, AIC31XX_MICBIAS, 0x03, (0x03));
+	else
+		snd_soc_update_bits(codec, AIC31XX_MICBIAS, 0x03, (0x0));
+}
+EXPORT_SYMBOL_GPL(aic31xx_enable_mic_bias);
+
+/**
+* aic31xx_hs_jack_report: Report jack notification to upper layer
+* @codec: pointer variable to codec having information related to codec
+* @jack: Pointer variable to snd_soc_jack having information of codec
+* and pin number$
+* @report: Provides informaton of whether it is headphone or microphone
+*
+*/
+int aic31xx_query_jack_status(struct snd_soc_codec *codec)
+{
+	int status, state = 0;
+
+	status = snd_soc_read(codec, AIC31XX_HSDETECT);
+
+	switch (status & AIC31XX_HS_MASK) {
+	case  AIC31XX_HS_MASK:
+		state |= SND_JACK_HEADSET;
+		break;
+	case AIC31XX_HP_MASK:
+		state |= SND_JACK_HEADPHONE;
+		break;
+	default:
+		break;
+	}
+	dev_dbg(codec->dev,
+			"AIC31XX_HSDETECT=0x%X,Jack Status returned is %x\n",
+								 status, state);
+	return state;
+}
+EXPORT_SYMBOL_GPL(aic31xx_query_jack_status);
+
+int aic31xx_query_btn_press(struct snd_soc_codec *codec)
+{
+	int state = 0, status;
+
+	status = snd_soc_read(codec, AIC31XX_INTRFLAG);
+	dev_dbg(codec->dev, "Status(P0/46): %x\n", status);
+	/** when HS is plugging out, BTN interrupts may be triggered
+	*  It is fake BTN press, should not be reported */
+	if ((status & AIC31XX_BTN_HS_STATUS_MASK) == AIC31XX_BTN_HS_STATUS_MASK)
+		return state | SND_JACK_BTN_0;
+	return state;
+
+}
+EXPORT_SYMBOL_GPL(aic31xx_query_btn_press);
+
+/**
+ * Instantiate the generic non-control parts of the device.
+ */
+int aic31xx_device_init(struct aic31xx_priv *aic31xx)
+{
+	int ret, i;
+	u8 resetval = 1;
+	unsigned int val;
+
+	dev_info(aic31xx->dev, "aic31xx_device_init beginning\n");
+
+	dev_set_drvdata(aic31xx->dev, aic31xx);
+
+	if (dev_get_platdata(aic31xx->dev))
+		memcpy(&aic31xx->pdata, dev_get_platdata(aic31xx->dev),
+			sizeof(aic31xx->pdata));
+	/*GPIO reset for TLV320AIC31xx codec */
+	if (aic31xx->pdata.gpio_reset) {
+		ret = devm_gpio_request_one(aic31xx->dev,
+				aic31xx->pdata.gpio_reset,
+				GPIOF_OUT_INIT_HIGH, "aic31xx-reset-pin");
+		if (ret < 0) {
+			dev_err(aic31xx->dev, "not able to acquire gpio\n");
+			goto err;
+		}
+	}
+
+	/* run the codec through software reset */
+	ret = regmap_write(aic31xx->regmap, AIC31XX_RESET, resetval);
+	if (ret < 0) {
+		dev_err(aic31xx->dev, "Could not write to AIC31xx register\n");
+		goto err;
+	}
+
+	/* This is according to datasheet */
+	/* Sleep for 10 ms minumum */
+	usleep_range(10000, 15000);
+	ret = regmap_read(aic31xx->regmap, AIC31XX_REV_PG_ID, &val);
+
+	if (ret < 0) {
+		dev_err(aic31xx->dev, "Failed to read ID register\n");
+		goto err;
+	}
+	/* Init the gpio registers */
+	for (i = 0; i < aic31xx->pdata.num_gpios; i++) {
+		regmap_write(aic31xx->regmap,
+			aic31xx->pdata.gpio_defaults[i].reg,
+			aic31xx->pdata.gpio_defaults[i].value);
+	}
+
+	return 0;
+
+err:
+	return ret;
+}
+
+void aic31xx_device_exit(struct aic31xx_priv *aic31xx)
+{
+}
+
+/*
+ * Codec probe function, called upon codec registration
+ *
+ */
+
+static int aic31xx_codec_probe(struct snd_soc_codec *codec)
+{
+
+
+	int ret = 0;
+	struct aic31xx_priv *aic31xx;
+
+	aic31xx = snd_soc_codec_get_drvdata(codec);
+	codec->control_data = aic31xx->regmap;
+
+	aic31xx->codec = codec;
+
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);
+
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache i/o:%d\n", ret);
+		return ret;
+	}
+
+	mutex_init(&aic31xx->mutex);
+
+	/* Dynamic Headset detection enabled */
+	snd_soc_update_bits(codec, AIC31XX_HSDETECT,
+			AIC31XX_HSPLUGDET_MASK,
+			AIC31XX_HSPLUGDET_MASK);
+	snd_soc_update_bits(codec, AIC31XX_INT1CTRL,
+			AIC31XX_BUTTONPRESSDET_MASK,
+			AIC31XX_BUTTONPRESSDET_MASK);
+	/* Program codec to use internal clock */
+	snd_soc_update_bits(codec, AIC31XX_TIMERCLOCK,
+			AIC31XX_CLKSEL_MASK, 0x0);
+
+	/* Debounce time depends on input clock. Set
+	 * debounce time for internal clock, since at
+	 * start we will be working with internal clock
+	 * 0x4 - 256ms debounce
+	 */
+	snd_soc_update_bits(codec, AIC31XX_HSDETECT,
+			AIC31XX_JACK_DEBOUCE_MASK, 0x4<<2);
+
+	/* set debounce time for button */
+	snd_soc_update_bits(codec, AIC31XX_HSDETECT,
+			AIC31XX_BTN_DEBOUCE_MASK, 0x03);
+
+	/*Reconfiguring CM to band gap mode*/
+	snd_soc_update_bits(codec, AIC31XX_HPPOP, 0xff, 0xA8);
+
+	/*disable soft stepping of DAC volume */
+	snd_soc_update_bits(codec, AIC31XX_DACSETUP,
+				AIC31XX_SOFTSTEP_MASK, 0x02);
+
+	/* HP driver weakly driven to common mode during powerdown */
+
+	/*Speaker ramp up time scaled to 30.5ms*/
+	snd_soc_write(codec, AIC31XX_SPPGARAMP, 0x70);
+
+	/* ADC Umnute */
+	snd_soc_update_bits(codec, AIC31XX_ADCFGA, AIC31XX_ADCMUTE_MASK, 0x0);
+
+	/* off, with power on */
+	aic31xx_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	aic31xx_add_controls(codec);
+	aic31xx_add_widgets(codec);
+	dev_dbg(codec->dev, "%d, %s, Firmware test\n", __LINE__, __func__);
+
+	snd_soc_update_bits(codec, AIC31XX_INT1CTRL,
+			AIC31XX_HSPLUGDET_MASK,
+			AIC31XX_HSPLUGDET_MASK);
+	msleep(250);
+	snd_soc_read(codec, AIC31XX_INTRDACFLAG);
+	snd_soc_read(codec, AIC31XX_INTRFLAG);
+
+	return ret;
+}
+
+/*
+ * Remove aic31xx soc device
+ */
+static int aic31xx_codec_remove(struct snd_soc_codec *codec)
+{
+	/* power down chip */
+	aic31xx_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+/*
+ *----------------------------------------------------------------------------
+ * @struct  snd_soc_codec_device |
+ *          This structure is soc audio codec device sturecute which pointer
+ *          to basic functions aic31xx_probe(), aic31xx_remove(),
+ *          aic31xx_suspend() and aic31xx_resume()
+ *----------------------------------------------------------------------------
+ */
+static struct snd_soc_codec_driver soc_codec_driver_aic31xx = {
+	.probe			= aic31xx_codec_probe,
+	.remove			= aic31xx_codec_remove,
+	.suspend		= aic31xx_suspend,
+	.resume			= aic31xx_resume,
+	.set_bias_level		= aic31xx_set_bias_level,
+	.controls		= aic31xx_snd_controls,
+	.num_controls		= ARRAY_SIZE(aic31xx_snd_controls),
+	.dapm_widgets		= aic31xx_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(aic31xx_dapm_widgets),
+	.dapm_routes		= aic31xx_audio_map,
+	.num_dapm_routes	= ARRAY_SIZE(aic31xx_audio_map),
+	.reg_cache_size		= 0,
+	.reg_word_size		= sizeof(u8),
+	.reg_cache_default	= NULL,
+	.set_sysclk		= aic31xx_set_sysclk,
+};
+
+/*
+ *----------------------------------------------------------------------------
+ * @struct  snd_soc_codec_dai |
+ *		It is SoC Codec DAI structure which has DAI capabilities viz.,
+ *		playback and capture, DAI runtime information viz. state of DAI
+ *		and pop wait state, and DAI private data.
+ *		The AIC31xx rates ranges from 8k to 192k
+ *		The PCM bit format supported are 16, 20, 24 and 32 bits
+ *----------------------------------------------------------------------------
+ */
+
+/*
+ * DAI ops
+ */
+
+static struct snd_soc_dai_ops aic31xx_dai_ops = {
+	.hw_params	= aic31xx_hw_params,
+	.set_pll	= aic31xx_set_dai_pll,
+	.set_fmt	= aic31xx_set_dai_fmt,
+	.digital_mute	= aic31xx_dac_mute,
+};
+
+/*
+ * It is SoC Codec DAI structure which has DAI capabilities viz.,
+ * playback and capture, DAI runtime information viz. state of DAI and
+ * pop wait state, and DAI private data.  The aic31xx rates ranges
+ * from 8k to 192k The PCM bit format supported are 16, 20, 24 and 32
+ * bits
+ */
+static struct snd_soc_dai_driver aic31xx_dai_driver[] = {
+{
+	.name = "tlv320aic31xx-codec",
+		.playback = {
+			.stream_name	 = "Playback",
+			.channels_min	 = 1,
+			.channels_max	 = 2,
+			.rates		 = AIC31XX_RATES,
+			.formats	 = AIC31XX_FORMATS,
+		},
+		.capture = {
+			.stream_name	 = "Capture",
+			.channels_min	 = 1,
+			.channels_max	 = 2,
+			.rates		 = AIC31XX_RATES,
+			.formats	 = AIC31XX_FORMATS,
+		},
+	.ops = &aic31xx_dai_ops,
+}
+};
+
+#ifdef CONFIG_ACPI
+static int aic31xx_get_acpi_data(struct aic31xx_priv *aic31xx)
+{
+	acpi_status status;
+	acpi_handle handle;
+	struct acpi_buffer pdata_buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *pdata_buf_ptr;
+	union acpi_object *element;
+	struct aic31xx_pdata *pdata;
+	int ret = 0, ret1 = 0;
+	struct gpio_desc *desc;
+
+	dev_dbg(aic31xx->dev, "acpi get data\n");
+	pdata = &aic31xx->pdata;
+	handle = DEVICE_ACPI_HANDLE(aic31xx->dev);
+
+	status = acpi_evaluate_object(handle, "OBJ1", NULL, &pdata_buffer);
+	if (ACPI_FAILURE(status)) {
+		dev_err(aic31xx->dev, "Error evaluating OBJ1\n");
+		ret = -ENODEV;
+		goto end;
+	}
+
+	pdata_buf_ptr = pdata_buffer.pointer;
+	if (!pdata_buf_ptr || pdata_buf_ptr->type != ACPI_TYPE_PACKAGE) {
+		dev_err(aic31xx->dev, "Invalid OBJ1 package data\n");
+		ret = -EFAULT;
+		goto end;
+	}
+	element = &(pdata_buf_ptr->package.elements[0]);
+	pdata->codec_type = element->integer.value;
+	dev_dbg(aic31xx->dev, "element 0 %llx\n", element->integer.value);
+
+	element = &(pdata_buf_ptr->package.elements[1]);
+	pdata->audio_mclk1 = element->integer.value;
+	dev_dbg(aic31xx->dev, "element 1 %llx\n", element->integer.value);
+
+	desc = devm_gpiod_get_index(aic31xx->dev, NULL, 0);
+	if (!IS_ERR(desc)) {
+		pdata->gpio_reset =  desc_to_gpio(desc);
+		devm_gpiod_put(aic31xx->dev, desc);
+		dev_info(aic31xx->dev, "Codec-reset gpio: %d\n",
+						 pdata->gpio_reset);
+	} else {
+		pdata->gpio_reset = -1;
+		dev_err(aic31xx->dev, "failed to get gpiod for codec-reset\n");
+	}
+
+	element = &(pdata_buf_ptr->package.elements[4]);
+	pdata->num_gpios = element->integer.value;
+	dev_dbg(aic31xx->dev, "element 4 %llx\n", element->integer.value);
+
+	pdata->gpio_defaults = devm_kzalloc(aic31xx->dev,
+				 sizeof(struct aic31xx_gpio_setup),
+				 GFP_KERNEL);
+	if (pdata->gpio_defaults == NULL)
+		return -ENOMEM;
+
+	element = &(pdata_buf_ptr->package.elements[8]);
+	pdata->gpio_defaults[0].value = element->integer.value;
+	dev_dbg(aic31xx->dev, "element 8 %llx\n", element->integer.value);
+
+	element = &(pdata_buf_ptr->package.elements[9]);
+	pdata->gpio_defaults[0].reg = element->integer.value;
+	dev_dbg(aic31xx->dev, "element 9 %llx\n", element->integer.value);
+
+end:
+	ACPI_FREE(pdata_buffer.pointer);
+	return ret;
+
+}
+#else
+static int aic31xx_get_acpi_data(struct aic31xx_priv *aic31xx)
+{
+	dev_dbg("CONFIG_ACPI not defined\n");
+	return 0;
+}
+
+#endif
+static struct acpi_device_id aic31xx_acpi_match[] = {
+	{ "10TI3100", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, aic31xx_acpi_match);
+
+static int aic31xx_i2c_probe(struct i2c_client *i2c,
+					const struct i2c_device_id *id)
+{
+	struct aic31xx_priv *aic31xx;
+	int ret;
+	const struct regmap_config *regmap_config;
+	struct aic31xx_driver_data *driver_data =
+		 (struct aic31xx_driver_data *)id->driver_data;
+
+
+	regmap_config = &aicxxx_i2c_regmap;
+
+	aic31xx = devm_kzalloc(&i2c->dev, sizeof(*aic31xx), GFP_KERNEL);
+	if (aic31xx == NULL)
+		return -ENOMEM;
+
+	aic31xx->regmap = devm_regmap_init_i2c(i2c, regmap_config);
+
+	if (IS_ERR(aic31xx->regmap)) {
+		ret = PTR_ERR(aic31xx->regmap);
+		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
+			ret);
+		return ret;
+	}
+	aic31xx->dev = &i2c->dev;
+	aic31xx->irq = i2c->irq;
+	if (driver_data && driver_data->acpi_device) {
+		ret = aic31xx_get_acpi_data(aic31xx);
+		if (ret) {
+			dev_err(&i2c->dev,
+				"Failed to get ACPI data: %d\n", ret);
+			return ret;
+		}
+	}
+	aic31xx_device_init(aic31xx);
+
+	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_driver_aic31xx,
+			aic31xx_dai_driver, ARRAY_SIZE(aic31xx_dai_driver));
+
+	return ret;
+}
+
+static int aic31xx_i2c_remove(struct i2c_client *i2c)
+{
+
+	struct aic31xx_priv *aic31xx = dev_get_drvdata(&i2c->dev);
+	snd_soc_unregister_codec(aic31xx->dev);
+	aic31xx_device_exit(aic31xx);
+	return 0;
+}
+
+static const struct i2c_device_id aic31xx_i2c_id[] = {
+	{ "tlv320aic31xx-codec", (kernel_ulong_t) &aic31xx_i2c_data},
+	{"10TI3100:00", (kernel_ulong_t) &aic31xx_acpi_data},
+	{"10TI3100", (kernel_ulong_t) &aic31xx_acpi_data},
+	{ "i2c-10TI3100:00:1c", (kernel_ulong_t) &aic31xx_acpi_data},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, aic31xx_i2c_id);
+
+static struct i2c_driver aic31xx_i2c_driver = {
+	.driver = {
+		.name	= "tlv320aic31xx-codec",
+		.owner	= THIS_MODULE,
+		.acpi_match_table = ACPI_PTR(aic31xx_acpi_match),
+	},
+	.probe		= aic31xx_i2c_probe,
+	.remove		= (aic31xx_i2c_remove),
+	.id_table	= aic31xx_i2c_id,
+};
+module_i2c_driver(aic31xx_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC TLV320AIC3111 codec driver");
+MODULE_AUTHOR("Ajit Kulkarni");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:tlv320aic31xx-codec");
diff --git a/sound/soc/codecs/tlv320aic31xx.h b/sound/soc/codecs/tlv320aic31xx.h
new file mode 100644
index 0000000..251b94f
--- /dev/null
+++ b/sound/soc/codecs/tlv320aic31xx.h
@@ -0,0 +1,403 @@
+/* revert
+ * linux/sound/soc/codecs/tlv320aic31xx.h
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+#ifndef _TLV320AIC31XX_H
+#define _TLV320AIC31XX_H
+
+#define AUDIO_NAME "aic31xx"
+/* AIC31XX supported sample rate are 8k to 192k */
+#define AIC31XX_RATES	SNDRV_PCM_RATE_8000_192000
+
+/* AIC31XX supports the word formats 16bits, 20bits, 24bits and 32 bits */
+#define AIC31XX_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \
+			 | SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+#define AIC31XX_REQ_TIMER_FREQ		1000000
+#define AIC31XX_FREQ_25000000		25000000
+#define AIC31XX_JD_FREQ			1000000
+
+#define AIC31XX_INTERNALCLOCK		0
+#define AIC31XX_MCLK			1
+/* Audio data word length = 16-bits (default setting) */
+#define AIC31XX_WORD_LEN_16BITS		0x00
+#define AIC31XX_WORD_LEN_20BITS		0x01
+#define AIC31XX_WORD_LEN_24BITS		0x02
+#define AIC31XX_WORD_LEN_32BITS		0x03
+
+
+/* D15..D8 aic31xx register offset */
+#define AIC31XX_REG_OFFSET_INDEX		0
+/* D7...D0 register data */
+#define AIC31XX_REG_DATA_INDEX		1
+
+
+/* 8 bit mask value */
+#define AIC31XX_8BITS_MASK		0xFF
+
+/* shift value for CLK_REG_3 register */
+#define CLK_REG_3_SHIFT			6
+/* shift value for DAC_OSR_MSB register */
+#define DAC_OSR_MSB_SHIFT		4
+
+/* Masks used for updating register bits */
+#define AIC31XX_IFACE1_DATALEN_MASK	0x30
+#define AIC31XX_IFACE1_DATALEN_SHIFT	(4)
+#define AIC31XX_IFACE1_DATATYPE_MASK	0xC0
+#define AIC31XX_IFACE1_DATATYPE_SHIFT	(6)
+/* Serial data bus uses I2S mode (Default mode) */
+#define AIC31XX_I2S_MODE		0x00
+#define AIC31XX_DSP_MODE		0x01
+#define AIC31XX_RIGHT_JUSTIFIED_MODE	0x02
+#define AIC31XX_LEFT_JUSTIFIED_MODE	0x03
+
+#define AIC31XX_IFACE1_MASTER_MASK	0x0C
+#define AIC31XX_IFACE1_MASTER_SHIFT	(2)
+#define AIC31XX_BCLK_MASTER	0x80
+#define AIC31XX_WCLK_MASTER	0x40
+
+
+#define AIC31XX_DATA_OFFSET_MASK	0xFF
+#define AIC31XX_BCLKINV_MASK		0x08
+#define AIC31XX_BDIVCLK_MASK		0x03
+
+#define AIC31XX_DAC2BCLK		0x00
+#define AIC31XX_DACMOD2BCLK		0x01
+#define AIC31XX_ADC2BCLK		0x02
+#define AIC31XX_ADCMOD2BCLK		0x03
+
+
+struct aic31xx_jack_data {
+	struct snd_soc_jack *jack;
+	int report;
+};
+
+struct aic31xx_gpio_setup {
+	unsigned int reg;
+	u8 value;
+};
+
+/*
+ *----------------------------------------------------------------------------
+ * @struct  aic31xx_rate_divs |
+ *          Setting up the values to get different freqencies
+ *
+ * @field   u32 | mclk |
+ *          Master clock
+ * @field   u32 | rate |
+ *          sample rate
+ * @field   u8 | p_val |
+ *          value of p in PLL
+ * @field   u32 | pll_j |
+ *          value for pll_j
+ * @field   u32 | pll_d |
+ *          value for pll_d
+ * @field   u32 | dosr |
+ *          value to store dosr
+ * @field   u32 | ndac |
+ *          value for ndac
+ * @field   u32 | mdac |
+ *          value for mdac
+ * @field   u32 | aosr |
+ *          value for aosr
+ * @field   u32 | nadc |
+ *          value for nadc
+ * @field   u32 | madc |
+ *          value for madc
+ * @field   u32 | blck_N |
+ *          value for block N
+ * @field   u32 | aic31xx_configs |
+ *          configurations for aic31xx register value
+ *----------------------------------------------------------------------------
+ */
+struct aic31xx_rate_divs {
+	u32 mclk;
+	u32 rate;
+	u8 p_val;
+	u8 pll_j;
+	u16 pll_d;
+	u16 dosr;
+	u8 ndac;
+	u8 mdac;
+	u8 aosr;
+	u8 nadc;
+	u8 madc;
+	u8 bclk_n;
+};
+
+
+enum aic31xx_type {
+	AIC311X = 0,
+	AIC310X = 1,
+};
+
+struct aic31xx_pdata {
+	enum aic31xx_type codec_type;
+	unsigned int audio_mclk1;
+	unsigned int gpio_irq; /* whether AIC31XX interrupts the host AP
+				on a GPIO pin of AP */
+	unsigned int gpio_reset; /* is the codec being reset by a gpio
+				[host] pin, if yes provide the number. */
+	int num_gpios;
+	struct aic31xx_gpio_setup *gpio_defaults;/* all gpio configuration */
+	int naudint_irq; /* audio interrupt */
+	int headset_detect;
+	int button_press_detect;
+};
+
+struct aic31xx_priv {
+	struct aic31xx_jack_data hs_jack;
+	struct workqueue_struct *workqueue;
+	struct delayed_work delayed_work;
+	struct snd_soc_codec *codec;
+	u8 i2c_regs_status;
+	struct device *dev;
+	struct regmap *regmap;
+	struct mutex mutex;
+	struct aic31xx_pdata pdata;
+	unsigned int irq;
+};
+
+/* Driver data to differentiate between apci and i2c device
+ * platform data extraction is different for ACPI and i2c device
+ */
+struct aic31xx_driver_data {
+	u32 acpi_device;
+};
+
+/*
+ *----------------------------------------------------------------------------
+int aic31xx_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+ * @struct  snd_soc_codec_device |
+ *          This structure is soc audio codec device sturecute which pointer
+ *          to basic functions aic31xx_probe(), aic31xx_remove(),
+ *			aic31xx_suspend() and aic31xx_resume()
+ *
+ */
+extern struct snd_soc_codec_device soc_codec_dev_aic31xx;
+
+
+/* Device I/O API */
+int aic31xx_device_init(struct aic31xx_priv *aic31xx);
+void aic31xx_device_exit(struct aic31xx_priv *aic31xx);
+void aic31xx_enable_mic_bias(struct snd_soc_codec *codec, int enable);
+int aic31xx_query_jack_status(struct snd_soc_codec *codec);
+int aic31xx_query_btn_press(struct snd_soc_codec *codec);
+void aic31xx_btn_press_intr_enable(struct snd_soc_codec *codec,
+		int enable);
+
+
+/* ****************** Book 0 Registers **************************************/
+/* ****************** AIC31XX has one book only *****************************/
+
+/* ****************** Page 0 Registers **************************************/
+/* Software reset register */
+#define AIC31XX_RESET				0x81
+/* OT FLAG register */
+#define AIC31XX_OT_FLAG				0x83
+/* Revision and PG-ID */
+#define AIC31XX_REV_PG_ID				0x03
+#define AIC31XX_REV_MASK				0x70 /* (0b01110000) */
+#define AIC31XX_REV_SHIFT				4
+#define AIC31XX_PG_MASK					0x1  /* (0b00000001) */
+#define AIC31XX_PG_SHIFT				0
+
+/* Clock clock Gen muxing, Multiplexers*/
+#define AIC31XX_CLKMUX					0x84
+#define AIC31XX_PLL_CLKIN_MASK				0xC  /* (0b00001100) */
+#define AIC31XX_PLL_CLKIN_SHIFT				2
+#define AIC31XX_PLL_CLKIN_MCLK				0
+#define AIC31XX_CODEC_CLKIN_MASK			0x3  /* (0b00000011) */
+#define AIC31XX_CODEC_CLKIN_SHIFT			0
+#define AIC31XX_CODEC_CLKIN_PLL				0x3
+/* PLL P and R-VAL register*/
+#define AIC31XX_PLLPR					0x85
+#define AIC31XX_PLL_MASK				0x7f
+/* PLL J-VAL register*/
+#define AIC31XX_PLLJ					0x86
+/* PLL D-VAL MSB register */
+#define AIC31XX_PLLDMSB					0x87
+/* PLL D-VAL LSB register */
+#define AIC31XX_PLLDLSB					0x88
+/* DAC NDAC_VAL register*/
+#define AIC31XX_NDAC				0x8B
+/* DAC MDAC_VAL register */
+#define AIC31XX_MDAC				0x8C
+/*DAC OSR setting register1, MSB value*/
+#define AIC31XX_DOSRMSB				0x8D
+/*DAC OSR setting register 2, LSB value*/
+#define AIC31XX_DOSRLSB				0x8E
+#define AIC31XX_MINI_DSP_INPOL				0x90
+/*Clock setting register 8, PLL*/
+#define AIC31XX_NADC				0x92
+/*Clock setting register 9, PLL*/
+#define AIC31XX_MADC				0x93
+/*ADC Oversampling (AOSR) Register*/
+#define AIC31XX_AOSR				0x94
+/*Clock setting register 9, Multiplexers*/
+#define AIC31XX_CLKOUTMUX				0x99
+/*Clock setting register 10, CLOCKOUT M divider value*/
+#define AIC31XX_CLKOUTMVAL					0x9A
+/*Audio Interface Setting Register 1*/
+#define AIC31XX_IFACE1			0x9B
+/*Audio Data Slot Offset Programming*/
+#define AIC31XX_DATA_OFFSET			0x9C
+/*Audio Interface Setting Register 2*/
+#define AIC31XX_IFACE2			0x9D
+/*Clock setting register 11, BCLK N Divider*/
+#define AIC31XX_BCLKN					0x9E
+/*Audio Interface Setting Register 3, Secondary Audio Interface*/
+#define AIC31XX_IFACESEC1			0x9F
+/*Audio Interface Setting Register 4*/
+#define AIC31XX_IFACESEC2			0xA0
+/*Audio Interface Setting Register 5*/
+#define AIC31XX_IFACESEC3			0xA1
+/* I2C Bus Condition */
+#define AIC31XX_I2C				0xA2
+/* ADC FLAG */
+#define AIC31XX_ADCFLAG				0xA4
+/* DAC Flag Registers */
+#define AIC31XX_DACFLAG1				0xA5
+#define AIC31XX_DACFLAG2				0xA6
+#define AIC31XX_HPL_MASK			0x20
+#define AIC31XX_HPR_MASK			0x02
+#define AIC31XX_SPL_MASK			0x10
+#define AIC31XX_SPR_MASK			0x01
+
+/* Sticky Interrupt flag (overflow) */
+#define AIC31XX_OFFLAG			0xA7
+
+/* Sticky Interrupt flags 1 and 2 registers (DAC) */
+#define AIC31XX_INTRDACFLAG				0xAC
+#define AIC31XX_HPSCDETECT_MASK				0x80
+#define AIC31XX_BUTTONPRESS_MASK			0x20
+#define AIC31XX_HSPLUG_MASK				0x10
+#define AIC31XX_LDRCTHRES_MASK				0x08
+#define AIC31XX_RDRCTHRES_MASK				0x04
+#define AIC31XX_DACSINT_MASK				0x02
+#define AIC31XX_DACAINT_MASK				0x01
+
+/* Sticky Interrupt flags 1 and 2 registers (ADC) */
+#define AIC31XX_INTRADCFLAG				0xAD
+
+/* Interrupt flags register */
+#define AIC31XX_INTRFLAG				0xAE
+#define AIC31XX_BTNPRESS_STATUS_MASK			0x20
+#define AIC31XX_HEADSET_STATUS_MASK			0x10
+#define AIC31XX_BTN_HS_STATUS_MASK (AIC31XX_BTNPRESS_STATUS_MASK \
+					|AIC31XX_HEADSET_STATUS_MASK)
+
+/* INT1 interrupt control */
+#define AIC31XX_INT1CTRL				0xB0
+#define AIC31XX_HSPLUGDET_MASK				0x80
+#define AIC31XX_BUTTONPRESSDET_MASK			0x40
+#define AIC31XX_DRCTHRES_MASK				0x20
+#define AIC31XX_AGCNOISE_MASK				0x10
+#define AIC31XX_OC_MASK					0x08
+#define AIC31XX_ENGINE_MASK				0x04
+#define AIC31XX_MULTIPLE_PULSES				0x01
+
+/* INT2 interrupt control */
+#define AIC31XX_INT2CTRL				0xB1
+
+/* GPIO1 control */
+#define AIC31XX_GPIO1					0xB3
+#define AIC31XX_GPIO_D5_D2				0x3C /* (0b00111100) */
+#define AIC31XX_GPIO_D2_SHIFT				2
+
+#define AIC31XX_DACPRB					0xBC
+/*ADC Instruction Set Register*/
+#define AIC31XX_ADCPRB					0xBD
+/*DAC channel setup register*/
+#define AIC31XX_DACSETUP				0xBF
+#define AIC31XX_SOFTSTEP_MASK				0x03
+/*DAC Mute and volume control register*/
+#define AIC31XX_DACMUTE					0xC0
+#define AIC31XX_DACMUTE_MASK				0x0C
+/*Left DAC channel digital volume control*/
+#define AIC31XX_LDACVOL				0xC1
+/*Right DAC channel digital volume control*/
+#define AIC31XX_RDACVOL				0xC2
+/* Headset detection */
+#define AIC31XX_HSDETECT				0xC3
+#define AIC31XX_HS_MASK					0x60 /* (0b01100000) */
+#define AIC31XX_HP_MASK					0x20 /* (0b00100000) */
+#define AIC31XX_JACK_DEBOUCE_MASK			0x1C /* (0b00011100) */
+#define AIC31XX_BTN_DEBOUCE_MASK			0x3  /* (0b00000011) */
+#define AIC31XX_ADCSETUP				0xD1
+#define AIC31XX_ADCFGA				0xD2
+#define AIC31XX_ADCMUTE_MASK			0x80
+#define AIC31XX_ADCVOL				0xD3
+
+
+/******************** Page 1 Registers **************************************/
+/* Headphone drivers */
+#define AIC31XX_HPDRIVER				0x11F
+/* Class-D Speakear Amplifier */
+#define AIC31XX_SPKAMP				0x120
+/* HP Output Drivers POP Removal Settings */
+#define AIC31XX_HPPOP				0x121
+/* Output Driver PGA Ramp-Down Period Control */
+#define AIC31XX_SPPGARAMP				0x122
+/* DAC_L and DAC_R Output Mixer Routing */
+#define AIC31XX_DACMIXERROUTE			0x123
+/*Left Analog Vol to HPL */
+#define AIC31XX_LANALOGHPL				0x124
+/* Right Analog Vol to HPR */
+#define AIC31XX_RANALOGHPR			0x125
+/* Left Analog Vol to SPL */
+#define AIC31XX_LANALOGSPL				0x126
+/* Right Analog Vol to SPR */
+#define AIC31XX_RANALOGSPR			0x127
+/* HPL Driver */
+#define AIC31XX_HPLGAIN				0x128
+/* HPR Driver */
+#define AIC31XX_HPRGAIN				0x129
+/* SPL Driver */
+#define AIC31XX_SPLGAIN				0x12A
+/* SPR Driver */
+#define AIC31XX_SPRGAIN				0x12B
+/* HP Driver Control */
+#define AIC31XX_HPCONTROL			0x12C
+/*MICBIAS Configuration Register*/
+#define AIC31XX_MICBIAS			0x12E
+/* MIC PGA*/
+#define AIC31XX_MICPGA				0x12F
+/* Delta-Sigma Mono ADC Channel Fine-Gain Input Selection for P-Terminal */
+#define AIC31XX_MICPGAPI				0x130
+/* ADC Input Selection for M-Terminal */
+#define AIC31XX_MICPGAMI				0x131
+/* Input CM Settings */
+#define AIC31XX_MICPGACM				0x132
+
+/* Timer Clock MCLK Divider */
+#define AIC31XX_TIMERCLOCK				0x210
+#define AIC31XX_CLKSEL_MASK				0x80
+#define AIC31XX_DIVIDER_MASK				0x7F
+
+/* ****************** Page 3 Registers **************************************/
+
+/* Timer Clock MCLK Divider */
+#define AIC31XX_MCLKDIV				0x310
+
+/* ****************** Page 8 Registers **************************************/
+#define AIC31XX_DACADAPTIVE			0x801
+#define AIC31XX_TIME_DELAY			5000
+#define AIC31XX_LDACPWRSTATUS_MASK		0x80
+#define AIC31XX_RDACPWRSTATUS_MASK		0x08
+#define AIC31XX_ADCPWRSTATUS_MASK		0x40
+#define AIC31XX_DELAY_COUNTER			100
+
+
+#endif				/* _TLV320AIC31XX_H */
diff --git a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
index 84f24d6..5c2d473 100644
--- a/sound/soc/intel/Kconfig
+++ b/sound/soc/intel/Kconfig
@@ -31,9 +31,10 @@ config SND_SOC_INTEL_ANCHOR8
           If unsure select "N".
 
 config SND_SOC_INTEL_CHT_T
-	tristate "SOC Machine Audio driver for Intel(R) CHT-T device"
+	tristate "SOC Machine Audio driver for Intel(R) CHT-T4 & CHT-T3 device"
 	depends on X86
 	select SND_SOC_RT5672
+	select SND_SOC_TLV320AIC31XX
 	select SND_SST_PLATFORM
 	select SND_SST_MACHINE
 	select SND_INTEL_SST
@@ -42,7 +43,7 @@ config SND_SOC_INTEL_CHT_T
 
 	help
 	  This adds support for ASoC machine driver for Intel(R) CHT-T device
-          based on the CHT-T platform and RT5672 codec.
+          based on the CHT-T3/T4 platform and RT5672/TLV320AIC31XX codec.
           Say Y if you have such a device
           If unsure select "N".
 
diff --git a/sound/soc/intel/board/Makefile b/sound/soc/intel/board/Makefile
index f4a6f28..988e1d3 100644
--- a/sound/soc/intel/board/Makefile
+++ b/sound/soc/intel/board/Makefile
@@ -13,4 +13,5 @@ obj-$(CONFIG_SND_SOC_INTEL_ANCHOR8) += snd-byt-cr-dpcm-rt5651.o  byt_cr_board_co
 
 # Cherrytrail board
 snd-cht-dpcm-rt5672-objs := cht_bl_dpcm_rt5672.o
-obj-$(CONFIG_SND_SOC_INTEL_CHT_T) += snd-cht-dpcm-rt5672.o
+snd-cht-cr-aic3100-objs := cht_cr_aic3100.o
+obj-$(CONFIG_SND_SOC_INTEL_CHT_T) += snd-cht-dpcm-rt5672.o snd-cht-cr-aic3100.o
diff --git a/sound/soc/intel/board/cht_cr_aic3100.c b/sound/soc/intel/board/cht_cr_aic3100.c
new file mode 100644
index 0000000..847818d
--- /dev/null
+++ b/sound/soc/intel/board/cht_cr_aic3100.c
@@ -0,0 +1,1066 @@
+/*
+ *  cht_cr_aic3100.c - ASoc DPCM Machine driver
+ *  for Intel CherryTrail MID platform
+ *
+ *  Copyright (C) 2014 Intel Corp
+ *  Author: Praveen Diwakar <praveen.diwakar@intel.com>
+ *          Bhakte, GurudattaX <gurudattax.bhakte@intel.com>
+ *  This file is modified from cht_bl_dpcm_rt5672.c for cherrytrail CR
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/vlv2_plat_clock.h>
+#include <linux/mutex.h>
+#include <asm/platform_cht_audio.h>
+#include <asm/intel-mid.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include "../../codecs/tlv320aic31xx.h"
+
+#define CHT_PLAT_CLK_3_HZ	25000000
+
+#define CHT_INTR_DEBOUNCE               2000
+#define CHT_HS_INSERT_DET_DELAY         100
+#define CHT_HS_REMOVE_DET_DELAY         100
+#define CHT_BUTTON_DET_DELAY            50
+#define CHT_HS_DET_POLL_INTRVL          100
+#define CHT_BUTTON_EN_DELAY             1500
+
+#define CHT_HS_DET_RETRY_COUNT          6
+
+struct cht_mc_private {
+	struct snd_soc_jack jack;
+	struct delayed_work hs_insert_work;
+	struct delayed_work hs_remove_work;
+	struct delayed_work hs_button_work;
+	struct delayed_work hs_button_release_work;
+	struct mutex jack_mlock;
+	/* To enable button press interrupts after a delay after HS detection.
+	 * This is to avoid spurious button press events during slow
+	 * HS insertion
+	 */
+	struct delayed_work hs_button_en_work;
+	int intr_debounce;
+	int hs_insert_det_delay;
+	int hs_remove_det_delay;
+	int button_det_delay;
+	int button_release_delay;
+	int button_en_delay;
+	int hs_det_poll_intrvl;
+	int hs_det_retry;
+	bool process_button_events;
+
+};
+
+static int cht_hs_detection(void *);
+
+static struct snd_soc_jack_gpio hs_gpio = {
+		.name			= "cht-codec-int",
+		.report			= SND_JACK_HEADSET |
+					  SND_JACK_HEADPHONE |
+					  SND_JACK_BTN_0,
+		.debounce_time		= CHT_INTR_DEBOUNCE,
+		.jack_status_check	= cht_hs_detection,
+};
+static inline void cht_force_enable_pin(struct snd_soc_codec *codec,
+			 const char *bias_widget, bool enable)
+{
+	pr_debug("%s %s\n", enable ? "enable" : "disable", bias_widget);
+	if (enable)
+		snd_soc_dapm_force_enable_pin(&codec->dapm, bias_widget);
+	else
+		snd_soc_dapm_disable_pin(&codec->dapm, bias_widget);
+}
+
+static inline void cht_set_mic_bias(struct snd_soc_codec *codec, bool enable)
+{
+	if (enable)
+		cht_force_enable_pin(codec, "micbias", true);
+	else
+		cht_force_enable_pin(codec, "micbias", true);
+	snd_soc_dapm_sync(&codec->dapm);
+}
+
+static inline void cht_set_codec_power(struct snd_soc_codec *codec,
+								int jack_type)
+{
+	switch (jack_type) {
+	case SND_JACK_HEADSET:
+		cht_force_enable_pin(codec, "micbias2", true);
+		cht_force_enable_pin(codec, "JD Power", true);
+		cht_force_enable_pin(codec, "Mic Det Power", true);
+		break;
+	case SND_JACK_HEADPHONE:
+		cht_force_enable_pin(codec, "JD Power", true);
+		cht_force_enable_pin(codec, "Mic Det Power", false);
+		cht_force_enable_pin(codec, "micbias2", false);
+		break;
+	case 0:
+		cht_force_enable_pin(codec, "JD Power", false);
+		cht_force_enable_pin(codec, "Mic Det Power", false);
+		cht_force_enable_pin(codec, "micbias2", false);
+	       break;
+	default:
+		return;
+	}
+	snd_soc_dapm_sync(&codec->dapm);
+}
+/* Identify the jack type as Headset/Headphone/None */
+static int cht_check_jack_type(struct snd_soc_jack *jack,
+					struct snd_soc_codec *codec)
+{
+	int status, jack_type = 0;
+	struct cht_mc_private *ctx = container_of(jack,
+					struct cht_mc_private, jack);
+
+	status = aic31xx_query_jack_status(codec);
+	/* jd status high indicates some accessory has been connected */
+	if (status) {
+		pr_debug("Jack insert intr");
+		/* Do not process button events until
+		accessory is detected as headset*/
+		ctx->process_button_events = false;
+		cht_set_mic_bias(codec, true);
+		jack_type = aic31xx_query_jack_status(codec);
+		if (jack_type == SND_JACK_HEADSET) {
+			ctx->process_button_events = true;
+			/* If headset is detected, enable
+			button interrupts after a delay */
+			schedule_delayed_work(&ctx->hs_button_en_work,
+					msecs_to_jiffies(ctx->button_en_delay));
+		}
+		if (jack_type != SND_JACK_HEADSET)
+			cht_set_mic_bias(codec, false);
+	} else
+		jack_type = 0;
+
+	pr_debug("Jack type detected:%d", jack_type);
+
+	return jack_type;
+}
+
+/* Work function invoked by the Jack Infrastructure.
+ * Other delayed works for jack detection/removal/button
+ * press are scheduled from this function
+ */
+static int cht_hs_detection(void *data)
+{
+	int status, jack_type = 0;
+	static int boot_debounce;
+	int ret, val, instantaneous;
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(jack,
+						struct cht_mc_private, jack);
+
+	/* Ack interrupt first */
+	val = snd_soc_read(codec, AIC31XX_INTRDACFLAG);
+	instantaneous = snd_soc_read(codec, AIC31XX_INTRFLAG);
+
+	mutex_lock(&ctx->jack_mlock);
+	/* Initialize jack status with previous status.
+	 * Delayed work will confirm the event and send updated status later
+	 */
+	jack_type = jack->status;
+	pr_debug("Enter:%s Page0/44=0x%x, Page0/46=0x%x", __func__,
+						val, instantaneous);
+
+	/* Debounce time for boot is 2 second due to noise from hardarware jack
+	   which generates spurious interrupt. After boot debounce time is again
+	   set to 100ms */
+	if (!boot_debounce) {
+		gpio->debounce_time = 100;
+		boot_debounce = 1;
+	}
+
+	if ((!jack->status) && (val & AIC31XX_HSPLUG_MASK)) {
+		ctx->hs_det_retry = CHT_HS_DET_RETRY_COUNT;
+		ret = schedule_delayed_work(&ctx->hs_insert_work,
+				msecs_to_jiffies(ctx->hs_insert_det_delay));
+		if (!ret)
+			pr_debug("cht_check_hs_insert_status already queued");
+		else
+			pr_debug("%s:Check hs insertion  after %d msec",
+					__func__, ctx->hs_insert_det_delay);
+
+	} else {
+		/* First check for accessory removal; If not removed,
+		 * check for button events
+		 */
+		status = aic31xx_query_jack_status(codec);
+		/* jd status low indicates accessory has been disconnected.
+		 * However, confirm the removal in the delayed work
+		 */
+		if ((!status) && (val & AIC31XX_HSPLUG_MASK)) {
+			/* Do not process button events while we make sure
+			 * accessory is disconnected
+			 */
+			ctx->process_button_events = false;
+			ret = schedule_delayed_work(&ctx->hs_remove_work,
+				msecs_to_jiffies(ctx->hs_remove_det_delay));
+			if (!ret)
+				pr_debug("remove work already queued");
+			else
+				pr_debug("%s:Check hs removal after %d msec",
+					__func__, ctx->hs_remove_det_delay);
+		} else {
+			/* Must be button event.
+			Confirm the event in delayed work*/
+			if (((jack->status & SND_JACK_HEADSET) ==
+						SND_JACK_HEADSET) &&
+					ctx->process_button_events) {
+				ret = schedule_delayed_work(
+					&ctx->hs_button_work,
+					msecs_to_jiffies(
+						ctx->button_det_delay));
+				if (!ret)
+					pr_debug("button_work already queued");
+				else
+					pr_debug("%s:check BP/BR after %d msec",
+					__func__, ctx->button_det_delay);
+			}
+		}
+	}
+
+	mutex_unlock(&ctx->jack_mlock);
+	pr_debug("Exit:%s", __func__);
+	return jack_type;
+}
+/* Checks jack insertion and identifies the jack type.
+ * Retries the detection if necessary
+ */
+static void cht_check_hs_insert_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work,
+				struct cht_mc_private, hs_insert_work.work);
+	int jack_type = 0;
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s", __func__);
+
+	jack_type = cht_check_jack_type(jack, codec);
+
+	/* Report jack immediately only if jack is headset.
+	 * If headphone or no jack was detected, dont report it
+	 * until the last HS det try.
+	 * This is to avoid reporting any temporary jack removal or
+	 * accessory change (eg, HP to HS) during the detection tries.
+	 * This provides additional debounce that will help in the case
+	 * of slow insertion.
+	 * This also avoids the pause in audio due to accessory change
+	 * from HP to HS
+	 */
+	if (ctx->hs_det_retry <= 0) {
+		/* end of retries; report the status */
+		snd_soc_jack_report(jack, jack_type, gpio->report);
+	} else {
+		/* Schedule another detection try if headphone or no jack
+		 * is detected.During slow insertion of headset, first a
+		 * headphone may be detected.
+		 * Hence retry until headset is detected
+		 */
+		if (jack_type == SND_JACK_HEADSET) {
+			ctx->hs_det_retry = 0;
+			/* HS detected, no more retries needed */
+			snd_soc_jack_report(jack, jack_type, gpio->report);
+		} else {
+			ctx->hs_det_retry--;
+			schedule_delayed_work(&ctx->hs_insert_work,
+				msecs_to_jiffies(ctx->hs_det_poll_intrvl));
+			pr_debug("%s:re-try hs detection after %d msec",
+					__func__, ctx->hs_det_poll_intrvl);
+		}
+	}
+
+	pr_debug("Exit:%s", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+/* Checks jack removal. */
+static void cht_check_hs_remove_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work,
+			struct cht_mc_private, hs_remove_work.work);
+	int status = 0, jack_type = 0;
+
+	/* Cancel any pending insertion detection.
+	 * There could be pending insertion detection in the
+	 * case of very slow insertion or insertion and immediate removal.
+	 */
+	cancel_delayed_work_sync(&ctx->hs_insert_work);
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s", __func__);
+	/* Initialize jack_type with previous status.
+	 * If the event was an invalid one, we return the previous state
+	 */
+	jack_type = jack->status;
+
+	if (jack->status) {
+		/* jack is in connected state; look for removal event */
+		status = aic31xx_query_jack_status(codec);
+		if (!status) {
+			/* jd status high implies accessory disconnected */
+			pr_debug("Jack remove event");
+			ctx->process_button_events = false;
+			cancel_delayed_work_sync(&ctx->hs_button_en_work);
+			jack_type = 0;
+			cht_set_mic_bias(codec, false);
+			aic31xx_btn_press_intr_enable(codec, false);
+
+		} else if (((jack->status & SND_JACK_HEADSET) ==
+				SND_JACK_HEADSET)
+				&& !ctx->process_button_events) {
+			/* Jack is still connected. We may come here if there
+			 * was a spurious jack removal event. No state change
+			 * is done until removal is confirmed by the
+			 * check_jd_status above.i.e. jack status remains
+			 * Headset or headphone.But as soon as the interrupt
+			 * thread(cht_hs_detection) detected a jack removal,
+			 * button processing gets disabled. Hence re-enable
+			 * button processing in the case of headset.
+			 */
+			pr_debug("spurious Jack remove event for headset");
+			pr_debug("re-enable button events");
+			ctx->process_button_events = true;
+		}
+	}
+	snd_soc_jack_report(jack, jack_type, gpio->report);
+	pr_debug("Exit:%s", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+/* Check for button press/release */
+static void cht_check_hs_button_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work,
+			struct cht_mc_private, hs_button_work.work);
+	int status = 0, jack_type = 0;
+	int ret;
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s", __func__);
+	/* Initialize jack_type with previous status.
+	 * If the event was an invalid one, we return the preious state
+	 */
+	jack_type = jack->status;
+
+	if (((jack->status & SND_JACK_HEADSET) == SND_JACK_HEADSET)
+			&& ctx->process_button_events) {
+
+		status = aic31xx_query_jack_status(codec);
+		if (status) {
+			/* confirm jack is connected */
+			status = aic31xx_query_btn_press(codec);
+			if (status & SND_JACK_BTN_0) {
+				jack_type = SND_JACK_HEADSET | SND_JACK_BTN_0;
+				pr_debug("%d Jack type sent is %d\n",
+					__LINE__, jack_type);
+				snd_soc_jack_report(jack, jack_type,
+							gpio->report);
+
+				/* Since there is not button_relese interrupt
+				   schedule delayed work to poll for button
+				   release status
+				*/
+				ret = schedule_delayed_work(
+					&ctx->hs_button_release_work,
+					msecs_to_jiffies(
+						ctx->button_det_delay));
+			}
+		}
+	}
+	pr_debug("Exit:%s", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+
+
+/* Check for button release */
+static void cht_check_hs_button_release_status(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work, struct cht_mc_private,
+					hs_button_release_work.work);
+	int status = 0, jack_type = 0;
+	int ret;
+
+	mutex_lock(&ctx->jack_mlock);
+	pr_debug("Enter:%s\n", __func__);
+	jack_type = jack->status;
+
+	if (((jack->status & SND_JACK_HEADSET) == SND_JACK_HEADSET)
+			&& ctx->process_button_events) {
+
+		status = aic31xx_query_jack_status(codec);
+		if (status) { /* confirm jack is connected */
+
+			status = aic31xx_query_btn_press(codec);
+			if (!(status & SND_JACK_BTN_0)) {
+				jack_type = SND_JACK_HEADSET;
+				pr_debug("%d Jack type sent is %d\n",
+					__LINE__, jack_type);
+				snd_soc_jack_report(jack, jack_type,
+					gpio->report);
+			} else {
+				/* Schedule again */
+				ret = schedule_delayed_work(
+					&ctx->hs_button_release_work,
+					msecs_to_jiffies(
+						ctx->button_det_delay));
+			}
+		}
+	}
+
+	pr_debug("Exit:%s\n", __func__);
+	mutex_unlock(&ctx->jack_mlock);
+}
+
+
+/* Delayed work for enabling the overcurrent detection circuit
+ * and interrupt for generating button events */
+static void cht_enable_hs_button_events(struct work_struct *work)
+{
+	struct snd_soc_jack_gpio *gpio = &hs_gpio;
+	struct snd_soc_jack *jack = gpio->jack;
+	struct snd_soc_codec *codec = jack->codec;
+	struct cht_mc_private *ctx = container_of(work, struct cht_mc_private,
+			 hs_button_en_work.work);
+
+	int status = aic31xx_query_jack_status(codec);
+	if (status == SND_JACK_HEADSET)
+		ctx->process_button_events = true;
+	else
+		ctx->process_button_events = false;
+	aic31xx_btn_press_intr_enable(codec, ctx->process_button_events);
+}
+
+static inline struct snd_soc_codec *cht_get_codec(struct snd_soc_card *card)
+{
+	bool found = false;
+	struct snd_soc_codec *codec;
+
+	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
+		if (!strstr(codec->name, "i2c-10TI3100:00")) {
+			pr_debug("codec was %s", codec->name);
+			continue;
+		} else {
+			found = true;
+			break;
+		}
+	}
+	if (found == false) {
+		pr_err("%s: cant find codec", __func__);
+		return NULL;
+	}
+	return codec;
+}
+
+#define VLV2_PLAT_CLK_AUDIO	3
+#define PLAT_CLK_FORCE_ON	1
+#define PLAT_CLK_FORCE_OFF	2
+static int platform_clock_control(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *k, int  event)
+{
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct snd_soc_codec *codec;
+
+	codec = cht_get_codec(card);
+	if (!codec) {
+		pr_err("Codec not found; Unable to set platform clock\n");
+		return -EIO;
+	}
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO,
+				PLAT_CLK_FORCE_ON);
+		pr_debug("Platform clk turned ON\n");
+		snd_soc_codec_set_sysclk(codec, AIC31XX_MCLK,
+				0, AIC31XX_FREQ_25000000, SND_SOC_CLOCK_IN);
+	} else {
+		/* Set codec clock source to internal clock before
+		 * turning off the platform clock. Codec needs clock
+		 * for Jack detection and button press
+		 */
+		snd_soc_codec_set_sysclk(codec, AIC31XX_INTERNALCLOCK,
+				0, 0, SND_SOC_CLOCK_IN);
+		vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO,
+				PLAT_CLK_FORCE_OFF);
+		pr_debug("Platform clk turned OFF\n");
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget cht_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Internal Mic", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_SUPPLY("Platform Clock", SND_SOC_NOPM, 0, 0,
+			platform_clock_control, SND_SOC_DAPM_PRE_PMU|
+			SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_route cht_audio_map[] = {
+		/* External Speakers: HFL, HFR */
+		{"Ext Spk", NULL, "SPK"},
+		{"micbias", NULL, "Internal Mic"},
+		/* Headset Mic: Headset Mic with bias */
+		{"MIC1RP", NULL, "Headset Mic"},
+
+		/* Headset Stereophone(Headphone): HSOL, HSOR */
+		{"Headphone", NULL, "HPL"},
+		{"Headphone", NULL, "HPR"},
+
+		{"Playback", NULL, "ssp2 Tx"},
+		{"ssp2 Tx", NULL, "codec_out0"},
+		{"ssp2 Tx", NULL, "codec_out1"},
+		{"codec_in0", NULL, "ssp2 Rx"},
+		{"codec_in1", NULL, "ssp2 Rx"},
+		{"ssp2 Rx", NULL, "Capture"},
+		{"ssp0 Tx", NULL, "modem_out"},
+		{"modem_in", NULL, "ssp0 Rx"},
+		{"ssp1 Tx", NULL, "bt_fm_out"},
+		{"bt_fm_in", NULL, "ssp1 Rx"},
+		{"Playback", NULL, "Platform Clock"},
+		{"Capture", NULL, "Platform Clock"},
+};
+
+static const struct snd_kcontrol_new cht_mc_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Internal Mic"),
+	SOC_DAPM_PIN_SWITCH("Ext Spk"),
+};
+
+
+static int cht_set_dai_fmt_pll(struct snd_soc_dai *codec_dai,
+			int source, unsigned int freq_out)
+{
+	int ret;
+	unsigned int fmt;
+	/* Set codec DAI configuration */
+	/* I2S Slave Mode`*/
+	fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF |
+			SND_SOC_DAIFMT_CBS_CFS;
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_err("can't set codec DAI configuration %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_pll(codec_dai, 0, source,
+			CHT_PLAT_CLK_3_HZ, freq_out);
+	if (ret < 0) {
+		pr_err("can't set codec pll: %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int cht_aif1_hw_params(struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	pr_err("Enter:%s", __func__);
+	/* Setecodec DAI confinuration */
+	if (strncmp(codec_dai->name, "tlv320aic31xx-codec", 19))
+		return 0;
+
+	return cht_set_dai_fmt_pll(codec_dai, AIC31XX_PLL_CLKIN_MCLK,
+			params_rate(params));
+}
+
+static int cht_compr_set_params(struct snd_compr_stream *cstream)
+{
+	return 0;
+}
+
+static const struct snd_soc_pcm_stream cht_dai_params = {
+	.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	.rate_min = 48000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+};
+
+static struct snd_soc_compr_ops cht_compr_ops = {
+	.set_params = cht_compr_set_params,
+};
+
+static int cht_codec_fixup(struct snd_soc_pcm_runtime *rtd,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	pr_debug("Invoked %s for dailink %s\n", __func__, rtd->dai_link->name);
+
+	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 4;
+	/* set SSP2 to 24-bit */
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				    SNDRV_PCM_FORMAT_S24_LE);
+	return 0;
+}
+
+static int cht_set_bias_level(struct snd_soc_card *card,
+				struct snd_soc_dapm_context *dapm,
+				enum snd_soc_bias_level level)
+{
+	int ret = 0;
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+	case SND_SOC_BIAS_STANDBY:
+	case SND_SOC_BIAS_OFF:
+		card->dapm.bias_level = level;
+		pr_debug("card(%s)->bias_level %u\n", card->name,
+				card->dapm.bias_level);
+		break;
+	default:
+		pr_err("%s: Invalid bias level=%d\n", __func__, level);
+		ret =  -EINVAL;
+	}
+
+	return ret;
+}
+
+static int cht_audio_init(struct snd_soc_pcm_runtime *runtime)
+{
+	int ret;
+	struct snd_soc_codec *codec;
+	struct snd_soc_card *card = runtime->card;
+	struct cht_mc_private *ctx = snd_soc_card_get_drvdata(runtime->card);
+	struct gpio_desc *desc;
+	pr_debug("Enter:%s", __func__);
+
+	codec = cht_get_codec(card);
+	if (!codec) {
+		pr_err("Codec not found: %s:failed\n", __func__);
+		return -EIO;
+	}
+	desc = devm_gpiod_get_index(codec->dev, NULL, 1);
+	if (!IS_ERR(desc)) {
+		hs_gpio.gpio = desc_to_gpio(desc);
+		devm_gpiod_put(codec->dev, desc);
+		pr_info("cht-cr GPIOs - JD/BP-int: %d\n", hs_gpio.gpio);
+	} else {
+		hs_gpio.gpio = -1;
+		pr_err("Failed to get gpio desc for Jack det\n");
+	}
+	pr_debug("hs codec gpio %d\n", hs_gpio.gpio);
+
+	/* Set codec bias level */
+	cht_set_bias_level(card, &card->dapm, SND_SOC_BIAS_OFF);
+	card->dapm.idle_bias_off = true;
+
+	/* Headset jack detection */
+	ret = snd_soc_jack_new(codec, "Headset Jack",
+			SND_JACK_HEADSET | SND_JACK_HEADPHONE | SND_JACK_BTN_0,
+			 &ctx->jack);
+	if (ret) {
+		pr_err("Jack creation failed\n");
+		return ret;
+	}
+	snd_jack_set_key(ctx->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+
+	ret = snd_soc_jack_add_gpios(&ctx->jack, 1, &hs_gpio);
+	if (ret) {
+		pr_err("Adding jack GPIO failed with error %d\n", ret);
+		return ret;
+	}
+
+
+	ret = snd_soc_add_card_controls(card, cht_mc_controls,
+					ARRAY_SIZE(cht_mc_controls));
+	if (ret) {
+		pr_err("unable to add card controls\n");
+		return ret;
+	}
+
+	cht_set_mic_bias(codec, true);
+	ret = snd_soc_dapm_sync(&card->dapm);
+	if (ret) {
+		pr_err("unable to sync dapm\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+static unsigned int rates_8000_16000[] = {
+	8000,
+	16000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_8000_16000 = {
+	.count = ARRAY_SIZE(rates_8000_16000),
+	.list  = rates_8000_16000,
+};
+
+static unsigned int rates_48000[] = {
+	48000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_48000 = {
+	.count = ARRAY_SIZE(rates_48000),
+	.list  = rates_48000,
+};
+
+static int cht_aif1_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_48000);
+}
+
+static struct snd_soc_ops cht_aif1_ops = {
+	.startup = cht_aif1_startup,
+};
+
+static int cht_8k_16k_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_8000_16000);
+}
+
+static struct snd_soc_ops cht_8k_16k_ops = {
+	.startup = cht_8k_16k_startup,
+	.hw_params = cht_aif1_hw_params,
+};
+
+static struct snd_soc_ops cht_be_ssp2_ops = {
+	.hw_params = cht_aif1_hw_params,
+};
+
+
+static struct snd_soc_dai_link cht_dailink[] = {
+	[CHT_DPCM_AUDIO] = {
+		.name = "Cherrytrail Audio Port",
+		.stream_name = "Cherrytrail Audio",
+		.cpu_dai_name = "Headset-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "sst-platform",
+		.init = cht_audio_init,
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &cht_aif1_ops,
+	},
+	[CHT_DPCM_DB] = {
+		.name = "Cherrytrail DB Audio Port",
+		.stream_name = "Deep Buffer Audio",
+		.cpu_dai_name = "Deepbuffer-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &cht_aif1_ops,
+		.dpcm_playback = 1,
+	},
+	[CHT_DPCM_COMPR] = {
+		.name = "Cherrytrail Compressed Port",
+		.stream_name = "Cherrytrail Compress",
+		.cpu_dai_name = "Compress-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.compr_ops = &cht_compr_ops,
+	},
+	[CHT_DPCM_VOIP] = {
+		.name = "Cherrytrail VOIP Port",
+		.stream_name = "Cherrytrail Voip",
+		.cpu_dai_name = "Voip-cpu-dai",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.init = NULL,
+		.ignore_suspend = 1,
+		.ops = &cht_8k_16k_ops,
+		.dynamic = 1,
+	},
+	[CHT_DPCM_PROBE] = {
+		.name = "Cherrytrail Probe Port",
+		.stream_name = "Cherrytrail Probe",
+		.cpu_dai_name = "Probe-cpu-dai",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.playback_count = 8,
+		.capture_count = 8,
+	},
+	/* CODEC<->CODEC link */
+	{
+		.name = "Cherrytrail Codec-Loop Port",
+		.stream_name = "Cherrytrail Codec-Loop",
+		.cpu_dai_name = "ssp2-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "tlv320aic31xx-codec",
+		.codec_name = "i2c-10TI3100:00",
+		.params = &cht_dai_params,
+		.dsp_loopback = true,
+	},
+	{
+		.name = "Cherrytrail Modem-Loop Port",
+		.stream_name = "Cherrytrail Modem-Loop",
+		.cpu_dai_name = "ssp0-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.params = &cht_dai_params,
+		.dsp_loopback = true,
+	},
+	{
+		.name = "Cherrytrail BTFM-Loop Port",
+		.stream_name = "Cherrytrail BTFM-Loop",
+		.cpu_dai_name = "ssp1-port",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.params = &cht_dai_params,
+		.dsp_loopback = true,
+	},
+	/* Back ends */
+	{
+		.name = "SSP2-Codec",
+		.be_id = 1,
+		.cpu_dai_name = "ssp2-port",
+		.platform_name = "sst-platform",
+		.no_pcm = 1,
+		.codec_dai_name = "tlv320aic31xx-codec",
+		.codec_name = "i2c-10TI3100:00",
+		.be_hw_params_fixup = cht_codec_fixup,
+		.ignore_suspend = 1,
+		.ops = &cht_be_ssp2_ops,
+	},
+	{
+		.name = "SSP1-BTFM",
+		.be_id = 2,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "SSP0-Modem",
+		.be_id = 3,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int snd_cht_prepare(struct device *dev)
+{
+	pr_debug("In %s device name\n", __func__);
+	return snd_soc_suspend(dev);
+}
+
+static void snd_cht_complete(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	snd_soc_resume(dev);
+}
+
+static int snd_cht_poweroff(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	return snd_soc_poweroff(dev);
+}
+#else
+#define snd_cht_prepare NULL
+#define snd_cht_complete NULL
+#define snd_cht_poweroff NULL
+#endif
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_cht = {
+	.name = "cherrytrailaud",
+	.dai_link = cht_dailink,
+	.num_links = ARRAY_SIZE(cht_dailink),
+	.set_bias_level = cht_set_bias_level,
+	.dapm_widgets = cht_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(cht_dapm_widgets),
+	.dapm_routes = cht_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(cht_audio_map),
+	.controls = cht_mc_controls,
+	.num_controls = ARRAY_SIZE(cht_mc_controls),
+};
+
+static int snd_cht_mc_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	struct cht_mc_private *drv;
+
+	pr_debug("Entry %s\n", __func__);
+
+	/* Audio Platform clock is on by default. The machine driver requests
+	 * this clock to be turned ON and OFF on playing any stream. But
+	 * until any stream is played the clock remains ON. Hence request the
+	 * clock to be turned OFF initially.
+	vlv2_plat_configure_clock(VLV2_PLAT_CLK_AUDIO, PLAT_CLK_FORCE_OFF);
+	 */
+
+	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_ATOMIC);
+	if (!drv) {
+		pr_err("allocation failed\n");
+		return -ENOMEM;
+	}
+
+
+	drv->intr_debounce = CHT_INTR_DEBOUNCE;
+	drv->hs_insert_det_delay = CHT_HS_INSERT_DET_DELAY;
+	drv->hs_remove_det_delay = CHT_HS_REMOVE_DET_DELAY;
+	drv->hs_det_poll_intrvl = CHT_HS_DET_POLL_INTRVL;
+	drv->hs_det_retry = CHT_HS_DET_RETRY_COUNT;
+	drv->button_det_delay = CHT_BUTTON_DET_DELAY;
+	drv->button_release_delay = CHT_BUTTON_DET_DELAY;
+	drv->button_en_delay = CHT_BUTTON_EN_DELAY;
+	drv->process_button_events = false;
+
+	INIT_DELAYED_WORK(&drv->hs_insert_work, cht_check_hs_insert_status);
+	INIT_DELAYED_WORK(&drv->hs_remove_work, cht_check_hs_remove_status);
+	INIT_DELAYED_WORK(&drv->hs_button_work,
+			cht_check_hs_button_status);
+	INIT_DELAYED_WORK(&drv->hs_button_release_work,
+				cht_check_hs_button_release_status);
+	INIT_DELAYED_WORK(&drv->hs_button_en_work, cht_enable_hs_button_events);
+	mutex_init(&drv->jack_mlock);
+	/* register the soc card */
+	snd_soc_card_cht.dev = &pdev->dev;
+	snd_soc_card_set_drvdata(&snd_soc_card_cht, drv);
+	ret_val = snd_soc_register_card(&snd_soc_card_cht);
+	if (ret_val) {
+		pr_err("snd_soc_register_card failed %d\n", ret_val);
+		return ret_val;
+	}
+	platform_set_drvdata(pdev, &snd_soc_card_cht);
+	pr_info("%s successful\n", __func__);
+	return ret_val;
+}
+
+static void snd_cht_unregister_jack(struct cht_mc_private *ctx)
+{
+	/* Set process button events to false so that the button
+	   delayed work will not be scheduled.*/
+	ctx->process_button_events = false;
+	cancel_delayed_work_sync(&ctx->hs_insert_work);
+	cancel_delayed_work_sync(&ctx->hs_button_en_work);
+	cancel_delayed_work_sync(&ctx->hs_button_work);
+	cancel_delayed_work_sync(&ctx->hs_button_release_work);
+	cancel_delayed_work_sync(&ctx->hs_remove_work);
+	snd_soc_jack_free_gpios(&ctx->jack, 1, &hs_gpio);
+}
+
+static int snd_cht_mc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct cht_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+	snd_cht_unregister_jack(drv);
+	snd_soc_card_set_drvdata(soc_card, NULL);
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static void snd_cht_mc_shutdown(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct cht_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+	snd_cht_unregister_jack(drv);
+}
+
+const struct dev_pm_ops snd_cht_cr_mc_pm_ops = {
+	.prepare = snd_cht_prepare,
+	.complete = snd_cht_complete,
+	.poweroff = snd_cht_poweroff,
+};
+
+static struct platform_driver snd_cht_mc_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "cht_aic31xx",
+		.pm = &snd_cht_cr_mc_pm_ops,
+	},
+	.probe = snd_cht_mc_probe,
+	.remove = snd_cht_mc_remove,
+	.shutdown = snd_cht_mc_shutdown,
+};
+
+static int __init snd_cht_driver_init(void)
+{
+	int ret;
+	ret = platform_driver_register(&snd_cht_mc_driver);
+	if (ret)
+		pr_err("Fail to register Cherrytrail Machine driver cht_aic31xx\n");
+	else
+		pr_info("Cherrytrail Machine Driver cht_aic31xx registerd\n");
+	return ret;
+}
+late_initcall(snd_cht_driver_init);
+
+static void __exit snd_cht_driver_exit(void)
+{
+	pr_debug("In %s\n", __func__);
+	platform_driver_unregister(&snd_cht_mc_driver);
+}
+module_exit(snd_cht_driver_exit);
+
+MODULE_DESCRIPTION("ASoC Intel(R) Cherrytrail CR Machine driver");
+MODULE_AUTHOR("Praveen Diwakar <praveen.diwakar@intel.com>");
+MODULE_AUTHOR("Bhakte, GurudattaX <gurudattax.bhakte@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:cht_aic3100");
diff --git a/sound/soc/intel/sst/sst.c b/sound/soc/intel/sst/sst.c
index 9405bce..abc0b6b 100644
--- a/sound/soc/intel/sst/sst.c
+++ b/sound/soc/intel/sst/sst.c
@@ -45,6 +45,7 @@
 #include <asm/intel-mid.h>
 #include <asm/platform_sst_audio.h>
 #include <asm/platform_sst.h>
+#include <linux/dmi.h>
 #include "../sst_platform.h"
 #include "../platform_ipc_v2.h"
 #include "sst.h"
@@ -618,6 +619,12 @@ static struct platform_device cht_t_mach_dev = {
 	.num_resources  = 0,
 };
 
+static struct platform_device cht_cr_mach_dev = {
+	.name           = "cht_aic31xx",
+	.id             = -1,
+	.num_resources  = 0,
+};
+
 void sst_init_lib_mem_mgr(struct intel_sst_drv *ctx)
 {
 	struct sst_mem_mgr *mgr = &ctx->lib_mem_mgr;
@@ -638,6 +645,7 @@ int sst_request_firmware_async(struct intel_sst_drv *ctx)
 	int ret = 0;
 	struct mach_codec_link const *mc_link;
 	struct board_config const *conf;
+	const char *board_name;
 
 	ret = sst_audio_platform_init(ctx->pci_id);
 	if (ret) {
@@ -661,12 +669,26 @@ int sst_request_firmware_async(struct intel_sst_drv *ctx)
 		snprintf(ctx->firmware_name, sizeof(ctx->firmware_name),
 				"fw_sst_%04x.bin", ctx->pci_id);
 
-		pr_info("Registering machine device %s\n", cht_t_mach_dev.name);
-		ret = platform_device_register(&cht_t_mach_dev);
-		if (ret) {
-			pr_err("failed to register machine device %s\n",
-					cht_t_mach_dev.name);
-			return -ENOENT;
+		board_name = dmi_get_system_info(DMI_BOARD_NAME);
+		if (strcmp(board_name, "Cherry Trail CR") == 0) {
+			pr_info("Registering machine device %s\n",
+						cht_cr_mach_dev.name);
+			ret = platform_device_register(&cht_cr_mach_dev);
+			if (ret) {
+				pr_err("failed to register machine device %s\n",
+						cht_cr_mach_dev.name);
+				return -ENOENT;
+			}
+		} else if ((strcmp(board_name, "Cherry Trail Tablet") == 0) ||
+				(strcmp(board_name, "Cherry Trail FFD") == 0)) {
+			pr_info("Registering machine device %s\n",
+						cht_t_mach_dev.name);
+			ret = platform_device_register(&cht_t_mach_dev);
+			if (ret) {
+				pr_err("failed to register machine device %s\n",
+						cht_t_mach_dev.name);
+				return -ENOENT;
+			}
 		}
 
 	} else {
-- 
1.9.1

