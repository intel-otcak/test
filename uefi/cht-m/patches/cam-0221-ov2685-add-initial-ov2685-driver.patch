From 019d4ce889bd3c1514c910f217820280c9101c95 Mon Sep 17 00:00:00 2001
From: Shuguang Gong <shuguang.gong@intel.com>
Date: Thu, 19 Jun 2014 14:20:07 +0800
Subject: [PATCH 221/230] ov2685: add initial ov2685 driver

Add initial ov2685 driver

Change-Id: Ia3f77b1b8da084e9edf93e6c7f593995314a6232
Tracked-On: https://jira01.devtools.intel.com/browse/IMINAN-15968
Signed-off-by: Shuguang Gong <shuguang.gong@intel.com>
Reviewed-on: https://android.intel.com:443/314863
Reviewed-on: https://icggerrit.ir.intel.com/35725
Approver: Wei Tao <wei.tao@intel.com>
Reviewed-by: Wei Tao <wei.tao@intel.com>
---
 .../camera/drivers/media/i2c/Kconfig               |   10 +
 .../camera/drivers/media/i2c/Makefile              |    1 +
 .../camera/drivers/media/i2c/ov2685.c              | 1095 ++++++++++++++++++++
 .../camera/drivers/media/i2c/ov2685.h              |  988 ++++++++++++++++++
 4 files changed, 2094 insertions(+)
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov2685.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/i2c/ov2685.h

diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
index 019d4b1..16d88eb 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Kconfig
@@ -18,6 +18,16 @@ config VIDEO_OV9724
 
          It currently only works with the atomisp driver.
 
+config VIDEO_OV2685
+        tristate "OVT ov2685 sensor support"
+        depends on I2C && VIDEO_V4L2
+        ---help---
+          This is a Video4Linux2 sensor-level driver for the OVT
+          OV2685 soc camera.
+
+          OVT is a 2M soc sensor.
+
+          It currently only works with the atomisp driver.
 config VIDEO_OV2722
        tristate "OVT ov2722 sensor support"
        depends on I2C && VIDEO_V4L2
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/Makefile b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
index 7898f25..5c874a8 100644
--- a/drivers/external_drivers/camera/drivers/media/i2c/Makefile
+++ b/drivers/external_drivers/camera/drivers/media/i2c/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_VIDEO_MT9V113)    += mt9v113.o
 obj-$(CONFIG_VIDEO_OV5640)     += ov5640.o
 
 obj-$(CONFIG_VIDEO_GC2235)     += gc2235.o
+obj-$(CONFIG_VIDEO_OV2685)     += ov2685.o
 obj-$(CONFIG_VIDEO_OV9724)     += ov9724.o
 obj-$(CONFIG_VIDEO_OV2722)     += ov2722.o
 obj-$(CONFIG_VIDEO_OV8830)     += ov8830.o
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov2685.c b/drivers/external_drivers/camera/drivers/media/i2c/ov2685.c
new file mode 100644
index 0000000..146c94d
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov2685.c
@@ -0,0 +1,1095 @@
+/*
+ * Support for ov2685 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kmod.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/firmware.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#include "ov2685.h"
+
+#define to_ov2685_sensor(sd) container_of(sd, struct ov2685_device, sd)
+
+static int
+ov2685_read_reg(struct i2c_client *client, u16 data_length, u16 reg, u16 *val)
+{
+	int err;
+	struct i2c_msg msg[2];
+	unsigned char data[4];
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(msg, 0 , sizeof(msg));
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = MSG_LEN_OFFSET;
+	msg[0].buf = data;
+
+	/* high byte goes out first */
+	data[0] = (u8)(reg >> 8);
+	data[1] = (u8)(reg & 0xff);
+
+	msg[1].addr = client->addr;
+	msg[1].len = data_length;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+
+	err = i2c_transfer(client->adapter, msg, 2);
+	if (err != 2) {
+		if (err >= 0)
+			err = -EIO;
+		goto error;
+	}
+
+	*val = 0;
+	/* high byte comes first */
+	if (data_length == MISENSOR_8BIT)
+		*val = (u8)data[0];
+	else if (data_length == MISENSOR_16BIT)
+		*val = be16_to_cpu(*(u16 *)&data[0]);
+	else
+		*val = be32_to_cpu(*(u32 *)&data[0]);
+
+	return 0;
+error:
+	dev_err(&client->dev, "read from offset 0x%x error %d", reg, err);
+	return err;
+}
+
+static int
+ov2685_write_reg(struct i2c_client *client, u16 data_length, u16 reg, u32 val)
+{
+	int num_msg;
+	struct i2c_msg msg;
+	unsigned char data[6] = {0};
+	u16 *wreg;
+	int retry = 0;
+
+	if (!client->adapter) {
+		dev_err(&client->dev, "%s error, no client->adapter\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	if (data_length != MISENSOR_8BIT && data_length != MISENSOR_16BIT
+					 && data_length != MISENSOR_32BIT) {
+		dev_err(&client->dev, "%s error, invalid data_length\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+
+again:
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = 2 + data_length;
+	msg.buf = data;
+
+	/* high byte goes out first */
+	wreg = (u16 *)data;
+	*wreg = cpu_to_be16(reg);
+
+	if (data_length == MISENSOR_8BIT) {
+		data[2] = (u8)(val);
+	} else if (data_length == MISENSOR_16BIT) {
+		u16 *wdata = (u16 *)&data[2];
+		*wdata = cpu_to_be16((u16)val);
+	} else {
+		u32 *wdata = (u32 *)&data[2];
+		*wdata = cpu_to_be32(val);
+	}
+
+	num_msg = i2c_transfer(client->adapter, &msg, 1);
+
+	/*
+	 * It is said that Rev 2 sensor needs some delay here otherwise
+	 * registers do not seem to load correctly. But tests show that
+	 * removing the delay would not cause any in-stablility issue and the
+	 * delay will cause serious performance down, so, removed previous
+	 * mdelay(1) here.
+	 */
+
+	if (num_msg >= 0)
+		return 0;
+
+	dev_err(&client->dev, "write error: wrote 0x%x to offset 0x%x error %d",
+		val, reg, num_msg);
+	if (retry <= I2C_RETRY_COUNT) {
+		dev_err(&client->dev, "retrying... %d", retry);
+		retry++;
+		msleep(20);
+		goto again;
+	}
+
+	return num_msg;
+}
+
+/*
+ * ov2685_write_reg_array - Initializes a list of MT9T111 registers
+ * @client: i2c driver client structure
+ * @reglist: list of registers to be written
+ *
+ * Initializes a list of MT9T111 registers. The list of registers is
+ * terminated by MISENSOR_TOK_TERM.
+ */
+static int ov2685_write_reg_array(struct i2c_client *client,
+			    const struct misensor_reg *reglist)
+{
+	const struct misensor_reg *next = reglist;
+	int err;
+
+	for (; next->length != MISENSOR_TOK_TERM; next++) {
+		if (next->length == MISENSOR_TOK_DELAY) {
+			msleep(next->val);
+		} else {
+			err = ov2685_write_reg(client, next->length, next->reg,
+						next->val);
+			/* REVISIT: Do we need this delay? */
+			udelay(10);
+			if (err) {
+				dev_err(&client->dev, "%s err. aborted\n",
+					__func__);
+				return err;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int ov2685_g_hflip(struct v4l2_subdev *sd, s32 *val)
+{
+	return 0;
+}
+
+static int ov2685_g_vflip(struct v4l2_subdev *sd, s32 *val)
+{
+	return 0;
+}
+
+/* Horizontal flip the image. */
+static int ov2685_t_hflip(struct v4l2_subdev *sd, int value)
+{
+	return 0;
+}
+
+/* Vertically flip the image */
+static int ov2685_t_vflip(struct v4l2_subdev *sd, int value)
+{
+	return 0;
+}
+
+static int ov2685_s_freq(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	switch (value) {
+	case V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
+	case V4L2_CID_POWER_LINE_FREQUENCY_50HZ:
+	case V4L2_CID_POWER_LINE_FREQUENCY_60HZ:
+	case V4L2_CID_POWER_LINE_FREQUENCY_AUTO:
+	default:
+		dev_err(&client->dev, "ov2685_s_freq: %d\n", value);
+	}
+	return 0;
+}
+
+static int ov2685_g_scene(struct v4l2_subdev *sd, s32 *value)
+{
+	return 0;
+}
+
+static int ov2685_s_scene(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	switch (value) {
+	case V4L2_SCENE_MODE_NONE:
+	case V4L2_SCENE_MODE_BACKLIGHT:
+	case V4L2_SCENE_MODE_BEACH_SNOW:
+	case V4L2_SCENE_MODE_CANDLE_LIGHT:
+	case V4L2_SCENE_MODE_DAWN_DUSK:
+	case V4L2_SCENE_MODE_FALL_COLORS:
+	case V4L2_SCENE_MODE_FIREWORKS:
+	case V4L2_SCENE_MODE_LANDSCAPE:
+	case V4L2_SCENE_MODE_NIGHT:
+	case V4L2_SCENE_MODE_PARTY_INDOOR:
+	case V4L2_SCENE_MODE_PORTRAIT:
+	case V4L2_SCENE_MODE_SPORTS:
+	case V4L2_SCENE_MODE_SUNSET:
+	case V4L2_SCENE_MODE_TEXT:
+	default:
+		dev_err(&client->dev, "ov2685_s_scene: %d\n", value);
+		break;
+	}
+	return 0;
+}
+
+static int ov2685_g_wb(struct v4l2_subdev *sd, s32 *value)
+{
+	return 0;
+}
+
+static int ov2685_s_wb(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	switch (value) {
+	case V4L2_WHITE_BALANCE_MANUAL:
+	case V4L2_WHITE_BALANCE_AUTO:
+	case V4L2_WHITE_BALANCE_INCANDESCENT:
+	case V4L2_WHITE_BALANCE_FLUORESCENT:
+	case V4L2_WHITE_BALANCE_FLUORESCENT_H:
+	case V4L2_WHITE_BALANCE_HORIZON:
+	case V4L2_WHITE_BALANCE_DAYLIGHT:
+	case V4L2_WHITE_BALANCE_FLASH:
+	case V4L2_WHITE_BALANCE_CLOUDY:
+	case V4L2_WHITE_BALANCE_SHADE:
+	default:
+		dev_err(&client->dev, "ov2685_s_wb: %d\n", value);
+	}
+	return 0;
+}
+
+static int ov2685_g_exposure(struct v4l2_subdev *sd, s32 *value)
+{
+	return 0;
+}
+
+static int ov2685_s_exposure(struct v4l2_subdev *sd, int value)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	switch (value) {
+	case -2:
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_AUTO, 0x3);
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_1, 0x6);
+		break;
+	case -1:
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_AUTO, 0x3);
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_1, 0x16);
+		break;
+	case 0:
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_AUTO, 0x0);
+		break;
+	case 1:
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_AUTO, 0x3);
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_1, 0x36);
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_GAIN_1, 0x46);
+		break;
+	case 2:
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_AUTO, 0x3);
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_EXPOSURE_1, 0x46);
+		ov2685_write_reg(client, MISENSOR_8BIT,
+			OV2685_REG_GAIN_1, 0x56);
+		break;
+	}
+
+	return 0;
+}
+
+
+static int power_up(struct v4l2_subdev *sd)
+{
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 1);
+	if (ret)
+		goto fail_power;
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 1);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* flis clock control */
+	ret = dev->platform_data->flisclk_ctrl(sd, 1);
+	if (ret)
+		goto fail_clk;
+
+	return 0;
+
+fail_clk:
+	dev->platform_data->flisclk_ctrl(sd, 0);
+fail_power:
+	dev->platform_data->power_ctrl(sd, 0);
+	dev_err(&client->dev, "sensor power-up failed\n");
+
+	return ret;
+}
+
+static int power_down(struct v4l2_subdev *sd)
+{
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	if (NULL == dev->platform_data) {
+		dev_err(&client->dev, "no camera_sensor_platform_data");
+		return -ENODEV;
+	}
+
+	/* Wait for 1 frame + 512 XVCLK cycle.*/
+	msleep(50);
+
+	ret = dev->platform_data->flisclk_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "flisclk failed\n");
+
+	/* gpio ctrl */
+	ret = dev->platform_data->gpio_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "gpio failed\n");
+
+	/* power control */
+	ret = dev->platform_data->power_ctrl(sd, 0);
+	if (ret)
+		dev_err(&client->dev, "vprog failed.\n");
+
+	return ret;
+}
+
+static int ov2685_s_power(struct v4l2_subdev *sd, int power)
+{
+	if (power == 0)
+		return power_down(sd);
+
+	if (power_up(sd))
+		return -EINVAL;
+
+	return 0;
+}
+
+/* ov2685 resolutions supports below 2 aspect ratio */
+#define OV2685_4_3 1333 /* 4:3*//* 1600x1200*/
+#define OV2585_3_2 1500 /* 3:2*//* 720x480*/
+#define OV2685_16_9 1777 /* 16:9*//* 1280x720*/
+
+static int ov2685_try_res(u32 *w, u32 *h)
+{
+	int i;
+	/*
+	 * The mode list is in ascending order. We're done as soon as
+	 * we have found the first equal or bigger size.
+	 */
+	for (i = 0; i < N_RES; i++) {
+		if (ov2685_res[i].width >= *w &&
+		    ov2685_res[i].height >= *h)
+			break;
+	}
+
+	/*
+	 * If no mode was found, it means we can provide only a smaller size.
+	 * Returning the biggest one available in this case.
+	 */
+	if (i == N_RES)
+		i--;
+
+	*w = ov2685_res[i].width;
+	*h = ov2685_res[i].height;
+	return 0;
+}
+
+static int ov2685_to_res(u32 w, u32 h)
+{
+	int  index;
+
+	for (index = 0; index < N_RES; index++) {
+		if (ov2685_res[index].width == w &&
+		    ov2685_res[index].height == h)
+			break;
+	}
+
+	/* No mode found */
+	if (index >= N_RES)
+		index--;
+
+	return index;
+}
+
+static int ov2685_try_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	return ov2685_try_res(&fmt->width, &fmt->height);
+}
+
+static int ov2685_g_mbus_fmt(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt)
+{
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+
+	if (!fmt)
+		return -EINVAL;
+
+	fmt->width = ov2685_res[dev->fmt_idx].width;
+	fmt->height = ov2685_res[dev->fmt_idx].height;
+	fmt->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int ov2685_s_mbus_fmt(struct v4l2_subdev *sd,
+			      struct v4l2_mbus_framefmt *fmt)
+{
+	struct i2c_client *c = v4l2_get_subdevdata(sd);
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+	int res_index;
+	struct camera_mipi_info *mipi_info = NULL;
+	u32 width = fmt->width;
+	u32 height = fmt->height;
+	int ret;
+	mipi_info = v4l2_get_subdev_hostdata(sd);
+	if (mipi_info == NULL) {
+		dev_err(&c->dev, "%s: can not find mipi info!!!\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&dev->input_lock);
+	ov2685_try_res(&width, &height);
+	res_index = ov2685_to_res(width, height);
+
+	switch (ov2685_res[res_index].res)  {
+	/*
+	case OV2685_RES_VGA:
+		ret = ov2685_write_reg_array(c, ov2685_vga_init);
+		break;
+	*/
+	case OV2685_RES_720P:
+		ret = ov2685_write_reg_array(c, ov2685_720p_init);
+		break;
+	case OV2685_RES_2M:
+		ret = ov2685_write_reg_array(c, ov2685_2M_init);
+		break;
+	default:
+		dev_err(&c->dev, "%s: can not support the resolution!!!\n",
+			__func__);
+
+		mutex_unlock(&dev->input_lock);
+		return  -EINVAL;
+	}
+
+	mipi_info->num_lanes = ov2685_res[res_index].lanes;
+	/*
+	 * ov2685 - we don't poll for context switch
+	 * because it does not happen with streaming disabled.
+	 */
+	dev->fmt_idx = res_index;
+	fmt->width = width;
+	fmt->height = height;
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+}
+
+static int ov2685_detect(struct i2c_client *client,  u16 *id, u8 *revision)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	int timeout = 10;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_err(&client->dev, "%s: i2c error", __func__);
+		return -ENODEV;
+	}
+	/* WORKAROUND: there is instable issue when reading the REG_PID,
+	 * try more times to check the sensor id.
+	 */
+	while (timeout > 0) {
+		if (ov2685_read_reg(client, MISENSOR_16BIT,
+					OV2685_REG_PID, id)) {
+			dev_err(&client->dev, "sensor id error\n");
+			return -ENODEV;
+		}
+
+		if (*id == OV2685_MOD_ID)
+			break;
+		timeout--;
+	}
+
+	if (timeout == 0) {
+		dev_err(&client->dev, "timeout to read sensor id\n");
+		return -ENODEV;
+	}
+	/* REVISIT: HACK: Driver is currently forcing revision to 0 */
+	*revision = 0;
+
+	return 0;
+}
+
+static int
+ov2685_s_config(struct v4l2_subdev *sd, int irq, void *platform_data)
+{
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u8 sensor_revision;
+	u16 sensor_id = 0;
+	int ret;
+
+	if (NULL == platform_data)
+		return -ENODEV;
+
+	dev->platform_data =
+	    (struct camera_sensor_platform_data *)platform_data;
+
+	mutex_lock(&dev->input_lock);
+
+	if (dev->platform_data->platform_init) {
+		ret = dev->platform_data->platform_init(client);
+		if (ret) {
+			dev_err(&client->dev, "platform init err\n");
+			goto platform_init_failed;
+		}
+	}
+
+	ret = power_down(sd);
+	if (ret) {
+		dev_err(&client->dev, "power_off failed");
+		goto fail_power_off;
+	}
+
+	ret = power_up(sd);
+	if (ret) {
+		dev_err(&client->dev, "power_up failed");
+		goto fail_power_on;
+	}
+
+	ret = dev->platform_data->csi_cfg(sd, 1);
+	if (ret)
+		goto fail_csi_cfg;
+
+	/* config & detect sensor */
+	ret = ov2685_detect(client, &sensor_id, &sensor_revision);
+	if (ret) {
+		dev_err(&client->dev, "ov2685_detect err s_config.\n");
+		goto fail_csi_cfg;
+	}
+
+	dev->sensor_id = sensor_id;
+	dev->sensor_revision = sensor_revision;
+
+	ret = power_down(sd);
+	if (ret)
+		dev_err(&client->dev, "sensor power-gating failed\n");
+
+	mutex_unlock(&dev->input_lock);
+	return ret;
+
+fail_csi_cfg:
+	dev->platform_data->csi_cfg(sd, 0);
+fail_power_on:
+	power_down(sd);
+	dev_err(&client->dev, "sensor power-gating failed\n");
+fail_power_off:
+	if (dev->platform_data->platform_deinit)
+		dev->platform_data->platform_deinit();
+platform_init_failed:
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static struct ov2685_control ov2685_controls[] = {
+	{
+		.qc = {
+			.id = V4L2_CID_EXPOSURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "exposure",
+			.minimum = 0x0,
+			.maximum = 0xffff,
+			.step = 1,
+			.default_value = 0,
+			.flags = 0,
+		},
+		.query = ov2685_g_exposure,
+		.tweak = ov2685_s_exposure,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_SCENE_MODE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Scene Mode",
+			.minimum = V4L2_SCENE_MODE_NONE,
+			.maximum = V4L2_SCENE_MODE_TEXT,
+			.step = 1,
+			.default_value = V4L2_SCENE_MODE_NONE,
+			.flags = 0,
+		},
+		.query = ov2685_g_scene,
+		.tweak = ov2685_s_scene,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_POWER_LINE_FREQUENCY,
+			.type = V4L2_CTRL_TYPE_MENU,
+			.name = "Light frequency filter",
+			.minimum = V4L2_CID_POWER_LINE_FREQUENCY_DISABLED,
+			.maximum = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,
+			.step = 1,
+			.default_value = V4L2_CID_POWER_LINE_FREQUENCY_AUTO,
+			.flags = 0,
+		},
+		.tweak = ov2685_s_freq,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "White Balance",
+			.minimum = V4L2_WHITE_BALANCE_MANUAL,
+			.maximum = V4L2_WHITE_BALANCE_SHADE,
+			.step = 1,
+			.default_value = V4L2_WHITE_BALANCE_AUTO,
+			.flags = 0,
+		},
+		.query = ov2685_g_wb,
+		.tweak = ov2685_s_wb,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image v-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov2685_g_vflip,
+		.tweak = ov2685_t_vflip,
+	},
+	{
+		.qc = {
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Image h-Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 1,
+			.default_value = 0,
+		},
+		.query = ov2685_g_hflip,
+		.tweak = ov2685_t_hflip,
+	},
+};
+#define N_CONTROLS (ARRAY_SIZE(ov2685_controls))
+
+static struct ov2685_control *ov2685_find_control(__u32 id)
+{
+	int i;
+
+	for (i = 0; i < N_CONTROLS; i++) {
+		if (ov2685_controls[i].qc.id == id)
+			return &ov2685_controls[i];
+	}
+	return NULL;
+}
+
+static int ov2685_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	struct ov2685_control *ctrl = ov2685_find_control(qc->id);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+
+	if (ctrl == NULL) {
+		dev_err(&client->dev,  "%s unsupported control id!\n",
+			__func__);
+		return 0;
+	}
+
+	mutex_lock(&dev->input_lock);
+	*qc = ctrl->qc;
+	mutex_unlock(&dev->input_lock);
+	return 0;
+}
+
+static int ov2685_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov2685_control *octrl = ov2685_find_control(ctrl->id);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+
+	int ret;
+
+	if (!octrl || !octrl->query) {
+		dev_err(&client->dev,  "%s unsupported control id or no query func!\n",
+			__func__);
+		return 0;
+	}
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->query(sd, &ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov2685_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct ov2685_control *octrl = ov2685_find_control(ctrl->id);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+	int ret;
+
+	if (!octrl || !octrl->tweak) {
+		dev_err(&client->dev,  "%s unsupported control id or no tweak func!\n",
+			__func__);
+		return 0;
+	}
+
+	mutex_lock(&dev->input_lock);
+	ret = octrl->tweak(sd, ctrl->value);
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov2685_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+	int ret;
+
+	mutex_lock(&dev->input_lock);
+	dev->streaming = enable;
+	ret = ov2685_write_reg(client, MISENSOR_8BIT,
+			0x301c,
+			enable ? 0xf0 : 0xf4);
+	mutex_unlock(&dev->input_lock);
+
+	return ret;
+}
+
+static int
+ov2685_enum_framesizes(struct v4l2_subdev *sd, struct v4l2_frmsizeenum *fsize)
+{
+	unsigned int index = fsize->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fsize->discrete.width = ov2685_res[index].width;
+	fsize->discrete.height = ov2685_res[index].height;
+
+	fsize->reserved[0] = ov2685_res[index].used;
+
+	return 0;
+}
+
+static int ov2685_enum_frameintervals(struct v4l2_subdev *sd,
+				       struct v4l2_frmivalenum *fival)
+{
+	unsigned int index = fival->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fival->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	fival->discrete.numerator = 1;
+	fival->discrete.denominator = ov2685_res[index].fps;
+
+	return 0;
+}
+
+static int
+ov2685_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *chip)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_OV2685, 0);
+}
+
+static int ov2685_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->index)
+		return -EINVAL;
+	code->code = V4L2_MBUS_FMT_UYVY8_1X16;
+
+	return 0;
+}
+
+static int ov2685_enum_frame_size(struct v4l2_subdev *sd,
+	struct v4l2_subdev_fh *fh,
+	struct v4l2_subdev_frame_size_enum *fse)
+{
+	unsigned int index = fse->index;
+
+	if (index >= N_RES)
+		return -EINVAL;
+
+	fse->min_width = ov2685_res[index].width;
+	fse->min_height = ov2685_res[index].height;
+	fse->max_width = ov2685_res[index].width;
+	fse->max_height = ov2685_res[index].height;
+
+	return 0;
+}
+
+static int
+ov2685_get_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov2685_device *snr = to_ov2685_sensor(sd);
+
+	switch (fmt->which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		fmt->format = *v4l2_subdev_get_try_format(fh, fmt->pad);
+		break;
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		fmt->format = snr->format;
+	}
+
+	return 0;
+}
+
+static int
+ov2685_set_pad_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+		       struct v4l2_subdev_format *fmt)
+{
+	struct ov2685_device *snr = to_ov2685_sensor(sd);
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		snr->format = fmt->format;
+
+	return 0;
+}
+
+/* set focus zone */
+static int
+ov2685_set_selection(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_selection *sel)
+{
+	return 0;
+}
+
+static int ov2685_g_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	if (!param)
+		return -EINVAL;
+
+	if (param->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		dev_err(&client->dev,  "unsupported buffer type.\n");
+		return -EINVAL;
+	}
+
+	memset(param, 0, sizeof(*param));
+	param->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	return 0;
+}
+
+static int ov2685_s_parm(struct v4l2_subdev *sd,
+			struct v4l2_streamparm *param)
+{
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+
+	mutex_lock(&dev->input_lock);
+	dev->run_mode = param->parm.capture.capturemode;
+	mutex_unlock(&dev->input_lock);
+
+	return 0;
+}
+
+static int ov2685_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *interval)
+{
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+
+	interval->interval.numerator = 1;
+	interval->interval.denominator = ov2685_res[dev->fmt_idx].fps;
+
+	return 0;
+}
+
+static int
+ov2685_g_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	struct ov2685_device *dev = to_ov2685_sensor(sd);
+	*frames = ov2685_res[dev->fmt_idx].skip_frames;
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ov2685_video_ops = {
+	.try_mbus_fmt = ov2685_try_mbus_fmt,
+	.g_mbus_fmt = ov2685_g_mbus_fmt,
+	.s_mbus_fmt = ov2685_s_mbus_fmt,
+	.s_parm = ov2685_s_parm,
+	.g_parm = ov2685_g_parm,
+	.s_stream = ov2685_s_stream,
+	.enum_framesizes = ov2685_enum_framesizes,
+	.enum_frameintervals = ov2685_enum_frameintervals,
+	.g_frame_interval = ov2685_g_frame_interval,
+};
+
+static const struct v4l2_subdev_sensor_ops ov2685_sensor_ops = {
+	.g_skip_frames	= ov2685_g_skip_frames,
+};
+
+static const struct v4l2_subdev_core_ops ov2685_core_ops = {
+	.g_chip_ident = ov2685_g_chip_ident,
+	.queryctrl = ov2685_queryctrl,
+	.g_ctrl = ov2685_g_ctrl,
+	.s_ctrl = ov2685_s_ctrl,
+	.s_power = ov2685_s_power,
+};
+
+static const struct v4l2_subdev_pad_ops ov2685_pad_ops = {
+	.enum_mbus_code = ov2685_enum_mbus_code,
+	.enum_frame_size = ov2685_enum_frame_size,
+	.get_fmt = ov2685_get_pad_format,
+	.set_fmt = ov2685_set_pad_format,
+	.set_selection = ov2685_set_selection,
+};
+
+static const struct v4l2_subdev_ops ov2685_ops = {
+	.core = &ov2685_core_ops,
+	.video = &ov2685_video_ops,
+	.sensor = &ov2685_sensor_ops,
+	.pad = &ov2685_pad_ops,
+};
+
+static const struct media_entity_operations ov2685_entity_ops;
+
+static int ov2685_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov2685_device *dev = container_of(sd,
+					struct ov2685_device, sd);
+
+	dev->platform_data->csi_cfg(sd, 0);
+
+	release_firmware(dev->firmware);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&dev->sd.entity);
+	kfree(dev);
+
+	return 0;
+}
+
+static int ov2685_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov2685_device *dev = container_of(sd,
+					struct ov2685_device, sd);
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		dev_err(&client->dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	mutex_init(&dev->input_lock);
+
+	v4l2_i2c_subdev_init(&(dev->sd), client, &ov2685_ops);
+	if (client->dev.platform_data) {
+		ret = ov2685_s_config(&dev->sd, client->irq,
+				       client->dev.platform_data);
+		if (ret)
+			goto out_free;
+	}
+
+	dev->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	dev->pad.flags = MEDIA_PAD_FL_SOURCE;
+	dev->format.code = V4L2_MBUS_FMT_UYVY8_1X16;
+	dev->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+
+	ret = media_entity_init(&dev->sd.entity, 1, &dev->pad, 0);
+	if (ret)
+		ov2685_remove(client);
+
+	return ret;
+out_free:
+	v4l2_device_unregister_subdev(&dev->sd);
+	kfree(dev);
+	return ret;
+}
+
+MODULE_DEVICE_TABLE(i2c, ov2685_id);
+static struct i2c_driver ov2685_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OV2685_NAME,
+	},
+	.probe = ov2685_probe,
+	.remove = __exit_p(ov2685_remove),
+	.id_table = ov2685_id,
+};
+
+static __init int ov2685_init_mod(void)
+{
+	return i2c_add_driver(&ov2685_driver);
+}
+
+static __exit void ov2685_exit_mod(void)
+{
+	i2c_del_driver(&ov2685_driver);
+}
+
+module_init(ov2685_init_mod);
+module_exit(ov2685_exit_mod);
+
+MODULE_DESCRIPTION("A low-level driver for Omnivision OV2685 sensors");
+MODULE_LICENSE("GPL");
diff --git a/drivers/external_drivers/camera/drivers/media/i2c/ov2685.h b/drivers/external_drivers/camera/drivers/media/i2c/ov2685.h
new file mode 100644
index 0000000..a8d1179
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/i2c/ov2685.h
@@ -0,0 +1,988 @@
+/*
+ * Support for ov2685 Camera Sensor.
+ *
+ * Copyright (c) 2012 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __OV2685_H__
+#define __OV2685_H__
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <linux/spinlock.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <linux/atomisp_platform.h>
+#include <linux/atomisp.h>
+
+#define OV2685_NAME	"ov2685"
+#define V4L2_IDENT_OV2685 1111
+#define	LAST_REG_SETING	{0xffff, 0xff}
+
+/* #defines for register writes and register array processing */
+#define MISENSOR_8BIT		1
+#define MISENSOR_16BIT		2
+#define MISENSOR_32BIT		4
+
+#define MISENSOR_TOK_TERM	0xf000	/* terminating token for reg list */
+#define MISENSOR_TOK_DELAY	0xfe00	/* delay token for reg list */
+#define MISENSOR_TOK_FWLOAD	0xfd00	/* token indicating load FW */
+#define MISENSOR_TOK_POLL	0xfc00	/* token indicating poll instruction */
+
+#define I2C_RETRY_COUNT		5
+#define MSG_LEN_OFFSET		2
+
+/*register */
+#define OV2685_REG_GAIN_0	0x350a
+#define OV2685_REG_GAIN_1	0x350b
+#define OV2685_REG_EXPOSURE_0	0x3500
+#define OV2685_REG_EXPOSURE_1	0x3501
+#define OV2685_REG_EXPOSURE_2	0x3502
+#define OV2685_REG_EXPOSURE_AUTO	0x3503
+#define OV2685_REG_SMIA	0x0100
+#define OV2685_REG_PID	0x300a
+#define OV2685_REG_SYS_RESET	0x3000
+#define OV2685_REG_FW_START	0x8000
+
+/*value */
+#define OV2685_FRAME_START	0x01
+#define OV2685_FRAME_STOP	0x00
+#define OV2685_AWB_GAIN_AUTO	0
+#define OV2685_AWB_GAIN_MANUAL	1
+
+#define MIN_SYSCLK		10
+#define MIN_VTS			8
+#define MIN_HTS			8
+#define MIN_SHUTTER		0
+#define MIN_GAIN		0
+
+/* OV2685_DEVICE_ID */
+#define OV2685_MOD_ID		0x2685
+
+#define OV2685_RES_5M_SIZE_H		2560
+#define OV2685_RES_5M_SIZE_V		1920
+#define OV2685_RES_D5M_SIZE_H		2496
+#define OV2685_RES_D5M_SIZE_V		1664
+#define OV2685_RES_D3M_SIZE_H		2112
+#define OV2685_RES_D3M_SIZE_V		1408
+#define OV2685_RES_3M_SIZE_H		2048
+#define OV2685_RES_3M_SIZE_V		1536
+#define OV2685_RES_2M_SIZE_H		1600
+#define OV2685_RES_2M_SIZE_V		1200
+#define OV2685_RES_1088P_SIZE_H		1920
+#define OV2685_RES_1088P_SIZE_V		1088
+#define OV2685_RES_1080P_SIZE_H		1920
+#define OV2685_RES_1080P_SIZE_V		1080
+#define OV2685_RES_720P_SIZE_H		1280
+#define OV2685_RES_720P_SIZE_V		720
+#define OV2685_RES_480P_SIZE_H		720
+#define OV2685_RES_480P_SIZE_V		480
+#define OV2685_RES_VGA_SIZE_H		640
+#define OV2685_RES_VGA_SIZE_V		480
+#define OV2685_RES_360P_SIZE_H		640
+#define OV2685_RES_360P_SIZE_V		360
+#define OV2685_RES_320P_SIZE_H		480
+#define OV2685_RES_320P_SIZE_V		320
+#define OV2685_RES_DVGA_SIZE_H		416
+#define OV2685_RES_DVGA_SIZE_V		312
+#define OV2685_RES_QVGA_SIZE_H		320
+#define OV2685_RES_QVGA_SIZE_V		240
+
+/*
+ * struct misensor_reg - MI sensor  register format
+ * @length: length of the register
+ * @reg: 16-bit offset to register
+ * @val: 8/16/32-bit register value
+ * Define a structure for sensor register initialization values
+ */
+struct misensor_reg {
+	u16 length;
+	u16 reg;
+	u32 val;	/* value or for read/mod/write */
+};
+
+struct regval_list {
+	u16 reg_num;
+	u8 value;
+};
+
+struct ov2685_device {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_mbus_framefmt format;
+	struct mutex input_lock;
+	struct firmware *firmware;
+
+	struct camera_sensor_platform_data *platform_data;
+	int run_mode;
+	int focus_mode;
+	int night_mode;
+	bool focus_mode_change;
+	int color_effect;
+	bool streaming;
+	bool preview_ag_ae;
+	u16 sensor_id;
+	u8 sensor_revision;
+	unsigned int ae_high;
+	unsigned int ae_low;
+	unsigned int preview_shutter;
+	unsigned int preview_gain16;
+	unsigned int average;
+	unsigned int preview_sysclk;
+	unsigned int preview_hts;
+	unsigned int preview_vts;
+	unsigned int fmt_idx;
+};
+
+struct ov2685_priv_data {
+	u32 port;
+	u32 num_of_lane;
+	u32 input_format;
+	u32 raw_bayer_order;
+};
+
+struct ov2685_format_struct {
+	u8 *desc;
+	u32 pixelformat;
+	struct regval_list *regs;
+};
+
+struct ov2685_res_struct {
+	u8 *desc;
+	int res;
+	int width;
+	int height;
+	int fps;
+	int skip_frames;
+	int lanes;
+	bool used;
+	struct regval_list *regs;
+};
+
+#define OV2685_MAX_WRITE_BUF_SIZE	32
+struct ov2685_write_buffer {
+	u16 addr;
+	u8 data[OV2685_MAX_WRITE_BUF_SIZE];
+};
+
+struct ov2685_write_ctrl {
+	int index;
+	struct ov2685_write_buffer buffer;
+};
+
+struct ov2685_control {
+	struct v4l2_queryctrl qc;
+	int (*query)(struct v4l2_subdev *sd, s32 *value);
+	int (*tweak)(struct v4l2_subdev *sd, int value);
+};
+
+/* Supported resolutions */
+enum {
+	OV2685_RES_720P,
+	OV2685_RES_2M,
+};
+
+static struct ov2685_res_struct ov2685_res[] = {
+	{
+	.desc	= "720P",
+	.res	= OV2685_RES_720P,
+	.width	= 1280,
+	.height	= 720,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 1,
+	.lanes = 1,
+	},
+	{
+	.desc	= "2M",
+	.res	= OV2685_RES_2M,
+	.width	= 1600,
+	.height	= 1200,
+	.fps	= 30,
+	.used	= 0,
+	.regs	= NULL,
+	.skip_frames = 0,
+	.lanes = 2,
+	},
+};
+#define N_RES (ARRAY_SIZE(ov2685_res))
+
+static const struct i2c_device_id ov2685_id[] = {
+	{"ov2685", 0},
+	{}
+};
+
+static struct misensor_reg const ov2685_2M_init[] = {
+	/*2lanes, 30fps*/
+	{MISENSOR_8BIT, 0x0103 , 0x01},
+	{MISENSOR_8BIT, 0x3002 , 0x00},
+	{MISENSOR_8BIT, 0x3016 , 0x1c},
+	{MISENSOR_8BIT, 0x3018 , 0x84},
+	{MISENSOR_8BIT, 0x301d , 0xf0},
+	{MISENSOR_8BIT, 0x3020 , 0x00},
+	{MISENSOR_8BIT, 0x3082 , 0x37},/*mclk = 19.2Mhz*/
+	{MISENSOR_8BIT, 0x3083 , 0x03},
+	{MISENSOR_8BIT, 0x3084 , 0x07},
+	{MISENSOR_8BIT, 0x3085 , 0x03},
+	{MISENSOR_8BIT, 0x3086 , 0x00},
+	{MISENSOR_8BIT, 0x3087 , 0x00},
+	{MISENSOR_8BIT, 0x3501 , 0x4e},
+	{MISENSOR_8BIT, 0x3502 , 0xe0},
+	{MISENSOR_8BIT, 0x3503 , 0x03},
+	{MISENSOR_8BIT, 0x350b , 0x36},
+	{MISENSOR_8BIT, 0x3600 , 0xb4},
+	{MISENSOR_8BIT, 0x3603 , 0x35},
+	{MISENSOR_8BIT, 0x3604 , 0x24},
+	{MISENSOR_8BIT, 0x3605 , 0x00},
+	{MISENSOR_8BIT, 0x3620 , 0x24},
+	{MISENSOR_8BIT, 0x3621 , 0x34},
+	{MISENSOR_8BIT, 0x3622 , 0x03},
+	{MISENSOR_8BIT, 0x3628 , 0x10},
+	{MISENSOR_8BIT, 0x3705 , 0x3c},
+	{MISENSOR_8BIT, 0x370a , 0x21},
+	{MISENSOR_8BIT, 0x370c , 0x50},
+	{MISENSOR_8BIT, 0x370d , 0xc0},
+	{MISENSOR_8BIT, 0x3717 , 0x58},
+	{MISENSOR_8BIT, 0x3718 , 0x80},
+	{MISENSOR_8BIT, 0x3720 , 0x00},
+	{MISENSOR_8BIT, 0x3721 , 0x09},
+	{MISENSOR_8BIT, 0x3722 , 0x06},
+	{MISENSOR_8BIT, 0x3723 , 0x59},
+	{MISENSOR_8BIT, 0x3738 , 0x99},
+	{MISENSOR_8BIT, 0x3781 , 0x80},
+	{MISENSOR_8BIT, 0x3784 , 0x0c},
+	{MISENSOR_8BIT, 0x3789 , 0x60},
+	{MISENSOR_8BIT, 0x3800 , 0x00},
+	{MISENSOR_8BIT, 0x3801 , 0x00},
+	{MISENSOR_8BIT, 0x3802 , 0x00},
+	{MISENSOR_8BIT, 0x3803 , 0x00},
+	{MISENSOR_8BIT, 0x3804 , 0x06},
+	{MISENSOR_8BIT, 0x3805 , 0x4f},
+	{MISENSOR_8BIT, 0x3806 , 0x04},
+	{MISENSOR_8BIT, 0x3807 , 0xbf},
+	{MISENSOR_8BIT, 0x3808 , 0x06},
+	{MISENSOR_8BIT, 0x3809 , 0x40},
+	{MISENSOR_8BIT, 0x380a , 0x04},
+	{MISENSOR_8BIT, 0x380b , 0xb0},
+	{MISENSOR_8BIT, 0x380c , 0x06},
+	{MISENSOR_8BIT, 0x380d , 0xa4},
+	{MISENSOR_8BIT, 0x380e , 0x05},
+	{MISENSOR_8BIT, 0x380f , 0x0e},
+	{MISENSOR_8BIT, 0x3810 , 0x00},
+	{MISENSOR_8BIT, 0x3811 , 0x08},
+	{MISENSOR_8BIT, 0x3812 , 0x00},
+	{MISENSOR_8BIT, 0x3813 , 0x08},
+	{MISENSOR_8BIT, 0x3814 , 0x11},
+	{MISENSOR_8BIT, 0x3815 , 0x11},
+	{MISENSOR_8BIT, 0x3819 , 0x04},
+	{MISENSOR_8BIT, 0x3820 , 0xc0},
+	{MISENSOR_8BIT, 0x3821 , 0x00},
+	{MISENSOR_8BIT, 0x3a06 , 0x01},
+	{MISENSOR_8BIT, 0x3a07 , 0x84},
+	{MISENSOR_8BIT, 0x3a08 , 0x01},
+	{MISENSOR_8BIT, 0x3a09 , 0x43},
+	{MISENSOR_8BIT, 0x3a0a , 0x24},
+	{MISENSOR_8BIT, 0x3a0b , 0x60},
+	{MISENSOR_8BIT, 0x3a0c , 0x28},
+	{MISENSOR_8BIT, 0x3a0d , 0x60},
+	{MISENSOR_8BIT, 0x3a0e , 0x04},
+	{MISENSOR_8BIT, 0x3a0f , 0x8c},
+	{MISENSOR_8BIT, 0x3a10 , 0x05},
+	{MISENSOR_8BIT, 0x3a11 , 0x0c},
+	{MISENSOR_8BIT, 0x4000 , 0x81},
+	{MISENSOR_8BIT, 0x4001 , 0x40},
+	{MISENSOR_8BIT, 0x4008 , 0x02},
+	{MISENSOR_8BIT, 0x4009 , 0x09},
+	{MISENSOR_8BIT, 0x4300 , 0x32},
+	{MISENSOR_8BIT, 0x430e , 0x00},
+	{MISENSOR_8BIT, 0x4602 , 0x02},
+	{MISENSOR_8BIT, 0x4837 , 0x1e},
+	{MISENSOR_8BIT, 0x5000 , 0xff},
+	{MISENSOR_8BIT, 0x5001 , 0x05},
+	{MISENSOR_8BIT, 0x5002 , 0x32},
+	{MISENSOR_8BIT, 0x5003 , 0x04},
+	{MISENSOR_8BIT, 0x5004 , 0xff},
+	{MISENSOR_8BIT, 0x5005 , 0x12},
+	{MISENSOR_8BIT, 0x0100 , 0x01},
+	{MISENSOR_8BIT, 0x5180 , 0xf4},
+	{MISENSOR_8BIT, 0x5181 , 0x11},
+	{MISENSOR_8BIT, 0x5182 , 0x41},
+	{MISENSOR_8BIT, 0x5183 , 0x42},
+	{MISENSOR_8BIT, 0x5184 , 0x78},
+	{MISENSOR_8BIT, 0x5185 , 0x58},
+	{MISENSOR_8BIT, 0x5186 , 0xb5},
+	{MISENSOR_8BIT, 0x5187 , 0xb2},
+	{MISENSOR_8BIT, 0x5188 , 0x08},
+	{MISENSOR_8BIT, 0x5189 , 0x0e},
+	{MISENSOR_8BIT, 0x518a , 0x0c},
+	{MISENSOR_8BIT, 0x518b , 0x4c},
+	{MISENSOR_8BIT, 0x518c , 0x38},
+	{MISENSOR_8BIT, 0x518d , 0xf8},
+	{MISENSOR_8BIT, 0x518e , 0x04},
+	{MISENSOR_8BIT, 0x518f , 0x7f},
+	{MISENSOR_8BIT, 0x5190 , 0x40},
+	{MISENSOR_8BIT, 0x5191 , 0x5f},
+	{MISENSOR_8BIT, 0x5192 , 0x40},
+	{MISENSOR_8BIT, 0x5193 , 0xff},
+	{MISENSOR_8BIT, 0x5194 , 0x40},
+	{MISENSOR_8BIT, 0x5195 , 0x07},
+	{MISENSOR_8BIT, 0x5196 , 0x04},
+	{MISENSOR_8BIT, 0x5197 , 0x04},
+	{MISENSOR_8BIT, 0x5198 , 0x00},
+	{MISENSOR_8BIT, 0x5199 , 0x05},
+	{MISENSOR_8BIT, 0x519a , 0xd2},
+	{MISENSOR_8BIT, 0x519b , 0x10},
+	{MISENSOR_8BIT, 0x5200 , 0x09},
+	{MISENSOR_8BIT, 0x5201 , 0x00},
+	{MISENSOR_8BIT, 0x5202 , 0x06},
+	{MISENSOR_8BIT, 0x5203 , 0x20},
+	{MISENSOR_8BIT, 0x5204 , 0x41},
+	{MISENSOR_8BIT, 0x5205 , 0x16},
+	{MISENSOR_8BIT, 0x5206 , 0x00},
+	{MISENSOR_8BIT, 0x5207 , 0x05},
+	{MISENSOR_8BIT, 0x520b , 0x30},
+	{MISENSOR_8BIT, 0x520c , 0x75},
+	{MISENSOR_8BIT, 0x520d , 0x00},
+	{MISENSOR_8BIT, 0x520e , 0x30},
+	{MISENSOR_8BIT, 0x520f , 0x75},
+	{MISENSOR_8BIT, 0x5210 , 0x00},
+	{MISENSOR_8BIT, 0x5280 , 0x14},
+	{MISENSOR_8BIT, 0x5281 , 0x02},
+	{MISENSOR_8BIT, 0x5282 , 0x02},
+	{MISENSOR_8BIT, 0x5283 , 0x04},
+	{MISENSOR_8BIT, 0x5284 , 0x06},
+	{MISENSOR_8BIT, 0x5285 , 0x08},
+	{MISENSOR_8BIT, 0x5286 , 0x0c},
+	{MISENSOR_8BIT, 0x5287 , 0x10},
+	{MISENSOR_8BIT, 0x5300 , 0xc5},
+	{MISENSOR_8BIT, 0x5301 , 0xa0},
+	{MISENSOR_8BIT, 0x5302 , 0x06},
+	{MISENSOR_8BIT, 0x5303 , 0x0a},
+	{MISENSOR_8BIT, 0x5304 , 0x30},
+	{MISENSOR_8BIT, 0x5305 , 0x60},
+	{MISENSOR_8BIT, 0x5306 , 0x90},
+	{MISENSOR_8BIT, 0x5307 , 0xc0},
+	{MISENSOR_8BIT, 0x5308 , 0x82},
+	{MISENSOR_8BIT, 0x5309 , 0x00},
+	{MISENSOR_8BIT, 0x530a , 0x26},
+	{MISENSOR_8BIT, 0x530b , 0x02},
+	{MISENSOR_8BIT, 0x530c , 0x02},
+	{MISENSOR_8BIT, 0x530d , 0x00},
+	{MISENSOR_8BIT, 0x530e , 0x0c},
+	{MISENSOR_8BIT, 0x530f , 0x14},
+	{MISENSOR_8BIT, 0x5310 , 0x1a},
+	{MISENSOR_8BIT, 0x5311 , 0x20},
+	{MISENSOR_8BIT, 0x5312 , 0x80},
+	{MISENSOR_8BIT, 0x5313 , 0x4b},
+	{MISENSOR_8BIT, 0x5380 , 0x01},
+	{MISENSOR_8BIT, 0x5381 , 0x52},
+	{MISENSOR_8BIT, 0x5382 , 0x00},
+	{MISENSOR_8BIT, 0x5383 , 0x4a},
+	{MISENSOR_8BIT, 0x5384 , 0x00},
+	{MISENSOR_8BIT, 0x5385 , 0xb6},
+	{MISENSOR_8BIT, 0x5386 , 0x00},
+	{MISENSOR_8BIT, 0x5387 , 0x8d},
+	{MISENSOR_8BIT, 0x5388 , 0x00},
+	{MISENSOR_8BIT, 0x5389 , 0x3a},
+	{MISENSOR_8BIT, 0x538a , 0x00},
+	{MISENSOR_8BIT, 0x538b , 0xa6},
+	{MISENSOR_8BIT, 0x538c , 0x00},
+	{MISENSOR_8BIT, 0x5400 , 0x0d},
+	{MISENSOR_8BIT, 0x5401 , 0x18},
+	{MISENSOR_8BIT, 0x5402 , 0x31},
+	{MISENSOR_8BIT, 0x5403 , 0x5a},
+	{MISENSOR_8BIT, 0x5404 , 0x65},
+	{MISENSOR_8BIT, 0x5405 , 0x6f},
+	{MISENSOR_8BIT, 0x5406 , 0x77},
+	{MISENSOR_8BIT, 0x5407 , 0x80},
+	{MISENSOR_8BIT, 0x5408 , 0x87},
+	{MISENSOR_8BIT, 0x5409 , 0x8f},
+	{MISENSOR_8BIT, 0x540a , 0xa2},
+	{MISENSOR_8BIT, 0x540b , 0xb2},
+	{MISENSOR_8BIT, 0x540c , 0xcc},
+	{MISENSOR_8BIT, 0x540d , 0xe4},
+	{MISENSOR_8BIT, 0x540e , 0xf0},
+	{MISENSOR_8BIT, 0x540f , 0xa0},
+	{MISENSOR_8BIT, 0x5410 , 0x6e},
+	{MISENSOR_8BIT, 0x5411 , 0x06},
+	{MISENSOR_8BIT, 0x5480 , 0x19},
+	{MISENSOR_8BIT, 0x5481 , 0x00},
+	{MISENSOR_8BIT, 0x5482 , 0x09},
+	{MISENSOR_8BIT, 0x5483 , 0x12},
+	{MISENSOR_8BIT, 0x5484 , 0x04},
+	{MISENSOR_8BIT, 0x5485 , 0x06},
+	{MISENSOR_8BIT, 0x5486 , 0x08},
+	{MISENSOR_8BIT, 0x5487 , 0x0c},
+	{MISENSOR_8BIT, 0x5488 , 0x10},
+	{MISENSOR_8BIT, 0x5489 , 0x18},
+	{MISENSOR_8BIT, 0x5500 , 0x02},
+	{MISENSOR_8BIT, 0x5501 , 0x03},
+	{MISENSOR_8BIT, 0x5502 , 0x04},
+	{MISENSOR_8BIT, 0x5503 , 0x05},
+	{MISENSOR_8BIT, 0x5504 , 0x06},
+	{MISENSOR_8BIT, 0x5505 , 0x08},
+	{MISENSOR_8BIT, 0x5506 , 0x00},
+	{MISENSOR_8BIT, 0x5600 , 0x02},
+	{MISENSOR_8BIT, 0x5603 , 0x40},
+	{MISENSOR_8BIT, 0x5604 , 0x28},
+	{MISENSOR_8BIT, 0x5609 , 0x20},
+	{MISENSOR_8BIT, 0x560a , 0x60},
+	{MISENSOR_8BIT, 0x5800 , 0x03},
+	{MISENSOR_8BIT, 0x5801 , 0x24},
+	{MISENSOR_8BIT, 0x5802 , 0x02},
+	{MISENSOR_8BIT, 0x5803 , 0x40},
+	{MISENSOR_8BIT, 0x5804 , 0x34},
+	{MISENSOR_8BIT, 0x5805 , 0x05},
+	{MISENSOR_8BIT, 0x5806 , 0x12},
+	{MISENSOR_8BIT, 0x5807 , 0x05},
+	{MISENSOR_8BIT, 0x5808 , 0x03},
+	{MISENSOR_8BIT, 0x5809 , 0x3c},
+	{MISENSOR_8BIT, 0x580a , 0x02},
+	{MISENSOR_8BIT, 0x580b , 0x40},
+	{MISENSOR_8BIT, 0x580c , 0x26},
+	{MISENSOR_8BIT, 0x580d , 0x05},
+	{MISENSOR_8BIT, 0x580e , 0x52},
+	{MISENSOR_8BIT, 0x580f , 0x06},
+	{MISENSOR_8BIT, 0x5810 , 0x03},
+	{MISENSOR_8BIT, 0x5811 , 0x28},
+	{MISENSOR_8BIT, 0x5812 , 0x02},
+	{MISENSOR_8BIT, 0x5813 , 0x40},
+	{MISENSOR_8BIT, 0x5814 , 0x24},
+	{MISENSOR_8BIT, 0x5815 , 0x05},
+	{MISENSOR_8BIT, 0x5816 , 0x42},
+	{MISENSOR_8BIT, 0x5817 , 0x06},
+	{MISENSOR_8BIT, 0x5818 , 0x0d},
+	{MISENSOR_8BIT, 0x5819 , 0x40},
+	{MISENSOR_8BIT, 0x581a , 0x04},
+	{MISENSOR_8BIT, 0x581b , 0x0c},
+	{MISENSOR_8BIT, 0x3a03 , 0x4c},
+	{MISENSOR_8BIT, 0x3a04 , 0x40},
+	{MISENSOR_8BIT, 0x3503 , 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov2685_720p_init[] = {
+	/*1lane 30fps*/
+	{MISENSOR_8BIT, 0x0103 , 0x01},
+	{MISENSOR_8BIT, 0x3002 , 0x00},
+	{MISENSOR_8BIT, 0x3016 , 0x1c},
+	{MISENSOR_8BIT, 0x3018 , 0x44},
+	{MISENSOR_8BIT, 0x301d , 0xf0},
+	{MISENSOR_8BIT, 0x3020 , 0x00},
+	{MISENSOR_8BIT, 0x3082 , 0x37},
+	{MISENSOR_8BIT, 0x3083 , 0x03},
+	{MISENSOR_8BIT, 0x3084 , 0x0f},
+	{MISENSOR_8BIT, 0x3085 , 0x03},
+	{MISENSOR_8BIT, 0x3086 , 0x00},
+	{MISENSOR_8BIT, 0x3087 , 0x00},
+	{MISENSOR_8BIT, 0x3501 , 0x2d},
+	{MISENSOR_8BIT, 0x3502 , 0x80},
+	{MISENSOR_8BIT, 0x3503 , 0x03},
+	{MISENSOR_8BIT, 0x350b , 0x36},
+	{MISENSOR_8BIT, 0x3600 , 0xb4},
+	{MISENSOR_8BIT, 0x3603 , 0x35},
+	{MISENSOR_8BIT, 0x3604 , 0x24},
+	{MISENSOR_8BIT, 0x3605 , 0x00},
+	{MISENSOR_8BIT, 0x3620 , 0x26},
+	{MISENSOR_8BIT, 0x3621 , 0x37},
+	{MISENSOR_8BIT, 0x3622 , 0x04},
+	{MISENSOR_8BIT, 0x3628 , 0x10},
+	{MISENSOR_8BIT, 0x3705 , 0x3c},
+	{MISENSOR_8BIT, 0x370a , 0x21},
+	{MISENSOR_8BIT, 0x370c , 0x50},
+	{MISENSOR_8BIT, 0x370d , 0xc0},
+	{MISENSOR_8BIT, 0x3717 , 0x58},
+	{MISENSOR_8BIT, 0x3718 , 0x88},
+	{MISENSOR_8BIT, 0x3720 , 0x00},
+	{MISENSOR_8BIT, 0x3721 , 0x00},
+	{MISENSOR_8BIT, 0x3722 , 0x00},
+	{MISENSOR_8BIT, 0x3723 , 0x00},
+	{MISENSOR_8BIT, 0x3738 , 0x00},
+	{MISENSOR_8BIT, 0x3781 , 0x80},
+	{MISENSOR_8BIT, 0x3789 , 0x60},
+	{MISENSOR_8BIT, 0x3800 , 0x00},
+	{MISENSOR_8BIT, 0x3801 , 0xa0},
+	{MISENSOR_8BIT, 0x3802 , 0x00},
+	{MISENSOR_8BIT, 0x3803 , 0xf2},
+	{MISENSOR_8BIT, 0x3804 , 0x05},
+	{MISENSOR_8BIT, 0x3805 , 0xaf},
+	{MISENSOR_8BIT, 0x3806 , 0x03},
+	{MISENSOR_8BIT, 0x3807 , 0xcd},
+	{MISENSOR_8BIT, 0x3808 , 0x05},
+	{MISENSOR_8BIT, 0x3809 , 0x00},
+	{MISENSOR_8BIT, 0x380a , 0x02},
+	{MISENSOR_8BIT, 0x380b , 0xd0},
+	{MISENSOR_8BIT, 0x380c , 0x05},
+	{MISENSOR_8BIT, 0x380d , 0xa6},
+	{MISENSOR_8BIT, 0x380e , 0x02},
+	{MISENSOR_8BIT, 0x380f , 0xf8},
+	{MISENSOR_8BIT, 0x3810 , 0x00},
+	{MISENSOR_8BIT, 0x3811 , 0x08},
+	{MISENSOR_8BIT, 0x3812 , 0x00},
+	{MISENSOR_8BIT, 0x3813 , 0x06},
+	{MISENSOR_8BIT, 0x3814 , 0x11},
+	{MISENSOR_8BIT, 0x3815 , 0x11},
+	{MISENSOR_8BIT, 0x3819 , 0x04},
+	{MISENSOR_8BIT, 0x3820 , 0xc0},
+	{MISENSOR_8BIT, 0x3821 , 0x00},
+	{MISENSOR_8BIT, 0x3a06 , 0x00},
+	{MISENSOR_8BIT, 0x3a07 , 0xe4},
+	{MISENSOR_8BIT, 0x3a08 , 0x00},
+	{MISENSOR_8BIT, 0x3a09 , 0xbe},
+	{MISENSOR_8BIT, 0x3a0a , 0x15},
+	{MISENSOR_8BIT, 0x3a0b , 0x60},
+	{MISENSOR_8BIT, 0x3a0c , 0x17},
+	{MISENSOR_8BIT, 0x3a0d , 0xc0},
+	{MISENSOR_8BIT, 0x3a0e , 0x02},
+	{MISENSOR_8BIT, 0x3a0f , 0xac},
+	{MISENSOR_8BIT, 0x3a10 , 0x02},
+	{MISENSOR_8BIT, 0x3a11 , 0xf8},
+	{MISENSOR_8BIT, 0x4000 , 0x81},
+	{MISENSOR_8BIT, 0x4001 , 0x40},
+	{MISENSOR_8BIT, 0x4008 , 0x02},
+	{MISENSOR_8BIT, 0x4009 , 0x09},
+	{MISENSOR_8BIT, 0x4300 , 0x32},
+	{MISENSOR_8BIT, 0x430e , 0x00},
+	{MISENSOR_8BIT, 0x4602 , 0x02},
+	{MISENSOR_8BIT, 0x4837 , 0x1e},
+	{MISENSOR_8BIT, 0x5000 , 0xff},
+	{MISENSOR_8BIT, 0x5001 , 0x05},
+	{MISENSOR_8BIT, 0x5002 , 0x32},
+	{MISENSOR_8BIT, 0x5003 , 0x04},
+	{MISENSOR_8BIT, 0x5004 , 0xff},
+	{MISENSOR_8BIT, 0x5005 , 0x12},
+	{MISENSOR_8BIT, 0x0100 , 0x01},
+	{MISENSOR_8BIT, 0x5180 , 0xf4},
+	{MISENSOR_8BIT, 0x5181 , 0x11},
+	{MISENSOR_8BIT, 0x5182 , 0x41},
+	{MISENSOR_8BIT, 0x5183 , 0x42},
+	{MISENSOR_8BIT, 0x5184 , 0x78},
+	{MISENSOR_8BIT, 0x5185 , 0x58},
+	{MISENSOR_8BIT, 0x5186 , 0xb5},
+	{MISENSOR_8BIT, 0x5187 , 0xb2},
+	{MISENSOR_8BIT, 0x5188 , 0x08},
+	{MISENSOR_8BIT, 0x5189 , 0x0e},
+	{MISENSOR_8BIT, 0x518a , 0x0c},
+	{MISENSOR_8BIT, 0x518b , 0x4c},
+	{MISENSOR_8BIT, 0x518c , 0x38},
+	{MISENSOR_8BIT, 0x518d , 0xf8},
+	{MISENSOR_8BIT, 0x518e , 0x04},
+	{MISENSOR_8BIT, 0x518f , 0x7f},
+	{MISENSOR_8BIT, 0x5190 , 0x40},
+	{MISENSOR_8BIT, 0x5191 , 0x5f},
+	{MISENSOR_8BIT, 0x5192 , 0x40},
+	{MISENSOR_8BIT, 0x5193 , 0xff},
+	{MISENSOR_8BIT, 0x5194 , 0x40},
+	{MISENSOR_8BIT, 0x5195 , 0x07},
+	{MISENSOR_8BIT, 0x5196 , 0x04},
+	{MISENSOR_8BIT, 0x5197 , 0x04},
+	{MISENSOR_8BIT, 0x5198 , 0x00},
+	{MISENSOR_8BIT, 0x5199 , 0x05},
+	{MISENSOR_8BIT, 0x519a , 0xd2},
+	{MISENSOR_8BIT, 0x519b , 0x10},
+	{MISENSOR_8BIT, 0x5200 , 0x09},
+	{MISENSOR_8BIT, 0x5201 , 0x00},
+	{MISENSOR_8BIT, 0x5202 , 0x06},
+	{MISENSOR_8BIT, 0x5203 , 0x20},
+	{MISENSOR_8BIT, 0x5204 , 0x41},
+	{MISENSOR_8BIT, 0x5205 , 0x16},
+	{MISENSOR_8BIT, 0x5206 , 0x00},
+	{MISENSOR_8BIT, 0x5207 , 0x05},
+	{MISENSOR_8BIT, 0x520b , 0x30},
+	{MISENSOR_8BIT, 0x520c , 0x75},
+	{MISENSOR_8BIT, 0x520d , 0x00},
+	{MISENSOR_8BIT, 0x520e , 0x30},
+	{MISENSOR_8BIT, 0x520f , 0x75},
+	{MISENSOR_8BIT, 0x5210 , 0x00},
+	{MISENSOR_8BIT, 0x5280 , 0x14},
+	{MISENSOR_8BIT, 0x5281 , 0x02},
+	{MISENSOR_8BIT, 0x5282 , 0x02},
+	{MISENSOR_8BIT, 0x5283 , 0x04},
+	{MISENSOR_8BIT, 0x5284 , 0x06},
+	{MISENSOR_8BIT, 0x5285 , 0x08},
+	{MISENSOR_8BIT, 0x5286 , 0x0c},
+	{MISENSOR_8BIT, 0x5287 , 0x10},
+	{MISENSOR_8BIT, 0x5300 , 0xc5},
+	{MISENSOR_8BIT, 0x5301 , 0xa0},
+	{MISENSOR_8BIT, 0x5302 , 0x06},
+	{MISENSOR_8BIT, 0x5303 , 0x0a},
+	{MISENSOR_8BIT, 0x5304 , 0x30},
+	{MISENSOR_8BIT, 0x5305 , 0x60},
+	{MISENSOR_8BIT, 0x5306 , 0x90},
+	{MISENSOR_8BIT, 0x5307 , 0xc0},
+	{MISENSOR_8BIT, 0x5308 , 0x82},
+	{MISENSOR_8BIT, 0x5309 , 0x00},
+	{MISENSOR_8BIT, 0x530a , 0x26},
+	{MISENSOR_8BIT, 0x530b , 0x02},
+	{MISENSOR_8BIT, 0x530c , 0x02},
+	{MISENSOR_8BIT, 0x530d , 0x00},
+	{MISENSOR_8BIT, 0x530e , 0x0c},
+	{MISENSOR_8BIT, 0x530f , 0x14},
+	{MISENSOR_8BIT, 0x5310 , 0x1a},
+	{MISENSOR_8BIT, 0x5311 , 0x20},
+	{MISENSOR_8BIT, 0x5312 , 0x80},
+	{MISENSOR_8BIT, 0x5313 , 0x4b},
+	{MISENSOR_8BIT, 0x5380 , 0x01},
+	{MISENSOR_8BIT, 0x5381 , 0x52},
+	{MISENSOR_8BIT, 0x5382 , 0x00},
+	{MISENSOR_8BIT, 0x5383 , 0x4a},
+	{MISENSOR_8BIT, 0x5384 , 0x00},
+	{MISENSOR_8BIT, 0x5385 , 0xb6},
+	{MISENSOR_8BIT, 0x5386 , 0x00},
+	{MISENSOR_8BIT, 0x5387 , 0x8d},
+	{MISENSOR_8BIT, 0x5388 , 0x00},
+	{MISENSOR_8BIT, 0x5389 , 0x3a},
+	{MISENSOR_8BIT, 0x538a , 0x00},
+	{MISENSOR_8BIT, 0x538b , 0xa6},
+	{MISENSOR_8BIT, 0x538c , 0x00},
+	{MISENSOR_8BIT, 0x5400 , 0x0d},
+	{MISENSOR_8BIT, 0x5401 , 0x18},
+	{MISENSOR_8BIT, 0x5402 , 0x31},
+	{MISENSOR_8BIT, 0x5403 , 0x5a},
+	{MISENSOR_8BIT, 0x5404 , 0x65},
+	{MISENSOR_8BIT, 0x5405 , 0x6f},
+	{MISENSOR_8BIT, 0x5406 , 0x77},
+	{MISENSOR_8BIT, 0x5407 , 0x80},
+	{MISENSOR_8BIT, 0x5408 , 0x87},
+	{MISENSOR_8BIT, 0x5409 , 0x8f},
+	{MISENSOR_8BIT, 0x540a , 0xa2},
+	{MISENSOR_8BIT, 0x540b , 0xb2},
+	{MISENSOR_8BIT, 0x540c , 0xcc},
+	{MISENSOR_8BIT, 0x540d , 0xe4},
+	{MISENSOR_8BIT, 0x540e , 0xf0},
+	{MISENSOR_8BIT, 0x540f , 0xa0},
+	{MISENSOR_8BIT, 0x5410 , 0x6e},
+	{MISENSOR_8BIT, 0x5411 , 0x06},
+	{MISENSOR_8BIT, 0x5480 , 0x19},
+	{MISENSOR_8BIT, 0x5481 , 0x00},
+	{MISENSOR_8BIT, 0x5482 , 0x09},
+	{MISENSOR_8BIT, 0x5483 , 0x12},
+	{MISENSOR_8BIT, 0x5484 , 0x04},
+	{MISENSOR_8BIT, 0x5485 , 0x06},
+	{MISENSOR_8BIT, 0x5486 , 0x08},
+	{MISENSOR_8BIT, 0x5487 , 0x0c},
+	{MISENSOR_8BIT, 0x5488 , 0x10},
+	{MISENSOR_8BIT, 0x5489 , 0x18},
+	{MISENSOR_8BIT, 0x5500 , 0x02},
+	{MISENSOR_8BIT, 0x5501 , 0x03},
+	{MISENSOR_8BIT, 0x5502 , 0x04},
+	{MISENSOR_8BIT, 0x5503 , 0x05},
+	{MISENSOR_8BIT, 0x5504 , 0x06},
+	{MISENSOR_8BIT, 0x5505 , 0x08},
+	{MISENSOR_8BIT, 0x5506 , 0x00},
+	{MISENSOR_8BIT, 0x5600 , 0x02},
+	{MISENSOR_8BIT, 0x5603 , 0x40},
+	{MISENSOR_8BIT, 0x5604 , 0x28},
+	{MISENSOR_8BIT, 0x5609 , 0x20},
+	{MISENSOR_8BIT, 0x560a , 0x60},
+	{MISENSOR_8BIT, 0x5800 , 0x03},
+	{MISENSOR_8BIT, 0x5801 , 0x24},
+	{MISENSOR_8BIT, 0x5802 , 0x02},
+	{MISENSOR_8BIT, 0x5803 , 0x40},
+	{MISENSOR_8BIT, 0x5804 , 0x34},
+	{MISENSOR_8BIT, 0x5805 , 0x05},
+	{MISENSOR_8BIT, 0x5806 , 0x12},
+	{MISENSOR_8BIT, 0x5807 , 0x05},
+	{MISENSOR_8BIT, 0x5808 , 0x03},
+	{MISENSOR_8BIT, 0x5809 , 0x3c},
+	{MISENSOR_8BIT, 0x580a , 0x02},
+	{MISENSOR_8BIT, 0x580b , 0x40},
+	{MISENSOR_8BIT, 0x580c , 0x26},
+	{MISENSOR_8BIT, 0x580d , 0x05},
+	{MISENSOR_8BIT, 0x580e , 0x52},
+	{MISENSOR_8BIT, 0x580f , 0x06},
+	{MISENSOR_8BIT, 0x5810 , 0x03},
+	{MISENSOR_8BIT, 0x5811 , 0x28},
+	{MISENSOR_8BIT, 0x5812 , 0x02},
+	{MISENSOR_8BIT, 0x5813 , 0x40},
+	{MISENSOR_8BIT, 0x5814 , 0x24},
+	{MISENSOR_8BIT, 0x5815 , 0x05},
+	{MISENSOR_8BIT, 0x5816 , 0x42},
+	{MISENSOR_8BIT, 0x5817 , 0x06},
+	{MISENSOR_8BIT, 0x5818 , 0x0d},
+	{MISENSOR_8BIT, 0x5819 , 0x40},
+	{MISENSOR_8BIT, 0x581a , 0x04},
+	{MISENSOR_8BIT, 0x581b , 0x0c},
+	{MISENSOR_8BIT, 0x3a03 , 0x4c},
+	{MISENSOR_8BIT, 0x3a04 , 0x40},
+	{MISENSOR_8BIT, 0x3503 , 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+/* camera vga 30fps, yuv, 1lanes */
+static struct misensor_reg const ov2685_vga_init[] = {
+	{MISENSOR_8BIT, 0x0103 , 0x01},
+	{MISENSOR_8BIT, 0x3002 , 0x00},
+	{MISENSOR_8BIT, 0x3016 , 0x1c},
+	{MISENSOR_8BIT, 0x3018 , 0x44},
+	{MISENSOR_8BIT, 0x301d , 0xf0},
+	{MISENSOR_8BIT, 0x3020 , 0x00},
+	{MISENSOR_8BIT, 0x3082 , 0x37},
+	{MISENSOR_8BIT, 0x3083 , 0x03},
+	{MISENSOR_8BIT, 0x3084 , 0x0f},
+	{MISENSOR_8BIT, 0x3085 , 0x03},
+	{MISENSOR_8BIT, 0x3086 , 0x00},
+	{MISENSOR_8BIT, 0x3087 , 0x00},
+	{MISENSOR_8BIT, 0x3501 , 0x26},
+	{MISENSOR_8BIT, 0x3502 , 0x40},
+	{MISENSOR_8BIT, 0x3503 , 0x03},
+	{MISENSOR_8BIT, 0x350b , 0x36},
+	{MISENSOR_8BIT, 0x3600 , 0xb4},
+	{MISENSOR_8BIT, 0x3603 , 0x35},
+	{MISENSOR_8BIT, 0x3604 , 0x24},
+	{MISENSOR_8BIT, 0x3605 , 0x00},
+	{MISENSOR_8BIT, 0x3620 , 0x26},
+	{MISENSOR_8BIT, 0x3621 , 0x37},
+	{MISENSOR_8BIT, 0x3622 , 0x04},
+	{MISENSOR_8BIT, 0x3628 , 0x10},
+	{MISENSOR_8BIT, 0x3705 , 0x3c},
+	{MISENSOR_8BIT, 0x370a , 0x23},
+	{MISENSOR_8BIT, 0x370c , 0x50},
+	{MISENSOR_8BIT, 0x370d , 0xc0},
+	{MISENSOR_8BIT, 0x3717 , 0x58},
+	{MISENSOR_8BIT, 0x3718 , 0x88},
+	{MISENSOR_8BIT, 0x3720 , 0x00},
+	{MISENSOR_8BIT, 0x3721 , 0x00},
+	{MISENSOR_8BIT, 0x3722 , 0x00},
+	{MISENSOR_8BIT, 0x3723 , 0x00},
+	{MISENSOR_8BIT, 0x3738 , 0x00},
+	{MISENSOR_8BIT, 0x3781 , 0x80},
+	{MISENSOR_8BIT, 0x3789 , 0x60},
+	{MISENSOR_8BIT, 0x3800 , 0x00},
+	{MISENSOR_8BIT, 0x3801 , 0xa0},
+	{MISENSOR_8BIT, 0x3802 , 0x00},
+	{MISENSOR_8BIT, 0x3803 , 0x78},
+	{MISENSOR_8BIT, 0x3804 , 0x05},
+	{MISENSOR_8BIT, 0x3805 , 0xaf},
+	{MISENSOR_8BIT, 0x3806 , 0x04},
+	{MISENSOR_8BIT, 0x3807 , 0x47},
+	{MISENSOR_8BIT, 0x3808 , 0x02},
+	{MISENSOR_8BIT, 0x3809 , 0x80},
+	{MISENSOR_8BIT, 0x380a , 0x01},
+	{MISENSOR_8BIT, 0x380b , 0xe0},
+	{MISENSOR_8BIT, 0x380c , 0x06},
+	{MISENSOR_8BIT, 0x380d , 0xac},
+	{MISENSOR_8BIT, 0x380e , 0x02},
+	{MISENSOR_8BIT, 0x380f , 0x84},
+	{MISENSOR_8BIT, 0x3810 , 0x00},
+	{MISENSOR_8BIT, 0x3811 , 0x04},
+	{MISENSOR_8BIT, 0x3812 , 0x00},
+	{MISENSOR_8BIT, 0x3813 , 0x04},
+	{MISENSOR_8BIT, 0x3814 , 0x31},
+	{MISENSOR_8BIT, 0x3815 , 0x31},
+	{MISENSOR_8BIT, 0x3819 , 0x04},
+	{MISENSOR_8BIT, 0x3820 , 0xc2},
+	{MISENSOR_8BIT, 0x3821 , 0x01},
+	{MISENSOR_8BIT, 0x3a06 , 0x00},
+	{MISENSOR_8BIT, 0x3a07 , 0xc1},
+	{MISENSOR_8BIT, 0x3a08 , 0x00},
+	{MISENSOR_8BIT, 0x3a09 , 0xa1},
+	{MISENSOR_8BIT, 0x3a0a , 0x12},
+	{MISENSOR_8BIT, 0x3a0b , 0x18},
+	{MISENSOR_8BIT, 0x3a0c , 0x14},
+	{MISENSOR_8BIT, 0x3a0d , 0x20},
+	{MISENSOR_8BIT, 0x3a0e , 0x02},
+	{MISENSOR_8BIT, 0x3a0f , 0x43},
+	{MISENSOR_8BIT, 0x3a10 , 0x02},
+	{MISENSOR_8BIT, 0x3a11 , 0x84},
+	{MISENSOR_8BIT, 0x4000 , 0x81},
+	{MISENSOR_8BIT, 0x4001 , 0x40},
+	{MISENSOR_8BIT, 0x4008 , 0x00},
+	{MISENSOR_8BIT, 0x4009 , 0x03},
+	{MISENSOR_8BIT, 0x4300 , 0x32},
+	{MISENSOR_8BIT, 0x430e , 0x00},
+	{MISENSOR_8BIT, 0x4602 , 0x02},
+	{MISENSOR_8BIT, 0x4837 , 0x1e},
+	{MISENSOR_8BIT, 0x5000 , 0xff},
+	{MISENSOR_8BIT, 0x5001 , 0x05},
+	{MISENSOR_8BIT, 0x5002 , 0x32},
+	{MISENSOR_8BIT, 0x5003 , 0x04},
+	{MISENSOR_8BIT, 0x5004 , 0xff},
+	{MISENSOR_8BIT, 0x5005 , 0x12},
+	{MISENSOR_8BIT, 0x0100 , 0x01},
+	{MISENSOR_8BIT, 0x0101 , 0x01},
+	{MISENSOR_8BIT, 0x1000 , 0x01},
+	{MISENSOR_8BIT, 0x0129 , 0x10},
+	{MISENSOR_8BIT, 0x5180 , 0xf4},
+	{MISENSOR_8BIT, 0x5181 , 0x11},
+	{MISENSOR_8BIT, 0x5182 , 0x41},
+	{MISENSOR_8BIT, 0x5183 , 0x42},
+	{MISENSOR_8BIT, 0x5184 , 0x78},
+	{MISENSOR_8BIT, 0x5185 , 0x58},
+	{MISENSOR_8BIT, 0x5186 , 0xb5},
+	{MISENSOR_8BIT, 0x5187 , 0xb2},
+	{MISENSOR_8BIT, 0x5188 , 0x08},
+	{MISENSOR_8BIT, 0x5189 , 0x0e},
+	{MISENSOR_8BIT, 0x518a , 0x0c},
+	{MISENSOR_8BIT, 0x518b , 0x4c},
+	{MISENSOR_8BIT, 0x518c , 0x38},
+	{MISENSOR_8BIT, 0x518d , 0xf8},
+	{MISENSOR_8BIT, 0x518e , 0x04},
+	{MISENSOR_8BIT, 0x518f , 0x7f},
+	{MISENSOR_8BIT, 0x5190 , 0x40},
+	{MISENSOR_8BIT, 0x5191 , 0x5f},
+	{MISENSOR_8BIT, 0x5192 , 0x40},
+	{MISENSOR_8BIT, 0x5193 , 0xff},
+	{MISENSOR_8BIT, 0x5194 , 0x40},
+	{MISENSOR_8BIT, 0x5195 , 0x07},
+	{MISENSOR_8BIT, 0x5196 , 0x04},
+	{MISENSOR_8BIT, 0x5197 , 0x04},
+	{MISENSOR_8BIT, 0x5198 , 0x00},
+	{MISENSOR_8BIT, 0x5199 , 0x05},
+	{MISENSOR_8BIT, 0x519a , 0xd2},
+	{MISENSOR_8BIT, 0x519b , 0x10},
+	{MISENSOR_8BIT, 0x5200 , 0x09},
+	{MISENSOR_8BIT, 0x5201 , 0x00},
+	{MISENSOR_8BIT, 0x5202 , 0x06},
+	{MISENSOR_8BIT, 0x5203 , 0x20},
+	{MISENSOR_8BIT, 0x5204 , 0x41},
+	{MISENSOR_8BIT, 0x5205 , 0x16},
+	{MISENSOR_8BIT, 0x5206 , 0x00},
+	{MISENSOR_8BIT, 0x5207 , 0x05},
+	{MISENSOR_8BIT, 0x520b , 0x30},
+	{MISENSOR_8BIT, 0x520c , 0x75},
+	{MISENSOR_8BIT, 0x520d , 0x00},
+	{MISENSOR_8BIT, 0x520e , 0x30},
+	{MISENSOR_8BIT, 0x520f , 0x75},
+	{MISENSOR_8BIT, 0x5210 , 0x00},
+	{MISENSOR_8BIT, 0x5280 , 0x14},
+	{MISENSOR_8BIT, 0x5281 , 0x02},
+	{MISENSOR_8BIT, 0x5282 , 0x02},
+	{MISENSOR_8BIT, 0x5283 , 0x04},
+	{MISENSOR_8BIT, 0x5284 , 0x06},
+	{MISENSOR_8BIT, 0x5285 , 0x08},
+	{MISENSOR_8BIT, 0x5286 , 0x0c},
+	{MISENSOR_8BIT, 0x5287 , 0x10},
+	{MISENSOR_8BIT, 0x5300 , 0xc5},
+	{MISENSOR_8BIT, 0x5301 , 0xa0},
+	{MISENSOR_8BIT, 0x5302 , 0x06},
+	{MISENSOR_8BIT, 0x5303 , 0x0a},
+	{MISENSOR_8BIT, 0x5304 , 0x30},
+	{MISENSOR_8BIT, 0x5305 , 0x60},
+	{MISENSOR_8BIT, 0x5306 , 0x90},
+	{MISENSOR_8BIT, 0x5307 , 0xc0},
+	{MISENSOR_8BIT, 0x5308 , 0x82},
+	{MISENSOR_8BIT, 0x5309 , 0x00},
+	{MISENSOR_8BIT, 0x530a , 0x26},
+	{MISENSOR_8BIT, 0x530b , 0x02},
+	{MISENSOR_8BIT, 0x530c , 0x02},
+	{MISENSOR_8BIT, 0x530d , 0x00},
+	{MISENSOR_8BIT, 0x530e , 0x0c},
+	{MISENSOR_8BIT, 0x530f , 0x14},
+	{MISENSOR_8BIT, 0x5310 , 0x1a},
+	{MISENSOR_8BIT, 0x5311 , 0x20},
+	{MISENSOR_8BIT, 0x5312 , 0x80},
+	{MISENSOR_8BIT, 0x5313 , 0x4b},
+	{MISENSOR_8BIT, 0x5380 , 0x01},
+	{MISENSOR_8BIT, 0x5381 , 0x52},
+	{MISENSOR_8BIT, 0x5382 , 0x00},
+	{MISENSOR_8BIT, 0x5383 , 0x4a},
+	{MISENSOR_8BIT, 0x5384 , 0x00},
+	{MISENSOR_8BIT, 0x5385 , 0xb6},
+	{MISENSOR_8BIT, 0x5386 , 0x00},
+	{MISENSOR_8BIT, 0x5387 , 0x8d},
+	{MISENSOR_8BIT, 0x5388 , 0x00},
+	{MISENSOR_8BIT, 0x5389 , 0x3a},
+	{MISENSOR_8BIT, 0x538a , 0x00},
+	{MISENSOR_8BIT, 0x538b , 0xa6},
+	{MISENSOR_8BIT, 0x538c , 0x00},
+	{MISENSOR_8BIT, 0x5400 , 0x0d},
+	{MISENSOR_8BIT, 0x5401 , 0x18},
+	{MISENSOR_8BIT, 0x5402 , 0x31},
+	{MISENSOR_8BIT, 0x5403 , 0x5a},
+	{MISENSOR_8BIT, 0x5404 , 0x65},
+	{MISENSOR_8BIT, 0x5405 , 0x6f},
+	{MISENSOR_8BIT, 0x5406 , 0x77},
+	{MISENSOR_8BIT, 0x5407 , 0x80},
+	{MISENSOR_8BIT, 0x5408 , 0x87},
+	{MISENSOR_8BIT, 0x5409 , 0x8f},
+	{MISENSOR_8BIT, 0x540a , 0xa2},
+	{MISENSOR_8BIT, 0x540b , 0xb2},
+	{MISENSOR_8BIT, 0x540c , 0xcc},
+	{MISENSOR_8BIT, 0x540d , 0xe4},
+	{MISENSOR_8BIT, 0x540e , 0xf0},
+	{MISENSOR_8BIT, 0x540f , 0xa0},
+	{MISENSOR_8BIT, 0x5410 , 0x6e},
+	{MISENSOR_8BIT, 0x5411 , 0x06},
+	{MISENSOR_8BIT, 0x5480 , 0x19},
+	{MISENSOR_8BIT, 0x5481 , 0x00},
+	{MISENSOR_8BIT, 0x5482 , 0x09},
+	{MISENSOR_8BIT, 0x5483 , 0x12},
+	{MISENSOR_8BIT, 0x5484 , 0x04},
+	{MISENSOR_8BIT, 0x5485 , 0x06},
+	{MISENSOR_8BIT, 0x5486 , 0x08},
+	{MISENSOR_8BIT, 0x5487 , 0x0c},
+	{MISENSOR_8BIT, 0x5488 , 0x10},
+	{MISENSOR_8BIT, 0x5489 , 0x18},
+	{MISENSOR_8BIT, 0x5500 , 0x02},
+	{MISENSOR_8BIT, 0x5501 , 0x03},
+	{MISENSOR_8BIT, 0x5502 , 0x04},
+	{MISENSOR_8BIT, 0x5503 , 0x05},
+	{MISENSOR_8BIT, 0x5504 , 0x06},
+	{MISENSOR_8BIT, 0x5505 , 0x08},
+	{MISENSOR_8BIT, 0x5506 , 0x00},
+	{MISENSOR_8BIT, 0x5600 , 0x02},
+	{MISENSOR_8BIT, 0x5603 , 0x40},
+	{MISENSOR_8BIT, 0x5604 , 0x28},
+	{MISENSOR_8BIT, 0x5609 , 0x20},
+	{MISENSOR_8BIT, 0x560a , 0x60},
+	{MISENSOR_8BIT, 0x5800 , 0x03},
+	{MISENSOR_8BIT, 0x5801 , 0x24},
+	{MISENSOR_8BIT, 0x5802 , 0x02},
+	{MISENSOR_8BIT, 0x5803 , 0x40},
+	{MISENSOR_8BIT, 0x5804 , 0x34},
+	{MISENSOR_8BIT, 0x5805 , 0x05},
+	{MISENSOR_8BIT, 0x5806 , 0x12},
+	{MISENSOR_8BIT, 0x5807 , 0x05},
+	{MISENSOR_8BIT, 0x5808 , 0x03},
+	{MISENSOR_8BIT, 0x5809 , 0x3c},
+	{MISENSOR_8BIT, 0x580a , 0x02},
+	{MISENSOR_8BIT, 0x580b , 0x40},
+	{MISENSOR_8BIT, 0x580c , 0x26},
+	{MISENSOR_8BIT, 0x580d , 0x05},
+	{MISENSOR_8BIT, 0x580e , 0x52},
+	{MISENSOR_8BIT, 0x580f , 0x06},
+	{MISENSOR_8BIT, 0x5810 , 0x03},
+	{MISENSOR_8BIT, 0x5811 , 0x28},
+	{MISENSOR_8BIT, 0x5812 , 0x02},
+	{MISENSOR_8BIT, 0x5813 , 0x40},
+	{MISENSOR_8BIT, 0x5814 , 0x24},
+	{MISENSOR_8BIT, 0x5815 , 0x05},
+	{MISENSOR_8BIT, 0x5816 , 0x42},
+	{MISENSOR_8BIT, 0x5817 , 0x06},
+	{MISENSOR_8BIT, 0x5818 , 0x0d},
+	{MISENSOR_8BIT, 0x5819 , 0x40},
+	{MISENSOR_8BIT, 0x581a , 0x04},
+	{MISENSOR_8BIT, 0x581b , 0x0c},
+	{MISENSOR_8BIT, 0x3a03 , 0x4c},
+	{MISENSOR_8BIT, 0x3a04 , 0x40},
+	{MISENSOR_8BIT, 0x3503 , 0x00},
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov2685_common[] = {
+	 {MISENSOR_TOK_TERM, 0, 0}
+};
+
+static struct misensor_reg const ov2685_iq[] = {
+	{MISENSOR_TOK_TERM, 0, 0}
+};
+
+#endif
-- 
1.9.1

