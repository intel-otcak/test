From 24ec9b641ac285750170ed64a35c61b478425678 Mon Sep 17 00:00:00 2001
From: Fei Yang <fei.yang@intel.com>
Date: Mon, 19 May 2014 14:20:17 -0700
Subject: [PATCH] Add DollarCove battery and charger drivers

Also enable upstream CrystalCove drivers

For: GMIN-858
Change-Id: I66ed9e083a20692620abeb93ebaddb46b5b16cf9
Signed-off-by: Radivoje Jovanovic <radivoje.jovanovic@intel.com>
---
 arch/x86/platform/intel-mid/platform_imx134.c |   50 -
 drivers/power/dc_xpwr_battery.c               | 1029 ++++++++++++++++++++++++++
 drivers/power/dc_xpwr_charger.c               |  987 ++++++++++++++++++++++++
 drivers/regulator/pmic_crystal_cove.c         |   28 
 include/linux/mfd/intel_soc_pmic.h            |    2 
 include/linux/power/battery_id.h              |   79 +
 include/linux/power/dc_xpwr_battery.h         |   49 +
 include/linux/power/dc_xpwr_charger.h         |   48 +
 9 files changed, 2226 insertions(+), 53 deletions(-)
 create mode 100644 drivers/power/dc_xpwr_battery.c
 create mode 100644 drivers/power/dc_xpwr_charger.c
 create mode 100644 include/linux/power/battery_id.h
 create mode 100644 include/linux/power/dc_xpwr_battery.h
 create mode 100644 include/linux/power/dc_xpwr_charger.h

--- linux.orig/arch/x86/platform/intel-mid/platform_imx134.c
+++ linux/arch/x86/platform/intel-mid/platform_imx134.c
@@ -17,7 +17,7 @@
 #include <linux/regulator/consumer.h>
 #include <asm/intel-mid.h>
 #include <media/v4l2-subdev.h>
-#include <linux/mfd/intel_mid_pmic.h>
+#include <linux/mfd/intel_soc_pmic.h>
 #include <linux/atomisp_gmin_platform.h>
 
 #ifdef CONFIG_VLV2_PLAT_CLK
@@ -33,7 +33,6 @@
 #define CLK_ON	0x1
 #define CLK_OFF	0x2
 #endif
-#ifdef CONFIG_CRYSTAL_COVE
 #define ALDO1_SEL_REG	0x28
 #define ALDO1_CTRL3_REG	0x13
 #define ALDO1_2P8V	0x16
@@ -68,7 +67,6 @@ enum pmic_ids {
 };
 
 static enum pmic_ids pmic_id;
-#endif
 static int camera_reset;
 static int camera_power_down;
 static int camera_vprog1_on;
@@ -76,7 +74,6 @@ static int camera_vprog1_on;
 /*
  * MRFLD VV primary camera sensor - IMX134 platform data
  */
-#ifdef CONFIG_CRYSTAL_COVE
 static int match_name(struct device *dev, void *data)
 {
 	const char *name = data;
@@ -132,35 +129,35 @@ static int camera_pmic_set(bool flag)
 			break;
 		case PMIC_XPOWER:
 			/* ALDO1 */
-			ret = intel_mid_pmic_writeb(ALDO1_SEL_REG, ALDO1_2P8V);
+			ret = intel_soc_pmic_writeb(ALDO1_SEL_REG, ALDO1_2P8V);
 			if (ret)
 				return ret;
 
 			/* PMIC Output CTRL 3 for ALDO1 */
-			val = intel_mid_pmic_readb(ALDO1_CTRL3_REG);
+			val = intel_soc_pmic_readb(ALDO1_CTRL3_REG);
 			val |= (1 << ALDO1_CTRL3_SHIFT);
-			ret = intel_mid_pmic_writeb(ALDO1_CTRL3_REG, val);
+			ret = intel_soc_pmic_writeb(ALDO1_CTRL3_REG, val);
 			if (ret)
 				return ret;
 
 			/* ELDO2 */
-			ret = intel_mid_pmic_writeb(ELDO2_SEL_REG, ELDO2_1P8V);
+			ret = intel_soc_pmic_writeb(ELDO2_SEL_REG, ELDO2_1P8V);
 			if (ret)
 				return ret;
 
 			/* PMIC Output CTRL 2 for ELDO2 */
-			val = intel_mid_pmic_readb(ELDO2_CTRL2_REG);
+			val = intel_soc_pmic_readb(ELDO2_CTRL2_REG);
 			val |= (1 << ELDO2_CTRL2_SHIFT);
-			ret = intel_mid_pmic_writeb(ELDO2_CTRL2_REG, val);
+			ret = intel_soc_pmic_writeb(ELDO2_CTRL2_REG, val);
 			break;
 		case PMIC_TI:
 			/* LDO9 */
-			ret = intel_mid_pmic_writeb(LDO9_REG, LDO9_2P8V_ON);
+			ret = intel_soc_pmic_writeb(LDO9_REG, LDO9_2P8V_ON);
 			if (ret)
 				return ret;
 
 			/* LDO10 */
-			ret = intel_mid_pmic_writeb(LDO10_REG, LDO10_1P8V_ON);
+			ret = intel_soc_pmic_writeb(LDO10_REG, LDO10_1P8V_ON);
 			if (ret)
 				return ret;
 			break;
@@ -175,24 +172,24 @@ static int camera_pmic_set(bool flag)
 			ret += regulator_disable(v1p8_reg);
 			break;
 		case PMIC_XPOWER:
-			val = intel_mid_pmic_readb(ALDO1_CTRL3_REG);
+			val = intel_soc_pmic_readb(ALDO1_CTRL3_REG);
 			val &= ~(1 << ALDO1_CTRL3_SHIFT);
-			ret = intel_mid_pmic_writeb(ALDO1_CTRL3_REG, val);
+			ret = intel_soc_pmic_writeb(ALDO1_CTRL3_REG, val);
 			if (ret)
 				return ret;
 
-			val = intel_mid_pmic_readb(ELDO2_CTRL2_REG);
+			val = intel_soc_pmic_readb(ELDO2_CTRL2_REG);
 			val &= ~(1 << ELDO2_CTRL2_SHIFT);
-			ret = intel_mid_pmic_writeb(ELDO2_CTRL2_REG, val);
+			ret = intel_soc_pmic_writeb(ELDO2_CTRL2_REG, val);
 			break;
 		case PMIC_TI:
 			/* LDO9 */
-			ret = intel_mid_pmic_writeb(LDO9_REG, LDO9_2P8V_OFF);
+			ret = intel_soc_pmic_writeb(LDO9_REG, LDO9_2P8V_OFF);
 			if (ret)
 				return ret;
 
 			/* LDO10 */
-			ret = intel_mid_pmic_writeb(LDO10_REG, LDO10_1P8V_OFF);
+			ret = intel_soc_pmic_writeb(LDO10_REG, LDO10_1P8V_OFF);
 			if (ret)
 				return ret;
 			break;
@@ -202,7 +199,6 @@ static int camera_pmic_set(bool flag)
 	}
 	return ret;
 }
-#endif
 
 static int imx134_gpio_ctrl(struct v4l2_subdev *sd, int flag)
 {
@@ -281,23 +277,17 @@ static int imx134_flisclk_ctrl(struct v4
 
 static int imx134_power_ctrl(struct v4l2_subdev *sd, int flag)
 {
-#ifdef CONFIG_CRYSTAL_COVE
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
-#endif
 	int ret = 0;
 
 	if (flag) {
 		if (!camera_vprog1_on) {
-#ifdef CONFIG_CRYSTAL_COVE
 			ret = camera_pmic_set(flag);
 			if (ret) {
 				dev_err(&client->dev,
 						"Failed to enable regulator\n");
 				return ret;
 			}
-#else
-			pr_err("imx134 power is not set.\n");
-#endif
 			if (!ret) {
 				/* imx1x5 VDIG rise to XCLR release */
 				usleep_range(1000, 1200);
@@ -307,16 +297,12 @@ static int imx134_power_ctrl(struct v4l2
 		}
 	} else {
 		if (camera_vprog1_on) {
-#ifdef CONFIG_CRYSTAL_COVE
 			ret = camera_pmic_set(flag);
 			if (ret) {
 				dev_err(&client->dev,
 						"Failed to enable regulator\n");
 				return ret;
 			}
-#else
-			pr_err("imx134 power is not set.\n");
-#endif
 			if (!ret)
 				camera_vprog1_on = 0;
 			return ret;
@@ -345,7 +331,6 @@ static int imx134_csi_configure(struct v
 	return camera_sensor_csi(sd, port, lanes, format, bayer, flag);
 }
 
-#ifdef CONFIG_CRYSTAL_COVE
 static int imx134_platform_init(struct i2c_client *client)
 {
 	pmic_id = camera_pmic_probe();
@@ -378,26 +363,21 @@ static int imx134_platform_deinit(void)
 
 	return 0;
 }
-#endif
 
 static struct camera_sensor_platform_data imx134_sensor_platform_data = {
 	.gpio_ctrl      = imx134_gpio_ctrl,
 	.flisclk_ctrl   = imx134_flisclk_ctrl,
 	.power_ctrl     = imx134_power_ctrl,
 	.csi_cfg        = imx134_csi_configure,
-#ifdef CONFIG_CRYSTAL_COVE
 	.platform_init = imx134_platform_init,
 	.platform_deinit = imx134_platform_deinit,
-#endif
 };
 
 void *imx134_platform_data(void *info)
 {
 	camera_reset = -1;
 	camera_power_down = -1;
-#ifdef CONFIG_CRYSTAL_COVE
 	pmic_id = PMIC_MAX;
-#endif
 	return &imx134_sensor_platform_data;
 }
 EXPORT_SYMBOL_GPL(imx134_platform_data);
--- /dev/null
+++ linux/drivers/power/dc_xpwr_battery.c
@@ -0,0 +1,1029 @@
+/*
+ * dc_xpwr_battery.c - Dollar Cove(X-power) Battery driver
+ *
+ * Copyright (C) 2014 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Ramakrishna Pallala <ramakrishna.pallala@intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/power_supply.h>
+#include <linux/idr.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <asm/unaligned.h>
+#include <linux/notifier.h>
+#include <linux/acpi.h>
+#include <linux/iio/consumer.h>
+#include <linux/mfd/intel_soc_pmic.h>
+#include <linux/power/dc_xpwr_battery.h>
+
+#define DC_PS_STAT_REG			0x00
+#define PS_STAT_VBUS_TRIGGER		(1 << 0)
+#define PS_STAT_BAT_CHRG_DIR		(1 << 2)
+#define PS_STAT_VBUS_ABOVE_VHOLD	(1 << 3)
+#define PS_STAT_VBUS_VALID		(1 << 4)
+#define PS_STAT_VBUS_PRESENT		(1 << 5)
+
+#define DC_CHRG_STAT_REG		0x01
+#define CHRG_STAT_BAT_SAFE_MODE		(1 << 3)
+#define CHRG_STAT_BAT_VALID		(1 << 4)
+#define CHRG_STAT_BAT_PRESENT		(1 << 5)
+#define CHRG_STAT_CHARGING		(1 << 6)
+#define CHRG_STAT_PMIC_OTP		(1 << 7)
+
+#define DC_CHRG_CCCV_REG		0x33
+#define CHRG_CCCV_CC_MASK		0xf		/* 4 bits */
+#define CHRG_CCCV_CC_BIT_POS		0
+#define CHRG_CCCV_CC_OFFSET		200		/* 200mA */
+#define CHRG_CCCV_CC_LSB_RES		200		/* 200mA */
+#define CHRG_CCCV_ITERM_20P		(1 << 4)	/* 20% of CC */
+#define CHRG_CCCV_CV_MASK		0x60		/* 2 bits */
+#define CHRG_CCCV_CV_BIT_POS		5
+#define CHRG_CCCV_CV_4100MV		0x0		/* 4.10V */
+#define CHRG_CCCV_CV_4150MV		0x1		/* 4.15V */
+#define CHRG_CCCV_CV_4200MV		0x2		/* 4.20V */
+#define CHRG_CCCV_CV_4350MV		0x3		/* 4.35V */
+#define CHRG_CCCV_CHG_EN		(1 << 7)
+
+#define CV_4100				4100	/* 4100mV */
+#define CV_4150				4150	/* 4150mV */
+#define CV_4200				4200	/* 4200mV */
+#define CV_4350				4350	/* 4350mV */
+
+#define DC_FG_VLTFW_REG			0x3C
+#define FG_VLTFW_0C			0xA5	/* 0 DegC */
+#define DC_FG_VHTFW_REG			0x3D
+#define FG_VHTFW_56C			0x15	/* 56 DegC */
+
+#define DC_TEMP_IRQ_CFG_REG		0x42
+#define TEMP_IRQ_CFG_QWBTU		(1 << 0)
+#define TEMP_IRQ_CFG_WBTU		(1 << 1)
+#define TEMP_IRQ_CFG_QWBTO		(1 << 2)
+#define TEMP_IRQ_CFG_WBTO		(1 << 3)
+#define TEMP_IRQ_CFG_MASK		0xf
+
+#define DC_FG_IRQ_CFG_REG		0x43
+#define FG_IRQ_CFG_LOWBATT_WL2		(1 << 0)
+#define FG_IRQ_CFG_LOWBATT_WL1		(1 << 1)
+#define FG_IRQ_CFG_LOWBATT_MASK		0x3
+
+#define DC_LOWBAT_IRQ_STAT_REG		0x4B
+#define LOWBAT_IRQ_STAT_LOWBATT_WL2	(1 << 0)
+#define LOWBAT_IRQ_STAT_LOWBATT_WL1	(1 << 1)
+
+#define DC_FG_CNTL_REG			0xB8
+#define FG_CNTL_OCV_ADJ_STAT		(1 << 2)
+#define FG_CNTL_OCV_ADJ_EN		(1 << 3)
+#define FG_CNTL_CAP_ADJ_STAT		(1 << 4)
+#define FG_CNTL_CAP_ADJ_EN		(1 << 5)
+#define FG_CNTL_CC_EN			(1 << 6)
+#define FG_CNTL_GAUGE_EN		(1 << 7)
+
+#define DC_FG_REP_CAP_REG		0xB9
+#define FG_REP_CAP_VALID		(1 << 7)
+#define FG_REP_CAP_VAL_MASK		0x7F
+
+#define DC_FG_RDC1_REG			0xBA
+#define DC_FG_RDC0_REG			0xBB
+
+#define DC_FG_OCVH_REG			0xBC
+#define DC_FG_OCVL_REG			0xBD
+
+#define DC_FG_OCV_CURVE_REG		0xC0
+
+#define DC_FG_DES_CAP1_REG		0xE0
+#define DC_FG_DES_CAP1_VALID		(1 << 7)
+#define DC_FG_DES_CAP1_VAL_MASK		0x7F
+
+#define DC_FG_DES_CAP0_REG		0xE1
+#define FG_DES_CAP0_VAL_MASK		0xFF
+#define FG_DES_CAP_RES_LSB		1456	/* 1.456mAhr */
+
+#define DC_FG_CC_MTR1_REG		0xE2
+#define FG_CC_MTR1_VALID		(1 << 7)
+#define FG_CC_MTR1_VAL_MASK		0x7F
+
+#define DC_FG_CC_MTR0_REG		0xE3
+#define FG_CC_MTR0_VAL_MASK		0xFF
+#define FG_DES_CC_RES_LSB		1456	/* 1.456mAhr */
+
+#define DC_FG_OCV_CAP_REG		0xE4
+#define FG_OCV_CAP_VALID		(1 << 7)
+#define FG_OCV_CAP_VAL_MASK		0x7F
+
+#define DC_FG_CC_CAP_REG		0xE5
+#define FG_CC_CAP_VALID			(1 << 7)
+#define FG_CC_CAP_VAL_MASK		0x7F
+
+#define DC_FG_LOW_CAP_REG		0xE6
+#define FG_LOW_CAP_THR1_MASK		0xf0	/* 5% tp 20% */
+#define FG_LOW_CAP_THR1_VAL		0xa0	/* 15 perc */
+#define FG_LOW_CAP_THR2_MASK		0x0f	/* 0% to 15% */
+#define FG_LOW_CAP_WARN_THR		14	/* 14 perc */
+#define FG_LOW_CAP_CRIT_THR		4	/* 4 perc */
+#define FG_LOW_CAP_SHDN_THR		0	/* 0 perc */
+
+#define DC_FG_TUNING_CNTL0		0xE8
+#define DC_FG_TUNING_CNTL1		0xE9
+#define DC_FG_TUNING_CNTL2		0xEA
+#define DC_FG_TUNING_CNTL3		0xEB
+#define DC_FG_TUNING_CNTL4		0xEC
+#define DC_FG_TUNING_CNTL5		0xED
+
+/* each LSB is equal to 1.1mV */
+#define ADC_TO_VBATT(a)			((a * 11) / 10)
+
+/* each LSB is equal to 1mA */
+#define ADC_TO_BATCUR(a)		(a)
+
+/* each LSB is equal to 1mA */
+#define ADC_TO_PMICTEMP(a)		(a - 267)
+
+#define STATUS_MON_DELAY_JIFFIES	(HZ * 60)	/*60 sec */
+
+#define DC_FG_INTR_NUM			6
+
+#define THERM_CURVE_MAX_SAMPLES		18
+#define THERM_CURVE_MAX_VALUES		4
+
+/* No of times we should retry on -EAGAIN error */
+#define NR_RETRY_CNT	3
+
+#define DEV_NAME			"dollar_cove_battery"
+
+enum {
+	QWBTU_IRQ = 0,
+	WBTU_IRQ,
+	QWBTO_IRQ,
+	WBTO_IRQ,
+	WL2_IRQ,
+	WL1_IRQ,
+};
+
+struct pmic_fg_info {
+	struct platform_device *pdev;
+	struct dollarcove_fg_pdata *pdata;
+	int			irq[DC_FG_INTR_NUM];
+	struct power_supply	bat;
+	struct mutex		lock;
+
+	int			status;
+	/* Worker to monitor status and faults */
+	struct delayed_work status_monitor;
+};
+
+static enum power_supply_property pmic_fg_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+};
+
+/*
+ * This array represents the Battery Pack thermistor
+ * temperature and corresponding ADC value limits
+ */
+static int const therm_curve_data[THERM_CURVE_MAX_SAMPLES]
+	[THERM_CURVE_MAX_VALUES] = {
+	/* {temp_max, temp_min, adc_max, adc_min} */
+	{-15, -20, 682, 536},
+	{-10, -15, 536, 425},
+	{-5, -10, 425, 338},
+	{0, -5, 338, 272},
+	{5, 0, 272, 220},
+	{10, 5, 220, 179},
+	{15, 10, 179, 146},
+	{20, 15, 146, 120},
+	{25, 20, 120, 100},
+	{30, 25, 100, 83},
+	{35, 30, 83, 69},
+	{40, 35, 69, 58},
+	{45, 40, 58, 49},
+	{50, 45, 49, 41},
+	{55, 50, 41, 35},
+	{60, 55, 35, 30},
+	{65, 60, 30, 25},
+	{70, 65, 25, 22},
+};
+
+static int pmic_fg_reg_readb(struct pmic_fg_info *info, int reg)
+{
+	int ret, i;
+
+	for (i = 0; i < NR_RETRY_CNT; i++) {
+		ret = intel_soc_pmic_readb(reg);
+		if (ret == -EAGAIN || ret == -ETIMEDOUT)
+			continue;
+		else
+			break;
+	}
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "pmic reg read err:%d\n", ret);
+
+	return ret;
+}
+
+static int pmic_fg_reg_writeb(struct pmic_fg_info *info, int reg, u8 val)
+{
+	int ret, i;
+
+	for (i = 0; i < NR_RETRY_CNT; i++) {
+		ret = intel_soc_pmic_writeb(reg, val);
+		if (ret == -EAGAIN || ret == -ETIMEDOUT)
+			continue;
+		else
+			break;
+	}
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "pmic reg write err:%d\n", ret);
+
+	return ret;
+}
+
+static void pmic_fg_dump_init_regs(struct pmic_fg_info *info)
+{
+	int i;
+
+	dev_info(&info->pdev->dev, "reg:%x, val:%x\n",
+			DC_CHRG_CCCV_REG,
+			pmic_fg_reg_readb(info, DC_CHRG_CCCV_REG));
+
+	for (i = 0; i < BAT_CURVE_SIZE; i++) {
+		dev_info(&info->pdev->dev, "reg:%x, val:%x\n",
+			DC_FG_OCV_CURVE_REG + i,
+			pmic_fg_reg_readb(info, DC_FG_OCV_CURVE_REG + i));
+	}
+
+	dev_info(&info->pdev->dev, "reg:%x, val:%x\n",
+				DC_FG_CNTL_REG,
+				pmic_fg_reg_readb(info, DC_FG_CNTL_REG));
+	dev_info(&info->pdev->dev, "reg:%x, val:%x\n",
+				DC_FG_DES_CAP1_REG,
+				pmic_fg_reg_readb(info, DC_FG_DES_CAP1_REG));
+	dev_info(&info->pdev->dev, "reg:%x, val:%x\n",
+				DC_FG_DES_CAP0_REG,
+				pmic_fg_reg_readb(info, DC_FG_DES_CAP0_REG));
+	dev_info(&info->pdev->dev, "reg:%x, val:%x\n",
+				DC_FG_RDC1_REG,
+				pmic_fg_reg_readb(info, DC_FG_RDC1_REG));
+	dev_info(&info->pdev->dev, "reg:%x, val:%x\n",
+				DC_FG_RDC0_REG,
+				pmic_fg_reg_readb(info, DC_FG_RDC0_REG));
+}
+
+static int conv_adc_temp(int adc_val, int adc_max, int adc_diff, int temp_diff)
+{
+	int ret;
+
+	ret = (adc_max - adc_val) * temp_diff;
+	return ret / adc_diff;
+}
+
+static bool is_valid_temp_adc_range(int val, int min, int max)
+{
+	if (val > min && val <= max)
+		return true;
+	else
+		return false;
+}
+
+static int dc_xpwr_get_batt_temp(int adc_val, int *temp)
+{
+	int i;
+
+	for (i = 0; i < THERM_CURVE_MAX_SAMPLES; i++) {
+		/* linear approximation for battery pack temperature */
+		if (is_valid_temp_adc_range(adc_val, therm_curve_data[i][3],
+					    therm_curve_data[i][2])) {
+
+			*temp = conv_adc_temp(adc_val, therm_curve_data[i][2],
+					     therm_curve_data[i][2] -
+					     therm_curve_data[i][3],
+					     therm_curve_data[i][0] -
+					     therm_curve_data[i][1]);
+
+			*temp += therm_curve_data[i][1];
+			break;
+		}
+	}
+
+	if (i >= THERM_CURVE_MAX_SAMPLES)
+		return -ERANGE;
+
+	return 0;
+
+}
+
+/**
+ * pmic_read_adc_val - read ADC value of specified sensors
+ * @channel: channel of the sensor to be sampled
+ * @sensor_val: pointer to the charger property to hold sampled value
+ * @chc :  battery info pointer
+ *
+ * Returns 0 if success
+ */
+static int pmic_read_adc_val(const char *map, const char *name,
+			int *raw_val, struct pmic_fg_info *info)
+{
+	int ret, val;
+	struct iio_channel *indio_chan;
+
+	indio_chan = iio_channel_get(NULL, name);
+	if (IS_ERR_OR_NULL(indio_chan)) {
+		ret = PTR_ERR(indio_chan);
+		goto exit;
+	}
+	ret = iio_read_channel_raw(indio_chan, &val);
+	if (ret) {
+		dev_err(&info->pdev->dev, "IIO channel read error\n");
+		goto err_exit;
+	}
+
+	dev_dbg(&info->pdev->dev, "adc raw val=%x\n", val);
+	*raw_val = val;
+
+err_exit:
+	iio_channel_release(indio_chan);
+exit:
+	return ret;
+}
+
+static int pmic_fg_get_vbatt(struct pmic_fg_info *info, int *vbatt)
+{
+	int ret, raw_val;
+
+	ret = pmic_read_adc_val("VIBAT", "VBAT", &raw_val, info);
+	if (ret < 0)
+		goto vbatt_read_fail;
+
+	*vbatt = ADC_TO_VBATT(raw_val);
+vbatt_read_fail:
+	return ret;
+}
+
+static int pmic_fg_get_current(struct pmic_fg_info *info, int *cur)
+{
+	int ret = 0, raw_val, sign;
+	int pwr_stat;
+
+	pwr_stat = pmic_fg_reg_readb(info, DC_PS_STAT_REG);
+	if (pwr_stat < 0) {
+		dev_err(&info->pdev->dev, "PWR STAT read failed:%d\n", pwr_stat);
+		return pwr_stat;
+	}
+
+	if (pwr_stat & PS_STAT_BAT_CHRG_DIR) {
+		sign = 1;
+		ret = pmic_read_adc_val("CURRENT", "BATCCUR", &raw_val, info);
+	} else {
+		sign = -1;
+		ret = pmic_read_adc_val("CURRENT", "BATDCUR", &raw_val, info);
+	}
+	if (ret < 0)
+		goto cur_read_fail;
+
+	*cur = raw_val * sign;
+cur_read_fail:
+	return ret;
+}
+
+static int pmic_fg_get_btemp(struct pmic_fg_info *info, int *btemp)
+{
+	int ret, raw_val;
+
+	ret = pmic_read_adc_val("THERMAL", "BATTEMP", &raw_val, info);
+	if (ret < 0)
+		goto btemp_read_fail;
+
+	/*
+	 * Convert the TS pin ADC codes in to 10's of Kohms
+	 * by deviding the ADC code with 10 and pass it to
+	 * the Thermistor look up function.
+	 */
+	ret = dc_xpwr_get_batt_temp(raw_val / 10, btemp);
+	if (ret < 0)
+		dev_warn(&info->pdev->dev, "ADC conversion error%d\n", ret);
+	else
+		dev_dbg(&info->pdev->dev,
+				"ADC code:%d, TEMP:%d\n", raw_val, *btemp);
+btemp_read_fail:
+	return ret;
+}
+
+static int pmic_fg_get_vocv(struct pmic_fg_info *info, int *vocv)
+{
+	int ret, value;
+
+	/*
+	 * OCV readings are 12-bit length. So Read
+	 * the MSB first left-shift by 4 bits and
+	 * read the lower nibble.
+	 */
+	ret = pmic_fg_reg_readb(info, DC_FG_OCVH_REG);
+	if (ret < 0)
+		goto vocv_read_fail;
+	value = ret << 4;
+
+	ret = pmic_fg_reg_readb(info, DC_FG_OCVL_REG);
+	if (ret < 0)
+		goto vocv_read_fail;
+	value |= (ret & 0xf);
+
+	*vocv = ADC_TO_VBATT(value);
+vocv_read_fail:
+	return ret;
+}
+
+static int pmic_fg_battery_health(struct pmic_fg_info *info)
+{
+	int temp, vocv;
+	int ret, health = POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	ret = pmic_fg_get_btemp(info, &temp);
+	if (ret < 0)
+		goto health_read_fail;
+
+	ret = pmic_fg_get_vocv(info, &vocv);
+	if (ret < 0)
+		goto health_read_fail;
+
+	if (vocv > info->pdata->design_max_volt)
+		health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	else if (temp > info->pdata->max_temp ||
+			temp < info->pdata->min_temp)
+		health = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (vocv < info->pdata->design_min_volt)
+		health = POWER_SUPPLY_HEALTH_DEAD;
+	else
+		health = POWER_SUPPLY_HEALTH_GOOD;
+
+health_read_fail:
+	return health;
+}
+
+static int pmic_fg_get_battery_property(struct power_supply *psy,
+					enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	struct pmic_fg_info *info = container_of(psy,
+				struct pmic_fg_info, bat);
+	int ret = 0, value;
+
+	mutex_lock(&info->lock);
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = info->status;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = pmic_fg_battery_health(info);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		ret = pmic_fg_get_vbatt(info, &value);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+		val->intval = value * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		ret = pmic_fg_get_vocv(info, &value);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+
+		val->intval = value * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		ret = pmic_fg_get_current(info, &value);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+		val->intval = value * 1000;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		ret = pmic_fg_reg_readb(info, DC_CHRG_STAT_REG);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+
+		if (ret & CHRG_STAT_BAT_PRESENT)
+			val->intval = 1;
+		else
+			val->intval = 0;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		ret = pmic_fg_get_vocv(info, &value);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+
+		/* do Vocv min threshold check */
+		if (value < info->pdata->design_min_volt) {
+			val->intval = 0;
+			break;
+		}
+
+		ret = pmic_fg_reg_readb(info, DC_FG_REP_CAP_REG);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+
+		if (!(ret & FG_REP_CAP_VALID))
+			dev_err(&info->pdev->dev,
+				"capacity measurement not valid\n");
+		val->intval = (ret & FG_REP_CAP_VAL_MASK);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		ret = pmic_fg_get_btemp(info, &value);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+		val->intval = value * 10;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_NOW:
+		ret = pmic_fg_reg_readb(info, DC_FG_CC_MTR1_REG);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+
+		value = (ret & FG_CC_MTR1_VAL_MASK) << 8;
+		ret = pmic_fg_reg_readb(info, DC_FG_CC_MTR0_REG);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+		value |= (ret & FG_CC_MTR0_VAL_MASK);
+		val->intval = value * FG_DES_CAP_RES_LSB;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		ret = pmic_fg_reg_readb(info, DC_FG_DES_CAP1_REG);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+
+		value = (ret & DC_FG_DES_CAP1_VAL_MASK) << 8;
+		ret = pmic_fg_reg_readb(info, DC_FG_DES_CAP0_REG);
+		if (ret < 0)
+			goto pmic_fg_read_err;
+		value |= (ret & FG_DES_CAP0_VAL_MASK);
+		val->intval = value * FG_DES_CAP_RES_LSB;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = info->pdata->design_cap * 1000;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = info->pdata->battid;
+		break;
+	default:
+		mutex_unlock(&info->lock);
+		return -EINVAL;
+	}
+
+	mutex_unlock(&info->lock);
+	return 0;
+
+pmic_fg_read_err:
+	mutex_unlock(&info->lock);
+	return ret;
+}
+
+static int pmic_fg_set_battery_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    const union power_supply_propval *val)
+{
+	struct pmic_fg_info *info = container_of(psy,
+				struct pmic_fg_info, bat);
+	int ret = 0;
+
+	mutex_lock(&info->lock);
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		info->status = val->intval;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&info->lock);
+	return ret;
+}
+
+static void pmic_fg_status_monitor(struct work_struct *work)
+{
+	struct pmic_fg_info *info = container_of(work,
+		struct pmic_fg_info, status_monitor.work);
+
+	power_supply_changed(&info->bat);
+	schedule_delayed_work(&info->status_monitor, STATUS_MON_DELAY_JIFFIES);
+}
+
+static irqreturn_t pmic_fg_thread_handler(int irq, void *dev)
+{
+	struct pmic_fg_info *info = dev;
+	int i;
+
+	for (i = 0; i < DC_FG_INTR_NUM; i++) {
+		if (info->irq[i] == irq)
+			break;
+	}
+
+	if (i >= DC_FG_INTR_NUM) {
+		dev_warn(&info->pdev->dev, "spurious interrupt!!\n");
+		return IRQ_NONE;
+	}
+
+	switch (i) {
+	case QWBTU_IRQ:
+		dev_info(&info->pdev->dev,
+			"Quit Battery Under Temperature(DISCHRG) INTR\n");
+		break;
+	case WBTU_IRQ:
+		dev_info(&info->pdev->dev,
+			"Hit Battery Over Temperature(DISCHRG) INTR\n");
+		break;
+	case QWBTO_IRQ:
+		dev_info(&info->pdev->dev,
+			"Quit Battery Over Temperature(DISCHRG) INTR\n");
+		break;
+	case WBTO_IRQ:
+		dev_info(&info->pdev->dev,
+			"Hit Battery Over Temperature(DISCHRG) INTR\n");
+		break;
+	case WL2_IRQ:
+		dev_info(&info->pdev->dev, "Low Batt Warning(2) INTR\n");
+		break;
+	case WL1_IRQ:
+		dev_info(&info->pdev->dev, "Low Batt Warning(1) INTR\n");
+		break;
+	default:
+		dev_warn(&info->pdev->dev, "Spurious Interrupt!!!\n");
+	}
+
+	power_supply_changed(&info->bat);
+	return IRQ_HANDLED;
+}
+
+static void pmic_fg_external_power_changed(struct power_supply *psy)
+{
+	struct pmic_fg_info *info = container_of(psy,
+				struct pmic_fg_info, bat);
+
+	power_supply_changed(&info->bat);
+}
+
+static int pmic_fg_set_lowbatt_thresholds(struct pmic_fg_info *info)
+{
+	int ret;
+	u8 reg_val;
+
+	ret = pmic_fg_reg_readb(info, DC_FG_REP_CAP_REG);
+	if (ret < 0) {
+		dev_err(&info->pdev->dev, "%s:read err:%d\n", __func__, ret);
+		return ret;
+	}
+	ret = (ret & FG_REP_CAP_VAL_MASK);
+
+	if (ret > FG_LOW_CAP_WARN_THR)
+		reg_val = FG_LOW_CAP_WARN_THR;
+	else if (ret > FG_LOW_CAP_CRIT_THR)
+		reg_val = FG_LOW_CAP_CRIT_THR;
+	else
+		reg_val = FG_LOW_CAP_SHDN_THR;
+
+	reg_val |= FG_LOW_CAP_THR1_VAL;
+	ret = pmic_fg_reg_writeb(info, DC_FG_LOW_CAP_REG, reg_val);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "%s:write err:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static int pmic_fg_program_vbatt_full(struct pmic_fg_info *info)
+{
+	int ret;
+	u8 val;
+
+	ret = pmic_fg_reg_readb(info, DC_CHRG_CCCV_REG);
+	if (ret < 0)
+		goto fg_prog_ocv_fail;
+	else
+		val = (ret & ~CHRG_CCCV_CV_MASK);
+
+	switch (info->pdata->design_max_volt) {
+	case CV_4100:
+		val |= (CHRG_CCCV_CV_4100MV << CHRG_CCCV_CV_BIT_POS);
+		break;
+	case CV_4150:
+		val |= (CHRG_CCCV_CV_4150MV << CHRG_CCCV_CV_BIT_POS);
+		break;
+	case CV_4200:
+		val |= (CHRG_CCCV_CV_4200MV << CHRG_CCCV_CV_BIT_POS);
+		break;
+	case CV_4350:
+		val |= (CHRG_CCCV_CV_4350MV << CHRG_CCCV_CV_BIT_POS);
+		break;
+	default:
+		val |= (CHRG_CCCV_CV_4200MV << CHRG_CCCV_CV_BIT_POS);
+		break;
+	}
+
+	ret = pmic_fg_reg_writeb(info, DC_CHRG_CCCV_REG, val);
+fg_prog_ocv_fail:
+	return ret;
+}
+
+static int pmic_fg_program_design_cap(struct pmic_fg_info *info)
+{
+	int ret;
+
+	ret = pmic_fg_reg_writeb(info, DC_FG_DES_CAP1_REG, info->pdata->cap1);
+	if (ret < 0)
+		goto fg_prog_descap_fail;
+
+	ret = pmic_fg_reg_writeb(info, DC_FG_DES_CAP0_REG, info->pdata->cap0);
+
+fg_prog_descap_fail:
+	return ret;
+}
+
+static int pmic_fg_program_ocv_curve(struct pmic_fg_info *info)
+{
+	int ret, i;
+
+	for (i = 0; i < BAT_CURVE_SIZE; i++) {
+		ret = pmic_fg_reg_writeb(info,
+			DC_FG_OCV_CURVE_REG + i, info->pdata->bat_curve[i]);
+		if (ret < 0)
+			goto fg_prog_ocv_fail;
+	}
+
+fg_prog_ocv_fail:
+	return ret;
+}
+
+static int pmic_fg_program_rdc_vals(struct pmic_fg_info *info)
+{
+	int ret;
+
+	ret = pmic_fg_reg_writeb(info, DC_FG_RDC1_REG, info->pdata->rdc1);
+	if (ret < 0)
+		goto fg_prog_ocv_fail;
+
+	ret = pmic_fg_reg_writeb(info, DC_FG_RDC0_REG, info->pdata->rdc0);
+
+fg_prog_ocv_fail:
+	return ret;
+}
+
+static void pmic_fg_init_config_regs(struct pmic_fg_info *info)
+{
+	int ret;
+
+
+	/*
+	 * check if the config data is already
+	 * programmed and if so just return.
+	 */
+	ret = pmic_fg_reg_readb(info, DC_FG_DES_CAP1_REG);
+	if (ret < 0) {
+		dev_warn(&info->pdev->dev, "CAP1 reg read err!!\n");
+	} else if (ret & DC_FG_DES_CAP1_VALID) {
+		dev_info(&info->pdev->dev, "FG data is already initialized\n");
+		pmic_fg_dump_init_regs(info);
+		return;
+	} else {
+		dev_info(&info->pdev->dev, "FG data need to be initialized\n");
+	}
+
+	ret = pmic_fg_program_vbatt_full(info);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "set vbatt full fail:%d\n", ret);
+
+	ret = pmic_fg_program_design_cap(info);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "set design cap fail:%d\n", ret);
+
+	ret = pmic_fg_program_rdc_vals(info);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "set rdc fail:%d\n", ret);
+
+	ret = pmic_fg_program_ocv_curve(info);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "set ocv curve fail:%d\n", ret);
+
+	ret = pmic_fg_set_lowbatt_thresholds(info);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "lowbatt thr set fail:%d\n", ret);
+
+	ret = pmic_fg_reg_writeb(info, DC_FG_CNTL_REG, 0xef);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "gauge cntl set fail:%d\n", ret);
+
+	pmic_fg_dump_init_regs(info);
+}
+
+static void pmic_fg_init_irq(struct pmic_fg_info *info)
+{
+	int ret, i;
+
+	for (i = 0; i < DC_FG_INTR_NUM; i++) {
+		info->irq[i] = platform_get_irq(info->pdev, i);
+		ret = request_threaded_irq(info->irq[i],
+				NULL, pmic_fg_thread_handler,
+				IRQF_ONESHOT, DEV_NAME, info);
+		if (ret) {
+			dev_warn(&info->pdev->dev,
+				"cannot get IRQ:%d\n", info->irq[i]);
+			info->irq[i] = -1;
+			goto intr_failed;
+		} else {
+			dev_info(&info->pdev->dev, "IRQ No:%d\n", info->irq[i]);
+		}
+	}
+	return;
+
+intr_failed:
+	for (; i > 0; i--) {
+		free_irq(info->irq[i - 1], info);
+		info->irq[i - 1] = -1;
+	}
+}
+
+static void pmic_fg_init_hw_regs(struct pmic_fg_info *info)
+{
+	/* program temperature thresholds */
+	intel_soc_pmic_writeb(DC_FG_VLTFW_REG, FG_VLTFW_0C);
+	intel_soc_pmic_writeb(DC_FG_VHTFW_REG, FG_VHTFW_56C);
+
+	/* enable interrupts */
+	intel_soc_pmic_setb(DC_TEMP_IRQ_CFG_REG, TEMP_IRQ_CFG_MASK);
+	intel_soc_pmic_setb(DC_FG_IRQ_CFG_REG, FG_IRQ_CFG_LOWBATT_MASK);
+}
+
+static void pmic_fg_init_psy(struct pmic_fg_info *info)
+{
+	info->status = POWER_SUPPLY_STATUS_DISCHARGING;
+}
+
+static int pmic_fg_probe(struct platform_device *pdev)
+{
+	struct pmic_fg_info *info;
+	int ret;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&pdev->dev, "mem alloc failed\n");
+		return -ENOMEM;
+	}
+
+	info->pdev = pdev;
+	info->pdata = pdev->dev.platform_data;
+	if (!info->pdata)
+		return -ENODEV;
+
+	platform_set_drvdata(pdev, info);
+	mutex_init(&info->lock);
+	INIT_DELAYED_WORK(&info->status_monitor, pmic_fg_status_monitor);
+
+	pmic_fg_init_config_regs(info);
+	pmic_fg_init_psy(info);
+
+	info->bat.name = DEV_NAME;
+	info->bat.type = POWER_SUPPLY_TYPE_BATTERY;
+	info->bat.properties = pmic_fg_props;
+	info->bat.num_properties = ARRAY_SIZE(pmic_fg_props);
+	info->bat.get_property = pmic_fg_get_battery_property;
+	info->bat.set_property = pmic_fg_set_battery_property;
+	info->bat.external_power_changed = pmic_fg_external_power_changed;
+	ret = power_supply_register(&pdev->dev, &info->bat);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register battery: %d\n", ret);
+		return ret;
+	}
+
+	/* register fuel gauge interrupts */
+	pmic_fg_init_irq(info);
+	pmic_fg_init_hw_regs(info);
+	schedule_delayed_work(&info->status_monitor, STATUS_MON_DELAY_JIFFIES);
+	return 0;
+}
+
+static int pmic_fg_remove(struct platform_device *pdev)
+{
+	struct pmic_fg_info *info = platform_get_drvdata(pdev);
+	int i;
+
+	cancel_delayed_work_sync(&info->status_monitor);
+	for (i = 0; i < DC_FG_INTR_NUM && info->irq[i] != -1; i++)
+		free_irq(info->irq[i], info);
+	power_supply_unregister(&info->bat);
+	return 0;
+}
+
+static int pmic_fg_suspend(struct device *dev)
+{
+	struct pmic_fg_info *info = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s called\n", __func__);
+	/*
+	 * set lowbatt thresholds to
+	 * wake the platform from S3.
+	 */
+	pmic_fg_set_lowbatt_thresholds(info);
+	cancel_delayed_work_sync(&info->status_monitor);
+	return 0;
+}
+
+static int pmic_fg_resume(struct device *dev)
+{
+	struct pmic_fg_info *info = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s called\n", __func__);
+
+	power_supply_changed(&info->bat);
+	schedule_delayed_work(&info->status_monitor, STATUS_MON_DELAY_JIFFIES);
+	return 0;
+}
+
+static int pmic_fg_runtime_suspend(struct device *dev)
+{
+
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int pmic_fg_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int pmic_fg_runtime_idle(struct device *dev)
+{
+
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops pmic_fg_pm_ops = {
+		SET_SYSTEM_SLEEP_PM_OPS(pmic_fg_suspend,
+				pmic_fg_resume)
+		SET_RUNTIME_PM_OPS(pmic_fg_runtime_suspend,
+				pmic_fg_runtime_resume,
+				pmic_fg_runtime_idle)
+};
+
+static struct platform_driver pmic_fg_driver = {
+	.driver = {
+		.name = DEV_NAME,
+		.owner	= THIS_MODULE,
+		.pm = &pmic_fg_pm_ops,
+	},
+	.probe = pmic_fg_probe,
+	.remove = pmic_fg_remove,
+};
+
+static int __init dc_pmic_fg_init(void)
+{
+	return platform_driver_register(&pmic_fg_driver);
+}
+device_initcall(dc_pmic_fg_init);
+
+static void __exit dc_pmic_fg_exit(void)
+{
+	platform_driver_unregister(&pmic_fg_driver);
+}
+module_exit(dc_pmic_fg_exit);
+
+MODULE_AUTHOR("Ramakrishna Pallala <ramakrishna.pallala@intel.com>");
+MODULE_DESCRIPTION("Dollar Cove(X-power) PMIC Battery Driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ linux/drivers/power/dc_xpwr_charger.c
@@ -0,0 +1,987 @@
+/*
+ * Intel Dollar Cove PMIC Charger driver
+ *
+ * Copyright (C) 2013 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Ramakrishna Pallala <ramakrishna.pallala@intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/usb/otg.h>
+#include <linux/notifier.h>
+#include <linux/power_supply.h>
+#include <linux/idr.h>
+#include <linux/slab.h>
+#include <asm/unaligned.h>
+#include <linux/notifier.h>
+#include <linux/gpio.h>
+#include <linux/acpi.h>
+#include <linux/mfd/intel_soc_pmic.h>
+#include <linux/power/dc_xpwr_charger.h>
+#include <linux/extcon.h>
+
+#define DC_PS_STAT_REG			0x00
+#define PS_STAT_VBUS_TRIGGER		(1 << 0)
+#define PS_STAT_BAT_CHRG_DIR		(1 << 2)
+#define PS_STAT_VBAT_ABOVE_VHOLD	(1 << 3)
+#define PS_STAT_VBUS_VALID		(1 << 4)
+#define PS_STAT_VBUS_PRESENT		(1 << 5)
+
+#define DC_CHRG_STAT_REG		0x01
+#define CHRG_STAT_BAT_SAFE_MODE		(1 << 3)
+#define CHRG_STAT_BAT_VALID		(1 << 4)
+#define CHRG_STAT_BAT_PRESENT		(1 << 5)
+#define CHRG_STAT_CHARGING		(1 << 6)
+#define CHRG_STAT_PMIC_OTP		(1 << 7)
+
+#define DC_VBUS_ISPOUT_REG		0x30
+#define VBUS_ISPOUT_CUR_LIM_MASK	0x03
+#define VBUS_ISPOUT_CUR_LIM_BIT_POS	0
+#define VBUS_ISPOUT_CUR_LIM_900MA	0x0	/* 900mA */
+#define VBUS_ISPOUT_CUR_LIM_1500MA	0x1	/* 1500mA */
+#define VBUS_ISPOUT_CUR_LIM_2000MA	0x2	/* 2000mA */
+#define VBUS_ISPOUT_CUR_NO_LIM		0x3	/* 2500mA */
+#define VBUS_ISPOUT_VHOLD_SET_MASK	0x31
+#define VBUS_ISPOUT_VHOLD_SET_BIT_POS	0x3
+#define VBUS_ISPOUT_VHOLD_SET_OFFSET	4000	/* 4000mV */
+#define VBUS_ISPOUT_VHOLD_SET_LSB_RES	100	/* 100mV */
+#define VBUS_ISPOUT_VHOLD_SET_4300MV	0x3	/* 4300mV */
+#define VBUS_ISPOUT_VBUS_PATH_DIS	(1 << 7)
+
+#define DC_CHRG_CCCV_REG		0x33
+#define CHRG_CCCV_CC_MASK		0xf		/* 4 bits */
+#define CHRG_CCCV_CC_BIT_POS		0
+#define CHRG_CCCV_CC_OFFSET		200		/* 200mA */
+#define CHRG_CCCV_CC_LSB_RES		200		/* 200mA */
+#define CHRG_CCCV_ITERM_20P		(1 << 4)	/* 20% of CC */
+#define CHRG_CCCV_CV_MASK		0x60		/* 2 bits */
+#define CHRG_CCCV_CV_BIT_POS		5
+#define CHRG_CCCV_CV_4100MV		0x0		/* 4.10V */
+#define CHRG_CCCV_CV_4150MV		0x1		/* 4.15V */
+#define CHRG_CCCV_CV_4200MV		0x2		/* 4.20V */
+#define CHRG_CCCV_CV_4350MV		0x3		/* 4.35V */
+#define CHRG_CCCV_CHG_EN		(1 << 7)
+
+#define DC_CHRG_CNTL2_REG		0x34
+#define CNTL2_CC_TIMEOUT_MASK		0x3	/* 2 bits */
+#define CNTL2_CC_TIMEOUT_OFFSET		6	/* 6 Hrs */
+#define CNTL2_CC_TIMEOUT_LSB_RES	2	/* 2 Hrs */
+#define CNTL2_CC_TIMEOUT_12HRS		0x3	/* 12 Hrs */
+#define CNTL2_CHGLED_TYPEB		(1 << 4)
+#define CNTL2_CHG_OUT_TURNON		(1 << 5)
+#define CNTL2_PC_TIMEOUT_MASK		0xC0
+#define CNTL2_PC_TIMEOUT_OFFSET		40	/* 40 mins */
+#define CNTL2_PC_TIMEOUT_LSB_RES	10	/* 10 mins */
+#define CNTL2_PC_TIMEOUT_70MINS		0x3
+
+#define DC_CHRG_ILIM_REG		0x35
+#define CHRG_ILIM_TEMP_LOOP_EN		(1 << 3)
+#define CHRG_ILIM_MASK			0xf0
+#define CHRG_ILIM_BIT_POS		4
+#define CHRG_ILIM_100MA			0x0	/* 100mA */
+#define CHRG_ILIM_500MA			0x1	/* 500mA */
+#define CHRG_ILIM_900MA			0x2	/* 900mA */
+#define CHRG_ILIM_1500MA		0x3	/* 1500mA */
+#define CHRG_ILIM_2000MA		0x4	/* 2000mA */
+#define CHRG_ILIM_2500MA		0x5	/* 2500mA */
+#define CHRG_ILIM_3000MA		0x6	/* 3000mA */
+
+#define DC_CHRG_VLTFC_REG		0x38
+#define CHRG_VLTFC_N5C			0xCA	/* -5 DegC */
+
+#define DC_CHRG_VHTFC_REG		0x39
+#define CHRG_VHTFC_60C			0x12	/* 60 DegC */
+
+#define DC_PWRSRC_IRQ_CFG_REG		0x40
+#define PWRSRC_IRQ_CFG_VBUS_LOW		(1 << 2)
+#define PWRSRC_IRQ_CFG_VBUS_HIGH	(1 << 3)
+#define PWRSRC_IRQ_CFG_VBUS_OVP		(1 << 4)
+#define PWRSRC_IRQ_CFG_SVBUS_LOW	(1 << 5)
+#define PWRSRC_IRQ_CFG_SVBUS_HIGH	(1 << 6)
+#define PWRSRC_IRQ_CFG_SVBUS_OVP	(1 << 7)
+
+#define DC_BAT_IRQ_CFG_REG		0x41
+#define BAT_IRQ_CFG_CHRG_DONE		(1 << 2)
+#define BAT_IRQ_CFG_CHRG_START		(1 << 3)
+#define BAT_IRQ_CFG_BAT_SAFE_EXIT	(1 << 4)
+#define BAT_IRQ_CFG_BAT_SAFE_ENTER	(1 << 5)
+#define BAT_IRQ_CFG_BAT_DISCON		(1 << 6)
+#define BAT_IRQ_CFG_BAT_CONN		(1 << 7)
+#define BAT_IRQ_CFG_BAT_MASK		0xFC
+
+#define DC_TEMP_IRQ_CFG_REG		0x42
+#define TEMP_IRQ_CFG_QCBTU		(1 << 4)
+#define TEMP_IRQ_CFG_CBTU		(1 << 5)
+#define TEMP_IRQ_CFG_QCBTO		(1 << 6)
+#define TEMP_IRQ_CFG_CBTO		(1 << 7)
+#define TEMP_IRQ_CFG_MASK		0xF0
+
+#define DC_PWRSRC_IRQ_STAT_REG		0x48
+#define PWRSRC_IRQ_STAT_VBUS_LOW	(1 << 2)
+#define PWRSRC_IRQ_STAT_VBUS_HIGH	(1 << 3)
+#define PWRSRC_IRQ_STAT_VBUS_OVP	(1 << 4)
+
+#define DC_BAT_IRQ_STAT_REG		0x49
+#define BAT_IRQ_STAT_CHRG_DONE		(1 << 2)
+#define BAT_IRQ_STAT_CHARGING		(1 << 3)
+#define BAT_IRQ_STAT_BAT_SAFE_EXIT	(1 << 4)
+#define BAT_IRQ_STAT_BAT_SAFE_ENTER	(1 << 5)
+#define BAT_IRQ_STAT_BAT_DISCON		(1 << 6)
+#define BAT_IRQ_STAT_BAT_CONN		(1 << 7)
+
+#define DC_TEMP_IRQ_STAT_REG		0x4A
+#define TEMP_IRQ_STAT_QWBTU		(1 << 0)
+#define TEMP_IRQ_STAT_WBTU		(1 << 1)
+#define TEMP_IRQ_STAT_QWBTO		(1 << 2)
+#define TEMP_IRQ_STAT_WBTO		(1 << 3)
+#define TEMP_IRQ_STAT_QCBTU		(1 << 4)
+#define TEMP_IRQ_STAT_CBTU		(1 << 5)
+#define TEMP_IRQ_STAT_QCBTO		(1 << 6)
+#define TEMP_IRQ_STAT_CBTO		(1 << 7)
+
+#define DC_PMIC_IRQ_STAT_REG		0x4B
+#define PMIC_IRQ_STAT_OTP		(1 << 7)
+
+#define CV_4100				4100	/* 4100mV */
+#define CV_4150				4150	/* 4150mV */
+#define CV_4200				4200	/* 4200mV */
+#define CV_4350				4350	/* 4350mV */
+
+#define ILIM_100MA			100	/* 100mA */
+#define ILIM_500MA			500	/* 500mA */
+#define ILIM_900MA			900	/* 900mA */
+#define ILIM_1500MA			1500	/* 1500mA */
+#define ILIM_2000MA			2000	/* 2000mA */
+#define ILIM_2500MA			2500	/* 2500mA */
+#define ILIM_3000MA			3000	/* 3000mA */
+
+#define DC_CHRG_INTR_NUM		9
+
+#define DEV_NAME			"dollar_cove_charger"
+
+enum {
+	VBUS_OV_IRQ = 0,
+	CHARGE_DONE_IRQ,
+	CHARGE_CHARGING_IRQ,
+	BAT_SAFE_QUIT_IRQ,
+	BAT_SAFE_ENTER_IRQ,
+	QCBTU_IRQ,
+	CBTU_IRQ,
+	QCBTO_IRQ,
+	CBTO_IRQ,
+};
+
+struct pmic_chrg_info {
+	struct platform_device *pdev;
+	struct dollarcove_chrg_pdata	*pdata;
+	int			irq[DC_CHRG_INTR_NUM];
+	struct power_supply	psy_usb;
+	struct mutex		lock;
+	struct work_struct	otg_work;
+	struct extcon_specific_cable_nb cable_obj;
+	struct notifier_block	id_nb;
+	bool			id_short;
+
+	int chrg_health;
+	int chrg_status;
+	int bat_health;
+	int cc;
+	int cv;
+	int inlmt;
+	int max_cc;
+	int max_cv;
+	int iterm;
+	int cable_type;
+	int cntl_state;
+	int max_temp;
+	int min_temp;
+	bool online;
+	bool present;
+	bool is_charging_enabled;
+	bool is_charger_enabled;
+	bool is_hw_chrg_term;
+};
+
+static enum power_supply_property pmic_chrg_usb_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_INLMT,
+	POWER_SUPPLY_PROP_ENABLE_CHARGING,
+	POWER_SUPPLY_PROP_ENABLE_CHARGER,
+	POWER_SUPPLY_PROP_CHARGE_TERM_CUR,
+	POWER_SUPPLY_PROP_CABLE_TYPE,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,
+	POWER_SUPPLY_PROP_MAX_TEMP,
+	POWER_SUPPLY_PROP_MIN_TEMP,
+};
+
+static int pmic_chrg_reg_readb(struct pmic_chrg_info *info, int reg)
+{
+	int ret;
+
+	ret = intel_soc_pmic_readb(reg);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "pmic reg read err:%d\n", ret);
+
+	return ret;
+}
+
+static int pmic_chrg_reg_writeb(struct pmic_chrg_info *info, int reg, u8 val)
+{
+	int ret;
+
+	ret = intel_soc_pmic_writeb(reg, val);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "pmic reg write err:%d\n", ret);
+
+	return ret;
+}
+
+static int pmic_chrg_reg_setb(struct pmic_chrg_info *info, int reg, u8 mask)
+{
+	int ret;
+
+	ret = intel_soc_pmic_setb(reg, mask);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "pmic reg set mask err:%d\n", ret);
+
+	return ret;
+}
+
+static int pmic_chrg_reg_clearb(struct pmic_chrg_info *info, int reg, u8 mask)
+{
+	int ret;
+
+	ret = intel_soc_pmic_clearb(reg, mask);
+	if (ret < 0)
+		dev_err(&info->pdev->dev, "pmic reg set mask err:%d\n", ret);
+
+	return ret;
+}
+
+static enum power_supply_type get_power_supply_type(
+		enum power_supply_charger_cable_type cable)
+{
+
+	switch (cable) {
+
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+		return POWER_SUPPLY_TYPE_USB_DCP;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+		return POWER_SUPPLY_TYPE_USB_CDP;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_ACA:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+		return POWER_SUPPLY_TYPE_USB_ACA;
+	case POWER_SUPPLY_CHARGER_TYPE_AC:
+		return POWER_SUPPLY_TYPE_MAINS;
+	case POWER_SUPPLY_CHARGER_TYPE_NONE:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+	default:
+		return POWER_SUPPLY_TYPE_USB;
+	}
+
+	return POWER_SUPPLY_TYPE_USB;
+}
+
+static inline int pmic_chrg_set_cc(struct pmic_chrg_info *info, int cc)
+{
+	u8 reg_val;
+	int ret;
+
+	/* read CCCV register */
+	ret = pmic_chrg_reg_readb(info, DC_CHRG_CCCV_REG);
+	if (ret < 0)
+		goto set_cc_fail;
+
+	if (cc < CHRG_CCCV_CC_OFFSET)
+		cc = CHRG_CCCV_CC_OFFSET;
+	else if (cc > info->max_cc)
+		cc = info->max_cc;
+
+	reg_val = (cc - CHRG_CCCV_CC_OFFSET) / CHRG_CCCV_CC_LSB_RES;
+	reg_val = (ret & ~CHRG_CCCV_CC_MASK) | (reg_val << CHRG_CCCV_CC_BIT_POS);
+	ret = pmic_chrg_reg_writeb(info, DC_CHRG_CCCV_REG, reg_val);
+
+set_cc_fail:
+	return ret;
+}
+
+static inline int pmic_chrg_set_cv(struct pmic_chrg_info *info, int cv)
+{
+	u8 reg_val;
+	int ret;
+
+	/* read CCCV register */
+	ret = pmic_chrg_reg_readb(info, DC_CHRG_CCCV_REG);
+	if (ret < 0)
+		goto set_cv_fail;
+
+	if (cv < CV_4100)
+		reg_val = CHRG_CCCV_CV_4100MV;
+	else if (cv < CV_4150)
+		reg_val = CHRG_CCCV_CV_4150MV;
+	else if (cv < CV_4200)
+		reg_val = CHRG_CCCV_CV_4200MV;
+	else
+		reg_val = CHRG_CCCV_CV_4350MV;
+
+	reg_val = (ret & ~CHRG_CCCV_CV_MASK) |
+				(reg_val << CHRG_CCCV_CV_BIT_POS);
+
+	ret = pmic_chrg_reg_writeb(info, DC_CHRG_CCCV_REG, reg_val);
+
+set_cv_fail:
+	return ret;
+}
+
+static inline int pmic_chrg_set_inlmt(struct pmic_chrg_info *info, int inlmt)
+{
+	u8 reg_val;
+	int ret;
+
+	/* Read in limit register */
+	ret = pmic_chrg_reg_readb(info, DC_CHRG_ILIM_REG);
+	if (ret < 0)
+		goto set_inlmt_fail;
+
+	if (inlmt <= ILIM_100MA)
+		reg_val = CHRG_ILIM_100MA;
+	else if (inlmt <= ILIM_500MA)
+		reg_val = CHRG_ILIM_500MA;
+	else if (inlmt <= ILIM_900MA)
+		reg_val = CHRG_ILIM_900MA;
+	else if (inlmt <= ILIM_1500MA)
+		reg_val = CHRG_ILIM_1500MA;
+	else if (inlmt <= ILIM_2000MA)
+		reg_val = CHRG_ILIM_2000MA;
+	else if (inlmt <= ILIM_2500MA)
+		reg_val = CHRG_ILIM_2500MA;
+	else
+		reg_val = CHRG_ILIM_3000MA;
+
+	reg_val = (ret & ~CHRG_ILIM_MASK) | (reg_val << CHRG_ILIM_BIT_POS);
+	ret = pmic_chrg_reg_writeb(info, DC_CHRG_ILIM_REG, reg_val);
+
+set_inlmt_fail:
+	return ret;
+}
+
+static inline int pmic_chrg_set_iterm(struct pmic_chrg_info *info, int iterm)
+{
+	info->iterm = iterm;
+	return 0;
+}
+
+static int pmic_chrg_enable_charger(struct pmic_chrg_info *info, bool enable)
+{
+	int ret;
+
+	if (enable)
+		ret = pmic_chrg_reg_clearb(info,
+			DC_VBUS_ISPOUT_REG, VBUS_ISPOUT_VBUS_PATH_DIS);
+	else
+		ret = pmic_chrg_reg_setb(info,
+			DC_VBUS_ISPOUT_REG, VBUS_ISPOUT_VBUS_PATH_DIS);
+	return ret;
+}
+
+static int pmic_chrg_enable_charging(struct pmic_chrg_info *info, bool enable)
+{
+	int ret;
+
+	ret = pmic_chrg_enable_charger(info, true);
+	if (ret < 0)
+		dev_warn(&info->pdev->dev, "vbus path disable failed\n");
+
+	if (enable)
+		ret = pmic_chrg_reg_setb(info,
+			DC_CHRG_CCCV_REG, CHRG_CCCV_CHG_EN);
+	else
+		ret = pmic_chrg_reg_clearb(info,
+			DC_CHRG_CCCV_REG, CHRG_CCCV_CHG_EN);
+	return ret;
+}
+
+static int pmic_chrg_is_present(struct pmic_chrg_info *info)
+{
+	int ret, present = 0;
+
+	ret = pmic_chrg_reg_readb(info, DC_PS_STAT_REG);
+	if (ret < 0)
+		return ret;
+
+	if (ret & PS_STAT_VBUS_PRESENT)
+		present = 1;
+	return present;
+}
+
+static int pmic_chrg_is_online(struct pmic_chrg_info *info)
+{
+	int ret, online = 0;
+
+	ret = pmic_chrg_reg_readb(info, DC_PS_STAT_REG);
+	if (ret < 0)
+		return ret;
+
+	if (ret & PS_STAT_VBUS_VALID)
+		online = 1;
+	return online;
+}
+
+static int get_charger_health(struct pmic_chrg_info *info)
+{
+	int ret, pwr_stat, chrg_stat, pwr_irq;
+	int health = POWER_SUPPLY_HEALTH_UNKNOWN;
+
+	ret = pmic_chrg_reg_readb(info, DC_PS_STAT_REG);
+	if ((ret < 0) || !(ret & PS_STAT_VBUS_PRESENT))
+		goto health_read_fail;
+	else
+		pwr_stat = ret;
+
+	ret = pmic_chrg_reg_readb(info, DC_CHRG_STAT_REG);
+	if (ret < 0)
+		goto health_read_fail;
+	else
+		chrg_stat = ret;
+
+	ret = pmic_chrg_reg_readb(info, DC_PWRSRC_IRQ_STAT_REG);
+	if (ret < 0)
+		goto health_read_fail;
+	else
+		pwr_irq = ret;
+
+	if (!(pwr_stat & PS_STAT_VBUS_VALID))
+		health = POWER_SUPPLY_HEALTH_DEAD;
+	else if (pwr_irq & PWRSRC_IRQ_CFG_SVBUS_OVP)
+		health = POWER_SUPPLY_HEALTH_OVERVOLTAGE;
+	else if (chrg_stat & CHRG_STAT_PMIC_OTP)
+		health = POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (chrg_stat & CHRG_STAT_BAT_SAFE_MODE)
+		health = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;
+	else
+		health = POWER_SUPPLY_HEALTH_GOOD;
+
+health_read_fail:
+	return health;
+}
+
+static int get_charging_status(struct pmic_chrg_info *info)
+{
+	int stat = POWER_SUPPLY_STATUS_UNKNOWN;
+	int pwr_stat, chrg_stat, bat_irq_stat;
+
+	pwr_stat = pmic_chrg_reg_readb(info, DC_PS_STAT_REG);
+	if (pwr_stat < 0)
+		goto chrg_stat_read_fail;
+
+	chrg_stat = pmic_chrg_reg_readb(info, DC_CHRG_STAT_REG);
+	if (chrg_stat < 0)
+		goto chrg_stat_read_fail;
+
+	bat_irq_stat = pmic_chrg_reg_readb(info, DC_BAT_IRQ_STAT_REG);
+	if (bat_irq_stat < 0)
+		goto chrg_stat_read_fail;
+
+	if (bat_irq_stat & BAT_IRQ_STAT_BAT_DISCON)
+		stat = POWER_SUPPLY_STATUS_UNKNOWN;
+	else if (!(pwr_stat & PS_STAT_VBUS_PRESENT))
+		stat = POWER_SUPPLY_STATUS_DISCHARGING;
+	else if (bat_irq_stat & CHRG_STAT_CHARGING)
+		stat = POWER_SUPPLY_STATUS_CHARGING;
+	else if (bat_irq_stat & BAT_IRQ_STAT_CHRG_DONE)
+		stat = POWER_SUPPLY_STATUS_FULL;
+	else
+		stat = POWER_SUPPLY_STATUS_NOT_CHARGING;
+
+chrg_stat_read_fail:
+	return stat;
+}
+
+static int pmic_chrg_usb_set_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    const union power_supply_propval *val)
+{
+	struct pmic_chrg_info *info = container_of(psy,
+						    struct pmic_chrg_info,
+						    psy_usb);
+	int ret = 0;
+
+	mutex_lock(&info->lock);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		info->present = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		info->online = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
+		/*
+		 * X-Power Inlimit is getting set to default(500mA)
+		 * whenever we hit the Charger UVP condition and the
+		 * setting remains same even after UVP recovery.
+		 * As a WA to make sure the SW programmed INLMT intact
+		 * we are reprogramming the inlimit before enabling the charging.
+		 */
+		ret = pmic_chrg_set_inlmt(info, info->inlmt);
+		if (ret < 0)
+			dev_warn(&info->pdev->dev, "set inlimit failed\n");
+
+		ret = pmic_chrg_enable_charging(info, val->intval);
+		if (ret < 0)
+			dev_warn(&info->pdev->dev, "enable charging failed\n");
+		info->is_charging_enabled = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
+		/*
+		 * Disabling the VSYS or Charger is not
+		 * allowing the PMIC to detect the subsequent
+		 * USB plug events. For better to keep the
+		 * default VBUS ON bit always to have better
+		 * user experience. So commenting teh actual
+		 * enable_charger() and for charger enable/disable
+		 * we need to use teh same enable_charginig() to
+		 * align with charegr framework.
+		 *
+		 * ret = pmic_chrg_enable_charger(info, val->intval);
+		 */
+		ret = pmic_chrg_enable_charging(info, val->intval);
+		if (ret < 0)
+			dev_warn(&info->pdev->dev, "enable charger failed\n");
+		 info->is_charger_enabled = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+		ret = pmic_chrg_set_cc(info, val->intval);
+		if (ret < 0)
+			dev_warn(&info->pdev->dev, "set inlimit failed\n");
+		info->cc = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_INLMT:
+		ret = pmic_chrg_set_inlmt(info, val->intval);
+		if (ret < 0)
+			dev_warn(&info->pdev->dev, "set inlimit failed\n");
+		info->inlmt = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+		ret = pmic_chrg_set_cv(info, val->intval);
+		if (ret < 0)
+			dev_warn(&info->pdev->dev, "set inlimit failed\n");
+		info->cv = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+		info->max_cc = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+		info->max_cv = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
+		info->iterm = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CABLE_TYPE:
+		info->cable_type = val->intval;
+		info->psy_usb.type = get_power_supply_type(info->cable_type);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		info->cntl_state = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MAX_TEMP:
+		info->max_temp = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_MIN_TEMP:
+		info->min_temp = val->intval;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&info->lock);
+	return ret;
+}
+
+static int pmic_chrg_usb_get_property(struct power_supply *psy,
+				    enum power_supply_property psp,
+				    union power_supply_propval *val)
+{
+	struct pmic_chrg_info *info = container_of(psy,
+				struct pmic_chrg_info, psy_usb);
+	int ret = 0;
+
+	mutex_lock(&info->lock);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT:
+		/* check for OTG case first */
+		if (info->id_short) {
+			val->intval = 0;
+			break;
+		}
+		ret = pmic_chrg_is_present(info);
+		if (ret < 0)
+			goto psy_get_prop_fail;
+		val->intval = ret;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		/* check for OTG case first */
+		if (info->id_short) {
+			val->intval = 0;
+			break;
+		}
+		val->intval = info->online;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = get_charger_health(info);
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT:
+		val->intval = info->max_cc;
+		break;
+	case POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE:
+		val->intval = info->max_cv;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CURRENT:
+		val->intval = info->cc;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_VOLTAGE:
+		val->intval = info->cv;
+		break;
+	case POWER_SUPPLY_PROP_INLMT:
+		val->intval = info->inlmt;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TERM_CUR:
+		val->intval = info->iterm;
+		break;
+	case POWER_SUPPLY_PROP_CABLE_TYPE:
+		val->intval = info->cable_type;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGING:
+		val->intval = info->is_charging_enabled;
+		break;
+	case POWER_SUPPLY_PROP_ENABLE_CHARGER:
+		val->intval = info->is_charger_enabled;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:
+		val->intval = info->cntl_state;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:
+		val->intval = info->pdata->num_throttle_states;
+		break;
+	case POWER_SUPPLY_PROP_MAX_TEMP:
+		val->intval = info->max_temp;
+		break;
+	case POWER_SUPPLY_PROP_MIN_TEMP:
+		val->intval = info->min_temp;
+		break;
+	default:
+		mutex_unlock(&info->lock);
+		return -EINVAL;
+	}
+
+psy_get_prop_fail:
+	mutex_unlock(&info->lock);
+	return ret;
+}
+
+static irqreturn_t pmic_chrg_thread_handler(int irq, void *dev)
+{
+	struct pmic_chrg_info *info = dev;
+	int i;
+
+	for (i = 0; i < DC_CHRG_INTR_NUM; i++) {
+		if (info->irq[i] == irq)
+			break;
+	}
+
+	if (i >= DC_CHRG_INTR_NUM) {
+		dev_warn(&info->pdev->dev, "spurious interrupt!!\n");
+		return IRQ_NONE;
+	}
+
+	switch (i) {
+	case VBUS_OV_IRQ:
+		dev_info(&info->pdev->dev, "VBUS Over Voltage INTR\n");
+		break;
+	case CHARGE_DONE_IRQ:
+		dev_info(&info->pdev->dev, "Charging Done INTR\n");
+		break;
+	case CHARGE_CHARGING_IRQ:
+		dev_info(&info->pdev->dev, "Start Charging IRQ\n");
+		break;
+	case QCBTU_IRQ:
+		dev_info(&info->pdev->dev,
+			"Quit Battery Under Temperature(CHRG) INTR\n");
+		break;
+	case BAT_SAFE_QUIT_IRQ:
+		dev_info(&info->pdev->dev,
+			"Quit Safe Mode(restart timer) Charging IRQ\n");
+		break;
+	case BAT_SAFE_ENTER_IRQ:
+		dev_info(&info->pdev->dev,
+			"Enter Safe Mode(timer expire) Charging IRQ\n");
+		break;
+	case CBTU_IRQ:
+		dev_info(&info->pdev->dev,
+			"Hit Battery Under Temperature(CHRG) INTR\n");
+		break;
+	case QCBTO_IRQ:
+		dev_info(&info->pdev->dev,
+			"Quit Battery Over Temperature(CHRG) INTR\n");
+		break;
+	case CBTO_IRQ:
+		dev_info(&info->pdev->dev,
+			"Hit Battery Over Temperature(CHRG) INTR\n");
+		break;
+	default:
+		dev_warn(&info->pdev->dev, "Spurious Interrupt!!!\n");
+	}
+
+	power_supply_changed(&info->psy_usb);
+	return IRQ_HANDLED;
+}
+
+static void dc_xpwr_otg_event_worker(struct work_struct *work)
+{
+	struct pmic_chrg_info *info =
+	    container_of(work, struct pmic_chrg_info, otg_work);
+	int ret;
+
+	/* disable VBUS path before enabling the 5V boost */
+	ret = pmic_chrg_enable_charger(info, !info->id_short);
+	if (ret < 0)
+		dev_warn(&info->pdev->dev, "vbus path disable failed\n");
+
+	if (info->pdata->otg_gpio >= 0)
+		gpio_direction_output(info->pdata->otg_gpio, info->id_short);
+}
+
+static int dc_xpwr_handle_otg_event(struct notifier_block *nb,
+				   unsigned long event, void *param)
+{
+	struct pmic_chrg_info *info =
+	    container_of(nb, struct pmic_chrg_info, id_nb);
+	struct extcon_dev *edev = param;
+	int usb_host = !!edev->state;
+
+	dev_info(&info->pdev->dev,
+		"[extcon notification] evt:USB-Host val:%s\n",
+		usb_host ? "Connected" : "Disconnected");
+
+	/*
+	 * in case of id short(usb_host = 1)
+	 * enable vbus else disable vbus.
+	 */
+	info->id_short = usb_host;
+	schedule_work(&info->otg_work);
+
+	return NOTIFY_OK;
+}
+
+static void pmic_chrg_init_hw_regs(struct pmic_chrg_info *info)
+{
+	/* program temperature thresholds */
+	intel_soc_pmic_writeb(DC_CHRG_VLTFC_REG, CHRG_VLTFC_N5C);
+	intel_soc_pmic_writeb(DC_CHRG_VHTFC_REG, CHRG_VHTFC_60C);
+
+	/* do not turn-off charger o/p after charge cycle ends */
+	intel_soc_pmic_setb(DC_CHRG_CNTL2_REG, CNTL2_CHG_OUT_TURNON);
+
+	/* enable interrupts */
+	intel_soc_pmic_setb(DC_BAT_IRQ_CFG_REG, BAT_IRQ_CFG_BAT_MASK);
+	intel_soc_pmic_setb(DC_TEMP_IRQ_CFG_REG, TEMP_IRQ_CFG_MASK);
+}
+
+static void pmic_chrg_init_psy_props(struct pmic_chrg_info *info)
+{
+	info->max_cc = info->pdata->max_cc;
+	info->max_cv = info->pdata->max_cv;
+}
+
+static void pmic_chrg_init_irq(struct pmic_chrg_info *info)
+{
+	int ret, i;
+
+	for (i = 0; i < DC_CHRG_INTR_NUM; i++) {
+		info->irq[i] = platform_get_irq(info->pdev, i);
+		ret = request_threaded_irq(info->irq[i],
+				NULL, pmic_chrg_thread_handler,
+				IRQF_ONESHOT, DEV_NAME, info);
+		if (ret) {
+			dev_warn(&info->pdev->dev,
+				"cannot get IRQ:%d\n", info->irq[i]);
+			info->irq[i] = -1;
+			goto intr_failed;
+		} else {
+			dev_info(&info->pdev->dev, "IRQ No:%d\n", info->irq[i]);
+		}
+	}
+
+	return;
+
+intr_failed:
+	for (; i > 0; i--) {
+		free_irq(info->irq[i - 1], info);
+		info->irq[i - 1] = -1;
+	}
+}
+
+static int pmic_chrg_probe(struct platform_device *pdev)
+{
+	struct pmic_chrg_info *info;
+	int ret;
+
+	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		dev_err(&pdev->dev, "mem alloc failed\n");
+		return -ENOMEM;
+	}
+
+	info->pdev = pdev;
+	info->pdata = pdev->dev.platform_data;
+	if (!info->pdata)
+		return -ENODEV;
+
+	platform_set_drvdata(pdev, info);
+	mutex_init(&info->lock);
+	INIT_WORK(&info->otg_work, dc_xpwr_otg_event_worker);
+
+	pmic_chrg_init_psy_props(info);
+	pmic_chrg_init_irq(info);
+	pmic_chrg_init_hw_regs(info);
+
+	/* Register for OTG notification */
+	info->id_nb.notifier_call = dc_xpwr_handle_otg_event;
+	ret = extcon_register_interest(&info->cable_obj, NULL, "USB-Host",
+				       &info->id_nb);
+	if (ret)
+		dev_err(&pdev->dev, "failed to register extcon notifier\n");
+
+	info->psy_usb.name = DEV_NAME;
+	info->psy_usb.type = POWER_SUPPLY_TYPE_USB;
+	info->psy_usb.properties = pmic_chrg_usb_props;
+	info->psy_usb.num_properties = ARRAY_SIZE(pmic_chrg_usb_props);
+	info->psy_usb.get_property = pmic_chrg_usb_get_property;
+	info->psy_usb.set_property = pmic_chrg_usb_set_property;
+	info->psy_usb.supplied_to = info->pdata->supplied_to;
+	info->psy_usb.num_supplicants = info->pdata->num_supplicants;
+	info->psy_usb.throttle_states = info->pdata->throttle_states;
+	info->psy_usb.num_throttle_states = info->pdata->num_throttle_states;
+	info->psy_usb.supported_cables = info->pdata->supported_cables;
+	ret = power_supply_register(&pdev->dev, &info->psy_usb);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed: power supply register (%d)\n",
+			ret);
+		goto psy_reg_failed;
+	}
+
+	return 0;
+
+psy_reg_failed:
+	return ret;
+}
+
+static int pmic_chrg_remove(struct platform_device *pdev)
+{
+	struct pmic_chrg_info *info =  dev_get_drvdata(&pdev->dev);
+	int i;
+
+	for (i = 0; i < DC_CHRG_INTR_NUM && info->irq[i] != -1; i++)
+		free_irq(info->irq[i], info);
+	extcon_unregister_interest(&info->cable_obj);
+	power_supply_unregister(&info->psy_usb);
+	return 0;
+}
+
+static int pmic_chrg_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int pmic_chrg_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int pmic_chrg_runtime_suspend(struct device *dev)
+{
+
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int pmic_chrg_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static int pmic_chrg_runtime_idle(struct device *dev)
+{
+
+	dev_dbg(dev, "%s called\n", __func__);
+	return 0;
+}
+
+static const struct dev_pm_ops pmic_chrg_pm_ops = {
+		SET_SYSTEM_SLEEP_PM_OPS(pmic_chrg_suspend,
+				pmic_chrg_resume)
+		SET_RUNTIME_PM_OPS(pmic_chrg_runtime_suspend,
+				pmic_chrg_runtime_resume,
+				pmic_chrg_runtime_idle)
+};
+
+static struct platform_driver pmic_chrg_driver = {
+	.driver = {
+		.name = DEV_NAME,
+		.owner	= THIS_MODULE,
+		.pm = &pmic_chrg_pm_ops,
+	},
+	.probe = pmic_chrg_probe,
+	.remove = pmic_chrg_remove,
+};
+
+static int __init dc_pmic_chrg_init(void)
+{
+	return platform_driver_register(&pmic_chrg_driver);
+
+}
+device_initcall(dc_pmic_chrg_init);
+
+static void __exit dc_pmic_chrg_exit(void)
+{
+	platform_driver_unregister(&pmic_chrg_driver);
+}
+module_exit(dc_pmic_chrg_exit);
+
+MODULE_AUTHOR("Ramakrishna Pallala <ramakrishna.pallala@intel.com>");
+MODULE_DESCRIPTION("Dollar Cove Xpower PMIC Charger Driver");
+MODULE_LICENSE("GPL");
--- linux.orig/drivers/regulator/pmic_crystal_cove.c
+++ linux/drivers/regulator/pmic_crystal_cove.c
@@ -24,7 +24,7 @@
 #include <linux/regulator/intel_crystal_cove_pmic.h>
 #include <linux/regulator/machine.h>
 
-#include <linux/mfd/intel_mid_pmic.h>
+#include <linux/mfd/intel_soc_pmic.h>
 
 /* Intel Voltage cntrl register parameters*/
 #define REG_ENA_STATUS_MASK	0x01
@@ -76,10 +76,10 @@ static int intel_pmic_reg_is_enabled(str
 	struct intel_pmic_info *pmic_info = rdev_get_drvdata(rdev);
 	int reg_value;
 
-	reg_value = intel_mid_pmic_readb(pmic_info->pmic_reg);
+	reg_value = intel_soc_pmic_readb(pmic_info->pmic_reg);
 	if (reg_value < 0) {
 		dev_err(&rdev->dev,
-			"intel_mid_pmic_readb returns error %08x\n", reg_value);
+			"intel_soc_pmic_readb returns error %08x\n", reg_value);
 		return reg_value;
 	}
 
@@ -99,14 +99,14 @@ static int intel_pmic_reg_enable(struct
 	struct intel_pmic_info *pmic_info = rdev_get_drvdata(rdev);
 	int reg_value;
 
-	reg_value = intel_mid_pmic_readb(pmic_info->pmic_reg);
+	reg_value = intel_soc_pmic_readb(pmic_info->pmic_reg);
 	if (reg_value < 0) {
 		dev_err(&rdev->dev,
-			"intel_mid_pmic_readb returns error %08x\n", reg_value);
+			"intel_soc_pmic_readb returns error %08x\n", reg_value);
 		return reg_value;
 	}
 
-	return intel_mid_pmic_writeb(pmic_info->pmic_reg,
+	return intel_soc_pmic_writeb(pmic_info->pmic_reg,
 				(reg_value | REG_ON | REG_CNT_ENBL));
 }
 /**
@@ -120,14 +120,14 @@ static int intel_pmic_reg_disable(struct
 	struct intel_pmic_info *pmic_info = rdev_get_drvdata(rdev);
 	int reg_value;
 
-	reg_value = intel_mid_pmic_readb(pmic_info->pmic_reg);
+	reg_value = intel_soc_pmic_readb(pmic_info->pmic_reg);
 	if (reg_value < 0) {
 		dev_err(&rdev->dev,
-			"intel_mid_pmic_readb returns error %08x\n", reg_value);
+			"intel_soc_pmic_readb returns error %08x\n", reg_value);
 		return reg_value;
 	}
 
-	return intel_mid_pmic_writeb(pmic_info->pmic_reg,
+	return intel_soc_pmic_writeb(pmic_info->pmic_reg,
 				((reg_value | REG_CNT_ENBL) & REG_OFF));
 }
 /**
@@ -159,10 +159,10 @@ static int intel_pmic_reg_getvoltage(str
 	u8  vsel;
 	int reg_value;
 
-	reg_value = intel_mid_pmic_readb(pmic_info->pmic_reg);
+	reg_value = intel_soc_pmic_readb(pmic_info->pmic_reg);
 	if (reg_value < 0) {
 		dev_err(&rdev->dev,
-			"intel_mid_pmic_readb returns error %08x\n", reg_value);
+			"intel_soc_pmic_readb returns error %08x\n", reg_value);
 		return reg_value;
 	}
 	vsel = (reg_value & REG_VSEL_MASK) >> VSEL_SHIFT;
@@ -199,17 +199,17 @@ static int intel_pmic_reg_setvoltage(str
 			continue;
 
 		*selector = vsel;
-		reg_value = intel_mid_pmic_readb(pmic_info->pmic_reg);
+		reg_value = intel_soc_pmic_readb(pmic_info->pmic_reg);
 		if (reg_value < 0) {
 			dev_err(&rdev->dev,
-			"intel_mid_pmic_readb returns error %08x\n", reg_value);
+			"intel_soc_pmic_readb returns error %08x\n", reg_value);
 			return reg_value;
 		}
 		reg_value &= ~REG_VSEL_MASK;
 		reg_value |= vsel << VSEL_SHIFT;
 		dev_dbg(&rdev->dev,
 			"intel_pmic_reg_setvoltage voltage: %u uV\n", uV);
-		return intel_mid_pmic_writeb(pmic_info->pmic_reg, reg_value);
+		return intel_soc_pmic_writeb(pmic_info->pmic_reg, reg_value);
 	}
 	return -EINVAL;
 }
--- linux.orig/include/linux/mfd/intel_soc_pmic.h
+++ linux/include/linux/mfd/intel_soc_pmic.h
@@ -19,6 +19,8 @@
 #define __INTEL_SOC_PMIC_H__
 
 #define	INTEL_PMIC_IRQBASE	456
+#define INTEL_NGPIO_SCORE	102
+#define INTEL_NGPIO_NCORE	28
 
 int intel_soc_pmic_readb(int reg);
 int intel_soc_pmic_writeb(int reg, u8 val);
--- /dev/null
+++ linux/include/linux/power/battery_id.h
@@ -0,0 +1,79 @@
+#ifndef __BATTERY_ID_H__
+
+#define __BATTERY_ID_H__
+
+enum {
+	POWER_SUPPLY_BATTERY_REMOVED = 0,
+	POWER_SUPPLY_BATTERY_INSERTED,
+};
+
+enum batt_chrg_prof_type {
+	CHRG_PROF_NONE = 0,
+	PSE_MOD_CHRG_PROF,
+};
+
+/* charging profile structure definition */
+struct ps_batt_chg_prof {
+	enum batt_chrg_prof_type chrg_prof_type;
+	void *batt_prof;
+};
+
+/* PSE Modified Algo Structure */
+/* Parameters defining the charging range */
+struct ps_temp_chg_table {
+	/* upper temperature limit for each zone */
+	short int temp_up_lim;
+	/* charge current and voltage */
+	short int full_chrg_vol;
+	short int full_chrg_cur;
+	/* maintenance thresholds */
+	/* maintenance lower threshold. Once battery hits full, charging
+	*  charging will be resumed when battery voltage <= this voltage
+	*/
+	short int maint_chrg_vol_ll;
+	/* Charge current and voltage in maintenance mode */
+	short int maint_chrg_vol_ul;
+	short int maint_chrg_cur;
+} __packed;
+
+
+#define BATTID_STR_LEN		8
+#define BATT_TEMP_NR_RNG	6
+/* Charging Profile */
+struct ps_pse_mod_prof {
+	/* battery id */
+	char batt_id[BATTID_STR_LEN];
+	/* type of battery */
+	u16 battery_type;
+	u16 capacity;
+	u16 voltage_max;
+	/* charge termination current */
+	u16 chrg_term_ma;
+	/* Low battery level voltage */
+	u16 low_batt_mV;
+	/* upper and lower temperature limits on discharging */
+	s8 disch_tmp_ul;
+	s8 disch_tmp_ll;
+	/* number of temperature monitoring ranges */
+	u16 temp_mon_ranges;
+	struct ps_temp_chg_table temp_mon_range[BATT_TEMP_NR_RNG];
+	/* Lowest temperature supported */
+	short int temp_low_lim;
+} __packed;
+
+/*For notification during battery change event*/
+extern struct atomic_notifier_head    batt_id_notifier;
+
+extern void battery_prop_changed(int battery_conn_stat,
+				struct ps_batt_chg_prof *batt_prop);
+#ifdef CONFIG_POWER_SUPPLY_BATTID
+extern int get_batt_prop(struct ps_batt_chg_prof *batt_prop);
+#else
+static inline int get_batt_prop(struct ps_batt_chg_prof *batt_prop)
+{
+	return -ENOMEM;
+}
+#endif
+extern int batt_id_reg_notifier(struct notifier_block *nb);
+extern void batt_id_unreg_notifier(struct notifier_block *nb);
+#endif
--- /dev/null
+++ linux/include/linux/power/dc_xpwr_battery.h
@@ -0,0 +1,49 @@
+/*
+ * dollar_cove_battery.h: platform data struct for dollar cove battery
+ *
+ * Copyright (C) 2013 Intel Corporation
+ * Ramakrishna Pallala <ramakrishna.pallala@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __DOLLAR_COVE_BATTERY_H__
+#define __DOLLAR_COVE_BATTERY_H__
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/power_supply.h>
+#include <linux/power/battery_id.h>
+
+#define BAT_CURVE_SIZE		32
+#define BATTID_LEN		8
+
+struct dollarcove_fg_pdata {
+	char battid[BATTID_LEN + 1];
+
+	int design_cap;
+	int design_min_volt;
+	int design_max_volt;
+	int max_temp;
+	int min_temp;
+
+	int cap1;
+	int cap0;
+	int rdc1;
+	int rdc0;
+	int bat_curve[BAT_CURVE_SIZE];
+};
+
+#endif	/* __DOLLAR_COVE_BATTERY_H__ */
--- /dev/null
+++ linux/include/linux/power/dc_xpwr_charger.h
@@ -0,0 +1,48 @@
+/*
+ * dollar_cove_charger.h: platform data struct for dollar cove charger
+ *
+ * Copyright (C) 2013 Intel Corporation
+ * Ramakrishna Pallala <ramakrishna.pallala@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __DOLLAR_COVE_CHARGER_H__
+#define __DOLLAR_COVE_CHARGER_H__
+
+#include <linux/types.h>
+#include <linux/power_supply.h>
+#include <linux/power/battery_id.h>
+
+struct dollarcove_chrg_pdata {
+	char **supplied_to;
+	size_t num_supplicants;
+	struct power_supply_throttle *throttle_states;
+	size_t num_throttle_states;
+	unsigned long supported_cables;
+	int otg_gpio;
+	struct ps_batt_chg_prof *chg_profile;
+
+	int max_cc;
+	int max_cv;
+	int def_cc;
+	int def_cv;
+	int def_ilim;
+	int def_iterm;
+	int def_max_temp;
+	int def_min_temp;
+};
+
+#endif	/* __DOLLAR_COVE_CHARGER_H__ */
