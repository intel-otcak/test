From 9beff2edb038c4421962eb7c451559e5bb044ad1 Mon Sep 17 00:00:00 2001
From: Daniel Drubin <idaniel.drubin@intel.com>
Date: Tue, 15 Mar 2016 18:49:25 +0200
Subject: [PATCH 2/4] Added sensor-collection2 API

Added sensor-collection2 API that addresses number of issues with
senscol1
Provides consistent interface in Linux with multiple user-mode clients
(subcollections)
Retires use of kobjects and associated kernel memory
Makes sensors availability time at boot faster and more predictable
Makes delays between sensors enablement and first report shorter

This is transition variant that can expose either API, swithed in
senscol.h and defaulted to sensor-collection1 (legacy).
After user-mode sensor HAL implements usage of new API, senscol1
will be retired

Change-Id: I5e77e9db32bc80ac56c65daa57dde3ddcbaf8f13
Tracked-On: https://jira01.devtools.intel.com/browse/OAM-23377
Signed-off-by: Daniel Drubin <daniel.drubin@intel.com>
Reviewed-on: https://android.intel.com:443/479046
---
 drivers/misc/intel-ish/Kconfig               |    1 -
 drivers/misc/intel-ish/Makefile              |    6 +-
 drivers/misc/intel-ish/ish-hid-dd.c          | 1105 ++++++++--------
 drivers/misc/intel-ish/platform-config.h     |    1 -
 drivers/misc/intel-ish/senscol-core-common.c |  133 ++
 drivers/misc/intel-ish/senscol-core-legacy.c |  836 ++++++++++++
 drivers/misc/intel-ish/senscol-core.c        | 1758 +++++++++++++-------------
 include/linux/senscol/senscol-core.h         |  236 +++-
 8 files changed, 2587 insertions(+), 1489 deletions(-)
 create mode 100644 drivers/misc/intel-ish/senscol-core-common.c
 create mode 100644 drivers/misc/intel-ish/senscol-core-legacy.c

diff --git a/drivers/misc/intel-ish/Kconfig b/drivers/misc/intel-ish/Kconfig
index 30f5038..0585a6a 100644
--- a/drivers/misc/intel-ish/Kconfig
+++ b/drivers/misc/intel-ish/Kconfig
@@ -31,4 +31,3 @@ config ISH_PATH_SENSCOL
 
 	  Disable sensor-collection path if you want to expose a different
 	  interface to user-mode, such as IIO
-
diff --git a/drivers/misc/intel-ish/Makefile b/drivers/misc/intel-ish/Makefile
index b89631a..2184a35 100644
--- a/drivers/misc/intel-ish/Makefile
+++ b/drivers/misc/intel-ish/Makefile
@@ -20,7 +20,7 @@ hid-ishtp-objs += ishtp-hid-client.o
 
 obj-$(CONFIG_INTEL_ISH) += ish-hid-drv.o
 ish-hid-drv-objs := ish-hid-dd.o
-
-obj-$(CONFIG_INTEL_ISH) += sens-col-core.o
-sens-col-core-objs := senscol-core.o
+ish-hid-drv-objs += senscol-core-common.o
+ish-hid-drv-objs += senscol-core-legacy.o
+ish-hid-drv-objs += senscol-core.o
 
diff --git a/drivers/misc/intel-ish/ish-hid-dd.c b/drivers/misc/intel-ish/ish-hid-dd.c
index a1e816c..99beaab 100644
--- a/drivers/misc/intel-ish/ish-hid-dd.c
+++ b/drivers/misc/intel-ish/ish-hid-dd.c
@@ -1,6 +1,6 @@
 /*
  * HID Sensors Driver
- * Copyright (c) 2012, Intel Corporation.
+ * Copyright (c) 2012-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -8,7 +8,7 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  *
  * You should have received a copy of the GNU General Public License along with
@@ -16,7 +16,6 @@
  *
  */
 
-
 #include <linux/device.h>
 #include <linux/hid.h>
 #include <linux/module.h>
@@ -30,57 +29,29 @@
 #define USB_VENDOR_ID_INTEL_0		0x8086
 #define USB_VENDOR_ID_INTEL_1		0x8087
 #define USB_DEVICE_ID_INTEL_HID_SENSOR	0x09fa
-#define USB_VENDOR_ID_STM_0             0x0483
-#define USB_DEVICE_ID_STM_HID_SENSOR    0x91d1
-#define USB_DEVICE_ID_STM_HID_SENSOR_1  0x9100
-
-
-
-/**
- * struct ish_pending - Synchronous read pending information
- * @status:		Pending status true/false.
- * @ready:		Completion synchronization data.
- * @usage_id:		Usage id for physical device, E.g. Gyro usage id.
- * @attr_usage_id:	Usage Id of a field, E.g. X-AXIS for a gyro.
- * @raw_size:		Response size for a read request.
- * @raw_data:		Place holder for received response.
- */
-struct ish_pending {
-	bool status;
-	struct completion ready;
-	u32 usage_id;
-	u32 attr_usage_id;
-	int raw_size;
-	u8  *raw_data;
-};
+#define USB_VENDOR_ID_STM_0		0x0483
+#define USB_DEVICE_ID_STM_HID_SENSOR	0x91d1
+#define USB_DEVICE_ID_STM_HID_SENSOR_1	0x9100
 
 struct hid_sens_hub_device {
 	struct hid_device *hdev;
-	u32 vendor_id;
-	u32 product_id;
+	uint32_t vendor_id;
+	uint32_t product_id;
 };
 
-/**
- * struct ish_data - Hold a instance data for a HID hub device
- * @hsdev:		Stored hid instance for current hub device.
- * @lock:		Spin lock to protect pending request structure.
- * @pending:		Holds information of pending sync read request.
- */
+/* struct ish_data - Holds a instance data for a HID hub device */
 struct ish_data {
 	struct hid_sens_hub_device *hsdev;
 	struct mutex mutex;
-	spinlock_t lock;
-	struct ish_pending pending;
 	int ish_index;	/* Needed to identify sensor in a collection */
 };
 
-#define	MAX_HID_SENSOR_HUBS 32
-static struct hid_device *hid_sens_hubs[MAX_HID_SENSOR_HUBS];
+#define	MAX_HID_SENSOR_HUBS	32
+static struct hid_device	*hid_sens_hubs[MAX_HID_SENSOR_HUBS];
 static int	ish_cur_count;
 static int	ish_max_count;
 
-static struct hid_report *ish_report(int id, struct hid_device *hdev,
-						int dir)
+static struct hid_report *ish_report(int id, struct hid_device *hdev, int dir)
 {
 	struct hid_report *report;
 
@@ -89,12 +60,10 @@ static struct hid_report *ish_report(int id, struct hid_device *hdev,
 			return report;
 	}
 	hid_warn(hdev, "No report with id 0x%x found\n", id);
-
 	return NULL;
 }
 
-static int ish_get_physical_device_count(
-				struct hid_report_enum *report_enum)
+static int ish_get_physical_device_count(struct hid_report_enum *report_enum)
 {
 	struct hid_report *report;
 	struct hid_field *field;
@@ -105,31 +74,43 @@ static int ish_get_physical_device_count(
 		if (report->maxfield && field && field->physical)
 			cnt++;
 	}
-
 	return cnt;
 }
 
-static int ish_set_feature(struct hid_sens_hub_device *hsdev, u32 report_id,
-				u32 field_index, s32 value)
+/* Get sensor hub device by index */
+static struct ish_data	*get_ish_by_index(unsigned idx)
 {
-	struct hid_report *report;
-	struct ish_data *data = hid_get_drvdata(hsdev->hdev);
-	int ret = 0;
+	int	i;
+	struct ish_data	*sd;
 
-	mutex_lock(&data->mutex);
-	report = ish_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);
-	if (!report || (field_index >= report->maxfield)) {
-		ret = -EINVAL;
-		goto done_proc;
+	for (i = 0; i < ish_cur_count; ++i) {
+		if (!hid_sens_hubs[i])
+			continue;
+		sd = hid_get_drvdata(hid_sens_hubs[i]);
+		if (!sd)
+			continue;
+		if (sd->ish_index == idx)
+			return	sd;
 	}
-	hid_set_field(report->field[field_index], 0, value);
-	hid_hw_request(hsdev->hdev, report, HID_REQ_SET_REPORT);
-	hid_hw_wait(hsdev->hdev);
+	return	NULL;
+}
 
-done_proc:
-	mutex_unlock(&data->mutex);
+/* returns field_index with the given hid usage on success, (-1) on failure */
+static int get_field_index(struct hid_device *hdev, unsigned report_id,
+	unsigned usage, int report_type)
+{
+	int i = 0;
+	struct hid_report *report;
 
-	return ret;
+	report = ish_report(report_id, hdev,
+		report_type /* HID_FEATURE_REPORT or HID_INPUT_REPORT */);
+	if (!report)
+		return -1;
+
+	for (i = 0; i < report->maxfield; ++i)
+		if (report->field[i]->usage->hid == usage)
+			return i;
+	return -1;
 }
 
 #ifdef CONFIG_PM
@@ -147,57 +128,30 @@ static int ish_reset_resume(struct hid_device *hdev)
 {
 	return 0;
 }
-#endif /*CONFIG_PM*/
-
-/**************************** SENSCOL block: START ****************************/
-#if 1
-static int	senscol_impl_added;
-static int	is_sens_data_field(unsigned usage);
-static int get_field_index(struct hid_device *hdev, unsigned report_id,
-	unsigned usage, int report_idx);
-
-/* Get sensor's property by name */
-static struct sens_property *get_prop_by_name(struct sensor_def *sensor,
-	char *name)
-{
-	int	i;
-
-	for (i = 0; i < sensor->num_properties; ++i)
-		if (!strcmp(sensor->properties[i].name, name))
-			return	&sensor->properties[i];
-
-	return	NULL;
-}
-
-/* Get sensor's data field by name */
-static struct data_field *get_data_field_by_name(struct sensor_def *sensor,
-	char *name)
-{
-	int	i;
-
-	for (i = 0; i < sensor->num_data_fields; ++i)
-		if (!strcmp(sensor->data_fields[i].name, name))
-			return	&sensor->data_fields[i];
-
-	return	NULL;
-}
+#endif /* CONFIG_PM */
 
-static int get_field_index(struct hid_device *hdev, unsigned report_id,
-	unsigned usage, int report_type)
+#if SENSCOL_1
+static int ish_set_feature(struct hid_sens_hub_device *hsdev, uint32_t report_id,
+				uint32_t field_index, int32_t value)
 {
-	int i = 0;
 	struct hid_report *report;
+	struct ish_data *data = hid_get_drvdata(hsdev->hdev);
+	int ret = 0;
 
-	report = ish_report(report_id, hdev,
-		report_type /*HID_FEATURE_REPORT or HID_INPUT_REPORT*/);
-	if (!report)
-		return -1;
+	mutex_lock(&data->mutex);
+	report = ish_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report || (field_index >= report->maxfield)) {
+		ret = -EINVAL;
+		goto done_proc;
+	}
+	hid_set_field(report->field[field_index], 0, value);
+	hid_hw_request(hsdev->hdev, report, HID_REQ_SET_REPORT);
+	hid_hw_wait(hsdev->hdev);
 
-	for (i = 0; i < report->maxfield; ++i)
-		if (report->field[i]->usage->hid == usage)
-			return i;
+done_proc:
+	mutex_unlock(&data->mutex);
 
-	return -1;
+	return ret;
 }
 
 /*
@@ -207,21 +161,21 @@ static int get_field_index(struct hid_device *hdev, unsigned report_id,
  * If that was fixed, existing callers would immediately buffer-overflow
  * if such feature was delivered
  * NOTES:
- *   - if ret != 0, contents of pvalue and count are undefined.
- *   - upon success, count is in s32 values (not in bytes)
+ * - if ret != 0, contents of pvalue and count are undefined.
+ * - upon success, count is in int32_t values (not in bytes)
  */
 static int ish_get_feature_ex(struct hid_sens_hub_device *hsdev,
-	u32 report_id, u32 field_index, u32 *usage_id, s32 **pvalue,
+	uint32_t report_id, uint32_t field_index, uint32_t *usage_id, int32_t **pvalue,
 	size_t *count, unsigned *is_string)
 {
 	struct hid_report *report;
-	struct ish_data *data =  hid_get_drvdata(hsdev->hdev);
+	struct ish_data *data = hid_get_drvdata(hsdev->hdev);
 	int ret = 0;
 
 	mutex_lock(&data->mutex);
 	report = ish_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);
-	if (!report || (field_index >=  report->maxfield) ||
-	    report->field[field_index]->report_count < 1) {
+	if (!report || (field_index >= report->maxfield) ||
+			report->field[field_index]->report_count < 1) {
 		ret = -EINVAL;
 		goto done_proc;
 	}
@@ -238,38 +192,19 @@ done_proc:
 	return ret;
 }
 
-/* Get sensor hub device by index */
-static struct ish_data	*get_ish_by_index(unsigned idx)
-{
-	int	i;
-	struct ish_data	*sd;
-
-	for (i = 0; i < ish_cur_count; ++i) {
-		if (!hid_sens_hubs[i])
-			continue;
-		sd = hid_get_drvdata(hid_sens_hubs[i]);
-		if (!sd)
-			continue;
-		if (sd->ish_index == idx)
-			return	sd;
-	}
-
-	return	NULL;
-}
-
-static int     hid_get_sens_property(struct sensor_def *sensor,
+static int	hid_get_sens_property(struct sensor_def *sensor,
 	const struct sens_property *prop, char *value, size_t val_buf_size)
 {
 	unsigned	idx;
 	struct ish_data	*sd;
-	char	buf[1024];		/* Enough for single property (?) */
+	char	buf[1024];		/* Enough for single property */
 	unsigned	report_id;
 	int	field;
 	uint32_t	usage_id;
 	int32_t	*pval;
 	size_t	count;
-	unsigned is_string;
-	int	rv;
+	unsigned	is_string;
+	int	rv = 0;
 
 	if (!sensor || !prop)
 		return	-EINVAL;	/* input is invalid */
@@ -278,7 +213,7 @@ static int     hid_get_sens_property(struct sensor_def *sensor,
 	idx = sensor->id >> 16 & 0xFFFF;
 	sd = get_ish_by_index(idx);
 	if (!sd)
-		return	-EINVAL;	/* sensor->id is bad */
+		return	-EINVAL;	/* sensor->id is erroneous */
 
 	/* Report ID */
 	report_id = sensor->id & 0xFFFF;
@@ -295,7 +230,7 @@ static int     hid_get_sens_property(struct sensor_def *sensor,
 	if (rv)
 		return	rv;
 
-	if  (is_string) {
+	if (is_string) {
 		int	i;
 
 		for (i = 0; i < count; ++i)
@@ -312,7 +247,7 @@ static int     hid_get_sens_property(struct sensor_def *sensor,
 	return	0;
 }
 
-static int     hid_set_sens_property(struct sensor_def *sensor,
+static int	hid_set_sens_property(struct sensor_def *sensor,
 	const struct sens_property *prop, const char *value)
 {
 	unsigned	idx;
@@ -334,7 +269,7 @@ static int     hid_set_sens_property(struct sensor_def *sensor,
 	idx = sensor->id >> 16 & 0xFFFF;
 	sd = get_ish_by_index(idx);
 	if (!sd)
-		return	-EINVAL;	/* sensor->id is bad */
+		return	-EINVAL;	/* sensor->id is erroneous */
 
 	/* Report ID */
 	report_id = sensor->id & 0xFFFF;
@@ -349,8 +284,150 @@ static int     hid_set_sens_property(struct sensor_def *sensor,
 	rv = ish_set_feature(sd->hsdev, report_id, field, val);
 	return	rv;
 }
+#endif
+
+static struct hid_report *ish_get_feature(struct hid_sens_hub_device *hsdev,
+	uint32_t report_id)
+{
+	struct ish_data *data = hid_get_drvdata(hsdev->hdev);
+	struct hid_report *report;
+
+	mutex_lock(&data->mutex);
+	 report = ish_report(report_id, hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report)
+		goto done_proc;
+
+	hid_hw_request(hsdev->hdev, report, HID_REQ_GET_REPORT);
+	hid_hw_wait(hsdev->hdev);
+
+done_proc:
+	mutex_unlock(&data->mutex);
+
+	return report;
+}
 
-static int     hid_get_sample(struct sensor_def *sensor)
+static int update_sensor_properties(struct sensor_def *sensor,
+		struct hid_report *freport)
+{
+	uint32_t	usage_id;
+	uint32_t	*pval;
+	char	prop_val[MAX_PROP_VAL_LEN];
+	int	i, j, is_string = 0;
+
+	if (!freport)
+		return -EINVAL;
+
+	for (i = 0; i < freport->maxfield; ++i) {
+		usage_id = freport->field[i]->usage->hid;
+
+		is_string = (freport->field[i]->report_count > 1 &&
+			freport->field[i]->report_size == 16);
+		pval = freport->field[i]->value;
+		memset(prop_val, 0, MAX_PROP_VAL_LEN);
+		if (is_string) {
+			for (j = 0; j < freport->field[i]->report_count; ++j)
+				prop_val[j] = (char)pval[j];
+			prop_val[j] = '\0';
+		} else {
+			sprintf(prop_val, "%d", *pval);/* null terminated */
+		}
+
+		for (j = 0; j < sensor->num_properties; ++j)
+			if (sensor->properties[j].usage_id == usage_id) {
+				kfree(sensor->properties[j].value);
+				sensor->properties[j].value =
+					kasprintf(GFP_KERNEL, "%s", prop_val);
+				break;
+			}
+	}
+	return 0;
+}
+
+static int hid_get_sens_properties(struct sensor_def *sensor)
+{
+	struct ish_data *sd;
+	struct hid_report *freport;
+	unsigned	idx;
+	unsigned	report_id;
+	int	rv;
+
+	if (!sensor)
+		return -EINVAL;	/* input is invalid */
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_ish_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is erroneous */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+	freport = ish_get_feature(sd->hsdev, report_id);
+	if (!freport)
+		return -EINVAL;
+	rv = update_sensor_properties(sensor, freport);
+	return	rv;
+}
+
+static int hid_set_sens_properties(struct list_head *set_prop_list,
+		uint32_t sensor_id)
+{
+	unsigned	idx;
+	struct ish_data	*sd;
+	unsigned	report_id;
+	int32_t val;
+	int	field, rv = 0;
+	struct hid_report *report;
+	struct ish_data *data;
+	struct sens_property *prop, *next;
+
+	/* sensor hub device */
+	idx = sensor_id >> 16 & 0xFFFF;
+	sd = get_ish_by_index(idx);
+	if (!sd)
+		return -EINVAL;	/* sensor->id is erroneous */
+	/* Report ID */
+	report_id = sensor_id & 0xFFFF;
+
+	data = hid_get_drvdata(sd->hsdev->hdev);
+	mutex_lock(&data->mutex);
+	report = ish_report(report_id, sd->hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report) {
+		rv = -EINVAL;
+		goto done_proc;
+	}
+
+	/* set all fields values */
+	list_for_each_entry_safe(prop, next, set_prop_list, link) {
+		field = get_field_index(sd->hsdev->hdev,
+			report_id, prop->usage_id, HID_FEATURE_REPORT);
+		if (field == -1 || field >= report->maxfield) {
+			rv = -EINVAL;
+			goto done_proc;
+		}
+		/* all values are numeric */
+		rv = sscanf(prop->value, " %d ", &val);
+		if (rv != 1) {
+			rv = -EINVAL;
+			goto done_proc;
+		}
+		hid_set_field(report->field[field], 0, val);
+	}
+
+	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_SET_REPORT);
+	hid_hw_wait(sd->hsdev->hdev);
+
+	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_GET_REPORT);
+	hid_hw_wait(sd->hsdev->hdev);
+
+	rv = 0;
+done_proc:
+	mutex_unlock(&data->mutex);
+
+	return rv;
+}
+
+static int	hid_get_sample(struct sensor_def *sensor)
 {
 	unsigned	idx;
 	struct ish_data	*sd;
@@ -365,22 +442,23 @@ static int     hid_get_sample(struct sensor_def *sensor)
 	idx = sensor->id >> 16 & 0xFFFF;
 	sd = get_ish_by_index(idx);
 	if (!sd)
-		return	-EINVAL;	/* sensor->id is bad */
+		return	-EINVAL;	/* sensor->id is erroneous */
 
 	/* Report ID */
 	report_id = sensor->id & 0xFFFF;
 
 	mutex_lock(&sd->mutex);
-	report = ish_report(report_id, sd->hsdev->hdev,
-		HID_INPUT_REPORT);
+	report = ish_report(report_id, sd->hsdev->hdev,	HID_INPUT_REPORT);
 	if (!report) {
 		ret = -EINVAL;
 		goto done_proc;
 	}
 	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_GET_REPORT);
 
-	/*The sample will arrive to "raw event" func,
-	and will be pushed to user via "push_sample" method*/
+	/*
+	 * The sample will arrive to "raw event" func,
+	 * and will be pushed to user via "push_sample" method
+	 */
 
 done_proc:
 	mutex_unlock(&sd->mutex);
@@ -388,210 +466,197 @@ done_proc:
 	return	ret;
 }
 
-/* Check sensor is activated and in batch mode                  *
- * property_power_state =       2       hid_usage 0x200319      *
- * property_reporting_state =   2/5     hid_usage 0x200316      *
- * property_report_interval !=  0       hid_usage 0x20030e      *
- * property_report_interval_resolution != 0 hid_usage 0x20530e  *
- * return value:        0 - sensor is not activated in batch    *
- *                      1 - sensor is activated in batch        */
-static int      hid_batch_check(struct sensor_def *sensor)
+/*
+ * Disable the given sensor.
+ * set:
+ * property_power_state =	3
+ * property_reporting_state =	1
+ * property_report_interval_resolution = 0
+ */
+static int	hid_disable_sensor(struct sensor_def *sensor)
 {
 	unsigned idx;
-	struct ish_data  *sd;
+	struct ish_data *sd;
 	unsigned report_id;
 	struct hid_report *report;
-	int field_idx;
+	int field_idx, rv = 0;
+	struct ish_data *data;
 
 	idx = sensor->id >> 16 & 0xFFFF;
 	sd = get_ish_by_index(idx);
 	if (!sd)
 		return -EINVAL;
 	report_id = sensor->id & 0xFFFF;
-	report = ish_report(report_id, sd->hsdev->hdev,
-		HID_FEATURE_REPORT);
-	if (!report)
-		return -EINVAL;
+	data = hid_get_drvdata(sd->hsdev->hdev);
+	mutex_lock(&data->mutex);
+	report = ish_report(report_id, sd->hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report) {
+		rv = -EINVAL;
+		goto done_proc;
+	}
 
 	/* property_power_state */
-	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x200319,
-		HID_FEATURE_REPORT);
-	if (field_idx < 0)
-		return -EINVAL;
-	if (report->field[field_idx]->value[0] != 2)
-		return 0;
+	field_idx = get_field_index(sd->hsdev->hdev, report_id,
+		HID_USAGE_SENSOR_PROP_POWER_STATE, HID_FEATURE_REPORT);
+	if (field_idx < 0) {
+		rv = -EINVAL;
+		goto done_proc;
+	}
+	hid_set_field(report->field[field_idx], 0, 3);
 
 	/* property_reporting_state */
-	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x200316,
-		HID_FEATURE_REPORT);
-	if (field_idx < 0)
-		return -EINVAL;
-	if (report->field[field_idx]->value[0] != 2 &&
-		report->field[field_idx]->value[0] != 5)
-		return 0;
-
-	/* property_report_interval */
-	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x20030e,
-		HID_FEATURE_REPORT);
-	if (field_idx < 0)
-		return -EINVAL;
-	if (report->field[field_idx]->value[0] == 0)
-		return 0;
+	field_idx = get_field_index(sd->hsdev->hdev, report_id,
+		HID_USAGE_SENSOR_PROP_REPORT_STATE, HID_FEATURE_REPORT);
+	if (field_idx < 0) {
+		rv = -EINVAL;
+		goto done_proc;
+	}
+	hid_set_field(report->field[field_idx], 0, 1);
 
 	/* property_report_interval_resolution */
-	field_idx = get_field_index(sd->hsdev->hdev, report_id, 0x20530e,
-		HID_FEATURE_REPORT);
-	if (field_idx < 0)
-		return -EINVAL;
-	if (report->field[field_idx]->value[0] == 0)
-		return 0;
+	field_idx = get_field_index(sd->hsdev->hdev, report_id,
+		(HID_USAGE_SENSOR_PROP_REPORT_INTERVAL |
+		HID_USAGE_SENSOR_MODIFIER_RESOLUTION), HID_FEATURE_REPORT);
+	if (field_idx < 0) {
+		rv = -EINVAL;
+		goto done_proc;
+	}
+	hid_set_field(report->field[field_idx], 0, 0);
 
-	return 1;
+	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_SET_REPORT);
+	hid_hw_wait(sd->hsdev->hdev);
+
+	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_GET_REPORT);
+	hid_hw_wait(sd->hsdev->hdev);
+
+	rv = 0;
+done_proc:
+	mutex_unlock(&data->mutex);
+	return rv;
+}
+
+/* ask for "get properties" but do not wait for FW response */
+static int hid_ask_flush(struct sensor_def *sensor)
+{
+	struct ish_data *sd;
+	struct hid_report *report;
+	unsigned	idx;
+	unsigned	report_id;
+	int	ret = 0;
+
+	if (!sensor)
+		return -EINVAL;	/* input is invalid */
+
+	/* sensor hub device */
+	idx = sensor->id >> 16 & 0xFFFF;
+	sd = get_ish_by_index(idx);
+	if (!sd)
+		return	-EINVAL;	/* sensor->id is erroneous */
+
+	/* Report ID */
+	report_id = sensor->id & 0xFFFF;
+
+	mutex_lock(&sd->mutex);
+	report = ish_report(report_id, sd->hsdev->hdev, HID_FEATURE_REPORT);
+	if (!report) {
+		ret = -EINVAL;
+		goto done_proc;
+	}
+
+	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_GET_REPORT);
+
+done_proc:
+	mutex_unlock(&sd->mutex);
+	return ret;
 }
 
 struct senscol_impl	hid_senscol_impl = {
+	.get_sample = hid_get_sample,
+#if SENSCOL_1
 	.get_sens_property = hid_get_sens_property,
 	.set_sens_property = hid_set_sens_property,
-	.get_sample = hid_get_sample,
-	.batch_check = hid_batch_check
+#endif
+	.get_sens_properties = hid_get_sens_properties,
+	.set_sens_properties = hid_set_sens_properties,
+	.disable_sensor = hid_disable_sensor,
+	.ask_flush = hid_ask_flush
 };
 
 static int	is_sens_data_field(unsigned usage)
 {
-	if (usage >= 0x400 && usage <= 0x49F ||
-			usage >= 0x4B0 && usage <= 0x4DF ||
-			usage >= 0x4F0 && usage <= 0x4F7 ||
-			usage >= 0x500 && usage <= 0x52F ||
-			usage >= 0x540 && usage <= 0x57F ||
-			usage >= 590 && usage <= 0x7FF)
+	if ((usage >= 0x400 && usage <= 0x49F) ||
+			(usage >= 0x4B0 && usage <= 0x4DF) ||
+			(usage >= 0x4F0 && usage <= 0x4F7) ||
+			(usage >= 0x500 && usage <= 0x52F) ||
+			(usage >= 0x540 && usage <= 0x57F) ||
+			(usage >= 590 && usage <= 0x7FF))
 		return	1;
 	return	0;
 }
 
-static int	fill_data_field(struct hid_field *field, unsigned usage,
-	struct sensor_def *senscol_sensor)
-{
-	struct data_field	data_field;
-	char	*usage_name;
-	int	rv;
-
-	memset(&data_field, 0, sizeof(struct data_field));
-	usage_name = senscol_usage_to_name(usage & 0xFFFF);
-	if (usage_name)
-		data_field.name = kasprintf(GFP_KERNEL, "%s", usage_name);
-	else
-		data_field.name = kasprintf(GFP_KERNEL, "data-%X", usage);
-	if (!data_field.name)
-		return	-ENOMEM;
-
-	data_field.usage_id = usage;
-	data_field.is_numeric = (field->flags & HID_MAIN_ITEM_VARIABLE);
-	if (data_field.is_numeric) {
-		if (field->unit_exponent > 7 ||
-				field->unit_exponent < -8)
-			data_field.exp = 0xFF;
-		else if (field->unit_exponent >= 0)
-			data_field.exp = field->unit_exponent;
-		else
-			data_field.exp = 0x10 - field->unit_exponent;
-		data_field.unit = field->unit;
-	}
-
-	data_field.len = (field->report_size >> 3) * field->report_count;
-	rv = add_data_field(senscol_sensor, &data_field);
-	senscol_sensor->sample_size += (field->report_size >> 3) *
-		field->report_count;
-
-	return	rv;
-}
-
-#endif /*SENSCOL*/
-/***************************** SENSCOL block: END *****************************/
-
-/*
- * Handle raw report as sent by device
- */
+/* Handle raw report as sent by device */
 static int ish_raw_event(struct hid_device *hdev,
-		struct hid_report *report, u8 *raw_data, int size)
+		struct hid_report *report, uint8_t *raw_data, int size)
 {
-	int i;
-	u8 *ptr;
-	int sz;
 	struct ish_data *pdata = hid_get_drvdata(hdev);
-	unsigned long flags;
-	struct hid_collection *collection = NULL;
-	void *priv = NULL;
-#if 1
+	int	i, sz;
+	uint8_t	*ptr;
 	uint32_t	sensor_id;
-	static unsigned char	data_buf[1024];
+	static unsigned char	*data_buf;
 	unsigned	sample_size;
-#endif /*SENSCOL*/
-
 
-	hid_dbg(hdev, "ish_raw_event report id:0x%x size:%d type:%d\n",
-			 report->id, size, report->type);
-	hid_dbg(hdev, "maxfield:%d\n", report->maxfield);
-	if (report->type != HID_INPUT_REPORT)
+	/* make up senscol id */
+	sensor_id = pdata->ish_index << 16 | (report->id & 0xFFFF);
+
+	if (report->type == HID_FEATURE_REPORT) { /* it indicates a flush
+							complete event */
+#if SENSCOL_1
+		senscol_flush_cb_legacy(sensor_id);
+#else
+		senscol_flush_cb(sensor_id);
+#endif
 		return 0;
+	}
+
+	data_buf = kmalloc(size, GFP_KERNEL);
+	if (!data_buf)
+		return -ENOMEM;
 
 	ptr = raw_data;
 	ptr++; /* Skip report id */
 
-	spin_lock_irqsave(&pdata->lock, flags);
-
-#if 1
-	/* make up senscol id */
-	sensor_id = pdata->ish_index << 16 | report->id & 0xFFFF;
 	sample_size = 0;
-#endif /*SENSCOL*/
 
 	for (i = 0; i < report->maxfield; ++i) {
-		hid_dbg(hdev, "%d collection_index:%x hid:%x sz:%x\n",
-				i, report->field[i]->usage->collection_index,
-				report->field[i]->usage->hid,
-				(report->field[i]->report_size *
-					report->field[i]->report_count)/8);
 		sz = (report->field[i]->report_size *
 					report->field[i]->report_count)/8;
 
-#if 1
 		/* Prepare data for senscol sample */
 		if (is_sens_data_field(report->field[i]->usage->hid & 0xFFFF)) {
-			dev_dbg(&hdev->dev, "%s(): aggregating, sz=%u\n",
-				__func__, sample_size);
 			memcpy(data_buf + sample_size, ptr, sz);
 			sample_size += sz;
 		}
-#endif /*SENSCOL*/
-		/*
-		 * If we want to add indication into raw stream that the last
-		 * sample was synchronous, it's here: check for complete()
-		 * condition above
-		 */
-
 		ptr += sz;
 	}
 
-	spin_unlock_irqrestore(&pdata->lock, flags);
-
-#if 1
 	/* Upstream sample to sensor collection framework */
-	dev_dbg(&hdev->dev, "%s(): calling push_sample, aggregated sample size is %u\n",
-		__func__, sample_size);
+#if SENSCOL_1
+	push_sample_legacy(sensor_id, data_buf);
+#else
 	push_sample(sensor_id, data_buf);
-#endif /*SENSCOL*/
+#endif
+	kfree(data_buf);
 	return 1;
 }
 
-static __u8 *ish_report_fixup(struct hid_device *hdev, __u8 *rdesc,
+static uint8_t *ish_report_fixup(struct hid_device *hdev, uint8_t *rdesc,
 		unsigned int *rsize)
 {
 	int index;
-	struct ish_data *sd =  hid_get_drvdata(hdev);
 	unsigned char report_block[] = {
-				0x0a,  0x16, 0x03, 0x15, 0x00, 0x25, 0x05};
+				0x0a, 0x16, 0x03, 0x15, 0x00, 0x25, 0x05};
 	unsigned char power_block[] = {
-				0x0a,  0x19, 0x03, 0x15, 0x00, 0x25, 0x05};
+				0x0a, 0x19, 0x03, 0x15, 0x00, 0x25, 0x05};
 
 	/* Looks for power and report state usage id and force to 1 */
 	for (index = 0; index < *rsize; ++index) {
@@ -612,25 +677,173 @@ static __u8 *ish_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 	return rdesc;
 }
 
-static int ish_probe(struct hid_device *hdev,
-				const struct hid_device_id *id)
+static void translate_logical_physical_usage(struct hid_report_enum *rep_enum)
 {
-	int ret;
-	struct ish_data *sd;
-	int i;
-	char *name;
-	struct hid_report *report, *freport;
-	struct hid_report_enum *inp_report_enum, *feat_report_enum;
-	struct hid_field *field, *feat_field;
-	int dev_cnt;
-	int	rv;
-	struct sensor_def	*senscol_sensor;
-	int	j;
+	struct hid_report	*report;
+	struct hid_field	*field;
+	int	j, i;
+
+	list_for_each_entry(report, &rep_enum->report_list, list) {
+		for (j = 0; j < report->maxfield; ++j) {
+			field = report->field[j];
+			if (!(field->flags & HID_MAIN_ITEM_VARIABLE))
+				for (i = 0; i < field->maxusage; ++i)
+					field->usage[i].hid = field->logical;
+		}
+	}
+}
+
+static int	add_data_fields(struct hid_report *report,
+				struct sensor_def *senscol_sensor)
+{
+	struct hid_field	*field;
+	struct data_field	data_field;
 	const char	*usage_name;
+	char	*name;
+	unsigned	usage;
+	int	i, rv = 0;
+
+	for (i = 0; i < report->maxfield; ++i) {
+		field = report->field[i];
+		usage = field->usage[0].hid;
+		if (!is_sens_data_field(usage & 0xFFFF))
+			continue;
+
+		memset(&data_field, 0, sizeof(struct data_field));
+		usage_name = senscol_usage_to_name(usage & 0xFFFF);
+		if (usage_name)
+			name = kasprintf(GFP_KERNEL, "%s", usage_name);
+		else
+			name = kasprintf(GFP_KERNEL, "data-%X", usage);
+		if (!name)
+			return	-ENOMEM;
+
+		data_field.name = name;
+		data_field.usage_id = usage;
+		data_field.len = (field->report_size >> 3) *
+			field->report_count;
+		data_field.is_numeric = (field->flags & HID_MAIN_ITEM_VARIABLE);
+		if (data_field.is_numeric) {
+			if (field->unit_exponent > 7 ||
+					field->unit_exponent < -8)
+				data_field.exp = 0xFF;
+			else if (field->unit_exponent >= 0)
+				data_field.exp = field->unit_exponent;
+			else
+				data_field.exp = 0x10 - field->unit_exponent;
+			data_field.unit = field->unit;
+		}
+
+		rv = add_data_field(senscol_sensor, &data_field);
+		if (rv)
+			return rv;
+		senscol_sensor->sample_size += (field->report_size >> 3) *
+			field->report_count;
+	}
+	return	0;
+}
+
+static int	add_properties(struct hid_report *report,
+				struct sensor_def *senscol_sensor)
+{
+	struct hid_field	*field;
+	struct sens_property	prop_field;
+	unsigned	usage;
+	int	i, rv;
+
+	for (i = 0; i < report->maxfield; ++i) {
+		field = report->field[i];
+		usage = field->usage[0].hid;
+
+		memset(&prop_field, 0, sizeof(struct sens_property));
+		prop_field.name = create_sens_prop_name(usage & 0xFFFF);
+		if (!prop_field.name)
+			return -ENOMEM;
+
+		prop_field.usage_id = usage;
+		prop_field.is_string = (field->flags & HID_MAIN_ITEM_VARIABLE)
+			&& field->report_count > 1 && field->report_size == 16;
+
+		rv = add_sens_property(senscol_sensor,	&prop_field);
+		if (rv)
+			return rv;
+	}
+	return 0;
+}
+
+/*
+ * release allocated memory of senscol_sensor.
+ * cannot use the senscol-core remove function because the sensor
+ * was not yet added to sensors list
+ */
+static void free_senscol_sensor(struct sensor_def *senscol_sensor)
+{
+	int	i;
+
+	for (i = 0; i < senscol_sensor->num_properties; ++i) {
+		kfree(senscol_sensor->properties[i].name);
+		kfree(senscol_sensor->properties[i].value);
+	}
+	kfree(senscol_sensor->properties);
+
+	for (i = 0; i < senscol_sensor->num_data_fields; ++i)
+		kfree(senscol_sensor->data_fields[i].name);
+	kfree(senscol_sensor->data_fields);
+
+	kfree(senscol_sensor->name);
+	kfree(senscol_sensor);
+}
+
+static struct sensor_def	*create_sensor_from_report(int dev_idx,
+		struct hid_report *inp_report, struct hid_report *feat_report)
+{
+	struct sensor_def	*senscol_sensor;
+	struct hid_field	*inp_field = inp_report->field[0];
+	int	ret;
+
+	senscol_sensor = alloc_senscol_sensor();
+	if (!senscol_sensor)
+		return NULL;
+#if SENSCOL_1
+	init_senscol_sensor_legacy(senscol_sensor);
+#else
+	init_senscol_sensor(senscol_sensor);
+#endif
+	senscol_sensor->name = create_sensor_name(inp_field->physical & 0xFFFF);
+	if (!senscol_sensor->name)
+		goto err_free;
+
+	senscol_sensor->usage_id = inp_field->physical;
+	senscol_sensor->id = dev_idx << 16 | (inp_report->id & 0xFFFF);
+	senscol_sensor->impl = &hid_senscol_impl;
+	senscol_sensor->sample_size = 0;
+
+	ret = add_data_fields(inp_report, senscol_sensor);
+	if (ret)
+		goto err_free;
+
+	ret = add_properties(feat_report, senscol_sensor);
+	if (ret)
+		goto err_free;
+
+	return senscol_sensor;
+err_free:
+	free_senscol_sensor(senscol_sensor);
+	return NULL;
+}
+
+static int ish_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	struct ish_data	*sd;
+	struct hid_report_enum	*inp_report_enum, *feat_report_enum;
+	struct hid_report	*inp_report, *feat_report;
+	struct hid_field	*inp_field, *feat_field;
+	struct sensor_def	*senscol_sensor;
+	int	dev_cnt, ret = 0;
 
 	sd = devm_kzalloc(&hdev->dev, sizeof(*sd), GFP_KERNEL);
 	if (!sd) {
-		hid_err(hdev, "cannot allocate Sensor data\n");
+		hid_err(hdev, "cannot allocate sensor data structure\n");
 		return -ENOMEM;
 	}
 	sd->hsdev = devm_kzalloc(&hdev->dev, sizeof(*sd->hsdev), GFP_KERNEL);
@@ -644,16 +857,10 @@ static int ish_probe(struct hid_device *hdev,
 	hid_sens_hubs[ish_cur_count] = hdev;
 	/* Need to count sensor hub devices for senscol ids */
 	sd->ish_index = ish_cur_count++;
-#if 1
-	if (ish_cur_count >= ish_max_count)
-		senscol_send_ready_event();
-	if (ish_cur_count > ish_max_count)
-		ish_max_count = ish_cur_count;
-#endif
+
 	sd->hsdev->hdev = hdev;
 	sd->hsdev->vendor_id = hdev->vendor;
 	sd->hsdev->product_id = hdev->product;
-	spin_lock_init(&sd->lock);
 	mutex_init(&sd->mutex);
 	ret = hid_parse(hdev);
 	if (ret) {
@@ -662,280 +869,112 @@ static int ish_probe(struct hid_device *hdev,
 	}
 	INIT_LIST_HEAD(&hdev->inputs);
 
-	ret = hid_hw_start(hdev, 0);
-	if (ret) {
-		hid_err(hdev, "hw start failed\n");
-		goto err_free;
-	}
 	inp_report_enum = &hdev->report_enum[HID_INPUT_REPORT];
 	feat_report_enum = &hdev->report_enum[HID_FEATURE_REPORT];
 
 	dev_cnt = ish_get_physical_device_count(inp_report_enum);
 	if (dev_cnt > HID_MAX_PHY_DEVICES) {
-		hid_err(hdev, "Invalid Physical device count\n");
+		hid_err(hdev, "Invalid physical device count\n");
 		ret = -EINVAL;
 		goto err_stop_hw;
 	}
 
-#if 1
-	/* Register senscol impl */
-	if (!senscol_impl_added) {
-		rv = add_senscol_impl(&hid_senscol_impl);
-		dev_dbg(&hdev->dev, "%s(): add_senscol_impl() returned %d\n",
-			__func__, rv);
-		if (!rv)
-			senscol_impl_added = 1;
-	}
-#endif /*SENSCOL*/
-	/* Translate properties logical->physical if needed here,
-	 * instead of hid-core */
-	list_for_each_entry(freport, &feat_report_enum->report_list, list) {
-		int	j;
-
-		for (j = 0; j < freport->maxfield; ++j) {
-			feat_field = freport->field[j];
-			if (!(feat_field->flags & HID_MAIN_ITEM_VARIABLE))
-				for (i = 0; i < feat_field->maxusage; ++i)
-					feat_field->usage[i].hid =
-						feat_field->logical;
-		}
-	}
+	translate_logical_physical_usage(feat_report_enum);
+	translate_logical_physical_usage(inp_report_enum);
 
-	/* Translate  input fields logical->physical if needed here,
-	 * instead of hid-core */
-	list_for_each_entry(report, &inp_report_enum->report_list, list) {
-		int	j;
+	list_for_each_entry(inp_report, &inp_report_enum->report_list, list) {
+		hid_dbg(hdev, "Report id:%x\n", inp_report->id);
+		inp_field = inp_report->field[0];
 
-		for (j = 0; j < report->maxfield; ++j) {
-			field = report->field[j];
-			if (!(field->flags & HID_MAIN_ITEM_VARIABLE))
-				for (i = 0; i < field->maxusage; ++i)
-					field->usage[i].hid = field->logical;
-		}
-	}
-
-	list_for_each_entry(report, &inp_report_enum->report_list, list) {
-		hid_dbg(hdev, "Report id:%x\n", report->id);
-		field = report->field[0];
-
-#if 1
-		/* Create senscol sensor from each report */
-		senscol_sensor = alloc_senscol_sensor();
-		if (!senscol_sensor) {
-			dev_err(&hdev->dev,
-				"%s(): failed to allocate sensor\n", __func__);
-			break;
-		}
-		init_senscol_sensor(senscol_sensor);
-		usage_name = senscol_usage_to_name(field->physical & 0xFFFF);
-		if (usage_name)
-			senscol_sensor->name = kasprintf(GFP_KERNEL,
-				"%s", usage_name);
-		else
-			senscol_sensor->name = kasprintf(GFP_KERNEL,
-				"custom-%X", field->physical);
-		if (!senscol_sensor->name) {
-			dev_err(&hdev->dev,
-				"%s(): failed to allocate name\n",
-				__func__);
-			kfree(senscol_sensor);
-			break;
-		}
-		senscol_sensor->usage_id = field->physical;
-		senscol_sensor->id = sd->ish_index << 16 |
-			report->id & 0xFFFF;
-		senscol_sensor->impl = &hid_senscol_impl;
-		senscol_sensor->sample_size = 0;
-
-		/* Add properties */
-		/* 1. find matching feature report */
-		list_for_each_entry(freport,
-				&feat_report_enum->report_list,
+		/* find matching feature report to add properties */
+		list_for_each_entry(feat_report, &feat_report_enum->report_list,
 				list) {
-			feat_field = freport->field[0];
-			if (freport->maxfield && feat_field &&
+			feat_field = feat_report->field[0];
+			if (feat_report->maxfield && feat_field &&
 					feat_field->physical &&
 					(feat_field->physical ==
-					senscol_sensor->usage_id) &&
-					freport->id == report->id)
+					inp_field->physical) &&
+					feat_report->id == inp_report->id)
 				break;
 		}
-
-		/*2. dump each prop field */
-		for (i = 0; i < freport->maxfield; ++i) {
-			struct sens_property	prop_field;
-
-			dev_dbg(&hdev->dev,
-				"%d collection_index:%x hid:%x sz:%x ",
-				i,
-				freport->field[i]->usage->
-					collection_index,
-				freport->field[i]->usage->hid,
-				freport->field[i]->report_size / 8);
-
-			dev_dbg(&hdev->dev, "report count: %u\n",
-				freport->field[i]->report_count);
-
-			memset(&prop_field, 0,
-				sizeof(struct sens_property));
-			prop_field.usage_id =
-				freport->field[i]->usage->hid;
-			usage_name = senscol_usage_to_name(
-				prop_field.usage_id & 0xFFFF);
-			if (usage_name)
-				prop_field.name = kasprintf(GFP_KERNEL,
-						"%s", usage_name);
-			/* there is  a special case when the property
-			 * is related to specific data field/
-			 * set of fields */
-			else {
-				uint32_t modifier =
-					prop_field.usage_id & 0xF000;
-				uint32_t data_hid =
-					prop_field.usage_id & 0x0FFF;
-				const char *modif_name =
-					senscol_get_modifier(modifier);
-				usage_name = senscol_usage_to_name(
-					data_hid);
-
-				if (!strcmp(modif_name, "custom")) {
-					prop_field.name =
-						kasprintf(GFP_KERNEL,
-						"custom-%X",
-						prop_field.usage_id & 0xFFFF);
-				} else if (!usage_name)
-					prop_field.name =
-						kasprintf(GFP_KERNEL,
-						"unknown-%X",
-						prop_field.usage_id & 0xFFFF);
-				else
-					prop_field.name =
-						kasprintf(GFP_KERNEL,
-						"%s_%s", usage_name,
-						modif_name);
-			}
-			prop_field.is_numeric =
-				(freport->field[i]->flags &
-				HID_MAIN_ITEM_VARIABLE) &&
-				/* not string: not array of unsigned short */
-				!(freport->field[i]->report_count > 1 &&
-				freport->field[i]->report_size == 16);
-
-			rv = add_sens_property(senscol_sensor,
-				&prop_field);
-			dev_dbg(&hdev->dev, "%s(): ", __func__);
-			dev_dbg(&hdev->dev, "adding prop %s %s %d\n",
-				prop_field.name, "returned",  rv);
+		senscol_sensor = create_sensor_from_report(sd->ish_index,
+			inp_report, feat_report);
+		if (!senscol_sensor) {
+			dev_err(&hdev->dev, "failed to create sensor\n");
+			ret = -ENOMEM;
+			goto err_stop_hw;
 		}
 
-		/* Add data fields; Dump fields in this report.
-		`maxfield' is upper-bound NON-INCLUSIVE */
-		for (j = 0; j < report->maxfield; ++j) {
-
-			dev_dbg(&hdev->dev, "%s(): ", __func__);
-			dev_dbg(&hdev->dev,
-				"%s=%d %s=%08X %s=%08X %s=%u %s=%u ",
-				"field", j,
-				"physical",  report->field[j]->physical,
-				"logical", report->field[j]->logical,
-				"maxusage", report->field[j]->maxusage,
-				"report_type",
-				report->field[j]->report_type);
-			dev_dbg(&hdev->dev, "%s=%u %s=%d %s=%d %s=%d ",
-				"report_size",
-				report->field[j]->report_size >> 3,
-				"logic_min",
-				report->field[j]->logical_minimum,
-				"logic_max",
-				report->field[j]->logical_maximum,
-				"phys_min",
-				report->field[j]->physical_minimum);
-			dev_dbg(&hdev->dev, "%s=%d %s=%d %s=%u %s=%d\n",
-				"phys_max",
-				report->field[j]->physical_maximum,
-				"exp",
-				report->field[j]->unit_exponent,
-				"unit",
-				report->field[j]->unit,
-				"report_count",
-				report->field[j]->report_count);
-			dev_dbg(&hdev->dev, "%s(): usages --\n",
-				__func__);
-
-			field = report->field[j];
-			/* Add data field */
-			if (is_sens_data_field(field->usage[0].hid & 0xFFFF)) {
-				rv = fill_data_field(field,
-					field->usage[0].hid,
-					senscol_sensor);
-				if (rv == -ENOMEM)
-					dev_err(&hdev->dev,
-						"%s(): Failed to allocated data field for usage %08X\n",
-						__func__,
-						field->usage[0].hid);
-			}
+		/* Add the filled senscol_sensor */
+#if SENSCOL_1
+		ret = add_senscol_sensor_legacy(senscol_sensor);
+#else
+		ret = add_senscol_sensor(senscol_sensor);
+#endif
+		if (ret) {
+			dev_err(&hdev->dev, "Failed to add senscol sensor\n");
+			goto err_stop_hw;
 		}
-
-		/* Add senscol_sensor */
-		rv = add_senscol_sensor(senscol_sensor);
-		dev_dbg(&hdev->dev,
-			"%s(): add_senscol_sensor() returned %d\n",
-			__func__, rv);
-#endif /*SENSCOL*/
 	}
-	return ret;
 
-err_free_names:
+	if (ish_cur_count >= ish_max_count)
+#if SENSCOL_1
+		senscol_send_ready_event_legacy();
+#else
+		senscol_send_ready_event();
+#endif
+	if (ish_cur_count > ish_max_count)
+		ish_max_count = ish_cur_count;
+
+	return 0;
+
 err_stop_hw:
 	hid_hw_stop(hdev);
 err_free:
-	/*kfree(sd->hsdev);*/
+	kfree(sd->hsdev);
 err_free_hub:
-	/*kfree(sd);*/
+	kfree(sd);
 
 	return ret;
 }
 
 static void ish_remove(struct hid_device *hdev)
 {
-	struct ish_data *data = hid_get_drvdata(hdev);
-	unsigned long flags;
-	int i;
-#if 1
+	struct ish_data	*data = hid_get_drvdata(hdev);
 	uint32_t	hid_device_id;
-	struct hid_report *report;
-#endif
+	struct hid_report	*report;
+	int	i;
 
-	/*use max count since we can't know the remove order of hid devices*/
+	/* use max count since we can't know the remove order of hid devices */
 	for (i = 0; i < ish_max_count; ++i)
 		if (hid_sens_hubs[i] == hdev) {
 			hid_sens_hubs[i] = NULL;
 			break;
 		}
 
-	hid_dbg(hdev, " hardware removed\n");
 	hid_hw_close(hdev);
 	hid_hw_stop(hdev);
-	spin_lock_irqsave(&data->lock, flags);
-	if (data->pending.status)
-		complete(&data->pending.ready);
-	spin_unlock_irqrestore(&data->lock, flags);
 
-#if 1
 	hid_device_id = data->ish_index;
 	list_for_each_entry(report,
 			&hdev->report_enum[HID_INPUT_REPORT].report_list,
 			list) {
+#if SENSCOL_1
+		remove_senscol_sensor_legacy(data->ish_index << 16 |
+			(report->id & 0xFFFF));
+#else
 		remove_senscol_sensor(data->ish_index << 16 |
 			(report->id & 0xFFFF));
-	}
 #endif
+	}
 
 	hid_set_drvdata(hdev, NULL);
 	mutex_destroy(&data->mutex);
 	ish_cur_count--;
-#if 1
 	if (ish_cur_count == ish_max_count - 1)
+#if SENSCOL_1
+		senscol_reset_notify_legacy();
+#else
 		senscol_reset_notify();
 #endif
 }
@@ -950,7 +989,7 @@ static const struct hid_device_id ish_devices[] = {
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, USB_VENDOR_ID_STM_0,
 			USB_DEVICE_ID_STM_HID_SENSOR_1)},
 	{ HID_DEVICE(HID_BUS_ANY, HID_GROUP_SENSOR_HUB, HID_ANY_ID,
-		     HID_ANY_ID) },
+			HID_ANY_ID) },
 	{ }
 };
 MODULE_DEVICE_TABLE(hid, ish_devices);
@@ -966,10 +1005,21 @@ static struct hid_driver ish_driver = {
 	.suspend = ish_suspend,
 	.resume = ish_resume,
 	.reset_resume = ish_reset_resume,
-#endif /*CONFIG_PM*/
+#endif /* CONFIG_PM */
 };
+
 static int __init ish_driver_init(void)
 {
+	int ret;
+
+#if SENSCOL_1
+	ret = senscol_init_legacy();
+#else
+	ret = senscol_init();
+#endif
+	if (ret)
+		return ret;
+
 	return hid_register_driver(&ish_driver);
 }
 late_initcall(ish_driver_init);
@@ -977,6 +1027,9 @@ late_initcall(ish_driver_init);
 static void __exit ish_driver_exit(void)
 {
 	hid_unregister_driver(&ish_driver);
+#if SENSCOL_1
+	senscol_exit_legacy();
+#endif
 }
 module_exit(ish_driver_exit);
 
diff --git a/drivers/misc/intel-ish/platform-config.h b/drivers/misc/intel-ish/platform-config.h
index 2f03699..dc446bd 100644
--- a/drivers/misc/intel-ish/platform-config.h
+++ b/drivers/misc/intel-ish/platform-config.h
@@ -19,7 +19,6 @@
 /* Build ID string */
 #define BUILD_ID	"260-stdint"
 
-#define	ISH_DBG_PRINT	no_printk
 #define	ISH_INFO	1
 #if ISH_INFO
 #define	ISH_INFO_PRINT	printk
diff --git a/drivers/misc/intel-ish/senscol-core-common.c b/drivers/misc/intel-ish/senscol-core-common.c
new file mode 100644
index 0000000..37273a7
--- /dev/null
+++ b/drivers/misc/intel-ish/senscol-core-common.c
@@ -0,0 +1,133 @@
+/*
+ * Sensor collection interface
+ *
+ * Copyright (c) 2014-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/senscol/senscol-core.h>
+#include "hid-strings-def.h"
+
+struct list_head	senscol_sensors_list;
+spinlock_t	senscol_lock;
+
+const char	*senscol_usage_to_name(unsigned usage)
+{
+	int i;
+
+	for (i = 0; code_msg_arr[i].msg && code_msg_arr[i].code != usage; i++)
+		;
+	return code_msg_arr[i].msg;
+}
+
+const char	*senscol_get_modifier(unsigned modif)
+{
+	uint32_t to4bits = modif >> 0xC;
+	return	modifiers[to4bits];
+}
+
+char	*create_sensor_name(unsigned usage_id)
+{
+	const char	*usage_name;
+
+	usage_name = senscol_usage_to_name(usage_id & 0xFFFF);
+	if (usage_name)
+		return kasprintf(GFP_KERNEL, "%s", usage_name);
+
+	return kasprintf(GFP_KERNEL, "custom-%X", usage_id);
+}
+
+char	*create_sens_prop_name(unsigned usage_id)
+{
+	const char	*usage_name;
+	uint32_t	modifier;
+	uint32_t	data_hid;
+	const char	*modif_name;
+
+	usage_name = senscol_usage_to_name(usage_id & 0xFFFF);
+	if (usage_name)
+		/* a regular property */
+		return kasprintf(GFP_KERNEL, "%s", usage_name);
+
+	modifier = usage_id & 0xF000;
+	data_hid = usage_id & 0x0FFF;
+	modif_name = senscol_get_modifier(modifier);
+	usage_name = senscol_usage_to_name(data_hid);
+	if (!strcmp(modif_name, "custom"))
+		/* a private (custom) property */
+		return kasprintf(GFP_KERNEL, "custom-%X", usage_id & 0xFFFF);
+
+	if (!usage_name)
+		/* unknown property */
+		return kasprintf(GFP_KERNEL, "unknown-%X", usage_id & 0xFFFF);
+
+	/* a modifier related to another property */
+	return kasprintf(GFP_KERNEL, "%s_%s", usage_name, modif_name);
+}
+
+/* Only allocates new sensor */
+struct sensor_def	*alloc_senscol_sensor(void)
+{
+	struct sensor_def *sens;
+
+	sens = kzalloc(sizeof(struct sensor_def), GFP_KERNEL);
+	return	sens;
+}
+
+/* should be called under senscol_lock */
+struct sensor_def	*get_senscol_sensor_by_id(uint32_t id)
+{
+	struct sensor_def	*sens, *next;
+
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->id == id)
+			return	sens;
+	}
+	return	NULL;
+}
+
+/* Add data field to existing sensor */
+int	add_data_field(struct sensor_def *sensor, struct data_field *data)
+{
+	struct data_field	*temp;
+
+	temp = krealloc(sensor->data_fields,
+		(sensor->num_data_fields + 1) * sizeof(struct data_field),
+		GFP_KERNEL);
+	if (!temp)
+		return	-ENOMEM;
+
+	data->sensor = sensor;
+	memcpy(&temp[sensor->num_data_fields++], data,
+		sizeof(struct data_field));
+	sensor->data_fields = temp;
+	return	0;
+}
+
+/* Add property to existing sensor */
+int	add_sens_property(struct sensor_def *sensor, struct sens_property *prop)
+{
+	struct sens_property	*temp;
+
+	temp = krealloc(sensor->properties,
+		(sensor->num_properties + 1) * sizeof(struct sens_property),
+		GFP_KERNEL);
+	if (!temp)
+		return	-ENOMEM;
+
+	prop->sensor = sensor;		/* The needed backlink */
+	memcpy(&temp[sensor->num_properties++], prop,
+		sizeof(struct sens_property));
+	sensor->properties = temp;
+	return	0;
+}
diff --git a/drivers/misc/intel-ish/senscol-core-legacy.c b/drivers/misc/intel-ish/senscol-core-legacy.c
new file mode 100644
index 0000000..6baa6c5
--- /dev/null
+++ b/drivers/misc/intel-ish/senscol-core-legacy.c
@@ -0,0 +1,836 @@
+/*
+ * Sensor collection interface
+ *
+ * Copyright (c) 2014-2016, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/senscol/senscol-core.h>
+
+#if SENSCOL_1
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/kobject.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include "platform-config.h"
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include "ishtp-hid.h"
+
+spinlock_t	senscol_data_lock;
+uint8_t	*senscol_data_buf;
+unsigned	senscol_data_head, senscol_data_tail;
+int	flush_asked = 0;
+
+wait_queue_head_t	senscol_read_wait;
+wait_queue_head_t	senscol_init_wait;
+int	senscol_init_done = 0;
+
+struct task_struct	*user_task = NULL;
+
+static struct platform_device	*sc_pdev;
+
+void senscol_send_ready_event_legacy(void)
+{
+	if (waitqueue_active(&senscol_read_wait))
+		wake_up_interruptible(&senscol_read_wait);
+}
+
+int senscol_reset_notify_legacy(void)
+{
+
+	struct siginfo si;
+	int ret;
+
+	memset(&si, 0, sizeof(struct siginfo));
+	si.si_signo = SIGUSR1;
+	si.si_code = SI_USER;
+
+	if (user_task == NULL)
+		return -EINVAL;
+
+	ret = send_sig_info(SIGUSR1, &si, user_task);
+	return ret;
+}
+
+/* data node definition */
+static void	sc_data_release(struct kobject *k)
+{
+}
+static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	scnprintf(buf, PAGE_SIZE, "%s\n", attr->name);
+	return	strlen(buf);
+}
+
+static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	return	size;
+}
+
+const struct sysfs_ops	sc_data_sysfs_fops = {
+	.show = sc_data_show,
+	.store = sc_data_store
+};
+
+struct kobj_type	sc_data_kobj_type = {
+	.release = sc_data_release,
+	.sysfs_ops = &sc_data_sysfs_fops
+};
+
+struct kobject	sc_data_kobj;
+
+static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
+
+static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
+
+struct bin_attribute	sensors_data_binattr = {
+	.attr = {
+		.name = "sensors_data",
+		.mode = S_IRUGO
+	},
+	.size = 0,
+	.read = sensors_data_read,
+	.write = sensors_data_write
+};
+/************************/
+
+/*
+ * sensor_def kobject type and handlers
+ */
+static struct attribute	sc_sensdef_defattr_name = {
+	.name = "name",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_id = {
+	.name = "id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_sample_size = {
+	.name = "sample_size",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_flush = {
+	.name = "flush",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_sensdef_defattr_get_sample = {
+	.name = "get_sample",
+	.mode = (S_IRUGO)
+};
+
+struct attribute	*sc_sensdef_defattrs[] = {
+	&sc_sensdef_defattr_name,
+	&sc_sensdef_defattr_id,
+	&sc_sensdef_defattr_usage_id,
+	&sc_sensdef_defattr_sample_size,
+	&sc_sensdef_defattr_flush,
+	&sc_sensdef_defattr_get_sample,
+	NULL
+};
+
+static void	sc_sensdef_release(struct kobject *k)
+{
+}
+
+static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	ssize_t	rv;
+	struct sensor_def	*sensdef;
+	static char	tmp_buf[0x1000];
+	unsigned long flags;
+
+	sensdef = container_of(kobj, struct sensor_def, kobj);
+	buf[0] = '\0';
+	if (!strcmp(attr->name, "id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->id);
+	else if (!strcmp(attr->name, "sample_size"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", sensdef->sample_size);
+	else if (!strcmp(attr->name, "usage_id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->usage_id);
+	else if (!strcmp(attr->name, "name"))
+		scnprintf(buf, PAGE_SIZE, "%s\n", sensdef->name);
+	else if (!strcmp(attr->name, "flush")) {
+		spin_lock_irqsave(&senscol_lock, flags);
+		flush_asked = 1;
+		sensdef->flush_req = 1;
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		sensdef->impl->get_sens_property(sensdef,
+			sensdef->properties, tmp_buf, 0x1000);
+		scnprintf(buf, PAGE_SIZE, "1\n");
+	} else if (!strcmp(attr->name, "get_sample")) {
+		rv = sensdef->impl->get_sample(sensdef);
+		/* The sample will arrive to hid "raw event" func,
+		and will be pushed to user via "push_sample" method */
+
+		scnprintf(buf, PAGE_SIZE, "%d\n", !rv);
+	}
+	rv = strlen(buf) + 1;
+	return	rv;
+}
+
+static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	return	-EINVAL;
+}
+const struct sysfs_ops	sc_sensdef_sysfs_fops = {
+	.show = sc_sensdef_show,
+	.store = sc_sensdef_store
+};
+
+struct kobj_type	sc_sensdef_kobj_type = {
+	.release = sc_sensdef_release,
+	.sysfs_ops = &sc_sensdef_sysfs_fops,
+	.default_attrs = sc_sensdef_defattrs
+};
+/*****************************************/
+
+/*
+ * kobject type for empty sub-directories
+ */
+static struct attribute	*sc_subdir_defattrs[] = {
+	NULL
+};
+
+static void	sc_subdir_release(struct kobject *k)
+{
+}
+
+static ssize_t	sc_subdir_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	return	-EINVAL;
+}
+
+static ssize_t	sc_subdir_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	return	-EINVAL;
+}
+
+const struct sysfs_ops	sc_subdir_sysfs_fops = {
+	.show = sc_subdir_show,
+	.store = sc_subdir_store
+};
+
+struct kobj_type	sc_subdir_kobj_type = {
+	.release = sc_subdir_release,
+	.sysfs_ops = &sc_subdir_sysfs_fops,
+	.default_attrs = sc_subdir_defattrs
+};
+/*****************************************/
+
+/*
+ * sensors 'data_field's kobject type
+ */
+static struct attribute	sc_datafield_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	sc_datafield_defattr_exp = {
+	.name = "exponent",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_len = {
+	.name = "length",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_unit = {
+	.name = "unit",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute sc_datafield_defattr_index = {
+	.name = "index",
+	.mode = (S_IRUGO)
+};
+
+static struct attribute	sc_datafield_defattr_is_numeric = {
+	.name = "is_numeric",
+	.mode = (S_IRUGO)
+};
+
+struct attribute	*sc_datafield_defattrs[] = {
+	&sc_datafield_defattr_usage_id,
+	&sc_datafield_defattr_exp,
+	&sc_datafield_defattr_len,
+	&sc_datafield_defattr_unit,
+	&sc_datafield_defattr_index,
+	&sc_datafield_defattr_is_numeric,
+	NULL
+};
+
+static void	sc_datafield_release(struct kobject *k)
+{
+}
+
+static ssize_t	sc_datafield_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	ssize_t	rv;
+	struct data_field	*dfield;
+
+	dfield = container_of(kobj, struct data_field, kobj);
+	if (!strcmp(attr->name, "usage_id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", (unsigned)dfield->usage_id);
+	else if (!strcmp(attr->name, "exponent"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->exp);
+	else if (!strcmp(attr->name, "length"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->len);
+	else if (!strcmp(attr->name, "unit"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->unit);
+	else if (!strcmp(attr->name, "index"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->index);
+	else if (!strcmp(attr->name, "is_numeric"))
+		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->is_numeric);
+
+	rv = strlen(buf) + 1;
+	return	rv;
+}
+
+static ssize_t	sc_datafield_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	return	-EINVAL;
+}
+
+const struct sysfs_ops	sc_datafield_sysfs_fops = {
+	.show = sc_datafield_show,
+	.store = sc_datafield_store
+};
+
+struct kobj_type	sc_datafield_kobj_type = {
+	.release = sc_datafield_release,
+	.sysfs_ops = &sc_datafield_sysfs_fops,
+	.default_attrs = sc_datafield_defattrs
+};
+/*****************************************/
+
+/*
+ * sensors 'properties' kobject type
+ */
+static struct attribute sc_sensprop_defattr_value = {
+	.name = "value",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+
+static struct attribute sc_sensprop_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+
+struct attribute	*sc_sensprop_defattrs[] = {
+	&sc_sensprop_defattr_value,
+	&sc_sensprop_defattr_usage_id,
+	NULL
+};
+
+static void	sc_sensprop_release(struct kobject *k)
+{
+}
+
+static ssize_t	sc_sensprop_show(struct kobject *kobj, struct attribute *attr,
+	char *buf)
+{
+	struct sens_property	*pfield;
+	struct sensor_def	*sensor;
+	int	rv = 0;
+
+	/*
+	 * We need "property_power_state" (=2), "property_reporting_state" (=2)
+	 * and "property_report_interval" (in ms?)
+	 */
+	pfield = container_of(kobj, struct sens_property, kobj);
+	sensor = pfield->sensor;
+
+	if (!strcmp(attr->name, "value"))
+		rv = sensor->impl->get_sens_property(sensor, pfield, buf,
+			0x1000);
+	else if (!strcmp(attr->name, "usage_id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", pfield->usage_id & 0xFFFF);
+	if (rv)
+		return	rv;
+	return	strlen(buf);
+}
+
+static ssize_t	sc_sensprop_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	struct sens_property	*pfield;
+	struct sensor_def	*sensor;
+	int	rv;
+
+	if (strcmp(attr->name, "value"))
+		return -EINVAL;
+
+	pfield = container_of(kobj, struct sens_property, kobj);
+	sensor = pfield->sensor;
+	rv = sensor->impl->set_sens_property(sensor, pfield, buf);
+
+	if (rv)
+		return	rv;
+	return	size;
+}
+
+const struct sysfs_ops	sc_sensprop_sysfs_fops = {
+	.show = sc_sensprop_show,
+	.store = sc_sensprop_store
+};
+
+struct kobj_type	sc_sensprop_kobj_type = {
+	.release = sc_sensprop_release,
+	.sysfs_ops = &sc_sensprop_sysfs_fops,
+	.default_attrs = sc_sensprop_defattrs
+};
+/*****************************************/
+
+static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+{
+	size_t	count;
+	unsigned	cur;
+	struct senscol_sample	*sample;
+	unsigned long	flags;
+
+	if (size > PAGE_SIZE)
+		size = PAGE_SIZE;
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+
+	/*
+	 * Count how much we may copy, keeping whole samples.
+	 * Copy samples along the way
+	 */
+	count = 0;
+	cur = senscol_data_head;
+	while (cur != senscol_data_tail) {
+		sample = (struct senscol_sample *)(senscol_data_buf + cur);
+		if (count + sample->size > size)
+			break;
+		memcpy(buf + count, sample, sample->size);
+		count += sample->size;
+		cur += sample->size;
+		if (cur > SENSCOL_DATA_BUF_LAST)
+			cur = 0;
+	}
+	senscol_data_head = cur;
+
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	return	count;
+}
+
+static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+{
+	return	-EINVAL;
+}
+
+/* Init sensor (don't call for initialized sensors) */
+void	init_senscol_sensor_legacy(struct sensor_def *sensor)
+{
+	if (!sensor)
+		return;
+	memset(sensor, 0, sizeof(*sensor));
+	sensor->name = NULL;
+	sensor->friendly_name = NULL;
+	sensor->impl = NULL;
+	sensor->data_fields = NULL;
+	sensor->properties = NULL;
+}
+
+int remove_senscol_sensor_legacy(uint32_t id)
+{
+	unsigned long	flags;
+	struct sensor_def	*sens, *next;
+	int i;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->id == id) {
+			list_del(&sens->link);
+			spin_unlock_irqrestore(&senscol_lock, flags);
+
+			for (i = 0; i < sens->num_properties; ++i)
+				if (sens->properties[i].name) {
+					kobject_put(&sens->properties[i].kobj);
+					kobject_del(&sens->properties[i].kobj);
+				}
+			kfree(sens->properties);
+			kobject_put(&sens->props_kobj);
+			kobject_del(&sens->props_kobj);
+
+			for (i = 0; i < sens->num_data_fields; ++i)
+				if (sens->data_fields[i].name) {
+					kobject_put(&sens->data_fields[i].kobj);
+					kobject_del(&sens->data_fields[i].kobj);
+				}
+			kfree(sens->data_fields);
+			kobject_put(&sens->data_fields_kobj);
+			kobject_del(&sens->data_fields_kobj);
+			kobject_put(&sens->kobj);
+			kobject_del(&sens->kobj);
+
+			kfree(sens);
+
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&senscol_lock, flags);
+
+	return -EINVAL;
+}
+
+/*
+ * Exposed sensor via sysfs, structure may be static
+ *
+ * The caller is responsible for setting all meaningful fields
+ * (may call add_data_field() and add_sens_property() as needed)
+ * We'll consider hiding senscol framework-specific fields
+ * into opaque structures
+ */
+
+int	add_senscol_sensor_legacy(struct sensor_def *sensor)
+{
+	unsigned long	flags;
+	char	sensor_name[256];	/* Enough for name "sensor_<NN>_def",
+					 * if convention changes array size
+					 * should be reviewed */
+	int	i;
+	int	rv;
+	int	j;
+
+	if (!sensor->name || !sensor->impl || !sensor->usage_id || !sensor->id)
+		return	-EINVAL;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_add_tail(&sensor->link, &senscol_sensors_list);
+	spin_unlock_irqrestore(&senscol_lock, flags);
+
+	/*
+	 * Create sysfs entries for this sensor
+	 */
+
+	/* Init and add sensor_def kobject */
+	snprintf(sensor_name, sizeof(sensor_name), "sensor_%X_def", sensor->id);
+	rv = kobject_init_and_add(&sensor->kobj, &sc_sensdef_kobj_type,
+		&sc_pdev->dev.kobj, sensor_name);
+	if (rv) {
+		rv = -EFAULT;
+err_ret:
+		kobject_put(&sensor->kobj);
+		kobject_del(&sensor->kobj);
+		return	rv;
+	}
+
+	/*
+	 * Create kobjects without attributes for
+	 * sensor_<NN>_def/data_fields and sensor_<NN>/properties
+	 */
+	rv = kobject_init_and_add(&sensor->data_fields_kobj,
+		&sc_subdir_kobj_type, &sensor->kobj, "data_fields");
+	if (rv) {
+		rv = -EFAULT;
+err_ret2:
+		kobject_put(&sensor->data_fields_kobj);
+		kobject_del(&sensor->data_fields_kobj);
+		goto	err_ret;
+	}
+
+	rv = kobject_init_and_add(&sensor->props_kobj, &sc_subdir_kobj_type,
+		&sensor->kobj, "properties");
+	if (rv) {
+		rv = -EFAULT;
+		kobject_put(&sensor->props_kobj);
+		kobject_del(&sensor->props_kobj);
+		goto	err_ret2;
+	}
+
+	/*
+	 * Create kobjects for data_fields
+	 */
+	for (i = 0; i < sensor->num_data_fields; ++i)
+		if (sensor->data_fields[i].name)
+			for (j = i-1; j >= 0; --j)	/* use index as a temp
+							variable */
+				if (sensor->data_fields[j].name &&
+					!strcmp(sensor->data_fields[i].name,
+						sensor->data_fields[j].name)) {
+					if (!sensor->data_fields[j].index)
+						sensor->data_fields[j].index++;
+					sensor->data_fields[i].index =
+						sensor->data_fields[j].index
+									+ 1;
+					break;
+				}
+
+	for (i = 0; i < sensor->num_data_fields; ++i) {
+		if (sensor->data_fields[i].name) {
+			if (sensor->data_fields[i].index) {
+				char *p = kasprintf(GFP_KERNEL, "%s#%d",
+					sensor->data_fields[i].name,
+					sensor->data_fields[i].index-1);
+				kfree(sensor->data_fields[i].name);
+				sensor->data_fields[i].name = p;
+			}
+
+			/* Mark index */
+			sensor->data_fields[i].index = i;
+
+			rv = kobject_init_and_add(&sensor->data_fields[i].kobj,
+				&sc_datafield_kobj_type,
+				&sensor->data_fields_kobj,
+				sensor->data_fields[i].name);
+		}
+	}
+
+	/*
+	 * Create kobjects for properties
+	 */
+	for (i = 0; i < sensor->num_properties; ++i) {
+		if (sensor->properties[i].name) {
+			rv = kobject_init_and_add(&sensor->properties[i].kobj,
+				&sc_sensprop_kobj_type, &sensor->props_kobj,
+				sensor->properties[i].name);
+		}
+	}
+
+	/* Sample size should be set by the caller to size of raw data */
+	sensor->sample_size += offsetof(struct senscol_sample, data);
+
+	return	0;
+}
+
+/*
+ * Push data sample in upstream buffer towards user-mode.
+ * Sample's size is determined from the structure
+ *
+ * Samples are queued is a simple FIFO binary buffer with head and tail
+ * pointers.
+ * Additional fields if wanted to be communicated to user mode can be defined
+ *
+ * Returns 0 on success, negative error code on error
+ */
+int	push_sample_legacy(uint32_t id, void *sample)
+{
+	struct sensor_def	*sensor;
+	unsigned long flags;
+	unsigned char	sample_buf[1024];
+	struct senscol_sample	*p_sample = (struct senscol_sample *)sample_buf;
+	struct sensor_def pseudo_event_sensor;
+
+	if (!senscol_data_buf)
+		return	-ENOMEM;
+
+	if (id & PSEUSO_EVENT_BIT) {
+		pseudo_event_sensor.sample_size = sizeof(uint32_t) +
+			offsetof(struct senscol_sample, data);
+		sensor = &pseudo_event_sensor;
+	} else
+		sensor = get_senscol_sensor_by_id(id);
+
+	if (!sensor)
+		return	-ENODEV;
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+
+	/* When buffer overflows the new data is dropped */
+	if (senscol_data_head != senscol_data_tail &&
+			(senscol_data_head - senscol_data_tail) %
+			SENSCOL_DATA_BUF_SIZE <= sensor->sample_size) {
+		spin_unlock_irqrestore(&senscol_data_lock, flags);
+		return	-ENOMEM;
+	}
+
+	p_sample->id = id;
+	p_sample->size = sensor->sample_size;
+	memcpy(p_sample->data, sample,
+		sensor->sample_size - offsetof(struct senscol_sample, data));
+
+	memcpy(senscol_data_buf + senscol_data_tail, p_sample, p_sample->size);
+	senscol_data_tail += sensor->sample_size;
+	if (senscol_data_tail > SENSCOL_DATA_BUF_LAST)
+		senscol_data_tail = 0;
+
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	/* Fire event through "data/event" */
+
+	if (waitqueue_active(&senscol_read_wait))
+		wake_up_interruptible(&senscol_read_wait);
+
+	return	0;
+}
+
+static int senscol_open_legacy(struct inode *inode, struct file *file)
+{
+	user_task = current;
+	return	0;
+}
+
+static int senscol_release_legacy(struct inode *inode, struct file *file)
+{
+	return	0;
+}
+
+static ssize_t senscol_read_legacy(struct file *file, char __user *ubuf,
+	size_t length, loff_t *offset)
+{
+	return	length;
+}
+
+static ssize_t senscol_write_legacy(struct file *file, const char __user *ubuf,
+	size_t length, loff_t *offset)
+{
+	return	length;
+}
+
+static long senscol_ioctl_legacy(struct file *file, unsigned int cmd,
+	unsigned long data)
+{
+	return	0;
+}
+
+static unsigned int senscol_poll_legacy(struct file *file, poll_table *wait)
+{
+	unsigned int mask = 0;
+	unsigned long	flags;
+	int	rd_ready = 0;
+
+	poll_wait(file, &senscol_read_wait, wait);
+
+	spin_lock_irqsave(&senscol_data_lock, flags);
+	rd_ready = (senscol_data_head != senscol_data_tail);
+	spin_unlock_irqrestore(&senscol_data_lock, flags);
+
+	if (rd_ready)
+		mask |= (POLLIN | POLLRDNORM);
+	return	mask;
+}
+
+/* flush callback */
+void senscol_flush_cb_legacy(unsigned sens_id)
+{
+	struct sensor_def	*sens, *next;
+	unsigned long	flags;
+	uint32_t pseudo_event_id;
+	uint32_t pseudo_event_content = 0;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	if (!flush_asked) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return;
+	}
+
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->flush_req) {
+			sens->flush_req = 0;
+			pseudo_event_id = sens->id | PSEUSO_EVENT_BIT;
+			pseudo_event_content |= FLUSH_CMPL_BIT;
+
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			push_sample_legacy(pseudo_event_id,
+				&pseudo_event_content);
+			spin_lock_irqsave(&senscol_lock, flags);
+		}
+	}
+	flush_asked = 0;
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return;
+}
+
+static const struct file_operations senscol_fops_legacy = {
+	.owner = THIS_MODULE,
+	.read = senscol_read_legacy,
+	.unlocked_ioctl = senscol_ioctl_legacy,
+	.open = senscol_open_legacy,
+	.release = senscol_release_legacy,
+	.write = senscol_write_legacy,
+	.poll = senscol_poll_legacy,
+	.llseek = no_llseek
+};
+
+/*
+ * Misc Device Struct
+ */
+static struct miscdevice senscol_misc_device_legacy = {
+		.name = "sensor-collection",
+		.fops = &senscol_fops_legacy,
+		.minor = MISC_DYNAMIC_MINOR,
+};
+
+int senscol_init_legacy(void)
+{
+	int	rv;
+
+	INIT_LIST_HEAD(&senscol_sensors_list);
+	spin_lock_init(&senscol_lock);
+	spin_lock_init(&senscol_data_lock);
+	init_waitqueue_head(&senscol_read_wait);
+
+	/* Init data buffer */
+	senscol_data_buf = kmalloc(SENSCOL_DATA_BUF_SIZE, GFP_KERNEL);
+	if (!senscol_data_buf)
+		return -ENOMEM;
+
+	senscol_data_head = 0;
+	senscol_data_tail = 0;
+
+	/* Create sensor_collection platform device and default sysfs entries */
+	sc_pdev = platform_device_register_simple("sensor_collection", -1,
+		NULL, 0);
+	if (IS_ERR(sc_pdev)) {
+		kfree(senscol_data_buf);
+		return -ENODEV;
+	}
+
+	senscol_misc_device_legacy.parent = &sc_pdev->dev;
+	rv = misc_register(&senscol_misc_device_legacy);
+	if (rv)
+		return	rv;
+
+	rv = kobject_init_and_add(&sc_data_kobj, &sc_data_kobj_type,
+		&sc_pdev->dev.kobj, "data");
+
+	rv = sysfs_create_bin_file(&sc_data_kobj, &sensors_data_binattr);
+	if (rv)
+		return rv;
+
+	return	0;
+}
+
+void senscol_exit_legacy(void)
+{
+	kfree(senscol_data_buf);
+}
+#endif /* SENSCOL_1 */
diff --git a/drivers/misc/intel-ish/senscol-core.c b/drivers/misc/intel-ish/senscol-core.c
index 00582bf4..c2f0099 100644
--- a/drivers/misc/intel-ish/senscol-core.c
+++ b/drivers/misc/intel-ish/senscol-core.c
@@ -1,7 +1,7 @@
 /*
- * Sensor collection framework core
+ * Sensor collection interface
  *
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,1069 +9,1065 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
-#include <linux/module.h>
 #include <linux/senscol/senscol-core.h>
+
+#if !SENSCOL_1
+
+#include <linux/module.h>
 #include <linux/platform_device.h>
-#include <linux/kobject.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
-#include "hid-strings-def.h"
-#include "platform-config.h"
+#include <linux/sched.h>
 #include <linux/miscdevice.h>
 #include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
+#include <linux/compat.h>
 #include "ishtp-hid.h"
 
-struct list_head	senscol_impl_list;
-struct list_head	senscol_sensors_list;
-spinlock_t	senscol_lock;
-spinlock_t	senscol_data_lock;
-uint8_t	*senscol_data_buf;
-unsigned	senscol_data_head, senscol_data_tail;
-int	flush_asked = 0;
-struct task_struct *user_task;
-
-static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
-	char *buf);
-
-static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size);
+int sensor_num = 0;
 
-static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
+struct list_head	fds_list;
+spinlock_t	fds_list_lock;
 
-static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size);
-
-static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
-	char *buf);
-
-static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size);
-
-static struct platform_device	*sc_pdev;
-
-wait_queue_head_t senscol_read_wait;
+int sens_prop_to_usage(struct sensor_def *sensor, const char *prop_name)
+{
+	int i;
+	for (i = 0; i < sensor->num_properties; i++)
+		if (strcmp(sensor->properties[i].name, prop_name) == 0)
+			return sensor->properties[i].usage_id;
+	return 0;
+}
 
 void senscol_send_ready_event(void)
 {
-	if (waitqueue_active(&senscol_read_wait))
-		wake_up_interruptible(&senscol_read_wait);
+	struct using_fd *fd, *next;
+	unsigned long flags;
+
+	spin_lock_irqsave(&fds_list_lock, flags);
+	list_for_each_entry_safe(fd, next, &fds_list, link) {
+		if (waitqueue_active(&fd->read_wait))
+			wake_up_interruptible(&fd->read_wait);
+	}
+	spin_unlock_irqrestore(&fds_list_lock, flags);
 }
-EXPORT_SYMBOL(senscol_send_ready_event);
 
 int senscol_reset_notify(void)
 {
-
+	struct using_fd *fd, *next;
 	struct siginfo si;
-	int ret;
+	unsigned long flags;
 
 	memset(&si, 0, sizeof(struct siginfo));
 	si.si_signo = SIGUSR1;
 	si.si_code = SI_USER;
 
-	if (user_task == NULL)
-		return -EINVAL;
+	spin_lock_irqsave(&fds_list_lock, flags);
+	list_for_each_entry_safe(fd, next, &fds_list, link) {
+		if (fd->user_task)
+			send_sig_info(SIGUSR1, &si, fd->user_task);
+	}
+	spin_unlock_irqrestore(&fds_list_lock, flags);
 
-	ret = send_sig_info(SIGUSR1, &si, user_task);
-	return ret;
+	return 0;
 }
-EXPORT_SYMBOL(senscol_reset_notify);
 
-const char *senscol_usage_to_name(unsigned usage)
+int add_set_list_property(struct sensor_def *sensor,
+		struct list_head *set_prop_list, const char *prop_name,
+		const char *value)
 {
-	int i;
-
-	for (i = 0; code_msg_arr[i].msg && code_msg_arr[i].code != usage; i++)
-		;
-	return	code_msg_arr[i].msg;
-}
-EXPORT_SYMBOL(senscol_usage_to_name);
+	struct sens_property *temp;
+	uint32_t hid_usage_id = sens_prop_to_usage(sensor, prop_name);
 
+	if (!hid_usage_id)
+		return -EINVAL;
 
-unsigned senscol_name_to_usage(const char *name)
-{
-	int i;
+	temp = kmalloc(sizeof(struct sens_property), GFP_KERNEL);
 
-	for (i = 0; code_msg_arr[i].msg &&
-			strcmp(code_msg_arr[i].msg, name) != 0; ++i)
-		;
-	return	code_msg_arr[i].code;
+	if (!temp)
+		return -ENOMEM;
+
+	temp->usage_id = hid_usage_id;
+	temp->name = kasprintf(GFP_KERNEL, "%s", prop_name);
+	temp->value = kasprintf(GFP_KERNEL, "%s", value);
+	temp->sensor = sensor;
+	list_add_tail(&temp->link, set_prop_list);
+	return 0;
 }
-EXPORT_SYMBOL(senscol_name_to_usage);
 
-
-const char	*senscol_get_modifier(unsigned modif)
+int remove_set_list_properties(struct list_head *set_props_list)
 {
-	uint32_t to4bits = modif >> 0xC;
-	return	modifiers[to4bits];
-}
-EXPORT_SYMBOL(senscol_get_modifier);
+	struct sens_property *prop, *next;
 
+	list_for_each_entry_safe(prop, next, set_props_list, link) {
+		list_del(&prop->link);
 
-
-#if 0
-/*
- * data kobject attributes and handlers
- */
-
-static struct attribute	sc_data_defattr_event = {
-	.name = "event",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute	*sc_data_defattrs[] = {
-	&sc_data_defattr_event,
-	NULL
-};
-#endif
-
-static void	sc_data_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+		kfree(prop->name);
+		kfree(prop->value);
+		kfree(prop);
+	}
+	return 0;
 }
 
-static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
+/* Init sensor (don't call for initialized sensors) */
+void init_senscol_sensor(struct sensor_def *sensor)
 {
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	scnprintf(buf, PAGE_SIZE, "%s\n", attr->name);
-	return	strlen(buf);
+	if (!sensor)
+		return;
+	memset(sensor, 0, sizeof(*sensor));
+	sensor->name = NULL;
+	sensor->friendly_name = NULL;
+	sensor->impl = NULL;
+	sensor->data_fields = NULL;
+	sensor->properties = NULL;
+	sensor->acquire_fd = NULL;
+	sensor->ask_flush_count = 0;
+	sensor->sens_in_use = 0;
+	init_waitqueue_head(&sensor->wait_sens_free);
 }
 
-static ssize_t	sc_data_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
+/* return pointer to sensor if exists in fd sensors list, NULL otherwise */
+struct sensor_def *get_sensor_from_fd_list(struct using_fd *cur_fd, uint32_t id)
 {
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__,
-		attr->name, buf, (unsigned)size);
-	return	size;
-}
-
-const struct sysfs_ops	sc_data_sysfs_fops = {
-	.show = sc_data_show,
-	.store = sc_data_store
-};
-
-struct kobj_type	sc_data_kobj_type = {
-	.release = sc_data_release,
-	.sysfs_ops = &sc_data_sysfs_fops
-	/*.default_attrs = sc_data_defattrs*/
-};
+	struct sens_link *sensor_link, *next;
 
-struct bin_attribute	sensors_data_binattr = {
-	.attr = {
-		.name = "sensors_data",
-		.mode = S_IRUGO
-	},
-	.size = 0,
-	.read = sensors_data_read,
-	.write = sensors_data_write
-};
-
-struct kobject	sc_data_kobj;
-
-/*****************************************/
-
-
-/*
- * sensor_def kobject type and handlers
- */
-static struct attribute	sc_sensdef_defattr_name = {
-	.name = "name",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_sensdef_defattr_id = {
-	.name = "id",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_sensdef_defattr_usage_id = {
-	.name = "usage_id",
-	.mode = (S_IRUGO)
-};
+	list_for_each_entry_safe(sensor_link, next, &cur_fd->sensors_list,
+			link) {
+		if (sensor_link->sensor->id == id)
+			return sensor_link->sensor;
+	}
+	return NULL;
+}
 
-static struct attribute sc_sensdef_defattr_sample_size = {
-	.name = "sample_size",
-	.mode = (S_IRUGO)
-};
+int remove_senscol_sensor(uint32_t id)
+{
+	unsigned long	flags;
+	struct sensor_def	*sens, *next;
+	struct sens_link *sensor_link, *next_sens_link;
+	struct using_fd *cur_fd;
+	int i;
 
-static struct attribute sc_sensdef_defattr_flush = {
-	.name = "flush",
-	.mode = (S_IRUGO)
-};
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->id == id) {
+			/* mark the sensor as "in use" */
+			if (sens->sens_in_use) {
+				/* the sensor is currently in use,
+					wait for it to be free */
+				spin_unlock_irqrestore(&senscol_lock, flags);
+				wait_event(sens->wait_sens_free,
+					(!sens->sens_in_use));
+				spin_lock_irqsave(&senscol_lock, flags);
+			}
+			sens->sens_in_use = 1;
+
+			/* remove sensor from the fd using it */
+			if (sens->acquire_fd) {
+				cur_fd = sens->acquire_fd;
+				list_for_each_entry_safe(sensor_link,
+						next_sens_link,
+						&cur_fd->sensors_list, link) {
+					if (sensor_link->sensor == sens) {
+						list_del(&sensor_link->link);
+						kfree(sensor_link);
+					}
+				}
+			}
 
-static struct attribute sc_sensdef_defattr_get_sample = {
-	.name = "get_sample",
-	.mode = (S_IRUGO)
-};
+			list_del(&sens->link);
+			sensor_num--;
 
-struct attribute	*sc_sensdef_defattrs[] = {
-	&sc_sensdef_defattr_name,
-	&sc_sensdef_defattr_id,
-	&sc_sensdef_defattr_usage_id,
-	&sc_sensdef_defattr_sample_size,
-	&sc_sensdef_defattr_flush,
-	&sc_sensdef_defattr_get_sample,
-	NULL
-};
+			/*
+			 * senscol_lock protects sensors list
+			 * of each fd as well
+			 */
+			spin_unlock_irqrestore(&senscol_lock, flags);
 
-static void	sc_sensdef_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
+			/* remove sens props */
+			for (i = 0; i < sens->num_properties; ++i) {
+				kfree(sens->properties[i].name);
+				kfree(sens->properties[i].value);
+			}
+			kfree(sens->properties);
 
-static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	ssize_t	rv;
-	struct sensor_def	*sensdef;
-	static char    tmp_buf[0x1000];
-	unsigned long flags;
+			/* remove sens data fields */
+			for (i = 0; i < sens->num_data_fields; ++i)
+				kfree(sens->data_fields[i].name);
+			kfree(sens->data_fields);
+			kfree(sens->name);
+			kfree(sens);
 
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	sensdef = container_of(kobj, struct sensor_def, kobj);
-	buf[0] = '\0';
-	if (!strcmp(attr->name, "id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->id);
-	else if (!strcmp(attr->name, "sample_size"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", sensdef->sample_size);
-	else if (!strcmp(attr->name, "usage_id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", sensdef->usage_id);
-	else if (!strcmp(attr->name, "name"))
-		scnprintf(buf, PAGE_SIZE, "%s\n", sensdef->name);
-	else if (!strcmp(attr->name, "flush"))
-		/*if "sensdef" is activated in batch mode,
-		mark it as asking flush*/
-		if (sensdef->impl->batch_check(sensdef)) {
-			spin_lock_irqsave(&senscol_lock, flags);
-			flush_asked = 1;
-			sensdef->flush_req = 1;
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			sensdef->impl->get_sens_property(sensdef,
-				sensdef->properties, tmp_buf, 0x1000);
-			scnprintf(buf, PAGE_SIZE, "1\n");
-		} else {
-			uint32_t pseudo_event_id =
-				sensdef->id | PSEUSO_EVENT_BIT;
-			uint32_t pseudo_event_content = 0;
-			pseudo_event_content |= FLUSH_CMPL_BIT;
-			push_sample(pseudo_event_id, &pseudo_event_content);
-			scnprintf(buf, PAGE_SIZE, "0\n");
+			return 0;
 		}
-	else if (!strcmp(attr->name, "get_sample")) {
-		rv = sensdef->impl->get_sample(sensdef);
-		/* The sample will arrive to hid "raw event" func,
-		and will be pushed to user via "push_sample" method */
-
-		scnprintf(buf, PAGE_SIZE, "%d\n", !rv);
 	}
-	rv = strlen(buf) + 1;
-	return	rv;
-}
-
-static ssize_t	sc_sensdef_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
+	/* the sensor to remove was not found */
+	spin_unlock_irqrestore(&senscol_lock, flags);
+	return -EINVAL;
 }
-const struct sysfs_ops	sc_sensdef_sysfs_fops = {
-	.show = sc_sensdef_show,
-	.store = sc_sensdef_store
-};
-
-struct kobj_type	sc_sensdef_kobj_type = {
-	.release = sc_sensdef_release,
-	.sysfs_ops = &sc_sensdef_sysfs_fops,
-	.default_attrs = sc_sensdef_defattrs
-};
-/*****************************************/
 
 /*
- * kobject type for empty sub-directories
+ * The caller is responsible for setting all meaningful fields
+ * (may call add_data_field() and add_sens_property() as needed)
+ * We'll consider hiding senscol framework-specific fields
+ * into opaque structures
  */
-static struct attribute	*sc_subdir_defattrs[] = {
-	NULL
-};
-
-static void	sc_subdir_release(struct kobject *k)
+int add_senscol_sensor(struct sensor_def *sensor)
 {
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
+	unsigned long	flags;
+	int	i;
 
-static ssize_t	sc_subdir_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
-}
+	if (!sensor->name || !sensor->impl || !sensor->usage_id || !sensor->id)
+		return	-EINVAL;
 
-static ssize_t	sc_subdir_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
-}
+	/* Sample size should be set by the caller to size of raw data */
+	sensor->sample_size += offsetof(struct senscol_sample, data);
+	/* Mark index of data_field */
+	for (i = 0; i < sensor->num_data_fields; ++i)
+		if (sensor->data_fields[i].name)
+			sensor->data_fields[i].index = i;
 
-const struct sysfs_ops	sc_subdir_sysfs_fops = {
-	.show = sc_subdir_show,
-	.store = sc_subdir_store
-};
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_add_tail(&sensor->link, &senscol_sensors_list);
+	sensor_num++;
+	spin_unlock_irqrestore(&senscol_lock, flags);
 
-struct kobj_type	sc_subdir_kobj_type = {
-	.release = sc_subdir_release,
-	.sysfs_ops = &sc_subdir_sysfs_fops,
-	.default_attrs = sc_subdir_defattrs
-};
-/*****************************************/
+	return 0;
+}
 
 /*
- * sensors 'data_field's kobject type
+ * Push data sample in upstream buffer towards user-mode.
+ * Sample's size is determined from the structure
+ *
+ * Samples are queued is a simple FIFO binary buffer with head and tail
+ * pointers (buffer per opened fd).
+ * Additional fields if wanted to be communicated to user mode can be defined
+ *
+ * Returns 0 on success, negative error code on error
  */
-static struct attribute	sc_datafield_defattr_usage_id = {
-	.name = "usage_id",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute	sc_datafield_defattr_exp = {
-	.name = "exponent",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_datafield_defattr_len = {
-	.name = "length",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_datafield_defattr_unit = {
-	.name = "unit",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute sc_datafield_defattr_index = {
-	.name = "index",
-	.mode = (S_IRUGO)
-};
-
-static struct attribute	sc_datafield_defattr_is_numeric = {
-	.name = "is_numeric",
-	.mode = (S_IRUGO)
-};
-
-struct attribute	*sc_datafield_defattrs[] = {
-	&sc_datafield_defattr_usage_id,
-	&sc_datafield_defattr_exp,
-	&sc_datafield_defattr_len,
-	&sc_datafield_defattr_unit,
-	&sc_datafield_defattr_index,
-	&sc_datafield_defattr_is_numeric,
-	NULL
-};
-
-static void	sc_datafield_release(struct kobject *k)
+int push_sample(uint32_t id, void *sample)
 {
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-}
-
-static ssize_t	sc_datafield_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
-{
-	ssize_t	rv;
-	struct data_field	*dfield;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	dfield = container_of(kobj, struct data_field, kobj);
-	if (!strcmp(attr->name, "usage_id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", (unsigned)dfield->usage_id);
-	else if (!strcmp(attr->name, "exponent"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->exp);
-	else if (!strcmp(attr->name, "length"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->len);
-	else if (!strcmp(attr->name, "unit"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->unit);
-	else if (!strcmp(attr->name, "index"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->index);
-	else if (!strcmp(attr->name, "is_numeric"))
-		scnprintf(buf, PAGE_SIZE, "%u\n", (unsigned)dfield->is_numeric);
-
-	rv = strlen(buf) + 1;
-	return	rv;
-}
+	struct using_fd	*cur_fd;
+	unsigned long	flags, buf_flags, fd_flags;
+	unsigned char	*sample_buf;
+	struct senscol_sample	*p_sample;
+	struct sensor_def	*sensor;
+	int	ret = 0;
 
-static ssize_t	sc_datafield_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
-{
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n", __func__,
-		attr->name, buf, (unsigned)size);
-	return	-EINVAL;
-}
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor = get_senscol_sensor_by_id(id);
+	if (!sensor) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return	-ENODEV;
+	}
 
-const struct sysfs_ops	sc_datafield_sysfs_fops = {
-	.show = sc_datafield_show,
-	.store = sc_datafield_store
-};
+	sample_buf = kmalloc(sensor->sample_size, GFP_ATOMIC);
+	if (!sample_buf) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -ENOMEM;
+	}
+	p_sample = (struct senscol_sample *)sample_buf;
 
-struct kobj_type	sc_datafield_kobj_type = {
-	.release = sc_datafield_release,
-	.sysfs_ops = &sc_datafield_sysfs_fops,
-	.default_attrs = sc_datafield_defattrs
-};
-/*****************************************/
+	p_sample->id = id;
+	p_sample->size = sensor->sample_size;
+	memcpy(p_sample->data, sample,
+		sensor->sample_size - offsetof(struct senscol_sample, data));
 
+	/* When buffer overflows the new data is dropped */
+	if (sensor->acquire_fd) {
+		cur_fd = sensor->acquire_fd;
 
-/*
- * sensors 'properties' kobject type
- */
-/*
-static struct attribute	sc_sensprop_defattr_unit = {
-	.name = "unit",
-	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
-};
-*/
-static struct attribute sc_sensprop_defattr_value = {
-	.name = "value",
-	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
-};
+		spin_lock_irqsave(&fds_list_lock, fd_flags);
+		if (cur_fd->fd_used_cnt == FD_BEING_REMOVED) {
+			/* the fd is in remove process */
+			spin_unlock_irqrestore(&fds_list_lock, fd_flags);
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return -EINVAL;
+		} else
+			cur_fd->fd_used_cnt++; /* increase fd in-use cnt.
+						other usages than release fd
+						won't block each other */
+		spin_unlock_irqrestore(&fds_list_lock, fd_flags);
+		spin_unlock_irqrestore(&senscol_lock, flags);
 
-static struct attribute sc_sensprop_defattr_usage_id = {
-	.name = "usage_id",
-	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
-};
+		if (!cur_fd->data_buf) {
+			ret = -EINVAL;
+			goto free_fd;
+		}
 
-struct attribute	*sc_sensprop_defattrs[] = {
-/*	&sc_sensprop_defattr_unit,*/
-	&sc_sensprop_defattr_value,
-	&sc_sensprop_defattr_usage_id,
-	NULL
-};
+		/* buffer is OK. copy data */
+		spin_lock_irqsave(&cur_fd->buf_lock, buf_flags);
+		if (cur_fd->head != cur_fd->tail &&
+				(cur_fd->head - cur_fd->tail) %
+				SENSCOL_DATA_BUF_SIZE <= p_sample->size) {
+			/* drop sample */
+			spin_unlock_irqrestore(&cur_fd->buf_lock, buf_flags);
+		} else {
+			memcpy(cur_fd->data_buf + cur_fd->tail, p_sample,
+				p_sample->size);
+			cur_fd->tail += p_sample->size;
+			if (cur_fd->tail > SENSCOL_DATA_BUF_LAST)
+				cur_fd->tail = 0;
+			if (waitqueue_active(&cur_fd->read_wait))
+				wake_up_interruptible(&cur_fd->read_wait);
+			spin_unlock_irqrestore(&cur_fd->buf_lock, buf_flags);
+		}
+	} else {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return 0;
+	}
+free_fd:
+	spin_lock_irqsave(&fds_list_lock, fd_flags);
+	cur_fd->fd_used_cnt--;
+	if (!cur_fd->fd_used_cnt && waitqueue_active(&cur_fd->wait_fd_free))
+		wake_up_interruptible(&cur_fd->wait_fd_free);
+	spin_unlock_irqrestore(&fds_list_lock, fd_flags);
 
-static void	sc_sensprop_release(struct kobject *k)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
+	return ret;
 }
 
-static ssize_t	sc_sensprop_show(struct kobject *kobj, struct attribute *attr,
-	char *buf)
+static int senscol_open(struct inode *inode, struct file *file)
 {
-	struct sens_property	*pfield;
-	struct sensor_def	*sensor;
-	int	rv = -EINVAL;
+	unsigned long flags;
+	struct using_fd *cur_fd = kmalloc(sizeof(struct using_fd), GFP_KERNEL);
+	if (!cur_fd)
+		return -ENOMEM;
+
+	cur_fd->user_task = current;/* save task to send reset notify */
+	cur_fd->data_buf = NULL;
+	cur_fd->head = 0;
+	cur_fd->tail = 0;
+	cur_fd->fd_used_cnt = 0;
+	INIT_LIST_HEAD(&cur_fd->sensors_list);
+	spin_lock_init(&cur_fd->buf_lock);
+	init_waitqueue_head(&cur_fd->read_wait);
+	init_waitqueue_head(&cur_fd->wait_fd_free);
+
+	file->private_data = cur_fd;
+
+	spin_lock_irqsave(&fds_list_lock, flags);
+	list_add_tail(&cur_fd->link, &fds_list);
+	spin_unlock_irqrestore(&fds_list_lock, flags);
 
-	/*
-	 * We need "property_power_state" (=2), "property_reporting_state" (=2)
-	 * and "property_report_interval" (in ms?)
-	 */
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): +++ attr='%s'\n",
-		__func__, attr->name);
-	pfield = container_of(kobj, struct sens_property, kobj);
-	sensor = pfield->sensor;
-
-	if (!strcmp(attr->name, "value"))
-		rv = sensor->impl->get_sens_property(sensor, pfield, buf,
-			0x1000);
-	else if (!strcmp(attr->name, "usage_id"))
-		scnprintf(buf, PAGE_SIZE, "%08X\n", pfield->usage_id & 0xFFFF);
-	if (rv)
-		return	rv;
-	return	strlen(buf);
+	return	0;
 }
 
-static ssize_t	sc_sensprop_store(struct kobject *kobj, struct attribute *attr,
-	const char *buf, size_t size)
+static int senscol_release(struct inode *inode, struct file *file)
 {
-	struct sens_property	*pfield;
-	struct sensor_def	*sensor;
-	int	rv;
+	struct using_fd *cur_fd = file->private_data;
+	struct sensor_def *sensor;
+	struct sens_link *sensor_link, *next;
+	unsigned long	flags, sens_flags;
 
 	/*
-	 * TODO: stream down set property request and return size
-	 * upon successful completion or error code
+	 * No need to mark fd as in used in all fd functions (ioctl, read
+	 * and write), because POSIX avoid them from being called in parallel
+	 * to the release function.
+	 * the fd_used_cnt is used to avoid race condition between the
+	 * release function and the push_sample or flush callback.
 	 */
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n",
-		__func__, attr->name, buf, (unsigned)size);
-	if (strcmp(attr->name, "value"))
-		return -EINVAL;
 
-	pfield = container_of(kobj, struct sens_property, kobj);
-	sensor = pfield->sensor;
-	rv = sensor->impl->set_sens_property(sensor, pfield, buf);
-
-	if (rv)
-		return	rv;
-	return	size;
-}
+	spin_lock_irqsave(&fds_list_lock, flags);
+	/* mark the fd as "in use" */
+	if (cur_fd->fd_used_cnt) {
+		/* the fd is currently in use, wait for it to be free */
+		spin_unlock_irqrestore(&fds_list_lock, flags);
+		wait_event(cur_fd->wait_fd_free,
+			(!cur_fd->fd_used_cnt));
+		spin_lock_irqsave(&fds_list_lock, flags);
+	}
+	cur_fd->fd_used_cnt = FD_BEING_REMOVED; /* mark fd in remove process */
+	list_del(&cur_fd->link);
+	spin_unlock_irqrestore(&fds_list_lock, flags);
+
+	spin_lock_irqsave(&senscol_lock, sens_flags);
+	list_for_each_entry_safe(sensor_link, next, &cur_fd->sensors_list,
+			link) {
+		sensor = sensor_link->sensor;
+		/* mark the sensor as "in use" */
+		if (sensor->sens_in_use) {
+			/*
+			 * the sensor is currently in use, wait for it to be
+			 * free. it is NOT at the middle of being removed,
+			 * because it is still in the fd sensors list.
+			 */
+			spin_unlock_irqrestore(&senscol_lock, sens_flags);
+			wait_event(sensor->wait_sens_free,
+				(!sensor->sens_in_use));
+			spin_lock_irqsave(&senscol_lock, sens_flags);
+		}
+		sensor->sens_in_use = 1;
+		sensor->acquire_fd = NULL;
+		list_del(&sensor_link->link);
+		kfree(sensor_link);
+		spin_unlock_irqrestore(&senscol_lock, sens_flags);
+
+		sensor->impl->disable_sensor(sensor);
+
+		spin_lock_irqsave(&senscol_lock, sens_flags);
+		sensor->ask_flush_count = 0;
+		sensor->sens_in_use = 0;
+		if (waitqueue_active(&sensor->wait_sens_free))
+			wake_up_interruptible(&sensor->wait_sens_free);
+	}
+	spin_unlock_irqrestore(&senscol_lock, sens_flags);
 
-const struct sysfs_ops	sc_sensprop_sysfs_fops = {
-	.show = sc_sensprop_show,
-	.store = sc_sensprop_store
-};
+	kfree(cur_fd->data_buf);
+	kfree(cur_fd);
 
-struct kobj_type	sc_sensprop_kobj_type = {
-	.release = sc_sensprop_release,
-	.sysfs_ops = &sc_sensprop_sysfs_fops,
-	.default_attrs = sc_sensprop_defattrs
-};
-/*****************************************/
+	file->private_data = NULL;
+	return	0;
+}
 
-static ssize_t	sensors_data_read(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+static ssize_t senscol_read(struct file *file, char __user *ubuf,
+	size_t length, loff_t *offset)
 {
 	size_t	count;
 	unsigned	cur;
 	struct senscol_sample	*sample;
 	unsigned long	flags;
+	struct using_fd *cur_fd = file->private_data;
+	char *tmp_buf = kzalloc(length, GFP_KERNEL);
+	if (!tmp_buf)
+		return -ENOMEM;
 
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-
-	if (size > PAGE_SIZE)
-		size = PAGE_SIZE;
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): >>> offs=%u size=%u senscol_data_head=%u senscol_data_tail=%u\n",
-		__func__, (unsigned)offs, (unsigned)size,
-		(unsigned)senscol_data_head, (unsigned)senscol_data_tail);
-
-	spin_lock_irqsave(&senscol_data_lock, flags);
-
+	spin_lock_irqsave(&cur_fd->buf_lock, flags);
 	/*
 	 * Count how much we may copy, keeping whole samples.
 	 * Copy samples along the way
 	 */
 	count = 0;
-	cur = senscol_data_head;
-	while (cur != senscol_data_tail) {
-		sample = (struct senscol_sample *)(senscol_data_buf + cur);
-		if (count + sample->size > size)
+	cur = cur_fd->head;
+	while (cur != cur_fd->tail) {
+		sample = (struct senscol_sample *)(cur_fd->data_buf + cur);
+		if (count + sample->size > length)
 			break;
-		memcpy(buf + count, sample, sample->size);
+		memcpy(tmp_buf + count, sample, sample->size);
 		count += sample->size;
 		cur += sample->size;
 		if (cur > SENSCOL_DATA_BUF_LAST)
 			cur = 0;
 	}
-	senscol_data_head = cur;
+	cur_fd->head = cur;
+	spin_unlock_irqrestore(&cur_fd->buf_lock, flags);
 
-	spin_unlock_irqrestore(&senscol_data_lock, flags);
-
-	if (count) {
-		ISH_DBG_PRINT(KERN_ALERT
-			"[senscol]: <<< %s(): senscol_data_head=%u senscol_data_tail=%u\n",
-			__func__, senscol_data_head, senscol_data_tail);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[senscol]: %s(): returning count=%u\n", __func__,
-			(unsigned)count);
+	if (copy_to_user(ubuf, tmp_buf, count)) {
+		kfree(tmp_buf);
+		return -EINVAL;
 	}
-
-	return	count;
+	kfree(tmp_buf);
+	return count;
 }
 
-static ssize_t	sensors_data_write(struct file *f, struct kobject *kobj,
-	struct bin_attribute *bin_attr, char *buf, loff_t offs, size_t size)
+static ssize_t senscol_write(struct file *file, const char __user *ubuf,
+	size_t length, loff_t *offset)
 {
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	return	-EINVAL;
+	return	length;
 }
 
-int	add_senscol_impl(struct senscol_impl *impl)
+/* IOCTL functions */
+static long ioctl_get_sens_num(unsigned long param)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_add_tail(&impl->link, &senscol_impl_list);
-	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	0;
+	if (copy_to_user((char __user *)param, &sensor_num, sizeof(int)))
+		return -EFAULT;
+	return 0;
 }
-EXPORT_SYMBOL(add_senscol_impl);
 
-int	remove_senscol_impl(struct senscol_impl *impl)
+static long ioctl_get_sens_list(unsigned long param, int compat_called)
 {
-	unsigned long flags;
-
+	struct sensor_def *sensor, *next;
+	struct ioctl_res ioctl_result;
+	struct sensor_details sens_details;
+	char *tmp_buf;
+	unsigned long	flags;
+	int buf_off = 0;
+	int ret = 0;
+
+	if (copy_from_user(&ioctl_result, (char __user *)param,
+			sizeof(struct ioctl_res)))
+		return -EFAULT;
+	ioctl_result.response_size = sensor_num * sizeof(struct sensor_details);
+	/* write back to user, with response_size filled */
+	if (copy_to_user((char __user *)param, &ioctl_result,
+			sizeof(struct ioctl_res)))
+		return -EFAULT;
+	if (ioctl_result.buffer_size < ioctl_result.response_size)
+		return -ENOMEM;
+	if (!ioctl_result.buffer_ptr)
+		return -EINVAL;
+	tmp_buf = kmalloc(ioctl_result.response_size, GFP_KERNEL);
+	if (!tmp_buf)
+		return -ENOMEM;
+
+#ifdef CONFIG_COMPAT
+	if (compat_called)
+		ioctl_result.buffer_ptr =
+			(uint64_t)compat_ptr(ioctl_result.buffer_ptr);
+#endif
 	spin_lock_irqsave(&senscol_lock, flags);
-	list_del(&impl->link);
+	list_for_each_entry_safe(sensor, next, &senscol_sensors_list, link) {
+		if (ioctl_result.buffer_size - buf_off <
+				sizeof(struct sensor_details)) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			ret = -ENOMEM;
+			goto out;
+		}
+		sens_details.id = sensor->id;
+		sens_details.usage_id = sensor->usage_id;
+		sens_details.sample_size = sensor->sample_size;
+		sens_details.properties_num = sensor->num_properties;
+		sens_details.data_fields_num = sensor->num_data_fields;
+		strncpy(sens_details.name, sensor->name, MAX_NAME_LENGTH);
+		memcpy(tmp_buf + buf_off, &sens_details,
+				sizeof(struct sensor_details));
+		buf_off += sizeof(struct sensor_details);
+	}
 	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	0;
-}
-EXPORT_SYMBOL(remove_senscol_impl);
-
-/* Only allocates new sensor */
-struct sensor_def *alloc_senscol_sensor(void)
-{
-	struct sensor_def *sens;
-
-	sens = kzalloc(sizeof(struct sensor_def), GFP_KERNEL);
-	return	sens;
-}
-EXPORT_SYMBOL(alloc_senscol_sensor);
-
-/* Init sensor (don't call for initialized sensors */
-void	init_senscol_sensor(struct sensor_def *sensor)
-{
-	if (!sensor)
-		return;
+	if (buf_off != ioctl_result.response_size) {
+		ret = -EFAULT;
+		goto out;
+	}
 
-	memset(sensor, 0, sizeof(*sensor));
-	sensor->name = NULL;
-	sensor->friendly_name = NULL;
-	sensor->impl = NULL;
-	sensor->data_fields = NULL;
-	sensor->properties = NULL;
+	if (copy_to_user((char __user *)ioctl_result.buffer_ptr, tmp_buf,
+			buf_off)) {
+		ret = -EFAULT;
+		goto out;
+	}
+out:
+	kfree(tmp_buf);
+	return ret;
 }
-EXPORT_SYMBOL(init_senscol_sensor);
 
-int remove_senscol_sensor(uint32_t id)
+static long ioctl_get_prop(unsigned long param, int compat_called)
 {
+	struct sensor_def *sensor;
+	struct ioctl_res ioctl_result;
+	struct property_details prop_details;
+	int buf_off = 0;
 	unsigned long	flags;
-	struct sensor_def	*sens, *next;
-	int i;
+	int i, ret = 0;
 
+	if (copy_from_user(&ioctl_result, (char __user *)param,
+			sizeof(struct ioctl_res)))
+		return -EFAULT;
 	spin_lock_irqsave(&senscol_lock, flags);
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (sens->id == id) {
-			list_del(&sens->link);
-			spin_unlock_irqrestore(&senscol_lock, flags);
+	sensor = get_senscol_sensor_by_id(ioctl_result.sens_id);
+	if (!sensor) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EINVAL;
+	}
+	/* mark sensor as in-use */
+	if (sensor->sens_in_use) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EBUSY;
+	}
+	sensor->sens_in_use = 1;
+	spin_unlock_irqrestore(&senscol_lock, flags);
 
-			for (i = 0; i < sens->num_properties; ++i)
-				if (sens->properties[i].name) {
-					kobject_put(&sens->properties[i].kobj);
-					kobject_del(&sens->properties[i].kobj);
-				}
-			kfree(sens->properties);
-			kobject_put(&sens->props_kobj);
-			kobject_del(&sens->props_kobj);
+	ioctl_result.response_size = sensor->num_properties *
+		sizeof(struct property_details);
+	/* write back to user, with response_size filled */
+	if (copy_to_user((char __user *)param, &ioctl_result,
+			sizeof(struct ioctl_res))) {
+		ret = -EFAULT;
+		goto free_sens;
+	}
+	if (ioctl_result.buffer_size < ioctl_result.response_size) {
+		ret = -ENOMEM;
+		goto free_sens;
+	}
+	if (!ioctl_result.buffer_ptr) {
+		ret = -EINVAL;
+		goto free_sens;
+	}
 
-			for (i = 0; i < sens->num_data_fields; ++i)
-				if (sens->data_fields[i].name) {
-					kobject_put(&sens->data_fields[i].kobj);
-					kobject_del(&sens->data_fields[i].kobj);
-				}
-			kfree(sens->data_fields);
-			kobject_put(&sens->data_fields_kobj);
-			kobject_del(&sens->data_fields_kobj);
-			kobject_put(&sens->kobj);
-			kobject_del(&sens->kobj);
+#ifdef CONFIG_COMPAT
+	if (compat_called)
+		ioctl_result.buffer_ptr =
+			(uint64_t)compat_ptr(ioctl_result.buffer_ptr);
+#endif
+	if (sensor->impl->get_sens_properties(sensor)) {
+		ret = -EINVAL;
+		goto free_sens;
+	}
 
-			kfree(sens);
+	for (i = 0; i < sensor->num_properties; ++i) {
+		if (ioctl_result.buffer_size - buf_off <
+				sizeof(struct property_details)) {
+			ret = -ENOMEM;
+			goto free_sens;
+		}
 
-			return 0;
+		strncpy(prop_details.prop_name, sensor->properties[i].name,
+			MAX_PROP_NAME_LEN);
+		strncpy(prop_details.value, sensor->properties[i].value,
+			MAX_PROP_VAL_LEN);
+		if (copy_to_user((char __user *)ioctl_result.buffer_ptr +
+				buf_off, &prop_details,
+				sizeof(struct property_details))) {
+			ret = -EFAULT;
+			goto free_sens;
 		}
+		buf_off += sizeof(struct property_details);
 	}
+	if (buf_off != ioctl_result.response_size)
+		ret = -EFAULT;
+free_sens:
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor->sens_in_use = 0;
+	if (waitqueue_active(&sensor->wait_sens_free))
+		wake_up_interruptible(&sensor->wait_sens_free);
 	spin_unlock_irqrestore(&senscol_lock, flags);
 
-	return -EINVAL;
+	return ret;
 }
-EXPORT_SYMBOL(remove_senscol_sensor);
-
-/*
- * Exposed sensor via sysfs, structure may be static
- *
- * The caller is responsible for setting all meaningful fields
- * (may call add_data_field() and add_sens_property() as needed)
- * We'll consider hiding senscol framework-specific fields
- * into opaque structures
- */
 
-int	add_senscol_sensor(struct sensor_def *sensor)
+static long ioctl_set_prop(struct using_fd *cur_fd, unsigned long param,
+	int compat_called)
 {
-	unsigned long	flags;
-	char	sensor_name[256];	/* Enough for name "sensor_<NN>_def",
-					 * if convention changes array size
-					 * should be reviewed */
-	int	i;
-	int	rv;
-	int	j;
-
-	if (!sensor->name || !sensor->impl || !sensor->usage_id || !sensor->id)
-		return	-EINVAL;
+	struct sens_link *sensor_link = NULL;
+	struct sensor_def *sensor;
+	struct ioctl_res ioctl_result;
+	struct list_head set_props;
+	char *prop_array_buf;
+	struct property_details *prop_array;
+	int prop_array_size;
+	unsigned long flags;
+	int ret = 0, i;
+	/* flag indicates recover from error when occurs */
+	int sens_aquired_now = 0;
+
+	if (copy_from_user(&ioctl_result, (char __user *)param,
+			sizeof(struct ioctl_res)))
+		return -EFAULT;
+	if (ioctl_result.buffer_size <= 0)
+		return -EINVAL;
+	if (!ioctl_result.buffer_ptr)
+		return -EINVAL;
+	if (ioctl_result.buffer_size % sizeof(struct property_details))
+		return -EINVAL; /* error format of user buffer -
+					size doesn't fit */
 
+	/* check if this fd already acquired this sensor*/
 	spin_lock_irqsave(&senscol_lock, flags);
-	list_add_tail(&sensor->link, &senscol_sensors_list);
-	spin_unlock_irqrestore(&senscol_lock, flags);
+	sensor = get_sensor_from_fd_list(cur_fd, ioctl_result.sens_id);
+	if (!sensor) {
+		sensor = get_senscol_sensor_by_id(ioctl_result.sens_id);
+		if (!sensor) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return -EINVAL;
+		}
+		/* mark sensor as in-use */
+		if (sensor->sens_in_use) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return -EBUSY;
+		}
+		sensor->sens_in_use = 1;
 
-	/*
-	 * Create sysfs entries for this sensor
-	 */
+		if (sensor->acquire_fd) { /* sensor is caught by another fd */
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			ret = -EINVAL;
+			goto out;
+		}
+		spin_unlock_irqrestore(&senscol_lock, flags);
 
-	/* Init and add sensor_def kobject */
-	snprintf(sensor_name, sizeof(sensor_name), "sensor_%X_def", sensor->id);
-	rv = kobject_init_and_add(&sensor->kobj, &sc_sensdef_kobj_type,
-		&sc_pdev->dev.kobj, sensor_name);
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): kobject_init_and_add() for 'data' returned %d\n",
-		__func__, rv);
-	if (rv) {
-		rv = -EFAULT;
-err_ret:
-		kobject_put(&sensor->kobj);
-		kobject_del(&sensor->kobj);
-		return	rv;
-	}
+		spin_lock_irqsave(&cur_fd->buf_lock, flags);
+		if (!cur_fd->data_buf) { /* this is the first sensor this fd
+						using. allocate buffer */
+			cur_fd->data_buf = kzalloc(SENSCOL_DATA_BUF_SIZE,
+				GFP_ATOMIC);
+		}
+		if (!cur_fd->data_buf) {
+			spin_unlock_irqrestore(&cur_fd->buf_lock, flags);
+			ret = -ENOMEM;
+			goto out;
+		}
+		spin_unlock_irqrestore(&cur_fd->buf_lock, flags);
 
-/*
- * Special attribute "friendly_name" is retired in favor
- * of generic property "property_friendly_name"
- */
-#if 0
-	/* If freiendly_name is given, add such attribute */
-	memset(&attr, 0, sizeof(struct attribute));
-	attr.name = "friendly_name";
-	attr.mode = S_IRUGO;
-	rv = sysfs_create_file(&sensor->kobj, &attr);
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): sysfs_create_file() for 'friendly_name' returned %d\n",
-		__func__, rv);
-#endif
+		sensor_link = kmalloc(sizeof(struct sens_link), GFP_KERNEL);
+		if (!sensor_link) {
+			ret = -ENOMEM;
+			goto out;
+		}
 
-	/*
-	 * Create kobjects without attributes for
-	 * sensor_<NN>_def/data_fields and sensor_<NN>/properties
-	 */
-	rv = kobject_init_and_add(&sensor->data_fields_kobj,
-		&sc_subdir_kobj_type, &sensor->kobj, "data_fields");
-	if (rv) {
-		rv = -EFAULT;
-err_ret2:
-		kobject_put(&sensor->data_fields_kobj);
-		kobject_del(&sensor->data_fields_kobj);
-		goto	err_ret;
-	}
+		spin_lock_irqsave(&senscol_lock, flags);
+		sensor_link->sensor = sensor;
+		list_add_tail(&sensor_link->link, &cur_fd->sensors_list);
+		sensor->acquire_fd = cur_fd;
+		spin_unlock_irqrestore(&senscol_lock, flags);
 
-	rv = kobject_init_and_add(&sensor->props_kobj, &sc_subdir_kobj_type,
-		&sensor->kobj, "properties");
-	if (rv) {
-		rv = -EFAULT;
-err_ret3:
-		kobject_put(&sensor->props_kobj);
-		kobject_del(&sensor->props_kobj);
-		goto	err_ret2;
+		sens_aquired_now = 1;
+	} else {
+		/* mark sensor as in-use */
+		if (sensor->sens_in_use) {
+			spin_unlock_irqrestore(&senscol_lock, flags);
+			return -EBUSY;
+		}
+		sensor->sens_in_use = 1;
+		spin_unlock_irqrestore(&senscol_lock, flags);
 	}
 
-	/*
-	 * Create kobjects for data_fields
-	 */
-	for (i = 0; i < sensor->num_data_fields; ++i)
-		if (sensor->data_fields[i].name)
-			for (j = i-1; j >= 0; --j)	/*use index as a temp
-							variable*/
-				if (sensor->data_fields[j].name &&
-					!strcmp(sensor->data_fields[i].name,
-						sensor->data_fields[j].name)) {
-					if (!sensor->data_fields[j].index)
-						sensor->data_fields[j].index++;
-					sensor->data_fields[i].index =
-						sensor->data_fields[j].index
-									+ 1;
-					break;
-				}
-
-	for (i = 0; i < sensor->num_data_fields; ++i) {
-		if (sensor->data_fields[i].name) {
-			if (sensor->data_fields[i].index) {
-				char *p = kasprintf(GFP_KERNEL, "%s#%d",
-					sensor->data_fields[i].name,
-					sensor->data_fields[i].index-1);
-				kfree(sensor->data_fields[i].name);
-				sensor->data_fields[i].name = p;
-			}
-
-			/* Mark index */
-			sensor->data_fields[i].index = i;
-
-			rv = kobject_init_and_add(&sensor->data_fields[i].kobj,
-				&sc_datafield_kobj_type,
-				&sensor->data_fields_kobj,
-				sensor->data_fields[i].name);
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): kobject_init_and_add() for data_field '%s' returned %d\n",
-				__func__, sensor->data_fields[i].name, rv);
-		}
+	prop_array_buf = kmalloc(ioctl_result.buffer_size, GFP_KERNEL);
+	if (!prop_array_buf) {
+		ret = -ENOMEM;
+		goto out;
 	}
-	ISH_DBG_PRINT(KERN_ALERT "%s(): sample_size=%u\n",
-		__func__, sensor->sample_size);
 
-	/*
-	 * Create kobjects for properties
-	 */
-	for (i = 0; i < sensor->num_properties; ++i) {
-		if (sensor->properties[i].name) {
-			rv = kobject_init_and_add(&sensor->properties[i].kobj,
-				&sc_sensprop_kobj_type, &sensor->props_kobj,
-				sensor->properties[i].name);
-			ISH_DBG_PRINT(KERN_ALERT
-				"%s(): kobject_init_and_add() for property '%s' returned %d\n",
-				__func__, sensor->properties[i].name, rv);
+#ifdef CONFIG_COMPAT
+	if (compat_called)
+		ioctl_result.buffer_ptr =
+			(uint64_t)compat_ptr(ioctl_result.buffer_ptr);
+#endif
+	if (copy_from_user(prop_array_buf,
+			(char __user *)ioctl_result.buffer_ptr,
+			ioctl_result.buffer_size)) {
+		ret = -EFAULT;
+		goto free;
+	}
+	prop_array = (struct property_details *)prop_array_buf;
+	prop_array_size = ioctl_result.buffer_size /
+		sizeof(struct property_details);
+
+	/* call hid set properties */
+	INIT_LIST_HEAD(&set_props);
+	for (i = 0; i < prop_array_size; i++) {
+		if (add_set_list_property(sensor, &set_props,
+				prop_array[i].prop_name, prop_array[i].value)) {
+			ret = -EINVAL;
+			goto free_prop_list;
 		}
 	}
+	ret = sensor->impl->set_sens_properties(&set_props, sensor->id);
+free_prop_list:
+	remove_set_list_properties(&set_props);
+free:
+	kfree(prop_array_buf);
+out:
+	/* in error: release the acquired sensor, if it was acquired now */
+	if (ret && sens_aquired_now) {
+		spin_lock_irqsave(&senscol_lock, flags);
+		list_del(&sensor_link->link);
+		sensor->acquire_fd = NULL;
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		kfree(sensor_link);
+	}
 
-	/* Sample size should be set by the caller to size of raw data */
-	sensor->sample_size += offsetof(struct senscol_sample, data);
+	/* free sensor "in-use" flag */
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor->sens_in_use = 0;
+	if (waitqueue_active(&sensor->wait_sens_free))
+		wake_up_interruptible(&sensor->wait_sens_free);
+	spin_unlock_irqrestore(&senscol_lock, flags);
 
-	return	0;
+	return ret;
 }
-EXPORT_SYMBOL(add_senscol_sensor);
 
-struct sensor_def	*get_senscol_sensor_by_name(const char *name)
+static long ioctl_get_data_fields(unsigned long param, int compat_called)
 {
-	struct sensor_def	*sens, *next;
-	unsigned long	flags;
+	struct sensor_def *sensor;
+	struct ioctl_res ioctl_result;
+	struct data_fields_details data_fld_details;
+	unsigned long flags;
+	int buf_off = 0;
+	int i, ret = 0;
 
+	if (copy_from_user(&ioctl_result, (char __user *)param,
+			sizeof(struct ioctl_res)))
+		return -EFAULT;
 	spin_lock_irqsave(&senscol_lock, flags);
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (!strcmp(sens->name, name)) {
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			return	sens;
-		}
+	sensor = get_senscol_sensor_by_id(ioctl_result.sens_id);
+	if (!sensor) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EINVAL;
 	}
 
+	/* mark sensor as in-use */
+	if (sensor->sens_in_use) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EBUSY;
+	}
+	sensor->sens_in_use = 1;
 	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	NULL;
-}
-EXPORT_SYMBOL(get_senscol_sensor_by_name);
+	ioctl_result.response_size = sensor->num_data_fields *
+		sizeof(struct data_fields_details);
+	/* write back to user, with response_size filled */
+	if (copy_to_user((char __user *)param, &ioctl_result,
+			sizeof(struct ioctl_res))) {
+		ret = -EFAULT;
+		goto free_sens;
+	}
+	if (ioctl_result.buffer_size < ioctl_result.response_size) {
+		ret = -ENOMEM;
+		goto free_sens;
+	}
+	if (!ioctl_result.buffer_ptr) {
+		ret = -EINVAL;
+		goto free_sens;
+	}
 
-struct sensor_def	*get_senscol_sensor_by_id(uint32_t id)
-{
-	struct sensor_def	*sens, *next;
-	unsigned long	flags;
+#ifdef CONFIG_COMPAT
+	if (compat_called)
+		ioctl_result.buffer_ptr =
+			(uint64_t)compat_ptr(ioctl_result.buffer_ptr);
+#endif
+	for (i = 0; i < sensor->num_data_fields; ++i) {
+		if (ioctl_result.buffer_size - buf_off <
+				sizeof(struct data_fields_details)) {
+			ret = -ENOMEM;
+			goto free_sens;
+		}
 
-	spin_lock_irqsave(&senscol_lock, flags);
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (sens->id == id) {
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			return	sens;
+		strncpy(data_fld_details.data_field_name,
+			sensor->data_fields[i].name, MAX_DATA_FIELD_NAME_LEN);
+		data_fld_details.usage_id = sensor->data_fields[i].usage_id;
+		data_fld_details.exponent = sensor->data_fields[i].exp;
+		data_fld_details.len = sensor->data_fields[i].len;
+		data_fld_details.unit = sensor->data_fields[i].unit;
+		data_fld_details.index = sensor->data_fields[i].index;
+		data_fld_details.is_numeric = sensor->data_fields[i].is_numeric;
+
+		if (copy_to_user((char __user *)ioctl_result.buffer_ptr +
+				buf_off, &data_fld_details,
+				sizeof(struct data_fields_details))) {
+			ret = -EFAULT;
+			goto free_sens;
 		}
+		buf_off += sizeof(struct data_fields_details);
 	}
-
+	if (buf_off != ioctl_result.response_size)
+		ret = -EFAULT;
+free_sens:
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor->sens_in_use = 0;
+	if (waitqueue_active(&sensor->wait_sens_free))
+		wake_up_interruptible(&sensor->wait_sens_free);
 	spin_unlock_irqrestore(&senscol_lock, flags);
-	return	NULL;
+
+	return ret;
 }
-EXPORT_SYMBOL(get_senscol_sensor_by_id);
 
-/* Add data field to existing sensor */
-int	add_data_field(struct sensor_def *sensor, struct data_field *data)
+static long ioctl_flush(struct using_fd *cur_fd, unsigned long param)
 {
-	struct data_field	*temp;
-
-	temp = krealloc(sensor->data_fields,
-		(sensor->num_data_fields + 1) * sizeof(struct data_field),
-		GFP_KERNEL);
-	if (!temp)
-		return	-ENOMEM;
+	struct sensor_def *sensor;
+	unsigned long flags;
+	uint32_t sens_id;
+	long	ret;
 
-	data->sensor = sensor;
-	memcpy(&temp[sensor->num_data_fields++], data,
-		sizeof(struct data_field));
-	sensor->data_fields = temp;
-	return	0;
-}
-EXPORT_SYMBOL(add_data_field);
+	if (copy_from_user(&sens_id, (char __user *)param,
+			sizeof(uint32_t)))
+		return -EFAULT;
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor = get_sensor_from_fd_list(cur_fd, sens_id);
+	if (!sensor) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EINVAL;
+	}
+	/* mark sensor as in-use */
+	if (sensor->sens_in_use) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EBUSY;
+	}
+	sensor->sens_in_use = 1;
+	sensor->ask_flush_count++;
+	spin_unlock_irqrestore(&senscol_lock, flags);
 
-/* Add property to existing sensor */
-int	add_sens_property(struct sensor_def *sensor, struct sens_property *prop)
-{
-	struct sens_property	*temp;
+	ret = sensor->impl->ask_flush(sensor);
 
-	temp = krealloc(sensor->properties,
-		(sensor->num_properties + 1) * sizeof(struct sens_property),
-		GFP_KERNEL);
-	if (!temp)
-		return	-ENOMEM;
+	/* release sensor "in use" flag */
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor->sens_in_use = 0;
+	if (waitqueue_active(&sensor->wait_sens_free))
+		wake_up_interruptible(&sensor->wait_sens_free);
+	spin_unlock_irqrestore(&senscol_lock, flags);
 
-	prop->sensor = sensor;		/* The needed backlink */
-	memcpy(&temp[sensor->num_properties++], prop,
-		sizeof(struct sens_property));
-	sensor->properties = temp;
-	return	0;
+	return ret;
 }
-EXPORT_SYMBOL(add_sens_property);
 
-/*
- * Push data sample in upstream buffer towards user-mode.
- * Sample's size is determined from the structure
- *
- * Samples are queued is a simple FIFO binary buffer with head and tail
- * pointers.
- * Additional fields if wanted to be communicated to user mode can be defined
- *
- * Returns 0 on success, negative error code on error
- */
-int	push_sample(uint32_t id, void *sample)
+static long ioctl_get_sample(struct using_fd *cur_fd, unsigned long param)
 {
-	struct sensor_def	*sensor;
+	struct sensor_def *sensor;
+	uint32_t sens_id;
 	unsigned long flags;
-	unsigned char	sample_buf[1024];
-	struct senscol_sample	*p_sample = (struct senscol_sample *)sample_buf;
-	struct sensor_def pseudo_event_sensor;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	g_ish_print_log("%s() DATA from sensor #%x\n", __func__, id);
-
-	if (!senscol_data_buf)
-		return	-ENOMEM;
+	long ret;
 
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): senscol_data_buf=%p\n",
-		__func__, senscol_data_buf);
-
-	if (id & PSEUSO_EVENT_BIT) {
-		pseudo_event_sensor.sample_size = sizeof(uint32_t) +
-			offsetof(struct senscol_sample, data);
-		sensor = &pseudo_event_sensor;
-	} else
-		sensor = get_senscol_sensor_by_id(id);
-
-	if (!sensor)
-		return	-ENODEV;
-
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s(): sensor=%p\n",
-		__func__, sensor);
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol]: %s(): senscol_data_head=%u senscol_data_tail=%u sample_size=%u\n",
-		__func__, senscol_data_head, senscol_data_tail,
-		sensor->sample_size);
-
-	spin_lock_irqsave(&senscol_data_lock, flags);
-
-	/*
-	 * TBD: when buffer overflows we may choose to drop
-	 * the new data or oldest data.
-	 */
-	/* Here we drop the new data */
-	if (senscol_data_head != senscol_data_tail &&
-			(senscol_data_head - senscol_data_tail) %
-			SENSCOL_DATA_BUF_SIZE <= sensor->sample_size) {
-		spin_unlock_irqrestore(&senscol_data_lock, flags);
-		ISH_DBG_PRINT(KERN_ALERT
-			"[senscol]: %s(): dropping sample, senscol_data_head=%u senscol_data_tail=%u sample size=%u\n",
-			__func__, senscol_data_head, senscol_data_tail,
-			sensor->sample_size);
-		return	-ENOMEM;
+	if (copy_from_user(&sens_id, (char __user *)param,
+			sizeof(uint32_t)))
+		return -EFAULT;
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor = get_sensor_from_fd_list(cur_fd, sens_id);
+	if (!sensor) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EINVAL;
 	}
 
-	p_sample->id = id;
-	p_sample->size = sensor->sample_size;
-	memcpy(p_sample->data, sample,
-		sensor->sample_size - offsetof(struct senscol_sample, data));
-
-	memcpy(senscol_data_buf + senscol_data_tail, p_sample, p_sample->size);
-	senscol_data_tail += sensor->sample_size;
-	if (senscol_data_tail > SENSCOL_DATA_BUF_LAST)
-		senscol_data_tail = 0;
-
-	spin_unlock_irqrestore(&senscol_data_lock, flags);
-
-	/* Fire event through "data/event" */
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol] %s(): firing data-ready event senscol_data_head=%u senscol_data_tail=%u id=%08X sample_size=%u\n",
-		__func__, senscol_data_head, senscol_data_tail, p_sample->id,
-		sensor->sample_size);
-
-	if (waitqueue_active(&senscol_read_wait))
-		wake_up_interruptible(&senscol_read_wait);
+	/* mark sensor as in-use */
+	if (sensor->sens_in_use) {
+		spin_unlock_irqrestore(&senscol_lock, flags);
+		return -EBUSY;
+	}
+	sensor->sens_in_use = 1;
+	spin_unlock_irqrestore(&senscol_lock, flags);
 
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():--- 0\n", __func__);
-	return	0;
-}
-EXPORT_SYMBOL(push_sample);
+	ret = sensor->impl->get_sample(sensor);
 
+	/* release sensor "in use" flag */
+	spin_lock_irqsave(&senscol_lock, flags);
+	sensor->sens_in_use = 0;
+	if (waitqueue_active(&sensor->wait_sens_free))
+		wake_up_interruptible(&sensor->wait_sens_free);
+	spin_unlock_irqrestore(&senscol_lock, flags);
 
-static int senscol_open(struct inode *inode, struct file *file)
-{
-	user_task = current;
-	return	0;
+	return ret;
 }
 
-static int senscol_release(struct inode *inode, struct file *file)
+static long senscol_ioctl(struct file *file, unsigned int cmd,
+	unsigned long param)
 {
-	return	0;
-}
+	struct using_fd *cur_fd = file->private_data;
+	int compat_called = cur_fd->comapt_ioctl;
+	cur_fd->comapt_ioctl = 0;
 
-static ssize_t senscol_read(struct file *file, char __user *ubuf,
-	size_t length, loff_t *offset)
-{
-	return	length;
-}
+	if (!param)
+		return -EINVAL;
 
-static ssize_t senscol_write(struct file *file, const char __user *ubuf,
-	size_t length, loff_t *offset)
-{
-	return	length;
-}
+	switch (cmd) {
+	case IOCTL_GET_SENSORS_NUM:
+		return ioctl_get_sens_num(param);
+	case IOCTL_GET_SENSORS_LIST:
+		return ioctl_get_sens_list(param, compat_called);
+	case IOCTL_GET_PROP:
+		return ioctl_get_prop(param, compat_called);
+	case IOCTL_SET_PROP:
+		return ioctl_set_prop((struct using_fd *)file->private_data,
+			param, compat_called);
+	case IOCTL_GET_DATA_FIELDS:
+		return ioctl_get_data_fields(param, compat_called);
+	case IOCTL_FLUSH:
+		return ioctl_flush((struct using_fd *)file->private_data,
+			param);
+	case IOCTL_GET_SAMPLE:
+		return ioctl_get_sample((struct using_fd *)file->private_data,
+			param);
+	default: return -EINVAL;
+	}
 
-static long senscol_ioctl(struct file *file, unsigned int cmd,
-	unsigned long data)
-{
 	return	0;
 }
 
 static unsigned int senscol_poll(struct file *file, poll_table *wait)
 {
 	unsigned int mask = 0;
-	unsigned long   flags;
+	unsigned long	flags;
 	int	rd_ready = 0;
+	struct using_fd *cur_fd = file->private_data;
 
-	poll_wait(file, &senscol_read_wait, wait);
-
-	/* If read buffer is empty, wait again on senscol_read_wait */
+	poll_wait(file, &cur_fd->read_wait, wait);
 
-	spin_lock_irqsave(&senscol_data_lock, flags);
-	rd_ready = (senscol_data_head != senscol_data_tail);
-	spin_unlock_irqrestore(&senscol_data_lock, flags);
+	spin_lock_irqsave(&cur_fd->buf_lock, flags);
+	rd_ready = (cur_fd->head != cur_fd->tail);
+	spin_unlock_irqrestore(&cur_fd->buf_lock, flags);
 
 	if (rd_ready)
 		mask |= (POLLIN | POLLRDNORM);
-	/*mask |= DEFAULT_POLLMASK|POLLERR|POLLPRI;*/
 	return	mask;
 }
 
 /* flush callback */
-void senscol_flush_cb(void)
+void senscol_flush_cb(unsigned sens_id)
 {
-	struct sensor_def	*sens, *next;
-	unsigned long   flags;
-	uint32_t pseudo_event_id;
+	struct sensor_def *sensor;
+	unsigned long	buf_flags, sens_flags, flags;
+	unsigned char	sample_buf[50];
+	struct senscol_sample	*p_sample = (struct senscol_sample *)sample_buf;
 	uint32_t pseudo_event_content = 0;
-
-	spin_lock_irqsave(&senscol_lock, flags);
-	if (!flush_asked) {
-		spin_unlock_irqrestore(&senscol_lock, flags);
+	struct using_fd *cur_fd;
+
+	p_sample->id = sens_id | PSEUSO_EVENT_BIT;
+	p_sample->size = sizeof(uint32_t) +
+		offsetof(struct senscol_sample, data);
+	pseudo_event_content |= FLUSH_CMPL_BIT;
+	memcpy(p_sample->data, &pseudo_event_content, sizeof(uint32_t));
+
+	spin_lock_irqsave(&senscol_lock, sens_flags);
+	sensor = get_senscol_sensor_by_id(sens_id);
+	if (!sensor) {
+		spin_unlock_irqrestore(&senscol_lock, sens_flags);
 		return;
 	}
 
-	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
-		if (sens->flush_req) {
-			sens->flush_req = 0;
-			pseudo_event_id = sens->id | PSEUSO_EVENT_BIT;
-			pseudo_event_content |= FLUSH_CMPL_BIT;
-
-			spin_unlock_irqrestore(&senscol_lock, flags);
-			push_sample(pseudo_event_id, &pseudo_event_content);
-			spin_lock_irqsave(&senscol_lock, flags);
+	if (sensor->acquire_fd) {
+		cur_fd = sensor->acquire_fd;
+
+		spin_lock_irqsave(&fds_list_lock, flags);
+		if (cur_fd->fd_used_cnt == FD_BEING_REMOVED) {
+			/* the fd is in remove process */
+			spin_unlock_irqrestore(&fds_list_lock, flags);
+			spin_unlock_irqrestore(&senscol_lock, sens_flags);
+			return;
+		} else
+			cur_fd->fd_used_cnt++; /* increase fd in-use cnt.
+						other usages than release fd
+						won't block each other */
+		spin_unlock_irqrestore(&fds_list_lock, flags);
+
+		/* buffer is ruined or no one asked for flush */
+		if (!cur_fd->data_buf || !sensor->ask_flush_count) {
+			spin_unlock_irqrestore(&senscol_lock, sens_flags);
+			goto free_fd;
+		}
+		sensor->ask_flush_count--;
+		spin_unlock_irqrestore(&senscol_lock, sens_flags);
+
+		/* buffer is OK. copy data */
+		spin_lock_irqsave(&cur_fd->buf_lock, buf_flags);
+		if (cur_fd->head != cur_fd->tail &&
+				(cur_fd->head - cur_fd->tail) %
+				SENSCOL_DATA_BUF_SIZE <= p_sample->size) {
+			/* drop sample */
+			spin_unlock_irqrestore(&cur_fd->buf_lock, buf_flags);
+		} else {
+			memcpy(cur_fd->data_buf + cur_fd->tail,	p_sample,
+				p_sample->size);
+			cur_fd->tail += p_sample->size;
+			if (cur_fd->tail > SENSCOL_DATA_BUF_LAST)
+				cur_fd->tail = 0;
+			spin_unlock_irqrestore(&cur_fd->buf_lock, buf_flags);
 		}
+		if (waitqueue_active(&cur_fd->read_wait))
+			wake_up_interruptible(&cur_fd->read_wait);
+	} else {
+		spin_unlock_irqrestore(&senscol_lock, sens_flags);
+		return;
 	}
-	flush_asked = 0;
-	spin_unlock_irqrestore(&senscol_lock, flags);
-	return;
+free_fd:
+	spin_lock_irqsave(&fds_list_lock, flags);
+	cur_fd->fd_used_cnt--;
+	if (!cur_fd->fd_used_cnt && waitqueue_active(&cur_fd->wait_fd_free))
+		wake_up_interruptible(&cur_fd->wait_fd_free);
+	spin_unlock_irqrestore(&fds_list_lock, flags);
 }
 
+#ifdef CONFIG_COMPAT
+static long senscol_compat_ioctl(struct file *file,
+			unsigned int cmd, unsigned long data)
+{
+	struct using_fd *cur_fd = file->private_data;
+	if (!data)
+		return -EINVAL;
+
+	cur_fd->comapt_ioctl = 1;
+	return senscol_ioctl(file, cmd, (unsigned long)compat_ptr(data));
+}
+#endif /* CONFIG_COMPAT */
 
-/*
- * file operations structure will be used for ishtp char device.
- */
 static const struct file_operations senscol_fops = {
 	.owner = THIS_MODULE,
 	.read = senscol_read,
 	.unlocked_ioctl = senscol_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = senscol_compat_ioctl,
+#endif
 	.open = senscol_open,
 	.release = senscol_release,
 	.write = senscol_write,
@@ -1082,80 +1078,26 @@ static const struct file_operations senscol_fops = {
 /*
  * Misc Device Struct
  */
-static struct miscdevice  senscol_misc_device = {
-		.name = "sensor-collection",
+static struct miscdevice senscol_misc_device = {
+		.name = "senscol2",
 		.fops = &senscol_fops,
 		.minor = MISC_DYNAMIC_MINOR,
 };
 
-
-static int __init senscol_init(void)
+int senscol_init(void)
 {
 	int	rv;
 
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-
-	INIT_LIST_HEAD(&senscol_impl_list);
 	INIT_LIST_HEAD(&senscol_sensors_list);
+	INIT_LIST_HEAD(&fds_list);
 	spin_lock_init(&senscol_lock);
-	spin_lock_init(&senscol_data_lock);
-	init_waitqueue_head(&senscol_read_wait);
-
-	/* Init data buffer */
-	senscol_data_buf = kmalloc(SENSCOL_DATA_BUF_SIZE, GFP_KERNEL);
-	if (!senscol_data_buf)
-		return	-ENOMEM;
-	ISH_DBG_PRINT(KERN_ALERT
-		"[senscol] %s(): allocated senscol_data_buf of size %u\n",
-		__func__, SENSCOL_DATA_BUF_SIZE);
-
-	senscol_data_head = 0;
-	senscol_data_tail = 0;
-
-	/* Create sensor_collection platform device and default sysfs entries */
-	sc_pdev = platform_device_register_simple("sensor_collection", -1,
-		NULL, 0);
-	if (IS_ERR(sc_pdev)) {
-		ISH_DBG_PRINT(KERN_ERR
-			"%s(): failed to create platform device sensor_collection\n",
-			__func__);
-		kfree(senscol_data_buf);
-		return	-ENODEV;
-	}
+	spin_lock_init(&fds_list_lock);
 
-	senscol_misc_device.parent = &sc_pdev->dev;
 	rv = misc_register(&senscol_misc_device);
 	if (rv)
 		return	rv;
 
-	rv = kobject_init_and_add(&sc_data_kobj, &sc_data_kobj_type,
-		&sc_pdev->dev.kobj, "data");
-	ISH_DBG_PRINT(KERN_ALERT
-		"%s(): kobject_init_and_add() for 'data' returned %d\n",
-		__func__, rv);
-
-	rv = sysfs_create_bin_file(&sc_data_kobj, &sensors_data_binattr);
-	if (rv)
-		ISH_DBG_PRINT(KERN_ERR
-			"%s(): sysfs_create_bin_file() for 'sensors_data' returned %d\n",
-			__func__, rv);
-
-	register_flush_cb(senscol_flush_cb);
-
-	return	0;
-}
-
-static void __exit senscol_exit(void)
-{
-	ISH_DBG_PRINT(KERN_ALERT "[senscol]: %s():+++\n", __func__);
-	kfree(senscol_data_buf);
+	return 0;
 }
 
-
-module_init(senscol_init);
-module_exit(senscol_exit);
-
-MODULE_DESCRIPTION("Sensor Collection framework core");
-MODULE_AUTHOR("Intel Corporation");
-MODULE_LICENSE("GPL");
-
+#endif /* !SENSCOL_1 */
diff --git a/include/linux/senscol/senscol-core.h b/include/linux/senscol/senscol-core.h
index cf66838..0b91eb1 100644
--- a/include/linux/senscol/senscol-core.h
+++ b/include/linux/senscol/senscol-core.h
@@ -1,7 +1,7 @@
 /*
  * Sensor collection framework header
  *
- * Copyright (c) 2014-2015, Intel Corporation.
+ * Copyright (c) 2014-2016, Intel Corporation.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
@@ -9,15 +9,23 @@
  *
  * This program is distributed in the hope it will be useful, but WITHOUT
  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
  * more details.
  */
 
 #ifndef	SENSCOL_CORE__
 #define	SENSCOL_CORE__
 
+#define SENSCOL_1	1 /* 1: senscol_1, 0: senscol_2*/
+
 #include <linux/types.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+
+#if SENSCOL_1
 #include <linux/kobject.h>
+#endif
 
 #define	PSEUSO_EVENT_BIT	(1<<31)
 #define	FLUSH_CMPL_BIT		(1<<0)
@@ -41,25 +49,37 @@ struct sensor_def {
 						updated when every
 						data_field is added */
 	struct senscol_impl	*impl;
+	struct using_fd *acquire_fd;	/* fd acquired the sensor,
+						NULL if sensor is available */
+	int ask_flush_count;
+
 	struct list_head	link;
+
+	wait_queue_head_t wait_sens_free;
+	int sens_in_use;		/* use the generic senscol_lock to
+						protect	the "in-use" flag of
+						each sensor */
+#if SENSCOL_1
 	struct kobject	kobj;
 	struct kobject	data_fields_kobj;
 	struct kobject	props_kobj;
-	int     flush_req;
+	int	flush_req;
+#endif
 };
 
 struct data_field {
-	char *name;			/* Must be not NULL */
+	char	*name;			/* Must be not NULL */
 	uint32_t	usage_id;	/* Usage ID of data_field */
 	uint8_t	exp;			/* Exponent: 0..F */
 	uint8_t	len;			/* Length: 0..4 */
 	uint32_t	unit;		/* Usage ID of unit */
-	int	is_numeric;		/* If !is_numeric,
-					 * only name and usage_id appear */
-	struct kobject	kobj;
+	int	is_numeric;
 	struct sensor_def	*sensor;/* We need backlink for properties to
 					 * their parent sensors */
 	int	index;			/* Index of field in raw data */
+#if SENSCOL_1
+	struct kobject	kobj;
+#endif
 };
 
 struct sens_property {
@@ -67,45 +87,45 @@ struct sens_property {
 	uint32_t	usage_id;	/* Usage ID of sens_property */
 	char	*value;
 	uint32_t	unit;		/* Usage ID of unit */
-	int	is_numeric;		/* If !is_numeric,
+	int	is_string;		/* If !is_numeric,
 					 * only name and usage_id appear */
-	struct kobject	kobj;
 	struct sensor_def	*sensor;/* We need backlink for properties
 					 * to their parent sensors */
+	struct list_head	link;
+#if SENSCOL_1
+	struct kobject	kobj;
+#endif
 };
 
-/* Only allocates new sensor */
-struct sensor_def *alloc_senscol_sensor(void);
-
-/* Init sensor (don't call for initialized sensors */
-void	init_senscol_sensor(struct sensor_def *sensor);
-
-/* Exposed sensor via sysfs, structure may be static */
-int	add_senscol_sensor(struct sensor_def *sensor);
-
-struct sensor_def	*get_senscol_sensor_by_name(const char *name);
-struct sensor_def	*get_senscol_sensor_by_id(uint32_t id);
-
-/* Add data field to existing sensor */
-int	add_data_field(struct sensor_def *sensor, struct data_field *data);
+/* fd using the sensors details */
+struct using_fd {
+	uint8_t *data_buf;
+	unsigned head;
+	unsigned tail;
+	spinlock_t buf_lock;
+	wait_queue_head_t read_wait;
+	struct list_head sensors_list;
+	int comapt_ioctl;	/* the flag is set in ioctl func
+				 * if it was called from the compat_ioctl func*/
+	struct task_struct *user_task; /* task to send reset notify event*/
 
-/* Add property to existing sensor */
-int	add_sens_property(struct sensor_def *sensor,
-	struct sens_property *prop);
-
-/* Get known name of given usages (NULL if unknown) */
-const char	*senscol_usage_to_name(unsigned usage);
-
-/*
- * Push data sample in upstream buffer towards user-mode.
- * Sample's size is determined from the structure
- */
-int	push_sample(uint32_t id, void *sample);
+	wait_queue_head_t wait_fd_free;
+#define FD_BEING_REMOVED	(-1)
+	int fd_used_cnt; /*	-1: in remove process
+				0: free
+				>0: cnt of using (either push_sample and/or
+					flush callback)
+				use the generic fds_list_lock to protect it */
+	struct list_head link;
+};
 
-/* Get known name of given modifier  safe, always returns value*/
-const char	*senscol_get_modifier(unsigned modif);
+/* pointer to sensor to save in sensors list of using_fd struct */
+struct sens_link {
+	struct sensor_def *sensor;
+	struct list_head link;
+};
 
-/* Sample structure. Understood by binary SysFS provider and user-mode client */
+/* Sample structure */
 struct senscol_sample {
 	uint32_t	id;
 	uint32_t	size;	/* For easier/faster
@@ -121,22 +141,23 @@ struct senscol_sample {
  * Additional fields if wanted to be communicated to user mode can be define
  */
 
-
 /*
  * Suggested size of data buffer:
- *   avg 24 bytes per sampl
- *   expected 2600 samples/s for 17 sensors at max. rate
- *   cover for 10 seconds of data
+ * avg 24 bytes per sampl
+ * expected 2600 samples/s for 17 sensors at max. rate
+ * cover for 10 seconds of data
  */
-/*#define	SENSCOL_DATA_BUF_SIZE	(24*2600*10)*/
-#define	SENSCOL_DATA_BUF_SIZE	0x40000
-#define	SENSCOL_DATA_BUF_LAST	(SENSCOL_DATA_BUF_SIZE-128)
+
+#define	SENSCOL_DATA_BUF_SIZE	(0x40000)
+#define MAX_SENS_SAMPLE_SIZE	128
+#define	SENSCOL_DATA_BUF_LAST	(SENSCOL_DATA_BUF_SIZE - MAX_SENS_SAMPLE_SIZE)
 
 /*
  * Sensor collection underlying handler.
  * Supplies set_prop(), get_prop() and get_sample() callback
  */
 struct senscol_impl {
+#if SENSCOL_1
 	/* Get property value, will return NULL on failure */
 	int	(*get_sens_property)(struct sensor_def *sensor,
 		const struct sens_property *prop, char *value,
@@ -145,23 +166,138 @@ struct senscol_impl {
 	/* Set property value */
 	int	(*set_sens_property)(struct sensor_def *sensor,
 		const struct sens_property *prop, const char *value);
+#endif
 
 	/* Get sample */
 	int	(*get_sample)(struct sensor_def *sensor);
 
 	/* Check if sensor is activated in batch mode */
-	int	(*batch_check)(struct sensor_def *sensor);
+	int	(*disable_sensor)(struct sensor_def *sensor);
+
+	int	(*get_sens_properties)(struct sensor_def *sensor);
+	int	(*set_sens_properties)(struct list_head *set_prop_list,
+		uint32_t sensor_id);
+	int	(*ask_flush)(struct sensor_def *sensor);
 
 	struct list_head link;
 };
 
-int	add_senscol_impl(struct senscol_impl *impl);
-int	remove_senscol_impl(struct senscol_impl *impl);
+/* structs for API get-set using ioctl */
+#define MAX_NAME_LENGTH		56
+#define MAX_PROP_NAME_LEN	80
+#define MAX_PROP_VAL_LEN	56
+#define MAX_DATA_FIELD_NAME_LEN	80
+
+struct ioctl_res;
+
+#define IOCTL_GET_SENSORS_NUM	_IOWR('H', 0x01, int)
+#define IOCTL_GET_SENSORS_LIST	_IOWR('H', 0x02, struct ioctl_res)
+#define IOCTL_GET_PROP		_IOWR('H', 0x03, struct ioctl_res)
+#define IOCTL_SET_PROP		_IOWR('H', 0x04, struct ioctl_res)
+#define IOCTL_GET_DATA_FIELDS	_IOWR('H', 0x05, struct ioctl_res)
+#define IOCTL_FLUSH		_IOWR('H', 0x06, int)
+#define IOCTL_GET_SAMPLE	_IOWR('H', 0x07, int)
+
+struct ioctl_res {
+	uint32_t buffer_size;	/* user buffer size */
+	uint32_t sens_id;	/* sensor id, 0 in general cmd */
+	uint32_t response_size;	/* size of response from driver */
+	uint64_t buffer_ptr;	/* user buffer */
+} __packed;
+
+struct sensor_details {
+	uint32_t id;
+	char name[MAX_NAME_LENGTH];
+	uint32_t usage_id;
+	uint32_t sample_size;
+	uint32_t properties_num;	/* number of properties */
+	uint32_t data_fields_num;	/* number of data fields */
+} __packed;
+
+struct property_details {
+	char prop_name[MAX_PROP_NAME_LEN];
+	char value[MAX_PROP_VAL_LEN];
+} __packed;
+
+struct data_fields_details {
+	char data_field_name[MAX_DATA_FIELD_NAME_LEN];
+	uint32_t usage_id;
+	uint32_t index;
+	uint32_t len;
+	uint8_t is_numeric;
+	uint32_t exponent;
+	uint32_t unit;
+} __packed;
+
+/***************************************/
+
+#if SENSCOL_1
+/* init and exit functions of sensor-collection */
+int	senscol_init_legacy(void);
+void	senscol_exit_legacy(void);
+
+/* Init sensor (don't call for initialized sensors) */
+void	init_senscol_sensor_legacy(struct sensor_def *sensor);
+
+int	add_senscol_sensor_legacy(struct sensor_def *sensor);
+int	remove_senscol_sensor_legacy(uint32_t id);
+
+/*
+ * Push data sample in upstream buffer towards user-mode.
+ * Sample's size is determined from the structure
+ */
+int	push_sample_legacy(uint32_t id, void *sample);
+void	senscol_flush_cb_legacy(unsigned sens_id);
+
+void	senscol_send_ready_event_legacy(void);
+int	senscol_reset_notify_legacy(void);
+
+#else /* senscol2 api */
+
+/* init and exit functions of sensor-collection */
+int	senscol_init(void);
+void	senscol_exit(void);
+
+/* Init sensor (don't call for initialized sensors) */
+void	init_senscol_sensor(struct sensor_def *sensor);
+
+int	add_senscol_sensor(struct sensor_def *sensor);
 int	remove_senscol_sensor(uint32_t id);
+
+/*
+ * Push data sample in upstream buffer towards user-mode.
+ * Sample's size is determined from the structure
+ */
+int	push_sample(uint32_t id, void *sample);
+void	senscol_flush_cb(unsigned sens_id);
+
 void	senscol_send_ready_event(void);
 int	senscol_reset_notify(void);
+#endif /* SENSCOL_1 */
+
+/* Only allocates new sensor */
+struct sensor_def *alloc_senscol_sensor(void);
+/* Add data field to existing sensor */
+int	add_data_field(struct sensor_def *sensor, struct data_field *data);
+/* Add property to existing sensor */
+int	add_sens_property(struct sensor_def *sensor,
+	struct sens_property *prop);
+
+struct sensor_def	*get_senscol_sensor_by_id(uint32_t id);
+/* Returns known name of given usages (NULL if unknown) */
+const char	*senscol_usage_to_name(unsigned usage);
+/* Returns known name of given modifier safe, always returns value*/
+const char	*senscol_get_modifier(unsigned modif);
+
+/* Allocates string with the name of the given usage */
+char	*create_sensor_name(unsigned usage_id);
+char	*create_sens_prop_name(unsigned usage_id);
+
+extern struct list_head	senscol_sensors_list;
+extern spinlock_t	senscol_lock;
 
-/*DEBUG*/
+/*********** Locally redirect ish_print_log **************/
 void g_ish_print_log(char *format, ...);
-#endif /*SENSCOL_CORE__H*/
+/*********************************************************/
+#endif /*SENSCOL_CORE__*/
 
-- 
1.9.1

