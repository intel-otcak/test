From c07d05a9c533a862430bb35e60687db6ee3a4561 Mon Sep 17 00:00:00 2001
Message-Id: <c07d05a9c533a862430bb35e60687db6ee3a4561.1421709247.git.chang-joon.lee@intel.com>
In-Reply-To: <3650eb44734ad4fbe098313349da8185595a20d8.1421709247.git.chang-joon.lee@intel.com>
References: <3650eb44734ad4fbe098313349da8185595a20d8.1421709247.git.chang-joon.lee@intel.com>
From: Shobhit Kumar <shobhit.kumar@intel.com>
Date: Sun, 5 Oct 2014 18:39:22 +0530
Subject: [PATCH 46/75] MUST_REBASE [VPG]: adf/intel/vlv/dsi: Update the DSI
 sequence to match i915

The DSI earlier sequence pulled in was from upstream i915 driver and
tested only on AusT100. But the internal sequence though deviating from
recommended sequence is working better on Anchor 8 and ECS devices

This patch aligns the ADF driver DSI sequence to be same as that of i915
generic DSI sequence. Will need further analysis.

v2: DSI enable needs REF_A Clock to be turned on. In DPOUnit there  is a FIFO
    which is written in cdclk and read in dotclk. In MIPI mode cdclk isbeing
    fed to dotclk so both read and write are using cdclk. When nothing is
    enabled cdclk trunk is gated off to save power. Only when Ref clock is
    enabeld the cdclk trunk will be enabled

v3: Change symbols so that DSI code can be looked both in ADF and i915

MUST_REBASE: Since Google ADF framework is not in upstream and also
we cannot have two display drivers, other one being i915, we need to
work on i915 and ADF convergence path before it can be upstreamed

For: GMINL-3547
Change-Id: Id65f7e6e3f0a6ec8546faac0442b12cc3a71465d
Signed-off-by: Shobhit Kumar <shobhit.kumar@intel.com>
---
 drivers/video/adf/intel/core/common/Makefile       |    2 +
 .../video/adf/intel/core/common/dsi/dsi_pipe_ops.c |  664 ++++++++++----------
 .../video/adf/intel/core/common/dsi/gen_dsi_pipe.c |   36 +-
 .../video/adf/intel/core/common/dsi/intel_dsi.h    |   45 +-
 .../adf/intel/core/common/dsi/intel_dsi_cmd.c      |   53 +-
 .../adf/intel/core/common/dsi/intel_dsi_cmd.h      |   47 +-
 .../adf/intel/core/common/dsi/intel_dsi_pll.c      |    6 +-
 .../core/common/dsi/panels/intel_dsi_panel_vbt.c   |  128 ++--
 drivers/video/adf/intel/core/vlv/vlv_dc_config.c   |   32 +-
 .../adf/intel/include/core/vlv/vlv_dc_config.h     |    2 +-
 .../video/adf/intel/include/core/vlv/vlv_dc_regs.h |    1 +
 11 files changed, 512 insertions(+), 504 deletions(-)

diff --git a/drivers/video/adf/intel/core/common/Makefile b/drivers/video/adf/intel/core/common/Makefile
index 8ac8402..80f2350 100644
--- a/drivers/video/adf/intel/core/common/Makefile
+++ b/drivers/video/adf/intel/core/common/Makefile
@@ -3,3 +3,5 @@ ccflags-y := -Idrivers/staging/ -Iinclude/adf -Iinclude/uapi/adf -Idrivers/video
 
 obj-$(CONFIG_ADF_INTEL) += backlight_dev.o
 obj-$(CONFIG_ADF_INTEL) += intel_gen_backlight.o
+
+obj-y			+= dsi/
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c b/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
index e08c251..619b0dc 100644
--- a/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
@@ -20,10 +20,11 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  *
+ * Author: Jani Nikula <jani.nikula@intel.com>
  */
 
 #include <drm/i915_drm.h>
-#include <drm/i915_adf_wrapper.h>
+#include <drm/i915_adf.h>
 #include <intel_adf_device.h>
 #include <core/common/dsi/dsi_pipe.h>
 #include <core/common/dsi/dsi_config.h>
@@ -40,11 +41,11 @@
 #define PMIC_BKL_EN		0x4B
 #define PMIC_PWM_LEVEL		0x4E
 
-static void band_gap_reset(void)
+static void band_gap_reset(struct dsi_pipe *dsi_pipe)
 {
 	pr_err("ADF: %s\n", __func__);
 
-	vlv_flisdsi_write(0x0F, 0x0001);
+	vlv_flisdsi_write(0x08, 0x0001);
 	vlv_flisdsi_write(0x0F, 0x0005);
 	vlv_flisdsi_write(0x0F, 0x0025);
 	udelay(150);
@@ -62,107 +63,200 @@ static inline bool is_cmd_mode(struct dsi_config *config)
 	return config->ctx.operation_mode == DSI_DBI;
 }
 
-int intel_dsi_soc_power_on(struct dsi_pipe *dsi_pipe)
+static void intel_adf_dsi_device_ready(struct dsi_pipe *dsi_pipe)
 {
-	pr_err("ADF: %s\n", __func__);
+	int pipe = dsi_pipe->config.pipe;
+	u32 val;
 
-	/*  cabc disable */
-	vlv_gpio_write(PANEL1_VDDEN_GPIONC_9_PCONF0, 0x2000CC00,
-		       IOSF_PORT_GPIO_NC);
-	vlv_gpio_write(PANEL1_VDDEN_GPIONC_9_PAD, 0x00000004,
-		       IOSF_PORT_GPIO_NC);
+	pr_err("ADF: %s\n", __func__);
 
-	/* panel enable */
-	vlv_gpio_write(PANEL1_BKLTCTL_GPIONC_11_PCONF0, 0x2000CC00,
-		       IOSF_PORT_GPIO_NC);
-	vlv_gpio_write(PANEL1_BKLTCTL_GPIONC_11_PAD, 0x00000005,
-		       IOSF_PORT_GPIO_NC);
-	udelay(500);
-	return 0;
+	val = REG_READ(MIPI_PORT_CTRL(pipe));
+	REG_WRITE(MIPI_PORT_CTRL(pipe), val | LP_OUTPUT_HOLD);
+	usleep_range(1000, 1500);
+	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_EXIT);
+	usleep_range(2000, 2500);
+	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY);
+	usleep_range(2000, 2500);
+	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x00);
+	usleep_range(2000, 2500);
+	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY);
+	usleep_range(2000, 2500);
 }
 
-int intel_dsi_pmic_power_on(struct dsi_pipe *dsi_pipe)
+static void intel_adf_dsi_enable(struct dsi_pipe *dsi_pipe)
 {
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	u32 temp;
+
 	pr_err("ADF: %s\n", __func__);
 
-	intel_soc_pmic_writeb(PMIC_PANEL_EN, 0x01);
-	return 0;
+	if (is_cmd_mode(config))
+		REG_WRITE(MIPI_MAX_RETURN_PKT_SIZE(pipe), 8 * 4);
+	else {
+		msleep(20); /* XXX */
+		adf_dpi_send_cmd(dsi_pipe, TURN_ON, DPI_LP_MODE_EN);
+		msleep(100);
+
+		if (panel->ops->power_on)
+			panel->ops->power_on(dsi_pipe);
+
+		/* assert ip_tg_enable signal */
+		temp = REG_READ(MIPI_PORT_CTRL(pipe)) &
+				~LANE_CONFIGURATION_MASK;
+		temp = temp | intel_dsi->port_bits;
+		REG_WRITE(MIPI_PORT_CTRL(pipe), temp | DPI_ENABLE);
+		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
+	}
+
+	if (intel_dsi->backlight_on_delay >= 20)
+		msleep(intel_dsi->backlight_on_delay);
+	else
+		usleep_range(intel_dsi->backlight_on_delay * 1000,
+				(intel_dsi->backlight_on_delay * 1000) + 500);
+
+	intel_enable_backlight(&dsi_pipe->base);
 }
 
-int intel_dsi_soc_power_off(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_soc_power_on(struct dsi_pipe *dsi_pipe)
 {
 	pr_err("ADF: %s\n", __func__);
 
-	vlv_gpio_write(PANEL1_BKLTCTL_GPIONC_11_PCONF0, 0x2000CC00,
-		       IOSF_PORT_GPIO_NC);
-	vlv_gpio_write(PANEL1_BKLTCTL_GPIONC_11_PAD, 0x00000004,
-		       IOSF_PORT_GPIO_NC);
+	/*  cabc disable */
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_VDDEN_GPIONC_9_PCONF0, 0x2000CC00);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_VDDEN_GPIONC_9_PAD, 0x00000004);
+
+	/* panel enable */
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTCTL_GPIONC_11_PCONF0, 0x2000CC00);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTCTL_GPIONC_11_PAD, 0x00000005);
 	udelay(500);
 	return 0;
 }
 
-int intel_dsi_pmic_power_off(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_pmic_power_on(struct dsi_pipe *dsi_pipe)
 {
 	pr_err("ADF: %s\n", __func__);
-
-	intel_soc_pmic_writeb(PMIC_PANEL_EN, 0x00);
+	intel_soc_pmic_writeb(PMIC_PANEL_EN, 0x01);
 	return 0;
 }
 
-int intel_dsi_pmic_backlight_on(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_pre_enable(struct dsi_pipe *dsi_pipe)
 {
-	intel_soc_pmic_writeb(PMIC_BKL_EN, 0xFF);
-	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x01);
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	int pipe = config->pipe;
+	u32 tmp;
 
-	/*
-	 * I2C based control if any was already there
-	 * in seq version < 3, so call that sequence
-	 * here as well
-	 *
-	 * Mainly needed for CHV
-	 */
-	generic_enable_bklt(dsi_pipe);
+	pr_err("ADF: %s\n", __func__);
 
-	return 0;
-}
+	/* Panel Enable */
+	if (panel->ops->panel_power_on)
+		panel->ops->panel_power_on(dsi_pipe);
+
+	msleep(intel_dsi->panel_on_delay);
+
+	/* Disable DPOunit clock gating, can stall pipe
+	* and we need DPLL REFA always enabled */
+	tmp = REG_READ(DPLL(pipe));
+	tmp |= DPLL_REFA_CLK_ENABLE_VLV;
+	REG_WRITE(DPLL(pipe), tmp);
+
+	tmp = REG_READ(DSPCLK_GATE_D);
+	tmp |= DPOUNIT_CLOCK_GATE_DISABLE;
+	REG_WRITE(DSPCLK_GATE_D, tmp);
+
+	if (panel->ops->reset)
+		panel->ops->reset(dsi_pipe);
+
+	/* put device in ready state */
+	intel_adf_dsi_device_ready(dsi_pipe);
+
+	msleep(intel_dsi->panel_on_delay);
+
+	if (panel->ops->drv_ic_init)
+		panel->ops->drv_ic_init(dsi_pipe);
+
+	/* Enable port in pre-enable phase itself because as per hw team
+	 * recommendation, port should be enabled befor plane & pipe */
+	intel_adf_dsi_enable(dsi_pipe);
 
-int intel_dsi_soc_backlight_on(struct dsi_pipe *dsi_pipe)
-{
-	vlv_gpio_write(PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00,
-		       IOSF_PORT_GPIO_NC);
-	vlv_gpio_write(PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000005,
-		       IOSF_PORT_GPIO_NC);
-	udelay(500);
 	return 0;
 }
 
-int intel_dsi_pmic_backlight_off(struct dsi_pipe *dsi_pipe)
+void intel_adf_dsi_pre_disable(struct dsi_pipe *dsi_pipe)
 {
-	/*
-	 * I2C based control if any was already there
-	 * in seq version < 3, so call that sequence
-	 * here as well
-	 *
-	 * Mainly needed for CHV
-	 */
-	generic_disable_bklt(dsi_pipe);
+	struct dsi_config *config = &dsi_pipe->config;
 
-	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x00);
-	intel_soc_pmic_writeb(PMIC_BKL_EN, 0x7F);
-	return 0;
+	pr_err("ADF: %s\n", __func__);
+
+	if (is_vid_mode(config)) {
+		/* Send Shutdown command to the panel in LP mode */
+		adf_dpi_send_cmd(dsi_pipe, SHUTDOWN, DPI_LP_MODE_EN);
+		usleep_range(10000, 10500);
+		pr_err("ADF: %s: Sent DPI_SHUTDOWN\n", __func__);
+	}
 }
 
-int intel_dsi_soc_backlight_off(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_disable(struct dsi_pipe *dsi_pipe)
 {
-	vlv_gpio_write(PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00,
-		       IOSF_PORT_GPIO_NC);
-	vlv_gpio_write(PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000004,
-		       IOSF_PORT_GPIO_NC);
-	udelay(500);
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	int pipe = dsi_pipe->config.pipe;
+	u32 temp;
+
+	pr_err("ADF: %s\n", __func__);
+
+	intel_disable_backlight(&dsi_pipe->base);
+
+	if (intel_dsi->backlight_off_delay >= 20)
+		msleep(intel_dsi->backlight_off_delay);
+	else
+		usleep_range(intel_dsi->backlight_off_delay * 1000,
+				(intel_dsi->backlight_off_delay * 1000) + 500);
+
+	if (is_vid_mode(config)) {
+		/* de-assert ip_tg_enable signal */
+		temp = REG_READ(MIPI_PORT_CTRL(pipe));
+		REG_WRITE(MIPI_PORT_CTRL(pipe), temp & ~DPI_ENABLE);
+		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
+
+		usleep_range(2000, 2500);
+	}
+
+	/* Panel commands can be sent when clock is in LP11 */
+	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x0);
+
+	temp = REG_READ(MIPI_CTRL(pipe));
+	temp &= ~ESCAPE_CLOCK_DIVIDER_MASK;
+	REG_WRITE(MIPI_CTRL(pipe), temp |
+			intel_dsi->escape_clk_div <<
+			ESCAPE_CLOCK_DIVIDER_SHIFT);
+
+	REG_WRITE(MIPI_EOT_DISABLE(pipe), CLOCKSTOP);
+
+	temp = REG_READ(MIPI_DSI_FUNC_PRG(pipe));
+	temp &= ~VID_MODE_FORMAT_MASK;
+	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), temp);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x1);
+
+	/* if disable packets are sent before sending shutdown packet then in
+	 * some next enable sequence send turn on packet error is observed */
+	if (panel->ops->power_off)
+		panel->ops->power_off(dsi_pipe);
+
 	return 0;
 }
 
-static void intel_dsi_device_ready(struct dsi_pipe *dsi_pipe)
+static void intel_adf_dsi_clear_device_ready(struct dsi_pipe *dsi_pipe)
 {
 	int pipe = dsi_pipe->config.pipe;
 	u32 val;
@@ -170,47 +264,100 @@ static void intel_dsi_device_ready(struct dsi_pipe *dsi_pipe)
 	pr_err("ADF: %s\n", __func__);
 
 	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_ENTER);
-	usleep_range(2500, 3000);
+	usleep_range(2000, 2500);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_EXIT);
+	usleep_range(2000, 2500);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_ENTER);
+	usleep_range(2000, 2500);
 
 	val = REG_READ(MIPI_PORT_CTRL(pipe));
-	REG_WRITE(MIPI_PORT_CTRL(pipe), val | LP_OUTPUT_HOLD);
+	REG_WRITE(MIPI_PORT_CTRL(pipe), val & ~LP_OUTPUT_HOLD);
 	usleep_range(1000, 1500);
 
-	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_EXIT);
-	usleep_range(2500, 3000);
+	if (wait_for(((REG_READ(MIPI_PORT_CTRL(pipe)) & AFE_LATCHOUT)
+					== 0x00000), 30))
+		DRM_ERROR("DSI LP not going Low\n");
 
-	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY);
-	usleep_range(2500, 3000);
+	REG_WRITE(MIPI_DEVICE_READY(pipe), 0x00);
+	usleep_range(2000, 2500);
+
+	adf_vlv_disable_dsi_pll(&dsi_pipe->config);
 }
 
-static void intel_dsi_enable(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_soc_power_off(struct dsi_pipe *dsi_pipe)
+{
+	pr_err("ADF: %s\n", __func__);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTCTL_GPIONC_11_PCONF0, 0x2000CC00);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTCTL_GPIONC_11_PAD, 0x00000004);
+	udelay(500);
+	return 0;
+}
+
+int intel_adf_dsi_pmic_power_off(struct dsi_pipe *dsi_pipe)
+{
+	pr_err("ADF: %s\n", __func__);
+	intel_soc_pmic_writeb(PMIC_PANEL_EN, 0x00);
+	return 0;
+}
+
+int intel_adf_dsi_post_disable(struct dsi_pipe *dsi_pipe)
 {
-	struct dsi_config *config = &dsi_pipe->config;
 	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	int pipe = config->pipe;
 	struct dsi_panel *panel = dsi_pipe->panel;
-	u32 temp;
+	u32 val;
 
 	pr_debug("ADF: %s\n", __func__);
-	if (is_cmd_mode(config))
-		REG_WRITE(MIPI_MAX_RETURN_PKT_SIZE(pipe), 8 * 4);
-	else {
-		msleep(20); /* XXX */
-		dpi_send_cmd(dsi_pipe, TURN_ON, DPI_LP_MODE_EN);
-		msleep(100);
 
-		if (panel->ops->power_on)
-			panel->ops->power_on(dsi_pipe);
+	intel_adf_dsi_disable(dsi_pipe);
 
-		wait_for_dsi_fifo_empty(dsi_pipe);
+	intel_adf_dsi_clear_device_ready(dsi_pipe);
 
-		/* assert ip_tg_enable signal */
-		temp = REG_READ(MIPI_PORT_CTRL(pipe)) &
-				~LANE_CONFIGURATION_MASK;
-		temp = temp | intel_dsi->port_bits;
-		REG_WRITE(MIPI_PORT_CTRL(pipe), temp | DPI_ENABLE);
-		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
-	}
+	val = REG_READ(DSPCLK_GATE_D);
+	val &= ~DPOUNIT_CLOCK_GATE_DISABLE;
+	REG_WRITE(DSPCLK_GATE_D, val);
+
+	if (panel->ops->disable_panel_power)
+		panel->ops->disable_panel_power(dsi_pipe);
+
+	/* Disable Panel */
+	if (panel->ops->panel_power_off)
+		panel->ops->panel_power_off(dsi_pipe);
+
+	msleep(intel_dsi->panel_off_delay);
+	msleep(intel_dsi->panel_pwr_cycle_delay);
+
+	return 0;
+}
+
+int intel_adf_dsi_modeset(struct dsi_pipe *dsi_pipe,
+			  struct drm_mode_modeinfo *mode)
+{
+	pr_err("ADF: %s\n", __func__);
+	return 0;
+}
+
+int intel_adf_dsi_set_events(struct dsi_pipe *dsi_pipe, u8 event, bool enabled)
+{
+	return 0;
+}
+
+void intel_adf_dsi_get_events(struct dsi_pipe *dsi_pipe, u32 *events)
+{
+	return;
+}
+
+void intel_adf_dsi_handle_events(struct dsi_pipe *dsi_pipe, u32 events)
+{
+	return;
+}
+
+void intel_adf_dsi_pre_post(struct dsi_pipe *dsi_pipe)
+{
+	return;
 }
 
 /* return txclkesc cycles in terms of divider and duration in us */
@@ -243,17 +390,8 @@ static void set_dsi_timings(struct dsi_pipe *dsi_pipe,
 	int pipe = config->pipe;
 	unsigned int bpp = config->bpp;
 	unsigned int lane_count = intel_dsi->lane_count;
-	u32 val;
-
 	u16 hactive, hfp, hsync, hbp, vfp, vsync, vbp;
 
-	pr_err("ADF: %s\n", __func__);
-
-	/* DEVICE_READY[0] = 0 */
-	val = REG_READ(MIPI_DEVICE_READY(pipe));
-	val &= ~0x1;
-	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
-
 	hactive = mode->hdisplay;
 	hfp = mode->hsync_start - mode->hdisplay;
 	hsync = mode->hsync_end - mode->hsync_start;
@@ -283,49 +421,10 @@ static void set_dsi_timings(struct dsi_pipe *dsi_pipe,
 	REG_WRITE(MIPI_VFP_COUNT(pipe), vfp);
 	REG_WRITE(MIPI_VSYNC_PADDING_COUNT(pipe), vsync);
 	REG_WRITE(MIPI_VBP_COUNT(pipe), vbp);
-
-	val = intel_dsi->lane_count << DATA_LANES_PRG_REG_SHIFT;
-	if (is_cmd_mode(config)) {
-		val |= intel_dsi->channel << CMD_MODE_CHANNEL_NUMBER_SHIFT;
-		val |= CMD_MODE_DATA_WIDTH_8_BIT; /* XXX */
-	} else {
-		val |= intel_dsi->channel << VID_MODE_CHANNEL_NUMBER_SHIFT;
-
-		/* XXX: cross-check bpp vs. pixel format? */
-		val |= intel_dsi->pixel_format;
-	}
-	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), val);
-
-	val = 0;
-	if (intel_dsi->eotp_pkt == 0)
-		val |= EOT_DISABLE;
-
-	if (intel_dsi->clock_stop)
-		val |= CLOCKSTOP;
-
-	/* recovery disables */
-	REG_WRITE(MIPI_EOT_DISABLE(pipe), val);
-
-	/* DEVICE_READY[0] = 1 */
-	val = REG_READ(MIPI_DEVICE_READY(pipe));
-	val |= 0x1;
-	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
-
-	/* XXX: why here, why like this? handling in irq handler?! */
-	REG_WRITE(MIPI_INTR_STAT(pipe), 0xffffffff);
-	REG_WRITE(MIPI_INTR_EN(pipe), 0xffffffff);
-}
-
-int intel_dsi_modeset(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
-{
-	pr_err("ADF: %s\n", __func__);
-
-	vlv_display_off(&dsi_pipe->base);
-
-	return 0;
 }
 
-int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
+int intel_adf_dsi_prepare(struct dsi_pipe *dsi_pipe,
+			  struct drm_mode_modeinfo *mode)
 {
 	struct dsi_config *config = &dsi_pipe->config;
 	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
@@ -333,11 +432,7 @@ int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
 	unsigned int bpp = config->bpp;
 	u32 val, tmp;
 
-	pr_err("ADF: %s\n", __func__);
-
-	val = REG_READ(MIPI_DEVICE_READY(pipe));
-	val &= ~0x1;
-	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
+	pr_err("ADF: %s: pipe %d\n", __func__, pipe);
 
 	/* escape clock divider, 20MHz, shared for A and C. device ready must be
 	 * off when doing this! txclkesc? */
@@ -350,12 +445,30 @@ int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
 	tmp &= ~READ_REQUEST_PRIORITY_MASK;
 	REG_WRITE(MIPI_CTRL(pipe), tmp | READ_REQUEST_PRIORITY_HIGH);
 
+	/* XXX: why here, why like this? handling in irq handler?! */
+	REG_WRITE(MIPI_INTR_STAT(pipe), 0xffffffff);
+	REG_WRITE(MIPI_INTR_EN(pipe), 0xffffffff);
+
 	REG_WRITE(MIPI_DPHY_PARAM(pipe), intel_dsi->dphy_reg);
 
 	REG_WRITE(MIPI_DPI_RESOLUTION(pipe),
 		   mode->vdisplay << VERTICAL_ADDRESS_SHIFT |
 		   mode->hdisplay << HORIZONTAL_ADDRESS_SHIFT);
 
+	set_dsi_timings(dsi_pipe, mode);
+
+	val = intel_dsi->lane_count << DATA_LANES_PRG_REG_SHIFT;
+	if (is_cmd_mode(config)) {
+		val |= intel_dsi->channel << CMD_MODE_CHANNEL_NUMBER_SHIFT;
+		val |= CMD_MODE_DATA_WIDTH_8_BIT; /* XXX */
+	} else {
+		val |= intel_dsi->channel << VID_MODE_CHANNEL_NUMBER_SHIFT;
+
+		/* XXX: cross-check bpp vs. pixel format? */
+		val |= intel_dsi->pixel_format;
+	}
+	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), val);
+
 	/* timeouts for recovery. one frame IIUC. if counter expires, EOT and
 	 * stop state. */
 
@@ -386,8 +499,6 @@ int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
 				       bpp, intel_dsi->lane_count,
 				       intel_dsi->burst_mode_ratio) + 1);
 	}
-
-	REG_WRITE(MIPI_HS_TX_TIMEOUT(pipe), 0x3FFFFF);
 	REG_WRITE(MIPI_LP_RX_TIMEOUT(pipe), intel_dsi->lp_rx_timeout);
 	REG_WRITE(MIPI_TURN_AROUND_TIMEOUT(pipe), intel_dsi->turn_arnd_val);
 	REG_WRITE(MIPI_DEVICE_RESET_TIMER(pipe), intel_dsi->rst_timer_val);
@@ -395,8 +506,18 @@ int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
 	/* dphy stuff */
 
 	/* in terms of low power clock */
-	REG_WRITE(MIPI_INIT_COUNT(pipe),
-				 txclkesc(intel_dsi->escape_clk_div, 100));
+	REG_WRITE(MIPI_INIT_COUNT(pipe), txclkesc(intel_dsi->escape_clk_div,
+						  100));
+
+	val = 0;
+	if (intel_dsi->eotp_pkt == 0)
+		val |= EOT_DISABLE;
+
+	if (intel_dsi->clock_stop)
+		val |= CLOCKSTOP;
+
+	/* recovery disables */
+	REG_WRITE(MIPI_EOT_DISABLE(pipe), val);
 
 	/* in terms of low power clock */
 	REG_WRITE(MIPI_INIT_COUNT(pipe), intel_dsi->init_count);
@@ -407,7 +528,7 @@ int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
 	 * XXX: write MIPI_STOP_STATE_STALL?
 	 */
 	REG_WRITE(MIPI_HIGH_LOW_SWITCH_COUNT(pipe),
-		   intel_dsi->hs_to_lp_count);
+						intel_dsi->hs_to_lp_count);
 
 	/* XXX: low power clock equivalence in terms of byte clock. the number
 	 * of byte clocks occupied in one low power clock. based on txbyteclkhs
@@ -432,243 +553,90 @@ int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
 		 * 64 like 1366 x 768. Enable RANDOM resolution support for such
 		 * panels by default */
 		REG_WRITE(MIPI_VIDEO_MODE_FORMAT(pipe),
-			   intel_dsi->video_frmt_cfg_bits |
-			   intel_dsi->video_mode_format |
-			   IP_TG_CONFIG |
-			   RANDOM_DPI_DISPLAY_RESOLUTION);
-
-	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), 0);
-	REG_WRITE(MIPI_EOT_DISABLE(pipe), CLOCKSTOP);
-
-	val = REG_READ(MIPI_DEVICE_READY(pipe));
-	val |= 0x1;
-	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
+				intel_dsi->video_frmt_cfg_bits |
+				intel_dsi->video_mode_format |
+				IP_TG_CONFIG |
+				RANDOM_DPI_DISPLAY_RESOLUTION);
 
 	return 0;
 }
 
-static void intel_dsi_pre_pll_enable(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_pre_pll_enable(struct dsi_pipe *dsi_pipe)
 {
-	pr_debug("ADF: %s\n", __func__);
-	vlv_enable_dsi_pll(&dsi_pipe->config);
-}
-
-int intel_dsi_pre_enable(struct dsi_pipe *dsi_pipe)
-{
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	struct dsi_config *config = &dsi_pipe->config;
 	struct dsi_panel *panel = dsi_pipe->panel;
-	int pipe = dsi_pipe->config.pipe;
-	u32 tmp;
 	struct drm_mode_modeinfo mode;
+	int pipe = config->pipe;
+	u32 tmp;
 
 	pr_err("ADF: %s\n", __func__);
 
+	/*
+	 * FIXME:
+	 * get the mode; works for DSI as only one mode
+	 */
+	panel->ops->get_config_mode(&dsi_pipe->config, &mode);
+	intel_adf_dsi_prepare(dsi_pipe, &mode);
+
 	/* program rcomp for compliance, reduce from 50 ohms to 45 ohms
 	 * needed everytime after power gate */
 	vlv_flisdsi_write(0x04, 0x0004);
 
 	/* bandgap reset is needed after everytime we do power gate */
-	band_gap_reset();
-
-	/*
-	 * Panel power control using PMIC/LPIO
-	 */
-	if (panel->ops->panel_power_on)
-		panel->ops->panel_power_on(dsi_pipe);
+	band_gap_reset(dsi_pipe);
 
-	msleep(intel_dsi->panel_on_delay);
-
-	if (panel->ops->reset)
-		panel->ops->reset(dsi_pipe);
-
-	/* Disable DPOunit clock gating, can stall pipe
-	 * and we need DPLL REFA always enabled */
+	/* Disable DPOunit clock gating, can stall pipe */
 	tmp = REG_READ(DPLL(pipe));
-	tmp |= DPLL_REFA_CLK_ENABLE_VLV;
+	tmp |= DPLL_RESERVED_BIT;
 	REG_WRITE(DPLL(pipe), tmp);
 
 	tmp = REG_READ(DSPCLK_GATE_D);
-	tmp |= DPOUNIT_CLOCK_GATE_DISABLE;
+	tmp |= VSUNIT_CLOCK_GATE_DISABLE;
 	REG_WRITE(DSPCLK_GATE_D, tmp);
 
-	intel_dsi_pre_pll_enable(dsi_pipe);
-
-	/* put device in ready state */
-	intel_dsi_device_ready(dsi_pipe);
-
-	/*
-	 * FIXME:
-	 * get the mode; works for DSI as only one mode
-	 */
-	panel->ops->get_config_mode(&dsi_pipe->config, &mode);
-
-	intel_dsi_prepare(dsi_pipe, &mode);
-
-	if (panel->ops->drv_ic_init)
-		panel->ops->drv_ic_init(dsi_pipe);
-
-	wait_for_dsi_fifo_empty(dsi_pipe);
+	adf_vlv_enable_dsi_pll(&dsi_pipe->config);
 
-	set_dsi_timings(dsi_pipe, &mode);
-
-	/* Enable port in pre-enable phase itself because as per hw team
-	 * recommendation, port should be enabled befor plane & pipe */
-	intel_dsi_enable(dsi_pipe);
-
-	/* Enabling the backlight */
-	intel_enable_backlight(&dsi_pipe->base);
+	intel_adf_dsi_pre_enable(dsi_pipe);
 
 	return 0;
 }
 
-void intel_dsi_pre_disable(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_pmic_backlight_on(struct dsi_pipe *dsi_pipe)
 {
-	struct dsi_config *config = &dsi_pipe->config;
-
-	pr_debug("ADF: %s\n", __func__);
-
-	intel_disable_backlight(&dsi_pipe->base);
-
-	if (is_vid_mode(config)) {
-		/* Send Shutdown command to the panel in LP mode */
-		dpi_send_cmd(dsi_pipe, SHUTDOWN, DPI_LP_MODE_EN);
-		usleep_range(10000, 10500);
-		pr_err("ADF: %s: Sent DPI_SHUTDOWN\n", __func__);
-	}
-}
-
-int intel_dsi_disable(struct dsi_pipe *dsi_pipe)
-{
-	struct dsi_config *config = &dsi_pipe->config;
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	struct dsi_panel *panel = dsi_pipe->panel;
-	int pipe = dsi_pipe->config.pipe;
-	u32 temp;
-
-	pr_err("ADF: %s\n", __func__);
-
-	if (is_vid_mode(config)) {
-		wait_for_dsi_fifo_empty(dsi_pipe);
-
-		/* de-assert ip_tg_enable signal */
-		temp = REG_READ(MIPI_PORT_CTRL(pipe));
-		REG_WRITE(MIPI_PORT_CTRL(pipe), temp & ~DPI_ENABLE);
-		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
-
-		usleep_range(2000, 2500);
-	}
-
-	/* Panel commands can be sent when clock is in LP11 */
-	temp = REG_READ(MIPI_DEVICE_READY(pipe));
-	temp &= ~0x1;
-	REG_WRITE(MIPI_DEVICE_READY(pipe), temp);
-
-	temp = REG_READ(MIPI_CTRL(pipe));
-	temp &= ~ESCAPE_CLOCK_DIVIDER_MASK;
-	REG_WRITE(MIPI_CTRL(pipe), temp |
-		   intel_dsi->escape_clk_div <<
-		   ESCAPE_CLOCK_DIVIDER_SHIFT);
-
-	/*
-	 * FIXME:
-	 * Writing 0 here works but we get LP not going low error
-	temp = REG_READ(MIPI_DSI_FUNC_PRG(pipe));
-	temp &= ~VID_MODE_FORMAT_MASK;
-	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), temp);
-	*/
-	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), 0);
-
-	REG_WRITE(MIPI_EOT_DISABLE(pipe), CLOCKSTOP);
-
-	temp = REG_READ(MIPI_DEVICE_READY(pipe));
-	temp |= 0x1;
-	REG_WRITE(MIPI_DEVICE_READY(pipe), temp);
-
-	/* if disable packets are sent before sending shutdown packet then in
-	 * some next enable sequence send turn on packet error is observed */
-	if (panel->ops->power_off)
-		panel->ops->power_off(dsi_pipe);
-
-	wait_for_dsi_fifo_empty(dsi_pipe);
+	intel_soc_pmic_writeb(PMIC_BKL_EN, 0xFF);
+	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x01);
 
+	panel_generic_enable_bklt(dsi_pipe);
 	return 0;
 }
 
-static void intel_dsi_clear_device_ready(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_soc_backlight_on(struct dsi_pipe *dsi_pipe)
 {
-	int pipe = dsi_pipe->config.pipe;
-	u32 val;
-	pr_debug("ADF: %s\n", __func__);
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_ENTER);
-	usleep_range(2000, 2500);
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_EXIT);
-	usleep_range(2000, 2500);
-
-	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_ENTER);
-	usleep_range(2000, 2500);
-
-	if (wait_for(((REG_READ(MIPI_PORT_CTRL(pipe)) & AFE_LATCHOUT)
-		      == 0x00000), 30))
-		DRM_ERROR("DSI LP not going Low\n");
-
-	val = REG_READ(MIPI_PORT_CTRL(pipe));
-	REG_WRITE(MIPI_PORT_CTRL(pipe), val & ~LP_OUTPUT_HOLD);
-	usleep_range(1000, 1500);
-
-	val = REG_READ(MIPI_DEVICE_READY(pipe));
-	val &= ~0x1;
-	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
-	usleep_range(2000, 2500);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000005);
+	udelay(500);
 
-	vlv_disable_dsi_pll(&dsi_pipe->config);
+	return 0;
 }
 
-int intel_dsi_post_disable(struct dsi_pipe *dsi_pipe)
+int intel_adf_dsi_pmic_backlight_off(struct dsi_pipe *dsi_pipe)
 {
-	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
-	struct dsi_panel *panel = dsi_pipe->panel;
-	u32 val;
-
-	pr_debug("ADF: %s\n", __func__);
-	intel_dsi_disable(dsi_pipe);
+	panel_generic_disable_bklt(dsi_pipe);
 
-	intel_dsi_clear_device_ready(dsi_pipe);
-
-	val = REG_READ(DSPCLK_GATE_D);
-	val &= ~DPOUNIT_CLOCK_GATE_DISABLE;
-	REG_WRITE(DSPCLK_GATE_D, val);
-
-	if (panel->ops->disable_panel_power)
-		panel->ops->disable_panel_power(dsi_pipe);
-
-	/* Panel power off control using PMIC/LPIO */
-	if (panel->ops->panel_power_off)
-		panel->ops->panel_power_off(dsi_pipe);
-
-	msleep(intel_dsi->panel_off_delay);
-	msleep(intel_dsi->panel_pwr_cycle_delay);
+	intel_soc_pmic_writeb(PMIC_PWM_EN, 0x00);
+	intel_soc_pmic_writeb(PMIC_BKL_EN, 0x7F);
 
 	return 0;
 }
 
-int intel_dsi_set_events(struct dsi_pipe *dsi_pipe, u8 event, bool enabled)
+int intel_adf_dsi_soc_backlight_off(struct dsi_pipe *dsi_pipe)
 {
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PCONF0, 0x2000CC00);
+	vlv_gpio_write(IOSF_PORT_GPIO_NC,
+			PANEL1_BKLTEN_GPIONC_10_PAD, 0x00000004);
+	udelay(500);
 	return 0;
 }
-
-void intel_dsi_get_events(struct dsi_pipe *dsi_pipe, u32 *events)
-{
-	return;
-}
-
-void intel_dsi_handle_events(struct dsi_pipe *dsi_pipe, u32 events)
-{
-	return;
-}
-
-void intel_dsi_pre_post(struct dsi_pipe *dsi_pipe)
-{
-	return;
-}
diff --git a/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c b/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
index 37a49d9..2b7fd48 100644
--- a/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
+++ b/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
@@ -461,20 +461,24 @@ int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 		 */
 		if (vbt->config->pwm_blc) {
 			/* using SOC PWM */
-			panel->ops->panel_power_on = intel_dsi_soc_power_on;
-			panel->ops->panel_power_off = intel_dsi_soc_power_off;
+			panel->ops->panel_power_on =
+					intel_adf_dsi_soc_power_on;
+			panel->ops->panel_power_off =
+					intel_adf_dsi_soc_power_off;
 			panel->ops->enable_backlight =
-						intel_dsi_soc_backlight_on;
+					intel_adf_dsi_soc_backlight_on;
 			panel->ops->disable_backlight =
-						intel_dsi_soc_backlight_off;
+					intel_adf_dsi_soc_backlight_off;
 		} else {
 			/* Using PMIC */
-			panel->ops->panel_power_on = intel_dsi_pmic_power_on;
-			panel->ops->panel_power_off = intel_dsi_pmic_power_off;
+			panel->ops->panel_power_on =
+					intel_adf_dsi_pmic_power_on;
+			panel->ops->panel_power_off =
+					intel_adf_dsi_pmic_power_off;
 			panel->ops->enable_backlight =
-						intel_dsi_pmic_backlight_on;
+					intel_adf_dsi_pmic_backlight_on;
 			panel->ops->disable_backlight =
-						intel_dsi_pmic_backlight_off;
+					intel_adf_dsi_pmic_backlight_off;
 		}
 	}
 
@@ -484,14 +488,14 @@ int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 		goto err;
 
 	/*init dsi interface ops*/
-	pipe->ops.power_on = intel_dsi_pre_enable;
-	pipe->ops.pre_power_off = intel_dsi_pre_disable;
-	pipe->ops.power_off = intel_dsi_post_disable;
-	pipe->ops.mode_set = intel_dsi_modeset;
-	pipe->ops.pre_post = intel_dsi_pre_post;
-	pipe->ops.set_event = intel_dsi_set_events;
-	pipe->ops.get_events = intel_dsi_get_events;
-	pipe->ops.handle_events = intel_dsi_handle_events;
+	pipe->ops.power_on = intel_adf_dsi_pre_pll_enable;
+	pipe->ops.pre_power_off = intel_adf_dsi_pre_disable;
+	pipe->ops.power_off = intel_adf_dsi_post_disable;
+	pipe->ops.mode_set = intel_adf_dsi_modeset;
+	pipe->ops.pre_post = intel_adf_dsi_pre_post;
+	pipe->ops.set_event = intel_adf_dsi_set_events;
+	pipe->ops.get_events = intel_adf_dsi_get_events;
+	pipe->ops.handle_events = intel_adf_dsi_handle_events;
 	pipe->dpms_state = DRM_MODE_DPMS_OFF;
 
 	pipe->panel = panel;
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi.h b/drivers/video/adf/intel/core/common/dsi/intel_dsi.h
index 6586d1c..5acc9b0 100644
--- a/drivers/video/adf/intel/core/common/dsi/intel_dsi.h
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi.h
@@ -27,31 +27,32 @@
 #define INTEL_SIDEBAND_REG_READ		0
 #define INTEL_SIDEBAND_REG_WRITE	1
 
-extern void vlv_enable_dsi_pll(struct dsi_config *);
-extern void vlv_disable_dsi_pll(struct dsi_config *);
-extern u32 vlv_get_dsi_pclk(struct dsi_config *, int pipe_bpp);
+extern void adf_vlv_enable_dsi_pll(struct dsi_config *);
+extern void adf_vlv_disable_dsi_pll(struct dsi_config *);
+extern u32 adf_vlv_get_dsi_pclk(struct dsi_config *, int pipe_bpp);
 
-extern int intel_dsi_pre_enable(struct dsi_pipe *dsi_pipe);
-extern void intel_dsi_pre_post(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_post_disable(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_prepare(struct dsi_pipe *dsi_pipe,
+extern int intel_adf_dsi_pre_pll_enable(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_pre_enable(struct dsi_pipe *dsi_pipe);
+extern void intel_adf_dsi_pre_post(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_post_disable(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_prepare(struct dsi_pipe *dsi_pipe,
 						struct drm_mode_modeinfo *mode);
-extern int intel_dsi_set_events(struct dsi_pipe *dsi_pipe, u8 event,
+extern int intel_adf_dsi_set_events(struct dsi_pipe *dsi_pipe, u8 event,
 						bool enabled);
-extern void intel_dsi_get_events(struct dsi_pipe *dsi_pipe, u32 *events);
-extern void intel_dsi_handle_events(struct dsi_pipe *dsi_pipe, u32 events);
-extern void intel_dsi_pre_disable(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_modeset(struct dsi_pipe *dsi_pipe,
+extern void intel_adf_dsi_get_events(struct dsi_pipe *dsi_pipe, u32 *events);
+extern void intel_adf_dsi_handle_events(struct dsi_pipe *dsi_pipe, u32 events);
+extern void intel_adf_dsi_pre_disable(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_modeset(struct dsi_pipe *dsi_pipe,
 						struct drm_mode_modeinfo *mode);
 
-extern int intel_dsi_soc_power_on(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_pmic_power_on(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_soc_power_off(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_pmic_power_off(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_pmic_backlight_on(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_soc_backlight_on(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_pmic_backlight_off(struct dsi_pipe *dsi_pipe);
-extern int intel_dsi_soc_backlight_off(struct dsi_pipe *dsi_pipe);
-extern int generic_enable_bklt(struct dsi_pipe *interface);
-extern int generic_disable_bklt(struct dsi_pipe *interface);
+extern int intel_adf_dsi_soc_power_on(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_pmic_power_on(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_soc_power_off(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_pmic_power_off(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_pmic_backlight_on(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_soc_backlight_on(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_pmic_backlight_off(struct dsi_pipe *dsi_pipe);
+extern int intel_adf_dsi_soc_backlight_off(struct dsi_pipe *dsi_pipe);
+extern int panel_generic_enable_bklt(struct dsi_pipe *interface);
+extern int panel_generic_disable_bklt(struct dsi_pipe *interface);
 #endif /* _INTEL_DSI_H */
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c
index 0d13958..1b87893 100644
--- a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c
@@ -99,7 +99,7 @@ enum dsi_type {
 };
 
 /* enable or disable command mode hs transmissions */
-void dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable)
+void adf_dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable)
 {
 	struct dsi_config *config = &dsi_pipe->config;
 	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
@@ -118,7 +118,7 @@ void dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable)
 	intel_dsi->hs = enable;
 }
 
-static int dsi_vc_send_short(struct dsi_pipe *dsi_pipe, int channel,
+static int adf_dsi_vc_send_short(struct dsi_pipe *dsi_pipe, int channel,
 			     u8 data_type, u16 data)
 {
 	struct dsi_config *config = &dsi_pipe->config;
@@ -158,7 +158,7 @@ static int dsi_vc_send_short(struct dsi_pipe *dsi_pipe, int channel,
 	return 0;
 }
 
-static int dsi_vc_send_long(struct dsi_pipe *dsi_pipe, int channel,
+static int adf_dsi_vc_send_long(struct dsi_pipe *dsi_pipe, int channel,
 			    u8 data_type, const u8 *data, int len)
 {
 	struct dsi_config *config = &dsi_pipe->config;
@@ -194,10 +194,10 @@ static int dsi_vc_send_long(struct dsi_pipe *dsi_pipe, int channel,
 		 * dwords, then wait for not set, then continue. */
 	}
 
-	return dsi_vc_send_short(dsi_pipe, channel, data_type, len);
+	return adf_dsi_vc_send_short(dsi_pipe, channel, data_type, len);
 }
 
-static int dsi_vc_write_common(struct dsi_pipe *dsi_pipe,
+static int adf_dsi_vc_write_common(struct dsi_pipe *dsi_pipe,
 			       int channel, const u8 *data, int len,
 			       enum dsi_type type)
 {
@@ -205,22 +205,22 @@ static int dsi_vc_write_common(struct dsi_pipe *dsi_pipe,
 
 	if (len == 0) {
 		BUG_ON(type == DSI_GENERIC);
-		ret = dsi_vc_send_short(dsi_pipe, channel,
+		ret = adf_dsi_vc_send_short(dsi_pipe, channel,
 					MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM,
 					0);
 	} else if (len == 1) {
-		ret = dsi_vc_send_short(dsi_pipe, channel,
+		ret = adf_dsi_vc_send_short(dsi_pipe, channel,
 					type == DSI_GENERIC ?
 					MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM :
 					MIPI_DSI_DCS_SHORT_WRITE, data[0]);
 	} else if (len == 2) {
-		ret = dsi_vc_send_short(dsi_pipe, channel,
+		ret = adf_dsi_vc_send_short(dsi_pipe, channel,
 					type == DSI_GENERIC ?
 					MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM :
 					MIPI_DSI_DCS_SHORT_WRITE_PARAM,
 					(data[1] << 8) | data[0]);
 	} else {
-		ret = dsi_vc_send_long(dsi_pipe, channel,
+		ret = adf_dsi_vc_send_long(dsi_pipe, channel,
 				       type == DSI_GENERIC ?
 				       MIPI_DSI_GENERIC_LONG_WRITE :
 				       MIPI_DSI_DCS_LONG_WRITE, data, len);
@@ -229,26 +229,27 @@ static int dsi_vc_write_common(struct dsi_pipe *dsi_pipe,
 	return ret;
 }
 
-int dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
+int adf_dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
 		     const u8 *data, int len)
 {
-	return dsi_vc_write_common(dsi_pipe, channel, data, len, DSI_DCS);
+	return adf_dsi_vc_write_common(dsi_pipe, channel, data, len, DSI_DCS);
 }
 
-int dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
+int adf_dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
 			 const u8 *data, int len)
 {
-	return dsi_vc_write_common(dsi_pipe, channel, data, len, DSI_GENERIC);
+	return adf_dsi_vc_write_common(dsi_pipe, channel, data,
+				       len, DSI_GENERIC);
 }
 
-static int dsi_vc_dcs_send_read_request(struct dsi_pipe *dsi_pipe,
+static int adf_dsi_vc_dcs_send_read_request(struct dsi_pipe *dsi_pipe,
 					int channel, u8 dcs_cmd)
 {
-	return dsi_vc_send_short(dsi_pipe, channel, MIPI_DSI_DCS_READ,
+	return adf_dsi_vc_send_short(dsi_pipe, channel, MIPI_DSI_DCS_READ,
 				 dcs_cmd);
 }
 
-static int dsi_vc_generic_send_read_request(struct dsi_pipe *dsi_pipe,
+static int adf_dsi_vc_generic_send_read_request(struct dsi_pipe *dsi_pipe,
 					    int channel, u8 *reqdata,
 					    int reqlen)
 {
@@ -272,10 +273,10 @@ static int dsi_vc_generic_send_read_request(struct dsi_pipe *dsi_pipe,
 		BUG();
 	}
 
-	return dsi_vc_send_short(dsi_pipe, channel, data_type, data);
+	return adf_dsi_vc_send_short(dsi_pipe, channel, data_type, data);
 }
 
-static int dsi_read_data_return(struct dsi_pipe *dsi_pipe,
+static int adf_dsi_read_data_return(struct dsi_pipe *dsi_pipe,
 				u8 *buf, int buflen)
 {
 	struct dsi_config *config = &dsi_pipe->config;
@@ -298,7 +299,7 @@ static int dsi_read_data_return(struct dsi_pipe *dsi_pipe,
 	return len;
 }
 
-int dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
+int adf_dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
 		    u8 *buf, int buflen)
 {
 	struct dsi_config *config = &dsi_pipe->config;
@@ -313,7 +314,7 @@ int dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
 
 	REG_WRITE(MIPI_INTR_STAT(pipe), GEN_READ_DATA_AVAIL);
 
-	ret = dsi_vc_dcs_send_read_request(dsi_pipe, channel, dcs_cmd);
+	ret = adf_dsi_vc_dcs_send_read_request(dsi_pipe, channel, dcs_cmd);
 	if (ret)
 		return ret;
 
@@ -321,7 +322,7 @@ int dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
 	if (wait_for((REG_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 50))
 		DRM_ERROR("Timeout waiting for read data.\n");
 
-	ret = dsi_read_data_return(dsi_pipe, buf, buflen);
+	ret = adf_dsi_read_data_return(dsi_pipe, buf, buflen);
 	if (ret < 0)
 		return ret;
 
@@ -331,7 +332,7 @@ int dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
 	return 0;
 }
 
-int dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
+int adf_dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
 			u8 *reqdata, int reqlen, u8 *buf, int buflen)
 {
 	struct dsi_config *config = &dsi_pipe->config;
@@ -346,7 +347,7 @@ int dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
 
 	REG_WRITE(MIPI_INTR_STAT(pipe), GEN_READ_DATA_AVAIL);
 
-	ret = dsi_vc_generic_send_read_request(dsi_pipe, channel, reqdata,
+	ret = adf_dsi_vc_generic_send_read_request(dsi_pipe, channel, reqdata,
 					       reqlen);
 	if (ret)
 		return ret;
@@ -355,7 +356,7 @@ int dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
 	if (wait_for((REG_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 50))
 		pr_err("Timeout waiting for read data.\n");
 
-	ret = dsi_read_data_return(dsi_pipe, buf, buflen);
+	ret = adf_dsi_read_data_return(dsi_pipe, buf, buflen);
 	if (ret < 0)
 		return ret;
 
@@ -370,7 +371,7 @@ int dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
  *
  * XXX: commands with data in MIPI_DPI_DATA?
  */
-int dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs)
+int adf_dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs)
 {
 	struct dsi_config *config = &dsi_pipe->config;
 	int pipe = config->pipe;
@@ -398,7 +399,7 @@ int dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs)
 	return 0;
 }
 
-void wait_for_dsi_fifo_empty(struct dsi_pipe *dsi_pipe)
+void adf_wait_for_dsi_fifo_empty(struct dsi_pipe *dsi_pipe)
 {
 	struct dsi_config *config = &dsi_pipe->config;
 	int pipe = config->pipe;
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
index d00b41f..7aa0ca9 100644
--- a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
@@ -36,77 +36,78 @@
 #define DPI_LP_MODE_EN	false
 #define DPI_HS_MODE_EN	true
 
-void dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable);
+void adf_dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable);
 
-int dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
+int adf_dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
 		     const u8 *data, int len);
 
-int dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
+int adf_dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
 			 const u8 *data, int len);
 
-int dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
+int adf_dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
 		    u8 *buf, int buflen);
 
-int dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
+int adf_dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
 			u8 *reqdata, int reqlen, u8 *buf, int buflen);
 
-int dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs);
-void wait_for_dsi_fifo_empty(struct dsi_pipe *dsi_pipe);
+int adf_dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs);
+void adf_wait_for_dsi_fifo_empty(struct dsi_pipe *dsi_pipe);
 
 /* XXX: questionable write helpers */
-static inline int dsi_vc_dcs_write_0(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_dcs_write_0(struct dsi_pipe *dsi_pipe,
 				     int channel, u8 dcs_cmd)
 {
-	return dsi_vc_dcs_write(dsi_pipe, channel, &dcs_cmd, 1);
+	return adf_dsi_vc_dcs_write(dsi_pipe, channel, &dcs_cmd, 1);
 }
 
-static inline int dsi_vc_dcs_write_1(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_dcs_write_1(struct dsi_pipe *dsi_pipe,
 				     int channel, u8 dcs_cmd, u8 param)
 {
 	u8 buf[2] = { dcs_cmd, param };
-	return dsi_vc_dcs_write(dsi_pipe, channel, buf, 2);
+	return adf_dsi_vc_dcs_write(dsi_pipe, channel, buf, 2);
 }
 
-static inline int dsi_vc_generic_write_0(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_generic_write_0(struct dsi_pipe *dsi_pipe,
 					 int channel)
 {
-	return dsi_vc_generic_write(dsi_pipe, channel, NULL, 0);
+	return adf_dsi_vc_generic_write(dsi_pipe, channel, NULL, 0);
 }
 
-static inline int dsi_vc_generic_write_1(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_generic_write_1(struct dsi_pipe *dsi_pipe,
 					 int channel, u8 param)
 {
-	return dsi_vc_generic_write(dsi_pipe, channel, &param, 1);
+	return adf_dsi_vc_generic_write(dsi_pipe, channel, &param, 1);
 }
 
-static inline int dsi_vc_generic_write_2(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_generic_write_2(struct dsi_pipe *dsi_pipe,
 					 int channel, u8 param1, u8 param2)
 {
 	u8 buf[2] = { param1, param2 };
-	return dsi_vc_generic_write(dsi_pipe, channel, buf, 2);
+	return adf_dsi_vc_generic_write(dsi_pipe, channel, buf, 2);
 }
 
 /* XXX: questionable read helpers */
-static inline int dsi_vc_generic_read_0(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_generic_read_0(struct dsi_pipe *dsi_pipe,
 					int channel, u8 *buf, int buflen)
 {
-	return dsi_vc_generic_read(dsi_pipe, channel, NULL, 0, buf, buflen);
+	return adf_dsi_vc_generic_read(dsi_pipe, channel, NULL, 0, buf, buflen);
 }
 
-static inline int dsi_vc_generic_read_1(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_generic_read_1(struct dsi_pipe *dsi_pipe,
 					int channel, u8 param, u8 *buf,
 					int buflen)
 {
-	return dsi_vc_generic_read(dsi_pipe, channel, &param, 1, buf, buflen);
+	return adf_dsi_vc_generic_read(dsi_pipe, channel, &param,
+				       1, buf, buflen);
 }
 
-static inline int dsi_vc_generic_read_2(struct dsi_pipe *dsi_pipe,
+static inline int adf_dsi_vc_generic_read_2(struct dsi_pipe *dsi_pipe,
 					int channel, u8 param1, u8 param2,
 					u8 *buf, int buflen)
 {
 	u8 req[2] = { param1, param2 };
 
-	return dsi_vc_generic_read(dsi_pipe, channel, req, 2, buf, buflen);
+	return adf_dsi_vc_generic_read(dsi_pipe, channel, req, 2, buf, buflen);
 }
 
 
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c b/drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c
index b0d0da7..1e3fe08 100644
--- a/drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c
@@ -29,7 +29,7 @@
 #include <linux/delay.h>
 #include <drm/drmP.h>
 #include <drm/i915_drm.h>
-#include <drm/i915_adf_wrapper.h>
+#include <drm/i915_adf.h>
 #include <intel_adf_device.h>
 #include <core/common/dsi/dsi_pipe.h>
 #include <core/common/dsi/dsi_config.h>
@@ -172,7 +172,7 @@ static void vlv_configure_dsi_pll(struct dsi_config *config)
 	vlv_cck_write(CCK_REG_DSI_PLL_CONTROL, dsi_mnp.dsi_pll_ctrl);
 }
 
-void vlv_enable_dsi_pll(struct dsi_config *config)
+void adf_vlv_enable_dsi_pll(struct dsi_config *config)
 {
 	u32 tmp;
 	int pipe = config->pipe;
@@ -194,7 +194,7 @@ void vlv_enable_dsi_pll(struct dsi_config *config)
 	pr_info("DSI PLL locked\n");
 }
 
-void vlv_disable_dsi_pll(struct dsi_config *config)
+void adf_vlv_disable_dsi_pll(struct dsi_config *config)
 {
 	u32 tmp;
 	tmp = vlv_cck_read(CCK_REG_DSI_PLL_CONTROL);
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c b/drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c
index 9d75735..c18c9c2 100644
--- a/drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c
+++ b/drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c
@@ -28,7 +28,7 @@
 #include <video/mipi_display.h>
 #include <asm/intel-mid.h>
 #include <drm/i915_drm.h>
-#include <drm/i915_adf_wrapper.h>
+#include <drm/i915_adf.h>
 #include <core/common/dsi/dsi_config.h>
 #include <core/common/dsi/dsi_pipe.h>
 #include <core/common/dsi/dsi_panel.h>
@@ -258,13 +258,13 @@ static u8 *mipi_exec_send_packet(struct dsi_pipe *dsi_pipe, u8 *data)
 
 	switch (type) {
 	case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
-		dsi_vc_generic_write_0(dsi_pipe, vc);
+		adf_dsi_vc_generic_write_0(dsi_pipe, vc);
 		break;
 	case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
-		dsi_vc_generic_write_1(dsi_pipe, vc, *data);
+		adf_dsi_vc_generic_write_1(dsi_pipe, vc, *data);
 		break;
 	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
-		dsi_vc_generic_write_2(dsi_pipe, vc, *data, *(data + 1));
+		adf_dsi_vc_generic_write_2(dsi_pipe, vc, *data, *(data + 1));
 		break;
 	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
 	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
@@ -272,19 +272,19 @@ static u8 *mipi_exec_send_packet(struct dsi_pipe *dsi_pipe, u8 *data)
 		pr_debug("Generic Read not yet implemented or used\n");
 		break;
 	case MIPI_DSI_GENERIC_LONG_WRITE:
-		dsi_vc_generic_write(dsi_pipe, vc, data, len);
+		adf_dsi_vc_generic_write(dsi_pipe, vc, data, len);
 		break;
 	case MIPI_DSI_DCS_SHORT_WRITE:
-		dsi_vc_dcs_write_0(dsi_pipe, vc, *data);
+		adf_dsi_vc_dcs_write_0(dsi_pipe, vc, *data);
 		break;
 	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
-		dsi_vc_dcs_write_1(dsi_pipe, vc, *data, *(data + 1));
+		adf_dsi_vc_dcs_write_1(dsi_pipe, vc, *data, *(data + 1));
 		break;
 	case MIPI_DSI_DCS_READ:
 		pr_debug("DCS Read not yet implemented or used\n");
 		break;
 	case MIPI_DSI_DCS_LONG_WRITE:
-		dsi_vc_dcs_write(dsi_pipe, vc, data, len);
+		adf_dsi_vc_dcs_write(dsi_pipe, vc, data, len);
 		break;
 	}
 
@@ -342,14 +342,14 @@ static u8 *mipi_exec_gpio(struct dsi_pipe *dsi_pipe, u8 *data)
 	if (!gtable[gpio].init) {
 		/* program the function */
 		/* FIXME: remove constant below */
-		vlv_gpio_write(function, 0x2000CC00, port);
+		vlv_gpio_write(port, function, 0x2000CC00);
 		gtable[gpio].init = 1;
 	}
 
 	val = 0x4 | action;
 
 	/* pull up/down */
-	vlv_gpio_write(pad, val, port);
+	vlv_gpio_write(port, pad, val);
 
 	return data;
 }
@@ -485,7 +485,8 @@ static const char * const seq_name[] = {
 	"MIPI_SEQ_PANEL_OFF"
 };
 
-static void generic_exec_sequence(struct dsi_pipe *dsi_pipe, char *sequence)
+static void panel_generic_exec_sequence(struct dsi_pipe *dsi_pipe,
+					char *sequence)
 {
 	u8 *data = sequence;
 	fn_mipi_elem_exec mipi_elem_exec;
@@ -533,7 +534,7 @@ static void generic_exec_sequence(struct dsi_pipe *dsi_pipe, char *sequence)
 	}
 }
 
-static int generic_init(struct dsi_pipe *pipe)
+static int panel_generic_init(struct dsi_pipe *pipe)
 {
 	struct dsi_config *dsi_config = &pipe->config;
 	struct dsi_context *intel_dsi = &dsi_config->ctx;
@@ -555,7 +556,7 @@ static int generic_init(struct dsi_pipe *pipe)
 	pr_debug("ADF: %s\n", __func__);
 
 	/* get the VBT parsed MIPI data and support mode from i915 wrapper */
-	intel_get_dsi_vbt_data((void **)&dsi_vbt, &mode);
+	intel_adf_get_dsi_vbt_data((void **)&dsi_vbt, &mode);
 	if (!dsi_vbt || !mode) {
 		pr_err("ADF: %s: No VBT data from i915\n", __func__);
 		return -1;
@@ -820,127 +821,127 @@ static int generic_init(struct dsi_pipe *pipe)
 }
 
 #if 0
-static int generic_mode_valid(struct intel_dsi_device *dsi,
+static int panel_generic_mode_valid(struct intel_dsi_device *dsi,
 		   struct drm_display_mode *mode)
 {
 	return MODE_OK;
 }
 
-static bool generic_mode_fixup(struct intel_dsi_device *dsi,
+static bool panel_generic_mode_fixup(struct intel_dsi_device *dsi,
 		    const struct drm_display_mode *mode,
 		    struct drm_display_mode *adjusted_mode) {
 	return true;
 }
 #endif
 
-static int generic_panel_reset(struct dsi_pipe *interface)
+static int panel_generic_panel_reset(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_ASSERT_RESET];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 
 	return 0;
 }
 
-static int generic_disable_panel_power(struct dsi_pipe *interface)
+static int panel_generic_disable_panel_power(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_DEASSERT_RESET];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 	return 0;
 }
 
-static int generic_send_otp_cmds(struct dsi_pipe *interface)
+static int panel_generic_send_otp_cmds(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_INIT_OTP];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 
 	return 0;
 }
 
-static int generic_enable(struct dsi_pipe *interface)
+static int panel_generic_enable(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_DISPLAY_ON];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 
 	return 0;
 }
 
-static int generic_disable(struct dsi_pipe *interface)
+static int panel_generic_disable(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_DISPLAY_OFF];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 
 	return 0;
 }
 
-int generic_enable_bklt(struct dsi_pipe *interface)
+int panel_generic_enable_bklt(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_BACKLIGHT_ON];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 	return 0;
 }
 
-int generic_disable_bklt(struct dsi_pipe *interface)
+int panel_generic_disable_bklt(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_BACKLIGHT_OFF];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 	return 0;
 }
 
-int generic_power_on(struct dsi_pipe *interface)
+int panel_generic_power_on(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_PANEL_ON];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 	return 0;
 }
 
-int generic_power_off(struct dsi_pipe *interface)
+int panel_generic_power_off(struct dsi_pipe *interface)
 {
 	struct dsi_vbt *dsi = interface->config.dsi;
 	char *sequence = dsi->sequence[MIPI_SEQ_PANEL_OFF];
 	pr_debug("ADF: %s\n", __func__);
 
-	generic_exec_sequence(interface, sequence);
+	panel_generic_exec_sequence(interface, sequence);
 	return 0;
 }
 
-static int generic_detect(struct dsi_pipe *interface)
+static int panel_generic_detect(struct dsi_pipe *interface)
 {
 	pr_debug("ADF: %s\n", __func__);
 	return 1;
 }
 
 #if 0
-static bool generic_get_hw_state(struct intel_dsi_device *dev)
+static bool panel_generic_get_hw_state(struct intel_dsi_device *dev)
 {
 	return true;
 }
 #endif
 
-static int generic_get_modes(struct dsi_config *config,
+static int panel_generic_get_modes(struct dsi_config *config,
 			     struct drm_mode_modeinfo *modeinfo)
 {
 	struct drm_display_mode *mode = &config->vbt_mode;
@@ -967,10 +968,11 @@ static int generic_get_modes(struct dsi_config *config,
 }
 
 #if 0
-static void generic_destroy(struct intel_dsi_device *dsi) { }
+static void panel_generic_destroy(struct intel_dsi_device *dsi) { }
 #endif
 
-int generic_get_panel_info(struct dsi_config *config, struct panel_info *info)
+int panel_generic_get_panel_info(struct dsi_config *config,
+				 struct panel_info *info)
 {
 	struct drm_display_mode *mode = &config->vbt_mode;
 	struct dsi_context *ctx = &config->ctx;
@@ -994,53 +996,53 @@ int generic_get_panel_info(struct dsi_config *config, struct panel_info *info)
 	return 0;
 }
 
-static int generic_exit_standby(struct dsi_pipe *interface)
+static int panel_generic_exit_standby(struct dsi_pipe *interface)
 {
 	pr_debug("ADF: %s\n", __func__);
 	return 0;
 }
 
-static int generic_set_brightness(struct dsi_pipe *interface, int level)
+static int panel_generic_set_brightness(struct dsi_pipe *interface, int level)
 {
 	pr_debug("ADF: %s\n", __func__);
 	return 0;
 }
 
-static int generic_set_mode(struct dsi_pipe *interface)
+static int panel_generic_set_mode(struct dsi_pipe *interface)
 {
 	pr_debug("ADF: %s\n", __func__);
 	return 0;
 }
 
-struct panel_ops generic_ops = {
-		.get_config_mode = generic_get_modes,
-		.dsi_controller_init = generic_init,
-		.get_panel_info = generic_get_panel_info,
-		.reset = generic_panel_reset,
-		.exit_deep_standby = generic_exit_standby,
-		.detect = generic_detect,
-		.power_on = generic_enable,
-		.power_off = generic_disable,
-		.enable_backlight = generic_enable_bklt,
-		.disable_backlight = generic_disable_bklt,
-		.set_brightness = generic_set_brightness,
-		.drv_ic_init = generic_send_otp_cmds,
-		.drv_set_panel_mode = generic_set_mode,
-		.disable_panel_power = generic_disable_panel_power,
-		.panel_power_on = generic_power_on,
-		.panel_power_off = generic_power_off,
+struct panel_ops panel_generic_ops = {
+		.get_config_mode = panel_generic_get_modes,
+		.dsi_controller_init = panel_generic_init,
+		.get_panel_info = panel_generic_get_panel_info,
+		.reset = panel_generic_panel_reset,
+		.exit_deep_standby = panel_generic_exit_standby,
+		.detect = panel_generic_detect,
+		.power_on = panel_generic_enable,
+		.power_off = panel_generic_disable,
+		.enable_backlight = panel_generic_enable_bklt,
+		.disable_backlight = panel_generic_disable_bklt,
+		.set_brightness = panel_generic_set_brightness,
+		.drv_ic_init = panel_generic_send_otp_cmds,
+		.drv_set_panel_mode = panel_generic_set_mode,
+		.disable_panel_power = panel_generic_disable_panel_power,
+		.panel_power_on = panel_generic_power_on,
+		.panel_power_off = panel_generic_power_off,
 /*
  * Might need to add these hooks in panel_ops
-		.mode_valid = generic_mode_valid,
-		.mode_fixup = generic_mode_fixup,
-		.get_hw_state = generic_get_hw_state,
-		.destroy = generic_destroy,
+		.mode_valid = panel_generic_mode_valid,
+		.mode_fixup = panel_generic_mode_fixup,
+		.get_hw_state = panel_generic_get_hw_state,
+		.destroy = panel_generic_destroy,
 */
 };
 
 struct dsi_panel generic_panel = {
 	.panel_id = MIPI_DSI_GENERIC_PANEL_ID,
-	.ops = &generic_ops,
+	.ops = &panel_generic_ops,
 };
 
 const struct dsi_panel *get_generic_panel(void)
diff --git a/drivers/video/adf/intel/core/vlv/vlv_dc_config.c b/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
index a11d747..1635103 100644
--- a/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
+++ b/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
@@ -41,13 +41,23 @@ void vlv_dc_config_destroy(struct intel_dc_config *config)
 	struct vlv_dc_config *vlv_config = to_vlv_dc_config(config);
 	struct vlv_pri_plane *pplane;
 	struct vlv_sp_plane *splane;
+	struct dsi_pipe *dsi_pipe;
 	int pipe;
 
 	if (!config)
 		return;
 
 	for (pipe = 0; pipe < MAX_PIPES; pipe++) {
-		/* Do pipe deinit here one pipe init code is ready for DSI */
+		if (vlv_config->vdisp[pipe].type == INTEL_PIPE_DSI) {
+			dsi_pipe = &vlv_config->vdisp[pipe].pipe.dsi;
+			dsi_pipe_destroy(dsi_pipe);
+		} else if (vlv_config->vdisp[pipe].type == INTEL_PIPE_HDMI) {
+			/* FIXME:
+			 * HDMI Pipe deinit
+			 */
+		} else
+			pr_err("ADF: %s: Unknown pipe type\n", __func__);
+
 		pplane = &vlv_config->vdisp[pipe].pplane;
 		vlv_pri_plane_destroy(pplane);
 		splane = &vlv_config->vdisp[pipe].splane[0];
@@ -67,12 +77,14 @@ static int vlv_initialize_disp(struct vlv_dc_config *vlv_config, int pipe,
 {
 	struct vlv_pri_plane *pplane;
 	struct vlv_sp_plane *splane;
+	struct dsi_pipe *dsi_pipe;
 	int err;
 
 	if (pipe > MAX_PIPES) {
 		dev_err(vlv_config->base.dev, "%s:invalid pipe", __func__);
 		return -EINVAL;
 	}
+
 	/* Initialize the plane */
 	pplane = &vlv_config->vdisp[pipe].pplane;
 	err = vlv_pri_plane_init(pplane, vlv_config->base.dev, PRIMARY_PLANE);
@@ -109,7 +121,23 @@ static int vlv_initialize_disp(struct vlv_dc_config *vlv_config, int pipe,
 	intel_dc_config_add_plane(&vlv_config->base, &splane->base,
 				  VLV_ID(pipe, VLV_SPRITE2));
 
-	/* TBD: Initialize interface PIPE */
+	/* Initialize interface PIPE */
+	if (type == INTEL_PIPE_DSI) {
+		dsi_pipe = &vlv_config->vdisp[pipe].pipe.dsi;
+		err = dsi_pipe_init(dsi_pipe, vlv_config->base.dev,
+				   &pplane->base, pipe);
+		if (err) {
+			dev_err(vlv_config->base.dev,
+				"%s: failed to init pipe(%d)\n", __func__, err);
+			return err;
+		}
+		intel_dc_config_add_pipe(&vlv_config->base,
+					 &dsi_pipe->base, pipe);
+		vlv_config->vdisp[pipe].type = type;
+	} else {
+		pr_err("ADF: %s: unsupported pipe type = %d\n", __func__, type);
+		err = -EINVAL;
+	}
 
 	return err;
 }
diff --git a/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h b/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h
index f0f7602..ff7e314 100644
--- a/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h
+++ b/drivers/video/adf/intel/include/core/vlv/vlv_dc_config.h
@@ -52,7 +52,7 @@ enum vlv_disp_plane {
 	VLV_MAX_PLANES,
 };
 
-static inline void vlv_gpio_write(u32 reg, u32 val, u32 port)
+static inline void vlv_gpio_write(u32 port, u32 reg, u32 val)
 {
 	intel_adf_pci_sideband_rw(INTEL_SIDEBAND_REG_WRITE, port, reg, &val);
 }
diff --git a/drivers/video/adf/intel/include/core/vlv/vlv_dc_regs.h b/drivers/video/adf/intel/include/core/vlv/vlv_dc_regs.h
index e4b671f..f4f89a2 100644
--- a/drivers/video/adf/intel/include/core/vlv/vlv_dc_regs.h
+++ b/drivers/video/adf/intel/include/core/vlv/vlv_dc_regs.h
@@ -1237,6 +1237,7 @@
 #define   DPLL_LOCK_VLV			(1<<15)
 #define   DPLL_INTEGRATED_CRI_CLK_VLV	(1<<14)
 #define   DPLL_INTEGRATED_CLOCK_VLV	(1<<13)
+#define   DPLL_RESERVED_BIT		(1<<11)
 #define   DPLL_PORTC_READY_MASK		(0xf << 4)
 #define   DPLL_PORTB_READY_MASK		(0xf)
 
-- 
1.7.9.5

