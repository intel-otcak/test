From 9c208d1b3813ccd3779ed5fdcd8a817c83561310 Mon Sep 17 00:00:00 2001
From: Daniel Drubin <daniel.drubin@intel.com>
Date: Sun, 3 May 2015 15:51:07 +0300
Subject: [PATCH] Added implementation of ISS FW reset flow 	Included KW
 fixes 	Included private sensors properties support 	Fixed sending
 fragmented HECI messages 	Fixes for race conditions on HECI and IPC
 levels send path 	Disabled ISH internal log 	Added stats counters 
 Added sanity checks 	Fixed bug in reset flow 	Fixed static analysis
 issues 	Added get_sample support 	Fixed locks 	Added FW clock
 sync 	FW clock sync rebased on host time since boot 	Fixed latency in
 syncing FW clock 	Fixed spinlock balance in senscol sensor removal

Tracked-On: https://jira01.devtools.intel.com/browse/AKP-1534
Change-Id: I098d87b9d6160ef3ec0baf4486a1e29df7c531c9
Signed-off-by: Daniel Drubin <daniel.drubin@intel.com>
---
 drivers/hid/hid-core.c               |   2 +
 drivers/hid/hid-sensor-hub.c         | 104 +++++++++++++++++++-----------
 drivers/misc/heci/bus.c              |  81 +++++++++++++++--------
 drivers/misc/heci/client.c           |  78 +++++++++++++++-------
 drivers/misc/heci/client.h           |   6 +-
 drivers/misc/heci/debugfs.c          |   6 +-
 drivers/misc/heci/hbm.c              |  54 ++++++----------
 drivers/misc/heci/hbm.h              |  12 +++-
 drivers/misc/heci/heci-api.c         |  29 ++++++---
 drivers/misc/heci/heci-hid-client.c  | 101 +++++++++++++++--------------
 drivers/misc/heci/heci-hid.c         |   2 +-
 drivers/misc/heci/heci_dev.h         |   6 +-
 drivers/misc/heci/hw-ish-regs.h      |   1 +
 drivers/misc/heci/hw-ish.c           |  80 +++++++++++++++++++----
 drivers/misc/heci/init.c             |   6 +-
 drivers/misc/heci/pci-ish.c          |  63 ++++++++++--------
 drivers/misc/heci/platform-config.h  |   6 +-
 drivers/misc/heci/senscol-core.c     | 121 ++++++++++++++++++++++++++++-------
 include/linux/senscol/senscol-core.h |   6 +-
 19 files changed, 501 insertions(+), 263 deletions(-)

diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index d92c7d9b959a..47de8ab46866 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -1010,6 +1010,8 @@ EXPORT_SYMBOL_GPL(hid_snto32);
 static u32 s32ton(__s32 value, unsigned n)
 {
 	s32 a = value >> (n - 1);
+	if (n == 32)
+		return value;
 	if (a && a != -1)
 		return value < 0 ? 1 << (n - 1) : (1 << (n - 1)) - 1;
 	return value & ((1 << n) - 1);
diff --git a/drivers/hid/hid-sensor-hub.c b/drivers/hid/hid-sensor-hub.c
index b0167e555d86..f20b7753abf3 100644
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@ -105,7 +105,8 @@ struct sensor_hub_data {
 
 #define	MAX_HID_SENSOR_HUBS 32
 static struct hid_device *hid_sensor_hubs[MAX_HID_SENSOR_HUBS];
-static int	sensor_hub_count;
+static int	sensor_hub_cur_count;
+static int	sensor_hub_max_count;
 
 /**
  * struct hid_sensor_hub_callbacks_list - Stores callback list
@@ -555,7 +556,6 @@ static int sensor_hub_get_feature_ex(struct hid_sensor_hub_device *hsdev,
 	*usage_id = report->field[field_index]->usage->hid;
 	*is_string = (report->field[field_index]->report_size == 16) &&
 			(*count > 1);
-
 done_proc:
 	mutex_unlock(&data->mutex);
 
@@ -568,7 +568,7 @@ static struct sensor_hub_data	*get_sensor_hub_by_index(unsigned idx)
 	int	i;
 	struct sensor_hub_data	*sd;
 
-	for (i = 0; i < sensor_hub_count; ++i) {
+	for (i = 0; i < sensor_hub_cur_count; ++i) {
 		if (!hid_sensor_hubs[i])
 			continue;
 		sd = hid_get_drvdata(hid_sensor_hubs[i]);
@@ -674,14 +674,16 @@ static int     hid_set_sens_property(struct sensor_def *sensor,
 	return	rv;
 }
 
-static int     hid_get_sample(struct sensor_def *sensor, void *sample_buf,
-	size_t sample_buf_size)
+static int     hid_get_sample(struct sensor_def *sensor)
 {
 	unsigned	idx;
 	struct sensor_hub_data	*sd;
 	unsigned	report_id;
-	struct data_field *data_field;
-	int32_t	val;
+	struct	hid_report *report;
+	int	ret = 0;
+
+	if (!sensor)
+		return -EINVAL;
 
 	/* sensor hub device */
 	idx = sensor->id >> 16 & 0xFFFF;
@@ -692,24 +694,22 @@ static int     hid_get_sample(struct sensor_def *sensor, void *sample_buf,
 	/* Report ID */
 	report_id = sensor->id & 0xFFFF;
 
-	/*
-	 * Request an input report with the first data field,
-	 * regardless of what it is
-	 */
-	data_field = &sensor->data_fields[0];
-	val = sensor_hub_input_attr_get_raw_value(sd->hsdev, sensor->usage_id,
-		data_field->usage_id, HID_INPUT_REPORT);
-	if (!sd->pending.status)
-		return	-EIO;
-
-	/*
-	 * Actual sample will be pushed by sensor_hub_raw_event().
-	 * Invoke a short sleep in order to remove threads race condition and
-	 * ensure that the sample is in senscol buffer
-	 */
-	schedule_timeout(2);
+	mutex_lock(&sd->mutex);
+	report = sensor_hub_report(report_id, sd->hsdev->hdev,
+		HID_INPUT_REPORT);
+	if (!report) {
+		ret = -EINVAL;
+		goto done_proc;
+	}
+	hid_hw_request(sd->hsdev->hdev, report, HID_REQ_GET_REPORT);
+
+	/*The sample will arrive to "raw event" func,
+	and will be pushed to user via "push_sample" method*/
 
-	return	0;
+done_proc:
+	mutex_unlock(&sd->mutex);
+
+	return	ret;
 }
 
 /* Check sensor is activated and in batch mode                  *
@@ -1040,9 +1040,15 @@ static int sensor_hub_probe(struct hid_device *hdev,
 	}
 	hid_set_drvdata(hdev, sd);
 	/* Keep array of HID sensor hubs for senscol_impl usage */
-	hid_sensor_hubs[sensor_hub_count] = hdev;
+	hid_sensor_hubs[sensor_hub_cur_count] = hdev;
 	/* Need to count sensor hub devices for senscol ids */
-	sd->sensor_hub_index = sensor_hub_count++;
+	sd->sensor_hub_index = sensor_hub_cur_count++;
+#if SENSCOL
+	if (sensor_hub_cur_count >= sensor_hub_max_count)
+		senscol_send_ready_event();
+	if (sensor_hub_cur_count > sensor_hub_max_count)
+		sensor_hub_max_count = sensor_hub_cur_count;
+#endif
 	sd->quirks = id->driver_data;
 	sd->hsdev->hdev = hdev;
 	sd->hsdev->vendor_id = hdev->vendor;
@@ -1240,27 +1246,26 @@ static int sensor_hub_probe(struct hid_device *hdev,
 					prop_field.usage_id & 0xF000;
 				uint32_t data_hid =
 					prop_field.usage_id & 0x0FFF;
+				const char *modif_name =
+					senscol_get_modifier(modifier);
 				usage_name = senscol_usage_to_name(
 					data_hid);
-				dev_dbg(&hdev->dev,
-					"%s(): DATANAME %s\n",
-					__func__, usage_name);
-				if (!usage_name)
+
+				if (!strcmp(modif_name, "custom")) {
+					prop_field.name =
+						kasprintf(GFP_KERNEL,
+						"custom-%X",
+						prop_field.usage_id & 0xFFFF);
+				} else if (!usage_name)
 					prop_field.name =
 						kasprintf(GFP_KERNEL,
 						"unknown-%X",
-						prop_field.usage_id && 0xFFFF);
-				else {
-					const char *modif_name =
-						senscol_get_modifier(modifier);
-					dev_dbg(&hdev->dev,
-						"%s(): MODIFNAME %s\n",
-						__func__, modif_name);
+						prop_field.usage_id & 0xFFFF);
+				else
 					prop_field.name =
 						kasprintf(GFP_KERNEL,
 						"%s_%s", usage_name,
 						modif_name);
-				}
 			}
 			prop_field.is_numeric =
 				(freport->field[i]->flags &
@@ -1358,8 +1363,13 @@ static void sensor_hub_remove(struct hid_device *hdev)
 	struct sensor_hub_data *data = hid_get_drvdata(hdev);
 	unsigned long flags;
 	int i;
+#if SENSCOL
+	uint32_t	hid_device_id;
+	struct hid_report *report;
+#endif
 
-	for (i = 0; i < sensor_hub_count; ++i)
+	/*use max count since we can't know the remove order of hid devices*/
+	for (i = 0; i < sensor_hub_max_count; ++i)
 		if (hid_sensor_hubs[i] == hdev) {
 			hid_sensor_hubs[i] = NULL;
 			break;
@@ -1372,12 +1382,28 @@ static void sensor_hub_remove(struct hid_device *hdev)
 	if (data->pending.status)
 		complete(&data->pending.ready);
 	spin_unlock_irqrestore(&data->lock, flags);
+
+#if SENSCOL
+	hid_device_id = data->sensor_hub_index;
+	list_for_each_entry(report,
+			&hdev->report_enum[HID_INPUT_REPORT].report_list,
+			list) {
+		remove_senscol_sensor(data->sensor_hub_index << 16 |
+			(report->id & 0xFFFF));
+	}
+#endif
+
 	mfd_remove_devices(&hdev->dev);
 	for (i = 0; i < data->hid_sensor_client_cnt ; ++i)
 		kfree(data->hid_sensor_hub_client_devs[i].name);
 	kfree(data->hid_sensor_hub_client_devs);
 	hid_set_drvdata(hdev, NULL);
 	mutex_destroy(&data->mutex);
+	sensor_hub_cur_count--;
+#if SENSCOL
+	if (sensor_hub_cur_count == sensor_hub_max_count - 1)
+		senscol_reset_notify();
+#endif
 }
 
 static const struct hid_device_id sensor_hub_devices[] = {
diff --git a/drivers/misc/heci/bus.c b/drivers/misc/heci/bus.c
index e60911c10b90..0f2b3b458498 100644
--- a/drivers/misc/heci/bus.c
+++ b/drivers/misc/heci/bus.c
@@ -38,10 +38,11 @@
  * @dev: heci device
  * returns me client index or -ENOENT if not found
  */
-int heci_me_cl_by_uuid(const struct heci_device *dev, const uuid_le *uuid)
+int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *uuid)
 {
 	int i, res = -ENOENT;
-
+	unsigned long	flags;
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
 	for (i = 0; i < dev->me_clients_num; ++i) {
 		if (uuid_le_cmp(*uuid, dev->me_clients[i].props.protocol_name)
 				== 0) {
@@ -49,6 +50,7 @@ int heci_me_cl_by_uuid(const struct heci_device *dev, const uuid_le *uuid)
 			break;
 		}
 	}
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 	return res;
 }
 EXPORT_SYMBOL(heci_me_cl_by_uuid);
@@ -66,15 +68,21 @@ EXPORT_SYMBOL(heci_me_cl_by_uuid);
 int heci_me_cl_by_id(struct heci_device *dev, u8 client_id)
 {
 	int i;
+	unsigned long	flags;
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
 	for (i = 0; i < dev->me_clients_num; i++)
 		if (dev->me_clients[i].client_id == client_id)
 			break;
-	if (WARN_ON(dev->me_clients[i].client_id != client_id))
+	if (WARN_ON(dev->me_clients[i].client_id != client_id)) {
+		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 		return -ENOENT;
+	}
 
-	if (i == dev->me_clients_num)
+	if (i == dev->me_clients_num) {
+		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 		return -ENOENT;
-
+	}
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 	return i;
 }
 
@@ -187,8 +195,9 @@ struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
 {
 	struct heci_cl_device *device;
 	int status;
+	unsigned long flags;
 
-	device = kzalloc(sizeof(struct heci_cl_device), GFP_KERNEL);
+	device = kzalloc(sizeof(struct heci_cl_device), GFP_ATOMIC);
 	if (!device)
 		return NULL;
 
@@ -198,15 +207,22 @@ struct heci_cl_device *heci_bus_add_device(struct heci_device *dev,
 	device->dev.bus = &heci_cl_bus_type;
 	device->dev.type = &heci_cl_device_type;
 	device->heci_dev = dev;
+
+	/* no need for spin lock here, the caller locked me_clients_lock */
 	device->fw_client =
 		&dev->me_clients[dev->me_client_presentation_num - 1];
 
 	dev_set_name(&device->dev, "%s", name);
+
+	spin_lock_irqsave(&dev->device_list_lock, flags);
 	list_add_tail(&device->device_link, &dev->device_list);
+	spin_unlock_irqrestore(&dev->device_list_lock, flags);
 
 	status = device_register(&device->dev);
 	if (status) {
+		spin_lock_irqsave(&dev->device_list_lock, flags);
 		list_del(&device->device_link);
+		spin_unlock_irqrestore(&dev->device_list_lock, flags);
 		dev_err(&dev->pdev->dev, "Failed to register HECI device\n");
 		kfree(device);
 		return NULL;
@@ -237,15 +253,14 @@ EXPORT_SYMBOL_GPL(heci_bus_remove_device);
  */
 void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
 {
-	struct heci_cl_device *heci_cl_dev;
+	struct heci_cl_device	*cl_device, *next_device;
 	struct heci_cl	*cl, *next;
 	unsigned long	flags;
 
-	spin_lock_irqsave(&heci_dev->device_lock, flags);
+	spin_lock_irqsave(&heci_dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
 		list_del(&cl->link);
-		spin_unlock_irqrestore(&heci_dev->device_lock, flags);
-		heci_cl_dev = cl->device;
+		cl->state = HECI_CL_DISCONNECTED;
 
 		/*
 		 * Wake any pending process. The waiter would check dev->state
@@ -257,9 +272,10 @@ void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
 		if (waitqueue_active(&cl->wait_ctrl_res))
 			wake_up(&cl->wait_ctrl_res);
 
-		/* Disband any pending read/write requests */
+		/* Disband any pending read/write requests and free RB */
 		heci_cl_flush_queues(cl);
 
+		/* Remove read_rb for user-mode API clients */
 		if (cl->read_rb) {
 			struct heci_cl_rb *rb = NULL;
 
@@ -277,20 +293,30 @@ void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
 			}
 		}
 
-		/* Unregister HECI bus client device */
-		heci_bus_remove_device(heci_cl_dev);
+		/* Remove all free and in_process rings, both Rx and Tx */
+		heci_cl_free_rx_ring(cl);
+		heci_cl_free_tx_ring(cl);
 
 		/* Free client and HECI bus client device structures */
-		kfree(cl);
-		spin_lock_irqsave(&heci_dev->device_lock, flags);
+		/* don't free host client because it is part of the OS fd
+		   structure */
 	}
-	spin_unlock_irqrestore(&heci_dev->device_lock, flags);
-#if 0
-	if (waitqueue_active(&heci_dev->wait_recvd_msg))
-		wake_up(&heci_dev->wait_recvd_msg);
-#endif
+	spin_unlock_irqrestore(&heci_dev->cl_list_lock, flags);
+
+	/* remove bus clients */
+	spin_lock_irqsave(&heci_dev->device_list_lock, flags);
+	list_for_each_entry_safe(cl_device, next_device,
+		&heci_dev->device_list, device_link) {
+			list_del(&cl_device->device_link);
+			spin_unlock_irqrestore(&heci_dev->device_list_lock,
+				flags);
+			heci_bus_remove_device(cl_device);
+			spin_lock_irqsave(&heci_dev->device_list_lock, flags);
+		}
+	spin_unlock_irqrestore(&heci_dev->device_list_lock, flags);
 
 	/* Free all client structures */
+	spin_lock_irqsave(&heci_dev->me_clients_lock, flags);
 	kfree(heci_dev->me_clients);
 	heci_dev->me_clients = NULL;
 	heci_dev->me_clients_num = 0;
@@ -299,6 +325,8 @@ void	heci_bus_remove_all_clients(struct heci_device *heci_dev)
 	bitmap_zero(heci_dev->me_clients_map, HECI_CLIENTS_MAX);
 	bitmap_zero(heci_dev->host_clients_map, HECI_CLIENTS_MAX);
 	bitmap_set(heci_dev->host_clients_map, 0, 3);
+	spin_unlock_irqrestore(&heci_dev->me_clients_lock, flags);
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
 }
 EXPORT_SYMBOL_GPL(heci_bus_remove_all_clients);
 
@@ -441,7 +469,7 @@ ssize_t cl_prop_read(struct device *dev, struct device_attribute *dev_attr,
 		rv = strlen(buf);
 	} else if (!strcmp(dev_attr->attr.name,  "max_number_of_connections")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
-			(unsigned)cl_device->fw_client->props.max_number_of_connections);
+(unsigned)cl_device->fw_client->props.max_number_of_connections);
 		rv = strlen(buf);
 	} else if (!strcmp(dev_attr->attr.name,  "fixed_address")) {
 		scnprintf(buf, PAGE_SIZE, "%u\n",
@@ -459,14 +487,14 @@ ssize_t cl_prop_read(struct device *dev, struct device_attribute *dev_attr,
 		struct heci_cl	*cl, *next;
 		unsigned	count = 0;
 
-		spin_lock_irqsave(&cl_device->heci_dev->device_lock, flags);
+		spin_lock_irqsave(&cl_device->heci_dev->cl_list_lock, flags);
 		list_for_each_entry_safe(cl, next,
 				&cl_device->heci_dev->cl_list, link) {
 			if (cl->state == HECI_CL_CONNECTED &&
 					cl->device == cl_device)
 				++count;
 		}
-		spin_unlock_irqrestore(&cl_device->heci_dev->device_lock,
+		spin_unlock_irqrestore(&cl_device->heci_dev->cl_list_lock,
 			flags);
 
 		scnprintf(buf, PAGE_SIZE, "%u\n", count);
@@ -574,6 +602,8 @@ int	heci_bus_new_client(struct heci_device *dev)
 	 * If appropriate driver has loaded, this will trigger its probe().
 	 * Otherwise, probe() will be called when driver is loaded
 	 */
+	/* no need for spinlock here - the caller locked me_clients_lock */
+
 	i = dev->me_client_presentation_num - 1;
 	device_uuid = dev->me_clients[i].props.protocol_name;
 	dev_name = kasprintf(GFP_ATOMIC,
@@ -639,11 +669,12 @@ int	heci_cl_device_bind(struct heci_cl *cl)
 {
 	int	rv;
 	struct heci_cl_device	*cl_device, *next;
-
+	unsigned long flags;
 	if (!cl->me_client_id || cl->state != HECI_CL_CONNECTED)
 		return	-EFAULT;
 
 	rv = -ENOENT;
+	spin_lock_irqsave(&cl->dev->device_list_lock, flags);
 	list_for_each_entry_safe(cl_device, next, &cl->dev->device_list,
 			device_link) {
 		if (cl_device->fw_client->client_id == cl->me_client_id) {
@@ -652,7 +683,7 @@ int	heci_cl_device_bind(struct heci_cl *cl)
 			break;
 		}
 	}
-
+	spin_unlock_irqrestore(&cl->dev->device_list_lock, flags);
 	return	rv;
 }
 
diff --git a/drivers/misc/heci/client.c b/drivers/misc/heci/client.c
index b187d41437eb..dcf8e188453f 100644
--- a/drivers/misc/heci/client.c
+++ b/drivers/misc/heci/client.c
@@ -32,7 +32,7 @@ static void no_dev_dbg(void *v, char *s, ...)
 {
 }
 #define dev_dbg no_dev_dbg
-/*#define dev_dbg dev_err*/
+/* #define dev_dbg dev_err */
 
 int	host_dma_enabled;
 void	*host_dma_buf;
@@ -67,22 +67,25 @@ void	heci_cl_alloc_dma_buf(void)
 
 
 /**
- * heci_io_list_flush - removes list entry belonging to cl.
+ * heci_read_list_flush - removes list entry belonging to cl.
  *
  * @list:  An instance of our list structure
  * @cl: host client
  */
-void heci_io_list_flush(struct heci_cl_rb *list, struct heci_cl *cl)
+void heci_read_list_flush(struct heci_cl *cl)
 {
 	struct heci_cl_rb *rb;
 	struct heci_cl_rb *next;
 
-	list_for_each_entry_safe(rb, next, &list->list, list) {
+	unsigned long	flags;
+	spin_lock_irqsave(&cl->dev->read_list_spinlock, flags);
+	list_for_each_entry_safe(rb, next, &cl->dev->read_list.list, list) {
 		if (rb->cl && heci_cl_cmp_id(cl, rb->cl)) {
 			list_del(&rb->list);
 			heci_io_rb_free(rb);
 		}
 	}
+	spin_unlock_irqrestore(&cl->dev->read_list_spinlock, flags);
 }
 
 /**
@@ -193,7 +196,7 @@ int heci_cl_flush_queues(struct heci_cl *cl)
 		return -EINVAL;
 
 	dev_dbg(&cl->dev->pdev->dev, "remove list entry belonging to cl\n");
-	heci_io_list_flush(&cl->dev->read_list, cl);
+	heci_read_list_flush(cl);
 
 	return 0;
 }
@@ -232,8 +235,10 @@ void heci_cl_init(struct heci_cl *cl, struct heci_device *dev)
 int	heci_cl_free_rx_ring(struct heci_cl *cl)
 {
 	struct heci_cl_rb *rb;
+	unsigned long	flags;
 
 	/* relese allocated mem- pass over free_rb_list */
+	spin_lock_irqsave(&cl->free_list_spinlock, flags);
 	while (!list_empty(&cl->free_rb_list.list)) {
 		rb = list_entry(cl->free_rb_list.list.next, struct heci_cl_rb,
 			list);
@@ -241,8 +246,9 @@ int	heci_cl_free_rx_ring(struct heci_cl *cl)
 		kfree(rb->buffer.data);
 		kfree(rb);
 	}
-
+	spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
 	/* relese allocated mem- pass over in_process_list */
+	spin_lock_irqsave(&cl->in_process_spinlock, flags);
 	while (!list_empty(&cl->in_process_list.list)) {
 		rb = list_entry(cl->in_process_list.list.next,
 			struct heci_cl_rb, list);
@@ -250,14 +256,16 @@ int	heci_cl_free_rx_ring(struct heci_cl *cl)
 		kfree(rb->buffer.data);
 		kfree(rb);
 	}
-
+	spin_unlock_irqrestore(&cl->in_process_spinlock, flags);
 	return	0;
 }
 
 int	heci_cl_free_tx_ring(struct heci_cl *cl)
 {
 	struct heci_cl_tx_ring  *tx_buf;
+	unsigned long	flags;
 
+	spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
 	/* relese allocated mem- pass over tx_free_list */
 	while (!list_empty(&cl->tx_free_list.list)) {
 		tx_buf = list_entry(cl->tx_free_list.list.next,
@@ -266,7 +274,9 @@ int	heci_cl_free_tx_ring(struct heci_cl *cl)
 		kfree(tx_buf->send_buf.data);
 		kfree(tx_buf);
 	}
+	spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
 
+	spin_lock_irqsave(&cl->tx_list_spinlock, flags);
 	/* relese allocated mem- pass over tx_list */
 	while (!list_empty(&cl->tx_list.list)) {
 		tx_buf = list_entry(cl->tx_list.list.next,
@@ -275,6 +285,7 @@ int	heci_cl_free_tx_ring(struct heci_cl *cl)
 		kfree(tx_buf->send_buf.data);
 		kfree(tx_buf);
 	}
+	spin_unlock_irqrestore(&cl->tx_list_spinlock, flags);
 
 	return	0;
 }
@@ -286,6 +297,7 @@ int	heci_cl_alloc_rx_ring(struct heci_cl *cl)
 	struct heci_cl_rb *rb;
 	int	ret = 0;
 	struct heci_device *dev = cl->dev;
+	unsigned long	flags;
 
 	for (j = 0; j < cl->rx_ring_size; ++j) {
 		rb = heci_io_rb_init(cl);
@@ -296,7 +308,9 @@ int	heci_cl_alloc_rx_ring(struct heci_cl *cl)
 		ret = heci_io_rb_alloc_buf(rb, len);
 		if (ret)
 			goto out;
+		spin_lock_irqsave(&cl->free_list_spinlock, flags);
 		list_add_tail(&rb->list, &cl->free_rb_list.list);
+		spin_unlock_irqrestore(&cl->free_list_spinlock, flags);
 	}
 
 	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
@@ -316,6 +330,7 @@ int	heci_cl_alloc_tx_ring(struct heci_cl *cl)
 	size_t	len = cl->device->fw_client->props.max_msg_length;
 	int	j;
 	struct heci_device *dev = cl->dev;
+	unsigned long	flags;
 
 	/*cl->send_fc_flag = 0;*/
 	ISH_DBG_PRINT(KERN_ALERT "%s() allocated rb pool successfully\n",
@@ -339,7 +354,9 @@ int	heci_cl_alloc_tx_ring(struct heci_cl *cl)
 			kfree(tx_buf);
 			goto	out;
 		}
+		spin_lock_irqsave(&cl->tx_free_list_spinlock, flags);
 		list_add_tail(&tx_buf->list, &cl->tx_free_list.list);
+		spin_unlock_irqrestore(&cl->tx_free_list_spinlock, flags);
 	}
 	ISH_DBG_PRINT(KERN_ALERT "%s() allocated Tx  pool successfully\n",
 		__func__);
@@ -421,7 +438,7 @@ EXPORT_SYMBOL(heci_cl_find_read_rb);
 int heci_cl_link(struct heci_cl *cl, int id)
 {
 	struct heci_device *dev;
-	unsigned long	flags;
+	unsigned long	flags, flags_cl;
 
 	if (WARN_ON(!cl || !cl->dev))
 		return -EINVAL;
@@ -448,7 +465,14 @@ int heci_cl_link(struct heci_cl *cl, int id)
 
 	dev->open_handle_count++;
 	cl->host_client_id = id;
+	spin_lock_irqsave(&dev->cl_list_lock, flags_cl);
+	if (dev->dev_state != HECI_DEV_ENABLED) {
+		spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
+		spin_unlock_irqrestore(&dev->device_lock, flags);
+		return -ENODEV;
+	}
 	list_add_tail(&cl->link, &dev->cl_list);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags_cl);
 	set_bit(id, dev->host_clients_map);
 	cl->state = HECI_CL_INITIALIZING;
 	spin_unlock_irqrestore(&dev->device_lock, flags);
@@ -477,23 +501,24 @@ int heci_cl_unlink(struct heci_cl *cl)
 	dev = cl->dev;
 
 	spin_lock_irqsave(&dev->device_lock, flags);
-
 	if (dev->open_handle_count > 0) {
 		clear_bit(cl->host_client_id, dev->host_clients_map);
 		dev->open_handle_count--;
 	}
+	spin_unlock_irqrestore(&dev->device_lock, flags);
 
 	/*
 	 * This checks that 'cl' is actually linked into device's structure,
 	 * before attempting 'list_del'
 	 */
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
 		if (cl->host_client_id == pos->host_client_id) {
 			list_del_init(&pos->link);
 			break;
 		}
 	}
-	spin_unlock_irqrestore(&dev->device_lock, flags);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 
 	return 0;
 }
@@ -536,7 +561,7 @@ int heci_cl_disconnect(struct heci_cl *cl)
 	}
 
 	err = wait_event_timeout(cl->wait_ctrl_res,
-			(dev->dev_state == HECI_DEV_ENABLED &&
+			(dev->dev_state != HECI_DEV_ENABLED ||
 			HECI_CL_DISCONNECTED == cl->state),
 			heci_secs_to_jiffies(HECI_CL_CONNECT_TIMEOUT));
 
@@ -594,16 +619,16 @@ bool heci_cl_is_other_connecting(struct heci_cl *cl)
 
 	dev = cl->dev;
 
-	spin_lock_irqsave(&dev->device_lock, flags);
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(pos, next, &dev->cl_list, link) {
 		if ((pos->state == HECI_CL_CONNECTING) && (pos != cl) &&
 				cl->me_client_id == pos->me_client_id) {
-			spin_unlock_irqrestore(&dev->device_lock, flags);
+			spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 			return true;
 		}
 
 	}
-	spin_unlock_irqrestore(&dev->device_lock, flags);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 
 	return false;
 }
@@ -807,7 +832,7 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 	int id;
 	struct heci_cl_tx_ring  *cl_msg;
 	int	have_msg_to_send = 0;
-	unsigned long	tx_flags, tx_free_flags;
+	unsigned long	me_flags, tx_flags, tx_free_flags;
 
 	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	if (WARN_ON(!cl || !cl->dev))
@@ -819,6 +844,7 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 		++cl->err_send_msg;
 		return -EPIPE;
 	}
+
 	if (dev->dev_state != HECI_DEV_ENABLED) {
 		++cl->err_send_msg;
 		return -ENODEV;
@@ -831,6 +857,7 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 		return -ENOENT;
 	}
 
+	spin_lock_irqsave(&dev->me_clients_lock, me_flags);
 	if (length > dev->me_clients[id].props.max_msg_length) {
 		/* If the client supports DMA, try to use it */
 		if (host_dma_enabled && dev->me_clients[id].props.dma_hdr_len &
@@ -838,9 +865,9 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 			struct heci_msg_hdr	hdr;
 			struct hbm_client_dma_request	heci_dma_request_msg;
 			unsigned len = sizeof(struct hbm_client_dma_request);
-			int preview_len =
-				dev->me_clients[id].props.dma_hdr_len &	0x7F;
-
+			int	preview_len =
+				dev->me_clients[id].props.dma_hdr_len & 0x7F;
+			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
 			/* DMA max msg size is 1M */
 			if (length > host_dma_buf_size) {
 				++cl->err_send_msg;
@@ -880,9 +907,12 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 				(uint8_t *)&heci_dma_request_msg);
 			return 0;
 		} else {
+			spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
 			++cl->err_send_msg;
 			return -EINVAL;		/* -EMSGSIZE? */
 		}
+	} else {
+		spin_unlock_irqrestore(&dev->me_clients_lock, me_flags);
 	}
 
 	/* No free bufs */
@@ -913,7 +943,7 @@ int heci_cl_send(struct heci_cl *cl, u8 *buf, size_t length)
 	list_add_tail(&cl_msg->list, &cl->tx_list.list);
 	spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
 
-	if (!have_msg_to_send &&  cl->heci_flow_ctrl_creds > 0)
+	if (!have_msg_to_send && cl->heci_flow_ctrl_creds > 0)
 		heci_cl_send_msg(dev, cl);
 
 	return	0;
@@ -963,13 +993,13 @@ void heci_cl_all_disconnect(struct heci_device *dev)
 	struct heci_cl *cl, *next;
 	unsigned long	flags;
 
-	spin_lock_irqsave(&dev->device_lock, flags);
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
 		cl->state = HECI_CL_DISCONNECTED;
 		cl->heci_flow_ctrl_creds = 0;
 		cl->read_rb = NULL;
 	}
-	spin_unlock_irqrestore(&dev->device_lock, flags);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
 
@@ -983,14 +1013,14 @@ void heci_cl_all_read_wakeup(struct heci_device *dev)
 	struct heci_cl *cl, *next;
 	unsigned long	flags;
 
-	spin_lock_irqsave(&dev->device_lock, flags);
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
 		if (waitqueue_active(&cl->rx_wait)) {
 			dev_dbg(&dev->pdev->dev, "Waking up client!\n");
 			wake_up_interruptible(&cl->rx_wait);
 		}
 	}
-	spin_unlock_irqrestore(&dev->device_lock, flags);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
 /*##################################*/
@@ -1051,7 +1081,7 @@ static void	ipc_tx_callback(void *prm)
 		spin_unlock_irqrestore(&cl->tx_free_list_spinlock,
 			tx_free_flags);
 	} else {
-		/* FIXME Send IPC fragment */
+		/* FIXME: Send IPC fragment */
 		spin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);
 		cl->tx_offs += dev->mtu;
 		heci_hdr.length = dev->mtu;
diff --git a/drivers/misc/heci/client.h b/drivers/misc/heci/client.h
index a8dd99dc9657..8614020b6bb5 100644
--- a/drivers/misc/heci/client.h
+++ b/drivers/misc/heci/client.h
@@ -86,7 +86,7 @@ struct heci_cl {
 	/*#############################*/
 
 	/* Send FC spinlock */
-	spinlock_t	fc_spinlock;
+	spinlock_t      fc_spinlock;
 
 	/* wait queue for connect and disconnect response from FW */
 	wait_queue_head_t wait_ctrl_res;
@@ -112,7 +112,7 @@ extern int	dma_ready;
 extern int	host_dma_enabled;
 
 int heci_can_client_connect(struct heci_device *heci_dev, uuid_le *uuid);
-int heci_me_cl_by_uuid(const struct heci_device *dev, const uuid_le *cuuid);
+int heci_me_cl_by_uuid(struct heci_device *dev, const uuid_le *cuuid);
 int heci_me_cl_by_id(struct heci_device *dev, u8 client_id);
 
 /*
@@ -133,7 +133,7 @@ static inline void heci_io_list_init(struct heci_cl_rb *list)
 {
 	INIT_LIST_HEAD(&list->list);
 }
-void heci_io_list_flush(struct heci_cl_rb *list, struct heci_cl *cl);
+void heci_read_list_flush(struct heci_cl *cl);
 
 /*
  * HECI Host Client Functions
diff --git a/drivers/misc/heci/debugfs.c b/drivers/misc/heci/debugfs.c
index a08f7a7aa07e..1160d4f1f4d8 100644
--- a/drivers/misc/heci/debugfs.c
+++ b/drivers/misc/heci/debugfs.c
@@ -30,7 +30,7 @@ static ssize_t heci_dbgfs_read_meclients(struct file *fp, char __user *ubuf,
 	int i;
 	int pos = 0;
 	int ret;
-
+	unsigned long	flags;
 	if  (!buf)
 		return -ENOMEM;
 
@@ -40,10 +40,9 @@ static ssize_t heci_dbgfs_read_meclients(struct file *fp, char __user *ubuf,
 	/*  if the driver is not enabled the list won't b consitent */
 	if (dev->dev_state != HECI_DEV_ENABLED)
 		goto out;
-
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
 	for (i = 0; i < dev->me_clients_num; i++) {
 		cl = &dev->me_clients[i];
-
 		/* skip me clients that cannot be connected */
 		if (cl->props.max_number_of_connections == 0)
 			continue;
@@ -56,6 +55,7 @@ static ssize_t heci_dbgfs_read_meclients(struct file *fp, char __user *ubuf,
 			cl->props.max_number_of_connections,
 			cl->props.max_msg_length);
 	}
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 out:
 	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, pos);
 	kfree(buf);
diff --git a/drivers/misc/heci/hbm.c b/drivers/misc/heci/hbm.c
index ceb34b89f84a..67680aae0bde 100644
--- a/drivers/misc/heci/hbm.c
+++ b/drivers/misc/heci/hbm.c
@@ -22,7 +22,6 @@
 #include "hbm.h"
 #include "client.h"
 #include <linux/spinlock.h>
-
 /*
 #define	DEBUG_FW_BOOT_SEQ	1
 #define	DUMP_CL_PROP	1
@@ -63,7 +62,7 @@ static  void no_dev_dbg(void *v, char *s, ...)
 {
 }
 #define dev_dbg no_dev_dbg
-/*#define dev_dbg dev_err*/
+/* #define dev_dbg dev_err */
 
 /**
  * heci_hbm_me_cl_allocate - allocates storage for me clients
@@ -266,7 +265,6 @@ static int heci_hbm_prop_req(struct heci_device *dev)
 				++dev->me_client_presentation_num)
 			/* Add new client device */
 			heci_bus_new_client(dev);
-
 		return 0;
 	}
 
@@ -380,7 +378,6 @@ int heci_hbm_cl_flow_control_req(struct heci_device *dev, struct heci_cl *cl)
 				cl->max_fc_delay_usec = us;
 			}
 		}
-
 	} else {
 		++cl->err_send_fc;
 	}
@@ -432,7 +429,7 @@ static void heci_hbm_cl_disconnect_res(struct heci_device *dev,
 			rs->host_addr,
 			rs->status);
 
-	spin_lock_irqsave(&dev->device_lock, flags);
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
 		if (!rs->status && heci_hbm_cl_addr_equal(cl, rs)) {
 			cl->state = HECI_CL_DISCONNECTED;
@@ -441,7 +438,7 @@ static void heci_hbm_cl_disconnect_res(struct heci_device *dev,
 	}
 	if (cl)
 		wake_up(&cl->wait_ctrl_res);
-	spin_unlock_irqrestore(&dev->device_lock, flags);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
 /**
@@ -487,7 +484,7 @@ static void heci_hbm_cl_connect_res(struct heci_device *dev,
 			rs->host_addr,
 			rs->status);
 
-	spin_lock_irqsave(&dev->device_lock, flags);
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
 		if (heci_hbm_cl_addr_equal(cl, rs)) {
 			if (!rs->status) {
@@ -502,7 +499,7 @@ static void heci_hbm_cl_connect_res(struct heci_device *dev,
 	}
 	if (cl)
 		wake_up(&cl->wait_ctrl_res);
-	spin_unlock_irqrestore(&dev->device_lock, flags);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
 
@@ -522,7 +519,7 @@ static void heci_hbm_fw_disconnect_req(struct heci_device *dev,
 	struct heci_msg_hdr hdr;
 	unsigned char data[4];	/* All HBM messages are 4 bytes */
 
-	spin_lock_irqsave(&dev->device_lock, flags);
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
 		if (heci_hbm_cl_addr_equal(cl, disconnect_req)) {
 			cl->state = HECI_CL_DISCONNECTED;
@@ -535,7 +532,7 @@ static void heci_hbm_fw_disconnect_req(struct heci_device *dev,
 			break;
 		}
 	}
-	spin_unlock_irqrestore(&dev->device_lock, flags);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 }
 
 
@@ -630,7 +627,8 @@ void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
 		}
 
 		if (me_client->client_id != props_res->address) {
-			dev_err(&dev->pdev->dev, "reset: host properties response address mismatch [%02X %02X]\n",
+			dev_err(&dev->pdev->dev,
+"reset: host properties response address mismatch [%02X %02X]\n",
 				me_client->client_id, props_res->address);
 			heci_reset(dev, 1);
 			return;
@@ -638,9 +636,9 @@ void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
 
 		if (dev->dev_state != HECI_DEV_INIT_CLIENTS ||
 		    dev->hbm_state != HECI_HBM_CLIENT_PROPERTIES) {
-			dev_err(&dev->pdev->dev, "reset: unexpected properties response\n");
+			dev_err(&dev->pdev->dev,
+				"reset: unexpected properties response\n");
 			heci_reset(dev, 1);
-
 			return;
 		}
 
@@ -649,21 +647,6 @@ void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
 		dev->me_client_presentation_num++;
 
 #if 0
-		/* DEBUG -- dump received client's GUID */
-		do {
-			int	i;
-
-			ISH_DBG_PRINT(
-				KERN_ALERT "%s(): idx=%d protocol_name = ",
-				__func__, dev->me_client_presentation_num - 1);
-			for (i = 0; i <  16; ++i)
-				ISH_DBG_PRINT(KERN_ALERT "%02X ",
-					(unsigned)me_client->props.protocol_name.b[i]);
-			ISH_DBG_PRINT(KERN_ALERT "\n");
-		} while (0);
-#endif
-
-#if 0
 		/* Add new client device */
 		heci_bus_new_client(dev);
 #endif
@@ -680,6 +663,7 @@ void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr)
 		    dev->hbm_state == HECI_HBM_ENUM_CLIENTS) {
 				dev->me_client_presentation_num = 0;
 				dev->me_client_index = 0;
+
 				heci_hbm_me_cl_allocate(dev);
 				dev->hbm_state = HECI_HBM_CLIENT_PROPERTIES;
 
@@ -742,7 +726,7 @@ void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 	uint8_t	rd_msg_buf[HECI_RD_MSG_BUF_SIZE];
 	struct heci_bus_message	*heci_msg =
 		(struct heci_bus_message *)rd_msg_buf;
-	unsigned long	flags, tx_flags;
+	unsigned long	flags;
 
 	dev->ops->read(dev, rd_msg_buf, heci_hdr->length);
 
@@ -752,13 +736,13 @@ void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 			(struct hbm_flow_control *)heci_msg;
 		struct heci_cl *cl = NULL;
 		struct heci_cl *next = NULL;
-		unsigned long	flags;
+		unsigned long	flags, tx_flags;
 
 		ISH_DBG_PRINT(KERN_ALERT
 			"%s(): HECI_FLOW_CONTROL_CMD, checking to whom (host_addr=%d me_addr=%d\n",
 			__func__, flow_control->host_addr,
 			flow_control->me_addr);
-		spin_lock_irqsave(&dev->device_lock, flags);
+		spin_lock_irqsave(&dev->cl_list_lock, flags);
 		list_for_each_entry_safe(cl, next, &dev->cl_list, link) {
 			if (cl->host_client_id == flow_control->host_addr &&
 					cl->me_client_id ==
@@ -774,7 +758,7 @@ void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 						"recv extra FC from FW client %u (host client %u) (FC count was %u)\n",
 						(unsigned)cl->me_client_id,
 						(unsigned)cl->host_client_id,
-						(unsigned)cl->heci_flow_ctrl_creds);
+					(unsigned)cl->heci_flow_ctrl_creds);
 				else {
 					if (cl->host_client_id == 3 &&
 							cl->me_client_id == 5) {
@@ -804,7 +788,7 @@ void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr)
 				/*##########################################*/
 			}
 		}
-		spin_unlock_irqrestore(&dev->device_lock, flags);
+		spin_unlock_irqrestore(&dev->cl_list_lock, flags);
 		goto	eoi;
 	}
 
@@ -846,8 +830,6 @@ eoi:
 }
 EXPORT_SYMBOL(recv_hbm);
 
-/* Suspend and resume notification*/
-
 /*
  *      Receive and process HECI fixed client messages
  *
@@ -885,6 +867,8 @@ static inline void fix_cl_hdr(struct heci_msg_hdr *hdr, size_t length,
 	hdr->reserved = 0;
 }
 
+/* Suspend and resume notification*/
+
 /*Global var for suspend & resume*/
 u32 current_state = 0;
 u32 supported_states = 0 | SUSPEND_STATE_BIT;
diff --git a/drivers/misc/heci/hbm.h b/drivers/misc/heci/hbm.h
index e72ded101ba0..94eb0ab59a79 100644
--- a/drivers/misc/heci/hbm.h
+++ b/drivers/misc/heci/hbm.h
@@ -321,15 +321,18 @@ int heci_hbm_cl_connect_req(struct heci_device *dev, struct heci_cl *cl);
 void heci_hbm_enum_clients_req(struct heci_device *dev);
 void	recv_hbm(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
 
-/* Suspend and resume notification*/
+/* System state */
 #define HECI_SYSTEM_STATE_CLIENT_ADDR 13
 
 #define SYSTEM_STATE_SUBSCRIBE                  0x1
 #define SYSTEM_STATE_STATUS                     0x2
 #define SYSTEM_STATE_QUERY_SUBSCRIBERS          0x3
+#define SYSTEM_STATE_STATE_CHANGE_REQ		0x4
 
 #define SUSPEND_STATE_BIT       (1<<1) /*indicates suspend and resume states*/
 
+#define ANDROID_EVENT_MASK	0xff000000
+
 struct ish_system_states_header {
 	u32 cmd;
 	u32 cmd_status;  /*responses will have this set*/
@@ -350,12 +353,17 @@ struct ish_system_states_query_subscribers {
 	struct ish_system_states_header hdr;
 } __packed;
 
+struct ish_system_states_state_change_req {
+	struct ish_system_states_header hdr;
+	u32 requested_states;
+	u32 states_status;
+} __packed;
+
 void send_suspend(struct heci_device *dev);
 void send_resume(struct heci_device *dev);
 void query_subscribers(struct heci_device *dev);
 
 void recv_fixed_cl_msg(struct heci_device *dev, struct heci_msg_hdr *heci_hdr);
 void heci_hbm_dispatch(struct heci_device *dev, struct heci_bus_message *hdr);
-
 #endif /* _HECI_HBM_H_ */
 
diff --git a/drivers/misc/heci/heci-api.c b/drivers/misc/heci/heci-api.c
index 82134efce232..4c2f9a82484d 100644
--- a/drivers/misc/heci/heci-api.c
+++ b/drivers/misc/heci/heci-api.c
@@ -65,6 +65,7 @@ static int heci_open(struct inode *inode, struct file *file)
 	struct heci_device *dev;
 	int err;
 
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	/* Non-blocking semantics are not supported */
 	if (file->f_flags & O_NONBLOCK)
 		return	-EINVAL;
@@ -88,14 +89,12 @@ static int heci_open(struct inode *inode, struct file *file)
 	 * We may have a case of issued open() with
 	 * dev->dev_state == HECI_DEV_DISABLED, as part of re-enabling path
 	 */
-#if 0
 	err = -ENODEV;
 	if (dev->dev_state != HECI_DEV_ENABLED) {
 		dev_dbg(&dev->pdev->dev, "dev_state != HECI_ENABLED  dev_state = %s\n",
 		    heci_dev_state_str(dev->dev_state));
 		goto out_free;
 	}
-#endif
 
 	err = heci_cl_link(cl, HECI_HOST_CLIENT_ID_ANY);
 	if (err)
@@ -108,6 +107,7 @@ static int heci_open(struct inode *inode, struct file *file)
 out_free:
 	kfree(cl);
 out:
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
 	return err;
 }
 
@@ -124,7 +124,9 @@ static int heci_release(struct inode *inode, struct file *file)
 	struct heci_cl *cl = file->private_data;
 	struct heci_device *dev;
 	int rets = 0;
+	unsigned int flags;
 
+	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	if (WARN_ON(!cl || !cl->dev))
 		return -ENODEV;
 
@@ -143,17 +145,21 @@ static int heci_release(struct inode *inode, struct file *file)
 			cl->host_client_id, cl->me_client_id);
 		rets = heci_cl_disconnect(cl);
 	}
-	heci_cl_flush_queues(cl);
+
 	dev_dbg(&dev->pdev->dev, "remove client host client = %d, ME client = %d\n",
 	    cl->host_client_id,
 	    cl->me_client_id);
 
 	heci_cl_unlink(cl);
-
+	heci_cl_flush_queues(cl);
 	file->private_data = NULL;
 
 	/* disband and free all Tx and Rx client-level rings */
+	spin_lock_irqsave(&dev->cl_list_lock, flags);
 	heci_cl_free(cl);
+	spin_unlock_irqrestore(&dev->cl_list_lock, flags);
+
+	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
 	return rets;
 }
 
@@ -392,6 +398,7 @@ static int heci_ioctl_connect_client(struct file *file,
 	struct heci_cl *cl;
 	int i;
 	int rets;
+	unsigned long flags;
 
 	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	cl = file->private_data;
@@ -413,13 +420,15 @@ static int heci_ioctl_connect_client(struct file *file,
 
 	/* find ME client we're trying to connect to */
 	i = heci_me_cl_by_uuid(dev, &data->in_client_uuid);
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
 	if (i < 0 || dev->me_clients[i].props.fixed_address) {
 		dev_dbg(&dev->pdev->dev, "Cannot connect to FW Client UUID = %pUl\n",
 				&data->in_client_uuid);
+		spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 		rets = -ENODEV;
 		goto end;
 	}
-
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 	/* Check if there's driver attached to this UUID */
 	if (!heci_can_client_connect(dev, &data->in_client_uuid))
 		return	-EBUSY;
@@ -429,17 +438,19 @@ static int heci_ioctl_connect_client(struct file *file,
 
 	dev_dbg(&dev->pdev->dev, "Connect to FW Client ID = %d\n",
 			cl->me_client_id);
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
 	dev_dbg(&dev->pdev->dev, "FW Client - Protocol Version = %d\n",
 			dev->me_clients[i].props.protocol_version);
 	dev_dbg(&dev->pdev->dev, "FW Client - Max Msg Len = %d\n",
 			dev->me_clients[i].props.max_msg_length);
-
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 	/* prepare the output buffer */
 	client = &data->out_client_properties;
+	spin_lock_irqsave(&dev->me_clients_lock, flags);
 	client->max_msg_length = dev->me_clients[i].props.max_msg_length;
 	client->protocol_version = dev->me_clients[i].props.protocol_version;
 	dev_dbg(&dev->pdev->dev, "Can connect?\n");
-
+	spin_unlock_irqrestore(&dev->me_clients_lock, flags);
 	rets = heci_cl_connect(cl);
 
 end:
@@ -535,7 +546,8 @@ err:
 	}
 
 	if (cmd == IOCTL_GET_FW_STATUS) {
-		sprintf(fw_stat_buf, "%08X\n", dev->ops->get_fw_status(dev));
+		scnprintf(fw_stat_buf, sizeof(fw_stat_buf),
+			"%08X\n", dev->ops->get_fw_status(dev));
 		copy_to_user((char __user *)data, fw_stat_buf,
 			strlen(fw_stat_buf));
 		return strlen(fw_stat_buf);
@@ -630,7 +642,6 @@ static struct miscdevice  heci_misc_device = {
 		.minor = MISC_DYNAMIC_MINOR,
 };
 
-
 int heci_register(struct heci_device *dev)
 {
 	int ret;
diff --git a/drivers/misc/heci/heci-hid-client.c b/drivers/misc/heci/heci-hid-client.c
index bed8c2739b9f..2febee3c0f85 100644
--- a/drivers/misc/heci/heci-hid-client.c
+++ b/drivers/misc/heci/heci-hid-client.c
@@ -78,8 +78,9 @@ void	process_recv(void *recv_buf, size_t data_len)
 		(unsigned)data_len);
 
 	if (data_len < sizeof(struct hostif_msg_hdr)) {
-		printk(KERN_ERR "[hid-ish]: error, received %u which is less than data header %u\n",
-			(unsigned)data_len,
+		dev_err(NULL, "[hid-ish]: error, received %u which is ",
+			(unsigned)data_len);
+		dev_err(NULL, " less than data header %u\n",
 			(unsigned)sizeof(struct hostif_msg_hdr));
 		return;
 	}
@@ -102,9 +103,6 @@ void	process_recv(void *recv_buf, size_t data_len)
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): received HOSTIF_DM_ENUM_DEVICES\n",
 				__func__);
-			g_ish_print_log(
-				"%s() received HOSTIF_DM_ENUM_DEVICES\n"
-				, __func__);
 			hid_dev_count = (unsigned)*payload;
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): hid_dev_count=%d\n",
@@ -117,10 +115,16 @@ void	process_recv(void *recv_buf, size_t data_len)
 
 			for (i = 0; i < hid_dev_count; ++i) {
 				if (1 + sizeof(struct device_info) * i >=
-						payload_len)
-					printk(KERN_ERR "[hid-ish]: [HOSTIF_DM_ENUM_DEVICES]: content size %u is bigger than payload_len %u\n",
-						1 + (unsigned)(sizeof(struct device_info) * i),
+						payload_len) {
+					dev_err(NULL,
+						"[hid-ish]: [ENUM_DEVICES]:");
+					dev_err(NULL, " content size %lu ", 1 +
+						sizeof(struct device_info) *
+						i);
+					dev_err(NULL, "is bigger than ");
+					dev_err(NULL, "payload_len %u\n",
 						(unsigned)payload_len);
+				}
 
 				if (1 + sizeof(struct device_info) * i >=
 						data_len)
@@ -148,9 +152,6 @@ void	process_recv(void *recv_buf, size_t data_len)
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): received HOSTIF_GET_HID_DESCRIPTOR\n",
 				__func__);
-			g_ish_print_log(
-				"%s() received HOSTIF_GET_HID_DESCRIPTOR\n"
-				, __func__);
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): dump HID descriptor\n",
 				__func__);
@@ -174,9 +175,6 @@ void	process_recv(void *recv_buf, size_t data_len)
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): received HOSTIF_GET_REPORT_DESCRIPTOR\n",
 				__func__);
-			g_ish_print_log(
-				"%s() received HOSTIF_GET_REPORT_DESCRIPTOR\n"
-				, __func__);
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): Length of report descriptor is %u\n",
 				__func__, (unsigned)payload_len);
@@ -198,9 +196,6 @@ void	process_recv(void *recv_buf, size_t data_len)
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): received HOSTIF_GET_FEATURE_REPORT\n",
 				__func__);
-			g_ish_print_log(
-				"%s() received HOSTIF_GET_FEATURE_REPORT\n",
-				__func__);
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): dump Get Feature Result\n",
 				__func__);
@@ -212,9 +207,6 @@ void	process_recv(void *recv_buf, size_t data_len)
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): received HOSTIF_GET_INPUT_REPORT\n",
 				__func__);
-			g_ish_print_log(
-				"%s() received HOSTIF_GET_INPUT_REPORT\n"
-				, __func__);
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): dump Get Input Result\n",
 				__func__);
@@ -247,9 +239,6 @@ do_get_report:
 			ISH_DBG_PRINT(KERN_ALERT
 				"[hid-ish]: %s(): HOSTIF_SET_FEATURE_REPORT returned status=%02X\n",
 				__func__, recv_msg->hdr.status);
-			g_ish_print_log(
-				"%s() HOSTIF_SET_FEATURE_REPORT returned status=%02X\n"
-				, __func__, recv_msg->hdr.status);
 			ISH_DBG_PRINT(KERN_ALERT
 				"%s(): received feature report, upstreaming\n",
 				__func__);
@@ -260,9 +249,6 @@ do_get_report:
 
 		case HOSTIF_PUBLISH_INPUT_REPORT:
 			report_type = HID_INPUT_REPORT;
-			g_ish_print_log(
-				"%s() received ASYNC DATA REPORT\n"
-				, __func__, (unsigned)payload_len);
 			do {
 				ISH_DBG_PRINT(KERN_ALERT
 					"[hid-ish]: %s(): received ASYNC DATA REPORT [payload_len=%u]. Dump data:\n",
@@ -434,6 +420,7 @@ void hid_heci_get_report(struct hid_device *hid, int report_id, int report_type)
 		"[hid-ish]: %s(): heci_cl_send() returned %d\n", __func__, rv);
 }
 
+struct work_struct my_work;
 
 int	hid_heci_cl_probe(struct heci_cl_device *cl_device,
 	const struct heci_cl_device_id *id)
@@ -467,6 +454,12 @@ int	hid_heci_cl_probe(struct heci_cl_device *cl_device,
 	if (waitqueue_active(&init_wait))
 		wake_up(&init_wait);
 
+	schedule_work(&my_work);
+
+	ISH_DBG_PRINT(KERN_ALERT
+		"[ish client driver] %s() enqueue init_work function\n",
+		__func__);
+
 	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
 	return	0;
 
@@ -479,10 +472,20 @@ int	hid_heci_cl_probe(struct heci_cl_device *cl_device,
 
 int     hid_heci_cl_remove(struct heci_cl_device *dev)
 {
+	int i;
+
 	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
 	heci_hid_remove();
 	hid_heci_client_found = 0;
 	hid_heci_cl = NULL;
+
+	for (i = 0; i < num_hid_devices ; ++i) {
+		/* kfree(NULL) is safe */
+		kfree(hid_descr[i]);
+		/* kfree(NULL) is safe */
+		kfree(report_descr[i]);
+	}
+	num_hid_devices = 0;
 	ISH_DBG_PRINT(KERN_ALERT "%s(): ---\n", __func__);
 	return  0;
 }
@@ -497,7 +500,7 @@ struct heci_cl_driver	hid_heci_cl_driver = {
 
 /****************************************************************/
 
-struct work_struct my_work;
+
 
 
 void workqueue_init_function(struct work_struct *work)
@@ -571,11 +574,11 @@ void workqueue_init_function(struct work_struct *work)
 	rv = 0;
 
 	retry_count = 0;
-	printk(KERN_ALERT "[hid-ish]: going to send HOSTIF_DM_ENUM_DEVICES\n");
 	while (!enum_devices_done && retry_count < 10) {
 		wait_event_timeout(init_wait, enum_devices_done, 3 * HZ);
 		++retry_count;
-		printk(KERN_ALERT "[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
+		dev_err(&hid_heci_cl->device->dev,
+			"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
 			enum_devices_done, retry_count);
 		if (!enum_devices_done) {
 			/* Send HOSTIF_DM_ENUM_DEVICES */
@@ -585,16 +588,19 @@ void workqueue_init_function(struct work_struct *work)
 			rv = heci_cl_send(hid_heci_cl, buf, len);
 		}
 	}
-	printk(KERN_ALERT "[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
+	dev_err(&hid_heci_cl->device->dev,
+		"[hid-ish]: enum_devices_done = %d, retry_count = %d\n",
 		enum_devices_done, retry_count);
 
 	if (!enum_devices_done) {
-		printk(KERN_ERR "[ish client driver]: timed out waiting for enum_devices_done\n");
+		dev_err(&hid_heci_cl->device->dev,
+			"[hid-ish]: timed out waiting for enum_devices_done\n");
 		rv = -ETIMEDOUT;
 		goto	ret;
 	}
 	if (!hid_devices) {
-		printk(KERN_ERR "[ish client driver]: failed to allocate sensors devices structures\n");
+		dev_err(&hid_heci_cl->device->dev,
+			"[hid-ish]: failed to allocate HID dev structures\n");
 		rv = -ENOMEM;
 		goto	ret;
 	}
@@ -608,7 +614,8 @@ void workqueue_init_function(struct work_struct *work)
 	 */
 
 	num_hid_devices = hid_dev_count;
-	printk(KERN_ALERT "[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n",
+	dev_err(&hid_heci_cl->device->dev,
+		"[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n",
 		num_hid_devices);
 
 
@@ -668,18 +675,21 @@ void workqueue_init_function(struct work_struct *work)
 				30 * HZ);
 #endif
 		if (!report_descr_done) {
-			printk(KERN_ERR "[hid-ish]: timed out waiting for report_descr_done\n");
+			dev_err(&hid_heci_cl->device->dev,
+				"[hid-ish]: timed out wait for report descr\n");
 			continue;
 		}
 
 		if (!report_descr[i]) {
-			printk(KERN_ERR "[hid-ish]: failed to allocate report descriptor buffer\n");
+			dev_err(&hid_heci_cl->device->dev,
+				"[hid-ish]: failed to alloc report descr\n");
 			continue;
 		}
 
 		rv = heci_hid_probe(i);
 		if (rv) {
-			printk(KERN_ERR "[hid-ish]: HECI-HID probe for device #%u failed: %d\n",
+			dev_err(&hid_heci_cl->device->dev,
+				"[hid-ish]: HID probe for #%u failed: %d\n",
 				i, rv);
 			continue;
 		}
@@ -700,13 +710,15 @@ ret:
 static int __init ish_init(void)
 {
 	int	rv;
-	struct workqueue_struct *workqueue_for_init;
 
-	ISH_INFO_PRINT(KERN_ERR "[hid-ish]: %s():+++ [Build" BUILD_ID "]\n",
+	ISH_INFO_PRINT(KERN_ERR "[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
+		__func__);
+	g_ish_print_log(
+		"[hid-ish]: %s():+++ [Build " BUILD_ID "]\n",
 		__func__);
+
 	init_waitqueue_head(&init_wait);
 	init_waitqueue_head(&heci_hid_wait);
-
 	/* Register HECI client device driver - ISS */
 	rv = heci_cl_driver_register(&hid_heci_cl_driver);
 
@@ -715,18 +727,9 @@ static int __init ish_init(void)
 	 * needs to run in work queue and here we should return rv
 	 */
 	/****************************************************************/
-	workqueue_for_init = create_workqueue("workqueue_for_init");
-	if (!workqueue_for_init)
-		return -ENOMEM;
 	INIT_WORK(&my_work, workqueue_init_function);
-	queue_work(workqueue_for_init, &my_work);
-
-	ISH_DBG_PRINT(KERN_ALERT
-		"[ish client driver] %s() enqueue init_work function\n",
-		__func__);
-
+	/***************************************************************/
 	return rv;
-	/****************************************************************/
 
 }
 
diff --git a/drivers/misc/heci/heci-hid.c b/drivers/misc/heci/heci-hid.c
index 10d5ea2d3e9b..d692cb196bee 100644
--- a/drivers/misc/heci/heci-hid.c
+++ b/drivers/misc/heci/heci-hid.c
@@ -211,7 +211,7 @@ int	heci_hid_probe(unsigned cur_hid_dev)
 	rv = hid_add_device(hid);
 	if (rv) {
 		if (rv != -ENODEV)
-			printk(KERN_ERR "[hid-heci]: can't add HID device: %d\n",
+			hid_err(hid, "[hid-heci]: can't add HID device: %d\n",
 				rv);
 		kfree(hid);
 		return	rv;
diff --git a/drivers/misc/heci/heci_dev.h b/drivers/misc/heci/heci_dev.h
index 201d3dab0061..a2349d30b977 100644
--- a/drivers/misc/heci/heci_dev.h
+++ b/drivers/misc/heci/heci_dev.h
@@ -162,6 +162,7 @@ struct heci_device {
 	 * list of heci_cl's (formerly: files)
 	 */
 	struct list_head cl_list;
+	spinlock_t      cl_list_lock;
 	long open_handle_count;			/* Why's this?.. */
 
 	/*
@@ -228,15 +229,16 @@ struct heci_device {
 	spinlock_t	wr_msg_spinlock;
 */
 	struct hbm_version version;
-	struct heci_me_client *me_clients; /*Note: memory has to be allocated*/
+	struct heci_me_client *me_clients; /* Note: memory has to be allocated*/
 	DECLARE_BITMAP(me_clients_map, HECI_CLIENTS_MAX);
 	DECLARE_BITMAP(host_clients_map, HECI_CLIENTS_MAX);
 	u8 me_clients_num;
 	u8 me_client_presentation_num;
 	u8 me_client_index;
-
+	spinlock_t      me_clients_lock;
 	/* List of bus devices */
 	struct list_head device_list;
+	spinlock_t      device_list_lock;
 
 	/* buffer to save prints from driver */
 	unsigned char log_buffer[PRINT_BUFFER_SIZE];
diff --git a/drivers/misc/heci/hw-ish-regs.h b/drivers/misc/heci/hw-ish-regs.h
index 3d4515093691..e67fd444bb1b 100644
--- a/drivers/misc/heci/hw-ish-regs.h
+++ b/drivers/misc/heci/hw-ish-regs.h
@@ -163,6 +163,7 @@ ISS FW may not write to them */
 #define MNG_RX_CMPL_INDICATION          2
 #define MNG_RESET_NOTIFY		3
 #define MNG_RESET_NOTIFY_ACK		4
+#define MNG_SYNC_FW_CLOCK		5
 #define MNG_ILLEGAL_CMD			0xFF
 
 #endif /* _HECI_ISH_REGS_H_ */
diff --git a/drivers/misc/heci/hw-ish.c b/drivers/misc/heci/hw-ish.c
index e5354a9727a8..30fed051cde0 100644
--- a/drivers/misc/heci/hw-ish.c
+++ b/drivers/misc/heci/hw-ish.c
@@ -21,6 +21,7 @@
 #include "heci_dev.h"
 #include "hbm.h"
 #include <linux/spinlock.h>
+#include <linux/jiffies.h>
 
 #ifdef dev_dbg
 #undef dev_dbg
@@ -28,7 +29,7 @@
 static void no_dev_dbg(void *v, char *s, ...)
 {
 }
-/*#define dev_dbg dev_err */
+/*#define dev_dbg dev_err*/
 #define dev_dbg no_dev_dbg
 
 #include <linux/delay.h>
@@ -292,6 +293,20 @@ int write_ipc_from_queue(struct heci_device *dev)
 	doorbell_val = *(u32 *)ipc_link->inline_data;
 	r_buf = (u32 *)(ipc_link->inline_data + sizeof(u32));
 
+	/* If sending MNG_SYNC_FW_CLOCK, update clock again */
+	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG &&
+		IPC_HEADER_GET_MNG_CMD(doorbell_val) == MNG_SYNC_FW_CLOCK) {
+
+		struct timespec	ts;
+		uint64_t	usec;
+
+		get_monotonic_boottime(&ts);
+		usec = (uint64_t)ts.tv_sec * 1000000 +
+			(uint64_t)ts.tv_nsec / 1000;
+		r_buf[0] = (u32)(usec & 0xFFFFFFFF);
+		r_buf[1] = (u32)(usec >> 32);
+	}
+
 	for (i = 0, reg_addr = IPC_REG_HOST2ISH_MSG; i < length >> 2; i++,
 			reg_addr += 4)
 		ish_reg_write(dev, reg_addr, r_buf[i]);
@@ -335,12 +350,13 @@ int write_ipc_from_queue(struct heci_device *dev)
 	list_del_init(&ipc_link->link);
 	list_add_tail(&ipc_link->link, &dev->wr_free_list_head.link);
 	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
 	/*
 	 * callback will be called out of spinlock,
 	 * after ipc_link returned to free list
 	 */
-	if (ipc_link->ipc_send_compl)
-		ipc_link->ipc_send_compl(ipc_link->ipc_send_compl_prm);
+	if (ipc_send_compl)
+		ipc_send_compl(ipc_send_compl_prm);
 	ISH_DBG_PRINT(KERN_ALERT
 		"%s(): --- written %lu bytes [%08X ! %08X %08X %08X %08X...]\n",
 		__func__, length, *(u32 *)ipc_link->inline_data, r_buf[0],
@@ -353,7 +369,8 @@ int write_ipc_from_queue(struct heci_device *dev)
 static int	ish_fw_reset_handler(struct heci_device *dev)
 {
 	uint32_t	reset_id;
-
+	unsigned long	flags;
+	struct wr_msg_ctl_info *processing, *next;
 	/* Read reset ID */
 	reset_id = ish_reg_read(dev, IPC_REG_ISH2HOST_MSG) & 0xFFFF;
 
@@ -363,6 +380,20 @@ static int	ish_fw_reset_handler(struct heci_device *dev)
 	/* Clear HOST2ISH.ILUP (what's it?) */
 	/*ish_clr_host_rdy(dev);*/
 
+	/* Clear IPC output queue */
+	spin_lock_irqsave(&dev->wr_processing_spinlock, flags);
+	list_for_each_entry_safe(processing, next,
+			&dev->wr_processing_list_head.link, link) {
+		list_del(&processing->link);
+		list_add_tail(&processing->link, &dev->wr_free_list_head.link);
+	}
+	spin_unlock_irqrestore(&dev->wr_processing_spinlock, flags);
+
+	/* Clear BH processing queue - no further HBMs */
+	spin_lock_irqsave(&dev->rd_msg_spinlock, flags);
+	dev->rd_msg_fifo_head = dev->rd_msg_fifo_tail = 0;
+	spin_unlock_irqrestore(&dev->rd_msg_spinlock, flags);
+
 	/* Handle ISS FW reset against upper layers */
 	heci_bus_remove_all_clients(dev);	/* Remove all client devices */
 
@@ -408,11 +439,21 @@ struct heci_device	*heci_dev;
 static void	fw_reset_work_fn(struct work_struct *unused)
 {
 	int	rv;
+	static int reset_cnt;
 
 	ISH_DBG_PRINT(KERN_ALERT "%s(): +++\n", __func__);
+	reset_cnt++;
+
 	rv = ish_fw_reset_handler(heci_dev);
 	if (!rv) {
 		/* ISS is ILUP & HECI-ready. Restart HECI */
+	/* bug fix here: when reset flow occurs, sometimes, the sysfs entries
+		which were removed in ish_fw_reset_handler were still up,
+		but the driver tried to create the same entries and failed.
+		so wait some time here and then the sysfs entries removal will
+		be done */
+		if (reset_cnt != 0) /* not the boot flow */
+			schedule_timeout(HZ / 3);
 		heci_dev->recvd_hw_ready = 1;
 		if (waitqueue_active(&heci_dev->wait_hw_ready))
 			wake_up(&heci_dev->wait_hw_ready);
@@ -427,6 +468,23 @@ static void	fw_reset_work_fn(struct work_struct *unused)
 		printk(KERN_ERR "[heci-ish]: FW reset failed (%d)\n", rv);
 }
 
+
+static void	sync_fw_clock(struct heci_device *dev)
+{
+	static unsigned long	prev_sync;
+	struct timespec	ts;
+	uint64_t	usec;
+
+	if (prev_sync && jiffies - prev_sync < 120 * HZ)
+		return;
+
+	prev_sync = jiffies;
+	get_monotonic_boottime(&ts);
+	usec = (uint64_t)ts.tv_sec * 1000000 + (uint64_t)ts.tv_nsec / 1000;
+	ipc_send_mng_msg(dev, MNG_SYNC_FW_CLOCK, &usec, sizeof(uint64_t));
+}
+
+
 /*
  *	Receive and process IPC management messages
  *
@@ -477,8 +535,6 @@ static void	recv_ipc(struct heci_device *dev, uint32_t doorbell_val)
 }
 
 
-
-
 /**
  * ish_irq_handler - ISR of the HECI device
  *
@@ -532,7 +588,6 @@ irqreturn_t ish_irq_handler(int irq, void *dev_id)
 
 	/* IPC message */
 	if (IPC_HEADER_GET_PROTOCOL(doorbell_val) == IPC_PROTOCOL_MNG) {
-		g_ish_print_log("%s(): received IPC protocol msg\n", __func__);
 		recv_ipc(dev, doorbell_val);
 		goto	eoi;
 	}
@@ -545,6 +600,8 @@ irqreturn_t ish_irq_handler(int irq, void *dev_id)
 	if (!msg_hdr)
 		goto	eoi;
 
+	sync_fw_clock(dev);
+
 	heci_hdr = (struct heci_msg_hdr *)&msg_hdr;
 
 	/* Sanity check: HECI frag. length in header */
@@ -558,25 +615,21 @@ irqreturn_t ish_irq_handler(int irq, void *dev_id)
 
 	/* HECI bus message */
 	if (!heci_hdr->host_addr && !heci_hdr->me_addr) {
-		g_ish_print_log("%s(): received HBM\n", __func__);
 		recv_hbm(dev, heci_hdr);
 		goto	eoi;
 
 	/* HECI fixed-client message */
 	} else if (!heci_hdr->host_addr) {
-		g_ish_print_log("%s(): received HECI fixed client message\n",
-			__func__);
 		recv_fixed_cl_msg(dev, heci_hdr);
 		goto	eoi;
 	} else {
 		/* HECI client message */
-		g_ish_print_log(
-			"%s(): received HECI client message\n", __func__);
 		recv_heci_cl_msg(dev, heci_hdr);
 		goto	eoi;
 	}
 
 eoi:
+
 	ISH_DBG_PRINT(KERN_ALERT
 		"%s(): Doorbell cleared, busy reading cleared\n", __func__);
 	/* Update IPC counters */
@@ -829,6 +882,9 @@ struct heci_device *ish_dev_init(struct pci_dev *pdev)
 	spin_lock_init(&dev->out_ipc_spinlock);
 	spin_lock_init(&dev->read_list_spinlock);
 	spin_lock_init(&dev->device_lock);
+	spin_lock_init(&dev->device_list_lock);
+	spin_lock_init(&dev->cl_list_lock);
+	spin_lock_init(&dev->me_clients_lock);
 	INIT_WORK(&dev->bh_hbm_work, bh_hbm_work_fn);
 
 	dev->ops = &ish_hw_ops;
diff --git a/drivers/misc/heci/init.c b/drivers/misc/heci/init.c
index 282f47b88d05..bacee066c646 100644
--- a/drivers/misc/heci/init.c
+++ b/drivers/misc/heci/init.c
@@ -92,7 +92,7 @@ void heci_device_init(struct heci_device *dev)
 				 * IPC buffers may be limited or not available
 				 * at all - although this shouldn't happen
 				 */
-				printk(KERN_ERR "[heci-ish]: failure in Tx FIFO allocations (%d)\n",
+				dev_err(&dev->pdev->dev, "[heci-ish]: failure in Tx FIFO allocations (%d)\n",
 					i);
 				break;
 			}
@@ -141,7 +141,7 @@ int heci_start(struct heci_device *dev)
 #endif
 	/* DEBUGDEBUGDEBUG: Below code until 'reset_done:' is defunct */
 #else
-#endif /*FORCE_FW_INIT_RESET*/
+#endif
 	/* acknowledge interrupt and stop interupts */
 	dev_dbg(&dev->pdev->dev, "reset in start the heci device.\n");
 	heci_reset(dev, 1);
@@ -214,8 +214,6 @@ void heci_reset(struct heci_device *dev, int interrupts_enabled)
 		heci_cl_all_disconnect(dev);
 	}
 
-	dev->me_clients_num = 0;
-
 	if (unexpected)
 		dev_warn(&dev->pdev->dev, "unexpected reset: dev_state = %s\n",
 			 heci_dev_state_str(dev->dev_state));
diff --git a/drivers/misc/heci/pci-ish.c b/drivers/misc/heci/pci-ish.c
index 54cc7d705358..03fe37629783 100644
--- a/drivers/misc/heci/pci-ish.c
+++ b/drivers/misc/heci/pci-ish.c
@@ -58,7 +58,7 @@ static bool nomsi;
 module_param_named(nomsi, nomsi, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(nomsi, "don't use msi (default = false)");
 
-/* Currently this driver works as long as there is only a single AMT device. */
+/* Currently this driver works as long as there is only a single HECI device. */
 static struct pci_dev *heci_pci_device;
 
 static const struct pci_device_id ish_pci_tbl[] = {
@@ -148,8 +148,9 @@ static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
 	char    dbg_req_buf[768];
 	char    cmd[768];
 	int     rv;
-	int     addr, count, sscanf_match, i, cur_index;
-	volatile uint32_t *reg_data;
+	unsigned     addr, count;
+	int	sscanf_match, i, cur_index;
+	uint32_t __iomem *reg_data;
 
 	if (length > sizeof(dbg_req_buf))
 		length = sizeof(dbg_req_buf);
@@ -157,50 +158,49 @@ static ssize_t ishdbg_write(struct file *file, const char __user *ubuf,
 	if (rv)
 		return  -EINVAL;
 	if (sscanf(dbg_req_buf, "%s ", cmd) != 1) {
-		printk(KERN_ERR "[ish-dbg]) sscanf failed\n");
+		dev_err(&heci_pci_device->dev, "[ish-dbg]) sscanf failed\n");
 		return  -EINVAL;
 	}
-	sscanf_match = sscanf(dbg_req_buf + 2, "%x %d", &addr, &count);
+	sscanf_match = sscanf(dbg_req_buf + 2, "%x %u", &addr, &count);
 	if (!strcmp(cmd, "d")) {
 		/* Dump values: d <addr> [count] */
 		if (sscanf_match == 1)
 			count = 1;
 		else if (sscanf_match != 2) {
-			printk(KERN_ERR "[ish-dbg] sscanf failed, sscanf_match = %d\n",
+			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanf_match = %d\n",
 				sscanf_match);
 			return  -EINVAL;
 		}
-		if (addr < 0 /*|| addr > MAX_RANGE*/ ||
-				count < 0 /*|| count > MAX_RANGE*/)
-			return -EINVAL;
 		if (addr % 4) {
-			printk(KERN_ERR "[ish-dbg] address isn't aligned to 4 bytes\n");
+			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
 			return -EINVAL;
 		}
 		cur_index = 0;
 		for (i = 0; i < count; i++) {
-			reg_data = (volatile uint32_t *)
+			reg_data = (uint32_t __iomem *)
 				((char *)hw_dbg->mem_addr + addr + i*4);
-			cur_index += sprintf(dbg_resp_buf + cur_index, "%08X ",
-				*reg_data);
+			cur_index += scnprintf(dbg_resp_buf + cur_index,
+				sizeof(dbg_resp_buf) - cur_index, "%08X ",
+				readl(reg_data));
 		}
-		cur_index += sprintf(dbg_resp_buf + cur_index, "\n");
+		cur_index += scnprintf(dbg_resp_buf + cur_index,
+			sizeof(dbg_resp_buf) - cur_index, "\n");
 		resp_buf_read = 0;
 	} else if (!strcmp(cmd, "e")) {
 		/* Enter values e <addr> <value> */
 		if (sscanf_match != 2) {
-			printk(KERN_ERR "[ish-dbg] sscanf failed, sscanfMatch = %d\n",
+			dev_err(&heci_pci_device->dev, "[ish-dbg] sscanf failed, sscanfMatch = %d\n",
 				sscanf_match);
 			return  -EINVAL;
 		}
 		if (addr % 4) {
-			printk(KERN_ERR "[ish-dbg] address isn't aligned to 4 bytes\n");
+			dev_err(&heci_pci_device->dev, "[ish-dbg] address isn't aligned to 4 bytes\n");
 			return -EINVAL;
 		}
-		reg_data = (volatile uint32_t *)((char *)hw_dbg->mem_addr
+		reg_data = (uint32_t __iomem *)((char *)hw_dbg->mem_addr
 			+ addr);
-		*reg_data = count;
-		sprintf(dbg_resp_buf, "OK\n");
+		writel(count, reg_data);
+		scnprintf(dbg_resp_buf, sizeof(dbg_resp_buf), "OK\n");
 		resp_buf_read = 0;
 	}
 
@@ -265,7 +265,8 @@ static void ish_print_log(struct heci_device *dev, char *format, ...)
 		return;
 
 	do_gettimeofday(&tv);
-	i = sprintf(tmp_buf, "[%ld.%06ld] ", tv.tv_sec, tv.tv_usec);
+	i = scnprintf(tmp_buf, sizeof(tmp_buf), "[%ld.%06ld] ",
+		tv.tv_sec, tv.tv_usec);
 
 	va_start(args, format);
 	length = vsnprintf(tmp_buf + i, sizeof(tmp_buf)-i, format, args);
@@ -345,7 +346,7 @@ static ssize_t ish_read_log(struct heci_device *dev, char *buf, size_t size)
 {
 	int i, full_space, ret_val;
 
-	if (dev->log_head == dev->log_tail)/* log is empty */
+	if (dev->log_head == dev->log_tail) /* log is empty */
 		return 0;
 
 	/* read size the minimum between full_space and the buffer size */
@@ -526,7 +527,8 @@ ssize_t show_heci_dev_props(struct device *dev,
 				"------------\n");
 		spin_lock_irqsave(&heci_dev->device_lock, flags);
 		list_for_each_entry_safe(cl, next, &heci_dev->cl_list, link) {
-			sprintf(buf + strlen(buf), "id: %d\n",
+			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
+				"id: %d\n",
 				cl->host_client_id);
 			scnprintf(buf + strlen(buf), PAGE_SIZE - strlen(buf),
 				"state: %s\n", cl->state < 0 || cl->state >
@@ -568,7 +570,6 @@ ssize_t show_heci_dev_props(struct device *dev,
 					"RX free: %u\n", count);
 
 				count = 0;
-
 				spin_lock_irqsave(&cl->tx_list_spinlock,
 					tx_flags);
 				list_for_each_entry_safe(tx_rb, next_tx_rb,
@@ -679,7 +680,7 @@ static unsigned	num_force_hid_fc;
 ssize_t show_force_hid_fc(struct device *dev, struct device_attribute *dev_attr,
 	char *buf)
 {
-	sprintf(buf, "%u\n", num_force_hid_fc);
+	scnprintf(buf, PAGE_SIZE, "%u\n", num_force_hid_fc);
 	return	 strlen(buf);
 }
 
@@ -787,6 +788,8 @@ struct my_work_t {
 	struct heci_device *dev;
 };
 
+struct my_work_t *work;
+
 void workqueue_init_function(struct work_struct *work)
 {
 	struct heci_device *dev = ((struct my_work_t *)work)->dev;
@@ -817,7 +820,8 @@ void workqueue_init_function(struct work_struct *work)
 
 	spin_lock_init(&dev->log_spinlock);
 
-	dev->print_log(dev, "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
+	dev->print_log(dev,
+		"[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
 		__func__);
 	dev->print_log(dev, "[heci-ish] %s() running on %s revision [%02X]\n",
 		__func__,
@@ -879,9 +883,9 @@ static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct ish_hw *hw;
 	int err;
 	int	rv;
-	struct my_work_t *work;
 
-	ISH_INFO_PRINT(KERN_ERR "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
+	ISH_INFO_PRINT(
+	KERN_ERR "[heci-ish]: %s():+++ [Build "BUILD_ID "]\n",
 		__func__);
 	ISH_INFO_PRINT(KERN_ERR
 		"[heci-ish] %s() running on %s revision [%02X]\n", __func__,
@@ -1006,8 +1010,10 @@ static int ish_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		return -ENOMEM;
 	work->dev = dev;
 	workqueue_for_init = create_workqueue("workqueue_for_init");
-	if (!workqueue_for_init)
+	if (!workqueue_for_init) {
+		kfree(work);
 		return -ENOMEM;
+	}
 	INIT_WORK(&work->my_work, workqueue_init_function);
 	queue_work(workqueue_for_init, &work->my_work);
 
@@ -1048,6 +1054,7 @@ static void ish_remove(struct pci_dev *pdev)
 	 *** If this case of removal is viable,
 	 * also go through HECI clients removal ***
 	 */
+	kfree(work);
 
 	if (heci_pci_device != pdev) {
 		dev_err(&pdev->dev, "heci: heci_pci_device != pdev\n");
diff --git a/drivers/misc/heci/platform-config.h b/drivers/misc/heci/platform-config.h
index 02096118911e..140601758fe1 100644
--- a/drivers/misc/heci/platform-config.h
+++ b/drivers/misc/heci/platform-config.h
@@ -17,7 +17,7 @@
 #define PLATFORM_CONFIG__H
 
 /* Build ID string */
-#define	BUILD_ID	"gmin-0001"
+#define	BUILD_ID	"0174-imin-reset-flow-private-prop"
 
 #define	ISH_DEBUG	0
 #if ISH_DEBUG
@@ -106,14 +106,14 @@ static void	do_mutex_unlock(void *m)
 
 #define mutex_lock(a) \
 	do {\
-		printk(KERN_ALERT "%s:%d[%s] -- mutex_lock(%p)\n",	\
+		dev_warn(NULL, "%s:%d[%s] -- mutex_lock(%p)\n",	\
 			__FILE__, __LINE__, __func__, a);	\
 		do_mutex_lock(a);	\
 	} while (0)
 
 #define mutex_unlock(a) \
 	do {\
-		printk(KERN_ALERT "%s:%d[%s] -- mutex_unlock(%p)\n",	\
+		dev_warn(NULL, "%s:%d[%s] -- mutex_unlock(%p)\n",	\
 			__FILE__, __LINE__, __func__, a);	\
 		do_mutex_unlock(a);	\
 	} while (0)
diff --git a/drivers/misc/heci/senscol-core.c b/drivers/misc/heci/senscol-core.c
index 70378b07925f..8d20977b9664 100644
--- a/drivers/misc/heci/senscol-core.c
+++ b/drivers/misc/heci/senscol-core.c
@@ -34,7 +34,7 @@ spinlock_t	senscol_data_lock;
 uint8_t	*senscol_data_buf;
 unsigned	senscol_data_head, senscol_data_tail;
 int	flush_asked = 0;
-
+struct task_struct *user_task;
 
 static ssize_t	sc_data_show(struct kobject *kobj, struct attribute *attr,
 	char *buf);
@@ -58,6 +58,31 @@ static struct platform_device	*sc_pdev;
 
 wait_queue_head_t senscol_read_wait;
 
+void senscol_send_ready_event(void)
+{
+	if (waitqueue_active(&senscol_read_wait))
+		wake_up_interruptible(&senscol_read_wait);
+}
+EXPORT_SYMBOL(senscol_send_ready_event);
+
+int senscol_reset_notify(void)
+{
+
+	struct siginfo si;
+	int ret;
+
+	memset(&si, 0, sizeof(struct siginfo));
+	si.si_signo = SIGUSR1;
+	si.si_code = SI_USER;
+
+	if (user_task == NULL)
+		return -EINVAL;
+
+	ret = send_sig_info(SIGUSR1, &si, user_task);
+	return ret;
+}
+EXPORT_SYMBOL(senscol_reset_notify);
+
 const char *senscol_usage_to_name(unsigned usage)
 {
 	int i;
@@ -183,12 +208,18 @@ static struct attribute sc_sensdef_defattr_flush = {
 	.mode = (S_IRUGO)
 };
 
+static struct attribute sc_sensdef_defattr_get_sample = {
+	.name = "get_sample",
+	.mode = (S_IRUGO)
+};
+
 struct attribute	*sc_sensdef_defattrs[] = {
 	&sc_sensdef_defattr_name,
 	&sc_sensdef_defattr_id,
 	&sc_sensdef_defattr_usage_id,
 	&sc_sensdef_defattr_sample_size,
 	&sc_sensdef_defattr_flush,
+	&sc_sensdef_defattr_get_sample,
 	NULL
 };
 
@@ -236,6 +267,13 @@ static ssize_t	sc_sensdef_show(struct kobject *kobj, struct attribute *attr,
 			push_sample(pseudo_event_id, &pseudo_event_content);
 			scnprintf(buf, PAGE_SIZE, "0\n");
 		}
+	else if (!strcmp(attr->name, "get_sample")) {
+		rv = sensdef->impl->get_sample(sensdef);
+		/* The sample will arrive to hid "raw event" func,
+		and will be pushed to user via "push_sample" method */
+
+		scnprintf(buf, PAGE_SIZE, "%d\n", !rv);
+	}
 	rv = strlen(buf) + 1;
 	return	rv;
 }
@@ -406,9 +444,15 @@ static struct attribute sc_sensprop_defattr_value = {
 	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
 };
 
+static struct attribute sc_sensprop_defattr_usage_id = {
+	.name = "usage_id",
+	.mode = (S_IRUGO | S_IWUSR | S_IWGRP)
+};
+
 struct attribute	*sc_sensprop_defattrs[] = {
 /*	&sc_sensprop_defattr_unit,*/
 	&sc_sensprop_defattr_value,
+	&sc_sensprop_defattr_usage_id,
 	NULL
 };
 
@@ -422,7 +466,7 @@ static ssize_t	sc_sensprop_show(struct kobject *kobj, struct attribute *attr,
 {
 	struct sens_property	*pfield;
 	struct sensor_def	*sensor;
-	int	rv;
+	int	rv = -EINVAL;
 
 	/*
 	 * We need "property_power_state" (=2), "property_reporting_state" (=2)
@@ -433,7 +477,11 @@ static ssize_t	sc_sensprop_show(struct kobject *kobj, struct attribute *attr,
 	pfield = container_of(kobj, struct sens_property, kobj);
 	sensor = pfield->sensor;
 
-	rv = sensor->impl->get_sens_property(sensor, pfield, buf, 0x1000);
+	if (!strcmp(attr->name, "value"))
+		rv = sensor->impl->get_sens_property(sensor, pfield, buf,
+			0x1000);
+	else if (!strcmp(attr->name, "usage_id"))
+		scnprintf(buf, PAGE_SIZE, "%08X\n", pfield->usage_id & 0xFFFF);
 	if (rv)
 		return	rv;
 	return	strlen(buf);
@@ -453,6 +501,9 @@ static ssize_t	sc_sensprop_store(struct kobject *kobj, struct attribute *attr,
 	ISH_DBG_PRINT(KERN_ALERT
 		"[senscol]: %s(): +++ attr='%s' buf='%s' size=%u\n",
 		__func__, attr->name, buf, (unsigned)size);
+	if (strcmp(attr->name, "value"))
+		return -EINVAL;
+
 	pfield = container_of(kobj, struct sens_property, kobj);
 	sensor = pfield->sensor;
 	rv = sensor->impl->set_sens_property(sensor, pfield, buf);
@@ -580,6 +631,49 @@ void	init_senscol_sensor(struct sensor_def *sensor)
 }
 EXPORT_SYMBOL(init_senscol_sensor);
 
+int remove_senscol_sensor(uint32_t id)
+{
+	unsigned long	flags;
+	struct sensor_def	*sens, *next;
+	int i;
+
+	spin_lock_irqsave(&senscol_lock, flags);
+	list_for_each_entry_safe(sens, next, &senscol_sensors_list, link) {
+		if (sens->id == id) {
+			list_del(&sens->link);
+			spin_unlock_irqrestore(&senscol_lock, flags);
+
+			for (i = 0; i < sens->num_properties; ++i)
+				if (sens->properties[i].name) {
+					kobject_put(&sens->properties[i].kobj);
+					kobject_del(&sens->properties[i].kobj);
+				}
+			kfree(sens->properties);
+			kobject_put(&sens->props_kobj);
+			kobject_del(&sens->props_kobj);
+
+			for (i = 0; i < sens->num_data_fields; ++i)
+				if (sens->data_fields[i].name) {
+					kobject_put(&sens->data_fields[i].kobj);
+					kobject_del(&sens->data_fields[i].kobj);
+				}
+			kfree(sens->data_fields);
+			kobject_put(&sens->data_fields_kobj);
+			kobject_del(&sens->data_fields_kobj);
+			kobject_put(&sens->kobj);
+			kobject_del(&sens->kobj);
+
+			kfree(sens);
+
+			return 0;
+		}
+	}
+	spin_unlock_irqrestore(&senscol_lock, flags);
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL(remove_senscol_sensor);
+
 /*
  * Exposed sensor via sysfs, structure may be static
  *
@@ -868,25 +962,7 @@ int	push_sample(uint32_t id, void *sample)
 	p_sample->size = sensor->sample_size;
 	memcpy(p_sample->data, sample,
 		sensor->sample_size - offsetof(struct senscol_sample, data));
-#if 0
-	ISH_DBG_PRINT(KERN_ALERT "%s(): pushing to buffer,
-		sample_size=%u[%u]\n", __func__,
-		sensor->sample_size, p_sample->size);
-
-	/***** DEBUG - dump sample ******/
-	do {
-		int	i;
-		char	buf[4096];
-
-		sprintf(buf,  "%s(): sample dump [id=%u size=%u] -- ",
-			__func__, p_sample->id, p_sample->size);
-		for (i = 0; i < p_sample->size; ++i)
-			sprintf(buf + strlen(buf),  "%02X ",
-				(unsigned)p_sample->data[i]);
-		ISH_DBG_PRINT(KERN_ALERT "%s\n", buf);
-	} while (0);
-	/********************************/
-#endif
+
 	memcpy(senscol_data_buf + senscol_data_tail, p_sample, p_sample->size);
 	senscol_data_tail += sensor->sample_size;
 	if (senscol_data_tail > SENSCOL_DATA_BUF_LAST)
@@ -911,6 +987,7 @@ EXPORT_SYMBOL(push_sample);
 
 static int senscol_open(struct inode *inode, struct file *file)
 {
+	user_task = current;
 	return	0;
 }
 
diff --git a/include/linux/senscol/senscol-core.h b/include/linux/senscol/senscol-core.h
index b0acb3ba821c..875cf671e2c7 100644
--- a/include/linux/senscol/senscol-core.h
+++ b/include/linux/senscol/senscol-core.h
@@ -147,8 +147,7 @@ struct senscol_impl {
 		const struct sens_property *prop, const char *value);
 
 	/* Get sample */
-	int	(*get_sample)(struct sensor_def *sensor, void *sample_buf,
-		size_t sample_buf_size);
+	int	(*get_sample)(struct sensor_def *sensor);
 
 	/* Check if sensor is activated in batch mode */
 	int	(*batch_check)(struct sensor_def *sensor);
@@ -158,6 +157,9 @@ struct senscol_impl {
 
 int	add_senscol_impl(struct senscol_impl *impl);
 int	remove_senscol_impl(struct senscol_impl *impl);
+int	remove_senscol_sensor(uint32_t id);
+void	senscol_send_ready_event(void);
+int	senscol_reset_notify(void);
 
 /*DEBUG*/
 void g_ish_print_log(char *format, ...);
-- 
1.9.1

